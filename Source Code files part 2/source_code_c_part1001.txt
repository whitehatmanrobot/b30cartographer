tyCols[1],
        m_cxPropertyCols[2],
        m_cxSingleCol);

    theApp.WriteProfileString(_T("Settings"), _T("ColWidths"), strCols);

    RemoveColumns();
}

void CObjView::DoPopupMenu(UINT nMenuID)
{
    CMenu popMenu;

    popMenu.LoadMenu(nMenuID);
	
    CPoint posMouse;
    GetCursorPos(&posMouse);

    CWnd* pWndPopupOwner = this;
    while (pWndPopupOwner->GetStyle() & WS_CHILD)
        pWndPopupOwner = pWndPopupOwner->GetParent();
 
	popMenu.GetSubMenu(0)->TrackPopupMenu(0,posMouse.x,posMouse.y,pWndPopupOwner);
}

CObjInfo *CObjView::GetCurrentObj()
{
    CObjInfo *pInfo = NULL;

    if (m_iColHint == HINT_OP_SEL)
    {
        HTREEITEM hitem = GetSelectedItem();

        if (hitem)
            pInfo = (CObjInfo*) GetDocument()->m_pOpView->m_pTree->
                        GetItemData(hitem);
    }

    return pInfo;
}

void CObjView::OnDelete() 
{
	int iItem = GetSelectedItemIndex();

	if (iItem == -1)
        return;

    // Object selected?
    if (m_pWrap != NULL)
    {
        HTREEITEM hItem = (HTREEITEM) m_pList->GetItemData(iItem);

        if (hItem)
            GetDocument()->m_pOpView->RemoveItemFromTree(hItem, FALSE);
    }
    // Property selected
    else
    {
        CString  strProperty;
        CObjInfo *pObj = GetDocument()->m_pOpView->GetCurrentObj();

        if (pObj)
        {
            HRESULT hr;

            strProperty = m_pList->GetItemText(iItem, 0);

            hr = pObj->m_pObj->Delete(_bstr_t(strProperty));

            if (SUCCEEDED(hr))
            {
                pObj->SetModified(TRUE);
                GetDocument()->m_pOpView->UpdateCurrentObject(TRUE);
            }
            else
                CWMITestDoc::DisplayWMIErrorBox(hr);
        }
	}
}

void CObjView::OnRclick(NMHDR* pNMHDR, LRESULT* pResult) 
{
	CPoint curPoint;
	
	GetCursorPos(&curPoint);
	ScreenToClient(&curPoint);

	int iItem = m_pList->HitTest(curPoint);

	// Object selected?
    if (m_pWrap != NULL)
    {
        if (iItem != -1)
	    {
            HTREEITEM hItem = (HTREEITEM) m_pList->GetItemData(iItem);

            if (hItem)
                GetDocument()->m_pOpView->DoContextMenuForItem(hItem);
	    }
    }
    // Property selected
    else
    {
        CString strTemp;

        if (iItem == -1)
            GetDocument()->m_pOpView->DoPopupMenu(IDR_NEW_PROP);
        else
        {
            if (GetSelectedObjPath(strTemp))
                GetDocument()->m_pOpView->DoPopupMenu(IDR_PROP_AND_INST);
            else
                GetDocument()->m_pOpView->DoPopupMenu(IDR_PROP);
        }
	}

	*pResult = 0;
}

int CObjView::GetSelectedItemIndex()
{
    POSITION  pos = m_pList->GetFirstSelectedItemPosition();

    if (pos)
        return m_pList->GetNextSelectedItem(pos);
    else
        return -1;
}

HTREEITEM CObjView::GetSelectedItem()
{
    int iItem = GetSelectedItemIndex();

    if (iItem != -1 && m_iColHint == HINT_OP_SEL)
        return (HTREEITEM) m_pList->GetItemData(iItem);
    else
        return NULL;
}

BOOL CObjView::GetSelectedObjPath(CString &strPath)
{
    BOOL     bRet = FALSE;
    CObjInfo *pInfo = GetCurrentObj();

    if (pInfo)
    {
        strPath = pInfo->GetStringPropValue(L"__RELPATH");
        bRet = TRUE;
    }
    else
    {
        int iItem = GetSelectedItemIndex();
        
        if (iItem != -1)
        {
            pInfo = GetDocument()->m_pOpView->GetCurrentObj();

            if (pInfo && pInfo->GetProps()->GetData()[iItem].m_type == CIM_REFERENCE)
            {
                CString strItem = pInfo->GetStringPropValue(iItem);

                // Assume we need an equal sign for this to be an object path.
                if (strItem.Find('=') != -1)
                {
                    strPath = strItem;
                    bRet = TRUE;
                }
            }
        }
    }

    return bRet;
}

BOOL CObjView::GetSelectedClass(CString &strClass)
{
    BOOL     bRet = FALSE;
    CObjInfo *pInfo = GetCurrentObj();

    if (pInfo)
    {
        strClass = pInfo->GetStringPropValue(L"__CLASS");
        bRet = TRUE;
    }
    else
    {
        int iItem = GetSelectedItemIndex();
        
        if (iItem != -1)
        {
            pInfo = GetDocument()->m_pOpView->GetCurrentObj();

            if (pInfo && pInfo->GetProps()->GetData()[iItem].m_type == CIM_REFERENCE)
            {
                CString strItem = pInfo->GetStringPropValue(iItem);

                if (!strItem.IsEmpty())
                {
                    int iWhere = strItem.Find(':');

                    if (iWhere != -1)
                        strItem = strItem.Mid(iWhere + 1);

                    iWhere = strItem.Find('.');

                    if (iWhere != -1)
                        strItem = strItem.Left(iWhere);

                    strClass = strItem;

                    bRet = TRUE;
                }
            }
        }
    }

    return bRet;
}

void CObjView::OnDblclk(NMHDR* pNMHDR, LRESULT* pResult) 
{
    EditCurrentSelection();

    *pResult = 0;
}

BOOL CObjView::EditProperty(CObjInfo *pObj, CPropInfo *pProp, VARIANT *pVar)
{
    CString strTitle;

    strTitle.Format(IDS_EDIT_PROPERTY, pProp->m_strName);

    CPropertySheet sheet(strTitle);
    CValuePg       pgValue;
    CPropQualsPg   pgQuals;
    BOOL           bRet = FALSE;

    pgValue.m_propUtil.m_prop = *pProp;
    pgValue.m_propUtil.m_pVar = pVar;
    pgValue.m_propUtil.m_bTranslate = theApp.m_bTranslateValues;
    pgValue.m_propUtil.m_pNamespace = g_pOpView->GetDocument()->m_pNamespace;

    pgQuals.m_pObj = pObj->m_pObj;
    pgQuals.m_propInfo = *pProp;
    pgQuals.m_mode = CPropQualsPg::QMODE_PROP;
    pgQuals.m_bIsInstance = pObj->IsInstance();

    sheet.AddPage(&pgValue);
    sheet.AddPage(&pgQuals);

    if (sheet.DoModal() == IDOK)
    {
        // TODO: Save this property, indicate the object has changed.
        HRESULT hr;

        hr = pObj->m_pObj->Put(
                _bstr_t(pProp->m_strName),
                0,
                pVar,
                0);

        if (SUCCEEDED(hr))
            bRet = TRUE;
        else
            CWMITestDoc::DisplayWMIErrorBox(hr);
    }

    return bRet;
}

void CObjView::EditCurrentSelection()
{
    // Property selected?
    if (InPropertyMode())
    {
	    CObjInfo   *pObj = NULL;
        CPropInfo  *pProp = NULL;
        _variant_t var;

        if (GetCurrentProperty(&pObj, &pProp, &var))
        {
            int iItem = GetSelectedItemIndex();
        
            if (EditProperty(pObj, pProp, &var))
            {
                pObj->SetModified(TRUE);
                GetDocument()->m_pOpView->UpdateCurrentObject(TRUE);

                if (iItem != -1)
                {
                    m_pList->EnsureVisible(iItem, FALSE);
                    m_pList->SetItemState(iItem, LVIS_SELECTED, LVIS_SELECTED);
                }
            }
        }

        // Otherwise the destructor freaks out because it doesn't know what to 
        // do with VT_I8.
        if (var.vt == VT_I8)
            var.vt = VT_I4;
    }
    else
    // In object mode
    {
        CObjInfo *pObj = GetCurrentObj();

        if (pObj)
        {
            GetDocument()->m_pOpView->EditObj(pObj);

/* Bring this back once we make the 1st column be __RELPATH.

            LVFINDINFO find;
            int        iItem;
            CString    strItem = pObj->GetObjText();

            find.flags = LVFI_STRING;
            find.psz = strItem;

            iItem = m_pList->FindItem(&find);

            if (iItem != -1)
            {
                m_pList->EnsureVisible(iItem, FALSE);
                m_pList->SetItemState(iItem, LVIS_SELECTED, LVIS_SELECTED);
            }
*/
        }
    }
}

BOOL CObjView::GetCurrentProperty(CObjInfo **ppObj, CPropInfo **ppProp, VARIANT *pVar)
{
	BOOL bRet = FALSE;

    // Property selected?
    if (InPropertyMode())
    {
        int iItem = GetSelectedItemIndex();
        
        if (iItem != -1)
        {
           // Translate the selected index to the property index.
           iItem = m_pList->GetItemData(iItem);

           *ppObj = GetDocument()->m_pOpView->GetCurrentObj();
           
           *ppProp = &(*ppObj)->GetProps()->GetData()[iItem];
           (*ppObj)->ValueToVariant(iItem, pVar);

           bRet = TRUE;
        }
    }

    return bRet;
}

void CObjView::OnModify() 
{
    EditCurrentSelection();
}

void CObjView::OnUpdateModify(CCmdUI* pCmdUI) 
{
    pCmdUI->Enable(GetSelectedItemIndex() != -1);
}

void CObjView::OnNewProp() 
{
    // Property selected?
    if (InPropertyMode())
    {
        CObjInfo *pObj = GetDocument()->m_pOpView->GetCurrentObj();
        CString  strProperty;

        if (AddProperty(pObj, strProperty))
        {
            pObj->SetModified(TRUE);
            GetDocument()->m_pOpView->UpdateCurrentObject(TRUE);

            LVFINDINFO find;
            int        iItem;

            find.flags = LVFI_STRING;
            find.psz = strProperty;

            iItem = m_pList->FindItem(&find);

            if (iItem != -1)
            {
                m_pList->EnsureVisible(iItem, FALSE);
                m_pList->SetItemState(iItem, LVIS_SELECTED, LVIS_SELECTED);
            }
        }
    }
}

BOOL CObjView::AddProperty(CObjInfo *pObj, CString &strName)
{
    CPropertySheet sheet(IDS_NEW_PROPERTY);
    CValuePg       pg;
    _variant_t     var;
    BOOL           bRet = FALSE;

    var.vt = VT_NULL;
    pg.m_propUtil.m_pVar = &var;
    pg.m_propUtil.m_bTranslate = theApp.m_bTranslateValues;
    pg.m_propUtil.m_bNewProperty = TRUE;
    pg.m_propUtil.m_pNamespace = g_pOpView->GetDocument()->m_pNamespace;

    sheet.AddPage(&pg);

    if (sheet.DoModal() == IDOK)
    {
        HRESULT hr;

        hr = pObj->m_pObj->Put(
                _bstr_t(pg.m_propUtil.m_prop.m_strName),
                0,
                &var,
                pg.m_propUtil.m_prop.m_type);

        if (SUCCEEDED(hr))
        {
            bRet = TRUE;
            strName = pg.m_propUtil.m_prop.m_strName;
        }
        else
            CWMITestDoc::DisplayWMIErrorBox(hr);
    }

    return bRet;
}

void CObjView::OnUpdateNewProp(CCmdUI* pCmdUI) 
{
    BOOL bEnable = FALSE;

    if (InPropertyMode())
    {
        CObjInfo *pObj = GetDocument()->m_pOpView->GetCurrentObj();

        if (pObj && !pObj->IsInstance())
            bEnable = TRUE;
    }

    pCmdUI->Enable(bEnable);
}


BOOL CObjView::CanCopy()
{
    return GetSelectedItemIndex() != -1;
}

void CObjView::OnUpdateEditCopy(CCmdUI* pCmdUI) 
{
	pCmdUI->Enable(CanCopy());
}

void CObjView::OnEditCopy() 
{
    if (InPropertyMode())
    {
        POSITION pos = m_pList->GetFirstSelectedItemPosition();
        CString  strFinal;

        while (pos)
        {
            int iIndex = m_pList->GetNextSelectedItem(pos);
            
            if (!strFinal.IsEmpty())
                strFinal += "\r\n";

            strFinal += m_pList->GetItemText(iIndex, 2);
        }

        // Set the ANSI text data.
        DWORD   dwSize = strFinal.GetLength() + 1;
        HGLOBAL hglob = GlobalAlloc(GMEM_MOVEABLE | GMEM_DDESHARE, dwSize);

        memcpy(GlobalLock(hglob), (LPCTSTR) strFinal, dwSize);
        GlobalUnlock(hglob);

        ::OpenClipboard(NULL);

        SetClipboardData(CF_TEXT, hglob);


        // Set the Unicode text data.
        _bstr_t strUnicode = strFinal;
        
        dwSize *= 2;
        hglob = GlobalAlloc(GMEM_MOVEABLE | GMEM_DDESHARE, dwSize);
        memcpy(GlobalLock(hglob), (LPCWSTR) strUnicode, dwSize);
        GlobalUnlock(hglob);
        SetClipboardData(CF_UNICODETEXT, hglob);

        CloseClipboard();
    }
    else
    {
        COpList list;

        BuildSelectedOpList(list);

        GetDocument()->m_pOpView->DoCopy(list);
    }
}

void CObjView::BuildSelectedOpList(COpList &list)
{
    POSITION  pos = m_pList->GetFirstSelectedItemPosition();
	CTreeCtrl *pTree = GetDocument()->m_pOpView->m_pTree;

    list.RemoveAll();

    while (pos)
    {
        int       iIndex = m_pList->GetNextSelectedItem(pos);
        HTREEITEM hitem = (HTREEITEM) m_pList->GetItemData(iIndex);
        CObjInfo  *pObj = GetDocument()->m_pOpView->GetObjInfo(hitem);
        CString   strRelpath = pObj->GetStringPropValue(L"__RELPATH");

        if (!strRelpath.IsEmpty())
        {
            BOOL    bIsClass = strRelpath.Find('=') == -1;
            COpWrap wrap(bIsClass ? WMI_GET_CLASS : WMI_GET_OBJ, strRelpath);

            list.AddTail(wrap);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\wmitest\objvw.h ===
/*++

Copyright (C) 1997-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/

// ObjVw.h : interface of the CObjView class
//
/////////////////////////////////////////////////////////////////////////////

#if !defined(AFX_OBJVW_H__4419F1AC_692B_11D3_BD30_0080C8E60955__INCLUDED_)
#define AFX_OBJVW_H__4419F1AC_692B_11D3_BD30_0080C8E60955__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define HINT_NEW_CHILD 100
#define HINT_NEW_OP    101
#define HINT_OP_SEL    102
#define HINT_OBJ_SEL   103
#define HINT_ROOT_SEL  104

#include "OpWrap.h"

class CObjView : public CListView
{
protected: // create from serialization only
	CObjView();
	DECLARE_DYNCREATE(CObjView)

// Attributes
public:
	CWMITestDoc *GetDocument();
    CListCtrl *m_pList;

// Operations
public:
    void Flush();

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_ VIRTUAL(CObjView)
	public:

	virtual BOOL PreCreateWindow(CREATESTRUCT& cs);
	protected:
	virtual void OnInitialUpdate(); // called first time after construct
	virtual void OnUpdate(CView* pSender, LPARAM lHint, CObject* pHint);
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CObjView();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

    HTREEITEM GetSelectedItem();
    int GetSelectedItemIndex();
    BOOL GetSelectedObjPath(CString &strPath);
    BOOL GetSelectedClass(CString &strClass);
    CObjInfo *GetCurrentObj();
    void SaveColumns();
    BOOL GetCurrentProperty(CObjInfo **ppInfo, CPropInfo **ppProp, 
        VARIANT *pVar);
    void EditCurrentSelection();

    static BOOL EditProperty(CObjInfo *pObj, CPropInfo *pProp, VARIANT *pVar);
    static BOOL AddProperty(CObjInfo *pObj, CString &strName);

protected:
    HTREEITEM m_hitemLastChildUpdate,
              m_hitemLastParentUpdate;
    COpWrap   *m_pWrap;
    int       m_nCols,
              m_iItemImage,
              m_iColHint;
    CIntArray m_piDisplayCols;
    int       m_cxPropertyCols[3],
              m_cxSingleCol;

    void RemoveColumns();
    void AddColumns(HTREEITEM hItem = NULL);
    void AddObjValues(HTREEITEM hItem);
    void AddObjValues(CObjInfo *pInfo);
    void AddChildItems(HTREEITEM hItem);
    void DoPopupMenu(UINT nMenuID);
    BOOL InPropertyMode() { return m_pWrap == NULL; }
    BOOL CanCopy();
    void BuildSelectedOpList(COpList &list);

// Generated message map functions
protected:
	//{{AFX_MSG(CObjView)
	afx_msg void OnSize(UINT nType, int cx, int cy);
	afx_msg void OnGetDispInfo(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnRclick(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnDblclk(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnModify();
	afx_msg void OnUpdateModify(CCmdUI* pCmdUI);
	afx_msg void OnNewProp();
	afx_msg void OnUpdateNewProp(CCmdUI* pCmdUI);
	afx_msg void OnDelete();
	afx_msg void OnProperties();
	afx_msg void OnUpdateProperties(CCmdUI* pCmdUI);
	afx_msg void OnEditCopy();
	afx_msg void OnUpdateEditCopy(CCmdUI* pCmdUI);
	//}}AFX_MSG
	afx_msg void OnStyleChanged(int nStyleType, LPSTYLESTRUCT lpStyleStruct);
	DECLARE_MESSAGE_MAP()
};

#ifndef _DEBUG  // debug version in ObjVw.cpp
inline CWMITestDoc* CObjView::GetDocument()
   { return (CWMITestDoc*)m_pDocument; }
#endif

/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_OBJVW_H__4419F1AC_692B_11D3_BD30_0080C8E60955__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\wmitest\opview.cpp ===
/*++

Copyright (C) 1997-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/

// OpView.cpp : implementation of the COpView class
//

#include "stdafx.h"
#include "WMITest.h"

#include "MainFrm.h"
#include "WMITestDoc.h"
#include "OpView.h"
#include "ObjVw.h"
#include "DelDlg.h"
#include "PropsPg.H"
#include "PropQualsPg.h"
#include "MethodsPg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// COpView

IMPLEMENT_DYNCREATE(COpView, CTreeView)

BEGIN_MESSAGE_MAP(COpView, CTreeView)
    //{{AFX_MSG_MAP(COpView)
    ON_WM_SIZE()
    ON_NOTIFY_REFLECT(NM_DBLCLK, OnDblclk)
    ON_NOTIFY_REFLECT(TVN_SELCHANGED, OnSelChanged)
    ON_NOTIFY_REFLECT(NM_RCLICK, OnRclick)
    ON_COMMAND(ID_DELETE, OnDelete)
    ON_UPDATE_COMMAND_UI(ID_DELETE, OnUpdateDelete)
    ON_COMMAND(ID_MODIFY, OnModify)
    ON_UPDATE_COMMAND_UI(ID_MODIFY, OnUpdateModify)
    ON_COMMAND(ID_EDIT_COPY, OnEditCopy)
    ON_WM_DESTROY()
	ON_UPDATE_COMMAND_UI(ID_EDIT_COPY, OnUpdateEditCopy)
	//}}AFX_MSG_MAP
    ON_MESSAGE(WM_OBJ_INDICATE, OnObjIndicate) 
    ON_MESSAGE(WM_OP_STATUS, OnOpStatus) 
END_MESSAGE_MAP()

// Global used by sinks.
COpView *g_pOpView;

/////////////////////////////////////////////////////////////////////////////
// COpView construction/destruction

COpView::COpView() :
    m_pTree(NULL),
    m_hitemRoot(NULL)
{
    g_pOpView = this;
}

COpView::~COpView()
{
}

BOOL COpView::PreCreateWindow(CREATESTRUCT& cs)
{
    cs.style |= WS_CHILD | WS_VISIBLE | TVS_HASLINES | TVS_HASBUTTONS | 
        TVS_SHOWSELALWAYS; //TVS_EDITLABELS | 

    return CTreeView::PreCreateWindow(cs);
}

/////////////////////////////////////////////////////////////////////////////
// COpView drawing

void COpView::OnInitialUpdate()
{
    CTreeView::OnInitialUpdate();

    m_pTree->SetImageList(&((CMainFrame *) GetParentFrame())->m_imageList, 
        TVSIL_NORMAL);

    if (!m_hitemRoot)
        m_hitemRoot = m_pTree->InsertItem(_T(""), IMAGE_ROOT, IMAGE_ROOT);

    GetDocument()->m_pOpView = this;

    UpdateRootText();
}

/////////////////////////////////////////////////////////////////////////////
// COpView diagnostics

#ifdef _DEBUG
void COpView::AssertValid() const
{
    CTreeView::AssertValid();
}

void COpView::Dump(CDumpContext& dc) const
{
    CTreeView::Dump(dc);
}

CWMITestDoc* COpView::GetDocument() // non-debug version is inline
{
    ASSERT(m_pDocument->IsKindOf(RUNTIME_CLASS(CWMITestDoc)));
    return (CWMITestDoc*)m_pDocument;
}
#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// COpView message handlers

void COpView::OnSize(UINT nType, int cx, int cy) 
{
    CTreeView::OnSize(nType, cx, cy);
    
    if (!m_pTree)
        m_pTree = &GetTreeCtrl();
}

LRESULT COpView::OnObjIndicate(WPARAM wParam, LPARAM lParam)
{
    COpWrap  *pWrap = (COpWrap*) wParam;
    CObjInfo *pInfo = (CObjInfo*) lParam;

    if (!pWrap->IsObject())
    {
        AddOpItemChild(
            pInfo, 
            pWrap->m_item, 
            pInfo->GetImage(), 
            pInfo->GetObjText());
    }
    else
    {
        // This just simulates a selection since the object has already been 
        // added.
        if (pWrap->m_item == m_pTree->GetSelectedItem())
            GetDocument()->UpdateAllViews(this, HINT_OP_SEL, 
                (CObject*) pWrap->m_item);
    }

    if (pWrap->m_item == m_pTree->GetSelectedItem())
        UpdateStatusText();

    return 0;
}

LRESULT COpView::OnOpStatus(WPARAM wParam, LPARAM lParam)
{
    COpWrap *pWrap = (COpWrap*) wParam;
    int     iImage = pWrap->GetImage();

    GetDocument()->DecBusyOps();

    // Update in case it's changed.
    m_pTree->SetItemImage(pWrap->m_item, iImage, iImage);

    if (pWrap->m_item == m_pTree->GetSelectedItem())
        UpdateStatusText();

    return 0;
}

void COpView::AddOpItem(WMI_OP_TYPE type, LPCTSTR szText, BOOL bOption)
{
    AddOpItem(new COpWrap(type, szText, bOption));
}

void COpView::AddOpItem(COpWrap *pWrap)
{
    CString strCaption = pWrap->GetCaption();
    int     iImage = pWrap->GetImage();
    BOOL    bExpand = m_pTree->GetChildItem(m_hitemRoot) == NULL;

    pWrap->m_item = m_pTree->InsertItem(strCaption, iImage, iImage, 
                        m_hitemRoot);
    m_pTree->SetItemData(pWrap->m_item, (DWORD_PTR) pWrap);

    RefreshItem(pWrap);

    if (bExpand)
        m_pTree->Expand(m_hitemRoot, TVE_EXPAND);

    m_pTree->SelectItem(pWrap->m_item);

    GetDocument()->SetModifiedFlag(TRUE);
}

void COpView::AddOpItemChild(
    CObjInfo *pInfo,
    HTREEITEM hParent, 
    int iImage, 
    LPCTSTR szText)
{
    BOOL      bUpdateCaption = !m_pTree->ItemHasChildren(hParent);
    HTREEITEM hChild = m_pTree->InsertItem(szText, iImage, iImage, hParent);
    
    // If this is the first child added see if the caption has been
    // updated.
    if (bUpdateCaption)
    {
        COpWrap *pWrap = (COpWrap*) m_pTree->GetItemData(hParent);

        m_pTree->SetItemText(pWrap->m_item, pWrap->GetCaption());
    }

    if (hParent == m_pTree->GetSelectedItem())
        UpdateStatusText();

    m_pTree->SetItemData(hChild, (DWORD_PTR) pInfo);

    GetDocument()->UpdateAllViews(this, HINT_NEW_CHILD, (CObject*) hChild);
}

void COpView::FlushItems()
{
    HTREEITEM hitemParent;

    if (!m_hitemRoot)
        m_hitemRoot = m_pTree->InsertItem(_T(""), IMAGE_ROOT, IMAGE_ROOT);

    while ((hitemParent = m_pTree->GetChildItem(m_hitemRoot)) != NULL)
    {
        RemoveItemFromTree(hitemParent, TRUE);
    }
}

void COpView::RemoveChildrenFromTree(HTREEITEM item, BOOL bDoRemove)
{
    COpWrap *pWrap = GetCurrentOp();

    if (pWrap && pWrap->m_item == item)
        GetDocument()->m_pObjView->Flush();

    HTREEITEM hitemChild;

    while ((hitemChild = m_pTree->GetChildItem(item)) != NULL)
    {
        RemoveNonOpObjectFromTree(hitemChild);
    }
}

void COpView::RemoveNonOpObjectFromTree(HTREEITEM hitem)
{
    ASSERT(!IsOp(hitem));

    CObjInfo *pInfo = (CObjInfo*) m_pTree->GetItemData(hitem);

    ASSERT(pInfo != NULL);

    m_pTree->DeleteItem(hitem);

    delete pInfo;
}

void COpView::RemoveItemFromTree(HTREEITEM item, BOOL bNoWMIRemove)
{
    if (!bNoWMIRemove && IsObjDeleteable(item))
    {
        CDelDlg dlg;

        dlg.m_bDelFromWMI = theApp.m_bDelFromWMI;

        if (dlg.DoModal() == IDOK)
        {
            theApp.m_bDelFromWMI = dlg.m_bDelFromWMI;

            if (dlg.m_bDelFromWMI)
            {
                CObjInfo           *pObj = GetObjInfo(item);
                HRESULT            hr;
                IWbemCallResultPtr pResult;

                if (pObj->IsInstance())
                {
                    CString strPath;

                    strPath = pObj->GetStringPropValue(L"__RELPATH");
                    
                    hr = 
                        GetDocument()->m_pNamespace->DeleteInstance(
                            _bstr_t(strPath),
                            0,
                            NULL,
                            &pResult);
                }
                else
                {
                    CString strClass;

                    strClass = pObj->GetStringPropValue(L"__CLASS");
                    
                    hr = 
                        GetDocument()->m_pNamespace->DeleteClass(
                            _bstr_t(strClass),
                            0,
                            NULL,
                            &pResult);
                }

                if (FAILED(hr))
                {
                    //CWMITestDoc::DisplayWMIErrorBox(hr, pResult);
                    CWMITestDoc::DisplayWMIErrorBox(hr);

                    return;
                }
            }
        }
        else
            // Get out if the user canceled the dialog.
            return;
    }

    if (IsOp(item))
    {
        RemoveChildrenFromTree(item, TRUE);

        COpWrap *pWrap = (COpWrap*) m_pTree->GetItemData(item);
        pWrap->CancelOp(GetDocument()->m_pNamespace);
        m_pTree->DeleteItem(item);

        delete pWrap;
    }
    else
    {
        HTREEITEM itemParent = m_pTree->GetParentItem(item);

        RemoveNonOpObjectFromTree(item);
        
        UpdateItem(itemParent);
    }
}

void COpView::UpdateRootText()
{
    CString strText;

    if (GetDocument()->m_pNamespace)
        strText = GetDocument()->m_strNamespace;
    else
        strText.LoadString(IDS_NOT_CONNECTED);

    m_pTree->SetItemText(m_hitemRoot, strText);

    UpdateStatusText();
}


void COpView::OnDblclk(NMHDR* pNMHDR, LRESULT* pResult) 
{
    CPoint curPoint;
    
    GetCursorPos(&curPoint);
    ScreenToClient(&curPoint);

    HTREEITEM hItem = m_pTree->HitTest(curPoint);

    *pResult = 0;

    // Only do something if we really selected an item.
    if (hItem)
    {
        m_pTree->SelectItem(hItem);

        if (hItem == m_hitemRoot)
        {
            GetDocument()->DoConnectDlg();
            *pResult = 1;
        }
        else
            OnModify();
    }
    
}

void COpView::UpdateCurrentItem()
{
    HTREEITEM hitem = m_pTree->GetSelectedItem();

    if (hitem)
        UpdateItem(hitem);
}

void COpView::UpdateItem(HTREEITEM hitem)
{
    long iHint;

    if (IsRoot(hitem))
        iHint = HINT_ROOT_SEL;
    else if (IsOp(hitem))
        iHint = HINT_OP_SEL;
    else
        iHint = HINT_OBJ_SEL;
             
    GetDocument()->UpdateAllViews(this, iHint, (CObject*) hitem);
}

void COpView::OnSelChanged(NMHDR* pNMHDR, LRESULT* pResult) 
{
    NM_TREEVIEW *pNMTreeView = (NM_TREEVIEW*)pNMHDR;

    if ((pNMTreeView->itemNew.state & TVIS_SELECTED))
    {    
        UpdateItem(pNMTreeView->itemNew.hItem);
    }
    
    UpdateStatusText();

    *pResult = 0;
}

void COpView::RefreshObject(CObjInfo *pInfo)
{
}

void COpView::RefreshItem(HTREEITEM hitem)
{
    RefreshItem((COpWrap*) m_pTree->GetItemData(hitem));
}

    
void COpView::RefreshItem(COpWrap *pWrap)
{
    pWrap->CancelOp(GetDocument()->m_pNamespace);
    pWrap->m_listObj.RemoveAll();
    RemoveChildrenFromTree(pWrap->m_item, TRUE);

    GetDocument()->IncBusyOps();
    
    pWrap->Execute(GetDocument()->m_pNamespace);

    int iImage = pWrap->GetImage();

    m_pTree->SetItemImage(pWrap->m_item, iImage, iImage);
}

void COpView::RefreshItems()
{
    for (HTREEITEM hitemOp = m_pTree->GetChildItem(m_hitemRoot);
        hitemOp != NULL;
        hitemOp = m_pTree->GetNextSiblingItem(hitemOp))
    {
        RefreshItem(hitemOp);
    }
}

COpWrap *COpView::GetCurrentOp()
{
    HTREEITEM hitemCurrent = m_pTree->GetSelectedItem();
    COpWrap   *pWrap = NULL;

    if (hitemCurrent && (IsOp(hitemCurrent) || 
        IsOp(hitemCurrent = m_pTree->GetParentItem(hitemCurrent))))
        pWrap = (COpWrap*) m_pTree->GetItemData(hitemCurrent);

    return pWrap;
}

CObjInfo *COpView::GetCurrentObj()
{
    HTREEITEM hitemCurrent = m_pTree->GetSelectedItem();
    CObjInfo  *pObj = NULL;

    if (hitemCurrent && !IsRoot(hitemCurrent))
    {
        if (IsOp(hitemCurrent))
        {
            COpWrap *pWrap;

            pWrap = (COpWrap*) m_pTree->GetItemData(hitemCurrent);
            if (pWrap->IsObject())
                pObj = pWrap->GetObjInfo();
        }
        else
            pObj = (CObjInfo*) m_pTree->GetItemData(hitemCurrent);
    }

    return pObj;
}

void COpView::DoPopupMenu(UINT nMenuID)
{
    CMenu popMenu;

    popMenu.LoadMenu(nMenuID);
    
    CPoint posMouse;
    GetCursorPos(&posMouse);

    CWnd* pWndPopupOwner = this;
    while (pWndPopupOwner->GetStyle() & WS_CHILD)
        pWndPopupOwner = pWndPopupOwner->GetParent();
 
    popMenu.GetSubMenu(0)->TrackPopupMenu(0,posMouse.x,posMouse.y,pWndPopupOwner);
}


void COpView::OnRclick(NMHDR* pNMHDR, LRESULT* pResult) 
{
    CPoint curPoint;
    
    GetCursorPos(&curPoint);
    ScreenToClient(&curPoint);

    HTREEITEM hItem = m_pTree->HitTest(curPoint);

    // Only do something if we really selected an item.
    if (hItem)
    {
        m_pTree->SelectItem(hItem);
        DoContextMenuForItem(hItem);
    }
    
    *pResult = 0;
}

void COpView::DoContextMenuForItem(HTREEITEM hItem)
{
    if (hItem == m_hitemRoot)
        DoPopupMenu(IDR_NAMESPACE);
    else if (IsOp(hItem))
    {
        COpWrap *pWrap = (COpWrap*) m_pTree->GetItemData(hItem);

        if (FAILED(pWrap->m_hr))
            DoPopupMenu(IDR_BAD_OP);
        else
        {
            if (!pWrap->IsObject())
                DoPopupMenu(IDR_OP);
            else
            {
                if (pWrap->HoldsObjects())
                    DoPopupMenu(IDR_INST);
                else
                    DoPopupMenu(IDR_CLASS);
            }
        }
    }
    else
    {
        HTREEITEM hitemParent = m_pTree->GetParentItem(hItem);
        COpWrap   *pWrap = (COpWrap*) m_pTree->GetItemData(hitemParent);

        if (pWrap->HoldsObjects())
            DoPopupMenu(IDR_INST);
        else
            DoPopupMenu(IDR_CLASS);
    }
}

int COpView::GetChildCount(HTREEITEM hitem)
{
    int nCount = 0;

    for (HTREEITEM hitemOp = m_pTree->GetChildItem(m_hitemRoot);
        hitemOp != NULL;
        hitemOp = m_pTree->GetNextSiblingItem(hitemOp))
    {
        nCount++;
    }

    return nCount;
}

int COpView::GetOpCount()
{
    return GetChildCount(m_hitemRoot);
}

BOOL COpView::IsObj(HTREEITEM hitem) 
{ 
    return GetObjInfo(hitem) != NULL;
}

CObjInfo *COpView::GetObjInfo(HTREEITEM hitem)
{
    if (IsRoot(hitem))
        return NULL;

    BOOL bIsOp = IsOp(hitem);

    if (bIsOp)
    {
        COpWrap *pWrap = (COpWrap*) m_pTree->GetItemData(hitem);

        if (pWrap->IsObject())
            return pWrap->GetObjInfo();
        else
            return NULL;
    }
    else
        return (CObjInfo*) m_pTree->GetItemData(hitem);
}

void COpView::UpdateCurrentObject(BOOL bReloadProps)
{
    HTREEITEM hitem = m_pTree->GetSelectedItem();

    if (!IsObj(hitem))
        hitem = GetDocument()->m_pObjView->GetSelectedItem();

    if (IsObj(hitem))
    {
        if (bReloadProps)
        {
            CObjInfo *pObj = (CObjInfo*) GetObjInfo(hitem);
            COpWrap  *pOp = (COpWrap*) GetCurrentOp();

            pOp->RefreshPropInfo(pObj);

            // Update the icon.
            int iImage = pObj->GetImage();
            
            m_pTree->SetItemImage(hitem, iImage, iImage);

            // Update the text.
            m_pTree->SetItemText(hitem, 
                pObj == &pOp->m_objInfo ? pOp->GetCaption() : pObj->GetObjText());
        }

    }

    UpdateItem(m_pTree->GetSelectedItem());
}

void COpView::UpdateStatusText()
{
    HTREEITEM hitem = m_pTree->GetSelectedItem();
    CString   strText;


    if (IsRoot(hitem))
    {
        if (GetDocument()->m_pNamespace)
            strText.Format(IDS_ROOT_STATUS, (LPCTSTR) GetDocument()->m_strNamespace);
        else
            strText.LoadString(IDS_NOT_CONNECTED);
    }
    else if (IsOp(hitem))
    {
        COpWrap *pWrap = (COpWrap*) m_pTree->GetItemData(hitem);
        
        if (SUCCEEDED(pWrap->m_hr))
        {
            strText.Format(
                pWrap->HoldsObjects() ? IDS_OBJ_COUNT : IDS_CLASS_COUNT,
                pWrap->GetObjCount());
        }
        else
            strText = pWrap->m_strErrorText;
    }

    ((CMainFrame *) GetParentFrame())->SetStatusText(strText);    
}

BOOL COpView::GetSelectedObjPath(CString &strPath)
{
    BOOL     bRet = FALSE;
    CObjInfo *pInfo = GetCurrentObj();

    if (pInfo)
    {
        strPath = pInfo->GetStringPropValue(L"__RELPATH");
        bRet = !strPath.IsEmpty();
    }

    return bRet;
}

BOOL COpView::GetSelectedClass(CString &strClass)
{
    BOOL     bRet = FALSE;
    CObjInfo *pInfo = GetCurrentObj();

    if (pInfo)
    {
        strClass = pInfo->GetStringPropValue(L"__CLASS");
        bRet = TRUE;
    }

    return bRet;
}


void COpView::OnDelete() 
{
    HTREEITEM hitem = m_pTree->GetSelectedItem();

    if (hitem != NULL && !IsRoot(hitem))
    {
        RemoveItemFromTree(hitem, FALSE);        
        GetDocument()->SetModifiedFlag(TRUE);
    }
}

void COpView::OnUpdateDelete(CCmdUI* pCmdUI) 
{
    HTREEITEM hitem = m_pTree->GetSelectedItem();

    pCmdUI->Enable(hitem != NULL && !IsRoot(hitem));
}

BOOL COpView::IsObjDeleteable(HTREEITEM hitem)
{
    BOOL bRet = FALSE;

    if (IsObj(hitem))
    {
        if (IsOp(hitem))
        {
            COpWrap *pWrap = (COpWrap*) m_pTree->GetItemData(hitem);    

            bRet = SUCCEEDED(pWrap->m_hr) &&
                    pWrap->m_type != WMI_CREATE_CLASS && 
                    pWrap->m_type != WMI_CREATE_OBJ;
        }
        else
            bRet = TRUE;
    }

    return bRet;
}

void COpView::EditObj(CObjInfo *pInfo)
{
    CPropertySheet sheet(pInfo->IsInstance() ? IDS_EDIT_INST : IDS_EDIT_CLASS);
    CPropsPg       pgProps;
    CPropQualsPg   pgQuals;
    CMethodsPg     pgMethods;
    IWbemClassObjectPtr
                   pOrigObj;

    pInfo->m_pObj->Clone(&pOrigObj);

    pgProps.m_pNamespace = GetDocument()->m_pNamespace;
    pgProps.m_pObj = pInfo;

    pgQuals.m_pObj = pInfo->m_pObj;
    pgQuals.m_bIsInstance = pInfo->IsInstance();
    pgQuals.m_mode = CPropQualsPg::QMODE_CLASS;

    sheet.AddPage(&pgProps);
    sheet.AddPage(&pgQuals);

    if (!pInfo->IsInstance())
    {
        pgMethods.m_pObj = pInfo->m_pObj;

        sheet.AddPage(&pgMethods);
    }

    sheet.DoModal();

    if (pInfo->m_pObj->CompareTo(WBEM_COMPARISON_INCLUDE_ALL, pOrigObj) ==
        WBEM_S_DIFFERENT)
    {
        pInfo->SetModified(TRUE);
        UpdateCurrentObject(TRUE);
    }
}

void COpView::OnModify() 
{
    CObjInfo *pInfo = GetCurrentObj();

    if (pInfo && pInfo->m_pObj != NULL)
        EditObj(pInfo);
    else
    {
        COpWrap *pOp = GetCurrentOp();

        if (pOp && pOp->m_pErrorObj != NULL)
            CWMITestDoc::DisplayWMIErrorDetails(pOp->m_pErrorObj);
    }
}

void COpView::OnUpdateModify(CCmdUI* pCmdUI) 
{
    pCmdUI->Enable(GetCurrentObj() != NULL);
}

void COpView::ExportItemToFile(LPCTSTR szFilename, HTREEITEM hitem,
    BOOL bShowSystem, BOOL bTranslate)
{
    // Open the file.  If this fails, an exception will fire that MFC will 
    // handle for us.
    CStdioFile file(szFilename, 
        CFile::modeCreate | CFile::modeWrite | CFile::typeText);

    // Add the namespace.
    CString strNamespace;

    strNamespace.Format("<%s>\n", GetDocument()->m_strNamespace);

    file.WriteString(strNamespace);

    ExportItem(&file, hitem, bShowSystem, bTranslate);
}

void COpView::ExportItem(CStdioFile *pFile, HTREEITEM hitem, 
    BOOL bShowSystem, BOOL bTranslate)
{
    CObjInfo *pObj = GetObjInfo(hitem);

    if (pObj)
        pObj->Export(pFile, bShowSystem, bTranslate, 0);
    else
    {
        for (HTREEITEM hitemChild = m_pTree->GetChildItem(hitem);
            hitemChild != NULL;
            hitemChild = m_pTree->GetNextSiblingItem(hitemChild))
        {
            ExportItem(pFile, hitemChild, bShowSystem, bTranslate);
        }
    }
}

/*
DWORD WINAPI SetClipboardThreadProc(COleDataSource *pSrc)
{
    OleInitialize(NULL);

    pSrc->SetClipboard();

    BOOL bRet;

    bRet = IsClipboardFormatAvailable(CF_TEXT);
    bRet = IsClipboardFormatAvailable(CF_UNICODETEXT);

    OpenClipboard(NULL);
    
//    HANDLE hRet = GetClipboardData(CF_TEXT);
//    LPSTR  szText = (LPSTR) GlobalLock((HGLOBAL) hRet);

//    GlobalUnlock((HGLOBAL) hRet);
    
    CloseClipboard();

    OleUninitialize();

    return 0;
}

DWORD WINAPI COpView::CopyThreadProc(COpView *pThis)
{
    OleInitialize(NULL);
    
    pThis->CopyToClipboard();

    OleUninitialize();

    return 0;
}

void COpView::DoThreadedCopy()
{
    HANDLE hThread;
    DWORD  dwID;

    hThread =
        CreateThread(
            NULL,
            0,
            (LPTHREAD_START_ROUTINE) CopyThreadProc,
            this,
            0,
            &dwID);

    //WaitForSingleObject(hThread, INFINITE);

    CloseHandle(hThread);
}
*/

void COpView::OnEditCopy() 
{
    CopyToClipboard();
    //DoThreadedCopy();
}

#define NO_DATA_SRC

void COpView::CopyToClipboard() 
{
    COpList list;

    BuildSelectedOpList(list);

    if (list.GetCount())
    {
        // Ole will kill this variable when it's done.
        //COleDataSource *pSrc = new COleDataSource;

        //DoCopy(pSrc, list);
        DoCopy(list);

#ifndef NO_DATA_SRC
#if 1
        pSrc->SetClipboard();
#else
        HANDLE hThread;
        DWORD  dwID;

        hThread =
            CreateThread(
                NULL,
                0,
                (LPTHREAD_START_ROUTINE) SetClipboardThreadProc,
                pSrc,
                0,
                &dwID);

        WaitForSingleObject(hThread, INFINITE);

        CloseHandle(hThread);
#endif
#endif
    }
}

void COpView::BuildSelectedOpList(COpList &list)
{
    HTREEITEM hitem = m_pTree->GetSelectedItem();

    list.RemoveAll();

    if (hitem == m_hitemRoot)
    {
        for (HTREEITEM hitemOp = m_pTree->GetChildItem(m_hitemRoot);
            hitemOp != NULL;
            hitemOp = m_pTree->GetNextSiblingItem(hitemOp))
        {
            COpWrap *pWrap = (COpWrap*) m_pTree->GetItemData(hitemOp);

            list.AddTail(*pWrap);
        }
    }
    else if (IsOp(hitem))
    {
        COpWrap *pWrap = (COpWrap*) m_pTree->GetItemData(hitem);

        list.AddTail(*pWrap);
    }
    else
    {
        ASSERT(IsObj(hitem));

        CObjInfo *pObj = GetObjInfo(hitem);
        CString  strRelpath = pObj->GetStringPropValue(L"__RELPATH");

        if (!strRelpath.IsEmpty())
        {
            BOOL    bIsClass = strRelpath.Find('=') == -1;
            COpWrap wrap(bIsClass ? WMI_GET_CLASS : WMI_GET_OBJ, strRelpath);

            list.AddTail(wrap);
        }
    }
}

void COpView::DoCopy(COpList &list)
{
    CMemFile memNative,
             memText;
    CArchive arcNative(&memNative, CArchive::store),
             arcText(&memText, CArchive::store);
    POSITION pos = list.GetHeadPosition();
    BOOL     bFirst = TRUE;

    // Save off the count into the archive.
    arcNative << (int) list.GetCount();

    while (pos)
    {
        COpWrap &op = list.GetNext(pos);

        // Save off the option wrapper into the native archive.
        op.Serialize(arcNative);

        // Add a new-line if we've already done an item.
        if (bFirst)
            bFirst = FALSE;
        else
            arcText.Write("\n", sizeof("\n") - 1);

        // Add the option text into the text archive.
        arcText.Write((LPCTSTR) op.m_strOpText, op.m_strOpText.GetLength());
    }

    // Add the null character.
    arcText.Write("", 1);

    arcNative.Close();
    arcText.Close();

#ifdef NO_DATA_SRC
    BOOL bRet = ::OpenClipboard(NULL);
#endif

    // Save off the native archive contents.
    DWORD   dwSize = memNative.GetLength();
    HGLOBAL pGlobBuffer = GlobalAlloc(GMEM_MOVEABLE | GMEM_DDESHARE, dwSize),
            pArcBuffer = memNative.Detach();

    memcpy(GlobalLock(pGlobBuffer), pArcBuffer, dwSize);
    GlobalUnlock(pGlobBuffer);
    free(pArcBuffer);

#ifdef NO_DATA_SRC
    SetClipboardData(GetDocument()->m_cfOps, (HGLOBAL) pGlobBuffer);
#else
    pSrc->CacheGlobalData(GetDocument()->m_cfOps, (HGLOBAL) pGlobBuffer);
#endif


    // Save off the text archive contents.
    dwSize = memText.GetLength();
    pGlobBuffer = (LPBYTE) GlobalAlloc(GMEM_MOVEABLE | GMEM_DDESHARE, dwSize);
    pArcBuffer = memText.Detach();

    // Turn the text into Unicode.
    _bstr_t strText = (LPSTR) pArcBuffer;

    memcpy(GlobalLock(pGlobBuffer), pArcBuffer, dwSize);
    GlobalUnlock(pGlobBuffer);
    free(pArcBuffer);

#ifdef NO_DATA_SRC
    SetClipboardData(CF_TEXT, (HGLOBAL) pGlobBuffer);
#else
    pSrc->CacheGlobalData(CF_TEXT, (HGLOBAL) pGlobBuffer);
#endif


    pGlobBuffer = (LPBYTE) GlobalAlloc(GMEM_MOVEABLE | GMEM_DDESHARE, dwSize * 2);
    LPBYTE pBuffer = (LPBYTE) GlobalLock(pGlobBuffer);
    memcpy(pBuffer, (LPCWSTR) strText, dwSize * 2);
    GlobalUnlock(pGlobBuffer);

#ifdef NO_DATA_SRC
    SetClipboardData(CF_UNICODETEXT, (HGLOBAL) pGlobBuffer);
#else
    pSrc->CacheGlobalData(CF_UNICODETEXT, (HGLOBAL) pGlobBuffer);
#endif

#ifdef NO_DATA_SRC
    ::CloseClipboard();
#endif
}

/*
void COpView::SerializeForClipboard(CArchive &arcNative, CArchive &arcText, 
    CLIPFORMAT *pFormat)
{
    HTREEITEM hitem = m_pTree->GetSelectedItem();

    if (hitem == m_hitemRoot)
    {
		int nCount = GetOpCount();

        archive << nCount;

        for (HTREEITEM hitemOp = m_pTree->GetChildItem(m_hitemRoot);
            hitemOp != NULL;
            hitemOp = m_pTree->GetNextSiblingItem(hitemOp))
        {
            COpWrap *pWrap = (COpWrap*) m_pTree->GetItemData(hitemOp);

            m_pWrap->Serialize(arcNative);
        }

        *pFormat = GetDocument()->m_cfOps; 
    }
    else if (IsOp(hitem))
    {
        int     nCount = 1;
        COpWrap *pWrap = (COpWrap*) m_pTree->GetItemData(hitem);

        archive << nCount;
        pWrap->Serialize(arcNative);
        *pFormat = GetDocument()->m_cfOps;


    }
    else
    {
        ASSERT(IsObj(hitem));
    }


}

void COpView::SerializeTreeItem(HTREEITEM item, CArchive &arcNative, CArchive &arcText)
{
}
*/

BOOL COpView::CanCopy()
{
    return m_pTree->GetSelectedItem() != NULL;
}

void COpView::OnUpdateEditCopy(CCmdUI* pCmdUI) 
{
	pCmdUI->Enable(CanCopy());
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\wmitest\opwrap.cpp ===
/*++

Copyright (C) 1997-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/
// OpWrap.cpp

#include "stdafx.h"
#include "OpWrap.h"
#include "resource.h"
#include "OpView.h"
#include "MainFrm.h"

void Trace(LPCTSTR szFormat, ...)
{
	va_list ap;

	TCHAR szMessage[512];

	va_start(ap, szFormat);
	_vstprintf(szMessage, szFormat, ap);
	va_end(ap);

	lstrcat(szMessage, _T("\n"));
	OutputDebugString(szMessage);
}

CString GetEmbeddedObjectText(IUnknown *pUnk)
{
    IWbemClassObjectPtr pObj;
    CString             strRet;

    if (pUnk)
    {
        pUnk->QueryInterface(
            IID_IWbemClassObject, 
            (LPVOID*) &pObj);

        if (pObj != NULL)
        {
            CObjInfo obj;

            obj.SetObj(pObj);

            strRet = obj.GetObjText();
        }
    }
    else
        strRet.LoadString(IDS_NULL);

    return strRet;
}

/////////////////////////////////////////////////////////////////////////////
// CObjInfo

CObjInfo::~CObjInfo()
{
}

BOOL CObjInfo::GetPropValue(int iIndex, CString &strValue, BOOL bTranslate)
{
    BOOL        bRet;
    _variant_t  var;
    CPropInfo   &prop = (*m_ppProps)[iIndex];

    ValueToVariant(iIndex, &var);

    bRet = prop.VariantToString(&var, strValue, bTranslate);

    // Otherwise the destructor freaks out because it doesn't know what to do
    // with VT_I8.
    if (var.vt == VT_I8)
        var.vt = VT_I4;

    return bRet;
}

CString CObjInfo::GetStringPropValue(int iIndex)
{
    _bstr_t strProp = m_ppProps->GetData()[iIndex].m_strName;

    return GetStringPropValue(strProp);
}

CString CObjInfo::GetStringPropValue(LPCWSTR szName)
{
    CString    strRet;
    _variant_t var;

    if (m_pObj != NULL)
    {
        m_pObj->Get(
            szName,
            0,
            &var,
            NULL,
            NULL);
    }

    if (var.vt == VT_BSTR)
        strRet = var.bstrVal;

    return strRet;
}

#define KEY_PROP_FORMAT         _T("\t\t%s (%s)*  = %s\n")
#define NON_KEY_PROP_FORMAT     _T("\t\t%s (%s)  = %s\n")

void CObjInfo::Export(CStdioFile *pFile, BOOL bShowSystem, BOOL bTranslate, 
    int iLevel)
{
#ifdef _DEBUG
    // Don't leave this in here!  It's a hack I'm using to check out the 
    // internal layout of IWbemClassObject.
    DoDebugStuff();
#endif
    
    CPropInfo *pProps;
    int       nItems;

    // Get out if the object isn't valid (like on an object where the
    // refresh failed).
    if (m_pObj == NULL)
        return;

    pProps = GetProps()->GetData();
    nItems = GetProps()->GetSize();

    // Add the object path.
    for (int i = 0; i <= iLevel; i++)
        pFile->Write(_T("\t"), sizeof(TCHAR));

    pFile->WriteString(GetObjText());
    pFile->Write(_T("\n"), sizeof(TCHAR));
    
    for (i = 0; i < nItems; i++)
    {
        if (bShowSystem || pProps[i].m_iFlavor != WBEM_FLAVOR_ORIGIN_SYSTEM)
        {
            CString    strLine,
                       strType,
                       strValue;
            _variant_t vValue;
            IUnknown   **pUnks = NULL;
            int        nUnks = 0,
                       iImage;
            BOOL       bArray;

            pProps[i].GetPropType(strType, &iImage);
            ValueToVariant(i, &vValue);

            if (vValue.vt == VT_UNKNOWN)
            {
                bArray = FALSE;
                nUnks = 1;
                pUnks = &vValue.punkVal; 
            }
            else if (vValue.vt == ((int) VT_UNKNOWN | VT_ARRAY))
            {
                bArray = TRUE;
                nUnks = vValue.parray->rgsabound[0].cElements;
                pUnks = (IUnknown**) vValue.parray->pvData; 
            }
            else
                pProps[i].VariantToString(&vValue, strValue, bTranslate, TRUE);

            strLine.Format(
                pProps[i].m_bKey ? KEY_PROP_FORMAT : NON_KEY_PROP_FORMAT,
                (LPCTSTR) pProps[i].m_strName,
                (LPCTSTR) strType,
                (LPCTSTR) strValue);

            // Add some additional space if we're in a nested level.
            for (int i = 0; i < iLevel; i++)
                pFile->Write(_T("\t"), sizeof(TCHAR));

            pFile->WriteString(strLine);

            // Now do the embedded object stuff.
            if (nUnks)
            {
                for (int i = 0; i < nUnks; i++)
                {
                    IWbemClassObjectPtr pObj;
                    HRESULT             hr;

                    hr =
                        pUnks[i]->QueryInterface(
                            IID_IWbemClassObject, 
                            (LPVOID*) &pObj);

                    if (SUCCEEDED(hr))
                    {
                        CObjInfo info;

                        info.SetObj(pObj);
                        info.SetBaseImage(IMAGE_OBJECT);
                        info.LoadProps(NULL);

                        info.Export(pFile, bShowSystem, bTranslate, iLevel + 2);

                        // This looks bad, but normally this is done by a 
                        // controlling COpWrap.  In this case we faked one, so 
                        // we have to get rid of it ourselves.
                        delete info.GetProps();
                    }
                }
            }

            // Otherwise the destructor freaks out because it doesn't know what to do
            // with VT_I8.
            if (vValue.vt == VT_I8)
                vValue.vt = VT_I4;
        }
    }

    // Leave room for another one.
    pFile->Write(_T("\n"), sizeof(TCHAR));
}

CString CObjInfo::GetObjText()
{
    CString strRet = GetStringPropValue(L"__RELPATH");

    if (strRet.IsEmpty())
    {
        CString strClass = GetStringPropValue(L"__CLASS");

        if (!strClass.IsEmpty())
            strRet.Format(IDS_CLASS_NO_KEY, (LPCTSTR) strClass);
        else
            strRet.LoadString(IDS_NO_KEY);
    }

    return strRet;    
}

#define MAX_STR_SIZE 4096

BOOL CObjInfo::ValueToVariant(int iIndex, VARIANT *pVar)
{
    CPropInfo &prop = (*m_ppProps)[iIndex];
    BOOL      bRet = FALSE;

    VariantClear(pVar);
    pVar->vt = VT_NULL;

    if (prop.m_iHandle && !(prop.m_type & CIM_FLAG_ARRAY))
    {
        BOOL  bString = prop.m_vt == VT_BSTR;
        long  nRead = 0;

        if (bString)
        {
            WCHAR szBuff[MAX_STR_SIZE];

            bRet = 
                SUCCEEDED(m_pAccess->ReadPropertyValue(
                    prop.m_iHandle,
                    prop.m_dwExpectedSize,
                    &nRead,
                    (LPBYTE) szBuff)) && nRead != 0;

            if (bRet)
            {
                pVar->vt = VT_BSTR;
                V_BSTR(pVar) = SysAllocString(szBuff);
            }
        }
        else
        {
            bRet = 
                SUCCEEDED(m_pAccess->ReadPropertyValue(
                    prop.m_iHandle,
                    prop.m_dwExpectedSize,
                    &nRead,
                    (LPBYTE) &V_BSTR(pVar))) && 
                        (nRead == prop.m_dwExpectedSize);

            if (bRet)
                pVar->vt = prop.m_vt;
        }
    }
    else
    {
        bRet = SUCCEEDED(m_pObj->Get(
            _bstr_t(prop.m_strName),
            0,
            pVar,
            NULL,
            NULL));
    }

    return bRet;
}

CString GetStringPropType(int iIndex);
void CObjInfo::GetPropInfo(
    int iIndex, 
    CString &strValue,
    CString &strType,
    int *piImage,
    int *piFlavor,
    BOOL bTranslate)
{
    CPropInfo &info = (*m_ppProps)[iIndex];

    info.GetPropType(strType, piImage);
        
    strValue = _T("");

    *piFlavor = info.m_iFlavor;

    GetPropValue(iIndex, strValue, bTranslate);
}

void CObjInfo::SetObj(IWbemClassObject *pObj)
{
    m_pObj = pObj;

    pObj->QueryInterface(
        IID_IWbemObjectAccess, 
        (LPVOID*) &m_pAccess);
}

BOOL IsVarStringArray(VARIANT *pVar)
{
    return pVar->vt == (VT_BSTR | VT_ARRAY) && 
        pVar->parray->rgsabound[0].cElements != 0;
}

// This converts a BitMap qualifier value string into a bitmask scalar value.
// If the number is a decimal number we have to shift it (e.g. convert '3',
// or bit 3 (zero based), into 0x8.
// If the number is hex, just use wcstoul to convert it into a DWORD.
DWORD CObjInfo::BitmaskStrToValue(LPCWSTR szStr)
{
    WCHAR *szBad;

    if (szStr[0] && towupper(szStr[1]) != 'X')
        return 1 << wcstoul(szStr, &szBad, 0);
    else
        return wcstoul(szStr, &szBad, 0);
}

HRESULT CObjInfo::LoadProps(IWbemServices *pNamespace)
{
    // We need to get the class definition for the amended qualifiers.
    IWbemClassObjectPtr pClass;
    CString             strClass = GetStringPropValue(L"__CLASS");

    if (!m_ppProps)
        m_ppProps = new CPropInfoArray;

    if (pNamespace)
    {
        pNamespace->GetObject(
            _bstr_t(strClass),
            WBEM_FLAG_USE_AMENDED_QUALIFIERS,
            NULL,
            &pClass,
            NULL);
    }


    SAFEARRAY  *pArr = NULL;
    HRESULT    hr;
    CMap<CString, LPCTSTR, BOOL, BOOL>
               mapNameToKey;
    _variant_t vTrue(true);

    // Find our key properties
    if (SUCCEEDED(m_pObj->GetNames(
        L"KEY",
        WBEM_FLAG_ONLY_IF_IDENTICAL,
        &vTrue,
        &pArr)) && pArr->rgsabound[0].cElements != 0)
    {
        BSTR *pNames = (BSTR*) pArr->pvData;

        for (int i = 0; 
            i < pArr->rgsabound[0].cElements;
            i++)
        {
            mapNameToKey.SetAt(_bstr_t(pNames[i]), TRUE);
        }

        SafeArrayDestroy(pArr);
    }


    // Find out how big we need to make our array.
    if (SUCCEEDED(hr = m_pObj->GetNames(
        NULL,
        WBEM_FLAG_ALWAYS,
        NULL,
        &pArr)) && pArr->rgsabound[0].cElements != 0)
    {
        BSTR *pNames = (BSTR*) pArr->pvData;

        m_ppProps->SetSize(pArr->rgsabound[0].cElements);

        for (int i = 0; 
            i < pArr->rgsabound[0].cElements && SUCCEEDED(hr);
            i++)
        {
            BOOL bKey; // This value isn't really used, but we need it for the
                       // mapNameToKey.Lookup call.

            CPropInfo &info = (*m_ppProps)[i];

            CIMTYPE type;

            m_pObj->Get(pNames[i], 0, NULL, &type, &info.m_iFlavor);
            info.m_strName = (LPCWSTR) _bstr_t(pNames[i]);
                
            BOOL bSystemProp = info.m_iFlavor == WBEM_FLAVOR_ORIGIN_SYSTEM;

            // Don't bother getting the handle for system props since they don't
            // exist.
            if (!bSystemProp)
                m_pAccess->GetPropertyHandle(pNames[i], NULL, &info.m_iHandle);

            info.SetType(type);

            if (mapNameToKey.Lookup(info.m_strName, bKey))
                info.m_bKey = TRUE;

            // Load up the valuemap/bitmap values.
            
            IWbemQualifierSetPtr pQuals;

            if (pClass != NULL && 
                SUCCEEDED(pClass->GetPropertyQualifierSet(pNames[i], &pQuals)))
            {
                _variant_t vValues;

                // Try to get the Values/Valuemap stuff.
                if (SUCCEEDED(pQuals->Get(L"Values", 0, &vValues, NULL)) && 
                    IsVarStringArray(&vValues))
                {
                    _variant_t vMap;
                    BOOL       bUsingMap;
                    
                    bUsingMap = SUCCEEDED(pQuals->Get(L"ValueMap", 0, &vMap, NULL)) &&
                                    IsVarStringArray(&vMap) &&
                                    vMap.parray->rgsabound[0].cElements ==
                                        vValues.parray->rgsabound[0].cElements;

                    // Indicate whether this property will be using 
                    // m_mapValues.
                    info.m_bValueMap = 
                        vValues.parray->rgsabound[0].cElements != 0;

                    // Clear this out in case we're refreshing our data.
                    info.m_mapValues.RemoveAll();

                    for (int i = 0; i < vValues.parray->rgsabound[0].cElements;
                        i++)
                    {
                        CString strKey,
                                strValue;

                        if (bUsingMap)
                            strKey = ((BSTR*)(vMap.parray->pvData))[i];
                        else
                            strKey.Format(_T("%d"), i);

                        strValue = ((BSTR*)(vValues.parray->pvData))[i];

                        info.m_mapValues.SetAt(strKey, strValue);
                    }
                }


                // Try to get the Values/Valuemap stuff.
                if (SUCCEEDED(pQuals->Get(L"BitValues", 0, &vValues, NULL)) && 
                    IsVarStringArray(&vValues))
                {
                    _variant_t vMap;
                    BOOL       bUsingBitmap;
                    
                    bUsingBitmap = SUCCEEDED(pQuals->Get(L"BitMap", 0, &vMap, NULL)) &&
                                    IsVarStringArray(&vMap) &&
                                    vMap.parray->rgsabound[0].cElements ==
                                        vValues.parray->rgsabound[0].cElements;

                    // Indicate whether this property will be using 
                    // m_bitmaskValues.
                    info.m_bBitmask = 
                        vValues.parray->rgsabound[0].cElements != 0;

                    if (info.m_bBitmask)
                        info.m_bitmaskValues.SetSize(
                            vValues.parray->rgsabound[0].cElements);

                    for (int i = 0; i < vValues.parray->rgsabound[0].cElements;
                        i++)
                    {
                        CString      strValue;
                        CBitmaskInfo &value = info.m_bitmaskValues[i];

                        if (bUsingBitmap)
                            value.m_dwBitmaskValue = 
                                BitmaskStrToValue(((BSTR*)(vMap.parray->pvData))[i]);
                        else
                            value.m_dwBitmaskValue = 1 << i;

                        value.m_strName = ((BSTR*)(vValues.parray->pvData))[i];
                    }
                }
            }
        }
        
        SafeArrayDestroy(pArr);
    }

    // Load up the methods.
    m_ppProps->LoadMethods(pClass);

    return hr;
}


/////////////////////////////////////////////////////////////////////////////
// COpWrap

COpWrap::COpWrap() :
    m_nCount(0),
    m_status(WBEM_STATUS_COMPLETE),
    m_nExpectedStatusCalls(0),
    m_lRef(0)
{
}

COpWrap::COpWrap(
    WMI_OP_TYPE type, 
    LPCTSTR szText,
    BOOL bOption) :
    m_nCount(0),
    m_strOpText(szText),
    m_type(type),
    m_status(WBEM_STATUS_COMPLETE),
    m_bOption(bOption),
    m_nExpectedStatusCalls(0),
    m_lRef(0)
{
    Init();
}

COpWrap::~COpWrap()
{
}

STDMETHODIMP_(ULONG) CObjSink::AddRef(void) 
{ 
    LONG lRet = InterlockedIncrement(&m_lRef);

    //Trace("Addref = %d", m_lRef);

    return lRet; 
}

STDMETHODIMP_(ULONG) CObjSink::Release(void) 
{ 
    LONG lRet = InterlockedDecrement(&m_lRef);

    //Trace("Release = %d", m_lRef);

    if (lRet == 0)
        delete this;

    return lRet; 
}

HRESULT STDMETHODCALLTYPE CObjSink::Indicate(
    LONG lObjectCount,
    IWbemClassObject **ppObjArray)
{
    return m_pWrap->Indicate(lObjectCount, ppObjArray);
}

HRESULT STDMETHODCALLTYPE CObjSink::SetStatus(
    LONG lFlags,
    HRESULT hResult, 
    BSTR strParam, 
    IWbemClassObject *pObjParam)
{
    return m_pWrap->SetStatus(lFlags, hResult, strParam, pObjParam);
}

const COpWrap& COpWrap::operator=(const COpWrap &other)
{
    m_strOpText = other.m_strOpText;
    m_type = other.m_type;
    m_bOption = other.m_bOption;

    return *this;
}

HRESULT COpWrap::Execute(IWbemServices *pNamespace)
{
    _bstr_t strWQL = L"WQL",
            strText = m_strOpText;

    m_hr = S_OK;

    m_pNamespace = pNamespace;

    m_nCount = 0;
    m_status = WBEM_STATUS_PROGRESS;

    m_strProps.RemoveAll();
    m_piDisplayCols.RemoveAll();

    m_mapClassToProps.Flush();

    m_hr = S_OK;

    m_nExpectedStatusCalls++;

    CObjSink *pSink = new CObjSink(this);

    m_pObjSink = pSink;
    
    // It seems like WMI never does this.  Why?
    //pSink->AddRef();

    switch(m_type)
    {
        case WMI_QUERY:
            m_hr = 
                pNamespace->ExecQueryAsync(
                    strWQL,
                    strText,
                    WBEM_FLAG_USE_AMENDED_QUALIFIERS,
                    NULL,
                    m_pObjSink);
                    //(IWbemObjectSink*) this);
            break;

        case WMI_EVENT_QUERY:
            m_hr = 
                pNamespace->ExecNotificationQueryAsync(
                    strWQL,
                    strText,
                    WBEM_FLAG_USE_AMENDED_QUALIFIERS |
                        (m_bOption ? WBEM_FLAG_MONITOR : 0),
                    NULL,
                    m_pObjSink);
                    //(IWbemObjectSink*) this);
            break;

        case WMI_ENUM_OBJ:
            m_hr = 
                pNamespace->CreateInstanceEnumAsync(
                    strText,
                    //WBEM_FLAG_FORWARD_ONLY | // WMI doesn't seem to like this.  Why?
                    WBEM_FLAG_USE_AMENDED_QUALIFIERS |
                        (m_bOption ? WBEM_FLAG_DEEP : WBEM_FLAG_SHALLOW),
                    NULL,
                    m_pObjSink);
                    //(IWbemObjectSink*) this);
            break;

        case WMI_GET_OBJ:
            m_hr = 
                pNamespace->GetObjectAsync(
                    strText,
                    WBEM_FLAG_USE_AMENDED_QUALIFIERS,
                    NULL,
                    m_pObjSink);
                    //(IWbemObjectSink*) this);
            break;

        case WMI_ENUM_CLASS:
        {
            // First see if we can get the class.  If we do, set m_strOpText
            // to be the 'pretty' class name.
            IWbemClassObject *pClass = NULL;

            m_hr = 
                pNamespace->GetObject(
                    strText,
                    0,
                    NULL,
                    &pClass,
                    NULL);

            if (SUCCEEDED(m_hr))
            {
                _variant_t var;

                pClass->Get(
                    L"__CLASS",
                    0,
                    &var,
                    NULL,
                    NULL);

                if (var.vt == VT_BSTR)
                    m_strOpText = var.bstrVal;

                pClass->Release();
            }

            m_hr =
                pNamespace->CreateClassEnumAsync(
                    strText,
                        //WBEM_FLAG_FORWARD_ONLY | // WMI doesn't seem to like this.  Why?
                    WBEM_FLAG_USE_AMENDED_QUALIFIERS |
                        m_bOption ? WBEM_FLAG_DEEP : WBEM_FLAG_SHALLOW,
                    NULL,
                    m_pObjSink);
                    //(IWbemObjectSink*) this);

            break;
        }
        
        case WMI_GET_CLASS:
            m_hr = 
                pNamespace->GetObjectAsync(
                    strText,
                    WBEM_FLAG_USE_AMENDED_QUALIFIERS,
                    NULL,
                    m_pObjSink);
                    //(IWbemObjectSink*) this);
            break;

        case WMI_CREATE_CLASS:
        {
            BSTR             bstrClass = *(LPCWSTR) strText == 0 ? NULL : 
                                            (BSTR) strText;
            IWbemClassObject *pSuperClass = NULL;

            // Get the superclass.
            m_hr = 
                pNamespace->GetObject(
                    bstrClass,
                    WBEM_FLAG_USE_AMENDED_QUALIFIERS,
                    NULL,
                    &pSuperClass,
                    NULL);

            if (SUCCEEDED(m_hr))
            {
                IWbemClassObject *pClass = NULL;
                
                // If bstrClass isn't null then we didn't get a top-level 
                // class, which means we now need to spawn a derived class.
                if (bstrClass)
                {
                    m_hr =
                        pSuperClass->SpawnDerivedClass(
                            0,
                            &pClass);

                    if (SUCCEEDED(m_hr))
                    {
                        Indicate(1, &pClass);

                        // Show the user this object already needs to be saved.
                        m_objInfo.SetModified(TRUE);
                        
                        pClass->Release();

                        // Fake the status callback.
                        SetStatus(WBEM_STATUS_COMPLETE, m_hr, NULL, NULL);
                    }
                }
                else
                {
                    Indicate(1, &pSuperClass);

                    // Fake the status callback.
                    SetStatus(WBEM_STATUS_COMPLETE, m_hr, NULL, NULL);
                }

                pSuperClass->Release();
            }

            break;
        }

        case WMI_CREATE_OBJ:
        {
            IWbemClassObject *pClass = NULL;

            // Get the superclass.
            m_hr = 
                pNamespace->GetObject(
                    strText,
                    WBEM_FLAG_USE_AMENDED_QUALIFIERS,
                    NULL,
                    &pClass,
                    NULL);


            if (SUCCEEDED(m_hr))
            {
                IWbemClassObject *pObject = NULL;
                
                m_hr =
                    pClass->SpawnInstance(
                        0,
                        &pObject);

                if (SUCCEEDED(m_hr))
                {
                    Indicate(1, &pObject);

                    // Show the user this object already needs to be saved.
                    m_objInfo.SetModified(TRUE);
                        
                    pObject->Release();

                    // Fake the status callback.
                    SetStatus(WBEM_STATUS_COMPLETE, m_hr, NULL, NULL);
                }

                pClass->Release();
            }

            break;
        }
    }

    if (FAILED(m_hr))
    {
        IWbemClassObjectPtr pErrorObj;
        
        pErrorObj.Attach(GetWMIErrorObject(), FALSE);

        if (!m_nExpectedStatusCalls)
            m_nExpectedStatusCalls = 1;

        SetStatus(WBEM_STATUS_COMPLETE, m_hr, NULL, pErrorObj);
    }

    return m_hr;
}

HRESULT COpWrap::RefreshPropInfo(CObjInfo *pInfo)
{
    if (!pInfo->IsInstance())
    {
        HRESULT hr = pInfo->LoadProps(m_pNamespace);

        if (SUCCEEDED(hr))
            AddPropsToGlobalIndex(pInfo);

        return hr;
    }
    else
        return S_OK;
}

HRESULT COpWrap::LoadPropInfo(CObjInfo *pInfo)
{
    CString strClass = pInfo->GetStringPropValue(L"__CLASS");

    m_cs.Lock();

    CPropInfoArray *pProps;

    if (!m_mapClassToProps.Lookup(strClass, pProps))
    {
        // Since it's not in our map it must have gotten deleted.
        pInfo->SetProps(NULL);

        pInfo->LoadProps(m_pNamespace);

        pProps = pInfo->GetProps();
        m_mapClassToProps.SetAt(strClass, pProps);

        AddPropsToGlobalIndex(pInfo);
    }
    else
        pInfo->SetProps(pProps);

    m_cs.Unlock();

    return S_OK;
}

HRESULT STDMETHODCALLTYPE COpWrap::Indicate(
    LONG lObjectCount,
    IWbemClassObject **ppObjArray)
{
    for (LONG i = 0; i < lObjectCount; i++, m_nCount++)
    {
        CObjPtr ptr(ppObjArray[i]);

        m_listObj.AddTail(ptr);

        CObjInfo *pInfo;
        
        if (!IsObject())
            pInfo = new CObjInfo;
        else
            pInfo = &m_objInfo;

        pInfo->SetObj(ppObjArray[i]);
        pInfo->SetBaseImage(m_iChildImage);

        LoadPropInfo(pInfo);

        g_pOpView->PostMessage(WM_OBJ_INDICATE, (WPARAM) this, (LPARAM) pInfo);
    }

    return S_OK;
}

CString COpWrap::GetWbemErrorText(HRESULT hres)
{
    CString strRet,
            strError,
            strFacility;
	
    IWbemStatusCodeText *pStatus = NULL;

    SCODE sc = CoCreateInstance(
                  CLSID_WbemStatusCodeText, 
                  0, 
                  CLSCTX_INPROC_SERVER,
				  IID_IWbemStatusCodeText, 
                  (LPVOID *) &pStatus);
	
	if (sc == S_OK)
	{
		BSTR bstr = NULL;
		
        if (SUCCEEDED(pStatus->GetErrorCodeText(hres, 0, 0, &bstr)))
        {
			strError = bstr;
            SysFreeString(bstr);
		}

		if (SUCCEEDED(pStatus->GetFacilityCodeText(hres, 0, 0, &bstr)))
		{
			strFacility = bstr;
			SysFreeString(bstr);
		}

		pStatus->Release();
	}

    if (!strError.IsEmpty() && !strFacility.IsEmpty())
    {
        strRet.FormatMessage(
            IDS_ERROR_FORMAT, 
            hres,
            (LPCSTR) strFacility,
            (LPCSTR) strError);
    }
    else
    {
        strRet.FormatMessage(IDS_ERROR_FAILED, hres);
    }

    return strRet;
}

HRESULT STDMETHODCALLTYPE COpWrap::SetStatus(
    LONG lFlags,
    HRESULT hResult, 
    BSTR strParam, 
    IWbemClassObject *pObjParam)
{
    if (m_nExpectedStatusCalls)
    {
        m_status = lFlags;

        m_hr = hResult;

        if (SUCCEEDED(hResult))
            m_strErrorText.Empty();
        else
            m_strErrorText = GetWbemErrorText(hResult);

        g_pOpView->PostMessage(WM_OP_STATUS, (WPARAM) this, 0);

        m_nExpectedStatusCalls--;

        m_pErrorObj = pObjParam;
    }

    return S_OK;
}

void COpWrap::SetHoldsObjects()
{
    switch(m_type)
    {
        case WMI_QUERY:
        {
            CString strQuery = m_strOpText;

            strQuery.MakeUpper();
            strQuery.TrimLeft();
            if (strQuery.Find(_T("ASSOCIATORS")) != -1 ||
                strQuery.Find(_T("REFERENCES")) != -1)
                m_bShowPathsOnly = TRUE;
            else
                m_bShowPathsOnly = FALSE;

            break;
        }

        case WMI_ENUM_OBJ:
        case WMI_GET_OBJ:
        case WMI_EVENT_QUERY:
        case WMI_CREATE_OBJ:
            m_bShowPathsOnly = FALSE;
            break;

        default:
        case WMI_ENUM_CLASS:
        case WMI_GET_CLASS:
        case WMI_CREATE_CLASS:
            m_bShowPathsOnly = TRUE;
    }
}

void COpWrap::GetPropValue(
    CObjInfo *pInfo,
    int iGlobalIndex, 
    CString &strValue,
    BOOL bTranslate)
{
    int iIndex;

    if (pInfo->GetProps()->m_mapGlobalToLocalIndex.Lookup(iGlobalIndex, iIndex))
        pInfo->GetPropValue(iIndex, strValue, bTranslate);
}

CString COpWrap::GetClassName()
{
    CString strRet;

    if (m_type != WMI_ENUM_CLASS)
    {
        if (m_listObj.GetCount())
        {
            CObjPtr    &pObj = m_listObj.GetAt(m_listObj.GetHeadPosition());
            _variant_t var;

            if (SUCCEEDED(pObj->Get(
                L"__CLASS",
                0,
                &var,
                NULL,
                NULL)) && var.vt == VT_BSTR)
            {
                strRet = var.bstrVal;
            }
        }
    }
    else
    {
        return m_strOpText;
    }

    return strRet;
}

CString COpWrap::GetCaption()
{
    CString strRet;

    switch(m_type)
    {
        case WMI_CREATE_CLASS:
            if (!m_strOpText.IsEmpty())
                strRet.Format(IDS_SUBCLASS_OF, (LPCTSTR) m_strOpText);
            else
                strRet.LoadString(IDS_TOPLEVEL_CLASS);

            break;

        case WMI_GET_CLASS:
            strRet = GetClassName();

            if (strRet.IsEmpty())
                strRet = m_strOpText;
                
            break;             

        case WMI_ENUM_CLASS:
            if (!m_strOpText.IsEmpty())
                strRet.Format(IDS_ENUM_CLASS_CAPTION, (LPCTSTR) m_strOpText);
            else
                strRet.LoadString(m_bOption ? IDS_ALL_CLASSES : 
                    IDS_TOP_LEVEL_CLASSES);

            break;             

        case WMI_GET_OBJ:
        case WMI_EVENT_QUERY:
        case WMI_QUERY:
            strRet = m_strOpText;
            break;

        case WMI_CREATE_OBJ:
            strRet.Format(IDS_INSTANCE_OF, (LPCTSTR) m_strOpText);
            break;

        case WMI_ENUM_OBJ:
        {
            CString strClass = GetClassName();

            if (strClass.IsEmpty())
                strClass = m_strOpText;
                
            strRet.Format(IDS_ENUM_OBJ_CAPTION, (LPCTSTR) strClass);

            break;             
        }
    }

    return strRet;    
}

#define DEF_MAX_COLS 100

#define DEF_COL_SIZE 100

int COpWrap::GetPropIndex(LPCTSTR szName, BOOL bAddToDisplay)
{
    for (int i = 0; i <= m_strProps.GetUpperBound(); i++)
    {
        if (m_strProps[i] == szName)
            return i;
    }

    m_strProps.Add(szName);

    if (bAddToDisplay)
    {
        m_piDisplayCols.Add(i);
        
        if (m_piDisplayCols.GetUpperBound() > 
            m_piDisplayColsWidth.GetUpperBound())
        {
            m_piDisplayColsWidth.Add(DEF_COL_SIZE);
        }
    }

    return i;
}

void COpWrap::AddPropsToGlobalIndex(CObjInfo *pInfo)
{
    CPropInfoArray *ppProps = pInfo->GetProps();

    if (ppProps)
    {
        CPropInfo *pProps = ppProps->GetData();
        int       nItems = ppProps->GetSize();

        for (int i = 0; i < nItems; i++)
        {
            int iGlobalIndex = GetPropIndex(pProps[i].m_strName, 
                                !(pProps[i].m_iFlavor == WBEM_FLAVOR_ORIGIN_SYSTEM));
    
            ppProps->m_mapGlobalToLocalIndex.SetAt(iGlobalIndex, i);
        }
    }
}

void CPropInfoArray::LoadMethods(IWbemClassObject *pClass)
{
    HRESULT hr;

    // Flush the list.
    while(m_listMethods.GetCount())
        m_listMethods.RemoveHead();

    m_nStaticMethods = 0;

    if (pClass && SUCCEEDED(hr = pClass->BeginMethodEnumeration(0)))
    {
        BSTR pName = NULL;

        while(1)
        {
            hr = 
                pClass->NextMethod(
                    0,
                    &pName,
                    NULL,
                    NULL);

            if (FAILED(hr) || hr == WBEM_S_NO_MORE_DATA)
                break;

            IWbemQualifierSetPtr pQuals;
            CMethodInfo          method;

            method.m_strName = pName;

            SysFreeString(pName);

            if (SUCCEEDED(hr = pClass->GetMethodQualifierSet(
                pName,
                &pQuals)))
            {
                _variant_t vStatic;

                if (SUCCEEDED(hr = pQuals->Get(
                    L"static",
                    0,
                    &vStatic,
                    NULL)) && vStatic.vt == VT_BOOL && (bool) vStatic == true)
                {
                    method.m_bStatic = TRUE;
                    m_nStaticMethods++;
                }

                _variant_t vDesc;

                if (SUCCEEDED(hr = pQuals->Get(
                    L"Description",
                    0,
                    &vDesc,
                    NULL)) && vDesc.vt == VT_BSTR)
                {
                    method.m_strDescription = vDesc.bstrVal;
                }

                m_listMethods.AddTail(method);
            }
        }
    }

}

int COpWrap::GetImage()
{
    if (m_status == WBEM_STATUS_PROGRESS)
        return m_iImageBase + 1; // + 1 == busy
    else
    {
        if (SUCCEEDED(m_hr))
            // If we're an object, use our m_objInfo to get the image.
            return IsObject() ? m_objInfo.GetImage() : m_iImageBase;
        else
            // + 2 == error
            return m_iImageBase + 2;
    }
}

void COpWrap::CancelOp(IWbemServices *pNamespace)
{
    if (m_status == WBEM_STATUS_PROGRESS)
    {
        HRESULT hr;

        if (FAILED(hr = pNamespace->CancelAsyncCall(m_pObjSink)))
        {
            //((IWbemObjectSink*) this)->Release();
                
            SetStatus(
                WBEM_STATUS_COMPLETE,
                hr, 
                NULL, 
                NULL);
        }
    }
}

IMPLEMENT_SERIAL(COpWrap, CObject, VERSIONABLE_SCHEMA|1)

void COpWrap::Serialize(CArchive &archive)
{
    if (archive.IsLoading())
    {
        int type;

        archive >> type;
        m_type = (WMI_OP_TYPE) type;

        archive >> m_strOpText;
        archive >> m_bOption;

        int nCols;

        archive >> nCols;

        if (nCols > 0)
        {
            m_piDisplayColsWidth.SetSize(nCols);

            for (int i = 0; i < nCols; i++)
            {
                int iVal;

                archive >> iVal;
                m_piDisplayColsWidth[i] = iVal;
            }
        }

        Init();
    }
    else
    {
        archive.SetObjectSchema(1);

        archive << (int) m_type;
        archive << m_strOpText;
        archive << m_bOption;

        int nCols = m_piDisplayColsWidth.GetUpperBound() + 1;

        archive << nCols;

        for (int i = 0; i < nCols; i++)
            archive << m_piDisplayColsWidth[i];
    }
}

void COpWrap::Init()
{
    m_hr = S_OK;

    SetHoldsObjects();

    switch(m_type)
    {
        case WMI_QUERY:
            m_iImageBase = IMAGE_QUERY;
            m_iChildImage = IMAGE_OBJECT;
            break;

        case WMI_ENUM_OBJ:
            m_iImageBase = IMAGE_ENUM_OBJ;
            m_iChildImage = IMAGE_OBJECT;
            break;

        case WMI_CREATE_OBJ:
        case WMI_GET_OBJ:
            m_iImageBase = IMAGE_OBJECT;
            m_iChildImage = IMAGE_OBJECT;
            break;

        case WMI_EVENT_QUERY:
            m_iImageBase = IMAGE_EVENT_QUERY;
            m_iChildImage = IMAGE_OBJECT;
            break;

        case WMI_ENUM_CLASS:
            m_iImageBase = IMAGE_ENUM_CLASS;
            m_iChildImage = IMAGE_CLASS;
            break;

        case WMI_CREATE_CLASS:
        case WMI_GET_CLASS:
            m_iImageBase = IMAGE_CLASS;
            m_iChildImage = IMAGE_CLASS;
            break;
    }
}



/////////////////////////////////////////////////////////////////////////////
// CClassToProps

CClassToProps::~CClassToProps()
{
    Flush();
}

void CClassToProps::Flush()
{
    POSITION       pos = GetStartPosition();
    CPropInfoArray *pProps;
    CString        strClass;

    while (pos)
    {
        GetNextAssoc(pos, strClass, pProps);

        delete pProps;
    }

    RemoveAll();
}


/////////////////////////////////////////////////////////////////////////////
// CPropInfo

// Copy constructor.
CPropInfo::CPropInfo(const CPropInfo& other)
{
    *this = other;
}

const CPropInfo& CPropInfo::operator=(const CPropInfo& other)
{
    m_strName = other.m_strName;
    m_iHandle = other.m_iHandle;
    m_type = other.m_type;
    m_iFlavor = other.m_iFlavor;
    m_bKey = other.m_bKey;
    m_dwExpectedSize = other.m_dwExpectedSize;
    m_vt = other.m_vt;
    m_bSigned = other.m_bSigned;
    m_bValueMap = other.m_bValueMap;
    m_bBitmask = other.m_bBitmask;
    
    // Copy the m_mapValues member.
    POSITION pos = other.m_mapValues.GetStartPosition();

    m_mapValues.RemoveAll();
    while (pos)
    {
        CString strKey,
                strValue;

        other.m_mapValues.GetNextAssoc(pos, strKey, strValue);
        m_mapValues.SetAt(strKey, strValue);
    }

    // Copy the m_bitmaskValues member.
    int nItems = other.m_bitmaskValues.GetSize();

    m_bitmaskValues.SetSize(nItems);

    for (int i = 0; i < nItems; i++)
        m_bitmaskValues[i] = other.m_bitmaskValues[i];

    return *this;
}

void CPropInfo::SetType(CIMTYPE type)
{
    m_type = type;

    m_bSigned = FALSE;

    switch(m_type & ~CIM_FLAG_ARRAY)
    {
	    default:
        case CIM_EMPTY:
            m_dwExpectedSize = 0;
            //m_dwArrayItemSize = 0;
            m_vt = VT_EMPTY;
            break;
            
	    case CIM_SINT8:
            m_bSigned = TRUE;
            m_dwExpectedSize = 1;
            // Fall through...

	    case CIM_UINT8:
            m_dwExpectedSize = 1;
            //m_dwArrayItemSize = 1;
            m_vt = VT_UI1;
            break;
            
	    case CIM_SINT16:
            m_bSigned = TRUE;
            // Fall through...

	    case CIM_CHAR16:
	    case CIM_UINT16:
            m_dwExpectedSize = 2;
            //m_dwArrayItemSize = 4;
            m_vt = VT_I2;
            break;
            
	    case CIM_SINT64:
            m_bSigned = TRUE;
            // Fall through...

	    case CIM_UINT64:
            m_dwExpectedSize = sizeof(__int64);
            //m_dwArrayItemSize = sizeof(__int64);
            m_vt = VT_I8;
            break;
            
	    case CIM_REAL32:
            m_dwExpectedSize = sizeof(float);
            //m_dwArrayItemSize = sizeof(float);
            m_vt = VT_R4;
            break;
            
	    case CIM_REAL64:
            m_dwExpectedSize = sizeof(double);
            //m_dwArrayItemSize = sizeof(double);
            m_vt = VT_R8;
            break;
            
	    case CIM_BOOLEAN:
            m_dwExpectedSize = sizeof(short);
            //m_dwArrayItemSize = sizeof(short);
            m_vt = VT_BOOL;
            break;
            
        case CIM_STRING:
	    case CIM_DATETIME:
	    case CIM_REFERENCE:
            m_dwExpectedSize = MAX_STR_SIZE;
            //m_dwArrayItemSize = sizeof(BSTR*);
            m_vt = VT_BSTR;
            break;

	    case CIM_OBJECT:
            m_dwExpectedSize = sizeof(LPVOID);
            //m_dwArrayItemSize = sizeof(BSTR*);
            m_vt = VT_UNKNOWN;
            break;
            
        case CIM_SINT32:
            m_bSigned = TRUE;
            // Fall through...

        case CIM_UINT32:
            m_dwExpectedSize = sizeof(DWORD);
            //m_dwArrayItemSize = sizeof(DWORD);
            m_vt = VT_I4;
            break;
    }

    if (m_type & CIM_FLAG_ARRAY)
        m_vt = (VARENUM) ((int) m_vt | VT_ARRAY);
}

void CPropInfo::GetPropType(
    CString &strType,
    int *piImage, 
    BOOL bIgnoreArrayFlag)
{
    DWORD dwStrID;

    *piImage = IMAGE_PROP_BINARY;
    
    switch(m_type & ~CIM_FLAG_ARRAY)
    {
	    default:
        case CIM_EMPTY:
            dwStrID = IDS_CIM_EMPTY;
            break;
            
	    case CIM_SINT8:
            dwStrID = IDS_CIM_SINT8;
            break;
            
	    case CIM_UINT8:
            dwStrID = IDS_CIM_UINT8;
            break;
            
	    case CIM_SINT16:
            dwStrID = IDS_CIM_SINT16;
            break;
            
	    case CIM_UINT16:
            dwStrID = IDS_CIM_UINT16;
            break;
            
	    case CIM_SINT64:
            dwStrID = IDS_CIM_SINT64;
            break;
            
	    case CIM_UINT64:
            dwStrID = IDS_CIM_UINT64;
            break;
            
	    case CIM_REAL32:
            dwStrID = IDS_CIM_REAL32;
            break;
            
	    case CIM_REAL64:
            dwStrID = IDS_CIM_REAL64;
            break;
            
	    case CIM_BOOLEAN:
            dwStrID = IDS_CIM_BOOLEAN;
            break;
            
	    case CIM_DATETIME:
            dwStrID = IDS_CIM_DATETIME;
            break;
            
	    case CIM_REFERENCE:
            dwStrID = IDS_CIM_REFERENCE;
            *piImage = IMAGE_PROP_OBJECT;
            break;
            
	    case CIM_CHAR16:
            dwStrID = IDS_CIM_CHAR16;
            break;
            
	    case CIM_OBJECT:
            dwStrID = IDS_CIM_OBJECT;
            break;
            
        case CIM_STRING:
            dwStrID = IDS_CIM_STRING;
            *piImage = IMAGE_PROP_TEXT;
            break;

        case CIM_UINT32:
            dwStrID = IDS_CIM_UINT32;
            break;

        case CIM_SINT32:
            dwStrID = IDS_CIM_SINT32;
            break;
    }

    strType.LoadString(dwStrID);

    if ((m_type & CIM_FLAG_ARRAY) && !bIgnoreArrayFlag)
    {
        CString strArray;

        strArray.LoadString(IDS_CIM_ARRAY);
        strType += _T(" | ");
        strType += strArray;
    }

    if (m_bKey)
        *piImage = *piImage + 1;
}

DWORD64 ato64u(LPCTSTR szVal)
{
    DWORD64 dwRet = 0;

    _stscanf(szVal, _T("%I64u"), &dwRet);

    return dwRet;
}

BOOL CPropInfo::SetArrayItem(VARIANT *pVar, DWORD dwIndex, DWORD dwValue)
{
    ASSERT(m_vt & VT_ARRAY);
    ASSERT(pVar->vt & VT_ARRAY);
    ASSERT(dwIndex < pVar->parray->rgsabound[0].cElements);

    DWORD  dwArrayItemSize = GetArrayItemSize((VARENUM) pVar->vt);
    LPBYTE pDest = (LPBYTE) pVar->parray->pvData + (dwArrayItemSize * dwIndex);
    BOOL   bRet = TRUE;

    switch(dwArrayItemSize)
    {
        case 1:
            *(char*) pDest = dwValue;
            break;

        case 2:
            *(short*) pDest = dwValue;
            break;

        case 4:
            *(int*) pDest = dwValue;
            break;

        default:
            bRet = FALSE;
    }

    return bRet;
}

DWORD CPropInfo::GetArrayItem(VARIANT *pVar, DWORD dwIndex)
{
    ASSERT(m_vt & VT_ARRAY);
    ASSERT(pVar->vt & VT_ARRAY);
    ASSERT(dwIndex < pVar->parray->rgsabound[0].cElements);

    DWORD  dwArrayItemSize = GetArrayItemSize((VARENUM) pVar->vt);
    LPBYTE pSrc = (LPBYTE) pVar->parray->pvData + 
                    (dwArrayItemSize * dwIndex);
    DWORD  dwRet = 0;

    switch(dwArrayItemSize)
    {
        case 1:
            dwRet = *(char*) pSrc;
            break;

        case 2:
            dwRet = *(short*) pSrc;
            break;

        case 4:
            dwRet = *(int*) pSrc;
            break;
    }

    return dwRet;
}

// This one doesn't handle arrays since we'll never go from a single string to
// an array.
BOOL CPropInfo::StringToVariant(LPCSTR szValue, VARIANT *pVar, BOOL bTranslate)
{
    BOOL    bRet;
    VARENUM typeRaw = (VARENUM) (m_vt & ~VT_ARRAY);

    VariantClear(pVar);

    pVar->vt = typeRaw;
    if (pVar->vt == VT_I8)
        pVar->vt = VT_BSTR;

    LPVOID pData = &V_BSTR(pVar);

    bRet = StringToVariantBlob(szValue, pData, bTranslate);
    
    return bRet;        
}

// TODO: Need to be able to accept dates with month names.
LPTSTR IntToDMTF(LPTSTR szOut, int iValue, int iDigits)
{
    _ASSERT(iDigits <= 6 && iDigits >= 0);

    if (iValue == -1)
    {
        memcpy(szOut, _T("******"), iDigits * sizeof(TCHAR));
        szOut[iDigits] = 0;
    }
    else
    {
        char szFormat[100] = _T("%0*d");

        szFormat[2] = '0' + iDigits;
        
        wsprintf(szOut, szFormat, iValue);
    }

    return szOut;
}

enum LOCALE_TOKEN
{
    L_UNKNOWN,
    
    L_MONTH_1,
    L_MONTH_2,
    L_MONTH_3,
    L_MONTH_4,
    L_MONTH_5,
    L_MONTH_6,
    L_MONTH_7,
    L_MONTH_8,
    L_MONTH_9,
    L_MONTH_10,
    L_MONTH_11,
    L_MONTH_12,

    L_DATE_SEP,
    L_TIME_SEP,

    L_AM,
    L_PM,

    L_UTC
};

class CLocaleInfo
{
public:
    TCHAR szDateSep[MAX_PATH],
          szTimeSep[MAX_PATH],
          szPM[MAX_PATH],
          szAM[MAX_PATH],
          szUTC[MAX_PATH],
          szLongMonths[12][MAX_PATH],
          szShortMonths[12][MAX_PATH];

    CLocaleInfo() { Init(); }
    
    void Init();
    LOCALE_TOKEN GetNextToken(LPCTSTR *ppszCurrent);

protected:
    BOOL CheckAndIncrement(LPCTSTR szCheckAgainst, LPCTSTR *ppszCurrent);
};

LOCALE_TOKEN CLocaleInfo::GetNextToken(LPCTSTR *ppszCurrent)
{
    if (CheckAndIncrement(szDateSep, ppszCurrent))
        return L_DATE_SEP;
    else if (CheckAndIncrement(szTimeSep, ppszCurrent))
        return L_TIME_SEP;
    else if (CheckAndIncrement(szAM, ppszCurrent))
        return L_AM;
    else if (CheckAndIncrement(szPM, ppszCurrent))
        return L_PM;
    else if (CheckAndIncrement(szUTC, ppszCurrent))
        return L_UTC;
    else
    {
        for (int i = 0; i < 12; i++)
        {
            if (CheckAndIncrement(szLongMonths[i], ppszCurrent))
                return (LOCALE_TOKEN) (L_MONTH_1 + i);
        }

        for (i = 0; i < 12; i++)
        {
            if (CheckAndIncrement(szShortMonths[i], ppszCurrent))
                return (LOCALE_TOKEN) (L_MONTH_1 + i);
        }
    }

    return L_UNKNOWN;
}

BOOL CLocaleInfo::CheckAndIncrement(LPCTSTR szCheckAgainst, LPCTSTR *ppszCurrent)
{
    // Get past the spaces.
    while (isspace(**ppszCurrent))
        (*ppszCurrent)++;
            
    int  nLen = _tcslen(szCheckAgainst);
    BOOL bRet;

    if (!_tcsncmp(szCheckAgainst, *ppszCurrent, nLen))
    {
        bRet = TRUE;
        *ppszCurrent += nLen;
    }
    else
        bRet = FALSE;

    return bRet;
        
}

void CLocaleInfo::Init()
{
    GetLocaleInfo(
        LOCALE_USER_DEFAULT,
        LOCALE_SDATE,
        szDateSep,
        sizeof(szDateSep) / sizeof(TCHAR));
    _tcsupr(szDateSep);

    GetLocaleInfo(
        LOCALE_USER_DEFAULT,
        LOCALE_STIME,
        szTimeSep,
        sizeof(szTimeSep) / sizeof(TCHAR));
    _tcsupr(szTimeSep);

    GetLocaleInfo(
        LOCALE_USER_DEFAULT,
        LOCALE_S2359,
        szPM,
        sizeof(szPM) / sizeof(TCHAR));
    _tcsupr(szPM);

    GetLocaleInfo(
        LOCALE_USER_DEFAULT,
        LOCALE_S1159,
        szAM,
        sizeof(szAM) / sizeof(TCHAR));
    _tcsupr(szAM);

    for (int i = 0; i < 12; i++)
    {
        GetLocaleInfo(
            LOCALE_USER_DEFAULT,
            LOCALE_SMONTHNAME1 + i,
            szLongMonths[i],
            sizeof(szLongMonths[0]) / sizeof(TCHAR));
        _tcsupr(szLongMonths[i]);

        GetLocaleInfo(
            LOCALE_USER_DEFAULT,
            LOCALE_SABBREVMONTHNAME1 + i,
            szShortMonths[i],
            sizeof(szShortMonths[0]) / sizeof(TCHAR));
        _tcsupr(szShortMonths[i]);
    }

    CString strUTC;

    strUTC.LoadString(IDS_UTC_TOKEN);

    lstrcpy(szUTC, strUTC);
}

enum DATE_STATE
{
    S_BEGIN,
    S_MONTH,
    S_DAY,
    S_YEAR,
    S_HOUR,
    S_MINUTE,
    S_SECOND,
    S_NEED_UTC,
};

BOOL DoAMPM(LOCALE_TOKEN token, int *piHour, DATE_STATE *pState)
{
    BOOL bRet;

    ASSERT(*piHour != -1);

    if (*pState == S_HOUR || *pState == S_MINUTE || *pState == S_SECOND)
    {
        bRet = TRUE;

        if (*piHour == 12 && token == L_AM)
            *piHour = 0;
        else if (*piHour < 12 && token == L_PM)
            *piHour += 12;

        *pState = S_NEED_UTC;
    }
    else
        bRet = FALSE;

    return bRet;
}

BOOL DoUTC(int *piOffset, LPCTSTR *pszCurrent, TCHAR *pcOffsetSign, DATE_STATE *pState)
{
    // Until we prove otherwise...
    BOOL  bRet = FALSE;
    TCHAR cSign = **pszCurrent;

    if (cSign == '+' || cSign == '-')
    {
        // Get past the sign.
        (*pszCurrent)++;

        if (isdigit(**pszCurrent))
        {
            *piOffset = _ttoi(*pszCurrent) * 60;

            // Get past the number.
            while (isdigit(**pszCurrent))
                (*pszCurrent)++;
                        
            if (**pszCurrent != ')')
            {
                // Get past the separator.
                while (!isdigit(**pszCurrent) && **pszCurrent)
                    (*pszCurrent)++;
                        
                *piOffset += _ttoi(*pszCurrent);
            }
                    
            // Find the end of this thing.
            while (**pszCurrent != ')' && **pszCurrent)
                (*pszCurrent)++;
                        
            if (**pszCurrent == ')')
            {
                *pcOffsetSign = cSign;

                *pState = S_BEGIN;

                (*pszCurrent)++;

                bRet = TRUE;
            }
        }
    }

    return bRet;
}

BOOL StringDateTimeToDMTF(LPCTSTR szDateTime, CString &strDateTime)
{
    CLocaleInfo info;
    DATE_STATE  state = S_BEGIN;
    BOOL        bMonthFromString = FALSE,
                bPM = FALSE,
                bAM = FALSE;
    int         iDay = -1,
                iMonth = -1,
                iYear = -1,
                iHour = -1,
                iMin = -1,
                iSec = -1,
                iMicro = -1,
                iOffset = -1;
    char        szOffsetSign[2] = _T("*");
    BOOL        bRet = TRUE;
    CString     strTemp = szDateTime;

    // So we can do case insensitive compares.
    strTemp.MakeUpper();

    LPCTSTR szCurrent = strTemp;

    while (*szCurrent && bRet)
    {
        while (isspace(*szCurrent))
            szCurrent++;
            
        ////////////////////////////////////////////////////
        // State action == number found
        if (isdigit(*szCurrent))
        {
            // Reset if we were potentially looking for a UTC and we didn't get it.
            if (state == S_NEED_UTC)
                state = S_BEGIN;

            int iNumber = _ttoi(szCurrent);
            
            // Get past the current number.
            while (isdigit(*szCurrent))
                szCurrent++;
                        
            LOCALE_TOKEN token = info.GetNextToken(&szCurrent);

            switch(state)
            {
                ////////////////////////////////////////////////////
                // Begin state
                case S_BEGIN:
                    if (token == L_TIME_SEP)
                    {
                        iHour = iNumber;
                        state = S_HOUR;
                    }
                    else if (token == L_DATE_SEP || token == L_UNKNOWN)
                    {
                        iMonth = iNumber;
                        state = S_MONTH;
                    }
                    else if (token == L_AM || token == L_PM)
                    {
                        iHour = iNumber;
                        
                        state = S_HOUR;
                        bRet = DoAMPM(token, &iHour, &state);
                        //bAM = token == L_AM;
                        //bPM = !bAM;

                        //state = S_NEED_UTC;
                    }
                    else
                        bRet = FALSE;

                    break;

                ////////////////////////////////////////////////////
                // Date states
                case S_MONTH:
                    if (token == L_DATE_SEP)
                    {
                        iDay = iNumber;
                        state = S_DAY;
                    }
                    else if (token == L_UNKNOWN)
                    {
                        iYear = iNumber;
                        state = S_BEGIN;
                    }
                    else
                        bRet = FALSE;

                    break;

                case S_DAY:
                    if (token == L_UNKNOWN)
                    {
                        iYear = iNumber;
                        state = S_BEGIN;
                    }
                    else
                        bRet = FALSE;

                    break;

                //case S_YEAR:
                //    iYear = iNumber;
                //    state = S_BEGIN;
                //    break;


                ////////////////////////////////////////////////////
                // Time states
                case S_HOUR:
                    iMin = iNumber;

                    if (token == L_TIME_SEP)
                        state = S_MINUTE;
                    else if (token == L_AM || token == L_PM)
                        bRet = DoAMPM(token, &iHour, &state);
                    else if (token == L_UTC)
                        bRet = DoUTC(&iOffset, &szCurrent, &szOffsetSign[0], &state);
                    else
                        bRet = FALSE;

                    break;

                case S_MINUTE:
                    iSec = iNumber;

                    if (token == L_AM || token == L_PM)
                        bRet = DoAMPM(token, &iHour, &state);
                    else if (token == L_UTC)
                        bRet = DoUTC(&iOffset, &szCurrent, &szOffsetSign[0], &state);
                    else
                        bRet = FALSE;

                    break;

                default:
                    bRet = FALSE;
                    break;
            }
        } // End of state action == number found.
        else
        {
            ////////////////////////////////////////////////////
            // State action == some token
            LOCALE_TOKEN token = info.GetNextToken(&szCurrent);

            // Reset if we were potentially looking for a UTC and we didn't get it.
            if (state == S_NEED_UTC && token != L_UTC)
                state = S_BEGIN;

            // token == string month found
            if (token >= L_MONTH_1 && token <= L_MONTH_12)
            {
                // Move past any non-digits beyond the string date, such as a 
                // separator or a comma, etc.
                while (!isdigit(*szCurrent) && *szCurrent)
                    szCurrent++;

                if (state == S_BEGIN)
                {
                    iMonth = token - L_MONTH_1 + 1;
                    state = S_MONTH;
                    bMonthFromString = TRUE;
                }
                else if (state == S_MONTH && !bMonthFromString)
                {
                    iDay = iMonth;
                    iMonth = token - L_MONTH_1 + 1;
                    state = S_DAY;
                }
                else
                    bRet = FALSE;
            }
            else if (token == L_AM || token == L_PM)
            {
                if (state == S_HOUR || state == S_MINUTE || state == S_SECOND)
                {
                    //bAM = token == L_AM;
                    //bPM = !bAM;
                    bRet = DoAMPM(token, &iHour, &state);

                    //state = S_NEED_UTC;
                }
                else
                    bRet = FALSE;
            }
            else if (state == S_NEED_UTC)
            {
                bRet = DoUTC(&iOffset, &szCurrent, &szOffsetSign[0], &state);
            }
            else if (token == L_UNKNOWN)
                szCurrent++;
            else
                bRet = FALSE;
        }
    }

    // At this point, we may need to juggle our day and month around, depending
    // on what the order is for the current locale.
    if (iDay != -1 && iMonth != -1 && iYear != -1)
    {
        TCHAR szOrder[2] = _T("0");

        GetLocaleInfo(
            LOCALE_USER_DEFAULT,
            LOCALE_IDATE,
            szOrder,
            sizeof(szOrder) / sizeof(TCHAR));

        // dd/mm/yy
        if (*szOrder == '1')
        {
            int iTemp = iDay;

            iDay = iMonth;
            iMonth = iDay;
        }
        // yy/mm/dd
        else if (*szOrder == '2')
        {
            int iTemp = iDay;

            iDay = iYear;
            iYear = iDay;
        }
    }


    // Finally, splice it all together.
    TCHAR szOut[100] = _T(""),
          szTemp[20];
    
    lstrcat(szOut, IntToDMTF(szTemp, iYear, 4));
    lstrcat(szOut, IntToDMTF(szTemp, iMonth, 2));
    lstrcat(szOut, IntToDMTF(szTemp, iDay, 2));
    lstrcat(szOut, IntToDMTF(szTemp, iHour, 2));
    lstrcat(szOut, IntToDMTF(szTemp, iMin, 2));
    lstrcat(szOut, IntToDMTF(szTemp, iSec, 2));
    lstrcat(szOut, _T("."));
    lstrcat(szOut, IntToDMTF(szTemp, iMicro, 6));
    lstrcat(szOut, szOffsetSign);
    lstrcat(szOut, IntToDMTF(szTemp, iOffset, 3));

    strDateTime = szOut;

    return TRUE;
}

BOOL IsDMTF(LPCTSTR szDate)
{
    for (int i = 0; i < 14; i++)
    {
        if (!isdigit(szDate[i]) && szDate[i] != '*')
            return FALSE;
    }

    if (szDate[14] != '.')
        return FALSE;

    for (i = 15; i < 21; i++)
    {
        if (!isdigit(szDate[i]) && szDate[i] != '*')
            return FALSE;
    }

    if (szDate[21] != '-' && szDate[21] != '+' && szDate[21] != '*')
        return FALSE;

    for (i = 22; i < 25; i++)
    {
        if (!isdigit(szDate[i]) && szDate[i] != '*')
            return FALSE;
    }

    return TRUE;
}

BOOL CPropInfo::StringToVariantBlob(LPCTSTR szValue, LPVOID pData, 
    BOOL bTranslate)
{
    BOOL    bRet = TRUE;
    char    *szTemp;
    CString strValue;
    VARENUM typeRaw = (VARENUM) (m_vt & ~VT_ARRAY);

    // This one is special-cased from the others because the value will
    // usually be in a localized form, even if bTranslate == FALSE.
    if (typeRaw == VT_BOOL)
    {
        CString strTrue;

        strTrue.LoadString(IDS_TRUE);

        if (!lstrcmpi(strTrue, szValue))
            *(short*) pData = VARIANT_TRUE;
        else
            *(short*) pData = atoi(szValue) ? VARIANT_TRUE : VARIANT_FALSE;
    } 
    else
    {
        // Translate if necessary.
        if (bTranslate && m_bValueMap)
        {
            // TODO: We could make this faster if we added a reverse lookup 
            // map.  For now we'll do a sequential search.
            POSITION pos = m_mapValues.GetStartPosition();
            CString  strKey;

            while(pos)
            {
                m_mapValues.GetNextAssoc(pos, strKey, strValue);
                if (!lstrcmpi(szValue, strValue))
                {
                    szValue = strKey;
                    break;
                }
            }
        }

        switch(typeRaw)
        {
            case VT_I8:
            case VT_BSTR:
            {
                if (GetRawCIMType() != CIM_DATETIME)
                    *(BSTR*) pData = _bstr_t(szValue).copy();
                else
                {
                    if (!IsDMTF(szValue))
                    {
                        CString strRet;
                        
                        StringDateTimeToDMTF(szValue, strRet);

                        _ASSERT(IsDMTF(strRet));
                    
                        *(BSTR*) pData = strRet.AllocSysString();
                    }
                    else
                        *(BSTR*) pData = _bstr_t(szValue).copy();
                }

                break;
            }

            case VT_R8:
                *(double*) pData = atof(szValue);
                break;

            case VT_R4:
                *(float*) pData = atof(szValue);
                break;

            case VT_UI1:
                *(char*) pData = m_bSigned ? atoi(szValue) : strtoul(szValue, &szTemp, 10);
                break;
             
            case VT_I2:
                *(short*) pData = m_bSigned ? atoi(szValue) : strtoul(szValue, &szTemp, 10);
                break;

            case VT_I4:
                *(int*) pData = m_bSigned ? atoi(szValue) : strtoul(szValue, &szTemp, 10);
                break;

            //case VT_I8:
            //    *(DWORD64*) pData = m_bSigned ? _atoi64(szValue) : ato64u(szValue);
            //    break;
        }
    }

    return bRet;        
}

// We have to pass the vt as contained on the actual variant because WMI sometimes
// uses a different VARENUM for Gets/Puts (go figure).
BOOL CPropInfo::VariantBlobToString(VARENUM vt, LPVOID pData, CString &strValue, 
    BOOL bTranslate, BOOL bQuoteStrings)
{
    VARENUM vtRaw = (VARENUM) (vt & ~VT_ARRAY);

    strValue.Empty();

    switch(vtRaw)
    {
        case VT_BSTR:
            strValue = *(BSTR*) pData;
            break;

        case VT_R8:
            strValue.Format(_T("%.5f"), *(double*) pData);
            break;

        case VT_R4:
            strValue.Format(_T("%.5f"), *(float*) pData);
            break;

        case VT_UI1:
        {
            if (m_bSigned)
                strValue.Format(_T("%d"), *(char*) pData);
            else
                strValue.Format(_T("%u"), *(BYTE*) pData);

            break;
        }
             
        case VT_I2:
        {
            if (m_bSigned)
                strValue.Format(_T("%d"), *(short*) pData);
            else
                strValue.Format(_T("%u"), *(WORD*) pData);

            break;
        }

        case VT_I4:
        {
            if (m_bSigned)
                strValue.Format(_T("%d"), *(int*) pData);
            else
                strValue.Format(_T("%u"), *(DWORD*) pData);

            break;
        }

        case VT_I8:
        {
            if (m_bSigned)
                strValue.Format(_T("%I64d"), *(__int64*) pData);
            else
                strValue.Format(_T("%I64u"), *(DWORD64*) pData);

            break;
        }

        case VT_BOOL:
            strValue.LoadString(*(short*) pData ? IDS_TRUE : IDS_FALSE);
            break;

        case VT_UNKNOWN:
            //strValue.Format(IDS_EMBEDDED_OBJECT, *(IUnknown*) pData);
            strValue = GetEmbeddedObjectText(*(IUnknown**) pData);
            break;
    }

    if (bTranslate && !strValue.IsEmpty())
    {
        if (m_bValueMap)
        {
            CString strKey = strValue;

            m_mapValues.Lookup(strKey, strValue);
        }
        else if (m_bBitmask)
        {
            DWORD nSize = m_bitmaskValues.GetSize(),
                  dwValue = *(DWORD*) pData;

            // Clear this out.
            strValue.Empty();

            for (int i = 0; i < nSize; i++)
            {
                CString strPart;

                if (dwValue & m_bitmaskValues[i].m_dwBitmaskValue)
                {
                    if (!strValue.IsEmpty())
                        strValue += _T(" | ");

                    strValue += m_bitmaskValues[i].m_strName;
                }
            }
        }
        else if (GetRawCIMType() == CIM_DATETIME)
        {
            struct DATETIME_INFO
            {
                TCHAR szYear[5],
                      szMonth[3],
                      szDay[3],
                      szHour[3],
                      szMin[3],
                      szSec[3],
                      szMicro[7],
                      cSep,
                      szOffset[4];
            } datetime;

            ZeroMemory(&datetime, sizeof(datetime));

            if (_stscanf(
                strValue,
                _T("%4c%2c%2c%2c%2c%2c.%6c%c%3c"),
                datetime.szYear,
                datetime.szMonth,
                datetime.szDay,
                datetime.szHour,
                datetime.szMin,
                datetime.szSec,
                datetime.szMicro,
                &datetime.cSep,
                datetime.szOffset) == 9)
            {
                SYSTEMTIME systime;
                TCHAR      szDate[100] = _T(""),
                           szTime[100] = _T("");

                // _stscanf seems to be screwing this up, so fix it.
                datetime.szOffset[3] = 0;

                ZeroMemory(&systime, sizeof(systime));

                // Figure out the date.
                if (*datetime.szYear != '*' && *datetime.szMonth != '*')
                {
                    DWORD dwFlag;
                    TCHAR szFormat[10],
                          *pszFormat;

                    systime.wYear = (WORD) _ttoi(datetime.szYear);
                    systime.wMonth = (WORD) _ttoi(datetime.szMonth);

                    if (*datetime.szDay == '*')
                    {
                        // This would have been nice to use, but it only lives
                        // on W2K.
                        //dwFlag = DATE_YEARMONTH;
                        TCHAR szSep[100];

                        if (GetLocaleInfo(
                            LOCALE_USER_DEFAULT,
                            LOCALE_SDATE,
                            szSep,
                            sizeof(szSep) / sizeof(TCHAR)))
                        {
                            // Otherwise GetDateFormat will fail, even though
                            // it doesn't need it!
                            systime.wDay = 1;

                            wsprintf(szFormat, _T("MM%syyyy"), szSep);
                            dwFlag = 0;
                            pszFormat = szFormat;
                        }
                    }
                    else
                    {
                        dwFlag = DATE_SHORTDATE;
                        pszFormat = NULL;
                        systime.wDay = (WORD) _ttoi(datetime.szDay);
                    }
                    
                    GetDateFormat(
                        LOCALE_USER_DEFAULT,
                        dwFlag,
                        &systime,
                        pszFormat,
                        szDate,
                        sizeof(szDate) / sizeof(TCHAR));
                }

                // Figure out the time.
                if (*datetime.szHour != '*')
                {
                    DWORD dwFlag = 0;

                    systime.wHour = (WORD) _ttoi(datetime.szHour);

                    if (*datetime.szMin == '*')
                        dwFlag = TIME_NOMINUTESORSECONDS;
                    else
                    {
                        systime.wMinute = (WORD) _ttoi(datetime.szMin);

                        if (*datetime.szSec == '*')
                            dwFlag = TIME_NOSECONDS;
                        else
                            systime.wSecond = (WORD) _ttoi(datetime.szSec);
                    }

                    GetTimeFormat(
                        LOCALE_USER_DEFAULT,
                        dwFlag,
                        &systime,
                        NULL,
                        szTime,
                        sizeof(szTime) / sizeof(TCHAR));

                    if (*szTime && 
                        (datetime.cSep == '-' || datetime.cSep == '+') && 
                        *datetime.szOffset != '*')
                    {
                        CString strOffset;
                        DWORD   dwMinutes = _ttoi(datetime.szOffset);

                        strOffset.FormatMessage(
                            IDS_UTC, datetime.cSep, dwMinutes / 60, 
                            dwMinutes % 60);

                        strcat(szTime, strOffset);
                    }
                }

                strValue = szDate;
                if (*szTime)
                {
                    if (!strValue.IsEmpty())
                        strValue += _T(" ");

                    strValue += szTime;
                }
            }
        }
    }

    if (bQuoteStrings && GetRawCIMType() == CIM_STRING)
    {
        CString strTemp;

        strTemp.Format(_T("\"%s\""), (LPCTSTR) strValue);

        strValue = strTemp;
    }

    return TRUE;
}

DWORD CPropInfo::GetArrayItemCount(VARIANT *pVar)
{
    return pVar->parray->rgsabound[0].cElements;
}

BOOL CPropInfo::ArrayItemToString(VARIANT *pVar, DWORD dwIndex, 
    CString &strValue, BOOL bTranslate)
{
    ASSERT(m_vt & VT_ARRAY);
    ASSERT(pVar->vt & VT_ARRAY);
    ASSERT(dwIndex < pVar->parray->rgsabound[0].cElements);

    BOOL bRet = TRUE;

    LPBYTE  pData = (LPBYTE) pVar->parray->pvData;
    CString strItem;
    DWORD   dwArrayItemSize = GetArrayItemSize((VARENUM) pVar->vt);

    if (VariantBlobToString(
        (VARENUM) pVar->vt,
        pData + (dwArrayItemSize * dwIndex), 
        strItem, 
        bTranslate,
        FALSE))
        strValue = strItem;
    
    return bRet;        
}

BOOL CPropInfo::PrepArrayVar(VARIANT *pVar, DWORD dwSize)
{
    BOOL bRet = FALSE;

    ASSERT((m_vt & VT_ARRAY) != 0);

    VariantClear(pVar);

    if (dwSize > 0)
    {
        SAFEARRAYBOUND bound;

        pVar->vt = m_vt;

        if (pVar->vt == (VT_I8 | VT_ARRAY))
            pVar->vt = VT_BSTR | VT_ARRAY;

        bound.lLbound = 0;
        bound.cElements = dwSize;

        pVar->parray = SafeArrayCreate(pVar->vt & ~VT_ARRAY, 1, &bound);

        bRet = pVar->parray != NULL;
    }
    else
    {
        pVar->vt = VT_NULL;
        bRet = TRUE;
    }

    return bRet;
}

BOOL CPropInfo::StringToArrayItem(LPCTSTR szItem, VARIANT *pVar, DWORD dwIndex, 
    BOOL bTranslate)
{
    //ASSERT(m_vt & VT_ARRAY);
    ASSERT(pVar->vt & VT_ARRAY);
    ASSERT(dwIndex < pVar->parray->rgsabound[0].cElements);

    BOOL   bRet = TRUE;
    LPBYTE pData = (LPBYTE) pVar->parray->pvData;
    DWORD  dwArrayItemSize = GetArrayItemSize((VARENUM) pVar->vt);

    bRet = 
        StringToVariantBlob(szItem, pData + (dwArrayItemSize * dwIndex), 
            bTranslate);
    
    return bRet;        
}

int CPropInfo::GetArrayItemSize(VARENUM vt)
{
    switch(vt & ~VT_ARRAY)
    {
        case VT_UI1:
        case VT_I1:
            return 1;
            
	    case VT_BOOL:
        case VT_I2:
            return 2;

        case VT_I4:
            return 4;

        case VT_I8:
            return 8;

	    case VT_UNKNOWN:
        case VT_BSTR:
            return sizeof(BSTR*);

	    case VT_R4:
            return sizeof(float);
            
	    case VT_R8:
            return sizeof(double);

	    default:
            // This shouldn't happen!  If it does, add another case statement.
            ASSERT(FALSE);
            return 0;
    }
}

BOOL CPropInfo::VariantToString(VARIANT *pVar, CString &strValue, 
    BOOL bTranslate, BOOL bQuoteStrings)
{
    BOOL bRet = TRUE;

    if (pVar->vt != VT_NULL)
    {
        if (pVar->vt & VT_ARRAY)
        {
            DWORD dwArrayItemSize = GetArrayItemSize((VARENUM) pVar->vt);

            strValue.Empty();

            LPBYTE  pData = (LPBYTE) pVar->parray->pvData;
            CString strItem;

            for (int i = 0; i < pVar->parray->rgsabound[0].cElements; 
                i++, pData += dwArrayItemSize)
            {
                VariantBlobToString((VARENUM) pVar->vt, pData, strItem, 
                    bTranslate, bQuoteStrings);

                if (i != 0)
                    strValue += _T(", ");

                strValue += strItem;
            }
        }
        else
        {
            LPVOID pData = &V_BSTR(pVar);

            VariantBlobToString((VARENUM) pVar->vt, pData, strValue, 
                bTranslate, bQuoteStrings);
        }
    }
    else
        strValue.LoadString(IDS_NULL);
    
    return bRet;        
}

// Use this to get __ExtendedStatus.
IWbemClassObject *GetWMIErrorObject()
{
    IWbemClassObject *pObj = NULL;
    IErrorInfo       *pInfo = NULL;

    if (SUCCEEDED(GetErrorInfo(0, &pInfo)) && pInfo != NULL)
    {
        pInfo->QueryInterface(IID_IWbemClassObject, (LPVOID*) &pObj);

        pInfo->Release();
    }

    return pObj;        
}

// Wbemcomn.dll prototypes.
typedef HRESULT (IWbemClassObject::*FPGET_PROPERTY_HANDLE_EX)(LPCWSTR, CIMTYPE*, long*);
typedef LPVOID (IWbemClassObject::*FPGET_ARRAY_BY_HANDLE)(long);

void CObjInfo::DoDebugStuff()
{
    // I tried doing directly (from GetProcAddress into memember vars) but
    // I couldn't come up with a conversion the compiler would let me do.
    // So, do it the hardway.
    HINSTANCE hWbemComn = GetModuleHandle(_T("wbemcomn.dll"));
    FARPROC   fpGetPropertyHandleEx = 
                GetProcAddress(
                    hWbemComn, 
                    "?GetPropertyHandleEx@CWbemObject@@QAEJPBGPAJ1@Z");
    FARPROC   fpGetArrayByHandle = 
                GetProcAddress(
                    hWbemComn, 
                    "?GetArrayByHandle@CWbemObject@@QAEPAVCUntypedArray@@J@Z");

    FPGET_PROPERTY_HANDLE_EX
              m_fpGetPropertyHandleEx;
    FPGET_ARRAY_BY_HANDLE            
              m_fpGetArrayByHandle;

    memcpy(
        &m_fpGetPropertyHandleEx, 
        &fpGetPropertyHandleEx, 
        sizeof(fpGetPropertyHandleEx));

    memcpy(
        &m_fpGetArrayByHandle, 
        &fpGetArrayByHandle, 
        sizeof(fpGetArrayByHandle));

    SAFEARRAY *pArr = NULL;

    if (SUCCEEDED(m_pObj->GetNames(NULL, WBEM_FLAG_NONSYSTEM_ONLY, NULL, &pArr)))
    {
        BSTR *pNames = (BSTR*) pArr->pvData;
        int  nItems = pArr->rgsabound[0].cElements;

        for (int i = 0; i < nItems; i++)
        {
            CIMTYPE type;
            long    handle;

            if (SUCCEEDED(
                (m_pObj->*m_fpGetPropertyHandleEx)(
                    pNames[i],
                    &type,
                    &handle)))
            {
                LPVOID pData = (m_pObj->*m_fpGetArrayByHandle)(handle);
                int    x;

                x = 3;

                HRESULT    hr;
                _variant_t vValue;

                hr =
                    m_pObj->Get(
                        pNames[i],
                        0,
                        &vValue,
                        &type,
                        NULL);

                BSTR *pStrings = NULL;
                
                if (vValue.vt == (VT_BSTR | VT_ARRAY))
                    pStrings = (BSTR*) vValue.parray->pvData;

                hr =
                    m_pObj->Put(
                        pNames[i],
                        0,
                        &vValue,
                        0);
            }
        }

        SafeArrayDestroy(pArr);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\wmitest\opview.h ===
/*++

Copyright (C) 1997-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/
// OpView.h : interface of the COpView class
//
/////////////////////////////////////////////////////////////////////////////

#if !defined(AFX_OPVIEW_H__4419F1AE_692B_11D3_BD30_0080C8E60955__INCLUDED_)
#define AFX_OPVIEW_H__4419F1AE_692B_11D3_BD30_0080C8E60955__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "OpWrap.h"

#define WM_OBJ_INDICATE  (WM_USER + 101)
#define WM_OP_STATUS     (WM_USER + 102)

class CWMITestDoc;

class COpView : public CTreeView
{
protected: // create from serialization only
	COpView();
	DECLARE_DYNCREATE(COpView)

// Attributes
public:
	CWMITestDoc* GetDocument();
    CTreeCtrl *m_pTree;
    HTREEITEM m_hitemRoot;

// Operations
public:

    void AddOpItem(WMI_OP_TYPE type, LPCTSTR szText, BOOL bOption = FALSE);
    void AddOpItem(COpWrap *pWrap);
    void AddOpItemChild(    
        CObjInfo* pInfo, 
        HTREEITEM hParent, 
        int iImage, 
        LPCTSTR szText);
    void RefreshItem(HTREEITEM hitem);
    void RefreshItem(COpWrap *pWrap);
    void RefreshItems();
    void RefreshObject(CObjInfo *pInfo);
	void FlushItems();
    void RemoveItemFromTree(HTREEITEM item, BOOL bNoWMIRemove);
    void UpdateRootText();
    BOOL IsRoot(HTREEITEM hitem) { return hitem == m_hitemRoot; }
    BOOL IsOp(HTREEITEM hitem) { return IsRoot(m_pTree->GetParentItem(hitem)); }
    BOOL IsObj(HTREEITEM hitem);
    BOOL IsObjDeleteable(HTREEITEM hitem);
    void RemoveChildrenFromTree(HTREEITEM item, BOOL bDoRemove);
    COpWrap *GetCurrentOp();
    CObjInfo *GetCurrentObj();
    void DoContextMenuForItem(HTREEITEM hItem);
    int GetOpCount();
    CObjInfo *GetObjInfo(HTREEITEM hItem);
    void UpdateCurrentObject(BOOL bReloadProps = FALSE);
    void UpdateItem(HTREEITEM hitem);
    void UpdateCurrentItem();
    void UpdateStatusText();
    BOOL GetSelectedObjPath(CString &strPath);
    BOOL GetSelectedClass(CString &strClass);
    void DoPopupMenu(UINT nMenuID);
    void UpdateObject(CObjInfo *pInfo);

    void EditObj(CObjInfo *pInfo);

    void ExportItemToFile(LPCTSTR szFilename, HTREEITEM hitem, 
        BOOL bShowSystem, BOOL bTranslate);

    //void SerializeForClipboard(CArchive &arcNative, CArchive &arcText, 
    //    CLIPFORMAT *pFormat);
    //void SerializeTreeItem(HTREEITEM item, CArchive &arcNative, CArchive &arcText);

    void DoCopy(COpList &list);
    void BuildSelectedOpList(COpList &list);
    BOOL CanCopy();


    static DWORD WINAPI CopyThreadProc(COpView *pThis);
    void DoThreadedCopy();
    void CopyToClipboard();
     
// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(COpView)
	public:
	virtual BOOL PreCreateWindow(CREATESTRUCT& cs);
	protected:
	virtual void OnInitialUpdate(); // called first time after construct
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~COpView();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

protected:
    int GetChildCount(HTREEITEM hitem);

// Generated message map functions
protected:
    void RemoveNonOpObjectFromTree(HTREEITEM item);
    void ExportItem(CStdioFile *pFile, HTREEITEM item, BOOL bShowSystem, 
        BOOL bTranslate);

	//{{AFX_MSG(COpView)
	afx_msg void OnSize(UINT nType, int cx, int cy);
	afx_msg void OnDblclk(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnSelChanged(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnRclick(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnDelete();
	afx_msg void OnUpdateDelete(CCmdUI* pCmdUI);
	afx_msg void OnModify();
	afx_msg void OnUpdateModify(CCmdUI* pCmdUI);
	afx_msg void OnEditCopy();
	afx_msg void OnUpdateEditCopy(CCmdUI* pCmdUI);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
    afx_msg LRESULT OnObjIndicate(WPARAM wParam, LPARAM lParam);
    afx_msg LRESULT OnOpStatus(WPARAM wParam, LPARAM lParam);
};

extern COpView *g_pOpView;

#ifndef _DEBUG  // debug version in OpView.cpp
inline CWMITestDoc* COpView::GetDocument()
   { return (CWMITestDoc*)m_pDocument; }
#endif

/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_OPVIEW_H__4419F1AE_692B_11D3_BD30_0080C8E60955__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\wmitest\paramspg.cpp ===
/*++

Copyright (C) 1997-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/
// ParamsPg.cpp : implementation file
//

#include "stdafx.h"
#include "wmitest.h"
#include "WMITestDoc.h"
#include "OpView.h"
#include "OpWrap.h"
#include "ParamsPg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CParamsPg property page

IMPLEMENT_DYNCREATE(CParamsPg, CPropertyPage)

CParamsPg::CParamsPg() : CPropertyPage(CParamsPg::IDD)
{
	//{{AFX_DATA_INIT(CParamsPg)
	m_strName = _T("");
	//}}AFX_DATA_INIT
}

CParamsPg::~CParamsPg()
{
}

void CParamsPg::DoDataExchange(CDataExchange* pDX)
{
	CPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CParamsPg)
	DDX_Text(pDX, IDC_NAME, m_strName);
	//}}AFX_DATA_MAP


}


BEGIN_MESSAGE_MAP(CParamsPg, CPropertyPage)
	//{{AFX_MSG_MAP(CParamsPg)
	ON_BN_CLICKED(IDC_EDIT_INPUT, OnEditInput)
	ON_BN_CLICKED(IDC_EDIT_OUT, OnEditOut)
	ON_BN_CLICKED(IDC_NULL_IN, OnNullIn)
	ON_BN_CLICKED(IDC_NULL_OUT, OnNullOut)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CParamsPg message handlers

BOOL CParamsPg::EditParams(DWORD dwID, IWbemClassObjectPtr &pObj)
{
    HRESULT hr;

    if (pObj == NULL)
    {
        //IWbemClassObjectPtr pClass;

        if (SUCCEEDED(hr = g_pOpView->GetDocument()->m_pNamespace->GetObject(
            L"__PARAMETERS",
            WBEM_FLAG_RETURN_WBEM_COMPLETE,
            NULL,
            &pObj,
            NULL)))
        {
            //_variant_t vValue = dwID == IDS_EDIT_IN_PARAMS ? L"InParams"
            //hr = 
            //    pClass->SpawnInstance(
            //        0,
            //        ppObj);
        }

        if (FAILED(hr))
        {
            CWMITestDoc::DisplayWMIErrorBox(hr);

            return FALSE;
        }
    }
            
    return CWMITestDoc::EditGenericObject(dwID, pObj);
}

void CParamsPg::OnEditInput() 
{
    EditParams(IDS_EDIT_IN_PARAMS, m_pObjIn);
}

void CParamsPg::OnEditOut() 
{
    EditParams(IDS_EDIT_OUT_PARAMS, m_pObjOut);
}

void CParamsPg::OnNullIn() 
{
    GetDlgItem(IDC_EDIT_INPUT)->EnableWindow(
        !IsDlgButtonChecked(IDC_NULL_IN));
}

void CParamsPg::OnNullOut() 
{
    GetDlgItem(IDC_EDIT_OUT)->EnableWindow(
        !IsDlgButtonChecked(IDC_NULL_OUT));
}

BOOL CParamsPg::OnInitDialog() 
{
	CPropertyPage::OnInitDialog();
	
    if (!m_bNewMethod)
    {
        m_pClass->GetMethod(
            _bstr_t(m_strName),
            0,
            &m_pObjIn,
            &m_pObjOut);
    }

    GetDlgItem(IDC_NAME)->EnableWindow(m_bNewMethod);

    CheckDlgButton(IDC_NULL_IN, m_pObjIn == NULL);
    OnNullIn();

    CheckDlgButton(IDC_NULL_OUT, m_pObjOut == NULL);
    OnNullOut();
	
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

void CParamsPg::OnOK() 
{
	if (IsDlgButtonChecked(IDC_NULL_IN))
        m_pObjIn = NULL;
	
	if (IsDlgButtonChecked(IDC_NULL_OUT))
        m_pObjOut = NULL;
	
	CPropertyPage::OnOK();
}

BOOL CParamsPg::OnKillActive() 
{
	if (m_strName.IsEmpty())
    {
        AfxMessageBox(IDS_METHOD_NAME_IS_EMPTY, MB_ICONEXCLAMATION | MB_OK);

        return FALSE;
    }
	
	return CPropertyPage::OnKillActive();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\wmitest\paramspg.h ===
/*++

Copyright (C) 1997-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/
#if !defined(AFX_PARAMSPG_H__ED65CC8B_57CB_43A4_B579_78261F5DC324__INCLUDED_)
#define AFX_PARAMSPG_H__ED65CC8B_57CB_43A4_B579_78261F5DC324__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// ParamsPg.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CParamsPg dialog

class CParamsPg : public CPropertyPage
{
	DECLARE_DYNCREATE(CParamsPg)

// Construction
public:
	CParamsPg();
	~CParamsPg();

// Dialog Data
	//{{AFX_DATA(CParamsPg)
	enum { IDD = IDD_METHOD_PARAMS };
	CString	m_strName;
	//}}AFX_DATA
    BOOL                m_bNewMethod;
    IWbemClassObject    *m_pClass;
    IWbemClassObjectPtr m_pObjIn,
                        m_pObjOut;

// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CParamsPg)
	public:
	virtual void OnOK();
	virtual BOOL OnKillActive();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
    BOOL EditParams(DWORD dwID, IWbemClassObjectPtr &pObj);

	// Generated message map functions
	//{{AFX_MSG(CParamsPg)
	afx_msg void OnEditInput();
	afx_msg void OnEditOut();
	afx_msg void OnNullIn();
	afx_msg void OnNullOut();
	virtual BOOL OnInitDialog();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_PARAMSPG_H__ED65CC8B_57CB_43A4_B579_78261F5DC324__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\wmitest\opwrap.h ===
/*++

Copyright (C) 1997-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/
// OpWrap.h

#ifndef _OPWRAP_H
#define _OPWRAP_H

#include "MainFrm.h"

_COM_SMARTPTR_TYPEDEF(IWbemClassObject, __uuidof(IWbemClassObject));
_COM_SMARTPTR_TYPEDEF(IWbemObjectSink, __uuidof(IWbemObjectSink));
_COM_SMARTPTR_TYPEDEF(IWbemCallResult, __uuidof(IWbemCallResult));
_COM_SMARTPTR_TYPEDEF(IWbemObjectAccess, __uuidof(IWbemObjectAccess));
_COM_SMARTPTR_TYPEDEF(IWbemQualifierSet, __uuidof(IWbemQualifierSet));

CString GetEmbeddedObjectText(IUnknown *pUnk);

class CObjPtr : public IWbemClassObjectPtr
{
public:
    CObjPtr() {}
    CObjPtr(IWbemClassObject *pObj) : IWbemClassObjectPtr(pObj) {}
    CObjPtr *operator&() { return this; }
};

#include "list"

typedef CArray<int, int> CIntArray;
typedef CMap<int, int, int, int> CIntMap;
typedef CMap<CString, LPCTSTR, CString, LPCTSTR> CStringMap;

class CBitmaskInfo
{
public:
    CBitmaskInfo() :
        m_dwBitmaskValue(0)
    {
    }

    DWORD m_dwBitmaskValue;
    CString m_strName;
};

typedef CArray<CBitmaskInfo, CBitmaskInfo&> CBitmaskInfoArray;

// Use this to get __ExtendedStatus.
IWbemClassObject *GetWMIErrorObject();

class CMethodInfo
{
public:
    CString m_strName,
            m_strDescription;
    BOOL    m_bStatic;

    CMethodInfo() :
        m_bStatic(FALSE)
    {
    }
};

typedef CList<CMethodInfo, CMethodInfo&> CMethodInfoList;

class CPropInfo
{
public:
    CString m_strName;
    long    m_iHandle;
    CIMTYPE m_type;
    long    m_iFlavor;
    BOOL    m_bKey;
    DWORD   m_dwExpectedSize;
    VARENUM m_vt;
    BOOL    m_bSigned,
            m_bValueMap,
            m_bBitmask;
    CStringMap m_mapValues;
    CBitmaskInfoArray m_bitmaskValues;


    CPropInfo() :
        m_iHandle(0),
        m_iFlavor(WBEM_FLAVOR_ORIGIN_LOCAL),
        m_bKey(FALSE),
        m_bValueMap(FALSE),
        m_bBitmask(FALSE)
    {
        SetType(CIM_UINT32);
    }

    CPropInfo(const CPropInfo& other);
    const CPropInfo& operator=(const CPropInfo& other);
    void GetPropType(CString &strType, int *piImage, BOOL bIgnoreArrayFlag = FALSE);

    // Funcs use to turn variants into strings.  Works on arrays too.
    BOOL VariantToString(VARIANT *pVar, CString &strValue, BOOL bTranslate,
        BOOL bQuoteStrings = FALSE);
    
    // Use this to get turn an array item into a string.
    BOOL ArrayItemToString(VARIANT *pVar, DWORD dwIndex, CString &strValue, BOOL bTranslate);
    DWORD GetArrayItem(VARIANT *pVar, DWORD dwIndex);
    
    // Helper called by COpWrap::LoadPropInfoList.
    void SetType(CIMTYPE type);

    // Call this to allocate the safe array before calling StringToArrayItem.
    // If dwSize is 0, pVar is set to VT_NULL.
    BOOL PrepArrayVar(VARIANT *pVar, DWORD dwSize);
    BOOL StringToArrayItem(LPCTSTR szItem, VARIANT *pVar, DWORD dwIndex, 
        BOOL bTranslate);
    BOOL StringToVariant(LPCSTR szValue, VARIANT *pVar, BOOL bTranslate);
    BOOL SetArrayItem(VARIANT *pVar, DWORD dwIndex, DWORD dwValue);

    BOOL IsBitmask() { return m_bBitmask; }
    BOOL IsArray() { return (m_vt & VT_ARRAY) != 0; }
    BOOL HasValuemap() { return m_bValueMap; }
    DWORD GetArrayItemCount(VARIANT *pVar);

    // Masks off the array flag.
    VARENUM GetRawType() { return (VARENUM) (m_vt & ~VT_ARRAY); }
    CIMTYPE GetRawCIMType() { return (CIMTYPE) (m_type & ~CIM_FLAG_ARRAY); }

protected:
    BOOL VariantBlobToString(VARENUM vt, LPVOID pData, CString &strValue, 
        BOOL bTranslate, BOOL bQuoteStrings);
    BOOL StringToVariantBlob(LPCTSTR szValue, LPVOID pData, BOOL bTranslate);

    static int GetArrayItemSize(VARENUM vt);
};

class CPropInfoArray : public CArray<CPropInfo, CPropInfo&>
{
public:
    CPropInfoArray() : 
        m_nStaticMethods(0)
    {
    }

    CIntMap m_mapGlobalToLocalIndex;
    CMethodInfoList m_listMethods;

    // Method stuff.
    void LoadMethods(IWbemClassObject *pClass);
    int GetMethodCount() { return m_listMethods.GetCount(); }
    int GetStaticMethodCount() { return m_nStaticMethods; }

protected:
    int m_nStaticMethods;

};

enum WMI_OP_TYPE
{
    WMI_QUERY,
    WMI_EVENT_QUERY,
    WMI_ENUM_OBJ,
    WMI_GET_OBJ,
    WMI_ENUM_CLASS,
    WMI_GET_CLASS,
    WMI_CREATE_CLASS,
    WMI_CREATE_OBJ,
};

class CObjInfo
{
public:    
    CObjInfo() :
        m_ppProps(NULL),
        m_bModified(FALSE)
    {
    }

    ~CObjInfo();

    IWbemClassObjectPtr m_pObj;

    void SetObj(IWbemClassObject *pObj);

    HRESULT LoadProps(IWbemServices *pNamespace);
    BOOL GetPropValue(int iIndex, CString &strValue, BOOL bTranslate);
    CString GetStringPropValue(LPCWSTR szName);
    CString GetStringPropValue(int iIndex);
    void GetPropInfo(
        int iIndex, 
        CString &strValue, 
        CString &strType, 
        int *piImage,
        int *piFlavor,
        BOOL bTranslate);
    CString GetObjText();
    BOOL ValueToVariant(int iIndex, VARIANT *pVar);
    void SetModified(BOOL bModified) { m_bModified = bModified; }
    BOOL IsModified() { return m_bModified; }
    int GetImage() { return m_bModified ? m_iBaseImage + 3 : m_iBaseImage; }
    void SetBaseImage(int iImage) { m_iBaseImage = iImage; }
    BOOL IsInstance() { return m_iBaseImage == IMAGE_OBJECT; }

    CPropInfoArray *GetProps() { return m_ppProps; }
    void SetProps(CPropInfoArray *pProps) { m_ppProps = pProps; }

    void Export(CStdioFile *pFile, BOOL bShowSystem, BOOL bTranslate, 
        int iLevel);

    void DoDebugStuff();

protected:
    BOOL m_bModified;
    int  m_iBaseImage;
    IWbemObjectAccessPtr m_pAccess;
    CPropInfoArray *m_ppProps;
    //CPropInfoArray m_propsModified;

    void GetPropType(CPropInfo &info, CString &strType, int *piImage);
    static DWORD BitmaskStrToValue(LPCWSTR szStr);
};

class CClassToProps : public CMap<CString, LPCSTR, CPropInfoArray*, CPropInfoArray*&>
{
public:
    ~CClassToProps();
    void Flush();
};

class COpWrap;

class CObjSink : public IWbemObjectSink
{
public:
    COpWrap *m_pWrap;
    LONG m_lRef;

    CObjSink(COpWrap *pWrap) :
        m_lRef(0)
    { 
        m_pWrap = pWrap; 
    }

public:
    STDMETHODIMP QueryInterface(REFIID refid, PVOID *ppThis)
    { 
/*
        if (refid == IID_IUnknown || refid == IID_IWbemObjectSink)
        {
            *ppThis = this;

            return S_OK;
        }
        else
            return E_NOINTERFACE;
*/
        HRESULT hr;

        if (refid == IID_IUnknown)
        {
            *ppThis = (IUnknown*) this;

            AddRef();

            hr = S_OK;
        }
        else if (refid == IID_IWbemObjectSink)
        {
            *ppThis = (IWbemObjectSink*) this;

            AddRef();

            hr = S_OK;
        }
        else
            hr = E_NOINTERFACE;

        return hr;
    }

    STDMETHODIMP_(ULONG) AddRef(void); //{ return 1; }
    STDMETHODIMP_(ULONG) Release(void); //{ return 1; }

    // IWbemObjectSink
    HRESULT STDMETHODCALLTYPE Indicate(
        LONG lObjectCount,
        IWbemClassObject **ppObjArray);

    HRESULT STDMETHODCALLTYPE SetStatus(
        LONG lFlags,
        HRESULT hResult, 
        BSTR strParam, 
        IWbemClassObject *pObjParam);
};

//class COpWrap : public IWbemObjectSink, public CObject
class COpWrap : public CObject
{
public:
    CCriticalSection m_cs;
    CString m_strOpText;
    WMI_OP_TYPE m_type;
    HTREEITEM m_item;
    int m_iImageBase;
    CClassToProps
        m_mapClassToProps;
    int m_nCount;
    int m_status;
    BOOL m_bOption;
    CObjInfo m_objInfo;
    CList<CObjPtr, CObjPtr&> m_listObj;
    HRESULT m_hr;

    CString m_strErrorText;
    IWbemClassObjectPtr m_pErrorObj;
    IWbemObjectSinkPtr m_pObjSink;

    CStringArray m_strProps;
    CIntArray m_piDisplayCols;
    CIntArray m_piDisplayColsWidth;

    COpWrap(); // For Serialize
    COpWrap(WMI_OP_TYPE type, LPCTSTR szText, BOOL bOption = FALSE);
    ~COpWrap();
    
    // This only copies over type, text and option.
    const COpWrap& operator=(const COpWrap &other);

    HRESULT Execute(IWbemServices *pNamespace);
    void CancelOp(IWbemServices *pNamespace);
    int GetPropIndex(LPCTSTR szName, BOOL bAddToDisplay);
    CObjInfo *GetObjInfo() { return &m_objInfo; }
    int GetObjCount() { return m_nCount; }
        

    BOOL HoldsObjects() { return m_iChildImage == IMAGE_OBJECT; }
    BOOL ShowPathsOnly() { return m_bShowPathsOnly; }
    BOOL IsObject() { return m_type == WMI_GET_CLASS || m_type == WMI_GET_OBJ ||
                        m_type == WMI_CREATE_CLASS || m_type == WMI_CREATE_OBJ; }
    CString GetClassName();
    CString GetCaption();
    int GetImage();
    //HRESULT LoadPropInfoList(CObjInfo *pInfo, IWbemClassObject *pClass, 
    //    CPropInfoArray *pProps);
    HRESULT RefreshPropInfo(CObjInfo *pInfo);

    void GetPropValue(
        CObjInfo *pInfo,
        int iIndex, 
        CString &strValue,
        BOOL bTranslate);

    // Serialize stuff
    DECLARE_SERIAL(COpWrap)
    void Serialize(CArchive &archive);


    static CString GetWbemErrorText(HRESULT hres);
    

protected:
    BOOL m_bShowPathsOnly;
    int  m_iChildImage,
         m_nExpectedStatusCalls;
    LONG m_lRef;
    
    
    // We need this to get the amended qualifiers.
    IWbemServices *m_pNamespace; 

    void SetHoldsObjects();
    void AddPropsToGlobalIndex(CObjInfo *pInfo);
    HRESULT LoadPropInfo(CObjInfo *pInfo);
    
    
    // Called by constructor and Serialize after member vars are set.
    void Init();

public:
    // IUnknown
/*
    STDMETHODIMP QueryInterface(REFIID refid, PVOID *ppThis)
    { 
        if (refid == IID_IUnknown || refid == IID_IWbemObjectSink)
        {
            *ppThis = this;

            return S_OK;
        }
        else
            return E_NOINTERFACE;
    }

    STDMETHODIMP_(ULONG) AddRef(void); //{ return 1; }
    STDMETHODIMP_(ULONG) Release(void); //{ return 1; }
*/

    HRESULT STDMETHODCALLTYPE Indicate(
        LONG lObjectCount,
        IWbemClassObject **ppObjArray);

    HRESULT STDMETHODCALLTYPE SetStatus(
        LONG lFlags,
        HRESULT hResult, 
        BSTR strParam, 
        IWbemClassObject *pObjParam);
};

typedef CList<COpWrap, COpWrap&> COpList;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\wmitest\prefdlg.cpp ===
/*++

Copyright (C) 1997-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/
// PrefDlg.cpp : implementation file
//

#include "stdafx.h"
#include "WMITest.h"
#include "PrefDlg.h"
#include "Utils.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CPrefDlg dialog


CPrefDlg::CPrefDlg(CWnd* pParent /*=NULL*/)
	: CDialog(CPrefDlg::IDD, pParent)
{
	//{{AFX_DATA_INIT(CPrefDlg)
	m_bLoadLast = FALSE;
	m_bShowSystem = FALSE;
	m_bShowInherited = FALSE;
	m_bEnablePrivsOnStartup = FALSE;
	m_bPrivsEnabled = FALSE;
	//}}AFX_DATA_INIT

    m_dwUpdateFlag = WBEM_FLAG_CREATE_OR_UPDATE;
    m_dwClassUpdateMode = WBEM_FLAG_UPDATE_COMPATIBLE;
}


void CPrefDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CPrefDlg)
	DDX_Check(pDX, IDC_LOAD_LAST, m_bLoadLast);
	DDX_Check(pDX, IDC_SYSTEM_PROPS, m_bShowSystem);
	DDX_Check(pDX, IDC_SHOW_INHERITED, m_bShowInherited);
	DDX_Check(pDX, IDC_PRIVS_ON_START, m_bEnablePrivsOnStartup);
	DDX_Check(pDX, IDC_ENABLE_PRIVS, m_bPrivsEnabled);
	//}}AFX_DATA_MAP

    if (!pDX->m_bSaveAndValidate)
    {
        DWORD dwID;

        switch(m_dwUpdateFlag)
        {
            case WBEM_FLAG_CREATE_ONLY:
                dwID = IDC_CREATE;
                break;

            case WBEM_FLAG_UPDATE_ONLY:
                dwID = IDC_UPDATE;
                break;

            default:
            case WBEM_FLAG_CREATE_OR_UPDATE:
                dwID = IDC_CREATE_OR_UPDATE;
                break;
        }

        CheckRadioButton(IDC_CREATE, IDC_CREATE_OR_UPDATE, dwID);


        switch(m_dwClassUpdateMode)
        {
            case WBEM_FLAG_UPDATE_COMPATIBLE:
                dwID = IDC_COMPATIBLE;
                break;

            case WBEM_FLAG_UPDATE_SAFE_MODE:
                dwID = IDC_SAFE;
                break;

            default:
            case WBEM_FLAG_UPDATE_FORCE_MODE:
                dwID = IDC_FORCE;
                break;
        }

        CheckRadioButton(IDC_COMPATIBLE, IDC_FORCE, dwID);

        if (m_bPrivsEnabled)
            GetDlgItem(IDC_ENABLE_PRIVS)->EnableWindow(FALSE);
    }
    else
    {
        switch(GetCheckedRadioButton(IDC_CREATE, IDC_CREATE_OR_UPDATE))
        {
            case IDC_CREATE:
                m_dwUpdateFlag = WBEM_FLAG_CREATE_ONLY;
                break;

            case IDC_UPDATE:
                m_dwUpdateFlag = WBEM_FLAG_UPDATE_ONLY;
                break;

            default:
            case IDC_CREATE_OR_UPDATE:
                m_dwUpdateFlag = WBEM_FLAG_CREATE_OR_UPDATE;
                break;
        }

        switch(GetCheckedRadioButton(IDC_COMPATIBLE, IDC_FORCE))
        {
            case IDC_COMPATIBLE:
                m_dwClassUpdateMode = WBEM_FLAG_UPDATE_COMPATIBLE;
                break;

            case IDC_SAFE:
                m_dwClassUpdateMode = WBEM_FLAG_UPDATE_SAFE_MODE;
                break;

            default:
            case IDC_FORCE:
                m_dwClassUpdateMode = WBEM_FLAG_UPDATE_FORCE_MODE;
                break;
        }
    }
}


BEGIN_MESSAGE_MAP(CPrefDlg, CDialog)
	//{{AFX_MSG_MAP(CPrefDlg)
	ON_BN_CLICKED(IDC_ENABLE_PRIVS, OnEnablePrivs)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CPrefDlg message handlers

void CPrefDlg::OnEnablePrivs() 
{
    HRESULT hr = EnableAllPrivileges(TOKEN_PROCESS);    

    if (SUCCEEDED(hr))
        GetDlgItem(IDC_ENABLE_PRIVS)->EnableWindow(FALSE);
    else
        AfxMessageBox(IDS_ENABLE_PRIVS_FAILED, hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\wmitest\propqualspg.cpp ===
/*++

Copyright (C) 1997-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/

// PropQualsPg.cpp : implementation file
//

#include "stdafx.h"
#include "wmitest.h"
#include "WMITestDoc.h"
#include "MainFrm.h"
#include "OpWrap.h"
#include "PropQualsPg.h"
#include "EditQualDlg.h"
#include "OpView.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CPropQualsPg property page

IMPLEMENT_DYNCREATE(CPropQualsPg, CPropertyPage)

CPropQualsPg::CPropQualsPg() : 
    CPropertyPage(CPropQualsPg::IDD),
    m_mode(QMODE_PROP),
    m_bIsInstance(FALSE),
    m_pObj(NULL),
    m_pQuals(NULL)
{
	//{{AFX_DATA_INIT(CPropQualsPg)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
}

CPropQualsPg::~CPropQualsPg()
{
    if (m_pQuals)
        m_pQuals->Release();
}

void CPropQualsPg::DoDataExchange(CDataExchange* pDX)
{
	CPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CPropQualsPg)
	DDX_Control(pDX, IDC_QUALS, m_ctlQuals);
	//}}AFX_DATA_MAP

    if (!pDX->m_bSaveAndValidate)
    {
    }
    else
    {
/*
        // Delete the quals in m_listQualsToDelete.
        POSITION pos = m_listQualsToDelete.GetHeadPosition();

        while(pos)
        {
            CQual   &qual = m_listQualsToDelete.GetNext(pos);
            HRESULT hr;

            hr = m_pQuals->Delete(_bstr_t(qual.m_strName));
        }


        // Add our quals.
        BOOL bNoFlavor = m_bIsInstance || !m_bInPropQualMode;

        pos = m_listQuals.GetHeadPosition();

        while(pos)
        {
            CQual   &qual = m_listQuals.GetNext(pos);
            HRESULT hr;

            hr =
                m_pQuals->Put(
                    _bstr_t(qual.m_strName),
                    &qual.m_var,
                    bNoFlavor ? 0 : qual.m_lFlavor);

            if (FAILED(hr))
                // TODO: We need to tell the user which qualifer
                // failed here.
                CWMITestDoc::DisplayWMIErrorBox(hr, NULL);
        }
*/
        
        if (!m_bIsInstance)
        {
            // Now put in the standard qualifer.
            PROP_TYPE type = (PROP_TYPE) (GetCheckedRadioButton(IDC_KEY, 
                                IDC_NORMAL) - IDC_KEY);

            // Get rid of the previous one since these are apparently mutually
            // exclusive but winmgmt doesn't do it for us.
            if (type != m_type && m_type != PROP_NORMAL)
                m_pQuals->Delete(TypeToQual(m_type));

            if (type != PROP_NORMAL)
            {
                _variant_t var = true;
                LPCWSTR    szVar = TypeToQual(type);
                HRESULT    hr;

                hr =
                    m_pQuals->Put(
                        szVar,
                        &var,
                        0);

                if (FAILED(hr))
                    // TODO: We need to tell the user which qualifer
                    // failed here.
                    CWMITestDoc::DisplayWMIErrorBox(hr);
            }
        }
    }
}

void CPropQualsPg::InitListCtrl()
{
    RECT    rect;
    CString strTemp;
            
	m_ctlQuals.SetExtendedStyle(LVS_EX_FULLROWSELECT);

    m_ctlQuals.SetImageList(&((CMainFrame *) AfxGetMainWnd())->m_imageList, 
		LVSIL_SMALL);
    m_ctlQuals.GetClientRect(&rect);

    strTemp.LoadString(IDS_NAME);
    m_ctlQuals.InsertColumn(0, strTemp, LVCFMT_LEFT, rect.right * 25 / 100);
            
    strTemp.LoadString(IDS_TYPE);
    m_ctlQuals.InsertColumn(1, strTemp, LVCFMT_LEFT, rect.right * 25 / 100);
            
    strTemp.LoadString(IDS_VALUE);
    m_ctlQuals.InsertColumn(2, strTemp, LVCFMT_LEFT, rect.right * 50 / 100);
}

LPCWSTR CPropQualsPg::TypeToQual(PROP_TYPE type)
{
    LPCWSTR szRet = NULL;

    switch(type)
    {
        case PROP_KEY:
            szRet = L"key";
            break;

        case PROP_INDEXED:
            szRet = L"indexed";
            break;

        case PROP_NOT_NULL:
            szRet = L"not_null";
            break;
    }

    return szRet;
}

HRESULT CPropQualsPg::InitQualSet()
{
    HRESULT hr;

    if (m_mode == QMODE_PROP)
        hr = m_pObj->GetPropertyQualifierSet(
            _bstr_t(m_propInfo.m_strName),
            &m_pQuals);
    else if (m_mode == QMODE_CLASS)
        hr = m_pObj->GetQualifierSet(&m_pQuals);
    else
        hr = m_pObj->GetMethodQualifierSet(
                _bstr_t(m_strMethodName),
                &m_pQuals);   

    return hr;
}

void CPropQualsPg::LoadQuals()
{
    HRESULT hr;
    //CString strType;
    //int     iImage;

    //m_propInfo.GetPropType(strType, &iImage);
    //SetDlgItemText(IDC_TYPE, strType);

    m_ctlQuals.DeleteAllItems();
    m_listQuals.RemoveAll();

    m_type = PROP_NORMAL;

    if (SUCCEEDED(hr = InitQualSet()))
    {
        int iItem = 0;

        if (SUCCEEDED(hr = m_pQuals->BeginEnumeration(0)))
        {
            BSTR       pName = NULL;
            _variant_t var;
            long       lFlavor;
            BOOL       bIgnoreQual = FALSE;

            while(1)
            {
                hr = 
                    m_pQuals->Next(
                        0,
                        &pName,
                        &var,
                        &lFlavor);

                if (FAILED(hr) || hr == WBEM_S_NO_MORE_DATA)
                    break;

                // We won't add every qual to our list when editing a property's
                // qualifiers.
                if (IsInPropMode())
                {
                    bIgnoreQual = TRUE;

                    if (!_wcsicmp(pName, L"key"))
                    {
                        if ((bool) var)
                            m_type = PROP_KEY;
                    }
                    else if (!_wcsicmp(pName, L"indexed"))
                    {
                        if ((bool) var)
                            m_type = PROP_INDEXED;
                    }
                    else if (!_wcsicmp(pName, L"not_null"))
                    {
                        if ((bool) var)
                            m_type = PROP_NOT_NULL;
                    }
                    // Just skip this lame one.
                    else if (!_wcsicmp(pName, L"CIMTYPE"))
                    {
                    }
                    else
                        bIgnoreQual = FALSE;
                }

                if (!bIgnoreQual)
                    AddQualifier(_bstr_t(pName), &var, lFlavor);

                SysFreeString(pName);
            }
        }
    }
            
    UpdateButtons();

    CheckRadioButton(IDC_KEY, IDC_NORMAL, IDC_KEY + m_type);

    if (FAILED(hr))
        CWMITestDoc::DisplayWMIErrorBox(hr);
}

CIMTYPE CPropQualsPg::QualTypeToCIMTYPE(VARENUM vt)
{
    CIMTYPE type;

    switch((long) vt & ~VT_ARRAY)
    {
        case VT_BSTR:
            type = CIM_STRING;
            break;

        case VT_BOOL:
            type = CIM_BOOLEAN;
            break;

        case VT_I4:
            type = CIM_SINT32;
            break;

        case VT_R8:
            type = CIM_REAL64;
            break;
    }

    if (vt & VT_ARRAY)
        type |= CIM_FLAG_ARRAY;

    return type;
}


BEGIN_MESSAGE_MAP(CPropQualsPg, CPropertyPage)
	//{{AFX_MSG_MAP(CPropQualsPg)
	ON_BN_CLICKED(IDC_ADD, OnAdd)
	ON_BN_CLICKED(IDC_EDIT, OnEdit)
	ON_BN_CLICKED(IDC_DELETE, OnDelete)
	ON_NOTIFY(NM_DBLCLK, IDC_QUALS, OnDblclkQuals)
	ON_NOTIFY(LVN_ITEMCHANGED, IDC_QUALS, OnItemchangedQuals)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CPropQualsPg message handlers

BOOL CPropQualsPg::OnInitDialog() 
{
	CPropertyPage::OnInitDialog();
	
    InitListCtrl();

    if (m_bIsInstance || m_mode == QMODE_METHOD)
    {
        const DWORD dwIDs[] =
        {
            IDC_KEY,
            IDC_INDEXED,
            IDC_NON_NULL,
            IDC_NORMAL,
        };

        for (int i = 0; i < sizeof(dwIDs) / sizeof(dwIDs[0]); i++)
            GetDlgItem(dwIDs[i])->EnableWindow(FALSE);
    }

    LoadQuals();
	
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

#define DEF_FLAVOR  (WBEM_FLAVOR_FLAG_PROPAGATE_TO_INSTANCE |     \
                    WBEM_FLAVOR_FLAG_PROPAGATE_TO_DERIVED_CLASS | \
                    WBEM_FLAVOR_OVERRIDABLE |                     \
                    WBEM_FLAVOR_NOT_AMENDED)

void CPropQualsPg::OnAdd() 
{
    CEditQualDlg dlg;
    _variant_t   var;

    dlg.m_propUtil.m_bNewProperty = TRUE;
    dlg.m_propUtil.m_bIsQualifier = TRUE;
    dlg.m_propUtil.m_pNamespace = g_pOpView->GetDocument()->m_pNamespace;
    dlg.m_bIsInstance = m_bIsInstance;
    dlg.m_propUtil.m_prop.SetType(CIM_STRING);
    dlg.m_propUtil.m_pVar = &var;
    dlg.m_lFlavor = DEF_FLAVOR;

    if (dlg.DoModal() == IDOK)
    {
        HRESULT hr;

        if (SUCCEEDED(hr =
            m_pQuals->Put(
                _bstr_t(dlg.m_propUtil.m_prop.m_strName),
                &var,
                m_bIsInstance ? 0 : dlg.m_lFlavor)))
        {
            AddQualifier(
                dlg.m_propUtil.m_prop.m_strName,
                &var,
                dlg.m_lFlavor);
        }
        else
            CWMITestDoc::DisplayWMIErrorBox(hr);
    }    
}

void CPropQualsPg::OnEdit() 
{
    int iItem = m_ctlQuals.GetSelectionMark();

    if (iItem != -1)
    {
        CEditQualDlg dlg;
        CQual        &qual = m_listQuals.GetAt(m_listQuals.FindIndex(iItem));
        _variant_t   var = qual.m_var;

        dlg.m_propUtil.m_bNewProperty = FALSE;
        dlg.m_propUtil.m_bIsQualifier = TRUE;
        dlg.m_bIsInstance = m_bIsInstance;
        dlg.m_propUtil.m_prop.m_strName = qual.m_strName;
        dlg.m_propUtil.m_prop.SetType(QualTypeToCIMTYPE((VARENUM) qual.m_var.vt));
        dlg.m_propUtil.m_pVar = &var;
        dlg.m_lFlavor = qual.m_lFlavor;

        if (dlg.DoModal() == IDOK)
        {
            CString strValue;
            HRESULT hr;

            if (SUCCEEDED(hr =
                m_pQuals->Put(
                    _bstr_t(qual.m_strName),
                    &var,
                    m_bIsInstance ? 0 : dlg.m_lFlavor)))
            {
                qual.m_lFlavor = dlg.m_lFlavor;
                qual.m_var = var;

                dlg.m_propUtil.m_prop.VariantToString(&qual.m_var, strValue, TRUE);
                m_ctlQuals.SetItemText(iItem, 2, strValue);
            }
            else
                CWMITestDoc::DisplayWMIErrorBox(hr);
        }
    }
}

void CPropQualsPg::OnDelete() 
{
    int iItem = m_ctlQuals.GetSelectionMark();

    if (iItem != -1)
    {
        CQual   qual = m_listQuals.GetAt(m_listQuals.FindIndex(iItem));
        HRESULT hr;
        
        if (SUCCEEDED(hr =
            m_pQuals->Delete(_bstr_t(qual.m_strName))))
        {
            m_ctlQuals.DeleteItem(iItem);

            m_listQuals.RemoveAt(m_listQuals.FindIndex(iItem));

            // Save this so we can delete it later.
            //m_listQualsToDelete.AddTail(qual);

            int nItems = m_ctlQuals.GetItemCount();

            if (iItem >= nItems)
                iItem--;

            if (iItem >= 0)
                m_ctlQuals.SetItemState(iItem, LVIS_SELECTED, LVIS_SELECTED);
        }
        else
            CWMITestDoc::DisplayWMIErrorBox(hr);
    }
}

void CPropQualsPg::UpdateButtons()
{
    int iIndex = GetSelectedItem();

    GetDlgItem(IDC_DELETE)->EnableWindow(iIndex != -1);
    GetDlgItem(IDC_EDIT)->EnableWindow(iIndex != -1);
}

void CPropQualsPg::AddQualifier(LPCTSTR szName, VARIANT *pVar, long lFlavor)
{
    CQual qual;

    qual.m_strName = szName;
    qual.m_var = *pVar;
    qual.m_lFlavor = lFlavor;

    m_listQuals.AddTail(qual);

    CPropInfo prop;
    int       iImage,
              iItem = m_ctlQuals.GetItemCount();
    CIMTYPE   type = QualTypeToCIMTYPE((VARENUM) pVar->vt);
    CString   strType,
              strValue;

    prop.SetType(type);
    prop.GetPropType(strType, &iImage);
    prop.VariantToString(&qual.m_var, strValue, TRUE);

    m_ctlQuals.InsertItem(iItem, qual.m_strName, iImage);
    m_ctlQuals.SetItemText(iItem, 1, strType);
    m_ctlQuals.SetItemText(iItem, 2, strValue);
}

int CPropQualsPg::GetSelectedItem()
{
    POSITION pos = m_ctlQuals.GetFirstSelectedItemPosition();

    if (pos)
        return m_ctlQuals.GetNextSelectedItem(pos);
    else
        return -1;
}


void CPropQualsPg::OnDblclkQuals(NMHDR* pNMHDR, LRESULT* pResult) 
{
	OnEdit();
	
	*pResult = 0;
}

void CPropQualsPg::OnItemchangedQuals(NMHDR* pNMHDR, LRESULT* pResult) 
{
	//NM_LISTVIEW* pNMListView = (NM_LISTVIEW*)pNMHDR;

    UpdateButtons();
	
	*pResult = 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\wmitest\prefdlg.h ===
/*++

Copyright (C) 1997-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/
#if !defined(AFX_PREFDLG_H__29D844AC_3045_4049_AE2A_3DA179505946__INCLUDED_)
#define AFX_PREFDLG_H__29D844AC_3045_4049_AE2A_3DA179505946__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// PrefDlg.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CPrefDlg dialog

class CPrefDlg : public CDialog
{
// Construction
public:
	CPrefDlg(CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CPrefDlg)
	enum { IDD = IDD_PREF };
	BOOL	m_bLoadLast;
	BOOL	m_bShowSystem;
	BOOL	m_bShowInherited;
	BOOL	m_bEnablePrivsOnStartup;
	BOOL	m_bPrivsEnabled;
	//}}AFX_DATA
    DWORD   m_dwUpdateFlag,
            m_dwClassUpdateMode;


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CPrefDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CPrefDlg)
	afx_msg void OnEnablePrivs();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_PREFDLG_H__29D844AC_3045_4049_AE2A_3DA179505946__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\wmitest\propqualspg.h ===
/*++

Copyright (C) 1997-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/
#if !defined(AFX_PROPQUALSPG_H__42BE2BB5_536D_45D6_B307_4EEF803B35C9__INCLUDED_)
#define AFX_PROPQUALSPG_H__42BE2BB5_536D_45D6_B307_4EEF803B35C9__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// PropQualsPg.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CPropQualsPg dialog

class CQual
{
public:
    CString    m_strName;
    _variant_t m_var;
    long       m_lFlavor;
};

typedef CList<CQual, CQual&> CQualList;

class CPropQualsPg : public CPropertyPage
{
	DECLARE_DYNCREATE(CPropQualsPg)

// Construction
public:
	CPropQualsPg();
	~CPropQualsPg();

// Dialog Data
	enum QUAL_MODE
    {
        QMODE_PROP,
        QMODE_CLASS,
        QMODE_METHOD
    };

    //{{AFX_DATA(CPropQualsPg)
	enum { IDD = IDD_QUALS };
	CListCtrl	m_ctlQuals;
	//}}AFX_DATA
    IWbemClassObject *m_pObj;
    QUAL_MODE        m_mode;
    BOOL             m_bIsInstance; // Applies only to property qualifer mode.
    CPropInfo        m_propInfo;
    CString          m_strMethodName;

// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CPropQualsPg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
    enum PROP_TYPE
    {
        PROP_KEY,
        PROP_INDEXED,
        PROP_NOT_NULL,
        PROP_NORMAL
    };

    IWbemQualifierSet *m_pQuals;
    CQualList         m_listQuals;
                      //m_listQualsToDelete;
    PROP_TYPE         m_type;

	void InitListCtrl();
    void LoadQuals();
    void UpdateButtons();
    CIMTYPE QualTypeToCIMTYPE(VARENUM vt);
    void AddQualifier(LPCTSTR szName, VARIANT *pVar, long lFlavor);
    int GetSelectedItem();
    LPCWSTR TypeToQual(PROP_TYPE type);
    HRESULT InitQualSet();
    BOOL IsInPropMode() { return m_mode == QMODE_PROP; }

    // Generated message map functions
	//{{AFX_MSG(CPropQualsPg)
	virtual BOOL OnInitDialog();
	afx_msg void OnAdd();
	afx_msg void OnEdit();
	afx_msg void OnDelete();
	afx_msg void OnDblclkQuals(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnItemchangedQuals(NMHDR* pNMHDR, LRESULT* pResult);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_PROPQUALSPG_H__42BE2BB5_536D_45D6_B307_4EEF803B35C9__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\wmitest\querycolpg.cpp ===
/*++

Copyright (C) 1997-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/

// QueryColPg.cpp : implementation file
//

#include "stdafx.h"
#include "WMITest.h"
#include "QueryColPg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CQueryColPg property page

IMPLEMENT_DYNCREATE(CQueryColPg, CPropertyPage)

CQueryColPg::CQueryColPg() : CPropertyPage(CQueryColPg::IDD)
{
	//{{AFX_DATA_INIT(CQueryColPg)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
}

CQueryColPg::~CQueryColPg()
{
}

void CQueryColPg::DoDataExchange(CDataExchange* pDX)
{
	CPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CQueryColPg)
	DDX_Control(pDX, IDC_SELECTED, m_ctlSelected);
	DDX_Control(pDX, IDC_AVAILABLE, m_ctlAvailable);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CQueryColPg, CPropertyPage)
	//{{AFX_MSG_MAP(CQueryColPg)
	ON_BN_CLICKED(IDC_ADD, OnAdd)
	ON_BN_CLICKED(IDC_REMOVE, OnRemove)
	ON_BN_CLICKED(IDC_ADD_ALL, OnAddAll)
	ON_BN_CLICKED(IDC_REMOVE_ALL, OnRemoveAll)
	ON_LBN_SELCHANGE(IDC_SELECTED, OnSelchangeSelected)
	ON_LBN_SELCHANGE(IDC_AVAILABLE, OnSelchangeAvailable)
	ON_LBN_DBLCLK(IDC_SELECTED, OnDblclkSelected)
	ON_LBN_DBLCLK(IDC_AVAILABLE, OnDblclkAvailable)
	ON_BN_CLICKED(IDC_UP, OnUp)
	ON_BN_CLICKED(IDC_DOWN, OnDown)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CQueryColPg message handlers

void CQueryColPg::OnAdd() 
{
    int nCount = m_ctlAvailable.GetSelCount();

    if (nCount)
    {
        int     *piItems = new int[nCount];
        CString strProp;

        m_ctlAvailable.GetSelItems(nCount, piItems);

        for (int i = 0; i < nCount; i++)
        {
            int iWhere = piItems[i] - i;
            
            m_ctlAvailable.GetText(iWhere, strProp);
            m_ctlAvailable.DeleteString(iWhere);

            m_ctlSelected.AddString(strProp);
        }

        delete piItems;
    }

    UpdateButtons();
}

void CQueryColPg::OnRemove() 
{
    int nCount = m_ctlSelected.GetSelCount();

    if (nCount)
    {
        int     *piItems = new int[nCount];
        CString strProp;

        m_ctlSelected.GetSelItems(nCount, piItems);

        for (int i = 0; i < nCount; i++)
        {
            int iWhere = piItems[i] - i;

            m_ctlSelected.GetText(iWhere, strProp);
            m_ctlSelected.DeleteString(iWhere);

            m_ctlAvailable.AddString(strProp);
        }

        delete piItems;
    }

    UpdateButtons();
}

void CQueryColPg::OnAddAll() 
{
    int     nCount = m_ctlAvailable.GetCount(),
            iWhere = m_ctlSelected.GetCurSel();
    CString strProp;

    if (iWhere == -1)
        iWhere = 0;

    for (int i = 0; i < nCount; i++)
    {
        m_ctlAvailable.GetText(i, strProp);

        m_ctlSelected.InsertString(iWhere + i, strProp);
    }

    m_ctlAvailable.ResetContent();

    UpdateButtons();
}

void CQueryColPg::OnRemoveAll() 
{
    int     nCount = m_ctlSelected.GetCount();
    CString strProp;

    for (int i = 0; i < nCount; i++)
    {
        m_ctlSelected.GetText(i, strProp);

        m_ctlAvailable.AddString(strProp);
    }

    m_ctlSelected.ResetContent();

    UpdateButtons();
}

BOOL CQueryColPg::OnSetActive() 
{
	if (m_pSheet->m_bColsNeeded)
    {
        m_pSheet->m_bColsNeeded = FALSE;
        
        LoadList();                                      
    }

    UpdateButtons();

    return CPropertyPage::OnSetActive();
}

void CQueryColPg::LoadList()
{
    CWaitCursor      wait;
    SAFEARRAY        *pArr = NULL;
    HRESULT          hr;
    IWbemClassObject *pClass = NULL;

    m_ctlSelected.ResetContent();
    m_ctlAvailable.ResetContent();
    
    if (SUCCEEDED(hr = m_pSheet->m_pNamespace->GetObject(
                           _bstr_t(m_pSheet->m_strClass),
                           WBEM_FLAG_RETURN_WBEM_COMPLETE,
                           NULL,
                           &pClass,
                           NULL)))
    {
        hr = 
            pClass->GetNames(
                NULL,
                WBEM_FLAG_ALWAYS,
                NULL,
                &pArr);

        if (SUCCEEDED(hr))
        {
            BSTR *pNames = (BSTR*) pArr->pvData;

            for (int i = 0; 
                i < (int) pArr->rgsabound[0].cElements;
                i++)
            {
                m_ctlAvailable.AddString(_bstr_t(pNames[i]));
            }

            SafeArrayDestroy(pArr);
        }

        pClass->Release();
    }
}

#define IDC_FINISH  0x3025

void CQueryColPg::UpdateButtons()
{
    BOOL bSelColSelected = m_ctlSelected.GetSelCount() != 0,
         bAllSelected = m_ctlSelected.GetSelCount() == m_ctlSelected.GetCount();

    GetDlgItem(IDC_ADD)->EnableWindow(m_ctlAvailable.GetSelCount() != 0);
    GetDlgItem(IDC_REMOVE)->EnableWindow(bSelColSelected);
    GetDlgItem(IDC_UP)->EnableWindow(bSelColSelected && !bAllSelected);
    GetDlgItem(IDC_DOWN)->EnableWindow(bSelColSelected && !bAllSelected);

    GetDlgItem(IDC_ADD_ALL)->EnableWindow(m_ctlAvailable.GetCount() != 0);
    GetDlgItem(IDC_REMOVE_ALL)->EnableWindow(m_ctlSelected.GetCount() != 0);

    m_pSheet->SetWizardButtons(PSWIZB_BACK | 
        (m_ctlSelected.GetCount() != 0 ? PSWIZB_FINISH : PSWIZB_DISABLEDFINISH));
}


void CQueryColPg::OnSelchangeSelected() 
{
    UpdateButtons();
}

void CQueryColPg::OnSelchangeAvailable() 
{
    UpdateButtons();
}

void CQueryColPg::OnDblclkSelected() 
{
    OnRemove();
}

void CQueryColPg::OnDblclkAvailable() 
{
    OnAdd();
}

BOOL CQueryColPg::OnWizardFinish() 
{
    // If m_ctlAvailable is empty we can assume they want all the 
    // properties.
    if (m_ctlAvailable.GetCount() == 0)
        m_pSheet->m_strQuery.Format(
            _T("select * from %s"), 
            (LPCTSTR) m_pSheet->m_strClass);
    else
    {
        CString strProps,
                strProp;
        int     nProps = m_ctlSelected.GetCount();

        for (int i = 0; i < nProps; i++)
        {
            if (i != 0)
                strProps += _T(",");
                
            m_ctlSelected.GetText(i, strProp);
            strProps += strProp;
        }

        m_pSheet->m_strQuery.Format(
            _T("select %s from %s"), 
            (LPCTSTR) strProps,
            (LPCTSTR) m_pSheet->m_strClass);
    }
	
	return CPropertyPage::OnWizardFinish();
}

void CQueryColPg::OnUp() 
{
    int nCount = m_ctlSelected.GetSelCount();

    if (nCount)
    {
        int     *piItems = new int[nCount],
                iBegin;
        CString strProp;

        m_ctlSelected.GetSelItems(nCount, piItems);

        // Find the first one we can move up.
        for (iBegin = 0; iBegin < nCount && piItems[iBegin] == iBegin; 
            iBegin++)
        {
        }

        for (int i = iBegin; i < nCount; i++)
        {
            int iWhere = piItems[i];

            if (iWhere != 0)
            {
                m_ctlSelected.GetText(iWhere, strProp);
                m_ctlSelected.DeleteString(iWhere);

                m_ctlSelected.InsertString(iWhere - 1, strProp);
                m_ctlSelected.SetSel(iWhere - 1, TRUE);
            }
        }

        delete piItems;
    }

    UpdateButtons();
}

void CQueryColPg::OnDown() 
{
    int nCount = m_ctlSelected.GetSelCount();

    if (nCount)
    {
        int     *piItems = new int[nCount],
                nListCount = m_ctlSelected.GetCount(),
                iBegin,
                i;
        CString strProp;

        m_ctlSelected.GetSelItems(nCount, piItems);

        // Find the first one we can move down.
        for (i = nListCount - 1, iBegin = nCount - 1; 
            iBegin >= 0 && piItems[iBegin] == i; 
            iBegin--, i--)
        {
        }

        for (i = iBegin; i >= 0; i--)
        {
            int iWhere = piItems[i];

            if (iWhere != m_ctlSelected.GetCount() - 1)
            {
                m_ctlSelected.GetText(iWhere, strProp);
                m_ctlSelected.DeleteString(iWhere);

                m_ctlSelected.InsertString(iWhere + 1, strProp);
                m_ctlSelected.SetSel(iWhere + 1, TRUE);
            }
        }

        delete piItems;
    }

    UpdateButtons();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\wmitest\propspg.h ===
/*++

Copyright (C) 1997-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/

#if !defined(AFX_PROPSPG_H__017BA77D_2EEE_406B_B751_13E29D83BC9A__INCLUDED_)
#define AFX_PROPSPG_H__017BA77D_2EEE_406B_B751_13E29D83BC9A__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// PropsPg.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CPropsPg dialog

class CPropsPg : public CPropertyPage
{
	DECLARE_DYNCREATE(CPropsPg)

// Construction
public:
	CPropsPg();
	~CPropsPg();

// Dialog Data
	//{{AFX_DATA(CPropsPg)
	enum { IDD = IDD_PROPS };
	CListCtrl	m_ctlProps;
	//}}AFX_DATA
    IWbemServices *m_pNamespace;
    CObjInfo      *m_pObj;


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CPropsPg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
    BOOL m_bShowSystemProperties,
         m_bShowInheritedProperties,
         m_bTranslateValues;

	void InitListCtrl();
    void LoadProps();
    void UpdateButtons();
    void AddProp(LPCTSTR szName, VARIANT *pVar, CIMTYPE type, long lFlavor);
    int GetSelectedItem();

	// Generated message map functions
	//{{AFX_MSG(CPropsPg)
	afx_msg void OnAdd();
	afx_msg void OnEdit();
	afx_msg void OnDelete();
	afx_msg void OnDblclkProps(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnItemchangedProps(NMHDR* pNMHDR, LRESULT* pResult);
	virtual BOOL OnInitDialog();
	afx_msg void OnSystem();
	afx_msg void OnInherited();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_PROPSPG_H__017BA77D_2EEE_406B_B751_13E29D83BC9A__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\wmitest\propspg.cpp ===
/*++

Copyright (C) 1997-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/

// PropsPg.cpp : implementation file
//

#include "stdafx.h"
#include "wmitest.h"
#include "OpWrap.h"
#include "PropsPg.h"
#include "WMITestDoc.h"
#include "ObjVw.h"
#include "OpView.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CPropsPg property page

IMPLEMENT_DYNCREATE(CPropsPg, CPropertyPage)

CPropsPg::CPropsPg() : 
    CPropertyPage(CPropsPg::IDD),
    m_pObj(NULL),
    //m_bShowSystemProperties(theApp.m_bShowSystemProperties),
    //m_bShowInheritedProperties(theApp.m_bShowInheritedProperties),
    m_bTranslateValues(theApp.m_bTranslateValues)
{
	//{{AFX_DATA_INIT(CPropsPg)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT

    m_bShowSystemProperties = 
        theApp.GetProfileInt(_T("Settings"), _T("ShowSysOnDlg"), TRUE);

    m_bShowInheritedProperties = 
        theApp.GetProfileInt(_T("Settings"), _T("ShowInheritedOnDlg"), TRUE);
}

CPropsPg::~CPropsPg()
{
    theApp.WriteProfileInt(_T("Settings"), _T("ShowSysOnDlg"), 
        m_bShowSystemProperties);

    theApp.WriteProfileInt(_T("Settings"), _T("ShowInheritedOnDlg"), 
        m_bShowInheritedProperties);
}

void CPropsPg::DoDataExchange(CDataExchange* pDX)
{
	CPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CPropsPg)
	DDX_Control(pDX, IDC_PROPS, m_ctlProps);
	//}}AFX_DATA_MAP

}

void CPropsPg::InitListCtrl()
{
    RECT    rect;
    CString strTemp;
            
	m_ctlProps.SetExtendedStyle(LVS_EX_FULLROWSELECT);

    m_ctlProps.SetImageList(&((CMainFrame *) AfxGetMainWnd())->m_imageList, 
		LVSIL_SMALL);
    m_ctlProps.GetClientRect(&rect);

    strTemp.LoadString(IDS_NAME);
    m_ctlProps.InsertColumn(0, strTemp, LVCFMT_LEFT, rect.right * 25 / 100);
            
    strTemp.LoadString(IDS_TYPE);
    m_ctlProps.InsertColumn(1, strTemp, LVCFMT_LEFT, rect.right * 25 / 100);
            
    strTemp.LoadString(IDS_VALUE);
    m_ctlProps.InsertColumn(2, strTemp, LVCFMT_LEFT, rect.right * 50 / 100);
}

void CPropsPg::LoadProps()
{
    int       nItems = m_pObj->GetProps()->GetSize(),
              iItem = 0;
    CPropInfo *pProps = m_pObj->GetProps()->GetData();

    m_ctlProps.DeleteAllItems();

    for (int i = 0; i < nItems; i++)
    {
        CString strType,
                strValue;
        int     iImage,
                iFlavor;

        m_pObj->GetPropInfo(i, strValue, strType, &iImage, &iFlavor, 
            m_bTranslateValues);

        
        if ((m_bShowSystemProperties || iFlavor != WBEM_FLAVOR_ORIGIN_SYSTEM) &&
            (m_bShowInheritedProperties || 
            iFlavor != WBEM_FLAVOR_ORIGIN_PROPAGATED))
        {
            m_ctlProps.InsertItem(iItem, pProps[i].m_strName, iImage);
            m_ctlProps.SetItemData(iItem, i);
            m_ctlProps.SetItemText(iItem, 1, strType);
            m_ctlProps.SetItemText(iItem, 2, strValue);

            iItem++;
        }
    }
            
    UpdateButtons();

    //if (FAILED(hr))
    //    CWMITestDoc::DisplayWMIErrorBox(hr, NULL);
}

int CPropsPg::GetSelectedItem()
{
    POSITION pos = m_ctlProps.GetFirstSelectedItemPosition();

    if (pos)
        return m_ctlProps.GetNextSelectedItem(pos);
    else
        return -1;
}

void CPropsPg::UpdateButtons()
{
    int iIndex = GetSelectedItem();

    GetDlgItem(IDC_DELETE)->EnableWindow(iIndex != -1);
    GetDlgItem(IDC_EDIT)->EnableWindow(iIndex != -1);
}

BEGIN_MESSAGE_MAP(CPropsPg, CPropertyPage)
	//{{AFX_MSG_MAP(CPropsPg)
	ON_BN_CLICKED(IDC_ADD, OnAdd)
	ON_BN_CLICKED(IDC_EDIT, OnEdit)
	ON_BN_CLICKED(IDC_DELETE, OnDelete)
	ON_NOTIFY(NM_DBLCLK, IDC_PROPS, OnDblclkProps)
	ON_NOTIFY(LVN_ITEMCHANGED, IDC_PROPS, OnItemchangedProps)
	ON_BN_CLICKED(IDC_SYSTEM, OnSystem)
	ON_BN_CLICKED(IDC_INHERITED, OnInherited)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CPropsPg message handlers

void CPropsPg::OnAdd() 
{
    CString strName;

    if (CObjView::AddProperty(m_pObj, strName))
    {
        m_pObj->LoadProps(g_pOpView->GetDocument()->m_pNamespace);

        LoadProps();
            
        // Now try to find the item we just added.
        LVFINDINFO find;
        int        iItem;

        find.flags = LVFI_STRING;
        find.psz = strName;

        iItem = m_ctlProps.FindItem(&find);

        if (iItem != -1)
        {
            m_ctlProps.EnsureVisible(iItem, FALSE);
            m_ctlProps.SetItemState(iItem, LVIS_SELECTED, LVIS_SELECTED);
        }
    }
}

void CPropsPg::OnEdit() 
{
    int iItem = GetSelectedItem();
        
    if (iItem != -1)
    {
        CPropInfo  *pProp;
        _variant_t var;

        iItem = m_ctlProps.GetItemData(iItem);
        pProp = &m_pObj->GetProps()->GetData()[iItem];
        m_pObj->ValueToVariant(iItem, &var);

        if (CObjView::EditProperty(m_pObj, pProp, &var))
        {
            LoadProps();
            m_ctlProps.EnsureVisible(iItem, FALSE);
            m_ctlProps.SetItemState(iItem, LVIS_SELECTED, LVIS_SELECTED);
        }

        // Otherwise the destructor freaks out because it doesn't know what to 
        // do with VT_I8.
        if (var.vt == VT_I8)
            var.vt = VT_I4;
    }
}

void CPropsPg::OnDelete() 
{
    int iItem = GetSelectedItem();
        
    if (iItem != -1)
    {
        CString strProperty = m_ctlProps.GetItemText(iItem, 0);
        HRESULT hr;

        hr = m_pObj->m_pObj->Delete(_bstr_t(strProperty));

        if (SUCCEEDED(hr))
        {
            m_pObj->LoadProps(g_pOpView->GetDocument()->m_pNamespace);

            LoadProps();
            
            if (iItem >= m_ctlProps.GetItemCount())
                iItem--;

            if (iItem >= 0)
            {
                m_ctlProps.EnsureVisible(iItem, FALSE);
                m_ctlProps.SetItemState(iItem, LVIS_SELECTED, LVIS_SELECTED);
            }
        }
        else
            CWMITestDoc::DisplayWMIErrorBox(hr);
    }
}

void CPropsPg::OnDblclkProps(NMHDR* pNMHDR, LRESULT* pResult) 
{
	OnEdit();
	
	*pResult = 0;
}

void CPropsPg::OnItemchangedProps(NMHDR* pNMHDR, LRESULT* pResult) 
{
	NM_LISTVIEW* pNMListView = (NM_LISTVIEW*)pNMHDR;

    UpdateButtons();
	
	*pResult = 0;
}

BOOL CPropsPg::OnInitDialog() 
{
	CPropertyPage::OnInitDialog();
	
    CheckDlgButton(IDC_SYSTEM, m_bShowSystemProperties); 
    CheckDlgButton(IDC_INHERITED, m_bShowInheritedProperties); 

    InitListCtrl();
	
    LoadProps();

	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

void CPropsPg::OnSystem() 
{
    m_bShowSystemProperties ^= 1;
    
    LoadProps();	
}

void CPropsPg::OnInherited() 
{
    m_bShowInheritedProperties ^= 1;
    
    LoadProps();	
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\wmitest\proputil.h ===
/*++

Copyright (C) 1997-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/

// PropUtil.h: interface for the CPropUtil class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_PROPUTIL_H__6F2C145F_F170_480E_B56B_C80A0039E388__INCLUDED_)
#define AFX_PROPUTIL_H__6F2C145F_F170_480E_B56B_C80A0039E388__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "OpWrap.h"

void ValuemapValuesToCombo(HWND hwnd, CPropInfo *pProp, LPCTSTR szDefault);
void BitmaskValuesToCheckListbox(CCheckListBox &ctlListbox, CPropInfo *pProp, 
	DWORD dwDefValue);
void CheckListboxToBitmaskValue(CCheckListBox &ctlListBox, DWORD *pdwValue);

class CSinglePropUtil
{
public:
    BOOL      m_bNewProperty;
    CPropInfo m_prop;
    VARIANT   *m_pVar;
    BOOL      m_bTranslate;

    CSinglePropUtil() :
        m_bControlsInited(FALSE)
    {
    }

    void Init(CWnd *pWnd) { m_pWnd = pWnd; }

    void SetType(CIMTYPE type);
    void ShowControls(BOOL bShow);
    void EnableControls(BOOL bEnable);

	void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support

    // Fake message handlers.
    void OnEditEmbedded();
    void OnClearEmbedded();
    BOOL OnInitDialog();

    static void EditObj(IUnknown *pUnk);
    static BOOL GetNewObj(IUnknown **ppUnk);

protected:
	CCheckListBox m_ctlBitmaskValues;
	CComboBox     m_ctlListValues;
    CEdit         m_ctlScalar,
                  m_ctlText;
    IUnknownPtr   m_pObjValue;
    BOOL          m_bControlsInited;
    CRect         m_rectScalar,
                  m_rectText;

	enum VALUE_TYPE
	{
		TYPE_EDIT_TEXT,
        TYPE_EDIT_SCALAR,
		TYPE_CHECKLISTBOX,
		TYPE_DROPDOWN,
		TYPE_DROPDOWNLIST,
        TYPE_EDIT_OBJ,
	};

    CWnd *m_pWnd;
	VALUE_TYPE m_type;
    DWORD m_dwScalarID;

    void InitTypeCombo();
    CIMTYPE GetCurrentType();
    void InitControls();
};

class CPropUtil  
{
public:
    CComboBox m_ctlTypes;
    BOOL      m_bNewProperty,
              m_bIsQualifier;
    CPropInfo m_prop;
    VARIANT   *m_pVar;
    BOOL      m_bTranslate;

	// Needed for spawning instances for embedded objects.
    IWbemServices *m_pNamespace;

    CPropUtil();
	virtual ~CPropUtil();

    void Init(CWnd *pWnd);

	void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	void OnNull();
	void OnAdd();
	void OnDelete();
	void OnUp();
	void OnDown();
	void OnSelchangeValueArray();
    void OnSelchangeType();
	void OnEdit();
	void OnArray();
    void OnEditEmbedded();
    void OnClearEmbedded();
    void OnDblclkArrayValues();
	BOOL OnInitDialog();
    BOOL OnSetActive();

protected:
	enum VALUE_TYPE
	{
		TYPE_EDIT,
		TYPE_CHECKLISTBOX,
		TYPE_DROPDOWN,
		TYPE_DROPDOWNLIST,
		TYPE_ARRAYLISTBOX,
	};

    CWnd *m_pWnd;
    CSinglePropUtil m_spropUtil;
	CListBox m_ctlArrayValues;

	VALUE_TYPE m_type;
    DWORD m_dwScalarID;
    BOOL m_bOnInitDialog;

    BOOL IsObjEdit() { return GetCurrentType() == CIM_OBJECT; }
    void UpdateArrayButtons();
    void Modify(BOOL bEdit);
    void InitTypeCombo();
    CIMTYPE GetCurrentType();

    void ShowArrayControls(BOOL bVal);
    void MoveArrayButtons();
};

#endif // !defined(AFX_PROPUTIL_H__6F2C145F_F170_480E_B56B_C80A0039E388__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\wmitest\proputil.cpp ===
/*++

Copyright (C) 1997-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/

// PropUtil.cpp: implementation of the CPropUtil class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "wmitest.h"
#include "GetTextDlg.h"
#include "OpWrap.h"
#include "PropUtil.h"
#include "WMITestDoc.h"
#include "OpView.h"
#include "ArrayItemDlg.h"

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#define new DEBUG_NEW
#endif

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CPropUtil::CPropUtil() :
    m_bTranslate(TRUE),
    m_bNewProperty(FALSE),
    m_bIsQualifier(FALSE),
    m_pNamespace(NULL),
    m_bOnInitDialog(FALSE)
{

}

CPropUtil::~CPropUtil()
{

}


void ArrayValuesToList(HWND hwnd, CPropInfo *pProp, VARIANT *pVar, 
    BOOL bTranslate)
{
	SendMessage(hwnd, LB_RESETCONTENT, 0, 0);

	if (pVar->vt != VT_NULL)
    {
        int  nItems = pProp->GetArrayItemCount(pVar);
        BOOL bIsBitmask = pProp->IsBitmask() && bTranslate,
             bObjEdit = (pVar->vt & ~VT_ARRAY) == VT_UNKNOWN;

        for (int i = 0; i < nItems; i++)
        {
            CString strItem;
            int     iIndex;

            pProp->ArrayItemToString(pVar, i, strItem, bTranslate);
            
            iIndex = SendMessage(hwnd, LB_ADDSTRING, 0, (LPARAM) (LPCTSTR) strItem);
            if (bIsBitmask || bObjEdit)
            {
                DWORD dwItem = pProp->GetArrayItem(pVar, i);

                SendMessage(hwnd, LB_SETITEMDATA, iIndex, dwItem);

                if (bObjEdit)
                    ((IUnknown*) dwItem)->AddRef();
            }
        }
    }
}

void ListToArrayValues(HWND hwnd, CPropInfo *pProp, VARIANT *pVar, 
    BOOL bTranslate)
{
	int  nItems = SendMessage(hwnd, LB_GETCOUNT, 0, 0);
    BOOL bUseData = (pProp->IsBitmask() && bTranslate) || 
                        pProp->GetRawType() == VT_UNKNOWN;

    pProp->PrepArrayVar(pVar, nItems);

    for (int i = 0; i < nItems; i++)
    {
        TCHAR szItem[1024] = _T("");

        if (!bUseData)
        {
            SendMessage(hwnd, LB_GETTEXT, i, (LPARAM) szItem);
            pProp->StringToArrayItem(szItem, pVar, i, bTranslate);
        }
        else
        {
            DWORD dwValue = SendMessage(hwnd, LB_GETITEMDATA, i, 0);

            pProp->SetArrayItem(pVar, i, dwValue);
        }
    }
}

void ValuemapValuesToCombo(HWND hwnd, CPropInfo *pProp, LPCTSTR szDefault)
{
	SendMessage(hwnd, CB_RESETCONTENT, 0, 0);

	if (pProp->GetRawType() != CIM_BOOLEAN)
    {
        POSITION pos = pProp->m_mapValues.GetStartPosition();

        while(pos)
        {
            CString strKey,
                    strValue;

            pProp->m_mapValues.GetNextAssoc(pos, strKey, strValue);

            SendMessage(hwnd, CB_ADDSTRING, 0, (LPARAM) (LPCTSTR) strValue);
        }
    }
    else
    {
        CString strTemp;

        strTemp.LoadString(IDS_FALSE);
        SendMessage(hwnd, CB_ADDSTRING, 0, (LPARAM) (LPCTSTR) strTemp);

        strTemp.LoadString(IDS_TRUE);
        SendMessage(hwnd, CB_ADDSTRING, 0, (LPARAM) (LPCTSTR) strTemp);
    }

	// Try to select the default.
	if (SendMessage(hwnd, CB_SELECTSTRING, 0, (LPARAM) szDefault) == CB_ERR)
	{
		DWORD dwStyle = GetWindowLong(hwnd, GWL_STYLE);

		// If that didn't work...
		if ((dwStyle & CBS_DROPDOWNLIST) == CBS_DROPDOWNLIST || !*szDefault)
			// If we're a drop down list, choose the first item.
			SendMessage(hwnd, CB_SETCURSEL, 0, 0);
		else
			// If we're a drop down, set the window text.
			SetWindowText(hwnd, szDefault);
	}
}

void BitmaskValuesToCheckListbox(CCheckListBox &ctlListbox, CPropInfo *pProp, 
	DWORD dwDefValue)
{
	int nValues = pProp->m_bitmaskValues.GetSize();

	ctlListbox.ResetContent();

    for (int i = 0; i < nValues; i++)
    {
        DWORD dwValue = pProp->m_bitmaskValues[i].m_dwBitmaskValue;
        int   nIndex;

        nIndex = ctlListbox.AddString(pProp->m_bitmaskValues[i].m_strName);
        ctlListbox.SetItemData(nIndex, dwValue);

        if (dwDefValue & dwValue)
            ctlListbox.SetCheck(nIndex, TRUE);
    }
}

void BitmaskValueToCheckListbox(CCheckListBox &ctlListbox, DWORD dwValue)
{
	int nValues = ctlListbox.GetCount();

    for (int i = 0; i < nValues; i++)
    {
        DWORD dwItemValue = ctlListbox.GetItemData(i);

        ctlListbox.SetCheck(i, (dwItemValue & dwValue) != 0);
    }
}

void CheckListboxToBitmaskValue(CCheckListBox &ctlListBox, DWORD *pdwValue)
{
	int nItems = ctlListBox.GetCount();

    *pdwValue = 0;

	for (int i = 0; i < nItems; i++)
	{
		if (ctlListBox.GetCheck(i))
            *pdwValue |= ctlListBox.GetItemData(i);
	}
}

void CPropUtil::Init(CWnd *pWnd) 
{
    m_pWnd = pWnd; 
    m_spropUtil.Init(pWnd); 
    m_spropUtil.m_pVar = m_pVar;
    m_spropUtil.m_prop = m_prop;
    m_spropUtil.m_bTranslate = m_bTranslate;
    m_spropUtil.m_bNewProperty = m_bNewProperty;
}

CIMTYPE CPropUtil::GetCurrentType()
{
    int iIndex = m_ctlTypes.GetCurSel();
    
    return (CIMTYPE) m_ctlTypes.GetItemData(iIndex);
}

void CPropUtil::DoDataExchange(CDataExchange* pDX)
{
    DDX_Control(pDX, IDC_TYPE, m_ctlTypes);
    DDX_Control(pDX, IDC_ARRAY_VALUES, m_ctlArrayValues);
    //DDX_Control(pDX, IDC_BITMASK_ARRAY, m_ctlBitmaskValues);
    //DDX_Control(pDX, IDC_VALUE_LIST, m_ctlListValues);

    BOOL bNull = m_pVar->vt == VT_NULL,
         bArray = m_prop.IsArray();

	// Setup lots of stuff if we're entering the dialog.
    if (!pDX->m_bSaveAndValidate)
	{
        CString strValue,
                strType;
        BOOL    bIsBool = m_prop.GetRawCIMType() == CIM_BOOLEAN;

        m_spropUtil.DoDataExchange(pDX);

        // Set the property name
        m_pWnd->SetDlgItemText(IDC_NAME, m_prop.m_strName);
        
        // Init the type combo box.
        InitTypeCombo();

        if (!m_bNewProperty)
        {
            m_pWnd->GetDlgItem(IDC_TYPE)->EnableWindow(FALSE);
            m_pWnd->GetDlgItem(IDC_ARRAY)->EnableWindow(FALSE);
            ((CEdit*) m_pWnd->GetDlgItem(IDC_NAME))->SetReadOnly(TRUE);
        }

        // Set the NULL checkbox.
        m_pWnd->CheckDlgButton(IDC_NULL, bNull);

        m_pWnd->CheckDlgButton(IDC_ARRAY, bArray);
        
        // This will simulate the array button getting checked so our
        // controls get hidden or shown.
        OnArray();

        // Add the array strings.
        if (bArray)
        {
            ArrayValuesToList(m_ctlArrayValues.m_hWnd, &m_prop, m_pVar, 
                m_bTranslate);
            
            UpdateArrayButtons();
        }

        // This will simulate the null button getting checked so our
        // controls get enabled/disabled.
        OnNull();
    }
    else // Time to put the data back into the variant.
    {
        BOOL bArray = m_pWnd->IsDlgButtonChecked(IDC_ARRAY),
             bEmbeddedObject = GetCurrentType() == CIM_OBJECT;

        if (m_bNewProperty)
        {
            CIMTYPE type = GetCurrentType();

            m_pWnd->GetDlgItemText(IDC_NAME, m_prop.m_strName);
            
            if (bArray)
                type |= CIM_FLAG_ARRAY;

            m_prop.SetType(type);
        }

        if (m_pWnd->IsDlgButtonChecked(IDC_NULL))
        {
            VariantClear(m_pVar);

            m_pVar->vt = VT_NULL;
        }
        else
        {
            if (bArray)
                ListToArrayValues(m_ctlArrayValues.m_hWnd, &m_prop, 
                    m_pVar, m_bTranslate);
            else
                m_spropUtil.DoDataExchange(pDX);
        }
    }
}


/////////////////////////////////////////////////////////////////////////////
// CPropUtil message handlers

void CPropUtil::UpdateArrayButtons()
{
    BOOL bIsNull = m_pWnd->IsDlgButtonChecked(IDC_NULL);

    if (!bIsNull)
    {
        int	iWhere = m_ctlArrayValues.GetCurSel(),
	        nItems = m_ctlArrayValues.GetCount();

        m_pWnd->GetDlgItem(IDC_UP)->EnableWindow(iWhere > 0);
        m_pWnd->GetDlgItem(IDC_DOWN)->EnableWindow(iWhere != -1 && iWhere != nItems - 1);
        m_pWnd->GetDlgItem(IDC_DELETE)->EnableWindow(iWhere != -1);
        m_pWnd->GetDlgItem(IDC_EDIT)->EnableWindow(iWhere != -1);
    }
}

void CPropUtil::OnNull() 
{
    BOOL bIsNull = m_pWnd->IsDlgButtonChecked(IDC_NULL);

    const DWORD dwToEnable[] =
    {
        IDC_ARRAY_VALUES,
        IDC_ADD,
        IDC_EDIT,
        IDC_DELETE,
        IDC_UP,
        IDC_DOWN,
    };

    for (int i = 0; i < sizeof(dwToEnable) / sizeof(DWORD); i++)
        m_pWnd->GetDlgItem(dwToEnable[i])->EnableWindow(!bIsNull);

    m_spropUtil.EnableControls(!bIsNull);

    UpdateArrayButtons();
}

void CPropUtil::OnAdd() 
{
    Modify(FALSE);
}

void CPropUtil::OnEdit() 
{
    int iWhich = m_ctlArrayValues.GetCurSel();
    
    Modify(iWhich != -1);
}

void CPropUtil::Modify(BOOL bEdit)
{
    if (GetCurrentType() == CIM_OBJECT)
    {
        int iItem = m_ctlArrayValues.GetCurSel();

        if (bEdit)
        {
            IUnknown *pUnk = (IUnknown*) m_ctlArrayValues.GetItemData(iItem);

            CSinglePropUtil::EditObj(pUnk);
        }
        else
        {
            // Not a smart pointer because we'll release it later.
            IUnknown *pUnk = NULL;

            if (CSinglePropUtil::GetNewObj(&pUnk))
            {
                CString strText;

                CSinglePropUtil::EditObj(pUnk);

                //strText.Format(IDS_EMBEDDED_OBJECT, (IUnknown*) pUnk);
                strText = GetEmbeddedObjectText(pUnk);
                
                iItem = m_ctlArrayValues.InsertString(iItem, strText);
                m_ctlArrayValues.SetItemData(iItem, (DWORD_PTR) pUnk);
            }
        }

        return;
    }

    DWORD         dwData = 0;
    CArrayItemDlg dlg;
    _variant_t    var;

    dlg.m_spropUtil.m_bNewProperty = !bEdit;
    dlg.m_spropUtil.m_bTranslate = m_bTranslate;
    dlg.m_spropUtil.m_pVar = &var;
    
    if (!m_bNewProperty)
        dlg.m_spropUtil.m_prop = m_prop;
    else
        dlg.m_spropUtil.m_prop.SetType(GetCurrentType());

    if (bEdit)
    {
        int  iItem = m_ctlArrayValues.GetCurSel();
        BOOL bIsBitmap = m_prop.IsBitmask() && m_bTranslate;

        if (bIsBitmap)
        {
            var = (long) m_ctlArrayValues.GetItemData(iItem);
            var.vt = m_prop.GetRawType();
        }
        else
        {
            CString strValue;
            BOOL    bIsObjEdit = GetCurrentType() == CIM_OBJECT;
        
            if (!bIsObjEdit)
            {
                m_ctlArrayValues.GetText(iItem, strValue);

                dlg.m_spropUtil.m_prop.StringToVariant(strValue, &var, m_bTranslate);
            }
            else
            {
                var.vt = VT_UNKNOWN;
                var.punkVal = (IUnknown*) m_ctlArrayValues.GetItemData(iItem);
                
                // So var doesn't nuke us when it goes away.
                var.punkVal->AddRef();
            }
        }
    }

    if (dlg.DoModal() != IDOK)
        return;

    int iNewIndex;

    if (!bEdit)
    {
        if (!m_ctlArrayValues.GetCount())
            iNewIndex = 0;
        else
		{
    	    iNewIndex = m_ctlArrayValues.GetCurSel() + 1;

			if (iNewIndex == 0)
			    iNewIndex = m_ctlArrayValues.GetCount();
        }
    }
    else
    {
        iNewIndex = m_ctlArrayValues.GetCurSel();
        m_ctlArrayValues.DeleteString(iNewIndex);
    }

    CString strValue;

    m_prop.VariantToString(&var, strValue, m_bTranslate);
        
    m_ctlArrayValues.InsertString(iNewIndex, strValue);
	m_ctlArrayValues.SetCurSel(iNewIndex);
    
    // This also works if var is VT_IUNKNOWN.
    m_ctlArrayValues.SetItemData(iNewIndex, var.iVal);

    UpdateArrayButtons();
}

void CPropUtil::OnDelete() 
{
	int iWhere = m_ctlArrayValues.GetCurSel();

	if (iWhere != -1)
	{
		if (IsObjEdit())
        {
            IUnknown *pUnk = (IUnknown *) m_ctlArrayValues.GetItemData(iWhere);

            pUnk->Release();
        }

        m_ctlArrayValues.DeleteString(iWhere);
		if (iWhere >= m_ctlArrayValues.GetCount())
			iWhere = m_ctlArrayValues.GetCount() - 1;

		m_ctlArrayValues.SetCurSel(iWhere);

		UpdateArrayButtons();
	}
}


void CPropUtil::OnUp() 
{
	int iWhere = m_ctlArrayValues.GetCurSel();

	if (iWhere > 0)
	{
		CString strValue;
        DWORD   dwVal;

		m_ctlArrayValues.GetText(iWhere, strValue);
        dwVal = m_ctlArrayValues.GetItemData(iWhere);

		m_ctlArrayValues.DeleteString(iWhere);

        iWhere--;
		m_ctlArrayValues.InsertString(iWhere, strValue);
        m_ctlArrayValues.SetItemData(iWhere, dwVal);
		m_ctlArrayValues.SetCurSel(iWhere);

		UpdateArrayButtons();
	}
}

void CPropUtil::OnDown() 
{
	int iWhere = m_ctlArrayValues.GetCurSel();

	if (iWhere != -1 && iWhere != m_ctlArrayValues.GetCount())
	{
		CString strValue;
        DWORD   dwVal;

		m_ctlArrayValues.GetText(iWhere, strValue);
        dwVal = m_ctlArrayValues.GetItemData(iWhere);
		m_ctlArrayValues.DeleteString(iWhere);
		
        iWhere++;
        m_ctlArrayValues.InsertString(iWhere, strValue);
        m_ctlArrayValues.SetItemData(iWhere, dwVal);
		m_ctlArrayValues.SetCurSel(iWhere);

		UpdateArrayButtons();
	}
}

void CPropUtil::OnSelchangeValueArray() 
{
    UpdateArrayButtons();
}

void CPropUtil::OnSelchangeType() 
{
    if (!m_pWnd->IsDlgButtonChecked(IDC_ARRAY))
    {
        m_spropUtil.SetType(GetCurrentType());
        OnNull();
    }
    else
    {
        m_ctlArrayValues.ResetContent();

        UpdateArrayButtons();
    }
}

void CPropUtil::InitTypeCombo()
{
    const DWORD dwIDs[] =
    {
        IDS_CIM_STRING,
        IDS_CIM_BOOLEAN,
        IDS_CIM_SINT32,
        IDS_CIM_REAL64,
        IDS_CIM_SINT8,
        IDS_CIM_UINT8,
        IDS_CIM_SINT16,
        IDS_CIM_UINT16,
        IDS_CIM_UINT32,
        IDS_CIM_SINT64,
        IDS_CIM_UINT64,
        IDS_CIM_REAL32,
        IDS_CIM_DATETIME,
        IDS_CIM_REFERENCE,
        IDS_CIM_CHAR16,
        IDS_CIM_OBJECT,
    };

    const CIMTYPE types[] =
    {
        CIM_STRING,
        CIM_BOOLEAN,
        CIM_SINT32,
        CIM_REAL64,
        CIM_SINT8,
        CIM_UINT8,
        CIM_SINT16,
        CIM_UINT16,
        CIM_UINT32,
        CIM_SINT64,
        CIM_UINT64,
        CIM_REAL32,
        CIM_DATETIME,
        CIM_REFERENCE,
        CIM_CHAR16,
        CIM_OBJECT,
    };

    CString strToSelect;
    CIMTYPE typeToSelect = m_prop.GetRawCIMType();
    int     nItems = m_bIsQualifier ? 4 : sizeof(dwIDs) / sizeof(dwIDs[0]);

    for (int i = 0; i < nItems; i++)
    {
        CString strType;
        int     iIndex;

        strType.LoadString(dwIDs[i]);

        iIndex = m_ctlTypes.AddString(strType);
        m_ctlTypes.SetItemData(iIndex, types[i]);

        if (types[i] == typeToSelect)
            strToSelect = strType;
    }

    // Select the type given in m_prop.
    if (m_ctlTypes.SelectString(-1, strToSelect) == -1)
        m_ctlTypes.SetCurSel(0);
}

void CPropUtil::ShowArrayControls(BOOL bVal)
{
    const DWORD dwToEnable[] =
    {
        IDC_ARRAY_VALUES,
        IDC_ADD,
        IDC_EDIT,
        IDC_DELETE,
        IDC_UP,
        IDC_DOWN,
    };

    DWORD dwFlag = bVal ? SW_SHOW : SW_HIDE;

    for (int i = 0; i < sizeof(dwToEnable) / sizeof(DWORD); i++)
        m_pWnd->GetDlgItem(dwToEnable[i])->ShowWindow(dwFlag);

    if (bVal)
        UpdateArrayButtons();
}

void CPropUtil::OnArray() 
{
    BOOL bArray = m_pWnd->IsDlgButtonChecked(IDC_ARRAY);

    m_spropUtil.ShowControls(!bArray);
    
    ShowArrayControls(bArray);
}

BOOL CPropUtil::OnSetActive()
{
    return TRUE;
}

BOOL CPropUtil::OnInitDialog() 
{
    // This is a total pain!!!  I tried putting this in WM_INIT_DIALOG and
    // DoDataExchange but neither one worked.
    MoveArrayButtons();

    BOOL bRet = m_spropUtil.OnInitDialog();

    return bRet;
}

void CPropUtil::OnEditEmbedded()
{
    m_spropUtil.OnEditEmbedded();
}

void CPropUtil::OnClearEmbedded()
{
    m_spropUtil.OnClearEmbedded();
}

void CPropUtil::OnDblclkArrayValues()
{
    OnEdit();
}

void CPropUtil::MoveArrayButtons()
{
	RECT rectEdit,
         rectAdd;
    CWnd *pwndAdd = m_pWnd->GetDlgItem(IDC_ADD),
         *pwndEdit = m_pWnd->GetDlgItem(IDC_BITMASK_ARRAY),
         *pwndParent = pwndAdd->GetParent();
    int  dx,
         dy;
         
    pwndEdit->GetClientRect(&rectEdit);
    pwndEdit->MapWindowPoints(pwndParent, &rectEdit);

    pwndAdd->GetClientRect(&rectAdd);
    pwndAdd->MapWindowPoints(pwndParent, &rectAdd);

    // Why this 2 business?  Because it seems to make the movement more
    // accurate.
    dx = rectEdit.left - rectAdd.left - 2;
    dy = rectEdit.top - rectAdd.top - 2;


    const DWORD dwToMove[] =
    {
        IDC_ARRAY_VALUES,
        IDC_ADD,
        IDC_EDIT,
        IDC_DELETE,
        IDC_UP,
        IDC_DOWN,
    };

    for (int i = 0; i < sizeof(dwToMove) / sizeof(DWORD); i++)
    {
        CWnd  *pWnd = m_pWnd->GetDlgItem(dwToMove[i]);
        CRect rect;

        pWnd->GetClientRect(&rect);
        pWnd->MapWindowPoints(pwndParent, &rect);

        rect.OffsetRect(dx, dy);
        
        // The array values controls seems to need this.  Why? I don't know.
        if (i == 0)
            rect.OffsetRect(-2, -2);

        pWnd->MoveWindow(&rect);

        pWnd->GetClientRect(&rect);
        pWnd->MapWindowPoints(pwndParent, &rect);
    }

    // Now make the array listbox the same size as the bitmask listbox.
    CWnd *pBitValues = m_pWnd->GetDlgItem(IDC_BITMASK_ARRAY),
         *pArrayValues = m_pWnd->GetDlgItem(IDC_ARRAY_VALUES);
    RECT rectBitValues,
         rectArrayValues;

    pBitValues->GetClientRect(&rectBitValues);
    pArrayValues->GetClientRect(&rectArrayValues);

    pArrayValues->SetWindowPos(
        NULL, 
        0, 0, 
        // More screwy values to make the sizing correct.
        rectBitValues.right + 4, rectBitValues.bottom + 4, 
        SWP_NOMOVE | SWP_NOZORDER);


    // Move the up and down buttons since we grew the array listbox.
    dx = rectBitValues.right - rectArrayValues.right - 2;
    dy = (rectBitValues.bottom - rectArrayValues.bottom) / 2;

    for (i = 0; i < 2; i++)
    {
        CWnd  *pWnd = m_pWnd->GetDlgItem(i == 0 ? IDC_UP : IDC_DOWN);
        CRect rect;

        pWnd->GetClientRect(&rect);
        pWnd->MapWindowPoints(m_pWnd, &rect);
        rect.OffsetRect(dx, dy);
        pWnd->MoveWindow(&rect);
    }
}


/////////////////////////////////////////////////////////////////////////////
// CSinglePropUtil

void CSinglePropUtil::DoDataExchange(CDataExchange* pDX)
{
	DDX_Control(pDX, IDC_VALUE_LIST, m_ctlListValues);
	DDX_Control(pDX, IDC_BITMASK_ARRAY, m_ctlBitmaskValues);
	DDX_Control(pDX, IDC_VALUE, m_ctlScalar);
	DDX_Control(pDX, IDC_VALUE_TEXT, m_ctlText);

    if (!pDX->m_bSaveAndValidate)
    {
        // This will set our data.
        SetType(m_prop.GetRawCIMType());
    }
    else
    {
        if (m_prop.GetRawCIMType() != CIM_OBJECT)
        {
            switch(m_type)
            {
                case TYPE_CHECKLISTBOX:
                    m_pVar->vt = m_prop.GetRawType();
                    CheckListboxToBitmaskValue(m_ctlBitmaskValues, 
                        (DWORD*) &V_I4(m_pVar));
                    break;

                default:
                {
                    CString strValue;

                    m_pWnd->GetDlgItemText(m_dwScalarID, strValue);
                    m_prop.StringToVariant(strValue, m_pVar, m_bTranslate);
                    break;
                }
            }
        }
        else
        {
            VariantClear(m_pVar);
            m_pVar->vt = VT_NULL;

            if (m_pObjValue != NULL)
            {
                m_pVar->vt = VT_UNKNOWN;
                m_pVar->punkVal = m_pObjValue;
                m_pVar->punkVal->AddRef();
            }
        }
    }
}

void CSinglePropUtil::ShowControls(BOOL bShow)
{
    DWORD dwFlag = bShow ? SW_SHOW : SW_HIDE;

    switch(m_type)
    {
        case TYPE_EDIT_SCALAR:
            m_ctlScalar.ShowWindow(dwFlag);
            //m_ctlScalar.EnableWindow(TRUE);
            break;

        case TYPE_EDIT_TEXT:
            m_ctlText.ShowWindow(dwFlag);
            //m_ctlText.EnableWindow(TRUE);
            break;

        case TYPE_CHECKLISTBOX:
            m_ctlBitmaskValues.ShowWindow(dwFlag);
            break;

        case TYPE_EDIT_OBJ:
            m_ctlScalar.ShowWindow(dwFlag);
            m_ctlScalar.EnableWindow(FALSE);
            m_pWnd->GetDlgItem(IDC_EDIT_OBJ)->ShowWindow(dwFlag);
            m_pWnd->GetDlgItem(IDC_CLEAR)->ShowWindow(dwFlag);
            break;

        case TYPE_DROPDOWN:
        case TYPE_DROPDOWNLIST:
            m_ctlListValues.ShowWindow(dwFlag);
            break;
    }

}

void CSinglePropUtil::EnableControls(BOOL bEnable)
{
    const DWORD dwIDs[] =
    {
        IDC_VALUE_LIST,
        IDC_BITMASK_ARRAY,    
        IDC_EDIT_OBJ,
        IDC_CLEAR,
        IDC_VALUE_TEXT,
    };

    for (int i = 0; i < sizeof(dwIDs) / sizeof(dwIDs[0]); i++)
        m_pWnd->GetDlgItem(dwIDs[i])->EnableWindow(bEnable);

    m_pWnd->GetDlgItem(IDC_VALUE)->EnableWindow(bEnable && m_type != 
        TYPE_EDIT_OBJ);
}

void CSinglePropUtil::SetType(CIMTYPE type)
{
    BOOL    bIsBool,
            bNull,
            bArray;
    CString strValue;

    m_prop.SetType(type);

    bIsBool = m_prop.GetRawCIMType() == CIM_BOOLEAN;
    bNull = m_pVar->vt == VT_NULL;
    bArray = (m_pVar->vt & VT_ARRAY) != 0;

    // Set the value.
    if (!bNull)
        m_prop.VariantToString(m_pVar, strValue, m_bTranslate);

    if (!m_bControlsInited)
        InitControls();

    // Get the type of operation we're dealing with.
	if (m_prop.IsBitmask() && m_bTranslate)
    {
	    m_type = TYPE_CHECKLISTBOX;
     
        m_ctlBitmaskValues.ShowWindow(SW_SHOW);

        m_ctlListValues.ShowWindow(SW_HIDE);
        m_ctlScalar.ShowWindow(SW_HIDE);
        m_ctlText.ShowWindow(SW_HIDE);
        m_pWnd->GetDlgItem(IDC_EDIT_OBJ)->ShowWindow(SW_HIDE);
        m_pWnd->GetDlgItem(IDC_CLEAR)->ShowWindow(SW_HIDE);

        BitmaskValuesToCheckListbox(
            m_ctlBitmaskValues, 
            &m_prop, 
            bNull ? 0 : m_pVar->iVal);
    }
    else if ((m_prop.HasValuemap() && m_bTranslate) || bIsBool)
    {
        m_type = TYPE_DROPDOWN;

        m_ctlListValues.ShowWindow(SW_SHOW);

        m_ctlBitmaskValues.ShowWindow(SW_HIDE);
        m_ctlScalar.ShowWindow(SW_HIDE);
        m_ctlText.ShowWindow(SW_HIDE);
        m_pWnd->GetDlgItem(IDC_EDIT_OBJ)->ShowWindow(SW_HIDE);
        m_pWnd->GetDlgItem(IDC_CLEAR)->ShowWindow(SW_HIDE);
    
        ValuemapValuesToCombo(m_ctlListValues.m_hWnd, &m_prop, strValue);

        m_dwScalarID = IDC_VALUE_LIST;
    }
    else
    {
        BOOL bMultiLine = type == CIM_STRING;
        CWnd *pwndValue = m_pWnd->GetDlgItem(IDC_VALUE);

        //pwndValue->ShowWindow(SW_SHOW);

/*
        if (bMultiLine)
        {
            pwndValue->DestroyWindow();

            CreateWindowEx(
                0x204, // From Spy++.
                _T("Edit"),
                NULL,
                ES_WANTRETURN | ES_MULTILINE | ES_LEFT | 
                    WS_VSCROLL | WS_CHILDWINDOW | WS_VISIBLE | WS_TABSTOP,
                m_rectText.left,
                m_rectText.top,
                m_rectText.Width(),
                m_rectText.Height(),
                m_pWnd->m_hWnd,
                (HMENU) IDC_VALUE,
                NULL,
                NULL);
               
            //pwndValue->ModifyStyle(ES_AUTOHSCROLL, );
            //pwndValue->MoveWindow(&m_rectText, TRUE);
        }
        else
        {
            pwndValue->DestroyWindow();

            CreateWindowEx(
                0x204, // From Spy++.
                _T("Edit"),
                NULL,
                ES_AUTOHSCROLL | ES_LEFT | 
                    WS_CHILDWINDOW | WS_VISIBLE | WS_TABSTOP,
                m_rectScalar.left,
                m_rectScalar.top,
                m_rectScalar.Width(),
                m_rectScalar.Height(),
                m_pWnd->m_hWnd,
                (HMENU) IDC_VALUE,
                NULL,
                NULL);

            //pwndValue->ModifyStyle(ES_WANTRETURN | ES_MULTILINE | WS_VSCROLL, ES_AUTOHSCROLL);
            //pwndValue->MoveWindow(&m_rectScalar);
        }
        pwndValue = m_pWnd->GetDlgItem(IDC_VALUE);
        pwndValue->UpdateWindow();
        pwndValue->ShowWindow(SW_SHOW);
        pwndValue->SetFont(m_pWnd->GetFont());
*/                    
        

        m_ctlListValues.ShowWindow(SW_HIDE);
        m_ctlBitmaskValues.ShowWindow(SW_HIDE);

        if (bMultiLine)
        {
            m_ctlScalar.ShowWindow(SW_HIDE);
            m_ctlText.ShowWindow(SW_SHOW);
            m_ctlText.EnableWindow(TRUE);

            m_pWnd->GetDlgItem(IDC_EDIT_OBJ)->ShowWindow(SW_HIDE);
            m_pWnd->GetDlgItem(IDC_CLEAR)->ShowWindow(SW_HIDE);

            m_dwScalarID = IDC_VALUE_TEXT;
            m_type = TYPE_EDIT_TEXT;
        }
        else
        {
            m_ctlText.ShowWindow(SW_HIDE);
            m_ctlScalar.ShowWindow(SW_SHOW);

            m_dwScalarID = IDC_VALUE;

            if (type == VT_UNKNOWN)
            {
                m_type = TYPE_EDIT_OBJ;

                m_pWnd->GetDlgItem(IDC_VALUE)->EnableWindow(FALSE);
        
                m_pWnd->GetDlgItem(IDC_EDIT_OBJ)->ShowWindow(SW_SHOW);
                m_pWnd->GetDlgItem(IDC_CLEAR)->ShowWindow(SW_SHOW);

                if (!bArray)
                {
                    if (m_pVar->vt == VT_UNKNOWN)
                        m_pObjValue = m_pVar->punkVal;
                    else
                        m_pObjValue = NULL;

                    VariantClear(m_pVar);
                    m_pVar->vt = VT_NULL;
                }
            }
            else
            {
    	        m_type = TYPE_EDIT_SCALAR;
    
                m_pWnd->GetDlgItem(IDC_VALUE)->EnableWindow(TRUE);

                m_pWnd->GetDlgItem(IDC_EDIT_OBJ)->ShowWindow(SW_HIDE);
                m_pWnd->GetDlgItem(IDC_CLEAR)->ShowWindow(SW_HIDE);
            }
        }

        m_pWnd->SetDlgItemText(m_dwScalarID, strValue);
    }
}


void CSinglePropUtil::InitControls()
{
    if (m_bControlsInited)
        return;

    m_bControlsInited = TRUE;

    // Move the combo box into place.
#define DROPDOWNLISTBOX_INCREASE 100

    // Get a bunch of vars the next group of code will use to
	// resize the dialog, create controls, etc.
	CWnd *pwndEdit = m_pWnd->GetDlgItem(IDC_VALUE),
         *pwndBitmask = m_pWnd->GetDlgItem(IDC_BITMASK_ARRAY);

	// Save this for single-line text editing.
    pwndEdit->GetClientRect(&m_rectScalar);
	pwndEdit->MapWindowPoints(m_pWnd, &m_rectScalar);

	// Save this for multi-line text editing.
    pwndBitmask->GetClientRect(&m_rectText);
	pwndBitmask->MapWindowPoints(m_pWnd, &m_rectText);

    m_rectScalar.InflateRect(2, 2);
    m_rectText.InflateRect(2, 2);

    m_ctlText.MoveWindow(&m_rectText);

    RECT rectDropdown = m_rectScalar;

    // Adjust the position of the translation since the edit control
	// doesn't seem to tell us exactly where it is.
	//rectDropdown.left -= 2;
	//rectDropdown.top -= 2;
	//rectDropdown.right += 2;

	// Make bigger for the dropdown list.
	rectDropdown.bottom += DROPDOWNLISTBOX_INCREASE;

	m_ctlListValues.MoveWindow(&rectDropdown);
}

/////////////////////////////////////////////////////////////////////////////
// CSinglePropUtil message handlers

BOOL CSinglePropUtil::GetNewObj(IUnknown **ppUnk)
{
    CGetTextDlg dlg;
    BOOL        bRet = FALSE;

    dlg.m_dwPromptID = IDS_CREATE_OBJ_PROMPT;
    dlg.m_dwTitleID = IDS_CREATE_OBJ_TITLE;
    dlg.m_bAllowClassBrowse = TRUE;
    dlg.m_pNamespace = g_pOpView->GetDocument()->m_pNamespace;
    dlg.LoadListViaReg(_T("GetClassHistory"));

    if (dlg.DoModal() == IDOK)
    {
        HRESULT             hr;
        IWbemClassObjectPtr pClass;

        // Get the superclass.
        hr = 
            dlg.m_pNamespace->GetObject(
                _bstr_t(dlg.m_strText),
                WBEM_FLAG_USE_AMENDED_QUALIFIERS,
                NULL,
                &pClass,
                NULL);


        if (SUCCEEDED(hr))
        {
            IWbemClassObjectPtr pObj;

            hr =
                pClass->SpawnInstance(
                    0,
                    &pObj);

            if (SUCCEEDED(hr))
            {
                pObj->QueryInterface(
                    IID_IUnknown, 
                    (LPVOID*) ppUnk);

                bRet = TRUE;
            }
        }

        if (FAILED(hr))
            CWMITestDoc::DisplayWMIErrorBox(hr);
    }

    return bRet;
}

void CSinglePropUtil::OnEditEmbedded() 
{
    if (m_pObjValue == NULL)
    {
        if (GetNewObj(&m_pObjValue))
        {
            // Call this again since now we're setup OK.
            OnEditEmbedded();

            CString strText;

            //strText.Format(IDS_EMBEDDED_OBJECT, (IUnknown*) m_pObjValue);
            strText = GetEmbeddedObjectText(m_pObjValue);
            m_ctlScalar.SetWindowText(strText);
        }
    }
    else
    {
        EditObj(m_pObjValue);
    }
}

void CSinglePropUtil::EditObj(IUnknown *pUnk)
{
    HRESULT             hr;
    IWbemClassObjectPtr pObj;
            
    hr =
        pUnk->QueryInterface(
            IID_IWbemClassObject, 
            (LPVOID*) &pObj);

    if (SUCCEEDED(hr))
        CWMITestDoc::EditGenericObject(IDS_EDIT_EMBEDDED_OBJ, pObj);
    else
        CWMITestDoc::DisplayWMIErrorBox(hr);
}

void CSinglePropUtil::OnClearEmbedded()
{
    m_pObjValue = NULL;

    CString strNull;

    strNull.LoadString(IDS_NULL);

    m_ctlScalar.SetWindowText(strNull);
}

BOOL CSinglePropUtil::OnInitDialog() 
{
    InitControls();

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\wmitest\querysheet.cpp ===
/*++

Copyright (C) 1997-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/

// QuerySheet.cpp : implementation file
//

#include "stdafx.h"
#include "WMITest.h"
#include "QuerySheet.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CQuerySheet

IMPLEMENT_DYNAMIC(CQuerySheet, CPropertySheet)

CQuerySheet::CQuerySheet(UINT nIDCaption, CWnd* pParentWnd, UINT iSelectPage)
	:CPropertySheet(nIDCaption, pParentWnd, iSelectPage),
    m_bColsNeeded(TRUE)
{
}

CQuerySheet::CQuerySheet(LPCTSTR pszCaption, CWnd* pParentWnd, UINT iSelectPage)
	:CPropertySheet(pszCaption, pParentWnd, iSelectPage),
    m_bColsNeeded(TRUE)
{
}

CQuerySheet::~CQuerySheet()
{
}


BEGIN_MESSAGE_MAP(CQuerySheet, CPropertySheet)
	//{{AFX_MSG_MAP(CQuerySheet)
		// NOTE - the ClassWizard will add and remove mapping macros here.
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CQuerySheet message handlers
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\wmitest\querycolpg.h ===
/*++

Copyright (C) 1997-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/

#if !defined(AFX_QUERYCOLPG_H__38815D64_6DE8_11D3_BD3D_0080C8E60955__INCLUDED_)
#define AFX_QUERYCOLPG_H__38815D64_6DE8_11D3_BD3D_0080C8E60955__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// QueryColPg.h : header file
//

#include "QuerySheet.h"

/////////////////////////////////////////////////////////////////////////////
// CQueryColPg dialog

class CQueryColPg : public CPropertyPage
{
	DECLARE_DYNCREATE(CQueryColPg)

// Construction
public:
	CQueryColPg();
	~CQueryColPg();

// Dialog Data
	//{{AFX_DATA(CQueryColPg)
	enum { IDD = IDD_PG_COLS };
	CListBox	m_ctlSelected;
	CListBox	m_ctlAvailable;
	//}}AFX_DATA

    CQuerySheet *m_pSheet;

// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CQueryColPg)
	public:
	virtual BOOL OnSetActive();
	virtual BOOL OnWizardFinish();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
    void LoadList();
    void UpdateButtons();

	// Generated message map functions
	//{{AFX_MSG(CQueryColPg)
	afx_msg void OnAdd();
	afx_msg void OnRemove();
	afx_msg void OnAddAll();
	afx_msg void OnRemoveAll();
	afx_msg void OnSelchangeSelected();
	afx_msg void OnSelchangeAvailable();
	afx_msg void OnDblclkSelected();
	afx_msg void OnDblclkAvailable();
	afx_msg void OnUp();
	afx_msg void OnDown();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_QUERYCOLPG_H__38815D64_6DE8_11D3_BD3D_0080C8E60955__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\wmitest\querysheet.h ===
/*++

Copyright (C) 1997-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/

#if !defined(AFX_QUERYSHEET_H__D02204D1_6F1E_11D3_BD3F_0080C8E60955__INCLUDED_)
#define AFX_QUERYSHEET_H__D02204D1_6F1E_11D3_BD3F_0080C8E60955__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// QuerySheet.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CQuerySheet

class CQuerySheet : public CPropertySheet
{
	DECLARE_DYNAMIC(CQuerySheet)

// Construction
public:
	CQuerySheet(UINT nIDCaption, CWnd* pParentWnd = NULL, UINT iSelectPage = 0);
	CQuerySheet(LPCTSTR pszCaption, CWnd* pParentWnd = NULL, UINT iSelectPage = 0);

// Attributes
public:
    IWbemServices *m_pNamespace;
    CString m_strQuery;
    CString m_strClass;
    CStringList m_listColums;
    BOOL m_bColsNeeded;

// Operations
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CQuerySheet)
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CQuerySheet();

protected:

	// Generated message map functions
protected:
	//{{AFX_MSG(CQuerySheet)
		// NOTE - the ClassWizard will add and remove member functions here.
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_QUERYSHEET_H__D02204D1_6F1E_11D3_BD3F_0080C8E60955__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\wmitest\resource.h ===
/*++

Copyright (C) 1997-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/

//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by WMITest.rc
//
#define IDD_ABOUTBOX                    100
#define IDR_MAINFRAME                   128
#define IDR_WMITESTYPE                  129
#define IDS_QUERY_PROMPT                129
#define IDD_GET_TEXT                    130
#define IDS_QUERY_TITLE                 130
#define IDD_LOGIN                       131
#define IDS_ENUM_OBJ_CAPTION            131
#define IDB_QUERY                       132
#define IDS_NOT_CONNECTED               132
#define IDB_OBJECT                      133
#define IDS_NOTIFICATION_QUERY_PROMPT   133
#define IDB_CLASS                       134
#define IDS_NOTIFICATION_QUERY_TITLE    134
#define IDB_EVENT_QUERY                 135
#define IDS_CLASS_NO_KEY                135
#define IDB_ROOT                        136
#define IDS_NO_KEY                      136
#define IDS_NAME                        137
#define IDB_TEXT                        137
#define IDS_TYPE                        138
#define IDB_BINARY                      138
#define IDS_VALUE                       139
#define IDS_NULL                        140
#define IDB_BUSY                        140
#define IDS_CIM_EMPTY                   141
#define IDB_ENUM_OBJ                    141
#define IDS_CIM_SINT8                   142
#define IDB_ENUM_CLASS                  142
#define IDS_CIM_UINT8                   143
#define IDR_OP                          143
#define IDS_CIM_SINT16                  144
#define IDR_NAMESPACE                   144
#define IDS_CIM_UINT16                  145
#define IDR_MENU1                       145
#define IDR_INST                        145
#define IDS_CIM_SINT32                  146
#define IDR_CLASS                       146
#define IDS_CIM_UINT32                  147
#define IDD_PREF                        147
#define IDS_CIM_SINT64                  148
#define IDB_ERROR                       148
#define IDS_CIM_UINT64                  149
#define IDD_CLASS_BROWSE                149
#define IDS_CIM_REAL32                  150
#define IDB_KEY                         150
#define IDS_CIM_REAL64                  151
#define IDD_PG_CLASS                    151
#define IDB_MODIFIED                    151
#define IDS_CIM_BOOLEAN                 152
#define IDD_PG_COLS                     152
#define IDS_CIM_STRING                  153
#define IDS_CIM_DATETIME                154
#define IDS_CIM_REFERENCE               155
#define IDS_CIM_CHAR16                  156
#define IDS_CIM_OBJECT                  157
#define IDS_TRUE                        158
#define IDS_FALSE                       159
#define IDS_ENUM_INST_PROMPT            160
#define IDS_ENUM_INST_TITLE             161
#define IDS_RECURSIVE                   162
#define IDS_ENUM_CLASS_PROMPT           163
#define IDS_ENUM_CLASS_TITLE            164
#define IDS_GET_INST_PROMPT             165
#define IDS_GET_INST_TITLE              166
#define IDS_GET_CLASS_PROMPT            167
#define IDS_GET_CLASS_TITLE             168
#define IDS_ENUM_CLASS_CAPTION          169
#define IDS_CLASS                       170
#define IDS_ALL_CLASSES                 171
#define IDS_TOP_LEVEL_CLASSES           172
#define IDS_OBJ_PATH                    173
#define IDS_CIM_ARRAY                   174
#define IDS_NO_SUPERCLASS               175
#define IDS_COM_INIT_FAILED             176
#define ID_STATUS_NUM_OBJECTS           177
#define ID_STATUS1                      178
#define IDS_ROOT_STATUS                 179
#define IDS_ERROR_FORMAT                180
#define IDS_ERROR_FAILED                181
#define IDS_OBJ_COUNT                   182
#define IDS_CLASS_COUNT                 183
#define IDS_QUERY_WIZARD                184
#define IDS_EMBEDDED_OBJECT             185
#define IDD_PROPERTY                    186
#define IDS_UTC                         186
#define IDS_EDIT_PROPERTY               187
#define IDD_NEW_PROPERTY                188
#define IDS_ERROR_BOX_FORMAT            188
#define IDR_PROP                        189
#define IDS_ADD_ARRAY_ITEM              189
#define IDR_NEW_PROP                    190
#define IDS_ARRAY_ITEM                  190
#define IDR_PROP_AND_INST               191
#define IDD_WMI_ERROR                   191
#define IDS_MODIFY_ARRAY_ITEM           191
#define IDS_NEW_PROPERTY                192
#define IDD_QUALS                       193
#define IDS_CREATE_CLASS_PROMPT         193
#define IDD_EDIT_QUAL                   194
#define IDS_CREATE_CLASS_TITLE          194
#define IDS_CREATE_OBJ_PROMPT           195
#define IDS_CREATE_OBJ_TITLE            196
#define IDS_SUBCLASS_OF                 197
#define IDD_DEL_ITEM                    197
#define IDS_TOPLEVEL_CLASS              198
#define IDD_PROPS                       198
#define IDS_INSTANCE_OF                 199
#define IDR_BAD_OP                      199
#define IDD_METHODS                     200
#define IDS_EDIT_INST                   201
#define IDD_METHOD_PARAMS               201
#define IDS_EDIT_CLASS                  202
#define IDD_EXEC_METHOD                 202
#define IDS_VIEW_ERROR_INFO             203
#define IDS_EDIT_EMBEDDED_OBJ           204
#define IDD_ARRAY_ITEM                  204
#define IDS_EDIT_IN_PARAMS              205
#define IDD_MOF                         205
#define IDS_EDIT_OUT_PARAMS             206
#define IDD_EXPORT                      206
#define IDS_METHOD_NAME_IS_EMPTY        207
#define IDD_NAMESPACE                   207
#define IDS_EDIT_NEW_METHOD             208
#define IDS_EDIT_METHOD                 209
#define IDD_PG_FILTERS                  209
#define IDS_PROMPT_EXEC_METHOD          210
#define IDD_PG_CONSUMERS                210
#define IDS_EXEC_METHOD_TITLE           211
#define IDD_PG_BINDINGS                 211
#define IDS_UTC_TOKEN                   212
#define IDD_FILTER                      212
#define IDS_ENABLE_PRIVS_FAILED         213
#define IDS_IMP_NAME1                   214
#define IDS_IMP_NAME2                   215
#define IDS_IMP_NAME3                   216
#define IDS_AUTH_NAME1                  217
#define IDS_AUTH_NAME2                  218
#define IDS_AUTH_NAME3                  219
#define IDS_AUTH_NAME4                  220
#define IDS_AUTH_NAME5                  221
#define IDS_AUTH_NAME6                  222
#define IDS_FILTER_TO_CONSUMER_BINDINGS 223
#define IDS_QUERY                       224
#define IDS_MONITORY_QUERY              225
#define IDC_STRINGS                     1000
#define IDC_OPTION                      1001
#define IDC_NAMESPACE                   1003
#define IDC_USER                        1004
#define IDC_PASSWORD                    1005
#define IDC_CURRENT_NTLM                1006
#define IDC_NTLM                        1007
#define IDC_KERBEROS                    1008
#define IDC_AUTHORITY                   1009
#define IDS_TEXT_PROMPT                 1010
#define IDC_LOCALE                      1010
#define IDC_LOAD_LAST                   1011
#define IDC_SYSTEM_PROPS                1012
#define IDC_SHOW_INHERITED              1013
#define IDC_CLASSES                     1014
#define IDC_BROWSE                      1015
#define IDC_AVAILABLE                   1016
#define IDC_ADD                         1017
#define IDC_REMOVE                      1018
#define IDC_SELECTED                    1019
#define IDC_ADD_ALL                     1020
#define IDC_REMOVE_ALL                  1021
#define IDC_UP                          1022
#define IDC_DOWN                        1023
#define IDC_VALUE                       1024
#define IDC_BITMASK_ARRAY               1025
#define IDC_NAME                        1026
#define IDC_DELETE                      1027
#define IDC_ARRAY_VALUES                1028
#define IDC_NULL                        1030
#define IDC_TYPE                        1034
#define IDC_ARRAY                       1037
#define IDC_CREATE                      1038
#define IDC_UPDATE                      1039
#define IDC_CREATE_OR_UPDATE            1040
#define IDC_INFO                        1040
#define IDC_COMPATIBLE                  1041
#define IDC_NUMBER                      1041
#define IDC_SAFE                        1042
#define IDC_FACILITY                    1042
#define IDC_QUALS                       1042
#define IDC_FORCE                       1043
#define IDC_DESCRIPTION                 1043
#define IDC_EDIT                        1043
#define IDS_ARRAY_LABEL                 1044
#define IDC_VALUE_COMBO                 1048
#define IDS_VALUE_LABEL                 1049
#define IDC_VALUE_LIST                  1050
#define IDC_KEY                         1055
#define IDC_INDEXED                     1056
#define IDC_NON_NULL                    1057
#define IDC_NORMAL                      1058
#define IDC_TO_INST                     1060
#define IDC_TO_CLASS                    1061
#define IDC_ALLOW_OVERRIDE              1062
#define IDC_AMENDED                     1063
#define IDC_PROPPED                     1064
#define IDC_DEL_FROM_WMI                1066
#define IDC_DEL_FROM_TREE               1067
#define IDC_PROPS                       1067
#define IDC_SYSTEM                      1068
#define IDC_INHERITED                   1069
#define IDC_EDIT_OBJ                    1070
#define IDC_METHODS                     1071
#define IDC_CLEAR                       1072
#define IDC_EDIT_INPUT                  1073
#define IDC_NULL_IN                     1074
#define IDC_EDIT_OUT                    1075
#define IDC_NULL_OUT                    1076
#define IDC_METHOD                      1077
#define IDC_CLEAR_IN                    1078
#define IDC_VALUE_TEXT                  1080
#define IDC_MOF                         1082
#define IDC_TRANSLATE                   1088
#define IDC_PRIVS_ON_START              1089
#define IDC_ENABLE_PRIVS                1091
#define IDS_VERSION                     1092
#define IDC_NAMESPACE_TREE              1095
#define IDC_IMP                         1098
#define IDC_IMP2                        1099
#define IDC_ADVANCED                    1100
#define IDC_FILTERS                     1101
#define IDC_CONSUMERS                   1102
#define IDC_MODIFY                      1106
#define IDC_BINDINGS                    1107
#define IDC_EDIT1                       1108
#define IDC_QUERY                       1109
#define IDC_EXECUTE_METHOD_FIRST        20000
#define IDC_EXECUTE_METHOD_LAST         21000
#define ID_CONNECT                      32771
#define IDS_EXEC_SUCCEEDED              32772
#define ID_STOP                         32776
#define ID_SYSTEM_PROPS                 32777
#define ID_REFRESH_CURRENT              32787
#define ID_DELETE                       32788
#define ID_INSTANCE_ASSOCIATORS         32789
#define ID_INSTANCE_REFERENCES          32790
#define ID_REFERENCES                   32791
#define ID_ASSOCIATORS                  32792
#define ID_INST_GET_CLASS               32793
#define ID_INST_GET_INST                32794
#define ID_CLASS_INSTANCES              32795
#define ID_CLASS_SUPERCLASS             32796
#define ID_CLASS_INSTANCES_DEEP         32797
#define ID_CLASS_SUBCLASSES             32798
#define ID_CLASS_SUBCLASSES_DEEP        32799
#define ID_OPTIONS                      32800
#define ID_INHERITED_PROPS              32801
#define ID_RECONNECT                    32802
#define ID_TRANSLATE_VALUES             32803
#define ID_NEW_PROP                     32814
#define ID_MODIFY                       32815
#define ID_SAVE                         32816
#define ID_CLASS_CREATE_INST            32823
#define ID_BAD_OP                       32826
#define ID_ERROR_DETAILS                32827
#define ID_NO_METHODS                   32829
#define ID_NO_S_METHODS                 32830
#define ID_NO_METHODS_FOUND             32831
#define ID_SHOW_MOF                     32834
#define ID_EXPORT_TREE                  32835
#define ID_EXPORT_ITEM                  32836
#define ID_STOP_CURRENT                 32838
#define ID_QUERY                        40000
#define ID_FIRST_NEED_CONNECTION        40000
#define ID_NOTIFICATIONQUERY            40001
#define ID_ENUMERATEINSTANCES           40002
#define ID_GETINSTANCE                  40003
#define ID_ENUMERATE_CLASSES            40004
#define ID_GET_CLASS                    40005
#define ID_REFRESH_ALL                  40006
#define ID_CREATE_INSTANCE              40007
#define ID_CREATE_CLASS                 40008
#define ID_EXEC_METHOD                  40009
#define ID_FILTER_BINDINGS              40010
#define ID_LAST_NEED_CONNECTION         40100

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_3D_CONTROLS                     1
#define _APS_NEXT_RESOURCE_VALUE        213
#define _APS_NEXT_COMMAND_VALUE         32839
#define _APS_NEXT_CONTROL_VALUE         1112
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\wmitest\stdafx.h ===
/*++

Copyright (C) 1997-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/

// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#if !defined(AFX_STDAFX_H__4419F1A6_692B_11D3_BD30_0080C8E60955__INCLUDED_)
#define AFX_STDAFX_H__4419F1A6_692B_11D3_BD30_0080C8E60955__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define _MFC_VER            0x0600

#define VC_EXTRALEAN		// Exclude rarely-used stuff from Windows headers

#include <afxwin.h>         // MFC core and standard components
#include <afxext.h>         // MFC extensions
#include <afxcview.h>
#include <afxdtctl.h>		// MFC support for Internet Explorer 4 Common Controls
#ifndef _AFX_NO_AFXCMN_SUPPORT
#include <afxcmn.h>			// MFC support for Windows Common Controls
#endif // _AFX_NO_AFXCMN_SUPPORT
#include <afxtempl.h>       // Template stuff

#include <comdef.h>         // _bstr_t, _variant_t
#include <wbemcli.h>        // duh
#include <afxmt.h>          // Multi-threaded stuff
#include <afxadv.h>         // For CRecentFileList
#include <winnls.h>
#include <afxole.h>         // For cut/paste stuff.

// Gets rid of dumb warning about truncating symbol name we get on some 
// template classes.
#pragma warning( disable : 4786 )

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__4419F1A6_692B_11D3_BD30_0080C8E60955__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\wmitest\stdafx.cpp ===
/*++

Copyright (C) 1997-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/

// stdafx.cpp : source file that includes just the standard includes
//	WMITest.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\wmitest\toolbarex.cpp ===
/*++

Copyright (C) 1997-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/

// ToolBarEx.cpp : implementation file
//

#include "stdafx.h"
#include "wmitest.h"
#include "ToolBarEx.h"
#include <AFXISAPI.H>

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CToolBarEx

CToolBarEx::CToolBarEx()
{
}

CToolBarEx::~CToolBarEx()
{
}


BEGIN_MESSAGE_MAP(CToolBarEx, CToolBar)
	//{{AFX_MSG_MAP(CToolBarEx)
		// NOTE - the ClassWizard will add and remove mapping macros here.
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


//////////////////////////////////////////////////////////////////////////////
// Lifted from Bartool.cpp.
#define RGB_TO_RGBQUAD(r,g,b)   (RGB(b,g,r))
#define CLR_TO_RGBQUAD(clr)     (RGB(GetBValue(clr), GetGValue(clr), GetRValue(clr)))

struct AFX_COLORMAP
{
	// use DWORD instead of RGBQUAD so we can compare two RGBQUADs easily
	DWORD rgbqFrom;
	int iSysColorTo;
};

const AFX_COLORMAP _afxSysColorMap[] =
{
	// mapping from color in DIB to system color
	//{ RGB_TO_RGBQUAD(0x00, 0x00, 0x00),  COLOR_BTNTEXT },       // black
	//{ RGB_TO_RGBQUAD(0x80, 0x80, 0x80),  COLOR_BTNSHADOW },     // dark gray
	{ RGB_TO_RGBQUAD(0xC0, 0xC0, 0xC0),  COLOR_BTNFACE },       // bright gray
	//{ RGB_TO_RGBQUAD(0xFF, 0xFF, 0xFF),  COLOR_BTNHIGHLIGHT }   // white
};

HBITMAP AFXAPI AfxLoadSysColorBitmapEx(HINSTANCE hInst, HRSRC hRsrc, BOOL bMono = FALSE);

#ifndef _countof
#define _countof(x) (sizeof(x)/sizeof(x[0]))
#endif

HBITMAP AFXAPI
AfxLoadSysColorBitmapEx(HINSTANCE hInst, HRSRC hRsrc, BOOL bMono)
{
	HGLOBAL hglb;
	if ((hglb = LoadResource(hInst, hRsrc)) == NULL)
		return NULL;

	LPBITMAPINFOHEADER lpBitmap = (LPBITMAPINFOHEADER)LockResource(hglb);
	if (lpBitmap == NULL)
		return NULL;

	// make copy of BITMAPINFOHEADER so we can modify the color table
	const int nColorTableSize = 16;
	UINT nSize = lpBitmap->biSize + nColorTableSize * sizeof(RGBQUAD);
	LPBITMAPINFOHEADER lpBitmapInfo = (LPBITMAPINFOHEADER)::malloc(nSize);
	if (lpBitmapInfo == NULL)
		return NULL;
	memcpy(lpBitmapInfo, lpBitmap, nSize);

	// color table is in RGBQUAD DIB format
	DWORD* pColorTable =
		(DWORD*)(((LPBYTE)lpBitmapInfo) + (UINT)lpBitmapInfo->biSize);

	for (int iColor = 0; iColor < nColorTableSize; iColor++)
	{
		// look for matching RGBQUAD color in original
		for (int i = 0; i < _countof(_afxSysColorMap); i++)
		{
			if (pColorTable[iColor] == _afxSysColorMap[i].rgbqFrom)
			{
				if (bMono)
				{
					// all colors except text become white
					if (_afxSysColorMap[i].iSysColorTo != COLOR_BTNTEXT)
						pColorTable[iColor] = RGB_TO_RGBQUAD(255, 255, 255);
				}
				else
					pColorTable[iColor] =
						CLR_TO_RGBQUAD(::GetSysColor(_afxSysColorMap[i].iSysColorTo));
				break;
			}
		}
	}

	int nWidth = (int)lpBitmapInfo->biWidth;
	int nHeight = (int)lpBitmapInfo->biHeight;
	HDC hDCScreen = ::GetDC(NULL);
	HBITMAP hbm = ::CreateCompatibleBitmap(hDCScreen, nWidth, nHeight);

	if (hbm != NULL)
	{
		HDC hDCGlyphs = ::CreateCompatibleDC(hDCScreen);
		HBITMAP hbmOld = (HBITMAP)::SelectObject(hDCGlyphs, hbm);

		LPBYTE lpBits;
		lpBits = (LPBYTE)(lpBitmap + 1);
		lpBits += (1 << (lpBitmapInfo->biBitCount)) * sizeof(RGBQUAD);

		StretchDIBits(hDCGlyphs, 0, 0, nWidth, nHeight, 0, 0, nWidth, nHeight,
			lpBits, (LPBITMAPINFO)lpBitmapInfo, DIB_RGB_COLORS, SRCCOPY);
		SelectObject(hDCGlyphs, hbmOld);
		::DeleteDC(hDCGlyphs);
	}
	::ReleaseDC(NULL, hDCScreen);

	// free copy of bitmap info struct and resource itself
	::free(lpBitmapInfo);
	::FreeResource(hglb);

	return hbm;
}

//////////////////////////////////////////////////////////////////////////////
// Lifted from Bartool.cpp.  The only thing we changed was LoadBitmap to
// LoadBitmapEx.
struct CToolBarData
{
	WORD wVersion;
	WORD wWidth;
	WORD wHeight;
	WORD wItemCount;
	//WORD aItems[wItemCount]

	WORD* items()
		{ return (WORD*)(this+1); }
};

BOOL CToolBarEx::LoadToolBarEx(LPCTSTR lpszResourceName)
{
	ASSERT_VALID(this);
	ASSERT(lpszResourceName != NULL);

	// determine location of the bitmap in resource fork
	HINSTANCE hInst = AfxFindResourceHandle(lpszResourceName, RT_TOOLBAR);
	HRSRC hRsrc = ::FindResource(hInst, lpszResourceName, RT_TOOLBAR);
	if (hRsrc == NULL)
		return FALSE;

	HGLOBAL hGlobal = LoadResource(hInst, hRsrc);
	if (hGlobal == NULL)
		return FALSE;

	CToolBarData* pData = (CToolBarData*)LockResource(hGlobal);
	if (pData == NULL)
		return FALSE;
	ASSERT(pData->wVersion == 1);

	UINT* pItems = new UINT[pData->wItemCount];
	for (int i = 0; i < pData->wItemCount; i++)
		pItems[i] = pData->items()[i];
	BOOL bResult = SetButtons(pItems, pData->wItemCount);
	delete[] pItems;

	if (bResult)
	{
		// set new sizes of the buttons
		CSize sizeImage(pData->wWidth, pData->wHeight);
		CSize sizeButton(pData->wWidth + 7, pData->wHeight + 7);
		SetSizes(sizeButton, sizeImage);

		// load bitmap now that sizes are known by the toolbar control
		bResult = LoadBitmapEx(lpszResourceName);
	}

	UnlockResource(hGlobal);
	FreeResource(hGlobal);

	return bResult;
}

//////////////////////////////////////////////////////////////////////////////
// Lifted from Bartool.cpp.  The only thing we changed was AfxLoadSysColorBitmap to
// AfxLoadSysColorBitmapEx.
BOOL CToolBarEx::LoadBitmapEx(LPCTSTR lpszResourceName)
{
	ASSERT_VALID(this);
	ASSERT(lpszResourceName != NULL);

	// determine location of the bitmap in resource fork
	HINSTANCE hInstImageWell = AfxFindResourceHandle(lpszResourceName, RT_BITMAP);
	HRSRC hRsrcImageWell = ::FindResource(hInstImageWell, lpszResourceName, RT_BITMAP);
	if (hRsrcImageWell == NULL)
		return FALSE;

	// load the bitmap
	HBITMAP hbmImageWell;
	hbmImageWell = AfxLoadSysColorBitmapEx(hInstImageWell, hRsrcImageWell);

	// tell common control toolbar about the new bitmap
	if (!AddReplaceBitmap(hbmImageWell))
		return FALSE;

	// remember the resource handles so the bitmap can be recolored if necessary
	m_hInstImageWell = hInstImageWell;
	m_hRsrcImageWell = hRsrcImageWell;
	return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
// CToolBarEx message handlers
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\wmitest\utils.cpp ===
/*++

Copyright (C) 1997-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/

// Utils.cpp
#include "stdafx.h"
#include "utils.h"
#include <cominit.h>

HRESULT EnableAllPrivileges(DWORD dwTokenType)
{
    // Open thread token
    // =================

    HANDLE hToken = NULL;
	BOOL bRes;

	switch (dwTokenType)
	{
	case TOKEN_THREAD:
		bRes = OpenThreadToken(GetCurrentThread(), TOKEN_QUERY | TOKEN_ADJUST_PRIVILEGES, TRUE, &hToken); 
		break;
	case TOKEN_PROCESS:
		bRes = OpenProcessToken(GetCurrentProcess(), TOKEN_QUERY | TOKEN_ADJUST_PRIVILEGES, &hToken); 
		break;
	}
    if(!bRes)
        return WBEM_E_ACCESS_DENIED;

    // Get the privileges
    // ==================

    DWORD dwLen;
    TOKEN_USER tu;
	memset(&tu,0,sizeof(TOKEN_USER));
    bRes = GetTokenInformation(hToken, TokenPrivileges, &tu, sizeof(TOKEN_USER), &dwLen);
    
    BYTE* pBuffer = new BYTE[dwLen];
    if(pBuffer == NULL)
    {
        CloseHandle(hToken);
        return WBEM_E_OUT_OF_MEMORY;
    }
    
    bRes = GetTokenInformation(hToken, TokenPrivileges, pBuffer, dwLen, 
                                &dwLen);
    if(!bRes)
    {
        CloseHandle(hToken);
        delete [] pBuffer;
        return WBEM_E_ACCESS_DENIED;
    }

    // Iterate through all the privileges and enable them all
    // ======================================================

    TOKEN_PRIVILEGES* pPrivs = (TOKEN_PRIVILEGES*)pBuffer;
    for(DWORD i = 0; i < pPrivs->PrivilegeCount; i++)
    {
        pPrivs->Privileges[i].Attributes |= SE_PRIVILEGE_ENABLED;
    }

    // Store the information back into the token
    // =========================================

    bRes = AdjustTokenPrivileges(hToken, FALSE, pPrivs, 0, NULL, NULL);
    delete [] pBuffer;
    CloseHandle(hToken);

    if(!bRes)
        return WBEM_E_ACCESS_DENIED;
    else
        return WBEM_S_NO_ERROR;
}

BOOL GetFileVersion(LPCTSTR szFN, LPTSTR szVersion)
{
	DWORD	dwCount, 
			dwHandle,
			dwValueLen;
	BOOL	bRet;
	char	*pcValue, 
			*pc,
			*pBuffer,
			szFileName[MAX_PATH],
			szQuery[100];
                      
	lstrcpy(szFileName, szFN);
	if ((dwCount = GetFileVersionInfoSize(szFileName, &dwHandle)) != 0)
	{
		pBuffer = new char[dwCount];
		if (!pBuffer)
			return FALSE;

		if (GetFileVersionInfo(szFileName, dwHandle, dwCount, pBuffer) != 0)
		{
			VerQueryValue(pBuffer, "\\VarFileInfo\\Translation", 
				(void **) &pcValue, (UINT *) &dwValueLen);

			if (dwValueLen != 0)
			{   
				wsprintf(szQuery, "\\StringFileInfo\\%04X%04X\\FileVersion", 
					*(WORD *)pcValue, *(WORD *)(pcValue+2));

				bRet = VerQueryValue(pBuffer, szQuery, (void **) &pcValue, 
					(UINT *) &dwValueLen);

				if (bRet)
				{
					while ((pc = strchr(pcValue, '(')) != NULL)
						*pc = '{';
					while ((pc = strchr(pcValue, ')')) != NULL)
						*pc = '}';

					_tcscpy(szVersion, pcValue);

					delete pBuffer;
					return TRUE;
				}
			}
		}

		delete pBuffer;
	}

	return FALSE;
}

void SetSecurityHelper(
    IUnknown *pUnk,
    BSTR pAuthority,
    BSTR pUser,
    BSTR pPassword,
    DWORD dwImpLevel,
    DWORD dwAuthLevel)
{
    BSTR           pPrincipal = NULL;
    COAUTHIDENTITY *pAuthIdentity = NULL;

    SetInterfaceSecurityEx(
        pUnk, 
        pAuthority, 
        pUser, 
        pPassword,
        dwAuthLevel, 
        dwImpLevel, 
        EOAC_NONE, 
        &pAuthIdentity, 
        &pPrincipal);

    if (pPrincipal)
	    SysFreeString(pPrincipal);

	if (pAuthIdentity)
	    WbemFreeAuthIdentity(pAuthIdentity);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\wmitest\utils.h ===
/*++

Copyright (C) 1997-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/

// Utils.h

#pragma once

#define TOKEN_THREAD	0
#define TOKEN_PROCESS	1

HRESULT EnableAllPrivileges(DWORD dwTokenType = TOKEN_THREAD);
BOOL GetFileVersion(LPCTSTR szFN, LPTSTR szVersion);

void SetSecurityHelper(
    IUnknown *pUnk,
    BSTR pAuthority,
    BSTR pUser,
    BSTR pPassword,
    DWORD dwImpLevel,
    DWORD dwAuthLevel);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\wql\makefile.inc ===
!INCLUDE $(_NTDRIVE)$(_NTROOT)\WMI\COMMON\makefile.cmn
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\wmitest\toolbarex.h ===
/*++

Copyright (C) 1997-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/

#if !defined(AFX_TOOLBAREX_H__6D89DB48_2E76_4630_A95C_677E6CAB9E44__INCLUDED_)
#define AFX_TOOLBAREX_H__6D89DB48_2E76_4630_A95C_677E6CAB9E44__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// ToolBarEx.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CToolBarEx window

class CToolBarEx : public CToolBar
{
// Construction
public:
	CToolBarEx();

// Attributes
public:

// Operations
public:
    BOOL LoadToolBarEx(LPCTSTR lpszResourceName);

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CToolBarEx)
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CToolBarEx();

protected:
    BOOL LoadBitmapEx(LPCTSTR lpszResourceName);

	// Generated message map functions
protected:

	//{{AFX_MSG(CToolBarEx)
		// NOTE - the ClassWizard will add and remove member functions here.
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_TOOLBAREX_H__6D89DB48_2E76_4630_A95C_677E6CAB9E44__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\wmitest\valuepg.cpp ===
/*++

Copyright (C) 1997-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/

// ValuePg.cpp : implementation file
//

#include "stdafx.h"
#include "wmitest.h"
#include "OpWrap.h"
#include "ValuePg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CValuePg property page

IMPLEMENT_DYNCREATE(CValuePg, CPropertyPage)

CValuePg::CValuePg() : 
    CPropertyPage(CValuePg::IDD),
    m_bFirst(TRUE)
{
	//{{AFX_DATA_INIT(CValuePg)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
}

CValuePg::~CValuePg()
{
}

void CValuePg::DoDataExchange(CDataExchange* pDX)
{
    if (!pDX->m_bSaveAndValidate)
        m_propUtil.Init(this);

    m_propUtil.DoDataExchange(pDX);
}


BEGIN_MESSAGE_MAP(CValuePg, CPropertyPage)
	//{{AFX_MSG_MAP(CValuePg)
	ON_BN_CLICKED(IDC_NULL, OnNull)
	ON_BN_CLICKED(IDC_ADD, OnAdd)
	ON_BN_CLICKED(IDC_DELETE, OnDelete)
	ON_BN_CLICKED(IDC_UP, OnUp)
	ON_BN_CLICKED(IDC_DOWN, OnDown)
	ON_LBN_SELCHANGE(IDC_ARRAY_VALUES, OnSelchangeValueArray)
	ON_BN_CLICKED(IDC_EDIT, OnEdit)
	ON_BN_CLICKED(IDC_ARRAY, OnArray)
	ON_WM_PAINT()
	ON_CBN_SELCHANGE(IDC_TYPE, OnSelchangeType)
	ON_BN_CLICKED(IDC_EDIT_OBJ, OnEditObj)
	ON_BN_CLICKED(IDC_CLEAR, OnClear)
	ON_LBN_DBLCLK(IDC_ARRAY_VALUES, OnDblclkArrayValues)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CValuePg message handlers

void CValuePg::OnNull() 
{
    m_propUtil.OnNull();
}

void CValuePg::OnAdd() 
{
    m_propUtil.OnAdd();
}

void CValuePg::OnEdit() 
{
    m_propUtil.OnEdit();
}

void CValuePg::OnDelete() 
{
    m_propUtil.OnDelete();
}


void CValuePg::OnUp() 
{
    m_propUtil.OnUp();
}

void CValuePg::OnDown() 
{
    m_propUtil.OnDown();
}

void CValuePg::OnSelchangeValueArray() 
{
    m_propUtil.OnSelchangeValueArray();
}

void CValuePg::OnArray() 
{
    m_propUtil.OnArray();
}

void CValuePg::OnPaint() 
{
	CPaintDC dc(this); // device context for painting
	
    // This is a total pain!!!  I tried putting this in WM_INIT_DIALOG and
    // DoDataExchange but neither one worked.

/*
    if (m_bFirst)
    {
        m_propUtil.OnInitDialog();

        m_bFirst = FALSE;
    }
*/
	
	// Do not call CPropertyPage::OnPaint() for painting messages
}

void CValuePg::OnSelchangeType() 
{
    m_propUtil.OnSelchangeType();
}

void CValuePg::OnEditObj() 
{
    m_propUtil.OnEditEmbedded();
}

void CValuePg::OnClear() 
{
    m_propUtil.OnClearEmbedded();
}

void CValuePg::OnDblclkArrayValues() 
{
    m_propUtil.OnDblclkArrayValues();
}

BOOL CValuePg::OnInitDialog() 
{
	CPropertyPage::OnInitDialog();
	
	return m_propUtil.OnInitDialog();
	
	//return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\wmitest\wmitest.cpp ===
/*++

Copyright (C) 1997-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/

// WMITest.cpp : Defines the class behaviors for the application.
//

#include "stdafx.h"
#include "WMITest.h"

#include "MainFrm.h"
#include "WMITestDoc.h"
#include "OpView.h"

#include <cominit.h> // for SetInterfaceSecurityEx()
#include "Utils.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CWMITestApp

BEGIN_MESSAGE_MAP(CWMITestApp, CWinApp)
	//{{AFX_MSG_MAP(CWMITestApp)
	ON_COMMAND(ID_APP_ABOUT, OnAppAbout)
		// NOTE - the ClassWizard will add and remove mapping macros here.
		//    DO NOT EDIT what you see in these blocks of generated code!
	//}}AFX_MSG_MAP
	// Standard file based document commands
	ON_COMMAND(ID_FILE_NEW, CWinApp::OnFileNew)
	ON_COMMAND(ID_FILE_OPEN, CWinApp::OnFileOpen)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CWMITestApp construction

CWMITestApp::CWMITestApp()
{
	// TODO: add construction code here,
	// Place all significant initialization in InitInstance
}

/////////////////////////////////////////////////////////////////////////////
// The one and only CWMITestApp object

CWMITestApp theApp;

/////////////////////////////////////////////////////////////////////////////
// CWMITestApp initialization

BOOL CWMITestApp::InitInstance()
{
	// Standard initialization
	// If you are not using these features and wish to reduce the size
	//  of your final executable, you should remove from the following
	//  the specific initialization routines you do not need.

#ifdef _AFXDLL
	Enable3dControls();			// Call this when using MFC in a shared DLL
#else
	Enable3dControlsStatic();	// Call this when linking to MFC statically
#endif

	// Change the registry key under which our settings are stored.
	// TODO: You should modify this string to be something appropriate
	// such as the name of your company or organization.
	SetRegistryKey(_T("Microsoft"));

	LoadStdProfileSettings(16);  // Load standard INI file options (including MRU)

    //AfxOleInit();

	if (FAILED(InitializeCom()))
    {
        AfxMessageBox(IDS_COM_INIT_FAILED);
        return FALSE;
    }

/*
    CFileDialog file(TRUE);

    file.m_ofn.Flags |= OFN_NODEREFERENCELINKS;
    file.DoModal();
*/

	InitializeSecurity(
        NULL, -1, NULL, NULL,
		RPC_C_AUTHN_LEVEL_NONE,
		RPC_C_IMP_LEVEL_IMPERSONATE,
		NULL, EOAC_NONE, 0);

	m_bLoadLastFile = GetProfileInt(_T("Settings"), _T("LoadLast"), TRUE);
    m_bShowSystemProperties = GetProfileInt(_T("Settings"), _T("ShowSys"), TRUE);
    m_bShowInheritedProperties = GetProfileInt(_T("Settings"), _T("ShowInherited"), TRUE);
    m_bTranslateValues = GetProfileInt(_T("Settings"), _T("TranslateValues"), TRUE);
    m_dwUpdateFlag = GetProfileInt(_T("Settings"), _T("UpdateFlag"), 
                        WBEM_FLAG_CREATE_OR_UPDATE);
    m_dwClassUpdateMode = GetProfileInt(_T("Settings"), _T("ClassUpdateMode"), 
                        WBEM_FLAG_UPDATE_COMPATIBLE);
    m_bDelFromWMI = GetProfileInt(_T("Settings"), _T("DelFromWMI"), TRUE);
    m_bEnablePrivsOnStartup = GetProfileInt(_T("Settings"), _T("EnablePrivsOnStartup"), FALSE);

    if (m_bEnablePrivsOnStartup)
    {
        HRESULT hr = EnableAllPrivileges(TOKEN_PROCESS);    

        if (SUCCEEDED(hr))
            m_bPrivsEnabled = TRUE;
        else
            AfxMessageBox(IDS_ENABLE_PRIVS_FAILED, hr);
            //CWMITestDoc::DisplayWMIErrorBox(hr);
    }
        
/*
    HRESULT hr;

	// NOTE: This is needed to work around a security problem
	// when using IWBEMObjectSink. The sink wont normally accept
	// calls when the caller wont identify themselves. This
	// waives that process.
	hr = 
        CoInitializeSecurity(
            NULL, 
            -1, 
            NULL, 
            NULL, 
			RPC_C_AUTHN_LEVEL_CONNECT, 
			RPC_C_IMP_LEVEL_IDENTIFY, 
			NULL, 
            0, 
            0);
*/

	// Register the application's document templates.  Document templates
	//  serve as the connection between documents, frame windows and views.

	CSingleDocTemplate* pDocTemplate;
	pDocTemplate = new CSingleDocTemplate(
		IDR_MAINFRAME,
		RUNTIME_CLASS(CWMITestDoc),
		RUNTIME_CLASS(CMainFrame),       // main SDI frame window
		RUNTIME_CLASS(COpView));
	AddDocTemplate(pDocTemplate);

	// Enable DDE Execute open
	EnableShellOpen();
	RegisterShellFileTypes(TRUE);

	// Parse command line for standard shell commands, DDE, file open
/*
	CCommandLineInfo cmdInfo;
	ParseCommandLine(cmdInfo);

	// Dispatch commands specified on the command line
	if (!ProcessShellCommand(cmdInfo))
		return FALSE;
*/
	
    
    CCommandLineInfo cmdInfo;

	ParseCommandLine(cmdInfo);

	BOOL bModifiedParams = FALSE;

#if 1
    if (!(*m_pRecentFileList)[0].IsEmpty() &&
		cmdInfo.m_nShellCommand == CCommandLineInfo::FileNew &&
		m_bLoadLastFile)
	{
		cmdInfo.m_nShellCommand = CCommandLineInfo::FileOpen;
		cmdInfo.m_strFileName = (*m_pRecentFileList)[0];
		bModifiedParams = TRUE;
	}
#endif

	// Dispatch commands specified on the command line
	if (!ProcessShellCommand(cmdInfo))
	{
		if (bModifiedParams)
		{
			// If we failed to open the last .qvw file, change
			// the option to new and continue.
			cmdInfo.m_nShellCommand = CCommandLineInfo::FileNew;
			cmdInfo.m_strFileName = "";

			if (!ProcessShellCommand(cmdInfo))
				return FALSE;
		}
		else
			return FALSE;
	}

	// The one and only window has been initialized, so show and update it.
	m_pMainWnd->ShowWindow(SW_SHOW);
	m_pMainWnd->UpdateWindow();

	// Enable drag/drop open
	m_pMainWnd->DragAcceptFiles();

    ((CWMITestDoc*) ((CMainFrame*) m_pMainWnd)->GetActiveDocument())->AutoConnect();

	//CoInitialize(NULL);

    return TRUE;
}


/////////////////////////////////////////////////////////////////////////////
// CAboutDlg dialog used for App About

class CAboutDlg : public CDialog
{
public:
	CAboutDlg();

// Dialog Data
	//{{AFX_DATA(CAboutDlg)
	enum { IDD = IDD_ABOUTBOX };
	//}}AFX_DATA

	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CAboutDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	//{{AFX_MSG(CAboutDlg)
	virtual BOOL OnInitDialog();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

CAboutDlg::CAboutDlg() : CDialog(CAboutDlg::IDD)
{
	//{{AFX_DATA_INIT(CAboutDlg)
	//}}AFX_DATA_INIT
}

void CAboutDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CAboutDlg)
	//}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CAboutDlg, CDialog)
	//{{AFX_MSG_MAP(CAboutDlg)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

// App command to run the dialog
void CWMITestApp::OnAppAbout()
{
	CAboutDlg aboutDlg;
	aboutDlg.DoModal();
}

/////////////////////////////////////////////////////////////////////////////
// CWMITestApp message handlers


int CWMITestApp::ExitInstance() 
{
	CoUninitialize();
	//CoUninitialize();
	
	WriteProfileInt(_T("Settings"), _T("LoadLast"), m_bLoadLastFile);
    WriteProfileInt(_T("Settings"), _T("ShowSys"), m_bShowSystemProperties);
    WriteProfileInt(_T("Settings"), _T("ShowInherited"), m_bShowInheritedProperties);
    WriteProfileInt(_T("Settings"), _T("TranslateValues"), m_bTranslateValues);

    WriteProfileInt(_T("Settings"), _T("UpdateFlag"), m_dwUpdateFlag);
    WriteProfileInt(_T("Settings"), _T("ClassUpdateMode"), m_dwClassUpdateMode);

    WriteProfileInt(_T("Settings"), _T("DelFromWMI"), m_bDelFromWMI);

    WriteProfileInt(_T("Settings"), _T("EnablePrivsOnStartup"), m_bEnablePrivsOnStartup);

	return CWinApp::ExitInstance();
}

BOOL CAboutDlg::OnInitDialog() 
{
	CDialog::OnInitDialog();
	
    // Version info
    char szFilename[MAX_PATH],
         szVersion[100];

    GetModuleFileName(NULL, szFilename, sizeof(szFilename));
	
    if (GetFileVersion(szFilename, szVersion))
    {
        static CFont fontVersion;
        
        fontVersion.CreatePointFont(70, "Arial");

        GetDlgItem(IDS_VERSION)->SetFont(&fontVersion);

        SetDlgItemText(IDS_VERSION, szVersion);
	}
	
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\wmitest\valuepg.h ===
/*++

Copyright (C) 1997-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/

#if !defined(AFX_VALUEPG_H__941D3DE9_92EF_405C_BFA1_C1D8E50A484E__INCLUDED_)
#define AFX_VALUEPG_H__941D3DE9_92EF_405C_BFA1_C1D8E50A484E__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// ValuePg.h : header file
//

#include "PropUtil.h"

/////////////////////////////////////////////////////////////////////////////
// CValuePg dialog

class CValuePg : public CPropertyPage
{
	DECLARE_DYNCREATE(CValuePg)

// Construction
public:
	CValuePg();
	~CValuePg();

// Dialog Data
	//{{AFX_DATA(CValuePg)
	enum { IDD = IDD_PROPERTY };
	//}}AFX_DATA
    CPropUtil m_propUtil;
    
// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CValuePg)
	public:
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
    BOOL m_bFirst;

    // Generated message map functions
	//{{AFX_MSG(CValuePg)
	afx_msg void OnNull();
	afx_msg void OnAdd();
	afx_msg void OnDelete();
	afx_msg void OnUp();
	afx_msg void OnDown();
	afx_msg void OnSelchangeValueArray();
	afx_msg void OnEdit();
	afx_msg void OnArray();
	afx_msg void OnPaint();
	afx_msg void OnSelchangeType();
	afx_msg void OnEditObj();
	afx_msg void OnClear();
	afx_msg void OnDblclkArrayValues();
	virtual BOOL OnInitDialog();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_VALUEPG_H__941D3DE9_92EF_405C_BFA1_C1D8E50A484E__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\wmitest\wmitestdoc.cpp ===
/*++

Copyright (C) 1997-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/

// WMITestDoc.cpp : implementation of the CWMITestDoc class
//

#include "stdafx.h"
//#include <cominit.h>
#include "utils.h"
#include "WMITest.h"

#include "OpWrap.h"
#include "WMITestDoc.h"
#include "LoginDlg.h"
#include "GetTextDlg.h"
#include "MainFrm.h"
#include "OpView.h"
#include "ObjVw.h"
#include "PrefDlg.h"
#include "ErrorDlg.h"
#include "PropsPg.H"
#include "PropQualsPg.h"
#include "ExecMethodDlg.h"
#include "MofDlg.h"
#include "BindingSheet.h"
#include "FilterPg.h"
#include "ConsumerPg.h"
#include "BindingPg.h"

#include "ExportDlg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CWMITestDoc

IMPLEMENT_DYNCREATE(CWMITestDoc, CDocument)

BEGIN_MESSAGE_MAP(CWMITestDoc, CDocument)
	//{{AFX_MSG_MAP(CWMITestDoc)
	ON_COMMAND(ID_CONNECT, OnConnect)
	ON_UPDATE_COMMAND_UI_RANGE(ID_FIRST_NEED_CONNECTION, ID_LAST_NEED_CONNECTION, OnUpdateAgainstConnection)
	ON_COMMAND(ID_QUERY, OnQuery)
	ON_COMMAND(ID_NOTIFICATIONQUERY, OnNotificationQuery)
	ON_COMMAND(ID_STOP, OnStop)
	//ON_UPDATE_COMMAND_UI(ID_STOP, OnUpdateStop)
	ON_COMMAND(ID_REFRESH_ALL, OnRefreshAll)
	ON_COMMAND(ID_ENUMERATEINSTANCES, OnEnumerateInstances)
	ON_COMMAND(ID_ENUMERATE_CLASSES, OnEnumerateClasses)
	ON_COMMAND(ID_GET_CLASS, OnGetClass)
	ON_COMMAND(ID_GETINSTANCE, OnGetInstance)
	ON_COMMAND(ID_REFRESH_CURRENT, OnRefreshCurrent)
	ON_COMMAND(ID_ASSOCIATORS, OnAssociators)
	ON_UPDATE_COMMAND_UI(ID_ASSOCIATORS, OnUpdateAssociators)
	ON_COMMAND(ID_REFERENCES, OnReferences)
	ON_COMMAND(ID_INST_GET_CLASS, OnInstGetClass)
	ON_COMMAND(ID_INST_GET_INST, OnInstGetInst)
	ON_COMMAND(ID_CLASS_INSTANCES, OnClassInstances)
	ON_COMMAND(ID_CLASS_SUPERCLASS, OnClassSuperclass)
	ON_COMMAND(ID_CLASS_INSTANCES_DEEP, OnClassInstancesDeep)
	ON_COMMAND(ID_CLASS_SUBCLASSES_DEEP, OnClassSubclassesDeep)
	ON_COMMAND(ID_CLASS_SUBCLASSES, OnClassSubclasses)
	ON_COMMAND(ID_OPTIONS, OnOptions)
	ON_COMMAND(ID_SYSTEM_PROPS, OnSystemProps)
	ON_UPDATE_COMMAND_UI(ID_SYSTEM_PROPS, OnUpdateSystemProps)
	ON_COMMAND(ID_INHERITED_PROPS, OnInheritedProps)
	ON_UPDATE_COMMAND_UI(ID_INHERITED_PROPS, OnUpdateInheritedProps)
	ON_COMMAND(ID_RECONNECT, OnReconnect)
	ON_UPDATE_COMMAND_UI(ID_RECONNECT, OnUpdateReconnect)
	ON_COMMAND(ID_TRANSLATE_VALUES, OnTranslateValues)
	ON_UPDATE_COMMAND_UI(ID_TRANSLATE_VALUES, OnUpdateTranslateValues)
	ON_COMMAND(ID_SAVE, OnSave)
	ON_UPDATE_COMMAND_UI(ID_SAVE, OnUpdateSave)
	ON_COMMAND(ID_CREATE_CLASS, OnCreateClass)
	ON_COMMAND(ID_CREATE_INSTANCE, OnCreateInstance)
	ON_COMMAND(ID_CLASS_CREATE_INST, OnClassCreateInstance)
	ON_COMMAND(ID_ERROR_DETAILS, OnErrorDetails)
	ON_UPDATE_COMMAND_UI(ID_ERROR_DETAILS, OnUpdateErrorDetails)
	ON_COMMAND(ID_EXEC_METHOD, OnExecMethod)
	ON_COMMAND(ID_SHOW_MOF, OnShowMof)
	ON_UPDATE_COMMAND_UI(ID_SHOW_MOF, OnUpdateShowMof)
	ON_COMMAND(ID_EXPORT_TREE, OnExportTree)
	ON_COMMAND(ID_EXPORT_ITEM, OnExportItem)
	ON_COMMAND(ID_FILTER_BINDINGS, OnFilterBindings)
	ON_COMMAND(ID_STOP_CURRENT, OnStopCurrent)
	ON_UPDATE_COMMAND_UI(ID_REFRESH_CURRENT, OnUpdateRefreshCurrent)
	ON_UPDATE_COMMAND_UI(ID_REFERENCES, OnUpdateAssociators)
	ON_UPDATE_COMMAND_UI(ID_INST_GET_CLASS, OnUpdateAssociators)
	ON_UPDATE_COMMAND_UI(ID_INST_GET_INST, OnUpdateAssociators)
	ON_UPDATE_COMMAND_UI(ID_CLASS_INSTANCES, OnUpdateAssociators)
	ON_UPDATE_COMMAND_UI(ID_CLASS_SUPERCLASS, OnUpdateAssociators)
	ON_UPDATE_COMMAND_UI(ID_STOP_CURRENT, OnUpdateStopCurrent)
	//}}AFX_MSG_MAP
	ON_COMMAND_RANGE(IDC_EXECUTE_METHOD_FIRST, IDC_EXECUTE_METHOD_LAST, OnExecuteMethod)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CWMITestDoc construction/destruction

#define CLIPFORMAT_PROPERTIES _T("WMITest Properties")
#define CLIPFORMAT_OPS        _T("WMITest Operations")

CWMITestDoc::CWMITestDoc() :
    m_pOpView(NULL),
    m_pObjView(NULL),
    m_nBusyOps(0)
    //m_pPrincipal(NULL),
    //m_pAuthIdentity(NULL)
{
    m_pNamespace = NULL;

    m_cfProps = (CLIPFORMAT) RegisterClipboardFormat(CLIPFORMAT_PROPERTIES);
    m_cfOps = (CLIPFORMAT) RegisterClipboardFormat(CLIPFORMAT_OPS);
}

CWMITestDoc::~CWMITestDoc()
{
}

BOOL CWMITestDoc::OnNewDocument()
{
    if (m_pOpView)
        m_pOpView->FlushItems();

    if (!CDocument::OnNewDocument())
		return FALSE;

	return TRUE;
}



/////////////////////////////////////////////////////////////////////////////
// CWMITestDoc serialization

void CWMITestDoc::Serialize(CArchive& archive)
{
	if (archive.IsStoring())
	{
		int       nCount = m_pOpView->GetOpCount();
        CTreeCtrl *pTree = m_pOpView->m_pTree;

        // This will go into the op wrappers.
        m_pObjView->SaveColumns();

        archive << m_strNamespace;
        archive << nCount;

        for (HTREEITEM hitemOp = pTree->GetChildItem(m_pOpView->m_hitemRoot);
            hitemOp != NULL;
            hitemOp = pTree->GetNextSiblingItem(hitemOp))
        {
            COpWrap *pWrap = (COpWrap*) pTree->GetItemData(hitemOp);

            pWrap->Serialize(archive);
        }
	}
	else
	{
        if (!m_pOpView)
        {
            POSITION pos = GetFirstViewPosition();

            m_pOpView = (COpView*) GetNextView(pos);
            m_pObjView = (CObjView*) GetNextView(pos);
        }

        if (m_pOpView)
            m_pOpView->FlushItems();

        int nCount;

        archive >> m_strNamespace;
        if (SUCCEEDED(Connect(FALSE)))
        {
            archive >> nCount;

            for (int i = 0; i < nCount; i++)
            {
                COpWrap *pWrap = new COpWrap;

                pWrap->Serialize(archive);

                m_pOpView->AddOpItem(pWrap);
            }
        }
	}
}

/////////////////////////////////////////////////////////////////////////////
// CWMITestDoc diagnostics

#ifdef _DEBUG
void CWMITestDoc::AssertValid() const
{
	CDocument::AssertValid();
}

void CWMITestDoc::Dump(CDumpContext& dc) const
{
	CDocument::Dump(dc);
}
#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// CWMITestDoc commands

void CWMITestDoc::OnConnect() 
{
    CLoginDlg dlg;
    
    dlg.m_strAuthority = 
        theApp.GetProfileString(_T("Login"), _T("Authority"), _T(""));
    
    dlg.m_strNamespace = 
        theApp.GetProfileString(_T("Login"), _T("Namespace"), _T("root\\default"));
    
    dlg.m_strUser = theApp.GetProfileString(_T("Login"), _T("User"), _T(""));

    dlg.m_strLocale = theApp.GetProfileString(_T("Login"), _T("Locale"), _T(""));

    dlg.m_dwImpLevel = theApp.GetProfileInt(_T("Login"), _T("Imp"), 
                        RPC_C_IMP_LEVEL_IMPERSONATE);

    dlg.m_dwAuthLevel = theApp.GetProfileInt(_T("Login"), _T("Auth"), 
                         RPC_C_AUTHN_LEVEL_CONNECT);

    dlg.m_bNullPassword = theApp.GetProfileInt(_T("Login"), _T("Null"), FALSE);

    if (dlg.DoModal() == IDOK)
    {
        Disconnect();

        theApp.WriteProfileString(_T("Login"), _T("Authority"), dlg.m_strAuthority);
        theApp.WriteProfileString(_T("Login"), _T("Namespace"), dlg.m_strNamespace);
        theApp.WriteProfileString(_T("Login"), _T("User"), dlg.m_strUser);
        theApp.WriteProfileString(_T("Login"), _T("Locale"), dlg.m_strLocale);
        theApp.WriteProfileInt(_T("Login"), _T("Imp"), dlg.m_dwImpLevel);
        theApp.WriteProfileInt(_T("Login"), _T("Auth"), dlg.m_dwAuthLevel);
        theApp.WriteProfileInt(_T("Login"), _T("Null"), dlg.m_bNullPassword);
        m_strPassword = dlg.m_strPassword;
        m_strNamespace = dlg.m_strNamespace;

        Connect(FALSE, TRUE);
    }
}

void CWMITestDoc::AutoConnect()
{
    // Only do this if we're not already connected.
    if (m_pNamespace == NULL)
    {
        // If we weren't able to connect without prompting for information,
        // then display the connect dialog and try again.
        if (FAILED(Connect(TRUE, TRUE)))
            OnConnect();
    }
}

void CWMITestDoc::SetInterfaceSecurity(IUnknown *pUnk)
{
    CString strAuthority = 
                theApp.GetProfileString(_T("Login"), _T("Authority"), _T("")),
            strUser =
                theApp.GetProfileString(_T("Login"), _T("User"), _T(""));
    BOOL    bNullPassword = theApp.GetProfileInt(_T("Login"), _T("Null"), 
                                FALSE);
    BSTR    pUser = strUser.IsEmpty() ? NULL : 
                        strUser.AllocSysString(),
            pPassword = bNullPassword || !pUser ? NULL : 
                            m_strPassword.AllocSysString(),
            pAuthority = strAuthority.IsEmpty() ? NULL : 
                            strAuthority.AllocSysString();
    DWORD   dwImpLevel = theApp.GetProfileInt(_T("Login"), _T("Imp"), 
                            RPC_C_IMP_LEVEL_IMPERSONATE),
            dwAuthLevel = theApp.GetProfileInt(_T("Login"), _T("Auth"), 
                            RPC_C_AUTHN_LEVEL_CONNECT);

    SetSecurityHelper(
        pUnk, 
        pAuthority, 
        pUser, 
        pPassword,
        dwImpLevel,
        dwAuthLevel);

    if (pUser)
        SysFreeString(pUser);

    if (pPassword)
        SysFreeString(pPassword);

    if (pAuthority)
        SysFreeString(pAuthority);
}

HRESULT CWMITestDoc::Connect(BOOL bSilent, BOOL bFlushItems)
{
    // Create an instance of the WbemLocator interface.
	IWbemLocator *pLocator = NULL;
    HRESULT      hr;

    // Make sure this isn't empty.
    if (m_strNamespace.IsEmpty())
        m_strNamespace = 
            theApp.GetProfileString(
                _T("Login"), _T("Namespace"), _T("root\\default"));

    if ((hr = CoCreateInstance(
        CLSID_WbemLocator,
		NULL,
		CLSCTX_INPROC_SERVER,
		IID_IWbemLocator,
		(LPVOID *) &pLocator)) == S_OK)
    {
        CString strAuthority = 
                    theApp.GetProfileString(_T("Login"), _T("Authority"), _T("")),
                strUser =
                    theApp.GetProfileString(_T("Login"), _T("User"), _T("")),
                strLocale =
                    theApp.GetProfileString(_T("Login"), _T("Locale"), _T(""));
        BOOL    bNullPassword = theApp.GetProfileInt(_T("Login"), _T("Null"), FALSE);
        DWORD   dwImpLevel = theApp.GetProfileInt(_T("Login"), _T("Imp"), 
                                RPC_C_IMP_LEVEL_IMPERSONATE),
                dwAuthLevel = theApp.GetProfileInt(_T("Login"), _T("Auth"), 
                                RPC_C_AUTHN_LEVEL_CONNECT);

	    // Using the locator, connect to CIMOM in the given namespace.
        CWaitCursor wait;
        BSTR        pNamespace = m_strNamespace.AllocSysString(),
                    pUser = strUser.IsEmpty() ? NULL : 
                                strUser.AllocSysString(),
                    pPassword = bNullPassword || !pUser ? NULL : 
                                    m_strPassword.AllocSysString(),
                    pAuthority = strAuthority.IsEmpty() ? NULL : 
                                    strAuthority.AllocSysString(),
                    pLocale = strLocale.IsEmpty() ? NULL : 
                                    strLocale.AllocSysString();

#ifdef SVCEX
        IWbemServices *pTemp = NULL;
#endif

        if ((hr = pLocator->ConnectServer(
            pNamespace,
			pUser,      // username
			pPassword,	// password
			pLocale,    // locale
			0L,		    // securityFlags
			pAuthority,	// authority (domain for NTLM)
			NULL,	    // context
#ifdef SVCEX
            &pTemp)) == S_OK)
#else
			&m_pNamespace)) == S_OK) 
#endif
        {	
#ifdef SVCEX
            pTemp->QueryInterface(IID_IWbemServicesEx, (void **) &m_pNamespace);

            pTemp->Release();
#endif

            SetSecurityHelper(
                m_pNamespace, 
                pAuthority, 
                pUser, 
                pPassword,
                dwImpLevel,
                dwAuthLevel);
        }
		else
            m_pNamespace = NULL;

/*
        HRESULT hr;
        IWbemClassObject *pClass = NULL;
        _bstr_t          strClass = L"__ProviderRegistration";
        IWbemServices    *pSvc = NULL;
        
        m_pNamespace->QueryInterface(IID_IWbemServicesEx, (void **) &pSvc);
        
        hr =
        m_pNamespace->GetObject(
            strClass,
            WBEM_FLAG_RETURN_WBEM_COMPLETE,
            NULL,
            &pClass,
            NULL);
*/
            
        if (m_pOpView)
        {
            m_pOpView->UpdateRootText();
            
            if (bFlushItems)
                m_pOpView->FlushItems();
        }

        // Done with BSTR vars.
		if (pNamespace)
            SysFreeString(pNamespace);

        if (pUser)
            SysFreeString(pUser);

		if (pPassword)
            SysFreeString(pPassword);

		if (pAuthority)
            SysFreeString(pAuthority);

		if (pLocale)
            SysFreeString(pLocale);

		    
        // Done with pIWbemLocator. 
		pLocator->Release(); 
    }

    if (!bSilent && FAILED(hr))
        CWMITestDoc::DisplayWMIErrorBox(hr);

    return hr;
}

void CWMITestDoc::Disconnect()
{
    // If already connected, release m_pIWbemServices.
	if (m_pNamespace)
    {
        StopOps();

        m_pNamespace->Release();

        m_nBusyOps = 0;

        m_pNamespace = NULL;
    }
}


void CWMITestDoc::OnUpdateAgainstConnection(CCmdUI* pCmdUI) 
{
    pCmdUI->Enable(m_pNamespace != NULL);
}

void CWMITestDoc::OnQuery() 
{
	CGetTextDlg dlg;

    dlg.m_dwPromptID = IDS_QUERY_PROMPT;
    dlg.m_dwTitleID = IDS_QUERY_TITLE;
    dlg.m_bAllowQueryBrowse = TRUE;
    dlg.m_pNamespace = m_pNamespace;
    dlg.LoadListViaReg(_T("QueryHistory"));

    if (dlg.DoModal() == IDOK)
    {
        m_pOpView->AddOpItem(WMI_QUERY, dlg.m_strText);
    }
}

void CWMITestDoc::OnCloseDocument() 
{
	if (m_pOpView)
        m_pOpView->FlushItems();

    Disconnect();
	
	CDocument::OnCloseDocument();
}

void CWMITestDoc::DoConnectDlg()
{
    OnConnect();
}


void CWMITestDoc::OnNotificationQuery() 
{
	CGetTextDlg dlg;

    dlg.m_dwPromptID = IDS_NOTIFICATION_QUERY_PROMPT;
    dlg.m_dwTitleID = IDS_NOTIFICATION_QUERY_TITLE;
    dlg.m_dwOptionID = IDS_MONITORY_QUERY;
    dlg.m_bAllowQueryBrowse = TRUE;
    dlg.m_pNamespace = m_pNamespace;
    dlg.m_strSuperClass = _T("__EVENT");
    dlg.LoadListViaReg(_T("NotiQueryHistory"));
    dlg.m_bOptionChecked = theApp.GetProfileInt(_T("Settings"), _T("MonitorQuery"), FALSE);

    if (dlg.DoModal() == IDOK)
    {
        theApp.WriteProfileInt(_T("Settings"), _T("MonitorQuery"), dlg.m_bOptionChecked);

        m_pOpView->AddOpItem(WMI_EVENT_QUERY, dlg.m_strText, dlg.m_bOptionChecked);
    }
}

void CWMITestDoc::OnStop() 
{
    StopOps();    
}

void CWMITestDoc::StopOps()
{
    CTreeCtrl *pTree = m_pOpView->m_pTree;

    for (HTREEITEM hitemOp = pTree->GetChildItem(m_pOpView->m_hitemRoot);
        hitemOp != NULL;
        hitemOp = pTree->GetNextSiblingItem(hitemOp))
    {
        COpWrap *pWrap = (COpWrap*) pTree->GetItemData(hitemOp);

        pWrap->CancelOp(m_pNamespace);
    }
}

/*
void CWMITestDoc::OnUpdateStop(CCmdUI* pCmdUI) 
{
    pCmdUI->Enable(m_nBusyOps != 0);
}
*/

void CWMITestDoc::OnRefreshAll() 
{
    m_pOpView->RefreshItems();    
}

void CWMITestDoc::OnEnumerateInstances() 
{
	CGetTextDlg dlg;

    dlg.m_dwPromptID = IDS_ENUM_INST_PROMPT;
    dlg.m_dwTitleID = IDS_ENUM_INST_TITLE;
    dlg.m_dwOptionID = IDS_RECURSIVE;
    dlg.m_bAllowClassBrowse = TRUE;
    dlg.m_pNamespace = m_pNamespace;
    dlg.LoadListViaReg(_T("EnumInstHistory"));
    dlg.m_bOptionChecked = theApp.GetProfileInt(_T("Settings"), _T("Recurse"), FALSE);

    if (dlg.DoModal() == IDOK)
    {
        theApp.WriteProfileInt(_T("Settings"), _T("Recurse"), dlg.m_bOptionChecked);

        m_pOpView->AddOpItem(WMI_ENUM_OBJ, dlg.m_strText, dlg.m_bOptionChecked);
    }
}

void CWMITestDoc::OnEnumerateClasses() 
{
	CGetTextDlg dlg;

    dlg.m_dwPromptID = IDS_ENUM_CLASS_PROMPT;
    dlg.m_dwTitleID = IDS_ENUM_CLASS_TITLE;
    dlg.m_dwOptionID = IDS_RECURSIVE;
    dlg.m_bEmptyOK = TRUE;
    dlg.m_bAllowClassBrowse = TRUE;
    dlg.m_pNamespace = m_pNamespace;
    dlg.LoadListViaReg(_T("EnumClassHistory"));
    dlg.m_bOptionChecked = theApp.GetProfileInt(_T("Settings"), _T("Recurse"), FALSE);

    if (dlg.DoModal() == IDOK)
    {
        theApp.WriteProfileInt(_T("Settings"), _T("Recurse"), dlg.m_bOptionChecked);

        m_pOpView->AddOpItem(WMI_ENUM_CLASS, dlg.m_strText, dlg.m_bOptionChecked);
    }
}

void CWMITestDoc::OnGetClass() 
{
	CGetTextDlg dlg;

    dlg.m_dwPromptID = IDS_GET_CLASS_PROMPT;
    dlg.m_dwTitleID = IDS_GET_CLASS_TITLE;
    dlg.m_bAllowClassBrowse = TRUE;
    dlg.m_pNamespace = m_pNamespace;
    dlg.LoadListViaReg(_T("GetClassHistory"));

    if (dlg.DoModal() == IDOK)
    {
        m_pOpView->AddOpItem(WMI_GET_CLASS, dlg.m_strText);
    }
}

void CWMITestDoc::OnCreateClass() 
{
	CGetTextDlg dlg;

    dlg.m_dwPromptID = IDS_CREATE_CLASS_PROMPT;
    dlg.m_dwTitleID = IDS_CREATE_CLASS_TITLE;
    dlg.m_bAllowClassBrowse = TRUE;
    dlg.m_bEmptyOK = TRUE;
    dlg.m_pNamespace = m_pNamespace;
    dlg.LoadListViaReg(_T("GetClassHistory"));

    if (dlg.DoModal() == IDOK)
    {
        m_pOpView->AddOpItem(WMI_CREATE_CLASS, dlg.m_strText);
    }
}

void CWMITestDoc::OnGetInstance() 
{
	CGetTextDlg dlg;

    dlg.m_dwPromptID = IDS_GET_INST_PROMPT;
    dlg.m_dwTitleID = IDS_GET_INST_TITLE;
    dlg.LoadListViaReg(_T("GetInstHistory"));

    if (dlg.DoModal() == IDOK)
    {
        m_pOpView->AddOpItem(WMI_GET_OBJ, dlg.m_strText);
    }
}

void CWMITestDoc::OnCreateInstance() 
{
	CGetTextDlg dlg;

    dlg.m_dwPromptID = IDS_CREATE_OBJ_PROMPT;
    dlg.m_dwTitleID = IDS_CREATE_OBJ_TITLE;
    dlg.m_bAllowClassBrowse = TRUE;
    dlg.m_pNamespace = m_pNamespace;
    dlg.LoadListViaReg(_T("GetClassHistory"));

    if (dlg.DoModal() == IDOK)
    {
        m_pOpView->AddOpItem(WMI_CREATE_OBJ, dlg.m_strText);
    }
}

void CWMITestDoc::OnRefreshCurrent() 
{
    HTREEITEM hItem = m_pOpView->m_pTree->GetSelectedItem();

    m_pOpView->RefreshItem(hItem);
}

HTREEITEM CWMITestDoc::GetCurrentItem()
{
    CMainFrame *pFrame = (CMainFrame*) AfxGetMainWnd();

    if (pFrame->GetActiveView() == m_pOpView)
        return m_pOpView->m_pTree->GetSelectedItem();
    else
        return m_pObjView->GetSelectedItem();
}

CObjInfo *CWMITestDoc::GetCurrentObj()
{
    HTREEITEM hitem = GetCurrentItem();

    return m_pOpView->GetObjInfo(hitem);
}

void CWMITestDoc::OnAssociators() 
{
/*
    HTREEITEM hitem = GetCurrentItem();

    if (hitem && m_pOpView->IsObj(hitem))
    {
        CString strQuery,
                strPath;

        strPath = m_pOpView->m_pTree->GetItemText(hitem);

        strQuery.Format(
            _T("associators of {%s}"),
            (LPCTSTR) strPath);

        m_pOpView->AddOpItem(WMI_QUERY, strQuery);
    }
*/
    CString strObj;

    if (GetSelectedObjPath(strObj))
    {
        CString strQuery;

        strQuery.Format(
            _T("associators of {%s}"),
            (LPCTSTR) strObj);

        m_pOpView->AddOpItem(WMI_QUERY, strQuery);
    }
}

void CWMITestDoc::OnUpdateAssociators(CCmdUI* pCmdUI) 
{
    //HTREEITEM hitem = GetCurrentItem();

    //pCmdUI->Enable(hitem && m_pOpView->IsObj(hitem));
    CString strObj;

    pCmdUI->Enable(GetSelectedObjPath(strObj));
}

void CWMITestDoc::OnReferences() 
{
/*
    HTREEITEM hitem = GetCurrentItem();

    if (hitem && m_pOpView->IsObj(hitem))
    {
        CString strQuery,
                strPath;

        strPath = m_pOpView->m_pTree->GetItemText(hitem);

        strQuery.Format(
            _T("references of {%s}"),
            (LPCTSTR) strPath);

        m_pOpView->AddOpItem(WMI_QUERY, strQuery);
    }
*/
    CString strObj;

    if (GetSelectedObjPath(strObj))
    {
        CString strQuery;

        strQuery.Format(
            _T("references of {%s}"),
            (LPCTSTR) strObj);

        m_pOpView->AddOpItem(WMI_QUERY, strQuery);
    }
}

void CWMITestDoc::OnInstGetClass() 
{
    CString strClass;

    if (GetSelectedClass(strClass))
        m_pOpView->AddOpItem(WMI_GET_CLASS, strClass);
}

void CWMITestDoc::OnInstGetInst() 
{
    CString strObj;

    if (GetSelectedObjPath(strObj))
        m_pOpView->AddOpItem(WMI_GET_OBJ, strObj);
}

void CWMITestDoc::OnClassInstances() 
{
    CObjInfo *pInfo = m_pOpView->GetObjInfo(GetCurrentItem());

    if (pInfo)
    {
        CString strClass;

        strClass = pInfo->GetStringPropValue(L"__CLASS");

        m_pOpView->AddOpItem(WMI_ENUM_OBJ, strClass, FALSE);
    }
}

void CWMITestDoc::OnClassSuperclass() 
{
    CObjInfo *pInfo = m_pOpView->GetObjInfo(GetCurrentItem());

    if (pInfo)
    {
        CString strClass;

        strClass = pInfo->GetStringPropValue(L"__SUPERCLASS");

        if (!strClass.IsEmpty())
            m_pOpView->AddOpItem(WMI_GET_CLASS, strClass);
        else
            AfxMessageBox(IDS_NO_SUPERCLASS);
    }
}

void CWMITestDoc::OnClassInstancesDeep() 
{
    CObjInfo *pInfo = m_pOpView->GetObjInfo(GetCurrentItem());

    if (pInfo)
    {
        CString strClass;

        strClass = pInfo->GetStringPropValue(L"__CLASS");

        m_pOpView->AddOpItem(WMI_ENUM_OBJ, strClass, TRUE);
    }
}

void CWMITestDoc::OnClassSubclasses() 
{
    CObjInfo *pInfo = m_pOpView->GetObjInfo(GetCurrentItem());

    if (pInfo)
    {
        CString strClass;

        strClass = pInfo->GetStringPropValue(L"__CLASS");

        m_pOpView->AddOpItem(WMI_ENUM_CLASS, strClass, FALSE);
    }
}

void CWMITestDoc::OnClassSubclassesDeep() 
{
    CObjInfo *pInfo = m_pOpView->GetObjInfo(GetCurrentItem());

    if (pInfo)
    {
        CString strClass;

        strClass = pInfo->GetStringPropValue(L"__CLASS");

        m_pOpView->AddOpItem(WMI_ENUM_CLASS, strClass, TRUE);
    }
}


void CWMITestDoc::OnOptions() 
{
    CPrefDlg dlg;

    dlg.m_bLoadLast = theApp.m_bLoadLastFile;
    dlg.m_bShowInherited = theApp.m_bShowInheritedProperties;
    dlg.m_bShowSystem = theApp.m_bShowSystemProperties;
    dlg.m_dwUpdateFlag = theApp.m_dwUpdateFlag;
    dlg.m_dwClassUpdateMode = theApp.m_dwClassUpdateMode;
    dlg.m_bEnablePrivsOnStartup = theApp.m_bEnablePrivsOnStartup;
    dlg.m_bPrivsEnabled = theApp.m_bPrivsEnabled;

    if (dlg.DoModal() == IDOK)
    {
        theApp.m_bLoadLastFile = dlg.m_bLoadLast;
        theApp.m_bShowInheritedProperties = dlg.m_bShowInherited;
        theApp.m_bShowSystemProperties = dlg.m_bShowSystem;
        theApp.m_dwUpdateFlag = dlg.m_dwUpdateFlag;
        theApp.m_dwClassUpdateMode = dlg.m_dwClassUpdateMode;
        theApp.m_bEnablePrivsOnStartup = dlg.m_bEnablePrivsOnStartup;
        theApp.m_bPrivsEnabled = dlg.m_bPrivsEnabled;

        //m_pOpView->UpdateCurrentObject();
        m_pOpView->UpdateCurrentItem();
    }
}

void CWMITestDoc::OnSystemProps() 
{
    theApp.m_bShowSystemProperties ^= 1; 

    m_pOpView->UpdateCurrentItem();
}

void CWMITestDoc::OnUpdateSystemProps(CCmdUI* pCmdUI) 
{
    pCmdUI->SetCheck(theApp.m_bShowSystemProperties);
}

void CWMITestDoc::OnInheritedProps() 
{
    theApp.m_bShowInheritedProperties ^= 1; 

    m_pOpView->UpdateCurrentItem();
}

void CWMITestDoc::OnUpdateInheritedProps(CCmdUI* pCmdUI) 
{
    pCmdUI->SetCheck(theApp.m_bShowInheritedProperties);
}

BOOL CWMITestDoc::GetSelectedObjPath(CString &strPath)
{
    CMainFrame *pFrame = (CMainFrame*) AfxGetMainWnd();

    if (pFrame->GetActiveView() == m_pOpView)
        return m_pOpView->GetSelectedObjPath(strPath);
    else
        return m_pObjView->GetSelectedObjPath(strPath);
}

BOOL CWMITestDoc::GetSelectedClass(CString &strClass)
{
    CMainFrame *pFrame = (CMainFrame*) AfxGetMainWnd();

    if (pFrame->GetActiveView() == m_pOpView)
        return m_pOpView->GetSelectedClass(strClass);
    else
        return m_pObjView->GetSelectedClass(strClass);
}

void CWMITestDoc::OnReconnect() 
{
    Disconnect();

    // If we weren't able to connect without prompting for information,
    // then display the connect dialog and try again.
    if (FAILED(Connect(TRUE, FALSE)))
        OnConnect();

    OnRefreshAll();
}

void CWMITestDoc::OnUpdateReconnect(CCmdUI* pCmdUI) 
{
    pCmdUI->Enable(m_pNamespace != NULL);
}

void CWMITestDoc::OnTranslateValues() 
{
    theApp.m_bTranslateValues ^= 1; 

    m_pOpView->UpdateCurrentItem();
}

void CWMITestDoc::OnUpdateTranslateValues(CCmdUI* pCmdUI) 
{
    pCmdUI->SetCheck(theApp.m_bTranslateValues);
}

void CWMITestDoc::OnSave() 
{
	CObjInfo *pObj = GetCurrentObj();
    COpWrap  *pWrap = m_pOpView->GetCurrentOp();

    if (pObj)
    {
        HRESULT         hr;
        IWbemCallResult *pResult = NULL;

        if (pObj->IsInstance())
            hr = m_pNamespace->PutInstance(
                    pObj->m_pObj,
                    theApp.m_dwUpdateFlag | WBEM_FLAG_USE_AMENDED_QUALIFIERS,
                    NULL,
                    &pResult);
        else
            hr = m_pNamespace->PutClass(
                    pObj->m_pObj,
                    theApp.m_dwUpdateFlag | theApp.m_dwClassUpdateMode |
                        WBEM_FLAG_USE_AMENDED_QUALIFIERS,
                    NULL,
                    &pResult);

        if (SUCCEEDED(hr))
        {
            if (pWrap && pWrap->m_type == WMI_CREATE_OBJ)
            {
                _variant_t var;

                hr = pObj->m_pObj->Get(L"__RELPATH", 0, &var, NULL, NULL);
                
                if (SUCCEEDED(hr))
                {
                    // We created an instance, but since the key fields were
                    // generated by WMI we'll have to use GetResultString to
                    // get the path.
                    if (var.vt == VT_NULL)
                    {
                        BSTR bstr = NULL;

                        if (SUCCEEDED(hr =
                            pResult->GetResultString(WBEM_INFINITE, &bstr)))
                        {
                            var = bstr;
                            SysFreeString(bstr);
                        }
                    }

                    if (var.vt != VT_NULL)
                    {
                        pWrap->m_type = WMI_GET_OBJ;
                        pWrap->m_strOpText = var.bstrVal;

                        pObj->SetModified(FALSE);
                        m_pOpView->RefreshItem(pWrap);
                        m_pOpView->UpdateCurrentObject(TRUE);
                    }
                }
            }
            else if (pWrap && pWrap->m_type == WMI_CREATE_CLASS)
            {
                _variant_t var;

                hr = pObj->m_pObj->Get(L"__CLASS", 0, &var, NULL, NULL);
                if (SUCCEEDED(hr))
                {
                    pWrap->m_type = WMI_GET_CLASS;
                    pWrap->m_strOpText = var.bstrVal;

                    pObj->SetModified(FALSE);
                    m_pOpView->RefreshItem(pWrap);
                    m_pOpView->UpdateCurrentObject(TRUE);
                }
            }
            else
            {
                pObj->SetModified(FALSE);
                m_pOpView->UpdateCurrentObject(TRUE);
            }
        }
            
        if (FAILED(hr))
            DisplayWMIErrorBox(hr);
            //DisplayWMIErrorBox(hr, pResult);

        if (pResult)
            pResult->Release();
    }
}

void CWMITestDoc::OnUpdateSave(CCmdUI* pCmdUI) 
{
	CObjInfo *pObj = GetCurrentObj();

    pCmdUI->Enable(pObj && pObj->IsModified());
}

void CWMITestDoc::DisplayWMIErrorBox(
    HRESULT hres, 
    //IWbemCallResult *pResult,
    IWbemClassObject *pObj)
{
    CErrorDlg dlg;

    dlg.m_hr = hres;
    //dlg.m_pResult = pResult;
    
    if (!pObj)
        pObj = GetWMIErrorObject();

    dlg.m_pObj.Attach(pObj, FALSE);

    dlg.DoModal();
}

BOOL CWMITestDoc::EditGenericObject(DWORD dwPrompt, IWbemClassObject *pObj)
{
    CPropertySheet sheet(dwPrompt);
    CPropsPg       pgProps;
    CPropQualsPg   pgQuals;
    CObjInfo       info;

    info.SetObj(pObj);
    info.SetBaseImage(IMAGE_OBJECT);
    info.LoadProps(NULL);
        
    pgProps.m_pNamespace = NULL;
    pgProps.m_pObj = &info;

    pgQuals.m_pObj = pObj;
    pgQuals.m_bIsInstance = TRUE;
    pgQuals.m_mode = CPropQualsPg::QMODE_CLASS;

    sheet.AddPage(&pgProps);
    sheet.AddPage(&pgQuals);

    sheet.DoModal();

    // This looks bad, but normally this is done by a controlling COpWrap.  In
    // this case we faked one, so we have to get rid of it ourselves.
    delete info.GetProps();

    // TODO: We need to see if this object changed before returning TRUE.
    return TRUE;
}

void CWMITestDoc::DisplayWMIErrorDetails(IWbemClassObject *pObj)
{
    EditGenericObject(IDS_VIEW_ERROR_INFO, pObj);
}


void CWMITestDoc::OnClassCreateInstance() 
{
    CObjInfo *pInfo = m_pOpView->GetObjInfo(GetCurrentItem());

    if (pInfo)
    {
        CString strClass;

        strClass = pInfo->GetStringPropValue(L"__CLASS");

        m_pOpView->AddOpItem(WMI_CREATE_OBJ, strClass, FALSE);
    }
}

void CWMITestDoc::OnErrorDetails() 
{
	COpWrap *pOp = m_pOpView->GetCurrentOp();

    if (pOp && pOp->m_pErrorObj != NULL)
        DisplayWMIErrorDetails(pOp->m_pErrorObj);
}

void CWMITestDoc::OnUpdateErrorDetails(CCmdUI* pCmdUI) 
{
	COpWrap *pOp = m_pOpView->GetCurrentOp();

    pCmdUI->Enable(pOp && pOp->m_pErrorObj != NULL);
}

void CWMITestDoc::OnExecuteMethod(UINT uiCmd)
{
    CObjInfo *pInfo = GetCurrentObj();

    if (pInfo)
    {
        CPropInfoArray *pProps = pInfo->GetProps();
        int            iWhich = uiCmd - IDC_EXECUTE_METHOD_FIRST;

        if (iWhich < pProps->GetMethodCount())
        {
            CMethodInfo &info = pProps->m_listMethods.GetAt(
                                    pProps->m_listMethods.FindIndex(iWhich));
        
            ExecuteMethod(pInfo, info.m_strName);
        }
    }
}

void CWMITestDoc::ExecuteMethod(CObjInfo *pObj, LPCTSTR szMethod)
{
    CExecMethodDlg dlg;
    
    dlg.m_strDefaultMethod = szMethod;
    dlg.m_pInfo = pObj;
    
    dlg.DoModal();    
}


void CWMITestDoc::OnExecMethod() 
{
	CGetTextDlg dlg;

    dlg.m_dwPromptID = IDS_PROMPT_EXEC_METHOD;
    dlg.m_dwTitleID = IDS_EXEC_METHOD_TITLE;
    dlg.m_bAllowClassBrowse = TRUE;
    dlg.m_bEmptyOK = FALSE;
    dlg.m_pNamespace = m_pNamespace;
    dlg.LoadListViaReg(_T("ExecObjHistory"));

    if (dlg.DoModal() == IDOK)
    {
        IWbemClassObjectPtr pObj;
        HRESULT             hr;

        hr =
            m_pNamespace->GetObject(
                _bstr_t(dlg.m_strText),
                WBEM_FLAG_RETURN_WBEM_COMPLETE,
                NULL,
                &pObj,
                NULL);

        if (SUCCEEDED(hr))
        {
            CObjInfo info;

            info.SetObj(pObj);
            info.SetBaseImage(IMAGE_OBJECT);
            info.LoadProps(m_pNamespace);
        
            // The method is blank so the user can choose when the dialog
            // comes up.
            ExecuteMethod(&info, _T(""));

            // This looks bad, but normally this is done by a controlling COpWrap.  In
            // this case we faked one, so we have to get rid of it ourselves.
            delete info.GetProps();
        }
        else
            DisplayWMIErrorBox(hr);    
    }
}

void CWMITestDoc::OnShowMof() 
{
	CObjInfo *pObj = GetCurrentObj();
    CMofDlg  dlg;

    dlg.m_pObj = pObj->m_pObj;

    dlg.DoModal();
}

void CWMITestDoc::OnUpdateShowMof(CCmdUI* pCmdUI) 
{
	CObjInfo *pObj = GetCurrentObj();

    pCmdUI->Enable(pObj != NULL);
}

void CWMITestDoc::ExportItem(HTREEITEM hitem)
{
    CExportDlg dlg(FALSE);
    
    dlg.m_bTranslate = theApp.GetProfileInt(_T("Settings"), _T("ExportTrans"), TRUE);
    dlg.m_bShowSystemProps = theApp.GetProfileInt(_T("Settings"), _T("ExportShowSys"), TRUE);

    if (dlg.DoModal() == IDOK)
    {
        theApp.WriteProfileInt(_T("Settings"), _T("ExportTrans"), dlg.m_bTranslate); 
        theApp.WriteProfileInt(_T("Settings"), _T("ExportShowSys"), dlg.m_bShowSystemProps);

        m_pOpView->ExportItemToFile(
            dlg.GetFileName(), 
            hitem, 
            dlg.m_bShowSystemProps, 
            dlg.m_bTranslate);
    }
}

void CWMITestDoc::OnExportTree() 
{
    ExportItem(m_pOpView->m_hitemRoot);
}

void CWMITestDoc::OnExportItem() 
{
	ExportItem(GetCurrentItem());
}

void CWMITestDoc::OnFilterBindings() 
{
    CBindingSheet sheet(IDS_FILTER_TO_CONSUMER_BINDINGS);
    CFilterPg     pgFilters;
    CConsumerPg   pgConsumers;
    CBindingPg    pgBindings;

    sheet.AddPage(&pgFilters);
    sheet.AddPage(&pgConsumers);
    sheet.AddPage(&pgBindings);

    sheet.DoModal();
}

void CWMITestDoc::OnStopCurrent() 
{
    COpWrap *pWrap = m_pOpView->GetCurrentOp();

    if (pWrap)
        pWrap->CancelOp(m_pNamespace);
}

void CWMITestDoc::OnUpdateRefreshCurrent(CCmdUI* pCmdUI) 
{
	pCmdUI->Enable(m_pOpView->GetCurrentOp() != NULL);
}

void CWMITestDoc::OnUpdateStopCurrent(CCmdUI* pCmdUI) 
{
	pCmdUI->Enable(m_pOpView->GetCurrentOp() != NULL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\wmitest\wmitest.h ===
/*++

Copyright (C) 1997-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/

// WMITest.h : main header file for the WMITEST application
//

#if !defined(AFX_WMITEST_H__4419F1A4_692B_11D3_BD30_0080C8E60955__INCLUDED_)
#define AFX_WMITEST_H__4419F1A4_692B_11D3_BD30_0080C8E60955__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#ifndef __AFXWIN_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

#include "resource.h"       // main symbols

/////////////////////////////////////////////////////////////////////////////
// CWMITestApp:
// See WMITest.cpp for the implementation of this class
//

class CWMITestApp : public CWinApp
{
public:
	BOOL  m_bLoadLastFile,
          m_bShowSystemProperties,
          m_bShowInheritedProperties,
          m_bTranslateValues,
	      m_bEnablePrivsOnStartup,
	      m_bPrivsEnabled,
          m_bDelFromWMI;
    DWORD m_dwUpdateFlag,
          m_dwClassUpdateMode;

    CWMITestApp();

    
// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CWMITestApp)
	public:
	virtual BOOL InitInstance();
	virtual int ExitInstance();
	//}}AFX_VIRTUAL

// Implementation
	//{{AFX_MSG(CWMITestApp)
	afx_msg void OnAppAbout();
		// NOTE - the ClassWizard will add and remove member functions here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

extern CWMITestApp theApp;

/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_WMITEST_H__4419F1A4_692B_11D3_BD30_0080C8E60955__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\wql\wqllex.h ===
/*++

Copyright (C) 1997-2001 Microsoft Corporation

Module Name:

    WQLLEX.H

Abstract:

	WQL DFA Table & Tokenizer

History:

	raymcc    14-Sep-97       Created.

--*/

#ifndef _WQLLEX_H_

#include <genlex.h>
#define WQL_TOK_EOF           0
#define WQL_TOK_ERROR         1


#define WQL_TOK_SELECT                      256
#define WQL_TOK_ALL                         257
#define WQL_TOK_DISTINCT                    258
#define WQL_TOK_OPTIONS_DUMMY               259
#define WQL_TOK_ASTERISK                    260
#define WQL_TOK_COUNT                       261
#define WQL_TOK_COMMA                       262
#define WQL_TOK_OPEN_PAREN                  263
#define WQL_TOK_CLOSE_PAREN                 264
#define WQL_TOK_IDENT                       265
#define WQL_TOK_DOT                         266
#define WQL_TOK_FROM                        267
#define WQL_TOK_AS                          268
#define WQL_TOK_INNER                       269
#define WQL_TOK_FULL                        270
#define WQL_TOK_LEFT                        271
#define WQL_TOK_RIGHT                       272
#define WQL_TOK_OUTER                       273
#define WQL_TOK_JOIN                        274
#define WQL_TOK_ON                          275
#define WQL_TOK_WHERE                       276
#define WQL_TOK_GROUP                       277
#define WQL_TOK_BY                          278
#define WQL_TOK_HAVING                      279
#define WQL_TOK_ORDER                       280
#define WQL_TOK_OR                          281
#define WQL_TOK_AND                         282
#define WQL_TOK_NOT                         283
#define WQL_TOK_LE                          284
#define WQL_TOK_LT                          285
#define WQL_TOK_GE                          286
#define WQL_TOK_GT                          287
#define WQL_TOK_EQ                          288
#define WQL_TOK_NE                          289
#define WQL_TOK_LIKE                        290
#define WQL_TOK_IS                          291
#define WQL_TOK_BEFORE                      292
#define WQL_TOK_AFTER                       293
#define WQL_TOK_BETWEEN                     294
#define WQL_TOK_QSTRING                     295
#define WQL_TOK_INT                         296
#define WQL_TOK_REAL                        297
#define WQL_TOK_CHAR                        298
#define WQL_TOK_NULL                        299
#define WQL_TOK_OPEN_BRACKET                300
#define WQL_TOK_CLOSE_BRACKET               301
#define WQL_TOK_ISA                         302
#define WQL_TOK_A                           303
#define WQL_TOK_DAY                         304
#define WQL_TOK_MONTH                       305
#define WQL_TOK_YEAR                        306
#define WQL_TOK_HOUR                        307
#define WQL_TOK_MINUTE                      308
#define WQL_TOK_SECOND                      309
#define WQL_TOK_MILLISECOND                 310

#define WQL_TOK_UPPER                       311
#define WQL_TOK_LOWER                       312
#define WQL_TOK_DATEPART                    313
#define WQL_TOK_QUALIFIER                   314
#define WQL_TOK_ISNULL                      315
#define WQL_TOK_IN                          316

#define WQL_TOK_NOT_LIKE                    317
#define WQL_TOK_NOT_BEFORE                  318
#define WQL_TOK_NOT_AFTER                   319
#define WQL_TOK_NOT_BETWEEN                 320
#define WQL_TOK_NOT_NULL                    321
#define WQL_TOK_NOT_IN                      322
#define WQL_TOK_NOT_A                       323

#define WQL_TOK_TYPED_EXPR                  324


#define WQL_TOK_IN_SUBSELECT                325
#define WQL_TOK_NOT_IN_SUBSELECT            326
#define WQL_TOK_IN_CONST_LIST               327
#define WQL_TOK_NOT_IN_CONST_LIST           328

#define WQL_TOK_ASC                         329
#define WQL_TOK_DESC                        330
#define WQL_TOK_AGGREGATE                   331
#define WQL_TOK_FIRSTROW                    332

#define WQL_TOK_PROMPT                      333
#define WQL_TOK_UNION                       334
extern LexEl WQL_LexTable[];


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\wmitest\wmitestdoc.h ===
/*++

Copyright (C) 1997-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/

// WMITestDoc.h : interface of the CWMITestDoc class
//
/////////////////////////////////////////////////////////////////////////////

#if !defined(AFX_WMITESTDOC_H__4419F1AA_692B_11D3_BD30_0080C8E60955__INCLUDED_)
#define AFX_WMITESTDOC_H__4419F1AA_692B_11D3_BD30_0080C8E60955__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

class COpView;
class CObjView;
class CObjInfo;

//#define SVCEX

class CWMITestDoc : public CDocument
{
protected: // create from serialization only
	CWMITestDoc();
	DECLARE_DYNCREATE(CWMITestDoc)

// Attributes
public:
#ifdef SVCEX
    IWbemServicesEx *m_pNamespace;
#else
    IWbemServices *m_pNamespace;
#endif
    COpView *m_pOpView;
    CObjView *m_pObjView;
    CString m_strNamespace,
            m_strPassword;
    CLIPFORMAT m_cfRelPaths,
               m_cfProps,
               m_cfOps;

// Operations
public:
    HRESULT Connect(BOOL bSilent, BOOL bFlushItems = TRUE);
    void Disconnect();
    void DoConnectDlg();
    void StopOps();
    void IncBusyOps() { m_nBusyOps++; }
    void DecBusyOps() { if (m_nBusyOps > 0) m_nBusyOps--; }
    void AutoConnect();
    HTREEITEM GetCurrentItem();
    CObjInfo *GetCurrentObj();
    BOOL GetSelectedObjPath(CString &strPath);
    BOOL GetSelectedClass(CString &strClass);
    static void DisplayWMIErrorBox(
        HRESULT hres, 
        //IWbemCallResult *pResult = NULL,
        IWbemClassObject *pObj = NULL);
    static void DisplayWMIErrorDetails(IWbemClassObject *pObj);
    static BOOL EditGenericObject(DWORD dwPrompt, IWbemClassObject *pObj);
    void ExecuteMethod(CObjInfo *pObj, LPCTSTR szMethod);

    void SetInterfaceSecurity(IUnknown *pUnk);

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CWMITestDoc)
	public:
	virtual BOOL OnNewDocument();
	virtual void Serialize(CArchive& ar);
	virtual void OnCloseDocument();
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CWMITestDoc();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

protected:
    //BSTR           m_pPrincipal;
    //COAUTHIDENTITY *m_pAuthIdentity;
    int m_nBusyOps;

    void ExportItem(HTREEITEM hitem);

// Generated message map functions
protected:
	//{{AFX_MSG(CWMITestDoc)
	afx_msg void OnConnect();
	afx_msg void OnUpdateAgainstConnection(CCmdUI* pCmdUI);
	afx_msg void OnQuery();
	afx_msg void OnNotificationQuery();
	afx_msg void OnStop();
	afx_msg void OnUpdateStop(CCmdUI* pCmdUI);
	afx_msg void OnRefreshAll();
	afx_msg void OnEnumerateInstances();
	afx_msg void OnEnumerateClasses();
	afx_msg void OnGetClass();
	afx_msg void OnGetInstance();
	afx_msg void OnDelete();
	afx_msg void OnUpdateDelete(CCmdUI* pCmdUI);
	afx_msg void OnRefreshCurrent();
	afx_msg void OnAssociators();
	afx_msg void OnUpdateAssociators(CCmdUI* pCmdUI);
	afx_msg void OnReferences();
	afx_msg void OnInstGetClass();
	afx_msg void OnUpdateInstGetClass(CCmdUI* pCmdUI);
	afx_msg void OnInstGetInst();
	afx_msg void OnClassInstances();
	afx_msg void OnClassSuperclass();
	afx_msg void OnClassInstancesDeep();
	afx_msg void OnClassSubclassesDeep();
	afx_msg void OnClassSubclasses();
	afx_msg void OnOptions();
	afx_msg void OnSystemProps();
	afx_msg void OnUpdateSystemProps(CCmdUI* pCmdUI);
	afx_msg void OnInheritedProps();
	afx_msg void OnUpdateInheritedProps(CCmdUI* pCmdUI);
	afx_msg void OnReconnect();
	afx_msg void OnUpdateReconnect(CCmdUI* pCmdUI);
	afx_msg void OnTranslateValues();
	afx_msg void OnUpdateTranslateValues(CCmdUI* pCmdUI);
	afx_msg void OnSave();
	afx_msg void OnUpdateSave(CCmdUI* pCmdUI);
	afx_msg void OnCreateClass();
	afx_msg void OnCreateInstance();
	afx_msg void OnClassCreateInstance();
	afx_msg void OnErrorDetails();
	afx_msg void OnUpdateErrorDetails(CCmdUI* pCmdUI);
	afx_msg void OnExecMethod();
	afx_msg void OnShowMof();
	afx_msg void OnUpdateShowMof(CCmdUI* pCmdUI);
	afx_msg void OnExportTree();
	afx_msg void OnExportItem();
	afx_msg void OnFilterBindings();
	afx_msg void OnStopCurrent();
	afx_msg void OnUpdateRefreshCurrent(CCmdUI* pCmdUI);
	afx_msg void OnUpdateStopCurrent(CCmdUI* pCmdUI);
	//}}AFX_MSG
	afx_msg void OnExecuteMethod(UINT uiCmd);
	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_WMITESTDOC_H__4419F1AA_692B_11D3_BD30_0080C8E60955__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\wql\precomp.h ===
/*++

Copyright (C) 1997-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/


#pragma warning (disable : 4786)
#include <localloc.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\wqlscan\makefile.inc ===
!INCLUDE $(_NTDRIVE)$(_NTROOT)\WMI\COMMON\makefile.cmn
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\wqlscan\precomp.h ===
/*++

Copyright (C) 1997-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/


#pragma warning (disable : 4786)
#include <localloc.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\wqlscan\wqllex.cpp ===
/*++

Copyright (C) 1997-2001 Microsoft Corporation

Module Name:

    WQLLEX.CPP

Abstract:

    WQL DFA Table

History:

    raymcc    14-Sep-97       Created.
    raymcc    06-Oct-97       Single quote support

--*/

#include "precomp.h"
#include <stdio.h>

#include <genlex.h>
#include <wqllex.h>             

#define ST_STRING       26
#define ST_IDENT        31
#define ST_GE           37
#define ST_LE           39
#define ST_NE           42
#define ST_NUMERIC      44
#define ST_REAL         47
#define ST_STRING2      49
#define ST_STRING_ESC   54
#define ST_STRING2_ESC  55   
#define ST_SSTRING      56
#define ST_DOT          61

// DFA State Table for QL Level 1 lexical symbols.
// ================================================

LexEl WQL_LexTable[] =
{

// State    First   Last        New state,  Return tok,      Instructions
// =======================================================================
/* 0 */  L'A',   L'Z',       ST_IDENT,   0,               GLEX_ACCEPT,
/* 1 */  L'a',   L'z',       ST_IDENT,   0,               GLEX_ACCEPT,
/* 2 */  L'_',   GLEX_EMPTY, ST_IDENT,   0,               GLEX_ACCEPT,
/* 3 */  0x80,  0xfffd,     ST_IDENT,   0,               GLEX_ACCEPT,

/* 4 */  L'(',   GLEX_EMPTY, 0,          WQL_TOK_OPEN_PAREN,  GLEX_ACCEPT,
/* 5 */  L')',   GLEX_EMPTY, 0,  WQL_TOK_CLOSE_PAREN, GLEX_ACCEPT,
/* 6 */  L'.',   GLEX_EMPTY, ST_DOT,  0,         GLEX_ACCEPT,
/* 7 */  L'*',   GLEX_EMPTY, 0,  WQL_TOK_ASTERISK,    GLEX_ACCEPT,
/* 8 */  L'=',   GLEX_EMPTY, 0,  WQL_TOK_EQ,          GLEX_ACCEPT,
/* 9 */  L'[',   GLEX_EMPTY, 0,  WQL_TOK_OPEN_BRACKET,  GLEX_ACCEPT,
/* 10 */  L']',   GLEX_EMPTY, 0,  WQL_TOK_CLOSE_BRACKET, GLEX_ACCEPT,

/* 11 */  L'>',   GLEX_EMPTY, ST_GE,      0,               GLEX_ACCEPT,
/* 12 */  L'<',   GLEX_EMPTY, ST_LE,      0,               GLEX_ACCEPT,
/* 13 */ L'0',   L'9',       ST_NUMERIC, 0,               GLEX_ACCEPT,
/* 14 */ L'"',   GLEX_EMPTY, ST_STRING,  0,               GLEX_CONSUME,
/* 15 */ L'\'',  GLEX_EMPTY, ST_STRING2, 0,               GLEX_CONSUME,
/* 16 */ L'!',   GLEX_EMPTY, ST_NE,      0,               GLEX_ACCEPT,
/* 17 */ L'-',   GLEX_EMPTY, ST_NUMERIC, 0,               GLEX_ACCEPT,
/* 18 */ L'\'',  GLEX_EMPTY, ST_SSTRING, 0,               GLEX_CONSUME,

    // Whitespace, newlines, etc.
/* 19 */ L' ',   GLEX_EMPTY, 0,          0,               GLEX_CONSUME,
/* 20 */ L'\t',  GLEX_EMPTY, 0,  0,               GLEX_CONSUME,
/* 21 */ L'\n',  GLEX_EMPTY, 0,  0,               GLEX_CONSUME|GLEX_LINEFEED,
/* 22 */ L'\r',  GLEX_EMPTY, 0,  0,               GLEX_CONSUME,
/* 23 */ 0,      GLEX_EMPTY, 0,  WQL_TOK_EOF,   GLEX_CONSUME|GLEX_RETURN, // Note forced return
/* 24 */ L',',   GLEX_EMPTY, 0,  WQL_TOK_COMMA, GLEX_ACCEPT,

    // Unknown characters

/* 25 */ GLEX_ANY, GLEX_EMPTY, 0,        WQL_TOK_ERROR, GLEX_ACCEPT|GLEX_RETURN,

// ST_STRING
/* 26 */   L'\n', GLEX_EMPTY, 0,  WQL_TOK_ERROR,    GLEX_ACCEPT|GLEX_LINEFEED,
/* 27 */   L'\r', GLEX_EMPTY, 0,  WQL_TOK_ERROR,    GLEX_ACCEPT|GLEX_LINEFEED,
/* 28 */   L'"',  GLEX_EMPTY, 0,  WQL_TOK_QSTRING,  GLEX_CONSUME,
/* 29 */   L'\\',  GLEX_EMPTY, ST_STRING_ESC,  0,     GLEX_CONSUME,
/* 30 */   GLEX_ANY, GLEX_EMPTY, ST_STRING, 0,        GLEX_ACCEPT,
                                                      
// ST_IDENT

/* 31 */  L'a',   L'z',       ST_IDENT,   0,          GLEX_ACCEPT,
/* 32 */  L'A',   L'Z',       ST_IDENT,   0,          GLEX_ACCEPT,
/* 33 */  L'_',   GLEX_EMPTY, ST_IDENT,   0,          GLEX_ACCEPT,
/* 34 */  L'0',   L'9',       ST_IDENT,   0,          GLEX_ACCEPT,
/* 35 */  0x80,  0xfffd,     ST_IDENT,   0,          GLEX_ACCEPT,
/* 36 */  GLEX_ANY, GLEX_EMPTY,  0,       WQL_TOK_IDENT,  GLEX_PUSHBACK|GLEX_RETURN,

// ST_GE
/* 37 */  L'=',   GLEX_EMPTY,  0,  WQL_TOK_GE,  GLEX_ACCEPT,
/* 38 */  GLEX_ANY, GLEX_EMPTY,  0,       WQL_TOK_GT,   GLEX_PUSHBACK|GLEX_RETURN,

// ST_LE
/* 39 */  L'=',   GLEX_EMPTY,      0,  WQL_TOK_LE,  GLEX_ACCEPT,
/* 40 */  L'>',   GLEX_EMPTY,      0,  WQL_TOK_NE,  GLEX_ACCEPT,
/* 41 */  GLEX_ANY, GLEX_EMPTY,    0,  WQL_TOK_LT,  GLEX_PUSHBACK|GLEX_RETURN,

// ST_NE
/* 42 */  L'=',   GLEX_EMPTY,      0,  WQL_TOK_NE,     GLEX_ACCEPT,
/* 43 */  GLEX_ANY,  GLEX_EMPTY,   0,  WQL_TOK_ERROR,  GLEX_ACCEPT|GLEX_RETURN,

// ST_NUMERIC
/* 44 */  L'0',   L'9',         ST_NUMERIC, 0,          GLEX_ACCEPT,
/* 45 */  L'.',   GLEX_EMPTY,   ST_REAL,    0,          GLEX_ACCEPT,
/* 46 */  GLEX_ANY, GLEX_EMPTY, 0,          WQL_TOK_INT,  GLEX_PUSHBACK|GLEX_RETURN,

// ST_REAL
/* 47 */  L'0',   L'9',   ST_REAL, 0,          GLEX_ACCEPT,
/* 48 */  GLEX_ANY,       GLEX_EMPTY,   0,     WQL_TOK_REAL, GLEX_PUSHBACK|GLEX_RETURN,

// ST_STRING2
/* 49 */   L'\n',  GLEX_EMPTY, 0,  WQL_TOK_ERROR,     GLEX_ACCEPT|GLEX_LINEFEED,
/* 50 */   L'\r',  GLEX_EMPTY, 0,  WQL_TOK_ERROR,     GLEX_ACCEPT|GLEX_LINEFEED,
/* 51 */   L'\'',  GLEX_EMPTY, 0,  WQL_TOK_QSTRING,   GLEX_CONSUME,
/* 52 */   L'\\',  GLEX_EMPTY, ST_STRING2_ESC,  0,      GLEX_CONSUME,
/* 53 */   GLEX_ANY, GLEX_EMPTY, ST_STRING2, 0,        GLEX_ACCEPT,

// ST_STRING_ESC
/* 54 */   GLEX_ANY, GLEX_EMPTY, ST_STRING, 0, GLEX_ACCEPT,

// ST_STRING2_ESC
/* 55 */   GLEX_ANY, GLEX_EMPTY, ST_STRING2, 0, GLEX_ACCEPT,

// ST_SSTRING (Single quoted strings)
/* 56 */   L'\n', GLEX_EMPTY, 0,  WQL_TOK_ERROR,    GLEX_ACCEPT|GLEX_LINEFEED,
/* 57 */   L'\r', GLEX_EMPTY, 0,  WQL_TOK_ERROR,    GLEX_ACCEPT|GLEX_LINEFEED,
/* 58 */   L'\'',  GLEX_EMPTY, 0,  WQL_TOK_QSTRING,  GLEX_CONSUME,
/* 59 */   L'\\',  GLEX_EMPTY, ST_STRING_ESC,  0,     GLEX_CONSUME,
/* 60 */   GLEX_ANY, GLEX_EMPTY, ST_STRING, 0,        GLEX_ACCEPT,

// ST_DOT
/* 61 */  L'0',   L'9',   ST_REAL, 0,          GLEX_ACCEPT,
/* 62 */  GLEX_ANY,       GLEX_EMPTY,   0,     WQL_TOK_DOT, GLEX_PUSHBACK|GLEX_RETURN,
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\wql\wql.h ===
/*++

Copyright (C) 1997-2001 Microsoft Corporation

Module Name:

    WQL.H

Abstract:

	WQL 1.1 Parser

	Implements the syntax described in WQL.BNF. 

History:

	raymcc  19-Sep-97

--*/

#ifndef _WQL__H_
#define _WQL__H_



class CWQLParser
{
    // Data.
    // =====

    CGenLexer    *m_pLexer;
    int           m_nLine;
    wchar_t      *m_pTokenText;
    int           m_nCurrentToken;
    DWORD         m_dwFeaturesFlags;
    CWStringArray m_aReferencedTables;
    CWStringArray m_aReferencedAliases;
    CFlexArray    m_aSelAliases;
    CFlexArray    m_aSelColumns;

    SWQLNode_Select         *m_pQueryRoot; 
    SWQLNode_WhereClause    *m_pRootWhere; 
    SWQLNode_ColumnList     *m_pRootColList; 
    SWQLNode_FromClause     *m_pRootFrom; 
    SWQLNode_WhereOptions   *m_pRootWhereOptions; 


    // Parse context. In some cases, there is a general
    // shift in state for the whole parser.  Rather than
    // pass this as an inherited attribute to each production,
    // it is much easier to have a general purpose state variable.
    // ============================================================

    enum { Ctx_Default = 0, Ctx_Subselect = 0x1 };

    int         m_nParseContext;

    bool m_bAllowPromptForConstant;

    // Functions.
    // ==========

    BOOL Next();
    LONG GetTokenLong();

    int QNameToSWQLColRef(
        IN  SWQLQualifiedName *pQName,
        OUT SWQLColRef **pRetVal
        );

    enum { eCtxLeftSide = 1, eCtxRightSide = 2 };

    // Non-terminal productions.
    // =========================
    int select_stmt(OUT SWQLNode_Select **pSelStmt);                          
    int select_type(int & nSelType);                          
    int col_ref_list(IN OUT SWQLNode_TableRefs *pTblRefs);

    int from_clause(OUT SWQLNode_FromClause **pFrom);                          
    int where_clause(OUT SWQLNode_WhereClause **pRetWhere);                         
    int col_ref(OUT SWQLQualifiedName **pRetVal);                              
    int col_ref_rest(IN OUT SWQLNode_TableRefs *pTblRefs);                         

    int count_clause(
        OUT SWQLQualifiedName **pQualName
        );                         
        
    int single_table_decl(OUT SWQLNode_TableRef **pTblRef);                    
    int sql89_join_entry(
        IN  SWQLNode_TableRef *pInitialTblRef,
        OUT SWQLNode_Sql89Join **pJoin  );
    int sql92_join_entry(
        IN  SWQLNode_TableRef *pInitialTblRef,
        OUT SWQLNode_Join **pJoin             
        );

    int sql89_join_list(
        IN  SWQLNode_TableRef *pInitialTblRef,
        OUT SWQLNode_Sql89Join **pJoin  );
    int on_clause(OUT SWQLNode_OnClause **pOC);
    int rel_expr(OUT SWQLNode_RelExpr **pRelExpr);
    int where_options(OUT SWQLNode_WhereOptions **pWhereOpt0);
    int group_by_clause(OUT SWQLNode_GroupBy **pRetGroupBy);
    int having_clause(OUT SWQLNode_Having **pRetHaving);
    int order_by_clause(OUT SWQLNode_OrderBy **pRetOrderBy);
    int rel_term(OUT SWQLNode_RelExpr **pNewTerm);
    int rel_expr2(
        IN OUT SWQLNode_RelExpr *pLeftSide,
        OUT SWQLNode_RelExpr **pNewRootRE
        );
    int rel_simple_expr(OUT SWQLNode_RelExpr **pRelExpr);
    int rel_term2(
        IN SWQLNode_RelExpr *pLeftSide,                 
        OUT SWQLNode_RelExpr **pNewRootRE      
        );

    int typed_expr(OUT SWQLNode_RelExpr **pRelExpr);
    int typed_subexpr_rh(SWQLTypedExpr *pTE);
    int typed_subexpr(IN SWQLTypedExpr *pTE);
    int typed_const(OUT SWQLTypedConst **pRetVal);

    int datepart_call(
        OUT SWQLNode_Datepart **pRetDP
        );


    int function_call(IN BOOL bLeftSide, IN SWQLTypedExpr *pTE);
    int function_call_parms();
    int func_args();
    int func_arg();

    int rel_op(int &);
    int is_continuator(int &);
    int not_continuator(int &);

    int in_clause(IN SWQLTypedExpr *pTE);
    int subselect_stmt(OUT SWQLNode_Select **pSel);
    int qualified_name(OUT SWQLQualifiedName **pHead);
    int const_list(OUT SWQLConstList **pRetVal);
    int col_list(OUT SWQLNode_ColumnList **pRetColList);

    void Empty();

public:
    enum { 
        SUCCESS,
        SYNTAX_ERROR,
        LEXICAL_ERROR,
        FAILED,
        BUFFER_TOO_SMALL,
        INVALID_PARAMETER,
        INTERNAL_ERROR
    };

    enum 
    {
        Feature_Refs    = 0x2,             // A WQL 'references of' query
        Feature_Assocs  = 0x4,             // A WQL 'associators of' query
        Feature_Events  = 0x8,             // A WQL event-related query
        
        Feature_Joins        = 0x10,       // One or more joins occurred
        
        Feature_Having       = 0x20,       // HAVING used
        Feature_GroupBy      = 0x40,       // GROUP BY used
        Feature_OrderBy      = 0x80,       // ORDER BY used
        Feature_Count        = 0x100,      // COUNT used
        
        Feature_SelectAll     = 0x400,     // select * from
        Feature_SimpleProject = 0x800,        // no 'where' clause, no join
        Feature_ComplexNames  = 0x1000,       // Names with long qualifications occurred, such
                                              // as array properties and embedded objects.
        Feature_WQL_Extensions = 0x80000000   // WQL-specific extensions
        
    }   QueryFeatures;

    DWORD GetFeatureFlags();
        
    BOOL GetReferencedTables(OUT CWStringArray & Tables);
    BOOL GetReferencedAliases(OUT CWStringArray & Aliases);

    const LPWSTR AliasToTable(IN LPWSTR pAlias);

    const CFlexArray *GetSelectedAliases() { return &m_aSelAliases; }  
        // Array of ptrs to SWQLNode_TableRef structs; read-only

    const CFlexArray *GetSelectedColumns() { return &m_pRootColList->m_aColumnRefs; }  
        // Array of ptrs to SWQLColRef structs; read-only
        
    // Manual traversal.
    // =================

    SWQLNode *GetParseRoot() { return m_pQueryRoot; }
    SWQLNode *GetWhereClauseRoot() { return m_pRootWhere; }
    SWQLNode *GetColumnList() { return m_pRootColList; }
    SWQLNode *GetFromClause() { return m_pRootFrom; }
    SWQLNode *GetWhereOptions() { return m_pRootWhereOptions; }

    // Working
    // =======

    CWQLParser(CGenLexSource *pSrc);
   ~CWQLParser(); 
    int Parse();

    void AllowPromptForConstant(bool bIsAllowed = TRUE) {m_bAllowPromptForConstant = bIsAllowed;}
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\wql\wqllex.cpp ===
/*++

Copyright (C) 1997-2001 Microsoft Corporation

Module Name:

    WQLLEX.CPP

Abstract:

    WQL DFA Table

History:

    raymcc    14-Sep-97       Created.
    raymcc    06-Oct-97       Single quote support

--*/

#include "precomp.h"
#include <stdio.h>

#include <genlex.h>
#include <wqllex.h>             

#define ST_STRING       27
#define ST_IDENT        32
#define ST_GE           38
#define ST_LE           40
#define ST_NE           43
#define ST_NUMERIC      45
#define ST_REAL         48
#define ST_STRING2      50
#define ST_STRING_ESC   55
#define ST_STRING2_ESC  58   
#define ST_DOT          61
#define ST_PROMPT       63
#define ST_PROMPT_END   69
#define ST_PROMPT_ESC   71

// DFA State Table for QL Level 1 lexical symbols.
// ================================================

LexEl WQL_LexTable[] =
{

// State    First   Last        New state,  Return tok,      Instructions
// =======================================================================
/* 0 */  L'A',   L'Z',       ST_IDENT,   0,               GLEX_ACCEPT,
/* 1 */  L'a',   L'z',       ST_IDENT,   0,               GLEX_ACCEPT,
/* 2 */  L'_',   GLEX_EMPTY, ST_IDENT,   0,               GLEX_ACCEPT,
/* 3 */  0x80,  0xfffd,     ST_IDENT,   0,               GLEX_ACCEPT,

/* 4 */  L'(',   GLEX_EMPTY, 0,          WQL_TOK_OPEN_PAREN,  GLEX_ACCEPT,
/* 5 */  L')',   GLEX_EMPTY, 0,  WQL_TOK_CLOSE_PAREN, GLEX_ACCEPT,
/* 6 */  L'.',   GLEX_EMPTY, ST_DOT,  0,         GLEX_ACCEPT,
/* 7 */  L'*',   GLEX_EMPTY, 0,  WQL_TOK_ASTERISK,    GLEX_ACCEPT,
/* 8 */  L'=',   GLEX_EMPTY, 0,  WQL_TOK_EQ,          GLEX_ACCEPT,
/* 9 */  L'[',   GLEX_EMPTY, 0,  WQL_TOK_OPEN_BRACKET,  GLEX_ACCEPT,
/* 10 */  L']',   GLEX_EMPTY, 0,  WQL_TOK_CLOSE_BRACKET, GLEX_ACCEPT,

/* 11 */  L'>',   GLEX_EMPTY, ST_GE,      0,               GLEX_ACCEPT,
/* 12 */  L'<',   GLEX_EMPTY, ST_LE,      0,               GLEX_ACCEPT,
/* 13 */ L'0',   L'9',       ST_NUMERIC, 0,               GLEX_ACCEPT,
/* 14 */ L'"',   GLEX_EMPTY, ST_STRING,  0,               GLEX_CONSUME,
/* 15 */ L'\'',  GLEX_EMPTY, ST_STRING2, 0,               GLEX_CONSUME,
/* 16 */ L'!',   GLEX_EMPTY, ST_NE,      0,               GLEX_ACCEPT,
/* 17 */ L'-',   GLEX_EMPTY, ST_NUMERIC, 0,               GLEX_ACCEPT,
/* 18 */ L'\'',  GLEX_EMPTY, ST_STRING2, 0,               GLEX_CONSUME, // never

    // Whitespace, newlines, etc.
/* 19 */ L' ',   GLEX_EMPTY, 0,          0,               GLEX_CONSUME,
/* 20 */ L'\t',  GLEX_EMPTY, 0,  0,               GLEX_CONSUME,
/* 21 */ L'\n',  GLEX_EMPTY, 0,  0,               GLEX_CONSUME|GLEX_LINEFEED,
/* 22 */ L'\r',  GLEX_EMPTY, 0,  0,               GLEX_CONSUME,
/* 23 */ 0,      GLEX_EMPTY, 0,  WQL_TOK_EOF,   GLEX_CONSUME|GLEX_RETURN, // Note forced return
/* 24 */ L',',   GLEX_EMPTY, 0,  WQL_TOK_COMMA, GLEX_ACCEPT,

    // Prompt user for constant
/* 25 */   L'#',     GLEX_EMPTY, ST_PROMPT,     0,           GLEX_CONSUME,

    // Unknown characters
/* 26 */ GLEX_ANY, GLEX_EMPTY, 0,        WQL_TOK_ERROR, GLEX_ACCEPT|GLEX_RETURN,

// ST_STRING
/* 27 */   L'\n', GLEX_EMPTY, 0,  WQL_TOK_ERROR,    GLEX_ACCEPT|GLEX_LINEFEED,
/* 28 */   L'\r', GLEX_EMPTY, 0,  WQL_TOK_ERROR,    GLEX_ACCEPT,
/* 29 */   L'"',  GLEX_EMPTY, 0,  WQL_TOK_QSTRING,  GLEX_CONSUME,
/* 30 */   L'\\',  GLEX_EMPTY, ST_STRING_ESC,  0,     GLEX_CONSUME,
/* 31 */   GLEX_ANY, GLEX_EMPTY, ST_STRING, 0,        GLEX_ACCEPT,
                                                      
// ST_IDENT

/* 32 */  L'a',   L'z',       ST_IDENT,   0,          GLEX_ACCEPT,
/* 33 */  L'A',   L'Z',       ST_IDENT,   0,          GLEX_ACCEPT,
/* 34 */  L'_',   GLEX_EMPTY, ST_IDENT,   0,          GLEX_ACCEPT,
/* 35 */  L'0',   L'9',       ST_IDENT,   0,          GLEX_ACCEPT,
/* 36 */  0x80,  0xfffd,     ST_IDENT,   0,          GLEX_ACCEPT,
/* 37 */  GLEX_ANY, GLEX_EMPTY,  0,       WQL_TOK_IDENT,  GLEX_PUSHBACK|GLEX_RETURN,

// ST_GE
/* 38 */  L'=',   GLEX_EMPTY,  0,  WQL_TOK_GE,  GLEX_ACCEPT,
/* 39 */  GLEX_ANY, GLEX_EMPTY,  0,       WQL_TOK_GT,   GLEX_PUSHBACK|GLEX_RETURN,

// ST_LE
/* 40 */  L'=',   GLEX_EMPTY,      0,  WQL_TOK_LE,  GLEX_ACCEPT,
/* 41 */  L'>',   GLEX_EMPTY,      0,  WQL_TOK_NE,  GLEX_ACCEPT,
/* 42 */  GLEX_ANY, GLEX_EMPTY,    0,  WQL_TOK_LT,  GLEX_PUSHBACK|GLEX_RETURN,

// ST_NE
/* 43 */  L'=',   GLEX_EMPTY,      0,  WQL_TOK_NE,     GLEX_ACCEPT,
/* 44 */  GLEX_ANY,  GLEX_EMPTY,   0,  WQL_TOK_ERROR,  GLEX_ACCEPT|GLEX_RETURN,

// ST_NUMERIC
/* 45 */  L'0',   L'9',         ST_NUMERIC, 0,          GLEX_ACCEPT,
/* 46 */  L'.',   GLEX_EMPTY,   ST_REAL,    0,          GLEX_ACCEPT,
/* 47 */  GLEX_ANY, GLEX_EMPTY, 0,          WQL_TOK_INT,  GLEX_PUSHBACK|GLEX_RETURN,

// ST_REAL
/* 48 */  L'0',   L'9',   ST_REAL, 0,          GLEX_ACCEPT,
/* 49 */  GLEX_ANY,       GLEX_EMPTY,   0,     WQL_TOK_REAL, GLEX_PUSHBACK|GLEX_RETURN,

// ST_STRING2
/* 50 */   L'\n',  GLEX_EMPTY, 0,  WQL_TOK_ERROR,     GLEX_ACCEPT|GLEX_LINEFEED,
/* 51 */   L'\r',  GLEX_EMPTY, 0,  WQL_TOK_ERROR,     GLEX_ACCEPT,
/* 52 */   L'\'',  GLEX_EMPTY, 0,  WQL_TOK_QSTRING,   GLEX_CONSUME,
/* 53 */   L'\\',  GLEX_EMPTY, ST_STRING2_ESC,  0,      GLEX_CONSUME,
/* 54 */   GLEX_ANY, GLEX_EMPTY, ST_STRING2, 0,        GLEX_ACCEPT,

// ST_STRING_ESC
/* 55 */   L'"', GLEX_EMPTY, ST_STRING, 0, GLEX_ACCEPT,
/* 56 */   L'\\', GLEX_EMPTY, ST_STRING, 0, GLEX_ACCEPT,
/* 57 */   GLEX_ANY, GLEX_EMPTY, 0, WQL_TOK_ERROR, GLEX_ACCEPT|GLEX_RETURN,

// ST_STRING2_ESC
/* 58 */   L'\'', GLEX_EMPTY, ST_STRING2, 0, GLEX_ACCEPT,
/* 59 */   L'\\', GLEX_EMPTY, ST_STRING2, 0, GLEX_ACCEPT,
/* 60 */   GLEX_ANY, GLEX_EMPTY, 0, WQL_TOK_ERROR, GLEX_ACCEPT|GLEX_RETURN,

// ST_DOT
/* 61 */  L'0',   L'9',   ST_REAL, 0,          GLEX_ACCEPT,
/* 62 */  GLEX_ANY,       GLEX_EMPTY,   0,     WQL_TOK_DOT, GLEX_PUSHBACK|GLEX_RETURN,

// ST_PROMPT
/* 63 */   L'\n',    GLEX_EMPTY, ST_PROMPT,     0,           GLEX_ACCEPT|GLEX_LINEFEED,
/* 64 */   L'\r',    GLEX_EMPTY, ST_PROMPT,     0,           GLEX_ACCEPT,
/* 65 */   L'\\',    GLEX_EMPTY, ST_PROMPT_ESC, 0,           GLEX_CONSUME,
/* 66 */   L'#',     GLEX_EMPTY, ST_PROMPT_END, 0,           GLEX_ACCEPT,
/* 67 */   0,        GLEX_EMPTY,    0,      WQL_TOK_ERROR,   GLEX_PUSHBACK|GLEX_RETURN, // Note forced return
/* 68 */   GLEX_ANY, GLEX_EMPTY, ST_PROMPT,     0,           GLEX_ACCEPT,

// ST_PROMPT_END
/* 69 */   L'#',     GLEX_EMPTY,    0,      WQL_TOK_PROMPT,  GLEX_CONSUME,
/* 70 */  GLEX_ANY,  GLEX_EMPTY, ST_PROMPT,     0,           GLEX_PUSHBACK,

// ST_PROMPT_ESC
/* 71 */   L'#',     GLEX_EMPTY, ST_PROMPT,     0,           GLEX_ACCEPT,
/* 72 */   L'\\',    GLEX_EMPTY, ST_PROMPT,     0,           GLEX_ACCEPT,
/* 73 */   GLEX_ANY, GLEX_EMPTY,    0,      WQL_TOK_ERROR,   GLEX_PUSHBACK|GLEX_RETURN,
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\wql\wql.cpp ===
/*++

Copyright (C) 1997-2001 Microsoft Corporation

Module Name:

    WQL.CPP

Abstract:

    Implements the LL(1) syntax described in WQL.BNF via a recursive
    descent parser.

History:

    raymcc    14-Sep-97       Created.
    raymcc    18-Oct-97       SMS extensions.

--*/

// TO DO:

/*
5. SQL 89 joins
6. destructors & memleak checking
7. alias/table mismatch usage
8. allow ORDER BY and GROUP BY to occur in any order
9. AST-To-Text completion
11. Query Suite
11. "a" not a valid col name because it is now a keyword
18. ISNULL function
17. SELECT FROM (omission of the * or col-list)
*/


#include "precomp.h"
#include <stdio.h>

#include <genlex.h>
#include <flexarry.h>

#include <wqllex.h>

#include <wqlnode.h>
#include <wql.h>

static DWORD FlipOperator(DWORD dwOp);

inline wchar_t *Macro_CloneLPWSTR(LPCWSTR src)
{
    if (!src)
        return 0;
    wchar_t *dest = new wchar_t[wcslen(src) + 1];
    if (!dest)
        return 0;
    return wcscpy(dest, src);
}

#define trace(x) printf x

//***************************************************************************
//
//  CWQLParser::CWQLParser
//
//  Constructor
//
//  Parameters:
//  <pSrc>          A source from which to lex from.
//
//***************************************************************************

CWQLParser::CWQLParser(CGenLexSource *pSrc)
{
    m_pLexer = new CGenLexer(WQL_LexTable, pSrc);
    m_nLine = 0;
    m_pTokenText = 0;
    m_nCurrentToken = 0;

    m_dwFeaturesFlags = 0;

    m_pQueryRoot = 0;
    m_pRootWhere = 0;
    m_pRootColList = 0;
    m_pRootFrom = 0;
    m_pRootWhereOptions = 0;
    m_nParseContext = Ctx_Default;

    m_bAllowPromptForConstant = false;
}

//***************************************************************************
//
//  CWQLParser::~CWQLParser
//
//***************************************************************************


CWQLParser::~CWQLParser()
{
    Empty();
    delete m_pLexer;
}

//***************************************************************************
//
//***************************************************************************

void CWQLParser::Empty()
{
    m_aReferencedTables.Empty();
    m_aReferencedAliases.Empty();

    m_pTokenText = 0;   // We don't delete this, it was never allocated
    m_nLine = 0;
    m_nCurrentToken = 0;
    m_dwFeaturesFlags = 0;

    delete m_pQueryRoot;
    m_pQueryRoot = 0;
    m_pRootWhere = 0;
    m_pRootColList = 0;
    m_pRootFrom = 0;
    m_pRootWhereOptions = 0;
    m_nParseContext = Ctx_Default;


    // For the next two, we don't delete the pointers since they
    // were copies of structs elsewhere in the tree.
    // =========================================================
    m_aSelAliases.Empty();
    m_aSelColumns.Empty();
}

//***************************************************************************
//
//  CWQLParser::GetTokenLong
//
//  Converts the current token to a long int.
//
//***************************************************************************

LONG CWQLParser::GetTokenLong()
{
    char buf[64];
    sprintf(buf, "%S", m_pTokenText);
    return atol(buf);
}

//***************************************************************************
//
//  CWQLParser::GetReferencedTables
//
//  Creates an array of the names of the tables referenced in this query
//
//***************************************************************************

BOOL CWQLParser::GetReferencedTables(OUT CWStringArray& Tables)
{
    Tables = m_aReferencedTables;
    return TRUE;
}


BOOL CWQLParser::GetReferencedAliases(OUT CWStringArray & Aliases)
{
    Aliases = m_aReferencedAliases;
    return TRUE;
}

//***************************************************************************
//
//  Next()
//
//  Advances to the next token and recognizes keywords, etc.
//
//***************************************************************************

struct WqlKeyword
{
    LPWSTR m_pKeyword;
    int    m_nTokenCode;
};

static WqlKeyword KeyWords[] =      // Keep this alphabetized for binary search
{
    L"A",        WQL_TOK_A,
    L"AGGREGATE",WQL_TOK_AGGREGATE,
    L"ALL",      WQL_TOK_ALL,
    L"AND",      WQL_TOK_AND,
    L"AS",       WQL_TOK_AS,
    L"ASC",      WQL_TOK_ASC,
    L"BETWEEN",  WQL_TOK_BETWEEN,
    L"BY",       WQL_TOK_BY,
    L"COUNT",    WQL_TOK_COUNT,
    L"DATEPART", WQL_TOK_DATEPART,
    L"DESC",     WQL_TOK_DESC,
    L"DISTINCT", WQL_TOK_DISTINCT,
    L"FIRSTROW", WQL_TOK_FIRSTROW,
    L"FROM",     WQL_TOK_FROM,
    L"FULL",     WQL_TOK_FULL,
    L"GROUP",    WQL_TOK_GROUP,
    L"HAVING",   WQL_TOK_HAVING,
    L"IN",       WQL_TOK_IN,
    L"INNER",    WQL_TOK_INNER,
    L"IS",       WQL_TOK_IS,
    L"ISA",      WQL_TOK_ISA,
    L"ISNULL",   WQL_TOK_ISNULL,
    L"JOIN",     WQL_TOK_JOIN,
    L"LEFT",     WQL_TOK_LEFT,
    L"LIKE",     WQL_TOK_LIKE,
    L"LOWER",    WQL_TOK_LOWER,
    L"NOT",      WQL_TOK_NOT,
    L"NULL",     WQL_TOK_NULL,
    L"ON",       WQL_TOK_ON,
    L"OR",       WQL_TOK_OR,
    L"ORDER",    WQL_TOK_ORDER,
    L"OUTER",    WQL_TOK_OUTER,
    L"QUALIFIER", WQL_TOK_QUALIFIER,
    L"RIGHT",    WQL_TOK_RIGHT,
    L"SELECT",   WQL_TOK_SELECT,
    L"UPPER",    WQL_TOK_UPPER,
    L"WHERE",    WQL_TOK_WHERE
};

const int NumKeywords = sizeof(KeyWords)/sizeof(WqlKeyword);

BOOL CWQLParser::Next()
{
    m_nCurrentToken = m_pLexer->NextToken();
    if (m_nCurrentToken == WQL_TOK_ERROR
        || (m_nCurrentToken == WQL_TOK_PROMPT && !m_bAllowPromptForConstant))
        return FALSE;

    m_nLine = m_pLexer->GetLineNum();
    m_pTokenText = m_pLexer->GetTokenText();
    if (m_nCurrentToken == WQL_TOK_EOF)
        m_pTokenText = L"<end of file>";

    // Keyword check. Do a binary search
    // on the keyword table.
    // =================================

    if (m_nCurrentToken == WQL_TOK_IDENT)
    {
        int l = 0, u = NumKeywords - 1;

        while (l <= u)
        {
            int m = (l + u) / 2;
            if (_wcsicmp(m_pTokenText, KeyWords[m].m_pKeyword) < 0)
                u = m - 1;
            else if (_wcsicmp(m_pTokenText, KeyWords[m].m_pKeyword) > 0)
                l = m + 1;
            else        // Match
            {
                m_nCurrentToken = KeyWords[m].m_nTokenCode;
                break;
            }
        }
    }

    return TRUE;
}


//***************************************************************************
//
//  <parse> ::= SELECT <select_stmt>;
//
//***************************************************************************

int CWQLParser::Parse()
{
    Empty();

    SWQLNode_Select *pSel = 0;
    int nRes = SYNTAX_ERROR;

    m_pLexer->Reset();

    if (!Next())
        return LEXICAL_ERROR;

    if (m_nCurrentToken == WQL_TOK_SELECT)
    {
        if (!Next())
            return LEXICAL_ERROR;
        nRes = select_stmt(&pSel);
    }

    // cleanup...


    // If here, not a legal starter symbol.
    // ====================================

    m_pQueryRoot = pSel;

    return nRes;
}

//***************************************************************************
//
//  <select_stmt> ::=
//      <select_type>
//      <col_ref_list>
//      <from_clause>
//      <where_clause>
//
//***************************************************************************
// ...

int CWQLParser::select_stmt(OUT SWQLNode_Select **pSelStmt)
{
    int nRes = 0;
    int nType = 0;
    SWQLNode_FromClause *pFrom = 0;
    SWQLNode_Select *pSel = 0;
    SWQLNode_TableRefs *pTblRefs = 0;
    SWQLNode_WhereClause *pWhere = 0;

    *pSelStmt = 0;

    // Set up the basic AST.
    // =====================

    pSel = new SWQLNode_Select;
    pTblRefs = new SWQLNode_TableRefs;
    pSel->m_pLeft = pTblRefs;

    // Get the select type.
    // ====================

    nRes = select_type(nType);
    if (nRes)
        goto Exit;

    pTblRefs->m_nSelectType = nType;        // ALL, DISTINCT

    // Get the selected list of columns.
    // =================================

    nRes = col_ref_list(pTblRefs);
    if (nRes)
        goto Exit;

    m_pRootColList = (SWQLNode_ColumnList *) pTblRefs->m_pLeft;

    // Get the FROM clause and patch it into the AST.
    // ===============================================

    nRes = from_clause(&pFrom);
    if (nRes)
        goto Exit;

    m_pRootFrom = pFrom;
    pTblRefs->m_pRight = pFrom;

    // Get the WHERE clause.
    // =====================

    nRes = where_clause(&pWhere);
    if (nRes)
        goto Exit;

    m_pRootWhere = pWhere;
    pSel->m_pRight = pWhere;

    // Verify we are at the end of the query.
    // ======================================

    if (m_nCurrentToken != WQL_TOK_EOF)
    {
        nRes = SYNTAX_ERROR;
        goto Exit;
    }

    nRes = NO_ERROR;

Exit:
    if (nRes)
        delete pSel;
    else
    {
        *pSelStmt = pSel;
    }

    return nRes;
}



//***************************************************************************
//
//  <select_type> ::= ALL;
//  <select_type> ::= DISTINCT;
//  <select_type> ::= <>;
//
//  Returns type through nSelType :
//      WQL_TOK_ALL or WQL_TOK_DISTINCT
//
//***************************************************************************
// done

int CWQLParser::select_type(int & nSelType)
{
    nSelType = WQL_FLAG_ALL;        // Default

    if (m_nCurrentToken == WQL_TOK_ALL)
    {
        nSelType = WQL_FLAG_ALL;
        if (!Next())
            return LEXICAL_ERROR;
        return NO_ERROR;
    }

    if (m_nCurrentToken == WQL_TOK_DISTINCT)
    {
        nSelType = WQL_FLAG_DISTINCT;
        if (!Next())
            return LEXICAL_ERROR;
        return NO_ERROR;
    }

    if (m_nCurrentToken == WQL_TOK_AGGREGATE)
    {
        nSelType = WQL_FLAG_AGGREGATE;
        if (!Next())
            return LEXICAL_ERROR;
        return NO_ERROR;
    }

    return NO_ERROR;
}

//***************************************************************************
//
//  <col_ref_list> ::= <col_ref> <col_ref_rest>;
//  <col_ref_list> ::= ASTERISK;
//  <col_ref_list> ::= COUNT <count_clause>;
//
//***************************************************************************

int CWQLParser::col_ref_list(
    IN OUT SWQLNode_TableRefs *pTblRefs
    )
{
    int nRes;
    DWORD dwFuncFlags = 0;

    // Allocate a new left node of type SWQLNode_ColumnList and patch it in
    // if it doesn't already exist.
    // =====================================================================

    SWQLNode_ColumnList *pColList = (SWQLNode_ColumnList *) pTblRefs->m_pLeft;

    if (pColList == NULL)
    {
        pColList = new SWQLNode_ColumnList;
        pTblRefs->m_pLeft = pColList;
    }


    // If here, it is a "select *..." query.
    // =====================================

    if (m_nCurrentToken == WQL_TOK_ASTERISK)
    {
        // Allocate a new column list which has a single asterisk.
        // =======================================================

        SWQLColRef *pColRef = new SWQLColRef;
        pColRef->m_pColName = Macro_CloneLPWSTR(L"*");
        pColRef->m_dwFlags = WQL_FLAG_ASTERISK;
        pColList->m_aColumnRefs.Add(pColRef);

        if (!Next())
            return LEXICAL_ERROR;

        return NO_ERROR;
    }

    // If here, we have a "select COUNT..." operation.
    // ===============================================

    if (m_nCurrentToken == WQL_TOK_COUNT)
    {
        if (!Next())
            return LEXICAL_ERROR;

        pTblRefs->m_nSelectType |= WQL_FLAG_COUNT;

        SWQLQualifiedName *pQN = 0;
        nRes = count_clause(&pQN);

        // Now build up the column reference.
        // ==================================

        if (nRes)
            return nRes;

        SWQLColRef *pCR = 0;
        nRes = QNameToSWQLColRef(pQN, &pCR);
        pColList->m_aColumnRefs.Add(pCR);

        return NO_ERROR;
    }

    // Make a provision for wrapping the
    // column in a function all UPPER or LOWER
    // =======================================

    if (m_nCurrentToken == WQL_TOK_UPPER)
        dwFuncFlags = WQL_FLAG_FUNCTIONIZED | WQL_FLAG_UPPER;
    else if (m_nCurrentToken == WQL_TOK_LOWER)
        dwFuncFlags = WQL_FLAG_FUNCTIONIZED | WQL_FLAG_LOWER;

    if (dwFuncFlags)
    {
        // Common procedure for cases where UPPER or LOWER are used.

        if (!Next())
            return LEXICAL_ERROR;

        if (m_nCurrentToken != WQL_TOK_OPEN_PAREN)
            return SYNTAX_ERROR;

        if (!Next())
            return LEXICAL_ERROR;
    }


    // If here, must be an identifier.
    // ===============================

    if (m_nCurrentToken != WQL_TOK_IDENT)
        return SYNTAX_ERROR;

    SWQLQualifiedName *pInitCol = 0;

    nRes = col_ref(&pInitCol);
    if (nRes)
        return nRes;

    SWQLColRef *pCR = 0;
    nRes = QNameToSWQLColRef(pInitCol, &pCR);

    pCR->m_dwFlags |= dwFuncFlags;

    if (dwFuncFlags)
    {
        // If a function call was invoked, remove the trailing paren.
        // ==========================================================

        if (m_nCurrentToken != WQL_TOK_CLOSE_PAREN)
            return SYNTAX_ERROR;

        if (!Next())
            return LEXICAL_ERROR;
    }

    pColList->m_aColumnRefs.Add(pCR);

    return col_ref_rest(pTblRefs);
}


//***************************************************************************
//
//  <count_clause> ::= OPEN_PAREN <count_col> CLOSE_PAREN;
//  <count_col> ::= ASTERISK;
//  <count_col> ::= IDENT;
//
//  On NO_ERROR returns:
//  <bAsterisk> set to TRUE if a * occurred in the COUNT clause,
//  or <bAsterisk> set to FALSE and <pQualName> set to point to the
//  qualified name of the column referenced.
//
//***************************************************************************
// done

int CWQLParser::count_clause(
    OUT SWQLQualifiedName **pQualName
    )
{
    int nRes;
    *pQualName = 0;

    // Syntax check.
    // =============
    if (m_nCurrentToken != WQL_TOK_OPEN_PAREN)
        return SYNTAX_ERROR;

    if (!Next())
        return LEXICAL_ERROR;

    // Determine whether an asterisk was used COUNT(*) or
    // a col-ref COUNT(col-ref)
    // ==================================================

    if (m_nCurrentToken == WQL_TOK_ASTERISK)
    {
        SWQLQualifiedName *pQN = new SWQLQualifiedName;
        SWQLQualifiedNameField *pQF = new SWQLQualifiedNameField;
        pQF->m_pName = Macro_CloneLPWSTR(L"*");
        pQN->Add(pQF);
        *pQualName = pQN;
        if (!Next())
            return LEXICAL_ERROR;
    }
    else if (m_nCurrentToken == WQL_TOK_IDENT)
    {
        SWQLQualifiedName *pQN = 0;
        nRes = col_ref(&pQN);
        if (nRes)
            return nRes;
        *pQualName = pQN;
    }

    // Check for errors in syntax and clean up
    // if so.
    // =======================================

    if (m_nCurrentToken != WQL_TOK_CLOSE_PAREN)
    {
        if (*pQualName)
            delete *pQualName;
        *pQualName = 0;
        return SYNTAX_ERROR;
    }

    if (!Next())
    {
        if (*pQualName)
            delete *pQualName;
        *pQualName = 0;
        return LEXICAL_ERROR;
    }

    return NO_ERROR;
}


//***************************************************************************
//
//  <col_ref_rest> ::= COMMA <col_ref_list>;
//  <col_ref_rest> ::= <>;
//
//***************************************************************************

int CWQLParser::col_ref_rest(IN OUT SWQLNode_TableRefs *pTblRefs)
{
    int nRes;

    if (m_nCurrentToken != WQL_TOK_COMMA)
        return NO_ERROR;
    if (!Next())
        return LEXICAL_ERROR;

    nRes = col_ref_list(pTblRefs);
    return nRes;
}

//***************************************************************************
//
//  <from_clause> ::= <table_list>;
//
//  <table_list> ::= <single_table_decl> <optional_join>;
//
//  <optional_join> ::= <sql89_join_entry>;
//  <optional_join> ::= <sql92_join_entry>;
//
//  <optional_join> ::= <>;     // Unary query
//
//***************************************************************************

int CWQLParser::from_clause(OUT SWQLNode_FromClause **pFrom)
{
    int nRes = 0;
    SWQLNode_TableRef *pTbl = 0;
    SWQLNode_FromClause *pFC = new SWQLNode_FromClause;

    if (m_nCurrentToken != WQL_TOK_FROM)
        return SYNTAX_ERROR;
    if (!Next())
        return LEXICAL_ERROR;

    nRes = single_table_decl(&pTbl);
    if (nRes)
        return nRes;

    // Check for joins.
    // ===============

    if (m_nCurrentToken == WQL_TOK_COMMA)
    {
        SWQLNode_Sql89Join *pJoin = 0;
        nRes = sql89_join_entry(pTbl, &pJoin);
        if (nRes)
            return nRes;
        pFC->m_pLeft = pJoin;
    }
    else
    {

        if (m_nCurrentToken == WQL_TOK_INNER ||
            m_nCurrentToken == WQL_TOK_FULL  ||
            m_nCurrentToken == WQL_TOK_LEFT  ||
            m_nCurrentToken == WQL_TOK_RIGHT ||
            m_nCurrentToken == WQL_TOK_JOIN
            )
        {
            SWQLNode_Join *pJoin = 0;
            nRes = sql92_join_entry(pTbl, &pJoin);
            if (nRes)
                return nRes;
            pFC->m_pLeft = pJoin;
        }

        // Single table select (unary query).
        // ==================================
        else
        {
            pFC->m_pLeft = pTbl;
        }
    }

    *pFrom = pFC;

    return NO_ERROR;
}


//***************************************************************************
//
//  <sql89_join_entry> ::= COMMA <sql89_join_list>;
//
//***************************************************************************


int CWQLParser::sql89_join_entry(IN  SWQLNode_TableRef *pInitialTblRef,
        OUT SWQLNode_Sql89Join **pJoin )
{
    if (m_nCurrentToken != WQL_TOK_COMMA)
        return SYNTAX_ERROR;

    if (!Next())
        return LEXICAL_ERROR;

    return sql89_join_list(pInitialTblRef, pJoin);
}

//***************************************************************************
//
//  <sql89_join_list> ::= <single_table_decl> <sql89_join_rest>;
//
//  <sql89_join_rest> ::= COMMA <sql89_join_list>;
//  <sql89_join_rest> ::= <>;
//
//***************************************************************************

int CWQLParser::sql89_join_list(IN  SWQLNode_TableRef *pInitialTblRef,
        OUT SWQLNode_Sql89Join **pJoin )
{
    int nRes;

    SWQLNode_Sql89Join *p89Join = new SWQLNode_Sql89Join;
    p89Join->m_aValues.Add(pInitialTblRef);

    while (1)
    {
        SWQLNode_TableRef *pTR = 0;
        nRes = single_table_decl(&pTR);
        if (nRes)
            return nRes;
        p89Join->m_aValues.Add(pTR);
        if (m_nCurrentToken != WQL_TOK_COMMA)
            break;
        if (!Next())
            return LEXICAL_ERROR;
    }

    *pJoin = p89Join;

    return NO_ERROR;
}

//***************************************************************************
//
//  <where_clause> ::= WQL_TOK_WHERE <rel_expr> <where_options>;
//  <where_clause> ::= <>;          // 'where' is not required
//
//***************************************************************************
// done

int CWQLParser::where_clause(OUT SWQLNode_WhereClause **pRetWhere)
{
    SWQLNode_WhereClause *pWhere = new SWQLNode_WhereClause;
    *pRetWhere = pWhere;
    SWQLNode_RelExpr *pRelExpr = 0;
    int nRes;

    // 'where' is optional.
    // ====================

    if (m_nCurrentToken == WQL_TOK_WHERE)
    {
        if (!Next())
            return LEXICAL_ERROR;

        // Get the primary relational expression for the 'where' clause.
        // =============================================================
        nRes = rel_expr(&pRelExpr);
        if (nRes)
        {
            delete pRelExpr;
            return nRes;
        }

        // Get the options, such as ORDER BY, GROUP BY, etc.
        // =================================================
    }

    SWQLNode_WhereOptions *pWhereOpt = 0;
    nRes = where_options(&pWhereOpt);
    if (nRes)
    {
        delete pRelExpr;
        delete pWhereOpt;
        return nRes;
    }

    pWhere->m_pLeft = pRelExpr;
    pWhere->m_pRight = pWhereOpt;
    m_pRootWhereOptions = pWhereOpt;

    return NO_ERROR;
}

//***************************************************************************
//
//  <where_options> ::=
//      <group_by_clause>
//      <order_by_clause>
//
//***************************************************************************
// done

int CWQLParser::where_options(OUT SWQLNode_WhereOptions **pRetWhereOpt)
{
    int nRes;
    *pRetWhereOpt = 0;

    SWQLNode_GroupBy *pGroupBy = 0;
    nRes = group_by_clause(&pGroupBy);
    if (nRes)
    {
        delete pGroupBy;
        return nRes;
    }

    SWQLNode_OrderBy *pOrderBy = 0;
    nRes = order_by_clause(&pOrderBy);
    if (nRes)
    {
        delete pOrderBy;
        delete pGroupBy;
        return nRes;
    }

    SWQLNode_WhereOptions *pWhereOpt = 0;

    if (pGroupBy || pOrderBy)
    {
        pWhereOpt = new SWQLNode_WhereOptions;
        pWhereOpt->m_pLeft = pGroupBy;
        pWhereOpt->m_pRight = pOrderBy;
    }

    *pRetWhereOpt = pWhereOpt;
    return NO_ERROR;
}


//***************************************************************************
//
//  <group_by_clause> ::= WQL_TOK_GROUP WQL_TOK_BY <col_list> <having_clause>;
//  <group_by_clause> ::= <>;
//
//***************************************************************************
// done

int CWQLParser::group_by_clause(OUT SWQLNode_GroupBy **pRetGroupBy)
{
    int nRes;
    *pRetGroupBy = 0;

    if (m_nCurrentToken != WQL_TOK_GROUP)
        return NO_ERROR;
    if (!Next())
        return LEXICAL_ERROR;
    if (m_nCurrentToken != WQL_TOK_BY)
        return SYNTAX_ERROR;
    if (!Next())
        return LEXICAL_ERROR;

    // Get the guts of the GROUP BY.
    // =============================

    SWQLNode_GroupBy *pGroupBy = new SWQLNode_GroupBy;
    SWQLNode_ColumnList *pColList = 0;

    nRes = col_list(&pColList);
    if (nRes)
    {
        delete pGroupBy;
        delete pColList;
        return nRes;
    }

    pGroupBy->m_pLeft = pColList;

    // Check for the HAVING clause.
    // ============================
    SWQLNode_Having *pHaving = 0;
    nRes = having_clause(&pHaving);

    if (pHaving)
        pGroupBy->m_pRight = pHaving;

    *pRetGroupBy = pGroupBy;
    return NO_ERROR;
}

//***************************************************************************
//
//  <having_clause> ::= WQL_TOK_HAVING <rel_expr>;
//  <having_clause> ::= <>;
//
//***************************************************************************
// done

int CWQLParser::having_clause(OUT SWQLNode_Having **pRetHaving)
{
    int nRes;
    *pRetHaving = 0;

    if (m_nCurrentToken != WQL_TOK_HAVING)
        return NO_ERROR;

    if (!Next())
        return LEXICAL_ERROR;

    // If here, we have a HAVING clause.
    // =================================

    SWQLNode_RelExpr *pRelExpr = 0;
    nRes = rel_expr(&pRelExpr);
    if (nRes)
    {
        delete pRelExpr;
        return nRes;
    }

    SWQLNode_Having *pHaving = new SWQLNode_Having;
    pHaving->m_pLeft = pRelExpr;

    *pRetHaving = pHaving;

    return NO_ERROR;
}

//***************************************************************************
//
//  <order_by_clause> ::= WQL_TOK_ORDER WQL_TOK_BY <col_list>;
//  <order_by_clause> ::= <>;
//
//***************************************************************************
//  done

int CWQLParser::order_by_clause(OUT SWQLNode_OrderBy **pRetOrderBy)
{
    int nRes;

    if (m_nCurrentToken != WQL_TOK_ORDER)
        return NO_ERROR;
    if (!Next())
        return LEXICAL_ERROR;
    if (m_nCurrentToken != WQL_TOK_BY)
        return SYNTAX_ERROR;
    if (!Next())
        return LEXICAL_ERROR;

    // If here, we have an ORDER BY clause.
    // ====================================

    SWQLNode_ColumnList *pColList = 0;
    nRes = col_list(&pColList);
    if (nRes)
    {
        delete pColList;
        return nRes;
    }

    SWQLNode_OrderBy *pOrderBy = new SWQLNode_OrderBy;
    pOrderBy->m_pLeft = pColList;
    *pRetOrderBy = pOrderBy;

    return NO_ERROR;
}

//***************************************************************************
//
//  <single_table_decl> ::= <unbound_table_ident> <table_decl_rest>;
//
//  <unbound_table_ident> ::= IDENT;
//  <table_decl_rest> ::= <redundant_as> <table_alias>;
//  <table_decl_rest> ::= <>;
//  <table_alias> ::= IDENT;
//
//  <redundant_as> ::= AS;
//  <redundant_as> ::= <>;
//
//***************************************************************************
// done; no cleanup

int CWQLParser::single_table_decl(OUT SWQLNode_TableRef **pTblRef)
{
    if (pTblRef == 0)
        return INTERNAL_ERROR;

    *pTblRef = 0;

    if (m_nCurrentToken != WQL_TOK_IDENT)
        return SYNTAX_ERROR;

    SWQLNode_TableRef *pTR = new SWQLNode_TableRef;
    pTR->m_pTableName = Macro_CloneLPWSTR(m_pTokenText);

    m_aReferencedTables.Add(m_pTokenText);

    if (!Next())
        return LEXICAL_ERROR;

    if (m_nCurrentToken == WQL_TOK_AS)
    {
        // Here we have a redundant AS and an alias.
        // =========================================
        if (!Next())
            return LEXICAL_ERROR;
    }

    if (m_nCurrentToken == WQL_TOK_IDENT &&
        _wcsicmp(L"FIRSTROW", m_pTokenText) != 0
       )
    {
        // Alias name
        // ==========
        pTR->m_pAlias = Macro_CloneLPWSTR(m_pTokenText);
        m_aReferencedAliases.Add(m_pTokenText);
        if (!Next())
            return LEXICAL_ERROR;
    }

    // If no Alias was used, we simply copy the table name into
    // the alias slot.
    // ========================================================
    else
    {
        pTR->m_pAlias = Macro_CloneLPWSTR(pTR->m_pTableName);
        m_aReferencedAliases.Add(pTR->m_pTableName);
    }

    // For the primary select, we are keeping a list of tables
    // we are selecting from.
    // =======================================================

    if ((m_nParseContext & Ctx_Subselect) == 0)
        m_aSelAliases.Add(pTR);

    // Return the pointer to the caller.
    // =================================

    *pTblRef = pTR;

    return NO_ERROR;
}



//***************************************************************************
//
//  SQL-92 Joins.
//
//  We support:
//  1. [INNER] JOIN
//  2. LEFT [OUTER] JOIN
//  3. RIGHT [OUTER] JOIN
//  4. FULL [OUTER] JOIN
//
//
//  <sql92_join_entry> ::= <simple_join_clause>;
//  <sql92_join_entry> ::= INNER <simple_join_clause>;
//  <sql92_join_entry> ::= FULL <opt_outer> <simple_join_clause>;
//  <sql92_join_entry> ::= LEFT <opt_outer> <simple_join_clause>;
//  <sql92_join_entry> ::= RIGHT <opt_outer> <simple_join_clause>;
//
//  <opt_outer> ::= WQL_TOK_OUTER;
//  <opt_outer> ::= <>;
//
//  <simple_join_clause> ::=
//    JOIN
//    <single_table_decl>
//    <on_clause>
//    <sql92_join_continuator>
//
//  <sql92_join_continuator> ::= <sql92_join_entry>;
//  <sql92_join_continuator> ::= <>;
//
//***************************************************************************

int CWQLParser::sql92_join_entry(
    IN  SWQLNode_TableRef *pInitialTblRef,      // inherited
    OUT SWQLNode_Join **pJoin                   // synthesized
    )
{
    int nRes;

    /* Build a nested join tree bottom up.  Currently, the tree is always left-heavy:

            JN = Join Noe
            JP = Join Pair
            OC = On Clause
            TR = Table Ref

                   JN
                  /  \
                JP    OC
               /  \
             JN    TR
            /   \
          JP     OC
         /  \
        TR   TR
    */

    // State 1: Attempting to build a new JOIN node.
    // =============================================

    SWQLNode *pCurrentLeftNode = pInitialTblRef;
    SWQLNode_Join *pJN = 0;

    while (1)
    {
        pJN = new SWQLNode_Join;

        // Join-type.
        // ==========

        pJN->m_dwJoinType = WQL_FLAG_INNER_JOIN;    // Default

        if (m_nCurrentToken == WQL_TOK_INNER)
        {
            if (!Next())
                return LEXICAL_ERROR;
            pJN->m_dwJoinType = WQL_FLAG_INNER_JOIN;
        }
        else if (m_nCurrentToken == WQL_TOK_FULL)
        {
            if (!Next())
                return LEXICAL_ERROR;
            if (m_nCurrentToken == WQL_TOK_OUTER)
                if (!Next())
                    return LEXICAL_ERROR;
            pJN->m_dwJoinType = WQL_FLAG_FULL_OUTER_JOIN;
        }
        else if (m_nCurrentToken == WQL_TOK_LEFT)
        {
            if (!Next())
                return LEXICAL_ERROR;
            if (m_nCurrentToken == WQL_TOK_OUTER)
                if (!Next())
                    return LEXICAL_ERROR;
            pJN->m_dwJoinType = WQL_FLAG_LEFT_OUTER_JOIN;
        }
        else if (m_nCurrentToken == WQL_TOK_RIGHT)
        {
            if (!Next())
                return LEXICAL_ERROR;
            if (m_nCurrentToken == WQL_TOK_OUTER)
                if (!Next())
                    return LEXICAL_ERROR;
            pJN->m_dwJoinType = WQL_FLAG_RIGHT_OUTER_JOIN;
        }

        // <simple_join_clause>
        // =====================

        if (m_nCurrentToken != WQL_TOK_JOIN)
        {
            return SYNTAX_ERROR;
        }

        if (!Next())
            return LEXICAL_ERROR;

        SWQLNode_JoinPair *pJP = new SWQLNode_JoinPair;

        // Determine the table to which to join.
        // =====================================

        SWQLNode_TableRef *pTR = 0;
        nRes = single_table_decl(&pTR);
        if (nRes)
            return nRes;

        pJP->m_pRight = pTR;
        pJP->m_pLeft = pCurrentLeftNode;
        pCurrentLeftNode = pJN;

        // If FIRSTROW is used, add it in.
        // ===============================

        if (m_nCurrentToken == WQL_TOK_IDENT)
        {
            if (_wcsicmp(L"FIRSTROW", m_pTokenText) != 0)
                return SYNTAX_ERROR;
            pJN->m_dwFlags |= WQL_FLAG_FIRSTROW;
            if (!Next())
                return LEXICAL_ERROR;
        }

        // Get the ON clause.
        // ==================
        SWQLNode_OnClause *pOC = 0;

        nRes = on_clause(&pOC);
        if (nRes)
            return nRes;

        pJN->m_pRight = pOC;    // On clause
        pJN->m_pLeft  = pJP;

        // sql92_join_continuator();
        // =========================

        if (m_nCurrentToken == WQL_TOK_INNER ||
            m_nCurrentToken == WQL_TOK_FULL  ||
            m_nCurrentToken == WQL_TOK_LEFT  ||
            m_nCurrentToken == WQL_TOK_RIGHT ||
            m_nCurrentToken == WQL_TOK_JOIN
            )
            continue;

        break;
    }

    // Return the join node to the caller.
    // ====================================

    *pJoin = pJN;

    return NO_ERROR;
}


//***************************************************************************
//
//  <on_clause> ::= ON <rel_expr>;
//
//***************************************************************************

int CWQLParser::on_clause(OUT SWQLNode_OnClause **pOC)
{
    if (m_nCurrentToken != WQL_TOK_ON)
        return SYNTAX_ERROR;

    if (!Next())
        return LEXICAL_ERROR;

    SWQLNode_OnClause *pNewOC = new SWQLNode_OnClause;
    SWQLNode_RelExpr *pRelExpr = 0;
    int nRes = rel_expr(&pRelExpr);
    if (nRes)
        return nRes;

    pNewOC->m_pLeft = pRelExpr;
    *pOC = pNewOC;

    return NO_ERROR;
}

//***************************************************************************
//
//  <rel_expr> ::= <rel_term> <rel_expr2>;
//
//  We are creating a new expression or subexpression each time
//  we enter this recursively.   No inherited attributes are
//  propagated to this production.
//
//***************************************************************************

int CWQLParser::rel_expr(OUT SWQLNode_RelExpr **pRelExpr)
{
    int nRes;
    *pRelExpr = 0;

    // Get the new node.  This becomes a temporary root.
    // =================================================

    SWQLNode_RelExpr *pRE = 0;
    nRes = rel_term(&pRE);
    if (nRes)
        return nRes;

    // At this point, we have a possible root.  If
    // there are OR operations, the root will be
    // replaced by the next function.  Otherwise,
    // the call will pass through pRE into pNewRoot.
    // =============================================

    SWQLNode_RelExpr *pNewRoot = 0;
    nRes = rel_expr2(pRE, &pNewRoot);
    if (nRes)
        return nRes;

    // Return the expression to the caller.
    // ====================================

    *pRelExpr = pNewRoot;
    return NO_ERROR;
}



//***************************************************************************
//
//  <rel_expr2> ::= OR <rel_term> <rel_expr2>;
//  <rel_expr2> ::= <>;
//
//***************************************************************************
// done!

int CWQLParser::rel_expr2(
    IN OUT SWQLNode_RelExpr *pLeftSide,
    OUT SWQLNode_RelExpr **pNewRootRE
    )
{
    int nRes;
    *pNewRootRE = pLeftSide;            // Default for the nullable production

    while (1)
    {
        // Build a series of OR subtrees bottom-up.  We use iteration
        // and pointer juggling to simulate recursion.
        // ============================================================

        if (m_nCurrentToken == WQL_TOK_OR)
        {
            if (!Next())
                return LEXICAL_ERROR;

            SWQLNode_RelExpr *pNewRoot = new SWQLNode_RelExpr;
            pNewRoot->m_dwExprType = WQL_TOK_OR;
            pNewRoot->m_pLeft = pLeftSide;
            pLeftSide = pNewRoot;
            *pNewRootRE = pNewRoot;     // Communicate this fact to the caller

            SWQLNode_RelExpr *pRight = 0;

            if (nRes = rel_term(&pRight))
                return nRes;

            pNewRoot->m_pRight = pRight;
            // Right node becomes the new subexpr
        }
        else break;
    }

    return NO_ERROR;
}


//***************************************************************************
//
//  <rel_term> ::= <rel_simple_expr> <rel_term2>;
//
//***************************************************************************
// done!

int CWQLParser::rel_term(
    OUT SWQLNode_RelExpr **pNewTerm
    )
{
    int nRes;

    SWQLNode_RelExpr *pNewSimple = 0;
    if (nRes = rel_simple_expr(&pNewSimple))
        return nRes;

    SWQLNode_RelExpr *pNewRoot = 0;
    if (nRes = rel_term2(pNewSimple, &pNewRoot))
        return nRes;

    *pNewTerm = pNewRoot;

    return NO_ERROR;
}



//***************************************************************************
//
//  <rel_term2> ::= AND <rel_simple_expr> <rel_term2>;
//  <rel_term2> ::= <>;
//
//***************************************************************************
// done!

int CWQLParser::rel_term2(
    IN SWQLNode_RelExpr *pLeftSide,                 // Inherited
    OUT SWQLNode_RelExpr **pNewRootRE       // Synthesized
    )
{
    int nRes;
    *pNewRootRE = pLeftSide;            // Default for the nullable production

    while (1)
    {
        // Build a series of AND subtrees bottom-up.  We use iteration
        // and pointer juggling to simulate recursion.
        // ============================================================

        if (m_nCurrentToken == WQL_TOK_AND)
        {
            if (!Next())
                return LEXICAL_ERROR;

            SWQLNode_RelExpr *pNewRoot = new SWQLNode_RelExpr;
            pNewRoot->m_dwExprType = WQL_TOK_AND;
            pNewRoot->m_pLeft = pLeftSide;
            pLeftSide = pNewRoot;
            *pNewRootRE = pNewRoot;     // Communicate this fact to the caller

            SWQLNode_RelExpr *pRight = 0;
            if (nRes = rel_simple_expr(&pRight))
                return nRes;

            pNewRoot->m_pRight = pRight;
        }
        else break;
    }

    return NO_ERROR;
}


//***************************************************************************
//
//  <rel_simple_expr> ::= NOT <rel_expr>;
//  <rel_simple_expr> ::= OPEN_PAREN <rel_expr> CLOSE_PAREN;
//  <rel_simple_expr> ::= <typed_expr>;
//
//***************************************************************************
// done!

int CWQLParser::rel_simple_expr(OUT SWQLNode_RelExpr **pRelExpr)
{
    int nRes;
    *pRelExpr = 0;  // Default

    // NOT <rel_expr>
    // ==============
    if (m_nCurrentToken == WQL_TOK_NOT)
    {
        if (!Next())
            return LEXICAL_ERROR;

        // Allocate a NOT root and place the NOTed subexpr
        // under it.
        // ===============================================

        SWQLNode_RelExpr *pNotRoot = new SWQLNode_RelExpr;
        pNotRoot->m_dwExprType = WQL_TOK_NOT;

        SWQLNode_RelExpr *pRelSubExpr = 0;
        if (nRes = rel_expr(&pRelSubExpr))
            return nRes;

        pNotRoot->m_pLeft = pRelSubExpr;
        pNotRoot->m_pRight = NULL;   // intentional
        *pRelExpr = pNotRoot;

        return NO_ERROR;
    }

    // OPEN_PAREN <rel_expr> CLOSE_PAREN
    // =================================
    else if (m_nCurrentToken == WQL_TOK_OPEN_PAREN)
    {
        if (!Next())
            return LEXICAL_ERROR;

        SWQLNode_RelExpr *pSubExpr = 0;
        if (rel_expr(&pSubExpr))
            return SYNTAX_ERROR;

        if (m_nCurrentToken != WQL_TOK_CLOSE_PAREN)
            return SYNTAX_ERROR;

        if (!Next())
            return LEXICAL_ERROR;

        *pRelExpr = pSubExpr;

        return NO_ERROR;
    }

    // <typed_expr>
    // ============

    SWQLNode_RelExpr *pSubExpr = 0;
    nRes = typed_expr(&pSubExpr);
    if (nRes)
        return nRes;
    *pRelExpr = pSubExpr;

    return NO_ERROR;
}

//***************************************************************************
//
//  <typed_expr> ::= <typed_subexpr> <rel_op> <typed_subexpr_rh>;
//
//***************************************************************************
// done

int CWQLParser::typed_expr(OUT SWQLNode_RelExpr **pRelExpr)
{
    int nRes;

    // Allocate a node for this typed expression.
    // There are no possible child nodes, so <pRelExpr> this becomes
    // a synthesized attribute.
    // =============================================================

    SWQLNode_RelExpr *pRE = new SWQLNode_RelExpr;
    pRE->m_dwExprType = WQL_TOK_TYPED_EXPR;
    *pRelExpr = pRE;

    SWQLTypedExpr *pTE = new SWQLTypedExpr;

    // Look at the left hand side.
    // ===========================
    nRes = typed_subexpr(pTE);
    if (nRes)
        return nRes;

    int nOperator;

    // Get the operator.
    // =================
    nRes = rel_op(nOperator);
    if (nRes)
        return nRes;

    pTE->m_dwRelOperator = DWORD(nOperator);


    if (nOperator == WQL_TOK_ISNULL || nOperator == WQL_TOK_NOT_NULL)
    {
        pRE->m_pTypedExpr = pTE;
        return NO_ERROR;
    }

    // Get the right-hand side.
    // ========================
    nRes = typed_subexpr_rh(pTE);
    if (nRes)
        return nRes;


    // Check for IN, NOT IN and a const-list, to change the operator
    // to a more specific variety.
    // =============================================================
    if (pTE->m_pConstList)
    {
        if (pTE->m_dwRelOperator == WQL_TOK_IN)
            pTE->m_dwRelOperator = WQL_TOK_IN_CONST_LIST;
        if (pTE->m_dwRelOperator == WQL_TOK_NOT_IN)
            pTE->m_dwRelOperator = WQL_TOK_NOT_IN_CONST_LIST;
    }

    // Post-processing.  If the left side is a const and the right
    // side is a col-ref, flip the operator and swap so that
    // such expressions are normalized with the constant on the
    // right hand side and the column on the left.
    // ============================================================

    if (pTE->m_pConstValue && pTE->m_pJoinColRef)
    {
        pTE->m_dwRelOperator = FlipOperator(pTE->m_dwRelOperator);

        pTE->m_pColRef = pTE->m_pJoinColRef;
        pTE->m_pTableRef = pTE->m_pJoinTableRef;
        pTE->m_pJoinTableRef = 0;
        pTE->m_pJoinColRef = 0;

        DWORD dwTmp = pTE->m_dwRightFlags;
        pTE->m_dwRightFlags = pTE->m_dwLeftFlags;
        pTE->m_dwLeftFlags = dwTmp;

        // Interchange function references.
        // ================================

        pTE->m_pIntrinsicFuncOnColRef = pTE->m_pIntrinsicFuncOnJoinColRef;
        pTE->m_pIntrinsicFuncOnJoinColRef = 0;
    }

    pRE->m_pTypedExpr = pTE;

    return NO_ERROR;
}

//***************************************************************************
//
//  <typed_subexpr> ::= <col_ref>;
//  <typed_subexpr> ::= <function_call>;
//  <typed_subexpr> ::= <typed_const>;
//
//***************************************************************************
int CWQLParser::typed_subexpr(
    SWQLTypedExpr *pTE
    )
{
    int nRes;
    BOOL bStripTrailingParen = FALSE;
    SWQLQualifiedName *pColRef = 0;
    LPWSTR pFuncHolder = 0;

    // Check for <function_call>
    // =========================

    if (m_nCurrentToken == WQL_TOK_UPPER)
    {
        pTE->m_dwLeftFlags |= WQL_FLAG_FUNCTIONIZED;
        pFuncHolder = Macro_CloneLPWSTR(L"UPPER");
        if (!Next())
            return LEXICAL_ERROR;
        if (m_nCurrentToken != WQL_TOK_OPEN_PAREN)
            return SYNTAX_ERROR;
        if (!Next())
            return LEXICAL_ERROR;
        bStripTrailingParen = TRUE;
    }

    if (m_nCurrentToken == WQL_TOK_LOWER)
    {
        pTE->m_dwLeftFlags |= WQL_FLAG_FUNCTIONIZED;
        pFuncHolder = Macro_CloneLPWSTR(L"LOWER");
        if (!Next())
            return LEXICAL_ERROR;
        if (m_nCurrentToken != WQL_TOK_OPEN_PAREN)
            return SYNTAX_ERROR;
        if (!Next())
            return LEXICAL_ERROR;
        bStripTrailingParen = TRUE;
    }

    if (
        m_nCurrentToken == WQL_TOK_DATEPART  ||
        m_nCurrentToken == WQL_TOK_QUALIFIER ||
        m_nCurrentToken == WQL_TOK_ISNULL
        )
    {
        nRes = function_call(TRUE, pTE);
        if (nRes)
            return nRes;
        return NO_ERROR;
    }

    if (m_nCurrentToken == WQL_TOK_QSTRING ||
        m_nCurrentToken == WQL_TOK_INT     ||
        m_nCurrentToken == WQL_TOK_REAL    ||
        m_nCurrentToken == WQL_TOK_CHAR    ||
        m_nCurrentToken == WQL_TOK_PROMPT  ||
        m_nCurrentToken == WQL_TOK_NULL
       )
    {
        SWQLTypedConst *pTC = 0;
        nRes = typed_const(&pTC);
        if (nRes)
            return nRes;
        pTE->m_pConstValue = pTC;
        pTE->m_dwLeftFlags |= WQL_FLAG_CONST;  // Intentional!
        pTE->m_pIntrinsicFuncOnConstValue = pFuncHolder;
        goto Exit;
    }

    // If here, must be a <col_ref>.
    // =============================

    nRes = col_ref(&pColRef);   // TBD
    if (nRes)
        return nRes;

    pTE->m_pIntrinsicFuncOnColRef = pFuncHolder;

    // Convert the col_ref to be part of the current SWQLTypedExpr.  We analyze the
    // qualified name and extract the table and col name.
    // ============================================================================

    if (pColRef->m_aFields.Size() == 1)
    {
        SWQLQualifiedNameField *pCol = (SWQLQualifiedNameField *) pColRef->m_aFields[0];
        pTE->m_pColRef = Macro_CloneLPWSTR(pCol->m_pName);
        pTE->m_dwLeftFlags |= WQL_FLAG_COLUMN;

        if (pCol->m_bArrayRef)
        {
            pTE->m_dwLeftFlags |= WQL_FLAG_ARRAY_REF;
            pTE->m_dwLeftArrayIndex = pCol->m_dwArrayIndex;
        }
    }

    else if (pColRef->m_aFields.Size() == 2)
    {
        SWQLQualifiedNameField *pCol = (SWQLQualifiedNameField *) pColRef->m_aFields[1];
        SWQLQualifiedNameField *pTbl = (SWQLQualifiedNameField *) pColRef->m_aFields[0];

        pTE->m_pColRef = Macro_CloneLPWSTR(pCol->m_pName);
        pTE->m_pTableRef = Macro_CloneLPWSTR(pTbl->m_pName);
        pTE->m_dwLeftFlags |= WQL_FLAG_TABLE | WQL_FLAG_COLUMN;

        if (pCol->m_bArrayRef)
        {
            pTE->m_dwLeftFlags |= WQL_FLAG_ARRAY_REF;
            pTE->m_dwLeftArrayIndex = pCol->m_dwArrayIndex;
        }
    }

    // If UPPER or LOWER was used, we have to strip a trailing
    // parenthesis.
    // =======================================================

Exit:
    delete pColRef;

    if (bStripTrailingParen)
    {
        if (m_nCurrentToken != WQL_TOK_CLOSE_PAREN)
            return SYNTAX_ERROR;
        if (!Next())
            return LEXICAL_ERROR;
    }

    return NO_ERROR;
}



//***************************************************************************
//
//  <typed_subexpr_rh> ::= <function_call>;
//  <typed_subexpr_rh> ::= <typed_const>;
//  <typed_subexpr_rh> ::= <col_ref>;
//
//  <typed_subexpr_rh> ::= <in_clause>;   // Operator must be _IN or _NOT_IN
//
//***************************************************************************
int CWQLParser::typed_subexpr_rh(IN SWQLTypedExpr *pTE)
{
    int nRes;
    BOOL bStripTrailingParen = FALSE;
    SWQLQualifiedName *pColRef = 0;
    LPWSTR pFuncHolder = 0;

    // Check for <function_call>
    // =========================

    if (m_nCurrentToken == WQL_TOK_UPPER)
    {
        pTE->m_dwRightFlags |= WQL_FLAG_FUNCTIONIZED;
        pFuncHolder = Macro_CloneLPWSTR(L"UPPER");
        if (!Next())
            return LEXICAL_ERROR;
        if (m_nCurrentToken != WQL_TOK_OPEN_PAREN)
            return SYNTAX_ERROR;
        if (!Next())
            return LEXICAL_ERROR;
        bStripTrailingParen = TRUE;
    }

    if (m_nCurrentToken == WQL_TOK_LOWER)
    {
        pTE->m_dwRightFlags |= WQL_FLAG_FUNCTIONIZED;
        pFuncHolder = Macro_CloneLPWSTR(L"LOWER");
        if (!Next())
            return LEXICAL_ERROR;
        if (m_nCurrentToken != WQL_TOK_OPEN_PAREN)
            return SYNTAX_ERROR;
        if (!Next())
            return LEXICAL_ERROR;
        bStripTrailingParen = TRUE;
    }

    if (m_nCurrentToken == WQL_TOK_DATEPART  ||
        m_nCurrentToken == WQL_TOK_QUALIFIER ||
        m_nCurrentToken == WQL_TOK_ISNULL
        )
    {
        nRes = function_call(FALSE, pTE);
        if (nRes)
            return nRes;
        return NO_ERROR;
    }

    if (m_nCurrentToken == WQL_TOK_QSTRING ||
        m_nCurrentToken == WQL_TOK_INT     ||
        m_nCurrentToken == WQL_TOK_REAL    ||
        m_nCurrentToken == WQL_TOK_CHAR    ||
        m_nCurrentToken == WQL_TOK_PROMPT  ||
        m_nCurrentToken == WQL_TOK_NULL
       )
    {
        SWQLTypedConst *pTC = 0;
        nRes = typed_const(&pTC);
        if (nRes)
            return nRes;
        pTE->m_pConstValue = pTC;
        pTE->m_dwRightFlags |= WQL_FLAG_CONST;
        pTE->m_pIntrinsicFuncOnConstValue = pFuncHolder;

        // Check for BETWEEN operator, since we have
        // the other end of the range to parse.
        // =========================================

        if (pTE->m_dwRelOperator == WQL_TOK_BETWEEN ||
            pTE->m_dwRelOperator == WQL_TOK_NOT_BETWEEN)
        {
            if (m_nCurrentToken != WQL_TOK_AND)
                return SYNTAX_ERROR;
            if (!Next())
                return LEXICAL_ERROR;

            SWQLTypedConst *pTC = 0;
            nRes = typed_const(&pTC);
            if (nRes)
                return nRes;
            pTE->m_pConstValue2 = pTC;
            pTE->m_dwRightFlags |= WQL_FLAG_CONST_RANGE;
        }

        goto Exit;
    }

    if (m_nCurrentToken == WQL_TOK_OPEN_PAREN)
    {
        // IN clause.
        nRes = in_clause(pTE);
        if (nRes)
            return nRes;
        goto Exit;
    }

    // If here, must be a <col_ref>.
    // =============================

    nRes = col_ref(&pColRef);
    if (nRes)
        return nRes;

    pTE->m_pIntrinsicFuncOnJoinColRef = pFuncHolder;

    // Convert the col_ref to be part of the current SWQLTypedExpr.  We analyze the
    // qualified name and extract the table and col name.
    // ============================================================================

    if (pColRef->m_aFields.Size() == 1)
    {
        SWQLQualifiedNameField *pCol = (SWQLQualifiedNameField *) pColRef->m_aFields[0];
        pTE->m_pJoinColRef = Macro_CloneLPWSTR(pCol->m_pName);
        pTE->m_dwRightFlags |= WQL_FLAG_COLUMN;

        if (pCol->m_bArrayRef)
        {
            pTE->m_dwRightFlags |= WQL_FLAG_ARRAY_REF;
            pTE->m_dwRightArrayIndex = pCol->m_dwArrayIndex;
        }
    }

    else if (pColRef->m_aFields.Size() == 2)
    {
        SWQLQualifiedNameField *pCol = (SWQLQualifiedNameField *) pColRef->m_aFields[1];
        SWQLQualifiedNameField *pTbl = (SWQLQualifiedNameField *) pColRef->m_aFields[0];

        pTE->m_pJoinColRef = Macro_CloneLPWSTR(pCol->m_pName);
        pTE->m_pJoinTableRef = Macro_CloneLPWSTR(pTbl->m_pName);
        pTE->m_dwRightFlags |= WQL_FLAG_TABLE | WQL_FLAG_COLUMN;

        if (pCol->m_bArrayRef)
        {
            pTE->m_dwRightFlags |= WQL_FLAG_ARRAY_REF;
            pTE->m_dwRightArrayIndex = pCol->m_dwArrayIndex;
        }
    }

Exit:
    delete pColRef;

    if (bStripTrailingParen)
    {
        if (m_nCurrentToken != WQL_TOK_CLOSE_PAREN)
            return SYNTAX_ERROR;
        if (!Next())
            return LEXICAL_ERROR;
    }

    return NO_ERROR;
}




//*****************************************************************************************
//
//  <rel_op> ::= WQL_TOK_LE;
//  <rel_op> ::= WQL_TOK_LT;
//  <rel_op> ::= WQL_TOK_GE;
//  <rel_op> ::= WQL_TOK_GT;
//  <rel_op> ::= WQL_TOK_EQ;
//  <rel_op> ::= WQL_TOK_NE;
//  <rel_op> ::= WQL_TOK_LIKE;
//  <rel_op> ::= WQL_TOK_BETWEEN;
//  <rel_op> ::= WQL_TOK_IS <is_continuator>;
//  <rel_op> ::= WQL_TOK_ISA;
//  <rel_op> ::= WQL_TOK_IN;
//  <rel_op> ::= WQL_TOK_NOT <not_continuator>;
//
//  Operator type is returned via <nReturnedOp>
//
//*****************************************************************************************
// done

int CWQLParser::rel_op(OUT int & nReturnedOp)
{
    int nRes;
    nReturnedOp = WQL_TOK_ERROR;

    switch (m_nCurrentToken)
    {
        case WQL_TOK_LE:
            nReturnedOp = WQL_TOK_LE;
            if (!Next())
                return LEXICAL_ERROR;
            return NO_ERROR;

        case WQL_TOK_LT:
            nReturnedOp = WQL_TOK_LT;
            if (!Next())
                return LEXICAL_ERROR;
            return NO_ERROR;

        case WQL_TOK_GE:
            nReturnedOp = WQL_TOK_GE;
            if (!Next())
                return LEXICAL_ERROR;
            return NO_ERROR;

        case WQL_TOK_GT:
            nReturnedOp = WQL_TOK_GT;
            if (!Next())
                return LEXICAL_ERROR;
            return NO_ERROR;

        case WQL_TOK_EQ:
            nReturnedOp = WQL_TOK_EQ;
            if (!Next())
                return LEXICAL_ERROR;
            return NO_ERROR;

        case WQL_TOK_NE:
            nReturnedOp = WQL_TOK_NE;
            if (!Next())
                return LEXICAL_ERROR;
            return NO_ERROR;

        case WQL_TOK_LIKE:
            nReturnedOp = WQL_TOK_LIKE;
            if (!Next())
                return LEXICAL_ERROR;
            return NO_ERROR;

        case WQL_TOK_BETWEEN:
            nReturnedOp = WQL_TOK_BETWEEN;
            if (!Next())
                return LEXICAL_ERROR;
            return NO_ERROR;

        case WQL_TOK_IS:
            if (!Next())
                return LEXICAL_ERROR;
            nRes = is_continuator(nReturnedOp);
            return nRes;

        case WQL_TOK_ISA:
            nReturnedOp = WQL_TOK_ISA;
            if (!Next())
                return LEXICAL_ERROR;
            return NO_ERROR;

        case WQL_TOK_IN:
            nReturnedOp = WQL_TOK_IN;
            if (!Next())
                return LEXICAL_ERROR;
            return NO_ERROR;

        case WQL_TOK_NOT:
            if (!Next())
                return LEXICAL_ERROR;
            nRes = not_continuator(nReturnedOp);
            return nRes;
    }

    return SYNTAX_ERROR;
}

//*****************************************************************************************
//
//  <typed_const> ::= WQL_TOK_QSTRING;
//  <typed_const> ::= WQL_TOK_INT;
//  <typed_const> ::= WQL_TOK_REAL;
//  <typed_const> ::= WQL_TOK_PROMPT;
//  <typed_const> ::= WQL_TOK_NULL;
//
//*****************************************************************************************
// done

int CWQLParser::typed_const(OUT SWQLTypedConst **pRetVal)
{
    SWQLTypedConst *pNew = new SWQLTypedConst;
    *pRetVal = pNew;

    if (m_nCurrentToken == WQL_TOK_QSTRING
        || m_nCurrentToken == WQL_TOK_PROMPT)
    {
        pNew->m_dwType = VT_LPWSTR;
        pNew->m_bPrompt = (m_nCurrentToken == WQL_TOK_PROMPT);
        pNew->m_Value.m_pString = Macro_CloneLPWSTR(m_pTokenText);
        if (!Next())
            return LEXICAL_ERROR;
        return NO_ERROR;
    }

    if (m_nCurrentToken == WQL_TOK_INT)
    {
        pNew->m_dwType = VT_I4;
        pNew->m_Value.m_lValue = GetTokenLong();
        if (!Next())
            return LEXICAL_ERROR;
        return NO_ERROR;
    }

    if (m_nCurrentToken == WQL_TOK_REAL)
    {
        pNew->m_dwType = VT_R8;
        char buf[64];
        sprintf(buf, "%S", m_pTokenText);
        pNew->m_Value.m_dblValue = atof(buf);
        if (!Next())
            return LEXICAL_ERROR;
        return NO_ERROR;
    }

    if (m_nCurrentToken == WQL_TOK_NULL)
    {
        pNew->m_dwType = VT_NULL;
        if (!Next())
            return LEXICAL_ERROR;
        return NO_ERROR;
    }

    // Unrecognized constant.
    // ======================

    *pRetVal = 0;
    delete pNew;

    return SYNTAX_ERROR;
}

//*****************************************************************************************
//
//  <datepart_call> ::=
//    WQL_TOK_OPEN_PAREN
//    WQL_TOK_IDENT               // yy, mm,dd, hh, mm, ss, year, month, etc.
//    WQL_TOK_COMMA
//    <col_ref>
//    WQL_TOK_CLOSE_PAREN
//
//*****************************************************************************************

static WqlKeyword DateKeyWords[] =      // Keep this alphabetized for binary search
{
    L"DAY",      WQL_TOK_DAY,
    L"DD",       WQL_TOK_DAY,
    L"HH",       WQL_TOK_HOUR,
    L"HOUR",     WQL_TOK_HOUR,
    L"MI",       WQL_TOK_MINUTE,
    L"MILLISECOND", WQL_TOK_MILLISECOND,
    L"MINUTE",   WQL_TOK_MINUTE,
    L"MONTH",    WQL_TOK_MONTH,
    L"MM",       WQL_TOK_MONTH,
    L"MS",          WQL_TOK_MILLISECOND,
    L"YEAR",     WQL_TOK_YEAR,
    L"YY",       WQL_TOK_YEAR
};

const int NumDateKeywords = sizeof(DateKeyWords)/sizeof(WqlKeyword);

int CWQLParser::datepart_call(OUT SWQLNode_Datepart **pRetDP)
{
    DWORD dwDatepartTok = 0;
    int nRes;

    if (m_nCurrentToken != WQL_TOK_OPEN_PAREN)
        return SYNTAX_ERROR;
    if (!Next())
        return LEXICAL_ERROR;
    if (m_nCurrentToken != WQL_TOK_IDENT)
        return SYNTAX_ERROR;

    // Ident must be one of the DATEPART identifiers.
    // ==============================================

    BOOL bFound = FALSE;
    int l = 0, u = NumDateKeywords - 1;
    while (l <= u)
    {
        int m = (l + u) / 2;
        if (_wcsicmp(m_pTokenText, DateKeyWords[m].m_pKeyword) < 0)
             u = m - 1;
        else if (_wcsicmp(m_pTokenText, DateKeyWords[m].m_pKeyword) > 0)
             l = m + 1;
        else        // Match
        {
           bFound = TRUE;
           dwDatepartTok = DateKeyWords[m].m_nTokenCode;
           break;
        }
    }

    if (!bFound)
        return SYNTAX_ERROR;

    // If here, we know the date part.
    // ===============================

    if (!Next())
        return LEXICAL_ERROR;
    if (m_nCurrentToken != WQL_TOK_COMMA)
        return SYNTAX_ERROR;
    if (!Next())
        return LEXICAL_ERROR;

    SWQLQualifiedName *pQN = 0;
    nRes = col_ref(&pQN);
    if (nRes)
        return nRes;

    SWQLColRef *pCR = 0;

    nRes = QNameToSWQLColRef(pQN, &pCR);

    if (nRes)
        return INVALID_PARAMETER;

    if (m_nCurrentToken != WQL_TOK_CLOSE_PAREN)
        return SYNTAX_ERROR;
    if (!Next())
        return LEXICAL_ERROR;

    // Return the new node.
    // ====================

    SWQLNode_Datepart *pDP = new SWQLNode_Datepart;

    pDP->m_nDatepart = dwDatepartTok;
    pDP->m_pColRef = pCR;

    *pRetDP = pDP;

    return NO_ERROR;
}



//*****************************************************************************************
//
//  <function_call> ::= WQL_TOK_UPPER <function_call_parms>;
//  <function_call> ::= WQL_TOK_LOWER  <function_call_parms>;
//  <function_call> ::= WQL_TOK_DATEPART  <datepart_call>;
//  <function_call> ::= WQL_TOK_QUALIFIER  <function_call_parms>;
//  <function_call> ::= WQL_TOK_ISNULL <function_call_parms>;
//
//*****************************************************************************************

int CWQLParser::function_call(
    IN BOOL bLeftSide,
    IN SWQLTypedExpr *pTE
    )
{
    int nRes;
    SWQLNode_Datepart *pDP = 0;

    switch (m_nCurrentToken)
    {
        case WQL_TOK_DATEPART:
        {
            if (!Next())
                return LEXICAL_ERROR;

            nRes = datepart_call(&pDP);

            if (nRes)
                return nRes;

            if (bLeftSide)
            {
                pTE->m_dwLeftFlags |= WQL_FLAG_FUNCTIONIZED;
                pTE->m_pLeftFunction = pDP;
                pTE->m_pIntrinsicFuncOnColRef = Macro_CloneLPWSTR(L"DATEPART");
            }
            else
            {
                pTE->m_dwRightFlags |= WQL_FLAG_FUNCTIONIZED;
                pTE->m_pRightFunction = pDP;
                pTE->m_pIntrinsicFuncOnJoinColRef = Macro_CloneLPWSTR(L"DATEPART");
            }

            return NO_ERROR;
        }

        case WQL_TOK_QUALIFIER:
            trace(("EMIT: QUALIFIER\n"));
            if (!Next())
                return LEXICAL_ERROR;
            nRes = function_call_parms();
            return nRes;

        case WQL_TOK_ISNULL:
            trace(("EMIT: ISNULL\n"));
            if (!Next())
                return LEXICAL_ERROR;
            nRes = function_call_parms();
            return nRes;
    }

    return SYNTAX_ERROR;
}

//*****************************************************************************************
//
//  <function_call_parms> ::=
//    WQL_TOK_OPEN_PAREN
//    <func_args>
//    WQL_TOK_CLOSE_PAREN
//
//*****************************************************************************************

int CWQLParser::function_call_parms()
{
    if (m_nCurrentToken != WQL_TOK_OPEN_PAREN)
        return SYNTAX_ERROR;

    if (!Next())
        return LEXICAL_ERROR;

    int nRes = func_args();
    if (nRes)
        return nRes;

    if (m_nCurrentToken != WQL_TOK_CLOSE_PAREN)
        return SYNTAX_ERROR;

    if (!Next())
        return LEXICAL_ERROR;

    return NO_ERROR;
}

//*****************************************************************************************
//
//  <func_args> ::= <func_arg> <func_arg_list>;
//  <func_arg_list> ::= WQL_TOK_COMMA <func_arg> <func_arg_list>;
//  <func_arg_list> ::= <>;
//
//*****************************************************************************************

int CWQLParser::func_args()
{
    int nRes;

    while (1)
    {
        nRes = func_arg();
        if (nRes)
            return nRes;

        if (m_nCurrentToken != WQL_TOK_COMMA)
            break;

        if (!Next())
            return LEXICAL_ERROR;
    }

    return NO_ERROR;
}

//*****************************************************************************************
//
//  <func_arg> ::= <typed_const>;
//  <func_arg> ::= <col_ref>;
//
//*****************************************************************************************

int CWQLParser::func_arg()
{
    SWQLQualifiedName *pColRef = 0;
    int nRes;

    if (m_nCurrentToken == WQL_TOK_IDENT)
    {
        nRes = col_ref(&pColRef);
        return nRes;
    }

    SWQLTypedConst *pTC = 0;
    return typed_const(&pTC);
}


// Tokens which can follow IS
// ===========================

//*****************************************************************************************
//
//  <is_continuator> ::= WQL_TOK_LIKE;
//  <is_continuator> ::= WQL_TOK_BEFORE;
//  <is_continuator> ::= WQL_TOK_AFTER;
//  <is_continuator> ::= WQL_TOK_BETWEEN;
//  <is_continuator> ::= WQL_TOK_NULL;
//  <is_continuator> ::= WQL_TOK_NOT <not_continuator>;
//  <is_continuator> ::= WQL_TOK_IN;
//  <is_continuator> ::= WQL_TOK_A;
//
//*****************************************************************************************
// done

int CWQLParser::is_continuator(int & nReturnedOp)
{
    int nRes;

    nReturnedOp = WQL_TOK_ERROR;

    switch (m_nCurrentToken)
    {
        case WQL_TOK_LIKE:
            nReturnedOp = WQL_TOK_LIKE;
            if (!Next())
                return LEXICAL_ERROR;
            return NO_ERROR;

        case WQL_TOK_BEFORE:
            nReturnedOp = WQL_TOK_BEFORE;
            if (!Next())
                return LEXICAL_ERROR;
            return NO_ERROR;

        case WQL_TOK_AFTER:
            nReturnedOp = WQL_TOK_AFTER;
            if (!Next())
                return LEXICAL_ERROR;
            return NO_ERROR;

        case WQL_TOK_BETWEEN:
            nReturnedOp = WQL_TOK_BETWEEN;
            if (!Next())
                return LEXICAL_ERROR;
            return NO_ERROR;

        case WQL_TOK_NULL:
            nReturnedOp = WQL_TOK_ISNULL;
            if (!Next())
                return LEXICAL_ERROR;
            return NO_ERROR;

        case WQL_TOK_NOT:
            if (!Next())
                return LEXICAL_ERROR;
              nRes = not_continuator(nReturnedOp);
            return nRes;

        case WQL_TOK_IN:
            nReturnedOp = WQL_TOK_IN;
            if (!Next())
                return LEXICAL_ERROR;
            return NO_ERROR;

        case WQL_TOK_A:
            nReturnedOp = WQL_TOK_ISA;
            if (!Next())
                return LEXICAL_ERROR;
            return NO_ERROR;
    }

    return SYNTAX_ERROR;
}

//*****************************************************************************************
//
//  <not_continuator> ::= WQL_TOK_LIKE;
//  <not_continuator> ::= WQL_TOK_BEFORE;
//  <not_continuator> ::= WQL_TOK_AFTER;
//  <not_continuator> ::= WQL_TOK_BETWEEN;
//  <not_continuator> ::= WQL_TOK_NULL;
//  <not_continuator> ::= WQL_TOK_IN;
//
//  Returns WQL_TOK_NOT_LIKE, WQL_TOK_NOT_BEFORE, WQL_TOK_NOT_AFTER, WQL_TOK_NOT_BETWEEN
//          WQL_TOK_NOT_NULL, WQL_TOK_NOT_IN
//
//*****************************************************************************************
// done

int CWQLParser::not_continuator(int & nReturnedOp)
{
    nReturnedOp = WQL_TOK_ERROR;

    switch (m_nCurrentToken)
    {
        case WQL_TOK_LIKE:
            nReturnedOp = WQL_TOK_NOT_LIKE;
            if (!Next())
                return LEXICAL_ERROR;
            return NO_ERROR;

        case WQL_TOK_BEFORE:
            nReturnedOp = WQL_TOK_NOT_BEFORE;
            if (!Next())
                return LEXICAL_ERROR;
            return NO_ERROR;

        case WQL_TOK_AFTER:
            nReturnedOp = WQL_TOK_NOT_AFTER;
            if (!Next())
                return LEXICAL_ERROR;
            return NO_ERROR;

        case WQL_TOK_BETWEEN:
            nReturnedOp = WQL_TOK_NOT_BETWEEN;
            if (!Next())
                return LEXICAL_ERROR;
            return NO_ERROR;

        case WQL_TOK_NULL:
            nReturnedOp = WQL_TOK_NOT_NULL;
            if (!Next())
                return LEXICAL_ERROR;
            return NO_ERROR;

        case WQL_TOK_IN:
            nReturnedOp = WQL_TOK_NOT_IN;
            if (!Next())
                return LEXICAL_ERROR;
            return NO_ERROR;

        case WQL_TOK_A:
            nReturnedOp = WQL_TOK_NOT_A;
            if (!Next())
                return LEXICAL_ERROR;
            return NO_ERROR;
    }

    return SYNTAX_ERROR;
}


//*****************************************************************************************
//
//  <in_clause> ::= WQL_TOK_OPEN_PAREN <in_type> WQL_TOK_CLOSE_PAREN;
//  <in_type> ::= <subselect_stmt>;
//  <in_type> ::= <const_list>;
//  <in_type> ::= <qualified_name>;
//
//*****************************************************************************************

int CWQLParser::in_clause(IN SWQLTypedExpr *pTE)
{
    int nRes;

    if (m_nCurrentToken != WQL_TOK_OPEN_PAREN)
        return SYNTAX_ERROR;

    int nStPos = m_pLexer->GetCurPos();

    if (!Next())
        return LEXICAL_ERROR;

    if (m_nCurrentToken == WQL_TOK_SELECT)
    {
        SWQLNode_Select *pSel = 0;
        nRes = subselect_stmt(&pSel);
        if (nRes)
            return nRes;

        pSel->m_nStPos = nStPos;
        pSel->m_nEndPos = m_pLexer->GetCurPos() - 1;

        // Translate the IN / NOT IN operator to the specific
        // case of subselects.
        // ==================================================

        if (pTE->m_dwRelOperator == WQL_TOK_IN)
            pTE->m_dwRelOperator = WQL_TOK_IN_SUBSELECT;
        else if (pTE->m_dwRelOperator == WQL_TOK_NOT_IN)
            pTE->m_dwRelOperator = WQL_TOK_NOT_IN_SUBSELECT;

        pTE->m_pSubSelect = pSel;
    }

    else if (m_nCurrentToken == WQL_TOK_IDENT)
    {
        nRes = qualified_name(0);
        if (nRes)
            return nRes;
    }

    // If here, we must have a const-list.
    // ===================================

    else
    {
        SWQLConstList *pCL = 0;

        nRes = const_list(&pCL);
        if (nRes)
            return nRes;

        pTE->m_pConstList = pCL;
    }

    if (m_nCurrentToken != WQL_TOK_CLOSE_PAREN)
        return SYNTAX_ERROR;

    if (!Next())
        return LEXICAL_ERROR;

    return NO_ERROR;
}

//*****************************************************************************************
//
//  <const_list> ::= <typed_const> <const_list2>;
//  <const_list2> ::= WQL_TOK_COMMA <typed_const> <const_list2>;
//  <const_list2> ::= <>;
//
//*****************************************************************************************
// done

int CWQLParser::const_list(SWQLConstList **pRetVal)
{
    int nRes;
    SWQLConstList *pCL = new SWQLConstList;
    *pRetVal = 0;

    while (1)
    {
        if (m_nCurrentToken == WQL_TOK_QSTRING ||
            m_nCurrentToken == WQL_TOK_INT     ||
            m_nCurrentToken == WQL_TOK_REAL    ||
            m_nCurrentToken == WQL_TOK_CHAR    ||
            m_nCurrentToken == WQL_TOK_PROMPT  ||
            m_nCurrentToken == WQL_TOK_NULL
           )
        {
            SWQLTypedConst *pTC = 0;
            nRes = typed_const(&pTC);
            if (nRes)
            {
                delete pTC;
                delete pCL;
                return nRes;
            }

            pCL->Add(pTC);
        }

        if (m_nCurrentToken != WQL_TOK_COMMA)
            break;

        // If here, a comma, indicating a following constant.
        // ==================================================
        if (!Next())
        {
            delete pCL;
            return LEXICAL_ERROR;
        }
    }

    *pRetVal = pCL;
    return NO_ERROR;
}

//*****************************************************************************************
//
//  QUALIFIED_NAME
//
//  This recognizes a name separated by dots, and recognizes any array references which
//  may occur with those names:
//      a
//      a.b
//      a[n].b[n]
//      a.b.c.d
//      a.b[2].c.d.e[3].f
//      ...etc.
//
//  <qualified_name> ::= WQL_TOK_IDENT <qualified_name2>;
//  <qualified_name2> ::= WQL_TOK_DOT WQL_TOK_IDENT <qualified_name2>;
//
//  <qualified_name2> ::=
//      WQL_TOK_OPEN_BRACKET
//      WQL_TOK_INT
//      WQL_TOK_CLOSEBRACKET
//      <qname_becomes_array_ref>
//      <qualified_name2>;
//
//  <qname_becomes_array_ref> ::= <>;   // Dummy to enforce array semantics
//
//  <qualified_name2> ::= <>;
//
//*****************************************************************************************
// done

int CWQLParser::qualified_name(OUT SWQLQualifiedName **pRetVal)
{
    if (pRetVal == 0)
        return INVALID_PARAMETER;

    *pRetVal = 0;

    if (m_nCurrentToken != WQL_TOK_IDENT)
        return SYNTAX_ERROR;

    SWQLQualifiedName QN;
    SWQLQualifiedNameField *pQNF;

    pQNF = new SWQLQualifiedNameField;
    pQNF->m_pName = Macro_CloneLPWSTR(m_pTokenText);
    QN.Add(pQNF);

    if (!Next())
        return LEXICAL_ERROR;

    while (1)
    {
        if (m_nCurrentToken == WQL_TOK_DOT)
        {
            // Move past dot
            // ==============

            if (!Next())
                return LEXICAL_ERROR;

            if (!(m_nCurrentToken == WQL_TOK_IDENT || m_nCurrentToken == WQL_TOK_ASTERISK))
                return SYNTAX_ERROR;

            pQNF = new SWQLQualifiedNameField;
            pQNF->m_pName = Macro_CloneLPWSTR(m_pTokenText);
            QN.Add(pQNF);

            if (!Next())
                return LEXICAL_ERROR;

            continue;
        }

        if (m_nCurrentToken == WQL_TOK_OPEN_BRACKET)
        {
            if (!Next())
                return LEXICAL_ERROR;

            if (m_nCurrentToken != WQL_TOK_INT)
                return SYNTAX_ERROR;

            pQNF->m_bArrayRef = TRUE;
            pQNF->m_dwArrayIndex = (DWORD) GetTokenLong();

            if (!Next())
                return LEXICAL_ERROR;

            if (m_nCurrentToken != WQL_TOK_CLOSE_BRACKET)
                return SYNTAX_ERROR;

            if (!Next())
                return LEXICAL_ERROR;

            continue;
        }

        break;
    }

    // Copy the object and return it.  We worked with the copy QN
    // throughout to avoid complicated cleanup problems on errors, since
    // we take advantage of the auto destructor of <QN> in cases
    // above where we return errors.
    // ==================================================================

    SWQLQualifiedName *pRetCopy = new SWQLQualifiedName(QN);
    *pRetVal = pRetCopy;

    return NO_ERROR;
}


//*****************************************************************************************
//
//  col_ref
//
//*****************************************************************************************
// done

int CWQLParser::col_ref(OUT SWQLQualifiedName **pRetVal)
{
    return qualified_name(pRetVal);
}


//*****************************************************************************************
//
//  <col_list> ::= <col_ref> <col_list_rest>;
//  <col_list_rest> ::= WQL_TOK_COMMA <col_ref> <col_list_rest>;
//  <col_list_rest> ::= <>;
//
//*****************************************************************************************
// <status: SWQLColRef fields to be analyzed and filled in. Testable, though>

int CWQLParser::col_list(OUT SWQLNode_ColumnList **pRetColList)
{
    *pRetColList = 0;
    SWQLNode_ColumnList *pColList = new SWQLNode_ColumnList;

    while (1)
    {
        SWQLQualifiedName *pColRef = 0;

        int nRes = col_ref(&pColRef);
        if (nRes)
        {
            delete pColList;
            return nRes;
        }

        // If here, we have a legit column to add to the node.
        // ===================================================

        SWQLColRef *pCRef = 0;

        QNameToSWQLColRef(pColRef, &pCRef);

        pColList->m_aColumnRefs.Add(pCRef);

        // Check for sortation indication
        // ==============================

        if (m_nCurrentToken == WQL_TOK_ASC)
        {
            pCRef->m_dwFlags |= WQL_FLAG_SORT_ASC;
            if (!Next())
            {
                delete pColList;
                return LEXICAL_ERROR;
            }
        }
        else if (m_nCurrentToken == WQL_TOK_DESC)
        {
            pCRef->m_dwFlags |= WQL_FLAG_SORT_DESC;
            if (!Next())
            {
                delete pColList;
                return LEXICAL_ERROR;
            }
        }

        // Check for a continuation.
        // =========================

        if (m_nCurrentToken != WQL_TOK_COMMA)
            break;

        if (!Next())
        {
            delete pColList;
            return LEXICAL_ERROR;
        }
    }

    *pRetColList = pColList;
    return NO_ERROR;
}


//*****************************************************************************************
//
//  <subselect_stmt> ::=
//      WQL_TOK_SELECT
//      <select_type>
//      <col_ref>                   // Must not be an asterisk
//      <from_clause>
//      <where_clause>
//
//*****************************************************************************************

int CWQLParser::subselect_stmt(OUT SWQLNode_Select **pRetSel)
{
    int nSelType;
    int nRes = 0;

    SWQLNode_FromClause *pFrom = 0;
    SWQLNode_Select *pSel = 0;
    SWQLNode_TableRefs *pTblRefs = 0;
    SWQLNode_WhereClause *pWhere = 0;

    *pRetSel = 0;

    // Verify that we are in a subselect.
    // ==================================

    if (m_nCurrentToken != WQL_TOK_SELECT)
        return SYNTAX_ERROR;

    if (!Next())
        return LEXICAL_ERROR;

    // This affects some of the productions, since they behave differently
    // in subselects than in primary selects.
    // ===================================================================

    m_nParseContext = Ctx_Subselect;

    // If here, we are definitely in a subselect, so
    // allocate a new node.
    // ==============================================

    pSel = new SWQLNode_Select;
    pTblRefs = new SWQLNode_TableRefs;
    pSel->m_pLeft = pTblRefs;

    // Find the select type.
    // =====================

    nRes = select_type(nSelType);
    if (nRes)
        return nRes;

    pTblRefs->m_nSelectType = nSelType;        // ALL, DISTINCT

    // Get the column list.  In this case
    // it must be a single column and not
    // an asterisk.
    // ====================================

    nRes = col_ref_list(pTblRefs);
    if (nRes)
        return nRes;

    // Get the FROM clause and patch it in.
    // =====================================

    nRes = from_clause(&pFrom);
    if (nRes)
        return nRes;

    pTblRefs->m_pRight = pFrom;

    // Get the WHERE clause.
    // =====================

    nRes = where_clause(&pWhere);
    if (nRes)
        return nRes;

    pSel->m_pRight = pWhere;

    *pRetSel = pSel;

    m_nParseContext = Ctx_Default;     // No longer in a subselect

    return NO_ERROR;
}


/////////////////////////////////////////////////////////////////////////////
//
//  Containers
//
/////////////////////////////////////////////////////////////////////////////

//***************************************************************************
//
//  SWQLTypedConst constructor
//
//***************************************************************************
// done

SWQLTypedConst::SWQLTypedConst()
{
    m_dwType = VT_NULL;
    m_bPrompt = false;
    memset(&m_Value, 0, sizeof(m_Value));
}

//***************************************************************************
//
//  SWQLTypedConst::operator =
//
//***************************************************************************
// done

SWQLTypedConst & SWQLTypedConst::operator = (SWQLTypedConst &Src)
{
    Empty();

    if (Src.m_dwType == VT_LPWSTR)
    {
        m_Value.m_pString = Macro_CloneLPWSTR(Src.m_Value.m_pString);
    }
    else
    {
        m_Value = Src.m_Value;
    }

    m_dwType = Src.m_dwType;
    m_bPrompt = Src.m_bPrompt;

    return *this;
}

//***************************************************************************
//
//  SWQLTypedConst::Empty()
//
//***************************************************************************
// done

void SWQLTypedConst::Empty()
{
    if (m_dwType == VT_LPWSTR)
        delete [] m_Value.m_pString;
    m_bPrompt = false;
}



//***************************************************************************
//
//  SWQLConstList::operator =
//
//***************************************************************************
// done

SWQLConstList & SWQLConstList::operator = (SWQLConstList & Src)
{
    Empty();

    for (int i = 0; i < Src.m_aValues.Size(); i++)
    {
        SWQLTypedConst *pC = (SWQLTypedConst *) Src.m_aValues[i];
        m_aValues.Add(new SWQLTypedConst(*pC));
    }

    return *this;
}

//***************************************************************************
//
//  SWQLConstList::Empty
//
//***************************************************************************
// done

void SWQLConstList::Empty()
{
    for (int i = 0; i < m_aValues.Size(); i++)
        delete (SWQLTypedConst *) m_aValues[i];
    m_aValues.Empty();
}


//***************************************************************************
//
//  SWQLQualifiedName::Empty()
//
//***************************************************************************
// done

void SWQLQualifiedName::Empty()
{
    for (int i = 0; i < m_aFields.Size(); i++)
        delete (SWQLQualifiedNameField *) m_aFields[i];
}

//***************************************************************************
//
//  SWQLQualifiedName::operator =
//
//***************************************************************************
// done

SWQLQualifiedName & SWQLQualifiedName::operator = (SWQLQualifiedName &Src)
{
    Empty();

    for (int i = 0; i < Src.m_aFields.Size(); i++)
    {
        SWQLQualifiedNameField *pQN = new SWQLQualifiedNameField;
        *pQN = *(SWQLQualifiedNameField *) Src.m_aFields[i];
        m_aFields.Add(pQN);
    }

    return *this;
}

//***************************************************************************
//
//  SWQLQualifiedNameField::operator =
//
//***************************************************************************
// done

SWQLQualifiedNameField &
    SWQLQualifiedNameField::operator =(SWQLQualifiedNameField &Src)
{
    Empty();

    m_bArrayRef = Src.m_bArrayRef;
    m_pName = Macro_CloneLPWSTR(Src.m_pName);
    m_dwArrayIndex = Src.m_dwArrayIndex;
    return *this;
}


//***************************************************************************
//
//  SWQLNode_ColumnList destructor
//
//***************************************************************************
// tbd


//***************************************************************************
//
//  QNameToSWQLColRef
//
//  Translates a qualified name to a SWQLColRef structure and embeds
//  the q-name into the struct (since that is a field).
//
//***************************************************************************

int CWQLParser::QNameToSWQLColRef(
    IN  SWQLQualifiedName *pQName,
    OUT SWQLColRef **pRetVal
    )
{
    *pRetVal = 0;
    if (pQName == 0 || pRetVal == 0)
        return INVALID_PARAMETER;

    SWQLColRef *pCR = new SWQLColRef;

    // Algorithm: With a two name sequence, assume that the first name is
    // the table and that the second name is the column. If multiple
    // names occur, then we set the SWQLColRef type to WQL_FLAG_COMPLEX
    // and just take the last name for the column.
    // ==================================================================

    if (pQName->m_aFields.Size() == 2)
    {
        SWQLQualifiedNameField *pCol = (SWQLQualifiedNameField *) pQName->m_aFields[1];
        SWQLQualifiedNameField *pTbl = (SWQLQualifiedNameField *) pQName->m_aFields[0];

        pCR->m_pColName = Macro_CloneLPWSTR(pCol->m_pName);
        pCR->m_pTableRef = Macro_CloneLPWSTR(pTbl->m_pName);
        pCR->m_dwFlags = WQL_FLAG_TABLE | WQL_FLAG_COLUMN;

        if (_wcsicmp(L"*", pCol->m_pName) == 0)
            pCR->m_dwFlags |= WQL_FLAG_ASTERISK;

        if (pCol->m_bArrayRef)
        {
            pCR->m_dwFlags |= WQL_FLAG_ARRAY_REF;
            pCR->m_dwArrayIndex = pCol->m_dwArrayIndex;
        }
    }

    else if (pQName->m_aFields.Size() == 1)
    {
        SWQLQualifiedNameField *pCol = (SWQLQualifiedNameField *) pQName->m_aFields[0];
        pCR->m_pColName = Macro_CloneLPWSTR(pCol->m_pName);

        pCR->m_dwFlags |= WQL_FLAG_COLUMN;

        if (_wcsicmp(L"*", pCol->m_pName) == 0)
            pCR->m_dwFlags |= WQL_FLAG_ASTERISK;

        if (pCol->m_bArrayRef)
        {
            pCR->m_dwFlags |= WQL_FLAG_ARRAY_REF;
            pCR->m_dwArrayIndex = pCol->m_dwArrayIndex;
        }
    }

    // Complex case.
    // =============
    else
    {
        pCR->m_dwFlags = WQL_FLAG_COMPLEX_NAME;
    }

    // Copy the qualified name.
    // ========================

    pCR->m_pQName = pQName;

    *pRetVal = pCR;

    return NO_ERROR;;
}






//***************************************************************************
//
//  SWQLNode_ColumnList::DebugDump
//
//***************************************************************************
void SWQLNode_ColumnList::DebugDump()
{
    printf("---SWQLNode_ColumnList---\n");
    for (int i = 0; i < m_aColumnRefs.Size(); i++)
    {
        SWQLColRef *pCR = (SWQLColRef *) m_aColumnRefs[i];
        pCR->DebugDump();
    }

    printf("---End SWQLNode_ColumnList---\n");
}

//***************************************************************************
//
//***************************************************************************

void SWQLColRef::DebugDump()
{
    printf("  ---SWQLColRef---\n");
    printf("  Col Name    = %S\n",   m_pColName);
    printf("  Table       = %S\n",   m_pTableRef);
    printf("  Array Index = %d\n", m_dwArrayIndex);
    printf("  Flags       = 0x%X ", m_dwFlags);

    if (m_dwFlags & WQL_FLAG_TABLE)
        printf("WQL_FLAG_TABLE ");
    if (m_dwFlags & WQL_FLAG_COLUMN)
        printf("WQL_FLAG_COLUMN ");
    if (m_dwFlags & WQL_FLAG_ASTERISK)
        printf("WQL_FLAG_ASTERISK ");
    if (m_dwFlags & WQL_FLAG_NULL)
        printf("WQL_FLAG_NULL ");
    if (m_dwFlags & WQL_FLAG_FUNCTIONIZED)
        printf("WQL_FLAG_FUNCTIONIZED ");
    if (m_dwFlags & WQL_FLAG_COMPLEX_NAME)
        printf("WQL_FLAG_COMPLEX_NAME ");
    if (m_dwFlags & WQL_FLAG_ARRAY_REF)
        printf(" WQL_FLAG_ARRAY_REF");
    if (m_dwFlags & WQL_FLAG_UPPER)
        printf(" WQL_FLAG_UPPER");
    if (m_dwFlags & WQL_FLAG_LOWER)
        printf(" WQL_FLAG_LOWER");
    if (m_dwFlags & WQL_FLAG_SORT_ASC)
        printf(" WQL_FLAG_SORT_ASC");
    if (m_dwFlags & WQL_FLAG_SORT_DESC)
        printf(" WQL_FLAG_SORT_DESC");

    printf("\n");

    printf("  ---\n\n");
}

//***************************************************************************
//
//***************************************************************************

void SWQLNode_TableRefs::DebugDump()
{
    printf("********** BEGIN SWQLNode_TableRefs *************\n");
    printf("Select type = ");
    if (m_nSelectType & WQL_FLAG_COUNT)
        printf("WQL_FLAG_COUNT ");
    if (m_nSelectType & WQL_FLAG_ALL)
        printf("WQL_FLAG_ALL ");
    if (m_nSelectType & WQL_FLAG_DISTINCT)
        printf("WQL_FLAG_DISTINCT ");
    printf("\n");

    m_pLeft->DebugDump();
    m_pRight->DebugDump();
    printf("********** END SWQLNode_TableRefs *************\n\n\n");
}

//***************************************************************************
//
//***************************************************************************

void SWQLNode_FromClause::DebugDump()
{
    printf("---SWQLNode_FromClause---\n");

    if (m_pLeft == 0)
        return;
    m_pLeft->DebugDump();

    printf("---End SWQLNode_FromClause---\n");
}

//***************************************************************************
//
//***************************************************************************

void SWQLNode_Select::DebugDump()
{
    printf("********** BEGIN SWQLNode_Select *************\n");
    m_pLeft->DebugDump();
    m_pRight->DebugDump();
    printf("********** END SWQLNode_Select *************\n");
}

//***************************************************************************
//
//***************************************************************************

void SWQLNode_TableRef::DebugDump()
{
    printf("  ---TableRef---\n");
    printf("  TableName = %S\n", m_pTableName);
    printf("  Alias     = %S\n", m_pAlias);
    printf("  ---End TableRef---\n");
}

//***************************************************************************
//
//***************************************************************************

void SWQLNode_Join::DebugDump()
{
    printf("---SWQLNode_Join---\n");

    printf("Join type = ");

    switch (m_dwJoinType)
    {
        case WQL_FLAG_INNER_JOIN : printf("WQL_FLAG_INNER_JOIN "); break;
        case WQL_FLAG_FULL_OUTER_JOIN : printf("WQL_FLAG_FULL_OUTER_JOIN "); break;
        case WQL_FLAG_LEFT_OUTER_JOIN : printf("WQL_FLAG_LEFT_OUTER_JOIN "); break;
        case WQL_FLAG_RIGHT_OUTER_JOIN : printf("WQL_FLAG_RIGHT_OUTER_JOIN "); break;
        default: printf("<error> ");
    }

    if (m_dwFlags & WQL_FLAG_FIRSTROW)
        printf(" (FIRSTROW)");

    printf("\n");

    if (m_pRight)
        m_pRight->DebugDump();

    if (m_pLeft)
        m_pLeft->DebugDump();

    printf("---End SWQLNode_Join---\n");
}

//***************************************************************************
//
//  SWQLNode_Sql89Join::Empty
//
//***************************************************************************

void SWQLNode_Sql89Join::Empty()
{
    for (int i = 0; i < m_aValues.Size(); i++)
        delete (SWQLNode_TableRef *) m_aValues[i];
    m_aValues.Empty();
}

//***************************************************************************
//
//  SWQLNode_Sql89Join::DebugDump
//
//***************************************************************************

void SWQLNode_Sql89Join::DebugDump()
{
    printf("\n========== SQL 89 JOIN =================================\n");
    for (int i = 0; i < m_aValues.Size(); i++)
    {
        SWQLNode_TableRef *pTR = (SWQLNode_TableRef *) m_aValues[i];
        pTR->DebugDump();
    }
    printf("\n========== END SQL 89 JOIN =============================\n");

}


//***************************************************************************
//
//  SWQLNode_WhereClause::DebugDump
//
//***************************************************************************

void SWQLNode_WhereClause::DebugDump()
{
    printf("\n========== WHERE CLAUSE ================================\n");

    if (m_pLeft)
        m_pLeft->DebugDump();
    else
        printf(" <no where clause> \n");
    if (m_pRight)
        m_pRight->DebugDump();

    printf("============= END WHERE CLAUSE ============================\n");
}

//***************************************************************************
//
//  SWQLNode_WhereOptions::DebugDump
//
//***************************************************************************

void SWQLNode_WhereOptions::DebugDump()
{
    printf("---- Where Options ----\n");

    if (m_pLeft)
        m_pLeft->DebugDump();
    if (m_pRight)
        m_pRight->DebugDump();

    printf("---- End Where Options ----\n");
}

//***************************************************************************
//
//  SWQLNode_Having::DebugDump
//
//***************************************************************************

void SWQLNode_Having::DebugDump()
{
    printf("---- Having ----\n");

    if (m_pLeft)
        m_pLeft->DebugDump();
    if (m_pRight)
        m_pRight->DebugDump();

    printf("---- End Having ----\n");
}

//***************************************************************************
//
//  SWQLNode_GroupBy::DebugDump
//
//***************************************************************************

void SWQLNode_GroupBy::DebugDump()
{
    printf("---- Group By ----\n");

    if (m_pLeft)
        m_pLeft->DebugDump();
    if (m_pRight)
        m_pRight->DebugDump();

    printf("---- End Group By ----\n");
}


//***************************************************************************
//
//  SWQLNode_RelExpr::DebugDump
//
//***************************************************************************

void SWQLNode_RelExpr::DebugDump()
{
    if (m_pRight)
        m_pRight->DebugDump();

    printf("   --- SWQLNode_RelExpr ---\n");

    switch (m_dwExprType)
    {
        case WQL_TOK_OR:
            printf("    <WQL_TOK_OR>\n");
            break;

        case WQL_TOK_AND:
            printf("    <WQL_TOK_AND>\n");
            break;

        case WQL_TOK_NOT:
            printf("    <WQL_TOK_NOT>\n");
            break;

        case WQL_TOK_TYPED_EXPR:
            printf("    <WQL_TOK_TYPED_EXPR>\n");
            m_pTypedExpr->DebugDump();
            break;

        default:
            printf("    <invalid>\n");
    }

    printf("   --- END SWQLNode_RelExpr ---\n\n");

    if (m_pLeft)
        m_pLeft->DebugDump();

}

//***************************************************************************
//
//***************************************************************************

static LPWSTR OpToStr(DWORD dwOp)
{
    LPWSTR pRet = 0;

    switch (dwOp)
    {
        case WQL_TOK_EQ: pRet = L" '='   <WQL_TOK_EQ>"; break;
        case WQL_TOK_NE: pRet = L" '!='  <WQL_TOK_NE>"; break;
        case WQL_TOK_GT: pRet = L" '>'   <WQL_TOK_GT>"; break;
        case WQL_TOK_LT: pRet = L" '<'   <WQL_TOK_LT>"; break;
        case WQL_TOK_GE: pRet = L" '>='  <WQL_TOK_GE>"; break;
        case WQL_TOK_LE: pRet = L" '<='  <WQL_TOK_LE>"; break;

        case WQL_TOK_IN_CONST_LIST : pRet = L" IN <WQL_TOK_IN_CONST_LIST>"; break;
        case WQL_TOK_NOT_IN_CONST_LIST : pRet = L" NOT IN <WQL_TOK_NOT_IN_CONST_LIST>"; break;
        case WQL_TOK_IN_SUBSELECT : pRet = L" IN <WQL_TOK_IN_SUBSELECT>"; break;
        case WQL_TOK_NOT_IN_SUBSELECT : pRet = L" NOT IN <WQL_TOK_NOT_IN_SUBSELECT>"; break;

        case WQL_TOK_ISNULL: pRet = L"<WQL_TOK_ISNULL>"; break;
        case WQL_TOK_NOT_NULL: pRet = L"<WQL_TOK_NOT_NULL>"; break;

        case WQL_TOK_BETWEEN: pRet = L"<WQL_TOK_BETWEEN>"; break;
        case WQL_TOK_NOT_BETWEEN: pRet = L"<WQL_TOK_NOT_BETWEEN>"; break;

        default: pRet = L"   <unknown operator>"; break;
    }

    return pRet;
}

//***************************************************************************
//
//***************************************************************************

void SWQLTypedExpr::DebugDump()
{
    printf("        === BEGIN SWQLTypedExpr ===\n");
    printf("        m_pTableRef     = %S\n", m_pTableRef);
    printf("        m_pColRef       = %S\n", m_pColRef);
    printf("        m_pJoinTableRef = %S\n", m_pJoinTableRef);
    printf("        m_pJoinColRef   = %S\n", m_pJoinColRef);
    printf("        m_dwRelOperator = %S\n", OpToStr(m_dwRelOperator));
    printf("        m_pSubSelect    = 0x%X\n", m_pSubSelect);
    printf("        m_dwLeftArrayIndex = %d\n", m_dwLeftArrayIndex);
    printf("        m_dwRightArrayIndex = %d\n", m_dwRightArrayIndex);

    printf("        m_pConstValue   = ");
    if (m_pConstValue)
        m_pConstValue->DebugDump();
    else
        printf("  NULL ptr \n");

    printf("        m_pConstValue2   = ");
    if (m_pConstValue2)
        m_pConstValue2->DebugDump();
    else
        printf("  NULL ptr \n");



    printf("        m_dwLeftFlags = (0x%X)", m_dwLeftFlags);
    if (m_dwLeftFlags & WQL_FLAG_COLUMN)
        printf(" WQL_FLAG_COLUMN");
    if (m_dwLeftFlags & WQL_FLAG_TABLE)
        printf(" WQL_FLAG_TABLE");
    if (m_dwLeftFlags & WQL_FLAG_CONST)
        printf(" WQL_FLAG_CONST");
    if (m_dwLeftFlags & WQL_FLAG_COMPLEX_NAME)
        printf(" WQL_FLAG_COMPLEX_NAME");
    if (m_dwLeftFlags & WQL_FLAG_SORT_ASC)
        printf(" WQL_FLAG_SORT_ASC");
    if (m_dwLeftFlags & WQL_FLAG_SORT_DESC)
        printf(" WQL_FLAG_SORT_DESC");
    if (m_dwLeftFlags & WQL_FLAG_FUNCTIONIZED)
        printf(" WQL_FLAG_FUNCTIONIZED (Function=%S)", m_pIntrinsicFuncOnColRef);
    if (m_dwLeftFlags & WQL_FLAG_ARRAY_REF)
        printf(" WQL_FLAG_ARRAY_REF");
    printf("\n");


    printf("        m_dwRightFlags = (0x%X)", m_dwRightFlags);
    if (m_dwRightFlags & WQL_FLAG_COLUMN)
        printf(" WQL_FLAG_COLUMN");
    if (m_dwRightFlags & WQL_FLAG_TABLE)
        printf(" WQL_FLAG_TABLE");
    if (m_dwRightFlags & WQL_FLAG_CONST)
        printf(" WQL_FLAG_CONST");
    if (m_dwRightFlags & WQL_FLAG_COMPLEX_NAME)
        printf(" WQL_FLAG_COMPLEX_NAME");
    if (m_dwLeftFlags & WQL_FLAG_SORT_ASC)
        printf(" WQL_FLAG_SORT_ASC");
    if (m_dwLeftFlags & WQL_FLAG_SORT_DESC)
        printf(" WQL_FLAG_SORT_DESC");
    if (m_dwRightFlags & WQL_FLAG_FUNCTIONIZED)
    {
        printf(" WQL_FLAG_FUNCTIONIZED");
        if (m_pIntrinsicFuncOnJoinColRef)
            printf("(On join col: Function=%S)", m_pIntrinsicFuncOnJoinColRef);
        if (m_pIntrinsicFuncOnConstValue)
            printf("(On const: Function=%S)", m_pIntrinsicFuncOnConstValue);
    }
    if (m_dwRightFlags & WQL_FLAG_ARRAY_REF)
        printf(" WQL_FLAG_ARRAY_REF");

    if (m_dwRightFlags & WQL_FLAG_CONST_RANGE)
        printf(" WQL_FLAG_CONST_RANGE");

    printf("\n");

    if (m_pLeftFunction)
    {
        printf("m_pLeftFunction: \n");
        m_pLeftFunction->DebugDump();
    }
    if (m_pRightFunction)
    {
        printf("m_pRightFunction: \n");
        m_pRightFunction->DebugDump();
    }

    if (m_pConstList)
    {
        printf("   ---Const List---\n");
        for (int i = 0; i < m_pConstList->m_aValues.Size(); i++)
        {
            SWQLTypedConst *pConst = (SWQLTypedConst *) m_pConstList->m_aValues.GetAt(i);
            printf("    ");
            pConst->DebugDump();
        }

        printf("   ---End Const List---\n");
    }

    // Subselects
    // ==========
    if (m_pSubSelect)
    {
        printf("    ------- Begin Subselect ------\n");
        m_pSubSelect->DebugDump();
        printf("    ------- End   Subselect ------\n");
    }

    printf("\n");

    printf("        === END SWQLTypedExpr ===\n");
}

//***************************************************************************
//
//***************************************************************************

SWQLTypedExpr::SWQLTypedExpr()
{
    m_pTableRef = 0;
    m_pColRef = 0;
    m_dwRelOperator = 0;
    m_pConstValue = 0;
    m_pConstValue2 = 0;
    m_pJoinTableRef = 0;
    m_pJoinColRef = 0;
    m_pIntrinsicFuncOnColRef = 0;
    m_pIntrinsicFuncOnJoinColRef = 0;
    m_pIntrinsicFuncOnConstValue = 0;
    m_pLeftFunction = 0;
    m_pRightFunction = 0;
    m_pQNRight = 0;
    m_pQNLeft = 0;
    m_dwLeftFlags = 0;
    m_dwRightFlags = 0;
    m_pSubSelect = 0;
    m_dwLeftArrayIndex = 0;
    m_dwRightArrayIndex = 0;
    m_pConstList = 0;
}

//***************************************************************************
//
//***************************************************************************

void SWQLTypedExpr::Empty()
{
    delete [] m_pTableRef;
    delete [] m_pColRef;

    delete m_pConstValue;
    delete m_pConstValue2;

    delete m_pConstList;

    delete [] m_pJoinTableRef;
    delete [] m_pJoinColRef;
    delete [] m_pIntrinsicFuncOnColRef;
    delete [] m_pIntrinsicFuncOnJoinColRef;
    delete [] m_pIntrinsicFuncOnConstValue;

    delete m_pLeftFunction;
    delete m_pRightFunction;
    delete m_pQNRight;
    delete m_pQNLeft;
    delete m_pSubSelect;
}

//***************************************************************************
//
//***************************************************************************

void SWQLTypedConst::DebugDump()
{
    printf("   Typed Const <");

    switch (m_dwType)
    {
        case VT_LPWSTR:
            printf("%S", m_Value.m_pString);
            break;

        case VT_I4:
            printf("%d (0x%X)", m_Value.m_lValue, m_Value.m_lValue);
            break;

        case VT_R8:
            printf("%f", m_Value.m_dblValue);
            break;

        case VT_BOOL:
            printf("(bool) %d", m_Value.m_bValue);
            break;

        case VT_NULL:
            printf(" NULL");
            break;

        default:
            printf(" unknown");
    }

    printf(">\n");
}


//***************************************************************************
//
//***************************************************************************

static DWORD FlipOperator(DWORD dwOp)
{
    switch (dwOp)
    {
        case WQL_TOK_LT: return WQL_TOK_GT;
        case WQL_TOK_LE: return WQL_TOK_GE;
        case WQL_TOK_GT: return WQL_TOK_LT;
        case WQL_TOK_GE: return WQL_TOK_LE;
    }

    return dwOp; // Echo original
}

//***************************************************************************
//
//***************************************************************************

void SWQLNode_JoinPair::DebugDump()
{
    printf("---SWQLNode_JoinPair---\n");
    m_pRight->DebugDump();
    m_pLeft->DebugDump();
    printf("---End SWQLNode_JoinPair---\n");
}

void SWQLNode_OnClause::DebugDump()
{
    printf("---SWQLNode_OnClause---\n");
    m_pLeft->DebugDump();
    printf("---END SWQLNode_OnClause---\n");
}


//***************************************************************************
//
//***************************************************************************

void SWQLNode_OrderBy::DebugDump()
{
    printf("\n\n---- 'ORDER BY' Clause ----\n");
    m_pLeft->DebugDump();
    printf("---- End 'ORDER BY' Clause ----\n\n");
}

//***************************************************************************
//
//***************************************************************************


const LPWSTR CWQLParser::AliasToTable(IN LPWSTR pAlias)
{
    const CFlexArray *pAliases = GetSelectedAliases();

    for (int i = 0; i < pAliases->Size(); i++)
    {
        SWQLNode_TableRef *pTR = (SWQLNode_TableRef *) pAliases->GetAt(i);

        if (_wcsicmp(pTR->m_pAlias, pAlias) == 0)
            return pTR->m_pTableName;
    }

    return NULL;    // Not found
}



void SWQLNode_Datepart::DebugDump()
{
    printf("        ----Begin SWQLNode_Datepart----\n");

    switch (m_nDatepart)
    {
        case WQL_TOK_YEAR:   printf("       WQL_TOK_YEAR"); break;
        case WQL_TOK_MONTH:  printf("       WQL_TOK_MONTH"); break;
        case WQL_TOK_DAY:    printf("       WQL_TOK_DAY"); break;
        case WQL_TOK_HOUR:   printf("       WQL_TOK_HOUR"); break;
        case WQL_TOK_MINUTE: printf("       WQL_TOK_MINUTE"); break;
        case WQL_TOK_SECOND: printf("       WQL_TOK_SECOND"); break;
        case WQL_TOK_MILLISECOND: printf("      WQL_TOK_MILLISECOND"); break;
        default:
            printf("        -> No datepart specified\n");
    }

    printf("\n");

    if (m_pColRef)
        m_pColRef->DebugDump();

    printf("        ----End SWQLNode_Datepart----\n");
}


void SWQLNode_ColumnList::Empty()
{
    for (int i = 0; i < m_aColumnRefs.Size(); i++)
        delete (SWQLColRef *) m_aColumnRefs[i];
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\wqlscan\wqltest.cpp ===
/*++

Copyright (C) 1997-2001 Microsoft Corporation

Module Name:

    WQLTEST.CPP

Abstract:

History:

--*/

#include "precomp.h"
#include <stdio.h>

#include <genlex.h>

#include <flexarry.h>

#include <wqllex.h>
#include <wqlnode.h>
#include <wqlscan.h>




void xmain(int argc, char **argv)
{
    if (argc < 2)
    {
        printf("No SQL query specified\n");
        return;
    }

    char buf[8192];

    FILE *f = fopen(argv[1], "rt");
    int nCnt = fread(buf, 1, 8192, f);
    fclose(f);

    buf[nCnt] = 0;

    wchar_t buf2[8192];
    MultiByteToWideChar(CP_ACP, 0, buf, -1, buf2, 8192); 

    CTextLexSource src(buf2);

    CWQLScanner parser(&src);

    int nRes = parser.Parse();

    if (nRes)
    {
        printf("ERROR: %d\n", nRes);
    }
    else
    {
        printf("No errors.\n");
        parser.Dump();
    }
}

void main(int argc, char **argv)
{
    for (;;)
    {
        Sleep(500);
        xmain(argc, argv);
    }        
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\wql\wqltest.cpp ===
/*++

Copyright (C) 1997-2001 Microsoft Corporation

Module Name:

    WQLTEST.CPP

Abstract:

History:

--*/


#include "precomp.h"
#include <stdio.h>

#include <genlex.h>

#include <flexarry.h>
#include <wqllex.h>
#include <wqlnode.h>
#include <wql.h>




void dumpextra(CWQLParser &parser)
{
    const CFlexArray *pAliases = parser.GetSelectedAliases();
    const CFlexArray *pColumns = parser.GetSelectedColumns();

    printf("------------------------------------------------------\n");
    printf("Selected Aliases:\n");

    for (int i = 0; i < pAliases->Size(); i++)
    {
        SWQLNode_TableRef *pTR = (SWQLNode_TableRef *) pAliases->GetAt(i);
        printf("    Alias = %S      Table = %S\n", pTR->m_pAlias, pTR->m_pTableName);
    }

    printf("Selected Columns:\n");

    for (i = 0; i < pColumns->Size(); i++)
    {
        SWQLColRef *pCR = (SWQLColRef *) pColumns->GetAt(i);
        printf("    Alias = %S      Table = %S\n", pCR->m_pTableRef, pCR->m_pColName);
    }

    printf("------------------------------------------------------\n");
}

void xmain(int argc, char **argv)
{
    if (argc < 2)
    {
        printf("No SQL query specified\n");
        return;
    }

    char buf[8192];

    FILE *f = fopen(argv[1], "rt");
    int nCnt = fread(buf, 1, 8192, f);
    fclose(f);

    buf[nCnt] = 0;

    wchar_t buf2[8192];
    MultiByteToWideChar(CP_ACP, 0, buf, -1, buf2, 8192); 

    CTextLexSource src(buf2);

    CWQLParser parser(&src);

    int nRes = parser.Parse();

    if (nRes)
    {
        printf("ERROR: %d\n", nRes);
    }
    else
    {
        printf("--------------- QUERY DUMP ----------------------\n");
        parser.GetParseRoot()->DebugDump();

        CWStringArray aTbls;
        parser.GetReferencedTables(aTbls);
        printf("\n\n---Referenced Tables---\n");
        for (int i = 0; i < aTbls.Size(); i++)
            printf("    Referenced Table = %S\n", aTbls[i]);

    
        printf("-------------------------------------------------\n");

        dumpextra(parser);

        printf("No errors.\n");
    }
}

void main(int argc, char **argv)
{
    for (int i = 0; i < 100; i++)
        xmain(argc, argv);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\wql\wqlnode.h ===
/*++

Copyright (C) 1997-2001 Microsoft Corporation

Module Name:

    WQLNODE.H

Abstract:

	WQL Parse Node Definitions 

History:

	raymcc      29-Sep-97       Created

--*/

#ifndef _WQLNODE_H_
#define _WQLNODE_H_


#define  WQL_FLAG_ALIAS          0x1
#define  WQL_FLAG_TABLE          0x2
#define  WQL_FLAG_ASTERISK       0x4
#define  WQL_FLAG_DISTINCT       0x8
#define  WQL_FLAG_ALL            0x10
#define  WQL_FLAG_COUNT          0x20
#define  WQL_FLAG_CONST          0x40
#define  WQL_FLAG_COLUMN         0x80
#define  WQL_FLAG_COMPLEX_NAME   0x100
#define  WQL_FLAG_FUNCTIONIZED   0x200
#define  WQL_FLAG_ARRAY_REF      0x400
#define  WQL_FLAG_UPPER          0x800
#define  WQL_FLAG_LOWER          0x1000
#define  WQL_FLAG_FIRSTROW       0x2000
#define  WQL_FLAG_CONST_RANGE    0x4000
#define  WQL_FLAG_SORT_ASC       0x8000
#define  WQL_FLAG_SORT_DESC      0x10000
#define  WQL_FLAG_AGGREGATE      0x20000
#define  WQL_FLAG_NULL           0x40000

#define WQL_FLAG_INNER_JOIN         1
#define WQL_FLAG_LEFT_OUTER_JOIN    2
#define WQL_FLAG_RIGHT_OUTER_JOIN   3
#define WQL_FLAG_FULL_OUTER_JOIN    4



//***************************************************************************
//
//  SWQLNode
//
//  Base node type for all parser output.
//  
//***************************************************************************

struct SWQLNode
{
    DWORD        m_dwNodeType;
    SWQLNode    *m_pLeft;
    SWQLNode    *m_pRight;

    SWQLNode() { m_pLeft = 0; m_pRight = 0; m_dwNodeType = 0; }
    virtual ~SWQLNode() { delete m_pLeft; delete m_pRight; }
    virtual void DebugDump() = 0;
};


//***************************************************************************
//
//  SWQLTypedConst
//
//  Typed constant container (similar to OA VARIANT).
//  
//***************************************************************************

union UWQLTypedConst
{
    LPWSTR m_pString;       // VT_LPWSTR for WQL_TOK_QSTRING and WQL_TOK_PROMPT
    LONG   m_lValue;        // VT_LONG
    double m_dblValue;      // VT_DOUBLE
    BOOL   m_bValue;        // VT_BOOL, use TRUE/FALSE (not VARIANT_TRUE, VARIANT_FALSE)
};

struct SWQLTypedConst
{
    DWORD m_dwType;             // A VT_ type
    UWQLTypedConst m_Value;     // One of the union fields
    bool m_bPrompt;             // Only true if token was WQL_TOK_PROMPT

    SWQLTypedConst();
    SWQLTypedConst(SWQLTypedConst &Src) { m_dwType = VT_NULL; *this = Src; }
    SWQLTypedConst & operator = (SWQLTypedConst &Src);
   ~SWQLTypedConst() { Empty(); }
    void Empty();
    void DebugDump();
};

struct SWQLConstList
{
    CFlexArray m_aValues;       // ptrs to SWQLTypedConst

    SWQLConstList() {}
    SWQLConstList(SWQLConstList &Src) { *this = Src; }
    SWQLConstList & operator = (SWQLConstList & Src);
   ~SWQLConstList() { Empty(); }
    void Add(SWQLTypedConst *pTC) { m_aValues.Add(pTC); }
    void Empty();
};



struct SWQLQualifiedNameField
{
    LPWSTR  m_pName;         // Name
    BOOL    m_bArrayRef;     // TRUE if this is an array reference
    DWORD   m_dwArrayIndex;  // If <m_bArrayRef == TRUE> this is the array index

    SWQLQualifiedNameField() { m_pName = 0; m_bArrayRef = 0; m_dwArrayIndex = 0; }
    SWQLQualifiedNameField(SWQLQualifiedNameField &Src) { m_pName = 0; *this = Src; } 
    SWQLQualifiedNameField & operator = (SWQLQualifiedNameField &Src);    
   ~SWQLQualifiedNameField() { Empty(); }
    void Empty() { delete [] m_pName; }
};

struct SWQLQualifiedName
{
    CFlexArray m_aFields;       // [0] =  left most, last entry is column

    SWQLQualifiedName() {}
    SWQLQualifiedName(SWQLQualifiedName &Src) { *this = Src; }
    SWQLQualifiedName & operator = (SWQLQualifiedName &Src);    
   ~SWQLQualifiedName() { Empty(); }

    int GetNumNames() { return m_aFields.Size(); }
    
    const LPWSTR GetName(int nIndex) 
    { 
        return (LPWSTR) ((SWQLQualifiedNameField*) m_aFields[nIndex])->m_pName; 
    }

    int Add(SWQLQualifiedNameField *pQN) { return m_aFields.Add(pQN); }
    void Empty();
};



#define WQL_TOK_BASE            100

//***************************************************************************
//
//   SWQLNode_Select
//
//   This is the root of the parse tree or the root of a subselect.
//
//                SWQLNode_Select
//               /               \
//      SWQLNode_TableRefs     SWQLNode_WhereClause
//     /                \      /                   \
//    x                  x    x                     x
//
//***************************************************************************

#define TYPE_SWQLNode_Select        (WQL_TOK_BASE + 1)



struct SWQLNode_Select : SWQLNode
{
    // Left  Node is of type SWQLNode_TableRefs
    // Right Node is of type SWQLNode_WhereClause

    int m_nStPos;
    int m_nEndPos;

    SWQLNode_Select() : m_nStPos(-1), m_nEndPos(-1) { m_dwNodeType = TYPE_SWQLNode_Select; }
    void DebugDump();
};


//***************************************************************************
//
//   SWQLNode_TableRefs
//
//  This contains everything prior to the WHERE clause: the target
//  column list and the FROM clause.
//
//  Also contains the SELECT type, i.e., ALL vs. DISTINCT vs. COUNT.
//
//                SWQLNode_TableRefs
//               /               \
//      SWQLNode_ColumnList     SWQLNode_FromClause
//
//  In all cases, SWQLNode_ColumnList is present.  Note that if the
//  user did a "select *...", then the SWQLNode_ColumnList will only
//  have a single column in it clearly marked as an asterisk.  If
//  a "select count(...) " was done, then m_nSelectType is set to
//  WQL_FLAG_COUNT and the SWQLNode_ColumnList will have a single
//  column in it, whether an * or a qualified name.
//
//***************************************************************************

#define TYPE_SWQLNode_TableRefs      (WQL_TOK_BASE + 2)

struct SWQLNode_TableRefs : SWQLNode
{
    // Left  Node is SWQLNode_ColumnList
    // Right Node is SWQLNode_FromClause

    int m_nSelectType;       // WQL_FLAG_ALL means ALL was used.
                             // WQL_FLAG_DISTINCT means DISTINCT was used.
                             // WQL_FLAG_COUNT means COUNT was used.  

    SWQLNode_TableRefs() 
        { m_nSelectType = WQL_FLAG_ALL; 
          m_dwNodeType = TYPE_SWQLNode_TableRefs;
        }

   ~SWQLNode_TableRefs() {}
    void DebugDump();
};


//***************************************************************************
//
//   SWQLNode_ColumnList
//
//  This contains the selected list of columns.
//
//                SWQLNode_ColumnList
//               /                 \
//              NULL               NULL
//
//***************************************************************************

#define TYPE_SWQLNode_ColumnList   (WQL_TOK_BASE + 3)

struct SWQLNode_ColumnList : SWQLNode
{
    // Left  Node is NULL
    // Right Node is NULL

    CFlexArray m_aColumnRefs ;   // Pointers to SWQLColRef entries.

    SWQLNode_ColumnList() { m_dwNodeType = TYPE_SWQLNode_ColumnList; }
   ~SWQLNode_ColumnList() { Empty(); }
    void Empty();
    void DebugDump();
};


struct SWQLColRef
{
    LPWSTR m_pColName;      // The column name or "*" or NULL
    LPWSTR m_pTableRef;     // The table/alias name or NULL if there is none
    DWORD  m_dwArrayIndex;
    DWORD  m_dwFlags;       // WQL_FLAG_TABLE bit set if m_pTableRef 
                            //   is a table name
                            // WQL_FLAG_ALIAS bit set if m_pTableRef 
                            //   is a table alias
                            // WQL_FLAG_ASTERISK bit set if m_pColName is 
                            //   * (this is faster than to check than a 
                            //   string compare on <m_pColName> for "*".
                            // WQL_FLAG_NULL if the column name was "NULL"
                            // WQL_FLAG_FUNCTIONIZED is set if the column
                            //    is wrapped in a function call.
                            //    The function bits WQL_FLAG_UPPER or
                            //    WQL_FLAG_LOWER will be set.
                            // WQL_FLAG_ARRAY_REF is set if the column
                            //    is an array column, in which case
                            //    m_dwArrayIndex is set to the array offset.
                            // WQL_FLAG_COMPLEX_NAME is set if the name
                            //  is qualified in a deeply nested way,
                            //  which requires examination of the <QName>
                            //  object.  In this case <m_pColName> is
                            //  set to the last name, but m_pTableRef
                            //  is left blank.
                            // WQL_FLAG_SORT_ASC to sort ascending (Order by only)
                            // WQL_FLAG_SORT_DESC to sort descending (Order by only)

    SWQLQualifiedName *m_pQName;    // The full qualified name

    SWQLColRef() { m_pColName = NULL; m_pTableRef = 0; 
        m_dwFlags = 0; m_dwArrayIndex = 0; m_pQName = 0;
        }

   ~SWQLColRef() { delete [] m_pColName; delete [] m_pTableRef; delete m_pQName; }
    void DebugDump();
};



//***************************************************************************
//
//   SWQLNode_FromClause
//
//   The subtree containing the tables selected from and any joins.
//
//                SWQLNode_FromClause
//               /                   \
//             SWQLNode_TableRef      NULL
//          or SWQLNode_Join
//          or SWQLNode_Sql89Join
//
//***************************************************************************

#define TYPE_SWQLNode_FromClause  (WQL_TOK_BASE + 4)

struct SWQLNode_FromClause : SWQLNode
{
    // Left is SWQLNode_TableRef or SWQLNode_Join
    // Right is NULL

    SWQLNode_FromClause() { m_dwNodeType = TYPE_SWQLNode_FromClause; }
   ~SWQLNode_FromClause() {}
    void DebugDump();
};



//***************************************************************************
//
//  SWQLNode_Sql89Join
//  
//  A subtree which expresses a SQL-89 join.
//
//                SWQLNode_Sql89Join
//               /             \
//             NULL             NULL
//
//***************************************************************************

#define TYPE_SWQLNode_Sql89Join     (WQL_TOK_BASE + 5)

struct SWQLNode_Sql89Join : SWQLNode
{
    CFlexArray m_aValues;           // Array of pointers to SWQLNode_TableRef
                                    // objects

    SWQLNode_Sql89Join() { m_dwNodeType = TYPE_SWQLNode_Sql89Join; }
    ~SWQLNode_Sql89Join() {Empty();};
    void DebugDump();
    void Empty();
};



//***************************************************************************
//
//  SWQLNode_Join
//  
//  A subtree which expresses a join.
//
//                SWQLNode_Join
//               /              \
//       SWQLNode_JoinPair       SWQLNode_OnClause or NULL.
//
//***************************************************************************

#define TYPE_SWQLNode_Join  (WQL_TOK_BASE + 6)

struct SWQLNode_Join : SWQLNode
{
    // Left ptr is SWQLNode_JoinPair
    // Right ptr is ON clause.  If NULL, there is no ON clause
    // and the JOIN was a SQL-89 style join with the join condition
    // present in the WHERE clause.  

    DWORD m_dwJoinType;     
            // One of WQL_FLAG_INNER_JOIN, WQL_FLAG_LEFT_OUTER_JOIN, 
            // WQL_FLAG_RIGHT_OUTER_JOIN or WQL_FLAG_FULL_OUTER_JOIN
    DWORD m_dwFlags;
        // Contains WQL_FLAG_FIRSTROW if used

    SWQLNode_Join() { m_dwNodeType = TYPE_SWQLNode_Join; m_dwJoinType = m_dwFlags = 0; }
   ~SWQLNode_Join() {}
    void DebugDump();
};


//***************************************************************************
//
//  SWQLNode_JoinPair
//  
//                SWQLNode_JoinPair
//               /                 \
//        <SWQLNode_Join or SWQLNode_TableRef>
//
//***************************************************************************
#define TYPE_SWQLNode_JoinPair   (WQL_TOK_BASE + 7)

struct SWQLNode_JoinPair : SWQLNode
{
    // Left ptr is SWQLNode_Join or SWQLNode_TableRef
    // Right ptr is SWQLNodeNode_Join or SWQL_NodeTableRef

    SWQLNode_JoinPair() { m_dwNodeType = TYPE_SWQLNode_JoinPair; }
   ~SWQLNode_JoinPair() {}

    void DebugDump();
};



//***************************************************************************
//
//  SWQLNode_TableRef
//  
//  A node representing a table name and its alias, if any.
//
//                SWQLNode_TableRef
//               /                 \
//             NULL               NULL
//
//***************************************************************************

#define TYPE_SWQLNode_TableRef  (WQL_TOK_BASE + 8)

struct SWQLNode_TableRef : SWQLNode
{
    LPWSTR m_pTableName;        // The table
    LPWSTR m_pAlias;            // Table alias. NULL if not used.

    SWQLNode_TableRef() { m_pTableName = 0; m_pAlias = 0; m_dwNodeType = TYPE_SWQLNode_TableRef; }
    ~SWQLNode_TableRef() { delete [] m_pTableName; delete [] m_pAlias; }
    void DebugDump();    
};

//***************************************************************************
//
//  SWQLNode_OnClause
//  
//                SWQLNode_OnClause
//               /                 \
//        <SWQLNode_RelExpr>        NULL
//
//***************************************************************************
#define TYPE_SWQLNode_OnClause   (WQL_TOK_BASE + 9)

struct SWQLNode_OnClause : SWQLNode
{
    // Left ptr is <SWQLNode_RelExpr> which contains the ON clause.
    // Right ptr is always NULL.

    SWQLNode_OnClause() { m_dwNodeType = TYPE_SWQLNode_OnClause; }
   ~SWQLNode_OnClause() {}
    void DebugDump();
};



//***************************************************************************
//
//  SWQLNode_WhereClause
//  
//                SWQLNode_WhereClause
//               /                 \
//        SWQLNode_RelExpr         SWQLNode_WhereOptions or NULL
//        or 
//        NULL if no conditions
//
//***************************************************************************

#define TYPE_SWQLNode_WhereClause  (WQL_TOK_BASE + 10)

struct SWQLNode_WhereClause : SWQLNode
{
    // Left ptr is SWQLNode_RelExpr.
    // Right ptr is SQLNode_QueryOptions or NULL if none

    SWQLNode_WhereClause() { m_dwNodeType = TYPE_SWQLNode_WhereClause; }
   ~SWQLNode_WhereClause() {}

    void DebugDump();
};

//***************************************************************************
//  
//  struct SWQLTypedExpr
//
//  This represents a typed subexpression in a where clause:
//
//      mycol < 2
//      33 <= tbl1.col2
//      tbl3.col4 = tbl4.col5
//      ...etc.
//       
//***************************************************************************

struct SWQLTypedExpr
{
    LPWSTR         m_pTableRef;         // For qualified column names, 
                                        //   NULL if not used
    LPWSTR         m_pColRef;           // Column name

    DWORD          m_dwRelOperator;     // The operator used: WQL_TOK_LE, 
                                        //  WQL_TOK_GE, WQL_TOK_LIKE etc.   
                                        //  WQL_TOK_IN_CONST_LIST
                                        //  WQL_TOK_NOT_IN_CONST_LIST
                                        //  WQL_TOK_IN_SUBSELECT
                                        //  WQL_TOK_NOT_IN_SUBSELECT

    SWQLTypedConst *m_pConstValue;     // A const value 
    SWQLTypedConst *m_pConstValue2;    // The other const value used with BETWEEN

    LPWSTR         m_pJoinTableRef;     // The joined table name or its alias, 
                                        //   NULL if not used
    LPWSTR         m_pJoinColRef;       // The joined column name

    LPWSTR         m_pIntrinsicFuncOnColRef;        
    LPWSTR         m_pIntrinsicFuncOnJoinColRef;
    LPWSTR         m_pIntrinsicFuncOnConstValue;
    
    SWQLNode      *m_pLeftFunction;         // More detail for DATEPART, etc.
    SWQLNode      *m_pRightFunction;        // More detail for DATEPART, etc.

    DWORD          m_dwLeftArrayIndex;
    DWORD          m_dwRightArrayIndex;

    SWQLQualifiedName *m_pQNRight;
    SWQLQualifiedName *m_pQNLeft;

    DWORD          m_dwLeftFlags;
    DWORD          m_dwRightFlags;           
        // Each of the above to Flags shows the expression layout on each side 
        // of the operator.
        //  WQL_FLAG_CONST        = A typed constant was used
        //  WQL_FLAG_COLUMN       = Column field was used
        //  WQL_FLAG_TABLE        = Table/Alias was used
        //  WQL_FLAG_COMPLEX      = Complex qualified name and/or array was used
        //  WQL_FLAG_FUNCTIONIZED = Function was applied over the const or col.


    // For IN and NOT IN clauses.
    // ==========================

    SWQLNode       *m_pSubSelect;

    SWQLConstList  *m_pConstList;   // For IN clause with constant-list
            
    /*
    (1) If a const is tested against a column, then <m_pConstValue> will 
        be used to represent it, and the table+col referenced will be in 
        <m_pTableRef> and <m_pColRef>.

    (2) If a join occurs, then <m_pConstValue> will be NULL.

    (3) Intrinsic functions (primarily UPPER() and LOWER()) can be applied 
        to the column references  or the constant.  The function names will 
        be placed in the <m_pIntrinsic...> pointers when applied.

    (4) If <m_dwRelOperator> is WQL_TOK_IN_CONST_LIST or WQL_TOK_NOT_IN_CONST_LIST
        then <m_aConstSet> is an array of pointers to SWQLTypedConst structs representing
        the set of constants that the referenced column must intersect with.

    (5) If <m_dwRelOperator> is WQL_TOK_IN_SUBSELECT or WQL_TOK_NOT_IN_SUBSELECT
        then m_pSubSelect is a pointer to an embedded subselect tree in the form
        of a SWQLNode_Select struct, beginning the root of an entirely new select
        statement.
    */
        
    SWQLTypedExpr();
   ~SWQLTypedExpr() { Empty(); }
    void DebugDump();
    void Empty();
};



//***************************************************************************
//
//  SWQLNode_RelExpr
//  
//                SWQLNode_RelExpr
//               /                \
//        SWQLNode_RelExpr        SWQLNode_RelExpr
//        or NULL                 or NULL
//
//***************************************************************************

#define TYPE_SWQLNode_RelExpr   (WQL_TOK_BASE + 11)

struct SWQLNode_RelExpr : SWQLNode
{
    DWORD m_dwExprType;  // WQL_TOK_OR
                         // WQL_TOK_AND
                         // WQL_TOK_NOT
                         // WQL_TOK_TYPED_EXPR

    SWQLTypedExpr *m_pTypedExpr; 

    /*
    (1) If the <m_dwExprType> is WQL_TOK_AND or WQL_TOK_OR, then each of 
        the two subnodes are themselves SWQLNode_RelExpr nodes and 
        <m_pTypedExpr> points to NULL.

    (2) If <m_dwExprType> is WQL_TOK_NOT, then <m_pLeft> points to a 
        SWQLNode_RelExpr containing the subclause to which to apply the NOT 
        operation and <m_pRight> points to NULL.

    (3) If <m_dwExprType> is WQL_TOK_TYPED_EXPR, then <m_pLeft> and 
        <m_pRight> both point to NULL, and <m_pTypedExpr> contains a typed 
        relational subexpression.

    (4) Parentheses have been removed and are implied by the nesting.
    */

    SWQLNode_RelExpr() { m_dwNodeType = TYPE_SWQLNode_RelExpr; m_pTypedExpr = 0; m_dwExprType = 0; }
   ~SWQLNode_RelExpr() { delete m_pTypedExpr; }
    void DebugDump();
};



//***************************************************************************
//
//  SWQLNode_WhereOptions
//  
//                SWQLNode_WhereOptions
//               /                 \
//           SWQLNode_GroupBy      SWQLNode_OrderBy
//
//***************************************************************************

#define TYPE_SWQLNode_WhereOptions (WQL_TOK_BASE + 12)

struct SWQLNode_WhereOptions : SWQLNode
{
    // left ptr is SWQLNode_GroupBy, or NULL if not used
    // right ptr is SWQLNode_OrderBy, or NULL if not used    

    SWQLNode_WhereOptions() { m_dwNodeType = TYPE_SWQLNode_WhereOptions; }
    void DebugDump();
};

//***************************************************************************
//
//  SWQLNode_GroupBy
//  
//                SWQLNode_GroupBy
//               /                \
//        SWQLNode_ColumnList    SWQLNode_Having
//                               or NULL
//
//***************************************************************************

#define TYPE_SWQLNode_GroupBy (WQL_TOK_BASE + 13)

struct SWQLNode_GroupBy : SWQLNode
{
    // left ptr is SWQLNode_ColumnList of columns to group by
    // right ptr is Having clause, if any

    SWQLNode_GroupBy() { m_dwNodeType = TYPE_SWQLNode_GroupBy; }
    void DebugDump();
};

//***************************************************************************
//
//  SWQLNode_Having
//  
//                SWQLNode_Having
//               /               \
//           SWQLNode_RelExpr    NULL
//
//***************************************************************************

#define TYPE_SWQLNode_Having (WQL_TOK_BASE + 14)

struct SWQLNode_Having : SWQLNode
{
    // left ptr is SQLNode_RelExpr pointing to HAVING expressions
    // right ptr is NULL

    SWQLNode_Having() { m_dwNodeType = TYPE_SWQLNode_Having; }
    void DebugDump();
};



//***************************************************************************
//
//  SWQLNode_OrderBy
//  
//                SWQLNode_OrderBy
//               /                \
//      SWQLNode_ColumnList       NULL
//
//***************************************************************************

#define TYPE_SWQLNode_OrderBy (WQL_TOK_BASE + 15)

struct SWQLNode_OrderBy : SWQLNode
{
    // left ptr is SWQLNode_ColumnList 
    // right ptr is NULL
    SWQLNode_OrderBy() { m_dwNodeType = TYPE_SWQLNode_OrderBy; }
    void DebugDump();
};

//***************************************************************************
//
//  SWQLNode_Datepart 
//
//  Contains a datepart call.
//
//***************************************************************************
#define TYPE_SWQLNode_Datepart  (WQL_TOK_BASE + 16)

struct SWQLNode_Datepart : SWQLNode
{
    int m_nDatepart;        // One of WQL_TOK_YEAR, WQL_TOK_MONTH, 
                            // WQL_TOK_DAY, WQL_TOK_HOUR, WQL_TOK_MINUTE
                            // WQL_TOK_SECOND

    SWQLColRef *m_pColRef;  // The column to which DATEPART applies
    
    SWQLNode_Datepart() { m_dwNodeType = TYPE_SWQLNode_Datepart; m_nDatepart = 0; }
   ~SWQLNode_Datepart() { delete m_pColRef; }

    void DebugDump();    
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\wqlscan\wqllex.old.h ===
/*++

Copyright (C) 1997-2001 Microsoft Corporation

Module Name:

    WQLLEX.CPP

Abstract:

    WQL DFA Table

History:

	raymcc    14-Sep-97       Created.

--*/

#ifndef _WQLLEX_H_

#include <genlex.h>
#define WQL_TOK_EOF           0
#define WQL_TOK_ERROR         1


#define WQL_TOK_SELECT                      256
#define WQL_TOK_ALL                         257
#define WQL_TOK_DISTINCT                    258
#define WQL_TOK_OPTIONS_DUMMY               259
#define WQL_TOK_ASTERISK                    260
#define WQL_TOK_COUNT                       261
#define WQL_TOK_COMMA                       262
#define WQL_TOK_OPEN_PAREN                  263
#define WQL_TOK_CLOSE_PAREN                 264
#define WQL_TOK_IDENT                       265
#define WQL_TOK_DOT                         266
#define WQL_TOK_FROM                        267
#define WQL_TOK_AS                          268
#define WQL_TOK_INNER                       269
#define WQL_TOK_FULL                        270
#define WQL_TOK_LEFT                        271
#define WQL_TOK_RIGHT                       272
#define WQL_TOK_OUTER                       273
#define WQL_TOK_JOIN                        274
#define WQL_TOK_ON                          275
#define WQL_TOK_WHERE                       276
#define WQL_TOK_GROUP                       277
#define WQL_TOK_BY                          278
#define WQL_TOK_HAVING                      279
#define WQL_TOK_ORDER                       280
#define WQL_TOK_OR                          281
#define WQL_TOK_AND                         282
#define WQL_TOK_NOT                         283
#define WQL_TOK_LE                          284
#define WQL_TOK_LT                          285
#define WQL_TOK_GE                          286
#define WQL_TOK_GT                          287
#define WQL_TOK_EQ                          288
#define WQL_TOK_NE                          289
#define WQL_TOK_LIKE                        290
#define WQL_TOK_IS                          291
#define WQL_TOK_BEFORE                      292
#define WQL_TOK_AFTER                       293
#define WQL_TOK_BETWEEN                     294
#define WQL_TOK_QSTRING                     295
#define WQL_TOK_INT                         296
#define WQL_TOK_REAL                        297
#define WQL_TOK_CHAR                        298
#define WQL_TOK_NULL                        299
#define WQL_TOK_OPEN_BRACKET                300
#define WQL_TOK_CLOSE_BRACKET               301
#define WQL_TOK_ISA                         302
#define WQL_TOK_A                           303
#define WQL_TOK_DAY                         304
#define WQL_TOK_MONTH                       305
#define WQL_TOK_YEAR                        306
#define WQL_TOK_HOUR                        307
#define WQL_TOK_MINUTE                      308
#define WQL_TOK_SECOND                      309
#define WQL_TOK_MILLISECOND                 310

#define WQL_TOK_UPPER                       311
#define WQL_TOK_LOWER                       312
#define WQL_TOK_DATEPART                    313
#define WQL_TOK_QUALIFIER                   314
#define WQL_TOK_ISNULL                      315
#define WQL_TOK_IN                          316

#define WQL_TOK_NOT_LIKE                    317
#define WQL_TOK_NOT_BEFORE                  318
#define WQL_TOK_NOT_AFTER                   319
#define WQL_TOK_NOT_BETWEEN                 320
#define WQL_TOK_NOT_NULL                    321
#define WQL_TOK_NOT_IN                      322
#define WQL_TOK_NOT_A                       323

#define WQL_TOK_TYPED_EXPR                  324


#define WQL_TOK_IN_SUBSELECT                325
#define WQL_TOK_NOT_IN_SUBSELECT            326
#define WQL_TOK_IN_CONST_LIST               327
#define WQL_TOK_NOT_IN_CONST_LIST           328

#define WQL_TOK_FIRSTROW                    329

extern LexEl WQL_LexTable[];


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\xfiles\a51fib.h ===
/*++

Copyright (C) 2000-2001 Microsoft Corporation

--*/

#ifndef __A51_FIBER__H_
#define __A51_FIBER__H_

class CFiberTask
{
public:
    virtual ~CFiberTask(){}
    virtual HRESULT Execute() = 0;
};

void* CreateFiberForTask(CFiberTask* pTask);
void ReturnFiber(void* pFiber);


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\xfiles\a51tools.h ===
/*++

Copyright (C) 2000-2001 Microsoft Corporation

--*/

#ifndef __A51_TOOLS__H_
#define __A51_TOOLS__H_

#include <sync.h>
#include <newnew.h>
#include <xmemory>

#ifdef DBG
  #define _A51_INTERNAL_ASSERT
#endif

typedef LONGLONG TFileOffset;

#define MAX_HASH_LEN 32

void* TempAlloc(DWORD dwLen);
void TempFree(void* p, DWORD dwLen = 0);

void* TempAlloc(CTempMemoryManager& Manager, DWORD dwLen);
void TempFree(CTempMemoryManager& Manager, void* p, DWORD dwLen = 0);

HRESULT A51TranslateErrorCode(long lRes);

#define TEMPFREE_ME

class CTempFreeMe
{
protected:
    void* m_p;
    DWORD m_dwLen;
public:
    CTempFreeMe(void* p, DWORD dwLen = 0) : m_p(p), m_dwLen(dwLen){}
    ~CTempFreeMe() {TempFree(m_p, m_dwLen);}
};

HANDLE A51GetNewEvent();
void A51ReturnEvent(HANDLE hEvent);

class CReturnMe
{
protected:
    HANDLE m_h;
public:
    CReturnMe(HANDLE h) : m_h(h){}
    ~CReturnMe() {A51ReturnEvent(m_h);}
};


inline void wbem_wcsupr(WCHAR* pwcTo, const WCHAR* pwcFrom)
{
    while(*pwcFrom)
    {
        if(*pwcFrom >= 'a' && *pwcFrom <= 'z')
            *pwcTo = *pwcFrom + ('A'-'a');
        else if(*pwcFrom < 128)
            *pwcTo = *pwcFrom;
        else 
            *pwcTo = towupper(*pwcFrom);
        pwcTo++;
        pwcFrom++;
    }
    *pwcTo = 0;
}

class CFileName
{
private:
	wchar_t *m_wszFilename;

public:
	DWORD Length() { return MAX_PATH + 1; }
	CFileName() { m_wszFilename = (wchar_t*)TempAlloc(sizeof(wchar_t) * Length()); }
	~CFileName() { TempFree(m_wszFilename, sizeof(wchar_t) * Length()); }
	operator wchar_t *() { return m_wszFilename; }
};

long EnsureDirectory(LPCWSTR wszPath, LPSECURITY_ATTRIBUTES pSA = NULL);
long EnsureDirectoryForFile(LPCWSTR wszPath, LPSECURITY_ATTRIBUTES pSA = NULL);
bool A51Hash(LPCWSTR wszName, LPWSTR wszHash);
long A51DeleteFile(LPCWSTR wszFullPath);
long A51WriteFile(LPCWSTR wszFullPath, DWORD dwLen, BYTE* pBuffer);
long A51RemoveDirectory(LPCWSTR wszFullPath, bool bAbortOnFiles = true);
long A51WriteToFileAsync(HANDLE hFile, long lStartingOffset, BYTE* pBuffer,
                        DWORD dwBufferLen, OVERLAPPED* pov);
long A51WriteToFileSync(HANDLE hFile, long lStartingOffset, BYTE* pBuffer,
                        DWORD dwBufferLen);
long A51ReadFromFileAsync(HANDLE hFile, long lStartingOffset, BYTE* pBuffer,
                        DWORD dwBufferLen, OVERLAPPED* pov);
long A51ReadFromFileSync(HANDLE hFile, long lStartingOffset, BYTE* pBuffer,
                        DWORD dwBufferLen);

extern __int64 g_nCurrentTime;

#undef _ASSERT

#ifdef _A51_INTERNAL_ASSERT
#define _ASSERT(X, MSG) {if(!(X)) {A51TraceFlush(); DebugBreak();}}
#else
#define _ASSERT(X, MSG)
#endif

extern FILE* g_fLog;

#ifdef _A51_INTERNAL_DEBUG
#define A51TRACE(X) A51Trace X
#else
#define A51TRACE(X)
#endif

void A51Trace(LPCSTR szFormat, ...);

void A51TraceFlush();

template<class T>
class CTempAllocator
{
public:
    typedef size_t size_type;
    typedef ptrdiff_t difference_type;
    typedef T *pointer;
    typedef const T *const_pointer;
    typedef T& reference;
    typedef const T& const_reference;
    typedef T value_type;

    char* _Charalloc(size_t n)
    {
        return (char*)TempAlloc(n);
    }

    void deallocate(void* p, size_t n)
    {
        TempFree(p, 0);
    }

    void construct(pointer p, const T& val)
    {
        new ((void*)p) T(val);
    }

    void destroy(pointer p)
    {
        p->T::~T();
    }
};

template<class T>
class CPrivateTempAllocator
{
public:
    typedef size_t size_type;
    typedef ptrdiff_t difference_type;
    typedef T *pointer;
    typedef const T *const_pointer;
    typedef T& reference;
    typedef const T& const_reference;
    typedef T value_type;

    CPrivateTempAllocator(CTempMemoryManager* pManager) 
        : m_pManager(pManager)
    {}
    
    char* _Charalloc(size_t n)
    {
        return (char*)m_pManager->Allocate(n);
    }

    void deallocate(void* p, size_t n)
    {
        m_pManager->Free(p, 0);
    }

    void construct(pointer p, const T& val)
    {
        new ((void*)p) T(val);
    }

    void destroy(pointer p)
    {
        p->T::~T();
    }
protected:
    CTempMemoryManager* m_pManager;
};

#ifdef A51_CHECK_HRESULTS

class CHR
{
protected:
    HRESULT m_hres;
    bool m_bTested;

public:
    CHR(HRESULT hres) : m_hres(hres), m_bTested(false){}
    ~CHR() {_ASSERT(m_bTested, L"");}
    operator HRESULT() {m_bTested = true; return m_hres;}
};
        
#else

typedef HRESULT CHR;

#endif
    
            
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\wqlscan\wqlscan.cpp ===
/*++

Copyright (C) 1997-2001 Microsoft Corporation

Module Name:

    WQLSCAN.CPP

Abstract:

    WQL Prefix Scanner

    This module implements a specially cased shift-reduce parser to
    parse out selected columns, JOINed tables and aliases, while ignoring
    the rest of the query.

History:

    raymcc    17-Oct-97       SMS extensions.

--*/


#include "precomp.h"
#include <stdio.h>

#include <flexarry.h>
#include <wqllex.h>
#include <wqlnode.h>
#include <wqlscan.h>

inline wchar_t *Macro_CloneLPWSTR(LPCWSTR src)
{
    if (!src)
        return 0;
    wchar_t *dest = new wchar_t[wcslen(src) + 1];
    if (!dest)
        return 0;
    return wcscpy(dest, src);
}


#define trace(x) printf x


class CTokenArray : public CFlexArray
{
public:
    ~CTokenArray() { Empty(); }
    void Empty()
    {
        for (int i = 0; i < Size(); i++) delete PWSLexToken(GetAt(i));
        CFlexArray::Empty();
    }
};

//***************************************************************************
//
//  CWQLScanner::CWQLScanner
//
//  Constructor
//
//  Parameters:
//  <pSrc>          A source from which to lex from.
//
//***************************************************************************

CWQLScanner::CWQLScanner(CGenLexSource *pSrc)
{
    m_pLexer = new CGenLexer(WQL_LexTable, pSrc);
    m_nLine = 0;
    m_pTokenText = 0;
    m_nCurrentToken = 0;
    m_bCount = FALSE;
}

//***************************************************************************
//
//  CWQLScanner::~CWQLScanner
//
//***************************************************************************


CWQLScanner::~CWQLScanner()
{
    delete m_pLexer;

    ClearTokens();
    ClearTableRefs();
    ClearPropRefs();
}

//***************************************************************************
//
//***************************************************************************

BOOL CWQLScanner::GetReferencedAliases(CWStringArray &aAliases)
{
    for (int i = 0; i < m_aTableRefs.Size(); i++)
    {
        WSTableRef *pTRef = (WSTableRef *) m_aTableRefs[i];
        aAliases.Add(pTRef->m_pszAlias);
    }
    return TRUE;
}
//***************************************************************************
//
//***************************************************************************

BOOL CWQLScanner::GetReferencedTables(CWStringArray &aClasses)
{
    for (int i = 0; i < m_aTableRefs.Size(); i++)
    {
        WSTableRef *pTRef = (WSTableRef *) m_aTableRefs[i];
        aClasses.Add(pTRef->m_pszTable);
    }
    return TRUE;
}

//***************************************************************************
//
//***************************************************************************
void CWQLScanner::ClearTokens()
{
    for (int i = 0; i < m_aTokens.Size(); i++)
        delete (WSLexToken *) m_aTokens[i];
}

//***************************************************************************
//
//***************************************************************************
void CWQLScanner::ClearPropRefs()
{
    for (int i = 0; i < m_aPropRefs.Size(); i++)
        delete (SWQLColRef *) m_aPropRefs[i];
}

//***************************************************************************
//
//***************************************************************************

void CWQLScanner::ClearTableRefs()
{
    for (int i = 0; i < m_aTableRefs.Size(); i++)
        delete (WSTableRef *) m_aTableRefs[i];
    m_aTableRefs.Empty();
}

//***************************************************************************
//
//  Next()
//
//  Advances to the next token and recognizes keywords, etc.
//
//***************************************************************************

struct WqlKeyword
{
    LPWSTR m_pKeyword;
    int    m_nTokenCode;
};

static WqlKeyword KeyWords[] =      // Keep this alphabetized for binary search
{
    L"ALL",      WQL_TOK_ALL,
    L"AND",      WQL_TOK_AND,
    L"AS",       WQL_TOK_AS,
    L"BETWEEN",  WQL_TOK_BETWEEN,
    L"BY",       WQL_TOK_BY,
    L"COUNT",    WQL_TOK_COUNT,
    L"DATEPART", WQL_TOK_DATEPART,
    L"DISTINCT", WQL_TOK_DISTINCT,
    L"FIRSTROW", WQL_TOK_FIRSTROW,
    L"FROM",     WQL_TOK_FROM,
    L"FULL",     WQL_TOK_FULL,
    L"GROUP",    WQL_TOK_GROUP,
    L"HAVING",   WQL_TOK_HAVING,
    L"IN",       WQL_TOK_IN,
    L"INNER",    WQL_TOK_INNER,
    L"IS",       WQL_TOK_IS,
    L"ISA",      WQL_TOK_ISA,
    L"ISNULL",   WQL_TOK_ISNULL,
    L"JOIN",     WQL_TOK_JOIN,
    L"LEFT",     WQL_TOK_LEFT,
    L"LIKE",     WQL_TOK_LIKE,
    L"LOWER",    WQL_TOK_LOWER,
    L"NOT",      WQL_TOK_NOT,
    L"NULL",     WQL_TOK_NULL,
    L"ON",       WQL_TOK_ON,
    L"OR",       WQL_TOK_OR,
    L"ORDER",    WQL_TOK_ORDER,
    L"OUTER",    WQL_TOK_OUTER,
    L"QUALIFIER", WQL_TOK_QUALIFIER,
    L"RIGHT",    WQL_TOK_RIGHT,
    L"SELECT",   WQL_TOK_SELECT,
    L"UNION",    WQL_TOK_UNION,
    L"UPPER",    WQL_TOK_UPPER,
    L"WHERE",    WQL_TOK_WHERE

};

const int NumKeywords = sizeof(KeyWords)/sizeof(WqlKeyword);

BOOL CWQLScanner::Next()
{
    if (!m_pLexer)
        return FALSE;

    m_nCurrentToken = m_pLexer->NextToken();
    if (m_nCurrentToken == WQL_TOK_ERROR)
        return FALSE;

    m_nLine = m_pLexer->GetLineNum();
    m_pTokenText = m_pLexer->GetTokenText();
    if (m_nCurrentToken == WQL_TOK_EOF)
        m_pTokenText = L"<end of file>";

    // Keyword check. Do a binary search
    // on the keyword table.
    // =================================

    if (m_nCurrentToken == WQL_TOK_IDENT)
    {
        int l = 0, u = NumKeywords - 1;

        while (l <= u)
        {
            int m = (l + u) / 2;
            if (_wcsicmp(m_pTokenText, KeyWords[m].m_pKeyword) < 0)
                u = m - 1;
            else if (_wcsicmp(m_pTokenText, KeyWords[m].m_pKeyword) > 0)
                l = m + 1;
            else        // Match
            {
                m_nCurrentToken = KeyWords[m].m_nTokenCode;
                break;
            }
        }
    }

    return TRUE;
}

//***************************************************************************
//
//  CWQLScanner::ExtractNext
//
//***************************************************************************

PWSLexToken CWQLScanner::ExtractNext()
{
    if (m_aTokens.Size() == 0)
        return NULL;

    PWSLexToken pTok = PWSLexToken(m_aTokens[0]);
    m_aTokens.RemoveAt(0);
    return pTok;
}

//***************************************************************************
//
//  CWQLScanner::Pushback
//
//***************************************************************************

void CWQLScanner::Pushback(PWSLexToken pPushbackTok)
{
    m_aTokens.InsertAt(0, pPushbackTok);
}

//***************************************************************************
//
//  Shift-reduce parser entry.
//
//***************************************************************************

int CWQLScanner::Parse()
{
    int nRes = SYNTAX_ERROR;
    if (m_pLexer == NULL)
        return FAILED;

    m_pLexer->Reset();

    if (!Next())
        return LEXICAL_ERROR;


    // Completely tokenize the entire query and build a parse-stack.
    // =============================================================

    if (m_nCurrentToken == WQL_TOK_SELECT)
    {
        while (1)
        {
            WSLexToken *pTok = new WSLexToken;
            if (!pTok)
                return FAILED;

            pTok->m_nToken = m_nCurrentToken;
            pTok->m_pszTokenText = Macro_CloneLPWSTR(m_pTokenText);

            m_aTokens.Add(pTok);

            if (m_nCurrentToken == WQL_TOK_EOF)
                break;

            if (!Next())
                return LEXICAL_ERROR;
        }
    }
    else
        return SYNTAX_ERROR;

    // Reduce by extracting the select type keywords if possible.
    // ==========================================================

    nRes = ExtractSelectType();
    if (nRes)
        return nRes;

    // Eliminate all tokens from WHERE onwards.
    // ========================================

    StripWhereClause();

    // Reduce by extracting the select list.
    // =====================================

    if (!m_bCount)
    {
        nRes = SelectList();
        if (nRes != 0)
            return nRes;
    }
    else
    {
        // Strip everything until the FROM keyword is encountered.
        // =======================================================

        WSLexToken *pTok = ExtractNext();


        while (pTok)
        {
            if (pTok->m_nToken == WQL_TOK_FROM)
            {
                Pushback(pTok);
                break;
            }
            // Bug #46728: the count(*) clause
            // can be the only element of the select clause.

            else if (!wcscmp(pTok->m_pszTokenText, L","))
            {
                delete pTok;
                return SYNTAX_ERROR;
            }

            delete pTok;
            pTok = ExtractNext();
        }
        if (pTok == 0)
            return SYNTAX_ERROR;
    }

    // Extract tables/aliases from JOIN clauses.
    // =========================================

    if (ReduceSql89Joins() != TRUE)
    {
        ClearTableRefs();
        if (ReduceSql92Joins() != TRUE)
            return SYNTAX_ERROR;
    }


    // Post process select clause to determine if
    // columns are tables or aliases.
    // ==========================================
    for (int i = 0; i < m_aPropRefs.Size(); i++)
    {
        SWQLColRef *pCRef = (SWQLColRef *) m_aPropRefs[i];
        if (pCRef->m_pTableRef != 0)
        {
            LPWSTR pTbl = AliasToTable(pCRef->m_pTableRef);
            if (pTbl == 0)
                continue;

            if (_wcsicmp(pTbl, pCRef->m_pTableRef) == 0)
                pCRef->m_dwFlags |= WQL_FLAG_TABLE;
            else
                pCRef->m_dwFlags |= WQL_FLAG_ALIAS;
        }
    }


    if (m_aTableRefs.Size() == 0)
        return SYNTAX_ERROR;


    return SUCCESS;
}

//***************************************************************************
//
//  CWQLScanner::StripWhereClause
//
//  If present, removes the WHERE or ORDER BY clause.  Because
//  of SQL Syntax, stripping the first of {ORDER BY, WHERE} will automatically
//  get rid of the other.
//
//***************************************************************************
BOOL CWQLScanner::StripWhereClause()
{
    for (int i = 0; i < m_aTokens.Size(); i++)
    {
        WSLexToken *pCurrent = (WSLexToken *) m_aTokens[i];

        // If a WHERE token is found, we have something to strip.
        // ======================================================

        if (pCurrent->m_nToken == WQL_TOK_WHERE ||
            pCurrent->m_nToken == WQL_TOK_ORDER)
        {
            int nNumTokensToRemove = m_aTokens.Size() - i - 1;
            for (int i2 = 0; i2 < nNumTokensToRemove; i2++)
            {
                delete PWSLexToken(m_aTokens[i]);
                m_aTokens.RemoveAt(i);
            }
            return TRUE;
        }
    }

    return FALSE;
}


//***************************************************************************
//
//  CWQLScanner::ExtractSelectType
//
//  Examines the prefix to reduce the query by eliminating the SELECT
//  and select-type keywords, such as ALL, DISTINCT, FIRSTROW, COUNT
//
//  If COUNT is used, move past the open-close parentheses.
//
//***************************************************************************

int CWQLScanner::ExtractSelectType()
{
    // Verify that SELECT is the first token.
    // ======================================

    WSLexToken *pFront = ExtractNext();

    if (pFront == 0 || pFront->m_nToken == WQL_TOK_EOF)
    {
        delete pFront;
        return SYNTAX_ERROR;
    }

    if (pFront->m_nToken != WQL_TOK_SELECT)
    {
        delete pFront;
        return SYNTAX_ERROR;
    }

    delete pFront;

    // Check for possible select-type and extract it.
    // ==============================================

    pFront = ExtractNext();
    if (pFront == 0)
        return SYNTAX_ERROR;

    if (pFront->m_nToken == WQL_TOK_COUNT)
    {
        delete pFront;
        m_bCount = TRUE;
    }
    else if (pFront->m_nToken == WQL_TOK_ALL ||
        pFront->m_nToken == WQL_TOK_DISTINCT ||
        pFront->m_nToken == WQL_TOK_FIRSTROW
       )
        delete pFront;
    else
        Pushback(pFront);

    return SUCCESS;
}

//***************************************************************************
//
//  CWQLScanner::SelectList
//
//  Extracts all tokens up to the FROM keyword and builds a list
//  of selected properties/columns.  FROM is left on the parse-stack on exit.
//
//***************************************************************************

int CWQLScanner::SelectList()
{
    // If the first token is FROM, then we have a SELECT FROM <rest>
    // which is the same as SELECT * FROM <rest>.  We simply
    // alter the parse-stack and let the following loop handle it.
    // =============================================================

    WSLexToken *pTok = ExtractNext();

    if (pTok->m_nToken == WQL_TOK_FROM)
    {
        WSLexToken *pAsterisk = new WSLexToken;
        if (pAsterisk == NULL)
            return FAILED;

        pAsterisk->m_nToken = WQL_TOK_ASTERISK;
        pAsterisk->m_pszTokenText = Macro_CloneLPWSTR(L"*");
        Pushback(pTok);
        Pushback(pAsterisk);
    }
    else
        Pushback(pTok);

    // Otherwise, some kind of column selection is present.
    // ====================================================

    BOOL bTerminate = FALSE;

    while (!bTerminate)
    {
        pTok = ExtractNext();
        if (pTok == 0)
            return SYNTAX_ERROR;

        // We must begin at a legal token.
        // ===============================

        if (pTok->m_nToken != WQL_TOK_EOF)
        {
            CTokenArray Tokens;
            Tokens.Add(pTok);

            while (1)
            {
                pTok = ExtractNext();
                if (pTok == 0 || pTok->m_nToken == WQL_TOK_EOF)
                {
                    delete pTok;
                    return SYNTAX_ERROR;
                }
                if (pTok->m_nToken == WQL_TOK_FROM)
                {
                    Pushback(pTok);
                    bTerminate = TRUE;
                    break;
                }
                else if (pTok->m_nToken == WQL_TOK_COMMA)
                {
                    delete pTok;
                    break;
                }
                else
                    Tokens.Add(pTok);
            }

            SWQLColRef *pColRef = new SWQLColRef;
            if (pColRef == 0)
                return FAILED;

            BOOL bRes = BuildSWQLColRef(Tokens, *pColRef);
            if (bRes)
                m_aPropRefs.Add(pColRef);
            else
            {
                delete pColRef;
                return SYNTAX_ERROR;
            }
        }

        // Else an illegal token, such as WQL_TOK_EOF.
        // ===========================================
        else
        {
            delete pTok;
            return SYNTAX_ERROR;

        }
    }

    return SUCCESS;
}



//***************************************************************************
//
//  CWQLScanner::ReduceSql89Joins
//
//  Attempts to reduce the FROM clause, assuming it is based on SQL-89
//  join syntax or else a simple unary select.
//
//  The supported forms are:
//
//      FROM x
//      FROM x, y
//      FROM x as x1, y as y1
//      FROM x x1, y y1
//
//  If incompatible tokens are encountered, the entire function
//  returns FALSE and the results are ignored, and the parse-stack
//  is unaffected, in essence, allowing backtracking to try the SQL-92
//  syntax branch instead.
//
//***************************************************************************
BOOL CWQLScanner::ReduceSql89Joins()
{
    int i = 0;

    // Parse the FROM keyword.
    // =======================

    WSLexToken *pCurr = (WSLexToken *) m_aTokens[i++];
    if (pCurr->m_nToken != WQL_TOK_FROM)
        return FALSE;

    pCurr = (WSLexToken *) m_aTokens[i++];

    while (1)
    {
        if (pCurr->m_nToken != WQL_TOK_IDENT)
            return FALSE;

        // If here, we are looking at the beginnings of a table ref.
        // =========================================================

        WSTableRef *pTRef = new WSTableRef;
        if (pTRef == 0)
            return FAILED;

        pTRef->m_pszTable = Macro_CloneLPWSTR(pCurr->m_pszTokenText);
        pTRef->m_pszAlias = Macro_CloneLPWSTR(pCurr->m_pszTokenText);
        m_aTableRefs.Add(pTRef);

        // Attempt to recognize an alias.
        // ==============================

        pCurr = (WSLexToken *) m_aTokens[i++];
        if (pCurr == WQL_TOK_EOF || pCurr->m_nToken == WQL_TOK_UNION)
            break;

        if (pCurr->m_nToken == WQL_TOK_AS)
            pCurr = (WSLexToken *) m_aTokens[i++];

        if (pCurr->m_nToken == WQL_TOK_COMMA)
        {
            pCurr = (WSLexToken *) m_aTokens[i++];
            continue;
        }

        if (pCurr->m_nToken == WQL_TOK_EOF || pCurr->m_nToken == WQL_TOK_UNION)
            break;

        if (pCurr->m_nToken != WQL_TOK_IDENT)
            return FALSE;

        delete [] pTRef->m_pszAlias;
        pTRef->m_pszAlias = Macro_CloneLPWSTR(pCurr->m_pszTokenText);

        // We have completely parsed a table reference.
        // Now we move on to the next one.
        // ============================================

        pCurr = (WSLexToken *) m_aTokens[i++];

        if (pCurr->m_nToken == WQL_TOK_EOF || pCurr->m_nToken == WQL_TOK_UNION)
            break;

        if (pCurr->m_nToken != WQL_TOK_COMMA)
            return FALSE;

        pCurr = (WSLexToken *) m_aTokens[i++];
    }

    if (m_aTableRefs.Size())
        return TRUE;

    return FALSE;
}

//***************************************************************************
//
//  CWQLScanner::ReduceSql92Joins
//
//  This scans SQL-92 JOIN syntax looking for table aliases.   See the
//  algorithm at the end of this file.
//
//***************************************************************************

BOOL CWQLScanner::ReduceSql92Joins()
{
    WSLexToken *pCurrent = 0, *pRover = 0, *pRight = 0, *pLeft;
    int nNumTokens = m_aTokens.Size();
    DWORD dwNumJoins = 0;
    int iCurrBase = 0;

    for (int i = 0; i < nNumTokens; i++)
    {
        pCurrent = (WSLexToken *) m_aTokens[i];

        // If a JOIN token is found, we have a candidate.
        // ==============================================

        if (pCurrent->m_nToken == WQL_TOK_JOIN)
        {
            dwNumJoins++;

            // Analyze right-context.
            // ======================

            if (i + 1 < nNumTokens)
                pRover = PWSLexToken(m_aTokens[i + 1]);
            else
                pRover = NULL;

            if (pRover && pRover->m_nToken == WQL_TOK_IDENT)
            {
                // Check for aliased table by checking for
                // AS or two juxtaposed idents.
                // =======================================

                if (i + 2 < nNumTokens)
                    pRight = PWSLexToken(m_aTokens[i + 2]);
                else
                    pRight = NULL;


                if (pRight && pRight->m_nToken == WQL_TOK_AS)
                {
                    if (i + 3 < nNumTokens)
                        pRight = PWSLexToken(m_aTokens[i + 3]);
                    else
                        pRight = NULL;
                }

                if (pRight && pRight->m_nToken == WQL_TOK_IDENT)
                {
                    WSTableRef *pTRef = new WSTableRef;
                    if (pTRef == 0)
                        return FAILED;
                    pTRef->m_pszAlias = Macro_CloneLPWSTR(pRight->m_pszTokenText);
                    pTRef->m_pszTable = Macro_CloneLPWSTR(pRover->m_pszTokenText);
                    m_aTableRefs.Add(pTRef);
                }
                else    // An alias wasn't used, just a simple table ref.
                {
                    WSTableRef *pTRef = new WSTableRef;
                    if (pTRef == 0)
                        return FAILED;

                    pTRef->m_pszAlias = Macro_CloneLPWSTR(pRover->m_pszTokenText);
                    pTRef->m_pszTable = Macro_CloneLPWSTR(pRover->m_pszTokenText);
                    m_aTableRefs.Add(pTRef);
                }
                // discontinue analysis of right-context.
            }


            // Analyze left-context.
            // =====================

            int nLeft = i - 1;

            if (nLeft >= 0)
                pRover = PWSLexToken(m_aTokens[nLeft--]);
            else
                continue;   // No point in continuing

            // Verify the ANSI join syntax.

            if (nLeft)
            {
                int iTemp = nLeft;
                WSLexToken *pTemp = pRover;
                bool bInner = false;
                bool bDir = false;
                bool bOuter = false;
                bool bFail = false;
                bool bIdent = false;
                while (iTemp >= iCurrBase)
                {
                    if (pTemp->m_nToken == WQL_TOK_INNER)
                    {
                        if (bOuter || bIdent || bInner)
                            bFail = TRUE;
                        bInner = true;
                    }
                    else if (pTemp->m_nToken == WQL_TOK_OUTER)
                    {
                        if (bInner || bIdent || bOuter)
                            bFail = TRUE;
                        bOuter = true;
                    }
                    else if (pTemp->m_nToken == WQL_TOK_FULL  ||
                        pTemp->m_nToken == WQL_TOK_LEFT  ||
                        pTemp->m_nToken == WQL_TOK_RIGHT
                        )
                    {
                        if (bDir || bIdent)
                            bFail = TRUE;
                        bDir = true;
                    }
                    else
                        bIdent = TRUE;

                    // We are trying to enforce correct ANSI-92 joins
                    // even though we don't support them ourselves:
                    // OK:  LEFT OUTER JOIN
                    //      OUTER LEFT JOIN
                    //      LEFT JOIN
                    //      INNER JOIN
                    // NOT: LEFT LEFT JOIN
                    //      LEFT INNER JOIN
                    //      LEFT RIGHT JOIN
                    //      OUTER INNER JOIN
                    //      OUTER LEFT OUTER JOIN
                    //      OUTER GARBAGE LEFT JOIN
                    //      (no right side)

                    if ((bDir && bInner) || bFail)
                        return FALSE;

                    pTemp = PWSLexToken(m_aTokens[iTemp--]);
                }

            }

            // Skip past potential JOIN modifiers : INNER, OUTER,
            // FULL, LEFT, RIGHT
            // ==================================================

            if (pRover->m_nToken == WQL_TOK_INNER ||
                pRover->m_nToken == WQL_TOK_OUTER ||
                pRover->m_nToken == WQL_TOK_FULL  ||
                pRover->m_nToken == WQL_TOK_LEFT  ||
                pRover->m_nToken == WQL_TOK_RIGHT
                )
            {
                if (nLeft >= 0)
                    pRover = PWSLexToken(m_aTokens[nLeft--]);
                else
                    pRover = 0;
            }

            if (pRover->m_nToken == WQL_TOK_INNER ||
                pRover->m_nToken == WQL_TOK_OUTER ||
                pRover->m_nToken == WQL_TOK_FULL  ||
                pRover->m_nToken == WQL_TOK_LEFT  ||
                pRover->m_nToken == WQL_TOK_RIGHT
                )
            {
                if (nLeft >= 0)
                    pRover = PWSLexToken(m_aTokens[nLeft--]);
                else
                    pRover = 0;
            }

            // Now we look to see if the roving pointer is pointing
            // to an ident.
            // ====================================================

            if (pRover && pRover->m_nToken != WQL_TOK_IDENT)
            {
                // No chance that we are looking at an aliased
                // table in a JOIN clause.
                // ===========================================
                continue;
            }

            iCurrBase = i;

            // If here, we are now possibliy looking at the second half
            // of an alias, the 'alias' name proper.  We mark this
            // by leaving pRover alone and continue to move into the
            // left context with a different pointer.
            // ========================================================

            if (nLeft >= 0)
                pLeft = PWSLexToken(m_aTokens[nLeft--]);
            else
                pLeft = 0;

            if (pLeft && pLeft->m_nToken == WQL_TOK_AS)
            {
                if (nLeft >= 0)
                    pLeft = PWSLexToken(m_aTokens[nLeft--]);
                else
                    pLeft = 0;
            }

            // The critical test.  Are we at an ident?
            // =======================================

            if (pLeft && pLeft->m_nToken == WQL_TOK_IDENT)
            {
                WSTableRef *pTRef = new WSTableRef;
                if (pTRef == 0)
                    return FAILED;

                pTRef->m_pszAlias = Macro_CloneLPWSTR(pRover->m_pszTokenText);
                pTRef->m_pszTable = Macro_CloneLPWSTR(pLeft->m_pszTokenText);
                m_aTableRefs.Add(pTRef);
            }
            else if (pLeft && pLeft->m_nToken == WQL_TOK_FROM)
            {
                WSTableRef *pTRef = new WSTableRef;
                if (pTRef == 0)
                    return FAILED;

                pTRef->m_pszAlias = Macro_CloneLPWSTR(pRover->m_pszTokenText);
                pTRef->m_pszTable = Macro_CloneLPWSTR(pRover->m_pszTokenText);
                m_aTableRefs.Add(pTRef);
                if (nLeft >= 0)
                {
                    pLeft = PWSLexToken(m_aTokens[nLeft--]);
                    if (pLeft && pLeft->m_nToken == WQL_TOK_FROM)
                        return FALSE;
                }
            }
        }

        // Find next JOIN occurrence
    }

    // Make sure there are two sides to every join reference.

    if (dwNumJoins+1 != (DWORD)m_aTableRefs.Size())
        return FALSE;

    return TRUE;
}


//***************************************************************************
//
//***************************************************************************
void CWQLScanner::Dump()
{
    WSLexToken *pCurrent = 0;

    printf("---Token Stream----\n");

    for (int i = 0; i < m_aTokens.Size(); i++)
    {
        pCurrent = (WSLexToken *) m_aTokens[i];

        printf("Token %d <%S>\n", pCurrent->m_nToken, pCurrent->m_pszTokenText);
    }

    printf("---Table Refs---\n");

    for (i = 0; i < m_aTableRefs.Size(); i++)
    {
        WSTableRef *pTRef = (WSTableRef *) m_aTableRefs[i];
        printf("Table = %S  Alias = %S\n", pTRef->m_pszTable, pTRef->m_pszAlias);
    }


    if (!m_bCount)
    {
        printf("---Select List---\n");

        for (i = 0; i < m_aPropRefs.Size(); i++)
        {
            SWQLColRef *pCRef = (SWQLColRef *) m_aPropRefs[i];
            pCRef->DebugDump();
        }
    }
    else
        printf(" -> COUNT query\n");

    printf("\n\n---<end of dump>---\n\n");
}


/*---------------------------------------------------------------------------

   Algorithm for detecting aliased tables in SQL-92 join syntax.

   The JOIN keyword must appear.

   It may appear in several contexts which are not
   relevant to the aliasing problem, such as the following:

     select distinct t1a.name, t2a.id, t3.value from
       (t1 as t1a join t2 as t2a on t1a.name = t2a.name)
       join
       (t1 as t1b join t3 on t1b.id = t3.id and (t3.id = t1b.id or t1b.id = t3.id))
       on
       t1a.id = t3.id
     where a = b and c = d

   where the middle join is against anonymous result sets.

   When analyzing the JOIN, we can easily parse the right-context.  Either
   an identifier follows (possibly further followed by AS),and an optional
   identifier if the JOIN is aliased.  Otherwise, we hit ON immediately, or
   a parenthesis.

   The problem is the left-context of the JOIN token.

   For an alias to occur, an identifier must appear immediately to
   the left of the JOIN.

     id JOIN id2 as id3 ON ...
     ^

   If here, there is a chance we are looking at the left hand side of a
   SQL92 join, a table reference.  However, we might be looking at the end of
   an ON clause which ends in an identifier:

     idx = id JOIN id2 as id3 ON...
         ^
   To disambiguate, we have to do further analysis of left context.

   Consider the follow left-context possibilities:

        (1) t1 AS id JOIN id2 as id3 ON
               ^
        (2) t1 id JOIN id2 as id3 ON
            ^
        (3) <keyword (except AS)> id JOIN id2 as id3 ON
             ^
        (4) on x <rel op> id JOIN id2 as id3 ON
                  ^

   Once we have identified <id>, we have to consider the above cases.

   (1) Case 1 is easy.  An AS clearly tells us we have an alias
       and we know how to get at the table and alias names.

   (2) Case 2 is easy.  Two juxtaposed identifiers to the left always
       indicates an alias.

   In all other cases, like (3) and (4), etc., the table is not
   aliased anyway.  Therefore, we only have to determine whether we
   are looking at an unaliased table name or the trailing end of
   another construct like an ON clause.  This is easy.  Only the
   FROM keyword can precede <id> if <id> is a simple table name.

---------------------------------------------------------------------------
*/




//***************************************************************************
//
//  SWQLQualifiedName::Empty
//
//***************************************************************************

void SWQLQualifiedName::Empty()
{
    for (int i = 0; i < m_aFields.Size(); i++)
        delete (SWQLQualifiedNameField *) m_aFields[i];
}


//***************************************************************************
//
//  CWQLScanner::BuildSWQLColRef
//
//***************************************************************************

BOOL CWQLScanner::BuildSWQLColRef(
    IN  CFlexArray     &aTokens,
    IN OUT SWQLColRef  &ColRef      // Empty on entry
    )
{
    if (aTokens.Size() == 0)
        return FALSE;
    int nCurrent = 0;
    WSLexToken *pTok = PWSLexToken(aTokens[nCurrent++]);

    // Initial state: single asterisk or else prop name.
    // =================================================

    if (pTok->m_nToken == WQL_TOK_ASTERISK && aTokens.Size() == 1)
    {
        ColRef.m_pColName = Macro_CloneLPWSTR(L"*");
        ColRef.m_dwFlags = WQL_FLAG_ASTERISK;
        ColRef.m_pQName = new SWQLQualifiedName;
        if (ColRef.m_pQName == 0)
            return FALSE;
        SWQLQualifiedNameField *pField = new SWQLQualifiedNameField;
        if (pField == 0)
            return FALSE;

        pField->m_pName = Macro_CloneLPWSTR(L"*");
        ColRef.m_pQName->Add(pField);
        return TRUE;
    }

    // If not an identifier, we have an error.
    // =======================================

    else if (pTok->m_nToken == WQL_TOK_EOF)
        return FALSE;

    // If here, we have an identifier.
    // ===============================

    ColRef.m_pQName = new SWQLQualifiedName;
    if (ColRef.m_pQName == NULL)
        return FALSE;
    SWQLQualifiedNameField *pField = new SWQLQualifiedNameField;
    if (pField == 0)
        return FALSE;

    pField->m_pName = Macro_CloneLPWSTR(pTok->m_pszTokenText);
    ColRef.m_pQName->Add(pField);

    // Subsequent states.
    // ==================

    while (1)
    {
        if (nCurrent == aTokens.Size())
            break;

        pTok = PWSLexToken(aTokens[nCurrent++]);

        if (pTok->m_nToken == WQL_TOK_DOT)
        {
            pField = new SWQLQualifiedNameField;
            if (pField == 0)
                return FALSE;

            ColRef.m_pQName->Add(pField);

            if (nCurrent == aTokens.Size())
                return FALSE;
            pTok = PWSLexToken(aTokens[nCurrent++]);
            if (pTok->m_nToken != WQL_TOK_IDENT &&
                pTok->m_nToken != WQL_TOK_ASTERISK
                )
                return FALSE;

            pField->m_pName = Macro_CloneLPWSTR(pTok->m_pszTokenText);
        }
        else if (pTok->m_nToken == WQL_TOK_OPEN_BRACKET)
        {
            return FALSE; // Not supported at present!
        }
        else // illegal token
            return FALSE;
    }

    // Post-process.  If the name is not complex, then we
    // can fill out fields of ColRef.
    // ==================================================
    if (ColRef.m_pQName->GetNumNames() == 2)
    {
        ColRef.m_pTableRef = Macro_CloneLPWSTR(ColRef.m_pQName->GetName(0));
        ColRef.m_pColName  = Macro_CloneLPWSTR(ColRef.m_pQName->GetName(1));
        if (_wcsicmp(ColRef.m_pColName, L"NULL") == 0)
            ColRef.m_dwFlags |= WQL_FLAG_NULL;
    }
    else if (ColRef.m_pQName->GetNumNames() == 1)
    {
        LPWSTR pName = ColRef.m_pQName->GetName(0);
        ColRef.m_pColName  = Macro_CloneLPWSTR(pName);
        if (_wcsicmp(ColRef.m_pColName, L"NULL") == 0)
            ColRef.m_dwFlags |= WQL_FLAG_NULL;
    }
    else
    {
        ColRef.m_pTableRef = Macro_CloneLPWSTR(ColRef.m_pQName->GetName(0));
        ColRef.m_dwFlags = WQL_FLAG_COMPLEX_NAME;
    }

    return TRUE;
}


//***************************************************************************
//
//***************************************************************************

void SWQLColRef::DebugDump()
{
    printf("  ---SWQLColRef---\n");
    printf("  Col Name    = %S\n",   m_pColName);
    printf("  Table       = %S\n",   m_pTableRef);
    printf("  Array Index = %d\n", m_dwArrayIndex);
    printf("  Flags       = 0x%X ", m_dwFlags);


    if (m_dwFlags & WQL_FLAG_ALIAS)
        printf("WQL_FLAG_ALIAS ");
    if (m_dwFlags & WQL_FLAG_TABLE)
        printf("WQL_FLAG_TABLE ");
    if (m_dwFlags & WQL_FLAG_COLUMN)
        printf("WQL_FLAG_COLUMN ");
    if (m_dwFlags & WQL_FLAG_ASTERISK)
        printf("WQL_FLAG_ASTERISK ");
    if (m_dwFlags & WQL_FLAG_NULL)
        printf("WQL_FLAG_NULL ");
    if (m_dwFlags & WQL_FLAG_FUNCTIONIZED)
        printf("WQL_FLAG_FUNCTIONIZED ");
    if (m_dwFlags & WQL_FLAG_COMPLEX_NAME)
        printf("WQL_FLAG_COMPLEX_NAME ");
    if (m_dwFlags & WQL_FLAG_ARRAY_REF)
        printf(" WQL_FLAG_ARRAY_REF");
    if (m_dwFlags & WQL_FLAG_UPPER)
        printf(" WQL_FLAG_UPPER");
    if (m_dwFlags & WQL_FLAG_LOWER)
        printf(" WQL_FLAG_LOWER");
    if (m_dwFlags & WQL_FLAG_SORT_ASC)
        printf(" WQL_FLAG_SORT_ASC");
    if (m_dwFlags & WQL_FLAG_SORT_DESC)
        printf(" WQL_FLAG_SORT_DESC");

    printf("\n");

    printf("  ---\n\n");
}


//***************************************************************************
//
//  SWQLQualifiedName::operator =
//
//***************************************************************************
// done

SWQLQualifiedName & SWQLQualifiedName::operator = (SWQLQualifiedName &Src)
{
    Empty();

    for (int i = 0; i < Src.m_aFields.Size(); i++)
    {
        SWQLQualifiedNameField *pQN = new SWQLQualifiedNameField;
        if (pQN == 0)
            return *this;       // Short-circuit due to out-of-mem
        *pQN = *(SWQLQualifiedNameField *) Src.m_aFields[i];
        m_aFields.Add(pQN);
    }

    return *this;
}

//***************************************************************************
//
//  SWQLQualifiedNameField::operator =
//
//***************************************************************************
// done

SWQLQualifiedNameField &
    SWQLQualifiedNameField::operator =(SWQLQualifiedNameField &Src)
{
    Empty();

    m_bArrayRef = Src.m_bArrayRef;
    m_pName = Macro_CloneLPWSTR(Src.m_pName);
    m_dwArrayIndex = Src.m_dwArrayIndex;
    return *this;
}


const LPWSTR CWQLScanner::AliasToTable(LPWSTR pszAlias)
{
    if (pszAlias == 0)
        return 0;

    for (int i = 0; i < m_aTableRefs.Size(); i++)
    {
        WSTableRef *pTRef = (WSTableRef *) m_aTableRefs[i];
        if (_wcsicmp(pszAlias, pTRef->m_pszAlias) == 0)
            return pTRef->m_pszTable;

        if (_wcsicmp(pszAlias, pTRef->m_pszTable) == 0)
            return pTRef->m_pszTable;
    }

    return 0;
}



=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\wqlscan\wqlscan.h ===
/*++

Copyright (C) 1998-2001 Microsoft Corporation

Module Name:

    WQLSCAN.H

Abstract:

    WQL Prefix Scanner

History:

	raymcc  26-Mar-98

--*/

#ifndef _WQLSCAN_H_
#define _WQLSCAN_H_


struct WSLexToken
{
    int      m_nToken;
    wchar_t *m_pszTokenText;

    WSLexToken() { m_pszTokenText = 0; }
    ~WSLexToken() { delete [] m_pszTokenText; }
};

typedef WSLexToken *PWSLexToken;

struct WSTableRef
{
    wchar_t *m_pszTable;    
    wchar_t *m_pszAlias;    // Can be NULL if no alias specified

    WSTableRef() { m_pszTable = m_pszAlias = 0; }
   ~WSTableRef() { delete [] m_pszTable; delete [] m_pszAlias; }
};

typedef WSTableRef * PWSTableRef;

class CWQLScanner
{
    // Data.
    // =====

    CGenLexer    *m_pLexer;
    int           m_nLine;
    wchar_t      *m_pTokenText;
    int           m_nCurrentToken;
    BOOL          m_bCount;

    CFlexArray m_aTokens;       // Array of ptrs to WSLexToken structs.
    CFlexArray m_aPropRefs;     // Array of ptrs to SWQLColRef structs.
    CFlexArray m_aTableRefs;    // Ptrs to WSTableRef structs.
    
    // Local functions.
    // ==================

    BOOL Next();
    PWSLexToken ExtractNext();
    void Pushback(PWSLexToken);

    BOOL StripWhereClause();
    BOOL SelectList();
    BOOL ReduceSql92Joins();
    BOOL ReduceSql89Joins();
    BOOL ExtractSelectType();

    void ClearTableRefs();
    void ClearPropRefs();
    void ClearTokens();

    BOOL BuildSWQLColRef(
        CFlexArray &aTokens,
        SWQLColRef  &ColRef      // Empty on entry
        );

public:
    enum { 
        SUCCESS,
        SYNTAX_ERROR,
        LEXICAL_ERROR,
        FAILED,
        BUFFER_TOO_SMALL,
        INVALID_PARAMETER,
        INTERNAL_ERROR
    };

    const LPWSTR AliasToTable(LPWSTR pszAlias);

    BOOL GetReferencedAliases(CWStringArray &aClasses);
    BOOL GetReferencedTables(CWStringArray &aClasses);
    BOOL CountQuery() {return m_bCount;}

    CWQLScanner(CGenLexSource *pSrc);
   ~CWQLScanner(); 
    int Parse();
    
    void Dump();

    const CFlexArray *GetSelectedColumns() { return &m_aPropRefs; }
        // Returns pointer to array of SWQLColRef*

};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\xfiles\a51fib.cpp ===
/*++

Copyright (C) 2000-2001 Microsoft Corporation

--*/

#include <windows.h>
#include <stdio.h>
#include <wbemcomn.h>
#include "a51fib.h"
#include <tls.h>

void CALLBACK A51FiberBase(void* p)
{
    CFiberTask* pTask = (CFiberTask*)p;
    pTask->Execute();

    //
    // No need to clean up --- it's the job of our caller
    //
}

void* CreateFiberForTask(CFiberTask* pTask)
{
    return CreateFiber(0, A51FiberBase, pTask);
}

void ReturnFiber(void* pFiber)
{
    DeleteFiber(pFiber);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\xfiles\a51tools.cpp ===
/*++

Copyright (C) 2000-2001 Microsoft Corporation

--*/

#include <windows.h>
#include <stdio.h>
#include <wbemcomn.h>
#include "a51tools.h"

__int64 g_nCurrentTime = 1;

__int64 g_nReadFailures = 0;
__int64 g_nWriteFailures = 0;

//
// FILE_ATTRIBUTE_NOT_CONTENT_INDEXED is not actually supported on CreateFile,
// contrary to the docs.  However, also contrary to the docs, it is inherited
// from the parent directory
//

#define A51_FILE_CREATION_FLAGS 0 //FILE_ATTRIBUTE_NOT_CONTENT_INDEXED

CTempMemoryManager g_Manager;

void* TempAlloc(DWORD dwLen)
{
    return g_Manager.Allocate(dwLen);
}
    
void TempFree(void* p, DWORD dwLen)
{
    g_Manager.Free(p, dwLen);
}

void* TempAlloc(CTempMemoryManager& Manager, DWORD dwLen)
{
    return Manager.Allocate(dwLen);
}
    
void TempFree(CTempMemoryManager& Manager, void* p, DWORD dwLen)
{
    Manager.Free(p, dwLen);
}

HANDLE g_hLastEvent = NULL;
CCritSec g_csEvents;
HANDLE A51GetNewEvent()
{
    {
        CInCritSec ics(&g_csEvents);
        if(g_hLastEvent)
        {
            HANDLE h = g_hLastEvent;
            g_hLastEvent = NULL;
            return h;
        }
    }

    return CreateEvent(NULL, TRUE, FALSE, NULL);
}

void A51ReturnEvent(HANDLE hEvent)
{
    {
        CInCritSec ics(&g_csEvents);
        if(g_hLastEvent == NULL)
        {
            g_hLastEvent = hEvent;
            return;
        }
    }
    
    CloseHandle(hEvent);
}

HRESULT A51TranslateErrorCode(long lRes)
{
	if (lRes == ERROR_SUCCESS)
		return WBEM_S_NO_ERROR;

    switch(lRes)
    {
    case ERROR_FILE_NOT_FOUND:
    case ERROR_PATH_NOT_FOUND:
        return WBEM_E_NOT_FOUND;

    case ERROR_OUTOFMEMORY:
	case ERROR_NOT_ENOUGH_MEMORY:
        return WBEM_E_OUT_OF_MEMORY;

    case ERROR_NOT_ENOUGH_QUOTA:
    case ERROR_DISK_FULL:
        return WBEM_E_OUT_OF_DISK_SPACE;

	case ERROR_SERVER_SHUTDOWN_IN_PROGRESS:
		return WBEM_E_SHUTTING_DOWN;

    default:
        return WBEM_E_FAILED;
    }
}

long __stdcall EnsureDirectory(LPCWSTR wszPath, LPSECURITY_ATTRIBUTES pSA)
{
    if(!CreateDirectoryW(wszPath, NULL))
    {
		long lRes = GetLastError();
        if(lRes != ERROR_ALREADY_EXISTS)
            return lRes;
        else
            return ERROR_SUCCESS;
    }
    else
        return ERROR_SUCCESS;
}

long __stdcall EnsureDirectoryRecursiveForFile(LPWSTR wszPath, 
                                                LPSECURITY_ATTRIBUTES pSA);
long __stdcall EnsureDirectoryForFile(LPCWSTR wszPath, LPSECURITY_ATTRIBUTES pSA)
{
    //
    // Make a copy, since we will be messing with it
    //

    CFileName wszNewPath;
	if (wszNewPath == NULL)
		return ERROR_OUTOFMEMORY;
    wcscpy(wszNewPath, wszPath);

    return EnsureDirectoryRecursiveForFile(wszNewPath, pSA);
}


long __stdcall EnsureDirectoryRecursiveForFile(LPWSTR wszPath, 
                                                LPSECURITY_ATTRIBUTES pSA)
{
    long lRes;

    //
    // Find the last backslash and remove
    //

    WCHAR* pwcLastSlash = wcsrchr(wszPath, L'\\');
    if(pwcLastSlash == NULL)
        return ERROR_BAD_PATHNAME;

    *pwcLastSlash = 0;

    //
    // Try to create it
    //

    if(!CreateDirectoryW(wszPath, pSA))
    {
        //
        // Call ourselves recursively --- to create our parents
        //

        lRes = EnsureDirectoryRecursiveForFile(wszPath, pSA);
        if(lRes != ERROR_SUCCESS)
        {
            *pwcLastSlash = L'\\';
            return lRes;
        }

        //
        // Try again
        //

        BOOL bRes = CreateDirectoryW(wszPath, pSA);
        *pwcLastSlash = L'\\';
        if(bRes)
            return ERROR_SUCCESS;
        else
            return GetLastError();
    }
    else
    {
        *pwcLastSlash = L'\\';
        return ERROR_SUCCESS;
    }
}

static WCHAR g_HexDigit[] = 
{ L'0', L'1', L'2', L'3', L'4', L'5', L'6', L'7', L'8', L'9',
  L'A', L'B', L'C', L'D', L'E', L'F'
};
       
bool A51Hash(LPCWSTR wszName, LPWSTR wszHash)
{
	//
	// Have to upper-case everything
	//

    DWORD dwBufferSize = wcslen(wszName)*2+2;
    LPWSTR wszBuffer = (WCHAR*)TempAlloc(dwBufferSize);
	if (wszBuffer == NULL)
		return false;
    CTempFreeMe vdm(wszBuffer, dwBufferSize);

    wbem_wcsupr(wszBuffer, wszName);

    BYTE RawHash[16];
    MD5::Transform((void*)wszBuffer, wcslen(wszBuffer)*2, RawHash);

    WCHAR* pwc = wszHash;
    for(int i = 0; i < 16; i++)
    {
        *(pwc++) = g_HexDigit[RawHash[i]/16];
        *(pwc++) = g_HexDigit[RawHash[i]%16];
    }
	*pwc = 0;
    return true;
}

long A51WriteFile(LPCWSTR wszFullPath, DWORD dwLen, BYTE* pBuffer)
{
    long lRes;

    A51TRACE(( "Create file %S\n", wszFullPath));

    //
    // Create the right file
    //

    HANDLE hFile = CreateFileW(wszFullPath, GENERIC_WRITE, 0,
                    NULL, CREATE_ALWAYS, A51_FILE_CREATION_FLAGS, NULL);
    
    if(hFile == INVALID_HANDLE_VALUE)
    {
        lRes = GetLastError();
        if(lRes == ERROR_PATH_NOT_FOUND)
        {
            lRes = EnsureDirectoryForFile(wszFullPath, NULL);
            if(lRes != ERROR_SUCCESS)
                return lRes;

            hFile = CreateFileW(wszFullPath, GENERIC_WRITE, 0,
                            NULL, CREATE_ALWAYS, A51_FILE_CREATION_FLAGS, NULL);
    
            if(hFile == INVALID_HANDLE_VALUE)
            {
                lRes = GetLastError();
                _ASSERT(lRes != ERROR_SUCCESS, L"success error code from fail");
                return lRes;
            }
        }
        else
            return lRes;
    }
        
    CCloseMe cm(hFile);

    //
    // Write it and close
    //

    if(!WriteFile(hFile, pBuffer, dwLen, &dwLen, NULL))
    {
        lRes = GetLastError();
        _ASSERT(lRes != ERROR_SUCCESS, L"success error code from fail");
        return lRes;
    }

    return ERROR_SUCCESS;
}

long A51DeleteFile(LPCWSTR wszFullPath)
{
    A51TRACE(("Delete file %S\n", wszFullPath));

    //
    // Delete the right file
    //

    if(!DeleteFileW(wszFullPath))
        return GetLastError();
    return ERROR_SUCCESS;
}

long A51WriteToFileAsync(HANDLE hFile, long lStartingOffset, BYTE* pBuffer,
                        DWORD dwBufferLen, OVERLAPPED* pov)
{
    pov->Offset = lStartingOffset;
    pov->OffsetHigh = 0;
    pov->hEvent = A51GetNewEvent();

    BOOL bRes;
    DWORD dwWritten;
    while(!(bRes = WriteFile(hFile, pBuffer, dwBufferLen, &dwWritten, pov)) &&
            (GetLastError() == ERROR_INVALID_USER_BUFFER ||
             GetLastError() == ERROR_NOT_ENOUGH_MEMORY))
    {
        //
        // Out of buffer-space --- wait a bit and retry
        //

        g_nWriteFailures++;
        Sleep(16);
    }

    if(!bRes)
    {
        long lRes = GetLastError();
        if(lRes == ERROR_IO_PENDING)
            // perfect!
            return ERROR_SUCCESS;
        else
        {
            A51ReturnEvent(pov->hEvent);
            pov->hEvent = NULL;
            return lRes;
        }
    }
    else
    {
        //
        // Succeeded synchronously --- clean up and return
        //

        A51ReturnEvent(pov->hEvent);
        pov->hEvent = NULL;

        if(dwWritten != dwBufferLen)
            return ERROR_OUTOFMEMORY;
        else
            return ERROR_SUCCESS;
    }
}

long A51WriteToFileSync(HANDLE hFile, long lStartingOffset, BYTE* pBuffer,
                        DWORD dwBufferLen)
{
    OVERLAPPED ov;
    
    long lRes = A51WriteToFileAsync(hFile, lStartingOffset, pBuffer, 
                                    dwBufferLen, &ov);
    if(lRes != ERROR_SUCCESS)
        return lRes;

    if(ov.hEvent)
    {
        CReturnMe rm(ov.hEvent);
    
        //
        // Wait for completion
        //
    
        DWORD dwWritten;
        if(!GetOverlappedResult(hFile, &ov, &dwWritten, TRUE))
            return GetLastError();
    
        if(dwWritten != dwBufferLen)
            return ERROR_OUTOFMEMORY;
    }

    return ERROR_SUCCESS;
}
    
long A51ReadFromFileAsync(HANDLE hFile, long lStartingOffset, BYTE* pBuffer,
                        DWORD dwBufferLen, OVERLAPPED* pov)
{
    long lRes;

    pov->Offset = lStartingOffset;
    pov->OffsetHigh = 0;
    pov->hEvent = A51GetNewEvent();

    BOOL bRes;
    DWORD dwRead;
    while(!(bRes = ReadFile(hFile, pBuffer, dwBufferLen, &dwRead, pov)) &&
            (GetLastError() == ERROR_INVALID_USER_BUFFER ||
             GetLastError() == ERROR_NOT_ENOUGH_MEMORY))
    {
        //
        // Out of buffer-space --- wait a bit and retry
        //

        g_nReadFailures++;
        Sleep(16);
    }

    if(!bRes)
    {
        if(GetLastError() == ERROR_IO_PENDING)
            // perfect!
            return ERROR_SUCCESS;
        else
        {
            lRes = GetLastError();
            _ASSERT(lRes != ERROR_SUCCESS, L"Success returned on failure");
            A51ReturnEvent(pov->hEvent);
            pov->hEvent = NULL;
            if(lRes == ERROR_HANDLE_EOF)
                lRes = ERROR_SUCCESS;
            return lRes;
        }
    }
    else
    {
        //
        // Succeeded synchronously --- clean up and return
        //

        A51ReturnEvent(pov->hEvent);
        pov->hEvent = NULL;

        return ERROR_SUCCESS;
    }
}

long A51ReadFromFileSync(HANDLE hFile, long lStartingOffset, BYTE* pBuffer,
                        DWORD dwBufferLen)
{
    OVERLAPPED ov;
    
    long lRes = A51ReadFromFileAsync(hFile, lStartingOffset, pBuffer, 
                                    dwBufferLen, &ov);
    if(lRes != ERROR_SUCCESS)
        return lRes;

    if(ov.hEvent)
    {
        CReturnMe rm(ov.hEvent);
    
        //
        // Wait for completion
        //
    
        DWORD dwRead = 0;
        if(!GetOverlappedResult(hFile, &ov, &dwRead, TRUE))
        {
            lRes = GetLastError();
            _ASSERT(lRes != ERROR_SUCCESS, L"Success returned on failure");
            if(lRes == ERROR_HANDLE_EOF)
                lRes = ERROR_SUCCESS;
            return lRes;
        }
    }

    return ERROR_SUCCESS;
}
    
    

long RemoveDirectoryRecursive(LPCWSTR wszDirectoryPath, bool bAbortOnFiles);
long A51RemoveDirectory(LPCWSTR wszFullPath, bool bAbortOnFiles)
{
    long lRes = RemoveDirectoryRecursive(wszFullPath, bAbortOnFiles);
    if(lRes == ERROR_PATH_NOT_FOUND || lRes == ERROR_FILE_NOT_FOUND)
        return ERROR_FILE_NOT_FOUND;
    else
        return lRes;
}

long RemoveDirectoryRecursive(LPCWSTR wszDirectoryPath, bool bAbortOnFiles)
{
    long lRes;

    //
    // Try removing it right away
    //

    if(!RemoveDirectoryW(wszDirectoryPath))
    {
        lRes = GetLastError();
        if(lRes == ERROR_PATH_NOT_FOUND || lRes == ERROR_FILE_NOT_FOUND)
            return ERROR_FILE_NOT_FOUND;
        else if(lRes != ERROR_DIR_NOT_EMPTY && lRes != ERROR_SHARING_VIOLATION)
            return lRes;
    }
    else 
        return ERROR_SUCCESS;

    //
    // Not empty (or at least we are not sure it is empty) --- enumerate 
    // everything
    //

    CFileName wszMap;
	if (wszMap == NULL)
		return ERROR_OUTOFMEMORY;
    wcscpy(wszMap, wszDirectoryPath);
    wcscat(wszMap, L"\\*");

    CFileName wszChild;
	if (wszChild == NULL)
		return ERROR_OUTOFMEMORY;
    wcscpy(wszChild, wszDirectoryPath);
    wcscat(wszChild, L"\\");
    long lChildLen = wcslen(wszChild);

    WIN32_FIND_DATAW fd;
    HANDLE hSearch = FindFirstFileW(wszMap, &fd);
    if(hSearch == INVALID_HANDLE_VALUE)
        return ERROR_DIR_NOT_EMPTY;

    do
    {
        if(fd.cFileName[0] == L'.')
            continue;

        if((fd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) == 0)
        {
            if(bAbortOnFiles)
            {
                // There is a file --- give up
                FindClose(hSearch);
                return ERROR_DIR_NOT_EMPTY;
            }
            else
            {
                wcscpy(wszChild + lChildLen, fd.cFileName);
                if(!DeleteFileW(wszChild))
                {
                    FindClose(hSearch);
                    return GetLastError();
                }
            }
        }
        else
        {
            wcscpy(wszChild + lChildLen, fd.cFileName);
            lRes = RemoveDirectoryRecursive(wszChild, bAbortOnFiles);
            if(lRes != ERROR_SUCCESS && lRes != ERROR_FILE_NOT_FOUND)
            {
                FindClose(hSearch);
                return lRes;
            }
        }
    }
    while(FindNextFileW(hSearch, &fd));

    FindClose(hSearch);
            
    //
    // And try again
    //

    if(!RemoveDirectoryW(wszDirectoryPath))
    {
        lRes = GetLastError();
        if(lRes == ERROR_PATH_NOT_FOUND || lRes == ERROR_FILE_NOT_FOUND)
            return ERROR_FILE_NOT_FOUND;
        else if(lRes == ERROR_SHARING_VIOLATION)
            return ERROR_SUCCESS;
        else 
            return lRes;
    }

    return ERROR_SUCCESS;
}
    
CRITICAL_SECTION g_csLog;
char* g_szText = NULL;
long g_lTextLen = 0;
WCHAR g_wszLogFilename[MAX_PATH] = L"";
void A51Trace(LPCSTR szFormat, ...)
{
    if((g_wszLogFilename[0] == 0) || (g_szText == NULL))
    {
        InitializeCriticalSection(&g_csLog);

		delete g_szText;
		g_wszLogFilename[0] = 0;
		g_szText = NULL;

		HKEY hKey;
		long lRes = RegOpenKeyExW(HKEY_LOCAL_MACHINE, 
						L"SOFTWARE\\Microsoft\\WBEM\\CIMOM",
						0, KEY_READ, &hKey);
		if(lRes)
		{
			wcscpy(g_wszLogFilename, L"c:\\a51.log");
		}
		else
		{
			DWORD dwLen = MAX_PATH;
			CFileName wszTmp;
			if (wszTmp == 0)
			{
				wcscpy(g_wszLogFilename, L"c:\\a51.log");
				RegCloseKey(hKey);
			}
			else
			{
				lRes = RegQueryValueExW(hKey, L"Logging Directory", NULL, NULL, 
							(LPBYTE)(wchar_t*)wszTmp, &dwLen);
				RegCloseKey(hKey);
				if(lRes)
				{
					wcscpy(g_wszLogFilename, L"c:\\a51.log");
				}
				else
				{
					if (ExpandEnvironmentStringsW(wszTmp,g_wszLogFilename,MAX_PATH) == 0)
					{
						wcscpy(g_wszLogFilename, L"c:\\a51.log");
					}
					else
					{
						if (g_wszLogFilename[wcslen(g_wszLogFilename)] == L'\\')
						{
							wcscat(g_wszLogFilename, L"a51.log");
						}
						else
						{
							wcscat(g_wszLogFilename, L"\\a51.log");
						}
					}
				}
			}
		}
        
        g_szText = new char[3000000];
		if (g_szText == NULL)
			return;
    }

    EnterCriticalSection(&g_csLog);
    
    char szBuffer[256];
    va_list argptr;
    va_start(argptr, szFormat);
    vsprintf(szBuffer, szFormat, argptr);
    long lLen = strlen(szBuffer);
    if(g_lTextLen + lLen > 2900000)
        A51TraceFlush();

    strcpy(g_szText + g_lTextLen, szBuffer);
    g_lTextLen += lLen;

    LeaveCriticalSection(&g_csLog);
}

void A51TraceFlush()
{
	FILE* fLog = NULL;
	fLog = _wfopen(g_wszLogFilename, L"a");
    if(fLog)
    {
        fwrite(g_szText, 1, g_lTextLen, fLog);
        g_lTextLen = 0;
//      fflush(fLog);
		fclose(fLog);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\xfiles\a51rep.h ===
/*++

Copyright (C) 2000-2001 Microsoft Corporation

--*/

#ifndef __A51PROV__H_
#define __A51PROV__H_

#include <windows.h>
#include <wbemidl.h>
#include <unk.h>
#include <wbemcomn.h>
#include <sync.h>
#include <reposit.h>
#include <wmiutils.h>
#include <objpath.h>
#include <filecach.h>
#include <hiecache.h>
#include <corex.h>
#include "a51fib.h"
#include "creposit.h"

class CDbIterator;
class CRepEvent
{
public:
	DWORD m_dwType;
	LPWSTR m_wszArg1;
    LPWSTR m_wszNamespace;
	_IWmiObject* m_pObj1;
	_IWmiObject* m_pObj2;

	CRepEvent(DWORD dwType, LPCWSTR wszNamespace, LPCWSTR wszArg1, 
                _IWmiObject* pObj1, _IWmiObject* pObj2);
	~CRepEvent();

    void* operator new(size_t) {return TempAlloc(sizeof(CRepEvent));}
    void operator delete(void* p) {return TempFree(p, sizeof(CRepEvent));}
};

class CEventCollector
{
protected:
    CUniquePointerArray<CRepEvent> m_apEvents;
    bool m_bNamespaceOnly;
    CRITICAL_SECTION m_csLock;

public:
    CEventCollector() : m_bNamespaceOnly(false){ InitializeCriticalSection(&m_csLock);}
    ~CEventCollector() { DeleteCriticalSection(&m_csLock); }
    bool AddEvent(CRepEvent* pEvent);
    void SetNamespaceOnly(bool bNamespaceOnly) 
        {m_bNamespaceOnly = bNamespaceOnly;}
    bool IsNamespaceOnly() {return m_bNamespaceOnly;}

    HRESULT SendEvents(_IWmiCoreServices* pCore);

    void DeleteAllEvents();

    void TransferEvents(CEventCollector &aEventsToTransfer);

    int GetSize() { return m_apEvents.GetSize(); }
};
    


class CSession : public CUnkBase<IWmiDbSessionEx, &IID_IWmiDbSessionEx>
{
private:
    CEventCollector m_aTransactedEvents;
    bool m_bInWriteTransaction;

public:
    CSession(CLifeControl* pControl = NULL) : TUnkBase(pControl), m_bInWriteTransaction(false) {}

    virtual ~CSession();

    ULONG STDMETHODCALLTYPE Release();

    HRESULT STDMETHODCALLTYPE GetObject(
         IWmiDbHandle *pScope,
         IWbemPath *pPath,
         DWORD dwFlags,
         DWORD dwRequestedHandleType,
        IWmiDbHandle **ppResult
        );

    HRESULT STDMETHODCALLTYPE GetObjectDirect(
         IWmiDbHandle *pScope,
         IWbemPath *pPath,
         DWORD dwFlags,
         REFIID riid,
        LPVOID *pObj
        );

    HRESULT STDMETHODCALLTYPE PutObject(
         IWmiDbHandle *pScope,
         REFIID riid,
        LPVOID pObj,
         DWORD dwFlags,
         DWORD dwRequestedHandleType,
        IWmiDbHandle **ppResult
        );

    HRESULT STDMETHODCALLTYPE DeleteObject(
         IWmiDbHandle *pScope,
         DWORD dwFlags,
         REFIID riid,
         LPVOID pObj
        );

    HRESULT STDMETHODCALLTYPE ExecQuery(
         IWmiDbHandle *pScope,
         IWbemQuery *pQuery,
         DWORD dwFlags,
         DWORD dwRequestedHandleType,
        DWORD *dwMessageFlags,
        IWmiDbIterator **ppQueryResult
        );
    HRESULT STDMETHODCALLTYPE RenameObject(
         IWbemPath *pOldPath,
         IWbemPath *pNewPath,
         DWORD dwFlags,
         DWORD dwRequestedHandleType,
        IWmiDbHandle **ppResult
        );

    HRESULT STDMETHODCALLTYPE Enumerate(
         IWmiDbHandle *pScope,
         DWORD dwFlags,
         DWORD dwRequestedHandleType,
        IWmiDbIterator **ppQueryResult
        );

    HRESULT STDMETHODCALLTYPE AddObject(
         IWmiDbHandle *pScope,
         IWbemPath *pPath,
         DWORD dwFlags,
         DWORD dwRequestedHandleType,
        IWmiDbHandle **ppResult
        );

    HRESULT STDMETHODCALLTYPE RemoveObject (
         IWmiDbHandle *pScope,
         IWbemPath *pPath,
         DWORD dwFlags
        );

    HRESULT STDMETHODCALLTYPE SetDecoration(
         LPWSTR lpMachineName,
         LPWSTR lpNamespacePath
        );

    HRESULT STDMETHODCALLTYPE SupportsQueries( 
         DWORD *dwQuerySupportLevel
         ) {return WBEM_E_FAILED;};

    HRESULT STDMETHODCALLTYPE GetObjectByPath(
         IWmiDbHandle *pScope,
         LPCWSTR wszPath,
         DWORD dwFlags,
         REFIID riid,
        LPVOID *pObj
        );

	HRESULT STDMETHODCALLTYPE DeleteObjectByPath(
		IWmiDbHandle *pScope,
		LPCWSTR wszObjectPath,
		DWORD dwFlags
    );

    HRESULT STDMETHODCALLTYPE ExecQuerySink(
		IWmiDbHandle *pScope,
         IWbemQuery *pQuery,
         DWORD dwFlags,
         DWORD dwRequestedHandleType,
        IWbemObjectSink* pSink,
        DWORD *dwMessageFlags
        );

    HRESULT STDMETHODCALLTYPE QueryInterface(REFIID riid, void** ppv);

	HRESULT STDMETHODCALLTYPE BeginWriteTransaction(DWORD dwFlags);

    HRESULT STDMETHODCALLTYPE BeginReadTransaction(DWORD dwFlags);

	HRESULT STDMETHODCALLTYPE CommitTransaction(DWORD dwFlags);

	HRESULT STDMETHODCALLTYPE AbortTransaction(DWORD dwFlags);
protected:
	HRESULT InternalBeginTransaction(bool bWriteOperation);
	HRESULT InternalAbortTransaction(bool bWriteOperation);
	HRESULT InternalCommitTransaction(bool bWriteOperation);
};

class CNamespaceHandle : public CUnkBase<IWmiDbHandle, &IID_IWmiDbHandle>
{
protected:

    static long s_lActiveRepNs;

    CRepository * m_pRepository;
    WString m_wsNamespace;
    WString m_wsScope;
    WString m_wsFullNamespace;
    WCHAR m_wszMachineName[MAX_COMPUTERNAME_LENGTH+1];

    WCHAR m_wszClassRootDir[MAX_PATH];
    long m_lClassRootDirLen;

    WCHAR m_wszInstanceRootDir[MAX_PATH];
    long m_lInstanceRootDirLen;

    CHierarchyCache* m_pClassCache;
    CForestCache* m_ForestCache;

    _IWmiObject* m_pNullClass;
    bool m_bCached;

	bool m_bUseIteratorLock;

public:
    CNamespaceHandle(CLifeControl* pControl, CRepository * pRepository);
    ~CNamespaceHandle();
    

    STDMETHOD(GetHandleType)(DWORD* pdwType) {*pdwType = 0; return S_OK;}

    CHR Initialize(LPCWSTR wszNamespace, LPCWSTR wszScope = NULL);

    CHR GetObject(
         IWbemPath *pPath,
         DWORD dwFlags,
         DWORD dwRequestedHandleType,
        IWmiDbHandle **ppResult
        );

    CHR GetObjectDirect(
         IWbemPath *pPath,
         DWORD dwFlags,
         REFIID riid,
        LPVOID *pObj
        );

    CHR PutObject(
         REFIID riid,
        LPVOID pObj,
         DWORD dwFlags,
         DWORD dwRequestedHandleType,
        IWmiDbHandle **ppResult,
		CEventCollector &aEvents
        );

    CHR DeleteObject(
         DWORD dwFlags,
         REFIID riid,
         LPVOID pObj,
		 CEventCollector &aEvents
        );

    CHR ExecQuery(
         IWbemQuery *pQuery,
         DWORD dwFlags,
         DWORD dwRequestedHandleType,
        DWORD *dwMessageFlags,
        IWmiDbIterator **ppQueryResult
        );

    CHR GetObjectByPath(
        LPWSTR wszPath,
        DWORD dwFlags,
        REFIID riid,
        LPVOID *pObj
       );

    CHR ExecQuerySink(
         IWbemQuery *pQuery,
         DWORD dwFlags,
         DWORD dwRequestedHandleType,
        IWbemObjectSink* pSink,
        DWORD *dwMessageFlags
        );

	CHR DeleteObjectByPath(DWORD dwFlags, LPWSTR wszPath, CEventCollector &aEvents);
	HRESULT SendEvents(CEventCollector &aEvents);
    CHR GetErrorStatus();
    void SetErrorStatus(HRESULT hres);

	HRESULT CreateSystemClasses(CFlexArray &aSystemClasses);

	void TellIteratorNotToLock() { m_bUseIteratorLock = false; }

protected:
    CHR GetObjectHandleByPath(LPWSTR wszBuffer, DWORD dwFlags,
            DWORD dwRequestedHandleType, IWmiDbHandle **ppResult);
    CHR PutInstance(_IWmiObject* pInst, DWORD dwFlags, CEventCollector &aEvents);
    CHR PutClass(_IWmiObject* pClass, DWORD dwFlags, CEventCollector &aEvents);
    CHR ConstructClassRelationshipsDir(LPCWSTR wszClassName,
                                LPWSTR wszDirPath);
    CHR WriteParentChildRelationship(LPCWSTR wszChildFileName, 
                                LPCWSTR wszParentName);
    CHR WriteClassReferences(_IWmiObject* pClass, LPCWSTR wszFileName);
    CHR ExecClassQuery(QL_LEVEL_1_RPN_EXPRESSION* pQuery, 
                            IWbemObjectSink* pSink, DWORD dwFlags);
    CHR ExecInstanceQuery(QL_LEVEL_1_RPN_EXPRESSION* pQuery, 

                                LPCWSTR wszClassName, bool bDeep,
                                IWbemObjectSink* pSink);
    CHR GetClassDirect(LPCWSTR wszClassName, REFIID riid, void** ppObj,
                            bool bClone, __int64* pnTime,
                            bool* pbRead, bool *pbSystemClass);
    CHR GetInstanceDirect(ParsedObjectPath* pPath,
                                REFIID riid, void** ppObj);
	CHR DeleteInstance(LPCWSTR wszClassName, LPCWSTR wszKey, CEventCollector &aEvents);
	CHR DeleteInstanceByFile(LPCWSTR wszFilePath, _IWmiObject* pClass, 
                            bool bClassDeletion, CEventCollector &aEvents);
	CHR DeleteClass(LPCWSTR wszClassName, CEventCollector &aEvents);
	CHR DeleteClassInstances(LPCWSTR wszClassName, _IWmiObject* pClass, CEventCollector &aEvents);
    CHR FileToSystemClass(LPCWSTR wszFileName, _IWmiObject** ppClass, 
                            bool bClone, __int64* pnTime = NULL);
    CHR FileToClass(LPCWSTR wszFileName, _IWmiObject** ppClass, 
                            bool bClone, __int64* pnTime, 
							bool *pbSystemClass);
    CHR FileToInstance(_IWmiObject* pClass,
					   LPCWSTR wszFileName, 
					   BYTE *pRetrievedBlob,
					   DWORD dwSize,
					   _IWmiObject** ppInstance,
                       bool bMustBeThere = false);
    CHR WriteInstanceReferences(_IWmiObject* pInst, LPCWSTR wszClassName,
                                    LPCWSTR wszFilePath);
    CHR WriteInstanceReference(LPCWSTR wszReferringFile,
                            LPCWSTR wszReferringClass,
                            LPCWSTR wszReferringProp, LPWSTR wszReference);
    CHR CalculateInstanceFileBase(LPCWSTR wszInstancePath, 
                            LPWSTR wszFilePath);
    CHR ExecClassRefQuery(LPCWSTR wszQuery, LPCWSTR wszClassName,
                                                    IWbemObjectSink* pSink);
    CHR ExecReferencesQuery(LPCWSTR wszQuery, IWbemObjectSink* pSink);
    CHR ExecInstanceRefQuery(LPCWSTR wszQuery, LPCWSTR wszClassName,
                                    LPCWSTR wszKey, IWbemObjectSink* pSink);
    CHR GetReferrerFromFile(LPCWSTR wszReferenceFile,
                                LPWSTR wszReferrerRelFile, 
                                LPWSTR* pwszReferrerNamespace,
                                LPWSTR* pwszReferrerClass,
                                LPWSTR* pwszReferrerProp);
    CHR DeleteInstanceReference(LPCWSTR wszOurFilePath,
                                            LPWSTR wszReference);
    CHR DeleteInstanceReferences(_IWmiObject* pInst, LPCWSTR wszFilePath);

    CHR EnumerateClasses(IWbemObjectSink* pSink,
                                LPCWSTR wszSuperClass, LPCWSTR wszAncestor,
                                bool bClone, bool bDontIncludeAncestorInResultSet);
    CHR ListToEnum(CWStringArray& wsClasses, 
                                        IWbemObjectSink* pSink, bool bClone);

    bool Hash(LPCWSTR wszName, LPWSTR wszHash);
    CHR InstanceToFile(IWbemClassObject* pInst, LPCWSTR wszClassName,
                            LPCWSTR wszFileName1, LPCWSTR wszFileName2,
							__int64 nClassTime);
    CHR ConstructInstanceDefName(LPWSTR wszInstanceDefName, LPCWSTR wszKey);
    CHR ClassToFile(_IWmiObject* pSuperClass, _IWmiObject* pClass, 
                        LPCWSTR wszFileName, __int64 nFakeUpdateTime = 0);
    CHR ConstructClassName(LPCWSTR wszClassName, 
                                            LPWSTR wszFileName);
    CHR TryGetShortcut(LPWSTR wszPath, DWORD dwFlags, REFIID riid,
                            LPVOID *pObj);
    CHR ComputeKeyFromPath(LPWSTR wszPath, LPWSTR wszKey, 
                                LPWSTR* pwszClassName, bool* pbIsClass,
                                LPWSTR* pwszNamespace = NULL);
    CHR ParseKey(LPWSTR wszKeyStart, LPWSTR* pwcRealStart,
                                    LPWSTR* pwcNextKey);

    CHR GetInstanceByKey(LPCWSTR wszClassName, LPCWSTR wszKey,
                                REFIID riid, void** ppObj);
    CHR WriteClassRelationships(_IWmiObject* pClass, LPCWSTR wszFileName);
    CHR ConstructParentChildFileName(LPCWSTR wszChildFileName, 
                                    LPCWSTR wszParentName,
                                    LPWSTR wszParentChildFileName);
    CHR DeleteDerivedClasses(LPCWSTR wszClassName, CEventCollector &aEvents);
    CHR EraseParentChildRelationship(LPCWSTR wszChildFileName, 
                                        LPCWSTR wszParentName);
    CHR EraseClassRelationships(LPCWSTR wszClassName,
                                _IWmiObject* pClass, LPCWSTR wszFileName);
    CHR GetClassByHash(LPCWSTR wszHash, bool bClone, _IWmiObject** ppClass,
                            __int64* pnTime, bool* pbRead,
							bool *pbSystemClass);
    CHR DeleteClassByHash(LPCWSTR wszHash, CEventCollector &aEvents);
    CHR DeleteClassInternal(LPCWSTR wszClassName, _IWmiObject* pClass,
                                LPCWSTR wszFileName, CEventCollector &aEvents,
								bool bSystemClass);
    CHR GetChildHashes(LPCWSTR wszClassName, CWStringArray& wsChildHashes);
    CHR GetChildDefs(LPCWSTR wszClassName, bool bRecursive,
                                    IWbemObjectSink* pSink, bool bClone);
    CHR ConstructClassDefFileName(LPCWSTR wszClassName, LPWSTR wszFileName);
    CHR ConstructClassDefFileNameFromHash(LPCWSTR wszHash, 
                                            LPWSTR wszFileName);
    CHR ConstructClassRelationshipsDirFromHash(LPCWSTR wszHash, 
                                        LPWSTR wszDirPath);
    CHR GetChildHashesByHash(LPCWSTR wszHash, CWStringArray& wsChildHashes);
    CHR GetChildDefsByHash(LPCWSTR wszHash, bool bRecursive,
                                    IWbemObjectSink* pSink, bool bClone);
    CHR FireEvent(CEventCollector &aEvents, DWORD dwType, LPCWSTR wszArg1, _IWmiObject* pObj1, 
                                    _IWmiObject* pObj2 = NULL);
    CHR DeleteSelf(CEventCollector &aEvents);
    CHR DeleteInstanceAsScope(_IWmiObject* pInst, CEventCollector &aEvents);
    CHR DeleteInstanceSelf(LPCWSTR wszFilePath, _IWmiObject* pInst,
                                bool bClassDeletion);
    CHR ConstructReferenceDir(LPWSTR wszTargetPath, LPWSTR wszDir);
    CHR ConstructReferenceDirFromKey(LPCWSTR wszClassName,
                                LPCWSTR wszKey, LPWSTR wszReferenceDir);
    CHR ConstructReferenceFileName(LPWSTR wszReference,
                        LPCWSTR wszReferringFile, LPWSTR wszReferenceFile);
    CHR ConstructKeyRootDirFromClass(LPWSTR wszDir, LPCWSTR wszClassName);
    CHR ConstructKeyRootDirFromKeyRoot(LPWSTR wszDir, 
                                                    LPCWSTR wszKeyRootClass);
    CHR ConstructLinkDirFromClass(LPWSTR wszDir, LPCWSTR wszClassName);
    CHR DeleteInstanceLink(_IWmiObject* pInst, 
                                LPCWSTR wszInstanceDefFilePath);
    CHR GetKeyRoot(LPCWSTR wszClass, 
                                     TEMPFREE_ME LPWSTR* pwszKeyRootClass);
    CHR ConstructInstDefNameFromLinkName(LPWSTR wszInstanceDefName,
                                             LPCWSTR wszInstanceLinkName);
    CHR ExecDeepInstanceQuery(QL_LEVEL_1_RPN_EXPRESSION* pQuery, 
                                LPCWSTR wszClassHash,
                                IWbemObjectSink* pSink);
    CHR ExecShallowInstanceQuery(QL_LEVEL_1_RPN_EXPRESSION* pQuery, 
                                LPCWSTR wszClassHash, 
                                IWbemObjectSink* pSink);
    CHR GetKeyRootByHash(LPCWSTR wszClassHash, 
                                     TEMPFREE_ME LPWSTR* pwszKeyRootClass);
    CHR ConstructKeyRootDirFromClassHash(LPWSTR wszDir,
                                            LPCWSTR wszClassHash);
    CHR ConstructLinkDirFromClassHash(LPWSTR wszDir, LPCWSTR wszClassHash);
    CHR ConstructClassReferenceFileName(LPCWSTR wszReferredToClass,
                                LPCWSTR wszReferringFile, 
                                LPCWSTR wszReferringProp,
                                LPWSTR wszFieName);
    CHR WriteClassReference(_IWmiObject* pReferringClass,
                            LPCWSTR wszReferringFile,
                            LPCWSTR wszReferringProp);
    CHR EraseClassReference(_IWmiObject* pReferringClass,
                            LPCWSTR wszReferringFile,
                            LPCWSTR wszReferringProp);
    //CFileCache* GetFileCache();
	
	CHR CanClassBeUpdatedCompatible(DWORD dwFlags, LPCWSTR wszClassName, 
                _IWmiObject *pOldClass, _IWmiObject *pNewClass);
    CHR DeleteInstanceBackReferences(LPCWSTR wszFilePath);
    CHR ConstructReferenceDirFromFilePath(LPCWSTR wszFilePath, 
                                                LPWSTR wszReferenceDir);

	CHR ClassHasChildren(LPCWSTR wszClassName);
	CHR ClassHasInstances(LPCWSTR wszClassName);
	CHR ClassHasInstancesFromClassHash(LPCWSTR wszClassHash);
    CHR ClassHasInstancesInScopeFromClassHash(
                            LPCWSTR wszInstanceRootDir, LPCWSTR wszClassHash);

	CHR UpdateClassCompatible(_IWmiObject* pSuperClass, 
                LPCWSTR wszClassName, _IWmiObject *pNewClass, 
                _IWmiObject *pOldClass, __int64 nFakeUpdateTime = 0);
	CHR UpdateClassCompatibleHash(_IWmiObject* pSuperClass, 
                LPCWSTR wszClassHash, _IWmiObject *pClass, 
                _IWmiObject *pOldClass, __int64 nFakeUpdateTime = 0);
	CHR UpdateClassSafeForce(_IWmiObject* pSuperClass, DWORD dwFlags, 
                LPCWSTR wcsClassName, _IWmiObject *pOldClass, 
                _IWmiObject *pNewClass, CEventCollector &aEvents);
	CHR UpdateClassAggressively(_IWmiObject* pSuperClass, DWORD dwFlags, 
                LPCWSTR wszClassName, _IWmiObject *pNewClass, 
                _IWmiObject *pOldClass, 
                CEventCollector &aEvents);
	CHR UpdateChildClassAggressively(DWORD dwFlags, LPCWSTR wszClassHash, 
                _IWmiObject *pNewClass, 
                CEventCollector &aEvents);
	};

class CDbIterator : public CUnkBase2<IWmiDbIterator, &IID_IWmiDbIterator,
                                     IWbemObjectSink, &IID_IWbemObjectSink>
{
protected:
    CCritSec m_cs;
    CRefedPointerQueue<IWbemClassObject> m_qObjects;
    long m_lCurrentIndex;
    void* m_pExecFiber;
    CFiberTask* m_pExecReq;
    HRESULT m_hresStatus;
    
    void* m_pMainFiber;
    DWORD m_dwNumRequested;

    HRESULT m_hresCancellationStatus;
    bool m_bExecFiberRunning;
	bool m_bUseLock;

public:
    CDbIterator(CLifeControl* pControl, bool bUseLock);
    ~CDbIterator();

     STDMETHOD(Cancel) (DWORD dwFlags, void* pFiber);

     STDMETHOD(NextBatch)(
      DWORD dwNumRequested,
      DWORD dwTimeOutSeconds,
      DWORD dwFlags,
      DWORD dwRequestedHandleType,
      REFIID riid,
      void* pFiber,
      DWORD *pdwNumReturned,
      LPVOID *ppObjects
     );

    void SetExecFiber(void* pFiber, CFiberTask* pReq);
    
    STDMETHOD(Indicate)(long lNumObjects, IWbemClassObject** apObjects);
    STDMETHOD(SetStatus)(long lFlags, HRESULT hresResult, 
                                    BSTR, IWbemClassObject*);
};
    

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\xfiles\a51rep.cpp ===
/*++

Copyright (C) 2000-2001 Microsoft Corporation

--*/

#include <windows.h>
#include <wbemidl.h>
#include <wbemint.h>
#include <stdio.h>
#include <wbemcomn.h>
#include <ql.h>
#include <time.h>
#include "a51rep.h"
#include <md5.h>
#include <objpath.h>
#include "lock.h"
#include <persistcfg.h>
#include "a51fib.h"
#include "RepositoryPackager.h"


//**************************************************************************************************



HRESULT STDMETHODCALLTYPE CSession::QueryInterface(REFIID riid, void** ppv)
{
    if(riid == IID_IUnknown || riid == IID_IWmiDbSession || 
                riid == IID_IWmiDbSessionEx)
    {
        AddRef();
        *ppv = this;
        return S_OK;
    }
    else return E_NOINTERFACE;
}

ULONG STDMETHODCALLTYPE CSession::Release()
{
    return CUnkBase<IWmiDbSessionEx, &IID_IWmiDbSessionEx>::Release();
}

CSession::~CSession()
{
}
    

HRESULT STDMETHODCALLTYPE CSession::GetObject(
     IWmiDbHandle *pScope,
     IWbemPath *pPath,
     DWORD dwFlags,
     DWORD dwRequestedHandleType,
    IWmiDbHandle **ppResult
    )
{
#ifdef A51_SUPER_VERBOSE_LOGGING
	{
		DWORD dwLen = 0;
		HRESULT hres = pPath->GetText(WBEMPATH_GET_ORIGINAL, &dwLen, NULL);
		if(FAILED(hres) && hres != WBEM_E_BUFFER_TOO_SMALL)
			return hres;

		WCHAR* wszBuffer = (WCHAR*)TempAlloc(dwLen * sizeof(WCHAR));
		if(wszBuffer == NULL)
			return WBEM_E_OUT_OF_MEMORY;
		CTempFreeMe tfm(wszBuffer, dwLen * sizeof(WCHAR));

		if(FAILED(pPath->GetText(WBEMPATH_GET_ORIGINAL, &dwLen, wszBuffer)))
			return WBEM_E_FAILED;
		ERRORTRACE((LOG_REPDRV, "CSession::GetObject - pPath=<%S>\n", wszBuffer));
	}
#endif
	try
	{
        HRESULT hres;
        CAutoReadLock lock(&g_readWriteLock);

        if (!m_bInWriteTransaction)
        {
		    if (!lock.Lock())
		    	return WBEM_E_FAILED;
        }
        if (g_bShuttingDown)
        {
            return WBEM_E_SHUTTING_DOWN;
        }
    
        CNamespaceHandle* pNs = (CNamespaceHandle*)pScope;
        if(FAILED(pNs->GetErrorStatus()))
        {
            return pNs->GetErrorStatus();
        }

		hres = pNs->GetObject(pPath, dwFlags, dwRequestedHandleType, 
                                        ppResult);

		InternalCommitTransaction(false);
        return hres;
	}
	catch (...)
	{
		return WBEM_E_CRITICAL_ERROR;
	}
}


HRESULT STDMETHODCALLTYPE CSession::GetObjectDirect(
     IWmiDbHandle *pScope,
     IWbemPath *pPath,
     DWORD dwFlags,
     REFIID riid,
    LPVOID *pObj
    )
{
#ifdef A51_SUPER_VERBOSE_LOGGING
	{
		DWORD dwLen = 0;
		HRESULT hres = pPath->GetText(WBEMPATH_GET_ORIGINAL, &dwLen, NULL);
		if(FAILED(hres) && hres != WBEM_E_BUFFER_TOO_SMALL)
			return hres;

		WCHAR* wszBuffer = (WCHAR*)TempAlloc(dwLen * sizeof(WCHAR));
		if(wszBuffer == NULL)
			return WBEM_E_OUT_OF_MEMORY;
		CTempFreeMe tfm(wszBuffer, dwLen * sizeof(WCHAR));

		if(FAILED(pPath->GetText(WBEMPATH_GET_ORIGINAL, &dwLen, wszBuffer)))
			return WBEM_E_FAILED;
		ERRORTRACE((LOG_REPDRV, "CSession::GetObjectDirect - pPath=<%S>\n", wszBuffer));
	}
#endif
	try
	{
        HRESULT hres;
        CAutoReadLock lock(&g_readWriteLock);

        if (!m_bInWriteTransaction)
        {
		    if (!lock.Lock())
		    	return WBEM_E_FAILED;		    
        }
        if (g_bShuttingDown)
            return WBEM_E_SHUTTING_DOWN;

        CNamespaceHandle* pNs = (CNamespaceHandle*)pScope;
        if(FAILED(pNs->GetErrorStatus()))
        {
            return pNs->GetErrorStatus();
        }

		hres = pNs->GetObjectDirect(pPath, dwFlags, riid, pObj);
		InternalCommitTransaction(false);

        return hres;
	}
	catch (...)
	{
		return WBEM_E_CRITICAL_ERROR;
	}
}

HRESULT STDMETHODCALLTYPE CSession::GetObjectByPath(
     IWmiDbHandle *pScope,
     LPCWSTR wszObjectPath,
     DWORD dwFlags,
     REFIID riid,
    LPVOID *pObj
    )
{
#ifdef A51_SUPER_VERBOSE_LOGGING
	{
		ERRORTRACE((LOG_REPDRV, "CSession::GetObjectByPath - pPath=<%S>\n", wszObjectPath));
	}
#endif
	try
	{
        HRESULT hres;
        CAutoReadLock lock(&g_readWriteLock);

        if (!m_bInWriteTransaction)
        {
		    if (!lock.Lock())
		    	return WBEM_E_FAILED;		    
        }
        if (g_bShuttingDown)
            return WBEM_E_SHUTTING_DOWN;

        CNamespaceHandle* pNs = (CNamespaceHandle*)pScope;
        if(FAILED(pNs->GetErrorStatus()))
        {
            return pNs->GetErrorStatus();
        }

		DWORD dwLen = wcslen(wszObjectPath)+1;
		LPWSTR wszPath = (WCHAR*)TempAlloc(dwLen*sizeof(WCHAR));
		if (wszPath == NULL)
        {
			return WBEM_E_OUT_OF_MEMORY;
        }
		wcscpy(wszPath, wszObjectPath);

		CTempFreeMe vdm(wszPath, dwLen * sizeof(WCHAR));
		hres = pNs->GetObjectByPath(wszPath, dwFlags, riid, pObj);
		InternalCommitTransaction(false);

        return hres;
	}
	catch (...)
	{
		return WBEM_E_CRITICAL_ERROR;
	}
}
    


HRESULT STDMETHODCALLTYPE CSession::PutObject(
     IWmiDbHandle *pScope,
     REFIID riid,
    LPVOID pObj,
     DWORD dwFlags,
     DWORD dwRequestedHandleType,
    IWmiDbHandle **ppResult
    )
{
#ifdef A51_SUPER_VERBOSE_LOGGING
	{
		_IWmiObject* pObjEx = NULL;
		((IUnknown*)pObj)->QueryInterface(IID__IWmiObject, (void**)&pObjEx);
		CReleaseMe rm1(pObjEx);
		BSTR str = NULL;
		pObjEx->GetObjectText(0, &str);
		CSysFreeMe	sfm( str );

		ERRORTRACE((LOG_REPDRV, "CSession::PutObject Flags = <0x%X> - <%S>\n", dwFlags, str));
	}
#endif
	try
	{
        HRESULT hres;
        long lRes;
        CAutoWriteLock lock(&g_readWriteLock);
        CEventCollector aNonTransactedEvents;
        CEventCollector *aEvents = &m_aTransactedEvents;

        if (!m_bInWriteTransaction)
        {
		    if (!lock.Lock())
		    	return WBEM_E_FAILED;		    
            if (g_bShuttingDown)
                return WBEM_E_SHUTTING_DOWN;
            aEvents = &aNonTransactedEvents;
            hres = InternalBeginTransaction(true);
            if(hres != ERROR_SUCCESS)
                return hres;
            g_Glob.GetForestCache()->BeginTransaction();
        }
        else if (g_bShuttingDown)
            return WBEM_E_SHUTTING_DOWN;


        CNamespaceHandle* pNs = (CNamespaceHandle*)pScope;
        if(FAILED(pNs->GetErrorStatus()))
        {
            if(!m_bInWriteTransaction)
            {
                InternalAbortTransaction(true);
                g_Glob.GetForestCache()->AbortTransaction();
            }
            return pNs->GetErrorStatus();
        }

		hres =  pNs->PutObject(riid, pObj, dwFlags, dwRequestedHandleType, ppResult, *aEvents);
        
        if(!m_bInWriteTransaction)
        {
            if (FAILED(hres))
            {
                InternalAbortTransaction(true);
                g_Glob.GetForestCache()->AbortTransaction();
            }
            else
            {
                hres = InternalCommitTransaction(true);
                if(hres != ERROR_SUCCESS)
                {
                    g_Glob.GetForestCache()->AbortTransaction();
                }
                else
                {
                    g_Glob.GetForestCache()->CommitTransaction();
                    lock.Unlock();
                    _IWmiCoreServices * pSvcs = g_Glob.GetCoreSvcs();
                    CReleaseMe rm(pSvcs);
                    aNonTransactedEvents.SendEvents(pSvcs);
                }
            }
            aNonTransactedEvents.DeleteAllEvents();
        }
    
		return hres;
	}
	catch (...)
	{
		return WBEM_E_CRITICAL_ERROR;
	}
}

HRESULT STDMETHODCALLTYPE CSession::DeleteObject(
     IWmiDbHandle *pScope,
     DWORD dwFlags,
     REFIID riid,
     LPVOID pObj
    )
{
#ifdef A51_SUPER_VERBOSE_LOGGING
	{
		_IWmiObject* pObjEx = NULL;
		((IUnknown*)pObj)->QueryInterface(IID__IWmiObject, (void**)&pObjEx);
		CReleaseMe rm1(pObjEx);
		BSTR str = NULL;
		pObjEx->GetObjectText(0, &str);
		CSysFreeMe	sfm( str );

		ERRORTRACE((LOG_REPDRV, "CSession::DeleteObject - <%S>\n", str));
	}
#endif
	try
	{
        HRESULT hres;
        long lRes;
        CAutoWriteLock lock(&g_readWriteLock);
        CEventCollector aNonTransactedEvents;
        CEventCollector *aEvents = &m_aTransactedEvents;

        if (!m_bInWriteTransaction)
        {
		    if (!lock.Lock())
		    	return WBEM_E_FAILED;		    
            if (g_bShuttingDown)
                return WBEM_E_SHUTTING_DOWN;
            aEvents = &aNonTransactedEvents;
            hres = InternalBeginTransaction(true);
            if(hres != ERROR_SUCCESS)
                return hres;

        }
        else if (g_bShuttingDown)
            return WBEM_E_SHUTTING_DOWN;

        CNamespaceHandle* pNs = (CNamespaceHandle*)pScope;
        if(FAILED(pNs->GetErrorStatus()))
        {
            if(!m_bInWriteTransaction)
            {
                InternalAbortTransaction(true);
            }
            return pNs->GetErrorStatus();
        }

		hres = pNs->DeleteObject(dwFlags, riid, pObj, *aEvents);

        if(!m_bInWriteTransaction)
        {
            if (FAILED(hres))
            {
                InternalAbortTransaction(true);
            }
            else
            {
                hres = InternalCommitTransaction(true);
                if(hres == ERROR_SUCCESS)
                {
                    lock.Unlock();
                    _IWmiCoreServices * pSvcs = g_Glob.GetCoreSvcs();
                    CReleaseMe rm(pSvcs);
                    aNonTransactedEvents.SendEvents(pSvcs);                    
                }
            }
            aNonTransactedEvents.DeleteAllEvents();
        }

		return hres;
	}
	catch (...)
	{
		return WBEM_E_CRITICAL_ERROR;
	}
}

HRESULT STDMETHODCALLTYPE CSession::DeleteObjectByPath(
     IWmiDbHandle *pScope,
     LPCWSTR wszObjectPath,
     DWORD dwFlags
    )
{
#ifdef A51_SUPER_VERBOSE_LOGGING
	{
		ERRORTRACE((LOG_REPDRV, "CSession::DeleteObjectByPath - <%S>\n", wszObjectPath));
	}
#endif
	try
	{
        HRESULT hres;
        long lRes;
        CAutoWriteLock lock(&g_readWriteLock);
        CEventCollector aNonTransactedEvents;
        CEventCollector *aEvents = &m_aTransactedEvents;

        if (!m_bInWriteTransaction)
        {
		    if (!lock.Lock())
		    	return WBEM_E_FAILED;		    
            if (g_bShuttingDown)
                return WBEM_E_SHUTTING_DOWN;
            aEvents = &aNonTransactedEvents;
            hres = InternalBeginTransaction(true);
            if(hres != ERROR_SUCCESS)
                return hres;

        }
        else if (g_bShuttingDown)
            return WBEM_E_SHUTTING_DOWN;

        CNamespaceHandle* pNs = (CNamespaceHandle*)pScope;
        if(FAILED(pNs->GetErrorStatus()))
        {
            if(!m_bInWriteTransaction)
            {
                InternalAbortTransaction(true);
            }
            return pNs->GetErrorStatus();
        }
		DWORD dwLen = wcslen(wszObjectPath)+1;
		LPWSTR wszPath = (WCHAR*)TempAlloc(dwLen*sizeof(WCHAR));
		if (wszPath == NULL)
        {
            if(!m_bInWriteTransaction)
            {
                InternalAbortTransaction(true);
            }
			return WBEM_E_OUT_OF_MEMORY;
        }
		wcscpy(wszPath, wszObjectPath);

		CTempFreeMe vdm(wszPath, dwLen * sizeof(WCHAR));

		hres = pNs->DeleteObjectByPath(dwFlags, wszPath, *aEvents);

        if(!m_bInWriteTransaction)
        {
            if (FAILED(hres))
            {
                InternalAbortTransaction(true);
            }
            else
            {
                hres = InternalCommitTransaction(true);
                if(hres == ERROR_SUCCESS)
                {
                    lock.Unlock();
                    _IWmiCoreServices * pSvcs = g_Glob.GetCoreSvcs();
                    CReleaseMe rm(pSvcs);
                    aNonTransactedEvents.SendEvents(pSvcs);                    
                }
            }
            aNonTransactedEvents.DeleteAllEvents();
        }

		return hres;
	}
	catch (...)
	{
		return WBEM_E_CRITICAL_ERROR;
	}
}

HRESULT STDMETHODCALLTYPE CSession::ExecQuery(
     IWmiDbHandle *pScope,
     IWbemQuery *pQuery,
     DWORD dwFlags,
     DWORD dwRequestedHandleType,
    DWORD *dwMessageFlags,
    IWmiDbIterator **ppQueryResult
    )
{
#ifdef A51_SUPER_VERBOSE_LOGGING
	{
		LPWSTR wszQuery = NULL;
		HRESULT hres = pQuery->GetAnalysis(WMIQ_ANALYSIS_QUERY_TEXT, 0, (void**)&wszQuery);
		if (FAILED(hres))
			return hres;

		ERRORTRACE((LOG_REPDRV, "CSession::ExecQuery - <%S>\n", wszQuery));
		pQuery->FreeMemory(wszQuery);
	}
#endif
	try
	{
        HRESULT hres;
        CAutoReadLock lock(&g_readWriteLock);

        if (!m_bInWriteTransaction)
        {
		    if (!lock.Lock())
		    	return WBEM_E_FAILED;		    
        }
        if (g_bShuttingDown)
            return WBEM_E_SHUTTING_DOWN;

        CNamespaceHandle* pNs = (CNamespaceHandle*)pScope;
        if(FAILED(pNs->GetErrorStatus()))
        {
            return pNs->GetErrorStatus();
        }

		//If we are in a transaction, we have to get a message to the iteratir
		//on create so it does not mess around with the locks!
		if (m_bInWriteTransaction)
			pNs->TellIteratorNotToLock();

		hres = pNs->ExecQuery(pQuery, dwFlags,
				 dwRequestedHandleType, dwMessageFlags, ppQueryResult);
		InternalCommitTransaction(false);

        return hres;
	}
	catch (...)
	{
		return WBEM_E_CRITICAL_ERROR;
	}
}

HRESULT STDMETHODCALLTYPE CSession::ExecQuerySink(
     IWmiDbHandle *pScope,
     IWbemQuery *pQuery,
     DWORD dwFlags,
     DWORD dwRequestedHandleType,
     IWbemObjectSink* pSink,
    DWORD *dwMessageFlags
    )
{
	try
	{
        HRESULT hres;
        CAutoReadLock lock(&g_readWriteLock);

        if (!m_bInWriteTransaction)
        {
		    if (!lock.Lock())
		    	return WBEM_E_FAILED;		    
        }
        if (g_bShuttingDown)
            return WBEM_E_SHUTTING_DOWN;

        CNamespaceHandle* pNs = (CNamespaceHandle*)pScope;
        if(FAILED(pNs->GetErrorStatus()))
        {
            return pNs->GetErrorStatus();
        }

		hres = pNs->ExecQuerySink(pQuery, dwFlags,
				 dwRequestedHandleType, pSink, dwMessageFlags);

		InternalCommitTransaction(false);
        return hres;
	}
	catch (...)
	{
		return WBEM_E_CRITICAL_ERROR;
	}
}
                    
    
HRESULT STDMETHODCALLTYPE CSession::RenameObject(
     IWbemPath *pOldPath,
     IWbemPath *pNewPath,
     DWORD dwFlags,
     DWORD dwRequestedHandleType,
    IWmiDbHandle **ppResult
    )
{
    DebugBreak();
    return E_NOTIMPL;
}

HRESULT STDMETHODCALLTYPE CSession::Enumerate(
     IWmiDbHandle *pScope,
     DWORD dwFlags,
     DWORD dwRequestedHandleType,
    IWmiDbIterator **ppQueryResult
    )
{
    DebugBreak();
    return E_NOTIMPL;
}

HRESULT STDMETHODCALLTYPE CSession::AddObject(
     IWmiDbHandle *pScope,
     IWbemPath *pPath,
     DWORD dwFlags,
     DWORD dwRequestedHandleType,
    IWmiDbHandle **ppResult
    )
{
    DebugBreak();
    return E_NOTIMPL;
}

HRESULT STDMETHODCALLTYPE CSession::RemoveObject (
     IWmiDbHandle *pScope,
     IWbemPath *pPath,
     DWORD dwFlags
    )
{
    DebugBreak();
    return E_NOTIMPL;
}

HRESULT STDMETHODCALLTYPE CSession::SetDecoration(
     LPWSTR lpMachineName,
     LPWSTR lpNamespacePath
    )
{
    //
    // As the default driver, we really don't care.
    //

    return WBEM_S_NO_ERROR;
}

HRESULT STDMETHODCALLTYPE CSession::BeginWriteTransaction(DWORD dwFlags)
{
    if (CLock::NoError != g_readWriteLock.WriteLock())
    	return WBEM_E_FAILED;
    
    if (g_bShuttingDown)
    {
        g_readWriteLock.WriteUnlock();
        return WBEM_E_SHUTTING_DOWN;
    }

    HRESULT hres = InternalBeginTransaction(true);
    if(hres != ERROR_SUCCESS)
    {
        g_readWriteLock.WriteUnlock();
        return hres;
    }

    m_bInWriteTransaction = true;
    return ERROR_SUCCESS;
}

HRESULT STDMETHODCALLTYPE CSession::BeginReadTransaction(DWORD dwFlags)
{
    if (CLock::NoError != g_readWriteLock.ReadLock())
    	return WBEM_E_FAILED;
    
    if (g_bShuttingDown)
    {
        g_readWriteLock.ReadUnlock();
        return WBEM_E_SHUTTING_DOWN;
    }

    return ERROR_SUCCESS;
}

HRESULT STDMETHODCALLTYPE CSession::CommitTransaction(DWORD dwFlags)
{
    if (m_bInWriteTransaction)
    {
        long lRes = g_Glob.GetFileCache()->CommitTransaction();
        if(lRes != ERROR_SUCCESS)
        {
            HRESULT hres = A51TranslateErrorCode(lRes);
            AbortTransaction(0);
			CRepository::RecoverCheckpoint();
            return hres;
        }
		else
		{
			CRepository::WriteOperationNotification();
		}

        m_bInWriteTransaction = false;

        //Copy the event list and delete the original.  We need to deliver
        //outside the write lock.
        CEventCollector aTransactedEvents;
        aTransactedEvents.TransferEvents(m_aTransactedEvents);

        g_readWriteLock.WriteUnlock();

        _IWmiCoreServices * pSvcs = g_Glob.GetCoreSvcs();
        CReleaseMe rm(pSvcs);
        aTransactedEvents.SendEvents(pSvcs);
        aTransactedEvents.DeleteAllEvents();
    }
    else
    {
        if (m_aTransactedEvents.GetSize())
		{
            _ASSERT(false, L"Read transaction has events to send");
		}
        g_readWriteLock.ReadUnlock();
   }
    return ERROR_SUCCESS;
}

HRESULT STDMETHODCALLTYPE CSession::AbortTransaction(DWORD dwFlags)
{
    if (m_bInWriteTransaction)
    {
        m_bInWriteTransaction = false;
        g_Glob.GetFileCache()->AbortTransaction();
        m_aTransactedEvents.DeleteAllEvents();
        g_readWriteLock.WriteUnlock();
    }
    else
    {
        if (m_aTransactedEvents.GetSize())
		{
            _ASSERT(false, L"Read transaction has events to send");
		}
        g_readWriteLock.ReadUnlock();
    }
    return ERROR_SUCCESS;
}


HRESULT CSession::InternalBeginTransaction(bool bWriteOperation)
{
	if (bWriteOperation)
	{
		long lRes = g_Glob.GetFileCache()->BeginTransaction();
		if (lRes)
		{
			//An internal error state may have been triggered, therefore
			//we should try and recover from that and try again...
			CRepository::RecoverCheckpoint();

			lRes = g_Glob.GetFileCache()->BeginTransaction();
		}
		return A51TranslateErrorCode(lRes);
	}
	else
		return ERROR_SUCCESS;
}
HRESULT CSession::InternalAbortTransaction(bool bWriteOperation)
{
	if (bWriteOperation)
	{
		g_Glob.GetFileCache()->AbortTransaction();
	}

	return ERROR_SUCCESS;
}
HRESULT CSession::InternalCommitTransaction(bool bWriteOperation)
{
	DWORD dwres = ERROR_SUCCESS;

	if (bWriteOperation)
	{
		long lRes = g_Glob.GetFileCache()->CommitTransaction();
		if(lRes != ERROR_SUCCESS)
		{
			dwres = A51TranslateErrorCode(lRes);
			InternalAbortTransaction(bWriteOperation);
			CRepository::RecoverCheckpoint();
		}
		else 
		{
			CRepository::WriteOperationNotification();
		}
	}
	else
	{
		CRepository::ReadOperationNotification();
	}

	return dwres;
}

//
//
//
//
///////////////////////////////////////////////////////////////////////

long CNamespaceHandle::s_lActiveRepNs = 0;

CNamespaceHandle::CNamespaceHandle(CLifeControl* pControl,CRepository * pRepository)
    : TUnkBase(pControl), m_pClassCache(NULL),
       m_pNullClass(NULL), m_bCached(false), m_pRepository(pRepository),
	   m_bUseIteratorLock(true)
{    
    m_pRepository->AddRef();
    // unrefed pointer to a global
    m_ForestCache = g_Glob.GetForestCache(); 
    InterlockedIncrement(&s_lActiveRepNs);
}

CNamespaceHandle::~CNamespaceHandle()
{
    if(m_pClassCache)
    {
        // give-up our own reference
        // m_pClassCache->Release();
        // remove from the Forest cache this namespace
        m_ForestCache->ReleaseNamespaceCache(m_wsNamespace, m_pClassCache);
    }

    m_pRepository->Release();
    if(m_pNullClass)
        m_pNullClass->Release();
    InterlockedDecrement(&s_lActiveRepNs);
}

CHR CNamespaceHandle::GetErrorStatus()
{
    //
    // TEMP CODE: Someone is calling us on an impersonated thread.  Let's catch
    // the, ahem, culprit
    //

    HANDLE hToken;
    BOOL bRes = OpenThreadToken(GetCurrentThread(), TOKEN_READ, TRUE, &hToken);
    if(bRes)
    {
        //_ASSERT(false, L"Called with a thread token");
        ERRORTRACE((LOG_WBEMCORE, "Repository called with a thread token! "
                        "It shall be removed\n"));
        CloseHandle(hToken);
        SetThreadToken(NULL, NULL);
    }

    return m_pClassCache->GetError();
}

void CNamespaceHandle::SetErrorStatus(HRESULT hres)
{
    m_pClassCache->SetError(hres);
}

CHR CNamespaceHandle::Initialize(LPCWSTR wszNamespace, LPCWSTR wszScope)
{
    HRESULT hres;

    m_wsNamespace = wszNamespace;
    m_wsFullNamespace = L"\\\\.\\";
    m_wsFullNamespace += wszNamespace;

    DWORD dwSize = MAX_COMPUTERNAME_LENGTH+1;
    GetComputerNameW(m_wszMachineName, &dwSize);

    if(wszScope)
        m_wsScope = wszScope;

    //
    // Ask the forest for the cache for this namespace
    //

    m_pClassCache = g_Glob.GetForestCache()->
                        GetNamespaceCache(wszNamespace);
    if(m_pClassCache == NULL)
        return WBEM_E_OUT_OF_MEMORY;

    wcscpy(m_wszClassRootDir, g_Glob.GetRootDir());

    //
    // Append namespace-specific prefix
    //

    wcscat(m_wszClassRootDir, L"\\NS_");

    //
    // Append hashed namespace name
    //

    if (!Hash(wszNamespace, m_wszClassRootDir + wcslen(m_wszClassRootDir)))
		return WBEM_E_OUT_OF_MEMORY;
	m_lClassRootDirLen = wcslen(m_wszClassRootDir);

    //
    // Constuct the instance root dir
    //

    if(wszScope == NULL)
    {
        //
        // Basic namespace --- instances go into the root of the namespace
        //

        wcscpy(m_wszInstanceRootDir, m_wszClassRootDir);
        m_lInstanceRootDirLen = m_lClassRootDirLen;
    }   
    else
    {
        wcscpy(m_wszInstanceRootDir, m_wszClassRootDir);
        wcscat(m_wszInstanceRootDir, L"\\" A51_SCOPE_DIR_PREFIX);
        if(!Hash(m_wsScope, 
                 m_wszInstanceRootDir + wcslen(m_wszInstanceRootDir)))
        {
            return WBEM_E_OUT_OF_MEMORY;
        }

        m_lInstanceRootDirLen = wcslen(m_wszInstanceRootDir);
    }
        

    return WBEM_S_NO_ERROR;
}



CHR CNamespaceHandle::GetObject(
     IWbemPath *pPath,
     DWORD dwFlags,
     DWORD dwRequestedHandleType,
    IWmiDbHandle **ppResult
    )
{
    HRESULT hres;

    if((dwRequestedHandleType & WMIDB_HANDLE_TYPE_COOKIE) == 0)
    {
        DebugBreak();
        return E_NOTIMPL;
    }

    DWORD dwLen = 0;
    hres = pPath->GetText(WBEMPATH_GET_ORIGINAL, &dwLen, NULL);
    if(FAILED(hres) && hres != WBEM_E_BUFFER_TOO_SMALL)
        return hres;

    WCHAR* wszBuffer = (WCHAR*)TempAlloc(dwLen * sizeof(WCHAR));
    if(wszBuffer == NULL)
        return WBEM_E_OUT_OF_MEMORY;
    CTempFreeMe tfm(wszBuffer, dwLen * sizeof(WCHAR));

    if(FAILED(pPath->GetText(WBEMPATH_GET_ORIGINAL, &dwLen, wszBuffer)))
        return WBEM_E_FAILED;

    return GetObjectHandleByPath(wszBuffer, dwFlags, dwRequestedHandleType, 
        ppResult);
}

CHR CNamespaceHandle::GetObjectHandleByPath(
     LPWSTR wszBuffer,
     DWORD dwFlags,
     DWORD dwRequestedHandleType,
    IWmiDbHandle **ppResult
    )
{
    //
    // Get the key from path
    //

    DWORD dwLen = wcslen(wszBuffer)*sizeof(WCHAR)+2;
    LPWSTR wszKey = (WCHAR*)TempAlloc(dwLen);
    if(wszKey == NULL)
        return WBEM_E_OUT_OF_MEMORY;
    CTempFreeMe tfm(wszKey, dwLen);

    bool bIsClass;
    LPWSTR wszClassName = NULL;
    HRESULT hres = ComputeKeyFromPath(wszBuffer, wszKey, &wszClassName, 
                                        &bIsClass);
    if(FAILED(hres))
        return hres;
    CTempFreeMe tfm1(wszClassName, (wcslen(wszClassName)+1) * sizeof(WCHAR*));

    //
    // Check if it exists (except for ROOT --- it's fake)
    //

    _IWmiObject* pObj = NULL;
    if(m_wsNamespace.Length() > 0)
    {
        hres = GetInstanceByKey(wszClassName, wszKey, IID__IWmiObject, 
            (void**)&pObj);
        if(FAILED(hres))
            return hres;
    }
    CReleaseMe rm1(pObj);

    CNamespaceHandle* pNewHandle = new CNamespaceHandle(m_pControl,m_pRepository);
	if (pNewHandle == NULL)
		return WBEM_E_OUT_OF_MEMORY;

    pNewHandle->AddRef();
    CReleaseMe rm2(pNewHandle);

    //
    // Check if this is a namespace or not
    //

    if(pObj == NULL || pObj->InheritsFrom(L"__Namespace") == S_OK)
    {
        //
        // It's a namespace.  Open a basic handle pointing to it
        //

        WString wsName = m_wsNamespace;
        if(wsName.Length() > 0)
            wsName += L"\\";
        wsName += wszKey;
    
        hres = pNewHandle->Initialize(wsName);

        //
        // Since our namespace is for real, tell the cache that it is now valid.
        // The cache might have been invalidated if this namespace was deleted 
        // in the past
        //
        if (SUCCEEDED(hres))
            pNewHandle->SetErrorStatus(S_OK);
    }
    else
    {
        // 
        // It's a scope.  Construct the new scope name by appending this 
        // object's path to our own scope
        //

        VARIANT v;
        VariantInit(&v);
        CClearMe cm(&v);
        hres = pObj->Get(L"__RELPATH", 0, &v, NULL, NULL);
        if(FAILED(hres))
            return hres;
        if(V_VT(&v) != VT_BSTR)
            return WBEM_E_INVALID_OBJECT;

        WString wsScope = m_wsScope;
        if(wsScope.Length() > 0)
            wsScope += L":";
        wsScope += V_BSTR(&v);

        hres = pNewHandle->Initialize(m_wsNamespace, wsScope);
    }
        
    if(FAILED(hres))
        return hres;

    return pNewHandle->QueryInterface(IID_IWmiDbHandle, (void**)ppResult);
}
    
CHR CNamespaceHandle::ComputeKeyFromPath(LPWSTR wszPath, LPWSTR wszKey,
                                            TEMPFREE_ME LPWSTR* pwszClass,
                                            bool* pbIsClass,
                                            TEMPFREE_ME LPWSTR* pwszNamespace)
{
    HRESULT hres;

    *pbIsClass = false;

    //
    // Get and skip the namespace portion.
    //

    if(wszPath[0] == '\\' || wszPath[0] == '/')
    {
        //
        // Find where the server portion ends
        //

        WCHAR* pwcNextSlash = wcschr(wszPath+2, wszPath[0]);
        if(pwcNextSlash == NULL)
            return WBEM_E_INVALID_OBJECT_PATH;
        
        //
        // Find where the namespace portion ends
        //

        WCHAR* pwcColon = wcschr(pwcNextSlash, L':');
        if(pwcColon == NULL)
            return WBEM_E_INVALID_OBJECT_PATH;
    
        if(pwszNamespace)
        {
            DWORD dwLen = pwcColon - pwcNextSlash;
            *pwszNamespace = (WCHAR*)TempAlloc(dwLen * sizeof(WCHAR));
            if(*pwszNamespace == NULL)
                return WBEM_E_OUT_OF_MEMORY;
            
            *pwcColon = 0;
            wcscpy(*pwszNamespace, pwcNextSlash+1);
        }

        //
        // Advance wszPath to beyond the namespace portion
        //

        wszPath = pwcColon+1;
    }
    else if(pwszNamespace)
    {
        *pwszNamespace = NULL;
    }

    // Get the first key

    WCHAR* pwcFirstEq = wcschr(wszPath, L'=');
    if(pwcFirstEq == NULL)
    {
        //
        // It's a class!
        //

        *pbIsClass = true;
        // path to the "class" to distinguish from its  instances
        wszKey[0] = 1;
        wszKey[1] = 0;

        *pwszClass = (WCHAR*)TempAlloc((wcslen(wszPath)+1) * sizeof(WCHAR));
        if(*pwszClass == NULL)
        {
            if(pwszNamespace)
                TempFree(*pwszNamespace);
            return WBEM_E_OUT_OF_MEMORY;
        }
        wcscpy(*pwszClass, wszPath);
        return S_OK;
    }

    WCHAR* pwcFirstDot = wcschr(wszPath, L'.');

    if(pwcFirstDot == NULL || pwcFirstDot > pwcFirstEq)
    {
        // No name on the first key

        *pwcFirstEq = 0;

        *pwszClass = (WCHAR*)TempAlloc((wcslen(wszPath)+1) * sizeof(WCHAR));
        if(*pwszClass == NULL)
		{
			if(pwszNamespace)
				TempFree(*pwszNamespace);
			return WBEM_E_OUT_OF_MEMORY;
		}
        wcscpy(*pwszClass, wszPath);
    
        WCHAR* pwcThisKey = NULL;
        WCHAR* pwcEnd = NULL;
        hres = ParseKey(pwcFirstEq+1, &pwcThisKey, &pwcEnd);
        if(FAILED(hres))
        {
            TempFree(*pwszClass);
            if(pwszNamespace)
                TempFree(*pwszNamespace);

            return hres;
        }
        if(*pwcEnd != NULL)
        {
            TempFree(*pwszClass);
            if(pwszNamespace)
                TempFree(*pwszNamespace);

            return WBEM_E_INVALID_OBJECT_PATH;
        }

        wcscpy(wszKey, pwcThisKey);
        return S_OK;
    }

    //
    // Normal case
    //

    //
    // Get all the key values
    //

    struct CKeyStruct
    {
        WCHAR* m_pwcValue;
        WCHAR* m_pwcName;
    } * aKeys = (CKeyStruct*)TempAlloc(sizeof(CKeyStruct[256]));

    if (0==aKeys)
    {
        if(pwszNamespace)
            TempFree(*pwszNamespace);
      return WBEM_E_OUT_OF_MEMORY;
    }
    CTempFreeMe release_aKeys(aKeys);

    DWORD dwNumKeys = 0;

    *pwcFirstDot = NULL;

    *pwszClass = (WCHAR*)TempAlloc((wcslen(wszPath)+1) * sizeof(WCHAR));
    if(*pwszClass == NULL)
    {
        if(pwszNamespace)
            TempFree(*pwszNamespace);
        return WBEM_E_OUT_OF_MEMORY;
    }

    wcscpy(*pwszClass, wszPath);

    WCHAR* pwcNextKey = pwcFirstDot+1;

    do
    {
        pwcFirstEq = wcschr(pwcNextKey, L'=');
        if(pwcFirstEq == NULL)
        {
            TempFree(*pwszClass);
            if(pwszNamespace)
                TempFree(*pwszNamespace);

            return WBEM_E_INVALID_OBJECT_PATH;
        }
        
        *pwcFirstEq = 0;

        aKeys[dwNumKeys].m_pwcName = pwcNextKey;
        hres = ParseKey(pwcFirstEq+1, &(aKeys[dwNumKeys].m_pwcValue), 
                            &pwcNextKey);
        if(FAILED(hres))
        {
            TempFree(*pwszClass);
            if(pwszNamespace)
                TempFree(*pwszNamespace);

            return hres;
        }
		dwNumKeys++;
    }
    while(*pwcNextKey);

    if(*pwcNextKey != 0)
    {
        TempFree(*pwszClass);
        if(pwszNamespace)
            TempFree(*pwszNamespace);

        return WBEM_E_INVALID_OBJECT_PATH;
    }
    
    //
    // We have the array of keys --- sort it
    //

    DWORD dwCurrentIndex = 0;
    while(dwCurrentIndex < dwNumKeys-1)
    {
        if(wbem_wcsicmp(aKeys[dwCurrentIndex].m_pwcName, 
                        aKeys[dwCurrentIndex+1].m_pwcName) > 0)
        {
            CKeyStruct Temp = aKeys[dwCurrentIndex];
            aKeys[dwCurrentIndex] = aKeys[dwCurrentIndex+1];
            aKeys[dwCurrentIndex+1] = Temp;
            if(dwCurrentIndex)
                dwCurrentIndex--;
            else
                dwCurrentIndex++;
        }
        else
            dwCurrentIndex++;
    }

    //
    // Now generate the result
    //
    
    WCHAR* pwcKeyEnd = wszKey;
    for(DWORD i = 0; i < dwNumKeys; i++)
    {
        wcscpy(pwcKeyEnd, aKeys[i].m_pwcValue);
        pwcKeyEnd += wcslen(aKeys[i].m_pwcValue);
        if(i < dwNumKeys-1)
            *(pwcKeyEnd++) = -1;
    }
    *pwcKeyEnd = 0;
    return S_OK;
}

CHR CNamespaceHandle::ParseKey(LPWSTR wszKeyStart, LPWSTR* pwcRealStart,
                                    LPWSTR* pwcNextKey)
{
    if(wszKeyStart[0] == L'"' || wszKeyStart[0] == L'\'')
    {
        WCHAR wcStart = wszKeyStart[0];
        WCHAR* pwcRead = wszKeyStart+1;
        WCHAR* pwcWrite = wszKeyStart+1;
        while(*pwcRead && *pwcRead != wcStart)  
        {
            if((*pwcRead == '\\') && (*(pwcRead+1) != 'x') && (*(pwcRead+1) != 'X'))
                pwcRead++;

            *(pwcWrite++) = *(pwcRead++);
        }
        if(*pwcRead == 0)
            return WBEM_E_INVALID_OBJECT_PATH;

        *pwcWrite = 0;
        if(pwcRealStart)
            *pwcRealStart = wszKeyStart+1;

        //
        // Check separator
        //
    
        if(pwcRead[1] && pwcRead[1] != L',')
            return WBEM_E_INVALID_OBJECT_PATH;
            
        if(pwcNextKey)
		{
			//
			// If there is a separator, skip it.  Don't skip end of string!
			//

			if(pwcRead[1])
	            *pwcNextKey = pwcRead+2;
			else
				*pwcNextKey = pwcRead+1;
		}
    }
    else
    {
        if(pwcRealStart)
            *pwcRealStart = wszKeyStart;
        WCHAR* pwcComma = wcschr(wszKeyStart, L',');
        if(pwcComma == NULL)
        {
            if(pwcNextKey)
                *pwcNextKey = wszKeyStart + wcslen(wszKeyStart);
        }
        else
        {
            *pwcComma = 0;
            if(pwcNextKey)
                *pwcNextKey = pwcComma+1;
        }
    }

    return S_OK;
}
            

CHR CNamespaceHandle::GetObjectDirect(
     IWbemPath *pPath,
     DWORD dwFlags,
     REFIID riid,
    LPVOID *pObj
    )
{
    HRESULT hres;

    DWORD dwLen = 0;
    hres = pPath->GetText(WBEMPATH_GET_ORIGINAL, &dwLen, NULL);

    LPWSTR wszPath = (WCHAR*)TempAlloc(dwLen*sizeof(WCHAR));
	if (wszPath == NULL)
		return WBEM_E_OUT_OF_MEMORY;
    CTempFreeMe vdm(wszPath, dwLen * sizeof(WCHAR));

    hres = pPath->GetText(WBEMPATH_GET_ORIGINAL, &dwLen, wszPath);
    if(FAILED(hres))
        return hres;


    return GetObjectByPath(wszPath, dwFlags, riid, pObj);
}

CHR CNamespaceHandle::GetObjectByPath(
     LPWSTR wszPath,
     DWORD dwFlags,
     REFIID riid,
     LPVOID *pObj
    )
{
    HRESULT hres;

    //
    // Get the key from path
    //

    DWORD dwLen = wcslen(wszPath)*sizeof(WCHAR)+2;
    LPWSTR wszKey = (WCHAR*)TempAlloc(dwLen);
    if(wszKey == NULL)
        return WBEM_E_OUT_OF_MEMORY;
    CTempFreeMe tfm(wszKey, dwLen);

    bool bIsClass;
    LPWSTR wszClassName = NULL;
    hres = ComputeKeyFromPath(wszPath, wszKey, &wszClassName, &bIsClass);
    if(FAILED(hres))
        return hres;
    CTempFreeMe tfm1(wszClassName, (wcslen(wszClassName)+1) * sizeof(WCHAR*));

    if(bIsClass)
    {
        return GetClassDirect(wszClassName, riid, pObj, true, NULL, NULL, NULL);
    }
    else
    {
        return GetInstanceByKey(wszClassName, wszKey, riid, pObj);
    }
}

CHR CNamespaceHandle::GetInstanceByKey(LPCWSTR wszClassName,
                                LPCWSTR wszKey,
                                REFIID riid, void** ppObj)
{
    HRESULT hres;

    //
    // Get the class definition
    //

    _IWmiObject* pClass = NULL;
    hres = GetClassDirect(wszClassName, IID__IWmiObject, (void**)&pClass, 
                            false, NULL, NULL, NULL);
    if(FAILED(hres))
        return hres;
    CReleaseMe rm1(pClass);

    //
    // Construct directory path
    //

    CFileName wszFilePath;
	if (wszFilePath == NULL)
		return WBEM_E_OUT_OF_MEMORY;
    hres = ConstructKeyRootDirFromClass(wszFilePath, wszClassName);
    if(FAILED(hres))
        return hres;

    //
    // Construct the file path
    //

    int nLen = wcslen(wszFilePath);
    wszFilePath[nLen] = L'\\';

    hres = ConstructInstanceDefName(wszFilePath+nLen+1, wszKey);
    if(FAILED(hres))
        return hres;
    
    //
    // Get the object from that file
    //

    _IWmiObject* pInst;
    hres = FileToInstance(NULL, wszFilePath, NULL, 0, &pInst);
    if(FAILED(hres))
        return hres;
	CReleaseMe rm2(pInst);

    //
    // Return
    //

    return pInst->QueryInterface(riid, (void**)ppObj);
}

CHR CNamespaceHandle::GetClassByHash(LPCWSTR wszHash, bool bClone, 
                                            _IWmiObject** ppClass,
                                            __int64* pnTime,
                                            bool* pbRead,
											bool *pbSystemClass)
{
    HRESULT hres;

    //
    // Check the cache first
    //

    *ppClass = m_pClassCache->GetClassDefByHash(wszHash, bClone, pnTime, pbRead, pbSystemClass);
    if(*ppClass)
        return S_OK;

    //
    // Not found --- construct the file name and read it
    //

    if(pbRead)
        *pbRead = true;

    CFileName wszFileName;
	if (wszFileName == NULL)
		return WBEM_E_OUT_OF_MEMORY;
    hres = ConstructClassDefFileNameFromHash(wszHash, wszFileName);
    if(FAILED(hres))
        return hres;

    CFileName wszFilePath;
	if (wszFilePath == NULL)
		return WBEM_E_OUT_OF_MEMORY;
    swprintf(wszFilePath, L"%s\\%s", m_wszClassRootDir, wszFileName);

    hres = FileToClass(wszFilePath, ppClass, bClone, pnTime, pbSystemClass);
    if(FAILED(hres))
        return hres;

    return S_OK;
}

    
CHR CNamespaceHandle::GetClassDirect(LPCWSTR wszClassName,
                                REFIID riid, void** ppObj, bool bClone,
                                __int64* pnTime, bool* pbRead, 
								bool *pbSystemClass)
{
    HRESULT hres;

    if(wszClassName == NULL || wcslen(wszClassName) == 0)
    {
        if(m_pNullClass == NULL)
        {
            hres = CoCreateInstance(CLSID_WbemClassObject, NULL, 
                        CLSCTX_INPROC_SERVER,
                        IID__IWmiObject, (void **)&m_pNullClass);
            if (FAILED(hres))
                return hres;
        }

        IWbemClassObject* pRawObj;
        hres = m_pNullClass->Clone(&pRawObj);
		if (FAILED(hres))
			return hres;
        CReleaseMe rm(pRawObj);
        if(pnTime)
            *pnTime = 0;
        if(pbRead)
            *pbRead = false;

        return pRawObj->QueryInterface(riid, ppObj);
    }

    _IWmiObject* pClass;

    //
    // Check the cache first
    //

    pClass = m_pClassCache->GetClassDef(wszClassName, bClone, pnTime, pbRead);
    if(pClass)
    {
        CReleaseMe rm1(pClass);
        return pClass->QueryInterface(riid, ppObj);
    }

    if(pbRead)
        *pbRead = true;

    //
    // Construct the path for the file
    //

    CFileName wszFileName;
	if (wszFileName == NULL)
		return WBEM_E_OUT_OF_MEMORY;
    hres = ConstructClassDefFileName(wszClassName, wszFileName);
    if(FAILED(hres))
        return hres;

    CFileName wszFilePath;
	if (wszFilePath == NULL)
		return WBEM_E_OUT_OF_MEMORY;
    swprintf(wszFilePath, L"%s\\%s", m_wszClassRootDir, wszFileName);

    //
    // Read it from the file
    //

    hres = FileToClass(wszFilePath, &pClass, bClone, pnTime, pbSystemClass);
    if(FAILED(hres))
	    return hres;
    CReleaseMe rm1(pClass);

    return pClass->QueryInterface(riid, ppObj);
}

CHR CNamespaceHandle::FileToInstance(_IWmiObject* pClass,
									 LPCWSTR wszFileName, 
									 BYTE *pRetrievedBlob,
									 DWORD dwSize,
									 _IWmiObject** ppInstance, 
									 bool bMustBeThere)
{
    HRESULT hres;

    //
    // Read the data from the file
    //

	BYTE* pBlob = NULL;
	if (pRetrievedBlob == NULL)
	{
		long lRes = g_Glob.GetFileCache()->ReadObject(wszFileName, &dwSize, &pBlob, 
											 bMustBeThere);
		if(lRes != ERROR_SUCCESS)
		{
			if(lRes == ERROR_FILE_NOT_FOUND || lRes == ERROR_PATH_NOT_FOUND)
				return WBEM_E_NOT_FOUND;
			else
				return WBEM_E_FAILED;
		}
		pRetrievedBlob = pBlob;
	}

	CTempFreeMe tfm1(pBlob, dwSize);

    _ASSERT(dwSize > sizeof(__int64), L"Instance blob too short");
    if(dwSize <= sizeof(__int64))
        return WBEM_E_OUT_OF_MEMORY;

    //
    // Extract the class hash
    //

    WCHAR wszClassHash[MAX_HASH_LEN+1];
    DWORD dwClassHashLen = MAX_HASH_LEN*sizeof(WCHAR);
    memcpy(wszClassHash, pRetrievedBlob, MAX_HASH_LEN*sizeof(WCHAR));
    wszClassHash[MAX_HASH_LEN] = 0;

    __int64 nInstanceTime;
    memcpy(&nInstanceTime, pRetrievedBlob + dwClassHashLen, sizeof(__int64));

    __int64 nOldClassTime;
    memcpy(&nOldClassTime, pRetrievedBlob + dwClassHashLen + sizeof(__int64), 
            sizeof(__int64));

    BYTE* pInstancePart = pRetrievedBlob + dwClassHashLen + sizeof(__int64)*2;
    DWORD dwInstancePartSize = dwSize - dwClassHashLen - sizeof(__int64)*2;

    //
    // Get the class def
    //

    _IWmiObject* pRetrievedClass = NULL;
	if (pClass == NULL)
	{
		__int64 nClassTime;
		bool bRead;
		bool bSystemClass = false;
		hres = GetClassByHash(wszClassHash, false, &pRetrievedClass, &nClassTime, &bRead, &bSystemClass);
		if(FAILED(hres))
			return hres;
		pClass = pRetrievedClass;
	}
    CReleaseMe rm1(pRetrievedClass);

#ifdef A51_CHECK_TIMESTAMPS
    _ASSERT(nClassTime <= nInstanceTime, L"Instance is older than its class");
    _ASSERT(nClassTime == nOldClassTime, L"Instance verified with the wrong "
                        L"class definition");
#endif

    //
    // Construct the instance
    //
                    
    _IWmiObject* pInst = NULL;
    hres = pClass->Merge(WMIOBJECT_MERGE_FLAG_INSTANCE, 
                            dwInstancePartSize, pInstancePart, &pInst);
    if(FAILED(hres))
        return hres;

    //
    // Decorate it
    //

    pInst->SetDecoration(m_wszMachineName, m_wsNamespace);

    A51TRACE(("Read instance from %S in namespace %S\n", 
        wszFileName, (LPCWSTR)m_wsNamespace));

    *ppInstance = pInst;
    return S_OK;
}


CHR CNamespaceHandle::FileToSystemClass(LPCWSTR wszFileName, 
                                    _IWmiObject** ppClass, bool bClone,
                                    __int64* pnTime)
{
    //
    // Note: we must always clone the result of the system class retrieval,
    // since it will be decorated by the caller
    //

	return GetClassByHash(wszFileName + (wcslen(wszFileName) - MAX_HASH_LEN), 
                            true, 
                            ppClass, pnTime, NULL, NULL);
}
CHR CNamespaceHandle::FileToClass(LPCWSTR wszFileName, 
                                    _IWmiObject** ppClass, bool bClone,
                                    __int64* pnTime, bool *pbSystemClass)
{
    HRESULT hres;

    //
    // Read the data from the file
    //

	__int64 nTime;
	DWORD dwSize;
	BYTE* pBlob;
    VARIANT vClass;
	long lRes = g_Glob.GetFileCache()->ReadObject(wszFileName, &dwSize, &pBlob);
	if(lRes != ERROR_SUCCESS)
	{
		//We didn't find it here, so lets try and find it in the default namespace!
		//If we are not in the __SYSTEMCLASS namespace then we need to call into that...
		if((lRes == ERROR_FILE_NOT_FOUND || lRes == ERROR_PATH_NOT_FOUND) && g_pSystemClassNamespace && wcscmp(m_wsNamespace, A51_SYSTEMCLASS_NS) != 0)
		{
			hres = g_pSystemClassNamespace->FileToSystemClass(wszFileName, ppClass, bClone, &nTime);
			if (FAILED(hres))
				return hres;

			if (pnTime)
				*pnTime = nTime;

			//need to cache this item in the local cache
			hres = (*ppClass)->Get(L"__CLASS", 0, &vClass, NULL, NULL);
			if(FAILED(hres) || V_VT(&vClass) != VT_BSTR)
				return WBEM_E_INVALID_OBJECT;
			CClearMe cm1(&vClass);

			A51TRACE(("Read class %S from disk in namespace %S\n", V_BSTR(&vClass), m_wsNamespace));

			(*ppClass)->SetDecoration(m_wszMachineName, m_wsNamespace);

			m_pClassCache->AssertClass((*ppClass), V_BSTR(&vClass), bClone, nTime, true);

			if (pbSystemClass)
				*pbSystemClass = true;

			return hres;
		}
		else if (lRes == ERROR_FILE_NOT_FOUND || lRes == ERROR_PATH_NOT_FOUND)
			return WBEM_E_NOT_FOUND;
		else
			return WBEM_E_FAILED;
	}

	CTempFreeMe tfm1(pBlob, dwSize);

    _ASSERT(dwSize > sizeof(__int64), L"Class blob too short");
    if(dwSize <= sizeof(__int64))
        return WBEM_E_OUT_OF_MEMORY;

    //
    // Read off the superclass name
    //

    DWORD dwSuperLen;
    memcpy(&dwSuperLen, pBlob, sizeof(DWORD));
    LPWSTR wszSuperClass = (WCHAR*)TempAlloc(dwSuperLen*sizeof(WCHAR)+2);
	if (wszSuperClass == NULL)
		return WBEM_E_OUT_OF_MEMORY;
    CTempFreeMe vdm1(wszSuperClass, dwSuperLen*sizeof(WCHAR)+2);

    wszSuperClass[dwSuperLen] = 0;
    memcpy(wszSuperClass, pBlob+sizeof(DWORD), dwSuperLen*sizeof(WCHAR));
    DWORD dwPrefixLen = sizeof(DWORD) + dwSuperLen*sizeof(WCHAR);

    memcpy(&nTime, pBlob + dwPrefixLen, sizeof(__int64));

    //
    // Get the superclass
    //

    _IWmiObject* pSuperClass;
    __int64 nSuperTime;
    bool bRead;
    hres = GetClassDirect(wszSuperClass, IID__IWmiObject, (void**)&pSuperClass,
                            false, &nSuperTime, &bRead, NULL);
    if(FAILED(hres))
        return WBEM_E_CRITICAL_ERROR;

    CReleaseMe rm1(pSuperClass);

#ifdef A51_CHECK_TIMESTAMPS
    _ASSERT(nSuperTime <= nTime, L"Parent class is older than child");
#endif

    DWORD dwClassLen = dwSize - dwPrefixLen - sizeof(__int64);
    _IWmiObject* pNewObj;
    hres = pSuperClass->Merge(0, dwClassLen, 
                              pBlob + dwPrefixLen + sizeof(__int64), &pNewObj);
    if(FAILED(hres))
        return hres;

    //
    // Decorate it
    //

    pNewObj->SetDecoration(m_wszMachineName, m_wsNamespace);

    //
    // Cache it!
    //

    hres = pNewObj->Get(L"__CLASS", 0, &vClass, NULL, NULL);
    if(FAILED(hres) || V_VT(&vClass) != VT_BSTR)
        return WBEM_E_INVALID_OBJECT;
    CClearMe cm1(&vClass);

    A51TRACE(("Read class %S from disk in namespace %S\n",
        V_BSTR(&vClass), m_wsNamespace));

    m_pClassCache->AssertClass(pNewObj, V_BSTR(&vClass), bClone, nTime, false);

    *ppClass = pNewObj;
    if(pnTime)
        *pnTime = nTime;
	if (pbSystemClass)
		*pbSystemClass = false;

    return S_OK;
}

CHR CNamespaceHandle::PutObject(
     REFIID riid,
    LPVOID pObj,
     DWORD dwFlags,
     DWORD dwRequestedHandleType,
    IWmiDbHandle **ppResult,
	CEventCollector &aEvents
    )
{
    HRESULT hres;

    _IWmiObject* pObjEx = NULL;
    ((IUnknown*)pObj)->QueryInterface(IID__IWmiObject, (void**)&pObjEx);
	CReleaseMe rm1(pObjEx);
    
    if(pObjEx->IsObjectInstance() == S_OK)
    {
        hres = PutInstance(pObjEx, dwFlags, aEvents);
    }
    else
    {
        hres = PutClass(pObjEx, dwFlags, aEvents);
    }

    if(FAILED(hres))
        return hres;

    if(ppResult)
    {
        //
        // Got to get a handle
        //

        VARIANT v;
        hres = pObjEx->Get(L"__RELPATH", 0, &v, NULL, NULL);
        if(FAILED(hres) || V_VT(&v) != VT_BSTR)
            return WBEM_E_INVALID_OBJECT;

        hres = GetObjectHandleByPath(V_BSTR(&v), 0, WMIDB_HANDLE_TYPE_COOKIE, 
            ppResult);
        if(FAILED(hres))
            return hres;
    }
    return S_OK;
}

CHR CNamespaceHandle::PutInstance(_IWmiObject* pInst, DWORD dwFlags, 
                                        CEventCollector &aEvents)
{
    HRESULT hres;

    bool bDisableEvents = ((dwFlags & WMIDB_DISABLE_EVENTS)?true:false);

    //
    // Get the class name
    //

    VARIANT vClass;

    hres  = pInst->Get(L"__CLASS", 0, &vClass, NULL, NULL);
    if(FAILED(hres) || V_VT(&vClass) != VT_BSTR)
        return WBEM_E_INVALID_OBJECT;

    CClearMe cm1(&vClass);
    LPCWSTR wszClassName = V_BSTR(&vClass);

    //
	// Get the class so we can compare to make sure it is the same class used to
    // create the instance
    //

    _IWmiObject* pClass = NULL;
    __int64 nClassTime;
    hres = GetClassDirect(wszClassName, IID__IWmiObject, (void**)&pClass, 
                            false, &nClassTime, NULL, NULL);
    if(FAILED(hres))
        return hres;

    CReleaseMe rm2(pClass);

    if(wszClassName[0] != L'_')
	{
        hres = pInst->IsParentClass(0, pClass);
        if(FAILED(hres))
            return hres;

        if(hres == WBEM_S_FALSE)
            return WBEM_E_INVALID_CLASS;
    }

    //
    // Get the path
    //

	VARIANT var;
	VariantInit(&var);
	hres = pInst->Get(L"__relpath", 0, &var, 0, 0);
	if (FAILED(hres))
		return hres;
	CClearMe cm2(&var);
	DWORD dwLen = (wcslen(V_BSTR(&var)) + 1) * sizeof(WCHAR);
	LPWSTR strKey = (WCHAR*)TempAlloc(dwLen);
	if(strKey == NULL)
		return WBEM_E_OUT_OF_MEMORY;
	CTempFreeMe tfm(strKey, dwLen);

	bool bIsClass;
	LPWSTR __wszClassName = NULL;
	hres = ComputeKeyFromPath(V_BSTR(&var), strKey, &__wszClassName, &bIsClass);
	if(FAILED(hres))
		return hres;
    CTempFreeMe tfm1(__wszClassName);

    A51TRACE(("Putting instance %S of class %S\n", strKey, wszClassName));

    //
    // Get the old copy
    //

    _IWmiObject* pOldInst = NULL;
    hres = GetInstanceByKey(wszClassName, strKey, IID__IWmiObject, 
            (void**)&pOldInst);
    if(FAILED(hres) && hres != WBEM_E_NOT_FOUND)
        return hres;
    CReleaseMe rm1(pOldInst);

	if ((dwFlags & WBEM_FLAG_CREATE_ONLY) && (hres != WBEM_E_NOT_FOUND))
		return WBEM_E_ALREADY_EXISTS;
	else if ((dwFlags & WBEM_FLAG_UPDATE_ONLY) && (hres != WBEM_S_NO_ERROR))
		return WBEM_E_NOT_FOUND;

    if(pOldInst)
    {
        // 
        // Check that this guy is of the same class as the new one
        //

        //
        // Get the class name
        //
    
        VARIANT vClass2;
        hres  = pOldInst->Get(L"__CLASS", 0, &vClass2, NULL, NULL);
        if(FAILED(hres))
            return hres;
        if(V_VT(&vClass2) != VT_BSTR)
            return WBEM_E_INVALID_OBJECT;
    
        CClearMe cm3(&vClass2);

        if(wbem_wcsicmp(V_BSTR(&vClass2), wszClassName))
            return WBEM_E_INVALID_CLASS;
    }

    //
    // Construct the hash for the file
    //

    CFileName wszInstanceHash;
	if (wszInstanceHash == NULL)
		return WBEM_E_OUT_OF_MEMORY;
    if(!Hash(strKey, wszInstanceHash))
        return WBEM_E_OUT_OF_MEMORY;

    //
    // Construct the path to the instance file in key root
    //

    CFileName wszInstanceFilePath;
	if (wszInstanceFilePath == NULL)
		return WBEM_E_OUT_OF_MEMORY;
    hres = ConstructKeyRootDirFromClass(wszInstanceFilePath, wszClassName);
    if(FAILED(hres))
        return hres;

    wcscat(wszInstanceFilePath, L"\\" A51_INSTDEF_FILE_PREFIX);
    wcscat(wszInstanceFilePath, wszInstanceHash);

    //
    // Construct the path to the link file under the class
    //

    CFileName wszInstanceLinkPath;
	if (wszInstanceLinkPath == NULL)
		return WBEM_E_OUT_OF_MEMORY;
    hres = ConstructLinkDirFromClass(wszInstanceLinkPath, wszClassName);
    if(FAILED(hres))
        return hres;

    wcscat(wszInstanceLinkPath, L"\\" A51_INSTLINK_FILE_PREFIX);
    wcscat(wszInstanceLinkPath, wszInstanceHash);

    //
    // Clean up what was there, if anything
    //

    if(pOldInst)   
    {
        //
        // Just delete it, but be careful not to delete the scope!
        //

        hres = DeleteInstanceSelf(wszInstanceFilePath, pOldInst, false);
        if(FAILED(hres) && hres != WBEM_E_NOT_FOUND)
            return hres;
    }
        
    //
    // Create the actual instance def under key root
    //

    hres = InstanceToFile(pInst, wszClassName, wszInstanceFilePath, wszInstanceLinkPath, nClassTime);
    if(FAILED(hres))
	    return hres;

    //
    // Write the references
    //

    hres = WriteInstanceReferences(pInst, wszClassName, wszInstanceFilePath);
    if(FAILED(hres))
	    return hres;
    
    if(!bDisableEvents)
    {
        //
        // Fire Event
        //
    
        if(pInst->InheritsFrom(L"__Namespace") == S_OK)
        {
            //
            // Get the namespace name
            //

            VARIANT vClass2;
            VariantInit(&vClass2);
            CClearMe cm3(&vClass2);

            hres = pInst->Get(L"Name", 0, &vClass2, NULL, NULL);
            if(FAILED(hres) || V_VT(&vClass2) != VT_BSTR)
                return WBEM_E_INVALID_OBJECT;

            if(pOldInst)
            {
                hres = FireEvent(aEvents, WBEM_EVENTTYPE_NamespaceModification,
                            V_BSTR(&vClass2), pInst, pOldInst);
            }
            else
            {
                hres = FireEvent(aEvents, WBEM_EVENTTYPE_NamespaceCreation, 
                            V_BSTR(&vClass2), pInst);
            }
        }
        else
        {
            if(pOldInst)
            {
                hres = FireEvent(aEvents, WBEM_EVENTTYPE_InstanceModification, 
                            wszClassName, pInst, pOldInst);
            }
            else
            {
                hres = FireEvent(aEvents, WBEM_EVENTTYPE_InstanceCreation, 
                            wszClassName, pInst);
            }
        }
    }

	A51TRACE(("PutInstance for %S of class %S succeeded\n", 
                strKey, wszClassName));
    return S_OK;
}

CHR CNamespaceHandle::GetKeyRoot(LPCWSTR wszClass, 
                                     TEMPFREE_ME LPWSTR* pwszKeyRootClass)
{
    HRESULT hres;

    //
    // Look in the cache first
    //

    hres = m_pClassCache->GetKeyRoot(wszClass, pwszKeyRootClass);
    if(hres == S_OK)
        return S_OK;
    else if(hres == WBEM_E_CANNOT_BE_ABSTRACT)
        return WBEM_E_CANNOT_BE_ABSTRACT;

    //
    // Walk up the tree getting classes until you hit an unkeyed one
    //

    WString wsThisName = wszClass;
    WString wsPreviousName;

    while(1)
    {
        _IWmiObject* pClass = NULL;

        hres = GetClassDirect(wsThisName, IID__IWmiObject, (void**)&pClass, 
                                false, NULL, NULL, NULL);
        if(FAILED(hres))
            return hres;
        CReleaseMe rm1(pClass);

        //
        // Check if this class is keyed
        //

        unsigned __int64 i64Flags = 0;
        hres = pClass->QueryObjectFlags(0, WMIOBJECT_GETOBJECT_LOFLAG_KEYED,
                                        &i64Flags);
        if(FAILED(hres))
            return hres;
    
        if(i64Flags == 0)
        {
            //
            // It is not keyed --- the previous class wins!
            //

            if(wsPreviousName.Length() == 0)    
                return WBEM_E_CANNOT_BE_ABSTRACT;

            DWORD dwLen = (wsPreviousName.Length()+1)*sizeof(WCHAR);
            *pwszKeyRootClass = (WCHAR*)TempAlloc(dwLen);
			if (*pwszKeyRootClass == NULL)
				return WBEM_E_OUT_OF_MEMORY;
            wcscpy(*pwszKeyRootClass, (LPCWSTR)wsPreviousName);
            return S_OK;
        }

        //
        // It is keyed --- get the parent and continue;
        //

        VARIANT vParent;
        VariantInit(&vParent);
        CClearMe cm(&vParent);
        hres = pClass->Get(L"__SUPERCLASS", 0, &vParent, NULL, NULL);
        if(FAILED(hres))
            return hres;

        if(V_VT(&vParent) != VT_BSTR)
        {
            //
            // We've reached the top --- return this class
            //
        
            DWORD dwLen = (wsThisName.Length()+1)*sizeof(WCHAR);
            *pwszKeyRootClass = (WCHAR*)TempAlloc(dwLen);
			if (*pwszKeyRootClass == NULL)
				return WBEM_E_OUT_OF_MEMORY;
            wcscpy(*pwszKeyRootClass, (LPCWSTR)wsThisName);
            return S_OK;
        }

        wsPreviousName = wsThisName;
        wsThisName = V_BSTR(&vParent);
    }

    // Never here

    DebugBreak();
    return WBEM_E_CRITICAL_ERROR;
}

CHR CNamespaceHandle::GetKeyRootByHash(LPCWSTR wszClassHash, 
                                     TEMPFREE_ME LPWSTR* pwszKeyRootClass)
{
    //
    // Look in the cache first
    //

    HRESULT hres = m_pClassCache->GetKeyRootByKey(wszClassHash, 
                                                  pwszKeyRootClass);
    if(hres == S_OK)
        return S_OK;
    else if(hres == WBEM_E_CANNOT_BE_ABSTRACT)
        return WBEM_E_CANNOT_BE_ABSTRACT;

    //
    // NOTE: this could be done more efficiently, but it happens once in a 
    // lifetime, so it's not worth the complexity.
    //

    //
    // Get Class definition
    //

    _IWmiObject* pClass = NULL;
    hres = GetClassByHash(wszClassHash, false, &pClass, NULL, NULL, NULL);
    if(FAILED(hres))
        return hres;
    CReleaseMe rm1(pClass);

    //
    // Get the class name
    //

    VARIANT vClass;

    hres  = pClass->Get(L"__CLASS", 0, &vClass, NULL, NULL);
    if(FAILED(hres) || (V_VT(&vClass) != VT_BSTR) || 
        !V_BSTR(&vClass) || !wcslen(V_BSTR(&vClass)))
    {
        return WBEM_E_INVALID_OBJECT;
    }

    CClearMe cm1(&vClass);
    LPCWSTR wszClassName = V_BSTR(&vClass);

    //
    // Now get it by name
    //

    return GetKeyRoot(wszClassName, pwszKeyRootClass);
}

CHR CNamespaceHandle::ConstructKeyRootDirFromClass(LPWSTR wszDir,
                                            LPCWSTR wszClassName)
{
    HRESULT hres;

    //
    // NULL class stands for "meta-class"
    //

    if(wszClassName == NULL)
        return ConstructKeyRootDirFromKeyRoot(wszDir, L"");

    //
    // Figure out the key root for the class
    //

    LPWSTR wszKeyRootClass = NULL;

    hres = GetKeyRoot(wszClassName, &wszKeyRootClass);
    if(FAILED(hres))
        return hres;
    if(wszKeyRootClass == NULL)
    {
        // Abstract class --- bad error
        return WBEM_E_INVALID_CLASS;
    }
    CTempFreeMe tfm(wszKeyRootClass, (wcslen(wszKeyRootClass)+1)*sizeof(WCHAR));

    return ConstructKeyRootDirFromKeyRoot(wszDir, wszKeyRootClass);
}

CHR CNamespaceHandle::ConstructKeyRootDirFromClassHash(LPWSTR wszDir,
                                            LPCWSTR wszClassHash)
{
    HRESULT hres;

    //
    // Figure out the key root for the class
    //

    LPWSTR wszKeyRootClass = NULL;

    hres = GetKeyRootByHash(wszClassHash, &wszKeyRootClass);
    if(FAILED(hres))
        return hres;
    if(wszKeyRootClass == NULL)
    {
        // Abstract class --- bad error
        return WBEM_E_INVALID_CLASS;
    }
    CTempFreeMe tfm(wszKeyRootClass, (wcslen(wszKeyRootClass)+1)*sizeof(WCHAR));

    return ConstructKeyRootDirFromKeyRoot(wszDir, wszKeyRootClass);
}

CHR CNamespaceHandle::ConstructKeyRootDirFromKeyRoot(LPWSTR wszDir, 
                                                LPCWSTR wszKeyRootClass)
{
    wcscpy(wszDir, m_wszInstanceRootDir);
    wszDir[m_lInstanceRootDirLen] = L'\\';
    wcscpy(wszDir+m_lInstanceRootDirLen+1, A51_KEYROOTINST_DIR_PREFIX);
    if(!Hash(wszKeyRootClass, 
             wszDir+m_lInstanceRootDirLen+wcslen(A51_KEYROOTINST_DIR_PREFIX)+1))
    {
        return WBEM_E_OUT_OF_MEMORY;
    }

    return S_OK;
}

CHR CNamespaceHandle::ConstructLinkDirFromClass(LPWSTR wszDir, 
                                                LPCWSTR wszClassName)
{
    wcscpy(wszDir, m_wszInstanceRootDir);
    wszDir[m_lInstanceRootDirLen] = L'\\';
    wcscpy(wszDir+m_lInstanceRootDirLen+1, A51_CLASSINST_DIR_PREFIX);
    if(!Hash(wszClassName, 
             wszDir+m_lInstanceRootDirLen+wcslen(A51_CLASSINST_DIR_PREFIX)+1))
    {
        return WBEM_E_OUT_OF_MEMORY;
    }

    return S_OK;
}

CHR CNamespaceHandle::ConstructLinkDirFromClassHash(LPWSTR wszDir, 
                                                LPCWSTR wszClassHash)
{
    wcscpy(wszDir, m_wszInstanceRootDir);
    wszDir[m_lInstanceRootDirLen] = L'\\';
    wcscpy(wszDir+m_lInstanceRootDirLen+1, A51_CLASSINST_DIR_PREFIX);
    wcscat(wszDir, wszClassHash);

    return S_OK;
}
    

CHR CNamespaceHandle::WriteInstanceReferences(_IWmiObject* pInst, 
                                                    LPCWSTR wszClassName,
                                                    LPCWSTR wszFilePath)
{
    HRESULT hres;

    hres = pInst->BeginEnumeration(WBEM_FLAG_REFS_ONLY);
    if(FAILED(hres))
        return hres;
    
    VARIANT v;
    BSTR strName;
    while((hres = pInst->Next(0, &strName, &v, NULL, NULL)) == S_OK)
    {
        CSysFreeMe sfm(strName);
        CClearMe cm(&v);

        if(V_VT(&v) == VT_BSTR)
        {
            hres = WriteInstanceReference(wszFilePath, wszClassName, strName, 
                                        V_BSTR(&v));
            if(FAILED(hres))
                return hres;
        }
    }

    if(FAILED(hres))
        return hres;

    pInst->EndEnumeration();
    
    return S_OK;
}

// NOTE: will clobber wszTargetPath
CHR CNamespaceHandle::ConstructReferenceDir(LPWSTR wszTargetPath,
                                            LPWSTR wszReferenceDir)
{
    //
    // Deconstruct the target path name so that we could get a directory
    // for it
    //

    DWORD dwKeySpace = (wcslen(wszTargetPath)+1) * sizeof(WCHAR);
    LPWSTR wszKey = (LPWSTR)TempAlloc(dwKeySpace);
    if(wszKey == NULL)
        return WBEM_E_OUT_OF_MEMORY;
    CTempFreeMe tfm2(wszKey, dwKeySpace);

    LPWSTR wszClassName = NULL;
    LPWSTR wszTargetNamespace = NULL;
    bool bIsClass;
    HRESULT hres = ComputeKeyFromPath(wszTargetPath, wszKey, &wszClassName,
                                        &bIsClass, &wszTargetNamespace);
    if(FAILED(hres))
        return hres;
    CTempFreeMe tfm1(wszClassName);
    wszTargetPath = NULL; // invalidated by parsing

    CTempFreeMe tfm3(wszTargetNamespace);

    //
    // Check if the target namespace is the same as ours
    //

    CNamespaceHandle* pTargetHandle = NULL;
    if(wszTargetNamespace && wbem_wcsicmp(wszTargetNamespace, m_wsNamespace))
    {
        //
        // It's different --- open it!
        //

        hres = m_pRepository->GetNamespaceHandle(wszTargetNamespace,
                                &pTargetHandle);
        if(FAILED(hres))
        {
            ERRORTRACE((LOG_WBEMCORE, "Unable to open target namespace "
                "'%S' in namespace '%S'\n", wszTargetNamespace,
                (LPCWSTR)m_wsNamespace));
            return hres;
        }
    }
    else
    {
        pTargetHandle = this;
        pTargetHandle->AddRef();
    }

    CReleaseMe rm1(pTargetHandle);

    if(bIsClass)
    {
        return pTargetHandle->ConstructReferenceDirFromKey(NULL, wszClassName, 
                                            wszReferenceDir);
    }
    else
    {
        return pTargetHandle->ConstructReferenceDirFromKey(wszClassName, wszKey,
                                            wszReferenceDir);
    }
}

CHR CNamespaceHandle::ConstructReferenceDirFromKey(LPCWSTR wszClassName,
                                LPCWSTR wszKey, LPWSTR wszReferenceDir)
{
    HRESULT hres;

    //
    // Construct the class directory for this instance
    //

    hres = ConstructKeyRootDirFromClass(wszReferenceDir, wszClassName);
    if(FAILED(hres))
        return hres;

    int nLen = wcslen(wszReferenceDir);
    wcscpy(wszReferenceDir+nLen, L"\\" A51_INSTREF_DIR_PREFIX);
    nLen += 1 + wcslen(A51_INSTREF_DIR_PREFIX);

    //
    // Write instance hash
    //

    if(!Hash(wszKey, wszReferenceDir+nLen))
        return WBEM_E_OUT_OF_MEMORY;

    return S_OK;
}

    

    
    
    
// NOTE: will clobber wszReference
CHR CNamespaceHandle::ConstructReferenceFileName(LPWSTR wszReference,
                        LPCWSTR wszReferringFile, LPWSTR wszReferenceFile)
{
    HRESULT hres = ConstructReferenceDir(wszReference, wszReferenceFile);
    if(FAILED(hres))
        return hres;
    wszReference = NULL; // invalid

    //
    // It is basically 
    // irrelevant, we should use a randomly constructed name.  Right now, we
    // use a hash of the class name of the referrer --- THIS IS A BUG, THE SAME
    // INSTANCE CAN POINT TO THE SAME ENDPOINT TWICE!!
    //

    wcscat(wszReferenceFile, L"\\"A51_REF_FILE_PREFIX);
    DWORD dwLen = wcslen(wszReferenceFile);
    if (!Hash(wszReferringFile, wszReferenceFile+dwLen))
		return WBEM_E_OUT_OF_MEMORY;
    return S_OK;
}

// NOTE: will clobber wszReference
CHR CNamespaceHandle::WriteInstanceReference(LPCWSTR wszReferringFile,
                            LPCWSTR wszReferringClass,
                            LPCWSTR wszReferringProp, LPWSTR wszReference)
{
	HRESULT hres;

    //
    // Figure out the name of the file for the reference.  
    //

    CFileName wszReferenceFile;
	if (wszReferenceFile == NULL)
		return WBEM_E_OUT_OF_MEMORY;
    hres = ConstructReferenceFileName(wszReference, wszReferringFile, 
                                wszReferenceFile);
	if(FAILED(hres))
	{
		if(hres == WBEM_E_NOT_FOUND)
		{
			//
			// Oh joy. A reference to an instance of a *class* that does not
			// exist (not a non-existence instance, those are normal).
			// Forget it (BUGBUG)
			//

			return S_OK;
		}
		else
			return hres;
	}
	
    //
    // Construct the buffer
    //

    DWORD dwTotalLen = 4 * sizeof(DWORD) + 
                (wcslen(wszReferringClass) + wcslen(wszReferringProp) + 
                    wcslen(wszReferringFile) - g_Glob.GetRootDirLen() + 
                    wcslen(m_wsNamespace) + 4) 
                        * sizeof(WCHAR);

    BYTE* pBuffer = (BYTE*)TempAlloc(dwTotalLen);
	if (pBuffer == NULL)
		return WBEM_E_OUT_OF_MEMORY;
    CTempFreeMe vdm(pBuffer, dwTotalLen);

    BYTE* pCurrent = pBuffer;
    DWORD dwStringLen;

    //
    // Write namespace name
    //

    dwStringLen = wcslen(m_wsNamespace);
    memcpy(pCurrent, &dwStringLen, sizeof(DWORD));
    pCurrent += sizeof(DWORD);

    memcpy(pCurrent, m_wsNamespace, sizeof(WCHAR)*dwStringLen);
    pCurrent += sizeof(WCHAR)*dwStringLen;

    //
    // Write the referring class name
    //

    dwStringLen = wcslen(wszReferringClass);
    memcpy(pCurrent, &dwStringLen, sizeof(DWORD));
    pCurrent += sizeof(DWORD);
    
    memcpy(pCurrent, wszReferringClass, sizeof(WCHAR)*dwStringLen);
    pCurrent += sizeof(WCHAR)*dwStringLen;

    //
    // Write referring property name
    //

    dwStringLen = wcslen(wszReferringProp);
    memcpy(pCurrent, &dwStringLen, sizeof(DWORD));
    pCurrent += sizeof(DWORD);
    
    memcpy(pCurrent, wszReferringProp, sizeof(WCHAR)*dwStringLen);
    pCurrent += sizeof(WCHAR)*dwStringLen;

    //
    // Write referring file name minus the database root path. Notice that we 
    // cannot skip the namespace-specific prefix lest we break cross-namespace
    // associations
    //

    dwStringLen = wcslen(wszReferringFile) - g_Glob.GetRootDirLen();
    memcpy(pCurrent, &dwStringLen, sizeof(DWORD));
    pCurrent += sizeof(DWORD);
    
    memcpy(pCurrent, wszReferringFile + g_Glob.GetRootDirLen(), 
        sizeof(WCHAR)*dwStringLen);
    pCurrent += sizeof(WCHAR)*dwStringLen;

    //
    // All done --- create the file
    //

    long lRes = g_Glob.GetFileCache()->WriteObject(wszReferenceFile, NULL, dwTotalLen,
                    pBuffer);
    if(lRes != ERROR_SUCCESS)
        return WBEM_E_FAILED;
    
    return S_OK;
}

    
    
    
    

    
    
    



CHR CNamespaceHandle::PutClass(_IWmiObject* pClass, DWORD dwFlags, 
                                        CEventCollector &aEvents)
{
    HRESULT hres;

    bool bDisableEvents = ((dwFlags & WMIDB_DISABLE_EVENTS)?true:false);

    //
    // Get the class name
    //

    VARIANT vClass;

    hres  = pClass->Get(L"__CLASS", 0, &vClass, NULL, NULL);
    if(FAILED(hres) || (V_VT(&vClass) != VT_BSTR) || 
        !V_BSTR(&vClass) || !wcslen(V_BSTR(&vClass)))
    {
        return WBEM_E_INVALID_OBJECT;
    }

    CClearMe cm1(&vClass);
    LPCWSTR wszClassName = V_BSTR(&vClass);

    //
	// Check to make sure this class was created from a valid parent class
    //

    VARIANT vSuperClass;

    hres  = pClass->Get(L"__SUPERCLASS", 0, &vSuperClass, NULL, NULL);
    if (FAILED(hres))
        return WBEM_E_INVALID_OBJECT;
    CClearMe cm2(&vSuperClass);

    _IWmiObject* pSuperClass = NULL;
    if ((V_VT(&vSuperClass) == VT_BSTR) && V_BSTR(&vSuperClass) && 
        wcslen(V_BSTR(&vSuperClass)))
    {
        LPCWSTR wszSuperClassName = V_BSTR(&vSuperClass);

        // do not clone
        hres = GetClassDirect(wszSuperClassName, IID__IWmiObject, 
                                (void**)&pSuperClass, false, NULL, NULL, NULL); 
        if (hres == WBEM_E_NOT_FOUND)
            return WBEM_E_INVALID_SUPERCLASS;
        if (FAILED(hres))
            return hres;

	    if(wszClassName[0] != L'_')
	    {
            hres = pClass->IsParentClass(0, pSuperClass);
            if(FAILED(hres))
                return hres;
            if(hres == WBEM_S_FALSE)
                return WBEM_E_INVALID_SUPERCLASS;
        }
	}
    CReleaseMe rm(pSuperClass);

    //
    // Retrieve the previous definition, if any
    //

    _IWmiObject* pOldClass = NULL;
    __int64 nOldTime = 0;
    hres = GetClassDirect(wszClassName, IID__IWmiObject, (void**)&pOldClass,
                            false, &nOldTime, NULL, NULL); // do not clone
    if(FAILED(hres) && hres != WBEM_E_NOT_FOUND)
        return hres;
	CReleaseMe rm1(pOldClass);

	if ((dwFlags & WBEM_FLAG_CREATE_ONLY) && (hres !=  WBEM_E_NOT_FOUND))
		return WBEM_E_ALREADY_EXISTS;

	if ((dwFlags & WBEM_FLAG_UPDATE_ONLY) && (FAILED(hres)))
		return WBEM_E_NOT_FOUND;

    //
	// If the class exists, we need to check the update scenarios to make sure 
    // we do not break any
    //

	bool bNoClassChangeDetected = false;
	if (pOldClass)
	{
		hres = pClass->CompareDerivedMostClass(0, pOldClass);
		if ((hres != WBEM_S_FALSE) && (hres != WBEM_S_NO_ERROR))
			return hres;
		else if (hres == WBEM_S_NO_ERROR)
			bNoClassChangeDetected = true;
	}

    A51TRACE(("Putting class %S, dwFlags=0x%X.  Old was %p, changed=%d\n",
                wszClassName, dwFlags, pOldClass, !bNoClassChangeDetected));

	if (!bNoClassChangeDetected)
	{
		if (pOldClass != NULL) 
		{
			hres = CanClassBeUpdatedCompatible(dwFlags, wszClassName, pOldClass,
                                                pClass);            
            if(FAILED(hres))
            {
				if((dwFlags & WBEM_FLAG_UPDATE_SAFE_MODE) == 0 &&
                    (dwFlags & WBEM_FLAG_UPDATE_FORCE_MODE) == 0)
                {
                    // Can't compatibly, not allowed any other way
                    return hres;
                }

                if(hres != WBEM_E_CLASS_HAS_CHILDREN &&
                    hres != WBEM_E_CLASS_HAS_INSTANCES)
                {
                    // some serious failure!
                    return hres;
                }

                //
				// This is a safe mode or force mode update which takes more 
                // than a compatible update to carry out the operation
                //

				return UpdateClassSafeForce(pSuperClass, dwFlags, wszClassName, 
                                            pOldClass, pClass, aEvents);
			}
		}

        //
        // Either there was no previous copy, or it is compatible with the new
        // one, so we can perform a compatible update
        //

		hres = UpdateClassCompatible(pSuperClass, wszClassName, pClass, 
                                            pOldClass, nOldTime);
		if (FAILED(hres))
			return hres;

	}

    if(!bDisableEvents)
    {
        if(pOldClass)
        {
            hres = FireEvent(aEvents, WBEM_EVENTTYPE_ClassModification, 
                                wszClassName, pClass, pOldClass);
        }
        else
        {
            hres = FireEvent(aEvents, WBEM_EVENTTYPE_ClassCreation, 
                                wszClassName, pClass);
        }
    }

    return S_OK;
}

CHR CNamespaceHandle::UpdateClassCompatible(_IWmiObject* pSuperClass, 
            LPCWSTR wszClassName, _IWmiObject *pClass, _IWmiObject *pOldClass, 
            __int64 nFakeUpdateTime)
{
	HRESULT hres;

	//
	// Construct the path for the file
	//
    CFileName wszHash;
    if (wszHash == NULL)
        return WBEM_E_OUT_OF_MEMORY;

    if(!A51Hash(wszClassName, wszHash))
        return WBEM_E_OUT_OF_MEMORY;

	A51TRACE(("Class %S has has %S\n", wszClassName, wszHash));

	return UpdateClassCompatibleHash(pSuperClass, wszHash, pClass, pOldClass, 
                                        nFakeUpdateTime);
}

CHR CNamespaceHandle::UpdateClassCompatibleHash(_IWmiObject* pSuperClass,
            LPCWSTR wszClassHash, _IWmiObject *pClass, _IWmiObject *pOldClass, 
            __int64 nFakeUpdateTime)
{
	HRESULT hres;

	CFileName wszFileName;
	CFileName wszFilePath;
	if ((wszFileName == NULL) || (wszFilePath == NULL))
		return WBEM_E_OUT_OF_MEMORY;

	wcscpy(wszFileName, A51_CLASSDEF_FILE_PREFIX);
	wcscat(wszFileName, wszClassHash);

	wcscpy(wszFilePath, m_wszClassRootDir);
	wcscat(wszFilePath, L"\\");
	wcscat(wszFilePath, wszFileName);

	//
	// Write it into the file
	//

	hres = ClassToFile(pSuperClass, pClass, wszFilePath, 
                        nFakeUpdateTime);
	if(FAILED(hres))
		return hres;

	//
	// Add all needed references --- parent, pointers, etc	
	//

	if (pOldClass)
	{
		VARIANT v;
		VariantInit(&v);
		hres = pClass->Get(L"__CLASS", 0, &v, NULL, NULL);
		CClearMe cm(&v);

		if(SUCCEEDED(hres))
		{
			hres = EraseClassRelationships(V_BSTR(&v), pOldClass, wszFileName);
		}
		if (FAILED(hres))
			return hres;
	}

	hres = WriteClassRelationships(pClass, wszFileName);

	return hres;

}



CHR CNamespaceHandle::UpdateClassSafeForce(_IWmiObject* pSuperClass,
            DWORD dwFlags, LPCWSTR wszClassName, _IWmiObject *pOldClass, 
            _IWmiObject *pNewClass, CEventCollector &aEvents)
{
	HRESULT hres = UpdateClassAggressively(pSuperClass, dwFlags, wszClassName, 
                                        pNewClass, pOldClass, aEvents);

    // 
    // If this is a force mode update and we failed for anything other than 
    // out of memory then we should delete the class and try again.
    //

    if (FAILED(hres) && 
		(hres != WBEM_E_OUT_OF_MEMORY) && 
		(hres != WBEM_E_CIRCULAR_REFERENCE) &&
		(hres != WBEM_E_UPDATE_TYPE_MISMATCH) &&
        (dwFlags & WBEM_FLAG_UPDATE_FORCE_MODE))
    {
        //
        // We need to delete the class and try again.
        //

        hres = DeleteClass(wszClassName, aEvents);
        if(FAILED(hres))
            return hres;

		//Write class as though it did not exist
	    hres = UpdateClassCompatible(pSuperClass, wszClassName, pNewClass, NULL);
    }

	return hres;
}

CHR CNamespaceHandle::UpdateClassAggressively(_IWmiObject* pSuperClass,
           DWORD dwFlags, LPCWSTR wszClassName, _IWmiObject *pNewClass, 
           _IWmiObject *pOldClass, CEventCollector &aEvents)
{
    HRESULT hres = WBEM_S_NO_ERROR;

    if ((dwFlags & WBEM_FLAG_UPDATE_FORCE_MODE) == 0)
    {
        //
        // If we have instances we need to quit as we cannot update them.
        // 

        hres = ClassHasInstances(wszClassName);
        if(FAILED(hres))
            return hres;

        if (hres == WBEM_S_NO_ERROR)
            return WBEM_E_CLASS_HAS_INSTANCES;

        _ASSERT(hres == WBEM_S_FALSE, L"Unknown success code!");
    }
    else if (dwFlags & WBEM_FLAG_UPDATE_FORCE_MODE)
    {
        //
        // We need to delete the instances
        //

        hres = DeleteClassInstances(wszClassName, pOldClass, aEvents);
        if(FAILED(hres))
            return hres;
    }

    //
    // Retrieve all child classes and update them
    //

    CWStringArray wsChildHashes;
    hres = GetChildHashes(wszClassName, wsChildHashes);
    if(FAILED(hres))
        return hres;

    for (int i = 0; i != wsChildHashes.Size(); i++)
    {
        hres = UpdateChildClassAggressively(dwFlags, wsChildHashes[i], 
                                    pNewClass, aEvents);
        if (FAILED(hres))
            return hres;
    }

    //
    // Now we need to write the class back, update class refs etc.
    //

    hres = UpdateClassCompatible(pSuperClass, wszClassName, pNewClass, 
                                        pOldClass);
    if(FAILED(hres))
        return hres;

    //
    // Generate the class modification event...
    //

    if(!(dwFlags & WMIDB_DISABLE_EVENTS))
    {
        hres = FireEvent(aEvents, WBEM_EVENTTYPE_ClassModification, wszClassName, pNewClass, pOldClass);
    }

    return S_OK;
}

CHR CNamespaceHandle::UpdateChildClassAggressively(DWORD dwFlags, 
            LPCWSTR wszClassHash, _IWmiObject *pNewParentClass, 
            CEventCollector &aEvents)
{
    HRESULT hres = WBEM_S_NO_ERROR;

    dwFlags &= (WBEM_FLAG_UPDATE_FORCE_MODE | WBEM_FLAG_UPDATE_SAFE_MODE);

    if ((dwFlags & WBEM_FLAG_UPDATE_FORCE_MODE) == 0)
    {
        hres = ClassHasInstancesFromClassHash(wszClassHash);
        if(FAILED(hres))
            return hres;

        if (hres == WBEM_S_NO_ERROR)
            return WBEM_E_CLASS_HAS_INSTANCES;

        _ASSERT(hres == WBEM_S_FALSE, L"Unknown success code!");
    }

    //
    // Get the old class definition
    //

    _IWmiObject *pOldClass = NULL;
    hres = GetClassByHash(wszClassHash, true, &pOldClass, NULL, NULL, NULL);
    if(FAILED(hres))
        return hres;

    CReleaseMe rm1(pOldClass);

    if (dwFlags & WBEM_FLAG_UPDATE_FORCE_MODE)
    {
        //
        // Need to delete all its instances, if any
        //

        VARIANT v;
        VariantInit(&v);
        hres = pOldClass->Get(L"__CLASS", 0, &v, NULL, NULL);
        if(FAILED(hres))
            return hres;

        CClearMe cm(&v);

        hres = DeleteClassInstances(V_BSTR(&v), pOldClass, aEvents);
        if(FAILED(hres))
            return hres;
    }

    //
    // Update the existing class definition to work with the new parent class
    //

    _IWmiObject *pNewClass = NULL;
    hres = pNewParentClass->Update(pOldClass, dwFlags, &pNewClass);
    if(FAILED(hres))
        return hres;
    CReleaseMe rm2(pNewClass);

    //
    // Now we have to recurse through all child classes and do the same
    //

    CWStringArray wsChildHashes;
    hres = GetChildHashesByHash(wszClassHash, wsChildHashes);
    if(FAILED(hres))
        return hres;

    for (int i = 0; i != wsChildHashes.Size(); i++)
    {
        hres = UpdateChildClassAggressively(dwFlags, wsChildHashes[i], 
                                    pNewClass, aEvents);
        if (FAILED(hres))
            return hres;
    }

    // 
    // Now we need to write the class back, update class refs etc
    //


    hres = UpdateClassCompatibleHash(pNewParentClass, wszClassHash, 
                                            pNewClass, pOldClass);
    if(FAILED(hres))
        return hres;

    return S_OK;
}

CHR CNamespaceHandle::CanClassBeUpdatedCompatible(DWORD dwFlags, 
        LPCWSTR wszClassName, _IWmiObject *pOldClass, _IWmiObject *pNewClass)
{
	HRESULT hres;

    HRESULT hresError = WBEM_S_NO_ERROR;

    //
    // Do we have subclasses?
    //

    hres = ClassHasChildren(wszClassName);
    if(FAILED(hres))
        return hres;

    if(hres == WBEM_S_NO_ERROR)
    {
        hresError = WBEM_E_CLASS_HAS_CHILDREN;
    }
    else
    {
        _ASSERT(hres == WBEM_S_FALSE, L"Unknown success code");
    
        //
        // Do we have instances belonging to this class?  Don't even need to
        // worry about sub-classes because we know we have none at this point!
        //
    
        hres = ClassHasInstances(wszClassName);
        if(FAILED(hres))
            return hres;

        if(hres == WBEM_S_NO_ERROR)
        {
            hresError = WBEM_E_CLASS_HAS_INSTANCES;
        }
        else
        {
            _ASSERT(hres == WBEM_S_FALSE, L"Unknown success code");

            //
            // No nothing!
            //

            return WBEM_S_NO_ERROR;
        }
    }

    _ASSERT(hresError != WBEM_S_NO_ERROR, L"");

    //
    // We have either subclasses or instances.
    // Can we reconcile this class safely?
    //

    hres = pOldClass->ReconcileWith(
                        WMIOBJECT_RECONCILE_FLAG_TESTRECONCILE, pNewClass);

    if(hres == WBEM_S_NO_ERROR)
    {
        // reconcilable, so OK
        return WBEM_S_NO_ERROR;
    }
    else if(hres == WBEM_E_FAILED) // awful, isn't it
    {
        // irreconcilable
        return hresError;
    }
    else
    {
        return hres;
    }
}

CHR CNamespaceHandle::FireEvent(CEventCollector &aEvents, 
									DWORD dwType, LPCWSTR wszArg1,
                                    _IWmiObject* pObj1, _IWmiObject* pObj2)
{
	try
	{
		CRepEvent *pEvent = new CRepEvent(dwType, m_wsFullNamespace, wszArg1, 
                                            pObj1, pObj2);
		if (pEvent == NULL)
			return WBEM_E_OUT_OF_MEMORY;
		if (!aEvents.AddEvent(pEvent))
        {
            delete pEvent;
			return WBEM_E_OUT_OF_MEMORY;
        }
		return WBEM_S_NO_ERROR;
	}
	catch (CX_MemoryException)
	{
		return WBEM_E_OUT_OF_MEMORY;
	}
}
HRESULT CNamespaceHandle::SendEvents(CEventCollector &aEvents)
{
    _IWmiCoreServices * pSvcs = g_Glob.GetCoreSvcs();
    CReleaseMe rm(pSvcs);    
    aEvents.SendEvents(pSvcs);

    //
    // Ignore ESS return codes --- they do not invalidate the operation
    //

	return WBEM_S_NO_ERROR;
}

CHR CNamespaceHandle::WriteClassRelationships(_IWmiObject* pClass,
                                                LPCWSTR wszFileName)
{
    HRESULT hres;

    //
    // Get the parent
    //

    VARIANT v;
    VariantInit(&v);
    hres = pClass->Get(L"__SUPERCLASS", 0, &v, NULL, NULL);
    CClearMe cm(&v);

    if(FAILED(hres))
        return hres;

    if(V_VT(&v) == VT_BSTR)
        hres = WriteParentChildRelationship(wszFileName, V_BSTR(&v));
    else
        hres = WriteParentChildRelationship(wszFileName, L"");

	if(FAILED(hres))
		return hres;

    //
    // Write references
    //

    hres = pClass->BeginEnumeration(WBEM_FLAG_REFS_ONLY);
    if(FAILED(hres))
        return hres;
    
    BSTR strName = NULL;
    while((hres = pClass->Next(0, &strName, NULL, NULL, NULL)) == S_OK)
    {
        CSysFreeMe sfm(strName);

        hres = WriteClassReference(pClass, wszFileName, strName);
		if(FAILED(hres))
			return hres;
    }

    pClass->EndEnumeration();

	if(FAILED(hres))
		return hres;

    return S_OK;
}

CHR CNamespaceHandle::WriteClassReference(_IWmiObject* pReferringClass,
                            LPCWSTR wszReferringFile,
                            LPCWSTR wszReferringProp)
{
	HRESULT hres;

    //
    // Figure out the class we are pointing to
    //

    DWORD dwSize = 0;
    DWORD dwFlavor = 0;
    CIMTYPE ct;
    hres = pReferringClass->GetPropQual(wszReferringProp, L"CIMTYPE", 0, 0,
            &ct, &dwFlavor, &dwSize, NULL);
    if(dwSize == 0)
        return WBEM_E_OUT_OF_MEMORY;

    LPWSTR wszQual = (WCHAR*)TempAlloc(dwSize);
    if(wszQual == NULL)
        return WBEM_E_OUT_OF_MEMORY;
    CTempFreeMe tfm(wszQual, dwSize);

    hres = pReferringClass->GetPropQual(wszReferringProp, L"CIMTYPE", 0, dwSize,
            &ct, &dwFlavor, &dwSize, wszQual);
    if(FAILED(hres))
        return hres;
    
    //
    // Parse out the class name
    //

    WCHAR* pwcColon = wcschr(wszQual, L':');
    if(pwcColon == NULL)
        return S_OK; // untyped reference requires no bookkeeping

    LPCWSTR wszReferredToClass = pwcColon+1;

    //
    // Figure out the name of the file for the reference.  
    //

    CFileName wszReferenceFile;
	if (wszReferenceFile == NULL)
		return WBEM_E_OUT_OF_MEMORY;
    hres = ConstructClassReferenceFileName(wszReferredToClass, 
                                wszReferringFile, wszReferringProp,
                                wszReferenceFile);
    if(FAILED(hres))
        return hres;

    //
    // Create the empty file
    //

    long lRes = g_Glob.GetFileCache()->WriteLink(wszReferenceFile);
    if(lRes != ERROR_SUCCESS)
        return WBEM_E_FAILED;

    return S_OK;
}

CHR CNamespaceHandle::WriteParentChildRelationship(
                            LPCWSTR wszChildFileName, LPCWSTR wszParentName)
{
    CFileName wszParentChildFileName;
	if (wszParentChildFileName == NULL)
		return WBEM_E_OUT_OF_MEMORY;
    HRESULT hres = ConstructParentChildFileName(wszChildFileName,
                                                wszParentName,
												wszParentChildFileName);

    //
    // Create the file
    //

    long lRes = g_Glob.GetFileCache()->WriteLink(wszParentChildFileName);
    if(lRes != ERROR_SUCCESS)
        return WBEM_E_FAILED;

    return S_OK;
}

CHR CNamespaceHandle::ConstructParentChildFileName(
                            LPCWSTR wszChildFileName, LPCWSTR wszParentName,
							LPWSTR wszParentChildFileName)
{
    //
    // Construct the name of the directory where the parent class keeps its
    // children
    //

    HRESULT hres = ConstructClassRelationshipsDir(wszParentName, 
                                                    wszParentChildFileName);
    if(FAILED(hres))
        return hres;

    //
    // Append the filename of the child, but substituting the child-class prefix
    // for the class-def prefix
    //

    wcscat(wszParentChildFileName, L"\\" A51_CHILDCLASS_FILE_PREFIX);
    wcscat(wszParentChildFileName, 
        wszChildFileName + wcslen(A51_CLASSDEF_FILE_PREFIX));

    return S_OK;
}


CHR CNamespaceHandle::ConstructClassRelationshipsDir(LPCWSTR wszClassName,
                                LPWSTR wszDirPath)
{
    wcscpy(wszDirPath, m_wszClassRootDir);
    wcscpy(wszDirPath + m_lClassRootDirLen, L"\\" A51_CLASSRELATION_DIR_PREFIX);
    
    if(!Hash(wszClassName, 
        wszDirPath + m_lClassRootDirLen + 1 + wcslen(A51_CLASSRELATION_DIR_PREFIX)))
    {
        return WBEM_E_OUT_OF_MEMORY;
    }
    return S_OK;
}

CHR CNamespaceHandle::ConstructClassRelationshipsDirFromHash(
                                LPCWSTR wszHash, LPWSTR wszDirPath)
{
    wcscpy(wszDirPath, m_wszClassRootDir);
    wcscpy(wszDirPath + m_lClassRootDirLen, L"\\" A51_CLASSRELATION_DIR_PREFIX);
    wcscpy(wszDirPath + m_lClassRootDirLen + 1 +wcslen(A51_CLASSRELATION_DIR_PREFIX),
            wszHash);
    return S_OK;
}

CHR CNamespaceHandle::ConstructClassReferenceFileName(
                                LPCWSTR wszReferredToClass,
                                LPCWSTR wszReferringFile, 
                                LPCWSTR wszReferringProp,
                                LPWSTR wszFileName)
{
    HRESULT hres;

    hres = ConstructClassRelationshipsDir(wszReferredToClass, wszFileName);
    if(FAILED(hres))
        return hres;

    //
    // Extract the portion of the referring file containing the class hash
    //

    WCHAR* pwcLastUnderscore = wcsrchr(wszReferringFile, L'_');
    if(pwcLastUnderscore == NULL)
        return WBEM_E_CRITICAL_ERROR;
    LPCWSTR wszReferringClassHash = pwcLastUnderscore+1;

    wcscat(wszFileName, L"\\" A51_REF_FILE_PREFIX);
    wcscat(wszFileName, wszReferringClassHash);
    return S_OK;
}

CHR CNamespaceHandle::DeleteObject(
     DWORD dwFlags,
     REFIID riid,
     LPVOID pObj,
	 CEventCollector &aEvents
    )
{
	DebugBreak();
	return E_NOTIMPL;
}

CHR CNamespaceHandle::DeleteObjectByPath(DWORD dwFlags,	LPWSTR wszPath, 
                                                CEventCollector &aEvents)
{
	HRESULT hres;

    //
    // Get the key from path
    //

    DWORD dwLen = wcslen(wszPath)*sizeof(WCHAR)+2;
    LPWSTR wszKey = (WCHAR*)TempAlloc(dwLen);
    if(wszKey == NULL)
        return WBEM_E_OUT_OF_MEMORY;
    CTempFreeMe tfm(wszKey, dwLen);

    bool bIsClass;
    LPWSTR wszClassName = NULL;
    hres = ComputeKeyFromPath(wszPath, wszKey, &wszClassName, &bIsClass);
    if(FAILED(hres))
        return hres;
    CTempFreeMe tfm1(wszClassName, (wcslen(wszClassName)+1) * sizeof(WCHAR*));

    if(bIsClass)
    {
        return DeleteClass(wszClassName, aEvents);
    }
    else
    {
        return DeleteInstance(wszClassName, wszKey, aEvents);
    }
}

CHR CNamespaceHandle::DeleteInstance(LPCWSTR wszClassName, LPCWSTR wszKey, 
                                            CEventCollector &aEvents)
{
    HRESULT hres;

    //
    // Get Class definition
    //

    _IWmiObject* pClass = NULL;
    hres = GetClassDirect(wszClassName, IID__IWmiObject, (void**)&pClass, 
                            false, NULL, NULL, NULL);
    if(FAILED(hres))
        return hres;

    CReleaseMe rm1(pClass);

    //
    // Create its directory
    //

    CFileName wszFilePath;
	if (wszFilePath == NULL)
		return WBEM_E_OUT_OF_MEMORY;
    hres = ConstructKeyRootDirFromClass(wszFilePath, wszClassName);
    if(FAILED(hres))
        return hres;
    
    //
    // Construct the path for the file
    //

    CFileName wszFileName;
	if (wszFileName == NULL)
		return WBEM_E_OUT_OF_MEMORY;
    hres = ConstructInstanceDefName(wszFileName, wszKey);
    if(FAILED(hres))
        return hres;

    wcscat(wszFilePath, L"\\");
    wcscat(wszFilePath, wszFileName);

    _IWmiObject* pInst;
    hres = FileToInstance(NULL, wszFilePath, NULL, 0, &pInst);
    if(FAILED(hres))
        return hres;
	CReleaseMe rm2(pInst);

    if(pInst->InheritsFrom(L"__Namespace") == S_OK)
    {
		//Make sure this is not a deletion of the root\default namespace
		VARIANT vName;
		VariantInit(&vName);
	    CClearMe cm1(&vName);
		hres = pInst->Get(L"Name", 0, &vName, NULL, NULL);
		if(FAILED(hres))
			return WBEM_E_INVALID_OBJECT;

		LPCWSTR wszName = V_BSTR(&vName);
		if ((_wcsicmp(m_wsFullNamespace, L"\\\\.\\root") == 0) && (_wcsicmp(wszName, L"default") == 0))
			return WBEM_E_ACCESS_DENIED;
	}
	hres = DeleteInstanceByFile(wszFilePath, pInst, false, aEvents);
    if(FAILED(hres))
        return hres;

    //
    // Fire an event
    //

    if(pInst->InheritsFrom(L"__Namespace") == S_OK)
    {
        //
        // There is no need to do anything --- deletion of namespaces
        // automatically fires events in DeleteInstanceByFile (because we need
        // to accomplish it in the case of deleting a class derived from 
        // __NAMESPACE.
        //

    }
    else
    {
        hres = FireEvent(aEvents, WBEM_EVENTTYPE_InstanceDeletion, wszClassName,
                        pInst);
    }

	A51TRACE(("DeleteInstance for class %S succeeded\n", wszClassName));
    return S_OK;
}

CHR CNamespaceHandle::DeleteInstanceByFile(LPCWSTR wszFilePath, 
                                _IWmiObject* pInst, bool bClassDeletion,
                                CEventCollector &aEvents)
{
    HRESULT hres;

    hres = DeleteInstanceSelf(wszFilePath, pInst, bClassDeletion);
    if(FAILED(hres))
        return hres;

    hres = DeleteInstanceAsScope(pInst, aEvents);
    if(FAILED(hres) && hres != WBEM_E_NOT_FOUND)
    {
        return hres;
    }

    return S_OK;
}

CHR CNamespaceHandle::DeleteInstanceSelf(LPCWSTR wszFilePath, 
                                            _IWmiObject* pInst,
                                            bool bClassDeletion)
{
    HRESULT hres;

    //
    // Delete the file
    //

    long lRes = g_Glob.GetFileCache()->DeleteObject(wszFilePath);
    if(lRes == ERROR_FILE_NOT_FOUND || lRes == ERROR_PATH_NOT_FOUND)
    {
        return WBEM_E_NOT_FOUND;
    }
    else if(lRes != ERROR_SUCCESS)
        return WBEM_E_FAILED;

    hres = DeleteInstanceLink(pInst, wszFilePath);
    if(FAILED(hres) && hres != WBEM_E_NOT_FOUND)
        return hres;

    hres = DeleteInstanceReferences(pInst, wszFilePath);
    if(FAILED(hres) && hres != WBEM_E_NOT_FOUND)
        return hres;

    if(bClassDeletion)
    {
        //
        // We need to remove all dangling references to this instance, 
        // because they make no sense once the class is deleted --- we don't
        // know what key structure the new class will even have.  In the future,
        // we'll want to move these references to some class-wide location
        //

        hres = DeleteInstanceBackReferences(wszFilePath);
        if(FAILED(hres) && hres != WBEM_E_NOT_FOUND)
            return hres;
    }

    return S_OK;
}

CHR CNamespaceHandle::ConstructReferenceDirFromFilePath(
                                LPCWSTR wszFilePath, LPWSTR wszReferenceDir)
{
    //
    // It's the same, only with INSTDEF_FILE_PREFIX replaced with 
    // INSTREF_DIR_PREFIX
    //

    CFileName wszEnding;
	if (wszEnding == NULL)
		return WBEM_E_OUT_OF_MEMORY;
    WCHAR* pwcLastSlash = wcsrchr(wszFilePath, L'\\');
    if(pwcLastSlash == NULL)
        return WBEM_E_FAILED;
    
    wcscpy(wszEnding, pwcLastSlash + 1 + wcslen(A51_INSTDEF_FILE_PREFIX));

    wcscpy(wszReferenceDir, wszFilePath);
    wszReferenceDir[(pwcLastSlash+1)-wszFilePath] = 0;

    wcscat(wszReferenceDir, A51_INSTREF_DIR_PREFIX);
    wcscat(wszReferenceDir, wszEnding);
    return S_OK;
}

CHR CNamespaceHandle::DeleteInstanceBackReferences(LPCWSTR wszFilePath)
{
    HRESULT hres;

    CFileName wszReferenceDir;
	if (wszReferenceDir == NULL)
		return WBEM_E_OUT_OF_MEMORY;
    hres = ConstructReferenceDirFromFilePath(wszFilePath, wszReferenceDir);
    if(FAILED(hres))
        return hres;
    wcscat(wszReferenceDir, L"\\");

    CFileName wszReferencePrefix;
	if (wszReferencePrefix == NULL)
		return WBEM_E_OUT_OF_MEMORY;
    wcscpy(wszReferencePrefix, wszReferenceDir);
    wcscat(wszReferencePrefix, A51_REF_FILE_PREFIX);

    // Prepare a buffer for file path
    CFileName wszFullFileName;
	if (wszFullFileName == NULL)
		return WBEM_E_OUT_OF_MEMORY;

    wcscpy(wszFullFileName, wszReferenceDir);
    long lDirLen = wcslen(wszFullFileName);

    CFileName wszFileName;
	if (wszFileName == NULL)
		return WBEM_E_OUT_OF_MEMORY;

    // Enumerate all files in it

    void* hSearch;
    long lRes = g_Glob.GetFileCache()->IndexEnumerationBegin(wszReferencePrefix, &hSearch);
	if (lRes == ERROR_FILE_NOT_FOUND)
		return ERROR_SUCCESS;
	else if (lRes != ERROR_SUCCESS)
		return A51TranslateErrorCode(lRes);

    while ((lRes = g_Glob.GetFileCache()->IndexEnumerationNext(hSearch, wszFileName)) == ERROR_SUCCESS)
    {
        wcscpy(wszFullFileName+lDirLen, wszFileName);

        lRes = g_Glob.GetFileCache()->DeleteObject(wszFullFileName);
        if(lRes != ERROR_SUCCESS)
        {
            ERRORTRACE((LOG_WBEMCORE, "Cannot delete reference file '%S' with "
                "error code %d\n", wszFullFileName, lRes));
			lRes = ERROR_INVALID_OPERATION;	//trigger the correct error!
        }
    }
    
	g_Glob.GetFileCache()->IndexEnumerationEnd(hSearch);

    if(lRes == ERROR_NO_MORE_FILES)
    {
        return WBEM_S_NO_ERROR;
    }
    else if(lRes != ERROR_SUCCESS)
    {
        return WBEM_E_FAILED;
    }
    return S_OK;
}



CHR CNamespaceHandle::DeleteInstanceLink(_IWmiObject* pInst,
                                                LPCWSTR wszInstanceDefFilePath)
{
    HRESULT hres;

    //
    // Get the class name
    //
    
    VARIANT vClass;
    VariantInit(&vClass);
    CClearMe cm1(&vClass);
    
    hres = pInst->Get(L"__CLASS", 0, &vClass, NULL, NULL);
    if(FAILED(hres))
        return WBEM_E_INVALID_OBJECT;

    LPCWSTR wszClassName = V_BSTR(&vClass);

    //
    // Construct the link directory for the class
    //

    CFileName wszInstanceLinkPath;
	if (wszInstanceLinkPath == NULL)
		return WBEM_E_OUT_OF_MEMORY;
    hres = ConstructLinkDirFromClass(wszInstanceLinkPath, wszClassName);
    if(FAILED(hres))
        return hres;

    wcscat(wszInstanceLinkPath, L"\\" A51_INSTLINK_FILE_PREFIX);

    //
    // It remains to append the instance-specific part of the file name.  
    // Convineintly, it is the same material as was used for the def file path,
    // so we can steal it.  ALERT: RELIES ON ALL PREFIXES ENDING IN '_'!!
    //

    WCHAR* pwcLastUnderscore = wcsrchr(wszInstanceDefFilePath, L'_');
    if(pwcLastUnderscore == NULL)
        return WBEM_E_CRITICAL_ERROR;

    wcscat(wszInstanceLinkPath, pwcLastUnderscore+1);

    //
    // Delete the file
    //

    long lRes = g_Glob.GetFileCache()->DeleteLink(wszInstanceLinkPath);
    if(lRes == ERROR_FILE_NOT_FOUND || lRes == ERROR_PATH_NOT_FOUND)
        return WBEM_E_NOT_FOUND;
    else if(lRes != ERROR_SUCCESS)
        return WBEM_E_FAILED;

    return S_OK;
}

    


CHR CNamespaceHandle::DeleteInstanceAsScope(_IWmiObject* pInst, CEventCollector &aEvents)
{
    HRESULT hres;

    //
    // For now, just check if it is a namespace
    //

    hres = pInst->InheritsFrom(L"__Namespace");
    if(FAILED(hres))
        return hres;

    if(hres != S_OK) // not a namespace
        return S_FALSE;

    //
    // It is a namespace --- construct full path
    //

    WString wsFullName = m_wsNamespace;
    wsFullName += L"\\";

    VARIANT vName;
    VariantInit(&vName);
    CClearMe cm(&vName);
    hres = pInst->Get(L"Name", 0, &vName, NULL, NULL);
    if(FAILED(hres))
        return hres;
    if(V_VT(&vName) != VT_BSTR)
        return WBEM_E_INVALID_OBJECT;

    wsFullName += V_BSTR(&vName);

    //
    // Delete it
    //

    CNamespaceHandle* pNewHandle = new CNamespaceHandle(m_pControl,
                                                        m_pRepository);
    if(pNewHandle == NULL)
        return WBEM_E_OUT_OF_MEMORY;
    pNewHandle->AddRef();
    CReleaseMe rm1(pNewHandle);

    hres = pNewHandle->Initialize(wsFullName);
    if(FAILED(hres))
        return hres;

    //
    // Mind to only fire child namespace deletion events from the inside
    //

    bool bNamespaceOnly = aEvents.IsNamespaceOnly();
    aEvents.SetNamespaceOnly(true);
    hres = pNewHandle->DeleteSelf(aEvents);
    if(FAILED(hres))
        return hres;
    aEvents.SetNamespaceOnly(bNamespaceOnly);

    //
    // Fire the event
    //

    hres = FireEvent(aEvents, WBEM_EVENTTYPE_NamespaceDeletion, 
                    V_BSTR(&vName), pInst);

    return S_OK;
}

CHR CNamespaceHandle::DeleteSelf(CEventCollector &aEvents)
{
    //
    // Delete all top-level classes. This will delete all namespaces    
    // (as instances of __Namespace), all classes (as children of top-levels)
    // and all instances
    //

    HRESULT hres = DeleteDerivedClasses(L"", aEvents);
    if(FAILED(hres))
        return hres;

    //
    // We do not delete our class root directory --- if we are a namespace, it
    // is the same as our instance root directory so we are already done; if not
    // we should not be cleaning up all the classes!
    //

    m_pClassCache->SetError(WBEM_E_INVALID_NAMESPACE);

    return S_OK;
}
    

CHR CNamespaceHandle::DeleteInstanceReferences(_IWmiObject* pInst, 
                                                LPCWSTR wszFilePath)
{
    HRESULT hres;

    hres = pInst->BeginEnumeration(WBEM_FLAG_REFS_ONLY);
    if(FAILED(hres))
        return hres;
    
    VARIANT v;
    while((hres = pInst->Next(0, NULL, &v, NULL, NULL)) == S_OK)
    {
        CClearMe cm(&v);

        if(V_VT(&v) == VT_BSTR)
        {
            hres = DeleteInstanceReference(wszFilePath, V_BSTR(&v));
            if(FAILED(hres))
                return hres;
        }
    }

    if(FAILED(hres))
        return hres;

    pInst->EndEnumeration();
    return S_OK;
}
    
// NOTE: will clobber wszReference
CHR CNamespaceHandle::DeleteInstanceReference(LPCWSTR wszOurFilePath,
                                            LPWSTR wszReference)
{
    HRESULT hres;

    CFileName wszReferenceFile;
	if (wszReferenceFile == NULL)
		return WBEM_E_OUT_OF_MEMORY;
    hres = ConstructReferenceFileName(wszReference, wszOurFilePath, wszReferenceFile);
	if(FAILED(hres))
	{
		if(hres == WBEM_E_NOT_FOUND)
		{
			//
			// Oh joy. A reference to an instance of a *class* that does not
			// exist (not a non-existence instance, those are normal).
			// Forget it (BUGBUG)
			//

			return S_OK;
		}
		else
			return hres;
	}

    long lRes = g_Glob.GetFileCache()->DeleteObject(wszReferenceFile);
    if(lRes != ERROR_SUCCESS)
    {
        if(lRes == ERROR_FILE_NOT_FOUND)
            return WBEM_E_NOT_FOUND;
        else
            return WBEM_E_FAILED;
        }
    else
        return WBEM_S_NO_ERROR;
}


CHR CNamespaceHandle::DeleteClassByHash(LPCWSTR wszHash, CEventCollector &aEvents)
{
    HRESULT hres;

    //
    // Get Class definition
    //

    _IWmiObject* pClass = NULL;
	bool bSystemClass = false;
    hres = GetClassByHash(wszHash, false, &pClass, NULL, NULL, &bSystemClass);
    CReleaseMe rm1(pClass);
    if(FAILED(hres))
        return hres;

    //
    // Get the actual class name
    //

    VARIANT v;
    hres = pClass->Get(L"__CLASS", 0, &v, NULL, NULL);
    if(FAILED(hres))
        return hres;
    CClearMe cm1(&v);

    if(V_VT(&v) != VT_BSTR)
        return WBEM_E_INVALID_CLASS;

    //
    // Construct definition file name
    //

    CFileName wszFileName;
	if (wszFileName == NULL)
		return WBEM_E_OUT_OF_MEMORY;
    hres = ConstructClassDefFileNameFromHash(wszHash, wszFileName);
    if(FAILED(hres))
        return hres;

    return DeleteClassInternal(V_BSTR(&v), pClass, wszFileName, aEvents, bSystemClass);
}
    
CHR CNamespaceHandle::DeleteClass(LPCWSTR wszClassName, CEventCollector &aEvents)
{
    HRESULT hres;

	A51TRACE(("Deleting class %S\n", wszClassName));

    //
    // Construct the path for the file
    //

    CFileName wszFileName;
	if (wszFileName == NULL)
		return WBEM_E_OUT_OF_MEMORY;
    hres = ConstructClassDefFileName(wszClassName, wszFileName);
    if(FAILED(hres))
        return hres;

    //
    // Get Class definition
    //

    _IWmiObject* pClass = NULL;
	bool bSystemClass = false;
    hres = GetClassDirect(wszClassName, IID__IWmiObject, (void**)&pClass, 
                            false, NULL, NULL, &bSystemClass);
    if(FAILED(hres))
        return hres;
    CReleaseMe rm1(pClass);

    return DeleteClassInternal(wszClassName, pClass, wszFileName, aEvents, bSystemClass);
}

CHR CNamespaceHandle::DeleteClassInternal(LPCWSTR wszClassName,
                                              _IWmiObject* pClass,
                                              LPCWSTR wszFileName,
											  CEventCollector &aEvents,
											  bool bSystemClass)
{
    HRESULT hres;

    CFileName wszFilePath;
	if (wszFilePath == NULL)
		return WBEM_E_OUT_OF_MEMORY;
    swprintf(wszFilePath, L"%s\\%s", m_wszClassRootDir, wszFileName);

    //
    // Delete all derived classes
    //

    hres = DeleteDerivedClasses(wszClassName, aEvents);

    if(FAILED(hres))
        return hres;

	//
	// Delete all instances.  Only fire events if namespaces are deleted
	//

    bool bNamespaceOnly = aEvents.IsNamespaceOnly();
    aEvents.SetNamespaceOnly(true);
    hres = DeleteClassInstances(wszClassName, pClass, aEvents);
    if(FAILED(hres))
        return hres;
    aEvents.SetNamespaceOnly(bNamespaceOnly);

	if (!bSystemClass)
	{
		//
		// Clean up references
		//

		hres = EraseClassRelationships(wszClassName, pClass, wszFileName);
		if(FAILED(hres))
			return hres;

		//
		// Delete the file
		//

		long lRes = g_Glob.GetFileCache()->DeleteObject(wszFilePath);
		if(lRes == ERROR_FILE_NOT_FOUND || lRes == ERROR_PATH_NOT_FOUND)
			return WBEM_E_NOT_FOUND;
		else if(lRes != ERROR_SUCCESS)
			return WBEM_E_FAILED;

	}

    m_pClassCache->InvalidateClass(wszClassName);

    //
    // Fire an event
    //

    hres = FireEvent(aEvents, WBEM_EVENTTYPE_ClassDeletion, wszClassName, pClass);

    return S_OK;
}

CHR CNamespaceHandle::DeleteDerivedClasses(LPCWSTR wszClassName, CEventCollector &aEvents)
{
    HRESULT hres;

    CWStringArray wsChildHashes;
    hres = GetChildHashes(wszClassName, wsChildHashes);
    if(FAILED(hres))
        return hres;

    for(int i = 0; i < wsChildHashes.Size(); i++)
    {
        hres = DeleteClassByHash(wsChildHashes[i], aEvents);

        if(FAILED(hres) && (hres != WBEM_E_NOT_FOUND))
        {
            return hres;
        }
    }

    return S_OK;
}

CHR CNamespaceHandle::GetChildDefs(LPCWSTR wszClassName, bool bRecursive,
                                    IWbemObjectSink* pSink, bool bClone)
{
    CFileName wszHash;
	if (wszHash == NULL)
		return WBEM_E_OUT_OF_MEMORY;
    if(!A51Hash(wszClassName, wszHash))
        return WBEM_E_OUT_OF_MEMORY;

    return GetChildDefsByHash(wszHash, bRecursive, pSink, bClone);
}

CHR CNamespaceHandle::GetChildDefsByHash(LPCWSTR wszHash, bool bRecursive,
                                    IWbemObjectSink* pSink, bool bClone)
{
    HRESULT hres;

	long lStartIndex = m_pClassCache->GetLastInvalidationIndex();

    //
    // Get the hashes of the child filenames
    //

    CWStringArray wsChildHashes;
    hres = GetChildHashesByHash(wszHash, wsChildHashes);
    if(FAILED(hres))
        return hres;

    //
    // Get their class definitions
    //

    for(int i = 0; i < wsChildHashes.Size(); i++)
    {
        LPCWSTR wszChildHash = wsChildHashes[i];

        _IWmiObject* pClass = NULL;
        hres = GetClassByHash(wszChildHash, bClone, &pClass, NULL, NULL, NULL);
        if(FAILED(hres))
            return hres;
        CReleaseMe rm1(pClass);

        hres = pSink->Indicate(1, (IWbemClassObject**)&pClass);
        if(FAILED(hres))
            return hres;
        
        //
        // Continue recursively if indicated
        //

        if(bRecursive)
        {
            hres = GetChildDefsByHash(wszChildHash, bRecursive, pSink, bClone);
            if(FAILED(hres))
                return hres;
        }
    }

    //
    // Mark cache completeness
    //

	m_pClassCache->DoneWithChildrenByHash(wszHash, bRecursive, lStartIndex);
    return S_OK;
}

    
CHR CNamespaceHandle::GetChildHashes(LPCWSTR wszClassName, 
                                        CWStringArray& wsChildHashes)
{
    CFileName wszHash;
	if (wszHash == NULL)
		return WBEM_E_OUT_OF_MEMORY;
    if(!A51Hash(wszClassName, wszHash))
        return WBEM_E_OUT_OF_MEMORY;

    return GetChildHashesByHash(wszHash, wsChildHashes);
}

CHR CNamespaceHandle::GetChildHashesByHash(LPCWSTR wszHash, 
                                        CWStringArray& wsChildHashes)
{
    HRESULT hres;
    long lRes;

	//Try retrieving the system classes namespace first...
	if (g_pSystemClassNamespace && (wcscmp(m_wsNamespace, A51_SYSTEMCLASS_NS) != 0))
	{
		hres = g_pSystemClassNamespace->GetChildHashesByHash(wszHash, wsChildHashes);
		if (FAILED(hres))
			return hres;
	}

    //
    // Construct the prefix for the children classes
    //

    CFileName wszChildPrefix;
	if (wszChildPrefix == NULL)
		return WBEM_E_OUT_OF_MEMORY;
    hres = ConstructClassRelationshipsDirFromHash(wszHash, wszChildPrefix);
    if(FAILED(hres))
        return hres;

    wcscat(wszChildPrefix, L"\\" A51_CHILDCLASS_FILE_PREFIX);

    //
    // Enumerate all such files in the cache
    //

    void* pHandle = NULL;
	CFileName wszFileName;
	if (wszFileName == NULL)
		return WBEM_E_OUT_OF_MEMORY;

    lRes = g_Glob.GetFileCache()->IndexEnumerationBegin(wszChildPrefix, &pHandle);
	if (lRes == ERROR_FILE_NOT_FOUND)
		return ERROR_SUCCESS;
	else if (lRes != ERROR_SUCCESS)
		return A51TranslateErrorCode(lRes);
    
    while((lRes = g_Glob.GetFileCache()->IndexEnumerationNext(pHandle, wszFileName)) == ERROR_SUCCESS)
    {
        wsChildHashes.Add(wszFileName + wcslen(A51_CHILDCLASS_FILE_PREFIX));
    }

	g_Glob.GetFileCache()->IndexEnumerationEnd(pHandle);

    if(lRes != ERROR_NO_MORE_FILES && lRes != S_OK)
        return WBEM_E_FAILED;
    else
        return S_OK;
}

CHR CNamespaceHandle::ClassHasChildren(LPCWSTR wszClassName)
{
    CFileName wszHash;
	if (wszHash == NULL)
		return WBEM_E_OUT_OF_MEMORY;
    if(!A51Hash(wszClassName, wszHash))
        return WBEM_E_OUT_OF_MEMORY;
    
	HRESULT hres;
    long lRes;

	//Try retrieving the system classes namespace first...
	if (g_pSystemClassNamespace && (wcscmp(m_wsNamespace, A51_SYSTEMCLASS_NS) != 0))
	{
		hres = g_pSystemClassNamespace->ClassHasChildren(wszClassName);
		if (FAILED(hres) || (hres == WBEM_S_NO_ERROR))
			return hres;
	}
    //
    // Construct the prefix for the children classes
    //

    CFileName wszChildPrefix;
	if (wszChildPrefix == NULL)
		return WBEM_E_OUT_OF_MEMORY;
    CFileName wszFileName;
	if (wszFileName == NULL)
		return WBEM_E_OUT_OF_MEMORY;
    hres = ConstructClassRelationshipsDirFromHash(wszHash, wszChildPrefix);
    if(FAILED(hres))
        return hres;

    wcscat(wszChildPrefix, L"\\" A51_CHILDCLASS_FILE_PREFIX);

    void* pHandle = NULL;
    lRes = g_Glob.GetFileCache()->IndexEnumerationBegin(wszChildPrefix, &pHandle);
	if (lRes == ERROR_FILE_NOT_FOUND)
		return WBEM_S_FALSE;
	if (lRes != ERROR_SUCCESS)
		return A51TranslateErrorCode(lRes);

	g_Glob.GetFileCache()->IndexEnumerationEnd(pHandle);

    return WBEM_S_NO_ERROR;
}

CHR CNamespaceHandle::ClassHasInstances(LPCWSTR wszClassName)
{
    CFileName wszHash;
	if (wszHash == NULL)
		return WBEM_E_OUT_OF_MEMORY;
    if(!A51Hash(wszClassName, wszHash))
        return WBEM_E_OUT_OF_MEMORY;

	return ClassHasInstancesFromClassHash(wszHash);
}

CHR CNamespaceHandle::ClassHasInstancesFromClassHash(LPCWSTR wszClassHash)
{
    HRESULT hres;
    long lRes;

    //
    // Check the instances in this namespace first.  The instance directory in
    // default scope is the class directory of the namespace
    //

    hres = ClassHasInstancesInScopeFromClassHash(m_wszClassRootDir, 
                                                    wszClassHash);
    if(hres != WBEM_S_FALSE)
        return hres;

    return WBEM_S_FALSE;
}
        
CHR CNamespaceHandle::ClassHasInstancesInScopeFromClassHash(
                            LPCWSTR wszInstanceRootDir, LPCWSTR wszClassHash)
{
    CFileName wszFullDirName;
	if (wszFullDirName == NULL)
		return WBEM_E_OUT_OF_MEMORY;
    wcscpy(wszFullDirName, wszInstanceRootDir);
    wcscat(wszFullDirName, L"\\" A51_CLASSINST_DIR_PREFIX);
    wcscat(wszFullDirName, wszClassHash);
    wcscat(wszFullDirName, L"\\" A51_INSTLINK_FILE_PREFIX);

    void* pHandle = NULL;
	LONG lRes;
    lRes = g_Glob.GetFileCache()->IndexEnumerationBegin(wszFullDirName, &pHandle);
	if (lRes == ERROR_FILE_NOT_FOUND)
		return WBEM_S_FALSE;
	if (lRes != ERROR_SUCCESS)
	{
		return WBEM_E_FAILED;
	}

	if(pHandle)
	    g_Glob.GetFileCache()->IndexEnumerationEnd(pHandle);

	return WBEM_S_NO_ERROR;
}

CHR CNamespaceHandle::EraseParentChildRelationship(
                            LPCWSTR wszChildFileName, LPCWSTR wszParentName)
{
    CFileName wszParentChildFileName;
	if (wszParentChildFileName == NULL)
		return WBEM_E_OUT_OF_MEMORY;
    HRESULT hres = ConstructParentChildFileName(wszChildFileName,
                                                wszParentName,
                                                wszParentChildFileName);

    //
    // Delete the file
    //

    long lRes = g_Glob.GetFileCache()->DeleteLink(wszParentChildFileName);
    if(lRes != ERROR_SUCCESS)
        return WBEM_E_FAILED;

    return S_OK;
}

CHR CNamespaceHandle::EraseClassRelationships(LPCWSTR wszClassName,
                            _IWmiObject* pClass, LPCWSTR wszFileName)
{
    HRESULT hres;

    //
    // Get the parent
    //

    VARIANT v;
    VariantInit(&v);
    hres = pClass->Get(L"__SUPERCLASS", 0, &v, NULL, NULL);
    CClearMe cm(&v);


    if(FAILED(hres))
        return hres;

    if(V_VT(&v) == VT_BSTR)
        hres = EraseParentChildRelationship(wszFileName, V_BSTR(&v));
    else
        hres = EraseParentChildRelationship(wszFileName, L"");

	if(FAILED(hres))
		return hres;

    //
    // Erase references
    //

    hres = pClass->BeginEnumeration(WBEM_FLAG_REFS_ONLY);
    if(FAILED(hres))
        return hres;
    
    BSTR strName = NULL;
    while((hres = pClass->Next(0, &strName, NULL, NULL, NULL)) == S_OK)
    {
        CSysFreeMe sfm(strName);

        hres = EraseClassReference(pClass, wszFileName, strName);
		if(FAILED(hres) && (hres != WBEM_E_NOT_FOUND))
			return hres;
    }

    pClass->EndEnumeration();

    return S_OK;
}

CHR CNamespaceHandle::EraseClassReference(_IWmiObject* pReferringClass,
                            LPCWSTR wszReferringFile,
                            LPCWSTR wszReferringProp)
{
	HRESULT hres;

    //
    // Figure out the class we are pointing to
    //

    DWORD dwSize = 0;
    DWORD dwFlavor = 0;
    CIMTYPE ct;
    hres = pReferringClass->GetPropQual(wszReferringProp, L"CIMTYPE", 0, 0,
            &ct, &dwFlavor, &dwSize, NULL);
    if(dwSize == 0)
        return WBEM_E_OUT_OF_MEMORY;

    LPWSTR wszQual = (WCHAR*)TempAlloc(dwSize);
    if(wszQual == NULL)
        return WBEM_E_OUT_OF_MEMORY;
    CTempFreeMe tfm(wszQual, dwSize);

    hres = pReferringClass->GetPropQual(wszReferringProp, L"CIMTYPE", 0, dwSize,
            &ct, &dwFlavor, &dwSize, wszQual);
    if(FAILED(hres))
        return hres;
    
    //
    // Parse out the class name
    //

    WCHAR* pwcColon = wcschr(wszQual, L':');
    if(pwcColon == NULL)
        return S_OK; // untyped reference requires no bookkeeping

    LPCWSTR wszReferredToClass = pwcColon+1;

    //
    // Figure out the name of the file for the reference.  
    //

    CFileName wszReferenceFile;
	if (wszReferenceFile == NULL)
		return WBEM_E_OUT_OF_MEMORY;
    hres = ConstructClassReferenceFileName(wszReferredToClass, 
                                wszReferringFile, wszReferringProp,
                                wszReferenceFile);
    if(FAILED(hres))
        return hres;

    //
    // Delete the file
    //

    long lRes = g_Glob.GetFileCache()->DeleteLink(wszReferenceFile);
	if (lRes == ERROR_FILE_NOT_FOUND)
		return WBEM_E_NOT_FOUND;
	else if(lRes != ERROR_SUCCESS)
        return WBEM_E_FAILED;

    return S_OK;
}

CHR CNamespaceHandle::DeleteClassInstances(LPCWSTR wszClassName, 
											   _IWmiObject* pClass,
											   CEventCollector &aEvents)
{
	HRESULT hres;

    //
    // Find the link directory for this class
    //

    CFileName wszLinkDir;
	if (wszLinkDir == NULL)
		return WBEM_E_OUT_OF_MEMORY;
    hres = ConstructLinkDirFromClass(wszLinkDir, wszClassName);
    if(FAILED(hres))
        return hres;
    
    // 
    // Enumerate all links in it
    //

    CFileName wszSearchPrefix;
	if (wszSearchPrefix == NULL)
		return WBEM_E_OUT_OF_MEMORY;
    wcscpy(wszSearchPrefix, wszLinkDir);
    wcscat(wszSearchPrefix, L"\\" A51_INSTLINK_FILE_PREFIX);


    //
    // Prepare a buffer for instance definition file path
    //

    CFileName wszFullFileName;
    if (wszFullFileName == NULL)
        return WBEM_E_OUT_OF_MEMORY;

    hres = ConstructKeyRootDirFromClass(wszFullFileName, wszClassName);
    if(FAILED(hres))
    {
        if(hres == WBEM_E_CANNOT_BE_ABSTRACT)
            return WBEM_S_NO_ERROR;

        return hres;
    }

    long lDirLen = wcslen(wszFullFileName);
    wszFullFileName[lDirLen] = L'\\';
    lDirLen++;

    CFileName wszFileName;
    if (wszFullFileName == NULL)
        return WBEM_E_OUT_OF_MEMORY;

    void* hSearch;
    long lRes = g_Glob.GetFileCache()->IndexEnumerationBegin(wszSearchPrefix, &hSearch);
	if (lRes == ERROR_FILE_NOT_FOUND)
		return ERROR_SUCCESS;
	if (lRes != ERROR_SUCCESS)
		return A51TranslateErrorCode(lRes);

    while((lRes = g_Glob.GetFileCache()->IndexEnumerationNext(hSearch, wszFileName)) == ERROR_SUCCESS)
    {
        hres = ConstructInstDefNameFromLinkName(wszFullFileName+lDirLen, wszFileName);
        if(FAILED(hres))
            break;

        _IWmiObject* pInst;
        hres = FileToInstance(NULL, wszFullFileName, NULL, 0, &pInst);
        if(FAILED(hres))
			break;

        CReleaseMe rm1(pInst);

        //
        // Delete the instance, knowing that we are deleting its class. That
        // has an affect on how we deal with the references
        //

        hres = DeleteInstanceByFile(wszFullFileName, pInst, true, aEvents);
        if(FAILED(hres))
            break;
    }

	g_Glob.GetFileCache()->IndexEnumerationEnd(hSearch);

	if (hres != ERROR_SUCCESS)
		return hres;

    if(lRes != ERROR_NO_MORE_FILES && lRes != S_OK)
    {
        return WBEM_E_FAILED;
    }

    return S_OK;
}

class CExecQueryObject : public CFiberTask
{
protected:
    IWbemQuery* m_pQuery;
    CDbIterator* m_pIter;
    CNamespaceHandle* m_pNs;
	DWORD m_lFlags;

public:
    CExecQueryObject(CNamespaceHandle* pNs, IWbemQuery* pQuery, 
                        CDbIterator* pIter, DWORD lFlags)
        : m_pQuery(pQuery), m_pIter(pIter), m_pNs(pNs), m_lFlags(lFlags)
    {
        m_pQuery->AddRef();
        m_pNs->AddRef();

        //
        // Does not AddRef the iterator --- iterator owns and cleans up the req
        //
    }

    ~CExecQueryObject()
    {
        if(m_pQuery)
            m_pQuery->Release();
        if(m_pNs)
            m_pNs->Release();
    }
    
    HRESULT Execute()
    {
        HRESULT hres = m_pNs->ExecQuerySink(m_pQuery, m_lFlags, 0, m_pIter, NULL);
        m_pIter->SetStatus(WBEM_STATUS_COMPLETE, hres, NULL, NULL);
        return hres;
    }
};


CHR CNamespaceHandle::ExecQuery(
     IWbemQuery *pQuery,
     DWORD dwFlags,
     DWORD dwRequestedHandleType,
    DWORD *dwMessageFlags,
    IWmiDbIterator **ppQueryResult
    )
{
    CDbIterator* pIter = new CDbIterator(m_pControl, m_bUseIteratorLock);
	m_bUseIteratorLock = true;
	if (pIter == NULL)
		return WBEM_E_OUT_OF_MEMORY;

    pIter->AddRef();
    CReleaseMe rm1((IWmiDbIterator*)pIter);

    //
    // Create a fiber execution object
    //

    CExecQueryObject* pReq = new CExecQueryObject(this, pQuery, pIter, dwFlags);
    if(pReq == NULL)
        return WBEM_E_OUT_OF_MEMORY;

    //
    // Create a fiber for it
    //

    void* pFiber = CreateFiberForTask(pReq);
    if(pFiber == NULL)
    {
        delete pReq;
        return WBEM_E_OUT_OF_MEMORY;
    }

    pIter->SetExecFiber(pFiber, pReq);

    return pIter->QueryInterface(IID_IWmiDbIterator, (void**)ppQueryResult);
}

CHR CNamespaceHandle::ExecQuerySink(
     IWbemQuery *pQuery,
     DWORD dwFlags,
     DWORD dwRequestedHandleType,
    IWbemObjectSink* pSink,
    DWORD *dwMessageFlags
    )
{
	try
	{
		if (g_bShuttingDown)
			return WBEM_E_SHUTTING_DOWN;
        
		HRESULT hres;

		LPWSTR wszQuery = NULL;
		hres = pQuery->GetAnalysis(WMIQ_ANALYSIS_QUERY_TEXT, 0, (void**)&wszQuery);
		if (FAILED(hres))
			return hres;

		DWORD dwLen = ((wcslen(wszQuery) + 1) * sizeof(wchar_t));
		LPWSTR strParse = (LPWSTR)TempAlloc(dwLen);
		if(strParse == NULL)
		{
			pQuery->FreeMemory(wszQuery);
			return WBEM_E_OUT_OF_MEMORY;
		}
		CTempFreeMe tfm(strParse, dwLen);
		wcscpy(strParse, wszQuery);

		 if(!_wcsicmp(wcstok(strParse, L" "), L"references"))
		{
			hres = ExecReferencesQuery(wszQuery, pSink);
			pQuery->FreeMemory(wszQuery);
			return hres;
		}

		QL_LEVEL_1_RPN_EXPRESSION* pExpr = NULL;
		CTextLexSource Source(wszQuery);
		QL1_Parser Parser(&Source);
		int nRet = Parser.Parse(&pExpr);
		CDeleteMe<QL_LEVEL_1_RPN_EXPRESSION> dm(pExpr);

		pQuery->FreeMemory(wszQuery);

		if (nRet == QL1_Parser::OUT_OF_MEMORY)
			return WBEM_E_OUT_OF_MEMORY;
		if (nRet != QL1_Parser::SUCCESS)
			return WBEM_E_FAILED;

		if(!_wcsicmp(pExpr->bsClassName, L"meta_class"))
		{
			return ExecClassQuery(pExpr, pSink, dwFlags);
		}
		else
		{
			return ExecInstanceQuery(pExpr, pExpr->bsClassName, 
									 (dwFlags & WBEM_FLAG_SHALLOW ? false : true), 
										pSink);
		}
	}
	catch (CX_MemoryException)
	{
		return WBEM_E_OUT_OF_MEMORY;
	}
}


CHR CNamespaceHandle::ExecClassQuery(QL_LEVEL_1_RPN_EXPRESSION* pExpr, 
                                            IWbemObjectSink* pSink,
											DWORD dwFlags)
{
    if (g_bShuttingDown)
        return WBEM_E_SHUTTING_DOWN;

    HRESULT hres = ERROR_SUCCESS;

    //
    // Optimizations:
    //

    LPCWSTR wszClassName = NULL;
    LPCWSTR wszSuperClass = NULL;
    LPCWSTR wszAncestor = NULL;
	bool bDontIncludeAncestorInResultSet = false;

    if(pExpr->nNumTokens == 1)
    {
        QL_LEVEL_1_TOKEN* pToken = pExpr->pArrayOfTokens;
        if(!_wcsicmp(pToken->PropertyName.GetStringAt(0), L"__SUPERCLASS") &&
            pToken->nOperator == QL1_OPERATOR_EQUALS)
        {
            wszSuperClass = V_BSTR(&pToken->vConstValue);
        }
        else if(!_wcsicmp(pToken->PropertyName.GetStringAt(0), L"__THIS") &&
            pToken->nOperator == QL1_OPERATOR_ISA)
        {
            wszAncestor = V_BSTR(&pToken->vConstValue);
        }
        else if(!_wcsicmp(pToken->PropertyName.GetStringAt(0), L"__CLASS") &&
            pToken->nOperator == QL1_OPERATOR_EQUALS)
        {
            wszClassName = V_BSTR(&pToken->vConstValue);
        }
    }
	else if (pExpr->nNumTokens == 3)
	{
        //
		// This is a special optimisation used for deep enumeration of classes,
        // and is expecting a query of:
		//   select * from meta_class where __this isa '<class_name>' 
        //                                  and __class <> '<class_name>'
		// where the <class_name> is the same class iin both cases.  This will 
        // set the wszAncestor to <class_name> and propagate a flag to not 
        // include the actual ancestor in the list.
        //

		QL_LEVEL_1_TOKEN* pToken = pExpr->pArrayOfTokens;

		if ((pToken[0].nTokenType == QL1_OP_EXPRESSION) &&
			(pToken[1].nTokenType == QL1_OP_EXPRESSION) &&
			(pToken[2].nTokenType == QL1_AND) &&
			(pToken[0].nOperator == QL1_OPERATOR_ISA) &&
			(pToken[1].nOperator == QL1_OPERATOR_NOTEQUALS) &&
			(_wcsicmp(pToken[0].PropertyName.GetStringAt(0), L"__THIS") == 0) &&
			(_wcsicmp(pToken[1].PropertyName.GetStringAt(0), L"__CLASS") == 0) 
            &&
			(wcscmp(V_BSTR(&pToken[0].vConstValue), 
                    V_BSTR(&pToken[1].vConstValue)) == 0)
           )
		{
			wszAncestor = V_BSTR(&pToken[0].vConstValue);
			bDontIncludeAncestorInResultSet = true;
		}
	}

    if(wszClassName)
    {
        _IWmiObject* pClass = NULL;
        hres = GetClassDirect(wszClassName, IID__IWmiObject, (void**)&pClass,
                                true, NULL, NULL, NULL);
        if(hres == WBEM_E_NOT_FOUND)
        {
            //
            // Class not there --- but that's success for us!
            //
			if (dwFlags & WBEM_FLAG_VALIDATE_CLASS_EXISTENCE)
				return hres;
			else
				return S_OK;
        }
        else if(FAILED(hres))
        {
            return hres;
        }
        else 
        {
            CReleaseMe rm1(pClass);

            //
            // Get the class
            //

            hres = pSink->Indicate(1, (IWbemClassObject**)&pClass);
            if(FAILED(hres))
                return hres;

            return S_OK;
        }
    }
	if (dwFlags & WBEM_FLAG_VALIDATE_CLASS_EXISTENCE)
	{
        _IWmiObject* pClass = NULL;
		if (wszSuperClass)
			hres = GetClassDirect(wszSuperClass, IID__IWmiObject, (void**)&pClass, false, NULL, NULL, NULL);
		else if (wszAncestor)
			hres = GetClassDirect(wszAncestor, IID__IWmiObject, (void**)&pClass, false, NULL, NULL, NULL);
		if (FAILED(hres))
			return hres;
		if (pClass)
			pClass->Release();
	}
    
    hres = EnumerateClasses(pSink, wszSuperClass, wszAncestor, true, 
                                bDontIncludeAncestorInResultSet);
    if(FAILED(hres))
        return hres;
    
    return S_OK;
}

CHR CNamespaceHandle::EnumerateClasses(IWbemObjectSink* pSink,
                                LPCWSTR wszSuperClass, LPCWSTR wszAncestor,
                                bool bClone, 
                                bool bDontIncludeAncestorInResultSet)
{
    if (g_bShuttingDown)
        return WBEM_E_SHUTTING_DOWN;
        
    CWStringArray wsClasses;
    HRESULT hres;

    //
    // If superclass is given, check if its record is complete wrt children
    //

    if(wszSuperClass)
    {
        hres = m_pClassCache->EnumChildren(wszSuperClass, false, wsClasses);
        if(hres == WBEM_S_FALSE)
        {
            //
            // Not in cache --- get the info from files
            //

            return GetChildDefs(wszSuperClass, false, pSink, bClone);
        }
        else
        {
            if(FAILED(hres))
                return hres;
                
            return ListToEnum(wsClasses, pSink, bClone);
        }
    }
    else
    {
        if(wszAncestor == NULL)
            wszAncestor = L"";

        hres = m_pClassCache->EnumChildren(wszAncestor, true, wsClasses);
        if(hres == WBEM_S_FALSE)
        {
            //
            // Not in cache --- get the info from files
            //

            hres = GetChildDefs(wszAncestor, true, pSink, bClone);
            if(FAILED(hres))
                return hres;

            if(*wszAncestor && !bDontIncludeAncestorInResultSet)
            {
                //
                // The class is derived from itself
                //

                _IWmiObject* pClass =  NULL;
                hres = GetClassDirect(wszAncestor, IID__IWmiObject, 
                        (void**)&pClass, bClone, NULL, NULL, NULL);
                if(FAILED(hres))
                    return hres;
				CReleaseMe rm1(pClass);

				hres = pSink->Indicate(1, (IWbemClassObject**)&pClass);
				if(FAILED(hres))
			        return hres;
            }

            return S_OK;
        }
        else
        {
            if(FAILED(hres))
                return hres;

            if(*wszAncestor && !bDontIncludeAncestorInResultSet)
            {
	          wsClasses.Add(wszAncestor);
            }
            return ListToEnum(wsClasses, pSink, bClone);
        }
    }
}
    
CHR CNamespaceHandle::ListToEnum(CWStringArray& wsClasses, 
                                        IWbemObjectSink* pSink, bool bClone)
{
    HRESULT hres;

    for(int i = 0; i < wsClasses.Size(); i++)
    {
        _IWmiObject* pClass = NULL;
        if(wsClasses[i] == NULL || wsClasses[i][0] == 0)
            continue;

        hres = GetClassDirect(wsClasses[i], IID__IWmiObject, (void**)&pClass, 
                                bClone, NULL, NULL, NULL);
        if(FAILED(hres))
        {
            if(hres == WBEM_E_NOT_FOUND)
            {
                // That's OK --- class got removed
            }
            else
                return hres;
        }
        else
        {
            CReleaseMe rm1(pClass);
            hres = pSink->Indicate(1, (IWbemClassObject**)&pClass);
            if(FAILED(hres))
                return hres;
        }
    }

    return WBEM_S_NO_ERROR;
}

CHR CNamespaceHandle::ExecInstanceQuery(QL_LEVEL_1_RPN_EXPRESSION* pQuery, 
                                LPCWSTR wszClassName, bool bDeep,
                                IWbemObjectSink* pSink)
{
    if (g_bShuttingDown)
        return WBEM_E_SHUTTING_DOWN;
        
    HRESULT hres;

    WCHAR wszHash[MAX_HASH_LEN+1];
    if(!Hash(wszClassName, wszHash))
        return WBEM_E_OUT_OF_MEMORY;

    if(bDeep)
        hres = ExecDeepInstanceQuery(pQuery, wszHash, pSink);
    else
        hres = ExecShallowInstanceQuery(pQuery, wszHash, pSink);

    if(FAILED(hres))
        return hres;
        
    return S_OK;
}

CHR CNamespaceHandle::ExecDeepInstanceQuery(
                                QL_LEVEL_1_RPN_EXPRESSION* pQuery, 
                                LPCWSTR wszClassHash,
                                IWbemObjectSink* pSink)
{
    if (g_bShuttingDown)
        return WBEM_E_SHUTTING_DOWN;
        
    HRESULT hres;

    //
    // Get all our instances
    //

    hres = ExecShallowInstanceQuery(pQuery, wszClassHash, pSink);
    if(FAILED(hres))
        return hres;

    CWStringArray awsChildHashes;

    //
    // Check if the list of child classes is known to the cache
    //

    hres = m_pClassCache->EnumChildKeysByKey(wszClassHash, awsChildHashes);
	if (hres == WBEM_S_FALSE)
	{
        //
        // OK --- get them from the disk
        //

        hres = GetChildHashesByHash(wszClassHash, awsChildHashes);
	}
	
	if (FAILED(hres))
	{
		return hres;
	}

    //
    // We have our hashes --- call them recursively
    //

    for(int i = 0; i < awsChildHashes.Size(); i++)
    {
        LPCWSTR wszChildHash = awsChildHashes[i];
        hres = ExecDeepInstanceQuery(pQuery, wszChildHash, pSink);
        if(FAILED(hres))
            return hres;
    }

    return S_OK;
}
        
CHR CNamespaceHandle::ExecShallowInstanceQuery(
                                QL_LEVEL_1_RPN_EXPRESSION* pQuery, 
                                LPCWSTR wszClassHash, 
                                IWbemObjectSink* pSink)
{    
    if (g_bShuttingDown)
        return WBEM_E_SHUTTING_DOWN;

    HRESULT hres;

    // 
    // Enumerate all files in the link directory
    //

    CFileName wszSearchPrefix;
	if (wszSearchPrefix == NULL)
		return WBEM_E_OUT_OF_MEMORY;
    hres = ConstructLinkDirFromClassHash(wszSearchPrefix, wszClassHash);
    if(FAILED(hres))
        return hres;

    wcscat(wszSearchPrefix, L"\\" A51_INSTLINK_FILE_PREFIX);

    //
    // Get Class definition
    //

    _IWmiObject* pClass = NULL;
    hres = GetClassByHash(wszClassHash, false, &pClass, NULL, NULL, NULL);
    if(FAILED(hres))
        return hres;
    CReleaseMe rm1(pClass);

	CFileName fn;
	if (fn == NULL)
		return WBEM_E_OUT_OF_MEMORY;

    void* hSearch;
    long lRes = g_Glob.GetFileCache()->ObjectEnumerationBegin(wszSearchPrefix, &hSearch);
	if (lRes == ERROR_FILE_NOT_FOUND)
		return S_OK;
	else if (lRes != ERROR_SUCCESS)
		return A51TranslateErrorCode(lRes);

	BYTE *pBlob = NULL;
	DWORD dwSize = 0;

	while ((hres == ERROR_SUCCESS) && 
		   (lRes = g_Glob.GetFileCache()->ObjectEnumerationNext(hSearch, fn, &pBlob, &dwSize) == ERROR_SUCCESS))
    {
        _IWmiObject* pInstance = NULL;

		hres = FileToInstance(pClass, fn, pBlob, dwSize, &pInstance, true);

        CReleaseMe rm2(pInstance);

		if (SUCCEEDED(hres))
			hres = pSink->Indicate(1, (IWbemClassObject**)&pInstance);
		
		g_Glob.GetFileCache()->ObjectEnumerationFree(hSearch, pBlob);
    }

	g_Glob.GetFileCache()->ObjectEnumerationEnd(hSearch);

	if (lRes == ERROR_NO_MORE_FILES)
		return S_OK;
	else if (lRes)
		return A51TranslateErrorCode(lRes);
	else
		return hres;
}

CHR CNamespaceHandle::ExecReferencesQuery(LPCWSTR wszQuery, 
                                                IWbemObjectSink* pSink)
{
    if (g_bShuttingDown)
        return WBEM_E_SHUTTING_DOWN;
        
    HRESULT hres;

    //
    // Make a copy for parsing
    //

    LPWSTR wszParse = new WCHAR[wcslen(wszQuery)+1];
	if (wszParse == NULL)
		return WBEM_E_OUT_OF_MEMORY;
    CVectorDeleteMe<WCHAR> vdm(wszParse);
    wcscpy(wszParse, wszQuery);

    //
    // Extract the path of the target object.
    //

    //
    // Find the first brace
    //

    WCHAR* pwcStart = wcschr(wszParse, L'{');
    if(pwcStart == NULL)
        return WBEM_E_INVALID_QUERY;

    //
    // Find the beginning of the path
    //

    while(*pwcStart && iswspace(*pwcStart)) pwcStart++;
    if(!*pwcStart)
        return WBEM_E_INVALID_QUERY;

    pwcStart++;
    
    //
    // Find the ending curly brace
    //

    WCHAR* pwc = pwcStart;
    WCHAR wcCurrentQuote = 0;
    while(*pwc && (wcCurrentQuote || *pwc != L'}'))
    {
        if(wcCurrentQuote)
        {
            if(*pwc == L'\\')
            {
                pwc++;
            }
            else if(*pwc == wcCurrentQuote)
                wcCurrentQuote = 0;
        }
        else if(*pwc == L'\'' || *pwc == L'"')
            wcCurrentQuote = *pwc;

        pwc++;
    }

    if(*pwc != L'}')
        return WBEM_E_INVALID_QUERY;

    //
    // Find the end of the path
    //
    
    WCHAR* pwcEnd = pwc-1;
    while(iswspace(*pwcEnd)) pwcEnd--;

    pwcEnd[1] = 0;
    
    LPWSTR wszTargetPath = pwcStart;
    if(wszTargetPath == NULL)
        return WBEM_E_INVALID_QUERY;

    //
    // Parse the path
    //

    DWORD dwLen = (wcslen(wszTargetPath)+1) * sizeof(WCHAR);
    LPWSTR wszKey = (LPWSTR)TempAlloc(dwLen);
    if(wszKey == NULL)
        return WBEM_E_OUT_OF_MEMORY;
    CTempFreeMe tfm(wszKey, dwLen);

    LPWSTR wszClassName = NULL;
    bool bIsClass;
    hres = ComputeKeyFromPath(wszTargetPath, wszKey, &wszClassName, &bIsClass);
    if(FAILED(hres))
        return hres;
    CTempFreeMe tfm1(wszClassName, (wcslen(wszClassName)+1) * sizeof(WCHAR*));
    
    if(bIsClass)
    {
        //
        // Need to execute an instance reference query to find all instances
        // pointing to this class
        //

        hres = ExecInstanceRefQuery(wszQuery, NULL, wszClassName, pSink);
        if(FAILED(hres))
            return hres;

        hres = ExecClassRefQuery(wszQuery, wszClassName, pSink);
        if(FAILED(hres))
            return hres;
    }
    else
    {
        hres = ExecInstanceRefQuery(wszQuery, wszClassName, wszKey, pSink);
        if(FAILED(hres))
            return hres;
    }

    return S_OK;
}

CHR CNamespaceHandle::ExecInstanceRefQuery(LPCWSTR wszQuery, 
                                                LPCWSTR wszClassName,
                                                LPCWSTR wszKey,
                                                IWbemObjectSink* pSink)
{
    if (g_bShuttingDown)
        return WBEM_E_SHUTTING_DOWN;
        
    HRESULT hres;

    //
    // Find the instance's ref dir.
    //

    CFileName wszReferenceDir;
	if (wszReferenceDir == NULL)
		return WBEM_E_OUT_OF_MEMORY;
    hres = ConstructReferenceDirFromKey(wszClassName, wszKey, wszReferenceDir);
    if(FAILED(hres))
        return hres;

    CFileName wszReferenceMask;
	if (wszReferenceMask == NULL)
		return WBEM_E_OUT_OF_MEMORY;
    wcscpy(wszReferenceMask, wszReferenceDir);
    wcscat(wszReferenceMask, L"\\" A51_REF_FILE_PREFIX);

    //
    // Prepare a buffer for file path
    //

    CFileName wszFullFileName;
	if (wszFullFileName == NULL)
		return WBEM_E_OUT_OF_MEMORY;

    wcscpy(wszFullFileName, wszReferenceDir);
    wcscat(wszFullFileName, L"\\");
    long lDirLen = wcslen(wszFullFileName);

    HRESULT hresGlobal = WBEM_S_NO_ERROR;
    CFileName wszReferrerFileName;
	if (wszReferrerFileName == NULL)
		return WBEM_E_OUT_OF_MEMORY;

    wcscpy(wszReferrerFileName, g_Glob.GetRootDir());

    CFileName wszFileName;
	if (wszFileName == NULL)
		return WBEM_E_OUT_OF_MEMORY;
    // 
    // Enumerate all files in it
    //

    void* hSearch;
    long lRes = g_Glob.GetFileCache()->IndexEnumerationBegin(wszReferenceMask, &hSearch);
	if (lRes == ERROR_FILE_NOT_FOUND)
		return S_OK;
	else if (lRes != ERROR_SUCCESS)
		return A51TranslateErrorCode(lRes);

	while((lRes = g_Glob.GetFileCache()->IndexEnumerationNext(hSearch, wszFileName)) == ERROR_SUCCESS)
	{
        wcscpy(wszFullFileName+lDirLen, wszFileName);

        LPWSTR wszReferrerClass = NULL;
        LPWSTR wszReferrerProp = NULL;
        LPWSTR wszReferrerNamespace = NULL;
        hres = GetReferrerFromFile(wszFullFileName, wszReferrerFileName + g_Glob.GetRootDirLen(), &wszReferrerNamespace, &wszReferrerClass, &wszReferrerProp);
        if(FAILED(hres))
            continue;
        CVectorDeleteMe<WCHAR> vdm1(wszReferrerClass);
        CVectorDeleteMe<WCHAR> vdm2(wszReferrerProp);
        CVectorDeleteMe<WCHAR> vdm3(wszReferrerNamespace);

        // Check if the namespace of the referring object is the same as ours
        CNamespaceHandle* pReferrerHandle = NULL;
        if(wbem_wcsicmp(wszReferrerNamespace, m_wsNamespace))
        {
            // Open the other namespace
            hres = m_pRepository->GetNamespaceHandle(wszReferrerNamespace, &pReferrerHandle);
            if(FAILED(hres))
            {
                ERRORTRACE((LOG_WBEMCORE, "Unable to open referring namespace '%S' in namespace '%S'\n", wszReferrerNamespace, (LPCWSTR)m_wsNamespace));
                hresGlobal = hres;
                continue;
            }
        }
        else
        {
            pReferrerHandle = this;
            pReferrerHandle->AddRef();
        }

        CReleaseMe rm1(pReferrerHandle);


        _IWmiObject* pInstance = NULL;
        hres = pReferrerHandle->FileToInstance(NULL, wszReferrerFileName, NULL, 0, &pInstance);
        if(FAILED(hres))
        {
            // Oh well --- continue;
            hresGlobal = hres;
        }
        else
        {
            CReleaseMe rm2(pInstance);
            hres = pSink->Indicate(1, (IWbemClassObject**)&pInstance);
            if(FAILED(hres))
			{
				hresGlobal = hres;
                break;
			}
        }
    }

    g_Glob.GetFileCache()->IndexEnumerationEnd(hSearch);

	if (hresGlobal != ERROR_SUCCESS)
		return hresGlobal;
    if(lRes == ERROR_NO_MORE_FILES)
    {
        //
        // No files in dir --- no problem
        //
        return WBEM_S_NO_ERROR;
    }
    else if(lRes != ERROR_SUCCESS)
    {
        return WBEM_E_FAILED;
    }
	return WBEM_S_NO_ERROR;
}

CHR CNamespaceHandle::GetReferrerFromFile(LPCWSTR wszReferenceFile,
                            LPWSTR wszReferrerRelFile, 
                            LPWSTR* pwszReferrerNamespace,
                            LPWSTR* pwszReferrerClass,
                            LPWSTR* pwszReferrerProp)
{
    //
    // Get the entire buffer from the file
    //

    BYTE* pBuffer = NULL;
    DWORD dwBufferLen = 0;
    long lRes = g_Glob.GetFileCache()->ReadObject(wszReferenceFile, &dwBufferLen,
                                            &pBuffer);
    if(lRes != ERROR_SUCCESS)
        return WBEM_E_FAILED;
    CTempFreeMe tfm(pBuffer, dwBufferLen);

    if(dwBufferLen == 0)
        return WBEM_E_OUT_OF_MEMORY;

    BYTE* pCurrent = pBuffer;
    DWORD dwStringLen;

    //
    // Get the referrer namespace
    //

    memcpy(&dwStringLen, pCurrent, sizeof(DWORD));
    pCurrent += sizeof(DWORD);
    
    *pwszReferrerNamespace = new WCHAR[dwStringLen+1];
	if (*pwszReferrerNamespace == NULL)
		return WBEM_E_OUT_OF_MEMORY;
    (*pwszReferrerNamespace)[dwStringLen] = 0;
    memcpy(*pwszReferrerNamespace, pCurrent, dwStringLen*sizeof(WCHAR));
    pCurrent += sizeof(WCHAR)*dwStringLen;
    
    //
    // Get the referrer class name
    //

    memcpy(&dwStringLen, pCurrent, sizeof(DWORD));
    pCurrent += sizeof(DWORD);
    
    *pwszReferrerClass = new WCHAR[dwStringLen+1];
	if (*pwszReferrerClass == NULL)
		return WBEM_E_OUT_OF_MEMORY;
    (*pwszReferrerClass)[dwStringLen] = 0;
    memcpy(*pwszReferrerClass, pCurrent, dwStringLen*sizeof(WCHAR));
    pCurrent += sizeof(WCHAR)*dwStringLen;

    //
    // Get the referrer property
    //

    memcpy(&dwStringLen, pCurrent, sizeof(DWORD));
    pCurrent += sizeof(DWORD);
    
    *pwszReferrerProp = new WCHAR[dwStringLen+1];
	if (*pwszReferrerProp == NULL)
		return WBEM_E_OUT_OF_MEMORY;

    (*pwszReferrerProp)[dwStringLen] = 0;
    memcpy(*pwszReferrerProp, pCurrent, dwStringLen*sizeof(WCHAR));
    pCurrent += sizeof(WCHAR)*dwStringLen;

    //
    // Get referrer file path
    //

    memcpy(&dwStringLen, pCurrent, sizeof(DWORD));
    pCurrent += sizeof(DWORD);

    wszReferrerRelFile[dwStringLen] = 0;
    memcpy(wszReferrerRelFile, pCurrent, dwStringLen*sizeof(WCHAR));
    pCurrent += sizeof(WCHAR)*dwStringLen;

    return S_OK;
}
    

CHR CNamespaceHandle::ExecClassRefQuery(LPCWSTR wszQuery, 
                                                LPCWSTR wszClassName,
                                                IWbemObjectSink* pSink)
{
    if (g_bShuttingDown)
        return WBEM_E_SHUTTING_DOWN;
        
    HRESULT hres = ERROR_SUCCESS;

	//Execute against system class namespace first
	if (g_pSystemClassNamespace && (wcscmp(m_wsNamespace, A51_SYSTEMCLASS_NS) != 0))
	{
		hres = g_pSystemClassNamespace->ExecClassRefQuery(wszQuery, wszClassName, pSink);
		if (FAILED(hres))
			return hres;
	}
			
	//
    // Find the class's ref dir.
    //

    CFileName wszReferenceDir;
	if (wszReferenceDir == NULL)
		return WBEM_E_OUT_OF_MEMORY;
    hres = ConstructClassRelationshipsDir(wszClassName, wszReferenceDir);

    CFileName wszReferenceMask;
	if (wszReferenceMask == NULL)
		return WBEM_E_OUT_OF_MEMORY;
    wcscpy(wszReferenceMask, wszReferenceDir);
    wcscat(wszReferenceMask, L"\\" A51_REF_FILE_PREFIX);

    CFileName wszFileName;
	if (wszFileName == NULL)
		return WBEM_E_OUT_OF_MEMORY;
    // 
    // Enumerate all files in it
    //

    void* hSearch;
    long lRes = g_Glob.GetFileCache()->IndexEnumerationBegin(wszReferenceMask, &hSearch);
	if (lRes == ERROR_FILE_NOT_FOUND)
		return S_OK;
	else if (lRes != ERROR_SUCCESS)
		return A51TranslateErrorCode(lRes);

    while ((hres == ERROR_SUCCESS) && ((lRes = g_Glob.GetFileCache()->IndexEnumerationNext(hSearch, wszFileName) == ERROR_SUCCESS)))
    {
        //  
        // Extract the class hash from the name of the file
        //

        LPCWSTR wszReferrerHash = wszFileName + wcslen(A51_REF_FILE_PREFIX);
        
        //
        // Get the class from that hash
        //

        _IWmiObject* pClass = NULL;
        hres = GetClassByHash(wszReferrerHash, true, &pClass, NULL, NULL, NULL);
        if(hres == WBEM_E_NOT_FOUND)
        {
			hres = ERROR_SUCCESS;
			continue;
        }

        CReleaseMe rm1(pClass);
		if (hres == ERROR_SUCCESS)
			hres = pSink->Indicate(1, (IWbemClassObject**)&pClass);
    }
	g_Glob.GetFileCache()->IndexEnumerationEnd(hSearch);


	if (hres != ERROR_SUCCESS)
		return hres;
    if(lRes == ERROR_NO_MORE_FILES)
    {
        //
        // No files in dir --- no problem
        //
        return WBEM_S_NO_ERROR;
    }
    else if(lRes != ERROR_SUCCESS)
    {
        return WBEM_E_FAILED;
    }
    return S_OK;
}

bool CNamespaceHandle::Hash(LPCWSTR wszName, LPWSTR wszHash)
{
    return A51Hash(wszName, wszHash);
}

CHR CNamespaceHandle::InstanceToFile(IWbemClassObject* pInst, 
                            LPCWSTR wszClassName, LPCWSTR wszFileName1, LPCWSTR wszFileName2,
                            __int64 nClassTime)
{
    HRESULT hres;

    //
    // Allocate enough space for the buffer
    //

    _IWmiObject* pInstEx;
    pInst->QueryInterface(IID__IWmiObject, (void**)&pInstEx);
    CReleaseMe rm1(pInstEx);

    DWORD dwInstancePartLen = 0;
    hres = pInstEx->Unmerge(0, 0, &dwInstancePartLen, NULL);

    //
    // Add enough room for the class hash
    //

    DWORD dwClassHashLen = MAX_HASH_LEN * sizeof(WCHAR);
    DWORD dwTotalLen = dwInstancePartLen + dwClassHashLen + sizeof(__int64)*2;

    BYTE* pBuffer = (BYTE*)TempAlloc(dwTotalLen);
	if (pBuffer == NULL)
		return WBEM_E_OUT_OF_MEMORY;
    CTempFreeMe vdm(pBuffer, dwTotalLen);

    //
    // Write the class hash
    //

    if(!Hash(wszClassName, (LPWSTR)pBuffer))
        return WBEM_E_OUT_OF_MEMORY;

    memcpy(pBuffer + dwClassHashLen, &g_nCurrentTime, sizeof(__int64));
    g_nCurrentTime++;

    memcpy(pBuffer + dwClassHashLen + sizeof(__int64), &nClassTime, 
            sizeof(__int64));

    //
    // Unmerge the instance into a buffer
    // 

    DWORD dwLen;
    hres = pInstEx->Unmerge(0, dwInstancePartLen, &dwLen, 
                            pBuffer + dwClassHashLen + sizeof(__int64)*2);
    if(FAILED(hres))
        return hres;

    //
    // Write to the file only as much as we have actually used!
    //

    long lRes = g_Glob.GetFileCache()->WriteObject(wszFileName1, wszFileName2, 
                    dwClassHashLen + sizeof(__int64)*2 + dwLen, pBuffer);
    if(lRes != ERROR_SUCCESS)
        return WBEM_E_FAILED;
    
    return WBEM_S_NO_ERROR;
}

CHR CNamespaceHandle::ClassToFile(_IWmiObject* pParentClass, 
                _IWmiObject* pClass, LPCWSTR wszFileName, 
                __int64 nFakeUpdateTime)
{
    HRESULT hres;

    //
    // Get superclass name
    //

    VARIANT vSuper;
    hres = pClass->Get(L"__SUPERCLASS", 0, &vSuper, NULL, NULL);
    if(FAILED(hres))
        return hres;

    CClearMe cm1(&vSuper);

    LPCWSTR wszSuper;
    if(V_VT(&vSuper) == VT_BSTR)
        wszSuper = V_BSTR(&vSuper);
    else
        wszSuper = L"";

    VARIANT vClassName;
    hres = pClass->Get(L"__CLASS", 0, &vClassName, NULL, NULL);
    if(FAILED(hres))
        return hres;
    CClearMe cm2(&vClassName);

    LPCWSTR wszClassName;
    if(V_VT(&vClassName) == VT_BSTR)
        wszClassName = V_BSTR(&vClassName);
    else
        wszClassName = L"";

#ifdef A51_SUPER_VALIDATION
	if (wcscmp(wszSuper, wszClassName) == 0)
	{
		OutputDebugString(L"WinMgmt: Repository is trying to put a class that is derived from itself!\n");
		DebugBreak();
		return WBEM_E_FAILED;
	}
	if (pClass->IsObjectInstance() == S_OK)
	{
		OutputDebugString(L"WinMgmt: Repository is trying to store an instance in a class blob!\n");
		DebugBreak();
		return WBEM_E_FAILED;
	}
	if (FAILED(pClass->ValidateObject(WMIOBJECT_VALIDATEOBJECT_FLAG_FORCE)))
	{
		OutputDebugString(L"WinMgmt: Repository was gived an invalid class to store in the repository!\n");
		DebugBreak();
		return WBEM_E_FAILED;
	}
#endif

    //
    // Get unmerge length
    //

    DWORD dwUnmergedLen = 0;
    hres = pClass->Unmerge(0, 0, &dwUnmergedLen, NULL);

    //
    // Add enough space for the parent class name and the timestamp
    //

    DWORD dwSuperLen = sizeof(DWORD) + wcslen(wszSuper)*sizeof(WCHAR);

    DWORD dwLen = dwUnmergedLen + dwSuperLen + sizeof(__int64);

    BYTE* pBuffer = (BYTE*)TempAlloc(dwLen);
	if (pBuffer == NULL)
		return WBEM_E_OUT_OF_MEMORY;
    CTempFreeMe vdm(pBuffer, dwLen);

    //
    // Write superclass name
    //

    DWORD dwActualSuperLen = wcslen(wszSuper);
    memcpy(pBuffer, &dwActualSuperLen, sizeof(DWORD));
    memcpy(pBuffer + sizeof(DWORD), wszSuper, wcslen(wszSuper)*sizeof(WCHAR));

    //
    // Write the timestamp
    //

    if(nFakeUpdateTime == 0)
    {
        nFakeUpdateTime = g_nCurrentTime;
        g_nCurrentTime++;
    }

    memcpy(pBuffer + dwSuperLen, &nFakeUpdateTime, sizeof(__int64));

    //
    // Write the unmerged portion
    //

    BYTE* pUnmergedPortion = pBuffer + dwSuperLen + sizeof(__int64);
    hres = pClass->Unmerge(0, dwUnmergedLen, &dwUnmergedLen, 
                            pUnmergedPortion);
    if(FAILED(hres))
        return hres;

    //
    // Stash away the real length
    //

    DWORD dwFileLen = dwUnmergedLen + dwSuperLen + sizeof(__int64);

    long lRes = g_Glob.GetFileCache()->WriteObject(wszFileName, NULL, dwFileLen, pBuffer);
    if(lRes != ERROR_SUCCESS)
        return WBEM_E_FAILED;

    //
    // To properly cache the new class definition, first invalidate it
    //

    hres = m_pClassCache->InvalidateClass(wszClassName);
    if(FAILED(hres))
        return hres;

    //
    // Now, remerge the unmerged portion back in
    //

    if(pParentClass == NULL)
    {
        //
        // Get the empty class
        //

        hres = GetClassDirect(NULL, IID__IWmiObject, (void**)&pParentClass, 
                                false, NULL, NULL, NULL);
        if(FAILED(hres))
            return hres;
    }
    else
        pParentClass->AddRef();
    CReleaseMe rm0(pParentClass);

    _IWmiObject* pNewObj;
    hres = pParentClass->Merge(0, dwUnmergedLen, pUnmergedPortion, &pNewObj);
    if(FAILED(hres))
        return hres;
    CReleaseMe rm1(pNewObj);

    hres = pNewObj->SetDecoration(m_wszMachineName, m_wsNamespace);
    if(FAILED(hres))
        return hres;

    hres = m_pClassCache->AssertClass(pNewObj, wszClassName, false, 
                                        nFakeUpdateTime, false); 
    if(FAILED(hres))
        return hres;

    return WBEM_S_NO_ERROR;
}


CHR CNamespaceHandle::ConstructInstanceDefName(LPWSTR wszInstanceDefName,
                                                    LPCWSTR wszKey)
{
    wcscpy(wszInstanceDefName, A51_INSTDEF_FILE_PREFIX);
    if(!Hash(wszKey, wszInstanceDefName + wcslen(A51_INSTDEF_FILE_PREFIX)))
    {
        return WBEM_E_OUT_OF_MEMORY;
    }
    return WBEM_S_NO_ERROR;
}

CHR CNamespaceHandle::ConstructInstDefNameFromLinkName(
                                                    LPWSTR wszInstanceDefName,
                                                    LPCWSTR wszInstanceLinkName)
{
    wcscpy(wszInstanceDefName, A51_INSTDEF_FILE_PREFIX);
    wcscat(wszInstanceDefName, 
        wszInstanceLinkName + wcslen(A51_INSTLINK_FILE_PREFIX));
    return WBEM_S_NO_ERROR;
}

CHR CNamespaceHandle::ConstructClassDefFileName(LPCWSTR wszClassName, 
                                            LPWSTR wszFileName)
{
    wcscpy(wszFileName, A51_CLASSDEF_FILE_PREFIX);
    if(!Hash(wszClassName, wszFileName+wcslen(A51_CLASSDEF_FILE_PREFIX)))
        return WBEM_E_INVALID_OBJECT;
    return WBEM_S_NO_ERROR;
}

CHR CNamespaceHandle::ConstructClassDefFileNameFromHash(LPCWSTR wszHash, 
                                            LPWSTR wszFileName)
{
    wcscpy(wszFileName, A51_CLASSDEF_FILE_PREFIX);
    wcscat(wszFileName, wszHash);
    return WBEM_S_NO_ERROR;
}

//=============================================================================
//
// CNamespaceHandle::CreateSystemClasses
//
// We are in a pseudo namespace.  We need to determine if we already have
// the system classes in this namespace.  The system classes that we create
// are those that exist in all namespaces, and no others.  If they do not exist
// we create them.
// The whole creation process happens within the confines of a transaction
// that we create and own within this method.
//
//=============================================================================
HRESULT CNamespaceHandle::CreateSystemClasses(CFlexArray &aSystemClasses)
{
	HRESULT hRes = WBEM_S_NO_ERROR;

	//Now we need to determine if the system classes already exist.  Lets do this by looking for the __thisnamespace
	//class!
	{
		_IWmiObject *pObj = NULL;
		hRes = GetClassDirect(L"__thisnamespace", IID__IWmiObject, (void**)&pObj, false, NULL, NULL, NULL);
		if (SUCCEEDED(hRes))
		{
			//All done!  They already exist!
			pObj->Release();
			return WBEM_S_NO_ERROR;
		}
		else if (hRes != WBEM_E_NOT_FOUND)
		{
			//Something went bad, so we just fail!
			return hRes;
		}
	}

	//There are no system classes so we need to create them.
    hRes = A51TranslateErrorCode(g_Glob.GetFileCache()->BeginTransaction());
	
	CEventCollector eventCollector;
    _IWmiObject *Objects[256];
    _IWmiObject **ppObjects = NULL;
    ULONG uSize = 256;
	
	if (SUCCEEDED(hRes) && aSystemClasses.Size())
	{
		//If we have a system-class array we need to use that instead of using the ones retrieved from the core
		//not doing so will cause a mismatch.  We retrieved these as part of the upgrade process...
		uSize = aSystemClasses.Size();
		ppObjects = (_IWmiObject**)&aSystemClasses[0];
	}
	else if (SUCCEEDED(hRes))
	{
		//None retrieved from upgrade process so we must be a clean install.  Therefore we should 
		//get the list from the core...
        _IWmiCoreServices * pSvcs = g_Glob.GetCoreSvcs();
        CReleaseMe rm(pSvcs);		
		hRes = pSvcs->GetSystemObjects(GET_SYSTEM_STD_OBJECTS, &uSize, Objects);
		ppObjects = Objects;
	}
    if (SUCCEEDED(hRes))
    {
        for (int i = 0; i < uSize; i++)
        {
            IWbemClassObject *pObj;
            if (SUCCEEDED(hRes))
            {
                hRes = ppObjects[i]->QueryInterface(IID_IWbemClassObject, (LPVOID *) &pObj);
                if (SUCCEEDED(hRes))
                {
                    hRes = PutObject(IID_IWbemClassObject, pObj, WMIDB_DISABLE_EVENTS, 0, 0, eventCollector);
                    pObj->Release();
					if (FAILED(hRes))
					{
				        ERRORTRACE((LOG_WBEMCORE, "Creation of system class failed during repository creation <0x%X>!\n", hRes));
					}
                }
            }
            ppObjects[i]->Release();
        }
    }

	//Clear out the array that was sent to us.
	aSystemClasses.Empty();

    if (FAILED(hRes))
    {
        g_Glob.GetFileCache()->AbortTransaction();
    }
    else
    {
        hRes = A51TranslateErrorCode(g_Glob.GetFileCache()->CommitTransaction());
		if (hRes == ERROR_SUCCESS)
			CRepository::WriteOperationNotification();
		else
			CRepository::RecoverCheckpoint();
	}
	return hRes;
}

class CSystemClassDeletionSink : public CUnkBase<IWbemObjectSink, &IID_IWbemObjectSink>
{
	CWStringArray &m_aChildNamespaces;
public:
	CSystemClassDeletionSink(CWStringArray &aChildNamespaces) 
		: m_aChildNamespaces(aChildNamespaces) 
	{
	}
	~CSystemClassDeletionSink() 
	{
	}
    STDMETHOD(Indicate)(long lNumObjects, IWbemClassObject** apObjects)
	{
		HRESULT hRes;
		for (int i = 0; i != lNumObjects; i++)
		{
			if (apObjects[i] != NULL)
			{
				_IWmiObject *pInst = NULL;
				hRes = apObjects[i]->QueryInterface(IID__IWmiObject, (void**)&pInst);
				if (FAILED(hRes))
					return hRes;
				CReleaseMe rm(pInst);

				BSTR strKey = NULL;
				hRes = pInst->GetKeyString(0, &strKey);
				if(FAILED(hRes))
					return hRes;
				CSysFreeMe sfm(strKey);
				if (m_aChildNamespaces.Add(strKey) != CWStringArray::no_error)
					return WBEM_E_OUT_OF_MEMORY;
			}
		}

		return WBEM_S_NO_ERROR;
	}
    STDMETHOD(SetStatus)(long lFlags, HRESULT hresResult, BSTR, IWbemClassObject*) 
	{ 
		return WBEM_S_NO_ERROR; 
	}

};

//=============================================================================
//=============================================================================
CDbIterator::CDbIterator(CLifeControl* pControl, bool bUseLock)
        : TUnkBase(pControl), m_lCurrentIndex(0), m_hresStatus(WBEM_S_FALSE),
            m_pMainFiber(NULL), m_pExecFiber(NULL), m_dwNumRequested(0),
            m_pExecReq(NULL), m_hresCancellationStatus(WBEM_S_NO_ERROR),
            m_bExecFiberRunning(false), m_bUseLock(bUseLock)
{
}

CDbIterator::~CDbIterator()
{
    if(m_pExecFiber)
        Cancel(0, NULL);
    if(m_pExecReq)
        delete m_pExecReq;

	CRepository::ReadOperationNotification();
}

void CDbIterator::SetExecFiber(void* pFiber, CFiberTask* pReq)
{
    m_pExecFiber = pFiber;
    m_pExecReq = pReq;
}

STDMETHODIMP CDbIterator::Cancel(DWORD dwFlags, void* pFiber)
{
    CInCritSec ics(&m_cs);

    m_qObjects.Clear();

    //
    // Mark the iterator as cancelled and allow the execution fiber to resume
    // and complete --- that guarantees that any memory it allocated will be
    // cleaned up.  The exception to this rule is if the fiber has not started
    // execution yet; in that case, we do not want to switch to it, as it would
    // have to run until the first Indicate to find out that it's been
    // cancelled.  (In the normal case, the execution fiber is suspended    
    // inside Indicate, so when we switch back we will immediately give it
    // WBEM_E_CALL_CANCELLED so that it can clean up and return)
    //

    m_hresCancellationStatus = WBEM_E_CALL_CANCELLED;

    if(m_pExecFiber)
    {
        if(m_bExecFiberRunning)
        {
            _ASSERT(m_pMainFiber == NULL && m_pExecFiber != NULL, 
                    L"Fiber trouble");

            //
            // Make sure the calling thread has a fiber
            //

            m_pMainFiber = pFiber;
            if(m_pMainFiber == NULL)
                return WBEM_E_OUT_OF_MEMORY;

			{
				CAutoReadLock lock(&g_readWriteLock);

				if (m_bUseLock)
				{
	        	    if (!lock.Lock())
     	    	    	return WBEM_E_FAILED;					
				}

				SwitchToFiber(m_pExecFiber);
			}
        }
        
        // 
        // At this point, the executing fiber is dead.  We know, because in the
        // cancelled state we do not switch to the main fiber in Indicate. 
        //

        ReturnFiber(m_pExecFiber);
        m_pExecFiber = NULL;
    }

    return S_OK;
}

STDMETHODIMP CDbIterator::NextBatch(
      DWORD dwNumRequested,
      DWORD dwTimeOutSeconds,
      DWORD dwFlags,
      DWORD dwRequestedHandleType,
      REFIID riid,
      void* pFiber,
      DWORD *pdwNumReturned,
      LPVOID *ppObjects
     )
{
    CInCritSec ics(&m_cs);

    //
    // TEMP CODE: Someone is calling us on an impersonated thread.  Let's catch
    // the, ahem, bastard
    //

    HANDLE hToken;
    BOOL bRes = OpenThreadToken(GetCurrentThread(), TOKEN_READ, TRUE, &hToken);
    if(bRes)
    {
        //_ASSERT(false, L"Called with a thread token");
        ERRORTRACE((LOG_WBEMCORE, "Repository called with a thread token! "
                        "It shall be removed\n"));
        CloseHandle(hToken);
        SetThreadToken(NULL, NULL);
    }

    _ASSERT(SUCCEEDED(m_hresCancellationStatus), L"Next called after Cancel");
    

    m_bExecFiberRunning = true;

    //
    // Wait until it's over or the right number of objects has been received
    //

    if(m_qObjects.GetQueueSize() < dwNumRequested)
    {
        _ASSERT(m_pMainFiber == NULL && m_pExecFiber != NULL, L"Fiber trouble");

        //
        // Make sure the calling thread has a fiber
        //

        m_pMainFiber = pFiber;
        if(m_pMainFiber == NULL)
            return WBEM_E_OUT_OF_MEMORY;

        m_dwNumRequested = dwNumRequested;

        //
        // We need to acquire the read lock for the duration of the continuation
        // of the retrieval
        //

	    {
			CAutoReadLock lock(&g_readWriteLock);

			if (m_bUseLock)
			{
			    if (!lock.Lock())
			    {
                    m_pMainFiber = NULL;			    
			    	return WBEM_E_FAILED;				
			    }
			}
            if (g_bShuttingDown)
            {
                m_pMainFiber = NULL;
                return WBEM_E_SHUTTING_DOWN;
            }

            SwitchToFiber(m_pExecFiber);
        }

        m_pMainFiber = NULL;
    }

    //
    // We have as much as we are going to have!
    //
    
    DWORD dwReqIndex = 0;
    while(dwReqIndex < dwNumRequested)
    {
        if(0 == m_qObjects.GetQueueSize())
        {
            //
            // That's it --- we waited for production, so there are simply no 
            // more objects in the enumeration
            //

            *pdwNumReturned = dwReqIndex;
            return m_hresStatus;
        }

        IWbemClassObject* pObj = m_qObjects.Dequeue();
        CReleaseMe rm1(pObj);
        pObj->QueryInterface(riid, ppObjects + dwReqIndex);

        dwReqIndex++;
    }

    //
    // Got everything
    //

    *pdwNumReturned= dwNumRequested;
    return S_OK;
}

HRESULT CDbIterator::Indicate(long lNumObjects, IWbemClassObject** apObjects)
{
    if(FAILED(m_hresCancellationStatus))
    {
        //
        // Screw-up --- the fiber called back with Indicate even after we 
        // cancelled! Oh well.
        //
        
        _ASSERT(false, L"Execution code ignored cancel return code!");
        return m_hresCancellationStatus;
    }

    //
    // Add the objects received to the array
    //

    for(long i = 0; i < lNumObjects; i++)
    {
        m_qObjects.Enqueue(apObjects[i]);
    }

    //
    // Check if we have compiled enough for the current request and should
    // therefore interrupt the gatherer
    //

    if(m_qObjects.GetQueueSize() >= m_dwNumRequested)
    {
        //
        // Switch us back to the original fiber
        //

        SwitchToFiber(m_pMainFiber);
    }

    return m_hresCancellationStatus;
}

HRESULT CDbIterator::SetStatus(long lFlags, HRESULT hresResult, 
                                    BSTR, IWbemClassObject*)
{
    _ASSERT(m_hresStatus == WBEM_S_FALSE, L"SetStatus called twice!");
    _ASSERT(lFlags == WBEM_STATUS_COMPLETE, L"SetStatus flags invalid");

    m_hresStatus = hresResult;

    //
    // Switch us back to the original thread, we are done
    //

    m_bExecFiberRunning = false;
    SwitchToFiber(m_pMainFiber);

    return WBEM_S_NO_ERROR;
}



    
            


CRepEvent::CRepEvent(DWORD dwType, LPCWSTR wszNamespace, LPCWSTR wszArg1, 
            _IWmiObject* pObj1, _IWmiObject* pObj2)
{
    m_dwType = dwType;
    m_pObj1 = 0;
    m_pObj2 = 0;
    m_wszArg1 = m_wszNamespace = NULL;

    if (wszArg1)
    {
        m_wszArg1 = (WCHAR*)TempAlloc((wcslen(wszArg1)+1)*sizeof(WCHAR));
        if (m_wszArg1 == NULL)
            throw CX_MemoryException();
        wcscpy(m_wszArg1, wszArg1);
    }

    if (wszNamespace)
    {
        m_wszNamespace = (WCHAR*)TempAlloc((wcslen(wszNamespace)+1)*sizeof(WCHAR));
        if (m_wszNamespace == NULL)
            throw CX_MemoryException();
        wcscpy(m_wszNamespace, wszNamespace);
    }
    if (pObj1)
    {
        m_pObj1 = pObj1;
        pObj1->AddRef();
    }
    if (pObj2)
    {
        m_pObj2 = pObj2;
        pObj2->AddRef();
    }
}

CRepEvent::~CRepEvent()
{
    TempFree(m_wszArg1, (wcslen(m_wszArg1)+1)*sizeof(WCHAR));
    TempFree(m_wszNamespace, (wcslen(m_wszNamespace)+1)*sizeof(WCHAR));
    if (m_pObj1)
        m_pObj1->Release();
    if (m_pObj2)
        m_pObj2->Release();
};

HRESULT CEventCollector::SendEvents(_IWmiCoreServices* pCore)
{
	HRESULT hresGlobal = WBEM_S_NO_ERROR;
	for (int i = 0; i != m_apEvents.GetSize(); i++)
	{
		CRepEvent *pEvent = m_apEvents[i];

		_IWmiObject* apObjs[2];
		apObjs[0] = pEvent->m_pObj1;
		apObjs[1] = pEvent->m_pObj2;

		HRESULT hres = pCore->DeliverIntrinsicEvent(
				pEvent->m_wszNamespace, pEvent->m_dwType, NULL, 
                pEvent->m_wszArg1, NULL, (pEvent->m_pObj2?2:1), apObjs);
        if(FAILED(hres))
            hresGlobal = hres;
	}

    return hresGlobal;
}

bool CEventCollector::AddEvent(CRepEvent* pEvent)
{
    EnterCriticalSection(&m_csLock);

    if(m_bNamespaceOnly)
    {
        if(pEvent->m_dwType != WBEM_EVENTTYPE_NamespaceCreation &&
           pEvent->m_dwType != WBEM_EVENTTYPE_NamespaceDeletion &&
           pEvent->m_dwType != WBEM_EVENTTYPE_NamespaceModification)
        {
            delete pEvent;
            LeaveCriticalSection(&m_csLock);
            return true;
        }
    }

    bool bRet = (m_apEvents.Add(pEvent) >= 0);
    LeaveCriticalSection(&m_csLock);
    return bRet;
}

void CEventCollector::DeleteAllEvents()
{
    EnterCriticalSection(&m_csLock);
    m_bNamespaceOnly = false;
    m_apEvents.RemoveAll();
    LeaveCriticalSection(&m_csLock);
}

void CEventCollector::TransferEvents(CEventCollector &aEventsToTransfer)
{
    m_bNamespaceOnly = aEventsToTransfer.m_bNamespaceOnly;

	while(aEventsToTransfer.m_apEvents.GetSize())
	{
		CRepEvent *pEvent = 0;
        aEventsToTransfer.m_apEvents.RemoveAt(0, &pEvent);

        m_apEvents.Add(pEvent);
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\xfiles\btr.cpp ===
//***************************************************************************
//
//  BTR.CPP
//
//  WMI disk-based B-tree implementation for repository index
//
//  raymcc  15-Oct-00    Prepared for Whistler Beta 2 to reduce file count
//
//***************************************************************************

#include <windows.h>
#include <stdio.h>
#include <wbemcomn.h>
#include <reposit.h>
#include <stdlib.h>
#include <math.h>
#include "pagemgr.h"
#include "btr.h"
#include <arena.h>

#define MAX_WORD_VALUE          0xFFFF
#define MAX_TOKENS_PER_KEY      32
#define MAX_FLUSH_INTERVAL      4000

//#define MAX_PAGE_HISTORY        1024

/*

Notes:

 (a) Modify allocators to special case for page-size
 (b) Modify WriteIdxPage to not rewrite if no deltas
 (c) ERROR_PATH_NOT_FOUND if starting enum has no presence; GPF presently
 (d) Do a history of page hits and see if caching would be helpful

*/

//static WORD History[MAX_PAGE_HISTORY] = {0};

LONG g_lAllocs = 0;

//***************************************************************************
//
//  _BtrMemAlloc
//
//***************************************************************************
// ok
LPVOID WINAPI _BtrMemAlloc(
    SIZE_T dwBytes  // number of bytes to allocate
    )
{
    // Lookaside for items of page size, default array size, default
    // string pool size
    g_lAllocs++;
    return HeapAlloc(CWin32DefaultArena::GetArenaHeap(), HEAP_ZERO_MEMORY, dwBytes);
}

//***************************************************************************
//
//  _BtrMemReAlloc
//
//***************************************************************************
// ok
LPVOID WINAPI _BtrMemReAlloc(
    LPVOID pOriginal,
    DWORD dwNewBytes
    )
{
    return HeapReAlloc(CWin32DefaultArena::GetArenaHeap(), HEAP_ZERO_MEMORY, pOriginal, dwNewBytes);
}

//***************************************************************************
//
//  _BtrMemFree
//
//***************************************************************************
// ok
BOOL WINAPI _BtrMemFree(LPVOID pMem)
{
    if (pMem == 0)
        return TRUE;
    g_lAllocs--;
    return HeapFree(CWin32DefaultArena::GetArenaHeap(), 0, pMem);
}




//***************************************************************************
//
//  CBTreeFile::CBTreeFile
//
//***************************************************************************
// ok
CBTreeFile::CBTreeFile()
{
    m_dwPageSize = 0;
    m_dwLogicalRoot = 0;
}

//***************************************************************************
//
//  CBTreeFile::CBTreeFile
//
//***************************************************************************
//  ok
CBTreeFile::~CBTreeFile()
{
}


//***************************************************************************
//
//  CBTreeFile::Shutdown
//
//***************************************************************************
//  ok
DWORD CBTreeFile::Shutdown(DWORD dwShutDownFlags)
{

    m_dwPageSize = 0;
    m_dwLogicalRoot = 0;

	m_pFile->Release();

    return NO_ERROR;
}

//***************************************************************************
//
//  CBTreeFile::WriteAdminPage
//
//  Rewrites the admin page.  There is no need to update the pagesize,
//  version, etc.
//
//***************************************************************************
//  ok
DWORD CBTreeFile::WriteAdminPage()
{
    LPDWORD pPageZero = 0;
    DWORD dwRes = GetPage(0, (LPVOID *) &pPageZero);
    if (dwRes)
        return dwRes;

    pPageZero[OFFSET_LOGICAL_ROOT] = m_dwLogicalRoot;

    dwRes = PutPage(pPageZero, PAGE_TYPE_ADMIN);
    _BtrMemFree(pPageZero);
    return dwRes;
}

//***************************************************************************
//
//  CBTreeFile::SetRootPage
//
//***************************************************************************
//
DWORD CBTreeFile::SetRootPage(DWORD dwNewRoot)
{
    m_dwLogicalRoot = dwNewRoot;
    return WriteAdminPage();
}


//***************************************************************************
//
//  CBTreeFile::Init
//
//  The real "constructor" which opens the file
//
//***************************************************************************
// ok
DWORD CBTreeFile::Init(
    DWORD dwPageSize,
    LPWSTR pszFilename,
	CPageSource* pSource
    )
{
    DWORD dwLastError = 0;

	m_pTransactionManager = pSource;

    m_dwPageSize = dwPageSize;

	long lRes = pSource->GetBTreePageFile(&m_pFile);
    if(lRes != ERROR_SUCCESS)
		return lRes;

    return ReadAdminPage();
}


//***************************************************************************
//
//  CBTreeFile::ReadAdminPage
//
//***************************************************************************
// ok
DWORD CBTreeFile::ReadAdminPage()
{
    LPDWORD pPageZero = 0;
    DWORD dwRes = 0;

    dwRes = GetPage(0, (LPVOID *) &pPageZero);
	if (dwRes == ERROR_FILE_NOT_FOUND)
	{
		//First read of admin page fails so we need to set it up
		dwRes = Setup();
		m_dwLogicalRoot = 0;
	}
    else if (dwRes == ERROR_SUCCESS)
	{
		m_dwLogicalRoot = pPageZero[OFFSET_LOGICAL_ROOT];

		_BtrMemFree(pPageZero);
	}

    return dwRes;
}


//***************************************************************************
//
//  CBTreeFile::Setup
//
//  Sets up the 0th page (Admin page)
//
//***************************************************************************
// ok
DWORD CBTreeFile::Setup()
{
    DWORD dwRes;
	DWORD dwRoot = 0;

    // First two pages, admin & free list root

    LPDWORD pPageZero = (LPDWORD) _BtrMemAlloc(m_dwPageSize);

    if (pPageZero == 0)
    {
        dwRes = ERROR_NOT_ENOUGH_MEMORY;
        goto Exit;
    }

    memset(pPageZero, 0, m_dwPageSize);

    // Map the page

    pPageZero[OFFSET_PAGE_TYPE] = PAGE_TYPE_ADMIN;
    pPageZero[OFFSET_PAGE_ID] = 0;
    pPageZero[OFFSET_NEXT_PAGE] = 0;

    pPageZero[OFFSET_LOGICAL_ROOT] = 0;


	dwRes = m_pFile->NewPage(1, 1, &dwRoot);

    // Write it out
	if (dwRes == ERROR_SUCCESS)
		dwRes = PutPage(pPageZero, PAGE_TYPE_ADMIN);

Exit:
    _BtrMemFree(pPageZero);

    return dwRes;
}


//***************************************************************************
//
//  CBTreeFile::Dump
//
//  Debug helper
//
//***************************************************************************
// ok
void CBTreeFile::Dump(FILE *f)
{
	/*
    SetFilePointer(m_hFile, 0, 0, FILE_BEGIN);
    LPDWORD pPage = (LPDWORD) new BYTE[m_dwPageSize];
    DWORD dwPage = 0;
    DWORD dwTotalKeys = 0;

    fprintf(f, "---BEGIN PAGE SOURCE DUMP---\n");
    fprintf(f, "In memory part:\n");
    fprintf(f, "  m_dwPageSize = %d (0x%X)\n", m_dwPageSize, m_dwPageSize);
    fprintf(f, "  m_hFile = 0x%p\n", m_hFile);
    fprintf(f, "  m_dwNextFreePage = %d\n", m_dwNextFreePage);
    fprintf(f, "  m_dwTotalPages = %d\n", m_dwTotalPages);
    fprintf(f, "  m_dwLogicalRoot = %d\n", m_dwLogicalRoot);
    fprintf(f, "---\n");

    DWORD dwTotalFree = 0;
    DWORD dwOffs = 0;

    while (1)
    {
        DWORD dwRead = 0;
        BOOL bRes = ReadFile(m_hFile, pPage, m_dwPageSize, &dwRead, 0);
        if (dwRead != m_dwPageSize)
            break;

        fprintf(f, "Dump of page %d:\n", dwPage++);
        fprintf(f, "  Page type = 0x%X", pPage[OFFSET_PAGE_TYPE]);

        if (pPage[OFFSET_PAGE_TYPE] == PAGE_TYPE_IMPOSSIBLE)
            fprintf(f, "   PAGE_TYPE_IMPOSSIBLE\n");

        if (pPage[OFFSET_PAGE_TYPE] == PAGE_TYPE_DELETED)
        {
            fprintf(f, "   PAGE_TYPE_DELETED\n");
            fprintf(f, "     <page num check = %d>\n", pPage[1]);
            fprintf(f, "     <next free page = %d>\n", pPage[2]);
            dwTotalFree++;
        }

        if (pPage[OFFSET_PAGE_TYPE] == PAGE_TYPE_ACTIVE)
        {
            fprintf(f, "   PAGE_TYPE_ACTIVE\n");
            fprintf(f, "     <page num check = %d>\n", pPage[1]);

            SIdxKeyTable *pKT = 0;
            DWORD dwKeys = 0;
            DWORD dwRes = SIdxKeyTable::Create(pPage, &pKT);
            if (dwRes == 0)
            {
                pKT->Dump(f, &dwKeys);
                pKT->Release();
                dwTotalKeys += dwKeys;
            }
            else
            {
                fprintf(f,  "<INVALID Page Decode>\n");
            }
        }

        if (pPage[OFFSET_PAGE_TYPE] == PAGE_TYPE_ADMIN)
        {
            fprintf(f, "   PAGE_TYPE_ADMIN\n");
            fprintf(f, "     Page Num           = %d\n", pPage[1]);
            fprintf(f, "     Next Page          = %d\n", pPage[2]);
            fprintf(f, "     Logical Root       = %d\n", pPage[3]);
            fprintf(f, "     Free List Root     = %d\n", pPage[4]);
            fprintf(f, "     Total Pages        = %d\n", pPage[5]);
            fprintf(f, "     Page Size          = %d (0x%X)\n", pPage[6], pPage[6]);
            fprintf(f, "     Impl Version       = 0x%X\n", pPage[7]);
        }
    }

    delete [] pPage;

    fprintf(f, "Total free pages detected by scan = %d\n", dwTotalFree);
    fprintf(f, "Total active keys = %d\n", dwTotalKeys);
    fprintf(f, "---END PAGE DUMP---\n");
	*/
}

//***************************************************************************
//
//  CBTreeFile::GetPage
//
//  Reads an existing page; does not support seeking beyond end-of-file
//
//***************************************************************************
//  ok
DWORD CBTreeFile::GetPage(
    DWORD dwPage,
    LPVOID *pPage
    )
{
    DWORD dwRes;

    if (pPage == 0)
        return ERROR_INVALID_PARAMETER;

    // Allocate some memory

    LPVOID pMem = _BtrMemAlloc(m_dwPageSize);
    if (!pMem)
        return ERROR_NOT_ENOUGH_MEMORY;

    long lRes = m_pFile->GetPage(dwPage, 0, pMem);
    if (lRes != ERROR_SUCCESS)
    {
        _BtrMemFree(pMem);
        return lRes;
    }

    *pPage = pMem;
    return NO_ERROR;
}

//***************************************************************************
//
//  CBTreeFile::PutPage
//
//  Always rewrites; the file extent was grown when the page was allocated
//  with NewPage, so the page already exists and the write should not fail
//
//***************************************************************************
//  ok
DWORD CBTreeFile::PutPage(
    LPVOID pPage,
    DWORD dwType
    )
{
    // Force the page to confess its identity

    DWORD *pdwHeader = LPDWORD(pPage);
    DWORD dwPageId = pdwHeader[OFFSET_PAGE_ID];
    pdwHeader[OFFSET_PAGE_TYPE] = dwType;

    long lRes = m_pFile->PutPage(dwPageId, 0, pPage);
    if(lRes != ERROR_SUCCESS)
        return lRes;

    return NO_ERROR;
}

//***************************************************************************
//
//  CBTreeFile::NewPage
//
//  Allocates a new page, preferring the free list
//
//***************************************************************************
//  ok
DWORD CBTreeFile::NewPage(LPVOID *pRetPage)
{
    DWORD dwRes;

    if (pRetPage == 0)
        return ERROR_INVALID_PARAMETER;
    *pRetPage = 0;

    LPDWORD pNewPage = (LPDWORD) _BtrMemAlloc(m_dwPageSize);
    if (pNewPage == 0)
        return ERROR_NOT_ENOUGH_MEMORY;

	DWORD dwPage = 0;
	dwRes = m_pFile->NewPage(0, 1, &dwPage);
	if (dwRes != ERROR_SUCCESS)
	{
		_BtrMemFree(pNewPage);
		return dwRes;
	}

    memset(pNewPage, 0, m_dwPageSize);
    pNewPage[OFFSET_PAGE_ID] = dwPage;
    *pRetPage = pNewPage;

    return ERROR_SUCCESS;;
}

//***************************************************************************
//
//  CBTreeFile::FreePage
//
//  Called to delete or free a page.  If the last page is the one
//  being freed, then the file is truncated.
//
//***************************************************************************
//  ok
DWORD CBTreeFile::FreePage(
    LPVOID pPage
    )
{
    LPDWORD pCast = LPDWORD(pPage);
    DWORD dwPageId = pCast[OFFSET_PAGE_ID];

	return FreePage(dwPageId);
}

//***************************************************************************
//
//  CBTreeFile::FreePage
//
//***************************************************************************
//
DWORD CBTreeFile::FreePage(
    DWORD dwId
    )
{
	return m_pFile->FreePage(0, dwId);
}

//***************************************************************************
//
//  SIdxKeyTable::GetRequiredPageMemory
//
//  Returns the amount of memory required to store this object in a
//  linear page
//
//***************************************************************************
//  ok
DWORD SIdxKeyTable::GetRequiredPageMemory()
{
    DWORD dwTotal = m_pStrPool->GetRequiredPageMemory();

    // Size of the key lookup table & its sizing DWORD, and
    // add in the child page & user data

    dwTotal += sizeof(DWORD) + sizeof(WORD) * m_dwNumKeys;
    dwTotal += sizeof(DWORD) + sizeof(DWORD) * m_dwNumKeys;     // User data
    dwTotal += sizeof(DWORD) + sizeof(DWORD) * (m_dwNumKeys+1); // Child pages

    // Add in the key encoding table

    dwTotal += sizeof(WORD) + sizeof(WORD) * m_dwKeyCodesUsed;

    // Add in per page overhead
    //
    // Signature, Page Id, Next Page, Parent Page
    dwTotal += sizeof(DWORD) * 4;

    // (NOTE A): Add some safety margin...
    dwTotal += sizeof(DWORD) * 2;

    return dwTotal;
}

//***************************************************************************
//
//  SIdxKeyTable::StealKeyFromSibling
//
//  Transfers a key from the sibling via the parent in a sort of rotation:
//
//          10
//     1  2    12  13 14
//
//  Where <this> is node (1,2) and sibling is (12,13).  A single rotation
//  moves 10 into (1,2) and grabs 12 from the sibling to replace it,
//
//           12
//    1 2 10     13 14
//
//  We repeat this until minimum load of <this> is above const_MinimumLoad.
//
//***************************************************************************
//  ok
DWORD SIdxKeyTable::StealKeyFromSibling(
    SIdxKeyTable *pParent,
    SIdxKeyTable *pSibling
    )
{
    DWORD dwData, dwChild;
    WORD wID;
    LPSTR pszKey = 0;
	DWORD dwRes = 0;

    DWORD dwSiblingId = pSibling->GetPageId();
    DWORD dwThisId = GetPageId();


    for (WORD i = 0; i < WORD(pParent->GetNumKeys()); i++)
    {
        DWORD dwChildA = pParent->GetChildPage(i);
        DWORD dwChildB = pParent->GetChildPage(i+1);

        if (dwChildA == dwThisId && dwChildB == dwSiblingId)
        {
            dwRes = pParent->GetKeyAt(i, &pszKey);
			if (dwRes != 0)
				return dwRes;
            dwData = pParent->GetUserData(i);

            dwRes = FindKey(pszKey, &wID);
			if ((dwRes != 0) && (dwRes != ERROR_NOT_FOUND))
			{
	            _BtrMemFree(pszKey);
				return dwRes;
			}
            dwRes = AddKey(pszKey, wID, dwData);
			if (dwRes != 0)
			{
	            _BtrMemFree(pszKey);
				return dwRes;
			}

            dwRes = pParent->RemoveKey(i);
			if (dwRes != 0)
			{
	            _BtrMemFree(pszKey);
				return dwRes;
			}
            _BtrMemFree(pszKey);

            dwRes = pSibling->GetKeyAt(0, &pszKey);
			if (dwRes != 0)
				return dwRes;
            dwData = pSibling->GetUserData(0);
            dwChild = pSibling->GetChildPage(0);
            dwRes = pSibling->RemoveKey(0);
			if (dwRes != 0)
			{
	            _BtrMemFree(pszKey);
				return dwRes;
			}

            SetChildPage(wID+1, dwChild);

            dwRes = pParent->AddKey(pszKey, i, dwData);
			if (dwRes != 0)
			{
				_BtrMemFree(pszKey);
				return dwRes;
			}
            pParent->SetChildPage(i, dwThisId);
            pParent->SetChildPage(i+1, dwSiblingId);
            _BtrMemFree(pszKey);
            break;
        }
        else if (dwChildA == dwSiblingId && dwChildB == dwThisId)
        {
            dwRes = pParent->GetKeyAt(i, &pszKey);
			if (dwRes != 0)
				return dwRes;
            dwData = pParent->GetUserData(i);

            dwRes = FindKey(pszKey, &wID);
			if ((dwRes != 0) && (dwRes != ERROR_NOT_FOUND))
				return dwRes;
            dwRes = AddKey(pszKey, wID, dwData);
			if (dwRes != 0)
				return dwRes;

            dwRes = pParent->RemoveKey(i);
			if (dwRes != 0)
				return dwRes;
            _BtrMemFree(pszKey);

            WORD wSibId = (WORD) pSibling->GetNumKeys() - 1;
            dwRes = pSibling->GetKeyAt(wSibId, &pszKey);
			if (dwRes != 0)
				return dwRes;
            dwData = pSibling->GetUserData(wSibId);
            dwChild = pSibling->GetChildPage(wSibId+1);
            dwRes = pSibling->RemoveKey(wSibId);
			if (dwRes != 0)
				return dwRes;

            SetChildPage(wID, dwChild);

            dwRes = pParent->AddKey(pszKey, i, dwData);
			if (dwRes != 0)
				return dwRes;
            pParent->SetChildPage(i, dwSiblingId);
            pParent->SetChildPage(i+1, dwThisId);
            _BtrMemFree(pszKey);
            break;
        }
    }

    return NO_ERROR;
}

//***************************************************************************
//
//  SIdxKeyTable::Collapse
//
//  Collapses the contents of a node and its sibling into just one
//  node and adjusts the parent.
//
//  Precondition:  The two siblings can be successfully collapsed
//  into a single node, accomodate a key migrated from the parent
//  and still safely fit into a single node.  Page sizes are not
//  checked here.
//
//***************************************************************************
//  ok
DWORD SIdxKeyTable::Collapse(
    SIdxKeyTable *pParent,
    SIdxKeyTable *pDoomedSibling
    )
{
    WORD wId;
    DWORD dwRes;
    LPSTR pszKey = 0;
    DWORD dwData;
    DWORD dwChild;
    BOOL bExtra = FALSE;

    DWORD dwSiblingId = pDoomedSibling->GetPageId();
    DWORD dwThisId = GetPageId();

    // Locate the node in the parent which points to the two
    // siblings.  Since we don't know which sibling this is,
    // we have to take into account the two possibilites.
    // Is <this> the right side or the left?
    //
    //              10  20  30  40
    //             |   |   |   |  |
    //             x  Sib This x  x
    //
    //        vs.
    //              10  20  30 40
    //             |   |   |  |  |
    //            x  This Sib x  x
    //
    //  We then migrate the key down into the current node
    //  and remove it from the parent.  We steal the first
    //
    // ======================================================

    for (WORD i = 0; i < WORD(pParent->GetNumKeys()); i++)
    {
        DWORD dwChildA = pParent->GetChildPage(i);
        DWORD dwChildB = pParent->GetChildPage(i+1);

        if (dwChildA == dwSiblingId && dwChildB == dwThisId)
        {
            dwRes = pParent->GetKeyAt(i, &pszKey);
			if (dwRes != 0)
				return dwRes;
            dwData = pParent->GetUserData(i);
            dwRes = pParent->RemoveKey(i);
			if (dwRes != 0)
			{
				_BtrMemFree(pszKey);
				return dwRes;
			}
            pParent->SetChildPage(i, dwThisId);
            dwChild = pDoomedSibling->GetLastChildPage();
            dwRes = AddKey(pszKey, 0, dwData);
			if (dwRes != 0)
			{
				_BtrMemFree(pszKey);
				return dwRes;
			}
            SetChildPage(0, dwChild);
            _BtrMemFree(pszKey);
            bExtra = FALSE;
            break;
        }
        else if (dwChildA == dwThisId && dwChildB == dwSiblingId)
        {
            dwRes = pParent->GetKeyAt(i, &pszKey);
			if (dwRes != 0)
				return dwRes;
            dwData = pParent->GetUserData(i);
            dwRes = pParent->RemoveKey(i);
			if (dwRes != 0)
			{
				_BtrMemFree(pszKey);
				return dwRes;
			}
            pParent->SetChildPage(i, dwThisId);
            dwRes = FindKey(pszKey, &wId);
			if ((dwRes != 0) && (dwRes != ERROR_NOT_FOUND))
			{
				_BtrMemFree(pszKey);
				return dwRes;
			}
            dwRes = AddKey(pszKey, wId, dwData);
			if (dwRes != 0)
			{
				_BtrMemFree(pszKey);
				return dwRes;
			}
            _BtrMemFree(pszKey);
            bExtra = TRUE;
            break;
        }
    }

    // Move all info from sibling into the current node.
    // ==================================================

    DWORD dwNumSibKeys = pDoomedSibling->GetNumKeys();

    for (WORD i = 0; i < WORD(dwNumSibKeys); i++)
    {
        LPSTR pKeyStr = 0;
        dwRes = pDoomedSibling->GetKeyAt(i, &pKeyStr);
        if (dwRes)
            return dwRes;

        DWORD dwUserData = pDoomedSibling->GetUserData(i);

        dwRes = FindKey(pKeyStr, &wId);
        if (dwRes != ERROR_NOT_FOUND)
        {
            _BtrMemFree(pKeyStr);
            return ERROR_BAD_FORMAT;
        }

        dwRes = AddKey(pKeyStr, wId, dwUserData);
		if (dwRes != 0)
		{
            _BtrMemFree(pKeyStr);
			return dwRes;
		}

        dwChild = pDoomedSibling->GetChildPage(i);
        SetChildPage(wId, dwChild);
        _BtrMemFree(pKeyStr);
    }

    if (bExtra)
        SetChildPage(WORD(GetNumKeys()), pDoomedSibling->GetLastChildPage());

    pDoomedSibling->ZapPage();

    return NO_ERROR;
}

//***************************************************************************
//
//  SIdxKeyTable::GetRightSiblingOf
//  SIdxKeyTable::GetRightSiblingOf
//
//  Searches the child page pointers and returns the sibling of the
//  specified page.  A return value of zero indicates there was not
//  sibling of the specified value in the direction requested.
//
//***************************************************************************
//
DWORD SIdxKeyTable::GetRightSiblingOf(
    DWORD dwId
    )
{
    for (DWORD i = 0; i < m_dwNumKeys; i++)
    {
        if (m_pdwChildPageMap[i] == dwId)
            return m_pdwChildPageMap[i+1];
    }

    return 0;
}

DWORD SIdxKeyTable::GetLeftSiblingOf(
    DWORD dwId
    )
{
    for (DWORD i = 1; i < m_dwNumKeys+1; i++)
    {
        if (m_pdwChildPageMap[i] == dwId)
            return m_pdwChildPageMap[i-1];
    }

    return 0;

}


//***************************************************************************
//
//  SIdxKeyTable::Redist
//
//  Used when inserting and performing a node split.
//  Precondition:
//  (a) The current node is oversized
//  (b) <pParent> is ready to receive the new median key
//  (c) <pNewSibling> is completely empty and refers to the lesser node (left)
//  (d) All pages have assigned numbers
//
//  We move the nodes from <this> into the <pNewSibling> until both
//  are approximately half full.  The median key is moved into the parent.
//  May fail if <pNewSibling> cannot allocate memory for the new stuff.
//
//  If any errors occur, the entire sequence should be considered as failed
//  and the pages invalid.
//
//***************************************************************************
//
DWORD SIdxKeyTable::Redist(
    SIdxKeyTable *pParent,
    SIdxKeyTable *pNewSibling
    )
{
    DWORD dwRes;
    WORD wID;

    if (pParent == 0 || pNewSibling == 0)
        return ERROR_INVALID_PARAMETER;

    if (m_dwNumKeys < 3)
    {
        return ERROR_INVALID_DATA;
    }

    // Find median key info and put it into parent.

    DWORD dwToTransfer = m_dwNumKeys / 2;

    while (dwToTransfer--)
    {
        // Get 0th key

        LPSTR pStr = 0;
        dwRes = GetKeyAt(0, &pStr);
        if (dwRes)
            return dwRes;

        DWORD dwUserData = GetUserData(0);

        // Move stuff into younger sibling

        dwRes = pNewSibling->FindKey(pStr, &wID);
        if (dwRes != ERROR_NOT_FOUND)
        {
            _BtrMemFree(pStr);
            return dwRes;
        }

        dwRes = pNewSibling->AddKey(pStr, wID, dwUserData);
        _BtrMemFree(pStr);

        if (dwRes)
            return dwRes;

        DWORD dwChildPage = GetChildPage(0);
        pNewSibling->SetChildPage(wID, dwChildPage);
        dwRes = RemoveKey(0);
		if (dwRes)
			return dwRes;
    }

    pNewSibling->SetChildPage(WORD(pNewSibling->GetNumKeys()), GetChildPage(0));

    // Next key is the median key, which migrates to the parent.

    LPSTR pStr = 0;
    dwRes = GetKeyAt(0, &pStr);
    if (dwRes)
        return dwRes;
    DWORD dwUserData = GetUserData(0);

    dwRes = pParent->FindKey(pStr, &wID);
    if (dwRes != ERROR_NOT_FOUND)
    {
        _BtrMemFree(pStr);
        return dwRes;
    }

    dwRes = pParent->AddKey(pStr, wID, dwUserData);
    _BtrMemFree(pStr);

    if (dwRes)
        return dwRes;

    dwRes = RemoveKey(0);
	if (dwRes != 0)
		return dwRes;

    // Patch in the various page pointers

    pParent->SetChildPage(wID, pNewSibling->GetPageId());
    pParent->SetChildPage(wID+1, GetPageId());

    // Everything else is already okay

    return NO_ERROR;
}


//***************************************************************************
//
//  SIdxKeyTable::SIdxKeyTable
//
//***************************************************************************
//  ok
SIdxKeyTable::SIdxKeyTable()
{
    m_dwRefCount = 0;
    m_dwPageId = 0;
    m_dwParentPageId = 0;

    m_dwNumKeys = 0;                // Num keys
    m_pwKeyLookup = 0;              // Offset of key into key-lookup-table
    m_dwKeyLookupTotalSize = 0;     // Elements in array
    m_pwKeyCodes = 0;               // Key encoding table
    m_dwKeyCodesTotalSize = 0;      // Total elements in array
    m_dwKeyCodesUsed = 0;           // Elements used
    m_pStrPool = 0;                 // The pool associated with this key table

    m_pdwUserData = 0;              // Stores user DWORDs for each key
    m_pdwChildPageMap = 0;          // Stores the child page map (num keys + 1)
}

//***************************************************************************
//
//***************************************************************************
//
DWORD SIdxKeyTable::Clone(
    OUT SIdxKeyTable **pRetCopy
    )
{
    SIdxKeyTable *pCopy = new SIdxKeyTable;
    if (!pCopy)
        return ERROR_NOT_ENOUGH_MEMORY;

    pCopy->m_dwRefCount = 1;
    pCopy->m_dwPageId = m_dwPageId;
    pCopy->m_dwParentPageId = m_dwParentPageId;
    pCopy->m_dwNumKeys = m_dwNumKeys;

    pCopy->m_pwKeyLookup = (WORD *)_BtrMemAlloc(sizeof(WORD) * m_dwKeyLookupTotalSize);
    if (pCopy->m_pwKeyLookup == 0)
        return ERROR_NOT_ENOUGH_MEMORY;

    memcpy(pCopy->m_pwKeyLookup, m_pwKeyLookup, sizeof(WORD) * m_dwKeyLookupTotalSize);
    pCopy->m_dwKeyLookupTotalSize = m_dwKeyLookupTotalSize;

    pCopy->m_pdwUserData = (DWORD *)_BtrMemAlloc(sizeof(DWORD) * m_dwKeyLookupTotalSize);
    if (pCopy->m_pdwUserData == 0)
        return ERROR_NOT_ENOUGH_MEMORY;

    memcpy(pCopy->m_pdwUserData, m_pdwUserData, sizeof(DWORD) * m_dwKeyLookupTotalSize);

    pCopy->m_pdwChildPageMap = (DWORD *) _BtrMemAlloc(sizeof(DWORD) * (m_dwKeyLookupTotalSize+1));
    if (pCopy->m_pdwChildPageMap == 0)
        return ERROR_NOT_ENOUGH_MEMORY;

    memcpy(pCopy->m_pdwChildPageMap, m_pdwChildPageMap, sizeof(DWORD) * (m_dwKeyLookupTotalSize+1));

    pCopy->m_dwKeyCodesTotalSize = m_dwKeyCodesTotalSize;
    pCopy->m_pwKeyCodes = (WORD *) _BtrMemAlloc(sizeof(WORD) * m_dwKeyCodesTotalSize);
    if (pCopy->m_pwKeyCodes == 0)
        return ERROR_NOT_ENOUGH_MEMORY;

    memcpy(pCopy->m_pwKeyCodes, m_pwKeyCodes, sizeof(WORD)* m_dwKeyCodesTotalSize);
    pCopy->m_dwKeyCodesUsed = m_dwKeyCodesUsed;

    if (m_pStrPool->Clone(&pCopy->m_pStrPool) != 0)
		return ERROR_NOT_ENOUGH_MEMORY;

    *pRetCopy = pCopy;
    return NO_ERROR;
}

//***************************************************************************
//
//  SIdxKeyTable::~SIdxKeyTable
//
//***************************************************************************
//
SIdxKeyTable::~SIdxKeyTable()
{
    if (m_pwKeyCodes)
        _BtrMemFree(m_pwKeyCodes);
    if (m_pwKeyLookup)
        _BtrMemFree(m_pwKeyLookup);
    if (m_pdwUserData)
        _BtrMemFree(m_pdwUserData);
    if (m_pdwChildPageMap)
        _BtrMemFree(m_pdwChildPageMap);
    if (m_pStrPool)
        delete m_pStrPool;
}

//***************************************************************************
//
//  SIdxKeyTable::GetKeyAt
//
//  Precondition: <wID> is correct
//  The only real case of failure is that the return string cannot be allocated.
//
//  Return values:
//      NO_ERROR
//      ERROR_NOT_ENOUGH_MEMORY
//      ERROR_INVALID_PARAMETER
//
//***************************************************************************
//  tested
DWORD SIdxKeyTable::GetKeyAt(
    WORD wID,
    LPSTR *pszKey
    )
{
    if (wID >= m_dwNumKeys || pszKey == 0)
        return ERROR_INVALID_PARAMETER;

    WORD wStartOffs = m_pwKeyLookup[wID];
    WORD wNumTokens = m_pwKeyCodes[wStartOffs];

    LPSTR Strings[MAX_TOKENS_PER_KEY];
    DWORD dwTotalLengths = 0;

    for (DWORD i = 0; i < DWORD(wNumTokens); i++)
    {
        Strings[i] = m_pStrPool->GetStrById(m_pwKeyCodes[wStartOffs+1+i]);
        dwTotalLengths += strlen(Strings[i]);
    }

    LPSTR pszFinalStr = (LPSTR) _BtrMemAlloc(dwTotalLengths + 1 + wNumTokens);
    if (!pszFinalStr)
        return ERROR_NOT_ENOUGH_MEMORY;
    *pszFinalStr = 0;

    for (DWORD i = 0; i < DWORD(wNumTokens); i++)
    {
        if (i > 0)
            strcat(pszFinalStr, "\\");
        strcat(pszFinalStr, Strings[i]);
    }

    *pszKey = pszFinalStr;
    return NO_ERROR;
}

//***************************************************************************
//
//  SIdxStringPool::FindStr
//
//  Finds a string in the pool, if present and returns the assigned
//  offset.  Uses a binary search.
//
//  Return codes:
//      NO_ERROR            The string was found
//      ERROR_NOT_FOND
//
//***************************************************************************
// tested
DWORD SIdxStringPool::FindStr(
    IN  LPSTR pszSearchKey,
    OUT WORD *pwStringNumber,
    OUT WORD *pwPoolOffset
    )
{
    if (m_dwNumStrings == 0)
    {
        *pwStringNumber = 0;
        return ERROR_NOT_FOUND;
    }

    // Binary search current node for key match.
    // =========================================

    int nPosition = 0;
    int l = 0, u = int(m_dwNumStrings) - 1;

    while (l <= u)
    {
        int m = (l + u) / 2;

        // m is the current key to consider 0...n-1

        LPSTR pszCandidateKeyStr = m_pStringPool+m_pwOffsets[m];
        int nRes = strcmp(pszSearchKey, pszCandidateKeyStr);

        // Decide which way to cut the array in half.
        // ==========================================

        if (nRes < 0)
        {
            u = m - 1;
            nPosition = u + 1;
        }
        else if (nRes > 0)
        {
            l = m + 1;
            nPosition = l;
        }
        else
        {
            // If here, we found the darn thing.  Life is good.
            // Populate the key unit.
            // ================================================
            if (pwStringNumber)
                *pwStringNumber = WORD(m);
            if (pwPoolOffset)
                *pwPoolOffset = m_pwOffsets[m];
            return NO_ERROR;
        }
    }

    // Not found, if here.  We record where the key should have been
    // and tell the user the unhappy news.
    // ==============================================================

    *pwStringNumber = WORD(short(nPosition));  // The key would have been 'here'
    return ERROR_NOT_FOUND;
}

//***************************************************************************
//
//***************************************************************************
//
DWORD SIdxStringPool::Clone(
    SIdxStringPool **pRetCopy
    )
{
    SIdxStringPool *pCopy = new SIdxStringPool;
    if (pCopy == 0)
        return ERROR_NOT_ENOUGH_MEMORY;

    pCopy->m_dwNumStrings = m_dwNumStrings;
    pCopy->m_pwOffsets = (WORD *) _BtrMemAlloc(sizeof(WORD)*m_dwOffsetsSize);
    if (pCopy->m_pwOffsets == 0)
        return ERROR_NOT_ENOUGH_MEMORY;
    memcpy(pCopy->m_pwOffsets, m_pwOffsets, sizeof(WORD)*m_dwOffsetsSize);

    pCopy->m_dwOffsetsSize = m_dwOffsetsSize;

    pCopy->m_pStringPool = (LPSTR) _BtrMemAlloc(m_dwPoolTotalSize);
    if (pCopy->m_pStringPool == 0)
        return ERROR_NOT_ENOUGH_MEMORY;

    memcpy(pCopy->m_pStringPool, m_pStringPool, m_dwPoolTotalSize);
    pCopy->m_dwPoolTotalSize = m_dwPoolTotalSize;

    pCopy->m_dwPoolUsed = m_dwPoolUsed;

    *pRetCopy = pCopy;
    return NO_ERROR;
}

//***************************************************************************
//
//  SIdxStringPool::DeleteStr
//
//  Removes a string from the pool and pool index.
//  Precondition:  <wStringNum> is known to be valid by virtue of a prior
//  call to <FindStr>.
//
//  Return values:
//  NO_ERROR            <Cannot fail if precondition is met>.
//
//***************************************************************************
//
DWORD SIdxStringPool::DeleteStr(
    WORD wStringNum,
    int *pnAdjuster
    )
{
    if (pnAdjuster)
        *pnAdjuster = 0;

    // Find the address of the string to be removed.
    // =============================================

    DWORD dwTargetOffs = m_pwOffsets[wStringNum];
    LPSTR pszDoomed = m_pStringPool+dwTargetOffs;
    DWORD dwDoomedStrLen = strlen(pszDoomed) + 1;

    // Copy all subsequent strings over the top and shorten the heap.
    // Special case if this already the last string
    // ==============================================================
    DWORD dwStrBytesToMove = DWORD(m_pStringPool+m_dwPoolUsed - pszDoomed - dwDoomedStrLen);

    if (dwStrBytesToMove)
        memmove(pszDoomed, pszDoomed+dwDoomedStrLen, dwStrBytesToMove);

    m_dwPoolUsed -= dwDoomedStrLen;

    // Remove this entry from the array.
    // =================================

    DWORD dwArrayElsToMove = m_dwNumStrings - wStringNum - 1;
    if (dwArrayElsToMove)
    {
        memmove(m_pwOffsets+wStringNum, m_pwOffsets+wStringNum+1, dwArrayElsToMove * sizeof(WORD));
        if (pnAdjuster)
            *pnAdjuster = -1;
    }
    m_dwNumStrings--;

    // For all remaining elements, adjust offsets that were affected.
    // ==============================================================
    for (DWORD dwTrace = 0; dwTrace < m_dwNumStrings; dwTrace++)
    {
        if (m_pwOffsets[dwTrace] > dwTargetOffs)
            m_pwOffsets[dwTrace] -= WORD(dwDoomedStrLen);
    }

    // Adjust sizes.
    // =============
    return NO_ERROR;
}


//***************************************************************************
//
//  SIdxStringPool::AddStr
//
//  Adds a string to the pool. Assumes it is known prior to the call that
//  the string isn't present.
//
//  Parameters:
//    pszString           The string to add
//    pwAssignedOffset    Returns the offset code assigned to the string
//  Return values:
//    NO_ERROR
//    ERROR_NOT_ENOUGH_MEMORY
//
//***************************************************************************
// ok
DWORD SIdxStringPool::AddStr(
    LPSTR pszString,
    WORD  wInsertPos,
    int *pnAdjuster
    )
{
    if (pnAdjuster)
        *pnAdjuster = 0;

    // Precondition: String doesn't exist in the table

    // Determine if the pool is too small for another string.
    // If so, extend it.
    // ======================================================

    DWORD dwRequired = strlen(pszString)+1;
    DWORD dwPoolFree = m_dwPoolTotalSize - m_dwPoolUsed;

    if (m_dwPoolUsed + dwRequired - 1 > MAX_WORD_VALUE)
    {
        return ERROR_INSUFFICIENT_BUFFER;
    }

    if (dwRequired > dwPoolFree)
    {
        // Try to grow the pool
        // ====================
        LPVOID pTemp = _BtrMemReAlloc(m_pStringPool, m_dwPoolTotalSize * 2);
        if (!pTemp) {
            return ERROR_NOT_ENOUGH_MEMORY;
        }
        m_dwPoolTotalSize *= 2;
        m_pStringPool = (LPSTR) pTemp;
    }

    // If array too small, reallocate to larger one
    // ============================================

    if (m_dwNumStrings == m_dwOffsetsSize)
    {
        // Realloc; double current size
        LPVOID pTemp = _BtrMemReAlloc(m_pwOffsets, m_dwOffsetsSize * sizeof(WORD) * 2);
        if (!pTemp)
            return ERROR_NOT_ENOUGH_MEMORY;
        m_dwOffsetsSize *= 2;
        m_pwOffsets = PWORD(pTemp);
    }

    // If here, no problem. We have enough space for everything.
    // =========================================================

    LPSTR pszInsertAddr = m_pStringPool+m_dwPoolUsed;
    DWORD dwInsertOffs = m_dwPoolUsed;
    strcpy(pszInsertAddr, pszString);
    m_dwPoolUsed += dwRequired;

    // If here, there is enough room.
    // ==============================

    DWORD dwToBeMoved = m_dwNumStrings - wInsertPos;

    if (dwToBeMoved)
    {
        memmove(&m_pwOffsets[wInsertPos+1], &m_pwOffsets[wInsertPos], sizeof(WORD)*dwToBeMoved);
        if (pnAdjuster)
            *pnAdjuster = 1;
    }

    m_pwOffsets[wInsertPos] = WORD(dwInsertOffs);
    m_dwNumStrings++;

    return NO_ERROR;
}


//***************************************************************************
//
//  ParseIntoTokens
//
//  Parses a slash separated string into separate tokens in preparation
//  for encoding into the string pool.  Call FreeStringArray on the output
//  when no longer needed.
//
//  No more than MAX_TOKEN_PER_KEY are supported.  This means that
//  if backslashes are used, no more than MAX_TOKEN_PER_KEY units can
//  be parsed out.
//
//  Returns:
//    ERROR_INVALID_PARAMETER
//    ERROR_NOT_ENOUGH_MEMORY
//    NO_ERROR
//
//***************************************************************************
//  ok
DWORD ParseIntoTokens(
    IN  LPSTR pszSource,
    OUT DWORD *pdwTokenCount,
    OUT LPSTR **pszTokens
    )
{
    LPSTR Strings[MAX_TOKENS_PER_KEY];
    DWORD dwParseCount = 0, i = 0;
    DWORD dwSourceLen = strlen(pszSource);
    LPSTR *pszRetStr = 0;
    DWORD dwRet;

    if (pszSource == 0 || *pszSource == 0)
        return ERROR_INVALID_PARAMETER;

    LPSTR pszTempBuf = (LPSTR) _BtrMemAlloc(dwSourceLen+1);
    if (!pszTempBuf)
        return ERROR_NOT_ENOUGH_MEMORY;

    LPSTR pszTracer = pszTempBuf;

    for (;;)
    {
        *pszTracer = *pszSource;
        if (*pszTracer == '\\' || *pszTracer == 0)
        {
            *pszTracer = 0;   // Replace with null terminator

            LPSTR pszTemp2 = (LPSTR) _BtrMemAlloc(strlen(pszTempBuf)+1);
            if (pszTemp2 == 0)
            {
                dwRet = ERROR_NOT_ENOUGH_MEMORY;
                goto Error;
            }

            if (dwParseCount == MAX_TOKENS_PER_KEY)
            {
                _BtrMemFree(pszTemp2);
                dwRet = ERROR_INVALID_DATA;
                goto Error;
            }

            strcpy(pszTemp2, pszTempBuf);
            Strings[dwParseCount++] = pszTemp2;
            pszTracer = pszTempBuf;
            pszTracer--;
        }

        if (*pszSource == 0)
            break;

        pszTracer++;
        pszSource++;
    }

    // If here, we at least parsed one string.
    // =======================================
    pszRetStr = (LPSTR *) _BtrMemAlloc(sizeof(LPSTR) * dwParseCount);
    if (pszRetStr == 0)
    {
        dwRet = ERROR_NOT_ENOUGH_MEMORY;
        goto Error;
    }

    memcpy(pszRetStr, Strings, sizeof(LPSTR) * dwParseCount);
    *pdwTokenCount = dwParseCount;
    *pszTokens = pszRetStr;

    _BtrMemFree(pszTempBuf);

    return NO_ERROR;

Error:
    for (i = 0; i < dwParseCount; i++)
        _BtrMemFree(Strings[i]);
    *pdwTokenCount = 0;

    _BtrMemFree(pszTempBuf);

    return dwRet;
}


//***************************************************************************
//
//  FreeTokenArray
//
//  Cleans up the array returned by ParseIntoTokens.
//
//***************************************************************************
//  ok
void FreeTokenArray(
    DWORD dwCount,
    LPSTR *pszStrings
    )
{
    for (DWORD i = 0; i < dwCount; i++)
        _BtrMemFree(pszStrings[i]);
    _BtrMemFree(pszStrings);
}


//***************************************************************************
//
//  SIdxKeyTable::ZapPage
//
//  Empties the page completely of all keys, codes, strings
//
//***************************************************************************
//  ok
void SIdxKeyTable::ZapPage()
{
    m_pStrPool->Empty();
    m_dwKeyCodesUsed = 0;
    m_dwNumKeys = 0;
}

//***************************************************************************
//
//  SIdxKeyTable::MapFromPage
//
//  CAUTION!!!
//  The placement of DWORDs and WORDs is arranged to avoid 64-bit
//  alignment faults.
//
//***************************************************************************
//  ok
DWORD SIdxKeyTable::MapFromPage(LPVOID pSrc)
{
    if (pSrc == 0)
        return ERROR_INVALID_PARAMETER;

    // Header
    //
    // DWORD[0]  Signature
    // DWORD[1]  Page number
    // DWORD[2]  Next Page (always zero)
    // ==================================\

    LPDWORD pDWCast = (LPDWORD) pSrc;

    if (*pDWCast++ != CBTreeFile::PAGE_TYPE_ACTIVE)
    {
        return ERROR_BAD_FORMAT;
    }
    m_dwPageId = *pDWCast++;
    pDWCast++;  // Skip the 'next page' field

    // Key lookup table info
    //
    // DWORD[0]    Parent Page
    // DWORD[1]    Num Keys = n
    // DWORD[n]    User Data
    // DWORD[n+1]  Child Page Map
    // WORD[n]     Key encoding offsets array
    // ======================================

    m_dwParentPageId = *pDWCast++;
    m_dwNumKeys = *pDWCast++;

    // Decide the allocation sizes and build the arrays
    // ================================================

    if (m_dwNumKeys <= const_DefaultArray)
        m_dwKeyLookupTotalSize = const_DefaultArray;
    else
        m_dwKeyLookupTotalSize = m_dwNumKeys;

    m_pdwUserData = (DWORD*) _BtrMemAlloc(m_dwKeyLookupTotalSize * sizeof(DWORD));
    m_pdwChildPageMap = (DWORD*) _BtrMemAlloc((m_dwKeyLookupTotalSize+1) * sizeof(DWORD));
    m_pwKeyLookup = (WORD*) _BtrMemAlloc(m_dwKeyLookupTotalSize * sizeof(WORD));

    if (m_pdwUserData == 0 || m_pdwChildPageMap == 0 || m_pwKeyLookup == 0)
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    // Copy the page info into the arrays
    // ==================================

    memcpy(m_pdwUserData, pDWCast, sizeof(DWORD) * m_dwNumKeys);
    pDWCast += m_dwNumKeys;
    memcpy(m_pdwChildPageMap, pDWCast, sizeof(DWORD) * (m_dwNumKeys+1));
    pDWCast += m_dwNumKeys + 1;
    memcpy(m_pwKeyLookup, pDWCast, sizeof(WORD) * m_dwNumKeys);
    LPWORD pWCast = LPWORD(pDWCast);
    pWCast += m_dwNumKeys;

    // Key encoding table info
    //
    // WORD[0]  Num key codes = n
    // WORD[n]  Key codes
    // ===========================

    m_dwKeyCodesUsed = (DWORD) *pWCast++;

    if (m_dwKeyCodesUsed <= const_DefaultKeyCodeArray)
        m_dwKeyCodesTotalSize = const_DefaultKeyCodeArray;
    else
        m_dwKeyCodesTotalSize = m_dwKeyCodesUsed;

    m_pwKeyCodes = (WORD*) _BtrMemAlloc(m_dwKeyCodesTotalSize * sizeof(WORD));
    if (!m_pwKeyCodes)
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }
    memcpy(m_pwKeyCodes, pWCast, sizeof(WORD) * m_dwKeyCodesUsed);
    pWCast += m_dwKeyCodesUsed;

    // String pool
    //
    // WORD[0] Num strings = n
    // WORD[n] Offsets
    //
    // WORD[0] String pool size = n
    // BYTE[n] String pool
    // =============================

    m_pStrPool = new SIdxStringPool;
    if (!m_pStrPool)
        return ERROR_NOT_ENOUGH_MEMORY;

    m_pStrPool->m_dwNumStrings = (DWORD) *pWCast++;
    if (m_pStrPool->m_dwNumStrings <= const_DefaultArray)
        m_pStrPool->m_dwOffsetsSize = const_DefaultArray;
    else
        m_pStrPool->m_dwOffsetsSize = m_pStrPool->m_dwNumStrings;

    m_pStrPool->m_pwOffsets = (WORD *) _BtrMemAlloc(sizeof(WORD)* m_pStrPool->m_dwOffsetsSize);
    if (m_pStrPool->m_pwOffsets == 0)
        return ERROR_NOT_ENOUGH_MEMORY;

    memcpy(m_pStrPool->m_pwOffsets, pWCast, sizeof(WORD)*m_pStrPool->m_dwNumStrings);
    pWCast += m_pStrPool->m_dwNumStrings;

    // String pool setup
    // =================

    m_pStrPool->m_dwPoolUsed = *pWCast++;
    LPSTR pszCast = LPSTR(pWCast);

    if (m_pStrPool->m_dwPoolUsed <= SIdxStringPool::const_DefaultPoolSize)
        m_pStrPool->m_dwPoolTotalSize = SIdxStringPool::const_DefaultPoolSize;
    else
        m_pStrPool->m_dwPoolTotalSize = m_pStrPool->m_dwPoolUsed;

    m_pStrPool->m_pStringPool = (LPSTR) _BtrMemAlloc(m_pStrPool->m_dwPoolTotalSize);
    if (m_pStrPool->m_pStringPool == 0)
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    memcpy(m_pStrPool->m_pStringPool, pszCast, m_pStrPool->m_dwPoolUsed);

    return NO_ERROR;
}

//***************************************************************************
//
//  SIdxKeyTable::MapToPage
//
//  Copies the info to a linear page.  Precondition: the page must
//  be large enough by validating using a prior test to GetRequiredPageMemory.
//
//***************************************************************************
//  ok
DWORD SIdxKeyTable::MapToPage(LPVOID pDest)
{
    if (pDest == 0)
        return ERROR_INVALID_PARAMETER;

    // Header
    //
    // DWORD[0]  Signature
    // DWORD[1]  Page number
    // DWORD[2]  Next Page (always zero)
    // ==================================\

    LPDWORD pDWCast = (LPDWORD) pDest;
    *pDWCast++ = CBTreeFile::PAGE_TYPE_ACTIVE;
    *pDWCast++ = m_dwPageId;
    *pDWCast++ = 0;  // Unused 'next page' field

    // Key lookup table info
    //
    // DWORD[0]    Parent Page
    // DWORD[1]    Num Keys = n
    // DWORD[n]    User Data
    // DWORD[n+1]  Child Page Map
    // WORD[n]     Key encoding offsets array
    // ======================================

    *pDWCast++ = m_dwParentPageId;
    *pDWCast++ = m_dwNumKeys;

    // Decide the allocation sizes and build the arrays
    // ================================================

    memcpy(pDWCast, m_pdwUserData, sizeof(DWORD) * m_dwNumKeys);
    pDWCast += m_dwNumKeys;
    memcpy(pDWCast, m_pdwChildPageMap, sizeof(DWORD) * (m_dwNumKeys+1));
    pDWCast += m_dwNumKeys + 1;
    memcpy(pDWCast, m_pwKeyLookup, sizeof(WORD) * m_dwNumKeys);
    LPWORD pWCast = LPWORD(pDWCast);
    pWCast += m_dwNumKeys;

    // Key encoding table info
    //
    // WORD[0]  Num key codes = n
    // WORD[n]  Key codes
    // ===========================

    *pWCast++ = WORD(m_dwKeyCodesUsed);
    memcpy(pWCast, m_pwKeyCodes, sizeof(WORD) * m_dwKeyCodesUsed);
    pWCast += m_dwKeyCodesUsed;

    // String pool
    //
    // WORD[0] Num strings = n
    // WORD[n] Offsets
    //
    // WORD[0] String pool size = n
    // BYTE[n] String pool
    // =============================

    *pWCast++ = WORD(m_pStrPool->m_dwNumStrings);
    memcpy(pWCast, m_pStrPool->m_pwOffsets, sizeof(WORD)*m_pStrPool->m_dwNumStrings);
    pWCast += m_pStrPool->m_dwNumStrings;

    *pWCast++ = WORD(m_pStrPool->m_dwPoolUsed);
    LPSTR pszCast = LPSTR(pWCast);
    memcpy(pszCast, m_pStrPool->m_pStringPool, m_pStrPool->m_dwPoolUsed);

    return NO_ERROR;
}

//***************************************************************************
//
//  SIdxKeyTable::Create
//
//  Does a default create
//
//***************************************************************************
//  ok
DWORD SIdxKeyTable::Create(
    DWORD dwPageId,
    OUT SIdxKeyTable **pNewInst
    )
{
    SIdxKeyTable *p = new SIdxKeyTable;
    if (!p)
        return ERROR_NOT_ENOUGH_MEMORY;

    // Set up default string pool, arrays, etc.
    // ========================================

    p->m_dwPageId = dwPageId;
    p->m_dwNumKeys = 0;
    p->m_pwKeyLookup = (WORD*) _BtrMemAlloc(const_DefaultArray * sizeof(WORD));
    p->m_dwKeyLookupTotalSize = const_DefaultArray;
    p->m_pwKeyCodes = (WORD*) _BtrMemAlloc(const_DefaultArray * sizeof(WORD));
    p->m_dwKeyCodesTotalSize = const_DefaultArray;
    p->m_dwKeyCodesUsed = 0;

    p->m_pdwUserData = (DWORD*) _BtrMemAlloc(const_DefaultArray * sizeof(DWORD));
    p->m_pdwChildPageMap = (DWORD*) _BtrMemAlloc((const_DefaultArray+1) * sizeof(DWORD));

    // Set up string pool.
    // ===================
    p->m_pStrPool = new SIdxStringPool;

    p->m_pStrPool->m_pwOffsets = (WORD*) _BtrMemAlloc(const_DefaultArray * sizeof(WORD));
    p->m_pStrPool->m_dwOffsetsSize = const_DefaultArray;

    p->m_pStrPool->m_pStringPool = (LPSTR) _BtrMemAlloc(SIdxStringPool::const_DefaultPoolSize);
    p->m_pStrPool->m_dwPoolTotalSize = SIdxStringPool::const_DefaultPoolSize;

    // Check all pointers.  If any are null, error out.
    // ================================================

    if (
       p->m_pwKeyLookup == NULL ||
       p->m_pwKeyCodes == NULL  ||
       p->m_pdwUserData == NULL ||
       p->m_pdwChildPageMap == NULL ||
       p->m_pStrPool == NULL ||
       p->m_pStrPool->m_pwOffsets == NULL ||
       p->m_pStrPool->m_pStringPool == NULL
       )
    {
        delete p;
        *pNewInst = 0;
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    // Return good object to caller.
    // =============================

    p->AddRef();
    *pNewInst = p;
    return NO_ERROR;
}

//***************************************************************************
//
//  SIdxStringPool::~SIdxStringPool
//
//***************************************************************************
//  ok
SIdxStringPool::~SIdxStringPool()
{
    if (m_pwOffsets)
        _BtrMemFree(m_pwOffsets);
    m_pwOffsets = 0;
    if (m_pStringPool)
        _BtrMemFree(m_pStringPool);           // Pointer to string pool
    m_pStringPool = 0;
}

//***************************************************************************
//
//  SIdxKeyTable::Create
//
//  Does a default create
//
//***************************************************************************
//  ok
DWORD SIdxKeyTable::Create(
    IN  LPVOID pPage,
    OUT SIdxKeyTable **pNewInst
    )
{
    SIdxKeyTable *p = new SIdxKeyTable;
    if (!p)
        return ERROR_NOT_ENOUGH_MEMORY;
    DWORD dwRes = p->MapFromPage(pPage);
    if (dwRes)
    {
        *pNewInst = 0;
        return dwRes;
    }
    p->AddRef();
    *pNewInst = p;
    return NO_ERROR;
}

//***************************************************************************
//
//  SIdxKeyTable::AddRef
//
//***************************************************************************
// ok
DWORD SIdxKeyTable::AddRef()
{
    InterlockedIncrement((LONG *) &m_dwRefCount);
    return m_dwRefCount;
}

//***************************************************************************
//
//  SIdxKeyTable::Release
//
//***************************************************************************
// ok
DWORD SIdxKeyTable::Release()
{
    DWORD dwNewCount = InterlockedDecrement((LONG *) &m_dwRefCount);
    if (0 != dwNewCount)
        return dwNewCount;
    delete this;
    return 0;
}

//***************************************************************************
//
//  SIdxKeyTable::Cleanup
//
//  Does a consistency check of the key encoding table and cleans up the
//  string pool if any strings aren't being referenced.
//
//***************************************************************************
//  ok
DWORD SIdxKeyTable::Cleanup()
{
    // See if all string pool codes are used in key code table.
    // If not, remove the string pool code.
    // =======================================================

    DWORD dwLastId = m_pStrPool->GetLastId();
    BOOL *pCheck = (BOOL*) _BtrMemAlloc(sizeof(BOOL) * dwLastId);
    if (!pCheck)
        return ERROR_NOT_ENOUGH_MEMORY;

    while (1)
    {
        if (m_pStrPool->GetNumStrings() == 0 || m_dwKeyCodesUsed == 0 || m_dwNumKeys == 0)
        {
            ZapPage();
            break;
        }

        dwLastId = m_pStrPool->GetLastId();
        memset(pCheck, 0, sizeof(BOOL)*dwLastId);   // Mark all codes as 'unused'

        // Move through all key codes.  If we delete a key encoding, there
        // may be a code in the string pool not used by the encoding.
        // What we have to do is set the pCheck array to TRUE for each
        // code encountered.  If any have FALSE when we are done, we have
        // an unused code.

        WORD wCurrentSequence = 0;
        for (DWORD i = 0; i < m_dwKeyCodesUsed; i++)
        {
            if (wCurrentSequence == 0)  // Skip the length WORD
            {
                wCurrentSequence = m_pwKeyCodes[i];
                continue;
            }
            else                        // A string pool code
                pCheck[m_pwKeyCodes[i]] = TRUE;
            wCurrentSequence--;
        }

        // Now the pCheck array contains deep within its psyche
        // the knowledge of whether or not all string pool codes
        // were used TRUE for referenced ones, FALSE for those
        // not referenced. Let's look through it and see!

        DWORD dwUsed = 0, dwUnused = 0;

        for (i = 0; i < dwLastId; i++)
        {
            if (pCheck[i] == FALSE)
            {
                dwUnused++;
                // Yikes! A lonely, unused string code.  Let's be merciful
                // and zap it before it knows the difference.
                // =======================================================
                int nAdj = 0;
                m_pStrPool->DeleteStr(WORD(i), &nAdj);
                AdjustKeyCodes(WORD(i), nAdj);
                break;
            }
            else
                dwUsed++;
        }

        if (dwUnused == 0)
            break;
    }

    _BtrMemFree(pCheck);

    return NO_ERROR;
}

//***************************************************************************
//
//  SIdxKeyTable::AdjustKeyCodes
//
//***************************************************************************
//  ok
void SIdxKeyTable::AdjustKeyCodes(
    WORD wID,
    int nAdjustment
    )
{
    // Adjust all key codes starting with wID by the amount of the
    // adjustment, skipping length bytes.
    // =============================================================

    WORD wCurrentSequence = 0;
    for (DWORD i = 0; i < m_dwKeyCodesUsed; i++)
    {
        if (wCurrentSequence == 0)
        {
            wCurrentSequence = m_pwKeyCodes[i];
            continue;
        }
        else
        {
            if (m_pwKeyCodes[i] >= wID)
                m_pwKeyCodes[i] = m_pwKeyCodes[i] + nAdjustment;
        }
        wCurrentSequence--;
    }
}

//***************************************************************************
//
//  SIdxKeyTable::AddKey
//
//  Adds a string to the table at position <wID>.  Assumes FindString
//  was called first to get the correct location.
//
//  Precondition:  <pszStr> is valid, and <wID> is correct.
//
//  Return codes:
//
//  ERROR_OUT_OF_MEMORY
//  NO_ERROR
//  ERROR_INVALID_PARAMETER     // Too many slashes in key
//
//***************************************************************************
//  ok
DWORD SIdxKeyTable::AddKey(
    LPSTR pszStr,
    WORD wKeyID,
    DWORD dwUserData
    )
{
    DWORD dwRes, dwRet;
    LPVOID pTemp = 0;
    LPSTR pszTemp = 0;
    DWORD dwLen, i;
    DWORD dwTokenCount = 0;
    WORD *pwTokenIDs = 0;
    DWORD dwNumNewTokens = 0;
    LPSTR *pszStrings = 0;
    DWORD dwToBeMoved;
    DWORD dwStartingOffset;

    // Set up some temp working arrays.
    // ================================
    if (!pszStr)
        return ERROR_INVALID_PARAMETER;
    dwLen = strlen(pszStr);
    if (dwLen == 0)
        return ERROR_INVALID_PARAMETER;

    pszTemp = (LPSTR) _BtrMemAlloc(dwLen+1);
    if (!pszTemp)
    {
        dwRet = ERROR_NOT_ENOUGH_MEMORY;
        goto Exit;
    }

    // Ensure there is enough room.
    // ============================

    if (m_dwKeyLookupTotalSize == m_dwNumKeys)
    {
        // Expand the array.

        DWORD dwNewSize = m_dwKeyLookupTotalSize * 2;
        pTemp = _BtrMemReAlloc(m_pwKeyLookup, dwNewSize * sizeof(WORD));
        if (!pTemp)
        {
            dwRet = ERROR_NOT_ENOUGH_MEMORY;
            goto Exit;
        }
        m_dwKeyLookupTotalSize = dwNewSize;
        m_pwKeyLookup = PWORD(pTemp);

        // Expand user data.

        pTemp = _BtrMemReAlloc(m_pdwUserData, dwNewSize * sizeof(DWORD));
        if (!pTemp)
        {
            dwRet = ERROR_NOT_ENOUGH_MEMORY;
            goto Exit;
        }
        m_pdwUserData = (DWORD *) pTemp;

        // Expand child page map.

        pTemp = _BtrMemReAlloc(m_pdwChildPageMap, (dwNewSize + 1) * sizeof(DWORD));
        if (!pTemp)
        {
            dwRet = ERROR_NOT_ENOUGH_MEMORY;
            goto Exit;
        }
        m_pdwChildPageMap = (DWORD *) pTemp;
    }

    // Parse the string into backslash separated tokens.
    // =================================================

    dwRes = ParseIntoTokens(pszStr, &dwTokenCount, &pszStrings);
    if (dwRes)
    {
        dwRet = dwRes;
        goto Exit;
    }

    // Allocate an array to hold the IDs of the tokens in the string.
    // ==============================================================

    pwTokenIDs = (WORD *) _BtrMemAlloc(sizeof(WORD) * dwTokenCount);
    if (pwTokenIDs == 0)
    {
        dwRet = ERROR_NOT_ENOUGH_MEMORY;
        goto Exit;
    }

    // Work through the tokens and add them to the pool & key encoding table.
    // =============================================================

    for (i = 0; i < dwTokenCount; i++)
    {
        LPSTR pszTok = pszStrings[i];

        // See if token exists, if not add it.
        // ===================================
        WORD wID = 0;
        dwRes = m_pStrPool->FindStr(pszTok, &wID, 0);

        if (dwRes == NO_ERROR)
        {
            // Found it
            pwTokenIDs[dwNumNewTokens++] = wID;
        }
        else if (dwRes == ERROR_NOT_FOUND)
        {
            int nAdjustment = 0;
            dwRes = m_pStrPool->AddStr(pszTok, wID, &nAdjustment);
            if (dwRes)
            {
                dwRet = dwRes;
                goto Exit;
            }
            // Adjust string IDs because of the addition.
            // All existing ones with the same ID or higher
            // must be adjusted upwards.
            if (nAdjustment)
            {
                AdjustKeyCodes(wID, nAdjustment);
                for (DWORD i2 = 0; i2 < dwNumNewTokens; i2++)
                {
                    if (pwTokenIDs[i2] >= wID)
                        pwTokenIDs[i2] = pwTokenIDs[i2] + nAdjustment;
                }
            }

            // Adjust current tokens to accomodate new
            pwTokenIDs[dwNumNewTokens++] = wID;
        }
        else
        {
            dwRet = dwRes;
            goto Exit;
        }
    }

    // Now we know the encodings.  Add them to the key encoding table.
    // First make sure that there is enough room in the table.
    // ===============================================================

    if (m_dwKeyCodesTotalSize - m_dwKeyCodesUsed < dwNumNewTokens + 1)
    {
        DWORD dwNewSize = m_dwKeyCodesTotalSize * 2 + dwNumNewTokens + 1;
        PWORD pTemp2 = (PWORD) _BtrMemReAlloc(m_pwKeyCodes, dwNewSize * sizeof(WORD));
        if (!pTemp2)
        {
            dwRet = ERROR_NOT_ENOUGH_MEMORY;
            goto Exit;
        }
        m_pwKeyCodes = pTemp2;
        m_dwKeyCodesTotalSize = dwNewSize;
    }

    dwStartingOffset = m_dwKeyCodesUsed;

    m_pwKeyCodes[m_dwKeyCodesUsed++] = (WORD) dwNumNewTokens;  // First WORD is count of tokens

    for (i = 0; i < dwNumNewTokens; i++)                    // Encoded tokens
        m_pwKeyCodes[m_dwKeyCodesUsed++] = pwTokenIDs[i];

    // Now, add in the new key lookup by inserting it into the array.
    // ==============================================================

    dwToBeMoved = m_dwNumKeys - wKeyID;

    if (dwToBeMoved)
    {
        memmove(&m_pwKeyLookup[wKeyID+1], &m_pwKeyLookup[wKeyID], sizeof(WORD)*dwToBeMoved);
        memmove(&m_pdwUserData[wKeyID+1], &m_pdwUserData[wKeyID], sizeof(DWORD)*dwToBeMoved);
        memmove(&m_pdwChildPageMap[wKeyID+1], &m_pdwChildPageMap[wKeyID], (sizeof(DWORD))*(dwToBeMoved+1));
    }

    m_pwKeyLookup[wKeyID] = (WORD) dwStartingOffset;
    m_pdwUserData[wKeyID] = dwUserData;
    m_dwNumKeys++;

    dwRet = NO_ERROR;

    // Cleanup code.
    // =============

Exit:
    if (pszTemp)
        _BtrMemFree(pszTemp);
    FreeTokenArray(dwTokenCount, pszStrings);
    if (pwTokenIDs)
        _BtrMemFree(pwTokenIDs);

    return dwRet;
}

//***************************************************************************
//
//  SIdxKeyTable::RemoveKey
//
//  Precondition: <wID> is the valid target
//
//***************************************************************************
//  ok
DWORD SIdxKeyTable::RemoveKey(
    WORD wID
    )
{
    // Find the key code sequence and remove it.
    // =========================================

    WORD wKeyCodeStart = m_pwKeyLookup[wID];
    DWORD dwToBeMoved = m_dwNumKeys - DWORD(wID) - 1;
    if (dwToBeMoved)
    {
        memmove(&m_pwKeyLookup[wID], &m_pwKeyLookup[wID+1], sizeof(WORD)*dwToBeMoved);
        memmove(&m_pdwUserData[wID], &m_pdwUserData[wID+1], sizeof(DWORD)*dwToBeMoved);
        memmove(&m_pdwChildPageMap[wID], &m_pdwChildPageMap[wID+1], sizeof(DWORD)*(dwToBeMoved+1));
    }
    m_dwNumKeys--;

    // Zap the key encoding table to remove references to this key.
    // ============================================================

    WORD wCount = m_pwKeyCodes[wKeyCodeStart]+1;
    dwToBeMoved = m_dwKeyCodesUsed - (wKeyCodeStart + wCount);
    if (dwToBeMoved)
        memmove(&m_pwKeyCodes[wKeyCodeStart], &m_pwKeyCodes[wKeyCodeStart + wCount], sizeof(WORD)*dwToBeMoved);
    m_dwKeyCodesUsed -= wCount;

    // Adjust all zapped key codes referenced by key lookup table.
    // ===========================================================
    for (DWORD i = 0; i < m_dwNumKeys; i++)
    {
        if (m_pwKeyLookup[i] >= wKeyCodeStart)
            m_pwKeyLookup[i] -= wCount;
    }

    // Now check the string pool & key encoding table for
    // unreferenced strings thanks to the above tricks
    // and clean up the mess left behind!!
    // ==================================================

    return Cleanup();
}


//***************************************************************************
//
//  Compares the literal string in <pszSearchKey> against the encoded
//  string at <nID>.  Returns the same value as strcmp().
//
//  This is done by decoding the compressed string, token by token, and
//  comparing each character to that in the search string.
//
//***************************************************************************
//  ok
int SIdxKeyTable::KeyStrCompare(
    LPSTR pszSearchKey,
    WORD wID
    )
{
    LPSTR pszTrace = pszSearchKey;
    WORD dwEncodingOffs = m_pwKeyLookup[wID];
    WORD wNumTokens = m_pwKeyCodes[dwEncodingOffs];
    WORD wStrId = m_pwKeyCodes[++dwEncodingOffs];
    LPSTR pszDecoded = m_pStrPool->GetStrById(wStrId);
    wNumTokens--;
    int nRes;

    while (1)
    {
        int nTraceChar = *pszTrace++;
        int nCodedChar = *pszDecoded++;
        if (nCodedChar == 0 && wNumTokens)
        {
            pszDecoded = m_pStrPool->GetStrById(m_pwKeyCodes[++dwEncodingOffs]);
            wNumTokens--;
            nCodedChar = '\\';
        }
        nRes = nTraceChar - nCodedChar;
        if (nRes || (nTraceChar == 0 && nCodedChar == 0))
            return nRes;
    }

    // Identical strings
    return 0;
}


//***************************************************************************
//
//  SIdxKeyTable::FindKey
//
//  Finds the key in the key table, if present.  If not, returns
//  ERROR_NOT_FOUND and <pID> set to the point where it would be if
//  later inserted.
//
//  Return values:
//      ERROR_NOT_FOUND
//      NO_ERROR
//
//***************************************************************************
// ready for test
DWORD SIdxKeyTable::FindKey(
    LPSTR pszSearchKey,
    WORD *pID
    )
{
    if (pszSearchKey == 0 || *pszSearchKey == 0 || pID == 0)
        return ERROR_INVALID_PARAMETER;

    // Binary search the key table.
    // ============================

    if (m_dwNumKeys == 0)
    {
        *pID = 0;
        return ERROR_NOT_FOUND;
    }

    int nPosition = 0;
    int l = 0, u = int(m_dwNumKeys) - 1;

    while (l <= u)
    {
        int m = (l + u) / 2;
        int nRes;

        // m is the current key to consider 0...n-1

        nRes = KeyStrCompare(pszSearchKey, WORD(m));

        // Decide which way to cut the array in half.
        // ==========================================

        if (nRes < 0)
        {
            u = m - 1;
            nPosition = u + 1;
        }
        else if (nRes > 0)
        {
            l = m + 1;
            nPosition = l;
        }
        else
        {
            // If here, we found the darn thing.  Life is good.
            // Populate the key unit.
            // ================================================

            *pID = WORD(m);
            return NO_ERROR;
        }
    }


    // Not found, if here.  We record where the key should have been
    // and tell the user the unhappy news.
    // ==============================================================

    *pID = WORD(nPosition);  // The key would have been 'here'
    return ERROR_NOT_FOUND;
}

//***************************************************************************
//
//***************************************************************************
// untested
DWORD SIdxKeyTable::Dump(FILE *f, DWORD *pdwKeys)
{
    fprintf(f, "\t|---Begin Key Table Dump---\n");

    fprintf(f, "\t| m_dwPageId              = %d (0x%X)\n", m_dwPageId, m_dwPageId);
    fprintf(f, "\t| m_dwParentPageId        = %d\n", m_dwParentPageId);
    fprintf(f, "\t| m_dwNumKeys             = %d\n", m_dwNumKeys);
    fprintf(f, "\t| m_pwKeyLookup           = 0x%p\n", m_pwKeyLookup);
    fprintf(f, "\t| m_dwKeyLookupTotalSize  = %d\n", m_dwKeyLookupTotalSize);
    fprintf(f, "\t| m_pwKeyCodes            = 0x%p\n", m_pwKeyCodes);
    fprintf(f, "\t| m_dwKeyCodesTotalSize   = %d\n", m_dwKeyCodesTotalSize);
    fprintf(f, "\t| m_dwKeyCodesUsed        = %d\n", m_dwKeyCodesUsed);
    fprintf(f, "\t| Required Page Memory    = %d\n", GetRequiredPageMemory());

    fprintf(f, "\t| --Key Lookup Table\n");

    if (pdwKeys)
        *pdwKeys = m_dwNumKeys;

    for (DWORD i = 0; i < m_dwNumKeys; i++)
    {
        fprintf(f, "\t|  *  Left Child Page ------------------------> %d\n", m_pdwChildPageMap[i]);
        fprintf(f, "\t| KeyID[%d] = offset %d\n", i, m_pwKeyLookup[i]);
        fprintf(f, "\t|   User Data=%d\n", m_pdwUserData[i]);

        WORD wKeyEncodingOffset = m_pwKeyLookup[i];
        WORD wEncodingUnits = m_pwKeyCodes[wKeyEncodingOffset];

        int nPass = 0;
        fprintf(f, "\t  | Key=");

        for (DWORD i2 = 0; i2 < DWORD(wEncodingUnits); i2++)
        {
            WORD wCode = m_pwKeyCodes[wKeyEncodingOffset + 1 + i2];
            if (nPass)
                fprintf(f, "\\");
            fprintf(f,   "%s", m_pStrPool->GetStrById(wCode));
            nPass++;
        }

        fprintf(f, "\n");
        fprintf(f, "\t|  Num encoding units = %d\n", wEncodingUnits);

        for (DWORD i2 = 0; i2 < DWORD(wEncodingUnits); i2++)
        {
            WORD wCode = m_pwKeyCodes[wKeyEncodingOffset + 1 + i2];
            fprintf(f,   "\t  | KeyCode = %d\n", wCode);
        }
    }

    fprintf(f, "\t|   * Rightmost child page -------------------> %d\n", m_pdwChildPageMap[i]);
    fprintf(f, "\t|---\n");

#ifdef EXTENDED_STRING_TABLE_DUMP
    fprintf(f, "\t|---Key Encoding Table\n");

    WORD wCurrentSequence = 0;
    for (i = 0; i < m_dwKeyCodesUsed; i++)
    {
        if (wCurrentSequence == 0)
        {
            wCurrentSequence = m_pwKeyCodes[i];
            fprintf(f, "\t| KeyCode[%d] = %d <count>\n", i, m_pwKeyCodes[i]);
            continue;
        }
        else
            fprintf(f, "\t| KeyCode[%d] = %d <%s>\n", i, m_pwKeyCodes[i],
                m_pStrPool->GetStrById(m_pwKeyCodes[i]));
        wCurrentSequence--;
    }

    fprintf(f, "\t|---End Key Encoding Table---\n");
    m_pStrPool->Dump(f);
#endif
    return 0;
}



//***************************************************************************
//
//  SIdxStringPool::Dump
//
//  Dumps the string pool
//
//***************************************************************************
// tested
DWORD SIdxStringPool::Dump(FILE *f)
{
    try
    {
    fprintf(f, "\t\t|| ---String Pool Dump---\n");
    fprintf(f, "\t\t|| m_dwNumStrings    = %d\n", m_dwNumStrings);
    fprintf(f, "\t\t|| m_pwOffsets       = 0x%p\n", m_pwOffsets);
    fprintf(f, "\t\t|| m_dwOffsetsSize   = %d\n",  m_dwOffsetsSize);
    fprintf(f, "\t\t|| m_pStringPool     = 0x%p\n", m_pStringPool);
    fprintf(f, "\t\t|| m_dwPoolTotalSize = %d\n", m_dwPoolTotalSize);
    fprintf(f, "\t\t|| m_dwPoolUsed      = %d\n", m_dwPoolUsed);

    fprintf(f, "\t\t|| --Contents of offsets array--\n");

    for (DWORD ix = 0; ix < m_dwNumStrings; ix++)
    {
        fprintf(f, "\t\t|| String[%d] = offset %d  Value=<%s>\n",
            ix, m_pwOffsets[ix], m_pStringPool+m_pwOffsets[ix]);
    }

#ifdef EXTENDED_STRING_TABLE_DUMP
    fprintf(f, "\t\t|| --String table--\n");

    for (ix = 0; ix < m_dwPoolTotalSize; ix += 20)
    {
        fprintf(f, "\t\t || %4d ", ix);

        for (int nSubcount = 0; nSubcount < 20; nSubcount++)
        {
            if (nSubcount + ix >= m_dwPoolTotalSize)
                continue;

            char c = m_pStringPool[ix+nSubcount];
            fprintf(f, "%02x ", c);
        }

        for (int nSubcount = 0; nSubcount < 20; nSubcount++)
        {
            if (nSubcount + ix >= m_dwPoolTotalSize)
                continue;

            char c = m_pStringPool[ix+nSubcount];
            if (c < 32)
            {
                c = '.';
            }
            fprintf(f, "%c ", c);
        }

        fprintf(f, "\n");
    }
#endif

    fprintf(f, "\t\t|| ---End of String Pool Dump\n");
    }
    catch(...)
    {
        printf("Exception during dump\n");
    }
    return 0;
}


//***************************************************************************
//
//  CBTree::Init
//
//***************************************************************************
//
DWORD CBTree::Init(
    CBTreeFile *pSrc
    )
{
    DWORD dwRes;

    if (pSrc == 0)
        return ERROR_INVALID_PARAMETER;

    // Read the logical root page, if any.  If the index is just
    // being created, create the root index page.

    m_pSrc = pSrc;
    m_pRoot = 0;

    DWORD dwRoot = m_pSrc->GetRootPage();
    if (dwRoot == 0)
    {
        LPDWORD pNewPage = 0;

        dwRes = m_pSrc->NewPage((LPVOID *) &pNewPage);
        if (dwRes)
            return dwRes;

        DWORD dwPageNum = pNewPage[CBTreeFile::OFFSET_PAGE_ID];
        _BtrMemFree(pNewPage);
        dwRes = SIdxKeyTable::Create(dwPageNum, &m_pRoot);
        if (dwRes)
            return dwRes;

        dwRes = m_pSrc->SetRootPage(dwPageNum);
		if (dwRes)
			return dwRes;
        dwRes = WriteIdxPage(m_pRoot);
		if (dwRes)
			return dwRes;
    }
    else
    {
        // Retrieve existing root
        LPVOID pPage = 0;
        dwRes = m_pSrc->GetPage(dwRoot, &pPage);
        if (dwRes)
            return dwRes;

        dwRes = SIdxKeyTable::Create(pPage, &m_pRoot);
        _BtrMemFree(pPage);
        if (dwRes)
            return dwRes;
    }

    return dwRes;
}

//***************************************************************************
//
//  CBTree::CBTree
//
//***************************************************************************
//
CBTree::CBTree()
{
    m_pSrc = 0;
    m_pRoot = 0;
    m_lGeneration = 0;
}

//***************************************************************************
//
//  CBTree::~CBTree
//
//***************************************************************************
//
CBTree::~CBTree()
{
    if (m_pSrc || m_pRoot)
    {
        Shutdown(WMIDB_SHUTDOWN_NET_STOP);
    }
}

//***************************************************************************
//
//  CBTree::Shutdown
//
//***************************************************************************
//
DWORD CBTree::Shutdown(DWORD dwShutDownFlags)
{
    if (m_pRoot)
    {
        m_pRoot->Release();
        m_pRoot = 0;
    }

    return ERROR_SUCCESS;
}

//***************************************************************************
//
//  CBTree::InsertKey
//
//  Inserts the key+data into the tree.  Most of the work is done
//  in InsertPhase2().
//
//***************************************************************************
//   ok

DWORD CBTree::InsertKey(
    IN LPSTR pszKey,
    DWORD dwValue
    )
{
    DWORD dwRes;
	if (m_pRoot == NULL)
	{
		dwRes = InvalidateCache();
		if (dwRes != ERROR_SUCCESS)
			return dwRes;
	}
    WORD wID;
    SIdxKeyTable *pIdx = 0;
    LONG  StackPtr = -1;
    DWORD *Stack = new DWORD[CBTreeIterator::const_MaxStack];
	if (Stack == NULL)
		return ERROR_NOT_ENOUGH_MEMORY;
	std::auto_ptr <DWORD> _autodelete(Stack);

    if (pszKey == 0 || *pszKey == 0)
        return ERROR_INVALID_PARAMETER;

    dwRes = Search(pszKey, &pIdx, &wID, Stack, StackPtr);
    if (dwRes == 0)
    {
        // Ooops.  Aleady exists.  We can't insert it.
        // ===========================================
        pIdx->Release();
        return ERROR_ALREADY_EXISTS;
    }

    if (dwRes != ERROR_NOT_FOUND)
        return dwRes;

    // If here, we can indeed add it.
    // ==============================

    dwRes = InsertPhase2(pIdx, wID, pszKey, dwValue, Stack, StackPtr);
    pIdx->Release();

    return dwRes;
}

//***************************************************************************
//
//  CBTree::ComputeLoad
//
//***************************************************************************
//
DWORD CBTree::ComputeLoad(
    SIdxKeyTable *pKT
    )
{
    DWORD  dwMem = pKT->GetRequiredPageMemory();
    DWORD  dwLoad = dwMem * 100 / m_pSrc->GetPageSize();
    return dwLoad;
}

//***************************************************************************
//
//  CBTree::Search
//
//  The actual search occurs here.  Descends through the page mechanism.
//
//  Returns:
//  NO_ERROR    <pPage> is assigned, and <pwID> points to the key.
//
//  ERROR_NOT_FOUND <pPage> is assigned to where the insert should occur,
//                  at <pwID> in that page.
//
//  Other errors don't assign the OUT parameters.
//
//  Note: caller must release <pRetIdx> using Release() when it is returned
//  whether with an error code or not.
//
//***************************************************************************
//  ok
DWORD CBTree::Search(
    IN  LPSTR pszKey,
    OUT SIdxKeyTable **pRetIdx,
    OUT WORD *pwID,
    DWORD Stack[],
    LONG &StackPtr
    )
{
    DWORD dwRes, dwChildPage, dwPage;

    if (pszKey == 0 || *pszKey == 0 || pwID == 0 || pRetIdx == 0)
        return ERROR_INVALID_PARAMETER;
    *pRetIdx = 0;

    SIdxKeyTable *pIdx = m_pRoot;
    pIdx->AddRef();
    Stack[++StackPtr] = 0;

    while (1)
    {
        dwRes = pIdx->FindKey(pszKey, pwID);
        if (dwRes == 0)
        {
            // Found it

            *pRetIdx = pIdx;
            return NO_ERROR;
        }
		else if (dwRes != ERROR_NOT_FOUND)
			return dwRes;

        // Otherwise, we have to try to descend to a child page.
        // =====================================================
        dwPage = pIdx->GetPageId();
        dwChildPage = pIdx->GetChildPage(*pwID);
        if (dwChildPage == 0)
            break;

        pIdx->Release();
        pIdx = 0;
        Stack[++StackPtr] = dwPage;

        dwRes = ReadIdxPage(dwChildPage, &pIdx);
        if (dwRes)
            return dwRes;
    }

    *pRetIdx = pIdx;

    return ERROR_NOT_FOUND;
}

//***************************************************************************
//
//  CBTree::InsertPhase2
//
//  On entry, assumes that we have identified the page into which
//  the insert must physically occur.   This does the split + migrate
//  logical to keep the tree in balance.
//
//  Algorithm:  Add key to page.  If it does not overflow, we are done.
//  If overflow occurs, allocate a new sibling page which will acquire
//  half the keys from the current page.   This sibling will be treated
//  as lexically smaller in all cases.  The median key is migrated
//  up to the parent with pointers to both the new sibing page and
//  the current page.
//  The parent may also overflow.  If so, the algorithm repeats.
//  If an overflow occurs and there is no parent node (we are at the root)
//  a new root node is allocated and the median key migrated into it.
//
//***************************************************************************
// ok
DWORD CBTree::InsertPhase2(
    SIdxKeyTable *pCurrent,
    WORD wID,
    LPSTR pszKey,
    DWORD dwValue,
    DWORD Stack[],
    LONG &StackPtr
    )
{
    DWORD dwRes;

    // If non-NULL, used for a primary insert.
    // If NULL, skip this, under the assumption the
    // node is already up-to-date and merely requires
    // the up-recursive split & migrate treatment.
    // ==============================================

    if (pszKey)
    {
        dwRes = pCurrent->AddKey(pszKey, wID, dwValue);
        if (dwRes)
            return dwRes;    // Failed
    }

    pCurrent->AddRef();                       // Makes following loop consistent
    SIdxKeyTable *pSibling = 0;
    SIdxKeyTable *pParent = 0;

    // The class B-tree split+migration loop.
    // ======================================

    for (;;)
    {
        // Check the current node where we added the key.
        // If it isn't too big, we're done.
        // ==============================================

        dwRes = pCurrent->GetRequiredPageMemory();
        if (dwRes <= m_pSrc->GetPageSize())
        {
            dwRes = WriteIdxPage(pCurrent);
            break;
        }

        // If here, it ain't gonna fit.  We have to split the page.
        // Allocate a new page (Sibling) and get the parent page, which
        // will receive the median key.
        // ============================================================

        DWORD dwParent = Stack[StackPtr--];
        if (dwParent == 0)
        {
            // Allocate a new page to become the parent.
            LPDWORD pParentPg = 0;
            dwRes = m_pSrc->NewPage((LPVOID *) &pParentPg);
            if (dwRes)
                break;

            DWORD dwNewParent = pParentPg[CBTreeFile::OFFSET_PAGE_ID];
            _BtrMemFree(pParentPg);

            dwRes = SIdxKeyTable::Create(dwNewParent, &pParent);
            if (dwRes)
                break;
            dwRes = m_pSrc->SetRootPage(dwNewParent);
            if (dwRes)
                break;

            m_pRoot->Release();    // Replace old root
            m_pRoot = pParent;
            m_pRoot->AddRef();
        }
        else
        {
            if (dwParent == m_pRoot->GetPageId())
            {
                pParent = m_pRoot;
                pParent->AddRef();
            }
            else
            {
                dwRes = ReadIdxPage(dwParent, &pParent);
                if (dwRes)
                    break;
            }
        }

        // Allocate a new sibling in any case to hold half the keys
        // ========================================================

        LPDWORD pSibPg = 0;
        dwRes = m_pSrc->NewPage((LPVOID *) &pSibPg);
        if (dwRes)
            break;

        DWORD dwNewSib = pSibPg[CBTreeFile::OFFSET_PAGE_ID];
        _BtrMemFree(pSibPg);

        dwRes = SIdxKeyTable::Create(dwNewSib, &pSibling);
        if (dwRes)
            break;

        dwRes = pCurrent->Redist(pParent, pSibling);
        if (dwRes)
            break;

        dwRes = WriteIdxPage(pCurrent);
		if (dwRes)
			break;
        dwRes = WriteIdxPage(pSibling);
		if (dwRes)
			break;

        pCurrent->Release();
        pCurrent = 0;
        pSibling->Release();
        pSibling = 0;

        if (dwRes)
            break;

        pCurrent = pParent;
        pParent = 0;
    }

    ReleaseIfNotNULL(pParent);
    ReleaseIfNotNULL(pCurrent);
    ReleaseIfNotNULL(pSibling);

    return dwRes;
}


//***************************************************************************
//
//  CBTree::WriteIdxPage
//
//  Writes the object to the physical page it is assigned to.
//  If the page ID is zero, then it is considered invalid.  Further,
//  while is it correct to precheck the page size, this function does
//  validate with regard to sizes, etc.
//
//***************************************************************************
//
DWORD CBTree::WriteIdxPage(
    SIdxKeyTable *pIdx
    )
{
    DWORD dwRes;
    DWORD dwPageSize = m_pSrc->GetPageSize();
    DWORD dwMem = pIdx->GetRequiredPageMemory();
    if (dwMem > dwPageSize)
        return ERROR_INVALID_PARAMETER;

    LPVOID pMem = _BtrMemAlloc(dwPageSize);
    if (pMem == 0)
        return ERROR_NOT_ENOUGH_MEMORY;

    dwRes =  pIdx->MapToPage(pMem);
    if (dwRes)
    {
        _BtrMemFree(pMem);
        return dwRes;
    }

    dwRes = m_pSrc->PutPage(pMem, CBTreeFile::PAGE_TYPE_ACTIVE);
    _BtrMemFree(pMem);
	if (dwRes)
		return dwRes;

    InterlockedIncrement(&m_lGeneration);

    // Check for a root update.
    // ========================

    if (m_pRoot != pIdx && m_pRoot->GetPageId() == pIdx->GetPageId())
    {
        m_pRoot->Release();
        m_pRoot = pIdx;
        m_pRoot->AddRef();

        if (m_pSrc->GetRootPage() != m_pRoot->GetPageId())
           dwRes = m_pSrc->SetRootPage(m_pRoot->GetPageId());
    }

    return dwRes;
}

//***************************************************************************
//
//  CBTree::ReadIdxPage
//
//***************************************************************************
//
DWORD CBTree::ReadIdxPage(
    DWORD dwPage,
    SIdxKeyTable **pIdx
    )
{
    DWORD dwRes;
    LPVOID pPage = 0;
    SIdxKeyTable *p = 0;
    if (pIdx == 0)
        return ERROR_INVALID_PARAMETER;
    *pIdx = 0;

//    if (dwPage < MAX_PAGE_HISTORY)      // May remove if studies show no caching possible
//        ++History[dwPage];

    dwRes = m_pSrc->GetPage(dwPage, &pPage);
    if (dwRes)
        return dwRes;

    dwRes = SIdxKeyTable::Create(pPage, &p);
    if (dwRes)
    {
        _BtrMemFree(pPage);
        return dwRes;
    }

    _BtrMemFree(pPage);
    if (dwRes)
        return dwRes;

    *pIdx = p;
    return dwRes;
}

//***************************************************************************
//
//  CBTree::FindKey
//
//  Does a simple search of a key, returning the user data, if requested.
//
//  Typical Return values
//      NO_ERROR
//      ERROR_NOT_FOUND
//
//***************************************************************************
//  ok

DWORD CBTree::FindKey(
    IN LPSTR pszKey,
    DWORD *pdwData
    )
{
    DWORD dwRes;
	if (m_pRoot == NULL)
	{
		dwRes = InvalidateCache();
		if (dwRes != ERROR_SUCCESS)
			return dwRes;
	}
    WORD wID;
    SIdxKeyTable *pIdx = 0;
    LONG  StackPtr = -1;
    DWORD *Stack = new DWORD[CBTreeIterator::const_MaxStack];
	if (Stack == NULL)
		return ERROR_NOT_ENOUGH_MEMORY;
	CVectorDeleteMe<DWORD> vdm(Stack);

    if (pszKey == 0 || *pszKey == 0)
        return ERROR_INVALID_PARAMETER;

    // Search high and low, hoping against hope...
    // ===========================================

    dwRes = Search(pszKey, &pIdx, &wID, Stack, StackPtr);
    if (dwRes == 0 && pdwData)
    {
        *pdwData = pIdx->GetUserData(wID);
    }

    // If here, we can indeed add it.
    // ==============================

    ReleaseIfNotNULL(pIdx);
    return dwRes;
}


//***************************************************************************
//
//  CBTree::DeleteKey
//
//***************************************************************************
//
DWORD CBTree::DeleteKey(
    IN LPSTR pszKey
    )
{
    DWORD dwRes;
	if (m_pRoot == NULL)
	{
		dwRes = InvalidateCache();
		if (dwRes != ERROR_SUCCESS)
			return dwRes;
	}
    LONG  StackPtr = -1;
    DWORD *Stack = new DWORD[CBTreeIterator::const_MaxStack];
	if (Stack == NULL)
		return ERROR_NOT_ENOUGH_MEMORY;
	CVectorDeleteMe<DWORD> vdm(Stack);

    SIdxKeyTable *pIdx = 0;
    WORD wId;
    DWORD dwLoad;

    // Find it
    // =======
    dwRes = Search(pszKey, &pIdx, &wId, Stack, StackPtr);
    if (dwRes)
        return dwRes;

    // Delete key from from page
    // ==========================

    if (pIdx->IsLeaf())
    {
        // A leaf node.  Remove the key.
        // =============================
        dwRes = pIdx->RemoveKey(wId);
		if (dwRes)
			return dwRes;

        // Now, check the load and see if it has dropped below 30%.
        // Of course, if we are at the root node and it is a leaf,
        // we have to pretty much let it go as is...
        // ========================================================
        dwLoad = ComputeLoad(pIdx);
        if (dwLoad > const_MinimumLoad ||
            pIdx->GetPageId() == m_pRoot->GetPageId())
        {
            dwRes = WriteIdxPage(pIdx);
            pIdx->Release();
            return dwRes;
        }
    }
    else
    {
        // An internal node, so we have to find the successor.
        // Since this call may alter the shape of the tree quite
        // a bit (the successor may overflow the affected node),
        // we have to relocate the successor.
        // ====================================================
        LPSTR pszSuccessor = 0;
        BOOL bUnderflow = FALSE;
        dwRes = ReplaceBySuccessor(pIdx, wId, &pszSuccessor, &bUnderflow, Stack, StackPtr);
        if (dwRes)
            return dwRes;

        dwRes = InsertPhase2(pIdx, 0, 0, 0, Stack, StackPtr);
        if (dwRes)
            return dwRes;

        pIdx->Release();
        pIdx = 0;
        StackPtr = -1;

        if (bUnderflow == FALSE)
        {
            _BtrMemFree(pszSuccessor);
            return NO_ERROR;
        }

        // If here, the node we extracted the successor from was reduced
        // to poverty and underflowed.  We have to find it again and
        // execute the underflow repair loop.
        // =============================================================

        dwRes = Search(pszSuccessor, &pIdx, &wId, Stack, StackPtr);
        _BtrMemFree(pszSuccessor);
        if (dwRes)
            return dwRes;

        SIdxKeyTable *pSuccessor = 0;
        dwRes = FindSuccessorNode(pIdx, wId, &pSuccessor, 0, Stack, StackPtr);
        if (dwRes)
            return dwRes;

        pIdx->Release();
        pIdx = pSuccessor;
    }

    // UNDERFLOW REPAIR Loop.
    // At this point <pIdx> points to the deepest affected node.
    // We need to start working back up the tree and repairing
    // the damage.  Nodes which have reached zero in size are
    // quite a pain.  But they aren't half as bad as nodes which claim
    // they can recombine with a sibling but really can't.  So,
    // we either do nothing (the node has enough stuff to be useful),
    // collapse with a sibling node or borrow some keys from a sibling
    // to ensure all nodes meet the minimum load requirement.
    // ===============================================================

    SIdxKeyTable *pSibling = 0;
    SIdxKeyTable *pParent = 0;

    for (;;)
    {
        DWORD dwParentId = Stack[StackPtr--];
        DWORD dwThisId = pIdx->GetPageId();

        dwLoad = ComputeLoad(pIdx);
        if (dwLoad > const_MinimumLoad || dwParentId == 0)
        {
            dwRes = WriteIdxPage(pIdx);
            pIdx->Release();
			if (dwRes != 0)
				return dwRes;
            break;
        }

        // If here the node is getting small.  We must collapsed this
        // node with a sibling.

        // collapse this node and a sibling

        dwRes = ReadIdxPage(dwParentId, &pParent);
		if (dwRes != 0)
			return dwRes;

        // Locate a sibling and see if the sibling and the current node
        // can be collapsed with leftover space.
        // =============================================================

        DWORD dwLeftSibling = pParent->GetLeftSiblingOf(pIdx->GetPageId());
        DWORD dwRightSibling = pParent->GetRightSiblingOf(pIdx->GetPageId());
        DWORD dwSiblingId = 0;

        if (dwLeftSibling)
        {
            dwRes = ReadIdxPage(dwLeftSibling, &pSibling);
			if (dwRes != 0)
				return dwRes;
            dwSiblingId = pSibling->GetPageId();
        }
        else
        {
            dwRes = ReadIdxPage(dwRightSibling, &pSibling);
			if (dwRes != 0)
				return dwRes;
            dwSiblingId = pSibling->GetPageId();
        }

        // If here, the node is 'underloaded'.  Now we have to
        // get the parent and the sibling and collapsed them.
        // ===================================================

        SIdxKeyTable *pCopy = 0;
        dwRes = pIdx->Clone(&pCopy);
		if (dwRes != 0)
			return dwRes;

        dwRes = pIdx->Collapse(pParent, pSibling);
		if (dwRes != 0)
		{
			pCopy->Release();
			return dwRes;
		}

        // Now we have a different sort of problem, possibly.
        // If the collapsed node is too big, we have to try
        // a different strategy.
        // ===================================================

        if (pIdx->GetRequiredPageMemory() > m_pSrc->GetPageSize())
        {
            pIdx->Release();
            pParent->Release();
            pSibling->Release();
            pIdx = pParent = pSibling = 0;

            // Reread the pages.
            // =================
            pIdx = pCopy;
            dwRes = ReadIdxPage(dwParentId, &pParent);
			if (dwRes != 0)
				return dwRes;
            dwRes = ReadIdxPage(dwSiblingId, &pSibling);
			if (dwRes != 0)
				return dwRes;

            // Transfer a key or two from sibling via parent.
            // This doesn't change the tree shape, but the
            // parent may overflow.
            // ==============================================
            do
            {
                dwRes = pIdx->StealKeyFromSibling(pParent, pSibling);
				if (dwRes != 0)
					return dwRes;
                dwLoad = ComputeLoad(pIdx);
            }   while (dwLoad < const_MinimumLoad);

            dwRes = WriteIdxPage(pIdx);
            pIdx->Release();
			if (dwRes != 0)
				return dwRes;
            dwRes = WriteIdxPage(pSibling);
            pSibling->Release();
			if (dwRes != 0)
				return dwRes;
            dwRes = InsertPhase2(pParent, 0, 0, 0, Stack, StackPtr);
            pParent->Release();
			if (dwRes != 0)
				return dwRes;
            break;
        }
        else  // The collapse worked; we can free the sibling page
        {
            pCopy->Release();
            dwRes = m_pSrc->FreePage(pSibling->GetPageId());
			if (dwRes != 0)
				return dwRes;
            pSibling->Release();
        }

        // If here, the collapse worked.
        // =============================

        dwRes = WriteIdxPage(pIdx);
        if (dwRes)
        {
            pIdx->Release();
            break;
        }

        if (pParent->GetNumKeys() == 0)
        {
            // We have replaced the root. Note
            // that we transfer the ref count of pIdx to m_pRoot.
            DWORD dwOldRootId = m_pRoot->GetPageId();
            m_pRoot->Release();
            m_pRoot = pIdx;

            // Even though we wrote <pIdx> a few lines back,
            // a rewrite is required to update internal stuff
            // because this has become the new root.
            // ==============================================
            dwRes = m_pSrc->SetRootPage(m_pRoot->GetPageId());
			if (dwRes != 0)
				return dwRes;
            dwRes = WriteIdxPage(m_pRoot);
			if (dwRes != 0)
				return dwRes;
            dwRes = m_pSrc->FreePage(dwOldRootId);
			if (dwRes != 0)
				return dwRes;
            pParent->Release();
            break;
        }

        pIdx->Release();
        pIdx = pParent;
    }

    return dwRes;
}

//***************************************************************************
//
//  CBTree::ReplaceBySuccessor
//
//  Removes the wId key in the <pIdx> node, and replaces it with the
//  successor.
//
//  Precondition: <pIdx> is an internal (non-leaf) node.
//
//  Side-effects:  <pIdx> may be overflowed and require the InsertPhase2
//  treatment.  The node from which the successor is extracted is
//  written, but may have been reduced to zero keys.
//
//***************************************************************************
//
DWORD CBTree::ReplaceBySuccessor(
    IN SIdxKeyTable *pIdx,
    IN WORD wId,
    OUT LPSTR *pszSuccessorKey,
    OUT BOOL *pbUnderflowDetected,
    DWORD Stack[],
    LONG &StackPtr
    )
{
    SIdxKeyTable *pTemp = 0;
    DWORD dwRes;
    DWORD dwPredecessorChild;

    dwRes = FindSuccessorNode(pIdx, wId, &pTemp, &dwPredecessorChild, Stack, StackPtr);
    if (dwRes || pTemp == 0)
        return dwRes;

    LPSTR pszKey = 0;
    dwRes = pTemp->GetKeyAt(0, &pszKey);
	if (dwRes)
		return dwRes;
    DWORD dwUserData = pTemp->GetUserData(0);
    dwRes = pTemp->RemoveKey(0);
	if (dwRes)
		return dwRes;
    if (ComputeLoad(pTemp) < const_MinimumLoad)
        *pbUnderflowDetected = TRUE;
    dwRes = WriteIdxPage(pTemp);
    pTemp->Release();
	if (dwRes)
		return dwRes;

    pIdx->RemoveKey(wId);
    dwRes = pIdx->AddKey(pszKey, wId, dwUserData);
	if (dwRes)
		return dwRes;
    pIdx->SetChildPage(wId, dwPredecessorChild);

    *pszSuccessorKey = pszKey;
    StackPtr--;
    return dwRes;
}

//***************************************************************************
//
//  CBTree::FindSuccessorNode
//
//  Read-only. Finds the node containing the successor to the specified key.
//
//***************************************************************************
//
DWORD CBTree::FindSuccessorNode(
    IN SIdxKeyTable *pIdx,
    IN WORD wId,
    OUT SIdxKeyTable **pSuccessor,
    OUT DWORD *pdwPredecessorChild,
    DWORD Stack[],
    LONG &StackPtr
    )
{
    SIdxKeyTable *pTemp = 0;
    DWORD dwRes = 0;
    DWORD dwSuccessorChild, dwPredecessorChild;

    dwPredecessorChild = pIdx->GetChildPage(wId);
    dwSuccessorChild = pIdx->GetChildPage(wId+1);

    Stack[++StackPtr] = pIdx->GetPageId();

    // From this point on, take leftmost children until
    // we reach a leaf node.  The leftmost key in the
    // leftmost node is always the successor, thanks to the
    // astonishing properties of the BTree.  Nice and easy, huh?
    // =========================================================

    while (dwSuccessorChild)
    {
        Stack[++StackPtr] = dwSuccessorChild;
        if (pTemp)
            pTemp->Release();
        dwRes = ReadIdxPage(dwSuccessorChild, &pTemp);
		if (dwRes)
		{
			//Bail because we have an error!
			return dwRes;
		}
        dwSuccessorChild = pTemp->GetChildPage(0);
    }

    StackPtr--;     // Pop the element we are returning in <*pSuccessor>

    *pSuccessor = pTemp;
    if (pdwPredecessorChild)
        *pdwPredecessorChild = dwPredecessorChild;

    return dwRes;
}



//***************************************************************************
//
//   CBTree::BeginEnum
//
//***************************************************************************
//
DWORD CBTree::BeginEnum(
    LPSTR pszStartKey,
    OUT CBTreeIterator **pIterator
    )
{
	DWORD dwRes;
	if (m_pRoot == NULL)
	{
		dwRes = InvalidateCache();
		if (dwRes != ERROR_SUCCESS)
			return dwRes;
	}
    CBTreeIterator *pIt = new CBTreeIterator;
    if (pIt == 0)
        return ERROR_NOT_ENOUGH_MEMORY;

    dwRes = pIt->Init(this, pszStartKey);
    if (dwRes)
    {
        pIt->Release();
        return dwRes;
    }

    *pIterator = pIt;
    return NO_ERROR;
}


//***************************************************************************
//
//   CBTree::Dump
//
//***************************************************************************
//
void CBTree::Dump(FILE *f)
{
    m_pSrc->Dump(f);
}


//***************************************************************************
//
//***************************************************************************
//
DWORD CBTree::InvalidateCache()
{
	if (m_pRoot)
		m_pRoot->Release();

    DWORD dwRootPage = m_pSrc->GetRootPage();
    DWORD dwRes = ReadIdxPage(dwRootPage, &m_pRoot);
    return dwRes;
}

//***************************************************************************
//
//  CBTreeIterator::FlushCaches
//
//***************************************************************************
//
DWORD CBTree::FlushCaches()
{
	if (m_pRoot)
	{
		m_pRoot->Release();
		m_pRoot = NULL;
	}
	return NO_ERROR;
}

//***************************************************************************
//
//  CBTreeIterator::Init
//
//***************************************************************************
//
DWORD CBTreeIterator::Init(
    IN CBTree *pTree,
    IN LPSTR pszStartKey
    )
{
	DWORD dwRes;
    if (pTree == 0)
        return ERROR_INVALID_PARAMETER;
    m_pTree = pTree;

	if (m_pTree->m_pRoot == NULL)
	{
		dwRes = m_pTree->InvalidateCache();
		if (dwRes != ERROR_SUCCESS)
			return dwRes;
	}

    // Special case of enumerating everything.  Probably not useful
    // for WMI, but great for testing & debugging (I think).
    // ============================================================

    if (pszStartKey == 0)
    {
        Push(0, 0); // Sentinel value in stack

        SIdxKeyTable *pRoot = pTree->m_pRoot;
        pRoot->AddRef();
        Push(pRoot, 0);

        DWORD dwChildPage = Peek()->GetChildPage(0);

        while (dwChildPage)
        {
            SIdxKeyTable *pIdx = 0;
            dwRes = m_pTree->ReadIdxPage(dwChildPage, &pIdx);
            if (dwRes)
                return dwRes;
            if (StackFull())
            {
                pIdx->Release();
                return ERROR_INSUFFICIENT_BUFFER;
            }
            Push(pIdx, 0);
            dwChildPage = pIdx->GetChildPage(0);
        }
        return NO_ERROR;
    }

    // If here, a matching string was specified.
    // This is the typical case.
    // =========================================

    Push(0, 0); // Sentinel value in stack

    WORD wId = 0;
    DWORD dwChildPage;
    SIdxKeyTable *pIdx = pTree->m_pRoot;
    pIdx->AddRef();

    while (1)
    {
        dwRes = pIdx->FindKey(pszStartKey, &wId);
        if (dwRes == 0)
        {
            // Found it
            Push(pIdx, wId);
            return NO_ERROR;
        }
		else if (dwRes != ERROR_NOT_FOUND)
			return dwRes;

        // Otherwise, we have to try to descend to a child page.
        // =====================================================
        dwChildPage = pIdx->GetChildPage(wId);
        if (dwChildPage == 0)
            break;

        Push(pIdx, wId);
        pIdx = 0;
        dwRes = pTree->ReadIdxPage(dwChildPage, &pIdx);
        if (dwRes)
            return dwRes;
    }

    Push(pIdx, wId);

    while (Peek() && PeekId() == WORD(Peek()->GetNumKeys()))
        Pop();

    return NO_ERROR;
}

//***************************************************************************
//
//  CBTreeIterator::Next
//
//  On entry:
//  <wID> is the key to visit in the current node (top-of-stack).
//  The call sets up the successor before leaving.  If there is no successor,
//  the top of stack is left at NULL and ERROR_NO_MORE_ITEMS is returned.
//
//  Returns ERROR_NO_MORE_ITEMS when the iteration is complete.
//
//***************************************************************************
//
DWORD CBTreeIterator::Next(
    LPSTR *ppszStr,
    DWORD *pdwData
    )
{
    DWORD dwRes;

    if (ppszStr == 0)
        return ERROR_INVALID_PARAMETER;
    *ppszStr = 0;

    if (Peek() == 0)
        return ERROR_NO_MORE_ITEMS;

    // Get the item for the caller.
    // ============================

    dwRes = Peek()->GetKeyAt(PeekId(), ppszStr);
    if (dwRes)
        return dwRes;
    if (pdwData)
        *pdwData = Peek()->GetUserData(PeekId());
    IncStackId();

    // Now find the successor.
    // =======================

    DWORD dwChildPage = Peek()->GetChildPage(PeekId());

    while (dwChildPage)
    {
        SIdxKeyTable *pIdx = 0;
        dwRes = m_pTree->ReadIdxPage(dwChildPage, &pIdx);
        if (dwRes)
            return dwRes;
        if (StackFull())
        {
            pIdx->Release();
            return ERROR_INSUFFICIENT_BUFFER;
        }
        Push(pIdx, 0);
        dwChildPage = pIdx->GetChildPage(0);
    }

    // If here, we are at a leaf node.
    // ===============================

    while (Peek() && PeekId() == WORD(Peek()->GetNumKeys()))
        Pop();

    return NO_ERROR;
}

//***************************************************************************
//
//  CBTreeIterator::Release
//
//***************************************************************************
//
DWORD CBTreeIterator::Release()
{
    delete this;
    return 0;
}

//***************************************************************************
//
//  CBTreeIterator::~CBTreeIterator
//
//***************************************************************************
//
CBTreeIterator::~CBTreeIterator()
{
    // Cleanup any leftover stack
    while (m_lStackPointer > -1)
        Pop();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\xfiles\btr.h ===
//***************************************************************************
//
//  (c) 2000 Microsoft Corp.  All Rights Reserved.
//
//  BTR.H
//
//  Repository B-tree classes
//
//  raymcc  15-Oct-00       First version
//
//***************************************************************************

#ifndef _BTR_H_
#define _BTR_H_

#define A51_INDEX_FILE_ID 2
class CPageFile;
class CPageSource;

LPVOID WINAPI _BtrMemAlloc(
    SIZE_T dwBytes  // number of bytes to allocate
    );

LPVOID WINAPI _BtrMemReAlloc(
    LPVOID pOriginal,
    DWORD dwNewBytes
    );

BOOL WINAPI _BtrMemFree(LPVOID pMem);

#define ReleaseIfNotNULL(p) if(p) p->Release()

class CBTreeFile
{
    DWORD  m_dwPageSize;

    DWORD  m_dwLogicalRoot;

    CPageFile* m_pFile;
	CPageSource *m_pTransactionManager;

    // Methods
    DWORD Setup();
    DWORD WriteAdminPage();

public:
    CBTreeFile();
   ~CBTreeFile();

    enum { const_DefaultPageSize = 0x2000, const_CurrentVersion = 0x101 };

    enum {
        PAGE_TYPE_IMPOSSIBLE = 0x0,       // Not supposed to happen
        PAGE_TYPE_ACTIVE = 0xACCC,        // Page is active with data
        PAGE_TYPE_DELETED = 0xBADD,       // A deleted page on free list
        PAGE_TYPE_ADMIN = 0xADDD,         // Page zero only

        // All pages
        OFFSET_PAGE_TYPE = 0,             // True for all pages
        OFFSET_PAGE_ID = 1,               // True for all pages
        OFFSET_NEXT_PAGE = 2,             // True for all pages (Page continuator)

        // Admin Page (page zero) only
        OFFSET_LOGICAL_ROOT = 3,          // Root of database
        };


    DWORD Init(
        DWORD dwPageSize,        // 8k default
        LPWSTR pszFilename, 
		CPageSource* pSource
        );

    DWORD Shutdown(DWORD dwShutDownFlags);

    DWORD GetPage(DWORD dwId, LPVOID *pPage);
    DWORD PutPage(LPVOID pPage, DWORD dwType);
    DWORD NewPage(LPVOID *pPage);
    DWORD FreePage(LPVOID pPage);
    DWORD FreePage(DWORD dwId);

    DWORD GetPageSize() { return m_dwPageSize; }

    DWORD SetRootPage(DWORD dwID);
    DWORD GetRootPage() { return m_dwLogicalRoot; }
    DWORD ReadAdminPage();

    void  Dump(FILE *);
};

struct SIdxStringPool
{
    DWORD  m_dwNumStrings;          // Number of strings in pool
    WORD  *m_pwOffsets;             // Offsets into pool of strings
    DWORD  m_dwOffsetsSize;         // Number of elements in above array

    LPSTR  m_pStringPool;           // Pointer to string pool
    DWORD  m_dwPoolTotalSize;       // Total size, used+unused
    DWORD  m_dwPoolUsed;            // Offset of first free position

public:
    enum { const_DefaultPoolSize = 0x2200 };

    SIdxStringPool() { memset(this, 0, sizeof(SIdxStringPool)); }
   ~SIdxStringPool();

    DWORD  AddStr(LPSTR pszStr, WORD wInsertPos, int *pnAdjuster);
    DWORD  DeleteStr(WORD wAssignedOffset, int *pnAdjuster);

    DWORD  GetLastId() { return m_dwNumStrings; }

    DWORD FindStr(
        IN  LPSTR pszSearchKey,
        OUT WORD *pwStringNumber,
        OUT WORD *pwPoolOffset
        );

    DWORD  GetNumStrings() { return m_dwNumStrings; }
    DWORD  GetRequiredPageMemory()
        {
        return m_dwPoolUsed + (m_dwNumStrings * sizeof(WORD)) +
        sizeof(m_dwNumStrings) + sizeof(m_dwPoolUsed);
        }

    DWORD  Dump(FILE *f);

    LPSTR  GetStrById(WORD id) { return m_pStringPool+m_pwOffsets[id]; }
    void   Empty() { m_dwNumStrings = 0; m_dwPoolUsed = 0; }
    DWORD  Clone(SIdxStringPool **);
};

class SIdxKeyTable
{
    DWORD m_dwRefCount;                // Ref count

    DWORD m_dwPageId;                  // Page number
    DWORD m_dwParentPageId;            // Parent page id  <For DEBUGGING only>
    DWORD m_dwNumKeys;                 // Num keys
    WORD *m_pwKeyLookup;               // Offset of key into key-encoding-table
    DWORD m_dwKeyLookupTotalSize;      // Elements in array
    DWORD *m_pdwUserData;              // User DWORD with each key
    DWORD *m_pdwChildPageMap;          // Child page pointers n=left ptr, n+1=right pointer

    WORD *m_pwKeyCodes;                // Key encoding table
    DWORD m_dwKeyCodesTotalSize;       // Total elements in array
    DWORD m_dwKeyCodesUsed;            // Elements used
    SIdxStringPool *m_pStrPool;        // The pool associated with this key table

    // Methods

    SIdxKeyTable();
   ~SIdxKeyTable();

public:
    enum { const_DefaultArray = 256,
           const_DefaultKeyCodeArray = 512
         };

    static DWORD Create(DWORD dwPageId, SIdxKeyTable **pNew);
    static DWORD Create(LPVOID pPage, SIdxKeyTable **pNew);

    DWORD AddRef();
    DWORD Release();

    DWORD AddKey(LPSTR pszStr, WORD ID, DWORD dwUserData);
    DWORD RemoveKey(WORD wID);
    DWORD FindKey(LPSTR pszStr, WORD *pID);
    DWORD GetUserData(WORD wID) { return m_pdwUserData[wID]; }

    void  SetChildPage(WORD wID, DWORD dwPage) { m_pdwChildPageMap[wID] = dwPage; }
    DWORD GetChildPage(WORD wID) { return m_pdwChildPageMap[wID]; }
    DWORD GetLastChildPage() { return m_pdwChildPageMap[m_dwNumKeys]; }
    DWORD GetLeftSiblingOf(DWORD dwId);
    DWORD GetRightSiblingOf(DWORD dwId);
    DWORD GetKeyAt(WORD wID, LPSTR *pszKey);    // Use _MemFree
    DWORD GetNumKeys() { return m_dwNumKeys; }
    void  SetStringPool(SIdxStringPool *pPool) { m_pStrPool = pPool; }
    void  FreeMem(LPVOID pMem);

    void AdjustKeyCodes(
        WORD wID,
        int nAdjustment
        );

    int KeyStrCompare(
        LPSTR pszSearchKey,
        WORD wID
        );

    DWORD Cleanup();

    DWORD NumKeys() { return m_dwNumKeys; }
    DWORD GetRequiredPageMemory();
    DWORD Dump(FILE *, DWORD *pdwKeys = 0);
    void  ZapPage();
    DWORD GetPageId() { return m_dwPageId; }

    // Sibling/Parent page helpers

    DWORD GetKeyOverhead(WORD wID); // Returns total bytes required by new key

    BOOL IsLeaf() { return m_pdwChildPageMap[0] == 0; }
    DWORD Redist(
        SIdxKeyTable *pParent,
        SIdxKeyTable *pNewSibling
        );

    DWORD Collapse(
        SIdxKeyTable *pParent,
        SIdxKeyTable *pDoomedSibling
        );

    DWORD StealKeyFromSibling(
        SIdxKeyTable *pParent,
        SIdxKeyTable *pSibling
        );

    DWORD MapFromPage(LPVOID pSrc);
    DWORD MapToPage(LPVOID pMem);

    DWORD Clone(OUT SIdxKeyTable **pCopy);
};

class CBTree;


class CBTreeIterator
{
    friend class CBTree;
    enum {
        const_MaxStack = 1024,
        const_PrefetchSize = 64
        };

    CBTree       *m_pTree;
    SIdxKeyTable *m_Stack[const_MaxStack];
    WORD          m_wStack[const_MaxStack];
    LONG          m_lStackPointer;

    LPSTR        *m_pPrefetchKeys[const_PrefetchSize];
    DWORD         m_dwPrefetchData[const_PrefetchSize];
    DWORD         m_dwPrefetchActive;

   ~CBTreeIterator();

    // Stack helpers
    SIdxKeyTable *Peek() { return m_Stack[m_lStackPointer]; }
    WORD PeekId() { return m_wStack[m_lStackPointer]; }
    void IncStackId() { m_wStack[m_lStackPointer]++; }

    void Pop() {  ReleaseIfNotNULL(m_Stack[m_lStackPointer]); m_lStackPointer--; }
    BOOL StackFull() { return m_lStackPointer == const_MaxStack - 1; }
    void Push(SIdxKeyTable *p, WORD wId) { m_Stack[++m_lStackPointer] = p; m_wStack[m_lStackPointer] = wId; }

    DWORD ZapStack();
    DWORD PurgeKey(LPSTR pszDoomedKey);
    DWORD RebuildStack(LPSTR pszStartKey);
    DWORD ExecPrefetch();

    static DWORD ZapAllStacks();
    static DWORD GlobalPurgeKey(LPSTR pszDoomedKey);

public:

    CBTreeIterator() { m_pTree = 0; m_lStackPointer = -1; }

    DWORD Init(CBTree *pRoot, LPSTR pszStartKey = 0);  // If last parm is null, iterate through all
    DWORD Next(LPSTR *ppszStr, DWORD *pdwData = 0);
    void  FreeString(LPSTR pszStr) { _BtrMemFree(pszStr); }
    DWORD Release();
};

class CBTree
{
    enum { const_DefaultArray = 256 };
    enum { const_MinimumLoad = 33 };

    CBTreeFile *m_pSrc;
    SIdxKeyTable *m_pRoot;
    friend class CBTreeIterator;

    LONG m_lGeneration;

    // private methods

    DWORD ReplaceBySuccessor(
        IN SIdxKeyTable *pIdx,
        IN WORD wId,
        OUT LPSTR *pszSuccessorKey,
        OUT BOOL *pbUnderflowDetected,
        DWORD Stack[],
        LONG &StackPtr
        );

    DWORD FindSuccessorNode(
        IN SIdxKeyTable *pIdx,
        IN WORD wId,
        OUT SIdxKeyTable **pSuccessor,
        OUT DWORD *pdwPredecessorChild,
        DWORD Stack[],
        LONG &StackPtr
        );

    DWORD ReadIdxPage(
        DWORD dwPage,
        SIdxKeyTable **pIdx
        );

    DWORD WriteIdxPage(
        SIdxKeyTable *pIdx
        );

    DWORD ComputeLoad(
        SIdxKeyTable *pKT
        );

    DWORD InsertPhase2(
        SIdxKeyTable *pCurrent,
        WORD wID,
        LPSTR pszKey,
        DWORD dwValue,
        DWORD Stack[],
        LONG &StackPtr
        );

    DWORD Search(
        IN  LPSTR pszKey,
        OUT SIdxKeyTable **pRetIdx,
        OUT WORD *pwID,
        DWORD Stack[],
        LONG &StackPtr
        );

public:
    CBTree();
   ~CBTree();

    DWORD Init(CBTreeFile *pSrc);
    DWORD Shutdown(DWORD dwShutDownFlags);

    DWORD InsertKey(
        IN LPSTR pszKey,
        DWORD dwValue
        );

    DWORD FindKey(
        IN LPSTR pszKey,
        DWORD *pdwData
        );

    DWORD DeleteKey(
        IN LPSTR pszKey
        );

    DWORD BeginEnum(
        LPSTR pszStartKey,
        OUT CBTreeIterator **pIterator
        );

    void Dump(FILE *fp);

    DWORD InvalidateCache();

	DWORD FlushCaches();
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\xfiles\filecach.cpp ===
/*++

Copyright (C) 2000-2001 Microsoft Corporation

--*/

#include <windows.h>
#include <stdio.h>
#include <wbemcomn.h>
#include <reposit.h>
#include "filecach.h"
#include "creposit.h"

long CFileCache::InnerInitialize(LPCWSTR wszBaseName)
{
    long lRes;

    wcscpy(m_wszBaseName, wszBaseName);
    wcscat(m_wszBaseName, L"\\");
    m_dwBaseNameLen = wcslen(m_wszBaseName);

    lRes = m_TransactionManager.Init();
    if(lRes != ERROR_SUCCESS)
        return lRes;

	lRes = m_TransactionManager.BeginTrans();
	if (lRes != ERROR_SUCCESS)
		return lRes;
    lRes = m_ObjectHeap.Initialize(&m_TransactionManager, 
                                   (WCHAR*)wszBaseName,
                                   m_dwBaseNameLen);
    if(lRes != ERROR_SUCCESS)
	{
		m_TransactionManager.RollbackTrans();
	}
	else
	{
		lRes = m_TransactionManager.CommitTrans();
		if (lRes != ERROR_SUCCESS)
			m_TransactionManager.RollbackTrans();
	}


    return lRes;
}

long CFileCache::RepositoryExists(LPCWSTR wszBaseName)
{
    CFileName wszStagingName;
	if (wszStagingName == NULL)
		return ERROR_OUTOFMEMORY;

    swprintf(wszStagingName, L"%s\\index.btr", wszBaseName);

    DWORD dwAttributes = GetFileAttributesW(wszStagingName);
    if (dwAttributes == -1)
        return ERROR_FILE_NOT_FOUND;
    return ERROR_SUCCESS;
}

long CFileCache::Initialize(LPCWSTR wszBaseName)
{
	long lRes;

	if (m_bInit)
	    return ERROR_SUCCESS;

    lRes = RepositoryExists(wszBaseName);
	if (ERROR_FILE_NOT_FOUND == lRes)
	{
		//If we have a database restore to do, go ahead and do it...
		lRes = DoAutoDatabaseRestore();
	}
	
    //
    // Initialize file cache.  It will read the registry itself to find out
    // its size limitations
    //
	if (SUCCEEDED(lRes))
	{
		lRes = InnerInitialize(wszBaseName);
		if (ERROR_SUCCESS == lRes)
		{
		    m_bInit = TRUE;
		}
	}

	return lRes;
}

CFileCache::CFileCache()
: m_lRef(1), m_bInit(FALSE)
{
}

CFileCache::~CFileCache()
{
}

long CFileCache::Uninitialize(DWORD dwShutDownFlags)
{
    if (!m_bInit)
        return 0;

    Clear(dwShutDownFlags);

    m_bInit = FALSE;
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\xfiles\creposit.h ===
/*++

Copyright (C) 2000-2001 Microsoft Corporation

--*/

#ifndef __CREPOSIT__H_
#define __CREPOSIT__H_

#include <windows.h>
#include <wbemidl.h>
#include <unk.h>
#include <wbemcomn.h>
#include <sync.h>
#include <reposit.h>
#include <wmiutils.h>
#include <filecach.h>
#include <hiecache.h>
#include <corex.h>
#include "a51fib.h"
#include "lock.h"

extern CLock g_readWriteLock;
extern bool g_bShuttingDown;

/* ===================================================================================
 * A51_REP_FS_VERSION
 * 
 * 1 - Original A51 file-based repository
 * 2 - All Objects stored in single file (Whistler Beta 1)
 * 3 - BTree added
 * 4 - System Class optimisation - put all system classes in __SYSTEMCLASS namespace
 * 5 - Change to system classes in __SYSTEMCLASS namespace - need to propagate change
 *		to all namespaces as there may be instances of these classes.
 * 6 - XFiles: New page based heap. Transacted page manager sitting under new heap and
 *		BTree.  Instance indexing improved so instance queries are faster
 * ===================================================================================
 */
#define A51_REP_FS_VERSION 6

#define A51_CLASSDEF_FILE_PREFIX L"CD_"

#define A51_CLASSRELATION_DIR_PREFIX L"CR_"
#define A51_CHILDCLASS_FILE_PREFIX L"C_"

#define A51_KEYROOTINST_DIR_PREFIX L"KI_"
#define A51_INSTDEF_FILE_PREFIX L"I_"

#define A51_CLASSINST_DIR_PREFIX L"CI_"
#define A51_INSTLINK_FILE_PREFIX L"IL_"

#define A51_INSTREF_DIR_PREFIX L"IR_"
#define A51_REF_FILE_PREFIX L"R_"

#define A51_SCOPE_DIR_PREFIX L"SC_"

#define A51_SYSTEMCLASS_NS L"__SYSTEMCLASS"

class CGlobals;
extern CGlobals g_Glob;

class CNamespaceHandle;
extern CNamespaceHandle * g_pSystemClassNamespace;

/*
DWORD g_dwOldRepositoryVersion = 0;
DWORD g_dwCurrentRepositoryVersion = 0;
DWORD g_ShutDownFlags = 0;
*/

class CForestCache;
class CGlobals 
{
private:
    BOOL m_bInit;
    CRITICAL_SECTION m_cs;

    _IWmiCoreServices* m_pCoreServices;

    CForestCache m_ForestCache;

    CFileCache m_FileCache;
    
    long    m_lRootDirLen;
    WCHAR   m_wszRootDir[MAX_PATH];    // keep this last: be debugger friendly
public:
    CGlobals():m_bInit(FALSE)
    { 
        InitializeCriticalSection(&m_cs); 
    };
    ~CGlobals()
    { 
        DeleteCriticalSection(&m_cs); 
    };
    HRESULT Initialize();
    HRESULT Deinitialize();
    _IWmiCoreServices * GetCoreSvcs();
    CForestCache * GetForestCache();
    CFileCache   * GetFileCache();
    WCHAR * GetRootDir() {return (WCHAR *)m_wszRootDir;}
    long    GetRootDirLen() {return  m_lRootDirLen;};   
    void    SetRootDirLen(long Len) { m_lRootDirLen = Len;};
    BOOL    IsInit(){ return m_bInit; };
};


HRESULT DoAutoDatabaseRestore();


class CNamespaceHandle;
class CRepository : public CUnkBase<IWmiDbController, &IID_IWmiDbController>
{
private:
	CFlexArray m_aSystemClasses;	//Used for part of the upgrade process.

	static DWORD m_ShutDownFlags;
	static HANDLE m_hShutdownEvent;
	static HANDLE m_hFlusherThread;
	static LONG   m_ulReadCount;
	static LONG   m_ulWriteCount;
	static HANDLE m_hWriteEvent;
	static HANDLE m_hReadEvent;
	static int    m_threadState;
	static CCritSec m_cs;
	static LONG  m_threadCount;

	enum { ThreadStateDead, ThreadStateIdle, ThreadStateFlush, ThreadStateOperationPending};

protected:
    HRESULT Initialize();
	HRESULT UpgradeRepositoryFormat();
	HRESULT GetRepositoryDirectory();
	HRESULT InitializeGlobalVariables();
	HRESULT InitializeRepositoryVersions();
	static DWORD WINAPI _FlusherThread(void *);

public:

    HRESULT STDMETHODCALLTYPE Logon(
          WMIDB_LOGON_TEMPLATE *pLogonParms,
          DWORD dwFlags,
          DWORD dwRequestedHandleType,
         IWmiDbSession **ppSession,
         IWmiDbHandle **ppRootNamespace
        );

    HRESULT STDMETHODCALLTYPE GetLogonTemplate(
           LCID  lLocale,
           DWORD dwFlags,
          WMIDB_LOGON_TEMPLATE **ppLogonTemplate
        );

    HRESULT STDMETHODCALLTYPE FreeLogonTemplate(
         WMIDB_LOGON_TEMPLATE **ppTemplate
        );

    HRESULT STDMETHODCALLTYPE Shutdown(
         DWORD dwFlags
        );

    HRESULT STDMETHODCALLTYPE SetCallTimeout(
         DWORD dwMaxTimeout
        );

    HRESULT STDMETHODCALLTYPE SetCacheValue(
         DWORD dwMaxBytes
        );

    HRESULT STDMETHODCALLTYPE FlushCache(
         DWORD dwFlags
        );

    HRESULT STDMETHODCALLTYPE GetStatistics(
          DWORD  dwParameter,
         DWORD *pdwValue
        );

    HRESULT STDMETHODCALLTYPE Backup(
		LPCWSTR wszBackupFile,
		long lFlags
        );
    
    HRESULT STDMETHODCALLTYPE Restore(
		LPCWSTR wszBackupFile,
		long lFlags
        );

    HRESULT STDMETHODCALLTYPE LockRepository();

    HRESULT STDMETHODCALLTYPE UnlockRepository();

	HRESULT STDMETHODCALLTYPE GetRepositoryVersions(DWORD *pdwOldVersion, DWORD *pdwCurrentVersion);

	static HRESULT ReadOperationNotification();
	static HRESULT WriteOperationNotification();

	static HRESULT RecoverCheckpoint();
    
public:
    CRepository(CLifeControl* pControl) : TUnkBase(pControl)
    {
        
    }
    ~CRepository()
    {
    }

    HRESULT GetNamespaceHandle(LPCWSTR wszNamespaceName, 
                                CNamespaceHandle** ppHandle);
};


#endif /*__CREPOSIT__H_*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\xfiles\creposit.cpp ===
/*++

Copyright (C) 2000-2001 Microsoft Corporation

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#define WIN32_NO_STATUS
#include <windows.h>
#include <wbemidl.h>
#include <wbemint.h>
#include <stdio.h>
#include <wbemcomn.h>
#include <ql.h>
#include <time.h>
#include "a51rep.h"
#include <md5.h>
#include <objpath.h>
#include "lock.h"
#include <persistcfg.h>
#include "a51fib.h"
#include "RepositoryPackager.h"
#include "Win9xSecurity.h"
#include <scopeguard.h>
#include <malloc.h>

CLock g_readWriteLock;
bool g_bShuttingDown = false;
CNamespaceHandle *g_pSystemClassNamespace = NULL;
DWORD g_dwOldRepositoryVersion = 0;
DWORD g_dwCurrentRepositoryVersion = 0;

DWORD    CRepository::m_ShutDownFlags = 0;
HANDLE   CRepository::m_hShutdownEvent = 0;
HANDLE   CRepository::m_hFlusherThread = 0;
LONG     CRepository::m_ulReadCount = 0;
LONG     CRepository::m_ulWriteCount = 0;
HANDLE   CRepository::m_hWriteEvent = 0;
HANDLE   CRepository::m_hReadEvent = 0;
int      CRepository::m_threadState = CRepository::ThreadStateDead;
CCritSec CRepository::m_cs;
LONG     CRepository::m_threadCount = 0;

//*****************************************************************************

HRESULT CRepository::Initialize()
{
    HRESULT hRes = WBEM_S_NO_ERROR;

	InitializeRepositoryVersions();

	//
    // Initialize time index
    //
	if (SUCCEEDED(hRes))
	{
		FILETIME ft;
		GetSystemTimeAsFileTime(&ft);

		g_nCurrentTime = ft.dwLowDateTime + ((__int64)ft.dwHighDateTime << 32);
	}

    //
    // Get the repository directory
    //
	if (SUCCEEDED(hRes))
		hRes = GetRepositoryDirectory();

	//Do the upgrade of the repository if necessary
	if (SUCCEEDED(hRes))
		hRes = UpgradeRepositoryFormat();
    //
    // initialze all our global resources
    //
	if (SUCCEEDED(hRes))
		hRes = InitializeGlobalVariables();

	if (SUCCEEDED(hRes))
	{
		long lRes = g_Glob.GetFileCache()->Initialize(g_Glob.GetRootDir());
		hRes = A51TranslateErrorCode(lRes);
	}

    //
    // Initialize class cache.  It will read the registry itself to find out
    // its size limitations
    //

	if (SUCCEEDED(hRes))
	{
		hRes = g_Glob.Initialize();
		if(hRes != ERROR_SUCCESS)
		{
			hRes = WBEM_E_FAILED;
		}
	}
    
	//If we need to create the system class namespace then go ahead and do that...
	if (SUCCEEDED(hRes))
	{
		g_pSystemClassNamespace = new CNamespaceHandle(m_pControl, this);
		if (g_pSystemClassNamespace == NULL)
		{
			hRes = WBEM_E_OUT_OF_MEMORY;
		}
	}

	if (SUCCEEDED(hRes))
	{
		g_pSystemClassNamespace->AddRef();
		hRes = g_pSystemClassNamespace->Initialize(A51_SYSTEMCLASS_NS);
	}

	if (SUCCEEDED(hRes))
	{
		m_hWriteEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
		if (m_hWriteEvent == NULL)
			hRes = WBEM_E_CRITICAL_ERROR;
	}
	if (SUCCEEDED(hRes))
	{
		m_hReadEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
		if (m_hReadEvent == NULL)
			hRes = WBEM_E_CRITICAL_ERROR;
	}
	if (SUCCEEDED(hRes))
	{
		m_hShutdownEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
		if (m_hShutdownEvent == NULL)
			hRes = WBEM_E_CRITICAL_ERROR;
	}
// *** Don't need to create the thread here because the read/write operation
// *** will create it on demand...
//	if (SUCCEEDED(hRes))
//	{
//		m_hFlusherThread = CreateThread(NULL, 0, _FlusherThread, 0, 0, NULL);
//		if (m_hFlusherThread == NULL)
//			hRes = WBEM_E_CRITICAL_ERROR;
//		else
//			m_threadState = ThreadStateOperationPending;
//	}

	//We need to reset the shutting down flag as the flusher thread
	//will not start without it.  The problem is that the next 2 
	//operations (CreateSystemClasses and Import security do things
	//that will re-create the thread even though we don't do it above
	//
	if (SUCCEEDED(hRes))
		g_bShuttingDown = false;

	if (SUCCEEDED(hRes))
	{
		CAutoWriteLock lock(&g_readWriteLock);
		if (!lock.Lock())
            hRes = WBEM_E_FAILED;
		else			
    		hRes = g_pSystemClassNamespace->CreateSystemClasses(m_aSystemClasses);
	}

	if (SUCCEEDED(hRes))
	{
		// import Win9x security data if necessary
		CWin9xSecurity win9xSecurity(m_pControl, this);
		if (win9xSecurity.Win9xBlobFileExists())
			hRes = win9xSecurity.ImportWin9xSecurity();
	}

	if (SUCCEEDED(hRes))
		g_bShuttingDown = false;
	else
	{
		g_bShuttingDown = true;	//Reset to true as we cleared it earlier!
		g_Glob.GetFileCache()->Uninitialize(0);

		g_Glob.GetForestCache()->Deinitialize();

		if (g_pSystemClassNamespace)
		{
			delete g_pSystemClassNamespace;
			g_pSystemClassNamespace = NULL;
		}

		if (m_hWriteEvent != NULL)
		{
			CloseHandle(m_hWriteEvent);
			m_hWriteEvent = NULL;
		}
		if (m_hReadEvent != NULL)
		{
			CloseHandle(m_hReadEvent);
			m_hReadEvent = NULL;
		}
		if (m_hShutdownEvent != NULL)
		{
			CloseHandle(m_hShutdownEvent);
			m_hShutdownEvent = NULL;
		}
		if (m_hFlusherThread != NULL)
		{
			CloseHandle(m_hFlusherThread);
			m_hFlusherThread = NULL;
		}
	}

    return hRes;
}

HRESULT CRepository::InitializeRepositoryVersions()
{
	DWORD dwVal = 0;
	CPersistentConfig cfg;
	cfg.GetPersistentCfgValue(PERSIST_CFGVAL_CORE_FSREP_VERSION, dwVal);
	if (dwVal == 0)
		dwVal = A51_REP_FS_VERSION;

	g_dwOldRepositoryVersion = dwVal;
	g_dwCurrentRepositoryVersion = A51_REP_FS_VERSION;

	return WBEM_S_NO_ERROR;
}

HRESULT CRepository::UpgradeRepositoryFormat()
{
	HRESULT hRes = WBEM_E_DATABASE_VER_MISMATCH;
	CPersistentConfig cfg;
	DWORD dwVal = 0;
	cfg.GetPersistentCfgValue(PERSIST_CFGVAL_CORE_FSREP_VERSION, dwVal);
	
	if (dwVal == 0)
	{
        //
        // First time --- write the right version in
        //
		hRes = WBEM_S_NO_ERROR;

		cfg.SetPersistentCfgValue(PERSIST_CFGVAL_CORE_FSREP_VERSION, 
                                    A51_REP_FS_VERSION);
	}
	else if ((dwVal > 0) && (dwVal < 5))
	{
        ERRORTRACE((LOG_WBEMCORE, "Repository cannot upgrade this version of the repository.  Version found = <%ld>, version expected = <%ld>\n", dwVal, A51_REP_FS_VERSION ));
		hRes = WBEM_E_DATABASE_VER_MISMATCH;
	}
	else if (dwVal == 5)
	{
        ERRORTRACE((LOG_WBEMCORE, "Repository does not support upgrade from version 5. We are deleting the old version and re-initializing it. Version found = <%ld>, version expected = <%ld>\n", dwVal, A51_REP_FS_VERSION ));
		//Need to delete the old repostiory
		CFileName fn;
		if (fn == NULL)
			hRes = WBEM_E_OUT_OF_MEMORY;
		else
		{
			wcscpy(fn, g_Glob.GetRootDir());
			wcscat(fn, L"\\index.btr");
			DeleteFileW(fn);
			wcscpy(fn, g_Glob.GetRootDir());
			wcscat(fn, L"\\lowstage.dat");
			DeleteFileW(fn);
			wcscpy(fn, g_Glob.GetRootDir());
			wcscat(fn, L"\\objheap.fre");
			DeleteFileW(fn);
			wcscpy(fn, g_Glob.GetRootDir());
			wcscat(fn, L"\\objheap.hea");
			DeleteFileW(fn);
			
			cfg.SetPersistentCfgValue(PERSIST_CFGVAL_CORE_FSREP_VERSION, A51_REP_FS_VERSION);
			hRes = WBEM_S_NO_ERROR;
		}
	}
	else if (dwVal == A51_REP_FS_VERSION)
		hRes = WBEM_S_NO_ERROR;

	if (hRes == WBEM_E_DATABASE_VER_MISMATCH)
    {
        //
        // Unsupported version
        //
    
        ERRORTRACE((LOG_WBEMCORE, "Repository cannot initialize "
            "due to the detection of an unknown repository version.  Version found = <%ld>, version expected = <%ld>\n", dwVal, A51_REP_FS_VERSION ));
		return WBEM_E_DATABASE_VER_MISMATCH;
    }
	return hRes;
}


HRESULT CRepository::GetRepositoryDirectory()
{
    HKEY hKey;
    long lRes = RegOpenKeyExW(HKEY_LOCAL_MACHINE, 
                    L"SOFTWARE\\Microsoft\\WBEM\\CIMOM",
                    0, KEY_READ, &hKey);
    if(lRes)
        return WBEM_E_FAILED;

    CFileName wszTmp;
	if (wszTmp == NULL)
		return WBEM_E_OUT_OF_MEMORY;
    DWORD dwLen = wszTmp.Length();
    lRes = RegQueryValueExW(hKey, L"Repository Directory", NULL, NULL, 
                (LPBYTE)(wchar_t*)wszTmp, &dwLen);
	RegCloseKey(hKey);
    if(lRes)
        return WBEM_E_FAILED;

    CFileName wszRepDir;
	if (wszRepDir == NULL)
		return WBEM_E_OUT_OF_MEMORY;

	if (ExpandEnvironmentStringsW(wszTmp,wszRepDir,wszTmp.Length()) == 0)
		return WBEM_E_FAILED;


    lRes = EnsureDirectory(wszRepDir);
    if(lRes != ERROR_SUCCESS)
        return WBEM_E_FAILED;

    //
    // Append standard postfix --- that is our root
    //
    wcscpy(g_Glob.GetRootDir(), wszRepDir);
    wcscat(g_Glob.GetRootDir(), L"\\FS");
    g_Glob.SetRootDirLen(wcslen(g_Glob.GetRootDir()));

    //
    // Ensure the directory is there
    //

    lRes = EnsureDirectory(g_Glob.GetRootDir());
    if(lRes != ERROR_SUCCESS)
        return WBEM_E_FAILED;

    SetFileAttributesW(g_Glob.GetRootDir(), FILE_ATTRIBUTE_NOT_CONTENT_INDEXED);

	return WBEM_S_NO_ERROR;
}

HRESULT CRepository::InitializeGlobalVariables()
{

	return WBEM_S_NO_ERROR;
}

HRESULT DoAutoDatabaseRestore()
{
	HRESULT hRes = WBEM_S_NO_ERROR;

    //We may need to do a database restore!
    CFileName wszBackupFile;
	if (wszBackupFile == NULL)
    {
        return WBEM_E_OUT_OF_MEMORY;
    }

    int nLen = g_Glob.GetRootDirLen();
    wcsncpy(wszBackupFile, g_Glob.GetRootDir(), nLen - 3);	// exclude "\FS" from path
    wszBackupFile[nLen - 3] = '\0';
    wcscat(wszBackupFile, L"\\repdrvfs.rec");

    DWORD dwAttributes = GetFileAttributesW(wszBackupFile);
    if (dwAttributes != -1)
    {
		DWORD dwMask =	FILE_ATTRIBUTE_DEVICE |
						FILE_ATTRIBUTE_DIRECTORY |
						FILE_ATTRIBUTE_OFFLINE |
						FILE_ATTRIBUTE_REPARSE_POINT |
						FILE_ATTRIBUTE_SPARSE_FILE;

		if (!(dwAttributes & dwMask))
        {
            CRepositoryPackager packager;
	        hRes = packager.UnpackageRepository(wszBackupFile);

            //We are going to ignore the error so if there was a problem we will just
            //load all the standard MOFs.
            if (hRes != WBEM_E_OUT_OF_MEMORY)
                hRes = WBEM_S_NO_ERROR;
        }
    }

	return hRes;
}



HRESULT STDMETHODCALLTYPE CRepository::Logon(
      WMIDB_LOGON_TEMPLATE *pLogonParms,
      DWORD dwFlags,
      DWORD dwRequestedHandleType,
     IWmiDbSession **ppSession,
     IWmiDbHandle **ppRootNamespace
    )
{
    //If not initialized, initialize all subsystems...
    if (!g_Glob.IsInit())
    {
        HRESULT hres = Initialize();
        if (FAILED(hres))
            return hres;
    }
    
    CSession* pSession = new CSession(m_pControl);
	if (pSession == NULL)
		return WBEM_E_OUT_OF_MEMORY;
	pSession->AddRef();
	CReleaseMe rm1(pSession);

    CNamespaceHandle* pHandle = new CNamespaceHandle(m_pControl, this);
	if (pHandle == NULL)
		return WBEM_E_OUT_OF_MEMORY;
	pHandle->AddRef();
	CTemplateReleaseMe<CNamespaceHandle> rm2(pHandle);

    HRESULT hres = pHandle->Initialize(L"");
	if(FAILED(hres))
		return hres;

    *ppRootNamespace = pHandle;
	pHandle->AddRef();
    *ppSession = pSession;
	pSession->AddRef();

    return S_OK;
}

HRESULT STDMETHODCALLTYPE CRepository::GetLogonTemplate(
       LCID  lLocale,
       DWORD dwFlags,
      WMIDB_LOGON_TEMPLATE **ppLogonTemplate
    )
{
    WMIDB_LOGON_TEMPLATE* lt = (WMIDB_LOGON_TEMPLATE*)CoTaskMemAlloc(sizeof(WMIDB_LOGON_TEMPLATE));

    lt->dwArraySize = 0;
    lt->pParm = NULL;

    *ppLogonTemplate = lt;
    return S_OK;
}
    

HRESULT STDMETHODCALLTYPE CRepository::FreeLogonTemplate(
     WMIDB_LOGON_TEMPLATE **ppTemplate
    )
{
    CoTaskMemFree(*ppTemplate);
    *ppTemplate = NULL;
    return S_OK;
}

HRESULT STDMETHODCALLTYPE CRepository::Shutdown(
     DWORD dwFlags
    )
{
	g_bShuttingDown = true;     
    m_ShutDownFlags = dwFlags;

	//Trigger the flusher thread to shutdown
	SetEvent(m_hShutdownEvent);
	SetEvent(m_hWriteEvent);
	
	if (m_hFlusherThread)
		WaitForSingleObject(m_hFlusherThread, INFINITE);
	
    bool bUnlock = (CLock::NoError == g_readWriteLock.WriteLock());

	//Mark thread as dead
	m_threadState = ThreadStateDead;

    if (WMIDB_SHUTDOWN_MACHINE_DOWN != dwFlags)
    {
		if (g_pSystemClassNamespace)
			g_pSystemClassNamespace->Release();
		g_pSystemClassNamespace = NULL;

        g_Glob.GetForestCache()->Deinitialize();
    } 

	g_Glob.GetFileCache()->Flush();

	g_Glob.GetFileCache()->Uninitialize(dwFlags);


	if (WMIDB_SHUTDOWN_MACHINE_DOWN != dwFlags)
    {        
	    g_Glob.Deinitialize();
	    if (bUnlock)
            g_readWriteLock.WriteUnlock();
    }

	if (m_hShutdownEvent != NULL)
	{
		CloseHandle(m_hShutdownEvent);
		m_hShutdownEvent = NULL;
	}
	if (m_hWriteEvent != NULL)
	{
		CloseHandle(m_hWriteEvent);
		m_hWriteEvent = NULL;
	}
	if (m_hReadEvent != NULL)
	{
		CloseHandle(m_hReadEvent);
		m_hReadEvent = NULL;
	}
	if (m_hFlusherThread != NULL)
	{
		CloseHandle(m_hFlusherThread);
		m_hFlusherThread = NULL;
	}


    return S_OK;
}


HRESULT STDMETHODCALLTYPE CRepository::SetCallTimeout(
     DWORD dwMaxTimeout
    )
{
    return S_OK;
}

HRESULT STDMETHODCALLTYPE CRepository::SetCacheValue(
     DWORD dwMaxBytes
    )
{
    HKEY hKey;
    long lRes = RegOpenKeyExW(HKEY_LOCAL_MACHINE, 
                    L"SOFTWARE\\Microsoft\\WBEM\\CIMOM",
                    0, KEY_READ | KEY_WRITE, &hKey);
    if(lRes)
        return lRes;
    CRegCloseMe cm(hKey);
    DWORD dwLen = sizeof(DWORD);
    DWORD dwMaxAge;
    lRes = RegQueryValueExW(hKey, L"Max Class Cache Item Age (ms)", NULL, NULL, 
                (LPBYTE)&dwMaxAge, &dwLen);

    if(lRes != ERROR_SUCCESS)
    {
        dwMaxAge = 10000;
        lRes = RegSetValueExW(hKey, L"Max Class Cache Item Age (ms)", 0, 
                REG_DWORD, (LPBYTE)&dwMaxAge, sizeof(DWORD));
    }
    g_Glob.GetForestCache()->SetMaxMemory(dwMaxBytes, dwMaxAge);
    return S_OK;
}

HRESULT STDMETHODCALLTYPE CRepository::FlushCache(
     DWORD dwFlags
    )

{
    return S_OK;
}

HRESULT STDMETHODCALLTYPE CRepository::GetStatistics(
      DWORD  dwParameter,
     DWORD *pdwValue
    )
{
    return S_OK;
}

HRESULT STDMETHODCALLTYPE CRepository::GetRepositoryVersions(DWORD *pdwOldVersion, 
															 DWORD *pdwCurrentVersion)
{
	*pdwOldVersion = g_dwOldRepositoryVersion;
	*pdwCurrentVersion = g_dwCurrentRepositoryVersion;
	return S_OK;
}

HRESULT CRepository::GetNamespaceHandle(LPCWSTR wszNamespaceName,
                                    RELEASE_ME CNamespaceHandle** ppHandle)
{
    HRESULT hres;

    //
    // No validation --- that would be too hard.  Just create a handle and
    // return
    //

    CNamespaceHandle* pNewHandle = new CNamespaceHandle(m_pControl, this);
	if (pNewHandle == NULL)
		return WBEM_E_OUT_OF_MEMORY;

    pNewHandle->AddRef();
    CReleaseMe rm1(pNewHandle);

    hres = pNewHandle->Initialize(wszNamespaceName);
    if(FAILED(hres)) 
        return hres;

    *ppHandle = pNewHandle;
    pNewHandle->AddRef();
    return S_OK;
}

HRESULT CRepository::Backup(LPCWSTR wszBackupFile, long lFlags)
{
    HRESULT hRes = WBEM_S_NO_ERROR;

	// params have already been verified by the calling method (CWbemBackupRestore::DoBackup),
	// but do it again just in case things change and this is no longer the case
    if (NULL == wszBackupFile || (lFlags != 0))
        return WBEM_E_INVALID_PARAMETER;

    if (FAILED(hRes = LockRepository()))
    	return hRes;
	
    CRepositoryPackager packager;
    hRes = packager.PackageRepository(wszBackupFile);

    UnlockRepository();

	return hRes;
}
HRESULT CRepository::Restore(LPCWSTR wszBackupFile, long lFlags)
{
    return WBEM_E_NOT_SUPPORTED;
}


#define MaxTraceSizeBackup  (11)

struct BackUpTraces {
	DWORD ThreadId;	
	PVOID  Trace[MaxTraceSizeBackup];
} g_Backup[2];

LONG g_NumTimes;

HRESULT CRepository::LockRepository()
{
#ifdef _X86_
    DWORD * pDW = (DWORD *)_alloca(sizeof(DWORD));   
#endif
   //Lock the database so no one writes to it
   if (CLock::NoError != g_readWriteLock.WriteLock())
 	return WBEM_E_FAILED;

    ScopeGuard lockGuard = MakeObjGuard(g_readWriteLock, &CLock::WriteUnlock);

    if (g_bShuttingDown)
	{
        return WBEM_E_SHUTTING_DOWN;
	}

    InterlockedIncrement(&g_NumTimes);
    g_Backup[0].ThreadId = GetCurrentThreadId();
    ULONG Hash;
    RtlCaptureStackBackTrace(0,MaxTraceSizeBackup,g_Backup[0].Trace,&Hash);
    g_Backup[1].ThreadId = 0;	

    //We need to wait for the transaction manager write to flush...
    long lRes = g_Glob.GetFileCache()->Flush();
	if (lRes != ERROR_SUCCESS)
		return WBEM_E_FAILED;

    if (CLock::NoError != g_readWriteLock.DowngradeLock())
    	return WBEM_E_FAILED;

	lockGuard.Dismiss();
	return WBEM_S_NO_ERROR;
}

HRESULT CRepository::UnlockRepository()
{
#ifdef _X86_
    DWORD * pDW = (DWORD *)_alloca(sizeof(DWORD));   
#endif
	g_readWriteLock.ReadUnlock();

    InterlockedDecrement(&g_NumTimes);
    g_Backup[1].ThreadId = GetCurrentThreadId();
    ULONG Hash;
    RtlCaptureStackBackTrace(0,MaxTraceSizeBackup,g_Backup[1].Trace,&Hash);
    g_Backup[0].ThreadId = 0;	

	return WBEM_S_NO_ERROR;
}

#define A51REP_CACHE_FLUSH_TIMEOUT 60000
#define A51REP_THREAD_IDLE_TIMEOUT 60000

DWORD WINAPI CRepository::_FlusherThread(void *)
{
//	ERRORTRACE((LOG_REPDRV, "Flusher thread stated, thread = %lu\n", GetCurrentThreadId()));
	if (InterlockedIncrement(&m_threadCount) != 1)
	{
		ERRORTRACE((LOG_REPDRV, "Too many flusher threads detected in startup of thread!\n"));
		OutputDebugString(L"WinMgmt: Too many flusher threads detected in startup of thread!\n");
		DebugBreak();
	}
	HANDLE aHandles[2];
	aHandles[0] = m_hWriteEvent;
	aHandles[1] = m_hReadEvent;

	DWORD dwTimeout = INFINITE;
	LONG ulPreviousReadCount = m_ulReadCount;
	LONG ulPreviousWriteCount = m_ulWriteCount;
	bool bShutdownThread = false;

	while (!g_bShuttingDown && !bShutdownThread)
	{
		DWORD dwRet = WaitForMultipleObjects(2, aHandles, FALSE, dwTimeout);

		switch(dwRet)
		{
		case WAIT_OBJECT_0:	//Write event
		{
			dwRet = WaitForSingleObject(m_hShutdownEvent, 15000);
			switch (dwRet)
			{
			case WAIT_OBJECT_0:
				break;	//Shutting down, we cannot grab the lock so let the
						//initiator of shutdown do the flush for us
			case WAIT_TIMEOUT:
			{
				//We need to do a flush... either shutting down or idle
				CAutoWriteLock lock(&g_readWriteLock);
				if (lock.Lock())
				{
					if (g_Glob.GetFileCache()->Flush() != NO_ERROR)
					{
						RecoverCheckpoint();
					}
				}
				break;
			}
			case WAIT_FAILED:
				break;
			}

			//Transition to flush mode
			dwTimeout = A51REP_CACHE_FLUSH_TIMEOUT;
			ulPreviousReadCount = m_ulReadCount;
			m_threadState = ThreadStateFlush;
			break;
		}

		case WAIT_OBJECT_0+1:	//Read event
			//Reset the flush mode as read happened
			dwTimeout = A51REP_CACHE_FLUSH_TIMEOUT;
			ulPreviousReadCount = m_ulReadCount;
			m_threadState = ThreadStateFlush;
			break;

		case WAIT_TIMEOUT:	//Timeout, so flush caches
		{
			//Check for if we are in an idle shutdown state...
			m_cs.Enter();
			if (m_threadState == ThreadStateIdle)
			{
				m_threadState = ThreadStateDead;
				bShutdownThread = true;
			}
			m_cs.Leave();
			
			if (bShutdownThread)
				break;

			//Not thread shutdown, so we check for cache flush
			if (ulPreviousReadCount == m_ulReadCount)
			{
				//Mark the idle for the next phase so if another
				//request comes in while we are doing this we will
				//be brought out of the idle state...
				dwTimeout = A51REP_THREAD_IDLE_TIMEOUT;
				m_threadState = ThreadStateIdle;
				m_ulReadCount = 0;

				//Flush the caches
				CAutoWriteLock lock(&g_readWriteLock);
				if (lock.Lock())
				{
					g_Glob.GetForestCache()->Clear();
					g_Glob.GetFileCache()->EmptyCaches();

					//Recover the transaction manager if it has got into a bad state!
					g_Glob.GetFileCache()->RollbackCheckpointIfNeeded();
				}
			}
			else
			{
				//We need to sleep for some more as some more reads happened
				ulPreviousReadCount = m_ulReadCount;
				dwTimeout = A51REP_CACHE_FLUSH_TIMEOUT;
			}
			break;
		}
		}
	}

//	ERRORTRACE((LOG_REPDRV, "Flusher thread quiting, thread = %lu\n", GetCurrentThreadId()));
	if (InterlockedDecrement(&m_threadCount) != 0)
	{
		ERRORTRACE((LOG_REPDRV, "Too many flusher threads detected on shutdown of thread\n"));
		OutputDebugString(L"WinMgmt: Too many flusher threads detected on shutdown of thread!\n");
		DebugBreak();
	}
	return 0;
}

HRESULT CRepository::ReadOperationNotification()
{
//	ERRORTRACE((LOG_REPDRV, "Read Operation logged\n"));
	//Check to make sure the thread is active, if not we need to activate it!
	m_cs.Enter();
	if (m_threadState == ThreadStateDead)
	{
		m_threadState = ThreadStateOperationPending;
		if (m_hFlusherThread)
			CloseHandle(m_hFlusherThread);
		m_hFlusherThread = CreateThread(NULL, 0, _FlusherThread, 0, 0, NULL);
	}
	m_threadState = ThreadStateOperationPending;
	m_cs.Leave();
	if (InterlockedIncrement(&m_ulReadCount) == 1)
		SetEvent(m_hReadEvent);
	return NO_ERROR;
}
HRESULT CRepository::WriteOperationNotification()
{
//	ERRORTRACE((LOG_REPDRV, "Write Operation logged\n"));
	//Check to make sure the thread is active, if not we need to activate it!
	m_cs.Enter();
	if (m_threadState == ThreadStateDead)
	{
		m_threadState = ThreadStateOperationPending;
		if (m_hFlusherThread)
			CloseHandle(m_hFlusherThread);
		m_hFlusherThread = CreateThread(NULL, 0, _FlusherThread, 0, 0, NULL);
	}
	m_threadState = ThreadStateOperationPending;
	m_cs.Leave();
	SetEvent(m_hWriteEvent);
	return NO_ERROR;
}

HRESULT CRepository::RecoverCheckpoint()
{
	LONG lRes = g_Glob.GetFileCache()->RollbackCheckpoint();
	g_Glob.GetForestCache()->Clear();
	g_Glob.GetFileCache()->EmptyCaches();
	if (lRes != 0)
		return WBEM_E_FAILED;
	else
		return WBEM_S_NO_ERROR;
}


//
//
//
//
//////////////////////////////////////////////////////////////////////

CGlobals g_Glob;


HRESULT
CGlobals::Initialize()
{
    CInCritSec ics(&m_cs);
    
    if (m_bInit)
        return S_OK;

    HRESULT hRes;        

	hRes = CoCreateInstance(CLSID_IWmiCoreServices, NULL,
   			CLSCTX_INPROC_SERVER, IID__IWmiCoreServices,
				(void**)&m_pCoreServices);
				
	if (SUCCEEDED(hRes))
	{
	    hRes = m_ForestCache.Initialize();
	    if (SUCCEEDED(hRes))
	    {
    	    m_bInit = TRUE;
    	}
    	else
    	{
    	    m_pCoreServices->Release();
    	    m_pCoreServices = NULL;
    	}
	}
    
    return hRes;
}


HRESULT
CGlobals::Deinitialize()
{
    CInCritSec ics(&m_cs);
    
    if (!m_bInit)
        return S_OK;

    HRESULT hRes;

    m_pCoreServices->Release();
    m_pCoreServices = NULL;

    hRes = m_ForestCache.Deinitialize();

    m_bInit = FALSE;
    return hRes;
}


_IWmiCoreServices *
CGlobals::GetCoreSvcs()
{
    if (m_pCoreServices)
    {
        m_pCoreServices->AddRef();
    }
    return m_pCoreServices;
}

CForestCache * 
CGlobals::GetForestCache()
{
    return &m_ForestCache;
}

CFileCache *
CGlobals::GetFileCache()
{
    return &m_FileCache;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\xfiles\localloc.cpp ===
/*++

Copyright (C) 2000-2001 Microsoft Corporation

--*/

#include "precomp.h"
#include <arena.h>

void* __cdecl operator new ( size_t size )
{
    return CWin32DefaultArena::WbemMemAlloc( size );
}
    
void __cdecl operator delete ( void* pv )
{
    CWin32DefaultArena::WbemMemFree( pv );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\xfiles\filecach.h ===
//depot/private/wmi_branch2/admin/wmi/wbem/winmgmt/xfiles/filecach.h#8 - edit change 28793 (text)
/*++

Copyright (C) 2000-2001 Microsoft Corporation

--*/

#ifndef __WMI_A51_FILECACHE_H_
#define __WMI_A51_FILECACHE_H_

#include <set>
#include <string>

extern bool g_bShuttingDown;


#include "pagemgr.h"
#include "a51tools.h"
#include "objheap.h"
#include "index.h"

class CFileCache
{
protected:
    long m_lRef;
    BOOL m_bInit;

    CPageSource m_TransactionManager;
    
    CObjectHeap m_ObjectHeap;
    
    DWORD m_dwBaseNameLen;
    WCHAR m_wszBaseName[MAX_PATH+1]; // be debugger friendly, live it last

public:

protected:

public:
    CFileCache();
    ~CFileCache();
private:    
    void Clear(DWORD dwShutDownFlags)
	{    
		m_ObjectHeap.Uninitialize(dwShutDownFlags);
		m_TransactionManager.Shutdown(dwShutDownFlags);
	}

public:    
	long Flush()
	{
		if (!m_bInit) return ERROR_SERVER_SHUTDOWN_IN_PROGRESS;
		return m_TransactionManager.Checkpoint();
	}

	long RollbackCheckpoint()
	{
		if (!m_bInit) return ERROR_SERVER_SHUTDOWN_IN_PROGRESS;
		return m_TransactionManager.CheckpointRollback();
	}
	long RollbackCheckpointIfNeeded()
	{
		if (!m_bInit) return ERROR_SERVER_SHUTDOWN_IN_PROGRESS;
		if (m_TransactionManager.GetStatus())
			return m_TransactionManager.CheckpointRollback();
		else
			return 0;
	}

    long Initialize(LPCWSTR wszBaseName);
    long Uninitialize(DWORD dwShutDownFlags);
    
private:    
    long InnerInitialize(LPCWSTR wszBaseName);    
    long RepositoryExists(LPCWSTR wszBaseName);
public:   
	//Write 1 or 2 indexes pointing to the object in the object store
	long WriteObject(LPCWSTR wszFileName1, LPCWSTR wszFileName2, DWORD dwLen, BYTE* pBuffer)
	{
		if (!m_bInit) return ERROR_SERVER_SHUTDOWN_IN_PROGRESS;
		if (g_bShuttingDown) return ERROR_SERVER_SHUTDOWN_IN_PROGRESS;
		return m_ObjectHeap.WriteObject(wszFileName1, wszFileName2, dwLen, pBuffer);
	}

	//Writes a link and no object
	long WriteLink(LPCWSTR wszLinkName)
	{
		if (!m_bInit) return ERROR_SERVER_SHUTDOWN_IN_PROGRESS;
		if (g_bShuttingDown) return ERROR_SERVER_SHUTDOWN_IN_PROGRESS;
		return m_ObjectHeap.WriteLink(wszLinkName);
	}
    
	//Retrieve a buffer based on the index
	HRESULT ReadObject(LPCWSTR wszFileName, DWORD* pdwLen, BYTE** ppBuffer, bool bMustBeThere = false)
	{
		if (!m_bInit) return ERROR_SERVER_SHUTDOWN_IN_PROGRESS;
		if (g_bShuttingDown) return ERROR_SERVER_SHUTDOWN_IN_PROGRESS;
		return m_ObjectHeap.ReadObject(wszFileName, pdwLen, ppBuffer);
	}

	//Deletion of an object deletes the link also
	long DeleteObject(LPCWSTR wszFileName)
	{
		if (!m_bInit) return ERROR_SERVER_SHUTDOWN_IN_PROGRESS;
		if (g_bShuttingDown) return ERROR_SERVER_SHUTDOWN_IN_PROGRESS;
		return m_ObjectHeap.DeleteObject(wszFileName);
	}
	//Deletion of a link does not touch the object heap
	long DeleteLink(LPCWSTR wszLinkName)
	{
		if (!m_bInit) return ERROR_SERVER_SHUTDOWN_IN_PROGRESS;
		if (g_bShuttingDown) return ERROR_SERVER_SHUTDOWN_IN_PROGRESS;
		return m_ObjectHeap.DeleteLink(wszLinkName);
	}

	long BeginTransaction()
	{
		if (!m_bInit) return ERROR_SERVER_SHUTDOWN_IN_PROGRESS;
		if (g_bShuttingDown) return ERROR_SERVER_SHUTDOWN_IN_PROGRESS;
		return m_TransactionManager.BeginTrans();
	}
	long CommitTransaction()
	{
		if (!m_bInit) return ERROR_SERVER_SHUTDOWN_IN_PROGRESS;
		return m_TransactionManager.CommitTrans();
	}
	long AbortTransaction()
	{
		if (!m_bInit) return ERROR_SERVER_SHUTDOWN_IN_PROGRESS;
		long lRes = m_TransactionManager.RollbackTrans();
		if(lRes != ERROR_SUCCESS) return lRes;
		m_ObjectHeap.InvalidateCache();
		return ERROR_SUCCESS;
	}

    long AddRef() {return InterlockedIncrement(&m_lRef);}
    long Release() {long lRet = InterlockedDecrement(&m_lRef); if (!lRet) delete this;return lRet;}

	//Object enumeration methods that allow us to enumerate a set of objects and the
	//result is the heap object itself rather than just the path
	long ObjectEnumerationBegin(const wchar_t *wszSearchPrefix, void **ppHandle)
	{
		if (!m_bInit) return ERROR_SERVER_SHUTDOWN_IN_PROGRESS;
		if (g_bShuttingDown) return ERROR_SERVER_SHUTDOWN_IN_PROGRESS;
		return m_ObjectHeap.ObjectEnumerationBegin(wszSearchPrefix, ppHandle);
	}

	long ObjectEnumerationEnd(void *pHandle)
	{
		if (!m_bInit)return ERROR_SERVER_SHUTDOWN_IN_PROGRESS;
		if (g_bShuttingDown) return ERROR_SERVER_SHUTDOWN_IN_PROGRESS;
		return m_ObjectHeap.ObjectEnumerationEnd(pHandle);
	}
	long ObjectEnumerationNext(void *pHandle, CFileName &wszFileName, BYTE **ppBlob, DWORD *pdwSize)
	{
		if (!m_bInit) return ERROR_SERVER_SHUTDOWN_IN_PROGRESS;
		if (g_bShuttingDown) return ERROR_SERVER_SHUTDOWN_IN_PROGRESS;
		return m_ObjectHeap.ObjectEnumerationNext(pHandle, wszFileName, ppBlob, pdwSize);
	}
	long ObjectEnumerationFree(void *pHandle, BYTE *pBlob)
	{
		if (!m_bInit) return ERROR_SERVER_SHUTDOWN_IN_PROGRESS;
		return m_ObjectHeap.ObjectEnumerationFree(pHandle, pBlob);
	}

	//Index enumeration methods for iterating through the index
	long IndexEnumerationBegin(const wchar_t *wszSearchPrefix, void **ppHandle)
	{
		if (!m_bInit) return ERROR_SERVER_SHUTDOWN_IN_PROGRESS;
		if (g_bShuttingDown) return ERROR_SERVER_SHUTDOWN_IN_PROGRESS;
		return m_ObjectHeap.IndexEnumerationBegin(wszSearchPrefix, ppHandle);
	}
	long IndexEnumerationEnd(void *pHandle)
	{
		if (!m_bInit) return ERROR_SERVER_SHUTDOWN_IN_PROGRESS;
		if (g_bShuttingDown) return ERROR_SERVER_SHUTDOWN_IN_PROGRESS;
		return m_ObjectHeap.IndexEnumerationEnd(pHandle);
	}
	long IndexEnumerationNext(void *pHandle, CFileName &wszFileName)
	{
		if (!m_bInit) return ERROR_SERVER_SHUTDOWN_IN_PROGRESS;
		if (g_bShuttingDown) return ERROR_SERVER_SHUTDOWN_IN_PROGRESS;
		return m_ObjectHeap.IndexEnumerationNext(pHandle, wszFileName);
	}
	long EmptyCaches()
	{
		if (!m_bInit) return ERROR_SERVER_SHUTDOWN_IN_PROGRESS;
		long lRes = m_TransactionManager.EmptyCaches();
		if (lRes == 0)
			lRes = m_ObjectHeap.FlushCaches();

		return lRes;
	}
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\xfiles\hiecache.cpp ===
/*++

Copyright (C) 2000-2001 Microsoft Corporation

--*/

#include <wbemcomn.h>
#include "hiecache.h"
#include <creposit.h>
#include <malloc.h>
#include <corex.h>

extern bool g_bShuttingDown;

long CHierarchyCache::s_nCaches = 0;

long CClassRecord::s_nRecords = 0;

//
//
//  CClassRecord::CClassRecord
//
////////////////////////////////////////////////////////////////////

CClassRecord::CClassRecord(LPCWSTR wszClassName, LPCWSTR wszHash)
    : m_wszClassName(NULL), m_pClassDef(NULL), m_pParent(NULL), 
        m_eIsKeyed(e_KeynessUnknown), m_bTreeComplete(false), 
        m_bChildrenComplete(false),
        m_lLastChildInvalidationIndex(-1), m_pMoreRecentlyUsed(NULL),
        m_pLessRecentlyUsed(NULL), m_lRef(0), m_nStatus(0), m_bSystemClass(false)
{
    m_wszClassName = new WCHAR[wcslen(wszClassName)+1];
	if (m_wszClassName == NULL)
		throw CX_MemoryException();
    wcscpy(m_wszClassName, wszClassName);

    wcscpy(m_wszHash, wszHash);

    m_dwLastUsed = GetTickCount();
	s_nRecords++;
}

CClassRecord::~CClassRecord()
{
    delete [] m_wszClassName;
    if(m_pClassDef)
	{
		if(m_pClassDef->Release() != 0)
		{
			s_nRecords++;
			s_nRecords--;
		}
    }
	s_nRecords--;
}

HRESULT CClassRecord::EnsureChild(CClassRecord* pChild)
{
    A51TRACE(("Make %S child of %S\n", pChild->m_wszClassName,
            m_wszClassName));
    for(int i = 0; i < m_apChildren.GetSize(); i++)
    {
        if(m_apChildren[i] == pChild)
            return WBEM_S_FALSE;
    }
    
    if(m_apChildren.Add(pChild) < 0)
        return WBEM_E_OUT_OF_MEMORY;

    return WBEM_S_NO_ERROR;
}

HRESULT CClassRecord::RemoveChild(CClassRecord* pChild)
{
    A51TRACE(("Make %S NOT child of %S\n", 
                    pChild->m_wszClassName, m_wszClassName));
    for(int i = 0; i < m_apChildren.GetSize(); i++)
    {
        if(m_apChildren[i] == pChild)
        {
            m_apChildren.RemoveAt(i);
            return WBEM_S_NO_ERROR;
        }
    }
    
    return WBEM_E_NOT_FOUND;
}
        
//
//
//    CHierarchyCache::CHierarchyCache
//
/////////////////////////////////////////////////////////////////////
    
CHierarchyCache::CHierarchyCache(CForestCache* pForest)
    : m_pForest(pForest), m_lNextInvalidationIndex(0), m_lRef(0),
        m_hresError(S_OK)
{
	s_nCaches++;
}

CHierarchyCache::~CHierarchyCache()
{
    Clear();
	s_nCaches--;
}

void CHierarchyCache::Clear()
{
    LockGuard<CriticalSection> gl(m_pForest->GetLock());
    if(gl.locked() == false)
        return;    
    
    TIterator it = m_map.begin();
    while(it != m_map.end())
    {
        CClassRecord* pRecord = it->second;
        m_pForest->RemoveRecord(pRecord);
        it = m_map.erase(it);
        pRecord->Release();
    }
}

void CHierarchyCache::SetError(HRESULT hresError)
{
    m_hresError = hresError;
}

HRESULT CHierarchyCache::GetError()
{
    return m_hresError;
}

void CHierarchyCache::MakeKey(LPCWSTR wszClassName, LPWSTR wszKey)
{
    // wbem_wcsupr(wszKey, wszClassName);
    A51Hash(wszClassName, wszKey);
}

INTERNAL CClassRecord* CHierarchyCache::FindClass(LPCWSTR wszClassName)
{
    LockGuard<CriticalSection> gl(m_pForest->GetLock());
    if(gl.locked() == false)
        return NULL;    

    LPWSTR wszKey = (WCHAR*)TempAlloc((MAX_HASH_LEN+2) * sizeof(WCHAR));
	if (wszKey == NULL)
		return NULL;
	CTempFreeMe tfm(wszKey, (MAX_HASH_LEN+2) * sizeof(WCHAR));
    MakeKey(wszClassName, wszKey);

    return FindClassByKey(wszKey);
}

INTERNAL CClassRecord* CHierarchyCache::FindClassByKey(LPCWSTR wszKey)
{
    TIterator it = m_map.find(wszKey);
    if(it == m_map.end())
        return NULL;

    return it->second;
}

INTERNAL CClassRecord* CHierarchyCache::EnsureClass(LPCWSTR wszClassName)
{
    LockGuard<CriticalSection> gl(m_pForest->GetLock());
    if(gl.locked() == false)
        return NULL;    

    LPWSTR wszKey = (WCHAR*)TempAlloc((MAX_HASH_LEN+2) * sizeof(WCHAR));
	if (wszKey == NULL)
		return NULL;
	CTempFreeMe tfm(wszKey, (MAX_HASH_LEN+2) * sizeof(WCHAR));
    MakeKey(wszClassName, wszKey);

    TIterator it = m_map.find(wszKey);
    if(it == m_map.end())
    {
        //
        // Create a new record with the name
        //

		try
		{
			CClassRecord* pRecord = new CClassRecord(wszClassName, wszKey);
			if(pRecord == NULL)
				return NULL;

		    pRecord->AddRef(); // one for the map			
    		m_map[pRecord->m_wszHash] = pRecord;			

			return pRecord;
		}
		catch (CX_MemoryException)
		{
			return NULL;
		}
    }
    else
    {
        return it->second;
    }
}


HRESULT CHierarchyCache::AssertClass(_IWmiObject* pClass, LPCWSTR wszClassName,
                                    bool bClone, __int64 nTime, bool bSystemClass)
{
    LockGuard<CriticalSection> gl(m_pForest->GetLock());
    if(gl.locked() == false)
        return WBEM_E_TIMED_OUT;

    HRESULT hres;

    m_pForest->MarkAsserted(this, wszClassName);

    //
    // If no record is given, find one
    //

    CClassRecord* pRecord = NULL;

    if(wszClassName == NULL)
    {
        VARIANT v;
        VariantInit(&v);
        CClearMe cm(&v);

        hres = pClass->Get(L"__CLASS", 0, &v, NULL, NULL);
        if(FAILED(hres) || V_VT(&v) != VT_BSTR)
            return WBEM_E_INVALID_CLASS;

        pRecord = EnsureClass(V_BSTR(&v));
    }
    else
        pRecord = EnsureClass(wszClassName);

    if(pRecord == NULL)
        return WBEM_E_OUT_OF_MEMORY;

    //
    // Figure out the parent
    //

    A51TRACE(("%p: Asserting %S on %I64d with %I64d\n", 
                    this, pRecord->m_wszClassName, g_nCurrentTime, nTime));

    VARIANT v;
    VariantInit(&v);
    hres = pClass->Get(L"__SUPERCLASS", 0, &v, NULL, NULL);
    CClearMe cm(&v);

    if(SUCCEEDED(hres))
    {
        if(V_VT(&v) == VT_BSTR)
            pRecord->m_pParent = EnsureClass(V_BSTR(&v));
        else
            pRecord->m_pParent = EnsureClass(L"");

        if(pRecord->m_pParent)
            pRecord->m_pParent->EnsureChild(pRecord);
    }
    else
    {
        return hres;
    }
    
    //
    // Check if the class is keyed
    //

    unsigned __int64 i64Flags = 0;
    hres = pClass->QueryObjectFlags(0, WMIOBJECT_GETOBJECT_LOFLAG_KEYED,
                                    &i64Flags);
    if(FAILED(hres))
        return hres;

    if(i64Flags)
    {
        pRecord->m_eIsKeyed = e_Keyed;
    }
    else
    {
        pRecord->m_eIsKeyed = e_NotKeyed;
    }
     
    //
    // Expell whatever definition is there from the cache
    //

    m_pForest->RemoveRecord(pRecord);

    //  
    // Figure out how much space this object will take
    //

    DWORD dwSize;
    hres = pClass->GetObjectMemory(NULL, 0, &dwSize);
    if(hres != WBEM_E_BUFFER_TOO_SMALL)
    {
        if(SUCCEEDED(hres))
            return WBEM_E_CRITICAL_ERROR;
        else
            return hres;
    }

    //
    // Good.  Make room and add to cache
    //

    if(m_pForest->MakeRoom(dwSize))
    {
        if(bClone)
        {
            IWbemClassObject* pObj = NULL;
            hres = pClass->Clone(&pObj);
            if(FAILED(hres))
                return hres;

            if(pObj)
            {
                pObj->QueryInterface(IID__IWmiObject, 
                                        (void**)&pRecord->m_pClassDef);
                pObj->Release();
            }
        }
        else
        {   pRecord->m_pClassDef = pClass;
            pClass->AddRef();
        }

        if(nTime)
        {
            pRecord->m_bRead = true;
            pRecord->m_nClassDefCachedTime = nTime;
        }
        else
        {
            pRecord->m_bRead = false;
            pRecord->m_nClassDefCachedTime = g_nCurrentTime++;
        }

        pRecord->m_dwClassDefSize = dwSize;

		pRecord->m_bSystemClass = bSystemClass;
        
        //
        // It is most recently used, of course
        //

        m_pForest->Add(pRecord);
    }
    
    return WBEM_S_NO_ERROR;
    
}

HRESULT CHierarchyCache::InvalidateClass(LPCWSTR wszClassName)
{
    LockGuard<CriticalSection> gl(m_pForest->GetLock());
    if(gl.locked() == false)
        return WBEM_E_TIMED_OUT;    

    HRESULT hres;

    //
    // Find the record if not given
    //

    CClassRecord* pRecord = NULL;
    pRecord = FindClass(wszClassName);
    if(pRecord == NULL)
    {
        // 
        // The record is not there --- there is nothing to invalidate.  This
        // is based on the assumption that if a class record is in the 
        // cache, then so are all its parents, which is true at the moment
        // because in order to construct a class we need to retrieve its
        // parents first.
        //

        return WBEM_S_FALSE;
    }

    pRecord->AddRef();
    CTemplateReleaseMe<CClassRecord> rm1(pRecord);

    LONGLONG lThisInvalidationIndex = m_lNextInvalidationIndex++;

    hres = InvalidateClassInternal(pRecord);

    //
    // Clear complete bits in all our parents, since this invalidation
    // means that no current enumeration of children can be trusted. At the same
    // time untie ourselves from the parent!
    //
    
    if(pRecord->m_pParent)
    {
        pRecord->m_pParent->m_bChildrenComplete = false;
        pRecord->m_pParent->m_bTreeComplete = false;
        pRecord->m_pParent->m_lLastChildInvalidationIndex = 
            lThisInvalidationIndex;
        pRecord->m_pParent->RemoveChild(pRecord);

        CClassRecord* pCurrent = pRecord->m_pParent->m_pParent;
        while(pCurrent)
        {
            pCurrent->m_bTreeComplete = false;
            pCurrent = pCurrent->m_pParent;
        }
    }

    return S_OK;
}


HRESULT CHierarchyCache::InvalidateClassInternal(CClassRecord* pRecord)
{
    //
    // Untie from the usage chain
    //

    A51TRACE(("%p: Invalidating %S on %I64d with %d children\n",
                    this, pRecord->m_wszClassName, g_nCurrentTime,
                    pRecord->m_apChildren.GetSize()));
    
    //
    // Remove all its children from the cache
    //

    for(int i = 0; i < pRecord->m_apChildren.GetSize(); i++)
    {
        InvalidateClassInternal(pRecord->m_apChildren[i]);
    }

    pRecord->m_apChildren.RemoveAll();

    //
    // Count ourselves out of the total memory
    //

    m_pForest->RemoveRecord(pRecord);

    //
    // Remove ourselves from the cache
    //

    m_map.erase(pRecord->m_wszHash);
	pRecord->Release();

    return S_OK;
}

HRESULT CHierarchyCache::DoneWithChildren(LPCWSTR wszClassName, bool bRecursive,
                                LONGLONG lStartIndex, CClassRecord* pRecord)
{
    LockGuard<CriticalSection> gl(m_pForest->GetLock());
    if(gl.locked() == false)
        return WBEM_E_TIMED_OUT;    

    HRESULT hres;

    //
    // Find the record if not given
    //

    if(pRecord == NULL)
    {
        pRecord = FindClass(wszClassName);
        if(pRecord == NULL)
        {
            // Big time invalidation must have occurred
            return WBEM_S_FALSE;
        }
    }

    return DoneWithChildrenByRecord(pRecord, bRecursive, lStartIndex);
}

HRESULT CHierarchyCache::DoneWithChildrenByHash(LPCWSTR wszHash, 
                                bool bRecursive, LONGLONG lStartIndex)
{
    LockGuard<CriticalSection> gl(m_pForest->GetLock());
    if(gl.locked() == false)
        return WBEM_E_TIMED_OUT;    

    HRESULT hres;

    //
    // Find the record if not given
    //

    CClassRecord* pRecord = FindClassByKey(wszHash);
    if(pRecord == NULL)
    {
        // Big time invalidation must have occurred
        return WBEM_S_FALSE;
    }

    return DoneWithChildrenByRecord(pRecord, bRecursive, lStartIndex);
}

HRESULT CHierarchyCache::DoneWithChildrenByRecord(CClassRecord* pRecord,
                                bool bRecursive,  LONGLONG lStartIndex)
{
    //  
    // Check if any child invalidations occurred in this node since we started
    //

    if(lStartIndex < pRecord->m_lLastChildInvalidationIndex)
        return WBEM_S_FALSE;
    else
        pRecord->m_bChildrenComplete = true;
    
    if(bRecursive)
    {
        //
        // We have completed a recursive enumeration --- descend the 
        // hierarchy and mark as complete all the children that have not been
        // modified since the start
        //

        bool bAllValid = true;
        for(int i = 0; i < pRecord->m_apChildren.GetSize(); i++)
        {
            CClassRecord* pChildRecord = pRecord->m_apChildren[i];
            HRESULT hres = DoneWithChildren(pChildRecord->m_wszClassName, true, 
                                    lStartIndex, pChildRecord);
    
            if(hres != S_OK)
                bAllValid = false;
        }
    
        if(bAllValid)
        {
            //
            // There were no invalidations anywhere in the tree, which makes
            // this record tree-complete
            //

            pRecord->m_bTreeComplete = true;
            return WBEM_S_NO_ERROR;
        }
        else
            return S_FALSE;
    }
    else
        return WBEM_S_NO_ERROR;
}


RELEASE_ME _IWmiObject* CHierarchyCache::GetClassDef(LPCWSTR wszClassName,
                                                bool bClone, __int64* pnTime,
                                                bool* pbRead)
{
    LockGuard<CriticalSection> gl(m_pForest->GetLock());
    if(gl.locked() == false)
        return NULL;

    CClassRecord* pRecord = FindClass(wszClassName);
    if(pRecord == NULL)
        return NULL;

    if(pnTime)
        *pnTime = pRecord->m_nClassDefCachedTime;

    if(pbRead)
        *pbRead = pRecord->m_bRead;

    return GetClassDefFromRecord(pRecord, bClone);
}

RELEASE_ME _IWmiObject* CHierarchyCache::GetClassDefByHash(LPCWSTR wszHash,
                                                bool bClone, __int64* pnTime,
                                                bool* pbRead, bool *pbSystemClass)
{
    LockGuard<CriticalSection> gl(m_pForest->GetLock());
    if(gl.locked() == false)
        return NULL;    

    CClassRecord* pRecord = FindClassByKey(wszHash);
    if(pRecord == NULL)
        return NULL;

    if(pbRead)
        *pbRead = pRecord->m_bRead;

    if(pnTime)
        *pnTime = pRecord->m_nClassDefCachedTime;
	
	if (pbSystemClass)
		*pbSystemClass = pRecord->m_bSystemClass;

    return GetClassDefFromRecord(pRecord, bClone);
}

// assumes: in m_cs
RELEASE_ME _IWmiObject* CHierarchyCache::GetClassDefFromRecord(
                                                CClassRecord* pRecord,
                                                bool bClone)
{
    //
    // Accessing m_pClassDef, so we have to lock the forest
    //
    LockGuard<CriticalSection> gl(m_pForest->GetLock());
    if(gl.locked() == false)
        return NULL;

    if(pRecord->m_pClassDef)
    {
        m_pForest->MakeMostRecentlyUsed(pRecord);

        if(bClone)
        {
            IWbemClassObject* pObj = NULL;
            if(FAILED(pRecord->m_pClassDef->Clone(&pObj)))
                return NULL;
            else
            {
                _IWmiObject* pRes = NULL;
                pObj->QueryInterface(IID__IWmiObject, (void**)&pRes);
                pObj->Release();
                return pRes;
            }
        }
        else
        {
            pRecord->m_pClassDef->AddRef();
            return pRecord->m_pClassDef;
        }
    }
    else
        return NULL;
}

HRESULT CHierarchyCache::EnumChildren(LPCWSTR wszClassName, bool bRecursive,
                            CWStringArray& awsChildren)
{
    LockGuard<CriticalSection> gl(m_pForest->GetLock());
    if(gl.locked() == false)
        return WBEM_E_TIMED_OUT;    

    //
    // Get the record
    //

    CClassRecord* pRecord = FindClass(wszClassName);
    if(pRecord == NULL)
        return WBEM_S_FALSE;

    //
    // Check if it is complete for this type of enumeration
    //

    if(!pRecord->m_bChildrenComplete)
        return WBEM_S_FALSE;

    if(bRecursive && !pRecord->m_bTreeComplete)
        return WBEM_S_FALSE;

    return EnumChildrenInternal(pRecord, bRecursive, awsChildren);
}

HRESULT CHierarchyCache::EnumChildrenInternal(CClassRecord* pRecord, 
                                        bool bRecursive,
                                        CWStringArray& awsChildren)
{
    for(int i = 0; i < pRecord->m_apChildren.GetSize(); i++)
    {
        CClassRecord* pChildRecord = pRecord->m_apChildren[i];
        if(awsChildren.Add(pChildRecord->m_wszClassName) < 0)
            return WBEM_E_OUT_OF_MEMORY;
        
        if(bRecursive)
        {
            HRESULT hres = EnumChildrenInternal(pChildRecord, bRecursive, 
                                                    awsChildren);
            if(FAILED(hres))
                return hres;
        }
    }

    return WBEM_S_NO_ERROR;
}

HRESULT CHierarchyCache::EnumChildKeysByKey(LPCWSTR wszClassKey, 
                            CWStringArray& awsChildKeys)
{
    LockGuard<CriticalSection> gl(m_pForest->GetLock());
    if(gl.locked() == false)
        return WBEM_E_TIMED_OUT;

    //
    // Get the record
    //

    CClassRecord* pRecord = FindClassByKey(wszClassKey);
    if(pRecord == NULL)
        return WBEM_S_FALSE;

    //
    // Check if it is complete for this type of enumeration
    //

    if(!pRecord->m_bChildrenComplete)
        return WBEM_S_FALSE;

    for(int i = 0; i < pRecord->m_apChildren.GetSize(); i++)
    {
        CClassRecord* pChildRecord = pRecord->m_apChildren[i];
        if(awsChildKeys.Add(pChildRecord->m_wszHash) < 0)
            return WBEM_E_OUT_OF_MEMORY;
    }

    return WBEM_S_NO_ERROR;
}

 
HRESULT CHierarchyCache::GetKeyRoot(LPCWSTR wszClassName, 
                                    TEMPFREE_ME LPWSTR* pwszKeyRoot)
{
    LockGuard<CriticalSection> gl(m_pForest->GetLock());
    if(gl.locked() == false)
        return WBEM_E_TIMED_OUT;
    
    CClassRecord* pRecord = FindClass(wszClassName);
    if(pRecord == NULL)
        return WBEM_E_NOT_FOUND;

    return GetKeyRootByRecord(pRecord, pwszKeyRoot);
}

// assumes: in cs
HRESULT CHierarchyCache::GetKeyRootByRecord(CClassRecord* pRecord,
                                    TEMPFREE_ME LPWSTR* pwszKeyRoot)
{
    *pwszKeyRoot = NULL;

    if(pRecord->m_eIsKeyed == e_NotKeyed)
        return WBEM_E_CANNOT_BE_ABSTRACT;

    //
    // Go up until an unkeyed record is found.  Keep the previous in pPrev
    //

	CClassRecord* pPrev = pRecord;
    while(pRecord && pRecord->m_eIsKeyed == e_Keyed)
	{
		pPrev = pRecord;
        pRecord = pRecord->m_pParent;
	}

    if(pRecord && pRecord->m_eIsKeyed == e_NotKeyed)
    {
        //
        // Found unkeyed parent --- pPrev is the root
        //

        LPCWSTR wszKeyRoot = pPrev->m_wszClassName;
        DWORD dwLen = (wcslen(wszKeyRoot)+1) * sizeof(WCHAR);
        *pwszKeyRoot = (WCHAR*)TempAlloc(dwLen);
		if (*pwszKeyRoot == NULL)
			return WBEM_E_OUT_OF_MEMORY;
        wcscpy(*pwszKeyRoot, wszKeyRoot);
        return S_OK;
    }
    else
    {
        //
        // No unkeyed parents --- since "" is known to be unkeyed, we had have
        // hit a gap in the cache
        //

        return WBEM_E_NOT_FOUND;
    }
}

HRESULT CHierarchyCache::GetKeyRootByKey(LPCWSTR wszKey, 
                                    TEMPFREE_ME LPWSTR* pwszKeyRoot)
{
    LockGuard<CriticalSection> gl(m_pForest->GetLock());
    if(gl.locked() == false)
        return WBEM_E_TIMED_OUT;
    
    CClassRecord* pRecord = FindClassByKey(wszKey);
    if(pRecord == NULL)
        return WBEM_E_NOT_FOUND;

    return GetKeyRootByRecord(pRecord, pwszKeyRoot);
}

DELETE_ME LPWSTR CHierarchyCache::GetParent(LPCWSTR wszClassName)
{
    LockGuard<CriticalSection> gl(m_pForest->GetLock());
    if(gl.locked() == false)
        return NULL;
    
    CClassRecord* pRecord = FindClass(wszClassName);
    if(pRecord == NULL)
        return NULL;

    if(pRecord->m_pParent)
    {
        LPCWSTR wszParent = pRecord->m_pParent->m_wszClassName;
        LPWSTR wszCopy = new WCHAR[wcslen(wszParent)+1];
		if (wszCopy == NULL)
			return NULL;
        wcscpy(wszCopy, wszParent);
        return wszCopy;
    }
    else
        return NULL;
}

//
//
//  CForestCache
//
//////////////////////////////////////////////////////////////////////

HRESULT CForestCache::Initialize()
{
    LockGuard<CriticalSection> gl(m_cs);
    if(gl.locked() == false)
        return WBEM_E_TIMED_OUT;
        
    if (m_bInit)
        return S_OK;

    //
    // Read the size limits from the registry
    //

    HKEY hKey;
    long lRes = RegOpenKeyExW(HKEY_LOCAL_MACHINE, 
                    L"SOFTWARE\\Microsoft\\WBEM\\CIMOM",
                    0, KEY_READ | KEY_WRITE, &hKey);
    if(lRes)
        return lRes;
    CRegCloseMe cm(hKey);

    DWORD dwLen = sizeof(DWORD);
    DWORD dwMaxSize;
    lRes = RegQueryValueExW(hKey, L"Max Class Cache Size", NULL, NULL, 
                (LPBYTE)&dwMaxSize, &dwLen);

    //
    // If not there, set to default and write the default into the registry
    //

    if(lRes != ERROR_SUCCESS)
    {
        dwMaxSize = 5000000;
        lRes = RegSetValueExW(hKey, L"Max Class Cache Size", 0, REG_DWORD, 
                (LPBYTE)&dwMaxSize, sizeof(DWORD));
    }

    //
    // Read the maximum useful age of an item
    //

    dwLen = sizeof(DWORD);
    DWORD dwMaxAge;
    lRes = RegQueryValueExW(hKey, L"Max Class Cache Item Age (ms)", NULL, NULL, 
                (LPBYTE)&dwMaxAge, &dwLen);

    //
    // If not there, set to default and write the default into the registry
    //

    if(lRes != ERROR_SUCCESS)
    {
        dwMaxAge = 10000;
        lRes = RegSetValueExW(hKey, L"Max Class Cache Item Age (ms)", 0, 
                REG_DWORD, (LPBYTE)&dwMaxAge, sizeof(DWORD));
    }


    //
    // Apply
    //

    SetMaxMemory(dwMaxSize, dwMaxAge);

    //
    // Create a timer queue for flushing
    //

    //m_hTimerQueue = CreateTimerQueue();
    //m_hCompletionEvent = CreateEvent(NULL, FALSE, FALSE, NULL);

    m_bInit = TRUE;

    return WBEM_S_NO_ERROR;
}


bool CForestCache::MakeRoom(DWORD dwSize)
{
    LockGuard<CriticalSection> gl(m_cs);
    if(gl.locked() == false)
        return false;
    
    if (!m_bInit)
        return false;    

    if(dwSize > m_dwMaxMemory)
        return false; // no hope!

    //  
    // Remove records until satisfied. Also, remove all records older than the
    // maximum age
    //

    DWORD dwNow = GetTickCount();

    while(m_pLeastRecentlyUsed && 
            (m_dwTotalMemory + dwSize > m_dwMaxMemory ||
             dwNow - m_pLeastRecentlyUsed->m_dwLastUsed > m_dwMaxAgeMs)
         )
    {
		RemoveRecord(m_pLeastRecentlyUsed);
    }

    return true;
}

bool CForestCache::Flush()
{
    LockGuard<CriticalSection> gl(m_cs);
    if(gl.locked() == false)
        return false;
        
    if (!m_bInit)
        return false;
    
    while(m_pLeastRecentlyUsed)
    {
		RemoveRecord(m_pLeastRecentlyUsed);
    }

    return true;
}

//
//
//  Test Only Function NOT IN REGULAR CODE
//
///////////////////////////////////////////////////////////////


bool CForestCache::Test()
{
	if(m_pMostRecentlyUsed == NULL)
	{
		if(m_pLeastRecentlyUsed)
			DebugBreak();
		return true;
	}

	if(m_pMostRecentlyUsed->m_pMoreRecentlyUsed)
		DebugBreak();

	CClassRecord* pOne = m_pMostRecentlyUsed;
	CClassRecord* pTwo = m_pMostRecentlyUsed->m_pLessRecentlyUsed;

	while(pOne && pOne != pTwo)
	{
		if(pOne->m_pLessRecentlyUsed && pOne->m_pLessRecentlyUsed->m_pMoreRecentlyUsed != pOne)
			DebugBreak();
		if(pOne->m_pClassDef == NULL)
			DebugBreak();

		if(pOne->m_pLessRecentlyUsed == NULL && pOne != m_pLeastRecentlyUsed)
			DebugBreak();
		
		pOne = pOne->m_pLessRecentlyUsed;
		if(pTwo)
			pTwo = pTwo->m_pLessRecentlyUsed;
		if(pTwo)
			pTwo = pTwo->m_pLessRecentlyUsed;
	}
	if(pOne)
		DebugBreak();
	return true;
}
        
void CForestCache::MakeMostRecentlyUsed(CClassRecord* pRecord)
{
    LockGuard<CriticalSection> gl(m_cs);
    if(gl.locked() == false)
        return;

	//Test();
	Untie(pRecord);

	pRecord->m_pMoreRecentlyUsed = NULL;
	pRecord->m_pLessRecentlyUsed = m_pMostRecentlyUsed;
	if(m_pMostRecentlyUsed)
		m_pMostRecentlyUsed->m_pMoreRecentlyUsed = pRecord;

	m_pMostRecentlyUsed = pRecord;
	if(m_pLeastRecentlyUsed == NULL)
		m_pLeastRecentlyUsed = pRecord;


    pRecord->m_dwLastUsed = GetTickCount();
    pRecord->m_nStatus = 4;
	//Test();

    //
    // Schedule a timer to clean up, if not already there
    //

    if(m_hCurrentTimer == NULL)
    {
        CreateTimerQueueTimer(&m_hCurrentTimer, NULL, //m_hTimerQueue, 
            (WAITORTIMERCALLBACK)&staticTimerCallback, this, m_dwMaxAgeMs,
            m_dwMaxAgeMs, WT_EXECUTEINTIMERTHREAD);
    }
}

void CForestCache::staticTimerCallback(void* pParam, BOOLEAN)
{
#ifdef DBG
    if (!g_Glob.GetForestCache()->m_hCurrentTimer)
    {
        DebugBreak();
    }
    if (pParam != g_Glob.GetForestCache())
    {
        char pBuff[128];
        sprintf(pBuff,"_RTLP_GENERIC_TIMER::Context == %p != %p\n",pParam,g_Glob.GetForestCache());
        OutputDebugStringA(pBuff);
        DebugBreak();
    }
#endif 
    g_Glob.GetForestCache()->TimerCallback();
}
    
void CForestCache::TimerCallback()
{    
    LockGuard<CriticalSection> gl(m_cs);
    if(gl.locked() == false)
        return;
    
    if (!m_bInit)
        return;

    //
    // Clean up what's stale
    //

    MakeRoom(0);

    //
    // See if we have any more reasons to live
    //

    if(m_pMostRecentlyUsed == NULL)
    {
        DeleteTimerQueueTimer(NULL , m_hCurrentTimer, NULL);
        m_hCurrentTimer = NULL;
    }
}

void CForestCache::Add(CClassRecord* pRecord)
{
    LockGuard<CriticalSection> gl(m_cs);
    if(gl.locked() == false)
        return;
    
    if (!m_bInit)
        return;

    MakeMostRecentlyUsed(pRecord);
    m_dwTotalMemory += pRecord->m_dwClassDefSize;
    pRecord->m_nStatus = 3;
}

void CForestCache::RemoveRecord(CClassRecord* pRecord)
{
    LockGuard<CriticalSection> gl(m_cs);
    if(gl.locked() == false)
        return;
    
    if (!m_bInit)
        return;    

    if(pRecord->m_pClassDef == NULL)
		return;

	Untie(pRecord);

    m_dwTotalMemory -= pRecord->m_dwClassDefSize;

    pRecord->m_pClassDef->Release();
    pRecord->m_pClassDef = NULL;
    pRecord->m_nStatus = 2;
}

//
//
//  helper function, always in m_cs
//
///////////////////////////////////////////////////////

void CForestCache::Untie(CClassRecord* pRecord)
{
	//Test();

    CClassRecord* pPrev = pRecord->m_pLessRecentlyUsed;
    CClassRecord* pNext = pRecord->m_pMoreRecentlyUsed;
    if(pPrev)
        pPrev->m_pMoreRecentlyUsed = pNext;
    if(pNext)
        pNext->m_pLessRecentlyUsed = pPrev;

    if(m_pLeastRecentlyUsed == pRecord)
        m_pLeastRecentlyUsed = m_pLeastRecentlyUsed->m_pMoreRecentlyUsed;

    if(m_pMostRecentlyUsed == pRecord)
        m_pMostRecentlyUsed = m_pMostRecentlyUsed->m_pLessRecentlyUsed;

	pRecord->m_pMoreRecentlyUsed = pRecord->m_pLessRecentlyUsed = NULL;
	//Test();
}

void CForestCache::SetMaxMemory(DWORD dwMaxMemory, DWORD dwMaxAgeMs)
{
    m_dwMaxMemory = dwMaxMemory;
    m_dwMaxAgeMs = dwMaxAgeMs;
    
    // 
    // Make room for 0 bytes --- has the effect of clearing all the records
    // above the limit
    //

    MakeRoom(0);
}


CHierarchyCache* CForestCache::GetNamespaceCache(LPCWSTR wszNamespace)
{
    LockGuard<CriticalSection> gl(m_cs);
    if(gl.locked() == false)
        return NULL;
        
    if (!m_bInit)
        return  NULL;

    //
    // See if you can find one
    //

    TIterator it = m_map.find(wszNamespace);
    if(it != m_map.end())
    {
        it->second->AddRef();
        return it->second;
    }
    else
    {
        //
        // Not there --- create one
        //

        CHierarchyCache* pCache = new CHierarchyCache(this);
        if(pCache == NULL)
            return NULL;

        try 
        {
            pCache->AddRef();   // this refcount is for the cache
            m_map[wszNamespace] = pCache;
            pCache->AddRef();  // this refcount is for the customers
        }
        catch (CX_MemoryException)
        {
            delete pCache; // despite the AddRef
            pCache = NULL;
        }
        return pCache;
    }
}

void CForestCache::ReleaseNamespaceCache(LPCWSTR wszNamespace, 
                                            CHierarchyCache* pCache)
{
    LockGuard<CriticalSection> gl(m_cs);
    if(gl.locked() == false)
        return;

    //
    // this is a cleanup function, we always want this to be called
    //
    //if (!m_bInit)
    //    return;    

    //
    // Find it in the map
    //
    TIterator it = m_map.find(wszNamespace);
        
    if (it !=  m_map.end() && (it->second == pCache))
    {
        //
	    // Last ref-count --- remove
	    //
        if( 1 == pCache->Release())
        {
	        m_map.erase(it);
	        pCache->Release(); // this is the last one
        }
    }
    else
    {
        pCache->Release();
    }
}

void CForestCache::BeginTransaction()
{
    m_bAssertedInTransaction = false;
}

bool CForestCache::MarkAsserted(CHierarchyCache* pCache, LPCWSTR wszClassName)
{
    m_bAssertedInTransaction = true;
    return true;
}

void CForestCache::CommitTransaction()
{
    m_bAssertedInTransaction = false;
}

void CForestCache::AbortTransaction()
{
    if(m_bAssertedInTransaction)
        Clear();

    m_bAssertedInTransaction = false;
}

void CForestCache::Clear()
{
    LockGuard<CriticalSection> gl(m_cs);
    if(gl.locked() == false)
        return;
    
    if (!m_bInit)
        return;

    Flush();

    TIterator it = m_map.begin();
    while(it != m_map.end())
    {
        it->second->Clear();
        it++;
    }
}

HRESULT
CForestCache::Deinitialize()
{
    LockGuard<CriticalSection> gl(m_cs);
    if(gl.locked() == false)
        return WBEM_E_TIMED_OUT;
    
    if (!m_bInit)
        return S_OK;
    
    if(m_hCurrentTimer)
    {
        DeleteTimerQueueTimer( NULL, m_hCurrentTimer, NULL);
        m_hCurrentTimer = NULL;
    }

    TIterator it = m_map.begin();
    while(it != m_map.end())
    {
        it->second->Clear();
        it->second->Release();
        it->second = NULL;        
        it++;
    };

    m_map.erase(m_map.begin(),m_map.end());

    m_bInit = FALSE;
    return S_OK;
}

CForestCache::~CForestCache()
{
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\xfiles\index.h ===
#ifndef __A51_INDEX__H_
#define __A51_INDEX__H_

#include "btr.h"


class CBtrIndex
{
    DWORD m_dwPrefixLength;
    CBTree bt;
    CBTreeFile ps;

    BOOL CopyStringToWIN32_FIND_DATA(
        LPSTR pszSource,
        LPWSTR wszDest
        );

public:
    CBtrIndex();
   ~CBtrIndex();

    long Shutdown(DWORD dwShutDownFlags);

    long Initialize(DWORD dwPrefixLength, LPCWSTR wszRepositoryDir, 
                    CPageSource* pSource );
    long Create(LPCWSTR wszFileName);
    long Delete(LPCWSTR wszFileName);
    long FindFirst(LPCWSTR wszPrefix, WIN32_FIND_DATAW* pfd, void** ppHandle);
    long FindNext(void* pHandle, WIN32_FIND_DATAW* pfd);
    long FindClose(void* pHandle);

	long IndexEnumerationBegin(const wchar_t *wszSearchPrefix, void **ppHandle);
	long IndexEnumerationEnd(void *pHandle);
	long IndexEnumerationNext(void *pHandle, CFileName &wszFileName);

	long InvalidateCache();

	long FlushCaches();

    CBTree& GetTree() {return bt;}
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\xfiles\hiecache.h ===
/*++

Copyright (C) 2000-2001 Microsoft Corporation

--*/

#ifndef __WMI_A51__HIECACHE__H_
#define __WMI_A51__HIECACHE__H_

//
// NOTE: it is critical that things be marked in the cache while the repository
// lock is held!  Otherwise, invalidation/completion logic will break
//

#include <wbemint.h>
#include <map>
#include <sync.h>
#include <wstlallc.h>
#include <lockst.h>
#include "a51tools.h"


class wcscless : public binary_function<LPCWSTR, LPCWSTR, bool> 
{
public:
    bool operator()(const LPCWSTR& wcs1, const LPCWSTR& wcs2) const
        {return wcscmp(wcs1, wcs2) < 0;}
};

typedef enum {e_KeynessUnknown, e_Keyed, e_NotKeyed} EKeyNess;

class CClassRecord
{
protected:
    static long s_nRecords;

    long m_lRef;

    CClassRecord* m_pMoreRecentlyUsed;
    CClassRecord* m_pLessRecentlyUsed;
    
    LPWSTR m_wszClassName;
    WCHAR m_wszHash[MAX_HASH_LEN+1];

    _IWmiObject* m_pClassDef;
    DWORD m_dwClassDefSize;
    
    CClassRecord* m_pParent;
    EKeyNess m_eIsKeyed;
    CPointerArray<CClassRecord> m_apChildren;

    bool m_bTreeComplete;
    bool m_bChildrenComplete;
    LONGLONG m_lLastChildInvalidationIndex;

    DWORD m_dwLastUsed;
    int m_nStatus;
    __int64 m_nClassDefCachedTime;
    bool m_bRead;
	bool m_bSystemClass;

public:
    CClassRecord(LPCWSTR wszClassName, LPCWSTR wszHash);
    virtual ~CClassRecord();

    void AddRef() {InterlockedIncrement(&m_lRef);}
    void Release() {if(InterlockedDecrement(&m_lRef) == 0) delete this;}

    HRESULT EnsureChild(CClassRecord* pChild);
    HRESULT RemoveChild(CClassRecord* pChild);

    friend class CHierarchyCache;
    friend class CForestCache;
};

class CForestCache;
class CHierarchyCache
{
protected:

    static long s_nCaches;

    long m_lRef;
    typedef std::map<LPCWSTR, CClassRecord*, wcscless, wbem_allocator<CClassRecord*> > TMap;
    typedef TMap::iterator TIterator;

    CForestCache* m_pForest;
    TMap m_map;
    LONGLONG m_lNextInvalidationIndex;
    HRESULT m_hresError;

public:
    CHierarchyCache(CForestCache* pForest);
    virtual ~CHierarchyCache();
    long AddRef() {return InterlockedIncrement(&m_lRef);}
    long Release() { long lRet = InterlockedDecrement(&m_lRef); if (0 == lRet) delete this; return lRet; }

    HRESULT AssertClass(_IWmiObject* pClass, LPCWSTR wszClassName, 
                       bool bClone, __int64 nTime, bool bSystemClass);
    HRESULT InvalidateClass(LPCWSTR wszClassName);

    HRESULT DoneWithChildren(LPCWSTR wszClassName, bool bRecursive, 
                            LONGLONG lStartingIndex, 
                            CClassRecord* pRecord = NULL);
    HRESULT DoneWithChildrenByHash(LPCWSTR wszHash, bool bRecursive,
                                LONGLONG lStartIndex);
    LONGLONG GetLastInvalidationIndex() {return m_lNextInvalidationIndex-1;}

    void SetError(HRESULT hresError);
    HRESULT GetError();

    void Clear();

public:
    RELEASE_ME _IWmiObject* GetClassDef(LPCWSTR wszClassName, 
                                        bool bClone, __int64* pnTime = NULL,
                                        bool* pbRead = NULL);
    HRESULT EnumChildren(LPCWSTR wszClassName, bool bRecursive,
                            CWStringArray& awsChildren);
    HRESULT EnumChildKeysByKey(LPCWSTR wszClassKey, 
                            CWStringArray& awsChildKeys);
    HRESULT GetKeyRootByKey(LPCWSTR wszKey, 
                                    TEMPFREE_ME LPWSTR* pwszKeyRoot);
    HRESULT GetKeyRoot(LPCWSTR wszClassName, 
                                    TEMPFREE_ME LPWSTR* pwszKeyRoot);
    HRESULT GetKeyRootByRecord(CClassRecord* pRecord,
                                    TEMPFREE_ME LPWSTR* pwszKeyRoot);
    DELETE_ME LPWSTR GetParent(LPCWSTR wszClassName);
    RELEASE_ME _IWmiObject* GetClassDefByHash(LPCWSTR wszHash, bool bClone,
                                              __int64* pnTime = NULL,
                                              bool* pbRead = NULL,
											  bool *pbSystemClass = NULL);

protected:
    INTERNAL CClassRecord* FindClass(LPCWSTR wszClassName);
    INTERNAL CClassRecord* FindClassByKey(LPCWSTR wszKey);
    RELEASE_ME _IWmiObject* GetClassDefFromRecord(CClassRecord* pRecord,
                                                bool bClone);
    INTERNAL CClassRecord* EnsureClass(LPCWSTR wszClassName);
    HRESULT EnumChildrenInternal(CClassRecord* pRecord, 
                                        bool bRecursive,
                                        CWStringArray& awsChildren);

    HRESULT InvalidateClassInternal(CClassRecord* pRecord);
    HRESULT DoneWithChildrenByRecord(CClassRecord* pRecord,
                                bool bRecursive,  LONGLONG lStartIndex);
    static void MakeKey(LPCWSTR wszClassName, LPWSTR wszKey);
};

class CForestCache
{
protected:
    CriticalSection m_cs;

    CClassRecord* m_pMostRecentlyUsed;
    CClassRecord* m_pLeastRecentlyUsed;
    DWORD m_dwMaxMemory;
    DWORD m_dwMaxAgeMs;
    DWORD m_dwTotalMemory;

    HANDLE m_hCurrentTimer;
    long m_lRef;
    BOOL m_bInit;

    typedef std::map<WString, CHierarchyCache*, WSiless, wbem_allocator<CHierarchyCache*> > TMap;
    typedef TMap::iterator TIterator;

    TMap m_map;
    bool m_bAssertedInTransaction;

public:
    CForestCache() : m_dwMaxMemory(0xFFFFFFFF), m_dwTotalMemory(0),
        m_pMostRecentlyUsed(NULL), m_pLeastRecentlyUsed(NULL),
        m_dwMaxAgeMs(0), m_hCurrentTimer(NULL),
        m_lRef(1), m_bInit(FALSE), m_bAssertedInTransaction(false),
        m_cs(THROW_LOCK,0x80000000 | 400L)
    {
    }

    ~CForestCache();
    HRESULT Initialize();
    HRESULT Deinitialize();    

    void SetMaxMemory(DWORD dwMaxMemory, DWORD dwMaxAgeMs);
    bool MakeRoom(DWORD dwSize);
    bool Flush();
    void MakeMostRecentlyUsed(CClassRecord* pRecord);
    void Add(CClassRecord* pRecord);
    void RemoveRecord(CClassRecord* pRecord);
    void BeginTransaction();
    bool MarkAsserted(CHierarchyCache* pCache, LPCWSTR wszClassName);
    void CommitTransaction();
    void AbortTransaction();

public:
    CHierarchyCache* GetNamespaceCache(LPCWSTR wszNamespace);
    void ReleaseNamespaceCache(LPCWSTR wszNamespace, CHierarchyCache* pCache);
    long AddRef() {  return InterlockedIncrement(&m_lRef);}
    long Release() { long lRet = InterlockedDecrement(&m_lRef);  if (!lRet) delete this; return lRet;}

    void Clear();
protected:	
    CriticalSection & GetLock() {return m_cs;}
	bool Test();	
	void Untie(CClassRecord* pRecord);
    void TimerCallback();
    static void staticTimerCallback(VOID* pParam, BOOLEAN);
    friend class CHierarchyCache;
};
    
    
    
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\xfiles\objheap.h ===
#ifndef __A51_OBJHEAP__H_
#define __A51_OBJHEAP__H_

#include "index.h"
#include "VarObjHeap.h"

typedef DWORD TOffset;
typedef DWORD TPage;

class CObjectHeap
{
protected:
    BOOL      m_bInit;
    
    CVarObjHeap m_Heap;
    CBtrIndex m_Index;

public:
    CObjectHeap() :m_bInit(FALSE)
    {}
    virtual ~CObjectHeap(){}

    long Initialize(CPageSource  * pAbstractSource, 
                    WCHAR * wszBaseName,
                    DWORD dwBaseNameLen);
                    
    long Uninitialize(DWORD dwShutDownFlags);

	//Transaction aborts require caches to be flushed and re-read
    void InvalidateCache();

	long FlushCaches();

	//File read/write methods
    long WriteObject(LPCWSTR wszFilePath1, LPCWSTR wszFilePath2, DWORD dwBufferLen, BYTE* pBuffer);
    long WriteLink(LPCWSTR wszLinkPath);
    long DeleteObject(LPCWSTR wszFilePath);
    long DeleteLink(LPCWSTR wszLinkPath);
    long ReadObject(LPCWSTR wszFilePath, DWORD* pdwBufferLen, BYTE** ppBuffer);

    // for the dump utility
    CBtrIndex * GetIndex(){ return &m_Index; };
    CVarObjHeap * GetFileHeap(){ return &m_Heap; };
    
	long ObjectEnumerationBegin(const wchar_t *wszSearchPrefix, void **ppHandle);
	long ObjectEnumerationEnd(void *pHandle);
	long ObjectEnumerationNext(void *pHandle, CFileName &wszFileName, BYTE **ppBlob, DWORD *pdwSize);
	long ObjectEnumerationFree(void *pHandle, BYTE *pBlob);

	long IndexEnumerationBegin(const wchar_t *wszSearchPrefix, void **ppHandle);
	long IndexEnumerationEnd(void *pHandle);
	long IndexEnumerationNext(void *pHandle, CFileName &wszFileName);

protected:
    long GetIndexFileName(LPCWSTR wszFilePath, LPWSTR wszIndexFileName);
    long GetFileInfo(LPCWSTR wszFilePath, TPage *pnPage, TOffset* pnOffset, DWORD* pdwLength);
    long ParseInfoFromIndexFile(LPCWSTR wszIndexFileName, TPage *pnPage, TOffset* pnOffset, DWORD* pdwLength);
    long CreateIndexFile(LPCWSTR wszFilePath, TPage nPage, TOffset nOffset, DWORD dwLength);
    long DeleteIndexFile(LPCWSTR wszFilePath, LPCWSTR wszIndexFileName);
    long CreateZeroLengthFile(LPCWSTR wszFilePath);
    long DeleteZeroLengthFile(LPCWSTR wszFilePath);
    long WriteAllocation(DWORD dwDataLength, BYTE* pData, TPage *pnPage, TOffset *pnOffset);
    long WriteExistingAllocation(TPage nOldPage, TOffset nOldOffset, DWORD dwBufferLen, BYTE *pBuffer, DWORD *pnNewPage, DWORD *pnNewOffset);
    long ReadAllocation(TPage nPage, TOffset nOffset, DWORD dwDataLength, BYTE* pBuffer);
};

    

    
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\xfiles\index.cpp ===
//***************************************************************************
//
//  (c) 2000-2001 by Microsoft Corp.  All Rights Reserved.
//
//  INDEX.CPP
//
//  24-Oct-00   raymcc      Integration layer to disk-based B-Tree
//
//***************************************************************************

#include <wbemcomn.h>
#include <reposit.h>
#include "a51tools.h"
#include "index.h"

#include "btr.h"

//***************************************************************************
//
//***************************************************************************
//
//#define DEBUG

static CLockableFlexArray g_aIterators;

class CIteratorBatch
{
    CFlexArray m_aStrings;
    BOOL  m_bDone;
    DWORD m_dwCursor;

public:
    CIteratorBatch();
   ~CIteratorBatch();
    BOOL Purge(LPSTR pszTarget);
    BOOL Add(LPSTR pszSrc);    // Acquires memory
    void SetDone() { m_bDone = TRUE; }
    BOOL Next(LPSTR *pString);
    static DWORD PurgeAll(LPSTR pszDoomed);
};

//***************************************************************************
//
//  CIteratorBatch::PurgeAll
//
//
//  Purges all iterators of a particular string.  This happens when
//  a DeleteKey succeeds while there are outstanding enumerators; we want
//  to remove the key from all enumerators so that deleted objects
//  are not reported.
//
//  This is required because the enumerators do "prefetch" and may
//  have been invoked considerably in advance of the delete
//
//  Assumes prior concurrency control.
//
//***************************************************************************
// ok
DWORD CIteratorBatch::PurgeAll(LPSTR pszDoomed)
{
    DWORD dwTotal = 0;
	g_aIterators.Lock();
    for (int i = 0; i < g_aIterators.Size(); i++)
    {
        CIteratorBatch *p = (CIteratorBatch *) g_aIterators[i];
        BOOL bRes = p->Purge(pszDoomed);
        if (bRes)
            dwTotal++;
    }
	g_aIterators.Unlock();
    return dwTotal;
}

//***************************************************************************
//
//  CIteratorBatch::CIteratorBatch
//
//***************************************************************************
// ok
CIteratorBatch::CIteratorBatch()
{
    m_bDone = FALSE;
    m_dwCursor = 0;
	g_aIterators.Lock();
    g_aIterators.Add(this);
	g_aIterators.Unlock();
}

//***************************************************************************
//
//  CIteratorBatch::Add
//
//  Adds a string to the enumerator.
//
//***************************************************************************
//
BOOL CIteratorBatch::Add(LPSTR pszSrc)
{
    int nRes = m_aStrings.Add(pszSrc);
    if (nRes)
        return FALSE;
    return TRUE;
}


//***************************************************************************
//
//  CIteratorBatch::~CIteratorBatch
//
//  Removes all remaining strings and deallocates them and removes
//  this iterator from the global list.
//
//  Assumes prior concurrency control.
//
//***************************************************************************
//
CIteratorBatch::~CIteratorBatch()
{
    for (int i = 0; i < m_aStrings.Size(); i++)
    {
        _BtrMemFree(m_aStrings[i]);
    }

	g_aIterators.Lock();
    for (i = 0; i < g_aIterators.Size(); i++)
    {
        if (g_aIterators[i] == this)
        {
            g_aIterators.RemoveAt(i);
            break;
        }
    }
	g_aIterators.Unlock();
}

//***************************************************************************
//
//  CIteratorBatch::Purge
//
//  Removes a specific string from the enumerator.  Happens when a concurrent
//  delete succeeds; we have to remove the deleted key from the enumeration
//  for result set coherence.
//
//  Assumes prior concurrency control.
//
//  Returns FALSE if the string was not removed, TRUE if it was.  The
//  return value is mostly a debugging aid.
//
//***************************************************************************
// ok
BOOL CIteratorBatch::Purge(
    LPSTR pszTarget
    )
{
    int nSize = m_aStrings.Size();

    if (nSize == 0)
        return FALSE;

    // First, check the first/last strings against
    // the first character of the target.  We can
    // avoid a lot of strcmp calls if the target
    // is lexcially outside the range of the contents of
    // the enumerator.
    // ==================================================

    LPSTR pszFirst = (LPSTR) m_aStrings[0];
    LPSTR pszLast = (LPSTR) m_aStrings[nSize-1];
    if (*pszTarget > *pszLast)
        return FALSE;
    if (*pszTarget < *pszFirst)
        return FALSE;

    // If here, there is a chance that we have the
    // string in the enumerator. Since all keys are
    // retrieved in lexical order, a simple binary
    // search is all we need.
    // =============================================

    int nPosition = 0;
    int l = 0, u = nSize - 1;

    while (l <= u)
    {
        int m = (l + u) / 2;

        // m is the current key to consider 0...n-1

        LPSTR pszCandidate = (LPSTR) m_aStrings[m];
        int nRes = strcmp(pszTarget, pszCandidate);

        // Decide which way to cut the array in half.
        // ==========================================

        if (nRes < 0)
        {
            u = m - 1;
            nPosition = u + 1;
        }
        else if (nRes > 0)
        {
            l = m + 1;
            nPosition = l;
        }
        else
        {
            // If here, we found the darn thing.  Life is good.
            // Zap it and return!
            // ================================================

            _BtrMemFree(pszCandidate);
            m_aStrings.RemoveAt(m);
            return TRUE;
        }
    }

    return FALSE;
}



//***************************************************************************
//
//  CIteratorBatch::Next
//
//  Returns the next string from the enumeration prefetch.
//
//***************************************************************************
//
BOOL CIteratorBatch::Next(LPSTR *pMem)
{
    if (m_aStrings.Size())
    {
        *pMem = (LPSTR) m_aStrings[0];
        m_aStrings.RemoveAt(0);
        return TRUE;
    }
    return FALSE;
}



//***************************************************************************
//
//  CBtrIndex::CBtrIndex
//
//***************************************************************************
//
CBtrIndex::CBtrIndex()
{
    m_dwPrefixLength = 0;
}


//***************************************************************************
//
//  CBtrIndex::~CBtrIndex
//
//***************************************************************************
//
CBtrIndex::~CBtrIndex()
{
}

long CBtrIndex::Shutdown(DWORD dwShutDownFlags)
{
    long lRes;

    lRes = bt.Shutdown(dwShutDownFlags);
    if(lRes != ERROR_SUCCESS)
        return lRes;

    lRes = ps.Shutdown(dwShutDownFlags);
    if(lRes != ERROR_SUCCESS)
        return lRes;
    return ERROR_SUCCESS;
}

//***************************************************************************
//
//  CBtrIndex::Initialize
//
//***************************************************************************
//
long CBtrIndex::Initialize(DWORD dwPrefixLength, 
						   LPCWSTR wszRepositoryDir, 
						   CPageSource* pSource)
{
    // Initialize the files in question and map BTree into it.
    // =======================================================

    wchar_t buf[MAX_PATH];
    wcscpy(buf, wszRepositoryDir);
    wcscat(buf, L"\\index.btr");

    DWORD dwRes = ps.Init(8192, buf, pSource);
    dwRes |= bt.Init(&ps);

    m_dwPrefixLength = dwPrefixLength;

    return long(dwRes);
}


//***************************************************************************
//
//   CBtrIndex::Create
//
//***************************************************************************
//
long CBtrIndex::Create(LPCWSTR wszFileName)
{
    DWORD dwRes;

    if (wszFileName == 0)
        return ERROR_INVALID_PARAMETER;

    wszFileName += m_dwPrefixLength;

    // Convert to ANSI
    // ================

    char *pAnsi = new char[wcslen(wszFileName) + 1];
    if (pAnsi == 0)
        return ERROR_NOT_ENOUGH_MEMORY;

    LPCWSTR pSrc = wszFileName;
    char *pDest = pAnsi;
    while (*pSrc)
        *pDest++ = (char) *pSrc++;
    *pDest = 0;

    try
    {
        dwRes = bt.InsertKey(pAnsi, 0);
    }
    catch (...)
    {
        dwRes = ERROR_BADDB;
    }

    delete [] pAnsi;

    if (dwRes == ERROR_ALREADY_EXISTS)
        dwRes = NO_ERROR;

    return long(dwRes);
}

//***************************************************************************
//
//  CBtrIndex::Delete
//
//  Deletes a key from the index
//
//***************************************************************************
//
long CBtrIndex::Delete(LPCWSTR wszFileName)
{
    DWORD dwRes = 0;

    wszFileName += m_dwPrefixLength;

    // Convert to ANSI
    // ================

    char *pAnsi = new char[wcslen(wszFileName) + 1];
    if (pAnsi == 0)
        return ERROR_NOT_ENOUGH_MEMORY;

    LPCWSTR pSrc = wszFileName;
    char *pDest = pAnsi;
    while (*pSrc)
        *pDest++ = (char) *pSrc++;
    *pDest = 0;

    try
    {
        dwRes = bt.DeleteKey(pAnsi);
        if (dwRes == 0)
            CIteratorBatch::PurgeAll(pAnsi);
    }
    catch (...)
    {
        dwRes = ERROR_BADDB;
    }

    delete pAnsi;

    return long(dwRes);
}

//***************************************************************************
//
//  CBtrIndex::CopyStringToWIN32_FIND_DATA
//
//  Does an ANSI to UNICODE convert for the key string.
//
//***************************************************************************
//
BOOL CBtrIndex::CopyStringToWIN32_FIND_DATA(
    LPSTR pszKey,
    LPWSTR pszDest
    )
{
    LPSTR pszSuffix = pszKey + strlen(pszKey) - 1;
    while (pszSuffix[-1] != '\\' && pszSuffix > pszKey)
    {
        pszSuffix--;
    }

    // If here, a clean match.
    // =======================

    while (*pszSuffix)
        *pszDest++ = (wchar_t) *pszSuffix++;
    *pszDest = 0;

    return TRUE;
}


//***************************************************************************
//
//  CBtrIndex::FindFirst
//
//  Starts an enumeration
//
//***************************************************************************
//
long CBtrIndex::FindFirst(LPCWSTR wszPrefix, WIN32_FIND_DATAW* pfd,
                            void** ppHandle)
{
    DWORD dwRes;
    wszPrefix += m_dwPrefixLength;

    if(ppHandle)
        *ppHandle = INVALID_HANDLE_VALUE;

    pfd->cFileName[0] = 0;
    pfd->dwFileAttributes = FILE_ATTRIBUTE_NORMAL;

    // Convert to ANSI
    // ================

    char *pAnsi = new char[wcslen(wszPrefix) + 1];
    if (pAnsi == 0)
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }
    CVectorDeleteMe<char> vdm(pAnsi);

    LPCWSTR pSrc = wszPrefix;
    char *pDest = pAnsi;
    while (*pSrc)
        *pDest++ = (char) *pSrc++;
    *pDest = 0;

    // Critical-section blocked.
    // =========================

    CBTreeIterator *pIt = new CBTreeIterator;
    if (!pIt)
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    try
    {
        dwRes = pIt->Init(&bt, pAnsi);
    }
    catch (...)
    {
        dwRes = ERROR_BADDB;
    }

    if (dwRes)
    {
        pIt->Release();
        return ERROR_FILE_NOT_FOUND;
    }

    // Create CIteratorBatch.
    // ======================

    CIteratorBatch *pBatch = new CIteratorBatch;

    if (pBatch == 0)
    {
        pIt->Release();
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    // Iterate and fill batcher.
    // =========================

    LPSTR pszKey = 0;
    int nMatchLen = strlen(pAnsi);

    for (;;)
    {
        dwRes = pIt->Next(&pszKey);
        
        if (dwRes)
            break;

        // See if prefix matches.

        if (strncmp(pAnsi, pszKey, nMatchLen) != 0)
        {
            pIt->FreeString(pszKey);
            pBatch->SetDone();
            break;
        }
        pBatch->Add(pszKey);

		if (ppHandle == NULL)
			break;	//Only asked for 1 item!  No need to try the next
    }

    pIt->Release();

    long lRes = FindNext(pBatch, pfd);

    if (lRes == ERROR_NO_MORE_FILES)
        lRes = ERROR_FILE_NOT_FOUND;

    if (lRes == NO_ERROR)
    {
        if(ppHandle)
        {
            *ppHandle = (LPVOID *) pBatch;
        }
        else
        {
            //
            // Only asked for one --- close handle
            //

            delete pBatch;
        }
    }
    else
    {
        delete pBatch;
    }

    return lRes;
}

//***************************************************************************
//
//  CBtrIndex::FindNext
//
//  Continues an enumeration.  Reads from the prefetch buffer.
//
//***************************************************************************
//
long CBtrIndex::FindNext(void* pHandle, WIN32_FIND_DATAW* pfd)
{
    LPSTR pszString = 0;
    BOOL bRes;

    if (pHandle == 0 || pfd == 0 || pHandle == INVALID_HANDLE_VALUE)
        return ERROR_INVALID_PARAMETER;

    CIteratorBatch *pBatch = (CIteratorBatch *) pHandle;
    bRes = pBatch->Next(&pszString);

    if (bRes == FALSE)
        return ERROR_NO_MORE_FILES;

    CopyStringToWIN32_FIND_DATA(pszString, pfd->cFileName);
    pfd->dwFileAttributes = FILE_ATTRIBUTE_NORMAL;

    if (pszString)
       _BtrMemFree(pszString);

    return ERROR_SUCCESS;
}

//***************************************************************************
//
//  CBtrIndex::FindClose
//
//  Closes an enumeration by deleting the 'hidden' pointer.
//
//***************************************************************************
//  ok
long CBtrIndex::FindClose(void* pHandle)
{
    if (pHandle == 0 || pHandle == INVALID_HANDLE_VALUE)
        return NO_ERROR;

    delete (CIteratorBatch *) pHandle;

    return ERROR_SUCCESS;
}

long CBtrIndex::InvalidateCache()
{

    //
    // Re-read the admin page from disk.  NOTE: this will need changing if more
    // caching is added!
    //

    DWORD dwRes = ps.ReadAdminPage();
    if (dwRes == NO_ERROR)
        dwRes = bt.InvalidateCache();

    return long(dwRes);
}

long CBtrIndex::FlushCaches()
{
	return bt.FlushCaches();
}


long CBtrIndex::IndexEnumerationBegin(const wchar_t *wszSearchPrefix, void **ppHandle)
{
    DWORD dwRes = ERROR_SUCCESS;
    wszSearchPrefix += m_dwPrefixLength;

    if(ppHandle)
        *ppHandle = INVALID_HANDLE_VALUE;

    // Convert to ANSI
    // ================

    char *pAnsi = new char[wcslen(wszSearchPrefix) + 1];
    if (pAnsi == 0)
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }
    CVectorDeleteMe<char> vdm(pAnsi);

    LPCWSTR pSrc = wszSearchPrefix;
    char *pDest = pAnsi;
    while (*pSrc)
        *pDest++ = (char) *pSrc++;
    *pDest = 0;

    CBTreeIterator *pIt = new CBTreeIterator;
    if (!pIt)
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    try
    {
        dwRes = pIt->Init(&bt, pAnsi);
    }
    catch (...)
    {
        dwRes = ERROR_BADDB;
    }

    if (dwRes)
    {
        pIt->Release();
        return ERROR_FILE_NOT_FOUND;
    }

    // Create CIteratorBatch.
    // ======================

    CIteratorBatch *pBatch = new CIteratorBatch;

    if (pBatch == 0)
    {
        pIt->Release();
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    // Iterate and fill batcher.
    // =========================

    LPSTR pszKey = 0;
    int nMatchLen = strlen(pAnsi);

    for (int nCount = 0;;nCount++)
    {
        dwRes = pIt->Next(&pszKey);
        if (dwRes == ERROR_NO_MORE_ITEMS)
        {
            //We hit the end of the BTree result set, so we need to ignore this error
            dwRes = 0;
            break;
        }
    
        if (dwRes)
            break;

        // See if prefix matches.

        if (strncmp(pAnsi, pszKey, nMatchLen) != 0)
        {
            pIt->FreeString(pszKey);
            pBatch->SetDone();
            break;
        }
        pBatch->Add(pszKey);
    }

    pIt->Release();

	if (nCount == 0)
		dwRes = ERROR_FILE_NOT_FOUND;

	if (dwRes == ERROR_SUCCESS)
	{
		if(ppHandle)
		{
			*ppHandle = (LPVOID *) pBatch;
		}
		else
			delete pBatch;
	}
	else
		delete pBatch;


    return dwRes;
}

long CBtrIndex::IndexEnumerationEnd(void *pHandle)
{
	if (pHandle != INVALID_HANDLE_VALUE)
		delete (CIteratorBatch *) pHandle;

    return ERROR_SUCCESS;
}

long CBtrIndex::IndexEnumerationNext(void *pHandle, CFileName &wszFileName)
{
    LPSTR pszString = 0;
    BOOL bRes;

    if (pHandle == 0 || pHandle == INVALID_HANDLE_VALUE)
        return ERROR_INVALID_PARAMETER;

    CIteratorBatch *pBatch = (CIteratorBatch *) pHandle;
    bRes = pBatch->Next(&pszString);

    if (bRes == FALSE)
        return ERROR_NO_MORE_FILES;

    CopyStringToWIN32_FIND_DATA(pszString, wszFileName);

    if (pszString)
       _BtrMemFree(pszString);

    return ERROR_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\xfiles\main.cpp ===
/*++

Copyright (C) 2000-2001 Microsoft Corporation

--*/

#include <windows.h>
#include <wbemidl.h>
#include <commain.h>
#include <clsfac.h>
#include <creposit.h>

#include <initguid.h>
#ifndef INITGUID
#define INITGUID
#endif

DEFINE_GUID(CLSID_A51Repository, 
0x7998dc37, 0xd3fe, 0x487c, 0xa6, 0x0a, 0x77, 0x01, 0xfc, 0xc7, 0x0c, 0xc6);

class CMyServer : public CComServer
{
public:
    HRESULT Initialize()
    {
        AddClassInfo(CLSID_A51Repository, 
            new CSimpleClassFactory<CRepository>(GetLifeControl()), 
            L"A51 Repository", TRUE);

        return S_OK;
    }

    HRESULT InitializeCom()
    {
        return CoInitializeEx(NULL, COINIT_MULTITHREADED);
    }
} Server;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\xfiles\lock.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    LOCK.CPP

Abstract:

    Implements the generic class for obtaining read and write locks to some 
    resource. 

    See lock.h for all documentation.

    Classes defined:

    CLock

History:

    a-levn  5-Sept-96       Created.
    3/10/97     a-levn      Fully documented

--*/

#include <windows.h>
#include <ole2.h>

#include <stdio.h>
#include <stdio.h>

#include "lock.h"

// debugging.
#define PRINTF

#if 0
#define DBG_PRINTFA( a ) { char pBuff[128]; sprintf a ; OutputDebugStringA(pBuff); }
#else
#define DBG_PRINTFA( a )
#endif


//******************************************************************************
//
//  See lock.h for documentation
//
//******************************************************************************

CLock::CLock() : m_nReading(0), m_nWriting(0), m_nWaitingToRead(0),
            m_nWaitingToWrite(0),
            m_csEntering(THROW_LOCK,0x80000000 | 500L),
            m_csAll(THROW_LOCK,0x80000000 | 500L)
            
{
    m_dwArrayIndex = 0;
    for (DWORD i=0;i<MaxRegistredReaders;i++)
    {
        m_adwReaders[i].ThreadId = 0;
    }
    // Create unnamed events for reading and writing
    // =============================================

    m_hCanRead = CreateEvent(NULL, TRUE, TRUE, NULL);
    m_hCanWrite = CreateEvent(NULL, TRUE, TRUE, NULL);
    if (NULL == m_hCanRead || NULL == m_hCanWrite)
    	DebugBreak();
}

//******************************************************************************
//
//  See lock.h for documentation
//
//******************************************************************************
CLock::~CLock()
{
    CloseHandle(m_hCanWrite);
    CloseHandle(m_hCanRead);
}


//******************************************************************************
//
//  See lock.h for documentation
//
//******************************************************************************
int CLock::ReadLock(DWORD dwTimeout)
{
    PRINTF("%d wants to read\n", GetCurrentThreadId());


    // Get in line for getting any kind of lock (those unlocking don't go into
    // this line)
    // =======================================================================
    DWORD_PTR dwThreadId = GetCurrentThreadId();
    
    LockGuard<CriticalSection> lgEnter(m_csEntering);
    if (!lgEnter.locked())
    {
        DebugBreak();
    	return TimedOut;
    }

    // We are the only ones allowed to get any kind of lock now. Wait for the
    // event indicating that reading is enabled to become signaled
    // ======================================================================

    PRINTF("%d next to enter\n", GetCurrentThreadId());
    if(m_nWriting != 0)
    {
        int nRes = WaitFor(m_hCanRead, dwTimeout);
        if(nRes != NoError)
        {
            return nRes;
        }
    }

    // Enter inner critical section (unlockers use it too), increment the
    // number of readers and disable writing.
    // ==================================================================

    PRINTF("%d got event\n", GetCurrentThreadId());

    LockGuard<CriticalSection> lgAll(m_csAll);
    if (!lgAll.locked())
    {    
	    if(m_nReading == 0)
	    {
	        // this is for the read lock acquired on one thread and release on one other        
	        m_dwArrayIndex = 0;
	        
	        if(!SetEvent(m_hCanWrite))
	        {
                DebugBreak();	        
	            return Failed;
	        }
	    }
        DebugBreak();
        return TimedOut;
    }
    	
    m_nReading++;

    DBG_PRINTFA((pBuff,"+ (%08x) %d\n",GetCurrentThreadId(),m_nReading));

    if (m_dwArrayIndex < MaxRegistredReaders)
    {
        m_adwReaders[m_dwArrayIndex].ThreadId = dwThreadId;
        ULONG Hash;
        //RtlCaptureStackBackTrace(1,MaxTraceSize,m_adwReaders[m_dwArrayIndex].Trace,&Hash);
        m_dwArrayIndex++;
    }
    //m_adwReaders.Add((void*)dwThreadId);
    
    PRINTF("Reset write\n");
    ResetEvent(m_hCanWrite);
    PRINTF("Done\n");

	if (m_nWriting)
	{
		//OutputDebugString(L"WinMgmt: Read lock aquired while write lock is aquired!\n");
		DebugBreak();
	}

    // Get out of all critical sections and return
    // ===========================================

    PRINTF("%d begins to read\n", GetCurrentThreadId());

    return NoError;
}

//******************************************************************************
//
//  See lock.h for documentation
//
//******************************************************************************

int CLock::ReadUnlock()
{
    PRINTF("%d wants to unlock reading\n", GetCurrentThreadId());

    // Enter internal ciritcal section and decrement the number of readers
    // ===================================================================

    LockGuard<CriticalSection> gl(m_csAll);

    while (!gl.locked())
    {
    	Sleep(20);
    	gl.acquire();
    };

    m_nReading--;

    DBG_PRINTFA((pBuff,"- (%08x) %d\n",GetCurrentThreadId(),m_nReading));

    if(m_nReading < 0)
	{
		//OutputDebugString(L"WinMgmt: Repository detected more read unlocks than locks\n");
		DebugBreak();
		return Failed;
	}

    DWORD_PTR dwThreadId = GetCurrentThreadId();
    for(int i = 0; i < MaxRegistredReaders; i++)
    {
        if(m_adwReaders[i].ThreadId == dwThreadId)
        {
            m_adwReaders[i].ThreadId = 0;
            break;
        }
    }

    // If all readers are gone, allow writers in
    // =========================================

    if(m_nReading == 0)
    {
        // this is for the read lock acquired on one thread and release on one other                
        m_dwArrayIndex = 0;
        
        PRINTF("%d is the last reader\n", GetCurrentThreadId());
        PRINTF("Set write\n");
        if(!SetEvent(m_hCanWrite))
        {
            DebugBreak();
            return Failed;
        }
        PRINTF("Done\n");
    }
    else PRINTF("%d sees %d still reading\n", GetCurrentThreadId(), m_nReading);

    // Get out and return
    // ==================

    return NoError;
}

//******************************************************************************
//
//  See lock.h for documentation
//
//******************************************************************************

int CLock::WriteLock(DWORD dwTimeout)
{
    PRINTF("%d wants to write\n", GetCurrentThreadId());

    // Get in line for getting any kind of lock. Those unlocking don't use this
    // critical section.
    // ========================================================================

    LockGuard<CriticalSection> lgEnter(m_csEntering);
    if (!lgEnter.locked())
    {
        DebugBreak();
    	return TimedOut;
    }

    // We are the only ones allowed to get any kind of lock now
    // ========================================================

    PRINTF("%d next to enter\n", GetCurrentThreadId());

    // Wait for the event allowing writing to become signaled
    // ======================================================

    int nRes = WaitFor(m_hCanWrite, dwTimeout);
    PRINTF("%d got event\n", GetCurrentThreadId());
    if(nRes != NoError)
    {            
        DebugBreak();
        return nRes;
    }

    // Enter internal critical section (unlockers use it too), increment the
    // number of writers (from 0 to 1) and disable both reading and writing
    // from now on.
    // ======================================================================

    LockGuard<CriticalSection> lgAll(m_csAll);
    if (!lgAll.locked())
    {
        if(!SetEvent(m_hCanWrite))
        	DebugBreak();
        DebugBreak();
        return TimedOut;
    }

    m_WriterId = GetCurrentThreadId();
    m_nWriting++;

    DBG_PRINTFA((pBuff,"+ (%08x) %d W %d\n",GetCurrentThreadId(),m_nReading,m_nWriting));
    
    PRINTF("Reset both\n");
    ResetEvent(m_hCanWrite);
    ResetEvent(m_hCanRead);
    PRINTF("Done\n");

	if (m_nReading)
	{
		//OutputDebugString(L"WinMgmt: Write lock aquired while read lock is aquired!\n");
		DebugBreak();
	}

    // Get out and return
    // ==================
    PRINTF("%d begins to write\n", GetCurrentThreadId());

    return NoError;
}

//******************************************************************************
//
//  See lock.h for documentation
//
//******************************************************************************

int CLock::WriteUnlock()
{
    PRINTF("%d wants to release writing\n", GetCurrentThreadId());

    // Enter lock determination critical section
    // =========================================

    LockGuard<CriticalSection> gl(m_csAll);

    while (!gl.locked())
    {
    	Sleep(20);
    	gl.acquire();
    };
    
    m_nWriting--;

    DBG_PRINTFA((pBuff,"- (%08x) %d W %d\n",GetCurrentThreadId(),m_nReading,m_nWriting));
    
    m_WriterId = 0;
    if(m_nWriting < 0) 
	{
		//OutputDebugString(L"WinMgmt: Repository detected too many write unlocks\n");
		DebugBreak();
		return Failed;
	}

    // Allow readers and writers in
    // ============================

    PRINTF("%d released writing\n", GetCurrentThreadId());

    PRINTF("Set both\n");
    if(!SetEvent(m_hCanRead))
    {
		DebugBreak();    
        return Failed;
    }
    else if(!SetEvent(m_hCanWrite))
    {
		DebugBreak();    
        return Failed;
    }
    else
    {
        PRINTF("Done\n");
        return NoError;
    }
}

//******************************************************************************
//
//  See lock.h for documentation
//
//******************************************************************************

int CLock::WaitFor(HANDLE hEvent, DWORD dwTimeout)
{
    DWORD dwRes;
    dwRes = WaitForSingleObject(hEvent, dwTimeout);

    // Analyze the error code and convert to ours
    // ==========================================

    if(dwRes == WAIT_OBJECT_0) return NoError;
    else if(dwRes == WAIT_TIMEOUT) return TimedOut;
    else return Failed;
}

//******************************************************************************
//
//  See lock.h for documentation
//
//******************************************************************************

int CLock::DowngradeLock()
{
    // Enter lock determination critical section
    // =========================================
    LockGuard<CriticalSection> gl(m_csAll);

    while (!gl.locked())
    {
    	Sleep(20);
    	gl.acquire();
    };

    m_nWriting--;
    m_WriterId = 0;    

    if(!SetEvent(m_hCanRead))
    {
        DebugBreak();
        return Failed;
    }

    m_nReading++;
    if (1 != m_nReading)
    	DebugBreak();

    DBG_PRINTFA((pBuff,"+ (%08x) %d\n",GetCurrentThreadId(),m_nReading));    
    
    DWORD_PTR dwThreadId = GetCurrentThreadId();
    if (m_dwArrayIndex < MaxRegistredReaders)
    {
        m_adwReaders[m_dwArrayIndex].ThreadId = dwThreadId;
        ULONG Hash;
        //RtlCaptureStackBackTrace(1,MaxTraceSize,m_adwReaders[m_dwArrayIndex].Trace,&Hash);
        m_dwArrayIndex++;
    }
   
    return NoError;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\xfiles\pagemanager.cpp ===
#include <windows.h>

#ifdef __XFILES_TEST_PAGE_MANAGER

#include <stdio.h>
#include <unk.h>
#include <arrtempl.h>
#include <FlexArry.h>
#include "pagemgr.h"
#include <wbemutil.h>

//#define PF_VERBOSE_LOGGING

//*****************************************************************************
//*****************************************************************************
CPageFile::CPageFile(const char *pszFile)
: m_bInTransaction (false), m_pszFile(pszFile)
{
}
//*****************************************************************************
//*****************************************************************************
CPageFile::~CPageFile()
{
}
//*****************************************************************************
//*****************************************************************************
ULONG CPageFile::AddRef( )
{
	return 0;
}
//*****************************************************************************
//*****************************************************************************
ULONG CPageFile::Release( )
{
	return 0;
}

DWORD CPageFile::RetrievePage(DWORD dwId, Page **ppPage)
{
#ifdef PF_VERBOSE_LOGGING
    ERRORTRACE((LOG_REPDRV, "%s: Retrieving page 0x%08X\n", m_pszFile, dwId));
#endif
	DWORD dwRes = ERROR_FILE_NOT_FOUND;

	PAGETABLE::iterator iter = m_aTransactionPageTable.find(dwId);
	if (iter != m_aTransactionPageTable.end())
	{
		*ppPage = iter->second;
		dwRes = ERROR_SUCCESS;
	}
	else
	{
		iter = m_aMasterPageTable.find(dwId);
		if (iter != m_aMasterPageTable.end())
		{
			*ppPage = iter->second;
			dwRes = ERROR_SUCCESS;
		}
	}
	return dwRes; 
}

//*****************************************************************************
//*****************************************************************************
DWORD CPageFile::StorePage(Page *pPage)
{
#ifdef PF_VERBOSE_LOGGING
    ERRORTRACE((LOG_REPDRV, "%s: Storing page 0x%08X, %s\n", m_pszFile, pPage->dwPageId, (pPage->bActive?"": "DELETED")));
#endif
	if (!m_bInTransaction)
	{
		OutputDebugString(L"Storing page outside a transaction!\n");
		DebugBreak();
	}
	DWORD dwRes = ERROR_FILE_NOT_FOUND;

	PAGETABLE::iterator iter = m_aTransactionPageTable.find(pPage->dwPageId);
	if (iter != m_aTransactionPageTable.end())
	{
		Page *pExistingPage = iter->second;

		if (!pExistingPage->bActive)
		{
			//We should not be storing a page over the top of a deleted page!!!
			DebugBreak();
			dwRes = ERROR_INVALID_OPERATION;
		}
		else
		{
			CopyMemory(pExistingPage, pPage, sizeof(Page));
			dwRes = ERROR_SUCCESS;
		}
	}
	else
	{
		dwRes = ERROR_SUCCESS;
		Page *pNewPage = new Page;
		if (pNewPage == NULL)
		{
			dwRes = ERROR_OUTOFMEMORY;
		}
		else
		{
			CopyMemory(pNewPage, pPage, sizeof(Page));
			m_aTransactionPageTable[pNewPage->dwPageId] = pNewPage;
		}
	}

	return dwRes;
}
//*****************************************************************************
//*****************************************************************************
DWORD CPageFile::GetPage(
    DWORD dwId,                     
    DWORD dwFlags,
    LPVOID pPage
    )
{
	Page *pExistingPage;
	DWORD dwRes = RetrievePage(dwId, &pExistingPage);
	if ((dwRes == ERROR_SUCCESS) && (pExistingPage->bActive))
	{
		CopyMemory(pPage, pExistingPage->aPage, WMIREP_PAGE_SIZE);
	}
	else if (dwRes == ERROR_SUCCESS)
	{
		//Should not be retrieving a deleted page!!!!!
		DebugBreak();
		dwRes = ERROR_INVALID_OPERATION;
	}

	return dwRes;
}

//*****************************************************************************
//*****************************************************************************
DWORD CPageFile::PutPage(
    DWORD dwId,
    DWORD dwFlags,
    LPVOID pbPage
    ) 
{ 
	Page *pExistingPage;
	DWORD dwRes = RetrievePage(dwId, &pExistingPage);

	if (dwRes == ERROR_SUCCESS)
	{
		if (!pExistingPage->bActive)
		{
			//Should not be retrieving a deleted page!!!!!
			DebugBreak();
			dwRes = ERROR_INVALID_OPERATION;
		}
		else
		{
			Page *pNewPage = new Page;
			if (pNewPage == NULL)
			{
				dwRes = ERROR_OUTOFMEMORY;
			}
			else
			{
				pNewPage->bActive = true;
				pNewPage->dwPageId = dwId;
				CopyMemory(pNewPage->aPage, pbPage, WMIREP_PAGE_SIZE);
				dwRes = StorePage(pNewPage);
				delete pNewPage;
			}
		}
	}
	return dwRes; 
}

//*****************************************************************************
//*****************************************************************************
DWORD CPageFile::NewPage(
    DWORD dwFlags,
    DWORD dwCount,
    DWORD *pdwFirstId
    ) 
{ 
	DWORD dwFreeId = 0;

	if (dwCount > 1)
	{
		//This is a multi-page item, so we get the last used ID and the position
		//is the end of the list
		DWORD dwTranFree = 0;
		DWORD dwMasterFree = 0;
		if (m_aTransactionPageTable.size())
		{
			PAGETABLE::iterator it = m_aTransactionPageTable.end();
			it--;

			dwTranFree = it->first + 1;
		}
		if (m_aMasterPageTable.size())
		{
			PAGETABLE::iterator it = m_aMasterPageTable.end();
			it--;

			dwMasterFree = it->first + 1;
		}
		if (dwTranFree > dwMasterFree)
		{
			dwFreeId = dwTranFree;
		}
		else
		{
			dwFreeId = dwMasterFree;
		}
	}
	else if (dwFlags == 1)
	{
		//Allocation of admin page
		dwFreeId = 0;
	}
	else
	{
		//Grab the first one from the free list
		PAGEFREELIST::iterator it = m_aFreeList.begin();
		if (it != m_aFreeList.end())
		{
			dwFreeId = it->first;
			m_aFreeList.erase(it);
		}
		else
		{
			//We have nothing in the free list, so grab the next ID from
			//the transaction and master pages and use the largest one.
			DWORD dwTranFree = 0;
			DWORD dwMasterFree = 0;
			if (m_aTransactionPageTable.size())
			{
				PAGETABLE::iterator it = m_aTransactionPageTable.end();
				it--;

				dwTranFree = it->first + 1;
			}
			if (m_aMasterPageTable.size())
			{
				PAGETABLE::iterator it = m_aMasterPageTable.end();
				it--;

				dwMasterFree = it->first + 1;
			}
			if (dwTranFree > dwMasterFree)
			{
				dwFreeId = dwTranFree;
			}
			else
			{
				dwFreeId = dwMasterFree;
			}
		}
	}

	//Record the ID for the caller
	*pdwFirstId = dwFreeId;

	//Loop through the number of pages required
	while (dwCount--)
	{
		Page *pPage = new Page;
		if (pPage == NULL)
			return ERROR_OUTOFMEMORY;

		pPage->dwPageId = dwFreeId++;
		pPage->bActive = true;

		StorePage(pPage);

		delete pPage;
	}

	
	return ERROR_SUCCESS; 
}

//*****************************************************************************
//*****************************************************************************
DWORD CPageFile::FreePage(
    DWORD dwFlags,
    DWORD dwId
    ) 
{ 
	if (dwId == 0)
		DebugBreak();

	DWORD dwRes = ERROR_FILE_NOT_FOUND;
	Page *pPage;
	dwRes =	RetrievePage(dwId, &pPage);
	if ((dwRes == ERROR_FILE_NOT_FOUND) || (!pPage->bActive))
	{
		//Should not be freeing a not-found or already deleted page
		DebugBreak();
		dwRes = ERROR_INVALID_OPERATION;
	}
	else
	{
		Page *pNewPage = new Page;
		pNewPage->bActive = false;
		pNewPage->dwPageId = dwId;
		StorePage(pNewPage);
		delete pNewPage;
	}
	return dwRes; 
}
DWORD CPageFile::BeginTran()
{
#ifdef PF_VERBOSE_LOGGING
    ERRORTRACE((LOG_REPDRV, "%s: Begin Transaction\n", m_pszFile));
#endif
	if (m_bInTransaction)
	{
		OutputDebugString(L"WinMgmt: Nested transasctions are NOT supported!\n");
		DebugBreak();
	}
	m_bInTransaction = true;
	return ERROR_SUCCESS;
}
DWORD CPageFile::CommitTran()
{
#ifdef PF_VERBOSE_LOGGING
    ERRORTRACE((LOG_REPDRV, "%s: Commit Transaction\n", m_pszFile));
#endif
	if (!m_bInTransaction)
	{
		OutputDebugString(L"WinMgmt: Commiting a transaction when we are NOT in a transaction!\n");
		DebugBreak();
	}
	PAGETABLE::iterator it;
	while (m_aTransactionPageTable.size())
	{
		it = m_aTransactionPageTable.begin();

		PAGETABLE::iterator masterIt = m_aMasterPageTable.find(it->first);
		if (masterIt != m_aMasterPageTable.end())
		{
			//replace it
			if (it->second->bActive)
			{
#ifdef PF_VERBOSE_LOGGING
				ERRORTRACE((LOG_REPDRV, "%s: Replacing existing page in master page list <0x%08X>\n", m_pszFile, it->first));
#endif
				CopyMemory(masterIt->second, it->second, sizeof(Page));
			}
			else
			{
				//Deleted page and add id to free list!
#ifdef PF_VERBOSE_LOGGING
				ERRORTRACE((LOG_REPDRV, "%s: Deleting page in master page list <0x%08X>\n", m_pszFile, it->first));
#endif
				m_aFreeList[it->first] = it->first;
				delete masterIt->second;
				m_aMasterPageTable.erase(masterIt);
			}
			delete it->second;
		}
		else
		{
#ifdef PF_VERBOSE_LOGGING
			ERRORTRACE((LOG_REPDRV, "%s: Creating new page in master page list <0x%08X>\n", m_pszFile, it->first));
#endif
			m_aMasterPageTable[it->first] = it->second;
		}
		m_aTransactionPageTable.erase(it);
	}
	m_bInTransaction = false;
#ifdef PF_VERBOSE_LOGGING
	ERRORTRACE((LOG_REPDRV, "%s: Commit Transaction completed\n", m_pszFile));
#endif
	return ERROR_SUCCESS;
}
DWORD CPageFile::AbortTran()
{
#ifdef PF_VERBOSE_LOGGING
    ERRORTRACE((LOG_REPDRV, "%s: Abort Transaction\n", m_pszFile));
#endif
	PAGETABLE::iterator it;
	while (m_aTransactionPageTable.size())
	{
		it = m_aTransactionPageTable.begin();

#ifdef PF_VERBOSE_LOGGING
		ERRORTRACE((LOG_REPDRV, "%s: Rolling back page <0x%08X>\n", m_pszFile, it->first));
#endif
		delete it->second;
		m_aTransactionPageTable.erase(it);
	}
	m_bInTransaction = false;
#ifdef PF_VERBOSE_LOGGING
    ERRORTRACE((LOG_REPDRV, "%s: Abort Transaction\n", m_pszFile));
#endif
	return ERROR_SUCCESS;
}

//*****************************************************************************
//*****************************************************************************
CPageSource::CPageSource()
: m_pHeap(0)
{
}

//*****************************************************************************
//*****************************************************************************
CPageSource::~CPageSource()
{
}

//*****************************************************************************
//*****************************************************************************
DWORD CPageSource::Init(
						DWORD  dwCachePages,
						DWORD  dwCheckpointTime,    // milliseconds
						DWORD  dwPageSize
						)
{
	m_pHeap = new CPageFile("ObjHeap");
	m_pIndex = new CPageFile("Index");
	return ERROR_SUCCESS;
}

//*****************************************************************************
//*****************************************************************************
DWORD CPageSource::Shutdown(DWORD dwShutdownType	)
{
	delete m_pHeap;
	delete m_pIndex;
	return ERROR_SUCCESS;
}

//*****************************************************************************
//*****************************************************************************
DWORD CPageSource::GetBTreePageFile(OUT CPageFile **pPF)
{
	*pPF = m_pIndex;
	return ERROR_SUCCESS;
}
//*****************************************************************************
//*****************************************************************************
DWORD CPageSource::GetObjectHeapPageFile(OUT CPageFile **pPF)
{
	*pPF = m_pHeap;
	return ERROR_SUCCESS;
}

// Transactions

//*****************************************************************************
//*****************************************************************************
DWORD CPageSource::BeginTrans()
{
	m_pIndex->BeginTran();
	return m_pHeap->BeginTran();
}
//*****************************************************************************
//*****************************************************************************
DWORD CPageSource::CommitTrans()
{
	m_pIndex->CommitTran();
	return m_pHeap->CommitTran();
}
//*****************************************************************************
//*****************************************************************************
DWORD CPageSource::RollbackTrans()
{
	m_pIndex->AbortTran();
	return m_pHeap->AbortTran();
}

//*****************************************************************************
//*****************************************************************************
DWORD CPageSource::Flush()
{
	return ERROR_SUCCESS;;
}

//*****************************************************************************
//*****************************************************************************
DWORD CPageSource::LastCommitVersion(DWORD *pdwCommitted)
{
	return ERROR_SUCCESS;
}
//*****************************************************************************
//*****************************************************************************
DWORD CPageSource::CurrentVersion(DWORD *pdwCurrent)
{
	return ERROR_SUCCESS;
}

// Checkpoint

//*****************************************************************************
//*****************************************************************************
DWORD CPageSource::Checkpoint()
{
	return ERROR_SUCCESS;
}
//*****************************************************************************
//*****************************************************************************
DWORD CPageSource::Dump(FILE *f)
{
	return ERROR_SUCCESS;
}

#endif /* __XFILES_TEST_PAGE_MANAGER */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\xfiles\pagemanager.h ===
//***************************************************************************
//
//  (c) 2001 by Microsoft Corp.  All Rights Reserved.
//
//  PageManager.H
//
//  Declarations for CPageFile, CPageSource for WMI repository for
//  Windows XP.
//
//
//  21-Feb-01       raymcc
//
//***************************************************************************

#ifndef _PAGEMGR_H_
#define _PAGEMGR_H_

#include <map>

#define WMIREP_PAGE_SIZE (8192)
class CPageSource;
typedef struct _Page
{
	DWORD dwPageId;
	bool  bActive;
	BYTE  aPage[WMIREP_PAGE_SIZE];
} Page;

typedef map<DWORD, Page*, less<DWORD> > PAGETABLE;
typedef map<DWORD, DWORD, less<DWORD> > PAGEFREELIST;

class CPageFile
{
	friend CPageSource;
	PAGETABLE m_aMasterPageTable;
	PAGETABLE m_aTransactionPageTable;
	PAGEFREELIST m_aFreeList;
	bool m_bInTransaction;
	const char *m_pszFile;

	DWORD dwCommitTrans();
	DWORD RollbackTrans();

    // Private methods

    CPageFile(const char *pszFile);
   ~CPageFile();

    DWORD Init(LPWSTR pszPrimaryFile, LPWSTR pszMapFile, DWORD dwPageSize, DWORD dwCacheSize);
    DWORD Shutdown();
	DWORD RetrievePage(DWORD dwId, Page **ppPage);
	DWORD StorePage(Page *pPage);

public:
    enum { InvalidPage = 0xFFFFFFFF };

    ULONG AddRef( );
    ULONG Release( );

    DWORD GetPage(
        DWORD dwId,                     // page zero is admin page; doesn't require NewPage() call
        DWORD dwFlags,
        LPVOID pPage
        );

    DWORD PutPage(
        DWORD dwId,
        DWORD dwFlags,
        LPVOID pPage
        );

    DWORD NewPage(
        DWORD dwFlags,
        DWORD dwCount,
        DWORD *pdwFirstId
        );

    DWORD FreePage(
        DWORD dwFlags,
        DWORD dwId
        );

    DWORD GetPageSize() { return WMIREP_PAGE_SIZE; }

	DWORD CommitTran();
	DWORD AbortTran();
	DWORD BeginTran();

    void  Dump(FILE *f);
};


class CPageSource
{
	CPageFile *m_pHeap;
	CPageFile *m_pIndex;

public:
	CPageSource();
	~CPageSource();
    DWORD Init(
        DWORD  dwCachePages = 128,
        DWORD  dwCheckpointTime = 15000,    // milliseconds
        DWORD  dwPageSize = 8192
        );

    DWORD Shutdown(DWORD dwShutdownType	);

    DWORD GetBTreePageFile(OUT CPageFile **pPF);    // Use Release() when done
    DWORD GetObjectHeapPageFile(OUT CPageFile **pPF);  // Use Release() when done

    // Transactions

    DWORD BeginTrans();
    DWORD CommitTrans();   // Flag allows full commit vs subcommit within checkpoint
    DWORD RollbackTrans();

	DWORD Flush();

    DWORD LastCommitVersion(DWORD *pdwCommitted);
    DWORD CurrentVersion(DWORD *pdwCurrent);

    // Checkpoint

    DWORD Checkpoint();
    DWORD Dump(FILE *f);
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\xfiles\lock.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    LOCK.H

Abstract:

	Generic class for obtaining read and write locks to some resource. 

	See lock.h for all documentation.

	Classes defined:

	CLock

History:

	a-levn  5-Sept-96       Created.
	3/10/97     a-levn      Fully documented

--*/

#ifndef __GATEWAY__LOCK__H_
#define __GATEWAY__LOCK__H_

#include <lockst.h>


//*****************************************************************************
//
//	class CLock
//
//	Generic class for obtaining read and write locks to some resource. 
//	Simultaneous reads are allowed, but no concurrent writes or concurrent 
//	read and write accesses are.
//
//	NOTE: this class is for in-process sinchronization only!
//
//	Usage: create an instance of this class and share it among the accessing
//	threads.  Threads must call member functions of the same instance to 
//	obtain and release locks.
//
//*****************************************************************************
//
//	ReadLock
//
//	Use this function to request read access to the resource. Access will be
//	granted once no threads are writing on the resource. You must call 
//	ReadUnlock once you are done reading.
//
//	Parameters:
//
//		DWORD dwTimeout		The number of milliseconds to wait for access.
//							If access is still unavailable after this time,
//							an error is returned.
//	Returns:
//
//		NoError		On Success
//		TimedOut	On timeout.
//		Failed		On system error
//
//*****************************************************************************
//
//	ReadUnlock
//
//	Use this function to release a read lock on the resource. No check is 
//	performed to assertain that this thread holds a lock. Unmatched calls to
//	ReadUnlock may lead to lock integrity violations!
//
//	Returns:
//
//		NoError		On success
//		Failed		On system error or unmatched call.
//
//*****************************************************************************
//
//	WriteLock
//
//	Use this function to request write access to the resource. Access will be
//	granted once no threads are reading or writing on the resource. You must 
//	call WriteUnlock once you are done writing.
//
//	Parameters:
//
//		DWORD dwTimeout		The number of milliseconds to wait for access.
//							If access is still unavailable after this time,
//							an error is returned.
//	Returns:
//
//		NoError		On Success
//		TimedOut	On timeout.
//		Failed		On system error
//
//*****************************************************************************
//
//	WriteUnlock
//
//	Use this function to release a write lock on the resource. No check is 
//	performed to assertain that this thread holds a lock. Unmatched calls to
//	WriteUnlock may lead to lock integrity violations!
//
//	Returns:
//
//		NoError		On success
//		Failed		On system error or unmatched call.
//
//*****************************************************************************
//
//  DowngradeLock
//
//  Use this function to "convert" a Write lock into a Read lock. That is, if
//  you are currently holding a write lock and call DowngradeLock, you will 
//  be holding a read lock with the guarantee that no one wrote anything between
//  the unlock and the lock
//
//  Returns:
//
//      NoError     On Success
//      Failed      On system error or unmatched call
//
//******************************************************************************
class CLock
{
public:
	enum { NoError = 0, TimedOut, Failed };

	int ReadLock(DWORD dwTimeout = INFINITE);
	int ReadUnlock();
	int WriteLock(DWORD dwTimeout = INFINITE);
	int WriteUnlock();

	int DowngradeLock();

	CLock();
	~CLock();

protected:
	int WaitFor(HANDLE hEvent, DWORD dwTimeout);

protected:
	int m_nWriting;
	int m_nReading;
	int m_nWaitingToWrite;
	int m_nWaitingToRead;

	CriticalSection m_csEntering;
	CriticalSection m_csAll;
	HANDLE m_hCanWrite;
	HANDLE m_hCanRead;
	DWORD m_WriterId;
	//CFlexArray m_adwReaders;
	enum { MaxRegistredReaders = 16,
	       MaxTraceSize = 7};
	DWORD m_dwArrayIndex;
	struct {
		DWORD ThreadId;
		//PVOID  Trace[MaxTraceSize];
	} m_adwReaders[MaxRegistredReaders];
};

class CAutoReadLock
{
public:
	CAutoReadLock(CLock *lock) : m_lock(lock), m_bLocked(FALSE) {  }
	~CAutoReadLock() { Unlock(); }
	void Unlock() {if ( m_bLocked) { m_lock->ReadUnlock(); m_bLocked = FALSE; } }
	bool Lock()   {if (!m_bLocked) { return m_bLocked = (CLock::NoError == m_lock->ReadLock())  ; } else {return false;}; }

private:
	CLock *m_lock;
	BOOL m_bLocked;
};
class CAutoWriteLock
{
public:
	CAutoWriteLock(CLock *lock) : m_lock(lock), m_bLocked(FALSE) { }
	~CAutoWriteLock() { Unlock(); }
	void Unlock() {if ( m_bLocked) { m_lock->WriteUnlock(); m_bLocked = FALSE; } }
	bool Lock()   {if (!m_bLocked) { return m_bLocked = (CLock::NoError == m_lock->WriteLock()); } else { return false; }; }

private:
	CLock *m_lock;
	BOOL m_bLocked;
};
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\xfiles\repositorypackager.h ===
/*++

Copyright (C) 2000-2001 Microsoft Corporation

Module Name:

    RepositoryPackager.h

Abstract:

    Recursively packages the contents of the repository directory into a single file,
	and unpackages it.

History:

    paulall	  07/26/00  Created.
	a-shawnb  07/27/00  Finished.

--*/

#ifndef __REPOSITORYPACKAGER_H_
#define __REPOSITORYPACKAGER_H_

#define PACKAGE_TYPE_NAMESPACE_START	1
#define PACKAGE_TYPE_NAMESPACE_END		2
#define PACKAGE_TYPE_FILE				3
#define PACKAGE_TYPE_END_OF_FILE		4

typedef struct _PACKAGE_HEADER
{
	char szSignature[10];
} PACKAGE_HEADER;

typedef struct _PACKAGE_SPACER
{
	DWORD dwSpacerType;
} PACKAGE_SPACER;

typedef struct _PACKAGER_SPACER_NAMESPACE : _PACKAGE_SPACER
{
	wchar_t wszNamespaceName[MAX_PATH+1];
} PACKAGE_SPACER_NAMESPACE;

typedef struct _PACKAGER_SPACER_FILE : _PACKAGE_SPACER
{
	wchar_t wszFileName[MAX_PATH+1];
	DWORD dwFileSize;
} PACKAGE_SPACER_FILE;

class CRepositoryPackager
{
    wchar_t m_wszFileToProcess[MAX_PATH+1];
private:
	HRESULT GetRepositoryDirectory(wchar_t wszRepositoryDirectory[MAX_PATH+1]);
	
	HRESULT PackageHeader(HANDLE hFile);
	HRESULT PackageContentsOfDirectory(HANDLE hFile, const wchar_t *wszRepositoryDirectory);
	HRESULT PackageDirectory(HANDLE hFile, const wchar_t *wszParentDirectory, wchar_t *wszSubDirectory);
	HRESULT PackageFile(HANDLE hFile, const wchar_t *wszParentDirectory, wchar_t *wszFilename);
	HRESULT PackageTrailer(HANDLE hFile);
	
	HRESULT UnPackageHeader(HANDLE hFile);
	HRESULT UnPackageContentsOfDirectory(HANDLE hFile, const wchar_t *wszRepositoryDirectory);
	HRESULT UnPackageDirectory(HANDLE hFile, const wchar_t *wszParentDirectory);
	HRESULT UnPackageFile(HANDLE hFile, const wchar_t *wszParentDirectory);

	HRESULT DeleteContentsOfDirectory(const wchar_t *wszRepositoryDirectory);
	HRESULT PackageDeleteDirectory(const wchar_t *wszParentDirectory, wchar_t *wszSubDirectory);

public:
	CRepositoryPackager() {}
	~CRepositoryPackager() {}
	
	HRESULT PackageRepository(const wchar_t *wszFilename);
	HRESULT UnpackageRepository(const wchar_t *wszFilename);
	HRESULT DeleteRepository();
};

#endif // __REPOSITORYPACKAGER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\xfiles\objheap.cpp ===
#include <wbemcomn.h>
#include "a51tools.h"
#include "objheap.h"
#include "index.h"

#define ROSWELL_HEAPALLOC_TYPE_BUSY 0xA51A51A5

//*******************************************************************
//*******************************************************************
long CObjectHeap::Initialize(CPageSource  * pAbstractSource, 
                             WCHAR * wszBaseName,
                             DWORD dwBaseNameLen)
{
    if (m_bInit)
        return ERROR_SUCCESS;
        
    long lRes;
    
    lRes = m_Heap.Initialize(pAbstractSource);

    if(lRes != ERROR_SUCCESS)
        return lRes;

    lRes = m_Index.Initialize(dwBaseNameLen, wszBaseName, pAbstractSource);
    if(lRes != ERROR_SUCCESS)
        return lRes;

    m_bInit = TRUE;

    return lRes;
}

//*******************************************************************
//*******************************************************************
long CObjectHeap::Uninitialize(DWORD dwShutDownFlags)
{
    if (!m_bInit)
        return ERROR_SUCCESS;
        
    m_Index.Shutdown(dwShutDownFlags);

    m_Heap.Shutdown(dwShutDownFlags);

    m_bInit = FALSE;

    return ERROR_SUCCESS;
}

//*******************************************************************
//*******************************************************************
void CObjectHeap::InvalidateCache()
{
    m_Index.InvalidateCache();
    m_Heap.InvalidateCache();
}

//*******************************************************************
//*******************************************************************
long CObjectHeap::GetIndexFileName(LPCWSTR wszFilePath, LPWSTR wszIndexFileName)
{
    WIN32_FIND_DATAW wfd;

    long lRes = m_Index.FindFirst(wszFilePath, &wfd, NULL);
    if(lRes != ERROR_SUCCESS)
    {
        if(lRes == ERROR_PATH_NOT_FOUND)
            lRes = ERROR_FILE_NOT_FOUND;
        return lRes;
    }

    wcscpy(wszIndexFileName, wfd.cFileName);
    return ERROR_SUCCESS;
}

//*******************************************************************
//*******************************************************************
long CObjectHeap::GetFileInfo(LPCWSTR wszFilePath, TPage *pnPage, TOffset* pnOffset,
                            DWORD* pdwLength)
{
    CFileName wszIndexFileName;
    if(wszIndexFileName == NULL)
        return ERROR_OUTOFMEMORY;

    long lRes = GetIndexFileName(wszFilePath, wszIndexFileName);
    if(lRes != ERROR_SUCCESS)
        return lRes;

    return ParseInfoFromIndexFile(wszIndexFileName, pnPage, pnOffset, pdwLength);
}

//*******************************************************************
//*******************************************************************
long CObjectHeap::ParseInfoFromIndexFile(LPCWSTR wszIndexFileName, 
										TPage *pnPage,
                                        TOffset* pnOffset, 
										DWORD* pdwLength)
{
    WCHAR* pDot = wcschr(wszIndexFileName, L'.');
    if(pDot == NULL)
        return ERROR_INVALID_PARAMETER;

    WCHAR* pwc = pDot+1;
    *pnPage = 0;
    while(*pwc && *pwc != L'.')
    {
        *pnPage = (*pnPage * 10) + (*pwc - '0');
		pwc++;
    }

    if(*pwc != L'.')
        return ERROR_INVALID_PARAMETER;

    pwc++;

    *pnOffset = 0;
    while(*pwc && *pwc != L'.')
    {
        *pnOffset = (*pnOffset * 10) + (*pwc - '0');
		pwc++;
    }

    if(*pwc != L'.')
        return ERROR_INVALID_PARAMETER;

    pwc++;

    *pdwLength = 0;
    while(*pwc && *pwc != L'.')
    {
        *pdwLength = (*pdwLength * 10) + (*pwc - '0');
		pwc++;
    }

    return ERROR_SUCCESS;
}

//*******************************************************************
//*******************************************************************
long CObjectHeap::CreateIndexFile(LPCWSTR wszFilePath, 
								  TPage nPage, 
								  TOffset nOffset,
								  DWORD dwLength)
{
    //
    // Simply append the numbers to the file path
    //

    CFileName wszIndexFilePath;
    if(wszIndexFilePath == NULL)
        return ERROR_OUTOFMEMORY;

    swprintf(wszIndexFilePath, L"%s.%u.%u.%u",
        wszFilePath, nPage, nOffset, dwLength);

    return CreateZeroLengthFile(wszIndexFilePath);
}

//*******************************************************************
//*******************************************************************
long CObjectHeap::DeleteIndexFile(LPCWSTR wszFilePath, LPCWSTR wszIndexFileName)
{
    //
    // Construct the full path to the index file by concatenating the directory 
    // of the original file with the name
    //

    CFileName wszIndexFilePath;
    if(wszIndexFilePath == NULL)
        return ERROR_OUTOFMEMORY;

    WCHAR* pwcLastSlash = wcsrchr(wszFilePath, L'\\');
    if(pwcLastSlash == NULL)
        return ERROR_INVALID_PARAMETER;

    int nPrefixLen = (pwcLastSlash - wszFilePath + 1);
    memcpy(wszIndexFilePath, wszFilePath, nPrefixLen * sizeof(WCHAR));

    wcscpy(wszIndexFilePath + nPrefixLen, wszIndexFileName);
	return DeleteZeroLengthFile(wszIndexFilePath);
}

    

//*******************************************************************
//*******************************************************************
long CObjectHeap::CreateZeroLengthFile(LPCWSTR wszFilePath)
{
	return m_Index.Create(wszFilePath);
}

//*******************************************************************
//*******************************************************************
long CObjectHeap::DeleteZeroLengthFile(LPCWSTR wszFilePath)
{
    return m_Index.Delete(wszFilePath);
}
    
//*******************************************************************
//*******************************************************************
long CObjectHeap::WriteAllocation(DWORD dwDataLength, BYTE* pData, TPage *pnPage, TOffset *pnOffset)
{
    return m_Heap.WriteNewBuffer(dwDataLength, pData, pnPage, pnOffset);
}
//*******************************************************************
//*******************************************************************
long CObjectHeap::WriteExistingAllocation(TPage nOldPage, TOffset nOldOffset, DWORD dwDataLength, BYTE *pBuffer, DWORD *pnNewPage, DWORD *pnNewOffset)
{
    return m_Heap.WriteExistingBuffer(dwDataLength, pBuffer, nOldPage, nOldOffset, pnNewPage, pnNewOffset);
}

//*******************************************************************
//*******************************************************************
long CObjectHeap::ReadAllocation(TPage nPage, TOffset nOffset, DWORD dwDataLength, BYTE* pBuffer)
{
    //
    // Prepare a buffer with the complete allocation
    //

    BYTE* pAllocation;
	DWORD dwReadLength;

    long lRes = m_Heap.ReadBuffer(nPage, nOffset, &pAllocation, &dwReadLength);
    if(lRes != ERROR_SUCCESS)
        return lRes;

    memcpy(pBuffer, pAllocation, dwDataLength);

	delete [] pAllocation;

    return ERROR_SUCCESS;
}
    

//*******************************************************************
//*******************************************************************
long CObjectHeap::WriteObject(LPCWSTR wszFilePath1, LPCWSTR wszFilePath2, DWORD dwBufferLen, BYTE* pBuffer)
{
    if (!m_bInit)
        return -1;

    long lRes;

    if(dwBufferLen == 0)
    {
        //
        // We do not use the heap for 0-length files, we create them directly
        //

        return CreateZeroLengthFile(wszFilePath1);
    }

    //
    // Now, check if this file already exists
    //

    CFileName wszIndexFileName1;
    if(wszIndexFileName1 == NULL)
        return ERROR_OUTOFMEMORY;

    lRes = GetIndexFileName(wszFilePath1, wszIndexFileName1);
    if(lRes != ERROR_FILE_NOT_FOUND && lRes != ERROR_SUCCESS)
        return lRes;

    if(lRes == ERROR_SUCCESS)
    {
        //
        // Already there. 
        //

		TPage nOldPage;
        TOffset nOldOffset;
        DWORD dwOldLength;
		TPage nNewPage;
		TOffset nNewOffset;

        lRes = ParseInfoFromIndexFile(wszIndexFileName1, &nOldPage, &nOldOffset, &dwOldLength);
        if(lRes != ERROR_SUCCESS)
            return lRes;


        //
        // Enough space in place --- just write the data and update the
        // length
        //

        lRes = WriteExistingAllocation(nOldPage, nOldOffset, dwBufferLen, pBuffer, &nNewPage, &nNewOffset);
        if(lRes != ERROR_SUCCESS)
            return lRes;

        if((dwOldLength != dwBufferLen) || (nOldPage != nNewPage) || (nOldOffset != nNewOffset))
        {

            //
            // One of the bits of the path has changed so we need to re-create the index
            //

            lRes = DeleteIndexFile(wszFilePath1, wszIndexFileName1);
            if(lRes != ERROR_SUCCESS)
                return lRes;

            lRes = CreateIndexFile(wszFilePath1, nNewPage, nNewOffset, dwBufferLen);
            if(lRes != ERROR_SUCCESS)
                return lRes;

			if (wszFilePath2)
			{
				CFileName wszIndexFileName2;
				if(wszIndexFileName2 == NULL)
					return ERROR_OUTOFMEMORY;
				lRes = GetIndexFileName(wszFilePath2, wszIndexFileName2);
				if(lRes != ERROR_SUCCESS)
					return lRes;

				lRes = DeleteIndexFile(wszFilePath2, wszIndexFileName2);
				if(lRes != ERROR_SUCCESS)
					return lRes;

				lRes = CreateIndexFile(wszFilePath2, nNewPage, nNewOffset, dwBufferLen);
				if(lRes != ERROR_SUCCESS)
					return lRes;
			}
        }

        return ERROR_SUCCESS;
    }

    //
    // it wasn't there
    //

	TPage nPage;
    TOffset nOffset;

    lRes = WriteAllocation(dwBufferLen, pBuffer, &nPage, &nOffset);
    if(lRes != ERROR_SUCCESS)
        return lRes;

    lRes = CreateIndexFile(wszFilePath1, nPage, nOffset, dwBufferLen);
    if(lRes != ERROR_SUCCESS)
        return lRes;

	if (wszFilePath2)
		lRes = CreateIndexFile(wszFilePath2, nPage, nOffset, dwBufferLen);
    
    return lRes;
}

//***********************************************************************
//***********************************************************************
long CObjectHeap::WriteLink(LPCWSTR wszLinkPath)
{
    if (!m_bInit)
        return -1;

    return CreateZeroLengthFile(wszLinkPath);
}
//*******************************************************************
//*******************************************************************
long CObjectHeap::ReadObject(LPCWSTR wszFilePath, DWORD* pdwLength, BYTE** ppBuffer)
{
    if (!m_bInit)
        return -1;    

    long lRes;

    //
    // Find the file
    //

	TPage nPage;
    TOffset nOffset;
    lRes = GetFileInfo(wszFilePath, &nPage, &nOffset, pdwLength);
    if(lRes != ERROR_SUCCESS)
        return lRes;

    //
    // Read the allocation
    //

    *ppBuffer = (BYTE*)TempAlloc(*pdwLength);
    if(*ppBuffer == NULL)
        return ERROR_OUTOFMEMORY;

    lRes = ReadAllocation(nPage, nOffset, *pdwLength, *ppBuffer);
    if(lRes != ERROR_SUCCESS)
    {
        TempFree(*ppBuffer);
        return lRes;
    }

    return ERROR_SUCCESS;
}

//*******************************************************************
//*******************************************************************
long CObjectHeap::DeleteLink(LPCWSTR wszFilePath)
{
    if (!m_bInit)
        return -1;    

    //
    // Find the index file
    //

    CFileName wszIndexFileName;
    if(wszIndexFileName == NULL)
        return ERROR_OUTOFMEMORY;

    long lRes = GetIndexFileName(wszFilePath, wszIndexFileName);
    if(lRes != ERROR_SUCCESS)
	{
        return lRes;
	}

	//If we have any index information at the end of the path we need to add that to
	//the main path and delete that.  The delete requires an accurate path.
	CFileName wszActualFileName;
    if(wszActualFileName == NULL)
        return ERROR_OUTOFMEMORY;

	wcscpy(wszActualFileName, wszFilePath);
	wchar_t *wszDot = wcschr(wszIndexFileName, L'.');
	if (wszDot != NULL)
		wcscat(wszActualFileName, wszDot);

	return DeleteZeroLengthFile(wszActualFileName);
}
//*******************************************************************
//*******************************************************************
long CObjectHeap::DeleteObject(LPCWSTR wszFilePath)
{
    if (!m_bInit)
        return -1;    

    //
    // Find the index file
    //

    CFileName wszIndexFileName;
    if(wszIndexFileName == NULL)
        return ERROR_OUTOFMEMORY;

    long lRes = GetIndexFileName(wszFilePath, wszIndexFileName);
    if(lRes != ERROR_SUCCESS)
        return lRes;

    //
    // Delete the allocation
    //

	TPage nPage;
    TOffset nOffset;
    DWORD dwLength;
    lRes = ParseInfoFromIndexFile(wszIndexFileName, &nPage, &nOffset, &dwLength);
	if(lRes == ERROR_INVALID_PARAMETER)
	{
		OutputDebugString(L"WinMgmt: Deleting an object that does not have details of where object is!\n");
		DebugBreak();
		return ERROR_INVALID_OPERATION;
    }
    
    lRes = m_Heap.DeleteBuffer(nPage, nOffset);
    if(lRes != ERROR_SUCCESS)
        return lRes;
    
    //
    // Delete the index itself
    //

    lRes = DeleteIndexFile(wszFilePath, wszIndexFileName);
    if(lRes != ERROR_SUCCESS)
        return lRes;

    return ERROR_SUCCESS;
}

long CObjectHeap::ObjectEnumerationBegin(const wchar_t *wszSearchPrefix, void **ppHandle)
{
	return IndexEnumerationBegin(wszSearchPrefix, ppHandle);
}

long CObjectHeap::ObjectEnumerationEnd(void *pHandle)
{
	return IndexEnumerationEnd(pHandle);
}

long CObjectHeap::ObjectEnumerationNext(void *pHandle, CFileName &wszFileName, BYTE **ppBlob, DWORD *pdwSize)
{
    if (!m_bInit)
        return -1;  
	
	long lRes = m_Index.IndexEnumerationNext(pHandle, wszFileName);

	if (lRes == ERROR_SUCCESS)
	{
		//We need to retrieve the object from the heap!
		TPage nPage;
		TOffset nOffset;
		DWORD dwLength;
		lRes = ParseInfoFromIndexFile(wszFileName, &nPage, &nOffset, &dwLength);
		if(lRes == ERROR_INVALID_PARAMETER)
			lRes = ERROR_SUCCESS;	//This is a plain enumeration, no blobs associated with it
		else
		{
			//Remove extra stuff from end of string...
			for (int nCount = 0, nIndex = wcslen(wszFileName); nCount != 3; nIndex --)
			{
				if (wszFileName[nIndex-1] == L'.')
				{
					if (++nCount == 3)
						wszFileName[nIndex-1] = L'\0';
				}

			}
			DWORD dwSize = 0;
			lRes = m_Heap.ReadBuffer(nPage, nOffset, ppBlob, &dwSize);
			*pdwSize = dwLength;
		}
	}
	return lRes;
}

long CObjectHeap::ObjectEnumerationFree(void *pHandle, BYTE *pBlob)
{
    if (!m_bInit)
        return -1; 

	delete [] pBlob;
	
	return ERROR_SUCCESS;
}

long CObjectHeap::IndexEnumerationBegin(const wchar_t *wszSearchPrefix, void **ppHandle)
{
    if (!m_bInit)
        return -1;
	return m_Index.IndexEnumerationBegin(wszSearchPrefix, ppHandle);
}
long CObjectHeap::IndexEnumerationEnd(void *pHandle)
{
    if (!m_bInit)
        return -1;    
	return m_Index.IndexEnumerationEnd(pHandle);
}
long CObjectHeap::IndexEnumerationNext(void *pHandle, CFileName &wszFileName)
{
    if (!m_bInit)
        return -1;  
	
	long lRes = m_Index.IndexEnumerationNext(pHandle, wszFileName);

	if (lRes == ERROR_SUCCESS)
	{
		wchar_t *pDot = wcschr(wszFileName, L'.');
		if (pDot)
			*pDot = L'\0';
	}

	return lRes;
}

long CObjectHeap::FlushCaches()
{
	long lRes = m_Index.FlushCaches();
	if (lRes == 0)
		lRes = m_Heap.FlushCaches();
	return lRes;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\xfiles\pagemgr.h ===
//***************************************************************************
//
//  (c) 2001 by Microsoft Corp.  All Rights Reserved.
//
//  PAGEMGR.H
//
//  Declarations for CPageFile, CPageSource for WMI repository for
//  Windows XP.
//
//  21-Feb-01       raymcc
//
//***************************************************************************

#ifndef _PAGEMGR_H_
#define _PAGEMGR_H_

#define WMIREP_PAGE_SIZE (8192)

#define WMIREP_INVALID_PAGE   0xFFFFFFFF
#define WMIREP_RESERVED_PAGE  0xFFFFFFFE

#define WMIREP_OBJECT_DATA L"OBJECTS.DATA"
#define WMIREP_OBJECT_MAP  L"OBJECTS.MAP"
#define WMIREP_BTREE_DATA L"INDEX.BTR"
#define WMIREP_BTREE_MAP  L"INDEX.MAP"

#include <vector>
#include <wstlallc.h>
#include <wstring.h>
#include <sync.h>


struct SCachePage
{
    BOOL   m_bDirty;
    DWORD  m_dwPhysId;
    LPBYTE m_pPage;

    SCachePage() { m_bDirty = 0; m_dwPhysId = 0; m_pPage = 0; }
   ~SCachePage() { if (m_pPage) delete [] m_pPage; }
};

class AutoClose
{
    HANDLE m_hHandle;
public:
    AutoClose(HANDLE h) { m_hHandle = h; }
   ~AutoClose() { CloseHandle(m_hHandle); }
};

class CPageCache
{
private:
    DWORD   m_dwStatus;

    DWORD   m_dwPageSize;
    DWORD   m_dwCacheSize;

    DWORD   m_dwCachePromoteThreshold;
    DWORD   m_dwCacheSpillRatio;

    DWORD   m_dwLastFlushTime;
    DWORD   m_dwWritesSinceFlush;
    DWORD   m_dwLastCacheAccess;
    DWORD   m_dwReadHits;
    DWORD   m_dwReadMisses;
    DWORD   m_dwWriteHits;
    DWORD   m_dwWriteMisses;

    HANDLE  m_hFile;

    // Page r/w cache
    std::vector <SCachePage *, wbem_allocator<SCachePage *> > m_aCache;
public:
    DWORD ReadPhysPage(                         // Does a real disk access
        IN  DWORD   dwPage,                     // Always physical ID
        OUT LPBYTE *pPageMem                    // Returns read-only pointer (copy of ptr in SCachePage struct)
        );

    DWORD WritePhysPage(                        // Does a real disk access
        DWORD dwPageId,                         // Always physical ID
        LPBYTE pPageMem                         // Read-only; doesn't acquire pointer
        );

    DWORD Spill();
    DWORD Empty();

    // Private methods
public:
    CPageCache();
   ~CPageCache();

    DWORD Init(
        LPCWSTR pszFilename,                    // File
        DWORD dwPageSize,                       // In bytes
        DWORD dwCacheSize = 64,                 // Pages in cache
        DWORD dwCachePromoteThreshold = 16,     // When to ignore promote-to-front
        DWORD dwCacheSpillRatio = 4             // How many additional pages to write on cache write-through
        );

    // Cache operations

    DWORD Write(                    // Only usable from within a transaction
        DWORD dwPhysId,
        LPBYTE pPageMem             // Acquires memory (operator new required)
        );

    DWORD Read(
        IN DWORD dwPhysId,
        OUT LPBYTE *pMem            // Use operator delete
        );

    DWORD Flush();
    DWORD Status() { return m_dwStatus; }

    DWORD EmptyCache() { DWORD dwRet = Flush();  if (dwRet == ERROR_SUCCESS) Empty(); return dwRet; }
    void  Dump(FILE *f);

    DWORD GetReadHits() { return m_dwReadHits; }
    DWORD GetReadMisses() { return m_dwReadMisses; }
    DWORD GetWriteHits()  { return m_dwWriteHits; }
    DWORD GetWriteMisses() { return m_dwWriteMisses; }
};

class CPageFile
{
private:
    friend class CPageSource;

    LONG              m_lRef;
    DWORD             m_dwStatus;
    DWORD             m_dwPageSize;
	DWORD			  m_dwCachePromotionThreshold;
	DWORD             m_dwCacheSpillRatio;

    CRITICAL_SECTION  m_cs;
    bool m_bCsInit;

    WString      m_sDirectory;
    WString      m_sMapFile;
    WString      m_sMainFile;

    CPageCache       *m_pCache;
    BOOL              m_bInTransaction;
    DWORD             m_dwLastCheckpoint;
    DWORD             m_dwTransVersion;

    // Generation A Mapping
    std::vector <DWORD, wbem_allocator<DWORD> > m_aPageMapA;
    std::vector <DWORD, wbem_allocator<DWORD> > m_aPhysFreeListA;
    std::vector <DWORD, wbem_allocator<DWORD> > m_aLogicalFreeListA;
    std::vector <DWORD, wbem_allocator<DWORD> > m_aReplacedPagesA;
    DWORD m_dwPhysPagesA;

    // Generation B Mapping
    std::vector <DWORD, wbem_allocator<DWORD> > m_aPageMapB;
    std::vector <DWORD, wbem_allocator<DWORD> > m_aPhysFreeListB;
    std::vector <DWORD, wbem_allocator<DWORD> > m_aLogicalFreeListB;
    std::vector <DWORD, wbem_allocator<DWORD> > m_aReplacedPagesB;
    DWORD m_dwPhysPagesB;

    std::vector <DWORD, wbem_allocator<DWORD> > m_aDeferredFreeList;

	//De-initialized the structure and marks it as such.  A ReInit is required
	//before things will work again
	DWORD DeInit();

	//Re-initialize after a DeInit
	DWORD ReInit();

public: // temp for testing
    // Internal methods
    DWORD Trans_Begin();
    DWORD Trans_Rollback();
    DWORD Trans_Commit();

    DWORD Trans_Checkpoint();

    DWORD InitFreeList();
    DWORD ResyncMaps();
    DWORD InitMap();
    DWORD ReadMap();
    DWORD WriteMap(LPCWSTR pszTempFile);

    DWORD AllocPhysPage(DWORD *pdwId);

    DWORD ReclaimLogicalPages(
        DWORD dwCount,
        DWORD *pdwId
        );

    DWORD GetTransVersion() { return m_dwTransVersion; }
    void DumpFreeListInfo();

public:
    CPageFile();
   ~CPageFile();

   //First-time initializatoin of structure
    DWORD Init(
        LPCWSTR pszDirectory,
        LPCWSTR pszMainFile,
        LPCWSTR pszMapFile,
        DWORD  dwRepPageSize,
        DWORD  dwCacheSize,
        DWORD  dwCachePromotionThreshold,
        DWORD  dwCacheSpillRatio
        );


    static DWORD Map_Startup(
        LPCWSTR pszDirectory,
        LPCWSTR pszBTreeMap,
        LPCWSTR pszObjMap
        );


    ULONG AddRef();
    ULONG Release();

    DWORD GetPage(
        DWORD dwId,                     // page zero is admin page; doesn't require NewPage() call
        DWORD dwFlags,
        LPVOID pPage
        );

    DWORD PutPage(
        DWORD dwId,
        DWORD dwFlags,
        LPVOID pPage
        );

    DWORD NewPage(
        DWORD dwFlags,
        DWORD dwCount,
        DWORD *pdwFirstId
        );

    DWORD FreePage(
        DWORD dwFlags,
        DWORD dwId
        );

    DWORD GetPageSize() { return m_dwPageSize; }
    DWORD GetNumPages() { return m_aPageMapB.size(); }
    DWORD GetPhysPage(DWORD dwLogical) { return m_aPageMapB[dwLogical]; }
    DWORD Status() { return m_dwStatus; }

	DWORD EmptyCache() 
	{ 
		if ((m_dwStatus == 0) && (m_pCache))
			return m_pCache->EmptyCache(); 
		else 
			return m_dwStatus;
	}

    void  Dump(FILE *f);
};

class CPageSource
{
private:

    DWORD m_dwPageSize;

	DWORD m_dwCacheSize;
	DWORD m_dwCachePromotionThreshold;
	DWORD m_dwCacheSpillRatio;

    DWORD m_dwLastCheckpoint;
    DWORD m_dwCheckpointInterval;
    WString m_sDirectory;
    WString m_sBTreeMap;
    WString m_sObjMap;

    CPageFile *m_pBTreePF;
    CPageFile *m_pObjPF;

    DWORD Restart();

public:
    CPageSource();
   ~CPageSource();

    DWORD Init(
        DWORD  dwCacheSize = 128,
        DWORD  dwCheckpointTime = 15000,
        DWORD  dwPageSize = 8192
        );

    DWORD Shutdown(DWORD dwFlags);

    DWORD GetBTreePageFile(OUT CPageFile **pPF);    // Use Release() when done
    DWORD GetObjectHeapPageFile(OUT CPageFile **pPF);  // Use Release() when done

    // Transactions

    DWORD BeginTrans();
    DWORD CommitTrans();
    DWORD RollbackTrans();

    // Checkpoint

    DWORD Checkpoint();
    DWORD CheckpointRollback();
    BOOL  CheckpointRequired();

	// Cache discard

	DWORD EmptyCaches();

    DWORD GetStatus()
    {
		if (m_pBTreePF && m_pBTreePF->Status())
			return m_pBTreePF->Status();
		else if (m_pObjPF && m_pObjPF->Status())
			return m_pObjPF->Status();
		else if (!m_pBTreePF && !m_pObjPF)
            return ERROR_GEN_FAILURE;
		else
			return 0;
    }

    void Dump(FILE *f);
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\xfiles\repositorypackager.cpp ===
/*++

Copyright (C) 2000-2001 Microsoft Corporation

Module Name:

    RepositoryPackager.CPP

Abstract:

    Recursively packages the contents of the repository directory into a single file,
	and unpackages it.

History:

    paulall	  07/26/00  Created.
	a-shawnb  07/27/00  Finished.

--*/

#include "precomp.h"
#include <wbemcli.h>
#include "RepositoryPackager.h"

/******************************************************************************
 *
 *	CRepositoryPackager::PackageRepository
 *
 *	Description:
 *		Iterates deeply through the repository directly and packages it up 
 *		into the given file specified by the given parameter.
 *		Repository directory is the one retrieved from the registry.
 *
 *	Parameters:
 *		wszFilename:	Filename we package everything up into
 *
 *	Return:
 *		HRESULT:		WBEM_S_NO_ERROR			If successful
 *						WBEM_E_OUT_OF_MEMORY	If out of memory
 *						WBEM_E_FAILED			If anything else failed
 *
 ******************************************************************************
 */
HRESULT CRepositoryPackager::PackageRepository(const wchar_t *wszFilename)
{
	HRESULT hres = WBEM_S_NO_ERROR;
	wchar_t wszRepositoryDirectory[MAX_PATH+1];
	HANDLE hFile = INVALID_HANDLE_VALUE;

    //Store the filename so when package files, we make sure we ignore this file!
    wcscpy(m_wszFileToProcess, wszFilename);

	//Get the root directory of the repository
	hres = GetRepositoryDirectory(wszRepositoryDirectory);

	//Create a new file to package contents up to...
	if (SUCCEEDED(hres))
	{
		hFile = CreateFileW(wszFilename, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
		if (hFile == INVALID_HANDLE_VALUE)
			hres = WBEM_E_FAILED;
	}

	//Write the package header...
	if (SUCCEEDED(hres))
	{
		hres = PackageHeader(hFile);
	}

	if (SUCCEEDED(hres))
	{
		hres = PackageContentsOfDirectory(hFile, wszRepositoryDirectory);
	}

	//Write the end of package marker
	if (SUCCEEDED(hres))
		hres = PackageTrailer(hFile);


	if (hFile != INVALID_HANDLE_VALUE)
		CloseHandle(hFile);

	//If things failed we should delete the file...
	if (FAILED(hres))
		DeleteFileW(wszFilename);
	return hres;
}


/******************************************************************************
 *
 *	CRepositoryPackager::UnpackageRepository
 *
 *	Description:
 *		Given the filename of a packaged up repository we unpack everything
 *		into the repository directory specified in the registry.  The 
 *		directory should have no files in it before doing this.
 *
 *	Parameters:
 *		wszFilename:	Filename we unpackage everything from
 *
 *	Return:
 *		HRESULT:		WBEM_S_NO_ERROR			If successful
 *						WBEM_E_OUT_OF_MEMORY	If out of memory
 *						WBEM_E_FAILED			If anything else failed
 *
 ******************************************************************************
 */
HRESULT CRepositoryPackager::UnpackageRepository(const wchar_t *wszFilename)
{
	HRESULT hres = WBEM_S_NO_ERROR;
	wchar_t wszRepositoryDirectory[MAX_PATH+1];
	HANDLE hFile = INVALID_HANDLE_VALUE;

	//Get the root directory of the repository
	hres = GetRepositoryDirectory(wszRepositoryDirectory);

	//open the file for unpacking...
	if (SUCCEEDED(hres))
	{
		hFile = CreateFileW(wszFilename, GENERIC_READ, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
		if (hFile == INVALID_HANDLE_VALUE)
			hres = WBEM_E_FAILED;
	}

	//unpack the package header...
	if (SUCCEEDED(hres))
	{
		hres = UnPackageHeader(hFile);
	}

	//unpack the file...
	if (SUCCEEDED(hres))
	{
		hres = UnPackageContentsOfDirectory(hFile, wszRepositoryDirectory);
	}

	if (hFile != INVALID_HANDLE_VALUE)
		CloseHandle(hFile);

	//If things failed we should delete the partially unpacked repository...
	if (FAILED(hres))
		DeleteRepository();

	return hres;
}

/******************************************************************************
 *
 *	CRepositoryPackager::DeleteRepository
 *
 *	Description:
 *		Delete all files and directories under the repository directory.
 *		The repository directory location is retrieved from the registry.
 *
 *	Parameters:
 *		<none>
 *
 *	Return:
 *		HRESULT:		WBEM_S_NO_ERROR			If successful
 *						WBEM_E_OUT_OF_MEMORY	If out of memory
 *						WBEM_E_FAILED			If anything else failed
 *
 ******************************************************************************
 */
HRESULT CRepositoryPackager::DeleteRepository()
{
	HRESULT hres = WBEM_S_NO_ERROR;
	wchar_t wszRepositoryDirectory[MAX_PATH+1];

	//Get the root directory of the repository
	hres = GetRepositoryDirectory(wszRepositoryDirectory);

	if (SUCCEEDED(hres))
	{
		hres = DeleteContentsOfDirectory(wszRepositoryDirectory);
	}
	
	return hres;
}


/******************************************************************************
 *
 *	CRepositoryPackager::PackageContentsOfDirectory
 *
 *	Description:
 *		Given a directory, iterates through all files and directories and
 *		calls into the function to package it into the file specified by the
 *		file handle passed to the method.
 *
 *	Parameters:
 *		hFile:					Handle to the destination file.
 *		wszRepositoryDirectory:	Directory to process
 *
 *	Return:
 *		HRESULT:		WBEM_S_NO_ERROR			If successful
 *						WBEM_E_OUT_OF_MEMORY	If out of memory
 *						WBEM_E_FAILED			If anything else failed
 *
 ******************************************************************************
 */
HRESULT CRepositoryPackager::PackageContentsOfDirectory(HANDLE hFile, const wchar_t *wszRepositoryDirectory)
{
	HRESULT hres  = WBEM_S_NO_ERROR;

	WIN32_FIND_DATAW findFileData;
	HANDLE hff = INVALID_HANDLE_VALUE;

	//create file search pattern...
	wchar_t *wszSearchPattern = new wchar_t[MAX_PATH+1];
	if (wszSearchPattern == NULL)
		hres = WBEM_E_OUT_OF_MEMORY;
	else
	{
		wcscpy(wszSearchPattern, wszRepositoryDirectory);
		wcscat(wszSearchPattern, L"\\*");
	}

	//Start the file iteration in this directory...
	if (SUCCEEDED(hres))
	{
		hff = FindFirstFileW(wszSearchPattern, &findFileData);
		if (hff == INVALID_HANDLE_VALUE)
		{
			hres = WBEM_E_FAILED;
		}
	}
	
	if (SUCCEEDED(hres))
	{
		do
		{
			//If we have a filename of '.' or '..' we ignore it...
			if ((wcscmp(findFileData.cFileName, L".") == 0) ||
				(wcscmp(findFileData.cFileName, L"..") == 0))
			{
				//Do nothing with these...
			}
			else if (findFileData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
			{
				//This is a directory, so we need to deal with that...
				hres = PackageDirectory(hFile, wszRepositoryDirectory, findFileData.cFileName);
				if (FAILED(hres))
					break;
			}
			else
			{
				//This is a file, so we need to deal with that...
				hres = PackageFile(hFile, wszRepositoryDirectory, findFileData.cFileName);
				if (FAILED(hres))
					break;
			}
			
		} while (FindNextFileW(hff, &findFileData));
	}

	if (wszSearchPattern)
		delete [] wszSearchPattern;

	if (hff != INVALID_HANDLE_VALUE)
		FindClose(hff);

	return hres;
}

/******************************************************************************
 *
 *	CRepositoryPackager::GetRepositoryDirectory
 *
 *	Description:
 *		Retrieves the location of the repository directory from the registry.
 *
 *	Parameters:
 *		wszRepositoryDirectory:	Array to store location in.
 *
 *	Return:
 *		HRESULT:		WBEM_S_NO_ERROR			If successful
 *						WBEM_E_OUT_OF_MEMORY	If out of memory
 *						WBEM_E_FAILED			If anything else failed
 *
 ******************************************************************************
 */
HRESULT CRepositoryPackager::GetRepositoryDirectory(wchar_t wszRepositoryDirectory[MAX_PATH+1])
{
    HKEY hKey;
    long lRes = RegOpenKeyExW(HKEY_LOCAL_MACHINE, 
                    L"SOFTWARE\\Microsoft\\WBEM\\CIMOM",
                    0, KEY_READ, &hKey);
    if(lRes)
        return WBEM_E_FAILED;

    wchar_t wszTmp[MAX_PATH + 1];
    DWORD dwLen = MAX_PATH + 1;
    lRes = RegQueryValueExW(hKey, L"Repository Directory", NULL, NULL, 
                (LPBYTE)wszTmp, &dwLen);
	RegCloseKey(hKey);
    if(lRes)
        return WBEM_E_FAILED;

	if (ExpandEnvironmentStringsW(wszTmp,wszRepositoryDirectory, MAX_PATH + 1) == 0)
		return WBEM_E_FAILED;

	return WBEM_S_NO_ERROR;
}

/******************************************************************************
 *
 *	CRepositoryPackager::PackageHeader
 *
 *	Description:
 *		Stores the header package in the given file.  This is a footprint
 *		so we can recognise if this really is one of our files when 
 *		we try to decode it.  Also it allows us to version it.
 *
 *	Parameters:
 *		hFile:	File handle to store header in.
 *
 *	Return:
 *		HRESULT:		WBEM_S_NO_ERROR			If successful
 *						WBEM_E_OUT_OF_MEMORY	If out of memory
 *						WBEM_E_FAILED			If anything else failed
 *
 ******************************************************************************
 */
HRESULT CRepositoryPackager::PackageHeader(HANDLE hFile)
{
	HRESULT hres = WBEM_S_NO_ERROR;
	PACKAGE_HEADER header;
	strcpy(header.szSignature, "FS PKG1.1");	//NOTE!  MAXIMUM OF 10 CHARACTERS (INCLUDING TERMINATOR!)

	DWORD dwSize = 0;
	if ((WriteFile(hFile, &header, sizeof(header), &dwSize, NULL) == 0) || (dwSize != sizeof(header)))
		hres = WBEM_E_FAILED;
	
	return hres;
}

/******************************************************************************
 *
 *	CRepositoryPackager::PackageDirectory
 *
 *	Description:
 *		This is the code which processes a directory.  It stores the namespace
 *		header and footer marker in the file, and also iterates through
 *		all files and directories in that directory.
 *
 *	Parameters:
 *		hFile:				File handle to store directory information in.
 *		wszParentDirectory:	Full path of parent directory
 *		eszSubDirectory:	Name of sub-directory to process
 *
 *	Return:
 *		HRESULT:		WBEM_S_NO_ERROR			If successful
 *						WBEM_E_OUT_OF_MEMORY	If out of memory
 *						WBEM_E_FAILED			If anything else failed
 *
 ******************************************************************************
 */
HRESULT CRepositoryPackager::PackageDirectory(HANDLE hFile, const wchar_t *wszParentDirectory, wchar_t *wszSubDirectory)
{
	HRESULT hres = WBEM_S_NO_ERROR;

	{
		PACKAGE_SPACER_NAMESPACE header;
		header.dwSpacerType = PACKAGE_TYPE_NAMESPACE_START;
		wcscpy(header.wszNamespaceName, wszSubDirectory);
		DWORD dwSize = 0;
		if ((WriteFile(hFile, &header, sizeof(header), &dwSize, NULL) == 0) || (dwSize != sizeof(header)))
			hres = WBEM_E_FAILED;
	}
	
	//Get full path of new directory...
	wchar_t *wszFullDirectoryName = NULL;
	if (SUCCEEDED(hres))
	{
		wszFullDirectoryName = new wchar_t[MAX_PATH+1];
		if (wszFullDirectoryName == NULL)
			hres = WBEM_E_OUT_OF_MEMORY;
		else
		{
			wcscpy(wszFullDirectoryName, wszParentDirectory);
			wcscat(wszFullDirectoryName, L"\\");
			wcscat(wszFullDirectoryName, wszSubDirectory);
		}
	}

	//Package the contents of that directory...
	if (SUCCEEDED(hres))
	{
		hres = PackageContentsOfDirectory(hFile, wszFullDirectoryName);
	}

	//Now need to write the end of package marker...
	if (SUCCEEDED(hres))
	{
		PACKAGE_SPACER header2;
		header2.dwSpacerType = PACKAGE_TYPE_NAMESPACE_END;
		DWORD dwSize = 0;
		if ((WriteFile(hFile, &header2, sizeof(header2), &dwSize, NULL) == 0) || (dwSize != sizeof(header2)))
			hres = WBEM_E_FAILED;
	}

	delete [] wszFullDirectoryName;

	return hres;
}

/******************************************************************************
 *
 *	CRepositoryPackager::PackageFile
 *
 *	Description:
 *		This is the code which processes a file.  It stores the file header
 *		and the contents of the file into the destination file whose handle
 *		is passed in.  The file directory and name is passed in.
 *
 *	Parameters:
 *		hFile:				File handle to store directory information in.
 *		wszParentDirectory:	Full path of parent directory
 *		wszFilename:		Name of file to process
 *
 *	Return:
 *		HRESULT:		WBEM_S_NO_ERROR			If successful
 *						WBEM_E_OUT_OF_MEMORY	If out of memory
 *						WBEM_E_FAILED			If anything else failed
 *
 ******************************************************************************
 */
HRESULT CRepositoryPackager::PackageFile(HANDLE hFile, const wchar_t *wszParentDirectory, wchar_t *wszFilename)
{
	HRESULT hres = WBEM_S_NO_ERROR;
    bool bSkipFile = false; //Sometimes we need to need to skip files!

	PACKAGE_SPACER_FILE header;
	header.dwSpacerType = PACKAGE_TYPE_FILE;
	wcscpy(header.wszFileName, wszFilename);

	WIN32_FILE_ATTRIBUTE_DATA fileAttribs;
	wchar_t *wszFullFileName = new wchar_t[MAX_PATH+1];
	if (wszFullFileName == NULL)
		hres = WBEM_E_OUT_OF_MEMORY;

	if (SUCCEEDED(hres))
	{
		wcscpy(wszFullFileName, wszParentDirectory);
		wcscat(wszFullFileName, L"\\");
		wcscat(wszFullFileName, wszFilename);

		if (GetFileAttributesExW(wszFullFileName, GetFileExInfoStandard, &fileAttribs) == 0)
			hres = WBEM_E_FAILED;
		else
		{
			header.dwFileSize = fileAttribs.nFileSizeLow;
		}
	}

    //Make sure we are not packaging the file that is the destination file!
    if (SUCCEEDED(hres))
    {
        if (_wcsicmp(wszFullFileName, m_wszFileToProcess) == 0)
        {
            bSkipFile = true;
        }
    }

	//Write header...
	if (SUCCEEDED(hres) && !bSkipFile)
	{
		DWORD dwSize = 0;
		if ((WriteFile(hFile, &header, sizeof(header), &dwSize, NULL) == 0) || (dwSize != sizeof(header)))
			hres = WBEM_E_FAILED;
	}
	
	//Now need to write actual contents of file to current one... but only if the file is not 0 bytes long...
	if (SUCCEEDED(hres) && (header.dwFileSize != 0) && !bSkipFile)
	{
		HANDLE hFromFile = CreateFileW(wszFullFileName, GENERIC_READ, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
		if (hFromFile == INVALID_HANDLE_VALUE)
			hres = WBEM_E_FAILED;

		BYTE *pFileBlob = NULL;
		if (SUCCEEDED(hres))
		{
			pFileBlob = new BYTE[header.dwFileSize];
			if (pFileBlob == NULL)
				hres = WBEM_E_OUT_OF_MEMORY;
		}

		if (SUCCEEDED(hres))
		{
			DWORD dwSize = 0;
			if ((ReadFile(hFromFile, pFileBlob, header.dwFileSize, &dwSize, NULL) == 0) || (dwSize != header.dwFileSize))
				hres = WBEM_E_FAILED;
		}

		if (SUCCEEDED(hres))
		{
			DWORD dwSize = 0;
			if ((WriteFile(hFile, pFileBlob, header.dwFileSize, &dwSize, NULL) == 0) || (dwSize != header.dwFileSize))
				hres = WBEM_E_FAILED;
		}

		delete pFileBlob;

		if (hFromFile != INVALID_HANDLE_VALUE)
			CloseHandle(hFromFile);
	}

	delete [] wszFullFileName;
	return hres;
}

/******************************************************************************
 *
 *	CRepositoryPackager::PackageTrailer
 *
 *	Description:
 *		Writes the end of file marker to the file.
 *
 *	Parameters:
 *		hFile:				File handle to store directory information in.
 *
 *	Return:
 *		HRESULT:		WBEM_S_NO_ERROR			If successful
 *						WBEM_E_OUT_OF_MEMORY	If out of memory
 *						WBEM_E_FAILED			If anything else failed
 *
 ******************************************************************************
 */
HRESULT CRepositoryPackager::PackageTrailer(HANDLE hFile)
{
	HRESULT hres = WBEM_S_NO_ERROR;
	PACKAGE_SPACER trailer;
	trailer.dwSpacerType = PACKAGE_TYPE_END_OF_FILE;

	DWORD dwSize = 0;
	if ((WriteFile(hFile, &trailer, sizeof(trailer), &dwSize, NULL) == 0) || (dwSize != sizeof(trailer)))
		hres = WBEM_E_FAILED;
	
	return hres;
}

/******************************************************************************
 *
 *	CRepositoryPackager::UnPackageHeader
 *
 *	Description:
 *		Unpacks the header package in the given file.  This allows us to recognise
 *		if this really is one of our files. Also it allows us to version it.
 *
 *	Parameters:
 *		hFile:	File handle to unpack header from.
 *
 *	Return:
 *		HRESULT:		WBEM_S_NO_ERROR			If successful
 *						WBEM_E_OUT_OF_MEMORY	If out of memory
 *						WBEM_E_FAILED			If anything else failed
 *
 ******************************************************************************
 */
HRESULT CRepositoryPackager::UnPackageHeader(HANDLE hFile)
{
	HRESULT hres = WBEM_S_NO_ERROR;
	PACKAGE_HEADER header;

    DWORD dwSize = 0;
    if ((ReadFile(hFile, &header, sizeof(header), &dwSize, NULL) == 0) || (dwSize != sizeof(header)))
    {
		hres = WBEM_E_FAILED;
    }
	else if (strncmp(header.szSignature,"FS PKG1.1", 9) != 0)
    {
		hres = WBEM_E_FAILED;
    }

	return hres;
}

/******************************************************************************
 *
 *	CRepositoryPackager::UnPackageContentsOfDirectory
 *
 *	Description:
 *		Unpack the contents of a namespace/directory.
 *		If a subdirectory is encountered, then it calls UnPackageDirectory to handle it.
 *		If a file is encountered, then it calls UnPackageFile to handle it.
 *		If no errors occur, then it will enventually encounter the end of the namespace,
 *		which will terminate the loop and return control to the calling function.
 *
 *	Parameters:
 *		hFile:					Handle to the file to unpack from
 *		wszRepositoryDirectory:	Directory to write to.
 *
 *	Return:
 *		HRESULT:		WBEM_S_NO_ERROR			If successful
 *						WBEM_E_OUT_OF_MEMORY	If out of memory
 *						WBEM_E_FAILED			If anything else failed
 *
 ******************************************************************************
 */
HRESULT CRepositoryPackager::UnPackageContentsOfDirectory(HANDLE hFile, const wchar_t *wszRepositoryDirectory)
{
	HRESULT hres = WBEM_S_NO_ERROR;
	PACKAGE_SPACER header;
	DWORD dwSize;

	while (hres == WBEM_S_NO_ERROR)
	{
		// this loop will be exited when we either
		// - successfully process a complete directory/namespace
		// - encounter an error

		dwSize = 0;
		if ((ReadFile(hFile, &header, sizeof(header), &dwSize, NULL) == 0) || (dwSize != sizeof(header)))
		{
			hres = WBEM_E_FAILED;
		}
		else if (header.dwSpacerType == PACKAGE_TYPE_NAMESPACE_START)
		{
			hres = UnPackageDirectory(hFile, wszRepositoryDirectory);
		}
		else if (header.dwSpacerType == PACKAGE_TYPE_NAMESPACE_END)
		{
			// done with this directory   
			break;
		}
		else if (header.dwSpacerType == PACKAGE_TYPE_FILE)
		{
			hres = UnPackageFile(hFile, wszRepositoryDirectory);
		}
		else if (header.dwSpacerType == PACKAGE_TYPE_END_OF_FILE)
		{
			// done unpacking
			break;
		}
		else
		{
			hres = WBEM_E_FAILED;
		}
	}

	return hres;
}

/******************************************************************************
 *
 *	CRepositoryPackager::UnPackageDirectory
 *
 *	Description:
 *		Unpack the start of a namespace, then call UnPackageContentsOfDirectory
 *		to handle everything within it.
 *
 *	Parameters:
 *		hFile:				File handle to unpack directory information from.
 *		wszParentDirectory:	Full path of parent directory
 *
 *	Return:
 *		HRESULT:		WBEM_S_NO_ERROR			If successful
 *						WBEM_E_OUT_OF_MEMORY	If out of memory
 *						WBEM_E_FAILED			If anything else failed
 *
 ******************************************************************************
 */
HRESULT CRepositoryPackager::UnPackageDirectory(HANDLE hFile, const wchar_t *wszParentDirectory)
{
	HRESULT hres = WBEM_S_NO_ERROR;
	PACKAGE_SPACER_NAMESPACE header;

	// read namespace/directory name
	DWORD dwSize = 0;
	DWORD dwSizeToRead = sizeof(header)-sizeof(PACKAGE_SPACER);
	if ((ReadFile(hFile, ((LPBYTE)&header)+sizeof(PACKAGE_SPACER), dwSizeToRead, &dwSize, NULL) == 0) || (dwSize != dwSizeToRead))
	{
		hres = WBEM_E_FAILED;
	}

	//Get full path of new directory...
	wchar_t *wszFullDirectoryName = NULL;
	if (SUCCEEDED(hres))
	{
		wszFullDirectoryName = new wchar_t[MAX_PATH+1];
		if (wszFullDirectoryName == NULL)
			hres = WBEM_E_OUT_OF_MEMORY;
		else
		{
			wcscpy(wszFullDirectoryName, wszParentDirectory);
			wcscat(wszFullDirectoryName, L"\\");
			wcscat(wszFullDirectoryName, header.wszNamespaceName);
		}
	}

	// create directory
	if (!CreateDirectoryW(wszFullDirectoryName, NULL))
	{
        if (GetLastError() != ERROR_ALREADY_EXISTS)
		    hres = WBEM_E_FAILED;
	}

	// UnPackage the contents into the new directory...
	if (SUCCEEDED(hres))
	{
		hres = UnPackageContentsOfDirectory(hFile, wszFullDirectoryName);
	}

	delete [] wszFullDirectoryName;
	return hres;
}

/******************************************************************************
 *
 *	CRepositoryPackager::UnPackageFile
 *
 *	Description:
 *		Unpack a file.
 *
 *	Parameters:
 *		hFile:				File handle to unpack file information from.
 *		wszParentDirectory:	Full path of parent directory
 *
 *	Return:
 *		HRESULT:		WBEM_S_NO_ERROR			If successful
 *						WBEM_E_OUT_OF_MEMORY	If out of memory
 *						WBEM_E_FAILED			If anything else failed
 *
 ******************************************************************************
 */
HRESULT CRepositoryPackager::UnPackageFile(HANDLE hFile, const wchar_t *wszParentDirectory)
{
	HRESULT hres = WBEM_S_NO_ERROR;
	PACKAGE_SPACER_FILE header;

	// read file name and size
	DWORD dwSize = 0;
	DWORD dwSizeToRead = sizeof(header)-sizeof(PACKAGE_SPACER);
	if ((ReadFile(hFile, ((LPBYTE)&header)+sizeof(PACKAGE_SPACER), dwSizeToRead, &dwSize, NULL) == 0) || (dwSize != dwSizeToRead))
	{
		hres = WBEM_E_FAILED;
	}

	//Get full path of new file...
	wchar_t *wszFullFileName = NULL;
	if (SUCCEEDED(hres))
	{
		wszFullFileName = new wchar_t[MAX_PATH+1];
		if (wszFullFileName == NULL)
			hres = WBEM_E_OUT_OF_MEMORY;
		else
		{
			wcscpy(wszFullFileName, wszParentDirectory);
			wcscat(wszFullFileName, L"\\");
			wcscat(wszFullFileName, header.wszFileName);
		}
	}

	// create the file
	HANDLE hNewFile = INVALID_HANDLE_VALUE;
	if (SUCCEEDED(hres))
	{
		hNewFile = CreateFileW(wszFullFileName, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
		if (hNewFile == INVALID_HANDLE_VALUE)
			hres = WBEM_E_FAILED;
	}

	// read file blob and write to file if size is greater than zero
	if (SUCCEEDED(hres))
	{
		if (header.dwFileSize > 0)
		{
			BYTE* pFileBlob = new BYTE[header.dwFileSize];
			if (pFileBlob == NULL)
				hres = WBEM_E_OUT_OF_MEMORY;

			if (SUCCEEDED(hres))
			{
				dwSize = 0;
				if ((ReadFile(hFile, pFileBlob, header.dwFileSize, &dwSize, NULL) == 0) || (dwSize != header.dwFileSize))
				{
					hres = WBEM_E_FAILED;
				}
			}

			// write file
			if (SUCCEEDED(hres))
			{
				dwSize = 0;
				if ((WriteFile(hNewFile, pFileBlob, header.dwFileSize, &dwSize, NULL) == 0) || (dwSize != header.dwFileSize))
					hres = WBEM_E_FAILED;
			}

			if (pFileBlob)
				delete pFileBlob;
		}
	}

	if (hNewFile != INVALID_HANDLE_VALUE)
		CloseHandle(hNewFile);
	
	if (wszFullFileName)
		delete [] wszFullFileName;

	return hres;
}

/******************************************************************************
 *
 *	CRepositoryPackager::DeleteContentsOfDirectory
 *
 *	Description:
 *		Given a directory, iterates through all files and directories and
 *		calls into the function to delete it.
 *
 *	Parameters:
 *		wszRepositoryDirectory:	Directory to process
 *
 *	Return:
 *		HRESULT:		WBEM_S_NO_ERROR			If successful
 *						WBEM_E_OUT_OF_MEMORY	If out of memory
 *						WBEM_E_FAILED			If anything else failed
 *
 ******************************************************************************
 */
HRESULT CRepositoryPackager::DeleteContentsOfDirectory(const wchar_t *wszRepositoryDirectory)
{
	HRESULT hres = WBEM_S_NO_ERROR;

	wchar_t *wszFullFileName = new wchar_t[MAX_PATH+1];
	if (wszFullFileName == NULL)
		return WBEM_E_OUT_OF_MEMORY;

	WIN32_FIND_DATAW findFileData;
	HANDLE hff = INVALID_HANDLE_VALUE;

	//create file search pattern...
	wchar_t *wszSearchPattern = new wchar_t[MAX_PATH+1];
	if (wszSearchPattern == NULL)
		hres = WBEM_E_OUT_OF_MEMORY;
	else
	{
		wcscpy(wszSearchPattern, wszRepositoryDirectory);
		wcscat(wszSearchPattern, L"\\*");
	}

	//Start the file iteration in this directory...
	if (SUCCEEDED(hres))
	{
		hff = FindFirstFileW(wszSearchPattern, &findFileData);
		if (hff == INVALID_HANDLE_VALUE)
		{
			hres = WBEM_E_FAILED;
		}
	}
	
	if (SUCCEEDED(hres))
	{
		do
		{
			//If we have a filename of '.' or '..' we ignore it...
			if ((wcscmp(findFileData.cFileName, L".") == 0) ||
				(wcscmp(findFileData.cFileName, L"..") == 0))
			{
				//Do nothing with these...
			}
			else if (findFileData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
			{
				//This is a directory, so we need to deal with that...
				hres = PackageDeleteDirectory(wszRepositoryDirectory, findFileData.cFileName);
				if (FAILED(hres))
					break;
			}
			else
			{
				//This is a file, so we need to deal with that...
				wcscpy(wszFullFileName, wszRepositoryDirectory);
				wcscat(wszFullFileName, L"\\");
				wcscat(wszFullFileName, findFileData.cFileName);
				if (!DeleteFileW(wszFullFileName))
				{
					hres = WBEM_E_FAILED;
					break;
				}
			}
			
		} while (FindNextFileW(hff, &findFileData));
	}
	
	if (wszSearchPattern)
		delete [] wszSearchPattern;

	if (hff != INVALID_HANDLE_VALUE)
		FindClose(hff);

	return hres;
}

/******************************************************************************
 *
 *	CRepositoryPackager::PackageDeleteDirectory
 *
 *	Description:
 *		This is the code which processes a directory.  It iterates through
 *		all files and directories in that directory.
 *
 *	Parameters:
 *		wszParentDirectory:	Full path of parent directory
 *		eszSubDirectory:	Name of sub-directory to process
 *
 *	Return:
 *		HRESULT:		WBEM_S_NO_ERROR			If successful
 *						WBEM_E_OUT_OF_MEMORY	If out of memory
 *						WBEM_E_FAILED			If anything else failed
 *
 ******************************************************************************
 */
HRESULT CRepositoryPackager::PackageDeleteDirectory(const wchar_t *wszParentDirectory, wchar_t *wszSubDirectory)
{
	HRESULT hres = WBEM_S_NO_ERROR;

	//Get full path of new directory...
	wchar_t *wszFullDirectoryName = NULL;
	if (SUCCEEDED(hres))
	{
		wszFullDirectoryName = new wchar_t[MAX_PATH+1];
		if (wszFullDirectoryName == NULL)
			hres = WBEM_E_OUT_OF_MEMORY;
		else
		{
			wcscpy(wszFullDirectoryName, wszParentDirectory);
			wcscat(wszFullDirectoryName, L"\\");
			wcscat(wszFullDirectoryName, wszSubDirectory);
		}
	}

	//Package the contents of that directory...
	if (SUCCEEDED(hres))
	{
		hres = DeleteContentsOfDirectory(wszFullDirectoryName);
	}

	// now that the directory is empty, remove it
	if (!RemoveDirectoryW(wszFullDirectoryName))
		hres = WBEM_E_FAILED;

	delete [] wszFullDirectoryName;

	return hres;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\xfiles\varobjheap.h ===
/*++

Copyright (C) 2000-2001 Microsoft Corporation

Module Name:

    VarObjHeap.H

Abstract:

    Implements the storage of variable length objects over the top of of a fixed
	length page system. It keeps a set of admin pages for holding the pages active
	by this subsystem, along with how much space is used on each.  When a page becomes
	empty it frees up the page to the page system.  It also deals with blocks that span
	multiple pages

History:
	paulall		02-Feb-2001		Created  

--*/

#include <unk.h>
#include <arrtempl.h>

class CPageFile;
class CPageSource;

#define VAROBJ_VERSION 1

//**************************************************************************************
//VarObjAdminPageEntry - This is a structure that is stored within the
//m_aAdminPages cache.  It has an entry for each of the admin pages
//that we cache.  It stores the PageId (0 for the first one!), 
//pointer to the actual page, and a flag to determine if we need to
//flush it next time around.
//**************************************************************************************
typedef struct _VarObjAdminPageEntry
{
	DWORD dwPageId;
	BYTE *pbPage;
	bool bDirty;
} VarObjAdminPageEntry;

//**************************************************************************************
//VarObjObjOffsetEntry: There is an array of these objects stored at the 
//start of the object page to point out where each object is stored.
//If this is a continuation block we do not have one of these, however
//continuation blocks have consecutive pageIds so it should be fairly easy 
//to conclude
//**************************************************************************************
typedef struct _VarObjObjOffsetEntry
{
	DWORD dwOffsetId;
	DWORD dwPhysicalStartOffset;
	DWORD dwBlockLength;
	DWORD dwCRC;
} VarObjObjOffsetEntry;

//**************************************************************************************
//VarObjHeapAdminPage - This is the header of each of the admin pages
//that are stored in the object file.  The version is only relevant 
//in the first page (page 0).  The last entry is a buffer to make 
//it 4-DWORD structure rather than 3.  May use it at a later date.
//Should always set it to 0 for now.
//**************************************************************************************
typedef struct _VarObjHeapAdminPage
{
	DWORD dwVersion;
	DWORD dwNextAdminPage;
	DWORD dwNumberEntriesOnPage;

	//VarObjHeapFreeList aFreeListEntries[dwNumberEntriesOnPage];
} VarObjHeapAdminPage;


//**************************************************************************************
//VarObjHeapFreeList - This structure follows the admin page header
//and there is an entry for each page we use to store objects.  The
//page may not be full, so we do not shuffle items on a second page
//to this page when we delete an entry.
//**************************************************************************************
typedef struct _VarObjHeapFreeList
{
	DWORD dwPageId;
	DWORD dwFreeSpace;
	DWORD dwCRC32;
	DWORD dwReserved;
} VarObjHeapFreeList;

//**************************************************************************************
//CVarObjHeap - This is the implementation of the variable sized object store
//over the top of the transacted fixed page manager.  It tracks the admin pages
//that hold all pages we use to store objects in (it caches these pages), and
//also manages cases when an object is too big to fit on a single page.
//**************************************************************************************
class CVarObjHeap
{
private:
	//Current status of admin page
	enum 
	{ 
		NoError = 0, 
		AdminPageReadFailure = 1, 
		RootAdminPageCreationFailure = 2,
		AdminPagesNeedReading = 3
	} m_dwStatus;

	//Pointer to the transacted file for the object storage
	CPageFile *m_pObjectFile;

	//Page size used within the object storage file.
	DWORD m_dwPageSize;


	//Admin page structure
	CLockableFlexArray m_aAdminPages;

protected:
	//Adds an allocation to the end of the existing allocations
	DWORD AllocateFromPage(/* in */ DWORD dwPageId, 
							 /* in */ BYTE *pbPage,
							 /* in */ ULONG ulBlockSize, 
							 /* in */ const BYTE *pBlock, 
							 /* out*/ ULONG *pdwNewOffset);

	//Allocates a multi-page entry in the object file.  This requires
	//different algorithms to work things out so is a special case
	DWORD AllocateMultiPageBuffer(/* in */ ULONG ulBlockSize, 
									/* in */ const BYTE *pBlock, 
									/* out */ ULONG *pulPageId, 
									/* out */ ULONG *pulOffsetId);

	//Given and offsetId and a page, calculate the physical pointer to the object and also 
	//return the size of the block
	DWORD OffsetToPointer(/* in */ ULONG ulOffsetId, 
							/* in */ BYTE *pbPage, 
							/* out*/ BYTE **pOffsetPointer, 
							/* out*/ ULONG *pdwBlockSize,
							/* out*/ DWORD *pdwCRC32);

	//Reads the admin pages into memory and marks them as clean (no changes)
	//setting bReReadPages to false has an affect of clearing the pages out
	DWORD ReadAdminPages(CPageSource *pTransactionManager, bool bReReadPages);

	//Writes each of the changed admin pages back to the object file
	DWORD FlushAdminPages();

	//Find a page form the admin pages that can accomodate a particular buffer size
	DWORD FindPageWithSpace(/* in */ DWORD dwRequiredSize, 
							  /* out*/ DWORD *pdwPageId);

	//Allocate a new page for use with objects.  A buffer for the new page is passed
	//in, however the PageId of this page is passed out
	DWORD AllocateNewPage(/* in */ DWORD ulBlockSize, 
							/* out*/ DWORD *dwPageId, 
							/* in */ BYTE *pbNewObjectPage);

	//Deletes a page, and updates the admin pages as appropriage
	DWORD DeletePage(/* in */ DWORD ulPageId);

	//DeleteFromPage - removes an object from a specific object page
	DWORD RemoveFromPage(/* in */ ULONG ulPageId, 
						   /* in */ ULONG ulOffsetId,
						   /* in */ BYTE *pbPage,
						   /* out*/ DWORD *pdwSize);

	//MultiPageObject - returns true if the provided page is the first page
	//of a multi-page object
	bool MultiPageObject(/* in */ BYTE *pbPage) { return ((VarObjObjOffsetEntry*) pbPage)->dwBlockLength > (m_dwPageSize - (sizeof(VarObjObjOffsetEntry) * 2)); }

	//DeleteMultiPageBuffer - handles the deletion of an object when it spans
	//multiple pages
	DWORD DeleteMultiPageBuffer(/* in */ ULONG ulPageId, 
								  /* in */ ULONG ulOffsetId, 
								  /* in */ BYTE *pbPage);

	//UpdateAdminPageForAllocate - Updates the admin page to decrement the amount
	//of free space on a page by this amount ( + sizeof(VarObjObjOffsetEntry))
	DWORD UpdateAdminPageForAllocate(/* in */ ULONG ulPageId,
									   /* in */ ULONG ulBlockSize,
									   /* in */ DWORD dwCRC32);

	//UpdateAdminPageForDelete - Updates the admin page for giving space back.  If 
	//the page is totally empty we should delete the page altogether
	DWORD UpdateAdminPageForDelete(/* in */ ULONG ulPageId,
									 /* in */ ULONG ulBlockSize,
									 /* in */ DWORD dwCRC32,
									 /* out */ bool *pbPageDeleted);

	//Removes an object page entry from an admin page, removing the
	//admin page if it is no longer needed
	DWORD RemoveEntryFromAdminPage(/* in */ DWORD dwAdminPageIndex, 
								     /* in */ DWORD dwAdminPageEntry);

	//Returns a CRC based on a given block of memory
	#define FINALIZE_CRC32(x)    (x=~x)
	DWORD CreateCRC32(/* in */ const BYTE *pBlock,
					  /* in */ DWORD dwSize,
					  /* in */ DWORD dwPreviousCRC = (DWORD) -1);	 // Must be 0xFFFFFFFF if no previous CRC

#ifdef DBG
	//Given a page we validate that there is in fact enough space
	//for this block.  If there is not it asserts.  This implies
	//that the admin page is not in sync with the actual pages.
	DWORD ValidatePageFreeSpace(/* in */ const BYTE *pbPage, 
								/* in */ DWORD ulBlockSize);

	//Given a page and a page ID, it validates the amount of free space
	//on the page is equal to the amount the admin page thinks is on 
	//there.
	DWORD ValidatePageFreeSpaceWithAdminPage(/* in */ const BYTE *pbPage,
											 /* in */ DWORD ulPageId);

	//Dumps the offset table of a page to the debugger
	DWORD DumpPageOffsetTable(/* in */ DWORD dwPageId, 
							  /* in */ const BYTE *pbPage);
	
	//Checks the CRCs of all objects on a page (cannot do this
	//for a multi-page object though as we only have the first
	//page!)
	DWORD ValidateAllCRC32OnPage(/* in */ const BYTE *pbPage);

	//Validates the page check-sum with the admin page
	DWORD ValidatePageCRCWithAdminPage(/* in */ const BYTE *pbPage,
									   /* in */ DWORD dwPageId);
#endif /* DBG */

public:
	CVarObjHeap();
	~CVarObjHeap();

	DWORD Initialize(CPageSource *pPageManager);
	DWORD Shutdown(DWORD dwShutdownType);

	//Re-read admin pages
	DWORD InvalidateCache();

	//Discard admin pages
	DWORD FlushCaches();

	//ReadBuffer pages the virtual page and offset of the block and returns a new[]-ed block
	DWORD ReadBuffer(/* in */ ULONG ulPageId, 
					   /* in */ ULONG ulOffsetId, 
					   /* out */ BYTE **ppReturnedBlock,
					   /* out */ DWORD *pdwBlockSize);

	//WriteNewBuffer will write a new page based on size of BYTE *, and return the
	//new virtual pageId and offsetId of the block.
	DWORD WriteNewBuffer(/* in */ ULONG ulBlockSize, 
						   /* in */ const BYTE *pBlock, 
						   /* out */ ULONG *pulPageId, 
						   /* out */ ULONG *pulOffsetId);

	//WriteExistingBuffer will update an existing block with new data.  The old virtual page 
	//and offset are passed in, and new ones are returned.  They may or may not be the same
	//depending on if it still fits in the page or not.
	DWORD WriteExistingBuffer(/* in */ ULONG ulBlockSize, 
							    /* in */ const BYTE *pBlock, 
								/* in */ ULONG ulOldPageId, 
								/* in */ ULONG ulOldOffsetId, 
								/* out */ ULONG *pulNewPageId, 
								/* out */ ULONG *pulNewOffsetId);

	//DeleteBuffer is called to delete the item in the store given the virtual pageId and 
	//offsetId.
	DWORD DeleteBuffer(/* in */ ULONG ulPageId, 
					     /* in */ ULONG ulOffsetId);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\xfiles\varobjheap.cpp ===
/*++

Copyright (C) 2000-2001 Microsoft Corporation

Module Name:

    VarObjHeap.CPP

Abstract:

    Implements the storage of variable length objects over the top of of a fixed
	length page system. It keeps a set of admin pages for holding the pages active
	by this subsystem, along with how much space is used on each.  When a page becomes
	empty it frees up the page to the page system.  It also deals with blocks that span
	multiple pages

History:
	paulall		02-Feb-2001		Created  

--*/

#include <windows.h>
#include "VarObjHeap.h"
#include "pagemgr.h"
#ifdef DBG
#include <tchar.h>
#endif
#include <wbemutil.h>

//**************************************************************************************
//CVarObjHeap will do little other than initialize variables.  The Initialize method
//deals with starting everything up.
//**************************************************************************************
CVarObjHeap::CVarObjHeap()
: m_pObjectFile(NULL), m_dwPageSize(0), m_dwStatus(AdminPagesNeedReading)
{
}

//**************************************************************************************
//~CVarObjHeap will break the connection with the transacted object file layer
//**************************************************************************************
CVarObjHeap::~CVarObjHeap()
{
	Shutdown(0);
}

//**************************************************************************************
//Initialize will create the link with the transacted object file layer
//**************************************************************************************
DWORD CVarObjHeap::Initialize(CPageSource *pPageManager)
{
	//Initialize the object file layer...
	DWORD dwRes = pPageManager->GetObjectHeapPageFile(&m_pObjectFile);

	if (dwRes == ERROR_SUCCESS)
		m_dwPageSize = m_pObjectFile->GetPageSize();

	if (dwRes == ERROR_SUCCESS)
	{
		m_dwStatus = AdminPagesNeedReading;
		dwRes = ReadAdminPages(pPageManager, true);
	}

	return dwRes;
}

//**************************************************************************************
//Shutdown will close the transactioned object file layer and tidy up anything else
//that is needed.
//**************************************************************************************
DWORD CVarObjHeap::Shutdown(DWORD dwShutdownType)
{
	DWORD dwRes = ERROR_SUCCESS;

	//Flush the admin pages... remember the error though!
	dwRes = FlushAdminPages();

	if (m_pObjectFile)
	{
		m_pObjectFile->Release();
		m_pObjectFile = NULL;
	}

	//Delete the admin pages structures
	m_aAdminPages.Lock();
	while (m_aAdminPages.Size())
	{	
		VarObjAdminPageEntry * pEntry = (VarObjAdminPageEntry*)m_aAdminPages[0];
		delete [] pEntry->pbPage;
		delete pEntry;
		m_aAdminPages.RemoveAt(0);
	}
	m_aAdminPages.Unlock();

	return dwRes;
}

//**************************************************************************************
//InvalidateCache - called when a transaction is aborted and we need to re-read cached
//data.  Data we cache is mainlyh the admin pages, therefore we should just re-read
//them.
//**************************************************************************************
DWORD CVarObjHeap::InvalidateCache()
{
	m_dwStatus = AdminPagesNeedReading;
	return ReadAdminPages(0, true);
}

DWORD CVarObjHeap::FlushCaches()
{
	m_dwStatus = AdminPagesNeedReading;
	return ReadAdminPages(0, false);
}

//**************************************************************************************
//ReadBuffer retrieves the appropriate page(s) from the virtual page store and copies 
//off the actual block from those page(s).  It may reside on the main page if it is small,
//it may reside on main page and some of the next page, or it may reside on main page, 
//one or more whole pages following that, followed by a partial (or full) page.
//**************************************************************************************
DWORD CVarObjHeap::ReadBuffer(/* in */  ULONG ulPageId, 
								/* in */  ULONG ulOffsetId, 
								/* out */ BYTE **ppReturnedBlock,
								/* out */ DWORD *pdwBlockSize)
{
	if ((ulPageId == 0) || (ulOffsetId == 0))
		DebugBreak();

	DWORD dwRes = ERROR_SUCCESS;
	if (m_dwStatus == NoError)
	{
		//Nothing to do... help with compiler prediction logic
	}
	else if ((m_dwStatus == AdminPageReadFailure) || (m_dwStatus == AdminPagesNeedReading))
	{
		dwRes = ReadAdminPages(0, true);
		if (dwRes != ERROR_SUCCESS)
			return dwRes;
	}
	else if (m_dwStatus == RootAdminPageCreationFailure)
	{
		OutputDebugString(L"WinMgmt: Repository initialization failed and we were still called to retrieve stuff! Yeah, right!\n");
		DebugBreak();
		return ERROR_INTERNAL_ERROR;
	}
	//We need to retrieve the page from the file store, and then we need to retrieve the 
	//block from the the page.  We need to allocate the appropriate memory and copy it
	//into that memory.


	BYTE *pbPage = new BYTE[m_dwPageSize];
	if (pbPage == NULL)
		dwRes = ERROR_OUTOFMEMORY;
	CVectorDeleteMe<BYTE> vdm1(pbPage);

	//So, first we need to retrieve the page...
	if (dwRes == ERROR_SUCCESS)
		dwRes = m_pObjectFile->GetPage(ulPageId, 0, pbPage);

	//Retrieve the REAL offset and size to the block based on offsetId
	BYTE *pOffsetPointer = NULL;
	DWORD dwBlockSize = 0;
	DWORD dwCRC32 = 0;
	if (dwRes == ERROR_SUCCESS)
		dwRes = OffsetToPointer(ulOffsetId, pbPage, &pOffsetPointer, &dwBlockSize, &dwCRC32);

	//We can now allocate the real block now as we know how big it is.  We may not have all 
	//the pages in memory yet though!
	BYTE *pBlock = NULL;
	if (dwRes == ERROR_SUCCESS)
		pBlock = new BYTE[dwBlockSize];

	if ((dwRes == ERROR_SUCCESS) && (pBlock == NULL))
		dwRes = ERROR_OUTOFMEMORY;

	DWORD dwBlockNumber = 0;
	DWORD dwAmountCopiedSoFar = 0;
	
	//Copy off the first block
	if (dwRes == ERROR_SUCCESS)
	{
		DWORD dwSizeOfFirstPageBlock = min(dwBlockSize, DWORD((pbPage + m_dwPageSize) - pOffsetPointer));
		dwAmountCopiedSoFar = dwSizeOfFirstPageBlock;
		memcpy(pBlock, pOffsetPointer, dwSizeOfFirstPageBlock);
	}
	//We should now loop through the pages (retrieving them if necessary) and copying
	//the data into our buffer
	while ((dwRes == ERROR_SUCCESS) && (dwAmountCopiedSoFar < dwBlockSize))
	{
		dwBlockNumber++;
		
		//Read the next page...
		dwRes = m_pObjectFile->GetPage(ulPageId + dwBlockNumber, 0, pbPage);

		if (dwRes == ERROR_SUCCESS)
		{
			//Distinguish if this is a full page or not...
			if ((dwAmountCopiedSoFar + m_dwPageSize) > dwBlockSize)
			{
				//This is a partial block, so copy as much as is needed
				DWORD dwPartialSize = dwBlockSize - dwAmountCopiedSoFar;
				memcpy((pBlock + dwAmountCopiedSoFar), pbPage, dwPartialSize);
				dwAmountCopiedSoFar += dwPartialSize;
			}
			else
			{
				//This is a full block, so grab it all...
				memcpy((pBlock + dwAmountCopiedSoFar), pbPage, m_dwPageSize);
				dwAmountCopiedSoFar += m_dwPageSize;
			}
		}
	}
#ifdef DBG
	if (dwRes == ERROR_SUCCESS)
	{
		//Can only check for single-page blocks!
		if (ulOffsetId != 1)
		{
			dwRes = ValidatePageCRCWithAdminPage(pbPage, ulPageId);
		}
	}
#endif

	//If we are successful, lets do a CRC check on the object
	if (dwRes == ERROR_SUCCESS)
	{
		try 
		{
			DWORD dwNewCRC32 = CreateCRC32(pBlock, dwBlockSize);
			FINALIZE_CRC32(dwNewCRC32);
			if (dwNewCRC32 != dwCRC32)
			{
#ifdef DBG
				OutputDebugString(L"WinMgmt: CRC check on an object retrieved from repository is invalid\n");
				DebugBreak();
#endif
				dwRes = ERROR_INTERNAL_ERROR;
			}

		}
		catch (...)
		{
#ifdef DBG
			OutputDebugString(L"WinMgmt: CRC check on an object retrieved from repository is invalid\n");
			DebugBreak();
#endif
			dwRes = ERROR_INTERNAL_ERROR;
		}
	}
	//If successful we need to return the pointer to the object
	if (dwRes == ERROR_SUCCESS)
	{
		*ppReturnedBlock = pBlock;
		*pdwBlockSize = dwBlockSize;
	}
	else
	{
		delete [] pBlock;
	}

	return dwRes;
}

//**************************************************************************************
//WriteNewBuffer will write a new page based on size of BYTE *, and return the
//new virtual pageId and offsetId of the block. Although we may use multiple pages
//we only need to return the details of the first page.
//**************************************************************************************
DWORD CVarObjHeap::WriteNewBuffer(/* in */ ULONG ulBlockSize, 
									/* in */ const BYTE *pBlock, 
									/* out */ ULONG *pulPageId, 
									/* out */ ULONG *pulOffsetId)
{
	DWORD dwRes = ERROR_SUCCESS;
	if (m_dwStatus == NoError)
	{
		//Nothing to do... help with compiler prediction logic
	}
	else if ((m_dwStatus == AdminPageReadFailure) || (m_dwStatus == AdminPagesNeedReading))
	{
		dwRes = ReadAdminPages(0, true);
		if (dwRes != ERROR_SUCCESS)
			return dwRes;
	}
	else if (m_dwStatus == RootAdminPageCreationFailure)
	{
		OutputDebugString(L"WinMgmt: Repository initialization failed and we were still called to retrieve stuff! Yeah, right!\n");
		DebugBreak();
		return ERROR_INTERNAL_ERROR;
	}

	//If this block will not fit on a single page we call the dedicated method!
	if (ulBlockSize > (m_dwPageSize - (sizeof(VarObjObjOffsetEntry) * 2)))
		return AllocateMultiPageBuffer(ulBlockSize, pBlock, pulPageId, pulOffsetId);

	BYTE *pbPage = new BYTE[m_dwPageSize];
	if (pbPage == NULL)
		dwRes = ERROR_OUTOFMEMORY;
	CVectorDeleteMe<BYTE> vdm(pbPage);

	DWORD dwPageId = 0;

	//Find a page that has enough space for this
	if (dwRes == ERROR_SUCCESS)
		dwRes = FindPageWithSpace(ulBlockSize, &dwPageId);

	if (dwRes == ERROR_SUCCESS)
	{
		//There is a page with space in it!
		//Read the page from the file
		dwRes = m_pObjectFile->GetPage(dwPageId, 0, pbPage);

#ifdef DBG
		if (dwRes == ERROR_SUCCESS)
			dwRes = ValidatePageCRCWithAdminPage(pbPage, dwPageId);
		if (dwRes == ERROR_SUCCESS)
			dwRes = ValidatePageFreeSpaceWithAdminPage(pbPage, dwPageId);		
		if (dwRes == ERROR_SUCCESS)
			dwRes = ValidatePageFreeSpace(pbPage, ulBlockSize);
#endif /* DBG */
	}
	else if (dwRes == ERROR_FILE_NOT_FOUND)
	{
		//We didn't find space so we allocate a new page

		dwRes = AllocateNewPage(ulBlockSize, &dwPageId, pbPage);
	}

	//We now have a page, albeit a new page or an existing one, so now we need
	//to allocate space from it
	if (dwRes == ERROR_SUCCESS)
	{
		dwRes = AllocateFromPage(dwPageId, pbPage, ulBlockSize, pBlock, pulOffsetId);
	}

	//Write the page to the object file
	if (dwRes == ERROR_SUCCESS)
		dwRes = m_pObjectFile->PutPage(dwPageId, 0, pbPage);

	DWORD dwCRC32 = 0;
	if (dwRes == ERROR_SUCCESS)
	{
		dwCRC32 = CreateCRC32(pbPage, m_dwPageSize);
		FINALIZE_CRC32(dwCRC32);
	}

	if (dwRes == ERROR_SUCCESS)
		dwRes = UpdateAdminPageForAllocate(dwPageId, ulBlockSize, dwCRC32);

	if (dwRes == ERROR_SUCCESS)
		dwRes = FlushAdminPages();
	
	//Update the pageId for the client caller
	if (dwRes == ERROR_SUCCESS)
	{
		*pulPageId = dwPageId;
		if ((*pulPageId == 0) || (*pulOffsetId == 0))
			DebugBreak();
	}

#ifdef DBG
	if (dwRes == ERROR_SUCCESS)
		dwRes = ValidatePageFreeSpaceWithAdminPage(pbPage, dwPageId);	
	if (dwRes == ERROR_SUCCESS)
		dwRes = ValidateAllCRC32OnPage(pbPage);
#endif
	return dwRes;
}

//**************************************************************************************
//WriteExistingBuffer will update an existing block with new data.  The old virtual page 
//and offset are passed in, and new ones are returned.  They may or may not be the same
//depending on if it still fits in the page or not.
//**************************************************************************************
DWORD CVarObjHeap::WriteExistingBuffer(/* in */ ULONG ulBlockSize, 
										 /* in */ const BYTE *pBlock, 
										 /* in */ ULONG ulOldPageId, 
										 /* in */ ULONG ulOldOffsetId, 
										 /* out */ ULONG *pulNewPageId, 
										 /* out */ ULONG *pulNewOffsetId)
{
	//Validate the in parameters!
	if ((ulOldPageId == 0) || (ulOldOffsetId == 0))
	{
		DebugBreak();
		return ERROR_INTERNAL_ERROR;
	}

	DWORD dwRes = ERROR_SUCCESS;
	if (m_dwStatus == NoError)
	{
		//Nothing to do... help with compiler prediction logic
	}
	else if ((m_dwStatus == AdminPageReadFailure) || (m_dwStatus == AdminPagesNeedReading))
	{
		dwRes = ReadAdminPages(0, true);
		if (dwRes != ERROR_SUCCESS)
			return dwRes;
	}
	else if (m_dwStatus == RootAdminPageCreationFailure)
	{
		OutputDebugString(L"WinMgmt: Repository initialization failed and we were still called to retrieve stuff! Yeah, right!\n");
		DebugBreak();
		return ERROR_INTERNAL_ERROR;
	}

	//We need to retrieve the page that is being updated, then we need to overwrite the 
	//original stuff in the page.  We may need to shuffle all the existing blocks around
	//within the page to make sure everything is fully packed.  We may need to adjust
	//the free-page list with the amount of space we have available on this page.
	//TODO!  Do this properly!!!
	dwRes = DeleteBuffer(ulOldPageId, ulOldOffsetId);
	if (dwRes == ERROR_SUCCESS)
		dwRes = WriteNewBuffer(ulBlockSize, pBlock, pulNewPageId, pulNewOffsetId);

	//Validate the out parameters!
	if ((*pulNewPageId == 0) || (*pulNewOffsetId == 0))
	{
		DebugBreak();
		dwRes = ERROR_INTERNAL_ERROR;
	}
	return dwRes;
}

//**************************************************************************************
//DeleteBuffer is called to delete the item in the store given the virtual pageId and 
//offsetId.
//**************************************************************************************
DWORD CVarObjHeap::DeleteBuffer(/* in */ ULONG ulPageId, 
								  /* in */ ULONG ulOffsetId)
{
	DWORD dwRes = ERROR_SUCCESS;
	if (m_dwStatus == NoError)
	{
		//Nothing to do... help with compiler prediction logic
	}
	else if ((m_dwStatus == AdminPageReadFailure) || (m_dwStatus == AdminPagesNeedReading))
	{
		dwRes = ReadAdminPages(0, true);
		if (dwRes != ERROR_SUCCESS)
			return dwRes;
	}
	else if (m_dwStatus == RootAdminPageCreationFailure)
	{
		OutputDebugString(L"WinMgmt: Repository initialization failed and we were still called to retrieve stuff! Yeah, right!\n");
		DebugBreak();
		return ERROR_INTERNAL_ERROR;
	}

	//Allocate space for the page we are going to manipulate
	BYTE *pbPage = new BYTE[m_dwPageSize];
	if (pbPage == NULL)
		dwRes = ERROR_OUTOFMEMORY;
	CVectorDeleteMe<BYTE> vdm(pbPage);

	//Retrieve the page that contains this object
	if (dwRes == ERROR_SUCCESS)
		dwRes = m_pObjectFile->GetPage(ulPageId, 0, pbPage);

	//If this object is a multi-page object we have a different algorithm
	if (dwRes == ERROR_SUCCESS)
	{
		if (MultiPageObject(pbPage))
			return DeleteMultiPageBuffer(ulPageId, ulOffsetId, pbPage);
	}

	//Remove the object from this page
	DWORD dwSize = 0;
	if (dwRes == ERROR_SUCCESS)
		dwRes = RemoveFromPage(ulPageId, ulOffsetId, pbPage, &dwSize);

	DWORD dwCRC32 = 0;
	if (dwRes == ERROR_SUCCESS)
	{
		dwCRC32 = CreateCRC32(pbPage, m_dwPageSize);
		FINALIZE_CRC32(dwCRC32);
	}

	//Update the admin page, possibly even deleting the page!
	bool bPageDeleted = false;
	if (dwRes == ERROR_SUCCESS)
		dwRes = UpdateAdminPageForDelete(ulPageId, dwSize, dwCRC32, &bPageDeleted);

	//Flush the page back to the object file and update admin page
	if ((dwRes == ERROR_SUCCESS) && !bPageDeleted)
	{
		dwRes = m_pObjectFile->PutPage(ulPageId, 0, pbPage);
	}

	//Flush the admin pages
	if (dwRes == ERROR_SUCCESS)
		dwRes = FlushAdminPages();

	return dwRes;
}


//**************************************************************************************
//AllocateFromPage - adds an allocation to the end of the existing allocations
//**************************************************************************************
DWORD CVarObjHeap::AllocateFromPage(/* in */ DWORD dwPageId, 
									  /* in */ BYTE *pbPage,
									  /* in */ ULONG ulBlockSize, 
									  /* in */ const BYTE *pBlock, 
									  /* out*/ ULONG *pdwNewOffset)
{
#ifdef XFILES_DEBUG
	if (dwPageId == 0x125)
	{
		OutputDebugString(L"===============================\n");
		OutputDebugString(L"Start of AllocateFromPage\n");
		DumpPageOffsetTable(dwPageId, pbPage);
	}
#endif
	DWORD dwRes = ERROR_SUCCESS;
	
	//Get a pointer to the start of the offset table
	VarObjObjOffsetEntry *pOffsetEntry = (VarObjObjOffsetEntry *) pbPage;

	//This is the location where the last block resided and size so we can calculate
	//where the new block goes
	DWORD dwLastOffset = pOffsetEntry[0].dwPhysicalStartOffset;
	DWORD dwLastSize = 0;
	DWORD dwNewOffsetId = GetTickCount() + (DWORD)rand();
	bool bNewOffsetIdClash = false;

	//Loop through the table until we get to the end... adjusting the offset within the 
	//entries along the way to account for the fact we will be shifting them by the size
	//of an offset entry.
	for (DWORD dwOffsetIndex = 0; pOffsetEntry[dwOffsetIndex].dwOffsetId != 0; dwOffsetIndex++)
	{
		//Shuffle the size of this offset by one entry because we will be doing a memcpy
		//when this is done so we have room for our new entry.
		pOffsetEntry[dwOffsetIndex].dwPhysicalStartOffset += sizeof VarObjObjOffsetEntry;
		dwLastOffset = pOffsetEntry[dwOffsetIndex].dwPhysicalStartOffset;
		dwLastSize = pOffsetEntry[dwOffsetIndex].dwBlockLength;

		if (pOffsetEntry[dwOffsetIndex].dwOffsetId == dwNewOffsetId)
		{
			bNewOffsetIdClash = true;
		}
	}

	//While we have an offset class we need to keep re-calculating
	while (bNewOffsetIdClash)
	{
		bNewOffsetIdClash = false;
		dwNewOffsetId = GetTickCount() + (DWORD)rand();
		for (DWORD dwIndex = 0; pOffsetEntry[dwIndex].dwOffsetId != 0; dwIndex++)
		{
			if (pOffsetEntry[dwIndex].dwOffsetId == dwNewOffsetId)
			{
				bNewOffsetIdClash = true;
				break;
			}
		}
	}

	//Now dwOffsetIndex is where we are going to insert this new offset entry, and dwLastOffset + dwLastSize
	//is the new location where we need to copy this data...

	//Only problem now though is that we need to shuffle all data along by the size of an offset entry!
	MoveMemory(&pOffsetEntry[dwOffsetIndex+1], &pOffsetEntry[dwOffsetIndex], ((dwLastOffset + dwLastSize) - pOffsetEntry[0].dwPhysicalStartOffset) + sizeof(VarObjObjOffsetEntry));

	//Write the new entry in the offset table
	pOffsetEntry[dwOffsetIndex].dwOffsetId = dwNewOffsetId;

	if (dwLastOffset == 0)
	{
		//First block of the page!
		pOffsetEntry[dwOffsetIndex].dwPhysicalStartOffset = (sizeof(VarObjObjOffsetEntry) * 2);
	}
	else
	{
		pOffsetEntry[dwOffsetIndex].dwPhysicalStartOffset = dwLastOffset + dwLastSize;
	}

	pOffsetEntry[dwOffsetIndex].dwBlockLength = ulBlockSize;

#if XFILES_DEBUG
	if (dwPageId == 0x125)
	{
		OutputDebugString(L"===============================\n");
		OutputDebugString(L"Start of AllocateFromPage\n");
		DumpPageOffsetTable(dwPageId, pbPage);
	}
#endif

	//Write the block to the page
#ifdef DBG
	if (pOffsetEntry[dwOffsetIndex].dwPhysicalStartOffset + ulBlockSize > m_dwPageSize)
	{
		OutputDebugString(L"WinMgmt: Object heap is about to write past the end of a page boundary and will cause heap corruption if we continue!\n");
		DebugBreak();
		dwRes = ERROR_INTERNAL_ERROR;
	}
#endif

	if (dwRes == ERROR_SUCCESS)
	{
		//Generate the CRC
		DWORD dwCRC32 = CreateCRC32(pBlock, ulBlockSize);
		FINALIZE_CRC32(dwCRC32);
		pOffsetEntry[dwOffsetIndex].dwCRC = dwCRC32;

		//Copy the blob into the block
		CopyMemory(pbPage + pOffsetEntry[dwOffsetIndex].dwPhysicalStartOffset, pBlock, ulBlockSize);

		//Return the offset ID
		*pdwNewOffset = dwNewOffsetId;
	}

	return dwRes;
}

//**************************************************************************************
//OffsetToPointer - Given and offsetId and a page, calculate the physical pointer to the 
//object and also return the size of the block.
//**************************************************************************************
DWORD CVarObjHeap::OffsetToPointer(/* in */ ULONG ulOffsetId, 
									 /* in */ BYTE  *pbPage, 
									 /* out*/ BYTE  **pOffsetPointer, 
									 /* out*/ ULONG *pdwBlockSize,
									 /* out*/ DWORD *pdwCRC32)
{
	DWORD dwRes = ERROR_FILE_NOT_FOUND;

	//Get a pointer to the start of the offset table
	VarObjObjOffsetEntry *pOffsetEntry = (VarObjObjOffsetEntry *) pbPage;

	//Loop through the table until we find the one we are interested in
	for (DWORD dwOffsetIndex = 0; pOffsetEntry[dwOffsetIndex].dwOffsetId != 0; dwOffsetIndex++)
	{
		if (pOffsetEntry[dwOffsetIndex].dwOffsetId == ulOffsetId)
		{
			dwRes = ERROR_SUCCESS;
			*pdwBlockSize = pOffsetEntry[dwOffsetIndex].dwBlockLength;
			*pOffsetPointer = pbPage + pOffsetEntry[dwOffsetIndex].dwPhysicalStartOffset;
			*pdwCRC32 = pOffsetEntry[dwOffsetIndex].dwCRC;

			break;
		}
	}

	return dwRes;
}


//**************************************************************************************
//ReadAdminPages - Reads the admin pages into memory and marks them as clean (no changes)
//**************************************************************************************
DWORD CVarObjHeap::ReadAdminPages(CPageSource *pTransactionManager, bool bReReadPages)
{
	m_aAdminPages.Lock();

	//Check it wasn't lock contention that meant we had multiple 
	//threads trying to re-read the admin pages.
	if (m_dwStatus == NoError)
	{
		m_aAdminPages.Unlock();
		return ERROR_SUCCESS;
	}

	//Delete anything we may already have in the list in case we need to re-read it in 
	//case of an aborted transaction.
	while (m_aAdminPages.Size())
	{	
		VarObjAdminPageEntry * pEntry = (VarObjAdminPageEntry*)m_aAdminPages[0];
		delete [] pEntry->pbPage;
		delete pEntry;
		m_aAdminPages.RemoveAt(0);
	}


	DWORD dwRes = ERROR_SUCCESS;
	if (bReReadPages)
	{
		m_dwStatus = AdminPagesNeedReading;

		DWORD dwAdminPageId = 0;	//First admin page always resides on page 0
		do
		{
			bool bDirty = false;
			BYTE *pbAdminPage = new BYTE[m_dwPageSize];
			VarObjAdminPageEntry *pEntry = new VarObjAdminPageEntry;
			if ((pbAdminPage == NULL) || (pEntry == NULL))
			{
				dwRes = ERROR_OUTOFMEMORY;
				m_dwStatus = AdminPageReadFailure;
			}

			if (dwRes == ERROR_SUCCESS)
			{
				dwRes = m_pObjectFile->GetPage(dwAdminPageId, 0, pbAdminPage);

				if ((dwRes == ERROR_FILE_NOT_FOUND) && (dwAdminPageId == 0))
				{
					//This is the first attempt, so we need to create the admin page!
					dwRes = m_pObjectFile->NewPage(1, 1, &dwAdminPageId);
					if (dwRes == ERROR_SUCCESS)
					{
						//Write the default data to the admin page
						bDirty = true;	
						VarObjHeapAdminPage* pAdminPage = (VarObjHeapAdminPage*)pbAdminPage;
						pAdminPage->dwNextAdminPage = 0;
						pAdminPage->dwNumberEntriesOnPage = 0;
						pAdminPage->dwVersion = VAROBJ_VERSION;

						dwRes = m_pObjectFile->PutPage(dwAdminPageId, 0, pbAdminPage);
						if (dwRes != ERROR_SUCCESS)
						{
							m_dwStatus = RootAdminPageCreationFailure;
						}
					}
					else
					{
						m_dwStatus = RootAdminPageCreationFailure;
					}
				}
				else if ((dwAdminPageId == 0) && (dwRes != ERROR_SUCCESS))
				{
					m_dwStatus = AdminPageReadFailure;
				}
			}

			if (dwRes == ERROR_SUCCESS)
			{
				pEntry->dwPageId = dwAdminPageId;
				pEntry->pbPage = pbAdminPage;
				pEntry->bDirty = bDirty;
			}

			if ((dwRes == ERROR_SUCCESS) && (m_aAdminPages.Add(pEntry) != CFlexArray::no_error))
			{
				dwRes = ERROR_OUTOFMEMORY;
				m_dwStatus = AdminPageReadFailure;
			}

			if (dwRes == ERROR_SUCCESS)
				dwAdminPageId = ((VarObjHeapAdminPage*)pbAdminPage)->dwNextAdminPage;
			else
			{
				//Tidy up!
				delete [] pbAdminPage;
				delete pEntry;
			}
		}
		while ((dwRes == ERROR_SUCCESS) && (dwAdminPageId != 0));

		//If we had a problem we need to delete everything in the admin list
		if (dwRes != ERROR_SUCCESS)
		{
			while (m_aAdminPages.Size())
			{	
				VarObjAdminPageEntry * pEntry = (VarObjAdminPageEntry*)m_aAdminPages[0];
				delete [] pEntry->pbPage;
				delete pEntry;
				m_aAdminPages.RemoveAt(0);
			}
		}

		if (dwRes == ERROR_SUCCESS)
		{
			m_dwStatus = NoError;
		}

	}
	m_aAdminPages.Unlock();

	return dwRes;
}

//**************************************************************************************
//FlushAdminPages - Writes each of the changed admin pages back to the object file
//**************************************************************************************
DWORD CVarObjHeap::FlushAdminPages()
{
	DWORD dwRes = ERROR_SUCCESS;
	m_aAdminPages.Lock();
	for (DWORD dwIndex = 0; dwIndex != m_aAdminPages.Size(); dwIndex++)
	{	
		VarObjAdminPageEntry * pEntry = (VarObjAdminPageEntry*)m_aAdminPages[dwIndex];
#if DBG
		if ((dwIndex == 0) && (pEntry->dwPageId != 0))
		{
			OutputDebugString(L"WinMgmt: Repository corrupt!  First admin page should always be page 0!\n");
			DebugBreak();
		}
		VarObjHeapAdminPage *pAdminPage = (VarObjHeapAdminPage*) pEntry->pbPage;
		if ((dwIndex != 0) && (pAdminPage->dwVersion != 0))
		{
			OutputDebugString(L"WinMmgt: Repository corrupt!  Trailing admin pages should have version stamp of 0!\n");
			DebugBreak();
		}
#endif
		if (pEntry->bDirty)
			dwRes = m_pObjectFile->PutPage(pEntry->dwPageId, 0, pEntry->pbPage);
		if (dwRes == ERROR_SUCCESS)
			pEntry->bDirty = false;
		else
			break;
	}
	m_aAdminPages.Unlock();
	return dwRes;
}

//**************************************************************************************
//Find a page form the admin pages that can accomodate a particular buffer size
//**************************************************************************************
DWORD CVarObjHeap::FindPageWithSpace(/* in */ DWORD dwRequiredSize, 
									   /* out*/ DWORD *pdwPageId)
{
	DWORD dwRes = ERROR_FILE_NOT_FOUND;
	
	m_aAdminPages.Lock();
	for (DWORD dwPageIndex = 0; (*pdwPageId == 0) &&  (dwPageIndex != m_aAdminPages.Size()); dwPageIndex++)
	{	
		VarObjHeapAdminPage * pAdminPage = (VarObjHeapAdminPage *)(((VarObjAdminPageEntry*)m_aAdminPages[dwPageIndex])->pbPage);
		VarObjHeapFreeList *pFreeListEntry = (VarObjHeapFreeList *)(((BYTE*)pAdminPage) + sizeof (VarObjHeapAdminPage));
#if DBG
		if ((dwPageIndex != 0) && (pAdminPage->dwVersion != 0))
		{
			OutputDebugString(L"WinMgmt: Repository admin page is corrupt as version is invalid!\n");
			DebugBreak();
		}
		if (pAdminPage->dwNumberEntriesOnPage > ((m_dwPageSize - sizeof(VarObjHeapAdminPage)) / sizeof(VarObjHeapFreeList)))
		{
			OutputDebugString(L"WinMgmt: Repository admin page is corrupt because it thinks there are more entries than fit on the page!\n");
			DebugBreak();
		}
#endif

		for (DWORD dwFreeIndex = 0; (*pdwPageId == 0) && (dwFreeIndex != pAdminPage->dwNumberEntriesOnPage); dwFreeIndex++)
		{
			if (pFreeListEntry[dwFreeIndex].dwFreeSpace >= (dwRequiredSize + sizeof(VarObjObjOffsetEntry)))
			{
				*pdwPageId = pFreeListEntry[dwFreeIndex].dwPageId;
				dwRes = ERROR_SUCCESS;
			}
		}
	}
	m_aAdminPages.Unlock();
	return dwRes;
}

//**************************************************************************************
//Allocate a new page for use with objects.  
//**************************************************************************************
DWORD CVarObjHeap::AllocateNewPage(/* in */ DWORD ulBlockSize, 
									 /* out*/ DWORD *pdwPageId, 
									 /* in */ BYTE *pbNewObjectPage)
{
	DWORD dwRes = ERROR_SUCCESS;
	
	//Allocate a new page from the object file
	if (dwRes == ERROR_SUCCESS)
		dwRes = m_pObjectFile->NewPage(0, 1, pdwPageId);

	if (dwRes != ERROR_SUCCESS)
		return dwRes;
	
	//We need to know if we get to the end without finding space because at that point
	//we need to allocate a new admin page!
	dwRes = ERROR_FILE_NOT_FOUND;

	//Find an admin page that has space for this new entry
	m_aAdminPages.Lock();
	for (DWORD dwPageIndex = 0; dwPageIndex != m_aAdminPages.Size(); dwPageIndex++)
	{	
		VarObjHeapAdminPage * pAdminPage = (VarObjHeapAdminPage *)(((VarObjAdminPageEntry*)m_aAdminPages[dwPageIndex])->pbPage);
		VarObjHeapFreeList *pFreeListEntry = (VarObjHeapFreeList *)(((BYTE*)pAdminPage) + sizeof (VarObjHeapAdminPage));

		if ((sizeof(VarObjHeapAdminPage) + ((pAdminPage->dwNumberEntriesOnPage + 1) * sizeof(VarObjHeapFreeList))) <= m_dwPageSize)
		{
			dwRes = ERROR_SUCCESS;
			break;
		}
	}
	m_aAdminPages.Unlock();

	if (dwRes == ERROR_FILE_NOT_FOUND)
	{
		//TODO!  REMOVE DEBUG CODE!
		if (m_aAdminPages.Size() == 0)
		{
			OutputDebugString(L"Winmgmt: Repository admin page list is empty (1)\n");
			DebugBreak();
		}
		//We did not find an admin page with any additional slots available.  We need to allocate
		//a new admin page
		dwRes = ERROR_SUCCESS;

		DWORD dwNewAdminPageId = 0;

		//We need to allocate a new page in the object file
		dwRes = m_pObjectFile->NewPage(0, 1, &dwNewAdminPageId);

		if (m_aAdminPages.Size() == 0)
		{
			OutputDebugString(L"Winmgmt: Repository admin page list is empty (2)\n");
			DebugBreak();
		}
		//we need to allocate all the memory for the admin page cache
		BYTE *pbNewAdminPage = NULL;
		VarObjAdminPageEntry *pAdminPageEntry = NULL;
		if (dwRes == ERROR_SUCCESS)
		{
			pbNewAdminPage = new BYTE[m_dwPageSize];
			pAdminPageEntry = new VarObjAdminPageEntry;

			if ((pbNewAdminPage == NULL) || (pAdminPageEntry == NULL))
				dwRes = ERROR_OUTOFMEMORY;
		}
		if (dwRes == ERROR_SUCCESS)
		{
			if (m_aAdminPages.Add(pAdminPageEntry) != CFlexArray::no_error)
			{
				dwRes = ERROR_OUTOFMEMORY;
			}
		}
		if (m_aAdminPages.Size() == 0)
		{
			OutputDebugString(L"Winmgmt: Repository admin page list is empty (3)\n");
			DebugBreak();
		}
		if (dwRes != ERROR_SUCCESS)
		{
			 delete [] pbNewAdminPage;
			 delete pAdminPageEntry;
		}

		if (dwRes == ERROR_SUCCESS)
		{
			//Write the admin page entry detail
			pAdminPageEntry->dwPageId = dwNewAdminPageId;
			pAdminPageEntry->pbPage = pbNewAdminPage;
			pAdminPageEntry->bDirty = true;		//new page needs to be written!

			//Hook the previous admin page to this one (we have already added the new one remember!
			if (m_aAdminPages.Size() == 0)
			{
				OutputDebugString(L"Winmgmt: Repository admin page list is empty (4)\n");
				DebugBreak();
			}
			VarObjAdminPageEntry *pPreviousAdminPageEntry = (VarObjAdminPageEntry*)m_aAdminPages[m_aAdminPages.Size() - 2];
			VarObjHeapAdminPage *pPreviousAdminPage = (VarObjHeapAdminPage *)(pPreviousAdminPageEntry->pbPage);
			pPreviousAdminPage->dwNextAdminPage = dwNewAdminPageId;
			pPreviousAdminPageEntry->bDirty = true;	//We just changed the page so it needs to be marked for flushing

			//Initialize this new admin page with everything necessary
			VarObjHeapAdminPage *pNewAdminPage = (VarObjHeapAdminPage *)pbNewAdminPage;
			pNewAdminPage->dwNextAdminPage = 0;
			pNewAdminPage->dwNumberEntriesOnPage = 0;
			pNewAdminPage->dwVersion = 0;	//not used on anything but the first page!

			//Now we have all the details in there, we can set the index to this page so we can allocate 
			//add the new object page to it!
			dwPageIndex = m_aAdminPages.Size() - 1;
		}
	}

	//By here we now have the admin page we have space to put this new page entry!
	if (dwRes == ERROR_SUCCESS)
	{
		//cached admin page entry, update the dirty bit as we are changing it
		VarObjAdminPageEntry *pAdminPageEntry = (VarObjAdminPageEntry*)m_aAdminPages[dwPageIndex];
		pAdminPageEntry->bDirty = true;

		//Admin page header, update the number of entries 
		VarObjHeapAdminPage *pAdminPage = (VarObjHeapAdminPage *)pAdminPageEntry->pbPage;
		pAdminPage->dwNumberEntriesOnPage++;

		//Add the entry to the end!
		VarObjHeapFreeList *pFreeList = (VarObjHeapFreeList *)(pAdminPageEntry->pbPage + sizeof(VarObjHeapAdminPage) + (sizeof(VarObjHeapFreeList) * (pAdminPage->dwNumberEntriesOnPage - 1)));
		pFreeList->dwPageId = *pdwPageId;
		pFreeList->dwFreeSpace = m_dwPageSize - sizeof(VarObjObjOffsetEntry);
		pFreeList->dwCRC32 = 0;
		pFreeList->dwReserved = 0;

		//Now we need to need to initialize the new object page to look like an empty page
		ZeroMemory(pbNewObjectPage, sizeof(VarObjObjOffsetEntry));

	}
	return dwRes;
}

//**************************************************************************************
//Allocates a multi-page entry in the object file.  This requires
//different algorithms to work things out so is a special case
//**************************************************************************************
DWORD CVarObjHeap::AllocateMultiPageBuffer(/* in */ ULONG ulBlockSize, 
											 /* in */ const BYTE *pBlock, 
											 /* out */ ULONG *pulPageId, 
											 /* out */ ULONG *pulOffsetId)
{
	DWORD dwRes = ERROR_SUCCESS;
	
	//Whole pages calculation
	DWORD dwNumberPagesNeeded = (ulBlockSize + (sizeof(VarObjObjOffsetEntry) * 2)) / m_dwPageSize;

	//Partial page calculation
	if ((ulBlockSize + (sizeof(VarObjObjOffsetEntry) * 2) % m_dwPageSize) != 0)
		dwNumberPagesNeeded++;

	DWORD dwFirstPageId = 0;
	dwRes = m_pObjectFile->NewPage(0, dwNumberPagesNeeded, &dwFirstPageId);

	for (DWORD dwCurrentOffset = 0, dwPageIndex = 0; dwPageIndex != dwNumberPagesNeeded; dwPageIndex++)
	{
		BYTE *pPage = new BYTE[m_dwPageSize];
		if (pPage == NULL)
			dwRes = ERROR_OUTOFMEMORY;
		CVectorDeleteMe<BYTE> vdm(pPage);

		if (dwRes == ERROR_SUCCESS)
		{
			if (dwCurrentOffset == 0)
			{
				//We have to write the header for the offset page
				ZeroMemory(pPage, sizeof(VarObjObjOffsetEntry) * 2);
				VarObjObjOffsetEntry *pEntry = (VarObjObjOffsetEntry*) pPage;
				pEntry->dwBlockLength = ulBlockSize;
				pEntry->dwOffsetId = 1;
				pEntry->dwPhysicalStartOffset = sizeof(VarObjObjOffsetEntry) * 2;

				DWORD dwCRC32 = CreateCRC32(pBlock, ulBlockSize);
				FINALIZE_CRC32(dwCRC32);
				pEntry->dwCRC = dwCRC32;

				//Fill the rest of this page
				CopyMemory(pPage + (sizeof(VarObjObjOffsetEntry) * 2), pBlock, m_dwPageSize - (sizeof(VarObjObjOffsetEntry) * 2));
				dwCurrentOffset = m_dwPageSize - (sizeof(VarObjObjOffsetEntry) * 2);
			}
			else
			{
				if (ulBlockSize - dwCurrentOffset > m_dwPageSize)
				{
					CopyMemory(pPage, pBlock + dwCurrentOffset, m_dwPageSize);
					dwCurrentOffset += m_dwPageSize;
				}
				else
				{
					CopyMemory(pPage, pBlock + dwCurrentOffset, ulBlockSize - dwCurrentOffset);
					dwCurrentOffset += (ulBlockSize - dwCurrentOffset);

					//NOTE!!!  dwCurrentOffset should equal ulBlockSize now!!!!!
				}
			}

			dwRes = m_pObjectFile->PutPage(dwFirstPageId + dwPageIndex, 0, pPage);
		}
		if (FAILED(dwRes))
			break;
	}

	if (dwRes == ERROR_SUCCESS)
	{
		//Set up the pageId and offset details the client requested
		*pulPageId = dwFirstPageId;
		*pulOffsetId = 1;
	}

	return dwRes;
}

//**************************************************************************************
//DeleteMultiPageBuffer - handles the deletion of an object when it spans
//multiple pages
//******************4********************************************************************
DWORD CVarObjHeap::DeleteMultiPageBuffer(/* in */ ULONG ulPageId, 
										   /* in */ ULONG ulOffsetId, 
										   /* in */ BYTE *pbPage)
{
	DWORD dwRes = ERROR_SUCCESS;

	//Calculate how many pages are used:
	VarObjObjOffsetEntry *pEntry = (VarObjObjOffsetEntry*)pbPage;

	//Whole pages calculation
	DWORD dwNumberPagesNeeded = (pEntry->dwBlockLength + (sizeof(VarObjObjOffsetEntry) * 2)) / m_dwPageSize;

	//Partial page calculation
	if ((pEntry->dwBlockLength + (sizeof(VarObjObjOffsetEntry) * 2) % m_dwPageSize) != 0)
		dwNumberPagesNeeded++;

	for (DWORD dwPageIndex = 0; dwPageIndex != dwNumberPagesNeeded; dwPageIndex ++)
	{
		dwRes = m_pObjectFile->FreePage(0, ulPageId + dwPageIndex);

		if (FAILED(dwRes))
			break;
	}
	
	return dwRes;
}

//**************************************************************************************
//DeleteFromPage - removes an object from a specific object page
//**************************************************************************************
DWORD CVarObjHeap::RemoveFromPage(/* in */ ULONG ulPageId, 
									/* in */ ULONG ulOffsetId,
									/* in */ BYTE *pbPage,
									/* out*/ DWORD *pdwSize)
{
	DWORD dwRes = ERROR_FILE_NOT_FOUND;

	//Need to remove the entry from the offset table, subtracting the deleted object size
	//from the offset of all items following it
	VarObjObjOffsetEntry *pEntry = (VarObjObjOffsetEntry*)pbPage;
	DWORD dwFoundOffset = 0;
	DWORD dwFoundSize = 0;
	DWORD dwFoundIndex = 0;
	for (DWORD dwIndex = 0; pEntry[dwIndex].dwOffsetId != 0; dwIndex ++)
	{

		if (pEntry[dwIndex].dwOffsetId == ulOffsetId)
		{
			//This is ours, so record the details
			dwFoundOffset = pEntry[dwIndex].dwPhysicalStartOffset;
			dwFoundSize = pEntry[dwIndex].dwBlockLength;
			*pdwSize = dwFoundSize;
			dwRes = ERROR_SUCCESS;
			dwFoundIndex = dwIndex;
		}
		else if (dwRes == ERROR_SUCCESS)
		{
			//We have already found it so we need to adjust this entry
			//to account for the removed space
			pEntry[dwIndex - 1].dwPhysicalStartOffset = pEntry[dwIndex].dwPhysicalStartOffset - dwFoundSize - sizeof(VarObjObjOffsetEntry);
			pEntry[dwIndex - 1].dwBlockLength = pEntry[dwIndex].dwBlockLength;
			pEntry[dwIndex - 1].dwOffsetId = pEntry[dwIndex].dwOffsetId;
			pEntry[dwIndex - 1].dwCRC = pEntry[dwIndex].dwCRC;
		}
		else
		{
			//Adjust for the fact that we are removing an entry for the offset table
			pEntry[dwIndex].dwPhysicalStartOffset -= sizeof(VarObjObjOffsetEntry);
		}
	}

	if (dwRes == ERROR_SUCCESS)
	{
		//We need to adjust the end-of-list by one place also
		pEntry[dwIndex - 1].dwPhysicalStartOffset = 0;
		pEntry[dwIndex - 1].dwBlockLength = 0;
		pEntry[dwIndex - 1].dwOffsetId = 0;
		pEntry[dwIndex - 1].dwCRC = 0;

		//Now we need to adjust all entries up to the deleted one by the size of 
		//the offset table entry... although if this was the first item in the list then there
		//is nothing to do
		if (dwFoundIndex != 0)
		{
			MoveMemory(pbPage + pEntry[0].dwPhysicalStartOffset,
				pbPage + pEntry[0].dwPhysicalStartOffset + sizeof(VarObjObjOffsetEntry), 
				dwFoundOffset - (pEntry[0].dwPhysicalStartOffset + sizeof(VarObjObjOffsetEntry)));
		}

		//Now we need to shuffle all entries that appeared after this entry back one... if this
		//was the last entry then we don't have anything to do.
		if (pEntry[dwFoundIndex].dwOffsetId != 0)
		{
			MoveMemory(pbPage + pEntry[dwFoundIndex].dwPhysicalStartOffset,
				pbPage + dwFoundOffset + dwFoundSize,
				(pEntry[dwIndex - 2].dwPhysicalStartOffset + pEntry[dwIndex - 2].dwBlockLength) - (pEntry[dwFoundIndex].dwPhysicalStartOffset));
		}

	}
	

	return dwRes;
}


//**************************************************************************************
//UpdateAdminPageForAllocate - Updates the admin page to decrement the amount
//of free space on a page by this amount ( + sizeof(VarObjObjOffsetEntry))
//**************************************************************************************
DWORD CVarObjHeap::UpdateAdminPageForAllocate(/* in */ ULONG ulPageId,
												/* in */ ULONG ulBlockSize,
												/* in */ DWORD dwNewCRC)
{
	DWORD dwRes = ERROR_FILE_NOT_FOUND;

	//Find an admin page that has this page
	for (DWORD dwPageIndex = 0; dwPageIndex != m_aAdminPages.Size(); dwPageIndex++)
	{	
		VarObjAdminPageEntry* pAdminPageEntry = (VarObjAdminPageEntry*)m_aAdminPages[dwPageIndex];
		VarObjHeapAdminPage * pAdminPage = (VarObjHeapAdminPage *)(pAdminPageEntry->pbPage);
		VarObjHeapFreeList *pFreeListEntry = (VarObjHeapFreeList *)(((BYTE*)pAdminPage) + sizeof (VarObjHeapAdminPage));

		for (DWORD dwEntry = 0; dwEntry != pAdminPage->dwNumberEntriesOnPage; dwEntry ++)
		{
			if (ulPageId == pFreeListEntry[dwEntry].dwPageId)
			{
				pFreeListEntry[dwEntry].dwFreeSpace -= (ulBlockSize + sizeof(VarObjObjOffsetEntry));
				pFreeListEntry[dwEntry].dwCRC32 = dwNewCRC;
				pAdminPageEntry->bDirty = true;
#if XFILES_DEBUG
				wchar_t buf[100];
				swprintf(buf, L"Page 0x%08X has allocated 0x%08X bytes.  Space left 0x%08X\n", ulPageId, ulBlockSize + sizeof(VarObjObjOffsetEntry), pFreeListEntry[dwEntry].dwFreeSpace);
				OutputDebugString(buf);
#endif
				dwRes = ERROR_SUCCESS;
				break;
			}
		}

		if (dwRes == ERROR_SUCCESS)
			break;
	}

	return dwRes;
}

//**************************************************************************************
//UpdateAdminPageForDelete - Updates the admin page for giving space back.  If the page 
//is totally empty we should delete the page altogether.  Note that the space taken
//up is sizeof(VarObjObjOffsetEntry) more than specified because of the offset entry!
//**************************************************************************************
DWORD CVarObjHeap::UpdateAdminPageForDelete(/* in */ ULONG ulPageId,
											  /* in */ ULONG ulBlockSize,
											  /* in */ DWORD dwNewCRC,
											  /* out */ bool *pbPageDeleted)
{
	DWORD dwRes = ERROR_FILE_NOT_FOUND;
	bool bFinished = false;

	//Find an admin page that has this page
	for (DWORD dwPageIndex = 0; dwPageIndex != m_aAdminPages.Size(); dwPageIndex++)
	{	
		VarObjAdminPageEntry* pAdminPageEntry = (VarObjAdminPageEntry*)m_aAdminPages[dwPageIndex];
		VarObjHeapAdminPage * pAdminPage = (VarObjHeapAdminPage *)(pAdminPageEntry->pbPage);
		VarObjHeapFreeList *pFreeListEntry = (VarObjHeapFreeList *)(((BYTE*)pAdminPage) + sizeof (VarObjHeapAdminPage));

		for (DWORD dwEntry = 0; dwEntry != pAdminPage->dwNumberEntriesOnPage; dwEntry ++)
		{
			if (ulPageId == pFreeListEntry[dwEntry].dwPageId)
			{
				pFreeListEntry[dwEntry].dwFreeSpace += (ulBlockSize + sizeof(VarObjObjOffsetEntry));
				pFreeListEntry[dwEntry].dwCRC32 = dwNewCRC;
				dwRes = ERROR_SUCCESS;
				bFinished = true;
				pAdminPageEntry->bDirty = true;
#if XFILES_DEBUG
				wchar_t buf[100];
				swprintf(buf, L"Page 0x%08X has deallocated 0x%08X bytes.  Space left 0x%08X\n", ulPageId, ulBlockSize + sizeof(VarObjObjOffsetEntry), pFreeListEntry[dwEntry].dwFreeSpace);
				OutputDebugString(buf);
#endif

				if (pFreeListEntry[dwEntry].dwFreeSpace == (m_dwPageSize - sizeof(VarObjObjOffsetEntry)))
				{
					dwRes = RemoveEntryFromAdminPage(dwPageIndex, dwEntry);

					if (dwRes == ERROR_SUCCESS)
					{
						dwRes = m_pObjectFile->FreePage(0, ulPageId);
						*pbPageDeleted = true;
					}
				}
				break;
			}
		}
		if (bFinished)
			break;
	}

	return dwRes;
}

//**************************************************************************************
//Deletes a page, and updates the admin pages as appropriage.  If the admin page
//is now enpty we delete this admin page and update the next pointer of the previous 
//page.  We do not delete the first admin page however as it has a special pageId
//that is reserved.
//**************************************************************************************
DWORD CVarObjHeap::DeletePage(/* in */ DWORD ulPageId)
{
	DWORD dwRes = m_pObjectFile->FreePage(0, ulPageId);
	bool bFinished = false;

	if (dwRes == ERROR_SUCCESS)
	{
		dwRes = ERROR_FILE_NOT_FOUND;
		for (DWORD dwPageIndex = 0; dwPageIndex != m_aAdminPages.Size(); dwPageIndex++)
		{	
			VarObjHeapAdminPage * pAdminPage = (VarObjHeapAdminPage *)(((VarObjAdminPageEntry*)m_aAdminPages[dwPageIndex])->pbPage);
			VarObjHeapFreeList *pFreeListEntry = (VarObjHeapFreeList *)(((BYTE*)pAdminPage) + sizeof (VarObjHeapAdminPage));

			for (DWORD dwEntry = 0; dwEntry != pAdminPage->dwNumberEntriesOnPage; dwEntry ++)
			{
				if (ulPageId == pFreeListEntry[dwEntry].dwPageId)
				{
					dwRes = RemoveEntryFromAdminPage(dwPageIndex, dwEntry);
					bFinished = true;
					break;
				}
			}
			if (bFinished)
				break;
		}
	}

	return dwRes;
}

//**************************************************************************************
//Removes an object page entry from an admin page, removing the
//admin page if it is no longer needed
//**************************************************************************************
DWORD CVarObjHeap::RemoveEntryFromAdminPage(/* in */ DWORD dwAdminPageIndex, 
											  /* in */ DWORD dwAdminPageEntry)
{
	DWORD dwRes = ERROR_SUCCESS;

	VarObjAdminPageEntry *pAdminPageEntry = (VarObjAdminPageEntry*)m_aAdminPages[dwAdminPageIndex];
	VarObjHeapAdminPage * pAdminPage = (VarObjHeapAdminPage *)pAdminPageEntry->pbPage;
	VarObjHeapFreeList *pFreeListEntry = (VarObjHeapFreeList *)(((BYTE*)pAdminPage) + sizeof (VarObjHeapAdminPage));

	pAdminPage->dwNumberEntriesOnPage--;
	if ((pAdminPage->dwNumberEntriesOnPage == 0) && (dwAdminPageIndex != 0))
	{
		//Need to delete this admin page... update the previous pages next admin page entry
		VarObjAdminPageEntry *pPreviousAdminPageEntry = (VarObjAdminPageEntry*)m_aAdminPages[dwAdminPageIndex - 1];
		VarObjHeapAdminPage * pPreviousAdminPage = (VarObjHeapAdminPage *)pPreviousAdminPageEntry->pbPage;
		pPreviousAdminPage->dwNextAdminPage = pAdminPage->dwNextAdminPage;
		//Set the dirty bit on that page so it gets flushed!
		pPreviousAdminPageEntry->bDirty = true;
		
		//Do the actual free page of this admin page
		dwRes = m_pObjectFile->FreePage(0, pAdminPageEntry->dwPageId);

		if (dwRes == ERROR_SUCCESS)
		{
			m_aAdminPages.RemoveAt(dwAdminPageIndex);
			delete pAdminPageEntry;
		}

	}
	else if ((pAdminPage->dwNumberEntriesOnPage == 0) && (dwAdminPageIndex == 0))
	{
		//The first admin page cannot be deleted so we just ignore this
	}
	else if (pAdminPage->dwNumberEntriesOnPage != 0)
	{
		//We just need to delete the entry, so shuffle the entries about
		//in the page
		MoveMemory(&pFreeListEntry[dwAdminPageEntry], &pFreeListEntry[dwAdminPageEntry+1], sizeof(VarObjHeapFreeList) * (pAdminPage->dwNumberEntriesOnPage - dwAdminPageEntry));
	}

	return dwRes;
}

#ifdef DBG
//Given a page we validate that there is in fact enough space
//for this block.  If there is not it asserts.  This implies
//that the admin page is not in sync with the actual pages.
DWORD CVarObjHeap::ValidatePageFreeSpace(/* in */ const BYTE *pbPage, 
							/* in */ DWORD ulBlockSize)
{
	DWORD dwRes = ERROR_SUCCESS;
	VarObjObjOffsetEntry *pEntry = (VarObjObjOffsetEntry*) pbPage;
	DWORD dwNextAvailableOffset = pEntry[0].dwPhysicalStartOffset + pEntry[0].dwBlockLength;

	//Search through the offset table until we find the last entry
	for (DWORD dwIndex = 0; pEntry[dwIndex].dwOffsetId != 0; dwIndex++)
	{
		dwNextAvailableOffset = pEntry[dwIndex].dwPhysicalStartOffset + pEntry[dwIndex].dwBlockLength;
	}

	if ((dwNextAvailableOffset + ulBlockSize + sizeof(VarObjObjOffsetEntry))> m_dwPageSize)
	{
		dwRes = ERROR_INTERNAL_ERROR;
		OutputDebugString(L"WinMgmt Repository Corruption: Object heap admin page free space information is out of sync with actual pages!\n");
		DebugBreak();
	}
	
	return dwRes;
}

//Given a page and a page ID, it validates the amount of free space
//on the page is equal to the amount the admin page thinks is on 
//there.
DWORD CVarObjHeap::ValidatePageFreeSpaceWithAdminPage(/* in */ const BYTE *pbPage,
													  /* in */ DWORD ulPageId)
{
	DWORD dwRes = ERROR_SUCCESS;
	VarObjObjOffsetEntry *pEntry = (VarObjObjOffsetEntry*) pbPage;
	DWORD dwNextAvailableOffset = pEntry[0].dwPhysicalStartOffset + pEntry[0].dwBlockLength;

	//Search through the offset table until we find the last entry
	for (DWORD dwIndex = 0; pEntry[dwIndex].dwOffsetId != 0; dwIndex++)
	{
		dwNextAvailableOffset = pEntry[dwIndex].dwPhysicalStartOffset + pEntry[dwIndex].dwBlockLength;
	}

	DWORD dwFreeSpace = m_dwPageSize - dwNextAvailableOffset;

	//Find the page in the admin page table	
	for (DWORD dwPageIndex = 0; dwPageIndex != m_aAdminPages.Size(); dwPageIndex++)
	{	
		VarObjHeapAdminPage * pAdminPage = (VarObjHeapAdminPage *)(((VarObjAdminPageEntry*)m_aAdminPages[dwPageIndex])->pbPage);
		VarObjHeapFreeList *pFreeListEntry = (VarObjHeapFreeList *)(((BYTE*)pAdminPage) + sizeof (VarObjHeapAdminPage));

		for (DWORD dwEntry = 0; dwEntry != pAdminPage->dwNumberEntriesOnPage; dwEntry ++)
		{
			//If this is the page we are interested in...
			if (ulPageId == pFreeListEntry[dwEntry].dwPageId)
			{
				//check the free space matches...
				if (pFreeListEntry[dwEntry].dwFreeSpace != dwFreeSpace)
				{
					//Oops, it doesn't!  We have a problem!
					OutputDebugString(L"WinMgmt Repository Corruption: Free space in page is out of sink with the free space listed in admin page!\n");
					DebugBreak();
					return ERROR_INTERNAL_ERROR;
				}
				return ERROR_SUCCESS;
			}
		}
	}
	return dwRes;
}

//Dumps the offset table of a page to the debugger
DWORD CVarObjHeap::DumpPageOffsetTable(/* in */ DWORD dwPageId, 
									   /* in */ const BYTE *pbPage)
{
	wchar_t buf[100];
	OutputDebugString(L"================================\n");
	_stprintf(buf, L"Dumping offset table for pageId <0x%X>\n", dwPageId);
	OutputDebugString(buf);
	OutputDebugString(L"================================\n");
	DWORD dwRes = ERROR_SUCCESS;
	VarObjObjOffsetEntry *pEntry = (VarObjObjOffsetEntry*) pbPage;
	for (DWORD dwIndex = 0; pEntry[dwIndex].dwOffsetId != 0; dwIndex++)
	{
		_stprintf(buf, L"0x%08X, 0x%08X, 0x%08X, 0x%08X\n", dwIndex, pEntry[dwIndex].dwOffsetId, pEntry[dwIndex].dwBlockLength, pEntry[dwIndex].dwPhysicalStartOffset);
		OutputDebugString(buf);
	}
	_stprintf(buf, L"0x%08X, 0x%08X, 0x%08X, 0x%08X\n", dwIndex, pEntry[dwIndex].dwOffsetId, pEntry[dwIndex].dwBlockLength, pEntry[dwIndex].dwPhysicalStartOffset);
	OutputDebugString(buf);
	OutputDebugString(L"================================\n");

	return ERROR_SUCCESS;
}
#endif /* DBG */

static DWORD g_CRCTable[] =
{
	0x00000000, 0x77073096, 0xee0e612c, 0x990951ba, 0x076dc419, 0x706af48f, 0xe963a535, 0x9e6495a3,
	0x0edb8832, 0x79dcb8a4, 0xe0d5e91e, 0x97d2d988, 0x09b64c2b, 0x7eb17cbd, 0xe7b82d07, 0x90bf1d91,
	0x1db71064, 0x6ab020f2, 0xf3b97148, 0x84be41de, 0x1adad47d, 0x6ddde4eb, 0xf4d4b551, 0x83d385c7,
	0x136c9856, 0x646ba8c0, 0xfd62f97a, 0x8a65c9ec, 0x14015c4f, 0x63066cd9, 0xfa0f3d63, 0x8d080df5,
	0x3b6e20c8, 0x4c69105e, 0xd56041e4, 0xa2677172, 0x3c03e4d1, 0x4b04d447, 0xd20d85fd, 0xa50ab56b,
	0x35b5a8fa, 0x42b2986c, 0xdbbbc9d6, 0xacbcf940, 0x32d86ce3, 0x45df5c75, 0xdcd60dcf, 0xabd13d59,
	0x26d930ac, 0x51de003a, 0xc8d75180, 0xbfd06116, 0x21b4f4b5, 0x56b3c423, 0xcfba9599, 0xb8bda50f,
	0x2802b89e, 0x5f058808, 0xc60cd9b2, 0xb10be924, 0x2f6f7c87, 0x58684c11, 0xc1611dab, 0xb6662d3d,
	0x76dc4190, 0x01db7106, 0x98d220bc, 0xefd5102a, 0x71b18589, 0x06b6b51f, 0x9fbfe4a5, 0xe8b8d433,
	0x7807c9a2, 0x0f00f934, 0x9609a88e, 0xe10e9818, 0x7f6a0dbb, 0x086d3d2d, 0x91646c97, 0xe6635c01,
	0x6b6b51f4, 0x1c6c6162, 0x856530d8, 0xf262004e, 0x6c0695ed, 0x1b01a57b, 0x8208f4c1, 0xf50fc457,
	0x65b0d9c6, 0x12b7e950, 0x8bbeb8ea, 0xfcb9887c, 0x62dd1ddf, 0x15da2d49, 0x8cd37cf3, 0xfbd44c65,
	0x4db26158, 0x3ab551ce, 0xa3bc0074, 0xd4bb30e2, 0x4adfa541, 0x3dd895d7, 0xa4d1c46d, 0xd3d6f4fb,
	0x4369e96a, 0x346ed9fc, 0xad678846, 0xda60b8d0, 0x44042d73, 0x33031de5, 0xaa0a4c5f, 0xdd0d7cc9,
	0x5005713c, 0x270241aa, 0xbe0b1010, 0xc90c2086, 0x5768b525, 0x206f85b3, 0xb966d409, 0xce61e49f,
	0x5edef90e, 0x29d9c998, 0xb0d09822, 0xc7d7a8b4, 0x59b33d17, 0x2eb40d81, 0xb7bd5c3b, 0xc0ba6cad,
	0xedb88320, 0x9abfb3b6, 0x03b6e20c, 0x74b1d29a, 0xead54739, 0x9dd277af, 0x04db2615, 0x73dc1683,
	0xe3630b12, 0x94643b84, 0x0d6d6a3e, 0x7a6a5aa8, 0xe40ecf0b, 0x9309ff9d, 0x0a00ae27, 0x7d079eb1,
	0xf00f9344, 0x8708a3d2, 0x1e01f268, 0x6906c2fe, 0xf762575d, 0x806567cb, 0x196c3671, 0x6e6b06e7,
	0xfed41b76, 0x89d32be0, 0x10da7a5a, 0x67dd4acc, 0xf9b9df6f, 0x8ebeeff9, 0x17b7be43, 0x60b08ed5,
	0xd6d6a3e8, 0xa1d1937e, 0x38d8c2c4, 0x4fdff252, 0xd1bb67f1, 0xa6bc5767, 0x3fb506dd, 0x48b2364b,
	0xd80d2bda, 0xaf0a1b4c, 0x36034af6, 0x41047a60, 0xdf60efc3, 0xa867df55, 0x316e8eef, 0x4669be79,
	0xcb61b38c, 0xbc66831a, 0x256fd2a0, 0x5268e236, 0xcc0c7795, 0xbb0b4703, 0x220216b9, 0x5505262f,
	0xc5ba3bbe, 0xb2bd0b28, 0x2bb45a92, 0x5cb36a04, 0xc2d7ffa7, 0xb5d0cf31, 0x2cd99e8b, 0x5bdeae1d,
	0x9b64c2b0, 0xec63f226, 0x756aa39c, 0x026d930a, 0x9c0906a9, 0xeb0e363f, 0x72076785, 0x05005713,
	0x95bf4a82, 0xe2b87a14, 0x7bb12bae, 0x0cb61b38, 0x92d28e9b, 0xe5d5be0d, 0x7cdcefb7, 0x0bdbdf21,
	0x86d3d2d4, 0xf1d4e242, 0x68ddb3f8, 0x1fda836e, 0x81be16cd, 0xf6b9265b, 0x6fb077e1, 0x18b74777,
	0x88085ae6, 0xff0f6a70, 0x66063bca, 0x11010b5c, 0x8f659eff, 0xf862ae69, 0x616bffd3, 0x166ccf45,
	0xa00ae278, 0xd70dd2ee, 0x4e048354, 0x3903b3c2, 0xa7672661, 0xd06016f7, 0x4969474d, 0x3e6e77db,
	0xaed16a4a, 0xd9d65adc, 0x40df0b66, 0x37d83bf0, 0xa9bcae53, 0xdebb9ec5, 0x47b2cf7f, 0x30b5ffe9,
	0xbdbdf21c, 0xcabac28a, 0x53b39330, 0x24b4a3a6, 0xbad03605, 0xcdd70693, 0x54de5729, 0x23d967bf,
	0xb3667a2e, 0xc4614ab8, 0x5d681b02, 0x2a6f2b94, 0xb40bbe37, 0xc30c8ea1, 0x5a05df1b, 0x2d02ef8d
};

//Creates a CRC for a block
DWORD CVarObjHeap::CreateCRC32(/* in */ const BYTE *pBlock,
							   /* in */ DWORD dwSize,
							   /* in */ DWORD dwPreviousCRC)
{
    if(dwSize == 0)
        return dwPreviousCRC;

    DWORD dwNewCRC = 0;

    for (int n = 0; n < dwSize; n++)
    {
        dwNewCRC = g_CRCTable[ BYTE(dwPreviousCRC ^ DWORD(pBlock[n]))] 
            ^ ((dwPreviousCRC >> 8) & 0x00FFFFFF);
        dwPreviousCRC = dwNewCRC;            
    }
    
    return dwNewCRC;
}

#ifdef DBG
//Checks the CRCs of all objects on a page (cannot do this
//for a multi-page object though as we only have the first
//page!)
DWORD CVarObjHeap::ValidateAllCRC32OnPage(/* in */ const BYTE *pbPage)
{
	DWORD dwRes = ERROR_SUCCESS;

	//Get a pointer to the start of the offset table
	VarObjObjOffsetEntry *pOffsetEntry = (VarObjObjOffsetEntry *) pbPage;

	//Loop through the table until we find the one we are interested in
	for (DWORD dwOffsetIndex = 0; pOffsetEntry[dwOffsetIndex].dwOffsetId != 0; dwOffsetIndex++)
	{
		if (pOffsetEntry[dwOffsetIndex].dwBlockLength > (m_dwPageSize - (sizeof(VarObjObjOffsetEntry) * 2)))
		{
			break;
		}
		else
		{
			try 
			{
				DWORD dwNewCRC32 = CreateCRC32(pbPage + pOffsetEntry[dwOffsetIndex].dwPhysicalStartOffset, pOffsetEntry[dwOffsetIndex].dwBlockLength);
				FINALIZE_CRC32(dwNewCRC32);
				if (dwNewCRC32 != pOffsetEntry[dwOffsetIndex].dwCRC)
				{
					OutputDebugString(L"WinMgmt: Page Check: CRC check on an object retrieved from repository is invalid\n");
					DebugBreak();
					dwRes = ERROR_INTERNAL_ERROR;
				}

			}
			catch (...)
			{
				OutputDebugString(L"WinMgmt: Page Check: CRC check on an object retrieved from repository is invalid\n");
				DebugBreak();
				dwRes = ERROR_INTERNAL_ERROR;
			}
		}
	}
	return dwRes;
}

//Validates the page check-sum with the admin page
DWORD CVarObjHeap::ValidatePageCRCWithAdminPage(/* in */ const BYTE *pbPage,
								   /* in */ DWORD dwPageId)
{
	DWORD dwCRC32 = 0;
	dwCRC32 = CreateCRC32(pbPage, m_dwPageSize);
	FINALIZE_CRC32(dwCRC32);

	for (DWORD dwPageIndex = 0; dwPageIndex != m_aAdminPages.Size(); dwPageIndex++)
	{	
		VarObjHeapAdminPage * pAdminPage = (VarObjHeapAdminPage *)(((VarObjAdminPageEntry*)m_aAdminPages[dwPageIndex])->pbPage);
		VarObjHeapFreeList *pFreeListEntry = (VarObjHeapFreeList *)(((BYTE*)pAdminPage) + sizeof (VarObjHeapAdminPage));

		if ((dwPageIndex != 0) && (pAdminPage->dwVersion != 0))
		{
			OutputDebugString(L"WinMgmt: Repository admin page is corrupt as version is invalid!\n");
			DebugBreak();
			return ERROR_INTERNAL_ERROR;
		}
		if (pAdminPage->dwNumberEntriesOnPage > ((m_dwPageSize - sizeof(VarObjHeapAdminPage)) / sizeof(VarObjHeapFreeList)))
		{
			OutputDebugString(L"WinMgmt: Repository admin page is corrupt because it thinks there are more entries than fit on the page!\n");
			DebugBreak();
			return ERROR_INTERNAL_ERROR;
		}

		for (DWORD dwFreeIndex = 0; dwFreeIndex != pAdminPage->dwNumberEntriesOnPage; dwFreeIndex++)
		{
			if (pFreeListEntry[dwFreeIndex].dwPageId == dwPageId)
			{
				if (pFreeListEntry[dwFreeIndex].dwCRC32 == 0)
					return ERROR_SUCCESS;
				else if (pFreeListEntry[dwFreeIndex].dwCRC32 == dwCRC32)
					return ERROR_SUCCESS;
				else
				{
					OutputDebugString(L"WinMgmt: Repository admin page has an invalid CRC for the object page!\n");
					DebugBreak();
					return ERROR_INTERNAL_ERROR;
				}
			}
		}
	}
	OutputDebugString(L"WinMgmt: Requested page was not found in the admin page list!\n");
	DebugBreak();
	return ERROR_INTERNAL_ERROR;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\xfiles\varobjheaptest.cpp ===
#include <windows.h>
#include <unk.h>
#include <arrtempl.h>
#include <FlexArry.h>
#include "pagemgr.h"
#include "VarObjHeap.h"
#include <wbemutil.h>
#include <stdio.h>
#include <tchar.h>

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// Assertion code
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


DWORD _RetAssert(TCHAR *msg, DWORD dwRes, const char *filename, int line)
{
	if (dwRes == ERROR_SUCCESS)
		return dwRes;

    TCHAR *buf = new TCHAR[512];
	if (buf == NULL)
	{
		return dwRes;
	}
    wsprintf(buf, __TEXT("%s\ndwRes = 0x%X\nFile: %S, Line: %lu\n\nPress Cancel to stop in debugger, OK to continue"), msg, dwRes, filename, line);
	_tprintf(buf);
    int mbRet = MessageBox(0, buf, __TEXT("WMI Assert"),  MB_OKCANCEL | MB_ICONSTOP | MB_SYSTEMMODAL | MB_SERVICE_NOTIFICATION);
	delete [] buf;
	if (mbRet == IDCANCEL)
	{
		DebugBreak();
	}
	return dwRes;
}

#define TEST_ASSERT(msg, dwRes) _RetAssert(msg, dwRes, __FILE__, __LINE__)

CVarObjHeap *pHeap = NULL;
CPageSource *pTranMan = NULL;

#define TEST_OBJECT_SIZE 30000
#define TEST_OBJECT_ITER 25000

DWORD TestMem(BYTE *buff, DWORD dwLen, BYTE dwSig)
{
	for (DWORD dwIndex = 0; dwIndex != dwLen; dwIndex++)
	{
		if (buff[dwIndex] != dwSig)
			return ERROR_INVALID_DATA;
	}
	return ERROR_SUCCESS;
}

DWORD Init()
{
	DWORD dwRes = ERROR_SUCCESS;

	pHeap = new CVarObjHeap;
	pTranMan = new CPageSource;

	if ((pHeap == NULL) || (pTranMan == NULL))
	{
		dwRes = ERROR_OUTOFMEMORY;
	}

	if (dwRes == ERROR_SUCCESS)
	{
		dwRes = pTranMan->Init();
		TEST_ASSERT(L"Initialization of Transaction Manager failed!", dwRes);
	}
	if (dwRes == ERROR_SUCCESS)
	{
		dwRes = pHeap->Initialize(pTranMan);
		TEST_ASSERT(L"Initialization of object heap failed!", dwRes);
	}

	return dwRes;
}

DWORD WriteBuffer(BYTE *pbBuffer, DWORD dwLength, DWORD *pdwPage, DWORD *pdwOffset)
{
	DWORD dwRes;

	dwRes = pTranMan->BeginTrans();
	TEST_ASSERT(L"Begin Transaction Failed!", dwRes);

	if (dwRes == ERROR_SUCCESS)
		dwRes = pHeap->WriteNewBuffer(dwLength, pbBuffer, pdwPage, pdwOffset);

	printf("Written %d bytes with signature of <%d> to pageId <0x%X>, offset <0x%X>\n", dwLength, pbBuffer[0], *pdwPage, *pdwOffset);
	TEST_ASSERT(L"Write failed!", dwRes);

	if (dwRes == ERROR_SUCCESS)
	{
		dwRes = pTranMan->CommitTrans();
		TEST_ASSERT(L"Commit Transaction Failed!", dwRes);
	}
	if (dwRes != ERROR_SUCCESS)
	{
		dwRes = pTranMan->RollbackTrans();
		TEST_ASSERT(L"Abort Transaction Failed!", dwRes);
	}

	return dwRes;
}

DWORD DeleteBuffer(DWORD dwPage, DWORD dwOffset)
{
	DWORD dwRes;

	dwRes = pTranMan->BeginTrans();
	TEST_ASSERT(L"Begin Transaction Failed!", dwRes);

	dwRes = pHeap->DeleteBuffer(dwPage, dwOffset);
	TEST_ASSERT(L"DeleteBuffer failed!", dwRes);

	if (dwRes == ERROR_SUCCESS)
	{
		dwRes = pTranMan->CommitTrans();
		TEST_ASSERT(L"Commit Transaction Failed!", dwRes);
	}
	if (dwRes != ERROR_SUCCESS)
	{
		dwRes = pTranMan->RollbackTrans();
		TEST_ASSERT(L"Abort Transaction Failed!", dwRes);
	}

	return dwRes;
}

void __cdecl main(void)
{
	DWORD dwRes = ERROR_SUCCESS;
	BYTE* buff = new BYTE[TEST_OBJECT_SIZE];
	DWORD* aPageId = new DWORD[TEST_OBJECT_ITER];
	DWORD* aOffsetId = new DWORD [TEST_OBJECT_ITER];
	DWORD* aSize = new DWORD [TEST_OBJECT_ITER];
	BYTE *pBuffer;

	if ((buff == 0) || (aPageId == 0) || (aOffsetId == 0) || (aSize == 0))
	{
		dwRes = ERROR_OUTOFMEMORY;
	}
	
	if (dwRes == ERROR_SUCCESS)
		dwRes = Init();

	if (dwRes == ERROR_SUCCESS)
	{

		for (int i = 0; i < TEST_OBJECT_ITER; i++)
		{
			aSize[i] = rand() % TEST_OBJECT_SIZE;
			memset(buff, i, aSize[i]);
			dwRes = WriteBuffer(buff, aSize[i], &aPageId[i], &aOffsetId[i]);
		}

		for (i = 0; i < TEST_OBJECT_ITER; i++)
		{
			pBuffer = NULL;
			DWORD dwLen;

			dwRes = pHeap->ReadBuffer(aPageId[i], aOffsetId[i], &pBuffer, &dwLen);
			TEST_ASSERT(L"ReadBuffer failed!", dwRes);

			dwRes = TestMem(pBuffer, aSize[i], (BYTE)i);
			TEST_ASSERT(L"Buffer read was not what we wrote!", dwRes);

			printf("Read %d bytes with signature of <%d> from pageId <0x%X>, offset <0x%X>\n", aSize[i], i, aPageId[i], aOffsetId[i]);
			delete [] pBuffer;
		}

		for (int i = 0; i < TEST_OBJECT_ITER; i++)
		{
			dwRes = DeleteBuffer(aPageId[i], aOffsetId[i]);
			TEST_ASSERT(L"DeleteBuffer failed!", dwRes);
			printf("Deleted %d bytes with signature of <%d> from pageId <0x%X>, offset <0x%X>\n", aSize[i], i, aPageId[i], aOffsetId[i]);
		}

	}

	if (dwRes == ERROR_SUCCESS)
	{
		dwRes = pHeap->Shutdown(0);
		TEST_ASSERT(L"Heap Shutdown failed!", dwRes);
		dwRes = pTranMan->Shutdown(0);
		TEST_ASSERT(L"Transaction manager Shutdown failed!", dwRes);
	}

	delete [] buff;
	delete [] aPageId;
	delete [] aOffsetId;
	delete [] aSize;
	delete pHeap;
	delete pTranMan;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\xfiles\win9xsecurity.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    Win9xSecurity.cpp

Abstract:

	This class handles the importing of Win9x security data that was extracted from an old MMF format repository.

History:

	03/17/2001	shbrown - created

--*/

#include "precomp.h"
#include <wbemcomn.h>
#include "Win9xSecurity.h"
#include <oahelp.inl>

bool CWin9xSecurity::Win9xBlobFileExists()
{
	wchar_t wszFilePath[MAX_PATH+1];
	if (!GetRepositoryDirectory(wszFilePath))
		return false;

	wcscat(wszFilePath, BLOB9X_FILENAME);
	DWORD dwAttributes = GetFileAttributesW(wszFilePath);
	if (dwAttributes != -1)
	{
		DWORD dwMask =	FILE_ATTRIBUTE_DEVICE |
						FILE_ATTRIBUTE_DIRECTORY |
						FILE_ATTRIBUTE_OFFLINE |
						FILE_ATTRIBUTE_REPARSE_POINT |
						FILE_ATTRIBUTE_SPARSE_FILE;

		if (!(dwAttributes & dwMask))
			return true;
	}
	return false;
}


HRESULT CWin9xSecurity::ImportWin9xSecurity()
{
    HRESULT hRes = WBEM_S_NO_ERROR;

	wchar_t wszFilePath[MAX_PATH+1];
	if (GetRepositoryDirectory(wszFilePath))
	{
		wcscat(wszFilePath, BLOB9X_FILENAME);
	    m_h9xBlobFile = CreateFileW(wszFilePath, GENERIC_READ, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
	}

	// get a session and begin a transaction
    CSession* pSession = new CSession(m_pControl);
	if (pSession == NULL)
		return WBEM_E_OUT_OF_MEMORY;
	pSession->AddRef();
    CReleaseMe relMe(pSession);

    hRes = pSession->BeginWriteTransaction(0);
    if (FAILED(hRes))
    {
        return hRes;
    }

	// process the file
    if (m_h9xBlobFile != INVALID_HANDLE_VALUE)
    {
		try
		{
			hRes = DecodeWin9xBlobFile();
		}
		catch (...)
		{
			ERRORTRACE((LOG_WBEMCORE, "Traversal of Win9x security data import file failed\n"));
			hRes = WBEM_E_FAILED;
		}
        CloseHandle(m_h9xBlobFile);
    }
    else
    {
		ERRORTRACE((LOG_WBEMCORE, "Could not open the Win9x security data import file for reading\n"));
		hRes = WBEM_E_FAILED;
    }

    if (SUCCEEDED(hRes))
	{
		if (DeleteWin9xBlobFile())
			hRes = pSession->CommitTransaction(0);
		else
		{
			ERRORTRACE((LOG_WBEMCORE, "Win9x security data import completed but failed to delete import file\n"));
			pSession->AbortTransaction(0);
			hRes = WBEM_E_FAILED;
		}
	}
	else
	{
		ERRORTRACE((LOG_WBEMCORE, "Win9x security data import failed to complete\n"));
		pSession->AbortTransaction(0);
	}

    return hRes;
}

HRESULT CWin9xSecurity::DecodeWin9xBlobFile()
{
	HRESULT hRes = WBEM_S_NO_ERROR;

	// read the file header
	if (!ReadWin9xHeader())
		return WBEM_E_FAILED;

	// import the file
	BLOB9X_SPACER header;
	DWORD dwSize;
	while (hRes == WBEM_S_NO_ERROR)
	{
		// this loop will be exited when we either...
		// - successfully process the whole import file, or
		// - encounter an error

		dwSize = 0;
		if ((ReadFile(m_h9xBlobFile, &header, sizeof(header), &dwSize, NULL) == 0) || (dwSize != sizeof(header)))
		{
			hRes = WBEM_E_FAILED;
		}
		else if ((header.dwSpacerType == BLOB9X_TYPE_SECURITY_INSTANCE) ||
				 (header.dwSpacerType == BLOB9X_TYPE_SECURITY_BLOB))
		{
			hRes = ProcessWin9xBlob(&header);
		}
		else if (header.dwSpacerType == BLOB9X_TYPE_END_OF_FILE)
		{
			break;
		}
		else
		{
			hRes = WBEM_E_FAILED;
		}
	}

	if (SUCCEEDED(hRes))
		hRes = RecursiveInheritSecurity(NULL, L"root");	// force namespaces to inherit their inheritable security settings

	return hRes;
}

bool CWin9xSecurity::ReadWin9xHeader()
{
	BLOB9X_HEADER header;
    DWORD dwSize = 0;
    if ((ReadFile(m_h9xBlobFile, &header, sizeof(header), &dwSize, NULL) == 0) || (dwSize != sizeof(header)))
    {
		ERRORTRACE((LOG_WBEMCORE, "Failed to retrieve the Win9x import file header information\n"));
		return false;
    }

	if (strncmp(header.szSignature, BLOB9X_SIGNATURE, 9) != 0)
    {
		ERRORTRACE((LOG_WBEMCORE, "The import file is not a Win9x import file\n"));
		return false;
    }

	return true;
}

HRESULT CWin9xSecurity::ProcessWin9xBlob(BLOB9X_SPACER* pHeader)
{
	if (pHeader->dwNamespaceNameSize == 0)
	{
		ERRORTRACE((LOG_WBEMCORE, "Namespace name size is zero in Win9x import blob\n"));
		return WBEM_E_FAILED;
	}

	if (pHeader->dwBlobSize == 0)
	{
		ERRORTRACE((LOG_WBEMCORE, "Blob size is zero in Win9x import blob\n"));
		return WBEM_E_FAILED;
	}

	// read the namespace name
	wchar_t* wszNamespaceName = new wchar_t[pHeader->dwNamespaceNameSize];
	if (!wszNamespaceName)
		return WBEM_E_OUT_OF_MEMORY;
	CVectorDeleteMe<wchar_t> delMe1(wszNamespaceName);
	DWORD dwSize = 0;
	if ((ReadFile(m_h9xBlobFile, wszNamespaceName, pHeader->dwNamespaceNameSize, &dwSize, NULL) == 0) || (dwSize != pHeader->dwNamespaceNameSize))
		return WBEM_E_FAILED;

	// read the parent namespace name if it exists
	wchar_t* wszParentClass = NULL;
	if (pHeader->dwParentClassNameSize)
	{
		wszParentClass = new wchar_t[pHeader->dwParentClassNameSize];
		if (!wszParentClass)
			return WBEM_E_OUT_OF_MEMORY;
		dwSize = 0;
		if ((ReadFile(m_h9xBlobFile, wszParentClass, pHeader->dwParentClassNameSize, &dwSize, NULL) == 0) || (dwSize != pHeader->dwParentClassNameSize))
		{
			delete [] wszParentClass;
			return WBEM_E_FAILED;
		}
	}
	CVectorDeleteMe<wchar_t> delMe2(wszParentClass);

	// read in the blob
    char* pObjectBlob = new char[pHeader->dwBlobSize];
	if (!pObjectBlob)
		return WBEM_E_OUT_OF_MEMORY;
	CVectorDeleteMe<char> delMe3(pObjectBlob);
	dwSize = 0;
	if ((ReadFile(m_h9xBlobFile, pObjectBlob, pHeader->dwBlobSize, &dwSize, NULL) == 0) || (dwSize != pHeader->dwBlobSize))
	{
		ERRORTRACE((LOG_WBEMCORE, "Failed to read Win9x security blob for namespace %S\n", wszNamespaceName));
		return WBEM_E_FAILED;
	}

	// get handle to the namespace so it can be used below
	CNamespaceHandle* pNamespaceHandle = new CNamespaceHandle(m_pControl, m_pRepository);
	if (!pNamespaceHandle)
		return WBEM_E_OUT_OF_MEMORY;
    pNamespaceHandle->AddRef();
    CReleaseMe relme(pNamespaceHandle);

	HRESULT hRes = pNamespaceHandle->Initialize(wszNamespaceName);
	if (SUCCEEDED(hRes))
	{
		// process the blob according to its type
		if (pHeader->dwSpacerType == BLOB9X_TYPE_SECURITY_INSTANCE)
			hRes = ProcessWin9xSecurityInstance(pNamespaceHandle, wszParentClass, pObjectBlob, pHeader->dwBlobSize);
		else // (pHeader->dwSpacerType == BLOB9X_TYPE_SECURITY_BLOB)
			hRes = ProcessWin9xSecurityBlob(pNamespaceHandle, wszNamespaceName, pObjectBlob);
	}
	return hRes;
}

HRESULT CWin9xSecurity::ProcessWin9xSecurityInstance(CNamespaceHandle* pNamespaceHandle, wchar_t* wszParentClass, char* pObjectBlob, DWORD dwBlobSize)
{
	// get parent class from the repository
    _IWmiObject* pParentClass = 0;
    HRESULT hRes = pNamespaceHandle->GetObjectByPath(wszParentClass, 0, IID_IWbemClassObject, (LPVOID*)&pParentClass);
	if (FAILED(hRes))
	{
		ERRORTRACE((LOG_WBEMCORE, "Failed to retrieve class %S from the repository; HRESULT = %#lx\n", wszParentClass, hRes));
		return hRes;
	}
    CReleaseMe relMe1(pParentClass);

	// merge object blob with parent class to produce instance
    _IWmiObject* pInstance = 0;
	hRes = pParentClass->Merge(WMIOBJECT_MERGE_FLAG_INSTANCE, dwBlobSize, pObjectBlob, &pInstance);
	if (FAILED(hRes))
	{
		ERRORTRACE((LOG_WBEMCORE, "Unable to merge instance; HRESULT = %#lx\n", hRes));
		return hRes;
	}
    CReleaseMe relMe2(pInstance);

	// convert security class instance to ACE
    bool bGroup = false;
    if(wbem_wcsicmp(L"__ntlmgroup", wszParentClass) == 0)
        bGroup = true;

    CNtAce* pAce = ConvertOldObjectToAce(pInstance, bGroup);
    if(!pAce)
    {
		ERRORTRACE((LOG_WBEMCORE, "Unable to convert old security instance to ACE"));
		return WBEM_E_FAILED;
	}
	CDeleteMe<CNtAce> delMe(pAce);

	// store the ACE
	hRes = StoreAce(pAce);
	if (FAILED(hRes))
	{
		ERRORTRACE((LOG_WBEMCORE, "Unable to store ACE; HRESULT = %#lx\n", hRes));
		return hRes;
	}

	return hRes;
}

// this function was stolen from coredll\secure.cpp with minor modifications to remove calls to IsNT()
CNtAce* CWin9xSecurity::ConvertOldObjectToAce(_IWmiObject* pObj, bool bGroup)
{
    // Get the properties out of the old object

    CVARIANT vName;
    pObj->Get(L"Name", 0, &vName, 0, 0);
    LPWSTR pName = NULL;
    if(vName.GetType() != VT_BSTR)
        return NULL;                // ignore this one.
    pName = LPWSTR(vName);

    CVARIANT vDomain;
    LPWSTR pDomain = L".";
    pObj->Get(L"Authority", 0, &vDomain, 0, 0);
    if(vDomain.GetType() == VT_BSTR)
        pDomain = LPWSTR(vDomain);

    bool bEditSecurity = false;
    bool bEnabled = false;
    bool bExecMethods = false;

    DWORD dwMask = 0;
    CVARIANT vEnabled;
    CVARIANT vEditSecurity;
    CVARIANT vExecMethods;
    CVARIANT vPermission;

    pObj->Get(L"Enabled", 0, &vEnabled, 0, 0);
    pObj->Get(L"EditSecurity", 0, &vEditSecurity, 0, 0);
    pObj->Get(L"ExecuteMethods", 0, &vExecMethods, 0, 0);
    pObj->Get(L"Permissions", 0, &vPermission, 0, 0);

    if (vEnabled.GetType() != VT_NULL && vEnabled.GetBool())
        bEnabled = true;

    if (vEditSecurity.GetType() != VT_NULL && vEditSecurity.GetBool())
        bEditSecurity = true;

    if (vExecMethods.GetType() != VT_NULL && vExecMethods.GetBool())
        bExecMethods = true;

    DWORD dwPermission = 0;
    if (vPermission.GetType() != VT_NULL && vPermission.GetLONG() > dwPermission)
            dwPermission = vPermission.GetLONG();

    // Now translate the old settings into new ones
    if(bEnabled)
        dwMask = WBEM_ENABLE | WBEM_REMOTE_ACCESS | WBEM_WRITE_PROVIDER;

    if(bEditSecurity)
        dwMask |= READ_CONTROL;

    if(bEditSecurity && dwPermission > 0)
        dwMask |= WRITE_DAC;

    if(bExecMethods)
        dwMask |= WBEM_METHOD_EXECUTE;

    if(dwPermission >= 1)
        dwMask |= WBEM_PARTIAL_WRITE_REP;

    if(dwPermission >= 2)
        dwMask |= WBEM_FULL_WRITE_REP | WBEM_PARTIAL_WRITE_REP | WBEM_WRITE_PROVIDER;


    // By default, CNtSid will look up the group name from either the local machine,
    // the domain, or a trusted domain.  So we need to be explicit

    WString wc;
    if(pDomain)
        if(_wcsicmp(pDomain, L"."))
        {
            wc = pDomain;
            wc += L"\\";
        }
    wc += pName;

    // under m1, groups that were not enabled were just ignored.  Therefore the bits
    // cannot be transfer over since m3 has allows and denies, but no noops.  Also,
    // win9x doesnt have denies, do we want to noop those users also.

    if(!bEnabled && bGroup)
        dwMask = 0;

    // In general, m1 just supported allows.  However, a user entry that was not enabled was
    // treated as a deny.  Note that win9x does not allow actual denies.

    DWORD dwType = ACCESS_ALLOWED_ACE_TYPE;
    if(!bGroup && !bEnabled)
    {
        dwMask |= (WBEM_ENABLE | WBEM_REMOTE_ACCESS | WBEM_WRITE_PROVIDER);
        dwType = ACCESS_DENIED_ACE_TYPE;
    }

    CNtSid Sid(wc, NULL);
    if(Sid.GetStatus() != CNtSid::NoError)
    {
        ERRORTRACE((LOG_WBEMCORE, "Error converting m1 security ace, name = %S, error = 0x%x", wc, Sid.GetStatus()));
        return NULL;
    }
    CNtAce * pace = new CNtAce(dwMask, dwType, CONTAINER_INHERIT_ACE, Sid);
    return pace;
}

HRESULT CWin9xSecurity::StoreAce(CNtAce* pAce)
{
	// get handle to the root namespace
	CNamespaceHandle* pRootNamespaceHandle = new CNamespaceHandle(m_pControl, m_pRepository);
	if (!pRootNamespaceHandle)
		return WBEM_E_OUT_OF_MEMORY;
    pRootNamespaceHandle->AddRef();
    CReleaseMe relme1(pRootNamespaceHandle);
	HRESULT hRes = pRootNamespaceHandle->Initialize(L"root");
	if (FAILED(hRes))
	{
		ERRORTRACE((LOG_WBEMCORE, "Failed to connect to namespace; HRESULT = %#lx\n", hRes));
		return hRes;
	}

	// get root namespace SD
	CNtSecurityDescriptor sdRoot;
	hRes = GetSDFromNamespace(pRootNamespaceHandle, sdRoot);
	if (FAILED(hRes))
		return hRes;

    // Delete all entries in the SD with the same name
    wchar_t* wszAccountName;
    hRes = pAce->GetFullUserName2(&wszAccountName);
    if(FAILED(hRes))
		return hRes;    
    CVectorDeleteMe<wchar_t> delMe(wszAccountName);

	if (!StripMatchingEntries(sdRoot, wszAccountName))
		return WBEM_E_FAILED;

	// add in the new security
	if (!AddAceToSD(sdRoot, pAce))
		return WBEM_E_FAILED;

	// set the security
	hRes = SetNamespaceSecurity(pRootNamespaceHandle, sdRoot);

	return hRes;
}

bool CWin9xSecurity::StripMatchingEntries(CNtSecurityDescriptor& sd, const wchar_t* wszAccountName)
{
    // Get the DACL
    CNtAcl* pAcl;
    pAcl = sd.GetDacl();
    if(!pAcl)
        return false;
    CDeleteMe<CNtAcl> dm(pAcl);

    // enumerate through the aces
    DWORD dwNumAces = pAcl->GetNumAces();
    BOOL bChanged = FALSE;
	HRESULT hRes = WBEM_S_NO_ERROR;
    for(long nIndex = (long)dwNumAces-1; nIndex >= 0; nIndex--)
    {
        CNtAce* pAce = pAcl->GetAce(nIndex);
        if(pAce)
        {
			wchar_t* wszAceListUserName;
			hRes = pAce->GetFullUserName2(&wszAceListUserName);
			if(FAILED(hRes))
				return false;
			CVectorDeleteMe<wchar_t> delMe(wszAceListUserName);

			if(wbem_wcsicmp(wszAceListUserName, wszAccountName) == 0)
			{
				if (!pAcl->DeleteAce(nIndex))
					return false;
				bChanged = TRUE;
			}
        }
    }

    if(bChanged)
	{
        if (!sd.SetDacl(pAcl))
			return false;
	}

    return true;
}

bool CWin9xSecurity::AddAceToSD(CNtSecurityDescriptor& sd, CNtAce* pAce)
{
    CNtAcl* pacl = sd.GetDacl();
    if(!pacl)
        return false;
    CDeleteMe<CNtAcl> delMe(pacl);

	if (!pacl->AddAce(pAce))
		return false;

	if (!sd.SetDacl(pacl))
		return false;

	return true;
}

HRESULT CWin9xSecurity::ProcessWin9xSecurityBlob(CNamespaceHandle* pNamespaceHandle, const wchar_t* wszNamespaceName, const char* pObjectBlob)
{
	HRESULT hRes = WBEM_S_NO_ERROR;

	// convert the Win9x security blob into a more proper NT security blob
	char* pNsSecurity = NULL;
	if (!ConvertSecurityBlob(pObjectBlob, &pNsSecurity))
	{
		ERRORTRACE((LOG_WBEMCORE, "Failed to convert Win9x security blob for namespace %S\n", wszNamespaceName));
		return WBEM_E_FAILED;
	}
	CVectorDeleteMe<char> delMe1(pNsSecurity);

	// get the parent namespace name, and if a parent exists, get a pointer to it so it can be used below
	CNamespaceHandle* pParentNamespaceHandle = new CNamespaceHandle(m_pControl, m_pRepository);
	if (!pParentNamespaceHandle)
		return WBEM_E_OUT_OF_MEMORY;
    pParentNamespaceHandle->AddRef();
    CReleaseMe relme(pParentNamespaceHandle);

	wchar_t* wszParentNamespaceName = new wchar_t[wcslen(wszNamespaceName)+1];
	if (!wszParentNamespaceName)
		return WBEM_E_OUT_OF_MEMORY;
	CVectorDeleteMe<wchar_t> delMe2(wszParentNamespaceName);

	wcscpy(wszParentNamespaceName, wszNamespaceName);
	wchar_t* pSlash = wcsrchr(wszParentNamespaceName, '\\');
	bool bRoot = true;
	if (pSlash)
	{
		bRoot = false;
		*pSlash = L'\0';
		hRes = pParentNamespaceHandle->Initialize(wszParentNamespaceName);
		if (FAILED(hRes))
			return hRes;
	}

	// now transform the old security blob that consisted of a header and array of ACE's
	// into a proper Security Descriptor that can be stored in the property
	CNtSecurityDescriptor mmfNsSD;
	hRes = TransformBlobToSD(bRoot, pParentNamespaceHandle, pNsSecurity, 0, mmfNsSD);
	if (FAILED(hRes))
	{
		ERRORTRACE((LOG_WBEMCORE, "Failed to convert security blob to SD for namespace %S\n", wszNamespaceName));
		return hRes;
	}

	// now set the security
	hRes = SetNamespaceSecurity(pNamespaceHandle, mmfNsSD);
	if (FAILED(hRes))
	{
		ERRORTRACE((LOG_WBEMCORE, "Failed to set namespace security for namespace %S\n", wszNamespaceName));
		return hRes;
	}

	return hRes;
}

bool CWin9xSecurity::ConvertSecurityBlob(const char* pOrgNsSecurity, char** ppNewNsSecurity)
{
	// convert an old Win9x pseudo-blob into a blob with NT-style ACE's

	if (!pOrgNsSecurity || !ppNewNsSecurity)
		return false;

    DWORD* pdwData = (DWORD*)pOrgNsSecurity;
    DWORD dwSize = *pdwData;

    pdwData++;
    DWORD dwVersion = *pdwData;

    if(dwVersion != 1 || dwSize == 0 || dwSize > 64000)
	{
		ERRORTRACE((LOG_WBEMCORE, "Invalid security blob header\n"));
		return false;
	}

    pdwData++;
    DWORD dwStoredAsNT = *pdwData;
	if (dwStoredAsNT)
	{
		ERRORTRACE((LOG_WBEMCORE, "NT security blob detected; should be Win9x\n"));
		return false;
	}

    CFlexAceArray AceList;
    if (!AceList.DeserializeWin9xSecurityBlob(pOrgNsSecurity))
	{
		ERRORTRACE((LOG_WBEMCORE, "Failed to deserialize a Win9x security blob\n"));
		return false;
	}
	
	// serialize the new WinNT blob
	if (!AceList.SerializeWinNTSecurityBlob(ppNewNsSecurity))
	{
		ERRORTRACE((LOG_WBEMCORE, "Failed to serialize a WinNT security blob\n"));
		return false;
	}
	return true;
}

HRESULT CWin9xSecurity::TransformBlobToSD(bool bRoot, CNamespaceHandle* pParentNamespaceHandle, const char* pNsSecurity, DWORD dwStoredAsNT, CNtSecurityDescriptor& mmfNsSD)
{
	// now transform the old security blob that consisted of a header and array of ACE's
	// into a proper Security Descriptor that can be stored in the property

	// build up an ACL from our blob, if we have one
	CNtAcl acl;

	if (pNsSecurity)
	{
		DWORD* pdwData = (DWORD*) pNsSecurity;
		pdwData += 3;
		int iAceCount = (int)*pdwData;
		pdwData += 2;
		BYTE* pAceData = (BYTE*)pdwData;

		PGENERIC_ACE pAce = NULL;
		for (int iCnt = 0; iCnt < iAceCount; iCnt++)
		{
			pAce = (PGENERIC_ACE)pAceData;
			if (!pAce)
			{
				ERRORTRACE((LOG_WBEMCORE, "Failed to access GENERIC_ACE within security blob\n"));
				return WBEM_E_FAILED;
			}

			CNtAce ace(pAce);
			if(ace.GetStatus() != 0)
			{
				ERRORTRACE((LOG_WBEMCORE, "Failed to construct CNtAce from GENERIC_ACE\n"));
				return WBEM_E_FAILED;
			}

			acl.AddAce(&ace);
			if (acl.GetStatus() != 0)
			{
				ERRORTRACE((LOG_WBEMCORE, "Failed to add ACE to ACL\n"));
				return WBEM_E_FAILED;
			}

			pAceData += ace.GetSize();
		}
	}

	// for Win9x, the security blob for ROOT would not have had any default
	// root aces for administrators and everyone, so create them
    if (bRoot)
    {
		if (!AddDefaultRootAces(&acl))
		{
			ERRORTRACE((LOG_WBEMCORE, "Failed to create default root ACE's\n"));
			return WBEM_E_FAILED;
		}
	}

	// a real SD was constructed and passed in by reference, now set it up properly
	SetOwnerAndGroup(mmfNsSD);
	mmfNsSD.SetDacl(&acl);
	if (mmfNsSD.GetStatus() != 0)
	{
		ERRORTRACE((LOG_WBEMCORE, "Failed to convert namespace security blob to SD\n"));
		return WBEM_E_FAILED;
	}

	// add in the parent's inheritable aces, if this is not ROOT
	if (!bRoot)
	{
		HRESULT hRes = GetParentsInheritableAces(pParentNamespaceHandle, mmfNsSD);
		if (FAILED(hRes))
		{
			ERRORTRACE((LOG_WBEMCORE, "Failed to inherit parent's inheritable ACE's; HRESULT = %#lx\n", hRes));
			return hRes;
		}
	}

	return WBEM_S_NO_ERROR;
}

HRESULT CWin9xSecurity::SetNamespaceSecurity(CNamespaceHandle* pNamespaceHandle, CNtSecurityDescriptor& mmfNsSD)
{
	if (!pNamespaceHandle)
		return WBEM_E_FAILED;

	// get the singleton object
    IWbemClassObject* pThisNamespace = NULL;
	wchar_t* wszThisNamespace = new wchar_t[wcslen(L"__thisnamespace=@")+1];
	wcscpy(wszThisNamespace, L"__thisnamespace=@");
    HRESULT hRes = pNamespaceHandle->GetObjectByPath(wszThisNamespace, 0, IID_IWbemClassObject, (LPVOID*)&pThisNamespace);
	if (FAILED(hRes))
    {
		ERRORTRACE((LOG_WBEMCORE, "Failed to get singleton namespace object; HRESULT = %#lx\n", hRes));
		return hRes;
    }
	CReleaseMe relMe(pThisNamespace);

	// copy SD data into a safearray
	SAFEARRAY FAR* psa;
	SAFEARRAYBOUND rgsabound[1];
	rgsabound[0].lLbound = 0;
	rgsabound[0].cElements = mmfNsSD.GetSize();
	psa = SafeArrayCreate( VT_UI1, 1 , rgsabound );
	if (!psa)
		return WBEM_E_OUT_OF_MEMORY;

	char* pData = NULL;
	hRes = SafeArrayAccessData(psa, (void HUGEP* FAR*)&pData);
	if (FAILED(hRes))
	{
		ERRORTRACE((LOG_WBEMCORE, "Failed SafeArrayAccessData; HRESULT = %#lx\n", hRes));
		return hRes;
	}
	memcpy(pData, mmfNsSD.GetPtr(), mmfNsSD.GetSize());
	hRes = SafeArrayUnaccessData(psa);
	if (FAILED(hRes))
	{
		ERRORTRACE((LOG_WBEMCORE, "Failed SafeArrayUnaccessData; HRESULT = %#lx\n", hRes));
		return hRes;
	}
	pData = NULL;

	// put the safearray into a variant and set the property on the instance
	VARIANT var;
	var.vt = VT_UI1|VT_ARRAY;
	var.parray = psa;
	hRes = pThisNamespace->Put(L"SECURITY_DESCRIPTOR" , 0, &var, 0);
	VariantClear(&var);
	if (FAILED(hRes))
	{
		ERRORTRACE((LOG_WBEMCORE, "Failed to put SECURITY_DESCRIPTOR property; HRESULT = %#lx\n", hRes));
		return hRes;
	}

	// put back the instance
	CEventCollector eventCollector;
    hRes = pNamespaceHandle->PutObject(IID_IWbemClassObject, pThisNamespace, WBEM_FLAG_CREATE_OR_UPDATE, NULL, NULL, eventCollector);
	if (FAILED(hRes))
	{
		ERRORTRACE((LOG_WBEMCORE, "Failed to put back singleton instance; HRESULT = %#lx\n", hRes));
		return hRes;
	}
	return hRes;
}

bool CWin9xSecurity::AddDefaultRootAces(CNtAcl * pacl )
{
	if (!pacl)
		return false;

    PSID pRawSid;
    SID_IDENTIFIER_AUTHORITY id = SECURITY_NT_AUTHORITY;

	//
	// Add ACE's for NETWORK_SERVICE ACCOUNT. These accounts have the following rights:
	// 1. WBEM_ENABLE
	// 2. WBEM_METHOD_EXECUTE
	// 3. WBEM_WRITE_PROVIDER
	//
	DWORD dwAccessMaskNetworkLocalService = WBEM_ENABLE | WBEM_METHOD_EXECUTE | WBEM_WRITE_PROVIDER ;

    if(AllocateAndInitializeSid( &id, 1,
        SECURITY_NETWORK_SERVICE_RID,0,0,0,0,0,0,0,&pRawSid))
    {
        CNtSid SidUsers(pRawSid);
        FreeSid(pRawSid);
        CNtAce * pace = new CNtAce(dwAccessMaskNetworkLocalService, ACCESS_ALLOWED_ACE_TYPE,
                                                CONTAINER_INHERIT_ACE, SidUsers);
		if ( NULL == pace )
		{
			return false;
		}

        CDeleteMe<CNtAce> dm(pace);
        pacl->AddAce(pace);
	}
	else
	{
		ERRORTRACE((LOG_WBEMCORE, "ERROR: Unable to add default root aces (SECURITY_NETWORK_SERVICE_RID)\n"));
	}


	//
	// Add ACE's for NETWORK_SERVICE ACCOUNT. These accounts have the following rights:
	// 1. WBEM_ENABLE
	// 2. WBEM_METHOD_EXECUTE
	// 3. WBEM_WRITE_PROVIDER
	//
    if(AllocateAndInitializeSid( &id, 1,
        SECURITY_LOCAL_SERVICE_RID,0,0,0,0,0,0,0,&pRawSid))
    {
        CNtSid SidUsers(pRawSid);
        FreeSid(pRawSid);
        CNtAce * pace = new CNtAce(dwAccessMaskNetworkLocalService, ACCESS_ALLOWED_ACE_TYPE,
                                                CONTAINER_INHERIT_ACE, SidUsers);
		if ( NULL == pace )
		{
			return false;
		}

        CDeleteMe<CNtAce> dm(pace);
        pacl->AddAce(pace);
	}
	else
	{
		ERRORTRACE((LOG_WBEMCORE, "ERROR: Unable to add default root aces (SECURITY_LOCAL_SERVICE_RID)\n"));
	}



	// add Administrator
    if(AllocateAndInitializeSid( &id, 2,
        SECURITY_BUILTIN_DOMAIN_RID, DOMAIN_ALIAS_RID_ADMINS,
        0,0,0,0,0,0,&pRawSid))
    {
        CNtSid SidAdmin(pRawSid);
        FreeSid(pRawSid);
        DWORD dwMask = FULL_RIGHTS;
        CNtAce * pace = new CNtAce(dwMask, ACCESS_ALLOWED_ACE_TYPE, CONTAINER_INHERIT_ACE, SidAdmin);
		if ( NULL == pace )
			return false;

        CDeleteMe<CNtAce> dm(pace);
        pacl->AddAce(pace);
		if (pacl->GetStatus() != 0)
			return false;
    }

	// add Everyone
	SID_IDENTIFIER_AUTHORITY id2 = SECURITY_WORLD_SID_AUTHORITY;
	if(AllocateAndInitializeSid( &id2, 1,
		0,0,0,0,0,0,0,0,&pRawSid))
	{
		CNtSid SidUsers(pRawSid);
		FreeSid(pRawSid);
		DWORD dwMask = WBEM_ENABLE | WBEM_METHOD_EXECUTE | WBEM_WRITE_PROVIDER;
		CNtAce * pace = new CNtAce(dwMask, ACCESS_ALLOWED_ACE_TYPE, CONTAINER_INHERIT_ACE, SidUsers);
		if ( NULL == pace )
			return false;

		CDeleteMe<CNtAce> dm(pace);
		pacl->AddAce(pace);
		if (pacl->GetStatus() != 0)
			return false;
	}
	return true;
}

HRESULT CWin9xSecurity::GetParentsInheritableAces(CNamespaceHandle* pParentNamespaceHandle, CNtSecurityDescriptor &sd)
{
	if (!pParentNamespaceHandle)
		return WBEM_E_FAILED;

    // Get the parent namespace's SD
	CNtSecurityDescriptor sdParent;
	HRESULT hRes = GetSDFromNamespace(pParentNamespaceHandle, sdParent);
	if (FAILED(hRes))
		return hRes;

	// strip out the inherited aces so we have a consistent SD
	if (!StripOutInheritedAces(sd))
		return WBEM_E_FAILED;

    // Go through the parents dacl and add any inheritable aces to ours.
	if (!CopyInheritAces(sd, sdParent))
		return WBEM_E_FAILED;

	return hRes;
}

HRESULT CWin9xSecurity::GetSDFromNamespace(CNamespaceHandle* pNamespaceHandle, CNtSecurityDescriptor& sd)
{
	if (!pNamespaceHandle)
		return WBEM_E_FAILED;

	// get the singleton object
    IWbemClassObject* pThisNamespace = NULL;
	wchar_t* wszThisNamespace = new wchar_t[wcslen(L"__thisnamespace=@")+1];
	wcscpy(wszThisNamespace, L"__thisnamespace=@");
    HRESULT hRes = pNamespaceHandle->GetObjectByPath(wszThisNamespace, 0, IID_IWbemClassObject, (LPVOID*)&pThisNamespace);
	if (FAILED(hRes))
    {
		ERRORTRACE((LOG_WBEMCORE, "Failed to get singleton namespace object; HRESULT = %#lx\n", hRes));
		return hRes;
    }
	CReleaseMe relMe(pThisNamespace);

    // Get the security descriptor argument
    VARIANT var;
    VariantInit(&var);
    hRes = pThisNamespace->Get(L"SECURITY_DESCRIPTOR", 0, &var, NULL, NULL);
    if (FAILED(hRes))
    {
        VariantClear(&var);
		ERRORTRACE((LOG_WBEMCORE, "Failed to get SECURITY_DESCRIPTOR property; HRESULT = %#lx\n", hRes));
		return hRes;
    }

    if(var.vt != (VT_ARRAY | VT_UI1))
    {
        VariantClear(&var);
		ERRORTRACE((LOG_WBEMCORE, "Failed to get SECURITY_DESCRIPTOR property due to incorrect variant type\n"));
		return WBEM_E_FAILED;
    }

    SAFEARRAY* psa = var.parray;
    PSECURITY_DESCRIPTOR pSD;
    hRes = SafeArrayAccessData(psa, (void HUGEP* FAR*)&pSD);
    if (FAILED(hRes))
    {
        VariantClear(&var);
		ERRORTRACE((LOG_WBEMCORE, "GetSDFromNamespace failed SafeArrayAccessData; HRESULT = %#lx\n", hRes));
		return hRes;
    }

    BOOL bValid = IsValidSecurityDescriptor(pSD);
    if (!bValid)
    {
        VariantClear(&var);
		ERRORTRACE((LOG_WBEMCORE, "GetSDFromNamespace retrieved an invalid security descriptor\n"));
		return WBEM_E_FAILED;
    }

    CNtSecurityDescriptor sdNew(pSD);

    // Check to make sure the owner and group is not NULL!!!!
	CNtSid *pTmpSid = sdNew.GetOwner();
	if (pTmpSid == NULL)
	{
        ERRORTRACE((LOG_WBEMCORE, "Security descriptor was retrieved and it had no owner\n"));
	}
	delete pTmpSid;

	pTmpSid = sdNew.GetGroup();
	if (pTmpSid == NULL)
	{
        ERRORTRACE((LOG_WBEMCORE, "Security descriptor was retrieved and it had no group\n"));
	}
	delete pTmpSid;
	
	sd = sdNew;
    SafeArrayUnaccessData(psa);
    VariantClear(&var);
	return hRes;
}

bool CWin9xSecurity::StripOutInheritedAces(CNtSecurityDescriptor& sd)
{
    // Get the DACL
    CNtAcl* pAcl;
    pAcl = sd.GetDacl();
    if(!pAcl)
        return false;
    CDeleteMe<CNtAcl> dm(pAcl);

    // enumerate through the aces
    DWORD dwNumAces = pAcl->GetNumAces();
    BOOL bChanged = FALSE;
    for(long nIndex = (long)dwNumAces-1; nIndex >= 0; nIndex--)
    {
        CNtAce *pAce = pAcl->GetAce(nIndex);
        CDeleteMe<CNtAce> dm2(pAce);
        if(pAce)
        {
            long lFlags = pAce->GetFlags();
            if(lFlags & INHERITED_ACE)
            {
                pAcl->DeleteAce(nIndex);
                bChanged = TRUE;
            }
        }
    }
    if(bChanged)
        sd.SetDacl(pAcl);
    return true;
}

bool CWin9xSecurity::CopyInheritAces(CNtSecurityDescriptor& sd, CNtSecurityDescriptor& sdParent)
{
	// Get the acl list for both SDs

    CNtAcl * pacl = sd.GetDacl();
    if(pacl == NULL)
        return false;
    CDeleteMe<CNtAcl> dm0(pacl);

    CNtAcl * paclParent = sdParent.GetDacl();
    if(paclParent == NULL)
        return false;
    CDeleteMe<CNtAcl> dm1(paclParent);

	//
	// If parent SD is protected from ACE inheritance only add Local/Network service.
	// This can happen during following conditions:
	//   If an upgrade is done from Win9x and we've stored away the namespace security
	//   into a temporary file another WMI client can create a namespace and set NS security
	//	 with SE_DACL_PROTECTED AFTER we've stored the file (can you say RSOP??). Now, at the 
	//   point of reboot, we scan the file and populate security for each namespace. Since we 
	//   dont have any namespace security stored for this 'new' namespace, we let it simply inherit
	//   from parent which is bad since they explicitly set the SE_DACL_PROTECTED control bit. To
	//	 remedy this, we check to see if the SD is protected and if so, do not inherit anything.
	//
	if ( IsProtected ( sd ) == true )
	{
		return true ;
	}

	int iNumParent = paclParent->GetNumAces();
	for(int iCnt = 0; iCnt < iNumParent; iCnt++)
	{
	    CNtAce *pParentAce = paclParent->GetAce(iCnt);
        CDeleteMe<CNtAce> dm2(pParentAce);

		long lFlags = pParentAce->GetFlags();
		if(lFlags & CONTAINER_INHERIT_ACE)
		{

			if(lFlags & NO_PROPAGATE_INHERIT_ACE)
				lFlags ^= CONTAINER_INHERIT_ACE;
			lFlags |= INHERITED_ACE;

			// If this is an inherit only ace we need to clear this
			// in the children.
			// NT RAID: 161761		[marioh]
			if ( lFlags & INHERIT_ONLY_ACE )
				lFlags ^= INHERIT_ONLY_ACE;

			pParentAce->SetFlags(lFlags);
			pacl->AddAce(pParentAce);
		}
	}
	sd.SetDacl(pacl);
	return true;
}

BOOL CWin9xSecurity::SetOwnerAndGroup(CNtSecurityDescriptor &sd)
{
    PSID pRawSid;
    BOOL bRet = FALSE;

    SID_IDENTIFIER_AUTHORITY id = SECURITY_NT_AUTHORITY;
    if(AllocateAndInitializeSid( &id, 2,
        SECURITY_BUILTIN_DOMAIN_RID, DOMAIN_ALIAS_RID_ADMINS,
        0,0,0,0,0,0,&pRawSid))
    {
        CNtSid SidAdmins(pRawSid);
        bRet = sd.SetGroup(&SidAdmins);		// Access check doesn't really care what you put,
											// so long as you put something for the owner
        if(bRet)
            bRet = sd.SetOwner(&SidAdmins);
        FreeSid(pRawSid);
        return bRet;
    }
    return bRet;
}

//
// CNamespaceListSink is used by the query in RecursiveInheritSecurity below
//
class CNamespaceListSink : public CUnkBase<IWbemObjectSink, &IID_IWbemObjectSink>
{
    CWStringArray &m_aNamespaceList;
public:
    CNamespaceListSink(CWStringArray &aNamespaceList)
        : m_aNamespaceList(aNamespaceList)
    {
    }
    ~CNamespaceListSink()
    {
    }
    STDMETHOD(Indicate)(long lNumObjects, IWbemClassObject** apObjects)
    {
        HRESULT hRes;
        for (int i = 0; i != lNumObjects; i++)
        {
            if (apObjects[i] != NULL)
            {
                _IWmiObject *pInst = NULL;
                hRes = apObjects[i]->QueryInterface(IID__IWmiObject, (void**)&pInst);
                if (FAILED(hRes))
                    return hRes;
                CReleaseMe rm(pInst);

                BSTR strKey = NULL;
                hRes = pInst->GetKeyString(0, &strKey);
                if(FAILED(hRes))
                    return hRes;
                CSysFreeMe sfm(strKey);
                if (m_aNamespaceList.Add(strKey) != CWStringArray::no_error)
                    return WBEM_E_OUT_OF_MEMORY;
            }
        }

        return WBEM_S_NO_ERROR;
    }
    STDMETHOD(SetStatus)(long lFlags, HRESULT hresResult, BSTR, IWbemClassObject*)
    {
        return WBEM_S_NO_ERROR;
    }
};

HRESULT CWin9xSecurity::RecursiveInheritSecurity(CNamespaceHandle* pParentNamespaceHandle, const wchar_t *wszNamespace)
{
	// force namespaces to inherit their inheritable security settings

    HRESULT hRes = WBEM_S_NO_ERROR;

	// get handle to the namespace
	CNamespaceHandle* pNamespaceHandle = new CNamespaceHandle(m_pControl, m_pRepository);
	if (!pNamespaceHandle)
		return WBEM_E_OUT_OF_MEMORY;
    pNamespaceHandle->AddRef();
    CReleaseMe relme1(pNamespaceHandle);
	hRes = pNamespaceHandle->Initialize(wszNamespace);
	if (FAILED(hRes))
	{
		ERRORTRACE((LOG_WBEMCORE, "Failed to connect to namespace; HRESULT = %#lx\n", hRes));
		return hRes;
	}

    // inherit parent's inheritable security if there is a parent
	if (pParentNamespaceHandle)
	{
		CNtSecurityDescriptor sdNamespace;
		hRes = GetSDFromNamespace(pNamespaceHandle, sdNamespace);
		if (FAILED(hRes))
			return hRes;

		hRes = GetParentsInheritableAces(pParentNamespaceHandle, sdNamespace);
		if (FAILED(hRes))
			return hRes;

		hRes = SetNamespaceSecurity(pNamespaceHandle, sdNamespace);
		if (FAILED(hRes))
			return hRes;
	}

	//Enumerate child namespaces
	CWStringArray aListNamespaces;
	CNamespaceListSink* pSink = new CNamespaceListSink(aListNamespaces);
	if (!pSink)
		return WBEM_E_OUT_OF_MEMORY;
	pSink->AddRef();
	CReleaseMe relme2(pSink);

    if (SUCCEEDED(hRes))
    {
		IWbemQuery *pQuery = NULL;
		hRes = CoCreateInstance(CLSID_WbemQuery, NULL, CLSCTX_INPROC_SERVER, IID_IWbemQuery, (void **)&pQuery);
		if (FAILED(hRes))
			return hRes;
		CReleaseMe relme3(pQuery);

		hRes = pQuery->Parse(L"SQL", L"select * from __namespace", 0);
		if (FAILED(hRes))
			return hRes;

		hRes = pNamespaceHandle->ExecQuerySink(pQuery, 0, 0, pSink, NULL);
    }

    //Work through list and call ourselves with that namespace name
    if (SUCCEEDED(hRes))
    {
        for (int i = 0; i != aListNamespaces.Size(); i++)
        {
            //Build the full name of this namespace
            wchar_t *wszChildNamespace = new wchar_t[wcslen(wszNamespace) + wcslen(aListNamespaces[i]) + wcslen(L"\\") + 1];
            if (wszChildNamespace == NULL)
            {
                hRes = WBEM_E_OUT_OF_MEMORY;
                break;
            }
			CVectorDeleteMe<wchar_t> delMe(wszChildNamespace);

            wcscpy(wszChildNamespace, wszNamespace);
            wcscat(wszChildNamespace, L"\\");
            wcscat(wszChildNamespace, aListNamespaces[i]);

            // Do the inherit
            hRes = RecursiveInheritSecurity(pNamespaceHandle, wszChildNamespace);
			if (FAILED(hRes))
				break;
        }
    }

    return hRes;
}

BOOL CWin9xSecurity::DeleteWin9xBlobFile()
{
	// delete the file
	wchar_t wszFilePath[MAX_PATH+1];
	if (!GetRepositoryDirectory(wszFilePath))
		return FALSE;

	wcscat(wszFilePath, BLOB9X_FILENAME);
	return DeleteFileW(wszFilePath);
}

bool CWin9xSecurity::GetRepositoryDirectory(wchar_t wszRepositoryDirectory[MAX_PATH+1])
{
    HKEY hKey;
    if (RegOpenKeyExW(HKEY_LOCAL_MACHINE, L"SOFTWARE\\Microsoft\\WBEM\\CIMOM", 0, KEY_READ, &hKey))
        return false;

    wchar_t wszTmp[MAX_PATH + 1];
    DWORD dwLen = MAX_PATH + 1;
    long lRes = RegQueryValueExW(hKey, L"Repository Directory", NULL, NULL, (LPBYTE)wszTmp, &dwLen);
	RegCloseKey(hKey);
    if(lRes)
        return false;

	if (ExpandEnvironmentStringsW(wszTmp,wszRepositoryDirectory, MAX_PATH + 1) == 0)
		return false;

	return true;
}

//***************************************************************************
//
//  CFlexAceArray::~CFlexAceArray()
//
//  Cleans up safe array entries.
//
//***************************************************************************

CFlexAceArray::~CFlexAceArray()
{
    for(int iCnt = 0; iCnt < Size(); iCnt++)
    {
        CBaseAce* pAce = (CBaseAce*)GetAt(iCnt);
        if(pAce)
            delete pAce;
    }
	Empty();
}

//***************************************************************************
//
//  bool CFlexAceArray::DeserializeWin9xSecurityBlob()
//
//  Description. Deserializes the Win9x pseudo-aces out of a blob.
//  The blob starts off with 5 dwords preceding the aces themselves:
//  <TOTAL SIZE><VERSION><ISNT><ACE_COUNT><RESERVED><ACE> ... <ACE>
//
//***************************************************************************

bool CFlexAceArray::DeserializeWin9xSecurityBlob(const char* pData)
{
	if (!pData)
		return false;

    DWORD* pdwData = (DWORD*)pData;
    pdwData += 3;
    int iAceCount = (int)*pdwData;
    pdwData += 2;

    // Set the ace data
    BYTE* pAceData = (BYTE*)pdwData;
    DWORD dwAceSize = 0;
    CBaseAce* pAce = NULL;
    for (int iCnt = 0; iCnt < iAceCount; iCnt++)
    {
		// if the user is preceeded by a ".\" advance the pointer past it
		if (_wcsnicmp((WCHAR*)pAceData, L".\\", 2) == 0)
			pAceData += 4;

        dwAceSize = 2*(wcslen((WCHAR*)pAceData) + 1) + 12;
        pAce = new CNtAce();
        if (!pAce)
            return false;

        // Deserialize Win9x pseudo ace into NT ace
        pAce->Deserialize(pAceData);

		// only add ACE's that we were successful in creating
		if (pAce->GetStatus() == 0)
	        Add(pAce);

        pAceData += dwAceSize;
    }
	return true;
}

//***************************************************************************
//
//  bool CFlexAceArray::SerializeWinNTSecurityBlob()
//
//  Description. Serializes the WinNT aces into a blob.
//  The blob starts off with 5 dwords preceding the aces themselves:
//  <TOTAL SIZE><VERSION><ISNT><ACE_COUNT><RESERVED><ACE> ... <ACE>
//
//  "version" should be 1.  
//  "ISNT" should be 1
//
//***************************************************************************
	
bool CFlexAceArray::SerializeWinNTSecurityBlob(char** ppData)
{
    // Start by determining the total size needed
    DWORD dwSize = 5 * sizeof(DWORD);               // for the header stuff
    int iAceCount = Size();                         // get count of aces stored in array
    CBaseAce* pAce = NULL;
    for (int iCnt = 0; iCnt < iAceCount; iCnt++)    // add each of the ace sizes
    {
        pAce = (CBaseAce*)GetAt(iCnt);
        if (!pAce)
    		return false;

        dwSize += pAce->GetSerializedSize();
    }

    // Allocate the blob, set the pointer from the caller;
    BYTE* pData = new BYTE[dwSize];
    if (!pData)
    	return false;

    *ppData = (char*)pData;

    // Set the header info
    DWORD* pdwData = (DWORD *)pData;
    *pdwData = dwSize;
    pdwData++;
    *pdwData = 1;           // version
    pdwData++;
    *pdwData = 1;           // ISNT
    pdwData++;
    *pdwData = iAceCount;
    pdwData++;
    *pdwData = 0;           // reserved
    pdwData++;

    // Set the ace data
    BYTE* pAceData = (BYTE*)pdwData;
    for(iCnt = 0; iCnt < iAceCount; iCnt++)
    {
        pAce = (CBaseAce*)GetAt(iCnt);
        pAce->Serialize(pAceData);
        pAceData += pAce->GetSerializedSize();;
    }
	return true;
}


/*
    --------------------------------------------------------------------------
   |
   | Checks to see if the Acl contains an ACE with the specified SID. 
   | The characteristics of the ACE is irrelevant. Only SID comparison applies.
   |
	--------------------------------------------------------------------------
*/
bool CWin9xSecurity::IsProtected(CNtSecurityDescriptor & sd)
{
    PSECURITY_DESCRIPTOR pActual = sd.GetPtr();
    if(pActual == NULL)
        return false;

    SECURITY_DESCRIPTOR_CONTROL Control;
    DWORD dwRevision;
    BOOL bRet = GetSecurityDescriptorControl(pActual, &Control, &dwRevision);
    if(bRet == false)
        return false;

    if(Control & SE_DACL_PROTECTED)
        return true;
    else
        return false;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\xfiles\pagemgr.cpp ===
//***************************************************************************
//
//  (c) 2001 by Microsoft Corp.  All Rights Reserved.
//
//  PAGEMGR.CPP
//
//  Declarations for CPageFile, CPageSource for WMI repository for
//  Windows XP.  This is a fully transacted high-speed page manager.
//
//  21-Feb-01       raymcc      first draft of interfaces
//  28-Feb-01       raymcc      first complete working model
//  18-Apr-01       raymcc      Final fixes for rollback; page reuse
//
//***************************************************************************

#include <windows.h>
#include <stdio.h>
#include <pagemgr.h>
#include <sync.h>
#include <wbemcomn.h>

#define MAP_LEADING_SIGNATURE   0xABCD
#define MAP_TRAILING_SIGNATURE  0xDCBA

#define CURRENT_TRANSACTION        0x80000000
#define PREVIOUS_TRANSACTION       0x40000000

#define ALL_REPLACED_FLAGS       (CURRENT_TRANSACTION | PREVIOUS_TRANSACTION)

#define MERE_PAGE_ID(x)              (x & 0x3FFFFFFF)


void StripHiBits(std::vector <DWORD, wbem_allocator<DWORD> > &Array);
void MoveCurrentToPrevious(std::vector <DWORD, wbem_allocator<DWORD> > &Array);


/*
Map & cache orientation

(a) There are two types of page ids, logical and physical.  The logical
    ID is what is used by the external user, such as the B-tree or
    object heap.  The physical ID is the 0-origin page number into the
    file itself.  For each logical id, there is a corresponding physical
    id.  The decoupling is to allow transacted writes without multiple
    physical writes during commit/rollback, but to 'simulate' transactions
    by interchanging physical-to-logical ID mapping instead. The
    physical offset into the file is the ID * the page size.

(b) Logical ID is implied, and is the offset into the PhysicalID array
(c) Cache operation is by physical id only
(d) The physical IDs of the pages contain other transaction information.
    The MS 2 bits are transaction-related and only the lower 30 bits is the
    physical page id, and so must be masked out when computing offsets.
    The bits are manipulated during commit/rollback, etc.

(d) 0xFFFFFFFE is a reserved page, meaning a page that was allocated
    by NewPage, but has not yet been written for the first time using PutPage.
    This is merely validation technique to ensure pages are written only
    after they were requested.

(e) Cache is agnostic to the transaction methodology.  It is
    simply a physical page cache and has no knowledge of anything
    else. It is promote-to-front on all accesses.  For optimization
    purposes, there is no real movement if the promotion would
    move the page from a near-to-front to absolute-front location.
    This is the 'PromoteToFrontThreshold' in the Init function.
    Note that the cache ordering is by access and not sorted
    in any other way.  Lookups require a linear scan.
    It is possible that during writes new physical pages
    are added to the cache which are 'new extent' pages.  These
    are harmless.

    Map  PhysId             Cache
    [0]  5        /->       2   ->  bytes
    [1]  6       /          3   ->  bytes
    [2]  -1     /           4   ->  bytes
    [3]  3     /            5   ->  bytes
    [4]  2  <-/
    [5]  4


(f) Transaction & checkpoint algorithms

    First, the general process is this:

      1.  Begin transaction:
          (a) Generation A mapping and Generation B mapping member
            variables are identical. Each contains a page map
      2.  Operations within the transaction occur on Generation B
          mapping.  Cache spills are allowed to disk, as they are harmless.
      3.  At rollback, Generation B mapping is copied from Generation A.
      4.  At commit, Generation A is copied from Generation B.
      5.  At checkpoint, Generation A/B are identical and written to disk

    Cache spills & usage are irrelevant to intermediate transactions.

    There are special cases in terms of how pages are reused.  First,
    as pages are freed within a transaction, we cannot just blindly add them
    to the free list, since they might be part of the previous checkpoint
    page set.  This would allow them to be accidentally reused and then
    a checkpoint rollback could never succeed (the original page
    having been destroyed).

    As pages committed during the previous checkpoint are updated, they
    are written to new physical pages under the same logical id.  The old
    physical pages are added to the "Replaced Pages" array.  This allows
    them to be identified as new free list pages once the checkpoint
    occurs.   So, during the checkpoint, replaced pages are merged
    into the current free list.  Until that time, they are 'off limits',
    since we need them for a checkpoint rollback in an emergency.

    Within a transaction, as pages are acquired, they are acquired
    from the physical free list, or if there is no free list, new
    pages are requested.  It can happen that during the next transaction (still
    within the checkpoint), those pages need updating, whether for rewrite
    or delete.  Now, because we may have to roll back, we cannot simply
    add those replaced pages directly to the free list (allowing them
    to be reused by some other operation). Instead, they
    have to be part of a 'deferred free list'. Once the current
    transaction is committed, they can safely be part of the
    regular free list.

    The algorithm is this:

    (a) The physical Page ID is the lower 30 bits of the entry. The two high
        bits have a special meaning.

    (b) Writes result either in an update or a new allocation [whether
        from an extent or a reuse of the free list].  Any such page is marked
        with the CURRENT_TRANSACTION bit (the ms bit) which is merged into
        the phyiscal id. If this page is encountered again, we know it
        was allocated during the current transaction.

    (c) For UPDATES
            1. If the page ID is equal to 0xFFFFFFFE, then we need to
               allocate a new page, which is marked with CURRENT_TRANSACTION.
            2. If the physical page ID written has both high bits clear,
               it is a page being updated which was inherited from the previous
               checkpoint page set. We allocate and write to a new physical
               page, marking this new page with CURRENT_TRANSACTION.
               We add the old physical page ID directly to the m_xReplacedPages
               array. It is off-limits until the next checkpoint, at which
               point it is merged into the free list.
            3. If the physical page id already has CURRENT_TRANSACTION, we
               simply update the page in place.
            4. If the page has the PREVIOUS_TRANSACTION bit set, we allocate
               a new page so a rollback will protect it, and add this page
               to the DeferredFreeList array.  During a commit, these
               pages are merged into the FreeList.  During a rollback,
               we simply throw this array away.

    (d) For DELETE
           1. If the page has both hi bits clear, we add it to the ReplacedPages
              array.
           2. If the page has the CURRENT_TRANSACTION bit set, we add it to the free list.
              This page was never part of any previous operation and can be reused
              right away.
           3. If the page has the PREVIOUS_TRANSACTION bit set, it is added to the
              DeferredFreeList.

    (e) For COMMIT
           1.  All pages with the CURRENT_TRANSACTION bit set are changed to clear that
               bit and set the PREVIOUS_TRANSACTION bit instead.
           2.  All pages with the PREVIOUS_TRANSACTION bit are left intact.
           3.  All pages in the DeferredFreeList are added to the FreeList.

    (f) For ROLLBACK
           1.  All pages with the CURRENT_TRANSACTION bit are moved back into the
               free list (the bits are cleared).
           2.  All pages with the PREVIOUS_TRANSACTION bit are left intact.

    (g) For Checkpoint
           1.  All DeferredFreeList entries are added to FreeList.
           2.  All ReplacedPages are added to FreeList.
           3.  All ms bits are cleared for physical IDs.

     Proof:

        T1 = page set touched for transaction 1, T2=page set touched for transaction 2, etc.

        After T1-START, all new pages are marked CURRENT.  If all are updated n times,
        no new pages are required, since rollback brings us back to zero pages
        anyway.

        At T1-COMMIT, all CURRENT pages are marked PREVIOUS. This is the T1a
        page set.

        After T2-BEGIN, all new pages are marked CURRENT. Again, updating
        all T2 pages infinitely never extends the file beyond the size
        of T1a+T2 page sets. Further deleting and reusing T2 pages
        never affects T1a pages, proving that deleting a CURRENT page
        merits direct addition to the free list.

        Updating n pages from T1 requires n new pages.  As we update
        all the T1 pages, we need a total file size of T2+T1*2.  As
        we encounter T1a pages marked as PREVIOUS, we allocate CURRENT
        pages for T1b and then reuse those indefinitely.  Whether we update
        all T1a or delete all T1a, we must still protect the original T1a
        page set in case of rollback.  Therefore all touched pages of T1a
        are posted the deferred free list as they become replaced by T1b
        equivalents.

        At rollback, we simply throw away the deferred free list,
        and T1a is intact, since those physical pages were never touched.

        At commit, all T1a pages are now in T1b, and al T1a
        pages are now reusable, and of course were in fact added
        to the deferred free list, which is merged with the
        general free list at commit time.  T1b and T2 pages are now
        protected and marked PREVIOUS.

        On the transitive nature of PREVIOUS:

        Assume zero T1 pages are touched at T2-BEGIN, and there
        are only T2 updates, commit and then T3 is begun.  At
        this point, both T1/T2 sets are marked as PREVIOUS
        and not distinguished. T3 new allocations follow the
        same rules.  Obviously if all T1 pages are deleted, we
        still cannot afford to reuse them, since a rollback
        would need to see T1 pages intact.   Therefore at
        each commit, there is an effective identity shift where
            T1 = T2 UNION T1
            T3 becomes T2
        And we are in the 2-transaction problem space again.

        Unmarking pages completely makes them equal to the
        previous checkpoint page set.  They can be completely
        replaced with new physical pages, but never reused until
        the next checkpoint, which wastes space.

    */

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
//
//  CPageCache


//***************************************************************************
//
//  CPageCache::CPageCache
//
//***************************************************************************
//  rev2
CPageCache::CPageCache()
{
    m_dwStatus = NO_ERROR;
    m_hFile = 0;

    m_dwPageSize = 0;
    m_dwCacheSize = 0;

    m_dwCachePromoteThreshold = 0;
    m_dwCacheSpillRatio = 0;

    m_dwLastFlushTime = GetCurrentTime();
    m_dwWritesSinceFlush = 0;
    m_dwLastCacheAccess = 0;

    m_dwReadHits = 0;
    m_dwReadMisses = 0;
    m_dwWriteHits = 0;
    m_dwWriteMisses = 0;
}

//***************************************************************************
//
//  CPageCache::Init
//
//  Initializes the cache.  Called once during startup.  If the file
//  can't be opened, the cache becomes invalid right at the start.
//
//***************************************************************************
// rev2
DWORD CPageCache::Init(
    LPCWSTR pszFilename,               // File
    DWORD dwPageSize,                  // In bytes
    DWORD dwCacheSize,                 // Pages in cache
    DWORD dwCachePromoteThreshold,     // When to ignore promote-to-front
    DWORD dwCacheSpillRatio            // How many additional pages to write on cache write-through
    )
{
    m_dwPageSize = dwPageSize;
    m_dwCacheSize = dwCacheSize;
    m_dwCachePromoteThreshold = dwCachePromoteThreshold;
    m_dwCacheSpillRatio = dwCacheSpillRatio;

    m_hFile = CreateFileW(pszFilename, GENERIC_READ | GENERIC_WRITE, FILE_SHARE_READ, 0,
            OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, 0);

    if (m_hFile == INVALID_HANDLE_VALUE)
    {
        return GetLastError();
    }

    return NO_ERROR;
}

//***************************************************************************
//
//  CPageCache::~CPageCache
//
//  Empties cache during destruct; called once at shutdown.
//
//***************************************************************************
//  rev2
CPageCache::~CPageCache()
{
    if (m_hFile != INVALID_HANDLE_VALUE)
        CloseHandle(m_hFile);

    try
    {
       Empty();
    }
    catch(...)
    {
        // Situation is hopeless
    }
}

//***************************************************************************
//
//  CPageCache::Write()
//
//  Writes a page to the cache and promotes it to the front.  If the
//  page is already present, it is simply marked as dirty and promoted
//  to the front (if it is outside the promote-to-front threshold).
//  If cache is full and this causes overflow, it is handled by the
//  Cache_Spill() at the end.  Physical writes occur in Spill() only if
//  there is cache overflow.
//
//  Errors: Return codes only, sets permanent error status of object
//          once error has occurred.
//
//  On failure, the caller must invoked Cache::Reinit() before using
//  it any further.  On error DISK_FULL, there is not much of a point
//  in a Reinit() even though it is safe.
//
//***************************************************************************
// rev2
DWORD CPageCache::Write(
    DWORD dwPhysId,
    LPBYTE pPageMem
    )
{
    if (m_dwStatus != NO_ERROR)
        return m_dwStatus;

    m_dwWritesSinceFlush++;
    m_dwLastCacheAccess = GetCurrentTime();

    // Search current cache.
    // =====================

    DWORD dwSize = m_aCache.size();

    for (DWORD dwIx = 0; dwIx < dwSize; dwIx++)
    {
        SCachePage *pTest = m_aCache[dwIx];
        if (pTest->m_dwPhysId == dwPhysId)
        {
            delete [] pTest->m_pPage;
            pTest->m_pPage = pPageMem;
            pTest->m_bDirty = TRUE;

            // Promote to front?
            // =================
            if (dwIx > m_dwCachePromoteThreshold)
            {
                try
                {
                    m_aCache.erase(m_aCache.begin()+dwIx);
                    m_aCache.insert(m_aCache.begin(), pTest);
                }
                catch (CX_MemoryException &)
                {
					pTest->m_pPage = 0;
                    m_dwStatus = ERROR_OUTOFMEMORY;
                    return m_dwStatus;
                }
            }
            m_dwWriteHits++;
            return NO_ERROR;
        }
    }

    // If here, no cache hit, so we create a new entry.
    // ================================================

    SCachePage *pCP = new SCachePage;
    if (!pCP)
    {
        m_dwStatus = ERROR_OUTOFMEMORY;
        return m_dwStatus;
    }

    pCP->m_dwPhysId = dwPhysId;
    pCP->m_pPage = pPageMem;
    pCP->m_bDirty = TRUE;

    try
    {
        m_aCache.insert(m_aCache.begin(), pCP);
    }
    catch(CX_MemoryException &)
    {
		pCP->m_pPage = 0;
        delete pCP;
        m_dwStatus = ERROR_OUTOFMEMORY;
        return m_dwStatus;
    }
    m_dwWriteMisses++;
    return Spill();
}


//***************************************************************************
//
//  CPageCache::Read
//
//  Reads the requested page from the cache.  If the page isn't found
//  it is loaded from the disk file.  The cache size cannot change, but
//  the referenced page is promoted to the front if it is outside of
//  the no-promote-threshold.
//
//  A pointer directly into the cache mem is returned in <pMem>, so
//  the contents should be copied as soon as possible.
//
//  Errors: If the read fails due to ERROR_OUTOFMEMORY, then the
//  cache is permanently in an error state until Cache->Reinit()
//  is called.
//
//***************************************************************************
// rev2
DWORD CPageCache::Read(
    IN DWORD dwPhysId,
    OUT LPBYTE *pMem            // Read-only!
    )
{
    if (pMem == 0)
        return ERROR_INVALID_PARAMETER;

    if (m_dwStatus != NO_ERROR)
        return m_dwStatus;

    m_dwLastCacheAccess = GetCurrentTime();

    // Search current cache.
    // =====================

    DWORD dwSize = m_aCache.size();

    for (DWORD dwIx = 0; dwIx < dwSize; dwIx++)
    {
        SCachePage *pTest = m_aCache[dwIx];
        if (pTest->m_dwPhysId == dwPhysId)
        {
            // Promote to front?

            if (dwIx > m_dwCachePromoteThreshold)
            {
                try
                {
                    m_aCache.erase(m_aCache.begin()+dwIx);
                    m_aCache.insert(m_aCache.begin(), pTest);
                }
                catch (CX_MemoryException &)
                {
                    m_dwStatus = ERROR_OUTOFMEMORY;
                    return m_dwStatus;
                }
            }
            *pMem = pTest->m_pPage;
            m_dwReadHits++;
            return NO_ERROR;
        }
    }

    // If here, not found, so we have to read in from disk
    // and do a spill test.
    // ====================================================

    SCachePage *pCP = new SCachePage;
    if (!pCP)
    {
        m_dwStatus = ERROR_OUTOFMEMORY;
        return m_dwStatus;
    }

    pCP->m_dwPhysId = dwPhysId;
    pCP->m_bDirty = FALSE;

    m_dwReadMisses++;
    DWORD dwRes = ReadPhysPage(dwPhysId, &pCP->m_pPage);
    if (dwRes)
    {
        delete pCP;
        m_dwStatus = dwRes;
        return dwRes;
    }

    try
    {
        m_aCache.insert(m_aCache.begin(), pCP);
    }
    catch(CX_MemoryException &)
    {
        delete pCP;
        m_dwStatus = ERROR_OUTOFMEMORY;
        return m_dwStatus;
    }

    dwRes = Spill();
    if (dwRes)
        return dwRes;

    *pMem = pCP->m_pPage;
    return dwRes;
}

//***************************************************************************
//
//  CPageCache::Spill
//
//  Checks for cache overflow and implements the spill-to-disk
//  algorithm.
//
//  Precondition: The cache is either within bounds or 1 page too large.
//
//  If the physical id of the pages written exceeds the physical extent
//  of the file, WritePhysPage will properly extend the file to handle it.
//
//  Note that if no write occurs during the spill, additional pages are
//  not spilled or written.
//
//***************************************************************************
//  rev2
DWORD CPageCache::Spill()
{
    BOOL bWritten = FALSE;
    DWORD dwRes = 0;
    DWORD dwSize = m_aCache.size();

    // See if the cache has exceeded its limit.
    // ========================================

    if (dwSize <= m_dwCacheSize)
        return NO_ERROR;

    // If here, the cache is too large by 1 element (precondition).
    // We remove the last page after checking to see if it is
    // dirty and needs writing.
    // ============================================================

    SCachePage *pDoomed = *(m_aCache.end()-1);
    if (pDoomed->m_bDirty)
    {
        dwRes = WritePhysPage(pDoomed->m_dwPhysId, pDoomed->m_pPage);
        if (dwRes != NO_ERROR)
        {
            m_dwStatus = dwRes;
            return dwRes;
        }
        bWritten = TRUE;
    }
    delete pDoomed;

    try
    {
        m_aCache.erase(m_aCache.end()-1);
    }
    catch(CX_MemoryException &)
    {
        m_dwStatus = ERROR_OUTOFMEMORY;
        return m_dwStatus;
    }

    if (!bWritten)
        return NO_ERROR;

    // If here, we had a write.
    // Next, work through the cache from the end and write out
    // a few more pages, based on the spill ratio. We don't
    // remove these from the cache, we simply write them and
    // clear the dirty bit.
    // ========================================================

    DWORD dwWriteCount = 0;

    try
    {
        std::vector <SCachePage *>::reverse_iterator rit;
        rit = m_aCache.rbegin();

        while (rit != m_aCache.rend() && dwWriteCount < m_dwCacheSpillRatio)
        {
            SCachePage *pTest = *rit;
            if (pTest->m_bDirty)
            {
                dwRes = WritePhysPage(pTest->m_dwPhysId, pTest->m_pPage);
                if (dwRes)
                    return dwRes;
                pTest->m_bDirty = FALSE;
                dwWriteCount++;
            }
            rit++;
        }
    }
    catch(CX_MemoryException &)
    {
        m_dwStatus = ERROR_GEN_FAILURE;
        return m_dwStatus;
    }

    return NO_ERROR;
}


//***************************************************************************
//
//  CPageCache::WritePhysPage
//
//  Writes a physical page.
//
//***************************************************************************
// rev2
DWORD CPageCache::WritePhysPage(
    IN DWORD dwPageId,
    IN LPBYTE pPageMem
    )
{
    if (m_dwStatus != NO_ERROR)
        return m_dwStatus;

    DWORD dwOffset = m_dwPageSize * dwPageId;
    DWORD dwRes = SetFilePointer(m_hFile, dwOffset, 0, FILE_BEGIN);
    if (dwRes != dwOffset)
    {
        m_dwStatus = ERROR_DISK_FULL;
        return m_dwStatus;
    }

    // Commit the page to the disk

    DWORD dwWritten = 0;
    BOOL bRes = WriteFile(m_hFile, pPageMem, m_dwPageSize, &dwWritten, 0);

    if (bRes == FALSE || dwWritten != m_dwPageSize)
    {
        // Probably out of disk space
        m_dwStatus = ERROR_DISK_FULL;
        return m_dwStatus;
    }

    return NO_ERROR;
}

//***************************************************************************
//
//  CPageCache::Empty
//
//  Does no checking to see if a flush should have occurred.
//  Callers have this in a try/catch block.
//
//***************************************************************************
// rev2
DWORD CPageCache::Empty()
{
    DWORD dwSize = m_aCache.size();
    for (DWORD dwIx = 0; dwIx < dwSize; dwIx++)
    {
        SCachePage *pTest = m_aCache[dwIx];
        delete pTest;
    }
    try
    {
       m_aCache.clear();
    }
    catch(CX_MemoryException &)
    {
        return ERROR_OUTOFMEMORY;
    }
    return NO_ERROR;
}


//***************************************************************************
//
//  CPageCache::Flush
//
//***************************************************************************
// rev2
DWORD CPageCache::Flush()
{
    if (m_dwStatus != NO_ERROR)
        return m_dwStatus;

    // Short-circuit.  If no writes have occurred, just reset
    // and return.
    // =======================================================

    if (m_dwWritesSinceFlush == 0)
    {
        m_dwLastFlushTime = GetCurrentTime();
        m_dwWritesSinceFlush = 0;
        return NO_ERROR;
    }

    // Logical cache flush.
    // ====================

    DWORD dwRes = 0;
    DWORD dwSize = m_aCache.size();
    for (DWORD dwIx = 0; dwIx < dwSize; dwIx++)
    {
        SCachePage *pTest = m_aCache[dwIx];
        if (pTest->m_bDirty)
        {
            dwRes = WritePhysPage(pTest->m_dwPhysId, pTest->m_pPage);
            if (dwRes)
                return m_dwStatus = dwRes;
            pTest->m_bDirty = FALSE;
        }
    }

    // Do the disk flush.
    // ==================

    FlushFileBuffers(m_hFile);
    m_dwLastFlushTime = GetCurrentTime();
    m_dwWritesSinceFlush = 0;

    return NO_ERROR;
}


//***************************************************************************
//
//  CPageCache::ReadPhysPage
//
//  Reads a physical page from the file.
//
//***************************************************************************
// rev2
DWORD CPageCache::ReadPhysPage(
    IN  DWORD   dwPage,
    OUT LPBYTE *pPageMem
    )
{
    DWORD dwRes;
    *pPageMem = 0;

    if (m_dwStatus != NO_ERROR)
        return m_dwStatus;

    if (pPageMem == 0)
        return ERROR_INVALID_PARAMETER;

    // Allocate some memory
    // ====================

    LPBYTE pMem = new BYTE[m_dwPageSize];
    if (!pMem)
    {
        m_dwStatus = ERROR_OUTOFMEMORY;
        return m_dwStatus;
    }

    // Where is this page hiding?
    // ==========================

    DWORD dwOffs = dwPage * m_dwPageSize;
    dwRes = SetFilePointer(m_hFile, dwOffs, 0, FILE_BEGIN);
    if (dwRes != dwOffs)
    {
        delete [] pMem;
        m_dwStatus = ERROR_DISK_FULL;
        return m_dwStatus;
    }

    // Try to read it.
    // ===============

    DWORD dwRead = 0;
    BOOL bRes = ReadFile(m_hFile, pMem, m_dwPageSize, &dwRead, 0);
    if (!bRes || dwRead != m_dwPageSize)
    {
        delete [] pMem;
        // If we can't read it, we probably did a seek past eof,
        // meaning the requested page was invalid.
        // =====================================================

        m_dwStatus = ERROR_INVALID_PARAMETER;
        return m_dwStatus;
    }

    *pPageMem = pMem;
    return NO_ERROR;
}


//***************************************************************************
//
//  CPageCache::Dump
//
//  Dumps cache info to the specified stream.
//
//***************************************************************************
// rev2
void CPageCache::Dump(FILE *f)
{
    DWORD dwSize = m_aCache.size();

    fprintf(f, "---Begin Cache Dump---\n");
    fprintf(f, "Status = %d\n", m_dwStatus);
    fprintf(f, "Time since last flush = %d\n", GetCurrentTime() - m_dwLastFlushTime);
    fprintf(f, "Writes since last flush = %d\n", m_dwWritesSinceFlush);
    fprintf(f, "Read hits = %d\n", m_dwReadHits);
    fprintf(f, "Read misses = %d\n", m_dwReadMisses);
    fprintf(f, "Write hits = %d\n", m_dwWriteHits);
    fprintf(f, "Write misses = %d\n", m_dwWriteMisses);
    fprintf(f, "Size = %d\n", dwSize);

    for (DWORD dwIx = 0; dwIx < dwSize; dwIx++)
    {
        SCachePage *pTest = m_aCache[dwIx];
        fprintf(f, "Cache[%d] ID=%d dirty=%d pMem=0x%p <%s>\n",
            dwIx, pTest->m_dwPhysId, pTest->m_bDirty, pTest->m_pPage, pTest->m_pPage);
    }

    fprintf(f, "---End Cache Dump---\n");
}




/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
//
//  CPageFile

//***************************************************************************
//
//  CPageFile::AddRef
//
//***************************************************************************
// rev2
ULONG CPageFile::AddRef()
{
    return (ULONG) InterlockedIncrement(&m_lRef);
}

//***************************************************************************
//
//  CPageFile::ResyncMaps
//
//  Reninitializes B maps from A maps.
//
//***************************************************************************
// rev2
DWORD CPageFile::ResyncMaps()
{
    try
    {
        m_aPageMapB = m_aPageMapA;
        m_aPhysFreeListB = m_aPhysFreeListA;
        m_aLogicalFreeListB = m_aLogicalFreeListA;
        m_aReplacedPagesB = m_aReplacedPagesA;
        m_dwPhysPagesB = m_dwPhysPagesA;
        m_aDeferredFreeList.clear();
    }
    catch (CX_MemoryException &)
    {
        return m_dwStatus = ERROR_NOT_ENOUGH_MEMORY;
    }

    return NO_ERROR;
}

//***************************************************************************
//
//  CPageFile::ReadMap
//
//  Reads the map file into memory.  Format:
//
//      DWORD dwLeadingSignature
//      DWORD dwTransactionGeneration
//      DWORD dwNumMappedPages
//      DWORD PhysicalPages[]
//      DWORD dwNumFreePages
//      DWORD FreePages[]
//      DWORD dwTrailingSignature
//
//  The only time the MAP file will not be present is on creation of
//  a new map file.
//
//  This function is retry-compatible.
//
//***************************************************************************
// rev2
DWORD CPageFile::ReadMap()
{
    BOOL bRes;
    WString sFilename;

    try
    {
        sFilename =  m_sDirectory;
        sFilename += L"\\" ;
        sFilename += m_sMapFile;
    }
    catch (CX_MemoryException &)
    {
        return m_dwStatus = ERROR_OUTOFMEMORY;
    }

    HANDLE hFile = CreateFileW((const wchar_t *)sFilename, GENERIC_READ | GENERIC_WRITE, FILE_SHARE_READ, 0,
            OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, 0);

    if (hFile == INVALID_HANDLE_VALUE)
    {
		DWORD dwRet = GetLastError();
		if (dwRet != ERROR_FILE_NOT_FOUND)
			m_dwStatus = dwRet;
        return dwRet;
    }

    AutoClose _(hFile);

    // If here, read it.
    // =================

    DWORD dwSignature = 0;
    DWORD dwRead = 0;

    bRes = ReadFile(hFile, &dwSignature, sizeof(DWORD), &dwRead, 0);
    if (!bRes || dwRead != sizeof(DWORD) || dwSignature != MAP_LEADING_SIGNATURE)
    {
        return m_dwStatus = ERROR_INVALID_DATA;
    }

    // Read transaction version.
    // =========================

    bRes = ReadFile(hFile, &m_dwTransVersion, sizeof(DWORD), &dwRead, 0);
    if (!bRes || dwRead != sizeof(DWORD))
    {
        return m_dwStatus = ERROR_INVALID_DATA;
    }

    // Read in physical page count.
    // ============================
    bRes = ReadFile(hFile, &m_dwPhysPagesA, sizeof(DWORD), &dwRead, 0);
    if (!bRes || dwRead != sizeof(DWORD))
    {
        return m_dwStatus = ERROR_INVALID_DATA;
    }

    // Read in the page map length and page map.
    // =========================================

    DWORD dwNumPages = 0;
    bRes = ReadFile(hFile, &dwNumPages, sizeof(DWORD), &dwRead, 0);
    if (!bRes || dwRead != sizeof(DWORD))
    {
        return m_dwStatus = ERROR_INVALID_DATA;
    }

    try
    {
        m_aPageMapA.resize(dwNumPages);
    }
    catch (CX_MemoryException &)
    {
        return m_dwStatus = ERROR_OUTOFMEMORY;
    }

    bRes = ReadFile(hFile, &m_aPageMapA[0], sizeof(DWORD)*dwNumPages, &dwRead, 0);
    if (!bRes || dwRead != sizeof(DWORD)*dwNumPages)
        return m_dwStatus = ERROR_INVALID_DATA;

    // Now, read in the physical free list.
    // ====================================

    DWORD dwFreeListSize = 0;
    bRes = ReadFile(hFile, &dwFreeListSize, sizeof(DWORD), &dwRead, 0);
    if (!bRes || dwRead != sizeof(DWORD))
    {
        return m_dwStatus = ERROR_INVALID_DATA;
    }

    try
    {
        m_aPhysFreeListA.resize(dwFreeListSize);
    }
    catch (CX_MemoryException &)
    {
        return m_dwStatus = ERROR_OUTOFMEMORY;
    }

    bRes = ReadFile(hFile, &m_aPhysFreeListA[0], sizeof(DWORD)*dwFreeListSize, &dwRead, 0);
    if (!bRes || dwRead != sizeof(DWORD)*dwFreeListSize)
    {
        return m_dwStatus = ERROR_INVALID_DATA;
    }

    // Read trailing signature.
    // ========================

    bRes = ReadFile(hFile, &dwSignature, sizeof(DWORD), &dwRead, 0);
    if (!bRes || dwRead != sizeof(DWORD) || dwSignature != MAP_TRAILING_SIGNATURE)
    {
        return m_dwStatus = ERROR_INVALID_DATA;
    }

    // Initialize the logical free list from the page map.
    // ===================================================

    return m_dwStatus = InitFreeList();
}


//***************************************************************************
//
//  CPageFile::WriteMap
//
//  Writes the generation A mapping (assuming that we write immediately
//  during a checkpoint when A and B generations are the same and that
//  the replacement lists have been appended to the free lists, etc., etc.
//  This write occurs to a temp file.  The renaming occurs externally.
//
//  This function is retry compatible.
//
//***************************************************************************
// rev2
DWORD CPageFile::WriteMap(LPCWSTR pszTempPath)
{
    BOOL bRes;

    DeleteFileW(pszTempPath);

    HANDLE hFile = CreateFileW(pszTempPath, GENERIC_READ | GENERIC_WRITE, FILE_SHARE_READ, 0,
            CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, 0);

    if (hFile == INVALID_HANDLE_VALUE)
    {
        return m_dwStatus = GetLastError();
    }

    AutoClose _(hFile);

    // If here, write leading signature.
    // =================================

    DWORD dwSignature = MAP_LEADING_SIGNATURE;
    DWORD dwWritten = 0;

    bRes = WriteFile(hFile, &dwSignature, sizeof(DWORD), &dwWritten, 0);
    if (!bRes || dwWritten != sizeof(DWORD))
    {
        m_dwStatus = ERROR_DISK_FULL;
        return m_dwStatus;
    }

    // Write transaction version.
    // ==========================

    bRes = WriteFile(hFile, &m_dwTransVersion, sizeof(DWORD), &dwWritten, 0);
    if (!bRes || dwWritten != sizeof(DWORD))
    {
        m_dwStatus = ERROR_DISK_FULL;
        return m_dwStatus;
    }

    bRes = WriteFile(hFile, &m_dwPhysPagesA, sizeof(DWORD), &dwWritten, 0);
    if (!bRes || dwWritten != sizeof(DWORD))
    {
        m_dwStatus = ERROR_DISK_FULL;
        return m_dwStatus;
    }

    // Write out page map
    // ==================

    DWORD dwNumPages = m_aPageMapA.size();
    bRes = WriteFile(hFile, &dwNumPages, sizeof(DWORD), &dwWritten, 0);
    if (!bRes || dwWritten != sizeof(DWORD))
    {
        m_dwStatus = ERROR_DISK_FULL;
        return m_dwStatus;
    }

    bRes = WriteFile(hFile, &m_aPageMapA[0], sizeof(DWORD)*dwNumPages, &dwWritten, 0);
    if (!bRes || dwWritten != sizeof(DWORD)*dwNumPages)
        return m_dwStatus = ERROR_DISK_FULL;

    // Now, write out physical free list.
    // ==================================

    DWORD dwFreeListSize = m_aPhysFreeListA.size();

    bRes = WriteFile(hFile, &dwFreeListSize, sizeof(DWORD), &dwWritten, 0);
    if (!bRes || dwWritten != sizeof(DWORD))
    {
        return m_dwStatus = ERROR_DISK_FULL;
    }

    bRes = WriteFile(hFile, &m_aPhysFreeListA[0], sizeof(DWORD)*dwFreeListSize, &dwWritten, 0);
    if (!bRes || dwWritten != sizeof(DWORD)*dwFreeListSize)
    {
        return m_dwStatus = ERROR_DISK_FULL;
    }

    // Write trailing signature.
    // =========================

    dwSignature = MAP_TRAILING_SIGNATURE;

    bRes = WriteFile(hFile, &dwSignature, sizeof(DWORD), &dwWritten, 0);
    if (!bRes || dwWritten != sizeof(DWORD))
    {
        m_dwStatus = ERROR_DISK_FULL;
        return m_dwStatus;
    }

    bRes = FlushFileBuffers(hFile);
    if (!bRes)
    {
        return m_dwStatus = GetLastError();  // Drastic failure
    }

    // auto close

    return NO_ERROR;
}

//***************************************************************************
//
//  CPageFile::Trans_Commit
//
//  Rolls the transaction forward (in-memory).  A checkpoint may
//  occur afterwards (decided outside this function)
//
//  The r/w cache contents are not affected except that they may contain
//  garbage pages no longer relevant.
//
//***************************************************************************
// rev2
DWORD CPageFile::Trans_Commit()
{
    if (m_dwStatus)
        return m_dwStatus;

    if (!m_bInTransaction)
        return ERROR_INVALID_OPERATION;


    try
    {
        MoveCurrentToPrevious(m_aPageMapB);
        while (m_aDeferredFreeList.size())
        {
            m_aPhysFreeListB.push_back(m_aDeferredFreeList.back());
            m_aDeferredFreeList.pop_back();
        }

        m_aPageMapA = m_aPageMapB;
        m_aPhysFreeListA = m_aPhysFreeListB;
        m_aLogicalFreeListA = m_aLogicalFreeListB;
        m_aReplacedPagesA = m_aReplacedPagesB;

        m_dwPhysPagesA = m_dwPhysPagesB;
    }
    catch (CX_MemoryException &)
    {
        return m_dwStatus = ERROR_NOT_ENOUGH_MEMORY;
    }

    m_dwTransVersion++;
    m_bInTransaction = FALSE;

    return NO_ERROR;
}

//***************************************************************************
//
//  CPageFile::Trans_Rollback
//
//  Rolls back a transaction within the current checkpoint window.
//  If the cache is hosed, try to recover it.
//
//***************************************************************************
// rev2
DWORD CPageFile::Trans_Rollback()
{
    if (m_dwStatus)
        return m_dwStatus;
    if (!m_bInTransaction)
        return ERROR_INVALID_OPERATION;
    m_bInTransaction = FALSE;
    return m_dwStatus = ResyncMaps();
}


//***************************************************************************
//
//  CPageFile::Trans_Checkpoint
//
//***************************************************************************
//  rev2
DWORD CPageFile::Trans_Checkpoint()
{
    DWORD dwRes;

    std::vector <DWORD, wbem_allocator<DWORD> > & ref = m_aPageMapA;

    if (m_dwStatus)
        return m_dwStatus;
    if (m_bInTransaction)
        return ERROR_INVALID_OPERATION;

    // Flush cache.  If cache is not in a valid state, it
    // will return the error/state immediately.
    // ===================================================

    dwRes = m_pCache->Flush();
    if (dwRes)
        return m_dwStatus = dwRes;

    // Strip the hi bits from the page maps.
    // =====================================

    StripHiBits(ref);

    // The replaced pages become added to the free list.
    // =================================================

    try
    {
        while (m_aReplacedPagesA.size())
        {
            m_aPhysFreeListA.push_back(m_aReplacedPagesA.back());
            m_aReplacedPagesA.pop_back();
        }
    }
    catch (CX_MemoryException &)
    {
        return m_dwStatus = ERROR_OUTOFMEMORY;
    }

    // Ensure maps are in sync.
    // ========================

    dwRes = ResyncMaps();
    if (dwRes)
        return m_dwStatus = dwRes;

    // Write out temp map file.  The atomic rename/rollforward
    // is handled by CPageSource.
    // =======================================================

    try
    {
        WString sFile = m_sDirectory;
        sFile += L"\\";
        sFile += m_sMapFile;
        sFile += L".NEW";

        dwRes = WriteMap((const wchar_t *)sFile);
    }
    catch(CX_MemoryException &)
    {
        return m_dwStatus = ERROR_GEN_FAILURE;
    }

    m_dwLastCheckpoint = GetCurrentTime();

    return m_dwStatus = dwRes; // May reflect WriteMap failure
}

//***************************************************************************
//
//  CPageFile::InitFreeList
//
//  Initializes the free list by a one-time analysis of the map.
//
//***************************************************************************
// rev2
DWORD CPageFile::InitFreeList()
{
    DWORD dwRes = NO_ERROR;

    try
    {
        for (DWORD i = 0; i < m_aPageMapA.size(); i++)
        {
            DWORD dwMapId = m_aPageMapA[i];
            if (dwMapId == WMIREP_INVALID_PAGE)
                m_aLogicalFreeListA.insert(m_aLogicalFreeListA.end(), i);
        }
    }
    catch (CX_MemoryException &)
    {
        m_dwStatus = dwRes = ERROR_GEN_FAILURE;
    }

    return dwRes;
}

//***************************************************************************
//
//  CPageFile::Trans_Begin
//
//***************************************************************************
// rev2
DWORD CPageFile::Trans_Begin()
{
    if (m_dwStatus)
        return m_dwStatus;
    if (m_bInTransaction)
    {
        return ERROR_INVALID_OPERATION;
    }

    DWORD dwRes = ResyncMaps();
    if (dwRes)
    {
        return m_dwStatus = ERROR_GEN_FAILURE;
    }

    m_bInTransaction = TRUE;
    return NO_ERROR;
}

//***************************************************************************
//
//  CPageFile::Release
//
//  No checks for a checkpoint.
//
//***************************************************************************
// rev2
ULONG CPageFile::Release()
{
    LONG lRes = InterlockedDecrement(&m_lRef);
    if (lRes != 0)
        return (ULONG) lRes;

    delete this;
    return 0;
}

//***************************************************************************
//
//  ShellSort
//
//  Generic DWORD sort using Donald Shell algorithm.
//
//***************************************************************************
// rev2
static void ShellSort(std::vector <DWORD, wbem_allocator<DWORD> > &Array)
{
    for (int nInterval = 1; nInterval < Array.size() / 9; nInterval = nInterval * 3 + 1);

    while (nInterval)
    {
        for (int iCursor = nInterval; iCursor < Array.size(); iCursor++)
        {
            int iBackscan = iCursor;
            while (iBackscan - nInterval >= 0 && Array[iBackscan] < Array[iBackscan-nInterval])
            {
                DWORD dwTemp = Array[iBackscan-nInterval];
                Array[iBackscan-nInterval] = Array[iBackscan];
                Array[iBackscan] = dwTemp;
                iBackscan -= nInterval;
            }
        }
        nInterval /= 3;
    }
}

//***************************************************************************
//
//  StripHiBits
//
//  Removes the hi bit from the physical disk ids so that they are no
//  longer marked as 'replaced' in a transaction.
//
//***************************************************************************
//  rev2
void StripHiBits(std::vector <DWORD, wbem_allocator<DWORD> > &Array)
{
    for (int i = 0; i < Array.size(); i++)
    {
        DWORD dwVal = Array[i];
        if (dwVal != WMIREP_INVALID_PAGE)
            Array[i] = MERE_PAGE_ID(dwVal);
    }
}

//***************************************************************************
//
//  MoveCurrentToPrevious
//
//  Removes the CURRENT_TRANSACTION bit from the array and makes
//  it the PREVIOUS_TRANSACTION.
//
//***************************************************************************
//  rev2
void MoveCurrentToPrevious(std::vector <DWORD, wbem_allocator<DWORD> > &Array)
{
    for (int i = 0; i < Array.size(); i++)
    {
        DWORD dwVal = Array[i];
        if (dwVal != WMIREP_INVALID_PAGE && (dwVal & CURRENT_TRANSACTION))
            Array[i] = MERE_PAGE_ID(dwVal) | PREVIOUS_TRANSACTION;
    }
}

//***************************************************************************
//
//  CPageFile::FreePage
//
//  Frees a page within the current transaction.  The logical id
//  is not removed from the map; its entry is simply assigned to
//  'InvalidPage' (0xFFFFFFFF) and the entry is added to the
//  logical free list.
//
//  If the associated physical page has been written within
//  the transaction, it is simply added to the free list.  If the page
//  was never written to within this transaction, it is added to
//  the replaced list.
//
//***************************************************************************
//  rev2
DWORD CPageFile::FreePage(
    DWORD dwFlags,
    DWORD dwId
    )
{
    DWORD dwPhysId;

    // Ensure the object is still valid for further operations.
    // ========================================================

    if (m_dwStatus != 0)
        return m_dwStatus;

    if (!m_bInTransaction)
    {
        return ERROR_INVALID_OPERATION;
    }

    // Make sure the page is 'freeable'.
    // =================================

    if (dwId >= m_aPageMapB.size())
        return ERROR_INVALID_PARAMETER;

    // Remove from page map.
    // =====================

    try
    {
        dwPhysId = m_aPageMapB[dwId];
        if (dwPhysId == WMIREP_INVALID_PAGE)
            return ERROR_INVALID_OPERATION; // Freeing a 'freed' page?
        m_aPageMapB[dwId] = WMIREP_INVALID_PAGE;
        m_aLogicalFreeListB.insert(m_aLogicalFreeListB.end(), MERE_PAGE_ID(dwId));
    }
    catch (CX_MemoryException &)
    {
        m_dwStatus = ERROR_OUTOFMEMORY;
        return m_dwStatus;
    }

    if (dwPhysId == WMIREP_RESERVED_PAGE)
    {
        // The logical page was freed without being ever actually committed to
        // a physical page. Legal, but weird.  The caller had a change of heart.
        return NO_ERROR;
    }

    // Examine physical page to determine its ancestry.  There are
    // three cases.
    // 1. If the page was created within the current transaction,
    //    we simply add it back to the free list.
    // 2. If the page was created in a previous transaction, we add
    //    it to the deferred free list.
    // 3. If the page was created in the previous checkpoint, we add
    //    it to the replaced pages list.
    // ==============================================================

    try
    {
        if (dwPhysId & CURRENT_TRANSACTION)
           m_aPhysFreeListB.insert(m_aPhysFreeListB.end(), MERE_PAGE_ID(dwPhysId));
        else if (dwPhysId & PREVIOUS_TRANSACTION)
           m_aDeferredFreeList.insert(m_aDeferredFreeList.end(), MERE_PAGE_ID(dwPhysId));
        else // previous checkpoint
           m_aReplacedPagesB.insert(m_aReplacedPagesB.end(), MERE_PAGE_ID(dwPhysId));
    }
    catch(...)
    {
        m_dwStatus = ERROR_OUTOFMEMORY;
    }

    return m_dwStatus;
}


//***************************************************************************
//
//  CPageFile::GetPage
//
//  Gets a page.  Doesn't have to be within a transaction.  However, the
//  "B" generation map is always used so that getting within a transaction
//  will reference the correct page.
//
//***************************************************************************
//  rev2
DWORD CPageFile::GetPage(
    DWORD dwId,
    DWORD dwFlags,
    LPVOID pPage
    )
{
    DWORD dwRes;

    if (m_dwStatus != 0)
        return m_dwStatus;

    if (pPage == 0)
        return ERROR_INVALID_PARAMETER;

	CInCritSec _(&m_cs);

    // Determine physical id from logical id.
    // ======================================

    if (dwId >= m_aPageMapB.size())
        return ERROR_FILE_NOT_FOUND;

    DWORD dwPhysId = m_aPageMapB[dwId];
    if (dwPhysId == WMIREP_INVALID_PAGE || dwPhysId == WMIREP_RESERVED_PAGE)
        return ERROR_INVALID_OPERATION;

    try
    {
        LPBYTE pTemp = 0;
        dwRes = m_pCache->Read(MERE_PAGE_ID(dwPhysId), &pTemp);
        if (dwRes == 0)
            memcpy(pPage, pTemp, m_dwPageSize);
    }
    catch(...)
    {
        dwRes = ERROR_GEN_FAILURE;
    }

    return m_dwStatus = dwRes;
}

//***************************************************************************
//
//  CPageFile::PutPage
//
//  Writes a page. Must be within a transaction.   If the page has been
//  written for the first time within the transaction, a new replacement
//  page is allocated and the original page is added to the 'replaced'
//  pages list.   If the page has already been updated within this transaction,
//  it is simply updated again.  We know this because the physical page
//  id has the ms bit set (MAP_REPLACED_PAGE_FLAG).
//
//***************************************************************************
//  rev2
DWORD CPageFile::PutPage(
    DWORD dwId,
    DWORD dwFlags,
    LPVOID pPage
    )
{
    DWORD dwRes = 0, dwNewPhysId = WMIREP_INVALID_PAGE;

    if (m_dwStatus != 0)
        return m_dwStatus;

    if (pPage == 0)
        return ERROR_INVALID_PARAMETER;

    if (!m_bInTransaction)
        return ERROR_INVALID_OPERATION;

    // Allocate some memory to hold the page, since we are reading
    // the caller's copy and not acquiring it.
    // ============================================================

    LPBYTE pPageCopy = new BYTE[m_dwPageSize];
    if (pPageCopy == 0)
        return m_dwStatus = ERROR_OUTOFMEMORY;
    memcpy(pPageCopy, pPage, m_dwPageSize);
    std::auto_ptr <BYTE> _autodelete(pPageCopy);

    // Look up the page.
    // =================

    if (dwId >= m_aPageMapB.size())
        return ERROR_INVALID_PARAMETER;

    DWORD dwPhysId = m_aPageMapB[dwId];
    if (dwPhysId == WMIREP_INVALID_PAGE)    // Unexpected
        return ERROR_GEN_FAILURE;

    // See if the page has already been written within this transaction.
    // =================================================================

    if ((CURRENT_TRANSACTION & dwPhysId)!= 0 && dwPhysId != WMIREP_RESERVED_PAGE)
    {
        // Just update it again.
        // =====================
        try
        {
            dwRes = m_pCache->Write(MERE_PAGE_ID(dwPhysId), LPBYTE(pPageCopy));
        }
        catch(...)
        {
            dwRes = ERROR_GEN_FAILURE;
        }
        if (dwRes == 0)
            _autodelete.release(); // memory acquired by cache
        return m_dwStatus = dwRes;
    }

    // If here, we are going to have to get a new page for writing, regardless
    // of any special casing.  So, we'll do that part first and then decide
    // what to do with the old physical page.
    // ========================================================================

    dwRes = AllocPhysPage(&dwNewPhysId);
    if (dwRes)
    {
        // Horrific.  Now what?  We have to rollback to checkpoint.
        return m_dwStatus = dwRes;
    }

    m_aPageMapB[dwId] = dwNewPhysId | CURRENT_TRANSACTION;

    try
    {
        dwRes = m_pCache->Write(MERE_PAGE_ID(dwNewPhysId), LPBYTE(pPageCopy));
    }
    catch (...)
    {
        dwRes = ERROR_GEN_FAILURE;
    }
    if (dwRes)
        return m_dwStatus = dwRes;
    _autodelete.release();    // Memory safely acquired by cache

    // If the old page ID was WMIREP_RESERVED_PAGE, we actually were
    // creating a page and there was no old page to update.
    // =====================================================================

    if (dwPhysId != WMIREP_RESERVED_PAGE)
    {
        // If here, the old page was either part of the previous checkpoint
        // or the previous set of transactions (the case of rewriting in the
        // current transaction was handled up above).

        try
        {
            if (dwPhysId & PREVIOUS_TRANSACTION)
                m_aDeferredFreeList.insert(m_aDeferredFreeList.end(), MERE_PAGE_ID(dwPhysId));
            else
                m_aReplacedPagesB.insert(m_aReplacedPagesB.end(), MERE_PAGE_ID(dwPhysId));
        }
        catch (CX_MemoryException &)
        {
            m_dwStatus = ERROR_OUTOFMEMORY;
            return m_dwStatus;
        }
    }

    return dwRes;
}



//***************************************************************************
//
//  CPageFile::ReclaimLogicalPages
//
//  Reclaims <dwCount> contiguous logical pages from the free list, if possible.
//  This is done by simply sorting the free list, and then seeing if
//  any contiguous entries have successive ids.
//
//  Returns NO_ERROR on success, ERROR_NOT_FOUND if no sequence could be
//  found, or other errors which are considered critical.
//
//  Callers verified for proper use of return code.
//
//***************************************************************************
//  rev2
DWORD CPageFile::ReclaimLogicalPages(
    DWORD dwCount,
    DWORD *pdwId
    )
{
    std::vector <DWORD, wbem_allocator<DWORD> > &v = m_aLogicalFreeListB;

    DWORD dwSize = v.size();

    if (dwSize < dwCount)
        return ERROR_NOT_FOUND;

    // Special case for one page.
    // ==========================

    if (dwCount == 1)
    {
        try
        {
            *pdwId = v.back();
            v.pop_back();
            m_aPageMapB[*pdwId] = WMIREP_RESERVED_PAGE;
        }
        catch(...)
        {
            return m_dwStatus = ERROR_GEN_FAILURE;
        }
        return NO_ERROR;
    }

    // If here, a multi-page sequence was requested.
    // =============================================
    ShellSort(v);

    DWORD dwContiguous = 1;
    DWORD dwStart = 0;

    for (DWORD dwIx = 0; dwIx+1 < dwSize; dwIx++)
    {
        if (v[dwIx]+1 == v[dwIx+1])
        {
            dwContiguous++;
        }
        else
        {
            dwContiguous = 1;
            dwStart = dwIx + 1;
        }

        // Have we achieved our goal?

        if (dwContiguous == dwCount)
        {
            *pdwId = v[dwStart];

            // Remove reclaimed pages from free list.
            // ======================================

            DWORD dwCount2 = dwCount;

            try
            {
                v.erase(v.begin()+dwStart, v.begin()+dwStart+dwCount);
            }
            catch(...)
            {
                m_dwStatus = ERROR_OUTOFMEMORY;
                return m_dwStatus;
            }

            // Change entries in page map to 'reserved'
            // ========================================

            dwCount2 = dwCount;
            for (DWORD i = *pdwId; dwCount2--; i++)
            {
                m_aPageMapB[i] = WMIREP_RESERVED_PAGE;
            }

            return NO_ERROR;
        }
    }

    return ERROR_NOT_FOUND;
}


//***************************************************************************
//
//  CPageFile::AllocPhysPage
//
//  Finds a free page, first by attempting to reuse the free list,
//  and only if it is zero-length by allocating a new extent to the file.
//
//  The page is marked as CURRENT_TRANSACTION before being returned.
//
//***************************************************************************
// rev2
DWORD CPageFile::AllocPhysPage(DWORD *pdwId)
{
    // Check the physical free list.
    // =============================

    if (m_aPhysFreeListB.size() == 0)
    {
        // No free pages.  Allocate a new one.
        // ===================================

        if (m_dwPhysPagesB == 0x3FFFFFFF)  // No more room
        {
            *pdwId = WMIREP_INVALID_PAGE;
            return m_dwStatus = ERROR_DISK_FULL;
        }

        *pdwId = m_dwPhysPagesB++;
        return NO_ERROR;
    }

    // Get the free page id.
    // =====================

    *pdwId = m_aPhysFreeListB[0];

    // Remove the entry from the free list.
    // ====================================

    try
    {
        m_aPhysFreeListB.erase(m_aPhysFreeListB.begin());
    }
    catch (CX_MemoryException &)
    {
        return m_dwStatus = ERROR_GEN_FAILURE;
    }

    return NO_ERROR;
}


//***************************************************************************
//
//  CPageFile::NewPage
//
//  Allocates one or more contiguous logical page ids for writing.
//
//  This function makes no reference or use of physical pages.
//
//  First examines the free list.  If there aren't any, then a new range
//  of ids is assigned.  These pages must be freed, even if they aren't
//  written, once this call is completed.
//
//***************************************************************************
// rev2
DWORD CPageFile::NewPage(
    DWORD dwFlags,
    DWORD dwRequestedCount,
    DWORD *pdwFirstId
    )
{
    DWORD dwRes;

    if (m_dwStatus != 0)
        return m_dwStatus;

    if (!m_bInTransaction)
        return ERROR_INVALID_OPERATION;

    // See if the logical free list can satisfy the request.
    // =====================================================

    dwRes = ReclaimLogicalPages(dwRequestedCount, pdwFirstId);
    if (dwRes == NO_ERROR)
        return NO_ERROR;

    if (dwRes != ERROR_NOT_FOUND)
    {
        m_dwStatus = dwRes;
        return m_dwStatus;
    }

    // If here, we have to allocate new pages altogether.
    // We do this by adding them to the map as 'reserved'
    // pages.
    // ===================================================

    DWORD dwStart = m_aPageMapB.size();

    for (DWORD dwIx = 0; dwIx < dwRequestedCount; dwIx++)
    {
        try
        {
            m_aPageMapB.insert(m_aPageMapB.end(), WMIREP_RESERVED_PAGE);
        }
        catch(...)
        {
            m_dwStatus = ERROR_OUTOFMEMORY;
            return m_dwStatus;
        }

    }

    *pdwFirstId = dwStart;
    return NO_ERROR;
}

//***************************************************************************
//
//  CPageFile::CPageFile
//
//***************************************************************************
//  rev2
CPageFile::CPageFile()
{
    m_lRef = 1;
    m_dwStatus = 0;
    m_dwPageSize = 0;
	m_dwCachePromotionThreshold = 0;
	m_dwCacheSpillRatio = 0;
    m_pCache = 0;
    m_bInTransaction = 0;
    m_dwLastCheckpoint = GetCurrentTime();
    m_dwTransVersion = 0;

    m_dwPhysPagesA = 0;
    m_dwPhysPagesB = 0;
    m_bCsInit = false;
}

//***************************************************************************
//
//  CPageFile::~CPageFile
//
//***************************************************************************
//  rev2
CPageFile::~CPageFile()
{
    if (m_bCsInit)
    	DeleteCriticalSection(&m_cs);
    delete m_pCache;
}

//***************************************************************************
//
//  FileExists
//
//***************************************************************************
// rev2
static BOOL FileExists(LPCWSTR pszFile)
{
    HANDLE hTest = CreateFileW(pszFile, GENERIC_READ, FILE_SHARE_READ | FILE_SHARE_WRITE, 0,
            OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, 0);

    if (hTest == INVALID_HANDLE_VALUE)
        return FALSE;
    CloseHandle(hTest);
    return TRUE;
}

//***************************************************************************
//
//  CPageFile::Map_Startup
//
//  Since this can only happen *after* a successful checkpoint or
//  a reboot, we won't set any internal status, as it doesn't affect
//  the page set.  It only affects rollforward/rollback at the checkpoint
//  level.
//
//***************************************************************************
// rev2
DWORD CPageFile::Map_Startup(
    LPCWSTR pszDirectory,
    LPCWSTR pszBTreeMap,
    LPCWSTR pszObjMap
    )
{
    // Compute various filenames.
    // ==========================

    WString sObjMap;
    WString sBTreeMap;
    WString sObjMapNew;
    WString sBTreeMapNew;
	WString sObjData;
	WString SBTreeData;
    WString sSemaphore;

    try
    {
	    sObjMap =  pszDirectory;
	    sObjMap += L"\\";
	    sObjMap += pszObjMap;
	
	    sBTreeMap = pszDirectory;
	    sBTreeMap += L"\\";
	    sBTreeMap += pszBTreeMap;
	
	    sObjMapNew = sObjMap;
	    sObjMapNew += L".NEW";
	
	    sBTreeMapNew = sBTreeMap;
	    sBTreeMapNew += L".NEW";

		sObjData = pszDirectory;
		sObjData += L"\\" WMIREP_OBJECT_DATA;

		SBTreeData = pszDirectory;
		SBTreeData += L"\\" WMIREP_BTREE_DATA;

		sSemaphore = pszDirectory;
	    sSemaphore += L"\\ROLL_FORWARD";
    }
    catch(CX_MemoryException &)
    {
        return ERROR_OUTOFMEMORY;
    }

    // To decide what to do, we need to know which files exist and which don't.
    // ========================================================================

    BOOL bSemaphore = FileExists((const wchar_t *)sSemaphore);

    BOOL bExists_BTreeMap       = FileExists((const wchar_t *)sBTreeMap);
    BOOL bExists_BTreeMapNew    = FileExists((const wchar_t *)sBTreeMapNew);
    BOOL bExists_ObjMap         = FileExists((const wchar_t *)sObjMap);
    BOOL bExists_ObjMapNew      = FileExists((const wchar_t *)sObjMapNew);
    
	if (!bSemaphore)
    {
        // If here, we are not a in a roll-forward. Just clean up any spurious
        // .NEW map files and revert to the old ones, if any.
        // ====================================================================

        DeleteFileW((const wchar_t *)sObjMapNew);
        DeleteFileW((const wchar_t *)sBTreeMapNew);

		//If only one of the MAP files exist then we are in trouble also... so detect that and
		//recover if necessary...
		if (bExists_BTreeMap ^ bExists_ObjMap)
		{
			DeleteFileW((const wchar_t *)sBTreeMap);
			DeleteFileW((const wchar_t *)sObjMap);
			DeleteFileW((const wchar_t *)sObjData);
			DeleteFileW((const wchar_t *)SBTreeData);
		}

		//OK, so now we need to check if we have both MAP files, we should have both of the 
		//data files also!
		else if (bExists_BTreeMap && 
			     bExists_ObjMap && 
				(!FileExists((const wchar_t *)SBTreeData) || !FileExists((const wchar_t *)sObjData)))
		{
			//We have MAP files and not all the data files!  We need to tidy up!
			DeleteFileW((const wchar_t *)sBTreeMap);
			DeleteFileW((const wchar_t *)sObjMap);
			DeleteFileW((const wchar_t *)sObjData);
			DeleteFileW((const wchar_t *)SBTreeData);
		}

        return NO_ERROR;
    }


	//Deal with foll forward of tree map file...
	if (bExists_BTreeMapNew)
	{
		if (bExists_BTreeMap)
			DeleteFileW((const wchar_t *)sBTreeMap);
		MoveFileW((const wchar_t *)sBTreeMapNew,(const wchar_t *)sBTreeMap);
	}

	//Deal with foll forward of object map file...
	if (bExists_ObjMapNew)
	{
		if (bExists_ObjMap)
			DeleteFileW((const wchar_t *)sObjMap);
		MoveFileW((const wchar_t *)sObjMapNew,(const wchar_t *)sObjMap);
	}

	//So we now _think_ we have recovered OK, we need to now check to make sure
	//we have both main MAP files.  If now we need to delete and start again
    bExists_BTreeMap       = FileExists((const wchar_t *)sBTreeMap);
    bExists_ObjMap         = FileExists((const wchar_t *)sObjMap);
	if (bExists_BTreeMap ^ bExists_ObjMap)
	{
		DeleteFileW((const wchar_t *)sBTreeMap);
		DeleteFileW((const wchar_t *)sObjMap);
		DeleteFileW((const wchar_t *)sObjData);
		DeleteFileW((const wchar_t *)SBTreeData);
	}
	//OK, so now we need to check if we have both MAP files, we should have both of the 
	//data files also!
	else if (bExists_BTreeMap && 
			 bExists_ObjMap && 
			(!FileExists((const wchar_t *)SBTreeData) || !FileExists((const wchar_t *)sObjData)))
	{
		//We have MAP files and not all the data files!  We need to tidy up!
		DeleteFileW((const wchar_t *)sBTreeMap);
		DeleteFileW((const wchar_t *)sObjMap);
		DeleteFileW((const wchar_t *)sObjData);
		DeleteFileW((const wchar_t *)SBTreeData);
	}
    DeleteFileW((const wchar_t *)sSemaphore);
    return NO_ERROR;
}


//***************************************************************************
//
//  CPageFile::Init
//
//  If failure occurs, we assume another call will follow.
//
//***************************************************************************
// rev2
DWORD CPageFile::Init(
    LPCWSTR pszDirectory,
    LPCWSTR pszMainFile,
    LPCWSTR pszMapFile,
    DWORD dwPageSize,
    DWORD dwCacheSize,
    DWORD dwCachePromotionThreshold,
    DWORD dwCacheSpillRatio
    )
{
    if (pszDirectory == 0 || pszMainFile == 0 || pszMapFile == 0 ||
        dwPageSize == 0
        )
        return ERROR_INVALID_PARAMETER;

    try
    {
		if (!m_bCsInit)
		{
			InitializeCriticalSection(&m_cs);
			m_bCsInit = true;
		}
		m_dwPageSize = dwPageSize;
		m_sDirectory = pszDirectory;
		m_sMainFile = pszMainFile;
		m_sMapFile = pszMapFile;
		m_dwCacheSpillRatio = dwCacheSpillRatio;
		m_dwCachePromotionThreshold = dwCachePromotionThreshold;
    }
    catch(...)
    {
        return m_dwStatus = ERROR_OUTOFMEMORY;
    }


    return 0;
}

DWORD CPageFile::DeInit()
{
	delete m_pCache;
	m_pCache = NULL;

	m_aPageMapA.clear();
	m_aPhysFreeListA.clear();
	m_aLogicalFreeListA.clear();
	m_aReplacedPagesA.clear();
	m_aPageMapB.clear();
	m_aPhysFreeListB.clear();
	m_aLogicalFreeListB.clear();
	m_aReplacedPagesB.clear();
	m_aDeferredFreeList.clear();

	return NO_ERROR;
}

DWORD CPageFile::ReInit()
{

	//Reset the error!
	m_dwStatus = 0;

    m_pCache = new CPageCache;
    if (!m_pCache)
        return m_dwStatus = ERROR_OUTOFMEMORY;
    try
    {
        WString sFile = m_sDirectory;
        sFile += L"\\";
        sFile += m_sMainFile;

        DWORD dwRet = m_pCache->Init((const wchar_t *)sFile, m_dwPageSize,
            m_dwCachePromotionThreshold, m_dwCacheSpillRatio
            );
		if ((dwRet != 0) && (dwRet != ERROR_FILE_NOT_FOUND))
			m_dwStatus = dwRet;
    }
    catch(CX_MemoryException &)
    {
        m_dwStatus = ERROR_OUTOFMEMORY;
    }

    if (m_dwStatus)
	{
		delete m_pCache;
		m_pCache = NULL;
        return m_dwStatus;
	}

    // Read the map.
    // =============
    m_dwStatus = ReadMap();

    if (m_dwStatus != ERROR_FILE_NOT_FOUND && m_dwStatus != NO_ERROR)
	{
		delete m_pCache;
		m_pCache = NULL;
        return m_dwStatus;  // Some kind of error and yet the file exists !?
	}

    m_dwStatus = ResyncMaps();

	if (m_dwStatus != NO_ERROR)
	{
		delete m_pCache;
		m_pCache = NULL;
	}

	m_bInTransaction = FALSE;

    return m_dwStatus;
}

//***************************************************************************
//
//  CPageFile::Dump
//
//***************************************************************************
//
void CPageFile::DumpFreeListInfo()
{
    int i;
    printf("------Free List Info--------\n");
    printf("   Phys Free List (B) =\n");
    for (i = 0; i < m_aPhysFreeListB.size(); i++)
        printf("      0x%X\n", m_aPhysFreeListB[i]);

    printf("   Replaced Pages (B) =\n");
    for (i = 0; i < m_aReplacedPagesB.size(); i++)
        printf("      0x%X\n", m_aReplacedPagesB[i]);

    printf("   Deferred Free List =\n");
    for (i = 0; i < m_aDeferredFreeList.size(); i++)
        printf("      0x%X\n", m_aDeferredFreeList[i]);
    printf("-----End Free List Info -----------\n");

    printf("   Logical Free List =\n");
    for (i = 0; i < m_aLogicalFreeListB.size(); i++)
        printf("      0x%X\n", m_aLogicalFreeListB[i]);
    printf("-----End Free List Info -----------\n");
}

//***************************************************************************
//
//  CPageFile::Dump
//
//***************************************************************************
//  rev2
void CPageFile::Dump(FILE *f)
{
    fprintf(f, "---Page File Dump---\n");
    fprintf(f, "Ref count = %d\n", m_lRef);
    fprintf(f, "Status = %d\n", m_dwStatus);
    fprintf(f, "Page size = 0x%x\n", m_dwPageSize);
    fprintf(f, "Directory = %S\n", (const wchar_t *)m_sDirectory);
    fprintf(f, "Mainfile = %S\n", (const wchar_t *)m_sMainFile);
    fprintf(f, "Mapfile = %S\n", (const wchar_t *)m_sMapFile);
    fprintf(f, "In transaction = %d\n", m_bInTransaction);
    fprintf(f, "Time since last checkpoint = %d\n", GetCurrentTime() - m_dwLastCheckpoint);
    fprintf(f, "Transaction version = %d\n", m_dwTransVersion);

    fprintf(f, "   ---Logical Page Map <Generation A>---\n");
    fprintf(f, "   Phys pages = %d\n", m_dwPhysPagesA);

    int i;
    for (i = 0; i < m_aPageMapA.size(); i++)
        fprintf(f, "   Page[%d] = phys id 0x%x (%d)\n", i, m_aPageMapA[i], m_aPageMapA[i]);

    fprintf(f, "   ---<Generation A Physical Free List>---\n");
    for (i = 0; i < m_aPhysFreeListA.size(); i++)
        fprintf(f, "   phys free = %d\n", m_aPhysFreeListA[i]);

    fprintf(f, "   ---<Generation A Logical Free List>---\n");
    for (i = 0; i < m_aLogicalFreeListA.size(); i++)
        fprintf(f, "   logical free = %d\n", m_aLogicalFreeListA[i]);

    fprintf(f, "   ---<Generation A Replaced Page List>---\n");
    for (i = 0; i < m_aReplacedPagesA.size(); i++)
        fprintf(f, "   replaced = %d\n", m_aReplacedPagesA[i]);

    fprintf(f, "   ---END Generation A mapping---\n");

    fprintf(f, "   ---Logical Page Map <Generation B>---\n");
    fprintf(f, "   Phys pages = %d\n", m_dwPhysPagesB);

    for (i = 0; i < m_aPageMapB.size(); i++)
        fprintf(f, "   Page[%d] = phys id 0x%x (%d)\n", i, m_aPageMapB[i], m_aPageMapB[i]);

    fprintf(f, "   ---<Generation B Physical Free List>---\n");
    for (i = 0; i < m_aPhysFreeListB.size(); i++)
        fprintf(f, "   phys free = %d\n", m_aPhysFreeListB[i]);

    fprintf(f, "   ---<Generation B Logical Free List>---\n");
    for (i = 0; i < m_aLogicalFreeListB.size(); i++)
        fprintf(f, "   logical free = %d\n", m_aLogicalFreeListB[i]);

    fprintf(f, "   ---<Generation B Replaced Page List>---\n");
    for (i = 0; i < m_aReplacedPagesB.size(); i++)
        fprintf(f, "   replaced = %d\n", m_aReplacedPagesB[i]);

    fprintf(f, "   ---END Generation B mapping---\n");
    fprintf(f, "END Page File Dump\n");
}


//***************************************************************************
//
//  CPageSource::GetBTreePageFile
//
//***************************************************************************
// rev2
DWORD CPageSource::GetBTreePageFile(OUT CPageFile **pPF)
{
    if (m_pBTreePF == 0)
        return ERROR_INVALID_OPERATION;

    *pPF = m_pBTreePF;
    m_pBTreePF->AddRef();
    return NO_ERROR;
}

//***************************************************************************
//
//  CPageSource::GetObjectHeapPageFile
//
//***************************************************************************
// rev2
DWORD CPageSource::GetObjectHeapPageFile(OUT CPageFile **pPF)
{
    if (m_pObjPF == 0)
        return ERROR_INVALID_OPERATION;
    *pPF = m_pObjPF;
    m_pObjPF->AddRef();
    return NO_ERROR;
}

//***************************************************************************
//
//  CPageSource::BeginTrans
//
//  If either object gets messed up due to out-of-mem, out-of-disk for
//  the cache, etc., then error codes will be returned.  Calling this
//  forever won't help anything.  Rollback may help, but RollbackCheckpoint
//  is likely required.
//
//***************************************************************************                                                      //
//  rev2
DWORD CPageSource::BeginTrans()
{
    DWORD dwRes;

	//In case of an error state, just return
	dwRes = GetStatus();
	if (dwRes != NO_ERROR)
		return dwRes;

    dwRes = m_pObjPF->Trans_Begin();
    if (dwRes)
        return dwRes;

    dwRes = m_pBTreePF->Trans_Begin();
    if (dwRes)
        return dwRes;

    return dwRes;
}

//***************************************************************************
//
//  CPageSource::Init
//
//  Called once at startup
//
//***************************************************************************
//
DWORD CPageSource::Init(
    DWORD  dwCacheSize,
    DWORD  dwCheckpointTime,
    DWORD  dwPageSize
    )
{
    DWORD dwRes;
    wchar_t *p1 = 0, *p2 = 0;
    p1 = new wchar_t[MAX_PATH+1];
    if (!p1)
        return ERROR_OUTOFMEMORY;
    std::auto_ptr <wchar_t> _1(p1);
    p2 = new wchar_t[MAX_PATH+1];
    if (!p2)
        return ERROR_OUTOFMEMORY;
    std::auto_ptr <wchar_t> _2(p2);

    m_dwCacheSize = dwCacheSize;
    m_dwCheckpointInterval = dwCheckpointTime;
    m_dwPageSize = dwPageSize;

    // Set up working directory, filenames, etc.
    // =========================================

    HKEY hKey;
    long lRes = RegOpenKeyExW(HKEY_LOCAL_MACHINE,
                        L"SOFTWARE\\Microsoft\\WBEM\\CIMOM",
                        0, KEY_READ, &hKey);

    if (lRes)
        return ERROR_GEN_FAILURE;
    DWORD dwLen = MAX_PATH*2;   // in bytes

    lRes = RegQueryValueExW(hKey, L"Repository Directory", NULL, NULL,
                            (LPBYTE)(wchar_t*)p1, &dwLen);
    ExpandEnvironmentStringsW(p1, p2, MAX_PATH);

    try
    {
        m_sDirectory = p2;
        m_sDirectory += L"\\FS";
        m_sBTreeMap = WMIREP_BTREE_MAP;
        m_sObjMap = WMIREP_OBJECT_MAP;
    }
    catch (CX_MemoryException &)
    {
        RegCloseKey(hKey);
        return ERROR_GEN_FAILURE;
    }

    // Read cache settings.
    // ====================

    m_dwPageSize = WMIREP_PAGE_SIZE;
    m_dwCacheSize = 64;
    m_dwCachePromotionThreshold = 16;
    m_dwCacheSpillRatio = 4;
    DWORD dwTemp = 0;
    dwLen = sizeof(DWORD);

    lRes = RegQueryValueExW(hKey, L"Repository Page Size", NULL, NULL,
                            (LPBYTE)&dwTemp, &dwLen);
    if (lRes == 0)
        m_dwPageSize = dwTemp;

    dwLen = sizeof(DWORD);
    lRes = RegQueryValueExW(hKey, L"Repository Cache Size", NULL, NULL,
                            (LPBYTE)&dwTemp, &dwLen);
    if (lRes == 0)
        m_dwCacheSize = dwTemp;

    dwLen = sizeof(DWORD);
    lRes = RegQueryValueExW(hKey, L"Repository Cache Promotion Threshold", NULL, NULL,
                            (LPBYTE)&dwTemp, &dwLen);
    if (lRes == 0)
        m_dwCachePromotionThreshold = dwTemp;

    dwLen = sizeof(DWORD);
    lRes = RegQueryValueExW(hKey, L"Repository Cache Spill Ratio", NULL, NULL,
                            (LPBYTE)&dwTemp, &dwLen);
    if (lRes == 0)
        m_dwCacheSpillRatio = dwTemp;

    RegCloseKey(hKey);

    dwRes = Restart();
    return dwRes;
}

//***************************************************************************
//
//  CPageSource::Shutdown
//
//***************************************************************************
//  rev2
DWORD CPageSource::Shutdown(DWORD dwFlags)
{
    DWORD dwRes = Checkpoint();

	if (m_pObjPF)
		m_pObjPF->Release();
    m_pObjPF = 0;
	if (m_pBTreePF)
		m_pBTreePF->Release();
    m_pBTreePF = 0;

    return dwRes;
}


//***************************************************************************
//
//  CPageSource::CommitTrans
//
//***************************************************************************
//  rev2
DWORD CPageSource::CommitTrans()
{
    DWORD dwRes;

	//In case of an error state, just return
	dwRes = GetStatus();
	if (dwRes != NO_ERROR)
		return dwRes;

    dwRes = m_pObjPF->Trans_Commit();
    if (dwRes)
        return dwRes;

    dwRes = m_pBTreePF->Trans_Commit();
    if (dwRes)
        return dwRes;

    if (m_pBTreePF->GetTransVersion() != m_pObjPF->GetTransVersion())
    {
        return ERROR_GEN_FAILURE;
    }

    return dwRes;
}

//***************************************************************************
//
//  CPageSource::RollbackTrans
//
//  This needs to succeed and clear out the out-of-memory status flag
//  once it does.
//
//***************************************************************************
//  rev2
DWORD CPageSource::RollbackTrans()
{
    DWORD dwRes;

	//In case of an error state, just return
	dwRes = GetStatus();
	if (dwRes != NO_ERROR)
		return dwRes;

    dwRes = m_pObjPF->Trans_Rollback();
    if (dwRes)
        return dwRes;

    dwRes = m_pBTreePF->Trans_Rollback();
    if (dwRes)
        return dwRes;

    return dwRes;
}

//***************************************************************************
//
//  CPageSource::Checkpoint
//
//***************************************************************************
//
DWORD CPageSource::Checkpoint()
{
    DWORD dwRes = 0;

	//In case of an error state, just return
	dwRes = GetStatus();
	if (dwRes != NO_ERROR)
		return dwRes;

    // This is part of the two phase commit.
    // These two calls are the prepare-to-commit aspect.
    // The Map_Startup call later is the roll-forward to commit.
    // If either of the following two calls fails, we can still
    // roll back.
    // =========================================================

    dwRes = m_pObjPF->Trans_Checkpoint();
    if (dwRes)
        return dwRes;

    dwRes = m_pBTreePF->Trans_Checkpoint();
    if (dwRes)
        return dwRes;

    // Create semaphore 'roll forward file'
    // ====================================


    try
    {
        WString sSemaphore;
        sSemaphore = m_sDirectory;
        sSemaphore += L"\\ROLL_FORWARD";

        HANDLE hSem = CreateFileW((const wchar_t *)sSemaphore, GENERIC_READ | GENERIC_WRITE, FILE_SHARE_READ, 0,
            CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, 0);

        if (hSem == INVALID_HANDLE_VALUE)
            return ERROR_GEN_FAILURE;
	    FlushFileBuffers(hSem);
        CloseHandle(hSem);
    }
    catch (CX_MemoryException &)
    {
        return ERROR_OUTOFMEMORY;
    }

    // Now adjust everything for the next generation.
    // ==============================================

    dwRes = CPageFile::Map_Startup((const wchar_t *)m_sDirectory, (const wchar_t *)m_sBTreeMap, (const wchar_t *)m_sObjMap);
    if (dwRes)
        return dwRes;

    m_dwLastCheckpoint = GetCurrentTime();

    return NO_ERROR;
}

//***************************************************************************
//
//  CPageSource::Checkpoint
//
//  Effectively a restart, starting with the last checkpoint.
//
//***************************************************************************
//
DWORD CPageSource::CheckpointRollback()
{
    // Dump all objects and reinit.
	if (m_pObjPF)
		m_pObjPF->DeInit();
	if (m_pBTreePF)
		m_pBTreePF->DeInit();

	DWORD dwRet = Restart();
    return dwRet;
}

//***************************************************************************
//
//  CPageSource::Restart
//
//***************************************************************************
//
DWORD CPageSource::Restart()
{
    DWORD dwRes;

    // Do rollback or rollforward, depending on last system status.
    // ============================================================

    dwRes = CPageFile::Map_Startup((const wchar_t *)m_sDirectory, (const wchar_t *)m_sBTreeMap, (const wchar_t *)m_sObjMap);
    if (dwRes)
        return dwRes;

    // Create new objects.
    // ===================

	for (int i = 0; i != 2; i++)
	{
		if (m_pObjPF == NULL)
		{
			m_pObjPF = new CPageFile;
			if (m_pObjPF)
			{
				dwRes = m_pObjPF->Init(
					(const wchar_t *)m_sDirectory,
					WMIREP_OBJECT_DATA,
					WMIREP_OBJECT_MAP,
					m_dwPageSize,
					m_dwCacheSize,
					m_dwCachePromotionThreshold,
					m_dwCacheSpillRatio
					);

				if (dwRes)
				{
					delete m_pObjPF;
					m_pObjPF = NULL;
					return dwRes;
				}
			}
		}
		if (m_pBTreePF == NULL)
		{
			m_pBTreePF = new CPageFile;
			if (m_pBTreePF)
			{
				dwRes = m_pBTreePF->Init(
					(const wchar_t *)m_sDirectory,
					WMIREP_BTREE_DATA,
					WMIREP_BTREE_MAP,
					m_dwPageSize,
					m_dwCacheSize,
					m_dwCachePromotionThreshold,
					m_dwCacheSpillRatio
					);
				if (dwRes)
				{
					delete m_pObjPF;
					m_pObjPF = NULL;
					delete m_pBTreePF;
					m_pBTreePF = NULL;
					return dwRes;
				}
			}
		}

		if (m_pObjPF == 0 || m_pBTreePF == 0)
		{
			delete m_pObjPF;
			m_pObjPF = NULL;
			delete m_pBTreePF;
			m_pBTreePF = NULL;
			return ERROR_OUTOFMEMORY;
		}

		dwRes = m_pObjPF->ReInit();

		if (dwRes == ERROR_INVALID_DATA)
		{
			try
			{
				//Need to delete repository and start again!
				WString str;
				m_pObjPF->DeInit();
				m_pBTreePF->DeInit();
				str = m_sDirectory;
				str += L"\\";
				str += m_sBTreeMap;
				DeleteFileW(str);
				str = m_sDirectory;
				str += L"\\";
				str += m_sObjMap;
				DeleteFileW(str);
			}
			catch (CX_MemoryException &)
			{
				return ERROR_OUTOFMEMORY;
				
			}
			continue;
		}
		else if (dwRes)
		{
			m_pObjPF->DeInit();
			m_pBTreePF->DeInit();
			return dwRes;
		}

		dwRes = m_pBTreePF->ReInit();

		if (dwRes == ERROR_INVALID_DATA)
		{
			try
			{
				//Need to delete repository and start again!
				WString str;
				m_pObjPF->DeInit();
				m_pBTreePF->DeInit();
				str = m_sDirectory;
				str += L"\\";
				str += m_sBTreeMap;
				DeleteFileW(str);
				str = m_sDirectory;
				str += L"\\";
				str += m_sObjMap;
				DeleteFileW(str);
			}
			catch (CX_MemoryException &)
			{
				return ERROR_OUTOFMEMORY;
				
			}
			continue;
		}
		else if (dwRes)
		{
			m_pObjPF->DeInit();
			m_pBTreePF->DeInit();
			return dwRes;
		}

		return NO_ERROR;
	}
	return dwRes;
}

//***************************************************************************
//
//  CPageSource::RequiresCheckpoint
//
//***************************************************************************
// rev2
BOOL CPageSource::CheckpointRequired()
{
    DWORD dwTime = GetCurrentTime();
    if (dwTime - m_dwLastCheckpoint >= m_dwCheckpointInterval)
        return TRUE;
    return FALSE;
}

//***************************************************************************
//
//  CPageSource::Dump
//
//***************************************************************************
//  rev2
void CPageSource::Dump(FILE *f)
{
    // no impl
}

//***************************************************************************
//
//  CPageSource::CPageSource
//
//***************************************************************************
// rev2
CPageSource::CPageSource()
{
    m_dwPageSize = 0;
    m_dwLastCheckpoint = GetCurrentTime();
    m_dwCheckpointInterval = 0;

    m_pBTreePF = 0;
    m_pObjPF = 0;
}

//***************************************************************************
//
//  CPageSource::~CPageSource
//
//***************************************************************************
// rev2
CPageSource::~CPageSource()
{
    if (m_pBTreePF)
        m_pBTreePF->Release();
    if (m_pObjPF)
        m_pObjPF->Release();
}

//***************************************************************************
//
//  CPageSource::EmptyCaches
//
//***************************************************************************
//  rev2
DWORD CPageSource::EmptyCaches()
{
	DWORD dwRet = ERROR_SUCCESS;
	if (m_pBTreePF)
		dwRet = m_pBTreePF->EmptyCache();
	if (m_pObjPF && (dwRet == ERROR_SUCCESS))
		dwRet = m_pObjPF->EmptyCache();
	return dwRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\xfiles\win9xsecurity.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    Win9xSecurity.h

Abstract:

	This class handles the importing of Win9x security data that was extracted from an old MMF format repository.

History:

	03/17/2001	shbrown - created

--*/

#ifndef __wmi_win9xsecurity_h__
#define __wmi_win9xsecurity_h__

#include <wbemint.h>
#include <strutils.h>
#include <ql.h>
#include "a51rep.h"
#include "flexarry.h"
#include "winntsec.h"

#ifndef FULL_RIGHTS
#define FULL_RIGHTS WBEM_METHOD_EXECUTE | WBEM_FULL_WRITE_REP | WBEM_PARTIAL_WRITE_REP | \
                    WBEM_WRITE_PROVIDER | WRITE_DAC | READ_CONTROL | WBEM_ENABLE | WBEM_REMOTE_ACCESS
#endif

#define BLOB9X_FILENAME L"\\WBEM9xUpgd.dat"
#define BLOB9X_SIGNATURE "9xUpgrade"			//NOTE!  MAXIMUM OF 10 CHARACTERS (INCLUDING TERMINATOR!)

#define BLOB9X_TYPE_SECURITY_BLOB		1
#define BLOB9X_TYPE_SECURITY_INSTANCE	2
#define BLOB9X_TYPE_END_OF_FILE			3

typedef struct _BLOB9X_HEADER
{
	char szSignature[10];
} BLOB9X_HEADER;

typedef struct _BLOB9X_SPACER
{
	DWORD dwSpacerType;
	DWORD dwNamespaceNameSize;
	DWORD dwParentClassNameSize;
	DWORD dwBlobSize;
} BLOB9X_SPACER;

class CWin9xSecurity
{
public:
	CWin9xSecurity(CLifeControl* pControl, CRepository * pRepository)
		: m_h9xBlobFile(INVALID_HANDLE_VALUE), m_pControl(pControl), m_pRepository(pRepository) {};

	bool	Win9xBlobFileExists();
	HRESULT ImportWin9xSecurity();

private:
	HANDLE	m_h9xBlobFile;
	CLifeControl* m_pControl;
	CRepository * m_pRepository;

	HRESULT	DecodeWin9xBlobFile();
	bool	ReadWin9xHeader();
	HRESULT	ProcessWin9xBlob(BLOB9X_SPACER* pHeader);
	HRESULT	ProcessWin9xSecurityInstance(CNamespaceHandle* pNamespaceHandle, wchar_t* wszParentClass, char* pObjectBlob, DWORD dwBlobSize);
	CNtAce*	ConvertOldObjectToAce(_IWmiObject* pObj, bool bGroup);
	HRESULT StoreAce(CNtAce* pAce);
	bool	StripMatchingEntries(CNtSecurityDescriptor& sd, const wchar_t* wszAccountName);
	bool	AddAceToSD(CNtSecurityDescriptor& sd, CNtAce* pAce);
	HRESULT	ProcessWin9xSecurityBlob(CNamespaceHandle* pNamespaceHandle, const wchar_t* wszNamespaceName, const char* pObjectBlob);
	bool	ConvertSecurityBlob(const char* pOrgNsSecurity, char** ppNewNsSecurity);
	HRESULT	TransformBlobToSD(bool bRoot, CNamespaceHandle* pParentNamespaceHandle, const char* pNsSecurity, DWORD dwStoredAsNT, CNtSecurityDescriptor& mmfNsSD);
	HRESULT	SetNamespaceSecurity(CNamespaceHandle* pNamespaceHandle, CNtSecurityDescriptor& mmfNsSD);
	bool	AddDefaultRootAces(CNtAcl * pacl );
	HRESULT	GetParentsInheritableAces(CNamespaceHandle* pParentNamespaceHandle, CNtSecurityDescriptor &sd);
	bool	StripOutInheritedAces(CNtSecurityDescriptor &sd);
	HRESULT	GetSDFromNamespace(CNamespaceHandle* pNamespaceHandle, CNtSecurityDescriptor& sd);
	bool	CopyInheritAces(CNtSecurityDescriptor& sd, CNtSecurityDescriptor& sdParent);
	BOOL	SetOwnerAndGroup(CNtSecurityDescriptor &sd);
	HRESULT	RecursiveInheritSecurity(CNamespaceHandle* pParentNamespaceHandle, const wchar_t *wszNamespace);
	BOOL	DeleteWin9xBlobFile();
	bool	GetRepositoryDirectory(wchar_t wszRepositoryDirectory[MAX_PATH+1]);
	bool	IsProtected ( CNtSecurityDescriptor& sd ) ;
};

// Helper for ConvertSecurityBlob
// A variation of the CFlexArray which deletes the entries
class CFlexAceArray : public CFlexArray
{
public:
	CFlexAceArray(){};
	~CFlexAceArray();
    bool SerializeWinNTSecurityBlob(char** pData);
    bool DeserializeWin9xSecurityBlob(const char* pData);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\xfiles\dumptool\makefile.inc ===
!INCLUDE $(_NTDRIVE)$(_NTROOT)\WMI\COMMON\makefile.cmn
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\xmltransport\client\helpersources\enumerate.cpp ===
// EnumerateClassPacket.cpp: implementation of the CEnumeratePacket class.
//
//////////////////////////////////////////////////////////////////////

#include "XMLTransportClientHelper.h"
#include "XMLClientPacket.h"
#include "Enumerate.h"

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CEnumeratePacket::CEnumeratePacket(const WCHAR *pwszObjPath,const WCHAR *pwszNameSpace, bool bClassEnumeration)	
: CXMLClientPacket(pwszObjPath,pwszNameSpace, (bClassEnumeration)? L"EnumerateClasses" : L"EnumerateInstances")
{
	m_ePathstyle = NOVAPATH; //assume nova path if this ctor is called.
}


HRESULT CEnumeratePacket::GetBody(WCHAR **ppwszBody,DWORD *pdwLengthofPacket)
{
	if(NULL == ppwszBody)
		return E_INVALIDARG;

	HRESULT hr = S_OK;

	IStream *pStream = NULL;
	if(SUCCEEDED(hr = GetBodyTillLocalNamespacePathInStream(&pStream)))
	{
		if(SUCCEEDED(hr))
		{
			WRITETOSTREAM(pStream, L"<IPARAMVALUE NAME=\"ClassName\"><CLASSNAME NAME=\"");
			// Class Name can be NULL when you want to enuemrate all classes in a namespace
			if(m_pwszObjPath)
				WRITETOSTREAM(pStream, m_pwszObjPath);
			WRITETOSTREAM(pStream, L"\"/></IPARAMVALUE>");

			WRITETOSTREAM(pStream, L"<IPARAMVALUE NAME=\"LocalOnly\"><VALUE>");
			WRITETOSTREAM(pStream, m_pwszLocalOnly);
			WRITETOSTREAM(pStream, L"</VALUE></IPARAMVALUE>");

			WRITETOSTREAM(pStream, L"<IPARAMVALUE NAME=\"DeepInheritance\"><VALUE>");
			WRITETOSTREAM(pStream, m_pwszDeepInheritance);
			WRITETOSTREAM(pStream, L"</VALUE></IPARAMVALUE>");

			WRITETOSTREAM(pStream, L"<IPARAMVALUE NAME=\"IncludeClassOrigin\"><VALUE>");
			WRITETOSTREAM(pStream, m_pwszIncludeClassOrigin);
			WRITETOSTREAM(pStream, L"</VALUE></IPARAMVALUE>");

			WRITETOSTREAM(pStream, L"<IPARAMVALUE NAME=\"IncludeQualifiers\"><VALUE>");
			WRITETOSTREAM(pStream, m_pwszIncludeQualifier);
			WRITETOSTREAM(pStream, L"</VALUE></IPARAMVALUE>");

			WRITETOSTREAM(pStream, L"</IMETHODCALL></SIMPLEREQ></MESSAGE></CIM>");

			hr = GetWStringFromStream(pStream, ppwszBody, pdwLengthofPacket);			
		}
		pStream->Release();
	}
	
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\xmltransport\client\helpersources\deleteclasspacket.cpp ===
// DeleteClassPacket.cpp: implementation of the CDeleteClassPacket class.
//
//////////////////////////////////////////////////////////////////////

#include "XMLTransportClientHelper.h"
#include "XMLClientPacket.h"
#include "DeleteClassPacket.h"

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CDeleteClassPacket::CDeleteClassPacket(const WCHAR *pwszObjPath,const WCHAR *pwszNameSpace)
	: CXMLClientPacket(pwszObjPath,pwszNameSpace,L"DeleteClass")
{
	m_ePathstyle = NOVAPATH; //assume nova path if this ctor is called.
}


HRESULT CDeleteClassPacket::GetBody(WCHAR **ppwszBody,DWORD *pdwLengthofPacket)
{
	if(NULL == ppwszBody)
		return E_INVALIDARG;
	
	HRESULT hr = S_OK;
	IStream *pStream = NULL;
	if(SUCCEEDED(hr = GetBodyTillLocalNamespacePathInStream(&pStream)))
	{
		if(SUCCEEDED(hr))
		{
			WRITETOSTREAM(pStream,L"<IPARAMVALUE NAME=\"ClassName\"><CLASSNAME NAME=\"");
			WRITETOSTREAM(pStream,m_pwszObjPath);
			WRITETOSTREAM(pStream,L"\"/></IPARAMVALUE>");
			WRITETOSTREAM(pStream,L"</IMETHODCALL></SIMPLEREQ></MESSAGE></CIM>");
			hr = GetWStringFromStream(pStream, ppwszBody, pdwLengthofPacket);
		}
		pStream->Release();
	}

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\xmltransport\client\helpersources\execquerypacket.cpp ===
// GetInstancePacket.cpp: implementation of the CExecQueryPacket class.
//
//////////////////////////////////////////////////////////////////////

#include "XMLTransportClientHelper.h"
#include "XMLClientPacket.h"
#include "ExecQueryPacket.h"

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CExecQueryPacket::CExecQueryPacket(const WCHAR *pwszObjPath,const WCHAR *pwszNameSpace)
	: CXMLClientPacket(pwszObjPath,pwszNameSpace,L"ExecQuery")
{

	m_ePathstyle = NOVAPATH; //assume nova path if this ctor is called.

	//default query language.
	wcscpy(m_pwszQueryLanguage,L"WQL");
	m_pwszQueryString = NULL;
}

HRESULT CExecQueryPacket::GetBody(WCHAR **ppwszBody,DWORD *pdwLengthofPacket)
{
	//Client must first set the query string using SetQueryString fn.
	//we need a valid query for processing.
	if(NULL == m_pwszQueryString || (NULL == ppwszBody))
		return E_INVALIDARG;


	HRESULT hr = S_OK;
	IStream *pStream = NULL;
	if(SUCCEEDED(hr = GetBodyTillLocalNamespacePathInStream(&pStream)))
	{
		WRITETOSTREAM(pStream, L"<IPARAMVALUE NAME=\"Query\"><VALUE>");
		WRITETOSTREAM(pStream, m_pwszQueryString);
		WRITETOSTREAM(pStream, L"</VALUE></IPARAMVALUE><IPARAMVALUE NAME=\"QueryLanguage\"><VALUE>");
		WRITETOSTREAM(pStream, m_pwszQueryLanguage);
		WRITETOSTREAM(pStream, L"</VALUE></IPARAMVALUE></IMETHODCALL></SIMPLEREQ></MESSAGE></CIM>");

		hr = GetWStringFromStream(pStream, ppwszBody, pdwLengthofPacket);
		pStream->Release();
	}
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\xmltransport\client\helpersources\executeclassmethodpacket.cpp ===
// ExecuteClassMethodPacket.cpp: implementation of the CExecuteClassMethodPacket class.
//
//////////////////////////////////////////////////////////////////////

#include "XMLTransportClientHelper.h"
#include "XMLClientPacket.h"
#include "ExecuteClassMethodPacket.h"


//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CExecuteClassMethodPacket::CExecuteClassMethodPacket(const WCHAR *pwszObjPath,const WCHAR *pwszNameSpace):
CXMLClientPacket(pwszObjPath,pwszNameSpace,NULL)
{
	m_ePathstyle = NOVAPATH; //assume nova path if this ctor is called.
}


//////////////////////////////////////////////////////////////////////
// Member functions
//////////////////////////////////////////////////////////////////////

HRESULT CExecuteClassMethodPacket::GetBody(WCHAR **ppwszBody,DWORD *pdwLengthofPacket)
{
	
	if((NULL == ppwszBody)||(NULL == m_pwszObjPath))
		return E_INVALIDARG;

	HRESULT hr = S_OK;

	IStream *pStream = NULL;
	if(SUCCEEDED(hr = CreateStreamOnHGlobal(NULL,TRUE,&pStream)))
	{
		WRITETOSTREAM(pStream,L"<?xml version=\"1.0\" encoding=\"utf-8\" ?>");
		WRITETOSTREAM(pStream,L"<CIM CIMVERSION=\"2.0\" DTDVERSION=\"2.0\">");
		WRITETOSTREAM(pStream,L"<MESSAGE ID=\"");
		
		// Write the ID of the message tag
		WCHAR pTemp[5];
		pTemp[4]='\0';
		UINT uMsgID = 0;
		Get4DigitRandom(&uMsgID);
		wsprintf(pTemp,L"%u", uMsgID);
		WRITETOSTREAM(pStream, pTemp);

		WRITETOSTREAM(pStream, L"\" PROTOCOLVERSION=\"1.0\"><SIMPLEREQ><METHODCALL NAME=\"");
		WRITETOSTREAM(pStream, m_pwszCimOperation);
		WRITETOSTREAM(pStream, L"\"><LOCALCLASSPATH><LOCALNAMESPACEPATH>");
		if(SUCCEEDED(hr = GetXMLNamespaceInStream(pStream)))
		{
			WRITETOSTREAM(pStream, L"</LOCALNAMESPACEPATH>");
			WRITETOSTREAM(pStream,L"<CLASSNAME NAME=\"");
			WRITETOSTREAM(pStream,m_pwszObjPath);
			WRITETOSTREAM(pStream,L"\"></CLASSNAME>");
			WRITETOSTREAM(pStream,L"</LOCALCLASSPATH>");

			if(SUCCEEDED(hr))
			{
				if(NULL != m_pWbemClassObject)
					hr = GetParamsFromObjectInStream(pStream);

				if(SUCCEEDED(hr))
				{
					WRITETOSTREAM(pStream,L"</METHODCALL></SIMPLEREQ></MESSAGE></CIM>");
					hr = GetWStringFromStream(pStream,ppwszBody,pdwLengthofPacket);
				}
			}
		}
		pStream->Release();
	}
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\xmltransport\client\helpersources\deleteinstancepacket.cpp ===
// DeleteInstancePacket.cpp: implementation of the CDeleteInstancePacket class.
//
//////////////////////////////////////////////////////////////////////

#include "XMLTransportClientHelper.h"
#include "XMLClientPacket.h"
#include "DeleteInstancePacket.h"


//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CDeleteInstancePacket::CDeleteInstancePacket(const WCHAR *pwszObjPath,const WCHAR *pwszNameSpace):
CXMLClientPacket(pwszObjPath,pwszNameSpace,L"DeleteInstance")
{
	m_ePathstyle = NOVAPATH; //assume nova path if this ctor is called.
}


HRESULT CDeleteInstancePacket::GetBody(WCHAR **ppwszBody,DWORD *pdwLengthofPacket)
{
	if(NULL == ppwszBody)
		return E_INVALIDARG;
	
	HRESULT hr = S_OK;
	IStream *pStream = NULL;
	if(SUCCEEDED(hr = GetBodyTillLocalNamespacePathInStream(&pStream)))
	{
		if(SUCCEEDED(hr))
		{
			WRITETOSTREAM(pStream,L"<IPARAMVALUE NAME=\"InstanceName\">");
			if(SUCCEEDED(hr = GetKeyBindingsInStream(pStream)))
			{
				WRITETOSTREAM(pStream,L"\"/></IPARAMVALUE>");
				WRITETOSTREAM(pStream,L"</IMETHODCALL></SIMPLEREQ></MESSAGE></CIM>");
				hr = GetWStringFromStream(pStream,ppwszBody,pdwLengthofPacket);
			}
		}
		pStream->Release();
	}

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\xmltransport\client\helpersources\enumerateclassnamespacket.cpp ===
// EnumerateClassNamesPacket.cpp: implementation of the CEnumerateClassNamesPacket class.
//
//////////////////////////////////////////////////////////////////////

#include "XMLTransportClientHelper.h"
#include "XMLClientPacket.h"
#include "EnumerateClassNamesPacket.h"

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CEnumerateClassNamesPacket::CEnumerateClassNamesPacket(const WCHAR *pwszObjPath,const WCHAR *pwszNameSpace)
	: CXMLClientPacket(pwszObjPath,pwszNameSpace,L"EnumerateClassNames")
{}

HRESULT CEnumerateClassNamesPacket::GetBody(WCHAR **ppwszBody,DWORD *pdwLengthofPacket)
{
	if(NULL == ppwszBody)
		return E_INVALIDARG;
	
	HRESULT hr = S_OK;

	IStream *pStream = NULL;
	if(SUCCEEDED(hr = GetBodyTillLocalNamespacePathInStream(&pStream)))
	{
		if(SUCCEEDED(hr))
		{
			WRITETOSTREAM(pStream, L"<IPARAMVALUE NAME=\"ClassName\"><CLASSNAME NAME=\"");
			// Class Name can be NULL when you want to enuemrate all classes in a namespace
			if(m_pwszObjPath)
				WRITETOSTREAM(pStream, m_pwszObjPath);
			WRITETOSTREAM(pStream, L"\"/></IPARAMVALUE>");
			WRITETOSTREAM(pStream, L"<IPARAMVALUE NAME=\"DeepInheritance\"><VALUE>");
			WRITETOSTREAM(pStream, m_pwszDeepInheritance);
			WRITETOSTREAM(pStream, L"</VALUE></IPARAMVALUE>");
			WRITETOSTREAM(pStream, L"</IMETHODCALL></SIMPLEREQ></MESSAGE></CIM>");

			hr = GetWStringFromStream(pStream, ppwszBody, pdwLengthofPacket);			
		}
		pStream->Release();
	}
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\xmltransport\client\helpersources\enumerateinstancenamespacket.cpp ===
// EnumerateInstanceNamesPacket.cpp: implementation of the CEnumerateInstanceNamesPacket class.
//
//////////////////////////////////////////////////////////////////////

#include "XMLTransportClientHelper.h"
#include "XMLClientPacket.h"
#include "EnumerateInstanceNamesPacket.h"

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CEnumerateInstanceNamesPacket::CEnumerateInstanceNamesPacket(const WCHAR *pwszObjPath,const WCHAR *pwszNameSpace):
CXMLClientPacket(pwszObjPath,pwszNameSpace,L"EnumerateInstanceNames")
{

}

HRESULT CEnumerateInstanceNamesPacket::GetBody(WCHAR **ppwszBody,DWORD *pdwLengthofPacket)
{
	if(NULL == ppwszBody)
		return E_INVALIDARG;
	
	HRESULT hr = S_OK;

	IStream *pStream = NULL;
	if(SUCCEEDED(hr = GetBodyTillLocalNamespacePathInStream(&pStream)))
	{
		if(SUCCEEDED(hr))
		{
			WRITETOSTREAM(pStream, L"<IPARAMVALUE NAME=\"ClassName\"><CLASSNAME NAME=\"");
			// Class Name can be NULL when you want to enuemrate all classes in a namespace
			if(m_pwszObjPath)
				WRITETOSTREAM(pStream, m_pwszObjPath);
			WRITETOSTREAM(pStream, L"\"/></IPARAMVALUE>");
			WRITETOSTREAM(pStream, L"</IMETHODCALL></SIMPLEREQ></MESSAGE></CIM>");

			hr = GetWStringFromStream(pStream, ppwszBody, pdwLengthofPacket);			
		}
		pStream->Release();
	}
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\xfiles\dumptool\main.cpp ===
#include <windows.h>
#include <stdio.h>
#include <pagemgr.h>
#include <varobjheap.h>
#include <sync.h>
#include <wbemcomn.h>

#define MAP_LEADING_SIGNATURE   0xABCD
#define MAP_TRAILING_SIGNATURE  0xDCBA

typedef std::vector <DWORD, wbem_allocator<DWORD> > XFilesMap;

DWORD ReadMapFile(const wchar_t *sFilename, XFilesMap &aPageMap, XFilesMap & aPhysFreeList);
DWORD DumpHeapAdminPages(const wchar_t *sFilename, XFilesMap &aHeapMap, XFilesMap &aHeapFreeList);
DWORD GetHeapManagedPageCount(const wchar_t *sFilename, XFilesMap &aHeapMap, DWORD &dwNumAdminPages, DWORD &dwNumMultiBlockPages, DWORD &dwNumMultiBlockObjects);
DWORD GetMapUsageCount(XFilesMap &aHeapMap, DWORD &dwHeapMapUsed, DWORD &dwHeapMapFree);
DWORD DumpMap(XFilesMap &aMap);


void __cdecl main(int argc, char *argv[ ])
{
	printf("WMI XFiles repository dumper\n\n");
	bool bDumpHeapAdminPage = false;
	bool bDumpTreeMap = false;
	bool bDumpHeapMap = false;

	for (int i = 1; i != argc; i++)
	{
		if ((_stricmp(argv[i], "/?") == 0) ||
			(_stricmp(argv[i], "-?") == 0))
		{
			printf("Usage: DumpTool.exe /?               - display this message\n"
				   "       DumpTool.exe /DumpAdminPages  - dumps the heap admin tables\n"
				   "       DumpTool.exe /DumpTreeMap     - dumps the tree map usage\n"
				   "       DumpTool.exe /DumpHeapMap     - dumps the heap map usage\n");
			return;
		}
		else if (_stricmp(argv[i], "/DumpAdminPages") == 0)
		{
			bDumpHeapAdminPage = true;
		}
		else if (_stricmp(argv[i], "/DumpTreeMap") == 0)
		{
			bDumpTreeMap = true;
		}
		else if (_stricmp(argv[i], "/DumpHeapMap") == 0)
		{
			bDumpHeapMap = true;
		}
	}

	DWORD dwRet;

	XFilesMap aBTreeMap;
	XFilesMap aBTreeFreeList;
	DWORD     dwBTreeSize = 0;
	DWORD     dwBTreeUsed = 0;
	DWORD     dwBTreeFree = 0;
	XFilesMap aHeapMap;
	XFilesMap aHeapFreeList;
	DWORD     dwHeapSize = 0;
	DWORD     dwHeapUsed = 0;
	DWORD     dwHeapFree = 0;

	//Read MAP Files
	dwRet = ReadMapFile(L"index.map", aBTreeMap, aBTreeFreeList);
	if (dwRet)
	{
		printf("Failed to retrieve index.map details.  Please run from within the repository\\fs directory\n");
		return;
	}

	GetMapUsageCount(aBTreeMap, dwBTreeUsed, dwBTreeFree);

	dwRet = ReadMapFile(L"objects.map", aHeapMap, aHeapFreeList);
	if (dwRet)
	{
		printf("Failed to retrieve objects.map details.  Please run from within the repository\\fs directory\n");
		return;
	}
	
	GetMapUsageCount(aHeapMap, dwHeapUsed, dwHeapFree);

	WIN32_FILE_ATTRIBUTE_DATA fileInfo;
	dwRet = GetFileAttributesEx(L"INDEX.BTR", GetFileExInfoStandard, &fileInfo);
	if (dwRet == 0)
	{
		printf("Failed to retrieve size of index.btr file\n");
		return;
	}
	dwBTreeSize = fileInfo.nFileSizeLow / WMIREP_PAGE_SIZE;

	dwRet = GetFileAttributesEx(L"OBJECTS.DATA", GetFileExInfoStandard, &fileInfo);
	if (dwRet == 0)
	{
		printf("Failed to retrieve size of objects.data file\n");
		return;
	}
	dwHeapSize = fileInfo.nFileSizeLow / WMIREP_PAGE_SIZE;

	//Dump MAP file usage and free space sumary
	printf("BTree has %lu pages in it, of which %lu pages are in use and %lu pages are free\n", 
		dwBTreeSize, dwBTreeUsed, dwBTreeSize - dwBTreeUsed);
	printf("Heap  has %lu pages in it, of which %lu pages are in use and %lu pages are free\n", 
		dwHeapSize, dwHeapUsed, dwHeapSize - dwHeapUsed);

	//Get number of managed pages for heap...
	DWORD dwNumAdminPages = 0;
	DWORD dwNumMultiBlockPages = 0;
	DWORD dwNumMultiBlockObjects = 0;
	dwRet = GetHeapManagedPageCount(L"OBJECTS.DATA", aHeapMap, dwNumAdminPages, dwNumMultiBlockPages, dwNumMultiBlockObjects);
	if (dwRet)
	{
		printf("Failed to retrieve number of pages used in object heap\n");
		return;
	}

	printf("Heap has %lu admin pages, \n\t%lu pages used for small block allocation, total of %lu small block allocations, \n\t%lu pages for large block allocations\n", 
		dwNumAdminPages, 
		dwNumMultiBlockPages,
		dwNumMultiBlockObjects, 
		dwHeapSize - (dwHeapSize - dwHeapUsed) - dwNumAdminPages - dwNumMultiBlockPages);

	if (bDumpHeapAdminPage)
	{
		dwRet = DumpHeapAdminPages(L"OBJECTS.DATA", aHeapMap, aHeapFreeList);
		if (dwRet)
		{
			printf("Failed to dump the admin pages in the heap\n");
			return;
		}
	}

	if (bDumpTreeMap)
	{
		printf("**** BTree MAP Usage ****\n");
		DumpMap(aBTreeMap);
	}

	if (bDumpHeapMap)
	{
		printf("**** Heap MAP Usage ****\n");
		DumpMap(aHeapMap);
	}

}

DWORD ReadMapFile(const wchar_t *sFilename, XFilesMap &aPageMap,XFilesMap & aPhysFreeList)
{
    BOOL bRes;

    HANDLE hFile = CreateFileW(sFilename, GENERIC_READ | GENERIC_WRITE, FILE_SHARE_READ, 0, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, 0);

    if (hFile == INVALID_HANDLE_VALUE)
    {
		DWORD dwRet = GetLastError();
        return dwRet;
    }

    AutoClose _(hFile);

    // If here, read it.
    // =================

    DWORD dwSignature = 0;
    DWORD dwRead = 0;

    bRes = ReadFile(hFile, &dwSignature, sizeof(DWORD), &dwRead, 0);
    if (!bRes || dwRead != sizeof(DWORD) || dwSignature != MAP_LEADING_SIGNATURE)
    {
        return ERROR_INVALID_DATA;
    }

    // Read transaction version.
    // =========================

	DWORD dwTransVersion;
    bRes = ReadFile(hFile, &dwTransVersion, sizeof(DWORD), &dwRead, 0);
    if (!bRes || dwRead != sizeof(DWORD))
    {
        return ERROR_INVALID_DATA;
    }

    // Read in physical page count.
    // ============================
	DWORD dwPhysPages;
    bRes = ReadFile(hFile, &dwPhysPages, sizeof(DWORD), &dwRead, 0);
    if (!bRes || dwRead != sizeof(DWORD))
    {
        return ERROR_INVALID_DATA;
    }

    // Read in the page map length and page map.
    // =========================================

    DWORD dwNumPages = 0;
    bRes = ReadFile(hFile, &dwNumPages, sizeof(DWORD), &dwRead, 0);
    if (!bRes || dwRead != sizeof(DWORD))
    {
        return ERROR_INVALID_DATA;
    }

    try
    {
        aPageMap.resize(dwNumPages);
    }
    catch (CX_MemoryException &)
    {
        return ERROR_OUTOFMEMORY;
    }

    bRes = ReadFile(hFile, &aPageMap[0], sizeof(DWORD)*dwNumPages, &dwRead, 0);
    if (!bRes || dwRead != sizeof(DWORD)*dwNumPages)
        return ERROR_INVALID_DATA;

    // Now, read in the physical free list.
    // ====================================

    DWORD dwFreeListSize = 0;
    bRes = ReadFile(hFile, &dwFreeListSize, sizeof(DWORD), &dwRead, 0);
    if (!bRes || dwRead != sizeof(DWORD))
    {
        return ERROR_INVALID_DATA;
    }

    try
    {
        aPhysFreeList.resize(dwFreeListSize);
    }
    catch (CX_MemoryException &)
    {
        return ERROR_OUTOFMEMORY;
    }

    bRes = ReadFile(hFile, &aPhysFreeList[0], sizeof(DWORD)*dwFreeListSize, &dwRead, 0);
    if (!bRes || dwRead != sizeof(DWORD)*dwFreeListSize)
    {
        return ERROR_INVALID_DATA;
    }

    // Read trailing signature.
    // ========================

    bRes = ReadFile(hFile, &dwSignature, sizeof(DWORD), &dwRead, 0);
    if (!bRes || dwRead != sizeof(DWORD) || dwSignature != MAP_TRAILING_SIGNATURE)
    {
        return ERROR_INVALID_DATA;
    }

    return ERROR_SUCCESS;
}

DWORD DumpHeapAdminPages(const wchar_t *sFilename, XFilesMap &aHeapMap, XFilesMap &aHeapFreeList)
{
	//Open the file...
	HANDLE hFile = CreateFile(sFilename, GENERIC_READ, FILE_SHARE_WRITE|FILE_SHARE_READ, NULL, OPEN_EXISTING, 0,NULL);
	if (hFile == INVALID_HANDLE_VALUE)
		return GetLastError();

    HANDLE hMapping = CreateFileMapping(hFile, NULL, PAGE_READONLY, 0, 0, NULL);
	if (hMapping == NULL)
	{
		DWORD dwErr = GetLastError();
		CloseHandle(hFile);
		return dwErr;
	}

    BYTE *pObj = (BYTE *)MapViewOfFile(hMapping, FILE_MAP_READ, 0,0,0);
	if (pObj == NULL)
	{
		DWORD dwErr = GetLastError();
		CloseHandle(hMapping);
		CloseHandle(hFile);
		return dwErr;;
	}

	//Do stuff...
	DWORD dwVirtualPageId = 0;
	DWORD dwTotalObjectCount = 0;

	printf("Heap admin page dump...\n");
	do
	{
		DWORD dwPhysicalPageId = aHeapMap[dwVirtualPageId];
		VarObjHeapAdminPage *pAdminPageHeader = (VarObjHeapAdminPage *)(pObj + (dwPhysicalPageId * WMIREP_PAGE_SIZE));
		VarObjHeapFreeList *pAdminPageEntry = (VarObjHeapFreeList *)((BYTE*)pAdminPageHeader + sizeof(VarObjHeapAdminPage));

		printf("Admin page %lu (physical page %lu):  number of page entries %lu\n", dwVirtualPageId, dwPhysicalPageId, pAdminPageHeader->dwNumberEntriesOnPage);

		for (DWORD dwIndex = 0; dwIndex != pAdminPageHeader->dwNumberEntriesOnPage; dwIndex++)
		{
			DWORD dwNumObjectsOnPage = 0;
			VarObjObjOffsetEntry *pObjPage = (VarObjObjOffsetEntry*)(pObj + (aHeapMap[pAdminPageEntry[dwIndex].dwPageId] * WMIREP_PAGE_SIZE));
			for (DWORD dwIndex2 = 0; pObjPage[dwIndex2].dwOffsetId != 0; dwIndex2++)
			{
				dwNumObjectsOnPage++;
			}
			printf("\tPage % 6lu (physical page % 6lu): %4lu bytes free (% 2lu%%), %4lu objects on page\n", 
				pAdminPageEntry[dwIndex].dwPageId, 
				aHeapMap[pAdminPageEntry[dwIndex].dwPageId], 
				pAdminPageEntry[dwIndex].dwFreeSpace, 
				(pAdminPageEntry[dwIndex].dwFreeSpace * 100) / WMIREP_PAGE_SIZE,
				dwNumObjectsOnPage);
		}

		dwVirtualPageId = pAdminPageHeader->dwNextAdminPage;
	} while (dwVirtualPageId != 0);

	//Tidy up
	UnmapViewOfFile(pObj);
	CloseHandle(hMapping);
	CloseHandle(hFile);

	return ERROR_SUCCESS;

}

DWORD GetHeapManagedPageCount(const wchar_t *sFilename, XFilesMap &aHeapMap, DWORD &dwNumAdminPages, DWORD &dwNumMultiBlockPages, DWORD &dwNumMultiBlockObjects)
{
	//Open the file...
	HANDLE hFile = CreateFile(sFilename, GENERIC_READ, FILE_SHARE_WRITE|FILE_SHARE_READ, NULL, OPEN_EXISTING, 0,NULL);
	if (hFile == INVALID_HANDLE_VALUE)
		return GetLastError();

    HANDLE hMapping = CreateFileMapping(hFile, NULL, PAGE_READONLY, 0, 0, NULL);
	if (hMapping == NULL)
	{
		DWORD dwErr = GetLastError();
		CloseHandle(hFile);
		return dwErr;
	}

    BYTE *pObj = (BYTE *)MapViewOfFile(hMapping, FILE_MAP_READ, 0,0,0);
	if (pObj == NULL)
	{
		DWORD dwErr = GetLastError();
		CloseHandle(hMapping);
		CloseHandle(hFile);
		return dwErr;;
	}

	//Do stuff...
	DWORD dwVirtualPageId = 0;

	do
	{
		dwNumAdminPages++;
		DWORD dwPhysicalPageId = aHeapMap[dwVirtualPageId];
		VarObjHeapAdminPage *pAdminPageHeader = (VarObjHeapAdminPage *)(pObj + (dwPhysicalPageId * WMIREP_PAGE_SIZE));
		VarObjHeapFreeList *pAdminPageEntry = (VarObjHeapFreeList *)((BYTE*)pAdminPageHeader + sizeof(VarObjHeapAdminPage));

		for (DWORD dwIndex = 0; dwIndex != pAdminPageHeader->dwNumberEntriesOnPage; dwIndex++)
		{
			dwNumMultiBlockPages++;
			DWORD dwNumObjectsOnPage = 0;
			VarObjObjOffsetEntry *pObjPage = (VarObjObjOffsetEntry*)(pObj + (aHeapMap[pAdminPageEntry[dwIndex].dwPageId] * WMIREP_PAGE_SIZE));
			for (DWORD dwIndex2 = 0; pObjPage[dwIndex2].dwOffsetId != 0; dwIndex2++)
			{
				dwNumMultiBlockObjects++;
			}
		}

		dwVirtualPageId = pAdminPageHeader->dwNextAdminPage;
	} while (dwVirtualPageId != 0);

	//Tidy up
	UnmapViewOfFile(pObj);
	CloseHandle(hMapping);
	CloseHandle(hFile);

	return ERROR_SUCCESS;

}
DWORD GetMapUsageCount(XFilesMap &aMap, DWORD &dwMapUsed, DWORD &dwMapFree)
{
    for (DWORD i = 0; i < aMap.size(); i++)
    {
        if (aMap[i] == WMIREP_INVALID_PAGE)
            dwMapFree++;
		else
			dwMapUsed++;
    }
	return ERROR_SUCCESS;
}

void ShellSort(XFilesMap &Array)
{
    for (int nInterval = 1; nInterval < Array.size() / 9; nInterval = nInterval * 3 + 1);

    while (nInterval)
    {
        for (int iCursor = nInterval; iCursor < Array.size(); iCursor++)
        {
            int iBackscan = iCursor;
            while (iBackscan - nInterval >= 0 && Array[iBackscan] < Array[iBackscan-nInterval])
            {
                DWORD dwTemp = Array[iBackscan-nInterval];
                Array[iBackscan-nInterval] = Array[iBackscan];
                Array[iBackscan] = dwTemp;
                iBackscan -= nInterval;
            }
        }
        nInterval /= 3;
    }
}


DWORD DumpMap(XFilesMap &aMap)
{
	//Need to sort it... and need our own copy...
	XFilesMap aNewMap = aMap;
	ShellSort(aNewMap);

	printf("**** Usage dump... **** \n");
	DWORD dwStartId = aNewMap[0];
	for (DWORD dwOffset = 1, dwCurrentRun = 1; dwOffset != aNewMap.size(); dwOffset++, dwCurrentRun++)
	{
		if (dwStartId == 0xFFFFFFFF)
			break;
		if ((dwStartId+dwCurrentRun) != aNewMap[dwOffset])
		{
			//Finished slot... dump usage use
			if (dwStartId == aNewMap[dwOffset-1])
			{
				//Single location slot...
				printf("% 6lu          Used\n", dwStartId);
			}
			else
			{
				//Multiple location slot...
				printf("% 6lu - % 6lu Used\n", dwStartId, aNewMap[dwOffset-1]);
			}

			//Dump free space usage now
			if (aNewMap[dwOffset-1]+1 == aNewMap[dwOffset]-1)
			{
				//Single location slot...
				printf("% 6lu          Free\n", aNewMap[dwOffset-1]+1);
			}
			else
			{
				//Multiple location slot...
				printf("% 6lu - % 6lu Free\n", aNewMap[dwOffset-1]+1, aNewMap[dwOffset]-1);
			}
			dwStartId = aNewMap[dwOffset];
			dwCurrentRun = 0;
		}
	}

	return ERROR_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\xmltransport\client\helpersources\makefile.inc ===
############################################################################
#
#   Copyright (C) 1999, Microsoft Corporation.
#
#   All rights reserved.
#
############################################################################

!INCLUDE $(_NTDRIVE)$(_NTROOT)\WMI\COMMON\makefile.cmn
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\xmltransport\client\helpersources\getclasspacket.cpp ===
// GetClassPacket.cpp: implementation of the CGetClassPacket class.
//
//////////////////////////////////////////////////////////////////////

#include "XMLTransportClientHelper.h"
#include "XMLClientPacket.h"
#include "GetClassPacket.h"


//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CGetClassPacket::CGetClassPacket(const WCHAR *pwszObjPath,const WCHAR *pwszNameSpace)
	: CXMLClientPacket(pwszObjPath,pwszNameSpace,L"GetClass")
{
	m_ePathstyle = NOVAPATH; //assume nova path if this ctor is called.
}

//////////////////////////////////////////////////////////////////////
// Member functions
//////////////////////////////////////////////////////////////////////

HRESULT CGetClassPacket::GetBody(WCHAR **ppwszBody,DWORD *pdwLengthofPacket)
{
	if(NULL == ppwszBody)
		return E_INVALIDARG;

	HRESULT hr = S_OK;

	IStream *pStream = NULL;
	if(SUCCEEDED(hr = GetBodyTillLocalNamespacePathInStream(&pStream)))
	{
		WRITETOSTREAM(pStream, L"<IPARAMVALUE NAME=\"ClassName\"><CLASSNAME NAME=\"");
		if(NULL != m_pwszObjPath)
			WRITETOSTREAM(pStream, m_pwszObjPath);
		WRITETOSTREAM(pStream, L"\"/>");
		WRITETOSTREAM(pStream, L"</IPARAMVALUE>");
		WRITETOSTREAM(pStream, L"<IPARAMVALUE NAME=\"LocalOnly\"><VALUE>");
		WRITETOSTREAM(pStream, m_pwszLocalOnly);
		WRITETOSTREAM(pStream, L"</VALUE></IPARAMVALUE>");
		WRITETOSTREAM(pStream, L"<IPARAMVALUE NAME=\"IncludeQualifiers\"><VALUE>");
		WRITETOSTREAM(pStream, m_pwszIncludeQualifier);
		WRITETOSTREAM(pStream, L"</VALUE></IPARAMVALUE>");
		WRITETOSTREAM(pStream, L"</IMETHODCALL></SIMPLEREQ></MESSAGE></CIM>");

		hr = GetWStringFromStream(pStream,ppwszBody,pdwLengthofPacket);
		pStream->Release();	
	}

	return hr;
}

HRESULT CGetClassPacket::GetBodyDirect(const WCHAR *pwszXMLObjPath, 
									   DWORD dwLengthofObjPath, 
									   WCHAR **ppwszBody,
									   DWORD *pdwLengthofPacket)
{
	if(NULL == ppwszBody)
		return E_INVALIDARG;

	HRESULT hr = S_OK;

	IStream *pStream = NULL;
	if(SUCCEEDED(hr = GetBodyTillLocalNamespacePathInStream(&pStream)))
	{
		WRITETOSTREAM(pStream, L"<IPARAMVALUE NAME=\"ClassName\">");
		WRITETOSTREAM(pStream, pwszXMLObjPath);
		WRITETOSTREAM(pStream, L"</IPARAMVALUE>");
		WRITETOSTREAM(pStream, L"<IPARAMVALUE NAME=\"LocalOnly\"><VALUE>");
		WRITETOSTREAM(pStream, m_pwszLocalOnly);
		WRITETOSTREAM(pStream, L"</VALUE></IPARAMVALUE>");
		WRITETOSTREAM(pStream, L"<IPARAMVALUE NAME=\"IncludeQualifiers\"><VALUE>");
		WRITETOSTREAM(pStream, m_pwszIncludeQualifier);
		WRITETOSTREAM(pStream, L"</VALUE></IPARAMVALUE>");
		WRITETOSTREAM(pStream, L"</IMETHODCALL></SIMPLEREQ></MESSAGE></CIM>");

		hr = GetWStringFromStream(pStream,ppwszBody,pdwLengthofPacket);
		pStream->Release();	
	}

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\xmltransport\client\helpersources\executeinstancemethodpacket.cpp ===
// ExecuteInstanceMethodPacket.cpp: implementation of the CExecuteInstanceMethodPacket class.
//
//////////////////////////////////////////////////////////////////////

#include "XMLTransportClientHelper.h"
#include "XMLClientPacket.h"
#include "ExecuteInstanceMethodPacket.h"


//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CExecuteInstanceMethodPacket::CExecuteInstanceMethodPacket(const WCHAR *pwszObjPath,const WCHAR *pwszNameSpace):
CXMLClientPacket(pwszObjPath,pwszNameSpace,NULL)
{
	m_ePathstyle = NOVAPATH; //assume nova path if this ctor is called.
}

//////////////////////////////////////////////////////////////////////
// Member functions
//////////////////////////////////////////////////////////////////////

HRESULT CExecuteInstanceMethodPacket::GetBody(WCHAR **ppwszBody,DWORD *pdwLengthofPacket)
{
	if((NULL == ppwszBody)||(NULL == m_pwszObjPath))
		return E_INVALIDARG;


	HRESULT hr = S_OK;

	IStream *pStream = NULL;
	if(SUCCEEDED(hr = CreateStreamOnHGlobal(NULL,TRUE,&pStream)))
	{
		WRITETOSTREAM(pStream,L"<?xml version=\"1.0\" encoding=\"utf-8\" ?>");
		WRITETOSTREAM(pStream,L"<CIM CIMVERSION=\"2.0\" DTDVERSION=\"2.0\">");
		WRITETOSTREAM(pStream,L"<MESSAGE ID=\"");
		
		WCHAR pTemp[5];
		pTemp[4] = NULL;
		UINT uMsgID = 0;
		Get4DigitRandom(&uMsgID);
		wsprintf(pTemp,L"%04d", uMsgID);

		WRITETOSTREAM(pStream,pTemp);
		WRITETOSTREAM(pStream,L"\" PROTOCOLVERSION=\"1.0\">");
		WRITETOSTREAM(pStream,L"<SIMPLEREQ>");
		WRITETOSTREAM(pStream,L"<METHODCALL NAME=\"");
		WRITETOSTREAM(pStream,m_pwszCimOperation);
		WRITETOSTREAM(pStream,L"\">");
		WRITETOSTREAM(pStream,L"<LOCALINSTANCEPATH>");
		WRITETOSTREAM(pStream,L"<LOCALNAMESPACEPATH>");
		if(SUCCEEDED(GetXMLNamespaceInStream(pStream)))
		{
			WRITETOSTREAM(pStream,L"</LOCALNAMESPACEPATH>");
			if(SUCCEEDED(hr))
			{
				if(SUCCEEDED(hr = GetKeyBindingsInStream(pStream)))
				{
					WRITETOSTREAM(pStream,L"</LOCALINSTANCEPATH>");
					if(SUCCEEDED(hr = GetParamsFromObjectInStream(pStream)))
					{
						WRITETOSTREAM(pStream,L"</METHODCALL></SIMPLEREQ></MESSAGE></CIM>");
						hr = GetWStringFromStream(pStream,ppwszBody,pdwLengthofPacket);
					}
				}
			}
		}
		pStream->Release();
	}

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\xmltransport\client\helpersources\modifyclasspacket.cpp ===
// CModifyClassPacket.cpp: implementation of the CModifyClassPacket class.
//
//////////////////////////////////////////////////////////////////////

#include "XMLTransportClientHelper.h"
#include "XMLClientPacket.h"
#include "ModifyClassPacket.h"


//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CModifyClassPacket::CModifyClassPacket(const WCHAR *pwszObjPath,const WCHAR *pwszNameSpace):
CXMLClientPacket(pwszObjPath,pwszNameSpace,L"ModifyClass")
{
	m_ePathstyle = NOVAPATH; //assume nova path if this ctor is called.
}

//////////////////////////////////////////////////////////////////////
// Member functions
//////////////////////////////////////////////////////////////////////

HRESULT CModifyClassPacket::GetBody(WCHAR **ppwszBody,DWORD *pdwLengthofPacket)
{
	if(NULL == m_pWbemClassObject || m_ePathstyle == WHISTLERPATH)
		return E_INVALIDARG;

	HRESULT hr = S_OK;
	
	IStream *pStream = NULL;
	if(SUCCEEDED(hr = GetBodyTillLocalNamespacePathInStream(&pStream)))
	{
		WRITETOSTREAM(pStream, L"<IPARAMVALUE NAME=\"lFlags\"><VALUE>");
		WCHAR pwszFlags[16];
		pwszFlags[15] = '\0';
		wsprintf(pwszFlags,L"%u",m_lFlags);
		WRITETOSTREAM(pStream, pwszFlags);
		WRITETOSTREAM(pStream, L"</VALUE></IPARAMVALUE>");

		WRITETOSTREAM(pStream, L"<IPARAMVALUE NAME=\"ModifiedClass\">");
		if(SUCCEEDED(hr = ConvertWbemObjectToXMLStream(pStream)))
		{
			WRITETOSTREAM(pStream, L"</IPARAMVALUE></IMETHODCALL></SIMPLEREQ></MESSAGE></CIM>");
			hr = GetWStringFromStream(pStream,ppwszBody,pdwLengthofPacket);
		}
		pStream->Release();
	}

	return hr;
}

HRESULT CModifyClassPacket::GetBodyDirect(const WCHAR *pwszXMLObj, DWORD dwLengthofObj, 
										  WCHAR **ppwszBody,
										  DWORD *pdwLengthofPacket)
{
	if(NULL == m_pWbemClassObject || m_ePathstyle == WHISTLERPATH)
		return E_INVALIDARG;

	HRESULT hr = S_OK;
	
	IStream *pStream = NULL;
	if(SUCCEEDED(hr = GetBodyTillLocalNamespacePathInStream(&pStream)))
	{
		WRITETOSTREAM(pStream, L"<IPARAMVALUE NAME=\"lFlags\"><VALUE>");
		WCHAR pwszFlags[16];
		pwszFlags[15] = '\0';
		wsprintf(pwszFlags,L"%u",m_lFlags);
		WRITETOSTREAM(pStream, pwszFlags);
		WRITETOSTREAM(pStream, L"</VALUE></IPARAMVALUE>");

		WRITETOSTREAM(pStream, L"<IPARAMVALUE NAME=\"ModifiedClass\">");
		if(SUCCEEDED(hr = pStream->Write(pwszXMLObj, dwLengthofObj*sizeof(WCHAR), NULL)))
		{
			WRITETOSTREAM(pStream, L"</IPARAMVALUE></IMETHODCALL></SIMPLEREQ></MESSAGE></CIM>");
			hr = GetWStringFromStream(pStream,ppwszBody,pdwLengthofPacket);
		}
		pStream->Release();
	}
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\xmltransport\client\helpersources\getinstancepacket.cpp ===
// GetInstancePacket.cpp: implementation of the CGetInstancePacket class.
//
//////////////////////////////////////////////////////////////////////

#include "XMLTransportClientHelper.h"
#include "XMLClientPacket.h"
#include "GetInstancePacket.h"
#include "genlex.h"
#include "opathlex.h"
#include "objpath.h"

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CGetInstancePacket::CGetInstancePacket(const WCHAR *pwszObjPath,const WCHAR *pwszNameSpace):
CXMLClientPacket(pwszObjPath,pwszNameSpace,L"GetInstance")
{
	m_ePathstyle = NOVAPATH; //assume nova path if this ctor is called.
}


HRESULT CGetInstancePacket::GetBody(WCHAR **ppwszBody,DWORD *pdwLengthofPacket)
{
	if(NULL == ppwszBody || m_ePathstyle == WHISTLERPATH)
		return E_INVALIDARG;


	HRESULT hr = S_OK;

	IStream *pStream = NULL;
	if(SUCCEEDED(hr = GetBodyTillLocalNamespacePathInStream(&pStream)))
	{
		WRITETOSTREAM(pStream, L"<IPARAMVALUE NAME=\"InstanceName\">");
		if(SUCCEEDED(hr = GetKeyBindingsInStream(pStream)))
		{
			WRITETOSTREAM(pStream, L"</IPARAMVALUE>");
			WRITETOSTREAM(pStream, L"<IPARAMVALUE NAME=\"LocalOnly\"><VALUE>");
			WRITETOSTREAM(pStream, m_pwszLocalOnly);
			WRITETOSTREAM(pStream, L"</VALUE></IPARAMVALUE>");
			WRITETOSTREAM(pStream, L"<IPARAMVALUE NAME=\"IncludeQualifiers\"><VALUE>");
			WRITETOSTREAM(pStream, m_pwszIncludeQualifier);
			WRITETOSTREAM(pStream, L"</VALUE></IPARAMVALUE>");
			WRITETOSTREAM(pStream, L"</IMETHODCALL></SIMPLEREQ></MESSAGE></CIM>");

			hr = GetWStringFromStream(pStream,ppwszBody,pdwLengthofPacket);
		}
		pStream->Release();	
	}

	return hr;
}

HRESULT CGetInstancePacket::GetBodyDirect(const WCHAR *pwszXMLObjPath,
										  DWORD dwLengthofObjPath,
										  WCHAR **ppwszBody,
										  DWORD *pdwLengthofPacket)
{
	//pwszXMLObjPath MUST contain string of format 
	//<!ELEMENT INSTANCENAME (KEYBINDING*|KEYVALUE?|VALUE.REFERENCE?)>
	//<!ATTLIST INSTANCENAME %ClassName>
	//NOTE: This is a low level API. the XML string passed is NOT checked for syntactic correctness.
	
	if(NULL == ppwszBody || m_ePathstyle == WHISTLERPATH)
		return E_INVALIDARG;

	HRESULT hr = S_OK;

	IStream *pStream = NULL;
	if(SUCCEEDED(hr = GetBodyTillLocalNamespacePathInStream(&pStream)))
	{
		WRITETOSTREAM(pStream, L"<IPARAMVALUE NAME=\"InstanceName\">");
		WRITETOSTREAM(pStream, pwszXMLObjPath);
		WRITETOSTREAM(pStream, L"</IPARAMVALUE>");
		WRITETOSTREAM(pStream, L"<IPARAMVALUE NAME=\"LocalOnly\"><VALUE>");
		WRITETOSTREAM(pStream, m_pwszLocalOnly);
		WRITETOSTREAM(pStream, L"</VALUE></IPARAMVALUE>");
		WRITETOSTREAM(pStream, L"<IPARAMVALUE NAME=\"IncludeQualifiers\"><VALUE>");
		WRITETOSTREAM(pStream, m_pwszIncludeQualifier);
		WRITETOSTREAM(pStream, L"</VALUE></IPARAMVALUE>");
		WRITETOSTREAM(pStream, L"</IMETHODCALL></SIMPLEREQ></MESSAGE></CIM>");

		hr = GetWStringFromStream(pStream,ppwszBody,pdwLengthofPacket);
		pStream->Release();	
	}

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\xmltransport\client\helpersources\modifyinstancepacket.cpp ===
// ModifyInstancePacket.cpp: implementation of the CModifyInstancePacket class.
//
//////////////////////////////////////////////////////////////////////

#include "XMLTransportClientHelper.h"
#include "XMLClientPacket.h"
#include "ModifyInstancePacket.h"


//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CModifyInstancePacket::CModifyInstancePacket(const WCHAR *pwszObjPath, const WCHAR *pwszNameSpace)
	: CXMLClientPacket(pwszObjPath, pwszNameSpace, L"ModifyInstance")
{
	m_ePathstyle = NOVAPATH; //assume nova path if this ctor is called.
}

//////////////////////////////////////////////////////////////////////
// Member functions
//////////////////////////////////////////////////////////////////////

HRESULT CModifyInstancePacket::GetBody(WCHAR **ppwszBody, DWORD *pdwLengthofPacket)
{
	if(NULL == m_pWbemClassObject || m_ePathstyle == WHISTLERPATH)
		return E_INVALIDARG;

	HRESULT hr = S_OK;
	
	IStream *pStream = NULL;
	if(SUCCEEDED(hr = GetBodyTillLocalNamespacePathInStream(&pStream)))
	{
		WRITETOSTREAM(pStream, L"<IPARAMVALUE NAME=\"lFlags\"><VALUE>");
		WCHAR pwszFlags[16];
		pwszFlags[15] = '\0';
		wsprintf(pwszFlags,L"%u",m_lFlags);
		WRITETOSTREAM(pStream, pwszFlags);
		WRITETOSTREAM(pStream, L"</VALUE></IPARAMVALUE>");

		// This is a VALUE.NAMEDINSTANCE
		WRITETOSTREAM(pStream, L"<IPARAMVALUE NAME=\"ModifiedInstance\">")
		WRITETOSTREAM(pStream, L"<VALUE.NAMEDINSTANCE>");
		if(SUCCEEDED(hr = GetKeyBindingsInStream(pStream)))
		{
			if(SUCCEEDED(hr = ConvertWbemObjectToXMLStream(pStream)))
			{
				WRITETOSTREAM(pStream, L"</VALUE.NAMEDINSTANCE>");
				WRITETOSTREAM(pStream, L"</IPARAMVALUE></IMETHODCALL></SIMPLEREQ></MESSAGE></CIM>");
				hr = GetWStringFromStream(pStream,ppwszBody,pdwLengthofPacket);
			}
		}
		pStream->Release();
	}

	return hr;
}

// This assumes that pwszXMLObj contains a valid VALUE.NAMEDINSTANCE element
HRESULT CModifyInstancePacket::GetBodyDirect(const WCHAR *pwszXMLObj,
											 DWORD dwLengthofObj,
											 WCHAR **ppwszBody,
											 DWORD *pdwLengthofPacket)
{
	if(NULL == m_pWbemClassObject || m_ePathstyle == WHISTLERPATH)
		return E_INVALIDARG;

	HRESULT hr = S_OK;
	
	IStream *pStream = NULL;
	if(SUCCEEDED(hr = GetBodyTillLocalNamespacePathInStream(&pStream)))
	{
		WRITETOSTREAM(pStream, L"<IPARAMVALUE NAME=\"lFlags\"><VALUE>");
		WCHAR pwszFlags[16];
		pwszFlags[15] = '\0';
		wsprintf(pwszFlags,L"%u",m_lFlags);
		WRITETOSTREAM(pStream, pwszFlags);
		WRITETOSTREAM(pStream, L"</VALUE></IPARAMVALUE>");

		WRITETOSTREAM(pStream, L"<IPARAMVALUE NAME=\"ModifiedInstance\">");
		pStream->Write(pwszXMLObj, dwLengthofObj*sizeof(WCHAR), NULL);
		WRITETOSTREAM(pStream, L"</IPARAMVALUE></IMETHODCALL></SIMPLEREQ></MESSAGE></CIM>");
		hr = GetWStringFromStream(pStream,ppwszBody,pdwLengthofPacket);
		pStream->Release();
	}

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\xmltransport\client\helpersources\mypendingstream.cpp ===
#include "XMLTransportClientHelper.h"
#include <windows.h>
#include <objbase.h>
#include "MyPendingStream.h"


// Amount of data read at a time from the underlying IStream
ULONG CMyPendingStream :: READ_CHUNK_SIZE = 2000;

CMyPendingStream::CMyPendingStream(IStream *pStream) : m_cRef(1)
{
	m_bReturnPending = FALSE;
	m_pStream = NULL;
	m_pStream = pStream;
	m_pStream->AddRef();
}

CMyPendingStream::~CMyPendingStream()
{
	m_pStream->Release();
}

HRESULT CMyPendingStream::QueryInterface(REFIID iid,void ** ppvObject)
{
	if(iid == IID_IUnknown)
	{
		*ppvObject = (IUnknown *)this;
		AddRef();
		return S_OK;
	}
	else
	{
		if(iid == IID_IStream)
		{
			*ppvObject = (IStream*)this;
			AddRef();
			return S_OK;
		}
	}

	return E_NOTIMPL;
}

ULONG CMyPendingStream::AddRef()
{
	return InterlockedIncrement(&m_cRef);
}

ULONG CMyPendingStream::Release()
{
	if(InterlockedDecrement(&m_cRef)==0)
		delete this;

	return m_cRef;
}


HRESULT CMyPendingStream::Read(void *pv,ULONG cb,ULONG *pcbRead)
{
	// If our state is "pending", no need to return any data
	if(m_bReturnPending)
		return E_PENDING;

	// Dont read as much data as asked by the caller.
	// Instead read our own size of chunks.

	return m_pStream->Read(pv, READ_CHUNK_SIZE, pcbRead);
}

HRESULT CMyPendingStream::Write(void const *pv,ULONG cb,ULONG *pcbWritten)
{
	return S_OK;
}

HRESULT CMyPendingStream::Seek(LARGE_INTEGER dlibMove,DWORD dwOrigin,ULARGE_INTEGER *plibNewPosition)
{
	return S_OK;
}

HRESULT CMyPendingStream::SetSize(ULARGE_INTEGER libNewSize)
{
	return S_OK;
}

HRESULT CMyPendingStream::CopyTo(IStream *pstm,ULARGE_INTEGER cb,ULARGE_INTEGER *pcbRead,ULARGE_INTEGER *pcbWritten)
{
	return S_OK;
}

HRESULT CMyPendingStream::Commit(DWORD grfCommitFlags)
{
	return S_OK;
}

HRESULT CMyPendingStream::Revert(void)
{
	return S_OK;
}
	
HRESULT CMyPendingStream::LockRegion(ULARGE_INTEGER libOffset,ULARGE_INTEGER cb,DWORD dwLockType)
{
	return S_OK;
}

HRESULT CMyPendingStream::UnlockRegion(ULARGE_INTEGER libOffset,ULARGE_INTEGER cb,DWORD dwLockType)
{
	return S_OK;
}

HRESULT CMyPendingStream::Stat(STATSTG *pstatstg,DWORD grfStatFlag)
{
	return S_OK;
}

HRESULT CMyPendingStream::Clone(IStream **ppstm)
{
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\xmltransport\client\helpersources\mystream.cpp ===
#include "XMLTransportClientHelper.h"
#include "MyStream.h"

CMyStream::CMyStream():m_cRef(1)
{
	m_hOpenRequest = NULL;
	m_hRoot = NULL;
}

CMyStream::~CMyStream()
{
	// No need to close m_hOpenRequest since closing of the root handle closes all the sub-handles
	if(m_hRoot)
		InternetCloseHandle(m_hRoot);
}

HRESULT CMyStream::Initialize(HINTERNET hRoot, HINTERNET hOpenRequest)
{
	// Just copy over the handlers. The WinInet API has no way to Duplicate handles
	m_hOpenRequest = hOpenRequest;
	m_hRoot = hRoot;
	return S_OK;
}

HRESULT CMyStream::QueryInterface(REFIID iid,void ** ppvObject)
{
	if(iid == IID_IUnknown)
	{
		*ppvObject = (IUnknown *)this;
		AddRef();
		return S_OK;
	}
	else
	{
		if(iid == IID_IStream)
		{
			*ppvObject = (IStream*)this;
			AddRef();
			return S_OK;
		}
	}

	return E_NOTIMPL;
}

ULONG CMyStream::AddRef()
{
	return InterlockedIncrement(&m_cRef);
}

ULONG CMyStream::Release()
{
	if(InterlockedDecrement(&m_cRef)==0)
		delete this;

	return m_cRef;
}


HRESULT CMyStream::Read(void *pv,ULONG cb,ULONG *pcbRead)
{
	
	BOOL bResult = InternetReadFile(m_hOpenRequest,pv,cb,pcbRead);

	return S_OK;

}

HRESULT CMyStream::Write(void const *pv,ULONG cb,ULONG *pcbWritten)
{
	return S_OK;
}

HRESULT CMyStream::Seek(LARGE_INTEGER dlibMove,DWORD dwOrigin,ULARGE_INTEGER *plibNewPosition)
{
	return S_OK;
}

HRESULT CMyStream::SetSize(ULARGE_INTEGER libNewSize)
{
	return S_OK;
}

HRESULT CMyStream::CopyTo(IStream *pstm,ULARGE_INTEGER cb,ULARGE_INTEGER *pcbRead,ULARGE_INTEGER *pcbWritten)
{
	return S_OK;
}

HRESULT CMyStream::Commit(DWORD grfCommitFlags)
{
	return S_OK;
}

HRESULT CMyStream::Revert(void)
{
	return S_OK;
}
	
HRESULT CMyStream::LockRegion(ULARGE_INTEGER libOffset,ULARGE_INTEGER cb,DWORD dwLockType)
{
	return S_OK;
}

HRESULT CMyStream::UnlockRegion(ULARGE_INTEGER libOffset,ULARGE_INTEGER cb,DWORD dwLockType)
{
	return S_OK;
}

HRESULT CMyStream::Stat(STATSTG *pstatstg,DWORD grfStatFlag)
{
	return S_OK;
}

HRESULT CMyStream::Clone(IStream **ppstm)
{
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\xmltransport\client\helpersources\httpconnectionagent.cpp ===
// HTTPConnectionAgent.cpp: implementation of the CHTTPConnectionAgent class.
//
//////////////////////////////////////////////////////////////////////

#include "XMLTransportClientHelper.h"

#include "WbemTran.h"

#include "MyStream.h"
#include "HTTPConnectionAgent.h"
#include "Utils.h"

//Initialize static s_pszAgent. to be used if no other agent names are 
//specified.
LPCWSTR CHTTPConnectionAgent::s_pszAgent = L"WMI XML-HTTP CLIENT";

//asking unlimited number of connections per server . by default it is 2 for an HTTP 1.1 server
const UINT CHTTPConnectionAgent::s_uConnectionsPerServer = -1;

// The list of types that we accept - RAJESHR is this really correct
LPCWSTR CHTTPConnectionAgent::pContentTypes[] =
	{
		L"application/xml",
		NULL
	};

//we will request for data in chunks of 4k - change if needed
const DWORD CHTTPConnectionAgent::DATASIZE = 4096;

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CHTTPConnectionAgent::CHTTPConnectionAgent()
{
	InitializeMembers();	 
}

CHTTPConnectionAgent::~CHTTPConnectionAgent()
{
	DestroyMembers();
}

HRESULT CHTTPConnectionAgent::InitializeConnection(const WCHAR * pszServerName,
							 const WCHAR * pszUserName,
							 const WCHAR * pszPasswd)
{
	HRESULT hr = S_OK;

	if(m_pCriticalSection = new CRITICAL_SECTION)
	{
		InitializeCriticalSection(m_pCriticalSection); //function doesnt return error value...

		if(SUCCEEDED(hr = AssignString(&m_pszUserName, pszUserName)))
		{
			if(SUCCEEDED(hr = AssignString(&m_pszPasswd, pszPasswd)))
			{
				if(SUCCEEDED(hr = SetServerName(pszServerName)))
				{
					if(m_hRoot = InternetOpen(s_pszAgent,
												m_dwAccessType,
												m_pszProxyName,
												m_pszProxyBypass,
												0))
					{
						SetupCredentials(); //NULL passwd cant be sent using InternetConnect !
						if(m_hConnect = InternetConnect(m_hRoot,m_pszServerName,m_nServerPort,
									m_pszUserName,m_pszPasswd,INTERNET_SERVICE_HTTP,0,0))
						{
							InternetSetOption(NULL,INTERNET_OPTION_MAX_CONNS_PER_SERVER,(LPVOID)&s_uConnectionsPerServer,
								sizeof(DWORD));
						}
						else
							hr = E_FAIL;
					}
					else
						hr = E_FAIL;
				}
			}
		}
	}
	else
		hr = E_OUTOFMEMORY;
	if(FAILED(hr))
		ResetMembers();
	return hr;
}

HRESULT CHTTPConnectionAgent::InitializeConnection(INTERNET_PORT nPort,
										   const WCHAR * pszServerName,
										   const WCHAR * pszUserName,
										   const WCHAR * pszPasswd,
										   DWORD dwAccessType, 
										   const WCHAR * pszProxyName,
										   const WCHAR * pszProxyBypass,
										   DWORD dwFlags)
{
	HRESULT hr = S_OK;
	m_dwAccessType = dwAccessType;
	m_dwFlags = dwFlags;
	m_nServerPort = nPort;
	//Use default port number specified by m_dwService member
	m_nServerPort = INTERNET_INVALID_PORT_NUMBER;

	if(SUCCEEDED(hr = AssignString(&m_pszProxyName,pszProxyName)))
	{
		if(SUCCEEDED(hr = AssignString(&m_pszProxyBypass,pszProxyBypass)))
		{
			if(m_pCriticalSection = new CRITICAL_SECTION)
			{
				InitializeCriticalSection(m_pCriticalSection); //function doesnt return error value...

				if(SUCCEEDED(hr = AssignString(&m_pszUserName,pszUserName)))
				{
					if(SUCCEEDED(hr = AssignString(&m_pszPasswd,pszPasswd)))
					{
						if(SUCCEEDED(hr = SetServerName(pszServerName)))
						{
							if(m_hRoot = InternetOpen(s_pszAgent,
														m_dwAccessType,
														m_pszProxyName,
														m_pszProxyBypass,
														0))
							{
								SetupCredentials(); //NULL passwd cant be sent using InternetConnect !
								if(m_hConnect = InternetConnect(m_hRoot,m_pszServerName,m_nServerPort,
											m_pszUserName,m_pszPasswd,INTERNET_SERVICE_HTTP,0,0))
								{
									InternetSetOption(NULL,INTERNET_OPTION_MAX_CONNS_PER_SERVER,(LPVOID)&s_uConnectionsPerServer,
										sizeof(DWORD));
								}
								else
									hr = E_FAIL;
							}
							else
								hr = E_FAIL;
						}
					}
				}
			}
			else
				hr = E_OUTOFMEMORY;
		}
	}

	if(FAILED(hr))
		ResetMembers();
	return hr;
}

void CHTTPConnectionAgent::ResetMembers()
{
	DestroyMembers();
	InitializeMembers();
}

void CHTTPConnectionAgent::DestroyMembers()
{
	if(m_bReleaseHandles)
		InternetCloseHandle(m_hRoot);

	FreeString(m_pszServerName);
	FreeString(m_pszProxyName);
	FreeString(m_pszProxyBypass);
	FreeString(m_pszUserName);
	FreeString(m_pszPasswd);
	FreeString(m_pszURI);

	delete m_pCriticalSection;
}

void CHTTPConnectionAgent::InitializeMembers()
{
	m_pszServerName = NULL;
	m_pszURI = NULL;
	m_pszUserName = NULL;
	m_pszPasswd = NULL;
	m_hRoot = NULL;
	m_hConnect = NULL; 
	m_hOpenRequest = NULL;
	m_bReleaseHandles = TRUE;

	//Default Access type. 
	//Can change using parametrized constructor or SetAccessType function
	m_dwAccessType = INTERNET_OPEN_TYPE_PRECONFIG;

	m_pszProxyName = NULL;
	m_pszProxyBypass = NULL;
	
	m_dwFlags = 0;
	m_pCriticalSection = NULL;


	//Use default port number specified by m_dwService member
	m_nServerPort = INTERNET_INVALID_PORT_NUMBER;

	
	/******************************************************************************
	If authentication is required, the INTERNET_FLAG_KEEP_CONNECTION flag should be
	used in the call to HttpOpenRequest. The INTERNET_FLAG_KEEP_CONNECTION flag is 
	required for NTLM and other types of authentication in order to maintain the 
	connection while completing the authentication process. If the connection is not 
	maintained, the authentication process must be restarted with the proxy or server. 
	*********************************************************************************/
	
	//flags are in draft state. experimenting with values
	m_dwFlags = INTERNET_FLAG_KEEP_CONNECTION|INTERNET_FLAG_NO_CACHE_WRITE;/*|INTERNET_FLAG_NEED_FILE*/

}


HRESULT CHTTPConnectionAgent::SetAccessType(DWORD dwAccessType)
{
	EnterCriticalSection(m_pCriticalSection);
	m_dwAccessType = dwAccessType;
	LeaveCriticalSection(m_pCriticalSection);
	return S_OK;
}

HRESULT CHTTPConnectionAgent::SetProxyInformation(WCHAR * szProxyName, WCHAR * szProxyBypass)
{
	
	HRESULT hr = S_OK;

	EnterCriticalSection(m_pCriticalSection);
	RESET(m_pszProxyName);
	RESET(m_pszProxyBypass);
	if(SUCCEEDED(hr = AssignString(&m_pszProxyName,szProxyName)))
		hr = AssignString(&m_pszProxyBypass,szProxyBypass);
	LeaveCriticalSection(m_pCriticalSection);

	return hr;
}

HRESULT CHTTPConnectionAgent::SetFlags(DWORD dwFlags)
{
	EnterCriticalSection(m_pCriticalSection);
	m_dwFlags = dwFlags;
	LeaveCriticalSection(m_pCriticalSection);
	return S_OK;
}

HRESULT CHTTPConnectionAgent::EnableSSL(bool bFlag)
{
	HRESULT hr = S_OK;

	EnterCriticalSection(m_pCriticalSection);
	if(bFlag)
	{
		//This value specifies to WinInet to use SSL (HTTPS)
		m_nServerPort = INTERNET_DEFAULT_HTTPS_PORT;
	}
	else
	{
		m_nServerPort = INTERNET_INVALID_PORT_NUMBER;
		hr = E_FAIL;
	}

	LeaveCriticalSection(m_pCriticalSection);
	return hr;
}

HRESULT CHTTPConnectionAgent::SetServerName(const WCHAR * pszServerName)
{
	HRESULT hr = S_OK;

	EnterCriticalSection(m_pCriticalSection);

	// We need a valid host name to open an internet connection
	if(NULL != pszServerName)
	{
		URL_COMPONENTS uc;

		// We only need the scheme, hostname, URI and port number
		WCHAR pwszScheme[MAX_PATH+1];
		WCHAR pwszHostName[MAX_PATH+1];
		WCHAR pwszUrlPath[MAX_PATH+1];

		uc.dwStructSize		= sizeof(URL_COMPONENTS); // Weird documentation
		uc.lpszScheme		= pwszScheme;
		uc.dwSchemeLength	= MAX_PATH;
		uc.lpszHostName		= pwszHostName;
		uc.dwHostNameLength	= MAX_PATH;
		uc.lpszUserName		= NULL;
		uc.dwUserNameLength	= 0;
		uc.lpszPassword		= NULL;
		uc.dwPasswordLength	= 0;
		uc.lpszUrlPath		= pwszUrlPath;
		uc.dwUrlPathLength	= MAX_PATH;
		uc.lpszExtraInfo	= NULL;
		uc.dwExtraInfoLength= 0;

		BOOL bResult = InternetCrackUrl(pszServerName, wcslen(pszServerName), ICU_DECODE, &uc);

		if(FALSE == bResult)
			hr = E_INVALIDARG;
		else
		{
			// Retain the hostname and URI and port
			RESET(m_pszServerName);
			RESET(m_pszURI);
			AssignString(&m_pszServerName, pwszHostName);
			AssignString(&m_pszURI, pwszUrlPath);
			m_nServerPort = uc.nPort;
			// Check whether we need SSL
			if(_wcsicmp(pwszScheme, L"https")==0)
				EnableSSL(true);
		}
	}
	else
		hr = E_INVALIDARG;

	LeaveCriticalSection(m_pCriticalSection);
	return hr;
}



HRESULT CHTTPConnectionAgent::Send(LPCWSTR pszVerb,
								   LPCWSTR pszHeader,
								   WCHAR * pszBody,
								   DWORD dwLength)
{
	HRESULT  hr = S_OK;

	EnterCriticalSection(m_pCriticalSection);

	if(NULL != m_hOpenRequest)
	{
		InternetCloseHandle(m_hOpenRequest);
		m_hOpenRequest = NULL;
	}

	if(IsSSLEnabled())
	{
		m_hOpenRequest = HttpOpenRequest(m_hConnect, pszVerb, m_pszURI,
										L"HTTP/1.1",
										NULL,pContentTypes,
										m_dwFlags|INTERNET_FLAG_SECURE|INTERNET_FLAG_IGNORE_CERT_CN_INVALID|INTERNET_FLAG_IGNORE_CERT_DATE_INVALID,
										0);
	}
	else
	{
		m_hOpenRequest = HttpOpenRequest(m_hConnect, pszVerb, m_pszURI,
				L"HTTP/1.1",
				NULL, pContentTypes,
				m_dwFlags,
				0);
	}
	

	BOOL bResult = FALSE;
	if( NULL != m_hOpenRequest)
	{
		LPSTR pszUTF8Body = NULL;
		DWORD dwBodyLength = 0;

		dwBodyLength = ConvertLPWSTRToUTF8(pszBody, dwLength, &pszUTF8Body);

		// We need to distinguish here between the actual body being NULL
		// and the failure of the ConvertLPWSTRToUTF8() call
		if(pszBody && dwBodyLength == 0)
		{
			// This means that the ConvertLPWSTRToUTF8 call failed
			LeaveCriticalSection(m_pCriticalSection);
			return E_FAIL;
		}

		bResult = HttpSendRequest(m_hOpenRequest, 
			pszHeader, (pszHeader)? wcslen(pszHeader): 0,
			(void*)pszUTF8Body, dwBodyLength);

			//RAJESHR need more study here. - resending if access denied was sent by server
			/*
			GetStatusCode(&dwStatusCode);

			if((dwStatusCode==401)||(dwStatusCode == 407)) 
			{
				bResult = Resend(pszUTF8Body,dwBodyLength,&dwStatusCode);
			}*/

		delete [] pszUTF8Body;
	}

	LeaveCriticalSection(m_pCriticalSection);

	if( bResult == FALSE )
		return E_FAIL;
	return hr;
}

HRESULT CHTTPConnectionAgent::GetResultHeader(WCHAR **ppszBuffer)
{
	return GetResultHeader(ppszBuffer,NULL);	
}


HRESULT CHTTPConnectionAgent::GetResultBodyWrappedAsIStream(IStream **ppStream)
{
	HRESULT hr = E_FAIL;

	if(NULL == ppStream)
		return E_INVALIDARG;

	EnterCriticalSection(m_pCriticalSection);

	*ppStream = NULL;
	if(*ppStream = new CMyStream())
	{
		if(SUCCEEDED(hr = ((CMyStream *)(*ppStream))->Initialize(m_hRoot, m_hOpenRequest)))
		{
			// This means that the WinInet handle should not be closed in the descrtuctor since
			// someone else (the CMyStream()) is holding on it. This is unfortunate since, WinInet handles
			// are not true NT handles, and hence we cant duplicate them.
			m_bReleaseHandles = FALSE;
		}
		else
		{
			delete *ppStream;
			*ppStream = NULL;
		}
	}
	else
		hr = E_OUTOFMEMORY;

	LeaveCriticalSection(m_pCriticalSection);

	return hr;
}

HRESULT CHTTPConnectionAgent::GetStatusCode(DWORD *pdwStatusCode)
{
	
	if( NULL == pdwStatusCode)
		return E_INVALIDARG;

	*pdwStatusCode = 0;

	HRESULT hr = S_OK;
	
	DWORD dwSize = sizeof(DWORD);
	
	BOOL bRet = HttpQueryInfo(m_hOpenRequest,HTTP_QUERY_STATUS_CODE|HTTP_QUERY_FLAG_NUMBER,
                   pdwStatusCode, &dwSize, NULL);

	if(!bRet)
		hr = E_FAIL;

	return hr;
}


bool CHTTPConnectionAgent::IsSSLEnabled()
{
	return(INTERNET_DEFAULT_HTTPS_PORT==m_nServerPort);
}


HRESULT CHTTPConnectionAgent::StriphttpFromServername(WCHAR **ppszServername)
{
	if((NULL == ppszServername)||(NULL == *ppszServername))
		return E_INVALIDARG;

	int iHttplen = wcslen(L"http://");

	if(_wcsnicmp(*ppszServername,L"http://",iHttplen) == 0)
	{
		
		WCHAR *pszTemp = new WCHAR[wcslen(*ppszServername)-iHttplen+1];
	
		if(NULL == pszTemp)
			return E_OUTOFMEMORY;

		wcscpy(pszTemp,*ppszServername + iHttplen);
		
		wcscpy(*ppszServername,pszTemp);

		delete [] pszTemp;
	}

	iHttplen = wcslen(L"https://");

	if(_wcsnicmp(*ppszServername,L"https://",iHttplen) == 0)
	{
		WCHAR *pszTemp = new WCHAR[wcslen(*ppszServername)-iHttplen+1];
	
		if(NULL == pszTemp)
			return E_OUTOFMEMORY;

		wcscpy(pszTemp,*ppszServername + iHttplen);
		
		wcscpy(*ppszServername,pszTemp);

		delete [] pszTemp;
	}


	return S_OK;
}

DWORD CHTTPConnectionAgent::GetFlags()
{
	return m_dwFlags;
}


HRESULT CHTTPConnectionAgent::GetResultBodyCompleteAsIStream(IStream **ppStream)
{
	if(NULL == ppStream)
		return E_INVALIDARG;
	
	HRESULT hr = S_OK;
	*ppStream = NULL;

	// Create a Stream
	if (SUCCEEDED(hr = CreateStreamOnHGlobal(NULL, TRUE, ppStream)))
	{
		ULARGE_INTEGER uSize;
		uSize.LowPart = DATASIZE;
		uSize.HighPart = 0;

		if(SUCCEEDED(hr = S_OK)) // (*ppStream)->SetSize(uSize)))
		{
			EnterCriticalSection(m_pCriticalSection);	

			//Find out if any info is available from server. 
			//Last two parameters to InternetQueryDataAvailable must be zero
			DWORD dwBufLen = 0;
			if (InternetQueryDataAvailable(m_hOpenRequest,&dwBufLen,0,0))
			{	
				BOOL bResult = FALSE;

				//Variable to keep track of how much data was read in this session.
				// And a buffer for reading chunks of data
				DWORD dwCurData=0;
				BYTE pData[DATASIZE];
				while(true)
				{
					//InternetReadFile doesnt return false when no data is available !
					//So , the loop has to check for dwDataRead as well for a terminating
					//condition. 
					dwCurData = 0;
					bResult = FALSE;

					bResult = InternetReadFile(m_hOpenRequest, (LPVOID)pData, DATASIZE, &dwCurData);
					if(bResult && dwCurData)
					{
						// Write the next chunk to the IStream
						if(FAILED(hr = (*ppStream)->Write(pData, dwCurData, NULL)))
							break;
					}
					else
						break;
				}
				
				LARGE_INTEGER	offset;
				offset.LowPart = offset.HighPart = 0;

				(*ppStream)->Seek(offset, STREAM_SEEK_SET, NULL);
			}
			else 
				hr = E_FAIL;

			LeaveCriticalSection(m_pCriticalSection);
		}
	}

	return hr;
}

HRESULT CHTTPConnectionAgent::GetResultHeader(WCHAR **ppszBuffer, DWORD *pdwHeaderLen)
{
	if( NULL == ppszBuffer)
		return E_INVALIDARG;

	HRESULT hr = S_OK;
	
	EnterCriticalSection(m_pCriticalSection);

	DWORD dwBufLen=0,dwNextHeader=0;
	
	BOOL bResult = HttpQueryInfo(m_hOpenRequest,HTTP_QUERY_RAW_HEADERS_CRLF,NULL,
		&dwBufLen,&dwNextHeader);

	if( bResult == FALSE) 
	{
		
		WCHAR* szResult = NULL;

		szResult = new WCHAR[dwBufLen +1];

		if( NULL == szResult)
		{
			LeaveCriticalSection(m_pCriticalSection);
			return E_OUTOFMEMORY;
		}

		bResult = HttpQueryInfo(m_hOpenRequest,HTTP_QUERY_RAW_HEADERS_CRLF,
			szResult,&dwBufLen,&dwNextHeader);

		if(bResult = FALSE)
			hr = E_FAIL;
		else
			*ppszBuffer = szResult;

	}

	if(NULL != pdwHeaderLen)
		*pdwHeaderLen = dwBufLen; //fill out param header length.

	LeaveCriticalSection(m_pCriticalSection);

	return hr;
}

/*
BOOL CHTTPConnectionAgent::Resend(char *pszUTF8Body,
								  DWORD dwBodyLength,DWORD *pdwStatusCode)
{
	
	SetupCredentials();

	BOOL bResult = TRUE;

	bResult = HttpSendRequest(m_hOpenRequest,m_pszHeader,wcslen(m_pszHeader),
								(void*)pszUTF8Body,dwBodyLength);

	GetStatusCode(pdwStatusCode);

	return bResult;
}
*/

void CHTTPConnectionAgent::SetupCredentials()
{
	UINT iPwdlen=0,iUsrlen=0;
			
	if(NULL != m_pszUserName)
		iUsrlen = wcslen(m_pszUserName);

	if(NULL != m_pszPasswd)
		iPwdlen = wcslen(m_pszPasswd);
	else
	{
		iPwdlen = 1;
		m_pszPasswd = new WCHAR[1];
		wcscpy(m_pszPasswd,L"");
	}

	InternetSetOption(m_hConnect,INTERNET_OPTION_USERNAME,m_pszUserName,iUsrlen);
	InternetSetOption(m_hConnect,INTERNET_OPTION_PASSWORD,m_pszPasswd,iPwdlen);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\xmltransport\client\helpersources\nodefact.cpp ===
#include "XMLTransportClientHelper.h"
#include <objsafe.h>
#include <assert.h>
#include <xmlparser.h>
#include "myPendingStream.h"
#include "nodefact.h"


MyFactory::MyFactory(CMyPendingStream *pStream)
{
	// Note that the Global(DLL) Object count is not incremented here
	// This is because, this is always an internal COM object and is never given out
	// Instead it always stays wrapped in some other COM object (typically IEnumWbemCLassObject)
	// and has the same lifetime as the outer object.

	m_cRef = 1;

	// Hold on to the input stream - this is the source of data for the IXMLParser
	// and we have to set its state to "pending" once an object is manufactures by us
	if(m_pStream = pStream)
		m_pStream->AddRef();

	m_ppDocuments = NULL;
	m_dwNumDocuments = m_dwMaxNumDocuments = m_dwAvailableDocIndex = 0;
	m_pCurrentDocument = NULL;
	m_pszElementNames = NULL;
	m_dwNumElements = 0;
}

MyFactory::~MyFactory()
{
	if(m_pStream)
		m_pStream->Release();

	// Release all the documents that were manufactured, but unused
	for(DWORD i=m_dwAvailableDocIndex; i<m_dwNumDocuments; i++)
		(m_ppDocuments[i])->Release();
	delete [] m_ppDocuments;

	if(m_pCurrentDocument)
		m_pCurrentDocument->Release();

	// Release all element names and the array
	for(DWORD i=0; i<m_dwNumElements; i++)
		delete [] m_pszElementNames[i];
	delete [] m_pszElementNames;
}

HRESULT MyFactory::SetElementNames(LPCWSTR *pszElementNames, DWORD dwNumElements)
{
	// Release all element names and the array
	for(DWORD i=0; i<m_dwNumElements; i++)
		delete [] m_pszElementNames[i];
	delete [] m_pszElementNames;
	m_pszElementNames = NULL;
	m_dwNumElements = 0;

	HRESULT hr = S_OK;

	// Copy over the new list of interesting element names
	if(m_pszElementNames = new WCHAR *[dwNumElements])
	{
		for(DWORD i=0; i<dwNumElements; i++)
		{
			m_pszElementNames[i] = NULL;
			if(m_pszElementNames[i] = new WCHAR[wcslen(pszElementNames[i]) + 1])
				wcscpy(m_pszElementNames[i], pszElementNames[i]);
			else
				break;
		}

		// Did all go well?
		if(i<dwNumElements)
		{
			// Release all element names and the array
			for(DWORD j=0; j<i; j++)
				delete [] m_pszElementNames[j];
			delete [] m_pszElementNames;
			m_pszElementNames = NULL;
			m_dwNumElements = 0;
			hr = E_OUTOFMEMORY;
		}
		else
			m_dwNumElements = dwNumElements;
	}
	else
		hr = E_OUTOFMEMORY;
	return hr;
}

HRESULT STDMETHODCALLTYPE MyFactory::BeginChildren(
        IXMLNodeSource* pSource,
        XML_NODE_INFO* pNodeInfo)
{
	HRESULT hr = S_OK;
	//fwprintf(stderr, L"BeginChildren() called for %s\n", pNodeInfo->pwcText);
	return hr;
}


HRESULT STDMETHODCALLTYPE MyFactory::EndChildren(
        IXMLNodeSource* pSource,
        BOOL fEmpty,
        XML_NODE_INFO* pNodeInfo)
{
	HRESULT hr = E_FAIL;

	// See if it is the kind of elements we are manufacturing
	if(IsInterestingElement(pNodeInfo->pwcText))
	{
		// Stop the stream from issuing any more data
		m_pStream->SetPending(TRUE);

		// Add the document to the list of documents that we have
		hr = AddDocumentToList(m_pCurrentDocument);

		// Reset the document that we work with
		// This is the one that is used to hold the object
		// that is currently being manufactured
		m_pCurrentDocument->Release();
		m_pCurrentDocument = NULL;
	}
	else
		hr = S_OK;

	//fwprintf(stderr, L"EndChildren() called for %s\n", pNodeInfo->pwcText);
	return hr;
}


HRESULT STDMETHODCALLTYPE MyFactory::Error(
        IXMLNodeSource* pSource,
        HRESULT hrErrorCode,
        USHORT cNumRecs,
        XML_NODE_INFO __RPC_FAR **aNodeInfo)
{
	BSTR strReason = NULL;
	ULONG uLine = 0 , uPosition = 0;

	pSource->GetErrorInfo(&strReason);
	uLine = pSource->GetLineNumber();
	uPosition = pSource->GetLinePosition();
	fwprintf(stderr, L"An Error occured at Line:%d, Position%d, Source:%s, Reason%X\n",
		uLine, uPosition, strReason, hrErrorCode);
	return S_OK;
}


HRESULT STDMETHODCALLTYPE MyFactory::CreateNode(
        IXMLNodeSource __RPC_FAR *pSource,
        PVOID pNodeParent,
        USHORT cNumRecs,
        XML_NODE_INFO __RPC_FAR **aNodeInfo)
{
	HRESULT hr = S_OK;

	if(cNumRecs)
	{
		//fwprintf(stderr, L"CreateNode() called for %s with %d elements\n", (*aNodeInfo)->pwcText), cNumRecs;

		// Here we look for XML Elements, non-markup data and for the pragma PI
		switch( (aNodeInfo[0])->dwType)
		{
			case XML_ELEMENT:
			{
				// If it is an interesting element - create a new XML DOM Document
				if(IsInterestingElement(aNodeInfo[0]->pwcText))
				{
					// Create a new document for the class or instance
					if(m_pCurrentDocument)
					{
						m_pCurrentDocument->Release();
						m_pCurrentDocument = NULL;
					}
					if(SUCCEEDED(hr = CoCreateInstance(CLSID_DOMDocument, NULL, CLSCTX_INPROC_SERVER,
											IID_IXMLDOMDocument, (LPVOID *)&m_pCurrentDocument)))
					{
						// Make sure this is the parent node for this call
						 pNodeParent = m_pCurrentDocument;
					}
				}

				// Create a XML DOM Node under the parent node
				if(SUCCEEDED(hr) && m_pCurrentDocument)
				{
					IXMLDOMNode *pCurrentNode = NULL;
					if(SUCCEEDED(hr = AddChildNode((IXMLDOMNode *)pNodeParent, aNodeInfo, cNumRecs, &pCurrentNode)))
					{
						// Set the parent for the children of this element
						aNodeInfo[0]->pNode = pCurrentNode;
					}
				}

			}
			break;
			case XML_PCDATA:
			{
				hr = AddPCDATA((IXMLDOMNode *)pNodeParent, aNodeInfo);
			}
			break;
			case XML_CDATA:
			{
				hr = AddCDATA((IXMLDOMNode *)pNodeParent, aNodeInfo);
			}

		}
	}
	else
		fwprintf(stderr, L"CreateNode() called for with 0 elements\n");

	assert(SUCCEEDED(hr));
	return hr;
}

HRESULT MyFactory::AddDocumentToList(IXMLDOMDocument *pNewDocument)
{
	HRESULT hr = S_OK;

	// See if there is empty space in the array for yet another document pointer
	if(1+m_dwNumDocuments > m_dwMaxNumDocuments)
	{
		// Reallocate an array
		IXMLDOMDocument **ppNewArray = NULL;
		m_dwMaxNumDocuments += 5; // Increase the size by 5
		ppNewArray = new IXMLDOMDocument*[m_dwMaxNumDocuments];
		if(ppNewArray)
		{
			// Copy old elements to this one
			for(DWORD i=0; i<m_dwNumDocuments; i++)
				ppNewArray[i] = m_ppDocuments[i];

			delete [] m_ppDocuments;
			m_ppDocuments = ppNewArray;

		}
		else
			hr = E_OUTOFMEMORY;
	}

	// Copy the latest one
	m_ppDocuments[m_dwNumDocuments++] = pNewDocument;
	pNewDocument->AddRef();
	assert(SUCCEEDED(hr));

	return hr;
}

HRESULT MyFactory::AddChildNode(IXMLDOMNode *pNodeParent, XML_NODE_INFO **aNodeInfo, USHORT cNumRecs, IXMLDOMNode **ppCurrentNode)
{
	if(!pNodeParent)
		return S_OK;

	HRESULT hr = E_FAIL;
	BSTR strElementName = NULL;
	if(strElementName = SysAllocString(aNodeInfo[0]->pwcText))
	{
		// Create a new Element in the document
		*ppCurrentNode = NULL;
		IXMLDOMElement *pNewElement = NULL;
		if(SUCCEEDED(hr = m_pCurrentDocument->createElement(strElementName, &pNewElement)))
		{
			// Add the element to the parent node
			if(SUCCEEDED(hr = pNodeParent->appendChild(pNewElement, NULL)))
			{
				// Add the attributes of the new element
				if(SUCCEEDED(hr = AddAttributes(pNewElement, aNodeInfo, cNumRecs)))
				{
					pNewElement->AddRef();
					*ppCurrentNode = pNewElement;
				}

			}
			pNewElement->Release();
		}
		SysFreeString(strElementName);
	}
	else
		hr = E_OUTOFMEMORY;

	assert(SUCCEEDED(hr));
	return hr;
}

HRESULT MyFactory::AddPCDATA(IXMLDOMNode *pNodeParent, XML_NODE_INFO **aNodeInfo)
{
	if(!pNodeParent)
		return S_OK;

	HRESULT hr = S_OK;
	BSTR strElementValue = NULL;
	if(aNodeInfo[0]->dwType == XML_PCDATA)
	{
		// Just copy the text
		if(strElementValue = SysAllocStringLen(aNodeInfo[0]->pwcText, aNodeInfo[0]->ulLen))
		{
		}
		else
			hr = E_OUTOFMEMORY;
	}
	else if(aNodeInfo[0]->dwType == XML_CDATA)
	{
		// Just copy the text - RAJESHR is this correct
		if(strElementValue = SysAllocStringLen(aNodeInfo[0]->pwcText, aNodeInfo[0]->ulLen))
		{
		}
		else
			hr = E_OUTOFMEMORY;
	}

	if(strElementValue)
	{
		hr = pNodeParent->put_text(strElementValue);
		SysFreeString(strElementValue);
	}
	return hr;
}


HRESULT MyFactory::AddCDATA(IXMLDOMNode *pNodeParent, XML_NODE_INFO **aNodeInfo)
{
	return S_OK;
}

HRESULT MyFactory::AddAttributes(IXMLDOMElement *pElement, XML_NODE_INFO **aNodeInfo, USHORT cNumRecs)
{
	// If the element has no attributes, then return.
	if(cNumRecs <= 1)
		return S_OK;

	HRESULT hr = E_FAIL;
	DWORD i=1;
	while(i<cNumRecs)
	{
		if(aNodeInfo[i]->dwType == XML_ATTRIBUTE)
		{
			// Get the Attribute Name
			BSTR strAttributeName = NULL;
			if(strAttributeName = SysAllocStringLen(aNodeInfo[i]->pwcText, aNodeInfo[i]->ulLen))
			{
				// Get the attribute value
				i++;
				BSTR strAttributeValue = NULL;
				if(aNodeInfo[i]->dwType == XML_PCDATA)
				{
					// Just copy the text
					if(strAttributeValue = SysAllocStringLen(aNodeInfo[i]->pwcText, aNodeInfo[i]->ulLen))
					{
					}
					else
						hr = E_OUTOFMEMORY;
				}
				else if(aNodeInfo[i]->dwType == XML_CDATA)
				{
					// Just copy the text - RAJESHR is this correct
					if(strAttributeValue = SysAllocStringLen(aNodeInfo[i]->pwcText, aNodeInfo[i]->ulLen))
					{
					}
					else
						hr = E_OUTOFMEMORY;
				}

				if(strAttributeValue)
				{
					VARIANT vValue;
					VariantInit(&vValue);
					vValue.vt = VT_BSTR;
					vValue.bstrVal = strAttributeValue;
					hr = pElement->setAttribute(strAttributeName, vValue);
					VariantClear(&vValue);
				}

				SysFreeString(strAttributeName);
			}
			else
				hr = E_OUTOFMEMORY;
		}
		i++; // Move on to the next element in the array
	}
	assert(SUCCEEDED(hr));
	return hr;
}

HRESULT MyFactory::GetDocument(IXMLDOMDocument **ppDocument)
{
	// See if there is one more document that can be given away
	// We should always have atleast one document in our list of available documents
	// unless we've reached the end of input from the stream that we're reading from
	if(m_dwAvailableDocIndex >= m_dwNumDocuments)
		return E_FAIL;

	// As AddRef/Release call gets cancelled out here
	*ppDocument = m_ppDocuments[m_dwAvailableDocIndex++];

	// Allow more data to be read from the stream if we dont have another document to be buffered
	if(m_dwAvailableDocIndex > m_dwNumDocuments - 1)
		m_pStream->SetPending(FALSE);

	return S_OK;
}

HRESULT MyFactory :: SkipNextDocument()
{
	// See if there is one more document that can be skipped
	// We should always have atleast one document in our list of available documents
	// unless we've reached the end of input from the stream that we're reading from
	if(m_dwAvailableDocIndex >= m_dwNumDocuments)
		return E_FAIL;

	// Release the document that is being skipped
	(m_ppDocuments[m_dwAvailableDocIndex++])->Release();

	// Allow more data to be read from the stream if we dont have another document to be buffered
	if(m_dwAvailableDocIndex > m_dwNumDocuments - 1)
		m_pStream->SetPending(FALSE);

	return S_OK;
}

// Checks to see if the specified element is one of the elements
// that needs to be manufactured from the factory
BOOL MyFactory::IsInterestingElement(LPCWSTR pszElementName)
{
	BOOL bRetVal = FALSE;
	for(DWORD i=0; i<m_dwNumElements; i++)
	{
		if(_wcsicmp(m_pszElementNames[i], pszElementName) == 0)
		{
			bRetVal = TRUE;
			break;
		}
	}
	return bRetVal;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\xmltransport\client\helpersources\putclasspacket.cpp ===
// CPutClassPacket.cpp: implementation of the CPutClassPacket class.
//
//////////////////////////////////////////////////////////////////////

#include "XMLTransportClientHelper.h"
#include "XMLClientPacket.h"
#include "PutClassPacket.h"


//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CPutClassPacket::CPutClassPacket(const WCHAR *pwszObjPath,const WCHAR *pwszNameSpace):
CXMLClientPacket(pwszObjPath,pwszNameSpace,L"CreateClass")
{
	m_ePathstyle = NOVAPATH; //assume nova path if this ctor is called.
}

//////////////////////////////////////////////////////////////////////
// Member functions
//////////////////////////////////////////////////////////////////////

HRESULT CPutClassPacket::GetBody(WCHAR **ppwszBody, DWORD *pdwLengthofPacket)
{
	if(NULL == m_pWbemClassObject || m_ePathstyle == WHISTLERPATH)
		return E_INVALIDARG;

	HRESULT hr = S_OK;
	
	IStream *pStream = NULL;
	if(SUCCEEDED(hr = GetBodyTillLocalNamespacePathInStream(&pStream)))
	{
		WRITETOSTREAM(pStream, L"<IPARAMVALUE NAME=\"lFlags\"><VALUE>");
		WCHAR pwszFlags[16];
		pwszFlags[15] = '\0';
		wsprintf(pwszFlags,L"%u", m_lFlags);
		WRITETOSTREAM(pStream, pwszFlags);
		WRITETOSTREAM(pStream, L"</VALUE></IPARAMVALUE>");

		WRITETOSTREAM(pStream, L"<IPARAMVALUE NAME=\"NewClass\">");
		if(SUCCEEDED(hr = ConvertWbemObjectToXMLStream(pStream)))
		{
			WRITETOSTREAM(pStream, L"</IPARAMVALUE></IMETHODCALL></SIMPLEREQ></MESSAGE></CIM>");
			hr = GetWStringFromStream(pStream,ppwszBody,pdwLengthofPacket);
		}
		pStream->Release();
	}

	return hr;
}

HRESULT CPutClassPacket::GetBodyDirect(const WCHAR *pwszXMLObj,
									   DWORD dwLengthofObj,
									   WCHAR **ppwszBody,
									   DWORD *pdwLengthofPacket)
{
	if( m_ePathstyle == WHISTLERPATH)
		return E_INVALIDARG;

	HRESULT hr = S_OK;
	
	IStream *pStream = NULL;
	if(SUCCEEDED(hr = GetBodyTillLocalNamespacePathInStream(&pStream)))
	{
		WRITETOSTREAM(pStream, L"<IPARAMVALUE NAME=\"lFlags\"><VALUE>");
		WCHAR pwszFlags[16];
		pwszFlags[15] = '\0';
		wsprintf(pwszFlags,L"%u",m_lFlags);
		WRITETOSTREAM(pStream, pwszFlags);
		WRITETOSTREAM(pStream, L"</VALUE></IPARAMVALUE>");

		WRITETOSTREAM(pStream, L"<IPARAMVALUE NAME=\"NewClass\">");
		if(SUCCEEDED(hr = pStream->Write(pwszXMLObj, dwLengthofObj*sizeof(WCHAR), NULL)))
		{
			WRITETOSTREAM(pStream, L"</IPARAMVALUE></IMETHODCALL></SIMPLEREQ></MESSAGE></CIM>");
			hr = GetWStringFromStream(pStream,ppwszBody,pdwLengthofPacket);
		}
		pStream->Release();
	}
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\xmltransport\client\helpersources\putinstancepacket.cpp ===
// CPutInstancePacket.cpp: implementation of the CPutInstancePacket class.
//
//////////////////////////////////////////////////////////////////////

#include "XMLTransportClientHelper.h"
#include "XMLClientPacket.h"
#include "PutInstancePacket.h"


//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CPutInstancePacket::CPutInstancePacket(const WCHAR *pwszObjPath,const WCHAR *pwszNameSpace):
CXMLClientPacket(pwszObjPath,pwszNameSpace,L"CreateInstance")
{
	m_ePathstyle = NOVAPATH; //assume nova path if this ctor is called.
}

//////////////////////////////////////////////////////////////////////
// Member functions
//////////////////////////////////////////////////////////////////////

HRESULT CPutInstancePacket::GetBody(WCHAR **ppwszBody,DWORD *pdwLengthofPacket)
{
	if(NULL == m_pWbemClassObject)
		return E_INVALIDARG;

	HRESULT hr = S_OK;
	IStream *pStream = NULL;
	if(SUCCEEDED(hr = GetBodyTillLocalNamespacePathInStream(&pStream)))
	{
		WRITETOSTREAM(pStream, L"<IPARAMVALUE NAME=\"lFlags\"><VALUE>");
		WCHAR pwszFlags[16];
		pwszFlags[15] = '\0';
		wsprintf(pwszFlags,L"%u",m_lFlags);
		WRITETOSTREAM(pStream, pwszFlags);
		WRITETOSTREAM(pStream, L"</VALUE></IPARAMVALUE>");

		// This is an INSTANCE unlike a VALUE.NAMEDINSTANCE for ModifyInstance
		WRITETOSTREAM(pStream, L"<IPARAMVALUE NAME=\"NewInstance\">")
		if(SUCCEEDED(hr = ConvertWbemObjectToXMLStream(pStream)))
		{
			WRITETOSTREAM(pStream, L"</IPARAMVALUE></IMETHODCALL></SIMPLEREQ></MESSAGE></CIM>");
			hr = GetWStringFromStream(pStream,ppwszBody,pdwLengthofPacket);
		}
		pStream->Release();
	}

	return hr;
}

HRESULT CPutInstancePacket::GetBodyDirect(const WCHAR *pwszXMLObjPath,DWORD dwLengthofObjPath,
										  WCHAR **ppwszBody,DWORD *pdwLengthofPacket)
{
	if(NULL == m_pWbemClassObject)
		return E_INVALIDARG;

	HRESULT hr = S_OK;
	IStream *pStream = NULL;
	if(SUCCEEDED(hr = GetBodyTillLocalNamespacePathInStream(&pStream)))
	{
		WRITETOSTREAM(pStream, L"<IPARAMVALUE NAME=\"lFlags\"><VALUE>");
		WCHAR pwszFlags[16];
		pwszFlags[15] = '\0';
		wsprintf(pwszFlags,L"%u",m_lFlags);
		WRITETOSTREAM(pStream, pwszFlags);
		WRITETOSTREAM(pStream, L"</VALUE></IPARAMVALUE>");

		// This is an INSTANCE unlike a VALUE.NAMEDINSTANCE for ModifyInstance
		WRITETOSTREAM(pStream, L"<IPARAMVALUE NAME=\"NewInstance\">")
		if(SUCCEEDED(hr = pStream->Write(pwszXMLObjPath, dwLengthofObjPath*sizeof(WCHAR), NULL)))
		{
			WRITETOSTREAM(pStream, L"</IPARAMVALUE></IMETHODCALL></SIMPLEREQ></MESSAGE></CIM>");
			hr = GetWStringFromStream(pStream, ppwszBody, pdwLengthofPacket);
		}
		pStream->Release();
	}

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\xmltransport\client\helpersources\mapxmltowmi.cpp ===
//Implementation of the CMapXMLtoWMI helper class
//
#include "XMLTransportClientHelper.h"
#include "MapXMLtoWMI.h"

// Initialized in Utils.cpp
extern IXMLWbemConvertor	*g_pXMLWbemConvertor;

CMapXMLtoWMI::CMapXMLtoWMI()
{
	
}

CMapXMLtoWMI::~CMapXMLtoWMI()
{
}

// IN this function we create a WMI Object from a IXMLDOMNode that represents a CLASS or INSTANCE element
HRESULT CMapXMLtoWMI::MapDOMtoWMI(LPCWSTR pwszServername, LPCWSTR pwszNamespace,
								  IXMLDOMNode *pXMLDomNode,
								  IWbemContext *pCtx,
								  IWbemClassObject **ppObject)
{
	if((NULL == pXMLDomNode)||(NULL == ppObject))
		return E_FAIL;

	HRESULT hr = S_OK;
	BSTR strServer = NULL, strNamespace = NULL;
	if(strServer = SysAllocString(pwszServername))
	{
		if(strNamespace = SysAllocString(pwszNamespace))
		{
			hr = g_pXMLWbemConvertor->MapObjectToWMI(pXMLDomNode, pCtx, strNamespace, strServer, ppObject);
			SysFreeString(strNamespace);
		}
		SysFreeString(strServer);
	}
	else
		hr = E_OUTOFMEMORY;
	return hr;
}

// IN this function we create a WMI Object from a string that represents an entire CIM response (ie. a CIM element)
HRESULT CMapXMLtoWMI::MapXMLtoWMI(LPCWSTR pwszServername, LPCWSTR pwszNamespace,
								  IXMLDOMDocument *pDoc,
								  IWbemContext *pCtx,
								  IWbemClassObject **ppObject)
{
	if((NULL == pDoc)||(NULL == ppObject))
		return E_FAIL;

	HRESULT hr = E_FAIL;
	
	// Get the IRETURNVALUE elements list
	IXMLDOMNodeList *pXMLDomNodeList = NULL;
	if(SUCCEEDED(hr = pDoc->getElementsByTagName(WMI_XML_STR_IRETURN_VALUE, &pXMLDomNodeList)) && pXMLDomNodeList)
	{
		// Get the first IRETURNVALUE element in the list
		IXMLDOMNode	*pXMLDomNode = NULL;
		if(SUCCEEDED(hr = pXMLDomNodeList->nextNode(&pXMLDomNode)) && pXMLDomNode)
		{
			// Get the child of the IRETURNVALUE
			// This will be CLASS OR INSTANCE OR VALUE.NAMEDINSTANCE
			IXMLDOMNode	*pXMLDomNodeTemp = NULL;
			if(SUCCEEDED(hr = pXMLDomNode->get_firstChild(&pXMLDomNodeTemp)) && pXMLDomNodeTemp)
			{
				// Get the CLASS or INSTANCE from the IRETURNVALUE
				IXMLDOMNode	*pXMLDomNodeChild = NULL;
				if(SUCCEEDED(hr = Parse_IRETURNVALUE_Node(pXMLDomNodeTemp, &pXMLDomNodeChild)))
				{
					// Map the CLASS or INSTANCE to an IWbemClassObject
					hr = MapDOMtoWMI(pwszServername, pwszNamespace, pXMLDomNodeChild, pCtx, ppObject);
					pXMLDomNodeChild->Release();
				}
				pXMLDomNodeTemp->Release();
			}
			pXMLDomNode->Release();
		}
		pXMLDomNodeList->Release();
	}

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\xmltransport\client\includes\deleteclasspacket.h ===
// DeleteClassPacket.h: interface for the CDeleteClassPacket class.
//
//////////////////////////////////////////////////////////////////////

#ifndef WMI_XML_DELETE_CLASS_H
#define WMI_XML_DELETE_CLASS_H

class CDeleteClassPacket : public CXMLClientPacket  
{

public:
	CDeleteClassPacket(const WCHAR *pwszObjPath,const WCHAR *pwszNameSpace);
	HRESULT GetBody(WCHAR **ppwszBody,DWORD *pdwLengthofPacket=NULL);
	
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\xmltransport\client\includes\enumerateclassnamespacket.h ===
// EnumerateClassPacket.h: interface for the CEnumerateClassPacket class.
//
//////////////////////////////////////////////////////////////////////

#ifndef WMI_XML_ENUM_CLASS_NAME_H
#define WMI_XML_ENUM_CLASS_NAME_H


class CEnumerateClassNamesPacket : public CXMLClientPacket  
{
public:
	CEnumerateClassNamesPacket(const WCHAR *pwszObjPath,const WCHAR *pwszNameSpace);
	HRESULT GetBody(WCHAR **ppwszBody,DWORD *pdwLengthofPacket=NULL);
	
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\xmltransport\client\includes\enumerate.h ===
// EnumerateClassPacket.h: interface for the CEnumerateClassPacket class.
//
//////////////////////////////////////////////////////////////////////

#ifndef WMI_XML_ENUMERATE_H
#define WMI_XML_ENUMERATE_H


class CEnumeratePacket : public CXMLClientPacket  
{

public:
	HRESULT GetBody(WCHAR **ppwszBody,DWORD *pdwLengthofPacket=NULL);

	CEnumeratePacket(const WCHAR *pwszObjPath,const WCHAR *pwszNameSpace, bool bClassEnumeration);


};

#endif // WMI_XML_ENUMERATE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\xmltransport\client\includes\deleteinstancepacket.h ===
// DeleteInstancePacket.h: interface for the CDeleteInstancePacket class.
//
//////////////////////////////////////////////////////////////////////

#ifndef WMI_XML_DELETE_INSTANCE
#define WMI_XML_DELETE_INSTANCE


class CDeleteInstancePacket : public CXMLClientPacket  
{

public:
	CDeleteInstancePacket(const WCHAR *pwszObjPath,const WCHAR *pwszNameSpace);
	HRESULT GetBody(WCHAR **ppwszBody, DWORD *pdwLengthofPacket=NULL);

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\xmltransport\client\helpersources\xmlclientpacketfactory.cpp ===
// XMLClientPacketFactory.cpp: implementation of the CXMLClientPacketFactory class.
//
//////////////////////////////////////////////////////////////////////

#include "XMLTransportClientHelper.h"
#include "XMLClientPacket.h"
#include "GetClassPacket.h"
#include "GetInstancePacket.h"
#include "DeleteClassPacket.h"
#include "DeleteInstancePacket.h"
#include "Enumerate.h"
#include "ExecQueryPacket.h"
#include "PutclassPacket.h"
#include "ModifyclassPacket.h"
#include "PutInstancePacket.h"
#include "ModifyInstancePacket.h"
#include "EnumerateClassNamesPacket.h"
#include "EnumerateInstanceNamesPacket.h"
#include "ExecuteClassMethodpacket.h"
#include "ExecuteInstanceMethodpacket.h"
#include "XMLClientPacketFactory.h"


//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CXMLClientPacketFactory::CXMLClientPacketFactory()
{
}

CXMLClientPacketFactory::~CXMLClientPacketFactory()
{
}


CXMLClientPacket *CXMLClientPacketFactory::CreateXMLPacket(const WCHAR *pwszLocale,const WCHAR *pwszMethodName,
														   const WCHAR *pwszObjPath,
														   const WCHAR *pwszNameSpace,
														   IWbemContext *pCtx,
														   IWbemClassObject *pWbemClassObject,
														   bool bLocalOnly,bool bIncludeQualifier,
														   bool bDeepInheritance,bool bClassOrigin)
{
	CXMLClientPacket *pPacket =NULL;

	if(_wcsicmp(pwszMethodName,L"GetClass")==0)
	{
		pPacket = new CGetClassPacket(pwszObjPath,pwszNameSpace);
	}
	else
	if(_wcsicmp(pwszMethodName,L"GetInstance")==0)
	{
		pPacket = new CGetInstancePacket(pwszObjPath,pwszNameSpace);
	}
	else
	if(_wcsicmp(pwszMethodName,L"DeleteClass")==0)
	{
		pPacket = new CDeleteClassPacket(pwszObjPath,pwszNameSpace);
	}
	else
	if(_wcsicmp(pwszMethodName,L"DeleteInstance")==0)
	{
		pPacket = new CDeleteInstancePacket(pwszObjPath,pwszNameSpace);
	}
	else
	if(_wcsicmp(pwszMethodName,L"EnumerateClasses")==0)
	{
		pPacket = new CEnumeratePacket(pwszObjPath,pwszNameSpace, true);
	}
	else
	if(_wcsicmp(pwszMethodName,L"EnumerateInstances")==0)
	{
		pPacket = new CEnumeratePacket(pwszObjPath,pwszNameSpace, false);
	}
	else
	if(_wcsicmp(pwszMethodName,L"ExecQuery")==0)
	{
		pPacket = new CExecQueryPacket(pwszObjPath,pwszNameSpace);
	}
	else
	if(_wcsicmp(pwszMethodName,L"CreateClass")==0)
	{
		pPacket = new CPutClassPacket(pwszObjPath,pwszNameSpace);
	}
	else
	if(_wcsicmp(pwszMethodName,L"ModifyClass")==0)
	{
		pPacket = new CModifyClassPacket(pwszObjPath,pwszNameSpace);
	}
	else
	if(_wcsicmp(pwszMethodName,L"CreateInstance")==0)
	{
		pPacket = new CPutInstancePacket(pwszObjPath,pwszNameSpace);
	}
	else
	if(_wcsicmp(pwszMethodName,L"ModifyInstance")==0)
	{
		pPacket = new CModifyInstancePacket(pwszObjPath,pwszNameSpace);
	}
	else
	if(_wcsicmp(pwszMethodName,L"EnumerateClassNames")==0)
	{
		pPacket = new CEnumerateClassNamesPacket(pwszObjPath,pwszNameSpace);
	}
	else
	if(_wcsicmp(pwszMethodName,L"EnumerateInstanceNames")==0)
	{
		pPacket = new CEnumerateInstanceNamesPacket(pwszObjPath,pwszNameSpace);
	}
	else
	if(_wcsicmp(pwszMethodName,L"ExecuteClassMethod")==0)
	{
		pPacket = new CExecuteClassMethodPacket(pwszObjPath,pwszNameSpace);
	}
	else
	if(_wcsicmp(pwszMethodName,L"ExecuteInstanceMethod")==0)
	{
		pPacket = new CExecuteInstanceMethodPacket(pwszObjPath,pwszNameSpace);
	}


	
	if(NULL != pPacket)
	{
		if(pPacket->ClassConstructionSucceeded())
		{
			pPacket->SetOptions(pwszLocale,pCtx,pWbemClassObject,bLocalOnly,bIncludeQualifier,
				bDeepInheritance,bClassOrigin);
		}
		else
		{
			delete [] pPacket;
			pPacket = NULL;
		}
	}

	return pPacket;
}


CXMLClientPacket * CXMLClientPacketFactory::CreateXMLPacket(const WCHAR *pwszLocale,const WCHAR *pwszMethodName, const WCHAR *pwszObjPath, const WCHAR *pwszNameSpace)
{
	return CreateXMLPacket(pwszLocale,pwszMethodName,pwszObjPath,pwszNameSpace,NULL,NULL,false,true,false,true);
}

CXMLClientPacket * CXMLClientPacketFactory::CreateXMLPacket(const WCHAR *pwszLocale,const WCHAR *pwszMethodName,const WCHAR *pwszObjPath,const  WCHAR *pwszNameSpace,
															IWbemContext *pCtx)
{
	return CreateXMLPacket(pwszLocale,pwszMethodName,pwszObjPath,pwszNameSpace,pCtx,NULL,false,true,false,true);
}

CXMLClientPacket * CXMLClientPacketFactory::CreateXMLPacket(const WCHAR *pwszLocale,const WCHAR *pwszMethodName,const WCHAR *pwszObjPath,const WCHAR *pwszNameSpace,
															IWbemContext *pCtx,bool bLocalOnly,bool bIncludeQualifier,
															bool bDeepInheritance,bool bClassOrigin)

{
	return CreateXMLPacket(pwszLocale,pwszMethodName,pwszObjPath,pwszNameSpace,pCtx,NULL,bLocalOnly,
		bIncludeQualifier,bDeepInheritance,bClassOrigin);
}

CXMLClientPacket *CXMLClientPacketFactory::CreateXMLPacket(const WCHAR *pwszLocale,const WCHAR *pwszMethodName,const WCHAR *pwszObjPath,
														   const WCHAR *pwszNameSpace,
														   IWbemContext *pCtx,
														   IWbemClassObject *pWbemClassObject)
{
	return CreateXMLPacket(pwszLocale,pwszMethodName,pwszObjPath,pwszNameSpace,pCtx,pWbemClassObject,false,true,false,true);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\xmltransport\client\helpersources\utils.cpp ===
#include "XMLTransportClientHelper.h"

// These are globals used by the library and need to be initialized 
// by a call to InitWMIXMLClientLibrary and deallocated by a call
// to UninitWMIXMLClientLibrary
BSTR WMI_XML_STR_IRETURN_VALUE	= NULL;
BSTR WMI_XML_STR_NAME			= NULL;
BSTR WMI_XML_STR_CODE			= NULL;
BSTR WMI_XML_STR_ERROR			= NULL;
BSTR WMI_XML_STR_VALUE			= NULL;
// The 3 commonly used IWbemContext objects
IWbemContext *g_pLocalCtx			= NULL;
IWbemContext *g_pNamedCtx			= NULL;
IWbemContext *g_pAnonymousCtx		= NULL;
IXMLWbemConvertor	*g_pXMLWbemConvertor = NULL;


//////////////////////////////////////////////////////////////////////////
// Utility functions
//////////////////////////////////////////////////////////////////////////


void FreeString(WCHAR *&Str)
{
	delete [] Str;
	Str = NULL;
}

//This was originally a macro... 
void RESET(WCHAR *&X) 
{
	delete [] X; 
	X = NULL; 
}

//This was originally a macro... 
void RESET(LPBYTE &X) 
{
	delete [] X; 
	X = NULL; 
}

HRESULT AssignString(WCHAR ** ppszTo, const WCHAR * pszFrom) 
{
	if(ppszTo == NULL || ((*ppszTo == pszFrom)&&(NULL != pszFrom))) //avoid self assignment
		return E_INVALIDARG;

	// Just assign a NULL is the source is NULL
	if(!pszFrom)
	{
		*ppszTo = NULL;
		return S_OK;
	}

	// Now, you've to copy the contents
	int iLen = wcslen(pszFrom) + 1;
	*ppszTo = NULL;
	if(*ppszTo = new WCHAR[iLen])
		wcscpy((WCHAR *)*ppszTo,pszFrom);
	else
		return E_OUTOFMEMORY;
	
	return S_OK;
}

// Converts LPWSTR to its UTF-8 encoding
// Returns 0 if it fails
//
DWORD ConvertLPWSTRToUTF8(LPCWSTR theWcharString, 
						  ULONG lNumberOfWideChars, 
						  LPSTR * lppszRetValue)
{
	// Find the length of the Ansi string required
	DWORD dwBytesToWrite = WideCharToMultiByte(  CP_UTF8,    // UTF-8 code page
		0,				// performance and mapping flags
		theWcharString,	// address of wide-character string
		lNumberOfWideChars,				// number of characters in string
		NULL,			// address of buffer for new string
		0,				// size of buffer
		NULL,			// address of default for unmappable
                        // characters
		NULL);			// address of flag set when default char. used

	if(dwBytesToWrite == 0 )
		return dwBytesToWrite;

	// Allocate the required length for the Ansi string
	*lppszRetValue = NULL;
	if(!(*lppszRetValue = new char[dwBytesToWrite]))
		return 0;

	// Convert BSTR to ANSI
	dwBytesToWrite = WideCharToMultiByte(  CP_UTF8,         // code page
		0,         // performance and mapping flags
		theWcharString, // address of wide-character string
		lNumberOfWideChars,       // number of characters in string
		*lppszRetValue,  // address of buffer for new string
		dwBytesToWrite,      // size of buffer
		NULL,  // address of default for unmappable
                         // characters
		NULL   // address of flag set when default
                             // char. used
		);

	return dwBytesToWrite;
}

// Copies the contents of a BSTR on to a LPWSTR
HRESULT AssignBSTRtoWCHAR(LPWSTR *ppwszTo, BSTR strBstring)
{
	*ppwszTo = NULL;
	if(SysStringLen(strBstring) > 0)
	{
		UINT iBstrLen = SysStringLen(strBstring)+1;
		*ppwszTo = NULL;
		*ppwszTo = new WCHAR[iBstrLen];
		if(NULL == *ppwszTo)
			return E_OUTOFMEMORY;

		int totalBytes = (iBstrLen-1)*sizeof(WCHAR);
		memcpy((void *)(*ppwszTo), strBstring, totalBytes);//last one for null char
		memset((void *)((*ppwszTo)+iBstrLen-1), 0, sizeof(WCHAR)); // Set the last NULL character
	}

	return S_OK;
}

UINT ConvertMSLocaleStringToUint(LPWSTR pwszLocale)
{
	// Locale is of the form MS_XXX, where XXX are hexadecimal characters
	// Our job is to convert the XXX in this string to an UINT
	//=====================================================================================

	// Assume US English as default
	UINT num = 0x409;

	// See if the string has enough characters
	if(NULL == pwszLocale || wcslen(pwszLocale) != 6)
		return num;

	// Covert the XXX string to a number
	// Temporarily modify the string to get it in the format required by wcstoul(),
	// Which is 0xNNN
	WCHAR char2 = pwszLocale[1];
	WCHAR char3 = pwszLocale[2];
	LPWSTR pszDummy = NULL;
	pwszLocale[1] = L'0';
	pwszLocale[2] = L'X';

	// Try to convert it
	if(!(num = wcstoul(pwszLocale+1, &pszDummy, 16)))
		num = 0x409;

	// Restore the contents of the original locale string
	pwszLocale[1] = char2;
	pwszLocale[2] = char3;

	return num;
}

void Get4DigitRandom(UINT *puRand)
{
	*puRand = rand();
	(*puRand) &= 9999;
}

void Get2DigitRandom(UINT *puRand)
{
	*puRand = rand();
	(*puRand) &= 99;
}

HRESULT GetBstrAttribute(IXMLDOMNode *pNode, const BSTR strAttributeName, BSTR *pstrAttributeValue)
{
	HRESULT result = E_FAIL;
	*pstrAttributeValue = NULL;

	IXMLDOMNamedNodeMap *pNameMap = NULL;
	if(SUCCEEDED(result = pNode->get_attributes(&pNameMap)))
	{
		IXMLDOMNode *pAttribute = NULL;
		if(SUCCEEDED(result = pNameMap->getNamedItem(strAttributeName, &pAttribute)))
		{
			if(result == S_FALSE)
			{
				result = E_FAIL;
			}
			else
			{
				result = pAttribute->get_text(pstrAttributeValue);
			}

		}
		pAttribute->Release();
	}
	pNameMap->Release();

	return result;
}

HRESULT MapCimErrToWbemErr(DWORD dwCimErrCode,HRESULT *pWbemErrCode)
{
	static DWORD dwWbemErrCodes[18]=
	{
		WBEM_NO_ERROR,
		WBEM_E_FAILED,
		WBEM_E_ACCESS_DENIED,
		WBEM_E_INVALID_NAMESPACE,
		WBEM_E_INVALID_PARAMETER,
		WBEM_E_INVALID_CLASS,
		WBEM_E_NOT_FOUND,
		WBEM_E_NOT_SUPPORTED,
		WBEM_E_CLASS_HAS_CHILDREN,
		WBEM_E_CLASS_HAS_INSTANCES,
		WBEM_E_INVALID_SUPERCLASS,
		WBEM_E_ALREADY_EXISTS,
		WBEM_E_INVALID_PROPERTY,
		WBEM_E_TYPE_MISMATCH,
		WBEM_E_INVALID_QUERY_TYPE,
		WBEM_E_INVALID_QUERY,
		WBEM_E_INVALID_METHOD,
		WBEM_E_INVALID_METHOD
	};

	if(dwCimErrCode > 17)
	{
		*pWbemErrCode = WBEM_E_FAILED;
		return E_INVALIDARG;
	}

	*pWbemErrCode = dwWbemErrCodes[dwCimErrCode];

	return S_OK;
}

// RAJESHR - Is this a reasonable mapping from HTTP status to WMI Errors?
HRESULT MapHttpErrtoWbemErr(DWORD dwResultStatus)
{
	HRESULT hr = WBEM_E_TRANSPORT_FAILURE;

	if(200 == dwResultStatus) //the caller needs to do more processing. return COM ok..
		hr = S_OK;

	switch(dwResultStatus)
	{
	case 400: 
		hr = WBEM_E_INVALID_PARAMETER;
		break;

	case 401:
	case 403:
		hr = WBEM_E_ACCESS_DENIED;
		break;
	
	case 404:
	case 405:
	case 406:
	case 503:
		hr = WBEM_E_NOT_FOUND;
		break;

	case 407:
		hr = WBEM_E_ACCESS_DENIED;
		break;

	case 501:
		hr = WBEM_E_NOT_SUPPORTED;
		break;
	}

	return hr;
}

// Takes an XML Response packet form a server and determines if this contains an ERROR element
// If so, it takes the CODE value from it and maps the CIM error code to a WMI Error code
HRESULT ParseXMLResponsePacket(IStream *pXMLPacket, IXMLDOMDocument **ppDoc, HRESULT *phErrCode)
{
	if((NULL == phErrCode) || (NULL == ppDoc) || (NULL == pXMLPacket))
		return E_INVALIDARG;

	HRESULT hr = S_OK;
	*ppDoc = NULL;
	*phErrCode = WBEM_NO_ERROR;

	// Parse the XML Response
	// Pack up the IStream in a variant and feed it to the IXMLDOMDocument object
	VARIANT_BOOL vbResult = VARIANT_TRUE;
	if(SUCCEEDED(hr = CreateXMLDocumentFromStream(ppDoc, pXMLPacket, vbResult)))
	{
		if(vbResult == VARIANT_TRUE)
		{
			IXMLDOMNodeList *pNodeList = NULL;
			// See if there is an ERROR element
			if(SUCCEEDED((*ppDoc)->getElementsByTagName(WMI_XML_STR_ERROR,&pNodeList)) && pNodeList)
			{
				IXMLDOMNode *pErrNode = NULL;
				if(SUCCEEDED(pNodeList->nextNode(&pErrNode))&&pErrNode)
				{
					// Get the CODE attribute of the ERROR element and map it to WMI
					BSTR strErrCode = NULL;
					if(SUCCEEDED(GetBstrAttribute(pErrNode, WMI_XML_STR_CODE, &strErrCode)))
					{
						MapCimErrToWbemErr(_wtol(strErrCode),phErrCode);
						SysFreeString(strErrCode);
					}
					pErrNode->Release();
				}
				pNodeList->Release();
			}
		}
		else
		{
			hr = E_FAIL;
				// RAJESHR - Send an HTTP error back to the client?

				IXMLDOMParseError *pError = NULL;
				if(SUCCEEDED((*ppDoc)->get_parseError(&pError)))
				{
					LONG errorCode = 0;
					pError->get_errorCode(&errorCode);
					LONG line=0, linepos=0;
					BSTR reason=NULL, srcText = NULL;
					if(SUCCEEDED(pError->get_line(&line)) &&
						SUCCEEDED(pError->get_linepos(&linepos)) &&
						SUCCEEDED(pError->get_reason(&reason)) &&
						SUCCEEDED(pError->get_srcText(&srcText)))
					{
					}
					pError->Release();
					if(reason)
						SysFreeString(reason);
					if(srcText)
						SysFreeString(srcText);
				} 

		}
	}

	if(FAILED(hr) && (*ppDoc))
	{
		(*ppDoc)->Release();
		(*ppDoc) = NULL;
	}

	return hr;
}

HRESULT EncodeResponseIntoStream(LPBYTE pszXML, DWORD dwSize, VARIANT *pVariant)
{
	HRESULT result = E_FAIL;
	IStream *pStream = NULL;

	// Create a Stream
	if (SUCCEEDED(result = CreateStreamOnHGlobal(NULL, TRUE, &pStream)))
	{
		// Fill it with Data
		if(SUCCEEDED(result = pStream->Write(pszXML, dwSize, NULL)))
		{
			LARGE_INTEGER	offset;
			offset.LowPart = offset.HighPart = 0;
			pStream->Seek (offset, STREAM_SEEK_SET, NULL);

			// Put the stream in the variant
			VariantInit(pVariant);
			pVariant->vt = VT_UNKNOWN;
			pVariant->punkVal = pStream;
		}
		else
			pStream->Release ();
	}
	return result;
}

// Checks the WMI Context object to see if the special field for 
// dedicated enumeration has been turned on
bool IsEnumtypeDedicated(IWbemContext *pCtx)
{
	if(NULL == pCtx)
		return false;

	// We really check to see the presence of the context property rather than
	// check for correctness
	bool bResult = false;
	VARIANT var;
	VariantInit(&var);
	if(SUCCEEDED(pCtx->GetValue(DEDICATEDENUMPROPERTY,0,&var)))
		bResult = true;
	VariantClear(&var);

	return bResult;
}

// Removes those context values that should not be sent to the server
// These are context values for client side processing
HRESULT FilterContext(IWbemContext *pCtx,IWbemContext **ppFilteredCtx)
{
	if(NULL == ppFilteredCtx)
		return E_INVALIDARG;

	if(NULL == pCtx)
	{
		*ppFilteredCtx = NULL;
		return S_OK;
	}

	HRESULT hr = S_OK;
	hr = pCtx->Clone(ppFilteredCtx);

	if(!SUCCEEDED(hr))
		return hr;

	//these properties are NOT guaranteed to exist in the context object..
	//we wont fail if any of these deltes fail.
	(*ppFilteredCtx)->DeleteValue(DEDICATEDENUMPROPERTY,0);
	(*ppFilteredCtx)->DeleteValue(PROXYNAMEPROPERTY,0);
	(*ppFilteredCtx)->DeleteValue(PROXYBYPASSPROPERTY,0);
	
	return hr;
}

// This is a function that reads the data form an IStream and returns it.
// It assumes that the data is actually a stream of WCHARs and hence
// returns the size as number of WCHARs rather than the number of bytes read from the IStream
HRESULT GetWStringFromStream(IStream *pStream, WCHAR **ppwszBody,DWORD *pdwLengthofPacket)
{
	HRESULT hr = S_OK;
	STATSTG stat;
	memset(&stat,0,sizeof(STATSTG));
	LARGE_INTEGER	offset;
	offset.LowPart = offset.HighPart = 0;
	pStream->Seek (offset, STREAM_SEEK_SET, NULL);
	pStream->Stat(&stat,1);
	
	unsigned int iLen = (unsigned int)stat.cbSize.LowPart; 
	*ppwszBody = NULL;
	if(*ppwszBody = new WCHAR[(iLen/2) +1]) //size is in BYTEs. we want WCHARs
	{
		hr = pStream->Read((void*)*ppwszBody, iLen, pdwLengthofPacket);
		*pdwLengthofPacket = (*pdwLengthofPacket)/2;
	}
	else
		hr = E_OUTOFMEMORY;

	return hr;
}


HRESULT ConvertContextObjectToXMLStream(IStream *pStream, IWbemContext *pCtx)
{
	if((NULL == pCtx)||(NULL == pStream))
		return E_INVALIDARG;
	
	//RAJESHR : Add code to convert context to string using interface RAjesh will create...
	HRESULT hr = S_OK;
	return hr;
}

// Gets Proxy information from the fields in IWbemContext
HRESULT GetProxyInformation(IWbemContext *pCtx, WCHAR **ppwszProxyName, WCHAR **ppwszProxyBypass)
{
	if((NULL == ppwszProxyName)||(NULL == ppwszProxyBypass)||(pCtx==NULL))
		return E_INVALIDARG;

	*ppwszProxyName = *ppwszProxyBypass = NULL;
	HRESULT hr = WBEM_S_NO_ERROR;
	VARIANT var;
	VariantInit(&var);

	// Get the Proxy Name
	if(SUCCEEDED(hr = pCtx->GetValue(PROXYNAMEPROPERTY,0,&var)))
	{
		if(SUCCEEDED(hr = AssignBSTRtoWCHAR(ppwszProxyName, var.bstrVal)))
		{
			VariantInit(&var);
			if(SUCCEEDED(hr = pCtx->GetValue(PROXYBYPASSPROPERTY, 0, &var)))
				hr = AssignBSTRtoWCHAR(ppwszProxyBypass,var.bstrVal);
			VariantClear(&var);
		}
		VariantClear(&var);
	}

	// Delete allocated resources if the function failed
	if(FAILED(hr))
	{
		delete [] *ppwszProxyName;
		delete [] *ppwszProxyBypass;
		*ppwszProxyName = *ppwszProxyBypass = NULL;
	}
	return hr;
}

// Unlike the previous function that mapped the ERROR value in the CIM error to WMI hResult,
// this function maps the WMI error in Whistler packets to hResult
HRESULT GetHresultfromXMLPacket(IStream *pPacket, HRESULT *hres)
{
	HRESULT hr = S_OK;

	if((NULL == pPacket)||(NULL == hres))
		return E_INVALIDARG;

	IXMLDOMDocument	*pXMLDomDocument=NULL;
	VARIANT_BOOL vbResult = VARIANT_TRUE;
	if(SUCCEEDED(hr = CreateXMLDocumentFromStream(&pXMLDomDocument, pPacket, vbResult)))
	{
		if(vbResult == VARIANT_TRUE)
		{
			//THE CONTRACT WITH THE XMLHTTP SERVER IS THAT, FOR THE TRANSACTION OPERATIONS THAT EXPECT A HRESULT
			//IT WILL PACK THE RESULTING HRESULT IN THE *FIRST* VALUE TAG INSIDE THE IRETURNVALUE..

			IXMLDOMNodeList *pNodeList=NULL;
			if(SUCCEEDED(hr = pXMLDomDocument->getElementsByTagName(WMI_XML_STR_VALUE, &pNodeList)) && pNodeList)
			{
				IXMLDOMNode *pErrNode = NULL;
				if(SUCCEEDED(hr = pNodeList->nextNode(&pErrNode)) && pErrNode)
				{						
					BSTR strErrCode = NULL;
					if(SUCCEEDED(hr = pErrNode->get_text(&strErrCode)))
					{
						*hres = _wtol(strErrCode);
						SysFreeString(strErrCode);
					}
					pErrNode->Release();
				}
				pNodeList->Release();
			}
			else
			{
				// We got a badly formed response from the server
				hr = WBEM_E_FAILED;
			}
		}

		pXMLDomDocument->Release();
	}
	return hr;
}

// This function gets the CLASS or INSTANCE element from inside an
// IRETURNVALUE element. 
HRESULT Parse_IRETURNVALUE_Node(IXMLDOMNode *pXMLDomNodeTemp,IXMLDOMNode **ppXMLDomNodeChild)
{
	if((NULL == pXMLDomNodeTemp)||(NULL == ppXMLDomNodeChild))
		return E_INVALIDARG;

	HRESULT hr = S_OK;
	BSTR strNodename = NULL;
	if(!SUCCEEDED(hr = pXMLDomNodeTemp->get_nodeName(&strNodename)))
		return hr;

	//node contains CLASS/INSTANCE, no parsing required..
	if((_wcsicmp(strNodename,L"CLASS")==0)||(_wcsicmp(strNodename,L"INSTANCE")==0) ) 
	{
		*ppXMLDomNodeChild = pXMLDomNodeTemp;
		pXMLDomNodeTemp->AddRef();
		SysFreeString(strNodename);
		return S_OK;
	}

	// No need to keep the name with us
	SysFreeString(strNodename);

	// The given node was not a CLASS or INSTANCE element,
	// In that case it must be a VALUE.NAMEDINSTANCE element
	// So, let's look at its children
	*ppXMLDomNodeChild = NULL;
	IXMLDOMNodeList *pXMLDomNodeList = NULL;
	if(SUCCEEDED(hr = pXMLDomNodeTemp->get_childNodes(&pXMLDomNodeList)) && pXMLDomNodeList)
	{
		// Get the next child
		bool bFoundinstance = false;
		IXMLDOMNode *pChild = NULL;
		while(SUCCEEDED(hr = pXMLDomNodeList->nextNode(&pChild)) && pChild)
		{
			// Check its name
			BSTR strChildName = NULL;
			if(SUCCEEDED(hr = pChild->get_nodeName(&strChildName)))
			{
				if(_wcsicmp(strChildName, L"INSTANCE")==0) //INSTANCE 
				{
					SysFreeString(strChildName);
					break;
				}
				SysFreeString(strChildName);
			}
			pChild->Release();
			pChild = NULL;
		}

		// Did we find one?
		if(pChild)
		{
			*ppXMLDomNodeChild = pChild;
			pChild->AddRef();
		}

		pXMLDomNodeList->Release();
	}
	return (*ppXMLDomNodeChild) ? S_OK : E_FAIL;
}

// THis initialized the 3 global variables that are IWbemContext objects for
// the most commonly used IWbemContexts for the Convertor
static HRESULT CreateFlagsContext()
{
	HRESULT hres = S_OK;
	if(SUCCEEDED(hres = CoCreateInstance(CLSID_WbemContext,NULL,CLSCTX_INPROC,IID_IWbemContext,(LPVOID *)&g_pLocalCtx)))
	{
		VARIANT var;
		VariantInit(&var);
		var.vt = VT_BOOL;

		var.boolVal = VARIANT_TRUE;
		g_pLocalCtx->SetValue(L"AllowWMIExtensions", 0,&var);
		g_pLocalCtx->SetValue(L"IncludeQualifiers",  0,&var);
		g_pLocalCtx->SetValue(L"IncludeClassOrigin", 0,&var);
		g_pLocalCtx->SetValue(L"ExcludeSystemProperties", 0,&var);

		VariantInit(&var);
		var.vt = VT_I4;
		var.lVal = pathLevelLocal;
		g_pLocalCtx->SetValue(L"PathLevel", 0,&var);
	}

	if(SUCCEEDED(hres) && SUCCEEDED(hres = CoCreateInstance(CLSID_WbemContext,NULL,CLSCTX_INPROC,IID_IWbemContext,(LPVOID *)&g_pAnonymousCtx)))
	{
		VARIANT var;
		VariantInit(&var);
		var.vt = VT_BOOL;

		var.boolVal = VARIANT_TRUE;
		g_pAnonymousCtx->SetValue(L"AllowWMIExtensions", 0,&var);
		g_pAnonymousCtx->SetValue(L"IncludeQualifiers",  0,&var);
		g_pAnonymousCtx->SetValue(L"IncludeClassOrigin", 0,&var);
		g_pAnonymousCtx->SetValue(L"ExcludeSystemProperties", 0,&var);

		VariantInit(&var);
		var.vt = VT_I4;
		var.lVal = pathLevelAnonymous;
		g_pAnonymousCtx->SetValue(L"PathLevel", 0,&var);

	}

	if(SUCCEEDED(hres) && SUCCEEDED(hres = CoCreateInstance(CLSID_WbemContext,NULL,CLSCTX_INPROC,IID_IWbemContext,(LPVOID *)&g_pNamedCtx)))
	{
		VARIANT var;
		VariantInit(&var);
		var.vt = VT_BOOL;

		var.boolVal = VARIANT_TRUE;
		g_pNamedCtx->SetValue(L"AllowWMIExtensions", 0,&var);
		g_pNamedCtx->SetValue(L"IncludeQualifiers",  0,&var);
		g_pNamedCtx->SetValue(L"IncludeClassOrigin", 0,&var);
		g_pNamedCtx->SetValue(L"ExcludeSystemProperties", 0,&var);

		VariantInit(&var);
		var.vt = VT_I4;
		var.lVal = pathLevelNamed;
		g_pNamedCtx->SetValue(L"PathLevel", 0,&var);

	}

	return hres;
}


// {41388E26-F847-4a9d-96C0-9A847DBA4CFE}
DEFINE_GUID(CLSID_XMLWbemConvertor,
0x41388e26, 0xf847, 0x4a9d, 0x96, 0xc0, 0x9a, 0x84, 0x7d, 0xba, 0x4c, 0xfe);


// Initialize global variable required by the static library here
HRESULT InitWMIXMLClientLibrary()
{
	// Seed the random number library with the current time
	srand( (unsigned int)time(NULL) );

	HRESULT hr = E_FAIL;
	if(SUCCEEDED(hr = CreateFlagsContext()))
	{
		if(SUCCEEDED(hr = CoCreateInstance(CLSID_XMLWbemConvertor, NULL, CLSCTX_INPROC_SERVER,IID_IXMLWbemConvertor,
				(void**)&g_pXMLWbemConvertor)))
		{
			WMI_XML_STR_IRETURN_VALUE	= SysAllocString(L"IRETURNVALUE");
			WMI_XML_STR_NAME			= SysAllocString(L"NAME");
			WMI_XML_STR_CODE			= SysAllocString(L"CODE");
			WMI_XML_STR_ERROR			= SysAllocString(L"ERROR");
			WMI_XML_STR_VALUE			= SysAllocString(L"VALUE");

			if(WMI_XML_STR_IRETURN_VALUE &&
				WMI_XML_STR_NAME &&
				WMI_XML_STR_CODE &&
				WMI_XML_STR_ERROR &&
				WMI_XML_STR_VALUE)
				hr = S_OK;
			else
				hr = E_OUTOFMEMORY;
		}
	}


	// Check if each of the initializations was a success
	// Else, free resources and report error
	// We dont want to be in a partially initialized state
	if(FAILED(hr))
		UninitWMIXMLClientLibrary();

	return hr;
}

// Uninitialize globals and release resources here
HRESULT UninitWMIXMLClientLibrary()
{
	SysFreeString(WMI_XML_STR_IRETURN_VALUE);
	SysFreeString(WMI_XML_STR_NAME);
	SysFreeString(WMI_XML_STR_CODE);
	SysFreeString(WMI_XML_STR_ERROR);
	SysFreeString(WMI_XML_STR_VALUE);
	WMI_XML_STR_IRETURN_VALUE	= NULL;
	WMI_XML_STR_NAME			= NULL;
	WMI_XML_STR_CODE			= NULL;
	WMI_XML_STR_ERROR			= NULL;
	WMI_XML_STR_VALUE			= NULL;
	if(g_pLocalCtx)
	{
		g_pLocalCtx->Release();
		g_pLocalCtx = NULL;
	}
	if(g_pNamedCtx)
	{
		g_pNamedCtx->Release();
		g_pNamedCtx = NULL;
	}
	if(g_pAnonymousCtx)
	{
		g_pAnonymousCtx->Release();
		g_pAnonymousCtx = NULL;
	}
	if(g_pXMLWbemConvertor)
	{
		g_pXMLWbemConvertor->Release();
		g_pXMLWbemConvertor = NULL;
	}

	return S_OK;
}

HRESULT CreateXMLDocument(IXMLDOMDocument **ppXMLDocument)
{
	HRESULT hr = E_FAIL;
	if(SUCCEEDED(hr = CoCreateInstance(CLSID_DOMDocument, NULL, CLSCTX_INPROC_SERVER,
								IID_IXMLDOMDocument, (LPVOID *)ppXMLDocument)))
	{
		if(SUCCEEDED(hr = (*ppXMLDocument)->put_async(VARIANT_FALSE)))
		{
			if(SUCCEEDED(hr = (*ppXMLDocument)->put_resolveExternals(VARIANT_FALSE)))
			{
				if(SUCCEEDED(hr = (*ppXMLDocument)->put_validateOnParse(VARIANT_FALSE)))
				{
				}
			}
		}
		// Release out argument it things didnt go well
		if(FAILED(hr))
		{
			(*ppXMLDocument)->Release();
			*ppXMLDocument = NULL;
		}
	}
	return hr;
}

HRESULT CreateXMLDocumentFromStream(IXMLDOMDocument **ppXMLDocument, IStream *pStream, VARIANT_BOOL &bResult)
{
	HRESULT hr = E_FAIL;
	if(SUCCEEDED(hr = CreateXMLDocument(ppXMLDocument)))
	{
		VARIANT xmlVariant;
		VariantInit (&xmlVariant);
		xmlVariant.vt = VT_UNKNOWN;
		xmlVariant.punkVal = pStream;
		if(SUCCEEDED(hr = (*ppXMLDocument)->load(xmlVariant, &bResult)))
		{
			if(bResult == VARIANT_FALSE)
			{
				// This code is for debugging only
				IXMLDOMParseError *pError = NULL;
				if(SUCCEEDED((*ppXMLDocument)->get_parseError(&pError)))
				{
					LONG errorCode = 0;
					pError->get_errorCode(&errorCode);
					LONG line=0, linepos=0;
					BSTR reason=NULL, srcText = NULL;
					if(SUCCEEDED(pError->get_line(&line)) &&
						SUCCEEDED(pError->get_linepos(&linepos)) &&
						SUCCEEDED(pError->get_reason(&reason)) &&
						SUCCEEDED(pError->get_srcText(&srcText)))
					{
					}
					pError->Release();
					if(reason)
						SysFreeString(reason);
					if(srcText)
						SysFreeString(srcText);

					pError->Release();
				}
			}
		}
		else
		{
			(*ppXMLDocument)->Release();
			*ppXMLDocument = NULL;
		}

		// No need to clear the variant since we did not addref() the stream
	}
	return hr;
}

/* THESE ARE NOT BEING USED CURRENTLY
HRESULT CXMLClientPacket::ConvertContextObjectToXMLString(WCHAR **ppwszXMLString, DWORD *pdwDataLength)	
{
	HRESULT hr = S_OK;
	//aborting the attempt to rewrite this function as Rajesh has decided
	//to create an interface that would provide this functionality..

	//RAJESHR: use Rajesh's interface when ready...

	if((NULL == m_pCtx)||(NULL == ppwszXMLString))
		return E_INVALIDARG;
	
	IStream *pStream=NULL;
	
	if(SUCCEEDED(hr = CreateStreamOnHGlobal(NULL, TRUE, &pStream)))
	{
		WRITETOSTREAM(pStream,L"<CONTEXTOBJECT>\r\n"); 

		if(SUCCEEDED(m_pCtx->BeginEnumeration(0)))
		{
			VARIANT vNextArgValue;
			VariantInit(&vNextArgValue);
			BSTR strNextArgName = NULL;

			while(m_pCtx->Next(0, &strNextArgName, &vNextArgValue) != WBEM_S_NO_MORE_DATA)
			{
				//process each property of the context and fill in the XML equivalent
				//into the IStream pointer..
				hr=ProcessContextProperty(strNextArgName,vNextArgValue,pStream);
				
				SysFreeString(strNextArgName);
				strNextArgName = NULL;
				VariantInit(&vNextArgValue);

				if(!SUCCEEDED(hr))
					break;
			}

			VariantClear(&vNextArgValue);
		}

		WRITETOSTREAM(pStream,L"</CONTEXTOBJECT>\r\n"); 
	}

	RELEASE_AND_NULL_INTERFACE(pStream);
	return hr;
}


HRESULT CXMLClientPacket::ProcessContextProperty(BSTR &strNextArgName, VARIANT &vNextArgValue,
												 IStream *pStream)
{
	HRESULT hr = S_OK;
	if((NULL != strNextArgName)&&(NULL != pStream))
	{
		if(vNextArgValue.vt^VT_ARRAY)
		{
			//this is not an ARRAY, just a single property
			
			if(!(vNextArgValue.vt^VT_UNKNOWN)) //this property contains an Object.
			{
				WRITETOSTREAM(pStream,L"<CONTEXTPROPERTY.OBJECT NAME=\"");
				WRITETOSTREAM(pStream,strNextArgName);
				WRITETOSTREAM(pStream,L"\">");

				hr = ProcessSingleContextProperty(strNextArgName,vNextArgValue,pStream);
				
				WRITETOSTREAM(pStream,L"</CONTEXTPROPERTY.OBJECT>");

			}
			else
			{
				WRITETOSTREAM(pStream,L"<CONTEXTPROPERTY NAME=\"");
				WRITETOSTREAM(pStream,strNextArgName);
				WRITETOSTREAM(pStream,L" VTType=");
				GetVTType(vNextArgValue,pStream);
				WRITETOSTREAM(pStream,L">");

				hr = ProcessSingleContextProperty(strNextArgName,vNextArgValue,pStream);

				WRITETOSTREAM(pStream,L"</CONTEXTPROPERTY>");
			}
			
		}
		else
		{	//this is an ARRAY of properties
			hr = ProcessArrayContextProperty(strNextArgName,vNextArgValue,pStream);
		}

	}
	return hr;
}

HRESULT CXMLClientPacket::ProcessSingleContextProperty(BSTR &strNextArgName,VARIANT &vNextArgValue,
												 IStream *pStream)
{
	//NO NULL CHECKS NECESSARY. CONTROL WONT REACH HERE WITH NULLS
	HRESULT hr = S_OK;
	
	if(!(vNextArgValue.vt^VT_UNKNOWN)) //this property contains an Object.
	{
		WRITETOSTREAM(pStream,L"<VALUE.OBJECT>");
		//RAJESHR: CODE TO GET CONVERTOR INTERFACE FROM SINGLETON CLASS AND DO A MAPOBJECTTOXML..
		WRITETOSTREAM(pStream,L"</VALUE.OBJECT>");
	}
	else
	{
		WRITETOSTREAM(pStream,L"<VALUE>");
		
		//VT TYPES TAKEN FROM CIM DTD DEFINITION OF VTTYPE
		//VT_UNKNOWN IS HANDLED SEPARATELY ABOVE..
		switch(vNextArgValue.vt)
		{
		case VT_I4:
			{
				WCHAR tmp[32]; //VT_I4 number has to fit in this easily
				tmp[0] = '\0';
				wsprintf(tmp,L"%u\0",vNextArgValue.lVal);
				WRITETOSTREAM(pStream,tmp);
				break;
			}
		case VT_R8:
			{
				WCHAR tmp[32]; //VT_I4 number has to fit in this easily
				tmp[0] = '\0';
				wsprintf(tmp,L"%f\0",vNextArgValue.fltVal);
				WRITETOSTREAM(pStream,tmp);
				break;
			}
		case VT_BOOL:
			{
				if(vNextArgValue.boolVal == VARIANT_TRUE)
				{
					WRITETOSTREAM(pStream,L"TRUE");
				}
				else
				{
					WRITETOSTREAM(pStream,L"FALSE");
				}

				break;
			}
		case VT_BSTR:
			{
				WRITETOSTREAM(pStream,vNextArgValue.bstrVal);
				break;
			}
		}

		WRITETOSTREAM(pStream,L"</VALUE>");
	}

	
	return hr;
}

HRESULT CXMLClientPacket::ProcessArrayContextProperty(BSTR &strNextArgName,VARIANT &vNextArgValue,
												 IStream *pStream)
{
	//NO NULL CHECKS NECESSARY. CONTROL WONT REACH HERE WITH NULLS
	HRESULT hr = S_OK;
	//RAJESHR: ADD BODY. USE PREVIOUS FN IN A LOOP..
	return hr;
}

HRESULT GetVTType(VARIANT &var,IStream *pStream)
{
	HRESULT hr = S_OK;

	if(NULL == pStream)
		hr = E_INVALIDARG;
	else
	{
		WRITETOSTREAM(pStream,L"\"");

		switch(var.vt)
		{
		case VT_I4:
			WRITETOSTREAM(pStream,L" VT_I4");
			break;
		
		case VT_R8:
			WRITETOSTREAM(pStream,L" VT_R8");
			break;

		case VT_BOOL:
			WRITETOSTREAM(pStream,L" VT_BOOL");
			break;

		case VT_BSTR:
			WRITETOSTREAM(pStream,L" VT_BSTR");
			break;

		case VT_UNKNOWN:
			WRITETOSTREAM(pStream,L" VT_UNKNOWN");
			break;

		case VT_NULL:
			WRITETOSTREAM(pStream,L" VT_NULL");
			break;

		default:
			hr = E_INVALIDARG;
			break;
		}

		WRITETOSTREAM(pStream,L"\"");
	}

	return hr;
}
 */

/*
HRESULT WriteSecurityObjectToStream(IWbemRawSdAccessor *pSecurityObject,IStream *pStream)
{
	ULONG dwSize=0;
	
	HRESULT hr = S_OK;

	if(!SUCCEEDED(hr=pSecurityObject->Get(0,0,&dwSize,NULL)))
		return hr;

	BYTE *pSecurityInfo = new BYTE[dwSize];
	
	if(NULL == pSecurityInfo)
		return E_OUTOFMEMORY;

	pSecurityObject->Get(0,dwSize,&dwSize,pSecurityInfo);

	pStream->Write(pSecurityInfo,dwSize,&dwSize);

	return hr;
}

HRESULT PlaceStringAsSecurityinfo(IWbemRawSdAccessor *pSecurityObject,const BYTE *pwszSecurityinfo,DWORD dwSize)
{
	//pwszSecurityinfo actually contains the XML response sent by the server.
	//the security info is packed into an IPARAMVALUE, <VALUE></VALUE>.

	HRESULT hr = S_OK;

	IXMLDOMDocument *pXMLDomDocument = NULL;
	IXMLDOMNodeList *pXMLDomNodelist = NULL;
	IXMLDOMNode     *pXMLDomNode     = NULL;

	VARIANT xmlVariant;
	VariantInit(&xmlVariant);
	
	do
	{
		hr = CoCreateInstance(CLSID_DOMDocument, NULL, CLSCTX_INPROC_SERVER,IID_IXMLDOMDocument,
			(void**)&pXMLDomDocument); 

		if(!SUCCEEDED(hr))
			break;

		if(NULL == pXMLDomDocument)
		{
			hr = E_FAIL;
			break;
		}

		pXMLDomDocument->put_async(VARIANT_FALSE);

		VARIANT_BOOL vbResult = VARIANT_TRUE;


		if(!SUCCEEDED(hr = EncodeResponseIntoStream((LPBYTE)pwszSecurityinfo, dwSize, &xmlVariant)))
		{
			break;
		}
			
		if(!SUCCEEDED(hr = pXMLDomDocument->load(xmlVariant, &vbResult)))
		{
			break;
		}
						
		if(vbResult != VARIANT_TRUE)
		{
				hr = E_FAIL;
				break;
		}
		
		hr = pXMLDomDocument->getElementsByTagName(WMI_XML_STR_IRETURN_VALUE,&pXMLDomNodelist);
		if(!SUCCEEDED(hr) || (pXMLDomNodelist==NULL))
			break;
		
		if(!SUCCEEDED(hr = pXMLDomNodelist->nextNode(&pXMLDomNode))) //pNode now has IRETURNVALUE
			break;
			
		RELEASEINTERFACE(pXMLDomNodelist); //got the node, now dont need the node list. will reuse it
		
		if (!SUCCEEDED(pXMLDomNode->get_childNodes (&pXMLDomNodelist))) //getobjectsecurity must have returned a <PROPERTY NAME=ppvResult> <VALUE>..
			break;
					
		RELEASEINTERFACE(pXMLDomNode);

		while (SUCCEEDED(hr) && SUCCEEDED(pXMLDomNodelist->nextNode (&pXMLDomNode)) && pXMLDomNode)
		{
			BSTR strNodeName = NULL,strPropname=NULL;

			if (SUCCEEDED(pXMLDomNode->get_nodeName (&strNodeName)))
			{
				if (0 == _wcsicmp(strNodeName, L"PROPERTY"))
				{
					if(!SUCCEEDED(hr=GetBstrAttribute(pXMLDomNode, WMI_XML_STR_NAME, &strPropname)))
						break;

					if(0==_wcsicmp(strPropname,L"ppvResult"))
						break;

				}
				
			}
		}
		
		if(!SUCCEEDED(hr))
			break;
		
		//now we have the domnode which has the security information...

		BSTR strSecurityinfo = NULL;

		if(!SUCCEEDED(hr = pXMLDomNode->get_text(&strSecurityinfo)))
			break;

		ULONG uBufsize = SysStringLen(strSecurityinfo);

		WCHAR *pwszSecurityinfo = NULL;

		//dont worry, AssignBStr.. function uses memset internally...
		if(!SUCCEEDED(hr = AssignBSTRtoWCHAR(&pwszSecurityinfo,strSecurityinfo)))
			break;

		SysFreeString(strSecurityinfo);

		hr = pSecurityObject->Put(0,uBufsize,(LPBYTE)pwszSecurityinfo);

			
	}while(0);

	VariantClear(&xmlVariant);

	RELEASEINTERFACE(pXMLDomDocument);
	RELEASEINTERFACE(pXMLDomNodelist);
	RELEASEINTERFACE(pXMLDomNode);    

	return E_NOTIMPL;
}
*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\xmltransport\client\helpersources\xmlclientpacket.cpp ===
// XMLClientPacket.cpp: implementation of the CXMLClientPacket class.
//
//////////////////////////////////////////////////////////////////////

#include "XMLTransportClientHelper.h"
#include "wmiconv.h"
#include "wmi2xml.h"
#include "XMLClientPacket.h"
#include "XMLClientpacketFactory.h"

LPCWSTR CXMLClientPacket::WMI_WHISTLERSTRING		= L" WMI=\"WHISTLER\"";
LPCWSTR CXMLClientPacket::TRUE_STRING				= L"TRUE";
LPCWSTR CXMLClientPacket::FALSE_STRING				= L"FALSE";
LPCWSTR CXMLClientPacket::WHISTLER_HTTP_HEADER		= L"MicrosoftWMI:Whistler";

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CXMLClientPacket::CXMLClientPacket(const WCHAR *pObjPath,const WCHAR *pwszNameSpace,
								   const WCHAR *pwszCimOperation):
								m_bWMI(true),
								m_pwszNameSpace(NULL),
								m_pwszObjPath(NULL),
								m_pwszCimOperation(NULL),
								m_pwszLocale(NULL),
								m_dwXMLNamespaceLength(0),
								m_dwNumberofNamespaceparts(0),
								m_pwszQueryString(NULL),
								m_lFlags(0),
								m_pCtx(NULL),
								m_pWbemClassObject(NULL),
								m_ePathstyle(NOVAPATH)
{
	
	/********************************************************************************
		
		The following functions will set the m_hResult to S_OK or whatever the
		failure code is.. the XMLClientPacketFactory is the class that is supposed
		to be creating the XMLClientPacket derived classes. thats the purpose of
		the packet factory. the factory will create the packe class and then check
		this member (m_hResult) via the ClassConstructionSucceeded() member function to
		determine if everything went well during construction.

	********************************************************************************/
	
	m_hResult = S_OK;
	m_pwszQueryLanguage[0] = NULL;

	m_hResult = AssignString(&m_pwszNameSpace,const_cast<WCHAR*>(pwszNameSpace));

	if(SUCCEEDED(m_hResult))
		m_hResult = GetNamespaceLength(&m_dwXMLNamespaceLength, &m_dwNumberofNamespaceparts);
	
	//ExecQuery operation doesnt need to pass an ObjPath - will be NULL! also enums
	if(SUCCEEDED(m_hResult))
			m_hResult = AssignString(&m_pwszObjPath,const_cast<WCHAR*>(pObjPath));

	if(SUCCEEDED(m_hResult))
		m_hResult = AssignString(&m_pwszCimOperation,const_cast<WCHAR*>(pwszCimOperation));

	// Initialize other members that will ultimately point to static member strings
	m_iPostType				= 2; /*1 for POST, 2 for M-POST*/
	m_pwszLocalOnly				= FALSE_STRING;
	m_pwszIncludeQualifier		= TRUE_STRING;
	m_pwszDeepInheritance		= TRUE_STRING;
	m_pwszIncludeClassOrigin	= TRUE_STRING;
};

bool CXMLClientPacket::ClassConstructionSucceeded()
{
	return (SUCCEEDED(m_hResult)) ? true : false;
}

CXMLClientPacket::~CXMLClientPacket()
{
	delete [] m_pwszNameSpace;
	delete [] m_pwszObjPath;
	delete [] m_pwszCimOperation;
	delete [] m_pwszLocale;
	delete [] m_pwszQueryString;
	
	RELEASEINTERFACE(m_pCtx);
}

HRESULT CXMLClientPacket::SetPostType(int iPostType/*1 for POST, 2 for M-POST*/)
{
	// Just set the member variable to one of the static members
	if((iPostType<1)||(iPostType>2))
		return E_INVALIDARG;

	m_iPostType = iPostType;
	return S_OK;
}

HRESULT CXMLClientPacket::SetOptions(const WCHAR *pwszLocale,
									 IWbemContext *pCtx,
									 IWbemClassObject *pWbemClassObject,
									 bool bLocalOnly,
									 bool bIncludeQualifier,
									 bool bDeepInheritance,bool bIncludeClassOrigin)
{
	HRESULT hr = S_OK;

	// Set the context member
	//===============================
	RELEASE_AND_NULL_INTERFACE(m_pCtx);
	if(m_pCtx = pCtx)
		m_pCtx->AddRef();

	// Set the WMI object member
	//==================================
	RELEASE_AND_NULL_INTERFACE(m_pWbemClassObject);
	if(m_pWbemClassObject = pWbemClassObject)
		m_pWbemClassObject->AddRef();


	(bLocalOnly == true) ?			(m_pwszLocalOnly = TRUE_STRING) : (m_pwszLocalOnly = FALSE_STRING);
	(bIncludeQualifier == true) ?	(m_pwszIncludeQualifier = TRUE_STRING) : (m_pwszIncludeQualifier = FALSE_STRING);
	(bDeepInheritance == true) ?	(m_pwszDeepInheritance = TRUE_STRING) : (m_pwszDeepInheritance = FALSE_STRING);
	(bIncludeClassOrigin == true) ?	(m_pwszIncludeClassOrigin = TRUE_STRING) : (m_pwszIncludeClassOrigin = FALSE_STRING);

	if(NULL != pwszLocale)
		hr = AssignString(&m_pwszLocale,pwszLocale);

	return hr;
}

HRESULT CXMLClientPacket::SetQueryLanguage(const WCHAR *pwszQueryLanguage)
{
	if(NULL == pwszQueryLanguage)
		return E_INVALIDARG;

	wcscpy(m_pwszQueryLanguage,pwszQueryLanguage);
	return S_OK;
}

HRESULT CXMLClientPacket::SetQueryString(const WCHAR *pwszQueryString)
{
	if(NULL == pwszQueryString)
		return E_INVALIDARG;

	RESET(m_pwszQueryString);
	return AssignString(&m_pwszQueryString,pwszQueryString);
}

HRESULT CXMLClientPacket::SetFlags(LONG lFlags)
{
	m_lFlags = lFlags;
	return S_OK;
}

// In this function, we need to create the HTTP headers required for
// an M-POST or POST request
HRESULT CXMLClientPacket::GetHeader(WCHAR **ppwszHeader)
{
	if(NULL == m_pwszCimOperation || NULL == ppwszHeader)
		return E_INVALIDARG;

	/*1 for POST, 2 for M-POST*/
	if(m_iPostType == 1)
		return GetPostHeader(ppwszHeader);
	else
	if(m_iPostType == 2)
		return GetMPostHeader(ppwszHeader);
	else
		return E_FAIL;
}

// In this function, we need to create the HTTP headers required for
// an POST request
HRESULT CXMLClientPacket::GetPostHeader(WCHAR **ppwszHeader)
{
	static const WCHAR *pwszHeaderLine = 
		L"Content-Type:application/xml;charset=\"utf-8\"\r\nCIMOperation:MethodCall\r\nCIMMethod:";

	int iSize = wcslen(pwszHeaderLine) +
		wcslen(m_pwszNameSpace) +
		wcslen(m_pwszCimOperation) + 
		wcslen(L"\r\nCIMObject:") + 
		3; //  For the \r\n to be appended

	iSize += wcslen(WHISTLER_HTTP_HEADER) + 3;

	if(NULL !=m_pwszLocale)
		iSize += wcslen(L"Accept-Language: xx, *\r\n");

	if(*ppwszHeader = new WCHAR[iSize])
	{
		wcscpy(*ppwszHeader, pwszHeaderLine);
		wcscat(*ppwszHeader, m_pwszCimOperation);
		wcscat(*ppwszHeader, L"\r\nCIMObject:");
		wcscat(*ppwszHeader, m_pwszNameSpace);
		wcscat(*ppwszHeader, L"\r\n");
		if(NULL != m_pwszLocale)
		{
			wcscat(*ppwszHeader, L"Accept-Language: ");
			wcscat(*ppwszHeader, m_pwszLocale);
			wcscat(*ppwszHeader, L", *\r\n");
		}

		wcscat(*ppwszHeader, WHISTLER_HTTP_HEADER);
		wcscat(*ppwszHeader, L"\r\n");
	}
	else
		return E_OUTOFMEMORY;

	return S_OK;
}

// In this function, we need to create the HTTP headers required for
// an M-POST request
HRESULT CXMLClientPacket::GetMPostHeader(WCHAR **ppwszHeader)
{
	int size = 
		wcslen(L"Content-Type:application/xml;charset=\"utf-8\"\r\n\
Man:http://www.dmtf.org/cim/mapping/http/v1.0 ; ns=99\r\n\
99-CIMOperation:MethodCall\r\n99-CIMMethod:") + 
		wcslen(m_pwszNameSpace) + 
		wcslen(L"\r\n99-CIMObject:") +
		wcslen(m_pwszCimOperation) +
		3; //\r\n to be appended

	// Get a 2 digit random value that is use to designate the M-POST namespace
	UINT i = 0;
	Get2DigitRandom(&i);

	if(NULL !=m_pwszLocale)
		size += wcslen(L"99-Accept-Language: xx, *\r\n");

	
	WCHAR *pwszSpecialHeader = NULL;
	int iSpecialHeaderSize = wcslen(WHISTLER_HTTP_HEADER) + wcslen(L"99-") + 3; // \r\n
	if(pwszSpecialHeader = new WCHAR[iSpecialHeaderSize])
	{		
		wsprintf(pwszSpecialHeader,L"%02d-%s", i, WHISTLER_HTTP_HEADER);
		size += iSpecialHeaderSize;
	}
	else
		return E_OUTOFMEMORY;

	*ppwszHeader = NULL;
	if(*ppwszHeader = new WCHAR[size])
	{
		if(NULL != m_pwszLocale)
			wsprintf(*ppwszHeader,L"%s\r\n%s%02d\r\n%02d%s\r\n%02d%s%s\r\n%02d%s%s\r\n%02d%s%s%s\r\n",
				L"Content-Type:application/xml;charset=\"utf-8\"",
				L"Man:http://www.dmtf.org/cim/mapping/http/v1.0 ; ns=",
				i,i,
				L"-CIMOperation:MethodCall",
				i,
				L"-CIMMethod:",m_pwszCimOperation,
				i,
				L"-CIMObject:",
				m_pwszNameSpace,
				i,
				L"-Accept-Language: ",
				m_pwszLocale,
				L", *"
				);
		else
			wsprintf(*ppwszHeader,L"%s\r\n%s%02d\r\n%02d%s\r\n%02d%s%s\r\n%02d%s%s\r\n",
				L"Content-Type:application/xml;charset=\"utf-8\"",
				L"Man:http://www.dmtf.org/cim/mapping/http/v1.0 ; ns=",
				i,i,
				L"-CIMOperation:MethodCall",
				i,
				L"-CIMMethod:",m_pwszCimOperation,
				i,
				L"-CIMObject:",
				m_pwszNameSpace);

		if(NULL != pwszSpecialHeader)
		{
			wcscat(*ppwszHeader, pwszSpecialHeader);
			wcscat(*ppwszHeader, L"\r\n");
		}

		delete [] pwszSpecialHeader;
	}
	else
	{
		delete [] pwszSpecialHeader;
		return E_OUTOFMEMORY;
	}
	
	return S_OK;
}

// Gets the length of the XML text to represent a <NAMESPACE> element
// and also gets the number of namespaces in the m_pwszNameSpace member
HRESULT CXMLClientPacket::GetNamespaceLength(DWORD *pdwTotalLength, DWORD *pdwNumberofNamespaces)
{
	if(NULL == m_pwszNameSpace)
	{
		*pdwTotalLength = 0;
		*pdwNumberofNamespaces = 0;
		return S_OK;
	}

	int iEnd = wcslen(m_pwszNameSpace), iStart=0;

	//We are not interested in the trailing slash or begginning slash if any.
	//both frontslash and back slash are supported..
	if(m_pwszNameSpace[0] == '\\')
		iStart++;
	
	if(m_pwszNameSpace[iEnd] == '\\')
		iEnd --;
	
	int iNumNamespaces = 0;
	for(int i = iStart; i<iEnd; i++)
	{
		if(m_pwszNameSpace[i] == '\\')
			iNumNamespaces++;
	}

	//There are one more number of namespace elements than the number of slashes.
	//We have already excluded the starting and trailing slashes if any.
	iNumNamespaces ++; 

	//how many namespace elements ? Eg. in root\cimv2, we have 2
	*pdwNumberofNamespaces = iNumNamespaces;

	//length of namespace without preceding/trailing slashes minus number of slashes inside.
	*pdwTotalLength = (iEnd - iStart) - iNumNamespaces + 1; 
	*pdwTotalLength += iNumNamespaces *wcslen(L"<NAMESPACE NAME=\"\"/>"); 

	return S_OK;
}

HRESULT CXMLClientPacket::GetXMLNamespaceInStream(IStream *pStream)
{
	if(NULL == pStream)
		return E_INVALIDARG;

	if((0 == m_dwXMLNamespaceLength)||(0 == m_dwNumberofNamespaceparts))
		return S_OK; //nothing to write in stream

	LPWSTR pszCurrent = m_pwszNameSpace;
	LPWSTR pszEnd = m_pwszNameSpace + wcslen(m_pwszNameSpace) - 1;

	//We are not interested in the trailing slash or begginning slash if any.
	//both frontslash and back slash are supported..
	if(*pszCurrent == '\\')
		pszCurrent  ++;
	if(*pszEnd == '\\')
		pszEnd --;

	// Go thru the namespace string and break it into the individial namespace components
	LPWSTR pszBeginningOfLast = pszCurrent;
	while(true) //scan each character.
	{
		// Are we past one component or at the end of the string
		if(*pszCurrent == '\\' || *pszCurrent == NULL )
		{
			// If so, use the component that we just passed
			pStream->Write(L"<NAMESPACE NAME=\"", wcslen(L"<NAMESPACE NAME=\"")*sizeof(WCHAR), NULL);
			pStream->Write(pszBeginningOfLast, 
				(int)(((INT_PTR)(pszCurrent- pszBeginningOfLast))*sizeof(WCHAR)), 
				NULL);
			pStream->Write(L"\"/>", wcslen(L"\"/>")*sizeof(WCHAR), NULL);
			pszBeginningOfLast = pszCurrent+1;
		}

		if(*pszCurrent == NULL )
			break;

		pszCurrent++;
	}

	return S_OK;
}

HRESULT CXMLClientPacket::GetBodyTillLocalNamespacePathInStream(IStream **ppStream)
{
	HRESULT hr = E_FAIL;
	if(SUCCEEDED(hr = CreateStreamOnHGlobal(NULL, TRUE, ppStream)))
	{
		UINT i = 0;
		Get4DigitRandom(&i);

		WRITETOSTREAM(*ppStream, L"<?xml version=\"1.0\" encoding=\"utf-8\" ?>");
		WRITETOSTREAM(*ppStream, L"<CIM CIMVERSION=\"2.0\" DTDVERSION=\"2.0\">");
		WRITETOSTREAM(*ppStream, L"<MESSAGE ID=\"");
		WCHAR pTmp[5];
		wsprintf(pTmp,L"%04d", i);
		WRITETOSTREAM(*ppStream, pTmp);
		WRITETOSTREAM(*ppStream, L"\" PROTOCOLVERSION=\"1.0\">");
		WRITETOSTREAM(*ppStream, L"<SIMPLEREQ>");
		WRITETOSTREAM(*ppStream, L"<IMETHODCALL NAME=\"");
		WRITETOSTREAM(*ppStream, m_pwszCimOperation);
		WRITETOSTREAM(*ppStream, L"\"");
		if(m_ePathstyle != NOVAPATH)
			WRITETOSTREAM(*ppStream, WMI_WHISTLERSTRING);

		WRITETOSTREAM(*ppStream, L">");

		// We put Namespace information here only for Nova style paths
		if(m_ePathstyle == NOVAPATH)
		{
			WRITETOSTREAM(*ppStream, L"<LOCALNAMESPACEPATH>");
			hr = GetXMLNamespaceInStream(*ppStream);
			WRITETOSTREAM(*ppStream, L"</LOCALNAMESPACEPATH>");
		}

		
		if(SUCCEEDED(hr) && (NULL != m_pCtx))
			hr = ConvertContextObjectToXMLStream(*ppStream, m_pCtx);
	}

	if(FAILED(hr) && (*ppStream))
	{
		(*ppStream)->Release();
		*ppStream = NULL;
	}
	return hr;
}


HRESULT CXMLClientPacket::GetBodyDirect(const WCHAR *pwszXMLObjPath,DWORD dwLengthofObjPath,
										WCHAR **ppwszBody,
										DWORD *pdwLengthofPacket)
{
	return E_NOTIMPL; //implemented by derived classes. all of them need not implement this functionality.
}


DEFINE_GUID(CLSID_WbemXMLConvertor,
	0x610037ec, 0xce06, 0x11d3, 0x93, 0xfc, 0x0, 0x80, 0x5f, 0x85, 0x37, 0x71);


HRESULT CXMLClientPacket::ConvertWbemObjectToXMLStream(IStream *pStream)
{
	if(NULL == m_pWbemClassObject)
		return E_INVALIDARG;

	HRESULT hres = S_OK;
	IWbemXMLConvertor *ppv = NULL;
	if(SUCCEEDED(hres = CoCreateInstance(CLSID_WbemXMLConvertor, NULL, CLSCTX_INPROC, IID_IWbemXMLConvertor,(void**)&ppv)))
	{
		IWbemContext *pCtx = NULL;
		bool bModifyInstance = false;
		// Set the correct IWbemContext required by the convertor
		// We have 3 global contexts and we set pCtx to the right one,
		// based on the operation
		if(_wcsicmp(m_pwszCimOperation,L"ExecMethod")==0)
		{
			//LOCALINSTANCEPATH|LOCALCLASSPATH
			pCtx = g_pLocalCtx;
		}
		else
		{
			if((_wcsicmp(m_pwszCimOperation, L"CreateClass")==0)	||
				(_wcsicmp(m_pwszCimOperation, L"CreateInstance")==0)||
				(_wcsicmp(m_pwszCimOperation, L"ModifyClass")==0))
			{
				//INSTANCE|CLASS
				pCtx = g_pAnonymousCtx;
			}
			else
			{
				if(_wcsicmp(m_pwszCimOperation,L"ModifyInstance")==0)
				{
					bModifyInstance = true;
					pCtx = g_pNamedCtx;
				}
			}
		}

		if(bModifyInstance)
			WRITETOSTREAM(pStream,L"<VALUE.NAMEDINSTANCE>");

		hres = ppv->MapObjectToXML(m_pWbemClassObject, 
							NULL, 
							0, 
							pCtx, 
							pStream, 
							NULL);

		if(bModifyInstance)
			WRITETOSTREAM(pStream,L"</VALUE.NAMEDINSTANCE>");

		ppv->Release();
	}

	return hres;
}

HRESULT CXMLClientPacket::GetParamsFromObjectInStream(IStream *pStream)
{
	if(NULL == m_pWbemClassObject)
		return E_INVALIDARG;

	IWbemXMLConvertor *ppv = NULL;
	HRESULT hres = CoCreateInstance(CLSID_WbemXMLConvertor, NULL,CLSCTX_INPROC, IID_IWbemXMLConvertor,(void**)&ppv);
	if(SUCCEEDED(hres))
	{
		SAFEARRAY *psaNames = NULL;
		if(SUCCEEDED(hres = m_pWbemClassObject->GetNames(NULL,WBEM_FLAG_ALWAYS| WBEM_FLAG_NONSYSTEM_ONLY,NULL,&psaNames)))
		{
			long lLower=0, lUpper=0; 
			SafeArrayGetLBound(psaNames, 1, &lLower);
			SafeArrayGetUBound(psaNames, 1, &lUpper);
			BSTR pwszPropname = NULL;
			for (long i = lLower; i <= lUpper; i++) 
			{
				// Get this property.
				if(SUCCEEDED(hres = SafeArrayGetElement(psaNames,&i,&pwszPropname)))
				{
					pStream->Write(L"<PARAMVALUE NAME=\"",wcslen(L"<PARAMVALUE NAME=\"")*sizeof(WCHAR),NULL);
					pStream->Write(pwszPropname,SysStringLen(pwszPropname)*sizeof(WCHAR),NULL);
					pStream->Write(L"\">",wcslen(L"\">")*sizeof(WCHAR),NULL);
					ppv->MapPropertyToXML(m_pWbemClassObject, pwszPropname, g_pLocalCtx, pStream);
					pStream->Write(L"</PARAMVALUE>",wcslen(L"</PARAMVALUE>")*sizeof(WCHAR),NULL);
					SysFreeString(pwszPropname);
				}
			}
			SafeArrayDestroy(psaNames);
		}
		ppv->Release();
	}
	return hres;
}

HRESULT CXMLClientPacket::SetMethod(const WCHAR *pwszMethod)
{
	if(NULL == pwszMethod)
		return E_INVALIDARG;

	RESET(m_pwszCimOperation);
	return AssignString(&m_pwszCimOperation, const_cast<WCHAR*>(pwszMethod));
}

HRESULT CXMLClientPacket::GetKeyBindingsInStream(IStream *pStream)
{
	HRESULT hr = S_OK;
	IWbemXMLConvertor *ppv = NULL;
	if(SUCCEEDED(hr = CoCreateInstance(CLSID_WbemXMLConvertor, NULL,CLSCTX_INPROC, IID_IWbemXMLConvertor,(void**)&ppv)))
	{
		if(m_ePathstyle = NOVAPATH)
		{
			BSTR strInstanceName = NULL;
			if(strInstanceName = SysAllocString(m_pwszObjPath))
			{
				hr = ppv->MapInstanceNameToXML(strInstanceName, NULL, pStream);
				SysFreeString(strInstanceName);
			}
			else
				hr = E_OUTOFMEMORY;
		}
		else
		{
				WRITETOSTREAM(pStream, L"<VALUE>");
				WRITETOSTREAM(pStream, m_pwszObjPath);
				WRITETOSTREAM(pStream, L"</VALUE>");
		}
		ppv->Release();
	}
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\xmltransport\client\helpersources\urlparser.cpp ===
//
// URLPARSER.cpp: implementation of the CURLParser class.
//
/////////////////////////////////////////////////////////////////////////////////////////////////////////

#include "XMLTransportClientHelper.h"
#include <wmiutils.h>
#include "URLParser.h"


HRESULT CURLParser::Initialize(LPCWSTR pszObjPath)
{
	HRESULT hr = S_OK;
	m_pIWbemPath = NULL;
	if(SUCCEEDED(hr = CoCreateInstance(CLSID_WbemDefPath,NULL,CLSCTX_INPROC_SERVER,IID_IWbemPath,(LPVOID *)&m_pIWbemPath)))
		hr = m_pIWbemPath->SetText(WBEMPATH_CREATE_ACCEPT_ALL, pszObjPath);
	return hr;
}


//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////
CURLParser::~CURLParser()
{
	RELEASEINTERFACE(m_pIWbemPath);
}

//////////////////////////////////////////////////////////////////////
// Function to the get the server name
//////////////////////////////////////////////////////////////////////
HRESULT CURLParser::GetServername(WCHAR **ppwszServername)
{
	*ppwszServername = NULL;

	HRESULT hr = S_OK;
	ULONG	lTemp=0;
	if(SUCCEEDED(hr = m_pIWbemPath->GetServer(&lTemp,NULL)))
	{
		if(lTemp != 0)
		{
			*ppwszServername = new WCHAR[lTemp];
			hr = m_pIWbemPath->GetServer(&lTemp, *ppwszServername);
		}
	}

	if(FAILED(hr))
	{
		delete [] *ppwszServername;
		*ppwszServername = NULL;
	}

	return hr;
}

//////////////////////////////////////////////////////////////////////
// Function to the get the Name space
//////////////////////////////////////////////////////////////////////
HRESULT CURLParser::GetNamespace(WCHAR **ppwszNamespace)
{
	// If you cant get the namespace count, or if it is 0
	*ppwszNamespace = NULL;
	ULONG lNumNs = 0;
	if(FAILED(m_pIWbemPath->GetNamespaceCount(&lNumNs)) || (!lNumNs))
		return S_OK;

	// Make 2 passes - once to calculate the amount of memory required
	// Once to actually copy it into the memory allocated

	// Pass 1 - determine the amount
	DWORD dwMemLength = lNumNs -1; // INitialized to the number of backslashes required
	dwMemLength += 1; // And 1 for the terminating NULL character
	bool bError = false;
	ULONG lIndex = 0, lTemp = 0;
	while(!bError && (lIndex<lNumNs))
	{
		if(SUCCEEDED(m_pIWbemPath->GetNamespaceAt(lIndex, &lTemp,NULL)))
			dwMemLength += (lTemp-1); // Exclude the NULL character from the count
		else
			bError = true;
		lTemp = 0;
		lIndex ++;
	}

	if(bError)
		return E_FAIL;

	// Allocate the memory required now and Initialize it
	if(*ppwszNamespace = new WCHAR[dwMemLength])
	{
		(*ppwszNamespace)[0] = NULL;
		DWORD dwCurrentLength = 0; // And 1 for the terminating NULL character
		bool bError = false;
		ULONG lIndex = 0, lTemp = dwMemLength;
		while(!bError && (lIndex<lNumNs))
		{
			if(SUCCEEDED(m_pIWbemPath->GetNamespaceAt(lIndex, &lTemp, *ppwszNamespace + dwCurrentLength)))
			{
				dwCurrentLength += (lTemp-1); // Exclude the NULL character from the count
				*(*ppwszNamespace + dwCurrentLength++) = '\\';
			}
			else
				bError = true;
			lTemp = dwMemLength;
			lIndex ++;
		}
		if(bError)
		{
			delete [] (*ppwszNamespace);
			*ppwszNamespace = NULL;
			return E_FAIL;
		}
		else
			*(*ppwszNamespace + --dwMemLength) = NULL; // Terminate the string
	}
	else
		return E_OUTOFMEMORY;
	return S_OK;
}

////////////////////////////////////////////////////////////////////////
//	Function to get the Scope
////////////////////////////////////////////////////////////////////////
HRESULT CURLParser::GetScope(WCHAR **ppwszScope)
{
	ULONG uCount = 0;
	HRESULT hr = S_OK;

	*ppwszScope = NULL;
	ULONG lNumNs = 0;
	if(!SUCCEEDED(hr= m_pIWbemPath->GetScopeCount(&uCount)))
		return hr;

	// Make 2 passes - once to calculate the amount of memory required
	// Once to actually copy it into the memory allocated

	// Pass 1 - determine the amount
	DWORD dwMemLength = lNumNs -1; // INitialized to the number of colons required
	dwMemLength += 1; // And 1 for the terminating NULL character
	bool bError = false;
	ULONG lIndex = 0, lTemp = 0;
	while(!bError && (lIndex<lNumNs))
	{
		if(SUCCEEDED(m_pIWbemPath->GetScopeAsText(lIndex, &lTemp,NULL)))
			dwMemLength += (lTemp-1); // Exclude the NULL character from the count
		else
			bError = true;
		lTemp = 0;
		lIndex ++;
	}

	if(bError)
		return E_FAIL;

	// Allocate the memory required now and Initialize it
	if(*ppwszScope = new WCHAR[dwMemLength])
	{
		(*ppwszScope)[0] = NULL;
		DWORD dwCurrentLength = 0; // And 1 for the terminating NULL character
		bool bError = false;
		ULONG lIndex = 0, lTemp = dwMemLength;
		while(!bError && (lIndex<lNumNs))
		{
			if(SUCCEEDED(m_pIWbemPath->GetScopeAsText(lIndex, &lTemp, *ppwszScope + dwCurrentLength)))
			{
				dwCurrentLength += (lTemp-1); // Exclude the NULL character from the count
				*(*ppwszScope + dwCurrentLength++) = ':';
			}
			else
				bError = true;
			lTemp = dwMemLength;
			lIndex ++;
		}
		if(bError)
		{
			delete [] (*ppwszScope);
			*ppwszScope = NULL;
			return E_FAIL;
		}
		else
			*(*ppwszScope + --dwMemLength) = NULL; // Terminate the string
	}
	else
		return E_OUTOFMEMORY;
	

	return hr;
}
//////////////////////////////////////////////////////////////////////
// Function to the Get the instancename
// The string will be freed by the calling application
//////////////////////////////////////////////////////////////////////
HRESULT CURLParser::GetObjectName(WCHAR **ppwszInstancename)
{
	if(NULL == ppwszInstancename)
		return E_INVALIDARG;

	ULONG	lBuffLen = 0;
	HRESULT hr = S_OK;
	*ppwszInstancename = NULL;
	if(SUCCEEDED(hr = m_pIWbemPath->GetText(WBEMPATH_GET_RELATIVE_ONLY, &lBuffLen,NULL)))
	{
		if(lBuffLen != 0)
		{
			if(*ppwszInstancename = new WCHAR[lBuffLen])
			{
				if(FAILED(hr = m_pIWbemPath->GetText(WBEMPATH_GET_RELATIVE_ONLY, &lBuffLen, *ppwszInstancename)))
				{
					delete [] (*ppwszInstancename);
					*ppwszInstancename = NULL;
				}
			}
			else
				hr = E_OUTOFMEMORY;
		}
	}

	return hr;
}


//////////////////////////////////////////////////////////////////////
// Function to the set the object path
//////////////////////////////////////////////////////////////////////
HRESULT CURLParser::SetObjPath(LPCWSTR pszObjPath)
{
	if(NULL == pszObjPath)
		return E_INVALIDARG;

	return m_pIWbemPath->SetText(WBEMPATH_CREATE_ACCEPT_ALL, pszObjPath);
}

bool CURLParser::IsNovapath()
{
	bool bResult = false;
	unsigned __int64 ull;
	
	SCODE sc = m_pIWbemPath->GetInfo(0,&ull);
	
	if(SUCCEEDED(sc))
	{
		if(ull & WBEMPATH_INFO_V1_COMPLIANT)
			bResult = true;
	}

	return bResult;
}
	
bool CURLParser::IsWhistlerpath()
{
	bool bResult = false;
	unsigned __int64 ull;
	
	SCODE sc = m_pIWbemPath->GetInfo(0,&ull);
	
	if(SUCCEEDED(sc))
	{
		if(ull & WBEMPATH_INFO_V2_COMPLIANT)
			bResult = true;
	}

	return bResult;
}
	
bool CURLParser::IsClass()
{
	unsigned __int64 ull;
	if(FAILED(m_pIWbemPath->GetInfo(0,&ull)))
		return false;
	else
	{
		if(ull & WBEMPATH_INFO_IS_CLASS_REF)
			return true;
		else
			return false;
	}
}

bool CURLParser::IsInstance()
{
	unsigned __int64 ull;
	if(FAILED(m_pIWbemPath->GetInfo(0,&ull)))
		return false;
	else
	{
		if(ull & WBEMPATH_INFO_IS_INST_REF)
			return true;
		else
			return false;
	}
}

bool CURLParser::IsScopedpath()
{
	bool bResult = false;

	unsigned __int64 ull;
	
	SCODE sc = m_pIWbemPath->GetInfo(0,&ull);
	
	if(SUCCEEDED(sc))
	{
		if(ull & WBEMPATH_INFO_HAS_SUBSCOPES)
			bResult = true;
	}

	return bResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\xmltransport\client\includes\executeinstancemethodpacket.h ===
// ExecuteInstanceMethodPacket.h: interface for the CExecuteInstanceMethodPacket class.
//
//////////////////////////////////////////////////////////////////////

#ifndef WMI_XML_EXEC_INST_METH_PACKET
#define WMI_XML_EXEC_INST_METH_PACKET



class CExecuteInstanceMethodPacket : public CXMLClientPacket  
{

public:
	CExecuteInstanceMethodPacket(const WCHAR *pwszObjPath,const WCHAR *pwszNameSpace);
	HRESULT GetBody(WCHAR **ppwszBody,DWORD *pdwLengthofPacket=NULL);
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\xmltransport\client\includes\executeclassmethodpacket.h ===
// ExecuteClassMethodPacket.h: interface for the CExecuteClassMethodPacket class.
//
//////////////////////////////////////////////////////////////////////

#ifndef WMI_XML_EXECUTECLASSMETHODPACKET_H
#define WMI_XML_EXECUTECLASSMETHODPACKET_H



class CExecuteClassMethodPacket : public CXMLClientPacket  
{

protected:

	HRESULT GetWhistlerBody(WCHAR **ppwszBody,DWORD *pdwLengthofPacket=NULL);

public:
	
	CExecuteClassMethodPacket(const WCHAR *pwszObjPath,const WCHAR *pwszNameSpace);
	HRESULT GetBody(WCHAR **ppwszBody,DWORD *pdwLengthofPacket=NULL);
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\xmltransport\client\includes\execquerypacket.h ===
// ExecQueryPacket.h: interface for the CExecQueryPacket class.
//
//////////////////////////////////////////////////////////////////////

#ifndef WMI_XML_EXECQUERYPACKET_H
#define WMI_XML_EXECQUERYPACKET_H


class CExecQueryPacket : public CXMLClientPacket  
{

public:
	
	HRESULT GetBody(WCHAR **ppwszBody, DWORD *pdwLengthofPacket=NULL);
	CExecQueryPacket(const WCHAR *pwszObjPath, const WCHAR *pwszNameSpace);

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\xmltransport\client\includes\enumerateinstancenamespacket.h ===
// EnumerateInstanceNamesPacket.h: interface for the CEnumerateInstanceNamesPacket class.
//
//////////////////////////////////////////////////////////////////////

#ifndef WMI_XML_ENUM_INST_NAME
#define WMI_XML_ENUM_INST_NAME


class CEnumerateInstanceNamesPacket : public CXMLClientPacket  
{
public:
	HRESULT GetBody(WCHAR **ppwszBody,DWORD *pdwLengthofPacket=NULL);
	CEnumerateInstanceNamesPacket(const WCHAR *pwszObjPath,const WCHAR *pwszNameSpace);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\xmltransport\client\includes\getclasspacket.h ===
// GetClassPacket.h: interface for the CGetClassPacket class.
//
//////////////////////////////////////////////////////////////////////

#ifndef WMI_XML_GET_CLASS_PACKET
#define WMI_XML_GET_CLASS_PACKET



class CGetClassPacket : public CXMLClientPacket  
{


public:
	CGetClassPacket(const WCHAR *pwszObjPath,const WCHAR *pwszNameSpace);

public:
	virtual HRESULT GetBody(WCHAR **ppwszBody,DWORD *pdwLengthofPacket=NULL);
	virtual HRESULT GetBodyDirect(const WCHAR *pwszXMLObjPath,DWORD dwLengthofObjPath,WCHAR **ppwszBody,DWORD *pdwLengthofPacket=NULL);
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\xmltransport\client\includes\getinstancepacket.h ===
// GetInstancePacket.h: interface for the CGetInstancePacket class.
//
//////////////////////////////////////////////////////////////////////

#ifndef WMI_XML_GET_INST_PACKET
#define WMI_XML_GET_INST_PACKET


class CGetInstancePacket : public CXMLClientPacket  
{

public:
	CGetInstancePacket(const WCHAR *pwszObjPath,const WCHAR *pwszNameSpace);

	virtual HRESULT GetBody(WCHAR **ppwszBody,DWORD *pdwLengthofPacket=NULL);
	virtual HRESULT GetBodyDirect(const WCHAR *pwszXMLObjPath,DWORD dwLengthofObjPath,WCHAR **ppwszBody,DWORD *pdwLengthofPacket=NULL);

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\xmltransport\client\includes\mapxmltowmi.h ===
#ifndef WMI_XML_MAP_XML_TO_WMI
#define WMI_XML_MAP_XML_TO_WMI

//Helper class to convert XML result into WMI objects.
//the result is as an XML STRING. but the interface that does the conversion
//NEEDS an IXMLDOMDocument*. Also, the interface itself needs to be created only
//once. thus the need for this class..

class CMapXMLtoWMI
{

public:
	CMapXMLtoWMI();
	virtual ~CMapXMLtoWMI();

	HRESULT MapXMLtoWMI(LPCWSTR pwszServername, LPCWSTR pwszNamespace,
		IXMLDOMDocument *pDoc,
		IWbemContext *pCtx,
		IWbemClassObject **ppObject);

	HRESULT MapDOMtoWMI(LPCWSTR pwszServername, LPCWSTR pwszNamespace,
		IXMLDOMNode *, IWbemContext *, IWbemClassObject **);
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\xmltransport\client\includes\modifyclasspacket.h ===
// ModifyClassPacket.h: interface for the CModifyClassPacket class.
//
//////////////////////////////////////////////////////////////////////

#ifndef WMI_XML_MODIFY_CLASS_PACKET
#define WMI_XML_MODIFY_CLASS_PACKET



class CModifyClassPacket : public CXMLClientPacket  
{
public:
	CModifyClassPacket(const WCHAR *pwszObjPath,const WCHAR *pwszNameSpace);
	HRESULT GetBody(WCHAR **ppwszBody,DWORD *pdwLengthofPacket=NULL);
	HRESULT GetBodyDirect(const WCHAR *pwszXMLObjPath,DWORD dwLengthofObjPath,WCHAR **ppwszBody,DWORD *pdwLengthofPacket=NULL);

};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\xmltransport\client\includes\modifyinstancepacket.h ===
// ModifyINSTANCEPacket.h: interface for the CModifyInstancePacket class.
//
//////////////////////////////////////////////////////////////////////

#ifndef WMI_XML_MODIFY_INST_PACKET
#define WMI_XML_MODIFY_INST_PACKET

class CModifyInstancePacket : public CXMLClientPacket  
{
public:
	CModifyInstancePacket(const WCHAR *pwszObjPath,const WCHAR *pwszNameSpace);
	HRESULT GetBody(WCHAR **ppwszBody,DWORD *pdwLengthofPacket=NULL);
	HRESULT GetBodyDirect(const WCHAR *pwszXMLObjPath,DWORD dwLengthofObjPath,WCHAR **ppwszBody,DWORD *pdwLengthofPacket=NULL);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\xmltransport\client\includes\putclasspacket.h ===
// PutClassPacket.h: interface for the CPutClassPacket class.
//
//////////////////////////////////////////////////////////////////////

#ifndef WMI_XML_PUT_CLASS_PACKET
#define WMI_XML_PUT_CLASS_PACKET



class CPutClassPacket : public CXMLClientPacket  
{
public:
	CPutClassPacket(const WCHAR *pwszObjPath,const WCHAR *pwszNameSpace);


	HRESULT GetBody(WCHAR **ppwszBody,DWORD *pdwLengthofPacket=NULL);
	HRESULT GetBodyDirect(const WCHAR *pwszXMLObjPath,DWORD dwLengthofObjPath,WCHAR **ppwszBody,DWORD *pdwLengthofPacket=NULL);
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\xmltransport\client\includes\httpconnectionagent.h ===
// HTTPConnectionAgent.h: interface for the CHTTPConnectionAgent class.
//
//////////////////////////////////////////////////////////////////////

#ifndef WMI_XML_CONNECTION_AGENT_H
#define WMI_XML_CONNECTION_AGENT_H


/*****************************************************************************************

  This is the declaration of the class CHTTPConnectionAgent.  This class is a wrapper
  class around WinInet and would be used by the xmlhttp client to send/recieved http (xml) 
  packets.

  created  a-vinrs
*****************************************************************************************/


class CHTTPConnectionAgent  
{
public:
	//stores the agent name used by http server for identification.
	static LPCWSTR s_pszAgent;

	//we will request for data in chunks of 4k - change if needed
	static const DWORD DATASIZE;

	// The list of types that we accept - TODO is this really correct
	static LPCWSTR pContentTypes[2];

	//asking unlimited number of connections per server . by default it is 2 for an HTTP 1.1 server
	static const UINT s_uConnectionsPerServer;

private:
	WCHAR *		m_pszServerName;//Server name or url 
	WCHAR *		m_pszURI;
	WCHAR *		m_pszUserName;
	WCHAR *		m_pszPasswd;

	HINTERNET	m_hRoot;//returned by InternetOpen - the root handle.(will close this later)
	HINTERNET	m_hConnect;//returned by InternetConnect
	HINTERNET	m_hOpenRequest;//returned by InternetOpenRequest

	// If this is true, it means that the 3 WinInet handles should not be closed in the destruuctor since
	// someone else (the CMyStream()) is holding on it. This is unfortunate since, WinInet handles
	// are not true NT handles, and hence we cant duplicate them.
	BOOL		m_bReleaseHandles; 
	
	//Parameters that would be used by WinInet's InternetOpen function
    DWORD		m_dwAccessType;
    WCHAR *		m_pszProxyName;
    WCHAR *		m_pszProxyBypass;
    DWORD		m_dwFlags;
	
	CRITICAL_SECTION	*m_pCriticalSection; // for thread synchronizations
	//Parameters used by InternetConnect...

	//The port to be used. default is INTERNET_INVALID_PORT_NUMBER - use default
	//port number for service specifed by m_dwService parameter.

	INTERNET_PORT m_nServerPort;

	void ResetMembers();
	void DestroyMembers();
	void InitializeMembers();

public:
		
	//The default ctor. initializes everything to 0/NULL except m_dwAccessType
	//Initializes m_dwAccessType to INTERNET_OPEN_TYPE_PRECONFIG
	CHTTPConnectionAgent();

	//Parametrized ctor - customize all WinInet parameters.
	//dwFlags - values are not very well documented.
	CHTTPConnectionAgent(WCHAR * pszHostName,
		DWORD dwAccessType, 
		WCHAR * pszProxyName, 
		WCHAR * pszProxyBypass,
		DWORD dwFlags,
		INTERNET_PORT nPort);

	//Dtor -
	virtual ~CHTTPConnectionAgent();

public:
	
	//Many ways of calling InitializeConnection depending on type of ctor used and
	//whether authentication is required
	HRESULT InitializeConnection(const WCHAR * pszServerName,
								const WCHAR * pszUserName,
								const WCHAR * pszPasswd);
	HRESULT InitializeConnection(INTERNET_PORT nPort,
								   const WCHAR * pszServerName,
								   const WCHAR * pszUserName,
								   const WCHAR * pszPasswd,
								   DWORD dwAccessType, 
								   const WCHAR * pszProxyName,
								   const WCHAR * pszProxyBypass,
								   DWORD dwFlags);

	DWORD GetFlags();

	//We are using HttpOpenRequest function to set up a HTTP request.
	//this function needs the server name without http://. so, if 
	//the servername contains "http://" this function can be used
	//to strip it - used by the class only, changes the server name - 
	//make a copy if you are using this function and want
	//to retain the original name.

	//Also, depending on whether the url contains http:// or https://
	//this function will enable/disable SSL
	HRESULT StriphttpFromServername(WCHAR **ppszServername);

	//is transport taking place using secure sockets ?
	bool IsSSLEnabled();

	//Resend request - used when you get 401 from server
	// BOOL Resend(char *pszUTF8Body,DWORD dwBodyLength,DWORD *pdwStatusCode);

	//NULL passwd cant be sent using InternetConnect !
	void SetupCredentials();

	//the http status code returned by the server
	HRESULT GetStatusCode(DWORD *pdwStatusCode);

	// If you want an IStream that is wrapped around the connection (socket)
	// and hasnt read the entire response, but holds on to the socket and reads
	// on demand when calls are made to IStream, use this function
	// Remember that if this function is used, then no other thread should
	// try to read from this socket until this particular HTTP response has
	// be read to completion
	HRESULT GetResultBodyWrappedAsIStream(IStream **ppStream);

	// If you want an IStream that is is an in-memory implementation of
	// the entire HTTP response to this request, then use this function
	// In this case, you're free to use this HTTP connection(socket) for
	// more requests immediately, since we've read the entire response
	// from the socket
	HRESULT GetResultBodyCompleteAsIStream(IStream **ppStream);

	//the result http header
	HRESULT GetResultHeader(WCHAR **ppszBuffer);
	//if you want to know size of header..
	HRESULT GetResultHeader(WCHAR **ppszBuffer,DWORD *pdwHeaderLen);
	
	//set up the verb/header and the call this function to send your data(xml packet)
	HRESULT Send(LPCWSTR pszVerb,
			   LPCWSTR pszHeader,
			   WCHAR * pszBody,
			   DWORD dwLength);

	//set/modify the server name
	HRESULT SetServerName(const WCHAR * pszServerName);

	//enable transport using secure sockets.
	HRESULT EnableSSL(bool bFlag = true);
	
	/******************************************************************************
	If authentication is required, the INTERNET_FLAG_KEEP_CONNECTION flag should be
	used in the call to HttpOpenRequest. The INTERNET_FLAG_KEEP_CONNECTION flag is 
	required for NTLM and other types of authentication in order to maintain the 
	connection while completing the authentication process. If the connection is not 
	maintained, the authentication process must be restarted with the proxy or server. 

	This is set by default by this class. you could use this function as
	SetFlags(GetFlags()|dwYourflags); Also, this call has to be made before calling the 
	InitializeConnection(...)
	*********************************************************************************/
	HRESULT SetFlags(DWORD dwFlags);

	//used to set ProxyName/ProxyBypass - default is NULL for both
	//Can alternatively use the parametrized ctor
	HRESULT SetProxyInformation(WCHAR * szProxyName,WCHAR * szProxyBypass);

	//Used to change the m_dwAccessType parameter. default value is INTERNET_OPEN_TYPE_PRECONFIG
	//Other values could be obtained by looking at help for InternetOpen(...)
	HRESULT SetAccessType(DWORD dwAccessType);
	
};

#endif // WMI_XML_CONNECTION_AGENT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\xmltransport\client\includes\putinstancepacket.h ===
// PutINSTANCEPacket.h: interface for the CPutInstancePacket class.
//
//////////////////////////////////////////////////////////////////////

#ifndef WMI_XML_PUT_INST_PACKET
#define WMI_XML_PUT_INST_PACKET



class CPutInstancePacket : public CXMLClientPacket  
{
public:
	CPutInstancePacket(const WCHAR *pwszObjPath,const WCHAR *pwszNameSpace);

	HRESULT GetBody(WCHAR **ppwszBody,DWORD *pdwLengthofPacket=NULL);
	HRESULT GetBodyDirect(const WCHAR *pwszXMLObjPath,DWORD dwLengthofObjPath,WCHAR **ppwszBody,DWORD *pdwLengthofPacket=NULL);
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\xmltransport\client\includes\mypendingstream.h ===
// MyStream.h: declaration for the CMyPendingStream class. - used by HTTPConnectionAgent
//
//////////////////////////////////////////////////////////////////////

#ifndef WMI_XML_MYPENDINGSTREAM_H
#define WMI_XML_MYPENDINGSTREAM_H

// This is a class that wraps an IStream and makes it a pending IStream.
// A "Pending IStream" is defined as an IStream on 
// which you can set the state as Pending, so that
// Subsequent calls to Read() from that IStream will return
// E_PENDING even if the wrapped IStream has data in it.
// Once we reset the Pending state to false, subsequent Read()
// calls work like normal IStream::Read() calls
// Another property of this implementation is that it always reads
// data from the underlying IStream in fixed amounts (READ_CHUNK_SIZE)
// This is because, the XML Parser asks for huge amounts of data (0xffff) from
// its underlying stream, thereby defeating our purpose of not reading
// too much data from a Socket and readin only the amount required to manufacture
// the next element in the Node factory
class CMyPendingStream : public IStream
{

private:

	// A pointer to the IStream being wrapped
	IStream *m_pStream;
	LONG	m_cRef;

	// Whether we are in a Pending state or not
	BOOL	m_bReturnPending;

	// Amount of data read at a time from the underlying IStream
	static ULONG READ_CHUNK_SIZE;
	
public:
	
	CMyPendingStream(IStream *pStream);
	virtual ~CMyPendingStream();

	void SetPending(BOOL bPending)
	{
		m_bReturnPending = bPending;
	}

public:
	// IUnknown functions
	//======================================================
	HRESULT __stdcall QueryInterface(REFIID iid,void ** ppvObject);
	ULONG __stdcall AddRef();
	ULONG __stdcall Release();


	// IStream functions
	//======================================================
	HRESULT __stdcall Read(void *pv,ULONG cb,ULONG *pcbRead);
	HRESULT __stdcall Write(void const *pv,ULONG cb,ULONG *pcbWritten);
	HRESULT __stdcall Seek(LARGE_INTEGER dlibMove,DWORD dwOrigin,ULARGE_INTEGER *plibNewPosition);
	HRESULT __stdcall SetSize(ULARGE_INTEGER libNewSize);
	HRESULT __stdcall CopyTo(IStream *pstm,ULARGE_INTEGER cb,ULARGE_INTEGER *pcbRead,ULARGE_INTEGER *pcbWritten);
	HRESULT __stdcall Commit(DWORD grfCommitFlags);
	HRESULT __stdcall Revert(void);
	HRESULT __stdcall LockRegion(ULARGE_INTEGER libOffset,ULARGE_INTEGER cb,DWORD dwLockType);
	HRESULT __stdcall UnlockRegion(ULARGE_INTEGER libOffset,ULARGE_INTEGER cb,DWORD dwLockType);
	HRESULT __stdcall Stat(STATSTG *pstatstg,DWORD grfStatFlag);
	HRESULT __stdcall Clone(IStream **ppstm);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\xmltransport\client\includes\mystream.h ===
// MyStream.h: declaration for the CMyStream class. - used by HTTPConnectionAgent
//
//////////////////////////////////////////////////////////////////////

#ifndef WMI_XML_MYSTREAM_H
#define WMI_XML_MYSTREAM_H

// This class is just an IStream wrapper around a WinInet connection
class CMyStream:public IStream
{

private:

	// The WinInet handles that we're wrapping
	HINTERNET	m_hOpenRequest;
	HINTERNET	m_hRoot;

	// COM Reference count
	LONG		m_cRef;
	
public:
	
	CMyStream();
	virtual ~CMyStream();

	// Once this function is called, we take ownership of the WinInet handles
	// The caller does not (should not) close the handles. We will do it in
	// the destructor of this stream. This is because WinInet handles are not
	// true NT Handles, and there is no API to Duplicate them
	HRESULT Initialize(HINTERNET hRoot, HINTERNET hOpenRequest);

public:
	// IUnknown functions
	//=============================
	HRESULT __stdcall QueryInterface(REFIID iid,void ** ppvObject);
	ULONG __stdcall AddRef();
	ULONG __stdcall Release();

	// IStream functions - Only Read() is actually implemented. The rest return S_OK
	//=============================
	HRESULT __stdcall Read(void *pv,ULONG cb,ULONG *pcbRead);
	HRESULT __stdcall Write(void const *pv,ULONG cb,ULONG *pcbWritten);
	HRESULT __stdcall Seek(LARGE_INTEGER dlibMove,DWORD dwOrigin,ULARGE_INTEGER *plibNewPosition);
	HRESULT __stdcall SetSize(ULARGE_INTEGER libNewSize);
	HRESULT __stdcall CopyTo(IStream *pstm,ULARGE_INTEGER cb,ULARGE_INTEGER *pcbRead,ULARGE_INTEGER *pcbWritten);
	HRESULT __stdcall Commit(DWORD grfCommitFlags);
	HRESULT __stdcall Revert(void);
	HRESULT __stdcall LockRegion(ULARGE_INTEGER libOffset,ULARGE_INTEGER cb,DWORD dwLockType);
	HRESULT __stdcall UnlockRegion(ULARGE_INTEGER libOffset,ULARGE_INTEGER cb,DWORD dwLockType);
	HRESULT __stdcall Stat(STATSTG *pstatstg,DWORD grfStatFlag);
	HRESULT __stdcall Clone(IStream **ppstm);

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\xmltransport\client\includes\nodefact.h ===
#ifndef WMI_XML_NODE_FACT_H
#define WMI_XML_NODE_FACT_H

// This is a class that is used to manufacture XML Elements
// from an CMyPendingStream source of data
// This type of elements manufactured from the source of data
// is configurable. It is specified as a list of element names
// that we are interested in manufacturing. The whole purpose of using
// this Node factory is to prevent reading all the XML data from the input
// source (typically a WinInet Socket) and hence reduce memory consumption.
// This is useful in supporting the case where there is a huge amount of data
// in the source, and we dont want to parse all of it at once, and instead want
// to parse it on demand from the user. This typically occurs when 
// there is a huge WMI Instance/Class Enumeration. The result of such an
// enumeration is an IEnumWbemClassObject from which the user "pulls"
// data by calling Next(). This user action is used to manufacture
// XML Nodes from the input source. The InputSource is a CMyPendingStream.
// This implements the IStream functions and adds one more function,
// SetPending() its list of members. Once this function is called, all
// subsequent calls to Read() return E_PENDING until the pending state is reset
// This works in conjunction with the IXMLParser implementation from Microsoft
// as follows:
// 1. The user wraps the data source (typically a WinInet Handle) in a CMyPendingStream
//		and gives the CMyPendingStream to both the IXMLParser object and 
//		to this (IXMLNodeFactory) object. 
// 2. The user of the Parser calls Run(-1) on it, upon which the Parser asks for data from
//		the CMyPendingStream in chunks (the size of which is decided by a static member in CMyPendingStream
// 3. As it reads the data, the IXMLParser also starts calling into the IXMLNodeFactory. The
//		IXMLNodeFactory, as soon as the end of an Element that we're interested in is reached, sets
//		the state of the CMyPendingStream to "pending". Hence at this point, the IXMLNodeFactory
//		has manufactured 1 object (XML Document) of the element that we're interested int.
// 4. Further calls from the IXMLParser to the CMyPendingStream::Read() return E_PENDING and hence
//		the IXMLParser::Run() returns to the caller with E_PENDING.
// 5. When the IXMLParser::Run() returns to the user, he calls IXMLNodeFactory::GetDocument() to get
//		the XML Object that was just manufactured.
// 6. The user goes back to step 2. if he needs more objects (XML Documents) from the data source
// It is possible that is the XML Elements being manufactured are extremely small, then a given call to
// IXMLParser::Run() by the client will result in more than one object being manufactured by the factory
// This is the case when the amount of data read at a time from CMyPendingStream is much more than the 
// encoding of 1 object. Hence we need the m_ppDocuments to store the extra objects that are manufactured
class MyFactory : public IXMLNodeFactory
{
	LONG m_cRef;					// COM Ref Count
	CMyPendingStream *m_pStream;	// The stream of XML data. This can be put into a Pending state

	IXMLDOMDocument **m_ppDocuments;// The resulting documents
	DWORD m_dwMaxNumDocuments;		// # of elements in the above array
	DWORD m_dwNumDocuments;			// # of documents in the above array - ie., #of elements that have data
	DWORD m_dwAvailableDocIndex;	// If GetDocument() is called we give out this document

	IXMLDOMDocument *m_pCurrentDocument; // Just a holder for the current document being parsed

	LPWSTR *m_pszElementNames;		// The factory manufactures elements of these names. These are the elemtns that we're "interested" in
	DWORD m_dwNumElements;			// Number of elements in the above array
	
	// These are the values of the last pragma's if any
	LONG m_lClassFlags;
	LONG m_lInstanceFlags;
	BSTR *m_pstrDeleteList;
	BSTR m_strNamespace;


	// Adds a document to the list in m_ppDocuments
	HRESULT AddDocumentToList(IXMLDOMDocument *pNewDocument);

	// Helper functions for manufacttring XML DOM Elements, adding attributes, setting element values etc.
	HRESULT AddChildNode(IXMLDOMNode *pNodeParent, XML_NODE_INFO **aNodeInfo, USHORT cNumRecs, IXMLDOMNode **ppCurrentNode);
	HRESULT AddPCDATA(IXMLDOMNode *pNodeParent, XML_NODE_INFO **aNodeInfo);
	HRESULT AddCDATA(IXMLDOMNode *pNodeParent, XML_NODE_INFO **aNodeInfo);
	HRESULT AddAttributes(IXMLDOMElement *pElement, XML_NODE_INFO **aNodeInfo, USHORT cNumRecs);

	// Checks to see if the specified element is one of the elements
	// that needs to be manufactured from the factory
	BOOL IsInterestingElement(LPCWSTR pszElementName);

public:
	MyFactory(CMyPendingStream *pStream);
	virtual ~MyFactory();

	// Sets the names of the elements (tag-names) that we're interested in manufacturing
	HRESULT SetElementNames(LPCWSTR *pszElementNames, DWORD dwNumElements);

	// Get's the next document manufactured by the factory
	HRESULT GetDocument(IXMLDOMDocument **ppDocument);

	// Manufactures a document and throws it away
	HRESULT SkipNextDocument();

	// The following are the IXMLNodeFactory functions
	//====================================================
	HRESULT STDMETHODCALLTYPE NotifyEvent(
            IXMLNodeSource* pSource,
            XML_NODEFACTORY_EVENT iEvt)
	{
		// We dont implement this
		return S_OK;
	}

    HRESULT STDMETHODCALLTYPE BeginChildren(
            IXMLNodeSource* pSource, 
            XML_NODE_INFO* pNodeInfo);
			
            
    HRESULT STDMETHODCALLTYPE EndChildren(
            IXMLNodeSource* pSource,
            BOOL fEmpty,
            XML_NODE_INFO* pNodeInfo);


    HRESULT STDMETHODCALLTYPE Error(
            IXMLNodeSource* pSource,
            HRESULT hrErrorCode,
            USHORT cNumRecs,
            XML_NODE_INFO __RPC_FAR **aNodeInfo);


    HRESULT STDMETHODCALLTYPE CreateNode( 
            IXMLNodeSource __RPC_FAR *pSource,
            PVOID pNodeParent,
            USHORT cNumRecs,
            XML_NODE_INFO __RPC_FAR **aNodeInfo);

	// IUnknown Functions
	//=======================================
	STDMETHODIMP QueryInterface (
		IN REFIID riid,
		OUT LPVOID *ppv
	)
	{
		*ppv=NULL;

		if (IID_IUnknown==riid)
			*ppv = reinterpret_cast<IUnknown*>(this);
		else if (IID_IXMLNodeFactory==riid)
			*ppv = (IXMLNodeFactory *)this;

		if (NULL!=*ppv)
		{
			((LPUNKNOWN)*ppv)->AddRef();
			return NOERROR;
		}

		return ResultFromScode(E_NOINTERFACE);
	}

	STDMETHODIMP_(ULONG) AddRef(void)
	{
		InterlockedIncrement(&m_cRef);
		return m_cRef;
	}

	STDMETHODIMP_(ULONG) Release(void)
	{
		InterlockedDecrement(&m_cRef);
		if (0L!=m_cRef)
			return m_cRef;
		delete this;
		return 0;
	}
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\xmltransport\client\mainsources\makefile.inc ===
############################################################################
#
#   Copyright (C) 1999, Microsoft Corporation.
#
#   All rights reserved.
#
############################################################################

!INCLUDE $(_NTDRIVE)$(_NTROOT)\WMI\COMMON\makefile.cmn
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\xmltransport\client\includes\xmltransportclienthelper.h ===
#ifndef WMI_XML_TRANSPORT_CLIENT_HELPER_H
#define WMI_XML_TRANSPORT_CLIENT_HELPER_H

//This is the main header file that includes all necessary header files
//similar to StdAfx.h used in mfc

// Insert your headers here


#include <windows.h>
#include <objbase.h>
#include <objidl.h>
#include <initguid.h>
#include <tchar.h>
#include <stdio.h>
#include <objidl.h>
#include <olectl.h>
#include <Wbemidl.h>
#include <wininet.h>
#include <Oaidl.h>
#include <time.h>
#include <wchar.h>
#include <wbemcli.h>
#include <wmiutils.h>

#include "HTTPConnectionAgent.h"
#include "genlex.h"
#include "opathlex.h"
#include "objpath.h"
#include "wmiconv.h"
#include "wmi2xml.h"
#include "Utils.h"
#include "MapXMLtoWMI.h"


// These are globals used by the library and need to be initialized 
// by a call to InitWMIXMLClientLibrary and deallocated by a call
// to UninitWMIXMLClientLibrary
extern BSTR WMI_XML_STR_IRETURN_VALUE;
extern BSTR WMI_XML_STR_NAME;
extern BSTR WMI_XML_STR_CODE;
extern BSTR WMI_XML_STR_ERROR;
extern BSTR WMI_XML_STR_VALUE;

// The 3 commonly used IWbemContext objects
extern IWbemContext *g_pLocalCtx;
extern IWbemContext *g_pNamedCtx;
extern IWbemContext *g_pAnonymousCtx;

// These functions are used to initialize and uninitialize the globals
// The Init function has to be called exactly once before using the library
// The Uninit function has to be called once and no library calls should be made after that
HRESULT InitWMIXMLClientLibrary();
HRESULT UninitWMIXMLClientLibrary();


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\xmltransport\client\includes\xmlclientpacketfactory.h ===
// XMLClientPacketFactory.h: interface for the CXMLClientPacketFactory class.
//
//////////////////////////////////////////////////////////////////////

#ifndef WMI_XML_PACKET_FACTORY_H
#define WMI_XML_PACKET_FACTORY_H


//A Class meant for createing WMI XML  Request packets .

class CXMLClientPacketFactory  
{

public:
	CXMLClientPacketFactory();
	
	//The packet factory needs only one function - CreateXMLPacket.  It creates the appropriate 
	//packet class depending on the CIM operation specified as the arguement.

	//FOR THE SAKE OF AVOIDING DEFAULT FUNCTION ARGUEMENTS, WE HAVE SO MANY OVERLOADED VERSIONS OF THIS FUNCTION.
	//It would have been simpler if all WMI apis took a single structure as the parameter rather than 
	//n different kinds of arguments. this would also have been in keeping with the normal style of windows APIs..

	CXMLClientPacket * CreateXMLPacket(const WCHAR *pwszLocale,const WCHAR *pwszMethodName,const WCHAR *pwszObjPath,
		const WCHAR *pwszNameSpace);

	CXMLClientPacket *CreateXMLPacket(const WCHAR *pwszLocale,const WCHAR *pwszMethodName,const WCHAR *pwszObjPath,
		const WCHAR *pwszNameSpace,
		IWbemContext *pCtx,IWbemClassObject *pWbemClassObject,
		bool bLocalOnly,bool bIncludeQualifier,bool bDeepInheritance,bool bClassOrigin);

	CXMLClientPacket *CreateXMLPacket(const WCHAR *pwszLocale,const WCHAR *pwszMethodName,const WCHAR *pwszObjPath,
		const WCHAR *pwszNameSpace,
		IWbemContext *pCtx,bool bLocalOnly,bool bIncludeQualifier,
		bool bDeepInheritance,bool bClassOrigin);
	
	CXMLClientPacket *CreateXMLPacket(const WCHAR *pwszLocale,const WCHAR *pwszMethodName,const WCHAR *pwszObjPath,
		const WCHAR *pwszNameSpace,
		IWbemContext *pCtx);

	CXMLClientPacket *CreateXMLPacket(const WCHAR *pwszLocale,const WCHAR *pwszMethodName,const WCHAR *pwszObjPath,
		const WCHAR *pwszNameSpace,
		IWbemContext *pCtx,IWbemClassObject *pWbemClassObject);

	virtual ~CXMLClientPacketFactory();

};

#endif // WMI_XML_PACKET_FACTORY_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\xmltransport\client\mainsources\actualops.cpp ===
// XMLWbemServices.cpp: implementation of the CXMLWbemServices class.
// our implementation of IWbemServices
//////////////////////////////////////////////////////////////////////

#include "XMLProx.h"
#include "XMLClientPacket.h"
#include "XMLClientPacketFactory.h"
#include "SinkMap.h"
#include "MapXMLtoWMI.h"
#include "XMLWbemServices.h"
#include "XMLEnumWbemClassObject.h"
#include <xmlparser.h>
#include "MyPendingStream.h"
#include "nodefact.h"
#include "XMLEnumWbemClassObject2.h"
#include "URLParser.h"
#include "XMLWbemCallResult.h"

/****************************************************************************************************
			The Actual functions.....
****************************************************************************************************/
	
HRESULT CXMLWbemServices::Actual_GetInstance(const BSTR strObjectPath,
											 LONG lFlags, IWbemContext *pCtx,
											 IWbemClassObject **ppObject)
{
	
	WaitForSingleObject(m_hMutex,INFINITE);

	HRESULT hr = S_OK;
	*ppObject = NULL;

		
	//by Default, LocalOnly is true,and others are false for GetInstance (CIM Spec)
	//IncludeClassOrigin , though false by default is sent as true here as there is 
	//no flag in this call that could turn it on.
	CXMLClientPacket *pPacket = NULL;
	pPacket = g_oXMLClientPacketFactory.CreateXMLPacket(m_pwszLocale, L"GetInstance",
		(LPWSTR)strObjectPath, m_pwszNamespace, pCtx, false, true, false, true);

	IStream *pResponse = NULL;
	if(SUCCEEDED(hr = SendRequestAndGetResponse(pPacket, &pResponse)))
	{
		HRESULT hErrCode = WBEM_NO_ERROR;
		IXMLDOMDocument *pResponseDoc = NULL;
		if(SUCCEEDED(hr = ParseXMLResponsePacket(pResponse, &pResponseDoc, &hErrCode)))
		{
			if((hr = hErrCode) == WBEM_NO_ERROR)
				hr = m_MapXMLtoWMI.MapXMLtoWMI(m_pwszBracketedServername, m_pwszNamespace, pResponseDoc, NULL, ppObject);
			pResponseDoc->Release();
		}
		pResponse->Release();
	}
	
	delete pPacket;
	ReleaseMutex(m_hMutex);
	return hr;
}

HRESULT CXMLWbemServices::Actual_GetClass(const BSTR strObjectPath,LONG lFlags,IWbemContext *pCtx,
										  IWbemClassObject **ppObject)
{
	WaitForSingleObject(m_hMutex,INFINITE);

	HRESULT hr = WBEM_NO_ERROR;
	CXMLClientPacket *pPacket = NULL;
	//LocalOnly and IncludeQualifiers are true by default (CIM Spec), IncludeClassOrigin is 
	//passes as true here as there is no flag that could turn it on
	if(m_ePathstyle == NOVAPATH)
		pPacket = g_oXMLClientPacketFactory.CreateXMLPacket(m_pwszLocale,
					L"GetClass", (LPWSTR)strObjectPath ,
					m_pwszNamespace,pCtx,
					false,true,false,true);

	IStream *pResponse = NULL;
	if(SUCCEEDED(hr = SendRequestAndGetResponse(pPacket, &pResponse)))
	{
		HRESULT hErrCode = WBEM_NO_ERROR;
		IXMLDOMDocument *pResponseDoc = NULL;
		if(SUCCEEDED(hr = ParseXMLResponsePacket(pResponse, &pResponseDoc, &hErrCode)))
		{
			if((hr = hErrCode) == WBEM_NO_ERROR)
				hr = m_MapXMLtoWMI.MapXMLtoWMI(m_pwszBracketedServername, m_pwszNamespace, pResponseDoc, NULL, ppObject); 
			pResponseDoc->Release();
		}
		pResponse->Release();
	}
	
	delete pPacket;
	ReleaseMutex(m_hMutex);
	return hr;
}

HRESULT CXMLWbemServices::Actual_DeleteClass(const BSTR strClass,LONG lFlags,IWbemContext *pCtx)
{
	WaitForSingleObject(m_hMutex,INFINITE);
	
	HRESULT hr = WBEM_NO_ERROR;

	CXMLClientPacket *pPacket = NULL;
	if(m_ePathstyle == NOVAPATH)
		pPacket = g_oXMLClientPacketFactory.CreateXMLPacket(
							m_pwszLocale,L"DeleteClass",
							(LPWSTR) strClass,m_pwszNamespace);

	IStream *pResponse = NULL;
	if(SUCCEEDED(hr = SendRequestAndGetResponse(pPacket, &pResponse)))
	{
		IXMLDOMDocument *pResponseDoc = NULL;
		if(SUCCEEDED(ParseXMLResponsePacket(pResponse, &pResponseDoc, &hr)))
			pResponseDoc->Release();
		pResponse->Release();
	}

	delete pPacket;
	ReleaseMutex(m_hMutex);
	return hr;
}

HRESULT CXMLWbemServices::Actual_DeleteInstance(const BSTR strObjectPath, LONG lFlags,IWbemContext *pCtx)
{
	WaitForSingleObject(m_hMutex,INFINITE);

	HRESULT hr = WBEM_NO_ERROR;
	CXMLClientPacket *pPacket = NULL;

	if(m_ePathstyle == NOVAPATH)
		pPacket = g_oXMLClientPacketFactory.CreateXMLPacket(m_pwszLocale,L"DeleteInstance",
			(LPWSTR)strObjectPath,m_pwszNamespace);

	IStream *pResponse = NULL;
	if(SUCCEEDED(hr = SendRequestAndGetResponse(pPacket, &pResponse)))
	{
		IXMLDOMDocument *pResponseDoc = NULL;
		if(SUCCEEDED(ParseXMLResponsePacket(pResponse, &pResponseDoc, &hr)))
			pResponseDoc->Release();
		pResponse->Release();
	}

	delete pPacket;
	ReleaseMutex(m_hMutex);
	return hr;
}

HRESULT CXMLWbemServices::Actual_CreateClassEnum(const BSTR strSuperclass, 
												LONG lFlags,  
												IWbemContext *pCtx, 
												IEnumWbemClassObject *pEnum,
												bool bEnumTypeDedicated)
{
	bool bDeep = true;
	if(WBEM_FLAG_SHALLOW & lFlags) // Shallow
		bDeep = false;

	// Form the request packet
	CXMLClientPacket *pPacket = NULL;
	if(m_ePathstyle == NOVAPATH)
		pPacket = g_oXMLClientPacketFactory.CreateXMLPacket(m_pwszLocale,L"EnumerateClasses",
			(LPWSTR)strSuperclass,m_pwszNamespace,pCtx,NULL,false,true,bDeep,true);	
			
	if(NULL == pPacket)
		return WBEM_E_OUT_OF_MEMORY;

	HRESULT hr = WBEM_NO_ERROR;
	// If this is a dedicated enumeration, then we dont need to wait for any mutex since
	// we're going to open a new connection
	//======================================================================================
	if(bEnumTypeDedicated)
	{
		// Create a HTTP Connection Agent and initialize it
		//===================================================
		CHTTPConnectionAgent t_HttpAgent;
		if(SUCCEEDED(hr = t_HttpAgent.InitializeConnection(m_pwszServername,m_pwszUser,m_pwszPassword)))
		{
			// Set the proxy information on the connection
			m_pConnectionAgent->SetProxyInformation(m_pwszProxyName, m_pwszProxyBypass);

			if(SUCCEEDED(hr = SendPacket(pPacket, &t_HttpAgent)))
			{
				// Send the request
				IStream *pWrappedResponse = NULL;
				if(SUCCEEDED(hr = t_HttpAgent.GetResultBodyWrappedAsIStream(&pWrappedResponse)))
				{
					if(!pWrappedResponse)
						hr = WBEM_E_FAILED;
					else
					{
						hr = ((CXMLEnumWbemClassObject2*)pEnum)->SetResponse(pWrappedResponse);
						pWrappedResponse->Release();
					}
				}
			}
		}
		else
			hr = WBEM_E_OUT_OF_MEMORY;

		if(FAILED(hr))
			((CXMLEnumWbemClassObject2*)pEnum)->AcceptFailure(hr);
	}
	else
	{
		WaitForSingleObject(m_hMutex,INFINITE);

		IStream *pResponse = NULL;
		if(SUCCEEDED(hr = SendRequestAndGetResponse(pPacket, &pResponse)))
		{
			IXMLDOMDocument *pResponseDoc = NULL;
			HRESULT hErrCode = WBEM_NO_ERROR;
			if(SUCCEEDED(hr = ParseXMLResponsePacket(pResponse, &pResponseDoc, &hErrCode)))
			{
				hr = hErrCode;
				if(SUCCEEDED(hr))
				{
					hr = ((CXMLEnumWbemClassObject*)pEnum)->SetResponse(pResponseDoc);
				}

				pResponseDoc->Release();
			}
			pResponse->Release();
		}
		if(FAILED(hr))
				((CXMLEnumWbemClassObject*)pEnum)->AcceptFailure(hr);

		ReleaseMutex(m_hMutex);
	}

	delete pPacket;
	return SUCCEEDED(hr) ? WBEM_S_NO_ERROR:hr;
}

HRESULT CXMLWbemServices::Actual_CreateInstanceEnum(const BSTR strClass, 
													LONG lFlags,
													IWbemContext *pCtx,
													IEnumWbemClassObject *pEnum,
													bool bEnumTypeDedicated)
{
	bool bDeep = false;
	if(WBEM_FLAG_DEEP & lFlags) //Deep 
		bDeep = true;

	// Form the request packet
	CXMLClientPacket *pPacket = NULL;
	if(m_ePathstyle == NOVAPATH)
		pPacket = g_oXMLClientPacketFactory.CreateXMLPacket(m_pwszLocale,L"EnumerateInstances",
			(LPWSTR) strClass,m_pwszNamespace,pCtx,NULL,false,true,bDeep,true);
			
	if(NULL == pPacket)
		return WBEM_E_OUT_OF_MEMORY;

	HRESULT hr = WBEM_NO_ERROR;
	// If this is a dedicated enumeration, then we dont need to wait for any mutex since
	// we're going to open a new connection
	//======================================================================================
	if(bEnumTypeDedicated)
	{
		// Create a HTTP Connection Agent and initialize it
		//===================================================
		CHTTPConnectionAgent t_HttpAgent;
		if(SUCCEEDED(hr = t_HttpAgent.InitializeConnection(m_pwszServername,m_pwszUser,m_pwszPassword)))
		{
			// Set the proxy information on the connection
			m_pConnectionAgent->SetProxyInformation(m_pwszProxyName, m_pwszProxyBypass);

			if(SUCCEEDED(hr = SendPacket(pPacket, &t_HttpAgent)))
			{
				// Send the request
				IStream *pWrappedResponse = NULL;
				if(SUCCEEDED(hr = t_HttpAgent.GetResultBodyWrappedAsIStream(&pWrappedResponse)))
				{
					if(!pWrappedResponse)
						hr = WBEM_E_FAILED;
					else
					{
						hr = ((CXMLEnumWbemClassObject2*)pEnum)->SetResponse(pWrappedResponse);
						pWrappedResponse->Release();
					}
				}
			}
		}
		else
			hr = WBEM_E_OUT_OF_MEMORY;

		if(FAILED(hr))
			((CXMLEnumWbemClassObject2*)pEnum)->AcceptFailure(hr);
	}
	else
	{
		WaitForSingleObject(m_hMutex,INFINITE);

		IStream *pResponse = NULL;
		if(SUCCEEDED(hr = SendRequestAndGetResponse(pPacket, &pResponse)))
		{
			IXMLDOMDocument *pResponseDoc = NULL;
			HRESULT hErrCode = WBEM_NO_ERROR;
			if(SUCCEEDED(hr = ParseXMLResponsePacket(pResponse, &pResponseDoc, &hErrCode)))
			{
				hr = hErrCode;
				if(SUCCEEDED(hr))
				{
					hr = ((CXMLEnumWbemClassObject*)pEnum)->SetResponse(pResponseDoc);
				}

				pResponseDoc->Release();
			}
			pResponse->Release();
		}

		if(FAILED(hr))
				((CXMLEnumWbemClassObject*)pEnum)->AcceptFailure(hr);

		ReleaseMutex(m_hMutex);
	}

	delete pPacket;
	return SUCCEEDED(hr) ? WBEM_S_NO_ERROR:hr;

}

HRESULT CXMLWbemServices::Actual_ExecQuery(const BSTR strQueryLanguage, const BSTR strQuery, LONG lFlags, IWbemContext *pCtx,  
						IEnumWbemClassObject *pEnum)
{
	WaitForSingleObject(m_hMutex,INFINITE);
	
	CXMLClientPacket *pPacket = NULL;
	if(m_ePathstyle == NOVAPATH)
		pPacket = g_oXMLClientPacketFactory.CreateXMLPacket(m_pwszLocale,L"ExecQuery",
			NULL,m_pwszNamespace,pCtx);

	if(!pPacket)
		return E_OUTOFMEMORY;

	HRESULT hr = WBEM_NO_ERROR;
	if(SUCCEEDED(hr = pPacket->SetFlags(lFlags)))
	{
		if(SUCCEEDED(pPacket->SetQueryLanguage((LPWSTR)strQueryLanguage)))
		{
			if(SUCCEEDED(pPacket->SetQueryString((LPWSTR)strQuery)))
			{
				IStream *pResponse = NULL;
				if(SUCCEEDED(hr = SendRequestAndGetResponse(pPacket, &pResponse)))
				{
					HRESULT hErrCode = WBEM_NO_ERROR;
					IXMLDOMDocument *pResponseDoc = NULL;
					if(SUCCEEDED(hr = ParseXMLResponsePacket(pResponse, &pResponseDoc, &hErrCode)))
					{
						if(SUCCEEDED(hErrCode))
							hr = ((CXMLEnumWbemClassObject*)pEnum)->SetResponse(pResponseDoc);
						else 
							hr = hErrCode;
						pResponseDoc->Release();
					}
					pResponse->Release();
				}
			}
		}
	}

	if(FAILED(hr))
		((CXMLEnumWbemClassObject*)pEnum)->AcceptFailure(hr);
	
	delete pPacket;
	ReleaseMutex(m_hMutex);
	return SUCCEEDED(hr) ? WBEM_S_NO_ERROR:hr;
}

HRESULT CXMLWbemServices::Actual_OpenNamespace(const BSTR strNamespace, LONG lFlags, IWbemContext *pCtx,
		IWbemServices **ppWorkingNamespace)
{
	HRESULT hr = WBEM_NO_ERROR;

	CXMLWbemServices *pClone = NULL;
	pClone = new CXMLWbemServices();

	if(NULL == pClone)
	{
		*ppWorkingNamespace = NULL;
		hr = WBEM_E_OUT_OF_MEMORY;
	}
	else
	{
		// Concatenate the namespace to the current IWbemServices namespace
		LPWSTR pszNewNamespace = NULL;
		if(pszNewNamespace = new WCHAR[wcslen(m_pwszNamespace) + wcslen(strNamespace) + 2])
		{
			wcscpy(pszNewNamespace, m_pwszNamespace);
			wcscat(pszNewNamespace, L"\\");
			wcscat(pszNewNamespace, strNamespace);

			if(SUCCEEDED(hr = pClone->Initialize(m_pwszServername, 
									pszNewNamespace,
									m_pwszUser, m_pwszPassword, m_pwszLocale,
									m_lSecurityFlags, m_pwszAuthority,pCtx,
									m_pwszOptionsResponse, m_ePathstyle)))
			{
				// No need to AddRef() it since it is created with a refcount of 1
				*ppWorkingNamespace = pClone;
			}
			else
				delete pClone;

			delete [] pszNewNamespace;
		}
		else
			hr = WBEM_E_OUT_OF_MEMORY;

	}

	return hr;
}

HRESULT CXMLWbemServices::Actual_PutClass(IWbemClassObject *pObject,
										  LONG lFlags, 
										  IWbemContext *pCtx)
{
	WaitForSingleObject(m_hMutex,INFINITE);
	
	CXMLClientPacket *pPacket = NULL;
	//Find out if user wants to modify class or create class
	if((!(lFlags^WBEM_FLAG_UPDATE_ONLY))||
		(!(lFlags^WBEM_FLAG_UPDATE_SAFE_MODE))||
		(!(lFlags^WBEM_FLAG_UPDATE_FORCE_MODE)))
	{
		//Update only 
		if(m_ePathstyle == NOVAPATH)
			pPacket = g_oXMLClientPacketFactory.CreateXMLPacket(m_pwszLocale,L"ModifyClass",
				NULL,m_pwszNamespace,pCtx,pObject);
	}
	else
	{
		if(m_ePathstyle == NOVAPATH)
			pPacket = g_oXMLClientPacketFactory.CreateXMLPacket(m_pwszLocale,L"CreateClass",
				NULL,m_pwszNamespace,pCtx,pObject);
	}

	HRESULT hr = WBEM_NO_ERROR;
	if(pPacket)
	{
		if(SUCCEEDED(hr = pPacket->SetFlags(lFlags)))
		{
			IStream *pResponse = NULL;
			if(SUCCEEDED(hr = SendRequestAndGetResponse(pPacket, &pResponse)))
			{
				HRESULT hErrCode = WBEM_NO_ERROR;
				IXMLDOMDocument *pResponseDoc = NULL;
				if(SUCCEEDED(hr = ParseXMLResponsePacket(pResponse, &pResponseDoc, &hErrCode)))
				{	
					hr = hErrCode;
					pResponseDoc->Release();
				}
				pResponse->Release();
			}
		}
	}
	else
		hr = E_OUTOFMEMORY;

	delete pPacket;
	ReleaseMutex(m_hMutex);
	return hr;
}

HRESULT CXMLWbemServices::Actual_PutInstance(IWbemClassObject *pObject,LONG lFlags, 
											IWbemContext *pCtx)
{
	WaitForSingleObject(m_hMutex,INFINITE);
	
	CXMLClientPacket *pPacket = NULL;
	//Find out if user wants to modify class or create class
	if(!(lFlags^WBEM_FLAG_UPDATE_ONLY))
	{
		//Update only 
		if(m_ePathstyle == NOVAPATH)
			pPacket = g_oXMLClientPacketFactory.CreateXMLPacket(m_pwszLocale,L"ModifyInstance",
				NULL,m_pwszNamespace,pCtx,pObject,false,true,false,true);
	}
	else
	{
		if(m_ePathstyle == NOVAPATH)
			pPacket = g_oXMLClientPacketFactory.CreateXMLPacket(m_pwszLocale,L"CreateInstance",
				NULL,m_pwszNamespace,pCtx,pObject,false,true,false,true);
	}

	HRESULT hr = WBEM_NO_ERROR;
	if(pPacket)
	{
		if(SUCCEEDED(hr = pPacket->SetFlags(lFlags)))
		{
			IStream *pResponse = NULL;
			if(SUCCEEDED(hr = SendRequestAndGetResponse(pPacket, &pResponse)))
			{
				HRESULT hErrCode = WBEM_NO_ERROR;
				IXMLDOMDocument *pResponseDoc = NULL;
				if(SUCCEEDED(hr = ParseXMLResponsePacket(pResponse, &pResponseDoc, &hErrCode)))
				{	
					hr = hErrCode;
					pResponseDoc->Release();
				}
				pResponse->Release();
			}
		}
	}
	else
		hr = E_OUTOFMEMORY;

	delete pPacket;
	ReleaseMutex(m_hMutex);
	return hr;
}

HRESULT CXMLWbemServices::Actual_ExecMethod(const BSTR strObjectPath, const BSTR strMethodName,  long lFlags, 
											IWbemContext *pCtx,IWbemClassObject *pInParams, 
											IWbemClassObject **ppOutParams)
{
	WaitForSingleObject(m_hMutex,INFINITE);
	
	HRESULT hr = WBEM_NO_ERROR;
	ePATHTYPE ePathType = INVALIDOBJECTPATH;
	ParsePath(strObjectPath,&ePathType);

	if( ePathType == INVALIDOBJECTPATH)
		hr = WBEM_E_INVALID_PARAMETER;
	else
	{
		CXMLClientPacket *pPacket = NULL;
		//Find out if user wants to Execute method on class or instance
		if(ePathType == INSTANCEPATH)
		{
			if(m_ePathstyle == NOVAPATH)
				pPacket = g_oXMLClientPacketFactory.CreateXMLPacket(m_pwszLocale,L"ExecuteInstanceMethod",
					(LPWSTR) strObjectPath,m_pwszNamespace,pCtx,pInParams);
		}
		else
		{
			if(m_ePathstyle == NOVAPATH)
				pPacket = g_oXMLClientPacketFactory.CreateXMLPacket(m_pwszLocale,L"ExecuteClassMethod",
					(LPWSTR) strObjectPath,m_pwszNamespace,pCtx,pInParams);
		}

		if(NULL == pPacket)
			hr = E_OUTOFMEMORY;
		else
		{
			if(SUCCEEDED(hr = pPacket->SetFlags(lFlags)))
			{
				if(SUCCEEDED(hr = pPacket->SetMethod((LPWSTR)strMethodName)))
				{
					IStream *pResponse = NULL;
					if(SUCCEEDED(hr = SendRequestAndGetResponse(pPacket, &pResponse)))
					{
						HRESULT hErrCode = WBEM_NO_ERROR;
						IXMLDOMDocument *pResponseDoc = NULL;
						if(SUCCEEDED(hr = ParseXMLResponsePacket(pResponse, &pResponseDoc, &hErrCode)))
						{
							if(SUCCEEDED(hr = hErrCode))
								hr = m_MapXMLtoWMI.MapXMLtoWMI(m_pwszBracketedServername, m_pwszNamespace, pResponseDoc, NULL, ppOutParams);
							pResponseDoc->Release();
						}
						pResponse->Release();
					}
				}
			}
			delete pPacket;
		}
	}

	
	ReleaseMutex(m_hMutex);
	return hr;

}


HRESULT CXMLWbemServices::SendRequestAndGetResponse(CXMLClientPacket *pPacket, IStream **ppStream)
{
	if(!pPacket)
		return WBEM_E_FAILED;

	HRESULT hr = WBEM_E_FAILED;
	if(SUCCEEDED(hr = SendPacket(pPacket)))
		hr = m_pConnectionAgent->GetResultBodyCompleteAsIStream(ppStream);
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\xmltransport\client\includes\utils.h ===
#ifndef WMI_XMLHTTPCLIENT_UTILS_H
#define WMI_XMLHTTPCLIENT_UTILS_H
//////////////////////////////////////////////////////////////////////////
// Utility functions
//////////////////////////////////////////////////////////////////////////
/******************************************************************************************
	GENERAL #defines which could be used by everybody. 		
******************************************************************************************/

#define RELEASEINTERFACE(X) if(NULL != X)\
		X->Release(); 

#define RELEASE_AND_NULL_INTERFACE(X) if(NULL != X)\
		X->Release(); \
		X = NULL;

#define WRITETOSTREAM(X,S) (X)->Write(S, wcslen(S)*sizeof(WCHAR), NULL);
#define WRITEBSTRTOSTREAM(X,S) (X)->Write(S, SysStringLen(S)*sizeof(WCHAR), NULL);

#define DEDICATEDENUMPROPERTY	L"dedicatedHTTPConnection"
#define PROXYNAMEPROPERTY		L"ProxyName"
#define PROXYBYPASSPROPERTY		L"ProxyBypass"

/******************************************************************************************/

//This was a macro, but changed it to a function to enable debugging...
//used to delete a WCHAR string allocated on the heap and initialize the ptr to NULL
void RESET(WCHAR *&X);

void RESET(LPBYTE &X);

void FreeString(WCHAR *&Str);


HRESULT AssignString(WCHAR ** ppszTo,const WCHAR * pszFrom);
HRESULT AssignBSTRtoWCHAR(LPWSTR *ppwszTo,BSTR strBstring);

DWORD ConvertLPWSTRToUTF8(LPCWSTR theWcharString, ULONG lNumberOfWideChars, LPSTR * lppszRetValue);

// COnverts an IWbemContext object to XML
HRESULT ConvertContextObjectToXMLStream(IStream *pStream, IWbemContext *pCtx);

//need to parse the response packet for
//1. check if error occured
//2. present only the data related info to the IWbemClassObject
HRESULT ParseXMLResponsePacket(IStream *pXMLPacket, IXMLDOMDocument **ppDoc, HRESULT *phErrCode);
HRESULT GetHresultfromXMLPacket(IStream *pPacket, HRESULT *hres);

//map cim errors to wbem errors. mappings documented in requirement spec - 7.5.4
HRESULT MapCimErrToWbemErr(DWORD dwCimErrCode, HRESULT *pWbemErrCode);

//Try to map http error to wbem error. return WBEM_E_FAILED for error codes which cant be
//mapped exactly.
HRESULT MapHttpErrtoWbemErr(DWORD dwResultStatus);

// Gets the specified BSTR attribute from an XML Element
HRESULT GetBstrAttribute(IXMLDOMNode *pNode, const BSTR strAttributeName, BSTR *pstrAttributeValue);

// Takes a byte array and creates an IStream Variant from it, suitable
// for use in a call to IXMLDOMDocument::load()
HRESULT EncodeResponseIntoStream(LPBYTE pszXML, DWORD dwSize, VARIANT *pVariant);

// Takes an IStream and gets its contents
HRESULT GetWStringFromStream(IStream *pStream,WCHAR **ppwszBody,DWORD *pdwLengthofPacket);

// CoCreates an IXMLDOMDocument object and sets the async, resolveExternals and validateOnParse
// properties to false
HRESULT CreateXMLDocument(IXMLDOMDocument **ppXMLDocument);

// CoCreates an IXMLDOMDocument object and sets the async, resolveExternals and validateOnParse
// properties to false
// And then creates a Variant from the IStream and calls load() on the IXMLDomDocument
// with this variant
HRESULT CreateXMLDocumentFromStream(IXMLDOMDocument **ppXMLDocument, IStream *pStream, VARIANT_BOOL &bResult);

// Converts a locale string in the form MS_XXX to a UINT
UINT ConvertMSLocaleStringToUint(LPWSTR pwszLocale);

HRESULT ConvertWbemObjectToXMLString(IWbemClassObject *pWbemClassObject,
													   PathLevel ePathLevel,
													   WCHAR **ppwszXMLString,
													   DWORD *pdwDataLength);


HRESULT GetProxyInformation(IWbemContext *pCtx,WCHAR **ppwszProxyName,WCHAR **ppwszProxyBypass);

//given a node that contains elements starting from IRETURNVALUE, this gives the underlying CLASS or INSTANCE node.
HRESULT Parse_IRETURNVALUE_Node(IXMLDOMNode *pXMLDomNodeTemp,IXMLDOMNode **ppXMLDomNodeChild);

void Get4DigitRandom(UINT *puRand);
void Get2DigitRandom(UINT *puRand);

bool IsEnumtypeDedicated(IWbemContext *pCtx);
HRESULT FilterContext(IWbemContext *pCtx,IWbemContext **pFilteredCtx);
HRESULT UninitWMIXMLClientLibrary();
HRESULT InitWMIXMLClientLibrary();


enum ePATHSTYLE
{
	UNRECOGNIZEDPATH=0,
	NON_SCOPEDPATH=1,
	NOVAPATH=3, //implies non_scoped
	SCOPEDPATH = 4,
	WHISTLERPATH= 12
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\xmltransport\client\mainsources\asynchronous.cpp ===
// XMLWbemServices.cpp: implementation of the CXMLWbemServices class.
// our implementation of IWbemServices
//////////////////////////////////////////////////////////////////////

#include "XMLProx.h"
#include "XMLClientPacket.h"
#include "XMLClientPacketFactory.h"
#include "SinkMap.h"
#include "MapXMLtoWMI.h"
#include "XMLWbemServices.h"
#include "XMLEnumWbemClassObject.h"
#include <xmlparser.h>
#include "MyPendingStream.h"
#include "nodefact.h"
#include "XMLEnumWbemClassObject2.h"
#include "URLParser.h"
#include "XMLWbemCallResult.h"

//This macro is frequently used to check if User has already issued CancelAsync for this IWbemObjectSink pointer.
#define CHECKIFCANCELLED(X) if(NULL == X)\
								return WBEM_E_INVALID_PARAMETER;\
							bool bIsCancelled = m_SinkMap.IsCancelled(X);\
							if( true == bIsCancelled )\
								return WBEM_E_CALL_CANCELLED;

HRESULT CXMLWbemServices::SpawnASyncThreadWithNormalPackage( LPTHREAD_START_ROUTINE pfThreadFunction,
															const BSTR strNsOrObjPath, 
															LONG lFlags, 
															IWbemContext *pCtx, 
															IWbemClassObject *pObject,
															IEnumWbemClassObject *pEnum,
															IWbemObjectSink *pResponseHandler,
															bool bEnumTypeDedicated)
{
	if(lFlags & WBEM_FLAG_SEND_STATUS) //user requested status
		pResponseHandler->SetStatus(WBEM_STATUS_PROGRESS, S_OK, NULL, NULL);

	HRESULT hr = WBEM_NO_ERROR;
	ASYNC_NORMAL_PACKAGE *pPackage = NULL;
	if(pPackage = new ASYNC_NORMAL_PACKAGE())
	{
		if(SUCCEEDED(hr = pPackage->Initialize(strNsOrObjPath, lFlags, this, pCtx, NULL, pObject, pEnum, bEnumTypeDedicated)))
		{
			if(SUCCEEDED(hr = pPackage->SetResponsehandler(pResponseHandler)))
			{
				HANDLE hChild = NULL;
				if(hChild = CreateThread(NULL, 0, pfThreadFunction, (void*)pPackage, 0, NULL))
					CloseHandle(hChild);
				else
					hr = WBEM_E_FAILED;
			}
		}
		// Thread wasnt created - hence our responsibility to delete the package
		if(FAILED(hr))
			delete pPackage; 
	}
	else
		hr = WBEM_E_OUT_OF_MEMORY;
	return hr;
}




/****************************************************************************************************
			Async member functions ......
****************************************************************************************************/


HRESULT  CXMLWbemServices::GetObjectAsync(const BSTR strObjectPath,
										  LONG lFlags, 
										  IWbemContext *pCtx, 
										  IWbemObjectSink *pResponseHandler)
{
	CHECKIFCANCELLED(pResponseHandler);	

	// Check for validity of input arguments
	//=====================================
	// These are the only valid flags for this operation..
	LONG lAllowedFlags = (WBEM_FLAG_USE_AMENDED_QUALIFIERS|WBEM_FLAG_DIRECT_READ|WBEM_FLAG_SEND_STATUS);
	if((lFlags | lAllowedFlags) != lAllowedFlags)
			return WBEM_E_INVALID_PARAMETER;

	// Parse the object path to decide whether it is a class or instance
	ePATHTYPE ePathType = INVALIDOBJECTPATH;
	if(NULL == strObjectPath)
		ePathType = CLASSPATH;
	else if(strObjectPath[0]=='\0'/*empty class*/)
		ePathType = CLASSPATH;
	else
		ParsePath(strObjectPath, &ePathType);


	HRESULT hr = WBEM_NO_ERROR;

	//For Whistler paths, invoke Thread_Async_GetClass, it will perform a "GetObject" if WHISTLERPATH
	if((ePathType == CLASSPATH)||(m_ePathstyle != NOVAPATH))
		hr = SpawnASyncThreadWithNormalPackage(Thread_Async_GetClass, 
												strObjectPath, 
												lFlags, 
												pCtx, 
												NULL, 
												NULL, 
												pResponseHandler);
	else if(ePathType == INSTANCEPATH)
		hr = SpawnASyncThreadWithNormalPackage(Thread_Async_GetInstance, 
												strObjectPath, 
												lFlags, 
												pCtx, 
												NULL, 
												NULL, 
												pResponseHandler);
	else
		hr = WBEM_E_INVALID_PARAMETER;

	return hr;
}

HRESULT  CXMLWbemServices::PutClassAsync(IWbemClassObject *pObject, LONG lFlags, IWbemContext *pCtx, 
										IWbemObjectSink *pResponseHandler)
{
	CHECKIFCANCELLED(pResponseHandler);	

	if(NULL == pObject)
		return WBEM_E_INVALID_PARAMETER;

	// Check for validity of the flags
	//=================================
	LONG lAllowedFlags = (	WBEM_FLAG_USE_AMENDED_QUALIFIERS|WBEM_FLAG_CREATE_OR_UPDATE|
							WBEM_FLAG_UPDATE_ONLY|WBEM_FLAG_CREATE_ONLY|
							WBEM_FLAG_SEND_STATUS |WBEM_FLAG_OWNER_UPDATE|
							WBEM_FLAG_UPDATE_COMPATIBLE|WBEM_FLAG_UPDATE_SAFE_MODE|
							WBEM_FLAG_UPDATE_FORCE_MODE );

	if((lFlags | lAllowedFlags) != lAllowedFlags)
			return WBEM_E_INVALID_PARAMETER;

	if(lFlags & WBEM_FLAG_SEND_STATUS)
		pResponseHandler->SetStatus(WBEM_STATUS_PROGRESS, S_OK, NULL, NULL);

	HRESULT hr = WBEM_NO_ERROR;
	hr = SpawnASyncThreadWithNormalPackage(Thread_Async_PutClass, 
											NULL, 
											lFlags, 
											pCtx, 
											pObject, 
											NULL, 
											pResponseHandler);
	return hr;
}

HRESULT  CXMLWbemServices::DeleteClassAsync(const BSTR strClass, 
											LONG lFlags, 
											IWbemContext *pCtx,  
											IWbemObjectSink *pResponseHandler)
{
	CHECKIFCANCELLED(pResponseHandler);	
	
	// Check for validity of the flags
	//=================================
	LONG lAllowedFlags = (	WBEM_FLAG_OWNER_UPDATE|WBEM_FLAG_SEND_STATUS);
	if((lFlags | lAllowedFlags) != lAllowedFlags)
			return WBEM_E_INVALID_PARAMETER;

	if(lFlags & WBEM_FLAG_SEND_STATUS) //user requested status
		pResponseHandler->SetStatus(WBEM_STATUS_PROGRESS,S_OK,NULL,NULL);

	HRESULT hr = S_OK;
	hr = SpawnASyncThreadWithNormalPackage(Thread_Async_DeleteClass, 
											strClass, 
											lFlags, 
											pCtx, 
											NULL, 
											NULL, 
											pResponseHandler);

	return hr;
}

HRESULT  CXMLWbemServices::CreateClassEnumAsync(const BSTR strSuperclass, 
												LONG lFlags, 
												IWbemContext *pCtx, 
												IWbemObjectSink *pResponseHandler)
{
	CHECKIFCANCELLED(pResponseHandler);

	// Check for validity of the flags
	//=================================
	LONG lAllowedFlags = (	WBEM_FLAG_USE_AMENDED_QUALIFIERS|WBEM_FLAG_DEEP |
							WBEM_FLAG_SHALLOW |WBEM_FLAG_SEND_STATUS |
							WBEM_FLAG_FORWARD_ONLY|WBEM_FLAG_BIDIRECTIONAL);
	if((lFlags | lAllowedFlags) != lAllowedFlags)
			return WBEM_E_INVALID_PARAMETER;

	if(lFlags & WBEM_FLAG_SEND_STATUS) //user requested status..
		pResponseHandler->SetStatus(WBEM_STATUS_PROGRESS, S_OK, NULL, NULL);

	IEnumWbemClassObject *pActualEnum = NULL;

	// See if we need to do it on a dedicated HTTP connection
	// Create the correct enumerator based on that
	bool bEnumTypeDedicated = false;
	bEnumTypeDedicated = IsEnumtypeDedicated(pCtx);
	HRESULT hr = S_OK;
	if(bEnumTypeDedicated)
	{
		if(pActualEnum = new CXMLEnumWbemClassObject2())
			hr = ((CXMLEnumWbemClassObject2 *)pActualEnum)->Initialize(false, L"CLASS", m_pwszBracketedServername, m_pwszNamespace);
		else
			hr = WBEM_E_OUT_OF_MEMORY;
	}
	else
	{
		//the last parameter specifies that this is part of a semi-synchronous operation
		if(pActualEnum = new CXMLEnumWbemClassObject())
			hr = ((CXMLEnumWbemClassObject *)pActualEnum)->Initialize(false, m_pwszBracketedServername, m_pwszNamespace);
		else
			hr = WBEM_E_OUT_OF_MEMORY;
	}

	if(SUCCEEDED(hr))
	{
		hr = SpawnASyncThreadWithNormalPackage(Thread_Async_CreateClassEnum, 
												strSuperclass, 
												lFlags, 
												pCtx, 
												NULL, 
												pActualEnum, 
												pResponseHandler,
												bEnumTypeDedicated);
	}
	RELEASEINTERFACE(pActualEnum); // This may actually be NULL if hr = WBEM_E_OUT_OF_MEMORY
	return hr;
}

HRESULT  CXMLWbemServices::CreateInstanceEnumAsync(const BSTR strClass,LONG lFlags, IWbemContext *pCtx, 
													IWbemObjectSink *pResponseHandler)
{
	CHECKIFCANCELLED(pResponseHandler);

	// Check for validity of the flags
	//=================================
	LONG lAllowedFlags = (	WBEM_FLAG_USE_AMENDED_QUALIFIERS|WBEM_FLAG_DEEP |
							WBEM_FLAG_SHALLOW |WBEM_FLAG_SEND_STATUS|
							WBEM_FLAG_FORWARD_ONLY|WBEM_FLAG_BIDIRECTIONAL|
							WBEM_FLAG_DIRECT_READ);

	if((lFlags | lAllowedFlags) != lAllowedFlags)
			return WBEM_E_INVALID_PARAMETER;

	if(lFlags & WBEM_FLAG_SEND_STATUS) //user requested status..
		pResponseHandler->SetStatus(WBEM_STATUS_PROGRESS, S_OK, NULL, NULL);

	IEnumWbemClassObject *pActualEnum = NULL;

	// See if we need to do it on a dedicated HTTP connection
	// Create the correct enumerator based on that
	bool bEnumTypeDedicated = false;
	bEnumTypeDedicated = IsEnumtypeDedicated(pCtx);
	HRESULT hr = S_OK;
	if(bEnumTypeDedicated)
	{
		if(pActualEnum = new CXMLEnumWbemClassObject2())
			hr = ((CXMLEnumWbemClassObject2 *)pActualEnum)->Initialize(false, L"VALUE.NAMEDINSTANCE", m_pwszBracketedServername, m_pwszNamespace);
		else
			hr = WBEM_E_OUT_OF_MEMORY;
	}
	else
	{
		//the last parameter specifies that this is part of a semi-synchronous operation
		if(pActualEnum = new CXMLEnumWbemClassObject())
			hr = ((CXMLEnumWbemClassObject *)pActualEnum)->Initialize(false, m_pwszBracketedServername, m_pwszNamespace);
		else
			hr = WBEM_E_OUT_OF_MEMORY;
	}

	if(SUCCEEDED(hr))
	{
		hr = SpawnASyncThreadWithNormalPackage(Thread_Async_CreateInstanceEnum, 
												strClass, 
												lFlags, 
												pCtx, 
												NULL, 
												pActualEnum, 
												pResponseHandler,
												bEnumTypeDedicated);
	}
	
	RELEASEINTERFACE(pActualEnum); // This may actually be NULL if hr = WBEM_E_OUT_OF_MEMORY
	return hr;
}

HRESULT  CXMLWbemServices::PutInstanceAsync(IWbemClassObject *pInst, LONG lFlags, IWbemContext *pCtx, 
											IWbemObjectSink *pResponseHandler)
{
	CHECKIFCANCELLED(pResponseHandler);	

	// Check for validity of the input arguments
	//=================================
	LONG lAllowedFlags = (	WBEM_FLAG_CREATE_OR_UPDATE|WBEM_FLAG_UPDATE_ONLY|
							WBEM_FLAG_CREATE_ONLY|WBEM_FLAG_SEND_STATUS);

	if((lFlags | lAllowedFlags) != lAllowedFlags)
			return WBEM_E_INVALID_PARAMETER;

	if(NULL == pInst)
		return WBEM_E_INVALID_PARAMETER;


	if(lFlags & WBEM_FLAG_SEND_STATUS) //user requested status..
		pResponseHandler->SetStatus(WBEM_STATUS_PROGRESS, S_OK, NULL, NULL);

	HRESULT hr = S_OK;
	hr = SpawnASyncThreadWithNormalPackage(Thread_Async_PutInstance, 
											NULL, 
											lFlags, 
											pCtx, 
											pInst, 
											NULL, 
											pResponseHandler);

	return hr;
}


HRESULT  CXMLWbemServices::DeleteInstanceAsync(const BSTR strObjectPath, LONG lFlags, IWbemContext *pCtx, 
							 IWbemObjectSink *pResponseHandler)
{
	CHECKIFCANCELLED(pResponseHandler);	

	// Do Input Parameter Verification
	//=======================================
	LONG lAllowedFlags = (WBEM_FLAG_SEND_STATUS);
	if((lFlags | lAllowedFlags) != lAllowedFlags)
			return WBEM_E_INVALID_PARAMETER;

	if(lFlags & WBEM_FLAG_SEND_STATUS) //user requested status
		pResponseHandler->SetStatus(WBEM_STATUS_PROGRESS, S_OK, NULL, NULL);
	
	HRESULT hr = S_OK;
	hr = SpawnASyncThreadWithNormalPackage(Thread_Async_DeleteInstance, 
											strObjectPath, 
											lFlags, 
											pCtx, 
											NULL, 
											NULL, 
											pResponseHandler);

	return hr;
}


HRESULT  CXMLWbemServices::ExecQueryAsync(const BSTR strQueryLanguage, const BSTR strQuery,  long lFlags,  
											IWbemContext *pCtx, IWbemObjectSink *pResponseHandler)
{
	CHECKIFCANCELLED(pResponseHandler);	

	// Do Input Parameter Verification
	//=======================================
	LONG lAllowedFlags = (	WBEM_FLAG_USE_AMENDED_QUALIFIERS|WBEM_FLAG_FORWARD_ONLY|
							WBEM_FLAG_BIDIRECTIONAL|WBEM_FLAG_SEND_STATUS|
							WBEM_FLAG_ENSURE_LOCATABLE|WBEM_FLAG_PROTOTYPE|
							WBEM_FLAG_DIRECT_READ);
	if((lFlags | lAllowedFlags) != lAllowedFlags)
			return WBEM_E_INVALID_PARAMETER;

	if(SysStringLen(strQuery)<=0)
		return WBEM_E_INVALID_PARAMETER;

	if(lFlags & WBEM_FLAG_SEND_STATUS) //user requested status
		pResponseHandler->SetStatus(WBEM_STATUS_PROGRESS, S_OK, NULL, NULL);

	CXMLEnumWbemClassObject *pActualEnum = NULL;
	pActualEnum = new CXMLEnumWbemClassObject();
	if(NULL == pActualEnum)
		return WBEM_E_OUT_OF_MEMORY;

	HRESULT hr = WBEM_NO_ERROR;
	if(SUCCEEDED(hr = pActualEnum->Initialize(false, m_pwszBracketedServername, m_pwszNamespace)))
	{
		// Create a package for passing to the thread that executes this call
		ASYNC_QUERY_PACKAGE *pPackage = NULL;
		if(pPackage = new ASYNC_QUERY_PACKAGE())
		{
			if(SUCCEEDED(hr = pPackage->Initialize(strQueryLanguage, strQuery, lFlags, this, pCtx, pActualEnum)))
			{
				if(SUCCEEDED(hr = pPackage->SetResponsehandler(pResponseHandler)))
				{
					// Kick off the request on the other thread
					HANDLE hChild = NULL;
					if(hChild = CreateThread(NULL, 0, Thread_Async_ExecQuery, (void*)pPackage, 0, NULL))
					{
						CloseHandle(hChild);
					}
					else 
						hr = WBEM_E_FAILED;
				}
			}

			if(FAILED(hr)) // This means the other thread (that would have deleted this package) wasnt created
				delete pPackage;
		}
		else 
			hr = WBEM_E_OUT_OF_MEMORY;
	}

	pActualEnum->Release();
	return hr;
}

HRESULT  CXMLWbemServices::ExecMethodAsync(const BSTR strObjectPath,const BSTR strMethodName, LONG lFlags,
											IWbemContext *pCtx, IWbemClassObject *pInParams,  
											IWbemObjectSink *pResponseHandler)
{
	CHECKIFCANCELLED(pResponseHandler);	

	// Do Input Parameter Verification
	//=======================================
	LONG lAllowedFlags = (WBEM_FLAG_SEND_STATUS);
	if((lFlags | lAllowedFlags) != lAllowedFlags)
			return WBEM_E_INVALID_PARAMETER;

	if(( SysStringLen(strObjectPath) == 0) || (SysStringLen(strMethodName) == 0) )
		return WBEM_E_INVALID_PARAMETER;

	if(lFlags & WBEM_FLAG_SEND_STATUS) //user requested status
		pResponseHandler->SetStatus(WBEM_STATUS_PROGRESS, S_OK, NULL, NULL);
	

	HRESULT hr = S_OK;
	// Create a package for passing to the thread that executes this call
	ASYNC_METHOD_PACKAGE *pPackage = NULL;
	if(pPackage = new ASYNC_METHOD_PACKAGE())
	{
		if(SUCCEEDED(hr = pPackage->Initialize(strObjectPath, strMethodName, lFlags, this, pCtx, NULL, pInParams)))
		{
			if(SUCCEEDED(hr = pPackage->SetResponsehandler(pResponseHandler)))
			{
				// Kick off the request on the other thread
				HANDLE hChild = NULL;
				if(hChild = CreateThread(NULL, 0, Thread_Async_ExecMethod, (void*)pPackage, 0, NULL))
				{
					CloseHandle(hChild);
				}
				else 
					hr = WBEM_E_FAILED;
			}
		}

		if(FAILED(hr)) // This means the other thread (that would have deleted this package) wasnt created
			delete pPackage;
	}
	else 
		hr = WBEM_E_OUT_OF_MEMORY;

	return hr;
}

HRESULT  CXMLWbemServices::CancelAsyncCall( IWbemObjectSink *pSink)
{
	// All we do is set the status in our per-Services table.
	// The threads that are doing Async calls periodically check this table
	// and exit if the call has been cancelled
	return m_SinkMap.AddToMap(pSink);
}


/****************************************************************************************************
			End of Async member functions ......
****************************************************************************************************/



/****************************************************************************************************
			The thread function that are used for Nova Async operations..
****************************************************************************************************/

DWORD WINAPI Thread_Async_GetClass(LPVOID pPackage)
{
	ASYNC_NORMAL_PACKAGE *pThisPackage = (ASYNC_NORMAL_PACKAGE *) pPackage;

	// Get the contents of the package. No need to addref it since we dont give it away
	IWbemObjectSink  *pSink = pThisPackage->m_pResponseHandler;
	CXMLWbemServices *pCallingObject = pThisPackage->m_pCallingObject;
	HRESULT hr = WBEM_NO_ERROR;

	// Check for a second whether the user has cancelled the call
	if(SUCCEEDED(hr = CoInitialize(NULL)))
	{
		if(pCallingObject->m_SinkMap.IsCancelled(pSink))
			hr = WBEM_E_CALL_CANCELLED;
		else
		{
			IWbemClassObject *pClassObject = NULL;
			if(SUCCEEDED(hr = pCallingObject->Actual_GetClass(pThisPackage->m_strNsOrObjPath, 
																pThisPackage->m_lFlags,
																pThisPackage->m_pCtx, 
																&pClassObject)))
			{
				pSink->Indicate(1,&pClassObject);
				pClassObject->Release();
			}
		}
		CoUninitialize();
	}

	pSink->SetStatus(WBEM_STATUS_COMPLETE, hr, NULL, NULL);
	delete pThisPackage;
	return 0;
}

DWORD WINAPI Thread_Async_GetInstance(LPVOID pPackage)
{
	ASYNC_NORMAL_PACKAGE *pThisPackage = (ASYNC_NORMAL_PACKAGE *) pPackage;

	// Get the contents of the package. No need to addref it since we dont give it away
	IWbemObjectSink  *pSink = pThisPackage->m_pResponseHandler;
	CXMLWbemServices *pCallingObject = pThisPackage->m_pCallingObject;
	HRESULT hr = WBEM_NO_ERROR;

	// Check for a second whether the user has cancelled the call
	if(SUCCEEDED(hr = CoInitialize(NULL)))
	{
		if(pCallingObject->m_SinkMap.IsCancelled(pSink))
			hr = WBEM_E_CALL_CANCELLED;
		else
		{
			IWbemClassObject *pClassObject = NULL;
			if(SUCCEEDED(hr = pCallingObject->Actual_GetInstance(pThisPackage->m_strNsOrObjPath, 
																pThisPackage->m_lFlags,
																pThisPackage->m_pCtx, 
																&pClassObject)))
			{
				pSink->Indicate(1,&pClassObject);
				pClassObject->Release();
			}
		}
		CoUninitialize();
	}

	pSink->SetStatus(WBEM_STATUS_COMPLETE, hr, NULL, NULL);
	delete pThisPackage;
	return 0;
}

DWORD WINAPI Thread_Async_PutClass(LPVOID pPackage)
{
	ASYNC_NORMAL_PACKAGE *pThisPackage = (ASYNC_NORMAL_PACKAGE *) pPackage;

	// Get the contents of the package. No need to addref it since we dont give it away
	IWbemObjectSink  *pSink = pThisPackage->m_pResponseHandler;
	CXMLWbemServices *pCallingObject = pThisPackage->m_pCallingObject;
		
	HRESULT hr = WBEM_NO_ERROR;

	// Check for a second whether the user has cancelled the call
	if(SUCCEEDED(hr = CoInitialize(NULL)))
	{
		if(pCallingObject->m_SinkMap.IsCancelled(pSink))
			hr = WBEM_E_CALL_CANCELLED;
		else
		{
			hr = pCallingObject->Actual_PutClass(pThisPackage->m_pWbemClassObject, 
																pThisPackage->m_lFlags,
																pThisPackage->m_pCtx);
		}
		CoUninitialize();
	}
	pSink->SetStatus(WBEM_STATUS_COMPLETE, hr, NULL, NULL);

	delete pThisPackage;
	return 0;
}

DWORD WINAPI Thread_Async_PutInstance(LPVOID pPackage)
{
	ASYNC_NORMAL_PACKAGE *pThisPackage = (ASYNC_NORMAL_PACKAGE *) pPackage;

	// Get the contents of the package. No need to addref it since we dont give it away
	IWbemObjectSink  *pSink = pThisPackage->m_pResponseHandler;
	CXMLWbemServices *pCallingObject = pThisPackage->m_pCallingObject;
		
	HRESULT hr = WBEM_NO_ERROR;

	// Check for a second whether the user has cancelled the call
	if(SUCCEEDED(hr = CoInitialize(NULL)))
	{
		if(pCallingObject->m_SinkMap.IsCancelled(pSink))
			hr = WBEM_E_CALL_CANCELLED;
		else
		{
			hr = pCallingObject->Actual_PutInstance(pThisPackage->m_pWbemClassObject, 
																pThisPackage->m_lFlags,
																pThisPackage->m_pCtx);
		}
		CoUninitialize();
	}
	pSink->SetStatus(WBEM_STATUS_COMPLETE, hr, NULL, NULL);

	delete pThisPackage;
	return 0;
}

DWORD WINAPI Thread_Async_DeleteClass(LPVOID pPackage)
{
	ASYNC_NORMAL_PACKAGE *pThisPackage = (ASYNC_NORMAL_PACKAGE *) pPackage;

	// Get the contents of the package. No need to addref it since we dont give it away
	IWbemObjectSink  *pSink = pThisPackage->m_pResponseHandler;
	CXMLWbemServices *pCallingObject = pThisPackage->m_pCallingObject;
		
	HRESULT hr = WBEM_NO_ERROR;
	if(SUCCEEDED(hr = CoInitialize(NULL)))
	{
		// Check for a second whether the user has cancelled the call
		if(pCallingObject->m_SinkMap.IsCancelled(pSink))
			hr = WBEM_E_CALL_CANCELLED;
		else
		{
			hr = pCallingObject->Actual_DeleteClass(pThisPackage->m_strNsOrObjPath, 
														pThisPackage->m_lFlags,
														pThisPackage->m_pCtx);
		}
		CoUninitialize();
	}
	pSink->SetStatus(WBEM_STATUS_COMPLETE, hr, NULL, NULL);
	delete pThisPackage;
	return 0;
}

DWORD WINAPI Thread_Async_DeleteInstance(LPVOID pPackage)
{
	ASYNC_NORMAL_PACKAGE *pThisPackage = (ASYNC_NORMAL_PACKAGE *) pPackage;

	// Get the contents of the package. No need to addref it since we dont give it away
	IWbemObjectSink  *pSink = pThisPackage->m_pResponseHandler;
	CXMLWbemServices *pCallingObject = pThisPackage->m_pCallingObject;
		
	HRESULT hr = WBEM_NO_ERROR;

	if(SUCCEEDED(hr = CoInitialize(NULL)))
	{
		// Check for a second whether the user has cancelled the call
		if(pCallingObject->m_SinkMap.IsCancelled(pSink))
			hr = WBEM_E_CALL_CANCELLED;
		else
		{
			hr = pCallingObject->Actual_DeleteInstance(pThisPackage->m_strNsOrObjPath, 
														pThisPackage->m_lFlags,
														pThisPackage->m_pCtx);
		}
		CoUninitialize();
	}
	pSink->SetStatus(WBEM_STATUS_COMPLETE, hr, NULL, NULL);
	delete pThisPackage;
	return 0;
}


DWORD WINAPI Thread_Async_CreateClassEnum(LPVOID pPackage)
{
	ASYNC_NORMAL_PACKAGE *pThisPackage = (ASYNC_NORMAL_PACKAGE *) pPackage;
	IWbemObjectSink  *pSink = pThisPackage->m_pResponseHandler;
	CXMLWbemServices *pCallingObject = pThisPackage->m_pCallingObject;

	HRESULT hr = S_OK;
	if(SUCCEEDED(hr = CoInitialize(NULL)))
	{
		if(pCallingObject->m_SinkMap.IsCancelled(pSink))  //check if cancelled just before performing actual operation
			hr = WBEM_E_CALL_CANCELLED;
		else
		{
			if(SUCCEEDED(hr = pCallingObject->Actual_CreateClassEnum(pThisPackage->m_strNsOrObjPath,
							pThisPackage->m_lFlags,
							pThisPackage->m_pCtx, 
							pThisPackage->m_pEnum,
							pThisPackage->m_bDedicatedEnum)))
			{
				ULONG uCount=0;
				IWbemClassObject *pObject = NULL;
				while(SUCCEEDED((pThisPackage->m_pEnum)->Next(WBEM_INFINITE, 1, &pObject, &uCount)) && uCount)
				{
					pSink->Indicate(1, &pObject);
					pObject->Release();
					uCount = 0;
				}
			}
		}
		CoUninitialize();
	}
	pSink->SetStatus(WBEM_STATUS_COMPLETE, hr, NULL, NULL);
	delete pThisPackage;
	return 0;
}

DWORD WINAPI Thread_Async_CreateInstanceEnum(LPVOID pPackage)
{
	ASYNC_NORMAL_PACKAGE *pThisPackage = (ASYNC_NORMAL_PACKAGE *) pPackage;
	IWbemObjectSink  *pSink = pThisPackage->m_pResponseHandler;
	CXMLWbemServices *pCallingObject = pThisPackage->m_pCallingObject;

	HRESULT hr = S_OK;
	if(SUCCEEDED(hr = CoInitialize(NULL)))
	{
		if(pCallingObject->m_SinkMap.IsCancelled(pSink))  //check if cancelled just before performing actual operation
			hr = WBEM_E_CALL_CANCELLED;
		else
		{
			if(SUCCEEDED(hr = pCallingObject->Actual_CreateInstanceEnum(pThisPackage->m_strNsOrObjPath,
							pThisPackage->m_lFlags,
							pThisPackage->m_pCtx, 
							pThisPackage->m_pEnum,
							pThisPackage->m_bDedicatedEnum)))
			{
				ULONG uCount=0;
				IWbemClassObject *pObject = NULL;
				while(SUCCEEDED((pThisPackage->m_pEnum)->Next(WBEM_INFINITE, 1, &pObject, &uCount)) && uCount)
				{
					pSink->Indicate(1, &pObject);
					pObject->Release();
					uCount = 0;
				}
			}
		}
		CoUninitialize();
	}
	pSink->SetStatus(WBEM_STATUS_COMPLETE, hr, NULL, NULL);
	delete pThisPackage;
	return 0;
}


DWORD WINAPI Thread_Async_ExecQuery(LPVOID pPackage)
{

	ASYNC_QUERY_PACKAGE *pThisPackage = (ASYNC_QUERY_PACKAGE *) pPackage;
	IWbemObjectSink  *pSink = pThisPackage->m_pResponseHandler;
	CXMLWbemServices *pCallingObject = pThisPackage->m_pCallingObject;

	HRESULT hr = S_OK;
	if(SUCCEEDED(hr = CoInitialize(NULL)))
	{
		if(pCallingObject->m_SinkMap.IsCancelled(pSink))  //check if cancelled just before performing actual operation
			hr = WBEM_E_CALL_CANCELLED;
		else
		{
			if(SUCCEEDED(hr = pCallingObject->Actual_ExecQuery(
							pThisPackage->m_strQueryLanguage,
							pThisPackage->m_strQuery,
							pThisPackage->m_lFlags,
							pThisPackage->m_pCtx, 
							pThisPackage->m_pEnum)))
			{
				ULONG uCount=0;
				IWbemClassObject *pObject = NULL;
				while(SUCCEEDED((pThisPackage->m_pEnum)->Next(WBEM_INFINITE, 1, &pObject, &uCount)) && uCount)
				{
					pSink->Indicate(1, &pObject);
					pObject->Release();
					uCount = 0;
				}
			}
		}
		CoUninitialize();
	}
	pSink->SetStatus(WBEM_STATUS_COMPLETE, hr, NULL, NULL);
	delete pThisPackage;
	return 0;
}

DWORD WINAPI Thread_Async_ExecMethod(LPVOID pPackage)
{
	ASYNC_METHOD_PACKAGE *pThisPackage = (ASYNC_METHOD_PACKAGE *) pPackage;
	IWbemObjectSink  *pSink = pThisPackage->m_pResponseHandler;
	CXMLWbemServices *pCallingObject = pThisPackage->m_pCallingObject;

	HRESULT hr = S_OK;
	if(SUCCEEDED(hr = CoInitialize(NULL)))
	{
		if(pCallingObject->m_SinkMap.IsCancelled(pSink))  //check if cancelled just before performing actual operation
			hr = WBEM_E_CALL_CANCELLED;
		else
		{
			IWbemClassObject *pOutParams = NULL;
			if(SUCCEEDED(hr = pCallingObject->Actual_ExecMethod(pThisPackage->m_strNsOrObjPath,
												pThisPackage->m_strMethod,
												pThisPackage->m_lFlags,
												pThisPackage->m_pCtx,
												pThisPackage->m_pWbemClassObject,
												&pOutParams)))
			{
				if(NULL != pOutParams)
					pSink->Indicate(1, &pOutParams);

			}
		}
		CoUninitialize();
	}
	pSink->SetStatus(WBEM_STATUS_COMPLETE, hr, NULL, NULL);
	delete pThisPackage;
	return 0;
}

/****************************************************************************************************
			End of Nova Async Thread Functions
****************************************************************************************************/


/****************************************************************************************************
			End of thread functions that are used for Async operations..
****************************************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\xmltransport\client\includes\urlparser.h ===
/////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// Microsoft XML HTTP Transport Client
// (C) Copyright 1999 Microsoft Corporation. All Rights Reserved.
//
//	UrlParser.h		-	CURLParer class header file,
/////////////////////////////////////////////////////////////////////////////////////////////////////////
#ifndef _URLPARSER_H_
#define _URLPARSER_H_


class CURLParser
{
private:
	
	//interface to be used for parsing
	IWbemPath	*m_pIWbemPath;

public:
	//set the object path to be parsed
	HRESULT Initialize(LPCWSTR strObjPath);
	virtual ~CURLParser();

	bool IsNovapath();
	bool IsWhistlerpath();
	bool IsClass();
	bool IsInstance();
	bool IsScopedpath();

	//set a new path - will FAIL if the object path is invalid
	HRESULT SetObjPath(LPCWSTR pszObjPath);

	HRESULT GetObjectName(WCHAR **ppwszClassname);
	HRESULT GetNamespace(WCHAR **ppwszNamespace);
	HRESULT GetServername(WCHAR **ppwszServername);
	HRESULT	GetScope(WCHAR **ppwszScope);
	HRESULT GetKeyValue(BSTR strKey,VARIANT &varValue);

};



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\xmltransport\client\includes\xmlclientpacket.h ===
// XMLClientPacket.h: interface for the CXMLClientPacket class.
//
//////////////////////////////////////////////////////////////////////

#ifndef WMI_XML_CLIENTPACKET_H
#define WMI_XML_CLIENTPACKET_H


//Abstract base class . all classes creating client xml packets MUST 
//derive from this class.

class CXMLClientPacket  
{
protected:
	// Function that retrieves the key bindings in XML format from the INSTANCE name.
	HRESULT GetKeyBindingsInStream(IStream *pStream);

	//get standard body till </LOCALNAMESPACEPATH>\r\n
	HRESULT GetBodyTillLocalNamespacePathInStream(IStream **ppStream);

	//get the HTTP header in M-POST format
	HRESULT GetMPostHeader(WCHAR **pwszHeader);
	//get the HTTP header in POST format
	HRESULT GetPostHeader(WCHAR **pwszHeader);

	//the length of the XML representation of namespace viz., <NAMESPACE NAME="root"/> ....
	HRESULT GetNamespaceLength(DWORD *pdwTotalLength,DWORD *pdwNumberofNamespaces);
	// Get the namespace in XML format
	HRESULT GetXMLNamespaceInStream(IStream *pStream);

	// This creates an IWbemContext object with some specific
	// flags set in it for use by the WMIXML convertor
	HRESULT CreateFlagsContext(IWbemContext **ppCtx);

	// A string used to identify a Whistler method
	static LPCWSTR WMI_WHISTLERSTRING;

	// Whether this is a WMI client
	bool	m_bWMI;

	// Indicates which HTTP method is being used
	int	m_iPostType;			/*1 for POST, 2 for M-POST*/

	// These are static strings used as the value of many operation parameters
	static LPCWSTR TRUE_STRING;
	static LPCWSTR FALSE_STRING;
	static LPCWSTR WHISTLER_HTTP_HEADER;

	WCHAR	*m_pwszNameSpace;			//the namespace
	WCHAR	*m_pwszObjPath;				//the obj path. eg root/cimv2
	WCHAR	*m_pwszNewObjPath;			//for operations that take an old and new path. eg. Copy.

	// The following should not be deleted in the destructor since
	// they will be made to point to static members
	LPCWSTR	m_pwszLocalOnly;			//"TRUE" or "FALSE"
	LPCWSTR	m_pwszIncludeQualifier;		//''
	LPCWSTR	m_pwszDeepInheritance;		//''
	LPCWSTR	m_pwszIncludeClassOrigin;	//''

	WCHAR	*m_pwszCimOperation;		//CimOperation - eg "GetClass"
	WCHAR   *m_pwszLocale;

	DWORD	m_dwXMLNamespaceLength;
	DWORD	m_dwNumberofNamespaceparts;

	WCHAR	m_pwszQueryLanguage[80];	//Used only by ExecQuery packet class. by default "WQL"
	WCHAR	*m_pwszQueryString;			//stores the query. used only by ExecQuery packet class

	//additional flags that clients would be setting that need to be passed through our packet.
	LONG	m_lFlags;

	IWbemContext		*m_pCtx;
	IWbemClassObject	*m_pWbemClassObject;
	
	ePATHSTYLE	m_ePathstyle; //WHISTLER OR NOVA ?

	HRESULT		m_hResult; //function calls made in the ctor set this member..

public:
	
	CXMLClientPacket(const WCHAR *pwszObjPath,
		const WCHAR *pwszNameSpace,
		const WCHAR *pwszCimOperation);
	virtual ~CXMLClientPacket();

	
	//function that would be called by the creating packet factory to determine if the
	//class construction completed without any errors..
	bool ClassConstructionSucceeded();

	// Function to convert given IWbemClassObject to XML representation.
	HRESULT ConvertWbemObjectToXMLStream(IStream *pStream);

	//this function mainly used by ExecMethodPacket class... when parameters are passed 
	//via an IWbemClassObject pointer, this function decodes them into IPARAMVALUEs (XML)
	HRESULT GetParamsFromObjectInStream(IStream *pStream);

	//boolean flag set to mean the server is a WMI server
	HRESULT SetWMI(bool bFlag);

public:
	//returns the http extension header for specified CIMOperation
	virtual HRESULT GetHeader(WCHAR **ppwszHeader);
	//retunrs the message body
	virtual HRESULT GetBody(WCHAR **ppwszBody,DWORD *pdwLengthofPacket=NULL)=0;
	
	//retunrs the message body
	//This version takes an XML version of ObjPath directly and forms the body.
	//useful if you already have the objpath in xml version and dont want
	//this class to convert for you.
	virtual HRESULT GetBodyDirect(const WCHAR *pwszXMLObjPath, DWORD dwLengthofObjPath, WCHAR **ppwszBody, DWORD *pdwLengthofPacket);

	//this is a better implementation. uses UINT rather than strings for specifying post type.
	//keeping the old fn to prevent breaking of any existing code that uses this..
	virtual HRESULT SetPostType(int uPostType/*1 for POST, 2 for M-POST*/);

	virtual HRESULT SetOptions(const WCHAR *pwszLocale,
		IWbemContext *pCtx,
		IWbemClassObject *pWbemClassObject,
		bool bLocalOnly,
		bool bIncludeQualifier,
		bool bDeepInheritance,
		bool bIncludeClassOrigin);

	//flags like WBEM_FLAG_AMMENDED_QUALIFIER that would be passed 
	//as Iparamnames in the packet.
	virtual HRESULT SetFlags(LONG lFlags);

	//only for ExecQuery packet class. doesnt makesense for others. 
	//including this fn in base class to maintain uniformity.
	//clients only get a base class ptr.
	virtual HRESULT SetQueryLanguage(const WCHAR *pwszQueryLanguage);
	virtual HRESULT SetQueryString(const WCHAR *pwszQueryString);

	//For EXTRINSIC method invocations, the CimOperation would be 
	//the method name that the user would pass. - it would have been 
	//nice if the standard was maintained and the CimOperation for ExecuteMethod
	//had been "ExecuteMethod" and the actual method name had been one of the elements
	//of the xml packet - but then....
	virtual HRESULT SetMethod(const WCHAR *pwszMethod);

};
#endif // WMI_XML_CLIENTPACKET_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\xmltransport\client\mainsources\package.cpp ===
#include "XMLProx.h"
#include "XMLClientPacket.h"
#include "XMLClientPacketFactory.h"
#include "SinkMap.h"
#include "MapXMLtoWMI.h"
#include "XMLWbemServices.h"


NOVABASEPACKET::NOVABASEPACKET()
{
	m_strNsOrObjPath = NULL;
	m_lFlags = 0;
	m_pCtx = NULL;
	m_pResponseHandler = NULL;
	m_pCallResult = NULL;
	m_pWbemClassObject = NULL;
	m_pCallingObject = NULL;
	m_pEnum = NULL;
};

HRESULT NOVABASEPACKET::Initialize(const BSTR strNsOrObjPath,
	ULONG lFlags,
	CXMLWbemServices *pCallingObject,
	IWbemContext *pCtx, 
	CXMLWbemCallResult *pCallResult,
	IWbemClassObject *pObject,
	IEnumWbemClassObject *pEnum,
	bool bDedicatedEnum)
{
	m_lFlags = lFlags;
	m_bDedicatedEnum = bDedicatedEnum;

	HRESULT hr = S_OK;
	if(strNsOrObjPath)
	{
		if(!(m_strNsOrObjPath = SysAllocString(strNsOrObjPath)) )
			hr = E_OUTOFMEMORY;
	}

	if(SUCCEEDED(hr))
	{
		if(m_pCallingObject = pCallingObject)
			pCallingObject->AddRef();
		if(m_pCtx = pCtx)
			pCtx->AddRef();
		if(m_pCallResult = pCallResult)
			pCallResult->AddRef();
		if(m_pWbemClassObject = pObject)
			pObject->AddRef();
		if(m_pEnum = pEnum)
			pEnum->AddRef();
	}
	return hr;
}


NOVABASEPACKET::~NOVABASEPACKET()
{
	SysFreeString(m_strNsOrObjPath);
	RELEASEINTERFACE(m_pCallingObject);
	RELEASEINTERFACE(m_pCtx);
	RELEASEINTERFACE(m_pCallResult);
	RELEASEINTERFACE(m_pWbemClassObject);
	RELEASEINTERFACE(m_pResponseHandler);
}

HRESULT NOVABASEPACKET::SetResponsehandler(IWbemObjectSink *pCallback) 
{
	if(m_pResponseHandler = pCallback)
		m_pResponseHandler->AddRef();
	return S_OK;
}

ASYNC_QUERY_PACKAGE::ASYNC_QUERY_PACKAGE()
{
	m_strQueryLanguage = NULL;
	m_strQuery = NULL;
}

ASYNC_QUERY_PACKAGE::~ASYNC_QUERY_PACKAGE()
{
	SysFreeString(m_strQueryLanguage);
	SysFreeString(m_strQuery);
}

HRESULT ASYNC_QUERY_PACKAGE::Initialize(const BSTR strQueryLanguage, const BSTR strQuery,
								ULONG lFlags,
								CXMLWbemServices *pCallingObject,
								IWbemContext *pCtx, 
								IEnumWbemClassObject *pEnum)

{
	HRESULT hr = S_OK;
	if(strQueryLanguage)
	{
		if(!(m_strQueryLanguage = SysAllocString(strQueryLanguage)))
			hr = E_OUTOFMEMORY;
	}
	if(SUCCEEDED(hr) && strQuery)
	{
		if(!(m_strQuery = SysAllocString(strQuery)))
			hr = E_OUTOFMEMORY;
	}

	if(SUCCEEDED(hr))
		hr = NOVABASEPACKET::Initialize(NULL, lFlags, pCallingObject, pCtx, NULL, NULL, pEnum);

	return hr;
}

ASYNC_METHOD_PACKAGE::ASYNC_METHOD_PACKAGE()
{
	m_strMethod = NULL;
}

ASYNC_METHOD_PACKAGE::~ASYNC_METHOD_PACKAGE()
{
	SysFreeString(m_strMethod);
}

HRESULT ASYNC_METHOD_PACKAGE::Initialize(const BSTR strObjectPath, 
							const BSTR strMethod,
							ULONG lFlags,
							CXMLWbemServices *pCallingObject,
							IWbemContext *pCtx, 
							CXMLWbemCallResult *pCallback,
							IWbemClassObject *pInParams)
{
	HRESULT hr = S_OK;
	if(strMethod)
	{
		if(!(m_strMethod = SysAllocString(strMethod)))
			hr = E_OUTOFMEMORY;
	}

	if(SUCCEEDED(hr))
		hr = NOVABASEPACKET::Initialize(strObjectPath, lFlags, pCallingObject, pCtx, pCallback, pInParams, NULL);

	return hr;
}


ASYNC_ENUM_PACKAGE::ASYNC_ENUM_PACKAGE()
{
	m_pResponseHandler = NULL;
	m_pEnum = NULL;
}
ASYNC_ENUM_PACKAGE::~ASYNC_ENUM_PACKAGE()
{
	if(m_pResponseHandler)
		m_pResponseHandler->Release();
	if(m_pEnum)
		m_pEnum->Release();
}

HRESULT ASYNC_ENUM_PACKAGE::Initialize(IWbemObjectSink *pResponseHandler, 
									   IEnumWbemClassObject *pEnum, 
									   ULONG uCount)
{
	m_uCount = uCount;

	if(m_pResponseHandler = pResponseHandler)
		m_pResponseHandler->AddRef();
	if(m_pEnum = pEnum)
		m_pEnum->AddRef();
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\xmltransport\client\mainsources\sinkmap.h ===
// SinkMap.h: interface for the CSinkMap class.
//
//////////////////////////////////////////////////////////////////////

#ifndef WMI_XML_SINK_MAP_H
#define WMI_XML_SINK_MAP_H

class SinkMapNode
{
public:
	IWbemObjectSink *m_pObjSink;
	SinkMapNode		*m_pNext;

	SinkMapNode(IWbemObjectSink *pObjSink, SinkMapNode *pNext)
	{
		if(m_pObjSink = pObjSink)
			m_pObjSink->AddRef();
		m_pNext = pNext;
	}

	virtual ~SinkMapNode()
	{
		if(m_pObjSink)
			m_pObjSink->Release();
	}
};

class CSinkMap  
{
private:
	CRITICAL_SECTION m_CSMain;
	SinkMapNode *m_pHead;

protected:
	
	SinkMapNode	*Get(IWbemObjectSink *pObjSink);
	SinkMapNode	*Add(IWbemObjectSink *pObjSink);

public:
	CSinkMap();
	virtual ~CSinkMap();

public:

	HRESULT AddToMap(IWbemObjectSink *pObjSink);
	bool	IsCancelled(IWbemObjectSink *pObjSink);
};

#endif // WMI_XML_SINK_MAP_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\xmltransport\client\mainsources\wbemclienttransportfactory.h ===
#ifndef WMI_XML_CLIENT_TRANSPORT_FACTORY
#define WMI_XML_CLIENT_TRANSPORT_FACTORY

/**********************************************************************

The declaration of the Class factory for our component implimenting
the IWbemClientTransport interface.
**********************************************************************/
class CWbemClientTransportFactory:public IClassFactory
{
public:

	virtual HRESULT __stdcall QueryInterface(const IID& iid,void** ppv);
	virtual ULONG   __stdcall AddRef();
	virtual ULONG   __stdcall Release();


	//IClassFactory

	virtual HRESULT __stdcall CreateInstance(IUnknown *pUnknownOuter,const IID& iid, void** ppv);
	
	virtual HRESULT __stdcall LockServer(BOOL bLock);

	CWbemClientTransportFactory();

	virtual ~CWbemClientTransportFactory();

private:
	long m_cRef;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\xmltransport\client\mainsources\semisync.cpp ===
// XMLWbemServices.cpp: implementation of the CXMLWbemServices class.
// our implementation of IWbemServices
//////////////////////////////////////////////////////////////////////

#include "XMLProx.h"
#include "XMLClientPacket.h"
#include "XMLClientPacketFactory.h"
#include "SinkMap.h"
#include "MapXMLtoWMI.h"
#include "XMLWbemServices.h"
#include "XMLEnumWbemClassObject.h"
#include <xmlparser.h>
#include "MyPendingStream.h"
#include "nodefact.h"
#include "XMLEnumWbemClassObject2.h"
#include "URLParser.h"
#include "XMLWbemCallResult.h"


HRESULT CXMLWbemServices::SpawnSemiSyncThreadWithNormalPackage( LPTHREAD_START_ROUTINE pfThreadFunction,
															const BSTR strNsOrObjPath, 
															LONG lFlags, 
															IWbemContext *pCtx, 
															IWbemCallResult **ppCallResult,
															IWbemClassObject *pObject,
															IEnumWbemClassObject *pEnum,
															bool bIsEnum,
															bool bEnumTypeDedicated)
{
	// For enumerations (class, instance and query) there is no CallResult.
	if(!bIsEnum && (NULL == ppCallResult))
		return WBEM_E_INVALID_PARAMETER;

	HRESULT hr = WBEM_NO_ERROR;
	// Create a Call Result object for the client, for non Enumeration operations
	CXMLWbemCallResult *pCallResult = NULL;
	if(!bIsEnum)
	{
		*ppCallResult = NULL;
		if(pCallResult = new CXMLWbemCallResult())
		{
		}
		else 
			hr = WBEM_E_OUT_OF_MEMORY;
	}

	if(SUCCEEDED(hr))
	{
		// Create a package for passing to the thread that executes this call
		ASYNC_NORMAL_PACKAGE *pPackage = NULL;
		if(pPackage = new ASYNC_NORMAL_PACKAGE())
		{
			if(SUCCEEDED(hr = pPackage->Initialize(strNsOrObjPath, 
													lFlags, 
													this, 
													pCtx, 
													pCallResult, 
													pObject,
													pEnum,
													bEnumTypeDedicated)))
			{
				// Kick off the request on the other thread
				HANDLE hChild = NULL;
				if(hChild = CreateThread(NULL, 0, pfThreadFunction, (void*)pPackage, 0, NULL))
				{
					// Set the out parameter for non-Enumeration operations
					if(!bIsEnum)
					{
						*ppCallResult = (IWbemCallResult*)pCallResult;
						pCallResult->AddRef();
					}
					CloseHandle(hChild);
				}
				else 
					hr = WBEM_E_FAILED;
			}

			// Thread wasnt created - hence our responsibility to delete the package
			if(FAILED(hr))
				delete pPackage;
		}
		else 
			hr = WBEM_E_OUT_OF_MEMORY;

		if(!bIsEnum)
			pCallResult->Release();
	}

	return hr;
}

/****************************************************************************************************
			The thread functions that are used for SemiSync operations..
****************************************************************************************************/

DWORD WINAPI Thread_SemiSync_GetClass(LPVOID pPackage)
{
	HRESULT hr = WBEM_NO_ERROR;
	ASYNC_NORMAL_PACKAGE *pThisPackage = (ASYNC_NORMAL_PACKAGE *) pPackage;
	CXMLWbemCallResult  *pCallResult = pThisPackage->m_pCallResult;
	if(SUCCEEDED(hr = CoInitialize(NULL)))
	{
		IWbemClassObject *pClassObject = NULL;
		if(SUCCEEDED(hr = (pThisPackage->m_pCallingObject)->Actual_GetClass(
								pThisPackage->m_strNsOrObjPath,
								pThisPackage->m_lFlags,
								pThisPackage->m_pCtx, &pClassObject)))
		{
			pCallResult->SetResultObject(pClassObject);
			pClassObject->Release();
		}
		CoUninitialize();
	}

	pCallResult->SetCallStatus(hr);

	delete pThisPackage;
	return 0;
}

DWORD WINAPI Thread_SemiSync_GetInstance(LPVOID pPackage)
{
	ASYNC_NORMAL_PACKAGE *pThisPackage = (ASYNC_NORMAL_PACKAGE *) pPackage;
	CXMLWbemCallResult  *pCallResult = pThisPackage->m_pCallResult;
	HRESULT hr = WBEM_NO_ERROR;

	IWbemClassObject *pClassObject = NULL;
	if(SUCCEEDED(hr = (pThisPackage->m_pCallingObject)->Actual_GetInstance(
							pThisPackage->m_strNsOrObjPath,
							pThisPackage->m_lFlags,
							pThisPackage->m_pCtx, &pClassObject)))
	{
		pCallResult->SetResultObject(pClassObject);
		pClassObject->Release();
	}

	pCallResult->SetCallStatus(hr);

	delete pThisPackage;
	return 0;
}


DWORD WINAPI Thread_SemiSync_PutClass(LPVOID pPackage)
{
	ASYNC_NORMAL_PACKAGE *pThisPackage = (ASYNC_NORMAL_PACKAGE *) pPackage;
	CXMLWbemCallResult  *pCallResult = pThisPackage->m_pCallResult;
	HRESULT hr = WBEM_NO_ERROR;

	if(SUCCEEDED(hr = CoInitialize(NULL)))
	{
		hr = (pThisPackage->m_pCallingObject)->Actual_PutClass(
							pThisPackage->m_pWbemClassObject,
							pThisPackage->m_lFlags,
							pThisPackage->m_pCtx);
		CoUninitialize();
	}
	// Nothing more to be set in the call status
	pCallResult->SetCallStatus(hr);

	delete pThisPackage;
	return 0;
}

DWORD WINAPI Thread_SemiSync_PutInstance(LPVOID pPackage)
{
	HRESULT hr = WBEM_NO_ERROR;
	ASYNC_NORMAL_PACKAGE *pThisPackage = (ASYNC_NORMAL_PACKAGE *) pPackage;
	CXMLWbemCallResult  *pCallResult = pThisPackage->m_pCallResult;
	if(SUCCEEDED(hr = CoInitialize(NULL)))
	{
		if(SUCCEEDED(hr = (pThisPackage->m_pCallingObject)->Actual_PutInstance(
								pThisPackage->m_pWbemClassObject,
								pThisPackage->m_lFlags,
								pThisPackage->m_pCtx)))
		{
				VARIANT var;
				VariantInit(&var);

				if(SUCCEEDED(hr = (pThisPackage->m_pWbemClassObject)->Get(L"__RELPATH", 0, &var, NULL, NULL)))
					pCallResult->SetResultString(var.bstrVal);
				// No need to do a VariantClear() since the SetResultString owns the memory now
		}
		CoUninitialize();
	}

	pCallResult->SetCallStatus(hr);

	delete pThisPackage;
	return 0;
}


DWORD WINAPI Thread_SemiSync_DeleteClass(LPVOID pPackage)
{
	ASYNC_NORMAL_PACKAGE *pThisPackage = (ASYNC_NORMAL_PACKAGE *) pPackage;
	CXMLWbemCallResult  *pCallResult = pThisPackage->m_pCallResult;
	HRESULT hr = WBEM_NO_ERROR;

	if(SUCCEEDED(hr = CoInitialize(NULL)))
	{
		hr = (pThisPackage->m_pCallingObject)->Actual_DeleteClass(
								pThisPackage->m_strNsOrObjPath,
								pThisPackage->m_lFlags,
								pThisPackage->m_pCtx);
		CoUninitialize();
	}

	// Nothing more to be set in the call status
	pCallResult->SetCallStatus(hr);

	delete pThisPackage;
	return 0;
}

DWORD WINAPI Thread_SemiSync_DeleteInstance(LPVOID pPackage)
{
	ASYNC_NORMAL_PACKAGE *pThisPackage = (ASYNC_NORMAL_PACKAGE *) pPackage;
	CXMLWbemCallResult  *pCallResult = pThisPackage->m_pCallResult;
	HRESULT hr = WBEM_NO_ERROR;
	if(SUCCEEDED(hr = CoInitialize(NULL)))
	{
		hr = (pThisPackage->m_pCallingObject)->Actual_DeleteInstance(
								pThisPackage->m_strNsOrObjPath,
								pThisPackage->m_lFlags,
								pThisPackage->m_pCtx);
		CoUninitialize();
	}
	// Nothing more to be set in the call status
	pCallResult->SetCallStatus(hr);

	delete pThisPackage;
	return 0;
}


DWORD WINAPI Thread_SemiSync_CreateClassEnum(LPVOID pPackage)
{
	ASYNC_NORMAL_PACKAGE *pThisPackage = (ASYNC_NORMAL_PACKAGE *) pPackage;
	if(SUCCEEDED(CoInitialize(NULL)))
	{
		(pThisPackage->m_pCallingObject)->Actual_CreateClassEnum(
						pThisPackage->m_strNsOrObjPath,
						pThisPackage->m_lFlags,
						pThisPackage->m_pCtx,
						pThisPackage->m_pEnum,
						pThisPackage->m_bDedicatedEnum);
		CoUninitialize();
	}
	delete pThisPackage;
	return 0;
}

DWORD WINAPI Thread_SemiSync_CreateInstanceEnum(LPVOID pPackage)
{
	ASYNC_NORMAL_PACKAGE *pThisPackage = (ASYNC_NORMAL_PACKAGE *) pPackage;
	if(SUCCEEDED(CoInitialize(NULL)))
	{
		(pThisPackage->m_pCallingObject)->Actual_CreateInstanceEnum(
						pThisPackage->m_strNsOrObjPath,
						pThisPackage->m_lFlags,
						pThisPackage->m_pCtx,
						pThisPackage->m_pEnum,
						pThisPackage->m_bDedicatedEnum);
		CoUninitialize();
	}
	delete pThisPackage;
	return 0;
}


DWORD WINAPI Thread_SemiSync_ExecQuery(LPVOID pPackage)
{
	ASYNC_QUERY_PACKAGE *pThisPackage = (ASYNC_QUERY_PACKAGE *) pPackage;
	if(SUCCEEDED(CoInitialize(NULL)))
	{
		(pThisPackage->m_pCallingObject)->Actual_ExecQuery(
						pThisPackage->m_strQueryLanguage,
						pThisPackage->m_strQuery,
						pThisPackage->m_lFlags,
						pThisPackage->m_pCtx,
						pThisPackage->m_pEnum);
		CoUninitialize();
	}
	delete pThisPackage;
	return 0;
}

DWORD WINAPI Thread_SemiSync_ExecMethod(LPVOID pPackage)
{
	ASYNC_METHOD_PACKAGE *pThisPackage = (ASYNC_METHOD_PACKAGE *) pPackage;
	CXMLWbemCallResult  *pCallResult = pThisPackage->m_pCallResult;

	HRESULT hr = S_OK;
	IWbemClassObject *pOutParams = NULL;
	if(SUCCEEDED(hr = CoInitialize(NULL)))
	{
		if(SUCCEEDED(hr = (pThisPackage->m_pCallingObject)->Actual_ExecMethod(
					pThisPackage->m_strNsOrObjPath,
					pThisPackage->m_strMethod,
					pThisPackage->m_lFlags,
					pThisPackage->m_pCtx,
					pThisPackage->m_pWbemClassObject,
					&pOutParams)))
		{
			if(pOutParams)
			{
				pCallResult->SetResultObject(pOutParams);
				pOutParams->Release();
			}
		}
		CoUninitialize();
	}

	pCallResult->SetCallStatus(hr);

	delete pThisPackage;
	return 0;
}

DWORD WINAPI Thread_SemiSync_OpenNamespace(LPVOID pPackage)
{
	ASYNC_NORMAL_PACKAGE *pThisPackage = (ASYNC_NORMAL_PACKAGE *) pPackage;
	CXMLWbemCallResult  *pCallResult = pThisPackage->m_pCallResult;

	HRESULT hr = S_OK;
	if(SUCCEEDED(hr = CoInitialize(NULL)))
	{
		IWbemServices *pWbemServices = NULL;
		if(SUCCEEDED(hr = (pThisPackage->m_pCallingObject)->Actual_OpenNamespace(
			pThisPackage->m_strNsOrObjPath,
			pThisPackage->m_lFlags,
			pThisPackage->m_pCtx,
			&pWbemServices)))
		{
			pCallResult->SetResultServices(pWbemServices);
			pWbemServices->Release();
		}
		CoUninitialize();
	}

	pCallResult->SetCallStatus(hr);

	delete pThisPackage;
	return 0;
}


/****************************************************************************************************
			End of threads that would be used for SemiSync operations..
****************************************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\xmltransport\client\mainsources\sinkmap.cpp ===
// SinkMap.cpp: implementation of the CSinkMap class.
//
//////////////////////////////////////////////////////////////////////

#include "XMLProx.h"
#include "SinkMap.h"

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CSinkMap::CSinkMap(): m_pHead(NULL)
{
	InitializeCriticalSection(&m_CSMain);
}

CSinkMap::~CSinkMap()
{
	SinkMapNode *pTmp = NULL;
	while(m_pHead)
	{
		pTmp = m_pHead;
		m_pHead = pTmp->m_pNext;
		delete pTmp;
	}

	DeleteCriticalSection(&m_CSMain);
}


// Add a Sink to the Map
HRESULT CSinkMap::AddToMap(IWbemObjectSink *pObjSink)
{
	HRESULT hr = S_OK;
	SinkMapNode *pNode = NULL;

	EnterCriticalSection(&m_CSMain);
	// See if it is already in the Map
	if((pNode = Get(pObjSink)) == NULL)
		pNode = Add(pObjSink); //create new entry
	LeaveCriticalSection(&m_CSMain);

	if(NULL == pNode)
		hr = E_FAIL;

	return hr;
}

// Check if a Sink is in the Map
bool CSinkMap::IsCancelled(IWbemObjectSink *pObjSink)
{
	bool bCancelled = false;
	SinkMapNode *pNode = NULL;

	EnterCriticalSection(&m_CSMain);
	if((pNode = Get(pObjSink)) != NULL)
		bCancelled = true;
	LeaveCriticalSection(&m_CSMain);
	
	return bCancelled;
}

/************************************************************************************************
			Internal Functions.... Can be accessed only by public members who are all
			protected with Critical sections....no need for mutual exclusion from this
			point onwards..
*************************************************************************************************/

SinkMapNode *CSinkMap::Add(IWbemObjectSink *pObjSink)
{
	SinkMapNode *pNode = NULL;
	if(pNode = new SinkMapNode(pObjSink, NULL))
	{
		pNode->m_pNext = m_pHead;
		m_pHead = pNode;
	}
	return pNode;
}

SinkMapNode *CSinkMap::Get(IWbemObjectSink *pObjSink)
{
	SinkMapNode *pNode = m_pHead;

	while(pNode)
	{
		if(pNode->m_pObjSink == pObjSink)
			break;
		pNode = pNode->m_pNext;
	}

	return pNode;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\xmltransport\client\mainsources\wbemclienttransportfactory.cpp ===
#include "XMLProx.h"
#include "WbemClientTransportFactory.h"
#include "XMLWbemClientTransport.h"

extern long g_lServerLocks;
extern long g_lComponents; //Declared in the XMLProx.dll


CWbemClientTransportFactory::CWbemClientTransportFactory():m_cRef(1)
{
	InterlockedIncrement(&g_lComponents);
}

CWbemClientTransportFactory::~CWbemClientTransportFactory()
{
	InterlockedDecrement(&g_lComponents);
}

HRESULT __stdcall CWbemClientTransportFactory::QueryInterface(const IID& iid,void **ppv)
{
	if((iid == IID_IUnknown) || (iid == IID_IClassFactory))
	{
		*ppv = static_cast<IClassFactory*>(this);
	}
	else
	{
		*ppv = NULL;
		return E_NOINTERFACE;
	}

	reinterpret_cast<IUnknown*>(*ppv)->AddRef();

	return S_OK;
}

ULONG __stdcall CWbemClientTransportFactory::AddRef()
{
	return InterlockedIncrement(&m_cRef);
}

ULONG __stdcall CWbemClientTransportFactory::Release()
{
	if(InterlockedDecrement(&m_cRef)==0)
	{
		delete this;
		return 0;
	}
	return m_cRef;
}

HRESULT __stdcall CWbemClientTransportFactory::CreateInstance(IUnknown* pUnknownOuter,const IID& iid,void **ppv)
{
	HRESULT hr;

	if(pUnknownOuter != NULL)
	{
		hr = CLASS_E_NOAGGREGATION;
	}
	else
	if((iid == IID_IWbemClientTransport)||(iid == IID_IUnknown))
	{
		
		CXMLWbemClientTransport *pWbemClientTransport = NULL;
		pWbemClientTransport = new CXMLWbemClientTransport;
		
		if( pWbemClientTransport == NULL )
		{
			return E_OUTOFMEMORY;
		}

		hr = pWbemClientTransport->QueryInterface(iid,ppv);

		pWbemClientTransport->Release(); //if queryinterface fails object kills itself
		
	}
	else
	{
		hr = E_NOTIMPL;
	}

	return hr;
}

HRESULT __stdcall CWbemClientTransportFactory::LockServer(BOOL bLock)
{
	if(bLock)
	{
		InterlockedIncrement(&g_lServerLocks);
	}
	else
	{
		InterlockedDecrement(&g_lServerLocks);
	}

	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\xmltransport\client\mainsources\package.h ===
/***************************************************************************************************
		Structures used by CXMLWbemService's Async functions to package
		data and pass them to threads that do the job.
***************************************************************************************************/


#ifndef WMI_XML_THREAD_PACKAGES_H
#define WMI_XML_THREAD_PACKAGES_H

enum eENUMERATIONTYPE
{
	ENUMERATECLASSES = 1,
	ENUMERATEINSTANCES,
	EXECQUERY,
	INVALIDOPERATION
};

class CXMLWbemServices;

class NOVABASEPACKET
{
public:
	BSTR				m_strNsOrObjPath;	// Holds either a namespace, or a class path or an instance path
	ULONG				m_lFlags;
	CXMLWbemServices *	m_pCallingObject;	// This is required to call the Actual_*() functions on the same HTTP connection
	IWbemContext		*m_pCtx;
	IWbemClassObject	*m_pWbemClassObject;// Used only for Put() operations
	IEnumWbemClassObject *m_pEnum;			//Used only when an enumerator is needed (ClassEnum, InstanceEnum and Queries)
	bool				m_bDedicatedEnum;	// Whether this is a dedicated Enumeration - Used only for CreateClassEnum and CreateINstanceEnum

	CXMLWbemCallResult	*m_pCallResult;		// Used only for SemiSync Operations
	IWbemObjectSink		*m_pResponseHandler;// USed only for Async Operations


	NOVABASEPACKET();
	virtual ~NOVABASEPACKET();

	HRESULT Initialize(const BSTR strNsOrObjPath,
		ULONG lFlags,
		CXMLWbemServices *pCallingObject,
		IWbemContext *pCtx, 
		CXMLWbemCallResult *pCallback,
		IWbemClassObject *pObject,
		IEnumWbemClassObject *pEnum,
		bool bDedicatedEnum = false
		);

	HRESULT SetResponsehandler(IWbemObjectSink *pCallback);
};

typedef NOVABASEPACKET ASYNC_NORMAL_PACKAGE; 

//parameters used by ExecQuery function
class ASYNC_QUERY_PACKAGE : public NOVABASEPACKET
{
public:
	BSTR	m_strQueryLanguage;
	BSTR	m_strQuery;

	ASYNC_QUERY_PACKAGE();
	virtual ~ASYNC_QUERY_PACKAGE();

	HRESULT Initialize(const BSTR QueryLanguage,const BSTR Query,
								ULONG lFlags,
								CXMLWbemServices *pCallingObject,
								IWbemContext *pCtx, 
								IEnumWbemClassObject *pEnum);
};

//parameters used by ExecuteMethod function
class ASYNC_METHOD_PACKAGE : public NOVABASEPACKET
{
public:
	BSTR	m_strMethod;
	ASYNC_METHOD_PACKAGE();
	virtual ~ASYNC_METHOD_PACKAGE();

	HRESULT Initialize(const BSTR strObjectPath, 
								const BSTR strMethod,
								ULONG lFlags,
								CXMLWbemServices *pCallingObject,
								IWbemContext *pCtx, 
								CXMLWbemCallResult *pCallback,
								IWbemClassObject *pInParams);

};

// This is used for implementing NextAsync() on enumerators
class ASYNC_ENUM_PACKAGE
{
public:
	IWbemObjectSink		*m_pResponseHandler;
	IEnumWbemClassObject *m_pEnum; 
	ULONG m_uCount;

	ASYNC_ENUM_PACKAGE();
	virtual ~ASYNC_ENUM_PACKAGE();
	HRESULT Initialize(IWbemObjectSink *pResponseHandler, IEnumWbemClassObject *pEnum, ULONG uCount);

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\xmltransport\client\mainsources\xmlenumwbemclassobject.cpp ===
// XMLWbemClassObject.cpp: implementation of the CXMLEnumWbemClassObject class.
//
//////////////////////////////////////////////////////////////////////

#include "XMLProx.h"
#include "Utils.h"
#include "SinkMap.h"
#include "XMLClientpacket.h"
#include "XMLClientpacketFactory.h"
#include "XMLWbemServices.h"
#include "XMLEnumWbemClassObject.h"

extern long g_lComponents; //Declared in the XMLProx.dll
extern BSTR WMI_XML_STR_IRETURN_VALUE;

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////
CXMLEnumWbemClassObject::CXMLEnumWbemClassObject():
													m_cRef(1),
													m_pXMLDomDocument(NULL),
													m_pXMLDomNodeList(NULL),
													m_hEventBlockNext(NULL),
													m_bSemiSync(false),
													m_bEndofDocuments(false),
													m_pszNamespace(NULL),
													m_pszServer(NULL),
													m_hrSemiSyncFailure(S_OK)
{
	InterlockedIncrement(&g_lComponents);
	InitializeCriticalSection(&m_CriticalSection);
}


// It is assumed that this is called only once for this object
// Calling multiple times results in a memory leak
HRESULT CXMLEnumWbemClassObject::Initialize(bool bSemiSync, LPCWSTR pszServer, LPCWSTR pszNamespace)
{
	HRESULT hr = S_OK;

	// Create a mutex for semi-sync enumerations
	if(m_bSemiSync = bSemiSync)
	{
		// Create it in an un-signalled state
		if(!(m_hEventBlockNext = CreateEvent(NULL, TRUE, FALSE, NULL)))
			hr = E_FAIL;
	}

	if(SUCCEEDED(hr))
	{
		if(SUCCEEDED(hr = AssignString(&m_pszServer, pszServer)))
			hr = AssignString(&m_pszNamespace, pszNamespace);
	}

	return hr;
}

CXMLEnumWbemClassObject::~CXMLEnumWbemClassObject()
{
	InterlockedDecrement(&g_lComponents);

	delete [] m_pszNamespace;
	delete [] m_pszServer;

	if(m_pXMLDomDocument)
		m_pXMLDomDocument->Release();
	if(m_pXMLDomNodeList)
		m_pXMLDomNodeList->Release();

	DeleteCriticalSection(&m_CriticalSection);

	if(m_bSemiSync && m_hEventBlockNext)
		CloseHandle(m_hEventBlockNext);
}

HRESULT CXMLEnumWbemClassObject::QueryInterface(REFIID riid,void ** ppvObject)
{
	if (riid == IID_IUnknown || riid == IID_IEnumWbemClassObject)
    {
        *ppvObject = (IEnumWbemClassObject*) this;
        AddRef();
        return WBEM_S_NO_ERROR;
    }
    else 
		return E_NOINTERFACE;
}

ULONG CXMLEnumWbemClassObject::AddRef()
{
	return InterlockedIncrement(&m_cRef);
}

ULONG CXMLEnumWbemClassObject::Release()
{
	if(InterlockedDecrement(&m_cRef)==0)
		delete this;

	return m_cRef;
}

HRESULT CXMLEnumWbemClassObject::Clone(IEnumWbemClassObject **ppEnum)
{
	return E_FAIL;
}

HRESULT CXMLEnumWbemClassObject::Next(LONG lTimeOut,
									  ULONG uCount,
									  IWbemClassObject **pArrayOfObjects,
									  ULONG *puReturned)
{
	if(NULL == pArrayOfObjects)
		return WBEM_E_INVALID_PARAMETER;

	// This is as per the documentation
	if(0 == uCount)
		return WBEM_S_FALSE;

	// For Semi-sync operations, the response might not be ready yet
	// Hence we need to block here until this event has been signalled by InitializeResponse()
	if(m_bSemiSync)
	{
		WaitForSingleObject(m_hEventBlockNext,INFINITE);
		if(FAILED(m_hrSemiSyncFailure))
			return m_hrSemiSyncFailure;
	}
		
	EnterCriticalSection(&m_CriticalSection);

	HRESULT hr = S_OK;
	UINT uReturned = 0;

	if(m_bEndofDocuments)
	{
		if(NULL != puReturned)
			*puReturned = 0;
		hr = WBEM_S_FALSE;
	}
	else // We have some objects left in the response
	{
		// This loop loops until uReturned < uCount or till we reach the end of enumeration
		// whichever is earlier, or if there was some unexpected error in between..
		IXMLDOMNode *pXMLTempNode = NULL;
		IWbemClassObject *pObject = NULL;

		while(uReturned<uCount && !m_bEndofDocuments)
		{
			if(SUCCEEDED(hr = m_pXMLDomNodeList->nextNode(&pXMLTempNode)) && pXMLTempNode)
			{				
				IXMLDOMNode *pObjectNode = NULL;
				if(SUCCEEDED(hr = Parse_IRETURNVALUE_Node(pXMLTempNode, &pObjectNode)))
				{
					if(SUCCEEDED(hr = m_MapXMLtoWMI.MapDOMtoWMI(m_pszServer, m_pszNamespace, pObjectNode, NULL, &pObject)) && pObject)
					{
						pArrayOfObjects[uReturned] = pObject;
						uReturned++;
					}
					pObjectNode->Release();
				}
				pXMLTempNode->Release();
				pXMLTempNode = NULL;
			}
			else
				m_bEndofDocuments = true;
		}
	}

	if(NULL != puReturned)
		*puReturned = uReturned;
	
	LeaveCriticalSection(&m_CriticalSection);
	
	return (uReturned < uCount) ? WBEM_S_FALSE : WBEM_S_NO_ERROR;
}

HRESULT CXMLEnumWbemClassObject::NextAsync(ULONG uCount, IWbemObjectSink *pSink)
{
	if(NULL == pSink)
		return WBEM_E_INVALID_PARAMETER;

	// This is as per the documentation
	if(0 == uCount)
		return WBEM_S_FALSE;

	HRESULT hr = S_OK;
	EnterCriticalSection(&m_CriticalSection);

	ASYNC_ENUM_PACKAGE *pPackage = NULL;
	if(pPackage = new ASYNC_ENUM_PACKAGE())
	{
		if(SUCCEEDED(hr = pPackage->Initialize(pSink, this, uCount)))
		{
			HANDLE hThread = NULL;
			if(hThread == CreateThread(NULL, 0, Thread_Async_Next, (void*)pPackage, 0, NULL))
				CloseHandle(hThread);
			else
				hr = WBEM_E_FAILED;
		}

		// A thread was not created - hence it is our job to delete the package
		if(FAILED(hr))
			delete pPackage;
	}
	else
		E_OUTOFMEMORY;

	LeaveCriticalSection(&m_CriticalSection);
	return hr;
}

HRESULT CXMLEnumWbemClassObject::Reset( )
{
	return E_FAIL;
}	

HRESULT CXMLEnumWbemClassObject::Skip(LONG lTimeOut, ULONG UCount)
{
	if(NULL == m_pXMLDomNodeList)
		return WBEM_E_FAILED;

	EnterCriticalSection(&m_CriticalSection);
	IXMLDOMNode *pNode = NULL;
	for(ULONG i=0; i<UCount; i++)
	{
		if(SUCCEEDED(m_pXMLDomNodeList->nextNode(&pNode)) && pNode)
		{
			pNode->Release();
			pNode = NULL;
		}
		else
			break;
		
	}
	LeaveCriticalSection(&m_CriticalSection);

	return (i==UCount)? WBEM_NO_ERROR : WBEM_S_FALSE;
}


HRESULT CXMLEnumWbemClassObject::SetResponse(IXMLDOMDocument *pDoc)
{
	if(NULL == pDoc)
		return WBEM_E_INVALID_PARAMETER;

	HRESULT hr = S_OK;

	EnterCriticalSection(&m_CriticalSection); 

	// Make a copy of the entire response
	m_pXMLDomDocument = pDoc;
	m_pXMLDomDocument->AddRef();

	// Get the IRETURNVALUE node
	IXMLDOMNodeList *pNodeList = NULL;
	if(SUCCEEDED(hr = m_pXMLDomDocument->getElementsByTagName(WMI_XML_STR_IRETURN_VALUE, &pNodeList)) && pNodeList)
	{
		IXMLDOMNode *pParentNode = NULL;
		if(SUCCEEDED(hr = pNodeList->nextNode(&pParentNode)) && pParentNode)
		{
			// It's children should be either VALUE.NAMEDOBJECTs or CLASSes 
			//find out if there are any CLASS/INSTANCEs to be enumerated at all..
			VARIANT_BOOL vbHaschildren = VARIANT_FALSE;
			if(SUCCEEDED(hr = pParentNode->hasChildNodes(&vbHaschildren)))
			{
				if(VARIANT_FALSE == vbHaschildren)
					m_bEndofDocuments = true;
				else
				{
					// Get the list of objects that we're interested in
					hr = pParentNode->get_childNodes(&m_pXMLDomNodeList);
				}
			}
			pParentNode->Release();
		}
		pNodeList->Release();
	}

	LeaveCriticalSection(&m_CriticalSection);

	// Set the event only for semi-sync operation
	if(SUCCEEDED(hr))
	{
		if(m_bSemiSync)
			SetEvent(m_hEventBlockNext); // Next() blocks on this
	}
	return hr;
}

/***********************************************************************************************************

	Thread for the NextAsync... 
************************************************************************************************************/

DWORD WINAPI Thread_Async_Next(LPVOID pPackage)
{
	ASYNC_ENUM_PACKAGE *pThisPackage = (ASYNC_ENUM_PACKAGE *) pPackage;
	IWbemObjectSink  *pSink = pThisPackage->m_pResponseHandler;

	HRESULT hr = WBEM_NO_ERROR;
	if(SUCCEEDED(hr = CoInitialize(NULL)))
	{
		if(pThisPackage->m_uCount >0)
		{
			IWbemClassObject **ppArrayOfObjects = NULL;
			if(ppArrayOfObjects = new IWbemClassObject*[pThisPackage->m_uCount])
			{
				ULONG uReturned = 0;
				if(SUCCEEDED(hr = (pThisPackage->m_pEnum)->Next(WBEM_INFINITE, pThisPackage->m_uCount, ppArrayOfObjects, &uReturned)))
				{
					pSink->Indicate(uReturned, ppArrayOfObjects);
					for(ULONG i=0; i<uReturned; i++)
						ppArrayOfObjects[i]->Release();
				}
				delete [] ppArrayOfObjects;
			}
			else
				hr = E_OUTOFMEMORY;
		}
		CoUninitialize();
	}
	pSink->SetStatus(WBEM_STATUS_COMPLETE, hr, NULL, NULL);

	delete pThisPackage;
	return 0;
}

HRESULT CXMLEnumWbemClassObject::AcceptFailure(HRESULT hr)
{
	RELEASEINTERFACE(m_pXMLDomDocument);
	RELEASEINTERFACE(m_pXMLDomNodeList);

	if(m_bSemiSync)
	{
		m_hrSemiSyncFailure = hr;
		SetEvent(m_hEventBlockNext);
	}

	return S_OK;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\xmltransport\client\mainsources\synchronous.cpp ===
// XMLWbemServices.cpp: implementation of the CXMLWbemServices class.
// our implementation of IWbemServices
//////////////////////////////////////////////////////////////////////

#include "XMLProx.h"
#include "XMLClientPacket.h"
#include "XMLClientPacketFactory.h"
#include "SinkMap.h"
#include "MapXMLtoWMI.h"
#include "XMLWbemServices.h"
#include "XMLEnumWbemClassObject.h"
#include <xmlparser.h>
#include "MyPendingStream.h"
#include "nodefact.h"
#include "XMLEnumWbemClassObject2.h"
#include "URLParser.h"
#include "XMLWbemCallResult.h"

extern long g_lComponents; //Declared in the XMLProx.dll

///////////////////////////////////////////////////////////////////////

// Initialize the static of the class
LPCWSTR		CXMLWbemServices::s_pwszWMIString = L"MicrosoftWMI"; //identity of a WMI server


//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CXMLWbemServices::CXMLWbemServices()
					:	m_cRef(1),
						m_pwszServername(NULL),
						m_pwszBracketedServername(NULL),
						m_pwszNamespace(NULL),
						m_pwszUser(NULL),
						m_pwszPassword(NULL),
						m_pwszLocale(NULL),
						m_pwszAuthority(NULL),
						m_pConnectionAgent(NULL),
						m_pwszOptionsResponse(NULL),
						m_bWMIServer(false),
						m_pCtx(NULL),
						m_ePathstyle(NOVAPATH),
						m_lSecurityFlags(0),
						m_bTryMpost(true),
						m_hMutex(NULL),
						m_pwszProxyName(NULL),
						m_pwszProxyBypass (NULL)


{
	InterlockedIncrement(&g_lComponents);
}

CXMLWbemServices::~CXMLWbemServices()
{
	InterlockedDecrement(&g_lComponents);

	delete [] m_pwszServername;
	delete [] m_pwszBracketedServername;
	delete [] m_pwszNamespace;
	delete [] m_pwszUser;
	delete [] m_pwszPassword;
	delete [] m_pwszLocale;
	delete [] m_pwszAuthority;
	delete [] m_pwszOptionsResponse;
	delete m_pConnectionAgent;
	delete [] m_pwszProxyName;
	delete [] m_pwszProxyBypass;

	CloseHandle(m_hMutex);

	if(m_pCtx)
		m_pCtx->Release();

}

/****************************************************************************************************
			Member Helper functions ......
****************************************************************************************************/

HRESULT CXMLWbemServices::QueryInterface(REFIID iid,void ** ppvObject)
{
	if(iid == IID_IWbemServices)
	{
		*ppvObject = (IWbemServices*)this;
		AddRef();
		return S_OK;
	}

	if(iid == IID_IUnknown)
	{
		*ppvObject = (IUnknown*)((IWbemServices*)this);
		AddRef();
		return S_OK;
	}

	if(iid == IID_IClientSecurity)
	{
		*ppvObject = (IClientSecurity*)this;
		AddRef();		
		return S_OK;
	}
	

	*ppvObject = NULL;
	return E_NOINTERFACE;
}

ULONG CXMLWbemServices::AddRef()
{
	return InterlockedIncrement(&m_cRef);
}

ULONG CXMLWbemServices::Release()
{
	if(InterlockedDecrement(&m_cRef)==0)
		delete this;

	return m_cRef;
}

//Function used to parse the object path and decide whether it is a class, instance or a namespace
HRESULT	CXMLWbemServices::ParsePath(const BSTR strObjPath, ePATHTYPE *pePathType)
{
	HRESULT hr = S_OK;
	
	// Parse the object path
	CObjectPathParser theParser;
	ParsedObjectPath *pParsedPath = NULL;
	
	switch(theParser.Parse(strObjPath, &pParsedPath))
	{
		case CObjectPathParser::NoError:
			break;
		default:
			*pePathType = INVALIDOBJECTPATH;
			return WBEM_E_INVALID_PARAMETER;
	}

	if(pParsedPath->IsInstance())
		*pePathType = INSTANCEPATH;
	else
	if(pParsedPath->IsClass())
		*pePathType = CLASSPATH;

	theParser.Free(pParsedPath);
	return hr;
}

//CXMLWbemServices is designed to be created in a two-step process. 
//Initialize MUST be called after constructing this object. 
HRESULT CXMLWbemServices::Initialize(WCHAR*	pwszServername, 
								    WCHAR*  pwszNamespace,
									WCHAR*	pwszUser,
									WCHAR*	pwszPassword,
									WCHAR*	pwszLocale,
									LONG	lSecurityFlags,
									WCHAR*	pwszAuthority,
									IWbemContext *pCtx,
									WCHAR *pwszOptionsResponse, 
									ePATHSTYLE PathStyle)
{
	m_lSecurityFlags = lSecurityFlags;
	m_ePathstyle = PathStyle;

	// Store the context that is given to us
	if(m_pCtx = pCtx)
		m_pCtx->AddRef();

	HRESULT hr = S_OK;

	// Copy over the server, namespace, user, passwd,  and authority information
	//=======================================================================
	if(SUCCEEDED(hr = AssignString(&m_pwszServername, pwszServername)) &&
		SUCCEEDED(hr = AssignString(&m_pwszNamespace, pwszNamespace)) &&
		SUCCEEDED(hr = AssignString(&m_pwszUser, pwszUser)) &&
		SUCCEEDED(hr = AssignString(&m_pwszPassword, pwszPassword)) &&
		SUCCEEDED(hr = AssignString(&m_pwszAuthority, pwszAuthority)))
	{
		// Create a bracketed server name for settting the __SERVER property in the objects
		if(m_pwszBracketedServername = new WCHAR[wcslen(m_pwszServername) + 3])
		{
			wcscpy(m_pwszBracketedServername, L"[");
			wcscat(m_pwszBracketedServername, m_pwszServername);
			wcscat(m_pwszBracketedServername, L"]");
		}
		else
			hr = E_OUTOFMEMORY;
		
		// Process and store the OPTIONS response
		//=======================================
		if(SUCCEEDED(hr))
		{
			if(NULL == pwszOptionsResponse)
				m_bWMIServer = false;
			else
			{
				if(SUCCEEDED(hr = AssignString(&m_pwszOptionsResponse,pwszOptionsResponse)))
				{
					if(wcsstr(pwszOptionsResponse,s_pwszWMIString)!=NULL) //it is a WMI server
						m_bWMIServer = true;
					else
						m_bWMIServer = false;
				}
			}
		}

		// Process and store the locale information
		//=========================================
		if(SUCCEEDED(hr))
		{
			if(NULL != pwszLocale) //some locale was passed on by client 
			{
				UINT iLocale = ConvertMSLocaleStringToUint(pwszLocale);
				int iResult =  GetLocaleInfo(	iLocale,      // locale identifier
												LOCALE_SISO639LANGNAME ,    // information type
												NULL,  // information buffer
												0       // size of buffer
												); 

				if(m_pwszLocale = new WCHAR[iResult])
				{
					iResult = GetLocaleInfo(	iLocale,      // locale identifier
												LOCALE_SISO639LANGNAME   ,    // information type
												m_pwszLocale,  // information buffer
												iResult       // size of buffer
												);

					// GetLocalInfo() returns 0 when it fails
					if(0 == iResult)
						hr = WBEM_E_INVALID_PARAMETER;
				}
				else
					hr = E_OUTOFMEMORY;
			}
		}

		// Create a HTTP Connection Agent and initialize it
		//===================================================
		if(SUCCEEDED(hr))
		{
			if(m_pConnectionAgent = new CHTTPConnectionAgent())
				hr = m_pConnectionAgent->InitializeConnection(m_pwszServername,m_pwszUser,m_pwszPassword);
			else
				hr = E_OUTOFMEMORY;
		}

		// Process the Proxy information from the context and set it on the connection agent
		// We need this for later use, if a dedicated enumeration is started on this IWbemServices
		//===================================================================================
		if(SUCCEEDED(hr) && m_pCtx)
		{
			if(SUCCEEDED(hr = GetProxyInformation(m_pCtx, &m_pwszProxyName, &m_pwszProxyBypass)))
				//not checking for return val because proxyinfo can be null in this case.
				m_pConnectionAgent->SetProxyInformation(m_pwszProxyName, m_pwszProxyBypass);
		}

		// Create a Mutex for serializing requests that go to the HTTP connection agent
		//================================================================================
		if(m_hMutex = CreateMutex(NULL, TRUE, NULL))
			ReleaseMutex(m_hMutex); //mutex is ready for use now.
		else
			hr = E_FAIL;
	}
	return hr;
}

//Helper function that does the following jobs
//1.	select POST or M-POST depending on server's capabilities and store the 
//		selected option for future calls on this connection

//2.	Get the HTTP headers and XML message BODY from the packet 

//3.	Send them to the server using CHTTPConnectionAgent

//4.	Get the resulting status code from the server.
HRESULT CXMLWbemServices::SendPacket(CXMLClientPacket *pPacketClass, CHTTPConnectionAgent *pDedicatedConnection)
{
	
	if(NULL == pPacketClass)
		return WBEM_E_INVALID_PARAMETER;

	// This will be used only in Whistler, and that too
	// if a transaction is currently under way.
	// pPacketClass->SetTransactionGUID(&m_GUID);

	// This will contain the HTTP reponse status
	DWORD dwResultStatus = 0;

	// Start with "M-POST", if server doesnt accept then try "POST" - fail only after..
	// in compliance with HTTP RFC. However, if we've already done that on this
	// connection, and the server supports only POST, there's no need to try M-POST again.
	HRESULT hr = S_OK;
	if(m_bTryMpost)
		hr = SendPacketForMethod(2, pPacketClass, pDedicatedConnection, &dwResultStatus); // 2 for M-POST
	else
		dwResultStatus = 501; // We assume that the server does not support M-POST

	// Try POST if necessary
	if(SUCCEEDED(hr))
	{
		if((dwResultStatus == 501/*Not Implemented*/)||(dwResultStatus == 510/*Not Extended*/))
		{
			m_bTryMpost = false;
			hr = SendPacketForMethod(1, pPacketClass, pDedicatedConnection, &dwResultStatus); // 1 for POST
		}
	}

	// If the call failed at the HTTP layer itself, let's make an
	// attempt to map the failure to WMI
	if(SUCCEEDED(hr) && dwResultStatus != 200)
		hr = MapHttpErrtoWbemErr(dwResultStatus);

	return hr;
}

//Used by SendPacket - iMethod is 2 for M-POST and 1 for POST
HRESULT	CXMLWbemServices::SendPacketForMethod(int iMethod, CXMLClientPacket *pPacketClass, CHTTPConnectionAgent *pDedicatedConnection, DWORD *pdwResultStatus)
{
	HRESULT hr = S_OK;

	*pdwResultStatus = 0;
	pPacketClass->SetPostType(iMethod); 

	WCHAR *pwszHeader = NULL;
	if(SUCCEEDED(hr = pPacketClass->GetHeader(&pwszHeader)))
	{
		WCHAR *pwszBody = NULL;
		DWORD dwSizeofBody = 0;
		if(SUCCEEDED(hr = pPacketClass->GetBody(&pwszBody,&dwSizeofBody)))
		{
			// If a dedicated connection is being requested, then use it. 
			// Otherwise, use the connection being used for all requests 
			// on this IWbemServices
			CHTTPConnectionAgent *pConnectionToBeUsed = (pDedicatedConnection) ? pDedicatedConnection : m_pConnectionAgent;
			if(SUCCEEDED(hr = pConnectionToBeUsed->Send((iMethod == 2)? L"M-POST" : L"POST" , pwszHeader, pwszBody,dwSizeofBody)))
				pConnectionToBeUsed->GetStatusCode(pdwResultStatus);
			delete [] pwszBody;
		}
		delete [] pwszHeader;
	}

	return hr;
}




/****************************************************************************************************
			End of Helper member  functions ......
****************************************************************************************************/


/****************************************************************************************************
			Synchonous Entry Points
****************************************************************************************************/

HRESULT  CXMLWbemServices::GetObject(const BSTR strObjectPath,
									LONG lFlags,
									IWbemContext *pCtx,                        
									IWbemClassObject **ppObject,    
									IWbemCallResult **ppCallResult)
{
	HRESULT hr = WBEM_NO_ERROR;
	// Check for validity of input arguments
	//=====================================
	if(!ppObject)
		return hr;

	// Check for validity of the flags
	//=================================
	//these are the only valid flags for this operation..
	LONG lAllowedFlags = (	WBEM_FLAG_USE_AMENDED_QUALIFIERS|WBEM_FLAG_RETURN_WBEM_COMPLETE|
							WBEM_FLAG_RETURN_IMMEDIATELY|WBEM_FLAG_DIRECT_READ);

	if((lFlags | lAllowedFlags) != lAllowedFlags)
			return WBEM_E_INVALID_PARAMETER;

	// Parse the object path to decide whether it is a class or instance
	ePATHTYPE ePathType = INVALIDOBJECTPATH;
	if(NULL == strObjectPath)
		ePathType = CLASSPATH;
	else if(strObjectPath[0]=='\0'/*empty class*/)
		ePathType = CLASSPATH;
	else
		ParsePath(strObjectPath, &ePathType);
	
	
	//Invoke actual_getclass, it will perform a "GetObject" if WHISTLERPATH
	if((ePathType == CLASSPATH)||(m_ePathstyle != NOVAPATH)) 
	{
		// Semi-sync call
		if(lFlags & WBEM_FLAG_RETURN_IMMEDIATELY)
		{
			hr = SpawnSemiSyncThreadWithNormalPackage(Thread_SemiSync_GetClass,
								strObjectPath, lFlags, pCtx, ppCallResult, NULL, NULL);
		}
		else
		//synchronous call
		{
			hr = Actual_GetClass(strObjectPath, lFlags, pCtx, ppObject);
		}
	}
	else if(ePathType == INSTANCEPATH)
	{
		if(lFlags & WBEM_FLAG_RETURN_IMMEDIATELY)
		{
			hr = SpawnSemiSyncThreadWithNormalPackage(Thread_SemiSync_GetInstance,
								strObjectPath, lFlags, pCtx, ppCallResult, NULL, NULL);
		}
		else //synchronous call
		{
			hr = Actual_GetInstance(strObjectPath,lFlags,pCtx,ppObject);
		}
		
	}
	else  
		hr = WBEM_E_INVALID_OBJECT_PATH;

	return hr;
}


HRESULT CXMLWbemServices::OpenNamespace( const BSTR strNamespace, LONG lFlags, 
										IWbemContext *pCtx, IWbemServices **ppWorkingNamespace, 
										IWbemCallResult **ppResult)
{

	// Do Input Parameter Verification
	//=======================================

	// Check for validity of the namespace parameter
	if(SysStringLen(strNamespace) == 0)
		return WBEM_E_INVALID_PARAMETER;

	// Check for the validity of the flags
	LONG lAllowedFlags = (WBEM_FLAG_RETURN_IMMEDIATELY);
	if((lFlags | lAllowedFlags) != lAllowedFlags)
			return WBEM_E_INVALID_PARAMETER;

	HRESULT hr = S_OK;
	// If this is a Semi-sync call, we need to set up a package for passing
	// to the thread that is created
	//================================================================
	if(lFlags & WBEM_FLAG_RETURN_IMMEDIATELY) 
	{
		hr = SpawnSemiSyncThreadWithNormalPackage(Thread_SemiSync_OpenNamespace,
								strNamespace, lFlags, pCtx, ppResult, NULL, NULL);
	}
	else
	//synchronous call
	{
		hr = Actual_OpenNamespace( strNamespace, lFlags, pCtx, ppWorkingNamespace);
	}
		
	return hr;
}

HRESULT  CXMLWbemServices::PutClass(IWbemClassObject *pObject, LONG lFlags, IWbemContext *pCtx, 
									IWbemCallResult **ppCallResult)
{
	// Check for the validity of the arguments
	//========================================
	if(NULL == pObject)
		return WBEM_E_INVALID_PARAMETER;

	// These are the only valid flags for this operation..
	LONG lAllowedFlags = (	WBEM_FLAG_USE_AMENDED_QUALIFIERS|WBEM_FLAG_CREATE_OR_UPDATE|
							WBEM_FLAG_UPDATE_ONLY|WBEM_FLAG_CREATE_ONLY|
							WBEM_FLAG_RETURN_IMMEDIATELY|WBEM_FLAG_OWNER_UPDATE|
							WBEM_FLAG_UPDATE_COMPATIBLE|WBEM_FLAG_UPDATE_SAFE_MODE|
							WBEM_FLAG_UPDATE_FORCE_MODE );

	if((lFlags | lAllowedFlags) != lAllowedFlags)
			return WBEM_E_INVALID_PARAMETER;
	
	HRESULT hr = S_OK;

	// If this is a Semi-sync call, we need to set up a package for passing
	// to the thread that is created
	//================================================================
	if(lFlags & WBEM_FLAG_RETURN_IMMEDIATELY) 
	{
		// Remove the return immediately flag
		lFlags = lFlags & ~WBEM_FLAG_RETURN_IMMEDIATELY;
		hr = SpawnSemiSyncThreadWithNormalPackage(Thread_SemiSync_PutClass,
								NULL, lFlags, pCtx, ppCallResult, pObject, NULL);
	}
	else
	//synchronous call
	{
		hr = Actual_PutClass(pObject, lFlags, pCtx);
	}
		
	return hr;
}


HRESULT  CXMLWbemServices::DeleteClass( const BSTR strClass, LONG lFlags, 
										IWbemContext *pCtx, IWbemCallResult **ppCallResult)
{
	HRESULT hr = S_OK;

	if(SysStringLen(strClass) == 0)
			return WBEM_E_INVALID_PARAMETER;

	// Check for validity of the flags
	//=================================
	LONG lAllowedFlags = (WBEM_FLAG_OWNER_UPDATE|WBEM_FLAG_RETURN_IMMEDIATELY);
	if((lFlags | lAllowedFlags) != lAllowedFlags)
			return WBEM_E_INVALID_PARAMETER;

	if(lFlags & WBEM_FLAG_RETURN_IMMEDIATELY) //semisynchronous call
	{
		hr = SpawnSemiSyncThreadWithNormalPackage(Thread_SemiSync_DeleteClass,
								strClass, lFlags, pCtx, ppCallResult, NULL, NULL);
	}
	else
	//synchronous call
	{
		return Actual_DeleteClass(strClass,lFlags,pCtx);
	}
		
	return hr;
}


HRESULT  CXMLWbemServices::CreateClassEnum(const BSTR strSuperclass, LONG lFlags,  IWbemContext *pCtx,
											IEnumWbemClassObject **ppEnum)
{
	// Do Input Parameter Verification
	//=======================================
	//these are the only valid flags for this operation..
	LONG lAllowedFlags = (	WBEM_FLAG_USE_AMENDED_QUALIFIERS|WBEM_FLAG_DEEP |
							WBEM_FLAG_SHALLOW |WBEM_FLAG_RETURN_IMMEDIATELY |
							WBEM_FLAG_FORWARD_ONLY|WBEM_FLAG_BIDIRECTIONAL);

	if((lFlags | lAllowedFlags) != lAllowedFlags)
		return WBEM_E_INVALID_PARAMETER;

	if(ppEnum == NULL)
		return WBEM_E_INVALID_PARAMETER;
	*ppEnum = NULL;


	bool bSemisync = ((lFlags & WBEM_FLAG_RETURN_IMMEDIATELY) != 0);

	// See if we need to do it on a dedicated HTTP connection
	// Create the correct enumerator based on that
	bool bEnumTypeDedicated = false;
	bEnumTypeDedicated = IsEnumtypeDedicated(pCtx);
	IEnumWbemClassObject *pActualEnum = NULL;
	HRESULT hr = WBEM_NO_ERROR;
	if(bEnumTypeDedicated)
	{
		// If we're using a dedicated connection, then we do not allow bi-directional enumerators
		if(lFlags & WBEM_FLAG_BIDIRECTIONAL)
			hr = WBEM_E_INVALID_PARAMETER;
		else
		{
			if(pActualEnum = new CXMLEnumWbemClassObject2())
				hr = ((CXMLEnumWbemClassObject2 *)pActualEnum)->Initialize(bSemisync, L"CLASS", m_pwszBracketedServername, m_pwszNamespace);
			else
				hr = WBEM_E_OUT_OF_MEMORY;
		}
	}
	else
	{
		//the last parameter specifies that this is part of a semi-synchronous operation
		if(pActualEnum = new CXMLEnumWbemClassObject())
			hr = ((CXMLEnumWbemClassObject *)pActualEnum)->Initialize(bSemisync, m_pwszBracketedServername, m_pwszNamespace);
		else
			hr = WBEM_E_OUT_OF_MEMORY;
	}

	if(SUCCEEDED(hr))
	{
		if(bSemisync) //semisynchronous call
			hr = SpawnSemiSyncThreadWithNormalPackage(Thread_SemiSync_CreateClassEnum,
									strSuperclass, lFlags, pCtx, NULL, NULL, pActualEnum, true, bEnumTypeDedicated);
		else
		//synchronous call
			hr = Actual_CreateClassEnum(strSuperclass, lFlags, pCtx, pActualEnum, bEnumTypeDedicated);
	}

	if(FAILED(hr))
	{
		RELEASEINTERFACE(pActualEnum); // This may actually be NULL if hr = WBEM_E_OUT_OF_MEMORY
	}
	else
		*ppEnum = pActualEnum; // No need to addref it since it has been created with a refcount of 1

	return hr;
}


HRESULT  CXMLWbemServices::PutInstance(IWbemClassObject *pInst, LONG lFlags, 
										IWbemContext *pCtx, IWbemCallResult **ppCallResult)
{
	// Do Input Parameter Verification
	//=======================================

	if(NULL == pInst)
		return WBEM_E_INVALID_PARAMETER;

	//these are the only valid flags for this operation..
	LONG lAllowedFlags = (	WBEM_FLAG_CREATE_OR_UPDATE|WBEM_FLAG_UPDATE_ONLY|
							WBEM_FLAG_CREATE_ONLY|WBEM_FLAG_RETURN_IMMEDIATELY);

	if((lFlags | lAllowedFlags) != lAllowedFlags)
			return WBEM_E_INVALID_PARAMETER;

	HRESULT hr = S_OK;

	if(lFlags & WBEM_FLAG_RETURN_IMMEDIATELY) //semisynchronous call
	{
		// Remove the return immediately flag
		lFlags = lFlags & ~WBEM_FLAG_RETURN_IMMEDIATELY;
		hr = SpawnSemiSyncThreadWithNormalPackage(Thread_SemiSync_PutInstance,
								NULL, lFlags, pCtx, ppCallResult, pInst, NULL);
	}
	else
	//synchronous call
	{
		hr = Actual_PutInstance(pInst, lFlags, pCtx);
	}
	
	return hr;
}

HRESULT  CXMLWbemServices::DeleteInstance(const BSTR strObjectPath, LONG lFlags, 
											IWbemContext *pCtx, IWbemCallResult **ppCallResult)
{
	if(SysStringLen(strObjectPath) == 0)
			return WBEM_E_INVALID_PARAMETER;

	// Do Input Parameter Verification
	//=======================================

	//these are the only valid flags for this operation..
	LONG lAllowedFlags = (WBEM_FLAG_RETURN_IMMEDIATELY);
	if((lFlags | lAllowedFlags) != lAllowedFlags)
			return WBEM_E_INVALID_PARAMETER;
	
	HRESULT hr = S_OK;

	if(lFlags & WBEM_FLAG_RETURN_IMMEDIATELY) //semisynchronous call
		hr = SpawnSemiSyncThreadWithNormalPackage(Thread_SemiSync_DeleteInstance,
								strObjectPath, lFlags, pCtx, ppCallResult, NULL, NULL);
	else
	//synchronous call
		hr = Actual_DeleteInstance(strObjectPath,lFlags,pCtx);
	return hr;
}


HRESULT  CXMLWbemServices::CreateInstanceEnum(const BSTR strClass, LONG lFlags, 
												IWbemContext *pCtx, IEnumWbemClassObject **ppEnum)
{
	// Do Input Parameter Verification
	//=======================================
	if(!ppEnum || SysStringLen(strClass) == 0)
		return WBEM_E_INVALID_PARAMETER;

	//these are the only valid flags for this operation..
	LONG lAllowedFlags = (	WBEM_FLAG_USE_AMENDED_QUALIFIERS|WBEM_FLAG_DEEP |
							WBEM_FLAG_SHALLOW |WBEM_FLAG_RETURN_IMMEDIATELY |
							WBEM_FLAG_FORWARD_ONLY|WBEM_FLAG_BIDIRECTIONAL|
							WBEM_FLAG_DIRECT_READ);

	if((lFlags | lAllowedFlags) != lAllowedFlags)
		return WBEM_E_INVALID_PARAMETER;

	bool bSemisync = ((lFlags & WBEM_FLAG_RETURN_IMMEDIATELY) != 0);
	*ppEnum = NULL;

	// See if we need to do it on a dedicated HTTP connection
	// Create the correct enumerator based on that
	bool bEnumTypeDedicated = false;
	bEnumTypeDedicated = IsEnumtypeDedicated(pCtx);
	HRESULT hr = WBEM_NO_ERROR;
	IEnumWbemClassObject *pActualEnum = NULL;
	if(bEnumTypeDedicated)
	{
		// If we're using a dedicated connection, then we do not allow bi-directional enumerators
		if(lFlags & WBEM_FLAG_BIDIRECTIONAL)
			hr = WBEM_E_INVALID_PARAMETER;
		else
		{
			if(pActualEnum = new CXMLEnumWbemClassObject2())
				hr = ((CXMLEnumWbemClassObject2 *)pActualEnum)->Initialize(bSemisync, L"VALUE.NAMEDINSTANCE", m_pwszBracketedServername, m_pwszNamespace);
			else
				hr = WBEM_E_OUT_OF_MEMORY;
		}
	}
	else
	{
		//the last parameter specifies that this is part of a semi-synchronous operation
		if(pActualEnum = new CXMLEnumWbemClassObject())
			hr = ((CXMLEnumWbemClassObject *)pActualEnum)->Initialize(bSemisync, m_pwszBracketedServername, m_pwszNamespace);
		else
			hr = WBEM_E_OUT_OF_MEMORY;
	}

	if(SUCCEEDED(hr))
	{
		if(bSemisync) //semisynchronous call
			hr = SpawnSemiSyncThreadWithNormalPackage(Thread_SemiSync_CreateInstanceEnum,
									strClass, lFlags, pCtx, NULL, NULL, pActualEnum, true, bEnumTypeDedicated);
		else
			//synchronous call
			hr = Actual_CreateInstanceEnum(strClass, lFlags, pCtx, pActualEnum, bEnumTypeDedicated);
	}
	
	if(FAILED(hr))
	{
		RELEASEINTERFACE(pActualEnum); // This may actually be NULL if hr = WBEM_E_OUT_OF_MEMORY
	}
	else
		*ppEnum = pActualEnum; // No need to addref it since it has been created with a refcount of 1

	return hr;
}


HRESULT  CXMLWbemServices::ExecQuery(const BSTR strQueryLanguage, const BSTR strQuery, LONG lFlags, 
										IWbemContext *pCtx,  IEnumWbemClassObject **ppEnum)
{
	// Do Input Parameter Verification
	//=======================================
	if((SysStringLen(strQuery) == 0) || (NULL == ppEnum))
		return WBEM_E_INVALID_PARAMETER;

	//these are the only valid flags for this operation..
	LONG lAllowedFlags = (	WBEM_FLAG_USE_AMENDED_QUALIFIERS|WBEM_FLAG_FORWARD_ONLY|
							WBEM_FLAG_BIDIRECTIONAL|WBEM_FLAG_RETURN_IMMEDIATELY |
							WBEM_FLAG_ENSURE_LOCATABLE|WBEM_FLAG_PROTOTYPE|
							WBEM_FLAG_DIRECT_READ);
	if((lFlags | lAllowedFlags) != lAllowedFlags)
			return WBEM_E_INVALID_PARAMETER;


	*ppEnum = NULL;

	CXMLEnumWbemClassObject *pActualEnum = NULL;
	bool bSemisync = ((lFlags & WBEM_FLAG_RETURN_IMMEDIATELY) != 0);

	pActualEnum = new CXMLEnumWbemClassObject();
	if(NULL == pActualEnum)
		return WBEM_E_OUT_OF_MEMORY;

	HRESULT hr = WBEM_NO_ERROR;
	if(SUCCEEDED(hr = pActualEnum->Initialize(bSemisync, m_pwszBracketedServername, m_pwszNamespace)))
	{
		if(bSemisync) //semisynchronous call
		{
			// Create a package for passing to the thread that executes this call
			ASYNC_QUERY_PACKAGE *pPackage = NULL;
			if(pPackage = new ASYNC_QUERY_PACKAGE())
			{
				if(SUCCEEDED(hr = pPackage->Initialize(strQueryLanguage, strQuery, lFlags, this, pCtx, pActualEnum)))
				{
					// Kick off the request on the other thread
					HANDLE hChild = NULL;
					if(hChild = CreateThread(NULL, 0, Thread_SemiSync_ExecQuery, (void*)pPackage, 0, NULL))
					{
						CloseHandle(hChild);
					}
					else 
						hr = WBEM_E_FAILED;
				}

				if(FAILED(hr)) // This means the other thread (that would have deleted this package) wasnt created
					delete pPackage;

			}
			else 
				hr = WBEM_E_OUT_OF_MEMORY;
		}
		else
		//synchronous call
		{
			hr = Actual_ExecQuery(strQueryLanguage, strQuery, lFlags, pCtx, pActualEnum);
		}
	}

	if(FAILED(hr))
		pActualEnum->Release();
	else
		*ppEnum = pActualEnum; // No need to addref it since it has been created with a refcount of 1

	return hr;
}

HRESULT  CXMLWbemServices::ExecMethod(const BSTR strObjectPath, const BSTR strMethodName, long lFlags, 
										IWbemContext *pCtx, IWbemClassObject *pInParams, 
										IWbemClassObject **ppOutParams, IWbemCallResult **ppCallResult)
{
	// Do Input Parameter Verification
	//=======================================
	if((SysStringLen(strObjectPath) == 0)||(SysStringLen(strMethodName) == 0))
		return WBEM_E_INVALID_PARAMETER;


	// These are the only valid flags for this operation..
	LONG lAllowedFlags = WBEM_FLAG_RETURN_IMMEDIATELY;
	if((lFlags | lAllowedFlags) != lAllowedFlags)
			return WBEM_E_INVALID_PARAMETER;
	
	HRESULT hr = WBEM_NO_ERROR;

	if(lFlags & WBEM_FLAG_RETURN_IMMEDIATELY) //semisynchronous call
	{
		// Create a CallResult object for the client
		CXMLWbemCallResult *pCallResult = NULL;
		if(ppCallResult)
		{
			// Create a Call Result object for the client
			*ppCallResult = NULL;
			if(pCallResult = new CXMLWbemCallResult())
			{
			}
			else 
				hr = WBEM_E_OUT_OF_MEMORY;
		}
		else
			hr = WBEM_E_INVALID_PARAMETER;

		if(SUCCEEDED(hr))
		{
			// Create a package for passing to the thread that executes this call
			ASYNC_METHOD_PACKAGE *pPackage = NULL;
			if(pPackage = new ASYNC_METHOD_PACKAGE())
			{
				if(SUCCEEDED(hr = pPackage->Initialize(strObjectPath, strMethodName, lFlags, this, pCtx, pCallResult, pInParams)))
				{
					// Kick off the request on the other thread
					HANDLE hChild = NULL;
					if(hChild = CreateThread(NULL, 0, Thread_SemiSync_ExecMethod, (void*)pPackage, 0, NULL))
					{
						// Set the out parameter for non-Enumeration operations
						*ppCallResult = (IWbemCallResult*)pCallResult;
						pCallResult->AddRef();
						CloseHandle(hChild);
					}
					else 
						hr = WBEM_E_FAILED;
				}

				// Thread wasnt created - hence our responsibility to delete the package
				if(FAILED(hr))
					delete pPackage;
			}
			else 
				hr = WBEM_E_OUT_OF_MEMORY;

			// We dont need this any more since the out parameter will have it
			pCallResult->Release();
		}
	}
	else
	//synchronous call
	{
		hr = Actual_ExecMethod(strObjectPath, strMethodName, lFlags, pCtx, pInParams, ppOutParams);
	}

	return hr;
}


/****************************************************************************************************
			End of member functions ......
****************************************************************************************************/

/****************************************************************************************************
			IClientSecurity functions...
****************************************************************************************************/


HRESULT CXMLWbemServices::CopyProxy(IUnknown *  pProxy,IUnknown **  ppCopy)
{
	return E_NOTIMPL;
}

HRESULT CXMLWbemServices::QueryBlanket(IUnknown*  pProxy,DWORD*  pAuthnSvc,DWORD*  pAuthzSvc,
							OLECHAR**  pServerPrincName,DWORD* pAuthnLevel,
							DWORD* pImpLevel,RPC_AUTH_IDENTITY_HANDLE*  pAuthInfo, 
							DWORD*  pCapabilities)
{
	return E_NOTIMPL;
}


HRESULT CXMLWbemServices::SetBlanket(IUnknown * pProxy,DWORD  dwAuthnSvc,DWORD  dwAuthzSvc,
						OLECHAR * pServerPrincName,DWORD  dwAuthnLevel,
						DWORD  dwImpLevel,RPC_AUTH_IDENTITY_HANDLE  pAuthInfo,
						DWORD  dwCapabilities)
{
	return S_OK;
}


/****************************************************************************************************
			End of IClientSecurity functions...
****************************************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\xmltransport\client\mainsources\xmlenumwbemclassobject2.cpp ===
// XMLWbemClassObject.cpp: implementation of the CXMLEnumWbemClassObject2 class.
//
//////////////////////////////////////////////////////////////////////

#include "XMLProx.h"

#include <xmlparser.h>


#include "Utils.h"
#include "SinkMap.h"
#include "XMLClientpacket.h"
#include "XMLClientpacketFactory.h"
#include "XMLWbemServices.h"


#include "MyPendingStream.h"
#include "nodefact.h"
#include "XMLEnumWbemClassObject2.h"

extern long g_lComponents; //Declared in the XMLProx.dll


//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////


CXMLEnumWbemClassObject2::CXMLEnumWbemClassObject2():	m_cRef(1),
														m_pStream(NULL),
														m_pwszTagname(NULL),
														m_hEventBlockNext(NULL),
														m_bSemiSync(false),
														m_pFactory(NULL),
														m_pParser(NULL),
														m_pszNamespace(NULL),
														m_pszServer(NULL),
														m_hrSemiSyncFailure(S_OK)
{
	InterlockedIncrement(&g_lComponents);
	InitializeCriticalSection(&m_CriticalSection);
}

CXMLEnumWbemClassObject2::~CXMLEnumWbemClassObject2()
{
	InterlockedDecrement(&g_lComponents);

	delete [] m_pszNamespace;
	delete [] m_pszServer;


	if(m_pStream)
		m_pStream->Release();
	if(m_pParser)
		m_pParser->Release();

	delete m_pFactory;
	DeleteCriticalSection(&m_CriticalSection);
	
	delete [] m_pwszTagname;

	if(m_bSemiSync && m_hEventBlockNext)
		CloseHandle(m_hEventBlockNext);
}


HRESULT CXMLEnumWbemClassObject2::QueryInterface(REFIID riid,void ** ppvObject)
{
	if (riid == IID_IUnknown || riid == IID_IEnumWbemClassObject)
    {
        *ppvObject = (IEnumWbemClassObject*) this;
        AddRef();
        return WBEM_S_NO_ERROR;
    }
    else return E_NOINTERFACE;
}

ULONG CXMLEnumWbemClassObject2::AddRef()
{
	return InterlockedIncrement(&m_cRef);
}

ULONG CXMLEnumWbemClassObject2::Release()
{
	if(InterlockedDecrement(&m_cRef)==0)
		delete this;

	return m_cRef;
}

// It is assumed that this is called only once for this object
// Calling multiple times results in a memory leak
HRESULT CXMLEnumWbemClassObject2::Initialize(bool bSemisync, const WCHAR *pwszTagname, LPCWSTR pszServer, LPCWSTR pszNamespace)
{
	HRESULT hr = S_OK;

	// Create a mutex for semi-sync enumerations
	if(m_bSemiSync = bSemisync)
	{
		// Create it in an un-signalled state
		if(!(m_hEventBlockNext = CreateEvent(NULL, TRUE, FALSE, NULL)))
			hr = E_FAIL;
	}

	// Copy over the tag name that we're interested in
	if(SUCCEEDED(hr = AssignString(&m_pwszTagname,pwszTagname)))
	{
		// COpy the namespace and server strings
		if(SUCCEEDED(hr = AssignString(&m_pszServer, pszServer)))
			hr = AssignString(&m_pszNamespace, pszNamespace);
	}

	return hr;
}


HRESULT CXMLEnumWbemClassObject2::Clone(IEnumWbemClassObject **ppEnum)
{
	// Cant clone in this case since we read directly from the WinInet handle
	// Same reason as to why we dont support bidirectional enumerators here
	return E_NOTIMPL;
}


HRESULT CXMLEnumWbemClassObject2::Next(LONG lTimeOut, ULONG uCount, IWbemClassObject **pArrayOfObjects, ULONG *puReturned)
{
	if(NULL == pArrayOfObjects)
		return WBEM_E_INVALID_PARAMETER;

	// This is as per the documentation
	if(0 == uCount)
		return WBEM_S_FALSE;

	// For Semi-sync operations, the response might not be ready yet
	// Hence we need to block here until this event has been signalled by InitializeResponse()
	// For Semi-sync operations, the response might not be ready yet
	// Hence we need to block here until this event has been signalled by InitializeResponse()
	if(m_bSemiSync)
	{
		WaitForSingleObject(m_hEventBlockNext,INFINITE);
		if(FAILED(m_hrSemiSyncFailure))
			return m_hrSemiSyncFailure;
	}
		
	// Something went wrong 
	if((NULL == m_pStream)) 
		return WBEM_E_FAILED;
	
	HRESULT hr = S_OK, hParser=S_OK;
		
	UINT uReturned = 0;

	EnterCriticalSection(&m_CriticalSection);
	while(SUCCEEDED(hr) &&
		(SUCCEEDED(hParser = m_pParser->Run(-1)) || hParser == E_PENDING) && 
		(uReturned<uCount) )
	{
		// Fetch the next object from the factory
		IXMLDOMDocument *pNextObject = NULL;
		if(SUCCEEDED(hr = m_pFactory->GetDocument(&pNextObject)))
		{
			IXMLDOMElement *pDocElement = NULL;
			if(SUCCEEDED(hr = pNextObject->get_documentElement(&pDocElement)))
			{
				IXMLDOMNode *pObjectNode = NULL;
				if(SUCCEEDED(hr = Parse_IRETURNVALUE_Node(pDocElement, &pObjectNode)))
				{
					IWbemClassObject *pObject = NULL;
					if(SUCCEEDED(hr = m_MapXMLtoWMI.MapDOMtoWMI(m_pszServer, m_pszNamespace, pObjectNode, NULL, &pObject)))
					{
						pArrayOfObjects[uReturned] = pObject;
						// Save an Addref/Release here
						uReturned++;
					}
					pObjectNode->Release();
				}
				pDocElement->Release();
			}
			pNextObject->Release();
		}
	}
	
	if(NULL != puReturned)
		*puReturned = uReturned;

	LeaveCriticalSection(&m_CriticalSection);

	return (uReturned < uCount) ? WBEM_S_FALSE : WBEM_S_NO_ERROR;
}

HRESULT CXMLEnumWbemClassObject2::NextAsync(ULONG uCount,IWbemObjectSink *pSink)
{
	HRESULT hr=S_OK;
	
	ASYNC_ENUM_PACKAGE *pPackage = NULL;

	DWORD dwWait=0;
	pPackage = new ASYNC_ENUM_PACKAGE();
	if(NULL == pPackage)
		return E_OUTOFMEMORY;

	hr = pPackage->Initialize(pSink, this, uCount); //using flags for sending uCount - flags not used by Next anyway.
	if(SUCCEEDED(hr))
	{
		EnterCriticalSection(&m_CriticalSection);
		if(NULL == CreateThread(NULL,0,Thread_Async_Next2,(void*)pPackage,0,NULL))
		{
			delete pPackage;
			hr =  E_FAIL;
		}
		LeaveCriticalSection(&m_CriticalSection);
	}
		
	return ((!SUCCEEDED(hr))||(dwWait==WAIT_OBJECT_0)) ? WBEM_S_FALSE : WBEM_S_NO_ERROR;
}

HRESULT CXMLEnumWbemClassObject2::Reset( )
{
	//CURRENTLY, WE CANT SUPPORT RESETS IN THE DEDICATED MODE..
	return E_NOTIMPL;
}	

HRESULT CXMLEnumWbemClassObject2::Skip(LONG lTimeOut,ULONG UCount)
{
	HRESULT hr = S_OK;

	ULONG i = 0;

	while((SUCCEEDED(hr = m_pParser->Run(-1)) || hr == E_PENDING) && i<UCount)
	{
		IXMLDOMDocument *pNextObject = NULL;
			
		if(SUCCEEDED(hr = m_pFactory->GetDocument(&pNextObject)))
		{
			i++;
		}
	}
	
	return hr;
}


HRESULT CXMLEnumWbemClassObject2::SetResponse(IStream *pStream)
{
	// Keep a pointer to the stream
	m_pStream = pStream;
	m_pStream->AddRef();

	HRESULT hr = S_OK;
	const WCHAR *pszElementNames = m_pwszTagname;
	CMyPendingStream *pMyStream = NULL;
	if(pMyStream = new CMyPendingStream(pStream))
	{
		if(SUCCEEDED(hr = CoCreateInstance(CLSID_XMLParser, NULL, CLSCTX_INPROC_SERVER,
			IID_IXMLParser,  (LPVOID *)&m_pParser)))
		{
			if(SUCCEEDED(hr = m_pParser->SetInput(pMyStream)))
			{
				if(m_pFactory = new MyFactory(pMyStream))
				{
					if(SUCCEEDED(hr = m_pFactory->SetElementNames(&pszElementNames,1)))
					{

						if(SUCCEEDED(hr = m_pParser->SetFactory(m_pFactory)))
						{
						}
					}
				}
				else
					hr = E_OUTOFMEMORY;
			}
		}
		pMyStream->Release();

	}

	// Set the event only for semi-sync operation
	if(SUCCEEDED(hr))
	{
		if(m_bSemiSync)
			SetEvent(m_hEventBlockNext); // Next() blocks on this
	}
	return hr;
}

/***********************************************************************************************************

	Thread for the NextAsync... 
************************************************************************************************************/

DWORD WINAPI Thread_Async_Next2(LPVOID pPackage)
{
	ASYNC_ENUM_PACKAGE *pThisPackage = (ASYNC_ENUM_PACKAGE *) pPackage;
	IWbemObjectSink  *pSink = pThisPackage->m_pResponseHandler;

	HRESULT hr = WBEM_NO_ERROR;
	if(SUCCEEDED(hr = CoInitialize(NULL)))
	{
		if(pThisPackage->m_uCount >0)
		{
			IWbemClassObject **ppArrayOfObjects = NULL;
			if(ppArrayOfObjects = new IWbemClassObject*[pThisPackage->m_uCount])
			{
				ULONG uReturned = 0;
				if(SUCCEEDED(hr = (pThisPackage->m_pEnum)->Next(WBEM_INFINITE, pThisPackage->m_uCount, ppArrayOfObjects, &uReturned)))
				{
					pSink->Indicate(uReturned, ppArrayOfObjects);
					for(ULONG i=0; i<uReturned; i++)
						ppArrayOfObjects[i]->Release();
				}
				delete [] ppArrayOfObjects;
			}
			else
				hr = E_OUTOFMEMORY;
		}
		CoUninitialize();
	}
	pSink->SetStatus(WBEM_STATUS_COMPLETE, hr, NULL, NULL);

	delete pThisPackage;
	return 0;
}

HRESULT CXMLEnumWbemClassObject2::AcceptFailure(HRESULT hr)
{
	RELEASEINTERFACE(m_pStream);
	m_pStream = NULL;

	if(m_bSemiSync)
	{
		m_hrSemiSyncFailure = hr;
		SetEvent(m_hEventBlockNext);
	}

	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\xmltransport\client\mainsources\xmlenumwbemclassobject2.h ===
//////////////////////////////////////////////////////////////////////////
// XMLWbemClassObject2.h: interface for the CXMLEnumWbemClassObject2 class.
// this class would be used when the DEDICATED enumerations are requested
// by specifying the "EnumerationtypeDedicated" flag in the PCtx parameter
//////////////////////////////////////////////////////////////////////////

#ifndef WMI_XML_ENUM_2_H
#define WMI_XML_ENUM_2_H

class CXMLEnumWbemClassObject2 : public IEnumWbemClassObject  
{
private:
	LONG				m_cRef; //reference count

	// The Namespace on which this enumeration was done
	LPWSTR	m_pszNamespace;

	// The Server on which this enumeration was done
	LPWSTR	m_pszServer;

	// Our IWbemServices implementation would pass this IStream to us.
	// This stream will wrap a WinInet handle and read from it when
	// data is pulled from it by the m_pParser
	IStream				*m_pStream;

	// The factory used to construct objects
	MyFactory *m_pFactory; 

	// The parser used by the factory
	IXMLParser *m_pParser; 

	// Name of the key - CLASS,VALUE.NAMEDINSTANCE,VALUE.OBJECTWITHPATH
	WCHAR				*m_pwszTagname; 
	
	//This Event is used only in semi-sync operations.
	// Note that in Async WMI API, there is no enumerator, but only an Object sink. And hence
	// the thread spawned by us is free to write into the object sink whenever it gets the results
	// In case of Sync WMI API, there is no Call Result. The call returns only after the enumerator
	// has been dully initialized with the response to the XML request
	// In case Semi-sync WMI API, though, the call returns immediately, but the call to Next() on the
	// enumerator will block if the response is not available yet. Hence we need a Mutex since there will 
	// actually be a thread (spawned by us) that will be sending the request and initializing the enumerator
	// with the response. Hence if the client calls Next() before the initialization has been successful,
	// then the Next() needs to block. Hence we use this mutex and only in the semi-sync case.
	// This mutex is signalled in InitializeWithResponse() and waited upon in Next()
	// It is created in an un-signalled state
	HANDLE			m_hEventBlockNext;
	bool			m_bSemiSync; //is this a semi-synchronous operation? If so, we've to wait on the mutexs in Next()
	// This is used to store any failures that occur during a semi sync request
	HRESULT				m_hrSemiSyncFailure;

	// As opposed to the event which is to block a call to Next() if data is not ready,
	// the following critical section is used to make the enumerator thread-safe
	CRITICAL_SECTION	m_CriticalSection;

	// Helper class to do the mapping from XML toWMI 
	CMapXMLtoWMI	m_MapXMLtoWMI; 

public:
	//our class MUST be ctor must be passed a valid xml packet as argument.
	//lFlags and pCtx are what were passed to the original CreateClass(Instance)Enum call.
	//pwszCimOperation MUST be "EnumerateInstances","EnumerateClasses" or "ExecQuery"
	//pServices is the services pointer that we will use in case user wants to Reset the enumeration.

	CXMLEnumWbemClassObject2(); 
	virtual ~CXMLEnumWbemClassObject2();

	// Initialized with the element name that will be used to seed the XML Node factory
	// that manufactures this kind of elements
	HRESULT Initialize(bool bSemisync, const WCHAR *pwszTagname, LPCWSTR pszServer, LPCWSTR pszNamespace);

	// This is where we take the WinInet handle that contains the response to an enumeration
	HRESULT SetResponse(IStream *pStream);

	// CXMLWbemServices will call this function in case it failed to transport the packet
	// prevents Next from blocking forever
	HRESULT AcceptFailure(HRESULT hr);

	// IUnknown fns
	//======================
	STDMETHODIMP QueryInterface(REFIID iid,void ** ppvObject);
	STDMETHODIMP_(ULONG) AddRef();
	STDMETHODIMP_(ULONG) Release();

	// IEnumWbemClassObject functions
	//===================================
	STDMETHODIMP Clone(IEnumWbemClassObject **ppEnum);
	STDMETHODIMP Next(LONG lTimeOut,ULONG uCount,IWbemClassObject **ppObjects,ULONG *puReturned);
	STDMETHODIMP NextAsync(ULONG uCount,IWbemObjectSink *pSink);
	STDMETHODIMP Reset( );
	STDMETHODIMP Skip(LONG lTimeOut,ULONG UCount);

protected:
	// The thread function used to implement NextAsync()
	friend DWORD WINAPI Thread_Async_Next2(LPVOID pPackage);

};

#endif // WMI_XML_ENUM_2_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\xmltransport\client\mainsources\xmlenumwbemclassobject.h ===
// XMLEnumWbemClassObject.h: interface for the CXMLEnumWbemClassObject class.
//
//////////////////////////////////////////////////////////////////////

#ifndef WMI_XML_ENUM_H
#define WMI_XML_ENUM_H


class CXMLEnumWbemClassObject : public IEnumWbemClassObject  
{
private:
	LONG				m_cRef; //reference count

	// The Namespace on which this enumeration was done
	LPWSTR	m_pszNamespace;

	// The Server on which this enumeration was done
	LPWSTR	m_pszServer;

	//Our IWbemServices implementation would pass this packet
	//to us while creating our implementation of the IEnumWbemClassobject (this class)
	//this packet contains the class information in XML format sent by the 
	//XMLHTTP server.
	// The entire response
	IXMLDOMDocument	*m_pXMLDomDocument;
	// The node in the response that contains the CLASS or INSTANCE below it
	IXMLDOMNodeList *m_pXMLDomNodeList;


	//This Event is used only in semi-sync operations.
	// Note that in Async WMI API, there is no enumerator, but only an Object sink. And hence
	// the thread spawned by us is free to write into the object sink whenever it gets the results
	// In case of Sync WMI API, there is no Call Result. The call returns only after the enumerator
	// has been dully initialized with the response to the XML request
	// In case Semi-sync WMI API, though, the call returns immediately, but the call to Next() on the
	// enumerator will block if the response is not available yet. Hence we need a Mutex since there will 
	// actually be a thread (spawned by us) that will be sending the request and initializing the enumerator
	// with the response. Hence if the client calls Next() before the initialization has been successful,
	// then the Next() needs to block. Hence we use this mutex and only in the semi-sync case.
	// This mutex is signalled in InitializeWithResponse() and waited upon in Next()
	// It is created in an un-signalled state
	HANDLE			m_hEventBlockNext;
	bool			m_bSemiSync; //is this a semi-synchronous operation? If so, we've to wait on the mutexs in Next()
	// This is used to store any failures that occur during a semi sync request
	HRESULT				m_hrSemiSyncFailure;

	// As opposed to the event which is to block a call to Next() if data is not ready,
	// the following critical section is used to make the enumerator thread-safe
	CRITICAL_SECTION	m_CriticalSection;

	// Used to find out if the enumeration is completed
	bool			m_bEndofDocuments;

	// Helper class to do the mapping from XML toWMI 
	CMapXMLtoWMI	m_MapXMLtoWMI; 

public:
	// Our class MUST be passed a valid xml packet as argument.
	// lFlags and pCtx are what were passed to the original CreateClass(Instance)Enum call.
	// pwszCimOperation MUST be "EnumerateInstances","EnumerateClasses" or "ExecQuery"
	// pServices is the services pointer that we will use in case user wants to Reset the enumeration.

	CXMLEnumWbemClassObject(); 
	virtual ~CXMLEnumWbemClassObject();

	HRESULT Initialize(bool bSemiSync, LPCWSTR pszServer, LPCWSTR pszNamespace);

	// This is where we take the xml packet and load it into the IXMLDomNode. 
	// we now dont have to make a copy of the packet, and also can return error code if needed
	HRESULT SetResponse(IXMLDOMDocument *pDocument);

	// CXMLWbemServices will call this function in case it failed to transport the packet
	// prevents Next from blocking forever
	HRESULT AcceptFailure(HRESULT hr);

	// IUnknown functions
	//===================================
	STDMETHODIMP QueryInterface(REFIID iid,void ** ppvObject);
	STDMETHODIMP_(ULONG) AddRef();
	STDMETHODIMP_(ULONG) Release();

	// IEnumWbemClassObject functions
	//===================================
	STDMETHODIMP Clone(IEnumWbemClassObject **ppEnum);
	STDMETHODIMP Next(LONG lTimeOut,ULONG uCount,IWbemClassObject **ppObjects,ULONG *puReturned);
	STDMETHODIMP NextAsync(ULONG uCount,IWbemObjectSink *pSink);
	STDMETHODIMP Reset( );
	STDMETHODIMP Skip(LONG lTimeOut,ULONG UCount);

protected:
	// The thread function used to implement NextAsync()
	friend DWORD WINAPI Thread_Async_Next(LPVOID pPackage);

};

#endif // WMI_XML_ENUM_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\xmltransport\client\mainsources\xmlwbemcallresult.h ===
//Header file XMLWbemCallResult.h for class XMLWbemCallResult - our implementation of the IWbemCallResult

#ifndef WMI_XML_CALLRESULT_H
#define WMI_XML_CALLRESULT_H

class CXMLWbemCallResult : public IWbemCallResult
{
protected: 
	LONG				m_lStatus;
	IWbemClassObject	*m_pWbemClassObject;
	IWbemServices		*m_pWbemServices;
	BSTR				m_strResultString; //sysalloc this to the passed bstr ptr in GetResultString(..);
	LONG				m_cRef;

	bool				m_bStatusSet;
	bool				m_bJobDone;

	CRITICAL_SECTION	m_CriticalSection;

public:

	CXMLWbemCallResult();
	virtual ~CXMLWbemCallResult();

	//CXMLWbemCallResult functions. - used by CXMLWbemServices. 
	//not visible to user (we give him IWbemCallResult *
	STDMETHODIMP SetCallStatus(LONG lStatus);
	STDMETHODIMP SetResultObject(IWbemClassObject *pResultObject);
	STDMETHODIMP SetResultServices(IWbemServices *pResultServices);
	STDMETHODIMP SetResultString(BSTR strResultString);
	
	//IUnknown functions
	STDMETHODIMP QueryInterface(REFIID iid,void ** ppvObject);
	STDMETHODIMP_(ULONG) AddRef();
	STDMETHODIMP_(ULONG) Release();

	//IWbemCallResult functions.
	STDMETHODIMP GetCallStatus(LONG lTimeout,LONG *plStatus);
	STDMETHODIMP GetResultObject(LONG lTimeout,IWbemClassObject **ppResultObject);
	STDMETHODIMP GetResultServices(LONG lTimeout,IWbemServices **ppServices);
	STDMETHODIMP GetResultString(LONG lTimeout,BSTR *pstrResultString);
};

#endif // WMI_XML_CALLRESULT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\xmltransport\client\mainsources\xmlwbemcallresult.cpp ===
//XMLWbemCallResult.cpp - the CXMLWbemCallResult class implementation (our version of IWbemCallResult

#include "XMLProx.h"
#include "XMLClientpacket.h"
#include "XMLClientPacketFactory.h"
#include "SinkMap.h"
#include "XMLWbemServices.h"
#include "XMLWbemCallResult.h"

extern long g_lComponents; //Declared in the XMLProx.dll

// The amount of quantums, in milliseconds between which we check for results
static const LONG YIELDTIME=70; 

CXMLWbemCallResult::CXMLWbemCallResult():	m_lStatus(WBEM_S_TIMEDOUT),
											m_pWbemClassObject(NULL),
											m_pWbemServices(NULL),
											m_strResultString(NULL),
											m_cRef(1)
{
	InterlockedIncrement(&g_lComponents);
	InitializeCriticalSection(&m_CriticalSection);
	m_bStatusSet = m_bJobDone = false;
}

CXMLWbemCallResult::~CXMLWbemCallResult()
{
	InterlockedDecrement(&g_lComponents);
	SysFreeString(m_strResultString);
	RELEASEINTERFACE(m_pWbemServices);
	RELEASEINTERFACE(m_pWbemClassObject);
	DeleteCriticalSection(&m_CriticalSection);
}
	
HRESULT CXMLWbemCallResult::GetCallStatus(LONG lTimeout, LONG *plStatus)
{
	if(NULL == plStatus)
		return (E_INVALIDARG);

	LONG dwYield = YIELDTIME;
	if((lTimeout < dwYield) && (lTimeout != WBEM_INFINITE))
		dwYield = lTimeout;

	DWORD dwTickEnd = 0;
	DWORD dwTickStart = GetTickCount();
	while(!m_bStatusSet)
	{
		dwTickEnd = GetTickCount();
		
		if(((LONG)(dwTickEnd - dwTickStart) > lTimeout)&&(lTimeout != WBEM_INFINITE))
			break;

		Sleep(dwYield);
	}
	if(!m_bStatusSet)
		*plStatus = WBEM_S_TIMEDOUT; //timedout before we could set the callstatus..
	else
		*plStatus = m_lStatus;
	
	return (*plStatus);
}

HRESULT CXMLWbemCallResult::GetResultObject(LONG lTimeout,IWbemClassObject **ppResultObject)
{
	if(NULL == ppResultObject)
		return E_INVALIDARG;

	LONG dwYield = YIELDTIME;
	
	if((lTimeout < dwYield)&&(lTimeout != WBEM_INFINITE))
		dwYield = lTimeout;

	DWORD dwTickEnd = 0;

	DWORD dwTickStart = GetTickCount();

	while(!m_bJobDone)
	{
		dwTickEnd = GetTickCount();
		
		if(((LONG)(dwTickEnd - dwTickStart) > lTimeout)&&(lTimeout != WBEM_INFINITE))
			break;

		Sleep(dwYield);
	}

	if(!m_bJobDone)
	{
		//operation timed out before we could get the object..
		*ppResultObject = NULL;
		SetCallStatus(WBEM_S_TIMEDOUT);
	}
	else
	{
		*ppResultObject = m_pWbemClassObject;
		m_pWbemClassObject->AddRef();
	}
	
	return m_lStatus;
}


HRESULT CXMLWbemCallResult::GetResultServices(LONG lTimeout,IWbemServices **ppServices)
{
	if(NULL == ppServices)
		return E_INVALIDARG;

	LONG dwYield = YIELDTIME;
	
	if((lTimeout < dwYield)&&(lTimeout != WBEM_INFINITE))
		dwYield = lTimeout;

	DWORD dwTickEnd = 0;

	DWORD dwTickStart = GetTickCount();

	while(!m_bJobDone)
	{
		dwTickEnd = GetTickCount();
		
		if(((LONG)(dwTickEnd - dwTickStart) > lTimeout)&&(lTimeout != WBEM_INFINITE))
			break;

		Sleep(dwYield);
	}

	if(!m_bJobDone)
	{
		//operation timed out before we could get the object..
		*ppServices = NULL;
		SetCallStatus(WBEM_S_TIMEDOUT);
	}
	else
	{
		*ppServices = m_pWbemServices;
		m_pWbemServices->AddRef();
	}

	return m_lStatus;
}


HRESULT CXMLWbemCallResult::GetResultString(LONG lTimeout,BSTR *pstrResultString)
{
	if(NULL == pstrResultString)
		return E_INVALIDARG;

	LONG dwYield = YIELDTIME;
	
	if((lTimeout < dwYield)&&(lTimeout != WBEM_INFINITE))
		dwYield = lTimeout;

	DWORD dwTickEnd = 0;

	DWORD dwTickStart = GetTickCount();

	while(!m_bJobDone)
	{
		dwTickEnd = GetTickCount();
		
		if(((LONG)(dwTickEnd - dwTickStart) > lTimeout)&&(lTimeout != WBEM_INFINITE))
			break;

		Sleep(dwYield);
	}

	*pstrResultString  = NULL;
	if(!m_bJobDone)
	{
		//operation timed out before we could get the object..
		SetCallStatus(WBEM_S_TIMEDOUT);
	}
	else
	{
		if(!(*pstrResultString = SysAllocString(m_strResultString)))
			return E_OUTOFMEMORY;
	}
	
	return m_lStatus;
}



HRESULT CXMLWbemCallResult::SetCallStatus(LONG lStatus)
{
	EnterCriticalSection(&m_CriticalSection);

	HRESULT hr = S_OK;

	m_lStatus = lStatus;

	m_bStatusSet = true;

	LeaveCriticalSection(&m_CriticalSection);

	return hr;
}


HRESULT CXMLWbemCallResult::SetResultObject(IWbemClassObject *pResultObject)
{
	EnterCriticalSection(&m_CriticalSection);

	HRESULT hr = S_OK;

	if(m_pWbemClassObject)
	{
		m_pWbemClassObject->Release();
		m_pWbemClassObject = NULL;
	}
	
	if(m_pWbemClassObject = pResultObject)
		m_pWbemClassObject->AddRef();

	m_bJobDone = true;

	LeaveCriticalSection(&m_CriticalSection);

	return hr;
}


HRESULT CXMLWbemCallResult::SetResultServices(IWbemServices *pResultServices)
{
	EnterCriticalSection(&m_CriticalSection);

	HRESULT hr = S_OK;

	if(m_pWbemServices)
	{
		m_pWbemServices->Release();
		m_pWbemServices = NULL;
	}
	
	if(m_pWbemServices = pResultServices)
		m_pWbemServices->AddRef();

	m_bJobDone = true;

	LeaveCriticalSection(&m_CriticalSection);

	return hr;
}


// Caution - The memory in pwszResultString will belong to us once this call is invoked
HRESULT CXMLWbemCallResult::SetResultString(BSTR strResultString)
{
	EnterCriticalSection(&m_CriticalSection);
	m_strResultString = strResultString;
	m_bJobDone = true;
	LeaveCriticalSection(&m_CriticalSection);

	return S_OK;
}

HRESULT CXMLWbemCallResult::QueryInterface(REFIID riid,void ** ppv)
{
	if (riid == IID_IUnknown || riid == IID_IWbemCallResult)
    {
        *ppv = (IWbemCallResult*) this;
        AddRef();
        return WBEM_S_NO_ERROR;
    }
    else return E_NOINTERFACE;
}

ULONG CXMLWbemCallResult::AddRef()
{
	return InterlockedIncrement(&m_cRef);
}

ULONG CXMLWbemCallResult::Release()
{
	if(InterlockedDecrement(&m_cRef) == 0)
		delete this;

	return m_cRef;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\xmltransport\client\mainsources\xmlprox.h ===
#ifndef WMI_XML_PROX_H
#define WMI_XML_PROX_H

//This is the main header file that includes all necessary header files
//similar to StdAfx.h used in mfc

// Insert your headers here


#include <windows.h>
#include <objbase.h>
#include <objidl.h>
#include <initguid.h>
#include <tchar.h>
#include <stdio.h>
#include <objidl.h>
#include <olectl.h>
#include <Wbemidl.h>
#include <wininet.h>
#include <Oaidl.h>
#include <time.h>
#include <wchar.h>
#include <wbemcli.h>
#include <wmiutils.h>



#include "genlex.h"
#include "opathlex.h"
#include "objpath.h"
#include "wmiconv.h"
#include "wmi2xml.h"

#include "SinkMap.h" //Needed by services.
#include "HTTPConnectionAgent.h"
#include "Utils.h"
#include "MapXMLtoWMI.h"
#include "XMLClientPacket.h"
#include "XMLClientPacketFactory.h"
#include "XMLWbemCallResult.h"
#include "XMLWbemClientTransport.h"
#include "package.h"


//CLSID Of our component

// {CD23CCA0-7FC8-4eb1-997A-C0AFA06F3CCF}
DEFINE_GUID(CLSID_WbemClientTransport, 
0xcd23cca0, 0x7fc8, 0x4eb1, 0x99, 0x7a, 0xc0, 0xaf, 0xa0, 0x6f, 0x3c, 0xcf);


// This is a static packet factory used to create XML client packets
extern CXMLClientPacketFactory g_oXMLClientPacketFactory;
extern BSTR g_strIRETURNVALUE;

#endif // WMI_XML_PROX_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\xmltransport\client\mainsources\xmlprox.cpp ===
// XMLProx.cpp : Defines the entry point for the DLL application.
//
#include "XMLProx.h"
#include "Utils.h"
#include "WbemClientTransportFactory.h"



// HANDLE of the DLL
HINSTANCE   g_hInst = NULL;

//used to initialize/uninitialize Global DLL resources
CRITICAL_SECTION g_csGlobalsInitialized;
static bool g_bStaticLibraryInitialized = false; // The static library requires that we call Initialize() only once

// Count of locks
long g_lComponents = 0;
// Count of active locks
long g_lServerLocks = 0;

// The Globals in the DLL
//==========================

// This is a global packet factory used to create XML client packets
CXMLClientPacketFactory g_oXMLClientPacketFactory;

// 2 Functions to initialize and uninitialize the globals in the DLL
static HRESULT InitializeDLLResources();
static void UninitializeDLLResources();

//***************************************************************************
//
// DllMain
//
// Description: Entry point for DLL.  Good place for initialization.
// Parameters: The standard DllMain() parameters
// Return: TRUE if OK.
//***************************************************************************

BOOL APIENTRY DllMain (
	HINSTANCE hInstance,
	ULONG ulReason ,
	LPVOID pvReserved
)
{
	switch(ulReason)
	{
	case DLL_PROCESS_ATTACH:
		InitializeCriticalSection(&g_csGlobalsInitialized);
		break;
	case DLL_PROCESS_DETACH:
		DeleteCriticalSection(&g_csGlobalsInitialized);
		break;
	}
	
	g_hInst = hInstance;

    return TRUE;
}

//***************************************************************************
//
//  DllGetClassObject
//
//  Description: Called by COM when some client wants a a class factory.
//
//	Parameters: Ths standard DllGetClassObject() parameters
//
//	Return Value: S_OK only if it is the sort of class this DLL supports.
//
//***************************************************************************

STDAPI DllGetClassObject (
	REFCLSID rclsid ,
	REFIID riid,
	void **ppv
)
{
	HRESULT status = S_OK;

	// Initialize Global DLL Resources - The corresponsing compelementary call is in DllCanUnloadNow()
	status = InitializeDLLResources();
	if(FAILED(status))
		return status;

	IClassFactory *lpunk = NULL;
	//this is the CLSID we enter in the registry under transports.
	if ( rclsid == CLSID_WbemClientTransport ) 
	{
		if((riid == IID_IWbemClientTransport)||(riid == IID_IClassFactory))
		{	
			if(!(lpunk = new CWbemClientTransportFactory))
				return E_OUTOFMEMORY;

			status = lpunk->QueryInterface ( riid , ppv ) ;
			lpunk->Release();
		}
	}
	else
		return CLASS_E_CLASSNOTAVAILABLE;

	return status ;
}

//***************************************************************************
//
// DllCanUnloadNow
//
// Description: Called periodically by COM in order to determine if the
// DLL can be unloaded.
//
// Return Value: S_OK if there are no objects in use and the class factory
// isn't locked.
//***************************************************************************

STDAPI DllCanUnloadNow ()
{
	if(g_lServerLocks == 0 && g_lComponents == 0)
	{
		InitializeDLLResources();
		return S_OK;
	}
	else
		return S_FALSE;
}

/***************************************************************************
 *
 * SetKeyAndValue
 *
 * Description: Helper function for DllRegisterServer that creates
 * a key, sets a value, and closes that key. If pszSubkey is NULL, then
 * the value is created for the pszKey key.
 *
 * Parameters:
 *  pszKey          LPTSTR to the name of the key
 *  pszSubkey       LPTSTR to the name of a subkey
 *  pszValueName    LPTSTR to the value name to use
 *  pszValue        LPTSTR to the value to store
 *
 * Return Value:
 *  BOOL            TRUE if successful, FALSE otherwise.
 ***************************************************************************/

BOOL SetKeyAndValue(LPCTSTR pszKey, LPCTSTR pszSubkey, LPCTSTR pszValueName, LPCTSTR pszValue)
{
    HKEY        hKey;
    TCHAR       szKey[256];

    _tcscpy(szKey, pszKey);

	// If a sub key is mentioned, use it.
    if (NULL != pszSubkey)
    {
		_tcscat(szKey, __TEXT("\\"));
        _tcscat(szKey, pszSubkey);
    }

    if (ERROR_SUCCESS != RegCreateKeyEx(HKEY_LOCAL_MACHINE,
		szKey, 0, NULL, REG_OPTION_NON_VOLATILE,
		KEY_ALL_ACCESS, NULL, &hKey, NULL))
        return FALSE;

    if (NULL != pszValue)
    {
        if (ERROR_SUCCESS != RegSetValueEx(hKey, pszValueName, 0, REG_SZ, (BYTE *)pszValue,
			(_tcslen(pszValue)+1)*sizeof(TCHAR)))
			return FALSE;
    }
    RegCloseKey(hKey);
    return TRUE;
}

/***************************************************************************
 *
 * DeleteKey
 *
 * Description: Helper function for DllUnRegisterServer that deletes the subkey
 * of a key.
 *
 * Parameters:
 *  pszKey          LPTSTR to the name of the key
 *  pszSubkey       LPTSTR ro the name of a subkey
 *
 * Return Value:
 *  BOOL            TRUE if successful, FALSE otherwise.
 ***************************************************************************/

BOOL DeleteKey(LPCTSTR pszKey, LPCTSTR pszSubkey)
{
    HKEY        hKey;

    if (ERROR_SUCCESS != RegCreateKeyEx(HKEY_LOCAL_MACHINE,
		pszKey, 0, NULL, REG_OPTION_NON_VOLATILE,
		KEY_ALL_ACCESS, NULL, &hKey, NULL))
        return FALSE;

	if(ERROR_SUCCESS != RegDeleteKey(hKey, pszSubkey))
		return FALSE;

    RegCloseKey(hKey);
    return TRUE;
}


////////////////////////////////////////////////////////////////////
// Strings used during self registration
////////////////////////////////////////////////////////////////////
LPCTSTR INPROC32_STR			= __TEXT("InprocServer32");
LPCTSTR INPROC_STR				= __TEXT("InprocServer");
LPCTSTR THREADING_MODEL_STR		= __TEXT("ThreadingModel");
LPCTSTR APARTMENT_STR			= __TEXT("Both");

LPCTSTR CLSID_STR				= __TEXT("SOFTWARE\\CLASSES\\CLSID\\");

// DS Class Provider
LPCTSTR FRIENDLY_NAME_STR		= __TEXT("Microsoft XMLHTTP Transport Client");


STDAPI DllRegisterServer()
{
	TCHAR szModule[512];
	GetModuleFileName(g_hInst, szModule, sizeof(szModule)/sizeof(TCHAR));

	TCHAR szClassID[128];
	TCHAR szCLSIDClassID[128];

#ifdef UNICODE
	if(StringFromGUID2(CLSID_WbemClientTransport, szClassID, 128) == 0)
		return SELFREG_E_CLASS;
#else
	WCHAR wszClassID[128];
	if(StringFromGUID2(CLSID_WbemClientTransport, wszClassID, 128) == 0)
		return SELFREG_E_CLASS;
	WideCharToMultiByte(CP_ACP, 0, wszClassID, -1, szClassID, 128, NULL, NULL);

#endif

	wcscpy(szCLSIDClassID, CLSID_STR);
	wcscat(szCLSIDClassID, szClassID);

	//
	// Create entries under CLSID 
	//
	if (FALSE == SetKeyAndValue(szCLSIDClassID, NULL, NULL, FRIENDLY_NAME_STR))
		return SELFREG_E_CLASS;
	if (FALSE == SetKeyAndValue(szCLSIDClassID, INPROC32_STR, NULL, szModule))
		return SELFREG_E_CLASS;
	if (FALSE == SetKeyAndValue(szCLSIDClassID, INPROC32_STR, THREADING_MODEL_STR, APARTMENT_STR))
		return SELFREG_E_CLASS;
	
	return S_OK;
}


STDAPI DllUnregisterServer(void)
{
	TCHAR szModule[512];
	GetModuleFileName(g_hInst,szModule, sizeof(szModule)/sizeof(TCHAR));

	TCHAR szClassID[128];
	TCHAR szCLSIDClassID[128];

#ifdef UNICODE
	if(StringFromGUID2(CLSID_WbemClientTransport, szClassID, 128) == 0)
		return SELFREG_E_CLASS;
#else
	WCHAR wszClassID[128];
	if(StringFromGUID2(CLSID_WbemClientTransport, wszClassID, 128) == 0)
		return SELFREG_E_CLASS;
	WideCharToMultiByte(CP_ACP, 0, wszClassID, -1, szClassID, 128, NULL, NULL);

#endif

	wcscpy(szCLSIDClassID, CLSID_STR);
	wcscat(szCLSIDClassID, szClassID);

	//
	// Delete the keys for DS Class Provider in the reverse order of creation in DllRegisterServer()
	//
	if(FALSE == DeleteKey(szCLSIDClassID, INPROC32_STR))
		return SELFREG_E_CLASS;
	if(FALSE == DeleteKey(CLSID_STR, szClassID))
		return SELFREG_E_CLASS;

	return S_OK;
}


static void UninitializeDLLResources()
{
	// Unnitialize Global DLL Resources that were done in DllGetClassObject()
	EnterCriticalSection(&g_csGlobalsInitialized);

	if(g_bStaticLibraryInitialized)
	{
		UninitWMIXMLClientLibrary();
		g_bStaticLibraryInitialized = false;
	}

	LeaveCriticalSection(&g_csGlobalsInitialized);
}

static HRESULT InitializeDLLResources()
{
	HRESULT hr = S_OK;

	EnterCriticalSection(&g_csGlobalsInitialized);
	
	if(!g_bStaticLibraryInitialized)
	{
		if(SUCCEEDED(hr = InitWMIXMLClientLibrary()))
			g_bStaticLibraryInitialized = true;
	}

	if(FAILED(hr))
		UninitializeDLLResources();

	LeaveCriticalSection(&g_csGlobalsInitialized);
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\xmltransport\client\mainsources\xmlwbemclienttransport.h ===
#ifndef WMI_XML_CLIENT_TRANSPORT_H
#define WMI_XML_CLIENT_TRANSPORT_H

/******************************************************************************

This is the header file for the class implementing the IWbemClientTransport
interface.  This interface would be the entry point in our xmlhttp client
that WbemProx.dll would be calling.

******************************************************************************/

class CXMLWbemClientTransport : public IWbemClientTransport
{
private:
	long m_cRef;
public:

	CXMLWbemClientTransport();
	virtual ~CXMLWbemClientTransport();

	// IUnknown methods.
	STDMETHODIMP QueryInterface(REFIID iid,void ** ppvObject);
	STDMETHODIMP_(ULONG) AddRef();
	STDMETHODIMP_(ULONG) Release();
 
	// IWbemLocator methods.
	virtual HRESULT STDMETHODCALLTYPE ConnectServer(
									BSTR strAddressType,               
									DWORD dwBinaryAddressLength,
									BYTE* abBinaryAddress,

									BSTR strNetworkResource,               
									BSTR strUser,
									BSTR strPassword,
									BSTR strLocale,
									long lSecurityFlags,                 
									BSTR strAuthority,                  
									IWbemContext* pCtx,                 
									IWbemServices** ppNamespace
									);     
protected:
	// Function to check if the parameters are ok and wmi specific
	HRESULT CheckLocatorParams(BSTR strNetworkResource,BSTR strLocale);
	HRESULT CrackNetworkResource(WCHAR *pwszNetworkResource,
		WCHAR **ppwszFullServerName,WCHAR **ppwszNamespace);



};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\xmltransport\client\mainsources\xmlwbemservices.h ===
//XMLWbemServices.h - declaration for our implementation of IWbemServices

#ifndef WMI_XML_WBEM_SERVICE_H
#define WMI_XML_WBEM_SERVICE_H

enum ePATHTYPE
{
	CLASSPATH=1,
	INSTANCEPATH,
	SERVERPATH,
	NAMESPACEPATH,
	INVALIDOBJECTPATH
};

class CXMLWbemServices : public IWbemServices, public IClientSecurity
{		
private:
	
	static const WCHAR *s_pwszWMIString;

	// The COM ref count
	long	m_cRef;

	// Parameters directly provided by CXMLWbemClientTransport to our ctor
	// These come from the arguments of a ConnectServer() call
	WCHAR *m_pwszServername; 
	WCHAR *m_pwszNamespace; 
	WCHAR *m_pwszUser;
	WCHAR *m_pwszPassword;
	WCHAR *m_pwszLocale;
	WCHAR *m_pwszAuthority;

	// This is the same as m_pwszServername, but with square brackets around it
	// It is useful in setting the __SERVER property on object
	WCHAR *m_pwszBracketedServername;

	// Proxy information coming from the IWbemContext in ConnectServer
	WCHAR *m_pwszProxyName;
	WCHAR *m_pwszProxyBypass;

	// What response we got form the server for the  OPTIONS request
	// This is useful in passing on to other IWbemServices objects created from
	// OpenNamespace(), Open() etc. instead of resending an OPTIONS request 
	WCHAR *m_pwszOptionsResponse; 

	//set to indicate we are dealing with a WMI server
	bool	m_bWMIServer;

	IWbemContext *m_pCtx;

	ePATHSTYLE	m_ePathstyle; //NOVA OR WHISTLER PATH ?
		
	LONG	m_lSecurityFlags;

	//need to check availability of M-POST only once per connection..
	bool m_bTryMpost;

	CMapXMLtoWMI m_MapXMLtoWMI; //helper class to do the mapping from XML toWMI 


	static	LONG s_cCount; //used for creating unique mutexes for each CXMLWbemClientSecurity instance
	HANDLE	m_hMutex; //to be used for synchronization by all Actual_ functions

	//the http connection helper class. we will maintain one instance for 
	//a given server and use the same connection for all calls unless
	//user wants to connect to a different server/ different authentication.
	CHTTPConnectionAgent	*m_pConnectionAgent;

	// Used for implement CancelAsync call. This holds the list of Sinks on which 
	// calls have been cancelled
	// As soon as the user calls CancelAsync(), we simply add the Sink to this Map
	// Async calls will periodically check to see if a call on a Sink has been cancelled. 
	// If so, they try to do their best from executing
	// the call to completion
	CSinkMap	m_SinkMap; 
	
protected:
	// This function belongs to the ClientSecurity
	HRESULT  SetAuthenticationLevel(UINT iLevel); 

	//Function used to parse the object path and decide whether it is a class, instance or a namespace
	HRESULT	ParsePath(const BSTR strObjPath, ePATHTYPE *pePathType);

	// Different kinds of functions to send a packet and/or get a response
	HRESULT SendPacketForMethod(int iMethod, CXMLClientPacket *pPacket, CHTTPConnectionAgent *pDedicatedConnection, DWORD *pdwResultStatus);
	HRESULT SendRequestAndGetResponse(CXMLClientPacket *pPacket, IStream **ppStream);
	HRESULT SendPacketAndGetHRESULTResponse(CXMLClientPacket *pPacket, HRESULT *pHr);
	
	HRESULT SpawnSemiSyncThreadWithNormalPackage( LPTHREAD_START_ROUTINE pfThreadFunction,
																const BSTR strNsOrObjPath, 
																LONG lFlags, 
																IWbemContext *pCtx, 
																IWbemCallResult **ppCallResult,
																IWbemClassObject *pObject,
																IEnumWbemClassObject *pEnum,
																bool bIsEnum = false,
																bool bEnumTypeDedicated = false);

	HRESULT SpawnASyncThreadWithNormalPackage( LPTHREAD_START_ROUTINE pfThreadFunction,
																const BSTR strNsOrObjPath, 
																LONG lFlags, 
																IWbemContext *pCtx, 
																IWbemClassObject *pObject,
																IEnumWbemClassObject *pEnum,
																IWbemObjectSink *pResponseHandler,
																bool bEnumTypeDedicated = false);


	// Used internally by our IWbemServices functions
	// Our IWbemServices functions use these corresponding functions
	// to facilitate semisynchronous and asynchronous calls. 
	
	HRESULT Actual_GetInstance(const BSTR strObjectPath,LONG lFlags,IWbemContext *pCtx,IWbemClassObject **ppObject);
	HRESULT Actual_GetClass(const BSTR strObjectPath,LONG lFlags,IWbemContext *pCtx,IWbemClassObject **ppObject);
	HRESULT Actual_DeleteClass(const BSTR strClass,LONG lFlags,IWbemContext *pCtx);
	HRESULT Actual_DeleteInstance(const BSTR strObjectPath, LONG lFlags,IWbemContext *pCtx);
	HRESULT Actual_CreateClassEnum(const BSTR strSuperclass, LONG lFlags,  IWbemContext *pCtx, 
							IEnumWbemClassObject *pEnum, bool bEnumTypeDedicated);
	HRESULT Actual_CreateInstanceEnum(const BSTR strClass, LONG lFlags,IWbemContext *pCtx,
								IEnumWbemClassObject *pEnum, bool bEnumTypeDedicated);
	HRESULT Actual_ExecQuery(const BSTR strQueryLanguage, const BSTR strQuery, LONG lFlags, IWbemContext *pCtx,  
						IEnumWbemClassObject *pEnum);
	HRESULT Actual_OpenNamespace(const BSTR strNamespace,LONG lFlags, IWbemContext *pCtx,
		IWbemServices **ppWorkingNamespace);
	HRESULT Actual_PutClass(IWbemClassObject *pObject,LONG lFlags, 
		IWbemContext *pCtx);
	HRESULT Actual_PutInstance(IWbemClassObject *pObject,LONG lFlags, 
		IWbemContext *pCtx);
	HRESULT Actual_ExecMethod(const BSTR strObjectPath, const BSTR MethodName,  long lFlags, IWbemContext *pCtx, 
		IWbemClassObject *pInParams, IWbemClassObject **ppOutParams);


public:
	//helper function. also used by CXMLWbemTransaction class..
	HRESULT SendPacket(CXMLClientPacket *pPacketClass, CHTTPConnectionAgent *pDedicatedConnection = NULL);

public:
	//IUnknown functions
	STDMETHODIMP QueryInterface(REFIID iid,void ** ppvObject);
	STDMETHODIMP_(ULONG) AddRef();
	STDMETHODIMP_(ULONG) Release();

public:
	//passed by our ClientTransport's ConnectServer - result of OPTIONS req to server.
	HRESULT Initialize(WCHAR*	pwszServername, 
										WCHAR*  pwszNamespace,
										WCHAR*	pwszUser,
										WCHAR*	pwszPassword,
										WCHAR*	pwszLocale,
										LONG	lSecurityFlags,
										WCHAR*	pwszAuthority,
										IWbemContext *pCtx,
										WCHAR *pwszOptionsResponse, 
										ePATHSTYLE PathStyle);

public:
	CXMLWbemServices();
	virtual ~CXMLWbemServices();

	// IWbemServices Functions
	//=====================================================
	STDMETHODIMP  OpenNamespace( const BSTR strNamespace,              
		LONG lFlags, IWbemContext *pCtx,IWbemServices **ppWorkingNamespace, IWbemCallResult **ppResult);
	STDMETHODIMP  CancelAsyncCall( IWbemObjectSink *pSink);
	STDMETHODIMP GetObject(const BSTR strObjectPath,LONG lFlags,IWbemContext *pCtx,                        
										IWbemClassObject **ppObject,    
										IWbemCallResult **ppCallResult);
	STDMETHODIMP  GetObjectAsync(const BSTR strObjectPath,
		LONG lFlags, IWbemContext *pCtx, IWbemObjectSink *pResponseHandler);
	STDMETHODIMP  PutClass(IWbemClassObject *pObject,LONG lFlags, 
		IWbemContext *pCtx, IWbemCallResult **ppCallResult);
	STDMETHODIMP  PutClassAsync(IWbemClassObject *pObject, LONG lFlags, IWbemContext *pCtx, IWbemObjectSink *pResponseHandler);
	STDMETHODIMP  DeleteClass( const BSTR strClass,LONG lFlags, 
		IWbemContext *pCtx, IWbemCallResult **ppCallResult);
	STDMETHODIMP  DeleteClassAsync(const BSTR strClass, LONG lFlags, 
		IWbemContext *pCtx,  IWbemObjectSink *pResponseHandler);
	STDMETHODIMP  CreateClassEnum(const BSTR strSuperclass, LONG lFlags,  IWbemContext *pCtx, IEnumWbemClassObject **ppEnum);
	STDMETHODIMP  CreateClassEnumAsync(const BSTR strSuperclass, LONG lFlags, IWbemContext *pCtx, IWbemObjectSink *pResponseHandler);
	STDMETHODIMP  PutInstance(IWbemClassObject *pInst, LONG lFlags, 
		IWbemContext *pCtx, IWbemCallResult **ppCallResult);
	STDMETHODIMP  PutInstanceAsync(IWbemClassObject *pInst, LONG lFlags, IWbemContext *pCtx, IWbemObjectSink *pResponseHandler);
	STDMETHODIMP  DeleteInstance(const BSTR strObjectPath, LONG lFlags, 
		IWbemContext *pCtx, IWbemCallResult **ppCallResult);
	STDMETHODIMP  DeleteInstanceAsync(const BSTR strObjectPath, LONG lFlags, IWbemContext *pCtx, IWbemObjectSink *pResponseHandler);
	STDMETHODIMP  CreateInstanceEnum(const BSTR strClass, LONG lFlags, 
		IWbemContext *pCtx, IEnumWbemClassObject **ppEnum);
	STDMETHODIMP  CreateInstanceEnumAsync(const BSTR strClass,
		LONG lFlags, IWbemContext *pCtx, IWbemObjectSink *pResponseHandler);
	STDMETHODIMP  ExecQuery(const BSTR strQueryLanguage, const BSTR strQuery, LONG lFlags, IWbemContext *pCtx,  IEnumWbemClassObject **ppEnum);
	STDMETHODIMP  ExecQueryAsync(const BSTR strQueryLanguage, const BSTR strQuery,  long lFlags,  IWbemContext *pCtx, IWbemObjectSink *pResponseHandler);
	STDMETHODIMP  ExecMethod(const BSTR strObjectPath, const BSTR MethodName,  long lFlags, IWbemContext *pCtx, 
		IWbemClassObject *pInParams, IWbemClassObject **ppOutParams,
		IWbemCallResult **ppCallResult);
	STDMETHODIMP  ExecMethodAsync(const BSTR strObjectPath,
		const BSTR strMethodName, LONG lFlags,
		IWbemContext *pCtx, IWbemClassObject *pInParams,  IWbemObjectSink *pResponseHandler);

	// These methods not implemented - no eventing in XML
	//=========================================================
	STDMETHODIMP  QueryObjectSink(LONG lFlags, IWbemObjectSink **ppResponseHandler)
	{
		return E_NOTIMPL;
	}
	STDMETHODIMP  ExecNotificationQuery(const BSTR strQueryLanguage, 
		const BSTR strQuery,  long lFlags,  IWbemContext *pCtx,
		IEnumWbemClassObject **ppEnum)
	{
		return E_NOTIMPL;
	}

	STDMETHODIMP  ExecNotificationQueryAsync( const BSTR strQueryLanguage, const BSTR strQuery,  long lFlags, IWbemContext *pCtx, IWbemObjectSink *pResponseHandler)
	{
		return E_NOTIMPL;
	}


private:

	/****************************************************************************************************
			The threads that would be used for Async operations..
			Declared as friend functions as they call back our
			protected functions..... 
	****************************************************************************************************/

	friend DWORD WINAPI Thread_Async_GetObject(LPVOID pPackage);
	friend DWORD WINAPI Thread_Async_GetClass(LPVOID pPackage);
	friend DWORD WINAPI Thread_Async_GetInstance(LPVOID pPackage);
	friend DWORD WINAPI Thread_Async_PutClass(LPVOID pPackage);
	friend DWORD WINAPI Thread_Async_PutInstance(LPVOID pPackage);
	friend DWORD WINAPI Thread_Async_DeleteClass(LPVOID pPackage);
	friend DWORD WINAPI Thread_Async_DeleteInstance(LPVOID pPackage);
	friend DWORD WINAPI Thread_Async_CreateClassEnum(LPVOID pPackage);
	friend DWORD WINAPI Thread_Async_CreateInstanceEnum(LPVOID pPackage);
	friend DWORD WINAPI Thread_Async_ExecQuery(LPVOID pPackage);
	friend DWORD WINAPI Thread_Async_ExecMethod(LPVOID pPackage);

	/****************************************************************************************************
			The threads that would be used for Semi-sync operations..
			Declared as friend functions as they call back our
			protected functions..... 
	****************************************************************************************************/

	friend DWORD WINAPI Thread_SemiSync_GetObject(LPVOID pPackage);
	friend DWORD WINAPI Thread_SemiSync_GetClass(LPVOID pPackage);
	friend DWORD WINAPI Thread_SemiSync_GetInstance(LPVOID pPackage);
	friend DWORD WINAPI Thread_SemiSync_PutClass(LPVOID pPackage);
	friend DWORD WINAPI Thread_SemiSync_PutInstance(LPVOID pPackage);
	friend DWORD WINAPI Thread_SemiSync_DeleteClass(LPVOID pPackage);
	friend DWORD WINAPI Thread_SemiSync_DeleteInstance(LPVOID pPackage);
	friend DWORD WINAPI Thread_SemiSync_CreateClassEnum(LPVOID pPackage);
	friend DWORD WINAPI Thread_SemiSync_CreateInstanceEnum(LPVOID pPackage);
	friend DWORD WINAPI Thread_SemiSync_ExecQuery(LPVOID pPackage);
	friend DWORD WINAPI Thread_SemiSync_ExecMethod(LPVOID pPackage);
	friend DWORD WINAPI Thread_SemiSync_OpenNamespace(LPVOID pPackage);

	/***************************************************************************************************
			IClientSecurity functions.
	***************************************************************************************************/

public:
	STDMETHODIMP CopyProxy(IUnknown *  pProxy,IUnknown **  ppCopy);

	STDMETHODIMP QueryBlanket(IUnknown*  pProxy,DWORD*  pAuthnSvc,DWORD*  pAuthzSvc,
							OLECHAR**  pServerPrincName,DWORD* pAuthnLevel,
							DWORD* pImpLevel,RPC_AUTH_IDENTITY_HANDLE*  pAuthInfo, 
							DWORD*  pCapabilities);

	STDMETHODIMP SetBlanket(IUnknown * pProxy,DWORD  dwAuthnSvc,DWORD  dwAuthzSvc,
						OLECHAR * pServerPrincName,DWORD  dwAuthnLevel,
						DWORD  dwImpLevel,RPC_AUTH_IDENTITY_HANDLE  pAuthInfo,
						DWORD  dwCapabilities);

};


#endif //WMI_XML_WBEM_SERVICE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\xmltransport\client\testclient\stdafx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#if !defined(AFX_STDAFX_H__A9DB83DB_A9FD_11D0_BFD1_444553540000__INCLUDED_)
#define AFX_STDAFX_H__A9DB83DB_A9FD_11D0_BFD1_444553540000__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#ifndef _WIN32_DCOM
#define _WIN32_DCOM
#endif

#ifndef UNICODE
#define UNICODE
#endif

#include <windows.h>
#include <iostream.h>
#include <stdio.h>
#include <objbase.h>
#include <TCHAR.H>

// TODO: reference additional headers your program requires here

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__A9DB83DB_A9FD_11D0_BFD1_444553540000__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\xmltransport\client\mainsources\xmlwbemclienttransport.cpp ===
#include "wbemtran.h"
#include "XMLProx.h"
#include "SinkMap.h" //Needed by services.
#include "URLParser.h"
#include "XMLWbemClientTransport.h"
#include "XMLClientpacket.h"
#include "XMLClientPacketFactory.h"
#include "HTTPConnectionAgent.h"
#include "XMLWbemCallResult.h"
#include "XMLWbemServices.h"

extern long g_lComponents; //Declared in the XMLProx.dll

CXMLWbemClientTransport::CXMLWbemClientTransport():m_cRef(1)
{
	InterlockedIncrement(&g_lComponents);
}

CXMLWbemClientTransport::~CXMLWbemClientTransport()
{
	InterlockedDecrement(&g_lComponents);
}

HRESULT CXMLWbemClientTransport::QueryInterface(REFIID iid,void ** ppvObject)
{
	HRESULT hr = E_NOTIMPL;

	//QueryInterface is reflexive
	if(iid == IID_IWbemClientTransport ||
		iid == IID_IUnknown )
	{
		*ppvObject = (IWbemClientTransport *)this;
		hr = S_OK;
		AddRef();
	}

	return hr;
}

ULONG CXMLWbemClientTransport::AddRef()
{
	return (InterlockedIncrement(&m_cRef));
}

ULONG CXMLWbemClientTransport::Release()
{
	if(InterlockedDecrement(&m_cRef) == 0)
		delete this;
	return m_cRef;
}
 
	
HRESULT CXMLWbemClientTransport::ConnectServer(
									BSTR strAddressType,               
									DWORD dwBinaryAddressLength,
									BYTE* abBinaryAddress,
									BSTR strNetworkResource,               
									BSTR strUser,
									BSTR strPassword,
									BSTR strLocale,
									long lSecurityFlags,                 
									BSTR strAuthority,                  
									IWbemContext* pCtx,                 
									IWbemServices** ppNamespace
									)
{
	if (lSecurityFlags != 0)
		return WBEM_E_INVALID_PARAMETER;

	HRESULT hr = S_OK;
	CXMLWbemServices *pXMLWbemServices = NULL;

	//Check if network resource and locale are properly supplied to us.
	if(SUCCEEDED(hr = CheckLocatorParams(strNetworkResource,strLocale)))
	{
		WCHAR *pwszFullServerName = NULL;
		WCHAR *pwszNamespace = NULL;

		if(SUCCEEDED(hr = CrackNetworkResource(strNetworkResource, &pwszFullServerName,&pwszNamespace)))
		{
			
			//Send the OPTIONS request and pass on the result to 
			//IWbemServices implementation. it will decide what to make
			//out of this response

			CHTTPConnectionAgent ConnectionAgent;
			if(SUCCEEDED(hr = ConnectionAgent.InitializeConnection(pwszFullServerName, strUser,strPassword)))
			{
				//send would fail if the destination machine is unreachable or 
				//the server could not recognize our packet at all.
				//not same as OPTIONS failed
				if(SUCCEEDED(ConnectionAgent.Send(L"OPTIONS",NULL, NULL, 0)))
				{
					DWORD dwResponseSize = 0;
					WCHAR *pwszResponse = NULL;

					// No need to check the return value here since, if the call
					// fails and pszResponse is NULL, the call to Initialize() below
					// will automatically assume a non-WMI server
					ConnectionAgent.GetResultHeader(&pwszResponse,&dwResponseSize);

					// Create the IWbemServices object and initialize it with not only the
					// OPTIONS response, but also other argumens to the ConnectServer() call
					// The NOVAPATH argument implies that we are a Nova Client
					if(pXMLWbemServices = new CXMLWbemServices())
					{
						hr = pXMLWbemServices->Initialize(pwszFullServerName, 
																pwszNamespace,
																strUser,
																strPassword,
																strLocale,
																lSecurityFlags,
																strAuthority,
																pCtx,
																pwszResponse, 
																NOVAPATH);
					}
					else 
						hr = E_OUTOFMEMORY;
					// Done with the response
					delete [] pwszResponse;
				}
				else
				{
					// RAJESHR David Johnson has to give us a new error code to indicate
					// that the machine did not exist
					hr = WBEM_E_TRANSPORT_FAILURE;
				}
			}
			delete [] pwszFullServerName;
			delete [] pwszNamespace;
		}
		
	}

	// See if we really need to keep the XMLWbemServices pointer
	if(SUCCEEDED(hr))
	{
		*ppNamespace = pXMLWbemServices; 
	}
	else
	{
		delete pXMLWbemServices;
		*ppNamespace = NULL;
	}

	return hr;
}

// Checks to see it the strNetworkResource actually is a HTTP URL and the strLocale (if any),
// begins with MS_
HRESULT CXMLWbemClientTransport::CheckLocatorParams(const BSTR strNetworkResource, const BSTR strLocale)
{
	HRESULT hr = WBEM_E_INVALID_PARAMETER;

	//if network resource is NULL, fail, no need to check anything else.
	if(SysStringLen(strNetworkResource)>0)
	{
		//According to new Whistler specs, the network resource has to be of the format
		//"//[http://abc.xyz.com/cimom/whatever]/rootnamespace/subnamespace" Or
		//"//[https://abc.xyz.com/cimom/whatever]/rootnamespace/subnamespace"

		if((_wcsnicmp(strNetworkResource, L"//[http://", wcslen(L"//[http://"))== 0)		||
			(_wcsnicmp(strNetworkResource, L"\\\\[http://", wcslen(L"\\\\[http://"))== 0)	||
			(_wcsnicmp(strNetworkResource, L"//[https://", wcslen(L"//[https://"))==NULL)	||
			(_wcsnicmp(strNetworkResource, L"\\\\[https://", wcslen(L"\\\\[https://"))==NULL))
		{
			// To pass Nova Automation, we need to do some additional checking
			// The automation passes us strings of the form "\\[URL]" and expects
			// WBEM_E_INVALID_NAMESPACE as the return code
			LPWSTR pszNetworkResource = (LPWSTR)strNetworkResource;
			if(pszNetworkResource[wcslen(pszNetworkResource)-1] == L']')
				hr = WBEM_E_INVALID_NAMESPACE;
			else
			{
				// User need not provide a locale , in which case the default will be chosen.
				// Otherwise, the local has to start with "MS_"
				if(SysStringLen(strLocale) > 0)
				{
					if(SysStringLen(strLocale) > 3)
					{
						if(_wcsnicmp(strLocale, L"MS_", 3) == 0) //not an MS approved locale
								hr = S_OK;
					}
				}
				else
					hr = S_OK;
			}
		}
	}
	return hr;
}

// Breaks down a URL-Namespace string of the form \\[URL]\Namespace
// into URL and Namespace. When this function is called we know for certain
// that pwszNetworkResource is a string that has been checked by
// CheckLocatorParams() to contain a proper http or https URL in it
HRESULT  CXMLWbemClientTransport::CrackNetworkResource(WCHAR *pwszNetworkResource,
									   WCHAR **ppwszFullServerName,WCHAR **ppwszNamespace)
{
	// remove [s and ]s from pwszNetworkResource and break it into url and namespace
	//=====================================================================

	HRESULT hr = S_OK;
	LPWSTR pwszServername = pwszNetworkResource + wcslen(L"//[");
	LPWSTR pwszNamespace = NULL;

	// at this point, pwszServername contains the network resource without the "//[" prefix. but with "]"

	// get the beginning of the namespace
	if(pwszNamespace = wcsstr(pwszServername,L"]"))
	{
		if(*ppwszNamespace = new WCHAR[wcslen(pwszNamespace)])
		{
			 // string after "]" is supposed to contain the namespace
			wcscpy(*ppwszNamespace, pwszNamespace+2);

			// Now we go for the URL
			INT_PTR iURLLen = pwszNamespace - pwszServername;
			if(*ppwszFullServerName = new WCHAR[iURLLen + 1])
			{
				wcsncpy(*ppwszFullServerName, pwszServername, iURLLen);
				(*ppwszFullServerName)[iURLLen] = NULL;
			}
			else
				hr = E_OUTOFMEMORY;
		}
		else
			hr = E_OUTOFMEMORY;
	}
	else
		hr = WBEM_E_INVALID_PARAMETER;
	
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\xmltransport\client\testclient\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//	WClient.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

// TODO: reference any additional headers you need in STDAFX.H
// and not in this file
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\xmltransport\compiler\control\uuid\xmltrnsf_guids.c ===
#include <xmltrnsf_i.c>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\xmltransport\client\testclient\wclient.cpp ===
// WClient.cpp : Defines the entry point for the application.
//

#include "stdafx.h"
#include <BASETYPS.H>
#include "wmiconv.h"
#include "wmixmlop_i.c"
#include <F:\nt\public\sdk\inc\psapi.h>



// {610037EC-CE06-11d3-93FC-00805F853771}
//DEFINE_GUID(CLSID_WbemXMLConvertor, 
//0x610037ec, 0xce06, 0x11d3, 0x93, 0xfc, 0x0, 0x80, 0x5f, 0x85, 0x37, 0x71);

void AssignBSTRtoWCHAR(WCHAR **ppwszTo,BSTR strBstring);

bool InitSecurity(void);
bool ConnectToNamespace(BSTR strNamespace,IWbemServices **ppWbemServices);
void EnumerateForClass(BSTR classname);

void TryGetObject(IWbemServices *pIWbemServices,WCHAR *ObjPath);
void TryPutClass(IWbemServices *pWbemServices,IWbemClassObject *pObject);
void TryPutInstance(IWbemServices *pWbemServices,IWbemClassObject *pObject);

HRESULT TryWMIXMLConvertor();

DWORD WINAPI GetClassThread(void *pIWbemServices);

IWbemServices	*m_pIWbemServices=NULL;

BSTR			m_namespace=NULL;


int APIENTRY WinMain(HINSTANCE hInstance,
                     HINSTANCE hPrevInstance,
                     LPSTR     lpCmdLine,
                     int       nCmdShow)
{
 	// TODO: Place code here.

	OleInitialize(NULL);


	if (!InitSecurity())
    {
        return 1;
    }


	//TryWMIXMLConvertor();

	
	//m_namespace=SysAllocString(L"//[http://calvinids/cimhttp/wmiisapi.dll]/root/cimv2");
	
	m_namespace=SysAllocString(L"\\\\.\\root\\cimv2");
	
	wprintf(L"Connecting to Namespace %s\n",m_namespace);

	IWbemServices *pWbemServices;

	ConnectToNamespace(m_namespace,&pWbemServices);

	SysFreeString(m_namespace);



	//m_namespace=SysAllocString(L"//[http://Calvinids/cimom]/root/cimv2");
	m_namespace=SysAllocString(L"//[http://localhost/cimhttp/wmiisapi.dll]/root/cimv2");
	//m_namespace=SysAllocString(L"//[http://calvinids/cimhttp/wmiisapi.dll]/root/cimv2");

	wprintf(L"Connecting to Namespace %s\n",m_namespace);

	ConnectToNamespace(m_namespace,&pWbemServices);

	SysFreeString(m_namespace);

	//TryPutClass(pWbemServices,pCimObject);
	//TryPutInstance(pWbemServices,pInstance);
	
	
	//MessageBox(NULL,tmp,NULL,MB_OK);


	IWbemClassObject *pOutObj=NULL;

	//pWbemServices->ExecMethod(SysAllocString(L"Win32_process"),SysAllocString(L"Create"),
			//					WBEM_FLAG_RETURN_WBEM_COMPLETE,NULL,                       
			//					pCimObject,&pOutObj,NULL);

			
	TryGetObject(pWbemServices,L"Cim_Processor");

	pWbemServices->Release();
	
	//WaitForSingleObject(hThread,INFINITE);

	return 0;
}

bool InitSecurity(void)
{
	// Adjust thesecurity to allow client impersonation.

	HRESULT hres =	CoInitializeSecurity
					(NULL,-1,NULL,NULL,RPC_C_AUTHN_LEVEL_NONE,RPC_C_IMP_LEVEL_IMPERSONATE,NULL,0,0);

	return (SUCCEEDED(hres));
}

bool ConnectToNamespace(BSTR strNamespace,IWbemServices **ppServices)
{

	IWbemLocator *pIWbemLocator = NULL;

    wprintf(L"\nCreating instance of IWbemLocator class..\n");

	if(CoCreateInstance(CLSID_WbemLocator,
        NULL,
        CLSCTX_INPROC_SERVER,
        IID_IWbemLocator,
        (LPVOID *) &pIWbemLocator) == S_OK)
    {
        // Using the locator, connect to WMI in the given namespace.
        BSTR pNamespace = m_namespace;

		wprintf(L"\nGetting an IWbemServices ptr using IWbemLocator's ConnectServer method\n");

        if(pIWbemLocator->ConnectServer(strNamespace,
                                NULL,    //using current account
                                NULL,    //using current password
                                NULL,      // locale
                                0L,      // securityFlags
                                NULL,    // authority (NTLM domain)
                                NULL,    // context
                                ppServices) == S_OK) 
        {
            // Indicate success.
           wprintf(L"%s",_T("\nConnected to namespace"));

        }
        else 
		{
			wprintf(L"%s",_T("\nBad namespace"));
			return false;
		}

		// Done with pNamespace.
        SysFreeString(pNamespace);

        // Done with pIWbemLocator. 
        pIWbemLocator->Release(); 
    
		//wprintf(L"\nSwitching security level to IMPERSONATE using CoSetProxyBlanket\n");

            // Switch security level to IMPERSONATE. 
            /*
			CoSetProxyBlanket(m_pIWbemServices,    // proxy
                RPC_C_AUTHN_WINNT,        // authentication service
                RPC_C_AUTHZ_NONE,         // authorization service
                NULL,                         // server principle name
                RPC_C_AUTHN_LEVEL_CALL,   // authentication level
                RPC_C_IMP_LEVEL_IMPERSONATE,    // impersonation level
                NULL,                         // identity of the client
                EOAC_NONE);               // capability flags
			*/

			return true;
        }
    else wprintf(L"%s",_T("Failed to create IWbemLocator object"));
	return false;
}

void AssignBSTRtoWCHAR(WCHAR **ppwszTo,BSTR strBstring)
{
	if((NULL ==strBstring)||(ppwszTo == NULL))
		return;

	UINT iBstrLen = SysStringLen(strBstring)+1;

	iBstrLen = sizeof(WCHAR) * iBstrLen;

	*ppwszTo = new WCHAR[iBstrLen];

	memset((void *)(*ppwszTo),0, iBstrLen);

	memcpy((void *)(*ppwszTo), strBstring, iBstrLen-sizeof(WCHAR));//last one for null char

}

DWORD WINAPI GetClassThread(void *pIWbemServices)
{

	IWbemServices *m_pIWbemServices = (IWbemServices *)pIWbemServices;
	
	BSTR strNamespace = SysAllocString(L"root\\cimv2");

	

	BSTR strObjectPath;

	BSTR strObjectText;
	
	strObjectPath = SysAllocString(L"Win32_LogicalDisk");

	IWbemClassObject *pObject;

	HRESULT hr = m_pIWbemServices->GetObject(
										strObjectPath,                          
										WBEM_FLAG_RETURN_WBEM_COMPLETE,                              
										NULL,                        
										&pObject,    
										NULL);

	
	if(NULL != pObject)
	{
		pObject->GetObjectText(0,&strObjectText);
		pObject->Release();
	}

	WCHAR *pStrObjectText = NULL;

	AssignBSTRtoWCHAR(&pStrObjectText,strObjectText);

	MessageBox(NULL,pStrObjectText,L"Win32_LogicalDisk",MB_OK);

	SysFreeString(strObjectText);

	delete [] pStrObjectText;

	return 0;

}

HRESULT TryWMIXMLConvertor()
{
	CLSID clsid;

    SCODE sc = CLSIDFromString(L"{610037EC-CE06-11d3-93FC-00805F853771}", &clsid);
    
	if(sc != S_OK)
        return sc;
	
	IWbemXMLConvertor *ppv = NULL;

	HRESULT hres = CoCreateInstance(clsid,NULL,CLSCTX_INPROC,IID_IWbemXMLConvertor,(void**)&ppv);
	
	IWbemServices *pWbemServices;

	if(SUCCEEDED(hres))
	{
		IWbemClassObject *pObject = NULL;
		

		ConnectToNamespace(SysAllocString(L"\\\\.\\root\\cimv2"),&pWbemServices);

		BSTR strObjectPath;
	
		strObjectPath = SysAllocString(L"Cim_Processor");
	
		HRESULT hr = pWbemServices->GetObject(
										strObjectPath,                          
										WBEM_FLAG_RETURN_WBEM_COMPLETE,                              
										NULL,                        
										&pObject,    
										NULL);

		SysFreeString(strObjectPath);

		IStream *pOutputStream=NULL;
		
		CreateStreamOnHGlobal(
								NULL,         //Memory handle for the stream object
								TRUE,   //Whether to free memory when the 
										// object is released
								&pOutputStream          //Address of output variable that 
														// receives the IStream interface pointer
								);

		IWbemContext *ppctx = NULL;

		CoCreateInstance(CLSID_WbemContext,NULL,CLSCTX_INPROC,IID_IWbemContext,(void**)&ppctx);

		if(NULL != pObject)
		{
			ppv->MapObjectToXML(pObject, 
								NULL, 
								0, 
								ppctx, 
								pOutputStream, 
								NULL);

			if(NULL != pOutputStream)
			{
				STATSTG stat;
				DWORD dwRead;
				
				memset(&stat,0,sizeof(STATSTG));

				LARGE_INTEGER	offset;
				
				offset.LowPart = offset.HighPart = 0;
				
				pOutputStream->Seek (offset, STREAM_SEEK_SET, NULL);

				pOutputStream->Stat(&stat,1);

				unsigned int iLen = (unsigned int)stat.cbSize.LowPart;

				WCHAR *pwszResult = new WCHAR[iLen];

				hr = pOutputStream->Read((void*)pwszResult,iLen,&dwRead);

				MessageBox(NULL,pwszResult,NULL,MB_OK);
			}
		}

	}

	pWbemServices->Release();
	return S_OK;
}


void TryGetObject(IWbemServices *pIWbemServices,WCHAR *ObjPath)
{
	IWbemClassObject *pObject = NULL;

	HRESULT hr;

	BSTR strObjectText;
	WCHAR *pStrObjectText = NULL;
	BSTR strObjectPath;

	strObjectPath = SysAllocString(ObjPath);

		
	if(NULL != pIWbemServices)
	{
		hr = pIWbemServices->GetObject(
										strObjectPath,                          
										WBEM_FLAG_RETURN_WBEM_COMPLETE,                              
										NULL,                        
										&pObject,    
										NULL);
		
		
	}
	
	if(NULL != pObject)
	{
		pObject->GetObjectText(0,&strObjectText);
		pObject->Release();
	

		AssignBSTRtoWCHAR(&pStrObjectText,strObjectText);

		MessageBox(NULL,pStrObjectText,strObjectPath,MB_OK);
		
		SysFreeString(strObjectText);
	}

	delete [] pStrObjectText;

}

void TryPutClass(IWbemServices *pWbemServices,IWbemClassObject *pObject)
{
	HRESULT hr;

			
	if(NULL != pWbemServices)
	{
		hr = pWbemServices->PutClass(
										pObject,                
										WBEM_FLAG_UPDATE_ONLY,                             
										NULL,                       
										NULL  
										);
	}
	
}

void TryPutInstance(IWbemServices *pWbemServices,IWbemClassObject *pObject)
{
	HRESULT hr;

			
	if(NULL != pWbemServices)
	{
		hr = pWbemServices->PutInstance(
										pObject,                
										WBEM_FLAG_CREATE_OR_UPDATE,                             
										NULL,                       
										NULL  
										);
	}
	
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\xmltransport\compiler\control\xmltransf\classfac.h ===
//***************************************************************************
//
// Copyright (c) 1997-1999 Microsoft Corporation
//
//  classfac.h
//
//  alanbos  13-Feb-98   Created.
//
//  Class factory interface.
//
//***************************************************************************

#ifndef _XML_TRANS_CLASSFAC_H_
#define _XML_TRANS_CLASSFAC_H_

typedef LPVOID * PPVOID;

// These variables keep track of when the module can be unloaded

extern long       g_cObj;
extern ULONG       g_cLock;

//***************************************************************************
//
//  CLASS NAME:
//
//  CXMLTFactory
//
//  DESCRIPTION:
//
//  Class factory for the CLocator class.
//
//***************************************************************************

class CXMLTFactory : public IClassFactory
{
protected:
	long           m_cRef;

public:

    CXMLTFactory(void);
    ~CXMLTFactory(void);
    
    //IUnknown members
	STDMETHODIMP         QueryInterface(REFIID, LPVOID*);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    //IClassFactory members
	STDMETHODIMP         CreateInstance(LPUNKNOWN, REFIID, LPVOID*);
	STDMETHODIMP         LockServer(BOOL);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\xmltransport\compiler\control\xmltransf\classfac.cpp ===
//***************************************************************************
//
// Copyright (c) 1997-1999 Microsoft Corporation
//
//  CLASSFAC.CPP
//
//  alanbos  13-Feb-98   Created.
//
//  Contains the class factory.  This creates objects when
//  connections are requested.
//
//***************************************************************************
#include <tchar.h>
#include "precomp.h"
#include <map>
#include <vector>
#include <wmiutils.h>
#include <wbemdisp.h>
#include <ocidl.h>
#include "disphlp.h"
#include <objsafe.h>
#include <wbemcli.h>
#include <wbemdisp.h>
#include <XMLTransportClientHelper.h>
#include "classfac.h"
#include "xmltrnsf.h"
#include "privilege.h"
#include "cxmltransf.h"

static HRESULT InitializeWmiXmlTransfDLL ();

//***************************************************************************
//
// CXMLTFactory::CXMLTFactory
//
// DESCRIPTION:
//
// Constructor
//
//***************************************************************************

CXMLTFactory::CXMLTFactory()
{
    m_cRef=0L;
	return;
}

//***************************************************************************
//
// CXMLTFactory::~CXMLTFactory
//
// DESCRIPTION:
//
// Destructor
//
//***************************************************************************

CXMLTFactory::~CXMLTFactory(void)
{
	return;
}

//***************************************************************************
//
// CXMLTFactory::QueryInterface
// CXMLTFactory::AddRef
// CXMLTFactory::Release
//
// Purpose: Standard Ole routines needed for all interfaces
//
//***************************************************************************


STDMETHODIMP CXMLTFactory::QueryInterface(REFIID riid
    , LPVOID *ppv)
{
    *ppv=NULL;

    if (IID_IUnknown==riid || IID_IClassFactory==riid)
        *ppv=this;

    if (NULL!=*ppv)
        {
        ((LPUNKNOWN)*ppv)->AddRef();
        return NOERROR;
        }

    return ResultFromScode(E_NOINTERFACE);
}

STDMETHODIMP_(ULONG) CXMLTFactory::AddRef(void)
{
    long l = InterlockedIncrement(&m_cRef);
    return l;
}

STDMETHODIMP_(ULONG) CXMLTFactory::Release(void)
{
    long l = InterlockedDecrement(&m_cRef);
    if (0L!=l)
        return l;

    delete this;
    return 0L;
}

//***************************************************************************
//
//  SCODE CXMLTFactory::CreateInstance
//
//  Description:
//
//  Instantiates a Translator object returning an interface pointer.
//
//  Parameters:
//
//  pUnkOuter       LPUNKNOWN to the controlling IUnknown if we are
//                  being used in an aggregation.
//  riid            REFIID identifying the interface the caller
//                  desires to have for the new object.
//  ppvObj          PPVOID in which to store the desired
//                  interface pointer for the new object.
//
// Return Value:
//  HRESULT         NOERROR if successful, otherwise E_NOINTERFACE
//                  if we cannot support the requested interface.
//***************************************************************************

STDMETHODIMP CXMLTFactory::CreateInstance (

	IN LPUNKNOWN pUnkOuter,
    IN REFIID riid,
    OUT PPVOID ppvObj
)
{
    IUnknown *pObj = NULL;
    HRESULT hr = E_FAIL;

    *ppvObj=NULL;

    // This object doesnt support aggregation.
    if (NULL!=pUnkOuter)
        return ResultFromScode(CLASS_E_NOAGGREGATION);

	// Set up global variables. 
	if(SUCCEEDED(hr = InitializeWmiXmlTransfDLL()))
	{
		if(pObj = (IWmiXMLTransformer *) new CXMLTransformer)
		{
			if(FAILED(hr = pObj->QueryInterface(riid, ppvObj)))
			{
				//Kill the object if initial creation or Init failed.
				delete pObj;
			}
		}
		else
			hr = ResultFromScode(E_OUTOFMEMORY);;
	}
    return hr;
}

//***************************************************************************
//
//  SCODE CXMLTFactory::LockServer
//
//  Description:
//
//  Increments or decrements the lock count of the DLL.  If the
//  lock count goes to zero and there are no objects, the DLL
//  is allowed to unload.  See DllCanUnloadNow.
//
//  Parameters:
//
//  fLock           BOOL specifying whether to increment or
//                  decrement the lock count.
//
//  Return Value:
//
//  HRESULT         NOERROR always.
//***************************************************************************


STDMETHODIMP CXMLTFactory::LockServer(IN BOOL fLock)
{
    if (fLock)
        InterlockedIncrement((long *)&g_cLock);
    else
        InterlockedDecrement((long *)&g_cLock);

    return NOERROR;
}




//***************************************************************************
//
//  SCODE InitializeWmiXmlTransfDLL
//
//  DESCRIPTION:
//
//  This static function is caused on CreateInstance(); it sets up some global information
// required for security processing.
//
//***************************************************************************
 
HRESULT InitializeWmiXmlTransfDLL ()
{
	HRESULT hr = S_OK;
	EnterCriticalSection (&g_csGlobalInitialization);

	if (!s_bInitialized)
	{
		// Get OS info
		OSVERSIONINFO	osVersionInfo;
		osVersionInfo.dwOSVersionInfoSize = sizeof (OSVERSIONINFO);

		GetVersionEx (&osVersionInfo);
		s_bIsNT = (VER_PLATFORM_WIN32_NT == osVersionInfo.dwPlatformId);
		s_dwNTMajorVersion = osVersionInfo.dwMajorVersion;

		if (s_bIsNT)
		{
			HKEY hKey;

			// Security values are relevant for NT only - for Win9x leave as default
			if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, 
					L"Software\\Microsoft\\Wbem\\XML\\XMLTransformer", 0, KEY_QUERY_VALUE, &hKey))
			{
				DWORD dwDummy = 0;

				// Get revert flag value from registry - NT 4.0 or less only
				if (s_dwNTMajorVersion <= 4)
				{
					DWORD dwEnableForAsp = 0;
					dwDummy = sizeof (dwEnableForAsp);
				
					if (ERROR_SUCCESS == RegQueryValueEx (hKey, L"EnableForASP", 
							NULL, NULL, (BYTE *) &dwEnableForAsp,  &dwDummy))
						s_bCanRevert = (0 != dwEnableForAsp);
				}

				RegCloseKey (hKey);
			}
		}
		if(SUCCEEDED(hr = InitWMIXMLClientLibrary()))
			s_bInitialized = true;
	}
	
	LeaveCriticalSection (&g_csGlobalInitialization);
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\xmltransport\compiler\control\xmltransf\cxmltransf.h ===
//***************************************************************************
//
// Copyright (c) 1997-1999 Microsoft Corporation
//
//  cwbmxmlt.h
//
//  alanbos  13-Feb-98   Created.
//
//  Genral purpose include file.
//
//***************************************************************************

#ifndef _CXMLTRANSF_H_
#define _CXMLTRANSF_H_

//***************************************************************************
//
//  CLASS NAME:
//
//  CXMLTransformer
//
//  DESCRIPTION:
//
//  Implements the IWmiXMLTransformer.
//
//***************************************************************************

class CXMLTransformer : public IWmiXMLTransformer,
					   public IObjectSafety,
					   public ISupportErrorInfo
{

private:
	CRITICAL_SECTION			m_cs;
	ITypeInfo*					m_pITINeutral; 
	CSWbemPrivilegeSet			m_PrivilegeSet; // The set of privileges used when any operation is done

	// Various propertied of this COM object
	WmiXMLEncoding				m_iEncoding;
	VARIANT_BOOL				m_bQualifierFilter;
	VARIANT_BOOL				m_bClassOriginFilter;
	BSTR						m_strUser;
	BSTR						m_strPassword;
	BSTR						m_strAuthority;
	DWORD						m_dwImpersonationLevel;
	DWORD						m_dwAuthenticationLevel;
	BSTR						m_strLocale;
	VARIANT_BOOL				m_bLocalOnly;

	HRESULT				m_hResult;	// Last HRESULT returned from CIMOM call

	// Compilation errors, if any, due to the last compilation
	BSTR m_strCompilationErrors;

	// Takes the contents of an IStream and puts it into a BSTR
	static HRESULT	SaveStreamAsBSTR (IStream *pStream, BSTR *pBstr);

	// Gets the first child element of the specified name
	static HRESULT GetFirstImmediateElement(IXMLDOMNode *pParent, IXMLDOMElement **ppChildElement, LPCWSTR pszName);

	// For creating standard syntax error messages with information form the XML Parser
	static LPCWSTR s_pszXMLParseErrorMessage;

	HRESULT STDMETHODCALLTYPE DoWellFormCheck(
						VARIANT *pvInputSource, 
						VARIANT_BOOL *pStatus, 
						BSTR *pstrError, 
						bool bCheckForValidity, 
						IXMLDOMDocument **pDoc);
	HRESULT STDMETHODCALLTYPE CompileString(
			/* [in] */ VARIANT *pvInputSource,
			/* [in] */ BSTR strNamespacePath,
			/* [in] */ LONG lClassFlags,
			/* [in] */ LONG lInstanceFlags,
			/* [in] */ IWbemContext *pContext,
			/* [out]*/ BSTR *pstrError);

	HRESULT STDMETHODCALLTYPE CompileStream(
			/* [in] */ VARIANT *pvInputSource,
			/* [in] */ BSTR strNamespacePath,
			/* [in] */ LONG lClassFlags,
			/* [in] */ LONG lInstanceFlags,
			/* [in] */ IWbemContext *pContext,
			/* [out]*/ BSTR *pstrError);

	// Compiles a single document
	HRESULT CompileDocument (
		IXMLDOMDocument *pDocument,
        BSTR strNamespacePath,
        LONG lClassFlags,
        LONG lInstanceFlags,
		IWbemContext *pContext,
			/* [out]*/ BSTR *pstrError);
	HRESULT ProcessDeclGroup (
		IXMLDOMElement *pDeclGroup,
        BSTR strNamespacePath,
        LONG lClassFlags,
        LONG lInstanceFlags,
		IWbemContext *pContext,
			/* [out]*/ BSTR *pstrError);
	HRESULT ProcessDeclGroupWithName (
		IXMLDOMElement *pDeclGroup,
        BSTR strNamespacePath,
        LONG lClassFlags,
        LONG lInstanceFlags,
		IWbemContext *pContext,
			/* [out]*/ BSTR *pstrError);
	HRESULT ProcessDeclGroupWithPath (
		IXMLDOMElement *pDeclGroup,
        BSTR strNamespacePath,
        LONG lClassFlags,
        LONG lInstanceFlags,
		IWbemContext *pContext,
			/* [out]*/ BSTR *pstrError);
	HRESULT ProcessValueObject (
		IXMLDOMNode *pValueObject,
        BSTR strNamespacePath,
        LONG lClassFlags,
        LONG lInstanceFlags,
		IWbemContext *pContext);
	HRESULT ProcessValueNamedObject (
		IXMLDOMNode *pValueObject,
        BSTR strNamespacePath,
        LONG lClassFlags,
        LONG lInstanceFlags,
		IWbemContext *pContext);
	HRESULT ProcessValueObjectWithPath (
		IXMLDOMNode *pValueObject,
        BSTR strNamespacePath,
        LONG lClassFlags,
        LONG lInstanceFlags,
		IWbemContext *pContext);
	HRESULT PutObject (
		IXMLDOMElement *pObjectElement,
        BSTR strNamespacePath,
        LONG lClassFlags,
        LONG lInstanceFlags,
		IWbemContext *pContext);
	HRESULT PutClass (
		bool bIsHTTP,
		bool bIsNovaPath,
		BSTR strNamespacePath,
		LPCWSTR pszHostNameOrURL,
		LPCWSTR pszNamespace,
		LONG lClassFlags,
		IXMLDOMNode *pClassPathNode,
		IXMLDOMElement *pClassNode,
		IWbemContext *pContext);
	HRESULT PutInstance (
		bool bIsHTTP,
		bool bIsNovaPath,
		BSTR strNamespacePath,
		LPCWSTR pszHostNameOrURL,
		LPCWSTR pszNamespace,
		LONG lInstanceFlags,
		IXMLDOMNode *pInstancePathNode,
		IXMLDOMElement *pInstanceNode,
		IWbemContext *pContext);

	HRESULT ProcessPragmas(IXMLDOMNode *pNode, BSTR strNodeName, 
										LONG &lClassFlags, LONG&lInstanceFlags, BSTR &strNamespacePath,
										IWbemContext *pContext,
										BSTR *pstrError);

	HRESULT ProcessClassPragma(IXMLDOMNode *pNode, LONG &lClassFlags,
	BSTR *pstrError);

	HRESULT ProcessInstancePragma(IXMLDOMNode *pNode, LONG&lInstanceFlags,
	BSTR *pstrError);

	HRESULT ProcessNamespacePragma(IXMLDOMNode *pNode, BSTR &strNamespacePath,
	BSTR *pstrError);

	HRESULT ProcessDeletePragma(IXMLDOMNode *pNode, LPCWSTR pszNamespacePath, IWbemContext *pContext,
		BSTR *pstrError);

	void AddError(BSTR *pstrError, LPCWSTR pszFormat, ...);

protected:

	long            m_cRef;         //Object reference count

public:
    
    CXMLTransformer();
    ~CXMLTransformer(void);

    //Non-delegating object IUnknown
	//************************************
    STDMETHODIMP         QueryInterface(REFIID, LPVOID*);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

	// IDispatch methods
	//************************************
	STDMETHODIMP		GetTypeInfoCount(UINT* pctinfo);
    STDMETHODIMP		GetTypeInfo(UINT itinfo, LCID lcid, ITypeInfo** pptinfo);
    STDMETHODIMP		GetIDsOfNames(REFIID riid, OLECHAR** rgszNames, 
							UINT cNames, LCID lcid, DISPID* rgdispid);
    STDMETHODIMP		Invoke(DISPID dispidMember, REFIID riid, LCID lcid, 
							WORD wFlags, DISPPARAMS* pdispparams, VARIANT* pvarResult, 
									EXCEPINFO* pexcepinfo, UINT* puArgErr);

 
	// IWbemXMLTransformer methods
	//************************************
	HRESULT STDMETHODCALLTYPE	get_XMLEncodingType
		(
		/*[out]*/	WmiXMLEncoding *piEncoding
		)
	{
		if(piEncoding)
		{
			*piEncoding = m_iEncoding;
			return S_OK;
		}
		return WBEM_E_INVALID_PARAMETER;
	}

	HRESULT STDMETHODCALLTYPE	put_XMLEncodingType
		(
		/*[in]*/	WmiXMLEncoding iEncoding
		)
	{
		m_iEncoding = iEncoding;
		return S_OK;
	}

	HRESULT STDMETHODCALLTYPE get_QualifierFilter
		(
			/*[out]*/ VARIANT_BOOL *bQualifierFilter
		)
	{
		if(bQualifierFilter)
		{
			*bQualifierFilter = m_bQualifierFilter;
			return S_OK;
		}
		return WBEM_E_INVALID_PARAMETER;
	}

	HRESULT STDMETHODCALLTYPE put_QualifierFilter
		(
			/*[in]*/ VARIANT_BOOL bQualifierFilter
		)
	{
		m_bQualifierFilter = bQualifierFilter;
		return S_OK;
	}

	HRESULT STDMETHODCALLTYPE	get_ClassOriginFilter
		(
		/*[out]*/	VARIANT_BOOL *bClassOriginFilter
		)
	{
		if(bClassOriginFilter)
		{
			*bClassOriginFilter = m_bClassOriginFilter;
			return S_OK;
		}
		return WBEM_E_INVALID_PARAMETER;
	}

	HRESULT STDMETHODCALLTYPE	put_ClassOriginFilter
		(
		/*[in]*/	VARIANT_BOOL bClassOriginFilter
		)
	{
		m_bClassOriginFilter = bClassOriginFilter;
		return S_OK;	
	}

	HRESULT STDMETHODCALLTYPE	get_LocalOnly
		(
		/*[out]*/	VARIANT_BOOL *bLocalOnly
		)
	{
		if(bLocalOnly)
		{
			*bLocalOnly = m_bLocalOnly;
			return S_OK;
		}
		return WBEM_E_INVALID_PARAMETER;
	}

	HRESULT STDMETHODCALLTYPE	put_LocalOnly
		(
		/*[in]*/	VARIANT_BOOL bLocalOnly
		)
	{
		m_bLocalOnly = bLocalOnly;
		return S_OK;	
	}

	
	HRESULT STDMETHODCALLTYPE get_User( 
        /* [out][retval] */ BSTR __RPC_FAR *pstrUser);
        
	HRESULT STDMETHODCALLTYPE put_User( 
            /* [in] */ BSTR strUser);
        
    HRESULT STDMETHODCALLTYPE get_Password( 
            /* [out][retval] */ BSTR __RPC_FAR *pstrPassword);
        
    HRESULT STDMETHODCALLTYPE put_Password( 
            /* [in] */ BSTR strPassword);
        
    HRESULT STDMETHODCALLTYPE get_Authority( 
            /* [out][retval] */ BSTR __RPC_FAR *pstrAuthority);
        
    HRESULT STDMETHODCALLTYPE put_Authority( 
            /* [in] */ BSTR strAuthority);
        
    HRESULT STDMETHODCALLTYPE get_ImpersonationLevel( 
            /* [out][retval] */ DWORD __RPC_FAR *pdwImpersonationLevel)
	{
		if(pdwImpersonationLevel)
		{
			*pdwImpersonationLevel = m_dwImpersonationLevel;
			return S_OK;
		}
		return WBEM_E_INVALID_PARAMETER;
	}
        
    HRESULT STDMETHODCALLTYPE put_ImpersonationLevel( 
            /* [in] */ DWORD dwImpersonationLevel)
	{
		if(dwImpersonationLevel == RPC_C_IMP_LEVEL_DEFAULT||
			dwImpersonationLevel == RPC_C_IMP_LEVEL_ANONYMOUS||
			dwImpersonationLevel == RPC_C_IMP_LEVEL_IDENTIFY||
			dwImpersonationLevel == RPC_C_IMP_LEVEL_IMPERSONATE||
			dwImpersonationLevel == RPC_C_IMP_LEVEL_DELEGATE)
		{
			m_dwImpersonationLevel = dwImpersonationLevel;
			return S_OK;
		}
		return WBEM_E_INVALID_PARAMETER;
	}
        
    HRESULT STDMETHODCALLTYPE get_AuthenticationLevel( 
            /* [out][retval] */ DWORD __RPC_FAR *pdwAuthenticationLevel)
	{
		if(pdwAuthenticationLevel)
		{
			*pdwAuthenticationLevel = m_dwAuthenticationLevel;
			return S_OK;
		}
		return WBEM_E_INVALID_PARAMETER;
	}

        
    HRESULT STDMETHODCALLTYPE put_AuthenticationLevel( 
            /* [in] */ DWORD dwAuthenticationLevel)
	{
		if(dwAuthenticationLevel == RPC_C_AUTHN_LEVEL_DEFAULT||
			dwAuthenticationLevel == RPC_C_AUTHN_LEVEL_NONE||
			dwAuthenticationLevel == RPC_C_AUTHN_LEVEL_CONNECT||
			dwAuthenticationLevel == RPC_C_AUTHN_LEVEL_CALL||
			dwAuthenticationLevel == RPC_C_AUTHN_LEVEL_PKT||
			dwAuthenticationLevel == RPC_C_AUTHN_LEVEL_PKT_INTEGRITY||
			dwAuthenticationLevel == RPC_C_AUTHN_LEVEL_PKT_PRIVACY )
		{
			m_dwAuthenticationLevel = dwAuthenticationLevel;
			return S_OK;
		}
		return WBEM_E_INVALID_PARAMETER;
	}
        
    HRESULT STDMETHODCALLTYPE get_Locale( 
            /* [out][retval] */ BSTR __RPC_FAR *pstrLocale);
        
    HRESULT STDMETHODCALLTYPE put_Locale( 
            /* [in] */ BSTR strLocale);
        
    HRESULT STDMETHODCALLTYPE GetObject( 
            /* [in] */ BSTR strObjectPath,
			/* [in]	*/ IDispatch *pCtx,
            /* [retval][out] */ IXMLDOMDocument **ppXMLDocument);
        
    HRESULT STDMETHODCALLTYPE ExecQuery( 
            /* [in] */ BSTR strNamespacePath,
            /* [in] */ BSTR strQuery,
			/* [in] */ BSTR strQueryLanguage,
			/* [in]	*/ IDispatch *pCtx,
            /* [retval][out] */ ISWbemXMLDocumentSet **ppXMLDocumentSet);
        
    HRESULT STDMETHODCALLTYPE EnumClasses( 
            /* [in] */ BSTR strSuperClassPath,
            /* [in] */ VARIANT_BOOL bDeep,
			/* [in]	*/ IDispatch *pCtx,
            /* [retval][out] */ ISWbemXMLDocumentSet **ppXMLDocumentSet);
        
    HRESULT STDMETHODCALLTYPE EnumInstances( 
            /* [in] */ BSTR strClassPath,
            /* [in] */ VARIANT_BOOL bDeep,
			/* [in]	*/ IDispatch *pCtx,
            /* [retval][out] */ ISWbemXMLDocumentSet **ppXMLDocumentSet);
        
    HRESULT STDMETHODCALLTYPE EnumClassNames( 
            /* [in] */ BSTR strSuperClassPath,
            /* [in] */ VARIANT_BOOL bDeep,
			/* [in]	*/ IDispatch *pCtx,
            /* [retval][out] */ ISWbemXMLDocumentSet **ppXMLDocumentSet);
        
    HRESULT STDMETHODCALLTYPE EnumInstanceNames( 
            /* [in] */ BSTR strClassPath,
			/* [in]	*/ IDispatch *pCtx,
            /* [retval][out] */ ISWbemXMLDocumentSet **ppXMLDocumentSet);
        
    HRESULT STDMETHODCALLTYPE Compile( 
            /* [in] */ VARIANT *pInputSource,
			/* [in] */ BSTR strNamespacePath,
            /* [in] */ LONG lClassFlags,
            /* [in] */ LONG lInstanceFlags,
            /* [in] */ WmiXMLCompilationTypeEnum iOperation,
			/* [in]	*/ IDispatch *pCtx,
			/* [out]*/ VARIANT_BOOL *pStatus);

	HRESULT STDMETHODCALLTYPE get_Privileges (/*[out, retval] */ISWbemPrivilegeSet **objWbemPrivilegeSet);

	HRESULT STDMETHODCALLTYPE get_CompilationErrors (/*[out, retval] */BSTR *pstrErrors);


	// IObjectSafety methods
	//************************************
	HRESULT STDMETHODCALLTYPE SetInterfaceSafetyOptions
	(     
		/* [in] */ REFIID riid,
		/* [in] */ DWORD dwOptionSetMask,    
		/* [in] */ DWORD dwEnabledOptions
	)
	{ 
		return (dwOptionSetMask & dwEnabledOptions) ? E_FAIL : S_OK;
	}

	HRESULT  STDMETHODCALLTYPE GetInterfaceSafetyOptions( 
		/* [in]  */ REFIID riid,
		/* [out] */ DWORD __RPC_FAR *pdwSupportedOptions,
		/* [out] */ DWORD __RPC_FAR *pdwEnabledOptions
	)
	{ 
		if (pdwSupportedOptions) *pdwSupportedOptions = 0;
		if (pdwEnabledOptions) *pdwEnabledOptions = 0;
		return S_OK;
	}

	// ISupportErrorInfo methods
	//************************************
	HRESULT STDMETHODCALLTYPE InterfaceSupportsErrorInfo 
	(
		/* [in] */ REFIID riid
	)
	{
		return (IID_IWmiXMLTransformer == riid) ? S_OK : S_FALSE;
	}

};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\xmltransport\compiler\control\xmltransf\cxmltransf.cpp ===
//***************************************************************************
//
// Copyright (c) 1997-1999 Microsoft Corporation
//
//  WBEMXMLT.CPP
//
//  alanbos  15-Aug-96   Created.
//
//  Defines the implementation of IWbemXMLTransformer
//
//***************************************************************************
#include <tchar.h>
#include "precomp.h"
#include <map>
#include <vector>
#include <wmiutils.h>
#include <wbemdisp.h>
#include <ocidl.h>
#include "disphlp.h"
#include <objsafe.h>
#include <wbemcli.h>
#include <xmlparser.h>
#include <genlex.h>
#include <opathlex.h>
#include <objpath.h>

#include "wmiconv.h"
#include "wmi2xml.h"
#include "classfac.h"
#include "xmltrnsf.h"
#include "privilege.h"
#include "cxmltransf.h"
#include "XMLTransportClientHelper.h"
#include "XMLClientPacket.h"
#include "XMLClientPacketFactory.h"
#include "HTTPConnectionAgent.h"
#include "httpops.h"
#include "dcomops.h"
#include "myStream.h"
#include "MyPendingStream.h"
#include "nodefact.h"
#include "disphlp.h"
#include "docset.h"
#include "putfact.h"
#include "parse.h"
#include "dispi.h"
#include "helper.h"

LPCWSTR CXMLTransformer::s_pszXMLParseErrorMessage =
	L"Syntax Error in input at line(%d), position(%d) and source(\"%s\"). Reason is \"%s\"";


static BSTR MapHresultToWmiDescription (HRESULT hr);
static HRESULT PackageHTTPOutput(IStream *pOutputStream, IXMLDOMDocument **ppXMLDocument);
static HRESULT PackageHTTPOutputUsingFactory(IStream *pOutputStream, ISWbemXMLDocumentSet **ppSet, LPCWSTR pszElementName);
static HRESULT PackageDCOMOutputUsingEnumerator(IEnumWbemClassObject *pEnum,
												WmiXMLEncoding iEncoding,
												VARIANT_BOOL bIncludeQualifiers,
												VARIANT_BOOL bIncludeClassOrigin,
												VARIANT_BOOL bLocalOnly,
												ISWbemXMLDocumentSet **ppSet,
												bool bNamesOnly = false);

//***************************************************************************
//
//  CXMLTransformer::CXMLTransformer
//
//  DESCRIPTION:
//
//  Constructor.
//
//***************************************************************************

CXMLTransformer::CXMLTransformer()
{
	// Initialize members
	m_iEncoding = wmiXML_WMI_DTD_2_0;
	m_bQualifierFilter = VARIANT_FALSE; // No Qualifiers in output
	m_bClassOriginFilter = VARIANT_FALSE; // No class origin info
	m_bLocalOnly = VARIANT_TRUE; // Only local elements (methods and properties) in output
	m_strUser = NULL;
	m_strPassword = NULL;
	m_strAuthority = NULL;
	m_strLocale = NULL;
	m_dwImpersonationLevel = RPC_C_IMP_LEVEL_IMPERSONATE;
	m_dwAuthenticationLevel = RPC_C_AUTHN_LEVEL_DEFAULT;
	m_strCompilationErrors = NULL;
	m_cRef=0;
	InitializeCriticalSection (&m_cs);
	m_pITINeutral = NULL;
	m_hResult = S_OK;
    InterlockedIncrement(&g_cObj);
}

//***************************************************************************
//
//  CXMLTransformer::~CXMLTransformer
//
//  DESCRIPTION:
//
//  Destructor.
//
//***************************************************************************

CXMLTransformer::~CXMLTransformer(void)
{
    InterlockedDecrement(&g_cObj);

	if (m_pITINeutral)
		m_pITINeutral->Release ();

	EnterCriticalSection (&m_cs);
	SysFreeString(m_strUser);
	SysFreeString(m_strPassword);
	SysFreeString(m_strAuthority);
	SysFreeString(m_strLocale);
	SysFreeString(m_strCompilationErrors);
	LeaveCriticalSection (&m_cs);

	DeleteCriticalSection (&m_cs);
}

//***************************************************************************
// HRESULT CXMLTransformer::QueryInterface
// long CXMLTransformer::AddRef
// long CXMLTransformer::Release
//
// DESCRIPTION:
//
// Standard Com IUNKNOWN functions.
//
//***************************************************************************

STDMETHODIMP CXMLTransformer::QueryInterface (

	IN REFIID riid,
    OUT LPVOID *ppv
)
{
    *ppv=NULL;

    if (IID_IUnknown==riid)
		*ppv = reinterpret_cast<IUnknown*>(this);
	else if (IID_IWmiXMLTransformer==riid)
		*ppv = (IWmiXMLTransformer *)this;
	else if (IID_IDispatch==riid)
		*ppv = (IDispatch *)this;
	else if (IID_IObjectSafety==riid)
        *ppv = (IObjectSafety *)this;
	else if (IID_ISupportErrorInfo==riid)
		*ppv = (ISupportErrorInfo *)this;

    if (NULL!=*ppv)
    {
        ((LPUNKNOWN)*ppv)->AddRef();
        return NOERROR;
    }

    return ResultFromScode(E_NOINTERFACE);
}

STDMETHODIMP_(ULONG) CXMLTransformer::AddRef(void)
{
    InterlockedIncrement(&m_cRef);
    return m_cRef;
}

STDMETHODIMP_(ULONG) CXMLTransformer::Release(void)
{
    InterlockedDecrement(&m_cRef);
    if (0L!=m_cRef)
        return m_cRef;
    delete this;
    return 0;
}

//***************************************************************************
// HRESULT CXMLTransformer::GetTypeInfoCount
// HRESULT CXMLTransformer::GetTypeInfo
// HRESULT CXMLTransformer::GetIDsOfNames
// HRESULT CXMLTransformer::Invoke
//
//
// DESCRIPTION:
//
// Standard Com IDispatch functions.
//
//***************************************************************************

STDMETHODIMP CXMLTransformer::GetTypeInfoCount(UINT *pctInfo)
{
	*pctInfo = 1;
	return S_OK;
}

STDMETHODIMP CXMLTransformer:: GetTypeInfo(UINT itInfo, LCID lcid,
											ITypeInfo **ppITypeInfo)
{
	ITypeLib	*pITypeLib = NULL;
	ITypeInfo	**ppITI = NULL;

	if (0 != itInfo)
		return TYPE_E_ELEMENTNOTFOUND;

	if (NULL == ppITypeInfo)
		return E_POINTER;

	*ppITypeInfo = NULL;

	switch (PRIMARYLANGID(lcid))
	{
		case LANG_NEUTRAL:
		case LANG_ENGLISH:
			ppITI = &m_pITINeutral;
			break;

		default:
			return DISP_E_UNKNOWNLCID;
	}

	if (ppITI)
	{
		HRESULT		hr = E_FAIL;

		if (FAILED(hr = LoadRegTypeLib(LIBID_WmiXMLTransformer, 1, 0,
					PRIMARYLANGID(lcid), &pITypeLib)))
			hr = LoadTypeLib(OLESTR("xmltrnsf.tlb"), &pITypeLib);

		if (FAILED(hr))
			return hr;

		hr = pITypeLib->GetTypeInfoOfGuid (IID_IWmiXMLTransformer, ppITI);
		pITypeLib->Release ();

		if (FAILED(hr))
			return hr;
	}

	// Getting here means we have a real ITypeInfo to assign
	(*ppITI)->AddRef ();
	*ppITypeInfo = *ppITI;
	return S_OK;
}

STDMETHODIMP CXMLTransformer::GetIDsOfNames (REFIID riid,
				OLECHAR **rgszNames, UINT cNames, LCID lcid, DISPID *rgDispID)
{
	ITypeInfo	*pTI = NULL;

	if (IID_NULL != riid)
		return DISP_E_UNKNOWNINTERFACE;

	HRESULT	hr = GetTypeInfo (0, lcid, &pTI);

	if (SUCCEEDED(hr))
	{
		pTI->GetIDsOfNames (rgszNames, cNames, rgDispID);
		pTI->Release ();
	}

	return hr;
}

STDMETHODIMP CXMLTransformer::Invoke (DISPID dispID, REFIID riid,
				LCID lcid, unsigned short wFlags, DISPPARAMS *pDispParams,
				VARIANT *pVarResult, EXCEPINFO *pExcepInfo, UINT *puArgErr)
{
	ITypeInfo	*pTI = NULL;
	m_hResult = S_OK;

	if (IID_NULL != riid)
		return DISP_E_UNKNOWNINTERFACE;

	HRESULT hr = GetTypeInfo (0, lcid, &pTI);
	if (FAILED(hr))
		return hr;

	hr = pTI->Invoke (this, dispID, wFlags, pDispParams, pVarResult,
						pExcepInfo, puArgErr);

	pTI->Release ();

	if (FAILED(m_hResult))
	{
		if (NULL != pExcepInfo)
		{
			if (pExcepInfo->bstrDescription)
				SysFreeString (pExcepInfo->bstrDescription);

			pExcepInfo->bstrDescription = MapHresultToWmiDescription (m_hResult);

			if (pExcepInfo->bstrSource)
				SysFreeString (pExcepInfo->bstrSource);

			pExcepInfo->bstrSource = SysAllocString (L"XMLTransformer");
			pExcepInfo->scode = m_hResult;

			hr = DISP_E_EXCEPTION;
		}
	}

	return hr;
}

BSTR MapHresultToWmiDescription (HRESULT hr)
{
	BSTR bsMessageText = NULL;

	// Used as our error code translator
	IWbemStatusCodeText *pErrorCodeTransformer = NULL;

	HRESULT result = CoCreateInstance (CLSID_WbemStatusCodeText, 0, CLSCTX_INPROC_SERVER,
				IID_IWbemStatusCodeText, (LPVOID *) &pErrorCodeTransformer);

	if (SUCCEEDED (result))
	{
		pErrorCodeTransformer->GetErrorCodeText(hr, (LCID) 0, 0, &bsMessageText);
		pErrorCodeTransformer->Release ();
	}

	return bsMessageText;
}


//***************************************************************************
// HRESULT CXMLTransformer::get_User
// HRESULT CXMLTransformer::put_User
//
// DESCRIPTION:
//
// IWbemXMLTransformer methods for handling properties.
//
// Property Name			Function
//		User				User name used for authentication
//
//***************************************************************************

HRESULT CXMLTransformer::get_User (BSTR *pstrUser)
{
	HRESULT hr = WBEM_E_INVALID_PARAMETER;
	if (pstrUser)
	{
		*pstrUser = NULL;
		EnterCriticalSection (&m_cs);
		if (m_strUser)
		{
			*pstrUser = SysAllocString (m_strUser);
			if(*pstrUser)
				hr = S_OK;
			else
				hr = E_OUTOFMEMORY;
		}
		else
			hr = S_OK;
		LeaveCriticalSection (&m_cs);
	}
	return hr;

}

HRESULT CXMLTransformer::put_User (BSTR strUser)
{
	HRESULT hr = S_OK;

	EnterCriticalSection (&m_cs);
	if (m_strUser)
		SysFreeString (m_strUser);
	m_strUser = NULL;

	if(strUser)
	{
		m_strUser = SysAllocString (strUser);
		if(!m_strUser)
			hr = E_OUTOFMEMORY;
	}

	LeaveCriticalSection (&m_cs);

	return hr;
}
//***************************************************************************
// HRESULT CXMLTransformer::get_Password
// HRESULT CXMLTransformer::put_Password
//
// DESCRIPTION:
//
// IWbemXMLTransformer methods for handling properties.
//
// Property Name			Function
//		Password				Password used for authentication
//
//***************************************************************************

HRESULT CXMLTransformer::get_Password (BSTR *pstrPassword)
{
	HRESULT hr = WBEM_E_INVALID_PARAMETER;
	if (pstrPassword)
	{
		*pstrPassword = NULL;

		EnterCriticalSection (&m_cs);
		if (m_strPassword)
		{
			*pstrPassword = SysAllocString (m_strPassword);
			if(*pstrPassword)
				hr = S_OK;
			else
				hr = E_OUTOFMEMORY;
		}
		else
			hr = S_OK;
		LeaveCriticalSection (&m_cs);
	}
	return hr;
}

HRESULT CXMLTransformer::put_Password (BSTR strPassword)
{
	HRESULT hr = S_OK;
	EnterCriticalSection (&m_cs);
	if (m_strPassword)
		SysFreeString (m_strPassword);
	m_strPassword = NULL;
	if(strPassword)
	{
		m_strPassword = SysAllocString (strPassword);
		if(!m_strPassword)
			hr = E_OUTOFMEMORY;
	}
	LeaveCriticalSection (&m_cs);

	return hr;
}
//***************************************************************************
// HRESULT CXMLTransformer::get_Authority
// HRESULT CXMLTransformer::put_Authority
//
// DESCRIPTION:
//
// IWbemXMLTransformer methods for handling properties.
//
// Property Name			Function
//		Authority				Authority (domain/machine name) used for authentication
//
//***************************************************************************

HRESULT CXMLTransformer::get_Authority (BSTR *pstrAuthority)
{
	HRESULT hr = WBEM_E_INVALID_PARAMETER;
	if (pstrAuthority)
	{
		*pstrAuthority = NULL;
		if(m_strAuthority)
		{
			EnterCriticalSection (&m_cs);
			*pstrAuthority = SysAllocString (m_strAuthority);
			if(*pstrAuthority)
				hr = S_OK;
			else
				hr = E_OUTOFMEMORY;
			LeaveCriticalSection (&m_cs);
		}
		else
			hr = S_OK;
	}
	return hr;
}

HRESULT CXMLTransformer::put_Authority (BSTR strAuthority)
{
	HRESULT hr = S_OK;
	EnterCriticalSection (&m_cs);
	if (m_strAuthority)
		SysFreeString (m_strAuthority);
	m_strAuthority = NULL;
	if(strAuthority)
	{
		m_strAuthority = SysAllocString (strAuthority);
		if(!m_strAuthority)
			hr = E_OUTOFMEMORY;
	}
	LeaveCriticalSection (&m_cs);

	return hr;
}

//***************************************************************************
// HRESULT CXMLTransformer::get_Locale
// HRESULT CXMLTransformer::put_Locale
//
// DESCRIPTION:
//
// IWbemXMLTransformer methods for handling properties.
//
// Property Name			Function
//		Locale				Locale used for retreiving data
//
//***************************************************************************

HRESULT CXMLTransformer::get_Locale (BSTR *pstrLocale)
{
	HRESULT hr = WBEM_E_INVALID_PARAMETER;
	if (pstrLocale)
	{
		*pstrLocale = NULL;

		if(m_strLocale)
		{
			EnterCriticalSection (&m_cs);
			*pstrLocale = SysAllocString (m_strLocale);
			if(*pstrLocale)
				hr = S_OK;
			else
				hr = E_OUTOFMEMORY;
			LeaveCriticalSection (&m_cs);
		}
		else
			hr = S_OK;
	}
	return hr;
}

HRESULT CXMLTransformer::put_Locale (BSTR strLocale)
{
	HRESULT hr = S_OK;

	EnterCriticalSection (&m_cs);
	if (m_strLocale)
		SysFreeString (m_strLocale);
	m_strLocale = NULL;
	if(strLocale)
	{
		m_strLocale = SysAllocString (strLocale);
		if(!m_strLocale)
			hr = E_OUTOFMEMORY;
	}
	LeaveCriticalSection (&m_cs);

	return S_OK;
}

//***************************************************************************
//
//  SCODE CXMLTransformer::GetObject
//
//  DESCRIPTION:
//
//  Transforms a single WBEM object into its equivalent XML representation
//
//  PARAMETERS:
//
//		pszNamespacePath		The namespace path in which the object resides
//		pszObjectPath			The relative (model) path of the object within
//								that namespace
//		pXML					On successful return addresses the XML document.
//								The caller is responsible for freeing this BSTR
//								using SysFreeString.
//
//  RETURN VALUES:
//
//  WBEM_S_NO_ERROR				success, XML document is addressed by pXML
//	WBEM_E_INVALID_PARAMETER	bad input parameters
//  WBEM_E_FAILED				otherwise
//
//	Other WBEM error codes may be returned by ConnectServer etc., in which
//	case these are passed on to the caller.
//
//***************************************************************************

HRESULT CXMLTransformer::GetObject (
	BSTR strObjectPath,
	IDispatch *pCtx,
    IXMLDOMDocument **ppXMLDocument
)
{
	HRESULT hr = WBEM_E_FAILED;

	if (NULL == ppXMLDocument || NULL == strObjectPath)
		return WBEM_E_INVALID_PARAMETER;

	/*
	 * This call does a lot of things. Firstly, if we are on NT4.0 and are
	 * impersonating, then this call will fail unless the EnableForASP registry
	 * key is set. Otherwise, it sets the required privileges on the thread
	 * token from the data in the m_PrivilegeSet member
	 */
	bool needToResetSecurity = false;
	HANDLE hThreadToken = NULL;
	if (!CSWbemPrivilege::SetSecurity (&m_PrivilegeSet, needToResetSecurity, m_strUser != NULL, hThreadToken))
	{
		if (needToResetSecurity)
			CSWbemPrivilege::ResetSecurity (hThreadToken);
		return WBEM_E_FAILED;
	}

	// Convert the scriptable named value set to a context object
	IWbemContext *pContext = NULL;
	if(pCtx && FAILED(hr = GetIWbemContext(pCtx, &pContext)))
		return hr;

	// Parse the path to get a lot of details
	bool bIsClass = false;
	bool bIsNovaPath = true;
	bool bIsHTTP = true;
	LPWSTR pszHostNameOrURL = NULL, pszNamespacePath = NULL, pszObjectName = NULL;

	if(SUCCEEDED(hr = ParseObjectPath(strObjectPath, &pszHostNameOrURL, &pszNamespacePath, &pszObjectName, bIsClass, bIsHTTP, bIsNovaPath)))
	{
		if(pszObjectName && *pszObjectName)
		{
			// Try HTTP and/or DCOM
			if(bIsHTTP)
			{
				IStream *pOutputStream = NULL;
				if(SUCCEEDED(hr = HttpGetObject((LPCWSTR)m_strUser, (LPCWSTR)m_strPassword, 
					m_iEncoding, m_bQualifierFilter, m_bClassOriginFilter, m_bLocalOnly, (LPCWSTR)m_strLocale, 
					(LPCWSTR)strObjectPath, bIsNovaPath, 
					pszHostNameOrURL, pszNamespacePath, pszObjectName, bIsClass, pContext,
					&pOutputStream)))
				{
					// Post-process output
					hr = PackageHTTPOutput(pOutputStream, ppXMLDocument);
					pOutputStream->Release();
				}
			}
			else
			{
				BSTR strHostName = NULL; 
				BSTR strNamespacePath = NULL; 
				BSTR strObjectName = NULL;

				if(bIsNovaPath)
				{
					strHostName = SysAllocString(pszHostNameOrURL);
					strNamespacePath = SysAllocString(pszNamespacePath);
					strObjectName = SysAllocString(pszObjectName);

					if(!(strHostName && strNamespacePath && strObjectName))
						hr = E_OUTOFMEMORY;
				}

				if(SUCCEEDED(hr))
				{
					IWbemClassObject *pObject = NULL;
					// No need to pass the m_iEncoding, m_bQualifierFilter, m_bClassOriginFilter, m_schemaURL
					// and m_bLocalOnly here since we're using DCOM.
					// We can only post-process the result to support these flags
					if(SUCCEEDED(hr = DcomGetObject(m_strUser, m_strPassword,
							m_strLocale, m_strAuthority, strObjectPath, bIsNovaPath,
							m_dwImpersonationLevel, m_dwAuthenticationLevel, pContext,
							&pObject)))
					{
						// Post-process output
						hr = PackageDCOMOutput(pObject, ppXMLDocument, m_iEncoding, m_bQualifierFilter, m_bClassOriginFilter,
							m_bLocalOnly);
						pObject->Release();
					}
				}

				SysFreeString(strHostName);
				SysFreeString(strNamespacePath);
				SysFreeString(strObjectName);
			}
		}
		else
			hr = WBEM_E_INVALID_PARAMETER;

		delete [] pszHostNameOrURL;
		delete [] pszNamespacePath;
		delete [] pszObjectName;
	}

	if (needToResetSecurity)
		CSWbemPrivilege::ResetSecurity (hThreadToken);

	if(pContext)
		pContext->Release();

	if (FAILED(hr))
		m_hResult = hr;
	return hr;
}

//***************************************************************************
//
//  SCODE CXMLTransformer::ExecQuery
//
//  DESCRIPTION:
//
//  Transforms the query result set nto its equivalent XML representation
//
//  PARAMETERS:
//
//		pszNamespacePath		The namespace path in which the object resides.
//		pszQueryString			The query to execute within	that namespace.
//		pXML					On successful return addresses the XML document.
//								The caller is responsible for freeing this BSTR
//								using SysFreeString.
//
//  RETURN VALUES:
//
//  WBEM_S_NO_ERROR				success, XML document is addressed by pXML
//	WBEM_E_INVALID_PARAMETER	bad input parameters
//  WBEM_E_FAILED				otherwise
//
//	Other WBEM error codes may be returned by ConnectServer etc., in which
//	case these are passed on to the caller.
//
//***************************************************************************

HRESULT CXMLTransformer::ExecQuery (
	BSTR strNamespacePath,
	BSTR strQueryString,
	BSTR strQueryLanguage,
	IDispatch *pCtx,
    ISWbemXMLDocumentSet **ppXMLDocumentSet)
{
	HRESULT hr = WBEM_E_FAILED;

	if ((NULL == ppXMLDocumentSet) || (NULL == strNamespacePath) || 
		(NULL == strQueryString) || (NULL == strQueryLanguage))
		return WBEM_E_INVALID_PARAMETER;

	/*
	 * This call does a lot of things. Firstly, if we are on NT4.0 and are
	 * impersonating, then this call will fail unless the EnableForASP registry
	 * key is set. Otherwise, it sets the required privileges on the thread
	 * token from the data in the m_PrivilegeSet member
	 */
	bool needToResetSecurity = false;
	HANDLE hThreadToken = NULL;
	if (!CSWbemPrivilege::SetSecurity (&m_PrivilegeSet, needToResetSecurity, m_strUser != NULL, hThreadToken))
	{
		if (needToResetSecurity)
			CSWbemPrivilege::ResetSecurity (hThreadToken);
		return WBEM_E_FAILED;
	}

	// Convert the scriptable named value set to a context object
	IWbemContext *pContext = NULL;
	if(pCtx && FAILED(hr = GetIWbemContext(pCtx, &pContext)))
		return hr;

	// Parse the path to get a lot of details
	bool bIsClass = false;
	bool bIsNovaPath = true;
	bool bIsHTTP = true;
	LPWSTR pszHostNameOrURL = NULL, pszNamespace = NULL, pszObjectName = NULL;

	if(SUCCEEDED(hr = ParseObjectPath(strNamespacePath, &pszHostNameOrURL, &pszNamespace, &pszObjectName, bIsClass, bIsHTTP, bIsNovaPath)))
	{
		// Try HTTP and/or DCOM
		if(bIsHTTP)
		{
			IStream *pOutputStream = NULL;
			if(SUCCEEDED(hr = HttpExecQuery(
				(LPCWSTR)m_strUser, (LPCWSTR)m_strPassword,
				m_iEncoding, m_bQualifierFilter, m_bClassOriginFilter,
				(LPCWSTR)m_strLocale, (LPCWSTR)strNamespacePath, pszHostNameOrURL, pszNamespace, (LPCWSTR)strQueryString,
				(LPCWSTR)strQueryLanguage, pContext,
				&pOutputStream)))
			{
				// Post-process output
				hr = PackageHTTPOutputUsingFactory(pOutputStream, ppXMLDocumentSet, L"INSTANCE");
				pOutputStream->Release();
			}
		}
		else
		{
			BSTR strHostName = NULL; 
			BSTR strNamespace = NULL; 

			if(bIsNovaPath)
			{
				strHostName = SysAllocString(pszHostNameOrURL);
				strNamespace = SysAllocString(pszNamespace);

				if(!(strHostName && strNamespace))
					hr = E_OUTOFMEMORY;
			}

			if(SUCCEEDED(hr))
			{
				IEnumWbemClassObject *pEnum = NULL;
				if(SUCCEEDED(hr = DcomExecQuery(
					m_strUser, m_strPassword,
					m_strLocale, m_strAuthority, m_dwImpersonationLevel, m_dwAuthenticationLevel, 
					strNamespacePath, strQueryString, strQueryLanguage, pContext, 
					&pEnum)))
				{
					hr = PackageDCOMOutputUsingEnumerator(pEnum, m_iEncoding, m_bQualifierFilter, 
						m_bClassOriginFilter, m_bLocalOnly, ppXMLDocumentSet);
					pEnum->Release();
				}
			}

			SysFreeString(strHostName);
			SysFreeString(strNamespace);
		}
		delete [] pszHostNameOrURL;
		delete [] pszNamespace;
	}

	if (needToResetSecurity)
		CSWbemPrivilege::ResetSecurity (hThreadToken);

	if(pContext)
		pContext->Release();

	if (FAILED(hr))
		m_hResult = hr;

	return hr;
}


HRESULT STDMETHODCALLTYPE CXMLTransformer :: EnumClasses(
				BSTR strSuperClassPath,
    /* [in] */	VARIANT_BOOL bDeep,
	/* [in] */	IDispatch *pCtx,
				ISWbemXMLDocumentSet **ppXMLDocumentSet)
{
	HRESULT hr = WBEM_E_FAILED;

	if ((NULL == strSuperClassPath) || (NULL == ppXMLDocumentSet))
		return WBEM_E_INVALID_PARAMETER;

	/*
	 * This call does a lot of things. Firstly, if we are on NT4.0 and are
	 * impersonating, then this call will fail unless the EnableForASP registry
	 * key is set. Otherwise, it sets the required privileges on the thread
	 * token from the data in the m_PrivilegeSet member
	 */
	bool needToResetSecurity = false;
	HANDLE hThreadToken = NULL;
	if (!CSWbemPrivilege::SetSecurity (&m_PrivilegeSet, needToResetSecurity, m_strUser != NULL, hThreadToken))
	{
		if (needToResetSecurity)
			CSWbemPrivilege::ResetSecurity (hThreadToken);
		return WBEM_E_FAILED;
	}


	// Convert the scriptable named value set to a context object
	IWbemContext *pContext = NULL;
	if(pCtx && FAILED(hr = GetIWbemContext(pCtx, &pContext)))
		return hr;

	// Parse the path to get a lot of details
	bool bIsClass = false;
	bool bIsNovaPath = true;
	bool bIsHTTP = true;
	LPWSTR pszHostNameOrURL = NULL, pszNamespacePath = NULL, pszObjectName = NULL;

	if(SUCCEEDED(hr = ParseObjectPath(strSuperClassPath, &pszHostNameOrURL, &pszNamespacePath, &pszObjectName, bIsClass, bIsHTTP, bIsNovaPath)))
	{
		// Try HTTP and/or DCOM
		if(bIsHTTP)
		{
			IStream *pOutputStream = NULL;
			if(SUCCEEDED(hr = HttpEnumClass(
				(LPCWSTR)m_strUser, (LPCWSTR)m_strPassword,
				m_iEncoding, m_bQualifierFilter, m_bClassOriginFilter, m_bLocalOnly,
				(LPCWSTR)m_strLocale, (LPCWSTR)strSuperClassPath, pszHostNameOrURL, pszNamespacePath, pszObjectName,
				bDeep, pContext,
				&pOutputStream)))
			{
				// Post-process output
				hr = PackageHTTPOutputUsingFactory(pOutputStream, ppXMLDocumentSet, L"CLASS");
				pOutputStream->Release();
			}
		}
		else
		{
			BSTR strHostName = NULL; 
			BSTR strNamespacePath = NULL; 
			BSTR strObjectName = NULL;

			if(bIsNovaPath)
			{
				strHostName = SysAllocString(pszHostNameOrURL);
				strNamespacePath = SysAllocString(pszNamespacePath);
				strObjectName = SysAllocString(pszObjectName);

				if(!(strHostName && strNamespacePath))
					hr = E_OUTOFMEMORY;

				// EnumClass allows a NULL as the object name to enumerate all classes in a namespace
				if(pszObjectName && !strObjectName)
					hr = E_OUTOFMEMORY;
			}

			if(SUCCEEDED(hr))
			{
				IEnumWbemClassObject *pEnum = NULL;
				if(SUCCEEDED(hr = DcomEnumClass(
					m_strUser, m_strPassword,
					m_strLocale, m_strAuthority, m_dwImpersonationLevel, m_dwAuthenticationLevel, 
					strSuperClassPath, bDeep, pContext,
					&pEnum)))
				{
					hr = PackageDCOMOutputUsingEnumerator(pEnum, m_iEncoding, m_bQualifierFilter, m_bClassOriginFilter,
						m_bLocalOnly, ppXMLDocumentSet);
					pEnum->Release();
				}
			}

			SysFreeString(strHostName);
			SysFreeString(strNamespacePath);
			SysFreeString(strObjectName);
		}
		delete [] pszHostNameOrURL;
		delete [] pszNamespacePath;
		delete [] pszObjectName;
	}

	if (needToResetSecurity)
		CSWbemPrivilege::ResetSecurity (hThreadToken);

	if(pContext)
		pContext->Release();

	if (FAILED(hr))
		m_hResult = hr;

	return hr;
}

HRESULT STDMETHODCALLTYPE CXMLTransformer :: EnumInstances(
    /* [in] */ BSTR strClassPath,
    /* [in] */ VARIANT_BOOL bDeep,
	/* [in] */IDispatch *pCtx,
    ISWbemXMLDocumentSet **ppXMLDocumentSet)
{
	HRESULT hr = WBEM_E_FAILED;

	if ((NULL == ppXMLDocumentSet) || (NULL == strClassPath))
		return WBEM_E_INVALID_PARAMETER;

	/*
	 * This call does a lot of things. Firstly, if we are on NT4.0 and are
	 * impersonating, then this call will fail unless the EnableForASP registry
	 * key is set. Otherwise, it sets the required privileges on the thread
	 * token from the data in the m_PrivilegeSet member
	 */
	bool needToResetSecurity = false;
	HANDLE hThreadToken = NULL;
	if (!CSWbemPrivilege::SetSecurity (&m_PrivilegeSet, needToResetSecurity, m_strUser != NULL, hThreadToken))
	{
		if (needToResetSecurity)
			CSWbemPrivilege::ResetSecurity (hThreadToken);
		return WBEM_E_FAILED;
	}

	// Convert the scriptable named value set to a context object
	IWbemContext *pContext = NULL;
	if(pCtx && FAILED(hr = GetIWbemContext(pCtx, &pContext)))
		return hr;

	// Parse the path to get a lot of details
	bool bIsClass = false;
	bool bIsNovaPath = true;
	bool bIsHTTP = true;
	LPWSTR pszHostNameOrURL = NULL, pszNamespacePath = NULL, pszObjectName = NULL;

	if(SUCCEEDED(hr = ParseObjectPath(strClassPath, &pszHostNameOrURL, &pszNamespacePath, &pszObjectName, bIsClass, bIsHTTP, bIsNovaPath)))
	{
		if(pszObjectName && *pszObjectName)
		{
			// Try HTTP and/or DCOM
			if(bIsHTTP)
			{
				IStream *pOutputStream = NULL;
				if(SUCCEEDED(hr = HttpEnumInstance(
					(LPCWSTR)m_strUser, (LPCWSTR)m_strPassword,
					m_iEncoding, m_bQualifierFilter, m_bClassOriginFilter, m_bLocalOnly,
					(LPCWSTR)m_strLocale, (LPCWSTR)strClassPath, pszHostNameOrURL, pszNamespacePath, pszObjectName,
					bDeep, pContext,
					&pOutputStream)))
				{
					// Post-process output
					hr = PackageHTTPOutputUsingFactory(pOutputStream, ppXMLDocumentSet, L"VALUE.NAMEDINSTANCE");
					pOutputStream->Release();
				}
			}
			else
			{
				BSTR strHostName = NULL; 
				BSTR strNamespacePath = NULL; 
				BSTR strObjectName = NULL;

				if(bIsNovaPath)
				{
					strHostName = SysAllocString(pszHostNameOrURL);
					strNamespacePath = SysAllocString(pszNamespacePath);
					strObjectName = SysAllocString(pszObjectName);

					if(!(strHostName && strNamespacePath && strObjectName))
						hr = E_OUTOFMEMORY;
				}

				if(SUCCEEDED(hr))
				{
					IEnumWbemClassObject *pEnum = NULL;
					if(SUCCEEDED(hr = DcomEnumInstance(
						m_strUser, m_strPassword,
						m_strLocale, m_strAuthority, m_dwImpersonationLevel, m_dwAuthenticationLevel, 
						strClassPath, bDeep, pContext,
						&pEnum)))
					{
						hr = PackageDCOMOutputUsingEnumerator(pEnum, m_iEncoding, m_bQualifierFilter, m_bClassOriginFilter,
							m_bLocalOnly, ppXMLDocumentSet);
						pEnum->Release();
					}
					SysFreeString(strHostName);
					SysFreeString(strNamespacePath);
					SysFreeString(strObjectName);
				}
			}
		}
		else
			hr = WBEM_E_INVALID_PARAMETER;

		delete [] pszHostNameOrURL;
		delete [] pszNamespacePath;
		delete [] pszObjectName;
	}

	if (needToResetSecurity)
		CSWbemPrivilege::ResetSecurity (hThreadToken);

	if(pContext)
		pContext->Release();

	if (FAILED(hr))
		m_hResult = hr;

	return hr;
}

HRESULT STDMETHODCALLTYPE CXMLTransformer :: EnumClassNames(
        /* [in] */ BSTR strSuperClassPath,
        /* [in] */ VARIANT_BOOL bDeep,
		/* [in] */IDispatch *pCtx,
    ISWbemXMLDocumentSet **ppXMLDocumentSet)
{
	HRESULT hr = WBEM_E_FAILED;

	if ((NULL == strSuperClassPath) || (NULL == ppXMLDocumentSet) )
		return WBEM_E_INVALID_PARAMETER;

	/*
	 * This call does a lot of things. Firstly, if we are on NT4.0 and are
	 * impersonating, then this call will fail unless the EnableForASP registry
	 * key is set. Otherwise, it sets the required privileges on the thread
	 * token from the data in the m_PrivilegeSet member
	 */
	bool needToResetSecurity = false;
	HANDLE hThreadToken = NULL;
	if (!CSWbemPrivilege::SetSecurity (&m_PrivilegeSet, needToResetSecurity, m_strUser != NULL, hThreadToken))
	{
		if (needToResetSecurity)
			CSWbemPrivilege::ResetSecurity (hThreadToken);
		return WBEM_E_FAILED;
	}

	// Convert the scriptable named value set to a context object
	IWbemContext *pContext = NULL;
	if(pCtx && FAILED(hr = GetIWbemContext(pCtx, &pContext)))
		return hr;

	// Parse the path to get a lot of details
	bool bIsClass = false;
	bool bIsNovaPath = true;
	bool bIsHTTP = true;
	LPWSTR pszHostNameOrURL = NULL, pszNamespacePath = NULL, pszObjectName = NULL;

	if(SUCCEEDED(hr = ParseObjectPath(strSuperClassPath, &pszHostNameOrURL, &pszNamespacePath, &pszObjectName, bIsClass, bIsHTTP, bIsNovaPath)))
	{
		// Try HTTP and/or DCOM
		if(bIsHTTP)
		{
			IStream *pOutputStream = NULL;
			if(SUCCEEDED(hr = HttpEnumClassNames(
					(LPCWSTR)m_strUser, (LPCWSTR)m_strPassword,
					m_iEncoding,
					(LPCWSTR)m_strLocale, (LPCWSTR)strSuperClassPath, pszHostNameOrURL, pszNamespacePath, pszObjectName,
					bDeep, pContext,
					&pOutputStream)))
			{
				// Post-process output
				hr = PackageHTTPOutputUsingFactory(pOutputStream, ppXMLDocumentSet, L"CLASSNAME");
				pOutputStream->Release();
			}
		}
		else
		{
			BSTR strHostName = NULL; 
			BSTR strNamespacePath = NULL; 
			BSTR strObjectName = NULL;

			if(bIsNovaPath)
			{
				strHostName = SysAllocString(pszHostNameOrURL);
				strNamespacePath = SysAllocString(pszNamespacePath);
				strObjectName = SysAllocString(pszObjectName);

				if(!(strHostName && strNamespacePath ))
					hr = E_OUTOFMEMORY;

				// EnumClass allows a NULL as the object name to enumerate all classes in a namespace
				if(pszObjectName && !strObjectName)
					hr = E_OUTOFMEMORY;
			}

			if(SUCCEEDED(hr))
			{
				IEnumWbemClassObject *pEnum = NULL;
				if(SUCCEEDED(hr = DcomEnumClassNames(
					m_strUser, m_strPassword,
					m_strLocale, m_strAuthority, m_dwImpersonationLevel, m_dwAuthenticationLevel, 
					strSuperClassPath, bDeep, pContext,
					&pEnum)))
				{
					hr = PackageDCOMOutputUsingEnumerator(pEnum, m_iEncoding, m_bQualifierFilter, m_bClassOriginFilter,
						m_bLocalOnly, ppXMLDocumentSet, true);
					pEnum->Release();
				}
				SysFreeString(strHostName);
				SysFreeString(strNamespacePath);
				SysFreeString(strObjectName);
			}
		}
		delete [] pszHostNameOrURL;
		delete [] pszNamespacePath;
		delete [] pszObjectName;
	}

	if (needToResetSecurity)
		CSWbemPrivilege::ResetSecurity (hThreadToken);

	if(pContext)
		pContext->Release();

	if (FAILED(hr))
		m_hResult = hr;

	return hr;
}

HRESULT STDMETHODCALLTYPE CXMLTransformer :: EnumInstanceNames(
        /* [in] */ BSTR strClassPath,
		/* [in] */IDispatch *pCtx,
    ISWbemXMLDocumentSet **ppXMLDocumentSet)
{
	HRESULT hr = WBEM_E_FAILED;

	if ((NULL == strClassPath) || (NULL == ppXMLDocumentSet))
		return WBEM_E_INVALID_PARAMETER;

	/*
	 * This call does a lot of things. Firstly, if we are on NT4.0 and are
	 * impersonating, then this call will fail unless the EnableForASP registry
	 * key is set. Otherwise, it sets the required privileges on the thread
	 * token from the data in the m_PrivilegeSet member
	 */
	bool needToResetSecurity = false;
	HANDLE hThreadToken = NULL;
	if (!CSWbemPrivilege::SetSecurity (&m_PrivilegeSet, needToResetSecurity, m_strUser != NULL, hThreadToken))
	{
		if (needToResetSecurity)
			CSWbemPrivilege::ResetSecurity (hThreadToken);
		return WBEM_E_FAILED;
	}

	// Convert the scriptable named value set to a context object
	IWbemContext *pContext = NULL;
	if(pCtx && FAILED(hr = GetIWbemContext(pCtx, &pContext)))
		return hr;

	// Parse the path to get a lot of details
	bool bIsClass = false;
	bool bIsNovaPath = true;
	bool bIsHTTP = true;
	LPWSTR pszHostNameOrURL = NULL, pszNamespacePath = NULL, pszObjectName = NULL;

	if(SUCCEEDED(hr = ParseObjectPath(strClassPath, &pszHostNameOrURL, &pszNamespacePath, &pszObjectName, bIsClass, bIsHTTP, bIsNovaPath)))
	{
		if(pszObjectName && *pszObjectName)
		{
			// Try HTTP and/or DCOM
			if(bIsHTTP)
			{
				IStream *pOutputStream = NULL;
				if(SUCCEEDED(hr = HttpEnumInstanceNames(
						(LPCWSTR)m_strUser, (LPCWSTR)m_strPassword,
						m_iEncoding,
						(LPCWSTR)m_strLocale, (LPCWSTR)strClassPath, pszHostNameOrURL, pszNamespacePath, pszObjectName, pContext,
						&pOutputStream)))
				{
					// Post-process output
					hr = PackageHTTPOutputUsingFactory(pOutputStream, ppXMLDocumentSet, L"CLASSNAME");
					pOutputStream->Release();
				}
			}
			else
			{
				BSTR strHostName = NULL; 
				BSTR strNamespacePath = NULL; 
				BSTR strObjectName = NULL;

				if(bIsNovaPath)
				{
					strHostName = SysAllocString(pszHostNameOrURL);
					strNamespacePath = SysAllocString(pszNamespacePath);
					strObjectName = SysAllocString(pszObjectName);

					if(!(strHostName && strNamespacePath && strObjectName))
						hr = E_OUTOFMEMORY;
				}

				if(SUCCEEDED(hr))
				{
					IEnumWbemClassObject *pEnum = NULL;
					if(SUCCEEDED(hr = DcomEnumInstanceNames(
						m_strUser, m_strPassword,
						m_strLocale, m_strAuthority, m_dwImpersonationLevel, m_dwAuthenticationLevel, 
						strClassPath, pContext, 
						&pEnum)))
					{
						hr = PackageDCOMOutputUsingEnumerator(pEnum, m_iEncoding, m_bQualifierFilter, m_bClassOriginFilter,
							m_bLocalOnly, ppXMLDocumentSet);
						pEnum->Release();
					}
					SysFreeString(strHostName);
					SysFreeString(strNamespacePath);
					SysFreeString(strObjectName);
				}
			}
		}
		else
			hr = WBEM_E_INVALID_PARAMETER;

		delete [] pszHostNameOrURL;
		delete [] pszNamespacePath;
		delete [] pszObjectName;
	}

	if (needToResetSecurity)
		CSWbemPrivilege::ResetSecurity (hThreadToken);

	if(pContext)
		pContext->Release();

	if (FAILED(hr))
		m_hResult = hr;

	return hr;
}

HRESULT STDMETHODCALLTYPE CXMLTransformer :: get_CompilationErrors (/*[out, retval] */BSTR *pstrErrors)
{
	HRESULT hr = S_OK;
	if(m_strCompilationErrors)
	{
		*pstrErrors = NULL;
		if(!(*pstrErrors = SysAllocString(m_strCompilationErrors)))
			hr = E_OUTOFMEMORY;
	}
	return hr;
}

HRESULT STDMETHODCALLTYPE CXMLTransformer :: Compile(
        /* [in] */ VARIANT *pvInputSource,
        /* [in] */ BSTR strNamespacePath,
        /* [in] */ LONG lClassFlags,
        /* [in] */ LONG lInstanceFlags,
        /* [in] */ WmiXMLCompilationTypeEnum iOperation,
		/* [in] */ IDispatch *pCtx,
		/* [out]*/ VARIANT_BOOL *pStatus)
{
	HRESULT hr = E_FAIL;

	// Clear any existing compilation error
	SysFreeString(m_strCompilationErrors);
	m_strCompilationErrors = NULL;

	if(!pvInputSource || (NULL == strNamespacePath) || (NULL == pStatus))
		return WBEM_E_INVALID_PARAMETER;

	/*
	 * This call does a lot of things. Firstly, if we are on NT4.0 and are
	 * impersonating, then this call will fail unless the EnableForASP registry
	 * key is set. Otherwise, it sets the required privileges on the thread
	 * token from the data in the m_PrivilegeSet member
	 */
	bool needToResetSecurity = false;
	HANDLE hThreadToken = NULL;
	if (!CSWbemPrivilege::SetSecurity (&m_PrivilegeSet, needToResetSecurity, m_strUser != NULL, hThreadToken))
	{
		if (needToResetSecurity)
			CSWbemPrivilege::ResetSecurity (hThreadToken);
		return WBEM_E_FAILED;
	}

	// See if we just need to do Syntax Checking
	switch(iOperation)
	{
		case WmiXMLCompilationWellFormCheck:
		{
			IXMLDOMDocument *pDoc = NULL;
			DoWellFormCheck(pvInputSource, pStatus, &m_strCompilationErrors, false, &pDoc);
			if(pDoc)
				pDoc->Release();
			return S_OK;
		}
		case WmiXMLCompilationValidityCheck:
		{
			IXMLDOMDocument *pDoc = NULL;
			DoWellFormCheck(pvInputSource, pStatus, &m_strCompilationErrors, true, &pDoc);
			if(pDoc)
				pDoc->Release();
			return S_OK;
		}
		case WmiXMLCompilationFullCompileAndLoad:
		{
			// Convert the scriptable named value set to a context object
			IWbemContext *pContext = NULL;
			if(pCtx && FAILED(hr = GetIWbemContext(pCtx, &pContext)))
				return hr;
			if(pvInputSource->vt == VT_BSTR)
				hr = CompileString(pvInputSource, strNamespacePath, lClassFlags, lInstanceFlags, pContext, &m_strCompilationErrors);
			else if(pvInputSource->vt == VT_UNKNOWN)
				hr = CompileStream(pvInputSource, strNamespacePath, lClassFlags, lInstanceFlags, pContext, &m_strCompilationErrors);
			else
				hr = WBEM_E_INVALID_PARAMETER;

			if(pContext)
				pContext->Release();
		}
	}

	if (needToResetSecurity)
		CSWbemPrivilege::ResetSecurity (hThreadToken);

	if(FAILED(hr))
	{
		*pStatus = VARIANT_FALSE;
		hr = S_OK;
	}
	else
		*pStatus = VARIANT_TRUE;
	return hr;
}

HRESULT STDMETHODCALLTYPE CXMLTransformer :: get_Privileges (/*[out, retval] */ISWbemPrivilegeSet **objWbemPrivilegeSet)
{
	HRESULT hr = WBEM_E_FAILED;

	if (NULL == objWbemPrivilegeSet)
		hr = WBEM_E_INVALID_PARAMETER;
	else
	{
		*objWbemPrivilegeSet = NULL;
		if (SUCCEEDED (m_PrivilegeSet.QueryInterface (IID_ISWbemPrivilegeSet, (LPVOID *) objWbemPrivilegeSet)))
			hr = WBEM_S_NO_ERROR;
	}
		
	return hr;
}


HRESULT STDMETHODCALLTYPE CXMLTransformer :: DoWellFormCheck(
			VARIANT *pvInputSource, 
			VARIANT_BOOL *pStatus, 
			BSTR *pstrError, 
			bool bCheckForValidity, 
			IXMLDOMDocument **pDoc)
{
	HRESULT hr = E_FAIL;
	// No need to use the factory
	// Create DOM Document using the variant
	//==============================
	*pDoc = NULL;
	*pstrError = NULL;
	if(SUCCEEDED(hr = CreateXMLDocument(pDoc)))
	{
		if(pvInputSource->vt == VT_UNKNOWN)
			hr = (*pDoc)->load(*pvInputSource, pStatus);
		else
			hr = (*pDoc)->loadXML(pvInputSource->bstrVal, pStatus);

		if(SUCCEEDED(hr))
		{
			if(*pStatus != VARIANT_TRUE)
			// Create an Error Message
			{
				IXMLDOMParseError *pError = NULL;
				if(SUCCEEDED((*pDoc)->get_parseError(&pError)))
				{
					LONG errorCode = 0;
					pError->get_errorCode(&errorCode);
					LONG line=0, linepos=0;
					BSTR reason=NULL, srcText = NULL;
					if(SUCCEEDED(pError->get_line(&line)) &&
						SUCCEEDED(pError->get_linepos(&linepos)) &&
						SUCCEEDED(pError->get_reason(&reason)) &&
						SUCCEEDED(pError->get_srcText(&srcText)))
					{
						LPWSTR pszError = NULL;
						if(pszError = new WCHAR[wcslen(s_pszXMLParseErrorMessage) +
							8 + 8 + 
							((reason) ? wcslen(reason):0) + 
							((srcText)? wcslen(srcText):0) + 1])
						{
							wsprintf(pszError, s_pszXMLParseErrorMessage, line, linepos, 
								((srcText)? srcText : L""), 
								((reason)? reason : L""));
							if(!(*pstrError = SysAllocString(pszError)))
								hr = E_OUTOFMEMORY;

							delete [] pszError;
						}
						hr = WBEM_E_INVALID_PARAMETER;
					}
					pError->Release();
					if(reason)
						SysFreeString(reason);
					if(srcText)
						SysFreeString(srcText);
				}
			}
		}
	}
	return hr;
}

HRESULT STDMETHODCALLTYPE CXMLTransformer :: CompileString(
        /* [in] */ VARIANT *pvInputSource,
        /* [in] */ BSTR strNamespacePath,
        /* [in] */ LONG lClassFlags,
        /* [in] */ LONG lInstanceFlags,
		/* [in] */ IWbemContext *pContext,
        /* [out]*/ BSTR *pstrError)
{
	HRESULT hr = E_FAIL;
	// No need to use the factory
	// Create DOM Document using the variant
	//==============================
	IXMLDOMDocument *pDoc = NULL;
	VARIANT_BOOL bStatus = VARIANT_TRUE;
	if(SUCCEEDED(hr = DoWellFormCheck(pvInputSource, &bStatus, pstrError, false, &pDoc)))
	{
		if(bStatus == VARIANT_TRUE)
			hr = CompileDocument(pDoc, strNamespacePath, lClassFlags, lInstanceFlags, pContext, pstrError);
		else
			hr = E_FAIL;
		if(pDoc)
			pDoc->Release();
	}
	return hr;
}

HRESULT STDMETHODCALLTYPE CXMLTransformer :: CompileStream(
        /* [in] */ VARIANT *pvInputSource,
        /* [in] */ BSTR strNamespacePath,
        /* [in] */ LONG lClassFlags,
        /* [in] */ LONG lInstanceFlags,
		/* [in] */ IWbemContext *pContext,
        /* [out]*/ BSTR *pstrError)
{
	HRESULT hr = E_FAIL;

	// Create a Pending Stream
	CMyPendingStream *pMyStream = NULL;
	if(pMyStream = new CMyPendingStream((IStream *)pvInputSource->punkVal))
	{
		IXMLParser *pParser = NULL;
		if(SUCCEEDED(hr = CoCreateInstance(CLSID_XMLParser, NULL, CLSCTX_INPROC_SERVER,
			IID_IXMLParser,  (LPVOID *)&pParser)))
		{
			if(SUCCEEDED(hr = pParser->SetInput(pMyStream)))
			{
				CCompileFactory *pFactory = NULL;
				if(pFactory = new CCompileFactory(pMyStream))
				{
					if(SUCCEEDED(hr = pParser->SetFactory(pFactory)))
					{
						HRESULT hParse = E_FAIL;
						while((SUCCEEDED(hParse = pParser->Run(-1)) || hParse == E_PENDING))
						{
							// We will be getting a Document with a VALUE.OBJECT or a VALUE.NAMEDOBJECT or a VALUE.OBJECTWITHLOCALPATH or VALUE.OBJECTWITHPATH
							// or an XML PI for pragmas in it
							IXMLDOMDocument *pValue = NULL;
							if(SUCCEEDED(pFactory->GetDocument(&pValue)))
							{
								IXMLDOMElement *pTopElement = NULL;
								if(SUCCEEDED(hr = pValue->get_documentElement(&pTopElement)))
								{
									// Get the name of the element
									BSTR strElementName = NULL;
									if(SUCCEEDED(pTopElement->get_nodeName(&strElementName)))
									{
										if(_wcsicmp(strElementName, L"VALUE.OBJECT") == 0)
										{
											// See if there is CLASS or INSTANCE child
											IXMLDOMElement *pObjectElement = NULL;
											if(FAILED(hr = GetFirstImmediateElement(pTopElement, &pObjectElement, L"CLASS")))
												hr = GetFirstImmediateElement(pTopElement, &pObjectElement, L"INSTANCE");

											if(pObjectElement)
											{
												hr = PutObject(pObjectElement, strNamespacePath, lClassFlags, lInstanceFlags, pContext);
												pObjectElement->Release();
											}
										}
										else if(_wcsicmp(strElementName, L"VALUE.NAMEDOBJECT") == 0)
										{
										}
										else if(_wcsicmp(strElementName, L"VALUE.OBJECTWITHLOCALPATH") == 0)
										{
										}
										else if(_wcsicmp(strElementName, L"VALUE.OBJECTWITHPATH") == 0)
										{
										}
										SysFreeString(strElementName);
									}
									pTopElement->Release();
								}
								pValue->Release();
							}
						}
					}
					pFactory->Release();
				}
				else
					hr = E_OUTOFMEMORY;
			}
			pParser->Release();
		}
		pMyStream->Release();
	}
	else
		hr = E_OUTOFMEMORY;
	return hr;
}



//***************************************************************************
//
//  HRESULT CXMLTransformer::SaveStreamAsBSTR
//
//  DESCRIPTION:
//
//  Returns the stream contents as a single BSTR
//
//  PARAMETERS:
//
//		pOutputStream			The stream from which the stream is to be extracted.
//		pBstr			Addresses the BSTR to hold the extracted string.  If
//						allocated by this function the caller must call
//						SysFreeString to release the mempory.
//
//  RETURN VALUES:
//
//  WBEM_S_NO_ERROR				success, pBstr contains the extracted text
//  WBEM_E_FAILED				otherwise
//
//***************************************************************************

HRESULT CXMLTransformer::SaveStreamAsBSTR (IStream *pOutputStream, BSTR *pBstr)
{
	HRESULT hr = WBEM_E_FAILED;

	/*
	FILE *outputFile = fopen( "//xml.htm", "w");
	if(!outputFile)
		return WBEM_E_FAILED;
	*/


	// Write the XML into the supplied BSTR

	STATSTG statstg;
	if (SUCCEEDED(pOutputStream->Stat(&statstg, STATFLAG_NONAME)))
	{
		ULONG cbSize = (statstg.cbSize).LowPart;
		OLECHAR *pText = NULL;
		pText= new OLECHAR [(cbSize/2) + 1];

		if(pText)
		{
			if (SUCCEEDED(pOutputStream->Read(pText, cbSize, NULL)))
			{
				// Terminate the string
				pText [cbSize/2] = NULL;

				// The following must be freed by the caller using SysFreeString
				*pBstr = SysAllocStringLen (pText, cbSize/2);
				delete [] pText;
				hr = WBEM_S_NO_ERROR;
			}
		}
		else
			return E_OUTOFMEMORY;
	}

	// fclose(outputFile);

	return hr;
}

static HRESULT PackageHTTPOutput(IStream *pOutputStream, IXMLDOMDocument **ppXMLDocument)
{
	HRESULT hr = E_FAIL;
	*ppXMLDocument = NULL;

	// Parse the response that we got from the server
	//=============================================================
	HRESULT hWMIError = S_OK;
	IXMLDOMDocument *pTemp = NULL;
	if(SUCCEEDED(hr = ParseXMLResponsePacket(pOutputStream, &pTemp, &hWMIError)))
	{
		// See if we got a CIM error in the response
		if(FAILED(hWMIError))
			hr = hWMIError;
		else
		{
			// The pTemp argument should contain the entire response now
			
			// Get the IRETURNVALUE elements list
			IXMLDOMNodeList *pXMLDomNodeList = NULL;
			if(SUCCEEDED(hr = pTemp->getElementsByTagName(WMI_XML_STR_IRETURN_VALUE, &pXMLDomNodeList)) && pXMLDomNodeList)
			{
				// Get the first IRETURNVALUE element in the list
				IXMLDOMNode	*pXMLDomNode = NULL;
				if(SUCCEEDED(hr = pXMLDomNodeList->nextNode(&pXMLDomNode)) && pXMLDomNode)
				{
					// Get the child of the IRETURNVALUE
					// This will be CLASS OR INSTANCE OR VALUE.NAMEDINSTANCE
					IXMLDOMNode	*pXMLDomNodeTemp = NULL;
					if(SUCCEEDED(hr = pXMLDomNode->get_firstChild(&pXMLDomNodeTemp)) && pXMLDomNodeTemp)
					{
						// Get the CLASS or INSTANCE from the IRETURNVALUE
						IXMLDOMNode	*pXMLDomNodeChild = NULL;
						if(SUCCEEDED(hr = Parse_IRETURNVALUE_Node(pXMLDomNodeTemp, &pXMLDomNodeChild)))
						{
							IXMLDOMElement *pTopElement = NULL;
							if(SUCCEEDED(pXMLDomNodeChild->QueryInterface(IID_IXMLDOMElement, (LPVOID *)&pTopElement)))
							{
								// We need to create an XML DOM Document with just this one node (CLASS or INSTANCE) 
								// in it. Hence you need to delete the top level element
								if(SUCCEEDED(hr = pTemp->putref_documentElement(pTopElement)))
								{	
									*ppXMLDocument = pTemp;
									pTemp->AddRef();
								}
								pTopElement->Release();
							}
							pXMLDomNodeChild->Release();
						}
						pXMLDomNodeTemp->Release();
					}
					pXMLDomNode->Release();
				}
				pXMLDomNodeList->Release();
			}
		}
		pTemp->Release();
	}
	return hr;
}

static HRESULT PackageHTTPOutputUsingFactory(IStream *pOutputStream, ISWbemXMLDocumentSet **ppSet, LPCWSTR pszElementName)
{
	HRESULT hr = E_FAIL;
	*ppSet = NULL;
	CWbemXMLHTTPDocSet *pSet = NULL;
	if(pSet = new CWbemXMLHTTPDocSet())
	{
		// Set which kind of elements we want to be manufactured.
		if(SUCCEEDED(hr = pSet->Initialize(pOutputStream, &pszElementName, 1)))
		{
			*ppSet = pSet;
		}
		else
			delete pSet;
	}
	else
		hr = E_OUTOFMEMORY;
	return hr;
}

HRESULT CXMLTransformer::CompileDocument (
	IXMLDOMDocument *pDocument,
    BSTR strNamespacePath,
    LONG lClassFlags,
    LONG lInstanceFlags,
	IWbemContext *pContext,
	BSTR *pstrError)
{
	// This should be a CIM Document with a DECLGROUP
	// We look for CLASS or INSTANCE in the DECLGROUP

	IXMLDOMElement *pTopElement = NULL;
	HRESULT hr = E_FAIL;
	if(SUCCEEDED(hr = pDocument->get_documentElement(&pTopElement)))
	{
		// It better be a CIM Element
		// It's child should be a DECLARATION element,
		IXMLDOMElement *pDeclarationElement = NULL;
		if(SUCCEEDED(hr = GetFirstImmediateElement(pTopElement, &pDeclarationElement, L"DECLARATION")))
		{
			// Underneath this should be a DECLGROUP or DECLGROUP.WITHNAME or DECLGROUP.WITHPATH element
			IXMLDOMElement *pDeclGroupElement = NULL;
			if(SUCCEEDED(hr = GetFirstImmediateElement(pDeclarationElement, &pDeclGroupElement, L"DECLGROUP")))
			{
				hr = ProcessDeclGroup(pDeclGroupElement, strNamespacePath, lClassFlags, lInstanceFlags, pContext, pstrError);
			}
			else if(SUCCEEDED(hr = GetFirstImmediateElement(pDeclarationElement, &pDeclGroupElement, L"DECLGROUP")))
			{
				hr = ProcessDeclGroupWithName(pDeclGroupElement, strNamespacePath, lClassFlags, lInstanceFlags, pContext, pstrError);
			}
			else if(SUCCEEDED(hr = GetFirstImmediateElement(pDeclarationElement, &pDeclGroupElement, L"DECLGROUP")))
			{
				hr = ProcessDeclGroupWithPath(pDeclGroupElement, strNamespacePath, lClassFlags, lInstanceFlags, pContext, pstrError);
			}

			if(pDeclGroupElement)
				pDeclGroupElement->Release();

			pDeclarationElement->Release();
		}

		pTopElement->Release();
	}
	return hr;
}

HRESULT CXMLTransformer::ProcessDeclGroup (
		IXMLDOMElement *pDeclElement,
        BSTR strNamespacePath,
        LONG lClassFlags,
        LONG lInstanceFlags,
		IWbemContext *pContext,
		BSTR *pstrError
)
{
	// Go through its children looking for VALUE.OBJECT
	// Go thru all the properties of the class
	IXMLDOMNodeList *pNodeList = NULL;
	bool bError = false;
	HRESULT hr = E_FAIL;
	if (SUCCEEDED(pDeclElement->get_childNodes (&pNodeList)))
	{
		IXMLDOMNode *pNode = NULL;
		while (!bError && SUCCEEDED(pNodeList->nextNode (&pNode)) &&pNode)
		{
			BSTR strNodeName = NULL;
			if (SUCCEEDED(pNode->get_nodeName (&strNodeName)))
			{
				if(_wcsicmp(strNodeName, L"VALUE.OBJECT") == 0)
				{
					hr = ProcessValueObject(pNode, strNamespacePath,  lClassFlags, lInstanceFlags, pContext);
				}
				else
					ProcessPragmas(pNode, strNodeName, lClassFlags, lInstanceFlags, strNamespacePath, pContext, pstrError);

				SysFreeString(strNodeName);
			}
			pNode->Release();
			pNode = NULL;
		}
		pNodeList->Release();
	}

	if(bError)
		return hr;
	return S_OK;
}

HRESULT CXMLTransformer::ProcessPragmas(IXMLDOMNode *pNode, BSTR strNodeName, 
										LONG &lClassFlags, LONG&lInstanceFlags, 
										BSTR &strNamespacePath, IWbemContext *pContext,
										BSTR *pstrError)
{
	HRESULT hr = S_OK;
	if(_wcsicmp(strNodeName, L"pragma:classflags") == 0)
		ProcessClassPragma(pNode, lClassFlags, pstrError);
	else if(_wcsicmp(strNodeName, L"pragma:instanceflags") == 0)
		ProcessInstancePragma(pNode, lInstanceFlags, pstrError);
	else if(_wcsicmp(strNodeName, L"pragma:namespacepath") == 0)
		ProcessNamespacePragma(pNode, strNamespacePath, pstrError);
	else if(_wcsicmp(strNodeName, L"pragma:deleteclass") == 0)
		hr = ProcessDeletePragma(pNode, strNamespacePath, pContext, pstrError);
	return hr;
}

HRESULT CXMLTransformer::ProcessClassPragma(IXMLDOMNode *pNode, LONG &lClassFlags,
	BSTR *pstrError)
{
	BSTR strValue = NULL;
	if(SUCCEEDED(GetBstrAttribute(pNode, L"VALUE", &strValue)))
	{
		if(_wcsicmp(strValue, L"createOnly") == 0)
			lClassFlags = WBEM_FLAG_CREATE_ONLY;
		else if(_wcsicmp(strValue, L"forceUpdate") == 0)
			lClassFlags = WBEM_FLAG_UPDATE_FORCE_MODE;
		else if(_wcsicmp(strValue, L"updateOnly") == 0)
			lClassFlags = WBEM_FLAG_UPDATE_SAFE_MODE;
		else if(_wcsicmp(strValue, L"safeUpdate") == 0)
			lClassFlags = WBEM_FLAG_UPDATE_ONLY;
		else if(_wcsicmp(strValue, L"createOrUpdate") == 0)
			lClassFlags = WBEM_FLAG_CREATE_OR_UPDATE;
		else
			AddError(pstrError, L"Invalid pragma value %s for the classflags pragma", strValue);
		SysFreeString(strValue);
	}
	else
		AddError(pstrError, L"Missing the VALUE attribute for the classflags pragma");
	return S_OK;
}

HRESULT CXMLTransformer::ProcessInstancePragma(IXMLDOMNode *pNode, LONG&lInstanceFlags,
	BSTR *pstrError)
{
	BSTR strValue = NULL;
	if(SUCCEEDED(GetBstrAttribute(pNode, L"VALUE", &strValue)))
	{
		if(_wcsicmp(strValue, L"createOnly") == 0)
			lInstanceFlags = WBEM_FLAG_CREATE_ONLY;
		else if(_wcsicmp(strValue, L"updateOnly") == 0)
			lInstanceFlags = WBEM_FLAG_UPDATE_ONLY;
		else if(_wcsicmp(strValue, L"createOrUpdate") == 0)
			lInstanceFlags = WBEM_FLAG_CREATE_OR_UPDATE;
		else
			AddError(pstrError, L"Invalid pragma value %s for the instanceflags pragma", strValue);
		SysFreeString(strValue);
	}
	else
		AddError(pstrError, L"Missing the VALUE attribute for the instanceflags pragma");
	return S_OK;
}

HRESULT CXMLTransformer::ProcessNamespacePragma(IXMLDOMNode *pNode, BSTR &strNamespacePath,
	BSTR *pstrError)
{
	BSTR strValue = NULL;
	if(SUCCEEDED(GetBstrAttribute(pNode, L"VALUE", &strValue)))
	{
		// We check to see if there is a relative namespace path or an absolute namespace path
		// If it is the former (indicated by the absence of "\\" at the beginning,
		// then we concatenate it to the current strNamespacePath
		// If it is the latter, then we simply copy it on to the current strNamespacePath

		if(_wcsnicmp(strValue, L"\\\\", 2) == 0)
		{
			BSTR strTemp = strNamespacePath;
			strNamespacePath = NULL;
			if(!(strNamespacePath = SysAllocString(strTemp)))
				AddError(pstrError, L"Memory allocation failure when processing namespacepath pragma");
			SysFreeString(strTemp);
		}
		else
		{
			LPWSTR pszTemp = NULL;
			if(pszTemp = new WCHAR[wcslen(strNamespacePath) + wcslen(strValue) + 1])
			{
				pszTemp[0] = NULL;
				wcscat(pszTemp, strNamespacePath);
				wcscat(pszTemp, strValue);

				BSTR strTemp = strNamespacePath;
				strNamespacePath = NULL;
				if(!(strNamespacePath = SysAllocString(pszTemp)))
					AddError(pstrError, L"Memory allocation failure when processing namespacepath pragma");
				SysFreeString(strTemp);
			}
			else
				AddError(pstrError, L"Memory allocation failure when processing namespacepath pragma");
		}

		SysFreeString(strValue);
	}
	else
		AddError(pstrError, L"Missing the VALUE attribute for the namespacepath pragma");
	return S_OK;
}

HRESULT CXMLTransformer::ProcessDeletePragma(IXMLDOMNode *pNode, LPCWSTR pszNamespacePath, 
											IWbemContext *pContext,
											BSTR *pstrError)
{
	// Look at the optional FAIL attribute first
	BSTR strFailValue = NULL;
	bool bIsFail = false;
	if(SUCCEEDED(GetBstrAttribute(pNode, L"FAIL", &strFailValue)))
	{
		if(_wcsicmp(strFailValue, L"TRUE") == 0)
			bIsFail = true;

		SysFreeString(strFailValue);
	}

	HRESULT hr = E_FAIL;
	BSTR strValue = NULL;
	if(SUCCEEDED(hr = GetBstrAttribute(pNode, L"className", &strValue)))
	{

		// Parse the path to get a lot of details
		bool bIsClass = false;
		bool bIsNovaPath = true;
		bool bIsHTTP = true;
		LPWSTR pszHostNameOrURL = NULL, pszNamespace = NULL, pszObjectName = NULL;

		if(SUCCEEDED(hr = ParseObjectPath(pszNamespacePath, &pszHostNameOrURL, &pszNamespace, &pszObjectName, bIsClass, bIsHTTP, bIsNovaPath)))
		{
			// Try HTTP and/or DCOM
			if(bIsHTTP)
			{
				if(SUCCEEDED(hr = HttpDeleteClass(
					(LPCWSTR)m_strUser, (LPCWSTR)m_strPassword, (LPCWSTR)m_strLocale, 
					pszHostNameOrURL, pszNamespace, strValue, pContext)))
				{
				}
			}
			else
			{
				BSTR strHostName = NULL; 
				BSTR strNamespacePath = NULL; 
				BSTR strObjectName = NULL;

				if(bIsNovaPath)
				{
					strHostName = SysAllocString(pszHostNameOrURL);
					strNamespacePath = SysAllocString(pszNamespace);
					strObjectName = SysAllocString(strValue);

					if(!(strHostName && strNamespacePath && strObjectName))
						hr = E_OUTOFMEMORY;
				}

				if(SUCCEEDED(hr))
				{
					if(SUCCEEDED(hr = DcomDeleteClass(m_strUser, m_strPassword,
							m_strLocale, m_strAuthority, strObjectName, 
							m_dwImpersonationLevel, m_dwAuthenticationLevel, pContext)))
					{
					}
				}

				SysFreeString(strHostName);
				SysFreeString(strNamespacePath);
				SysFreeString(strObjectName);
			}

			delete [] pszHostNameOrURL;
			delete [] pszNamespace;
			delete [] pszObjectName;
		}
		SysFreeString(strValue);
	}
	if(FAILED(hr) && bIsFail)
		return hr;
	return S_OK;
}


HRESULT CXMLTransformer::ProcessValueObject (
		IXMLDOMNode *pValueObject,
        BSTR strNamespacePath,
        LONG lClassFlags,
        LONG lInstanceFlags,
		IWbemContext *pContext
)
{
	HRESULT hr = E_FAIL;
	// See if there is CLASS or INSTANCE child
	IXMLDOMElement *pObjectElement = NULL;
	if(FAILED(hr = GetFirstImmediateElement(pValueObject, &pObjectElement, L"CLASS")))
		hr = GetFirstImmediateElement(pValueObject, &pObjectElement, L"INSTANCE");

	if(pObjectElement)
	{
		hr = PutObject(pObjectElement, strNamespacePath, lClassFlags, lInstanceFlags, pContext);
		pObjectElement->Release();
	}
	return hr;
}

HRESULT CXMLTransformer::ProcessDeclGroupWithName (
		IXMLDOMElement *pDeclElement,
        BSTR strNamespacePath,
        LONG lClassFlags,
        LONG lInstanceFlags,
		IWbemContext *pContext,
		BSTR *pstrError)
{
	// Go through its children looking for VALUE.NAMEDOBJECT
	// Go thru all the properties of the class
	IXMLDOMNodeList *pNodeList = NULL;
	bool bError = false;
	HRESULT hr = E_FAIL;
	if (SUCCEEDED(pDeclElement->get_childNodes (&pNodeList)))
	{
		IXMLDOMNode *pNode = NULL;
		while (!bError && SUCCEEDED(pNodeList->nextNode (&pNode)) &&pNode)
		{
			BSTR strNodeName = NULL;
			if (SUCCEEDED(pNode->get_nodeName (&strNodeName)))
			{
				if(_wcsicmp(strNodeName, L"VALUE.NAMEDOBJECT") == 0)
				{
					hr = ProcessValueNamedObject(pNode, strNamespacePath,  lClassFlags, lInstanceFlags, pContext);
				}
				SysFreeString(strNodeName);
			}
			pNode->Release();
			pNode = NULL;
		}
		pNodeList->Release();
	}

	if(bError)
		return hr;
	return S_OK;
}

HRESULT CXMLTransformer::ProcessValueNamedObject (
		IXMLDOMNode *pValueNamedObject,
        BSTR strNamespacePath,
        LONG lClassFlags,
        LONG lInstanceFlags,
		IWbemContext *pContext
)
{
	HRESULT hr = E_FAIL;
	// The definition of VALUE.NAMEDOBJECT is
	// (CLASS|(INSTANCENAME, INSTANCE))
	// We ignore the INSTANCENAME since we are interested
	// only in the INSTANCE

	// See if there is CLASS or INSTANCE child
	IXMLDOMElement *pObjectElement = NULL;
	if(FAILED(hr = GetFirstImmediateElement(pValueNamedObject, &pObjectElement, L"CLASS")))
		hr = GetFirstImmediateElement(pValueNamedObject, &pObjectElement, L"INSTANCE");

	if(pObjectElement)
	{
		hr = PutObject(pObjectElement, strNamespacePath, lClassFlags, lInstanceFlags, pContext);
		pObjectElement->Release();
	}
	return hr;
}

HRESULT CXMLTransformer::ProcessDeclGroupWithPath (
		IXMLDOMElement *pDeclElement,
        BSTR strNamespacePath,
        LONG lClassFlags,
        LONG lInstanceFlags,
		IWbemContext *pContext,
		BSTR *pstrError)
{
	// Go through its children looking for VALUE.OBJECTWITHPATH
	// Go thru all the properties of the class
	IXMLDOMNodeList *pNodeList = NULL;
	bool bError = false;
	HRESULT hr = E_FAIL;
	if (SUCCEEDED(pDeclElement->get_childNodes (&pNodeList)))
	{
		IXMLDOMNode *pNode = NULL;
		while (!bError && SUCCEEDED(pNodeList->nextNode (&pNode)) &&pNode)
		{
			BSTR strNodeName = NULL;
			if (SUCCEEDED(pNode->get_nodeName (&strNodeName)))
			{
				if(_wcsicmp(strNodeName, L"VALUE.OBJECTWITHPATH") == 0)
				{
					hr = ProcessValueObjectWithPath(pNode, strNamespacePath,  lClassFlags, lInstanceFlags, pContext);
				}
				SysFreeString(strNodeName);
			}
			pNode->Release();
			pNode = NULL;
		}
		pNodeList->Release();
	}

	if(bError)
		return hr;
	return S_OK;
}

HRESULT CXMLTransformer::ProcessValueObjectWithPath (
		IXMLDOMNode *pValueObjectWithPath,
        BSTR strNamespacePath,
        LONG lClassFlags,
        LONG lInstanceFlags,
		IWbemContext *pContext
)
{
	HRESULT hr = E_FAIL;
	// The definition of VALUE.OBJECTWITH is
	// ((CLASSPATH,CLASS)|(INSTANCEPATH, INSTANCE))
	// We need to get the NamespacePath from the CLASSPATH and INSTANCEPATH
	// before we can proceed
	// See if there is CLASSPATH or INSTANCEPATH child
	IXMLDOMElement *pPathElement = NULL;
	if(FAILED(hr = GetFirstImmediateElement(pValueObjectWithPath, &pPathElement, L"CLASSPATH")))
		hr = GetFirstImmediateElement(pValueObjectWithPath, &pPathElement, L"INSTANCEPATH");
	if(FAILED(hr))
		return WBEM_E_INVALID_PARAMETER;

	IXMLDOMElement *pNamespacePathElement = NULL;
	BSTR strSpecificPath = NULL;
	if(SUCCEEDED(hr = GetFirstImmediateElement(pPathElement, &pNamespacePathElement, L"NAMESPACEPATH")))
	{
		hr = CParseHelper::GetNamespacePath(pNamespacePathElement, &strSpecificPath);
	}
	pPathElement->Release();

	if(FAILED(hr))
		return WBEM_E_INVALID_PARAMETER;


	// See if there is CLASS or INSTANCE child
	IXMLDOMElement *pObjectElement = NULL;
	if(FAILED(hr = GetFirstImmediateElement(pValueObjectWithPath, &pObjectElement, L"CLASS")))
		hr = GetFirstImmediateElement(pValueObjectWithPath, &pObjectElement, L"INSTANCE");

	if(pObjectElement)
	{
		hr = PutObject(pObjectElement, strSpecificPath, lClassFlags, lInstanceFlags, pContext);
		pObjectElement->Release();
	}

	SysFreeString(strSpecificPath);
	return hr;
}

HRESULT CXMLTransformer::PutObject (
		IXMLDOMElement *pObjectElement,
        BSTR strNamespacePath,
        LONG lClassFlags,
        LONG lInstanceFlags,
		IWbemContext *pContext)
{
	HRESULT hr = E_FAIL;
	// Parse the path to get a lot of details
	bool bIsClass = false;
	bool bIsNovaPath = true;
	bool bIsHTTP = true;
	LPWSTR pszHostNameOrURL = NULL, pszNamespace = NULL, pszObjectName = NULL;
	// We ignore the pszObjectName value since we expect the strNamespacepath to
	// be a path to just a namespace/scope
	if(SUCCEEDED(hr = ParseObjectPath(strNamespacePath, &pszHostNameOrURL, &pszNamespace, &pszObjectName, bIsClass, bIsHTTP, bIsNovaPath)))
	{
		// See if it is a class or an instance
		BSTR strName = NULL;
		if(SUCCEEDED(hr = pObjectElement->get_nodeName(&strName)))
		{
			if(_wcsicmp(strName, L"CLASS") == 0)
				hr = PutClass(bIsHTTP, bIsNovaPath, strNamespacePath, pszHostNameOrURL, pszNamespace, lClassFlags, NULL, pObjectElement, pContext);
			else if(_wcsicmp(strName, L"INSTANCE") == 0)
				hr = PutInstance(bIsHTTP, bIsNovaPath, strNamespacePath, pszHostNameOrURL, pszNamespace, lInstanceFlags, NULL, pObjectElement, pContext);
			SysFreeString(strName);
		}
		SysFreeString(strName);

		delete [] pszHostNameOrURL;
		delete [] pszNamespace;
		delete [] pszObjectName;
	}
	return hr;
}


HRESULT CXMLTransformer::PutClass (
	bool bIsHTTP,
	bool bIsNovaPath,
    BSTR strNamespacePath,
	LPCWSTR pszHostNameOrURL,
	LPCWSTR pszNamespace,
    LONG lClassFlags,
	IXMLDOMNode *pClassPathNode,
	IXMLDOMElement *pClassNode,
	IWbemContext *pContext)
{
	HRESULT hr = E_FAIL;

	// We need to decide 2 things:
	// 1. Whether to do a CreateClass or to do a ModifyClass Operation
	// 2. Whether to do a ModifyClass id CreateClass fails
	bool bDoCreate = true; // If this is false, then we do a ModifyClass Operation
	bool bTryModify = false; // This flag is used if the first operation is CreateClass and it fails
	switch(lClassFlags)
	{
		case WBEM_FLAG_UPDATE_ONLY:
			bDoCreate = false; break;
		case WBEM_FLAG_CREATE_ONLY:
			break;
		case WBEM_FLAG_CREATE_OR_UPDATE:
			bTryModify = true;break;
	}

	BSTR strErrors = NULL;
	if(bIsHTTP)
	{
		if(bDoCreate)
			hr = HttpPutClass(
				(LPCWSTR)m_strUser, (LPCWSTR)m_strPassword, 
				(LPCWSTR)m_strLocale, (LPCWSTR)strNamespacePath,
				lClassFlags, pClassNode,
				pContext,
				&strErrors);
		else
			hr = HttpModifyClass(
				(LPCWSTR)m_strUser, (LPCWSTR)m_strPassword, 
				(LPCWSTR)m_strLocale, (LPCWSTR)strNamespacePath,
				lClassFlags, pClassNode,
				pContext,
				&strErrors);

		if(FAILED(hr) && !bDoCreate && bTryModify)
			hr = HttpModifyClass(
				(LPCWSTR)m_strUser, (LPCWSTR)m_strPassword, 
				(LPCWSTR)m_strLocale, (LPCWSTR)strNamespacePath,
				lClassFlags, pClassNode,
				pContext,
				&strErrors);

	}
	else
	{
		hr = DcomPutClass(m_strUser, m_strPassword, 
					m_strLocale, strNamespacePath, lClassFlags, pClassNode, pContext, m_dwImpersonationLevel, m_dwAuthenticationLevel, &strErrors);
	}

	// Post-process output
	if(SUCCEEDED(hr))
	{
	}
	else
	{
		if(strErrors)
			SysFreeString(strErrors);
	}

	if (FAILED(hr))
		m_hResult = hr;

	return hr;
}

HRESULT CXMLTransformer::PutInstance (
	bool bIsHTTP,
	bool bIsNovaPath,
    BSTR strNamespacePath,
	LPCWSTR pszHostNameOrURL,
	LPCWSTR pszNamespace,
    LONG lInstanceFlags,
	IXMLDOMNode *pInstancePathNode,
	IXMLDOMElement *pInstanceNode,
	IWbemContext *pContext)
{
	HRESULT hr = E_FAIL;

	// We need to decide 2 things:
	// 1. Whether to do a CreateInstance or to do a ModifyInstance Operation
	// 2. Whether to do a ModifyInstance id CreateInstance fails
	bool bDoCreate = true; // If this is false, then we do a ModifyInstance Operation
	bool bTryModify = false; // This flag is used if the first operation is CreateInstance and it fails
	switch(lInstanceFlags)
	{
		case WBEM_FLAG_UPDATE_ONLY:
			bDoCreate = false; break;
		case WBEM_FLAG_CREATE_ONLY:
			break;
		case WBEM_FLAG_CREATE_OR_UPDATE:
			bTryModify = true;break;
	}

	BSTR strErrors = NULL;
	if(bIsHTTP)
	{
		if(bDoCreate)
			hr = HttpPutInstance(
					(LPCWSTR)m_strUser, (LPCWSTR)m_strPassword, 
					(LPCWSTR)m_strLocale, (LPCWSTR)strNamespacePath,
					lInstanceFlags, pInstanceNode,
					pContext,
					&strErrors);
		else
			hr = HttpModifyInstance(
					(LPCWSTR)m_strUser, (LPCWSTR)m_strPassword, 
					(LPCWSTR)m_strLocale, (LPCWSTR)strNamespacePath,
					lInstanceFlags, pInstanceNode,
					pContext,
					&strErrors);

		if(FAILED(hr) && !bDoCreate && bTryModify)
			hr = HttpModifyInstance(
					(LPCWSTR)m_strUser, (LPCWSTR)m_strPassword, 
					(LPCWSTR)m_strLocale, (LPCWSTR)strNamespacePath,
					lInstanceFlags, pInstanceNode,
					pContext,
					&strErrors);

	}
	else
	{
		hr = DcomPutInstance(m_strUser, m_strPassword, 
					m_strLocale, strNamespacePath, lInstanceFlags, pInstanceNode, pContext, m_dwImpersonationLevel, m_dwAuthenticationLevel, &strErrors);
	}

	// Post-process output
	if(SUCCEEDED(hr))
	{
	}
	else
	{
		if(strErrors)
			SysFreeString(strErrors);
	}

	if (FAILED(hr))
		m_hResult = hr;

	return hr;
}

HRESULT CXMLTransformer::GetFirstImmediateElement(IXMLDOMNode *pParent, IXMLDOMElement **ppChildElement, LPCWSTR pszName)
{
	HRESULT hr = E_FAIL;

	// Now cycle thru the children
	IXMLDOMNodeList *pNodeList = NULL;
	BOOL bFound = FALSE;
	if (SUCCEEDED(hr = pParent->get_childNodes (&pNodeList)))
	{
		IXMLDOMNode *pNode = NULL;
		while (!bFound && SUCCEEDED(pNodeList->nextNode (&pNode)) && pNode)
		{
			// Get the name of the child
			BSTR strNodeName = NULL;
			if (SUCCEEDED(hr = pNode->get_nodeName (&strNodeName)))
			{
				// We're interested only in PROPERTIES at this point
				if(_wcsicmp(strNodeName, pszName) == 0)
				{
					*ppChildElement = NULL;
					hr = pNode->QueryInterface(IID_IXMLDOMElement, (LPVOID *)ppChildElement);
					bFound = TRUE;
				}
				SysFreeString(strNodeName);
			}
			pNode->Release();
			pNode = NULL;
		}
		pNodeList->Release();
	}
	if(bFound)
		return hr;
	return E_FAIL;
}


static HRESULT PackageDCOMOutputUsingEnumerator(IEnumWbemClassObject *pEnum, 
												WmiXMLEncoding iEncoding,
												VARIANT_BOOL bIncludeQualifiers,
												VARIANT_BOOL bIncludeClassOrigin,
												VARIANT_BOOL bLocalOnly,
												ISWbemXMLDocumentSet **ppSet,
												bool bNamesOnly)
{
	HRESULT hr = E_FAIL;
	*ppSet = NULL;
	CWbemDCOMDocSet *pSet = NULL;
	if(pSet = new CWbemDCOMDocSet())
	{
		// Set which kind of elements we want to be manufactured.
		if(SUCCEEDED(hr = pSet->Initialize(pEnum, iEncoding, bIncludeQualifiers, bIncludeClassOrigin, bLocalOnly, bNamesOnly)))
			*ppSet = pSet;
		else
			delete pSet;
	}
	else
		hr = E_OUTOFMEMORY;
	return hr;
}


void CXMLTransformer::AddError(BSTR *pstrError, LPCWSTR pszFormat, ...)
{
	// Create the latest error message
	WCHAR pszLatestError[256];
	int length = 0;
	// Initialize the var args variables
	va_list marker;
	va_start( marker, pszFormat);     
	swprintf(pszLatestError, pszFormat, marker );

	// Append the error to the list of errors already in the pstrError
	if(*pstrError)
	{
		LPWSTR pszTemp = NULL;
		if(pszTemp = new WCHAR[wcslen(*pstrError) + wcslen(pszLatestError) + 2])
		{
			pszTemp[0] = NULL;
			wcscat(pszTemp, *pstrError);
			wcscat(pszTemp, L"\n");
			wcscat(pszTemp, pszLatestError);
			SysFreeString(*pstrError);
			*pstrError = NULL;
			*pstrError = SysAllocString(pszTemp);
			delete [] pszTemp;
		}
	}
	else
		*pstrError = SysAllocString(pszLatestError);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\xmltransport\compiler\control\xmltransf\dcomops.cpp ===
#include "precomp.h"
#include <windows.h>
#include <initguid.h>
#include <objbase.h>
#include <stdio.h>
#include <msxml.h>

#include "cominit.h"
#include "wbemcli.h"
#include "wmiutils.h"
#include "dcomops.h"
#include "wmiconv.h"

// This function gets the object name and the server/namespace from a Nove style objectpath
static HRESULT DCOMParseObjectPath(BSTR strObjectPath, BSTR *pstrNamespace, BSTR *pstrObjectName);

// This function is used to create a WQL query for an EnumINstNames operation
static HRESULT CreateInstNameQuery(BSTR strClassName, BSTR *pstrQuery, BSTR *pstrQueryLanguage);

// Gets a connection to a namespace/scope - first tries Whistler and then Nova APIs
static HRESULT GetDCOMConnection(
	BSTR strUser,
	BSTR strPassword,
	BSTR strLocale,
	BSTR strNamespacePath,
	IWbemContext *pContext,
	DWORD dwImpersonationLevel,
	DWORD dwAuthenticationLevel,
	IWbemServices **ppServices);

// This converts an XML object to WMI - works only on whistler
static HRESULT ConvertXMLObjectToWMI(IXMLDOMElement *pInstanceOrClassElement, IWbemContext *pContext, IWbemClassObject **ppObject);

HRESULT DcomGetObject (
	BSTR strUser,
	BSTR strPassword,
	BSTR strLocale,
	BSTR strAuthority,
	BSTR strObjectPath,
	bool bIsNovaPath,
	DWORD dwImpersonationLevel,
	DWORD dwAuthenticationLevel,
	IWbemContext *pContext,
	IWbemClassObject **ppObject)
{
	HRESULT hr = E_FAIL;

	// Now, we've to use the Nova ConnectServer() call and so on ...
	hr = DcomGetNovaObject(strUser, strPassword, strLocale, strAuthority, 
		strObjectPath, dwImpersonationLevel, dwAuthenticationLevel, pContext, ppObject);

	return hr;
}

HRESULT DcomDeleteClass(
	BSTR strUser,
	BSTR strPassword,
	BSTR strLocale,
	BSTR strAuthority,
	BSTR strClassPath,
	DWORD dwImpersonationLevel,
	DWORD dwAuthenticationLevel,
	IWbemContext *pContext)
{
	// A Class Path cant be scoped
	// Hence we do not need separate code paths for Nova and Whistler style paths
	HRESULT hr = E_FAIL;
	// We need to parse the object path to get the namespace
	BSTR strNamespace = NULL, strClassName = NULL;
	if(SUCCEEDED(hr = DCOMParseObjectPath(strClassPath, &strNamespace, &strClassName)))
	{
		// Connect to the namespace/scope
		IWbemServices *pServices = NULL;
		if (SUCCEEDED(hr = GetDCOMConnection(strUser, strPassword, strLocale, strNamespace, pContext, dwImpersonationLevel, dwAuthenticationLevel, &pServices)))
		{
			hr = pServices->DeleteClass(strClassName, 0, pContext, NULL);
			pServices->Release();
		}

		SysFreeString(strNamespace);
		SysFreeString(strClassName);
	}
	return hr;
}


HRESULT DcomExecQuery (
	BSTR strUser,
	BSTR strPassword,
	BSTR strLocale,
	BSTR strAuthority,
	DWORD dwImpersonationLevel,
	DWORD dwAuthenticationLevel,
	BSTR strNamespacePath,
	BSTR strQuery,
	BSTR strQueryLanguage,
	IWbemContext *pContext,
	IEnumWbemClassObject **ppEnum)
{
	HRESULT hr = E_FAIL;

	// Connect to the namespace/scope
	IWbemServices *pServices = NULL;
	if (SUCCEEDED(hr = GetDCOMConnection(strUser, strPassword, strLocale, strNamespacePath, pContext, dwImpersonationLevel, dwAuthenticationLevel, &pServices)))
	{
		// First try with the amended qualifiers
		// This will work on Win2k and above
		// If this fails, then try without the amended qualifiers
		long lFlags = WBEM_FLAG_USE_AMENDED_QUALIFIERS | WBEM_FLAG_FORWARD_ONLY | WBEM_FLAG_RETURN_IMMEDIATELY;
		if((hr = pServices->ExecQuery(strQueryLanguage, strQuery, lFlags, pContext, ppEnum)) == WBEM_E_INVALID_PARAMETER)
		{
			lFlags = WBEM_FLAG_FORWARD_ONLY | WBEM_FLAG_RETURN_IMMEDIATELY;
			if(SUCCEEDED(hr = pServices->ExecQuery(strQueryLanguage, strQuery, lFlags, pContext, ppEnum)))
			{
			}
		}

		// Set the security on the enumerator
		if(SUCCEEDED(hr))
		{
			if(FAILED(hr = SetInterfaceSecurity(*ppEnum, NULL, NULL, NULL, dwAuthenticationLevel, dwImpersonationLevel, EOAC_STATIC_CLOAKING)))
			{
				(*ppEnum)->Release();
				*ppEnum = NULL;
			}
		}
		pServices->Release();
	}
	return hr;
}

HRESULT DcomEnumClass (
	BSTR strUser,
	BSTR strPassword,
	BSTR strLocale,
	BSTR strAuthority,
	DWORD dwImpersonationLevel,
	DWORD dwAuthenticationLevel,
	BSTR strSuperClassPath,
	VARIANT_BOOL bDeep,
	IWbemContext *pContext,
	IEnumWbemClassObject **ppEnum
	)
{
	// A Class Path cant be scoped
	// Hence we do not need separate code paths for Nova and Whistler style paths
	HRESULT hr = E_FAIL;
	// We need to parse the object path to get the namespace
	BSTR strNamespace = NULL, strClassName = NULL;
	if(SUCCEEDED(hr = DCOMParseObjectPath(strSuperClassPath, &strNamespace, &strClassName)))
	{
		// Connect to the namespace/scope
		IWbemServices *pServices = NULL;
		if (SUCCEEDED(hr = GetDCOMConnection(strUser, strPassword, strLocale, strNamespace, pContext, dwImpersonationLevel, dwAuthenticationLevel, &pServices)))
		{
			// First try with the amended qualifiers
			// This will work on Win2k and above
			// If this fails, then try without the amended qualifiers
			long lFlags = WBEM_FLAG_USE_AMENDED_QUALIFIERS | WBEM_FLAG_RETURN_IMMEDIATELY | WBEM_FLAG_FORWARD_ONLY;
			lFlags |= ( (bDeep == VARIANT_TRUE) ? WBEM_FLAG_DEEP  : 0 );
			if((hr = pServices->CreateClassEnum(strClassName, lFlags, pContext, ppEnum)) == WBEM_E_INVALID_PARAMETER)
			{
				lFlags = WBEM_FLAG_RETURN_IMMEDIATELY | WBEM_FLAG_FORWARD_ONLY;
				lFlags |= ( (bDeep == VARIANT_TRUE) ? WBEM_FLAG_DEEP  : 0);
				hr = pServices->CreateClassEnum(strClassName, lFlags, pContext, ppEnum);
			}

			// Set the security on the enumerator
			if(SUCCEEDED(hr))
			{
				if(FAILED(hr = SetInterfaceSecurity(*ppEnum, NULL, NULL, NULL, dwAuthenticationLevel, dwImpersonationLevel, EOAC_STATIC_CLOAKING)))
				{
					(*ppEnum)->Release();
					*ppEnum = NULL;
				}
			}
			pServices->Release();
		}

		SysFreeString(strNamespace);
		SysFreeString(strClassName);
	}
	return hr;
}

HRESULT DcomEnumInstance (
	BSTR strUser,
	BSTR strPassword,
	BSTR strLocale,
	BSTR strAuthority,
	DWORD dwImpersonationLevel,
	DWORD dwAuthenticationLevel,
	BSTR strClassPath,
	VARIANT_BOOL bDeep,
	IWbemContext *pContext,
	IEnumWbemClassObject **ppEnum)
{
	// A Class Path cant be scoped
	// Hence we do not need separate code paths for Nova and Whistler style paths
	HRESULT hr = E_FAIL;
	// We need to parse the object path to get the namespace
	BSTR strNamespace = NULL, strClassName = NULL;
	if(SUCCEEDED(hr = DCOMParseObjectPath(strClassPath, &strNamespace, &strClassName)))
	{
		// Connect to the namespace/scope
		IWbemServices *pServices = NULL;
		if (SUCCEEDED(hr = GetDCOMConnection(strUser, strPassword, strLocale, strNamespace, pContext, dwImpersonationLevel, dwAuthenticationLevel, &pServices)))
		{
			// First try with the amended qualifiers
			// This will work on Win2k and above
			// If this fails, then try without the amended qualifiers
			long lFlags = WBEM_FLAG_USE_AMENDED_QUALIFIERS | WBEM_FLAG_RETURN_IMMEDIATELY | WBEM_FLAG_FORWARD_ONLY;
			lFlags |= ( (bDeep == VARIANT_TRUE) ? WBEM_FLAG_DEEP  : 0 );
			if((hr = pServices->CreateInstanceEnum(strClassName, lFlags, pContext, ppEnum)) == WBEM_E_INVALID_PARAMETER)
			{
				lFlags = WBEM_FLAG_RETURN_IMMEDIATELY | WBEM_FLAG_FORWARD_ONLY;
				lFlags |= ( (bDeep == VARIANT_TRUE) ? WBEM_FLAG_DEEP  : 0);
				hr = pServices->CreateInstanceEnum(strClassName, lFlags, pContext, ppEnum);
			}

			// Set the security on the enumerator
			if(SUCCEEDED(hr))
			{
				if(FAILED(hr = SetInterfaceSecurity(*ppEnum, NULL, NULL, NULL, dwAuthenticationLevel, dwImpersonationLevel, EOAC_STATIC_CLOAKING)))
				{
					(*ppEnum)->Release();
					*ppEnum = NULL;
				}
			}
			pServices->Release();
		}

		SysFreeString(strNamespace);
		SysFreeString(strClassName);
	}
	return hr;

}


HRESULT DcomEnumClassNames (
	BSTR strUser,
	BSTR strPassword,
	BSTR strLocale,
	BSTR strAuthority,
	DWORD dwImpersonationLevel,
	DWORD dwAuthenticationLevel,
	BSTR strSuperClassPath,
	VARIANT_BOOL bDeep,
	IWbemContext *pContext,
	IEnumWbemClassObject **ppEnum)
{
	// No way we can optimize this operation to a WQL Query fully
	// "Select __CLASS form meta_class" is an invalid query
	// So currently, do an enumerateClass operation and let the post-processor 
	// take care of the eliminating all but the __PATH property
	return DcomEnumClass(strUser, strPassword, strLocale, strAuthority, 
		dwImpersonationLevel, dwAuthenticationLevel, strSuperClassPath, bDeep, pContext, ppEnum);
}

HRESULT DcomEnumInstanceNames (
	BSTR strUser,
	BSTR strPassword,
	BSTR strLocale,
	BSTR strAuthority,
	DWORD dwImpersonationLevel,
	DWORD dwAuthenticationLevel,
	BSTR strClassPath,
	IWbemContext *pContext,
	IEnumWbemClassObject **ppEnum)
{
	// A Class Path cant be scoped
	// Hence we do not need separate code paths for Nova and Whistler style paths
	HRESULT hr = E_FAIL;
	// We need to parse the object path to get the namespace
	BSTR strNamespace = NULL, strClassName = NULL;
	if(SUCCEEDED(hr = DCOMParseObjectPath(strClassPath, &strNamespace, &strClassName)))
	{
		// We need to optimize this operation to a query
		BSTR strQuery = NULL, strQueryLanguage = NULL;
		if(SUCCEEDED(hr = CreateInstNameQuery(strClassName, &strQuery, &strQueryLanguage)))
		{
			hr = DcomExecQuery (strUser, strPassword, strLocale, strAuthority, dwImpersonationLevel,
				dwAuthenticationLevel, strNamespace, strQuery, strQueryLanguage, pContext, ppEnum);
			SysFreeString(strQuery);
			SysFreeString(strQueryLanguage);
		}
		SysFreeString(strNamespace);
		SysFreeString(strClassName);
	}
	return hr;
}

HRESULT DcomPutClass (
	BSTR strUser,
	BSTR strPassword,
	BSTR strLocale,
	BSTR strNamespacePath,
	LONG lClassFlags,
	IXMLDOMElement *pClassElement,
	IWbemContext *pContext,
	DWORD dwImpersonationLevel,
	DWORD dwAuthenticationLevel,
	BSTR *pstrErrors)
{
	HRESULT hr = E_FAIL;
	IWbemClassObject *pObject = NULL;
	if(SUCCEEDED(hr = ConvertXMLObjectToWMI(pClassElement, pContext, &pObject)))
	{
		IWbemServices *pServices = NULL;
		if(SUCCEEDED(hr = GetDCOMConnection(strUser, strPassword, strLocale, strNamespacePath, pContext, dwImpersonationLevel, dwAuthenticationLevel, &pServices)))
		{
			hr = pServices->PutClass(pObject, lClassFlags, pContext, NULL);
			pServices->Release();
		}
	}
	return hr;
}

HRESULT DcomPutInstance (
	BSTR strUser,
	BSTR strPassword,
	BSTR strLocale,
	BSTR strNamespacePath,
	LONG lInstanceFlags,
	IXMLDOMElement *pInstanceElement,
	IWbemContext *pContext,
	DWORD dwImpersonationLevel,
	DWORD dwAuthenticationLevel,
	BSTR *pstrErrors)
{
	HRESULT hr = E_FAIL;
	IWbemClassObject *pObject = NULL;
	if(SUCCEEDED(hr = ConvertXMLObjectToWMI(pInstanceElement, pContext, &pObject)))
	{
		IWbemServices *pServices = NULL;
		if(SUCCEEDED(hr = GetDCOMConnection(strUser, strPassword, strLocale, strNamespacePath, pContext, dwImpersonationLevel, dwAuthenticationLevel, &pServices)))
		{
			hr = pServices->PutInstance(pObject, lInstanceFlags, pContext, NULL);
			pServices->Release();
		}
	}
	return hr;
}


HRESULT DcomGetNovaObject (
	BSTR strUser,
	BSTR strPassword,
	BSTR strLocale,
	BSTR strAuthority,
	BSTR strObjectPath,
	DWORD dwImpersonationLevel,
	DWORD dwAuthenticationLevel,
	IWbemContext *pContext,
	IWbemClassObject **ppObject)
{
	HRESULT hr = E_FAIL;
	// We need to parse the object path to get the namespace
	// But first, we need the Locator
	IWbemLocator *pLocator = NULL;
	if (SUCCEEDED(hr = CoCreateInstance(CLSID_WbemLocator, 0, CLSCTX_INPROC_SERVER,
			IID_IWbemLocator, (LPVOID *) &pLocator)))
	{
		BSTR strNamespace = NULL, strObjectName = NULL;
		if(SUCCEEDED(hr = DCOMParseObjectPath(strObjectPath, &strNamespace, &strObjectName)))
		{
			// Connect to the namespace
			IWbemServices *pServices = NULL;
			if (SUCCEEDED(hr = pLocator->ConnectServer (strNamespace, strUser, strPassword, strLocale, 0, strAuthority, pContext, &pServices)))
			{
				// Set the impersonation/authentication levels
				if(SUCCEEDED(hr = SetInterfaceSecurity(pServices, NULL, NULL, NULL, dwAuthenticationLevel, dwImpersonationLevel, EOAC_STATIC_CLOAKING)))
				{
					// First try with the amended qualifiers
					// This will work on Win2k and above
					// If this fails, then try without the amended qualifiers
					long lFlags = WBEM_FLAG_USE_AMENDED_QUALIFIERS;
					if((hr = pServices->GetObject(strObjectName, lFlags, pContext, ppObject, NULL)) == WBEM_E_INVALID_PARAMETER)
					{
						lFlags = 0;
						hr = pServices->GetObject(strObjectName, lFlags, pContext, ppObject, NULL);
					}
				}
				pServices->Release();
			}

			SysFreeString(strNamespace);
			SysFreeString(strObjectName);
		}
		pLocator->Release();
	}
	return hr;
}

// This function gets the object name and the server/namespace from a Nove style objectpath
static HRESULT DCOMParseObjectPath(BSTR strObjectPath, BSTR *pstrNamespace, BSTR *pstrObjectName)
{
	if(NULL == strObjectPath)
		return E_INVALIDARG;

	HRESULT hr = E_FAIL;
	*pstrNamespace = NULL;
	*pstrObjectName = NULL;

	// Special case when the strObjectPath is just "root"
	// This occurs when you try to enumerate classes in the root namespace
	// In this case, we need to make a special consideration since the object path
	// parser gives root as the class name and NULL as the namespace
	if(_wcsicmp(strObjectPath, L"root") == 0)
	{
		if(*pstrNamespace = SysAllocString(strObjectPath))
			return S_OK;
		return E_OUTOFMEMORY;
	}

	// We need to parse the Nova-style path
	IWbemPath *pPath = NULL;
	if(SUCCEEDED(hr = CoCreateInstance(CLSID_WbemDefPath,NULL, CLSCTX_INPROC_SERVER, IID_IWbemPath,(LPVOID *)&pPath)))
	{
		if(SUCCEEDED(hr = pPath->SetText(WBEMPATH_CREATE_ACCEPT_ALL, strObjectPath)))
		{
			// Get the memory requirements first
			ULONG	lBuffLen = 0;
			if(SUCCEEDED(hr = pPath->GetText(WBEMPATH_GET_RELATIVE_ONLY, &lBuffLen,NULL)))
			{
				if(lBuffLen != 0)
				{
					LPWSTR pszObjectName = NULL;
					if(pszObjectName = new WCHAR[lBuffLen])
					{
						// Now get the object name
						//===========================
						if(SUCCEEDED(hr = pPath->GetText(WBEMPATH_GET_RELATIVE_ONLY, &lBuffLen, pszObjectName)))
						{
							// Convert to BSTR
							*pstrObjectName = NULL;
							if(*pstrObjectName = SysAllocString(pszObjectName))
							{
								// Now we need to get the server/namespace
								//==========================================
								lBuffLen = 0;
								if(SUCCEEDED(hr = pPath->GetText(WBEMPATH_GET_SERVER_AND_NAMESPACE_ONLY, &lBuffLen,NULL)))
								{
									if(lBuffLen != 0)
									{
										LPWSTR pszServerNamespace = NULL;
										if(pszServerNamespace = new WCHAR[lBuffLen])
										{
											// Now get the object name
											//===========================
											if(SUCCEEDED(hr = pPath->GetText(WBEMPATH_GET_SERVER_AND_NAMESPACE_ONLY, &lBuffLen, pszServerNamespace)))
											{
												// Convert to BSTR
												*pstrNamespace = NULL;
												if(*pstrNamespace = SysAllocString(pszServerNamespace))
												{
												}
												else hr = E_OUTOFMEMORY;
											}
											delete [] pszServerNamespace;
										}
										else
											hr = E_OUTOFMEMORY;
									}
									else
										hr = WBEM_E_FAILED;
								}
							}
							else hr = E_OUTOFMEMORY;
						}
						delete [] pszObjectName;
					}
					else
						hr = E_OUTOFMEMORY;
				}
				else
					hr = WBEM_E_FAILED;
			}
		}
		pPath->Release();
	}

	if(FAILED(hr))
	{
		SysFreeString(*pstrNamespace);
		SysFreeString(*pstrObjectName);
	}
	return hr;
}

// This function creates a query for an EnumInstanceName operation
static HRESULT CreateInstNameQuery(BSTR strClassName, BSTR *pstrQuery, BSTR *pstrQueryLanguage)
{
	HRESULT hr = E_FAIL;
	*pstrQuery = NULL;
	*pstrQueryLanguage = NULL;

	LPCWSTR pszQueryFormat = L"select __PATH from %s";
	DWORD dwQueryLength = wcslen(pszQueryFormat) + wcslen(strClassName) + 1;
	LPWSTR pszQuery = NULL;
	if(pszQuery = new WCHAR[dwQueryLength])
	{
		swprintf(pszQuery, pszQueryFormat, strClassName);
		if(*pstrQuery = SysAllocString(pszQuery))
		{
			if(*pstrQueryLanguage = SysAllocString(L"WQL"))
			{
				hr = S_OK;
			}
			else
				hr = E_OUTOFMEMORY;
		}
		else
			hr = E_OUTOFMEMORY;
	}
	else
		hr = E_OUTOFMEMORY;

	if(FAILED(hr))
	{
		SysFreeString(*pstrQuery);
		SysFreeString(*pstrQueryLanguage);
	}
	return hr;
}

static HRESULT GetDCOMConnection(
	BSTR strUser,
	BSTR strPassword,
	BSTR strLocale,
	BSTR strNamespacePath,
	IWbemContext *pContext,
	DWORD dwImpersonationLevel,
	DWORD dwAuthenticationLevel,
	IWbemServices **ppServices)
{
	HRESULT hr = E_FAIL;
	*ppServices = NULL;
	IWbemLocator *pLocator = NULL;
	if(SUCCEEDED(hr = CoCreateInstance (CLSID_WbemLocator, NULL, CLSCTX_INPROC_SERVER,
																IID_IWbemLocator, (LPVOID *)&pLocator)))
	{
		hr = pLocator->ConnectServer(strNamespacePath, strUser, strPassword, strLocale, 0, NULL, pContext, ppServices);
		pLocator->Release();
	}

	if(*ppServices)
	{
			// Set the impersonation/authentication levels
		hr = SetInterfaceSecurity(*ppServices, NULL, NULL, NULL, dwAuthenticationLevel, dwImpersonationLevel, EOAC_STATIC_CLOAKING);
	}
	return hr;
}

DEFINE_GUID(CLSID_XMLWbemConvertor,
0x41388e26, 0xf847, 0x4a9d, 0x96, 0xc0, 0x9a, 0x84, 0x7d, 0xba, 0x4c, 0xfe);

static HRESULT ConvertXMLObjectToWMI(IXMLDOMElement *pInstanceOrClassElement, IWbemContext *pContext, IWbemClassObject **ppObject)
{
	HRESULT hr = E_FAIL;
	IXMLWbemConvertor *pSrc = NULL;
	if(SUCCEEDED(hr = CoCreateInstance (CLSID_XMLWbemConvertor, NULL, CLSCTX_INPROC_SERVER,
												IID_IXMLWbemConvertor, (void**) &pSrc)))
	{
		hr = pSrc->MapObjectToWMI(pInstanceOrClassElement, pContext, NULL, NULL, ppObject);
		pSrc->Release();
	}
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\xmltransport\compiler\control\xmltransf\dcomops.h ===
#ifndef DCOM_OPS_H
#define DCOM_OPS_H

HRESULT DcomGetObject (
	BSTR strUser,
	BSTR strPassword,
	BSTR strLocale,
	BSTR strAuthority,
	BSTR strObjectPath,
	bool bIsNovaPath,
	DWORD dwImpersonationLevel,
	DWORD dwAuthenticationLevel,
	IWbemContext *pContext,
	IWbemClassObject **ppObject);

HRESULT DcomDeleteClass(
	BSTR strUser,
	BSTR strPassword,
	BSTR strLocale,
	BSTR strAuthority,
	BSTR strClassPath,
	DWORD dwImpersonationLevel,
	DWORD dwAuthenticationLevel,
	IWbemContext *pContext);
						
						
HRESULT DcomExecQuery (
	BSTR strUser,
	BSTR strPassword,
	BSTR strLocale,
	BSTR strAuthority,
	DWORD dwImpersonationLevel,
	DWORD dwAuthenticationLevel,
	BSTR strNamespacePath,
	BSTR strQuery,
	BSTR strQueryLanguage,
	IWbemContext *pContext,
	IEnumWbemClassObject **ppEnum);

HRESULT DcomEnumClass (
	BSTR strUser,
	BSTR strPassword,
	BSTR strLocale,
	BSTR strAuthority,
	DWORD dwImpersonationLevel,
	DWORD dwAuthenticationLevel,
	BSTR strSuperClassPath,
	VARIANT_BOOL bDeep,
	IWbemContext *pContext,
	IEnumWbemClassObject **ppEnum);


HRESULT DcomEnumInstance (
	BSTR strUser,
	BSTR strPassword,
	BSTR strLocale,
	BSTR strAuthority,
	DWORD dwImpersonationLevel,
	DWORD dwAuthenticationLevel,
	BSTR strClassPath,
	VARIANT_BOOL bDeep,
	IWbemContext *pContext,
	IEnumWbemClassObject **ppEnum);

HRESULT DcomEnumClassNames (
	BSTR strUser,
	BSTR strPassword,
	BSTR strLocale,
	BSTR strAuthority,
	DWORD dwImpersonationLevel,
	DWORD dwAuthenticationLevel,
	BSTR strSuperClassPath,
	VARIANT_BOOL bDeep,
	IWbemContext *pContext,
	IEnumWbemClassObject **ppEnum);

HRESULT DcomEnumInstanceNames (
	BSTR strUser,
	BSTR strPassword,
	BSTR strLocale,
	BSTR strAuthority,
	DWORD dwImpersonationLevel,
	DWORD dwAuthenticationLevel,
	BSTR strClassPath,
	IWbemContext *pContext,
	IEnumWbemClassObject **ppEnum);

HRESULT DcomPutClass (
	BSTR strUser,
	BSTR strPassword,
	BSTR strLocale,
	BSTR strNamespacePath,
	LONG lClassFlags,
	IXMLDOMElement *pClassElement,
	IWbemContext *pContext,
	DWORD dwImpersonationLevel,
	DWORD dwAuthenticationLevel,
	BSTR *pstrErrors);

HRESULT DcomPutInstance (
	BSTR strUser,
	BSTR strPassword,
	BSTR strLocale,
	BSTR strNamespacePath,
	LONG lInstanceFlags,
	IXMLDOMElement *pClassElement,
	IWbemContext *pContext,
	DWORD dwImpersonationLevel,
	DWORD dwAuthenticationLevel,
	BSTR *pstrErrors);


HRESULT DcomGetNovaObject (
	BSTR strUser,
	BSTR strPassword,
	BSTR strLocale,
	BSTR strAuthority,
	BSTR strObjectPath,
	DWORD dwImpersonationLevel,
	DWORD dwAuthenticationLevel,
	IWbemContext *pContext,
	IWbemClassObject **ppObject);


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\xmltransport\compiler\control\xmltransf\disphlp.cpp ===
//***************************************************************************
//
//  cdisphlp.CPP
//
//  Module: Client side of WBEM marshalling.
//
//  Purpose: Defines dispatch helper object
//
//  Copyright (c) 1998-1999 Microsoft Corporation
//
//  a-davj    6-feb-97   Created.
//
//***************************************************************************
#include "precomp.h"
#include <msxml.h>
#include <wbemcli.h>

#include "xmltrnsf.h"
#include "disphlp.h"

const int CDispatchHelp::ENGLISH_LOCALE = 1033;
const HRESULT CDispatchHelp::wbemErrTimedout = 0x80043001;
const HRESULT CDispatchHelp::wbemErrResetToDefault = 0x80043002;

//***************************************************************************
//  CDispatchHelp::CDispatchHelp()
//  CDispatchHelp::~CDispatchHelp()
//
//  Purpose: constructor and destructor
//
//***************************************************************************

CDispatchHelp::CDispatchHelp()
{
    m_pITINeutral = NULL;      //Type information
	m_pCITINeutral = NULL;
    m_pObj = NULL;
	m_objectName = NULL;
	m_hResult = S_OK;
}

CDispatchHelp::~CDispatchHelp(void)
{
    if(m_pITINeutral != NULL)
        m_pITINeutral->Release();
    if(m_pCITINeutral != NULL)
        m_pCITINeutral->Release();

	SysFreeString (m_objectName);
}

// This is for non-CoCreatable objects, hence there is only an IID
void CDispatchHelp::SetObj(IDispatch * pObj, GUID guid, LPWSTR objectName)
{
    m_pObj = pObj;
    m_GUID = guid;
	m_objectName = SysAllocString (objectName);
}

// This is for CoCreateable object, hence there'se CLSID as well
void CDispatchHelp::SetObj(IDispatch * pObj, GUID guid, 
						   GUID cGuid, LPWSTR objectName)
{
    m_pObj = pObj;
    m_GUID = guid;
	m_cGUID = cGuid;
	m_objectName = SysAllocString (objectName);
}

SCODE CDispatchHelp::GetTypeInfoCount(UINT FAR* pctinfo)
{
    //We implement GetTypeInfo so return 1
    *pctinfo=1;
    return NOERROR;
}

SCODE CDispatchHelp::GetTypeInfo(
      UINT itinfo,
      LCID lcid,
      ITypeInfo FAR* FAR* ppITypeInfo)
{
    HRESULT     hr;

    if (0!=itinfo)
        return TYPE_E_ELEMENTNOTFOUND;

    if (NULL==ppITypeInfo)
        return E_POINTER;

    *ppITypeInfo=NULL;

    //Load a type lib if we don't have the information already.
    if (NULL==m_pITINeutral)
    {
		ITypeLib   *pITypeLib = NULL;
        hr=LoadRegTypeLib(LIBID_WmiXMLTransformer, 1, 0, lcid, &pITypeLib);

        if (FAILED(hr))
			return hr;

        //Got the type lib, get type info for the interface we want
        hr=pITypeLib->GetTypeInfoOfGuid(m_GUID, &m_pITINeutral);
        pITypeLib->Release();

        if (FAILED(hr))
            return hr;
    }

    /*
     * Note:  the type library is still loaded since we have
     * an ITypeInfo from it.
     */

    m_pITINeutral->AddRef();
    *ppITypeInfo = m_pITINeutral;
    return NOERROR;
}

SCODE CDispatchHelp::GetIDsOfNames(
      REFIID riid,
      OLECHAR FAR* FAR* rgszNames,
      UINT cNames,
      LCID lcid,
      DISPID FAR* rgdispid)
{
    HRESULT     hr;
    ITypeInfo  *pTI;

    if (IID_NULL!=riid)
        return DISP_E_UNKNOWNINTERFACE;

    //Get the right ITypeInfo for lcid.
    hr=GetTypeInfo(0, lcid, &pTI);

    if (SUCCEEDED(hr))
    {
        hr=DispGetIDsOfNames(pTI, rgszNames, cNames, rgdispid);
        pTI->Release();
    }

    return hr;
}


void ParseDispArgs (DISPPARAMS FAR * dispparams)
{
	if (dispparams)
	{
		int argCount = dispparams->cArgs;

		for (int i = 0; i < argCount; i++)
		{
			VARIANTARG &v = dispparams->rgvarg [i];
		}

		int nargCount = dispparams->cNamedArgs;
	}
}

SCODE CDispatchHelp::Invoke(
      DISPID dispidMember,
      REFIID riid,
      LCID lcid,
      WORD wFlags,
      DISPPARAMS FAR* pdispparams,
      VARIANT FAR* pvarResult,
      EXCEPINFO FAR* pexcepinfo,
      UINT FAR* puArgErr)
{

    HRESULT     hr;
    ITypeInfo  *pTI;
	m_hResult = S_OK;

    if(m_pObj == NULL)
        return WBEM_E_FAILED;

    //riid is supposed to be IID_NULL always
    if (IID_NULL!=riid)
        return DISP_E_UNKNOWNINTERFACE;

    //Get the ITypeInfo for lcid
    hr=GetTypeInfo(0, lcid, &pTI);

    if (FAILED(hr))
        return hr;

	//ParseDispArgs (pdispparams);

	// Reinterpret inbound VT_NULLs as VT_ERRORs
	if (HandleNulls (dispidMember, wFlags))
		MapNulls (pdispparams);

	hr=pTI->Invoke(m_pObj, dispidMember, wFlags,
              pdispparams, pvarResult,
              pexcepinfo, puArgErr);

	if (FAILED(hr))
	{
		// Try the error handler for this object in case it can handle this
		hr = HandleError (dispidMember, wFlags, pdispparams, pvarResult, puArgErr, hr);
	}

	pTI->Release();

	if (FAILED(m_hResult))
	{
		if (NULL != pexcepinfo)
			SetException (pexcepinfo, m_hResult, m_objectName);

		hr = DISP_E_EXCEPTION;
	}

    return hr;
}


void CDispatchHelp::RaiseException (HRESULT hr)
{
	// Store the HRESULT for processing in the Invoke routine
	m_hResult = hr;

	// Set a WMI scripting error on this thread for the client
	ICreateErrorInfo *pCreateErrorInfo = NULL;

	if (SUCCEEDED (CreateErrorInfo (&pCreateErrorInfo)))
	{
		BSTR bsDescr = MapHresultToWmiDescription (hr);
		pCreateErrorInfo->SetDescription (bsDescr);
		SysFreeString (bsDescr);
		pCreateErrorInfo->SetGUID (m_cGUID);
		pCreateErrorInfo->SetSource (m_objectName);

		IErrorInfo *pErrorInfo = NULL;

		if (SUCCEEDED (pCreateErrorInfo->QueryInterface(IID_IErrorInfo, (void**) &pErrorInfo)))
		{
			SetErrorInfo (0, pErrorInfo);
			pErrorInfo->Release ();
		}

		pCreateErrorInfo->Release ();
	}
}


// IDispatchEx methods
HRESULT STDMETHODCALLTYPE CDispatchHelp::GetDispID(
	/* [in] */ BSTR bstrName,
	/* [in] */ DWORD grfdex,
	/* [out] */ DISPID __RPC_FAR *pid)
{
	return GetIDsOfNames(IID_NULL, &((OLECHAR *)bstrName), 1, ENGLISH_LOCALE, pid);
}

//***************************************************************************
//
//  void MapNulls
//
//  Description:
//
//  The passing of a "null" value from script (where "null" in VB/VBS and JS
//	is the keyword null, and is an undefined variable in Perl) may be interpreted
//	by this API as equivalent to a default value for certain method calls.
//
//	This function is used to map VT_NULL dispatch parameters to the VB standard
//	realization of "missing" parameters, i.e. a VT_ERROR value whose scode is
//	DISP_E_PARAMNOTFOUND.
//
//  Parameters:
//
//  pdispparams		the input dispatch parameters
//
//***************************************************************************

void	CDispatchHelp::MapNulls (DISPPARAMS FAR* pdispparams)
{
	if (pdispparams)
	{
		for (unsigned int i = 0; i < pdispparams->cArgs; i++)
		{
			VARIANTARG &v = pdispparams->rgvarg [i];

			if (VT_NULL == V_VT(&v))
			{
				v.vt = VT_ERROR;
				v.scode = DISP_E_PARAMNOTFOUND;
			}
			else if (((VT_VARIANT|VT_BYREF) == V_VT(&v)) &&
					 (VT_NULL == V_VT(v.pvarVal)))
			{
				v.vt = VT_ERROR;
				v.scode = DISP_E_PARAMNOTFOUND;
			}
		}
	}
}


//***************************************************************************
//
//  HRESULT MapHresultToWmiDescription
//
//  Description:
//
//  Thin wrapper around the IWbemStatusCodeText implementation.  Transforms
//	an HRESULT (which may or may not be a WMI-specific error code) into a
//	localized user-friendly description.
//
//  Parameters:
//
//	  hr				HRESULT to map to string
//
// Return Value:
//    BSTR containing the description (or NULL).
//***************************************************************************

BSTR CDispatchHelp::MapHresultToWmiDescription (HRESULT hr)
{
	BSTR bsMessageText = NULL;

	// Used as our error code translator
	IWbemStatusCodeText *pErrorCodeTranslator = NULL;

	HRESULT result = CoCreateInstance (CLSID_WbemStatusCodeText, 0, CLSCTX_INPROC_SERVER,
				IID_IWbemStatusCodeText, (LPVOID *) &pErrorCodeTranslator);

	if (SUCCEEDED (result))
	{
		HRESULT hrCode = hr;

		// Some WBEM success codes become Scripting error codes.

		if (wbemErrTimedout == hr)
			hrCode = WBEM_S_TIMEDOUT;
		else if (wbemErrResetToDefault == hr)
			hrCode = WBEM_S_RESET_TO_DEFAULT;

		HRESULT sc = pErrorCodeTranslator->GetErrorCodeText(
							hrCode, (LCID) 0, 0, &bsMessageText);

		pErrorCodeTranslator->Release ();
	}

	return bsMessageText;
}

//***************************************************************************
//
//  HRESULT SetException
//
//  Description:
//
//  This function fills in an EXECPINFO structure using the supplied HRESULT
//	and object name.  The former is mapped to the Err.Description property,
//	and the latter to the Err.Source property.
//
//  Parameters:
//
//  pExcepInfo		pointer to EXCEPINFO to initialize (must not be NULL)
//	hr				HRESULT to map to string
//	bsObjectName	Name of source object that generated the error
//
// Return Value:
//  HRESULT         S_OK if successful
//***************************************************************************

void CDispatchHelp::SetException (EXCEPINFO *pExcepInfo, HRESULT hr, BSTR bsObjectName)
{
	if (pExcepInfo->bstrDescription)
		SysFreeString (pExcepInfo->bstrDescription);

	pExcepInfo->bstrDescription = MapHresultToWmiDescription (hr);

	if (pExcepInfo->bstrSource)
		SysFreeString (pExcepInfo->bstrSource);

	pExcepInfo->bstrSource = SysAllocString (bsObjectName);
	pExcepInfo->scode = hr;
}


SCODE CDispatchHelp::GetClassInfo(
      ITypeInfo FAR* FAR* ppITypeInfo)
{
    HRESULT     hr;
    
    if (NULL==ppITypeInfo)
        return E_POINTER;

    *ppITypeInfo=NULL;
    
    //Load a type lib if we don't have the information already.
    if (NULL==m_pCITINeutral)
    {
		ITypeLib   *pITypeLib = NULL;
        hr=LoadRegTypeLib(LIBID_WmiXMLTransformer, 1, 0, 0, &pITypeLib);

        if (FAILED(hr))
			return hr;

        //Got the type lib, get type info for the interface we want
        hr=pITypeLib->GetTypeInfoOfGuid(m_cGUID, &m_pCITINeutral);
        pITypeLib->Release();

        if (FAILED(hr))
            return hr;
    }

    /*
     * Note:  the type library is still loaded since we have
     * an ITypeInfo from it.
     */

    m_pCITINeutral->AddRef();
    *ppITypeInfo = m_pCITINeutral;
    return NOERROR; 
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\xmltransport\compiler\control\xmltransf\helper.h ===
#ifndef WMI_XML_TRANSFORMER_HELPER_H
#define WMI_XML_TRANSFORMER_HELPER_H

HRESULT PackageDCOMOutput(IWbemClassObject *pObject, IXMLDOMDocument **ppXMLDocument, 
	WmiXMLEncoding iEncoding, VARIANT_BOOL bQualifierFilter, VARIANT_BOOL bClassOriginFilter,
	VARIANT_BOOL bLocalOnly,
	bool bNamesOnly = false);


// Creates an IWbemCOntext object with the correct context values required for
// conversion of WMI objects to XML for this specific operation
HRESULT CreateFlagsContext(IWbemContext **ppContext, 
			BOOL bIncludeQualifiers, BOOL bLocalOnly, BOOL bIncludeClassOrigin);
HRESULT CreateXMLTranslator(IWbemXMLConvertor **pConvertor);

HRESULT GetIWbemContext(IDispatch *pSet, IWbemContext **ppContext);
// A Helper function for setting a booles value in a context
HRESULT SetBoolProperty(IWbemContext *pContext, LPCWSTR pszName, BOOL bValue);
HRESULT ParseObjectPath(LPCWSTR pszObjectPath, LPWSTR *pszHostName, LPWSTR *pszNamespace, LPWSTR *pszObjectName, bool& bIsClass, bool& bIsHTTP, bool& bIsNovaPath);
HRESULT SaveLPWSTRStreamAsBSTR (IStream *pStream, BSTR *pstr);



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\xmltransport\compiler\control\xmltransf\disphlp.h ===
//***************************************************************************
//
//  cdisphlp.h
//
//  Module: Client side of WBEMS marshalling.
//
//  Purpose: Defines the CDispatchHelper object 
//
//  Copyright (c) 1998-1999 Microsoft Corporation
//
//***************************************************************************


#ifndef _wmi_xml_disphlp_H_
#define _wmi_xml_disphlp_H_

// This class implements the IDispatch interface using a type library.

class CDispatchHelp
{
private:
	BSTR				m_objectName;
	HRESULT				m_hResult;	// Last HRESULT returned from CIMOM call

protected:
        ITypeInfo      *m_pITINeutral;      //Type information for interface
		ITypeInfo	   *m_pCITINeutral;		//Type information for class
        IDispatch      *m_pObj;
        GUID            m_GUID;				// Interface GUID
		GUID            m_cGUID;			// Class GUID
	
		// All the functions from utils.cpp in wbem scripting
		void MapNulls (DISPPARAMS FAR* pdispparams);
		BSTR MapHresultToWmiDescription (HRESULT hr);
		void CDispatchHelp::SetException (EXCEPINFO *pExcepInfo, HRESULT hr, BSTR bsObjectName);
		static const int ENGLISH_LOCALE;
		static const HRESULT wbemErrTimedout;
		static const HRESULT wbemErrResetToDefault;
		/*
		 * May be overriden in subclass to provide bespoke 
		 * handling of exceptions.
		 */
		virtual HRESULT HandleError (
							DISPID dispidMember,
							unsigned short wFlags,
							DISPPARAMS FAR* pdispparams,
							VARIANT FAR* pvarResult,
							UINT FAR* puArgErr,
							HRESULT hRes)
		{
			return hRes;
		}

		/*
		 * May be overriden in subclass to provide
		 * bespoke handling of VT_NULL dispparams.
		 */
		virtual bool HandleNulls (
							DISPID dispidMember,
							unsigned short wFlags)
		{
			// By default treat a VT_NULL as a default
			// value in all methods.
			return 	(wFlags & DISPATCH_METHOD);
		}

public:
        CDispatchHelp();
        virtual ~CDispatchHelp(void);
        void SetObj(IDispatch * pObj, GUID guid, GUID cGuid, LPWSTR objectName);
        void SetObj(IDispatch * pObj, GUID guid, LPWSTR objectName);

	STDMETHOD(GetTypeInfoCount)(THIS_ UINT FAR* pctinfo);

    	STDMETHOD(GetTypeInfo)(
      		THIS_
		UINT itinfo,
      LCID lcid,
      ITypeInfo FAR* FAR* pptinfo);

    STDMETHOD(GetIDsOfNames)(
      THIS_
      REFIID riid,
      OLECHAR FAR* FAR* rgszNames,
      UINT cNames,
      LCID lcid,
      DISPID FAR* rgdispid);

    STDMETHOD(Invoke)(
      THIS_
      DISPID dispidMember,
      REFIID riid,
      LCID lcid,
      WORD wFlags,
      DISPPARAMS FAR* pdispparams,
      VARIANT FAR* pvarResult,
      EXCEPINFO FAR* pexcepinfo,
      UINT FAR* puArgErr);

	// IDispatchEx methods
        HRESULT STDMETHODCALLTYPE GetDispID( 
            /* [in] */ BSTR bstrName,
            /* [in] */ DWORD grfdex,
            /* [out] */ DISPID __RPC_FAR *pid);
        
        /* [local] */ HRESULT STDMETHODCALLTYPE InvokeEx( 
            /* [in] */ DISPID id,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [in] */ DISPPARAMS __RPC_FAR *pdp,
            /* [out] */ VARIANT __RPC_FAR *pvarRes,
            /* [out] */ EXCEPINFO __RPC_FAR *pei,
            /* [unique][in] */ IServiceProvider __RPC_FAR *pspCaller)
		{ 
			UINT uArgErr;
			return Invoke(id, IID_NULL, lcid, wFlags, pdp, pvarRes, pei, &uArgErr); 
		}
        
        HRESULT STDMETHODCALLTYPE DeleteMemberByName( 
            /* [in] */ BSTR bstr,
            /* [in] */ DWORD grfdex)
		{ return S_FALSE; }
        
        HRESULT STDMETHODCALLTYPE DeleteMemberByDispID( 
            /* [in] */ DISPID id)
		{ return S_FALSE; }
        
        HRESULT STDMETHODCALLTYPE GetMemberProperties( 
            /* [in] */ DISPID id,
            /* [in] */ DWORD grfdexFetch,
            /* [out] */ DWORD __RPC_FAR *pgrfdex)
		{ return S_FALSE; }
        
        HRESULT STDMETHODCALLTYPE GetMemberName( 
            /* [in] */ DISPID id,
            /* [out] */ BSTR __RPC_FAR *pbstrName)
		{ return S_FALSE; }
        
        HRESULT STDMETHODCALLTYPE GetNextDispID( 
            /* [in] */ DWORD grfdex,
            /* [in] */ DISPID id,
            /* [out] */ DISPID __RPC_FAR *pid)
		{ return S_FALSE; }
        
        HRESULT STDMETHODCALLTYPE GetNameSpaceParent( 
            /* [out] */ IUnknown __RPC_FAR *__RPC_FAR *ppunk)
		{ return S_FALSE; }

		HRESULT STDMETHODCALLTYPE GetClassInfo(ITypeInfo FAR* FAR* ppITypeInfo);
        

	// Other methods
	void RaiseException (HRESULT hr);
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\xmltransport\compiler\control\xmltransf\docset.h ===
#ifndef WMI_XML_DOC_SET
#define WMI_XML_DOC_SET

// This is a class that implements the ISWbemXMLDocumentSet scriptable interface
// over an IStream. The IStream is assumed to contain a response to an
// Enumeration, Query etc.
class CWbemXMLHTTPDocSet : public ISWbemXMLDocumentSet,
						public ISupportErrorInfo,
						public IEnumVARIANT
{
private:
	MyFactory *m_pFactory; // The factory used to construct objects
	IXMLParser *m_pParser; // The parser used by the factory

protected:
	long					m_cRef;         //Object reference count
	CDispatchHelp			m_Dispatch;		

public:
    
    CWbemXMLHTTPDocSet();
    virtual ~CWbemXMLHTTPDocSet();

    //Non-delegating object IUnknown

    STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppv)
	{
		*ppv=NULL;

		if (IID_IUnknown==riid)
			*ppv = reinterpret_cast<IUnknown*>(this);
		else if (IID_ISWbemXMLDocumentSet==riid)
			*ppv = (ISWbemXMLDocumentSet *)this;
		else if (IID_ISupportErrorInfo==riid)
			*ppv = (ISupportErrorInfo *)this;
		else if (IID_IDispatch==riid)
			*ppv = (IDispatch *)this;
		else if (IID_IEnumVARIANT==riid)
			*ppv = (IEnumVARIANT *)this;

		if (NULL!=*ppv)
		{
			((LPUNKNOWN)*ppv)->AddRef();
			return NOERROR;
		}

		return ResultFromScode(E_NOINTERFACE);
	}

	STDMETHODIMP_(ULONG) AddRef(void)
	{
		InterlockedIncrement(&m_cRef);
		return m_cRef;
	}

	STDMETHODIMP_(ULONG) Release(void)
	{
		InterlockedDecrement(&m_cRef);
		if (0L!=m_cRef)
			return m_cRef;
		delete this;
		return 0;
	}

	// IDispatch
	STDMETHODIMP		GetTypeInfoCount(UINT* pctinfo)
		{return  m_Dispatch.GetTypeInfoCount(pctinfo);}
    STDMETHODIMP		GetTypeInfo(UINT itinfo, LCID lcid, ITypeInfo** pptinfo)
		{return m_Dispatch.GetTypeInfo(itinfo, lcid, pptinfo);}
    STDMETHODIMP		GetIDsOfNames(REFIID riid, OLECHAR** rgszNames, 
							UINT cNames, LCID lcid, DISPID* rgdispid)
		{return m_Dispatch.GetIDsOfNames(riid, rgszNames, cNames,
                          lcid,
                          rgdispid);}
    STDMETHODIMP		Invoke(DISPID dispidMember, REFIID riid, LCID lcid, 
							WORD wFlags, DISPPARAMS* pdispparams, VARIANT* pvarResult, 
									EXCEPINFO* pexcepinfo, UINT* puArgErr)
		{return m_Dispatch.Invoke(dispidMember, riid, lcid, wFlags,
                        pdispparams, pvarResult, pexcepinfo, puArgErr);}

	// Collection methods
	HRESULT STDMETHODCALLTYPE get__NewEnum
	(
		/*[out]*/	IUnknown **ppUnk
	);
	HRESULT STDMETHODCALLTYPE get_Count
	(
		/*[out]*/	long	*plCount
	);
    HRESULT STDMETHODCALLTYPE Item
	(
        /*[in]*/	BSTR objectPath,
        /*[in]*/	long lFlags,
        /*[out]*/	IXMLDOMDocument **ppDocument
    );        

	// IEnumVARIANT methods
	HRESULT STDMETHODCALLTYPE Reset 
	();

    HRESULT STDMETHODCALLTYPE Next
	(
        /*[in]*/	unsigned long celt,
		/*[out]*/	VARIANT FAR *rgvar,
        /*[out]*/	unsigned long FAR *pceltFetched
    );

	HRESULT STDMETHODCALLTYPE Clone
	(
        /*[out]*/	IEnumVARIANT **ppEnum
    );

	HRESULT STDMETHODCALLTYPE Skip
	(
        /*[in]*/	unsigned long celt
    );

	// ISupportErrorInfo methods
	HRESULT STDMETHODCALLTYPE InterfaceSupportsErrorInfo 
	(
		/* [in] */ REFIID riid
	);

	HRESULT STDMETHODCALLTYPE NextDocument (IXMLDOMDocument **ppDoc);
	HRESULT STDMETHODCALLTYPE SkipNextDocument ();

	HRESULT Initialize(IStream *pStream, LPCWSTR *ppszElementNames, DWORD dwElementCount);
};

// This is a class that implements the ISWbemXMLDocumentSet scriptable interface
// over an IEnumWbemClassObject. T
class CWbemDCOMDocSet : public ISWbemXMLDocumentSet,
						public ISupportErrorInfo,
						public IEnumVARIANT
{
private:
	IEnumWbemClassObject *m_pEnum;
	VARIANT_BOOL m_bLocalOnly;
	VARIANT_BOOL m_bIncludeQualifiers;
	VARIANT_BOOL m_bIncludeClassOrigin;
	bool m_bNamesOnly;
	WmiXMLEncoding m_iEncoding;

protected:
	long            m_cRef;         //Object reference count
	CDispatchHelp			m_Dispatch;		

public:
    
	CWbemDCOMDocSet();
	virtual ~CWbemDCOMDocSet();

    //Non-delegating object IUnknown
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppv)
	{
		*ppv=NULL;

		if (IID_IUnknown==riid)
			*ppv = reinterpret_cast<IUnknown*>(this);
		else if (IID_ISWbemXMLDocumentSet==riid)
			*ppv = (ISWbemXMLDocumentSet *)this;
		else if (IID_ISupportErrorInfo==riid)
			*ppv = (ISupportErrorInfo *)this;
		else if (IID_IDispatch==riid)
			*ppv = (IDispatch *)this;
		else if (IID_IEnumVARIANT==riid)
			*ppv = (IEnumVARIANT *)this;

		if (NULL!=*ppv)
		{
			((LPUNKNOWN)*ppv)->AddRef();
			return NOERROR;
		}

		return ResultFromScode(E_NOINTERFACE);
	}

	STDMETHODIMP_(ULONG) AddRef(void)
	{
		InterlockedIncrement(&m_cRef);
		return m_cRef;
	}

	STDMETHODIMP_(ULONG) Release(void)
	{
		InterlockedDecrement(&m_cRef);
		if (0L!=m_cRef)
			return m_cRef;
		delete this;
		return 0;
	}

	// IDispatch
	STDMETHODIMP		GetTypeInfoCount(UINT* pctinfo)
		{return  m_Dispatch.GetTypeInfoCount(pctinfo);}
    STDMETHODIMP		GetTypeInfo(UINT itinfo, LCID lcid, ITypeInfo** pptinfo)
		{return m_Dispatch.GetTypeInfo(itinfo, lcid, pptinfo);}
    STDMETHODIMP		GetIDsOfNames(REFIID riid, OLECHAR** rgszNames, 
							UINT cNames, LCID lcid, DISPID* rgdispid)
		{return m_Dispatch.GetIDsOfNames(riid, rgszNames, cNames,
                          lcid,
                          rgdispid);}
    STDMETHODIMP		Invoke(DISPID dispidMember, REFIID riid, LCID lcid, 
							WORD wFlags, DISPPARAMS* pdispparams, VARIANT* pvarResult, 
									EXCEPINFO* pexcepinfo, UINT* puArgErr)
		{return m_Dispatch.Invoke(dispidMember, riid, lcid, wFlags,
                        pdispparams, pvarResult, pexcepinfo, puArgErr);}

	// Collection methods
	HRESULT STDMETHODCALLTYPE get__NewEnum
	(
		/*[out]*/	IUnknown **ppUnk
	);
	HRESULT STDMETHODCALLTYPE get_Count
	(
		/*[out]*/	long	*plCount
	);
    HRESULT STDMETHODCALLTYPE Item
	(
        /*[in]*/	BSTR objectPath,
        /*[in]*/	long lFlags,
        /*[out]*/	IXMLDOMDocument **ppDocument
    );        

	// IEnumVARIANT methods
	HRESULT STDMETHODCALLTYPE Reset 
	();

    HRESULT STDMETHODCALLTYPE Next
	(
        /*[in]*/	unsigned long celt,
		/*[out]*/	VARIANT FAR *rgvar,
        /*[out]*/	unsigned long FAR *pceltFetched
    );

	HRESULT STDMETHODCALLTYPE Clone
	(
        /*[out]*/	IEnumVARIANT **ppEnum
    );

	HRESULT STDMETHODCALLTYPE Skip
	(
        /*[in]*/	unsigned long celt
    );

	// ISupportErrorInfo methods
	HRESULT STDMETHODCALLTYPE InterfaceSupportsErrorInfo 
	(
		/* [in] */ REFIID riid
	);

	// Other methods
	HRESULT STDMETHODCALLTYPE NextDocument (IXMLDOMDocument **ppDoc);
	HRESULT STDMETHODCALLTYPE SkipNextDocument ();

	HRESULT Initialize(IEnumWbemClassObject *pEnum,
						WmiXMLEncoding iEncoding,
						VARIANT_BOOL bIncludeQualifiers,
						VARIANT_BOOL bIncludeClassOrigin,
						VARIANT_BOOL bLocalOnly,
						bool bNamesOnly);
};




#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\xmltransport\compiler\control\xmltransf\httpops.cpp ===
#include "precomp.h"
#include <objsafe.h>
#include <wbemcli.h>
#include <wbemdisp.h>
#include <wininet.h>
#include <msxml.h>

#include "xmltrnsf.h"
#include "XMLTransportClientHelper.h"
#include "XMLClientPacket.h"
#include "XMLClientPacketFactory.h"
#include "HTTPConnectionAgent.h"
#include "httpops.h"
#include "urlparser.h"
#include "helper.h"

HRESULT HttpGetObject (
	LPCWSTR	pszUserName,
	LPCWSTR pszPassword,
	WmiXMLEncoding iEncoding,
	VARIANT_BOOL bQualifierFilter,
	VARIANT_BOOL bClassOriginFilter,
	VARIANT_BOOL bLocalOnly,
	LPCWSTR pszLocale,
	LPCWSTR pszObjectPath,
	bool bIsNovaPath,
	LPCWSTR pszHostURL,
	LPCWSTR pszNamespace,
	LPCWSTR pszObjectName,
	bool bIsClass,
	IWbemContext *pContext,
	IStream **ppXMLDocument)
{
	// Create and Initialize the HTTP Connection Agent
	CHTTPConnectionAgent cConnectionAgent;
	HRESULT hr = E_FAIL;
	if(SUCCEEDED(hr = cConnectionAgent.InitializeConnection(pszHostURL, pszUserName, pszPassword)))
	{
		// Create A Packet factory for creating the HTTP packet and HTTP Headers.
		CXMLClientPacketFactory  oXMLClientPacketFactory;
		// RAJESHR use the bAllowWMIExtensions to set the MicrosoftWMI: HTTP header
		// LocalOnly and IncludeQualifiers are true by default (CIM Spec), IncludeClassOrigin is
		// passed as true here as there is no flag that could turn it on
		CXMLClientPacket *pPacketClass = NULL;
		if(pPacketClass = oXMLClientPacketFactory.CreateXMLPacket(
			pszLocale,
			(bIsClass)? L"GetClass" :  L"GetInstance", 
			pszObjectName, pszNamespace, pContext,
			(bLocalOnly == VARIANT_TRUE) ? true : false,
			(bQualifierFilter == VARIANT_TRUE) ? true : false,
			false, // Deep - Unused
			(bClassOriginFilter == VARIANT_TRUE) ? true : false))
		{
			if(SUCCEEDED(hr = SendPacket(&cConnectionAgent, pPacketClass)))
			{
				hr = HandleFilteringAndOutput(&cConnectionAgent, ppXMLDocument);
			}
			delete pPacketClass;
		}
	}
	return hr;
}

HRESULT HttpDeleteClass(
	LPCWSTR	pszUserName,
	LPCWSTR pszPassword,
	LPCWSTR pszLocale,
	LPCWSTR pszHostURL,
	LPCWSTR pszNamespace,
	LPCWSTR pszClassName,
	IWbemContext *pContext)
{
	// Create and Initialize the HTTP Connection Agent
	CHTTPConnectionAgent cConnectionAgent;
	HRESULT hr = E_FAIL;
	if(SUCCEEDED(hr = cConnectionAgent.InitializeConnection(pszHostURL, pszUserName, pszPassword)))
	{
		// Create A Packet factory for creating the HTTP packet and HTTP Headers.
		CXMLClientPacketFactory  oXMLClientPacketFactory;
		// RAJESHR use the bAllowWMIExtensions to set the MicrosoftWMI: HTTP header
		// LocalOnly and IncludeQualifiers are true by default (CIM Spec), IncludeClassOrigin is
		// passed as true here as there is no flag that could turn it on
		CXMLClientPacket *pPacketClass = NULL;
		if(pPacketClass = oXMLClientPacketFactory.CreateXMLPacket(
			pszLocale,
			L"DeleteClass", 
			pszClassName, pszNamespace, pContext,
			false,
			false,
			false, // Deep - Unused
			false))
		{
			if(SUCCEEDED(hr = SendPacket(&cConnectionAgent, pPacketClass)))
			{
				hr = HandleFilteringAndOutput(&cConnectionAgent, NULL);
			}
			delete pPacketClass;
		}
	}
	return hr;
}

HRESULT HttpExecQuery (
	LPCWSTR	pszUserName,
	LPCWSTR pszPassword,
	WmiXMLEncoding iEncoding,
	VARIANT_BOOL bQualifierFilter,
	VARIANT_BOOL bClassOriginFilter,
	LPCWSTR pszLocale,
	LPCWSTR pszNamespacePath,
	LPCWSTR pszHostURL,
	LPCWSTR pszNamespace,
	LPCWSTR pszQuery,
	LPCWSTR pszQueryLanguage,
	IWbemContext *pContext,
	IStream **ppXMLDocument)
{
	// Create and Initialize the HTTP Connection Agent
	CHTTPConnectionAgent cConnectionAgent;
	HRESULT hr = E_FAIL;
	if(SUCCEEDED(hr = cConnectionAgent.InitializeConnection(pszHostURL, pszUserName, pszPassword)))
	{
		// Create A Packet factory for creating the HTTP packet and HTTP Headers.
		CXMLClientPacketFactory  oXMLClientPacketFactory;
		// RAJESHR use the bAllowWMIExtensions to set the MicrosoftWMI: HTTP header
		//LocalOnly and IncludeQualifiers are true by default (CIM Spec), IncludeClassOrigin is
		//passes as true here as there is no flag that could turn it on
		CXMLClientPacket *pPacketClass = NULL;
		if(pPacketClass = oXMLClientPacketFactory.CreateXMLPacket(
			pszLocale,
			L"ExecQuery",
			NULL, pszNamespace, pContext,
			false, // LocalOnly - unused
			(bQualifierFilter == VARIANT_TRUE) ? true : false,
			false, // Deep - Unused
			(bClassOriginFilter == VARIANT_TRUE) ? true : false))
		{
			// Set the Query Language and String
			if(SUCCEEDED(hr = pPacketClass->SetQueryLanguage(L"WQL")))
			{
				if(SUCCEEDED(hr = pPacketClass->SetQueryString(pszQuery)))
				{
					if(SUCCEEDED(hr = SendPacket(&cConnectionAgent, pPacketClass)))
					{
						hr = HandleFilteringAndOutput(&cConnectionAgent, ppXMLDocument);
					}
				}
			}
			delete pPacketClass;
		}
	}
	return hr;
}


HRESULT HttpEnumClass (
	LPCWSTR	pszUserName,
	LPCWSTR pszPassword,
	WmiXMLEncoding iEncoding,
	VARIANT_BOOL bQualifierFilter,
	VARIANT_BOOL bClassOriginFilter,
	VARIANT_BOOL bLocalOnly,
	LPCWSTR pszLocale,
	LPCWSTR pszSuperClassPath,
	LPCWSTR pszHostURL,
	LPCWSTR pszNamespace,
	LPCWSTR pszObjectName,
	VARIANT_BOOL bDeep,
	IWbemContext *pContext,
	IStream **ppXMLDocument)
{
	// Create and Initialize the HTTP Connection Agent
	CHTTPConnectionAgent cConnectionAgent;
	HRESULT hr = E_FAIL;
	if(SUCCEEDED(hr = cConnectionAgent.InitializeConnection(pszHostURL, pszUserName, pszPassword)))
	{
		// Create A Packet factory for creating the HTTP packet and HTTP Headers.
		CXMLClientPacketFactory  oXMLClientPacketFactory;
		// RAJESHR use the bAllowWMIExtensions to set the MicrosoftWMI: HTTP header
		//LocalOnly and IncludeQualifiers are true by default (CIM Spec), IncludeClassOrigin is
		//passes as true here as there is no flag that could turn it on
		CXMLClientPacket *pPacketClass = NULL;
		if(pPacketClass = oXMLClientPacketFactory.CreateXMLPacket(
			pszLocale,
			L"EnumerateClasses",
			pszObjectName, pszNamespace, pContext,
			(bLocalOnly == VARIANT_TRUE) ? true : false,
			(bQualifierFilter == VARIANT_TRUE) ? true : false,
			(bDeep == VARIANT_TRUE)? true : false,
			(bClassOriginFilter == VARIANT_TRUE) ? true : false))
		{
			if(SUCCEEDED(hr = SendPacket(&cConnectionAgent, pPacketClass)))
			{
				hr = HandleFilteringAndOutput(&cConnectionAgent, ppXMLDocument);
			}
			delete pPacketClass;
		}
	}
	return hr;
}

HRESULT HttpEnumInstance (
	LPCWSTR	pszUserName,
	LPCWSTR pszPassword,
	WmiXMLEncoding iEncoding,
	VARIANT_BOOL bQualifierFilter,
	VARIANT_BOOL bClassOriginFilter,
	VARIANT_BOOL bLocalOnly,
	LPCWSTR pszLocale,
	LPCWSTR pszClassPath,
	LPCWSTR pszHostURL,
	LPCWSTR pszNamespace,
	LPCWSTR pszObjectName,
	VARIANT_BOOL bDeep,
	IWbemContext *pContext,
	IStream **ppXMLDocument)
{
	// Create and Initialize the HTTP Connection Agent
	CHTTPConnectionAgent cConnectionAgent;
	HRESULT hr = E_FAIL;
	if(SUCCEEDED(hr = cConnectionAgent.InitializeConnection(pszHostURL, pszUserName, pszPassword)))
	{
		// Create A Packet factory for creating the HTTP packet and HTTP Headers.
		CXMLClientPacketFactory  oXMLClientPacketFactory;
		// RAJESHR use the bAllowWMIExtensions to set the MicrosoftWMI: HTTP header
		//LocalOnly and IncludeQualifiers are true by default (CIM Spec), IncludeClassOrigin is
		//passes as true here as there is no flag that could turn it on
		CXMLClientPacket *pPacketClass = NULL;
		if(pPacketClass = oXMLClientPacketFactory.CreateXMLPacket(
			pszLocale,
			L"EnumerateInstances",
			pszObjectName, pszNamespace, pContext,
			(bLocalOnly == VARIANT_TRUE) ? true : false,
			(bQualifierFilter == VARIANT_TRUE) ? true : false,
			(bDeep == VARIANT_TRUE)? true : false,
			(bClassOriginFilter == VARIANT_TRUE) ? true : false))
		{
			if(SUCCEEDED(hr = SendPacket(&cConnectionAgent, pPacketClass)))
			{
				hr = HandleFilteringAndOutput(&cConnectionAgent, ppXMLDocument);
			}
			delete pPacketClass;
		}
	}
	return hr;
}

HRESULT HttpEnumClassNames (
	LPCWSTR	pszUserName,
	LPCWSTR pszPassword,
	WmiXMLEncoding iEncoding,
	LPCWSTR pszLocale,
	LPCWSTR pszSuperClassPath,
	LPCWSTR pszHostURL,
	LPCWSTR pszNamespace,
	LPCWSTR pszObjectName,
	VARIANT_BOOL bDeep,
	IWbemContext *pContext,
	IStream **ppXMLDocument)
{
	// Create and Initialize the HTTP Connection Agent
	CHTTPConnectionAgent cConnectionAgent;
	HRESULT hr = E_FAIL;
	if(SUCCEEDED(hr = cConnectionAgent.InitializeConnection(pszHostURL, pszUserName, pszPassword)))
	{
		// Create A Packet factory for creating the HTTP packet and HTTP Headers.
		CXMLClientPacketFactory  oXMLClientPacketFactory;
		// RAJESHR use the bAllowWMIExtensions to set the MicrosoftWMI: HTTP header
		//LocalOnly and IncludeQualifiers are true by default (CIM Spec), IncludeClassOrigin is
		//passes as true here as there is no flag that could turn it on
		CXMLClientPacket *pPacketClass = NULL;
		if(pPacketClass = oXMLClientPacketFactory.CreateXMLPacket(
			pszLocale,
			L"EnumerateClassNames",
			pszObjectName, pszNamespace, pContext,
			false,
			false,
			(bDeep == VARIANT_TRUE)? true : false,
			false))
		{
			if(SUCCEEDED(hr = SendPacket(&cConnectionAgent, pPacketClass)))
			{
				hr = HandleFilteringAndOutput(&cConnectionAgent, ppXMLDocument);
			}
			delete pPacketClass;
		}
	}
	return hr;
}

HRESULT HttpEnumInstanceNames (
	LPCWSTR	pszUserName,
	LPCWSTR pszPassword,
	WmiXMLEncoding iEncoding,
	LPCWSTR pszLocale,
	LPCWSTR pszClassPath,
	LPCWSTR pszHostURL,
	LPCWSTR pszNamespace,
	LPCWSTR pszObjectName,
	IWbemContext *pContext,
	IStream **ppXMLDocument)
{
	// Create and Initialize the HTTP Connection Agent
	CHTTPConnectionAgent cConnectionAgent;
	HRESULT hr = E_FAIL;
	if(SUCCEEDED(hr = cConnectionAgent.InitializeConnection(pszHostURL, pszUserName, pszPassword)))
	{
		// Create A Packet factory for creating the HTTP packet and HTTP Headers.
		CXMLClientPacketFactory  oXMLClientPacketFactory;
		// RAJESHR use the bAllowWMIExtensions to set the MicrosoftWMI: HTTP header
		//LocalOnly and IncludeQualifiers are true by default (CIM Spec), IncludeClassOrigin is
		//passes as true here as there is no flag that could turn it on
		CXMLClientPacket *pPacketClass = NULL;
		if(pPacketClass = oXMLClientPacketFactory.CreateXMLPacket(
			pszLocale,
			L"EnumerateInstanceNames",
			pszObjectName, pszNamespace, pContext,
			false,
			false,
			false,
			false))
		{
			if(SUCCEEDED(hr = SendPacket(&cConnectionAgent, pPacketClass)))
			{
				hr = HandleFilteringAndOutput(&cConnectionAgent, ppXMLDocument);
			}
			delete pPacketClass;
		}
	}
	return hr;
}

HRESULT HttpPutClass (
	LPCWSTR	pszUserName,
	LPCWSTR pszPassword,
	LPCWSTR pszLocale,
	LPCWSTR pszNamespacePath,
	LONG lClassFlags,
	IXMLDOMElement *pClassElement,
	IWbemContext *pContext,
	BSTR *pstrErrors)
{
	return HttpGeneralPut(L"CreateClass", pszUserName, pszPassword, pszLocale, pszNamespacePath, lClassFlags, pClassElement, pContext, pstrErrors);
}

HRESULT HttpModifyClass (
	LPCWSTR	pszUserName,
	LPCWSTR pszPassword,
	LPCWSTR pszLocale,
	LPCWSTR pszNamespacePath,
	LONG lClassFlags,
	IXMLDOMElement *pClassElement,
	IWbemContext *pContext,
	BSTR *pstrErrors)
{
	return HttpGeneralPut(L"CreateClass", pszUserName, pszPassword, pszLocale, pszNamespacePath, lClassFlags, pClassElement, pContext, pstrErrors);
}


HRESULT HttpPutInstance (
	LPCWSTR	pszUserName,
	LPCWSTR pszPassword,
	LPCWSTR pszLocale,
	LPCWSTR pszNamespacePath,
	LONG lClassFlags,
	IXMLDOMElement *pClassElement,
	IWbemContext *pContext,
	BSTR *pstrErrors)
{
	return HttpGeneralPut(L"CreateInstance", pszUserName, pszPassword, pszLocale, pszNamespacePath, lClassFlags, pClassElement, pContext, pstrErrors);
}

HRESULT HttpModifyInstance (
	LPCWSTR	pszUserName,
	LPCWSTR pszPassword,
	LPCWSTR pszLocale,
	LPCWSTR pszNamespacePath,
	LONG lClassFlags,
	IXMLDOMElement *pClassElement,
	IWbemContext *pContext,
	BSTR *pstrErrors)
{
	return HttpGeneralPut(L"ModifyInstance", pszUserName, pszPassword, pszLocale, pszNamespacePath, lClassFlags, pClassElement, pContext, pstrErrors);
}

HRESULT HttpGeneralPut (
	LPCWSTR pszMethodName,
	LPCWSTR	pszUserName,
	LPCWSTR pszPassword,
	LPCWSTR pszLocale,
	LPCWSTR pszNamespacePath,
	LONG lClassFlags,
	IXMLDOMElement *pClassElement,
	IWbemContext *pContext,
	BSTR *pstrErrors)
{
	// Create and Initialize the HTTP Connection Agent
	CHTTPConnectionAgent cConnectionAgent;
	HRESULT hr = E_FAIL;
	LPWSTR pszHostURL = NULL, pszNamespaceName = NULL, pszObjectName = NULL;
	bool bClass = true;
	bool bIsHTTP = true;
	bool bIsNovaPath = true;
	if(SUCCEEDED(hr = ParseObjectPath(pszNamespacePath, &pszHostURL, &pszNamespaceName, &pszObjectName, bClass, bIsHTTP, bIsNovaPath)))
	{
		if(SUCCEEDED(hr = cConnectionAgent.InitializeConnection(pszHostURL, pszUserName, pszPassword)))
		{
			// Create A Packet factory for creating the HTTP packet and HTTP Headers.
			CXMLClientPacketFactory  oXMLClientPacketFactory;
			// RAJESHR use the bAllowWMIExtensions to set the MicrosoftWMI: HTTP header
			//LocalOnly and IncludeQualifiers are true by default (CIM Spec), IncludeClassOrigin is
			//passes as true here as there is no flag that could turn it on
			CXMLClientPacket *pPacketClass = NULL;
			if(pPacketClass = oXMLClientPacketFactory.CreateXMLPacket(
				pszLocale,
				pszMethodName,
				NULL,
				pszNamespaceName,
				pContext))
			{
				// Get the XML Representation of the object
				BSTR strObject = NULL;
				if(SUCCEEDED(hr = pClassElement->get_xml(&strObject)))
				{
					WCHAR *pszBody = NULL;
					DWORD dwPacketSize = 0;
					if(SUCCEEDED(hr = pPacketClass->GetBodyDirect(strObject, SysStringLen(strObject), &pszBody, &dwPacketSize)))
					{
						if(SUCCEEDED(hr = SendBody(&cConnectionAgent, pPacketClass, pszBody, dwPacketSize)))
						{
							// Check the HTTP status of the response
							DWORD dwHttpStatus = 0;
							if(SUCCEEDED(hr = cConnectionAgent.GetStatusCode(&dwHttpStatus)))
							{
								if(dwHttpStatus == 200)
								{
									// Just look at the result
									IStream *pResponse = NULL;
									if(SUCCEEDED(hr = cConnectionAgent.GetResultBodyCompleteAsIStream(&pResponse)))
									{
										pResponse->Release();
									}
								}
							}
						}
						
						delete [] pszBody;
					}
					SysFreeString(strObject);
				}
				delete pPacketClass;
			}
			else
				hr = E_FAIL;
		}
		delete [] pszHostURL;
		delete [] pszNamespaceName;
		delete [] pszObjectName;
	}
	return hr;
}


HRESULT SendPacket(CHTTPConnectionAgent *pConnectionAgent, CXMLClientPacket *pPacketClass)
{
	HRESULT hr = S_OK;
	DWORD dwResultStatus = 0;

	//start with "M-POST", if server doesnt accept then try "POST" - fail only after..
	//in compliance with HTTP RFC

	if(SUCCEEDED(hr = SendPacketForMethod(pConnectionAgent, 2, pPacketClass, &dwResultStatus)))
	{
		if((dwResultStatus == 501)||(dwResultStatus == 510/*Not Extended*/))
		{
			hr = SendPacketForMethod(pConnectionAgent, 1, pPacketClass,&dwResultStatus);
		}
	}

	return hr;
}

HRESULT SendBody(CHTTPConnectionAgent *pConnectionAgent, CXMLClientPacket *pPacketClass, LPWSTR pszBody, DWORD dwBodyLength)
{
	HRESULT hr = S_OK;
	DWORD dwResultStatus = 0;

	//start with "M-POST", if server doesnt accept then try "POST" - fail only after..
	//in compliance with HTTP RFC

	if(SUCCEEDED(hr = SendPacketForMethodWithBody(pConnectionAgent, 2, pPacketClass, pszBody, dwBodyLength, &dwResultStatus)))
	{
		if((dwResultStatus == 501)||(dwResultStatus == 510/*Not Extended*/))
		{
			hr = SendPacketForMethodWithBody(pConnectionAgent, 1, pPacketClass, pszBody, dwBodyLength, &dwResultStatus);
		}
	}

	return hr;
}


HRESULT	SendPacketForMethod(CHTTPConnectionAgent *pConnectionAgent, int iPostType/*1 for POST, 2 for M-POST*/, CXMLClientPacket *pPacketClass, DWORD *pdwResultStatus)
{
	HRESULT hr = S_OK;
	WCHAR *pwszHeader = NULL;
	WCHAR *pwszBody = NULL;

	do
	{
		if(NULL == pdwResultStatus)
		{
			hr = E_INVALIDARG;
			break;
		}

		*pdwResultStatus = 0;
		pPacketClass->SetPostType(iPostType);
		if((hr = pPacketClass->GetHeader(&pwszHeader)) != S_OK)
			break;
		DWORD dwBodySize = 0;
		if((hr = pPacketClass->GetBody(&pwszBody, &dwBodySize)) != S_OK)
			break;
		if((hr = pConnectionAgent->Send((iPostType == 1)? L"POST" : L"M-POST", 
									pwszHeader,
									pwszBody, 
									dwBodySize))!= S_OK)
			break;
		pConnectionAgent->GetStatusCode(pdwResultStatus);

	}while(0);

	delete [] pwszHeader;
	delete [] pwszBody;

	return hr;
}

HRESULT	SendPacketForMethodWithBody(CHTTPConnectionAgent *pConnectionAgent, int iPostType/*1 for POST, 2 for M-POST*/, CXMLClientPacket *pPacketClass, LPWSTR pwszBody, DWORD dwBodySize, DWORD *pdwResultStatus)
{
	HRESULT hr = S_OK;
	WCHAR *pwszHeader = NULL;

	do
	{
		if(NULL == pdwResultStatus)
		{
			hr = E_INVALIDARG;
			break;
		}

		*pdwResultStatus = 0;
		pPacketClass->SetPostType(iPostType);
		if((hr = pPacketClass->GetHeader(&pwszHeader)) != S_OK)
			break;
		if((hr = pConnectionAgent->Send((iPostType == 1)? L"POST" : L"M-POST", pwszHeader, pwszBody, dwBodySize))!= S_OK)
			break;
		pConnectionAgent->GetStatusCode(pdwResultStatus);

	}while(0);

	delete [] pwszHeader;

	return hr;
}

HRESULT HandleFilteringAndOutput(CHTTPConnectionAgent *pResultAgent, IStream **ppXMLDocument)
{
	// Check the HTTP status of the response
	DWORD dwHttpStatus = 0;
	HRESULT hr = E_FAIL;
	if(SUCCEEDED(hr = pResultAgent->GetStatusCode(&dwHttpStatus)))
	{
		if(dwHttpStatus == 200)
		{
			// For now, just package the result
			*ppXMLDocument = NULL;
			if(SUCCEEDED(hr = pResultAgent->GetResultBodyWrappedAsIStream(ppXMLDocument)))
			{
			}
		}
		else
			hr = MapHttpErrtoWbemErr(dwHttpStatus);
	}
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\xmltransport\compiler\control\xmltransf\makefile.inc ===
############################################################################
#
#   Copyright (C) 1999, Microsoft Corporation.
#
#   All rights reserved.
#
############################################################################

!INCLUDE $(_NTDRIVE)$(_NTROOT)\WMI\COMMON\makefile.cmn
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\xmltransport\compiler\control\xmltransf\enumpriv.cpp ===
//***************************************************************************
//
//  Copyright (c) 1998-1999 Microsoft Corporation
//
//  ENUMOBJ.CPP
//
//  alanbos  15-Aug-96   Created.
//
//  Defines the implementation of ISWbemObjectSet
//
//***************************************************************************

#include <tchar.h>
#include "precomp.h"
#include <map>
#include <vector>
#include <wmiutils.h>
#include <wbemdisp.h>
#include <ocidl.h>
#include "disphlp.h"
#include "privilege.h"

#ifndef _UNICODE
#include <mbstring.h>
#endif

//***************************************************************************
//
//  CSWbemPrivilegeSet::CSWbemPrivilegeSet
//
//  DESCRIPTION:
//
//  Constructor.
//
//***************************************************************************

CSWbemPrivilegeSet::CSWbemPrivilegeSet()
{
	m_Dispatch.SetObj (this, IID_ISWbemPrivilegeSet, 
						CLSID_SWbemPrivilegeSet, L"SWbemPrivilegeSet");
    m_cRef=1;
	m_bMutable = true;
	InterlockedIncrement(&g_cObj);
}

CSWbemPrivilegeSet::CSWbemPrivilegeSet(
	const CSWbemPrivilegeSet &privSet,
	bool bMutable
)
{
	m_Dispatch.SetObj (this, IID_ISWbemPrivilegeSet, 
						CLSID_SWbemPrivilegeSet, L"SWbemPrivilegeSet");
    m_cRef=1;
	m_bMutable = bMutable;

	// Copy the contents of the supplied Privilege set to this set
	PrivilegeMap::const_iterator next = privSet.m_PrivilegeMap.begin ();

	while (next != privSet.m_PrivilegeMap.end ())
	{
		WbemPrivilegeEnum iPrivilege = (*next).first;
		CSWbemPrivilege *pPrivilege = (*next).second;
		pPrivilege->AddRef ();

		m_PrivilegeMap.insert 
			(PrivilegeMap::value_type(iPrivilege, pPrivilege));

		next++;
	}

	InterlockedIncrement(&g_cObj);
}

CSWbemPrivilegeSet::CSWbemPrivilegeSet(
	ISWbemPrivilegeSet *pPrivilegeSet
)
{
	m_Dispatch.SetObj (this, IID_ISWbemPrivilegeSet, 
						CLSID_SWbemPrivilegeSet, L"SWbemPrivilegeSet");
    m_cRef=1;
	m_bMutable = true;

	// Copy the contents of the supplied Privilege set to this set
	if (pPrivilegeSet)
	{
		IUnknown *pUnk = NULL;

		if (SUCCEEDED(pPrivilegeSet->get__NewEnum (&pUnk)))
		{
			IEnumVARIANT	*pNewEnum = NULL;

			if (SUCCEEDED(pUnk->QueryInterface(IID_IEnumVARIANT, (void**) &pNewEnum)))
			{
				VARIANT var;
				VariantInit (&var);
				ULONG lFetched = 0;

				while (S_OK == pNewEnum->Next(1, &var, &lFetched))
				{
					if (VT_DISPATCH == V_VT(&var))
					{
						ISWbemPrivilege *pISWbemPrivilege = NULL;

						if (SUCCEEDED((var.pdispVal)->QueryInterface (IID_ISWbemPrivilege, 
										(void**) &pISWbemPrivilege)))
						{
							WbemPrivilegeEnum iPrivilege;
							VARIANT_BOOL	bIsEnabled;
							ISWbemPrivilege *pDummy = NULL;

							pISWbemPrivilege->get_Identifier (&iPrivilege);
							pISWbemPrivilege->get_IsEnabled (&bIsEnabled);

							if (SUCCEEDED (Add (iPrivilege, bIsEnabled, &pDummy)))
								pDummy->Release ();
							
							pISWbemPrivilege->Release ();
						}
					}

					VariantClear (&var);
				}

				VariantClear (&var);
				pNewEnum->Release ();
			}

			pUnk->Release ();
		}
	}
	InterlockedIncrement(&g_cObj);
}


//***************************************************************************
//
//  CSWbemPrivilegeSet::~CSWbemPrivilegeSet
//
//  DESCRIPTION:
//
//  Destructor.
//  
//***************************************************************************

CSWbemPrivilegeSet::~CSWbemPrivilegeSet(void)
{
	PrivilegeMap::iterator next; 
	
	while ((next = m_PrivilegeMap.begin ()) != m_PrivilegeMap.end ())
	{
		CSWbemPrivilege *pPrivilege = (*next).second;
		next = m_PrivilegeMap.erase (next);
		pPrivilege->Release ();
	}

	InterlockedDecrement(&g_cObj);
}

//***************************************************************************
// HRESULT CSWbemPrivilegeSet::QueryInterface
// long CSWbemPrivilegeSet::AddRef
// long CSWbemPrivilegeSet::Release
//
// DESCRIPTION:
//
// Standard Com IUNKNOWN functions.
//
//***************************************************************************

STDMETHODIMP CSWbemPrivilegeSet::QueryInterface (

	IN REFIID riid,
    OUT LPVOID *ppv
)
{
    *ppv=NULL;

    if (IID_IUnknown==riid)
		*ppv = reinterpret_cast<IUnknown*>(this);
	else if (IID_ISWbemPrivilegeSet==riid)
		*ppv = (ISWbemPrivilegeSet *)this;
	else if (IID_IDispatch==riid)
        *ppv = (IDispatch *)this;
	else if (IID_ISupportErrorInfo==riid)
		*ppv = (ISupportErrorInfo *)this;
	else if (IID_IProvideClassInfo==riid)
		*ppv = (IProvideClassInfo *)this;

    if (NULL!=*ppv)
    {
        ((LPUNKNOWN)*ppv)->AddRef();
        return NOERROR;
    }

    return ResultFromScode(E_NOINTERFACE);
}

STDMETHODIMP_(ULONG) CSWbemPrivilegeSet::AddRef(void)
{
    long l = InterlockedIncrement(&m_cRef);
    return l;
}

STDMETHODIMP_(ULONG) CSWbemPrivilegeSet::Release(void)
{
    long l = InterlockedDecrement(&m_cRef);
    if (0L!=l)
        return l;
    delete this;
    return 0;
}

//***************************************************************************
// HRESULT CSWbemPrivilegeSet::InterfaceSupportsErrorInfo
//
// DESCRIPTION:
//
// Standard Com ISupportErrorInfo functions.
//
//***************************************************************************

STDMETHODIMP CSWbemPrivilegeSet::InterfaceSupportsErrorInfo (IN REFIID riid)
{
	return (IID_ISWbemPrivilegeSet == riid) ? S_OK : S_FALSE;
}

//***************************************************************************
//
//  SCODE CSWbemPrivilegeSet::get__NewEnum
//
//  DESCRIPTION:
//
//  Return an IEnumVARIANT-supporting interface for collections
//
//  PARAMETERS:
//
//		ppUnk		on successful return addresses the IUnknown interface
//
//  RETURN VALUES:
//
//  S_OK				success
//  E_FAIL				otherwise
//
//***************************************************************************

HRESULT CSWbemPrivilegeSet::get__NewEnum (
	IUnknown **ppUnk
)
{
	HRESULT hr = E_FAIL;

	if (NULL != ppUnk)
	{
		*ppUnk = NULL;
		CEnumPrivilegeSet *pEnum = new CEnumPrivilegeSet (this);

		if (FAILED(hr = pEnum->QueryInterface (IID_IUnknown, (LPVOID *) ppUnk)))
			delete pEnum;
	}
	
	if (FAILED(hr))
		m_Dispatch.RaiseException (hr);

	return hr;
}

//***************************************************************************
//
//  SCODE CSWbemPrivilegeSet::get_Count
//
//  DESCRIPTION:
//
//  Return the number of items in the collection
//
//  PARAMETERS:
//
//		plCount		on successful return addresses the count
//
//  RETURN VALUES:
//
//  S_OK				success
//  E_FAIL				otherwise
//
//***************************************************************************

HRESULT CSWbemPrivilegeSet::get_Count (
	long *plCount
)
{
	HRESULT hr = E_FAIL;

	if (NULL != plCount)
	{
		*plCount = m_PrivilegeMap.size ();
		hr = S_OK;
	}
	
	if (FAILED(hr))
		m_Dispatch.RaiseException (hr);

	return hr;
}
		
//***************************************************************************
//
//  SCODE CSWbemPrivilegeSet::Item
//
//  DESCRIPTION:
//
//  Get object from the enumeration by path.  
//
//  PARAMETERS:
//
//		bsObjectPath	The path of the object to retrieve
//		lFlags			Flags
//		ppNamedObject	On successful return addresses the object
//
//  RETURN VALUES:
//
//  WBEM_S_NO_ERROR				success
//	WBEM_E_INVALID_PARAMETER	bad input parameters
//  WBEM_E_FAILED				otherwise
//
//***************************************************************************

HRESULT CSWbemPrivilegeSet::Item (
	WbemPrivilegeEnum iPrivilege,
    ISWbemPrivilege **ppPrivilege
)
{
	HRESULT hr = WBEM_E_NOT_FOUND;

	if (NULL == ppPrivilege)
		hr = WBEM_E_INVALID_PARAMETER;
	else
	{
		*ppPrivilege = NULL;
		PrivilegeMap::iterator theIterator;
		theIterator = m_PrivilegeMap.find (iPrivilege);

		if (theIterator != m_PrivilegeMap.end ())
		{
			CSWbemPrivilege *pPrivilege = (*theIterator).second;

			if (SUCCEEDED(pPrivilege->QueryInterface 
					(IID_ISWbemPrivilege, (LPVOID *) ppPrivilege)))
			{
				hr = WBEM_S_NO_ERROR;
			}
		}
	}

	if (FAILED(hr))
		m_Dispatch.RaiseException (hr);

	return hr;
}


//***************************************************************************
//
//  SCODE CSWbemPrivilegeSet::DeleteAll
//
//  DESCRIPTION:
//
//  Remove all items in the collection 
//
//  RETURN VALUES:
//
//  S_OK				success
//  E_FAIL				otherwise
//
//***************************************************************************

HRESULT CSWbemPrivilegeSet::DeleteAll ()
{
	HRESULT hr = S_OK;

	if (m_bMutable)
	{
		PrivilegeMap::iterator next; 
		
		while ((next = m_PrivilegeMap.begin ()) != m_PrivilegeMap.end ())
		{
			CSWbemPrivilege *pPrivilege = (*next).second;
			next = m_PrivilegeMap.erase (next);
			pPrivilege->Release ();
		}
	}
	else
		hr = WBEM_E_READ_ONLY;

	if (FAILED(hr))
		m_Dispatch.RaiseException (hr);

	return hr;
}

//***************************************************************************
//
//  SCODE CSWbemPrivilegeSet::Remove
//
//  DESCRIPTION:
//
//  Remove the named item in the collection
//
//	PARAMETERS
//		bsName			Name of item to remove
//
//  RETURN VALUES:
//
//  S_OK				success
//  E_FAIL				otherwise
//
//***************************************************************************

HRESULT CSWbemPrivilegeSet::Remove (
	WbemPrivilegeEnum	iPrivilege
)
{
	HRESULT hr = WBEM_E_NOT_FOUND;

	if (m_bMutable)
	{
		PrivilegeMap::iterator theIterator = m_PrivilegeMap.find (iPrivilege);

		if (theIterator != m_PrivilegeMap.end ())
		{
			// Found it - release and remove

			CSWbemPrivilege *pPrivilege = (*theIterator).second;
			m_PrivilegeMap.erase (theIterator);
			pPrivilege->Release ();
			hr = S_OK;
		}
	}
	else
		hr = WBEM_E_READ_ONLY;

	if (FAILED(hr))
		m_Dispatch.RaiseException (hr);

	return hr;
}

//***************************************************************************
//
//  SCODE CSWbemPrivilegeSet::Add
//
//  DESCRIPTION:
//
//  Add a new item to the collection
//
//  RETURN VALUES:
//
//  S_OK				success
//	wbemErrInvalidParameter		privilege name not recognized by OS
//  E_FAIL				otherwise
//
//***************************************************************************

HRESULT CSWbemPrivilegeSet::Add (
	WbemPrivilegeEnum iPrivilege,
	VARIANT_BOOL bIsEnabled,
	ISWbemPrivilege **ppPrivilege
)
{
	HRESULT hr = E_FAIL;

	if (NULL == ppPrivilege)
		hr = WBEM_E_INVALID_PARAMETER;
	else if (m_bMutable)
	{
		CSWbemPrivilege *pPrivilege = NULL;

		PrivilegeMap::iterator theIterator = m_PrivilegeMap.find (iPrivilege);

		if (theIterator != m_PrivilegeMap.end ())
		{
			// Already there, so modify setting
			pPrivilege = (*theIterator).second;
			if (SUCCEEDED(hr = pPrivilege->QueryInterface (IID_ISWbemPrivilege, 
																	(LPVOID *) ppPrivilege)))
			{
				pPrivilege->put_IsEnabled (bIsEnabled);
			}
		}
		else
		{
			/*
			 * Potential new element - first check it's 
			 * a valid Privilege name by getting it's LUID.
			 */
			LUID luid;
			TCHAR *tName = CSWbemPrivilege::GetNameFromId (iPrivilege);

			if (tName && CSWbemPrivilege::GetPrivilegeValue(tName, &luid))
			{
				// Super. Now add it to the map (note that constructor AddRef's)
				pPrivilege = new CSWbemPrivilege (iPrivilege, luid, 
					(bIsEnabled) ? true : false);
				if (SUCCEEDED(hr = pPrivilege->QueryInterface (IID_ISWbemPrivilege, 
																		(LPVOID *)ppPrivilege)))
				{
					m_PrivilegeMap.insert 
						(PrivilegeMap::value_type(iPrivilege, pPrivilege));
				}
				else
				{
					delete pPrivilege;
				}
			}
			else
			{
				DWORD dwLastError = GetLastError ();
				hr = wbemErrInvalidParameter;
			}
		}
	}
	else
		hr = WBEM_E_READ_ONLY;

	if (FAILED(hr))
		m_Dispatch.RaiseException (hr);

	return hr;
}

//***************************************************************************
//
//  SCODE CSWbemPrivilegeSet::AddAsString
//
//  DESCRIPTION:
//
//  Add a new item to the collection; the privilege is specified by
//	an NT privilege string rather than a WbemPrivilegeEnum id.
//
//  RETURN VALUES:
//
//  S_OK				success
//	wbemErrInvalidParameter		privilege name not recognized by OS
//  E_FAIL				otherwise
//
//***************************************************************************

HRESULT CSWbemPrivilegeSet::AddAsString (
	BSTR bsPrivilege,
	VARIANT_BOOL bIsEnabled,
	ISWbemPrivilege **ppPrivilege
)
{
	HRESULT hr = wbemErrInvalidParameter;

	// Map the string into a Privilege id
	WbemPrivilegeEnum	iPrivilege;

	if (CSWbemPrivilege::GetIdFromName (bsPrivilege, iPrivilege))
		hr = Add (iPrivilege, bIsEnabled, ppPrivilege);
	else
	{
		if (FAILED(hr))
			m_Dispatch.RaiseException (hr);
	}

	return hr;
}

//***************************************************************************
//
//  SCODE CSWbemPrivilegeSet::GetNumberOfDisabledElements
//
//  DESCRIPTION:
//
//  Add a new item to the collection
//
//  RETURN VALUES:
//
//  S_OK				success
//	wbemErrInvalidParameter		privilege name not recognized by OS
//  E_FAIL				otherwise
//
//***************************************************************************

ULONG CSWbemPrivilegeSet::GetNumberOfDisabledElements ()
{
	ULONG lNum = 0;

	PrivilegeMap::iterator next = m_PrivilegeMap.begin ();

	while (next != m_PrivilegeMap.end ())
	{
		CSWbemPrivilege *pPrivilege = (*next).second;
		VARIANT_BOOL bValue;

		if (SUCCEEDED(pPrivilege->get_IsEnabled (&bValue)) && (VARIANT_FALSE == bValue))
			lNum++;
	
		next++;
	}

	return lNum;
}

//***************************************************************************
//
//  SCODE CSWbemPrivilegeSet::Reset
//
//  DESCRIPTION:
//
//  Remove all items from the set and reinstantiate with 
//	a copy of the items in the input privilege set
//
//***************************************************************************

void CSWbemPrivilegeSet::Reset (CSWbemPrivilegeSet &privSet)
{
	DeleteAll ();

	PrivilegeMap::iterator next = privSet.m_PrivilegeMap.begin ();

	while (next != privSet.m_PrivilegeMap.end ())
	{
		VARIANT_BOOL bIsEnabled;
		CSWbemPrivilege *pPrivilege = (*next).second;
		pPrivilege->get_IsEnabled (&bIsEnabled);

		ISWbemPrivilege *pDummy = NULL;

		if (SUCCEEDED (Add ((*next).first, bIsEnabled, &pDummy)))
			pDummy->Release ();

		next++;
	}
}


// CEnumPrivilegeSet Methods

//***************************************************************************
//
//  CEnumPrivilegeSet::CEnumPrivilegeSet
//
//  DESCRIPTION:
//
//  Constructor.
//
//***************************************************************************

CEnumPrivilegeSet::CEnumPrivilegeSet(CSWbemPrivilegeSet *pPrivilegeSet)
{
	m_cRef=0;
	m_pPrivilegeSet = pPrivilegeSet;
	m_pPrivilegeSet->AddRef ();

	m_Iterator = m_pPrivilegeSet->m_PrivilegeMap.begin ();
	InterlockedIncrement(&g_cObj);
}

CEnumPrivilegeSet::CEnumPrivilegeSet(CSWbemPrivilegeSet *pPrivilegeSet,
							 PrivilegeMap::iterator iterator) :
		m_Iterator (iterator)
{
	m_cRef=0;
	m_pPrivilegeSet = pPrivilegeSet;
	m_pPrivilegeSet->AddRef ();
	InterlockedIncrement(&g_cObj);
}

//***************************************************************************
//
//  CEnumPrivilegeSet::~CEnumPrivilegeSet
//
//  DESCRIPTION:
//
//  Destructor.
//  
//***************************************************************************

CEnumPrivilegeSet::~CEnumPrivilegeSet(void)
{
    InterlockedDecrement(&g_cObj);

	if (m_pPrivilegeSet)
		m_pPrivilegeSet->Release ();
}

//***************************************************************************
// HRESULT CEnumPrivilegeSet::QueryInterface
// long CEnumPrivilegeSet::AddRef
// long CEnumPrivilegeSet::Release
//
// DESCRIPTION:
//
// Standard Com IUNKNOWN functions.
//
//***************************************************************************

STDMETHODIMP CEnumPrivilegeSet::QueryInterface (

	IN REFIID riid,
    OUT LPVOID *ppv
)
{
    *ppv=NULL;

    if (IID_IUnknown==riid || IID_IEnumVARIANT==riid)
        *ppv=this;

    if (NULL!=*ppv)
    {
        ((LPUNKNOWN)*ppv)->AddRef();
        return NOERROR;
    }

    return ResultFromScode(E_NOINTERFACE);
}

STDMETHODIMP_(ULONG) CEnumPrivilegeSet::AddRef(void)
{
    long l = InterlockedIncrement(&m_cRef);
    return l;
}

STDMETHODIMP_(ULONG) CEnumPrivilegeSet::Release(void)
{
    long l = InterlockedDecrement(&m_cRef);
    if (0L!=l)
        return l;
    delete this;
    return 0;
}

//***************************************************************************
//
//  SCODE CEnumPrivilegeSet::Reset
//
//  DESCRIPTION:
//
//  Reset the enumeration
//
//  PARAMETERS:
//
//  RETURN VALUES:
//
//  S_OK				success
//  S_FALSE				otherwise
//
//***************************************************************************

HRESULT CEnumPrivilegeSet::Reset ()
{
	HRESULT hr = S_FALSE;
	m_Iterator = m_pPrivilegeSet->m_PrivilegeMap.begin ();
	return hr;
}

//***************************************************************************
//
//  SCODE CEnumPrivilegeSet::Next
//
//  DESCRIPTION:
//
//  Get the next object in the enumeration
//
//  PARAMETERS:
//
//		lTimeout	Number of ms to wait for object (or WBEM_INFINITE for
//					indefinite)
//		ppObject	On return may contain the next element (if any)
//
//  RETURN VALUES:
//
//  S_OK				success
//  S_FALSE				not all elements could be returned
//
//***************************************************************************

HRESULT CEnumPrivilegeSet::Next (
		ULONG cElements, 
		VARIANT FAR* pVar, 
		ULONG FAR* pcElementFetched
)
{
	HRESULT hr = S_OK;
	ULONG l2 = 0;

	if (NULL != pcElementFetched)
		*pcElementFetched = 0;

	if ((NULL != pVar) && (m_pPrivilegeSet))
	{
		for (ULONG l = 0; l < cElements; l++)
			VariantInit (&pVar [l]);

		// Retrieve the next cElements elements.  
		for (l2 = 0; l2 < cElements; l2++)
		{
			if (m_Iterator != m_pPrivilegeSet->m_PrivilegeMap.end ())
			{
				CSWbemPrivilege *pSWbemPrivilege = (*m_Iterator).second;
				m_Iterator++;

				ISWbemPrivilege *pISWbemPrivilege = NULL;

				if (SUCCEEDED(pSWbemPrivilege->QueryInterface 
						(IID_ISWbemPrivilege, (LPVOID *) &pISWbemPrivilege)))
				{
					// Set the object into the variant array; note that pObject
					// has been addref'd as a result of the QI() call above
					pVar[l2].vt = VT_DISPATCH;
					pVar[l2].pdispVal = pISWbemPrivilege;
				}
			}
			else
				break;
		}
		if (NULL != pcElementFetched)
			*pcElementFetched = l2;
	}
	
	if (FAILED(hr))
		return hr;

	return (l2 < cElements) ? S_FALSE : S_OK;
}

//***************************************************************************
//
//  SCODE CEnumPrivilegeSet::Clone
//
//  DESCRIPTION:
//
//  Create a copy of this enumeration
//
//  PARAMETERS:
//
//		ppEnum		on successful return addresses the clone
//
//  RETURN VALUES:
//
//  WBEM_S_NO_ERROR				success
//  WBEM_E_FAILED				otherwise
//
//***************************************************************************

HRESULT CEnumPrivilegeSet::Clone (
	IEnumVARIANT **ppEnum
)
{
	HRESULT hr = E_FAIL;

	if (NULL != ppEnum)
	{
		*ppEnum = NULL;

		if (m_pPrivilegeSet)
		{
			CEnumPrivilegeSet *pEnum = new CEnumPrivilegeSet (m_pPrivilegeSet, m_Iterator);

			if (FAILED(hr = pEnum->QueryInterface (IID_IEnumVARIANT, (LPVOID *) ppEnum)))
				delete pEnum;;
		}
	}

	return hr;
}

//***************************************************************************
//
//  SCODE CEnumPrivilegeSet::Skip
//
//  DESCRIPTION:
//
//  Skip specified number of elements
//
//  PARAMETERS:
//
//		ppEnum		on successful return addresses the clone
//
//  RETURN VALUES:
//
//  S_OK				success
//  S_FALSE				end of sequence reached prematurely
//
//***************************************************************************

HRESULT CEnumPrivilegeSet::Skip(
	ULONG cElements
)	
{
	HRESULT hr = S_FALSE;

	if (m_pPrivilegeSet)
	{
		ULONG l2;

		// Retrieve the next cElements elements.  
		for (l2 = 0; l2 < cElements; l2++)
		{
			if (m_Iterator != m_pPrivilegeSet->m_PrivilegeMap.end ())
				m_Iterator++;
			else
				break;
		}

		if (l2 == cElements)
			hr = S_OK;
	}

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\xmltransport\compiler\control\xmltransf\docset.cpp ===
#include "precomp.h"
#include <objsafe.h>
#include <wbemcli.h>
#include <wmiutils.h>
#include <wbemdisp.h>
#include <xmlparser.h>
#include <genlex.h>
#include <opathlex.h>
#include <objpath.h>

#include "wmiconv.h"
#include "wmi2xml.h"
#include "classfac.h"
#include "xmltrnsf.h"
#include "XMLTransportClientHelper.h"
#include "XMLClientPacket.h"
#include "XMLClientPacketFactory.h"
#include "HTTPConnectionAgent.h"
#include "httpops.h"
#include "dcomops.h"
#include "myStream.h"
#include "MyPendingStream.h"
#include "nodefact.h"
#include "disphlp.h"
#include "docset.h"
#include "putfact.h"
#include "parse.h"
#include "dispi.h"
#include "helper.h"

CWbemXMLHTTPDocSet::CWbemXMLHTTPDocSet()
{
	m_cRef = 1;
	m_Dispatch.SetObj (this, IID_ISWbemXMLDocumentSet, L"SWbemXMLDocumentSet");
	m_pFactory = NULL;
	m_pParser = NULL;
	InterlockedIncrement(&g_cObj);
}

CWbemXMLHTTPDocSet::~CWbemXMLHTTPDocSet(void)
{
	if(m_pFactory)
		m_pFactory->Release();
	if(m_pParser)
		m_pParser->Release();
	InterlockedDecrement(&g_cObj);
}


HRESULT CWbemXMLHTTPDocSet::Initialize(IStream *pStream, LPCWSTR *pszElementNames, DWORD dwElementCount)
{
	HRESULT hr = E_FAIL;

	if(pStream)
	{
		CMyPendingStream *pMyStream = NULL;
		if(pMyStream = new CMyPendingStream(pStream))
		{
			if(SUCCEEDED(hr = CoCreateInstance(CLSID_XMLParser, NULL, CLSCTX_INPROC_SERVER,
				IID_IXMLParser,  (LPVOID *)&m_pParser)))
			{
				if(SUCCEEDED(hr = m_pParser->SetInput(pMyStream)))
				{
					if(m_pFactory = new MyFactory(pMyStream))
					{
						if(SUCCEEDED(hr = m_pFactory->SetElementNames(pszElementNames, dwElementCount)))
						{

							if(SUCCEEDED(hr = m_pParser->SetFactory(m_pFactory)))
							{
							}
						}
					}
					else
						hr = E_OUTOFMEMORY;
				}
			}
			pMyStream->Release();
		}
		else
			hr = E_OUTOFMEMORY;
	}
	return hr;
}


//***************************************************************************
// HRESULT CWbemXMLHTTPDocSet::InterfaceSupportsErrorInfo
//
// DESCRIPTION:
//
// Standard Com ISupportErrorInfo functions.
//
//***************************************************************************

STDMETHODIMP CWbemXMLHTTPDocSet::InterfaceSupportsErrorInfo (IN REFIID riid)
{
	return (IID_ISWbemXMLDocumentSet == riid) ? S_OK : S_FALSE;
}

// IEnumVARIANT methods
HRESULT STDMETHODCALLTYPE CWbemXMLHTTPDocSet::Reset
()
{
	return E_NOTIMPL;
}

HRESULT STDMETHODCALLTYPE CWbemXMLHTTPDocSet::Next
(
    /*[in]*/	unsigned long celt,
	/*[out]*/	VARIANT FAR *rgvar,
    /*[out]*/	unsigned long FAR *pceltFetched
)
{
	HRESULT hParse = E_FAIL, hr = S_OK;
	if (NULL != pceltFetched)
		*pceltFetched = 0;

	ULONG l = 0;
	if (NULL != rgvar)
	{
		// Initialize all variants
		for (l=0; l < celt; l++)
			VariantInit (&rgvar [l]);

		// Get the next document(s) from the factory
		l = 0;
		while(l<celt && (SUCCEEDED(hParse = m_pParser->Run(-1)) || hParse == E_PENDING))
		{
			IXMLDOMDocument *pNextObject = NULL;
			if(SUCCEEDED(m_pFactory->GetDocument(&pNextObject)))
			{
				// Wrap the document in a VARIANT
				rgvar[l].vt = VT_DISPATCH;
				rgvar[l].pdispVal = pNextObject;
				l++;
			}
		}
	}
	if (NULL != pceltFetched)
		*pceltFetched = l;

	if(FAILED(hr))
		return hr;

	return (l < celt) ? S_FALSE : S_OK;
}

HRESULT STDMETHODCALLTYPE CWbemXMLHTTPDocSet::Clone
(
    /*[out]*/	IEnumVARIANT **ppEnum
)
{
	return E_NOTIMPL;
}

HRESULT STDMETHODCALLTYPE CWbemXMLHTTPDocSet::Skip
(
    /*[in]*/	unsigned long celt
)
{
	return E_NOTIMPL;
}


//***************************************************************************
//
//  SCODE CWbemXMLHTTPDocSet::get__NewEnum
//
//  DESCRIPTION:
//
//  Return an IEnumVARIANT-supporting interface for collections
//
//  PARAMETERS:
//
//		ppUnk		on successful return addresses the IUnknown interface
//
//  RETURN VALUES:
//
//  S_OK				success
//  E_FAIL				otherwise
//
//***************************************************************************

HRESULT CWbemXMLHTTPDocSet::get__NewEnum (
	IUnknown **ppUnk
)
{
	AddRef();
	*ppUnk = (IUnknown *)(IDispatch *)(ISWbemXMLDocumentSet *)this;
	return S_OK;
}

//***************************************************************************
//
//  SCODE CWbemXMLHTTPDocSet::get_Count
//
//  DESCRIPTION:
//
//  Return the number of items in the collection
//
//  PARAMETERS:
//
//		plCount		on successful return addresses the count
//
//  RETURN VALUES:
//
//  S_OK				success
//  E_FAIL				otherwise
//
//***************************************************************************

HRESULT CWbemXMLHTTPDocSet::get_Count (
	long *plCount
)
{
	return E_NOTIMPL;
}

//***************************************************************************
//
//  SCODE CWbemXMLHTTPDocSet::Item
//
//  DESCRIPTION:
//
//  Get object from the enumeration by path.
//
//  PARAMETERS:
//
//		bsObjectPath	The path of the object to retrieve
//		lFlags			Flags
//		ppNamedObject	On successful return addresses the object
//
//  RETURN VALUES:
//
//  WBEM_S_NO_ERROR				success
//	WBEM_E_INVALID_PARAMETER	bad input parameters
//  WBEM_E_FAILED				otherwise
//
//***************************************************************************

HRESULT CWbemXMLHTTPDocSet::Item (
	BSTR bsObjectPath,
	long lFlags,
    IXMLDOMDocument **ppObject
)
{
	return E_NOTIMPL;
}

HRESULT CWbemXMLHTTPDocSet :: NextDocument (IXMLDOMDocument **ppDoc)
{
	if(ppDoc == NULL)
		return WBEM_E_INVALID_PARAMETER;

	HRESULT hr = E_FAIL, hParse = E_FAIL;
	*ppDoc = NULL;
	if(SUCCEEDED(hParse = m_pParser->Run(-1)) || hParse == E_PENDING)
	{
		if(SUCCEEDED(hr = m_pFactory->GetDocument(ppDoc)))
		{
		}
	}
	return hr;
}

HRESULT CWbemXMLHTTPDocSet :: SkipNextDocument ()
{
	// We *have* to run the parser here - we have no choice
	HRESULT hr = E_FAIL, hParse = E_FAIL;
	if(SUCCEEDED(hParse = m_pParser->Run(-1)) || hParse == E_PENDING)
	{
		if(SUCCEEDED(hr = m_pFactory->SkipNextDocument()))
		{
		}
	}
	return hr;
}


CWbemDCOMDocSet::CWbemDCOMDocSet()
{
	m_cRef = 1;
	m_Dispatch.SetObj (this, IID_ISWbemXMLDocumentSet, L"SWbemXMLDocumentSet");
	m_pEnum = NULL;
	m_bLocalOnly = TRUE;
	m_bIncludeQualifiers = FALSE;
	m_bIncludeClassOrigin = FALSE;
	m_iEncoding = wmiXML_WMI_DTD_WHISTLER;
	InterlockedIncrement(&g_cObj);
}

CWbemDCOMDocSet::~CWbemDCOMDocSet(void)
{
	if(m_pEnum)
		m_pEnum->Release();
	InterlockedDecrement(&g_cObj);
}


HRESULT CWbemDCOMDocSet::Initialize(IEnumWbemClassObject *pEnum,
												WmiXMLEncoding iEncoding,
												VARIANT_BOOL bIncludeQualifiers,
												VARIANT_BOOL bIncludeClassOrigin,
												VARIANT_BOOL bLocalOnly,
												bool bNamesOnly)
{
	if(m_pEnum = pEnum)
		m_pEnum->AddRef();
	m_iEncoding = iEncoding;
	m_bIncludeQualifiers = bIncludeQualifiers;
	m_bIncludeClassOrigin = bIncludeClassOrigin;
	m_bLocalOnly = bLocalOnly;
	m_bNamesOnly = bNamesOnly;

	return S_OK;
}


//***************************************************************************
// HRESULT CWbemXMLHTTPDocSet::InterfaceSupportsErrorInfo
//
// DESCRIPTION:
//
// Standard Com ISupportErrorInfo functions.
//
//***************************************************************************

STDMETHODIMP CWbemDCOMDocSet::InterfaceSupportsErrorInfo (IN REFIID riid)
{
	return (IID_ISWbemXMLDocumentSet == riid) ? S_OK : S_FALSE;
}

// IEnumVARIANT methods
HRESULT STDMETHODCALLTYPE CWbemDCOMDocSet::Reset
()
{
	return E_NOTIMPL;
}

HRESULT STDMETHODCALLTYPE CWbemDCOMDocSet::Next
(
    /*[in]*/	unsigned long celt,
	/*[out]*/	VARIANT FAR *rgvar,
    /*[out]*/	unsigned long FAR *pceltFetched
)
{
	HRESULT hEnum = E_FAIL, hr = S_OK;
	if (NULL != pceltFetched)
		*pceltFetched = 0;

	ULONG l = 0;
	if (NULL != rgvar)
	{
		// Initialize all variants
		for (l=0; l < celt; l++)
			VariantInit (&rgvar [l]);

		// Get the next object(s) from the enumerator
		l = 0;
		IWbemClassObject *pNextObject = NULL;
		ULONG lNext = 0;
		while(l<celt && SUCCEEDED(hEnum = m_pEnum->Next(WBEM_INFINITE, 1, &pNextObject, &lNext)) && hEnum != WBEM_S_FALSE && lNext )
		{
			// Convert the Object to XML
			IXMLDOMDocument *pNextXMLObject = NULL;
			if(SUCCEEDED(hr = PackageDCOMOutput(pNextObject, &pNextXMLObject, m_iEncoding, m_bIncludeQualifiers, m_bIncludeClassOrigin, m_bLocalOnly)))
			{
				// Wrap the document in a VARIANT
				rgvar[l].vt = VT_DISPATCH;
				rgvar[l].pdispVal = pNextXMLObject;
				l++;
			}
			pNextObject->Release();
			pNextObject = NULL;
		}
	}
	if (NULL != pceltFetched)
		*pceltFetched = l;

	if(FAILED(hr))
		return hr;

	return (l < celt) ? S_FALSE : S_OK;
}

HRESULT STDMETHODCALLTYPE CWbemDCOMDocSet::Clone
(
    /*[out]*/	IEnumVARIANT **ppEnum
)
{
	return E_NOTIMPL;
}

HRESULT STDMETHODCALLTYPE CWbemDCOMDocSet::Skip
(
    /*[in]*/	unsigned long celt
)
{
	return E_NOTIMPL;
}


//***************************************************************************
//
//  SCODE CWbemDCOMDocSet::get__NewEnum
//
//  DESCRIPTION:
//
//  Return an IEnumVARIANT-supporting interface for collections
//
//  PARAMETERS:
//
//		ppUnk		on successful return addresses the IUnknown interface
//
//  RETURN VALUES:
//
//  S_OK				success
//  E_FAIL				otherwise
//
//***************************************************************************

HRESULT CWbemDCOMDocSet::get__NewEnum (
	IUnknown **ppUnk
)
{
	AddRef();
	*ppUnk = (IUnknown *)(IDispatch *)(ISWbemXMLDocumentSet *)this;
	return S_OK;
}

//***************************************************************************
//
//  SCODE CWbemDCOMDocSet::get_Count
//
//  DESCRIPTION:
//
//  Return the number of items in the collection
//
//  PARAMETERS:
//
//		plCount		on successful return addresses the count
//
//  RETURN VALUES:
//
//  S_OK				success
//  E_FAIL				otherwise
//
//***************************************************************************

HRESULT CWbemDCOMDocSet::get_Count (
	long *plCount
)
{
	return E_NOTIMPL;
}

//***************************************************************************
//
//  SCODE CWbemDCOMDocSet::Item
//
//  DESCRIPTION:
//
//  Get object from the enumeration by path.
//
//  PARAMETERS:
//
//		bsObjectPath	The path of the object to retrieve
//		lFlags			Flags
//		ppNamedObject	On successful return addresses the object
//
//  RETURN VALUES:
//
//  WBEM_S_NO_ERROR				success
//	WBEM_E_INVALID_PARAMETER	bad input parameters
//  WBEM_E_FAILED				otherwise
//
//***************************************************************************

HRESULT CWbemDCOMDocSet::Item (
	BSTR bsObjectPath,
	long lFlags,
    IXMLDOMDocument **ppObject
)
{
	return E_NOTIMPL;
}

HRESULT CWbemDCOMDocSet :: NextDocument (IXMLDOMDocument **ppDoc)
{
	if(ppDoc == NULL)
		return WBEM_E_INVALID_PARAMETER;

	HRESULT hr = E_FAIL;
	IWbemClassObject *pNextObject = NULL;
	*ppDoc = NULL;
	ULONG lNext = 0;
	if(SUCCEEDED(hr = m_pEnum->Next(WBEM_INFINITE, 1, &pNextObject, &lNext)) && (hr != WBEM_S_FALSE) && lNext)
	{
		// Convert the Object to XML
		hr = PackageDCOMOutput(pNextObject, ppDoc, m_iEncoding, m_bIncludeQualifiers, m_bIncludeClassOrigin, m_bLocalOnly, m_bNamesOnly);
		pNextObject->Release();
	}
	return hr;
}

HRESULT CWbemDCOMDocSet :: SkipNextDocument ()
{
	// RAJESHR - Until Skip() has been fixed by the core team, do a Next(). Change this 
	// when the core team has a fix
	HRESULT hr = E_FAIL;
	IWbemClassObject *pNextObject = NULL;
	ULONG lNext = 0;
	if(SUCCEEDED(hr = m_pEnum->Next(WBEM_INFINITE, 1, &pNextObject, &lNext)) && (hr != WBEM_S_FALSE) && lNext)
	{
		// Discard it
		pNextObject->Release();
	}
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\xmltransport\compiler\control\xmltransf\helper.cpp ===
#include "precomp.h"
#include <objsafe.h>
#include <wbemcli.h>
#include <wmiutils.h>
#include <wbemdisp.h>
#include <xmlparser.h>
#include <genlex.h>
#include <opathlex.h>
#include <objpath.h>

#include "wmiconv.h"
#include "wmi2xml.h"
#include "classfac.h"
#include "xmltrnsf.h"
#include "XMLTransportClientHelper.h"
#include "XMLClientPacket.h"
#include "XMLClientPacketFactory.h"
#include "HTTPConnectionAgent.h"
#include "httpops.h"
#include "dcomops.h"
#include "myStream.h"
#include "MyPendingStream.h"
#include "nodefact.h"
#include "disphlp.h"
#include "docset.h"
#include "putfact.h"
#include "parse.h"
#include "dispi.h"
#include "helper.h"
#include "urlparser.h"

static HRESULT MapObjectNameToXML(IWbemXMLConvertor *pConvertor, IWbemClassObject *pObject, IStream *pStream);

// In this we are given an IWbemClassObject and are required to 
// get its XML representation based on the filters like
HRESULT PackageDCOMOutput(IWbemClassObject *pObject, IXMLDOMDocument **ppXMLDocument, 
		WmiXMLEncoding iEncoding, VARIANT_BOOL bQualifierFilter, VARIANT_BOOL bClassOriginFilter,
		VARIANT_BOOL bLocalOnly,
		bool bNamesOnly)
{
	HRESULT hr = E_FAIL;
	*ppXMLDocument = NULL;

	// RAJESHR Load the correct component based on the value of iEncoding here
	IWbemXMLConvertor *pConvertor = NULL;
	if(SUCCEEDED(hr = CreateXMLTranslator(&pConvertor)))
	{
		// Create an IWbemContext object with the appropriate flags used for 
		// the translation
		IWbemContext *pConvertorContext = NULL;
		if(SUCCEEDED(hr = CreateFlagsContext(&pConvertorContext,
			(bQualifierFilter == VARIANT_TRUE)? TRUE:FALSE,
			(bClassOriginFilter == VARIANT_TRUE)? TRUE:FALSE,
			(bLocalOnly == VARIANT_TRUE)? TRUE:FALSE)))
		{
			// Create a stream for placing thr translated data
			IStream *pStream = NULL;
			if (SUCCEEDED(hr = CreateStreamOnHGlobal(NULL, TRUE, &pStream)))
			{
				// Do the translation
				if(bNamesOnly)
					hr = MapObjectNameToXML(pConvertor, pObject, pStream);
				else
					hr = pConvertor->MapObjectToXML(pObject, NULL, 0, pConvertorContext, pStream, NULL);

				if (SUCCEEDED(hr))
				{
					// Pack the stream into an IXMLDOMDocument
					if(SUCCEEDED(hr = CreateXMLDocument(ppXMLDocument)))
					{
						// Convert the WCHAR IStream to UTF-8
						BSTR strUTF8 = NULL;
						if(SUCCEEDED(hr = SaveLPWSTRStreamAsBSTR(pStream, &strUTF8)))
						{
							VARIANT_BOOL bResult = VARIANT_TRUE;
							if(SUCCEEDED(hr = (*ppXMLDocument)->loadXML(strUTF8, &bResult)))
							{
								if(bResult != VARIANT_TRUE)
								{
									IXMLDOMParseError *pError = NULL;
									if(SUCCEEDED((*ppXMLDocument)->get_parseError(&pError)))
									{
										LONG errorCode = 0;
										pError->get_errorCode(&errorCode);
										LONG line=0, linepos=0;
										BSTR reason=NULL, srcText = NULL;
										if(SUCCEEDED(pError->get_line(&line)) &&
											SUCCEEDED(pError->get_linepos(&linepos)) &&
											SUCCEEDED(pError->get_reason(&reason)) &&
											SUCCEEDED(pError->get_srcText(&srcText)))
										{
										}
										pError->Release();
										if(reason)
											SysFreeString(reason);
										if(srcText)
											SysFreeString(srcText);
									}
									hr = WBEM_E_INVALID_SYNTAX;

								}
							}
							SysFreeString(strUTF8);
						}
					}
				}
				pStream->Release();
			}
		}
		pConvertor->Release();
	}

	// Deallocate the out argument of the function is all didnt go well
	if(FAILED(hr))
	{
		(*ppXMLDocument)->Release();
		*ppXMLDocument = NULL;
	}
	return hr;
}

// Creates an IWbemCOntext object with the correct context values required for
// conversion of WMI objects to XML for this specific operation
HRESULT CreateFlagsContext(IWbemContext **ppContext, 
			BOOL bIncludeQualifiers, BOOL bLocalOnly, BOOL bIncludeClassOrigin)
{
	HRESULT hr = E_FAIL;
	// Create an IWbemContext object
	if(SUCCEEDED(hr = CoCreateInstance(CLSID_WbemContext,
		0,
		CLSCTX_INPROC_SERVER,
		IID_IWbemContext, (LPVOID *) ppContext)))
	{
		if(SUCCEEDED(hr = SetBoolProperty(*ppContext, L"IncludeQualifiers", bIncludeQualifiers)) &&
			SUCCEEDED(hr = SetBoolProperty(*ppContext, L"IncludeClassOrigin", bIncludeClassOrigin)) &&
			SUCCEEDED(hr = SetBoolProperty(*ppContext, L"LocalOnly", bLocalOnly)) &&
			SUCCEEDED(hr = SetBoolProperty(*ppContext, L"AllowWMIExtensions", TRUE)))
		{
		}
	}

	if(FAILED(hr))
		(*ppContext)->Release();
	return hr;
}

// A Helper function for setting a booles value in a context
HRESULT SetBoolProperty(IWbemContext *pContext, LPCWSTR pszName, BOOL bValue)
{
	HRESULT result = E_FAIL;
	VARIANT vValue;
	VariantInit(&vValue);
	vValue.vt = VT_BOOL;
	if(bValue)
		vValue.boolVal = VARIANT_TRUE;
	else
		vValue.boolVal = VARIANT_FALSE;

	result = pContext->SetValue(pszName, 0, &vValue);
	VariantClear(&vValue);
	return result;
}


// RAJESHR - Remove this to read the GUID frm the registry on startup
DEFINE_GUID(CLSID_WbemXMLConvertor,
	0x610037ec, 0xce06, 0x11d3, 0x93, 0xfc, 0x0, 0x80, 0x5f, 0x85, 0x37, 0x71);

HRESULT CreateXMLTranslator(IWbemXMLConvertor **pConvertor)
{

	HRESULT result = E_FAIL;

	// Create the XMLAdaptor object
	//******************************************************
	*pConvertor = NULL;
	if(SUCCEEDED(result = CoCreateInstance(CLSID_WbemXMLConvertor,
		0,
		CLSCTX_INPROC_SERVER,
        IID_IWbemXMLConvertor, (LPVOID *) pConvertor)))
	{
	}
	return result;
}


DEFINE_GUID(IID_ISWbemInternalContext,
	0x61EA8DBC, 0x37B8, 0x11d2, 0x8B, 0x3C, 0x0, 0x60, 0x08, 0x06, 0xD9, 0xB6);
HRESULT GetIWbemContext(IDispatch *pSet, IWbemContext **ppContext)
{
	HRESULT hr = E_FAIL;
	ISWbemInternalContext *pInt = NULL;
	if(SUCCEEDED(hr = pSet->QueryInterface(IID_ISWbemInternalContext, (LPVOID *)&pInt)))
	{
		hr = pInt->GetIWbemContext(ppContext);
		pInt->Release();
	}
	return hr;
}

HRESULT ParseObjectPath(LPCWSTR pszObjectPath, LPWSTR *pszHostName, LPWSTR *pszNamespace, LPWSTR *pszObjectName, bool& bIsClass, bool &bIsHTTP, bool&bIsNovaPath)
{
	bIsHTTP = false;
	HRESULT hr = S_OK;
	CURLParser theParser;
	if(FAILED(hr = theParser.Initialize(pszObjectPath)))
		return hr;
	bIsNovaPath = theParser.IsNovapath();

	LPWSTR pszTemp = NULL;
	if(FAILED(hr = theParser.GetServername(&pszTemp)))
		return hr;
	else
	{
		// In case of HTTP style paths, remove the rectangular brackets
		if(pszTemp && (pszTemp[0] == L'[') )
		{
			*pszHostName = NULL;
			DWORD dwLen = wcslen(pszTemp);
			if(*pszHostName = new WCHAR [dwLen-1])
			{
				wcsncpy(*pszHostName, pszTemp+1, dwLen-2);
				(*pszHostName)[dwLen-2] = NULL;
				bIsHTTP = true;
			}
			else
			{
				delete [] pszTemp;
				return E_OUTOFMEMORY;
			}

			// We dont need the server name any more, since we made a copy
			delete [] pszTemp;
		}
		else // It is DCOM, we dont need to mess with the host name
			*pszHostName = pszTemp;
	}
	// Next get the namespace
	if(FAILED(hr = theParser.GetNamespace(pszNamespace)))
	{
		delete [] (*pszHostName);
		return hr;
	}
	// Next get the object name
	if(theParser.IsClass() || theParser.IsInstance())
	{
		bIsClass = false;
		if(theParser.IsClass())
			bIsClass = true;
		if(FAILED(hr = theParser.GetObjectName(pszObjectName)))
		{
			delete [] (*pszHostName);
			delete [] (*pszNamespace);
			return hr;
		}
	}

	// A small workaround for how the object path parser handles things
	// If the objectpath happens to be "root", then the parser returns NULL
	// as the namespace and "root" as the object name. This is not what we want
	// when someone wants to enumerate all the classes in the namespace root
	if(*pszObjectName && _wcsicmp(*pszObjectName, L"root") == 0)
	{
		delete [] *pszNamespace;
		*pszNamespace = *pszObjectName;
		*pszObjectName = NULL;
		bIsNovaPath = true;
	}

	return S_OK;
}


HRESULT SaveLPWSTRStreamAsBSTR (IStream *pStream, BSTR *pstr)
{
	HRESULT result = E_FAIL;

	LARGE_INTEGER	offset;
	offset.LowPart = offset.HighPart = 0;
	if(SUCCEEDED(result = pStream->Seek (offset, STREAM_SEEK_SET, NULL)))
	{
		// Get the LPWSTR data from the stream first
		//=========================================
		STATSTG statstg;
		if (SUCCEEDED(result = pStream->Stat(&statstg, STATFLAG_NONAME)))
		{
			ULONG cbSize = (statstg.cbSize).LowPart;
			WCHAR *pText = NULL;

			if(cbSize)
			{
				if(pText = new WCHAR [(cbSize/2)])
				{
					if (SUCCEEDED(result = pStream->Read(pText, cbSize, NULL)))
					{
						// Convert the LPWSTR tp a BSTR
						*pstr = NULL;
						if(!(*pstr = SysAllocStringLen(pText, cbSize/2)))
							result = E_OUTOFMEMORY;
					}
					delete [] pText;
				}
				else
					result = E_OUTOFMEMORY;
			}
		}
	}

	return result;
}


HRESULT MapObjectNameToXML(IWbemXMLConvertor *pConvertor, IWbemClassObject *pObject, IStream *pStream)
{
	HRESULT hr = S_OK;

	// Get the Genus of the object
	VARIANT var;
	VariantInit(&var);
	if(SUCCEEDED(hr = pObject->Get(L"__GENUS", 0, &var, NULL, NULL)))
	{
		VARIANT nameVar;
		VariantInit(&nameVar);

		// Class
		if(var.iVal == 1)
		{
			// Get its __CLASS Property
			if(SUCCEEDED(hr = pObject->Get(L"__CLASS", 0, &var, NULL, NULL)))
				hr = pConvertor->MapClassNameToXML(var.bstrVal, NULL, pStream);
		}
		else // Instance
		{
			// Get its __CLASS Property
			if(SUCCEEDED(hr = pObject->Get(L"__RELPATH", 0, &var, NULL, NULL)))
				hr = pConvertor->MapInstanceNameToXML(var.bstrVal, NULL, pStream);
		}
		VariantClear(&nameVar);

		VariantClear(&var);
	}
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\xmltransport\compiler\control\xmltransf\httpops.h ===
#ifndef HTTP_OPS_H
#define HTTP_OPS_H

// Macro to convert VT_BOOL values to bool values
static bool VariantToBool(VARIANT_BOOL vBool)
{
	if(vBool == VARIANT_TRUE)
		return true;
	return false;
}

// Static helper functions
HRESULT SendPacket(CHTTPConnectionAgent *pConnectionAgent, CXMLClientPacket *pPacketClass);
HRESULT	SendPacketForMethod(CHTTPConnectionAgent *pConnectionAgent, int iPostType/*1 for POST, 2 for M-POST*/, CXMLClientPacket *pPacketClass, DWORD *pdwResultStatus);
HRESULT SendBody(CHTTPConnectionAgent *pConnectionAgent, CXMLClientPacket *pPacketClass, LPWSTR pszBody, DWORD dwBodyLength);
HRESULT	SendPacketForMethodWithBody(CHTTPConnectionAgent *pConnectionAgent, int iPostType/*1 for POST, 2 for M-POST*/, CXMLClientPacket *pPacketClass, LPWSTR pwszBody, DWORD dwBodySize, DWORD *pdwResultStatus);
HRESULT EncodeHTTPResponseIntoStream(LPBYTE pXML, DWORD dwSize, VARIANT *pVariant);
HRESULT HandleFilteringAndOutput(CHTTPConnectionAgent *pResultAgent, IStream **ppXMLDocument);


// Main functions for HTTP operations
HRESULT HttpGetObject (
	LPCWSTR	pszUserName,
	LPCWSTR pszPassword,
	WmiXMLEncoding iEncoding,
	VARIANT_BOOL bQualifierFilter,
	VARIANT_BOOL bClassOriginFilter,
	VARIANT_BOOL bLocalOnly,
	LPCWSTR pszLocale,
	LPCWSTR pszObjectPath,
	bool bIsNovaPath,
	LPCWSTR pszHostURL,
	LPCWSTR pszNamespace,
	LPCWSTR pszObjectName,
	bool bIsClass,
	IWbemContext *pContext,
	IStream **ppXMLDocument);

HRESULT HttpExecQuery (
	LPCWSTR	pszUserName,
	LPCWSTR pszPassword,
	WmiXMLEncoding iEncoding,
	VARIANT_BOOL bQualifierFilter,
	VARIANT_BOOL bClassOriginFilter,
	LPCWSTR pszLocale,
	LPCWSTR pszNamespacePath,
	LPCWSTR pszHostURL,
	LPCWSTR pszNamespace,
	LPCWSTR pszQuery,
	LPCWSTR pszQueryLanguage,
	IWbemContext *pContext,
	IStream **ppXMLDocument);

HRESULT HttpEnumClass (
	LPCWSTR	pszUserName,
	LPCWSTR pszPassword,
	WmiXMLEncoding iEncoding,
	VARIANT_BOOL bQualifierFilter,
	VARIANT_BOOL bClassOriginFilter,
	VARIANT_BOOL bLocalOnly,
	LPCWSTR pszLocale,
	LPCWSTR pszSuperClassPath,
	LPCWSTR pszHostURL,
	LPCWSTR pszNamespace,
	LPCWSTR pszObjectName,
	VARIANT_BOOL bDeep,
	IWbemContext *pContext,
	IStream **ppXMLDocument);

HRESULT HttpEnumInstance (
	LPCWSTR	pszUserName,
	LPCWSTR pszPassword,
	WmiXMLEncoding iEncoding,
	VARIANT_BOOL bQualifierFilter,
	VARIANT_BOOL bClassOriginFilter,
	VARIANT_BOOL bLocalOnly,
	LPCWSTR pszLocale,
	LPCWSTR pszClassPath,
	LPCWSTR pszHostURL,
	LPCWSTR pszNamespace,
	LPCWSTR pszObjectName,
	VARIANT_BOOL bDeep,
	IWbemContext *pContext,
	IStream **ppXMLDocument);

HRESULT HttpEnumClassNames (
	LPCWSTR	pszUserName,
	LPCWSTR pszPassword,
	WmiXMLEncoding iEncoding,
	LPCWSTR pszLocale,
	LPCWSTR pszSuperClassPath,
	LPCWSTR pszHostURL,
	LPCWSTR pszNamespace,
	LPCWSTR pszObjectName,
	VARIANT_BOOL bDeep,
	IWbemContext *pContext,
	IStream **ppXMLDocument);

HRESULT HttpEnumInstanceNames (
	LPCWSTR	pszUserName,
	LPCWSTR pszPassword,
	WmiXMLEncoding iEncoding,
	LPCWSTR pszLocale,
	LPCWSTR pszClassPath,
	LPCWSTR pszHostURL,
	LPCWSTR pszNamespace,
	LPCWSTR pszObjectName,
	IWbemContext *pContext,
	IStream **ppXMLDocument);

HRESULT HttpPutClass (
	LPCWSTR	pszUserName,
	LPCWSTR pszPassword,
	LPCWSTR pszLocale,
	LPCWSTR pszNamespacePath,
	LONG lClassFlags,
	IXMLDOMElement *pClassElement,
	IWbemContext *pContext,
	BSTR *pstrErrors);

HRESULT HttpModifyClass (
	LPCWSTR	pszUserName,
	LPCWSTR pszPassword,
	LPCWSTR pszLocale,
	LPCWSTR pszNamespacePath,
	LONG lClassFlags,
	IXMLDOMElement *pClassElement,
	IWbemContext *pContext,
	BSTR *pstrErrors);

HRESULT HttpPutInstance (
	LPCWSTR	pszUserName,
	LPCWSTR pszPassword,
	LPCWSTR pszLocale,
	LPCWSTR pszNamespacePath,
	LONG lClassFlags,
	IXMLDOMElement *pClassElement,
	IWbemContext *pContext,
	BSTR *pstrErrors);

HRESULT HttpModifyInstance (
	LPCWSTR	pszUserName,
	LPCWSTR pszPassword,
	LPCWSTR pszLocale,
	LPCWSTR pszNamespacePath,
	LONG lClassFlags,
	IXMLDOMElement *pClassElement,
	IWbemContext *pContext,
	BSTR *pstrErrors);

HRESULT HttpGeneralPut (
	LPCWSTR pszMethodName,
	LPCWSTR	pszUserName,
	LPCWSTR pszPassword,
	LPCWSTR pszLocale,
	LPCWSTR pszNamespacePath,
	LONG lClassFlags,
	IXMLDOMElement *pClassElement,
	IWbemContext *pContext,
	BSTR *pstrErrors);

HRESULT HttpDeleteClass(
	LPCWSTR	pszUserName,
	LPCWSTR pszPassword,
	LPCWSTR pszLocale,
	LPCWSTR pszHostURL,
	LPCWSTR pszNamespace,
	LPCWSTR pszClassName,
	IWbemContext *pContext);
						

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\xmltransport\compiler\control\xmltransf\maindll.h ===
#ifndef WMI_XML_TRANSFORMER_MAIN_H
#define WMI_XML_TRANSFORMER_MAIN_H

// These are the globals which are initialized in the Initialize () function
extern bool		s_bIsNT;
extern DWORD	s_dwNTMajorVersion;
extern bool		s_bCanRevert;
extern bool		s_bInitialized;
extern CRITICAL_SECTION g_csGlobalInitialization;

// DLL Object count
extern long g_cObj;



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\xmltransport\compiler\control\xmltransf\precomp.h ===
#include <windows.h>
#include <objbase.h>
#include <stdio.h>
#include <msxml.h>

#include "cominit.h"
#include "wbemcli.h"
#include "wmiutils.h"
#include "maindll.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\xmltransport\compiler\control\xmltransf\maindll.cpp ===
//***************************************************************************
//
// Copyright (c) 1997-1999 Microsoft Corporation
//
//  MAINDLL.CPP
//
//  alanbos  13-Feb-98   Created.
//
//  Contains DLL entry points.
//
//***************************************************************************
#include "precomp.h"
#include <tchar.h>
#include <initguid.h>
#include <XMLTransportClientHelper.h>
#include "xmltrnsf.h"
#include "classfac.h"

// Control-specific registry strings
#define WMI_XML_DESCRIPTION	__TEXT("WMI XML Transformer Control")
#define WMI_XML_TXOR_PROGID	__TEXT("WMI.XMLTransformerControl")
#define WMI_XML_TXOR_PROGIDVER	__TEXT("WMI.XMLTransformerControl.1")
#define WMI_XML_TXOR_VERSION	__TEXT("1.0")

// Standard registry key/value names
#define WMI_XML_RK_THRDMODEL	__TEXT("ThreadingModel")
#define WMI_XML_RV_BOTH			__TEXT("Both")
#define WMI_XML_RK_CONTROL		__TEXT("Control")
#define WMI_XML_RK_PROGID		__TEXT("ProgID")
#define WMI_XML_RK_VERPROGID	__TEXT("VersionIndependentProgID")
#define WMI_XML_RK_TYPELIB		__TEXT("TypeLib")
#define WMI_XML_RK_VERSION		__TEXT("Version")
#define	WMI_XML_RK_INPROC32		__TEXT("InProcServer32")
#define WMI_XML_RK_CLSID		__TEXT("CLSID")
#define WMI_XML_RK_CURVER		__TEXT("CurVer")

#define GUIDSIZE	128

// Count number of objects and number of locks.
long g_cObj = 0 ;
ULONG g_cLock = 0 ;
HMODULE ghModule ;

// Used to protect initialization of global variables
// Eventhough the name of this variable sounds like a misnomer,
// it is primarily used for security
CRITICAL_SECTION g_csGlobalInitialization;

// These are the globals which are initialized in the Initialize () function
bool		s_bIsNT			= false;
DWORD		s_dwNTMajorVersion = 0;
bool		s_bCanRevert	= false;
bool		s_bInitialized	= false;

// A function for Initializing global DLL resources
static HRESULT UninitializeWmiXmlTransfDLL ();

//***************************************************************************
//
//  BOOL WINAPI DllMain
//
//  DESCRIPTION:
//
//  Entry point for DLL.  Good place for initialization.
//
//  PARAMETERS:
//
//  hInstance           instance handle
//  ulReason            why we are being called
//  pvReserved          reserved
//
//  RETURN VALUE:
//
//  TRUE if OK.
//
//***************************************************************************

BOOL WINAPI DllMain (

	IN HINSTANCE hInstance,
    IN ULONG ulReason,
    LPVOID pvReserved
)
{
	switch (ulReason)
	{
		case DLL_PROCESS_DETACH:
			DeleteCriticalSection (&g_csGlobalInitialization);
			return TRUE;

		case DLL_PROCESS_ATTACH:
			ghModule = hInstance;
			InitializeCriticalSection (&g_csGlobalInitialization);
	        return TRUE;
    }

    return TRUE;
}

//***************************************************************************
//
//  STDAPI DllGetClassObject
//
//  DESCRIPTION:
//
//  Called when Ole wants a class factory.  Return one only if it is the sort
//  of class this DLL supports.
//
//  PARAMETERS:
//
//  rclsid              CLSID of the object that is desired.
//  riid                ID of the desired interface.
//  ppv                 Set to the class factory.
//
//  RETURN VALUE:
//
//  S_OK                all is well
//  E_FAILED            not something we support
//
//***************************************************************************

STDAPI DllGetClassObject(

	IN REFCLSID rclsid,
    IN REFIID riid,
    OUT LPVOID *ppv
)
{
    HRESULT hr;
    CXMLTFactory *pObj = NULL;

    if (CLSID_WmiXMLTransformer == rclsid)
	{
        if (NULL == (pObj = new CXMLTFactory()))
			return ResultFromScode(E_OUTOFMEMORY);
	}
	else
        return E_FAIL;

    hr=pObj->QueryInterface(riid, ppv);

    if ( FAILED ( hr ) )
	{
        delete pObj ;
	}

    return hr ;
}

//***************************************************************************
//
//  STDAPI DllCanUnloadNow
//
//  DESCRIPTION:
//
//  Answers if the DLL can be freed, that is, if there are no
//  references to anything this DLL provides.
//
//  RETURN VALUE:
//
//  S_OK                if it is OK to unload
//  S_FALSE             if still in use
//
//***************************************************************************

STDAPI DllCanUnloadNow ()
{
	//It is OK to unload if there are no objects or locks on the
    // class factory.

    if (0L==g_cObj && 0L==g_cLock) 
	{
		UninitializeWmiXmlTransfDLL();
		return S_OK;
	}
	return S_FALSE;
}


//***************************************************************************
//
// DllRegisterServer
//
// Purpose: Called during setup or by regsvr32.
//
// Return:  NOERROR if registration successful, error otherwise.
//***************************************************************************

STDAPI DllRegisterServer(void)
{
	TCHAR		nwcID[GUIDSIZE];
	TCHAR		ntlID[GUIDSIZE];
    TCHAR		szCLSID[GUIDSIZE+128];
    TCHAR		szModule[MAX_PATH];
    HKEY hKey1 = NULL, hKey2 = NULL;

    // Create the path.

    if(0 ==StringFromGUID2(CLSID_WmiXMLTransformer, nwcID, GUIDSIZE))
		return ERROR;

    _tcscpy (szCLSID, WMI_XML_RK_CLSID);
	_tcscat (szCLSID, __TEXT("\\"));
	_tcscat (szCLSID, nwcID);

	if (0 == StringFromGUID2 (LIBID_WmiXMLTransformer, ntlID, GUIDSIZE))
		return ERROR;

	if(0 == GetModuleFileName(ghModule, szModule,  MAX_PATH))
		return ERROR;

    // Create entries under CLSID

    if(ERROR_SUCCESS == RegCreateKey(HKEY_CLASSES_ROOT, szCLSID, &hKey1))
	{
		// Description (on main key)
		RegSetValueEx(hKey1, NULL, 0, REG_SZ, (BYTE *)WMI_XML_DESCRIPTION,
										(_tcslen(WMI_XML_DESCRIPTION)+1));

		// Register as inproc server
		if (ERROR_SUCCESS == RegCreateKey(hKey1, WMI_XML_RK_INPROC32 ,&hKey2))
		{
			RegSetValueEx(hKey2, NULL, 0, REG_SZ, (BYTE *)szModule,
										(_tcslen(szModule)+1)*(sizeof(TCHAR)));
			RegSetValueEx(hKey2, WMI_XML_RK_THRDMODEL, 0, REG_SZ, (BYTE *)WMI_XML_RV_BOTH,
                                        (_tcslen(WMI_XML_RV_BOTH)+1)*(sizeof(TCHAR)));
			RegCloseKey(hKey2);
		}

		// Register as a control
		if (ERROR_SUCCESS == RegCreateKey(hKey1, WMI_XML_RK_CONTROL, &hKey2))
			RegCloseKey(hKey2);

		// Register the ProgID
		if (ERROR_SUCCESS == RegCreateKey(hKey1, WMI_XML_RK_PROGID ,&hKey2))
		{
			RegSetValueEx(hKey2, NULL, 0, REG_SZ, (BYTE *)WMI_XML_TXOR_PROGIDVER,
										(_tcslen(WMI_XML_TXOR_PROGIDVER)+1)*(sizeof(TCHAR)));
			RegCloseKey(hKey2);
        }

		// Register the version-independent ProgID

		if (ERROR_SUCCESS == RegCreateKey(hKey1, WMI_XML_RK_VERPROGID, &hKey2))
		{
			RegSetValueEx(hKey2, NULL, 0, REG_SZ, (BYTE *)WMI_XML_TXOR_PROGID,
										(_tcslen(WMI_XML_TXOR_PROGID)+1)*(sizeof(TCHAR)));
			RegCloseKey(hKey2);
        }

		// Register the type-library
		if (ERROR_SUCCESS == RegCreateKey(hKey1, WMI_XML_RK_TYPELIB, &hKey2))
		{
			RegSetValueEx(hKey2, NULL, 0, REG_SZ, (BYTE *)ntlID,
										(_tcslen(ntlID)+1)*(sizeof(TCHAR)));
			RegCloseKey(hKey2);
        }

		// Register the version
		if (ERROR_SUCCESS == RegCreateKey(hKey1, WMI_XML_RK_VERSION, &hKey2))
		{
			RegSetValueEx(hKey2, NULL, 0, REG_SZ, (BYTE *)WMI_XML_TXOR_VERSION,
										(_tcslen(WMI_XML_TXOR_VERSION)+1)*(sizeof(TCHAR)));
			RegCloseKey(hKey2);
        }

		RegCloseKey(hKey1);
	}
	else
		return ERROR;


    // Add the ProgID (Version independent and current version)

	if(ERROR_SUCCESS == RegCreateKey(HKEY_CLASSES_ROOT, WMI_XML_TXOR_PROGID, &hKey1))
    {
		RegSetValueEx(hKey1, NULL, 0, REG_SZ, (BYTE *)WMI_XML_DESCRIPTION,
										(_tcslen(WMI_XML_DESCRIPTION)+1)*(sizeof(TCHAR)));

		if(ERROR_SUCCESS == RegCreateKey(hKey1,WMI_XML_RK_CLSID, &hKey2))
        {
            RegSetValueEx(hKey2, NULL, 0, REG_SZ, (BYTE *)nwcID,
										(_tcslen(nwcID)+1)*(sizeof(TCHAR)));
            RegCloseKey(hKey2);
            hKey2 = NULL;
        }

        if(ERROR_SUCCESS == RegCreateKey(hKey1, WMI_XML_RK_CURVER, &hKey2))
        {
			RegSetValueEx(hKey2, NULL, 0, REG_SZ, (BYTE *)WMI_XML_TXOR_PROGIDVER,
										(_tcslen(WMI_XML_TXOR_PROGIDVER)+1)*(sizeof(TCHAR)));
			RegCloseKey(hKey2);
            hKey2 = NULL;
        }
        RegCloseKey(hKey1);
    }

    if(ERROR_SUCCESS == RegCreateKey(HKEY_CLASSES_ROOT, WMI_XML_TXOR_PROGIDVER, &hKey1))
    {
		RegSetValueEx(hKey1, NULL, 0, REG_SZ, (BYTE *)WMI_XML_DESCRIPTION,
										(_tcslen(WMI_XML_DESCRIPTION)+1)*(sizeof(TCHAR)));

        if(ERROR_SUCCESS == RegCreateKey(hKey1, WMI_XML_RK_CLSID, &hKey2))
        {
            RegSetValueEx(hKey2, NULL, 0, REG_SZ, (BYTE *)nwcID,
										(_tcslen(nwcID)+1)*(sizeof(TCHAR)));
            RegCloseKey(hKey2);
            hKey2 = NULL;
        }
        RegCloseKey(hKey1);
    }

	// AUTOMATION.  register type library
	WCHAR wPath[MAX_PATH];
	if(GetModuleFileName(ghModule, wPath, MAX_PATH-1))
	{
		// Replace final 3 characters "DLL" by "TLB"
		size_t pathLen = _tcslen (wPath);

		if ((pathLen > 3) && (0 == _tcsicmp (wPath + pathLen - 3, __TEXT("DLL"))))
		{
			wPath [pathLen - 3] = NULL;
			_tcscat (wPath, __TEXT("TLB"));
			ITypeLib FAR* ptlib = NULL;
			SCODE sc = LoadTypeLib(wPath, &ptlib);
			if(sc == 0 && ptlib)
			{
				sc = RegisterTypeLib(ptlib,wPath,NULL);
				ptlib->Release();
			}
		}
	}

	return NOERROR;
}

//***************************************************************************
//
// DllUnregisterServer
//
// Purpose: Called when it is time to remove the registry entries.
//
// Return:  NOERROR if registration successful, error otherwise.
//***************************************************************************

STDAPI DllUnregisterServer(void)
{
	TCHAR		wcID[GUIDSIZE];
    TCHAR		szCLSID[GUIDSIZE];
    HKEY		hKey;

    // Create the path using the CLSID

    if(0 == StringFromGUID2(CLSID_WmiXMLTransformer, wcID, GUIDSIZE))
		return ERROR;

    _tcscpy (szCLSID, WMI_XML_RK_CLSID);
	_tcscat (szCLSID, __TEXT("\\"));
	_tcscat (szCLSID, wcID);

    // First delete the subkeys of the HKCR\CLSID entry
    if(NO_ERROR == RegOpenKey(HKEY_CLASSES_ROOT, szCLSID, &hKey))
    {
        RegDeleteKey(hKey, WMI_XML_RK_INPROC32);
		RegDeleteKey(hKey, WMI_XML_RK_CONTROL);
		RegDeleteKey(hKey, WMI_XML_RK_PROGID);
		RegDeleteKey(hKey, WMI_XML_RK_VERPROGID);
		RegDeleteKey(hKey, WMI_XML_RK_TYPELIB);
		RegDeleteKey(hKey, WMI_XML_RK_VERSION);
        RegCloseKey(hKey);
    }

	// Delete the HKCR\CLSID key
    if(NO_ERROR == RegOpenKey(HKEY_CLASSES_ROOT, WMI_XML_RK_CLSID, &hKey))
    {
        RegDeleteKey(hKey, wcID);
        RegCloseKey(hKey);
    }

	// Delete the subkeys of the versioned HKCR\ProgID entry
    if (NO_ERROR == RegOpenKey(HKEY_CLASSES_ROOT, WMI_XML_TXOR_PROGIDVER, &hKey))
    {
		RegDeleteKey(hKey, WMI_XML_RK_CLSID);
		RegCloseKey(hKey);
	}

	// Delete the versioned HKCR\ProgID entry
    RegDeleteKey (HKEY_CLASSES_ROOT,WMI_XML_TXOR_PROGIDVER);

	// Delete the subkeys of the HKCR\VersionIndependentProgID entry
	if (NO_ERROR == RegOpenKey(HKEY_CLASSES_ROOT, WMI_XML_TXOR_PROGID, &hKey))
    {
		RegDeleteKey(hKey, WMI_XML_RK_CLSID);
		DWORD dwRet = RegDeleteKey(hKey, WMI_XML_RK_CURVER);
		RegCloseKey(hKey);
	}

	// Delete the HKCR\VersionIndependentProgID entry
	RegDeleteKey (HKEY_CLASSES_ROOT,WMI_XML_TXOR_PROGID);

	//	Unregister the type library.  The UnRegTypeLib function is not available in
    //  in some of the older version of the ole dlls and so it must be loaded
    //  dynamically
    HRESULT (STDAPICALLTYPE *pfnUnReg)(REFGUID, WORD,
            WORD , LCID , SYSKIND);

    TCHAR path[ MAX_PATH+20 ];
    GetSystemDirectory(path, MAX_PATH);
    _tcscat(path, __TEXT("\\oleaut32.dll"));

    HMODULE g_hOle32 = LoadLibraryEx(path, NULL, 0);

    if(g_hOle32 != NULL)
    {
        (FARPROC&)pfnUnReg = GetProcAddress(g_hOle32, "UnRegisterTypeLib");
        if(pfnUnReg)
            pfnUnReg(LIBID_WmiXMLTransformer,1,0,0,SYS_WIN32);
        FreeLibrary(g_hOle32);
    }
    return NOERROR;
}

static HRESULT UninitializeWmiXmlTransfDLL ()
{
	EnterCriticalSection (&g_csGlobalInitialization);
	if (s_bInitialized)
	{
		s_bInitialized = false;
		UninitWMIXMLClientLibrary();
	}

	LeaveCriticalSection (&g_csGlobalInitialization);
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\xmltransport\compiler\control\xmltransf\parse.h ===
#ifndef WMI_XML_COMP_PARSE_H
#define WMI_XML_COMP_PARSE_H

class CParseHelper
{
public:
	static HRESULT GetBstrAttribute(IXMLDOMNode *pNode, const BSTR strAttributeName, BSTR *pstrAttributeValue);
	static HRESULT ParseClassPath(IXMLDOMNode *pNode, BSTR *pstrHostName, BSTR *pstrNamespace, BSTR *pstrClassPath);
	static HRESULT ParseNamespacePath(IXMLDOMNode *pLocalNamespaceNode, BSTR *pstrHost, BSTR *pstrLocalNamespace);
	static HRESULT ParseLocalNamespacePath(IXMLDOMNode *pLocalNamespaceNode, BSTR *pstrLocalNamespacePath);
	static HRESULT GetNamespacePath(IXMLDOMNode *pNamespaceNode, BSTR *pstrNamespacePath);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\xmltransport\compiler\control\xmltransf\privilege.h ===
//***************************************************************************
//
//  Copyright (c) 1998-1999 Microsoft Corporation
//
//  PRIVILEGE.H
//
//  alanbos  30-Sep-98   Created.
//
//  Define Privilege classes.
//
//***************************************************************************

#ifndef WMI_XML_PRIVILEGE_H_
#define WMI_XML_PRIVILEGE_H_

using namespace std;

class CEnumPrivilegeSet;
class CSWbemPrivilegeSet;

//***************************************************************************
//
//  CLASS NAME:
//
//  CSWbemPrivilege
//
//  DESCRIPTION:
//
//  Implements the ISWbemPrivilege interface.  
//
//***************************************************************************

class CSWbemPrivilege : public ISWbemPrivilege,
						public ISupportErrorInfo,
						public IProvideClassInfo
{
private:
	CDispatchHelp		m_Dispatch;
	LUID				m_Luid;
	bool				m_bIsEnabled;
	WbemPrivilegeEnum	m_privilege;
	
protected:
	long            m_cRef;         //Object reference count

public:
    CSWbemPrivilege (WbemPrivilegeEnum privilege, LUID &luid, bool bIsEnabled);
	virtual ~CSWbemPrivilege (void);
	static HRESULT GetPrivilegeDisplayName (LPCTSTR lpName, BSTR *pDisplayName);
	static BOOL GetPrivilegeValue (LPCTSTR lpName, PLUID lpLuid);


	//Non-delegating object IUnknown

	STDMETHODIMP         QueryInterface(REFIID, LPVOID*);
	STDMETHODIMP_(ULONG) AddRef(void);
	STDMETHODIMP_(ULONG) Release(void);

	// IDispatch

	STDMETHODIMP		GetTypeInfoCount(UINT* pctinfo)
		{return  m_Dispatch.GetTypeInfoCount(pctinfo);}
	STDMETHODIMP		GetTypeInfo(UINT itinfo, LCID lcid, ITypeInfo** pptinfo)
		{return m_Dispatch.GetTypeInfo(itinfo, lcid, pptinfo);}
	STDMETHODIMP		GetIDsOfNames(REFIID riid, OLECHAR** rgszNames, 
							UINT cNames, LCID lcid, DISPID* rgdispid)
		{return m_Dispatch.GetIDsOfNames(riid, rgszNames, cNames,
						  lcid,
						  rgdispid);}
	STDMETHODIMP		Invoke(DISPID dispidMember, REFIID riid, LCID lcid, 
							WORD wFlags, DISPPARAMS* pdispparams, VARIANT* pvarResult, 
									EXCEPINFO* pexcepinfo, UINT* puArgErr)
		{return m_Dispatch.Invoke(dispidMember, riid, lcid, wFlags,
						pdispparams, pvarResult, pexcepinfo, puArgErr);}
	
	// ISWbemPrivilege methods

	HRESULT STDMETHODCALLTYPE get_IsEnabled 
	(
		/* [out] */ VARIANT_BOOL *bIsEnabled
	);

	HRESULT STDMETHODCALLTYPE put_IsEnabled
	(
		/* [in] */ VARIANT_BOOL bIsEnabled
	);

	HRESULT STDMETHODCALLTYPE get_Name 
	(
		/* [out] */ BSTR *bsName
	);

	HRESULT STDMETHODCALLTYPE get_DisplayName 
	(
		/* [out] */ BSTR *bsDisplayName
	);

	HRESULT STDMETHODCALLTYPE get_Identifier 
	(
		/* [out] */ WbemPrivilegeEnum *iPrivilege
	);

	// ISupportErrorInfo methods
	HRESULT STDMETHODCALLTYPE InterfaceSupportsErrorInfo 
	(
		/* [in] */ REFIID riid
	);

	// IProvideClassInfo methods
	HRESULT STDMETHODCALLTYPE GetClassInfo
	(
		/* [in,out] */ ITypeInfo **ppTI
	)
	{
		return m_Dispatch.GetClassInfo (ppTI);
	};

	// CSWbemPrivilege methods
	void	GetLUID (PLUID pLuid);

	static	TCHAR	*GetNameFromId (WbemPrivilegeEnum iPrivilege);
	static	OLECHAR *GetMonikerNameFromId (WbemPrivilegeEnum iPrivilege);
	static	bool GetIdFromMonikerName (OLECHAR *name, WbemPrivilegeEnum &iPrivilege);
	static	bool GetIdFromName (BSTR bsName, WbemPrivilegeEnum &iPrivilege);
	static void	ResetSecurity (HANDLE hThreadToken);
	static BOOL SetSecurity (CSWbemPrivilegeSet *pProvilegeSet, bool &needToResetSecurity, bool bUsingExplicitUserName, HANDLE &hThreadToken);
	static void SetTokenPrivileges (HANDLE hHandle, CSWbemPrivilegeSet *pPrivilegeSet);
};

typedef map< WbemPrivilegeEnum,CSWbemPrivilege*,less<int> > PrivilegeMap;

//***************************************************************************
//
//  CLASS NAME:
//
//  CSWbemPrivilegeSet
//
//  DESCRIPTION:
//
//  Implements the ISWbemPrivilegeSet interface.  
//
//***************************************************************************

class CSWbemPrivilegeSet : public ISWbemPrivilegeSet,
						   public ISupportErrorInfo,
						   public IProvideClassInfo
{
friend class CEnumPrivilegeSet;
friend class CSWbemSecurity;

private:
	bool			m_bMutable;
	CDispatchHelp	m_Dispatch;

protected:
	long            m_cRef;         //Object reference count

public:
	PrivilegeMap	m_PrivilegeMap;
    
    CSWbemPrivilegeSet ();
	CSWbemPrivilegeSet (const CSWbemPrivilegeSet &privSet,
						bool bMutable = true);
	CSWbemPrivilegeSet (ISWbemPrivilegeSet *pISWbemPrivilegeSet);
    virtual ~CSWbemPrivilegeSet (void);

    //Non-delegating object IUnknown

    STDMETHODIMP         QueryInterface(REFIID, LPVOID*);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

	// IDispatch

	STDMETHODIMP		GetTypeInfoCount(UINT* pctinfo)
		{return  m_Dispatch.GetTypeInfoCount(pctinfo);}
    STDMETHODIMP		GetTypeInfo(UINT itinfo, LCID lcid, ITypeInfo** pptinfo)
		{return m_Dispatch.GetTypeInfo(itinfo, lcid, pptinfo);}
    STDMETHODIMP		GetIDsOfNames(REFIID riid, OLECHAR** rgszNames, 
							UINT cNames, LCID lcid, DISPID* rgdispid)
		{return m_Dispatch.GetIDsOfNames(riid, rgszNames, cNames,
                          lcid,
                          rgdispid);}
    STDMETHODIMP		Invoke(DISPID dispidMember, REFIID riid, LCID lcid, 
							WORD wFlags, DISPPARAMS* pdispparams, VARIANT* pvarResult, 
									EXCEPINFO* pexcepinfo, UINT* puArgErr)
		{return m_Dispatch.Invoke(dispidMember, riid, lcid, wFlags,
                        pdispparams, pvarResult, pexcepinfo, puArgErr);}
	
	// Collection methods

	HRESULT STDMETHODCALLTYPE get__NewEnum
	(
		/*[out]*/	IUnknown **ppUnk
	);

	HRESULT STDMETHODCALLTYPE Item
	(
        /*[in]*/	WbemPrivilegeEnum privilege,
        /*[out]*/	ISWbemPrivilege **ppPrivilege
    );        

	HRESULT STDMETHODCALLTYPE get_Count
	(
		/*[in]*/	long *plCount
	);

	HRESULT STDMETHODCALLTYPE Add
	(
		/*[in]*/	WbemPrivilegeEnum privilege,
		/*[in]*/	VARIANT_BOOL bIsEnabled,
		/*[out]*/	ISWbemPrivilege **ppPrivilege
	);

	HRESULT STDMETHODCALLTYPE Remove 
	(
		/*[in]*/	WbemPrivilegeEnum privilege
	);

	
    // CSWbemPrivilegeSet methods

    HRESULT STDMETHODCALLTYPE DeleteAll
	(
    );

	HRESULT STDMETHODCALLTYPE AddAsString
	(
		/*[in]*/	BSTR strPrivilege,
		/*[in]*/	VARIANT_BOOL bIsEnabled,
		/*[out]*/	ISWbemPrivilege **ppPrivilege
	);

	// ISupportErrorInfo methods
	HRESULT STDMETHODCALLTYPE InterfaceSupportsErrorInfo 
	(
		/* [in] */ REFIID riid
	);

	// IProvideClassInfo methods
	HRESULT STDMETHODCALLTYPE GetClassInfo
	(
		/* [in,out] */ ITypeInfo **ppTI
	)
	{
		return m_Dispatch.GetClassInfo (ppTI);
	};

	// Other methods
	ULONG			GetNumberOfDisabledElements ();

	PrivilegeMap	&GetPrivilegeMap ()
	{
		return m_PrivilegeMap;
	}

	void			Reset (CSWbemPrivilegeSet &privSet);
};

//***************************************************************************
//
//  CLASS NAME:
//
//  CEnumPrivilegeSet
//
//  DESCRIPTION:
//
//  Implements the IEnumVARIANT interface for Privilege collections.  
//
//***************************************************************************

class CEnumPrivilegeSet : public IEnumVARIANT
{
private:
	long					m_cRef;
	CSWbemPrivilegeSet		*m_pPrivilegeSet;
	PrivilegeMap::iterator	m_Iterator;

public:
	CEnumPrivilegeSet (CSWbemPrivilegeSet *pPrivilegeSet);
	CEnumPrivilegeSet (CSWbemPrivilegeSet *pPrivilegeSet, 
				PrivilegeMap::iterator iterator);

	virtual ~CEnumPrivilegeSet (void);

    // Non-delegating object IUnknown
    STDMETHODIMP         QueryInterface(REFIID, LPVOID*);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

	// IEnumVARIANT
	STDMETHODIMP Next(
		unsigned long celt, 
		VARIANT FAR* rgvar, 
		unsigned long FAR* pceltFetched
	);
	
	STDMETHODIMP Skip(
		unsigned long celt
	);	
	
	STDMETHODIMP Reset();
	
	STDMETHODIMP Clone(
		IEnumVARIANT **ppenum
	);	

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\xmltransport\compiler\control\xmltransf\privilege.cpp ===
//***************************************************************************
//
//  Copyright (c) 1998-1999 Microsoft Corporation
//
//  PRIVILEGE.CPP
//
//  alanbos  30-Sep-98   Created.
//
//  Defines the implementation of CSWbemPrivilege
//
//***************************************************************************
#include <tchar.h>
#include "precomp.h"
#include <map>
#include <vector>
#include <wmiutils.h>
#include <wbemdisp.h>
#include <ocidl.h>
#include "disphlp.h"
#include "privilege.h"

#ifndef _UNICODE
#include <mbstring.h>
#endif

typedef struct PrivilegeDef {
	WbemPrivilegeEnum	privilege;
	TCHAR				*tName;
	OLECHAR				*monikerName;
} PrivilegeDef;

#define WBEMS_MAX_NUM_PRIVILEGE	26


static PrivilegeDef s_privilegeDefMap [WBEMS_MAX_NUM_PRIVILEGE] = {
	{ wbemPrivilegeCreateToken, SE_CREATE_TOKEN_NAME, L"CreateToken" },
	{ wbemPrivilegePrimaryToken, SE_ASSIGNPRIMARYTOKEN_NAME, L"PrimaryToken" },
	{ wbemPrivilegeLockMemory, SE_LOCK_MEMORY_NAME, L"LockMemory" },
	{ wbemPrivilegeIncreaseQuota, SE_INCREASE_QUOTA_NAME, L"IncreaseQuota" },
	{ wbemPrivilegeMachineAccount, SE_MACHINE_ACCOUNT_NAME, L"MachineAccount" },
	{ wbemPrivilegeTcb, SE_TCB_NAME, L"Tcb" },
	{ wbemPrivilegeSecurity, SE_SECURITY_NAME, L"Security" },
	{ wbemPrivilegeTakeOwnership, SE_TAKE_OWNERSHIP_NAME, L"TakeOwnership" },
	{ wbemPrivilegeLoadDriver, SE_LOAD_DRIVER_NAME, L"LoadDriver" },
	{ wbemPrivilegeSystemProfile, SE_SYSTEM_PROFILE_NAME, L"SystemProfile" },
	{ wbemPrivilegeSystemtime, SE_SYSTEMTIME_NAME, L"SystemTime" },
	{ wbemPrivilegeProfileSingleProcess, SE_PROF_SINGLE_PROCESS_NAME, L"ProfileSingleProcess" },
	{ wbemPrivilegeIncreaseBasePriority, SE_INC_BASE_PRIORITY_NAME, L"IncreaseBasePriority" },
	{ wbemPrivilegeCreatePagefile, SE_CREATE_PAGEFILE_NAME, L"CreatePagefile" },
	{ wbemPrivilegeCreatePermanent, SE_CREATE_PERMANENT_NAME, L"CreatePermanent" },
	{ wbemPrivilegeBackup, SE_BACKUP_NAME, L"Backup" },
	{ wbemPrivilegeRestore, SE_RESTORE_NAME, L"Restore" },
	{ wbemPrivilegeShutdown, SE_SHUTDOWN_NAME, L"Shutdown" },
	{ wbemPrivilegeDebug, SE_DEBUG_NAME, L"Debug" },
	{ wbemPrivilegeAudit, SE_AUDIT_NAME, L"Audit" },
	{ wbemPrivilegeSystemEnvironment, SE_SYSTEM_ENVIRONMENT_NAME, L"SystemEnvironment" },
	{ wbemPrivilegeChangeNotify, SE_CHANGE_NOTIFY_NAME, L"ChangeNotify" },
	{ wbemPrivilegeRemoteShutdown, SE_REMOTE_SHUTDOWN_NAME, L"RemoteShutdown" },
	{ wbemPrivilegeUndock, SE_UNDOCK_NAME, L"Undock" },
	{ wbemPrivilegeSyncAgent, SE_SYNC_AGENT_NAME, L"SyncAgent" },
	{ wbemPrivilegeEnableDelegation, SE_ENABLE_DELEGATION_NAME, L"EnableDelegation" }
};

TCHAR *CSWbemPrivilege::GetNameFromId (WbemPrivilegeEnum iPrivilege)
{
	DWORD i = iPrivilege - 1;
	return (WBEMS_MAX_NUM_PRIVILEGE > i) ?
				s_privilegeDefMap [i].tName : NULL;
}

OLECHAR *CSWbemPrivilege::GetMonikerNameFromId (WbemPrivilegeEnum iPrivilege)
{
	DWORD i = iPrivilege - 1;
	return (WBEMS_MAX_NUM_PRIVILEGE > i) ?
				s_privilegeDefMap [i].monikerName : NULL;
}

bool CSWbemPrivilege::GetIdFromMonikerName (OLECHAR *pName, WbemPrivilegeEnum &iPrivilege)
{
	bool status = false;

	if (pName)
	{
		for (DWORD i = 0; i < WBEMS_MAX_NUM_PRIVILEGE; i++)
		{
			if (0 == _wcsnicmp (pName, s_privilegeDefMap [i].monikerName,
								wcslen (s_privilegeDefMap [i].monikerName)))
			{
				// Success 
				iPrivilege = s_privilegeDefMap [i].privilege;
				status = true;
				break;
			}
		}
	}

	return status;
}

bool CSWbemPrivilege::GetIdFromName (BSTR bsName, WbemPrivilegeEnum &iPrivilege)
{
	bool status = false;

	if (bsName)
	{
#ifdef _UNICODE
		for (DWORD i = 0; i < WBEMS_MAX_NUM_PRIVILEGE; i++)
		{
			if (0 == _wcsicmp (bsName, s_privilegeDefMap [i].tName))
			{
				// Success 
				iPrivilege = s_privilegeDefMap [i].privilege;
				status = true;
				break;
			}
		}
#else
		// Convert bsName to a multibyte string
		size_t mbsNameLen = wcstombs (NULL, bsName, 0);
		char *mbsName = new char [mbsNameLen + 1];
		wcstombs (mbsName, bsName, mbsNameLen);
		mbsName [mbsNameLen] = NULL;

		for (DWORD i = 0; i < WBEMS_MAX_NUM_PRIVILEGE; i++)
		{
			if (0 == _mbsicmp ((unsigned char *)mbsName, (unsigned char *)(s_privilegeDefMap [i].tName)))
			{
				// Success 
				iPrivilege = s_privilegeDefMap [i].privilege;
				status = true;
				break;
			}
		}

		delete [] mbsName;
#endif
	}

	return status;
}

//***************************************************************************
//
// CSWbemPrivilege::CSWbemPrivilege
//
// CONSTRUCTOR 
//
//***************************************************************************

CSWbemPrivilege::CSWbemPrivilege (
	WbemPrivilegeEnum iPrivilege,
	LUID &luid, 
	bool bIsEnabled
)
{
	m_Dispatch.SetObj (this, IID_ISWbemPrivilege, 
						CLSID_SWbemPrivilege, L"SWbemPrivilege");
	m_cRef=1;

	m_privilege = iPrivilege;
	m_Luid = luid;
	m_bIsEnabled = bIsEnabled;

	InterlockedIncrement(&g_cObj);
}

//***************************************************************************
//
// CSWbemPrivilege::~CSWbemPrivilege
//
// DESTRUCTOR
//
//***************************************************************************

CSWbemPrivilege::~CSWbemPrivilege (void)
{
	InterlockedDecrement(&g_cObj);
}

//***************************************************************************
// HRESULT CSWbemPrivilege::QueryInterface
// long CSWbemPrivilege::AddRef
// long CSWbemPrivilege::Release
//
// DESCRIPTION:
//
// Standard Com IUNKNOWN functions.
//
//***************************************************************************

STDMETHODIMP CSWbemPrivilege::QueryInterface (

	IN REFIID riid,
    OUT LPVOID *ppv
)
{
    *ppv=NULL;

    if (IID_IUnknown==riid)
		*ppv = reinterpret_cast<IUnknown*>(this);
	else if (IID_ISWbemPrivilege==riid)
		*ppv = (ISWbemPrivilege *)this;
	else if (IID_IDispatch==riid)
        *ppv = (IDispatch *)this;
	else if (IID_ISupportErrorInfo==riid)
		*ppv = (ISupportErrorInfo *)this;
	else if (IID_IProvideClassInfo==riid)
		*ppv = (IProvideClassInfo *)this;

    if (NULL!=*ppv)
    {
        ((LPUNKNOWN)*ppv)->AddRef();
        return NOERROR;
    }

    return ResultFromScode(E_NOINTERFACE);
}

STDMETHODIMP_(ULONG) CSWbemPrivilege::AddRef(void)
{
    long l = InterlockedIncrement(&m_cRef);
    return l;
}

STDMETHODIMP_(ULONG) CSWbemPrivilege::Release(void)
{
    long l = InterlockedDecrement(&m_cRef);
    if (0L!=l)
        return l;
    delete this;
    return 0;
}

//***************************************************************************
// HRESULT CSWbemPrivilege::InterfaceSupportsErrorInfo
//
// DESCRIPTION:
//
// Standard Com ISupportErrorInfo functions.
//
//***************************************************************************

STDMETHODIMP CSWbemPrivilege::InterfaceSupportsErrorInfo (IN REFIID riid)
{
	return (IID_ISWbemPrivilege == riid) ? S_OK : S_FALSE;
}

//***************************************************************************
//
//  SCODE CSWbemPrivilege::get_Identifier
//
//  DESCRIPTION:
//
//  Retrieve the privilege identifier 
//
//  PARAMETERS:
//
//		pIsEnabled		holds the value on return
//
//  RETURN VALUES:
//
//  WBEM_S_NO_ERROR				success
//	WBEM_E_INVALID_PARAMETER	bad input parameters
//  WBEM_E_FAILED				otherwise
//
//***************************************************************************

HRESULT CSWbemPrivilege::get_Identifier (
	WbemPrivilegeEnum *pPrivilege
)
{
	HRESULT hr = WBEM_E_FAILED;


	if (NULL == pPrivilege)
		hr = WBEM_E_INVALID_PARAMETER;
	else 
	{
		*pPrivilege = m_privilege;
		hr = WBEM_S_NO_ERROR;
	}

	if (FAILED(hr))
		m_Dispatch.RaiseException (hr);

	return hr;
}

//***************************************************************************
//
//  SCODE CSWbemPrivilege::get_IsEnabled
//
//  DESCRIPTION:
//
//  Retrieve the override state
//
//  PARAMETERS:
//
//		pIsEnabled		holds the value on return
//
//  RETURN VALUES:
//
//  WBEM_S_NO_ERROR				success
//	WBEM_E_INVALID_PARAMETER	bad input parameters
//  WBEM_E_FAILED				otherwise
//
//***************************************************************************

HRESULT CSWbemPrivilege::get_IsEnabled (
	VARIANT_BOOL *pIsEnabled
)
{
	HRESULT hr = WBEM_E_FAILED;


	if (NULL == pIsEnabled)
		hr = WBEM_E_INVALID_PARAMETER;
	else 
	{
		*pIsEnabled = (m_bIsEnabled) ? VARIANT_TRUE : VARIANT_FALSE;
		hr = WBEM_S_NO_ERROR;
	}

	if (FAILED(hr))
		m_Dispatch.RaiseException (hr);

	return hr;
}

//***************************************************************************
//
//  SCODE CSWbemPrivilege::put_IsEnabled
//
//  DESCRIPTION:
//
//  Set the override state
//
//  PARAMETERS:
//
//		bIsEnabled		the new value
//
//  RETURN VALUES:
//
//  WBEM_S_NO_ERROR				success
//	WBEM_E_INVALID_PARAMETER	bad input parameters
//  WBEM_E_FAILED				otherwise
//
//***************************************************************************

HRESULT CSWbemPrivilege::put_IsEnabled (
	VARIANT_BOOL bIsEnabled
)
{
	m_bIsEnabled = (bIsEnabled) ? true : false;
	return WBEM_S_NO_ERROR;
}

//***************************************************************************
//
//  SCODE CSWbemPrivilege::get_Name
//
//  DESCRIPTION:
//
//  Retrieve the privilege name
//
//  PARAMETERS:
//
//		pName		holds the value on return
//
//  RETURN VALUES:
//
//  WBEM_S_NO_ERROR				success
//	WBEM_E_INVALID_PARAMETER	bad input parameters
//  WBEM_E_FAILED				otherwise
//
//***************************************************************************

HRESULT CSWbemPrivilege::get_Name (
	BSTR *pName
)
{
	HRESULT hr = WBEM_E_FAILED;

	if (NULL == pName)
		hr = WBEM_E_INVALID_PARAMETER;
	else 
	{
		TCHAR	*tName = GetNameFromId (m_privilege);

		if (tName)
		{
			// Have a valid name - now copy it to a BSTR
			
#ifdef _UNICODE
			*pName = SysAllocString (tName);
#else
			size_t tNameLen = strlen (tName);
			OLECHAR *nameW = new OLECHAR [tNameLen + 1];
			mbstowcs (nameW, tName, tNameLen);
			nameW [tNameLen] = NULL;
			*pName = SysAllocString (nameW);
			delete [] nameW;
#endif
			hr = WBEM_S_NO_ERROR;
		}
	}
	
	if (FAILED(hr))
		m_Dispatch.RaiseException (hr);

	return hr;
}

//***************************************************************************
//
//  SCODE CSWbemPrivilege::get_DisplayName
//
//  DESCRIPTION:
//
//  Retrieve the privilege display name
//
//  PARAMETERS:
//
//		pDisplayName		holds the value on return
//
//  RETURN VALUES:
//
//  WBEM_S_NO_ERROR				success
//	WBEM_E_INVALID_PARAMETER	bad input parameters
//  WBEM_E_FAILED				otherwise
//
//***************************************************************************

HRESULT CSWbemPrivilege::get_DisplayName (
	BSTR *pDisplayName
)
{
	HRESULT hr = WBEM_E_FAILED;

	if (NULL == pDisplayName)
		hr = WBEM_E_INVALID_PARAMETER;
	else 
	{
		TCHAR	*tName = GetNameFromId (m_privilege);

		if (tName)
		{	
			if(SUCCEEDED(hr = GetPrivilegeDisplayName (tName, pDisplayName)))
				hr = WBEM_S_NO_ERROR;
		}
	}
	
	if (FAILED(hr))
		m_Dispatch.RaiseException (hr);

	return hr;
}


void CSWbemPrivilege::GetLUID (PLUID pLuid)
{
	if (pLuid)
		*pLuid = m_Luid;
}


//***************************************************************************
//
//  SCODE CSWbemPrivilege::GetPrivilegeDisplayName
//
//  DESCRIPTION:
//
//  This static function wraps the Win32 LookupPrivilegeDisplayName function,
//	allowing us to do some OS-dependent stuff.
//
//  PARAMETERS:
//
//		tName			the privilege name
//		pDisplayName	holds the display name on successful return
//
//***************************************************************************

HRESULT CSWbemPrivilege::GetPrivilegeDisplayName (LPCTSTR lpName, BSTR *pDisplayName)
{
	HRESULT hr = E_FAIL;
	*pDisplayName = NULL;
	// Can't return display name on Win9x (no privilege support)
	if (s_bIsNT)
	{
		DWORD dwLangID;
		DWORD dwSize = 1;
		TCHAR dummy [1];
				
		// Get size of required buffer
		::LookupPrivilegeDisplayName (NULL, lpName, dummy, &dwSize, &dwLangID);
		LPTSTR dname = new TCHAR[dwSize + 1];
		if(dname)
		{
			if (::LookupPrivilegeDisplayName (__TEXT(""), lpName, dname, &dwSize, &dwLangID))
			{
				// Have a valid name - now copy it to a BSTR
				if(!(*pDisplayName = SysAllocString (dname)))
					hr = E_OUTOFMEMORY;
			}

			delete [] dname;
		}
		else
			hr = E_OUTOFMEMORY;
	}
	else
	{
		if(!(*pDisplayName = SysAllocString (L"")))
			hr = E_OUTOFMEMORY;
	}
	return hr;
}

//***************************************************************************
//
//  SCODE CSWbemPrivilege::LookupPrivilegeValue
//
//  DESCRIPTION:
//
//  This static function wraps the Win32 LookupPrivilegeValue function,
//	allowing us to do some OS-dependent stuff.
//
//  PARAMETERS:
//
//		lpName		the privilege name
//		lpLuid		holds the LUID on successful return
//
//  RETURN VALUES:
//
//		true		On NT this means we found the privilege. On Win9x we
//					always return this.
//
//		false		On NT this means the privilege is not recognized.  This
//					is never returned on Win9x.
//
//***************************************************************************
 
BOOL CSWbemPrivilege::GetPrivilegeValue (
	LPCTSTR lpName, 
	PLUID lpLuid
)
{
	// Allows any name to map to 0 LUID on Win9x - this aids script portability
	if (s_bIsNT)
		return ::LookupPrivilegeValue(NULL, lpName, lpLuid);
	else
		return true;
}

//***************************************************************************
//
//  SCODE CSWbemPrivilege::SetSecurity
//
//  DESCRIPTION:
//
//  Set Privileges on the Thread Token.
//
//***************************************************************************

BOOL CSWbemPrivilege::SetSecurity (
	CSWbemPrivilegeSet *pProvilegeSet,
	bool &needToResetSecurity,
	bool bUsingExplicitUserName,
	HANDLE &hThreadToken
)
{
	BOOL	result = TRUE;		// Default is success
	DWORD lastErr = 0;
	hThreadToken = NULL;			// Default assume we'll modify process token
	needToResetSecurity = false;	// Default assume we changed no privileges

	// Win9x has no security support
	if (s_bIsNT)
	{
		// Start by checking whether we are being impersonated.  On an NT4
		// box (which has no cloaking, and therefore cannot allow us to
		// pass on this impersonation to Winmgmt) we should RevertToSelf
		// if we have been configured to allow this.  If we haven't been
		// configured to allow this, bail out now.
		if (4 >= s_dwNTMajorVersion)
		{
			if (OpenThreadToken (GetCurrentThread (), TOKEN_QUERY|TOKEN_IMPERSONATE, true, &hThreadToken))
			{
				// We are being impersonated
				if (s_bCanRevert)
				{
					if (result = RevertToSelf())
						needToResetSecurity = true;
				}
				else
				{
					// Error - cannot do this!  Time to bail out
					CloseHandle (hThreadToken);
					hThreadToken = NULL;
					result = FALSE;
				}
			}
		}

		if (result)
		{
			// Now we check if we need to set privileges
			/*
			 * Specifying a user only makes sense for remote operations, and we
			 * don't need to mess with privilege for remote operations since
			 * they are set up by server logon anyway.
			 */
			if (!bUsingExplicitUserName)
			{
				// Nothing to do unless some privilege overrides have been set
				long lCount = 0;
				pProvilegeSet->get_Count (&lCount);

				if (0 < lCount)
				{
					if (4 < s_dwNTMajorVersion)
					{
						/*
						 * On NT5 we try to open the Thread token.  If the client app
						 * is calling into us on an impersonated thread (as IIS may be,
						 * for example), this will succeed. Otherwise, we use the process token
						 */
						HANDLE hToken;
						SECURITY_IMPERSONATION_LEVEL secImpLevel = SecurityImpersonation;
						
						if (!(result =  OpenThreadToken (GetCurrentThread (), TOKEN_QUERY|TOKEN_DUPLICATE|TOKEN_IMPERSONATE, true, &hToken)))
						{
							// No thread token - go for the Process token instead
							HANDLE hProcess = GetCurrentProcess ();
							result = OpenProcessToken(hProcess, TOKEN_QUERY|TOKEN_DUPLICATE, &hToken);
							CloseHandle (hProcess);
						}
						else
						{
							// We are working with a thread token
							hThreadToken = hToken;		
							// Try and get the impersonation level of this token
							DWORD dwReturnLength  = 0;
							BOOL thisRes = GetTokenInformation (hToken, TokenImpersonationLevel, &secImpLevel, 
											sizeof (SECURITY_IMPERSONATION_LEVEL), &dwReturnLength);
						}

						if (result)
						{
							/*
							 * Getting here means we have a valid token, be it process or thread. We
							 * now attempt to duplicate it before Adjusting the Privileges.
							 */
							HANDLE hDupToken;
							result = DuplicateTokenEx (hToken, TOKEN_QUERY|TOKEN_ADJUST_PRIVILEGES|TOKEN_IMPERSONATE, NULL,
											secImpLevel, TokenImpersonation, &hDupToken);

							if (result)
							{
								SetTokenPrivileges (hDupToken, pProvilegeSet);

								// Now use this token on the current thread
								if (SetThreadToken(NULL, hDupToken))
									needToResetSecurity = true;

								CloseHandle (hDupToken);
							}
							else
							{
								lastErr = GetLastError ();
							}
							
							/*
							 * If we are not using a thread token, close the token now. Otherwise
							 * the handle will be closed in the balanced call to RestorePrivileges ().
							 */
							if (!hThreadToken)
								CloseHandle (hToken);
						}
					}
					else
					{
						// For NT4 we adjust the privileges in the process token
						HANDLE hProcessToken = NULL;
						
						HANDLE hProcess = GetCurrentProcess ();
						result = OpenProcessToken(hProcess, TOKEN_QUERY|TOKEN_ADJUST_PRIVILEGES, &hProcessToken); 
						CloseHandle (hProcess);
						
						// Adjust privilege on the process
						if (result)
						{
							SetTokenPrivileges (hProcessToken, pProvilegeSet);
							CloseHandle (hProcessToken);
						}
					}
				}
			}
		}
	}

	return result;
}

//***************************************************************************
//
//  SCODE CEnumPrivilegeSet::ResetSecurity
//
//  DESCRIPTION:
//
//  Restore Privileges on the Thread Token.
//
//***************************************************************************

void	CSWbemPrivilege::ResetSecurity (
	HANDLE hThreadToken
)
{
	// Win9x has no security palaver
	if (s_bIsNT)
	{
		/* 
		 * Set the supplied token (which may be NULL) into
		 * the current thread.
		 */
		BOOL result = SetThreadToken (NULL, hThreadToken);
		DWORD error = 0;

		if (!result)
			error = GetLastError ();
			
		if (hThreadToken)
				CloseHandle (hThreadToken);
	}
}



//***************************************************************************
//
//  CSWbemPrivilege::SetTokenPrivileges
//
//  DESCRIPTION:
//
//  Adjust the Privileges on the specified token without allowing a future
//	restore of the current settings..
//
//  PARAMETERS:
//
//		hHandle			Handle of the token on which to adjust privileges
//		pPrivilegeSet	Specified privilege adjustments
//
//  RETURN VALUES:
//		none
//***************************************************************************

void CSWbemPrivilege::SetTokenPrivileges (
	HANDLE hHandle, 
	CSWbemPrivilegeSet *pPrivilegeSet
)
{
	DWORD lastErr = 0;

	if (pPrivilegeSet)
	{
		pPrivilegeSet->AddRef ();

		long lNumPrivileges = 0;
		pPrivilegeSet->get_Count (&lNumPrivileges);

		if (lNumPrivileges)
		{
			DWORD dwPrivilegeIndex = 0;

			/*
			 * Set up the token privileges array. Note that some jiggery-pokery
			 * is required here because the Privileges field is an [ANYSIZE_ARRAY]
			 * type.
			 */
			TOKEN_PRIVILEGES *pTokenPrivileges = (TOKEN_PRIVILEGES *) 
						new BYTE [sizeof(TOKEN_PRIVILEGES) + (lNumPrivileges * sizeof (LUID_AND_ATTRIBUTES [1]))];
			
			// Get the iterator
			PrivilegeMap::iterator next = pPrivilegeSet->m_PrivilegeMap.begin ();

			while (next != pPrivilegeSet->m_PrivilegeMap.end ())
			{
				CSWbemPrivilege *pPrivilege = (*next).second;
				pPrivilege->AddRef ();
				LUID luid;
				pPrivilege->GetLUID (&luid);
				VARIANT_BOOL vBool;
				pPrivilege->get_IsEnabled (&vBool);

				pTokenPrivileges->Privileges [dwPrivilegeIndex].Luid = luid;

				/*
				 * Note that any setting other than SE_PRIVILEGE_ENABLED
				 * is interpreted by AdjustTokenPrivileges as a DISABLE
				 * request for that Privilege.
				 */
				pTokenPrivileges->Privileges [dwPrivilegeIndex].Attributes
					= (VARIANT_TRUE == vBool) ?
					SE_PRIVILEGE_ENABLED : SE_PRIVILEGE_ENABLED_BY_DEFAULT;

				dwPrivilegeIndex++;
				pPrivilege->Release ();
				next++;
			}

			// Now we should have recorded the number of privileges that were OK

			if (0 < dwPrivilegeIndex)
			{
				pTokenPrivileges->PrivilegeCount = dwPrivilegeIndex;

				BOOL result = ::AdjustTokenPrivileges (hHandle, FALSE, pTokenPrivileges, 0, NULL, NULL);
				lastErr = GetLastError ();
			}

			delete [] pTokenPrivileges;
		}

		pPrivilegeSet->Release ();
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\xmltransport\compiler\control\xmltransf\parse.cpp ===
#include "precomp.h"
#include <windows.h>
#include <objbase.h>
#include <msxml.h>
#include "parse.h"

HRESULT CParseHelper::ParseClassPath(IXMLDOMNode *pNode, BSTR *pstrHostName, BSTR *pstrNamespace, BSTR *pstrClassName)
{
	HRESULT result = E_FAIL;

	// Get the Namespacepath followed by the class name
	IXMLDOMNode *pFirstNode = NULL, *pSecondNode = NULL;
	if(SUCCEEDED(result = pNode->get_firstChild(&pFirstNode)) && pFirstNode)
	{
		// Get the Namespace part
		if(SUCCEEDED(result = ParseNamespacePath(pFirstNode, pstrHostName, pstrNamespace)))
		{
			if(SUCCEEDED(result = pNode->get_lastChild(&pSecondNode)))
			{
				// Get the class name
				if(SUCCEEDED(result = GetBstrAttribute(pSecondNode, L"NAME", pstrClassName)))
				{
				}
				pSecondNode->Release();
			}
			else
			{
				SysFreeString(*pstrHostName);
				SysFreeString(*pstrNamespace);
				*pstrHostName = NULL;
				*pstrNamespace = NULL;
			}
		}
		pFirstNode->Release();
	}
	return result;
}

HRESULT CParseHelper::ParseNamespacePath(IXMLDOMNode *pLocalNamespaceNode, BSTR *pstrHost, BSTR *pstrLocalNamespace)
{
	HRESULT result = E_FAIL;

	// Get the HOST name first
	*pstrHost = NULL;
	IXMLDOMNode *pFirstNode, *pSecondNode = NULL;
	if(SUCCEEDED(result = pLocalNamespaceNode->get_firstChild(&pFirstNode)) && pFirstNode)
	{
		// Get the Namespace part
		if(SUCCEEDED (result = pFirstNode->get_text(pstrHost)))
		{
			if(SUCCEEDED(pLocalNamespaceNode->get_lastChild(&pSecondNode)))
			{
				// Get the instance path
				if(SUCCEEDED(result = ParseLocalNamespacePath(pSecondNode, pstrLocalNamespace)))
				{
				}
				pSecondNode->Release();
			}
		}
		pFirstNode->Release();
	}

	if(FAILED(result))
		SysFreeString(*pstrHost);

	return result;
}

HRESULT CParseHelper::ParseLocalNamespacePath(IXMLDOMNode *pLocalNamespaceNode, BSTR *pstrLocalNamespacePath)
{
	// Go thru the children collecting the NAME attribute and concatenating
	// This requires 2 passes since we dont know the length
	//=============================================================

	DWORD dwLength=0;
	*pstrLocalNamespacePath = NULL;
	HRESULT result = E_FAIL;

	IXMLDOMNodeList *pChildren = NULL;
	if(SUCCEEDED(result = pLocalNamespaceNode->get_childNodes(&pChildren)))
	{
		IXMLDOMNode *pNextChild = NULL;
		while(SUCCEEDED(pChildren->nextNode(&pNextChild)) && pNextChild)
		{
			BSTR strAttributeValue = NULL;
			GetBstrAttribute(pNextChild, L"NAME", &strAttributeValue);
			if(strAttributeValue)
			{
				dwLength += wcslen(strAttributeValue);
				dwLength ++; // For the back slash
				SysFreeString(strAttributeValue);
			}

			pNextChild->Release();
			pNextChild = NULL;
		}

		// Allocate memory
		LPWSTR pszNamespaceValue = NULL;
		if(pszNamespaceValue = new WCHAR[dwLength + 1])
		{
			pszNamespaceValue[0] = 0;

			// Once more
			pNextChild = NULL;
			pChildren->reset();
			while(SUCCEEDED(pChildren->nextNode(&pNextChild)) && pNextChild)
			{
				BSTR strAttributeValue = NULL;
				GetBstrAttribute(pNextChild, L"NAME", &strAttributeValue);
				if(strAttributeValue)
				{
					wcscat(pszNamespaceValue, strAttributeValue);
					wcscat(pszNamespaceValue, L"\\");
					SysFreeString(strAttributeValue);
				}

				pNextChild->Release();
				pNextChild = NULL;
			}

			pChildren->Release();

			// Remove the last back slash
			pszNamespaceValue[dwLength-1] = NULL;
			if(!(*pstrLocalNamespacePath = SysAllocString(pszNamespaceValue)))
				result = E_OUTOFMEMORY;

			delete [] pszNamespaceValue;
		}
		else
			result = E_OUTOFMEMORY;
	}

	return result;
}

HRESULT CParseHelper::GetBstrAttribute(IXMLDOMNode *pNode, const BSTR strAttributeName, BSTR *pstrAttributeValue)
{
	HRESULT result = E_FAIL;
	*pstrAttributeValue = NULL;

	IXMLDOMNamedNodeMap *pNameMap = NULL;
	if(SUCCEEDED(result = pNode->get_attributes(&pNameMap)))
	{
		IXMLDOMNode *pAttribute = NULL;
		if(SUCCEEDED(result = pNameMap->getNamedItem(strAttributeName, &pAttribute)))
		{
			if(result == S_FALSE)
				result = E_FAIL;
			else
			{
				result = pAttribute->get_text(pstrAttributeValue);
				pAttribute->Release();
			}

		}
		pNameMap->Release();
	}

	return result;
}

HRESULT CParseHelper::GetNamespacePath(IXMLDOMNode *pNamespaceNode, BSTR *pstrNamespacePath)
{
	HRESULT result = E_FAIL;
	*pstrNamespacePath = NULL;

	BSTR strHostName = NULL, strLocalNamespacePath = NULL;
	if(SUCCEEDED(result = ParseNamespacePath(pNamespaceNode, &strHostName, &strLocalNamespacePath)))
	{
			// Concatenate to form \\[host]\namespace
		LPWSTR pszRetValue = NULL;
		if(pszRetValue = new WCHAR[wcslen(strHostName) + wcslen(strLocalNamespacePath) + 6])
		{
			pszRetValue[0] = NULL;
			wcscat(pszRetValue, L"\\\\[");
			wcscat(pszRetValue, strHostName);
			wcscat(pszRetValue, L"]\\");
			wcscat(pszRetValue, strLocalNamespacePath);
			if(*pstrNamespacePath = SysAllocString(pszRetValue))
				result = S_OK;
			else
				result = E_OUTOFMEMORY;

			delete [] pszRetValue;
		}
		else
			result = E_OUTOFMEMORY;

		SysFreeString(strHostName);
		SysFreeString(strLocalNamespacePath);
	}
	return result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\xmltransport\compiler\control\xmltransf\putfact.h ===
#ifndef WMI_XML_COMP_NODE_FACT_H
#define WMI_XML_COMP_NODE_FACT_H

typedef enum 
{
	WMI_XML_DECLGROUP_INVALID,
	WMI_XML_DECLGROUP,
	WMI_XML_DECLGROUP_WITH_NAME,
	WMI_XML_DECLGROUP_WITH_PATH
}WMI_XML_DECLGROUP_TYPE;

class CCompileFactory : public IXMLNodeFactory
{
	LONG m_cRef;					// COM Ref Count
	WMI_XML_DECLGROUP_TYPE m_declGroupType; // The DECGROUP in the stream being compiled
	CMyPendingStream *m_pStream;	// The stream that will be checked when I've read one object
	IXMLDOMDocument **m_ppDocuments;// The resulting documents
	DWORD m_dwMaxNumDocuments;		// # of elements in the above array
	DWORD m_dwNumDocuments;			// # of documents in the above array - ie., #of elements that have data
	DWORD m_dwAvailableDocIndex;	// If GetDocument() is called we give out this document
	IXMLDOMDocument *m_pCurrentDocument; // Just a holder for the current document being parsed
	DWORD m_dwEmbeddingLevel;		// So that we dont return when we're at the end of an embedded object
	LPWSTR *m_pszElementNames;		// The factory manufactures elements of these names
	DWORD m_dwNumElements;			// Number of elements in the above array
	BOOL m_bNamespacePathProvided;	// Whether there is a NAMESPACEPATH in DECLGROUP/DECLGROUP.WITHNAME
	BOOL m_bLocalNamespacePathProvided;	// Whether there is a LOCALNAMESPACEPATH in DECLGROUP/DECLGROUP.WITHNAME
	BOOL m_bInHost;					// Whether we are currently parsing in the HOST element in a NAMESPACEPATH
	LPWSTR m_pszHostName;			// The HOST element in a NAMESPACEPATH
	LPWSTR m_pszLocalNamespacePath; // The concatenation of NAMESPACEs in LOCALNAMESPACEPATH

	// Whether a pragma was encountered in the call to this 
	HRESULT AddDocumentToList(IXMLDOMDocument *pNewDocument);
	HRESULT AddChildNode(IXMLDOMNode *pNodeParent, XML_NODE_INFO **aNodeInfo, USHORT cNumRecs, IXMLDOMNode **ppCurrentNode);
	HRESULT AddPCDATA(IXMLDOMNode *pNodeParent, XML_NODE_INFO **aNodeInfo);
	HRESULT AddCDATA(IXMLDOMNode *pNodeParent, XML_NODE_INFO **aNodeInfo);
	HRESULT AddAttributes(IXMLDOMElement *pElement, XML_NODE_INFO **aNodeInfo, USHORT cNumRecs);
	BOOL IsInterestingElement(LPCWSTR pszElementName);
	HRESULT SetHost(XML_NODE_INFO **aNodeInfo, USHORT cNumRecs);
	HRESULT AppendNamespace(XML_NODE_INFO **aNodeInfo, USHORT cNumRecs);

public:
	CCompileFactory(CMyPendingStream *pStream)
	{
		m_cRef = 1;
		m_declGroupType = WMI_XML_DECLGROUP_INVALID;

		if(m_pStream = pStream)
			m_pStream->AddRef();

		m_ppDocuments = NULL;
		m_dwNumDocuments = m_dwMaxNumDocuments = m_dwAvailableDocIndex = 0;
		m_pCurrentDocument = NULL;
		m_pszElementNames = NULL;
		m_dwNumElements = 0;
		m_bNamespacePathProvided = m_bLocalNamespacePathProvided = FALSE;
		m_bInHost = FALSE;
		m_pszHostName = m_pszLocalNamespacePath = NULL;
	}

	~CCompileFactory()
	{
		if(m_pStream)
			m_pStream->Release();

		// Release all the documents
		for(DWORD i=m_dwAvailableDocIndex; i<m_dwNumDocuments; i++)
			(m_ppDocuments[i])->Release();
		delete [] m_ppDocuments;
		if(m_pCurrentDocument)
			m_pCurrentDocument->Release();

		// Release all element names and the array
		for(DWORD i=0; i<m_dwNumElements; i++)
			delete [] m_pszElementNames[i];
		delete [] m_pszElementNames;

		delete [] m_pszHostName;
		delete [] m_pszLocalNamespacePath;
	}

	HRESULT GetDocument(IXMLDOMDocument **ppDocument);

	HRESULT SetElements(LPCWSTR *pszElementNames, DWORD dwNumElements)
	{
		// Release all element names and the array
		for(DWORD i=0; i<m_dwNumElements; i++)
			delete [] m_pszElementNames[i];
		delete [] m_pszElementNames;
		m_pszElementNames = NULL;
		m_dwNumElements = 0;

		HRESULT hr = S_OK;

		if(m_pszElementNames = new WCHAR *[dwNumElements])
		{
			for(DWORD i=0; i<dwNumElements; i++)
			{
				m_pszElementNames[i] = NULL;
				if(m_pszElementNames[i] = new WCHAR[wcslen(pszElementNames[i]) + 1])
					wcscpy(m_pszElementNames[i], pszElementNames[i]);
				else
					break;
			}

			// Did all go well?
			if(i<dwNumElements)
			{
				// Release all element names and the array
				for(DWORD j=0; j<i; j++)
					delete [] m_pszElementNames[j];
				delete [] m_pszElementNames;
				m_pszElementNames = NULL;
				m_dwNumElements = 0;
				hr = E_OUTOFMEMORY;
			}
			else
				m_dwNumElements = dwNumElements;
		}
		else
			hr = E_OUTOFMEMORY;
		return hr;
	}


	HRESULT STDMETHODCALLTYPE NotifyEvent(
            IXMLNodeSource* pSource,
            XML_NODEFACTORY_EVENT iEvt)
	{
		return S_OK;
	}

    HRESULT STDMETHODCALLTYPE BeginChildren(
            IXMLNodeSource* pSource, 
            XML_NODE_INFO* pNodeInfo);
			
            
    HRESULT STDMETHODCALLTYPE EndChildren(
            IXMLNodeSource* pSource,
            BOOL fEmpty,
            XML_NODE_INFO* pNodeInfo);


    HRESULT STDMETHODCALLTYPE Error(
            IXMLNodeSource* pSource,
            HRESULT hrErrorCode,
            USHORT cNumRecs,
            XML_NODE_INFO __RPC_FAR **aNodeInfo);


    HRESULT STDMETHODCALLTYPE CreateNode( 
            IXMLNodeSource __RPC_FAR *pSource,
            PVOID pNodeParent,
            USHORT cNumRecs,
            XML_NODE_INFO __RPC_FAR **aNodeInfo);

	STDMETHODIMP QueryInterface (
		IN REFIID riid,
		OUT LPVOID *ppv
	)
	{
		*ppv=NULL;

		if (IID_IUnknown==riid)
			*ppv = reinterpret_cast<IUnknown*>(this);
		else if (IID_IXMLNodeFactory==riid)
			*ppv = (IXMLNodeFactory *)this;

		if (NULL!=*ppv)
		{
			((LPUNKNOWN)*ppv)->AddRef();
			return NOERROR;
		}

		return ResultFromScode(E_NOINTERFACE);
	}

	STDMETHODIMP_(ULONG) AddRef(void)
	{
		InterlockedIncrement(&m_cRef);
		return m_cRef;
	}

	STDMETHODIMP_(ULONG) Release(void)
	{
		InterlockedDecrement(&m_cRef);
		if (0L!=m_cRef)
			return m_cRef;
		delete this;
		return 0;
	}
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\xmltransport\compiler\control\xmltransf\putfact.cpp ===
#include "precomp.h"
#include <assert.h>
#include <stdio.h>
#include <objsafe.h>
#include <wbemcli.h>
#include <xmlparser.h>
#include "XMLTransportClientHelper.h"
#include "XMLClientPacket.h"
#include "XMLClientPacketFactory.h"
#include "HTTPConnectionAgent.h"
#include "myStream.h"
#include "MyPendingStream.h"
#include "putfact.h"


HRESULT STDMETHODCALLTYPE CCompileFactory::BeginChildren(
        IXMLNodeSource* pSource,
        XML_NODE_INFO* pNodeInfo)
{
	// Make note of which DECLGROUP is being processed
	// Set the types of elements to be manufactured by the factory
	//============================================================
	if(_wcsicmp(pNodeInfo->pwcText, L"DECLGROUP") == 0)
	{
		m_declGroupType = WMI_XML_DECLGROUP;
		LPCWSTR pszElement = L"VALUE.OBJECT";
		SetElements(&pszElement, 1);
	}
	else if(_wcsicmp(pNodeInfo->pwcText, L"DECLGROUP.WITHNAME") == 0)
	{
		m_declGroupType = WMI_XML_DECLGROUP_WITH_NAME;
		LPCWSTR pszElement = L"VALUE.NAMEDOBJECT";
		SetElements(&pszElement, 1);
	}
	else if(_wcsicmp(pNodeInfo->pwcText, L"DECLGROUP.WITHPATH") == 0)
	{
		m_declGroupType = WMI_XML_DECLGROUP_WITH_PATH;
		LPCWSTR pszElement = L"VALUE.OBJECTWITHPATH";
		SetElements(&pszElement, 1);
	}
	return S_OK;
}


HRESULT STDMETHODCALLTYPE CCompileFactory::EndChildren(
        IXMLNodeSource* pSource,
        BOOL fEmpty,
        XML_NODE_INFO* pNodeInfo)
{
	HRESULT hr = E_FAIL;
	// See if it is the kind of elements we are manufacturing
	if(IsInterestingElement(pNodeInfo->pwcText))
	{
		// Stop the stream from issuing any more data
		m_pStream->SetPending(TRUE);

		// Add the document to the list of documents that we have
		hr = AddDocumentToList(m_pCurrentDocument);
		m_pCurrentDocument->Release();
		m_pCurrentDocument = NULL;
	}
	else
		hr = S_OK;
	//fwprintf(stderr, L"EndChildren() called for %s\n", pNodeInfo->pwcText);
	return hr;
}


HRESULT STDMETHODCALLTYPE CCompileFactory::Error(
        IXMLNodeSource* pSource,
        HRESULT hrErrorCode,
        USHORT cNumRecs,
        XML_NODE_INFO __RPC_FAR **aNodeInfo)
{
	BSTR strReason = NULL;
	ULONG uLine = 0 , uPosition = 0;

	pSource->GetErrorInfo(&strReason);
	uLine = pSource->GetLineNumber();
	uPosition = pSource->GetLinePosition();
	fwprintf(stderr, L"An Error occured at Line:%d, Position%d, Source:%s, Reason%X\n",
		uLine, uPosition, strReason, hrErrorCode);
	return S_OK;
}


HRESULT STDMETHODCALLTYPE CCompileFactory::CreateNode(
        IXMLNodeSource __RPC_FAR *pSource,
        PVOID pNodeParent,
        USHORT cNumRecs,
        XML_NODE_INFO __RPC_FAR **aNodeInfo)
{
	HRESULT hr = S_OK;

	if(cNumRecs)
	{
		//fwprintf(stderr, L"CreateNode() called for %s with %d elements\n", (*aNodeInfo)->pwcText), cNumRecs;
		switch( (aNodeInfo[0])->dwType)
		{
			case XML_ELEMENT:
			{
				// If it is an interesting element
				// the (!pNodeParent) check leaves out embedded objects
				if(IsInterestingElement(aNodeInfo[0]->pwcText))
				{
					if(!pNodeParent)
					{
						// Create a new document for the class or instance
						if(m_pCurrentDocument)
						{
							m_pCurrentDocument->Release();
							m_pCurrentDocument = NULL;
						}
						if(SUCCEEDED(hr = CoCreateInstance(CLSID_DOMDocument, NULL, CLSCTX_INPROC_SERVER,
												IID_IXMLDOMDocument, (LPVOID *)&m_pCurrentDocument)))
						{
							// Make sure this is the parent node for this call
							 pNodeParent = m_pCurrentDocument;
						}
					}
					// Otherwise it is an embedded object. Just add it to the parent below.
				}
				else
				{
					// Make a check as to whether this is the LOCALNAMESPACEPATH or NAMESPACEPATH in DECLGROUP and DECLGROUP.WITHNAME
					if(!pNodeParent)
					{
						if (_wcsicmp(aNodeInfo[0]->pwcText, L"NAMESPACEPATH") == 0 ||_wcsicmp(aNodeInfo[0]->pwcText, L"NAMESPACEPATH") == 0)
						{
							if (_wcsicmp(aNodeInfo[0]->pwcText, L"NAMESPACEPATH") == 0)
								m_bNamespacePathProvided = TRUE;
							else if (_wcsicmp(aNodeInfo[0]->pwcText, L"NAMESPACEPATH") == 0)
								m_bLocalNamespacePathProvided = TRUE;
						}
						else if (_wcsicmp(aNodeInfo[0]->pwcText, L"HOST") == 0)
						{
							m_bInHost = TRUE;
						}
						else if (_wcsicmp(aNodeInfo[0]->pwcText, L"NAMESPACE") == 0)
						{
							hr = AppendNamespace(aNodeInfo, cNumRecs);
						}

					}
				}

				// Create a XML DOM Node under the parent node
				if(SUCCEEDED(hr) && m_pCurrentDocument)
				{
					IXMLDOMNode *pCurrentNode = NULL;
					if(SUCCEEDED(hr = AddChildNode((IXMLDOMNode *)pNodeParent, aNodeInfo, cNumRecs, &pCurrentNode)))
					{
						// Set the parent for the children of this element
						aNodeInfo[0]->pNode = pCurrentNode;
					}
				}
			}
			break;
			case XML_PCDATA:
			{
				if(pNodeParent)
				{
					if(m_bInHost)
					{
						m_bInHost = FALSE;
						hr = SetHost(aNodeInfo, cNumRecs);
					}
					else
						hr = AddPCDATA((IXMLDOMNode *)pNodeParent, aNodeInfo);
				}
				else
				{
					// Nothing needs to be done. This is PCDATA in a node that we arent interested in
				}
			}
			break;
			case XML_CDATA:
			{
				if(pNodeParent)
				{
					hr = AddCDATA((IXMLDOMNode *)pNodeParent, aNodeInfo);
				}
				else
				{
					// Nothing needs to be done. This is PCDATA in a node that we arent interested in
				}
			}

		}
	}
	else
		fwprintf(stderr, L"CreateNode() called for with 0 elements\n");

	assert(SUCCEEDED(hr));
	return hr;
}

HRESULT CCompileFactory::AddDocumentToList(IXMLDOMDocument *pNewDocument)
{
	HRESULT hr = S_OK;

	if(1+m_dwNumDocuments > m_dwMaxNumDocuments)
	{
		// Reallocate an array
		IXMLDOMDocument **ppNewArray = NULL;
		m_dwMaxNumDocuments += 5; // Increase the size by 5
		ppNewArray = new IXMLDOMDocument*[m_dwMaxNumDocuments];
		if(ppNewArray)
		{
			// Copy old elements to this one
			for(DWORD i=0; i<m_dwNumDocuments; i++)
				ppNewArray[i] = m_ppDocuments[i];

			delete [] m_ppDocuments;
			m_ppDocuments = ppNewArray;

		}
		else
			hr = E_OUTOFMEMORY;
	}

	// Copy the latest one
	m_ppDocuments[m_dwNumDocuments++] = pNewDocument;
	pNewDocument->AddRef();
	assert(SUCCEEDED(hr));

	return hr;
}

HRESULT CCompileFactory::AddChildNode(IXMLDOMNode *pNodeParent, XML_NODE_INFO **aNodeInfo, USHORT cNumRecs, IXMLDOMNode **ppCurrentNode)
{
	HRESULT hr = E_FAIL;
	BSTR strElementName = NULL;
	if(strElementName = SysAllocString(aNodeInfo[0]->pwcText))
	{
		// Create a new Element in the document
		*ppCurrentNode = NULL;
		IXMLDOMElement *pNewElement = NULL;
		if(SUCCEEDED(hr = m_pCurrentDocument->createElement(strElementName, &pNewElement)))
		{
			// Add the element to the parent node
			if(SUCCEEDED(hr = pNodeParent->appendChild(pNewElement, NULL)))
			{
				// Add the attributes of the new element
				if(SUCCEEDED(hr = AddAttributes(pNewElement, aNodeInfo, cNumRecs)))
				{
					pNewElement->AddRef();
					*ppCurrentNode = pNewElement;
				}

			}
			pNewElement->Release();
		}
		SysFreeString(strElementName);
	}
	else
		hr = E_OUTOFMEMORY;

	assert(SUCCEEDED(hr));
	return hr;
}

HRESULT CCompileFactory::AddPCDATA(IXMLDOMNode *pNodeParent, XML_NODE_INFO **aNodeInfo)
{
	HRESULT hr = S_OK;
	BSTR strElementValue = NULL;
	if(aNodeInfo[0]->dwType == XML_PCDATA)
	{
		// Just copy the text
		if(strElementValue = SysAllocStringLen(aNodeInfo[0]->pwcText, aNodeInfo[0]->ulLen))
		{
		}
		else
			hr = E_OUTOFMEMORY;
	}
	else if(aNodeInfo[0]->dwType == XML_CDATA)
	{
		// Just copy the text - RAJESHR is this correct
		if(strElementValue = SysAllocStringLen(aNodeInfo[0]->pwcText, aNodeInfo[0]->ulLen))
		{
		}
		else
			hr = E_OUTOFMEMORY;
	}

	if(strElementValue)
	{
		hr = pNodeParent->put_text(strElementValue);
		SysFreeString(strElementValue);
	}
	return hr;
}


HRESULT CCompileFactory::AddCDATA(IXMLDOMNode *pNodeParent, XML_NODE_INFO **aNodeInfo)
{
	return S_OK;
}

HRESULT CCompileFactory::AddAttributes(IXMLDOMElement *pElement, XML_NODE_INFO **aNodeInfo, USHORT cNumRecs)
{
	// If the element has no attributes, then return.
	if(cNumRecs <= 1)
		return S_OK;

	HRESULT hr = E_FAIL;
	DWORD i=1;
	while(i<cNumRecs)
	{
		if(aNodeInfo[i]->dwType == XML_ATTRIBUTE)
		{
			// Get the Attribute Name
			BSTR strAttributeName = NULL;
			if(strAttributeName = SysAllocStringLen(aNodeInfo[i]->pwcText, aNodeInfo[i]->ulLen))
			{
				// Get the attribute value
				i++;
				BSTR strAttributeValue = NULL;
				if(aNodeInfo[i]->dwType == XML_PCDATA)
				{
					// Just copy the text
					if(strAttributeValue = SysAllocStringLen(aNodeInfo[i]->pwcText, aNodeInfo[i]->ulLen))
					{
					}
					else
						hr = E_OUTOFMEMORY;
				}
				else if(aNodeInfo[i]->dwType == XML_CDATA)
				{
					// Just copy the text - RAJESHR is this correct
					if(strAttributeValue = SysAllocStringLen(aNodeInfo[i]->pwcText, aNodeInfo[i]->ulLen))
					{
					}
					else
						hr = E_OUTOFMEMORY;
				}

				if(strAttributeValue)
				{
					VARIANT vValue;
					VariantInit(&vValue);
					vValue.vt = VT_BSTR;
					vValue.bstrVal = strAttributeValue;
					hr = pElement->setAttribute(strAttributeName, vValue);
					VariantClear(&vValue);
				}

				SysFreeString(strAttributeName);
			}
			else
				hr = E_OUTOFMEMORY;
		}
		i++; // Move on to the next element in the array
	}
	assert(SUCCEEDED(hr));
	return hr;
}

HRESULT CCompileFactory::GetDocument(IXMLDOMDocument **ppDocument)
{
	// See if there is one more document that can be given away
	if(m_dwAvailableDocIndex >= m_dwNumDocuments)
		return E_FAIL;

	*ppDocument = m_ppDocuments[m_dwAvailableDocIndex++];

	// Allow more data to be read from the stream if we dont have another document to be buffered
	if(m_dwAvailableDocIndex > m_dwNumDocuments - 1)
		m_pStream->SetPending(FALSE);

	return S_OK;
}

BOOL CCompileFactory::IsInterestingElement(LPCWSTR pszElementName)
{
	BOOL bRetVal = FALSE;
	for(DWORD i=0; i<m_dwNumElements; i++)
	{
		if(_wcsicmp(m_pszElementNames[i], pszElementName) == 0)
		{
			bRetVal = TRUE;
			break;
		}
	}
	return bRetVal;
}

HRESULT CCompileFactory::SetHost(XML_NODE_INFO **aNodeInfo, USHORT cNumRecs)
{
	HRESULT hr = E_FAIL;
	// Just copy the value of the elementaNodeInfo[0]->pwcText,
	delete [] m_pszHostName;
	m_pszHostName = NULL;
	if(m_pszHostName = new WCHAR [aNodeInfo[0]->ulLen + 1])
	{
		wcsncpy(m_pszHostName, aNodeInfo[0]->pwcText, aNodeInfo[0]->ulLen);
		hr = S_OK;
	}
	else
		hr = E_OUTOFMEMORY;
	return hr;
}

HRESULT CCompileFactory::AppendNamespace(XML_NODE_INFO **aNodeInfo, USHORT cNumRecs)
{
	HRESULT hr = E_FAIL;
	// There's got to be exactly one attribute in a NAMESPACE element
	if(cNumRecs == 3)
	{
		if(aNodeInfo[1]->dwType == XML_ATTRIBUTE)
		{
			// Get the NAME Attribute
			if(_wcsnicmp(aNodeInfo[1]->pwcText, L"NAME", aNodeInfo[1]->ulLen) == 0)
			{
				// Get the attribute value
				if(aNodeInfo[2]->dwType == XML_PCDATA)
				{
					// Just append the value of the attribute
					LPCWSTR pszPreviousValue = m_pszLocalNamespacePath;
					if(pszPreviousValue) // Append a "\" and then the namespace component
					{
						m_pszLocalNamespacePath = NULL;
						if(m_pszLocalNamespacePath = new WCHAR [wcslen(pszPreviousValue) + 1 + aNodeInfo[2]->ulLen + 1])
						{
							wcscpy(m_pszLocalNamespacePath, pszPreviousValue);
							wcscat(m_pszLocalNamespacePath, L"\\");
							wcsncat(m_pszLocalNamespacePath, aNodeInfo[2]->pwcText, aNodeInfo[2]->ulLen);
							hr = S_OK;
						}
						else
							hr = E_OUTOFMEMORY;

					}
					else // Just copy the namespace component
					{
						m_pszLocalNamespacePath = NULL;
						if(m_pszLocalNamespacePath = new WCHAR [aNodeInfo[2]->ulLen + 1])
						{
							wcsncpy(m_pszLocalNamespacePath, aNodeInfo[2]->pwcText, aNodeInfo[2]->ulLen);
							hr = S_OK;
						}
						else
							hr = E_OUTOFMEMORY;

					}
				}
				else if(aNodeInfo[2]->dwType == XML_CDATA)
				{
					// Just append the value of the attribute
					LPCWSTR pszPreviousValue = m_pszLocalNamespacePath;
					if(pszPreviousValue) // Append a "\" and then the namespace component
					{
						m_pszLocalNamespacePath = NULL;
						if(m_pszLocalNamespacePath = new WCHAR [wcslen(pszPreviousValue) + 1 + aNodeInfo[2]->ulLen + 1])
						{
							wcscpy(m_pszLocalNamespacePath, pszPreviousValue);
							wcscat(m_pszLocalNamespacePath, L"\\");
							wcsncat(m_pszLocalNamespacePath, aNodeInfo[2]->pwcText, aNodeInfo[2]->ulLen);
							hr = S_OK;
						}
						else
							hr = E_OUTOFMEMORY;

					}
					else // Just copy the namespace component
					{
						m_pszLocalNamespacePath = NULL;
						if(m_pszLocalNamespacePath = new WCHAR [aNodeInfo[2]->ulLen + 1])
						{
							wcsncpy(m_pszLocalNamespacePath, aNodeInfo[2]->pwcText, aNodeInfo[2]->ulLen);
							hr = S_OK;
						}
						else
							hr = E_OUTOFMEMORY;

					}
				}
			}
		}
	}
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\xmltransport\compiler\xmlcomp\filestr.cpp ===
#include <windows.h>
#include <io.h>
#include <stdio.h>
#include <objbase.h>
#include "filestr.h"

CFileStream::CFileStream():m_cRef(1)
{
	m_pFile = NULL;
}

CFileStream::~CFileStream()
{
	if(m_pFile)
		fclose(m_pFile);
}

HRESULT CFileStream::QueryInterface(REFIID iid,void ** ppvObject)
{
	if(iid == IID_IUnknown)
	{
		*ppvObject = (IUnknown *)this;
		AddRef();
		return S_OK;
	}
	else
	{
		if(iid == IID_IStream)
		{
			*ppvObject = (IStream*)this;
			AddRef();
			return S_OK;
		}
	}

	return E_NOTIMPL;
}

ULONG CFileStream::AddRef()
{
	return InterlockedIncrement(&m_cRef);
}

ULONG CFileStream::Release()
{
	if(InterlockedDecrement(&m_cRef)==0)
		delete this;

	return m_cRef;
}


HRESULT CFileStream::Read(void *pv,ULONG cb,ULONG *pcbRead)
{
	HRESULT hr = S_OK;
	*pcbRead = fread(pv, 1, cb, m_pFile);
	return hr;
}

HRESULT CFileStream::Write(void const *pv,ULONG cb,ULONG *pcbWritten)
{
	return E_FAIL;
}

HRESULT CFileStream::Seek(LARGE_INTEGER dlibMove, DWORD dwOrigin, ULARGE_INTEGER *plibNewPosition)
{
	// We're in no position to fill in the last argument
	if(plibNewPosition != NULL)
		return E_FAIL;

	// Map the IStream seek arguments to FILE seek argument
	int origin = SEEK_SET;
	switch(dwOrigin)
	{
		case STREAM_SEEK_SET:
			origin = SEEK_SET; break;
		case STREAM_SEEK_CUR:
			origin = SEEK_CUR; break;
		case STREAM_SEEK_END:
			origin = SEEK_END; break;
	}

	// fseek return 0 if it succeeds
	if(fseek(m_pFile, (long)dlibMove.LowPart, origin) == 0)
		return S_OK;

	return E_FAIL;
}

HRESULT CFileStream::SetSize(ULARGE_INTEGER libNewSize)
{
	return E_FAIL;
}

HRESULT CFileStream::CopyTo(IStream *pstm,ULARGE_INTEGER cb,ULARGE_INTEGER *pcbRead,ULARGE_INTEGER *pcbWritten)
{
	return E_FAIL;
}

HRESULT CFileStream::Commit(DWORD grfCommitFlags)
{
	return E_FAIL;
}

HRESULT CFileStream::Revert(void)
{
	return E_FAIL;
}
	
HRESULT CFileStream::LockRegion(ULARGE_INTEGER libOffset,ULARGE_INTEGER cb,DWORD dwLockType)
{
	return E_FAIL;
}

HRESULT CFileStream::UnlockRegion(ULARGE_INTEGER libOffset,ULARGE_INTEGER cb,DWORD dwLockType)
{
	return E_FAIL;
}

HRESULT CFileStream::Stat(STATSTG *pstatstg,DWORD grfStatFlag)
{
	// Get the file Handle
	int hFile = _fileno(m_pFile);

	// Get the length of the file
	long lFileLength = 0;
	if((lFileLength = _filelength(hFile)) == -1L)
		return E_FAIL;

	// Fill in the STATSTG structure
	(pstatstg->cbSize).LowPart = lFileLength;

	return S_OK;
}

HRESULT CFileStream::Clone(IStream **ppstm)
{
	return E_FAIL;
}

HRESULT CFileStream::Initialize(LPCWSTR pszFileName)
{
	HRESULT hr = E_FAIL;
	if(m_pFile)
	{
		fclose(m_pFile);
		m_pFile = NULL;
	}
	
	if(m_pFile = _wfopen(pszFileName, L"r"))
		hr = S_OK;

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\xmltransport\compiler\xmlcomp\errors.h ===
#ifndef XML_COMP_ERR_H
#define XML_COMP_ERR_H


void CreateMessage(UINT iStringTableID, ...);
void CreateWMIMessage(HRESULT hr);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\xmltransport\compiler\xmlcomp\makefile.inc ===
############################################################################
#
#   Copyright (C) 1999, Microsoft Corporation.
#
#   All rights reserved.
#
############################################################################

!INCLUDE $(_NTDRIVE)$(_NTROOT)\WMI\COMMON\makefile.cmn
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\xmltransport\compiler\xmlcomp\errors.cpp ===
#include <windows.h>
#include <stdio.h>
#include <stdarg.h>
#include <objbase.h>
#include <wbemcli.h>
#include "resource.h"
#include "errors.h"

// Command-line Error Messages
LPCWSTR s_pszErrors[] = 
{
	// 0-4
	L"Error on command-line at position %d - Invalid character",
	L"Missing value for switch at position %d",
	L"Unrecognized switch %s found at position %d",
	L"Unrecognized Authentication Level %s at position %d",
	L"Unrecognized Impersonation Level %s at position %d",

	// 5-9
	L"Unrecognized Operation %s at position %d",
	L"Unrecognized Class Flag %s at position %d",
	L"Unrecognized Instance Flag %s at position %d",
	L"Unrecognized DeclGroup type %s at position %d",
	L"No Operation specified on the command-line. Use the /op switch",

	//10-14
	L"Invalid switch(es) for the operation specified",
	L"No Input File/URL Specified. Use the /i switch",
	L"Only one operation at a time, please",
	L"No Object specified for the operation. Use the /obj switch",
	L"Invalid switch (/deep or /query or /names) for /op=get",

	//15-19
	L"No Query specified for /op=query. Use the /query switch",
	L"Invalid switch (/deep or /obj or /names) for /op=query",
	L"Invalid switch (/query) for the enumeration operation",
	L"Unrecognized Encoding %s at %d",
	L"Input File %s cannot be found, or unreadable",

	// 20-24
	L"Syntax errors in input file %s",
	L"Compilation errors in input file %s",
	L"Syntax check passed successfully on input file %s",
	L"Compilation successfully done on input file %s"
};

// Syntax Errors
LPCWSTR s_pszSyntaxErrors[] = 
{
	// 0-4
	L"Error in Server XML response at line# %d and position %d.\n"\
		L"\tThe source text is \"%s\", and the reason is \"%s\""
};

// Information Messages
LPCWSTR s_pszInformation [] =
{
	//0-4
	L"WMI XML Tranformer\n"\
		L"===================\n",
	L"The file %s was successfully compiled\n",
	L"The Operation was successful\n"

};

void CreateMessage(UINT iStringTableID, ...)
{
	// Get the error string template from the string table
	WCHAR pszErr[256];
	int length = 0;
	if(length = LoadString(NULL, iStringTableID, pszErr, 256))
	{
		pszErr[length] = NULL;

		// Initialize the var args variables
		va_list marker;
		va_start( marker, iStringTableID);     

		vfwprintf(stderr, pszErr, marker );
	}
	else
		fwprintf(stderr, L"Catastrophic error - could not get the string table of error messages");
}

void CreateWMIMessage(HRESULT hr)
{
	BSTR bsMessageText = NULL;

	// Used as our error code translator
	IWbemStatusCodeText *pErrorCodeTransformer = NULL;

	HRESULT result = CoCreateInstance (CLSID_WbemStatusCodeText, 0, CLSCTX_INPROC_SERVER,
				IID_IWbemStatusCodeText, (LPVOID *) &pErrorCodeTransformer);

	if (SUCCEEDED (result))
	{
		if(SUCCEEDED(pErrorCodeTransformer->GetErrorCodeText(hr, (LCID) 0, 0, &bsMessageText)) && bsMessageText)
		{
			// Create a message with the WMI message embedded in it
			CreateMessage(XML_COMP_WMI_ERROR, bsMessageText);
			SysFreeString(bsMessageText);
		}
		else
		{
			// Create a messge with the hex value of the COM HRESULT in it
			CreateMessage(XML_COMP_UNKNOWN_ERROR, hr);
		}
		pErrorCodeTransformer->Release ();
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\xmltransport\compiler\control\xmltransf\tests\main.cpp ===
#include <windows.h>
#include <stdio.h>
#include <stdarg.h>
#include <objbase.h>
#include <objsafe.h>

#include <wbemcli.h>
#include <xmltransf.h>

int _cdecl main()
{
	CoInitialize(NULL);

	// Create a context object
	IWbemContext  *pContext;		
    HRESULT hrs = CoCreateInstance(CLSID_WbemContext, NULL, 
                          CLSCTX_INPROC_SERVER, IID_IWbemContext, 
                          (void**) &pContext);
    
	IWmiXMLTransformer *pXMLT = NULL;

	// Create the transformer
	HRESULT hr = CoCreateInstance(CLSID_WmiXMLTransformer, NULL, CLSCTX_ALL, IID_IWmiXMLTransformer, 
			(LPVOID *)&pXMLT);

	// Create the transformer
	hr = CoCreateInstance(CLSID_WmiXMLTransformer, NULL, CLSCTX_ALL, IID_IWmiXMLTransformer, 
			(LPVOID *)&pXMLT);


	if (SUCCEEDED(hr)) 
	{
		pXMLT->put_ClassOriginFilter (false) ;
		pXMLT->put_QualifierFilter (false);
		pXMLT->put_XMLEncodingType (wmiXML_WMI_DTD_WHISTLER) ;
		pXMLT->put_ImpersonationLevel (3) ;
		pXMLT->put_Transport (wmiXML_DCOM) ;

		BSTR namesp = SysAllocString(L"root\\cimv2") ;
		BSTR query = SysAllocString(L"select * from Win32_Processor") ;
		BSTR qLang = SysAllocString(L"WQL") ;

		// The call below faults is I pass pContext as the last parameter.
		ISWbemXMLDocumentSet *pSet = NULL;
		if(SUCCEEDED(pXMLT->ExecQuery (namesp, query, qLang, NULL, &pSet)))
		{
			IXMLDOMDocument *pDoc = NULL;
			while(SUCCEEDED(hr = pSet->NextDocument(&pDoc)) && (hr != WBEM_S_FALSE))
			{
				IXMLDOMElement *pElement = NULL;
				if(SUCCEEDED(pDoc->get_documentElement(&pElement)))
				{
					BSTR strXML  = NULL;
					if(SUCCEEDED(pElement->get_text(&strXML)))
					{
						wprintf(strXML);
						SysFreeString(strXML);
					}
					pElement->Release();
				}
				pDoc->Release();	
			}
			pDoc = NULL;
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\xmltransport\compiler\xmlcomp\filestr.h ===
#if !defined(MY_FILE_STREAM_H)
#define MY_FILE_STREAM_H

class CFileStream:public IStream
{

private:

	FILE *m_pFile;
	LONG	m_cRef;
	
public:
	
	CFileStream();
	virtual ~CFileStream();

public:
	//IUnknown fns
	HRESULT __stdcall QueryInterface(REFIID iid,void ** ppvObject);
	ULONG __stdcall AddRef();
	ULONG __stdcall Release();

	// IStream Functions
	HRESULT __stdcall Read(void *pv,ULONG cb,ULONG *pcbRead);
	HRESULT __stdcall Write(void const *pv,ULONG cb,ULONG *pcbWritten);
	HRESULT __stdcall Seek(LARGE_INTEGER dlibMove,DWORD dwOrigin,ULARGE_INTEGER *plibNewPosition);
	HRESULT __stdcall SetSize(ULARGE_INTEGER libNewSize);
	HRESULT __stdcall CopyTo(IStream *pstm,ULARGE_INTEGER cb,ULARGE_INTEGER *pcbRead,ULARGE_INTEGER *pcbWritten);
	HRESULT __stdcall Commit(DWORD grfCommitFlags);
	HRESULT __stdcall Revert(void);
	HRESULT __stdcall LockRegion(ULARGE_INTEGER libOffset,ULARGE_INTEGER cb,DWORD dwLockType);
	HRESULT __stdcall UnlockRegion(ULARGE_INTEGER libOffset,ULARGE_INTEGER cb,DWORD dwLockType);
	HRESULT __stdcall Stat(STATSTG *pstatstg,DWORD grfStatFlag);
	HRESULT __stdcall Clone(IStream **ppstm);

	// Other Functions
	HRESULT Initialize(LPCWSTR pszFileName);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\xmltransport\compiler\xmlcomp\main.cpp ===
#include <windows.h>
#include <stdio.h>
#include <stdarg.h>
#include <objbase.h>
#include <objsafe.h>
#include <wbemcli.h>
#include "xmltrnsf.h"
#include "errors.h"
#include "ui.h"
#include "opns.h"
#include "filestr.h"
#include "resource.h"

// A function to enable all privileges on the process token
static HRESULT EnableAllPrivileges();


int _cdecl main(int argc, char * argv[])
{
	if(FAILED(CoInitialize(NULL)))
		return 1;

	CreateMessage(XML_COMP_HEADER);

	CXmlCompUI theUI;
	int iMainReturnValue = 1;
	HRESULT hr = S_OK;

	// Parse the command-line
	//===========================
	if( SUCCEEDED(theUI.ProcessCommandLine(GetCommandLine()) ))
	{
		// Enable privileges if required
		//===============================
		if(theUI.m_bEnableAllPrivileges)
		{
			if(FAILED(EnableAllPrivileges()))
			{
				CreateMessage(XML_COMP_ERR_PRIVILEGES);
				return 1;
			}
		}

		// Execute the operation required
		//==================================
		switch(theUI.m_iCommand)
		{
			case XML_COMP_WELL_FORM_CHECK:
			case XML_COMP_VALIDITY_CHECK:
			case XML_COMP_COMPILE:
			{

				// First check if the file exists
				//==================================
				CFileStream cInputFile;
				if(!SUCCEEDED(cInputFile.Initialize(theUI.m_pszInputFileName)))
				{
					CreateMessage(XML_COMP_ERR_INPUT_FILE_NOT_FOUND, theUI.m_pszInputFileName);
					exit(1);
				}

				// Now do the compilation
				//=====================================
				if(SUCCEEDED(DoCompilation(&cInputFile, &theUI)))
				{
					CreateMessage(XML_COMP_SUCCESSFUL_PROCESSING, theUI.m_pszInputFileName);
					return 0;
				}
				else
				{
					CreateMessage(XML_COMP_ERR_SYNTAX_ERRORS, theUI.m_pszInputFileName);
					return 1;
				}

				break;
			}
			case XML_COMP_GET:
				if(SUCCEEDED(hr = DoGetObject(&theUI)))
					iMainReturnValue = 0;
				else
					CreateWMIMessage(hr);
				break;
			case XML_COMP_QUERY:
				if(SUCCEEDED(hr = DoQuery(&theUI)))
					iMainReturnValue = 0;
				else
					CreateWMIMessage(hr);
				break;
			case XML_COMP_ENUM_INST:
				if(SUCCEEDED(hr = DoEnumInstance(&theUI)))
					iMainReturnValue = 0;
				else
					CreateWMIMessage(hr);
				break;
			case XML_COMP_ENUM_CLASS:
				if(SUCCEEDED(hr = DoEnumClass(&theUI)))
					iMainReturnValue = 0;
				else
					CreateWMIMessage(hr);
				break;
			case XML_COMP_ENUM_INST_NAMES:
				if(SUCCEEDED(hr = DoEnumInstNames(&theUI)))
					iMainReturnValue = 0;
				else
					CreateWMIMessage(hr);
				break;
			case XML_COMP_ENUM_CLASS_NAMES:
				if(SUCCEEDED(hr = DoEnumClassNames(&theUI)))
					iMainReturnValue = 0;
				else
					CreateWMIMessage(hr);
				break;
		}

	}
	if(iMainReturnValue == 0)
		CreateMessage(XML_COMP_SUCCESSFUL_OPERATION);
	return iMainReturnValue;
}


// This code is copied from wbemtest.cpp in the wbemtest project under winmgmt
static HRESULT EnableAllPrivileges()
{
    // Open process token
    // =================

    HANDLE hToken = NULL;
    BOOL bRes = FALSE;

    bRes = OpenProcessToken(GetCurrentProcess(), TOKEN_QUERY | TOKEN_ADJUST_PRIVILEGES, &hToken);

    if(!bRes)
        return WBEM_E_ACCESS_DENIED;

    // Get the privileges
    // ==================

    DWORD dwLen;
    TOKEN_USER tu;
    memset(&tu,0,sizeof(TOKEN_USER));
    bRes = GetTokenInformation(hToken, TokenPrivileges, &tu, sizeof(TOKEN_USER), &dwLen);

    BYTE* pBuffer = new BYTE[dwLen];
    if(pBuffer == NULL)
    {
        CloseHandle(hToken);
        return WBEM_E_OUT_OF_MEMORY;
    }

    bRes = GetTokenInformation(hToken, TokenPrivileges, pBuffer, dwLen,
                                &dwLen);
    if(!bRes)
    {
        CloseHandle(hToken);
        delete [] pBuffer;
        return WBEM_E_ACCESS_DENIED;
    }

    // Iterate through all the privileges and enable them all
    // ======================================================

    TOKEN_PRIVILEGES* pPrivs = (TOKEN_PRIVILEGES*)pBuffer;
    for(DWORD i = 0; i < pPrivs->PrivilegeCount; i++)
    {
        pPrivs->Privileges[i].Attributes |= SE_PRIVILEGE_ENABLED;
    }

    // Store the information back into the token
    // =========================================

    bRes = AdjustTokenPrivileges(hToken, FALSE, pPrivs, 0, NULL, NULL);
    delete [] pBuffer;
    CloseHandle(hToken);

    if(!bRes)
        return WBEM_E_ACCESS_DENIED;
    else
        return WBEM_S_NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\xmltransport\dtd\makefile.inc ===
############################################################################
#
#   Copyright (C) 1999, Microsoft Corporation.
#
#   All rights reserved.
#
############################################################################

!INCLUDE $(_NTDRIVE)$(_NTROOT)\WMI\COMMON\makefile.cmn
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\xmltransport\compiler\xmlcomp\opns.h ===
#ifndef XML_COMP_OPNS_H
#define XML_COMP_OPNS_H

// These Functions are for writing Some common XML tags into the output
static STDMETHODIMP MapCommonHeaders (FILE *fp, CXmlCompUI *pUI);
static STDMETHODIMP MapCommonTrailers (FILE *fp, CXmlCompUI *pUI);
static STDMETHODIMP MapDeclGroupHeaders (FILE *fp, CXmlCompUI *pUI );
static STDMETHODIMP MapDeclGroupTrailers (FILE *fp, CXmlCompUI *pUI);

// Helper functions
static HRESULT WriteOneDeclGroupNode(FILE *fp, IXMLDOMNode *pTopElement, CXmlCompUI *pUI );
static HRESULT WriteOneDeclGroupDocument(FILE *fp, IXMLDOMDocument *pDocument, CXmlCompUI *pUI );
static HRESULT GetFirstImmediateElement(IXMLDOMNode *pParent, IXMLDOMElement **ppChildElement, LPCWSTR pszName);
static HRESULT WriteNode(FILE *fp, IXMLDOMNode *pOutputNode, CXmlCompUI *pUI);
static HRESULT SaveStreamToBstrVariant (IStream *pStream, VARIANT *pVariant);
static HRESULT SaveStreamToUnkVariant (IStream *pStream, VARIANT *pVariant);
static HRESULT ConvertStreamToDOM(IStream *pStream, IXMLDOMElement **pInstanceName);
static void WriteOutputString(FILE *fp, BOOL bIsUTF8, LPCWSTR pszData, DWORD dwDataLen = 0);


// Functions for converting things to VALUE.NAMEDOBJECT
static HRESULT ConvertObjectToNamedObject(FILE *fp, IXMLDOMNode *pTopElement, CXmlCompUI *pUI );
static HRESULT ConvertNamedInstanceToNamedObject(FILE *fp, IXMLDOMNode *pTopElement, CXmlCompUI *pUI);
static HRESULT ConvertObjectWithPathToNamedObject(FILE *fp, IXMLDOMNode *pTopElement, CXmlCompUI *pUI);
static HRESULT ConvertObjectToObjectWithPath(FILE *fp, IXMLDOMNode *pTopElement, CXmlCompUI *pUI );


// Do the specified operation
HRESULT DoGetObject(CXmlCompUI *pUI);
HRESULT DoQuery(CXmlCompUI *pUI);
HRESULT DoEnumInstance(CXmlCompUI *pUI);
HRESULT DoEnumClass(CXmlCompUI *pUI);
HRESULT DoEnumInstNames(CXmlCompUI *pUI);
HRESULT DoEnumClassNames(CXmlCompUI *pUI);
HRESULT DoCompilation(IStream *pInputFile, CXmlCompUI *pUI);


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\xmltransport\compiler\xmlcomp\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by xmltrans.rc
//
#define XML_COMP_ERR_INVALID_CHAR       1
#define XML_COMP_ERR_MISSING_SWITCH_VALUE 2
#define XML_COMP_ERR_UNRECOGNIZED_SWITCH 3
#define XML_COMP_ERR_UNRECOGNIZED_AL    4
#define XML_COMP_ERR_UNRECOGNIZED_IL    5
#define XML_COMP_ERR_UNRECOGNIZED_OP    6
#define XML_COMP_ERR_UNRECOGNIZED_CLASSF 7
#define XML_COMP_ERR_UNRECOGNIZED_INSTANCEF 8
#define XML_COMP_ERR_UNRECOGNIZED_DECLGROUP 9
#define XML_COMP_ERR_NO_OP              10

#define XML_COMP_ERR_INVALID_SWITCH_FOR_OP 11
#define XML_COMP_ERR_NO_INPUT_FILE      12
#define XML_COMP_ERR_MULTIPLE_OP        13
#define XML_COMP_ERR_NO_OBJ             14
#define XML_COMP_ERR_INVALID_SWITCH_FOR_GET 15
#define XML_COMP_ERR_NO_QUERY           16
#define XML_COMP_ERR_INVALID_SWITCH_FOR_QUERY 17
#define XML_COMP_ERR_INVALID_SWITCH_FOR_ENUM 18
#define XML_COMP_ERR_UNRECOGNIZED_ENCODING 19
#define XML_COMP_ERR_INPUT_FILE_NOT_FOUND 20

#define XML_COMP_ERR_SYNTAX_ERRORS      21
#define XML_COMP_ERR_COMPILATION_ERRORS 22
#define XML_COMP_SYNTAX_ERR_SERVER_RESP 23
#define XML_COMP_HEADER                 24
#define XML_COMP_SUCCESSFUL_PROCESSING	25
#define XML_COMP_SUCCESSFUL_OPERATION   26
#define XML_COMP_ERR_PRIVILEGES			27
#define XML_COMP_ERR_UNABLE_TO_OPEN_OUTPUT 28
#define XML_COMP_UNSUCCESSFUL_OPERATION 29
#define XML_COMP_WMI_ERROR				30

#define XML_COMP_UNKNOWN_ERROR			31

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\xmltransport\compiler\xmlcomp\opns.cpp ===
#include <windows.h>
#include <stdio.h>
#include <stdarg.h>
#include <initguid.h>
#include <objbase.h>
#include <objsafe.h>
#include <wbemcli.h>
#include "wmiconv.h"
#include "xmltrnsf.h"
#include "errors.h"
#include "ui.h"
#include "opns.h"
#include "resource.h"

static HRESULT FilterOutputFromSet(ISWbemXMLDocumentSet *pOutput, CXmlCompUI *pUI );
static HRESULT FilterOutputForSingleObject(IXMLDOMDocument *pOutput, CXmlCompUI *pUI );
static HRESULT CreateXMLTranslator(IWbemXMLConvertor **pConvertor);

// Creates the Transformer control
static HRESULT CreateControl(IWmiXMLTransformer **ppControl)
{
	return CoCreateInstance (CLSID_WmiXMLTransformer, NULL, CLSCTX_INPROC_SERVER,
												IID_IWmiXMLTransformer, (LPVOID *)ppControl);
}

// Sets some properties that control the behaviour of the transformer control
HRESULT SetCommonControlProperties(IWmiXMLTransformer *pControl, CXmlCompUI *pUI)
{
	HRESULT hr = S_OK;

	// The type of encoding required
	if(SUCCEEDED(hr) && SUCCEEDED(hr = pControl->put_XMLEncodingType(pUI->m_iEncodingType)))
	{
	}

	// Qualifier Filter
	if(SUCCEEDED(hr) && SUCCEEDED(hr = pControl->put_QualifierFilter((pUI->m_bQualifierLevel)? VARIANT_TRUE : VARIANT_FALSE)))
	{
	}

	// Class Origin Filter
	if(SUCCEEDED(hr) && SUCCEEDED(hr = pControl->put_ClassOriginFilter((pUI->m_bClassOrigin)? VARIANT_TRUE : VARIANT_FALSE)))
	{
	}

	// Local Only
	if(SUCCEEDED(hr) && SUCCEEDED(hr = pControl->put_LocalOnly((pUI->m_bLocalOnly)? VARIANT_TRUE : VARIANT_FALSE)))
	{
	}

	// User name
	if(SUCCEEDED(hr) && pUI->m_pszUser)
	{
		BSTR strUser = NULL;
		if(strUser = SysAllocString(pUI->m_pszUser))
		{
			if(SUCCEEDED(hr = pControl->put_User(strUser)))
			{
			}
			SysFreeString(strUser);
		}
		else
			hr = E_OUTOFMEMORY;
	}

	// Password
	if(SUCCEEDED(hr) && pUI->m_pszPassword)
	{
		BSTR strPasswd = NULL;
		if(strPasswd = SysAllocString(pUI->m_pszPassword))
		{
			if(SUCCEEDED(hr = pControl->put_Password(strPasswd)))
			{
			}
			SysFreeString(strPasswd);
		}
		else
			hr = E_OUTOFMEMORY;
	}

	// Impersonation Level
	if(SUCCEEDED(hr) && SUCCEEDED(hr = pControl->put_ImpersonationLevel(pUI->m_dwImpersonationLevel)))
	{
	}

	// Authentication Level
	if(SUCCEEDED(hr) && SUCCEEDED(hr = pControl->put_AuthenticationLevel(pUI->m_dwAuthenticationLevel)))
	{
	}

	// Locale
	if(SUCCEEDED(hr) && pUI->m_pszLocale)
	{
		BSTR strLocale = NULL;
		if(strLocale = SysAllocString(pUI->m_pszLocale))
		{
			if(SUCCEEDED(hr = pControl->put_Locale(strLocale)))
			{
			}
			SysFreeString(strLocale);
		}
		else
			hr = E_OUTOFMEMORY;
	}

	return hr;
}

HRESULT DoGetObject(CXmlCompUI *pUI)
{
	HRESULT hr = E_FAIL;
	IWmiXMLTransformer *pControl = NULL;

	// Create the Backend Control
	if(SUCCEEDED(hr = CreateControl(&pControl)))
	{
		// Set most of the operation independent flags
		if(SUCCEEDED(hr = SetCommonControlProperties(pControl, pUI)))
		{
			// Set Object Path, Host Name and Namespace Path
			BSTR strObjectPath = NULL;
			if(strObjectPath = SysAllocString(pUI->m_pszObjectPath))
			{
				// Do the operation
				IXMLDOMDocument *pOutput = NULL;
				if(SUCCEEDED(hr = pControl->GetObject(strObjectPath, NULL, &pOutput)))
				{
					hr = FilterOutputForSingleObject(pOutput, pUI);
					pOutput->Release();
				}
			}
			else
				hr = E_OUTOFMEMORY;
			SysFreeString(strObjectPath);
		}
		pControl->Release();
	}
	return hr;
}

HRESULT DoQuery(CXmlCompUI *pUI)
{
	HRESULT hr = E_FAIL;
	IWmiXMLTransformer *pControl = NULL;

	// Create the Backend Control
	if(SUCCEEDED(hr = CreateControl(&pControl)))
	{
		// Set most of the operation independent flags
		if(SUCCEEDED(hr = SetCommonControlProperties(pControl, pUI)))
		{
			// Set Object Path, Host Name and Namespace Path
			BSTR strQuery = NULL;
			if(strQuery = SysAllocString(pUI->m_pszQuery))
			{
				BSTR strNamespacePath = NULL;
				if(strNamespacePath = SysAllocString(pUI->m_pszNamespacePath))
				{
					// Do the operation
					ISWbemXMLDocumentSet *pOutput = NULL;
					BSTR strQueryLanguage = NULL;
					if(strQueryLanguage = SysAllocString(L"WQL"))
					{
						if(SUCCEEDED(hr = pControl->ExecQuery(strNamespacePath, strQuery, strQueryLanguage, NULL, &pOutput)))
						{
							hr = FilterOutputFromSet(pOutput, pUI );
							pOutput->Release();
						}
						SysFreeString(strQueryLanguage);
					}
				}
				else
					hr = E_OUTOFMEMORY;
				SysFreeString(strNamespacePath);
			}
			else
				hr = E_OUTOFMEMORY;
		}
		pControl->Release();
	}
	return hr;
}

HRESULT DoEnumInstance(CXmlCompUI *pUI)
{
	HRESULT hr = E_FAIL;
	IWmiXMLTransformer *pControl = NULL;

	// Create the Backend Control
	if(SUCCEEDED(hr = CreateControl(&pControl)))
	{
		// Set most of the operation independent flags
		if(SUCCEEDED(hr = SetCommonControlProperties(pControl, pUI)))
		{
			// Set Object Path, Host Name and Namespace Path
			BSTR strObjectPath = NULL;
			if(strObjectPath = SysAllocString(pUI->m_pszObjectPath))
			{
				// Do the operation
				ISWbemXMLDocumentSet *pOutput = NULL;
				if(SUCCEEDED(hr = pControl->EnumInstances(strObjectPath, 
					(pUI->m_bDeep)? VARIANT_TRUE : VARIANT_FALSE, NULL, 
					&pOutput)))
				{
					hr = FilterOutputFromSet(pOutput, pUI );
					pOutput->Release();
				}
				SysFreeString(strObjectPath);
			}
			else
				hr = E_OUTOFMEMORY;
		}
		pControl->Release();
	}
	return hr;
}

HRESULT DoEnumClass(CXmlCompUI *pUI)
{
	HRESULT hr = E_FAIL;
	IWmiXMLTransformer *pControl = NULL;

	// Create the Backend Control
	if(SUCCEEDED(hr = CreateControl(&pControl)))
	{
		// Set most of the operation independent flags
		if(SUCCEEDED(hr = SetCommonControlProperties(pControl, pUI)))
		{
			// Set Object Path, Host Name and Namespace Path
			BSTR strObjectPath = NULL;
			if(strObjectPath = SysAllocString(pUI->m_pszObjectPath))
			{
				// Do the operation
				ISWbemXMLDocumentSet *pOutput = NULL;
				if(SUCCEEDED(hr = pControl->EnumClasses(strObjectPath,
					(pUI->m_bDeep)? VARIANT_TRUE : VARIANT_FALSE,
					NULL,
					&pOutput)))
				{
					hr = FilterOutputFromSet(pOutput, pUI );
					pOutput->Release();
				}
			}
			else
				hr = E_OUTOFMEMORY;
			SysFreeString(strObjectPath);
		}
		pControl->Release();
	}
	return hr;
}

HRESULT DoEnumInstNames(CXmlCompUI *pUI)
{
	HRESULT hr = E_FAIL;
	IWmiXMLTransformer *pControl = NULL;

	// Create the Backend Control
	if(SUCCEEDED(hr = CreateControl(&pControl)))
	{
		// Set most of the operation independent flags
		if(SUCCEEDED(hr = SetCommonControlProperties(pControl, pUI)))
		{
			// Set Object Path, Host Name and Namespace Path
			BSTR strObjectPath = NULL;
			if(strObjectPath = SysAllocString(pUI->m_pszObjectPath))
			{
				// Do the operation
				ISWbemXMLDocumentSet *pOutput = NULL;
				if(SUCCEEDED(hr = pControl->EnumInstanceNames(strObjectPath, NULL, &pOutput)))
				{
					hr = FilterOutputFromSet(pOutput, pUI );
					pOutput->Release();
				}
				SysFreeString(strObjectPath);
			}
			else
				hr = E_OUTOFMEMORY;
		}
		pControl->Release();
	}
	return hr;
}

HRESULT DoEnumClassNames(CXmlCompUI *pUI)
{
	HRESULT hr = E_FAIL;
	IWmiXMLTransformer *pControl = NULL;

	// Create the Backend Control
	if(SUCCEEDED(hr = CreateControl(&pControl)))
	{
		// Set most of the operation independent flags
		if(SUCCEEDED(hr = SetCommonControlProperties(pControl, pUI)))
		{
			// Set Object Path, Host Name and Namespace Path
			BSTR strObjectPath = NULL;
			if(strObjectPath = SysAllocString(pUI->m_pszObjectPath))
			{
				// Do the operation
				ISWbemXMLDocumentSet *pOutput = NULL;
				if(SUCCEEDED(hr = pControl->EnumClassNames(strObjectPath,
					(pUI->m_bDeep)? VARIANT_TRUE : VARIANT_FALSE, NULL, 
					&pOutput)))
				{
					hr = FilterOutputFromSet(pOutput, pUI );
					pOutput->Release();
				}
				SysFreeString(strObjectPath);
			}
			else
				hr = E_OUTOFMEMORY;
		}
		pControl->Release();
	}
	return hr;
}

STDMETHODIMP MapCommonHeaders (FILE *fp, CXmlCompUI *pUI)
{
	// WRITESIG
	WriteOutputString(fp, pUI->m_bIsUTF8, L"<?xml version=\"1.0\" ?>");
	if (pUI->m_pszDTDURL)
	{
		WriteOutputString(fp, pUI->m_bIsUTF8, L"<!DOCTYPE CIM SYSTEM \"");
		WriteOutputString(fp, pUI->m_bIsUTF8, pUI->m_pszDTDURL);
		WriteOutputString(fp, pUI->m_bIsUTF8, L"\">");
		
	}

	WriteOutputString(fp, pUI->m_bIsUTF8, L"<CIM CIMVERSION=\"2.0\" DTDVERSION=\"2.0\" >");
	WriteOutputString(fp, pUI->m_bIsUTF8, L"<DECLARATION>");
	return S_OK;
}

STDMETHODIMP MapCommonTrailers (FILE *fp, CXmlCompUI *pUI)
{
	WriteOutputString(fp, pUI->m_bIsUTF8, L"</DECLARATION>");
	WriteOutputString(fp, pUI->m_bIsUTF8, L"</CIM>");
	return S_OK;
}

STDMETHODIMP MapDeclGroupHeaders (FILE *fp, CXmlCompUI *pUI )
{
	switch(pUI->m_iDeclGroupType)
	{
		case wmiXMLDeclGroup:
			WriteOutputString(fp, pUI->m_bIsUTF8, L"<DECLGROUP>");
			break;
		case wmiXMLDeclGroupWithName:
			WriteOutputString(fp, pUI->m_bIsUTF8, L"<DECLGROUP.WITHNAME>");
			break;
		case wmiXMLDeclGroupWithPath:
			WriteOutputString(fp, pUI->m_bIsUTF8, L"<DECLGROUP.WITHPATH>");
			break;
	}
	return S_OK;
}

STDMETHODIMP MapDeclGroupTrailers (FILE *fp, CXmlCompUI *pUI)
{
	switch(pUI->m_iDeclGroupType)
	{
		case wmiXMLDeclGroup:
			WriteOutputString(fp, pUI->m_bIsUTF8, L"</DECLGROUP>");
			break;
		case wmiXMLDeclGroupWithName:
			WriteOutputString(fp, pUI->m_bIsUTF8, L"</DECLGROUP.WITHNAME>");
			break;
		case wmiXMLDeclGroupWithPath:
			WriteOutputString(fp, pUI->m_bIsUTF8, L"</DECLGROUP.WITHNAME>");
			break;
	}
	return S_OK;
}

HRESULT FilterOutputFromSet(ISWbemXMLDocumentSet *pOutput, CXmlCompUI *pUI )
{
	// Get the output file handle
	FILE *fp = NULL;
	if(pUI->m_pszOutputFileName)
		fp = _wfopen(pUI->m_pszOutputFileName, L"w");
	else
		fp = stdout;

	if(!fp)
	{
		CreateMessage(XML_COMP_ERR_UNABLE_TO_OPEN_OUTPUT);
		return E_FAIL;
	}

	// Go thru each element in the set
	HRESULT hr = S_OK;

	if(SUCCEEDED(hr = MapCommonHeaders(fp, pUI)))
	{
		if(SUCCEEDED(hr = MapDeclGroupHeaders(fp, pUI)))
		{
			IXMLDOMDocument *pDoc = NULL;
			bool bError = false;
			while(!bError && SUCCEEDED(hr = pOutput->NextDocument(&pDoc)) && hr != S_FALSE)
			{
				if(SUCCEEDED(hr = WriteOneDeclGroupDocument(fp, pDoc, pUI)))
				{
				}
				else
					bError = true;
				pDoc->Release();
				pDoc  = NULL;
			}
			if(!bError && SUCCEEDED(hr = MapDeclGroupTrailers(fp, pUI)))
			{
				hr = MapCommonTrailers(fp, pUI);
			}
		}
	}

	// Close any file that we opened
	if(fp != stdout)
		fclose(fp);

	return hr;
}

HRESULT FilterOutputForSingleObject(IXMLDOMDocument *pOutput, CXmlCompUI *pUI )
{
	// Get the output file handle
	FILE *fp = NULL;
	if(pUI->m_pszOutputFileName)
		fp = _wfopen(pUI->m_pszOutputFileName, L"w");
	else
		fp = stdout;

	if(!fp)
	{
		CreateMessage(XML_COMP_ERR_UNABLE_TO_OPEN_OUTPUT);
		return E_FAIL;
	}

	// Map the object to XML
	HRESULT hr = S_OK;

	if(SUCCEEDED(hr = MapCommonHeaders(fp, pUI)))
	{
		if(SUCCEEDED(hr = MapDeclGroupHeaders(fp, pUI)))
		{
			// We get a document with a CLASS or INSTANCE at the top level
			IXMLDOMElement *pTopElement = NULL;
			if(SUCCEEDED(hr = pOutput->get_documentElement(&pTopElement)))
			{
				if(SUCCEEDED(hr = WriteOneDeclGroupNode(fp, pTopElement, pUI)))
				{
					if(SUCCEEDED(hr = MapDeclGroupTrailers(fp, pUI)))
					{
						hr = MapCommonTrailers(fp, pUI);
					}
				}
				pTopElement->Release();
			}
		}
	}

	// Close any file that we opened
	if(fp != stdout)
		fclose(fp);

	return hr;
}

HRESULT WriteOneDeclGroupNode(FILE *fp, IXMLDOMNode *pTopElement, CXmlCompUI *pUI )
{
	HRESULT hr = E_FAIL;
	BSTR strTopName = NULL;
	if(SUCCEEDED(hr = pTopElement->get_nodeName(&strTopName)))
	{
		switch(pUI->m_iDeclGroupType)
		{
			// In this case you have to extract a CLASS or an INSTANCE from
			// 1. CLASS or INSTANCE for GetObject and ENumClass
			// 2. VALUE.NAMEDINSTANCE for EnumInstance
			// 3. VALUE.OBJECTWITHPATH for ExecQuery
			case wmiXMLDeclGroup:
				if(_wcsicmp(strTopName, L"CLASS") == 0 ||
					_wcsicmp(strTopName, L"INSTANCE") == 0 )
				{
					WriteOutputString(fp, pUI->m_bIsUTF8, L"<VALUE.OBJECT>");
					hr = WriteNode(fp, pTopElement, pUI);
					WriteOutputString(fp, pUI->m_bIsUTF8, L"</VALUE.OBJECT>");
				}
				else if(_wcsicmp(strTopName, L"VALUE.NAMEDINSTANCE") == 0 )
				{
					IXMLDOMElement *pInstance = NULL;
					if(SUCCEEDED(hr = GetFirstImmediateElement(pTopElement, &pInstance, L"INSTANCE")))
					{
						WriteOutputString(fp, pUI->m_bIsUTF8, L"<VALUE.OBJECT>");
						hr = WriteNode(fp, pInstance, pUI);
						WriteOutputString(fp, pUI->m_bIsUTF8, L"</VALUE.OBJECT>");
						pInstance->Release();
					}
				}
				else if(_wcsicmp(strTopName, L"VALUE.OBJECTWITHPATH") == 0 )
				{
					IXMLDOMElement *pObject = NULL;
					if(SUCCEEDED(hr = GetFirstImmediateElement(pTopElement, &pObject, L"INSTANCE")))
					{
						WriteOutputString(fp, pUI->m_bIsUTF8, L"<VALUE.OBJECT>");
						hr = WriteNode(fp, pObject, pUI);
						WriteOutputString(fp, pUI->m_bIsUTF8, L"</VALUE.OBJECT>");
						pObject->Release();
					}
					else if(SUCCEEDED(hr = GetFirstImmediateElement(pTopElement, &pObject, L"CLASS")))
					{
						WriteOutputString(fp, pUI->m_bIsUTF8, L"<VALUE.OBJECT>");
						hr = WriteNode(fp, pObject, pUI);
						WriteOutputString(fp, pUI->m_bIsUTF8, L"</VALUE.OBJECT>");
						pObject->Release();
					}
				}
				else
					hr = E_FAIL;
				break;
			// In this case you have to create a VALUE.NAMEDOBJECT from
			// 1. CLASS or INSTANCE for GetObject and ENumClass - For this we need the name of the class/instance
			// 2. VALUE.NAMEDINSTANCE for EnumInstance - Pretty Straightforward
			// 3. VALUE.OBJECTWITHPATH for ExecQuery - Pretty Straightforward
			case wmiXMLDeclGroupWithName:
				if(_wcsicmp(strTopName, L"CLASS") == 0 ||
					_wcsicmp(strTopName, L"INSTANCE") == 0 )
				{
					hr = ConvertObjectToNamedObject(fp, pTopElement, pUI);
				}
				else if(_wcsicmp(strTopName, L"VALUE.NAMEDINSTANCE") == 0 )
				{
					hr = ConvertNamedInstanceToNamedObject(fp, pTopElement, pUI);
				}
				else if(_wcsicmp(strTopName, L"VALUE.OBJECTWITHPATH") == 0 )
				{
					hr = ConvertObjectWithPathToNamedObject(fp, pTopElement, pUI);
				}
				else
					hr = E_FAIL;
				break;
			// In this case you have to create a VALUE.OBJECTWITHPATH from
			// 1. CLASS or INSTANCE for GetObject and ENumClass - For this we need the full path of the class/instance 
			// 2. VALUE.NAMEDINSTANCE for EnumInstance - For this we need the host and namespace of the class/instance
			// 3. VALUE.OBJECTWITHPATH for ExecQuery - Pretty Straightforward
			case wmiXMLDeclGroupWithPath:
				if(_wcsicmp(strTopName, L"CLASS") == 0 ||
					_wcsicmp(strTopName, L"INSTANCE") == 0 )
				{
					hr = ConvertObjectToObjectWithPath(fp, pTopElement, pUI);
				}
				else if(_wcsicmp(strTopName, L"VALUE.NAMEDINSTANCE") == 0 )
				{
					// Get the CLASS or INSTANCE in it
					IXMLDOMElement *pObject = NULL;
					if(FAILED(hr = GetFirstImmediateElement(pTopElement, &pObject, L"INSTANCE")))
						hr = GetFirstImmediateElement(pTopElement, &pObject, L"CLASS");
					// Convert the CLASS or INSTANCE to VALUE.OBJECTWITHPATH
					if(SUCCEEDED(hr))
						hr = ConvertObjectToObjectWithPath(fp, pTopElement, pUI);
				}
				else if(_wcsicmp(strTopName, L"VALUE.OBJECTWITHPATH") == 0 )
				{
					hr = WriteNode(fp, pTopElement, pUI);
				}
				else
					hr = E_FAIL;
				break;
		}

		SysFreeString(strTopName);
	}
	return hr;
}

HRESULT WriteOneDeclGroupDocument(FILE *fp, IXMLDOMDocument *pDocument, CXmlCompUI *pUI )
{
	// Check the top level document - it can be CLASS, INSTANCE, VALUE.NAMEDINSTANCE or VALUE.OBJECTWITHPATH
	// Or it can be CLASSNAME or INSTANCENAME for an EnumClassName or EnumInstanceName operation
	IXMLDOMElement *pTopElement = NULL;
	HRESULT hr = E_FAIL;
	if(SUCCEEDED(hr = pDocument->get_documentElement(&pTopElement)))
	{
		hr = WriteOneDeclGroupNode(fp, pTopElement, pUI);
		pTopElement->Release();
	}

	return hr;
}


HRESULT DoCompilation(IStream *pInputFile, CXmlCompUI *pUI)
{
	HRESULT hr = E_FAIL;
	IWmiXMLTransformer *pControl = NULL;

	// Create the Backend Control
	if(SUCCEEDED(hr = CreateControl(&pControl)))
	{
		// Set most of the operation independent flags
		if(SUCCEEDED(hr = SetCommonControlProperties(pControl, pUI)))
		{
			// Wrap the inptu stream in a variant
			VARIANT vInput;
			if(SUCCEEDED(hr = SaveStreamToUnkVariant(pInputFile, &vInput)))
			{
				// Set Host Name and Namespace Path
				BSTR strNamespacePath = NULL;
				if(strNamespacePath = SysAllocString(pUI->m_pszNamespacePath))
				{
					VARIANT_BOOL bStatus = VARIANT_FALSE;
					BSTR strErrors = NULL;
					// Do the operation
					if(SUCCEEDED(hr = pControl->Compile(&vInput, strNamespacePath,
						pUI->m_dwClassFlags,
						pUI->m_dwInstanceFlags,
						(pUI->m_iCommand == XML_COMP_WELL_FORM_CHECK)? WmiXMLCompilationWellFormCheck : ((pUI->m_iCommand == XML_COMP_VALIDITY_CHECK)? WmiXMLCompilationValidityCheck : WmiXMLCompilationFullCompileAndLoad),
						NULL,
						&bStatus)))
					{
						if(bStatus == VARIANT_FALSE)
						{
							hr = E_FAIL;
							if(SUCCEEDED(pControl->get_CompilationErrors(&strErrors)))
							{
								if(strErrors)
									fwprintf(stderr, strErrors);
								SysFreeString(strErrors);
							}
						}
					}
				}
				else
					hr = E_OUTOFMEMORY;
				SysFreeString(strNamespacePath);
				VariantClear(&vInput);
			}
		}
		pControl->Release();
	}
	return hr;
}

HRESULT SaveStreamToBstrVariant (IStream *pStream, VARIANT *pVariant)
{
	HRESULT result = E_FAIL;

	LARGE_INTEGER	offset;
	offset.LowPart = offset.HighPart = 0;
	// Seek to the beginning of the stream
	if(SUCCEEDED(result = pStream->Seek (offset, STREAM_SEEK_SET, NULL)))
	{
		// Get the size of the stream
		STATSTG statstg;
		if (SUCCEEDED(result = pStream->Stat(&statstg, STATFLAG_NONAME)))
		{
			ULONG cbSize = (statstg.cbSize).LowPart;
			CHAR *pText = NULL;

			if(cbSize && (pText = new CHAR [cbSize]))
			{
				// Read the Ascii data
				ULONG cbActualRead = 0;
				if (SUCCEEDED(result = pStream->Read(pText, cbSize, &cbActualRead)))
				{
					// Convert to Unicode
					//=======================

					// Calculate size of the resulting Wide char string
					DWORD dwSizeOfBstr = MultiByteToWideChar(
					   CP_ACP,					/* codepage                        */
					   0,				        /* character-type options          */
					   pText,					/* address of string to map        */
					   cbActualRead,			/* number of characters in string   */
					   NULL,					/* address of wide-character buffer */
					   0);						/* size of wide-character buffer    */


					if(dwSizeOfBstr > 0 )
					{
						// ALllocate the wide char string
						LPWSTR theWcharString = NULL;
						if(theWcharString = new WCHAR [dwSizeOfBstr])
						{
							//Convert the Ansi string to Bstr
							dwSizeOfBstr = MultiByteToWideChar(
							   CP_ACP,					/* codepage                        */
							   0,				        /* character-type options          */
							   pText,			/* address of string to map        */
							   cbActualRead,					/* number of characters in string   */
							   theWcharString,			/* address of wide-character buffer */
							   dwSizeOfBstr);			/* size of wide-character buffer    */

							BSTR strVal = NULL;
							if(strVal = SysAllocStringLen(theWcharString, dwSizeOfBstr))
							{
								VariantInit(pVariant);
								pVariant->vt = VT_BSTR;
								pVariant->bstrVal = strVal;
								result = S_OK;
							}
							else
								result = E_OUTOFMEMORY;
							delete [] theWcharString;
						}
						else
							result = E_OUTOFMEMORY;
					}
				}
				delete [] pText;
			}
			else
				result = E_OUTOFMEMORY;
		}
	}

	return result;
}

HRESULT GetFirstImmediateElement(IXMLDOMNode *pParent, IXMLDOMElement **ppChildElement, LPCWSTR pszName)
{
	HRESULT hr = E_FAIL;

	// Now cycle thru the children
	IXMLDOMNodeList *pNodeList = NULL;
	BOOL bFound = FALSE;
	if (SUCCEEDED(hr = pParent->get_childNodes (&pNodeList)))
	{
		IXMLDOMNode *pNode = NULL;
		while (!bFound && SUCCEEDED(pNodeList->nextNode (&pNode)) && pNode)
		{
			// Get the name of the child
			BSTR strNodeName = NULL;
			if (SUCCEEDED(hr = pNode->get_nodeName (&strNodeName)))
			{
				// We're interested only in PROPERTIES at this point
				if(_wcsicmp(strNodeName, pszName) == 0)
				{
					*ppChildElement = NULL;
					hr = pNode->QueryInterface(IID_IXMLDOMElement, (LPVOID *)ppChildElement);
					bFound = TRUE;
				}
				SysFreeString(strNodeName);
			}
			pNode->Release();
			pNode = NULL;
		}
		pNodeList->Release();
	}
	if(bFound)
		return hr;
	return E_FAIL;
}

HRESULT WriteNode(FILE *fp, IXMLDOMNode *pOutputNode, CXmlCompUI *pUI)
{
	HRESULT hr = S_OK;
	if(pOutputNode)
	{
		BSTR strXML = NULL;
		if(SUCCEEDED(hr = pOutputNode->get_xml(&strXML)))
		{
			WriteOutputString(fp, pUI->m_bIsUTF8, strXML, SysStringLen(strXML));
			SysFreeString(strXML);
		}
	}
	return hr;
}

HRESULT ConvertNamedInstanceToNamedObject(FILE *fp, IXMLDOMNode *pTopElement, CXmlCompUI *pUI)
{
	// Write the beginning tag
	WriteOutputString(fp, pUI->m_bIsUTF8, L"<VALUE.NAMEDOBJECT>");

	// Write the INSTANCENAME tag and its contents
	IXMLDOMElement *pInstanceName = NULL;
	if(SUCCEEDED(GetFirstImmediateElement(pTopElement, &pInstanceName, L"INSTANCENAME")))
	{
		WriteNode(fp, pInstanceName, pUI);
		pInstanceName->Release();
	}
	// Write the INSTANCE tag and its contents
	IXMLDOMElement *pInstance = NULL;
	if(SUCCEEDED(GetFirstImmediateElement(pTopElement, &pInstance, L"INSTANCE")))
	{
		WriteNode(fp, pInstance, pUI);
		pInstance->Release();
	}

	// Write the terminating tag
	WriteOutputString(fp, pUI->m_bIsUTF8, L"</VALUE.NAMEDOBJECT>");
	return S_OK;
}

HRESULT ConvertObjectWithPathToNamedObject(FILE *fp, IXMLDOMNode *pTopElement, CXmlCompUI *pUI)
{
	// Write the beginning tag
	WriteOutputString(fp, pUI->m_bIsUTF8, L"<VALUE.NAMEDOBJECT>");

	// This could be a class or an instance
	IXMLDOMElement *pClass = NULL;
	IXMLDOMElement *pInstancePath = NULL;

	// Get the INSTANCEPATH tag 
	if(SUCCEEDED(GetFirstImmediateElement(pTopElement, &pInstancePath, L"INSTANCEPATH")))
	{
		// Get the INSTANCENAME below the INSTANCEPATH
		IXMLDOMElement *pInstanceName = NULL;
		if(SUCCEEDED(GetFirstImmediateElement(pInstancePath, &pInstanceName, L"INSTANCENAME")))
		{
			WriteNode(fp, pInstanceName, pUI);
			pInstanceName->Release();
		}

		// Write the INSTANCE tag and its contents
		IXMLDOMElement *pInstance = NULL;
		if(SUCCEEDED(GetFirstImmediateElement(pTopElement, &pInstance, L"INSTANCE")))
		{
			WriteNode(fp, pInstance, pUI);
			pInstanceName->Release();
		}
		pInstancePath->Release();
	}
	// Get the CLASS tag 
	else if(SUCCEEDED(GetFirstImmediateElement(pTopElement, &pClass, L"CLASS")))
	{
		WriteNode(fp, pClass, pUI);
		pClass->Release();
	}

	// Write the terminating tag
	WriteOutputString(fp, pUI->m_bIsUTF8, L"</VALUE.NAMEDOBJECT>");
	return S_OK;
}

HRESULT ConvertObjectToNamedObject(FILE *fp, IXMLDOMNode *pTopElement, CXmlCompUI *pUI )
{
	// From the UI, we get the path to the object
	// From the path, we get the name of the object (INSTANCENAME for instance, nothing for a CLASS)
	// From that and the CLASS or INSTANCE, we get a VALUE.NAMEDOBJECT
	BSTR strName = NULL;
	HRESULT hr = E_FAIL;
	if(SUCCEEDED(hr = pTopElement->get_nodeName(&strName)))
	{
		// Nothing much to be done for a class
		if(_wcsicmp(strName, L"CLASS") == 0)
		{
			// Write the beginning tag
			WriteOutputString(fp, pUI->m_bIsUTF8, L"<VALUE.NAMEDOBJECT>");
			// Write the Class
			hr = WriteNode(fp, pTopElement, pUI);
			// Write the terminating tag
			WriteOutputString(fp, pUI->m_bIsUTF8, L"</VALUE.NAMEDOBJECT>");
		}
		// For the instance, we need to use the UI to get the instance name
		else if(_wcsicmp(strName, L"INSTANCE") == 0)
		{
			// Create a stream
			IStream *pStream = NULL;
			if (SUCCEEDED(hr = CreateStreamOnHGlobal(NULL, TRUE, &pStream)))
			{
				// Create the convertor
				IWbemXMLConvertor *pConvertor = NULL;
				if(SUCCEEDED(hr = CreateXMLTranslator(&pConvertor)))
				{
					// Get the XML representation in a Stream
					BSTR strInstanceName = NULL;
					if(strInstanceName = SysAllocString(pUI->m_pszObjectPath))
					{
						if(SUCCEEDED(hr = pConvertor->MapInstanceNameToXML(strInstanceName, NULL, pStream)))
						{
							// Convert the stream to a DOM Element
							IXMLDOMElement *pInstanceName = NULL;
							if(SUCCEEDED(hr = ConvertStreamToDOM(pStream, &pInstanceName)))
							{
								// Write the beginning tag
								WriteOutputString(fp, pUI->m_bIsUTF8, L"<VALUE.NAMEDOBJECT>");
								// Write the InstanceName
								WriteNode(fp, pInstanceName, pUI);
								// Write the Instance
								WriteNode(fp, pTopElement, pUI);
								// Write the terminating tag
								WriteOutputString(fp, pUI->m_bIsUTF8, L"</VALUE.NAMEDOBJECT>");
								pInstanceName->Release();
							}

						}
						SysFreeString(strInstanceName);
					}
					pConvertor->Release();
				}
				pStream->Release();
			}
		}
		SysFreeString(strName);
	}
	return hr;
}

HRESULT ConvertObjectToObjectWithPath(FILE *fp, IXMLDOMNode *pTopElement, CXmlCompUI *pUI )
{
	// From the UI, we get the path to the object
	// From the path, we get an INSTANCEPATH or CLASSPATH
	// From that and the CLASS or INSTANCE, we get a VALUE.OBJECTWITHPATH
	BSTR strName = NULL;
	HRESULT hr = E_FAIL;
	if(SUCCEEDED(hr = pTopElement->get_nodeName(&strName)))
	{
		// Create a stream
		IStream *pStream = NULL;
		if (SUCCEEDED(hr = CreateStreamOnHGlobal(NULL, TRUE, &pStream)))
		{
			// Create the convertor
			IWbemXMLConvertor *pConvertor = NULL;
			if(SUCCEEDED(hr = CreateXMLTranslator(&pConvertor)))
			{
				// Get the XML representation in a Stream
				BSTR strObjectPath = NULL;
				if(strObjectPath = SysAllocString(pUI->m_pszObjectPath))
				{
					// Get the Object Path
					if(_wcsicmp(strName, L"INSTANCE") == 0)
						hr = pConvertor->MapInstancePathToXML(strObjectPath, NULL, pStream);
					else if(_wcsicmp(strName, L"CLASS") == 0)
						hr = pConvertor->MapClassPathToXML(strObjectPath, NULL, pStream); 
					else
						hr = E_FAIL;

					if(SUCCEEDED(hr))
					{
						// Convert the stream to a DOM Element
						IXMLDOMElement *pObjectPath = NULL;
						if(SUCCEEDED(hr = ConvertStreamToDOM(pStream, &pObjectPath)))
						{
							// Write the beginning tag
							WriteOutputString(fp, pUI->m_bIsUTF8, L"<VALUE.OBJECTWITHPATH>");
							// Write the INSTANCEPATH/CLASSPATH
							WriteNode(fp, pObjectPath, pUI);
							// Write the INSTANCE/CLASS
							WriteNode(fp, pTopElement, pUI);
							// Write the terminating tag
							WriteOutputString(fp, pUI->m_bIsUTF8, L"</VALUE.OBJECTWITHPATH>");
							pObjectPath->Release();
						}
					}
					SysFreeString(strObjectPath);
				}
				pConvertor->Release();
			}
			pStream->Release();
		}
		SysFreeString(strName);
	}
	return hr;
}

// RAJESHR - Remove this to read the GUID frm the registry on startup
DEFINE_GUID(CLSID_WbemXMLConvertor,
	0x610037ec, 0xce06, 0x11d3, 0x93, 0xfc, 0x0, 0x80, 0x5f, 0x85, 0x37, 0x71);
HRESULT CreateXMLTranslator(IWbemXMLConvertor **pConvertor)
{

	HRESULT result = E_FAIL;

	// Create the XMLAdaptor object
	//******************************************************
	*pConvertor = NULL;
	if(SUCCEEDED(result = CoCreateInstance(CLSID_WbemXMLConvertor,
		0,
		CLSCTX_INPROC_SERVER,
        IID_IWbemXMLConvertor, (LPVOID *) pConvertor)))
	{
	}
	return result;
}

HRESULT ConvertStreamToDOM(IStream *pStream, IXMLDOMElement **pInstanceName)
{
	HRESULT hr = E_FAIL;
	VARIANT vInput;
	VariantInit(&vInput);
	vInput.vt = VT_UNKNOWN;
	vInput.punkVal = pStream;

	// Seek to the beginning of the stream
	//========================================
	LARGE_INTEGER	offset;
	offset.LowPart = offset.HighPart = 0;
	if(SUCCEEDED(hr = pStream->Seek (offset, STREAM_SEEK_SET, NULL)))
	{
		// Create an XML document for the stream
		//==============================
		IXMLDOMDocument *pDocument = NULL;
		if(SUCCEEDED(hr = CoCreateInstance(CLSID_DOMDocument, NULL, CLSCTX_INPROC_SERVER,
									IID_IXMLDOMDocument, (LPVOID *)&pDocument)))
		{
			// Load the Variant into the DOC
			VARIANT_BOOL bResult = VARIANT_TRUE;
			if(SUCCEEDED(hr = pDocument->put_async(VARIANT_FALSE)) && 
				SUCCEEDED(hr = pDocument->put_validateOnParse(VARIANT_FALSE)) && 
				SUCCEEDED(hr = pDocument->put_resolveExternals(VARIANT_FALSE)) )
			{
				if(SUCCEEDED(hr = pDocument->load(vInput, &bResult)))
				{
					if(bResult == VARIANT_TRUE)
					{
						hr = pDocument->get_documentElement(pInstanceName);
					}
					else
					{
						hr = E_FAIL;

						// This code is for debugging only
						IXMLDOMParseError *pError = NULL;
						if(SUCCEEDED(pDocument->get_parseError(&pError)))
						{
							LONG errorCode = 0;
							pError->get_errorCode(&errorCode);
							LONG line=0, linepos=0;
							BSTR reason=NULL, srcText = NULL;
							if(SUCCEEDED(pError->get_line(&line)) &&
								SUCCEEDED(pError->get_linepos(&linepos)) &&
								SUCCEEDED(pError->get_reason(&reason)) &&
								SUCCEEDED(pError->get_srcText(&srcText)))
							{
							}
							pError->Release();
							if(reason)
								SysFreeString(reason);
							if(srcText)
								SysFreeString(srcText);

							pError->Release();
						}
					}
				}
			}
			pDocument->Release();
		}
		// No need to clear the variant since we didnt AddRef() the pStream
	}
	return hr;
}

HRESULT SaveStreamToUnkVariant (IStream *pStream, VARIANT *pVariant)
{
	VariantInit(pVariant);
	pVariant->vt = VT_UNKNOWN;
	pVariant->punkVal = pStream;
	pStream->AddRef();
	return S_OK;
}

// Converts LPWSTR to its UTF-8 encoding
// Returns 0 if it fails
//
static DWORD ConvertWideStringToUTF8(LPCWSTR theWcharString, 
						  ULONG lNumberOfWideChars, 
						  LPSTR * lppszRetValue)
{
	// Find the length of the Ansi string required
	DWORD dwBytesToWrite = WideCharToMultiByte(  CP_UTF8,    // UTF-8 code page
		0,				// performance and mapping flags
		theWcharString,	// address of wide-character string
		lNumberOfWideChars,				// number of characters in string
		NULL,			// address of buffer for new string
		0,				// size of buffer
		NULL,			// address of default for unmappable
                        // characters
		NULL);			// address of flag set when default char. used

	if(dwBytesToWrite == 0 )
		return dwBytesToWrite;

	// Allocate the required length for the Ansi string
	*lppszRetValue = NULL;
	if(!(*lppszRetValue = new char[dwBytesToWrite]))
		return 0;

	// Convert BSTR to ANSI
	dwBytesToWrite = WideCharToMultiByte(  CP_UTF8,         // code page
		0,         // performance and mapping flags
		theWcharString, // address of wide-character string
		lNumberOfWideChars,       // number of characters in string
		*lppszRetValue,  // address of buffer for new string
		dwBytesToWrite,      // size of buffer
		NULL,  // address of default for unmappable
                         // characters
		NULL   // address of flag set when default
                             // char. used
		);

	return dwBytesToWrite;
}

void WriteOutputString(FILE *fp, BOOL bIsUTF8, LPCWSTR pszData, DWORD dwLen)
{
	// If we're not being asked to write UTF-8, then no conversion needs to be done
	// Otherwise, we first need to convert the string to UTF8 and then write it

	if(bIsUTF8)
	{
		// Convert the unicode string to UTF8
		DWORD dwBytesToWrite = 0;
		LPSTR pszUTF8 = NULL;
		if(dwBytesToWrite = ConvertWideStringToUTF8(pszData, (dwLen)? dwLen : wcslen(pszData), &pszUTF8))
		{
			// Write the binary UTF8 bytes
			fwrite((LPVOID)pszUTF8, sizeof(char), dwBytesToWrite, fp);
			delete [] pszUTF8;
		}
	}
	else
		// Directly write a Unicode string
		fwrite((LPVOID)pszData, sizeof(WCHAR), (dwLen)? dwLen : wcslen(pszData), fp);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\xmltransport\compiler\xmlcomp\ui.h ===
#ifndef XML_COM_UI_H
#define XML_COM_UI_H

// Various commands possible with the compiler
typedef enum
{
	XML_COMP_INVALID = 0,
	XML_COMP_WELL_FORM_CHECK,
	XML_COMP_VALIDITY_CHECK,
	XML_COMP_COMPILE,
	XML_COMP_GET,
	XML_COMP_QUERY,
	XML_COMP_ENUM_INST,
	XML_COMP_ENUM_CLASS,
	XML_COMP_ENUM_INST_NAMES,
	XML_COMP_ENUM_CLASS_NAMES
} XML_COMP_COMMAND;

typedef enum WmiXMLDeclGroupTypeEnum
{
	wmiXMLDeclGroup = 0x0,
	wmiXMLDeclGroupWithName = 0x1,
	wmiXMLDeclGroupWithPath = 0x2
} WmiXMLDeclGroupTypeEnum;

// A class to parse the Command-Line
class CXmlCompUI
{
public:

	// values for the various switches on teh command-line
	//*****************************************************
	XML_COMP_COMMAND m_iCommand;		// The command invoked 
	// Common Switches
	LPWSTR m_pszUser;					// Value of /user switch
	LPWSTR m_pszPassword;				// Value of /password switch
	DWORD m_dwAuthenticationLevel;		// Value of /al switch
	DWORD m_dwImpersonationLevel;		// Value of /il switch
	BOOL m_bEnableAllPrivileges;		// Value of /ep switch
	LPWSTR m_pszLocale;					// Value of the /locale switch
	LPWSTR m_pszNamespacePath;			// Value of the /namespace switch
	// Write-Mode switches
	LPWSTR m_pszDTDURL;					// Value of the /dtd switch
	DWORD m_dwClassFlags;				// Value of the /class switch
	DWORD m_dwInstanceFlags;			// Value of the /instance switch
	LPWSTR m_pszInputFileName;			// Value of the /i switch
	// Read-Mode switches
	LPWSTR m_pszOutputFileName;			// Value of the /o switch
	LPWSTR m_pszObjectPath;				// Value of the /obj switch
	LPWSTR m_pszQuery;					// Value of the /query switch
	BOOL m_bDeep;						// Value of the /deep switch
	WmiXMLDeclGroupTypeEnum m_iDeclGroupType; // Value of the /decl switch
	BOOL m_bQualifierLevel;				// Value of the /qualifiers switch
	BOOL m_bClassOrigin;				// Value of the /classorigin switch
	BOOL m_bLocalOnly;					// Value of the /local switch
	WmiXMLEncoding m_iEncodingType;		// Value of the /encoding switch
	BOOL m_bIsUTF8;						// Value of the /utf8 switch

	// A boolean each for whether the switches were specified on command-line
	// These are used for checkin validity of switches
	BOOL m_bUserSpecify;
	BOOL m_bPasswordSpecify;
	BOOL m_bAuthenticationLevelSpecify;
	BOOL m_bImpersonationLevelSpecify;
	BOOL m_bEnableAllPrivilegesSpecify;
	BOOL m_bLocaleSpecify;
	BOOL m_bNamespacePathSpecify;
	BOOL m_bDtdUrlSpecify;
	BOOL m_bClassSpecify;
	BOOL m_bInstanceSpecify;
	BOOL m_bInputFileSpecify;
	BOOL m_bOutputFileSpecify;
	BOOL m_bObjectPathSpecify;
	BOOL m_bQuerySpecify;
	BOOL m_bDeepSpecify;
	BOOL m_bDeclGroupTypeSpecify;
	BOOL m_bQualifierLevelSpecify;
	BOOL m_bClassOriginSpecify;
	BOOL m_bLocalOnlySpecify;
	BOOL m_bEncodingTypeSpecify;
	BOOL m_bIsUTF8Specify;

	// This function parses the command-line 
	HRESULT ParseCommandLine(LPCWSTR pszCommandLine);
	// This function validates the switches on the command-line
	HRESULT ValidateSwitches();
	// Prints the Help text (usage)
	void CXmlCompUI::PrintUsage();
	// Processes a switch that has a value
	HRESULT ProcessSingleValueSwitch(LPCWSTR pszCommandLine, LPCWSTR pszSwitchName, LPCWSTR &pszNextChar, LPWSTR &pszSwitchValue);
	// Processes a switch that has no value - a boolean switch
	HRESULT ProcessNoValueSwitch(LPCWSTR pszCommandLine, LPCWSTR pszSwitchName, LPCWSTR &pszNextChar, BOOL &bSwitchValue);
	// Processes a switch whose value runs till the end of line (query and obj)
	HRESULT ProcessTillEOLSwitch(LPCWSTR pszCommandLine, LPCWSTR pszSwitchName, LPCWSTR &pszNextChar, LPWSTR &pszSwitchValue);



public:
	CXmlCompUI();
	virtual ~CXmlCompUI();

	// This function parses the command-line and validates the switches
	HRESULT ProcessCommandLine(LPCWSTR pszCommandLine);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\xmltransport\compiler\xmlcomp\ui.cpp ===
#include <windows.h>
#include <stdio.h>
#include <stdarg.h>
#include <objbase.h>
#include <objsafe.h>
#include <wbemcli.h>
#include "xmltrnsf.h"
#include "errors.h"
#include "ui.h"
#include "resource.h"

// Default values of switches
static LPCWSTR s_pszDefaultNamespace = L"\\\\[http://localhost/cimom]\\root\\default";

// Macros to help in parsing
#define IsColon(X)							(*X == L':')
#define IsNull(X)							(!(*X))
#define SkipSpacesTillNull(X)				while ( (!IsNull(X)) && (iswspace(*X))) X++;
#define BreakIfEnd(X)						if(IsNull(X)) break;
#define SkipTillEnd(X)						while (!IsNull(X)) X++;
#define SkipTillNextSpaceOrEnd(X)			while ( (!IsNull(X)) && (!iswspace(*X))) X++;
#define SkipTillNextSpaceOrEndOrColon(X)	while ( (!IsNull(X)) && (!iswspace(*X)) && (*X != L':')) X++;

CXmlCompUI::CXmlCompUI()
{
	m_iCommand = XML_COMP_INVALID;		// The command invoked 

	// Common Switches
	m_pszUser = NULL;					// Value of /user switch
	m_pszPassword = NULL;				// Value of /password switch
	m_dwAuthenticationLevel = RPC_C_AUTHN_LEVEL_DEFAULT;		// Value of /al switch
	m_dwImpersonationLevel = RPC_C_IMP_LEVEL_IMPERSONATE;		// Value of /il switch
	m_bEnableAllPrivileges = FALSE;		// Value of /ep switch
	m_pszLocale = NULL;					// Value of the /locale switch

	m_pszNamespacePath = new WCHAR[wcslen(s_pszDefaultNamespace) + 1];// Value of the /namespace switch
	wcscpy(m_pszNamespacePath, s_pszDefaultNamespace);

	// Write-Mode switches
	m_pszDTDURL = NULL;
	m_dwClassFlags = WBEM_FLAG_CREATE_OR_UPDATE;		// Value of the /class switch
	m_dwInstanceFlags = WBEM_FLAG_CREATE_OR_UPDATE;		// Value of the /instance switch
	m_pszInputFileName = NULL;			// Value of the /i switch
	// Read-Mode switches
	m_pszOutputFileName = NULL;			// Value of the /o switch
	m_pszObjectPath = NULL;				// Value of the /obj switch
	m_pszQuery = NULL;					// Value of the /query switch
	m_bDeep = FALSE;					// Value of the /deep switch
	m_bQualifierLevel = FALSE;			// Value of the /qualifiers switch
	m_bClassOrigin = FALSE;				// Value of the /classorigin switch
	m_bLocalOnly = FALSE;				// Value of the /local switch
	m_iDeclGroupType = wmiXMLDeclGroup;	// Value of the /decl switch
	m_iEncodingType = wmiXML_WMI_DTD_2_0;
	m_bIsUTF8 = FALSE;					// Value of the /utf8 switch

	m_bUserSpecify = FALSE;
	m_bPasswordSpecify = FALSE;
	m_bAuthenticationLevelSpecify = FALSE;
	m_bImpersonationLevelSpecify = FALSE;
	m_bEnableAllPrivilegesSpecify = FALSE;
	m_bLocaleSpecify = FALSE;
	m_bNamespacePathSpecify = FALSE;
	m_bDtdUrlSpecify = FALSE;
	m_bClassSpecify = FALSE;
	m_bInstanceSpecify = FALSE;
	m_bInputFileSpecify = FALSE;
	m_bOutputFileSpecify = FALSE;
	m_bObjectPathSpecify = FALSE;
	m_bQuerySpecify = FALSE;
	m_bDeepSpecify = FALSE;
	m_bQualifierLevelSpecify = FALSE;
	m_bClassOriginSpecify = FALSE;
	m_bLocalOnlySpecify = FALSE;
	m_bDeclGroupTypeSpecify = FALSE;
	m_bEncodingTypeSpecify = FALSE;
	m_bIsUTF8Specify = FALSE;
}

CXmlCompUI::~CXmlCompUI()
{
	delete [] m_pszUser;
	delete [] m_pszPassword;
	delete [] m_pszLocale;
	delete [] m_pszNamespacePath;
	delete [] m_pszInputFileName;
	delete [] m_pszOutputFileName;
	delete [] m_pszObjectPath;
	delete [] m_pszQuery;
}


HRESULT CXmlCompUI::ProcessCommandLine(LPCWSTR pszCommandLine)
{
	HRESULT hr = E_FAIL;
	if(SUCCEEDED(hr = ParseCommandLine(pszCommandLine)))
	{
		hr = ValidateSwitches();
	}
	return hr;
}


HRESULT CXmlCompUI::ParseCommandLine(LPCWSTR pszCommandLine)
{
	HRESULT hr = S_OK;
	LPCWSTR pszNextChar = pszCommandLine;

	if(pszCommandLine && *pszCommandLine)
	{
		// Remove trailing spaces
		LPWSTR pszLastChar = (LPWSTR)(pszCommandLine + wcslen(pszCommandLine) - 1);
		while(pszLastChar >= pszCommandLine)
		{
			if(!isspace(*pszLastChar))
				break;
			pszLastChar--;
		}
		*(pszLastChar+1) = NULL;


		// Skip over the first tokwn which is the name of the module
		SkipTillNextSpaceOrEnd(pszNextChar);
		if(IsNull(pszNextChar))
		{
			// Print the help text and quit
			PrintUsage();
			return E_FAIL;
		}


		while(*pszNextChar)
		{
			// Go to the next token
			SkipSpacesTillNull(pszNextChar);
			BreakIfEnd(pszNextChar);

			// See if it is a switch
			LPWSTR pszDummyValue = NULL;
			BOOL bRecognizedSwitch = FALSE; 
			if(_wcsnicmp(pszNextChar, L"/", 1) == 0)
			{
				if(FAILED(hr = ProcessNoValueSwitch(pszCommandLine, L"/h", pszNextChar, bRecognizedSwitch)))
					break;
				else if (hr != S_FALSE)
				{
					PrintUsage();
					return E_FAIL;
				}

				if(FAILED(hr = ProcessSingleValueSwitch(pszCommandLine, L"/user", pszNextChar, m_pszUser)))
					break;
				else if (hr != S_FALSE)
				{
					bRecognizedSwitch = m_bUserSpecify = TRUE;
					continue;
				}

				if(FAILED(hr = ProcessSingleValueSwitch(pszCommandLine, L"/password", pszNextChar, m_pszPassword)))
					break;
				else if (hr != S_FALSE)
				{
					bRecognizedSwitch = m_bPasswordSpecify = TRUE;
					continue;
				}

				if(FAILED(hr = ProcessSingleValueSwitch(pszCommandLine, L"/al", pszNextChar, pszDummyValue)))
					break;
				else if (hr != S_FALSE)
				{
					if(pszDummyValue)
					{
						bRecognizedSwitch = m_bAuthenticationLevelSpecify = TRUE;
						// Convert to authentication level
						if(_wcsicmp(pszDummyValue, L"default") == 0)
							m_dwAuthenticationLevel = RPC_C_AUTHN_LEVEL_DEFAULT;
						else if(_wcsicmp(pszDummyValue, L"none") == 0)
							m_dwAuthenticationLevel = RPC_C_AUTHN_LEVEL_NONE;
						else if(_wcsicmp(pszDummyValue, L"connect") == 0)
							m_dwAuthenticationLevel = RPC_C_AUTHN_LEVEL_CONNECT;
						else if(_wcsicmp(pszDummyValue, L"call") == 0)
							m_dwAuthenticationLevel = RPC_C_AUTHN_LEVEL_CALL;
						else if(_wcsicmp(pszDummyValue, L"pkt") == 0)
							m_dwAuthenticationLevel = RPC_C_AUTHN_LEVEL_PKT;
						else if(_wcsicmp(pszDummyValue, L"integrity") == 0)
							m_dwAuthenticationLevel = RPC_C_AUTHN_LEVEL_PKT_INTEGRITY;
						else if(_wcsicmp(pszDummyValue, L"privacy") == 0)
							m_dwAuthenticationLevel = RPC_C_AUTHN_LEVEL_PKT_PRIVACY;
						else
						{
							CreateMessage(XML_COMP_ERR_UNRECOGNIZED_AL, pszDummyValue, pszNextChar - pszCommandLine);
							hr = E_FAIL;
							break;
						}
						delete [] pszDummyValue;
						pszDummyValue = NULL;
					}
					continue;
				}
				if(FAILED(hr = ProcessSingleValueSwitch(pszCommandLine, L"/il", pszNextChar, pszDummyValue)))
					break;
				else if (hr != S_FALSE)
				{
					if(pszDummyValue)
					{
						bRecognizedSwitch = m_bImpersonationLevelSpecify = TRUE;
						// Convert to impersonation level
						if(_wcsicmp(pszDummyValue, L"anonymous") == 0)
							m_dwImpersonationLevel = RPC_C_IMP_LEVEL_ANONYMOUS;
						else if(_wcsicmp(pszDummyValue, L"identify") == 0)
							m_dwImpersonationLevel = RPC_C_IMP_LEVEL_IDENTIFY;
						else if(_wcsicmp(pszDummyValue, L"impersonate") == 0)
							m_dwImpersonationLevel = RPC_C_IMP_LEVEL_IMPERSONATE;
						else if(_wcsicmp(pszDummyValue, L"delegate") == 0)
							m_dwImpersonationLevel = RPC_C_IMP_LEVEL_DELEGATE;
						else
						{
							CreateMessage(XML_COMP_ERR_UNRECOGNIZED_IL, pszDummyValue, pszNextChar - pszCommandLine);
							hr = E_FAIL;
							break;
						}
						delete [] pszDummyValue;
						pszDummyValue = NULL;
					}
					continue;
				}

				if(FAILED(hr = ProcessNoValueSwitch(pszCommandLine, L"/ep", pszNextChar, m_bEnableAllPrivileges)))
					break;
				else if (hr != S_FALSE)
				{
					bRecognizedSwitch = m_bEnableAllPrivilegesSpecify = TRUE;
					continue;
				}

				if(FAILED(hr = ProcessNoValueSwitch(pszCommandLine, L"/utf8", pszNextChar, m_bIsUTF8)))
					break;
				else if (hr != S_FALSE)
				{
					bRecognizedSwitch = m_bIsUTF8Specify = TRUE;
					continue;
				}

				if(FAILED(hr = ProcessSingleValueSwitch(pszCommandLine, L"/locale", pszNextChar, m_pszLocale)))
					break;
				else if (hr != S_FALSE)
				{
					bRecognizedSwitch = m_bLocaleSpecify = TRUE;
					continue;
				}

				if(FAILED(hr = ProcessSingleValueSwitch(pszCommandLine, L"/namespace", pszNextChar, m_pszNamespacePath)))
					break;
				else if (hr != S_FALSE)
				{
					bRecognizedSwitch = m_bNamespacePathSpecify = TRUE;
					continue;
				}

				if(FAILED(hr = ProcessSingleValueSwitch(pszCommandLine, L"/dtd", pszNextChar, m_pszDTDURL)))
					break;
				else if (hr != S_FALSE)
				{
					bRecognizedSwitch = m_bDtdUrlSpecify = TRUE;
					continue;
				}

				if(FAILED(hr = ProcessSingleValueSwitch(pszCommandLine, L"/op", pszNextChar, pszDummyValue)))
					break;
				else if (hr != S_FALSE)
				{
					if(pszDummyValue)
					{
						bRecognizedSwitch = TRUE;
						if(m_iCommand != XML_COMP_INVALID)
						{
							CreateMessage(XML_COMP_ERR_MULTIPLE_OP, pszNextChar - pszCommandLine);
							hr = E_FAIL;
							break;
						}

						// Convert to operation
						if(_wcsicmp(pszDummyValue, L"checkwf") == 0)
							m_iCommand = XML_COMP_WELL_FORM_CHECK;
						else if(_wcsicmp(pszDummyValue, L"checkvalid") == 0)
							m_iCommand = XML_COMP_VALIDITY_CHECK;
						else if(_wcsicmp(pszDummyValue, L"compile") == 0)
							m_iCommand = XML_COMP_COMPILE;
						else if(_wcsicmp(pszDummyValue, L"get") == 0)
							m_iCommand = XML_COMP_GET;
						else if(_wcsicmp(pszDummyValue, L"query") == 0)
							m_iCommand = XML_COMP_QUERY;
						else if(_wcsicmp(pszDummyValue, L"enumInstance") == 0)
							m_iCommand = XML_COMP_ENUM_INST;
						else if(_wcsicmp(pszDummyValue, L"enumClass") == 0)
							m_iCommand = XML_COMP_ENUM_CLASS;
						else if(_wcsicmp(pszDummyValue, L"enumInstNames") == 0)
							m_iCommand = XML_COMP_ENUM_INST_NAMES;
						else if(_wcsicmp(pszDummyValue, L"enumClassNames") == 0)
							m_iCommand = XML_COMP_ENUM_CLASS_NAMES;
						else
						{
							CreateMessage(XML_COMP_ERR_UNRECOGNIZED_OP, pszDummyValue, pszNextChar - pszCommandLine);
							hr = E_FAIL;
							break;
						}
						delete [] pszDummyValue;
						pszDummyValue = NULL;
					}
					continue;
				}

				if(FAILED(hr = ProcessSingleValueSwitch(pszCommandLine, L"/class", pszNextChar, pszDummyValue)))
					break;
				else if (hr != S_FALSE)
				{
					if(pszDummyValue)
					{
						bRecognizedSwitch = m_bClassSpecify = TRUE;

						// Convert to class flags
						if(_wcsicmp(pszDummyValue, L"createOnly") == 0)
							m_dwClassFlags = WBEM_FLAG_CREATE_ONLY;
						else if(_wcsicmp(pszDummyValue, L"forceUpdate") == 0)
							m_dwClassFlags = WBEM_FLAG_UPDATE_FORCE_MODE;
						else if(_wcsicmp(pszDummyValue, L"safeUpdate") == 0)
							m_dwClassFlags = WBEM_FLAG_UPDATE_SAFE_MODE;
						else if(_wcsicmp(pszDummyValue, L"updateOnly") == 0)
							m_dwClassFlags = WBEM_FLAG_UPDATE_ONLY;
						else if(_wcsicmp(pszDummyValue, L"createOrUpdate") == 0)
							m_dwClassFlags = WBEM_FLAG_CREATE_OR_UPDATE;
						else
						{
							CreateMessage(XML_COMP_ERR_UNRECOGNIZED_CLASSF, pszDummyValue, pszNextChar - pszCommandLine);
							hr = E_FAIL;
							break;
						}
						delete [] pszDummyValue;
						pszDummyValue = NULL;
					}
					continue;
				}
				if(FAILED(hr = ProcessSingleValueSwitch(pszCommandLine, L"/instance", pszNextChar, pszDummyValue)))
					break;
				else if (hr != S_FALSE)
				{
					if(pszDummyValue)
					{
						bRecognizedSwitch = m_bInstanceSpecify = TRUE;

						// Convert to instance flags
						if(_wcsicmp(pszDummyValue, L"createOnly") == 0)
							m_dwClassFlags = WBEM_FLAG_CREATE_ONLY;
						else if(_wcsicmp(pszDummyValue, L"updateOnly") == 0)
							m_dwClassFlags = WBEM_FLAG_UPDATE_ONLY;
						else if(_wcsicmp(pszDummyValue, L"createOrUpdate") == 0)
							m_dwClassFlags = WBEM_FLAG_CREATE_OR_UPDATE;
						else
						{
							CreateMessage(XML_COMP_ERR_UNRECOGNIZED_INSTANCEF, pszDummyValue, pszNextChar - pszCommandLine);
							hr = E_FAIL;
							break;
						}
						delete [] pszDummyValue;
						pszDummyValue = NULL;
					}
					continue;
				}
				if(FAILED(hr = ProcessSingleValueSwitch(pszCommandLine, L"/i", pszNextChar, m_pszInputFileName)))
					break;
				else if (hr != S_FALSE)
				{
					bRecognizedSwitch = m_bInputFileSpecify = TRUE;
					continue;
				}

				if(FAILED(hr = ProcessSingleValueSwitch(pszCommandLine, L"/o", pszNextChar, m_pszOutputFileName)))
					break;
				else if (hr != S_FALSE)
				{
					bRecognizedSwitch = m_bOutputFileSpecify = TRUE;
					continue;
				}

				if(FAILED(hr = ProcessTillEOLSwitch(pszCommandLine, L"/obj", pszNextChar, m_pszObjectPath)))
					break;
				else if (hr != S_FALSE)
				{
					bRecognizedSwitch = m_bObjectPathSpecify = TRUE;
					continue;
				}

				if(FAILED(hr = ProcessTillEOLSwitch(pszCommandLine, L"/query", pszNextChar, m_pszQuery)))
					break;
				else if (hr != S_FALSE)
				{
					bRecognizedSwitch = m_bQuerySpecify = TRUE;
					continue;
				}

				if(FAILED(hr = ProcessNoValueSwitch(pszCommandLine, L"/deep", pszNextChar, m_bDeep)))
					break;
				else if (hr != S_FALSE)
				{
					bRecognizedSwitch = m_bDeepSpecify = TRUE;
					continue;
				}

				if(FAILED(hr = ProcessSingleValueSwitch(pszCommandLine, L"/decl", pszNextChar, pszDummyValue)))
					break;
				else if (hr != S_FALSE)
				{
					if(pszDummyValue)
					{
						bRecognizedSwitch = m_bDeclGroupTypeSpecify = TRUE;

						// Convert to declgroup flags
						if(_wcsicmp(pszDummyValue, L"declgroup") == 0)
							m_iDeclGroupType = wmiXMLDeclGroup;
						else if(_wcsicmp(pszDummyValue, L"withname") == 0)
							m_iDeclGroupType = wmiXMLDeclGroupWithName;
						else if(_wcsicmp(pszDummyValue, L"withpath") == 0)
							m_iDeclGroupType = wmiXMLDeclGroupWithPath;
						else
						{
							CreateMessage(XML_COMP_ERR_UNRECOGNIZED_DECLGROUP, pszDummyValue, pszDummyValue, pszNextChar - pszCommandLine);
							hr = E_FAIL;
							break;
						}
						delete [] pszDummyValue;
						pszDummyValue = NULL;
					}
					continue;
				}

				if(FAILED(hr = ProcessNoValueSwitch(pszCommandLine, L"/qualifiers", pszNextChar, m_bQualifierLevel)))
					break;
				else if (hr != S_FALSE)
				{
					bRecognizedSwitch = m_bQualifierLevelSpecify = TRUE;
					continue;
				}


				if(FAILED(hr = ProcessNoValueSwitch(pszCommandLine, L"/classorigin", pszNextChar, m_bClassOrigin)))
					break;
				else if (hr != S_FALSE)
				{
					bRecognizedSwitch = m_bClassOriginSpecify = TRUE;
					continue;
				}

				if(FAILED(hr = ProcessNoValueSwitch(pszCommandLine, L"/local", pszNextChar, m_bLocalOnly)))
					break;
				else if (hr != S_FALSE)
				{
					bRecognizedSwitch = m_bLocalOnlySpecify = TRUE;
					continue;
				}

				if(FAILED(hr = ProcessSingleValueSwitch(pszCommandLine, L"/encoding", pszNextChar, pszDummyValue)))
					break;
				else if (hr != S_FALSE)
				{
					if(pszDummyValue)
					{
						bRecognizedSwitch = m_bEncodingTypeSpecify = TRUE;

						// Convert to instance flags
						if(_wcsicmp(pszDummyValue, L"wmidtd20") == 0)
							m_iEncodingType = wmiXML_CIM_DTD_2_0;
						else if(_wcsicmp(pszDummyValue, L"cimdtd20") == 0)
							m_iEncodingType = wmiXML_WMI_DTD_2_0;
						else if(_wcsicmp(pszDummyValue, L"wmiwhistlerdtd") == 0)
							m_iEncodingType = wmiXML_WMI_DTD_WHISTLER;
						else
						{
							CreateMessage(XML_COMP_ERR_UNRECOGNIZED_ENCODING, pszDummyValue, pszNextChar - pszCommandLine);
							hr = E_FAIL;
							break;
						}
						delete [] pszDummyValue;
						pszDummyValue = NULL;
					}
					continue;
				}

				// Did we find atleast one known switch in this iternation?
				if(!bRecognizedSwitch)
				{
					CreateMessage(XML_COMP_ERR_UNRECOGNIZED_SWITCH, pszDummyValue, pszNextChar - pszCommandLine);
					hr = E_FAIL;
					break;
				}
				else
					bRecognizedSwitch = FALSE;

			}
			else // Error
			{
				CreateMessage(XML_COMP_ERR_INVALID_CHAR, pszNextChar - pszCommandLine);
				hr = E_FAIL;
				break;
			}
		}
	}
	return hr;
}

HRESULT CXmlCompUI::ValidateSwitches()
{
	HRESULT hr = E_FAIL;

	// See if a valid value has been specified for the /op switch
	if(m_iCommand == XML_COMP_INVALID)
	{
		CreateMessage(XML_COMP_ERR_NO_OP);
		return hr;
	}

	// Do checks for switches common to read mode and write mode
	// RAJESHR Do checks here

	// Do Checks for Write-Mode operations
	if(m_iCommand <= XML_COMP_COMPILE)
	{
		// Check if any Read-Mode switches are present
		if (m_bOutputFileSpecify || m_bObjectPathSpecify || 
			m_bQuerySpecify || m_bDeepSpecify || 
			m_bDeclGroupTypeSpecify || m_bQualifierLevelSpecify || 
			m_bClassOriginSpecify || m_bDtdUrlSpecify || m_bIsUTF8Specify)
		{
			CreateMessage(XML_COMP_ERR_INVALID_SWITCH_FOR_OP);
			return hr;
		}

		if(!m_bInputFileSpecify)
		{
			CreateMessage(XML_COMP_ERR_NO_INPUT_FILE);
			return hr;
		}
	}
	// Do Checks for Read-Mode operations
	else 
	{
		// Check if any write-mode switches are present
		if(m_bClassSpecify || m_bInstanceSpecify || m_bInputFileSpecify)
		{
			CreateMessage(XML_COMP_ERR_INVALID_SWITCH_FOR_OP);
			return hr;
		}

		// Check if the operation is a get, then the an object path has been specified
		if(m_iCommand == XML_COMP_GET)
		{
			if(!m_bObjectPathSpecify)
			{
				CreateMessage(XML_COMP_ERR_NO_OBJ);
				return hr;
			}

			// See if any useless switches have been supplied
			if(m_bDeepSpecify || m_bQuerySpecify )
			{
				CreateMessage(XML_COMP_ERR_INVALID_SWITCH_FOR_GET);
				return hr;
			}
		}
		else if(m_iCommand == XML_COMP_QUERY)
		{
			if(!m_bQuerySpecify)
			{
				CreateMessage(XML_COMP_ERR_NO_QUERY);
				return hr;
			}

			// See if any useless switches have been supplied
			if(m_bDeepSpecify || m_bObjectPathSpecify)
			{
				CreateMessage(XML_COMP_ERR_INVALID_SWITCH_FOR_QUERY);
				return hr;
			}
		}
		else if(m_iCommand == XML_COMP_ENUM_INST || XML_COMP_ENUM_CLASS || XML_COMP_ENUM_INST_NAMES || XML_COMP_ENUM_CLASS_NAMES)
		{
			if(!m_bObjectPathSpecify)
			{
				CreateMessage(XML_COMP_ERR_NO_OBJ);
				return hr;
			}

			// See if any useless switches have been supplied
			if(m_bQuerySpecify)
			{
				CreateMessage(XML_COMP_ERR_INVALID_SWITCH_FOR_ENUM);
				return hr;
			}
		}
	}
		
	return S_OK;
}

void CXmlCompUI::PrintUsage()
{
	fprintf(stderr, "xmltrnsf.exe:  WMI XML Compiler/Translator. Usage :\n"\
		"------------------------------------------------------------\n\n"\
		"xmltrnsf [<AuthSwitch>] [<CommonSwitches>] /op:<Operation> [<OperationSwitches>]\n\n"\
		"\t <Operation> := checkwf|checkvalid|compile|get|query|enumInstance|\n"\
		"\t\t enumClass|enumInstNames|enumClassNames \n\n"\
		"\t For \"checkwf\", \"checkvalid\" and \"compile\", <OperationSwitches> are:\n"\
		"\t\t <OperationSwitches> :=  /class:<ClassSwitch> | \n"\
		"\t\t\t /instance:<InstSwitch> /i:<InputFileOrURL>\n"\
		"\t\t\t <ClassSwitch> := createOnly|forceUpdate|safeUpdate|\n"
		"\t\t\t\t updateOnly|createOrUpdate\n"\
		"\t\t\t <InstSwitch> := createOnly|updateOnly|createOrUpdate\n\n"\
		"\t For \"get\", \"query\", \"enumInstance\", \"enumClass\", \"enumInstNames\" and \n"\
		"\t\t \"enumClassNames\", <OperationSwitches> are:\n"\
		"\t\t <OperationSwitches> := /dtd:<DTDURL> | /obj:<objectPath> | \n"\
		"\t\t\t /query:<query> | /deep | <OutputSwitches>\n"\
		"\t\t\t Where OutputSwitches := /o:<OutputFile> | /utf8\n"\
		"\t\t\t\t /qualifiers | /local\n"\
		"\t\t\t\t /classorigin> | /decl:<DeclType>\n\n"\
		"\t The Authentication Switches are:\n"\
		"\t\t <AuthSwitch> := /user:<userName> | /password:<password> |\n"\
		"\t\t\t /il:<impersonationLevel> | /al:<authenticationlevel> |\n"\
		"\t\t\t /ep\n"
		);
}

HRESULT CXmlCompUI::ProcessSingleValueSwitch(LPCWSTR pszCommandLine, LPCWSTR pszSwitchName, LPCWSTR &pszNextChar, LPWSTR &pszSwitchValue)
{
	HRESULT hr = S_OK;
	// Store the beginning of the switch
	LPCWSTR pszStartOfSwitch = pszNextChar;

	// Reach the end of this switch
	SkipTillNextSpaceOrEndOrColon(pszNextChar);

	// See whether there are enough characters in this switch
	DWORD_PTR dwLengthOfSwitch = pszNextChar - pszStartOfSwitch;

	if(wcslen(pszSwitchName) == dwLengthOfSwitch && _wcsnicmp(pszStartOfSwitch, pszSwitchName, wcslen(pszSwitchName)) == 0)
	{
		// Check to see if there's some more command-line left
		if(IsNull(pszNextChar) || !IsColon(pszNextChar))
		{
			CreateMessage(XML_COMP_ERR_MISSING_SWITCH_VALUE, pszNextChar - pszCommandLine);
			return E_FAIL;
		}

		// Get the switch value
		// Go till the next null or space
		pszStartOfSwitch = ++pszNextChar;
		SkipTillNextSpaceOrEnd(pszNextChar);

		// See if there's a value
		if(pszNextChar == pszStartOfSwitch)
		{
			CreateMessage(XML_COMP_ERR_MISSING_SWITCH_VALUE, pszNextChar - pszCommandLine);
			return E_FAIL;
		}

		// Copy that value on to the class member
		dwLengthOfSwitch = pszNextChar - pszStartOfSwitch;
		pszSwitchValue = new WCHAR[dwLengthOfSwitch + 1];
		wcsncpy(pszSwitchValue, pszStartOfSwitch, dwLengthOfSwitch);
		pszSwitchValue[dwLengthOfSwitch] = NULL;
	}
	else
	{
		pszNextChar = pszStartOfSwitch; // Unread what was read
		return S_FALSE;
	}
	return hr;
}

HRESULT CXmlCompUI::ProcessNoValueSwitch(LPCWSTR pszCommandLine, LPCWSTR pszSwitchName, LPCWSTR &pszNextChar, BOOL &bSwitchValue)
{
	HRESULT hr = S_OK;
	// Store the beginning of the switch
	LPCWSTR pszStartOfSwitch = pszNextChar;

	// Reach the end of this switch
	SkipTillNextSpaceOrEnd(pszNextChar);

	// See whether there are enough characters in this switch
	DWORD_PTR dwLengthOfSwitch = pszNextChar - pszStartOfSwitch;

	if(wcslen(pszSwitchName) == dwLengthOfSwitch && _wcsnicmp(pszStartOfSwitch, pszSwitchName, wcslen(pszSwitchName)) == 0)
	{
		// Check to see if there's some more command-line left
		if(!IsNull(pszNextChar) && !iswspace(*pszNextChar))
		{
			CreateMessage(XML_COMP_ERR_MISSING_SWITCH_VALUE, pszNextChar - pszCommandLine);
			return E_FAIL;
		}

		bSwitchValue = TRUE;
	}
	else
	{
		pszNextChar = pszStartOfSwitch; // Unread what was read
		return S_FALSE;
	}
	return hr;
}

HRESULT CXmlCompUI::ProcessTillEOLSwitch(LPCWSTR pszCommandLine, LPCWSTR pszSwitchName, LPCWSTR &pszNextChar, LPWSTR &pszSwitchValue)
{
	HRESULT hr = S_OK;
	// Store the beginning of the switch
	LPCWSTR pszStartOfSwitch = pszNextChar;

	// Reach the end of this switch
	SkipTillNextSpaceOrEndOrColon(pszNextChar);

	// See whether there are enough characters in this switch
	DWORD_PTR dwLengthOfSwitch = pszNextChar - pszStartOfSwitch;

	if(wcslen(pszSwitchName) == dwLengthOfSwitch && _wcsnicmp(pszStartOfSwitch, pszSwitchName, wcslen(pszSwitchName)) == 0)
	{
		// Check to see if there's some more command-line left
		if(IsNull(pszNextChar) || !IsColon(pszNextChar))
		{
			CreateMessage(XML_COMP_ERR_MISSING_SWITCH_VALUE, pszNextChar - pszCommandLine);
			return E_FAIL;
		}

		// Get the switch value
		// Go till the EOL
		pszStartOfSwitch = ++pszNextChar;
		SkipTillEnd(pszNextChar);

		// See if there's a value
		if(pszNextChar == pszStartOfSwitch)
		{
			CreateMessage(XML_COMP_ERR_MISSING_SWITCH_VALUE, pszNextChar - pszCommandLine);
			return E_FAIL;
		}

		// Copy that value on to the class member
		dwLengthOfSwitch = (pszNextChar - pszStartOfSwitch) + 1;
		pszSwitchValue = new WCHAR[dwLengthOfSwitch + 1];
		wcsncpy(pszSwitchValue, pszStartOfSwitch, dwLengthOfSwitch);
		pszSwitchValue[dwLengthOfSwitch] = NULL;
	}
	else
	{
		pszNextChar = pszStartOfSwitch; // Unread what was read
		return S_FALSE;
	}
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\xmltransport\server\wmi2xml\makefile.inc ===
############################################################################
#
#   Copyright (C) 1999, Microsoft Corporation.
#
#   All rights reserved.
#
############################################################################

!INCLUDE $(_NTDRIVE)$(_NTROOT)\WMI\COMMON\makefile.cmn
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\xmltransport\server\wmi2xml\classfac.cpp ===
//***************************************************************************
//
// Copyright (c) 1997-1999 Microsoft Corporation
//
//  CLASSFAC.CPP
//
//  rajesh  2/25/2000   Created.
//
//  Contains the class factory for 2 components - CWmiToXml and CXml2Wmi  
//
//***************************************************************************

#include "precomp.h"
#include <wbemidl.h>
#include <wbemint.h>
#include <genlex.h>
#include <opathlex.h>
#include <objpath.h>


#include "maindll.h"
#include "classfac.h"
#include "wmiconv.h"
#include "wmi2xml.h"
#include "xmlToWmi.h"

//***************************************************************************
//
// CWmiToXmlFactory::CWmiToXmlFactory
//
// DESCRIPTION:
//
// Constructor
//
//***************************************************************************

CWmiToXmlFactory::CWmiToXmlFactory()
{
    m_cRef=0L;
    InterlockedIncrement(&g_cObj);
	return;
}

//***************************************************************************
//
// CWmiToXmlFactory::~CWmiToXmlFactory
//
// DESCRIPTION:
//
// Destructor
//
//***************************************************************************

CWmiToXmlFactory::~CWmiToXmlFactory(void)
{
    InterlockedDecrement(&g_cObj);
	return;
}

//***************************************************************************
//
// CWmiToXmlFactory::QueryInterface
// CWmiToXmlFactory::AddRef
// CWmiToXmlFactory::Release
//
// Purpose: Standard Ole routines needed for all interfaces
//
//***************************************************************************


STDMETHODIMP CWmiToXmlFactory::QueryInterface(REFIID riid
    , LPVOID *ppv)
{
    *ppv=NULL;

    if (IID_IUnknown==riid || IID_IClassFactory==riid)
        *ppv=this;

    if (NULL!=*ppv)
        {
        ((LPUNKNOWN)*ppv)->AddRef();
        return NOERROR;
        }

    return ResultFromScode(E_NOINTERFACE);
}

STDMETHODIMP_(ULONG) CWmiToXmlFactory::AddRef(void)
{
    long l = InterlockedIncrement(&m_cRef);
    return l;
}

STDMETHODIMP_(ULONG) CWmiToXmlFactory::Release(void)
{
    long l = InterlockedDecrement(&m_cRef);
    if (0L!=l)
        return l;

    delete this;
    return 0L;
}

//***************************************************************************
//
//  SCODE CWmiToXmlFactory::CreateInstance
//
//  Description:
//
//  Instantiates a Translator object returning an interface pointer.
//
//  Parameters:
//
//  pUnkOuter       LPUNKNOWN to the controlling IUnknown if we are
//                  being used in an aggregation.
//  riid            REFIID identifying the interface the caller
//                  desires to have for the new object.
//  ppvObj          PPVOID in which to store the desired
//                  interface pointer for the new object.
//
// Return Value:
//  HRESULT         NOERROR if successful, otherwise E_NOINTERFACE
//                  if we cannot support the requested interface.
//***************************************************************************

STDMETHODIMP CWmiToXmlFactory::CreateInstance (

	IN LPUNKNOWN pUnkOuter,
    IN REFIID riid,
    OUT PPVOID ppvObj
)
{
    IUnknown *   pObj;
    HRESULT      hr;

    *ppvObj=NULL;

    // This object doesnt support aggregation.
    if (NULL!=pUnkOuter)
        return ResultFromScode(CLASS_E_NOAGGREGATION);

    pObj = new CWmiToXml;

    if (NULL == pObj)
        return ResultFromScode(E_OUTOFMEMORY);;

    hr = pObj->QueryInterface(riid, ppvObj);

    //Kill the object if initial creation or Init failed.
    if ( FAILED(hr) )
        delete pObj;
    return hr;
}

//***************************************************************************
//
//  SCODE CWmiToXmlFactory::LockServer
//
//  Description:
//
//  Increments or decrements the lock count of the DLL.  If the
//  lock count goes to zero and there are no objects, the DLL
//  is allowed to unload.  See DllCanUnloadNow.
//
//  Parameters:
//
//  fLock           BOOL specifying whether to increment or
//                  decrement the lock count.
//
//  Return Value:
//
//  HRESULT         NOERROR always.
//***************************************************************************


STDMETHODIMP CWmiToXmlFactory::LockServer(IN BOOL fLock)
{
    if (fLock)
        InterlockedIncrement((long *)&g_cLock);
    else
        InterlockedDecrement((long *)&g_cLock);

    return NOERROR;
}


/* Conversion to Text to Wbem Object has been cut from the WHistler Feature List and hence commented out 






// ***************************************************************************
//
// CWmiToXmlFactory::CWmiToXmlFactory
//
// DESCRIPTION:
//
// Constructor
//
// ***************************************************************************

CXmlToWmiFactory::CXmlToWmiFactory()
{
    m_cRef=0L;
    InterlockedIncrement(&g_cObj);

	// Make sure Globals are initialized
	// The corresponding call ReleaseDLLResources() call
	// is made in DllCanUnloadNow()
	AllocateDLLResources();
	return;
}

// ***************************************************************************
//
// CWmiToXmlFactory::~CWmiToXmlFactory
//
// DESCRIPTION:
//
// Destructor
//
// ***************************************************************************

CXmlToWmiFactory::~CXmlToWmiFactory(void)
{
    InterlockedDecrement(&g_cObj);
	return;
}

// ***************************************************************************
//
// CWmiToXmlFactory::QueryInterface
// CWmiToXmlFactory::AddRef
// CWmiToXmlFactory::Release
//
// Purpose: Standard Ole routines needed for all interfaces
//
// ***************************************************************************


STDMETHODIMP CXmlToWmiFactory::QueryInterface(REFIID riid
    , LPVOID *ppv)
{
    *ppv=NULL;

    if (IID_IUnknown==riid || IID_IClassFactory==riid)
        *ppv=this;

    if (NULL!=*ppv)
        {
        ((LPUNKNOWN)*ppv)->AddRef();
        return NOERROR;
        }

    return ResultFromScode(E_NOINTERFACE);
}

STDMETHODIMP_(ULONG) CXmlToWmiFactory::AddRef(void)
{
    long l = InterlockedIncrement(&m_cRef);
    return l;
}

STDMETHODIMP_(ULONG) CXmlToWmiFactory::Release(void)
{
    long l = InterlockedDecrement(&m_cRef);
    if (0L!=l)
        return l;

    delete this;
    return 0L;
}

// ***************************************************************************
//
//  SCODE CWmiToXmlFactory::CreateInstance
//
//  Description: 
//
//  Instantiates a Translator object returning an interface pointer.
//
//  Parameters:
//
//  pUnkOuter       LPUNKNOWN to the controlling IUnknown if we are
//                  being used in an aggregation.
//  riid            REFIID identifying the interface the caller
//                  desires to have for the new object.
//  ppvObj          PPVOID in which to store the desired
//                  interface pointer for the new object.
//
// Return Value:
//  HRESULT         NOERROR if successful, otherwise E_NOINTERFACE
//                  if we cannot support the requested interface.
// ***************************************************************************

STDMETHODIMP CXmlToWmiFactory::CreateInstance (

	IN LPUNKNOWN pUnkOuter,
    IN REFIID riid, 
    OUT PPVOID ppvObj
)
{
    IUnknown *   pObj;
    HRESULT      hr;

    *ppvObj=NULL;
    
    // This object doesnt support aggregation.
    if (NULL!=pUnkOuter)
        return ResultFromScode(CLASS_E_NOAGGREGATION);

    pObj = new CXml2Wmi;
	
    if (NULL == pObj)
        return ResultFromScode(E_OUTOFMEMORY);;

    hr = pObj->QueryInterface(riid, ppvObj);

    //Kill the object if initial creation or Init failed.
    if ( FAILED(hr) )
        delete pObj;
    return hr;
}

// ***************************************************************************
//
//  SCODE CWmiToXmlFactory::LockServer
//
//  Description:
//
//  Increments or decrements the lock count of the DLL.  If the
//  lock count goes to zero and there are no objects, the DLL
//  is allowed to unload.  See DllCanUnloadNow.
//
//  Parameters:
//
//  fLock           BOOL specifying whether to increment or
//                  decrement the lock count.
//
//  Return Value:
// 
//  HRESULT         NOERROR always.
// ***************************************************************************


STDMETHODIMP CXmlToWmiFactory::LockServer(IN BOOL fLock)
{
    if (fLock)
        InterlockedIncrement((long *)&g_cLock);
    else
        InterlockedDecrement((long *)&g_cLock);

    return NOERROR;
}


*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\xmltransport\server\wmi2xml\maindll.h ===
#ifndef WMI_TO_XML_MAIN_DLL_H
#define WMI_TO_XML_MAIN_DLL_H

// These globals are initialized in the OpenWbemTextSource() call to the class factory
// and released in the CloseWbemTextSource() call
extern BSTR g_strName;
extern BSTR g_strSuperClass;
extern BSTR g_strType;
extern BSTR g_strClassOrigin;
extern BSTR g_strSize;
extern BSTR g_strClassName;
extern BSTR g_strValueType;
extern BSTR g_strToSubClass;
extern BSTR g_strToInstance;
extern BSTR g_strAmended;
extern BSTR g_strOverridable;
extern BSTR g_strArraySize;
extern BSTR g_strReferenceClass;

// This is the object factory used to create free-form objects
// This is initialized in OpenWbemTextSource() and released in CloseWbemTextSource()
extern _IWmiObjectFactory *g_pObjectFactory;

// A couple of routines to allocate and deallocate global variables
HRESULT ReleaseDLLResources();
HRESULT AllocateDLLResources();
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\xmltransport\server\wmi2xml\maindll.cpp ===
//***************************************************************************
//
// Copyright (c) 1997-1999 Microsoft Corporation
//
//  MAINDLL.CPP
//
//  rajesh  3/25/2000   Created.
//
// Contains the DLL entry points for the wmi2xml.dll
// This DLL can be used as a COM DLL with 2 components that implement the
// IWbemXMLConvertor and IXMLWbemConvertor interfaces, or it can be treated
// as a non-COM DLL with the entry points WbemObjectToText() and TextToWbemObject()
// The COM usage is done by the WMI Client API that uses XML. It uses the COM 
// components in this DLL to convert to/from XML and WMI.
// The non-COM usage is by the WMI Core for purposed of implementation of th
// IWbemObjectTextSrc interfaces. WMI Core uses the entry points WbemObjectToText
// and TextToWbemObject to implement that interface when used with XML representations
//
//***************************************************************************

#include "precomp.h"
#include <olectl.h>
#include <wbemidl.h>
#include <wbemint.h>

#include <genlex.h>
#include <opathlex.h>
#include <objpath.h>

#include "classfac.h"
#include "wmiconv.h"
#include "xmlToWmi.h"
#include "maindll.h"

// These the the CLSIDs of the 2 Components implemented in this DLL
// {610037EC-CE06-11d3-93FC-00805F853771}
DEFINE_GUID(CLSID_WbemXMLConvertor,
0x610037ec, 0xce06, 0x11d3, 0x93, 0xfc, 0x0, 0x80, 0x5f, 0x85, 0x37, 0x71);
// {41388E26-F847-4a9d-96C0-9A847DBA4CFE}
DEFINE_GUID(CLSID_XMLWbemConvertor,
0x41388e26, 0xf847, 0x4a9d, 0x96, 0xc0, 0x9a, 0x84, 0x7d, 0xba, 0x4c, 0xfe);


// Count number of objects and number of locks.
long g_cObj = 0 ;
long g_cLock = 0 ;
HMODULE ghModule = NULL;

// An Object Factory used by TextToWbemObject
_IWmiObjectFactory *g_pObjectFactory = NULL;

// Some const BSTRs
BSTR g_strName = NULL;
BSTR g_strSuperClass = NULL;
BSTR g_strType = NULL;
BSTR g_strClassOrigin = NULL;
BSTR g_strSize = NULL;
BSTR g_strClassName = NULL;
BSTR g_strValueType = NULL;
BSTR g_strToSubClass = NULL;
BSTR g_strToInstance = NULL;
BSTR g_strAmended = NULL;
BSTR g_strOverridable = NULL;
BSTR g_strArraySize = NULL;
BSTR g_strReferenceClass = NULL;

// A critical section to create/delete globals 
CRITICAL_SECTION g_StaticsCreationDeletion;

// A boolean that indicates whether globals have been initialized
bool g_bGlobalsInitialized = false;

// Control-specific registry strings
LPCTSTR WMI_XML_DESCRIPTION	= __TEXT("WMI TO XML Helper");
LPCTSTR XML_WMI_DESCRIPTION	= __TEXT("XML TO WMI Helper");

// Standard registry key/value names
LPCTSTR INPROC32_STR			= __TEXT("InprocServer32");
LPCTSTR INPROC_STR				= __TEXT("InprocServer");
LPCTSTR THREADING_MODEL_STR		= __TEXT("ThreadingModel");
LPCTSTR BOTH_STR				= __TEXT("Both");
LPCTSTR CLSID_STR				= __TEXT("SOFTWARE\\CLASSES\\CLSID\\");
LPCTSTR OBJECT_TXT_SRC_STR		= __TEXT("SOFTWARE\\Microsoft\\WBEM\\TextSource");
LPCTSTR XMLENCODER_STR			= __TEXT("SOFTWARE\\Microsoft\\WBEM\\xml\\Encoders");
LPCTSTR XMLDECODER_STR			= __TEXT("SOFTWARE\\Microsoft\\WBEM\\xml\\Decoders");
LPCTSTR VERSION_1				= __TEXT("1.0");
LPCTSTR VERSION_2				= __TEXT("2.0");

//***************************************************************************
//
//  BOOL WINAPI DllMain
//
//  DESCRIPTION:
//
//  Entry point for DLL.
//
//  PARAMETERS:
//
//		hModule           instance handle
//		ulReason          why we are being called
//		pvReserved        reserved
//
//  RETURN VALUE:
//
//  TRUE if OK.
//
//***************************************************************************
BOOL WINAPI DllMain( HINSTANCE hModule,
                       DWORD  ulReason,
                       LPVOID lpReserved
					 )
{
	switch (ulReason)
	{
		case DLL_PROCESS_DETACH:
			DeleteCriticalSection(&g_StaticsCreationDeletion);
			return TRUE;

		case DLL_PROCESS_ATTACH:
			InitializeCriticalSection(&g_StaticsCreationDeletion);
			ghModule = hModule;
	        return TRUE;
    }

    return TRUE;
}

//***************************************************************************
//
//  STDAPI DllGetClassObject
//
//  DESCRIPTION:
//
//  Called when Ole wants a class factory.  Return one only if it is the sort
//  of class this DLL supports.
//
//  PARAMETERS:
//
//  rclsid              CLSID of the object that is desired.
//  riid                ID of the desired interface.
//  ppv                 Set to the class factory.
//
//  RETURN VALUE:
//
//  S_OK                all is well
//  E_FAILED            not something we support
//
//***************************************************************************

STDAPI DllGetClassObject(

	IN REFCLSID rclsid,
    IN REFIID riid,
    OUT LPVOID *ppv
)
{
    HRESULT hr;

    if (CLSID_WbemXMLConvertor == rclsid)
	{
		CWmiToXmlFactory *pObj = NULL;
	    
		if (NULL == (pObj = new CWmiToXmlFactory()))
			return ResultFromScode(E_OUTOFMEMORY);
		
		hr=pObj->QueryInterface(riid, ppv);

		if ( FAILED ( hr ) )
		{
			delete pObj ;
		}
	}
	/* Conversion to Text to Wbem Object has been cut from the WHistler Feature List and hence commented out 
    else if (CLSID_XMLWbemConvertor == rclsid)
	{
		CXmlToWmiFactory *pObj = NULL;
	    
        if (NULL == (pObj = new CXmlToWmiFactory()))
			return ResultFromScode(E_OUTOFMEMORY);
		hr=pObj->QueryInterface(riid, ppv);

		if ( FAILED ( hr ) )
		{
			delete pObj ;
		}
	}
	*/
	else
        return E_FAIL;


    return hr ;
}


//***************************************************************************
//
//  STDAPI DllCanUnloadNow
//
//  DESCRIPTION:
//
//  Answers if the DLL can be freed, that is, if there are no
//  references to anything this DLL provides.
//
//  RETURN VALUE:
//
//  S_OK                if it is OK to unload
//  S_FALSE             if still in use
//
//***************************************************************************

STDAPI DllCanUnloadNow ()
{
	//It is OK to unload if there are no objects or locks on the
    // class factory.

    if (0L==g_cObj && 0L==g_cLock) 
	{
		ReleaseDLLResources();
		return S_OK;
	}

	return S_FALSE;
}


/***************************************************************************
 *
 * SetKeyAndValue
 *
 * Description: Helper function for DllRegisterServer that creates
 * a key, sets a value, and closes that key. If pszSubkey is NULL, then
 * the value is created for the pszKey key.
 *
 * Parameters:
 *  pszKey          LPTSTR to the name of the key
 *  pszSubkey       LPTSTR to the name of a subkey
 *  pszValueName    LPTSTR to the value name to use
 *  pszValue        LPTSTR to the value to store
 *
 * Return Value:
 *  BOOL            TRUE if successful, FALSE otherwise.
 ***************************************************************************/

BOOL SetKeyAndValue(LPCTSTR pszKey, LPCTSTR pszSubkey, LPCTSTR pszValueName, LPCTSTR pszValue)
{
    HKEY        hKey;
    TCHAR       szKey[256];

    _tcscpy(szKey, pszKey);

	// If a sub key is mentioned, use it.
    if (NULL != pszSubkey)
    {
		_tcscat(szKey, __TEXT("\\"));
        _tcscat(szKey, pszSubkey);
    }

    if (ERROR_SUCCESS != RegCreateKeyEx(HKEY_LOCAL_MACHINE,
		szKey, 0, NULL, REG_OPTION_NON_VOLATILE,
		KEY_ALL_ACCESS, NULL, &hKey, NULL))
        return FALSE;

    if (NULL != pszValue)
    {
        if (ERROR_SUCCESS != RegSetValueEx(hKey, pszValueName, 0, REG_SZ, (BYTE *)pszValue,
			(_tcslen(pszValue)+1)*sizeof(TCHAR)))
			return FALSE;
    }
    RegCloseKey(hKey);
    return TRUE;
}

/***************************************************************************
 *
 * DeleteKey
 *
 * Description: Helper function for DllUnRegisterServer that deletes the subkey
 * of a key.
 *
 * Parameters:
 *  pszKey          LPTSTR to the name of the key
 *  pszSubkey       LPTSTR ro the name of a subkey
 *
 * Return Value:
 *  BOOL            TRUE if successful, FALSE otherwise.
 ***************************************************************************/

BOOL DeleteKey(LPCTSTR pszKey, LPCTSTR pszSubkey)
{
    HKEY        hKey;

    if (ERROR_SUCCESS != RegCreateKeyEx(HKEY_LOCAL_MACHINE,
		pszKey, 0, NULL, REG_OPTION_NON_VOLATILE,
		KEY_ALL_ACCESS, NULL, &hKey, NULL))
        return FALSE;

	if(ERROR_SUCCESS != RegDeleteKey(hKey, pszSubkey))
		return FALSE;

    RegCloseKey(hKey);
    return TRUE;
}


/***************************************************************************
 *
 * DeleteValue
 *
 * Description: Helper function for DllUnRegisterServer that deletes a value
 * under a key.
 *
 * Parameters:
 *  pszKey          LPTSTR to the name of the key
 *  pszValue		LPTSTR to the name of a value under the key
 *
 * Return Value:
 *  BOOL            TRUE if successful, FALSE otherwise.
 ***************************************************************************/

BOOL DeleteValue(LPCTSTR pszKey, LPCTSTR pszValue)
{
    HKEY        hKey;

    if (ERROR_SUCCESS != RegCreateKeyEx(HKEY_LOCAL_MACHINE,
		pszKey, 0, NULL, REG_OPTION_NON_VOLATILE,
		KEY_ALL_ACCESS, NULL, &hKey, NULL))
        return FALSE;

	if(ERROR_SUCCESS != RegDeleteValue(hKey, pszValue))
		return FALSE;

    RegCloseKey(hKey);
    return TRUE;
}



//***************************************************************************
//
// DllRegisterServer
//
// Purpose: Called during setup or by regsvr32.
//
// Return:  NOERROR if registration successful, error otherwise.
//***************************************************************************

STDAPI DllRegisterServer(void)
{
	TCHAR szModule[512];
	GetModuleFileName(ghModule, szModule, sizeof(szModule)/sizeof(TCHAR));

	TCHAR szWmiXmlClassID[128];
	TCHAR szWmiXmlCLSIDClassID[128];

#ifdef UNICODE
	if(StringFromGUID2(CLSID_WbemXMLConvertor, szWmiXmlClassID, 128) == 0)
		return SELFREG_E_CLASS;
#else
	WCHAR wszWmiXmlClassID[128];
	if(StringFromGUID2(CLSID_WbemXMLConvertor, wszWmiXmlClassID, 128) == 0)
		return SELFREG_E_CLASS;
	WideCharToMultiByte(CP_ACP, 0, wszWmiXmlClassID, -1, szWmiXmlCLSIDClassID, 128, NULL, NULL);

#endif

	_tcscpy(szWmiXmlCLSIDClassID, CLSID_STR);
	_tcscat(szWmiXmlCLSIDClassID, szWmiXmlClassID);

	//
	// Create entries under CLSID for the Wmi to XML convertor
	//
	if (FALSE == SetKeyAndValue(szWmiXmlCLSIDClassID, NULL, NULL, WMI_XML_DESCRIPTION))
		return SELFREG_E_CLASS;
	if (FALSE == SetKeyAndValue(szWmiXmlCLSIDClassID, INPROC32_STR, NULL, szModule))
		return SELFREG_E_CLASS;
	if (FALSE == SetKeyAndValue(szWmiXmlCLSIDClassID, INPROC32_STR, THREADING_MODEL_STR, BOTH_STR))
		return SELFREG_E_CLASS;

	TCHAR szXmlWmiClassID[128];
	TCHAR szXmlWmiCLSIDClassID[128];

#ifdef UNICODE
	if(StringFromGUID2(CLSID_XMLWbemConvertor, szXmlWmiClassID, 128) == 0)
		return SELFREG_E_CLASS;
#else
	WCHAR wszXmlWmiClassID[128];
	if(StringFromGUID2(CLSID_XMLWbemConvertor, wszXmlWmiClassID, 128) == 0)
		return SELFREG_E_CLASS;
	WideCharToMultiByte(CP_ACP, 0, wszXmlWmiClassID, -1, szXmlWmiCLSIDClassID, 128, NULL, NULL);

#endif

	/* Conversion to Text to Wbem Object has been cut from the WHistler Feature List and hence commented out 
	_tcscpy(szXmlWmiCLSIDClassID, CLSID_STR);
	_tcscat(szXmlWmiCLSIDClassID, szXmlWmiClassID);


	//
	// Create entries under CLSID for the XML to WMI convertor
	//
	if (FALSE == SetKeyAndValue(szXmlWmiCLSIDClassID, NULL, NULL, XML_WMI_DESCRIPTION))
		return SELFREG_E_CLASS;
	if (FALSE == SetKeyAndValue(szXmlWmiCLSIDClassID, INPROC32_STR, NULL, szModule))
		return SELFREG_E_CLASS;
	if (FALSE == SetKeyAndValue(szXmlWmiCLSIDClassID, INPROC32_STR, THREADING_MODEL_STR, BOTH_STR))
		return SELFREG_E_CLASS;

	*/

	// Now create entries for the Core team's implementation of the IWbemObjectTxtSrc interface
	if (FALSE == SetKeyAndValue(OBJECT_TXT_SRC_STR, 
						L"1", // WMI_OBJ_TEXT_CIM_DTD_2_0
						L"TextSourceDLL", szModule))
		return SELFREG_E_CLASS;
	if (FALSE == SetKeyAndValue(OBJECT_TXT_SRC_STR, 
						L"2", // WMI_OBJ_TEXT_WMI_DTD_2_0, NULL
						L"TextSourceDLL", szModule))
		return SELFREG_E_CLASS;


	// We're done with the COM Entries. Now, we need to create our component specific entries.
	// Each WMI XML Encoder/Decoder is registered underneath the key HKLM/Software/Microsoft/WBEM/XML/Encoders
	// For each encoding (including these 2), we will have to create a value with the DTD version as name
	// and a value of the CLSID of the component. So, here we go
	// Remove the braces from the string representation first
	szWmiXmlClassID[wcslen(szWmiXmlClassID)-1] = NULL;
	if (FALSE == SetKeyAndValue(XMLENCODER_STR, NULL, VERSION_1, szWmiXmlClassID+1))
		return SELFREG_E_CLASS;
	if (FALSE == SetKeyAndValue(XMLENCODER_STR, NULL, VERSION_2, szWmiXmlClassID+1))
		return SELFREG_E_CLASS;
	if (FALSE == SetKeyAndValue(XMLDECODER_STR, NULL, VERSION_1, szXmlWmiClassID+1))
		return SELFREG_E_CLASS;
	if (FALSE == SetKeyAndValue(XMLDECODER_STR, NULL, VERSION_2, szXmlWmiClassID+1))
		return SELFREG_E_CLASS;

	return NOERROR;
}

//***************************************************************************
//
// DllUnregisterServer
//
// Purpose: Called when it is time to remove the registry entries.
//
// Return:  NOERROR if registration successful, error otherwise.
//***************************************************************************

STDAPI DllUnregisterServer(void)
{
	TCHAR szModule[512];
	GetModuleFileName(ghModule,szModule, sizeof(szModule)/sizeof(TCHAR));

	TCHAR szWmiXmlClassID[128];
	TCHAR szWmiXmlCLSIDClassID[128];

#ifdef UNICODE
	if(StringFromGUID2(CLSID_WbemXMLConvertor, szWmiXmlClassID, 128) == 0)
		return SELFREG_E_CLASS;
#else
	WCHAR wszWmiXmlClassID[128];
	if(StringFromGUID2(CLSID_WbemXMLConvertor, wszWmiXmlClassID, 128) == 0)
		return SELFREG_E_CLASS;
	WideCharToMultiByte(CP_ACP, 0, wszWmiXmlClassID, -1, szWmiXmlClassID, 128, NULL, NULL);

#endif

	_tcscpy(szWmiXmlCLSIDClassID, CLSID_STR);
	_tcscat(szWmiXmlCLSIDClassID, szWmiXmlClassID);

	//
	// Delete the keys for the WMI to XML COM obhect
	//
	if(FALSE == DeleteKey(szWmiXmlCLSIDClassID, INPROC32_STR))
		return SELFREG_E_CLASS;
	if(FALSE == DeleteKey(CLSID_STR, szWmiXmlClassID))
		return SELFREG_E_CLASS;

	/* Conversion to Text to Wbem Object has been cut from the WHistler Feature List and hence commented out 

	TCHAR szXmlWmiClassID[128];
	TCHAR szXmlWmiCLSIDClassID[128];

#ifdef UNICODE
	if(StringFromGUID2(CLSID_XMLWbemConvertor, szXmlWmiClassID, 128) == 0)
		return SELFREG_E_CLASS;
#else
	WCHAR wszXmlWmiClassID[128];
	if(StringFromGUID2(CLSID_XMLWbemConvertor, wszXmlWmiClassID, 128) == 0)
		return SELFREG_E_CLASS;
	WideCharToMultiByte(CP_ACP, 0, wszXmlWmiClassID, -1, szXmlWmiCLSIDClassID, 128, NULL, NULL);

#endif

	_tcscpy(szXmlWmiCLSIDClassID, CLSID_STR);
	_tcscat(szXmlWmiCLSIDClassID, szXmlWmiClassID);

	//
	// Delete the keys for the XML to WMI COM obhect
	//
	if(FALSE == DeleteKey(szXmlWmiCLSIDClassID, INPROC32_STR))
		return SELFREG_E_CLASS;
	if(FALSE == DeleteKey(CLSID_STR, szXmlWmiClassID))
		return SELFREG_E_CLASS;

	*/

	// Remove the  entries for the Core team's implementation of the IWbemObjectTxtSrc interface
	if (FALSE == DeleteKey(OBJECT_TXT_SRC_STR, /*WMI_OBJ_TEXT_CIM_DTD_2_0, NULL*/ L"1"))
		return SELFREG_E_CLASS;
	if (FALSE == DeleteKey(OBJECT_TXT_SRC_STR, /*WMI_OBJ_TEXT_WMI_DTD_2_0, NULL*/ L"2"))
		return SELFREG_E_CLASS;

	// Delete the non-COM Registry stuff
	if(FALSE == DeleteValue(XMLENCODER_STR, VERSION_1))
		return SELFREG_E_CLASS;
	if(FALSE == DeleteValue(XMLENCODER_STR, VERSION_2))
		return SELFREG_E_CLASS;
	if(FALSE == DeleteValue(XMLDECODER_STR, VERSION_1))
		return SELFREG_E_CLASS;
	if(FALSE == DeleteValue(XMLDECODER_STR, VERSION_2))
		return SELFREG_E_CLASS;
    return NOERROR;
}

// This is called only if this DLL is treated as a NON COM DLL
HRESULT AllocateDLLResources()
{
	HRESULT hr = E_FAIL;
	EnterCriticalSection(&g_StaticsCreationDeletion);
	if(!g_bGlobalsInitialized)
	{
		g_bGlobalsInitialized = true;

		// Increment the object count since this is a COM DLL too.
		// Otherwise a COM Client in the process would call CoFreeUnusedLibraries and
		// this would result in unloading of the DLL while a C++ client is
		// holding on to a proc address obtained using Loadlibrary/GetProcAddress
		InterlockedIncrement(&g_cObj);

		// Create an object factory for use in TextToWbemObject
		if(SUCCEEDED(hr = CoCreateInstance(CLSID__WmiObjectFactory, NULL, CLSCTX_INPROC_SERVER,
													IID__IWmiObjectFactory, (LPVOID *)&g_pObjectFactory)))
		{
			if(	(g_strName = SysAllocString(L"NAME"))				&&
				(g_strSuperClass = SysAllocString(L"SUPERCLASS")) &&
				(g_strType = SysAllocString(L"TYPE"))				&&
				(g_strClassOrigin = SysAllocString(L"CLASSORIGIN")) &&
				(g_strSize = SysAllocString(L"ARRAYSIZE"))		&&
				(g_strClassName = SysAllocString(L"CLASSNAME"))	&&
				(g_strValueType = SysAllocString(L"VALUETYPE"))	&&
				(g_strToSubClass = SysAllocString(L"TOSUBCLASS"))	&&
				(g_strToInstance = SysAllocString(L"TOINSTANCE"))	&&
				(g_strAmended = SysAllocString(L"AMENDED"))		&&
				(g_strOverridable = SysAllocString(L"OVERRIDABLE")) &&
				(g_strArraySize = SysAllocString(L"ARRAYSIZE")) &&
				(g_strReferenceClass = SysAllocString(L"REFERENCECLASS")) )
			{
				hr = S_OK;
			}
			else
				hr = E_OUTOFMEMORY;
		}

		// Release resources if things did not go well
		if(FAILED(hr))
			ReleaseDLLResources();
	}
	else
		hr = S_OK;
	LeaveCriticalSection(&g_StaticsCreationDeletion);
	return hr;
}


// This is called only if this DLL is treated as a NON COM DLL
// It is the inverse operation of AllocateDLLResources()
HRESULT ReleaseDLLResources()
{
	EnterCriticalSection(&g_StaticsCreationDeletion);
	if(g_bGlobalsInitialized)
	{
		// Decrement the object count even though this isnt a COM call
		// The reason is described in the AllocateDLLResources() call
		InterlockedDecrement(&g_cObj);

		if(g_pObjectFactory)
		{
			g_pObjectFactory->Release();
			g_pObjectFactory = NULL;
		}

		SysFreeString(g_strName);
		g_strName = NULL;
		SysFreeString(g_strSuperClass);
		g_strSuperClass = NULL;
		SysFreeString(g_strType);
		g_strType = NULL;
		SysFreeString(g_strClassOrigin);
		g_strClassOrigin = NULL;
		SysFreeString(g_strSize);
		g_strSize = NULL;
		SysFreeString(g_strClassName);
		g_strClassName = NULL;
		SysFreeString(g_strValueType);
		g_strValueType = NULL;
		SysFreeString(g_strToSubClass);
		g_strToSubClass = NULL;
		SysFreeString(g_strToInstance);
		g_strToInstance = NULL;
		SysFreeString(g_strAmended);
		g_strAmended = NULL;
		SysFreeString(g_strOverridable);
		g_strOverridable = NULL;
		SysFreeString(g_strArraySize);
		g_strArraySize = NULL;
		SysFreeString(g_strReferenceClass);
		g_strReferenceClass = NULL;

		g_bGlobalsInitialized = false;
	}
	LeaveCriticalSection(&g_StaticsCreationDeletion);
	return S_OK;
}

//
// Entry Points for WMI Core's implementation of IWbemObjectTextSrc
//*****************************************************************
HRESULT OpenWbemTextSource(long lFlags, ULONG uObjTextFormat)
{
	return AllocateDLLResources();
}


HRESULT CloseWbemTextSource(long lFlags, ULONG uObjTextFormat)
{
	return ReleaseDLLResources();
}

HRESULT WbemObjectToText(long lFlags, ULONG uObjTextFormat, void *pWbemContext, void *pWbemClassObject, BSTR *pstrText)
{
	if(pWbemClassObject == NULL || pstrText == NULL)
		return WBEM_E_INVALID_PARAMETER;

	// Check to see if we support this encoding format
	if(uObjTextFormat != WMI_OBJ_TEXT_CIM_DTD_2_0 &&
		uObjTextFormat != WMI_OBJ_TEXT_WMI_DTD_2_0 )
		return WBEM_E_INVALID_PARAMETER;

    HRESULT hr = E_FAIL;
    CWmiToXmlFactory oObjFactory;
	// Create an instance of the convertor
	IWbemXMLConvertor *pConvertor = NULL;
	if(SUCCEEDED(hr = oObjFactory.CreateInstance(NULL, IID_IWbemXMLConvertor, (LPVOID *)&pConvertor)))
	{
		// Create a stream
		IStream *pStream = NULL;
		if (SUCCEEDED(hr = CreateStreamOnHGlobal(NULL, TRUE, &pStream)))
		{
			// See if we need to write a VALUE.NAMEDOBJECT, VALUE.OBJECTWITHLOCALPATH or VALUE.OBJECTWITHPATH 
			// in the output. This is indicated by the "PathLevel" value in the IWbemContext object, if any
			int iValueTagToWrite = -1;
			if(pWbemContext)
			{
				VARIANT vPathLevel;
				VariantInit(&vPathLevel);
				if(SUCCEEDED(((IWbemContext *)pWbemContext)->GetValue(L"PathLevel", 0, &vPathLevel) ) && vPathLevel.vt != VT_NULL)
				{
					if(vPathLevel.lVal<0 || vPathLevel.lVal>3)
						hr = WBEM_E_INVALID_PARAMETER;

					iValueTagToWrite = vPathLevel.lVal;
					VariantClear(&vPathLevel);
				}
			}

			if(SUCCEEDED(hr))
			{
				switch(iValueTagToWrite)
				{
					case 1: pStream->Write ((void const *)L"<VALUE.NAMEDOBJECT>", wcslen (L"<VALUE.NAMEDOBJECT>") * sizeof (OLECHAR), NULL);break;
					case 2: pStream->Write ((void const *)L"<VALUE.OBJECTWITHLOCALPATH>", wcslen (L"<VALUE.OBJECTWITHLOCALPATH>") * sizeof (OLECHAR), NULL);break;
					case 3: pStream->Write ((void const *)L"<VALUE.OBJECTWITHPATH>", wcslen (L"<VALUE.OBJECTWITHPATH>") * sizeof (OLECHAR), NULL);break;
				}

				// Do the conversion
				if(SUCCEEDED(hr = pConvertor->MapObjectToXML((IWbemClassObject *)pWbemClassObject, NULL, 0,
					(IWbemContext *)pWbemContext, pStream, NULL)))
				{
					// Terminate with the correct tag
					switch(iValueTagToWrite)
					{
						case 1: pStream->Write ((void const *)L"</VALUE.NAMEDOBJECT>", wcslen (L"</VALUE.NAMEDOBJECT>") * sizeof (OLECHAR), NULL);break;
						case 2: pStream->Write ((void const *)L"</VALUE.OBJECTWITHLOCALPATH>", wcslen (L"</VALUE.OBJECTWITHLOCALPATH>") * sizeof (OLECHAR), NULL);break;
						case 3: pStream->Write ((void const *)L"</VALUE.OBJECTWITHPATH>", wcslen (L"</VALUE.OBJECTWITHPATH>") * sizeof (OLECHAR), NULL);break;
					}

					// Get the data from the stream
					LARGE_INTEGER	offset;
					offset.LowPart = offset.HighPart = 0;
					if(SUCCEEDED(hr = pStream->Seek (offset, STREAM_SEEK_SET, NULL)))
					{
						STATSTG statstg;
						if (SUCCEEDED(hr = pStream->Stat(&statstg, STATFLAG_NONAME)))
						{
							ULONG cbSize = (statstg.cbSize).LowPart;
							WCHAR *pText = NULL;

							// Convert the data to a BSTR
							if(pText = new WCHAR [(cbSize/2)])
							{
								if (SUCCEEDED(hr = pStream->Read(pText, cbSize, NULL)))
								{
									*pstrText = NULL;
									if(*pstrText = SysAllocStringLen(pText, cbSize/2))
									{
										hr = S_OK;
									}
									else
										hr = E_OUTOFMEMORY;
								}
								delete [] pText;
							}
						}
					}
				}
			}
			pStream->Release();
		}

		pConvertor->Release();
	}
	return hr;
}

HRESULT TextToWbemObject(long lFlags, ULONG uObjTextFormat, void *pWbemContext, BSTR strText, void **ppWbemClassObject)
{
	return WBEM_E_METHOD_NOT_IMPLEMENTED;

	/* Conversion to Text to Wbem Object has been cut from the WHistler Feature List and hence commented out 
	if(ppWbemClassObject == NULL )
		return WBEM_E_INVALID_PARAMETER;

	// Check to see if we support this encoding format
	if(uObjTextFormat != WMI_OBJ_TEXT_CIM_DTD_2_0 &&
		uObjTextFormat != WMI_OBJ_TEXT_WMI_DTD_2_0 )
		return WBEM_E_INVALID_PARAMETER;

	// See if we should allow WMI extensions
	bool bAllowWMIExtensions = false;
	if(uObjTextFormat == WMI_OBJ_TEXT_WMI_DTD_2_0)
		bAllowWMIExtensions = true;

	HRESULT hr = E_FAIL;
	// Create an XML document for the body
	//==============================
	IXMLDOMDocument *pDocument = NULL;
	if(SUCCEEDED(hr = CoCreateInstance(CLSID_DOMDocument, NULL, CLSCTX_INPROC_SERVER,
								IID_IXMLDOMDocument, (LPVOID *)&pDocument)))
	{
		VARIANT_BOOL bParse = VARIANT_FALSE;
		if(SUCCEEDED(hr = pDocument->loadXML(strText, &bParse)))
		{
			if(bParse == VARIANT_TRUE)
			{
				// Get the top level element
				IXMLDOMElement *pDocElement = NULL;
				if(SUCCEEDED(hr = pDocument->get_documentElement(&pDocElement)))
				{
					BSTR strDocName = NULL;
					if(SUCCEEDED(pDocElement->get_nodeName(&strDocName)))
					{
						if(_wcsicmp(strDocName, L"CLASS") == 0)
							hr = CXml2Wmi::MapClass(pDocElement, (IWbemClassObject **)ppWbemClassObject, NULL, NULL, false, bAllowWMIExtensions);
						else if(_wcsicmp(strDocName, L"INSTANCE") == 0)
							hr = CXml2Wmi::MapInstance(pDocElement, (IWbemClassObject **)ppWbemClassObject, NULL, NULL, bAllowWMIExtensions);
						else 
							hr = WBEM_E_INVALID_SYNTAX;
						SysFreeString(strDocName);
					}
					else
						hr = WBEM_E_INVALID_SYNTAX;
					pDocElement->Release();
				}
				else
					hr = WBEM_E_FAILED;
			}
			else
			{
				// RAJESHR - This is debugging code to be removed
				IXMLDOMParseError *pError = NULL;
				if(SUCCEEDED(pDocument->get_parseError(&pError)))
				{
					LONG errorCode = 0;
					pError->get_errorCode(&errorCode);
					LONG line=0, linepos=0;
					BSTR reason=NULL, srcText = NULL;
					if(SUCCEEDED(pError->get_line(&line)) &&
						SUCCEEDED(pError->get_linepos(&linepos)) &&
						SUCCEEDED(pError->get_reason(&reason)) &&
						SUCCEEDED(pError->get_srcText(&srcText)))
					{
					}
					pError->Release();
					if(reason)
						SysFreeString(reason);
					if(srcText)
						SysFreeString(srcText);
				}
				hr = WBEM_E_INVALID_SYNTAX;
			}
		}
		else
			hr = WBEM_E_INVALID_SYNTAX;
		pDocument->Release();
	}
	return hr;
	*/
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\xmltransport\server\wmi2xml\classfac.h ===
//***************************************************************************
//
// Copyright (c) 1997-1999 Microsoft Corporation
//
//  classfac.h
//
//  alanbos  13-Feb-98   Created.
//
//  Class factory interface.
//
//***************************************************************************

#ifndef _CLASSFAC_H_
#define _CLASSFAC_H_

typedef LPVOID * PPVOID;

// These variables keep track of when the module can be unloaded

extern long       g_cObj;
extern long       g_cLock;

//***************************************************************************
//
//  CLASS NAME:
//
//  CXMLTFactory
//
//  DESCRIPTION:
//
//
//***************************************************************************

class CWmiToXmlFactory : public IClassFactory
{
protected:
	long           m_cRef;

public:

    CWmiToXmlFactory(void);
    ~CWmiToXmlFactory(void);
    
    //IUnknown members
	STDMETHODIMP         QueryInterface(REFIID, LPVOID*);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    //IClassFactory members
	STDMETHODIMP         CreateInstance(LPUNKNOWN, REFIID, LPVOID*);
	STDMETHODIMP         LockServer(BOOL);
};


/* Conversion to Text to Wbem Object has been cut from the WHistler Feature List and hence commented out 

// ***************************************************************************
//
//  CLASS NAME:
//
//  CXMLTFactory
//
//  DESCRIPTION:
//
//
// ***************************************************************************

class CXmlToWmiFactory : public IClassFactory
{
protected:
	long           m_cRef;

public:

    CXmlToWmiFactory(void);
    ~CXmlToWmiFactory(void);
    
    //IUnknown members
	STDMETHODIMP         QueryInterface(REFIID, LPVOID*);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    //IClassFactory members
	STDMETHODIMP         CreateInstance(LPUNKNOWN, REFIID, LPVOID*);
	STDMETHODIMP         LockServer(BOOL);
};

*/
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\xmltransport\server\wmi2xml\precomp.h ===
#include <tchar.h>
#include <stdio.h>
#include <windows.h>
#include <initguid.h>
#include <objbase.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\xmltransport\server\wmi2xml\tests\makefile.inc ===
############################################################################
#
#   Copyright (C) 1999, Microsoft Corporation.
#
#   All rights reserved.
#
############################################################################

!INCLUDE $(_NTDRIVE)$(_NTROOT)\WMI\COMMON\makefile.cmn
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\xmltransport\server\wmifilt\makefile.inc ===
############################################################################
#
#   Copyright (C) 1999, Microsoft Corporation.
#
#   All rights reserved.
#
############################################################################

!INCLUDE $(_NTDRIVE)$(_NTROOT)\WMI\COMMON\makefile.cmn
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\xmltransport\server\wmi2xml\wmi2xml.cpp ===
//***************************************************************************
//
//  (c) 1998 by Microsoft Corporation
//
//  WBEM2XML.CPP
//
//  alanbos  18-Feb-98   Created.
//
//  The WBEM -> XML translator
//
//***************************************************************************

#include "precomp.h"
#include <wbemidl.h>

#include <genlex.h>
#include <opathlex.h>
#include <objpath.h>

#include "wmiconv.h"
#include "wmi2xml.h"

// This is the set of the names of properties that the control
// looks for in an IWbemContext object for modifying its output
const LPCWSTR CWmiToXml::s_wmiToXmlArgs[] =
{
	L"AllowWMIExtensions", // VT_BOOL - self-explanatory
	L"PathLevel", // VT_I4 see typedef enum PathLevel in wmi2xml.h
	L"IncludeQualifiers", // VT_BOOL - self-explanatory
	L"IncludeClassOrigin", // VT_BOOL  - self-explanatory
	L"LocalOnly", // VT_BOOL - local elements (methods, properties, qualifiers) are mapped.
	L"ExcludeSystemProperties", // VT_BOOL - Excludes any WMI System Properties
};


static OLECHAR *CDATASTART = OLESTR("<![CDATA[");
static OLECHAR *CDATAEND = OLESTR("]]>");
static OLECHAR *AMPERSAND = OLESTR("&amp;");
static OLECHAR *LEFTCHEVRON = OLESTR("&lt;");
static OLECHAR *RIGHTCHEVRON = OLESTR("&gt;");
static BYTE XMLNEWLINE [] = { 0x0D, 0x00, 0x0A, 0x00 };
extern long g_cObj;

CWmiToXml::CWmiToXml()
{
	m_cRef = 0;
	m_iPathLevel = pathLevelAnonymous; // RAJESHR - Is this a good default
	m_bAllowWMIExtensions = VARIANT_TRUE;
	m_bLocalOnly = VARIANT_FALSE; // RAJESHR - Change this when core team allows us to set __RELPATH
	m_iQualifierFilter = wmiXMLQualifierFilterNone; 
	m_iClassOriginFilter = wmiXMLClassOriginFilterAll;
	m_bExcludeSystemProperties = VARIANT_FALSE;
    InterlockedIncrement(&g_cObj);
}

//***************************************************************************
//
//  CWmiToXml::~CWmiToXml
//
//  DESCRIPTION:
//
//  Destructor.
//
//***************************************************************************

CWmiToXml::~CWmiToXml(void)
{
    InterlockedDecrement(&g_cObj);
}

//***************************************************************************
// HRESULT CWmiToXml::QueryInterface
// long CWmiToXml::AddRef
// long CWmiToXml::Release
//
// DESCRIPTION:
//
// Standard Com IUNKNOWN functions.
//
//***************************************************************************

STDMETHODIMP CWmiToXml::QueryInterface (

	IN REFIID riid,
    OUT LPVOID *ppv
)
{
    *ppv=NULL;

    if (IID_IUnknown==riid)
		*ppv = reinterpret_cast<IUnknown*>(this);
	else if (IID_IWbemXMLConvertor==riid)
		*ppv = reinterpret_cast<IWbemXMLConvertor*>(this);

    if (NULL!=*ppv)
    {
        ((LPUNKNOWN)*ppv)->AddRef();
        return NOERROR;
    }

    return ResultFromScode(E_NOINTERFACE);
}

STDMETHODIMP_(ULONG) CWmiToXml::AddRef(void)
{
    InterlockedIncrement(&m_cRef);
    return m_cRef;
}

STDMETHODIMP_(ULONG) CWmiToXml::Release(void)
{
    InterlockedDecrement(&m_cRef);
    if (0L!=m_cRef)
        return m_cRef;
    delete this;
    return 0;
}


/* 
* This function takes in an IWbemClassObject that represents a Class and
* produces a <CLASS> element in the outputstream
*/
STDMETHODIMP CWmiToXml::MapClass (IStream *pOutputStream, IWbemClassObject *pObject, IWbemQualifierSet *pQualSet, BSTR *ppPropertyList, DWORD dwNumProperties, BSTR strClassBasis)
{
	HRESULT hr = WBEM_E_FAILED;

	long flav = 0;
	VARIANT var;

	// Write the CLASS tag and its attributes
	//===========================================
	WRITEBSTR( OLESTR("<CLASS NAME=\""))

	// Write the CLASSNAME
	VariantInit (&var);
	if (WBEM_S_NO_ERROR == pObject->Get(L"__CLASS", 0, &var, NULL, &flav))
	{
		if ((VT_BSTR == var.vt) && (NULL != var.bstrVal) && (wcslen (var.bstrVal) > 0))
			WRITEBSTR( var.bstrVal)
	}
	VariantClear (&var);
	WRITEBSTR( OLESTR("\""))

	// Write the SUPERCLASS if specified
	VariantInit (&var);
	if (WBEM_S_NO_ERROR == pObject->Get(L"__SUPERCLASS", 0, &var, NULL, &flav))
	{
		if ((VT_BSTR == var.vt) && (NULL != var.bstrVal) && (wcslen (var.bstrVal) > 0))
		{
			WRITEBSTR( OLESTR(" SUPERCLASS=\""))
			WRITEBSTR( var.bstrVal)
			WRITEBSTR( OLESTR("\""))
		}
	}
	VariantClear (&var);
	WRITEBSTR( OLESTR(">"))
	WRITENEWLINE

	// Map the Qualifiers of the class
	if (pQualSet)
		hr = MapQualifiers (pOutputStream, pQualSet);
	else
		hr = S_OK;

	// Map the Properties
	if (SUCCEEDED(hr))
		hr = MapProperties(pOutputStream, pObject, ppPropertyList, dwNumProperties, strClassBasis, true);

	// Map the Methods
	if (SUCCEEDED(hr))
		hr = MapMethods (pOutputStream, pObject);

	// Terminate the CLASS element
	WRITEBSTR( OLESTR("</CLASS>"))
	WRITENEWLINE

	return hr;
}

STDMETHODIMP CWmiToXml::MapClassPath (IStream *pOutputStream, ParsedObjectPath *pParsedPath)
{
	HRESULT hr = E_FAIL;
	WRITEBSTR( OLESTR("<CLASSPATH>"))
	WRITENEWLINE
	if(SUCCEEDED(hr = MapNamespacePath (pOutputStream, pParsedPath)))
	{
		WRITENEWLINE
		hr = MapClassName (pOutputStream, pParsedPath->m_pClass);
	}
	WRITEBSTR( OLESTR("</CLASSPATH>"))
	return hr;
}

STDMETHODIMP CWmiToXml::MapLocalClassPath (IStream *pOutputStream, ParsedObjectPath *pParsedPath)
{
	HRESULT hr = E_FAIL;
	WRITEBSTR( OLESTR("<LOCALCLASSPATH>"))
	WRITENEWLINE
	if(SUCCEEDED(hr = MapLocalNamespacePath (pOutputStream, pParsedPath)))
	{
		WRITENEWLINE
		hr = MapClassName (pOutputStream, pParsedPath->m_pClass);
	}
	WRITEBSTR( OLESTR("</LOCALCLASSPATH>"))
	return hr;
}

STDMETHODIMP CWmiToXml::MapClassName (IStream *pOutputStream, BSTR bsClassName)
{
	WRITEBSTR( OLESTR("<CLASSNAME NAME=\""))
	WRITEBSTR( bsClassName)
	WRITEBSTR( OLESTR("\"/>"))
	return S_OK;
}

/* 
* This function takes in an IWbemClassObject that represents an Instance and
* produces an <INSTANCE> element in the outputstream
*/
STDMETHODIMP CWmiToXml::MapInstance (IStream *pOutputStream, IWbemClassObject *pObject, IWbemQualifierSet *pQualSet, BSTR *ppPropertyList, DWORD dwNumProperties, BSTR strClassBasis)
{
	HRESULT hr = WBEM_E_FAILED;

	// Write the beginning of the INSTANCE Tag and its attributes
	//===========================================================
	WRITEBSTR( OLESTR("<INSTANCE CLASSNAME=\""))
	// Write the CLASSNAME
	long flav = 0;
	VARIANT var;
	VariantInit (&var);
	if (WBEM_S_NO_ERROR == pObject->Get(L"__CLASS", 0, &var, NULL, &flav))
	{
		if ((VT_BSTR == var.vt) && (NULL != var.bstrVal) && (wcslen (var.bstrVal) > 0))
		{
			WRITEBSTR( var.bstrVal)
			WRITEBSTR( OLESTR("\">"))
			WRITENEWLINE
		}
	}
	VariantClear (&var);

	// Map Instance Qualifiers if any
	if (pQualSet)
		hr = MapQualifiers (pOutputStream, pQualSet);
	else
		hr = S_OK;

	// Map the properties of the instance
	if(SUCCEEDED(hr))
			hr = MapProperties (pOutputStream, pObject, ppPropertyList, dwNumProperties, strClassBasis, false);

	// Terminate the INSTANCE element
	WRITEBSTR( OLESTR("</INSTANCE>"))
	WRITENEWLINE

	return hr;
}

STDMETHODIMP CWmiToXml::MapInstancePath (IStream *pOutputStream, ParsedObjectPath *pParsedPath)
{
	WRITEBSTR( OLESTR("<INSTANCEPATH>"))
	WRITENEWLINE
	HRESULT hr = E_FAIL;
	if(SUCCEEDED(hr = MapNamespacePath (pOutputStream, pParsedPath)))
	{
		WRITENEWLINE
		hr = MapInstanceName (pOutputStream, pParsedPath);
		WRITENEWLINE
	}
	WRITEBSTR( OLESTR("</INSTANCEPATH>"))
	return hr;
}

STDMETHODIMP CWmiToXml::MapLocalInstancePath (IStream *pOutputStream, ParsedObjectPath *pParsedPath)
{
	WRITEBSTR( OLESTR("<LOCALINSTANCEPATH>"))
	WRITENEWLINE
	HRESULT hr = E_FAIL;
	if(SUCCEEDED(hr = MapLocalNamespacePath (pOutputStream, pParsedPath)))
	{
		WRITENEWLINE
		hr = MapInstanceName (pOutputStream, pParsedPath);
		WRITENEWLINE
	}
	WRITEBSTR( OLESTR("</LOCALINSTANCEPATH>"))
	return hr;
}

STDMETHODIMP CWmiToXml::MapInstanceName (IStream *pOutputStream, ParsedObjectPath *pParsedPath)
{
	WRITEBSTR( OLESTR("<INSTANCENAME CLASSNAME=\""))
	WRITEBSTR( pParsedPath->m_pClass)
	WRITEBSTR( OLESTR("\">"))
	WRITENEWLINE

	// Now write the key bindings - only if not singleton
	if (!(pParsedPath->m_bSingletonObj))
	{
		if ((1 == pParsedPath->m_dwNumKeys) &&
			!((pParsedPath->m_paKeys [0])->m_pName))
		{
			// Use the short form
			WRITENEWLINE
			MapKeyValue (pOutputStream, (pParsedPath->m_paKeys [0])->m_vValue);
			WRITENEWLINE
		}
		else
		{
			// Write each key-value binding
			//=============================
			for (DWORD numKey = 0; numKey < pParsedPath->m_dwNumKeys; numKey++)
			{
				WRITEBSTR( OLESTR("<KEYBINDING "))

				// Write the key name
				WRITEBSTR( OLESTR(" NAME=\""))
				WRITEBSTR( (pParsedPath->m_paKeys [numKey])->m_pName)
				WRITEBSTR( OLESTR("\">"))
				WRITENEWLINE

				// Write the key value
				MapKeyValue (pOutputStream, (pParsedPath->m_paKeys [numKey])->m_vValue);
				WRITENEWLINE

				WRITEBSTR( OLESTR("</KEYBINDING>"))
				WRITENEWLINE
			}
		}
	}
	else
	{
		// Nothing to be done here, since the spec says that
		// INSTANCENAMEs without any keybindings are assumed to be singleton instances
	}

	WRITEBSTR( OLESTR("</INSTANCENAME>"))
	return S_OK;
}

STDMETHODIMP CWmiToXml::MapNamespacePath (IStream *pOutputStream, BSTR bsNamespacePath)
{
	CObjectPathParser pathParser (e_ParserAcceptRelativeNamespace);
	ParsedObjectPath  *pParsedPath = NULL;
	pathParser.Parse (bsNamespacePath, &pParsedPath) ;

	HRESULT hr = E_FAIL;
	if (pParsedPath)
	{
		hr = MapNamespacePath (pOutputStream, pParsedPath);
		pathParser.Free(pParsedPath);
	}
	else
		hr = WBEM_E_INVALID_SYNTAX;

	return hr;
}

STDMETHODIMP CWmiToXml::MapNamespacePath (IStream *pOutputStream, ParsedObjectPath *pParsedPath)
{
	WRITEBSTR( OLESTR("<NAMESPACEPATH>"))
	WRITENEWLINE
	WRITEBSTR( OLESTR("<HOST>"))

	if (pParsedPath->m_pServer)
		WRITEWSTR( pParsedPath->m_pServer)
	else
		WRITEBSTR( OLESTR("."))

	WRITEBSTR( OLESTR("</HOST>"))
	WRITENEWLINE

	// Map the local namespaces
	HRESULT hr = MapLocalNamespacePath (pOutputStream, pParsedPath);

	WRITEBSTR( OLESTR("</NAMESPACEPATH>"))

	return hr;
}

STDMETHODIMP CWmiToXml::MapLocalNamespacePath (IStream *pOutputStream, BSTR bsNamespacePath)
{
	CObjectPathParser pathParser (e_ParserAcceptRelativeNamespace);
	ParsedObjectPath  *pParsedPath = NULL;
	pathParser.Parse (bsNamespacePath, &pParsedPath) ;

	HRESULT hr = E_FAIL;
	if (pParsedPath)
	{
		hr = MapLocalNamespacePath (pOutputStream, pParsedPath);
		pathParser.Free(pParsedPath);
	}
	else
		hr = E_FAIL;

	return hr;
}

STDMETHODIMP CWmiToXml::MapLocalNamespacePath (IStream *pOutputStream, ParsedObjectPath *pObjectPath)
{
	WRITEBSTR( OLESTR("<LOCALNAMESPACEPATH>"))
	WRITENEWLINE

	// Map each of the namespace components
	for (DWORD dwIndex = 0; dwIndex < pObjectPath->m_dwNumNamespaces; dwIndex++)
	{
		WRITEBSTR( OLESTR("<NAMESPACE NAME=\""))
		WRITEWSTR( pObjectPath->m_paNamespaces [dwIndex])
		WRITEBSTR( OLESTR("\"/>"))
		WRITENEWLINE
	}

	WRITEBSTR( OLESTR("</LOCALNAMESPACEPATH>"))

	return WBEM_S_NO_ERROR;
}

STDMETHODIMP CWmiToXml::MapReferenceProperty (IStream *pOutputStream, IWbemClassObject *pObject, BSTR name, VARIANT &var, bool isArray, long flavor, bool bIsClass)
{
	// CIM does not allow array references, only scalar references
	if(isArray && !m_bAllowWMIExtensions)
		return S_OK;

	HRESULT hr = WBEM_S_NO_ERROR;

	IWbemQualifierSet *pQualSet = NULL;
	if (WBEM_S_NO_ERROR == pObject->GetPropertyQualifierSet (name, &pQualSet))
	{
		// The property name
		if (isArray)
			WRITEBSTR( OLESTR("<PROPERTY.REFARRAY NAME=\""))
		else
			WRITEBSTR( OLESTR("<PROPERTY.REFERENCE NAME=\""))

		// The property name
		WRITEBSTR( name)
		WRITEBSTR( OLESTR("\""))

		// The originating class of this property
		BSTR propertyOrigin = NULL;

		if (WBEM_S_NO_ERROR == pObject->GetPropertyOrigin (name, &propertyOrigin))
		{
			MapClassOrigin (pOutputStream, propertyOrigin, bIsClass);
			SysFreeString(propertyOrigin);
			hr = S_OK;
		}

		if(SUCCEEDED(hr))
			MapLocal (pOutputStream, flavor);

		// The strong class of this property
		if(SUCCEEDED(hr))
			MapStrongType (pOutputStream, pQualSet);

		// Size of array
		if(SUCCEEDED(hr) && isArray)
			MapArraySize (pOutputStream, pQualSet);

		WRITEBSTR( OLESTR(">"))
		WRITENEWLINE

		// Map the qualifiers
		if(SUCCEEDED(hr))
			hr = MapQualifiers (pOutputStream, pQualSet);

		if(SUCCEEDED(hr))
			hr = MapReferenceValue (pOutputStream, isArray, var);

		if (isArray)
			WRITEBSTR( OLESTR("</PROPERTY.REFARRAY>"))
		else
			WRITEBSTR( OLESTR("</PROPERTY.REFERENCE>"))
		pQualSet->Release ();
	}

	return hr;
}

//***************************************************************************
//
//  CWmiToXml::IsReference
//
//  DESCRIPTION:
//
//		The purpose of this function is to examine a single
//		VARIANT value and determine whether it represents a
//		reference or not.
//
//		This is required because when mapping from a reference
//		property value we may encounter nested references within
//		the object path.  Unfortunately the object path syntax
//		is such that we cannot be certain whether a key value
//		represents a reference or a string, datetime or char
//		property.  (This is because a textual object path does
//		not contain as much information as its XML equivalent.)
//
//		This function performs a heuristic test on the value to
//		determine whether it is a reference.
//
//***************************************************************************

bool CWmiToXml::IsReference (VARIANT &var, ParsedObjectPath **ppObjectPath)
{
	ParsedObjectPath *pObjectPath = NULL;
	*ppObjectPath = NULL;
	bool isValidPath = false;

	// RAJESHR - could get the class of which this is a property value
	// and retrieve the type of the current key property - that would
	// be the authoritative answer but it doesn't come cheap.

	if ((VT_BSTR == var.vt) && (NULL != var.bstrVal) && (wcslen (var.bstrVal) > 0))
	{

		// Parse the object path
		CObjectPathParser	parser (e_ParserAcceptRelativeNamespace);
		BOOL status = parser.Parse (var.bstrVal, &pObjectPath);

		if ((0 == status) && pObjectPath)
		{
			// If it's an instance path we should be OK
			if (pObjectPath->IsInstance ())
				isValidPath = true;
			else if (pObjectPath->IsClass ())
			{
				// Hmmm - could be a classpath.  If we have a server
				// and some namespaces that would be a lot better

				if (pObjectPath->m_pServer && (0 < pObjectPath->m_dwNumNamespaces))
				{
					// RAJESHR - At this point we could assume that it is a reference
					// However, we've found a case in PCHealth where they do a
					// select * from Win32_ProgramGroup and it so happens that
					// one of the properties has a value "ntdev\rajeshr:Accessories"
					// which is CIM_STRING but actually matches a WMI class path
					// So, we need to try to connect ot this machine or namespace here
					// to check whether it is a classpath.

				}
				else
				{
					// A potential local class path
					// RAJESHR - try grabbing the class to see if it exists in
					// the current namespace.
				}
			}
		}
		// Apply one more heuristic - see whether it begins with "umi:"
		else
		{
			if(_wcsnicmp(var.bstrVal, L"umi:", wcslen(L"umi:")) == 0)
				isValidPath = true;
		}

		if (isValidPath)
			*ppObjectPath = pObjectPath;
		else
		{
			// Reject for now - too ambiguous
			parser.Free(pObjectPath);
			pObjectPath = NULL;
		}
	}

	return isValidPath;
}

HRESULT CWmiToXml::MapReferenceValue (IStream *pOutputStream, bool isArray, VARIANT &var)
{
	HRESULT hr = WBEM_S_NO_ERROR;

	if (VT_NULL == var.vt)
		return WBEM_S_NO_ERROR;

	if (isArray)
	{
		long uBound = 0;
		if (FAILED(SafeArrayGetUBound (var.parray, 1, &uBound)))
			return WBEM_E_FAILED;

		WRITEBSTR( OLESTR("<VALUE.REFARRAY>"))
		for (long i = 0; i<=uBound; i++)
		{
			BSTR pNextElement = NULL;
			if(SUCCEEDED(hr = SafeArrayGetElement(var.parray, (LONG *)&i, (LPVOID )&pNextElement )))
			{
				// Map the value - this will be a classpath or instancepath
				if ((NULL != pNextElement) && (wcslen (pNextElement) > 0))
				{
					// Parse the object path
					// We have 2 possibilities here
					// 1. The path is a Nova style path in which case it can be transformed into
					//		a DMTF style VALUE.REFERENCE
					// 2. It is a Whistler style scoped path or an UMI path. In this case,
					//		we have to transform it into a VALUE element (inside a VALUE.REFERENCE element)
					//		with the exact string representation of the path
					// The second vase is indicated it the parsing fails.
					CObjectPathParser	parser (e_ParserAcceptRelativeNamespace);
					ParsedObjectPath  *pObjectPath = NULL;
					BOOL status = parser.Parse (pNextElement, &pObjectPath) ;

					// pObjectPath might be NULL here, in which case it falls under category 2 above
					MapReferenceValue (pOutputStream, pObjectPath, pNextElement);

					if (pObjectPath)
						parser.Free(pObjectPath);
				}

				SysFreeString(pNextElement);
			}
		}
		WRITEBSTR( OLESTR("</VALUE.REFARRAY>"))
	}
	else
	{
		// Map the value - this will be a classpath or instancepath
		if ((VT_BSTR == var.vt) && (NULL != var.bstrVal) && (wcslen (var.bstrVal) > 0))
		{
			// Parse the object path
			CObjectPathParser	parser (e_ParserAcceptRelativeNamespace);
			ParsedObjectPath  *pObjectPath = NULL;
			BOOL status = parser.Parse (var.bstrVal, &pObjectPath) ;

			// We have 2 possibilities here
			// 1. The path is a Nova style path in which case it can be transformed into
			//		a DMTF style VALUE.REFERENCE
			// 2. It is a Whistler style scoped path or an UMI path. In this case,
			//		we have to transform it into a VALUE element (inside a VALUE.REFERENCE element)
			//		with the exact string representation of the path
			// The second vase is indicated it the parsing fails.
			MapReferenceValue (pOutputStream, pObjectPath, var.bstrVal);

			if (pObjectPath)
				parser.Free(pObjectPath);
		}
	}

	return hr;
}

// This function maps a reference value to XML
// We have 2 possibilities for the path in the reference value :
// 1. The path is a Nova style path in which case it can be transformed into
//		a DMTF style VALUE.REFERENCE
// 2. It is a Whistler style scoped path or an UMI path. In this case,
//		we have to transform it into a VALUE element (inside a VALUE.REFERENCE element)
//		with the exact string representation of the path
// The second vase is indicated by a NULL value for pObjectPath, in which case, we just
// use the contents of strPath
void CWmiToXml::MapReferenceValue (IStream *pOutputStream, ParsedObjectPath  *pObjectPath, BSTR strPath)
{
	WRITEBSTR( OLESTR("<VALUE.REFERENCE>"))
	WRITENEWLINE

	// Is it a Nova-style or DMTF style path?
	if(pObjectPath)
	{
		BOOL bIsAbsolutePath = (NULL != pObjectPath->m_pServer);
		BOOL bIsRelativePath = FALSE;

		if (!bIsAbsolutePath)
			bIsRelativePath = (0 < pObjectPath->m_dwNumNamespaces);

		// Is this is a class or is it an instance?
		if (pObjectPath->IsClass ())
		{
			if (bIsAbsolutePath)
				MapClassPath (pOutputStream, pObjectPath);
			else if (bIsRelativePath)
				MapLocalClassPath (pOutputStream, pObjectPath);
			else
				MapClassName (pOutputStream, pObjectPath->m_pClass);
		}
		else if (pObjectPath->IsInstance ())
		{
			if (bIsAbsolutePath)
				MapInstancePath (pOutputStream, pObjectPath);
			else if (bIsRelativePath)
				MapLocalInstancePath (pOutputStream, pObjectPath);
			else
				MapInstanceName (pOutputStream, pObjectPath);
		}
	}
	else // Ugh it is a Whistler or WMI Path
	{
		WRITEBSTR( OLESTR("<VALUE>"))
		MapStringValue(pOutputStream, strPath);
		WRITEBSTR( OLESTR("</VALUE>"))
	}

	WRITENEWLINE
	WRITEBSTR( OLESTR("</VALUE.REFERENCE>"))
}

STDMETHODIMP CWmiToXml::MapQualifiers (IStream *pOutputStream, 
			IWbemQualifierSet *pQualSet, IWbemQualifierSet *pQualSet2)
{
	if (wmiXMLQualifierFilterNone != m_iQualifierFilter)
	{
		// Map the requested filter to the flags value - default is ALL
		LONG lFlags = 0;
		if (wmiXMLQualifierFilterLocal == m_iQualifierFilter)
			lFlags = WBEM_FLAG_LOCAL_ONLY;
		else if (wmiXMLQualifierFilterPropagated == m_iQualifierFilter)
			lFlags = WBEM_FLAG_PROPAGATED_ONLY;
		else if (wmiXMLQualifierFilterAll == m_iQualifierFilter)
		{
			if(m_bLocalOnly == VARIANT_TRUE)
				lFlags = WBEM_FLAG_LOCAL_ONLY;
			// Else you get all qualifiers
		}

		pQualSet->BeginEnumeration (lFlags);

		VARIANT var;
		VariantInit (&var);
		long flavor = 0;
		BSTR name = NULL;

		while (WBEM_S_NO_ERROR  == pQualSet->Next (0, &name, &var, &flavor))
		{
			MapQualifier (pOutputStream, name, flavor, var);
			SysFreeString (name);
			name = NULL;
			VariantClear (&var);
		}

		pQualSet->EndEnumeration ();

		// Now check the subsiduary set for any qualifiers not in the first set
		if (pQualSet2)
		{
			pQualSet2->BeginEnumeration (lFlags);

			while (WBEM_S_NO_ERROR == pQualSet2->Next (0, &name, &var, &flavor))
			{
				// Is this qualifier in the primary set?
				if (WBEM_E_NOT_FOUND == pQualSet->Get (name, 0, NULL, NULL))
					MapQualifier (pOutputStream, name, flavor, var);

				SysFreeString (name);
				name = NULL;
				VariantClear (&var);
			}

			pQualSet2->EndEnumeration ();
		}
	}

	return WBEM_S_NO_ERROR;
}

void CWmiToXml::MapLocal (IStream *pOutputStream, long flavor)
{
	// default is FALSE
	if (WBEM_FLAVOR_ORIGIN_PROPAGATED == (WBEM_FLAVOR_MASK_ORIGIN & flavor))
		WRITEBSTR( OLESTR(" PROPAGATED=\"true\""))
}

STDMETHODIMP CWmiToXml::MapQualifier (IStream *pOutputStream, BSTR name, long flavor, VARIANT &var)
{
	// The qualifier name
	WRITEBSTR( OLESTR("<QUALIFIER NAME=\""))
	WRITEBSTR( name)
	WRITEBSTR( OLESTR("\""))
	MapLocal (pOutputStream, flavor);

	// The qualifier CIM type
	WRITEBSTR( OLESTR(" TYPE=\""))
	switch (var.vt & ~VT_ARRAY)
	{
		case VT_I4:
			WRITEBSTR( OLESTR("sint32"))
			break;

		case VT_R8:
			WRITEBSTR( OLESTR("real64"))
			break;

		case VT_BOOL:
			WRITEBSTR( OLESTR("boolean"))
			break;

		case VT_BSTR:
			WRITEBSTR( OLESTR("string"))
			break;
	}

	WRITEBSTR( OLESTR("\""))

	// Whether the qualifier is overridable - default is TRUE
	if (WBEM_FLAVOR_NOT_OVERRIDABLE == (WBEM_FLAVOR_MASK_PERMISSIONS & flavor))
		WRITEBSTR( OLESTR(" OVERRIDABLE=\"false\""))

	// Whether the qualifier is propagated to subclasses - default is TRUE
	if (!(WBEM_FLAVOR_FLAG_PROPAGATE_TO_DERIVED_CLASS & flavor))
		WRITEBSTR( OLESTR(" TOSUBCLASS=\"false\""))

	// Whether the qualifier is propagated to instances - default is FALSE
	if ((WBEM_FLAVOR_FLAG_PROPAGATE_TO_INSTANCE & flavor))
		WRITEBSTR( OLESTR(" TOINSTANCE=\"true\""))


	/* RAJESHR - This change has been put off until the CIM DTD gets modified
	 * Whether the qualifier is propagated to instances - default is FALSE
	 * This is absent from the CIM DTD
	if (m_bAllowWMIExtensions && (WBEM_FLAVOR_FLAG_PROPAGATE_TO_INSTANCE & flavor))
		WRITEBSTR( OLESTR(" TOINSTANCE=\"true\""))
	*/

	// Whether the qualifier is an amended one - default is FALSE
	// This is absent from the CIM DTD
	if (m_bAllowWMIExtensions && (WBEM_FLAVOR_AMENDED & flavor))
		WRITEBSTR( OLESTR(" AMENDED=\"true\""))

	// Currently set TRANSLATABLE as "FALSE" by default. WMI does not use this flavor

	WRITEBSTR( OLESTR(">"))
	WRITENEWLINE

	// Now map the value
	MapValue (pOutputStream, var);

	WRITEBSTR( OLESTR("</QUALIFIER>"))

	return WBEM_S_NO_ERROR;
}

STDMETHODIMP CWmiToXml::MapValue (IStream *pOutputStream, VARIANT &var)
{
	if (VT_NULL == var.vt)
		return WBEM_S_NO_ERROR;

	if (var.vt & VT_ARRAY)
	{
		long uBound = 0;
		if (FAILED(SafeArrayGetUBound (var.parray, 1, &uBound)))
			return WBEM_E_FAILED;

		WRITEBSTR( OLESTR("<VALUE.ARRAY>"))

		for (long i = 0; i <= uBound; i++)
		{
			WRITEBSTR( OLESTR("<VALUE>"))

			// Write the value itself
			switch (var.vt & ~VT_ARRAY)
			{
				case VT_I4:
				{
					long val = 0;
					SafeArrayGetElement (var.parray, &i, &val);
					MapLongValue (pOutputStream, val);
				}
					break;

				case VT_R8:
				{
					double val = 0;
					SafeArrayGetElement (var.parray, &i, &val);
					MapDoubleValue (pOutputStream, val);
				}
					break;

				case VT_BOOL:
				{
					VARIANT_BOOL val = 0;
					SafeArrayGetElement (var.parray, &i, &val);
					MapBoolValue (pOutputStream, (val) ? TRUE : FALSE);
				}
					break;

				case VT_BSTR:
				{
					BSTR val = NULL;
					SafeArrayGetElement (var.parray, &i, &val);
					MapStringValue (pOutputStream, val);
					SysFreeString (val);
				}
					break;
			}
			WRITEBSTR( OLESTR("</VALUE>"))
			WRITENEWLINE
		}

		WRITEBSTR( OLESTR("</VALUE.ARRAY>"))
	}
	else
	{
		// Simple value
		WRITEBSTR( OLESTR("<VALUE>"))
		switch (var.vt)
		{
			case VT_I4:
				MapLongValue (pOutputStream, var.lVal);
				break;

			case VT_R8:
				MapDoubleValue (pOutputStream, var.dblVal);
				break;

			case VT_BOOL:
				MapBoolValue (pOutputStream, (var.boolVal) ? TRUE : FALSE);
				break;

			case VT_BSTR:
				MapStringValue (pOutputStream, var.bstrVal);
				break;
		}

		WRITEBSTR( OLESTR("</VALUE>"))
	}

	return WBEM_S_NO_ERROR;
}

// This function is used to create a KEYVALUE element
// This element, besides having the value of the property
// also has a type indicator in the form of the VALUETYPE attribute
STDMETHODIMP CWmiToXml::MapKeyValue (IStream *pOutputStream, VARIANT &var)
{
	ParsedObjectPath *pObjectPath = NULL;

	// This could be simple value or a reference value
	// Note that keys are not allowed to be arrays
	if (IsReference (var, &pObjectPath))
	{
		// If the above function returns true, then we're sure that the variant is of type VT_BSTR
		MapReferenceValue (pOutputStream, pObjectPath, var.bstrVal);
		delete pObjectPath;
	}
	else
	{
		// Simple value
		WRITEBSTR( OLESTR("<KEYVALUE"))

		switch (var.vt)
		{
			case VT_I4:
				WRITEBSTR( OLESTR(" VALUETYPE=\"numeric\">"))
				MapLongValue (pOutputStream, var.lVal);
				break;

			case VT_R8:
				WRITEBSTR( OLESTR(" VALUETYPE=\"numeric\">"))
				MapDoubleValue (pOutputStream, var.dblVal);
				break;

			case VT_BOOL:
				WRITEBSTR( OLESTR(" VALUETYPE=\"boolean\">"))
				MapBoolValue (pOutputStream, (var.boolVal) ? TRUE : FALSE);
				break;

			case VT_BSTR:
				WRITEBSTR(OLESTR(" VALUETYPE=\"string\">"))
				// RAJESHR - We assume that the object path parser will have suitably unescaped
				// the escaped characters in the object path
				// If this is not the case, then we need to unescape it manually
				MapStringValue (pOutputStream, var.bstrVal);
				break;
		}

		WRITEBSTR( OLESTR("</KEYVALUE>"))
	}

	return WBEM_S_NO_ERROR;
}

// In this function we produce PROPERTY elements for each of the properties of an IWbemClassObject
// or if a property list is specified, then only for each of the properties in that list
STDMETHODIMP CWmiToXml::MapProperties (IStream *pOutputStream, IWbemClassObject *pObject, BSTR *ppPropertyList, DWORD dwNumProperties, BSTR strClassBasis, bool bIsClass)
{
	// Check to see if a property list is specified. If so, we map only those properties
	if (dwNumProperties && ppPropertyList)
	{
		VARIANT var;
		VariantInit (&var);
		long flavor = 0;
		CIMTYPE cimtype = CIM_ILLEGAL;

		for (DWORD i = 0; i < dwNumProperties; i++)
		{
			// A class basis may be optionally specified for this class
			// this happens in case of Enumerations and we have to filter out derived class properties
			// since the DMTF concept of SHALLOW enumeration is differnet from WMI's definition
			if (PropertyDefinedForClass (pObject, ppPropertyList [i], strClassBasis))
			{
				if (WBEM_S_NO_ERROR == pObject->Get (ppPropertyList [i], 0, &var, &cimtype, &flavor))
				{
					switch (cimtype & ~CIM_FLAG_ARRAY)
					{
						case CIM_OBJECT:
							MapObjectProperty (pOutputStream, pObject, ppPropertyList [i], var, (cimtype & CIM_FLAG_ARRAY) ? TRUE : FALSE, flavor, bIsClass);
							break;

						case CIM_REFERENCE:
							MapReferenceProperty (pOutputStream, pObject, ppPropertyList [i], var, (cimtype & CIM_FLAG_ARRAY) ? TRUE : FALSE, flavor,bIsClass);
							break;

						default:
							MapProperty (pOutputStream, pObject, ppPropertyList [i], var, cimtype & ~CIM_FLAG_ARRAY,
													(cimtype & CIM_FLAG_ARRAY) ? TRUE : FALSE, flavor, bIsClass);
							break;
					}
					VariantClear (&var);
				}
			}
		}
	}
	else
	{
		// Note that we cannot set the LOCAL_ONLY flag for the enumeration since this is mutually exclusive
		// with the NONSYSTEM Flag.
		// Hence we use the property flavour to check whether it is local or not below.
		// We dont want System propertied going to DMTF servers
		if(SUCCEEDED(pObject->BeginEnumeration (
			(m_bAllowWMIExtensions == VARIANT_FALSE || m_bExcludeSystemProperties == VARIANT_TRUE)? WBEM_FLAG_NONSYSTEM_ONLY : 0)))
		{
			VARIANT var;
			VariantInit (&var);
			long flavor = 0;
			CIMTYPE cimtype = CIM_ILLEGAL;
			BSTR name = NULL;

			while (WBEM_S_NO_ERROR  == pObject->Next (0, &name, &var, &cimtype, &flavor))
			{
				// If only local properties are being asked for, then skip this if it is not local 
				// Dont skip system properties though
				if(m_bLocalOnly == VARIANT_FALSE ||
					(m_bLocalOnly == VARIANT_TRUE && 
									((flavor == WBEM_FLAVOR_ORIGIN_LOCAL) || (flavor == WBEM_FLAVOR_ORIGIN_SYSTEM))   ))
				{
					// A class basis may be optionally specified for this call
					// this happens in case of Enumerations and we have to filter out derived class properties
					// since the DMTF concept of SHALLOW enumeration is differnet from WMI's definition
					if (PropertyDefinedForClass (pObject, name,strClassBasis))
					{
						switch (cimtype & ~CIM_FLAG_ARRAY)
						{
							case CIM_OBJECT:
								MapObjectProperty (pOutputStream, pObject, name, var, (cimtype & CIM_FLAG_ARRAY) ? TRUE : FALSE, flavor, bIsClass);
								break;

							case CIM_REFERENCE:
								MapReferenceProperty (pOutputStream, pObject, name, var, (cimtype & CIM_FLAG_ARRAY) ? TRUE : FALSE, flavor, bIsClass);
								break;

							default:
								MapProperty (pOutputStream, pObject, name, var, cimtype & ~CIM_FLAG_ARRAY,
														(cimtype & CIM_FLAG_ARRAY) ? TRUE : FALSE, flavor, bIsClass);
								break;
						}
					}
				}
				SysFreeString (name);
				VariantClear (&var);
			}
		}

		pObject->EndEnumeration ();
	}
	return WBEM_S_NO_ERROR;
}

STDMETHODIMP CWmiToXml::MapProperty (IStream *pOutputStream, IWbemClassObject *pObject, BSTR name, VARIANT &var, CIMTYPE cimtype,
										BOOL isArray, long flavor, bool bIsClass)
{
	HRESULT hr = WBEM_S_NO_ERROR;
			
	// The property name
	if (isArray)
		WRITEBSTR( OLESTR("<PROPERTY.ARRAY NAME=\""))
	else
		WRITEBSTR( OLESTR("<PROPERTY NAME=\""))
	WRITEBSTR( name)
	WRITEBSTR( OLESTR("\""));
		
	// The originating class of this property
	BSTR propertyOrigin = NULL;

	if (WBEM_S_NO_ERROR == pObject->GetPropertyOrigin (name, &propertyOrigin))
	{
		MapClassOrigin (pOutputStream, propertyOrigin, bIsClass);
		SysFreeString(propertyOrigin);
	}

	MapLocal (pOutputStream, flavor);

	// The property CIM type
	hr = MapType (pOutputStream, cimtype);

	// Get the Qualifier Set of the property at this time
	// Note that system properties do not have qualifiers sets
	// Map the Array Size attribute if this is an array type
	IWbemQualifierSet *pQualSet= NULL;
	if (SUCCEEDED(hr) && (_wcsnicmp(name, L"__", 2) != 0) )
	{
		if(WBEM_S_NO_ERROR == (hr = pObject->GetPropertyQualifierSet (name, &pQualSet))) 
		{
			if (isArray)
				MapArraySize (pOutputStream, pQualSet);
		}
	}
	
	WRITEBSTR( OLESTR(">"))
	WRITENEWLINE 

	// Map the qualifiers (note that system properties have no qualifiers)
	if(SUCCEEDED(hr) && pQualSet)
		hr = MapQualifiers (pOutputStream, pQualSet);

	// Now map the value
	if(SUCCEEDED(hr))
		hr = MapValue (pOutputStream, cimtype, isArray, var);

	if (isArray)
		WRITEBSTR( OLESTR("</PROPERTY.ARRAY>"))
	else
		WRITEBSTR( OLESTR("</PROPERTY>"))

	if(pQualSet)
		pQualSet->Release ();
	
	return hr;
}

STDMETHODIMP CWmiToXml::MapObjectProperty (IStream *pOutputStream, IWbemClassObject *pObject, BSTR name, VARIANT &var,
										BOOL isArray, long flavor, bool bIsClass)
{
	HRESULT hr = WBEM_S_NO_ERROR;
	IWbemQualifierSet *pQualSet= NULL;

	/*
	 * Only map embedded objects when WMI extensions are allowed
	 */

	if (m_bAllowWMIExtensions)
	{
		if (WBEM_S_NO_ERROR == (hr = pObject->GetPropertyQualifierSet (name, &pQualSet)))
		{
			// The property name
			if (isArray)
				WRITEBSTR( OLESTR("<PROPERTY.OBJECTARRAY NAME=\""))
			else
				WRITEBSTR( OLESTR("<PROPERTY.OBJECT NAME=\""))
			WRITEBSTR( name)
			WRITEBSTR( OLESTR("\""));

			// The originating class of this property
			BSTR propertyOrigin = NULL;

			if (WBEM_S_NO_ERROR == pObject->GetPropertyOrigin (name, &propertyOrigin))
			{
				MapClassOrigin (pOutputStream, propertyOrigin, bIsClass);
				SysFreeString(propertyOrigin);
			}

			MapLocal (pOutputStream, flavor);
			MapStrongType (pOutputStream, pQualSet);

			if (isArray)
				MapArraySize (pOutputStream, pQualSet);

			WRITEBSTR( OLESTR(">"))
			WRITENEWLINE

			MapQualifiers (pOutputStream, pQualSet);

			// Now map the value
			hr = MapEmbeddedObjectValue (pOutputStream, isArray, var);

			if (isArray)
				WRITEBSTR( OLESTR("</PROPERTY.OBJECTARRAY>"))
			else
				WRITEBSTR( OLESTR("</PROPERTY.OBJECT>"))

			pQualSet->Release ();
		}
	}

	return hr;
}


void CWmiToXml::MapArraySize (IStream *pOutputStream, IWbemQualifierSet *pQualSet)
{
	// RAJESHR - RAID 29167 covers the fact that case (1) below
	// should not be valid (but this is what the MOF compiler
	// does) - need to change the code when that bug is fixed
	// to be more strict.

	/*
	 * We defined the ARRAYSIZE element if the qualifier set
	 * satisfies one of the following constraints:
	 *
	 * 1) MAX is present with a positive integer value, and MIN
	 *    is absent.
	 *
	 * 2) MAX and MIN are both present, with the same positive
	 *    integer value.
	 */

	VARIANT var;
	VariantInit (&var);
	BOOL	isFixed = FALSE;

	if (WBEM_S_NO_ERROR == pQualSet->Get(L"MAX", 0, &var, NULL))
	{
		if ((V_VT(&var) == VT_I4) && (0 < var.lVal))
		{
			// Promising - have a candidate MAX value.  Now
			// look for a MIN
			long arraySize = var.lVal;

			if (WBEM_S_NO_ERROR == pQualSet->Get(L"MIN", 0, &var, NULL))
			{
				if ((V_VT(&var) == VT_I4) && (0 < var.lVal))
				{
					// Have a value - check if it's the same as MAX

					isFixed = (arraySize == var.lVal);
				}
			}
			else
				isFixed = TRUE;		// NO MIN only max
		}
	}

	if (isFixed)
	{
		WRITEBSTR( OLESTR(" ARRAYSIZE=\""))
		MapLongValue (pOutputStream, var.lVal);
		WRITEBSTR( OLESTR("\""))
	}

	VariantClear (&var);
}

void CWmiToXml::MapStrongType (IStream *pOutputStream, IWbemQualifierSet *pQualSet)
{
	VARIANT var;
	VariantInit(&var);

	if ((WBEM_S_NO_ERROR == pQualSet->Get(L"CIMTYPE",  0, &var,  NULL))
		&& (VT_BSTR == var.vt))
	{
		// Split out the class (if any) from the ref
		LPWSTR ptr = wcschr (var.bstrVal, OLECHAR(':'));

		if ((NULL != ptr) && (1 < wcslen(ptr)))
		{
			int classLen = wcslen(ptr) - 1;
			LPWSTR classPtr = NULL;
			if(classPtr = new OLECHAR[classLen + 1])
			{
				wcscpy (classPtr, ptr+1);
				BSTR pszClass = NULL;
				if(pszClass = SysAllocString(classPtr))
				{
					WRITEBSTR( OLESTR(" REFERENCECLASS=\""))
					WRITEBSTR( pszClass)
					WRITEBSTR( OLESTR("\""))
					SysFreeString(pszClass);
				}
				delete [] classPtr;
			}
		}
	}

	VariantClear(&var);
}

STDMETHODIMP CWmiToXml::MapType (IStream *pOutputStream, CIMTYPE cimtype)
{
	HRESULT hr = WBEM_S_NO_ERROR;

	WRITEBSTR( OLESTR(" TYPE=\""))
	switch (cimtype)
	{
		case CIM_SINT8:
			WRITEBSTR( OLESTR("sint8"))
			break;

		case CIM_UINT8:
			WRITEBSTR( OLESTR("uint8"))
			break;

		case CIM_SINT16:
			WRITEBSTR( OLESTR("sint16"))
			break;

		case CIM_UINT16:
			WRITEBSTR( OLESTR("uint16"))
			break;

		case CIM_SINT32:
			WRITEBSTR( OLESTR("sint32"))
			break;

		case CIM_UINT32:
			WRITEBSTR( OLESTR("uint32"))
			break;

		case CIM_SINT64:
			WRITEBSTR( OLESTR("sint64"))
			break;

		case CIM_UINT64:
			WRITEBSTR( OLESTR("uint64"))
			break;

		case CIM_REAL32:
			WRITEBSTR( OLESTR("real32"))
			break;

		case CIM_REAL64:
			WRITEBSTR( OLESTR("real64"))
			break;

		case CIM_BOOLEAN:
			WRITEBSTR( OLESTR("boolean"))
			break;

		case CIM_STRING:
			WRITEBSTR( OLESTR("string"))
			break;

		case CIM_DATETIME:
			WRITEBSTR( OLESTR("datetime"))
			break;

		case CIM_CHAR16:
			WRITEBSTR( OLESTR("char16"))
			break;

		default:
			// Don't recognize this type
			hr = WBEM_E_FAILED;
	}

	WRITEBSTR( OLESTR("\""))

	return hr;
}

STDMETHODIMP CWmiToXml::MapValue (IStream *pOutputStream, CIMTYPE cimtype, BOOL isArray, VARIANT &var)
{
	if (VT_NULL == var.vt)
		return WBEM_S_NO_ERROR;

	if (isArray)
	{
		long uBound = 0;
		if (FAILED(SafeArrayGetUBound (var.parray, 1, &uBound)))
			return WBEM_E_FAILED;

		WRITEBSTR( OLESTR("<VALUE.ARRAY>"))

		for (long i = 0; i <= uBound; i++)
		{
			WRITEBSTR( OLESTR("<VALUE>"))

			switch (cimtype)
			{
				case CIM_UINT8:
				{
					unsigned char val = 0;
					SafeArrayGetElement (var.parray, &i, &val);
					MapByteValue (pOutputStream, val);
				}
					break;

				case CIM_SINT8:
				case CIM_SINT16:
				{
					short val = 0;
					SafeArrayGetElement (var.parray, &i, &val);
					MapShortValue (pOutputStream, val);
				}
					break;

				case CIM_UINT16:
				case CIM_UINT32:
				case CIM_SINT32:
				{
					long val = 0;
					SafeArrayGetElement (var.parray, &i, &val);
					MapLongValue (pOutputStream, val);
				}
					break;

				case CIM_REAL32:
				{
					float val = 0;
					SafeArrayGetElement (var.parray, &i, &val);
					MapFloatValue (pOutputStream, val);
				}
					break;

				case CIM_REAL64:
				{
					double val = 0;
					SafeArrayGetElement (var.parray, &i, &val);
					MapDoubleValue (pOutputStream, val);
				}
					break;

				case CIM_BOOLEAN:
				{
					VARIANT_BOOL val = 0;
					SafeArrayGetElement (var.parray, &i, &val);
					MapBoolValue (pOutputStream, (val)? TRUE : FALSE);
				}
					break;

				case CIM_CHAR16:
				{
					long val = 0;
					SafeArrayGetElement (var.parray, &i, &val);
					MapCharValue (pOutputStream, val);
				}
					break;

				case CIM_STRING:
				{
					BSTR val = NULL;
					SafeArrayGetElement (var.parray, &i, &val);
					MapStringValue (pOutputStream, val);
					SysFreeString (val);
				}
					break;

				case CIM_UINT64:
				case CIM_SINT64:
				case CIM_DATETIME:
				{
					BSTR val = NULL;
					SafeArrayGetElement (var.parray, &i, &val);
					WRITEBSTR( val)
					SysFreeString(val);
				}
					break;
			}
			WRITEBSTR( OLESTR("</VALUE>"))
			WRITENEWLINE
		}

		WRITEBSTR( OLESTR("</VALUE.ARRAY>"))
	}
	else
	{
		// Simple value
		WRITEBSTR( OLESTR("<VALUE>"))
		switch (cimtype)
		{
			case CIM_UINT8:
				MapByteValue (pOutputStream, var.bVal);
				break;

			case CIM_SINT8:
			case CIM_SINT16:
				MapShortValue (pOutputStream, var.iVal);
				break;

			case CIM_UINT16:
			case CIM_UINT32:
			case CIM_SINT32:
				MapLongValue (pOutputStream, var.lVal);
				break;

			case CIM_REAL32:
				MapFloatValue (pOutputStream, var.fltVal);
				break;

			case CIM_REAL64:
				MapDoubleValue (pOutputStream, var.dblVal);
				break;

			case CIM_BOOLEAN:
				MapBoolValue (pOutputStream, (var.boolVal) ? TRUE : FALSE);
				break;

			case CIM_CHAR16:
				MapCharValue (pOutputStream, var.lVal);
				break;

			case CIM_STRING:
				MapStringValue (pOutputStream, var.bstrVal);
				break;

			case CIM_UINT64:
			case CIM_SINT64:
			case CIM_DATETIME:
				WRITEBSTR( var.bstrVal)
				break;
		}
		WRITEBSTR( OLESTR("</VALUE>"))
	}

	return WBEM_S_NO_ERROR;
}

STDMETHODIMP CWmiToXml::MapEmbeddedObjectValue (IStream *pOutputStream, BOOL isArray, VARIANT &var)
{
	HRESULT hr = WBEM_S_NO_ERROR;

	if (VT_NULL == var.vt)
		return WBEM_S_NO_ERROR;

	if (isArray)
	{
		long uBound = 0;
		if (FAILED(SafeArrayGetUBound (var.parray, 1, &uBound)))
			return WBEM_E_FAILED;

		WRITEBSTR(OLESTR("<VALUE.OBJECTARRAY>"))
		for (long i = 0; i<=uBound; i++)
		{
			IUnknown *pNextElement = NULL;
			if(SUCCEEDED(hr = SafeArrayGetElement(var.parray, (LONG *)&i, (LPVOID )&pNextElement )))
			{
				IWbemClassObject *pEmbeddedObject = NULL;
				if(SUCCEEDED(hr = pNextElement->QueryInterface(IID_IWbemClassObject, (LPVOID *)&pEmbeddedObject)))
				{
					// Note that we always use PathLevelAnonymous here since embedded objects are VALUE.OBJECTs as per the DTD
					CWmiToXml wbemToXml;
					wbemToXml.m_iPathLevel = pathLevelAnonymous;
					wbemToXml.m_bAllowWMIExtensions = m_bAllowWMIExtensions;
					wbemToXml.m_iQualifierFilter = m_iQualifierFilter;
					wbemToXml.m_iClassOriginFilter = m_iClassOriginFilter;
					WRITEBSTR(OLESTR("<VALUE.OBJECT>"))
					hr = wbemToXml.MapObjectToXML(pEmbeddedObject, NULL, 0, NULL, pOutputStream, NULL);
					WRITEBSTR(OLESTR("</VALUE.OBJECT>"))
					pEmbeddedObject->Release();
				}
				pNextElement->Release();
				pNextElement = NULL;
			}
		}
		WRITEBSTR(OLESTR("</VALUE.OBJECTARRAY>"))
	}
	else
	{
		// Note that we always use PathLevelAnonymous here since embedded objects are VALUE.OBJECTs as per the DTD
		IWbemClassObject *pEmbeddedObject = NULL;
		if(SUCCEEDED(hr = (var.punkVal)->QueryInterface(IID_IWbemClassObject, (LPVOID *)&pEmbeddedObject)))
		{
		
			WRITEBSTR(OLESTR("<VALUE.OBJECT>"))
			CWmiToXml wbemToXml;
			wbemToXml.m_iPathLevel = pathLevelAnonymous;
			wbemToXml.m_bAllowWMIExtensions = m_bAllowWMIExtensions;
			wbemToXml.m_iQualifierFilter = m_iQualifierFilter;
			wbemToXml.m_iClassOriginFilter = m_iClassOriginFilter;
			hr = wbemToXml.MapObjectToXML(pEmbeddedObject, NULL, 0, NULL, pOutputStream, NULL);
			pEmbeddedObject->Release();
			WRITEBSTR(OLESTR("</VALUE.OBJECT>"))
		}
	}
	return WBEM_S_NO_ERROR;
}

STDMETHODIMP CWmiToXml::MapMethods (IStream *pOutputStream, IWbemClassObject *pObject)
{
	HRESULT hr = WBEM_S_NO_ERROR;

	// Map the requested filter (local only) to the flags value - default is ALL
	LONG lFlags = 0;
	if (VARIANT_TRUE == m_bLocalOnly)
		lFlags = WBEM_FLAG_LOCAL_ONLY;

	pObject->BeginMethodEnumeration (lFlags);
	BSTR name = NULL;
	IWbemClassObject *pInParams = NULL;
	IWbemClassObject *pOutParams = NULL;

	while (WBEM_S_NO_ERROR == pObject->NextMethod (0, &name, &pInParams, &pOutParams))
	{
		MapMethod (pOutputStream, pObject, name, pInParams, pOutParams);

		if (pInParams)
		{
			pInParams->Release ();
			pInParams = NULL;
		}

		if (pOutParams)
		{
			pOutParams->Release ();
			pOutParams = NULL;
		}

		SysFreeString (name);
	}

	pObject->EndMethodEnumeration ();
	return WBEM_S_NO_ERROR;
}

void CWmiToXml::MapMethod (IStream *pOutputStream, IWbemClassObject *pObject, BSTR name, IWbemClassObject *pInParams, IWbemClassObject *pOutParams)
{
	HRESULT result = E_FAIL;
	CIMTYPE returnCimtype = 0;
	VARIANT vVariant;
	VariantInit(&vVariant);

	// First we need the return type of the method, if any
	if (pOutParams)
	{
		if (SUCCEEDED(result = pOutParams->Get (L"ReturnValue", 0, &vVariant, &returnCimtype, NULL)))
		{
			switch(returnCimtype)
			{
				case CIM_OBJECT:
					if(m_bAllowWMIExtensions)
						WRITEBSTR(OLESTR("<METHOD.OBJECT NAME=\""))
					else
					{
						// Just skip this method if WMI extensions are not allowed
						VariantClear(&vVariant);
						return;
					}
					break;
				case CIM_REFERENCE:
					if(m_bAllowWMIExtensions)
						WRITEBSTR(OLESTR("<METHOD.REFERENCE NAME=\""))
					else
					{
						// Just skip this method if WMI extensions are not allowed
						VariantClear(&vVariant);
						return;
					}
					break;
				default:
					WRITEBSTR(OLESTR("<METHOD NAME=\""))
						break;
			}
		}
		else if (result == WBEM_E_NOT_FOUND) // So this method returns a void
		{
			WRITEBSTR(OLESTR("<METHOD NAME=\""))
		}
	}
	else // This method returns a VOID
	{
		WRITEBSTR(OLESTR("<METHOD NAME=\""))
	}


	// The method name
	WRITEBSTR(name)
	WRITEBSTR(OLESTR("\" "))

	// The method return type (default is void).  This is the type of
	// the ReturnType property if present (otherwise defaults to void)
	MapMethodReturnType(pOutputStream, &vVariant, returnCimtype, pOutParams);
	VariantClear(&vVariant);

	// The class origin
	BSTR	methodOrigin = NULL;

	if (WBEM_S_NO_ERROR == pObject->GetMethodOrigin (name, &methodOrigin))
	{
		MapClassOrigin (pOutputStream, methodOrigin, true);
		SysFreeString(methodOrigin);
	}

	WRITEBSTR( OLESTR(">"))
	WRITENEWLINE

	// Now do the qualifiers of the method
	IWbemQualifierSet *pQualSet = NULL;
	if (WBEM_S_NO_ERROR == pObject->GetMethodQualifierSet (name, &pQualSet))
	{
		MapQualifiers (pOutputStream, pQualSet);
		pQualSet->Release ();
		pQualSet = NULL;
	}

	VARIANT idVar;
	VariantInit (&idVar);
	idVar.vt = VT_I4;
	idVar.lVal = 0;

	long nextId = 0;	// The next method ID to expect
	long fixedIndex = 0;

	// For each id,
	//		Get the name of the parameter (could be in, out or both)
	//		If just an in-parameter or just an out-parameter it's easy
	//		If both it's a bit tricky
	//=========================================================================

	while (TRUE)
	{
		BSTR nextInParamName = NULL;
		BSTR nextOutParamName = NULL;

		if (pInParams)
		{
			SAFEARRAY *pArray = NULL;

			if (WBEM_S_NO_ERROR ==
					pInParams->GetNames (L"ID", WBEM_FLAG_ONLY_IF_IDENTICAL|WBEM_FLAG_NONSYSTEM_ONLY,
											&idVar, &pArray))
			{
				// Did we get a match?
				if (pArray)
				{
					if ((1 == pArray->cDims) && (1 == (pArray->rgsabound[0]).cElements))
						SafeArrayGetElement (pArray, &fixedIndex, &nextInParamName);

					SafeArrayDestroy (pArray);
				}
			}
		}

		if (pOutParams)
		{
			SAFEARRAY *pArray = NULL;

			if (WBEM_S_NO_ERROR ==
					pOutParams->GetNames (L"ID", WBEM_FLAG_ONLY_IF_IDENTICAL|WBEM_FLAG_NONSYSTEM_ONLY,
											&idVar, &pArray))
			{
				// Did we get a match?
				if (pArray)
				{
					if ((1 == pArray->cDims) && (1 == (pArray->rgsabound[0]).cElements))
						SafeArrayGetElement (pArray, &fixedIndex, &nextOutParamName);

					SafeArrayDestroy (pArray);
				}
			}
		}

		// If [in] or [out] this is easy
		if ((nextInParamName && !nextOutParamName) || (!nextInParamName && nextOutParamName))
		{
			VARIANT var;
			VariantInit (&var);
			IWbemQualifierSet *pParamQualSet = NULL;
			CIMTYPE cimtype = 0;

			if (nextInParamName)
			{
				if (WBEM_S_NO_ERROR == pInParams->Get (nextInParamName, 0, &var, &cimtype, NULL))
				{
					pInParams->GetPropertyQualifierSet (nextInParamName, &pParamQualSet);
					MapParameter(pOutputStream, nextInParamName, pParamQualSet, cimtype);
				}
			}
			else
			{
				if (WBEM_S_NO_ERROR == pOutParams->Get (nextOutParamName, 0, &var, &cimtype, NULL))
				{
					pOutParams->GetPropertyQualifierSet (nextOutParamName, &pParamQualSet);
					MapParameter(pOutputStream, nextOutParamName, pParamQualSet, cimtype);
				}
			}

			if (pParamQualSet)
				pParamQualSet->Release ();

			VariantClear (&var);
		}
		else if (nextInParamName && nextOutParamName)
		{
			// The [in,out] case and we have to do a merge

			if (0 == _wcsicmp (nextInParamName, nextOutParamName))
			{
				VARIANT var;
				VariantInit (&var);
				CIMTYPE cimtype = 0;

				IWbemQualifierSet *pInParamQualSet = NULL;
				IWbemQualifierSet *pOutParamQualSet = NULL;

				if (WBEM_S_NO_ERROR == pInParams->Get (nextInParamName, 0, &var, &cimtype, NULL))
				{
					pInParams->GetPropertyQualifierSet (nextInParamName, &pInParamQualSet);
					pOutParams->GetPropertyQualifierSet (nextInParamName, &pOutParamQualSet);
					MapParameter(pOutputStream, nextInParamName, pInParamQualSet, cimtype, pOutParamQualSet);

				}

				if (pInParamQualSet)
					pInParamQualSet->Release ();

				if (pOutParamQualSet)
					pOutParamQualSet->Release ();

				VariantClear (&var);
			}
			else
			{
				// Bad news - conflicting IDs in the [in] and [out] parameter set
				// This cannot be a valid method definition
				SysFreeString (nextInParamName);
				SysFreeString (nextOutParamName);
				break;
			}
		}
		else
		{
			// Next id not found - stop now and break out
			SysFreeString (nextInParamName);
			SysFreeString (nextOutParamName);
			break;
		}

		SysFreeString (nextInParamName);
		SysFreeString (nextOutParamName);
		idVar.iVal = idVar.iVal + 1;
	}

	switch(returnCimtype)
	{
		case CIM_OBJECT:
			WRITEBSTR(OLESTR("</METHOD.OBJECT>"))
				break;
		case CIM_REFERENCE:
			WRITEBSTR(OLESTR("</METHOD.REFERENCE>"))
				break;
		default:
			WRITEBSTR(OLESTR("</METHOD>"))
				break;
	}
}

STDMETHODIMP CWmiToXml::MapMethodReturnType(IStream *pOutputStream, VARIANT *pValue, CIMTYPE returnCimType, IWbemClassObject *pOutputParams)
{
	HRESULT hr = E_FAIL;
	switch(returnCimType)
	{
		// Write a REFERENCECLASS
		case CIM_OBJECT:
		case CIM_REFERENCE:
		{
			IWbemQualifierSet *pQualifierSet = NULL;
			if(SUCCEEDED(hr = pOutputParams->GetPropertyQualifierSet(L"ReturnValue", &pQualifierSet)))
			{
				// Map the type of the return class
				MapStrongType(pOutputStream, pQualifierSet);
				pQualifierSet->Release();
			}
		}
		break;
		default:
			hr = MapType(pOutputStream, returnCimType);
			break;
	}
	return hr;
}

void CWmiToXml::MapClassOrigin (IStream *pOutputStream, BSTR &classOrigin, bool bIsClass)
{
	if ( (bIsClass && (m_iClassOriginFilter & wmiXMLClassOriginFilterClass)) ||
				   (m_iClassOriginFilter & wmiXMLClassOriginFilterInstance) )
	{
		WRITEBSTR( OLESTR(" CLASSORIGIN=\""))
		WRITEBSTR( classOrigin)
		WRITEBSTR( OLESTR("\""))
	}
}

void CWmiToXml::MapParameter (IStream *pOutputStream, BSTR paramName,
							   IWbemQualifierSet *pQualSet,
							   CIMTYPE cimtype,
							   IWbemQualifierSet *pQualSet2)
{
	/*
	 * For vanilla CIM XML we don't handle embedded object parameters
	 */

	if ((CIM_OBJECT != (cimtype & ~CIM_FLAG_ARRAY)) || m_bAllowWMIExtensions)
	{
		if (cimtype & CIM_FLAG_ARRAY)
		{
			// Map the array parameter
			if (CIM_REFERENCE == (cimtype & ~CIM_FLAG_ARRAY))
			{
				WRITEBSTR( OLESTR("<PARAMETER.REFARRAY NAME=\""))
				WRITEBSTR( paramName)
				WRITEBSTR( OLESTR("\" "))
				MapStrongType (pOutputStream, pQualSet);
				WRITEBSTR( OLESTR(" "))
				MapArraySize (pOutputStream, pQualSet);
				WRITEBSTR( OLESTR(">"))
				WRITENEWLINE

				// Map the qualifiers of the parameter
				if (pQualSet || pQualSet2)
					MapQualifiers (pOutputStream, pQualSet, pQualSet2);

				WRITEBSTR( OLESTR("</PARAMETER.REFARRAY>"))
			}
			else if (CIM_OBJECT == (cimtype & ~CIM_FLAG_ARRAY))
			{
				WRITEBSTR( OLESTR("<PARAMETER.OBJECTARRAY NAME=\""))
				WRITEBSTR( paramName)
				WRITEBSTR( OLESTR("\" "))
				MapStrongType (pOutputStream, pQualSet);
				WRITEBSTR( OLESTR(" "))
				MapArraySize (pOutputStream, pQualSet);
				WRITEBSTR( OLESTR(">"))
				WRITENEWLINE

				// Map the qualifiers of the parameter
				if (pQualSet || pQualSet2)
					MapQualifiers (pOutputStream, pQualSet, pQualSet2);

				WRITEBSTR( OLESTR("</PARAMETER.OBJECTARRAY>"))
			}
			else
			{
				WRITEBSTR( OLESTR("<PARAMETER.ARRAY NAME=\""))
				WRITEBSTR( paramName)
				WRITEBSTR( OLESTR("\" "))
				MapType (pOutputStream, cimtype & ~CIM_FLAG_ARRAY);
				WRITEBSTR( OLESTR(" "))
				MapArraySize (pOutputStream, pQualSet);
				WRITEBSTR( OLESTR(">"))
				WRITENEWLINE

				// Map the qualifiers of the parameter
				if (pQualSet || pQualSet2)
					MapQualifiers (pOutputStream, pQualSet, pQualSet2);

				WRITEBSTR( OLESTR("</PARAMETER.ARRAY>"))
			}
		}
		else if (cimtype == CIM_REFERENCE)
		{
			// Map the reference parameter
			WRITEBSTR( OLESTR("<PARAMETER.REFERENCE NAME=\""))
			WRITEBSTR( paramName)
			WRITEBSTR( OLESTR("\" "))
			MapStrongType (pOutputStream, pQualSet);
			WRITEBSTR( OLESTR(">"))
			WRITENEWLINE

			// Map the qualifiers of the parameter
			if (pQualSet || pQualSet2)
				MapQualifiers (pOutputStream, pQualSet, pQualSet2);

			WRITEBSTR( OLESTR("</PARAMETER.REFERENCE>"))
		}
		else if (cimtype == CIM_OBJECT)
		{
			WRITEBSTR( OLESTR("<PARAMETER.OBJECT NAME=\""))
			WRITEBSTR( paramName)
			WRITEBSTR( OLESTR("\" "))
			MapStrongType (pOutputStream, pQualSet);
			WRITEBSTR( OLESTR(">"))
			WRITENEWLINE

			// Map the qualifiers of the parameter
			if (pQualSet || pQualSet2)
				MapQualifiers (pOutputStream, pQualSet, pQualSet2);

			WRITEBSTR( OLESTR("</PARAMETER.OBJECT>"))
		}
		else
		{
			// Vanilla parameter
			WRITEBSTR( OLESTR("<PARAMETER NAME=\""))
			WRITEBSTR( paramName)
			WRITEBSTR( OLESTR("\" "))
			MapType (pOutputStream, cimtype);
			WRITEBSTR( OLESTR(">"))
			WRITENEWLINE

			// Map the qualifiers of the parameter
			if (pQualSet || pQualSet2)
				MapQualifiers (pOutputStream, pQualSet, pQualSet2);

			WRITEBSTR( OLESTR("</PARAMETER>"))
		}
	}
}


void CWmiToXml::MapByteValue (IStream *pOutputStream, unsigned char val)
{
	OLECHAR	wStr[32];
	swprintf (wStr, L"%d", val);
	WRITEBSTR( wStr)
}

void CWmiToXml::MapLongValue (IStream *pOutputStream, long val)
{
	OLECHAR	wStr[32];
	swprintf (wStr, L"%d", val);
	WRITEBSTR( wStr)
}

void CWmiToXml::MapShortValue (IStream *pOutputStream, short val)
{
	OLECHAR wStr[32];
	swprintf (wStr, L"%d", val);
	WRITEBSTR( wStr)
}

void CWmiToXml::MapDoubleValue (IStream *pOutputStream, double val)
{
	OLECHAR floatStr [64];
	swprintf (floatStr, L"%G", val);
	WRITEBSTR( floatStr)
}

void CWmiToXml::MapFloatValue (IStream *pOutputStream, float val)
{
	OLECHAR floatStr [64];
	swprintf (floatStr, L"%G", val);
	WRITEBSTR( floatStr)
}

void CWmiToXml::MapCharValue (IStream *pOutputStream, long val)
{
	// As per the XML Spec, the following are invalid character values in an XML Stream:
	// Char ::=  #x9 | #xA | #xD | [#x20-#xD7FF] | [#xE000-#xFFFD] | [#x10000-#x10FFFF]

	// As per the CIM Operations spec, they need to be escaped as follows:
	//	If the value is not a legal XML character
	//  (as defined in [2, section 2.2] by the Char production)
	//	then it MUST be escaped using a \x<hex> escape convention
	//	where <hex> is a hexadecimal constant consisting of
	//	between one and four digits

	if(	val < 0x9 ||
		(val == 0xB || val == 0xC)	||
		(val > 0xD && val <0x20)	||
		(val >0xD7FF && val < 0xE000) ||
		(val > 0xFFFD)
		)
	{
		// Map it in the escaped manner
		OLECHAR charStr [7];
		swprintf (charStr, L"\\x%04x", val&0xffff);
		charStr[6] = NULL;
		WRITEBSTR( charStr)
	}
	else
	{
		// FIrst check to see if is one of the reserved characters in XML - < & and >
		// Map it in the normal manner
		if(val == '<')
			WRITELT
		else if (val == '>')
			WRITEGT
		else if (val == '&')
			WRITEAMP
		else
		{
			// Map it in the normal manner
			WCHAR charStr [2];
			swprintf (charStr, L"%c", val);
			charStr[1] = NULL;
			WRITEBSTR(charStr)
		}
	}
}

void CWmiToXml::MapBoolValue (IStream *pOutputStream, BOOL val)
{
	if (TRUE == val)
		WRITEBSTR( OLESTR("TRUE"))
	else
		WRITEBSTR( OLESTR("FALSE"))
}

void CWmiToXml::MapStringValue (IStream *pOutputStream, BSTR &val)
{
	/*
	 * Quote from http://www.w3.org/TR/REC-xml:
	 *
	 *  The ampersand character (&) and the left angle bracket (<) may
	 *  appear in their literal form only when used as markup delimiters,
	 *  or within a comment, a processing instruction, or a CDATA section.
	 *
	 *  If they are needed elsewhere, they must be escaped using either
	 *  numeric character references or the strings "&amp;" and "&lt;"
	 *  respectively.
	 *
	 *  The right angle bracket (>) must, for compatibility, be escaped
	 *  using "&gt;" or a character reference when it appears in the string
	 *  "]]>" in content, when that string is not marking the end of a CDATA
	 *  section.
	 *
	 *  In the content of elements, character data is any string of characters
	 *  which does not contain the start-delimiter of any markup. In a CDATA
	 *  section, character data is any string of characters not including the
	 *  CDATA-section-close delimiter, "]]>".
	 */

	// Check that < or & do not occur in the value
	size_t length = wcslen (val);
	size_t offset = 0;
	OLECHAR *pWchar = NULL;

	if ((offset = wcscspn (val, L"<&")) < length)
	{
		// A reserved character (< &) appears in the value -
		// need to escape.  We can use CDATA if it does not
		// contain the string ]]>

		if (wcsstr (val, CDATAEND))
		{
			// Bad luck - can't use CDATA. Have to escape
			// each reserved character and the CDATAEND sequence!
			// Easiest way to do this is escape all occurences
			// of >.
			//	<	->		&lt;
			//	&	->		&amp;
			//	>	->		&gt;

			offset = wcscspn (val, L"<&>");
			OLECHAR *pStr = (OLECHAR *)val;

			while (TRUE)
			{
				// Write the initial block that's safe
				if (offset > 0)
					WRITEWSTRL( pStr, offset);

				pStr += offset;

				// Escape the offending character
				if (L'<' == *pStr)
					WRITELT
				else if (L'>' == *pStr)
					WRITEGT
				else
					WRITEAMP

				// Skip over the reserved character
				pStr += 1;

				// Find the next position
				if ((offset = wcscspn (pStr, L"<&>")) >= wcslen (pStr))
					break;
			}

			// Any data left?
			if (pStr && wcslen (pStr))
				WRITEWSTR (pStr)
		}
		else
		{
			// Can escape the whole value inside a CDATA
			WRITECDATASTART
			WRITEBSTR( val)
			WRITECDATAEND
		}
	}
	else if (pWchar = wcsstr (val, CDATAEND))
	{
		// Yuck we need to escape the > inside this sequence
		//
		// ]]>  -> ]]&gt;

		OLECHAR *pStr = (OLECHAR *)val;

		while (TRUE)
		{
			offset = wcslen (pStr) - wcslen (pWchar);

			// Write the initial block that's safe
			// (NOTE: the additional two characters for the "]]"
			//  which we don't need to escape)
			WRITEWSTRL( pStr,(offset+2));

			// Skip over the CDATAEND sequence
			pStr += offset + 3;

			// Escape the offending character
			WRITEGT

			// Find the next position
			if (!(pWchar = wcsstr (pStr, CDATAEND)))
				break;
		}

		// Any data left?
		if (pStr && wcslen (pStr))
			WRITEWSTR (pStr)
	}
	else
	{
		// Just write the value
		WRITEBSTR( val)
	}
}

void CWmiToXml::MapReturnParameter(IStream *pOutputStream, BSTR strParameterName, VARIANT &variant)
{
	// Could be a PARAMETER or PARAMETER.ARRAY
	if(variant.vt & VT_ARRAY)
		WRITEBSTR( OLESTR("<PARAMVALUE.ARRAY NAME=\""))
	else
		WRITEBSTR( OLESTR("<PARAMVALUE NAME=\""))

	WRITEBSTR( strParameterName);
	WRITEBSTR( OLESTR("\">"));

	// Convert the property value to XML
	MapValue(pOutputStream, variant);
	if(variant.vt & VT_ARRAY)
		WRITEBSTR( OLESTR("</PARAMVALUE.ARRAY>"))
	else
		WRITEBSTR( OLESTR("</PARAMVALUE>"))
}


BOOL CWmiToXml::PropertyDefinedForClass (IWbemClassObject *pObject, BSTR bsPropertyName, BSTR strClassBasis)
{
	BOOL result = TRUE;

	// Given (a) Class basis for enumeration and
	// (b) property name, determine
	//   (1) CLASSORIGIN of property
	//	 (2) Dynasty of class
	// And thereby check whether property was defined
	// at the level of the class basis.
	// If no class basis is supplied, then we always return TRUE
	//============================================================
	if (strClassBasis && pObject)
	{
		// Get Property originating class
		BSTR bsOrigClass = NULL;

		if (SUCCEEDED (pObject->GetPropertyOrigin (bsPropertyName, &bsOrigClass)))
		{
			// Derivation is the Class hierarchy of the current class or instance.
			// The first element is the immediate superclass, the next is its parent,
			// and so on; the last element is the base class.
			// Now work through the derivation array. If we meet the
			// propertys' originating class before the class basis,
			// we conclude that the property was not defined in the
			// class basis

			// If we have been give a class basis, get the __DERIVATION
			// property for each object
			VARIANT vDerivation;
			VariantInit(&vDerivation);
			if (SUCCEEDED(pObject->Get (L"__DERIVATION", 0, &vDerivation, NULL, NULL)))
			{
				SAFEARRAY *pArray = vDerivation.parray;

				if (pArray && (1 == pArray->cDims) && (0 < pArray->rgsabound [0].cElements))
				{
					int lBound = pArray->rgsabound [0].lLbound;
					int uBound = pArray->rgsabound [0].cElements + lBound;
					BOOL bDone = FALSE;

					for (long i = lBound; (i < uBound) && !bDone; i++)
					{
						BSTR bsClass = NULL;

						if (SUCCEEDED (SafeArrayGetElement (pArray, &i, &bsClass)))
						{
							if (0 == _wcsicmp (bsOrigClass, bsClass))
							{
								result = FALSE;
								bDone = TRUE;
							}
							else if (0 == _wcsicmp (strClassBasis, bsClass))
								bDone = TRUE;

							SysFreeString (bsClass);
						}
					}
				}
				VariantClear(&vDerivation);
			}

			SysFreeString (bsOrigClass);
		}
	}

	return result;
}

// Functions of the IWbemXMLConvertor interface
HRESULT STDMETHODCALLTYPE CWmiToXml::MapObjectToXML(
    /* [in] */ IWbemClassObject  *pObject,
 	/* [in] */ BSTR *ppPropertyList, DWORD dwNumProperties,
    /* [in] */ IWbemContext  *pInputFlags,
    /* [in] */ IStream  *pOutputStream,
	/* [in[ */ BSTR strClassBasis)
{
	// Set private members from arguments
	GetFlagsFromContext(pInputFlags);

	HRESULT hr = WBEM_E_FAILED;
	
	// Is this a class or an instance?
	VARIANT var;
	VariantInit (&var);
	long flav = 0;
	bool bIsClass = false;
	if (SUCCEEDED (pObject->Get(L"__GENUS", 0, &var, NULL, &flav)))
		bIsClass = (WBEM_GENUS_CLASS == var.lVal);
	else
		bIsClass = VARIANT_FALSE; // For now, assume that it is an instance. RAJESHR is this correct?
	VariantClear (&var);

	// Initalize the object path
	VariantInit (&var);
	
	// For pathLevelAnonymous (anonymous objects), we dont need anything more
	// For pathLevelNamed (named objects), we only need __RELPATH for a class and __RELPATH for an instance 
	// For pathLevelLocal, I wish core team had some concept
	// of machine-relative path, but they dont and hence we need the __PATH
	// For pathLevelFull, we definitely need __PATH
	LPWSTR lpszPath = NULL;
	switch(m_iPathLevel)
	{
		case pathLevelAnonymous:
			break; 
		case pathLevelNamed:
			lpszPath = L"__RELPATH";
			break;
		default:
			lpszPath = L"__PATH";
	}

	// Get the object path
	ParsedObjectPath *pParsedPath = NULL;
	CObjectPathParser pathParser;
	if(m_iPathLevel != pathLevelAnonymous)
	{
		if(FAILED(pObject->Get (lpszPath, 0, &var, NULL, NULL)))
			return WBEM_E_FAILED;
		// Now Parse it
		if ((VT_BSTR == var.vt) && (NULL != var.bstrVal) && (wcslen (var.bstrVal) > 0))
		{
			pathParser.Parse (var.bstrVal, &pParsedPath) ;
			if(!pParsedPath)
			{
				VariantClear (&var);
				return WBEM_E_FAILED;
			}
		}
		else
		{
			VariantClear (&var);
			return WBEM_E_FAILED;
		}
		VariantClear (&var);
	}

	// Get the object Qualifier Set
	IWbemQualifierSet *pQualSet= NULL;
	pObject->GetQualifierSet (&pQualSet);
	
	// Whether we generate a named object or not depends
	// on what was requested
	if (pathLevelNamed == m_iPathLevel)
	{
		if(!bIsClass)
			MapInstanceName(pOutputStream, pParsedPath);
			// Nothing to be done for a class
	}
	else if (pathLevelLocal == m_iPathLevel)
	{
		if(bIsClass)
			MapLocalClassPath(pOutputStream, pParsedPath);
		else
			MapLocalInstancePath(pOutputStream, pParsedPath);
	}
	else if (pathLevelFull == m_iPathLevel)
	{
		if (bIsClass)
			MapClassPath (pOutputStream, pParsedPath);
		else
			MapInstancePath (pOutputStream, pParsedPath);
	}

	hr = (bIsClass) ? MapClass (pOutputStream, pObject, pQualSet, ppPropertyList, dwNumProperties, strClassBasis) :
						MapInstance (pOutputStream, pObject, pQualSet, ppPropertyList, dwNumProperties, strClassBasis);


	if (pQualSet)
		pQualSet->Release ();
	if(pParsedPath)
		pathParser.Free(pParsedPath);

	return hr;
}

HRESULT STDMETHODCALLTYPE CWmiToXml::MapInstanceNameToXML(
    /* [in] */ BSTR  strInstanceName,
    /* [in] */ IWbemContext  *pInputFlags,
    /* [in] */ IStream  *pOutputStream)
{
	// Set private members from arguments
	GetFlagsFromContext(pInputFlags);

	HRESULT hr = WBEM_E_FAILED;
	if (strInstanceName)
	{
		CObjectPathParser pathParser;
		ParsedObjectPath	*pParsedPath = NULL;
		pathParser.Parse (strInstanceName, &pParsedPath) ;

		if(pParsedPath)
		{
			hr = MapInstanceName (pOutputStream, pParsedPath);;
			pathParser.Free(pParsedPath);
		}
	}

	return hr;
}

HRESULT STDMETHODCALLTYPE CWmiToXml::MapPropertyToXML(
        /* [in] */ IWbemClassObject  *pObject,
		/* [in] */ BSTR strPropertyName,
        /* [in] */ IWbemContext  *pInputFlags,
        /* [in] */ IStream  *pOutputStream)
{
	// Set private members from arguments
	GetFlagsFromContext(pInputFlags);

	VARIANT var;
	VariantInit (&var);
	CIMTYPE cimtype;
	long flavor;

	HRESULT hr = pObject->Get (strPropertyName, 0, &var, &cimtype, &flavor);

	if (SUCCEEDED (hr))
	{
		if (CIM_REFERENCE == (cimtype & ~CIM_FLAG_ARRAY))
			MapReferenceValue (pOutputStream, (cimtype & CIM_FLAG_ARRAY) ? TRUE : FALSE, var);
		else
			MapValue (pOutputStream, cimtype & ~CIM_FLAG_ARRAY, (cimtype & CIM_FLAG_ARRAY) ?
							TRUE : FALSE, var);
	}

	VariantClear (&var);
	return hr;
}


HRESULT STDMETHODCALLTYPE CWmiToXml::MapClassNameToXML(
    /* [in] */ BSTR  strClassName,
    /* [in] */ IWbemContext  *pInputFlags,
    /* [in] */ IStream  *pOutputStream)
{
	MapClassName(pOutputStream, strClassName);
	return S_OK;
}

HRESULT STDMETHODCALLTYPE CWmiToXml::MapInstancePathToXML(
    /* [in] */ BSTR  strInstancePath,
    /* [in] */ IWbemContext  *pInputFlags,
    /* [in] */ IStream  *pOutputStream)
{
	// Set private members from arguments
	GetFlagsFromContext(pInputFlags);

	HRESULT hr = WBEM_E_FAILED;
	if (strInstancePath)
	{
		CObjectPathParser pathParser;
		ParsedObjectPath	*pParsedPath = NULL;
		pathParser.Parse (strInstancePath, &pParsedPath) ;

		if (pParsedPath)
		{
			hr = MapInstancePath (pOutputStream, pParsedPath);;
			pathParser.Free(pParsedPath);
		}
	}

	return hr;
}

HRESULT STDMETHODCALLTYPE CWmiToXml::MapClassPathToXML(
    /* [in] */ BSTR  strClassPath,
    /* [in] */ IWbemContext  *pInputFlags,
    /* [in] */ IStream  *pOutputStream)
{
	// Set private members from arguments
	GetFlagsFromContext(pInputFlags);

	HRESULT hr = WBEM_E_FAILED;
	if (strClassPath)
	{
		CObjectPathParser pathParser;
		ParsedObjectPath	*pParsedPath = NULL;
		pathParser.Parse (strClassPath, &pParsedPath) ;

		if (pParsedPath)
		{
			hr = MapClassPath (pOutputStream, pParsedPath);;
			pathParser.Free(pParsedPath);
		}
	}

	return hr;
}

HRESULT STDMETHODCALLTYPE CWmiToXml::MapMethodResultToXML(
    /* [in] */ IWbemClassObject  *pMethodResult,
    /* [in] */ IWbemContext  *pInputFlags,
    /* [in] */ IStream  *pOutputStream)
{
	// Set private members from arguments
	GetFlagsFromContext(pInputFlags);

	HRESULT hr = WBEM_E_FAILED;

	// First Map the return Value
	// The property "ReturnValue" indicates the return value of the method call, if any
	VARIANT retValueVariant;
	VariantInit(&retValueVariant);
	CIMTYPE cimtype;
	long flavour;
	if(SUCCEEDED(pMethodResult->Get(L"ReturnValue", 0, &retValueVariant, &cimtype, &flavour)))
	{
		WRITEBSTR( OLESTR("<RETURNVALUE>"));
		MapValue(pOutputStream, retValueVariant);
		WRITEBSTR( OLESTR("</RETURNVALUE>"));
		VariantClear(&retValueVariant);
	}

	// Map each of its non-system properties, except for the "ReturnValue" property which
	// we've already mapped
	if(SUCCEEDED(hr = pMethodResult->BeginEnumeration(WBEM_FLAG_NONSYSTEM_ONLY)))
	{
		BSTR strName = NULL;
		VARIANT variant;
		VariantInit(&variant);
		while(SUCCEEDED(hr = pMethodResult->Next(0, &strName, &variant, &cimtype, &flavour)) && hr != WBEM_S_NO_MORE_DATA)
		{
			if(_wcsicmp(strName, L"ReturnValue") != 0)
				MapReturnParameter(pOutputStream, strName, variant);
			VariantClear(&variant);
		}
	}

	return hr;
}

// Get all the flags from the IWbemContextObject
void CWmiToXml::GetFlagsFromContext(IWbemContext  *pInputFlags)
{
	if(pInputFlags)
	{
		if(SUCCEEDED(pInputFlags->BeginEnumeration(0)))
		{
			VARIANT vNextArgValue;
			VariantInit(&vNextArgValue);
			BSTR strNextArgName = NULL;

			while(pInputFlags->Next(0, &strNextArgName, &vNextArgValue) != WBEM_S_NO_MORE_DATA)
			{
				// VARIANT_BOOL bAllowWMIExtensions,
				if(_wcsicmp(s_wmiToXmlArgs[WMI_EXTENSIONS_ARG], strNextArgName) == 0)
					m_bAllowWMIExtensions = vNextArgValue.boolVal;

				// VARIANT_BOOL bLocalOnly,
				else if(_wcsicmp(s_wmiToXmlArgs[LOCAL_ONLY_ARG], strNextArgName) == 0)
					m_bLocalOnly = vNextArgValue.boolVal;

				//	PathLevel					m_iPathLevel;
				else if(_wcsicmp(s_wmiToXmlArgs[PATH_LEVEL_ARG], strNextArgName) == 0)
					m_iPathLevel = (PathLevel)vNextArgValue.lVal;

				// WmiXMLQualifierFilterEnum m_iQualifierFilter
				else if(_wcsicmp(s_wmiToXmlArgs[QUALIFIER_FILTER_ARG], strNextArgName) == 0)
						m_iQualifierFilter = (vNextArgValue.boolVal == VARIANT_TRUE)? wmiXMLQualifierFilterAll : wmiXMLQualifierFilterNone;

				// WmiXMLClassOriginFilterEnum	iClassOriginFilter
				else if(_wcsicmp(s_wmiToXmlArgs[CLASS_ORIGIN_FILTER_ARG], strNextArgName) == 0)
					m_iClassOriginFilter = (vNextArgValue.boolVal == VARIANT_TRUE) ? wmiXMLClassOriginFilterAll : wmiXMLClassOriginFilterNone;

				// VARIANT_BOOL bExcludeSystemProperties
				else if(_wcsicmp(s_wmiToXmlArgs[EXCLUDE_SYSTEM_PROPERTIES_ARG], strNextArgName) == 0)
					m_bExcludeSystemProperties = vNextArgValue.boolVal;

				VariantClear(&vNextArgValue);
			}
			pInputFlags->EndEnumeration();
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\xmltransport\server\wmi2xml\quals.cpp ===
#include "precomp.h"
#include <olectl.h>
#include <wbemidl.h>
#include <wbemint.h>

#include "wmiconv.h"
#include "xmlToWmi.h"
#include "maindll.h"

/* !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! 
 * Conversion to Text to Wbem Object has been cut from the WHistler Feature List and hence commented out 
 *!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!


HRESULT CXml2Wmi::AddQualifier (
	IXMLDOMNode *pNode, // A <QUALIFIER> element
	IWbemQualifierSet *pQualSet,
	bool bIsObjectQualifier // Indicates whether this is for an object or for a property
)
{
	HRESULT hr = S_OK;

	BSTR strName = NULL;
	BSTR strType = NULL;
	BSTR strOverridable = NULL;
	BSTR strToSubclass = NULL;
	BSTR strToInstance = NULL;
	BSTR strAmended = NULL;

	// Get the Name of the Qualifier - this is a mandatory attribute
	if(SUCCEEDED(hr))
		hr = GetBstrAttribute (pNode, g_strName, &strName);

	// Dont map the CIMTYPE QUalifier
	// Dont map the "abstract" qualifiers for objects, but map them for properties (for whatever reason)
	if(SUCCEEDED(hr) && _wcsicmp(strName, L"CIMTYPE") == 0 ||
		(bIsObjectQualifier && _wcsicmp(strName, L"abstract") == 0))
	{
		SysFreeString(strName);
		return S_OK;
	}

	// Get a few more attributes - some of these are optional
	// In such cases, we dont check the return value
	if(SUCCEEDED(hr))
		hr = GetBstrAttribute (pNode, g_strType, &strType);
	if(SUCCEEDED(hr))
		GetBstrAttribute (pNode, g_strOverridable, &strOverridable);
	if(SUCCEEDED(hr))
		GetBstrAttribute (pNode, g_strToSubClass, &strToSubclass);
	if(SUCCEEDED(hr))
		GetBstrAttribute (pNode, g_strToInstance, &strToInstance);
	if(SUCCEEDED(hr))
		GetBstrAttribute (pNode, g_strAmended, &strAmended);

	// Build up the flavor of the Qualifier
	//======================================================
	long flavor = 0;
	if(SUCCEEDED(hr))
	{
		if (!strOverridable || (0 == _wcsicmp (strOverridable, L"true")))
			flavor |= WBEM_FLAVOR_OVERRIDABLE;
		else if (0 == _wcsicmp (strOverridable, L"false"))
			flavor |= WBEM_FLAVOR_NOT_OVERRIDABLE;
		else
			hr = WBEM_E_FAILED;
	}
	if (SUCCEEDED(hr))
	{
		if (!strToSubclass || (0 == _wcsicmp (strToSubclass, L"true")))
			flavor |= WBEM_FLAVOR_FLAG_PROPAGATE_TO_DERIVED_CLASS;
		else if (0 != _wcsicmp (strToSubclass, L"false"))
			hr = WBEM_E_FAILED;
	}
	if (SUCCEEDED(hr))
	{
		if (strToInstance && (0 == _wcsicmp (strToInstance, L"true")))
			flavor |= WBEM_FLAVOR_FLAG_PROPAGATE_TO_INSTANCE;
		else if (strToInstance && (0 != _wcsicmp (strToInstance, L"false")))
			hr = WBEM_E_FAILED;
	}
	if (SUCCEEDED(hr))
	{
		if (strAmended && (0 == _wcsicmp (strAmended, L"true")))
			flavor |= WBEM_FLAVOR_AMENDED;
		else if (strAmended && (0 != _wcsicmp (strAmended, L"false")))
			hr = WBEM_E_FAILED;
	}

	// Map the Qualifier type
	CIMTYPE cimtype = CIM_ILLEGAL;
	if (CIM_ILLEGAL == (cimtype = CimtypeFromString (strType)))
		hr = WBEM_E_FAILED;

	// Map the Qualifier value
	//============================
	VARIANT value;
	VariantInit (&value);
	if (SUCCEEDED (hr))
	{
		IXMLDOMNodeList *pNodeList = NULL;
		long length = 0;
		if (SUCCEEDED(hr = pNode->get_childNodes (&pNodeList)))
		{
			if (SUCCEEDED(hr = pNodeList->get_length (&length)) && (1 == length))
			{
				// Get the first node
				IXMLDOMNode *pValueNode = NULL;
				if (SUCCEEDED(hr = pNodeList->nextNode (&pValueNode)) && pValueNode)
				{
					// Get its name
					BSTR strNodeName = NULL;
					if(SUCCEEDED(hr = pValueNode->get_nodeName(&strNodeName)))
					{
						if (0 == _wcsicmp(strNodeName, VALUE_TAG))
						{
							BSTR bsValue = NULL;
							if(SUCCEEDED(hr = pValueNode->get_text(&bsValue)))
							{
								hr = MapStringQualiferValue (bsValue, value, cimtype);
								SysFreeString (bsValue);
							}
						}
						else if (0 == _wcsicmp(strNodeName, VALUEARRAY_TAG))
						{
							hr = MapStringArrayQualiferValue (pValueNode, value, cimtype);
						}

						SysFreeString (strNodeName);
					}
					pValueNode->Release ();
					pValueNode = NULL;
				}
			}

			pNodeList->Release ();
		}
	}

	// Put it all together
	if (SUCCEEDED (hr))
		hr = pQualSet->Put (strName, &value, flavor);

	SysFreeString (strName);
	SysFreeString (strType);
	SysFreeString (strOverridable);
	SysFreeString (strToSubclass);
	SysFreeString (strToInstance);
	SysFreeString (strAmended);

	VariantClear (&value);

	return hr;
}

//***************************************************************************
//
//  HRESULT CXml2Wmi::MapStringValue
//
//  DESCRIPTION:
//
//  Maps XML VALUE element content into its WMI VARIANT equivalent form
//
//  PARAMETERS:
//
//		bsValue			the VALUE element content
//		curValue		Placeholder for new value (set on return)
//		cimtype			for mapping purposes
//
//  RETURN VALUES:
//
//
//***************************************************************************

HRESULT CXml2Wmi::MapStringQualiferValue (BSTR bsValue, VARIANT &curValue, CIMTYPE cimtype)
{
	HRESULT hr = WBEM_E_TYPE_MISMATCH;
	VariantInit (&curValue);

	// We're assuming it's not an array
	if (!(cimtype & CIM_FLAG_ARRAY))
	{
		switch (cimtype)
		{
			// RAJESHR - more rigorous syntax checking
			case CIM_UINT8:
			{
				curValue.vt = VT_UI1;
				curValue.bVal = (BYTE) wcstol (bsValue, NULL, 0);
				hr = S_OK;
			}
			break;

			case CIM_SINT8:
			case CIM_SINT16:
			{
				curValue.vt = VT_I2;
				curValue.iVal = (short) wcstol (bsValue, NULL, 0);
				hr = S_OK;
			}
			break;

			case CIM_UINT16:
			case CIM_UINT32:
			case CIM_SINT32:
			{
				curValue.vt = VT_I4;
				curValue.lVal = wcstol (bsValue, NULL, 0);
				hr = S_OK;
			}
			break;

			case CIM_REAL32:
			{
				curValue.vt = VT_R4;
				curValue.fltVal = (float) wcstod (bsValue, NULL);
				hr = S_OK;
			}
			break;

			case CIM_REAL64:
			{
				curValue.vt = VT_R8;
				curValue.dblVal = wcstod (bsValue, NULL);
				hr = S_OK;
			}
			break;

			case CIM_BOOLEAN:
			{
				curValue.vt = VT_BOOL;
				curValue.boolVal = (0 == _wcsicmp (bsValue, L"TRUE")) ?
							VARIANT_TRUE : VARIANT_FALSE;
				hr = S_OK;
			}
			break;

			case CIM_CHAR16:
			{
				// As per the XML Spec, the following are invalid character values in an XML Stream:
				// Char ::=  #x9 | #xA | #xD | [#x20-#xD7FF] | [#xE000-#xFFFD] | [#x10000-#x10FFFF]

				// As per the CIM Operations spec, they need to be escaped as follows:
				//	If the value is not a legal XML character
				//  (as defined in [2, section 2.2] by the Char production)
				//	then it MUST be escaped using a \x<hex> escape convention
				//	where <hex> is a hexadecimal constant consisting of
				//	between one and four digits

				curValue.vt = VT_I2;
				if(_wcsnicmp(bsValue, L"\\x", 2) == 0)
					// It is an escaped value
					swscanf (bsValue+2, L"%x", &(curValue.iVal));
				else
					// It is a normal value
					swscanf (bsValue, L"%c", &(curValue.iVal));
				hr = S_OK;
			}
			break;

			case CIM_STRING:
			case CIM_UINT64:
			case CIM_SINT64:
			case CIM_DATETIME:
			{
				curValue.vt = VT_BSTR;
				curValue.bstrVal = SysAllocString (bsValue);
				hr = S_OK;
			}
			break;
		}
	}

	return hr;
}

//***************************************************************************
//
//  HRESULT CXml2Wmi::MapStringArrayValue
//
//  DESCRIPTION:
//
//  Maps XML VALUE.ARRAY element content into its WMI VARIANT equivalent form
//
//  PARAMETERS:
//
//		pValueNode		the VALUE.ARRAY node
//		curValue		Placeholder for new value (set on return)
//		cimtype			for mapping purposes
//
//  RETURN VALUES:
//
//
//***************************************************************************

HRESULT CXml2Wmi::MapStringArrayQualiferValue (
	IXMLDOMNode *pValueNode,
	VARIANT &curValue,
	CIMTYPE cimtype
)
{
	HRESULT hr = WBEM_E_TYPE_MISMATCH;

	// Build a safearray value from the node list
	IXMLDOMNodeList *pValueList = NULL;

	if (SUCCEEDED (pValueNode->get_childNodes (&pValueList)))
	{
		long length = 0;
		pValueList->get_length (&length);
		SAFEARRAYBOUND	rgsabound [1];
		rgsabound [0].lLbound = 0;
		rgsabound [0].cElements = length;
		VARTYPE vt = VTFromCIMType (cimtype & ~CIM_FLAG_ARRAY);
		SAFEARRAY *pArray = NULL;
		if( pArray = SafeArrayCreate (vt, 1, rgsabound))
		{
			IXMLDOMNode *pValue = NULL;
			long ix = 0;
			bool error = false;
			while (!error && SUCCEEDED(pValueList->nextNode(&pValue)) && pValue)
			{
				// Check whether this is a VALUE element
				BSTR strValName = NULL;
				if (SUCCEEDED(pValue->get_nodeName (&strValName)))
				{
					if (0 == _wcsicmp (strValName, VALUE_TAG))
					{
						BSTR bsValue = NULL;
						pValue->get_text (&bsValue);
						if(FAILED(MapStringQualiferValueIntoArray (bsValue, pArray, &ix, vt,
							cimtype & ~CIM_FLAG_ARRAY)))
								error = true;

						SysFreeString (bsValue);
						ix++;
					}
					else
						error = true;

					SysFreeString (strValName);
				}
				else
					error = true;

				pValue->Release ();
				pValue = NULL;
			}

			if(error)
				SafeArrayDestroy(pArray);
			else
			{
				curValue.vt = VT_ARRAY|vt;
				curValue.parray = pArray;
				hr = S_OK;
			}
		}
		else
			hr = E_OUTOFMEMORY;

		pValueList->Release();
	}
	return hr;
}

//***************************************************************************
//
//  HRESULT CXml2Wmi::MapStringValueIntoArray
//
//  DESCRIPTION:
//
//  Maps XML VALUE.ARRAY/VALUE element content into its WMI VARIANT equivalent form
//
//  PARAMETERS:
//
//		bsValue			the VALUE element content
//		pArray			SAFEARRAY in which to map the value
//		ix				index to map the value into
//		vt				VARTYPE of the SAFEARRAY
//		cimtype			for mapping purposes
//
//  RETURN VALUES:
//
//
//***************************************************************************

HRESULT CXml2Wmi::MapStringQualiferValueIntoArray (
	BSTR bsValue,
	SAFEARRAY *pArray,
	long *ix,
	VARTYPE vt,
	CIMTYPE cimtype)
{
	HRESULT hr = E_FAIL;
	switch (vt)
	{
		case VT_UI1:
		{
			BYTE bVal = (BYTE) wcstol (bsValue, NULL, 0);
			hr = SafeArrayPutElement (pArray, ix, &bVal);
		}
		break;

		case VT_I2:
		{
			short iVal;

			if (CIM_CHAR16 == cimtype)
				swscanf (bsValue, L"%c", &(iVal));
			else
				iVal = (short) wcstol (bsValue, NULL, 0);

			hr = SafeArrayPutElement (pArray, ix, &iVal);
		}
		break;

		case VT_I4:
		{
			long lVal = wcstol (bsValue, NULL, 0);
			hr = SafeArrayPutElement (pArray, ix, &lVal);
		}
		break;

		case VT_R4:
		{
			float fltVal = (float) wcstod (bsValue, NULL);
			hr = SafeArrayPutElement (pArray, ix, &fltVal);
		}
		break;

		case VT_R8:
		{
			double dblVal = wcstod (bsValue, NULL);
			hr = SafeArrayPutElement (pArray, ix, &dblVal);
		}
		break;

		case VT_BOOL:
		{
			VARIANT_BOOL boolVal = (0 == _wcsicmp (bsValue, L"TRUE")) ?
						VARIANT_TRUE : VARIANT_FALSE;
			hr = SafeArrayPutElement (pArray, ix, &boolVal);
		}
		break;

		case VT_BSTR:
			// No need to SysAllocString() since SafeArrayPutElement() does this automatically
			hr = SafeArrayPutElement (pArray, ix, bsValue);
			break;
	}
	return hr;
}

//***************************************************************************
//
//  HRESULT CXml2Wmi::VTFromCIMType
//
//  DESCRIPTION:
//
//  Utility function to map CIMTYPE to its VARTYPE equivalent
//
//  PARAMETERS:
//
//		cimtype			the CIMTYPE to be mapped
//
//  RETURN VALUES:
//
//		The corresponding VARTYPE, or VT_NULL if error
//
//***************************************************************************

VARTYPE CXml2Wmi::VTFromCIMType (CIMTYPE cimtype)
{
	VARTYPE vt = VT_NULL;

	switch (cimtype & ~CIM_FLAG_ARRAY)
	{
		case CIM_UINT8:
			vt = VT_UI1;
			break;

		case CIM_SINT8:
		case CIM_SINT16:
			vt = VT_I2;
			break;

		case CIM_UINT16:
		case CIM_UINT32:
		case CIM_SINT32:
			vt = VT_I4;
			break;

		case CIM_REAL32:
			vt = VT_R4;
			break;

		case CIM_REAL64:
			vt = VT_R8;
			break;

		case CIM_BOOLEAN:
			vt = VT_BOOL;
			break;

		case CIM_CHAR16:
			vt = VT_I2;
			break;

		case CIM_STRING:
		case CIM_UINT64:
		case CIM_SINT64:
		case CIM_DATETIME:
			vt = VT_BSTR;
			break;
	}

	return vt;
}

//***************************************************************************
//
//  HRESULT CXmlToWmi::CIMTypeFromString
//
//  DESCRIPTION:
//
//  Utility function to map type attribute string to its CIMTYPE equivalent
//
//  PARAMETERS:
//
//		bsType			the type string to be mapped
//
//  RETURN VALUES:
//
//		The corresponding CIMTYPE, or CIM_ILLEGAL if error
//
//***************************************************************************
CIMTYPE CXml2Wmi::CimtypeFromString (BSTR bsType)
{
	CIMTYPE cimtype = CIM_ILLEGAL;

	if (bsType)
	{
		if (0 == _wcsicmp (bsType, L"string"))
			cimtype = CIM_STRING;
		else if (0 == _wcsicmp (bsType, L"uint32"))
			cimtype = CIM_UINT32;
		else if (0 == _wcsicmp (bsType, L"boolean"))
			cimtype = CIM_BOOLEAN;
		else if (0 == _wcsicmp (bsType, L"sint32"))
			cimtype = CIM_SINT32;
		else if (0 == _wcsicmp (bsType, L"char16"))
			cimtype = CIM_CHAR16;
		else if (0 == _wcsicmp (bsType, L"uint8"))
			cimtype = CIM_UINT8;
		else if (0 == _wcsicmp (bsType, L"uint16"))
			cimtype = CIM_UINT16;
		else if (0 == _wcsicmp (bsType, L"sint16"))
			cimtype = CIM_SINT16;
		else if (0 == _wcsicmp (bsType, L"uint64"))
			cimtype = CIM_UINT64;
		else if (0 == _wcsicmp (bsType, L"sint64"))
			cimtype = CIM_SINT64;
		else if (0 == _wcsicmp (bsType, L"datetime"))
			cimtype = CIM_DATETIME;
		else if (0 == _wcsicmp (bsType, L"real32"))
			cimtype = CIM_REAL32;
		else if (0 == _wcsicmp (bsType, L"real64"))
			cimtype = CIM_REAL64;
	}

	return cimtype;
}


HRESULT CXml2Wmi::MakeObjectAbstract(IWbemClassObject *pObj, IXMLDOMNode *pAbstractQualifierNode)
{
	HRESULT hr = E_FAIL;

	// Get the object qualifeir set
	IWbemQualifierSet *pQuals = NULL;
	if(SUCCEEDED(hr = pObj->GetQualifierSet(&pQuals)))
	{
		// Add the "abstract" qualiifer
		hr = AddQualifier(pAbstractQualifierNode, pQuals);
		pQuals->Release();
	}
	return hr;
}

  */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\xmltransport\server\wmi2xml\xmltowmi.cpp ===
// ***************************************************************************
//
// Copyright (c) 1997-1999 Microsoft Corporation
//
//  XMLTOWMI.CPP
//
//  rajesh  3/25/2000   Created.
//
// Contains the implementation of the component that implements the IXMLWbemConvertor
// interface
//
// ***************************************************************************


#include "precomp.h"
#include <olectl.h>
#include <wbemcli.h>
#include <wbemint.h>

#include "wmiconv.h"
#include "xmlToWmi.h"
#include "maindll.h"

/* !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! 
 * Conversion to Text to Wbem Object has been cut from the WHistler Feature List and hence commented out 
 *!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

// INitialize the class - static variables
LPCWSTR CXml2Wmi::VALUE_TAG					= L"VALUE";
LPCWSTR CXml2Wmi::VALUEARRAY_TAG			= L"VALUE.ARRAY";
LPCWSTR CXml2Wmi::VALUEREFERENCE_TAG		= L"VALUE.REFERENCE";
LPCWSTR CXml2Wmi::CLASS_TAG					= L"CLASS";
LPCWSTR CXml2Wmi::INSTANCE_TAG				= L"INSTANCE";
LPCWSTR CXml2Wmi::CLASSNAME_TAG				= L"CLASSNAME";
LPCWSTR CXml2Wmi::LOCALCLASSPATH_TAG		= L"LOCALCLASSPATH";
LPCWSTR CXml2Wmi::CLASSPATH_TAG				= L"CLASSPATH";
LPCWSTR CXml2Wmi::INSTANCENAME_TAG			= L"INSTANCENAME";
LPCWSTR CXml2Wmi::LOCALINSTANCEPATH_TAG		= L"LOCALINSTANCEPATH";
LPCWSTR CXml2Wmi::INSTANCEPATH_TAG			= L"INSTANCEPATH";
LPCWSTR CXml2Wmi::LOCALNAMESPACEPATH_TAG	= L"LOCALNAMESPACEPATH";
LPCWSTR CXml2Wmi::NAMESPACEPATH_TAG			= L"NAMESPACEPATH";
LPCWSTR CXml2Wmi::KEYBINDING_TAG			= L"KEYBINDING";
LPCWSTR CXml2Wmi::KEYVALUE_TAG				= L"KEYVALUE";
LPCWSTR CXml2Wmi::QUALIFIER_TAG				= L"QUALIFIER";
LPCWSTR CXml2Wmi::PARAMETER_TAG				= L"PARAMETER";
LPCWSTR CXml2Wmi::PARAMETERARRAY_TAG		= L"PARAMETER.ARRAY";
LPCWSTR CXml2Wmi::PARAMETERREFERENCE_TAG	= L"PARAMETER.REFERENCE";
LPCWSTR CXml2Wmi::PARAMETERREFARRAY_TAG		= L"PARAMETER.REFARRAY";
LPCWSTR CXml2Wmi::PARAMETEROBJECT_TAG		= L"PARAMETER.OBJECT";
LPCWSTR CXml2Wmi::PARAMETEROBJECTARRAY_TAG	= L"PARAMETER.OBJECTARRAY";
LPCWSTR CXml2Wmi::REF_WSTR					= L"ref";
LPCWSTR CXml2Wmi::OBJECT_WSTR				= L"object";
LPCWSTR CXml2Wmi::EQUALS_SIGN				= L"=";
LPCWSTR CXml2Wmi::QUOTE_SIGN				= L"\"";
LPCWSTR CXml2Wmi::DOT_SIGN					= L".";
LPCWSTR CXml2Wmi::COMMA_SIGN				= L",";

extern long g_cObj;

CXml2Wmi::CXml2Wmi()
{
	m_cRef = 0;
    InterlockedIncrement(&g_cObj);
}

CXml2Wmi::~CXml2Wmi()
{
    InterlockedDecrement(&g_cObj);
}

STDMETHODIMP CXml2Wmi::QueryInterface (

	IN REFIID riid,
    OUT LPVOID *ppv
)
{
    *ppv=NULL;

    if (IID_IUnknown==riid)
		*ppv = reinterpret_cast<IUnknown*>(this);
	else if (IID_IXMLWbemConvertor==riid)
		*ppv = reinterpret_cast<IXMLWbemConvertor*>(this);

    if (NULL!=*ppv)
    {
        ((LPUNKNOWN)*ppv)->AddRef();
        return NOERROR;
    }

    return ResultFromScode(E_NOINTERFACE);
}

STDMETHODIMP_(ULONG) CXml2Wmi::AddRef(void)
{
    InterlockedIncrement(&m_cRef);
    return m_cRef;
}

STDMETHODIMP_(ULONG) CXml2Wmi::Release(void)
{
    InterlockedDecrement(&m_cRef);
    if (0L!=m_cRef)
        return m_cRef;
    delete this;
    return 0;
}

// This function maps an IXMLDOMNode that represents a CLASS or an INSTANCE
// to an IWbemClassObject. The caller should Release() this object when done with it
HRESULT CXml2Wmi::MapObjectToWMI(IUnknown *pXmlDOMNode, IWbemContext *pInputFlags,  
								 BSTR strNamespace, BSTR strServer, IWbemClassObject **ppObject)
{
	HRESULT result = E_FAIL;

	// Get the IXMLDOMElement interface from the input object
	IXMLDOMElement *pObjectNode = NULL;
	if(SUCCEEDED(result = pXmlDOMNode->QueryInterface(IID_IXMLDOMElement, (LPVOID *)&pObjectNode)))
	{
		BSTR strDocName = NULL;
		if(SUCCEEDED(result = pObjectNode->get_nodeName(&strDocName)))
		{
			// This has to be an INSTANCE or a CLASS
			if(_wcsicmp(strDocName, L"CLASS") == 0)
				result = CXml2Wmi::MapClass(pObjectNode, ppObject, strNamespace, strServer, false, true);
			else if(_wcsicmp(strDocName, L"INSTANCE") == 0)
				result = CXml2Wmi::MapInstance(pObjectNode, ppObject, strNamespace, strServer, true);
			else 
				result = WBEM_E_INVALID_SYNTAX;
			SysFreeString(strDocName);
		}
		pObjectNode->Release();
	}
	return result;
}

HRESULT CXml2Wmi::MapPropertyToWMI(IUnknown *pXmlDOMNode, IWbemClassObject *pObject, BSTR strPropertyName, IWbemContext *pInputFlags)
{
	return E_FAIL;
}

HRESULT CXml2Wmi::MapInstanceNameToWMI(IUnknown *pXmlDOMNode, IWbemContext *pInputFlags, BSTR *pstrInstanceName)
{
	HRESULT hr = E_FAIL;
	// Get the IXMLDOMElement interface from the input object
	IXMLDOMNode *pNode = NULL;
	if(SUCCEEDED(hr = pXmlDOMNode->QueryInterface(IID_IXMLDOMNode, (LPVOID *)&pNode)))
	{
		LPWSTR pszName = NULL;
		if(SUCCEEDED(hr = MapInstanceName(pNode, &pszName)))
		{
			*pstrInstanceName = NULL;
			if((*pstrInstanceName) = SysAllocString(pszName))
			{
			}
			else
				hr = E_OUTOFMEMORY;
			delete [] pszName;
		}
		pNode->Release();
	}
	return hr;
}

HRESULT CXml2Wmi::MapClassNameToWMI(IUnknown *pXmlDOMNode, IWbemContext *pInputFlags, BSTR *pstrClassName)
{
	HRESULT hr = E_FAIL;
	// Get the IXMLDOMElement interface from the input object
	IXMLDOMNode *pNode = NULL;
	if(SUCCEEDED(hr = pXmlDOMNode->QueryInterface(IID_IXMLDOMNode, (LPVOID *)&pNode)))
	{
		LPWSTR pszName = NULL;
		if(SUCCEEDED(hr = MapClassName(pNode, &pszName)))
		{
			*pstrClassName = NULL;
			if((*pstrClassName) = SysAllocString(pszName))
			{
			}
			else
				hr = E_OUTOFMEMORY;
			delete [] pszName;
		}
		pNode->Release();
	}
	return hr;
}

HRESULT CXml2Wmi::MapInstancePathToWMI(IUnknown *pXmlDOMNode, IWbemContext *pInputFlags, BSTR *pstrInstancePath)
{
	HRESULT hr = E_FAIL;
	// Get the IXMLDOMElement interface from the input object
	IXMLDOMNode *pNode = NULL;
	if(SUCCEEDED(hr = pXmlDOMNode->QueryInterface(IID_IXMLDOMNode, (LPVOID *)&pNode)))
	{
		LPWSTR pszName = NULL;
		if(SUCCEEDED(hr = MapInstancePath(pNode, &pszName)))
		{
			*pstrInstancePath = NULL;
			if((*pstrInstancePath) = SysAllocString(pszName))
			{
			}
			else
				hr = E_OUTOFMEMORY;
			delete [] pszName;
		}
		pNode->Release();
	}
	return hr;
}

HRESULT CXml2Wmi::MapClassPathToWMI(IUnknown *pXmlDOMNode, IWbemContext *pInputFlags, BSTR *pstrClassPath)
{
	HRESULT hr = E_FAIL;
	// Get the IXMLDOMElement interface from the input object
	IXMLDOMNode *pNode = NULL;
	if(SUCCEEDED(hr = pXmlDOMNode->QueryInterface(IID_IXMLDOMNode, (LPVOID *)&pNode)))
	{
		LPWSTR pszName = NULL;
		if(SUCCEEDED(hr = MapClassPath(pNode, &pszName)))
		{
			*pstrClassPath = NULL;
			if((*pstrClassPath) = SysAllocString(pszName))
			{
			}
			else
				hr = E_OUTOFMEMORY;
			delete [] pszName;
		}
		pNode->Release();
	}
	return hr;
}



HRESULT CXml2Wmi::MapClass (
	IXMLDOMElement *pXml,
	IWbemClassObject **ppClass,
	BSTR strSpecifiedNamespace, BSTR strSpecifiedServer, 
	bool bMakeInstance,
	bool bAllowWMIExtensions
)
{
	// This function expects either a <CLASS> document or an <INSTANCE> document
	// When it gets an INSTANCE element, it assumes that the property values
	// are default values for the class properties
	HRESULT hr = E_FAIL;
	*ppClass = NULL;
	if(pXml && ppClass)
	{
		// Create a Free Form Object
		_IWmiFreeFormObject *pObj = NULL;
		if(SUCCEEDED(hr = g_pObjectFactory->Create(NULL, 0, CLSID__WmiFreeFormObject, IID__IWmiFreeFormObject, (LPVOID *)&pObj)))
		{
			// Add the properties of the object
			// Note that we cannot add methods and qualifiers to a free form object
			// So we only add properties, and then use the IWbemClassObject interface
			// to add methods and qualifiers
			// Also, Get the __NAMESPACE and __SERVER at this time
			BSTR strServer = NULL, strNamespace = NULL;
			IXMLDOMNode *pAbstractQualifierNode = NULL;
			if(SUCCEEDED(hr = CreateWMIProperties(bAllowWMIExtensions, pObj, pXml, bMakeInstance, &strServer, &strNamespace, &pAbstractQualifierNode)))
			{
				// Now we switch over to IWbemClassObject since we possibly need it from now
				IWbemClassObject *pClass = NULL;
				if(SUCCEEDED(hr = pObj->QueryInterface(IID_IWbemClassObject, (LPVOID *)&pClass)))
				{
					// Special case for abstract classes
					// If a class is abstract, we need to set the abstract qualifier on the class
					// before calling SetDerivation() as per Sanj's rules
					// Hence we do it at this time, if applicable
					if(pAbstractQualifierNode)
					{
						hr = MakeObjectAbstract(pClass, pAbstractQualifierNode);
						pAbstractQualifierNode->Release();
					}

					// Set the name of the class first
					if(SUCCEEDED(hr) && SUCCEEDED(hr = SetDerivationAndClassName(pObj, pXml, bMakeInstance)))
					{
						// Decorate the object
						if(SUCCEEDED(hr = DecorateObject(pObj, (strSpecifiedServer)? strSpecifiedServer : strServer, (strSpecifiedNamespace)? strSpecifiedNamespace : strNamespace)))
						{
							// 1. Add methods
							if(SUCCEEDED(hr = CreateWMIMethods(bAllowWMIExtensions, pClass, pXml)))
							{
								// 2. Add Qualifiers
								if(SUCCEEDED(hr = AddObjectQualifiers(bAllowWMIExtensions, pXml, pClass)))
								{
									// 3. Convert weak property refs and embedded objects to strong ones
									// We could not do this on free-form objects, while adding the properties
									if(SUCCEEDED(hr = FixRefsAndEmbeddedObjects(pXml, pClass)))
									{
										*ppClass = pClass;
										pClass->AddRef();
									}
								}
							}
						}
					}
					pClass->Release();
				}
				SysFreeString(strServer);
				SysFreeString(strNamespace);
			}
			pObj->Release();
		}
	}
	return hr;
}

// This function sets the class name of a class 
// and its derivation if any
HRESULT CXml2Wmi::SetDerivationAndClassName(_IWmiFreeFormObject *pObj, IXMLDOMElement *pXML, bool bMakeInstance)
{
	HRESULT hr = S_OK;

	// First set the derivation
	BSTR strSuperClassName = NULL;
	if(SUCCEEDED(GetBstrAttribute(pXML, g_strSuperClass, &strSuperClassName)))
	{
		hr = pObj->SetDerivation(0, 1, strSuperClassName);
		SysFreeString(strSuperClassName);
	}

	// Next set the class name
	BSTR strName = NULL;
	if(bMakeInstance)
		hr = GetBstrAttribute(pXML, g_strClassName, &strName);
	else
		hr = GetBstrAttribute(pXML, g_strName, &strName);

	if(SUCCEEDED(hr))
	{
		hr = pObj->SetClassName(0, strName);
		SysFreeString(strName);
	}
	else
		hr = WBEM_E_INVALID_SYNTAX; // We could not get the NAME attribute on the <CLASS>
	return hr;
}

HRESULT CXml2Wmi::MapInstance (
	IXMLDOMElement *pXml,
	IWbemClassObject **ppInstance,
	BSTR strNamespace, BSTR strServer,
	bool bAllowWMIExtensions
)
{
	HRESULT hr = E_FAIL;
	if(SUCCEEDED(hr = MapClass(pXml, ppInstance, strNamespace, strServer, true, bAllowWMIExtensions)))
	{
		// Make it an instance
		_IWmiFreeFormObject *pFreeForm = NULL;
		if(SUCCEEDED(hr = (*ppInstance)->QueryInterface(IID__IWmiFreeFormObject, (LPVOID *)&pFreeForm)))
		{
			if(SUCCEEDED(hr = pFreeForm->MakeInstance(0)))
			{
			}
			pFreeForm->Release();
		}
	}
	return hr;
}

// Creates all the properties in a class/instance
// All strongly typed ref properties and embedded properties are mapped as
// weakly typed ones since the free-form object allows only such properties
HRESULT CXml2Wmi::CreateWMIProperties(bool bAllowWMIExtensions, 
									  _IWmiFreeFormObject *pObj, IXMLDOMElement *pXML, 
									  bool bMakeInstance, 
									  BSTR *pstrServer, BSTR *pstrNamespace, 
									  IXMLDOMNode **ppAbstractQualifierNode)
{
	HRESULT hr = E_FAIL;

	// Go thru all the properties of the class
	IXMLDOMNodeList *pNodeList = NULL;
	bool bError = false;
	if (SUCCEEDED(pXML->get_childNodes (&pNodeList)))
	{
		IXMLDOMNode *pNode = NULL;
		while (!bError && SUCCEEDED(pNodeList->nextNode (&pNode)) &&pNode)
		{
			// We're interested only in simple properties, embedded objects, ref properties
			// and arrays of such types
			BSTR strNodeName = NULL;
			if (SUCCEEDED(pNode->get_nodeName (&strNodeName)))
			{
				if(_wcsicmp(strNodeName, L"PROPERTY") == 0 ||
					_wcsicmp(strNodeName, L"PROPERTY.ARRAY") == 0 ||
					_wcsicmp(strNodeName, L"PROPERTY.REFERENCE") == 0 ||
					_wcsicmp(strNodeName, L"PROPERTY.REFARRAY") == 0 ||
					(_wcsicmp(strNodeName, L"PROPERTY.OBJECT") == 0  && bAllowWMIExtensions)||
					(_wcsicmp(strNodeName, L"PROPERTY.OBJECTARRAY") == 0 && bAllowWMIExtensions))
				{
					IXMLDOMElement *pPropElement = NULL;
					if(SUCCEEDED(hr = pNode->QueryInterface(IID_IXMLDOMElement, (LPVOID *)&pPropElement)))
					{
						BSTR strName = NULL;
						// Get the Name of the property
						if(SUCCEEDED(hr = GetBstrAttribute(pPropElement, g_strName, &strName)))
						{
							// See if it is one of the Decorative Properties
							if(_wcsicmp(strName, L"__NAMESPACE") == 0)
								pPropElement->get_text(pstrNamespace);
							else if(_wcsicmp(strName, L"__SERVER") == 0)
								pPropElement->get_text(pstrServer);
							else if(_wcsnicmp(strName, L"__", 2) == 0)
							{
								// Ignore other system properties
							}
							else if(FAILED(hr = CreateAWMIProperty(strNodeName, pObj, pPropElement, strName, bMakeInstance)))
								bError = true;
							SysFreeString(strName);
						}
						else
						{
							hr = WBEM_E_INVALID_SYNTAX;
							bError = true;
						}
						pPropElement->Release();
					}
					else
						bError = true;
				}
				// We need to check if this class is an abstract class
				else if(_wcsicmp(strNodeName, L"QUALIFIER") == 0)
				{
					// Get the Name of the Qualifier
					BSTR strQualifierName = NULL;
					if(SUCCEEDED(GetBstrAttribute (pNode, g_strName, &strQualifierName)))
					{
						// We're looking for the "abstract" qualifier
						if(_wcsicmp(strQualifierName, L"abstract") == 0)
						{
							*ppAbstractQualifierNode = pNode;
							pNode->AddRef();
						}
						SysFreeString(strQualifierName);
					}
				}

				SysFreeString(strNodeName);
			}
			pNode->Release();
			pNode = NULL;
		}
		pNodeList->Release();
	}

	if(bError)
		return hr;
	return S_OK;
}

HRESULT CXml2Wmi::CreateAWMIProperty(BSTR strNodeName, _IWmiFreeFormObject *pObj, IXMLDOMElement *pXML, BSTR strName, bool bMakeInstance)
{
	HRESULT hr = E_FAIL;
	BSTR strClassOrigin = NULL;

	// No need to check whether this was successful - ClassOrigin info is optional.
	GetBstrAttribute(pXML, g_strClassOrigin, &strClassOrigin);

	if(_wcsicmp(strNodeName, L"PROPERTY") == 0)
		hr = CreateSimpleProperty(strName, pObj, pXML, strClassOrigin, bMakeInstance);
	else if(_wcsicmp(strNodeName, L"PROPERTY.ARRAY") == 0)
		hr = CreateArrayProperty(strName, pObj, pXML, strClassOrigin, bMakeInstance);
	else if(_wcsicmp(strNodeName, L"PROPERTY.REFERENCE") == 0)
		hr = CreateReferenceProperty(strName, pObj, pXML, strClassOrigin, bMakeInstance);
	else if(_wcsicmp(strNodeName, L"PROPERTY.REFARRAY") == 0)
		hr = CreateRefArrayProperty(strName, pObj, pXML, strClassOrigin, bMakeInstance);
	else if(_wcsicmp(strNodeName, L"PROPERTY.OBJECT") == 0)
		hr = CreateObjectProperty(strName, pObj, pXML, strClassOrigin, bMakeInstance);
	else if(_wcsicmp(strNodeName, L"PROPERTY.OBJECTARRAY") == 0)
		hr = CreateObjectArrayProperty(strName, pObj, pXML, strClassOrigin, bMakeInstance);
	else 
		hr = WBEM_E_INVALID_PROPERTY;

	SysFreeString(strClassOrigin);
	return hr;
}

HRESULT CXml2Wmi::CreateSimpleProperty(LPCWSTR pszName, _IWmiFreeFormObject *pObj, IXMLDOMElement *pXML, LPCWSTR pszClassOrigin, bool bMakeInstance)
{
	HRESULT hr = WBEM_E_INVALID_SYNTAX;
	BSTR strType = NULL;
	// Get the Type of the property
	if(SUCCEEDED(hr = GetBstrAttribute(pXML, g_strType, &strType)))
	{
		// Get the Value of the Property - this value is optional
		BSTR strValue = NULL;
		IXMLDOMElement *pValue = NULL;
		if(SUCCEEDED(hr = GetFirstImmediateElement(pXML, &pValue, L"VALUE")))
		{
			// This is a simple property - its text value should be enough for mapping
			hr = pValue->get_text(&strValue);
			pValue->Release();
		}
		else
			hr = S_OK;


		if(SUCCEEDED(hr))
		{
			if(_wcsicmp(strType, L"boolean") == 0)
				hr = MapStringValue(pszName, pObj, strValue, CIM_BOOLEAN, pszClassOrigin, bMakeInstance);
			else if(_wcsicmp(strType, L"string") == 0)
				hr = MapStringValue(pszName, pObj, strValue, CIM_STRING, pszClassOrigin, bMakeInstance);
			else if(_wcsicmp(strType, L"char16") == 0)
				hr = MapStringValue(pszName, pObj, strValue, CIM_CHAR16, pszClassOrigin, bMakeInstance);
			else if(_wcsicmp(strType, L"uint8") == 0)
				hr = MapStringValue(pszName, pObj, strValue, CIM_UINT8, pszClassOrigin, bMakeInstance);
			else if(_wcsicmp(strType, L"sint8") == 0)
				hr = MapStringValue(pszName, pObj, strValue, CIM_SINT8, pszClassOrigin, bMakeInstance);
			else if(_wcsicmp(strType, L"uint16") == 0)
				hr = MapStringValue(pszName, pObj, strValue, CIM_UINT16, pszClassOrigin, bMakeInstance);
			else if(_wcsicmp(strType, L"sint16") == 0)
				hr = MapStringValue(pszName, pObj, strValue, CIM_SINT16, pszClassOrigin, bMakeInstance);
			else if(_wcsicmp(strType, L"uint32") == 0)
				hr = MapStringValue(pszName, pObj, strValue, CIM_UINT32, pszClassOrigin, bMakeInstance);
			else if(_wcsicmp(strType, L"sint32") == 0)
				hr = MapStringValue(pszName, pObj, strValue, CIM_SINT32, pszClassOrigin, bMakeInstance);
			else if(_wcsicmp(strType, L"uint64") == 0)
				hr = MapStringValue(pszName, pObj, strValue, CIM_UINT64, pszClassOrigin, bMakeInstance);
			else if(_wcsicmp(strType, L"sint64") == 0)
				hr = MapStringValue(pszName, pObj, strValue, CIM_SINT64, pszClassOrigin, bMakeInstance);
			else if(_wcsicmp(strType, L"datetime") == 0)
				hr = MapStringValue(pszName, pObj, strValue, CIM_DATETIME, pszClassOrigin, bMakeInstance);
			else if(_wcsicmp(strType, L"real32") == 0)
				hr = MapStringValue(pszName, pObj, strValue, CIM_REAL32, pszClassOrigin, bMakeInstance);
			else if(_wcsicmp(strType, L"real64") == 0)
				hr = MapStringValue(pszName, pObj, strValue, CIM_REAL64, pszClassOrigin, bMakeInstance);
			else
				hr = WBEM_E_INVALID_PROPERTY;
		}

		SysFreeString(strValue);
		SysFreeString(strType);
	}
	else
		hr = WBEM_E_INVALID_SYNTAX;
	return hr;
}

HRESULT CXml2Wmi::MapStringValue (LPCWSTR pszName, _IWmiFreeFormObject *pObj, BSTR bsValue, CIMTYPE cimtype, LPCWSTR pszClassOrigin, bool bMakeInstance)
{
	// RAJESHR First we need to remove any CDATA section from the string value
	// Even though the WMI implementation used CDATA (if necessary) only for CIM_STRING and CIM_DATETIME,
	// other implementations might use a CDATA to escape other values as well

	long lFlag = (bMakeInstance) ? WMIOBJECT_FREEFORM_FLAG_WRITE_TO_INSTANCE : 0;

	// If there is no value then it is simple - we just need to create a property of the appropriate type
	if(!bsValue)
		return pObj->AddProperty(pszName, lFlag, 0, 0, cimtype, NULL);


	// We create a value - buffer representations as required by the IWmiFreeFormObject interface
	HRESULT hr = WBEM_E_TYPE_MISMATCH;
	// We're assuming it's not an array
	if (!(cimtype & CIM_FLAG_ARRAY))
	{
		switch (cimtype)
		{
			// RAJESHR - more rigorous syntax checking
			case CIM_UINT8:
			case CIM_SINT8:
			{
				BYTE iVal = 0;
				int x;
				if(swscanf(bsValue, L"%d", &x))
				{
					iVal = (BYTE)x;
					hr = pObj->AddProperty(pszName, lFlag, 1, 1, cimtype, &iVal);
				}
				else
					hr = E_FAIL;
			}
			break;

			case CIM_UINT16:
			case CIM_SINT16:
			{
				SHORT iVal = 0;
				iVal = (SHORT) wcstol (bsValue, NULL, 0);
				hr = pObj->AddProperty(pszName, lFlag, 2, 1, cimtype, &iVal);
			}
			break;

			case CIM_UINT32:
			case CIM_SINT32:
			{
				LONG iVal = 0;
				iVal = (LONG) wcstol (bsValue, NULL, 0);
				hr = pObj->AddProperty(pszName, lFlag, 4, 1, cimtype, &iVal);
			}
			break;

			case CIM_REAL32:
			{
				float fVal = 0;
				fVal = (float) wcstod (bsValue, NULL);
				hr = pObj->AddProperty(pszName, lFlag, 4, 1, cimtype, &fVal);
			}
			break;

			case CIM_REAL64:
			{
				double fVal = 0;
				fVal = (double) wcstod (bsValue, NULL);
				hr = pObj->AddProperty(pszName, lFlag, 8, 1, cimtype, &fVal);
			}
			break;

			case CIM_BOOLEAN:
			{
				SHORT bVal = 0;
				if (0 == _wcsicmp (bsValue, L"TRUE"))
					bVal = 1;
				hr = pObj->AddProperty(pszName, lFlag, 2, 1, cimtype, &bVal);
			}
			break;

			case CIM_CHAR16:
			{
				// As per the XML Spec, the following are invalid character values in an XML Stream:
				// Char ::=  #x9 | #xA | #xD | [#x20-#xD7FF] | [#xE000-#xFFFD] | [#x10000-#x10FFFF]

				// As per the CIM Operations spec, they need to be escaped as follows:
				//	If the value is not a legal XML character
				//  (as defined in [2, section 2.2] by the Char production)
				//	then it MUST be escaped using a \x<hex> escape convention
				//	where <hex> is a hexadecimal constant consisting of
				//	between one and four digits

				SHORT cVal = 0;
				if(_wcsnicmp(bsValue, L"\\x", 2) == 0)
					// It is an escaped value
					swscanf (bsValue+2, L"%x", &(cVal));
				else
					// It is a normal value
					swscanf (bsValue, L"%c", &(cVal));
				hr = pObj->AddProperty(pszName, lFlag,2, 1, cimtype, &cVal);
			}
			break;

			case CIM_UINT64:
			case CIM_SINT64:
				{
					__int64 iVal = 0;
					if(swscanf(bsValue, L"%I64d", &iVal))
					{
						hr = pObj->AddProperty(pszName, lFlag, 8, 1, cimtype, &iVal);
					}
					else hr = E_FAIL;
				}
			break;

			case CIM_STRING:
			case CIM_DATETIME:
			{
				hr = pObj->AddProperty(pszName, lFlag, (wcslen(bsValue) + 1)*2, 1, cimtype, bsValue);
			}
			break;
		}
	}

	return hr;
}


HRESULT CXml2Wmi::MapStringArrayValue (
	LPCWSTR pszName,
	_IWmiFreeFormObject *pObj,
	IXMLDOMElement *pValueArrayNode,
	CIMTYPE cimtype,
	LPCWSTR pszClassOrigin, bool bMakeInstance)
{
	HRESULT hr = WBEM_E_TYPE_MISMATCH;
	long lFlag = (bMakeInstance) ? WMIOBJECT_FREEFORM_FLAG_WRITE_TO_INSTANCE : 0;

	// If there is no value then it is simple - we just need to create a property of the appropriate type
	if(!pValueArrayNode)
		return pObj->AddProperty(pszName, lFlag, 0, 0, cimtype|CIM_FLAG_ARRAY, NULL);


	switch(cimtype)
	{
		// We need to separate this into a NULL separated string
		case CIM_STRING:
		{
			// We need to get its text for calculating the length of
			// the buffer required
			BSTR bsValue = NULL;
			if(SUCCEEDED(hr = pValueArrayNode->get_text (&bsValue)))
			{
				// Go thru the child nodes
				IXMLDOMNodeList *pValueList = NULL;
				if (SUCCEEDED (pValueArrayNode->get_childNodes (&pValueList)))
				{
					// It's length is calculated this way
					LONG lArraylength = 0;
					// No of strings - One NULL character for each string
					pValueList->get_length (&lArraylength);
					// Plus the actual content
					LONG length = lArraylength + wcslen(bsValue);

					// Allocate the string
					LPWSTR pszValue = NULL;
					if(pszValue = new WCHAR[length + 1])
					{
						pszValue[0] = NULL;

						// Now fill up the array
						IXMLDOMNode *pValue = NULL;
						bool error = false;
						ULONG dwBufferLen = 0;

						// Get the next VALUE element
						while (!error &&
								SUCCEEDED(pValueList->nextNode(&pValue)) && pValue)
						{
							BSTR strValName = NULL;
							if (SUCCEEDED(pValue->get_nodeName (&strValName)))
							{
								if (0 == _wcsicmp (strValName, L"VALUE"))
								{
									// Get the value of the string
									BSTR bsStringValue = NULL;
									if(SUCCEEDED(pValue->get_text (&bsStringValue)))
									{
										// Concatenate it to the list we're building
										wcscat(pszValue + dwBufferLen, bsStringValue);
										dwBufferLen += (wcslen(bsStringValue) + 1);
										pszValue[dwBufferLen] = NULL;
									}
									else
										error = true;
									SysFreeString (bsStringValue);
								}
								else
								{
									// unexpected element
									error = true;
								}

								SysFreeString (strValName);
							}
							else
								error = true;

							pValue->Release ();
							pValue = NULL;
						}

						if(!error)
						{
							hr = pObj->AddProperty(pszName, lFlag, dwBufferLen*2, lArraylength, cimtype|CIM_FLAG_ARRAY, pszValue);
						}
						else
							hr = E_FAIL;
						delete [] pszValue;
					}
					else
						hr = E_OUTOFMEMORY;
					pValueList->Release();
				}
				SysFreeString(bsValue);
			}
		}
		break;
		case CIM_DATETIME:
		{
			// This needs to be an array of primitive values
			// Go thru the child nodes
			IXMLDOMNodeList *pValueList = NULL;
			if (SUCCEEDED (pValueArrayNode->get_childNodes (&pValueList)))
			{
				// It's length is calculated this way
				LONG lArrayLength = 0;
				// No of strings - One NULL character for each string
				pValueList->get_length (&lArrayLength);
				// Plus the actual content
				LONG length = lArrayLength*25 + lArrayLength; // 25 is the lenght of CIM_DATETIME

				// Allocate the string
				LPWSTR pszValue = NULL;
				if(pszValue = new WCHAR[length + 1])
				{
					pszValue[0] = NULL;

					// Now fill up the array
					IXMLDOMNode *pValue = NULL;
					bool error = false;
					ULONG dwBufferLen = 0;

					// Get the next VALUE element
					while (!error &&
							SUCCEEDED(pValueList->nextNode(&pValue)) && pValue)
					{
						BSTR strValName = NULL;
						if (SUCCEEDED(pValue->get_nodeName (&strValName)))
						{
							if (0 == _wcsicmp (strValName, VALUE_TAG))
							{
								// Get the value of the string
								BSTR bsValue = NULL;
								if(SUCCEEDED(pValue->get_text (&bsValue)))
								{
									// Concatenate it to the list we're building
									wcscat(pszValue + dwBufferLen, bsValue);
									dwBufferLen += (wcslen(bsValue) + 1);
									pszValue[dwBufferLen] = NULL;
								}
								else
									error = true;
								SysFreeString (bsValue);
							}
							else
							{
								// unexpected element
								error = true;
							}

							SysFreeString (strValName);
						}
						else
							error = true;

						pValue->Release ();
						pValue = NULL;
					}

					if(!error)
					{
						hr = pObj->AddProperty(pszName, lFlag, dwBufferLen*2, lArrayLength, cimtype|CIM_FLAG_ARRAY, pszValue);
					}
					else
						hr = E_FAIL;
					delete [] pszValue;
				}
				else
					hr = E_OUTOFMEMORY;
				pValueList->Release();
			}
		}
		break;
		case CIM_BOOLEAN:
		{
			// This needs to be an array of primitive values
			// Go thru the child nodes
			IXMLDOMNodeList *pValueList = NULL;
			if (SUCCEEDED (pValueArrayNode->get_childNodes (&pValueList)))
			{
				// Get the number of child elements - this should be the lenght of the array required
				LONG lArraylength = 0;
				pValueList->get_length (&lArraylength);

				// Allocate the string
				SHORT *pszValue = NULL;
				if(pszValue = new SHORT[lArraylength])
				{
					// Now fill up the array
					IXMLDOMNode *pValue = NULL;
					bool error = false;

					LONG lIndex = 0;
					// Get the next VALUE element
					while (!error &&
							SUCCEEDED(pValueList->nextNode(&pValue)) && pValue)
					{
						BSTR strValName = NULL;
						if (SUCCEEDED(pValue->get_nodeName (&strValName)))
						{
							if (0 == _wcsicmp (strValName, VALUE_TAG))
							{
								// Get the value of the string
								BSTR bsValue = NULL;
								if(SUCCEEDED(pValue->get_text (&bsValue)))
								{
									pszValue[lIndex] = 0;
									if (0 == _wcsicmp (bsValue, L"TRUE"))
										pszValue[lIndex] = 1;
									lIndex++;
								}
								else
									error = true;
								SysFreeString (bsValue);
							}
							else
							{
								// unexpected element
								error = true;
							}

							SysFreeString (strValName);
						}
						else
							error = true;

						pValue->Release ();
						pValue = NULL;
					}

					if(!error)
					{
						hr = pObj->AddProperty(pszName, lFlag, lArraylength*2, lArraylength, cimtype|CIM_FLAG_ARRAY, pszValue);
					}
					else
						hr = E_FAIL;
					delete [] pszValue;
				}
				else
					hr = E_OUTOFMEMORY;
				pValueList->Release();
			}
		}
		break;
		case CIM_UINT8:
		case CIM_SINT8:
		{
			// This needs to be an array of primitive values
			// Go thru the child nodes
			IXMLDOMNodeList *pValueList = NULL;
			if (SUCCEEDED (pValueArrayNode->get_childNodes (&pValueList)))
			{
				// Get the number of child elements - this should be the lenght of the array required
				LONG lArraylength = 0;
				pValueList->get_length (&lArraylength);

				// Allocate the array
				LPBYTE pszValue = NULL;
				if(pszValue = new BYTE[lArraylength])
				{
					// Now fill up the array
					IXMLDOMNode *pValue = NULL;
					bool error = false;

					LONG lIndex = 0;
					// Get the next VALUE element
					while (!error &&
							SUCCEEDED(pValueList->nextNode(&pValue)) && pValue)
					{
						BSTR strValName = NULL;
						if (SUCCEEDED(pValue->get_nodeName (&strValName)))
						{
							if (0 == _wcsicmp (strValName, VALUE_TAG))
							{
								// Get the value of the string
								BSTR bsValue = NULL;
								if(SUCCEEDED(pValue->get_text (&bsValue)))
								{
									pszValue[lIndex] = 0;
									pszValue[lIndex++] = (BYTE) wcstol (bsValue, NULL, 0);
								}
								else
									error = true;
								SysFreeString (bsValue);
							}
							else
							{
								// unexpected element
								er