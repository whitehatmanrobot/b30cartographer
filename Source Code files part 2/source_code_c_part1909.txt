eap - Supplies a pointer to the heap being modified

Return Value:

    PHEAP_FREE_ENTRY - returns a pointer to the largest free block
        in the heap

--*/

{
    SIZE_T OldFreeSize;
    SIZE_T FreeSize;
    ULONG n;
    PHEAP_FREE_ENTRY FreeBlock, LargestFreeBlock;
    PLIST_ENTRY FreeListHead, Next;

    RTL_PAGED_CODE();

    LargestFreeBlock = NULL;

    //
    //  For every free list in the heap, going from smallest to
    //  largest and skipping the zero index one we will
    //  scan the free list coalesceing the free blocks
    //

    FreeListHead = &Heap->FreeLists[ 1 ];

    n = HEAP_MAXIMUM_FREELISTS;

    while (n--) {

        //
        //  Scan the individual free list
        //

        Next = FreeListHead->Blink;

        while (FreeListHead != Next) {

            //
            //  Get a pointer to the current free list entry, and remember its
            //  next and size
            //

            FreeBlock = CONTAINING_RECORD( Next, HEAP_FREE_ENTRY, FreeList );

            Next = Next->Flink;
            OldFreeSize = FreeSize = FreeBlock->Size;

            //
            //  Coalesce the block
            //

            FreeBlock = RtlpCoalesceFreeBlocks( Heap,
                                                FreeBlock,
                                                &FreeSize,
                                                TRUE );

            //
            //  If the new free size is not equal to the old free size
            //  then we actually did some changes otherwise the coalesce
            //  calll was essentialy a noop
            //

            if (FreeSize != OldFreeSize) {

                //
                //  Check if we should decommit this block because it is too
                //  large and it is either at the beginning or end of a
                //  committed run.  Otherwise just insert the new sized
                //  block into its corresponding free list.  We'll hit this
                //  block again when we visit larger free lists.
                //

                if (FreeBlock->Size >= (PAGE_SIZE >> HEAP_GRANULARITY_SHIFT)

                        &&

                    (FreeBlock->PreviousSize == 0 ||
                     (FreeBlock->Flags & HEAP_ENTRY_LAST_ENTRY))) {

                    RtlpDeCommitFreeBlock( Heap, FreeBlock, FreeSize );

                } else {

                    RtlpInsertFreeBlock( Heap, FreeBlock, FreeSize );
                }

                Next = FreeListHead->Blink;

            } else {

                //
                //  Remember the largest free block we've found so far
                //

                if ((LargestFreeBlock == NULL) ||
                    (LargestFreeBlock->Size < FreeBlock->Size)) {

                    LargestFreeBlock = FreeBlock;
                }
            }
        }

        //
        //  Go to the next free list.  When we hit the largest dedicated
        //  size free list we'll fall back to the [0] index list
        //

        if (n == 1) {

            FreeListHead = &Heap->FreeLists[ 0 ];

        } else {

            FreeListHead++;
        }
    }

    //
    //  And return to our caller
    //

    return LargestFreeBlock;
}



SIZE_T
RtlDebugCompactHeap (
    IN PVOID HeapHandle,
    IN ULONG Flags
    )

/*++

Routine Description:

Arguments:

Return Value:

--*/

{
    PHEAP Heap = (PHEAP)HeapHandle;
    BOOLEAN LockAcquired = FALSE;
    SIZE_T LargestFreeSize;

#if 0

    IF_DEBUG_PAGE_HEAP_THEN_RETURN( HeapHandle,
                                    RtlpDebugPageHeapCompact( HeapHandle, Flags ));

#endif // 0

    LargestFreeSize = 0;

    try {

        try {

            //
            //  Validate that HeapAddress points to a HEAP structure.
            //

            if (!RtlpCheckHeapSignature( Heap, "RtlCompactHeap" )) {

                LargestFreeSize = 0;
                leave;
            }

            Flags |= Heap->ForceFlags | HEAP_SKIP_VALIDATION_CHECKS;

            //
            //  Lock the heap
            //

            if (!(Flags & HEAP_NO_SERIALIZE)) {

                RtlAcquireLockRoutine( Heap->LockVariable );

                LockAcquired = TRUE;

                Flags |= HEAP_NO_SERIALIZE;
            }

            RtlpValidateHeap( Heap, FALSE );

            LargestFreeSize = RtlCompactHeap( HeapHandle, Flags );

            RtlpValidateHeapHeaders( Heap, TRUE );

        } except( EXCEPTION_EXECUTE_HANDLER ) {

            SET_LAST_STATUS( GetExceptionCode() );
        }

    } finally {

        if (LockAcquired) {

            RtlReleaseLockRoutine( Heap->LockVariable );
        }
    }

    return LargestFreeSize;
}



//
//  Declared in nturtl.h
//

SIZE_T
NTAPI
RtlCompactHeap (
    IN PVOID HeapHandle,
    IN ULONG Flags
    )

/*++

Routine Description:

    This routine compacts the specified heap by coalescing all the free block.
    It also determines the size of the largest available free block and
    returns its, in bytes, back to the caller.

Arguments:

    HeapHandle - Supplies a pointer to the heap being modified

    Flags - Supplies a set of flags used to augment those already
        enforced by the heap

Return Value:

    SIZE_T - Returns the size, in bytes, of the largest free block
        available in the heap

--*/

{
    PHEAP Heap = (PHEAP)HeapHandle;
    PHEAP_FREE_ENTRY FreeBlock;
    PHEAP_SEGMENT Segment;
    UCHAR SegmentIndex;
    SIZE_T LargestFreeSize;
    BOOLEAN LockAcquired = FALSE;

    //
    //  Augment the heap flags
    //

    Flags |= Heap->ForceFlags;

    //
    //  Check if this is a debug version of heap
    //

    if (DEBUG_HEAP( Flags )) {

        return RtlDebugCompactHeap( HeapHandle, Flags );
    }

    try {

        //
        //  Lock the heap
        //

        if (!(Flags & HEAP_NO_SERIALIZE)) {

            RtlAcquireLockRoutine( Heap->LockVariable );

            LockAcquired = TRUE;
        }

        LargestFreeSize = 0;

        try {

            //
            //  Coalesce the heap into its largest free blocks possible
            //  and get the largest free block in the heap
            //

            FreeBlock = RtlpCoalesceHeap( (PHEAP)HeapHandle );

            //
            //  If there is a free block then compute its byte size
            //

            if (FreeBlock != NULL) {

                LargestFreeSize = FreeBlock->Size << HEAP_GRANULARITY_SHIFT;
            }

            //
            //  Scan every segment in the heap looking at its largest uncommitted
            //  range.  Remember the largest range if its bigger than anything
            //  we've found so far
            //

            for (SegmentIndex=0; SegmentIndex<HEAP_MAXIMUM_SEGMENTS; SegmentIndex++) {

                Segment = Heap->Segments[ SegmentIndex ];

                if (Segment && Segment->LargestUnCommittedRange > LargestFreeSize) {

                    LargestFreeSize = Segment->LargestUnCommittedRange;
                }
            }

        } except( EXCEPTION_EXECUTE_HANDLER ) {

            SET_LAST_STATUS( GetExceptionCode() );
        }

    } finally {

        //
        //  Unlock the heap
        //

        if (LockAcquired) {

            RtlReleaseLockRoutine( Heap->LockVariable );
        }
    }

    //
    //  And return the largest free size to our caller
    //

    return LargestFreeSize;
}


#endif // DBG
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\rtl\generr.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    generr.c

Abstract:

    This module contains code to generate the NT status code to DOS
    error code table that is used by the runtime to translate status
    codes.

Author:

    David N. Cutler (davec) 2-Dec-1992

Revision History:

--*/

#include <ntos.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <xtl.h>
#include <status.h>
#include "stdio.h"
#include "stdarg.h"
#include "stdlib.h"

//
// Ensure that the Registry ERROR_SUCCESS error code and the
// NO_ERROR error code remain equal and zero.
//

#if ERROR_SUCCESS != 0 || NO_ERROR != 0
#error Invalid value for ERROR_SUCCESS.
#endif

//
// The following error code table contains paired entries in a singly
// dimensioned array. The first member of a paired entry is an NT status
// code and the second member is the DOS error code that it translates to.
//
// To add a value to this table simply insert the NT status/DOS error code
// pair anywhere is the table. If multiple NT status codes map to a single
// DOS error code, then insert a paired entry for each of the code pairs.
//
#ifdef i386
#pragma warning (4:4018)        // lower to -W4
#endif
LONG CodePairs[] = {

    //
    // First some marker entries so that generr.exe can locate this table
    // in generr.obj.  The following line must appear first in the table.
    //

    'Begi','n ge','nerr',' tbl',

    //
    // Exception codes defined in WINNT.H can map to themselves.
    //

    STATUS_BREAKPOINT, STATUS_BREAKPOINT,
    STATUS_SINGLE_STEP, STATUS_SINGLE_STEP,
    STATUS_ILLEGAL_INSTRUCTION, STATUS_ILLEGAL_INSTRUCTION,
    STATUS_NONCONTINUABLE_EXCEPTION, STATUS_NONCONTINUABLE_EXCEPTION,
    STATUS_INVALID_DISPOSITION, STATUS_INVALID_DISPOSITION,
    STATUS_PARITY_ERROR, STATUS_PARITY_ERROR,
    STATUS_ARRAY_BOUNDS_EXCEEDED, STATUS_ARRAY_BOUNDS_EXCEEDED,
    STATUS_FLOAT_DENORMAL_OPERAND, STATUS_FLOAT_DENORMAL_OPERAND,
    STATUS_FLOAT_DIVIDE_BY_ZERO, STATUS_FLOAT_DIVIDE_BY_ZERO,
    STATUS_FLOAT_INEXACT_RESULT, STATUS_FLOAT_INEXACT_RESULT,
    STATUS_FLOAT_INVALID_OPERATION, STATUS_FLOAT_INVALID_OPERATION,
    STATUS_FLOAT_OVERFLOW, STATUS_FLOAT_OVERFLOW,
    STATUS_FLOAT_STACK_CHECK, STATUS_FLOAT_STACK_CHECK,
    STATUS_FLOAT_UNDERFLOW, STATUS_FLOAT_UNDERFLOW,
    STATUS_INTEGER_DIVIDE_BY_ZERO, STATUS_INTEGER_DIVIDE_BY_ZERO,
    STATUS_PRIVILEGED_INSTRUCTION, STATUS_PRIVILEGED_INSTRUCTION,
    STATUS_GUARD_PAGE_VIOLATION, STATUS_GUARD_PAGE_VIOLATION,

    //
    // These are also defined in WINNT.H, but we are stuck with these
    // mappings.
    //

    STATUS_DATATYPE_MISALIGNMENT, ERROR_NOACCESS,
    STATUS_ACCESS_VIOLATION, ERROR_NOACCESS,
    STATUS_DATATYPE_MISALIGNMENT_ERROR, ERROR_NOACCESS,

    STATUS_CTL_FILE_NOT_SUPPORTED, ERROR_NOT_SUPPORTED,
    STATUS_PORT_ALREADY_SET, ERROR_INVALID_PARAMETER,
    STATUS_SECTION_NOT_IMAGE, ERROR_INVALID_PARAMETER,
    STATUS_BAD_WORKING_SET_LIMIT, ERROR_INVALID_PARAMETER,
    STATUS_WORKING_SET_LIMIT_RANGE, ERROR_INVALID_PARAMETER,
    STATUS_INCOMPATIBLE_FILE_MAP, ERROR_INVALID_PARAMETER,
    STATUS_PORT_DISCONNECTED, ERROR_INVALID_HANDLE,
    STATUS_NOT_LOCKED, ERROR_NOT_LOCKED,
    STATUS_NOT_MAPPED_VIEW, ERROR_INVALID_ADDRESS,
    STATUS_UNABLE_TO_FREE_VM, ERROR_INVALID_PARAMETER,
    STATUS_UNABLE_TO_DELETE_SECTION, ERROR_INVALID_PARAMETER,
    STATUS_MORE_PROCESSING_REQUIRED, ERROR_MORE_DATA,
    STATUS_INVALID_CID, ERROR_INVALID_PARAMETER,
    STATUS_STACK_OVERFLOW, ERROR_STACK_OVERFLOW,
    STATUS_BAD_INITIAL_STACK, ERROR_STACK_OVERFLOW,
    STATUS_INVALID_VOLUME_LABEL, ERROR_LABEL_TOO_LONG,
    STATUS_SECTION_NOT_EXTENDED, ERROR_OUTOFMEMORY,
    STATUS_NOT_MAPPED_DATA, ERROR_INVALID_ADDRESS,

    STATUS_NO_LDT, ERROR_INVALID_THREAD_ID,

    STATUS_INFO_LENGTH_MISMATCH, ERROR_BAD_LENGTH,
    STATUS_INVALID_INFO_CLASS, ERROR_INVALID_PARAMETER,

    STATUS_SUSPEND_COUNT_EXCEEDED, ERROR_SIGNAL_REFUSED,

    STATUS_NOTIFY_ENUM_DIR, ERROR_NOTIFY_ENUM_DIR,

    STATUS_REGISTRY_RECOVERED, ERROR_REGISTRY_RECOVERED,

    STATUS_REGISTRY_IO_FAILED, ERROR_REGISTRY_IO_FAILED,

    STATUS_NOT_REGISTRY_FILE, ERROR_NOT_REGISTRY_FILE,

    STATUS_KEY_DELETED, ERROR_KEY_DELETED,

    STATUS_NO_LOG_SPACE, ERROR_NO_LOG_SPACE,

    STATUS_KEY_HAS_CHILDREN, ERROR_KEY_HAS_CHILDREN,

    STATUS_CHILD_MUST_BE_VOLATILE, ERROR_CHILD_MUST_BE_VOLATILE,

    STATUS_REGISTRY_CORRUPT, ERROR_BADDB,

    STATUS_DLL_NOT_FOUND, ERROR_MOD_NOT_FOUND,

    STATUS_DLL_INIT_FAILED, ERROR_DLL_INIT_FAILED,

    STATUS_ORDINAL_NOT_FOUND, ERROR_INVALID_ORDINAL,
    STATUS_DRIVER_ORDINAL_NOT_FOUND, ERROR_INVALID_ORDINAL,
    STATUS_DRIVER_UNABLE_TO_LOAD, ERROR_BAD_DRIVER,

    STATUS_ENTRYPOINT_NOT_FOUND, ERROR_PROC_NOT_FOUND,
    STATUS_DRIVER_ENTRYPOINT_NOT_FOUND, ERROR_PROC_NOT_FOUND,

    STATUS_PENDING, ERROR_IO_PENDING,

    STATUS_MORE_ENTRIES, ERROR_MORE_DATA,

    STATUS_INTEGER_OVERFLOW, ERROR_ARITHMETIC_OVERFLOW,

    STATUS_BUFFER_OVERFLOW, ERROR_MORE_DATA,

    STATUS_NO_MORE_FILES, ERROR_NO_MORE_FILES,

    STATUS_NO_INHERITANCE, ERROR_NO_INHERITANCE,

    STATUS_NO_MORE_EAS, ERROR_NO_MORE_ITEMS,
    STATUS_NO_MORE_ENTRIES, ERROR_NO_MORE_ITEMS,
    STATUS_GUIDS_EXHAUSTED, ERROR_NO_MORE_ITEMS,
    STATUS_AGENTS_EXHAUSTED, ERROR_NO_MORE_ITEMS,

    STATUS_UNSUCCESSFUL, ERROR_GEN_FAILURE,

    STATUS_TOO_MANY_LINKS, ERROR_TOO_MANY_LINKS,

    STATUS_NOT_IMPLEMENTED, ERROR_INVALID_FUNCTION,
    STATUS_ILLEGAL_FUNCTION, ERROR_INVALID_FUNCTION,

    STATUS_IN_PAGE_ERROR, ERROR_SWAPERROR,

    STATUS_PAGEFILE_QUOTA, ERROR_PAGEFILE_QUOTA,
    STATUS_COMMITMENT_LIMIT, ERROR_COMMITMENT_LIMIT,
    STATUS_SECTION_TOO_BIG, ERROR_NOT_ENOUGH_MEMORY,

    RPC_NT_SS_IN_NULL_CONTEXT, ERROR_INVALID_HANDLE,
    RPC_NT_INVALID_BINDING, ERROR_INVALID_HANDLE,
    STATUS_INVALID_HANDLE, ERROR_INVALID_HANDLE,
    STATUS_OBJECT_TYPE_MISMATCH, ERROR_INVALID_HANDLE,
    STATUS_FILE_CLOSED, ERROR_INVALID_HANDLE,
    STATUS_INVALID_PORT_HANDLE, ERROR_INVALID_HANDLE,
    STATUS_HANDLE_NOT_CLOSABLE, ERROR_INVALID_HANDLE,

    STATUS_NOT_COMMITTED, ERROR_INVALID_ADDRESS,
    STATUS_PARTIAL_COPY, ERROR_PARTIAL_COPY,

    STATUS_LPC_REPLY_LOST, ERROR_INTERNAL_ERROR,
    STATUS_INVALID_PARAMETER, ERROR_INVALID_PARAMETER,
    STATUS_INVALID_PARAMETER_1, ERROR_INVALID_PARAMETER,
    STATUS_INVALID_PARAMETER_2, ERROR_INVALID_PARAMETER,
    STATUS_INVALID_PARAMETER_3, ERROR_INVALID_PARAMETER,
    STATUS_INVALID_PARAMETER_4, ERROR_INVALID_PARAMETER,
    STATUS_INVALID_PARAMETER_5, ERROR_INVALID_PARAMETER,
    STATUS_INVALID_PARAMETER_6, ERROR_INVALID_PARAMETER,
    STATUS_INVALID_PARAMETER_7, ERROR_INVALID_PARAMETER,
    STATUS_INVALID_PARAMETER_8, ERROR_INVALID_PARAMETER,
    STATUS_INVALID_PARAMETER_9, ERROR_INVALID_PARAMETER,
    STATUS_INVALID_PARAMETER_10, ERROR_INVALID_PARAMETER,
    STATUS_INVALID_PARAMETER_11, ERROR_INVALID_PARAMETER,
    STATUS_INVALID_PARAMETER_12, ERROR_INVALID_PARAMETER,
    STATUS_INVALID_PARAMETER_MIX, ERROR_INVALID_PARAMETER,
    STATUS_INVALID_PAGE_PROTECTION, ERROR_INVALID_PARAMETER,
    STATUS_SECTION_PROTECTION, ERROR_INVALID_PARAMETER,

    STATUS_RESOURCE_DATA_NOT_FOUND, ERROR_RESOURCE_DATA_NOT_FOUND,
    STATUS_RESOURCE_TYPE_NOT_FOUND, ERROR_RESOURCE_TYPE_NOT_FOUND,
    STATUS_RESOURCE_NAME_NOT_FOUND, ERROR_RESOURCE_NAME_NOT_FOUND,
    STATUS_RESOURCE_LANG_NOT_FOUND, ERROR_RESOURCE_LANG_NOT_FOUND,

    STATUS_NO_SUCH_DEVICE, ERROR_FILE_NOT_FOUND,
    STATUS_NO_SUCH_FILE, ERROR_FILE_NOT_FOUND,

    STATUS_INVALID_DEVICE_REQUEST, ERROR_INVALID_FUNCTION,
    STATUS_VOLUME_NOT_UPGRADED, ERROR_INVALID_FUNCTION,

    STATUS_END_OF_FILE, ERROR_HANDLE_EOF,
    STATUS_FILE_FORCED_CLOSED, ERROR_HANDLE_EOF,

    STATUS_WRONG_VOLUME, ERROR_WRONG_DISK,

    STATUS_NO_MEDIA, ERROR_NO_MEDIA_IN_DRIVE,

    STATUS_NO_MEDIA_IN_DEVICE, ERROR_NOT_READY,

    STATUS_VOLUME_DISMOUNTED, ERROR_NOT_READY,

    STATUS_NONEXISTENT_SECTOR, ERROR_SECTOR_NOT_FOUND,

    STATUS_WORKING_SET_QUOTA, ERROR_WORKING_SET_QUOTA,
    STATUS_NO_MEMORY, ERROR_NOT_ENOUGH_MEMORY,
    STATUS_CONFLICTING_ADDRESSES, ERROR_INVALID_ADDRESS,

    STATUS_INVALID_SYSTEM_SERVICE, ERROR_INVALID_FUNCTION,

    STATUS_THREAD_IS_TERMINATING, ERROR_ACCESS_DENIED,
    STATUS_PROCESS_IS_TERMINATING, ERROR_ACCESS_DENIED,
    STATUS_INVALID_LOCK_SEQUENCE, ERROR_ACCESS_DENIED,
    STATUS_INVALID_VIEW_SIZE, ERROR_ACCESS_DENIED,
    STATUS_ALREADY_COMMITTED, ERROR_ACCESS_DENIED,
    STATUS_ACCESS_DENIED, ERROR_ACCESS_DENIED,
    STATUS_FILE_IS_A_DIRECTORY, ERROR_ACCESS_DENIED,
    STATUS_CANNOT_DELETE, ERROR_ACCESS_DENIED,
    STATUS_INVALID_COMPUTER_NAME, ERROR_INVALID_COMPUTERNAME,
    STATUS_FILE_DELETED, ERROR_ACCESS_DENIED,
    STATUS_FILE_RENAMED, ERROR_ACCESS_DENIED,
    STATUS_DELETE_PENDING, ERROR_ACCESS_DENIED,
    STATUS_PORT_CONNECTION_REFUSED, ERROR_ACCESS_DENIED,

    STATUS_NO_SUCH_PRIVILEGE, ERROR_NO_SUCH_PRIVILEGE,

    STATUS_PRIVILEGE_NOT_HELD, ERROR_PRIVILEGE_NOT_HELD,

    STATUS_CANNOT_IMPERSONATE, ERROR_CANNOT_IMPERSONATE,

    STATUS_LOGON_FAILURE, ERROR_LOGON_FAILURE,
    STATUS_MUTUAL_AUTHENTICATION_FAILED, ERROR_MUTUAL_AUTH_FAILED,
    STATUS_TIME_DIFFERENCE_AT_DC, ERROR_TIME_SKEW,

    STATUS_ACCOUNT_RESTRICTION, ERROR_ACCOUNT_RESTRICTION,

    STATUS_INVALID_LOGON_HOURS, ERROR_INVALID_LOGON_HOURS,

    STATUS_INVALID_WORKSTATION, ERROR_INVALID_WORKSTATION,

    STATUS_BUFFER_TOO_SMALL, ERROR_INSUFFICIENT_BUFFER,

    STATUS_UNABLE_TO_DECOMMIT_VM, ERROR_INVALID_ADDRESS,

    STATUS_DISK_CORRUPT_ERROR, ERROR_DISK_CORRUPT,

    STATUS_VARIABLE_NOT_FOUND, ERROR_ENVVAR_NOT_FOUND,

    STATUS_OBJECT_NAME_INVALID, ERROR_INVALID_NAME,

    STATUS_OBJECT_NAME_NOT_FOUND, ERROR_FILE_NOT_FOUND,

    STATUS_OBJECT_NAME_COLLISION, ERROR_ALREADY_EXISTS,

    STATUS_OBJECT_PATH_INVALID, ERROR_BAD_PATHNAME,

    STATUS_OBJECT_PATH_NOT_FOUND, ERROR_PATH_NOT_FOUND,
    STATUS_DFS_EXIT_PATH_FOUND, ERROR_PATH_NOT_FOUND,
    STATUS_DFS_UNAVAILABLE, ERROR_CONNECTION_UNAVAIL,

    STATUS_OBJECT_PATH_SYNTAX_BAD, ERROR_BAD_PATHNAME,

    STATUS_NAME_TOO_LONG, ERROR_FILENAME_EXCED_RANGE,

    STATUS_DATA_OVERRUN, ERROR_IO_DEVICE,
    STATUS_DATA_LATE_ERROR, ERROR_IO_DEVICE,
    STATUS_DATA_ERROR, ERROR_CRC,

    STATUS_CRC_ERROR, ERROR_CRC,

    STATUS_SHARING_VIOLATION, ERROR_SHARING_VIOLATION,

    STATUS_QUOTA_EXCEEDED, ERROR_NOT_ENOUGH_QUOTA,

    STATUS_MUTANT_NOT_OWNED, ERROR_NOT_OWNER,

    STATUS_SEMAPHORE_LIMIT_EXCEEDED, ERROR_TOO_MANY_POSTS,

    STATUS_DISK_FULL, ERROR_DISK_FULL,

    STATUS_LOCK_NOT_GRANTED, ERROR_LOCK_VIOLATION,

    STATUS_FILE_LOCK_CONFLICT, ERROR_LOCK_VIOLATION,  // FIX, FIX - is this right?

    STATUS_NOT_A_DIRECTORY, ERROR_DIRECTORY,          // FIX, FIX - is this right?

    STATUS_CANNOT_MAKE, ERROR_CANNOT_MAKE,

    STATUS_UNKNOWN_REVISION, ERROR_UNKNOWN_REVISION,

    STATUS_REVISION_MISMATCH, ERROR_REVISION_MISMATCH,

    STATUS_INVALID_OWNER, ERROR_INVALID_OWNER,

    STATUS_INVALID_PRIMARY_GROUP, ERROR_INVALID_PRIMARY_GROUP,

    STATUS_NO_IMPERSONATION_TOKEN, ERROR_NO_IMPERSONATION_TOKEN,

    STATUS_CANT_DISABLE_MANDATORY, ERROR_CANT_DISABLE_MANDATORY,

    STATUS_NO_LOGON_SERVERS, ERROR_NO_LOGON_SERVERS,
    STATUS_DOMAIN_CONTROLLER_NOT_FOUND, ERROR_DOMAIN_CONTROLLER_NOT_FOUND,

    STATUS_NO_SUCH_LOGON_SESSION, ERROR_NO_SUCH_LOGON_SESSION,

    STATUS_INVALID_ACCOUNT_NAME, ERROR_INVALID_ACCOUNT_NAME,

    STATUS_USER_EXISTS, ERROR_USER_EXISTS,

    STATUS_NO_SUCH_USER, ERROR_NO_SUCH_USER,

    STATUS_GROUP_EXISTS, ERROR_GROUP_EXISTS,

    STATUS_NO_SUCH_GROUP, ERROR_NO_SUCH_GROUP,

    STATUS_SPECIAL_GROUP, ERROR_SPECIAL_GROUP,

    STATUS_MEMBER_IN_GROUP, ERROR_MEMBER_IN_GROUP,

    STATUS_MEMBER_NOT_IN_GROUP, ERROR_MEMBER_NOT_IN_GROUP,

    STATUS_LAST_ADMIN, ERROR_LAST_ADMIN,

    STATUS_WRONG_PASSWORD, ERROR_INVALID_PASSWORD,
    STATUS_WRONG_PASSWORD_CORE, ERROR_INVALID_PASSWORD,

    STATUS_ILL_FORMED_PASSWORD, ERROR_ILL_FORMED_PASSWORD,

    STATUS_PASSWORD_RESTRICTION, ERROR_PASSWORD_RESTRICTION,

    STATUS_PASSWORD_EXPIRED, ERROR_PASSWORD_EXPIRED,
    STATUS_PASSWORD_MUST_CHANGE, ERROR_PASSWORD_MUST_CHANGE,

    STATUS_ACCOUNT_DISABLED, ERROR_ACCOUNT_DISABLED,
    STATUS_ACCOUNT_LOCKED_OUT, ERROR_ACCOUNT_LOCKED_OUT,

    STATUS_NONE_MAPPED, ERROR_NONE_MAPPED,

    STATUS_TOO_MANY_LUIDS_REQUESTED, ERROR_TOO_MANY_LUIDS_REQUESTED,

    STATUS_LUIDS_EXHAUSTED, ERROR_LUIDS_EXHAUSTED,

    STATUS_INVALID_SUB_AUTHORITY, ERROR_INVALID_SUB_AUTHORITY,

    STATUS_INVALID_ACL, ERROR_INVALID_ACL,

    STATUS_INVALID_SID, ERROR_INVALID_SID,

    STATUS_INVALID_SECURITY_DESCR, ERROR_INVALID_SECURITY_DESCR,

    STATUS_PROCEDURE_NOT_FOUND, ERROR_PROC_NOT_FOUND,

    STATUS_BAD_INITIAL_PC, ERROR_BAD_EXE_FORMAT,
    STATUS_INVALID_FILE_FOR_SECTION, ERROR_BAD_EXE_FORMAT,
    STATUS_INVALID_IMAGE_FORMAT, ERROR_BAD_EXE_FORMAT,
    STATUS_IMAGE_MP_UP_MISMATCH, ERROR_BAD_EXE_FORMAT,
    STATUS_IMAGE_CHECKSUM_MISMATCH, ERROR_BAD_EXE_FORMAT,
    STATUS_INVALID_IMAGE_PROTECT, ERROR_BAD_EXE_FORMAT,

    STATUS_NO_TOKEN, ERROR_NO_TOKEN,

    STATUS_RANGE_NOT_LOCKED, ERROR_NOT_LOCKED,

    STATUS_SERVER_DISABLED, ERROR_SERVER_DISABLED,

    STATUS_SERVER_NOT_DISABLED, ERROR_SERVER_NOT_DISABLED,

    STATUS_INVALID_ID_AUTHORITY, ERROR_INVALID_ID_AUTHORITY,

    STATUS_ALLOTTED_SPACE_EXCEEDED, ERROR_ALLOTTED_SPACE_EXCEEDED,

    STATUS_TOO_MANY_PAGING_FILES, ERROR_NOT_ENOUGH_MEMORY,
    STATUS_INSUFFICIENT_RESOURCES, ERROR_NO_SYSTEM_RESOURCES,

    STATUS_INSUFF_SERVER_RESOURCES, ERROR_NOT_ENOUGH_SERVER_MEMORY,

    STATUS_FILE_INVALID, ERROR_FILE_INVALID,
    STATUS_MAPPED_FILE_SIZE_ZERO, ERROR_FILE_INVALID,

    STATUS_DEVICE_PAPER_EMPTY, ERROR_OUT_OF_PAPER,

    STATUS_DEVICE_POWERED_OFF, ERROR_NOT_READY,
    STATUS_DEVICE_OFF_LINE, ERROR_NOT_READY,

    STATUS_DEVICE_DATA_ERROR, ERROR_CRC,

    STATUS_DEVICE_NOT_READY, ERROR_NOT_READY,
    STATUS_DEVICE_NOT_CONNECTED, ERROR_DEVICE_NOT_CONNECTED,
    STATUS_DEVICE_POWER_FAILURE, ERROR_NOT_READY,

    STATUS_NOT_FOUND, ERROR_NOT_FOUND,
    STATUS_NO_MATCH, ERROR_NO_MATCH,
    STATUS_PROPSET_NOT_FOUND, ERROR_SET_NOT_FOUND,


    STATUS_DEVICE_BUSY, ERROR_BUSY,                   // FIX, FIX - is there a better choice?

    STATUS_FREE_VM_NOT_AT_BASE, ERROR_INVALID_ADDRESS,
    STATUS_MEMORY_NOT_ALLOCATED, ERROR_INVALID_ADDRESS,

    STATUS_NOT_SAME_DEVICE, ERROR_NOT_SAME_DEVICE,

    STATUS_NOT_SUPPORTED, ERROR_NOT_SUPPORTED,

    STATUS_REMOTE_NOT_LISTENING, ERROR_REM_NOT_LIST,

    STATUS_DUPLICATE_NAME, ERROR_DUP_NAME,

    STATUS_BAD_NETWORK_PATH, ERROR_BAD_NETPATH,

    STATUS_NETWORK_BUSY, ERROR_NETWORK_BUSY,

    STATUS_ONLY_IF_CONNECTED, ERROR_ONLY_IF_CONNECTED,

    STATUS_DEVICE_DOES_NOT_EXIST, ERROR_DEV_NOT_EXIST,

    STATUS_TOO_MANY_COMMANDS, ERROR_TOO_MANY_CMDS,

    STATUS_ADAPTER_HARDWARE_ERROR, ERROR_ADAP_HDW_ERR,

    STATUS_REDIRECTOR_NOT_STARTED, ERROR_PATH_NOT_FOUND,

    STATUS_INVALID_EA_NAME, ERROR_INVALID_EA_NAME,

    STATUS_EA_LIST_INCONSISTENT, ERROR_EA_LIST_INCONSISTENT,
    STATUS_EA_TOO_LARGE, ERROR_EA_LIST_INCONSISTENT,
    STATUS_INVALID_EA_FLAG, ERROR_EA_LIST_INCONSISTENT,
    STATUS_EAS_NOT_SUPPORTED, ERROR_EAS_NOT_SUPPORTED,

    STATUS_FILE_CORRUPT_ERROR, ERROR_FILE_CORRUPT,
    STATUS_EA_CORRUPT_ERROR, ERROR_FILE_CORRUPT,
    STATUS_NONEXISTENT_EA_ENTRY, ERROR_FILE_CORRUPT,
    STATUS_NO_EAS_ON_FILE, ERROR_FILE_CORRUPT,

    STATUS_NOT_A_REPARSE_POINT, ERROR_NOT_A_REPARSE_POINT,
    STATUS_IO_REPARSE_TAG_INVALID, ERROR_REPARSE_TAG_INVALID,
    STATUS_IO_REPARSE_TAG_MISMATCH, ERROR_REPARSE_TAG_MISMATCH,
    STATUS_IO_REPARSE_TAG_NOT_HANDLED, ERROR_CANT_ACCESS_FILE,
    STATUS_REPARSE_POINT_NOT_RESOLVED, ERROR_CANT_RESOLVE_FILENAME,
    STATUS_DIRECTORY_IS_A_REPARSE_POINT, ERROR_BAD_PATHNAME,
    STATUS_REPARSE_ATTRIBUTE_CONFLICT, ERROR_REPARSE_ATTRIBUTE_CONFLICT,
    STATUS_IO_REPARSE_DATA_INVALID, ERROR_INVALID_REPARSE_DATA,

    STATUS_FILE_IS_OFFLINE, ERROR_FILE_OFFLINE,

    STATUS_INVALID_NETWORK_RESPONSE, ERROR_BAD_NET_RESP,

    STATUS_USER_SESSION_DELETED, ERROR_UNEXP_NET_ERR,
    STATUS_UNEXPECTED_NETWORK_ERROR, ERROR_UNEXP_NET_ERR,

    STATUS_USER_SESSION_DELETED, ERROR_UNEXP_NET_ERR,

    STATUS_BAD_REMOTE_ADAPTER, ERROR_BAD_REM_ADAP,

    STATUS_PRINT_QUEUE_FULL, ERROR_PRINTQ_FULL,

    STATUS_NO_SPOOL_SPACE, ERROR_NO_SPOOL_SPACE,

    STATUS_PRINT_CANCELLED, ERROR_PRINT_CANCELLED,

    STATUS_NETWORK_NAME_DELETED, ERROR_NETNAME_DELETED,

    STATUS_NETWORK_ACCESS_DENIED, ERROR_NETWORK_ACCESS_DENIED,

    STATUS_BAD_DEVICE_TYPE, ERROR_BAD_DEV_TYPE,

    STATUS_BAD_NETWORK_NAME, ERROR_BAD_NET_NAME,

    STATUS_TOO_MANY_NAMES, ERROR_TOO_MANY_NAMES,
    STATUS_TOO_MANY_GUIDS_REQUESTED, ERROR_TOO_MANY_NAMES,
    STATUS_TOO_MANY_ADDRESSES, ERROR_TOO_MANY_NAMES,
    STATUS_TOO_MANY_NODES, ERROR_TOO_MANY_NAMES,

    STATUS_TOO_MANY_SESSIONS, ERROR_TOO_MANY_SESS,

    STATUS_SHARING_PAUSED, ERROR_SHARING_PAUSED,

    STATUS_REQUEST_NOT_ACCEPTED, ERROR_REQ_NOT_ACCEP,

    STATUS_REDIRECTOR_PAUSED, ERROR_REDIR_PAUSED,

    STATUS_NET_WRITE_FAULT, ERROR_NET_WRITE_FAULT,

    STATUS_VIRTUAL_CIRCUIT_CLOSED, ERROR_VC_DISCONNECTED,

    STATUS_INVALID_PIPE_STATE, ERROR_BAD_PIPE,
    STATUS_INVALID_READ_MODE, ERROR_BAD_PIPE,

    STATUS_PIPE_CLOSING, ERROR_NO_DATA,
    STATUS_PIPE_EMPTY, ERROR_NO_DATA,

    STATUS_PIPE_CONNECTED, ERROR_PIPE_CONNECTED,

    STATUS_PIPE_DISCONNECTED, ERROR_PIPE_NOT_CONNECTED,

    STATUS_PIPE_LISTENING, ERROR_PIPE_LISTENING,

    STATUS_PIPE_NOT_AVAILABLE, ERROR_PIPE_BUSY,
    STATUS_INSTANCE_NOT_AVAILABLE, ERROR_PIPE_BUSY,
    STATUS_PIPE_BUSY, ERROR_PIPE_BUSY,

    STATUS_PIPE_BROKEN, ERROR_BROKEN_PIPE,

    STATUS_DIRECTORY_NOT_EMPTY, ERROR_DIR_NOT_EMPTY,

    STATUS_TOO_MANY_OPENED_FILES, ERROR_TOO_MANY_OPEN_FILES,

    STATUS_IO_TIMEOUT, ERROR_SEM_TIMEOUT,

    STATUS_CANCELLED, ERROR_OPERATION_ABORTED,

    STATUS_UNRECOGNIZED_MEDIA, ERROR_UNRECOGNIZED_MEDIA,

    STATUS_INVALID_LEVEL, ERROR_INVALID_LEVEL,

    STATUS_UNRECOGNIZED_VOLUME, ERROR_UNRECOGNIZED_VOLUME,

    STATUS_MEDIA_WRITE_PROTECTED, ERROR_WRITE_PROTECT,
    STATUS_TOO_LATE, ERROR_WRITE_PROTECT,

    STATUS_SUCCESS, NO_ERROR,

    STATUS_FULLSCREEN_MODE, ERROR_FULLSCREEN_MODE,

    STATUS_END_OF_MEDIA, ERROR_END_OF_MEDIA,

    STATUS_EOM_OVERFLOW, ERROR_EOM_OVERFLOW,

    STATUS_BEGINNING_OF_MEDIA, ERROR_BEGINNING_OF_MEDIA,

    STATUS_MEDIA_CHANGED, ERROR_MEDIA_CHANGED,

    STATUS_BUS_RESET, ERROR_BUS_RESET,

    STATUS_FILEMARK_DETECTED, ERROR_FILEMARK_DETECTED,

    STATUS_SETMARK_DETECTED, ERROR_SETMARK_DETECTED,

    STATUS_NO_DATA_DETECTED, ERROR_NO_DATA_DETECTED,

    STATUS_PARTITION_FAILURE, ERROR_PARTITION_FAILURE,

    STATUS_INVALID_BLOCK_LENGTH, ERROR_INVALID_BLOCK_LENGTH,

    STATUS_DEVICE_NOT_PARTITIONED, ERROR_DEVICE_NOT_PARTITIONED,

    STATUS_UNABLE_TO_LOCK_MEDIA, ERROR_UNABLE_TO_LOCK_MEDIA,

    STATUS_UNABLE_TO_UNLOAD_MEDIA, ERROR_UNABLE_TO_UNLOAD_MEDIA,

    STATUS_UNMAPPABLE_CHARACTER, ERROR_NO_UNICODE_TRANSLATION,

    STATUS_NOT_ALL_ASSIGNED, ERROR_NOT_ALL_ASSIGNED,

    STATUS_SOME_NOT_MAPPED, ERROR_SOME_NOT_MAPPED,

    STATUS_NO_QUOTAS_FOR_ACCOUNT, ERROR_NO_QUOTAS_FOR_ACCOUNT,

    STATUS_LOCAL_USER_SESSION_KEY, ERROR_LOCAL_USER_SESSION_KEY,

    STATUS_NULL_LM_PASSWORD, ERROR_NULL_LM_PASSWORD,

    STATUS_BAD_INHERITANCE_ACL, ERROR_BAD_INHERITANCE_ACL,

    STATUS_INVALID_GROUP_ATTRIBUTES, ERROR_INVALID_GROUP_ATTRIBUTES,

    STATUS_BAD_IMPERSONATION_LEVEL, ERROR_BAD_IMPERSONATION_LEVEL,

    STATUS_CANT_OPEN_ANONYMOUS, ERROR_CANT_OPEN_ANONYMOUS,

    STATUS_BAD_VALIDATION_CLASS, ERROR_BAD_VALIDATION_CLASS,

    STATUS_BAD_TOKEN_TYPE, ERROR_BAD_TOKEN_TYPE,

    STATUS_BAD_MASTER_BOOT_RECORD, ERROR_INVALID_PARAMETER,

    STATUS_NO_SECURITY_ON_OBJECT, ERROR_NO_SECURITY_ON_OBJECT,

    STATUS_CANT_ACCESS_DOMAIN_INFO, ERROR_CANT_ACCESS_DOMAIN_INFO,

    STATUS_INVALID_SERVER_STATE, ERROR_INVALID_SERVER_STATE,

    STATUS_INVALID_DOMAIN_STATE, ERROR_INVALID_DOMAIN_STATE,

    STATUS_INVALID_DOMAIN_ROLE, ERROR_INVALID_DOMAIN_ROLE,

    STATUS_NO_SUCH_DOMAIN, ERROR_NO_SUCH_DOMAIN,

    STATUS_DOMAIN_EXISTS, ERROR_DOMAIN_EXISTS,

    STATUS_DOMAIN_LIMIT_EXCEEDED, ERROR_DOMAIN_LIMIT_EXCEEDED,

    STATUS_OPLOCK_NOT_GRANTED, ERROR_OPLOCK_NOT_GRANTED,
    STATUS_INVALID_OPLOCK_PROTOCOL, ERROR_INVALID_OPLOCK_PROTOCOL,

    STATUS_INTERNAL_DB_CORRUPTION, ERROR_INTERNAL_DB_CORRUPTION,

    STATUS_INTERNAL_ERROR, ERROR_INTERNAL_ERROR,

    STATUS_GENERIC_NOT_MAPPED, ERROR_GENERIC_NOT_MAPPED,

    STATUS_BAD_DESCRIPTOR_FORMAT, ERROR_BAD_DESCRIPTOR_FORMAT,

    STATUS_NOT_LOGON_PROCESS, ERROR_NOT_LOGON_PROCESS,

    STATUS_LOGON_SESSION_EXISTS, ERROR_LOGON_SESSION_EXISTS,

    STATUS_NO_SUCH_PACKAGE, ERROR_NO_SUCH_PACKAGE,

    STATUS_BAD_LOGON_SESSION_STATE, ERROR_BAD_LOGON_SESSION_STATE,

    STATUS_LOGON_SESSION_COLLISION, ERROR_LOGON_SESSION_COLLISION,

    STATUS_INVALID_LOGON_TYPE, ERROR_INVALID_LOGON_TYPE,

    STATUS_SPECIAL_ACCOUNT, ERROR_SPECIAL_ACCOUNT,

    STATUS_SPECIAL_USER, ERROR_SPECIAL_USER,

    STATUS_MEMBERS_PRIMARY_GROUP, ERROR_MEMBERS_PRIMARY_GROUP,

    STATUS_TOKEN_ALREADY_IN_USE, ERROR_TOKEN_ALREADY_IN_USE,

    STATUS_NO_SUCH_ALIAS, ERROR_NO_SUCH_ALIAS,

    STATUS_MEMBER_NOT_IN_ALIAS, ERROR_MEMBER_NOT_IN_ALIAS,

    STATUS_MEMBER_IN_ALIAS, ERROR_MEMBER_IN_ALIAS,

    STATUS_ALIAS_EXISTS, ERROR_ALIAS_EXISTS,

    STATUS_LOGON_NOT_GRANTED, ERROR_LOGON_NOT_GRANTED,

    STATUS_TOO_MANY_SECRETS, ERROR_TOO_MANY_SECRETS,

    STATUS_SECRET_TOO_LONG, ERROR_SECRET_TOO_LONG,

    STATUS_INTERNAL_DB_ERROR, ERROR_INTERNAL_DB_ERROR,

    STATUS_TOO_MANY_CONTEXT_IDS, ERROR_TOO_MANY_CONTEXT_IDS,

    STATUS_LOGON_TYPE_NOT_GRANTED, ERROR_LOGON_TYPE_NOT_GRANTED,

    STATUS_NT_CROSS_ENCRYPTION_REQUIRED, ERROR_NT_CROSS_ENCRYPTION_REQUIRED,

    STATUS_NO_SUCH_MEMBER, ERROR_NO_SUCH_MEMBER,

    STATUS_INVALID_MEMBER, ERROR_INVALID_MEMBER,

    STATUS_TOO_MANY_SIDS, ERROR_TOO_MANY_SIDS,

    STATUS_LM_CROSS_ENCRYPTION_REQUIRED, ERROR_LM_CROSS_ENCRYPTION_REQUIRED,

    STATUS_MESSAGE_NOT_FOUND, ERROR_MR_MID_NOT_FOUND,

    STATUS_LOCAL_DISCONNECT, ERROR_NETNAME_DELETED,
    STATUS_REMOTE_DISCONNECT, ERROR_NETNAME_DELETED,

    STATUS_REMOTE_RESOURCES, ERROR_REM_NOT_LIST,

    STATUS_LINK_FAILED, ERROR_UNEXP_NET_ERR,
    STATUS_LINK_TIMEOUT, ERROR_UNEXP_NET_ERR,

    STATUS_INVALID_CONNECTION, ERROR_UNEXP_NET_ERR,
    STATUS_INVALID_ADDRESS, ERROR_UNEXP_NET_ERR,

    STATUS_IO_DEVICE_ERROR, ERROR_IO_DEVICE,
    STATUS_DEVICE_PROTOCOL_ERROR, ERROR_IO_DEVICE,
    STATUS_DRIVER_INTERNAL_ERROR, ERROR_IO_DEVICE,

    STATUS_INVALID_DEVICE_STATE, ERROR_BAD_COMMAND,

    STATUS_DEVICE_CONFIGURATION_ERROR, ERROR_INVALID_PARAMETER,

    STATUS_SOURCE_ELEMENT_EMPTY,       ERROR_SOURCE_ELEMENT_EMPTY,
    STATUS_DESTINATION_ELEMENT_FULL,   ERROR_DESTINATION_ELEMENT_FULL,
    STATUS_ILLEGAL_ELEMENT_ADDRESS,    ERROR_ILLEGAL_ELEMENT_ADDRESS,
    STATUS_MAGAZINE_NOT_PRESENT,       ERROR_MAGAZINE_NOT_PRESENT,
    STATUS_REINITIALIZATION_NEEDED,    ERROR_DEVICE_REINITIALIZATION_NEEDED,
    STATUS_DEVICE_REQUIRES_CLEANING,   ERROR_DEVICE_REQUIRES_CLEANING,
    STATUS_DEVICE_DOOR_OPEN,           ERROR_DEVICE_DOOR_OPEN,
    STATUS_TRANSPORT_FULL,             ERROR_TRANSPORT_FULL,

    STATUS_ENCRYPTION_FAILED,          ERROR_ACCESS_DENIED,
    STATUS_DECRYPTION_FAILED,          ERROR_ACCESS_DENIED,
    STATUS_NO_RECOVERY_POLICY,         ERROR_ACCESS_DENIED,
    STATUS_NO_EFS,                     ERROR_ACCESS_DENIED,
    STATUS_WRONG_EFS,                  ERROR_ACCESS_DENIED,
    STATUS_NO_USER_KEYS,               ERROR_ACCESS_DENIED,
    STATUS_FILE_NOT_ENCRYPTED,         ERROR_FILE_NOT_ENCRYPTED,
    STATUS_NOT_EXPORT_FORMAT,          ERROR_NOT_EXPORT_FORMAT,
    STATUS_FILE_ENCRYPTED,             ERROR_FILE_ENCRYPTED,

    STATUS_INVALID_USER_BUFFER, ERROR_INVALID_USER_BUFFER,

    STATUS_SERIAL_NO_DEVICE_INITED, ERROR_SERIAL_NO_DEVICE,

    STATUS_SHARED_IRQ_BUSY, ERROR_IRQ_BUSY,

    STATUS_SERIAL_MORE_WRITES, ERROR_MORE_WRITES,

    STATUS_SERIAL_COUNTER_TIMEOUT, ERROR_COUNTER_TIMEOUT,

    STATUS_DISK_RECALIBRATE_FAILED, ERROR_DISK_RECALIBRATE_FAILED,

    STATUS_DISK_OPERATION_FAILED, ERROR_DISK_OPERATION_FAILED,

    STATUS_DISK_RESET_FAILED, ERROR_DISK_RESET_FAILED,

    STATUS_EVENTLOG_FILE_CORRUPT, ERROR_EVENTLOG_FILE_CORRUPT,

    STATUS_EVENTLOG_CANT_START, ERROR_EVENTLOG_CANT_START,

    STATUS_NETLOGON_NOT_STARTED, ERROR_NETLOGON_NOT_STARTED,

    STATUS_ACCOUNT_EXPIRED, ERROR_ACCOUNT_EXPIRED,

    STATUS_NETWORK_CREDENTIAL_CONFLICT, ERROR_SESSION_CREDENTIAL_CONFLICT,

    STATUS_REMOTE_SESSION_LIMIT, ERROR_REMOTE_SESSION_LIMIT_EXCEEDED,

    STATUS_INVALID_BUFFER_SIZE, ERROR_INVALID_USER_BUFFER,

    STATUS_INVALID_ADDRESS_COMPONENT, ERROR_INVALID_NETNAME,
    STATUS_INVALID_ADDRESS_WILDCARD, ERROR_INVALID_NETNAME,

    STATUS_ADDRESS_ALREADY_EXISTS, ERROR_DUP_NAME,

    STATUS_ADDRESS_CLOSED, ERROR_NETNAME_DELETED,
    STATUS_CONNECTION_DISCONNECTED, ERROR_NETNAME_DELETED,

    STATUS_CONNECTION_RESET, ERROR_NETNAME_DELETED,

    STATUS_TRANSACTION_ABORTED, ERROR_UNEXP_NET_ERR,
    STATUS_TRANSACTION_TIMED_OUT, ERROR_UNEXP_NET_ERR,
    STATUS_TRANSACTION_NO_RELEASE, ERROR_UNEXP_NET_ERR,
    STATUS_TRANSACTION_NO_MATCH, ERROR_UNEXP_NET_ERR,
    STATUS_TRANSACTION_RESPONDED, ERROR_UNEXP_NET_ERR,
    STATUS_TRANSACTION_INVALID_ID, ERROR_UNEXP_NET_ERR,
    STATUS_TRANSACTION_INVALID_TYPE, ERROR_UNEXP_NET_ERR,

    STATUS_NOT_SERVER_SESSION, ERROR_NOT_SUPPORTED,
    STATUS_NOT_CLIENT_SESSION, ERROR_NOT_SUPPORTED,

    STATUS_USER_MAPPED_FILE, ERROR_USER_MAPPED_FILE,

    STATUS_PLUGPLAY_NO_DEVICE, ERROR_SERVICE_DISABLED,

    RPC_NT_SERVER_UNAVAILABLE, RPC_S_SERVER_UNAVAILABLE,

    RPC_NT_INVALID_STRING_BINDING, RPC_S_INVALID_STRING_BINDING,

    RPC_NT_WRONG_KIND_OF_BINDING, RPC_S_WRONG_KIND_OF_BINDING,

    RPC_NT_PROTSEQ_NOT_SUPPORTED, RPC_S_PROTSEQ_NOT_SUPPORTED,

    RPC_NT_INVALID_RPC_PROTSEQ, RPC_S_INVALID_RPC_PROTSEQ,

    RPC_NT_INVALID_STRING_UUID, RPC_S_INVALID_STRING_UUID,

    RPC_NT_INVALID_ENDPOINT_FORMAT, RPC_S_INVALID_ENDPOINT_FORMAT,

    RPC_NT_INVALID_NET_ADDR, RPC_S_INVALID_NET_ADDR,

    RPC_NT_NO_ENDPOINT_FOUND, RPC_S_NO_ENDPOINT_FOUND,

    RPC_NT_INVALID_TIMEOUT, RPC_S_INVALID_TIMEOUT,

    RPC_NT_OBJECT_NOT_FOUND, RPC_S_OBJECT_NOT_FOUND,

    RPC_NT_ALREADY_REGISTERED, RPC_S_ALREADY_REGISTERED,

    RPC_NT_TYPE_ALREADY_REGISTERED, RPC_S_TYPE_ALREADY_REGISTERED,

    RPC_NT_ALREADY_LISTENING, RPC_S_ALREADY_LISTENING,

    RPC_NT_NO_PROTSEQS_REGISTERED, RPC_S_NO_PROTSEQS_REGISTERED,

    RPC_NT_NOT_LISTENING, RPC_S_NOT_LISTENING,

    RPC_NT_UNKNOWN_MGR_TYPE, RPC_S_UNKNOWN_MGR_TYPE,

    RPC_NT_UNKNOWN_IF, RPC_S_UNKNOWN_IF,

    RPC_NT_NO_BINDINGS, RPC_S_NO_BINDINGS,

    RPC_NT_NO_MORE_BINDINGS, RPC_S_NO_MORE_BINDINGS,

    RPC_NT_NO_PROTSEQS, RPC_S_NO_PROTSEQS,

    RPC_NT_CANT_CREATE_ENDPOINT, RPC_S_CANT_CREATE_ENDPOINT,

    RPC_NT_OUT_OF_RESOURCES, RPC_S_OUT_OF_RESOURCES,

    RPC_NT_SERVER_TOO_BUSY, RPC_S_SERVER_TOO_BUSY,

    RPC_NT_INVALID_NETWORK_OPTIONS, RPC_S_INVALID_NETWORK_OPTIONS,

    RPC_NT_NO_CALL_ACTIVE, RPC_S_NO_CALL_ACTIVE,

    RPC_NT_CALL_FAILED, RPC_S_CALL_FAILED,

    RPC_NT_CALL_FAILED_DNE, RPC_S_CALL_FAILED_DNE,

    RPC_NT_PROTOCOL_ERROR, RPC_S_PROTOCOL_ERROR,

    RPC_NT_UNSUPPORTED_TRANS_SYN, RPC_S_UNSUPPORTED_TRANS_SYN,

    RPC_NT_UNSUPPORTED_TYPE, RPC_S_UNSUPPORTED_TYPE,

    RPC_NT_INVALID_TAG, RPC_S_INVALID_TAG,

    RPC_NT_INVALID_BOUND, RPC_S_INVALID_BOUND,

    RPC_NT_NO_ENTRY_NAME, RPC_S_NO_ENTRY_NAME,

    RPC_NT_INVALID_NAME_SYNTAX, RPC_S_INVALID_NAME_SYNTAX,

    RPC_NT_UNSUPPORTED_NAME_SYNTAX, RPC_S_UNSUPPORTED_NAME_SYNTAX,

    RPC_NT_UUID_NO_ADDRESS, RPC_S_UUID_NO_ADDRESS,

    RPC_NT_DUPLICATE_ENDPOINT, RPC_S_DUPLICATE_ENDPOINT,

    RPC_NT_UNKNOWN_AUTHN_TYPE, RPC_S_UNKNOWN_AUTHN_TYPE,

    RPC_NT_MAX_CALLS_TOO_SMALL, RPC_S_MAX_CALLS_TOO_SMALL,

    RPC_NT_STRING_TOO_LONG, RPC_S_STRING_TOO_LONG,

    RPC_NT_PROTSEQ_NOT_FOUND, RPC_S_PROTSEQ_NOT_FOUND,

    RPC_NT_PROCNUM_OUT_OF_RANGE, RPC_S_PROCNUM_OUT_OF_RANGE,

    RPC_NT_BINDING_HAS_NO_AUTH, RPC_S_BINDING_HAS_NO_AUTH,

    RPC_NT_UNKNOWN_AUTHN_SERVICE, RPC_S_UNKNOWN_AUTHN_SERVICE,

    RPC_NT_UNKNOWN_AUTHN_LEVEL, RPC_S_UNKNOWN_AUTHN_LEVEL,

    RPC_NT_INVALID_AUTH_IDENTITY, RPC_S_INVALID_AUTH_IDENTITY,

    RPC_NT_UNKNOWN_AUTHZ_SERVICE, RPC_S_UNKNOWN_AUTHZ_SERVICE,

    EPT_NT_INVALID_ENTRY, EPT_S_INVALID_ENTRY,

    EPT_NT_CANT_PERFORM_OP, EPT_S_CANT_PERFORM_OP,

    EPT_NT_NOT_REGISTERED, EPT_S_NOT_REGISTERED,

    RPC_NT_NOTHING_TO_EXPORT, RPC_S_NOTHING_TO_EXPORT,

    RPC_NT_INCOMPLETE_NAME, RPC_S_INCOMPLETE_NAME,

    RPC_NT_INVALID_VERS_OPTION, RPC_S_INVALID_VERS_OPTION,

    RPC_NT_NO_MORE_MEMBERS, RPC_S_NO_MORE_MEMBERS,

    RPC_NT_NOT_ALL_OBJS_UNEXPORTED, RPC_S_NOT_ALL_OBJS_UNEXPORTED,

    RPC_NT_INTERFACE_NOT_FOUND, RPC_S_INTERFACE_NOT_FOUND,

    RPC_NT_ENTRY_ALREADY_EXISTS, RPC_S_ENTRY_ALREADY_EXISTS,

    RPC_NT_ENTRY_NOT_FOUND, RPC_S_ENTRY_NOT_FOUND,

    RPC_NT_NAME_SERVICE_UNAVAILABLE, RPC_S_NAME_SERVICE_UNAVAILABLE,

    RPC_NT_INVALID_NAF_ID, RPC_S_INVALID_NAF_ID,

    RPC_NT_CANNOT_SUPPORT, RPC_S_CANNOT_SUPPORT,

    RPC_NT_NO_CONTEXT_AVAILABLE, RPC_S_NO_CONTEXT_AVAILABLE,

    RPC_NT_INTERNAL_ERROR, RPC_S_INTERNAL_ERROR,

    RPC_NT_ZERO_DIVIDE, RPC_S_ZERO_DIVIDE,

    RPC_NT_ADDRESS_ERROR, RPC_S_ADDRESS_ERROR,

    RPC_NT_FP_DIV_ZERO, RPC_S_FP_DIV_ZERO,

    RPC_NT_FP_UNDERFLOW, RPC_S_FP_UNDERFLOW,

    RPC_NT_FP_OVERFLOW, RPC_S_FP_OVERFLOW,

    RPC_NT_NO_MORE_ENTRIES, RPC_X_NO_MORE_ENTRIES,

    RPC_NT_SS_CHAR_TRANS_OPEN_FAIL, RPC_X_SS_CHAR_TRANS_OPEN_FAIL,

    RPC_NT_SS_CHAR_TRANS_SHORT_FILE, RPC_X_SS_CHAR_TRANS_SHORT_FILE,

    RPC_NT_SS_CONTEXT_MISMATCH, ERROR_INVALID_HANDLE,

    RPC_NT_SS_CONTEXT_DAMAGED, RPC_X_SS_CONTEXT_DAMAGED,

    RPC_NT_SS_HANDLES_MISMATCH, RPC_X_SS_HANDLES_MISMATCH,

    RPC_NT_SS_CANNOT_GET_CALL_HANDLE, RPC_X_SS_CANNOT_GET_CALL_HANDLE,

    RPC_NT_NULL_REF_POINTER, RPC_X_NULL_REF_POINTER,

    RPC_NT_ENUM_VALUE_OUT_OF_RANGE, RPC_X_ENUM_VALUE_OUT_OF_RANGE,

    RPC_NT_BYTE_COUNT_TOO_SMALL, RPC_X_BYTE_COUNT_TOO_SMALL,

    RPC_NT_BAD_STUB_DATA, RPC_X_BAD_STUB_DATA,

    RPC_NT_INVALID_OBJECT, RPC_S_INVALID_OBJECT,

    STATUS_NO_TRUST_LSA_SECRET, ERROR_NO_TRUST_LSA_SECRET,

    STATUS_NO_TRUST_SAM_ACCOUNT, ERROR_NO_TRUST_SAM_ACCOUNT,

    STATUS_TRUSTED_DOMAIN_FAILURE, ERROR_TRUSTED_DOMAIN_FAILURE,

    STATUS_TRUSTED_RELATIONSHIP_FAILURE, ERROR_TRUSTED_RELATIONSHIP_FAILURE,

    STATUS_TRUST_FAILURE, ERROR_TRUST_FAILURE,

    RPC_NT_CALL_IN_PROGRESS, RPC_S_CALL_IN_PROGRESS,

    STATUS_LOG_FILE_FULL, ERROR_LOG_FILE_FULL,

    STATUS_EVENTLOG_FILE_CHANGED, ERROR_EVENTLOG_FILE_CHANGED,

    STATUS_NOLOGON_INTERDOMAIN_TRUST_ACCOUNT, ERROR_NOLOGON_INTERDOMAIN_TRUST_ACCOUNT,

    STATUS_NOLOGON_WORKSTATION_TRUST_ACCOUNT, ERROR_NOLOGON_WORKSTATION_TRUST_ACCOUNT,

    STATUS_NOLOGON_SERVER_TRUST_ACCOUNT, ERROR_NOLOGON_SERVER_TRUST_ACCOUNT,

    STATUS_DOMAIN_TRUST_INCONSISTENT, ERROR_DOMAIN_TRUST_INCONSISTENT,

    STATUS_NO_USER_SESSION_KEY, ERROR_NO_USER_SESSION_KEY,

    STATUS_POSSIBLE_DEADLOCK, ERROR_POSSIBLE_DEADLOCK,

    STATUS_IMAGE_ALREADY_LOADED, ERROR_SERVICE_ALREADY_RUNNING,

    RPC_NT_GROUP_MEMBER_NOT_FOUND, RPC_S_GROUP_MEMBER_NOT_FOUND,

    RPC_NT_NO_INTERFACES, RPC_S_NO_INTERFACES,

    RPC_NT_CALL_CANCELLED, RPC_S_CALL_CANCELLED,

    RPC_NT_BINDING_INCOMPLETE, RPC_S_BINDING_INCOMPLETE,

    RPC_NT_COMM_FAILURE, RPC_S_COMM_FAILURE,

    RPC_NT_UNSUPPORTED_AUTHN_LEVEL, RPC_S_UNSUPPORTED_AUTHN_LEVEL,

    RPC_NT_NO_PRINC_NAME, RPC_S_NO_PRINC_NAME,

    RPC_NT_NOT_RPC_ERROR, RPC_S_NOT_RPC_ERROR,

    RPC_NT_UUID_LOCAL_ONLY, RPC_S_UUID_LOCAL_ONLY,

    RPC_NT_SEC_PKG_ERROR, RPC_S_SEC_PKG_ERROR,

    RPC_NT_NOT_CANCELLED, RPC_S_NOT_CANCELLED,

    RPC_NT_INVALID_ES_ACTION, RPC_X_INVALID_ES_ACTION,
    RPC_NT_WRONG_ES_VERSION, RPC_X_WRONG_ES_VERSION,
    RPC_NT_WRONG_STUB_VERSION, RPC_X_WRONG_STUB_VERSION,

    RPC_NT_INVALID_PIPE_OBJECT,    RPC_X_INVALID_PIPE_OBJECT,
//    RPC_NT_INVALID_PIPE_OPERATION, RPC_X_INVALID_PIPE_OPERATION,
    RPC_NT_WRONG_PIPE_VERSION,     RPC_X_WRONG_PIPE_VERSION,

    EPT_NT_CANT_CREATE,            EPT_S_CANT_CREATE,

    RPC_NT_SEND_INCOMPLETE,        RPC_S_SEND_INCOMPLETE,
    RPC_NT_INVALID_ASYNC_HANDLE,   RPC_S_INVALID_ASYNC_HANDLE,
    RPC_NT_INVALID_ASYNC_CALL,     RPC_S_INVALID_ASYNC_CALL,
    RPC_NT_PIPE_CLOSED,            RPC_X_PIPE_CLOSED,
    RPC_NT_PIPE_EMPTY,             RPC_X_PIPE_EMPTY,
    RPC_NT_PIPE_DISCIPLINE_ERROR,  RPC_X_PIPE_DISCIPLINE_ERROR,

    STATUS_NO_BROWSER_SERVERS_FOUND, ERROR_NO_BROWSER_SERVERS_FOUND,

    STATUS_MAPPED_ALIGNMENT, ERROR_MAPPED_ALIGNMENT,

    STATUS_CONNECTION_IN_USE, ERROR_DEVICE_IN_USE,

    STATUS_VERIFY_REQUIRED, ERROR_MEDIA_CHANGED,

    STATUS_ALREADY_DISCONNECTED, ERROR_ACTIVE_CONNECTIONS,

    STATUS_CONNECTION_REFUSED, ERROR_CONNECTION_REFUSED,

    STATUS_GRACEFUL_DISCONNECT, ERROR_GRACEFUL_DISCONNECT,

    STATUS_ADDRESS_ALREADY_ASSOCIATED, ERROR_ADDRESS_ALREADY_ASSOCIATED,

    STATUS_ADDRESS_NOT_ASSOCIATED, ERROR_ADDRESS_NOT_ASSOCIATED,

    STATUS_CONNECTION_INVALID, ERROR_CONNECTION_INVALID,

    STATUS_CONNECTION_ACTIVE, ERROR_CONNECTION_ACTIVE,

    STATUS_NETWORK_UNREACHABLE, ERROR_NETWORK_UNREACHABLE,

    STATUS_HOST_UNREACHABLE, ERROR_HOST_UNREACHABLE,

    STATUS_PROTOCOL_UNREACHABLE, ERROR_PROTOCOL_UNREACHABLE,

    STATUS_PORT_UNREACHABLE, ERROR_PORT_UNREACHABLE,

    STATUS_REQUEST_ABORTED, ERROR_REQUEST_ABORTED,

    STATUS_CONNECTION_ABORTED, ERROR_CONNECTION_ABORTED,

    STATUS_CONNECTION_COUNT_LIMIT, ERROR_CONNECTION_COUNT_LIMIT,

    STATUS_PATH_NOT_COVERED, ERROR_HOST_UNREACHABLE,

    STATUS_LOGIN_TIME_RESTRICTION, ERROR_LOGIN_TIME_RESTRICTION,
    STATUS_LOGIN_WKSTA_RESTRICTION, ERROR_LOGIN_WKSTA_RESTRICTION,
    STATUS_LICENSE_QUOTA_EXCEEDED, ERROR_LICENSE_QUOTA_EXCEEDED,

    STATUS_RESOURCE_NOT_OWNED, ERROR_NOT_OWNER,

    STATUS_DUPLICATE_OBJECTID, STATUS_DUPLICATE_OBJECTID,
    STATUS_OBJECTID_EXISTS, STATUS_OBJECTID_EXISTS,
    SEC_E_INSUFFICIENT_MEMORY, ERROR_NO_SYSTEM_RESOURCES,
    SEC_E_INVALID_HANDLE, ERROR_INVALID_HANDLE,
    SEC_E_UNSUPPORTED_FUNCTION, ERROR_INVALID_FUNCTION,
    SEC_E_TARGET_UNKNOWN, ERROR_BAD_NETPATH,
    SEC_E_INTERNAL_ERROR, ERROR_INTERNAL_ERROR,
    SEC_E_SECPKG_NOT_FOUND, ERROR_NO_SUCH_PACKAGE,
    SEC_E_NOT_OWNER, ERROR_NOT_OWNER,
    SEC_E_CANNOT_INSTALL, ERROR_NO_SUCH_PACKAGE,
    SEC_E_INVALID_TOKEN, ERROR_INVALID_PARAMETER,
    SEC_E_CANNOT_PACK, ERROR_INVALID_PARAMETER,
    SEC_E_QOP_NOT_SUPPORTED, ERROR_NOT_SUPPORTED,
    SEC_E_NO_IMPERSONATION, ERROR_CANNOT_IMPERSONATE,
    SEC_E_LOGON_DENIED, ERROR_LOGON_FAILURE,
    SEC_E_UNKNOWN_CREDENTIALS, ERROR_INVALID_PARAMETER,
    SEC_E_INCOMPLETE_CREDENTIALS, ERROR_INVALID_PARAMETER,
    SEC_E_NO_CREDENTIALS, ERROR_NO_SUCH_LOGON_SESSION,
    SEC_E_MESSAGE_ALTERED, ERROR_ACCESS_DENIED,
    SEC_E_OUT_OF_SEQUENCE, ERROR_ACCESS_DENIED,
    SEC_E_NO_AUTHENTICATING_AUTHORITY, ERROR_NO_LOGON_SERVERS,
    SEC_E_BAD_PKGID, ERROR_NO_SUCH_PACKAGE,
    SEC_E_WRONG_PRINCIPAL, ERROR_WRONG_TARGET_NAME,
    SEC_E_INCOMPLETE_MESSAGE, ERROR_INVALID_USER_BUFFER,
    SEC_E_BUFFER_TOO_SMALL, ERROR_INSUFFICIENT_BUFFER,
    SEC_E_UNTRUSTED_ROOT, ERROR_TRUST_FAILURE,
    SEC_E_ILLEGAL_MESSAGE, ERROR_INVALID_PARAMETER,
    SEC_E_CERT_UNKNOWN, ERROR_INVALID_PARAMETER,
    SEC_E_CERT_EXPIRED, ERROR_PASSWORD_EXPIRED,
    SEC_E_ENCRYPT_FAILURE, ERROR_ENCRYPTION_FAILED,
    SEC_E_DECRYPT_FAILURE, ERROR_DECRYPTION_FAILED,
    SEC_E_ALGORITHM_MISMATCH, ERROR_INVALID_FUNCTION,

    STATUS_DEVICE_REMOVED,ERROR_DEVICE_REMOVED,

    STATUS_RETRY,ERROR_RETRY,

    // Smb Server Entries

    STATUS_ENDPOINT_CLOSED,                 ERROR_DEV_NOT_EXIST,
    STATUS_DISCONNECTED,                    ERROR_DEV_NOT_EXIST,
    STATUS_NONEXISTENT_NET_NAME,            ERROR_DEV_NOT_EXIST,

    STATUS_FILES_OPEN,                      ERROR_OPEN_FILES,

    0xffffffff, 0
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\rtl\heappage.h ===
//
//  heappage.h
//

#ifndef _HEAP_PAGE_H_
#define _HEAP_PAGE_H_

//
//  #defining DEBUG_PAGE_HEAP will cause the page heap manager
//  to be compiled.  Only #define this flag if NOT kernel mode.
//  Probably want to define this just for checked-build (DBG).
//

#ifndef NTOS_KERNEL_RUNTIME
//    #if DBG
        #define DEBUG_PAGE_HEAP 1
//    #endif
#endif

#include "heappagi.h"

#ifndef DEBUG_PAGE_HEAP

//
//  These macro-based hooks should be defined to nothing so they
//  simply "go away" during compile if the debug heap manager is
//  not desired (retail builds).
//

#define IS_DEBUG_PAGE_HEAP_HANDLE( HeapHandle ) FALSE
#define IF_DEBUG_PAGE_HEAP_THEN_RETURN( Handle, ReturnThis )
#define IF_DEBUG_PAGE_HEAP_THEN_CALL( Handle, CallThis )
#define IF_DEBUG_PAGE_HEAP_THEN_BREAK( Handle, Text, ReturnThis )

#define HEAP_FLAG_PAGE_ALLOCS 0

#define RtlpDebugPageHeapValidate( HeapHandle, Flags, Address ) TRUE

#else // DEBUG_PAGE_HEAP

//
//  The following definitions and prototypes are the external interface
//  for hooking the debug heap manager in the retail heap manager.
//

#define HEAP_FLAG_PAGE_ALLOCS       0x01000000

#define HEAP_PROTECTION_ENABLED     0x02000000
#define HEAP_BREAK_WHEN_OUT_OF_VM   0x04000000
#define HEAP_NO_ALIGNMENT           0x08000000


#define IS_DEBUG_PAGE_HEAP_HANDLE( HeapHandle ) \
            (((PHEAP)(HeapHandle))->ForceFlags & HEAP_FLAG_PAGE_ALLOCS )


#define IF_DEBUG_PAGE_HEAP_THEN_RETURN( Handle, ReturnThis )                \
            {                                                               \
            if ( IS_DEBUG_PAGE_HEAP_HANDLE( Handle ))                       \
                {                                                           \
                return ReturnThis;                                          \
                }                                                           \
            }


#define IF_DEBUG_PAGE_HEAP_THEN_CALL( Handle, CallThis )                    \
            {                                                               \
            if ( IS_DEBUG_PAGE_HEAP_HANDLE( Handle ))                       \
                {                                                           \
                CallThis;                                                   \
                return;                                                     \
                }                                                           \
            }


#define IF_DEBUG_PAGE_HEAP_THEN_BREAK( Handle, Text, ReturnThis )           \
            {                                                               \
            if ( IS_DEBUG_PAGE_HEAP_HANDLE( Handle ))                       \
                {                                                           \
                RtlpDebugPageHeapBreak( Text );                             \
                return ReturnThis;                                          \
                }                                                           \
            }


PVOID
RtlpDebugPageHeapCreate(
    IN ULONG Flags,
    IN PVOID HeapBase,
    IN SIZE_T ReserveSize,
    IN SIZE_T CommitSize,
    IN PVOID Lock,
    IN PRTL_HEAP_PARAMETERS Parameters
    );

PVOID
RtlpDebugPageHeapAllocate(
    IN PVOID HeapHandle,
    IN ULONG Flags,
    IN SIZE_T Size
    );

BOOLEAN
RtlpDebugPageHeapFree(
    IN PVOID HeapHandle,
    IN ULONG Flags,
    IN PVOID Address
    );

PVOID
RtlpDebugPageHeapReAllocate(
    IN PVOID HeapHandle,
    IN ULONG Flags,
    IN PVOID Address,
    IN SIZE_T Size
    );

PVOID
RtlpDebugPageHeapDestroy(
    IN PVOID HeapHandle
    );

SIZE_T
RtlpDebugPageHeapSize(
    IN PVOID HeapHandle,
    IN ULONG Flags,
    IN PVOID Address
    );

ULONG
RtlpDebugPageHeapGetProcessHeaps(
    ULONG NumberOfHeaps,
    PVOID *ProcessHeaps
    );

ULONG
RtlpDebugPageHeapCompact(
    IN PVOID HeapHandle,
    IN ULONG Flags
    );

BOOLEAN
RtlpDebugPageHeapValidate(
    IN PVOID HeapHandle,
    IN ULONG Flags,
    IN PVOID Address
    );

NTSTATUS
RtlpDebugPageHeapWalk(
    IN PVOID HeapHandle,
    IN OUT PRTL_HEAP_WALK_ENTRY Entry
    );

BOOLEAN
RtlpDebugPageHeapLock(
    IN PVOID HeapHandle
    );

BOOLEAN
RtlpDebugPageHeapUnlock(
    IN PVOID HeapHandle
    );

BOOLEAN
RtlpDebugPageHeapSetUserValue(
    IN PVOID HeapHandle,
    IN ULONG Flags,
    IN PVOID Address,
    IN PVOID UserValue
    );

BOOLEAN
RtlpDebugPageHeapGetUserInfo(
    IN  PVOID  HeapHandle,
    IN  ULONG  Flags,
    IN  PVOID  Address,
    OUT PVOID* UserValue,
    OUT PULONG UserFlags
    );

BOOLEAN
RtlpDebugPageHeapSetUserFlags(
    IN PVOID HeapHandle,
    IN ULONG Flags,
    IN PVOID Address,
    IN ULONG UserFlagsReset,
    IN ULONG UserFlagsSet
    );

BOOLEAN
RtlpDebugPageHeapSerialize(
    IN PVOID HeapHandle
    );

NTSTATUS
RtlpDebugPageHeapExtend(
    IN PVOID HeapHandle,
    IN ULONG Flags,
    IN PVOID Base,
    IN SIZE_T Size
    );

NTSTATUS
RtlpDebugPageHeapZero(
    IN PVOID HeapHandle,
    IN ULONG Flags
    );

NTSTATUS
RtlpDebugPageHeapReset(
    IN PVOID HeapHandle,
    IN ULONG Flags
    );

NTSTATUS
RtlpDebugPageHeapUsage(
    IN PVOID HeapHandle,
    IN ULONG Flags,
    IN OUT PRTL_HEAP_USAGE Usage
    );

BOOLEAN
RtlpDebugPageHeapIsLocked(
    IN PVOID HeapHandle
    );

VOID
RtlpDebugPageHeapBreak(
    PCH Text
    );


#endif // DEBUG_PAGE_HEAP

#endif // _HEAP_PAGE_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\rtl\heapdll.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    heapdll.c

Abstract:

    This module implements the user mode only portions of the heap allocator.

Author:

    Steve Wood (stevewo) 20-Sep-1994

Revision History:

--*/

#include "ntrtlp.h"
#include "heap.h"
#include "heappriv.h"

#ifdef NTHEAP_ENABLED
#include "heapp.h"
#endif // NTHEAP_ENABLED


//
//  This structure is used by RtlUsageHeap to keep track of heap usage
//  between calls.  This package typecasts an extra reserved buffer passed
//  in by the user to hold this information
//

typedef struct _RTL_HEAP_USAGE_INTERNAL {
    PVOID Base;
    SIZE_T ReservedSize;
    SIZE_T CommittedSize;
    PRTL_HEAP_USAGE_ENTRY FreeList;
    PRTL_HEAP_USAGE_ENTRY LargeEntriesSentinal;
    ULONG Reserved;
} RTL_HEAP_USAGE_INTERNAL, *PRTL_HEAP_USAGE_INTERNAL;


//
//  Note that the following variables are specific to each process
//
//
//  This is a lock used to protect access the this processes heap list
//

HEAP_LOCK RtlpProcessHeapsListLock;

//
//  This is a specific list of heaps initialized and used by the process
//

#define RTLP_STATIC_HEAP_LIST_SIZE 16

PHEAP RtlpProcessHeapsListBuffer[ RTLP_STATIC_HEAP_LIST_SIZE ];

//
//  This variable stores a pointer to the heap used to storage global heap
//  tags
//

PHEAP RtlpGlobalTagHeap = NULL;

//
//  This varible is used by the process as work space to build up names for
//  pseudo tags
//

static WCHAR RtlpPseudoTagNameBuffer[ 24 ];


BOOLEAN
RtlpGrowBlockInPlace (
    IN PHEAP Heap,
    IN ULONG Flags,
    IN PHEAP_ENTRY BusyBlock,
    IN SIZE_T Size,
    IN SIZE_T AllocationIndex
    );

PVOID
RtlDebugReAllocateHeap (
    IN PVOID HeapHandle,
    IN ULONG Flags,
    IN PVOID BaseAddress,
    IN SIZE_T Size
    );

BOOLEAN
RtlDebugGetUserInfoHeap (
    IN PVOID HeapHandle,
    IN ULONG Flags,
    IN PVOID BaseAddress,
    OUT PVOID *UserValue OPTIONAL,
    OUT PULONG UserFlags OPTIONAL
    );

BOOLEAN
RtlDebugSetUserValueHeap (
    IN PVOID HeapHandle,
    IN ULONG Flags,
    IN PVOID BaseAddress,
    IN PVOID UserValue
    );

BOOLEAN
RtlDebugSetUserFlagsHeap (
    IN PVOID HeapHandle,
    IN ULONG Flags,
    IN PVOID BaseAddress,
    IN ULONG UserFlagsReset,
    IN ULONG UserFlagsSet
    );

SIZE_T
RtlDebugCompactHeap (
    IN PVOID HeapHandle,
    IN ULONG Flags
    );

NTSTATUS
RtlDebugCreateTagHeap (
    IN PVOID HeapHandle,
    IN ULONG Flags,
    IN PWSTR TagPrefix OPTIONAL,
    IN PWSTR TagNames
    );

PWSTR
RtlDebugQueryTagHeap (
    IN PVOID HeapHandle,
    IN ULONG Flags,
    IN USHORT TagIndex,
    IN BOOLEAN ResetCounters,
    OUT PRTL_HEAP_TAG_INFO TagInfo OPTIONAL
    );

NTSTATUS
RtlDebugUsageHeap (
    IN PVOID HeapHandle,
    IN ULONG Flags,
    IN OUT PRTL_HEAP_USAGE Usage
    );

BOOLEAN
RtlDebugWalkHeap (
    IN PVOID HeapHandle,
    IN OUT PRTL_HEAP_WALK_ENTRY Entry
    );

PHEAP_TAG_ENTRY
RtlpAllocateTags (
    PHEAP Heap,
    ULONG NumberOfTags
    );

PRTL_HEAP_USAGE_ENTRY
RtlpFreeHeapUsageEntry (
    PRTL_HEAP_USAGE_INTERNAL Buffer,
    PRTL_HEAP_USAGE_ENTRY p
    );

NTSTATUS
RtlpAllocateHeapUsageEntry (
    PRTL_HEAP_USAGE_INTERNAL Buffer,
    PRTL_HEAP_USAGE_ENTRY *pp
    );

//
//  Declared in ntrtl.h
//

NTSTATUS
RtlInitializeHeapManager(
    VOID
    )

/*++

Routine Description:

    This routine is used to initialize the heap manager for the current process

Arguments:

    None.

Return Value:

    None.

--*/

{
    PPEB Peb = NtCurrentPeb();

#if DBG

    //
    //  Sanity check the sizes of the header entry structures
    //

    if (sizeof( HEAP_ENTRY ) != sizeof( HEAP_ENTRY_EXTRA )) {

        HeapDebugPrint(( "Heap header and extra header sizes disagree\n" ));

        HeapDebugBreak( NULL );
    }

    if (sizeof( HEAP_ENTRY ) != CHECK_HEAP_TAIL_SIZE) {

        HeapDebugPrint(( "Heap header and tail fill sizes disagree\n" ));

        HeapDebugBreak( NULL );
    }

    if (sizeof( HEAP_FREE_ENTRY ) != (2 * sizeof( HEAP_ENTRY ))) {

        HeapDebugPrint(( "Heap header and free header sizes disagree\n" ));

        HeapDebugBreak( NULL );
    }

#endif // DBG

    //
    //  Initialize the heap specific structures in the current peb
    //

    Peb->NumberOfHeaps = 0;
    Peb->MaximumNumberOfHeaps = RTLP_STATIC_HEAP_LIST_SIZE;
    Peb->ProcessHeaps = RtlpProcessHeapsListBuffer;

#ifdef NTHEAP_ENABLED
    {
        (VOID) RtlInitializeNtHeapManager();
    }
#endif // NTHEAP_ENABLED

    //
    //  Initialize the lock and return to our caller
    //

    return RtlInitializeLockRoutine( &RtlpProcessHeapsListLock.Lock );
}


//
//  Declared in ntrtl.h
//

VOID
RtlProtectHeap (
    IN PVOID HeapHandle,
    IN BOOLEAN MakeReadOnly
    )

/*++

Routine Description:

    This routine will change the protection on all the pages in a heap
    to be either readonly or readwrite

Arguments:

    HeapHandle - Supplies a pointer to the heap being altered

    MakeReadOnly - Specifies if the heap is to be made readonly or
        readwrite

Return Value:

    None.

--*/

{
    PHEAP Heap;
    UCHAR SegmentIndex;
    PHEAP_SEGMENT Segment;
    MEMORY_BASIC_INFORMATION VaInfo;
    NTSTATUS Status;
    PVOID Address;
    PVOID ProtectAddress;
    SIZE_T Size;
    ULONG OldProtect;
    ULONG NewProtect;

    Heap = (PHEAP)HeapHandle;

    //
    //  For every valid segment in the heap we will zoom through all its
    //  regions and for those that are committed we'll change it protection
    //

    for (SegmentIndex=0; SegmentIndex<HEAP_MAXIMUM_SEGMENTS; SegmentIndex++) {

        Segment = Heap->Segments[ SegmentIndex ];

        if ( Segment ) {

            //
            //  Starting from the first address for the segment and going to
            //  the last address in the segment we'll step through by regions
            //

            Address = Segment->BaseAddress;

            while ((ULONG_PTR)Address < (ULONG_PTR)(Segment->LastValidEntry)) {

                //
                //  Query the current region to get its state and size
                //

                Status = ZwQueryVirtualMemory( NtCurrentProcess(),
                                               Address,
                                               MemoryBasicInformation,
                                               &VaInfo,
                                               sizeof(VaInfo),
                                               NULL );

                if (!NT_SUCCESS( Status )) {

                    HeapDebugPrint(( "VirtualQuery Failed 0x%08x %x\n", Address, Status ));

                    return;
                }

                //
                //  If we found a commited block then set its protection
                //

                if (VaInfo.State == MEM_COMMIT) {

                    Size = VaInfo.RegionSize;

                    ProtectAddress = Address;

                    if (MakeReadOnly) {

                        NewProtect = PAGE_READONLY;

                    } else {

                        NewProtect = PAGE_READWRITE;
                    }

                    Status = ZwProtectVirtualMemory( NtCurrentProcess(),
                                                     &ProtectAddress,
                                                     &Size,
                                                     NewProtect,
                                                     &OldProtect );

                    if (!NT_SUCCESS( Status )) {

                        HeapDebugPrint(( "VirtualProtect Failed 0x%08x %x\n", Address, Status ));

                        return;
                    }
                }

                //
                //  Now calculate the address of the next region in the segment
                //

                Address = (PVOID)((PCHAR)Address + VaInfo.RegionSize);
            }
        }
    }

    //
    //  And return to our caller
    //

    return;
}


//
//  Declared in nturtl.h
//

BOOLEAN
RtlLockHeap (
    IN PVOID HeapHandle
    )

/*++

Routine Description:

    This routine is used by lock access to a specific heap structure

Arguments:

    HeapHandle - Supplies a pointer to the heap being locked

Return Value:

    BOOLEAN - TRUE if the heap is now locked and FALSE otherwise (i.e.,
        the heap is ill-formed).  TRUE is returned even if the heap is
        not lockable.

--*/

{
    PHEAP Heap = (PHEAP)HeapHandle;

    RTL_PAGED_CODE();

    //
    //  Check for the heap protected by guard pages
    //

    IF_DEBUG_PAGE_HEAP_THEN_RETURN( HeapHandle,
                                    RtlpDebugPageHeapLock( HeapHandle ));

    //
    //  Validate that HeapAddress points to a HEAP structure.
    //

    if (!RtlpCheckHeapSignature( Heap, "RtlLockHeap" )) {

        return FALSE;
    }

    //
    //  Lock the heap.  And disable the lookaside list by incrementing
    //  its lock count.
    //

    if (!(Heap->Flags & HEAP_NO_SERIALIZE)) {

        RtlAcquireLockRoutine( Heap->LockVariable );

        Heap->LookasideLockCount += 1;
    }

    return TRUE;
}


//
//  Declared in nturtl.h
//

BOOLEAN
RtlUnlockHeap (
    IN PVOID HeapHandle
    )

/*++

Routine Description:

    This routine is used to unlock access to a specific heap structure

Arguments:

    HeapHandle - Supplies a pointer to the heep being unlocked

Return Value:

    BOOLEAN - TRUE if the heap is now unlocked and FALSE otherwise (i.e.,
        the heap is ill-formed).  TRUE is also returned if the heap was
        never locked to begin with because it is not seralizable.

--*/

{
    PHEAP Heap = (PHEAP)HeapHandle;

    RTL_PAGED_CODE();

    //
    //  Check for the heap protected by guard pages
    //

    IF_DEBUG_PAGE_HEAP_THEN_RETURN( HeapHandle,
                                    RtlpDebugPageHeapUnlock( HeapHandle ));

    //
    //  Validate that HeapAddress points to a HEAP structure.
    //

    if (!RtlpCheckHeapSignature( Heap, "RtlUnlockHeap" )) {

        return FALSE;
    }

    //
    //  Unlock the heap.  And enable the lookaside logic by decrementing
    //  its lock count
    //

    if (!(Heap->Flags & HEAP_NO_SERIALIZE)) {

        Heap->LookasideLockCount -= 1;

        RtlReleaseLockRoutine( Heap->LockVariable );
    }

    return TRUE;
}


//
//  Declared in nturtl.h
//

PVOID
RtlReAllocateHeap (
    IN PVOID HeapHandle,
    IN ULONG Flags,
    IN PVOID BaseAddress,
    IN SIZE_T Size
    )

/*++

Routine Description:

    This routine will resize a user specified heap block.  The new size
    can either be smaller or larger than the current block size.

Arguments:

    HeapHandle - Supplies a pointer to the heap being modified

    Flags - Supplies a set of heap flags to augment those already
        enforced by the heap

    BaseAddress - Supplies the current address of a block allocated
        from heap.  We will try and resize this block at its current
        address, but it could possibly move if this heap structure
        allows for relocation

    Size - Supplies the size, in bytes, for the newly resized heap
        block

Return Value:

    PVOID - A pointer to the resized block.  If the block had to move
        then this address will not be equal to the input base address

--*/

{
    PHEAP Heap = (PHEAP)HeapHandle;
    SIZE_T AllocationSize;
    PHEAP_ENTRY BusyBlock, NewBusyBlock;
    PHEAP_ENTRY_EXTRA OldExtraStuff, NewExtraStuff;
    SIZE_T FreeSize;
    BOOLEAN LockAcquired = FALSE;
    PVOID NewBaseAddress;
    PHEAP_FREE_ENTRY SplitBlock, SplitBlock2;
    SIZE_T OldSize;
    SIZE_T AllocationIndex;
    SIZE_T OldAllocationIndex;
    UCHAR FreeFlags;
    NTSTATUS Status;
    PVOID DeCommitAddress;
    SIZE_T DeCommitSize;
    EXCEPTION_RECORD ExceptionRecord;

    //
    //  If there isn't an address to relocate the heap at then our work is done
    //

    if (BaseAddress == NULL) {

        SET_LAST_STATUS( STATUS_SUCCESS );

        return NULL;
    }

#ifdef NTHEAP_ENABLED
    {
        if (Heap->Flags & NTHEAP_ENABLED_FLAG) {

            return RtlReAllocateNtHeap( HeapHandle, Flags, BaseAddress, Size );
        }
    }
#endif // NTHEAP_ENABLED

    //
    //  Augment the heap flags
    //

    Flags |= Heap->ForceFlags;

    //
    //  Check if we should simply call the debug version of heap to do the work
    //

    if (DEBUG_HEAP( Flags)) {

        return RtlDebugReAllocateHeap( HeapHandle, Flags, BaseAddress, Size );
    }

    //
    //  Make sure we didn't get a negative heap size
    //

    if (Size > 0x7fffffff) {

        SET_LAST_STATUS( STATUS_NO_MEMORY );

        return NULL;
    }

    //
    //  Round the requested size up to the allocation granularity.  Note
    //  that if the request is for 0 bytes, we still allocate memory, because
    //  we add in an extra byte to protect ourselves from idiots.
    //

    AllocationSize = ((Size ? Size : 1) + Heap->AlignRound) & Heap->AlignMask;

    if ((Flags & HEAP_NEED_EXTRA_FLAGS) ||
        (Heap->PseudoTagEntries != NULL) ||
        ((((PHEAP_ENTRY)BaseAddress)-1)->Flags & HEAP_ENTRY_EXTRA_PRESENT)) {

        AllocationSize += sizeof( HEAP_ENTRY_EXTRA );
    }

    try {

        //
        //  Lock the heap
        //

        if (!(Flags & HEAP_NO_SERIALIZE)) {

            RtlAcquireLockRoutine( Heap->LockVariable );

            LockAcquired = TRUE;

            //
            //  Because it is now zero the following statement will set the no
            //  serialize bit
            //

            Flags ^= HEAP_NO_SERIALIZE;
        }

        try {

            //
            //  Compute the heap block address for user specified block
            //

            BusyBlock = (PHEAP_ENTRY)BaseAddress - 1;

            //
            //  Check if the block is not in use then it is an error
            //

            if (!(BusyBlock->Flags & HEAP_ENTRY_BUSY)) {

                SET_LAST_STATUS( STATUS_INVALID_PARAMETER );

                //
                //  Bail if not a busy block.
                //

                leave;

            //
            //  We need the current (i.e., old) size and allocation of the
            //  block.  Check if the block is a big allocation.  The size
            //  field of a big block is really the unused by count
            //

            } else if (BusyBlock->Flags & HEAP_ENTRY_VIRTUAL_ALLOC) {

                OldSize = RtlpGetSizeOfBigBlock( BusyBlock );

                OldAllocationIndex = (OldSize + BusyBlock->Size) >> HEAP_GRANULARITY_SHIFT;

                //
                //  We'll need to adjust the new allocation size to account
                //  for the big block header and then round it up to a page
                //

                AllocationSize += FIELD_OFFSET( HEAP_VIRTUAL_ALLOC_ENTRY, BusyBlock );
                AllocationSize = ROUND_UP_TO_POWER2( AllocationSize, PAGE_SIZE );

            //
            //  Otherwise the block is in use and is a small allocation
            //

            } else {

                OldAllocationIndex = BusyBlock->Size;

                OldSize = (OldAllocationIndex << HEAP_GRANULARITY_SHIFT) -
                          BusyBlock->UnusedBytes;
            }

            //
            //  Compute the new allocation index
            //

            AllocationIndex = AllocationSize >> HEAP_GRANULARITY_SHIFT;

            //
            //  At this point we have the old size and index, and the new size
            //  and index
            //
            //  See if new size less than or equal to the current size.
            //

            if (AllocationIndex <= OldAllocationIndex) {

                //
                //  If the new allocation index is only one less then the current
                //  index then make the sizes equal
                //

                if (AllocationIndex + 1 == OldAllocationIndex) {

                    AllocationIndex += 1;
                    AllocationSize += sizeof( HEAP_ENTRY );
                }

                //
                //  Calculate new residual (unused) amount
                //

                if (BusyBlock->Flags & HEAP_ENTRY_VIRTUAL_ALLOC) {

                    //
                    //  In a big block the size is really the unused byte count
                    //

                    BusyBlock->Size = (USHORT)(AllocationSize - Size);

                } else if (BusyBlock->Flags & HEAP_ENTRY_EXTRA_PRESENT) {

                    //
                    //  The extra stuff struct goes after the data.  So compute
                    //  the old and new extra stuff location and copy the data
                    //

                    OldExtraStuff = (PHEAP_ENTRY_EXTRA)(BusyBlock + BusyBlock->Size - 1);

                    NewExtraStuff = (PHEAP_ENTRY_EXTRA)(BusyBlock + AllocationIndex - 1);

                    *NewExtraStuff = *OldExtraStuff;

                    //
                    //  If we're doing heap tagging then update the tag entry
                    //

                    if (IS_HEAP_TAGGING_ENABLED()) {

                        NewExtraStuff->TagIndex =
                            RtlpUpdateTagEntry( Heap,
                                                NewExtraStuff->TagIndex,
                                                OldAllocationIndex,
                                                AllocationIndex,
                                                ReAllocationAction );
                    }

                    BusyBlock->UnusedBytes = (UCHAR)(AllocationSize - Size);

                } else {

                    //
                    //  If we're doing heap tagging then update the tag entry
                    //

                    if (IS_HEAP_TAGGING_ENABLED()) {

                        BusyBlock->SmallTagIndex = (UCHAR)
                            RtlpUpdateTagEntry( Heap,
                                                BusyBlock->SmallTagIndex,
                                                BusyBlock->Size,
                                                AllocationIndex,
                                                ReAllocationAction );
                    }

                    BusyBlock->UnusedBytes = (UCHAR)(AllocationSize - Size);
                }

                //
                //  Check if the block is getting bigger, then fill in the extra
                //  space.
                //
                //  **** how can this happen if the allocation index is less than or
                //  **** equal to the old allocation index
                //

                if (Size > OldSize) {

                    //
                    //  See if we should zero the extra space
                    //

                    if (Flags & HEAP_ZERO_MEMORY) {

                        RtlZeroMemory( (PCHAR)BaseAddress + OldSize,
                                       Size - OldSize );

                    //
                    //  Otherwise see if we should fill the extra space
                    //

                    } else if (Heap->Flags & HEAP_FREE_CHECKING_ENABLED) {

                        SIZE_T PartialBytes, ExtraSize;

                        PartialBytes = OldSize & (sizeof( ULONG ) - 1);

                        if (PartialBytes) {

                            PartialBytes = 4 - PartialBytes;
                        }

                        if (Size > (OldSize + PartialBytes)) {

                            ExtraSize = (Size - (OldSize + PartialBytes)) & ~(sizeof( ULONG ) - 1);

                            if (ExtraSize != 0) {

                                RtlFillMemoryUlong( (PCHAR)(BusyBlock + 1) + OldSize + PartialBytes,
                                                    ExtraSize,
                                                    ALLOC_HEAP_FILL );
                            }
                        }
                    }
                }

                if (Heap->Flags & HEAP_TAIL_CHECKING_ENABLED) {

                    RtlFillMemory( (PCHAR)(BusyBlock + 1) + Size,
                                   CHECK_HEAP_TAIL_SIZE,
                                   CHECK_HEAP_TAIL_FILL );
                }

                //
                //  If amount of change is greater than the size of a free block,
                //  then need to free the extra space.  Otherwise, nothing else to
                //  do.
                //

                if (AllocationIndex != OldAllocationIndex) {

                    FreeFlags = BusyBlock->Flags & ~HEAP_ENTRY_BUSY;

                    if (FreeFlags & HEAP_ENTRY_VIRTUAL_ALLOC) {

                        PHEAP_VIRTUAL_ALLOC_ENTRY VirtualAllocBlock;

                        VirtualAllocBlock = CONTAINING_RECORD( BusyBlock, HEAP_VIRTUAL_ALLOC_ENTRY, BusyBlock );

                        if (IS_HEAP_TAGGING_ENABLED()) {

                            VirtualAllocBlock->ExtraStuff.TagIndex =
                                RtlpUpdateTagEntry( Heap,
                                                    VirtualAllocBlock->ExtraStuff.TagIndex,
                                                    OldAllocationIndex,
                                                    AllocationIndex,
                                                    VirtualReAllocationAction );
                        }

                        DeCommitAddress = (PCHAR)VirtualAllocBlock + AllocationSize;

                        DeCommitSize = (OldAllocationIndex << HEAP_GRANULARITY_SHIFT) -
                                       AllocationSize;

                        Status = ZwFreeVirtualMemory( NtCurrentProcess(),
                                                      (PVOID *)&DeCommitAddress,
                                                      &DeCommitSize,
                                                      MEM_RELEASE );

                        if (!NT_SUCCESS( Status )) {

                            HeapDebugPrint(( "Unable to release memory at %p for %p bytes - Status == %x\n",
                                             DeCommitAddress, DeCommitSize, Status ));

                            HeapDebugBreak( NULL );

                        } else {

                            VirtualAllocBlock->CommitSize -= DeCommitSize;
                        }

                    } else {

                        //
                        //  Otherwise, shrink size of this block to new size, and make extra
                        //  space at end free.
                        //

                        SplitBlock = (PHEAP_FREE_ENTRY)(BusyBlock + AllocationIndex);

                        SplitBlock->Flags = FreeFlags;

                        SplitBlock->PreviousSize = (USHORT)AllocationIndex;

                        SplitBlock->SegmentIndex = BusyBlock->SegmentIndex;

                        FreeSize = BusyBlock->Size - AllocationIndex;

                        BusyBlock->Size = (USHORT)AllocationIndex;

                        BusyBlock->Flags &= ~HEAP_ENTRY_LAST_ENTRY;

                        //
                        //  If the following block is uncommitted then we only need to
                        //  add this new entry to its free list
                        //

                        if (FreeFlags & HEAP_ENTRY_LAST_ENTRY) {

                            PHEAP_SEGMENT Segment;

                            Segment = Heap->Segments[SplitBlock->SegmentIndex];
                            Segment->LastEntryInSegment = (PHEAP_ENTRY)SplitBlock;

                            SplitBlock->Size = (USHORT)FreeSize;

                            RtlpInsertFreeBlockDirect( Heap, SplitBlock, (USHORT)FreeSize );

                            Heap->TotalFreeSize += FreeSize;

                        } else {

                            //
                            //  Otherwise get the next block and check if it is busy.  If it
                            //  is in use then add this new entry to its free list
                            //

                            SplitBlock2 = (PHEAP_FREE_ENTRY)((PHEAP_ENTRY)SplitBlock + FreeSize);

                            if (SplitBlock2->Flags & HEAP_ENTRY_BUSY) {

                                SplitBlock->Size = (USHORT)FreeSize;

                                ((PHEAP_FREE_ENTRY)((PHEAP_ENTRY)SplitBlock + FreeSize))->PreviousSize = (USHORT)FreeSize;

                                RtlpInsertFreeBlockDirect( Heap, SplitBlock, (USHORT)FreeSize );

                                Heap->TotalFreeSize += FreeSize;

                            } else {

                                //
                                //  Otherwise the next block is not in use so we
                                //  should be able to merge with it.  Remove the
                                //  second free block and if the combined size is
                                //  still okay then merge the two blocks and add
                                //  the single block back in.  Otherwise call a
                                //  routine that will actually break it apart
                                //  before insertion.
                                //

                                SplitBlock->Flags = SplitBlock2->Flags;

                                RtlpRemoveFreeBlock( Heap, SplitBlock2 );

                                Heap->TotalFreeSize -= SplitBlock2->Size;

                                FreeSize += SplitBlock2->Size;

                                if (FreeSize <= HEAP_MAXIMUM_BLOCK_SIZE) {

                                    SplitBlock->Size = (USHORT)FreeSize;

                                    if (!(SplitBlock->Flags & HEAP_ENTRY_LAST_ENTRY)) {

                                        ((PHEAP_FREE_ENTRY)((PHEAP_ENTRY)SplitBlock + FreeSize))->PreviousSize = (USHORT)FreeSize;

                                    } else {

                                        PHEAP_SEGMENT Segment;

                                        Segment = Heap->Segments[SplitBlock->SegmentIndex];
                                        Segment->LastEntryInSegment = (PHEAP_ENTRY)SplitBlock;
                                    }

                                    RtlpInsertFreeBlockDirect( Heap, SplitBlock, (USHORT)FreeSize );

                                    Heap->TotalFreeSize += FreeSize;

                                } else {

                                    RtlpInsertFreeBlock( Heap, SplitBlock, FreeSize );
                                }
                            }
                        }
                    }
                }

            } else {

                //
                //  At this point the new size is greater than the current size
                //
                //  If the block is a big allocation or we're not able to grow
                //  the block in place then we have a lot of work to do
                //

                if ((BusyBlock->Flags & HEAP_ENTRY_VIRTUAL_ALLOC) ||
                    !RtlpGrowBlockInPlace( Heap, Flags, BusyBlock, Size, AllocationIndex )) {

                    //
                    //  We're growing the block.  Allocate a new block with the bigger
                    //  size, copy the contents of the old block to the new block and then
                    //  free the old block.  Return the address of the new block.
                    //

                    if (Flags & HEAP_REALLOC_IN_PLACE_ONLY) {

#if DBG
                        // HeapDebugPrint(( "Failing ReAlloc because cant do it inplace.\n" ));
#endif

                        BaseAddress = NULL;

                    } else {

                        //
                        //  Clear the tag bits from the flags
                        //

                        Flags &= ~HEAP_TAG_MASK;

                        //
                        //  If there is an extra struct present then get the tag
                        //  index from the extra stuff and augment the flags with
                        //  the tag index.
                        //

                        if (BusyBlock->Flags & HEAP_ENTRY_EXTRA_PRESENT) {

                            Flags &= ~HEAP_SETTABLE_USER_FLAGS;

                            Flags |= HEAP_SETTABLE_USER_VALUE |
                                     ((BusyBlock->Flags & HEAP_ENTRY_SETTABLE_FLAGS) << 4);

                            OldExtraStuff = RtlpGetExtraStuffPointer( BusyBlock );

                            try {

                                if ((OldExtraStuff->TagIndex != 0) &&
                                    !(OldExtraStuff->TagIndex & HEAP_PSEUDO_TAG_FLAG)) {

                                    Flags |= OldExtraStuff->TagIndex << HEAP_TAG_SHIFT;
                                }

                            } except (EXCEPTION_EXECUTE_HANDLER) {

                                BusyBlock->Flags &= ~HEAP_ENTRY_EXTRA_PRESENT;
                            }

                        } else if (BusyBlock->SmallTagIndex != 0) {

                            //
                            //  There is not an extra stuff struct, but block
                            //  does have a small tag index so now add this small
                            //  tag to the flags
                            //

                            Flags |= BusyBlock->SmallTagIndex << HEAP_TAG_SHIFT;
                        }

                        //
                        //  Allocate from the heap space for the reallocation
                        //

                        NewBaseAddress = RtlAllocateHeap( HeapHandle,
                                                          Flags & ~HEAP_ZERO_MEMORY,
                                                          Size );

                        if (NewBaseAddress != NULL) {

                            //
                            //  We were able to get the allocation so now back up
                            //  to the heap block and if the block has an extra
                            //  stuff struct then copy over the extra stuff
                            //

                            NewBusyBlock = (PHEAP_ENTRY)NewBaseAddress - 1;

                            if (NewBusyBlock->Flags & HEAP_ENTRY_EXTRA_PRESENT) {

                                NewExtraStuff = RtlpGetExtraStuffPointer( NewBusyBlock );

                                if (BusyBlock->Flags & HEAP_ENTRY_EXTRA_PRESENT) {

                                    OldExtraStuff = RtlpGetExtraStuffPointer( BusyBlock );

                                    NewExtraStuff->Settable = OldExtraStuff->Settable;

                                } else {

                                    RtlZeroMemory( NewExtraStuff, sizeof( *NewExtraStuff ));
                                }
                            }

                            //
                            //  Copy over the user's data area to the new block
                            //

                            RtlMoveMemory( NewBaseAddress, BaseAddress, Size < OldSize ? Size : OldSize );

                            //
                            //  Check if we grew the block and we should zero
                            //  the remaining part.
                            //
                            //  **** is this first test always true because we're
                            //  **** in the part that grows blocks
                            //

                            if (Size > OldSize && (Flags & HEAP_ZERO_MEMORY)) {

                                RtlZeroMemory( (PCHAR)NewBaseAddress + OldSize,
                                               Size - OldSize );
                            }

                            //
                            //  Release the old block
                            //

                            RtlFreeHeap( HeapHandle,
                                         Flags,
                                         BaseAddress );
                        }

                        BaseAddress = NewBaseAddress;
                    }
                }
            }

            if ((BaseAddress == NULL) && (Flags & HEAP_GENERATE_EXCEPTIONS)) {

                //
                //  Construct an exception record.
                //

                ExceptionRecord.ExceptionCode = STATUS_NO_MEMORY;
                ExceptionRecord.ExceptionRecord = (PEXCEPTION_RECORD)NULL;
                ExceptionRecord.NumberParameters = 1;
                ExceptionRecord.ExceptionFlags = 0;
                ExceptionRecord.ExceptionInformation[ 0 ] = AllocationSize;

                RtlRaiseException( &ExceptionRecord );
            }

        } except( GetExceptionCode() == STATUS_NO_MEMORY ? EXCEPTION_CONTINUE_SEARCH :
                                                           EXCEPTION_EXECUTE_HANDLER ) {

            SET_LAST_STATUS( GetExceptionCode() );
            BaseAddress = NULL;

        }

    } finally {

        //
        //  Unlock the heap
        //

        if (LockAcquired) {

            RtlReleaseLockRoutine( Heap->LockVariable );
        }
    }

    //
    //  And return to our caller
    //

    return BaseAddress;
}


//
//  Declared in nturtl.h
//

BOOLEAN
RtlGetUserInfoHeap (
    IN PVOID HeapHandle,
    IN ULONG Flags,
    IN PVOID BaseAddress,
    OUT PVOID *UserValue OPTIONAL,
    OUT PULONG UserFlags OPTIONAL
    )

/*++

Routine Description:

    This routine returns to the user the set of user flags
    and user values for the specified heap entry.  The user value
    is set via a set call and the user flags is part of the
    user settable flags used when communicating with the heap package
    and can also be set via a set call

Arguments:

    HeapHandle - Supplies a pointer to the heap being queried

    Flags - Supplies a set of flags to agument those already in the heap

    BaseAddress - Supplies a pointer to the users heap entry being
        queried

    UserValue - Optionally supplies a pointer to recieve the heap entry
        value

    UserFlasg - Optionally supplies a pointer to recieve the heap flags

Return Value:

    BOOLEAN - TRUE if the query is successful and FALSE otherwise

--*/

{
    PHEAP Heap = (PHEAP)HeapHandle;
    PHEAP_ENTRY BusyBlock;
    PHEAP_ENTRY_EXTRA ExtraStuff;
    BOOLEAN LockAcquired = FALSE;
    BOOLEAN Result;

    //
    //  Build up a set of real flags to use in this operation
    //

    Flags |= Heap->ForceFlags;

    //
    //  Check if we should be going the debug route
    //

    if (DEBUG_HEAP( Flags )) {

        return RtlDebugGetUserInfoHeap( HeapHandle, Flags, BaseAddress, UserValue, UserFlags );
    }

    Result = FALSE;

    try {

        try {

            //
            //  Lock the heap
            //

            if (!(Flags & HEAP_NO_SERIALIZE)) {

                RtlAcquireLockRoutine( Heap->LockVariable );

                LockAcquired = TRUE;
            }

            //
            //  Backup the pointer to the heap entry
            //

            BusyBlock = (PHEAP_ENTRY)BaseAddress - 1;

            //
            //  If the entry is not in use then it is an error
            //

            if (!(BusyBlock->Flags & HEAP_ENTRY_BUSY)) {

                SET_LAST_STATUS( STATUS_INVALID_PARAMETER );

            } else {

                //
                //  The heap entry is in use so now check if there is
                //  any extra information present
                //

                if (BusyBlock->Flags & HEAP_ENTRY_EXTRA_PRESENT) {

                    //
                    //  Get a pointer to the extra information and if the
                    //  user asked for user values then that field from the
                    //  extra stuff
                    //

                    ExtraStuff = RtlpGetExtraStuffPointer( BusyBlock );

                    if (ARGUMENT_PRESENT( UserValue )) {

                        *UserValue = (PVOID)ExtraStuff->Settable;
                    }
                }

                //
                //  If the user asked for user flags then return the flags
                //  from the heap entry that are user setable
                //

                if (ARGUMENT_PRESENT( UserFlags )) {

                    *UserFlags = (BusyBlock->Flags & HEAP_ENTRY_SETTABLE_FLAGS) << 4;
                }

                //
                //  Now that the assignments are done we can say that
                //  we were successful
                //

                Result = TRUE;
            }

        } except( EXCEPTION_EXECUTE_HANDLER ) {

            SET_LAST_STATUS( GetExceptionCode() );

            Result = FALSE;
        }

    } finally {

        //
        //  Unlock the heap
        //

        if (LockAcquired) {

            RtlReleaseLockRoutine( Heap->LockVariable );
        }
    }

    //
    //  And return to our caller
    //

    return Result;
}


//
//  Declared in nturtl.h
//

BOOLEAN
RtlSetUserValueHeap (
    IN PVOID HeapHandle,
    IN ULONG Flags,
    IN PVOID BaseAddress,
    IN PVOID UserValue
    )

/*++

Routine Description:

    This routine is used to set the user settable value for a heap entry

Arguments:

    HeapHandle - Supplies a pointer to the heap being modified

    Flags - Supplies a set of flags needed to augment those already enforced
        by the heap

    BaseAddress - Supplies a pointer to the heap entry allocation being
        modified

    UserValue - Supplies the value to store in the extra stuff space of
        the heap entry

Return Value:

    BOOLEAN - TRUE if the setting worked, and FALSE otherwise.  It could be
        FALSE if the base address is invalid, or if there is not room for
        the extra stuff

--*/

{
    PHEAP Heap = (PHEAP)HeapHandle;
    PHEAP_ENTRY BusyBlock;
    PHEAP_ENTRY_EXTRA ExtraStuff;
    BOOLEAN LockAcquired = FALSE;
    BOOLEAN Result;

    //
    //  Augment the set of flags
    //

    Flags |= Heap->ForceFlags;

    //
    //  Check to see if we should be going the debug route
    //

    if (DEBUG_HEAP( Flags )) {

        return RtlDebugSetUserValueHeap( HeapHandle, Flags, BaseAddress, UserValue );
    }

    Result = FALSE;

    try {

        //
        //  Lock the heap
        //

        if (!(Flags & HEAP_NO_SERIALIZE)) {

            RtlAcquireLockRoutine( Heap->LockVariable );

            LockAcquired = TRUE;
        }

        //
        //  Get a pointer to the owning heap entry
        //

        BusyBlock = (PHEAP_ENTRY)BaseAddress - 1;

        //
        //  If the entry is not in use then its is an error
        //

        if (!(BusyBlock->Flags & HEAP_ENTRY_BUSY)) {

            SET_LAST_STATUS( STATUS_INVALID_PARAMETER );

        //
        //  Otherwise we only can set the value if the entry has space
        //  for the extra stuff
        //

        } else if (BusyBlock->Flags & HEAP_ENTRY_EXTRA_PRESENT) {

            ExtraStuff = RtlpGetExtraStuffPointer( BusyBlock );

            ExtraStuff->Settable = (ULONG_PTR)UserValue;

            Result = TRUE;
        }

    } finally {

        //
        //  Unlock the heap
        //

        if (LockAcquired) {

            RtlReleaseLockRoutine( Heap->LockVariable );
        }
    }

    //
    //  And return to our caller
    //

    return Result;
}


//
//  Declared in nturtl.h
//

BOOLEAN
RtlSetUserFlagsHeap (
    IN PVOID HeapHandle,
    IN ULONG Flags,
    IN PVOID BaseAddress,
    IN ULONG UserFlagsReset,
    IN ULONG UserFlagsSet
    )

/*++

Routine Description:

    HeapHandle - Supplies a pointer to the heap being modified

    Flags - Supplies a set of flags needed to augment those already enforced
        by the heap

    BaseAddress - Supplies a pointer to the heap entry allocation being
        modified

    UserFlagsReset - Supplies a mask of flags that the user wants cleared

    UserFlagsSet- Supplies a mask of flags that the user wants set

Return Value:

    BOOLEAN - TRUE if the operation is a success and FALSE otherwise

--*/

{
    PHEAP Heap = (PHEAP)HeapHandle;
    PHEAP_ENTRY BusyBlock;
    BOOLEAN LockAcquired = FALSE;
    BOOLEAN Result = FALSE;

    //
    //  Augment the set of flags
    //

    Flags |= Heap->ForceFlags;

    //
    //  Check to see if we should be going the debug route
    //

    if (DEBUG_HEAP( Flags )) {

        return RtlDebugSetUserFlagsHeap( HeapHandle, Flags, BaseAddress, UserFlagsReset, UserFlagsSet );
    }

    try {

        //
        //  Lock the heap
        //

        if (!(Flags & HEAP_NO_SERIALIZE)) {

            RtlAcquireLockRoutine( Heap->LockVariable );

            LockAcquired = TRUE;
        }

        try {

            //
            //  Get a pointer to the owning heap entry
            //

            BusyBlock = (PHEAP_ENTRY)BaseAddress - 1;

            //
            //  If the entry is not in use then it is an error
            //

            if (!(BusyBlock->Flags & HEAP_ENTRY_BUSY)) {

                SET_LAST_STATUS( STATUS_INVALID_PARAMETER );

            } else {

                //
                //  Otherwise modify the flags in the block
                //
                //  **** this is terrible error prone if the user passes in
                //  **** flags that aren't 0x200 0x400 or 0x800 only.
                //

                BusyBlock->Flags &= ~(UserFlagsReset >> 4);
                BusyBlock->Flags |= (UserFlagsSet >> 4);

                Result = TRUE;
            }

        } except( EXCEPTION_EXECUTE_HANDLER ) {

            SET_LAST_STATUS( GetExceptionCode() );

            Result = FALSE;
        }

    } finally {

        //
        //  Unlock the heap
        //

        if (LockAcquired) {

            RtlReleaseLockRoutine( Heap->LockVariable );
        }
    }

    return Result;
}


//
//  Declared in nturtl.h
//

ULONG
RtlCreateTagHeap (
    IN PVOID HeapHandle,
    IN ULONG Flags,
    IN PWSTR TagPrefix OPTIONAL,
    IN PWSTR TagNames
    )

/*++

Routine Description:

    This routine create a tag heap for either the specified heap or
    for the global tag heap.

Arguments:

    HeapHandle - Optionally supplies a pointer to the heap that we
        want modified.  If null then the global tag heap is used

    Flags - Supplies a list of flags to augment the flags already
        enforced by the heap

    TagPrefix - Optionally supplies a null terminated wchar string
        of a prefix to add to each tag

    TagNames - Supplies a list of tag names separated by null and terminated
        by a double null.  If the first name in the list start with
        a "!" then it is interpreted as the heap name.  The syntax
        for the tag name is

            [!<heapname> nul ] {<tagname> nul}* nul

Return Value:

    ULONG - returns the index of the last tag create shifted to the high
        order word.

--*/

{
    PHEAP Heap = (PHEAP)HeapHandle;
    BOOLEAN LockAcquired = FALSE;
    ULONG TagIndex;
    ULONG NumberOfTags, MaxTagNameLength, TagPrefixLength;
    PWSTR s, s1, HeapName;
    PHEAP_TAG_ENTRY TagEntry;
    ULONG Result;

    //
    //  Check if tagging is disable and so this call is a noop
    //

    if (!IS_HEAP_TAGGING_ENABLED()) {

        return 0;
    }

    //
    //  If the processes global tag heap has not been created yet then
    //  allocate a global tag heap
    //

    if (RtlpGlobalTagHeap == NULL) {

        RtlpGlobalTagHeap = RtlAllocateHeap( RtlProcessHeap( ), HEAP_ZERO_MEMORY, sizeof( HEAP ));

        if (RtlpGlobalTagHeap == NULL) {

            return 0;
        }
    }

    try {

        //
        //  If the user passed in a heap then we'll use the lock from that
        //  heap to synchronize our work.  Otherwise we're unsynchronized
        //

        if (Heap != NULL) {

            //
            //  Tagging is not part of the guard page heap package
            //

            IF_DEBUG_PAGE_HEAP_THEN_RETURN( HeapHandle, 0 );

            //
            //  Check if we should be calling the debug version of the heap package
            //

            if (DEBUG_HEAP( Flags )) {

                Result = RtlDebugCreateTagHeap( HeapHandle, Flags, TagPrefix, TagNames );
                leave;
            }

            //
            //  Augment the flags and lock the specified heap
            //

            Flags |= Heap->ForceFlags;

            if (!(Flags & HEAP_NO_SERIALIZE)) {

                RtlAcquireLockRoutine( Heap->LockVariable );

                LockAcquired = TRUE;
            }
        }

        //
        //  We start off with zero tags
        //

        TagIndex = 0;
        NumberOfTags = 0;

        //
        //  With tag names that start with "!" we assume what follows
        //  is a heap name.
        //

        if (*TagNames == L'!') {

            HeapName = TagNames + 1;

            //
            //  Move up to the following tag name after the heap name
            //  separated by a null
            //

            while (*TagNames++) { NOTHING; }

        } else {

            HeapName = NULL;
        }

        //
        //  Gobble up each tag name keeping count of how many we find
        //

        s = TagNames;

        while (*s) {

            while (*s++) { NOTHING; }

            NumberOfTags += 1;
        }

        //
        //  Now we will only continue on if we were supplied tag names
        //

        if (NumberOfTags > 0) {

            //
            //  Allocate heap entries for the number of tags we need and
            //  only proceed if this allocation succeeded.   The following
            //  call also makes room for the heap name as tag index 0.  Note
            //  that is heap is null then we assume we're using the global
            //  tag heap
            //

            TagEntry = RtlpAllocateTags( Heap, NumberOfTags );

            if (TagEntry != NULL) {

                MaxTagNameLength = (sizeof( TagEntry->TagName ) / sizeof( WCHAR )) - 1;

                TagIndex = TagEntry->TagIndex;

                //
                //  If the first tag index is zero then we'll make this tag entry
                //  the heap name.
                //

                if (TagIndex == 0) {

                    if (HeapName != NULL ) {

                        //
                        //  Copy over the heap name and pad it out with nulls up
                        //  to the end of the name buffer
                        //

                        wcsncpy( TagEntry->TagName, HeapName, MaxTagNameLength );
                    }

                    //
                    //  Whether we add a heap name or not we'll move on to the
                    //  next tag entry and index
                    //

                    TagEntry += 1;

                    TagIndex = TagEntry->TagIndex;

                //
                //  This isn't the first index for a specified heap, but see if
                //  it is the first index for the global heap.  If so then put
                //  name of the global tags into the 0 index
                //

                } else if (TagIndex == HEAP_GLOBAL_TAG) {

                    wcsncpy( TagEntry->TagName, L"GlobalTags", MaxTagNameLength );

                    TagEntry += 1;

                    TagIndex = TagEntry->TagIndex;
                }

                //
                //  Now we've taken case of the 0 index we'll go on to the rest of
                //  the tags.  If there is tag prefix and it is not zero length
                //  then we'll use this tag prefix provided that is leaves us at
                //  least 4 characters for the tag name itself.  Otherwise we'll
                //  ignore the tag prefix (by setting the variable to null).
                //

                if ((ARGUMENT_PRESENT( TagPrefix )) &&
                    (TagPrefixLength = wcslen( TagPrefix ))) {

                    if (TagPrefixLength >= MaxTagNameLength-4) {

                        TagPrefix = NULL;

                    } else {

                        MaxTagNameLength -= TagPrefixLength;
                    }

                } else {

                    TagPrefix = NULL;
                }

                //
                //  For every tag name (note that this varable has already been
                //  advanced beyond the heap name) we'll put it in a tag entry
                //  by copying in the prefix and then appending on the tag itself
                //
                //   s points to the current users supplied tag name
                //  s1 points to the tag name buffer in the current tag entry
                //

                s = TagNames;

                while (*s) {

                    s1 = TagEntry->TagName;

                    //
                    //  Copy in the optional tag prefix and update s1
                    //

                    if (ARGUMENT_PRESENT( TagPrefix )) {

                        wcscpy( s1, TagPrefix );

                        s1 += TagPrefixLength;
                    }

                    //
                    //  Copy over the remaining tag name padding it with nulls
                    //  up to the end of the name buffer
                    //

                    wcsncpy( s1, s, MaxTagNameLength );

                    //
                    //  Skip to the next tag name
                    //

                    while (*s++) { NOTHING; }

                    //
                    //  Skip to the next tag entry
                    //

                    TagEntry += 1;
                }
            }
        }

        Result = TagIndex << HEAP_TAG_SHIFT;

    } finally {

        //
        //  Unlock the heap
        //

        if (LockAcquired) {

            RtlReleaseLockRoutine( Heap->LockVariable );
        }
    }

    //
    //  And return to our caller.  The answer we return is the last tag index
    //  stored in the high word of a ulong result
    //

    return Result;
}


//
//  Declared in nturtl.h
//

PWSTR
RtlQueryTagHeap (
    IN PVOID HeapHandle,
    IN ULONG Flags,
    IN USHORT TagIndex,
    IN BOOLEAN ResetCounters,
    OUT PRTL_HEAP_TAG_INFO TagInfo OPTIONAL
    )

/*++

Routine Description:

    This routine returns the name and optional statistics for a given
    tag index.

Arguments:

        **** note that some of the code looks like it can handle the
        **** global tag heap but other places look rather wrong

    HeapHandle - Specifies the heap being queried.  If null then the
        global tag heap is used.

    Flags - Supplies a set flags to augment those enforced by the
        heap

    TagIndex - Specifies the tag index that we want to query

    ResetCounter - Specifies if this routine should reset the counter
        for the tag after the query

    TagInfo - Optionally supplies storage where the output tag information
        should be stored

Return Value:

    PWSTR - Returns a pointer to the tag name or NULL if the index
        doesn't exist

--*/

{
    PHEAP Heap = (PHEAP)HeapHandle;
    BOOLEAN LockAcquired = FALSE;
    PHEAP_TAG_ENTRY TagEntry;
    PWSTR Result;

    //
    //  Tagging is not part of the guard page heap package
    //

    IF_DEBUG_PAGE_HEAP_THEN_RETURN( HeapHandle, NULL );

    //
    //  Check if tagging is disabled
    //

    if (!IS_HEAP_TAGGING_ENABLED()) {

        return NULL;
    }

    try {

        //
        //  Check if the caller has given us a heap to query
        //

        if (Heap != NULL) {

            //
            //  Check if we should be using the debug version of the
            //  heap package
            //

            if (DEBUG_HEAP( Flags )) {

                Result = RtlDebugQueryTagHeap( HeapHandle, Flags, TagIndex, ResetCounters, TagInfo );
                leave;
            }

            //
            //  Lock the heap
            //

            Flags |= Heap->ForceFlags;

            if (!(Flags & HEAP_NO_SERIALIZE)) {

                RtlAcquireLockRoutine( Heap->LockVariable );

                LockAcquired = TRUE;
            }
        }

        Result = NULL;

        //
        //  **** note that the next test assumes that heap is not null
        //
        //  Check that the specified tag index is valid and that the
        //  this heap does actually have some tag entries
        //

        if ((TagIndex < Heap->NextAvailableTagIndex) &&
            (Heap->TagEntries != NULL)) {

            //
            //  Stride over to the specific tag entry and if the caller gave us
            //  an output buffer then fill in the details
            //

            TagEntry = Heap->TagEntries + TagIndex;

            if (ARGUMENT_PRESENT( TagInfo )) {

                TagInfo->NumberOfAllocations = TagEntry->Allocs;
                TagInfo->NumberOfFrees = TagEntry->Frees;
                TagInfo->BytesAllocated = TagEntry->Size << HEAP_GRANULARITY_SHIFT;
            }

            //
            //  Check if we should reset the counters
            //

            if (ResetCounters) {

                TagEntry->Allocs = 0;
                TagEntry->Frees = 0;
                TagEntry->Size = 0;
            }

            //
            //  Point to the tag name
            //

            Result = &TagEntry->TagName[ 0 ];

        //
        //  If the tag index has the psuedo tag bit set then recalulate the
        //  tag index and if this heap has pseudo tags than that is what
        //  we'll return
        //

        } else if (TagIndex & HEAP_PSEUDO_TAG_FLAG) {

            //
            //  Clear the bit
            //

            TagIndex ^= HEAP_PSEUDO_TAG_FLAG;

            if ((TagIndex < HEAP_NUMBER_OF_PSEUDO_TAG) &&
                (Heap->PseudoTagEntries != NULL)) {

                //
                //  Stride over to the specific pseudo tag entry and if the
                //  caller gave us an output buffer then fill in the details
                //

                TagEntry = (PHEAP_TAG_ENTRY)(Heap->PseudoTagEntries + TagIndex);

                if (ARGUMENT_PRESENT( TagInfo )) {

                    TagInfo->NumberOfAllocations = TagEntry->Allocs;
                    TagInfo->NumberOfFrees = TagEntry->Frees;
                    TagInfo->BytesAllocated = TagEntry->Size << HEAP_GRANULARITY_SHIFT;
                }

                //
                //  Check if we should reset the counters
                //

                if (ResetCounters) {

                    TagEntry->Allocs = 0;
                    TagEntry->Frees = 0;
                    TagEntry->Size = 0;
                }

                //
                //  Pseudo tags do not have names
                //

                Result = L"";
            }
        }

    } finally {

        //
        //  Unlock the heap
        //

        if (LockAcquired) {

            RtlReleaseLockRoutine( Heap->LockVariable );
        }
    }

    //
    //  And return the tag name to our caller
    //

    return Result;
}


//
//  Declared in nturtl.h
//

NTSTATUS
RtlExtendHeap (
    IN PVOID HeapHandle,
    IN ULONG Flags,
    IN PVOID Base,
    IN SIZE_T Size
    )

/*++

Routine Description:

    This routine grows the specified heap by adding a new segment to its
    storage.  The memory for the segment is supplied by the caller.

Arguments:

    HeapHandle - Supplies a pointer to the heap being modified

    Flags - Supplies a set of flags used to augment those already
        enforced by the heap

    Base - Supplies the starting address for the new segment being added
        to the input heap

    Size - Supplies the size, in bytes, of the new segment. Note that this
        routine will actually use more memory than specified by this
        variable.  It will use whatever is committed and reserved provided
        the amount is greater than or equal to "Size"

Return Value:

    NTSTATUS - An appropriate status value

--*/

{
    PHEAP Heap = (PHEAP)HeapHandle;
    NTSTATUS Status;
    PHEAP_SEGMENT Segment;
    BOOLEAN LockAcquired = FALSE;
    UCHAR SegmentIndex, EmptySegmentIndex;
    SIZE_T CommitSize;
    SIZE_T ReserveSize;
    ULONG SegmentFlags;
    PVOID CommittedBase;
    PVOID UnCommittedBase;
    MEMORY_BASIC_INFORMATION MemoryInformation;

    //
    //  Check if the guard page version of heap can do the work
    //

    IF_DEBUG_PAGE_HEAP_THEN_RETURN( HeapHandle,
                                    RtlpDebugPageHeapExtend( HeapHandle, Flags, Base, Size ));

    //
    //  See what Mm thinks about the base address we were passed in.
    //  The address must not be free.
    //

    Status = NtQueryVirtualMemory( NtCurrentProcess(),
                                   Base,
                                   MemoryBasicInformation,
                                   &MemoryInformation,
                                   sizeof( MemoryInformation ),
                                   NULL );

    if (!NT_SUCCESS( Status )) {

        return Status;
    }

    if (MemoryInformation.State == MEM_FREE) {

        return STATUS_INVALID_PARAMETER;
    }

    //
    //  If what we were passed in as a base address is not on a page boundary then
    //  adjust the information supplied by MM to the page boundary right after
    //  the input base address
    //

    if (MemoryInformation.BaseAddress != Base) {

        MemoryInformation.BaseAddress = (PCHAR)MemoryInformation.BaseAddress + PAGE_SIZE;
        MemoryInformation.RegionSize -= PAGE_SIZE;
    }

    try {

        //
        //  Lock the heap
        //

        if (!(Flags & HEAP_NO_SERIALIZE)) {

            RtlAcquireLockRoutine( Heap->LockVariable );

            LockAcquired = TRUE;
        }

        //
        //  Scan the heap's segment list for a free segment.  And make sure the address
        //  of all the segment does not contain the input base address
        //

        Status = STATUS_INSUFFICIENT_RESOURCES;

        EmptySegmentIndex = HEAP_MAXIMUM_SEGMENTS;

        for (SegmentIndex=0; SegmentIndex<HEAP_MAXIMUM_SEGMENTS; SegmentIndex++) {

            Segment = Heap->Segments[ SegmentIndex ];

            if (Segment) {

                if (((ULONG_PTR)Base >= (ULONG_PTR)Segment) &&
                    ((ULONG_PTR)Base < (ULONG_PTR)(Segment->LastValidEntry))) {

                    Status = STATUS_INVALID_PARAMETER;

                    break;
                }

            } else if ((Segment == NULL) &&
                       (EmptySegmentIndex == HEAP_MAXIMUM_SEGMENTS)) {

                EmptySegmentIndex = SegmentIndex;

                Status = STATUS_SUCCESS;
            }
        }

        //
        //  At this point if status is success then the empty segment index
        //  is available for us to use and base address doesn't overlap an
        //  existing segment.
        //

        if (NT_SUCCESS( Status )) {

            //
            //  Indicate that this segment is user supplied
            //

            SegmentFlags = HEAP_SEGMENT_USER_ALLOCATED;

            CommittedBase = MemoryInformation.BaseAddress;

            //
            //  If the start of the memory supplied by the use is already
            //  committed then check the state of the following
            //  uncommitted piece of memory to see if it is reserved
            //

            if (MemoryInformation.State == MEM_COMMIT) {

                CommitSize = MemoryInformation.RegionSize;

                UnCommittedBase = (PCHAR)CommittedBase + CommitSize;

                Status = NtQueryVirtualMemory( NtCurrentProcess(),
                                               UnCommittedBase,
                                               MemoryBasicInformation,
                                               &MemoryInformation,
                                               sizeof( MemoryInformation ),
                                               NULL );

                ReserveSize = CommitSize;

                if ((NT_SUCCESS( Status )) &&
                    (MemoryInformation.State == MEM_RESERVE)) {

                    ReserveSize += MemoryInformation.RegionSize;
                }

            } else {

                //
                //  Otherwise the user hasn't committed anything in the
                //  the address they gave us and we know it is not free
                //  so it must be reserved.
                //

                UnCommittedBase = CommittedBase;

                ReserveSize = MemoryInformation.RegionSize;
            }

            //
            //  Now if the reserved size is smaller than a page size or
            //  the user specified size is greater than the reserved size
            //  then the buffer we're given is too small to be a segment
            //  of heap
            //

            if ((ReserveSize < PAGE_SIZE) ||
                (Size > ReserveSize)) {

                Status = STATUS_BUFFER_TOO_SMALL;

            } else {

                //
                //  Otherwise the size is okay, now check if we need
                //  to do the commit of the base.  If so we'll commit
                //  one page

                if (UnCommittedBase == CommittedBase) {

                    CommitSize = PAGE_SIZE;

                    Status = ZwAllocateVirtualMemory( NtCurrentProcess(),
                                                      (PVOID *)&Segment,
                                                      0,
                                                      &CommitSize,
                                                      MEM_COMMIT,
                                                      PAGE_READWRITE );
                }
            }

            //
            //  At this point the if status is good then memory is all set up
            //  with at least one page of committed memory to start with.  So
            //  initialize the heap segment and we're done.
            //

            if (NT_SUCCESS( Status )) {

                if (RtlpInitializeHeapSegment( Heap,
                                               Segment,
                                               EmptySegmentIndex,
                                               0,
                                               Segment,
                                               (PCHAR)Segment + CommitSize,
                                               (PCHAR)Segment + ReserveSize )) {

                    Status = STATUS_NO_MEMORY;
                }
            }
        }

    } finally {

        //
        //  Unlock the heap
        //

        if (LockAcquired) {

            RtlReleaseLockRoutine( Heap->LockVariable );
        }
    }

    //
    //  And return to our caller
    //

    return Status;
}


//
//  Declared in nturtl.h
//

SIZE_T
NTAPI
RtlCompactHeap (
    IN PVOID HeapHandle,
    IN ULONG Flags
    )

/*++

Routine Description:

    This routine compacts the specified heap by coalescing all the free block.
    It also determines the size of the largest available free block and
    returns its, in bytes, back to the caller.

Arguments:

    HeapHandle - Supplies a pointer to the heap being modified

    Flags - Supplies a set of flags used to augment those already
        enforced by the heap

Return Value:

    SIZE_T - Returns the size, in bytes, of the largest free block
        available in the heap

--*/

{
    PHEAP Heap = (PHEAP)HeapHandle;
    PHEAP_FREE_ENTRY FreeBlock;
    PHEAP_SEGMENT Segment;
    UCHAR SegmentIndex;
    SIZE_T LargestFreeSize;
    BOOLEAN LockAcquired = FALSE;

    //
    //  Augment the heap flags
    //

    Flags |= Heap->ForceFlags;

    //
    //  Check if this is a debug version of heap
    //

    if (DEBUG_HEAP( Flags )) {

        return RtlDebugCompactHeap( HeapHandle, Flags );
    }

    try {

        //
        //  Lock the heap
        //

        if (!(Flags & HEAP_NO_SERIALIZE)) {

            RtlAcquireLockRoutine( Heap->LockVariable );

            LockAcquired = TRUE;
        }

        LargestFreeSize = 0;

        try {

            //
            //  Coalesce the heap into its largest free blocks possible
            //  and get the largest free block in the heap
            //

            FreeBlock = RtlpCoalesceHeap( (PHEAP)HeapHandle );

            //
            //  If there is a free block then compute its byte size
            //

            if (FreeBlock != NULL) {

                LargestFreeSize = FreeBlock->Size << HEAP_GRANULARITY_SHIFT;
            }

            //
            //  Scan every segment in the heap looking at its largest uncommitted
            //  range.  Remember the largest range if its bigger than anything
            //  we've found so far
            //

            for (SegmentIndex=0; SegmentIndex<HEAP_MAXIMUM_SEGMENTS; SegmentIndex++) {

                Segment = Heap->Segments[ SegmentIndex ];

                if (Segment && Segment->LargestUnCommittedRange > LargestFreeSize) {

                    LargestFreeSize = Segment->LargestUnCommittedRange;
                }
            }

        } except( EXCEPTION_EXECUTE_HANDLER ) {

            SET_LAST_STATUS( GetExceptionCode() );
        }

    } finally {

        //
        //  Unlock the heap
        //

        if (LockAcquired) {

            RtlReleaseLockRoutine( Heap->LockVariable );
        }
    }

    //
    //  And return the largest free size to our caller
    //

    return LargestFreeSize;
}


//
//  Declared in nturtl.h
//

BOOLEAN
RtlValidateHeap (
    PVOID HeapHandle,
    IN ULONG Flags,
    IN PVOID BaseAddress
    )

/*++

Routine Description:

    This routine verifies the structure of a heap and/or heap block

Arguments:

    HeapHandle - Supplies a pointer to the heap being queried

    Flags - Supplies a set of flags used to augment those already
        enforced by the heap

    BaseAddress - Optionally supplies a pointer to the heap block
        that should be individually validated

Return Value:

    BOOLEAN - TRUE if the heap/block is okay and FALSE otherwise

--*/

{
    PHEAP Heap = (PHEAP)HeapHandle;
    BOOLEAN LockAcquired = FALSE;
    BOOLEAN Result;

    try {

        try {

            //
            //  Check for the guard page version of heap
            //

            if ( IS_DEBUG_PAGE_HEAP_HANDLE( HeapHandle )) {

                Result = RtlpDebugPageHeapValidate( HeapHandle, Flags, BaseAddress );

            } else {

                //
                //  If there is an active lookaside list then drain and remove it.
                //  By setting the lookaside field in the heap to null we guarantee
                //  that the call the free heap will not try and use the lookaside
                //  list logic.
                //
                //  We'll actually capture the lookaside pointer from the heap and
                //  only use the captured pointer.  This will take care of the
                //  condition where another walk or lock heap can cause us to check
                //  for a non null pointer and then have it become null when we read
                //  it again.  If it is non null to start with then even if the
                //  user walks or locks the heap via another thread the pointer to
                //  still valid here so we can still try and do a lookaside list pop.
                //

                PHEAP_LOOKASIDE Lookaside = (PHEAP_LOOKASIDE)Heap->Lookaside;

                if (Lookaside != NULL) {

                    ULONG i;
                    PVOID Block;

                    Heap->Lookaside = NULL;

                    for (i = 0; i < HEAP_MAXIMUM_FREELISTS; i += 1) {

                        while ((Block = RtlpAllocateFromHeapLookaside(&(Lookaside[i]))) != NULL) {

                            RtlFreeHeap( HeapHandle, 0, Block );
                        }
                    }
                }

                Result = FALSE;

                //
                //  Validate that HeapAddress points to a HEAP structure.
                //

                if (RtlpCheckHeapSignature( Heap, "RtlValidateHeap" )) {

                    Flags |= Heap->ForceFlags;

                    //
                    //  Lock the heap
                    //

                    if (!(Flags & HEAP_NO_SERIALIZE)) {

                        RtlAcquireLockRoutine( Heap->LockVariable );

                        LockAcquired = TRUE;
                    }

                    //
                    //  If the user did not supply a base address then verify
                    //  the complete heap otherwise just do a single heap
                    //  entry
                    //

                    if (BaseAddress == NULL) {

                        Result = RtlpValidateHeap( Heap, TRUE );

                    } else {

                        Result = RtlpValidateHeapEntry( Heap, (PHEAP_ENTRY)BaseAddress - 1, "RtlValidateHeap" );
                    }
                }
            }

        } except( EXCEPTION_EXECUTE_HANDLER ) {

            SET_LAST_STATUS( GetExceptionCode() );

            Result = FALSE;
        }

    } finally {

        //
        //  Unlock the heap
        //

        if (LockAcquired) {

            RtlReleaseLockRoutine( Heap->LockVariable );
        }
    }

    //
    //  And return to our caller
    //

    return Result;
}


//
//  Declared in nturtl.h
//

BOOLEAN
RtlValidateProcessHeaps (
    VOID
    )

/*++

Routine Description:

    This routine cycles through all and validates each heap in the current
    process.

Arguments:

    None.

Return Value:

    BOOLEAN - TRUE if all the heap verify okay and FALSE for any other
        reason.

--*/

{
    NTSTATUS Status;
    ULONG i, NumberOfHeaps;
    PVOID HeapsArray[ 512 ];
    PVOID *Heaps;
    SIZE_T Size;
    BOOLEAN Result;

    Result = TRUE;

    Heaps = &HeapsArray[ 0 ];

    //
    //  By default we can handle 512 heaps per process any more than
    //  that and we'll need to allocate storage to do the processing
    //
    //  So now determine how many heaps are in the current process
    //

    NumberOfHeaps = RtlGetProcessHeaps( 512, Heaps );

    //
    //  **** this is bogus because the preceeding routine will
    //  **** never return more than 512.  Either this routine
    //  **** needs to get the heap count from the peb itself
    //  **** or the called routine needs to return the actual
    //  **** number of heaps in the process, Then we have to know
    //  **** not to to beyond the heap array size
    //

    if (NumberOfHeaps > 512) {

        //
        //  The number of heaps is greater than 512 so
        //  allocate extra memory to store the array of
        //  heap pointers
        //

        Heaps = NULL;
        Size = NumberOfHeaps * sizeof( PVOID );

        Status = ZwAllocateVirtualMemory( NtCurrentProcess(),
                                          (PVOID *)&Heaps,
                                          0,
                                          &Size,
                                          MEM_COMMIT,
                                          PAGE_READWRITE );

        if (!NT_SUCCESS( Status )) {

            return FALSE;
        }

        //
        //  And retry getting the heaps
        //
        //  **** this won't work again because it still uses 512
        //

        NumberOfHeaps = RtlGetProcessHeaps( 512, Heaps );
    }

    //
    //  Now for each heap in our heap array we'll validate
    //  that heap
    //

    for (i=0; i<NumberOfHeaps; i++) {

        if (!RtlValidateHeap( Heaps[i], 0, NULL )) {

            Result = FALSE;
        }
    }

    //
    //  Check if we need to return the memory that we use for
    //  an enlarged heap array
    //

    if (Heaps != &HeapsArray[ 0 ]) {

        ZwFreeVirtualMemory( NtCurrentProcess(),
                             (PVOID *)&Heaps,
                             &Size,
                             MEM_RELEASE );
    }

    //
    //  And return to our caller
    //

    return Result;
}


//
//  Declared in nturtl.h
//

ULONG
RtlGetProcessHeaps (
    ULONG NumberOfHeapsToReturn,
    PVOID *ProcessHeaps
    )

/*++

Routine Description:

    This routine determines how many individual heaps there are in the
    current process and fills an array with pointers to each heap.

Arguments:

    NumberOfHeapsToReturn - Indicates how many heaps the caller
        is willing to accept in the second parameter

    ProcessHeaps - Supplies a pointer to an array of heap pointer
        to be filled in by this routine.  The maximum size of this
        array is specified by the first parameter

Return Value:

    ULONG - Returns the smaller of the actual number of heaps in the
        the process or the size of the output buffer

--*/

{
    PPEB Peb = NtCurrentPeb();
    ULONG NumberOfHeapsToCopy;
    ULONG TotalHeaps;

    RtlAcquireLockRoutine( &RtlpProcessHeapsListLock.Lock );

    try {

        //
        //  Return no more than the number of heaps currently in use
        //

        TotalHeaps = Peb->NumberOfHeaps;

        if (TotalHeaps > NumberOfHeapsToReturn) {

            NumberOfHeapsToCopy = NumberOfHeapsToReturn;

        } else {

            NumberOfHeapsToCopy = TotalHeaps;

        }

        //
        //  Return the heap pointers to the caller
        //

        RtlMoveMemory( ProcessHeaps,
                       Peb->ProcessHeaps,
                       NumberOfHeapsToCopy * sizeof( *ProcessHeaps ));

        ProcessHeaps += NumberOfHeapsToCopy;
        NumberOfHeapsToReturn -= NumberOfHeapsToCopy;

    } finally {

        RtlReleaseLockRoutine( &RtlpProcessHeapsListLock.Lock );
    }

#ifdef DEBUG_PAGE_HEAP

    //
    //  If we have debugging page heaps, go return what we can from them
    //

    if ( RtlpDebugPageHeap ) {

        TotalHeaps +=
            RtlpDebugPageHeapGetProcessHeaps( NumberOfHeapsToReturn, ProcessHeaps );

    }

#endif

    return TotalHeaps;
}


//
//  Declared in nturtl.h
//

NTSTATUS
RtlEnumProcessHeaps (
    PRTL_ENUM_HEAPS_ROUTINE EnumRoutine,
    PVOID Parameter
    )

/*++

Routine Description:

    This routine cycles through all the heaps in a process and
    invokes the specified call back routine for that heap

Arguments:

    EnumRoutine - Supplies the callback to invoke for each heap
        in the process

    Parameter - Provides an additional parameter to pass to the
        callback routine

Return Value:

    NTSTATUS - returns success or the first error status returned
        by the callback routine

--*/

{
    PPEB Peb = NtCurrentPeb();
    NTSTATUS Status;
    ULONG i;

    Status = STATUS_SUCCESS;

    //
    //  Lock the heap
    //

    RtlAcquireLockRoutine( &RtlpProcessHeapsListLock.Lock );

    try {

        //
        //  For each heap in the process invoke the callback routine
        //  and if the callback returns anything other than success
        //  then break out and return immediately to our caller
        //

        for (i=0; i<Peb->NumberOfHeaps; i++) {

            Status = (*EnumRoutine)( (PHEAP)(Peb->ProcessHeaps[ i ]), Parameter );

            if (!NT_SUCCESS( Status )) {

                break;
            }
        }

    } finally {

        //
        //  Unlock the heap
        //

        RtlReleaseLockRoutine( &RtlpProcessHeapsListLock.Lock );
    }

    //
    //  And return to our caller
    //

    return Status;
}


//
//  Declared in nturtl.h
//

NTSTATUS
RtlUsageHeap (
    IN PVOID HeapHandle,
    IN ULONG Flags,
    IN OUT PRTL_HEAP_USAGE Usage
    )

/*++

Routine Description:

    This is a rather bizzare routine.  It models heap usage in that it returns
    to the caller the various heap sizes, but it also return three lists.  One
    is a list of entries for each active allocation in the heap.  The next two
    are used for tracking difference between usage calls.  There is a list of
    what was added and a list of what was removed.

Arguments:

    HeapHandle - Supplies a pointer to the heap being queried

    Flags - Supplies a set of flags needed to augment those enforced
        by the heap.

        HEAP_USAGE_ALLOCATED_BLOCKS - Denotes that the calls wants the list
            of allocated entries.

        HEAP_USAGE_FREE_BUFFER - Denotes the last call to this procedure and
            that any temporary storage can now be freed

    Usage - Receives the current usage statistics for the heap.  This variable
        is also used to store state information between calls to this routine.

Return Value:

    NTSTATUS - An appropriate status value.  STATUS_SUCCESS if the heap has
        not changed at all between calls and STATUS_MORE_ENTRIES if thep changed
        between two calls.

--*/

{
    NTSTATUS Status;
    PHEAP Heap = (PHEAP)HeapHandle;
    PRTL_HEAP_USAGE_INTERNAL Buffer;
    PHEAP_SEGMENT Segment;
    PHEAP_UNCOMMMTTED_RANGE UnCommittedRange;
    PHEAP_ENTRY CurrentBlock;
    PHEAP_ENTRY_EXTRA ExtraStuff;
    PLIST_ENTRY Head, Next;
    PHEAP_VIRTUAL_ALLOC_ENTRY VirtualAllocBlock;
    SIZE_T BytesFree;
    UCHAR SegmentIndex;
    BOOLEAN LockAcquired = FALSE;
    BOOLEAN VirtualAllocBlockSeen;
    PRTL_HEAP_USAGE_ENTRY pOldEntries, pNewEntries, pNewEntry;
    PRTL_HEAP_USAGE_ENTRY *ppEntries, *ppAddedEntries, *ppRemovedEntries, *pp;
    PVOID DataAddress;
    SIZE_T DataSize;

    //
    //  Augment the heap flags
    //

    Flags |= Heap->ForceFlags;

    //
    //  Check if we should be using the debug version of heap
    //

    if (DEBUG_HEAP( Flags )) {

        return RtlDebugUsageHeap( HeapHandle, Flags, Usage );
    }

    //
    //  Make sure that the size of the input buffer is correct
    //

    if (Usage->Length != sizeof( RTL_HEAP_USAGE )) {

        return STATUS_INFO_LENGTH_MISMATCH;
    }

    //
    //  Zero out the output fields
    //

    Usage->BytesAllocated = 0;
    Usage->BytesCommitted = 0;
    Usage->BytesReserved = 0;
    Usage->BytesReservedMaximum = 0;

    //
    //  Use the reserved area of the output buffer as an internal
    //  heap usage storage space between calls
    //

    Buffer = (PRTL_HEAP_USAGE_INTERNAL)&Usage->Reserved[ 0 ];

    //
    //  Check if there is not a base buffer and we should allocate
    //  one then do so now
    //

    if ((Buffer->Base == NULL) &&
        (Flags & HEAP_USAGE_ALLOCATED_BLOCKS)) {

        Buffer->ReservedSize = 4 * 1024 * 1024;

        Status = NtAllocateVirtualMemory( NtCurrentProcess(),
                                          &Buffer->Base,
                                          0,
                                          &Buffer->ReservedSize,
                                          MEM_RESERVE,
                                          PAGE_READWRITE );

        if (!NT_SUCCESS( Status )) {

            return Status;
        }

        Buffer->CommittedSize = 0;
        Buffer->FreeList = NULL;
        Buffer->LargeEntriesSentinal = NULL;

    //
    //  Otherwise check if there already is a base buffer
    //  and we should free it now
    //

    } else if ((Buffer->Base != NULL) &&
               (Flags & HEAP_USAGE_FREE_BUFFER)) {

        Buffer->ReservedSize = 0;

        Status = NtFreeVirtualMemory( NtCurrentProcess(),
                                      &Buffer->Base,
                                      &Buffer->ReservedSize,
                                      MEM_RELEASE );

        if (!NT_SUCCESS( Status )) {

            return Status;
        }

        RtlZeroMemory( Buffer, sizeof( *Buffer ) );
    }

    //
    //  **** Augment the heap flags again
    //

    Flags |= Heap->ForceFlags;

    try {

        //
        //  Lock the heap
        //

        if (!(Flags & HEAP_NO_SERIALIZE)) {

            RtlAcquireLockRoutine( Heap->LockVariable );

            LockAcquired = TRUE;
        }

        //
        //  Scan through the heap segments and for every in-use segment
        //  we add it to the amount of committed and reserved bytes
        //  If the segment is not in use and the heap is growable then
        //  we just add it to the reserved maximum
        //

        for (SegmentIndex=0; SegmentIndex<HEAP_MAXIMUM_SEGMENTS; SegmentIndex++) {

            Segment = Heap->Segments[ SegmentIndex ];

            if (Segment) {

                Usage->BytesCommitted += (Segment->NumberOfPages -
                                          Segment->NumberOfUnCommittedPages) * PAGE_SIZE;

                Usage->BytesReserved += Segment->NumberOfPages * PAGE_SIZE;

            } else if (Heap->Flags & HEAP_GROWABLE) {

                Usage->BytesReservedMaximum += Heap->SegmentReserve;
            }
        }

        Usage->BytesReservedMaximum += Usage->BytesReserved;
        Usage->BytesAllocated = Usage->BytesCommitted - (Heap->TotalFreeSize << HEAP_GRANULARITY_SHIFT);

        //
        //  Scan through the big allocations and add those amounts to the
        //  usage statistics
        //

        Head = &Heap->VirtualAllocdBlocks;
        Next = Head->Flink;

        while (Head != Next) {

            VirtualAllocBlock = CONTAINING_RECORD( Next, HEAP_VIRTUAL_ALLOC_ENTRY, Entry );

            Usage->BytesAllocated += VirtualAllocBlock->CommitSize;
            Usage->BytesCommitted += VirtualAllocBlock->CommitSize;

            Next = Next->Flink;
        }

        Status = STATUS_SUCCESS;

        //
        //  Now check if we have a base buffer and we are suppose to account
        //  for allocated blocks
        //

        if ((Buffer->Base != NULL) &&
            (Flags & HEAP_USAGE_ALLOCATED_BLOCKS)) {

            //
            //  Setup a pointer to the old entries, added entries, and removed
            //  entries in the usage struct.  Also drain the added entries
            //  and removed entries list
            //

            pOldEntries = Usage->Entries;

            ppEntries = &Usage->Entries;

            *ppEntries = NULL;

            ppAddedEntries = &Usage->AddedEntries;

            while (*ppAddedEntries = RtlpFreeHeapUsageEntry( Buffer, *ppAddedEntries )) { NOTHING; }

            ppRemovedEntries = &Usage->RemovedEntries;

            while (*ppRemovedEntries = RtlpFreeHeapUsageEntry( Buffer, *ppRemovedEntries )) { NOTHING; }

            //
            //  The way the code works is that ppEntries, ppAddedEntries, and
            //  ppRemovedEntries point to the tail of their respective lists.  If
            //  the list is empty then they point to the head.
            //

            //
            //  Process every segment in the heap
            //

            for (SegmentIndex=0; SegmentIndex<HEAP_MAXIMUM_SEGMENTS; SegmentIndex++) {

                Segment = Heap->Segments[ SegmentIndex ];

                //
                //  Only deal with segments that are in use
                //

                if (Segment) {

                    //
                    //  The current block is really the first block in current
                    //  segment.  We need to special case the computation to
                    //  account for the first heap segment.
                    //

                    if (Segment->BaseAddress == Heap) {

                        CurrentBlock = &Heap->Entry;

                    } else {

                        CurrentBlock = &Segment->Entry;
                    }

                    //
                    //  Now for every busy block in the segment we'll check if
                    //  we need to allocate a heap usage entry and put it in the
                    //  the entries list
                    //

                    while (CurrentBlock < Segment->LastValidEntry) {

                        if (CurrentBlock->Flags & HEAP_ENTRY_BUSY) {

                            //
                            //  Compute the users data address and size
                            //

                            DataAddress = (CurrentBlock+1);
                            DataSize = (CurrentBlock->Size << HEAP_GRANULARITY_SHIFT) -
                                       CurrentBlock->UnusedBytes;

    keepLookingAtOldEntries:

                            //
                            //  The first time through this routine will have
                            //  both of these variables null so we'll start off
                            //  by looking at new entries.
                            //

                            if (pOldEntries == Buffer->LargeEntriesSentinal) {

                                goto keepLookingAtNewEntries;
                            }

                            //
                            //  Check if this entry hasn't changed.
                            //
                            //  If the old entry is equal to this data block
                            //  then move the old entry back to the entries
                            //  list and go on to the next block.
                            //

                            if ((pOldEntries->Address == DataAddress) &&
                                (pOldEntries->Size == DataSize)) {

                                //
                                //  Same block, keep in entries list
                                //

                                *ppEntries = pOldEntries;
                                pOldEntries = pOldEntries->Next;
                                ppEntries = &(*ppEntries)->Next;

                                *ppEntries = NULL;

                            //
                            //  Check if an entry was removed
                            //
                            //  If this entry is beyond the old entry then move
                            //  the old entry to the removed entry list and keep
                            //  looking at the old entry list without advancing
                            //  the current data block
                            //

                            } else if (pOldEntries->Address <= DataAddress) {

                                *ppRemovedEntries = pOldEntries;
                                pOldEntries = pOldEntries->Next;
                                ppRemovedEntries = &(*ppRemovedEntries)->Next;

                                *ppRemovedEntries = NULL;

                                goto keepLookingAtOldEntries;

                            //
                            //  Otherwise the we want to process the current data block
                            //

                            } else {

    keepLookingAtNewEntries:

                                //
                                //  Allocate a new heap usage entry
                                //

                                pNewEntry = NULL;

                                Status = RtlpAllocateHeapUsageEntry( Buffer, &pNewEntry );

                                if (!NT_SUCCESS( Status )) {

                                    break;
                                }

                                //
                                //  And fill in the new entry
                                //

                                pNewEntry->Address = DataAddress;
                                pNewEntry->Size = DataSize;

                                //
                                //  If there is an extra stuff struct then fill it in
                                //  with the stack backtrace, and appropriate tag index
                                //

                                if (CurrentBlock->Flags & HEAP_ENTRY_EXTRA_PRESENT) {

                                    ExtraStuff = RtlpGetExtraStuffPointer( CurrentBlock );

    #if i386

                                    pNewEntry->AllocatorBackTraceIndex = ExtraStuff->AllocatorBackTraceIndex;

    #endif // i386

                                    if (!IS_HEAP_TAGGING_ENABLED()) {

                                        pNewEntry->TagIndex = 0;

                                    } else {

                                        pNewEntry->TagIndex = ExtraStuff->TagIndex;
                                    }

                                } else {

                                    //
                                    //  Otherwise there is no extra stuff so there is
                                    //  no backtrace and the tag is from the small index
                                    //

    #if i386

                                    pNewEntry->AllocatorBackTraceIndex = 0;

    #endif // i386

                                    if (!IS_HEAP_TAGGING_ENABLED()) {

                                        pNewEntry->TagIndex = 0;

                                    } else {

                                        pNewEntry->TagIndex = CurrentBlock->SmallTagIndex;
                                    }
                                }

                                //
                                //  Allocate another new heap usage entry as part of the added
                                //  entry list
                                //

                                Status = RtlpAllocateHeapUsageEntry( Buffer, ppAddedEntries );

                                if (!NT_SUCCESS( Status )) {

                                    break;
                                }

                                //
                                //  Copy over the contents of the new entry to the added entry
                                //

                                **ppAddedEntries = *pNewEntry;

                                //
                                //  Advance the added entry pointer to the next slot
                                //

                                ppAddedEntries = &((*ppAddedEntries)->Next);

                                *ppAddedEntries = NULL;

                                pNewEntry->Next = NULL;

                                //
                                //  Add the new entry to the entries list
                                //

                                *ppEntries = pNewEntry;
                                ppEntries = &pNewEntry->Next;
                            }
                        }

                        //
                        //  Now advance to the next block in the segment
                        //
                        //  If the next block doesn't exist then zoom through the
                        //  uncommitted ranges in the segment until we find a
                        //  match and can recompute the next real block
                        //

                        if (CurrentBlock->Flags & HEAP_ENTRY_LAST_ENTRY) {

                            CurrentBlock += CurrentBlock->Size;

                            if (CurrentBlock < Segment->LastValidEntry) {

                                UnCommittedRange = Segment->UnCommittedRanges;

                                while ((UnCommittedRange != NULL) &&
                                       (UnCommittedRange->Address != (ULONG_PTR)CurrentBlock)) {

                                    UnCommittedRange = UnCommittedRange->Next;
                                }

                                if (UnCommittedRange == NULL) {

                                    CurrentBlock = Segment->LastValidEntry;

                                } else {

                                    CurrentBlock = (PHEAP_ENTRY)(UnCommittedRange->Address +
                                                                 UnCommittedRange->Size);
                                }
                            }

                        } else {

                            //
                            //  Otherwise the next block exists and so point
                            //  directly at it
                            //

                            CurrentBlock += CurrentBlock->Size;
                        }
                    }
                }
            }

            //
            //  At this point we've scanned through every segment in the heap
            //
            //  The first time through we now have two lists one of entries and
            //  another of added entries.  In each case Usage->Entries, and
            //  Usage->AddedEntries points to the start of the list and ppEntries,
            //  and ppAddedEntries points to the tail of the list.  The first
            //  time through we has seem to have a one-to-one correspondence
            //  between Entries and AddedEntries, but the AddedEntries records
            //  do not contain anything useful
            //

            if (NT_SUCCESS( Status )) {

                //
                //  Now we'll examine each big allocation, and for each big allocation
                //  we'll make a heap usage entry
                //

                Head = &Heap->VirtualAllocdBlocks;
                Next = Head->Flink;
                VirtualAllocBlockSeen = FALSE;

                while (Head != Next) {

                    VirtualAllocBlock = CONTAINING_RECORD( Next, HEAP_VIRTUAL_ALLOC_ENTRY, Entry );

                    //
                    //  Allocate a new heap usage entry
                    //

                    pNewEntry = NULL;

                    Status = RtlpAllocateHeapUsageEntry( Buffer, &pNewEntry );

                    if (!NT_SUCCESS( Status )) {

                        break;
                    }

                    VirtualAllocBlockSeen = TRUE;

                    //
                    //  Fill in the new heap usage entry
                    //

                    pNewEntry->Address = (VirtualAllocBlock + 1);
                    pNewEntry->Size = VirtualAllocBlock->CommitSize - VirtualAllocBlock->BusyBlock.Size;

    #if i386

                    pNewEntry->AllocatorBackTraceIndex = VirtualAllocBlock->ExtraStuff.AllocatorBackTraceIndex;

    #endif // i386

                    if (!IS_HEAP_TAGGING_ENABLED()) {

                        pNewEntry->TagIndex = 0;

                    } else {

                        pNewEntry->TagIndex = VirtualAllocBlock->ExtraStuff.TagIndex;
                    }

                    //
                    //  Search the heap usage entries list until we find the address
                    //  that right after the new entry address and then insert
                    //  this new entry.  This will keep the entries list sorted in
                    //  assending addresses
                    //
                    //
                    //  The first time through this function ppEntries will point
                    //  to the tail and so *pp should actually start off as null,
                    //  which means that the big allocation simply get tacked on
                    //  the end of the entries list.  We do not augment the
                    //  AddedEntries list for these big allocations.
                    //

                    pp = ppEntries;

                    while (*pp) {

                        if ((*pp)->Address >= pNewEntry->Address) {

                            break;
                        }

                        pp = &(*pp)->Next;
                    }

                    pNewEntry->Next = *pp;
                    *pp = pNewEntry;

                    //
                    //  Get the next big allocation block
                    //

                    Next = Next->Flink;
                }

                //
                //  At this point we've scanned through the heap segments and the
                //  big allocations.
                //
                //  The first time through this procedure we have built two lists
                //  the Entries and the AddedEntries
                //

                if (NT_SUCCESS( Status )) {

                    pOldEntries = Buffer->LargeEntriesSentinal;
                    Buffer->LargeEntriesSentinal = *ppEntries;

                    //
                    //  Now we'll process the previous large entries sentinal list
                    //
                    //  This path is not taken the first time through this procedure
                    //

                    while (pOldEntries != NULL) {

                        //
                        //  If we have new entries and the entry is equal to the
                        //  entry in the previous large sentinal list then
                        //  we move one down on the new list and remove the previous
                        //  sentinal entry
                        //

                        if ((*ppEntries != NULL) &&
                            (pOldEntries->Address == (*ppEntries)->Address) &&
                            (pOldEntries->Size == (*ppEntries)->Size)) {

                            ppEntries = &(*ppEntries)->Next;

                            pOldEntries = RtlpFreeHeapUsageEntry( Buffer, pOldEntries );

                        //
                        //  If we do now have any new entries or the previous
                        //  sentinal entry is comes before this new entry then
                        //  we'll add the sentinal entry to the remove list
                        //

                        } else if ((*ppEntries == NULL) ||
                                   (pOldEntries->Address < (*ppEntries)->Address)) {

                            *ppRemovedEntries = pOldEntries;

                            pOldEntries = pOldEntries->Next;

                            ppRemovedEntries = &(*ppRemovedEntries)->Next;

                            *ppRemovedEntries = NULL;

                        //
                        //  Otherwise the old sentinal entry is put on the added
                        //  entries list
                        //

                        } else {

                            *ppAddedEntries = pOldEntries;

                            pOldEntries = pOldEntries->Next;

                            **ppAddedEntries = **ppEntries;

                            ppAddedEntries = &(*ppAddedEntries)->Next;

                            *ppAddedEntries = NULL;
                        }
                    }

                    //
                    //  This path is not taken the first time through this procedure
                    //

                    while (pNewEntry = *ppEntries) {

                        Status = RtlpAllocateHeapUsageEntry( Buffer, ppAddedEntries );

                        if (!NT_SUCCESS( Status )) {

                            break;
                        }

                        **ppAddedEntries = *pNewEntry;

                        ppAddedEntries = &(*ppAddedEntries)->Next;

                        *ppAddedEntries = NULL;

                        ppEntries = &pNewEntry->Next;
                    }

                    //
                    //  Tell the user that something has changed between the
                    //  previous call and this one
                    //

                    if ((Usage->AddedEntries != NULL) || (Usage->RemovedEntries != NULL)) {

                        Status = STATUS_MORE_ENTRIES;
                    }
                }
            }
        }

    } finally {

        //
        //  Unlock the heap
        //

        if (LockAcquired) {

            RtlReleaseLockRoutine( Heap->LockVariable );
        }
    }

    //
    //  And return to our caller
    //

    return Status;
}


//
//  Declared in nturtl.h
//

NTSTATUS
RtlWalkHeap (
    IN PVOID HeapHandle,
    IN OUT PRTL_HEAP_WALK_ENTRY Entry
    )

/*++

Routine Description:

    This routine is used to enumerate all the entries within a heap.  For each
    call it returns a new information in entry.

Arguments:

    HeapHandle - Supplies a pointer to the heap being queried

    Entry - Supplies storage for the entry information.  If the DataAddress field
        is null then the enumeration starts over from the beginning otherwise it
        resumes from where it left off

Return Value:

    NTSTATUS - An appropriate status value

--*/

{
    NTSTATUS Status;
    PHEAP Heap = (PHEAP)HeapHandle;
    PHEAP_SEGMENT Segment;
    UCHAR SegmentIndex;
    PHEAP_ENTRY CurrentBlock;
    PHEAP_ENTRY_EXTRA ExtraStuff;
    PHEAP_UNCOMMMTTED_RANGE UnCommittedRange, *pp;
    PLIST_ENTRY Next, Head;
    PHEAP_VIRTUAL_ALLOC_ENTRY VirtualAllocBlock;

    //
    //  Check if we should be using the guard page verion of heap
    //

    IF_DEBUG_PAGE_HEAP_THEN_RETURN( HeapHandle,
                                    RtlpDebugPageHeapWalk( HeapHandle, Entry ));

    //
    //  If this is the debug version of heap then validate the heap
    //  before we go on
    //

    if (DEBUG_HEAP( Heap->Flags )) {

        if (!RtlDebugWalkHeap( HeapHandle, Entry )) {

            return STATUS_INVALID_PARAMETER;
        }
    }

    Status = STATUS_SUCCESS;

    //
    //  If there is an active lookaside list then drain and remove it.
    //  By setting the lookaside field in the heap to null we guarantee
    //  that the call the free heap will not try and use the lookaside
    //  list logic.
    //
    //  We'll actually capture the lookaside pointer from the heap and
    //  only use the captured pointer.  This will take care of the
    //  condition where another walk or lock heap can cause us to check
    //  for a non null pointer and then have it become null when we read
    //  it again.  If it is non null to start with then even if the
    //  user walks or locks the heap via another thread the pointer to
    //  still valid here so we can still try and do a lookaside list pop.
    //

    {
        PHEAP_LOOKASIDE Lookaside = (PHEAP_LOOKASIDE)Heap->Lookaside;

        if (Lookaside != NULL) {

            ULONG i;
            PVOID Block;

            Heap->Lookaside = NULL;

            for (i = 0; i < HEAP_MAXIMUM_FREELISTS; i += 1) {

                while ((Block = RtlpAllocateFromHeapLookaside(&(Lookaside[i]))) != NULL) {

                    RtlFreeHeap( HeapHandle, 0, Block );
                }
            }
        }
    }

    //
    //  Check if this is the first time we've been called to walk the heap
    //

    if (Entry->DataAddress == NULL) {

        //
        //  Start with the first segement in the heap
        //

        SegmentIndex = 0;

nextSegment:

        CurrentBlock = NULL;

        //
        //  Now find the next in use segment for the heap
        //

        Segment = NULL;

        while ((SegmentIndex < HEAP_MAXIMUM_SEGMENTS) &&
               ((Segment = Heap->Segments[ SegmentIndex ]) == NULL)) {

            SegmentIndex += 1;
        }

        //
        //  If there are no more valid segments then we'll try the big
        //  allocation
        //

        if (Segment == NULL) {

            Head = &Heap->VirtualAllocdBlocks;
            Next = Head->Flink;

            if (Next == Head) {

                Status = STATUS_NO_MORE_ENTRIES;

            } else {

                VirtualAllocBlock = CONTAINING_RECORD( Next, HEAP_VIRTUAL_ALLOC_ENTRY, Entry );

                CurrentBlock = &VirtualAllocBlock->BusyBlock;
            }

        //
        //  Otherwise we'll grab information about the segment.  Note that
        //  the current block is still null so when we fall out of this
        //  block we'll return directly to our caller with this segment
        //  information
        //

        } else {

            Entry->DataAddress = Segment;

            Entry->DataSize = 0;

            Entry->OverheadBytes = sizeof( *Segment );

            Entry->Flags = RTL_HEAP_SEGMENT;

            Entry->SegmentIndex = SegmentIndex;

            Entry->Segment.CommittedSize = (Segment->NumberOfPages -
                                            Segment->NumberOfUnCommittedPages) * PAGE_SIZE;

            Entry->Segment.UnCommittedSize = Segment->NumberOfUnCommittedPages * PAGE_SIZE;

            Entry->Segment.FirstEntry = (Segment->FirstEntry->Flags & HEAP_ENTRY_BUSY) ?
                ((PHEAP_ENTRY)Segment->FirstEntry + 1) :
                (PHEAP_ENTRY)((PHEAP_FREE_ENTRY)Segment->FirstEntry + 1);

            Entry->Segment.LastEntry = Segment->LastValidEntry;
        }

    //
    //  This is not the first time through.  Check if last time we gave back
    //  an heap segement or an uncommitted range
    //

    } else if (Entry->Flags & (RTL_HEAP_SEGMENT | RTL_HEAP_UNCOMMITTED_RANGE)) {

        //
        //  Check that the segment index is still valid
        //

        if ((SegmentIndex = Entry->SegmentIndex) >= HEAP_MAXIMUM_SEGMENTS) {

            Status = STATUS_INVALID_ADDRESS;

            CurrentBlock = NULL;

        } else {

            //
            //  Check that the segment is still in use
            //

            Segment = Heap->Segments[ SegmentIndex ];

            if (Segment == NULL) {

                Status = STATUS_INVALID_ADDRESS;

                CurrentBlock = NULL;

            //
            //  The segment is still in use if what we returned last time
            //  as the segment header then this time we'll return the
            //  segments first entry
            //

            } else if (Entry->Flags & RTL_HEAP_SEGMENT) {

                CurrentBlock = (PHEAP_ENTRY)Segment->FirstEntry;

            //
            //  Otherwise what we returned last time as an uncommitted
            //  range so now we need to get the next block
            //

            } else {

                CurrentBlock = (PHEAP_ENTRY)((PCHAR)Entry->DataAddress + Entry->DataSize);

                //
                //  Check if we are beyond this segment and need to get the
                //  next one
                //

                if (CurrentBlock >= Segment->LastValidEntry) {

                    SegmentIndex += 1;

                    goto nextSegment;
                }
            }
        }

    //
    //  Otherwise this is not the first time through and last time we gave back a
    //  valid heap entry
    //

    } else {

        //
        //  Check if the last entry we gave back was in use
        //

        if (Entry->Flags & HEAP_ENTRY_BUSY) {

            //
            //  Get the last entry we returned
            //

            CurrentBlock = ((PHEAP_ENTRY)Entry->DataAddress - 1);

            //
            //  If the last entry was for a big allocation then
            //  get the next big block if there is one otherwise
            //  say there are no more entries
            //

            if (CurrentBlock->Flags & HEAP_ENTRY_VIRTUAL_ALLOC) {

                Head = &Heap->VirtualAllocdBlocks;

                VirtualAllocBlock = CONTAINING_RECORD( CurrentBlock, HEAP_VIRTUAL_ALLOC_ENTRY, BusyBlock );

                Next = VirtualAllocBlock->Entry.Flink;

                if (Next == Head) {

                    Status = STATUS_NO_MORE_ENTRIES;

                } else {

                    VirtualAllocBlock = CONTAINING_RECORD( Next, HEAP_VIRTUAL_ALLOC_ENTRY, Entry );

                    CurrentBlock = &VirtualAllocBlock->BusyBlock;
                }

            //
            //  Our previous result is a busy normal block
            //

            } else {

                //
                //  Get the segment and make sure it it still valid and in use
                //
                //  **** this should also check that segment index is not
                //  **** greater than HEAP MAXIMUM SEGMENTS
                //

                Segment = Heap->Segments[ SegmentIndex = CurrentBlock->SegmentIndex ];

                if (Segment == NULL) {

                    Status = STATUS_INVALID_ADDRESS;

                    CurrentBlock = NULL;

                //
                //  The segment is still in use, check if what we returned
                //  previously was a last entry
                //

                } else if (CurrentBlock->Flags & HEAP_ENTRY_LAST_ENTRY) {

findUncommittedRange:

                    //
                    //  We are at a last entry so now if the segment is done
                    //  then go get another segment
                    //

                    CurrentBlock += CurrentBlock->Size;

                    if (CurrentBlock >= Segment->LastValidEntry) {

                        SegmentIndex += 1;

                        goto nextSegment;
                    }

                    //
                    //  Otherwise we will find the uncommitted range entry that
                    //  immediately follows this last entry
                    //

                    pp = &Segment->UnCommittedRanges;

                    while ((UnCommittedRange = *pp) && UnCommittedRange->Address != (ULONG_PTR)CurrentBlock ) {

                        pp = &UnCommittedRange->Next;
                    }

                    if (UnCommittedRange == NULL) {

                        Status = STATUS_INVALID_PARAMETER;

                    } else {

                        //
                        //  Now fill in the entry to denote that uncommitted
                        //  range information
                        //

                        Entry->DataAddress = (PVOID)UnCommittedRange->Address;

                        Entry->DataSize = UnCommittedRange->Size;

                        Entry->OverheadBytes = 0;

                        Entry->SegmentIndex = SegmentIndex;

                        Entry->Flags = RTL_HEAP_UNCOMMITTED_RANGE;
                    }

                    //
                    //  Null out the current block because we've just filled in
                    //  the entry
                    //

                    CurrentBlock = NULL;

                } else {

                    //
                    //  Otherwise the entry has a following entry so now
                    //  advance to the next entry
                    //

                    CurrentBlock += CurrentBlock->Size;
                }
            }

        //
        //  Otherwise the previous entry we returned is not in use
        //

        } else {

            //
            //  Get the last entry we returned
            //

            CurrentBlock = (PHEAP_ENTRY)((PHEAP_FREE_ENTRY)Entry->DataAddress - 1);

            //
            //  Get the segment and make sure it it still valid and in use
            //
            //  **** this should also check that segment index is not
            //  **** greater than HEAP MAXIMUM SEGMENTS
            //

            Segment = Heap->Segments[ SegmentIndex = CurrentBlock->SegmentIndex ];

            if (Segment == NULL) {

                Status = STATUS_INVALID_ADDRESS;

                CurrentBlock = NULL;

            //
            //  If the block is the last entry then go find the next uncommitted
            //  range or segment
            //

            } else if (CurrentBlock->Flags & HEAP_ENTRY_LAST_ENTRY) {

                goto findUncommittedRange;

            //
            //  Otherwise we'll just move on to the next entry
            //

            } else {

                CurrentBlock += CurrentBlock->Size;
            }
        }
    }

    //
    //  At this point if current block is not null then we've found another
    //  entry to return.  We could also have found a segment or uncommitted
    //  range but those are handled separately above and keep current block
    //  null
    //

    if (CurrentBlock != NULL) {

        //
        //  Check if the block is in use
        //

        if (CurrentBlock->Flags & HEAP_ENTRY_BUSY) {

            //
            //  Fill in the entry field for this block
            //

            Entry->DataAddress = (CurrentBlock+1);

            if (CurrentBlock->Flags & HEAP_ENTRY_VIRTUAL_ALLOC) {

                Entry->DataSize = RtlpGetSizeOfBigBlock( CurrentBlock );

                Entry->OverheadBytes = (UCHAR)( sizeof( *VirtualAllocBlock ) + CurrentBlock->Size);

                Entry->SegmentIndex = HEAP_MAXIMUM_SEGMENTS;

                Entry->Flags = RTL_HEAP_BUSY |  HEAP_ENTRY_VIRTUAL_ALLOC;

            } else {

                Entry->DataSize = (CurrentBlock->Size << HEAP_GRANULARITY_SHIFT) -
                                  CurrentBlock->UnusedBytes;

                Entry->OverheadBytes = CurrentBlock->UnusedBytes;

                Entry->SegmentIndex = CurrentBlock->SegmentIndex;

                Entry->Flags = RTL_HEAP_BUSY;
            }

            if (CurrentBlock->Flags & HEAP_ENTRY_EXTRA_PRESENT) {

                ExtraStuff = RtlpGetExtraStuffPointer( CurrentBlock );

                Entry->Block.Settable = ExtraStuff->Settable;
#if i386

                Entry->Block.AllocatorBackTraceIndex = ExtraStuff->AllocatorBackTraceIndex;

#endif // i386

                if (!IS_HEAP_TAGGING_ENABLED()) {

                    Entry->Block.TagIndex = 0;

                } else {

                    Entry->Block.TagIndex = ExtraStuff->TagIndex;
                }

                Entry->Flags |= RTL_HEAP_SETTABLE_VALUE;

            } else {

                if (!IS_HEAP_TAGGING_ENABLED()) {

                    Entry->Block.TagIndex = 0;

                } else {

                    Entry->Block.TagIndex = CurrentBlock->SmallTagIndex;
                }
            }

            Entry->Flags |= CurrentBlock->Flags & HEAP_ENTRY_SETTABLE_FLAGS;

        //
        //  Otherwise the block is not in use
        //

        } else {

            Entry->DataAddress = ((PHEAP_FREE_ENTRY)CurrentBlock+1);

            Entry->DataSize = (CurrentBlock->Size << HEAP_GRANULARITY_SHIFT) -
                              sizeof( HEAP_FREE_ENTRY );

            Entry->OverheadBytes = sizeof( HEAP_FREE_ENTRY );

            Entry->SegmentIndex = CurrentBlock->SegmentIndex;

            Entry->Flags = 0;
        }
    }

    //
    //  And return to our caller
    //

    return Status;
}


//
//  Declared in heappriv.h
//

BOOLEAN
RtlpCheckHeapSignature (
    IN PHEAP Heap,
    IN PCHAR Caller
    )

/*++

Routine Description:

    This routine verifies that it is being called with a properly identified
    heap.

Arguments:

    Heap - Supplies a pointer to the heap being checked

    Caller - Supplies a string that can be used to identify the caller

Return Value:

    BOOLEAN - TRUE if the heap signature is present, and FALSE otherwise

--*/

{
    //
    //  If the heap signature matches then that is the only
    //  checking we do
    //

    if (Heap->Signature == HEAP_SIGNATURE) {

        return TRUE;

    } else {

        //
        //  We have a bad heap signature.  Print out some information, break
        //  into the debugger, and then return false
        //

        HeapDebugPrint(( "Invalid heap signature for heap at %x", Heap ));

        if (Caller != NULL) {

            DbgPrint( ", passed to %s", Caller );
        }

        DbgPrint( "\n" );

        HeapDebugBreak( &Heap->Signature );

        return FALSE;
    }
}


//
//  Declared in heappriv.h
//

PHEAP_FREE_ENTRY
RtlpCoalesceHeap (
    IN PHEAP Heap
    )

/*++

Routine Description:

    This routine scans through heap and coalesces its free blocks

Arguments:

    Heap - Supplies a pointer to the heap being modified

Return Value:

    PHEAP_FREE_ENTRY - returns a pointer to the largest free block
        in the heap

--*/

{
    SIZE_T OldFreeSize;
    SIZE_T FreeSize;
    ULONG n;
    PHEAP_FREE_ENTRY FreeBlock, LargestFreeBlock;
    PLIST_ENTRY FreeListHead, Next;

    RTL_PAGED_CODE();

    LargestFreeBlock = NULL;

    //
    //  For every free list in the heap, going from smallest to
    //  largest and skipping the zero index one we will
    //  scan the free list coalesceing the free blocks
    //

    FreeListHead = &Heap->FreeLists[ 1 ];

    n = HEAP_MAXIMUM_FREELISTS;

    while (n--) {

        //
        //  Scan the individual free list
        //

        Next = FreeListHead->Blink;

        while (FreeListHead != Next) {

            //
            //  Get a pointer to the current free list entry, and remember its
            //  next and size
            //

            FreeBlock = CONTAINING_RECORD( Next, HEAP_FREE_ENTRY, FreeList );

            Next = Next->Flink;
            OldFreeSize = FreeSize = FreeBlock->Size;

            //
            //  Coalesce the block
            //

            FreeBlock = RtlpCoalesceFreeBlocks( Heap,
                                                FreeBlock,
                                                &FreeSize,
                                                TRUE );

            //
            //  If the new free size is not equal to the old free size
            //  then we actually did some changes otherwise the coalesce
            //  calll was essentialy a noop
            //

            if (FreeSize != OldFreeSize) {

                //
                //  Check if we should decommit this block because it is too
                //  large and it is either at the beginning or end of a
                //  committed run.  Otherwise just insert the new sized
                //  block into its corresponding free list.  We'll hit this
                //  block again when we visit larger free lists.
                //

                if (FreeBlock->Size >= (PAGE_SIZE >> HEAP_GRANULARITY_SHIFT)

                        &&

                    (FreeBlock->PreviousSize == 0 ||
                     (FreeBlock->Flags & HEAP_ENTRY_LAST_ENTRY))) {

                    RtlpDeCommitFreeBlock( Heap, FreeBlock, FreeSize );

                } else {

                    RtlpInsertFreeBlock( Heap, FreeBlock, FreeSize );
                }

                Next = FreeListHead->Blink;

            } else {

                //
                //  Remember the largest free block we've found so far
                //

                if ((LargestFreeBlock == NULL) ||
                    (LargestFreeBlock->Size < FreeBlock->Size)) {

                    LargestFreeBlock = FreeBlock;
                }
            }
        }

        //
        //  Go to the next free list.  When we hit the largest dedicated
        //  size free list we'll fall back to the [0] index list
        //

        if (n == 1) {

            FreeListHead = &Heap->FreeLists[ 0 ];

        } else {

            FreeListHead++;
        }
    }

    //
    //  And return to our caller
    //

    return LargestFreeBlock;
}


//
//  Declared in heappriv.h
//

VOID
RtlpAddHeapToProcessList (
    IN PHEAP Heap
    )

/*++

Routine Description:

    This routine adds the specified heap to the heap list for the
    current process

Arguments:

    Heap - Supplies a pointer to the heap being added

Return Value:

    None.

--*/

{
    PPEB Peb = NtCurrentPeb();
    PHEAP *NewList;

    //
    //  Lock the processes heap list
    //

    RtlAcquireLockRoutine( &RtlpProcessHeapsListLock.Lock );

    try {

        //
        //  If the processes heap list is already full then we'll
        //  double the size of the heap list for the process
        //

        if (Peb->NumberOfHeaps == Peb->MaximumNumberOfHeaps) {

            //
            //  Double the size
            //

            Peb->MaximumNumberOfHeaps *= 2;

            //
            //  Allocate space for the new list
            //

            NewList = RtlAllocateHeap( RtlProcessHeap(),
                                       0,
                                       Peb->MaximumNumberOfHeaps * sizeof( *NewList ));

            if (NewList == NULL) {

                leave;
            }

            //
            //  Copy over the old buffer to the new buffer
            //

            RtlMoveMemory( NewList,
                           Peb->ProcessHeaps,
                           Peb->NumberOfHeaps * sizeof( *NewList ));

            //
            //  Check if we should free the previous heap list buffer
            //

            if (Peb->ProcessHeaps != RtlpProcessHeapsListBuffer) {

                RtlFreeHeap( RtlProcessHeap(), 0, Peb->ProcessHeaps );
            }

            //
            //  Set the new list
            //

            Peb->ProcessHeaps = NewList;
        }

        //
        //  Add the input heap to the next free heap list slot, and note that
        //  the processes heap list index is really one beyond the actualy
        //  index used to get the processes heap
        //

        Peb->ProcessHeaps[ Peb->NumberOfHeaps++ ] = Heap;
        Heap->ProcessHeapsListIndex = (USHORT)Peb->NumberOfHeaps;

    } finally {

        //
        //  Unlock the processes heap list
        //

        RtlReleaseLockRoutine( &RtlpProcessHeapsListLock.Lock );
    }

    //
    //  And return to our caller
    //

    return;
}


//
//  Delcared in heappriv.h
//

VOID
RtlpRemoveHeapFromProcessList (
    IN PHEAP Heap
    )

/*++

Routine Description:

    This routine removes the specified heap to the heap list for the
    current process

Arguments:

    Heap - Supplies a pointer to the heap being removed

Return Value:

    None.

--*/

{
    PPEB Peb = NtCurrentPeb();
    PHEAP *p, *p1;
    ULONG n;

    //
    //  Lock the current processes heap list lock
    //

    RtlAcquireLockRoutine( &RtlpProcessHeapsListLock.Lock );

    try {

        //
        //  We only want to the the work if the current process actually has some
        //  heaps, the index stored in the heap is within the range for active
        //  heaps.  Note that the heaps stored index is bias by one.
        //

        if ((Peb->NumberOfHeaps != 0) &&
            (Heap->ProcessHeapsListIndex != 0) &&
            (Heap->ProcessHeapsListIndex <= Peb->NumberOfHeaps)) {

            //
            //  Establish a pointer into the array of process heaps at the
            //  current heap location and one beyond
            //

            p = (PHEAP *)&Peb->ProcessHeaps[ Heap->ProcessHeapsListIndex - 1 ];

            p1 = p + 1;

            //
            //  Calculate the number of heaps that exist beyond the current
            //  heap in the array including the current heap location
            //

            n = Peb->NumberOfHeaps - (Heap->ProcessHeapsListIndex - 1);

            //
            //  For every heap beyond the current one that we are removing
            //  we'll move that heap down to the previous index.
            //

            while (--n) {

                //
                //  Copy the heap process array entry of the next entry to
                //  the current entry, and move p1 to the next next entry
                //

                *p = *p1++;

                //
                //  This is simply a debugging call
                //

                RtlpUpdateHeapListIndex( (*p)->ProcessHeapsListIndex,
                                         (USHORT)((*p)->ProcessHeapsListIndex - 1));

                //
                //  Assign the moved heap its new heap index
                //

                (*p)->ProcessHeapsListIndex -= 1;

                //
                //  Move on to the next heap entry
                //

                p += 1;
            }

            //
            //  Zero out the last process heap pointer, update the count, and
            //  make the heap we just removed realize it has been removed by
            //  zeroing out its process heap list index
            //

            Peb->ProcessHeaps[ --Peb->NumberOfHeaps ] = NULL;
            Heap->ProcessHeapsListIndex = 0;
        }

    } finally {

        //
        //  Unlock the current processes heap list lock
        //

        RtlReleaseLockRoutine( &RtlpProcessHeapsListLock.Lock );
    }

    return;
}



//
//  Local support routine
//

PHEAP_TAG_ENTRY
RtlpAllocateTags (
    PHEAP Heap,
    ULONG NumberOfTags
    )

/*++

Routine Description:

    This routine is used to allocate space for additional tags within
    a heap

Arguments:

    Heap - Supplies a pointer to the heap being modified.  If not specified
        then the processes global tag heap is used

    NumberOfTags - Supplies the number of tags that we want stored in the
        heap.  This is the number to grow the tag list by.

Return Value:

    PHEAP_TAG_ENTRY - Returns a pointer to the next available tag entry in the
        heap

--*/

{
    NTSTATUS Status;
    ULONG TagIndex;
    SIZE_T ReserveSize;
    SIZE_T CommitSize;
    PHEAP_TAG_ENTRY TagEntry;
    USHORT CreatorBackTraceIndex;
    USHORT MaximumTagIndex;
    USHORT TagIndexFlag;

    //
    //  Check if the process has a global tag heap.  If not then there is
    //  nothing for us to do
    //

    if (RtlpGlobalTagHeap == NULL) {

        return NULL;
    }

    //
    //  If the user didn't give us a heap then use the processes global
    //  tag heap
    //

    if (Heap == NULL) {

        RtlpGlobalTagHeap->Signature = HEAP_SIGNATURE;

        RtlpGlobalTagHeap->Flags = HEAP_NO_SERIALIZE;

        TagIndexFlag = HEAP_GLOBAL_TAG;

        Heap = RtlpGlobalTagHeap;

    } else {

        TagIndexFlag = 0;
    }

    //
    //  Grab the stack backtrace if possible and if we should
    //

    CreatorBackTraceIndex = 0;

#if i386

    if (Heap->Flags & HEAP_CAPTURE_STACK_BACKTRACES) {

        CreatorBackTraceIndex = (USHORT)RtlLogStackBackTrace();
    }

#endif // i386

    //
    //  If the heap does not already have tag entries then we'll
    //  reserve space for them
    //

    if (Heap->TagEntries == NULL) {

        MaximumTagIndex = HEAP_MAXIMUM_TAG & ~HEAP_GLOBAL_TAG;

        ReserveSize = MaximumTagIndex * sizeof( HEAP_TAG_ENTRY );

        Status = NtAllocateVirtualMemory( NtCurrentProcess(),
                                          &Heap->TagEntries,
                                          0,
                                          &ReserveSize,
                                          MEM_RESERVE,
                                          PAGE_READWRITE );

        if (!NT_SUCCESS( Status )) {

            return NULL;
        }

        Heap->MaximumTagIndex = MaximumTagIndex;

        Heap->NextAvailableTagIndex = 0;

        //
        // Add one for zero tag, as that is always reserved for heap name
        //

        NumberOfTags += 1;
    }

    //
    //  At this point we have a space reserved for tag entries.  If the number
    //  of tags that we need to grow is too large then tell the user we can't
    //  do it.
    //

    if (NumberOfTags > (ULONG)(Heap->MaximumTagIndex - Heap->NextAvailableTagIndex)) {

        return NULL;
    }

    //
    //  Get a pointer to the next available tag entry, and for
    //  every tag entry that we want to grow by we'll commit
    //  the page containing the tag entry.  We only need to do
    //  this for every page just once.  We'll determine this
    //  by seeing when the tag entry crosses a page boundary
    //

    TagEntry = Heap->TagEntries + Heap->NextAvailableTagIndex;

    for (TagIndex = Heap->NextAvailableTagIndex;
         TagIndex < Heap->NextAvailableTagIndex + NumberOfTags;
         TagIndex++ ) {

        if (((((ULONG_PTR)TagEntry + sizeof(*TagEntry)) & (PAGE_SIZE-1)) <=
            sizeof(*TagEntry))) {

            CommitSize = PAGE_SIZE;

            Status = NtAllocateVirtualMemory( NtCurrentProcess(),
                                              &TagEntry,
                                              0,
                                              &CommitSize,
                                              MEM_COMMIT,
                                              PAGE_READWRITE );

            if (!NT_SUCCESS( Status )) {

                return NULL;
            }
        }

        //
        //  Bias the tag index if this is the global tag heap
        //

        TagEntry->TagIndex = (USHORT)TagIndex | TagIndexFlag;

        //
        //  Set the stack back trace
        //

        TagEntry->CreatorBackTraceIndex = CreatorBackTraceIndex;

        //
        //  Move on to the next tag entry
        //

        TagEntry += 1;
    }

    //
    //  At this point we've build the new tag list so now pop off the next
    //  available tag entry
    //

    TagEntry = Heap->TagEntries + Heap->NextAvailableTagIndex;

    Heap->NextAvailableTagIndex += (USHORT)NumberOfTags;

    //
    //  And return to our caller
    //

    return TagEntry;
}


//
//  Declared in heappriv.h
//

PWSTR
RtlpGetTagName (
    PHEAP Heap,
    USHORT TagIndex
    )

/*++

Routine Description:

    This routine returns the name of the tag denoted by the heap, tagindex
    tuple.

    This routine is only called by heapdbg when doing a debug print to
    generate a tag name for printing

Arguments:

    Heap - Supplies the tag being queried

    TagIndex - Supplies the index for the tag being queried

Return Value:

    PWSTR - returns the name of the indicated tag

--*/

{
    //
    //  If the processes global tag heap has not been initialized then
    //  not tag has a name
    //

    if (RtlpGlobalTagHeap == NULL) {

        return NULL;
    }

    //
    //  We only deal with non zero tag indices
    //

    if (TagIndex != 0) {

        //
        //  If the tag index is for a pseudo tag then we clear the
        //  the psuedo bit and generate a pseudo tag name
        //

        if (TagIndex & HEAP_PSEUDO_TAG_FLAG) {

            TagIndex &= ~HEAP_PSEUDO_TAG_FLAG;

            //
            //  Check that the tag index is valid and that the heap
            //  has some psuedo tag entries
            //

            if ((TagIndex < HEAP_NUMBER_OF_PSEUDO_TAG) &&
                (Heap->PseudoTagEntries != NULL)) {

                //
                //  A pseudo tag index of zero denote objects
                //

                if (TagIndex == 0) {

                    swprintf( RtlpPseudoTagNameBuffer, L"Objects>%4u",
                              HEAP_MAXIMUM_FREELISTS << HEAP_GRANULARITY_SHIFT );

                //
                //  A psuedo tag index less than the free list maximum
                //  denotes the dedicated free list
                //

                } else if (TagIndex < HEAP_MAXIMUM_FREELISTS) {

                    swprintf( RtlpPseudoTagNameBuffer, L"Objects=%4u", TagIndex << HEAP_GRANULARITY_SHIFT );

                //
                //  Otherwise the pseudo tag is for the big allocations
                //

                } else {

                    swprintf( RtlpPseudoTagNameBuffer, L"VirtualAlloc" );
                }

                return RtlpPseudoTagNameBuffer;
            }

        //
        //  Otherwise if the tag index is for a global tag then we pull
        //  the name off of the global heap.  Provided the index is valid
        //  and the heap does have some tag entries
        //

        } else if (TagIndex & HEAP_GLOBAL_TAG) {

            TagIndex &= ~HEAP_GLOBAL_TAG;

            if ((TagIndex < RtlpGlobalTagHeap->NextAvailableTagIndex) &&
                (RtlpGlobalTagHeap->TagEntries != NULL)) {

                return RtlpGlobalTagHeap->TagEntries[ TagIndex ].TagName;
            }

        //
        //  Otherwise we'll pull the name off of the input heap
        //  provided the index is valid and the heap does have some
        //  tag entries
        //

        } else if ((TagIndex < Heap->NextAvailableTagIndex) &&
                   (Heap->TagEntries != NULL)) {

            return Heap->TagEntries[ TagIndex ].TagName;
        }
    }

    return NULL;
}


//
//  Declared in heappriv.h
//

USHORT
RtlpUpdateTagEntry (
    PHEAP Heap,
    USHORT TagIndex,
    SIZE_T OldSize,              // Only valid for ReAllocation and Free actions
    SIZE_T NewSize,              // Only valid for ReAllocation and Allocation actions
    HEAP_TAG_ACTION Action
    )

/*++

Routine Description:

    This routine is used to modify a tag entry

Arguments:

    Heap - Supplies a pointer to the heap being modified

    TagIndex - Supplies the tag being modified

    OldSize - Supplies the old allocation index of the block associated with the tag

    NewSize - Supplies the new allocation index of the block associated with the tag

    Action - Supplies the type of action being performed on the heap tag

Return Value:

    USHORT - Returns a tag index for the newly updated tag

--*/

{
    PHEAP_TAG_ENTRY TagEntry;

    //
    //  If the processes tag heap does not exist then we'll return a zero index
    //  right away
    //

    if (RtlpGlobalTagHeap == NULL) {

        return 0;
    }

    //
    //  If the action is greater than or equal to free action then it is
    //  either FreeAction, VirtualFreeAction, ReAllocationAction, or
    //  VirtualReAllocationAction.  Which means we already should have a tag
    //  that is simply being modified
    //

    if (Action >= FreeAction) {

        //
        //  If the tag index is zero then there is nothing for us to do
        //

        if (TagIndex == 0) {

            return 0;
        }

        //
        //  If this is a pseudo tag then make sure the rest of the tag index
        //  after we remove the psuedo bit is valid and that the heap is
        //  actually maintaining pseudo tags
        //

        if (TagIndex & HEAP_PSEUDO_TAG_FLAG) {

            TagIndex &= ~HEAP_PSEUDO_TAG_FLAG;

            if ((TagIndex < HEAP_NUMBER_OF_PSEUDO_TAG) &&
                (Heap->PseudoTagEntries != NULL)) {

                TagEntry = (PHEAP_TAG_ENTRY)(Heap->PseudoTagEntries + TagIndex);

                TagIndex |= HEAP_PSEUDO_TAG_FLAG;

            } else {

                return 0;
            }

        //
        //  Otherwise if this is a global tag then make sure the tag index
        //  after we remove the global bit is valid and that the global tag
        //  heap has some tag entries
        //

        } else if (TagIndex & HEAP_GLOBAL_TAG) {

            TagIndex &= ~HEAP_GLOBAL_TAG;

            if ((TagIndex < RtlpGlobalTagHeap->NextAvailableTagIndex) &&
                (RtlpGlobalTagHeap->TagEntries != NULL)) {

                TagEntry = &RtlpGlobalTagHeap->TagEntries[ TagIndex ];

                TagIndex |= HEAP_GLOBAL_TAG;

            } else {

                return 0;
            }

        //
        //  Otherwise we have a regular tag index that we need to make sure
        //  is a valid value and that the heap has some tag entries
        //

        } else if ((TagIndex < Heap->NextAvailableTagIndex) &&
                   (Heap->TagEntries != NULL)) {

            TagEntry = &Heap->TagEntries[ TagIndex ];

        } else {

            return 0;
        }

        //
        //  At this point we have a tag entry and tag index.  Increment the
        //  number of frees we've done on the tag, and decrement the size by
        //  the number of bytes we've just freed
        //

        TagEntry->Frees += 1;

        TagEntry->Size -= OldSize;

        //
        //  Now if the action is either ReAllocationAction or
        //  VirtualReAllocationAction.  Then we get to add back in the
        //  new size and the allocation count
        //

        if (Action >= ReAllocationAction) {

            //
            //  If the this is a pseudo tag then we tag entry goes off the
            //  pseudo tag list
            //

            if (TagIndex & HEAP_PSEUDO_TAG_FLAG) {

                TagIndex = (USHORT)(NewSize < HEAP_MAXIMUM_FREELISTS ?
                                        NewSize :
                                        (Action == VirtualReAllocationAction ? HEAP_MAXIMUM_FREELISTS : 0));

                TagEntry = (PHEAP_TAG_ENTRY)(Heap->PseudoTagEntries + TagIndex);

                TagIndex |= HEAP_PSEUDO_TAG_FLAG;
            }

            TagEntry->Allocs += 1;

            TagEntry->Size += NewSize;
        }

    //
    //  The action is either AllocationAction or VirtualAllocationAction
    //

    } else {

        //
        //  Check if the supplied tag index is a regular tag and that it is
        //  valid for the tags in this heap
        //

        if ((TagIndex != 0) &&
            (TagIndex < Heap->NextAvailableTagIndex) &&
            (Heap->TagEntries != NULL)) {

            TagEntry = &Heap->TagEntries[ TagIndex ];

        //
        //  Otherwise if this is a global tag then make sure that it is a
        //  valid global index
        //

        } else if (TagIndex & HEAP_GLOBAL_TAG) {

            TagIndex &= ~HEAP_GLOBAL_TAG;

            Heap = RtlpGlobalTagHeap;

            if ((TagIndex < Heap->NextAvailableTagIndex) &&
                (Heap->TagEntries != NULL)) {

                TagEntry = &Heap->TagEntries[ TagIndex ];

                TagIndex |= HEAP_GLOBAL_TAG;

            } else {

                return 0;
            }

        //
        //  Otherwise if this is a pseudo tag then build a valid tag index
        //  based on the new size of the allocation
        //

        } else if (Heap->PseudoTagEntries != NULL) {

            TagIndex = (USHORT)(NewSize < HEAP_MAXIMUM_FREELISTS ?
                                    NewSize :
                                    (Action == VirtualAllocationAction ? HEAP_MAXIMUM_FREELISTS : 0));

            TagEntry = (PHEAP_TAG_ENTRY)(Heap->PseudoTagEntries + TagIndex);

            TagIndex |= HEAP_PSEUDO_TAG_FLAG;

        //
        //  Otherwise the user didn't call us with a valid tag
        //

        } else {

            return 0;
        }

        //
        //  At this point we have a valid tag entry and tag index, so
        //  update the tag entry state to reflect this new allocation
        //

        TagEntry->Allocs += 1;

        TagEntry->Size += NewSize;
    }

    //
    //  And return to our caller with the new tag index
    //

    return TagIndex;
}


//
//  Declared in heappriv.h
//

VOID
RtlpResetTags (
    PHEAP Heap
    )

/*++

Routine Description:

    This routine is used to reset all the tag entries in a heap

Arguments:

    Heap - Supplies a pointer to the heap being modified

Return Value:

    None.

--*/

{
    PHEAP_TAG_ENTRY TagEntry;
    PHEAP_PSEUDO_TAG_ENTRY PseudoTagEntry;
    ULONG i;

    //
    //  We only have work to do if the heap has any allocated tag entries
    //

    TagEntry = Heap->TagEntries;

    if (TagEntry != NULL) {

        //
        //  For every tag entry in the heap we will zero out its counters
        //

        for (i=0; i<Heap->NextAvailableTagIndex; i++) {

            TagEntry->Allocs = 0;
            TagEntry->Frees = 0;
            TagEntry->Size = 0;

            //
            //  Advance to the next tag entry
            //

            TagEntry += 1;
        }
    }

    //
    //  We will only reset the pseudo tags if they exist
    //

    PseudoTagEntry = Heap->PseudoTagEntries;

    if (PseudoTagEntry != NULL) {

        //
        //  For every pseudo tag entry in the heap we will zero out its
        //  counters
        //

        for (i=0; i<HEAP_NUMBER_OF_PSEUDO_TAG; i++) {

            PseudoTagEntry->Allocs = 0;
            PseudoTagEntry->Frees = 0;
            PseudoTagEntry->Size = 0;

            //
            //  Advance to the next pseudo tag entry
            //

            PseudoTagEntry += 1;
        }
    }

    //
    //  And return to our caller
    //

    return;
}


//
//  Declared in heappriv.h
//

VOID
RtlpDestroyTags (
    PHEAP Heap
    )

/*++

Routine Description:

    This routine is used to completely remove all the normal tag entries
    in use by a heap

Arguments:

    Heap - Supplies a pointer to the heap being modified

Return Value:

    None.

--*/

{
    NTSTATUS Status;
    SIZE_T RegionSize;

    //
    //  We will only do the action if the heap has some tag entries
    //

    if (Heap->TagEntries != NULL) {

        //
        //  Release all the memory used by the tag entries
        //

        RegionSize = 0;

        Status = NtFreeVirtualMemory( NtCurrentProcess(),
                                      &Heap->TagEntries,
                                      &RegionSize,
                                      MEM_RELEASE );

        if (NT_SUCCESS( Status )) {

            Heap->TagEntries = NULL;
        }
    }

    //
    //  And return to our caller
    //

    return;
}


//
//  Local support routine
//

NTSTATUS
RtlpAllocateHeapUsageEntry (
    PRTL_HEAP_USAGE_INTERNAL Buffer,
    PRTL_HEAP_USAGE_ENTRY *pp
    )

/*++

Routine Description:

    This routine is used to allocate an new heap usage entry
    from the internal heap usage buffer

Arguments:

    Buffer - Supplies a pointer to the internal heap usage
        buffer from which to allocate an entry

    pp - Receives a pointer to the newly allocated heap
        usage entry.  If pp is already pointing to an existing
        heap usage entry then on return we'll have this old
        entry point to the new entry, but still return the new
        entry.

Return Value:

    NTSTATUS - An appropriate status value

--*/

{
    NTSTATUS Status;
    PRTL_HEAP_USAGE_ENTRY p;
    PVOID CommitAddress;
    SIZE_T PageSize;

    //
    //  Check if the free list is empty and then we have to allocate more
    //  memory for the free list
    //

    if (Buffer->FreeList == NULL) {

        //
        //  We cannot grow the buffer any larger than the reserved size
        //

        if (Buffer->CommittedSize >= Buffer->ReservedSize) {

            return STATUS_NO_MEMORY;
        }

        //
        //  Try and add one page of committed memory to the buffer
        //  starting right after the currently committed space
        //

        PageSize = PAGE_SIZE;

        CommitAddress = (PCHAR)Buffer->Base + Buffer->CommittedSize;

        Status = NtAllocateVirtualMemory( NtCurrentProcess(),
                                          &CommitAddress,
                                          0,
                                          &PageSize,
                                          MEM_COMMIT,
                                          PAGE_READWRITE );

        if (!NT_SUCCESS( Status )) {

            return Status;
        }

        //
        //  Update the committed buffer size
        //

        Buffer->CommittedSize += PageSize;

        //
        //  Add the newly allocated space to the free list and
        //  build up the free list
        //

        Buffer->FreeList = CommitAddress;

        p = Buffer->FreeList;

        while (PageSize != 0) {

            p->Next = (p+1);
            p += 1;
            PageSize -= sizeof( *p );
        }

        //
        //  Null terminate the next pointer in the last free entry
        //

        p -= 1;
        p->Next = NULL;
    }

    //
    //  At this point the free list contains at least one entry
    //  so simply pop the entry.
    //

    p = Buffer->FreeList;

    Buffer->FreeList = p->Next;

    p->Next = NULL;

    //
    //  Now if the caller supplied an existing heap entry then
    //  we'll make the old heap entry point to this new entry
    //

    if (*pp) {

        (*pp)->Next = p;
    }

    //
    //  And then return the new entry to our caller
    //

    *pp = p;

    return STATUS_SUCCESS;
}


//
//  Local support routine
//

PRTL_HEAP_USAGE_ENTRY
RtlpFreeHeapUsageEntry (
    PRTL_HEAP_USAGE_INTERNAL Buffer,
    PRTL_HEAP_USAGE_ENTRY p
    )

/*++

Routine Description:

    This routine moves a heap usage entry from its current
    list onto the free list and returns a pointer to the
    next heap usage entry in the list.  It is like doing a pop
    of the list denoted by "p"

Arguments:

    Buffer - Supplies a pointer to the internal heap usage buffer
        being modified

    p - Supplies a pointer to the entry being moved.  Okay if
        it's null

Return Value:

    PRTL_HEAP_USAGE_ENTRY - Returns a pointer to the next heap usage
        entry

--*/

{
    PRTL_HEAP_USAGE_ENTRY pTmp;

    //
    //  Check if we have a non null heap entry and if so then add
    //  the entry to the front of the free list and return the next
    //  entry in the list
    //

    if (p != NULL) {

        pTmp = p->Next;

        p->Next = Buffer->FreeList;

        Buffer->FreeList = p;

    } else {

        pTmp = NULL;
    }

    return pTmp;
}


//
//  Declared in heap.h
//

BOOLEAN
RtlpHeapIsLocked (
    IN PVOID HeapHandle
    )

/*++

Routine Description:

    This routine is used to determine if a heap is locked

Arguments:

    HeapHandle - Supplies a pointer to the heap being queried

Return Value:

    BOOLEAN - TRUE if the heap is locked and FALSE otherwise

--*/

{
    PHEAP Heap;

    //
    //  Check if this is guard page version of heap
    //

    IF_DEBUG_PAGE_HEAP_THEN_RETURN( HeapHandle,
                                    RtlpDebugPageHeapIsLocked( HeapHandle ));

    Heap = (PHEAP)HeapHandle;

    //
    //  The heap is locked if there is a lock variable, and it has an
    //  owning thread or the lockcount is not -1
    //

    return (( Heap->LockVariable != NULL ) &&
            ( Heap->LockVariable->Lock.CriticalSection.OwningThread ||
              Heap->LockVariable->Lock.CriticalSection.LockCount != -1 ));
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\rtl\heappage.c ===
//
//  heappage.c
//
//  Implementation of NT RtlHeap family of APIs for debugging
//  applications with heap usage bugs.  Each allocation returned to
//  the calling app is placed at the end of a virtual page such that
//  the following virtual page is protected (ie, NO_ACCESS).
//  So, when the errant app attempts to reference or modify memory
//  beyond the allocated portion of a heap block, an access violation
//  is immediately caused.  This facilitates debugging the app
//  because the access violation occurs at the exact point in the
//  app where the heap corruption or abuse would occur.  Note that
//  significantly more memory (pagefile) is required to run an app
//  using this heap implementation as opposed to the retail heap
//  manager.
//
//  Author:  Tom McGuire (tommcg)
//    Date:  01/06/1995
//
//  Copyright (C) 1994-1996, Microsoft
//

#include "ntrtlp.h"
#include "heappage.h"       // external interface (hooks) to debug heap manager

int __cdecl sprintf(char *, const char *, ...);

//
//  Remainder of entire file is wrapped with #ifdef DEBUG_PAGE_HEAP so that
//  it will compile away to nothing if DEBUG_PAGE_HEAP is not defined in
//  heappage.h
//

#ifdef DEBUG_PAGE_HEAP

#if defined(_X86_)
    #ifndef PAGE_SIZE
    #define PAGE_SIZE   0x1000
    #endif
    #define USER_ALIGNMENT 8
#elif defined(_MIPS_)
    #ifndef PAGE_SIZE
    #define PAGE_SIZE   0x1000
    #endif
    #define USER_ALIGNMENT 8
#elif defined(_PPC_)
    #ifndef PAGE_SIZE
    #define PAGE_SIZE   0x1000
    #endif
    #define USER_ALIGNMENT 8
#elif defined(_IA64_)
    #ifndef PAGE_SIZE
    #define PAGE_SIZE   0x2000
    #endif
    #define USER_ALIGNMENT 16
#elif defined(_AXP64_)
    #ifndef PAGE_SIZE
    #define PAGE_SIZE   0x2000
    #endif
    #define USER_ALIGNMENT 16
#elif defined(_ALPHA_)
    #ifndef PAGE_SIZE
    #define PAGE_SIZE   0x2000
    #endif
    #define USER_ALIGNMENT 8
#else
    #error  // platform not defined
#endif


#define DPH_HEAP_ROOT_SIGNATURE  0xFFEEDDCC
#define FILL_BYTE                0xEE
#define HEAD_FILL_SIZE           0x10
#define RESERVE_SIZE             0x800000
#define VM_UNIT_SIZE             0x10000
#define POOL_SIZE                0x4000
#define INLINE                   __inline
#define LOCAL_FUNCTION           // static   // no coff symbols on static functions
#define MIN_FREE_LIST_LENGTH     8


#define ROUNDUP2( x, n ) ((( x ) + (( n ) - 1 )) & ~(( n ) - 1 ))

#if INTERNAL_DEBUG
    #define DEBUG_CODE( a ) a
#else
    #define DEBUG_CODE( a )
#endif

#define RETAIL_ASSERT( a ) ( (a) ? TRUE : \
            RtlpDebugPageHeapAssert( "PAGEHEAP: ASSERTION FAILED: (" #a ")\n" ))

#define DEBUG_ASSERT( a ) DEBUG_CODE( RETAIL_ASSERT( a ))

#define HEAP_HANDLE_FROM_ROOT( HeapRoot ) \
            ((PVOID)(((PCHAR)(HeapRoot)) - PAGE_SIZE ))

#define IF_GENERATE_EXCEPTION( Flags, Status ) {                \
            if (( Flags ) & HEAP_GENERATE_EXCEPTIONS )          \
                RtlpDebugPageHeapException((ULONG)(Status));    \
            }

#define OUT_OF_VM_BREAK( Flags, szText ) {                      \
            if (( Flags ) & HEAP_BREAK_WHEN_OUT_OF_VM )         \
                RtlpDebugPageHeapBreak(( szText ));             \
            }

#define ENQUEUE_HEAD( Node, Head, Tail ) {          \
            (Node)->pNextAlloc = (Head);            \
            if ((Head) == NULL )                    \
                (Tail) = (Node);                    \
            (Head) = (Node);                        \
            }

#define ENQUEUE_TAIL( Node, Head, Tail ) {          \
            if ((Tail) == NULL )                    \
                (Head) = (Node);                    \
            else                                    \
                (Tail)->pNextAlloc = (Node);        \
            (Tail) = (Node);                        \
            }

#define DEQUEUE_NODE( Node, Prev, Head, Tail ) {    \
            PVOID Next = (Node)->pNextAlloc;        \
            if ((Head) == (Node))                   \
                (Head) = Next;                      \
            if ((Tail) == (Node))                   \
                (Tail) = (Prev);                    \
            if ((Prev) != (NULL))                   \
                (Prev)->pNextAlloc = Next;          \
            }

#define PROTECT_HEAP_STRUCTURES( HeapRoot ) {                           \
            if ((HeapRoot)->HeapFlags & HEAP_PROTECTION_ENABLED )       \
                RtlpDebugPageHeapProtectStructures( (HeapRoot) );       \
            }

#define UNPROTECT_HEAP_STRUCTURES( HeapRoot ) {                         \
            if ((HeapRoot)->HeapFlags & HEAP_PROTECTION_ENABLED )       \
                RtlpDebugPageHeapUnProtectStructures( (HeapRoot) );     \
            }


BOOLEAN              RtlpDebugPageHeap;                         // exported via extern
BOOLEAN              RtlpDebugPageHeapListHasBeenInitialized;
RTL_CRITICAL_SECTION RtlpDebugPageHeapListCritSect;
PDPH_HEAP_ROOT       RtlpDebugPageHeapListHead;
PDPH_HEAP_ROOT       RtlpDebugPageHeapListTail;
ULONG                RtlpDebugPageHeapListCount;

//
// `RtlpDebugPageHeapGlobalFlags' stores the global page heap flags.
// The value of this variable is copied into the per heap
// flags (ExtraFlags field) during heap creation.
//


ULONG RtlpDebugPageHeapGlobalFlags =
    
    PAGE_HEAP_ENABLE_PAGE_HEAP       |
#if DBG
    PAGE_HEAP_COLLECT_STACK_TRACES   |
#endif
    0;

//
// The values below are taken into consideration if MinimizeMemoryImpact
// flag is used. They control how are we going to try and minimize the
// memory impact and how we decide which blocks will get allocated
// in the page heap.
//
// `MinimizeCriteria' gives the percentage of available memory (page file)
// out of total memory below which all alocations are done with the normal heap. 
// The valid value is in the range 0..100. A value of 0 will force all allocations
// in the page heap whereas a value of 100 will force all allocations in the
// normal heap.
//
// `VerifyProbability' specifies the probability that the allocation is made in
// the page heap. The valid value is in range 1..100. A value of 100 means all
// allocations are done in the page heap. A value of zero has a special meaning,
// namely we will allocate in the page heap only blocks with the size in range
// `RangeStart'..`RangeEnd'.
//

ULONG RtlpDebugPageHeapVerifyProbability = 25;
ULONG RtlpDebugPageHeapMinimizeCriteria = 50;
ULONG RtlpDebugPageHeapVerifyRangeStart;
ULONG RtlpDebugPageHeapVerifyRangeEnd;

//
// `PageHeapDebugLevel' controls debug messages in the code.
// The value should always be zero for the retail bits.
//

ULONG PageHeapDebugLevel;

//
//  Supporting functions
//

VOID
RtlpDebugPageHeapBreak(
    IN PCH Text
    )
    {
    DbgPrint( Text );
    DbgBreakPoint();
    }


LOCAL_FUNCTION
BOOLEAN
RtlpDebugPageHeapAssert(
    IN PCH Text
    )
    {
    RtlpDebugPageHeapBreak( Text );
    return FALSE;
    }


LOCAL_FUNCTION
VOID
RtlpDebugPageHeapEnterCritSect(
    IN PDPH_HEAP_ROOT HeapRoot,
    IN ULONG          Flags
    )
    {
    if ( Flags & HEAP_NO_SERIALIZE ) {

        if ( ! RtlTryEnterCriticalSection( HeapRoot->HeapCritSect )) {

            if ( HeapRoot->nRemoteLockAcquired == 0 ) {

                //
                //  Another thread owns the CritSect.  This is an application
                //  bug since multithreaded access to heap was attempted with
                //  the HEAP_NO_SERIALIZE flag specified.
                //

                RtlpDebugPageHeapBreak( "PAGEHEAP: Multithreaded access with HEAP_NO_SERIALIZE\n" );

                //
                //  In the interest of allowing the errant app to continue,
                //  we'll force serialization and continue.
                //

                HeapRoot->HeapFlags &= ~HEAP_NO_SERIALIZE;

                }

            RtlEnterCriticalSection( HeapRoot->HeapCritSect );

            }
        }
    else {
        RtlEnterCriticalSection( HeapRoot->HeapCritSect );
        }
    }


LOCAL_FUNCTION
INLINE
VOID
RtlpDebugPageHeapLeaveCritSect(
    IN PDPH_HEAP_ROOT HeapRoot
    )
    {
    RtlLeaveCriticalSection( HeapRoot->HeapCritSect );
    }


LOCAL_FUNCTION
VOID
RtlpDebugPageHeapException(
    IN ULONG ExceptionCode
    )
    {
    EXCEPTION_RECORD ER;

    ER.ExceptionCode    = ExceptionCode;
    ER.ExceptionFlags   = 0;
    ER.ExceptionRecord  = NULL;
    ER.ExceptionAddress = RtlpDebugPageHeapException;
    ER.NumberParameters = 0;
    RtlRaiseException( &ER );

    }


LOCAL_FUNCTION
PVOID
RtlpDebugPageHeapPointerFromHandle(
    IN PVOID HeapHandle
    )
    {
    try {
        if (((PHEAP)(HeapHandle))->ForceFlags & HEAP_FLAG_PAGE_ALLOCS ) {

            PDPH_HEAP_ROOT HeapRoot = (PVOID)(((PCHAR)(HeapHandle)) + PAGE_SIZE );

            if ( HeapRoot->Signature == DPH_HEAP_ROOT_SIGNATURE ) {
                return HeapRoot;
                }
            }
        }
    except( EXCEPTION_EXECUTE_HANDLER ) {
        }

    RtlpDebugPageHeapBreak( "PAGEHEAP: Bad heap handle\n" );
    return NULL;
    }


LOCAL_FUNCTION
PCCH
RtlpDebugPageHeapProtectionText(
    IN     ULONG Access,
    IN OUT PCHAR Buffer
    )
    {
    switch ( Access ) {
        case PAGE_NOACCESS:          return "PAGE_NOACCESS";
        case PAGE_READONLY:          return "PAGE_READONLY";
        case PAGE_READWRITE:         return "PAGE_READWRITE";
        case PAGE_WRITECOPY:         return "PAGE_WRITECOPY";
        case PAGE_EXECUTE:           return "PAGE_EXECUTE";
        case PAGE_EXECUTE_READ:      return "PAGE_EXECUTE_READ";
        case PAGE_EXECUTE_READWRITE: return "PAGE_EXECUTE_READWRITE";
        case PAGE_EXECUTE_WRITECOPY: return "PAGE_EXECUTE_WRITECOPY";
        case PAGE_GUARD:             return "PAGE_GUARD";
        case 0:                      return "UNKNOWN";
        default:                     sprintf( Buffer, "0x%08X", Access );
                                     return Buffer;
        }
    }


LOCAL_FUNCTION
BOOLEAN
RtlpDebugPageHeapRobustProtectVM(
    IN PVOID   VirtualBase,
    IN SIZE_T  VirtualSize,
    IN ULONG   NewAccess,
    IN BOOLEAN Recursion
    )
    {
    PVOID  CopyOfVirtualBase = VirtualBase;
    SIZE_T CopyOfVirtualSize = VirtualSize;
    ULONG  OldAccess;
    NTSTATUS Status;

    Status = ZwProtectVirtualMemory(
                 NtCurrentProcess(),
                 &CopyOfVirtualBase,
                 &CopyOfVirtualSize,
                 NewAccess,
                 &OldAccess
                 );

    if ( NT_SUCCESS( Status ))
        return TRUE;

    if ( ! Recursion ) {

        //
        //  We failed to change the protection on a range of memory.
        //  This can happen if if the range of memory spans more than
        //  one adjancent blocks allocated by separate calls to
        //  ZwAllocateVirtualMemory.  It also seems fails occasionally
        //  for reasons unknown to me, but always when attempting to
        //  change the protection on more than one page in a single call.
        //  So, fall back to changing pages individually in this range.
        //  This should be rare, so it should not be a performance problem.
        //

        PCHAR VirtualExtent = (PCHAR)ROUNDUP2((ULONG_PTR)((PCHAR)VirtualBase + VirtualSize ), PAGE_SIZE );
        PCHAR VirtualPage   = (PCHAR)((ULONG_PTR)VirtualBase & ~( PAGE_SIZE - 1 ));
        BOOLEAN SuccessAll  = TRUE;
        BOOLEAN SuccessOne;

        while ( VirtualPage < VirtualExtent ) {

            SuccessOne = RtlpDebugPageHeapRobustProtectVM(
                             VirtualPage,
                             PAGE_SIZE,
                             NewAccess,
                             TRUE
                             );

            if ( ! SuccessOne ) {
                SuccessAll = FALSE;
                }

            VirtualPage += PAGE_SIZE;

            }

        return SuccessAll;      // TRUE if all succeeded, FALSE if any failed
        }

    else {

        MEMORY_BASIC_INFORMATION mbi;
        CHAR OldProtectionText[ 12 ];     // big enough for "0x12345678"
        CHAR NewProtectionText[ 12 ];     // big enough for "0x12345678"

        mbi.Protect = 0;    // in case ZwQueryVirtualMemory fails

        ZwQueryVirtualMemory(
            NtCurrentProcess(),
            VirtualBase,
            MemoryBasicInformation,
            &mbi,
            sizeof( mbi ),
            NULL
            );

        DbgPrint(
            "PAGEHEAP: Failed changing VM at %08X size 0x%X\n"
            "          from %s to %s (Status %08X)\n",
            VirtualBase,
            VirtualSize,
            RtlpDebugPageHeapProtectionText( mbi.Protect, OldProtectionText ),
            RtlpDebugPageHeapProtectionText( NewAccess, NewProtectionText ),
            Status
            );
        }

    return FALSE;
    }


LOCAL_FUNCTION
INLINE
BOOLEAN
RtlpDebugPageHeapProtectVM(
    IN PVOID   VirtualBase,
    IN SIZE_T  VirtualSize,
    IN ULONG   NewAccess
    )
    {
    return RtlpDebugPageHeapRobustProtectVM( VirtualBase, VirtualSize, NewAccess, FALSE );
    }


LOCAL_FUNCTION
INLINE
PVOID
RtlpDebugPageHeapAllocateVM(
    IN SIZE_T nSize
    )
    {
    NTSTATUS Status;
    PVOID pVirtual;

    pVirtual = NULL;

    Status = ZwAllocateVirtualMemory( NtCurrentProcess(),
                                      &pVirtual,
                                      0,
                                      &nSize,
                                      MEM_COMMIT,
                                      PAGE_NOACCESS );

    return NT_SUCCESS( Status ) ? pVirtual : NULL;
    }


LOCAL_FUNCTION
INLINE
BOOLEAN
RtlpDebugPageHeapReleaseVM(
    IN PVOID pVirtual
    )

{
    SIZE_T nSize = 0;

    return NT_SUCCESS( ZwFreeVirtualMemory( NtCurrentProcess(),
                                            &pVirtual,
                                            &nSize,
                                            MEM_RELEASE ));
}


LOCAL_FUNCTION
PDPH_HEAP_ALLOCATION
RtlpDebugPageHeapTakeNodeFromUnusedList(
    IN PDPH_HEAP_ROOT pHeap
    )
    {
    PDPH_HEAP_ALLOCATION pNode = pHeap->pUnusedNodeListHead;
    PDPH_HEAP_ALLOCATION pPrev = NULL;

    //
    //  UnusedNodeList is LIFO with most recent entry at head of list.
    //

    if ( pNode ) {

        DEQUEUE_NODE( pNode, pPrev, pHeap->pUnusedNodeListHead, pHeap->pUnusedNodeListTail );

        --pHeap->nUnusedNodes;

        }

    return pNode;
    }


LOCAL_FUNCTION
VOID
RtlpDebugPageHeapReturnNodeToUnusedList(
    IN PDPH_HEAP_ROOT       pHeap,
    IN PDPH_HEAP_ALLOCATION pNode
    )
    {

    //
    //  UnusedNodeList is LIFO with most recent entry at head of list.
    //

    ENQUEUE_HEAD( pNode, pHeap->pUnusedNodeListHead, pHeap->pUnusedNodeListTail );

    ++pHeap->nUnusedNodes;

    }


LOCAL_FUNCTION
PDPH_HEAP_ALLOCATION
RtlpDebugPageHeapFindBusyMem(
    IN  PDPH_HEAP_ROOT        pHeap,
    IN  PVOID                 pUserMem,
    OUT PDPH_HEAP_ALLOCATION *pPrevAlloc
    )
    {
    PDPH_HEAP_ALLOCATION pNode = pHeap->pBusyAllocationListHead;
    PDPH_HEAP_ALLOCATION pPrev = NULL;

    while ( pNode != NULL ) {

        if ( pNode->pUserAllocation == pUserMem ) {

            if ( pPrevAlloc )
                *pPrevAlloc = pPrev;

            return pNode;
            }

        pPrev = pNode;
        pNode = pNode->pNextAlloc;
        }

    return NULL;
    }


LOCAL_FUNCTION
VOID
RtlpDebugPageHeapRemoveFromAvailableList(
    IN PDPH_HEAP_ROOT       pHeap,
    IN PDPH_HEAP_ALLOCATION pNode,
    IN PDPH_HEAP_ALLOCATION pPrev
    )
    {

    DEQUEUE_NODE( pNode, pPrev, pHeap->pAvailableAllocationListHead, pHeap->pAvailableAllocationListTail );

    pHeap->nAvailableAllocations--;
    pHeap->nAvailableAllocationBytesCommitted -= pNode->nVirtualBlockSize;

    }


LOCAL_FUNCTION
VOID
RtlpDebugPageHeapPlaceOnFreeList(
    IN PDPH_HEAP_ROOT       pHeap,
    IN PDPH_HEAP_ALLOCATION pAlloc
    )
    {

    //
    //  FreeAllocationList is stored FIFO to enhance finding
    //  reference-after-freed bugs by keeping previously freed
    //  allocations on the free list as long as possible.
    //

    pAlloc->pNextAlloc = NULL;

    ENQUEUE_TAIL( pAlloc, pHeap->pFreeAllocationListHead, pHeap->pFreeAllocationListTail );

    pHeap->nFreeAllocations++;
    pHeap->nFreeAllocationBytesCommitted += pAlloc->nVirtualBlockSize;

    }


LOCAL_FUNCTION
VOID
RtlpDebugPageHeapRemoveFromFreeList(
    IN PDPH_HEAP_ROOT       pHeap,
    IN PDPH_HEAP_ALLOCATION pNode,
    IN PDPH_HEAP_ALLOCATION pPrev
    )
    {

    DEQUEUE_NODE( pNode, pPrev, pHeap->pFreeAllocationListHead, pHeap->pFreeAllocationListTail );

    pHeap->nFreeAllocations--;
    pHeap->nFreeAllocationBytesCommitted -= pNode->nVirtualBlockSize;

#if DPH_CAPTURE_STACK_TRACE

    pNode->pStackTrace = NULL;

#endif // DPH_CAPTURE_STACK_TRACE

    }


LOCAL_FUNCTION
VOID
RtlpDebugPageHeapPlaceOnVirtualList(
    IN PDPH_HEAP_ROOT       pHeap,
    IN PDPH_HEAP_ALLOCATION pNode
    )
    {

    //
    //  VirtualStorageList is LIFO so that releasing VM blocks will
    //  occur in exact reverse order.
    //

    ENQUEUE_HEAD( pNode, pHeap->pVirtualStorageListHead, pHeap->pVirtualStorageListTail );

    pHeap->nVirtualStorageRanges++;
    pHeap->nVirtualStorageBytes += pNode->nVirtualBlockSize;

    }


LOCAL_FUNCTION
VOID
RtlpDebugPageHeapPlaceOnBusyList(
    IN PDPH_HEAP_ROOT       pHeap,
    IN PDPH_HEAP_ALLOCATION pNode
    )
    {

    //
    //  BusyAllocationList is LIFO to achieve better temporal locality
    //  of reference (older allocations are farther down the list).
    //

    ENQUEUE_HEAD( pNode, pHeap->pBusyAllocationListHead, pHeap->pBusyAllocationListTail );

    pHeap->nBusyAllocations++;
    pHeap->nBusyAllocationBytesCommitted  += pNode->nVirtualBlockSize;
    pHeap->nBusyAllocationBytesAccessible += pNode->nVirtualAccessSize;

    }


LOCAL_FUNCTION
VOID
RtlpDebugPageHeapRemoveFromBusyList(
    IN PDPH_HEAP_ROOT       pHeap,
    IN PDPH_HEAP_ALLOCATION pNode,
    IN PDPH_HEAP_ALLOCATION pPrev
    )
    {

    DEQUEUE_NODE( pNode, pPrev, pHeap->pBusyAllocationListHead, pHeap->pBusyAllocationListTail );

    pHeap->nBusyAllocations--;
    pHeap->nBusyAllocationBytesCommitted  -= pNode->nVirtualBlockSize;
    pHeap->nBusyAllocationBytesAccessible -= pNode->nVirtualAccessSize;

    }


LOCAL_FUNCTION
PDPH_HEAP_ALLOCATION
RtlpDebugPageHeapSearchAvailableMemListForBestFit(
    IN  PDPH_HEAP_ROOT        pHeap,
    IN  SIZE_T                nSize,
    OUT PDPH_HEAP_ALLOCATION *pPrevAvailNode
    )
    {
    PDPH_HEAP_ALLOCATION pAvail, pFound, pAvailPrev, pFoundPrev;
    SIZE_T               nAvail, nFound;

    nFound     = 0x7FFFFFFF;
    pFound     = NULL;
    pFoundPrev = NULL;
    pAvailPrev = NULL;
    pAvail     = pHeap->pAvailableAllocationListHead;

    while (( pAvail != NULL ) && ( nFound > nSize )) {

        nAvail = pAvail->nVirtualBlockSize;

        if (( nAvail >= nSize ) && ( nAvail < nFound )) {
            nFound     = nAvail;
            pFound     = pAvail;
            pFoundPrev = pAvailPrev;
            }

        pAvailPrev = pAvail;
        pAvail     = pAvail->pNextAlloc;
        }

    *pPrevAvailNode = pFoundPrev;
    return pFound;
    }


LOCAL_FUNCTION
VOID
RtlpDebugPageHeapCoalesceNodeIntoAvailable(
    IN PDPH_HEAP_ROOT       pHeap,
    IN PDPH_HEAP_ALLOCATION pNode
    )
    {
    PDPH_HEAP_ALLOCATION pPrev    = NULL;
    PDPH_HEAP_ALLOCATION pNext    = pHeap->pAvailableAllocationListHead;
    PUCHAR               pVirtual = pNode->pVirtualBlock;
    SIZE_T               nVirtual = pNode->nVirtualBlockSize;

    pHeap->nAvailableAllocationBytesCommitted += nVirtual;
    pHeap->nAvailableAllocations++;

    //
    //  Walk list to insertion point.
    //

    while (( pNext ) && ( pNext->pVirtualBlock < pVirtual )) {
        pPrev = pNext;
        pNext = pNext->pNextAlloc;
        }

    if ( pPrev ) {

        if (( pPrev->pVirtualBlock + pPrev->nVirtualBlockSize ) == pVirtual ) {

            //
            //  pPrev and pNode are adjacent, so simply add size of
            //  pNode entry to pPrev entry.
            //

            pPrev->nVirtualBlockSize += nVirtual;

            RtlpDebugPageHeapReturnNodeToUnusedList( pHeap, pNode );

            pHeap->nAvailableAllocations--;

            pNode    = pPrev;
            pVirtual = pPrev->pVirtualBlock;
            nVirtual = pPrev->nVirtualBlockSize;

            }

        else {

            //
            //  pPrev and pNode are not adjacent, so insert the pNode
            //  block into the list after pPrev.
            //

            pNode->pNextAlloc = pPrev->pNextAlloc;
            pPrev->pNextAlloc = pNode;

            }
        }

    else {

        //
        //  pNode should be inserted at head of list.
        //

        pNode->pNextAlloc = pHeap->pAvailableAllocationListHead;
        pHeap->pAvailableAllocationListHead = pNode;

        }


    if ( pNext ) {

        if (( pVirtual + nVirtual ) == pNext->pVirtualBlock ) {

            //
            //  pNode and pNext are adjacent, so simply add size of
            //  pNext entry to pNode entry and remove pNext entry
            //  from the list.
            //

            pNode->nVirtualBlockSize += pNext->nVirtualBlockSize;

            pNode->pNextAlloc = pNext->pNextAlloc;

            if ( pHeap->pAvailableAllocationListTail == pNext )
                 pHeap->pAvailableAllocationListTail = pNode;

            RtlpDebugPageHeapReturnNodeToUnusedList( pHeap, pNext );

            pHeap->nAvailableAllocations--;

            }
        }

    else {

        //
        //  pNode is tail of list.
        //

        pHeap->pAvailableAllocationListTail = pNode;

        }
    }


LOCAL_FUNCTION
VOID
RtlpDebugPageHeapCoalesceFreeIntoAvailable(
    IN PDPH_HEAP_ROOT pHeap,
    IN ULONG          nLeaveOnFreeList
    )
    {
    PDPH_HEAP_ALLOCATION pNode = pHeap->pFreeAllocationListHead;
    SIZE_T               nFree = pHeap->nFreeAllocations;
    PDPH_HEAP_ALLOCATION pNext;

    DEBUG_ASSERT( nFree >= nLeaveOnFreeList );

    while (( pNode ) && ( nFree-- > nLeaveOnFreeList )) {

        pNext = pNode->pNextAlloc;  // preserve next pointer across shuffling

        RtlpDebugPageHeapRemoveFromFreeList( pHeap, pNode, NULL );

        RtlpDebugPageHeapCoalesceNodeIntoAvailable( pHeap, pNode );

        pNode = pNext;

        }

    DEBUG_ASSERT(( nFree = (volatile SIZE_T)( pHeap->nFreeAllocations )) >= nLeaveOnFreeList );
    DEBUG_ASSERT(( pNode != NULL ) || ( nFree == 0 ));

    }


LOCAL_FUNCTION
BOOLEAN
RtlpDebugPageHeapGrowVirtual(
    IN PDPH_HEAP_ROOT pHeap,
    IN SIZE_T         nSize
    );


LOCAL_FUNCTION
PDPH_HEAP_ALLOCATION
RtlpDebugPageHeapFindAvailableMem(
    IN  PDPH_HEAP_ROOT        pHeap,
    IN  SIZE_T                nSize,
    OUT PDPH_HEAP_ALLOCATION *pPrevAvailNode,
    IN  BOOLEAN               bGrowVirtual
    )
    {
    PDPH_HEAP_ALLOCATION pAvail;
    ULONG                nLeaveOnFreeList;

    //
    //  First search existing AvailableList for a "best-fit" block
    //  (the smallest block that will satisfy the request).
    //

    pAvail = RtlpDebugPageHeapSearchAvailableMemListForBestFit(
                 pHeap,
                 nSize,
                 pPrevAvailNode
                 );

    while (( pAvail == NULL ) && ( pHeap->nFreeAllocations > MIN_FREE_LIST_LENGTH )) {

        //
        //  Failed to find sufficient memory on AvailableList.  Coalesce
        //  3/4 of the FreeList memory to the AvailableList and try again.
        //  Continue this until we have sufficient memory in AvailableList,
        //  or the FreeList length is reduced to MIN_FREE_LIST_LENGTH entries.
        //  We don't shrink the FreeList length below MIN_FREE_LIST_LENGTH
        //  entries to preserve the most recent MIN_FREE_LIST_LENGTH entries
        //  for reference-after-freed purposes.
        //

        nLeaveOnFreeList = pHeap->nFreeAllocations / 4;

        if ( nLeaveOnFreeList < MIN_FREE_LIST_LENGTH )
             nLeaveOnFreeList = MIN_FREE_LIST_LENGTH;

        RtlpDebugPageHeapCoalesceFreeIntoAvailable( pHeap, nLeaveOnFreeList );

        pAvail = RtlpDebugPageHeapSearchAvailableMemListForBestFit(
                     pHeap,
                     nSize,
                     pPrevAvailNode
                     );

        }


    if (( pAvail == NULL ) && ( bGrowVirtual )) {

        //
        //  After coalescing FreeList into AvailableList, still don't have
        //  enough memory (large enough block) to satisfy request, so we
        //  need to allocate more VM.
        //

        if ( RtlpDebugPageHeapGrowVirtual( pHeap, nSize )) {

            pAvail = RtlpDebugPageHeapSearchAvailableMemListForBestFit(
                         pHeap,
                         nSize,
                         pPrevAvailNode
                         );

            if ( pAvail == NULL ) {

                //
                //  Failed to satisfy request with more VM.  If remainder
                //  of free list combined with available list is larger
                //  than the request, we might still be able to satisfy
                //  the request by merging all of the free list onto the
                //  available list.  Note we lose our MIN_FREE_LIST_LENGTH
                //  reference-after-freed insurance in this case, but it
                //  is a rare case, and we'd prefer to satisfy the allocation.
                //

                if (( pHeap->nFreeAllocationBytesCommitted +
                      pHeap->nAvailableAllocationBytesCommitted ) >= nSize ) {

                    RtlpDebugPageHeapCoalesceFreeIntoAvailable( pHeap, 0 );

                    pAvail = RtlpDebugPageHeapSearchAvailableMemListForBestFit(
                                 pHeap,
                                 nSize,
                                 pPrevAvailNode
                                 );
                    }
                }
            }
        }

    return pAvail;
    }


LOCAL_FUNCTION
VOID
RtlpDebugPageHeapPlaceOnPoolList(
    IN PDPH_HEAP_ROOT       pHeap,
    IN PDPH_HEAP_ALLOCATION pNode
    )
    {

    //
    //  NodePoolList is FIFO.
    //

    pNode->pNextAlloc = NULL;

    ENQUEUE_TAIL( pNode, pHeap->pNodePoolListHead, pHeap->pNodePoolListTail );

    pHeap->nNodePoolBytes += pNode->nVirtualBlockSize;
    pHeap->nNodePools     += 1;

    }


LOCAL_FUNCTION
VOID
RtlpDebugPageHeapAddNewPool(
    IN PDPH_HEAP_ROOT pHeap,
    IN PVOID          pVirtual,
    IN SIZE_T         nSize,
    IN BOOLEAN        bAddToPoolList
    )
    {
    PDPH_HEAP_ALLOCATION pNode, pFirst;
    ULONG n, nCount;

    //
    //  Assume pVirtual points to committed block of nSize bytes.
    //

    pFirst = pVirtual;
    nCount = (ULONG)(nSize  / sizeof( DPH_HEAP_ALLOCATION ));

    for ( n = nCount - 1, pNode = pFirst; n > 0; pNode++, n-- )
        pNode->pNextAlloc = pNode + 1;

    pNode->pNextAlloc = NULL;

    //
    //  Now link this list into the tail of the UnusedNodeList
    //

    ENQUEUE_TAIL( pFirst, pHeap->pUnusedNodeListHead, pHeap->pUnusedNodeListTail );

    pHeap->pUnusedNodeListTail = pNode;

    pHeap->nUnusedNodes += nCount;

    if ( bAddToPoolList ) {

        //
        //  Now add an entry on the PoolList by taking a node from the
        //  UnusedNodeList, which should be guaranteed to be non-empty
        //  since we just added new nodes to it.
        //

        pNode = RtlpDebugPageHeapTakeNodeFromUnusedList( pHeap );

        DEBUG_ASSERT( pNode != NULL );

        pNode->pVirtualBlock     = pVirtual;
        pNode->nVirtualBlockSize = nSize;

        RtlpDebugPageHeapPlaceOnPoolList( pHeap, pNode );

        }

    }


LOCAL_FUNCTION
PDPH_HEAP_ALLOCATION
RtlpDebugPageHeapAllocateNode(
    IN PDPH_HEAP_ROOT pHeap
    )
    {
    PDPH_HEAP_ALLOCATION pNode, pPrev, pReturn;
    PUCHAR pVirtual;
    SIZE_T nVirtual;
    SIZE_T nRequest;

    DEBUG_ASSERT( ! pHeap->InsideAllocateNode );
    DEBUG_CODE( pHeap->InsideAllocateNode = TRUE );

    pReturn = NULL;

    if ( pHeap->pUnusedNodeListHead == NULL ) {

        //
        //  We're out of nodes -- allocate new node pool
        //  from AvailableList.  Set bGrowVirtual to FALSE
        //  since growing virtual will require new nodes, causing
        //  recursion.  Note that simply calling FindAvailableMem
        //  might return some nodes to the pUnusedNodeList, even if
        //  the call fails, so we'll check that the UnusedNodeList
        //  is still empty before we try to use or allocate more
        //  memory.
        //

        nRequest = POOL_SIZE;

        pNode = RtlpDebugPageHeapFindAvailableMem(
                    pHeap,
                    nRequest,
                    &pPrev,
                    FALSE
                    );

        if (( pHeap->pUnusedNodeListHead == NULL ) && ( pNode == NULL )) {

            //
            //  Reduce request size to PAGE_SIZE and see if
            //  we can find at least a page on the available
            //  list.
            //

            nRequest = PAGE_SIZE;

            pNode = RtlpDebugPageHeapFindAvailableMem(
                        pHeap,
                        nRequest,
                        &pPrev,
                        FALSE
                        );

            }

        if ( pHeap->pUnusedNodeListHead == NULL ) {

            if ( pNode == NULL ) {

                //
                //  Insufficient memory on Available list.  Try allocating a
                //  new virtual block.
                //

                nRequest = POOL_SIZE;
                nVirtual = RESERVE_SIZE;
                pVirtual = RtlpDebugPageHeapAllocateVM( nVirtual );

                if ( pVirtual == NULL ) {

                    //
                    //  Unable to allocate full RESERVE_SIZE block,
                    //  so reduce request to single VM unit (64K)
                    //  and try again.
                    //

                    nVirtual = VM_UNIT_SIZE;
                    pVirtual = RtlpDebugPageHeapAllocateVM( nVirtual );

                    if ( pVirtual == NULL ) {

                        //
                        //  Can't allocate any VM.
                        //

                        goto EXIT;
                        }
                    }
                }

            else {

                RtlpDebugPageHeapRemoveFromAvailableList( pHeap, pNode, pPrev );

                pVirtual = pNode->pVirtualBlock;
                nVirtual = pNode->nVirtualBlockSize;

                }

            //
            //  We now have allocated VM referenced by pVirtual,nVirtual.
            //  Make nRequest portion of VM accessible for new node pool.
            //

            if ( ! RtlpDebugPageHeapProtectVM( pVirtual, nRequest, PAGE_READWRITE )) {

                if ( pNode == NULL ) {
                    RtlpDebugPageHeapReleaseVM( pVirtual );
                    }
                else {
                    RtlpDebugPageHeapCoalesceNodeIntoAvailable( pHeap, pNode );
                    }

                goto EXIT;
                }

            //
            //  Now we have accessible memory for new pool.  Add the
            //  new memory to the pool.  If the new memory came from
            //  AvailableList versus fresh VM, zero the memory first.
            //

            if ( pNode != NULL )
                RtlZeroMemory( pVirtual, nRequest );

            RtlpDebugPageHeapAddNewPool( pHeap, pVirtual, nRequest, TRUE );

            //
            //  If any memory remaining, put it on available list.
            //

            if ( pNode == NULL ) {

                //
                //  Memory came from new VM -- add appropriate list entries
                //  for new VM and add remainder of VM to free list.
                //

                pNode = RtlpDebugPageHeapTakeNodeFromUnusedList( pHeap );
                DEBUG_ASSERT( pNode != NULL );
                pNode->pVirtualBlock     = pVirtual;
                pNode->nVirtualBlockSize = nVirtual;
                RtlpDebugPageHeapPlaceOnVirtualList( pHeap, pNode );

                pNode = RtlpDebugPageHeapTakeNodeFromUnusedList( pHeap );
                DEBUG_ASSERT( pNode != NULL );
                pNode->pVirtualBlock     = pVirtual + nRequest;
                pNode->nVirtualBlockSize = nVirtual - nRequest;

                RtlpDebugPageHeapCoalesceNodeIntoAvailable( pHeap, pNode );

                }

            else {

                if ( pNode->nVirtualBlockSize > nRequest ) {

                    pNode->pVirtualBlock     += nRequest;
                    pNode->nVirtualBlockSize -= nRequest;

                    RtlpDebugPageHeapCoalesceNodeIntoAvailable( pHeap, pNode );
                    }

                else {

                    //
                    //  Used up entire available block -- return node to
                    //  unused list.
                    //

                    RtlpDebugPageHeapReturnNodeToUnusedList( pHeap, pNode );

                    }
                }
            }
        }

    pReturn = RtlpDebugPageHeapTakeNodeFromUnusedList( pHeap );
    DEBUG_ASSERT( pReturn != NULL );

EXIT:

    DEBUG_CODE( pHeap->InsideAllocateNode = FALSE );
    return pReturn;
    }


LOCAL_FUNCTION
BOOLEAN
RtlpDebugPageHeapGrowVirtual(
    IN PDPH_HEAP_ROOT pHeap,
    IN SIZE_T         nSize
    )
    {
    PDPH_HEAP_ALLOCATION pVirtualNode;
    PDPH_HEAP_ALLOCATION pAvailNode;
    PVOID  pVirtual;
    SIZE_T nVirtual;

    pVirtualNode = RtlpDebugPageHeapAllocateNode( pHeap );

    if ( pVirtualNode == NULL ) {
        return FALSE;
        }

    pAvailNode = RtlpDebugPageHeapAllocateNode( pHeap );

    if ( pAvailNode == NULL ) {
        RtlpDebugPageHeapReturnNodeToUnusedList( pHeap, pVirtualNode );
        return FALSE;
        }

    nSize    = ROUNDUP2( nSize, VM_UNIT_SIZE );
    nVirtual = ( nSize > RESERVE_SIZE ) ? nSize : RESERVE_SIZE;
    pVirtual = RtlpDebugPageHeapAllocateVM( nVirtual );

    if (( pVirtual == NULL ) && ( nSize < RESERVE_SIZE )) {
        nVirtual = nSize;
        pVirtual = RtlpDebugPageHeapAllocateVM( nVirtual );
        }

    if ( pVirtual == NULL ) {
        RtlpDebugPageHeapReturnNodeToUnusedList( pHeap, pVirtualNode );
        RtlpDebugPageHeapReturnNodeToUnusedList( pHeap, pAvailNode );
        return FALSE;
        }

    pVirtualNode->pVirtualBlock     = pVirtual;
    pVirtualNode->nVirtualBlockSize = nVirtual;
    RtlpDebugPageHeapPlaceOnVirtualList( pHeap, pVirtualNode );

    pAvailNode->pVirtualBlock     = pVirtual;
    pAvailNode->nVirtualBlockSize = nVirtual;
    RtlpDebugPageHeapCoalesceNodeIntoAvailable( pHeap, pAvailNode );

    return TRUE;
    }


LOCAL_FUNCTION
VOID
RtlpDebugPageHeapProtectStructures(
    IN PDPH_HEAP_ROOT pHeap
    )
    {
    PDPH_HEAP_ALLOCATION pNode;

    //
    //  Assume CritSect is owned so we're the only thread twiddling
    //  the protection.
    //

    DEBUG_ASSERT( pHeap->HeapFlags & HEAP_PROTECTION_ENABLED );

    if ( --pHeap->nUnProtectionReferenceCount == 0 ) {

        pNode = pHeap->pNodePoolListHead;

        while ( pNode != NULL ) {

            RtlpDebugPageHeapProtectVM( pNode->pVirtualBlock,
                                        pNode->nVirtualBlockSize,
                                        PAGE_READONLY );

            pNode = pNode->pNextAlloc;

            }
        }
    }


LOCAL_FUNCTION
VOID
RtlpDebugPageHeapUnProtectStructures(
    IN PDPH_HEAP_ROOT pHeap
    )
    {
    PDPH_HEAP_ALLOCATION pNode;

    DEBUG_ASSERT( pHeap->HeapFlags & HEAP_PROTECTION_ENABLED );

    if ( pHeap->nUnProtectionReferenceCount == 0 ) {

        pNode = pHeap->pNodePoolListHead;

        while ( pNode != NULL ) {

            RtlpDebugPageHeapProtectVM( pNode->pVirtualBlock,
                                        pNode->nVirtualBlockSize,
                                        PAGE_READWRITE );

            pNode = pNode->pNextAlloc;

            }
        }

    ++pHeap->nUnProtectionReferenceCount;

    }


LOCAL_FUNCTION
INLINE
PUCHAR
RtlpDebugPageHeapScanForFillCorruption(
    IN PUCHAR Address,
    IN UCHAR  ExpectedValue,
    IN SIZE_T Length
    )
    {
    PUCHAR End;

    for ( End = Address + Length; Address < End; Address++ ) {
        if ( *Address != ExpectedValue )
            return Address;
        }

    return NULL;
    }


LOCAL_FUNCTION
BOOLEAN
RtlpDebugPageHeapDetectFillCorruption(
    IN PDPH_HEAP_ALLOCATION pNode
    )
    {
    PUCHAR p;

    p = RtlpDebugPageHeapScanForFillCorruption(
            pNode->pUserAllocation + pNode->nUserRequestedSize,
            FILL_BYTE,
            pNode->nUserActualSize - pNode->nUserRequestedSize );

    if ( p != NULL ) {

        DbgPrint( "PAGEHEAP: Tail fill corruption detected:\n"
                  "          Allocation at  0x%08X\n"
                  "          Requested size 0x%08X\n"
                  "          Allocated size 0x%08X\n"
                  "          Corruption at  0x%08X\n",
                  pNode->pUserAllocation,
                  pNode->nUserRequestedSize,
                  pNode->nUserActualSize,
                  p );

        RtlpDebugPageHeapBreak( "" );
        return TRUE;
        }

    return FALSE;
    }


#if INTERNAL_DEBUG

LOCAL_FUNCTION
VOID
RtlpDebugPageHeapVerifyList(
    IN PDPH_HEAP_ALLOCATION pListHead,
    IN PDPH_HEAP_ALLOCATION pListTail,
    IN SIZE_T               nExpectedLength,
    IN SIZE_T               nExpectedVirtual,
    IN PCCH                 pListName
    )
    {
    PDPH_HEAP_ALLOCATION pPrev = NULL;
    PDPH_HEAP_ALLOCATION pNode = pListHead;
    PDPH_HEAP_ALLOCATION pTest = pListHead ? pListHead->pNextAlloc : NULL;
    ULONG                nNode = 0;
    SIZE_T               nSize = 0;

    while ( pNode ) {

        if ( pNode == pTest ) {
            DbgPrint( "PAGEHEAP: Internal %s list is circular\n", pListName );
            RtlpDebugPageHeapBreak( "" );
            return;
            }

        nNode++;
        nSize += pNode->nVirtualBlockSize;

        if ( pTest ) {
            pTest = pTest->pNextAlloc;
            if ( pTest ) {
                pTest = pTest->pNextAlloc;
                }
            }

        pPrev = pNode;
        pNode = pNode->pNextAlloc;

        }

    if ( pPrev != pListTail ) {
        DbgPrint( "PAGEHEAP: Internal %s list has incorrect tail pointer\n", pListName );
        RtlpDebugPageHeapBreak( "" );
        }

    if (( nExpectedLength != 0xFFFFFFFF ) && ( nExpectedLength != nNode )) {
        DbgPrint( "PAGEHEAP: Internal %s list has incorrect length\n", pListName );
        RtlpDebugPageHeapBreak( "" );
        }

    if (( nExpectedVirtual != 0xFFFFFFFF ) && ( nExpectedVirtual != nSize )) {
        DbgPrint( "PAGEHEAP: Internal %s list has incorrect virtual size\n", pListName );
        RtlpDebugPageHeapBreak( "" );
        }

    }


LOCAL_FUNCTION
VOID
RtlpDebugPageHeapVerifyIntegrity(
    IN PDPH_HEAP_ROOT pHeap
    )
    {

    RtlpDebugPageHeapVerifyList(
        pHeap->pVirtualStorageListHead,
        pHeap->pVirtualStorageListTail,
        pHeap->nVirtualStorageRanges,
        pHeap->nVirtualStorageBytes,
        "VIRTUAL"
        );

    RtlpDebugPageHeapVerifyList(
        pHeap->pBusyAllocationListHead,
        pHeap->pBusyAllocationListTail,
        pHeap->nBusyAllocations,
        pHeap->nBusyAllocationBytesCommitted,
        "BUSY"
        );

    RtlpDebugPageHeapVerifyList(
        pHeap->pFreeAllocationListHead,
        pHeap->pFreeAllocationListTail,
        pHeap->nFreeAllocations,
        pHeap->nFreeAllocationBytesCommitted,
        "FREE"
        );

    RtlpDebugPageHeapVerifyList(
        pHeap->pAvailableAllocationListHead,
        pHeap->pAvailableAllocationListTail,
        pHeap->nAvailableAllocations,
        pHeap->nAvailableAllocationBytesCommitted,
        "AVAILABLE"
        );

    RtlpDebugPageHeapVerifyList(
        pHeap->pUnusedNodeListHead,
        pHeap->pUnusedNodeListTail,
        pHeap->nUnusedNodes,
        0xFFFFFFFF,
        "FREENODE"
        );

    RtlpDebugPageHeapVerifyList(
        pHeap->pNodePoolListHead,
        pHeap->pNodePoolListTail,
        pHeap->nNodePools,
        pHeap->nNodePoolBytes,
        "NODEPOOL"
        );

    }

#endif // INTERNAL_DEBUG


#if DPH_CAPTURE_STACK_TRACE


VOID
RtlpDebugPageHeapRemoteThreadLock(
    IN PVOID HeapBaseAddress
    )
    {
    PDPH_HEAP_ROOT HeapRoot;
    LARGE_INTEGER  Delay;

    try {

        HeapRoot = HeapBaseAddress;

        if ( HeapRoot->Signature == DPH_HEAP_ROOT_SIGNATURE ) {

            RtlpDebugPageHeapEnterCritSect( HeapRoot, 0 );

            (volatile ULONG)( HeapRoot->nRemoteLockAcquired ) = 1;

            Delay.QuadPart = -1000000;  // 100ms, relative to now

            do  {
                ZwDelayExecution( FALSE, &Delay );
                }
            while ((volatile ULONG)( HeapRoot->nRemoteLockAcquired ) == 1 );

            RtlpDebugPageHeapLeaveCritSect( HeapRoot );

            }
        }
    except( EXCEPTION_EXECUTE_HANDLER ) {
        }

    //
    //  Note that TerminateThread will not free thread's stack --
    //  that will be done by remote caller after thread wait is
    //  satisfied by this termination call.
    //

    ZwTerminateThread( NtCurrentThread(), 0 );
    }

//
//  Since RtlpDebugPageHeapRemoteThreadLock is not called from any code in
//  ntdll, the linker will discard it unless we create a reference to it.
//

PVOID RtlpDebugPageHeapRemoteThreadLockAddress = RtlpDebugPageHeapRemoteThreadLock;


LOCAL_FUNCTION
PDPH_STACK_TRACE_NODE
RtlpDebugPageHeapNewStackTraceStorage(
    IN PDPH_HEAP_ROOT HeapRoot,
    IN SIZE_T         Length
    )
    {
    PDPH_HEAP_ALLOCATION  pAvailNode, pPrevNode, pStackNode;
    PDPH_STACK_TRACE_NODE Return;
    PUCHAR                pVirtual;
    SIZE_T                nRequest;
    SIZE_T                Size;

    Size = sizeof( DPH_STACK_TRACE_NODE ) + ( Length * sizeof( PVOID ));

    if ( Size > HeapRoot->nStackTraceStorage ) {

        nRequest = POOL_SIZE;

        pAvailNode = RtlpDebugPageHeapFindAvailableMem(
                         HeapRoot,
                         nRequest,
                         &pPrevNode,
                         TRUE
                         );

        if ( pAvailNode == NULL ) {

            //
            //  Reduce request size to PAGE_SIZE and see if
            //  we can find at least a page on the available
            //  list.
            //

            nRequest = PAGE_SIZE;

            pAvailNode = RtlpDebugPageHeapFindAvailableMem(
                             HeapRoot,
                             nRequest,
                             &pPrevNode,
                             TRUE
                             );

            }

        if ( pAvailNode == NULL )
            return NULL;

        pVirtual = pAvailNode->pVirtualBlock;

        if ( ! RtlpDebugPageHeapProtectVM( pVirtual, nRequest, PAGE_READWRITE )) {
            return NULL;
            }

        //
        //  pAvailNode (still on avail list) points to block large enough
        //  to satisfy request, but it might be large enough to split
        //  into two blocks -- one for request, remainder leave on
        //  avail list.
        //

        if ( pAvailNode->nVirtualBlockSize > nRequest ) {

            //
            //  Adjust pVirtualBlock and nVirtualBlock size of existing
            //  node in avail list.  The node will still be in correct
            //  address space order on the avail list.  This saves having
            //  to remove and then re-add node to avail list.  Note since
            //  we're changing sizes directly, we need to adjust the
            //  avail list counters manually.
            //
            //  Note: since we're leaving at least one page on the
            //  available list, we are guaranteed that AllocateNode
            //  will not fail.
            //

            pAvailNode->pVirtualBlock                    += nRequest;
            pAvailNode->nVirtualBlockSize                -= nRequest;
            HeapRoot->nAvailableAllocationBytesCommitted -= nRequest;

            pStackNode = RtlpDebugPageHeapAllocateNode( HeapRoot );

            DEBUG_ASSERT( pStackNode != NULL );

            pStackNode->pVirtualBlock     = pVirtual;
            pStackNode->nVirtualBlockSize = nRequest;

            }

        else {

            //
            //  Entire avail block is needed, so simply remove it from avail list.
            //

            RtlpDebugPageHeapRemoveFromAvailableList( HeapRoot, pAvailNode, pPrevNode );

            pStackNode = pAvailNode;

            }

        HeapRoot->nStackTraceBytesWasted    += HeapRoot->nStackTraceStorage;
        HeapRoot->nStackTraceBytesCommitted += nRequest;

        //
        //  Note: we're wasting the remaining HeapRoot->nStackTraceStorage
        //  bytes here.
        //

        HeapRoot->pStackTraceStorage = pVirtual;
        HeapRoot->nStackTraceStorage = nRequest;

        RtlpDebugPageHeapPlaceOnPoolList( HeapRoot, pStackNode );

        }

    Return = (PVOID) HeapRoot->pStackTraceStorage;

    HeapRoot->pStackTraceStorage += Size;
    HeapRoot->nStackTraceStorage -= Size;
    HeapRoot->nStackTraceBNodes++;

    return Return;
    }


LOCAL_FUNCTION
PDPH_STACK_TRACE_NODE
RtlpDebugPageHeapFindOrAddStackTrace(
    IN PDPH_HEAP_ROOT HeapRoot,
    IN ULONG          HashValue,
    IN SIZE_T         Length,
    IN PVOID*         Address
    )
    {
    PDPH_STACK_TRACE_NODE Node;
    PDPH_STACK_TRACE_NODE NewNode;
    ULONG                 Depth;

    Node    = HeapRoot->pStackTraceRoot;        // assume non-NULL
    NewNode = NULL;
    Depth   = 0;

    for (;;) {

        Depth++;

        if ( Node->Hash > HashValue ) {         // go left
            if ( Node->Left ) {
                Node = Node->Left;
                }
            else {

                NewNode = RtlpDebugPageHeapNewStackTraceStorage(
                              HeapRoot,
                              Length
                              );

                Node->Left = NewNode;
                break;
                }
            }

        else if ( Node->Hash < HashValue ) {    // go right
            if ( Node->Right ) {
                Node = Node->Right;
                }
            else {

                NewNode = RtlpDebugPageHeapNewStackTraceStorage(
                              HeapRoot,
                              Length
                              );

                Node->Right = NewNode;
                break;
                }
            }
        else {  // ( Node->Hash == HashValue ), verify matching data or rehash

            if (( Node->Length == Length ) &&
                ( RtlCompareMemory( Node->Address, Address, Length ) == Length )) {

                //
                //  Complete match, return this Node.
                //

                return Node;
                }

            else {

                //
                //  Not a match, increment hash value by one and search again
                //  (slow linear-rehashing, but don't expect many collisions).
                //

                HashValue++;
                Node  = HeapRoot->pStackTraceRoot;
                Depth = 0;

                HeapRoot->nStackTraceBHashCollisions++;

                }
            }
        }

    if ( NewNode != NULL ) {

        NewNode->Left      = NULL;
        NewNode->Right     = NULL;
        NewNode->Hash      = HashValue;
        NewNode->Length    = Length;
        NewNode->BusyCount = 0;
        NewNode->BusyBytes = 0;

        RtlCopyMemory( NewNode->Address, Address, Length * sizeof( PVOID ));

        if ( ++Depth > HeapRoot->nStackTraceBDepth ) {
            HeapRoot->nStackTraceBDepth = Depth;
            }
        }

    return NewNode;
    }


#if (( i386 ) && ( FPO ))
#pragma optimize( "y", off )    // disable FPO for consistent stack traces
#endif

LOCAL_FUNCTION
UCHAR
RtlpDebugPageHeapCaptureStackTrace(
    IN  UCHAR  FramesToSkip,
    IN  UCHAR  FramesToCapture,
    OUT PVOID* TraceBuffer,
    OUT PULONG HashValue
    )
{
    ULONG Index;
    PVOID Callers [32];
    ULONG Depth;
    ULONG Result;
    ULONG Hash;

    //
    // Make sure output buffer is clean.
    //

    RtlZeroMemory( TraceBuffer, FramesToCapture * sizeof( PVOID ));
    
    //
    // Figure out what is the depth of the stack
    // we want to search.
    //

    Depth = FramesToCapture + FramesToSkip;

    if (Depth > 32) {
        Depth = 32;
    }
    
    //
    // Get the maximum possible stack trace.
    //

    Result = RtlWalkFrameChain (
        Callers,
        Depth,
        0);

    //
    // Move identified callers into the output buffer and compute
    // a simplistic hash value.
    //

    for (Index = FramesToSkip, Hash = 0; Index < Result; Index++) {
                    
        TraceBuffer[Index - FramesToSkip] = Callers[Index];
        Hash += PtrToUlong(TraceBuffer[Index]);
    }

    //
    // Set hash value and return number of callers identified.
    //

    *HashValue = Hash;

    if (Result > FramesToSkip) {
        return (UCHAR)(Result - FramesToSkip);
    }
    else {
        return 0;
    }

#if 0 //bugbug: silviuc: should delete this code.

    UCHAR FramesCaptured;

    RtlZeroMemory( TraceBuffer, FramesToCapture * sizeof( PVOID ));


    *HashValue = 0;

    try {

        FramesCaptured = (UCHAR) RtlCaptureStackBackTrace(
                                    (UCHAR)( FramesToSkip + 1 ),
                                    FramesToCapture,
                                    TraceBuffer,
                                    HashValue
                                    );

        //
        //  Sometimes the final frame is NULL: if so, we'll strip it
        //  for smaller storage.
        //

        if (( FramesCaptured ) && ( ! TraceBuffer[ FramesCaptured - 1 ] )) {
            --FramesCaptured;
            }

        }

    except( EXCEPTION_EXECUTE_HANDLER ) {

        FramesCaptured = 0;

        while (( FramesCaptured < FramesToCapture ) &&
               ( TraceBuffer[ FramesCaptured ] != NULL )) {

            FramesCaptured++;

            }
        }

    return FramesCaptured;
#endif
}


LOCAL_FUNCTION
PDPH_STACK_TRACE_NODE
RtlpDebugPageHeapCaptureAndStoreStackTrace(
    IN PDPH_HEAP_ROOT HeapRoot,
    IN UCHAR          FramesToSkip
    )
    {
    PVOID TraceBuffer[ DPH_MAX_STACK_LENGTH ];
    ULONG HashValue;
    ULONG FramesCaptured;

    FramesCaptured = RtlpDebugPageHeapCaptureStackTrace(
                         (UCHAR)( FramesToSkip + 1 ),
                         (UCHAR)( DPH_MAX_STACK_LENGTH ),
                         TraceBuffer,
                         &HashValue
                         );

    if ( FramesCaptured ) {

        return RtlpDebugPageHeapFindOrAddStackTrace(
                   HeapRoot,
                   HashValue,
                   FramesCaptured,
                   TraceBuffer
                   );
        }

    return NULL;

    }


#if (( i386 ) && ( FPO ))
#pragma optimize( "", on )      // restore original optimizations
#endif

#endif // DPH_CAPTURE_STACK_TRACE


///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////



//
//  Here's where the exported interface functions are defined.
//

#if (( DPH_CAPTURE_STACK_TRACE ) && ( i386 ) && ( FPO ))
#pragma optimize( "y", off )    // disable FPO for consistent stack traces
#endif


PVOID
RtlpDebugPageHeapCreate(
    IN ULONG  Flags,
    IN PVOID  HeapBase    OPTIONAL,
    IN SIZE_T ReserveSize OPTIONAL,
    IN SIZE_T CommitSize  OPTIONAL,
    IN PVOID  Lock        OPTIONAL,
    IN PRTL_HEAP_PARAMETERS Parameters OPTIONAL
    )
    {
    SYSTEM_BASIC_INFORMATION SystemInfo;
    PDPH_HEAP_ALLOCATION     Node;
    PDPH_HEAP_ROOT           HeapRoot;
    PVOID                    HeapHandle;
    PUCHAR                   pVirtual;
    SIZE_T                   nVirtual;
    SIZE_T                   Size;
    NTSTATUS                 Status;

    //
    // Do we want a page heap for this heap? If we don't we return
    // null and the normal heap manager will continue by creating
    // a normal heap;
    //

    if (! (RtlpDebugPageHeapGlobalFlags & PAGE_HEAP_ENABLE_PAGE_HEAP)) {
        return NULL;
    }

    //
    // If `Parameters' is -1 then this is a recursive call to
    // RtlpDebugPageHeapCreate and we will return NULL so that
    // the normal heap manager will create a normal heap.
    // I agree this is a hack but we need this so that we maintain
    // a very loose dependency between the normal and page heap
    // manager.
    //

    if ((SIZE_T)Parameters == (SIZE_T)-1) {
        return NULL;                                        
    }

    //
    //  We don't handle heaps where HeapBase is already allocated
    //  from user or where Lock is provided by user.
    //

    DEBUG_ASSERT( HeapBase == NULL );
    DEBUG_ASSERT( Lock == NULL );

    if (( HeapBase != NULL ) || ( Lock != NULL ))
        return NULL;

    //
    //  Note that we simply ignore ReserveSize, CommitSize, and
    //  Parameters as we always have a growable heap with our
    //  own thresholds, etc.
    //

    ZwQuerySystemInformation( SystemBasicInformation,
                              &SystemInfo,
                              sizeof( SystemInfo ),
                              NULL );

    RETAIL_ASSERT( SystemInfo.PageSize == PAGE_SIZE );
    RETAIL_ASSERT( SystemInfo.AllocationGranularity == VM_UNIT_SIZE );
    DEBUG_ASSERT(( PAGE_SIZE + POOL_SIZE + PAGE_SIZE ) < VM_UNIT_SIZE );

    nVirtual = RESERVE_SIZE;
    pVirtual = RtlpDebugPageHeapAllocateVM( nVirtual );

    if ( pVirtual == NULL ) {

        nVirtual = VM_UNIT_SIZE;
        pVirtual = RtlpDebugPageHeapAllocateVM( nVirtual );

        if ( pVirtual == NULL ) {
            OUT_OF_VM_BREAK( Flags, "PAGEHEAP: Insufficient memory to create heap\n" );
            IF_GENERATE_EXCEPTION( Flags, STATUS_NO_MEMORY );
            return NULL;
            }
        }

    if ( ! RtlpDebugPageHeapProtectVM( pVirtual, PAGE_SIZE + POOL_SIZE + PAGE_SIZE, PAGE_READWRITE )) {
        RtlpDebugPageHeapReleaseVM( pVirtual );
        IF_GENERATE_EXCEPTION( Flags, STATUS_NO_MEMORY );
        return NULL;
        }

    //
    //  Out of our initial allocation, the initial page is the fake
    //  retail HEAP structure.  The second page begins our DPH_HEAP_ROOT
    //  structure followed by (POOL_SIZE-sizeof(DPH_HEAP_ROOT)) bytes for
    //  the initial pool.  The next page contains out CRIT_SECT
    //  variable, which must always be READWRITE.  Beyond that, the
    //  remainder of the virtual allocation is placed on the available
    //  list.
    //
    //  |_____|___________________|_____|__ _ _ _ _ _ _ _ _ _ _ _ _ __|
    //
    //  ^pVirtual
    //
    //  ^FakeRetailHEAP
    //
    //        ^HeapRoot
    //
    //            ^InitialNodePool
    //
    //                            ^CRITICAL_SECTION
    //
    //                                  ^AvailableSpace
    //
    //
    //
    //  Our DPH_HEAP_ROOT structure starts at the page following the
    //  fake retail HEAP structure pointed to by the "heap handle".
    //  For the fake HEAP structure, we'll fill it with 0xEEEEEEEE
    //  except for the Heap->Flags and Heap->ForceFlags fields,
    //  which we must set to include our HEAP_FLAG_PAGE_ALLOCS flag,
    //  and then we'll make the whole page read-only.
    //

    RtlFillMemory( pVirtual, PAGE_SIZE, FILL_BYTE );

    ((PHEAP)pVirtual)->Flags      = Flags | HEAP_FLAG_PAGE_ALLOCS;
    ((PHEAP)pVirtual)->ForceFlags = Flags | HEAP_FLAG_PAGE_ALLOCS;

    if ( ! RtlpDebugPageHeapProtectVM( pVirtual, PAGE_SIZE, PAGE_READONLY )) {
        RtlpDebugPageHeapReleaseVM( pVirtual );
        IF_GENERATE_EXCEPTION( Flags, STATUS_NO_MEMORY );
        return NULL;
        }

    HeapRoot = (PDPH_HEAP_ROOT)( pVirtual + PAGE_SIZE );

    HeapRoot->Signature    = DPH_HEAP_ROOT_SIGNATURE;
    HeapRoot->HeapFlags    = Flags;
    HeapRoot->HeapCritSect = (PVOID)((PCHAR)HeapRoot + POOL_SIZE );

    //
    // Copy the page heap global flags into per heap flags.
    //

    HeapRoot->ExtraFlags = RtlpDebugPageHeapGlobalFlags;

    //
    // We have to do a little bit of decoding for the GlobalFlags.
    // 
    // bugbug (silviuc) We need to validate the flags because some
    // bit combinations are not valid and might confuse the heap
    // manager.
    //

    if ((RtlpDebugPageHeapGlobalFlags & PAGE_HEAP_MINIMIZE_MEMORY_IMPACT)) {
        
        RtlpDebugPageHeapMinimizeCriteria = 
            (RtlpDebugPageHeapGlobalFlags >> 8) & 0x00FF;

        if ((RtlpDebugPageHeapGlobalFlags & PAGE_HEAP_VERIFY_RANDOMLY)) {

            RtlpDebugPageHeapVerifyProbability =
                RtlpDebugPageHeapGlobalFlags >> 24;
        }
        else {

            RtlpDebugPageHeapVerifyProbability = 0;

            RtlpDebugPageHeapVerifyRangeStart =
                RtlpDebugPageHeapGlobalFlags >> 24;
            
            RtlpDebugPageHeapVerifyRangeEnd =
                (RtlpDebugPageHeapGlobalFlags >> 16) & 0x00FF;
        }
    }

    //
    // Initialize the seed for the random generator used to decide
    // from where should we make allocations if minimize memory
    // impact flag is used. In case the query of performance counter
    // fails (used to give the "random" seed value of the generator)
    // we will default to ABCDDCBA as initial seed value.
    //

    {
        LARGE_INTEGER PerformanceCounter;

        PerformanceCounter.LowPart = 0xABCDDCBA;

        NtQueryPerformanceCounter (
            &PerformanceCounter,
            NULL);
        
        HeapRoot->Seed = PerformanceCounter.LowPart;
    }

    HeapRoot->Counter[0] = 0;
    HeapRoot->Counter[1] = 0;
    HeapRoot->Counter[2] = 0;
    HeapRoot->Counter[3] = 0;
    HeapRoot->Counter[4] = 0;

    //
    // Initialize the normal heap if the global flags combination
    // requires one.
    //

    if ((HeapRoot->ExtraFlags & PAGE_HEAP_MINIMIZE_MEMORY_IMPACT)) {

        HeapRoot->NormalHeap = RtlCreateHeap( 

            Flags,
            HeapBase,
            ReserveSize,
            CommitSize,
            Lock,
            (PRTL_HEAP_PARAMETERS)-1 );

    }
    else {
        HeapRoot->NormalHeap = NULL;
    }

    RtlInitializeCriticalSection( HeapRoot->HeapCritSect );

    //
    //  On the page that contains our DPH_HEAP_ROOT structure, use
    //  the remaining memory beyond the DPH_HEAP_ROOT structure as
    //  pool for allocating heap nodes.
    //

    RtlpDebugPageHeapAddNewPool( HeapRoot,
                                 HeapRoot + 1,
                                 POOL_SIZE - sizeof( DPH_HEAP_ROOT ),
                                 FALSE
                               );

    //
    //  Make initial PoolList entry by taking a node from the
    //  UnusedNodeList, which should be guaranteed to be non-empty
    //  since we just added new nodes to it.
    //

    Node = RtlpDebugPageHeapAllocateNode( HeapRoot );
    DEBUG_ASSERT( Node != NULL );
    Node->pVirtualBlock     = (PVOID)HeapRoot;
    Node->nVirtualBlockSize = POOL_SIZE;
    RtlpDebugPageHeapPlaceOnPoolList( HeapRoot, Node );

    //
    //  Make VirtualStorageList entry for initial VM allocation
    //

    Node = RtlpDebugPageHeapAllocateNode( HeapRoot );
    DEBUG_ASSERT( Node != NULL );
    Node->pVirtualBlock     = pVirtual;
    Node->nVirtualBlockSize = nVirtual;
    RtlpDebugPageHeapPlaceOnVirtualList( HeapRoot, Node );

    //
    //  Make AvailableList entry containing remainder of initial VM
    //  and add to (create) the AvailableList.
    //

    Node = RtlpDebugPageHeapAllocateNode( HeapRoot );
    DEBUG_ASSERT( Node != NULL );
    Node->pVirtualBlock     = pVirtual + ( PAGE_SIZE + POOL_SIZE + PAGE_SIZE );
    Node->nVirtualBlockSize = nVirtual - ( PAGE_SIZE + POOL_SIZE + PAGE_SIZE );
    RtlpDebugPageHeapCoalesceNodeIntoAvailable( HeapRoot, Node );

#if DPH_CAPTURE_STACK_TRACE

    if (HeapRoot->ExtraFlags & PAGE_HEAP_COLLECT_STACK_TRACES) {
        
        HeapRoot->pStackTraceRoot = RtlpDebugPageHeapNewStackTraceStorage( HeapRoot, 0 );
        DEBUG_ASSERT( HeapRoot->pStackTraceRoot != NULL );
        HeapRoot->pStackTraceRoot->Left      = NULL;
        HeapRoot->pStackTraceRoot->Right     = NULL;
        HeapRoot->pStackTraceRoot->Hash      = 0;
        HeapRoot->pStackTraceRoot->BusyCount = 0;
        HeapRoot->pStackTraceRoot->BusyBytes = 0;
        HeapRoot->pStackTraceCreator = RtlpDebugPageHeapCaptureAndStoreStackTrace( HeapRoot, 1 );
    }
    else {

        HeapRoot->pStackTraceRoot = NULL;
        HeapRoot->pStackTraceCreator = NULL;
    }


#endif // DPH_CAPTURE_STACK_TRACE

    //
    //  Initialize heap internal structure protection.
    //

    HeapRoot->nUnProtectionReferenceCount = 1;          // initialize

    //
    //  If this is the first heap creation in this process, then we
    //  need to initialize the process heap list critical section.
    //

    if ( ! RtlpDebugPageHeapListHasBeenInitialized ) {
        RtlpDebugPageHeapListHasBeenInitialized = TRUE;
        RtlInitializeCriticalSection( &RtlpDebugPageHeapListCritSect );
        }

    //
    //  Add this heap entry to the process heap linked list.
    //

    RtlEnterCriticalSection( &RtlpDebugPageHeapListCritSect );

    if ( RtlpDebugPageHeapListHead == NULL ) {
        RtlpDebugPageHeapListHead = HeapRoot;
        RtlpDebugPageHeapListTail = HeapRoot;
        }
    else {
        HeapRoot->pPrevHeapRoot = RtlpDebugPageHeapListTail;
        UNPROTECT_HEAP_STRUCTURES(RtlpDebugPageHeapListTail);
        RtlpDebugPageHeapListTail->pNextHeapRoot = HeapRoot;
        PROTECT_HEAP_STRUCTURES(RtlpDebugPageHeapListTail);
        RtlpDebugPageHeapListTail                = HeapRoot;
        }

    PROTECT_HEAP_STRUCTURES( HeapRoot );                // now protected

    RtlpDebugPageHeapListCount++;

    RtlLeaveCriticalSection( &RtlpDebugPageHeapListCritSect );

    DEBUG_CODE( RtlpDebugPageHeapVerifyIntegrity( HeapRoot ));

    DbgPrint( "PAGEHEAP: process 0x%X created debug heap %p (flags 0x%X, %u, %u, %u, %u)\n",
              NtCurrentTeb()->ClientId.UniqueProcess,
              HEAP_HANDLE_FROM_ROOT( HeapRoot ),
              HeapRoot->ExtraFlags,
              RtlpDebugPageHeapMinimizeCriteria,
              RtlpDebugPageHeapVerifyProbability,
              RtlpDebugPageHeapVerifyRangeStart,
              RtlpDebugPageHeapVerifyRangeEnd);

    return HEAP_HANDLE_FROM_ROOT( HeapRoot );       // same as pVirtual

}


PVOID
RtlpDebugPageHeapAllocate(
    IN PVOID  HeapHandle,
    IN ULONG  Flags,
    IN SIZE_T Size
    )
    {
    PDPH_HEAP_ROOT       HeapRoot;
    PDPH_HEAP_ALLOCATION pAvailNode;
    PDPH_HEAP_ALLOCATION pPrevAvailNode;
    PDPH_HEAP_ALLOCATION pBusyNode;
    SIZE_T               nBytesAllocate;
    SIZE_T               nBytesAccess;
    SIZE_T               nActual;
    PVOID                pVirtual;
    PVOID                pReturn;
    PUCHAR               pBlockHeader;

    HeapRoot = RtlpDebugPageHeapPointerFromHandle( HeapHandle );
    if ( HeapRoot == NULL )
        return NULL;

    Flags |= HeapRoot->HeapFlags;

    //
    // Figure out if we need to minimize memory impact. This
    // might trigger an allocation in the normal heap.
    //

    if ((HeapRoot->ExtraFlags & PAGE_HEAP_MINIMIZE_MEMORY_IMPACT)) {
        
        SYSTEM_PERFORMANCE_INFORMATION PerfInfo;
        NTSTATUS Status;
        ULONG Random;

        RETAIL_ASSERT (HeapRoot->NormalHeap);

        Status = NtQuerySystemInformation(
                    SystemPerformanceInformation,
                    &PerfInfo,
                    sizeof(PerfInfo),
                    NULL
                    );
        
        if(! NT_SUCCESS(Status)) {

            HeapRoot->Counter[0]++;

            return RtlAllocateHeap (

                HeapRoot->NormalHeap,
                Flags,
                Size); 
        }

        //
        // If less than `MinimizeCriteria'% of memory is available we will use
        // the normal heap.
        //

        {
            ULONG Percentage;

            if (PerfInfo.CommitLimit == 0) {

                //
                // Instead of getting divide by zero allocate in normal heap
                //

                Percentage = 100; 
            }
            else {

                //
                // Compute percentage of available memory.
                //

                Percentage = 100 - (((PerfInfo.CommittedPages) * 100)
                              / (PerfInfo.CommitLimit));

                if (PageHeapDebugLevel & 1) {
                    DbgPrint ("Percentage: %u (%08X, %08X) \n", 
                              Percentage, PerfInfo.CommittedPages, PerfInfo.CommitLimit);    
                }
            }

            if (Percentage <= RtlpDebugPageHeapMinimizeCriteria) {

                if (PageHeapDebugLevel & 1) {
                    DbgPrint ("Normal allocation forced by percentage of availmem \n");    
                }

                HeapRoot->Counter[1]++;

                return RtlAllocateHeap (

                    HeapRoot->NormalHeap,
                    Flags,
                    Size); 
            }
        }

        //
        // Generate a random number to decide if we need to
        // allocate from normal or verifier pool if the
        // `VerifyProbability' variable is 1..100.
        // If the value is zero we will make the decision from where
        // to allocate based on the size of the block requested.
        //

        if (RtlpDebugPageHeapVerifyProbability != 0) {
            
            RtlpDebugPageHeapEnterCritSect( HeapRoot, Flags );
            UNPROTECT_HEAP_STRUCTURES( HeapRoot );
            Random = RtlRandom (& (HeapRoot->Seed));
            PROTECT_HEAP_STRUCTURES( HeapRoot );
            RtlpDebugPageHeapLeaveCritSect( HeapRoot );

            //
            // With a `VerifyProbability' probability we should allocate in page heap.
            //

            if (PageHeapDebugLevel & 1) {
                DbgPrint ("Random number %u\n", Random % 100);    
            }

            if ((Random % 100) >= RtlpDebugPageHeapVerifyProbability) {

                if (PageHeapDebugLevel & 1) {
                    DbgPrint ("Normal allocation due to random choice \n");    
                }
                
                HeapRoot->Counter[2]++;

                return RtlAllocateHeap (

                    HeapRoot->NormalHeap,
                    Flags,
                    Size); 
            }
        }
        else {

            if (! (Size >= RtlpDebugPageHeapVerifyRangeStart
                && Size <= RtlpDebugPageHeapVerifyRangeEnd)) {
                
                if (PageHeapDebugLevel & 1) {
                    DbgPrint ("Normal allocation due to the verified range \n");    
                }

                HeapRoot->Counter[3]++;

                return RtlAllocateHeap (

                    HeapRoot->NormalHeap,
                    Flags,
                    Size); 
            }
        }

        //
        // For all the other cases control will just flow and
        // we will allocate from page heap.
        //

        if (PageHeapDebugLevel & 1) {
            DbgPrint ("Verified allocation with minimize memory impact flag on \n");    
        }
        
        HeapRoot->Counter[4]++;
    }

    //
    //  Acquire the heap CritSect and unprotect the structures
    //

    RtlpDebugPageHeapEnterCritSect( HeapRoot, Flags );
    DEBUG_CODE( RtlpDebugPageHeapVerifyIntegrity( HeapRoot ));
    UNPROTECT_HEAP_STRUCTURES( HeapRoot );

    pReturn = NULL;

    //
    //  Validate requested size so we don't overflow
    //  while rounding up size computations.  We do this
    //  after we've acquired the critsect so we can still
    //  catch serialization problems.
    //

    if ( Size > 0x7FFF0000 ) {
        OUT_OF_VM_BREAK( Flags, "PAGEHEAP: Invalid allocation size\n" );
        goto EXIT;
        }

    //
    //  Determine number of pages needed for READWRITE portion
    //  of allocation and add an extra page for the NO_ACCESS
    //  memory beyond the READWRITE page(s).
    //

    nBytesAccess  = ROUNDUP2( Size, PAGE_SIZE );
    nBytesAllocate = nBytesAccess + PAGE_SIZE;

    //
    //  RtlpDebugPageHeapFindAvailableMem will first attempt to satisfy
    //  the request from memory on the Available list.  If that fails,
    //  it will coalesce some of the Free list memory into the Available
    //  list and try again.  If that still fails, new VM is allocated and
    //  added to the Available list.  If that fails, the function will
    //  finally give up and return NULL.
    //

    pAvailNode = RtlpDebugPageHeapFindAvailableMem(
                     HeapRoot,
                     nBytesAllocate,
                     &pPrevAvailNode,
                     TRUE
                     );

    if ( pAvailNode == NULL ) {
        OUT_OF_VM_BREAK( Flags, "PAGEHEAP: Unable to allocate virtual memory\n" );
        goto EXIT;
        }

    //
    //  Now can't call AllocateNode until pAvailNode is
    //  adjusted and/or removed from Avail list since AllocateNode
    //  might adjust the Avail list.
    //

    pVirtual = pAvailNode->pVirtualBlock;

    if ( nBytesAccess > 0 ) {

        if ((HeapRoot->ExtraFlags & PAGE_HEAP_CATCH_BACKWARD_OVERRUNS)) {
            
            if ( ! RtlpDebugPageHeapProtectVM( (PUCHAR)pVirtual + PAGE_SIZE, nBytesAccess, PAGE_READWRITE )) {
                goto EXIT;
            }
        }
        else {

            if ( ! RtlpDebugPageHeapProtectVM( pVirtual, nBytesAccess, PAGE_READWRITE )) {
                goto EXIT;
            }
        }
    }

    //
    //  pAvailNode (still on avail list) points to block large enough
    //  to satisfy request, but it might be large enough to split
    //  into two blocks -- one for request, remainder leave on
    //  avail list.
    //

    if ( pAvailNode->nVirtualBlockSize > nBytesAllocate ) {

        //
        //  Adjust pVirtualBlock and nVirtualBlock size of existing
        //  node in avail list.  The node will still be in correct
        //  address space order on the avail list.  This saves having
        //  to remove and then re-add node to avail list.  Note since
        //  we're changing sizes directly, we need to adjust the
        //  avail and busy list counters manually.
        //
        //  Note: since we're leaving at least one page on the
        //  available list, we are guaranteed that AllocateNode
        //  will not fail.
        //

        pAvailNode->pVirtualBlock                    += nBytesAllocate;
        pAvailNode->nVirtualBlockSize                -= nBytesAllocate;
        HeapRoot->nAvailableAllocationBytesCommitted -= nBytesAllocate;

        pBusyNode = RtlpDebugPageHeapAllocateNode( HeapRoot );

        DEBUG_ASSERT( pBusyNode != NULL );

        pBusyNode->pVirtualBlock     = pVirtual;
        pBusyNode->nVirtualBlockSize = nBytesAllocate;

        }

    else {

        //
        //  Entire avail block is needed, so simply remove it from avail list.
        //

        RtlpDebugPageHeapRemoveFromAvailableList( HeapRoot, pAvailNode, pPrevAvailNode );

        pBusyNode = pAvailNode;

        }

    //
    //  Now pBusyNode points to our committed virtual block.
    //

    if ( HeapRoot->HeapFlags & HEAP_NO_ALIGNMENT )
        nActual = Size;
    else
        nActual = ROUNDUP2( Size, USER_ALIGNMENT );

    pBusyNode->nVirtualAccessSize = nBytesAccess;
    pBusyNode->nUserRequestedSize = Size;
    pBusyNode->nUserActualSize    = nActual;
    
    if ((HeapRoot->ExtraFlags & PAGE_HEAP_CATCH_BACKWARD_OVERRUNS)) {
        
        pBusyNode->pUserAllocation    = pBusyNode->pVirtualBlock
                                      + PAGE_SIZE;
    }
    else {

        pBusyNode->pUserAllocation    = pBusyNode->pVirtualBlock
                                      + pBusyNode->nVirtualAccessSize
                                      - nActual;
    }
    
    pBusyNode->UserValue          = NULL;
    pBusyNode->UserFlags          = Flags & HEAP_SETTABLE_USER_FLAGS;

#if DPH_CAPTURE_STACK_TRACE

    //
    //  RtlpDebugPageHeapAllocate gets called from RtlDebugAllocateHeap,
    //  which gets called from RtlAllocateHeapSlowly, which gets called
    //  from RtlAllocateHeap.  To keep from wasting lots of stack trace
    //  storage, we'll skip the bottom 3 entries, leaving RtlAllocateHeap
    //  as the first recorded entry.
    //

    if (HeapRoot->ExtraFlags & PAGE_HEAP_COLLECT_STACK_TRACES) {
        pBusyNode->pStackTrace = RtlpDebugPageHeapCaptureAndStoreStackTrace( HeapRoot, 3 );
    }
    else {
        pBusyNode->pStackTrace = NULL;
    }

    if ( pBusyNode->pStackTrace ) {
         pBusyNode->pStackTrace->BusyCount += 1;
         pBusyNode->pStackTrace->BusyBytes += pBusyNode->nUserRequestedSize;
         }

#endif

    RtlpDebugPageHeapPlaceOnBusyList( HeapRoot, pBusyNode );

    pReturn = pBusyNode->pUserAllocation;

    //
    //  For requests the specify HEAP_ZERO_MEMORY, we'll fill the
    //  user-requested portion of the block with zeros, but the
    //  16 bytes (HEAD_FILL_SIZE) before the block and the odd
    //  alignment bytes beyond the requested size up to the end of
    //  the page are filled with 0xEEEEEEEE.  For requests that
    //  don't specify HEAP_ZERO_MEMORY, we fill the whole request
    //  including the 16 bytes before the block and the alignment
    //  bytes beyond the block with 0xEEEEEEEE.
    //

    if ((HeapRoot->ExtraFlags & PAGE_HEAP_CATCH_BACKWARD_OVERRUNS)) {
    
        if ( Flags & HEAP_ZERO_MEMORY ) {
            RtlZeroMemory( pBusyNode->pUserAllocation, Size );
        }
    }
    else {

        pBlockHeader = pBusyNode->pUserAllocation - HEAD_FILL_SIZE;

        if ( pBlockHeader < pBusyNode->pVirtualBlock )
            pBlockHeader = pBusyNode->pVirtualBlock;

        if ( Flags & HEAP_ZERO_MEMORY ) {

            RtlFillMemory( pBlockHeader,
                           pBusyNode->pUserAllocation - pBlockHeader,
                           FILL_BYTE );

            RtlZeroMemory( pBusyNode->pUserAllocation, Size );

            RtlFillMemory( pBusyNode->pUserAllocation + Size,
                           nActual - Size,
                           FILL_BYTE );
            }
        else {

            RtlFillMemory( pBlockHeader,
                           pBusyNode->pUserAllocation + nActual - pBlockHeader,
                           FILL_BYTE );

            }
    }

EXIT:

    PROTECT_HEAP_STRUCTURES( HeapRoot );
    DEBUG_CODE( RtlpDebugPageHeapVerifyIntegrity( HeapRoot ));
    RtlpDebugPageHeapLeaveCritSect( HeapRoot );

    if ( pReturn == NULL ) {
        IF_GENERATE_EXCEPTION( Flags, STATUS_NO_MEMORY );
        }

    return pReturn;

    }


BOOLEAN
RtlpDebugPageHeapFree(
    IN PVOID HeapHandle,
    IN ULONG Flags,
    IN PVOID Address
    )
    {

    PDPH_HEAP_ROOT       HeapRoot;
    PDPH_HEAP_ALLOCATION Node, Prev;
    BOOLEAN              Success;
    PCH                  p;

    HeapRoot = RtlpDebugPageHeapPointerFromHandle( HeapHandle );
    if ( HeapRoot == NULL )
        return FALSE;

    if ( Address == NULL )
        return TRUE;            // for C++ apps that delete NULL

    Flags |= HeapRoot->HeapFlags;

    RtlpDebugPageHeapEnterCritSect( HeapRoot, Flags );
    DEBUG_CODE( RtlpDebugPageHeapVerifyIntegrity( HeapRoot ));
    UNPROTECT_HEAP_STRUCTURES( HeapRoot );

    Success = FALSE;

    Node = RtlpDebugPageHeapFindBusyMem( HeapRoot, Address, &Prev );

    if ( Node == NULL ) {

        //
        // No wonder we did not find the block in the page heap
        // structures because the block was probably allocated
        // from the normal heap. Or there is a real bug.
        //

        if ((HeapRoot->ExtraFlags & PAGE_HEAP_MINIMIZE_MEMORY_IMPACT)) {
            
            RETAIL_ASSERT (HeapRoot->NormalHeap);
                                                        
            Success = RtlFreeHeap (

                HeapRoot->NormalHeap,
                Flags,
                Address);

            if (Success == FALSE) {
                RtlpDebugPageHeapBreak( "PAGEHEAP: Normal heap free operation failed\n" );
            }
        }
        else {
            RtlpDebugPageHeapBreak( "PAGEHEAP: Attempt to reference block which is not allocated\n" );
        }
    
        //
        // Jump to end where we have to release critical section and
        // protect back heap structures.
        //

        goto EXIT;
    }

    //
    //  If tail was allocated, make sure filler not overwritten
    //

    if ((HeapRoot->ExtraFlags & PAGE_HEAP_CATCH_BACKWARD_OVERRUNS)) {
    
        if ( Node->nVirtualAccessSize > 0 ) {
            RtlpDebugPageHeapProtectVM( Node->pVirtualBlock + PAGE_SIZE,
                                        Node->nVirtualAccessSize,
                                        PAGE_NOACCESS );
            }
    }
    else {

        if ( Node->nUserActualSize > Node->nUserRequestedSize ) {
            RtlpDebugPageHeapDetectFillCorruption( Node );
            }

        if ( Node->nVirtualAccessSize > 0 ) {
            RtlpDebugPageHeapProtectVM( Node->pVirtualBlock,
                                        Node->nVirtualAccessSize,
                                        PAGE_NOACCESS );
            }
    }

    RtlpDebugPageHeapRemoveFromBusyList( HeapRoot, Node, Prev );

    RtlpDebugPageHeapPlaceOnFreeList( HeapRoot, Node );

#if DPH_CAPTURE_STACK_TRACE

    //
    //  RtlpDebugPageHeapFree gets called from RtlDebugFreeHeap, which
    //  gets called from RtlFreeHeapSlowly, which gets called from
    //  RtlFreeHeap.  To keep from wasting lots of stack trace storage,
    //  we'll skip the bottom 3 entries, leaving RtlFreeHeap as the
    //  first recorded entry.
    //

    if ( Node->pStackTrace ) {
         if ( Node->pStackTrace->BusyCount > 0 ) {
              Node->pStackTrace->BusyCount -= 1;
              Node->pStackTrace->BusyBytes -= Node->nUserRequestedSize;
              }
         }

    if (HeapRoot->ExtraFlags & PAGE_HEAP_COLLECT_STACK_TRACES) {
        Node->pStackTrace = RtlpDebugPageHeapCaptureAndStoreStackTrace( HeapRoot, 3 );
    }
    else {
        Node->pStackTrace = NULL;
    }

#endif

    Success = TRUE;

EXIT:

    PROTECT_HEAP_STRUCTURES( HeapRoot );
    DEBUG_CODE( RtlpDebugPageHeapVerifyIntegrity( HeapRoot ));
    RtlpDebugPageHeapLeaveCritSect( HeapRoot );

    if ( ! Success ) {
        IF_GENERATE_EXCEPTION( Flags, STATUS_ACCESS_VIOLATION );
        }

    return Success;
    }


PVOID
RtlpDebugPageHeapReAllocate(
    IN PVOID  HeapHandle,
    IN ULONG  Flags,
    IN PVOID  Address,
    IN SIZE_T Size
    )
    {
    PDPH_HEAP_ROOT       HeapRoot;
    PDPH_HEAP_ALLOCATION OldNode, OldPrev, NewNode;
    PVOID                NewAddress;
    PUCHAR               p;
    SIZE_T               CopyDataSize;
    ULONG                SaveFlags;

    HeapRoot = RtlpDebugPageHeapPointerFromHandle( HeapHandle );
    if ( HeapRoot == NULL )
        return NULL;

    Flags |= HeapRoot->HeapFlags;

    RtlpDebugPageHeapEnterCritSect( HeapRoot, Flags );
    DEBUG_CODE( RtlpDebugPageHeapVerifyIntegrity( HeapRoot ));
    UNPROTECT_HEAP_STRUCTURES( HeapRoot );

    NewAddress = NULL;

    //
    //  Check Flags for non-moveable reallocation and fail it
    //  unconditionally.  Apps that specify this flag should be
    //  prepared to deal with failure anyway.
    //

    if ( Flags & HEAP_REALLOC_IN_PLACE_ONLY ) {
        goto EXIT;
        }

    //
    //  Validate requested size so we don't overflow
    //  while rounding up size computations.  We do this
    //  after we've acquired the critsect so we can still
    //  catch serialization problems.
    //

    if ( Size > 0x7FFF0000 ) {
        OUT_OF_VM_BREAK( Flags, "PAGEHEAP: Invalid allocation size\n" );
        goto EXIT;
        }

    OldNode = RtlpDebugPageHeapFindBusyMem( HeapRoot, Address, &OldPrev );

    if ( OldNode == NULL ) {

        //
        // No wonder we did not find the block in the page heap
        // structures because the block was probably allocated
        // from the normal heap. Or there is a real bug.
        //

        if ((HeapRoot->ExtraFlags & PAGE_HEAP_MINIMIZE_MEMORY_IMPACT)) {
                                                        
            RETAIL_ASSERT (HeapRoot->NormalHeap);

            NewAddress = RtlReAllocateHeap (

                HeapRoot->NormalHeap,
                Flags,
                Address,
                Size);

            if (NewAddress == NULL) {
                RtlpDebugPageHeapBreak( "PAGEHEAP: Normal heap realloc operation failed\n" );
            }
        }
        else {
            RtlpDebugPageHeapBreak( "PAGEHEAP: Attempt to reference block which is not allocated\n" );
        }
    
        //
        // Jump to end where we have to release critical section and
        // protect back heap structures.
        //

        goto EXIT;
    }

    //
    //  If tail was allocated, make sure filler not overwritten
    //

    if ((HeapRoot->ExtraFlags & PAGE_HEAP_CATCH_BACKWARD_OVERRUNS)) {

        // nothing
    }
    else {

        if ( OldNode->nUserActualSize > OldNode->nUserRequestedSize ) {
            RtlpDebugPageHeapDetectFillCorruption( OldNode );
        }
    }

    //
    //  Before allocating a new block, remove the old block from
    //  the busy list.  When we allocate the new block, the busy
    //  list pointers will change, possibly leaving our acquired
    //  Prev pointer invalid.
    //

    RtlpDebugPageHeapRemoveFromBusyList( HeapRoot, OldNode, OldPrev );

    //
    //  Allocate new memory for new requested size.  Use try/except
    //  to trap exception if Flags caused out-of-memory exception.
    //

    try {

        //
        // In case we have flags that can force allocations into normal heap
        // we have to temporarily disable them so that we force a
        // page heap allocation.
        //

        SaveFlags = 0;

        if ((HeapRoot->ExtraFlags & PAGE_HEAP_MINIMIZE_MEMORY_IMPACT)) {
                    
            SaveFlags = HeapRoot->ExtraFlags;
            HeapRoot->ExtraFlags = PAGE_HEAP_ENABLE_PAGE_HEAP;

            if ((SaveFlags & PAGE_HEAP_COLLECT_STACK_TRACES)) {
                HeapRoot->ExtraFlags |= PAGE_HEAP_COLLECT_STACK_TRACES;
            }
        }

        NewAddress = RtlpDebugPageHeapAllocate( HeapHandle, Flags, Size );
    
        if ((SaveFlags & PAGE_HEAP_MINIMIZE_MEMORY_IMPACT)) {
                    
            HeapRoot->ExtraFlags = SaveFlags;
        }
    }
    except( EXCEPTION_EXECUTE_HANDLER ) {
    }

    if ( NewAddress ) {

        CopyDataSize = OldNode->nUserRequestedSize;

        if ( CopyDataSize > Size ) {
             CopyDataSize = Size;
             }

        if ( CopyDataSize > 0 ) {

            RtlCopyMemory(
                NewAddress,
                Address,
                CopyDataSize
                );
            }

        NewNode = RtlpDebugPageHeapFindBusyMem( HeapRoot, NewAddress, NULL );

        //
        // This block could not be in normal heap therefore from this
        // respect the call above should always succeed.
        //

        if (PageHeapDebugLevel & 2) {
            RETAIL_ASSERT (NewNode != NULL);
        }

        DEBUG_ASSERT( NewNode != NULL );

        NewNode->UserValue = OldNode->UserValue;
        NewNode->UserFlags = ( Flags & HEAP_SETTABLE_USER_FLAGS ) ?
                             ( Flags & HEAP_SETTABLE_USER_FLAGS ) :
                             OldNode->UserFlags;

        if ( OldNode->nVirtualAccessSize > 0 ) {
            RtlpDebugPageHeapProtectVM( OldNode->pVirtualBlock,
                                        OldNode->nVirtualAccessSize,
                                        PAGE_NOACCESS );
            }

        RtlpDebugPageHeapPlaceOnFreeList( HeapRoot, OldNode );

#if DPH_CAPTURE_STACK_TRACE

        //
        //  RtlpDebugPageHeapReAllocate gets called from RtlDebugReAllocateHeap,
        //  which gets called from RtlReAllocateHeap.  To keep from wasting
        //  lots of stack trace storage, we'll skip the bottom 2 entries,
        //  leaving RtlReAllocateHeap as the first recorded entry in the
        //  freed stack trace.
        //

        if ( OldNode->pStackTrace ) {
            if ( OldNode->pStackTrace->BusyCount > 0 ) {
                 OldNode->pStackTrace->BusyCount -= 1;
                 OldNode->pStackTrace->BusyBytes -= OldNode->nUserRequestedSize;
                 }
            }

        if (HeapRoot->ExtraFlags & PAGE_HEAP_COLLECT_STACK_TRACES) {
            OldNode->pStackTrace = RtlpDebugPageHeapCaptureAndStoreStackTrace( HeapRoot, 2 );
        }
        else {
            OldNode->pStackTrace = NULL;
        }

#endif
        }

    else {

        //
        //  Failed to allocate a new block.  Return old block to busy list.
        //

        RtlpDebugPageHeapPlaceOnBusyList( HeapRoot, OldNode );

        }

EXIT:

    PROTECT_HEAP_STRUCTURES( HeapRoot );
    DEBUG_CODE( RtlpDebugPageHeapVerifyIntegrity( HeapRoot ));
    RtlpDebugPageHeapLeaveCritSect( HeapRoot );

    if ( NewAddress == NULL ) {
        IF_GENERATE_EXCEPTION( Flags, STATUS_NO_MEMORY );
        }

    return NewAddress;
    }


#if (( DPH_CAPTURE_STACK_TRACE ) && ( i386 ) && ( FPO ))
#pragma optimize( "", on )      // restore original optimizations
#endif


PVOID
RtlpDebugPageHeapDestroy(
    IN PVOID HeapHandle
    )
    {
    PDPH_HEAP_ROOT       HeapRoot;
    PDPH_HEAP_ROOT       PrevHeapRoot;
    PDPH_HEAP_ROOT       NextHeapRoot;
    PDPH_HEAP_ALLOCATION Node;
    PDPH_HEAP_ALLOCATION Next;
    ULONG                Flags;
    PUCHAR               p;

    if ( HeapHandle == RtlProcessHeap() ) {
        RtlpDebugPageHeapBreak( "PAGEHEAP: Attempt to destroy process heap\n" );
        return NULL;
        }

    HeapRoot = RtlpDebugPageHeapPointerFromHandle( HeapHandle );
    if ( HeapRoot == NULL )
        return NULL;

    Flags = HeapRoot->HeapFlags | HEAP_NO_SERIALIZE;

    RtlpDebugPageHeapEnterCritSect( HeapRoot, Flags );
    DEBUG_CODE( RtlpDebugPageHeapVerifyIntegrity( HeapRoot ));
    UNPROTECT_HEAP_STRUCTURES( HeapRoot );

    //
    //  Walk all busy allocations and check for tail fill corruption
    //

    Node = HeapRoot->pBusyAllocationListHead;

    while ( Node ) {

        if ( Node->nUserActualSize > Node->nUserRequestedSize ) {
            RtlpDebugPageHeapDetectFillCorruption( Node );
            }

        Node = Node->pNextAlloc;
        }

    //
    //  Remove this heap entry from the process heap linked list.
    //

    RtlEnterCriticalSection( &RtlpDebugPageHeapListCritSect );

    if ( HeapRoot->pPrevHeapRoot ) {
         HeapRoot->pPrevHeapRoot->pNextHeapRoot = HeapRoot->pNextHeapRoot;
         }
    else {
         RtlpDebugPageHeapListHead = HeapRoot->pNextHeapRoot;
         }

    if ( HeapRoot->pNextHeapRoot ) {
         HeapRoot->pNextHeapRoot->pPrevHeapRoot = HeapRoot->pPrevHeapRoot;
         }
    else {
         RtlpDebugPageHeapListTail = HeapRoot->pPrevHeapRoot;
         }

    RtlpDebugPageHeapListCount--;

    RtlLeaveCriticalSection( &RtlpDebugPageHeapListCritSect );


    //
    //  Must release critical section before deleting it; otherwise,
    //  checked build Teb->CountOfOwnedCriticalSections gets out of sync.
    //

    RtlLeaveCriticalSection( HeapRoot->HeapCritSect );
    RtlDeleteCriticalSection( HeapRoot->HeapCritSect );

    //
    //  This is weird.  A virtual block might contain storage for
    //  one of the nodes necessary to walk this list.  In fact,
    //  we're guaranteed that the root node contains at least one
    //  virtual alloc node.
    //
    //  Each time we alloc new VM, we make that the head of the
    //  of the VM list, like a LIFO structure.  I think we're ok
    //  because no VM list node should be on a subsequently alloc'd
    //  VM -- only a VM list entry might be on its own memory (as
    //  is the case for the root node).  We read pNode->pNextAlloc
    //  before releasing the VM in case pNode existed on that VM.
    //  I think this is safe -- as long as the VM list is LIFO and
    //  we don't do any list reorganization.
    //

    Node = HeapRoot->pVirtualStorageListHead;

    while ( Node ) {
        Next = Node->pNextAlloc;
        if ( ! RtlpDebugPageHeapReleaseVM( Node->pVirtualBlock )) {
            RtlpDebugPageHeapBreak( "PAGEHEAP: Unable to release virtual memory\n" );
            }
        Node = Next;
        }

    //
    //  That's it.  All the VM, including the root node, should now
    //  be released.  RtlDestroyHeap always returns NULL.
    //

    return NULL;

    }


SIZE_T
RtlpDebugPageHeapSize(
    IN PVOID HeapHandle,
    IN ULONG Flags,
    IN PVOID Address
    )
    {
    PDPH_HEAP_ROOT       HeapRoot;
    PDPH_HEAP_ALLOCATION Node;
    SIZE_T               Size;

    Size = 0xFFFFFFFF;

    HeapRoot = RtlpDebugPageHeapPointerFromHandle( HeapHandle );
    if ( HeapRoot == NULL ) {
        return Size;
        }

    Flags |= HeapRoot->HeapFlags;

    RtlpDebugPageHeapEnterCritSect( HeapRoot, Flags );
    UNPROTECT_HEAP_STRUCTURES( HeapRoot );

    Node = RtlpDebugPageHeapFindBusyMem( HeapRoot, Address, NULL );

    if ( Node == NULL ) {

        //
        // No wonder we did not find the block in the page heap
        // structures because the block was probably allocated
        // from the normal heap. Or there is a real bug.
        //

        if ((HeapRoot->ExtraFlags & PAGE_HEAP_MINIMIZE_MEMORY_IMPACT)) {
                                                        
            RETAIL_ASSERT (HeapRoot->NormalHeap);

            Size = RtlSizeHeap (

                HeapRoot->NormalHeap,
                Flags,
                Address);

            // bugbug: should we use -1?
            if (Size == 0xFFFFFFFF) {
                RtlpDebugPageHeapBreak( "PAGEHEAP: Normal heap size operation failed\n" );
            }
        }
        else {
            RtlpDebugPageHeapBreak( "PAGEHEAP: Attempt to reference block which is not allocated\n" );
        }
    
        //
        // Jump to end where we have to release critical section and
        // protect back heap structures.
        //

        goto EXIT;
    }
    else {
        Size = Node->nUserRequestedSize;
    }

EXIT:
    PROTECT_HEAP_STRUCTURES( HeapRoot );
    RtlpDebugPageHeapLeaveCritSect( HeapRoot );

    // bugbug: should we use -1?
    if ( Size == 0xFFFFFFFF ) {
        IF_GENERATE_EXCEPTION( Flags, STATUS_ACCESS_VIOLATION );
        }

    return Size;
    }


ULONG
RtlpDebugPageHeapGetProcessHeaps(
    ULONG NumberOfHeaps,
    PVOID *ProcessHeaps
    )
    {
    PDPH_HEAP_ROOT HeapRoot;
    ULONG          Count;

    //
    //  Although we'd expect GetProcessHeaps never to be called
    //  before at least the very first heap creation, we should
    //  still be safe and initialize the critical section if
    //  necessary.
    //

    if ( ! RtlpDebugPageHeapListHasBeenInitialized ) {
        RtlpDebugPageHeapListHasBeenInitialized = TRUE;
        RtlInitializeCriticalSection( &RtlpDebugPageHeapListCritSect );
        }

    RtlEnterCriticalSection( &RtlpDebugPageHeapListCritSect );

    if ( RtlpDebugPageHeapListCount <= NumberOfHeaps ) {

        for ( HeapRoot  = RtlpDebugPageHeapListHead, Count = 0;
              HeapRoot != NULL;
              HeapRoot  = HeapRoot->pNextHeapRoot, Count++ ) {

            *ProcessHeaps++ = HEAP_HANDLE_FROM_ROOT( HeapRoot );
            }

        if ( Count != RtlpDebugPageHeapListCount ) {
            RtlpDebugPageHeapBreak( "PAGEHEAP: BUG: process heap list count wrong\n" );
            }

        }
    else {

        //
        //  User's buffer is too small.  Return number of entries
        //  necessary for subsequent call to succeed.  Buffer
        //  remains untouched.
        //

        Count = RtlpDebugPageHeapListCount;

        }

    RtlLeaveCriticalSection( &RtlpDebugPageHeapListCritSect );

    return Count;
    }


ULONG
RtlpDebugPageHeapCompact(
    IN PVOID HeapHandle,
    IN ULONG Flags
    )
    {
    PDPH_HEAP_ROOT HeapRoot;

    HeapRoot = RtlpDebugPageHeapPointerFromHandle( HeapHandle );
    if ( HeapRoot == NULL )
        return 0;

    Flags |= HeapRoot->HeapFlags;

    RtlpDebugPageHeapEnterCritSect( HeapRoot, Flags );

    //
    //  Don't do anything, but we did want to acquire the critsect
    //  in case this was called with HEAP_NO_SERIALIZE while another
    //  thread is in the heap code.
    //

    RtlpDebugPageHeapLeaveCritSect( HeapRoot );

    return 0;

    }



BOOLEAN
RtlpDebugPageHeapValidate(
    IN PVOID HeapHandle,
    IN ULONG Flags,
    IN PVOID Address
    )
    {
    PDPH_HEAP_ROOT       HeapRoot;
    PDPH_HEAP_ALLOCATION Node;
    BOOLEAN Result = FALSE;

    HeapRoot = RtlpDebugPageHeapPointerFromHandle( HeapHandle );
    if ( HeapRoot == NULL )
        return FALSE;

    Flags |= HeapRoot->HeapFlags;

    RtlpDebugPageHeapEnterCritSect( HeapRoot, Flags );
    DEBUG_CODE( RtlpDebugPageHeapVerifyIntegrity( HeapRoot ));
    UNPROTECT_HEAP_STRUCTURES( HeapRoot );

    Node = Address ? RtlpDebugPageHeapFindBusyMem( HeapRoot, Address, NULL ) : NULL;

    if (Node == NULL) {
        
        if ((HeapRoot->ExtraFlags & PAGE_HEAP_MINIMIZE_MEMORY_IMPACT)) {
                                                        
            RETAIL_ASSERT (HeapRoot->NormalHeap);

            Result = RtlValidateHeap (

                HeapRoot->NormalHeap,
                Flags,
                Address);
        }
    }

    PROTECT_HEAP_STRUCTURES( HeapRoot );
    RtlpDebugPageHeapLeaveCritSect( HeapRoot );

    if (Address) {
        if (Node) {
            return TRUE;
        }
        else {
            return Result;
        }
    }
    else {
        return TRUE;
    }
}


NTSTATUS
RtlpDebugPageHeapWalk(
    IN PVOID HeapHandle,
    IN OUT PRTL_HEAP_WALK_ENTRY Entry
    )
    {
    return STATUS_NOT_IMPLEMENTED;
    }


BOOLEAN
RtlpDebugPageHeapLock(
    IN PVOID HeapHandle
    )
    {
    PDPH_HEAP_ROOT HeapRoot;

    HeapRoot = RtlpDebugPageHeapPointerFromHandle( HeapHandle );
    if ( HeapRoot == NULL )
        return FALSE;

    RtlpDebugPageHeapEnterCritSect( HeapRoot, HeapRoot->HeapFlags );

    return TRUE;
    }


BOOLEAN
RtlpDebugPageHeapUnlock(
    IN PVOID HeapHandle
    )
    {
    PDPH_HEAP_ROOT HeapRoot;

    HeapRoot = RtlpDebugPageHeapPointerFromHandle( HeapHandle );
    if ( HeapRoot == NULL )
        return FALSE;

    RtlpDebugPageHeapLeaveCritSect( HeapRoot );

    return TRUE;
    }


BOOLEAN
RtlpDebugPageHeapSetUserValue(
    IN PVOID HeapHandle,
    IN ULONG Flags,
    IN PVOID Address,
    IN PVOID UserValue
    )
    {
    PDPH_HEAP_ROOT       HeapRoot;
    PDPH_HEAP_ALLOCATION Node;
    BOOLEAN              Success;

    Success = FALSE;

    HeapRoot = RtlpDebugPageHeapPointerFromHandle( HeapHandle );
    if ( HeapRoot == NULL )
        return Success;

    Flags |= HeapRoot->HeapFlags;

    RtlpDebugPageHeapEnterCritSect( HeapRoot, Flags );
    UNPROTECT_HEAP_STRUCTURES( HeapRoot );

    Node = RtlpDebugPageHeapFindBusyMem( HeapRoot, Address, NULL );

    if ( Node == NULL ) {

        //
        // If we cannot find the node in page heap structures it might be
        // because it has been allocated from normal heap.
        //

        if ((HeapRoot->ExtraFlags & PAGE_HEAP_MINIMIZE_MEMORY_IMPACT)) {

            Success = RtlSetUserValueHeap (
                HeapRoot->NormalHeap,
                Flags,
                Address,
                UserValue);

            goto EXIT;
        }
        else {

            RtlpDebugPageHeapBreak( "PAGEHEAP: Attempt to reference block which is not allocated\n" );
        }
    }
    else {
        Node->UserValue = UserValue;
        Success = TRUE;
        }

    EXIT:
    PROTECT_HEAP_STRUCTURES( HeapRoot );
    RtlpDebugPageHeapLeaveCritSect( HeapRoot );

    return Success;
    }


BOOLEAN
RtlpDebugPageHeapGetUserInfo(
    IN  PVOID  HeapHandle,
    IN  ULONG  Flags,
    IN  PVOID  Address,
    OUT PVOID* UserValue,
    OUT PULONG UserFlags
    )
    {
    PDPH_HEAP_ROOT       HeapRoot;
    PDPH_HEAP_ALLOCATION Node;
    BOOLEAN              Success;

    Success = FALSE;

    HeapRoot = RtlpDebugPageHeapPointerFromHandle( HeapHandle );
    if ( HeapRoot == NULL )
        return Success;

    Flags |= HeapRoot->HeapFlags;

    RtlpDebugPageHeapEnterCritSect( HeapRoot, Flags );
    UNPROTECT_HEAP_STRUCTURES( HeapRoot );

    Node = RtlpDebugPageHeapFindBusyMem( HeapRoot, Address, NULL );

    if ( Node == NULL ) {

        //
        // If we cannot find the node in page heap structures it might be
        // because it has been allocated from normal heap.
        //

        if ((HeapRoot->ExtraFlags & PAGE_HEAP_MINIMIZE_MEMORY_IMPACT)) {

            Success = RtlGetUserInfoHeap (

                HeapRoot->NormalHeap,
                Flags,
                Address,
                UserValue,
                UserFlags);

            goto EXIT;
        }
        else {

            RtlpDebugPageHeapBreak( "PAGEHEAP: Attempt to reference block which is not allocated\n" );
        }
    }
    else {
        if ( UserValue != NULL )
            *UserValue = Node->UserValue;
        if ( UserFlags != NULL )
            *UserFlags = Node->UserFlags;
        Success = TRUE;
        }

    EXIT:
    PROTECT_HEAP_STRUCTURES( HeapRoot );
    RtlpDebugPageHeapLeaveCritSect( HeapRoot );

    return Success;
    }


BOOLEAN
RtlpDebugPageHeapSetUserFlags(
    IN PVOID HeapHandle,
    IN ULONG Flags,
    IN PVOID Address,
    IN ULONG UserFlagsReset,
    IN ULONG UserFlagsSet
    )
    {
    PDPH_HEAP_ROOT       HeapRoot;
    PDPH_HEAP_ALLOCATION Node;
    BOOLEAN              Success;

    Success = FALSE;

    HeapRoot = RtlpDebugPageHeapPointerFromHandle( HeapHandle );
    if ( HeapRoot == NULL )
        return Success;

    Flags |= HeapRoot->HeapFlags;

    RtlpDebugPageHeapEnterCritSect( HeapRoot, Flags );
    UNPROTECT_HEAP_STRUCTURES( HeapRoot );

    Node = RtlpDebugPageHeapFindBusyMem( HeapRoot, Address, NULL );

    if ( Node == NULL ) {
        
        //
        // If we cannot find the node in page heap structures it might be
        // because it has been allocated from normal heap.
        //

        if ((HeapRoot->ExtraFlags & PAGE_HEAP_MINIMIZE_MEMORY_IMPACT)) {

            Success = RtlSetUserFlagsHeap (

                HeapRoot->NormalHeap,
                Flags,
                Address,
                UserFlagsReset,
                UserFlagsSet);

            goto EXIT;
        }
        else {

            RtlpDebugPageHeapBreak( "PAGEHEAP: Attempt to reference block which is not allocated\n" );
        }
    }
    else {
        Node->UserFlags &= ~( UserFlagsReset );
        Node->UserFlags |=    UserFlagsSet;
        Success = TRUE;
        }

    EXIT:
    PROTECT_HEAP_STRUCTURES( HeapRoot );
    RtlpDebugPageHeapLeaveCritSect( HeapRoot );

    return Success;
    }


BOOLEAN
RtlpDebugPageHeapSerialize(
    IN PVOID HeapHandle
    )
    {
    PDPH_HEAP_ROOT HeapRoot;

    HeapRoot = RtlpDebugPageHeapPointerFromHandle( HeapHandle );
    if ( HeapRoot == NULL )
        return FALSE;

    RtlpDebugPageHeapEnterCritSect( HeapRoot, 0 );
    UNPROTECT_HEAP_STRUCTURES( HeapRoot );

    HeapRoot->HeapFlags &= ~HEAP_NO_SERIALIZE;

    PROTECT_HEAP_STRUCTURES( HeapRoot );
    RtlpDebugPageHeapLeaveCritSect( HeapRoot );

    return TRUE;
    }


NTSTATUS
RtlpDebugPageHeapExtend(
    IN PVOID  HeapHandle,
    IN ULONG  Flags,
    IN PVOID  Base,
    IN SIZE_T Size
    )
    {
    return STATUS_SUCCESS;
    }


NTSTATUS
RtlpDebugPageHeapZero(
    IN PVOID HeapHandle,
    IN ULONG Flags
    )
    {
    return STATUS_SUCCESS;
    }


NTSTATUS
RtlpDebugPageHeapReset(
    IN PVOID HeapHandle,
    IN ULONG Flags
    )
    {
    return STATUS_SUCCESS;
    }


NTSTATUS
RtlpDebugPageHeapUsage(
    IN PVOID HeapHandle,
    IN ULONG Flags,
    IN OUT PRTL_HEAP_USAGE Usage
    )
    {
    PDPH_HEAP_ROOT HeapRoot;

    //
    //  Partial implementation since this information is kind of meaningless.
    //

    HeapRoot = RtlpDebugPageHeapPointerFromHandle( HeapHandle );
    if ( HeapRoot == NULL )
        return STATUS_INVALID_PARAMETER;

    if ( Usage->Length != sizeof( RTL_HEAP_USAGE ))
        return STATUS_INFO_LENGTH_MISMATCH;

    memset( Usage, 0, sizeof( RTL_HEAP_USAGE ));
    Usage->Length = sizeof( RTL_HEAP_USAGE );

    RtlpDebugPageHeapEnterCritSect( HeapRoot, 0 );
    UNPROTECT_HEAP_STRUCTURES( HeapRoot );

    Usage->BytesAllocated       = HeapRoot->nBusyAllocationBytesAccessible;
    Usage->BytesCommitted       = HeapRoot->nVirtualStorageBytes;
    Usage->BytesReserved        = HeapRoot->nVirtualStorageBytes;
    Usage->BytesReservedMaximum = HeapRoot->nVirtualStorageBytes;

    PROTECT_HEAP_STRUCTURES( HeapRoot );
    RtlpDebugPageHeapLeaveCritSect( HeapRoot );

    return STATUS_SUCCESS;
    }


BOOLEAN
RtlpDebugPageHeapIsLocked(
    IN PVOID HeapHandle
    )
    {
    PDPH_HEAP_ROOT HeapRoot;

    HeapRoot = RtlpDebugPageHeapPointerFromHandle( HeapHandle );
    if ( HeapRoot == NULL )
        return FALSE;

    if ( RtlTryEnterCriticalSection( HeapRoot->HeapCritSect )) {
        RtlLeaveCriticalSection( HeapRoot->HeapCritSect );
        return FALSE;
        }
    else {
        return TRUE;
        }
    }


#endif // DEBUG_PAGE_HEAP
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\rtl\heappriv.h ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    heappriv.h

Abstract:

    Private include file used by heap allocator (heap.c, heapdll.c and
    heapdbg.c)

Author:

    Steve Wood (stevewo) 25-Oct-1994

Revision History:

--*/

#ifndef _RTL_HEAP_PRIVATE_
#define _RTL_HEAP_PRIVATE_

#include "heappage.h"

//
//  Disable FPO optimization so even retail builds get somewhat reasonable
//  stack backtraces
//

#if i386
// #pragma optimize("y",off)
#endif

#if DBG
#define HEAPASSERT(exp) if (!(exp)) RtlAssert( #exp, __FILE__, __LINE__, NULL )
#else
#define HEAPASSERT(exp)
#endif

//
//  This variable contains the fill pattern used for heap tail checking
//

UCHAR CheckHeapFillPattern[ CHECK_HEAP_TAIL_SIZE ];


//
//  Here are the locking routines for the heap (kernel and user)
//

//
//  User mode heap uses the critical section package for locking
//

#define RtlInitializeLockRoutine(L) (RtlInitializeCriticalSection((PRTL_CRITICAL_SECTION)(L)), STATUS_SUCCESS)
#define RtlAcquireLockRoutine(L)    RtlEnterCriticalSection((PRTL_CRITICAL_SECTION)(L))
#define RtlReleaseLockRoutine(L)    RtlLeaveCriticalSection((PRTL_CRITICAL_SECTION)(L))
#define RtlDeleteLockRoutine(L)     RtlDeleteCriticalSection((PRTL_CRITICAL_SECTION)(L))
#define RtlOkayToLockRoutine(L)     NtdllOkayToLockRoutine((PVOID)(L))


//
//  Here are some debugging macros for the heap
//

#ifdef NTOS_KERNEL_RUNTIME

#define HEAP_DEBUG_FLAGS   0
#define DEBUG_HEAP(F)      FALSE
#define SET_LAST_STATUS(S) NOTHING;

#else // #ifdef NTOS_KERNEL_ROUTINE

#define HEAP_DEBUG_FLAGS   (HEAP_VALIDATE_PARAMETERS_ENABLED | \
                            HEAP_VALIDATE_ALL_ENABLED        | \
                            HEAP_CAPTURE_STACK_BACKTRACES    | \
                            HEAP_CREATE_ENABLE_TRACING       | \
                            HEAP_FLAG_PAGE_ALLOCS)
#define DEBUG_HEAP(F)      ((F & HEAP_DEBUG_FLAGS) && !(F & HEAP_SKIP_VALIDATION_CHECKS))
#define SET_LAST_STATUS(S) {NtCurrentTeb()->LastErrorValue = RtlNtStatusToDosError( NtCurrentTeb()->LastStatusValue = (ULONG)(S) );}

#endif // #ifdef NTOS_KERNEL_RUNTIME


//
//  Here are the macros used for debug printing and breakpoints
//

#if DBG

#ifdef NTOS_KERNEL_RUNTIME

#define HeapDebugPrint( _x_ ) {DbgPrint _x_;}

#define HeapDebugBreak( _x_ ) {if (KdDebuggerEnabled) DbgBreakPoint();}

#else // #ifdef NTOS_KERNEL_ROUTINE

#define HeapDebugPrint( _x_ )                                   \
{                                                               \
    PLIST_ENTRY _Module;                                        \
    PLDR_DATA_TABLE_ENTRY _Entry;                               \
                                                                \
    _Module = NtCurrentPeb()->Ldr->InLoadOrderModuleList.Flink; \
    _Entry = CONTAINING_RECORD( _Module,                        \
                                LDR_DATA_TABLE_ENTRY,           \
                                InLoadOrderLinks);              \
    DbgPrint("HEAP[%wZ]: ", &_Entry->BaseDllName);              \
    DbgPrint _x_;                                               \
}

#define HeapDebugBreak( _x_ )                    \
{                                                \
    VOID RtlpBreakPointHeap( PVOID BadAddress ); \
                                                 \
    RtlpBreakPointHeap( (_x_) );                 \
}

#endif // #ifdef NTOS_KERNEL_RUNTIME

#else  // DBG

#define HeapDebugPrint( _x_ )

#define HeapDebugBreak( _x_ )

#endif // DBG


//
//  Implemented in heap.c
//

BOOLEAN
RtlpInitializeHeapSegment (
    IN PHEAP Heap,
    IN PHEAP_SEGMENT Segment,
    IN UCHAR SegmentIndex,
    IN ULONG Flags,
    IN PVOID BaseAddress,
    IN PVOID UnCommittedAddress,
    IN PVOID CommitLimitAddress
    );

PHEAP_FREE_ENTRY
RtlpCoalesceFreeBlocks (
    IN PHEAP Heap,
    IN PHEAP_FREE_ENTRY FreeBlock,
    IN OUT PSIZE_T FreeSize,
    IN BOOLEAN RemoveFromFreeList
    );

VOID
RtlpDeCommitFreeBlock (
    IN PHEAP Heap,
    IN PHEAP_FREE_ENTRY FreeBlock,
    IN SIZE_T FreeSize
    );

VOID
RtlpInsertFreeBlock (
    IN PHEAP Heap,
    IN PHEAP_FREE_ENTRY FreeBlock,
    IN SIZE_T FreeSize
    );

PHEAP_FREE_ENTRY
RtlpFindAndCommitPages (
    IN PHEAP Heap,
    IN PHEAP_SEGMENT Segment,
    IN OUT PSIZE_T Size,
    IN PVOID AddressWanted OPTIONAL
    );

PVOID
RtlAllocateHeapSlowly (
    IN PVOID HeapHandle,
    IN ULONG Flags,
    IN SIZE_T Size
    );

BOOLEAN
RtlFreeHeapSlowly (
    IN PVOID HeapHandle,
    IN ULONG Flags,
    IN PVOID BaseAddress
    );

SIZE_T
RtlpGetSizeOfBigBlock (
    IN PHEAP_ENTRY BusyBlock
    );

PHEAP_ENTRY_EXTRA
RtlpGetExtraStuffPointer (
    PHEAP_ENTRY BusyBlock
    );

BOOLEAN
RtlpCheckBusyBlockTail (
    IN PHEAP_ENTRY BusyBlock
    );


//
//  Implemented in heapdll.c
//

VOID
RtlpAddHeapToProcessList (
    IN PHEAP Heap
    );

VOID
RtlpRemoveHeapFromProcessList (
    IN PHEAP Heap
    );

PHEAP_FREE_ENTRY
RtlpCoalesceHeap (
    IN PHEAP Heap
    );

BOOLEAN
RtlpCheckHeapSignature (
    IN PHEAP Heap,
    IN PCHAR Caller
    );


//
//  Implemented in heapdbg.c
//

BOOLEAN
RtlpValidateHeapEntry (
    IN PHEAP Heap,
    IN PHEAP_ENTRY BusyBlock,
    IN PCHAR Reason
    );

BOOLEAN
RtlpValidateHeap (
    IN PHEAP Heap,
    IN BOOLEAN AlwaysValidate
    );

VOID
RtlpUpdateHeapListIndex (
    USHORT OldIndex,
    USHORT NewIndex
    );

BOOLEAN
RtlpValidateHeapHeaders(
    IN PHEAP Heap,
    IN BOOLEAN Recompute
    );


//
//  Macro for setting a bit in the freelist vector to indicate entries are
//  present.
//

#define SET_FREELIST_BIT( H, FB )                                     \
{                                                                     \
    ULONG _Index_;                                                    \
    ULONG _Bit_;                                                      \
                                                                      \
    HEAPASSERT((FB)->Size < HEAP_MAXIMUM_FREELISTS);                  \
                                                                      \
    _Index_ = (FB)->Size >> 3;                                        \
    _Bit_ = (1 << ((FB)->Size & 7));                                  \
                                                                      \
    HEAPASSERT(((H)->u.FreeListsInUseBytes[ _Index_ ] & _Bit_) == 0); \
                                                                      \
    (H)->u.FreeListsInUseBytes[ _Index_ ] |= _Bit_;                   \
}

//
//  Macro for clearing a bit in the freelist vector to indicate entries are
//  not present.
//

#define CLEAR_FREELIST_BIT( H, FB )                            \
{                                                              \
    ULONG _Index_;                                             \
    ULONG _Bit_;                                               \
                                                               \
    HEAPASSERT((FB)->Size < HEAP_MAXIMUM_FREELISTS);           \
                                                               \
    _Index_ = (FB)->Size >> 3;                                 \
    _Bit_ = (1 << ((FB)->Size & 7));                           \
                                                               \
    HEAPASSERT((H)->u.FreeListsInUseBytes[ _Index_ ] & _Bit_); \
    HEAPASSERT(IsListEmpty(&(H)->FreeLists[ (FB)->Size ]));    \
                                                               \
    (H)->u.FreeListsInUseBytes[ _Index_ ] ^= _Bit_;            \
}


//
//  This macro inserts a free block into the appropriate free list including
//  the [0] index list with entry filling if necessary
//
#if DBG

#define RtlpInsertFreeBlockDirect( H, FB, SIZE )                          \
{                                                                         \
    PLIST_ENTRY _HEAD, _NEXT;                                             \
    PHEAP_FREE_ENTRY _FB1;                                                \
                                                                          \
    HEAPASSERT((FB)->Size == (SIZE));                                     \
    (FB)->Flags &= ~(HEAP_ENTRY_FILL_PATTERN |                            \
                     HEAP_ENTRY_EXTRA_PRESENT |                           \
                     HEAP_ENTRY_BUSY);                                    \
                                                                          \
    if ((H)->Flags & HEAP_FREE_CHECKING_ENABLED) {                        \
                                                                          \
        RtlFillMemoryUlong( (PCHAR)((FB) + 1),                            \
                            ((SIZE) << HEAP_GRANULARITY_SHIFT) -          \
                                sizeof( *(FB) ),                          \
                            FREE_HEAP_FILL );                             \
                                                                          \
        (FB)->Flags |= HEAP_ENTRY_FILL_PATTERN;                           \
    }                                                                     \
                                                                          \
    if ((SIZE) < HEAP_MAXIMUM_FREELISTS) {                                \
                                                                          \
        _HEAD = &(H)->FreeLists[ (SIZE) ];                                \
                                                                          \
        if (IsListEmpty(_HEAD)) {                                         \
                                                                          \
            SET_FREELIST_BIT( H, FB );                                    \
        }                                                                 \
                                                                          \
    } else {                                                              \
                                                                          \
        _HEAD = &(H)->FreeLists[ 0 ];                                     \
        _NEXT = _HEAD->Flink;                                             \
                                                                          \
        while (_HEAD != _NEXT) {                                          \
                                                                          \
            _FB1 = CONTAINING_RECORD( _NEXT, HEAP_FREE_ENTRY, FreeList ); \
                                                                          \
            if ((SIZE) <= _FB1->Size) {                                   \
                                                                          \
                break;                                                    \
                                                                          \
            } else {                                                      \
                                                                          \
                _NEXT = _NEXT->Flink;                                     \
            }                                                             \
        }                                                                 \
                                                                          \
        _HEAD = _NEXT;                                                    \
    }                                                                     \
                                                                          \
    InsertTailList( _HEAD, &(FB)->FreeList );                             \
}

#else  // DBG

#define RtlpInsertFreeBlockDirect( H, FB, SIZE )                          \
{                                                                         \
    PLIST_ENTRY _HEAD, _NEXT;                                             \
    PHEAP_FREE_ENTRY _FB1;                                                \
                                                                          \
    HEAPASSERT((FB)->Size == (SIZE));                                     \
    (FB)->Flags &= ~(HEAP_ENTRY_FILL_PATTERN |                            \
                     HEAP_ENTRY_EXTRA_PRESENT |                           \
                     HEAP_ENTRY_BUSY);                                    \
                                                                          \
    if ((SIZE) < HEAP_MAXIMUM_FREELISTS) {                                \
                                                                          \
        _HEAD = &(H)->FreeLists[ (SIZE) ];                                \
                                                                          \
        if (IsListEmpty(_HEAD)) {                                         \
                                                                          \
            SET_FREELIST_BIT( H, FB );                                    \
        }                                                                 \
                                                                          \
    } else {                                                              \
                                                                          \
        _HEAD = &(H)->FreeLists[ 0 ];                                     \
        _NEXT = _HEAD->Flink;                                             \
                                                                          \
        while (_HEAD != _NEXT) {                                          \
                                                                          \
            _FB1 = CONTAINING_RECORD( _NEXT, HEAP_FREE_ENTRY, FreeList ); \
                                                                          \
            if ((SIZE) <= _FB1->Size) {                                   \
                                                                          \
                break;                                                    \
                                                                          \
            } else {                                                      \
                                                                          \
                _NEXT = _NEXT->Flink;                                     \
            }                                                             \
        }                                                                 \
                                                                          \
        _HEAD = _NEXT;                                                    \
    }                                                                     \
                                                                          \
    InsertTailList( _HEAD, &(FB)->FreeList );                             \
}

#endif // DBG

//
//  This version of RtlpInsertFreeBlockDirect does no filling.
//

#define RtlpFastInsertFreeBlockDirect( H, FB, SIZE )              \
{                                                                 \
    if ((SIZE) < HEAP_MAXIMUM_FREELISTS) {                        \
                                                                  \
        RtlpFastInsertDedicatedFreeBlockDirect( H, FB, SIZE );    \
                                                                  \
    } else {                                                      \
                                                                  \
        RtlpFastInsertNonDedicatedFreeBlockDirect( H, FB, SIZE ); \
    }                                                             \
}

//
//  This version of RtlpInsertFreeBlockDirect only works for dedicated free
//  lists and doesn't do any filling.
//

#define RtlpFastInsertDedicatedFreeBlockDirect( H, FB, SIZE )             \
{                                                                         \
    PLIST_ENTRY _HEAD;                                                    \
                                                                          \
    HEAPASSERT((FB)->Size == (SIZE));                                     \
                                                                          \
    if (!((FB)->Flags & HEAP_ENTRY_LAST_ENTRY)) {                         \
                                                                          \
        HEAPASSERT(((PHEAP_ENTRY)(FB) + (SIZE))->PreviousSize == (SIZE)); \
    }                                                                     \
                                                                          \
    (FB)->Flags &= HEAP_ENTRY_LAST_ENTRY;                                 \
                                                                          \
    _HEAD = &(H)->FreeLists[ (SIZE) ];                                    \
                                                                          \
    if (IsListEmpty(_HEAD)) {                                             \
                                                                          \
        SET_FREELIST_BIT( H, FB );                                        \
    }                                                                     \
                                                                          \
    InsertTailList( _HEAD, &(FB)->FreeList );                             \
}

//
//  This version of RtlpInsertFreeBlockDirect only works for nondedicated free
//  lists and doesn't do any filling.
//

#define RtlpFastInsertNonDedicatedFreeBlockDirect( H, FB, SIZE )          \
{                                                                         \
    PLIST_ENTRY _HEAD, _NEXT;                                             \
    PHEAP_FREE_ENTRY _FB1;                                                \
                                                                          \
    HEAPASSERT((FB)->Size == (SIZE));                                     \
                                                                          \
    if (!((FB)->Flags & HEAP_ENTRY_LAST_ENTRY)) {                         \
                                                                          \
        HEAPASSERT(((PHEAP_ENTRY)(FB) + (SIZE))->PreviousSize == (SIZE)); \
    }                                                                     \
                                                                          \
    (FB)->Flags &= (HEAP_ENTRY_LAST_ENTRY);                               \
                                                                          \
    _HEAD = &(H)->FreeLists[ 0 ];                                         \
    _NEXT = _HEAD->Flink;                                                 \
                                                                          \
    while (_HEAD != _NEXT) {                                              \
                                                                          \
        _FB1 = CONTAINING_RECORD( _NEXT, HEAP_FREE_ENTRY, FreeList );     \
                                                                          \
        if ((SIZE) <= _FB1->Size) {                                       \
                                                                          \
            break;                                                        \
                                                                          \
        } else {                                                          \
                                                                          \
            _NEXT = _NEXT->Flink;                                         \
        }                                                                 \
    }                                                                     \
                                                                          \
    InsertTailList( _NEXT, &(FB)->FreeList );                             \
}


//
//  This macro removes a block from its free list with fill checking if
//  necessary
//

#define RtlpRemoveFreeBlock( H, FB )                                              \
{                                                                                 \
    RtlpFastRemoveFreeBlock( H, FB )                                              \
                                                                                  \
    if ((FB)->Flags & HEAP_ENTRY_FILL_PATTERN) {                                  \
                                                                                  \
        SIZE_T cb, cbEqual;                                                       \
        PVOID p;                                                                  \
                                                                                  \
        cb = ((FB)->Size << HEAP_GRANULARITY_SHIFT) - sizeof( *(FB) );            \
                                                                                  \
        if ((FB)->Flags & HEAP_ENTRY_EXTRA_PRESENT &&                             \
            cb > sizeof( HEAP_FREE_ENTRY_EXTRA )) {                               \
                                                                                  \
            cb -= sizeof( HEAP_FREE_ENTRY_EXTRA );                                \
        }                                                                         \
                                                                                  \
        cbEqual = RtlCompareMemoryUlong( (PCHAR)((FB) + 1),                       \
                                                 cb,                              \
                                                 FREE_HEAP_FILL );                \
                                                                                  \
        if (cbEqual != cb) {                                                      \
                                                                                  \
            HeapDebugPrint((                                                      \
                "HEAP: Free Heap block %lx modified at %lx after it was freed\n", \
                (FB),                                                             \
                (PCHAR)((FB) + 1) + cbEqual ));                                   \
                                                                                  \
            HeapDebugBreak((FB));                                                 \
        }                                                                         \
    }                                                                             \
}

//
//  This version of RtlpRemoveFreeBlock does no fill checking
//

#define RtlpFastRemoveFreeBlock( H, FB )         \
{                                                \
    PLIST_ENTRY _EX_Blink;                       \
    PLIST_ENTRY _EX_Flink;                       \
                                                 \
    _EX_Flink = (FB)->FreeList.Flink;            \
    _EX_Blink = (FB)->FreeList.Blink;            \
                                                 \
    _EX_Blink->Flink = _EX_Flink;                \
    _EX_Flink->Blink = _EX_Blink;                \
                                                 \
    if ((_EX_Flink == _EX_Blink) &&              \
        ((FB)->Size < HEAP_MAXIMUM_FREELISTS)) { \
                                                 \
        CLEAR_FREELIST_BIT( H, FB );             \
    }                                            \
}

//
//  This version of RtlpRemoveFreeBlock only works for dedicated free lists
//  (where we know that (FB)->Mask != 0) and doesn't do any fill checking
//

#define RtlpFastRemoveDedicatedFreeBlock( H, FB ) \
{                                                 \
    PLIST_ENTRY _EX_Blink;                        \
    PLIST_ENTRY _EX_Flink;                        \
                                                  \
    _EX_Flink = (FB)->FreeList.Flink;             \
    _EX_Blink = (FB)->FreeList.Blink;             \
                                                  \
    _EX_Blink->Flink = _EX_Flink;                 \
    _EX_Flink->Blink = _EX_Blink;                 \
                                                  \
    if (_EX_Flink == _EX_Blink) {                 \
                                                  \
        CLEAR_FREELIST_BIT( H, FB );              \
    }                                             \
}

//
//  This version of RtlpRemoveFreeBlock only works for dedicated free lists
//  (where we know that (FB)->Mask == 0) and doesn't do any fill checking
//

#define RtlpFastRemoveNonDedicatedFreeBlock( H, FB ) \
{                                                    \
    RemoveEntryList(&(FB)->FreeList)                 \
}


//
//  Heap tagging routines implemented in heapdll.c
//

#if DBG

#define IS_HEAP_TAGGING_ENABLED() (TRUE)

#else

#define IS_HEAP_TAGGING_ENABLED() (NtGlobalFlag & FLG_HEAP_ENABLE_TAGGING)

#endif // DBG

//
//  ORDER IS IMPORTANT HERE...SEE RtlpUpdateTagEntry sources
//

typedef enum _HEAP_TAG_ACTION {

    AllocationAction,
    VirtualAllocationAction,
    FreeAction,
    VirtualFreeAction,
    ReAllocationAction,
    VirtualReAllocationAction

} HEAP_TAG_ACTION;

PWSTR
RtlpGetTagName (
    PHEAP Heap,
    USHORT TagIndex
    );

USHORT
RtlpUpdateTagEntry (
    PHEAP Heap,
    USHORT TagIndex,
    SIZE_T OldSize,      // Only valid for ReAllocation and Free actions
    SIZE_T NewSize,      // Only valid for ReAllocation and Allocation actions
    HEAP_TAG_ACTION Action
    );

VOID
RtlpResetTags (
    PHEAP Heap
    );

VOID
RtlpDestroyTags (
    PHEAP Heap
    );


//
// Define heap lookaside list allocation functions.
//

typedef struct _HEAP_LOOKASIDE {
    SLIST_HEADER ListHead;

    USHORT Depth;
    USHORT MaximumDepth;

    ULONG TotalAllocates;
    ULONG AllocateMisses;
    ULONG TotalFrees;
    ULONG FreeMisses;

    ULONG LastTotalAllocates;
    ULONG LastAllocateMisses;

    ULONG Future[2];

} HEAP_LOOKASIDE, *PHEAP_LOOKASIDE;

NTKERNELAPI
VOID
RtlpInitializeHeapLookaside (
    IN PHEAP_LOOKASIDE Lookaside,
    IN USHORT Depth
    );

NTKERNELAPI
VOID
RtlpDeleteHeapLookaside (
    IN PHEAP_LOOKASIDE Lookaside
    );

VOID
RtlpAdjustHeapLookasideDepth (
    IN PHEAP_LOOKASIDE Lookaside
    );

NTKERNELAPI
PVOID
RtlpAllocateFromHeapLookaside (
    IN PHEAP_LOOKASIDE Lookaside
    );

NTKERNELAPI
BOOLEAN
RtlpFreeToHeapLookaside (
    IN PHEAP_LOOKASIDE Lookaside,
    IN PVOID Entry
    );

#endif // _RTL_HEAP_PRIVATE_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\rtl\heappagi.h ===
//
//  heappagi.h
//
//  The following definitions are internal to the debug heap manager,
//  but are placed in this include file so that debugger extensions
//  can reference the same structure definitions.  The following
//  definitions are not intended to be referenced externally except
//  by debugger extensions.
//

#ifndef _HEAP_PAGE_I_
#define _HEAP_PAGE_I_

#ifdef DEBUG_PAGE_HEAP

#include "heap.h"

#define DPH_INTERNAL_DEBUG      0   // change to 0 or #undef for production code

#define DPH_MAX_STACK_LENGTH   20

//
// Capture stacktraces in any context (x86/alpha, fre/chk). On alpha
// the stack acquisition function will fail and no stack trace will be
// acquired but in case we will find a better algorithm the page heap
// code will automatically take advantage of that.
//

#define DPH_CAPTURE_STACK_TRACE 1

//
// Page Heap Global Flags
//
// These flags are kept in a global variable that can be set from
// debugger. During heap creation these flags are stored in a per heap
// structure and control the behavior of that particular heap.
//
// PAGE_HEAP_ENABLE_PAGE_HEAP
//
//     This flag is set by default. It means that page heap allocations
//     should be used always. The flag is useful if we want to use page
//     heap only for certain heaps and stick with normal heaps for the
//     others.
//
// PAGE_HEAP_COLLECT_STACK_TRACES
//
//     This flag is disabled in free builds and enabled in checked builds.
//     If it is set the page heap manager will collect stack traces for
//     all important events (create, alloc, free, etc.).    
//
// PAGE_HEAP_MINIMIZE_MEMORY_IMPACT
//
//     This flags is disabled by default. If it is set then if the
//     memory available is less than 50% of total memory the allocation
//     will be done in a normal heap instead of page heap. Special care
//     is taken during free operations to figure out from what kind of
//     heap the block came.
//
// PAGE_HEAP_VERIFY_RANDOMLY
//
//     This is used in conjuction with MinimizeMemoryImpact flag.
//     It forces only a certain amount of allocations (randomly chosen)
//     into page heap. The probability is specified in the most significant
//     byte of the RtlpDebugPageHeapGlobalFlags.
//          
//     If the bit is reset and MinimizeMemoryImpact flag is set
//     it forces only a certain amount of allocations (with size in range)
//     into page heap. The range ([start..end]) is specified in the first
//     two most significant bytes of RtlpDebugPageHeapGlobalFlags.
//
//     For both cases the third byte (bits 15-8) represent the percentage
//     of available memory below which allocations will be done in normal heap
//     independent of other criteria.
//
// PAGE_HEAP_CATCH_BACKWARD_OVERRUNS
//
//     Places the NA page at the beginning of the block.
//

#define PAGE_HEAP_ENABLE_PAGE_HEAP          0x0001
#define PAGE_HEAP_COLLECT_STACK_TRACES      0x0002
#define PAGE_HEAP_MINIMIZE_MEMORY_IMPACT    0x0004
#define PAGE_HEAP_VERIFY_RANDOMLY           0x0008
#define PAGE_HEAP_CATCH_BACKWARD_OVERRUNS   0x0010

//
// `RtlpDebugPageHeapGlobalFlags' stores the global page heap flags.
// The value of this variable is copied into the per heap
// flags (ExtraFlags field) during heap creation.
//

extern ULONG RtlpDebugPageHeapGlobalFlags;

//
// DPH_STACK_TRACE_NODE
//

#if DPH_CAPTURE_STACK_TRACE

typedef struct _DPH_STACK_TRACE_NODE DPH_STACK_TRACE_NODE, *PDPH_STACK_TRACE_NODE;

struct _DPH_STACK_TRACE_NODE {

    PDPH_STACK_TRACE_NODE Left;         //  B-tree on Hash
    PDPH_STACK_TRACE_NODE Right;        //  B-tree on Hash

    ULONG                 Hash;         //  simple sum of PVOIDs in stack trace
    SIZE_T                Length;       //  number of PVOIDs in stack trace

    ULONG                 BusyCount;    //  number of busy allocations
    SIZE_T                BusyBytes;    //  total user size of busy allocations

    PVOID                 Address[ 0 ]; //  variable length array of addresses
};

#endif // DPH_CAPTURE_STACK_TRACE

//
// DPH_HEAP_ALLOCATION
//

typedef struct _DPH_HEAP_ALLOCATION DPH_HEAP_ALLOCATION, *PDPH_HEAP_ALLOCATION;

struct _DPH_HEAP_ALLOCATION {

    //
    //  Singly linked list of allocations (pNextAlloc must be
    //  first member in structure).
    //

    PDPH_HEAP_ALLOCATION pNextAlloc;

    //
    //   | PAGE_READWRITE          | PAGE_NOACCESS           |
    //   |____________________|___||_________________________|
    //
    //   ^pVirtualBlock       ^pUserAllocation
    //
    //   |---------------- nVirtualBlockSize ----------------|
    //
    //   |---nVirtualAccessSize----|
    //
    //                        |---|  nUserRequestedSize
    //
    //                        |----|  nUserActualSize
    //

    PUCHAR pVirtualBlock;
    SIZE_T  nVirtualBlockSize;

    SIZE_T  nVirtualAccessSize;
    PUCHAR pUserAllocation;
    SIZE_T  nUserRequestedSize;
    SIZE_T  nUserActualSize;
    PVOID  UserValue;
    ULONG  UserFlags;

#if DPH_CAPTURE_STACK_TRACE

    PDPH_STACK_TRACE_NODE pStackTrace;

#endif

    };


typedef struct _DPH_HEAP_ROOT DPH_HEAP_ROOT, *PDPH_HEAP_ROOT;

struct _DPH_HEAP_ROOT {

    //
    //  Maintain a signature (DPH_HEAP_ROOT_SIGNATURE) as the
    //  first value in the heap root structure.
    //

    ULONG                 Signature;
    ULONG                 HeapFlags;

    //
    //  Access to this heap is synchronized with a critical section.
    //

    PRTL_CRITICAL_SECTION HeapCritSect;
    ULONG                 nRemoteLockAcquired;

    //
    //  The "VirtualStorage" list only uses the pVirtualBlock,
    //  nVirtualBlockSize, and nVirtualAccessSize fields of the
    //  HEAP_ALLOCATION structure.  This is the list of virtual
    //  allocation entries that all the heap allocations are
    //  taken from.
    //

    PDPH_HEAP_ALLOCATION  pVirtualStorageListHead;
    PDPH_HEAP_ALLOCATION  pVirtualStorageListTail;
    ULONG                 nVirtualStorageRanges;
    SIZE_T                 nVirtualStorageBytes;

    //
    //  The "Busy" list is the list of active heap allocations.
    //  It is stored in LIFO order to improve temporal locality
    //  for linear searches since most initial heap allocations
    //  tend to remain permanent throughout a process's lifetime.
    //

    PDPH_HEAP_ALLOCATION  pBusyAllocationListHead;
    PDPH_HEAP_ALLOCATION  pBusyAllocationListTail;
    ULONG                 nBusyAllocations;
    SIZE_T                 nBusyAllocationBytesCommitted;

    //
    //  The "Free" list is the list of freed heap allocations, stored
    //  in FIFO order to increase the length of time a freed block
    //  remains on the freed list without being used to satisfy an
    //  allocation request.  This increases the odds of catching
    //  a reference-after-freed bug in an app.
    //

    PDPH_HEAP_ALLOCATION  pFreeAllocationListHead;
    PDPH_HEAP_ALLOCATION  pFreeAllocationListTail;
    ULONG                 nFreeAllocations;
    SIZE_T                 nFreeAllocationBytesCommitted;

    //
    //  The "Available" list is stored in address-sorted order to facilitate
    //  coalescing.  When an allocation request cannot be satisfied from the
    //  "Available" list, it is attempted from the free list.  If it cannot
    //  be satisfied from the free list, the free list is coalesced into the
    //  available list.  If the request still cannot be satisfied from the
    //  coalesced available list, new VM is added to the available list.
    //

    PDPH_HEAP_ALLOCATION  pAvailableAllocationListHead;
    PDPH_HEAP_ALLOCATION  pAvailableAllocationListTail;
    ULONG                 nAvailableAllocations;
    SIZE_T                 nAvailableAllocationBytesCommitted;

    //
    //  The "UnusedNode" list is simply a list of available node
    //  entries to place "Busy", "Free", or "Virtual" entries.
    //  When freed nodes get coalesced into a single free node,
    //  the other "unused" node goes on this list.  When a new
    //  node is needed (like an allocation not satisfied from the
    //  free list), the node comes from this list if it's not empty.
    //

    PDPH_HEAP_ALLOCATION  pUnusedNodeListHead;
    PDPH_HEAP_ALLOCATION  pUnusedNodeListTail;
    ULONG                 nUnusedNodes;

    SIZE_T                 nBusyAllocationBytesAccessible;

    //
    //  Node pools need to be tracked so they can be protected
    //  from app scribbling on them.
    //

    PDPH_HEAP_ALLOCATION  pNodePoolListHead;
    PDPH_HEAP_ALLOCATION  pNodePoolListTail;
    ULONG                 nNodePools;
    SIZE_T                 nNodePoolBytes;

    //
    //  Doubly linked list of DPH heaps in process is tracked through this.
    //

    PDPH_HEAP_ROOT        pNextHeapRoot;
    PDPH_HEAP_ROOT        pPrevHeapRoot;

    ULONG                 nUnProtectionReferenceCount;
    ULONG                 InsideAllocateNode;           // only for debugging

#if DPH_CAPTURE_STACK_TRACE

    PUCHAR                pStackTraceStorage;
    SIZE_T                nStackTraceStorage;

    PDPH_STACK_TRACE_NODE pStackTraceRoot;              // B-tree root
    PDPH_STACK_TRACE_NODE pStackTraceCreator;

    SIZE_T                nStackTraceBytesCommitted;
    SIZE_T                nStackTraceBytesWasted;

    SIZE_T                nStackTraceBNodes;
    SIZE_T                nStackTraceBDepth;
    SIZE_T                nStackTraceBHashCollisions;

#endif // DPH_CAPTURE_STACK_TRACE

    //
    // These are extra flags used to control page heap behavior.
    // During heap creation the current value of the global page heap
    // flags (process wise) is written into this field.
    //

    ULONG                 ExtraFlags;

    //
    // Seed for the random generator used to decide from where
    // should we make an allocation (normal or verified heap).
    // The field is protected by the critical section associated
    // with each page heap.
    //

    ULONG                  Seed;
    ULONG                  Counter[5];

    //
    // `NormalHeap' is used in case we want to combine verified allocations
    // with normal ones. This is useful to minimize memory impact. Without
    // this feature certain processes that are very heap intensive cannot
    // be verified at all.
    //

    PVOID                 NormalHeap;
    };


#endif // DEBUG_PAGE_HEAP

#endif // _HEAP_PAGE_I_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\rtl\imagedir.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    imagedir.c

Abstract:

    The module contains the code to translate an image directory type to
    the address of the data for that entry.

Author:

    Steve Wood (stevewo) 18-Aug-1989

Environment:

    User Mode or Kernel Mode

Revision History:

--*/

#include "ntrtlp.h"

PIMAGE_NT_HEADERS
RtlImageNtHeader (
    IN PVOID Base
    )

/*++

Routine Description:

    This function returns the address of the NT Header.

Arguments:

    Base - Supplies the base of the image.

Return Value:

    Returns the address of the NT Header.

--*/

{
#if defined (BLDR_KERNEL_RUNTIME) || defined(NTOS_KERNEL_RUNTIME)
    PIMAGE_NT_HEADERS NtHeaders = NULL;

    if (Base != NULL && Base != (PVOID)-1) {
        if (((PIMAGE_DOS_HEADER)Base)->e_magic == IMAGE_DOS_SIGNATURE) {
            NtHeaders = (PIMAGE_NT_HEADERS)((PCHAR)Base + ((PIMAGE_DOS_HEADER)Base)->e_lfanew);

#if defined(NTOS_KERNEL_RUNTIME)
            if (Base < MM_HIGHEST_USER_ADDRESS) {
                if ((PVOID)NtHeaders >= MM_HIGHEST_USER_ADDRESS) {
                    return NULL;
                }
                if ((PVOID)((PCHAR)NtHeaders + sizeof (IMAGE_NT_HEADERS)) >= MM_HIGHEST_USER_ADDRESS) {
                    return NULL;
                }
            }
#endif

            if (NtHeaders->Signature != IMAGE_NT_SIGNATURE) {
                NtHeaders = NULL;
            }
        }
    }

    return NtHeaders;
#else
    return RtlpImageNtHeader( Base );
#endif
}


PIMAGE_SECTION_HEADER
RtlSectionTableFromVirtualAddress (
    IN PIMAGE_NT_HEADERS NtHeaders,
    IN PVOID Base,
    IN ULONG Address
    )

/*++

Routine Description:

    This function locates a VirtualAddress within the image header
    of a file that is mapped as a file and returns a pointer to the
    section table entry for that virtual address

Arguments:

    NtHeaders - Supplies the pointer to the image or data file.

    Base - Supplies the base of the image or data file.

    Address - Supplies the virtual address to locate.

Return Value:

    NULL - The file does not contain data for the specified directory entry.

    NON-NULL - Returns the pointer of the section entry containing the data.

--*/

{
    ULONG i;
    PIMAGE_SECTION_HEADER NtSection;

    NtSection = IMAGE_FIRST_SECTION( NtHeaders );
    for (i=0; i<NtHeaders->FileHeader.NumberOfSections; i++) {
        if ((ULONG)Address >= NtSection->VirtualAddress &&
            (ULONG)Address < NtSection->VirtualAddress + NtSection->SizeOfRawData
           ) {
            return NtSection;
            }
        ++NtSection;
        }

    return NULL;
}


PVOID
RtlAddressInSectionTable (
    IN PIMAGE_NT_HEADERS NtHeaders,
    IN PVOID Base,
    IN ULONG Address
    )

/*++

Routine Description:

    This function locates a VirtualAddress within the image header
    of a file that is mapped as a file and returns the seek address
    of the data the Directory describes.

Arguments:

    NtHeaders - Supplies the pointer to the image or data file.

    Base - Supplies the base of the image or data file.

    Address - Supplies the virtual address to locate.

Return Value:

    NULL - The file does not contain data for the specified directory entry.

    NON-NULL - Returns the address of the raw data the directory describes.

--*/

{
    PIMAGE_SECTION_HEADER NtSection;

    NtSection = RtlSectionTableFromVirtualAddress( NtHeaders,
                                                   Base,
                                                   Address
                                                 );
    if (NtSection != NULL) {
        return( ((PCHAR)Base + ((ULONG_PTR)Address - NtSection->VirtualAddress) + NtSection->PointerToRawData) );
        }
    else {
        return( NULL );
        }
}


PVOID
RtlpImageDirectoryEntryToData32 (
    IN PVOID Base,
    IN BOOLEAN MappedAsImage,
    IN USHORT DirectoryEntry,
    OUT PULONG Size,
    PIMAGE_NT_HEADERS32 NtHeaders
    )
{
    ULONG DirectoryAddress;

    if (DirectoryEntry >= NtHeaders->OptionalHeader.NumberOfRvaAndSizes) {
        return( NULL );
    }

    if (!(DirectoryAddress = NtHeaders->OptionalHeader.DataDirectory[ DirectoryEntry ].VirtualAddress)) {
        return( NULL );
    }

#if defined(NTOS_KERNEL_RUNTIME)
    if (Base < MM_HIGHEST_USER_ADDRESS) {
        if ((PVOID)((PCHAR)Base + DirectoryAddress) >= MM_HIGHEST_USER_ADDRESS) {
            return( NULL );
        }
    }
#endif

    *Size = NtHeaders->OptionalHeader.DataDirectory[ DirectoryEntry ].Size;
    if (MappedAsImage || DirectoryAddress < NtHeaders->OptionalHeader.SizeOfHeaders) {
        return( (PVOID)((PCHAR)Base + DirectoryAddress) );
    }

    return( RtlAddressInSectionTable((PIMAGE_NT_HEADERS)NtHeaders, Base, DirectoryAddress ));
}


PVOID
RtlImageDirectoryEntryToData (
    IN PVOID Base,
    IN BOOLEAN MappedAsImage,
    IN USHORT DirectoryEntry,
    OUT PULONG Size
    )

/*++

Routine Description:

    This function locates a Directory Entry within the image header
    and returns either the virtual address or seek address of the
    data the Directory describes.

Arguments:

    Base - Supplies the base of the image or data file.

    MappedAsImage - FALSE if the file is mapped as a data file.
                  - TRUE if the file is mapped as an image.

    DirectoryEntry - Supplies the directory entry to locate.

    Size - Return the size of the directory.

Return Value:

    NULL - The file does not contain data for the specified directory entry.

    NON-NULL - Returns the address of the raw data the directory describes.

--*/

{
    PIMAGE_NT_HEADERS NtHeaders;

    if ((ULONG_PTR)Base & 0x00000001) {
        Base = (PVOID)((ULONG_PTR)Base & ~0x00000001);
        MappedAsImage = FALSE;
        }

    NtHeaders = RtlImageNtHeader(Base);

    if (!NtHeaders)
        return NULL;

    if (NtHeaders->OptionalHeader.Magic == IMAGE_NT_OPTIONAL_HDR32_MAGIC) {
        return (RtlpImageDirectoryEntryToData32(Base,
                                                MappedAsImage,
                                                DirectoryEntry,
                                                Size,
                                                (PIMAGE_NT_HEADERS32)NtHeaders));
    } else {
        return (NULL);
    }
}


#if !defined(NTOS_KERNEL_RUNTIME) && !defined(BLDR_KERNEL_RUNTIME)

PIMAGE_SECTION_HEADER
RtlImageRvaToSection(
    IN PIMAGE_NT_HEADERS NtHeaders,
    IN PVOID Base,
    IN ULONG Rva
    )

/*++

Routine Description:

    This function locates an RVA within the image header of a file
    that is mapped as a file and returns a pointer to the section
    table entry for that virtual address

Arguments:

    NtHeaders - Supplies the pointer to the image or data file.

    Base - Supplies the base of the image or data file.  The image
        was mapped as a data file.

    Rva - Supplies the relative virtual address (RVA) to locate.

Return Value:

    NULL - The RVA was not found within any of the sections of the image.

    NON-NULL - Returns the pointer to the image section that contains
               the RVA

--*/

{
    ULONG i;
    PIMAGE_SECTION_HEADER NtSection;

    NtSection = IMAGE_FIRST_SECTION( NtHeaders );
    for (i=0; i<NtHeaders->FileHeader.NumberOfSections; i++) {
        if (Rva >= NtSection->VirtualAddress &&
            Rva < NtSection->VirtualAddress + NtSection->SizeOfRawData
           ) {
            return NtSection;
            }
        ++NtSection;
        }

    return NULL;
}



PVOID
RtlImageRvaToVa(
    IN PIMAGE_NT_HEADERS NtHeaders,
    IN PVOID Base,
    IN ULONG Rva,
    IN OUT PIMAGE_SECTION_HEADER *LastRvaSection OPTIONAL
    )

/*++

Routine Description:

    This function locates an RVA within the image header of a file that
    is mapped as a file and returns the virtual addrees of the
    corresponding byte in the file.


Arguments:

    NtHeaders - Supplies the pointer to the image or data file.

    Base - Supplies the base of the image or data file.  The image
        was mapped as a data file.

    Rva - Supplies the relative virtual address (RVA) to locate.

    LastRvaSection - Optional parameter that if specified, points
        to a variable that contains the last section value used for
        the specified image to translate and RVA to a VA.

Return Value:

    NULL - The file does not contain the specified RVA

    NON-NULL - Returns the virtual addrees in the mapped file.

--*/

{
    PIMAGE_SECTION_HEADER NtSection;

    if (!ARGUMENT_PRESENT( LastRvaSection ) ||
        (NtSection = *LastRvaSection) == NULL ||
        Rva < NtSection->VirtualAddress ||
        Rva >= NtSection->VirtualAddress + NtSection->SizeOfRawData
       ) {
        NtSection = RtlImageRvaToSection( NtHeaders,
                                          Base,
                                          Rva
                                        );
        }

    if (NtSection != NULL) {
        if (LastRvaSection != NULL) {
            *LastRvaSection = NtSection;
            }

        return (PVOID)((PCHAR)Base +
                       (Rva - NtSection->VirtualAddress) +
                       NtSection->PointerToRawData
                      );
        }
    else {
        return NULL;
        }
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\rtl\ldrreloc.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

   ldrreloc.c

Abstract:

    This module contains the code to relocate an image when
    the preferred base isn't available. This is called by the
    boot loader, device driver loader, and system loader.

Author:

    Mike O'Leary (mikeol) 03-Feb-1992

Revision History:

--*/

#include "ntrtlp.h"

ULONG
LdrRelocateImage (
    IN PVOID NewBase,
    IN PUCHAR LoaderName,
    IN ULONG Success,
    IN ULONG Conflict,
    IN ULONG Invalid
    )

/*++

Routine Description:

    This routine relocates an image file that was not loaded into memory
    at the preferred address.

Arguments:

    NewBase - Supplies a pointer to the image base.

    LoaderName - Indicates which loader routine is being called from.

    Success - Value to return if relocation successful.

    Conflict - Value to return if can't relocate.

    Invalid - Value to return if relocations are invalid.

Return Value:

    Success if image is relocated.
    Conflict if image can't be relocated.
    Invalid if image contains invalid fixups.

--*/

{
    LONG_PTR Diff;
    ULONG TotalCountBytes;
    ULONG_PTR VA;
    ULONG_PTR OldBase;
    ULONG SizeOfBlock;
    PUCHAR FixupVA;
    USHORT Offset;
    PUSHORT NextOffset;
    PIMAGE_NT_HEADERS NtHeaders;
    PIMAGE_BASE_RELOCATION NextBlock;

    RTL_PAGED_CODE();

    NtHeaders = RtlImageNtHeader( NewBase );
    if ( NtHeaders ) {
        OldBase = NtHeaders->OptionalHeader.ImageBase;
        }
    else {
        return Invalid;
        }

    //
    // Locate the relocation section.
    //

    NextBlock = (PIMAGE_BASE_RELOCATION)RtlImageDirectoryEntryToData(
            NewBase, TRUE, IMAGE_DIRECTORY_ENTRY_BASERELOC, &TotalCountBytes);

    if (!NextBlock || !TotalCountBytes) {

        //
        // The image does not contain a relocation table, and therefore
        // cannot be relocated.
        //
#if DBG
        DbgPrint("%s: Image can't be relocated, no fixup information.\n", LoaderName);
#endif // DBG
        return Conflict;
    }

    //
    // If the image has a relocation table, then apply the specified fixup
    // information to the image.
    //

    while (TotalCountBytes) {
        SizeOfBlock = NextBlock->SizeOfBlock;
        TotalCountBytes -= SizeOfBlock;
        SizeOfBlock -= sizeof(IMAGE_BASE_RELOCATION);
        SizeOfBlock /= sizeof(USHORT);
        NextOffset = (PUSHORT)((PCHAR)NextBlock + sizeof(IMAGE_BASE_RELOCATION));

        VA = (ULONG_PTR)NewBase + NextBlock->VirtualAddress;
        Diff = (PCHAR)NewBase - (PCHAR)OldBase;

        if ( !(NextBlock = LdrProcessRelocationBlock(VA,SizeOfBlock,NextOffset,Diff)) ) {
#if DBG
            DbgPrint("%s: Unknown base relocation type\n", LoaderName);
#endif
            return Invalid;
        }
    }

    return Success;
}

PIMAGE_BASE_RELOCATION
LdrProcessRelocationBlock(
    IN ULONG_PTR VA,
    IN ULONG SizeOfBlock,
    IN PUSHORT NextOffset,
    IN LONG_PTR Diff
    )
{
    PUCHAR FixupVA;
    USHORT Offset;
    LONG Temp;

    RTL_PAGED_CODE();

    while (SizeOfBlock--) {

       Offset = *NextOffset & (USHORT)0xfff;
       FixupVA = (PUCHAR)(VA + Offset);

       //
       // Apply the fixups.
       //

       switch ((*NextOffset) >> 12) {

            case IMAGE_REL_BASED_HIGHLOW :
                //
                // HighLow - (32-bits) relocate the high and low half
                //      of an address.
                //
                *(LONG UNALIGNED *)FixupVA += (ULONG) Diff;
                break;

            case IMAGE_REL_BASED_HIGH :
                //
                // High - (16-bits) relocate the high half of an address.
                //
                Temp = *(PUSHORT)FixupVA << 16;
                Temp += (ULONG) Diff;
                *(PUSHORT)FixupVA = (USHORT)(Temp >> 16);
                break;

            case IMAGE_REL_BASED_HIGHADJ :
                //
                // Adjust high - (16-bits) relocate the high half of an
                //      address and adjust for sign extension of low half.
                //

                Temp = *(PUSHORT)FixupVA << 16;
                ++NextOffset;
                --SizeOfBlock;
                Temp += (LONG)(*(PSHORT)NextOffset);
                Temp += (ULONG) Diff;
                Temp += 0x8000;
                *(PUSHORT)FixupVA = (USHORT)(Temp >> 16);

                break;

            case IMAGE_REL_BASED_LOW :
                //
                // Low - (16-bit) relocate the low half of an address.
                //
                Temp = *(PSHORT)FixupVA;
                Temp += (ULONG) Diff;
                *(PUSHORT)FixupVA = (USHORT)Temp;
                break;

            case IMAGE_REL_BASED_ABSOLUTE :
                //
                // Absolute - no fixup required.
                //
                break;

            case IMAGE_REL_BASED_SECTION :
                //
                // Section Relative reloc.  Ignore for now.
                //
                break;

            case IMAGE_REL_BASED_REL32 :
                //
                // Relative intrasection. Ignore for now.
                //
                break;

            default :
                //
                // Illegal - illegal relocation type.
                //

                return (PIMAGE_BASE_RELOCATION)NULL;
       }
       ++NextOffset;
    }
    return (PIMAGE_BASE_RELOCATION)NextOffset;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\rtl\lookasid.c ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    lookasid.c

Abstract:

    This module implements heap lookaside list function.

Author:

    David N. Cutler (davec) 19-Feb-1995

Revision History:

--*/

#include "ntrtlp.h"
#include "heap.h"
#include "heappriv.h"


//
// Define Minimum lookaside list depth.
//

#define MINIMUM_LOOKASIDE_DEPTH 4

//
// Define minimum allocation threshold.
//

#define MINIMUM_ALLOCATION_THRESHOLD 25

//
// Define forward referenced function prototypes.
//



VOID
RtlpInitializeHeapLookaside (
    IN PHEAP_LOOKASIDE Lookaside,
    IN USHORT Depth
    )

/*++

Routine Description:

    This function initializes a heap lookaside list structure

Arguments:

    Lookaside - Supplies a pointer to a heap lookaside list structure.

    Allocate - Supplies a pointer to an allocate function.

    Free - Supplies a pointer to a free function.

    HeapHandle - Supplies a pointer to the heap that backs this lookaside list

    Flags - Supplies a set of heap flags.

    Size - Supplies the size for the lookaside list entries.

    Depth - Supplies the maximum depth of the lookaside list.

Return Value:

    None.

--*/

{

    //
    // Initialize the lookaside list structure.
    //

    RtlpInitializeSListHead(&Lookaside->ListHead);

    Lookaside->Depth = MINIMUM_LOOKASIDE_DEPTH;
    Lookaside->MaximumDepth = 256; //Depth;
    Lookaside->TotalAllocates = 0;
    Lookaside->AllocateMisses = 0;
    Lookaside->TotalFrees = 0;
    Lookaside->FreeMisses = 0;

    Lookaside->LastTotalAllocates = 0;
    Lookaside->LastAllocateMisses = 0;

    return;
}


VOID
RtlpDeleteHeapLookaside (
    IN PHEAP_LOOKASIDE Lookaside
    )

/*++

Routine Description:

    This function frees any entries specified by the lookaside structure.

Arguments:

    Lookaside - Supplies a pointer to a heap lookaside list structure.

Return Value:

    None.

--*/

{

    PVOID Entry;

    return;
}


VOID
RtlpAdjustHeapLookasideDepth (
    IN PHEAP_LOOKASIDE Lookaside
    )

/*++

Routine Description:

    This function is called periodically to adjust the maximum depth of
    a single heap lookaside list.

Arguments:

    Lookaside - Supplies a pointer to a heap lookaside list structure.

Return Value:

    None.

--*/

{
    ULONG Allocates;
    ULONG Misses;

    //
    // Compute the total number of allocations and misses for this scan
    // period.
    //

    Allocates = Lookaside->TotalAllocates - Lookaside->LastTotalAllocates;
    Lookaside->LastTotalAllocates = Lookaside->TotalAllocates;
    Misses = Lookaside->AllocateMisses - Lookaside->LastAllocateMisses;
    Lookaside->LastAllocateMisses = Lookaside->AllocateMisses;

    //
    // Compute target depth of lookaside list.
    //

    {
        ULONG Ratio;
        ULONG Target;

        //
        // If the allocate rate is less than the mimimum threshold, then lower
        // the maximum depth of the lookaside list. Otherwise, if the miss rate
        // is less than .5%, then lower the maximum depth. Otherwise, raise the
        // maximum depth based on the miss rate.
        //

        if (Misses >= Allocates) {
            Misses = Allocates;
        }

        if (Allocates == 0) {
            Allocates = 1;
        }

        Ratio = (Misses * 1000) / Allocates;
        Target = Lookaside->Depth;
        if (Allocates < MINIMUM_ALLOCATION_THRESHOLD) {
            if (Target > (MINIMUM_LOOKASIDE_DEPTH + 10)) {
                Target -= 10;

            } else {
                Target = MINIMUM_LOOKASIDE_DEPTH;
            }

        } else if (Ratio < 5) {
            if (Target > (MINIMUM_LOOKASIDE_DEPTH + 1)) {
                Target -= 1;

            } else {
                Target = MINIMUM_LOOKASIDE_DEPTH;
            }

        } else {
            Target += ((Ratio * Lookaside->MaximumDepth) / (1000 * 2)) + 5;
            if (Target > Lookaside->MaximumDepth) {
                Target = Lookaside->MaximumDepth;
            }
        }

        Lookaside->Depth = (USHORT)Target;
    }

    return;
}



PVOID
RtlpAllocateFromHeapLookaside (
    IN PHEAP_LOOKASIDE Lookaside
    )

/*++

Routine Description:

    This function removes (pops) the first entry from the specified
    heap lookaside list.

Arguments:

    Lookaside - Supplies a pointer to a paged lookaside list structure.

Return Value:

    If an entry is removed from the specified lookaside list, then the
    address of the entry is returned as the function value. Otherwise,
    NULL is returned.

--*/

{

    PVOID Entry;

    Lookaside->TotalAllocates += 1;

    //
    //  We need to protect ourselves from a second thread that can cause us
    //  to fault on the pop. If we do fault then we'll just do a regular pop
    //  operation
    //

#if defined(_X86_)

    if (USER_SHARED_DATA->ProcessorFeatures[PF_COMPARE_EXCHANGE_DOUBLE]) {

#endif // defined(_X86_)

        try {

            Entry = RtlpInterlockedPopEntrySList(&Lookaside->ListHead);

        } except (EXCEPTION_EXECUTE_HANDLER) {

            Entry = NULL;
        }

        if (Entry != NULL) {

            return Entry;
        }
#if defined(_X86_)

    }

#endif // defined(_X86_)

    Lookaside->AllocateMisses += 1;
    return NULL;
}


BOOLEAN
RtlpFreeToHeapLookaside (
    IN PHEAP_LOOKASIDE Lookaside,
    IN PVOID Entry
    )

/*++

Routine Description:

    This function inserts (pushes) the specified entry into the specified
    paged lookaside list.

Arguments:

    Lookaside - Supplies a pointer to a paged lookaside list structure.

    Entry - Supples a pointer to the entry that is inserted in the
        lookaside list.

Return Value:

    BOOLEAN - TRUE if the entry was put on the lookaside list and FALSE
        otherwise.

--*/

{
    Lookaside->TotalFrees += 1;

#if defined(_X86_)

    if (USER_SHARED_DATA->ProcessorFeatures[PF_COMPARE_EXCHANGE_DOUBLE]) {

#endif // defined(_X86_)

        if (RtlpQueryDepthSList(&Lookaside->ListHead) < Lookaside->Depth) {

            //
            //  We need to protect ourselves from a second thread that can
            //  cause us to fault on the push.  If we do fault then we'll
            //  just do a regular free operation
            //

            try {

                RtlpInterlockedPushEntrySList(&Lookaside->ListHead,
                                              (PSINGLE_LIST_ENTRY)Entry);

            } except (EXCEPTION_EXECUTE_HANDLER) {

                Lookaside->FreeMisses += 1;

                return FALSE;
            }

            return TRUE;
        }

#if defined(_X86_)

    }

#endif // defined(_X86_)

    Lookaside->FreeMisses += 1;

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\rtl\lznt1.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    LZNT1.c

Abstract:

    This module implements the LZNT1 compression engine.

Author:

    Gary Kimura     [GaryKi]    21-Jan-1994

Revision History:                                                

--*/

#include "ntrtlp.h"

#include <stdio.h>


//
//  Boolean which controls whether the asserts will fire.
//

#if DBG && !BLDR_KERNEL_RUNTIME
BOOLEAN Lznt1Break = TRUE;
#else
BOOLEAN Lznt1Break = FALSE;
#endif

//
//  Declare the internal workspace that we need
//

typedef struct _LZNT1_STANDARD_WORKSPACE {

    PUCHAR UncompressedBuffer;
    PUCHAR EndOfUncompressedBufferPlus1;
    ULONG  MaxLength;
    PUCHAR MatchedString;

    PUCHAR IndexPTable[4096][2];

} LZNT1_STANDARD_WORKSPACE, *PLZNT1_STANDARD_WORKSPACE;

typedef struct _LZNT1_MAXIMUM_WORKSPACE {

    PUCHAR UncompressedBuffer;
    PUCHAR EndOfUncompressedBufferPlus1;
    ULONG  MaxLength;
    PUCHAR MatchedString;

} LZNT1_MAXIMUM_WORKSPACE, *PLZNT1_MAXIMUM_WORKSPACE;

typedef struct _LZNT1_FRAGMENT_WORKSPACE {

    UCHAR Buffer[0x1000];

} LZNT1_FRAGMENT_WORKSPACE, *PLZNT1_FRAGMENT_WORKSPACE;

//
//  Now define the local procedure prototypes.
//

typedef ULONG (*PLZNT1_MATCH_FUNCTION) (
    );

NTSTATUS
LZNT1CompressChunk (
    IN PLZNT1_MATCH_FUNCTION MatchFunction,
    IN PUCHAR UncompressedBuffer,
    IN PUCHAR EndOfUncompressedBufferPlus1,
    OUT PUCHAR CompressedBuffer,
    IN PUCHAR EndOfCompressedBufferPlus1,
    OUT PULONG FinalCompressedChunkSize,
    IN PVOID WorkSpace
    );

NTSTATUS
LZNT1DecompressChunk (
    OUT PUCHAR UncompressedBuffer,
    IN PUCHAR EndOfUncompressedBufferPlus1,
    IN PUCHAR CompressedBuffer,
    IN PUCHAR EndOfCompressedBufferPlus1,
    OUT PULONG FinalUncompressedChunkSize
    );

ULONG
LZNT1FindMatchStandard (
    IN PUCHAR ZivString,
    IN PLZNT1_STANDARD_WORKSPACE WorkSpace
    );

ULONG
LZNT1FindMatchMaximum (
    IN PUCHAR ZivString,
    IN PVOID WorkSpace
    );


//
//  Local data structures
//

//
//  The compressed chunk header is the structure that starts every
//  new chunk in the compressed data stream.  In our definition here
//  we union it with a ushort to make setting and retrieving the chunk
//  header easier.  The header stores the size of the compressed chunk,
//  its signature, and if the data stored in the chunk is compressed or
//  not.
//
//  Compressed Chunk Size:
//
//      The actual size of a compressed chunk ranges from 4 bytes (2 byte
//      header, 1 flag byte, and 1 literal byte) to 4098 bytes (2 byte
//      header, and 4096 bytes of uncompressed data).  The size is encoded
//      in a 12 bit field biased by 3.  A value of 1 corresponds to a chunk
//      size of 4, 2 => 5, ..., 4095 => 4098.  A value of zero is special
//      because it denotes the ending chunk header.
//
//  Chunk Signature:
//
//      The only valid signature value is 3.  This denotes a 4KB uncompressed
//      chunk using with the 4/12 to 12/4 sliding offset/length encoding.
//
//  Is Chunk Compressed:
//
//      If the data in the chunk is compressed this field is 1 otherwise
//      the data is uncompressed and this field is 0.
//
//  The ending chunk header in a compressed buffer contains the a value of
//  zero (space permitting).
//

typedef union _COMPRESSED_CHUNK_HEADER {

    struct {

        USHORT CompressedChunkSizeMinus3 : 12;
        USHORT ChunkSignature            :  3;
        USHORT IsChunkCompressed         :  1;

    } Chunk;

    USHORT Short;

} COMPRESSED_CHUNK_HEADER, *PCOMPRESSED_CHUNK_HEADER;

#define MAX_UNCOMPRESSED_CHUNK_SIZE (4096)

//
//  USHORT
//  GetCompressedChunkSize (
//      IN COMPRESSED_CHUNK_HEADER ChunkHeader
//      );
//
//  USHORT
//  GetUncompressedChunkSize (
//      IN COMPRESSED_CHUNK_HEADER ChunkHeader
//      );
//
//  VOID
//  SetCompressedChunkHeader (
//      IN OUT COMPRESSED_CHUNK_HEADER ChunkHeader,
//      IN USHORT CompressedChunkSize,
//      IN BOOLEAN IsChunkCompressed
//      );
//

#define GetCompressedChunkSize(CH)   (       \
    (CH).Chunk.CompressedChunkSizeMinus3 + 3 \
)

#define GetUncompressedChunkSize(CH) (MAX_UNCOMPRESSED_CHUNK_SIZE)

#define SetCompressedChunkHeader(CH,CCS,ICC) {        \
    ASSERT((CCS) >= 4 && (CCS) <= 4098);              \
    (CH).Chunk.CompressedChunkSizeMinus3 = (CCS) - 3; \
    (CH).Chunk.ChunkSignature = 3;                    \
    (CH).Chunk.IsChunkCompressed = (ICC);             \
}


//
//  Local macros
//

#define FlagOn(F,SF)    ((F) & (SF))
#define SetFlag(F,SF)   { (F) |= (SF); }
#define ClearFlag(F,SF) { (F) &= ~(SF); }

#define Minimum(A,B)    ((A) < (B) ? (A) : (B))
#define Maximum(A,B)    ((A) > (B) ? (A) : (B))

#if defined(ALLOC_PRAGMA) && defined(NTOS_KERNEL_RUNTIME)

#pragma alloc_text(PAGE, RtlCompressWorkSpaceSizeLZNT1)
#pragma alloc_text(PAGE, RtlCompressBufferLZNT1)
#pragma alloc_text(PAGE, RtlDecompressBufferLZNT1)
#pragma alloc_text(PAGE, RtlDecompressFragmentLZNT1)
#pragma alloc_text(PAGE, RtlDescribeChunkLZNT1)
#pragma alloc_text(PAGE, RtlReserveChunkLZNT1)

#pragma alloc_text(PAGE, LZNT1CompressChunk)

#if !defined(_ALPHA_)
#if !defined(_MIPS_)
#if !defined(_PPC_)
#if !defined(i386)
#pragma alloc_text(PAGE, LZNT1DecompressChunk)
#endif
#endif
#endif
#endif

#pragma alloc_text(PAGE, LZNT1FindMatchStandard)
#pragma alloc_text(PAGE, LZNT1FindMatchMaximum)

#endif


NTSTATUS
RtlCompressWorkSpaceSizeLZNT1 (
    IN USHORT Engine,
    OUT PULONG CompressBufferWorkSpaceSize,
    OUT PULONG CompressFragmentWorkSpaceSize
    )

/*++

Routine Description:

Arguments:

Return Value:

--*/

{
    if (Engine == COMPRESSION_ENGINE_STANDARD) {

        *CompressBufferWorkSpaceSize = sizeof(LZNT1_STANDARD_WORKSPACE);
        *CompressFragmentWorkSpaceSize = sizeof(LZNT1_FRAGMENT_WORKSPACE);

        return STATUS_SUCCESS;

    } else if (Engine == COMPRESSION_ENGINE_MAXIMUM) {

        *CompressBufferWorkSpaceSize = sizeof(LZNT1_MAXIMUM_WORKSPACE);
        *CompressFragmentWorkSpaceSize = sizeof(LZNT1_FRAGMENT_WORKSPACE);

        return STATUS_SUCCESS;

    } else {

        return STATUS_NOT_SUPPORTED;
    }
}


NTSTATUS
RtlCompressBufferLZNT1 (
    IN USHORT Engine,
    IN PUCHAR UncompressedBuffer,
    IN ULONG UncompressedBufferSize,
    OUT PUCHAR CompressedBuffer,
    IN ULONG CompressedBufferSize,
    IN ULONG UncompressedChunkSize,
    OUT PULONG FinalCompressedSize,
    IN PVOID WorkSpace
    )

/*++

Routine Description:

    This routine takes as input an uncompressed buffer and produces
    its compressed equivalent provided the compressed data fits within
    the specified destination buffer.

    An output variable indicates the number of bytes used to store
    the compressed buffer.

Arguments:

    UncompressedBuffer - Supplies a pointer to the uncompressed data.

    UncompressedBufferSize - Supplies the size, in bytes, of the
        uncompressed buffer.

    CompressedBuffer - Supplies a pointer to where the compressed data
        is to be stored.

    CompressedBufferSize - Supplies the size, in bytes, of the
        compressed buffer.

    UncompressedChunkSize - Ignored.

    FinalCompressedSize - Receives the number of bytes needed in
        the compressed buffer to store the compressed data.

    WorkSpace - Mind your own business, just give it to me.

Return Value:

    STATUS_SUCCESS - the compression worked without a hitch.

    STATUS_BUFFER_ALL_ZEROS - the compression worked without a hitch and in
        addition the input buffer was all zeros.

    STATUS_BUFFER_TOO_SMALL - the compressed buffer is too small to hold the
        compressed data.

--*/

{
    NTSTATUS Status;

    PLZNT1_MATCH_FUNCTION MatchFunction;

    PUCHAR UncompressedChunk;
    PUCHAR CompressedChunk;
    LONG CompressedChunkSize;

    //
    //  The following variable is used to tell if we have processed an entire
    //  buffer of zeros and that we should return an alternate status value
    //

    BOOLEAN AllZero = TRUE;

    //
    //  The following variables are pointers to the byte following the
    //  end of each appropriate buffer.
    //

    PUCHAR EndOfUncompressedBuffer = UncompressedBuffer + UncompressedBufferSize;
    PUCHAR EndOfCompressedBuffer = CompressedBuffer + CompressedBufferSize;

    //
    //  Get the match function we are to be using
    //

    if (Engine == COMPRESSION_ENGINE_STANDARD) {

        MatchFunction = LZNT1FindMatchStandard;

    } else if (Engine == COMPRESSION_ENGINE_MAXIMUM) {

        MatchFunction = LZNT1FindMatchMaximum;

    } else {

        return STATUS_NOT_SUPPORTED;
    }

    //
    //  For each uncompressed chunk (even the odd sized ending buffer) we will
    //  try and compress the chunk
    //

    for (UncompressedChunk = UncompressedBuffer, CompressedChunk = CompressedBuffer;
         UncompressedChunk < EndOfUncompressedBuffer;
         UncompressedChunk += MAX_UNCOMPRESSED_CHUNK_SIZE, CompressedChunk += CompressedChunkSize) {

        ASSERT(EndOfUncompressedBuffer >= UncompressedChunk);
        ASSERT(EndOfCompressedBuffer >= CompressedChunk);

        //
        //  Call the appropriate engine to compress one chunk. and
        //  return an error if we got one.
        //

        if (!NT_SUCCESS(Status = LZNT1CompressChunk( MatchFunction,
                                                     UncompressedChunk,
                                                     EndOfUncompressedBuffer,
                                                     CompressedChunk,
                                                     EndOfCompressedBuffer,
                                                     &CompressedChunkSize,
                                                     WorkSpace ))) {

            return Status;
        }

        //
        //  See if we stay all zeros.  If not then all zeros will become
        //  false and stay that way no matter what we later compress
        //

        AllZero = AllZero && (Status == STATUS_BUFFER_ALL_ZEROS);
    }

    //
    //  If we are not within two bytes of the end of the compressed buffer then we
    //  need to zero out two more for the ending compressed header and update
    //  the compressed chunk pointer value.  Don't include these bytes in
    //  the count however, as that may force our caller to allocate an unneeded
    //  cluster, since on decompress we will terminate either on these two
    //  bytes of 0, or byte count.
    //

    if (CompressedChunk <= (EndOfCompressedBuffer - 2)) {

        *(CompressedChunk) = 0;
        *(CompressedChunk + 1) = 0;
    }

    //
    //  The final compressed size is the difference between the start of the
    //  compressed buffer and where the compressed chunk pointer was left
    //

    *FinalCompressedSize = (ULONG)(CompressedChunk - CompressedBuffer);

    //
    //  Check if the input buffer was all zeros and return the alternate status
    //  if appropriate
    //

    if (AllZero) { return STATUS_BUFFER_ALL_ZEROS; }

    return STATUS_SUCCESS;
}


NTSTATUS
RtlDecompressBufferLZNT1 (
    OUT PUCHAR UncompressedBuffer,
    IN ULONG UncompressedBufferSize,
    IN PUCHAR CompressedBuffer,
    IN ULONG CompressedBufferSize,
    OUT PULONG FinalUncompressedSize
    )

/*++

Routine Description:

    This routine takes as input a compressed buffer and produces
    its uncompressed equivalent provided the uncompressed data fits
    within the specified destination buffer.

    An output variable indicates the number of bytes used to store the
    uncompressed data.

Arguments:

    UncompressedBuffer - Supplies a pointer to where the uncompressed
        data is to be stored.

    UncompressedBufferSize - Supplies the size, in bytes, of the
        uncompressed buffer.

    CompressedBuffer - Supplies a pointer to the compressed data.

    CompressedBufferSize - Supplies the size, in bytes, of the
        compressed buffer.

    FinalUncompressedSize - Receives the number of bytes needed in
        the uncompressed buffer to store the uncompressed data.

Return Value:

    STATUS_SUCCESS - the decompression worked without a hitch.

    STATUS_BAD_COMPRESSION_BUFFER - the input compressed buffer is
        ill-formed.

--*/

{
    NTSTATUS Status;

    PUCHAR CompressedChunk = CompressedBuffer;
    PUCHAR UncompressedChunk = UncompressedBuffer;

    COMPRESSED_CHUNK_HEADER ChunkHeader;
    LONG SavedChunkSize;

    LONG UncompressedChunkSize;
    LONG CompressedChunkSize;

    //
    //  The following to variables are pointers to the byte following the
    //  end of each appropriate buffer.  This saves us from doing the addition
    //  for each loop check
    //

    PUCHAR EndOfUncompressedBuffer = UncompressedBuffer + UncompressedBufferSize;
    PUCHAR EndOfCompressedBuffer = CompressedBuffer + CompressedBufferSize;

    //
    //  Make sure that the compressed buffer is at least four bytes long to
    //  start with, and then get the first chunk header and make sure it
    //  is not an ending chunk header.
    //

    ASSERT(CompressedChunk <= EndOfCompressedBuffer - 4);

    RtlRetrieveUshort( &ChunkHeader, CompressedChunk );

    ASSERT( (ChunkHeader.Short != 0) || !Lznt1Break );

    //
    //  Now while there is space in the uncompressed buffer to store data
    //  we will loop through decompressing chunks
    //

    while (TRUE) {

        ASSERT( (ChunkHeader.Chunk.ChunkSignature == 3) || !Lznt1Break );

        CompressedChunkSize = GetCompressedChunkSize(ChunkHeader);

        //
        //  Check that the chunk actually fits in the buffer supplied
        //  by the caller
        //

        if (CompressedChunk + CompressedChunkSize > EndOfCompressedBuffer) {

            ASSERTMSG("CompressedBuffer is too small", !Lznt1Break);

            *FinalUncompressedSize = PtrToUlong(CompressedChunk);

            return STATUS_BAD_COMPRESSION_BUFFER;
        }

        //
        //  First make sure the chunk contains compressed data
        //

        if (ChunkHeader.Chunk.IsChunkCompressed) {

            //
            //  Decompress a chunk and return if we get an error
            //

            if (!NT_SUCCESS(Status = LZNT1DecompressChunk( UncompressedChunk,
                                                           EndOfUncompressedBuffer,
                                                           CompressedChunk + sizeof(COMPRESSED_CHUNK_HEADER),
                                                           CompressedChunk + CompressedChunkSize,
                                                           &UncompressedChunkSize ))) {

                *FinalUncompressedSize = UncompressedChunkSize;

                return Status;
            }

        } else {

            //
            //  The chunk does not contain compressed data so we need to simply
            //  copy over the uncompressed data
            //

            UncompressedChunkSize = GetUncompressedChunkSize( ChunkHeader );

            //
            //  Make sure the data will fit into the output buffer
            //

            if (UncompressedChunk + UncompressedChunkSize > EndOfUncompressedBuffer) {

                UncompressedChunkSize = (ULONG)(EndOfUncompressedBuffer - UncompressedChunk);
            }

            //
            //  Check that the compressed chunk has this many bytes to copy.
            //

            if (CompressedChunk + sizeof(COMPRESSED_CHUNK_HEADER) + UncompressedChunkSize > EndOfCompressedBuffer) {

                ASSERTMSG("CompressedBuffer is too small", !Lznt1Break);
                *FinalUncompressedSize = PtrToUlong(CompressedChunk);
                return STATUS_BAD_COMPRESSION_BUFFER;
            }

            RtlCopyMemory( UncompressedChunk,
                           CompressedChunk + sizeof(COMPRESSED_CHUNK_HEADER),
                           UncompressedChunkSize );
        }

        //
        //  Now update the compressed and uncompressed chunk pointers with
        //  the size of the compressed chunk and the number of bytes we
        //  decompressed into, and then make sure we didn't exceed our buffers
        //

        CompressedChunk += CompressedChunkSize;
        UncompressedChunk += UncompressedChunkSize;

        ASSERT( CompressedChunk <= EndOfCompressedBuffer );
        ASSERT( UncompressedChunk <= EndOfUncompressedBuffer );

        //
        //  Now if the uncompressed is full then we are done
        //

        if (UncompressedChunk == EndOfUncompressedBuffer) { break; }

        //
        //  Otherwise we need to get the next chunk header.  We first
        //  check if there is one, save the old chunk size for the
        //  chunk we just read in, get the new chunk, and then check
        //  if it is the ending chunk header
        //

        if (CompressedChunk > EndOfCompressedBuffer - 2) { break; }

        SavedChunkSize = GetUncompressedChunkSize(ChunkHeader);

        RtlRetrieveUshort( &ChunkHeader, CompressedChunk );
        if (ChunkHeader.Short == 0) { break; }

        //
        //  At this point we are not at the end of the uncompressed buffer
        //  and we have another chunk to process.  But before we go on we
        //  need to see if the last uncompressed chunk didn't fill the full
        //  uncompressed chunk size.
        //

        if (UncompressedChunkSize < SavedChunkSize) {

            LONG t1;
            PUCHAR t2;

            //
            //  Now we only need to zero out data if the really are going
            //  to process another chunk, to test for that we check if
            //  the zero will go beyond the end of the uncompressed buffer
            //

            if ((t2 = (UncompressedChunk +
                       (t1 = (SavedChunkSize -
                              UncompressedChunkSize)))) >= EndOfUncompressedBuffer) {

                break;
            }

            RtlZeroMemory( UncompressedChunk, t1);
            UncompressedChunk = t2;
        }
    }

    //
    //  If we got out of the loop with the compressed chunk pointer beyond the
    //  end of compressed buffer then the compression buffer is ill formed.
    //

    if (CompressedChunk > EndOfCompressedBuffer) {

        *FinalUncompressedSize = PtrToUlong(CompressedChunk);

        return STATUS_BAD_COMPRESSION_BUFFER;
    }

    //
    //  The final uncompressed size is the difference between the start of the
    //  uncompressed buffer and where the uncompressed chunk pointer was left
    //

    *FinalUncompressedSize = (ULONG)(UncompressedChunk - UncompressedBuffer);

    //
    //  And return to our caller
    //

    return STATUS_SUCCESS;
}


NTSTATUS
RtlDecompressFragmentLZNT1 (
    OUT PUCHAR UncompressedFragment,
    IN ULONG UncompressedFragmentSize,
    IN PUCHAR CompressedBuffer,
    IN ULONG CompressedBufferSize,
    IN ULONG FragmentOffset,
    OUT PULONG FinalUncompressedSize,
    IN PLZNT1_FRAGMENT_WORKSPACE WorkSpace
    )

/*++

Routine Description:

    This routine takes as input a compressed buffer and extract an
    uncompressed fragment.

    Output bytes are copied to the fragment buffer until either the
    fragment buffer is full or the end of the uncompressed buffer is
    reached.

    An output variable indicates the number of bytes used to store the
    uncompressed fragment.

Arguments:

    UncompressedFragment - Supplies a pointer to where the uncompressed
        fragment is to be stored.

    UncompressedFragmentSize - Supplies the size, in bytes, of the
        uncompressed fragment buffer.

    CompressedBuffer - Supplies a pointer to the compressed data buffer.

    CompressedBufferSize - Supplies the size, in bytes, of the
        compressed buffer.

    FragmentOffset - Supplies the offset (zero based) where the uncompressed
        fragment is being extract from.  The offset is the position within
        the original uncompressed buffer.

    FinalUncompressedSize - Receives the number of bytes needed in
        the Uncompressed fragment buffer to store the data.

    WorkSpace - Stop looking.

Return Value:

    STATUS_SUCCESS - the operation worked without a hitch.

    STATUS_BAD_COMPRESSION_BUFFER - the input compressed buffer is
        ill-formed.

--*/

{
    NTSTATUS Status;

    PUCHAR CompressedChunk = CompressedBuffer;

    COMPRESSED_CHUNK_HEADER ChunkHeader;
    ULONG UncompressedChunkSize;
    ULONG CompressedChunkSize;

    PUCHAR EndOfUncompressedFragment = UncompressedFragment + UncompressedFragmentSize;
    PUCHAR EndOfCompressedBuffer = CompressedBuffer + CompressedBufferSize;
    PUCHAR CurrentUncompressedFragment;

    ULONG CopySize;

    ASSERT(UncompressedFragmentSize > 0);

    //
    //  Get the chunk header for the first chunk in the
    //  compressed buffer and extract the uncompressed and
    //  the compressed chunk sizes
    //

    ASSERT(CompressedChunk <= EndOfCompressedBuffer - 2);

    RtlRetrieveUshort( &ChunkHeader, CompressedChunk );

    ASSERT( (ChunkHeader.Short != 0) || !Lznt1Break );
    ASSERT( (ChunkHeader.Chunk.ChunkSignature == 3) || !Lznt1Break );

    UncompressedChunkSize = GetUncompressedChunkSize(ChunkHeader);
    CompressedChunkSize = GetCompressedChunkSize(ChunkHeader);

    //
    //  Now we want to skip over chunks that precede the fragment
    //  we're after.  To do that we'll loop until the fragment
    //  offset is within the current chunk.  If it is not within
    //  the current chunk then we'll skip to the next chunk and
    //  subtract the uncompressed chunk size from the fragment offset
    //

    while (FragmentOffset >= UncompressedChunkSize) {

        //
        //  Check that the chunk actually fits in the buffer supplied
        //  by the caller
        //

        if (CompressedChunk + CompressedChunkSize > EndOfCompressedBuffer) {

            ASSERTMSG("CompressedBuffer is too small", !Lznt1Break);

            *FinalUncompressedSize = PtrToUlong(CompressedChunk);

            return STATUS_BAD_COMPRESSION_BUFFER;
        }

        //
        //  Adjust the fragment offset and move the compressed
        //  chunk pointer to the next chunk
        //

        FragmentOffset -= UncompressedChunkSize;
        CompressedChunk += CompressedChunkSize;

        //
        //  Get the next chunk header and if it is not in use
        //  then the fragment that the user wants is beyond the
        //  compressed data so we'll return a zero sized fragment
        //

        if (CompressedChunk > EndOfCompressedBuffer - 2) {

            *FinalUncompressedSize = 0;
            return STATUS_SUCCESS;
        }

        RtlRetrieveUshort( &ChunkHeader, CompressedChunk );

        if (ChunkHeader.Short == 0) {

            *FinalUncompressedSize = 0;
            return STATUS_SUCCESS;
        }

        ASSERT( (ChunkHeader.Chunk.ChunkSignature == 3) || !Lznt1Break );

        //
        //  Decode the chunk sizes for the new current chunk
        //

        UncompressedChunkSize = GetUncompressedChunkSize(ChunkHeader);
        CompressedChunkSize = GetCompressedChunkSize(ChunkHeader);
    }

    //
    //  At this point the current chunk contains the starting point
    //  for the fragment.  Now we'll loop extracting data until
    //  we've filled up the uncompressed fragment buffer or until
    //  we've run out of chunks.  Both test are done near the end of
    //  the loop
    //

    CurrentUncompressedFragment = UncompressedFragment;

    while (TRUE) {

        //
        //  Check that the chunk actually fits in the buffer supplied
        //  by the caller
        //

        if (CompressedChunk + CompressedChunkSize > EndOfCompressedBuffer) {

            ASSERTMSG("CompressedBuffer is too small", !Lznt1Break);

            *FinalUncompressedSize = PtrToUlong(CompressedChunk);

            return STATUS_BAD_COMPRESSION_BUFFER;
        }


        //
        //  Now we need to compute the amount of data to copy from the
        //  chunk.  It will be based on either to the end of the chunk
        //  size or the amount of data the user specified
        //

        CopySize = Minimum( UncompressedChunkSize - FragmentOffset, UncompressedFragmentSize );

        //
        //  Now check if the chunk contains compressed data
        //

        if (ChunkHeader.Chunk.IsChunkCompressed) {

            //
            //  The chunk is compressed but now check if the amount
            //  we need to get is the entire chunk and if so then
            //  we can do the decompress straight into the caller's
            //  buffer
            //

            if ((FragmentOffset == 0) && (CopySize == UncompressedChunkSize)) {

                if (!NT_SUCCESS(Status = LZNT1DecompressChunk( CurrentUncompressedFragment,
                                                               EndOfUncompressedFragment,
                                                               CompressedChunk + sizeof(COMPRESSED_CHUNK_HEADER),
                                                               CompressedChunk + CompressedChunkSize,
                                                               &CopySize ))) {

                    *FinalUncompressedSize = CopySize;

                    return Status;
                }

            } else {

                //
                //  The caller wants only a portion of this compressed chunk
                //  so we need to read it into our work buffer and then copy
                //  the parts from the work buffer into the caller's buffer
                //

                if (!NT_SUCCESS(Status = LZNT1DecompressChunk( (PUCHAR)WorkSpace,
                                                               &WorkSpace->Buffer[0] + sizeof(LZNT1_FRAGMENT_WORKSPACE),
                                                               CompressedChunk + sizeof(COMPRESSED_CHUNK_HEADER),
                                                               CompressedChunk + CompressedChunkSize,
                                                               &UncompressedChunkSize ))) {

                    *FinalUncompressedSize = UncompressedChunkSize;

                    return Status;
                }

                //
                //  If we got less than we were looking for then we are at the
                //  end of the file.  Remember the real uncompressed size and
                //  break out of the loop.
                //

                if ((UncompressedChunkSize - FragmentOffset) < CopySize) {

                    RtlCopyMemory( CurrentUncompressedFragment,
                                   &WorkSpace->Buffer[ FragmentOffset ],
                                   (UncompressedChunkSize - FragmentOffset) );

                    CurrentUncompressedFragment += (UncompressedChunkSize - FragmentOffset);
                    break;
                }

                RtlCopyMemory( CurrentUncompressedFragment,
                               &WorkSpace->Buffer[ FragmentOffset ],
                               CopySize );
            }

        } else {

            //
            //  The chunk is not compressed so we can do a simple copy of the
            //  data.  First verify that the compressed buffer holds this much
            //  data.
            //

            if (CompressedChunk + sizeof(COMPRESSED_CHUNK_HEADER) + FragmentOffset + CopySize > EndOfCompressedBuffer) {

                ASSERTMSG("CompressedBuffer is too small", !Lznt1Break);
                *FinalUncompressedSize = PtrToUlong(CompressedChunk);
                return STATUS_BAD_COMPRESSION_BUFFER;
            }

            RtlCopyMemory( CurrentUncompressedFragment,
                           CompressedChunk + sizeof(COMPRESSED_CHUNK_HEADER) + FragmentOffset,
                           CopySize );
        }

        //
        //  Now that we've done at least one copy make sure the fragment
        //  offset is set to zero so the next time through the loop will
        //  start at the right offset
        //

        FragmentOffset = 0;

        //
        //  Adjust the uncompressed fragment information by moving the
        //  pointer up by the copy size and subtracting copy size from
        //  the amount of data the user wants
        //

        CurrentUncompressedFragment += CopySize;
        UncompressedFragmentSize -= CopySize;

        //
        //  Now if the uncompressed fragment size is zero then we're
        //  done
        //

        if (UncompressedFragmentSize == 0) { break; }

        //
        //  Otherwise the user wants more data so we'll move to the
        //  next chunk, and then check if the chunk is is use.  If
        //  it is not in use then we the user is trying to read beyond
        //  the end of compressed data so we'll break out of the loop
        //

        CompressedChunk += CompressedChunkSize;

        if (CompressedChunk > EndOfCompressedBuffer - 2) { break; }

        RtlRetrieveUshort( &ChunkHeader, CompressedChunk );

        if (ChunkHeader.Short == 0) { break; }

        ASSERT( (ChunkHeader.Chunk.ChunkSignature == 3) || !Lznt1Break );

        //
        //  Decode the chunk sizes for the new current chunk
        //

        UncompressedChunkSize = GetUncompressedChunkSize(ChunkHeader);
        CompressedChunkSize = GetCompressedChunkSize(ChunkHeader);
    }

    //
    //  Now either we finished filling up the caller's buffer (and
    //  uncompressed fragment size is zero) or we've exhausted the
    //  compresed buffer (and chunk header is zero).  In either case
    //  we're done and we can now compute the size of the fragment
    //  that we're returning to the caller it is simply the difference
    //  between the start of the buffer and the current position
    //

    *FinalUncompressedSize = (ULONG)(CurrentUncompressedFragment - UncompressedFragment);

    return STATUS_SUCCESS;
}


NTSTATUS
RtlDescribeChunkLZNT1 (
    IN OUT PUCHAR *CompressedBuffer,
    IN PUCHAR EndOfCompressedBufferPlus1,
    OUT PUCHAR *ChunkBuffer,
    OUT PULONG ChunkSize
    )

/*++

Routine Description:

    This routine takes as input a compressed buffer, and returns
    a description of the current chunk in that buffer, updating
    the CompressedBuffer pointer to point to the next chunk (if
    there is one).

Arguments:

    CompressedBuffer - Supplies a pointer to the current chunk in
        the compressed data, and returns pointing to the next chunk

    EndOfCompressedBufferPlus1 - Points at first byte beyond
        compressed buffer

    ChunkBuffer - Receives a pointer to the chunk, if ChunkSize
        is nonzero, else undefined

    ChunkSize - Receives the size of the current chunk pointed
        to by CompressedBuffer.  Returns 0 if STATUS_NO_MORE_ENTRIES.

Return Value:

    STATUS_SUCCESS - the chunk size is being returned

    STATUS_BAD_COMPRESSION_BUFFER - the input compressed buffer is
        ill-formed.

    STATUS_NO_MORE_ENTRIES - There is no chunk at the current pointer.

--*/

{
    COMPRESSED_CHUNK_HEADER ChunkHeader;
    NTSTATUS Status = STATUS_NO_MORE_ENTRIES;

    //
    //  First initialize outputs
    //

    *ChunkBuffer = *CompressedBuffer;
    *ChunkSize = 0;

    //
    //  Make sure that the compressed buffer is at least four bytes long to
    //  start with, otherwise just return a zero chunk.
    //

    if (*CompressedBuffer <= EndOfCompressedBufferPlus1 - 4) {

        RtlRetrieveUshort( &ChunkHeader, *CompressedBuffer );

        //
        //  Check for end of chunks, terminated by USHORT of 0.
        //  First assume there are no more.
        //

        if (ChunkHeader.Short != 0) {

            Status = STATUS_SUCCESS;

            *ChunkSize = GetCompressedChunkSize(ChunkHeader);
            *CompressedBuffer += *ChunkSize;

            //
            //  Check that the chunk actually fits in the buffer supplied
            //  by the caller.  If not, restore *CompressedBuffer for debug!
            //

            if ((*CompressedBuffer > EndOfCompressedBufferPlus1) ||
                (ChunkHeader.Chunk.ChunkSignature != 3)) {

                ASSERTMSG("CompressedBuffer is bad or too small", !Lznt1Break);

                *CompressedBuffer -= *ChunkSize;

                Status = STATUS_BAD_COMPRESSION_BUFFER;

            //
            //  First make sure the chunk contains compressed data
            //

            } else if (!ChunkHeader.Chunk.IsChunkCompressed) {

                //
                //  The uncompressed chunk must be exactly this size!
                //  If not, restore *CompressedBuffer for debug!
                //

                if (*ChunkSize != MAX_UNCOMPRESSED_CHUNK_SIZE + 2) {

                    ASSERTMSG("Uncompressed chunk is wrong size", !Lznt1Break);

                    *CompressedBuffer -= *ChunkSize;

                    Status = STATUS_BAD_COMPRESSION_BUFFER;

                //
                //  The chunk does not contain compressed data so we need to
                //  remove the chunk header from the chunk description.
                //

                } else {

                    *ChunkBuffer += 2;
                    *ChunkSize -= 2;
                }

            //
            //  Otherwise we have a compressed chunk, and we only need to
            //  see if it is all zeros!  Since the header is already interpreted,
            //  we only have to see if there is exactly one literal and if it
            //  is zero - it doesn't matter what the copy token says - we have
            //  a chunk of zeros!
            //

            } else if ((*ChunkSize == 6) && (*(*ChunkBuffer + 2) == 2) && (*(*ChunkBuffer + 3) == 0)) {

                *ChunkSize = 0;
            }
        }
    }

    return Status;
}


NTSTATUS
RtlReserveChunkLZNT1 (
    IN OUT PUCHAR *CompressedBuffer,
    IN PUCHAR EndOfCompressedBufferPlus1,
    OUT PUCHAR *ChunkBuffer,
    IN ULONG ChunkSize
    )

/*++

Routine Description:

    This routine reserves space for a chunk of the specified
    size in the buffer, writing in a chunk header if necessary
    (uncompressed or all zeros case).  On return the CompressedBuffer
    pointer points to the next chunk.

Arguments:

    CompressedBuffer - Supplies a pointer to the current chunk in
        the compressed data, and returns pointing to the next chunk

    EndOfCompressedBufferPlus1 - Points at first byte beyond
        compressed buffer

    ChunkBuffer - Receives a pointer to the chunk, if ChunkSize
        is nonzero, else undefined

    ChunkSize - Supplies the compressed size of the chunk to be received.
                Two special values are 0 and MAX_UNCOMPRESSED_CHUNK_SIZE (4096).
                0 means the chunk should be filled with a pattern that equates
                to 4096 0's.  4096 implies that the compression routine should
                prepare to receive all of the data in uncompressed form.

Return Value:

    STATUS_SUCCESS - the chunk size is being returned

    STATUS_BUFFER_TOO_SMALL - the compressed buffer is too small to hold the
        compressed data.

--*/

{
    COMPRESSED_CHUNK_HEADER ChunkHeader;
    BOOLEAN Compressed;
    PUCHAR Tail, NextChunk, DontCare;
    ULONG Size;
    NTSTATUS Status;

    ASSERT(ChunkSize <= MAX_UNCOMPRESSED_CHUNK_SIZE);

    //
    //  Calculate the address of the tail of this buffer and its
    //  size, so it can be moved before we store anything.
    //

    Tail = NextChunk = *CompressedBuffer;
    while (NT_SUCCESS(Status = RtlDescribeChunkLZNT1( &NextChunk,
                                                      EndOfCompressedBufferPlus1,
                                                      &DontCare,
                                                      &Size))) {

        //
        //  First time through the loop, capture the address of the next chunk.
        //

        if (Tail == *CompressedBuffer) {
            Tail = NextChunk;
        }
    }

    //
    //  The buffer could be invalid.
    //

    if (Status == STATUS_NO_MORE_ENTRIES) {

        //
        //  The only way to successfully terminate the loop is by finding a USHORT
        //  terminator of 0.  Now calculate the size including the final USHORT
        //  we stopped on.
        //

        Size = (ULONG) (NextChunk - Tail + sizeof(USHORT));

        //
        //  First initialize outputs
        //

        Status = STATUS_BUFFER_TOO_SMALL;
        *ChunkBuffer = *CompressedBuffer;

        //
        //  Make sure that the compressed buffer is at least four bytes long to
        //  start with, otherwise just return a zero chunk.
        //

        if (*CompressedBuffer <= (EndOfCompressedBufferPlus1 - ChunkSize)) {

            //
            //  If the chunk is uncompressed, then we have to adjust the
            //  chunk description for the header.
            //

            if (ChunkSize == MAX_UNCOMPRESSED_CHUNK_SIZE) {

                //
                //  Increase ChunkSize to include header.
                //

                ChunkSize += 2;

                //
                //  Move the tail now that we know where to put it.
                //

                if ((*CompressedBuffer + ChunkSize + Size) <= EndOfCompressedBufferPlus1) {

                    RtlMoveMemory( *CompressedBuffer + ChunkSize, Tail, Size );

                    //
                    //  Build the header and store it for an uncompressed chunk.
                    //

                    SetCompressedChunkHeader( ChunkHeader,
                                              MAX_UNCOMPRESSED_CHUNK_SIZE + 2,
                                              FALSE );

                    RtlStoreUshort( (*CompressedBuffer), ChunkHeader.Short );

                    //
                    //  Advance to where the uncompressed data goes.
                    //

                    *ChunkBuffer += 2;

                    Status = STATUS_SUCCESS;
                }

            //
            //  Otherwise, if this is a zero chunk we have to build it.
            //

            } else if (ChunkSize == 0) {

                //
                //  It takes 6 bytes to describe a chunk of zeros.
                //

                ChunkSize = 6;

                if ((*CompressedBuffer + ChunkSize + Size) <= EndOfCompressedBufferPlus1) {

                    //
                    //  Move the tail now that we know where to put it.
                    //

                    RtlMoveMemory( *CompressedBuffer + ChunkSize, Tail, Size );

                    //
                    //  Build the header and store it
                    //

                    SetCompressedChunkHeader( ChunkHeader,
                                              6,
                                              TRUE );

                    RtlStoreUshort( (*CompressedBuffer), ChunkHeader.Short );

                    //
                    //  Now store the mask byte with one literal and the literal
                    //  is 0.
                    //

                    RtlStoreUshort( (*CompressedBuffer + 2), (USHORT)2 );

                    //
                    //  Now store the copy token for copying 4095 bytes from
                    //  the preceding byte (stored as offset 0).
                    //

                    RtlStoreUshort( (*CompressedBuffer + 4), (USHORT)(4095-3));

                    Status = STATUS_SUCCESS;
                }

            //
            //  Otherwise we have a normal compressed chunk.
            //

            } else {

                //
                //  Move the tail now that we know where to put it.
                //

                if ((*CompressedBuffer + ChunkSize + Size) <= EndOfCompressedBufferPlus1) {

                    RtlMoveMemory( *CompressedBuffer + ChunkSize, Tail, Size );

                    Status = STATUS_SUCCESS;
                }
            }

            //
            //  Advance the *CompressedBuffer before return
            //

            *CompressedBuffer += ChunkSize;
        }
    }

    return Status;
}


//
//  The Copy token is two bytes in size.
//  Our definition uses a union to make it easier to set and retrieve token values.
//
//  Copy Token
//
//          Length            Displacement
//
//      12 bits 3 to 4098    4 bits 1 to 16
//      11 bits 3 to 2050    5 bits 1 to 32
//      10 bits 3 to 1026    6 bits 1 to 64
//       9 bits 3 to 514     7 bits 1 to 128
//       8 bits 3 to 258     8 bits 1 to 256
//       7 bits 3 to 130     9 bits 1 to 512
//       6 bits 3 to 66     10 bits 1 to 1024
//       5 bits 3 to 34     11 bits 1 to 2048
//       4 bits 3 to 18     12 bits 1 to 4096
//

#define FORMAT412 0
#define FORMAT511 1
#define FORMAT610 2
#define FORMAT79  3
#define FORMAT88  4
#define FORMAT97  5
#define FORMAT106 6
#define FORMAT115 7
#define FORMAT124 8

//                                4/12  5/11  6/10   7/9   8/8   9/7  10/6  11/5  12/4

ULONG FormatMaxLength[]       = { 4098, 2050, 1026,  514,  258,  130,   66,   34,   18 };
ULONG FormatMaxDisplacement[] = {   16,   32,   64,  128,  256,  512, 1024, 2048, 4096 };

typedef union _LZNT1_COPY_TOKEN {

    struct { USHORT Length : 12; USHORT Displacement :  4; } Fields412;
    struct { USHORT Length : 11; USHORT Displacement :  5; } Fields511;
    struct { USHORT Length : 10; USHORT Displacement :  6; } Fields610;
    struct { USHORT Length :  9; USHORT Displacement :  7; } Fields79;
    struct { USHORT Length :  8; USHORT Displacement :  8; } Fields88;
    struct { USHORT Length :  7; USHORT Displacement :  9; } Fields97;
    struct { USHORT Length :  6; USHORT Displacement : 10; } Fields106;
    struct { USHORT Length :  5; USHORT Displacement : 11; } Fields115;
    struct { USHORT Length :  4; USHORT Displacement : 12; } Fields124;

    UCHAR Bytes[2];

} LZNT1_COPY_TOKEN, *PLZNT1_COPY_TOKEN;

//
//  USHORT
//  GetLZNT1Length (
//      IN COPY_TOKEN_FORMAT Format,
//      IN LZNT1_COPY_TOKEN CopyToken
//      );
//
//  USHORT
//  GetLZNT1Displacement (
//      IN COPY_TOKEN_FORMAT Format,
//      IN LZNT1_COPY_TOKEN CopyToken
//      );
//
//  VOID
//  SetLZNT1 (
//      IN COPY_TOKEN_FORMAT Format,
//      IN LZNT1_COPY_TOKEN CopyToken,
//      IN USHORT Length,
//      IN USHORT Displacement
//      );
//

#define GetLZNT1Length(F,CT) (                   \
    ( F == FORMAT412 ? (CT).Fields412.Length + 3 \
    : F == FORMAT511 ? (CT).Fields511.Length + 3 \
    : F == FORMAT610 ? (CT).Fields610.Length + 3 \
    : F == FORMAT79  ? (CT).Fields79.Length  + 3 \
    : F == FORMAT88  ? (CT).Fields88.Length  + 3 \
    : F == FORMAT97  ? (CT).Fields97.Length  + 3 \
    : F == FORMAT106 ? (CT).Fields106.Length + 3 \
    : F == FORMAT115 ? (CT).Fields115.Length + 3 \
    :                  (CT).Fields124.Length + 3 \
    )                                            \
)

#define GetLZNT1Displacement(F,CT) (                   \
    ( F == FORMAT412 ? (CT).Fields412.Displacement + 1 \
    : F == FORMAT511 ? (CT).Fields511.Displacement + 1 \
    : F == FORMAT610 ? (CT).Fields610.Displacement + 1 \
    : F == FORMAT79  ? (CT).Fields79.Displacement  + 1 \
    : F == FORMAT88  ? (CT).Fields88.Displacement  + 1 \
    : F == FORMAT97  ? (CT).Fields97.Displacement  + 1 \
    : F == FORMAT106 ? (CT).Fields106.Displacement + 1 \
    : F == FORMAT115 ? (CT).Fields115.Displacement + 1 \
    :                  (CT).Fields124.Displacement + 1 \
    )                                                  \
)

#define SetLZNT1(F,CT,L,D) {                                                                             \
    if      (F == FORMAT412) { (CT).Fields412.Length = (L) - 3; (CT).Fields412.Displacement = (D) - 1; } \
    else if (F == FORMAT511) { (CT).Fields511.Length = (L) - 3; (CT).Fields511.Displacement = (D) - 1; } \
    else if (F == FORMAT610) { (CT).Fields610.Length = (L) - 3; (CT).Fields610.Displacement = (D) - 1; } \
    else if (F == FORMAT79)  { (CT).Fields79.Length  = (L) - 3; (CT).Fields79.Displacement  = (D) - 1; } \
    else if (F == FORMAT88)  { (CT).Fields88.Length  = (L) - 3; (CT).Fields88.Displacement  = (D) - 1; } \
    else if (F == FORMAT97)  { (CT).Fields97.Length  = (L) - 3; (CT).Fields97.Displacement  = (D) - 1; } \
    else if (F == FORMAT106) { (CT).Fields106.Length = (L) - 3; (CT).Fields106.Displacement = (D) - 1; } \
    else if (F == FORMAT115) { (CT).Fields115.Length = (L) - 3; (CT).Fields115.Displacement = (D) - 1; } \
    else                     { (CT).Fields124.Length = (L) - 3; (CT).Fields124.Displacement = (D) - 1; } \
}



//
//  Local support routine
//

NTSTATUS
LZNT1CompressChunk (
    IN PLZNT1_MATCH_FUNCTION MatchFunction,
    IN PUCHAR UncompressedBuffer,
    IN PUCHAR EndOfUncompressedBufferPlus1,
    OUT PUCHAR CompressedBuffer,
    IN PUCHAR EndOfCompressedBufferPlus1,
    OUT PULONG FinalCompressedChunkSize,
    IN PVOID WorkSpace
    )

/*++

Routine Description:

    This routine takes as input an uncompressed chunk and produces
    one compressed chunk provided the compressed data fits within
    the specified destination buffer.

    The LZNT1 format used to store the compressed buffer.

    An output variable indicates the number of bytes used to store
    the compressed chunk.

Arguments:

    UncompressedBuffer - Supplies a pointer to the uncompressed chunk.

    EndOfUncompressedBufferPlus1 - Supplies a pointer to the next byte
        following the end of the uncompressed buffer.  This is supplied
        instead of the size in bytes because our caller and ourselves
        test against the pointer and by passing the pointer we get to
        skip the code to compute it each time.

    CompressedBuffer - Supplies a pointer to where the compressed chunk
        is to be stored.

    EndOfCompressedBufferPlus1 - Supplies a pointer to the next
        byte following the end of the compressed buffer.

    FinalCompressedChunkSize - Receives the number of bytes needed in
        the compressed buffer to store the compressed chunk.

Return Value:

    STATUS_SUCCESS - the compression worked without a hitch.

    STATUS_BUFFER_ALL_ZEROS - the compression worked without a hitch and in
        addition the input chunk was all zeros.

    STATUS_BUFFER_TOO_SMALL - the compressed buffer is too small to hold the
        compressed data.

--*/

{
    PUCHAR EndOfCompressedChunkPlus1;

    PUCHAR InputPointer;
    PUCHAR OutputPointer;

    PUCHAR FlagPointer;
    UCHAR FlagByte;
    ULONG FlagBit;

    LONG Length;
    LONG Displacement;

    LZNT1_COPY_TOKEN CopyToken;

    COMPRESSED_CHUNK_HEADER ChunkHeader;

    UCHAR NullCharacter = 0;

    ULONG Format = FORMAT412;

    //
    //  First adjust the end of the uncompressed buffer pointer to the smaller
    //  of what we're passed in and the uncompressed chunk size.  We use this
    //  to make sure we never compress more than a chunk worth at a time
    //

    if ((UncompressedBuffer + MAX_UNCOMPRESSED_CHUNK_SIZE) < EndOfUncompressedBufferPlus1) {

        EndOfUncompressedBufferPlus1 = UncompressedBuffer + MAX_UNCOMPRESSED_CHUNK_SIZE;
    }

    //
    //  Now set the end of the compressed chunk pointer to be the smaller of the
    //  compressed size necessary to hold the data in an uncompressed form and
    //  the compressed buffer size.  We use this to decide if we can't compress
    //  any more because the buffer is too small or just because the data
    //  doesn't compress very well.
    //

    if ((CompressedBuffer + MAX_UNCOMPRESSED_CHUNK_SIZE - 1) < EndOfCompressedBufferPlus1) {

        EndOfCompressedChunkPlus1 = CompressedBuffer + MAX_UNCOMPRESSED_CHUNK_SIZE - 1;

    } else {

        EndOfCompressedChunkPlus1 = EndOfCompressedBufferPlus1;
    }

    //
    //  Now set the input and output pointers to the next byte we are
    //  go to process and asser that the user gave use buffers that were
    //  large enough to hold the minimum size chunks
    //

    InputPointer = UncompressedBuffer;
    OutputPointer = CompressedBuffer + sizeof(COMPRESSED_CHUNK_HEADER);

    ASSERT(InputPointer < EndOfUncompressedBufferPlus1);
    //**** ASSERT(OutputPointer + 2 <= EndOfCompressedChunkPlus1);

    //
    //  The flag byte stores a copy of the flags for the current
    //  run and the flag bit denotes the current bit position within
    //  the flag that we are processing.  The Flag pointer denotes
    //  where in the compressed buffer we will store the current
    //  flag byte
    //

    FlagPointer = OutputPointer++;
    FlagBit = 0;
    FlagByte = 0;

    ChunkHeader.Short = 0;

    //
    //  While there is some more data to be compressed we will do the
    //  following loop
    //

    ((PLZNT1_STANDARD_WORKSPACE)WorkSpace)->UncompressedBuffer = UncompressedBuffer;
    ((PLZNT1_STANDARD_WORKSPACE)WorkSpace)->EndOfUncompressedBufferPlus1 = EndOfUncompressedBufferPlus1;
    ((PLZNT1_STANDARD_WORKSPACE)WorkSpace)->MaxLength = FormatMaxLength[FORMAT412];

    while (InputPointer < EndOfUncompressedBufferPlus1) {

        while (UncompressedBuffer + FormatMaxDisplacement[Format] < InputPointer) {

            Format += 1;
            ((PLZNT1_STANDARD_WORKSPACE)WorkSpace)->MaxLength = FormatMaxLength[Format];
        }

        //
        //  Search for a string in the Lempel
        //

        Length = 0;
        if ((InputPointer + 3) <= EndOfUncompressedBufferPlus1) {

            Length = (MatchFunction)( InputPointer, WorkSpace );
        }

        //
        //  If the return length is zero then we need to output
        //  a literal.  We clear the flag bit to denote the literal
        //  output the charcter and build up a character bits
        //  composite that if it is still zero when we are done then
        //  we know the uncompressed buffer contained only zeros.
        //

        if (!Length) {

            //
            //  There is more data to output now make sure the output
            //  buffer is not already full and can contain at least one
            //  more byte
            //

            if (OutputPointer >= EndOfCompressedChunkPlus1) { break; }

            ClearFlag(FlagByte, (1 << FlagBit));

            NullCharacter |= *(OutputPointer++) = *(InputPointer++);

        } else {

            //
            //  We need to output two byte, now make sure that
            //  the output buffer can contain at least two more
            //  bytes.
            //

            if ((OutputPointer+1) >= EndOfCompressedChunkPlus1) { break; }

            //
            //  Compute the displacement from the current pointer
            //  to the matched string
            //

            Displacement = (ULONG)(InputPointer - ((PLZNT1_STANDARD_WORKSPACE)WorkSpace)->MatchedString);

            SetFlag(FlagByte, (1 << FlagBit));

            SetLZNT1(Format, CopyToken, (USHORT)Length, (USHORT)Displacement);

            *(OutputPointer++) = CopyToken.Bytes[0];
            *(OutputPointer++) = CopyToken.Bytes[1];

            InputPointer += Length;
        }

        //
        //  Now adjust the flag bit and check if the flag byte
        //  should now be output.  If so output the flag byte
        //  and scarf up a new byte in the output buffer for the
        //  next flag byte.  Do not advance OutputPointer if we
        //  have no more input anyway!
        //

        FlagBit = (FlagBit + 1) % 8;

        if (!FlagBit && (InputPointer < EndOfUncompressedBufferPlus1)) {

            *FlagPointer = FlagByte;
            FlagByte = 0;

            FlagPointer = (OutputPointer++);
        }
    }

    //
    //  We've exited the preceeding loop because either the input buffer is
    //  all compressed or because we ran out of space in the output buffer.
    //  Check here if the input buffer is not exhasted (i.e., we ran out
    //  of space)
    //

    if (InputPointer < EndOfUncompressedBufferPlus1) {

        //
        //  We ran out of space, but now if the total space available
        //  for the compressed chunk is equal to the uncompressed data plus
        //  the header then we will make this an uncompressed chunk and copy
        //  over the uncompressed data
        //

        if ((CompressedBuffer + MAX_UNCOMPRESSED_CHUNK_SIZE + sizeof(COMPRESSED_CHUNK_HEADER)) <= EndOfCompressedBufferPlus1) {

            RtlCopyMemory( CompressedBuffer + sizeof(COMPRESSED_CHUNK_HEADER),
                           UncompressedBuffer,
                           MAX_UNCOMPRESSED_CHUNK_SIZE );

            *FinalCompressedChunkSize = MAX_UNCOMPRESSED_CHUNK_SIZE + sizeof(COMPRESSED_CHUNK_HEADER);

            SetCompressedChunkHeader( ChunkHeader,
                                      (USHORT)*FinalCompressedChunkSize,
                                      FALSE );

            RtlStoreUshort( CompressedBuffer, ChunkHeader.Short );

            return STATUS_SUCCESS;
        }

        //
        //  Otherwise the input buffer really is too small to store the
        //  compressed chuunk
        //

        return STATUS_BUFFER_TOO_SMALL;
    }

    //
    //  At this point the entire input buffer has been compressed so we need
    //  to output the last flag byte, provided it fits in the compressed buffer,
    //  set and store the chunk header.  Now if the Flag pointer doesn't fit
    //  in the output buffer that is because it is one beyond the end and
    //  we incremented output pointer too far so now bring output pointer
    //  back down.
    //

    if (FlagPointer < EndOfCompressedChunkPlus1) {

        *FlagPointer = FlagByte;

    } else {

        OutputPointer--;
    }

    *FinalCompressedChunkSize = (ULONG)(OutputPointer - CompressedBuffer);

    SetCompressedChunkHeader( ChunkHeader,
                              (USHORT)*FinalCompressedChunkSize,
                              TRUE );

    RtlStoreUshort( CompressedBuffer, ChunkHeader.Short );

    //
    //  Now if the only literal we ever output was a null then the
    //  input buffer was all zeros.
    //

    if (!NullCharacter) {

        return STATUS_BUFFER_ALL_ZEROS;
    }

    //
    //  Otherwise return to our caller
    //

    return STATUS_SUCCESS;
}


#if !defined(_ALPHA_)
#if !defined(_MIPS_)
#if !defined(_PPC_)
#if !defined(i386)
//
//  Local support routine
//

NTSTATUS
LZNT1DecompressChunk (
    OUT PUCHAR UncompressedBuffer,
    IN PUCHAR EndOfUncompressedBufferPlus1,
    IN PUCHAR CompressedBuffer,
    IN PUCHAR EndOfCompressedBufferPlus1,
    OUT PULONG FinalUncompressedChunkSize
    )

/*++

Routine Description:

    This routine takes as input a compressed chunk and produces its
    uncompressed equivalent chunk provided the uncompressed data fits
    within the specified destination buffer.

    The compressed buffer must be stored in the LZNT1 format.

    An output variable indicates the number of bytes used to store the
    uncompressed data.

Arguments:

    UncompressedBuffer - Supplies a pointer to where the uncompressed
        chunk is to be stored.

    EndOfUncompressedBufferPlus1 - Supplies a pointer to the next byte
        following the end of the uncompressed buffer.  This is supplied
        instead of the size in bytes because our caller and ourselves
        test against the pointer and by passing the pointer we get to
        skip the code to compute it each time.

    CompressedBuffer - Supplies a pointer to the compressed chunk.  (This
        pointer has already been adjusted to point past the chunk header.)

    EndOfCompressedBufferPlus1 - Supplies a pointer to the next
        byte following the end of the compressed buffer.

    FinalUncompressedChunkSize - Receives the number of bytes needed in
        the uncompressed buffer to store the uncompressed chunk.

Return Value:

    STATUS_SUCCESS - the decompression worked without a hitch.

    STATUS_BAD_COMPRESSION_BUFFER - the input compressed buffer is
        ill-formed.

--*/

{
    PUCHAR OutputPointer;
    PUCHAR InputPointer;

    UCHAR FlagByte;
    ULONG FlagBit;

    ULONG Format = FORMAT412;

    //
    //  The two pointers will slide through our input and input buffer.
    //  For the input buffer we skip over the chunk header.
    //

    OutputPointer = UncompressedBuffer;
    InputPointer = CompressedBuffer;

    //
    //  The flag byte stores a copy of the flags for the current
    //  run and the flag bit denotes the current bit position within
    //  the flag that we are processing
    //

    FlagByte = *(InputPointer++);
    FlagBit = 0;

    //
    //  While we haven't exhausted either the input or output buffer
    //  we will do some more decompression
    //

    while ((OutputPointer < EndOfUncompressedBufferPlus1) && (InputPointer < EndOfCompressedBufferPlus1)) {

        while (UncompressedBuffer + FormatMaxDisplacement[Format] < OutputPointer) { Format += 1; }

        //
        //  Check the current flag if it is zero then the current
        //  input token is a literal byte that we simply copy over
        //  to the output buffer
        //

        if (!FlagOn(FlagByte, (1 << FlagBit))) {

            *(OutputPointer++) = *(InputPointer++);

        } else {

            LZNT1_COPY_TOKEN CopyToken;
            LONG Displacement;
            LONG Length;

            //
            //  The current input is a copy token so we'll get the
            //  copy token into our variable and extract the
            //  length and displacement from the token
            //

            if (InputPointer+1 >= EndOfCompressedBufferPlus1) {

                *FinalUncompressedChunkSize = PtrToUlong(InputPointer);

                return STATUS_BAD_COMPRESSION_BUFFER;
            }

            //
            //  Now grab the next input byte and extract the
            //  length and displacement from the copy token
            //

            CopyToken.Bytes[0] = *(InputPointer++);
            CopyToken.Bytes[1] = *(InputPointer++);

            Displacement = GetLZNT1Displacement(Format, CopyToken);
            Length = GetLZNT1Length(Format, CopyToken);

            //
            //  At this point we have the length and displacement
            //  from the copy token, now we need to make sure that the
            //  displacement doesn't send us outside the uncompressed buffer
            //

            if (Displacement > (OutputPointer - UncompressedBuffer)) {

                *FinalUncompressedChunkSize = PtrToUlong(InputPointer);

                return STATUS_BAD_COMPRESSION_BUFFER;
            }

            //
            //  We also need to adjust the length to keep the copy from
            //  overflowing the output buffer
            //

            if ((OutputPointer + Length) >= EndOfUncompressedBufferPlus1) {

                Length = (ULONG)(EndOfUncompressedBufferPlus1 - OutputPointer);
            }

            //
            //  Now we copy bytes.  We cannot use Rtl Move Memory here because
            //  it does the copy backwards from what the LZ algorithm needs.
            //

            while (Length > 0) {

                *(OutputPointer) = *(OutputPointer-Displacement);

                Length -= 1;
                OutputPointer += 1;
            }
        }

        //
        //  Before we go back to the start of the loop we need to adjust the
        //  flag bit value (it goes from 0, 1, ... 7) and if the flag bit
        //  is back to zero we need to read in the next flag byte.  In this
        //  case we are at the end of the input buffer we'll just break out
        //  of the loop because we're done.
        //

        FlagBit = (FlagBit + 1) % 8;

        if (!FlagBit) {

            if (InputPointer >= EndOfCompressedBufferPlus1) { break; }

            FlagByte = *(InputPointer++);
        }
    }

    //
    //  The decompression is done so now set the final uncompressed
    //  chunk size and return success to our caller
    //

    *FinalUncompressedChunkSize = (ULONG)(OutputPointer - UncompressedBuffer);

    return STATUS_SUCCESS;
}
#endif // i386
#endif // _MIPS_
#endif // _PPC_
#endif // _ALPHA_


//
//  Local support routine
//

ULONG
LZNT1FindMatchStandard (
    IN PUCHAR ZivString,
    IN PLZNT1_STANDARD_WORKSPACE WorkSpace
    )

/*++

Routine Description:

    This routine does the compression lookup.  It locates
    a match for the ziv within a specified uncompressed buffer.

Arguments:

    ZivString - Supplies a pointer to the Ziv in the uncompressed buffer.
        The Ziv is the string we want to try and find a match for.

Return Value:

    Returns the length of the match if the match is greater than three
    characters otherwise return 0.

--*/

{
    PUCHAR UncompressedBuffer = WorkSpace->UncompressedBuffer;
    PUCHAR EndOfUncompressedBufferPlus1 = WorkSpace->EndOfUncompressedBufferPlus1;
    ULONG MaxLength = WorkSpace->MaxLength;

    ULONG Index;

    PUCHAR FirstEntry;
    ULONG  FirstLength;

    PUCHAR SecondEntry;
    ULONG  SecondLength;

    //
    //  First check if the Ziv is within two bytes of the end of
    //  the uncompressed buffer, if so then we can't match
    //  three or more characters
    //

    Index = ((40543*((((ZivString[0]<<4)^ZivString[1])<<4)^ZivString[2]))>>4) & 0xfff;

    FirstEntry  = WorkSpace->IndexPTable[Index][0];
    FirstLength = 0;

    SecondEntry  = WorkSpace->IndexPTable[Index][1];
    SecondLength = 0;

    //
    //  Check if first entry is good, and if so then get its length
    //

    if ((FirstEntry >= UncompressedBuffer) &&    //  is it within the uncompressed buffer?
        (FirstEntry < ZivString)           &&

        (FirstEntry[0] == ZivString[0])    &&    //  do at least 3 characters match?
        (FirstEntry[1] == ZivString[1])    &&
        (FirstEntry[2] == ZivString[2])) {

        FirstLength = 3;

        while ((FirstLength < MaxLength)

                 &&

               (ZivString + FirstLength < EndOfUncompressedBufferPlus1)

                 &&

               (ZivString[FirstLength] == FirstEntry[FirstLength])) {

            FirstLength++;
        }
    }

    //
    //  Check if second entry is good, and if so then get its length
    //

    if ((SecondEntry >= UncompressedBuffer) &&    //  is it within the uncompressed buffer?
        (SecondEntry < ZivString)           &&

        (SecondEntry[0] == ZivString[0])    &&    //  do at least 3 characters match?
        (SecondEntry[1] == ZivString[1])    &&
        (SecondEntry[2] == ZivString[2])) {

        SecondLength = 3;

        while ((SecondLength < MaxLength)

                 &&

               (ZivString + SecondLength< EndOfUncompressedBufferPlus1)

                 &&

               (ZivString[SecondLength] == SecondEntry[SecondLength])) {

            SecondLength++;
        }
    }

    if ((FirstLength >= SecondLength)) {

        WorkSpace->IndexPTable[Index][1] = FirstEntry;
        WorkSpace->IndexPTable[Index][0] = ZivString;

        WorkSpace->MatchedString = FirstEntry;
        return FirstLength;
    }

    WorkSpace->IndexPTable[Index][1] = FirstEntry;
    WorkSpace->IndexPTable[Index][0] = ZivString;

    WorkSpace->MatchedString = SecondEntry;
    return SecondLength;
}


//
//  Local support routine
//

ULONG
LZNT1FindMatchMaximum (
    IN PUCHAR ZivString,
    IN PLZNT1_MAXIMUM_WORKSPACE WorkSpace
    )

/*++

Routine Description:

    This routine does the compression lookup.  It locates
    a match for the ziv within a specified uncompressed buffer.

    If the matched string is two or more characters long then this
    routine does not update the lookup state information.

Arguments:

    ZivString - Supplies a pointer to the Ziv in the uncompressed buffer.
        The Ziv is the string we want to try and find a match for.

Return Value:

    Returns the length of the match if the match is greater than three
    characters otherwise return 0.

--*/

{
    PUCHAR UncompressedBuffer = WorkSpace->UncompressedBuffer;
    PUCHAR EndOfUncompressedBufferPlus1 = WorkSpace->EndOfUncompressedBufferPlus1;
    ULONG MaxLength = WorkSpace->MaxLength;

    ULONG i;
    ULONG BestMatchedLength;
    PUCHAR q;

    //
    //  First check if the Ziv is within two bytes of the end of
    //  the uncompressed buffer, if so then we can't match
    //  three or more characters
    //

    BestMatchedLength = 0;

    for (q = UncompressedBuffer; q < ZivString; q += 1) {

        i = 0;

        while ((i < MaxLength)

                 &&

               (ZivString + i < EndOfUncompressedBufferPlus1)

                 &&

               (ZivString[i] == q[i])) {

            i++;
        }

        if (i >= BestMatchedLength) {

            BestMatchedLength = i;
            WorkSpace->MatchedString = q;
        }
    }

    if (BestMatchedLength < 3) {

        return 0;

    } else {

        return BestMatchedLength;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\rtl\nls.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    nls.c

Abstract:

    This module implements NLS support functions for NT.

Author:

    Mark Lucovsky (markl) 16-Apr-1991

Environment:

    Kernel or user-mode

Revision History:

    16-Feb-1993    JulieB    Added Upcase Rtl Routines.
    08-Mar-1993    JulieB    Moved Upcase Macro to ntrtlp.h.
    02-Apr-1993    JulieB    Fixed RtlAnsiCharToUnicodeChar to use transl. tbls.
    02-Apr-1993    JulieB    Fixed BUFFER_TOO_SMALL check.
    28-May-1993    JulieB    Fixed code to properly handle DBCS.

--*/

#include "ntrtlp.h"

NTSTATUS
RtlAnsiStringToUnicodeString(
    OUT PUNICODE_STRING DestinationString,
    IN PANSI_STRING SourceString,
    IN BOOLEAN AllocateDestinationString
    )

/*++

Routine Description:

    This functions converts the specified ansi source string into a
    Unicode string. The translation is done with respect to the
    current system locale information.

Arguments:

    DestinationString - Returns a unicode string that is equivalent to
        the ansi source string. The maximum length field is only
        set if AllocateDestinationString is TRUE.

    SourceString - Supplies the ansi source string that is to be
        converted to unicode.

    AllocateDestinationString - Supplies a flag that controls whether or
        not this API allocates the buffer space for the destination
        string.  If it does, then the buffer must be deallocated using
        RtlFreeUnicodeString (note that only storage for
        DestinationString->Buffer is allocated by this API).

Return Value:

    SUCCESS - The conversion was successful

    !SUCCESS - The operation failed.  No storage was allocated and no
        conversion was done.  None.

--*/

{
    ULONG UnicodeLength;
    ULONG Index;
    NTSTATUS st;

    RTL_PAGED_CODE();

    UnicodeLength = RtlAnsiStringToUnicodeSize(SourceString);
    if ( UnicodeLength > MAXUSHORT ) {
        return STATUS_INVALID_PARAMETER_2;
        }

    DestinationString->Length = (USHORT)(UnicodeLength - sizeof(UNICODE_NULL));
    if ( AllocateDestinationString ) {
        DestinationString->MaximumLength = (USHORT)UnicodeLength;
        DestinationString->Buffer = RtlAllocateStringRoutine(UnicodeLength);
        if ( !DestinationString->Buffer ) {
            return STATUS_NO_MEMORY;
            }
        }
    else {
        if ( DestinationString->Length >= DestinationString->MaximumLength ) {
            return STATUS_BUFFER_OVERFLOW;
            }
        }

    st = RtlMultiByteToUnicodeN(
             DestinationString->Buffer,
             DestinationString->Length,
             &Index,
             SourceString->Buffer,
             SourceString->Length
             );

    if (!NT_SUCCESS(st)) {
        if ( AllocateDestinationString ) {
            RtlFreeStringRoutine(DestinationString->Buffer);
            DestinationString->Buffer = NULL;
        }

        return st;
    }

    DestinationString->Buffer[Index / sizeof(WCHAR)] = UNICODE_NULL;

    return STATUS_SUCCESS;
}

NTSTATUS
RtlUnicodeStringToAnsiString(
    OUT PANSI_STRING DestinationString,
    IN PUNICODE_STRING SourceString,
    IN BOOLEAN AllocateDestinationString
    )

/*++

Routine Description:

    This functions converts the specified unicode source string into an
    ansi string. The translation is done with respect to the
    current system locale information.

Arguments:

    DestinationString - Returns an ansi string that is equivalent to the
        unicode source string.  If the translation can not be done,
        an error is returned.  The maximum length field is only set if
        AllocateDestinationString is TRUE.

    SourceString - Supplies the unicode source string that is to be
        converted to ansi.

    AllocateDestinationString - Supplies a flag that controls whether or
        not this API allocates the buffer space for the destination
        string.  If it does, then the buffer must be deallocated using
        RtlFreeAnsiString (note that only storage for
        DestinationString->Buffer is allocated by this API).

Return Value:

    SUCCESS - The conversion was successful

    !SUCCESS - The operation failed.  No storage was allocated and no
        conversion was done.  None.

--*/

{
    ULONG AnsiLength;
    ULONG Index;
    NTSTATUS st;
    NTSTATUS ReturnStatus = STATUS_SUCCESS;

    RTL_PAGED_CODE();

    AnsiLength = RtlUnicodeStringToAnsiSize(SourceString);
    if ( AnsiLength > MAXUSHORT ) {
        return STATUS_INVALID_PARAMETER_2;
        }

    DestinationString->Length = (USHORT)(AnsiLength - 1);
    if ( AllocateDestinationString ) {
        DestinationString->MaximumLength = (USHORT)AnsiLength;
        DestinationString->Buffer = RtlAllocateStringRoutine(AnsiLength);
        if ( !DestinationString->Buffer ) {
            return STATUS_NO_MEMORY;
            }
        }
    else {
        if ( DestinationString->Length >= DestinationString->MaximumLength ) {
            /*
             * Return STATUS_BUFFER_OVERFLOW, but translate as much as
             * will fit into the buffer first.  This is the expected
             * behavior for routines such as GetProfileStringA.
             * Set the length of the buffer to one less than the maximum
             * (so that the trail byte of a double byte char is not
             * overwritten by doing DestinationString->Buffer[Index] = '\0').
             * RtlUnicodeToMultiByteN is careful not to truncate a
             * multibyte character.
             */
            if (!DestinationString->MaximumLength) {
                return STATUS_BUFFER_OVERFLOW;
            }
            ReturnStatus = STATUS_BUFFER_OVERFLOW;
            DestinationString->Length = DestinationString->MaximumLength - 1;
            }
        }

    st = RtlUnicodeToMultiByteN(
             DestinationString->Buffer,
             DestinationString->Length,
             &Index,
             SourceString->Buffer,
             SourceString->Length
             );

    if (!NT_SUCCESS(st)) {
        if ( AllocateDestinationString ) {
            RtlFreeStringRoutine(DestinationString->Buffer);
            DestinationString->Buffer = NULL;
        }

        return st;
    }

    DestinationString->Buffer[Index] = '\0';

    return ReturnStatus;
}

NTSTATUS
RtlUpcaseUnicodeString(
    OUT PUNICODE_STRING DestinationString,
    IN PCUNICODE_STRING SourceString,
    IN BOOLEAN AllocateDestinationString
    )

/*++

Routine Description:

    This functions converts the specified unicode source string into an
    upcased unicode string. The translation is done with respect to the
    current system locale information.

Arguments:

    DestinationString - Returns a unicode string that is the upcased equivalent
        to the unicode source string.  The maximum length field is only set if
        AllocateDestinationString is TRUE.

    SourceString - Supplies the unicode source string that is to being
        upcased.

    AllocateDestinationString - Supplies a flag that controls whether or
        not this API allocates the buffer space for the destination
        string.  If it does, then the buffer must be deallocated using
        RtlFreeUnicodeString (note that only storage for
        DestinationString->Buffer is allocated by this API).

Return Value:

    SUCCESS - The conversion was successful

    !SUCCESS - The operation failed.  No storage was allocated and no
        conversion was done.  None.

--*/

{
    ULONG Index;
    ULONG StopIndex;

    RTL_PAGED_CODE();

    if ( AllocateDestinationString ) {
        DestinationString->MaximumLength = SourceString->Length;
        DestinationString->Buffer = RtlAllocateStringRoutine((ULONG)DestinationString->MaximumLength);
        if ( !DestinationString->Buffer ) {
            return STATUS_NO_MEMORY;
            }
        }
    else {
        if ( SourceString->Length > DestinationString->MaximumLength ) {
            return STATUS_BUFFER_OVERFLOW;
            }
        }

    StopIndex = ((ULONG)SourceString->Length) / sizeof( WCHAR );

    for (Index = 0; Index < StopIndex; Index++) {
        DestinationString->Buffer[Index] = (WCHAR)NLS_UPCASE(SourceString->Buffer[Index]);
    }

    DestinationString->Length = SourceString->Length;

    return STATUS_SUCCESS;
}


NTSTATUS
RtlDowncaseUnicodeString(
    OUT PUNICODE_STRING DestinationString,
    IN PUNICODE_STRING SourceString,
    IN BOOLEAN AllocateDestinationString
    )

/*++

Routine Description:

    This functions converts the specified unicode source string into a
    downcased unicode string. The translation is done with respect to the
    current system locale information.

Arguments:

    DestinationString - Returns a unicode string that is the downcased
        equivalent to the unicode source string.  The maximum length field
        is only set if AllocateDestinationString is TRUE.

    SourceString - Supplies the unicode source string that is to being
        downcased.

    AllocateDestinationString - Supplies a flag that controls whether or
        not this API allocates the buffer space for the destination
        string.  If it does, then the buffer must be deallocated using
        RtlFreeUnicodeString (note that only storage for
        DestinationString->Buffer is allocated by this API).

Return Value:

    SUCCESS - The conversion was successful

    !SUCCESS - The operation failed.  No storage was allocated and no
        conversion was done.  None.

--*/

{
    ULONG Index;
    ULONG StopIndex;

    RTL_PAGED_CODE();

    if ( AllocateDestinationString ) {
        DestinationString->MaximumLength = SourceString->Length;
        DestinationString->Buffer = RtlAllocateStringRoutine((ULONG)DestinationString->MaximumLength);
        if ( !DestinationString->Buffer ) {
            return STATUS_NO_MEMORY;
            }
        }
    else {
        if ( SourceString->Length > DestinationString->MaximumLength ) {
            return STATUS_BUFFER_OVERFLOW;
            }
        }

    StopIndex = ((ULONG)SourceString->Length) / sizeof( WCHAR );

    for (Index = 0; Index < StopIndex; Index++) {
        DestinationString->Buffer[Index] = (WCHAR)NLS_DOWNCASE(SourceString->Buffer[Index]);
    }

    DestinationString->Length = SourceString->Length;

    return STATUS_SUCCESS;
}


WCHAR
RtlUpcaseUnicodeChar(
    IN WCHAR SourceCharacter
    )

/*++

Routine Description:

    This function translates the specified unicode character to its
    equivalent upcased unicode chararacter.  The purpose for this routine
    is to allow for character by character upcase translation.  The
    translation is done with respect to the current system locale
    information.


Arguments:

    SourceCharacter - Supplies the unicode character to be upcased.

Return Value:

    Returns the upcased unicode equivalent of the specified input character.

--*/

{
    RTL_PAGED_CODE();

    //
    // Note that this needs to reference the translation table !
    //

    return (WCHAR)NLS_UPCASE(SourceCharacter);
}



WCHAR
RtlDowncaseUnicodeChar(
    IN WCHAR SourceCharacter
    )

/*++

Routine Description:

    This function translates the specified unicode character to its
    equivalent downcased unicode chararacter.  The purpose for this routine
    is to allow for character by character downcase translation.  The
    translation is done with respect to the current system locale
    information.


Arguments:

    SourceCharacter - Supplies the unicode character to be downcased.

Return Value:

    Returns the downcased unicode equivalent of the specified input character.

--*/

{
    RTL_PAGED_CODE();

    //
    // Note that this needs to reference the translation table !
    //

    return (WCHAR)NLS_DOWNCASE(SourceCharacter);
}


VOID
RtlFreeUnicodeString(
    IN OUT PUNICODE_STRING UnicodeString
    )

/*++

Routine Description:

    This API is used to free storage allocated by
    RtlAnsiStringToUnicodeString.  Note that only UnicodeString->Buffer
    is free'd by this routine.

Arguments:

    UnicodeString - Supplies the address of the unicode string whose
        buffer was previously allocated by RtlAnsiStringToUnicodeString.

Return Value:

    None.

--*/

{
    RTL_PAGED_CODE();

    if (UnicodeString->Buffer) {
        RtlFreeStringRoutine(UnicodeString->Buffer);
        memset( UnicodeString, 0, sizeof( *UnicodeString ) );
        }
}


VOID
RtlFreeAnsiString(
    IN OUT PANSI_STRING AnsiString
    )

/*++

Routine Description:

    This API is used to free storage allocated by
    RtlUnicodeStringToAnsiString.  Note that only AnsiString->Buffer
    is free'd by this routine.

Arguments:

    AnsiString - Supplies the address of the ansi string whose buffer
        was previously allocated by RtlUnicodeStringToAnsiString.

Return Value:

    None.

--*/

{
    RTL_PAGED_CODE();

    if (AnsiString->Buffer) {
        RtlFreeStringRoutine(AnsiString->Buffer);
        memset( AnsiString, 0, sizeof( *AnsiString ) );
        }
}


LONG
RtlCompareUnicodeString(
    IN PUNICODE_STRING String1,
    IN PUNICODE_STRING String2,
    IN BOOLEAN CaseInSensitive
    )

/*++

Routine Description:

    The RtlCompareUnicodeString function compares two counted strings.  The
    return value indicates if the strings are equal or String1 is less than
    String2 or String1 is greater than String2.

    The CaseInSensitive parameter specifies if case is to be ignored when
    doing the comparison.

Arguments:

    String1 - Pointer to the first string.

    String2 - Pointer to the second string.

    CaseInsensitive - TRUE if case should be ignored when doing the
        comparison.

Return Value:

    Signed value that gives the results of the comparison:

        Zero - String1 equals String2

        < Zero - String1 less than String2

        > Zero - String1 greater than String2


--*/

{

    PWCHAR s1, s2, Limit;
    LONG n1, n2;
    WCHAR c1, c2;

    s1 = String1->Buffer;
    s2 = String2->Buffer;
    n1 = String1->Length;
    n2 = String2->Length;

    ASSERT((n1 & 1) == 0);
    ASSERT((n2 & 1) == 0);
    ASSERT(!(((((ULONG_PTR)s1 & 1) != 0) || (((ULONG_PTR)s2 & 1) != 0)) && (n1 != 0) && (n2 != 0)));

    Limit = (PWCHAR)((PCHAR)s1 + (n1 <= n2 ? n1 : n2));
    if (CaseInSensitive) {
        while (s1 < Limit) {
            c1 = *s1++;
            c2 = *s2++;
            if (c1 != c2) {

                //
                // Note that this needs to reference the translation table!
                //

                c1 = NLS_UPCASE(c1);
                c2 = NLS_UPCASE(c2);
                if (c1 != c2) {
                    return (LONG)(c1) - (LONG)(c2);
                }
            }
        }

    } else {
        while (s1 < Limit) {
            c1 = *s1++;
            c2 = *s2++;
            if (c1 != c2) {
                return (LONG)(c1) - (LONG)(c2);
            }
        }
    }

    return n1 - n2;
}


BOOLEAN
RtlEqualUnicodeString(
    IN PCUNICODE_STRING String1,
    IN PCUNICODE_STRING String2,
    IN BOOLEAN CaseInSensitive
    )

/*++

Routine Description:

    The RtlEqualUnicodeString function compares two counted unicode strings for
    equality.

    The CaseInSensitive parameter specifies if case is to be ignored when
    doing the comparison.

Arguments:

    String1 - Pointer to the first string.

    String2 - Pointer to the second string.

    CaseInsensitive - TRUE if case should be ignored when doing the
        comparison.

Return Value:

    Boolean value that is TRUE if String1 equals String2 and FALSE otherwise.

--*/

{

    PWCHAR s1, s2, Limit;
    LONG n1, n2;
    WCHAR c1, c2;

    n1 = String1->Length;
    n2 = String2->Length;

    ASSERT((n1 & 1) == 0);
    ASSERT((n2 & 1) == 0);

    if (n1 == n2) {
        s1 = String1->Buffer;
        s2 = String2->Buffer;

        ASSERT(!(((((ULONG_PTR)s1 & 1) != 0) || (((ULONG_PTR)s2 & 1) != 0)) && (n1 != 0) && (n2 != 0)));

        Limit = (PWCHAR)((PCHAR)s1 + n1);
        if (CaseInSensitive) {
            while (s1 < Limit) {
                c1 = *s1++;
                c2 = *s2++;
                if ((c1 != c2) && (NLS_UPCASE(c1) != NLS_UPCASE(c2))) {
                    return FALSE;
                }
            }

            return TRUE;

        } else {
            while (s1 < Limit) {
                c1 = *s1++;
                c2 = *s2++;
                if (c1 != c2) {
                    return FALSE;
                }
            }

            return TRUE;
        }

    } else {
        return FALSE;
    }
}


BOOLEAN
RtlPrefixUnicodeString(
    IN PUNICODE_STRING String1,
    IN PUNICODE_STRING String2,
    IN BOOLEAN CaseInSensitive
    )

/*++

Routine Description:

    The RtlPrefixUnicodeString function determines if the String1
    counted string parameter is a prefix of the String2 counted string
    parameter.

    The CaseInSensitive parameter specifies if case is to be ignored when
    doing the comparison.

Arguments:

    String1 - Pointer to the first unicode string.

    String2 - Pointer to the second unicode string.

    CaseInsensitive - TRUE if case should be ignored when doing the
        comparison.

Return Value:

    Boolean value that is TRUE if String1 equals a prefix of String2 and
    FALSE otherwise.

--*/

{
    PWSTR s1, s2;
    ULONG n;
    WCHAR c1, c2;

    s1 = String1->Buffer;
    s2 = String2->Buffer;
    n = String1->Length;
    if (String2->Length < n) {
        return( FALSE );
        }

    n = n / sizeof(c1);
    if (CaseInSensitive) {
        while (n) {
            c1 = *s1++;
            c2 = *s2++;

            if ((c1 != c2) && (NLS_UPCASE(c1) != NLS_UPCASE(c2))) {
                return( FALSE );
                }

            n--;
            }
        }
    else {
        while (n) {
            if (*s1++ != *s2++) {
                return( FALSE );
                }

            n--;
            }
        }

    return TRUE;
}


VOID
RtlCopyUnicodeString(
    OUT PUNICODE_STRING DestinationString,
    IN PUNICODE_STRING SourceString OPTIONAL
    )

/*++

Routine Description:

    The RtlCopyString function copies the SourceString to the
    DestinationString.  If SourceString is not specified, then
    the Length field of DestinationString is set to zero.  The
    MaximumLength and Buffer fields of DestinationString are not
    modified by this function.

    The number of bytes copied from the SourceString is either the
    Length of SourceString or the MaximumLength of DestinationString,
    whichever is smaller.

Arguments:

    DestinationString - Pointer to the destination string.

    SourceString - Optional pointer to the source string.

Return Value:

    None.

--*/

{
    UNALIGNED WCHAR *src, *dst;
    ULONG n;

    if (ARGUMENT_PRESENT(SourceString)) {
        dst = DestinationString->Buffer;
        src = SourceString->Buffer;
        n = SourceString->Length;
        if ((USHORT)n > DestinationString->MaximumLength) {
            n = DestinationString->MaximumLength;
        }

        DestinationString->Length = (USHORT)n;
        RtlCopyMemory(dst, src, n);
        if (DestinationString->Length < DestinationString->MaximumLength) {
            dst[n / sizeof(WCHAR)] = UNICODE_NULL;
        }

    } else {
        DestinationString->Length = 0;
    }

    return;
}


NTSTATUS
RtlAppendUnicodeToString (
    IN PUNICODE_STRING Destination,
    IN PCWSTR Source OPTIONAL
    )

/*++

Routine Description:

    This routine appends the supplied UNICODE string to an existing
    PUNICODE_STRING.

    It will copy bytes from the Source PSZ to the destination PSTRING up to
    the destinations PUNICODE_STRING->MaximumLength field.

Arguments:

    IN PUNICODE_STRING Destination, - Supplies a pointer to the destination
                            string
    IN PWSTR Source - Supplies the string to append to the destination

Return Value:

    STATUS_SUCCESS - The source string was successfully appended to the
        destination counted string.

    STATUS_BUFFER_TOO_SMALL - The destination string length was not big
        enough to allow the source string to be appended.  The Destination
        string length is not updated.

--*/

{
    USHORT n;
    UNALIGNED WCHAR *dst;

    if (ARGUMENT_PRESENT( Source )) {
        UNICODE_STRING UniSource;

        RtlInitUnicodeString(&UniSource, Source);

        n = UniSource.Length;

        if ((n + Destination->Length) > Destination->MaximumLength) {
            return( STATUS_BUFFER_TOO_SMALL );
            }

        dst = &Destination->Buffer[ (Destination->Length / sizeof( WCHAR )) ];
        RtlMoveMemory( dst, Source, n );

        Destination->Length += n;

        if (Destination->Length < Destination->MaximumLength) {
            dst[ n / sizeof( WCHAR ) ] = UNICODE_NULL;
            }
        }

    return( STATUS_SUCCESS );
}


NTSTATUS
RtlAppendUnicodeStringToString (
    IN PUNICODE_STRING Destination,
    IN PUNICODE_STRING Source
    )

/*++

Routine Description:

    This routine will concatinate two PSTRINGs together.  It will copy
    bytes from the source up to the MaximumLength of the destination.

Arguments:

    IN PSTRING Destination, - Supplies the destination string
    IN PSTRING Source - Supplies the source for the string copy

Return Value:

    STATUS_SUCCESS - The source string was successfully appended to the
        destination counted string.

    STATUS_BUFFER_TOO_SMALL - The destination string length was not big
        enough to allow the source string to be appended.  The Destination
        string length is not updated.

--*/

{
    USHORT n = Source->Length;
    UNALIGNED WCHAR *dst;

    if (n) {
        if ((n + Destination->Length) > Destination->MaximumLength) {
            return( STATUS_BUFFER_TOO_SMALL );
            }

        dst = &Destination->Buffer[ (Destination->Length / sizeof( WCHAR )) ];
        RtlMoveMemory( dst, Source->Buffer, n );

        Destination->Length += n;

        if (Destination->Length < Destination->MaximumLength) {
            dst[ n / sizeof( WCHAR ) ] = UNICODE_NULL;
            }
        }

    return( STATUS_SUCCESS );
}


BOOLEAN
RtlCreateUnicodeString(
    OUT PUNICODE_STRING DestinationString,
    IN PCWSTR SourceString
    )
{
    ULONG cb;

    RTL_PAGED_CODE();

    cb = (wcslen( SourceString ) + 1) * sizeof( WCHAR );
    DestinationString->Buffer = RtlAllocateStringRoutine( cb );
    if (DestinationString->Buffer) {
        RtlMoveMemory( DestinationString->Buffer, SourceString, cb );
        DestinationString->MaximumLength = (USHORT)cb;
        DestinationString->Length = (USHORT)(cb - sizeof( UNICODE_NULL ));
        return( TRUE );
        }
    else {
        return( FALSE );
        }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\rtl\resource.c ===
/*++

Copyright (c) 1989-2000  Microsoft Corporation

Module Name:

    Resource.c

Abstract:

    This module implements the executive functions to acquire and release
    a shared resource.

--*/

#include "ntrtlp.h"

VOID
RtlInitializeCriticalSection(
    IN PRTL_CRITICAL_SECTION CriticalSection
    )

/*++

Routine Description:

    This routine initializes the input critial section variable

Arguments:

    CriticalSection - Supplies the resource variable being initialized

Return Value:

    TBD - Status of semaphore creation.

--*/

{
    ASSERT(sizeof(CriticalSection->Synchronization.RawEvent) == sizeof(KEVENT));

    KeInitializeEvent((PKEVENT)&CriticalSection->Synchronization.RawEvent,
        SynchronizationEvent, FALSE);

    CriticalSection->LockCount = -1;
    CriticalSection->RecursionCount = 0;
    CriticalSection->OwningThread = 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\rtl\sertl.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    sertl.c

Abstract:

    This Module implements many security rtl routines defined in ntseapi.h

Author:

    Jim Kelly       (JimK)     23-Mar-1990
    Robert Reichel  (RobertRe)  1-Mar-1991

Environment:

    Pure Runtime Library Routine

Revision History:


--*/

#include "ntrtlp.h"

VOID
RtlMapGenericMask(
    IN OUT PACCESS_MASK AccessMask,
    IN PGENERIC_MAPPING GenericMapping
    )

/*++

Routine Description:

    This routine maps all generic accesses in the provided access mask
    to specific and standard accesses according to the provided
    GenericMapping.

Arguments:

        AccessMask - Points to the access mask to be mapped.

        GenericMapping - The mapping of generic to specific and standard
                         access types.

Return Value:

    None.

--*/

{
    RTL_PAGED_CODE();

    if (*AccessMask & GENERIC_READ) {

        *AccessMask |= GenericMapping->GenericRead;
    }

    if (*AccessMask & GENERIC_WRITE) {

        *AccessMask |= GenericMapping->GenericWrite;
    }

    if (*AccessMask & GENERIC_EXECUTE) {

        *AccessMask |= GenericMapping->GenericExecute;
    }

    if (*AccessMask & GENERIC_ALL) {

        *AccessMask |= GenericMapping->GenericAll;
    }

    //
    // Now clear the generic flags
    //

    *AccessMask &= ~(GENERIC_READ | GENERIC_WRITE | GENERIC_EXECUTE | GENERIC_ALL);

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\rtl\nlsxlat.c ===
/****************************** Module Header ******************************\
* Module Name: nlsxlat.c
*
* Copyright (c) 1985-91, Microsoft Corporation
*
* This modules contains the private routines for character translation:
* 8-bit <=> Unicode.
*
* History:
* 03-Jan-1992    gregoryw
* 16-Feb-1993    JulieB      Added Upcase Routines & Macros.
* 17-Feb-1993    JulieB      Fixed Tables; Fixed DBCS Code.
* 08-Mar-1993    JulieB      Moved Upcase Macro to ntrtlp.h.
\***************************************************************************/

#include "ntrtlp.h"

/*
 * Global data used by the translation routines.
 *
 */

//
// Upcase and Lowercase data
//
const UCHAR Nls844UnicodeCaseTableLevel1[] = {
    0x00,0x10,0x20,0x30,0x40,0x50,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,  // 0x00
    0x70,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x80,0x90,  // 0x10
    0x60,0xa0,0x60,0x60,0xb0,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,  // 0x20
    0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,  // 0x30
    0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,  // 0x40
    0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,  // 0x50
    0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,  // 0x60
    0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,  // 0x70
    0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,  // 0x80
    0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,  // 0x90
    0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,  // 0xa0
    0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,  // 0xb0
    0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,  // 0xc0
    0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,  // 0xd0
    0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,  // 0xe0
    0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0xc0,  // 0xf0
};

const UCHAR Nls844UnicodeUpcaseTableLevel2[] = {
    0x00,0x00,0x00,0x00,0x00,0x00,0x04,0x06,0x00,0x00,0x00,0x00,0x00,0x00,0x0a,0x91,  // 0x00
    0x95,0x95,0x95,0x99,0x9c,0x95,0x95,0x17,0xa0,0xa4,0xa8,0xac,0xb0,0xb4,0x95,0xb8,  // 0x10
    0x95,0xbb,0x00,0x00,0x00,0xbf,0xc3,0xc7,0xcb,0xcf,0x00,0x00,0x00,0x00,0x00,0x00,  // 0x20
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xd0,0x04,0xd4,0x00,0xd8,0x00,  // 0x30
    0x00,0x00,0x00,0x0a,0x0a,0x47,0x95,0x95,0xdc,0x95,0x95,0x95,0xe0,0x95,0x96,0xe4,  // 0x40
    0x00,0x00,0x00,0x00,0x00,0x00,0x57,0x58,0x5b,0x00,0x00,0x00,0x00,0x00,0x00,0x00,  // 0x50
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,  // 0x60
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,  // 0x70
    0x95,0x95,0x95,0x95,0x95,0x95,0x95,0x95,0x95,0xdb,0x95,0x95,0x95,0x95,0x95,0xda,  // 0x80
    0x6c,0x70,0x6c,0x6c,0x70,0x74,0x6c,0xe8,0x00,0x00,0x00,0xec,0x00,0xec,0xf0,0x00,  // 0x90
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x87,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,  // 0xa0
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x8d,0xf4,0x00,  // 0xb0
    0x00,0x00,0x00,0x00,0x04,0x06,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,  // 0xc0
};

const UCHAR Nls844UnicodeLowercaseTableLevel2[] = {
    0x00,0x00,0x00,0x00,0x04,0x06,0x00,0x00,0x00,0x00,0x00,0x00,0x0a,0x0d,0x00,0x00,  // 0x00
    0x11,0x11,0x11,0x15,0x17,0x11,0x11,0x1a,0x1e,0x22,0x26,0x2a,0x2e,0x31,0x11,0x35,  // 0x10
    0x11,0x38,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,  // 0x20
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x3b,0x04,0x3f,0x00,0x00,0x00,0x43,0x00,  // 0x30
    0x47,0x0a,0x0a,0x00,0x00,0x00,0x11,0x11,0x4b,0x11,0x11,0x11,0x4f,0x11,0x12,0x53,  // 0x40
    0x00,0x00,0x00,0x57,0x58,0x5b,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,  // 0x50
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,  // 0x60
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x58,0x58,0x5f,0x00,0x00,0x00,  // 0x70
    0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x63,0x11,0x11,0x11,0x11,0x11,0x67,  // 0x80
    0x6a,0x6e,0x6a,0x6a,0x6e,0x72,0x6a,0x00,0x00,0x00,0x00,0x76,0x79,0x7c,0x7f,0x83,  // 0x90
    0x00,0x00,0x00,0x00,0x00,0x00,0x87,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,  // 0xa0
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x8b,0x8d,0x00,0x00,0x00,  // 0xb0
    0x00,0x00,0x04,0x06,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,  // 0xc0
};

const USHORT Nls844UnicodeCaseTableLevel3[] = {
    0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,  // 0x00
    0x0000,0x0020,0x0020,0x0020,0x0020,0x0020,0x0020,0x0020,0x0020,0x0020,0x0020,0x0020,0x0020,0x0020,0x0020,0x0020,  // 0x01
    0x0020,0x0020,0x0020,0x0000,0x0000,0x0000,0x0000,0x0000,0x0020,0x0020,0x0020,0x0020,0x0020,0x0020,0x0020,0x0020,  // 0x02
    0x0020,0x0020,0x0020,0x0020,0x0020,0x0020,0x0020,0x0020,0x0020,0x0020,0x0020,0x0000,0x0020,0x0020,0x0020,0x0020,  // 0x03
    0x0020,0x0020,0x0020,0x0000,0x0001,0x0000,0x0001,0x0000,0x0001,0x0000,0x0001,0x0000,0x0001,0x0000,0x0001,0x0000,  // 0x04
    0x0001,0x0000,0x0001,0x0000,0x0000,0x0000,0x0001,0x0000,0x0001,0x0000,0x0001,0x0000,0x0000,0x0001,0x0000,0x0001,  // 0x05
    0x0000,0x0001,0x0000,0x0001,0x0000,0x0000,0x0001,0x0000,0x0001,0x0000,0x0001,0x0000,0x0001,0x0000,0x0001,0x0000,  // 0x06
    0xff87,0x0001,0x0000,0x0001,0x0000,0x0001,0x0000,0x0000,0x0000,0x00d2,0x0001,0x0000,0x0001,0x0000,0x00ce,0x0001,  // 0x07
    0x0000,0x00cd,0x00cd,0x0001,0x0000,0x0000,0x004f,0x00ca,0x00cb,0x0001,0x0000,0x00cd,0x00cf,0x0000,0x00d3,0x00d1,  // 0x08
    0x0001,0x0000,0x0000,0x0000,0x00d3,0x00d5,0x0000,0x00d6,0x0001,0x0000,0x0001,0x0000,0x0001,0x0000,0x0000,0x0001,  // 0x09
    0x0000,0x00da,0x0000,0x0000,0x0001,0x0000,0x00da,0x0001,0x0000,0x00d9,0x00d9,0x0001,0x0000,0x0001,0x0000,0x00db,  // 0x0a
    0x0001,0x0000,0x0000,0x0000,0x0001,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0002,0x0000,0x0000,0x0002,  // 0x0b
    0x0000,0x0000,0x0002,0x0000,0x0000,0x0001,0x0000,0x0001,0x0000,0x0001,0x0000,0x0001,0x0000,0x0001,0x0000,0x0001,  // 0x0c
    0x0000,0x0000,0x0001,0x0000,0x0000,0x0002,0x0000,0x0000,0x0001,0x0000,0x0000,0x0000,0x0000,0x0000,0x0001,0x0000,  // 0x0d
    0x0001,0x0000,0x0001,0x0000,0x0001,0x0000,0x0001,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,  // 0x0e
    0x0000,0x0000,0x0026,0x0000,0x0025,0x0025,0x0025,0x0000,0x0040,0x0000,0x003f,0x003f,0x0020,0x0020,0x0000,0x0020,  // 0x0f
    0x0020,0x0020,0x0020,0x0020,0x0020,0x0020,0x0020,0x0020,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0001,0x0000,  // 0x10
    0x0001,0x0000,0x0001,0x0000,0x0001,0x0000,0x0001,0x0000,0x0001,0x0000,0x0001,0x0000,0x0000,0x0050,0x0050,0x0050,  // 0x11
    0x0050,0x0050,0x0050,0x0050,0x0050,0x0050,0x0050,0x0050,0x0050,0x0000,0x0050,0x0050,0x0001,0x0000,0x0000,0x0000,  // 0x12
    0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0001,0x0000,0x0001,  // 0x13
    0x0000,0x0000,0x0000,0x0001,0x0000,0x0000,0x0000,0x0001,0x0000,0x0000,0x0000,0x0000,0x0001,0x0000,0x0001,0x0000,  // 0x14
    0x0001,0x0000,0x0000,0x0000,0x0001,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0030,0x0030,0x0030,  // 0x15
    0x0030,0x0030,0x0030,0x0030,0x0030,0x0030,0x0030,0x0030,0x0030,0x0030,0x0030,0x0030,0x0030,0x0030,0x0030,0x0030,  // 0x16
    0x0030,0x0030,0x0030,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0030,0x0030,0x0030,0x0030,  // 0x17
    0x0030,0x0030,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0001,0x0000,0x0001,0x0000,  // 0x18
    0x0001,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0001,0x0000,0x0001,0x0000,  // 0x19
    0x0001,0x0000,0x0001,0x0000,0x0001,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,  // 0x1a
    0xfff8,0xfff8,0xfff8,0xfff8,0xfff8,0xfff8,0xfff8,0xfff8,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,  // 0x1b
    0xfff8,0xfff8,0xfff8,0xfff8,0xfff8,0xfff8,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,  // 0x1c
    0x0000,0xfff8,0x0000,0xfff8,0x0000,0xfff8,0x0000,0xfff8,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,  // 0x1d
    0xfff8,0xfff8,0xffb6,0xffb6,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0xffaa,0xffaa,0xffaa,0xffaa,  // 0x1e
    0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0xfff8,0xfff8,0xff9c,0xff9c,0x0000,0x0000,0x0000,0x0000,  // 0x1f
    0x0000,0x0000,0x0000,0x0000,0xfff8,0xfff8,0xff90,0xff90,0xfff9,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,  // 0x20
    0x0000,0x0000,0x0000,0x0000,0xff80,0xff80,0xff82,0xff82,0x0000,0x0000,0x0000,0x0000,0x0010,0x0010,0x0010,0x0010,  // 0x21
    0x0010,0x0010,0x0010,0x0010,0x0010,0x0010,0x0010,0x0010,0x0010,0x0010,0x0010,0x0010,0x0000,0x0000,0x0000,0x0000,  // 0x22
    0x0000,0x0000,0x001a,0x001a,0x001a,0x001a,0x001a,0x001a,0x001a,0x001a,0x001a,0x001a,0x001a,0x001a,0x001a,0x001a,  // 0x23
    0x001a,0x001a,0x001a,0x001a,0x0020,0x0020,0x0020,0x0020,0x0020,0x0020,0x0020,0x0000,0x0020,0x0020,0x0020,0x0020,  // 0x24
    0x0020,0x0020,0x0020,0xff87,0x0000,0x0001,0x0000,0x0001,0x0000,0x0001,0x0000,0x0001,0x0000,0x0001,0x0000,0x0001,  // 0x25
    0x0000,0x0001,0x0000,0x0001,0x0000,0x0000,0x0000,0x0001,0x0000,0x0001,0x0000,0x0001,0x0000,0x0000,0x0001,0x0000,  // 0x26
    0x0001,0x0000,0x0001,0x0000,0x0001,0x0000,0x0001,0x0000,0x0001,0x0000,0x0000,0x0001,0x0000,0x0001,0x0000,0x0001,  // 0x27
    0x0000,0x0000,0x0000,0x0001,0x0000,0x0001,0x0000,0x0000,0x0001,0x0000,0x0000,0x0000,0x0001,0x0000,0x0000,0x0000,  // 0x28
    0x0000,0x0000,0x0001,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0001,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,  // 0x29
    0x0000,0x0001,0x0000,0x0001,0x0000,0x0001,0x0000,0x0000,0x0001,0x0000,0x0000,0x0000,0x0000,0x0001,0x0000,0x0000,  // 0x2a
    0x0001,0x0000,0x0000,0x0000,0x0001,0x0000,0x0001,0x0000,0x0000,0x0001,0x0000,0x0000,0x0000,0x0001,0x0000,0x0000,  // 0x2b
    0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0002,0x0000,0x0000,0x0002,0x0000,0x0000,0x0002,0x0000,0x0001,0x0000,  // 0x2c
    0x0001,0x0000,0x0001,0x0000,0x0001,0x0000,0x0001,0x0000,0x0001,0x0000,0x0001,0x0000,0x0001,0x004f,0x0000,0x0001,  // 0x2d
    0x0000,0x0000,0x0000,0x0002,0x0000,0x0001,0x0000,0x0000,0x0000,0x0000,0x0000,0x0001,0x0000,0x0001,0x0000,0x0001,  // 0x2e
    0x0000,0x0001,0x0000,0x0001,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x00d2,  // 0x2f
    0x00ce,0x0000,0x00cd,0x00cd,0x0000,0x00ca,0x0000,0x00cb,0x0000,0x0000,0x0000,0x0000,0x00cd,0x0000,0x0000,0x00cf,  // 0x30
    0x0000,0x0000,0x0000,0x0000,0x00d1,0x00d3,0x0000,0x0000,0x0000,0x0000,0x0000,0x00d3,0x0000,0x0000,0x00d5,0x0000,  // 0x31
    0x0000,0x00d6,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x00da,  // 0x32
    0x0000,0x0000,0x0000,0x0000,0x00da,0x0000,0x00d9,0x00d9,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x00db,0x0000,  // 0x33
    0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0026,0x0025,0x0025,0x0025,  // 0x34
    0x0020,0x0020,0x001f,0x0020,0x0020,0x0020,0x0020,0x0020,0x0020,0x0020,0x0020,0x0020,0x0040,0x003f,0x003f,0x0000,  // 0x35
    0x0000,0x0000,0x0000,0x0001,0x0000,0x0001,0x0000,0x0001,0x0000,0x0001,0x0000,0x0001,0x0000,0x0001,0x0000,0x0001,  // 0x36
    0x0000,0x0001,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,  // 0x37
    0x0000,0x0000,0x0001,0x0000,0x0001,0x0000,0x0000,0x0000,0x0001,0x0000,0x0000,0x0000,0x0001,0x0000,0x0000,0x0000,  // 0x38
    0x0000,0x0001,0x0000,0x0001,0x0000,0x0001,0x0000,0x0000,0x0000,0x0001,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,  // 0x39
    0xffb6,0xffb6,0xffaa,0xffaa,0xffaa,0xffaa,0xff9c,0xff9c,0xff80,0xff80,0xff90,0xff90,0xff82,0xff82,0x0000,0x0000,  // 0x3a
    0xfff8,0xfff8,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,  // 0x3b
    0xfff8,0xfff8,0x0000,0x0000,0x0000,0xfff9,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,  // 0x3c
    0x001a,0x001a,0x001a,0x001a,0x001a,0x001a,0x001a,0x001a,0x001a,0x001a,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,  // 0x3d
};


NTSTATUS
RtlMultiByteToUnicodeN(
    OUT PWCH UnicodeString,
    IN ULONG MaxBytesInUnicodeString,
    OUT PULONG BytesInUnicodeString OPTIONAL,
    IN PCH MultiByteString,
    IN ULONG BytesInMultiByteString)

/*++

Routine Description:

    This functions converts the specified ansi source string into a
    Unicode string. The translation is done with respect to the
    ANSI Code Page (ACP) installed at boot time.  Single byte characters
    in the range 0x00 - 0x7f are simply zero extended as a performance
    enhancement.  In some far eastern code pages 0x5c is defined as the
    Yen sign.  For system translation we always want to consider 0x5c
    to be the backslash character.  We get this for free by zero extending.

    NOTE: This routine only supports precomposed Unicode characters.

Arguments:

    UnicodeString - Returns a unicode string that is equivalent to
        the ansi source string.

    MaxBytesInUnicodeString - Supplies the maximum number of bytes to be
        written to UnicodeString.  If this causes UnicodeString to be a
        truncated equivalent of MultiByteString, no error condition results.

    BytesInUnicodeString - Returns the number of bytes in the returned
        unicode string pointed to by UnicodeString.

    MultiByteString - Supplies the ansi source string that is to be
        converted to unicode.  For single-byte character sets, this address
        CAN be the same as UnicodeString.

    BytesInMultiByteString - The number of bytes in the string pointed to
        by MultiByteString.

Return Value:

    SUCCESS - The conversion was successful.


--*/

{
    ULONG LoopCount;
    ULONG MaxCharsInUnicodeString;

    RTL_PAGED_CODE();

    MaxCharsInUnicodeString = MaxBytesInUnicodeString / sizeof(WCHAR);

    LoopCount = (MaxCharsInUnicodeString < BytesInMultiByteString) ?
                 MaxCharsInUnicodeString : BytesInMultiByteString;

    if (ARGUMENT_PRESENT(BytesInUnicodeString))
        *BytesInUnicodeString = LoopCount * sizeof(WCHAR);

    while (LoopCount) {

        *UnicodeString = (WCHAR)(UCHAR)(*MultiByteString);

        UnicodeString++;
        MultiByteString++;
        LoopCount--;
    }

    return STATUS_SUCCESS;
}


NTSTATUS
RtlMultiByteToUnicodeSize(
    OUT PULONG BytesInUnicodeString,
    IN PCH MultiByteString,
    IN ULONG BytesInMultiByteString)

/*++

Routine Description:

    This functions determines how many bytes would be needed to represent
    the specified ANSI source string in Unicode string (not counting the
    null terminator)
    The translation is done with respect to the ANSI Code Page (ACP) installed
    at boot time.  Single byte characters in the range 0x00 - 0x7f are simply
    zero extended as a performance enhancement.  In some far eastern code pages
    0x5c is defined as the Yen sign.  For system translation we always want to
    consider 0x5c to be the backslash character.  We get this for free by zero
    extending.

    NOTE: This routine only supports precomposed Unicode characters.

Arguments:

    BytesInUnicodeString - Returns the number of bytes a Unicode translation
        of the ANSI string pointed to by MultiByteString would contain.

    MultiByteString - Supplies the ansi source string whose Unicode length
        is to be calculated.

    BytesInMultiByteString - The number of bytes in the string pointed to
        by MultiByteString.

Return Value:

    SUCCESS - The conversion was successful


--*/

{
    RTL_PAGED_CODE();

    *BytesInUnicodeString = BytesInMultiByteString * sizeof(WCHAR);

    return STATUS_SUCCESS;
}


NTSTATUS
RtlUnicodeToMultiByteSize(
    OUT PULONG BytesInMultiByteString,
    IN PWCH UnicodeString,
    IN ULONG BytesInUnicodeString)

/*++

Routine Description:

    This functions determines how many bytes would be needed to represent
    the specified Unicode source string as an ANSI string (not counting the
    null terminator)

Arguments:

    BytesInMultiByteString - Returns the number of bytes an ANSI translation
        of the Unicode string pointed to by UnicodeString would contain.

    UnicodeString - Supplies the unicode source string whose ANSI length
        is to be calculated.

    BytesInUnicodeString - The number of bytes in the the string pointed to by
        UnicodeString.

Return Value:

    SUCCESS - The conversion was successful

    !SUCCESS - The conversion failed.  A unicode character was encountered
        that has no translation for the current ANSI Code Page (ACP).

--*/

{
    RTL_PAGED_CODE();

    *BytesInMultiByteString = BytesInUnicodeString / sizeof(WCHAR);

    return STATUS_SUCCESS;
}


NTSTATUS
RtlUnicodeToMultiByteN(
    OUT PCH MultiByteString,
    IN ULONG MaxBytesInMultiByteString,
    OUT PULONG BytesInMultiByteString OPTIONAL,
    IN PWCH UnicodeString,
    IN ULONG BytesInUnicodeString)

/*++

Routine Description:

    This functions converts the specified unicode source string into an
    ansi string. The translation is done with respect to the
    ANSI Code Page (ACP) loaded at boot time.

Arguments:

    MultiByteString - Returns an ansi string that is equivalent to the
        unicode source string.  If the translation can not be done,
        an error is returned.

    MaxBytesInMultiByteString - Supplies the maximum number of bytes to be
        written to MultiByteString.  If this causes MultiByteString to be a
        truncated equivalent of UnicodeString, no error condition results.

    BytesInMultiByteString - Returns the number of bytes in the returned
        ansi string pointed to by MultiByteString.

    UnicodeString - Supplies the unicode source string that is to be
        converted to ansi.

    BytesInUnicodeString - The number of bytes in the the string pointed to by
        UnicodeString.

Return Value:

    SUCCESS - The conversion was successful

--*/

{
    ULONG LoopCount;
    ULONG CharsInUnicodeString;

    RTL_PAGED_CODE();

    CharsInUnicodeString = BytesInUnicodeString / sizeof(WCHAR);

    LoopCount = (CharsInUnicodeString < MaxBytesInMultiByteString) ?
                 CharsInUnicodeString : MaxBytesInMultiByteString;

    if (ARGUMENT_PRESENT(BytesInMultiByteString))
        *BytesInMultiByteString = LoopCount;

    while (LoopCount) {

        *MultiByteString = (*UnicodeString < 256) ? (UCHAR)*UnicodeString : '?';

        UnicodeString++;
        MultiByteString++;
        LoopCount--;
    }

    return STATUS_SUCCESS;
}


NTSTATUS
RtlUpcaseUnicodeToMultiByteN(
    OUT PCH MultiByteString,
    IN ULONG MaxBytesInMultiByteString,
    OUT PULONG BytesInMultiByteString OPTIONAL,
    IN PWCH UnicodeString,
    IN ULONG BytesInUnicodeString)

/*++

Routine Description:

    This functions upper cases the specified unicode source string and
    converts it into an ansi string. The translation is done with respect
    to the ANSI Code Page (ACP) loaded at boot time.

Arguments:

    MultiByteString - Returns an ansi string that is equivalent to the
        upper case of the unicode source string.  If the translation can
        not be done, an error is returned.

    MaxBytesInMultiByteString - Supplies the maximum number of bytes to be
        written to MultiByteString.  If this causes MultiByteString to be a
        truncated equivalent of UnicodeString, no error condition results.

    BytesInMultiByteString - Returns the number of bytes in the returned
        ansi string pointed to by MultiByteString.

    UnicodeString - Supplies the unicode source string that is to be
        converted to ansi.

    BytesInUnicodeString - The number of bytes in the the string pointed to by
        UnicodeString.

Return Value:

    SUCCESS - The conversion was successful

--*/

{
    ULONG LoopCount;
    ULONG CharsInUnicodeString;
    WCHAR UnicodeChar;

    RTL_PAGED_CODE();

    CharsInUnicodeString = BytesInUnicodeString / sizeof(WCHAR);

    LoopCount = (CharsInUnicodeString < MaxBytesInMultiByteString) ?
                 CharsInUnicodeString : MaxBytesInMultiByteString;

    if (ARGUMENT_PRESENT(BytesInMultiByteString))
        *BytesInMultiByteString = LoopCount;

    while (LoopCount) {

        //
        // Convert to ANSI and back to Unicode before upper casing
        // to ensure the visual best fits are converted and
        // upper cased properly.
        //
        UnicodeChar = (*UnicodeString < 256) ? *UnicodeString : L'?';
        UnicodeChar = NLS_UPCASE(UnicodeChar);

        *MultiByteString = (UnicodeChar < 256) ? (UCHAR)UnicodeChar : '?';

        UnicodeString++;
        MultiByteString++;
        LoopCount--;
    }

    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\rtl\random.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    Random.c

Abstract:

    This module implements a simple random number generator

Author:

    Gary Kimura     [GaryKi]    26-May-1989

Environment:

    Pure utility routine

Revision History:

--*/

#include <ntrtlp.h>

#define Multiplier ((ULONG)(0x80000000ul - 19)) // 2**31 - 19
#define Increment  ((ULONG)(0x80000000ul - 61)) // 2**31 - 61
#define Modulus    ((ULONG)(0x80000000ul - 1))  // 2**31 - 1

ULONG RtlpRandomConstantVector[128] = {
    0x4c8bc0aa, 0x4c022957, 0x2232827a, 0x2f1e7626, 0x7f8bdafb, 0x5c37d02a, 0x0ab48f72, 0x2f0c4ffa,
    0x290e1954, 0x6b635f23, 0x5d3885c0, 0x74b49ff8, 0x5155fa54, 0x6214ad3f, 0x111e9c29, 0x242a3a09,
    0x75932ae1, 0x40ac432e, 0x54f7ba7a, 0x585ccbd5, 0x6df5c727, 0x0374dad1, 0x7112b3f1, 0x735fc311,
    0x404331a9, 0x74d97781, 0x64495118, 0x323e04be, 0x5974b425, 0x4862e393, 0x62389c1d, 0x28a68b82,
    0x0f95da37, 0x7a50bbc6, 0x09b0091c, 0x22cdb7b4, 0x4faaed26, 0x66417ccd, 0x189e4bfa, 0x1ce4e8dd,
    0x5274c742, 0x3bdcf4dc, 0x2d94e907, 0x32eac016, 0x26d33ca3, 0x60415a8a, 0x31f57880, 0x68c8aa52,
    0x23eb16da, 0x6204f4a1, 0x373927c1, 0x0d24eb7c, 0x06dd7379, 0x2b3be507, 0x0f9c55b1, 0x2c7925eb,
    0x36d67c9a, 0x42f831d9, 0x5e3961cb, 0x65d637a8, 0x24bb3820, 0x4d08e33d, 0x2188754f, 0x147e409e,
    0x6a9620a0, 0x62e26657, 0x7bd8ce81, 0x11da0abb, 0x5f9e7b50, 0x23e444b6, 0x25920c78, 0x5fc894f0,
    0x5e338cbb, 0x404237fd, 0x1d60f80f, 0x320a1743, 0x76013d2b, 0x070294ee, 0x695e243b, 0x56b177fd,
    0x752492e1, 0x6decd52f, 0x125f5219, 0x139d2e78, 0x1898d11e, 0x2f7ee785, 0x4db405d8, 0x1a028a35,
    0x63f6f323, 0x1f6d0078, 0x307cfd67, 0x3f32a78a, 0x6980796c, 0x462b3d83, 0x34b639f2, 0x53fce379,
    0x74ba50f4, 0x1abc2c4b, 0x5eeaeb8d, 0x335a7a0d, 0x3973dd20, 0x0462d66b, 0x159813ff, 0x1e4643fd,
    0x06bc5c62, 0x3115e3fc, 0x09101613, 0x47af2515, 0x4f11ec54, 0x78b99911, 0x3db8dd44, 0x1ec10b9b,
    0x5b5506ca, 0x773ce092, 0x567be81a, 0x5475b975, 0x7a2cde1a, 0x494536f5, 0x34737bb4, 0x76d9750b,
    0x2a1f6232, 0x2e49644d, 0x7dddcbe7, 0x500cebdb, 0x619dab9e, 0x48c626fe, 0x1cda3193, 0x52dabe9d
    };

#if !defined(NTOS_KERNEL_RUNTIME)
ULONG
RtlUniform (
    IN OUT PULONG Seed
    )

/*++

Routine Description:

    A simple uniform random number generator, based on D.H. Lehmer's 1948
    alrogithm.

Arguments:

    Seed - Supplies a pointer to the random number generator seed.

Return Value:

    ULONG - returns a random number uniformly distributed over [0..MAXLONG]

--*/

{
    *Seed = ((Multiplier * (*Seed)) + Increment) % Modulus;
    return *Seed;
}
#endif

#define UniformMacro(Seed) (                                 \
    *Seed = (((Multiplier * (*Seed)) + Increment) % Modulus) \
    )


ULONG
RtlRandom (
    IN OUT PULONG Seed
    )

/*++

Routine Description:

    An every better random number generator based on MacLaren and Marsaglia.

Arguments:

    Seed - Supplies a pointer to the random number generator seed.

Return Value:

    ULONG - returns a random number uniformly distributed over [0..MAXLONG]

--*/

{
    ULONG X;
    ULONG Y;
    ULONG j;
    ULONG Result;

    // RTL_PAGED_CODE();

    X = UniformMacro(Seed);
    Y = UniformMacro(Seed);

    j = Y % 128;

    Result = RtlpRandomConstantVector[j];

    RtlpRandomConstantVector[j] = X;

    return Result;

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\rtl\stdtimep.h ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    stdtimep.h

Abstract:

    This module contains definitions and function prototypes which are local to
    stdime.c and fmttime.c.

Author:

    Rob McKaughan (t-robmc) 17-Jul-1991

Revision History:

--*/

#ifndef _STD_TIME_P_
#define _STD_TIME_P_

//
//  These are the magic numbers needed to do our extended division.  The
//  only numbers we ever need to divide by are
//
//      10,000 = convert 100ns tics to millisecond tics
//
//      10,000,000 = convert 100ns tics to one second tics
//
//      86,400,000 = convert Millisecond tics to one day tics
//

extern LARGE_INTEGER Magic10000;
#define SHIFT10000                       13

extern LARGE_INTEGER Magic10000000;
#define SHIFT10000000                    23

extern LARGE_INTEGER Magic86400000;
#define SHIFT86400000                    26

//
//  To make the code more readable we'll also define some macros to
//  do the actual division for use
//

#define Convert100nsToMilliseconds(LARGE_INTEGER) (                         \
    RtlExtendedMagicDivide( (LARGE_INTEGER), Magic10000, SHIFT10000 )       \
    )

#define ConvertMillisecondsTo100ns(MILLISECONDS) (                 \
    RtlExtendedIntegerMultiply( (MILLISECONDS), 10000 )            \
    )

#define Convert100nsToSeconds(LARGE_INTEGER) (                              \
    RtlExtendedMagicDivide( (LARGE_INTEGER), Magic10000000, SHIFT10000000 ) \
    )

#define ConvertSecondsTo100ns(SECONDS) (                           \
    RtlExtendedIntegerMultiply( (SECONDS), 10000000L )             \
    )

#define ConvertMillisecondsToDays(LARGE_INTEGER) (                          \
    RtlExtendedMagicDivide( (LARGE_INTEGER), Magic86400000, SHIFT86400000 ) \
    )

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Macros for Time Differentials and Time Revisions                          //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

//
// The following define the minimum and maximum possible values for the Time
// Differential Factor as defined by ISO 4031-1978.
//

#define MAX_STDTIME_TDF (780)
#define MIN_STDTIME_TDF (-720)

//
// The revision of this design (will be inserted in the revision field of any
// STANDARD_TIMEs created by this revision).
//

#define STDTIME_REVISION (4)


//
// The number of bits we need to shift to get to and from a revision in a
// StdTime.TdfAndRevision field.
//

#define STDTIME_REVISION_SHIFT 12


//
// USHORT
// ShiftStandardTimeRevision(
//    IN USHORT Rev
//    )
// Description:
//    This routine shifts the given revision number to its proper place for
//    storing in a STANDARD_TIME.TdfAndRevision field.
//

#define ShiftStandardTimeRevision(Rev)                                        \
   ((USHORT) ((Rev) << STDTIME_REVISION_SHIFT))


//
// The pre-shifted value of the current revision
//

#define SHIFTED_STDTIME_REVISION (ShiftStandardTimeRevision(STDTIME_REVISION))


//
// The bit mask used to mask a STANDARD_TIME.TdfAndRevision field to retrieve
// the Tdf value.
//

#define TDF_MASK ((USHORT) 0x0fff)


//
// USHORT
// MaskStandardTimeTdf(
//    IN USHORT Tdf
//    )
// Description:
//    This routine masks the given tdf field with TDF_MASK and returns the
//    result.
//
// BUG: Byte order dependant
//

#define MaskStandardTimeTdf(Tdf) ((USHORT) ((Tdf) & TDF_MASK))


//
// SHORT
// GetStandardTimeTdf(
//    IN STANDARD_TIME
//    )
// Description:
//    This routine gets the Time Differential Factor from a tdf field and
//    makes any adjustments necessary to preserve the sign of the TDF.
//    The resulting TDF is returned.
//
//    Since the TDF is stored as a signed 12 bit int, it's sign bit is the
//    bit 0x0800.  To make it a 16 bit negative, we subtract 0x1000 from the
//    bottome 12 bits of the TdfAndRevision field.
//
// BUG: Byte order dependant
//

#define GetStandardTimeTdf(StdTime)                                           \
   ((SHORT)                                                                   \
     (((StdTime)->TdfAndRevision) & 0x0800)                                   \
        ? (MaskStandardTimeTdf((StdTime)->TdfAndRevision) - 0x1000)           \
        : MaskStandardTimeTdf((StdTime)->TdfAndRevision)                      \
   )


//
// USHORT
// GetStandardTimeRev(
//    IN USHORT Tdf
//    )
// Description:
//    This routine gets the revision number from a tdf field and returns it
//    shifted back down to its place as a SHORT.
//

#define GetStandardTimeRev(StdTime)                                           \
   ((USHORT) (((StdTime)->TdfAndRevision) >> STDTIME_REVISION_SHIFT))



///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Tests for absolute and delta times                                        //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

//
// BOOLEAN
// IsPositive(
//    IN LARGE_INTEGER Time
//    )
// Returns:
//    TRUE - if the time in Time is positive.
//    FALSE - if Time is negative.
//

#define IsPositive(Time)                                                      \
   ( ((Time).HighPart > 0) || (((Time).HighPart = 0) & ((Time).LowPart > 0)) )

//
// BOOLEAN
// IsAbsoluteTime(
//    IN PSTANDARDTIME Time
//    )
// Returns:
//    TRUE - if the given time is an absolute time
//    FALSE - If the given time is not an absolute time
//

#define IsAbsoluteTime(Time)                                                  \
   ( IsPositive(Time->SimpleTime) )


//
// BOOLEAN
// IsDeltaTime(
//    IN PSTANDARDTIME Time
//    )
// Returns:
//    TRUE - if the given time is a delta time
//    FALSE - If the given time is not a delta time
//

#define IsDeltaTime(Time)                                                     \
   ( !IsAbsoluteTime(Time) )


//
// BOOLEAN
// GreaterThanTime(
//    IN PLARGE_INTEGER Time1,
//    IN PLARGE_INTEGER Time2
//    )
// Returns:
//    TRUE - If Time1 is greater (older) than Time2
//    FALSE - If not
//
// BUG: Byte order dependant
// BUG: Only works on absolute times
//

#define GreaterThanTime(Time1, Time2)                                         \
   (                                                                          \
     ((Time1).HighPart > (Time2).HighPart)                                    \
     ||                                                                       \
     (                                                                        \
      ((Time1).HighPart == (Time2).HighPart)                                  \
      &&                                                                      \
      ((Time1).LowPart > (Time2).LowPart)                                     \
     )                                                                        \
   )


//
// BOOLEAN
// GreaterThanStandardTime(
//    IN PSTANDARD_TIME Time1,
//    IN PSTANDARD_TIME Time2
//    )
// Returns:
//    TRUE - If Time1 is greater (older) than Time2
//    FALSE - If not
//

#define GreaterThanStdTime(Time1, Time2) \
   GreaterThanTime((Time1).SimpleTime, (Time2).SimpleTime)



//////////////////////////////////////////////////////////////////////////////
//                                                                           /
//  The following definitions and declarations are some important constants  /
//  used in the time conversion routines                                     /
//                                                                           /
//////////////////////////////////////////////////////////////////////////////

//
//  This is the week day that January 1st, 1601 fell on (a Monday)
//

#define WEEKDAY_OF_1601                  1

//
//  These are known constants used to convert 1970 and 1980 times to 1601
//  times.  They are the number of seconds from the 1601 base to the start
//  of 1970 and the start of 1980.  The number of seconds from 1601 to
//  1970 is 369 years worth, or (369 * 365) + 89 leap days = 134774 days, or
//  134774 * 864000 seconds, which is equal to the large integer defined
//  below.  The number of seconds from 1601 to 1980 is 379 years worth, or etc.
//
//  These are declared in time.c
//

extern LARGE_INTEGER SecondsToStartOf1970;
extern LARGE_INTEGER SecondsToStartOf1980;


//
//  ULONG
//  ElapsedDaysToYears (
//      IN ULONG ElapsedDays
//      );
//
//  To be completely true to the Gregorian calendar the equation to
//  go from days to years is really
//
//      ElapsedDays / 365.2425
//
//  But because we are doing the computation in ulong integer arithmetic
//  and the LARGE_INTEGER variable limits the number of expressible days to around
//  11,000,000 we use the following computation
//
//      (ElapsedDays * 128 + 127) / (365.2425 * 128)
//
//  which will be off from the Gregorian calendar in about 150,000 years
//  but that doesn't really matter because LARGE_INTEGER can only express around
//  30,000 years
//

#define ElapsedDaysToYears(DAYS) ( \
    ((DAYS) * 128 + 127) / 46751   \
    )

//
//  ULONG
//  NumberOfLeapYears (
//      IN ULONG ElapsedYears
//      );
//
//  The number of leap years is simply the number of years divided by 4
//  minus years divided by 100 plus years divided by 400.  This says
//  that every four years is a leap year except centuries, and the
//  exception to the exception is the quadricenturies
//

#define NumberOfLeapYears(YEARS) (                    \
    ((YEARS) / 4) - ((YEARS) / 100) + ((YEARS) / 400) \
    )

//
//  ULONG
//  ElapsedYearsToDays (
//      IN ULONG ElapsedYears
//      );
//
//  The number of days contained in elapsed years is simply the number
//  of years times 365 (because every year has at least 365 days) plus
//  the number of leap years there are (i.e., the number of 366 days years)
//

#define ElapsedYearsToDays(YEARS) (            \
    ((YEARS) * 365) + NumberOfLeapYears(YEARS) \
    )

//
//  BOOLEAN
//  IsLeapYear (
//      IN ULONG ElapsedYears
//      );
//
//  If it is an even 400 or a non century leapyear then the
//  answer is true otherwise it's false
//

#define IsLeapYear(YEARS) (                        \
    (((YEARS) % 400 == 0) ||                       \
     ((YEARS) % 100 != 0) && ((YEARS) % 4 == 0)) ? \
        TRUE                                       \
    :                                              \
        FALSE                                      \
    )

//
//  ULONG
//  MaxDaysInMonth (
//      IN ULONG Year,
//      IN ULONG Month
//      );
//
//  The maximum number of days in a month depend on the year and month.
//  It is the difference between the days to the month and the days
//  to the following month
//

#define MaxDaysInMonth(YEAR,MONTH) (                                      \
    IsLeapYear(YEAR) ?                                                    \
        LeapYearDaysPrecedingMonth[(MONTH) + 1] -                         \
                                    LeapYearDaysPrecedingMonth[(MONTH)]   \
    :                                                                     \
        NormalYearDaysPrecedingMonth[(MONTH) + 1] -                       \
                                    NormalYearDaysPrecedingMonth[(MONTH)] \
    )


//
// Local utlity function prototypes
//

VOID
RtlpConvert48To64(
   IN PSTDTIME_ERROR num48,
   OUT LARGE_INTEGER *num64
   );

NTSTATUS
RtlpConvert64To48(
   IN LARGE_INTEGER num64,
   OUT PSTDTIME_ERROR num48
   );

LARGE_INTEGER
RtlpTimeToLargeInt(
   IN LARGE_INTEGER Time
   );

LARGE_INTEGER
RtlpLargeIntToTime(
   IN LARGE_INTEGER Int
   );

NTSTATUS
RtlpAdd48Int(
   IN PSTDTIME_ERROR First48,
   IN PSTDTIME_ERROR Second48,
   IN PSTDTIME_ERROR Result48
   );

NTSTATUS
RtlpAddTime(
   IN LARGE_INTEGER Time1,
   IN LARGE_INTEGER Time2,
   OUT PLARGE_INTEGER Result
   );

NTSTATUS
RtlpSubtractTime(
   IN LARGE_INTEGER Time1,
   IN LARGE_INTEGER Time2,
   OUT PLARGE_INTEGER Result
   );

LARGE_INTEGER
RtlpAbsTime(
   IN LARGE_INTEGER Time
   );

#endif //_STD_TIME_P_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\rtl\ntrtlp.h ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    ntrtlp.h

Abstract:

    Include file for NT runtime routines that are callable by both
    kernel mode code in the executive and user mode code in various
    NT subsystems, but which are private interfaces.

Author:

    David N. Cutler (davec) 15-Aug-1989

Environment:

    These routines are statically linked in the caller's executable and
    are callable in either kernel mode or user mode.

Revision History:

--*/

#ifndef _NTRTLP_
#define _NTRTLP_
#include <ntos.h>
#include <nturtl.h>
#include <zwapi.h>

#ifdef _X86_
#include    "i386\ntrtl386.h"
#endif

#ifdef BLDR_KERNEL_RUNTIME
#undef try
#define try if(1)
#undef except
#define except(a) else if (0)
#undef finally
#define finally if (1)
#undef GetExceptionCode
#define GetExceptionCode() 1
#define finally if (1)
#endif

#ifdef NTOS_KERNEL_RUNTIME
#define RtlAllocateStringRoutine(cb) ExAllocatePoolWithTag((cb), 'grtS')
#define RtlFreeStringRoutine(pv) ExFreePool(pv)
#endif

#include "string.h"
#include "wchar.h"

//
//  Machine state reporting.  See machine specific includes for more.
//

VOID
RtlpGetStackLimits (
    OUT PULONG_PTR LowLimit,
    OUT PULONG_PTR HighLimit
    );

LONG
LdrpCompareResourceNames(
    IN ULONG ResourceName,
    IN PIMAGE_RESOURCE_DIRECTORY ResourceDirectory,
    IN PIMAGE_RESOURCE_DIRECTORY_ENTRY ResourceDirectoryEntry
    );

NTSTATUS
LdrpSearchResourceSection(
    IN PVOID DllHandle,
    IN PULONG_PTR ResourceIdPath,
    IN ULONG ResourceIdPathLength,
    IN BOOLEAN FindDirectoryEntry,
    OUT PVOID *ResourceDirectoryOrData
    );

LONG
LdrpCompareResourceNames_U(
    IN ULONG_PTR ResourceName,
    IN PIMAGE_RESOURCE_DIRECTORY ResourceDirectory,
    IN PIMAGE_RESOURCE_DIRECTORY_ENTRY ResourceDirectoryEntry
    );

NTSTATUS
LdrpSearchResourceSection_U(
    IN PVOID DllHandle,
    IN PULONG_PTR ResourceIdPath,
    IN ULONG ResourceIdPathLength,
    IN BOOLEAN FindDirectoryEntry,
    IN BOOLEAN ExactMatchOnly,
    OUT PVOID *ResourceDirectoryOrData
    );

NTSTATUS
LdrpAccessResourceData(
    IN PVOID DllHandle,
    IN PIMAGE_RESOURCE_DATA_ENTRY ResourceDataEntry,
    OUT PVOID *Address OPTIONAL,
    OUT PULONG Size OPTIONAL
    );

extern CONST CCHAR RtlpBitsClearAnywhere[256];
extern CONST CCHAR RtlpBitsClearLow[256];
extern CONST CCHAR RtlpBitsClearHigh[256];
extern CONST CCHAR RtlpBitsClearTotal[256];

//
//  Macro that tells how many contiguous bits are set (i.e., 1) in
//  a byte
//

#define RtlpBitSetAnywhere( Byte ) RtlpBitsClearAnywhere[ (~(Byte) & 0xFF) ]


//
//  Macro that tells how many contiguous LOW order bits are set
//  (i.e., 1) in a byte
//

#define RtlpBitsSetLow( Byte ) RtlpBitsClearLow[ (~(Byte) & 0xFF) ]


//
//  Macro that tells how many contiguous HIGH order bits are set
//  (i.e., 1) in a byte
//

#define RtlpBitsSetHigh( Byte ) RtlpBitsClearHigh[ (~(Byte) & 0xFF) ]


//
//  Macro that tells how many set bits (i.e., 1) there are in a byte
//

#define RtlpBitsSetTotal( Byte ) RtlpBitsClearTotal[ (~(Byte) & 0xFF) ]



//
// Upcase data table
//

extern const UCHAR Nls844UnicodeCaseTableLevel1[];
extern const UCHAR Nls844UnicodeUpcaseTableLevel2[];
extern const UCHAR Nls844UnicodeLowercaseTableLevel2[];
extern const USHORT Nls844UnicodeCaseTableLevel3[];


//
// Macros for Upper Casing a Unicode Code Point.
//

#define LOBYTE(w)           ((UCHAR)((w)))
#define HIBYTE(w)           ((UCHAR)(((USHORT)((w)) >> 8) & 0xFF))
#define GET8(w)             ((ULONG)(((w) >> 8) & 0xff))
#define GETHI4(w)           ((ULONG)(((w) >> 4) & 0xf))
#define GETLO4(w)           ((ULONG)((w) & 0xf))

/***************************************************************************\
* TRAVERSE844W
*
* Traverses the 8:4:4 translation table for the given wide character.  It
* returns the final value of the 8:4:4 table, which is a WORD in length.
*
*   Broken Down Version:
*   --------------------
*       Incr = pTable[GET8(wch)];
*       Incr = pTable[Incr + GETHI4(wch)];
*       Value = pTable[Incr + GETLO4(wch)];
*
* DEFINED AS A MACRO.
*
* 05-31-91    JulieB    Created.
\***************************************************************************/

#define TRAVERSE844W(pTable, wch)                                           \
    Nls844UnicodeCaseTableLevel3[(4*((pTable)[Nls844UnicodeCaseTableLevel1[GET8(wch)] + GETHI4(wch)])) + GETLO4(wch)]

//
// NLS_UPCASE - Based on julieb's macros in nls.h
//
// We will have this upcase macro quickly shortcircuit out if the value
// is within the normal ANSI range (i.e., < 127).  We actually won't bother
// with the 5 values above 'z' because they won't happen very often and
// coding it this way lets us get out after 1 compare for value less than
// 'a' and 2 compares for lowercase a-z.
//

#define NLS_UPCASE(wch) (                                                   \
    ((wch) < 'a' ?                                                          \
        (wch)                                                               \
    :                                                                       \
        ((wch) <= 'z' ?                                                     \
            (wch) - ('a'-'A')                                               \
        :                                                                   \
            ((WCHAR)((wch) - TRAVERSE844W(Nls844UnicodeUpcaseTableLevel2,(wch)))) \
        )                                                                   \
    )                                                                       \
)

#define NLS_DOWNCASE(wch) (                                                 \
    ((wch) < 'A' ?                                                          \
        (wch)                                                               \
    :                                                                       \
        ((wch) <= 'Z' ?                                                     \
            (wch) + ('a'-'A')                                               \
        :                                                                   \
            ((WCHAR)((wch) + TRAVERSE844W(Nls844UnicodeLowercaseTableLevel2,(wch)))) \
        )                                                                   \
    )                                                                       \
)

#if DBG && defined(NTOS_KERNEL_RUNTIME)
#define RTL_PAGED_CODE() PAGED_CODE()
#else
#define RTL_PAGED_CODE()
#endif


//
// The follow definition is used to support the Rtl compression engine
// Every compression format that NT supports will need to supply
// these set of routines in order to be called by NtRtl.
//

typedef NTSTATUS (*PRTL_COMPRESS_WORKSPACE_SIZE) (
    IN USHORT CompressionEngine,
    OUT PULONG CompressBufferWorkSpaceSize,
    OUT PULONG CompressFragmentWorkSpaceSize
    );

typedef NTSTATUS (*PRTL_COMPRESS_BUFFER) (
    IN USHORT CompressionEngine,
    IN PUCHAR UncompressedBuffer,
    IN ULONG UncompressedBufferSize,
    OUT PUCHAR CompressedBuffer,
    IN ULONG CompressedBufferSize,
    IN ULONG UncompressedChunkSize,
    OUT PULONG FinalCompressedSize,
    IN PVOID WorkSpace
    );

typedef NTSTATUS (*PRTL_DECOMPRESS_BUFFER) (
    OUT PUCHAR UncompressedBuffer,
    IN ULONG UncompressedBufferSize,
    IN PUCHAR CompressedBuffer,
    IN ULONG CompressedBufferSize,
    OUT PULONG FinalUncompressedSize
    );

typedef NTSTATUS (*PRTL_DECOMPRESS_FRAGMENT) (
    OUT PUCHAR UncompressedFragment,
    IN ULONG UncompressedFragmentSize,
    IN PUCHAR CompressedBuffer,
    IN ULONG CompressedBufferSize,
    IN ULONG FragmentOffset,
    OUT PULONG FinalUncompressedSize,
    IN PVOID WorkSpace
    );

typedef NTSTATUS (*PRTL_DESCRIBE_CHUNK) (
    IN OUT PUCHAR *CompressedBuffer,
    IN PUCHAR EndOfCompressedBufferPlus1,
    OUT PUCHAR *ChunkBuffer,
    OUT PULONG ChunkSize
    );

typedef NTSTATUS (*PRTL_RESERVE_CHUNK) (
    IN OUT PUCHAR *CompressedBuffer,
    IN PUCHAR EndOfCompressedBufferPlus1,
    OUT PUCHAR *ChunkBuffer,
    IN ULONG ChunkSize
    );

//
// Here is the declarations of the LZNT1 routines
//

NTSTATUS
RtlCompressWorkSpaceSizeLZNT1 (
    IN USHORT CompressionEngine,
    OUT PULONG CompressBufferWorkSpaceSize,
    OUT PULONG CompressFragmentWorkSpaceSize
    );

NTSTATUS
RtlCompressBufferLZNT1 (
    IN USHORT CompressionEngine,
    IN PUCHAR UncompressedBuffer,
    IN ULONG UncompressedBufferSize,
    OUT PUCHAR CompressedBuffer,
    IN ULONG CompressedBufferSize,
    IN ULONG UncompressedChunkSize,
    OUT PULONG FinalCompressedSize,
    IN PVOID WorkSpace
    );

NTSTATUS
RtlDecompressBufferLZNT1 (
    OUT PUCHAR UncompressedBuffer,
    IN ULONG UncompressedBufferSize,
    IN PUCHAR CompressedBuffer,
    IN ULONG CompressedBufferSize,
    OUT PULONG FinalUncompressedSize
    );

NTSTATUS
RtlDecompressFragmentLZNT1 (
    OUT PUCHAR UncompressedFragment,
    IN ULONG UncompressedFragmentSize,
    IN PUCHAR CompressedBuffer,
    IN ULONG CompressedBufferSize,
    IN ULONG FragmentOffset,
    OUT PULONG FinalUncompressedSize,
    IN PVOID WorkSpace
    );

NTSTATUS
RtlDescribeChunkLZNT1 (
    IN OUT PUCHAR *CompressedBuffer,
    IN PUCHAR EndOfCompressedBufferPlus1,
    OUT PUCHAR *ChunkBuffer,
    OUT PULONG ChunkSize
    );

NTSTATUS
RtlReserveChunkLZNT1 (
    IN OUT PUCHAR *CompressedBuffer,
    IN PUCHAR EndOfCompressedBufferPlus1,
    OUT PUCHAR *ChunkBuffer,
    IN ULONG ChunkSize
    );

//
// Define procedure prototypes for architecture specific debug support routines.
//

NTSTATUS
DebugPrint(
    IN PSTRING Output
    );

ULONG
DebugPrompt(
    IN PSTRING Output,
    IN PSTRING Input
    );


//
// Define procedure prototypes for slist manipulation and general lookaside lists
//

/*++

VOID
RtlpInitializeSListHead (
    IN PSLIST_HEADER SListHead
    )

Routine Description:

    This function initializes a sequenced singly linked listhead.

Arguments:

    SListHead - Supplies a pointer to a sequenced singly linked listhead.

Return Value:

    None.

--*/

#define RtlpInitializeSListHead(_listhead_) (_listhead_)->Alignment = 0

/*++

USHORT
RtlpQueryDepthSListHead (
    IN PSLIST_HEADERT SListHead
    )

Routine Description:

    This function queries the current number of entries contained in a
    sequenced single linked list.

Arguments:

    SListHead - Supplies a pointer to the sequenced listhead which is
        be queried.

Return Value:

    The current number of entries in the sequenced singly linked list is
    returned as the function value.

--*/

#define RtlpQueryDepthSList(_listhead_) (_listhead_)->Depth

PVOID
FASTCALL
RtlpInterlockedPopEntrySList (
    IN PSLIST_HEADER ListHead
    );

PVOID
FASTCALL
RtlpInterlockedPushEntrySList (
    IN PSLIST_HEADER ListHead,
    IN PVOID ListEntry
    );


#if defined(NTOS_KERNEL_RUNTIME) || defined(BLDR_KERNEL_RUNTIME)

VOID
DebugLoadImageSymbols(
    IN PSTRING FileName,
    IN PKD_SYMBOLS_INFO SymbolInfo
    );

VOID
DebugUnLoadImageSymbols(
    IN PSTRING FileName,
    IN PKD_SYMBOLS_INFO SymbolInfo
    );

#endif // defined(NTOS_KERNEL_RUNTIME)

#endif  // _NTRTLP_

//
// Procedure prototype for exception logging routines.

ULONG
RtlpLogExceptionHandler(
    IN PEXCEPTION_RECORD ExceptionRecord,
    IN PCONTEXT ContextRecord,
    IN ULONG_PTR ControlPc,
    IN PVOID HandlerData,
    IN ULONG Size
    );

VOID
RtlpLogLastExceptionDisposition(
    IN ULONG LogIndex,
    IN EXCEPTION_DISPOSITION Disposition
    );

#ifndef NTOS_KERNEL_RUNTIME

#define NO_ALTERNATE_RESOURCE_MODULE    (PVOID)(-1)

typedef struct _ALT_RESOURCE_MODULE {
    //
    // Module handle for module known to application,
    // whose resource accesses we want to redirect.
    //
    PVOID ModuleBase;
    //
    // Module handle for module we loaded under the covers,
    // to which resource access will be redirected; will be
    // NO_ALTERNATE_RESOURCE_MODULE if we tried and failed to load
    // the alternate resource module for the module represented by
    // ModuleBase.
    //
    PVOID AlternateModule;
} ALT_RESOURCE_MODULE, *PALT_RESOURCE_MODULE;

BOOLEAN
LdrpVerifyAlternateResourceModule(
    IN PVOID Module,
    IN PVOID AlternateModule
    );

BOOLEAN
LdrpSetAlternateResourceModuleHandle(
    IN PVOID Module,
    IN PVOID AlternateModule
    );
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\rtl\time.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    Time.c

Abstract:

    This module implements the absolute time conversion routines for NT.

    Absolute LARGE_INTEGER in NT is represented by a 64-bit large integer accurate
    to 100ns resolution.  The smallest time resolution used by this package
    is One millisecond.  The basis for NT time is the start of 1601 which
    was chosen because it is the start of a new quadricentury.  Some facts
    to note are:

    o At 100ns resolution 32 bits is good for about 429 seconds (or 7 minutes)

    o At 100ns resolution a large integer (i.e., 63 bits) is good for
      about 29,247 years, or around 10,682,247 days.

    o At 1 second resolution 31 bits is good for about 68 years

    o At 1 second resolution 32 bits is good for about 136 years

    o 100ns Time (ignoring time less than a millisecond) can be expressed
      as two values, Days and Milliseconds.  Where Days is the number of
      whole days and Milliseconds is the number of milliseconds for the
      partial day.  Both of these values are ULONG.

    Given these facts most of the conversions are done by first splitting
    LARGE_INTEGER into Days and Milliseconds.

Author:

    Gary Kimura     [GaryKi]    26-Aug-1989

Environment:

    Pure utility routine

Revision History:

--*/

#include "ntrtlp.h"


//
//  The following two tables map a month index to the number of days preceding
//  the month in the year.  Both tables are zero based.  For example, 1 (Feb)
//  has 31 days preceding it.  To help calculate the maximum number of days
//  in a month each table has 13 entries, so the number of days in a month
//  of index i is the table entry of i+1 minus the table entry of i.
//

CONST CSHORT LeapYearDaysPrecedingMonth[13] = {
    0,                                 // January
    31,                                // February
    31+29,                             // March
    31+29+31,                          // April
    31+29+31+30,                       // May
    31+29+31+30+31,                    // June
    31+29+31+30+31+30,                 // July
    31+29+31+30+31+30+31,              // August
    31+29+31+30+31+30+31+31,           // September
    31+29+31+30+31+30+31+31+30,        // October
    31+29+31+30+31+30+31+31+30+31,     // November
    31+29+31+30+31+30+31+31+30+31+30,  // December
    31+29+31+30+31+30+31+31+30+31+30+31};

CONST CSHORT NormalYearDaysPrecedingMonth[13] = {
    0,                                 // January
    31,                                // February
    31+28,                             // March
    31+28+31,                          // April
    31+28+31+30,                       // May
    31+28+31+30+31,                    // June
    31+28+31+30+31+30,                 // July
    31+28+31+30+31+30+31,              // August
    31+28+31+30+31+30+31+31,           // September
    31+28+31+30+31+30+31+31+30,        // October
    31+28+31+30+31+30+31+31+30+31,     // November
    31+28+31+30+31+30+31+31+30+31+30,  // December
    31+28+31+30+31+30+31+31+30+31+30+31};


//
//  The following definitions and declarations are some important constants
//  used in the time conversion routines
//

//
//  This is the week day that January 1st, 1601 fell on (a Monday)
//

#define WEEKDAY_OF_1601                  1

//
//  These are the magic numbers needed to do our extended division.  The
//  only numbers we ever need to divide by are
//
//      10,000 = convert 100ns tics to millisecond tics
//
//      10,000,000 = convert 100ns tics to one second tics
//
//      86,400,000 = convert Millisecond tics to one day tics
//

const LARGE_INTEGER Magic10000    = {0xe219652c, 0xd1b71758};
#define SHIFT10000                       13

const LARGE_INTEGER Magic10000000 = {0xe57a42bd, 0xd6bf94d5};
#define SHIFT10000000                    23

const LARGE_INTEGER Magic86400000 = {0xfa67b90e, 0xc6d750eb};
#define SHIFT86400000                    26

//
//  To make the code more readable we'll also define some macros to
//  do the actual division for use
//

#define Convert100nsToMilliseconds(LARGE_INTEGER) (                         \
    RtlExtendedMagicDivide( (LARGE_INTEGER), Magic10000, SHIFT10000 )       \
    )

#define ConvertMillisecondsTo100ns(MILLISECONDS) (                 \
    RtlExtendedIntegerMultiply( (MILLISECONDS), 10000 )            \
    )

#define Convert100nsToSeconds(LARGE_INTEGER) (                              \
    RtlExtendedMagicDivide( (LARGE_INTEGER), Magic10000000, SHIFT10000000 ) \
    )

#define ConvertSecondsTo100ns(SECONDS) (                           \
    RtlExtendedIntegerMultiply( (SECONDS), 10000000 )              \
    )

#define ConvertMillisecondsToDays(LARGE_INTEGER) (                          \
    RtlExtendedMagicDivide( (LARGE_INTEGER), Magic86400000, SHIFT86400000 ) \
    )

#define ConvertDaysToMilliseconds(DAYS) (                          \
    Int32x32To64( (DAYS), 86400000 )                               \
    )


//
//  Local support routine
//

ULONG
ElapsedDaysToYears (
    IN ULONG ElapsedDays
    )

/*++

Routine Description:

    This routine computes the number of total years contained in the indicated
    number of elapsed days.  The computation is to first compute the number of
    400 years and subtract that it, then do the 100 years and subtract that out,
    then do the number of 4 years and subtract that out.  Then what we have left
    is the number of days with in a normalized 4 year block.  Normalized being that
    the first three years are not leap years.

Arguments:

    ElapsedDays - Supplies the number of days to use

Return Value:

    ULONG - Returns the number of whole years contained within the input number
        of days.

--*/

{
    ULONG NumberOf400s;
    ULONG NumberOf100s;
    ULONG NumberOf4s;
    ULONG Years;

    //
    //  A 400 year time block is 365*400 + 400/4 - 400/100 + 400/400 = 146097 days
    //  long.  So we simply compute the number of whole 400 year block and the
    //  the number days contained in those whole blocks, and subtract if from the
    //  elapsed day total
    //

    NumberOf400s = ElapsedDays / 146097;
    ElapsedDays -= NumberOf400s * 146097;

    //
    //  A 100 year time block is 365*100 + 100/4 - 100/100 = 36524 days long.
    //  The computation for the number of 100 year blocks is biased by 3/4 days per
    //  100 years to account for the extra leap day thrown in on the last year
    //  of each 400 year block.
    //

    NumberOf100s = (ElapsedDays * 100 + 75) / 3652425;
    ElapsedDays -= NumberOf100s * 36524;

    //
    //  A 4 year time block is 365*4 + 4/4 = 1461 days long.
    //

    NumberOf4s = ElapsedDays / 1461;
    ElapsedDays -= NumberOf4s * 1461;

    //
    //  Now the number of whole years is the number of 400 year blocks times 400,
    //  100 year blocks time 100, 4 year blocks times 4, and the number of elapsed
    //  whole years, taking into account the 3/4 day per year needed to handle the
    //  leap year.
    //

    Years = (NumberOf400s * 400) +
            (NumberOf100s * 100) +
            (NumberOf4s * 4) +
            (ElapsedDays * 100 + 75) / 36525;

    return Years;
}


//
//  ULONG
//  NumberOfLeapYears (
//      IN ULONG ElapsedYears
//      );
//
//  The number of leap years is simply the number of years divided by 4
//  minus years divided by 100 plus years divided by 400.  This says
//  that every four years is a leap year except centuries, and the
//  exception to the exception is the quadricenturies
//

#define NumberOfLeapYears(YEARS) (                    \
    ((YEARS) / 4) - ((YEARS) / 100) + ((YEARS) / 400) \
    )

//
//  ULONG
//  ElapsedYearsToDays (
//      IN ULONG ElapsedYears
//      );
//
//  The number of days contained in elapsed years is simply the number
//  of years times 365 (because every year has at least 365 days) plus
//  the number of leap years there are (i.e., the number of 366 days years)
//

#define ElapsedYearsToDays(YEARS) (            \
    ((YEARS) * 365) + NumberOfLeapYears(YEARS) \
    )

//
//  BOOLEAN
//  IsLeapYear (
//      IN ULONG ElapsedYears
//      );
//
//  If it is an even 400 or a non century leapyear then the
//  answer is true otherwise it's false
//

#define IsLeapYear(YEARS) (                        \
    (((YEARS) % 400 == 0) ||                       \
     ((YEARS) % 100 != 0) && ((YEARS) % 4 == 0)) ? \
        TRUE                                       \
    :                                              \
        FALSE                                      \
    )

//
//  ULONG
//  MaxDaysInMonth (
//      IN ULONG Year,
//      IN ULONG Month
//      );
//
//  The maximum number of days in a month depend on the year and month.
//  It is the difference between the days to the month and the days
//  to the following month
//

#define MaxDaysInMonth(YEAR,MONTH) (                                      \
    IsLeapYear(YEAR) ?                                                    \
        LeapYearDaysPrecedingMonth[(MONTH) + 1] -                         \
                                    LeapYearDaysPrecedingMonth[(MONTH)]   \
    :                                                                     \
        NormalYearDaysPrecedingMonth[(MONTH) + 1] -                       \
                                    NormalYearDaysPrecedingMonth[(MONTH)] \
    )



//
//  Internal Support routine
//

static
VOID
TimeToDaysAndFraction (
    IN PLARGE_INTEGER Time,
    OUT PULONG ElapsedDays,
    OUT PULONG Milliseconds
    )

/*++

Routine Description:

    This routine converts an input 64-bit time value to the number
    of total elapsed days and the number of milliseconds in the
    partial day.

Arguments:

    Time - Supplies the input time to convert from

    ElapsedDays - Receives the number of elapsed days

    Milliseconds - Receives the number of milliseconds in the partial day

Return Value:

    None

--*/

{
    LARGE_INTEGER TotalMilliseconds;
    LARGE_INTEGER Temp;

    //
    //  Convert the input time to total milliseconds
    //

    TotalMilliseconds = Convert100nsToMilliseconds( *(PLARGE_INTEGER)Time );

    //
    //  Convert milliseconds to total days
    //

    Temp = ConvertMillisecondsToDays( TotalMilliseconds );

    //
    //  Set the elapsed days from temp, we've divided it enough so that
    //  the high part must be zero.
    //

    *ElapsedDays = Temp.LowPart;

    //
    //  Calculate the exact number of milliseconds in the elapsed days
    //  and subtract that from the total milliseconds to figure out
    //  the number of milliseconds left in the partial day
    //

    Temp.QuadPart = ConvertDaysToMilliseconds( *ElapsedDays );

    Temp.QuadPart = TotalMilliseconds.QuadPart - Temp.QuadPart;

    //
    //  Set the fraction part from temp, the total number of milliseconds in
    //  a day guarantees that the high part must be zero.
    //

    *Milliseconds = Temp.LowPart;

    //
    //  And return to our caller
    //

    return;
}


//
//  Internal Support routine
//

//static
VOID
DaysAndFractionToTime (
    IN ULONG ElapsedDays,
    IN ULONG Milliseconds,
    OUT PLARGE_INTEGER Time
    )

/*++

Routine Description:

    This routine converts an input elapsed day count and partial time
    in milliseconds to a 64-bit time value.

Arguments:

    ElapsedDays - Supplies the number of elapsed days

    Milliseconds - Supplies the number of milliseconds in the partial day

    Time - Receives the output time to value

Return Value:

    None

--*/

{
    LARGE_INTEGER Temp;
    LARGE_INTEGER Temp2;

    //
    //  Calculate the exact number of milliseconds in the elapsed days.
    //

    Temp.QuadPart = ConvertDaysToMilliseconds( ElapsedDays );

    //
    //  Convert milliseconds to a large integer
    //

    Temp2.LowPart = Milliseconds;
    Temp2.HighPart = 0;

    //
    //  add milliseconds to the whole day milliseconds
    //

    Temp.QuadPart = Temp.QuadPart + Temp2.QuadPart;

    //
    //  Finally convert the milliseconds to 100ns resolution
    //

    *(PLARGE_INTEGER)Time = ConvertMillisecondsTo100ns( Temp );

    //
    //  and return to our caller
    //

    return;
}


VOID
RtlTimeToTimeFields (
    IN PLARGE_INTEGER Time,
    OUT PTIME_FIELDS TimeFields
    )

/*++

Routine Description:

    This routine converts an input 64-bit LARGE_INTEGER variable to its corresponding
    time field record.  It will tell the caller the year, month, day, hour,
    minute, second, millisecond, and weekday corresponding to the input time
    variable.

Arguments:

    Time - Supplies the time value to interpret

    TimeFields - Receives a value corresponding to Time

Return Value:

    None

--*/

{
    ULONG Years;
    ULONG Month;
    ULONG Days;

    ULONG Hours;
    ULONG Minutes;
    ULONG Seconds;
    ULONG Milliseconds;

    CONST CSHORT *DaysPrecedingMonthTable;

    //
    //  First divide the input time 64 bit time variable into
    //  the number of whole days and part days (in milliseconds)
    //

    TimeToDaysAndFraction( Time, &Days, &Milliseconds );

    //
    //  Compute which weekday it is and save it away now in the output
    //  variable.  We add the weekday of the base day to bias our computation
    //  which means that if one day has elapsed then we the weekday we want
    //  is the Jan 2nd, 1601.
    //

    TimeFields->Weekday = (CSHORT)((Days + WEEKDAY_OF_1601) % 7);

    //
    //  Calculate the number of whole years contained in the elapsed days
    //  For example if Days = 500 then Years = 1
    //

    Years = ElapsedDaysToYears( Days );

    //
    //  And subtract the number of whole years from our elapsed days
    //  For example if Days = 500, Years = 1, and the new days is equal
    //  to 500 - 365 (normal year).
    //

    Days = Days - ElapsedYearsToDays( Years );

    //
    //  Now test whether the year we are working on (i.e., The year
    //  after the total number of elapsed years) is a leap year
    //  or not.
    //

    if (IsLeapYear( Years + 1 )) {

        DaysPrecedingMonthTable = LeapYearDaysPrecedingMonth;

    } else {

        DaysPrecedingMonthTable = NormalYearDaysPrecedingMonth;
    }

    //
    //  Figure out what month it is, and then subtract the number of days
    //  preceding the month from the days to figure out whay day of the month
    //  it is.
    //

    for (Month = 1; Month <= 12; Month++) {

        if (Days < (USHORT)DaysPrecedingMonthTable[Month]) {

            Days = Days - DaysPrecedingMonthTable[Month - 1] + 1;
            break;
        }
    }

    ASSERT(Month <= 12);
    ASSERT(Days >= 1 && Days <= 31);

    //
    //  Now we need to compute the elapsed hour, minute, second, milliseconds
    //  from the millisecond variable.  This variable currently contains
    //  the number of milliseconds in our input time variable that did not
    //  fit into a whole day.  To compute the hour, minute, second part
    //  we will actually do the arithmetic backwards computing milliseconds
    //  seconds, minutes, and then hours.  We start by computing the
    //  number of whole seconds left in the day, and then computing
    //  the millisecond remainder.
    //

    Seconds = Milliseconds / 1000;
    Milliseconds = Milliseconds % 1000;

    //
    //  Now we compute the number of whole minutes left in the day
    //  and the number of remainder seconds
    //

    Minutes = Seconds / 60;
    Seconds = Seconds % 60;

    //
    //  Now compute the number of whole hours left in the day
    //  and the number of remainder minutes
    //

    Hours = Minutes / 60;
    Minutes = Minutes % 60;

    //
    //  As our final step we put everything into the time fields
    //  output variable
    //

    TimeFields->Year         = (CSHORT)(Years + 1601);
    TimeFields->Month        = (CSHORT)Month;
    TimeFields->Day          = (CSHORT)Days;
    TimeFields->Hour         = (CSHORT)Hours;
    TimeFields->Minute       = (CSHORT)Minutes;
    TimeFields->Second       = (CSHORT)Seconds;
    TimeFields->Milliseconds = (CSHORT)Milliseconds;

    //
    //  and return to our caller
    //

    return;
}



BOOLEAN
RtlTimeFieldsToTime (
    IN PTIME_FIELDS TimeFields,
    OUT PLARGE_INTEGER Time
    )

/*++

Routine Description:

    This routine converts an input Time Field variable to a 64-bit NT time
    value.  It ignores the WeekDay of the time field.

Arguments:

    TimeFields - Supplies the time field record to use

    Time - Receives the NT Time corresponding to TimeFields

Return Value:

    BOOLEAN - TRUE if the Time Fields is well formed and within the
        range of time expressible by LARGE_INTEGER and FALSE otherwise.

--*/

{
    ULONG Year;
    ULONG Month;
    ULONG Day;
    ULONG Hour;
    ULONG Minute;
    ULONG Second;
    ULONG Milliseconds;

    ULONG ElapsedDays;
    ULONG ElapsedMilliseconds;

    //
    //  Load the time field elements into local variables.  This should
    //  ensure that the compiler will only load the input elements
    //  once, even if there are alias problems.  It will also make
    //  everything (except the year) zero based.  We cannot zero base the
    //  year because then we can't recognize cases where we're given a year
    //  before 1601.
    //

    Year         = TimeFields->Year;
    Month        = TimeFields->Month - 1;
    Day          = TimeFields->Day - 1;
    Hour         = TimeFields->Hour;
    Minute       = TimeFields->Minute;
    Second       = TimeFields->Second;
    Milliseconds = TimeFields->Milliseconds;

    //
    //  Check that the time field input variable contains
    //  proper values.
    //

    if ((TimeFields->Month < 1)                      ||
        (TimeFields->Day < 1)                        ||
        (Year < 1601)                                ||
        (Month > 11)                                 ||
        ((CSHORT)Day >= MaxDaysInMonth(Year, Month)) ||
        (Hour > 23)                                  ||
        (Minute > 59)                                ||
        (Second > 59)                                ||
        (Milliseconds > 999)) {

        return FALSE;

    }

    //
    //  Compute the total number of elapsed days represented by the
    //  input time field variable
    //

    ElapsedDays = ElapsedYearsToDays( Year - 1601 );

    if (IsLeapYear( Year - 1600 )) {

        ElapsedDays += LeapYearDaysPrecedingMonth[ Month ];

    } else {

        ElapsedDays += NormalYearDaysPrecedingMonth[ Month ];

    }

    ElapsedDays += Day;

    //
    //  Now compute the total number of milliseconds in the fractional
    //  part of the day
    //

    ElapsedMilliseconds = (((Hour*60) + Minute)*60 + Second)*1000 + Milliseconds;

    //
    //  Given the elapsed days and milliseconds we can now build
    //  the output time variable
    //

    DaysAndFractionToTime( ElapsedDays, ElapsedMilliseconds, Time );

    //
    //  And return to our caller
    //

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\rtl\i386\bitmapa.asm ===
title  "Bitmap Functions"
;++
;
; Copyright (c) 1999  Microsoft Corporation
;
; Module Name:
;
;    bitmapa.asm
;
; Abstract:
;
;    This module implements functions to perform bitmap operations.
;
; Author:
;
;    Tracy Sharpe (tracysh) 16-Dec-1999
;
; Environment:
;
;    User or Kernel mode.
;
; Revision History:
;
;--
.486p
	.xlist
include ks386.inc
include callconv.inc            ; calling convention macros
	.list

_TEXT   SEGMENT PARA PUBLIC 'CODE'
	ASSUME  DS:FLAT, ES:FLAT, SS:NOTHING, FS:NOTHING, GS:NOTHING

	PAGE
	SUBTTL "RtlFindFirstSetRightMember"
;++
;
; USHORT
; RtlFindFirstSetRightMember(
;    IN ULONG Set
;    )
;
; /*++
;
; Routine Description:
;
;    Searches the Set for the lest signficant set bit.
;
; Arguments:
;
;    (ecx) Set - 32-bit value to operate on.
;
; Return Value:
;
;    Bit position of the first set right member.
;
;--

cPublicFastCall RtlFindFirstSetRightMember  ,1
cPublicFpo 0, 0

    bsf     eax, ecx
	fstRET  RtlFindFirstSetRightMember

fstENDP RtlFindFirstSetRightMember

_TEXT   ends
	    end
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\rtl\i386\byteswap.asm ===
title  "Byte Swap Functions"
;++
;
; Copyright (c) 1997  Microsoft Corporation
;
; Module Name:
;
;    movemem.asm
;
; Abstract:
;
;    This module implements functions to perform byte swapping operations.
;
;
; Author:
;
;    Forrest Foltz (forrestf) 12-Dec-1997
;
; Environment:
;
;    User or Kernel mode.
;
; Revision History:
;
;--
.486p
	.xlist
include ks386.inc
include callconv.inc            ; calling convention macros
	.list 

;
; Alignment for functions in this module
;

CODE_ALIGNMENT macro
    align   16
endm


_TEXT   SEGMENT PARA PUBLIC 'CODE'
	ASSUME  DS:FLAT, ES:FLAT, SS:NOTHING, FS:NOTHING, GS:NOTHING

	PAGE 
	SUBTTL "RtlUshortByteSwap"
;++
;
; USHORT
; RtlUshortByteSwap(
;    IN USHORT Source
;    )
;
; /*++
; 
; Routine Description:
; 
;    The RtlfUshortByteSwap function exchanges bytes 0 and 1 of Source
;    and returns the resulting USHORT.
; 
; Arguments:
; 
;    (cx) Source - 16-bit value to byteswap.
; 
; Return Value:
; 
;    Swapped 16-bit value.
;
;--

CODE_ALIGNMENT
				
cPublicFastCall RtlUshortByteSwap  ,1
cPublicFpo 0, 0

	mov     ah, cl
	mov     al, ch
	fstRET  RtlUshortByteSwap

fstENDP RtlUshortByteSwap


	PAGE 
	SUBTTL "RtlUlongByteSwap"
;++
;
; ULONG
; RtlUlongByteSwap(
;    IN ULONG Source
;    )
;
; /*++
;
; Routine Description:
;
;    The RtlUlongByteSwap function exchanges byte pairs 0:3 and 1:2 of
;    Source and returns the the resulting ULONG.
;
; Arguments:
;
;    (ecx) Source - 32-bit value to byteswap.
;
; Return Value:
;
;    Swapped 32-bit value.
;
;--

CODE_ALIGNMENT

cPublicFastCall RtlUlongByteSwap  ,1
cPublicFpo 0, 0

	mov     eax, ecx
	bswap   eax
	fstRET  RtlUlongByteSwap

fstENDP RtlUlongByteSwap

_TEXT   ends
	    end
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\rtl\stktrace.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    stktrace.c

Abstract:

    This module implements routines to snapshot a set of stack back traces
    in a data base.  Useful for heap allocators to track allocation requests
    cheaply.

Author:

    Steve Wood (stevewo) 29-Jan-1992

Revision History:

    17-May-1999 (silviuc) : added RtlWalkFrameChain that replaces the
    unsafe RtlCaptureStackBackTrace.

--*/

#include <ntos.h>
#include <ntrtl.h>
#include <nturtl.h>

USHORT
RtlCaptureStackBackTrace(
    IN ULONG FramesToSkip,
    IN ULONG FramesToCapture,
    OUT PVOID *BackTrace,
    OUT PULONG BackTraceHash
    )
/*++

Routine Description:

    This routine walks up the stack frames, capturing the return address from
    each frame requested. This used to be implemented in assembly language and
    used to be unsafe in special contexts (DPC level). Right now it uses
    RtlWalkFrameChain that validates the chain of pointers and it guarantees
    not to take exceptions.

Arguments:

    FramesToSkip - frames detected but not included in the stack trace

    FramesToCapture - frames to be captured in the stack trace buffer. 
        One of the frames will be for RtlCaptureStackBackTrace.

    BackTrace - stack trace buffer

    BackTraceHash - very simple hash value that can be used to organize
      hash tables. It is just an arithmetic sum of the pointers in the
      stack trace buffer.

Return Value:

     Number of return addresses returned in the stack trace buffer.

--*/
{
    PVOID Trace [2 * MAX_STACK_DEPTH];
    ULONG FramesFound;
    ULONG HashValue;
    ULONG Index;

    //
    // One more frame to skip for the "capture" function (WalkFrameChain).
    //

    FramesToSkip++;

    //
    // Sanity checks.
    //

    if (FramesToCapture + FramesToSkip >= 2 * MAX_STACK_DEPTH) {
        return 0;
    }

    FramesFound = RtlWalkFrameChain (
        Trace,
        FramesToCapture + FramesToSkip,
        0);

    if (FramesFound <= FramesToSkip) {
        return 0;
    }

    for (HashValue = 0, Index = 0; Index < FramesToCapture; Index++) {

        if (FramesToSkip + Index >= FramesFound) {
            break;
        }

        BackTrace[Index] = Trace[FramesToSkip + Index];
        HashValue += PtrToUlong(BackTrace[Index]);
    }

    *BackTraceHash = HashValue;
    return (USHORT)Index;
}

/////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////// RtlWalkFrameChain
/////////////////////////////////////////////////////////////////////

//
// This section contains an algorithm for getting stack traces.
// It works only on x86. It is an improvement of
// RtlCaptureStackBackTrace which for reasons that escape me is written
// in assembly and it is unsafe (can raise exceptions). The new function
// RtlWalkFrameChain is guaranteed to not take exceptions whatever the
// call context.
//
// Note. It might be a good idea to not BBT this code. Especially I am concerned
// about the only assembly instruction used in the whole code that saves
// the value of the EBP register.
//

#ifdef NTOS_KERNEL_RUNTIME
#define _KERNEL_MODE_STACK_TRACES_       1
#define _COLLECT_FRAME_WALK_STATISTICS_  0
#else
#define _KERNEL_MODE_STACK_TRACES_       0
#define _COLLECT_FRAME_WALK_STATISTICS_  0
#endif

#define SIZE_1_KB  ((ULONG_PTR) 0x400)
#define SIZE_1_GB  ((ULONG_PTR) 0x40000000)

#define PAGE_START(address) (((ULONG_PTR)address) & ~((ULONG_PTR)PAGE_SIZE - 1))

VOID CollectFrameWalkStatistics (ULONG Index);

#if (( i386 ) && ( FPO ))
#pragma optimize( "y", off )    // disable FPO for consistent stack traces
#endif

ULONG
RtlWalkFrameChain (
    OUT PVOID *Callers,
    IN ULONG Count,
    IN ULONG Flags)

/*++

Routine Description:

    RtlWalkFrameChain

Description:

    This function tries to walk the EBP chain and fill out a vector of
    return addresses. The function works only on x86. It is possible that
    the function cannot fill the requested number of callers because somewhere
    on the stack we have a function compiled FPO (the frame register (EBP) is
    used as a normal register. In this case the function will just return with
    a less then requested count. In kernel mode the function should not take
    any exceptions (page faults) because it can be called at all sorts of
    irql levels.

    The `Flags' parameter is used for future extensions. A zero value will be
    compatible with new stack walking algorithms.

    Note. The algorithm can be somewhat improved by unassembling the return
    addresses identified. However this is impractical in kernel mode because
    the function might get called at high irql levels where page faults are
    not allowed.

Return value:

    The number of identified return addresses on the stack. This can be less
    then the Count requested if the stack ends or we encounter a FPO compiled
    function.

--*/

{
#if defined(_X86_)

    ULONG_PTR Fp, NewFp, ReturnAddress;
    ULONG Index;
    ULONG_PTR StackEnd, StackStart;
    BOOLEAN Result;

    //
    // Get the current EBP pointer which is supposed to
    // be the start of the EBP chain.
    //

    _asm mov Fp, EBP;

    StackStart = Fp;

#if _KERNEL_MODE_STACK_TRACES_

    StackEnd = (ULONG_PTR)(KeGetCurrentThread()->StackBase);

    //
    // bugbug: find a reliable way to get the stack limit in kernel mode.
    // `StackBase' is not a reliable way to get the stack end in kernel
    // mode because we might execute a DPC routine on thread's behalf.
    // There are a few other reasons why we cannot trust this completely.
    //
    // Note. The condition `PAGE_START(StackEnd) - PAGE_START(StackStart) > PAGE_SIZE'
    // is not totally safe. We can encounter a situation where in this case we
    // do not have the same stack. Can we?
    //
    // The DPC stack is actually the stack of the idle thread corresponding to
    // the current processor. Based on that we probably can figure out in almost
    // all contexts what are the real limits of the stack.
    //

    if ((StackStart > StackEnd)
        || (PAGE_START(StackEnd) - PAGE_START(StackStart) > PAGE_SIZE)) {

        StackEnd = (StackStart + PAGE_SIZE) & ~((ULONG_PTR)PAGE_SIZE - 1);
    
        //
        // Try to get one more page if possible. Note that this is not
        // 100% reliable because a non faulting address can fault if
        // appropriate locks are not held.
        //

        if (MmIsAddressValid ((PVOID)StackEnd)) {
            StackEnd += PAGE_SIZE;
        }
    }

#else

    StackEnd = (ULONG_PTR)(NtCurrentTeb()->NtTib.StackBase);

#endif // #if _KERNEL_MODE_STACK_TRACES_

    try {

        for (Index = 0; Index < Count; Index++) {

            if (Fp + sizeof(ULONG_PTR) >= StackEnd) {
                break;
            }

            NewFp = *((PULONG_PTR)(Fp + 0));
            ReturnAddress = *((PULONG_PTR)(Fp + sizeof(ULONG_PTR)));

            //
            // Figure out if the new frame pointer is ok. This validation
            // should avoid all exceptions in kernel mode because we always
            // read within the current thread's stack and the stack is
            // guaranteed to be in memory (no page faults). It is also guaranteed
            // that we do not take random exceptions in user mode because we always
            // keep the frame pointer within stack limits.
            //

            if (! (Fp < NewFp && NewFp < StackEnd)) {
                break;
            }

            //
            // Figure out if the return address is ok. If return address
            // is a stack address or <64k then something is wrong. There is
            // no reason to return garbage to the caller therefore we stop.
            //

            if (StackStart < ReturnAddress && ReturnAddress < StackEnd) {
                break;
            }

            if (ReturnAddress < 64 * SIZE_1_KB) {
                break;
            }

            //
            // Store new fp and return address and move on.
            //

            Fp = NewFp;
            Callers[Index] = (PVOID)ReturnAddress;
        }
    }
    except (EXCEPTION_EXECUTE_HANDLER) {

        //
        // The frame traversal algorithm is written so that we should
        // not get any exception. Therefore if we get some exception
        // we better debug it.
        //

#if DBG
        DbgPrint ("Unexpected exception in RtlWalkFrameChain ...\n");
        DbgBreakPoint ();
#endif
    }

    //
    // Return the number of return addresses identified on the stack.
    //

#if _COLLECT_FRAME_WALK_STATISTICS_
    CollectFrameWalkStatistics (Index);
#endif // #if _COLLECT_FRAME_WALK_STATISTICS_

    return Index;

#else

    return 0;

#endif // #if defined(_X86_)
}


#if _COLLECT_FRAME_WALK_STATISTICS_

KSPIN_LOCK FrameWalkStatisticsLock;
ULONG FrameWalkStatisticsCounters [32];
ULONG FrameWalkCollectStatisticsCalls;
BOOLEAN FrameWalkStatisticsInitialized;

VOID
CollectFrameWalkStatistics (

    ULONG Index)

/*++

Routine description:

    CollectFrameWalkStatistics

Description:

    This function computes the distribution of detectable chain
    lengths. This is used only for debugging the frame traversal
    algorithm. It proves that it is worth trying to get stack
    traces on optimized images because only about 8% of the calls
    cannot be resolved to more than two callers. A sample distribution
    computed by calling RtlWalkFrameChain for every call to
    ExAllocatePoolWithTag gave the results below:

         Length       Percentage
         0-2          5%
         3-5          20%
         6-10         40%
         10-16        35%

    With a failure rate of 5% it is worth using it.

--*/

{
    KIRQL PreviousIrql;
    ULONG I;
    ULONG Percentage;
    ULONG TotalPercentage;

    //
    // Spin lock initialization is not safe in the code below
    // but this code is used only during frame walk algorithm
    // development so there is no reason to make it bulletproof.
    //

    if (! FrameWalkStatisticsInitialized) {
        KeInitializeSpinLock (&FrameWalkStatisticsLock);
        FrameWalkStatisticsInitialized = TRUE;
    }

    KeAcquireSpinLock (
        &FrameWalkStatisticsLock,
        &PreviousIrql);

    FrameWalkCollectStatisticsCalls++;

    if (Index < 32) {
        FrameWalkStatisticsCounters[Index]++;
    }

    if (FrameWalkCollectStatisticsCalls != 0
        && (FrameWalkCollectStatisticsCalls % 60000 == 0)) {

        DbgPrint ("FrameWalk: %u calls \n", FrameWalkCollectStatisticsCalls);

        TotalPercentage = 0;

        for (I = 0; I < 32; I++) {

            Percentage = FrameWalkStatisticsCounters[I] * 100
                / FrameWalkCollectStatisticsCalls;

            DbgPrint ("FrameWalk: [%02u] %02u \n", I, Percentage);

            TotalPercentage += Percentage;
        }

        DbgPrint ("FrameWalk: total %u \n", TotalPercentage);
        DbgBreakPoint ();
    }

    KeReleaseSpinLock (
        &FrameWalkStatisticsLock,
        PreviousIrql);
}

#endif // #if _COLLECT_FRAME_WALK_STATISTICS_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\rtl\string.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    string.c

Abstract:

    This module defines functions for manipulating counted strings (STRING).
    A counted string is a data structure containing three fields.  The Buffer
    field is a pointer to the string itself.  The MaximumLength field contains
    the maximum number of bytes that can be stored in the memory pointed to
    by the Buffer field.  The Length field contains the current length, in
    bytes, of the string pointed to by the Buffer field.  Users of counted
    strings should not make any assumptions about the existence of a null
    byte at the end of the string, unless the null byte is explicitly
    included in the Length of the string.

Author:

    Steve Wood (stevewo) 31-Mar-1989

Revision History:

    22-Sep-1993    JulieB    Fixed TO_UPPER macro for chars above 0x7f.


--*/

#include "ntrtlp.h"

VOID
RtlCopyString(
    OUT PSTRING DestinationString,
    IN PSTRING SourceString OPTIONAL
    )

/*++

Routine Description:

    The RtlCopyString function copies the SourceString to the
    DestinationString.  If SourceString is not specified, then
    the Length field of DestinationString is set to zero.  The
    MaximumLength and Buffer fields of DestinationString are not
    modified by this function.

    The number of bytes copied from the SourceString is either the
    Length of SourceString or the MaximumLength of DestinationString,
    whichever is smaller.

Arguments:

    DestinationString - Pointer to the destination string.

    SourceString - Optional pointer to the source string.

Return Value:

    None.

--*/

{
    PSZ src, dst;
    ULONG n;

    if (ARGUMENT_PRESENT( SourceString )) {
        dst = DestinationString->Buffer;
        src = SourceString->Buffer;
        n = SourceString->Length;
        if ((USHORT)n > DestinationString->MaximumLength) {
            n = DestinationString->MaximumLength;
            }
        DestinationString->Length = (USHORT)n;
        while (n) {
            *dst++ = *src++;
            n--;
            }
        }
    else {
        DestinationString->Length = 0;
        }
}

CHAR
RtlUpperChar (
    register IN CHAR Character
    )

/*++

Routine Description:

    This routine returns a character uppercased
.
Arguments:

    IN CHAR Character - Supplies the character to upper case

Return Value:

    CHAR - Uppercased version of the character
--*/

{
    WCHAR wCh;

    wCh = NLS_UPCASE((WCHAR)((UCHAR)Character));
    return (wCh < 256) ? wCh : '?';
}

CHAR
RtlLowerChar (
    register IN CHAR Character
    )

/*++

Routine Description:

    This routine returns a character lowercased
.
Arguments:

    IN CHAR Character - Supplies the character to lower case

Return Value:

    CHAR - Lowercased version of the character
--*/

{
    WCHAR wCh;

    wCh = NLS_DOWNCASE((WCHAR)((UCHAR)Character));
    return (wCh < 256) ? wCh : '?';
}

LONG
RtlCompareString(
    IN PSTRING String1,
    IN PSTRING String2,
    IN BOOLEAN CaseInSensitive
    )

/*++

Routine Description:

    The RtlCompareString function compares two counted strings.  The return
    value indicates if the strings are equal or String1 is less than String2
    or String1 is greater than String2.

    The CaseInSensitive parameter specifies if case is to be ignored when
    doing the comparison.

Arguments:

    String1 - Pointer to the first string.

    String2 - Pointer to the second string.

    CaseInsensitive - TRUE if case should be ignored when doing the
        comparison.

Return Value:

    Signed value that gives the results of the comparison:

        Zero - String1 equals String2

        < Zero - String1 less than String2

        > Zero - String1 greater than String2


--*/

{

    PUCHAR s1, s2, Limit;
    LONG n1, n2;
    UCHAR c1, c2;

    s1 = String1->Buffer;
    s2 = String2->Buffer;
    n1 = String1->Length;
    n2 = String2->Length;
    Limit = s1 + (n1 <= n2 ? n1 : n2);
    if (CaseInSensitive) {
        while (s1 < Limit) {
            c1 = *s1++;
            c2 = *s2++;
            if (c1 !=c2) {
                c1 = RtlUpperChar(c1);
                c2 = RtlUpperChar(c2);
                if (c1 != c2) {
                    return (LONG)c1 - (LONG)c2;
                }
            }
        }

    } else {
        while (s1 < Limit) {
            c1 = *s1++;
            c2 = *s2++;
            if (c1 != c2) {
                return (LONG)c1 - (LONG)c2;
            }
        }
    }

    return n1 - n2;
}

BOOLEAN
RtlEqualString(
    IN PSTRING String1,
    IN PSTRING String2,
    IN BOOLEAN CaseInSensitive
    )

/*++

Routine Description:

    The RtlEqualString function compares two counted strings for equality.

    The CaseInSensitive parameter specifies if case is to be ignored when
    doing the comparison.

Arguments:

    String1 - Pointer to the first string.

    String2 - Pointer to the second string.

    CaseInsensitive - TRUE if case should be ignored when doing the
        comparison.

Return Value:

    Boolean value that is TRUE if String1 equals String2 and FALSE otherwise.

--*/

{

    PUCHAR s1, s2, Limit;
    LONG n1, n2;
    UCHAR c1, c2;

    n1 = String1->Length;
    n2 = String2->Length;
    if (n1 == n2) {
        s1 = String1->Buffer;
        s2 = String2->Buffer;
        Limit = s1 + n1;
        if (CaseInSensitive) {
            while (s1 < Limit) {
                c1 = *s1++;
                c2 = *s2++;
                if (c1 != c2) {
                    c1 = RtlUpperChar(c1);
                    c2 = RtlUpperChar(c2);
                    if (c1 != c2) {
                        return FALSE;
                    }
                }
            }

            return TRUE;

        } else {
            while (s1 < Limit) {
                c1 = *s1++;
                c2 = *s2++;
                if (c1 != c2) {
                    return FALSE;
                }
            }

            return TRUE;
        }

    } else {
        return FALSE;
    }
}

BOOLEAN
RtlPrefixString(
    IN PSTRING String1,
    IN PSTRING String2,
    IN BOOLEAN CaseInSensitive
    )

/*++

Routine Description:

    The RtlPrefixString function determines if the String1 counted string
    parameter is a prefix of the String2 counted string parameter.

    The CaseInSensitive parameter specifies if case is to be ignored when
    doing the comparison.

Arguments:

    String1 - Pointer to the first string.

    String2 - Pointer to the second string.

    CaseInsensitive - TRUE if case should be ignored when doing the
        comparison.

Return Value:

    Boolean value that is TRUE if String1 equals a prefix of String2 and
    FALSE otherwise.

--*/

{
    PSZ s1, s2;
    USHORT n;
    UCHAR c1, c2;

    s1 = String1->Buffer;
    s2 = String2->Buffer;
    n = String1->Length;
    if (String2->Length < n) {
        return( FALSE );
        }

    if (CaseInSensitive) {
        while (n) {
            c1 = *s1++;
            c2 = *s2++;

            if (c1 != c2 && RtlUpperChar(c1) != RtlUpperChar(c2)) {
                return( FALSE );
                }

            n--;
            }
        }
    else {
        while (n) {
            if (*s1++ != *s2++) {
                return( FALSE );
                }

            n--;
            }
        }

    return TRUE;
}

VOID
RtlUpperString(
    IN PSTRING DestinationString,
    IN PSTRING SourceString
    )

/*++

Routine Description:

    The RtlUpperString function copies the SourceString to the
    DestinationString, converting it to upper case.  The MaximumLength
    and Buffer fields of DestinationString are not modified by this
    function.

    The number of bytes copied from the SourceString is either the
    Length of SourceString or the MaximumLength of DestinationString,
    whichever is smaller.

Arguments:

    DestinationString - Pointer to the destination string.

    SourceString - Pointer to the source string.

Return Value:

    None.

--*/

{
    PSZ src, dst;
    ULONG n;

    dst = DestinationString->Buffer;
    src = SourceString->Buffer;
    n = SourceString->Length;
    if ((USHORT)n > DestinationString->MaximumLength) {
        n = DestinationString->MaximumLength;
        }
    DestinationString->Length = (USHORT)n;
    while (n) {
        *dst++ = RtlUpperChar(*src++);
        n--;
        }
}

NTSTATUS
RtlAppendStringToString (
    IN PSTRING Destination,
    IN PSTRING Source
    )

/*++

Routine Description:

    This routine will concatinate two PSTRINGs together.  It will copy
    bytes from the source up to the MaximumLength of the destination.

Arguments:

    IN PSTRING Destination, - Supplies the destination string
    IN PSTRING Source - Supplies the source for the string copy

Return Value:

    STATUS_SUCCESS - The source string was successfully appended to the
        destination counted string.

    STATUS_BUFFER_TOO_SMALL - The destination string length was not big
        enough to allow the source string to be appended.  The Destination
        string length is not updated.

--*/

{
    USHORT n = Source->Length;

    if (n) {
        if ((n + Destination->Length) > Destination->MaximumLength) {
            return( STATUS_BUFFER_TOO_SMALL );
            }

        RtlMoveMemory( &Destination->Buffer[ Destination->Length ],
                       Source->Buffer,
                       n
                     );
        Destination->Length += n;
        }

    return( STATUS_SUCCESS );
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\rtl\i386\debug2.asm ===
title  "Debug Support Functions"
;++
;
; Copyright (c) 1989  Microsoft Corporation
;
; Module Name:
;
;    debug.s
;
; Abstract:
;
;    This module implements functions to support debugging NT.
;
; Author:
;
;    Steven R. Wood (stevewo) 3-Aug-1989
;
; Environment:
;
;    Any mode.
;
; Revision History:
;
;   11 April 90 (and before)    bryanwi
;       Ported to 386, 386 specific support added.
;
;   2  Aug.  90    (tomp)
;       Added _DbgUnLoadImageSymbols routine.
;
;--
.386p


        .xlist
include ks386.inc
include callconv.inc            ; calling convention macros
        .list

_TEXT	SEGMENT PUBLIC DWORD 'CODE'
ASSUME  DS:FLAT, ES:FLAT, FS:NOTHING, GS:NOTHING, SS:NOTHING

cPublicProc _DbgBreakPoint        ,0
cPublicFpo 0,0
        int 3
        stdRET    _DbgBreakPoint
stdENDP _DbgBreakPoint

cPublicProc _DbgBreakPointWithStatus,1
cPublicFpo 1,0
        mov eax,[esp+4]
        public _RtlpBreakWithStatusInstruction@0
_RtlpBreakWithStatusInstruction@0:
        int 3
        stdRET  _DbgBreakPointWithStatus
stdENDP _DbgBreakPointWithStatus

_TEXT   ends
        end
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\rtl\i386\critsect.asm ===
title   "Critical Section Support"
;++
;
;  Copyright (c) 1991  Microsoft Corporation
;
;  Module Name:
;
;     critsect.asm
;
;  Abstract:
;
;     This module implements functions to support user mode critical sections.
;
;  Author:
;
;     Bryan M. Willman (bryanwi) 2-Oct-91
;
;  Environment:
;
;     Any mode.
;
;  Revision History:
;
;--

.486p
        .xlist
KERNELONLY  equ     1

include ks386.inc
include callconv.inc                    ; calling convention macros
        .list

_TEXT   SEGMENT PARA PUBLIC 'CODE'
        ASSUME  DS:FLAT, ES:FLAT, SS:NOTHING, FS:NOTHING, GS:NOTHING

        extrn   _KiPCR:DWORD
        EXTRNP  _KeWaitForSingleObject,5
        EXTRNP  _KeSetEvent,3
        EXTRNP  HalRequestSoftwareInterrupt,1,,FASTCALL

CriticalSection equ     [esp + 4]

        page , 132
        subttl  "RtlEnterCriticalSectionAndRegion"

;++
;
; VOID
; RtlEnterCriticalSectionAndRegion(
;    IN PRTL_CRITICAL_SECTION CriticalSection
;    )
;
; Routine Description:
;
;    This function enters a critical section and disables kernel APC's.
;
; Arguments:
;
;    CriticalSection - supplies a pointer to a critical section.
;
; Return Value:
;
;    None.
;
;--

        align   16
cPublicProc _RtlEnterCriticalSectionAndRegion,1
cPublicFpo 1,0

        mov     ecx, PCR[PcPrcbData+PbCurrentThread]
        mov     edx, CriticalSection    ; get address of critical section

;
; Disable kernel APC's.
;

        dec     dword ptr ThKernelApcDisable[ecx]

;
; Attempt to acquire critical section.
;

        inc     dword ptr CsLockCount[edx] ; increment lock count
        jnz     short Ent20             ; if nz, already owned

;
; Set critical section owner and initialize recursion count.
;

        mov     CsOwningThread[edx], ecx ; set critical section owner
        mov     dword ptr CsRecursionCount[edx], 1 ; set recursion count

        stdRET  _RtlEnterCriticalSectionAndRegion

;
; For out of straight-line paths, we fall into RtlEnterCriticalSection
;

stdENDP _RtlEnterCriticalSectionAndRegion


        page , 132
        subttl  "RtlEnterCriticalSection"

;++
;
; VOID
; RtlEnterCriticalSection(
;    IN PRTL_CRITICAL_SECTION CriticalSection
;    )
;
; Routine Description:
;
;    This function enters a critical section.
;
; Arguments:
;
;    CriticalSection - supplies a pointer to a critical section.
;
; Return Value:
;
;    None.
;
;--

        align   16
cPublicProc _RtlEnterCriticalSection,1
cPublicFpo 1,0

        mov     ecx, PCR[PcPrcbData+PbCurrentThread]
        mov     edx, CriticalSection    ; get address of critical section

;
; Attempt to acquire critical section.
;

        inc     dword ptr CsLockCount[edx] ; increment lock count
        jnz     short Ent20             ; if nz, already owned

;
; Set critical section owner and initialize recursion count.
;

Ent10:
        mov     CsOwningThread[edx], ecx ; set critical section owner
        mov     dword ptr CsRecursionCount[edx], 1 ; set recursion count

        stdRET  _RtlEnterCriticalSection

;
; The critical section is already owned, but may be owned by the current thread.
;

        align   16
Ent20:  cmp     CsOwningThread[edx],ecx ; check if current thread is owner
        jne     short Ent30             ; if ne, current thread not owner
        inc     dword ptr CsRecursionCount[edx] ; increment recursion count

        stdRET  _RtlEnterCriticalSection

;
; The critcal section is owned by another thread and the current thread must
; wait for ownership.
;

Ent30:  stdCall _KeWaitForSingleObject,<edx,WrExecutive,0,0,0>
        mov     ecx, PCR[PcPrcbData+PbCurrentThread]
        mov     edx,CriticalSection     ; get address of critical section
        jmp     Ent10                   ; set owner and recursion count

stdENDP _RtlEnterCriticalSection


        page , 132
        subttl  "RtlLeaveCriticalSectionAndRegion"
;++
;
; VOID
; RtlLeaveCriticalSectionAndAndRegion(
;    IN PRTL_CRITICAL_SECTION CriticalSection
;    )
;
; Routine Description:
;
;    This function leaves a critical section and enables kernel APC's.
;
; Arguments:
;
;    CriticalSection - supplies a pointer to a critical section.
;
; Return Value:
;
;    None.
;
;--

        align   16
cPublicProc _RtlLeaveCriticalSectionAndRegion,1
cPublicFpo 1,0

        mov     edx,CriticalSection
        xor     eax,eax                     ; Assume STATUS_SUCCESS
        dec     dword ptr CsRecursionCount[edx]
        jnz     Lveea20                     ; skip if only leaving recursion

        mov     CsOwningThread[edx],eax     ; clear owning thread id

        dec     dword ptr CsLockCount[edx]  ; interlocked dec of
                                            ; ... CriticalSection->LockCount
        jl      Lveea10
        stdCall _KeSetEvent,<edx,EVENT_INCREMENT,0>

;
; Enable kernel APC's and check if we need to raise an APC interrupt.
;

Lveea10:
        mov     ecx, PCR[PcPrcbData+PbCurrentThread]
        mov     eax, dword ptr [ecx+ThKernelApcDisable]
                                            ; Grab the current APC disable count
        inc     eax
        test    eax, eax                    ; Kernel APC disable count == 0?
        mov     dword ptr [ecx+ThKernelApcDisable], eax
                                            ; Write the count back to the thread
        jnz     Lveea15
        lea     eax, [ecx+ThApcState+AsApcListHead]
        cmp     dword ptr [ecx+ThApcState+AsApcListHead], eax
                                            ; Check if APC list is empty
        je      Lveea15

        mov     byte ptr [ecx+ThApcState+AsKernelApcPending], 1
        mov     cl, APC_LEVEL               ; Service the pending kernel APC
        fstCall HalRequestSoftwareInterrupt

Lveea15:
        stdRET  _RtlLeaveCriticalSectionAndRegion

        align   16
Lveea20:
        dec     dword ptr CsLockCount[edx]  ; interlocked dec of
                                            ; ... CriticalSection->LockCount
        stdRET  _RtlLeaveCriticalSectionAndRegion

_RtlLeaveCriticalSectionAndRegion    endp


        page , 132
        subttl  "RtlLeaveCriticalSection"
;++
;
; VOID
; RtlLeaveCriticalSection(
;    IN PRTL_CRITICAL_SECTION CriticalSection
;    )
;
; Routine Description:
;
;    This function leaves a critical section.
;
; Arguments:
;
;    CriticalSection - supplies a pointer to a critical section.
;
; Return Value:
;
;    None.
;
;--

        align   16
cPublicProc _RtlLeaveCriticalSection,1
cPublicFpo 1,0

        mov     edx,CriticalSection
        xor     eax,eax                     ; Assume STATUS_SUCCESS
        dec     dword ptr CsRecursionCount[edx]
        jnz     leave_recurs                ; skip if only leaving recursion

        mov     CsOwningThread[edx],eax     ; clear owning thread id

        dec     dword ptr CsLockCount[edx]  ; interlocked dec of
                                            ; ... CriticalSection->LockCount
        jge     @F
        stdRET  _RtlLeaveCriticalSection
@@:
        stdCall _KeSetEvent,<edx,EVENT_INCREMENT,0>
        stdRET  _RtlLeaveCriticalSection

        align   16
leave_recurs:
        dec     dword ptr CsLockCount[edx]  ; interlocked dec of
                                            ; ... CriticalSection->LockCount
        stdRET  _RtlLeaveCriticalSection

_RtlLeaveCriticalSection    endp


        page    ,132
        subttl  "RtlTryEnterCriticalSection"
;++
;
; ULONG
; RtlTryEnterCriticalSection(
;    IN PRTL_CRITICAL_SECTION CriticalSection
;    )
;
; Routine Description:
;
;    This function attempts to enter a critical section without blocking.
;
; Arguments:
;
;    CriticalSection (a0) - Supplies a pointer to a critical section.
;
; Return Value:
;
;    If the critical section was successfully entered, then a value of TRUE
;    is returned as the function value. Otherwise, a value of FALSE is returned.
;
;--

CriticalSection equ     [esp + 4]

cPublicProc _RtlTryEnterCriticalSection,1
cPublicFpo 1,0

        mov     ecx, CriticalSection        ; interlocked inc of
        mov     eax, -1                     ; set value to compare against
        mov     edx, 0                      ; set value to set
        cmpxchg dword ptr CsLockCount[ecx], edx  ; Attempt to acquire critsect
        jnz     short tec10                 ; if nz, critsect already owned

        mov     eax, PCR[PcPrcbData+PbCurrentThread]
        mov     CsOwningThread[ecx], eax
        mov     dword ptr CsRecursionCount[ecx], 1

        mov     eax, 1                      ; set successful status

        stdRET  _RtlTryEnterCriticalSection

tec10:
;
; The critical section is already owned. If it is owned by another thread,
; return FALSE immediately. If it is owned by this thread, we must increment
; the lock count here.
;
        mov     eax, PCR[PcPrcbData+PbCurrentThread]
        cmp     CsOwningThread[ecx], eax
        jz      tec20                       ; if eq, this thread is already the owner
        xor     eax, eax                    ; set failure status
        stdRET  _RtlTryEnterCriticalSection

tec20:
;
; This thread is already the owner of the critical section. Perform an atomic
; increment of the LockCount and a normal increment of the RecursionCount and
; return success.
;
        inc     dword ptr CsLockCount[ecx]
        inc     dword ptr CsRecursionCount[ecx]
        mov     eax, 1
        stdRET  _RtlTryEnterCriticalSection

stdENDP _RtlTryEnterCriticalSection

_TEXT   ends
        end
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\rtl\i386\context.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    context.c

Abstract:

    This module implements user-mode callable context manipulation routines.
    The interfaces exported from this module are portable, but they must
    be re-implemented for each architecture.

Author:

    Mark Lucovsky (markl) 20-Jun-1989

Revision History:

    Bryan Willman (bryanwi) 8-Mar-90

	Ported to the 80386

--*/

#include "ntrtlp.h"

#if defined(ALLOC_PRAGMA) && defined(NTOS_KERNEL_RUNTIME)
#pragma alloc_text(PAGE,RtlInitializeContext)
#pragma alloc_text(PAGE,RtlRemoteCall)
#endif


VOID
RtlInitializeContext(
    IN HANDLE Process,
    OUT PCONTEXT Context,
    IN PVOID Parameter OPTIONAL,
    IN PVOID InitialPc OPTIONAL,
    IN PVOID InitialSp OPTIONAL
    )

/*++

Routine Description:

    This function initializes a context structure so that it can
    be used in a subsequent call to NtCreateThread.

Arguments:

    Context - Supplies a context buffer to be initialized by this routine.

    InitialPc - Supplies an initial program counter value.

    InitialSp - Supplies an initial stack pointer value.

Return Value:

    Raises STATUS_BAD_INITIAL_STACK if the value of InitialSp is not properly
           aligned.

    Raises STATUS_BAD_INITIAL_PC if the value of InitialPc is not properly
           aligned.

--*/

{
    RTL_PAGED_CODE();

    Context->Eax = 0L;
    Context->Ebx = 1L;
    Context->Ecx = 2L;
    Context->Edx = 3L;
    Context->Esi = 4L;
    Context->Edi = 5L;
    Context->Ebp = 0L;

    Context->SegGs = 0;
    Context->SegFs = KGDT_R3_TEB;
    Context->SegEs = KGDT_R3_DATA;
    Context->SegDs = KGDT_R3_DATA;
    Context->SegSs = KGDT_R3_DATA;
    Context->SegCs = KGDT_R3_CODE;

    Context->EFlags = 0x200L;	    // force interrupts on, clear all else.

    //
    // Even though these are optional, they are used as is, since NULL
    // is what these would have been initialized to anyway
    //

    Context->Esp = (ULONG) InitialSp;
    Context->Eip = (ULONG) InitialPc;

    //
    // add code to check alignment and raise exception...
    //

    Context->ContextFlags = CONTEXT_CONTROL|CONTEXT_INTEGER|CONTEXT_SEGMENTS;

    //
    // Set the initial context of the thread in a machine specific way.
    // ie, pass the initial parameter to the start address
    //

    Context->Esp -= sizeof(Parameter);
    ZwWriteVirtualMemory(Process,
			 (PVOID)Context->Esp,
			 (PVOID)&Parameter,
			 sizeof(Parameter),
			 NULL);
    Context->Esp -= sizeof(Parameter); // Reserve room for ret address


}



NTSTATUS
RtlRemoteCall(
    HANDLE Process,
    HANDLE Thread,
    PVOID CallSite,
    ULONG ArgumentCount,
    PULONG Arguments,
    BOOLEAN PassContext,
    BOOLEAN AlreadySuspended
    )

/*++

Routine Description:

    This function calls a procedure in another thread/process, using
    NtGetContext and NtSetContext.  Parameters are passed to the
    target procedure via its stack.

Arguments:

    Process - Handle of the target process

    Thread - Handle of the target thread within that process

    CallSite - Address of the procedure to call in the target process.

    ArgumentCount - Number of 32 bit parameters to pass to the target
                    procedure.

    Arguments - Pointer to the array of 32 bit parameters to pass.

    PassContext - TRUE if an additional parameter is to be passed that
        points to a context record.

    AlreadySuspended - TRUE if the target thread is already in a suspended
                       or waiting state.

Return Value:

    Status - Status value

--*/

{
    NTSTATUS Status;
    CONTEXT Context;
    ULONG NewSp;
    ULONG ArgumentsCopy[5];

    RTL_PAGED_CODE();

    if (ArgumentCount > 4)
        return STATUS_INVALID_PARAMETER;

    //
    // If necessary, suspend the guy before with we mess with his stack.
    //
    if (!AlreadySuspended) {
        Status = NtSuspendThread( Thread, NULL );
        if (!NT_SUCCESS( Status )) {
            return( Status );
            }
        }


    //
    // Get the context record for the target thread.
    //

    Context.ContextFlags = CONTEXT_FULL;
    Status = NtGetContextThread( Thread, &Context );
    if (!NT_SUCCESS( Status )) {
        if (!AlreadySuspended) {
            NtResumeThread( Thread, NULL );
            }
        return( Status );
        }


    //
    //	Pass all parameters on the stack, regardless of whether a
    //	a context record is passed.
    //

    //
    //	Put Context Record on stack first, so it is above other args.
    //
    NewSp = Context.Esp;
    if (PassContext) {
	NewSp -= sizeof( CONTEXT );
	Status = NtWriteVirtualMemory( Process,
				       (PVOID)NewSp,
				       &Context,
				       sizeof( CONTEXT ),
				       NULL
				    );
	if (!NT_SUCCESS( Status )) {
            if (!AlreadySuspended) {
                NtResumeThread( Thread, NULL );
                }
	    return( Status );
	    }
        ArgumentsCopy[0] = NewSp;   // pass pointer to context
        RtlMoveMemory(&(ArgumentsCopy[1]),Arguments,ArgumentCount*sizeof( ULONG ));
        ArgumentCount++;
	}
    else {
        RtlMoveMemory(ArgumentsCopy,Arguments,ArgumentCount*sizeof( ULONG ));
        }

    //
    //	Copy the arguments onto the target stack
    //
    if (ArgumentCount) {
        NewSp -= ArgumentCount * sizeof( ULONG );
        Status = NtWriteVirtualMemory( Process,
                                       (PVOID)NewSp,
                                       ArgumentsCopy,
                                       ArgumentCount * sizeof( ULONG ),
                                       NULL
                                     );
        if (!NT_SUCCESS( Status )) {
            if (!AlreadySuspended) {
                NtResumeThread( Thread, NULL );
                }
            return( Status );
            }
        }

    //
    // Set the address of the target code into Eip, the new target stack
    // into Esp, and reload context to make it happen.
    //
    Context.Esp = NewSp;
    Context.Eip = (ULONG)CallSite;
    Status = NtSetContextThread( Thread, &Context );
    if (!AlreadySuspended) {
        NtResumeThread( Thread, NULL );
        }

    return( Status );
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\rtl\i386\exdsptch.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    exdsptch.c

Abstract:

    This module implements the dispatching of exception and the unwinding of
    procedure call frames.

Author:

    David N. Cutler (davec) 13-Aug-1989

Environment:

    Any mode.

Revision History:

    10 april 90 bryanwi

            Port to the 386.

--*/

#include "ntrtlp.h"


//
// Dispatcher context structure definition.
//

typedef struct _DISPATCHER_CONTEXT {
    PEXCEPTION_REGISTRATION_RECORD RegistrationPointer;
    } DISPATCHER_CONTEXT;

//
// Execute handler for exception function prototype.
//

EXCEPTION_DISPOSITION
RtlpExecuteHandlerForException (
    IN PEXCEPTION_RECORD ExceptionRecord,
    IN PVOID EstablisherFrame,
    IN OUT PCONTEXT ContextRecord,
    IN OUT PVOID DispatcherContext,
    IN PEXCEPTION_ROUTINE ExceptionRoutine
    );

//
// Execute handler for unwind function prototype.
//

EXCEPTION_DISPOSITION
RtlpExecuteHandlerForUnwind (
    IN PEXCEPTION_RECORD ExceptionRecord,
    IN PVOID EstablisherFrame,
    IN OUT PCONTEXT ContextRecord,
    IN OUT PVOID DispatcherContext,
    IN PEXCEPTION_ROUTINE ExceptionRoutine
    );



BOOLEAN
RtlDispatchException (
    IN PEXCEPTION_RECORD ExceptionRecord,
    IN PCONTEXT ContextRecord
    )

/*++

Routine Description:

    This function attempts to dispatch an exception to a call frame based
    handler by searching backwards through the stack based call frames. The
    search begins with the frame specified in the context record and continues
    backward until either a handler is found that handles the exception, the
    stack is found to be invalid (i.e., out of limits or unaligned), or the end
    of the call hierarchy is reached.

Arguments:

    ExceptionRecord - Supplies a pointer to an exception record.

    ContextRecord - Supplies a pointer to a context record.

Return Value:

    If the exception is handled by one of the frame based handlers, then
    a value of TRUE is returned. Otherwise a value of FALSE is returned.

--*/

{

    DISPATCHER_CONTEXT DispatcherContext;
    EXCEPTION_DISPOSITION Disposition;
    PEXCEPTION_REGISTRATION_RECORD RegistrationPointer;
    PEXCEPTION_REGISTRATION_RECORD NestedRegistration;
    ULONG HighAddress;
    ULONG HighLimit;
    ULONG LowLimit;
    EXCEPTION_RECORD ExceptionRecord1;

#if !defined(WX86_i386)

    ULONG Index;

#endif

    //
    // Get current stack limits.
    //

    RtlpGetStackLimits(&LowLimit, &HighLimit);

    //
    // Start with the frame specified by the context record and search
    // backwards through the call frame hierarchy attempting to find an
    // exception handler that will handler the exception.
    //

    RegistrationPointer = RtlpGetRegistrationHead();
    NestedRegistration = 0;

    while (RegistrationPointer != EXCEPTION_CHAIN_END) {

        //
        // If the call frame is not within the specified stack limits or the
        // call frame is unaligned, then set the stack invalid flag in the
        // exception record and return FALSE. Else check to determine if the
        // frame has an exception handler.
        //

        HighAddress = (ULONG)RegistrationPointer +
            sizeof(EXCEPTION_REGISTRATION_RECORD);

        if ( ((ULONG)RegistrationPointer < LowLimit) ||
             (HighAddress > HighLimit) ||
             (((ULONG)RegistrationPointer & 0x3) != 0) ) {

#if defined(NTOS_KERNEL_RUNTIME)

            //
            // Allow for the possibility that the problem occured on the
            // DPC stack.
            //

            ULONG TestAddress = (ULONG)RegistrationPointer;

            if (((TestAddress & 0x3) == 0) &&
                KeGetCurrentIrql() >= DISPATCH_LEVEL) {

                PKPRCB Prcb = KeGetCurrentPrcb();
                ULONG DpcStack = (ULONG)Prcb->DpcStack;

                if ((Prcb->DpcRoutineActive) &&
                    (HighAddress <= DpcStack) &&
                    (TestAddress >= DpcStack - KERNEL_STACK_SIZE)) {

                    //
                    // This error occured on the DPC stack, switch
                    // stack limits to the DPC stack and restart 
                    // the loop.
                    // 

                    HighLimit = DpcStack;
                    LowLimit = DpcStack - KERNEL_STACK_SIZE;
                    continue;
                }
            }

#endif

            ExceptionRecord->ExceptionFlags |= EXCEPTION_STACK_INVALID;
            return FALSE;
        }

        Disposition = RtlpExecuteHandlerForException(
            ExceptionRecord,
            (PVOID)RegistrationPointer,
            ContextRecord,
            (PVOID)&DispatcherContext,
            (PEXCEPTION_ROUTINE)RegistrationPointer->Handler);

        //
        // If the current scan is within a nested context and the frame
        // just examined is the end of the context region, then clear
        // the nested context frame and the nested exception in the
        // exception flags.
        //

        if (NestedRegistration == RegistrationPointer) {
            ExceptionRecord->ExceptionFlags &= (~EXCEPTION_NESTED_CALL);
            NestedRegistration = 0;
        }

        //
        // Case on the handler disposition.
        //

        switch (Disposition) {

            //
            // The disposition is to continue execution. If the
            // exception is not continuable, then raise the exception
            // STATUS_NONCONTINUABLE_EXCEPTION. Otherwise return
            // TRUE.
            //

        case ExceptionContinueExecution :
            if ((ExceptionRecord->ExceptionFlags &
               EXCEPTION_NONCONTINUABLE) != 0) {
                ExceptionRecord1.ExceptionCode =
                                        STATUS_NONCONTINUABLE_EXCEPTION;
                ExceptionRecord1.ExceptionFlags = EXCEPTION_NONCONTINUABLE;
                ExceptionRecord1.ExceptionRecord = ExceptionRecord;
                ExceptionRecord1.NumberParameters = 0;
                RtlRaiseException(&ExceptionRecord1);
            } else {
                return TRUE;
            }

            //
            // The disposition is to continue the search. Get next
            // frame address and continue the search.
            //

        case ExceptionContinueSearch :
            break;

            //
            // The disposition is nested exception. Set the nested
            // context frame to the establisher frame address and set
            // nested exception in the exception flags.
            //

        case ExceptionNestedException :
            ExceptionRecord->ExceptionFlags |= EXCEPTION_NESTED_CALL;
            if (DispatcherContext.RegistrationPointer > NestedRegistration) {
                NestedRegistration = DispatcherContext.RegistrationPointer;
            }
            break;

            //
            // All other disposition values are invalid. Raise
            // invalid disposition exception.
            //

        default :
            ExceptionRecord1.ExceptionCode = STATUS_INVALID_DISPOSITION;
            ExceptionRecord1.ExceptionFlags = EXCEPTION_NONCONTINUABLE;
            ExceptionRecord1.ExceptionRecord = ExceptionRecord;
            ExceptionRecord1.NumberParameters = 0;
            RtlRaiseException(&ExceptionRecord1);
            break;
        }

        //
        // If chain goes in wrong direction or loops, report an
        // invalid exception stack, otherwise go on to the next one.
        //

        RegistrationPointer = RegistrationPointer->Next;
    }
    return FALSE;
}

#ifdef _X86_
#pragma optimize("y", off)      // RtlCaptureContext needs EBP to be correct
#endif

VOID
RtlUnwind (
    IN PVOID TargetFrame OPTIONAL,
    IN PVOID TargetIp OPTIONAL,
    IN PEXCEPTION_RECORD ExceptionRecord OPTIONAL,
    IN PVOID ReturnValue
    )

/*++

Routine Description:

    This function initiates an unwind of procedure call frames. The machine
    state at the time of the call to unwind is captured in a context record
    and the unwinding flag is set in the exception flags of the exception
    record. If the TargetFrame parameter is not specified, then the exit unwind
    flag is also set in the exception flags of the exception record. A backward
    walk through the procedure call frames is then performed to find the target
    of the unwind operation.

    N.B.    The captured context passed to unwinding handlers will not be
            a  completely accurate context set for the 386.  This is because
            there isn't a standard stack frame in which registers are stored.

            Only the integer registers are affected.  The segement and
            control registers (ebp, esp) will have correct values for
            the flat 32 bit environment.

    N.B.    If you change the number of arguments, make sure you change the
            adjustment of ESP after the call to RtlpCaptureContext (for
            STDCALL calling convention)

Arguments:

    TargetFrame - Supplies an optional pointer to the call frame that is the
        target of the unwind. If this parameter is not specified, then an exit
        unwind is performed.

    TargetIp - Supplies an optional instruction address that specifies the
        continuation address of the unwind. This address is ignored if the
        target frame parameter is not specified.

    ExceptionRecord - Supplies an optional pointer to an exception record.

    ReturnValue - Supplies a value that is to be placed in the integer
        function return register just before continuing execution.

Return Value:

    None.

--*/

{
    PCONTEXT ContextRecord;
    CONTEXT ContextRecord1;
    DISPATCHER_CONTEXT DispatcherContext;
    EXCEPTION_DISPOSITION Disposition;
    PEXCEPTION_REGISTRATION_RECORD RegistrationPointer;
    PEXCEPTION_REGISTRATION_RECORD PriorPointer;
    ULONG HighAddress;
    ULONG HighLimit;
    ULONG LowLimit;
    EXCEPTION_RECORD ExceptionRecord1;
    EXCEPTION_RECORD ExceptionRecord2;

    //
    // Get current stack limits.
    //

    RtlpGetStackLimits(&LowLimit, &HighLimit);

    //
    // If an exception record is not specified, then build a local exception
    // record for use in calling exception handlers during the unwind operation.
    //

    if (ARGUMENT_PRESENT(ExceptionRecord) == FALSE) {
        ExceptionRecord = &ExceptionRecord1;
        ExceptionRecord1.ExceptionCode = STATUS_UNWIND;
        ExceptionRecord1.ExceptionFlags = 0;
        ExceptionRecord1.ExceptionRecord = NULL;
        ExceptionRecord1.ExceptionAddress = RtlpGetReturnAddress();
        ExceptionRecord1.NumberParameters = 0;
    }

    //
    // If the target frame of the unwind is specified, then set EXCEPTION_UNWINDING
    // flag in the exception flags. Otherwise set both EXCEPTION_EXIT_UNWIND and
    // EXCEPTION_UNWINDING flags in the exception flags.
    //

    if (ARGUMENT_PRESENT(TargetFrame) == TRUE) {
        ExceptionRecord->ExceptionFlags |= EXCEPTION_UNWINDING;
    } else {
        ExceptionRecord->ExceptionFlags |= (EXCEPTION_UNWINDING |
                                                        EXCEPTION_EXIT_UNWIND);
    }

    //
    // Capture the context.
    //

    ContextRecord = &ContextRecord1;
    ContextRecord1.ContextFlags = CONTEXT_INTEGER | CONTEXT_CONTROL | CONTEXT_SEGMENTS;
    RtlpCaptureContext(ContextRecord);

#ifdef STD_CALL
    //
    // Adjust captured context to pop our arguments off the stack
    //
    ContextRecord->Esp += sizeof(TargetFrame) +
                          sizeof(TargetIp)    +
                          sizeof(ExceptionRecord) +
                          sizeof(ReturnValue);
#endif
    ContextRecord->Eax = (ULONG)ReturnValue;

    //
    // Scan backward through the call frame hierarchy, calling exception
    // handlers as they are encountered, until the target frame of the unwind
    // is reached.
    //

    RegistrationPointer = RtlpGetRegistrationHead();
    while (RegistrationPointer != EXCEPTION_CHAIN_END) {

        //
        // If this is the target of the unwind, then continue execution
        // by calling the continue system service.
        //

        if ((ULONG)RegistrationPointer == (ULONG)TargetFrame) {
            ZwContinue(ContextRecord, FALSE);

        //
        // If the target frame is lower in the stack than the current frame,
        // then raise STATUS_INVALID_UNWIND exception.
        //

        } else if ( (ARGUMENT_PRESENT(TargetFrame) == TRUE) &&
                    ((ULONG)TargetFrame < (ULONG)RegistrationPointer) ) {
            ExceptionRecord2.ExceptionCode = STATUS_INVALID_UNWIND_TARGET;
            ExceptionRecord2.ExceptionFlags = EXCEPTION_NONCONTINUABLE;
            ExceptionRecord2.ExceptionRecord = ExceptionRecord;
            ExceptionRecord2.NumberParameters = 0;
            RtlRaiseException(&ExceptionRecord2);
        }

        //
        // If the call frame is not within the specified stack limits or the
        // call frame is unaligned, then raise the exception STATUS_BAD_STACK.
        // Else restore the state from the specified frame to the context
        // record.
        //

        HighAddress = (ULONG)RegistrationPointer +
            sizeof(EXCEPTION_REGISTRATION_RECORD);

        if ( ((ULONG)RegistrationPointer < LowLimit) ||
             (HighAddress > HighLimit) ||
             (((ULONG)RegistrationPointer & 0x3) != 0) ) {

#if defined(NTOS_KERNEL_RUNTIME)

            //
            // Allow for the possibility that the problem occured on the
            // DPC stack.
            //

            ULONG TestAddress = (ULONG)RegistrationPointer;

            if (((TestAddress & 0x3) == 0) &&
                KeGetCurrentIrql() >= DISPATCH_LEVEL) {

                PKPRCB Prcb = KeGetCurrentPrcb();
                ULONG DpcStack = (ULONG)Prcb->DpcStack;

                if ((Prcb->DpcRoutineActive) &&
                    (HighAddress <= DpcStack) &&
                    (TestAddress >= DpcStack - KERNEL_STACK_SIZE)) {

                    //
                    // This error occured on the DPC stack, switch
                    // stack limits to the DPC stack and restart 
                    // the loop.
                    // 

                    HighLimit = DpcStack;
                    LowLimit = DpcStack - KERNEL_STACK_SIZE;
                    continue;
                }
            }

#endif

            ExceptionRecord2.ExceptionCode = STATUS_BAD_STACK;
            ExceptionRecord2.ExceptionFlags = EXCEPTION_NONCONTINUABLE;
            ExceptionRecord2.ExceptionRecord = ExceptionRecord;
            ExceptionRecord2.NumberParameters = 0;
            RtlRaiseException(&ExceptionRecord2);
        } else {

            //
            // The handler must be executed by calling another routine
            // that is written in assembler. This is required because
            // up level addressing of the handler information is required
            // when a collided unwind is encountered.
            //

            Disposition = RtlpExecuteHandlerForUnwind(
                ExceptionRecord,
                (PVOID)RegistrationPointer,
                ContextRecord,
                (PVOID)&DispatcherContext,
                RegistrationPointer->Handler);

            //
            // Case on the handler disposition.
            //

            switch (Disposition) {

                //
                // The disposition is to continue the search. Get next
                // frame address and continue the search.
                //

            case ExceptionContinueSearch :
                break;

                //
                // The disposition is colided unwind. Maximize the target
                // of the unwind and change the context record pointer.
                //

            case ExceptionCollidedUnwind :

                //
                // Pick up the registration pointer that was active at
                // the time of the unwind, and simply continue.
                //

                RegistrationPointer = DispatcherContext.RegistrationPointer;
                break;


                //
                // All other disposition values are invalid. Raise
                // invalid disposition exception.
                //

            default :
                ExceptionRecord2.ExceptionCode = STATUS_INVALID_DISPOSITION;
                ExceptionRecord2.ExceptionFlags = EXCEPTION_NONCONTINUABLE;
                ExceptionRecord2.ExceptionRecord = ExceptionRecord;
                ExceptionRecord2.NumberParameters = 0;
                RtlRaiseException(&ExceptionRecord2);
                break;
            }

            //
            // Step to next registration record
            //

            PriorPointer = RegistrationPointer;
            RegistrationPointer = RegistrationPointer->Next;

            //
            // Unlink the unwind handler, since it's been called.
            //

            RtlpUnlinkHandler(PriorPointer);

            //
            // If chain goes in wrong direction or loops, raise an
            // exception.
            //

        }
    }

    if (TargetFrame == EXCEPTION_CHAIN_END) {

        //
        //  Caller simply wants to unwind all exception records.
        //  This differs from an exit_unwind in that no "exit" is desired.
        //  Do a normal continue, since we've effectively found the
        //  "target" the caller wanted.
        //

        ZwContinue(ContextRecord, FALSE);

    } else {

        //
        //  Either (1) a real exit unwind was performed, or (2) the
        //  specified TargetFrame is not present in the exception handler
        //  list.  In either case, give debugger and subsystem a chance
        //  to see the unwind.
        //

        ZwRaiseException(ExceptionRecord, ContextRecord, FALSE);

    }
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\rtl\i386\largeint.asm ===
TITLE   "Large Integer Arithmetic"
;++
;
; Copyright (c) 1989  Microsoft Corporation
;
; Module Name:
;
;    largeint.s
;
; Abstract:
;
;    This module implements routines for performing extended integer
;    arithmtic.
;
; Author:
;
;    David N. Cutler (davec) 24-Aug-1989
;
; Environment:
;
;    Any mode.
;
; Revision History:
;
;--

.386p
        .xlist
include ks386.inc
include callconv.inc            ; calling convention macros
        .list

IFNDEF BLDR_KERNEL_RUNTIME
        EXTRNP  _RtlRaiseStatus, 1
ENDIF


_TEXT   SEGMENT DWORD PUBLIC 'CODE'
        ASSUME  DS:FLAT, ES:FLAT, SS:NOTHING, FS:NOTHING, GS:NOTHING

        page
        subttl  "Extended Large Integer Divide"

;++
;
; LARGE_INTEGER
; RtlExtendedLargeIntegerDivide (
;     IN LARGE_INTEGER Dividend,
;     IN ULONG Divisor,
;     OUT PULONG Remainder OPTIONAL
;     )
;
; Routine Description:
;
;     This routine divides an unsigned 64 bit dividend by a 32 bit divisor
;     and returns a 64-bit quotient, and optionally the 32-bit remainder.
;
;
; Arguments:
;
;     Dividend - Supplies the 64 bit dividend for the divide operation.
;
;     Divisor - Supplies the 32 bit divisor for the divide operation.
;
;     Remainder - Supplies an optional pointer to a variable which receives
;         the remainder
;
; Return Value:
;
;     The 64-bit quotient is returned as the function value.
;
;--

cPublicProc _RtlExtendedLargeIntegerDivide, 4
cPublicFpo 4,3

        push    esi
        push    edi
        push    ebx

        mov     eax, [esp+16]       ; (eax) = Dividend.LowPart
        mov     edx, [esp+20]       ; (edx) = Dividend.HighPart

lid00:  mov     ebx, [esp+24]       ; (ebx) = Divisor
        or      ebx, ebx
        jz      short lid_zero      ; Attempted a divide by zero

        push    ebp

        mov     ecx, 64             ; Loop count
        xor     esi, esi            ; Clear partial remainder

; (edx:eax) = Dividend
; (ebx) = Divisor
; (ecx) = Loop count
; (esi) = partial remainder

align 4
lid10:  shl     eax, 1              ; (LowPart << 1)  | 0
        rcl     edx, 1              ; (HighPart << 1) | CF
        rcl     esi, 1              ; (Partial << 1)  | CF

        sbb     edi, edi            ; clone CF into edi (0 or -1)

        cmp     esi, ebx            ; check if partial remainder less then divisor
        cmc
        sbb     ebp, ebp            ; clone CF intp ebp
        or      edi, ebp            ; merge with remainder of high bit

        sub     eax, edi            ; merge quotient bit
        and     edi, ebx            ; Select divisor or 0
        sub     esi, edi

        dec     ecx                 ; dec interration count
        jnz     short lid10         ; go around again

        pop     ebp
        pop     ebx
        pop     edi

        mov     ecx, [esp+20]       ; (ecx) = Remainder
        or      ecx, ecx
        jnz     short lid20

        pop     esi
        stdRET  _RtlExtendedLargeIntegerDivide

align 4
lid20:
        mov     [ecx], esi          ; store remainder
        pop     esi
        stdRET  _RtlExtendedLargeIntegerDivide

lid_zero:
IFNDEF BLDR_KERNEL_RUNTIME
        stdCall _RtlRaiseStatus, <STATUS_INTEGER_DIVIDE_BY_ZERO>
ENDIF
        pop     ebx
        pop     edi
        pop     esi
        stdRET  _RtlExtendedLargeIntegerDivide

stdENDP     _RtlExtendedLargeIntegerDivide

        page
        subttl  "Extended Magic Divide"
;++
;
; LARGE_INTEGER
; RtlExtendedMagicDivide (
;    IN LARGE_INTEGER Dividend,
;    IN LARGE_INTEGER MagicDivisor,
;    IN CCHAR ShiftCount
;    )
;
; Routine Description:
;
;    This function divides a signed large integer by an unsigned large integer
;    and returns the signed large integer result. The division is performed
;    using reciprocal multiplication of a signed large integer value by an
;    unsigned large integer fraction which represents the most significant
;    64-bits of the reciprocal divisor rounded up in its least significant bit
;    and normalized with respect to bit 63. A shift count is also provided
;    which is used to truncate the fractional bits from the result value.
;
; Arguments:
;
;   (ebp+8) = Dividend
;   (ebp+16) = MagicDivisor value is a 64-bit multiplicative reciprocal
;   (ebp+24) = ShiftCount - Right shift adjustment value.
;
; Return Value:
;
;    The large integer result is stored  in (edx:eax)
;
;--

RemdDiv     equ [ebp+8]             ; Dividend
RemdRec     equ [ebp+16]            ; Reciprocal (magic divisor)
RemdShift   equ [ebp+24]
RemdTmp1    equ [ebp-4]
RemdTmp2    equ [ebp-8]
RemdTmp3    equ [ebp-12]

cPublicProc _RtlExtendedMagicDivide ,5

        push    ebp
        mov     ebp,esp
        sub     esp,12
        push    esi

        mov     esi, RemdDiv+4
        test    esi,80000000h
        jz      remd10                  ; no sign, no need to negate

        neg     dword ptr RemdDiv+4
        neg     dword ptr RemdDiv
        sbb     dword ptr RemdDiv+4,0   ; negate

remd10: mov     eax,RemdRec
        mul     dword ptr RemdDiv       ; (edx:eax) = Div.lo * Rec.lo
        mov     RemdTmp1,edx

        mov     eax,RemdRec
        mul     dword ptr RemdDiv+4     ; (edx:eax) = Div.hi * Rec.lo
        mov     RemdTmp2,eax
        mov     RemdTmp3,edx

        mov     eax,RemdRec+4
        mul     dword ptr RemdDiv       ; (edx:eax) = Div.lo * Rec.hi

;
;   Col 0 doesn't matter
;   Col 1 = Hi(Div.lo * Rec.lo) + Low(Div.Hi * Rec.lo) + Low(Div.lo * Rec.hi)
;         = RemdTmp1 + RemdTmp2 + eax
;         -> Only want carry from Col 1
;

        xor     ecx,ecx                 ; (ecx) = 0
        add     eax,RemdTmp1
        adc     ecx, 0                  ; save carry in ecx
        add     eax,RemdTmp2
        adc     ecx, 0                  ; Save Carry, all we want from Col2

        mov     RemdTmp1,edx

        mov     eax,RemdRec+4
        mul     dword ptr RemdDiv+4     ; (edx:eax) = Div.Hi * Rec.Hi

;
;   TOS = carry flag from Col 1
;
;   Col 2 = Col1 CF +
;           Hi(Div.Hi * Rec.Lo) + Hi(Div.Lo * Rec.Hi) + Low(Div.Hi * Rec.Hi)
;         = CF + RemdTmp3 + RemdTmp1 + eax
;
;   Col 3 = Col2 CF + Hi(Div.Hi * Rec.Hi)
;         = CF + edx
;

        add     eax,RemdTmp1
        adc     edx, 0                  ; add carry to edx
        add     eax,RemdTmp3            ; (eax) = col 2
        adc     edx, 0                  ; add carry to edx
        add     eax, ecx
        adc     edx, 0                  ; (edx) = col 3

;
;   (edx:eax) = the high 64 bits of the multiply, shift it right by
;               shift count to discard bits to right of virtual decimal pt.
;
;   RemdShift could be as large as 63 and still not 0 the result, 386
;   will only shift 31 bits at a time, so must do the sift multiple
;   times to get correct effect.
;

        mov     cl,RemdShift
remd20: cmp     cl,31
        jbe     remd30
        sub     cl,31
        shrd    eax,edx,31
        shr     edx,31
        jmp     remd20

remd30: shrd    eax,edx,cl
        shr     edx,cl

;
;   Negate the result if need be
;

        test    esi,80000000h
        jz      remd40                  ; no sign, go return without negate

        neg     edx
        neg     eax
        sbb     edx,0

;
;   Store the result
;

remd40:
        ; results in (edx:eax)

        pop     esi
        mov     esp,ebp
        pop     ebp
        stdRET    _RtlExtendedMagicDivide

stdENDP _RtlExtendedMagicDivide


        page
        subttl  "Extended Integer Multiply"
;++
;
; LARGE_INTEGER
; RtlExtendedIntegerMultiply (
;    IN LARGE_INTEGER Multiplicand,
;    IN ULONG Multiplier
;    )
;
; Routine Description:
;
;    This function multiplies a signed large integer by a signed integer and
;    returns the signed large integer result.
;
; Arguments:
;
;   (ebp+8,12)=multiplican (MCAN)
;   (ebp+16)=multiplier (MPER)
;
; Return Value:
;
;    The large integer result is stored in (edx:eax)
;
;--

ReimMCAN    equ <dword ptr [ebp+8]>
ReimMPER    equ <dword ptr [ebp+16]>

cPublicProc _RtlExtendedIntegerMultiply ,3

        push    ebp
        mov     ebp,esp
        push    esi

        mov     esi,ReimMPER
        xor     esi,ReimMCAN+4              ; (esi) = result sign

        test    ReimMCAN+4,80000000h
        jz      short reim10                ; MCAN pos, go look at MPER

        neg     dword ptr ReimMCAN+4
        neg     dword ptr ReimMCAN
        sbb     dword ptr ReimMCAN+4,0      ; negate multiplican

reim10: test    ReimMPER,80000000h
        jz      short reim20                ; MPER pos, go do multiply

        neg     dword ptr ReimMPER          ; negate multiplier

reim20: mov     eax,ReimMPER
        mul     dword ptr ReimMCAN          ; (edx:eax) = MPER * MCAN.low
        push    edx
        mov     ecx, eax
        mov     eax,ReimMPER
        mul     dword ptr ReimMCAN+4        ; (edx:eax) = MPER * MCAN.high
        add     eax,[esp]                   ; (eax) = hi part of MPER*MCAN.low
                                            ;   plus low part of MPER*MCAN.hi

        test    esi,80000000h
        jz      short reim30                ; result sign is OK, go return

        neg     eax
        neg     ecx
        sbb     eax,0                       ; negate result

reim30: add     esp,4                       ; clean eax off stack
        pop     esi                         ; restore nonvolatile reg
        mov     edx,eax                     ; (edx:ecx) = result
        mov     eax,ecx                     ; (edx:eax) = result

        pop     ebp
        stdRET    _RtlExtendedIntegerMultiply

stdENDP _RtlExtendedIntegerMultiply

_TEXT   ends
        end
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\rtl\i386\divlarge.c ===
/*++

Copyright (c) 1992 Microsoft Corporation

Module Name:

    largediv.c

Abstract:

    This module implements the NT runtime library large integer divide
    routines.

    N.B. These routines use a one bit at a time algorithm and is slow.
         They should be used only when absolutely necessary.

Author:

    David N. Cutler 10-Aug-1992

Revision History:

--*/

#include "ntrtlp.h"

LARGE_INTEGER
RtlLargeIntegerDivide (
    IN LARGE_INTEGER Dividend,
    IN LARGE_INTEGER Divisor,
    OUT PLARGE_INTEGER Remainder OPTIONAL
    )

/*++

Routine Description:

    This routine divides an unsigned 64-bit dividend by an unsigned 64-bit
    divisor and returns a 64-bit quotient, and optionally a 64-bit remainder.

Arguments:

    Dividend - Supplies the 64-bit dividend for the divide operation.

    Divisor - Supplies the 64-bit divisor for the divide operation.

    Remainder - Supplies an optional pointer to a variable which receives
        the remainder

Return Value:

    The 64-bit quotient is returned as the function value.

--*/

{

    ULONG Index = 64;
    LARGE_INTEGER Partial = {0, 0};
    LARGE_INTEGER Quotient;

#ifndef BLDR_KERNEL_RUNTIME
    //
    // Check for divide by zero
    //

    if (!(Divisor.LowPart | Divisor.HighPart)) {
        RtlRaiseStatus (STATUS_INTEGER_DIVIDE_BY_ZERO);
    }
#endif

    //
    // Loop through the dividend bits and compute the quotient and remainder.
    //

    Quotient = Dividend;
    do {

        //
        // Shift the next dividend bit into the parital remainder and shift
        // the partial quotient (dividend) left one bit.
        //

        Partial.HighPart = (Partial.HighPart << 1) | (Partial.LowPart >> 31);
        Partial.LowPart = (Partial.LowPart << 1) | ((ULONG)Quotient.HighPart >> 31);
        Quotient.HighPart = (Quotient.HighPart << 1) | (Quotient.LowPart >> 31);
        Quotient.LowPart <<= 1;

        //
        // If the partial remainder is greater than or equal to the divisor,
        // then subtract the divisor from the partial remainder and insert a
        // one bit into the quotient.
        //

        if (((ULONG)Partial.HighPart > (ULONG)Divisor.HighPart) ||
            ((Partial.HighPart == Divisor.HighPart) &&
            (Partial.LowPart >= Divisor.LowPart))) {

            Quotient.LowPart |= 1;
            Partial.HighPart -= Divisor.HighPart;
            if (Partial.LowPart < Divisor.LowPart) {
                Partial.HighPart -= 1;
            }

            Partial.LowPart -= Divisor.LowPart;
        }

        Index -= 1;
    } while (Index > 0);

    //
    // If the remainder is requested, then return the 64-bit remainder.
    //

    if (ARGUMENT_PRESENT(Remainder)) {
        *Remainder = Partial;
    }

    //
    // Return the 64-bit quotient.
    //

    return Quotient;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\rtl\i386\lzntx86.asm ===
title	"Compression and Decompression Engines"
;++
;
; Copyright (c) 1989  Microsoft Corporation
;
; Module Name:
;
;    lzntx86.asm
;
; Abstract:
;
;    This module implements the compression and decompression engines needed
;    to support file system compression.  Functions are provided to
;    compress a buffer and decompress a buffer.
;
; Author:
;
;    Mark Zbikowski (markz) 15-Mar-1994
;
; Environment:
;
;    Any mode.
;
; Revision History:
;
;   15-Mar-1994 markz
;
;           386 version created
;
;--
.386p

        .xlist
include ks386.inc
include callconv.inc            ; calling convention macros
        .list

_TEXT   SEGMENT DWORD PUBLIC 'CODE'
        ASSUME  DS:FLAT, ES:FLAT, SS:NOTHING, FS:NOTHING, GS:NOTHING

        page
	subttl	"Decompress a buffer"
;++
;
; NTSTATUS
; LZNT1DecompressChunk (
;     OUT PUCHAR UncompressedBuffer,
;     IN PUCHAR EndOfUncompressedBufferPlus1,
;     IN PUCHAR CompressedBuffer,
;     IN PUCHAR EndOfCompressedBufferPlus1,
;     OUT PULONG FinalUncompressedChunkSize
;     )
;
; Routine Description:
;
;    This function decodes a stream of compression tokens and places the
;    resultant output into the destination buffer.  The format of the input
;    is described ..\lznt1.c.  As the input is decoded, checks are made to
;    ensure that no data is read past the end of the compressed input buffer
;    and that no data is stored past the end of the output buffer.  Violations
;    indicate corrupt input and are indicated by a status return.
;
;    The following code takes advantage of two distinct observations.
;    First, literal tokens occur at least twice as often as copy tokens.
;    This argues for having a "fall-through" being the case where a literal
;    token is found.  We structure the main decomposition loop in eight
;    pieces where the first piece is a sequence of literal-test fall-throughs
;    and the remainder are a copy token followed by 7,6,...,0 literal-test
;    fall-throughs.  Each test examines a particular bit in the tag byte
;    and jumps to the relevant code piece.
;
;    The second observation involves performing bounds checking only
;    when needed.  Bounds checking the compressed buffer need only be done
;    when fetching the tag byte.  If there is not enough room left in the
;    input for a tag byte and 8 (worst case) copy tokens, a branch is made
;    to a second loop that handles a byte-by-byte "safe" copy to finish
;    up the decompression.  Similarly, at the head of the loop a check is
;    made to ensure that there is enough room in the output buffer for 8
;    literal bytes.  If not enough room is left, then the second loop is
;    used.  Finally, after performing each copy, the output-buffer check
;    is made as well since a copy may take the destination pointer
;    arbitrarily close to the end of the destination.
;
;    The register conventions used in the loops below are:
;
;	    (al)    contains the current tag byte
;	    (ebx)   contains the current width in bits of the length given
;		    the maximum offset
;		    that can be utilized in a copy token.  We update this
;		    value only prior to performing a copy.  This width is used
;		    both to index a mask table (for extracting the length) as
;		    well as shifting (for extracting the copy offset)
;	    (ecx)   is used to contain counts during copies
;	    (edx)   is used as a temp variable during copies
;	    (esi)   is used mainly as the source of the next compressed token.
;		    It is also used for copies.
;	    (edi)   is used as the destination of literals and copies
;	    (ebp)   is used as a frame pointer
;
; Arguments:
;
;    UncompressedBuffer (ebp+8) - pointer to destination of uncompression.
;
;    EndOfUncompressedBufferPlus1  (ebp+12) - pointer just beyond the
;	output buffer.	This is used for consistency checking of the stored
;	compressed data.
;
;    CompressedBuffer (ebp+16) - pointer to compressed source.	This pointer
;       has been adjusted by the caller to point past the header word, so
;       the pointer points to the first tag byte describing which of the
;	following tokens are literals and which are copy groups.
;
;    EndOfCompressedBufferPlus1 (ebp+20) - pointer just beyond end of input
;	buffer.  This is used to terminate the decompression.
;
;    FinalUncompressedChunkSize (ebp+24) - pointer to a returned decompressed
;	size.  This has meaningful data ONLY when LZNT1DecompressChunk returns
;	STATUS_SUCCESS
;
; Return Value:
;
;    STATUS_SUCCESS is returned only if the decompression consumes thee entire
;	input buffer and does not exceed the output buffer.
;    STATUS_BAD_COMPRESSION_BUFFER is returned when the output buffer would be
;	overflowed.
;
;--

;    Decompression macros

;**	TestLiteralAt - tests to see if there's a literal at a specific
;	    bit position.  If so, it branches to the appropriate copy code
;	    (decorated by the bit being used).
;
;       This code does no bounds checking

TestLiteralAt	macro	CopyLabel,bit,IsMain
	test	al,1 SHL bit		; is there a copy token at this position?
	jnz	CopyLabel&bit		; yes, go copy it

	mov	dl,[esi+bit+1]		; (dl) = literal byte from compressed stream
ifidn <IsMain>,<Y>
	mov	[edi+bit],dl		; store literal byte
else
	mov	[edi],dl		; store literal byte
	inc	edi			; point to next literal
endif

endm


;	Jump - allow specific jumps with computed labels.

Jump	macro	lab,tag
        jmp     lab&tag
endm



;**	DoCopy - perform a copy.  If a bit position is specified
;	    then branch to the appropriate point in the "safe" tail when
;	    the copy takes us too close to the end of the output buffer
;
;       This code checks the bounds of the copy token:  copying before the
;       beginning of the buffer and copying beyond the end of the buffer.

DoCopy	macro	AdjustLabel,bit,IsMain

ifidn	<IsMain>,<Y>
if bit ne 0
	add	edi,bit
endif
endif

Test&AdjustLabel&bit:
	cmp	edi,WidthBoundary
	ja	Adjust&AdjustLabel&bit

	xor	ecx,ecx
	mov	cx,word ptr [esi+bit+1] ; (ecx) = encoded length:offset
	lea	edx,[esi+1]		; (edx) = next token location
	mov	Temp,edx

	mov	esi,ecx 		; (esi) = encoded length:offset
	and	ecx,MaskTab[ebx*4]	; (ecx) = length
	xchg	ebx,ecx 		; (ebx) = length/(ecx) = width
	shr	esi,cl			; (esi) = offset
	xchg	ebx,ecx 		; (ebx) = width, (ecx) = length

	neg	esi			; (esi) = negative real offset
	lea	esi,[esi+edi-1] 	; (esi) = pointer to previous string

        cmp     esi,UncompressedBuffer  ; off front of buffer?
        jb      DOA                     ; yes, error

	add	ecx,3			; (ecx) = real length

	lea	edx,[edi+ecx]		; (edx) = end of copy
ifidn	<IsMain>,<Y>
	cmp	edx,EndOfSpecialDest	; do we exceed buffer?
	jae	TailAdd&bit		; yes, handle in safe tail
else
	cmp	edx,EndOfUncompressedBufferPlus1
					; do we exceed buffer?
	ja	DOA			; yes, error
endif

	rep	movsb			; Copy the bytes

	mov	esi,Temp		; (esi) = next token location

ifidn	<IsMain>,<Y>
	sub	edi,bit+1
endif

endm





;**	AdjustWidth - adjust width of length based upon current position of
;	    input buffer (max offset)


AdjustWidth macro   l,i
Adjust&l&i:
	dec	ebx			; (ebx) = new width pointer
	mov	edx,UncompressedBuffer	; (edx) = pointer to dest buffer
	add	edx,WidthTab[ebx*4]	; (edx) = new width boundary
	mov	WidthBoundary,edx	; save boundary for comparison
	jmp	Test&l&i

endm


;**	GenerateBlock - generates the unsafe block of copy/literal pieces.
;
;       This code does no checking for simple input/output checking.  Only
;       the data referred to by the copy tokens is checked.

GenerateBlock	macro	bit
Copy&bit:

	DoCopy	Body,bit,Y

	j = bit + 1
	while j lt 8
	    TestLiteralAt   Copy,%(j),Y
	    j = j + 1
	endm

	add	esi,9
	add	edi,8

	jmp	Top

	AdjustWidth Body,bit
endm



;**	GenerateTailBlock - generates safe tail block for compression.	This
;	    code checks everything before each byte stored so it is expected
;	    to be executed only at the end of the buffer.


GenerateTailBlock   macro   bit
TailAdd&bit:
	add	EndOfCompressedBufferPlus1,1+2*8
                                        ; restore buffer length to true length
	mov     esi,Temp                ; (esi) = source of copy token block
	dec	esi

Tail&bit:
	lea	ecx,[esi+bit+1]         ; (ecx) = source of next token
	cmp	ecx,EndOfCompressedBufferPlus1	; are we done?
	jz	Done                    ; yes - we exactly match end of buffer
;       ja      DOA                     ; INTERNAL ERROR only

	cmp	edi,EndOfUncompressedBufferPlus1
	jz	Done			; go quit, destination is full
;       ja      DOA                     ; INTERNAL ERROR only

	TestLiteralAt	TailCopy,bit,N

        Jump	Tail,%(bit+1)


;       We expect a copy token to be at [esi+bit+1].  This means that
;       esi+bit+1+tokensize must be <= EndOfCompressedBufferPlus1
TailCopy&bit:
        lea     ecx,[esi+bit+3]         ; (ecx) = next input position
        cmp     ecx,EndOfCompressedBufferPlus1  ; do we go too far
        ja      DOA                     ; yes, we are beyond the end of buffer

	DoCopy	Tail,bit,N		; perform copy

        Jump	Tail,%(bit+1)

	AdjustWidth Tail,bit

endm



cPublicProc _LZNT1DecompressChunk ,5
	push	ebp			; (tos) = saved frame pointer
	mov	ebp,esp 		; (ebp) = frame pointer to arguments
	sub	esp,12			; Open up room for locals

Temp			      equ dword ptr [ebp-12]
WidthBoundary		      equ dword ptr [ebp-8]
EndOfSpecialDest	      equ dword ptr [ebp-4]

;SavedEBP		      equ dword ptr [ebp]
;ReturnAddress		      equ dword ptr [ebp+4]

UncompressedBuffer	      equ dword ptr [ebp+8]
EndOfUncompressedBufferPlus1  equ dword ptr [ebp+12]
CompressedBuffer	      equ dword ptr [ebp+16]
EndOfCompressedBufferPlus1    equ dword ptr [ebp+20]
FinalUncompressedChunkSize    equ dword ptr [ebp+24]


	push	ebx
	push	esi
	push	edi

	mov	edi,UncompressedBuffer	; (edi) = destination of decompress
	mov	esi,CompressedBuffer	; (esi) = header
	sub	EndOfCompressedBufferPlus1,1+2*8    ; make room for special source

	mov	eax,EndOfUncompressedBufferPlus1    ; (eax) = end of destination
	sub	eax,8			; (eax) = beginning of special tail
	mov	EndOfSpecialDest,eax	; store special tail

	mov	WidthBoundary,edi	; force initial width mismatch
	mov	ebx,13			; initial width of output


Top:	cmp	esi,EndOfCompressedBufferPlus1	; Will this be the last tag group in source?
	jae	DoTail			; yes, go handle specially
	cmp	edi,EndOfSpecialDest	; are we too close to end of buffer?
	jae	DoTail			; yes, go skip to end

	mov	al,byte ptr [esi]	; (al) = tag byte, (esi) points to token

	irpc	i,<01234567>
	    TestLiteralAt   Copy,%(i),Y
	endm

	add	esi,9
	add	edi,8

	jmp	Top
;		       ; Width of offset    Width of length
WidthTab    dd	0FFFFh ;	16		   0
	    dd	0FFFFh ;	15		   1
	    dd	0FFFFh ;	14		   2
	    dd	0FFFFh ;	13		   3
	    dd	0FFFFh ;	12		   4
	    dd	2048   ;	11		   5
	    dd	1024   ;	10		   6
	    dd	512    ;	9		   7
	    dd	256    ;	8		   8
	    dd	128    ;	7		   9
	    dd	64     ;	6		   10
	    dd	32     ;	5		   11
	    dd	16     ;	4		   12
	    dd	0      ;	3		   13
	    dd	0      ;	2		   14
	    dd	0      ;	1		   15
	    dd	0      ;	0		   16


;				    ;
MaskTab     dd	0000000000000000b   ;	     0
	    dd	0000000000000001b   ;	     1
	    dd	0000000000000011b   ;	     2
	    dd	0000000000000111b   ;	     3
	    dd	0000000000001111b   ;	     4
	    dd	0000000000011111b   ;	     5
	    dd	0000000000111111b   ;	     6
	    dd	0000000001111111b   ;	     7
	    dd	0000000011111111b   ;	     8
	    dd	0000000111111111b   ;	     9
	    dd	0000001111111111b   ;	     10
	    dd	0000011111111111b   ;	     11
	    dd	0000111111111111b   ;	     12
	    dd	0001111111111111b   ;	     13
	    dd	0011111111111111b   ;	     14
	    dd	0111111111111111b   ;	     15
	    dd	1111111111111111b   ;	     16


	irpc	i,<01234567>
	    GenerateBlock   %(i)
	endm

;	We're handling a tail specially for this.  We must check at all
;	spots for running out of input as well as overflowing output.
;
;	(esi) = pointer to possible next tag

DoTail: add	EndOfCompressedBufferPlus1,1+2*8    ; point to end of compressed input

TailLoop:
	cmp	esi,EndOfCompressedBufferPlus1	; are we totally done?
	jz	Done			; yes, go return
	mov	al,byte ptr [esi]	; (al) = tag byte

	jmp	Tail0

	irpc	i,<01234567>
	    GenerateTailBlock	i
	endm

Tail8:	add	esi,9
	jmp	TailLoop



DOA:	mov	eax,STATUS_BAD_COMPRESSION_BUFFER
	jmp	Final

Done:	mov	eax,edi 		; (eax) = pointer to next byte to store
	sub	eax,UncompressedBuffer	; (eax) = length of uncompressed
	mov	edi,FinalUncompressedChunkSize	; (edi) = user return value location
	mov	[edi],eax		; return total transfer size to user
	xor	eax,eax 		; (eax) = STATUS_SUCCESS

Final:	pop	edi
	pop	esi
	pop	ebx
	mov	esp,ebp
	pop	ebp


	stdRET _LZNT1DecompressChunk

stdENDP _LZNT1DecompressChunk

_TEXT   ends
        end
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\rtl\i386\debug3.c ===
//++
//
// Copyright (c) 1990  Microsoft Corporation
//
// Module Name:
//
//    debug3.c
//
// Abstract:
//
//    This module implements architecture specific functions to support debugging NT.
//
// Author:
//
//    Steven R. Wood (stevewo) 3-Aug-1989
//
// Environment:
//
//    Any mode.
//
// Revision History:
//
//--

#include "stdarg.h"
#include "stdio.h"
#include "string.h"
#include "ntrtlp.h"

//
// Prototype for local procedure
//

NTSTATUS
DebugService(
    ULONG   ServiceClass,
    PVOID   Arg1,
    PVOID   Arg2
    );

VOID _fptrap() {};

NTSTATUS
DebugPrint(
    IN PSTRING Output
    )
{
    return DebugService( BREAKPOINT_PRINT, Output, 0 );
}


ULONG
DebugPrompt(
    IN PSTRING Output,
    IN PSTRING Input
    )
{
    return DebugService( BREAKPOINT_PROMPT, Output, Input );
}

VOID
DebugLoadImageSymbols(
    IN PSTRING FileName,
    IN PKD_SYMBOLS_INFO SymbolInfo
    )
{
    DebugService( BREAKPOINT_LOAD_SYMBOLS, FileName, SymbolInfo );
}

NTSTATUS
DebugService(
    ULONG   ServiceClass,
    PVOID   Arg1,
    PVOID   Arg2
    )

//++
//
//  Routine Description:
//
//      Allocate an ExceptionRecord, fill in data to allow exception
//      dispatch code to do the right thing with the service, and
//      call RtlRaiseException (NOT ExRaiseException!!!).
//
//  Arguments:
//      ServiceClass - which call is to be performed
//      Arg1 - generic first argument
//      Arg2 - generic second argument
//
//  Returns:
//      Whatever the exception returns in eax
//
//--

{
    NTSTATUS    RetValue;

    _asm {
        mov     eax, ServiceClass
        mov     ecx, Arg1
        mov     edx, Arg2

        int     2dh                 ; Raise exception
        int     3                   ; DO NOT REMOVE (See KiDebugService)

        mov     RetValue, eax

    }

    return RetValue;
}


// DebugUnloadImageSymbols must appear after DebugSerive.  Moved
// it down below DebugService, so BBT would have a label after DebugService.
// A label after the above _asm  is necessary so BBT can treat DebugService
// as  "KnownDataRange".   Otherwise, the two  'int' instructions could get broken up
// by BBT's optimizer.
VOID
DebugUnLoadImageSymbols(
    IN PSTRING FileName,
    IN PKD_SYMBOLS_INFO SymbolInfo
    )
{
    DebugService( BREAKPOINT_UNLOAD_SYMBOLS, FileName, SymbolInfo );
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\rtl\i386\movemem.asm ===
title  "User Mode Zero and Move Memory functions"
;++
;
; Copyright (c) 1989  Microsoft Corporation
;
; Module Name:
;
;    movemem.asm
;
; Abstract:
;
;    This module implements functions to zero and copy blocks of memory
;
;
; Author:
;
;    Steven R. Wood (stevewo) 25-May-1990
;
; Environment:
;
;    User mode only.
;
; Revision History:
;
;--
.386p
        .xlist
include ks386.inc
include callconv.inc            ; calling convention macros
        .list

if DBG

ifndef BLDR_KERNEL_RUNTIME
_TEXT   SEGMENT PARA PUBLIC 'CODE'
_MsgUnalignedPtr    db  'RTL: RtlCompare/FillMemoryUlong called with unaligned pointer (%x)\n',0
_MsgUnalignedCount  db  'RTL: RtlCompare/FillMemoryUlong called with unaligned count (%x)\n',0
_TEXT   ENDS
endif

ifndef BLDR_KERNEL_RUNTIME
ifdef NTOS_KERNEL_RUNTIME
        extrn   _KdDebuggerEnabled:BYTE
endif
        EXTRNP  _DbgBreakPoint,0
        extrn   _DbgPrint:near
endif
endif

;
; Alignment parameters for zeroing and moving memory.
;

ZERO_MEMORY_ALIGNMENT = 4
ZERO_MEMORY_ALIGNMENT_LOG2 = 2
ZERO_MEMORY_ALIGNMENT_MASK = ZERO_MEMORY_ALIGNMENT - 1

MEMORY_ALIGNMENT = 4
MEMORY_ALIGNMENT_LOG2 = 2
MEMORY_ALIGNMENT_MASK = MEMORY_ALIGNMENT - 1


;
; Alignment for functions in this module
;

CODE_ALIGNMENT macro
    align   16
endm


_TEXT   SEGMENT PARA PUBLIC 'CODE'
        ASSUME  DS:FLAT, ES:FLAT, SS:NOTHING, FS:NOTHING, GS:NOTHING

        page , 132
        subttl "RtlCompareMemory"
;++
;
; ULONG
; RtlCompareMemory (
;    IN PVOID Source1,
;    IN PVOID Source2,
;    IN ULONG Length
;    )
;
; Routine Description:
;
;    This function compares two blocks of memory and returns the number
;    of bytes that compared equal.
;
; Arguments:
;
;    Source1 (esp+4) - Supplies a pointer to the first block of memory to
;       compare.
;
;    Source2 (esp+8) - Supplies a pointer to the second block of memory to
;       compare.
;
;    Length (esp+12) - Supplies the Length, in bytes, of the memory to be
;       compared.
;
; Return Value:
;
;    The number of bytes that compared equal is returned as the function
;    value. If all bytes compared equal, then the length of the orginal
;    block of memory is returned.
;
;--

RcmSource1      equ     [esp+12]
RcmSource2      equ     [esp+16]
RcmLength       equ     [esp+20]

CODE_ALIGNMENT
cPublicProc _RtlCompareMemory,3
cPublicFpo 3,0

        push    esi                     ; save registers
        push    edi                     ;
        cld                             ; clear direction
        mov     esi,RcmSource1          ; (esi) -> first block to compare
        mov     edi,RcmSource2          ; (edi) -> second block to compare

;
;   Compare dwords, if any.
;

rcm10:  mov     ecx,RcmLength           ; (ecx) = length in bytes
        shr     ecx,2                   ; (ecx) = length in dwords
        jz      rcm20                   ; no dwords, try bytes
        repe    cmpsd                   ; compare dwords
        jnz     rcm40                   ; mismatch, go find byte

;
;   Compare residual bytes, if any.
;

rcm20:  mov     ecx,RcmLength           ; (ecx) = length in bytes
        and     ecx,3                   ; (ecx) = length mod 4
        jz      rcm30                   ; 0 odd bytes, go do dwords
        repe    cmpsb                   ; compare odd bytes
        jnz     rcm50                   ; mismatch, go report how far we got

;
;   All bytes in the block match.
;

rcm30:  mov     eax,RcmLength           ; set number of matching bytes
        pop     edi                     ; restore registers
        pop     esi                     ;
        stdRET  _RtlCompareMemory

;
;   When we come to rcm40, esi (and edi) points to the dword after the
;   one which caused the mismatch.  Back up 1 dword and find the byte.
;   Since we know the dword didn't match, we can assume one byte won't.
;

rcm40:  sub     esi,4                   ; back up
        sub     edi,4                   ; back up
        mov     ecx,5                   ; ensure that ecx doesn't count out
        repe    cmpsb                   ; find mismatch byte

;
;   When we come to rcm50, esi points to the byte after the one that
;   did not match, which is TWO after the last byte that did match.
;

rcm50:  dec     esi                     ; back up
        sub     esi,RcmSource1          ; compute bytes that matched
        mov     eax,esi                 ;
        pop     edi                     ; restore registers
        pop     esi                     ;
        stdRET  _RtlCompareMemory

stdENDP _RtlCompareMemory


       subttl  "RtlCompareMemory"
EcmlSource       equ     [esp + 4 + 4]
EcmlLength       equ     [esp + 4 + 8]
EcmlPattern      equ     [esp + 4 + 12]

; end of arguments

CODE_ALIGNMENT
cPublicProc _RtlCompareMemoryUlong  ,3

;
; Save the non-volatile registers that we will use, without the benefit of
; a frame pointer.  No exception handling in this routine.
;

        push    edi

;
; Setup the registers for using REP STOS instruction to zero memory.
;
;   edi -> memory to zero
;   ecx = number of 32-bit words to zero
;   edx = number of extra 8-bit bytes to zero at the end (0 - 3)
;   eax = value to store in destination
;   direction flag is clear for auto-increment
;

        mov     edi,EcmlSource
if DBG
ifndef BLDR_KERNEL_RUNTIME
        test    edi,3
        jz      @F
        push    edi
        push    offset FLAT:_MsgUnalignedPtr
        call    _DbgPrint
        add     esp, 2 * 4
ifdef NTOS_KERNEL_RUNTIME
        cmp     _KdDebuggerEnabled,0
else
        mov     eax,fs:[PcTeb]
        mov    eax,[eax].TebPeb
        cmp     byte ptr [eax].PebBeingDebugged,0
endif
        je      @F
        call    _DbgBreakPoint@0
@@:
endif
endif
        mov     ecx,EcmlLength
        mov     eax,EcmlPattern
        shr     ecx,ZERO_MEMORY_ALIGNMENT_LOG2


;
; If number of 32-bit words to compare is non-zero, then do it.
;

        repe    scasd
        je      @F
        sub     edi,4
@@:
        sub     edi,EcmlSource
        mov     eax,edi
        pop     edi
        stdRET    _RtlCompareMemoryUlong

stdENDP _RtlCompareMemoryUlong


       subttl  "RtlFillMemory"
;++
;
; VOID
; RtlFillMemory (
;    IN PVOID Destination,
;    IN ULONG Length,
;    IN UCHAR Fill
;    )
;
; Routine Description:
;
;    This function fills memory with a byte value.
;
; Arguments:
;
;    Destination - Supplies a pointer to the memory to zero.
;
;    Length - Supplies the Length, in bytes, of the memory to be zeroed.
;
;    Fill - Supplies the byte value to fill memory with.
;
; Return Value:
;
;    None.
;
;--

; definitions for arguments
; (TOS) = Return address

EfmDestination  equ     [esp + 4 + 4]
EfmLength       equ     [esp + 4 + 8]
EfmFill         equ     byte ptr [esp + 4 + 12]

; end of arguments

CODE_ALIGNMENT
cPublicProc _RtlFillMemory  ,3
cPublicFpo 3,1

;
; Save the non-volatile registers that we will use, without the benefit of
; a frame pointer.  No exception handling in this routine.
;

        push    edi

;
; Setup the registers for using REP STOS instruction to zero memory.
;
;   edi -> memory to zero
;   ecx = number of 32-bit words to zero
;   edx = number of extra 8-bit bytes to zero at the end (0 - 3)
;   eax = value to store in destination
;   direction flag is clear for auto-increment
;

        mov     edi,EfmDestination
        mov     ecx,EfmLength
        mov     al,EfmFill
        mov     ah,al
        shl     eax,16
        mov     al,EfmFill
        mov     ah,al
        cld

        mov     edx,ecx
        and     edx,ZERO_MEMORY_ALIGNMENT_MASK
        shr     ecx,ZERO_MEMORY_ALIGNMENT_LOG2


;
; If number of 32-bit words to zero is non-zero, then do it.
;

        rep     stosd

;
; If number of extra 8-bit bytes to zero is non-zero, then do it.  In either
; case restore non-volatile registers and return.
;

        or      ecx,edx
        jnz     @F
        pop     edi
        stdRET    _RtlFillMemory
@@:
        rep     stosb
        pop     edi
        stdRET    _RtlFillMemory

stdENDP _RtlFillMemory

       subttl  "RtlZeroMemory"
;++
;
; VOID
; RtlFillMemoryUlong (
;    IN PVOID Destination,
;    IN ULONG Length,
;    IN ULONG Fill
;    )
;
; Routine Description:
;
;    This function fills memory with a 32-bit value.  The Destination pointer
;    must be aligned on a 4 byte boundary and the low order two bits of the
;    Length parameter are ignored.
;
; Arguments:
;
;    Destination - Supplies a pointer to the memory to zero.
;
;    Length - Supplies the Length, in bytes, of the memory to be zeroed.
;
;    Fill - Supplies the 32-bit value to fill memory with.
;
; Return Value:
;
;    None.
;
;--

; definitions for arguments
; (TOS) = Return address

EfmlDestination  equ     [esp + 4 + 4]
EfmlLength       equ     [esp + 4 + 8]
EfmlFill         equ     [esp + 4 + 12]

; end of arguments

CODE_ALIGNMENT
cPublicProc _RtlFillMemoryUlong  ,3
cPublicFpo 3,1

;
; Save the non-volatile registers that we will use, without the benefit of
; a frame pointer.  No exception handling in this routine.
;

        push    edi

;
; Setup the registers for using REP STOS instruction to zero memory.
;
;   edi -> memory to zero
;   ecx = number of 32-bit words to zero
;   edx = number of extra 8-bit bytes to zero at the end (0 - 3)
;   eax = value to store in destination
;   direction flag is clear for auto-increment
;

        mov     edi,EfmlDestination
if DBG
ifndef BLDR_KERNEL_RUNTIME
        test    edi,3
        jz      @F
        push    edi
        push    offset FLAT:_MsgUnalignedPtr
        call    _DbgPrint
        add     esp, 2 * 4
ifdef NTOS_KERNEL_RUNTIME
        cmp     _KdDebuggerEnabled,0
else
        mov     eax,fs:[PcTeb]
        mov    eax,[eax].TebPeb
        cmp     byte ptr [eax].PebBeingDebugged,0
endif
        je      @F
        call    _DbgBreakPoint@0
@@:
endif
endif
        mov     ecx,EfmlLength
        mov     eax,EfmlFill
        shr     ecx,ZERO_MEMORY_ALIGNMENT_LOG2


;
; If number of 32-bit words to zero is non-zero, then do it.
;

        rep     stosd

        pop     edi
        stdRET    _RtlFillMemoryUlong

stdENDP _RtlFillMemoryUlong

       subttl  "RtlZeroMemory"
;++
;
; VOID
; RtlZeroMemory (
;    IN PVOID Destination,
;    IN ULONG Length
;    )
;
; Routine Description:
;
;    This function zeros memory.
;
; Arguments:
;
;    Destination - Supplies a pointer to the memory to zero.
;
;    Length - Supplies the Length, in bytes, of the memory to be zeroed.
;
; Return Value:
;
;    None.
;
;--

; definitions for arguments
; (TOS) = Return address

EzmDestination  equ     [esp + 4 + 4]
EzmLength       equ     [esp + 4 + 8]

; end of arguments

CODE_ALIGNMENT
cPublicProc _RtlZeroMemory  ,2
cPublicFpo 2,1

;
; Save the non-volatile registers that we will use, without the benefit of
; a frame pointer.  No exception handling in this routine.
;

        push    edi

;
; Setup the registers for using REP STOS instruction to zero memory.
;
;   edi -> memory to zero
;   ecx = number of 32-bit words to zero
;   edx = number of extra 8-bit bytes to zero at the end (0 - 3)
;   eax = zero (value to store in destination)
;   direction flag is clear for auto-increment
;

        mov     edi,EzmDestination
        mov     ecx,EzmLength
        xor     eax,eax
        cld

        mov     edx,ecx
        and     edx,ZERO_MEMORY_ALIGNMENT_MASK
        shr     ecx,ZERO_MEMORY_ALIGNMENT_LOG2


;
; If number of 32-bit words to zero is non-zero, then do it.
;

        rep     stosd

;
; If number of extra 8-bit bytes to zero is non-zero, then do it.  In either
; case restore non-volatile registers and return.
;

        or      ecx,edx
        jnz     @F
        pop     edi
        stdRET    _RtlZeroMemory
@@:
        rep     stosb
        pop     edi
        stdRET    _RtlZeroMemory

stdENDP _RtlZeroMemory

        page , 132
        subttl  "RtlMoveMemory"
;++
;
; VOID
; RtlMoveMemory (
;    IN PVOID Destination,
;    IN PVOID Source OPTIONAL,
;    IN ULONG Length
;    )
;
; Routine Description:
;
;    This function moves memory either forward or backward, aligned or
;    unaligned, in 4-byte blocks, followed by any remaining bytes.
;
; Arguments:
;
;    Destination - Supplies a pointer to the destination of the move.
;
;    Source - Supplies a pointer to the memory to move.
;
;    Length - Supplies the Length, in bytes, of the memory to be moved.
;
; Return Value:
;
;    None.
;
;--

; Definitions of arguments
; (TOS) = Return address

EmmDestination  equ     [esp + 8 + 4]
EmmSource       equ     [esp + 8 + 8]
EmmLength       equ     [esp + 8 + 12]

; End of arguments

CODE_ALIGNMENT
cPublicProc _RtlMoveMemory  ,3
cPublicFpo 3,2

;
; Save the non-volatile registers that we will use, without the benefit of
; a frame pointer.  No exception handling in this routine.
;

        push    esi
        push    edi

;
; Setup the registers for using REP MOVS instruction to move memory.
;
;   esi -> memory to move (NULL implies the destination will be zeroed)
;   edi -> destination of move
;   ecx = number of 32-bit words to move
;   edx = number of extra 8-bit bytes to move at the end (0 - 3)
;   direction flag is clear for auto-increment
;

        mov     esi,EmmSource
        mov     edi,EmmDestination
        mov     ecx,EmmLength
        cld

        cmp     esi,edi                 ; Special case if Source > Destination
        jbe     overlap

nooverlap:
        mov     edx,ecx
        and     edx,MEMORY_ALIGNMENT_MASK
        shr     ecx,MEMORY_ALIGNMENT_LOG2

;
; If number of 32-bit words to move is non-zero, then do it.
;

        rep     movsd

;
; If number of extra 8-bit bytes to move is non-zero, then do it.  In either
; case restore non-volatile registers and return.
;

        or      ecx,edx
        jnz     @F
        pop     edi
        pop     esi
        stdRET    _RtlMoveMemory
@@:
        rep     movsb

movedone:
        pop     edi
        pop     esi
        stdRET    _RtlMoveMemory

;
; Here to handle special case when Source > Destination and therefore is a
; potential overlapping move.  If Source == Destination, then nothing to do.
; Otherwise, increment the Source and Destination pointers by Length and do
; the move backwards, a byte at a time.
;

overlap:
        je      movedone
        mov     eax,edi
        sub     eax,esi
        cmp     ecx,eax
        jbe     nooverlap

        std
        add     esi,ecx
        add     edi,ecx
        dec     esi
        dec     edi
        rep     movsb
        cld
        jmp     short movedone

stdENDP _RtlMoveMemory

_TEXT   ends
        end
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\rtl\i386\ntrtl386.h ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    ntrtl386.h

Abstract:

    i386 specific parts of ntrtlp.h

Author:

    Bryan Willman   10 April 90

Environment:

    These routines are statically linked in the caller's executable and
    are callable in either kernel mode or user mode.

Revision History:

--*/

//
// Exception handling procedure prototypes.
//
VOID
RtlpCaptureContext (
    OUT PCONTEXT ContextRecord
    );

VOID
RtlpUnlinkHandler (
    PEXCEPTION_REGISTRATION_RECORD UnlinkPointer
    );

PEXCEPTION_REGISTRATION_RECORD
RtlpGetRegistrationHead (
    VOID
    );

PVOID
RtlpGetReturnAddress (
    VOID
    );


//
//  Record dump procedures.
//

VOID
RtlpContextDump(
    IN PVOID Object,
    IN ULONG Control OPTIONAL
    );

VOID
RtlpExceptionReportDump(
    IN PVOID Object,
    IN ULONG Control OPTIONAL
    );

VOID
RtlpExceptionRegistrationDump(
    IN PVOID Object,
    IN ULONG Control OPTIONAL
    );
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\rtl\i386\ntcurteb.asm ===
title  "NtCurTeb.asm"
;++
;
; Copyright (c) 1989  Microsoft Corporation
;
; Module Name:
;
;    NtCurTeb.asm
;
; Abstract:
;
;    Efficient NtCurrentTeb code.
;
; Author:
;
;    Bryan Willman (bryanwi) 28 feb 90
;
; Environment:
;
; Revision History:
;
;--

.386p
        .xlist
include ks386.inc
include callconv.inc            ; calling convention macros
        .list

        page ,132
        subttl  "NtCurrentTeb"

IFDEF NTOS_KERNEL_RUNTIME
.PAGE   SEGMENT DWORD PUBLIC 'CODE'
ELSE
_TEXT   SEGMENT DWORD PUBLIC 'CODE'
ENDIF
        ASSUME  DS:FLAT, ES:FLAT, SS:NOTHING, FS:NOTHING, GS:NOTHING

;++
;
; PTEB
; NtCurrentTeb();
;
; Routine Description:
;
;    This routine returns the address of the current TEB.
;
; Arguments:
;
;    None
;
; Return Value:
;
;    Address of TEB.
;
;--
cPublicProc _NtCurrentTeb   ,0
cPublicFpo 0,0

;
;   How this works in both user and kernel mode.
;
;   In user mode, TEB.TIB.Self is flat address of containing structure.
;   In kernel mode, PCR.TIB.Self is flat address of the TEB.
;   Same offset both places, so fs:PcTeb is always the flat address
;   of the TEB.
;

        mov     eax,fs:[PcTeb]
        stdRET    _NtCurrentTeb

stdENDP _NtCurrentTeb
IFDEF NTOS_KERNEL_RUNTIME
.PAGE           ENDS
ELSE
_TEXT           ENDS
ENDIF
                end
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\rtl\i386\raisests.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    raisests.c

Abstract:

    This module implements the routine that raises an exception given a
    specific status value.

Author:

    David N. Cutler (davec) 8-Aug-1990

Environment:

    Any mode.

Revision History:

--*/

#include "ntrtlp.h"

VOID
RtlRaiseStatus (
    IN NTSTATUS Status
    )

/*++

Routine Description:

    This function raises an exception with the specified status value. The
    exception is marked as continuable with no parameters.

Arguments:

    Status - Supplies the status value to be used as the exception code
        for the exception that is to be raised.

Return Value:

    None.

--*/

{

    EXCEPTION_RECORD ExceptionRecord;

    //
    // Construct an exception record.
    //

    ExceptionRecord.ExceptionCode = Status;
    ExceptionRecord.ExceptionRecord = (PEXCEPTION_RECORD)NULL;
    ExceptionRecord.NumberParameters = 0;
    ExceptionRecord.ExceptionFlags = EXCEPTION_NONCONTINUABLE;
    RtlRaiseException(&ExceptionRecord);
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\rtl\i386\raise.asm ===
title  "Raise Exception"
;++
;
; Copyright (c) 1989  Microsoft Corporation
;
; Module Name:
;
;    raise.asm
;
; Abstract:
;
;    This module implements the function to raise a software exception.
;
; Author:
;
;    Bryan Willman  11 april 90
;
; Environment:
;
;    Any mode.
;
; Revision History:
;
;--
.386p
        .xlist
include ks386.inc
include callconv.inc            ; calling convention macros
        .list

        EXTRNP  _ZwRaiseException,3

_TEXT   SEGMENT DWORD PUBLIC 'CODE'
        ASSUME  DS:FLAT, ES:FLAT, SS:NOTHING, FS:NOTHING, GS:NOTHING

;
; Context flags definition.
;

CONTEXT_SETTING EQU CONTEXT_INTEGER OR CONTEXT_CONTROL OR CONTEXT_SEGMENTS


;
; Exception record length definition.
;

EXCEPTION_RECORD_LENGTH EQU (ErExceptionInformation + 16) AND 0fffffff0H

        page
        subttl  "Raise Software Exception"
;++
;
; VOID
; RtlRaiseException (
;    IN PEXCEPTION_RECORD ExceptionRecord
;    )
;
; Routine Description:
;
;    This function raises a software exception by building a context record,
;    establishing the stack limits of the current processor mode, and calling
;    the exception dispatcher. If the exception dispatcher finds a handler
;    to process the exception, then control is returned to the caller using
;    the NtContinue system service. Otherwise the NtLastChance system service
;    is called to provide default handing.
;
;   N.B.    On the 386, floating point state is not defined for non-fp
;           exceptions.  Therefore, this routine does not attempt to
;           capture it.
;
;           This means this routine cannot be used to report fp exceptions.
;
; Arguments:
;
;    ExceptionRecord (ebp+8) - Supplies a pointer to an exception record.
;
; Return Value:
;
;    None.
;
;--

cPublicProc _RtlRaiseException  ,1

        push    ebp
        mov     ebp,esp
        pushfd                          ; save flags before sub
        sub     esp,ContextFrameLength  ; Allocate a context record

;
;   Save regs we use in context record
;

        mov     [(ebp-ContextFrameLength-4)+CsEax],eax
        mov     [(ebp-ContextFrameLength-4)+CsEcx],ecx

;
;   Get pointer to exception report record, and set the exceptionaddress
;   field to be our return address
;

        mov     eax,[ebp+8]             ; (eax) -> ExceptionReportRecord

        mov     ecx,[ebp+4]
        mov     [eax.ErExceptionAddress],ecx

;
;   Copy machine context into the context record
;


        lea     eax,[ebp-ContextFrameLength-4]  ; (eax) -> Context record

        mov     [eax.CsEip],ecx

        mov     [eax.CsEbx],ebx
        mov     [eax.CsEdx],edx

        mov     [eax.CsEsi],esi
        mov     [eax.CsEdi],edi

;
; context record's ESP must have the argument popped off the stack
;

        lea     ecx,[ebp+12]

        mov     [eax.CsEsp],ecx

        mov     ecx,[ebp]
        mov     [eax.CsEbp],ecx

        mov     ecx,[ebp-4]
        mov     [eax.CsEflags],ecx

        mov     dword ptr [eax.CsSegCs],cs
        mov     dword ptr [eax.CsSegSs],ss

;
;   Set Context flags, note that FLOATING_POINT is NOT set.
;

        mov     dword ptr [eax.CsContextFlags],CONTEXT_SETTING

;
;   _ZwRaiseException(ExceptionRecord, ContextRecord, FirstChance=TRUE)
;

; 1 - TRUE
; eax - Context Record
; [ebp+8] - Exception Report Record

        stdCall   _ZwRaiseException,<[ebp+8],eax,1>

;
;   We came back, suggesting some sort of error in the call.  Raise
;   a status exception to report this, return from ZwRaiseException is type.
;

        sub     esp,EXCEPTION_RECORD_LENGTH ; allocate record on stack, esp is base
        mov     [esp.ErExceptionCode],eax   ; set exception type
        mov     dword ptr [esp.ErExceptionFlags],EXCEPTION_NONCONTINUABLE
        mov     dword ptr [esp.ErNumberParameters],0  ; no parms
        mov     eax,[ebp+8]
        mov     [esp.ErExceptionRecord],eax ; point back to first exception
        mov     eax,esp
        stdCall   _RtlRaiseException,<eax>

;
;   We will never come here, because RtlRaiseException will not allow
;   return if exception is non-continuable.
;

stdENDP _RtlRaiseException

_TEXT   ends
        end
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\rtl\i386\slist.asm ===
title  "Interlocked Support"
;++
;
; Copyright (c) 1996  Microsoft Corporation
;
; Module Name:
;
;    slist.asm
;
; Abstract:
;
;    This module implements functions to support interlocked S-List
;    operations.
;
; Author:
;
;    David N. Cutler (davec) 13-Mar-1996
;
; Environment:
;
;    Any mode.
;
; Revision History:
;
;--
.386p
        .xlist
include ks386.inc
include callconv.inc                    ; calling convention macros
        .list


_TEXT   SEGMENT DWORD PUBLIC 'CODE'
        ASSUME  DS:FLAT, ES:FLAT, SS:NOTHING, FS:NOTHING, GS:NOTHING

        page , 132
        subttl  "Interlocked Pop Entry Sequenced List"
;++
;
; PVOID
; FASTCALL
; RtlpInterlockedPopEntrySList (
;    IN PSLIST_HEADER ListHead
;    )
;
; Routine Description:
;
;    This function removes an entry from the front of a sequenced singly
;    linked list so that access to the list is synchronized in an MP system.
;    If there are no entries in the list, then a value of NULL is returned.
;    Otherwise, the address of the entry that is removed is returned as the
;    function value.
;
; Arguments:
;
;    (ecx) = ListHead - Supplies a pointer to the sequenced listhead from
;         which an entry is to be removed.
;
; Return Value:
;
;    The address of the entry removed from the list, or NULL if the list is
;    empty.
;
;--

cPublicFastCall RtlpInterlockedPopEntrySList, 1

cPublicFpo 0,2

;
; Save nonvolatile registers and read the listhead sequence number followed
; by the listhead next link.
;
; N.B. These two dwords MUST be read exactly in this order.
;

        push    ebx                     ; save nonvolatile registers
        push    ebp                     ;
        mov     ebp, ecx                ; save listhead address
        mov     edx,[ebp] + 4           ; get current sequence number
        mov     eax,[ebp] + 0           ; get current next link

;
; If the list is empty, then there is nothing that can be removed.
;

Epop10: or      eax, eax                ; check if list is empty
        jz      short Epop20            ; if z set, list is empty
        mov     ecx, edx                ; copy sequence number and depth
        add     ecx, 0FFFFH             ; adjust sequence number and depth

;
; N.B. It is possible for the following instruction to fault in the rare
;      case where the first entry in the list is allocated on another
;      processor and free between the time the free pointer is read above
;      and the following instruction. When this happens, the access fault
;      code continues execution by skipping the following instruction.
;      This results in the compare failing and the entire operation is
;      retried.
;

        mov     ebx, [eax]              ; get address of successor entry

.586

   lock cmpxchg8b qword ptr [ebp]       ; compare and exchange

.386

        jnz     short Epop10            ; if z clear, exchange failed

;
; Restore nonvolatile registers and return result.
;

cPublicFpo 0,0

Epop20: pop     ebp                     ; restore nonvolatile registers
        pop     ebx                     ;

        fstRET    RtlpInterlockedPopEntrySList

fstENDP RtlpInterlockedPopEntrySList

        page , 132
        subttl  "Interlocked Push Entry Sequenced List"
;++
;
; PVOID
; FASTCALL
; RtlpInterlockedPushEntrySList (
;    IN PSLIST_HEADER ListHead,
;    IN PVOID ListEntry
;    )
;
; Routine Description:
;
;    This function inserts an entry at the head of a sequenced singly linked
;    list so that access to the list is synchronized in an MP system.
;
; Arguments:
;
;    (ecx) ListHead - Supplies a pointer to the sequenced listhead into which
;          an entry is to be inserted.
;
;    (edx) ListEntry - Supplies a pointer to the entry to be inserted at the
;          head of the list.
;
; Return Value:
;
;    Previous contents of ListHead.  NULL implies list went from empty
;       to not empty.
;
;--

cPublicFastCall RtlpInterlockedPushEntrySList, 2

cPublicFpo 0,2

;
; Save nonvolatile registers and read the listhead sequence number followed
; by the listhead next link.
;
; N.B. These two dwords MUST be read exactly in this order.
;

        push    ebx                     ; save nonvolatile registers
        push    ebp                     ;
        mov     ebp, ecx                ; save listhead address
        mov     ebx, edx                ; save list entry address
        mov     edx,[ebp] + 4           ; get current sequence number
        mov     eax,[ebp] + 0           ; get current next link
Epsh10: mov     [ebx], eax              ; set next link in new first entry
        mov     ecx, edx                ; copy sequence number
        add     ecx, 010001H            ; increment sequence number and depth

.586

   lock cmpxchg8b qword ptr [ebp]       ; compare and exchange

.386

        jnz     short Epsh10            ; if z clear, exchange failed

;
; Restore nonvolatile registers and return result.
;

cPublicFpo 0,0

        pop     ebp                     ; restore nonvolatile registers
        pop     ebx                     ;

        fstRET  RtlpInterlockedPushEntrySList

fstENDP RtlpInterlockedPushEntrySList

_TEXT   ends
        end
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\rtl\i386\stringsp.asm ===
TITLE   "String support routines"
;++
;
; Copyright (c) 1989  Microsoft Corporation
;
; Module Name:
;
;    stringsup.asm
;
; Abstract:
;
;    This module implements suplimentary routines for performing string
;    operations.
;
; Author:
;
;    Larry Osterman (larryo) 18-Sep-1991
;
; Environment:
;
;    Any mode.
;
; Revision History:
;
;--

.386p

include callconv.inc            ; calling convention macros


_TEXT   SEGMENT DWORD PUBLIC 'CODE'
        ASSUME  DS:FLAT, ES:FLAT, SS:NOTHING, FS:NOTHING, GS:NOTHING

        page ,132
        subttl  "RtlInitAnsiString"
;++
;
; VOID
; RtlInitAnsiString(
;     OUT PANSI_STRING DestinationString,
;     IN PSZ SourceString OPTIONAL
;     )
;
;
; Routine Description:
;
;    The RtlInitAnsiString function initializes an NT counted string.
;    The DestinationString is initialized to point to the SourceString
;    and the Length and MaximumLength fields of DestinationString are
;    initialized to the length of the SourceString, which is zero if
;    SourceString is not specified.
;
; Arguments:
;
;    (TOS+4) = DestinationString - Pointer to the counted string to initialize
;
;    (TOS+8) = SourceString - Optional pointer to a null terminated string that
;        the counted string is to point to.
;
;
; Return Value:
;
;    None.
;
; NOTE:
;       This routine assumes that the string is less than 64K in size.
;
;--

cPublicProc _RtlInitAnsiString ,2
cPublicFpo 2,2
        push    edi
        mov     edi,[esp]+8+4           ; (edi)= SourceString
        mov     edx,[esp]+4+4           ; (esi)= DestinationString
        mov     DWORD PTR [edx], 0      ; (Destination).Length = (Destination).MaximumLength = 0
        mov     DWORD PTR [edx]+4, edi  ; (Destination).Buffer = 0
        test    edi, edi
        jz      @f
        or      ecx, -1
        xor     eax, eax
        repne   scasb
        not     ecx
        mov     [edx]+2, cx             ; Save maximum length
        dec     ecx
        mov     [edx], cx               ; Save length
@@:     pop     edi
        stdRET    _RtlInitAnsiString

stdENDP _RtlInitAnsiString


        page
        subttl  "RtlInitAnsiString"
;++
;
; VOID
; RtlInitUnicodeString(
;     OUT PUNICODE_STRING DestinationString,
;     IN PWSZ SourceString OPTIONAL
;     )
;
;
; Routine Description:
;
;    The RtlInitUnicodeString function initializes an NT counted string.
;    The DestinationString is initialized to point to the SourceString
;    and the Length and MaximumLength fields of DestinationString are
;    initialized to the length of the SourceString, which is zero if
;    SourceString is not specified.
;
; Arguments:
;
;    (TOS+4) = DestinationString - Pointer to the counted string to initialize
;
;    (TOS+8) = SourceString - Optional pointer to a null terminated string that
;        the counted string is to point to.
;
;
; Return Value:
;
;    None.
;
; NOTE:
;       This routine assumes that the string is less than 64K in size.
;
;--

cPublicProc _RtlInitUnicodeString ,2
cPublicFpo 2,2
        push    edi
        mov     edi,[esp]+8+4           ; (edi)= SourceString
        mov     edx,[esp]+4+4           ; (esi)= DestinationString
        mov     DWORD PTR [edx], 0      ; (Destination).Length = (Destination).MaximumLength = 0
        mov     DWORD PTR [edx]+4, edi  ; (Destination).Buffer = 0
        test    edi, edi
        jz      @f
        or      ecx, -1
        xor     eax, eax
        repne   scasw
        not     ecx
        shl     ecx,1
        mov     [edx]+2, cx             ; Save maximum length
        dec     ecx
        dec     ecx
        mov     [edx], cx               ; Save length
@@:     pop     edi
        stdRET    _RtlInitUnicodeString

stdENDP _RtlInitUnicodeString

_TEXT   ends
        end
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\rtl\i386\rtldump.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    rtldump.c

Abstract:

    This module implements dump procedures for:

	ContextRecords,
	ExceptionReportRecords,
	ExceptionRegistrationRecords

Author:

    Bryan Willman (bryanwi)  12 April 90

Environment:

    Callable in any mode in which DbgPrint works.

Revision History:

--*/

#include    "ntrtlp.h"

VOID
RtlpContextDump(
    IN PVOID Object,
    IN ULONG Control OPTIONAL
    )
/*++

Routine Description:

    This function dumps the contents of a context record.

    Currently, it does not dump floating point context.

Arguments:

    Object - Address of the record to dump.

    Control - Ignored, here so we look like a standard dump procedure.

Return Value:

    none

--*/

{
    PCONTEXT	Context;

    Context = (PCONTEXT)Object;

    DbgPrint("      Record @ %lx\n", (ULONG)Context);
    DbgPrint(" ContextFlags: %lx\n", Context->ContextFlags);
    DbgPrint("\n");

    DbgPrint("          Edi: %lx\n", Context->Edi);
    DbgPrint("          Esi: %lx\n", Context->Esi);
    DbgPrint("          Ebx: %lx\n", Context->Ebx);
    DbgPrint("          Edx: %lx\n", Context->Edx);
    DbgPrint("          Ecx: %lx\n", Context->Ecx);
    DbgPrint("          Eax: %lx\n", Context->Eax);
    DbgPrint("\n");

    DbgPrint("          Ebp: %lx\n", Context->Ebp);
    DbgPrint("          Eip: %lx\n", Context->Eip);
    DbgPrint("        SegCs: %lx\n", Context->SegCs);
    DbgPrint("       EFlags: %lx\n", Context->EFlags);
    DbgPrint("          Esp: %lx\n", Context->Esp);
    DbgPrint("        SegSs: %lx\n", Context->SegSs);
    DbgPrint("\n");

    return;
}



VOID
RtlpExceptionReportDump(
    IN PVOID Object,
    IN ULONG Control OPTIONAL
    )
/*++

Routine Description:

    This function dumps the contents of an Exception report record.

Arguments:

    Object - Address of the record to dump.

    Control - Ignored, here so we look like a standard dump procedure.

Return Value:

    none

--*/

{
    ULONG i;

    PEXCEPTION_RECORD	Exception;

    Exception = (PEXCEPTION_RECORD)Object;

    DbgPrint("                Record @ %lx\n", (ULONG)Exception);
    DbgPrint("          ExceptionCode: %lx\n", Exception->ExceptionCode);
    DbgPrint("         ExceptionFlags: %lx\n", Exception->ExceptionFlags);
    DbgPrint("        ExceptionRecord: %lx\n", Exception->ExceptionRecord);
    DbgPrint("       ExceptionAddress: %lx\n", Exception->ExceptionAddress);
    DbgPrint("       NumberParameters: %lx\n", Exception->NumberParameters);
    for (i = 0; i < Exception->NumberParameters; i++)
	DbgPrint("ExceptionInformation[%d]: %lx\n",
		 i, Exception->ExceptionInformation[i]);
    DbgPrint("\n");
    return;
}



VOID
RtlpExceptionRegistrationDump(
    IN PVOID Object,
    IN ULONG Control OPTIONAL
    )
/*++

Routine Description:

    This function dumps the contents of an exception registration record,
    unless Object == NULL, in which case it dumps the entire registration
    chain.

    Currently, it does not dump floating point context.

Arguments:

    Object - Address of the record to dump.

    Control - Ignored, here so we look like a standard dump procedure.

Return Value:

    none

--*/

{
    PEXCEPTION_REGISTRATION_RECORD RegistrationPointer;

    RegistrationPointer = (PEXCEPTION_REGISTRATION_RECORD)Object;

    if (RegistrationPointer != EXCEPTION_CHAIN_END) {
	DbgPrint("Record @ %lx\n", (ULONG)RegistrationPointer);
	DbgPrint("   Next: %lx\n", RegistrationPointer->Next);
	DbgPrint("Handler: %lx\n", RegistrationPointer->Handler);
	DbgPrint("\n");
    } else {
	RegistrationPointer = RtlpGetRegistrationHead();

	while (RegistrationPointer != EXCEPTION_CHAIN_END) {
	    DbgPrint("Record @ %lx\n", (ULONG)RegistrationPointer);
	    DbgPrint("   Next: %lx\n", RegistrationPointer->Next);
	    DbgPrint("Handler: %lx\n", RegistrationPointer->Handler);
	    DbgPrint("\n");
	}
    }
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\rtl\i386\stkwalk.asm ===
TITLE   "Capture Stack Back Trace"
;++
;
; Copyright (c) 1989  Microsoft Corporation
;
; Module Name:
;
;    stkwalk.asm
;
; Abstract:
;
;    This module implements the routine RtlCaptureStackBackTrace.  It will
;    walker the stack back trace and capture a portion of it.
;
; Author:
;
;    Steve Wood (stevewo) 29-Jan-1992
;
; Environment:
;
;    Any mode.
;
; Revision History:
;
;--

.386p
        .xlist
include ks386.inc
include callconv.inc            ; calling convention macros
        .list

IFDEF NTOS_KERNEL_RUNTIME
        EXTRNP  _MmIsAddressValid,1
        EXTRNP  _KeGetCurrentIrql,0
        EXTRN   _KiPCR:DWORD
ENDIF

_TEXT   SEGMENT DWORD PUBLIC 'CODE'
        ASSUME  DS:FLAT, ES:FLAT, SS:NOTHING, FS:NOTHING, GS:NOTHING

IFDEF NTOS_KERNEL_RUNTIME
        page ,132
        subttl  "RtlGetCallersAddress"
;++
;
; VOID
; RtlGetCallersAddress(
;    OUT PVOID *CallersAddress,
;    OUT PVOID *CallersCaller
;    )
;
; Routine Description:
;
;    This routine walks up the stack frames, capturing the first two return
;    addresses
;
;
; Arguments:
;
;    OUT PVOID CallersAddress - returns callers return address
;    OUT PVOID CallersCaller - returns callers caller return address
;
; Return Value:
;
;     None.
;
;
;--
RgcaCallersAddress      EQU [ebp+08h]
RgcaCallersCaller       EQU [ebp+0Ch]
cPublicProc _RtlGetCallersAddress ,2
        push    ebp
        mov     ebp, esp
        push    ebx                     ; Save EBX
        push    esi                     ; Save ESI
        push    edi                     ; Save EDI
        mov     eax, PCR[PcPrcbData+PbCurrentThread] ; (eax)->current thread
        push    ThStackBase[eax]        ;  RcbtStackBase = base of kernel stack
        push    esp                     ; Save current esp for handler
        push    offset RgcaFault        ; Address of handler
        push    PCR[PcExceptionList]    ; Save current list head
        mov     PCR[PcExceptionList],esp; Put us on list
        xor     esi,esi                 ; (ESI) will contain callers return address
        xor     edi,edi                 ; (EDI) will contain callers caller return address

        mov     edx,ebp                 ; (EDX) = current frame pointer
        mov     edx,[edx]               ; (EDX) = callers frame pointer
        cmp     edx,ebp                 ; If outside stack limits,
        jbe     short RgcaExit          ; ...then exit
        cmp     edx,RcbtStackBase
        jae     short RgcaCheckForDpcStack
        cmp     edx,ThStackLimit[eax]
        jb      short RgcaCheckForDpcStack

Rgca20:
        mov     esi,[edx].4             ; Get callers return address

        mov     edx,[edx]               ; (EDX) = callers caller frame pointer
        cmp     edx,ebp                 ; If outside stack limits,
        jbe     short RgcaExit          ; ...then exit
        cmp     edx,RcbtStackBase
        jae     short RgcaExit

        mov     edi,[edx].4             ; Get callers caller return address
RgcaExit:
        mov     ecx,RgcaCallersAddress
        jecxz   @F
        mov     [ecx],esi
@@:
        mov     ecx,RgcaCallersCaller
        jecxz   @F
        mov     [ecx],edi
@@:
        pop     PCR[PcExceptionList]    ; Restore Exception list
        pop     edi                     ; discard handler address
        pop     edi                     ; discard saved esp
        pop     edi                     ; discard RcbtStackBase
        pop     edi                     ; Restore EDI
        pop     esi                     ; Restore ESI
        pop     ebx                     ; Restore EBX
        pop     ebp
        stdRET  _RtlGetCallersAddress

;
; We may be executing on the DPC stack for this processor which is ok.
;

RgcaCheckForDpcStack:

        ; Check if DPC active.

        cmp     dword ptr PCR[PcPrcbData+PbDpcRoutineActive], 0
        mov     eax, PCR[PcPrcbData+PbDpcStack]
        je      short RgcaExit          ; if no DPC active, must be bad stack.

        ; Check if address if below DPC stack upper bound
        ;
        ; Note: If we ARE on the DPC stack, we need to adjust this funtion's
        ; idea of the initial stack pointer so it will succeed the check at
        ; the next level.   We do not support transitioning across stacks in
        ; this function.

        cmp     edx, eax
        mov     RcbtStackBase, eax
        jae     short RgcaExit          ; exit if above upper bound

        ; Check if below DPC stack lower bound.

        sub     eax, KERNEL_STACK_SIZE
        cmp     edx, eax
        ja      short Rgca20            ; jif on DPC stack
        jmp     short RgcaExit          ; not on DPC stack.


RgcaFault:
;
; Cheap and sleazy exception handler.  This will not unwind properly, which
; is ok because this function is a leaf except for calling KeGetCurrentIrql,
; which has no exception handler.
;
        mov     eax,[esp+0Ch]           ; (esp)->Context
        mov     edi,CsEdi[eax]          ; restore buffer pointer
        mov     esp,[esp+8]             ; (esp)->ExceptionList
        jmp     RgcaExit                ;
stdENDP _RtlGetCallersAddress
ENDIF

IFDEF NTOS_KERNEL_RUNTIME
RcbtStackBase        EQU [ebp-10h]
ENDIF

_TEXT   ends
        end
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\rtl\i386\xcptmisc.asm ===
title   "Miscellaneous Exception Handling"
;++
;
; Copyright (c) 1989  Microsoft Corporation
;
; Module Name:
;
;    xcptmisc.asm
;
; Abstract:
;
;    This module implements miscellaneous routines that are required to
;    support exception handling. Functions are provided to call an exception
;    handler for an exception, call an exception handler for unwinding, get
;    the caller's stack pointer, get the caller's frame pointer, get the
;    caller's floating status, get the caller's processor state, get the
;    caller's extended processor status, and get the current stack limits.
;
; Author:
;
;    David N. Cutler (davec) 14-Aug-1989
;
; Environment:
;
;    Any mode.
;
; Revision History:
;
;   6 April 90  bryanwi
;
;           386 version created
;
;--
.386p

        .xlist
include ks386.inc
include callconv.inc            ; calling convention macros
        .list

;
; Unwind flags.
;

Unwind  equ EXCEPTION_UNWINDING OR EXCEPTION_EXIT_UNWIND

_TEXT   SEGMENT DWORD PUBLIC 'CODE'
        ASSUME  DS:FLAT, ES:FLAT, SS:NOTHING, FS:NOTHING, GS:NOTHING

        page
        subttl  "Execute Handler for Exception"
;++
;
; EXCEPTION_DISPOSITION
; RtlpExecuteHandlerForException (
;    IN PEXCEPTION_RECORD ExceptionRecord,
;    IN PVOID EstablisherFrame,
;    IN OUT PCONTEXT ContextRecord,
;    IN OUT PVOID DispatcherContext,
;    IN PEXCEPTION_ROUTINE ExceptionRoutine
;    )
;
; Routine Description:
;
;    This function allocates a call frame, stores the handler address and
;    establisher frame pointer in the frame, establishes an exception
;    handler, and then calls the specified exception handler as an exception
;    handler. If a nested exception occurs, then the exception handler of
;    of this function is called and the handler address and establisher
;    frame pointer are returned to the exception dispatcher via the dispatcher
;    context parameter. If control is returned to this routine, then the
;    frame is deallocated and the disposition status is returned to the
;    exception dispatcher.
;
; Arguments:
;
;    ExceptionRecord (ebp+8) - Supplies a pointer to an exception record.
;
;    EstablisherFrame (ebp+12) - Supplies the frame pointer of the establisher
;       of the exception handler that is to be called.
;
;    ContextRecord (ebp+16) - Supplies a pointer to a context record.
;
;    DispatcherContext (ebp+20) - Supplies a pointer to the dispatcher context
;       record.
;
;    ExceptionRoutine (ebp+24) - supplies a pointer to the exception handler
;       that is to be called.
;
; Return Value:
;
;    The disposition value returned by the specified exception handler is
;    returned as the function value.
;
;--

cPublicProc _RtlpExecuteHandlerForException,5

        mov     edx,offset FLAT:ExceptionHandler    ; Set who to register
        jmp     ExecuteHandler                      ; jump to common code

stdENDP _RtlpExecuteHandlerForException


        page
        subttl  "Execute Handler for Unwind"
;++
;
; EXCEPTION_DISPOSITION
; RtlpExecuteHandlerForUnwind (
;    IN PEXCEPTION_RECORD ExceptionRecord,
;    IN PVOID EstablisherFrame,
;    IN OUT PCONTEXT ContextRecord,
;    IN OUT PVOID DispatcherContext,
;    IN PEXCEPTION_ROUTINE ExceptionRoutine
;    )
;
; Routine Description:
;
;    This function allocates a call frame, stores the handler address and
;    establisher frame pointer in the frame, establishes an exception
;    handler, and then calls the specified exception handler as an unwind
;    handler. If a collided unwind occurs, then the exception handler of
;    of this function is called and the handler address and establisher
;    frame pointer are returned to the unwind dispatcher via the dispatcher
;    context parameter. If control is returned to this routine, then the
;    frame is deallocated and the disposition status is returned to the
;    unwind dispatcher.
;
; Arguments:
;
;    ExceptionRecord (ebp+8) - Supplies a pointer to an exception record.
;
;    EstablisherFrame (ebp+12) - Supplies the frame pointer of the establisher
;       of the exception handler that is to be called.
;
;    ContextRecord (ebp+16) - Supplies a pointer to a context record.
;
;    DispatcherContext (ebp+20) - Supplies a pointer to the dispatcher context
;       record.
;
;    ExceptionRoutine (ebp+24) - supplies a pointer to the exception handler
;       that is to be called.
;
; Return Value:
;
;    The disposition value returned by the specified exception handler is
;    returned as the function value.
;
;--

cPublicProc _RtlpExecuteHandlerForUnwind    ,5

        mov     edx,offset FLAT:UnwindHandler

;;  N.B. - FALL into ExecuteHandler

stdENDP _RtlpExecuteHandlerForUnwind



;
;   ExecuteHandler is the common tail for RtlpExecuteHandlerForException
;   and RtlpExecuteHandlerForUnwind.
;
;   (edx) = handler (Exception or Unwind) address
;


ExceptionRecord     equ [ebp+8]
EstablisherFrame    equ [ebp+12]
ContextRecord       equ [ebp+16]
DispatcherContext   equ [ebp+20]
ExceptionRoutine    equ [ebp+24]


cPublicProc   ExecuteHandler,5

        push    ebp
        mov     ebp,esp

        push    EstablisherFrame        ; Save context of exception handler
                                        ; that we're about to call.

    .errnz   ErrHandler-4
        push    edx                     ; Set Handler address

    .errnz   ErrNext-0
        push    fs:PcExceptionList                      ; Set next pointer


        mov     fs:PcExceptionList,esp                  ; Link us on

; Call the specified exception handler.

        push    DispatcherContext
        push    ContextRecord
        push    EstablisherFrame
        push    ExceptionRecord

        mov     ecx,ExceptionRoutine
        call    ecx
        mov     esp,fs:PcExceptionList

; Don't clean stack here, code in front of ret will blow it off anyway

; Disposition is in eax, so all we do is deregister handler and return

    .errnz  ErrNext-0
        pop     fs:PcExceptionList

        mov     esp,ebp
        pop     ebp
        stdRET  ExecuteHandler

stdENDP ExecuteHandler

        page
        subttl  "Local Exception Handler"
;++
;
; EXCEPTION_DISPOSITION
; ExceptionHandler (
;    IN PEXCEPTION_RECORD ExceptionRecord,
;    IN PVOID EstablisherFrame,
;    IN OUT PCONTEXT ContextRecord,
;    IN OUT PVOID DispatcherContext
;    )
;
; Routine Description:
;
;    This function is called when a nested exception occurs. Its function
;    is to retrieve the establisher frame pointer and handler address from
;    its establisher's call frame, store this information in the dispatcher
;    context record, and return a disposition value of nested exception.
;
; Arguments:
;
;    ExceptionRecord (exp+4) - Supplies a pointer to an exception record.
;
;    EstablisherFrame (esp+8) - Supplies the frame pointer of the establisher
;       of this exception handler.
;
;    ContextRecord (esp+12) - Supplies a pointer to a context record.
;
;    DispatcherContext (esp+16) - Supplies a pointer to the dispatcher context
;       record.
;
; Return Value:
;
;    A disposition value ExceptionNestedException is returned if an unwind
;    is not in progress. Otherwise a value of ExceptionContinueSearch is
;    returned.
;
;--

stdPROC   ExceptionHandler,4

        mov     ecx,dword ptr [esp+4]           ; (ecx) -> ExceptionRecord
        test    dword ptr [ecx.ErExceptionFlags],Unwind
        mov     eax,ExceptionContinueSearch     ; Assume unwind
        jnz     eh10                            ; unwind, go return

;
; Unwind is not in progress - return nested exception disposition.
;

        mov     ecx,[esp+8]             ; (ecx) -> EstablisherFrame
        mov     edx,[esp+16]            ; (edx) -> DispatcherContext
        mov     eax,[ecx+8]             ; (eax) -> EstablisherFrame for the
                                        ;          handler active when we
                                        ;          nested.
        mov     [edx],eax               ; Set DispatcherContext field.
        mov     eax,ExceptionNestedException

eh10:   stdRET    ExceptionHandler

stdENDP ExceptionHandler

        page
        subttl  "Local Unwind Handler"
;++
;
; EXCEPTION_DISPOSITION
; UnwindHandler (
;    IN PEXCEPTION_RECORD ExceptionRecord,
;    IN PVOID EstablisherFrame,
;    IN OUT PCONTEXT ContextRecord,
;    IN OUT PVOID DispatcherContext
;    )
;
; Routine Description:
;
;    This function is called when a collided unwind occurs. Its function
;    is to retrieve the establisher frame pointer and handler address from
;    its establisher's call frame, store this information in the dispatcher
;    context record, and return a disposition value of nested unwind.
;
; Arguments:
;
;    ExceptionRecord (esp+4) - Supplies a pointer to an exception record.
;
;    EstablisherFrame (esp+8) - Supplies the frame pointer of the establisher
;       of this exception handler.
;
;    ContextRecord (esp+12) - Supplies a pointer to a context record.
;
;    DispatcherContext (esp+16) - Supplies a pointer to the dispatcher context
;       record.
;
; Return Value:
;
;    A disposition value ExceptionCollidedUnwind is returned if an unwind is
;    in progress. Otherwise a value of ExceptionContinueSearch is returned.
;
;--

stdPROC   UnwindHandler,4

        mov     ecx,dword ptr [esp+4]           ; (ecx) -> ExceptionRecord
        test    dword ptr [ecx.ErExceptionFlags],Unwind
        mov     eax,ExceptionContinueSearch     ; Assume NOT unwind
        jz      uh10                            ; not unwind, go return


;
; Unwind is in progress - return collided unwind disposition.
;

        mov     ecx,[esp+8]             ; (ecx) -> EstablisherFrame
        mov     edx,[esp+16]            ; (edx) -> DispatcherContext
        mov     eax,[ecx+8]             ; (eax) -> EstablisherFrame for the
                                        ;          handler active when we
                                        ;          nested.
        mov     [edx],eax               ; Set DispatcherContext field.
        mov     eax,ExceptionCollidedUnwind

uh10:   stdRET    UnwindHandler

stdENDP UnwindHandler

        page
        subttl  "Unlink Exception Registration Record & Handler"
;++
;
; VOID
; RtlpUnlinkHandler(PEXCEPTION_REGISTRATION_RECORD UnlinkPointer)
;
; Routine Description:
;
;   This function removes the specified exception registration record
;   (and thus the relevent handler) from the exception traversal
;   chain.
;
; Arguments:
;
;    UnlinkPointer (esp+4) - Address of registration record to unlink.
;
; Return Value:
;
;    The caller's return address.
;
;--

cPublicProc _RtlpUnlinkHandler ,1

        mov     ecx,dword ptr [esp+4]
        mov     ecx,[ecx.ErrNext]
        mov     fs:PcExceptionList,ecx
        stdRET    _RtlpUnlinkHandler

stdENDP _RtlpUnlinkHandler

        page
        subttl  "Capture Context"
;++
;
; VOID
; RtlCaptureContext (PCONTEXT ContextRecord)
; RtlpCaptureContext (PCONTEXT ContextRecord)
;
; Routine Description:
;
;   This fucntion fills in the specified context record with the
;   current state of the machine, except that the values of EBP
;   and ESP are computed to be those of the caller's caller.
;
;   N.B.  This function assumes it is called from a 'C' procedure with
;         the old ebp at [ebp], the return address at [ebp+4], and
;         old esp = ebp + 8.
;
;         Certain 'C' optimizations may cause this to not be true.
;
;   N.B.  This function does NOT adjust ESP to pop the arguments off
;         the caller's stack.  In other words, it provides a __cdecl ESP,
;         NOT a __stdcall ESP.  This is mainly because we can't figure
;         out how many arguments the caller takes.
;
;   N.B.  Floating point state is NOT captured.
;
;   RtlpCaptureContext does not capture volitales.
;   RtlCaptureContext captures volitales.
;
; Arguments:
;
;    ContextRecord  (esp+4) - Address of context record to fill in.
;
; Return Value:
;
;    The caller's return address.
;
;--

cPublicProc _RtlCaptureContext ,1

        push    ebx
        mov     ebx,[esp+8]         ; (ebx) -> ContextRecord

        mov     dword ptr [ebx.CsEax],eax
        mov     dword ptr [ebx.CsEcx],ecx
        mov     dword ptr [ebx.CsEdx],edx
        mov     eax, [esp]
        mov     dword ptr [ebx.CsEbx],eax

        mov     dword ptr [ebx.CsEsi],esi
        mov     dword ptr [ebx.CsEdi],edi
        jmp     RtlpCaptureCommon
stdENDP _RtlCaptureContext

cPublicProc _RtlpCaptureContext ,1

        push    ebx
        mov     ebx,[esp+8]         ; (ebx) -> ContextRecord

        mov     dword ptr [ebx.CsEax],0
        mov     dword ptr [ebx.CsEcx],0
        mov     dword ptr [ebx.CsEdx],0
        mov     dword ptr [ebx.CsEbx],0

        mov     dword ptr [ebx.CsEsi],0
        mov     dword ptr [ebx.CsEdi],0

RtlpCaptureCommon:
        mov     [ebx.CsSegCs],cs
        mov     [ebx.CsSegSs],ss

        pushfd
        pop     [ebx.CsEflags]

        mov     eax,[ebp+4]
        mov     [ebx.CsEip],eax

        mov     eax,[ebp]
        mov     [ebx.CsEbp],eax

        lea     eax,[ebp+8]
        mov     [ebx.CsEsp],eax

        pop     ebx
        stdRET    _RtlpCaptureContext

stdENDP _RtlpCaptureContext

        page
        subttl  "Capture Context (private)"
;++
;
; VOID
; RtlCaptureContext (PCONTEXT ContextRecord)
;
; Routine Description:
;
;   This function is similiar too RtlpCaptureContext expect that
;   volitales are captured as well.
;
;   This fucntion fills in the specified context record with the
;   current state of the machine, except that the values of EBP
;   and ESP are computed to be those of the caller's caller.
;
;   N.B.  This function does NOT adjust ESP to pop the arguments off
;         the caller's stack.  In other words, it provides a __cdecl ESP,
;         NOT a __stdcall ESP.  This is mainly because we can't figure
;         out how many arguments the caller takes.
;
;   N.B.  Floating point state is NOT captured.
;
; Arguments:
;
;    ContextRecord  (esp+4) - Address of context record to fill in.
;
; Return Value:
;
;    The caller's return address.
;
;--


ifndef WX86_i386
        page
        subttl  "Get Stack Limits"
;++
;
; VOID
; RtlpGetStackLimits (
;    OUT PULONG LowLimit,
;    OUT PULONG HighLimit
;    )
;
; Routine Description:
;
;    This function returns the current stack limits based on the current
;    processor mode.
;
;    On the 386 we always store the stack limits in the PCR, and address
;    both PCR and TEB the same way, so this code is mode independent.
;
; Arguments:
;
;    LowLimit (esp+4) - Supplies a pointer to a variable that is to receive
;       the low limit of the stack.
;
;    HighLimit (esp+8) - Supplies a pointer to a variable that is to receive
;       the high limit of the stack.
;
; Return Value:
;
;    None.
;
;--

cPublicProc _RtlpGetStackLimits ,2
;cPublicFpo 2,0

        mov     eax,fs:PcStackLimit
        mov     ecx,[esp+4]
        mov     [ecx],eax               ; Save low limit

        mov     eax,fs:PcStackBase
        mov     ecx,[esp+8]
        mov     [ecx],eax               ; Save high limit

        stdRET    _RtlpGetStackLimits

stdENDP _RtlpGetStackLimits

endif
        page
        subttl  "Get Exception Registration List Head"
;++
;
;   PVOID
;   RtlpGetRegistrationHead()
;
;   Routine Description:
;
;       This function returns the address of the first Exception
;       registration record for the current context.
;
;   Arguments:
;
;       None.
;
;   Return Value:
;
;       The address of the first registration record.
;
;--

cPublicProc _RtlpGetRegistrationHead    ,0
;cPublicFpo 0,0

        mov     eax,fs:PcExceptionList
        stdRET    _RtlpGetRegistrationHead

stdENDP _RtlpGetRegistrationHead

        page
        subttl  "Get Return Address"
;++
;
;   PVOID
;   RtlpGetReturnAddress()
;
;   Routine Description:
;
;       This function returns the caller's return address.  It assumes
;       that a standard 'C' entry sequence has been used, be warned
;       that certain optimizations might invalidate that assumption.
;
;   Arguments:
;
;       None.
;
;   Return Value:
;
;       The address of the first registration record.
;
;--

cPublicProc _RtlpGetReturnAddress ,0
;cPublicFpo 0,0

        mov     eax,[ebp+4]
        stdRET    _RtlpGetReturnAddress

stdENDP _RtlpGetReturnAddress
_TEXT   ends
        end
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\rtl\up\makefile.inc ===
!ifdef PASS0ONLY
.SUFFIXES: .c
!endif

obj\$(TARGET_DIRECTORY)\generr.obj: ..\generr.c

..\error.h: obj\$(TARGET_DIRECTORY)\generr.obj
    generr $? $@
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\rtl\i386\xsum.asm ===
title  "Compute Checksum"

;/*++
;
; Copyright (c) 1992  Microsoft Corporation
;
; Module Name:
;
;    cksy.asm
;
; Abstract:
;
;    This module implements a function to compute the checksum of a buffer.
;
; Author:
;
;    David N. Cutler (davec) 27-Jan-1992
;
; Revision History:
;
;     Who         When        What
;     --------    --------    ----------------------------------------------
;     mikeab      01-22-94    Pentium optimization
;
; Environment:
;
;    Any mode.
;
; Revision History:
;
;--*/

LOOP_UNROLLING_BITS     equ     5
LOOP_UNROLLING          equ     (1 SHL LOOP_UNROLLING_BITS)

        .386
        .model  small,c

        assume cs:FLAT,ds:FLAT,es:FLAT,ss:FLAT
        assume fs:nothing,gs:nothing

        .xlist
        include callconv.inc
        include ks386.inc
        .list

        .code

;++
;
; ULONG
; tcpxsum(
;   IN ULONG cksum,
;   IN PUCHAR buf,
;   IN ULONG len
;   )
;
; Routine Description:
;
;    This function computes the checksum of the specified buffer.
;
; Arguments:
;
;    cksum - Suppiles the initial checksum value, in 16-bit form,
;            with the high word set to 0.
;
;    buf - Supplies a pointer to the buffer to the checksum buffer.
;
;    len - Supplies the length of the buffer in bytes.
;
; Return Value:
;
;    The computed checksum in 32-bit two-partial-accumulators form, added to
;    the initial checksum, is returned as the function value.
;
;--

cksum   equ     12                      ; stack offset to initial checksum
buf     equ     16                      ; stack offset to source address
len     equ     20                      ; stack offset to length in words

to_checksum_last_word:
        jmp     checksum_last_word

to_checksum_done:
        jmp     checksum_done

to_checksum_dword_loop_done:
        jmp     checksum_dword_loop_done

cPublicProc tcpxsum,3

        push    ebx                     ; save nonvolatile register
        push    esi                     ; save nonvolatile register

        mov     ecx,[esp + len]         ; get length in bytes
        sub     eax,eax                 ; clear computed checksum
        test    ecx,ecx                 ; any bytes to checksum at all?
        jz      short to_checksum_done  ; no bytes to checksum

;
; if the checksum buffer is not word aligned, then add the first byte of
; the buffer to the input checksum.
;

        mov     esi,[esp + buf]         ; get source address
        sub     edx,edx                 ; set up to load word into EDX below
        test    esi,1                   ; check if buffer word aligned
        jz      short checksum_word_aligned ; if zf, buffer word aligned
        mov     ah,[esi]                ; get first byte (we know we'll have
                                        ;  to swap at the end)
        inc     esi                     ; increment buffer address
        dec     ecx                     ; decrement number of bytes
        jz      short to_checksum_done  ; if zf set, no more bytes

;
; If the buffer is not an even number of of bytes, then initialize
; the computed checksum with the last byte of the buffer.
;

checksum_word_aligned:                  ;
        shr     ecx,1                   ; convert to word count
        jnc     short checksum_start    ; if nc, even number of bytes
        mov     al,[esi+ecx*2]          ; initialize the computed checksum
        jz      short to_checksum_done  ; if zf set, no more bytes

;
; Compute checksum in large blocks of dwords, with one partial word up front if
; necessary to get dword alignment, and another partial word at the end if
; needed.
;

;
; Compute checksum on the leading word, if that's necessary to get dword
; alignment.
;

checksum_start:                         ;
        test    esi,02h                 ; check if source dword aligned
        jz      short checksum_dword_aligned ; source is already dword aligned
        mov     dx,[esi]                ; get first word to checksum
        add     esi,2                   ; update source address
        add     eax,edx                 ; update partial checksum
                                        ;  (no carry is possible, because EAX
                                        ;  and EDX are both 16-bit values)
        dec     ecx                     ; count off this word (zero case gets
                                        ;  picked up below)

;
; Checksum as many words as possible by processing a dword at a time.
;

checksum_dword_aligned:
        push    ecx                     ; so we can tell if there's a trailing
                                        ;  word later
        shr     ecx,1                   ; # of dwords to checksum
        jz      short to_checksum_last_word ; no dwords to checksum

        mov     edx,[esi]               ; preload the first dword
        add     esi,4                   ; point to the next dword
        dec     ecx                     ; count off the dword we just loaded
        jz      short to_checksum_dword_loop_done
                                        ; skip the loop if that was the only
                                        ;  dword
        mov     ebx,ecx                 ; EBX = # of dwords left to checksum
        add     ecx,LOOP_UNROLLING-1    ; round up loop count
        shr     ecx,LOOP_UNROLLING_BITS ; convert from word count to unrolled
                                        ;  loop count
        and     ebx,LOOP_UNROLLING-1    ; # of partial dwords to do in first
                                        ;  loop
        jz      short checksum_dword_loop ; special-case when no partial loop,
                                          ;  because fixup below doesn't work
                                          ;  in that case (carry flag is
                                          ;  cleared at this point, as required
                                          ;  at loop entry)
        lea     esi,[esi+ebx*4-(LOOP_UNROLLING*4)]
                                        ; adjust buffer pointer back to
                                        ;  compensate for hardwired displacement
                                        ;  at loop entry point
                                        ; ***doesn't change carry flag***
        jmp     loop_entry[ebx*4]       ; enter the loop to do the first,
                                        ; partial iteration, after which we can
                                        ; just do 64-word blocks
                                        ; ***doesn't change carry flag***

checksum_dword_loop:

DEFLAB  macro   pre,suf
pre&suf:
        endm

TEMP=0
        REPT    LOOP_UNROLLING
        deflab  loop_entry_,%TEMP
        adc     eax,edx
        mov     edx,[esi + TEMP]
TEMP=TEMP+4
        ENDM

checksum_dword_loop_end:

        lea     esi,[esi + LOOP_UNROLLING * 4]  ; update source address
                                        ; ***doesn't change carry flag***
        dec     ecx                     ; count off unrolled loop iteration
                                        ; ***doesn't change carry flag***
        jnz     checksum_dword_loop     ; do more blocks

checksum_dword_loop_done label proc
        adc     eax,edx                 ; finish dword checksum
        mov     edx,0                   ; prepare to load trailing word
        adc     eax,edx

;
; Compute checksum on the trailing word, if there is one.
; High word of EDX = 0 at this point
; Carry flag set iff there's a trailing word to do at this point
;

checksum_last_word label proc           ; "proc" so not scoped to function
        pop     ecx                     ; get back word count
        test    ecx,1                   ; is there a trailing word?
        jz      short checksum_done     ; no trailing word
        add     ax,[esi]                ; add in the trailing word
        adc     eax,0                   ;

checksum_done label proc                ; "proc" so not scoped to function
        mov     ecx,eax                 ; fold the checksum to 16 bits
        ror     ecx,16
        add     eax,ecx
        mov     ebx,[esp + buf]
        shr     eax,16
        test    ebx,1                   ; check if buffer word aligned
        jz      short checksum_combine  ; if zf set, buffer word aligned
        ror     ax,8                    ; byte aligned--swap bytes back
checksum_combine label proc             ; "proc" so not scoped to function
        add     ax,word ptr [esp + cksum] ; combine checksums
        pop     esi                     ; restore nonvolatile register
        adc     eax,0                   ;
        pop     ebx                     ; restore nonvolatile register
        stdRET  tcpxsum


REFLAB  macro   pre,suf
        dd      pre&suf
        endm

        align   4
loop_entry      label   dword
        dd      0
TEMP=LOOP_UNROLLING*4
        REPT    LOOP_UNROLLING-1
TEMP=TEMP-4
        reflab  loop_entry_,%TEMP
        ENDM






stdENDP tcpxsum



LOOP_UNROLLING_BITS_XMMI     equ     4
LOOP_UNROLLING_XMMI          equ     (1 SHL LOOP_UNROLLING_BITS_XMMI)

;VRSTEST EQU     0
ifdef VRSTEST
;
; Test tcpxsum_xmmi for correctness.
tcksum   equ     8[ebp]                   ; stack offset to initial checksum
tbuf     equ     12[ebp]                   ; stack offset to source address
tlen     equ     16[ebp]                  ; stack offset to length in words
        align
cPublicProc tcpxsum_xmmi,3
        ;int     3
        push    ebp
        mov     ebp, esp
        push    ebx
        push    esi
        mov     ebx, offset tcpxsum
        mov     esi, offset tcpxsum_xmmi1
        ; Get a "random" number
        .586p
        rdtsc
        .386p
        and     eax, 10H
        jz      old_then_new
        ; Swap which routine is called first
        push    ebx
        mov     ebx, esi
        pop     esi
old_then_new:
        ; Call the first routine
        push    tlen
        push    tbuf
        push    tcksum
        call    ebx
        ; Save the answer
        push    eax
        ; Call the second routine
        push    tlen
        push    tbuf
        push    tcksum
        call    esi
        ; Check the answer
        cmp     eax, [esp]
        jnz     different_xsum
        ; Same answer, we are done
        pop     eax
        pop     esi
        pop     ebx
        pop     ebp
        stdRET  tcpxsum_xmmi
        align
        ; Different answers, need to debug the problem
different_xsum:
        ; Get both checksums onto the stack
        push    eax
        ; ... and bugcheck
        ;EXTRNP  _KeBugCheck,1,IMPORT
        ;stdCall   _KeBugCheck, <0>
again:
        int     3
        jmp     again
stdENDP tcpxsum_xmmi
endif


;++
;
; ULONG
; tcpxsum_xmmi(
;   IN ULONG cksum,
;   IN PUCHAR buf,
;   IN ULONG len
;   )
;
; Routine Description:
;
;    This function computes the checksum of the specified buffer.
;    It uses Processor's prefetch instruction.
;
; Arguments:
;
;    cksum - Suppiles the initial checksum value, in 16-bit form,
;            with the high word set to 0.
;
;    buf - Supplies a pointer to the buffer to the checksum buffer.
;
;    len - Supplies the length of the buffer in bytes.
;
; Return Value:
;
;    The computed checksum in 32-bit two-partial-accumulators form, added to
;    the initial checksum, is returned as the function value.
;
;--

cksum   equ     12                      ; stack offset to initial checksum
buf     equ     16                      ; stack offset to source address
len     equ     20                      ; stack offset to length in words

to_checksum_last_word_xmmi:
        jmp     checksum_last_word_xmmi

to_checksum_done_xmmi:
        jmp     checksum_done_xmmi

to_checksum_dword_loop_done_xmmi:
        jmp     checksum_dword_loop_done_xmmi

ifdef VRSTEST
cPublicProc tcpxsum_xmmi1,3
else
cPublicProc tcpxsum_xmmi,3
endif

        push    ebx                     ; save nonvolatile register
        push    esi                     ; save nonvolatile register

        mov     ecx,[esp + len]         ; get length in bytes
        sub     eax,eax                 ; clear computed checksum
        test    ecx,ecx                 ; any bytes to checksum at all?
        jz      short to_checksum_done_xmmi  ; no bytes to checksum

;
; if the checksum buffer is not word aligned, then add the first byte of
; the buffer to the input checksum.
;

        mov     esi,[esp + buf]         ; get source address
        sub     edx,edx                 ; set up to load word into EDX below
        test    esi,1                   ; check if buffer word aligned
        jz      short checksum_word_aligned ; if zf, buffer word aligned
        mov     ah,[esi]                ; get first byte (we know we'll have
                                        ;  to swap at the end)
        inc     esi                     ; increment buffer address
        dec     ecx                     ; decrement number of bytes
        jz      short to_checksum_done_xmmi  ; if zf set, no more bytes

;
; If the buffer is not an even number of of bytes, then initialize
; the computed checksum with the last byte of the buffer.
;

checksum_word_aligned:                  ;
        shr     ecx,1                   ; convert to word count
        jnc     short checksum_start    ; if nc, even number of bytes
        mov     al,[esi+ecx*2]          ; initialize the computed checksum
        jz      short to_checksum_done_xmmi  ; if zf set, no more bytes

;
; Compute checksum in large blocks of dwords, with one partial word up front if
; necessary to get dword alignment, and another partial word at the end if
; needed.
;

;
; Compute checksum on the leading word, if that's necessary to get dword
; alignment.
;

checksum_start:                         ;
        test    esi,02h                 ; check if source dword aligned
        jz      short checksum_dword_aligned ; source is already dword aligned
        mov     dx,[esi]                ; get first word to checksum
        add     esi,2                   ; update source address
        add     eax,edx                 ; update partial checksum
                                        ;  (no carry is possible, because EAX
                                        ;  and EDX are both 16-bit values)
        dec     ecx                     ; count off this word (zero case gets
                                        ;  picked up below)

;
; Checksum as many words as possible by processing a dword at a time.
;

checksum_dword_aligned:
        push    ecx                     ; so we can tell if there's a trailing
                                        ;  word later
        shr     ecx,1                   ; # of dwords to checksum
        jz      short to_checksum_last_word_xmmi ; no dwords to checksum

        mov     edx,[esi]               ; preload the first dword
        add     esi,4                   ; point to the next dword
        dec     ecx                     ; count off the dword we just loaded
        jz      short to_checksum_dword_loop_done_xmmi
                                        ; skip the loop if that was the only
                                        ;  dword
        mov     ebx,ecx                 ; EBX = # of dwords left to checksum
        add     ecx,LOOP_UNROLLING_XMMI-1    ; round up loop count
        shr     ecx,LOOP_UNROLLING_BITS_XMMI ; convert from word count to unrolled
                                        ;  loop count
        and     ebx,LOOP_UNROLLING_XMMI-1    ; # of partial dwords to do in first
                                        ;  loop
        jz      short checksum_dword_loop ; special-case when no partial loop,
                                          ;  because fixup below doesn't work
                                          ;  in that case (carry flag is
                                          ;  cleared at this point, as required
                                          ;  at loop entry)
        lea     esi,[esi+ebx*4-(LOOP_UNROLLING_XMMI*4)]
                                        ; adjust buffer pointer back to
                                        ;  compensate for hardwired displacement
                                        ;  at loop entry point
                                        ; ***doesn't change carry flag***
        jmp     xmmi_loop_entry[ebx*4]  ; enter the loop to do the first,
                                        ; partial iteration, after which we can
                                        ; just do 64-word blocks
                                        ; ***doesn't change carry flag***

checksum_dword_loop:
        ; prefetch the 32-byte cache line from [esi+0]
        db 0fH
        db 18H
        db 46H
        db 00H

        ; prefetch the 32-byte cache line from [esi+20h]
        db 0fH
        db 18H
        db 46H
        db 20H

        ; prefetch the 32-byte cache line from [esi+40h]
        db 0fH
        db 18H
        db 46H
        db 40H

        ; prefetch the 32-byte cache line from [esi+60h]
        db 0fH
        db 18H
        db 46H
        db 60H

DEFLAB  macro   pre,suf
pre&suf:
        endm

TEMP=0
        REPT    LOOP_UNROLLING_XMMI
        deflab  xmmi_loop_entry_,%TEMP
        adc     eax,edx
        mov     edx,[esi + TEMP]
TEMP=TEMP+4
        ENDM

checksum_dword_loop_end:

        lea     esi,[esi + LOOP_UNROLLING_XMMI * 4]  ; update source address
                                        ; ***doesn't change carry flag***
        dec     ecx                     ; count off unrolled loop iteration
                                        ; ***doesn't change carry flag***
        jnz     checksum_dword_loop     ; do more blocks

checksum_dword_loop_done_xmmi label proc
        adc     eax,edx                 ; finish dword checksum
        mov     edx,0                   ; prepare to load trailing word
        adc     eax,edx

;
; Compute checksum on the trailing word, if there is one.
; High word of EDX = 0 at this point
; Carry flag set iff there's a trailing word to do at this point
;

checksum_last_word_xmmi label proc      ; "proc" so not scoped to function
        pop     ecx                     ; get back word count
        test    ecx,1                   ; is there a trailing word?
        jz      short checksum_done_xmmi; no trailing word
        add     ax,[esi]                ; add in the trailing word
        adc     eax,0                   ;

checksum_done_xmmi label proc           ; "proc" so not scoped to function
        mov     ecx,eax                 ; fold the checksum to 16 bits
        ror     ecx,16
        add     eax,ecx
        mov     ebx,[esp + buf]
        shr     eax,16
        test    ebx,1                   ; check if buffer word aligned
        jz      short checksum_combine_xmmi  ; if zf set, buffer word aligned
        ror     ax,8                    ; byte aligned--swap bytes back
checksum_combine_xmmi label proc        ; "proc" so not scoped to function
        add     ax,word ptr [esp + cksum] ; combine checksums
        pop     esi                     ; restore nonvolatile register
        adc     eax,0                   ;
        pop     ebx                     ; restore nonvolatile register
        stdRET  tcpxsum


REFLAB  macro   pre,suf
        dd      pre&suf
        endm

        align   4
xmmi_loop_entry      label   dword
        dd      0
TEMP=LOOP_UNROLLING_XMMI*4
        REPT    LOOP_UNROLLING_XMMI-1
TEMP=TEMP-4
        reflab  xmmi_loop_entry_,%TEMP
        ENDM

ifdef VRSTEST
stdENDP tcpxsum_xmmi1
else
stdENDP tcpxsum_xmmi
endif

        end
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\udfx\close.c ===
/*++

Copyright (c) 2000-2001  Microsoft Corporation

Module Name:

    close.c

Abstract:

    This module implements routines related to handling IRP_MJ_CLOSE.

--*/

#include "udfx.h"

NTSTATUS
UdfxFsdClose(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    This routine is called by the I/O manager to handle IRP_MJ_CLOSE requests.

Arguments:

    DeviceObject - Specifies the device object that the I/O request is for.

    Irp - Specifies the packet that describes the I/O request.

Return Value:

    Status of operation.

--*/
{
    PUDF_VOLUME_EXTENSION VolumeExtension;
    PIO_STACK_LOCATION IrpSp;
    PFILE_OBJECT FileObject;
    PDIRECTORY_ENUM_CONTEXT DirectoryEnumContext;
    PUDF_FCB Fcb;

    VolumeExtension = (PUDF_VOLUME_EXTENSION)DeviceObject->DeviceExtension;
    IrpSp = IoGetCurrentIrpStackLocation(Irp);
    FileObject = IrpSp->FileObject;

    //
    // Synchronize access to the file control block lists by acquiring the
    // global mutex.
    //

    UdfxAcquireGlobalMutexExclusive();

    //
    // Delete the directory enumeration context if one exists.
    //

    DirectoryEnumContext = (PDIRECTORY_ENUM_CONTEXT)FileObject->FsContext2;

    if (DirectoryEnumContext != NULL) {
        FileObject->FsContext2 = NULL;
        ExFreePool(DirectoryEnumContext);
    }

    //
    // Dereference the file control block associated with the file object.
    //

    Fcb = (PUDF_FCB)FileObject->FsContext;
    FileObject->FsContext = NULL;
    UdfxDereferenceFcb(Fcb);

    //
    // Decrement the file object count for the volume and check if we're ready
    // to delete this device object.
    //

    VolumeExtension->FileObjectCount--;

    if ((VolumeExtension->FileObjectCount == 0) && VolumeExtension->Dismounted) {
        UdfxDeleteVolumeDevice(DeviceObject);
    }

    UdfxReleaseGlobalMutex();

    Irp->IoStatus.Status = STATUS_SUCCESS;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\udfx\devctrl.c ===
/*++

Copyright (c) 2000-2001  Microsoft Corporation

Module Name:

    devctrl.c

Abstract:

    This module implements routines related to handling IRP_MJ_DEVICE_CONTROL.

--*/

#include "udfx.h"

NTSTATUS
UdfxFsdDeviceControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    This routine is called by the I/O manager to handle IRP_MJ_DEVICE_CONTROL
    requests.

Arguments:

    DeviceObject - Specifies the device object that the I/O request is for.

    Irp - Specifies the packet that describes the I/O request.

Return Value:

    Status of operation.

--*/
{
    NTSTATUS status;
    PUDF_VOLUME_EXTENSION VolumeExtension;

    VolumeExtension = (PUDF_VOLUME_EXTENSION)DeviceObject->DeviceExtension;

    //
    // Check if the volume has been dismounted.
    //

    if (VolumeExtension->Dismounted) {
        status = STATUS_VOLUME_DISMOUNTED;
        goto CleanupAndExit;
    }

    //
    // Pass the IRP down to the target device.  We don't need to touch any of
    // the arguments.
    //

    IoSkipCurrentIrpStackLocation(Irp);

    return IoCallDriver(VolumeExtension->TargetDeviceObject, Irp);

CleanupAndExit:
    Irp->IoStatus.Status = status;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\udfx\create.c ===
/*++

Copyright (c) 2000-2001  Microsoft Corporation

Module Name:

    create.c

Abstract:

    This module implements routines related to handling IRP_MJ_CREATE.

--*/

#include "udfx.h"

//
// Structure that wraps up all of the variables related to walk through a
// directory stream.
//

typedef struct _UDF_DIRECTORY_MAPPING {
    PUDF_VOLUME_EXTENSION VolumeExtension;
    PIRP Irp;
    PUDF_FCB DirectoryFcb;
    ULONG LogicalSectorNumber;
    ULONG FileBytesRemaining;
    ULONG CacheBytesRemaining;
    PVOID CacheBuffer;
    PUCHAR CurrentBuffer;
} UDF_DIRECTORY_MAPPING, *PUDF_DIRECTORY_MAPPING;

NTSTATUS
UdfxMapNextDirectorySector(
    IN OUT PUDF_DIRECTORY_MAPPING DirectoryMapping
    )
/*++

Routine Description:

    This routine maps the next directory sector into the cache using the state
    in the supplied mapping structure.

Arguments:

    DirectoryMapping - Specifies a structure that describes the current sector
        mapping and how to map the next sector.

Return Value:

    Status of operation.

--*/
{
    NTSTATUS status;
    PUDF_VOLUME_EXTENSION VolumeExtension;
    PUCHAR LocalCurrentBuffer;
    ULONG LocalCacheBytesRemaining;

    //
    // If another sector has already been mapped, then unmap it now.
    //

    if (DirectoryMapping->CacheBuffer != NULL) {
        FscUnmapBuffer(DirectoryMapping->CacheBuffer);
        DirectoryMapping->CacheBuffer = NULL;
    }

    //
    // If there aren't any more bytes remaining in the directory stream, then
    // bail out now.
    //

    if (DirectoryMapping->FileBytesRemaining == 0) {
        return STATUS_OBJECT_NAME_NOT_FOUND;
    }

    //
    // Map the directory sector into the cache.
    //

    VolumeExtension = DirectoryMapping->VolumeExtension;

    status = UdfxMapLogicalSector(VolumeExtension, DirectoryMapping->Irp,
        DirectoryMapping->LogicalSectorNumber, &DirectoryMapping->CacheBuffer);

    if (!NT_SUCCESS(status)) {
        return status;
    }

    DirectoryMapping->LogicalSectorNumber++;

    LocalCurrentBuffer = (PUCHAR)DirectoryMapping->CacheBuffer;

    //
    // If the data is part of the file descriptor, then adjust the current
    // buffer to point to the real start of the data.  The number of remaining
    // bytes will be adjusted below.
    //

    if (UdfxIsFlagSet(DirectoryMapping->DirectoryFcb->Flags, UDF_FCB_EMBEDDED_DATA)) {
        LocalCurrentBuffer += DirectoryMapping->DirectoryFcb->EmbeddedDataOffset;
        ASSERT(DirectoryMapping->FileBytesRemaining < UDF_CD_SECTOR_SIZE);
    }

    //
    // Compute the number of bytes remaining in the file and in this cache
    // buffer taking into account whether or not this is the last sector of the
    // directory stream.
    //

    if (DirectoryMapping->FileBytesRemaining > UDF_CD_SECTOR_SIZE) {
        LocalCacheBytesRemaining = UDF_CD_SECTOR_SIZE;
        DirectoryMapping->FileBytesRemaining -= UDF_CD_SECTOR_SIZE;
    } else {
        LocalCacheBytesRemaining = DirectoryMapping->FileBytesRemaining;
        DirectoryMapping->FileBytesRemaining = 0;
    }

    //
    // If we're to skip over bytes from a descriptor that crosses a sector
    // boundary, then do that adjustment here.
    //

    LocalCurrentBuffer -= DirectoryMapping->CacheBytesRemaining;
    LocalCacheBytesRemaining += DirectoryMapping->CacheBytesRemaining;

    //
    // Return the results back to the caller.
    //

    DirectoryMapping->CurrentBuffer = LocalCurrentBuffer;
    DirectoryMapping->CacheBytesRemaining = LocalCacheBytesRemaining;

    return STATUS_SUCCESS;
}

VOID
UdfxCopyPartialDirectoryBuffer(
    IN OUT PUDF_DIRECTORY_MAPPING DirectoryMapping,
    OUT PVOID Destination,
    IN PVOID Source,
    IN SIZE_T Length
    )
/*++

Routine Description:

    This routine is a wrapper for RtlCopyMemory that asserts that the arguments
    are valid cache pointers in a debug build and reduces the code bloat in a
    retail build caused by RtlCopyMemory inlining.

Arguments:

    DirectoryMapping - Specifies a structure that describes the current sector
        mapping and how to map the next sector.

    Destination - Specifies the destination of the move.

    Source - Specifies the memory to be copied.

    Length - Specifies the number of bytes to be copied.

Return Value:

    Status of operation.

--*/
{
    ASSERT((PUCHAR)Source >= (PUCHAR)DirectoryMapping->CacheBuffer);
    ASSERT((PUCHAR)Source < (PUCHAR)DirectoryMapping->CacheBuffer +
        UDF_CD_SECTOR_SIZE);
    ASSERT((PUCHAR)Source + Length <= (PUCHAR)DirectoryMapping->CacheBuffer +
        UDF_CD_SECTOR_SIZE);
    ASSERT(Length <= UDF_CD_SECTOR_SIZE);

    RtlCopyMemory(Destination, Source, Length);
}

NTSTATUS
UdfxLookupElementNameInDirectory(
    IN PUDF_VOLUME_EXTENSION VolumeExtension,
    IN PIRP Irp,
    IN PUDF_FCB DirectoryFcb,
    IN POBJECT_STRING ElementName,
    OUT PLONGAD ElementIcb
    )
/*++

Routine Description:

    This routine looks up the supplied file name in the supplied directory
    file control block.

Arguments:

    VolumeExtension - Specifies the extension that the I/O request is for.

    Irp - Specifies the packet that describes the I/O request.

    DirectoryFcb - Specifies the file control block that describes where to
        read the directory stream from.

    ElementName - Specifies the name to search for in the directory.

    ElementIcb - Specifies the buffer to receive the extent of the found file.

Return Value:

    Status of operation.

--*/
{
    NTSTATUS status;
    ULONG ExpectedFileID8BitLength;
    UDF_DIRECTORY_MAPPING DirectoryMapping;
    union {
        NSR_FID FileIdentifierDescriptor;
        UCHAR FileID[256];
    } Stack;
    ULONG PartialStackBufferBytes;
    PNSR_FID FileIdentifierDescriptor;
    ULONG FileIdentifierDescriptorLength;
    ULONG FileIDLength;
    ULONG FileIDStartingOffset;
    PUCHAR FileID;

    ASSERT(UdfxIsFlagSet(DirectoryFcb->Flags, UDF_FCB_DIRECTORY));

    //
    // Compute the expected lengths for a file identifier that will match the
    // supplied file name that we're searching for.  We only care about 8-bit
    // encodings.
    //

    ExpectedFileID8BitLength = sizeof(UCHAR) + ElementName->Length / sizeof(OCHAR);

    //
    // Initialize the directory mapping structure.
    //

    DirectoryMapping.VolumeExtension = VolumeExtension;
    DirectoryMapping.Irp = Irp;
    DirectoryMapping.DirectoryFcb = DirectoryFcb;
    DirectoryMapping.LogicalSectorNumber = DirectoryFcb->AllocationSectorStart;
    DirectoryMapping.FileBytesRemaining = DirectoryFcb->FileSize.LowPart;
    DirectoryMapping.CacheBytesRemaining = 0;
    DirectoryMapping.CacheBuffer = NULL;
    DirectoryMapping.CurrentBuffer = NULL;

    //
    // Process the directory stream.
    //

    for (;;) {

        //
        // If we're out of bytes in the current cache buffer, then map in the
        // next sector.
        //

        if ((LONG)DirectoryMapping.CacheBytesRemaining <= 0) {

            status = UdfxMapNextDirectorySector(&DirectoryMapping);

            if (!NT_SUCCESS(status)) {
                break;
            }
        }

        //
        // If the current cache buffer doesn't have enough bytes to contain a
        // full descriptor, then we'll have to buffer the descriptor on the
        // stack and carefully cross sector boundaries.
        //

        if (DirectoryMapping.CacheBytesRemaining < ISONsrFidConstantSize) {

            //
            // If the bytes from this cache buffer and what remains in the file
            // won't be enough to contain a full descriptor, then bail out now.
            //

            if (DirectoryMapping.CacheBytesRemaining +
                DirectoryMapping.FileBytesRemaining < ISONsrFidConstantSize) {
                status = STATUS_OBJECT_NAME_NOT_FOUND;
                break;
            }

            //
            // Copy the first part of the descriptor to the stack.
            //

            PartialStackBufferBytes = DirectoryMapping.CacheBytesRemaining;

            UdfxCopyPartialDirectoryBuffer(&DirectoryMapping,
                &Stack.FileIdentifierDescriptor, DirectoryMapping.CurrentBuffer,
                PartialStackBufferBytes);

            //
            // Map in the next sector.  Note that on return, the CurrentBuffer
            // CurrentBuffer and CacheBytesRemaining fields have been adjusted
            // adjusted to point back in memory as if the previous sector was
            // virtually mapped in order to make the below math easier.
            //

            status = UdfxMapNextDirectorySector(&DirectoryMapping);

            if (!NT_SUCCESS(status)) {
                break;
            }

            //
            // Copy the last part of the descriptor to the stack.
            //

            UdfxCopyPartialDirectoryBuffer(&DirectoryMapping,
                (PUCHAR)&Stack.FileIdentifierDescriptor + PartialStackBufferBytes,
                DirectoryMapping.CurrentBuffer + PartialStackBufferBytes,
                ISONsrFidConstantSize - PartialStackBufferBytes);

            FileIdentifierDescriptor = &Stack.FileIdentifierDescriptor;

        } else {

            //
            // There's enough bytes in the current buffer to contain at least
            // the header, so point directly into the cache buffer.
            //

            FileIdentifierDescriptor = (PNSR_FID)DirectoryMapping.CurrentBuffer;
        }

        //
        // Validate that the descriptor header looks valid and that its size
        // doesn't exceed a sector as specified by UDF or the number of
        // remaining bytes in the directory stream.  We can't use
        // UdfxVerifyDescriptor here because we don't have a contiguous
        // descriptor in memory.
        //

        FileIdentifierDescriptorLength = ISONsrFidSize(FileIdentifierDescriptor);

        if ((FileIdentifierDescriptor->Destag.Version != DESTAG_VER_CURRENT) ||
            (FileIdentifierDescriptor->Destag.Ident != DESTAG_ID_NSR_FID) ||
            (FileIdentifierDescriptorLength > UDF_CD_SECTOR_SIZE) ||
            (FileIdentifierDescriptorLength > DirectoryMapping.FileBytesRemaining +
                (ULONG)DirectoryMapping.CacheBytesRemaining)) {
            UdfxDbgPrint(("UDFX: file identifier descriptor doesn't verify\n"));
            status = STATUS_DISK_CORRUPT_ERROR;
            break;
        }

        FileIDLength = FileIdentifierDescriptor->FileIDLen;

        //
        // Only bother checking the file identifier descriptor if the file
        // identifier length matches the length of the element name we're
        // looking for.
        //

        if (FileIDLength == ExpectedFileID8BitLength) {

            //
            // Fill in the output buffer now since we'll shortly lose access to
            // the file identifier descriptor.
            //

            *ElementIcb = FileIdentifierDescriptor->Icb;

            //
            // Compute the byte offset of the file identifier.
            //

            FileIDStartingOffset = ISONsrFidConstantSize +
                FileIdentifierDescriptor->ImpUseLen;

            //
            // The below code can cause the current sector buffer to become
            // invalid, so we can no longer safely touch the
            // FileIdentifierDescriptor.
            //

            FileIdentifierDescriptor = NULL;

            //
            // If the current cache buffer doesn't have enough bytes to contain
            // the string, then we'll have to buffer the string on the stack and
            // carefully cross sector boundaries.
            //

            if (DirectoryMapping.CacheBytesRemaining < FileIDStartingOffset +
                FileIDLength) {

                //
                // Check if any of the string is inside the current cache
                // buffer.
                //

                if (DirectoryMapping.CacheBytesRemaining > FileIDStartingOffset) {

                    //
                    // Copy the first part of the string to the stack.
                    //

                    PartialStackBufferBytes =
                        DirectoryMapping.CacheBytesRemaining - FileIDStartingOffset;

                    UdfxCopyPartialDirectoryBuffer(&DirectoryMapping,
                        &Stack.FileID, DirectoryMapping.CurrentBuffer +
                        FileIDStartingOffset, PartialStackBufferBytes);

                } else {

                    PartialStackBufferBytes = 0;
                }

                //
                // Map in the next sector.  Note that on return, the
                // CurrentBuffer and CacheBytesRemaining fields have been
                // adjusted to point back in memory as if the previous sector
                // was virtually mapped in order to make the below math easier.
                //

                status = UdfxMapNextDirectorySector(&DirectoryMapping);

                if (!NT_SUCCESS(status)) {
                    break;
                }

                //
                // Copy the last part of the string to the stack.
                //

                UdfxCopyPartialDirectoryBuffer(&DirectoryMapping,
                    Stack.FileID + PartialStackBufferBytes,
                    DirectoryMapping.CurrentBuffer + FileIDStartingOffset +
                    PartialStackBufferBytes, FileIDLength -
                    PartialStackBufferBytes);

                FileID = Stack.FileID;

            } else {

                //
                // There's enough bytes in the current buffer to contain all of
                // the string, so point directly into the cache.
                //

                FileID = DirectoryMapping.CurrentBuffer + FileIDStartingOffset;
            }

            if (UdfxEqualOSTACS0StringAndObjectString(FileID, FileIDLength,
                ElementName)) {
                status = STATUS_SUCCESS;
                break;
            }
        }

        //
        // Advance to the next descriptor.
        //

        DirectoryMapping.CacheBytesRemaining -= FileIdentifierDescriptorLength;
        DirectoryMapping.CurrentBuffer += FileIdentifierDescriptorLength;
    }

    if (DirectoryMapping.CacheBuffer != NULL) {
        FscUnmapBuffer(DirectoryMapping.CacheBuffer);
    }

    return status;
}

NTSTATUS
UdfxFsdCreate(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    This routine is called by the I/O manager to handle IRP_MJ_CREATE requests.

Arguments:

    DeviceObject - Specifies the device object that the I/O request is for.

    Irp - Specifies the packet that describes the I/O request.

Return Value:

    Status of operation.

--*/
{
    NTSTATUS status;
    PUDF_VOLUME_EXTENSION VolumeExtension;
    PIO_STACK_LOCATION IrpSp;
    ACCESS_MASK DesiredAccess;
    ULONG CreateOptions;
    PFILE_OBJECT FileObject;
    OBJECT_STRING RemainingName;
    PFILE_OBJECT RelatedFileObject;
    ULONG CreateDisposition;
    PUDF_FCB CurrentFcb;
    SHARE_ACCESS ShareAccess;
    BOOLEAN TrailingBackslash;
    BOOLEAN CreateFcbCalled;
    OBJECT_STRING ElementName;
    PUDF_FCB FoundOrNewFcb;
    LONGAD ElementIcb;

    VolumeExtension = (PUDF_VOLUME_EXTENSION)DeviceObject->DeviceExtension;
    IrpSp = IoGetCurrentIrpStackLocation(Irp);
    DesiredAccess = IrpSp->Parameters.Create.DesiredAccess;
    CreateOptions = IrpSp->Parameters.Create.Options;
    FileObject = IrpSp->FileObject;
    RemainingName = *IrpSp->Parameters.Create.RemainingName;
    RelatedFileObject = FileObject->RelatedFileObject;

    //
    // Synchronize access to the file control block lists by acquiring the
    // global mutex.
    //

    UdfxAcquireGlobalMutexExclusive();

    //
    // Check if the volume has been dismounted.
    //

    if (VolumeExtension->Dismounted) {
        status = STATUS_VOLUME_DISMOUNTED;
        goto CleanupAndExit;
    }

    //
    // Don't allow the target directory to be opened.  This is only used by the
    // I/O manager when it wants to rename a file across a directory on the same
    // volume.
    //

    if (UdfxIsFlagSet(IrpSp->Flags, SL_OPEN_TARGET_DIRECTORY)) {
        status = STATUS_ACCESS_DENIED;
        goto CleanupAndExit;
    }

    //
    // Check the desired access mask to make sure that no write rights are being
    // requested.
    //

    if (UdfxIsFlagSet(DesiredAccess, FILE_WRITE_ATTRIBUTES | FILE_WRITE_DATA |
        FILE_WRITE_EA | FILE_ADD_FILE | FILE_ADD_SUBDIRECTORY |
        FILE_APPEND_DATA | FILE_DELETE_CHILD | DELETE | WRITE_DAC)) {
        status = STATUS_ACCESS_DENIED;
        goto CleanupAndExit;
    }

    //
    // Don't allow a file to be opened based on its file ID.
    //

    if (UdfxIsFlagSet(CreateOptions, FILE_OPEN_BY_FILE_ID)) {
        status = STATUS_NOT_IMPLEMENTED;
        goto CleanupAndExit;
    }

    //
    // Verify that the create disposition is for open access only.
    //

    CreateDisposition = (CreateOptions >> 24) & 0xFF;

    if ((CreateDisposition != FILE_OPEN) && (CreateDisposition != FILE_OPEN_IF)) {
        status = STATUS_ACCESS_DENIED;
        goto CleanupAndExit;
    }

    //
    // Determine whether we parse the file name from the root of the volume or
    // from a subdirectory by looking at RelatedFileObject.
    //

    if (RelatedFileObject != NULL) {

        //
        // Grab the file control block out of the related file object.
        //

        CurrentFcb = (PUDF_FCB)RelatedFileObject->FsContext;

        //
        // Verify that the related file object is really a directory object.
        // Note that the file control block could be NULL if the file object was
        // opened as a result of a direct device open in the I/O manager.
        //

        if ((CurrentFcb == NULL) ||
            UdfxIsFlagClear(CurrentFcb->Flags, UDF_FCB_DIRECTORY)) {
            status = STATUS_INVALID_PARAMETER;
            goto CleanupAndExit;
        }

        //
        // Check if we're supposed to open the related directory.
        //

        if (RemainingName.Length == 0) {
            CurrentFcb->ReferenceCount++;
            status = STATUS_SUCCESS;
            goto OpenStartDirectoryFcb;
        }

        //
        // Verify that this is not an absolute path.
        //

        if (RemainingName.Buffer[0] == OBJ_NAME_PATH_SEPARATOR) {
            status = STATUS_OBJECT_NAME_INVALID;
            goto CleanupAndExit;
        }

    } else {

        //
        // Check if we're supposed to open the physical volume.
        //

        if (RemainingName.Length == 0) {

            CurrentFcb = VolumeExtension->VolumeFcb;

            //
            // The caller shouldn't be expecting to see a directory file.
            //

            if (UdfxIsFlagSet(CreateOptions, FILE_DIRECTORY_FILE)) {
                status = STATUS_NOT_A_DIRECTORY;
                goto CleanupAndExit;
            }

            //
            // Physical volume access is always non-cached.  Mark the file
            // object as non-cached so that the I/O manager enforces alignment
            // requirements.
            //

            FileObject->Flags |= FO_NO_INTERMEDIATE_BUFFERING;

            CurrentFcb->ReferenceCount++;
            goto InitializeFileObject;
        }

        //
        // Start searching relative to the root directory.
        //

        CurrentFcb = VolumeExtension->RootDirectoryFcb;

        //
        // Verify that this is an absolute path.
        //

        if (RemainingName.Buffer[0] != OBJ_NAME_PATH_SEPARATOR) {
            status = STATUS_OBJECT_NAME_INVALID;
            goto CleanupAndExit;
        }

        //
        // Check if we're supposed to open the root directory.
        //

        if (RemainingName.Length == sizeof(OCHAR)) {
            CurrentFcb->ReferenceCount++;
            status = STATUS_SUCCESS;
            goto OpenStartDirectoryFcb;
        }
    }

    //
    // Check if the file name ends in a backslash.  If so, strip it off and set
    // a flag so that we can later verify that the target file is a directory.
    //
    // We've already checked for an empty file name or a file name that consists
    // of a single backslash above, so we know that before and after this check
    // that the remaining name will still have some characters in it.
    //

    ASSERT(RemainingName.Length > 0);

    if (RemainingName.Buffer[(RemainingName.Length / sizeof(OCHAR)) - 1] ==
        OBJ_NAME_PATH_SEPARATOR) {
        RemainingName.Length -= sizeof(OCHAR);
        TrailingBackslash = TRUE;
    } else {
        TrailingBackslash = FALSE;
    }

    ASSERT(RemainingName.Length > 0);

    //
    // Process the file name.  At this point, we're only walking the open file
    // control block list.
    //

    for (;;) {

        //
        // Pull off the next element of the file name.
        //

        ObDissectName(RemainingName, &ElementName, &RemainingName);

        //
        // Verify that there aren't multiple backslashes in the name.
        //

        if ((RemainingName.Length != 0) && (RemainingName.Buffer[0] ==
            OBJ_NAME_PATH_SEPARATOR)) {
            status = STATUS_OBJECT_NAME_INVALID;
            break;
        }

        //
        // Check if a file control block already exists for this file name.
        //

        if (!UdfxFindOpenChildFcb(CurrentFcb, &ElementName, &FoundOrNewFcb)) {
            break;
        }

        CurrentFcb = FoundOrNewFcb;

        //
        // If we have consumed the entire name, then the file is already open.
        // Bump up the reference count and skip past the on-disk search loop.
        //

        if (RemainingName.Length == 0) {
            CurrentFcb->ReferenceCount++;
            status = STATUS_SUCCESS;
            goto OpenCurrentFcb;
        }
    }

    //
    // Continue processing the file name.  At this point, we're searching
    // directory streams for the requested file.
    //

    CreateFcbCalled = FALSE;

    do {

        //
        // On the first iteration of the loop, we've already dissected the name
        // we're looking for so don't dissect another piece of the name.
        //

        if (CreateFcbCalled) {

            //
            // Pull off the next element of the file name.
            //

            ObDissectName(RemainingName, &ElementName, &RemainingName);

            //
            // Verify that there aren't multiple backslashes in the name.
            //

            if ((RemainingName.Length != 0) && (RemainingName.Buffer[0] ==
                OBJ_NAME_PATH_SEPARATOR)) {
                status = STATUS_OBJECT_NAME_INVALID;
                break;
            }
        }

        //
        // Lookup the element in the directory.
        //

        status = UdfxLookupElementNameInDirectory(VolumeExtension, Irp,
            CurrentFcb, &ElementName, &ElementIcb);

        if (!NT_SUCCESS(status)) {

            //
            // If we failed to find the element and there's more of a path name
            // to process, then convert the error from "file not found" to
            // "path not found".
            //

            if ((status == STATUS_OBJECT_NAME_NOT_FOUND) &&
                (RemainingName.Length != 0)) {
                status = STATUS_OBJECT_PATH_NOT_FOUND;
            }

            break;
        }

        //
        // Create a file control block for the file we found.
        //

        status = UdfxCreateFcbFromFileEntry(VolumeExtension, Irp, &ElementIcb,
            CurrentFcb, &ElementName, &FoundOrNewFcb);

        if (!NT_SUCCESS(status)) {
            break;
        }

        //
        // If this is the second or greater iteration of this loop, then we want
        // to release the reference to the parent directory from FatxCreateFcb.
        // The parent directory already has a reference count of one from when
        // we created that file control block.
        //

        if (CreateFcbCalled) {
            ASSERT(CurrentFcb->ReferenceCount >= 2);
            CurrentFcb->ReferenceCount--;
        }

        CreateFcbCalled = TRUE;
        CurrentFcb = FoundOrNewFcb;

        //
        // If there's still more of a path name to process, then the file that
        // we found had better be a directory.
        //

        if ((RemainingName.Length != 0) &&
            UdfxIsFlagClear(CurrentFcb->Flags, UDF_FCB_DIRECTORY)) {
            status = STATUS_OBJECT_PATH_NOT_FOUND;
            break;
        }

    } while (RemainingName.Length != 0);

    //
    // If we failed to open the file, then before bailing out, we may need to
    // dereference the current file control block.  If we haven't created any
    // file control blocks, then there's no file control blocks to clean up.
    //

    if (!NT_SUCCESS(status)) {

        if (CreateFcbCalled) {
            UdfxDereferenceFcb(CurrentFcb);
        }

        goto CleanupAndExit;
    }

    //
    // If the caller is expecting to open only a file or directory file, then
    // verify that the file type matches.
    //

OpenCurrentFcb:
    if (UdfxIsFlagSet(CurrentFcb->Flags, UDF_FCB_DIRECTORY)) {

OpenStartDirectoryFcb:
        if (UdfxIsFlagSet(CreateOptions, FILE_NON_DIRECTORY_FILE)) {
            status = STATUS_FILE_IS_A_DIRECTORY;
        }

    } else {

        if (TrailingBackslash ||
            UdfxIsFlagSet(CreateOptions, FILE_DIRECTORY_FILE)) {
            status = STATUS_NOT_A_DIRECTORY;
        }
    }

    //
    // If the resulting file looks acceptable, then fill out the file object
    // and return success.
    //

    if (NT_SUCCESS(status)) {

InitializeFileObject:
        //
        // We don't care about sharing modes for this file system.
        //

        IoSetShareAccess(DesiredAccess, 0, FileObject, &ShareAccess);

        //
        // Fill in the file object with the file control block that we
        // created.
        //

        FileObject->FsContext = CurrentFcb;
        FileObject->FsContext2 = NULL;

        VolumeExtension->FileObjectCount++;

        //
        // Indicate to the caller that we opened the file as opposed to
        // creating or overwriting the file.
        //

        Irp->IoStatus.Information = FILE_OPENED;

        status = STATUS_SUCCESS;
        goto CleanupAndExit;
    }

    //
    // If we reach this point, then we're going to be failing the call so
    // cleanup any file control block we're still holding on to.
    //

    UdfxDereferenceFcb(CurrentFcb);

CleanupAndExit:
    UdfxReleaseGlobalMutex();

    Irp->IoStatus.Status = status;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\udfx\dirctrl.c ===
/*++

Copyright (c) 2000-2001  Microsoft Corporation

Module Name:

    dirctrl.c

Abstract:

    This module implements routines related to handling
    IRP_MJ_DIRECTORY_CONTROL.

--*/

#include "udfx.h"

NTSTATUS
UdfxReadNextFileIdentifierDescriptor(
    IN PUDF_VOLUME_EXTENSION VolumeExtension,
    IN PIRP Irp,
    IN PUDF_FCB DirectoryFcb,
    IN PDIRECTORY_ENUM_CONTEXT DirectoryEnumContext,
    OUT PNSR_FID *ReturnedFileIdentifierDescriptor
    )
/*++

Routine Description:

    This routine returns the file identifier descriptor located at the
    Directory.QueryOffset of the supplied file control block.

Arguments:

    VolumeExtension - Specifies the extension that the I/O request is for.

    Irp - Specifies the packet that describes the I/O request.

    DirectoryFcb - Specifies the file control block that describes where to
        read the directory stream from.

    DirectoryEnumContext - Specifies the directory enumeration context.

    ReturnedFileIdentifierDescriptor - Specifies the buffer to receive the pool
        allocated file identifier descriptor.

Return Value:

    Status of operation.

--*/
{
    NTSTATUS status;
    PVOID CacheBuffer;
    PNSR_FID PoolFileIdentifierDescriptor;
    ULONG FileBytesRemaining;
    ULONG LogicalSectorNumber;
    ULONG CacheBufferOffset;
    ULONG CacheBytesRemaining;
    NSR_FID StackFileIdentifierDescriptor;
    PNSR_FID FileIdentifierDescriptor;
    ULONG FileIdentifierDescriptorLength;

    ASSERT(UdfxIsFlagSet(DirectoryFcb->Flags, UDF_FCB_DIRECTORY));

    *ReturnedFileIdentifierDescriptor = NULL;

    CacheBuffer = NULL;
    PoolFileIdentifierDescriptor = NULL;

    //
    // If there aren't enough bytes left in the directory stream to contain a
    // full descriptor, then stop enumerating files.
    //

    FileBytesRemaining = DirectoryFcb->FileSize.LowPart -
        DirectoryEnumContext->QueryOffset;

    if (FileBytesRemaining < ISONsrFidConstantSize) {
        status = STATUS_END_OF_FILE;
        goto CleanupAndExit;
    }

    //
    // Compute the logical sector number of the current query offset.
    //

    LogicalSectorNumber = DirectoryFcb->AllocationSectorStart +
        (DirectoryEnumContext->QueryOffset >> UDF_CD_SECTOR_SHIFT);

    //
    // Map the directory sector into the cache.
    //

    status = UdfxMapLogicalSector(VolumeExtension, Irp, LogicalSectorNumber,
        &CacheBuffer);

    if (!NT_SUCCESS(status)) {
        goto CleanupAndExit;
    }

    //
    // Compute the current offset into the cache and the number of bytes
    // remaining in this mapping.
    //

    CacheBufferOffset = (DirectoryEnumContext->QueryOffset & UDF_CD_SECTOR_MASK);

    if (UdfxIsFlagSet(DirectoryFcb->Flags, UDF_FCB_EMBEDDED_DATA)) {
        CacheBufferOffset += DirectoryFcb->EmbeddedDataOffset;
    }

    CacheBytesRemaining = UDF_CD_SECTOR_SIZE - CacheBufferOffset;

    //
    // Check if there are enough bytes in the cache buffer to contain a full
    // header.
    //

    if (CacheBytesRemaining < ISONsrFidConstantSize) {

        //
        // Copy the first part of the descriptor to the stack.
        //

        RtlCopyMemory(&StackFileIdentifierDescriptor, (PUCHAR)CacheBuffer +
            CacheBufferOffset, CacheBytesRemaining);

        //
        // Unmap this directory sector.
        //

        FscUnmapBuffer(CacheBuffer);
        CacheBuffer = NULL;

        //
        // Advance to the next directory sector.
        //

        LogicalSectorNumber++;

        //
        // Map the directory sector into the cache.
        //

        status = UdfxMapLogicalSector(VolumeExtension, Irp, LogicalSectorNumber,
            &CacheBuffer);

        if (!NT_SUCCESS(status)) {
            goto CleanupAndExit;
        }

        //
        // Copy the last part of the descriptor to the stack.  We've already
        // validated that the stream has at least enough bytes to contain a
        // header, so this copy is safe.
        //

        RtlCopyMemory((PUCHAR)&StackFileIdentifierDescriptor +
            CacheBytesRemaining, CacheBuffer, ISONsrFidConstantSize -
            CacheBytesRemaining);

        FileIdentifierDescriptor = &StackFileIdentifierDescriptor;

    } else {

        //
        // There's enough bytes in the current buffer to contain at least the
        // header, so point directly into the cache buffer.
        //

        FileIdentifierDescriptor = (PNSR_FID)((PUCHAR)CacheBuffer +
            CacheBufferOffset);
    }

    //
    // Validate that the descriptor header looks valid and that its size
    // doesn't exceed a sector as specified by UDF or the number of
    // remaining bytes in the directory stream.  We can't use
    // UdfxVerifyDescriptor here because we don't have a contiguous
    // descriptor in memory.
    //

    FileIdentifierDescriptorLength = ISONsrFidSize(FileIdentifierDescriptor);

    if ((FileIdentifierDescriptor->Destag.Version != DESTAG_VER_CURRENT) ||
        (FileIdentifierDescriptor->Destag.Ident != DESTAG_ID_NSR_FID) ||
        (FileIdentifierDescriptorLength > UDF_CD_SECTOR_SIZE) ||
        (FileIdentifierDescriptorLength > FileBytesRemaining)) {
        status = STATUS_DISK_CORRUPT_ERROR;
        goto CleanupAndExit;
    }

    //
    // Allocate a buffer to receive the file identifier descriptor.
    //

    PoolFileIdentifierDescriptor = (PNSR_FID)ExAllocatePoolWithTag(
        FileIdentifierDescriptorLength, 'iFxU');

    if (PoolFileIdentifierDescriptor == NULL) {
        status = STATUS_INSUFFICIENT_RESOURCES;
        goto CleanupAndExit;
    }

    //
    // Carefully copy the full file identifier descriptor to the pool block.
    //

    if (FileIdentifierDescriptor == &StackFileIdentifierDescriptor) {

        ASSERT(UdfxIsFlagClear(DirectoryFcb->Flags, UDF_FCB_EMBEDDED_DATA));

        //
        // The descriptor's header crossed a sector boundary.  Copy the first
        // part of the descriptor from the stack copy of the header and then
        // copy the rest from the current cache buffer.
        //

        RtlCopyMemory(PoolFileIdentifierDescriptor, &StackFileIdentifierDescriptor,
            CacheBytesRemaining);

        RtlCopyMemory((PUCHAR)PoolFileIdentifierDescriptor + CacheBytesRemaining,
            CacheBuffer, FileIdentifierDescriptorLength - CacheBytesRemaining);

    } else if (CacheBytesRemaining < FileIdentifierDescriptorLength) {

        ASSERT(UdfxIsFlagClear(DirectoryFcb->Flags, UDF_FCB_EMBEDDED_DATA));

        //
        // Part of the descriptor crosses a sector boundary, so we'll need to
        // copy as much as we can from the current cache buffer and then map in
        // the next sector.
        //

        //
        // Copy the first part of the descriptor to the pool block.
        //

        RtlCopyMemory(PoolFileIdentifierDescriptor, FileIdentifierDescriptor,
            CacheBytesRemaining);

        //
        // Unmap this directory sector.
        //

        FscUnmapBuffer(CacheBuffer);
        CacheBuffer = NULL;

        //
        // Advance to the next directory sector.
        //

        LogicalSectorNumber++;

        //
        // Map the directory sector into the cache.
        //

        status = UdfxMapLogicalSector(VolumeExtension, Irp, LogicalSectorNumber,
            &CacheBuffer);

        if (!NT_SUCCESS(status)) {
            goto CleanupAndExit;
        }

        //
        // Copy the last part of the descriptor to the pool block.
        //

        RtlCopyMemory((PUCHAR)PoolFileIdentifierDescriptor + CacheBytesRemaining,
            CacheBuffer, FileIdentifierDescriptorLength - CacheBytesRemaining);

    } else {

        //
        // The entire descriptor resides in one sector.  Copy it from the
        // current cache buffer.
        //

        RtlCopyMemory(PoolFileIdentifierDescriptor, FileIdentifierDescriptor,
            FileIdentifierDescriptorLength);
    }

    *ReturnedFileIdentifierDescriptor = PoolFileIdentifierDescriptor;
    PoolFileIdentifierDescriptor = NULL;

    status = STATUS_SUCCESS;

CleanupAndExit:
    if (PoolFileIdentifierDescriptor != NULL) {
        ExFreePool(PoolFileIdentifierDescriptor);
    }

    if (CacheBuffer != NULL) {
        FscUnmapBuffer(CacheBuffer);
    }

    return status;
}

NTSTATUS
UdfxFindNextFileIdentifierDescriptor(
    IN PUDF_VOLUME_EXTENSION VolumeExtension,
    IN PIRP Irp,
    IN PUDF_FCB DirectoryFcb,
    IN PDIRECTORY_ENUM_CONTEXT DirectoryEnumContext,
    OUT PNSR_FID *ReturnedFileIdentifierDescriptor,
    OUT POBJECT_STRING FileName
    )
/*++

Routine Description:

    This routine finds the next file identifier descriptor that matches the
    query template specification.

Arguments:

    VolumeExtension - Specifies the extension that the I/O request is for.

    Irp - Specifies the packet that describes the I/O request.

    DirectoryFcb - Specifies the file control block that describes where to
        read the directory stream from.

    DirectoryEnumContext - Specifies the directory enumeration context.

    ReturnedFileIdentifierDescriptor - Specifies the buffer to receive the pool
        allocated file identifier descriptor.

    FileName - Specifies the buffer to receive the pool allocated matching file
        name.

Return Value:

    Status of operation.

--*/
{
    NTSTATUS status;
    PNSR_FID FileIdentifierDescriptor;

    //
    // Process the directory stream until we find a match or run out of
    // file identifier descriptors.
    //

    for (;;) {

        //
        // Read in the next file identifier descriptor.
        //

        status = UdfxReadNextFileIdentifierDescriptor(VolumeExtension, Irp,
            DirectoryFcb, DirectoryEnumContext, &FileIdentifierDescriptor);

        if (!NT_SUCCESS(status)) {
            break;
        }

        //
        // Check if the file identifier descriptor has a name.  This filters out
        // the special directory entry that would map to "..".  We don't bother
        // faking this special name or the "." directory entry.
        //

        if (FileIdentifierDescriptor->FileIDLen != 0) {

            //
            // Convert the string to a Unicode string.
            //

            status = UdfxOSTACS0StringToObjectString(
                (PUCHAR)FileIdentifierDescriptor + ISONsrFidConstantSize +
                FileIdentifierDescriptor->ImpUseLen,
                FileIdentifierDescriptor->FileIDLen, FileName);

            if (!NT_SUCCESS(status)) {
                break;
            }

            //
            // If there's no template file name, then this is an automatic
            // match.  Otherwise, check if the file name matches the template
            // file name criteria.
            //

            if ((DirectoryEnumContext->TemplateFileName.Buffer == NULL) ||
                IoIsNameInExpression(&DirectoryEnumContext->TemplateFileName, FileName)) {
                *ReturnedFileIdentifierDescriptor = FileIdentifierDescriptor;
                return STATUS_SUCCESS;
            }

            ExFreePool(FileName->Buffer);
        }

        //
        // Advance to the offset of the next file identifier descriptor.
        //

        DirectoryEnumContext->QueryOffset += ISONsrFidSize(FileIdentifierDescriptor);

        //
        // Free the memory of the current file identifier descriptor.
        //

        ExFreePool(FileIdentifierDescriptor);
        FileIdentifierDescriptor = NULL;
    }

    if (FileIdentifierDescriptor != NULL) {
        ExFreePool(FileIdentifierDescriptor);
    }

    return status;
}

NTSTATUS
UdfxFsdDirectoryControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    This routine is called by the I/O manager to handle IRP_MJ_DIRECTORY_CONTROL
    requests.

Arguments:

    DeviceObject - Specifies the device object that the I/O request is for.

    Irp - Specifies the packet that describes the I/O request.

Return Value:

    Status of operation.

--*/
{
    NTSTATUS status;
    PUDF_VOLUME_EXTENSION VolumeExtension;
    PIO_STACK_LOCATION IrpSp;
    PFILE_OBJECT FileObject;
    PUDF_FCB DirectoryFcb;
    PDIRECTORY_ENUM_CONTEXT DirectoryEnumContext;
    ULONG FileInformationClass;
    SIZE_T FileInformationBaseLength;
    BOOLEAN InitialQuery;
    POBJECT_STRING TemplateFileName;
    PNSR_FID FileIdentifierDescriptor;
    OBJECT_STRING FileName;
    PFILE_DIRECTORY_INFORMATION DirectoryInformation;
    PUDF_FCB InformationFcb;
    ULONG FileNameBytesToCopy;
    ULONG OutputBytesRemaining;

    VolumeExtension = (PUDF_VOLUME_EXTENSION)DeviceObject->DeviceExtension;
    IrpSp = IoGetCurrentIrpStackLocation(Irp);
    FileObject = IrpSp->FileObject;
    DirectoryFcb = (PUDF_FCB)FileObject->FsContext;

    //
    // Synchronize the creation and access of the directory context control
    // block by acquiring the global mutex.
    //

    UdfxAcquireGlobalMutexExclusive();

    //
    // Ensure that the file object is for a directory.
    //

    if (UdfxIsFlagClear(DirectoryFcb->Flags, UDF_FCB_DIRECTORY)) {
        status = STATUS_INVALID_PARAMETER;
        goto CleanupAndExit;
    }

    //
    // Verify that this is a supported information class.
    //

    FileInformationClass = IrpSp->Parameters.QueryDirectory.FileInformationClass;

    switch (FileInformationClass) {

        case FileDirectoryInformation:
            FileInformationBaseLength = FIELD_OFFSET(FILE_DIRECTORY_INFORMATION,
                FileName[0]);
            break;

        case FileNamesInformation:
            FileInformationBaseLength = FIELD_OFFSET(FILE_NAMES_INFORMATION,
                FileName[0]);
            break;

        default:
            status = STATUS_INVALID_INFO_CLASS;
            goto CleanupAndExit;
    }

    //
    // The query cannot be started relative to a starting index.
    //

    if (UdfxIsFlagSet(IrpSp->Flags, SL_INDEX_SPECIFIED)) {
        status = STATUS_NOT_IMPLEMENTED;
        goto CleanupAndExit;
    }

    //
    // If this is the first query for this directory, then prepare the template
    // file name.
    //

    DirectoryEnumContext = (PDIRECTORY_ENUM_CONTEXT)FileObject->FsContext2;

    if (DirectoryEnumContext == NULL) {

        TemplateFileName = IrpSp->Parameters.QueryDirectory.FileName;

        status = IoCreateDirectoryEnumContext(TemplateFileName,
            &DirectoryEnumContext);

        if (!NT_SUCCESS(status)) {
            goto CleanupAndExit;
        }

        //
        // Connect the directory enumeration context to the file object.
        //

        FileObject->FsContext2 = DirectoryEnumContext;

        InitialQuery = TRUE;

    } else {

        InitialQuery = FALSE;
    }

    //
    // If we're to restart the directory scan, then reset the current index to
    // zero.
    //

    if (UdfxIsFlagSet(IrpSp->Flags, SL_RESTART_SCAN)) {
        DirectoryEnumContext->QueryOffset = 0;
    }

    //
    // Find the next file identifier descriptor that matches our query criteria.
    //
    // On return, Directory.QueryOffset still points at the matching identifier.
    // It's only updated after we're about to successfully return so that no
    // entries are lost in the event of an invalid parameter or pool allocation
    // failure.
    //

    status = UdfxFindNextFileIdentifierDescriptor(VolumeExtension, Irp,
        DirectoryFcb, DirectoryEnumContext, &FileIdentifierDescriptor, &FileName);

    if (NT_SUCCESS(status)) {

        //
        // The I/O manager has already checked that the user's buffer has enough
        // space to contain at least the header.
        //

        ASSERT(IrpSp->Parameters.QueryDirectory.Length >= FileInformationBaseLength);

        //
        // Zero out the header.
        //

        DirectoryInformation = (PFILE_DIRECTORY_INFORMATION)Irp->UserBuffer;
        RtlZeroMemory(DirectoryInformation, FileInformationBaseLength);

        //
        // For FileDirectoryInformation and FileNamesInformation, the
        // FileNameLength field is immediately before the FileName buffer.
        //

        *((PULONG)((PUCHAR)DirectoryInformation + FileInformationBaseLength -
            sizeof(ULONG))) = FileName.Length;

        //
        // If this is a FileDirectoryInformation request, then fill in more
        // information.  We have to go to dig into the file entry descriptor
        // to get the information we need, so we'll construct a file control
        // block to get the attributes.
        //

        if (FileInformationClass == FileDirectoryInformation) {

            status = UdfxCreateFcbFromFileEntry(VolumeExtension, Irp,
                &FileIdentifierDescriptor->Icb, NULL, NULL, &InformationFcb);

            if (NT_SUCCESS(status)) {

                DirectoryInformation->EndOfFile =
                DirectoryInformation->AllocationSize =
                    InformationFcb->FileSize;

                DirectoryInformation->CreationTime =
                DirectoryInformation->LastAccessTime =
                DirectoryInformation->LastWriteTime =
                DirectoryInformation->ChangeTime =
                    UdfxUdfTimestampToTime(&InformationFcb->ModifyTime);

                if (UdfxIsFlagSet(InformationFcb->Flags, UDF_FCB_DIRECTORY)) {
                    DirectoryInformation->FileAttributes =
                        FILE_ATTRIBUTE_READONLY | FILE_ATTRIBUTE_DIRECTORY;
                } else {
                    DirectoryInformation->FileAttributes =
                        FILE_ATTRIBUTE_READONLY;
                }

                UdfxDereferenceFcb(InformationFcb);
            }
        }

        //
        // If nothing has gone wrong yet, then copy the file name to the user's
        // buffer.
        //

        if (NT_SUCCESS(status)) {

            OutputBytesRemaining =
                ALIGN_DOWN(IrpSp->Parameters.QueryDirectory.Length -
                FileInformationBaseLength, sizeof(OCHAR));
            FileNameBytesToCopy = FileName.Length;

            if (FileNameBytesToCopy > OutputBytesRemaining) {
                FileNameBytesToCopy = OutputBytesRemaining;
                status = STATUS_BUFFER_OVERFLOW;
            } else {
                status = STATUS_SUCCESS;
            }

            RtlCopyMemory((PUCHAR)DirectoryInformation + FileInformationBaseLength,
                FileName.Buffer, FileNameBytesToCopy);

            //
            // Fill in the number of bytes that we wrote to the user's buffer.
            //

            Irp->IoStatus.Information = FileInformationBaseLength +
                FileNameBytesToCopy;

            //
            // Check that we didn't overflow the user's buffer.  The I/O manager
            // does the initial check to make sure there's enough space for the
            // static structure for a given information class, but we might
            // overflow the buffer when copying in the variable length file
            // name.
            //

            ASSERT(Irp->IoStatus.Information <=
                IrpSp->Parameters.QueryDirectory.Length);

            //
            // Update the query offset.
            //

            DirectoryEnumContext->QueryOffset += ISONsrFidSize(FileIdentifierDescriptor);
        }

        ExFreePool(FileName.Buffer);
        ExFreePool(FileIdentifierDescriptor);

    } else if (status == STATUS_END_OF_FILE) {

        //
        // If we hit the end of the directory stream, then return an appropriate
        // status code depending on whether this was the first pass through this
        // routine for this handle or not.
        //

        status = InitialQuery ? STATUS_NO_SUCH_FILE : STATUS_NO_MORE_FILES;
    }

CleanupAndExit:
    UdfxReleaseGlobalMutex();

    Irp->IoStatus.Status = status;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\udfx\driver.c ===
/*++

Copyright (c) 2000-2001  Microsoft Corporation

Module Name:

    driver.c

Abstract:

    This module implements routines that apply to the driver object including
    initialization and IRP dispatch routines.

--*/

#include "udfx.h"

//
// Driver object for the UDF file system.
//
DECLSPEC_RDATA DRIVER_OBJECT UdfxDriverObject = {
    NULL,                               // DriverStartIo
    NULL,                               // DriverDeleteDevice
    UdfxDismountVolume,                 // DriverDismountVolume
    {
        UdfxFsdCreate,                  // IRP_MJ_CREATE
        UdfxFsdClose,                   // IRP_MJ_CLOSE
        UdfxFsdRead,                    // IRP_MJ_READ
        IoInvalidDeviceRequest,         // IRP_MJ_WRITE
        UdfxFsdQueryInformation,        // IRP_MJ_QUERY_INFORMATION
        UdfxFsdSetInformation,          // IRP_MJ_SET_INFORMATION
        IoInvalidDeviceRequest,         // IRP_MJ_FLUSH_BUFFERS
        UdfxFsdQueryVolumeInformation,  // IRP_MJ_QUERY_VOLUME_INFORMATION
        UdfxFsdDirectoryControl,        // IRP_MJ_DIRECTORY_CONTROL
        UdfxFsdFileSystemControl,       // IRP_MJ_FILE_SYSTEM_CONTROL
        UdfxFsdDeviceControl,           // IRP_MJ_DEVICE_CONTROL
        IoInvalidDeviceRequest,         // IRP_MJ_INTERNAL_DEVICE_CONTROL
        IoInvalidDeviceRequest,         // IRP_MJ_SHUTDOWN
        IoInvalidDeviceRequest,         // IRP_MJ_CLEANUP
    }
};

//
// All file system access is guarded by this single global lock.
//
INITIALIZED_CRITICAL_SECTION(UdfxGlobalMutex);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\udfx\fileinfo.c ===
/*++

Copyright (c) 2000-2001  Microsoft Corporation

Module Name:

    fileinfo.c

Abstract:

    This module implements routines related to handling
    IRP_MJ_QUERY_INFORMATION and IRP_MJ_SET_INFORMATION.

--*/

#include "udfx.h"

VOID
UdfxQueryNetworkOpenInformation(
    IN PFILE_OBJECT FileObject,
    OUT PFILE_NETWORK_OPEN_INFORMATION NetworkOpenInformation
    )
/*++

Routine Description:

    This routine fills the information structure with attributes about the
    supplied file object.

Arguments:

    FileObject - Specifies the file object to obtain the information from.

    NetworkOpenInformation - Specifies the buffer to receive the file
        information.

Return Value:

    None.

--*/
{
    PUDF_FCB Fcb;

    Fcb = (PUDF_FCB)FileObject->FsContext;

    NetworkOpenInformation->CreationTime =
    NetworkOpenInformation->LastAccessTime =
    NetworkOpenInformation->LastWriteTime =
    NetworkOpenInformation->ChangeTime =
        UdfxUdfTimestampToTime(&Fcb->ModifyTime);

    if (UdfxIsFlagSet(Fcb->Flags, UDF_FCB_DIRECTORY)) {

        NetworkOpenInformation->FileAttributes = FILE_ATTRIBUTE_READONLY |
            FILE_ATTRIBUTE_DIRECTORY;
        NetworkOpenInformation->AllocationSize.QuadPart = 0;
        NetworkOpenInformation->EndOfFile.QuadPart = 0;

    } else {

        NetworkOpenInformation->FileAttributes = FILE_ATTRIBUTE_READONLY;
        NetworkOpenInformation->AllocationSize = Fcb->FileSize;
        NetworkOpenInformation->EndOfFile = Fcb->FileSize;
    }
}

NTSTATUS
UdfxFsdQueryInformation(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    This routine is called by the I/O manager to handle IRP_MJ_QUERY_INFORMATION
    requests.

Arguments:

    DeviceObject - Specifies the device object that the I/O request is for.

    Irp - Specifies the packet that describes the I/O request.

Return Value:

    Status of operation.

--*/
{
    NTSTATUS status;
    PUDF_VOLUME_EXTENSION VolumeExtension;
    PIO_STACK_LOCATION IrpSp;
    PFILE_OBJECT FileObject;
    PUDF_FCB Fcb;
    ULONG BytesWritten;
    PFILE_INTERNAL_INFORMATION InternalInformation;
    PFILE_POSITION_INFORMATION PositionInformation;

    VolumeExtension = (PUDF_VOLUME_EXTENSION)DeviceObject->DeviceExtension;
    IrpSp = IoGetCurrentIrpStackLocation(Irp);
    FileObject = IrpSp->FileObject;
    Fcb = (PUDF_FCB)FileObject->FsContext;

    //
    // For volume file control blocks, the only thing that can be queried is the
    // current file position.
    //

    if (UdfxIsFlagSet(Fcb->Flags, UDF_FCB_VOLUME) &&
        (IrpSp->Parameters.SetFile.FileInformationClass != FilePositionInformation)) {
        status = STATUS_INVALID_PARAMETER;
        goto CleanupAndExit;
    }

    //
    // Clear the output buffer.
    //

    RtlZeroMemory(Irp->UserBuffer, IrpSp->Parameters.QueryFile.Length);

    //
    // Dispatch the information class function.
    //

    status = STATUS_SUCCESS;

    switch (IrpSp->Parameters.QueryFile.FileInformationClass) {

        case FileInternalInformation:
            InternalInformation = (PFILE_INTERNAL_INFORMATION)Irp->UserBuffer;
            InternalInformation->IndexNumber.HighPart = PtrToUlong(VolumeExtension);
            InternalInformation->IndexNumber.LowPart = PtrToUlong(Fcb);
            BytesWritten = sizeof(FILE_INTERNAL_INFORMATION);
            break;

        case FilePositionInformation:
            PositionInformation = (PFILE_POSITION_INFORMATION)Irp->UserBuffer;
            PositionInformation->CurrentByteOffset = FileObject->CurrentByteOffset;
            BytesWritten = sizeof(FILE_POSITION_INFORMATION);
            break;

        case FileNetworkOpenInformation:
            UdfxQueryNetworkOpenInformation(FileObject,
                (PFILE_NETWORK_OPEN_INFORMATION)Irp->UserBuffer);
            BytesWritten = sizeof(FILE_NETWORK_OPEN_INFORMATION);
            break;

        default:
            BytesWritten = 0;
            status = STATUS_INVALID_PARAMETER;
            break;
    }

    //
    // Fill in the number of bytes that we wrote to the user's buffer.
    //

    Irp->IoStatus.Information = BytesWritten;

    //
    // Check that we didn't overflow the user's buffer.  The I/O manager does
    // the initial check to make sure there's enough space for the static
    // structure for a given information class, but we might overflow the buffer
    // when copying in the variable length file name.
    //

    ASSERT(Irp->IoStatus.Information <= IrpSp->Parameters.QueryFile.Length);

CleanupAndExit:
    Irp->IoStatus.Status = status;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    return status;
}

NTSTATUS
UdfxFsdSetInformation(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    This routine is called by the I/O manager to handle IRP_MJ_SET_INFORMATION
    requests.

Arguments:

    DeviceObject - Specifies the device object that the I/O request is for.

    Irp - Specifies the packet that describes the I/O request.

Return Value:

    Status of operation.

--*/
{
    NTSTATUS status;
    PIO_STACK_LOCATION IrpSp;
    PFILE_OBJECT FileObject;
    PFILE_POSITION_INFORMATION PositionInformation;

    IrpSp = IoGetCurrentIrpStackLocation(Irp);
    FileObject = IrpSp->FileObject;

    //
    // The only thing that can be set is the current file position.
    //

    if (IrpSp->Parameters.SetFile.FileInformationClass != FilePositionInformation) {
        status = STATUS_INVALID_PARAMETER;
        goto CleanupAndExit;
    }

    PositionInformation = (PFILE_POSITION_INFORMATION)Irp->UserBuffer;

    //
    // If the file was opened without intermediate buffering, then the byte
    // offset must be sector aligned.
    //
    // Note that we don't use UDF_SECTOR_CD_MASK here so that the generated code
    // ends up being identical to RawxFsdSetInformation.  The linker will take
    // care of collapsing the two functions.
    //

    if (UdfxIsFlagSet(FileObject->Flags, FO_NO_INTERMEDIATE_BUFFERING) &&
        (PositionInformation->CurrentByteOffset.LowPart &
        (DeviceObject->SectorSize - 1)) != 0) {
        status = STATUS_INVALID_PARAMETER;
        goto CleanupAndExit;
    }

    //
    // Update the current file position.
    //

    FileObject->CurrentByteOffset = PositionInformation->CurrentByteOffset;
    status = STATUS_SUCCESS;

CleanupAndExit:
    Irp->IoStatus.Status = status;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\udfx\fcbsup.c ===
/*++

Copyright (c) 2000-2001  Microsoft Corporation

Module Name:

    fcbsup.c

Abstract:

    This module implements routines which provide support for file control
    blocks.

--*/

#include "udfx.h"

NTSTATUS
UdfxCreateFcbFromFileEntry(
    IN PUDF_VOLUME_EXTENSION VolumeExtension,
    IN PIRP Irp,
    IN PLONGAD IcbExtent,
    IN PUDF_FCB ParentFcb OPTIONAL,
    IN POBJECT_STRING FileName OPTIONAL,
    OUT PUDF_FCB *ReturnedFcb
    )
/*++

Routine Description:

    This routine reads the file entry descriptor at the supplied extent and
    constructs a file control block that represents the file.

Arguments:

    VolumeExtension - Specifies the volume to read the file entry descriptor
        from.

    Irp - Specifies an IRP that can be used for cache I/O.

    IcbExtent - Specifies the extent of the file entry descriptor.

    ParentFcb - Specifies the parent directory that contains the supplied file.

    FileName - Specifies the name of the file.

    ReturnedFcb - Specifies the buffer to receive the created file control
        block.

Return Value:

    Status of operation.

--*/
{
    NTSTATUS status;
    SIZE_T FcbSize;
    PUDF_FCB Fcb;
    PICBFILE IcbFile;
    ULONG AllocationDescriptorType;
    PLONGAD LongExtent;
    PSHORTAD ShortExtent;

    *ReturnedFcb = NULL;

    Fcb = NULL;
    IcbFile = NULL;

    //
    // Verify that the extent specifies the single supported partition.
    //

    if (IcbExtent->Start.Partition != 0) {
        status = STATUS_DISK_CORRUPT_ERROR;
        goto CleanupAndExit;
    }

    //
    // Compute the size of the file control block.
    //

    FcbSize = sizeof(UDF_FCB) + ((FileName != NULL) ? FileName->Length : 0);

    //
    // Allocate and initialize the file control block.
    //

    Fcb = ExAllocatePoolWithTag(FcbSize, 'cFxU');

    if (Fcb == NULL) {
        status = STATUS_INSUFFICIENT_RESOURCES;
        goto CleanupAndExit;
    }

    RtlZeroMemory(Fcb, FcbSize);

    InitializeListHead(&Fcb->ChildFcbList);

    //
    // Copy the file name into the file control block.
    //

    if (FileName != NULL) {
        RtlCopyMemory(Fcb->FileName, FileName->Buffer, FileName->Length);
        Fcb->FileNameLength = (UCHAR)FileName->Length;
    }

    //
    // Map the file descriptor into the cache.
    //

    status = UdfxMapLogicalSector(VolumeExtension, Irp, IcbExtent->Start.Lbn,
        (PVOID*)&IcbFile);

    if (!NT_SUCCESS(status)) {
        goto CleanupAndExit;
    }

    //
    // Verify that this is a file descriptor.
    //

    if (!UdfxVerifyDescriptor(&IcbFile->Destag, UDF_CD_SECTOR_SIZE,
        DESTAG_ID_NSR_FILE, IcbExtent->Start.Lbn)) {

        UdfxDbgPrint(("UDFX: file descriptor doesn't verify\n"));
        status = STATUS_DISK_CORRUPT_ERROR;
        goto CleanupAndExit;
    }

    //
    // Verify that the size of the file descriptor's variable fields doesn't
    // exceed the size of a sector.  Avoid overflow problems by checking each
    // field individually as well.
    //

    if ((IcbFile->EALength > UDF_CD_SECTOR_SIZE) ||
        (IcbFile->AllocLength > UDF_CD_SECTOR_SIZE) ||
        ((FIELD_OFFSET(ICBFILE, EAs) + IcbFile->EALength + IcbFile->AllocLength) >
            UDF_CD_SECTOR_SIZE)) {
        UdfxDbgPrint(("UDFX: file descriptor has too large of variant structures\n"));
        status = STATUS_DISK_CORRUPT_ERROR;
        goto CleanupAndExit;
    }

    //
    // Verify that this is a file type that we can support and mark the file
    // control block accordingly.
    //

    if (IcbFile->Icbtag.FileType == ICBTAG_FILE_T_DIRECTORY) {
        Fcb->Flags |= UDF_FCB_DIRECTORY;
    } else if (IcbFile->Icbtag.FileType != ICBTAG_FILE_T_FILE) {
        UdfxDbgPrint(("UDFX: file descriptor has unsupported file type\n"));
        status = STATUS_DISK_CORRUPT_ERROR;
        goto CleanupAndExit;
    }

    //
    // Copy the file size to the file control block and verify that the length
    // is limited to 32-bits.  We only support a single allocation extent and
    // that's limited to a single ULONG.
    //

    Fcb->FileSize.QuadPart = IcbFile->InfoLength;

    if (Fcb->FileSize.HighPart != 0) {
        UdfxDbgPrint(("UDFX: file descriptor has too large of file size\n"));
        status = STATUS_DISK_CORRUPT_ERROR;
        goto CleanupAndExit;
    }

    //
    // Copy the modify timestamp to the file control block.  We don't bother
    // storing any of the other timestamps that are part of the file control
    // block or stored as extended attributes.
    //

    Fcb->ModifyTime = IcbFile->ModifyTime;

    //
    // Verify that the strategy type is direct mode.
    //

    if (IcbFile->Icbtag.StratType != ICBTAG_STRAT_DIRECT) {
        UdfxDbgPrint(("UDFX: file descriptor has unsupported ICB strategy\n"));
        status = STATUS_DISK_CORRUPT_ERROR;
        goto CleanupAndExit;
    }

    //
    // Verify that we know how to process the allocation descriptor encoding.
    //

    AllocationDescriptorType = (IcbFile->Icbtag.Flags & ICBTAG_F_ALLOC_MASK);

    if ((Fcb->FileSize.LowPart == 0) && (IcbFile->AllocLength == 0)) {

        //
        // If this is a zero length file, then there may not be any allocation
        // descriptors for the file.
        //

        ASSERT(Fcb->AllocationSectorStart == 0);
        ASSERT(Fcb->EmbeddedDataOffset == 0);

    } else if (AllocationDescriptorType == ICBTAG_F_ALLOC_IMMEDIATE) {

        //
        // The size of the file should match the length of the allocation data.
        //

        if (Fcb->FileSize.LowPart != IcbFile->AllocLength) {
            UdfxDbgPrint(("UDFX: file descriptor has invalid allocation length\n"));
            status = STATUS_DISK_CORRUPT_ERROR;
            goto CleanupAndExit;
        }

        Fcb->Flags |= UDF_FCB_EMBEDDED_DATA;
        Fcb->AllocationSectorStart = IcbExtent->Start.Lbn;
        Fcb->EmbeddedDataOffset = (USHORT)
            (FIELD_OFFSET(ICBFILE, EAs) + IcbFile->EALength);

    } else if (AllocationDescriptorType == ICBTAG_F_ALLOC_LONG) {

        if (IcbFile->AllocLength != sizeof(LONGAD)) {
            UdfxDbgPrint(("UDFX: file descriptor has invalid allocation length\n"));
            status = STATUS_DISK_CORRUPT_ERROR;
            goto CleanupAndExit;
        }

        LongExtent = (PLONGAD)((PUCHAR)IcbFile + FIELD_OFFSET(ICBFILE, EAs) +
            IcbFile->EALength);

        //
        // Verify that the extent specifies the single supported partition.
        //

        if (LongExtent->Start.Partition != 0) {
            status = STATUS_DISK_CORRUPT_ERROR;
            goto CleanupAndExit;
        }

        //
        // The size of the file should match the length of the extent.
        //

        if (Fcb->FileSize.LowPart != LongExtent->Length.Length) {
            UdfxDbgPrint(("UDFX: file descriptor has invalid extent length\n"));
            status = STATUS_DISK_CORRUPT_ERROR;
            goto CleanupAndExit;
        }

        Fcb->AllocationSectorStart = LongExtent->Start.Lbn;
        ASSERT(Fcb->EmbeddedDataOffset == 0);

    } else if (AllocationDescriptorType == ICBTAG_F_ALLOC_SHORT) {

        if (IcbFile->AllocLength != sizeof(SHORTAD)) {
            UdfxDbgPrint(("UDFX: file descriptor has invalid allocation length\n"));
            status = STATUS_DISK_CORRUPT_ERROR;
            goto CleanupAndExit;
        }

        ShortExtent = (PSHORTAD)((PUCHAR)IcbFile + FIELD_OFFSET(ICBFILE, EAs) +
            IcbFile->EALength);

        //
        // The size of the file should match the length of the extent.
        //

        if (Fcb->FileSize.LowPart != ShortExtent->Length.Length) {
            UdfxDbgPrint(("UDFX: file descriptor has invalid extent length\n"));
            status = STATUS_DISK_CORRUPT_ERROR;
            goto CleanupAndExit;
        }

        Fcb->AllocationSectorStart = ShortExtent->Start;
        ASSERT(Fcb->EmbeddedDataOffset == 0);

    } else {

        UdfxDbgPrint(("UDFX: file descriptor has unsupported allocation type\n"));
        status = STATUS_DISK_CORRUPT_ERROR;
        goto CleanupAndExit;
    }

    //
    // A file control block starts with the single reference for the caller.
    //

    Fcb->ReferenceCount = 1;

    //
    // Increment the reference count for the parent file control block and
    // attach it to this file control block.
    //

    if (ParentFcb != NULL) {
        ParentFcb->ReferenceCount++;
        Fcb->ParentFcb = ParentFcb;
        InsertHeadList(&ParentFcb->ChildFcbList, &Fcb->SiblingFcbLink);
    }

    //
    // The file control block is successfully filled in.  Return the results to
    // the caller.
    //

    *ReturnedFcb = Fcb;
    Fcb = NULL;
    status = STATUS_SUCCESS;

CleanupAndExit:
    if (IcbFile != NULL) {
        FscUnmapBuffer(IcbFile);
    }

    if (Fcb != NULL) {
        ExFreePool(Fcb);
    }

    return status;
}

BOOLEAN
UdfxFindOpenChildFcb(
    IN PUDF_FCB DirectoryFcb,
    IN POBJECT_STRING FileName,
    OUT PUDF_FCB *ReturnedFcb
    )
/*++

Routine Description:

    This routine searches the child file control block for the supplied
    directory for a file that has the supplied file name.

Arguments:

    DirectoryFcb - Specifies the file control block of the directory to search.

    FileName - Specifies the name to search for in the directory.

    ReturnedFcb - Specifies the buffer to receive the found file control block.

Return Value:

    Returns TRUE if the file control block was found, else FALSE.

--*/
{
    PLIST_ENTRY NextFcbLink;
    PUDF_FCB Fcb;
    OBJECT_STRING FcbFileName;

    //
    // Walk through the file control blocks actively in use by the volume and
    // find a match.
    //

    NextFcbLink = DirectoryFcb->ChildFcbList.Flink;

    while (NextFcbLink != &DirectoryFcb->ChildFcbList) {

        Fcb = CONTAINING_RECORD(NextFcbLink, UDF_FCB, SiblingFcbLink);

        FcbFileName.Length = Fcb->FileNameLength;
        FcbFileName.Buffer = Fcb->FileName;

        if ((FcbFileName.Length == FileName->Length) &&
            RtlEqualObjectString(&FcbFileName, FileName, TRUE)) {
            *ReturnedFcb = Fcb;
            return TRUE;
        }

        NextFcbLink = Fcb->SiblingFcbLink.Flink;
    }

    *ReturnedFcb = NULL;
    return FALSE;
}

VOID
UdfxDereferenceFcb(
    IN PUDF_FCB Fcb
    )
/*++

Routine Description:

    This routine decrements the reference count on the supplied file control
    block.  If the reference count reaches zero, then the file control block is
    deleted.

Arguments:

    Fcb - Specifies the file control block to dereference.

Return Value:

    None.

--*/
{
    PUDF_FCB ParentFcb;

    ASSERT(Fcb->ReferenceCount > 0);

    do {

        //
        // Decrement the reference count and bail out if there are still
        // outstanding references to the file control block.
        //

        if (--Fcb->ReferenceCount != 0) {
            return;
        }

        //
        // Verify that the child file control block list is empty if this is a
        // directory.
        //

        if (UdfxIsFlagSet(Fcb->Flags, UDF_FCB_DIRECTORY)) {
            ASSERT(IsListEmpty(&Fcb->ChildFcbList));
        }

        //
        // Save off the parent file control block so that we can dereference it
        // in a bit.
        //

        ParentFcb = Fcb->ParentFcb;

        //
        // Remove this file control block from the list of siblings.
        //

        if (ParentFcb != NULL) {
            RemoveEntryList(&Fcb->SiblingFcbLink);
        }

        //
        // Free the file control block.
        //

        ExFreePool(Fcb);

        //
        // Switch to the parent file control block and restart the loop to
        // dereference this object.
        //

        Fcb = ParentFcb;

    } while (Fcb != NULL);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\udfx\iso13346.h ===
/***    ISO13346.H - ISO 13346 File System Disk Format
 *
 *      Microsoft Confidential
 *      Copyright (C) Microsoft Corporation 1996-2001
 *      All Rights Reserved
 *
 *      This file defines the ISO 13346 Data Structures.
 *
 *      The UDF file system uses these data structures to interpret the
 *      media's contents.
 *
 */

//
//  All 13346 structures are aligned on natural boundaries even though it will
//  not be obvious to the compiler.  Disable compiler smarts for the duration
//  of the ISO definitions.
//
//  As an example, the LONGAD definition is {ULONG {ULONG USHORT} UCHAR[6]} and
//  normal packing will pad out the internal NSRLBA, nevermind that the UCHAR
//  reserved field is doing exactly that.
//

#pragma pack(1)

/***    ISO 13346 Part 1: General
 *
 *
 */

/***    charspec - Character Set Specification (1/7.2.1)
 *
 */

typedef struct  CHARSPEC {
    UCHAR       Type;                   // Character Set Type (CHARSPEC_T_...)
    UCHAR       Info[63];               // Character Set Information
} CHARSPEC, *PCHARSPEC;

//  CHARSPEC_T_... - Values for charspec_Type Character Set Types (1/7.2.1.1)

#define CHARSPEC_T_CS0  0               // By Agreement
#define CHARSPEC_T_CS1  1               // Unicode (according to ISO 2022)
#define CHARSPEC_T_CS2  2               // 38 Glyphs
#define CHARSPEC_T_CS3  3               // 65 Glyphs
#define CHARSPEC_T_CS4  4               // 95 Glyphs
#define CHARSPEC_T_CS5  5               // 191 Glyphs
#define CHARSPEC_T_CS6  6               // Unicode or ISO 2022
#define CHARSPEC_T_CS7  7               // Unicode or ISO 2022
#define CHARSPEC_T_CS8  8               // 53 Glyphs

/***    timestamp - Timestamp Structure (1/7.3)
 *
 */

typedef struct  TIMESTAMP {
    SHORT       Zone:12;                // Time Zone (+-1440 minutes from CUT)
    USHORT      Type:4;                 // Timestamp Type (TIMESTAMP_T_...)
    USHORT      Year;                   // Year (1..9999)
    UCHAR       Month;                  // Month (1..12)
    UCHAR       Day;                    // Day (1..31)
    UCHAR       Hour;                   // Hour (0..23)
    UCHAR       Minute;                 // Minute (0..59)
    UCHAR       Second;                 // Second (0..59)
    UCHAR       CentiSecond;            // Centiseconds (0..99)
    UCHAR       Usec100;                // Hundreds of microseconds (0..99)
    UCHAR       Usec;                   // microseconds (0..99)
} TIMESTAMP, *PTIMESTAMP;

//  TIMESTAMP_T_... - Values for timestamp_Type (1/7.3.1)

#define TIMESTAMP_T_CUT         0       // Coordinated Universal Time
#define TIMESTAMP_T_LOCAL       1       // Local Time
#define TIMESTAMP_T_AGREEMENT   2       // Time format by agreement

//  TIMESTAMP_Z_... Values for timestamp_Zone

#define TIMESTAMP_Z_MIN         (-1440) // Minimum timezone offset (minutes)
#define TIMESTAMP_Z_MAX         ( 1440) // Maximum timezone offset (minutes)
#define TIMESTAMP_Z_NONE        (-2047) // No timezone in timestamp_Zone


/****   regid - Entity Identifier (1/7.4)
 *
 */

typedef struct  REGID {
    UCHAR       Flags;                  // Flags (REGID_F_...)
    UCHAR       Identifier[23];         // Identifier
    UCHAR       Suffix[8];              // Identifier Suffix
} REGID, *PREGID;

//  REGID_F_... - Definitions for regid_Flags bits

#define REGID_F_DIRTY           (0x01)  // Information Modified
#define REGID_F_PROTECTED       (0x02)  // Changes Locked Out

//  REGID_LENGTH_... - regid field lengths

#define REGID_LENGTH_IDENT      23      // Length of regid_Identifier (bytes)
#define REGID_LENGTH_SUFFIX     8       // Length of regid_Suffix (bytes)

//  REGID_ID_... - Values for regid_Identifier[0]

#define REGID_ID_ISO13346       (0x2B)  // regid_Identifier within ISO 13346
#define REGID_ID_NOTREGISTERED  (0x2D)  // regid_Identifier is not registered


/***    Various Structures from Parts 3 and 4 moved here for compilation.
 *
 */


/***    extentad - Extent Address Descriptor (3/7.1)
 *
 */

typedef struct  EXTENTAD {
    ULONG       Len;                    // Extent Length in Bytes
    ULONG       Lsn;                    // Extent Logical Sector Number
} EXTENTAD, *PEXTENTAD;


/***    nsr_lba - Logical Block Address (4/7.1) (lb_addr)
 *
 */

typedef struct  NSRLBA {
    ULONG       Lbn;                    // Logical Block Number
    USHORT      Partition;              // Partition Reference Number
} NSRLBA, *PNSRLBA;


/***    nsr_length - Format of a NSR allocation descriptor length field (4/14.14.1.1)
 *
 *          This is hands-down one of the most stupid things in 13346
 */

typedef struct NSRLENGTH {
    ULONG       Length:30;
    ULONG       Type:2;
} NSRLENGTH, *PNSRLENGTH;

#define NSRLENGTH_TYPE_RECORDED         0
#define NSRLENGTH_TYPE_UNRECORDED       1
#define NSRLENGTH_TYPE_UNALLOCATED      2
#define NSRLENGTH_TYPE_CONTINUATION     3


/***    Short Allocation Descriptor (4/14.14.1)
 *
 *      Note that a SHORTAD precisely overlaps a LONGAD.  Use this by defining
 *      a generic allocation descriptor structure.
 */

typedef struct  SHORTAD {
    NSRLENGTH   Length;                 // Extent Length
    ULONG       Start;                  // Extent Logical Block Number
} SHORTAD, *PSHORTAD;

typedef SHORTAD AD_GENERIC, *PAD_GENERIC;


/***    Long Allocation Descriptor (4/14.14.2)
 *
 */

typedef struct  LONGAD {
    NSRLENGTH   Length;                 // Extent Length
    NSRLBA      Start;                  // Extent Location
    UCHAR       ImpUse[6];              // Implementation Use
} LONGAD, *PLONGAD;


/***    Extended Allocation Descriptor (4/14.14.3)
 *
 */

typedef struct  EXTAD {
    NSRLENGTH   ExtentLen;              // Extent Length
    NSRLENGTH   RecordedLen;            // Recorded Length
    ULONG       InfoLen;                // Information Length
    NSRLBA      Start;                  // Extent Location
    UCHAR       ImpUse[2];              // Implementation Use
} EXTAD, *PEXTAD;

/***    ISO 13346 Part 2: Volume and Boot Block Recognition
 *
 *
 */


/***    vsd_generic - Generic Volume Structure Descriptor (2/9.1)
 *
 */

typedef struct  VSD_GENERIC {
    UCHAR       Type;                   // Structure Type
    UCHAR       Ident[5];               // Standard Identifier
    UCHAR       Version;                // Standard Version
    UCHAR       Data[2041];             // Structure Data
} VSD_GENERIC, *PVSD_GENERIC;

//  VSD_LENGTH_... - vsd field lengths

#define VSD_LENGTH_IDENT        5       // Length of regid_Identifier (bytes)

//  VSD_IDENT_... - Values for vsd_generic_Ident

#define VSD_IDENT_BEA01     "BEA01"     // Begin Extended Area
#define VSD_IDENT_TEA01     "TEA01"     // Terminate Extended Area
#define VSD_IDENT_CDROM     "CDROM"     // High Sierra Group (pre-ISO 9660)
#define VSD_IDENT_CD001     "CD001"     // ISO 9660
#define VSD_IDENT_CDW01     "CDW01"     // ECMA 168
#define VSD_IDENT_CDW02     "CDW02"     // ISO 13490
#define VSD_IDENT_NSR01     "NSR01"     // ECMA 167
#define VSD_IDENT_NSR02     "NSR02"     // ISO 13346
#define VSD_IDENT_BOOT2     "BOOT2"     // Boot Descriptor

typedef enum _VSD_IDENT {
    VsdIdentBad = 0,
    VsdIdentBEA01,
    VsdIdentTEA01,
    VsdIdentCDROM,
    VsdIdentCD001,
    VsdIdentCDW01,
    VsdIdentCDW02,
    VsdIdentNSR01,
    VsdIdentNSR02,
    VsdIdentBOOT2
} VSD_IDENT, *PVSD_IDENT;

/***    vsd_bea01 - Begin Extended Area Descriptor (2/9.2)
 *
 */

typedef struct  VSD_BEA01 {
    UCHAR       Type;                   // Structure Type
    UCHAR       Ident[5];               // Standard Identifier ('BEA01')
    UCHAR       Version;                // Standard Version
    UCHAR       Data[2041];             // Structure Data
} VSD_BEA01, *PVSD_BEA01;


/***    vsd_tea01 - Terminate Extended Area Descriptor (2/9.3)
 *
 */

typedef struct  VSD_TEA01 {
    UCHAR       Type;                   // Structure Type
    UCHAR       Ident[5];               // Standard Identifier ('TEA01')
    UCHAR       Version;                // Standard Version
    UCHAR       Data[2041];             // Structure Data
} VSD_TEA01, *PVSD_TEA01;


/***    vsd_boot2 - Boot Descriptor (2/9.4)
 *
 */

typedef struct  VSD_BOOT2 {
    UCHAR       Type;                   // Structure Type
    UCHAR       Ident[5];               // Standard Identifier ('BOOT2')
    UCHAR       Version;                // Standard Version
    UCHAR       Res8;                   // Reserved Zero
    REGID       Architecture;           // Architecture Type
    REGID       BootIdent;              // Boot Identifier
    ULONG       BootExt;                // Boot Extent Start
    ULONG       BootExtLen;             // Boot Extent Length
    ULONG       LoadAddr[2];            // Load Address
    ULONG       StartAddr[2];           // Start Address
    TIMESTAMP   Timestamp;              // Creation Time
    USHORT      Flags;                  // Flags (VSD_BOOT2_F_...)
    UCHAR       Res110[32];             // Reserved Zeros
    UCHAR       BootUse[1906];          // Boot Use
} VSD_BOOT2, *PVSD_BOOT2;

//  VSD_BOOT2_F_... - Definitions for vsd_boot2_Flags bits

#define VSD_BOOT2_F_ERASE   (0x0001)    // Ignore previous similar BOOT2 vsds

//
//  Aligning this byte offset to a sector boundary by rounding up will
//  yield the starting offset of the Volume Recognition Area (2/8.3)
//

#define VRA_BOUNDARY_LOCATION (32767 + 1)

/***    ISO 13346 Part 3: Volume Structure
 *
 *
 */

/***    destag - Descriptor Tag (3/7.1 and 4/7.2)
 *
 *      destag_Checksum = Byte sum of bytes 0-3 and 5-15 of destag.
 *
 *      destag_CRC = CRC (X**16 + X**12 + X**5 + 1)
 *
 */

typedef struct  DESTAG {
    USHORT      Ident;                  // Tag Identifier
    USHORT      Version;                // Descriptor Version
    UCHAR       Checksum;               // Tag Checksum
    UCHAR       Res5;                   // Reserved
    USHORT      Serial;                 // Tag Serial Number
    USHORT      CRC;                    // Descriptor CRC
    USHORT      CRCLen;                 // Descriptor CRC Length
    ULONG       Lbn;                    // Tag Location (Logical Block Number)
} DESTAG, *PDESTAG;

//  DESTAG_ID_... - Values for destag_Ident
//  Descriptor Tag Values from NSR Part 3 (3/7.2.1)

#define DESTAG_ID_NOTSPEC           0   // Format Not Specified
#define DESTAG_ID_NSR_PVD           1   // (3/10.1) Primary Volume Descriptor
#define DESTAG_ID_NSR_ANCHOR        2   // (3/10.2) Anchor Volume Desc Pointer
#define DESTAG_ID_NSR_VDP           3   // (3/10.3) Volume Descriptor Pointer
#define DESTAG_ID_NSR_IMPUSE        4   // (3/10.4) Implementation Use Vol Desc
#define DESTAG_ID_NSR_PART          5   // (3/10.5) Partition Descriptor
#define DESTAG_ID_NSR_LVOL          6   // (3/10.6) Logical Volume Descriptor
#define DESTAG_ID_NSR_UASD          7   // (3/10.8) Unallocated Space Desc
#define DESTAG_ID_NSR_TERM          8   // (3/10.9) Terminating Descriptor
#define DESTAG_ID_NSR_LVINTEG       9   // (3/10.10) Logical Vol Integrity Desc

#define DESTAG_ID_MINIMUM_PART3     1   // The lowest legal DESTAG in Part 3
#define DESTAG_ID_MAXIMUM_PART3     9   // The highest legal DESTAG in Part 3

//  DESTAG_ID_... - Values for destag_Ident, continued...
//  Descriptor Tag Values from NSR Part 4 (4/7.2.1)

#define DESTAG_ID_NSR_FSD           256 // (4/14.1) File Set Descriptor
#define DESTAG_ID_NSR_FID           257 // (4/14.4) File Identifier Descriptor
#define DESTAG_ID_NSR_ALLOC         258 // (4/14.5) Allocation Extent Desc
#define DESTAG_ID_NSR_ICBIND        259 // (4/14.7) ICB Indirect Entry
#define DESTAG_ID_NSR_ICBTRM        260 // (4/14.8) ICB Terminal Entry
#define DESTAG_ID_NSR_FILE          261 // (4/14.9) File Entry
#define DESTAG_ID_NSR_EA            262 // (4/14.10) Extended Attribute Header
#define DESTAG_ID_NSR_UASE          263 // (4/14.11) Unallocated Space Entry
#define DESTAG_ID_NSR_SBP           264 // (4/14.12) Space Bitmap Descriptor
#define DESTAG_ID_NSR_PINTEG        265 // (4/14.13) Partition Integrity

#define DESTAG_ID_MINIMUM_PART4     256 // The lowest legal DESTAG in Part 4
#define DESTAG_ID_MAXIMUM_PART4     265 // The highest legal DESTAG in Part 4

//  DESTAG_VER_... - Values for destag_Version (3/7.2.2)

#define DESTAG_VER_CURRENT          2   // Current Descriptor Tag Version

//  DESTAG_SERIAL_... - Values for destag_Serial (3/7.2.5)

#define DESTAG_SERIAL_NONE          0   // No Serial Number specified


/***    Anchor Points (3/8.4.2.1)
 *
 */

#define ANCHOR_SECTOR   256


/***    vsd_nsr02 - NSR02 Volume Structure Descriptor (3/9.1)
 *
 */

typedef struct  VSD_NSR02 {
    UCHAR       Type;                   // Structure Type
    UCHAR       Ident[5];               // Standard Identifier ('NSR02')
    UCHAR       Version;                // Standard Version
    UCHAR       Res7;                   // Reserved 0 Byte
    UCHAR       Data[2040];             // Structure Data
} VSD_NSR02, *PVSD_NSR02;


//  Values for vsd_nsr02_Type

#define VSD_NSR02_TYPE_0        0       // Reserved 0

//  Values for vsd_nsr02_Version

#define VSD_NSR02_VER           1       // Standard Version 1


/***    nsr_vd_generic - Generic Volume Descriptor of 512 bytes
 *
 */

typedef struct  NSR_VD_GENERIC {
    DESTAG      Destag;                 // Descriptor Tag
    ULONG       Sequence;               // Volume Descriptor Sequence Number
    UCHAR       Data20[492];            // Descriptor Data
} NSR_VD_GENERIC, *PNSR_VD_GENERIC;


/***    nsr_pvd - NSR Primary Volume Descriptor (3/10.1)
 *
 *      nsr_pvd_destag.destag_Ident = DESTAG_ID_NSR_PVD
 *
 */

typedef struct  NSR_PVD {
    DESTAG      Destag;                 // Descriptor Tag (NSR_PVD)
    ULONG       VolDescSeqNum;          // Volume Descriptor Sequence Number
    ULONG       Number;                 // Primary Volume Descriptor Number
    UCHAR       VolumeID[32];           // Volume Identifier
    USHORT      VolSetSeq;              // Volume Set Sequence Number
    USHORT      VolSetSeqMax;           // Maximum Volume Set Sequence Number
    USHORT      Level;                  // Interchange Level
    USHORT      LevelMax;               // Maximum Interchange Level
    ULONG       CharSetList;            // Character Set List (See 1/7.2.11)
    ULONG       CharSetListMax;         // Maximum Character Set List
    UCHAR       VolSetID[128];          // Volume Set Identifier
    CHARSPEC    CharsetDesc;            // Descriptor Character Set
    CHARSPEC    CharsetExplan;          // Explanatory Character Set
    EXTENTAD    Abstract;               // Volume Abstract Location
    EXTENTAD    Copyright;              // Volume Copyright Notice Location
    REGID       Application;            // Application Identifier
    TIMESTAMP   RecordTime;             // Recording Time
    REGID       ImpUseID;               // Implementation Identifier
    UCHAR       ImpUse[64];             // Implementation Use
    ULONG       Predecessor;            // Predecessor Vol Desc Seq Location
    USHORT      Flags;                  // Flags
    UCHAR       Res490[22];             // Reserved Zeros
} NSR_PVD, *PNSR_PVD;

//  NSRPVD_F_... - Definitions for nsr_pvd_Flags

#define NSRPVD_F_COMMON_VOLID   (0x0001)// Volume ID is common across Vol Set


/***    nsr_anchor - Anchor Volume Descriptor Pointer (3/10.2)
 *
 *      nsr_anchor_destag.destag_Ident = DESTAG_ID_NSR_ANCHOR
 *
 */

typedef struct  NSR_ANCHOR {
    DESTAG      Destag;                 // Descriptor Tag (NSR_ANCHOR)
    EXTENTAD    Main;                   // Main Vol Desc Sequence Location
    EXTENTAD    Reserve;                // Reserve Vol Desc Sequence Location
    UCHAR       Res32[480];             // Reserved Zeros
} NSR_ANCHOR, *PNSR_ANCHOR;


/***    nsr_vdp - Volume Descriptor Pointer (3/10.3)
 *
 *      nsr_vdp_destag.destag_Ident = DESTAG_ID_NSR_VDP
 *
 */

typedef struct  NSR_VDP {
    DESTAG      Destag;                 // Descriptor Tag (NSR_VDP)
    ULONG       VolDescSeqNum;          // Vol Desc Sequence Number
    EXTENTAD    Next;                   // Next Vol Desc Sequence Location
    UCHAR       Res28[484];             // Reserved Zeros
} NSR_VDP, *PNSR_VDP;


/***    nsr_impuse - Implementation Use Volume Descriptor (3/10.4)
 *
 *      nsr_impuse_destag.destag_Ident = DESTAG_ID_NSR_IMPUSE
 *
 */

typedef struct  NSR_IMPUSE {
    DESTAG      Destag;                 // Descriptor Tag (NSR_IMPUSE)
    ULONG       VolDescSeqNum;          // Vol Desc Sequence Number
    REGID       ImpUseID;               // Implementation Identifier
    UCHAR       ImpUse[460];            // Implementation Use
} NSR_IMPUSE, *PNSR_IMPUSE;


/***    nsr_part - Partition Descriptor (3/10.5)
 *
 *      nsr_part_destag.destag_Ident = DESTAG_ID_NSR_PART
 *
 */

typedef struct  NSR_PART {
    DESTAG      Destag;                 // Descriptor Tag (NSR_PART)
    ULONG       VolDescSeqNum;          // Vol Desc Sequence Number
    USHORT      Flags;                  // Partition Flags (NSR_PART_F_...)
    USHORT      Number;                 // Partition Number
    REGID       ContentsID;             // Partition Contents ID
    UCHAR       ContentsUse[128];       // Partition Contents Use
    ULONG       AccessType;             // Access Type
    ULONG       Start;                  // Partition Starting Location
    ULONG       Length;                 // Partition Length (sector count)
    REGID       ImpUseID;               // Implementation Identifier
    UCHAR       ImpUse[128];            // Implementation Use
    UCHAR       Res356[156];            // Reserved Zeros
} NSR_PART, *PNSR_PART;


//  NSR_PART_F_... - Definitions for nsr_part_Flags

#define NSR_PART_F_ALLOCATION   (0x0001)    // Volume Space Allocated

//  Values for nsr_part_ContentsID.regid_Identifier

#define NSR_PART_CONTID_FDC01   "+FDC01"    // ISO 9293-1987
#define NSR_PART_CONTID_CD001   "+CD001"    // ISO 9660
#define NSR_PART_CONTID_CDW01   "+CDW01"    // ECMA 168
#define NSR_PART_CONTID_CDW02   "+CDW02"    // ISO 13490
#define NSR_PART_CONTID_NSR01   "+NSR01"    // ECMA 167
#define NSR_PART_CONTID_NSR02   "+NSR02"    // ISO 13346

typedef enum NSR_PART_CONTID {
    NsrPartContIdBad = 0,
    NsrPartContIdFDC01,
    NsrPartContIdCD001,
    NsrPartContIdCDW01,
    NsrPartContIdCDW02,
    NsrPartContIdNSR01,
    NsrPartContIdNSR02
} NSR_PART_CONTID, *PNSR_PART_CONTID;

//  Values for nsr_part_AccessType

#define NSR_PART_ACCESS_NOSPEC  0       // Partition Access Unspecified
#define NSR_PART_ACCESS_RO      1       // Read Only Access
#define NSR_PART_ACCESS_WO      2       // Write-Once Access
#define NSR_PART_ACCESS_RW_PRE  3       // Read/Write with preparation
#define NSR_PART_ACCESS_RW_OVER 4       // Read/Write, fully overwritable


/***    nsr_lvol - Logical Volume Descriptor (3/10.6)
 *
 *      nsr_lvol_destag.destag_Ident = DESTAG_ID_NSR_LVOL
 *
 *      The Logical Volume Contents Use field is specified here as a
 *      File Set Descriptor Sequence (FSD) address.  See (4/3.1).
 *
 */

typedef struct  NSR_LVOL {
    DESTAG      Destag;                 // Descriptor Tag (NSR_LVOL)
    ULONG       VolDescSeqNum;          // Vol Desc Sequence Number
    CHARSPEC    Charset;                // Descriptor Character Set
    UCHAR       VolumeID[128];          // Logical Volume ID
    ULONG       BlockSize;              // Logical Block Size (in bytes)
    REGID       DomainID;               // Domain Identifier
    LONGAD      FSD;                    // Logical Volume Contents Use
    ULONG       MapTableLength;         // Map Table Length (bytes)
    ULONG       MapTableCount;          // Map Table Partition Maps Count
    REGID       ImpUseID;               // Implementaion Identifier
    UCHAR       ImpUse[128];            // Implementation Use
    EXTENTAD    Integrity;              // Integrity Sequence Extent
    UCHAR       MapTable[0];            // Partition Map Table (variant!)

//  The true length of this structure may vary!

} NSR_LVOL, *PNSR_LVOL;

#define ISONsrLvolConstantSize (FIELD_OFFSET( NSR_LVOL, MapTable ))
#define ISONsrLvolSize( L ) (ALIGN_UP( ISONsrLvolConstantSize + (L)->MapTableLength, sizeof(ULONGLONG) ))

/***    partmap_generic - Generic Partition Map (3/10.7.1)
 *
 */

typedef struct  PARTMAP_GENERIC {
    UCHAR       Type;                   // Partition Map Type
    UCHAR       Length;                 // Partition Map Length
    UCHAR       Map[0];                 // Partion Mapping (variant!)

//  The true length of this structure may vary!

} PARTMAP_GENERIC, *PPARTMAP_GENERIC;

//  Values for partmap_g_Type

#define PARTMAP_TYPE_NOTSPEC        0   // Partition Map Format Not Specified
#define PARTMAP_TYPE_PHYSICAL       1   // Partition Map in Volume Set (Type 1)
#define PARTMAP_TYPE_PROXY          2   // Partition Map by identifier (Type 2)


/***    partmap_physical - Normal (Type 1) Partition Map (3/10.7.2)
 *
 *      A Normal Partion Map specifies a partition number on a volume
 *      within the same volume set.
 *
 */

typedef struct  PARTMAP_PHYSICAL {
    UCHAR       Type;                   // Partition Map Type = 1
    UCHAR       Length;                 // Partition Map Length = 6
    USHORT      VolSetSeq;              // Partition Volume Set Sequence Number
    USHORT      Partition;              // Partition Number
} PARTMAP_PHYSICAL, *PPARTMAP_PHYSICAL;


/***    partmap_proxy - Proxy (Type 2) Partition Map (3/10.7.3)
 *
 *      A Proxy Partition Map is commonly not interchangeable.
 *
 */

typedef struct  PARTMAP_PROXY {
    UCHAR       Type;                   // Partition Map Type = 2
    UCHAR       Length;                 // Partition Map Length = 64
    UCHAR       PartID[62];             // Partition Identifier (Proxy)
} PARTMAP_PROXY, *PPARTMAP_PROXY;


/***    nsr_uasd - Unallocated Space Descriptor (3/10.8)
 *
 *      nsr_uasd_destag.destag_Ident = DESTAG_ID_NSR_UASD
 *
 *      The true length of nsr_uasd_Extents is (nsr_uasd_ExtentCount * 8), and
 *      the last logical sector of nsr_uasd_Extents is zero padded.
 *
 */

typedef struct  NSR_UASD {
    DESTAG      Destag;                 // Descriptor Tag (NSR_UASD)
    ULONG       VolDescSeqNum;          // Vol Desc Sequence Number
    ULONG       ExtentCount;            // Number of Allocation Descriptors
    EXTENTAD    Extents[0];             // Allocation Descriptors (variant!)

//  The true length of this structure may vary!
//  The true length of nsr_uasd_Extents is (nsr_uasd_ExtentCount * 8) bytes.
//  The last logical sector of nsr_uasd_Extents is zero padded.

} NSR_UASD, *PNSR_UASD;


/***    nsr_term - Terminating Descriptor (3/10.9 and 4/14.2)
 *
 *      nsr_term_destag.destag_Ident = DESTAG_ID_NSR_TERM
 *
 */

typedef struct  NSR_TERM {
    DESTAG      Destag;                 // Descriptor Tag (NSR_TERM)
    UCHAR       Res16[496];             // Reserved Zeros
} NSR_TERM, *PNSR_TERM;


/***    nsr_lvhd - Logical Volume Header Descriptor (4/14.15)
 *
 *      This descriptor is found in the Logical Volume Content Use
 *      field of a Logical Volume Integrity Descriptor.
 *
 *      This definition is moved to here to avoid forward reference.
 */

typedef struct  NSR_LVHD {
    ULONG       UniqueID[2];            // Unique ID
    UCHAR       Res8[24];               // Reserved Zeros
} NSR_LVHD, *PNSR_LVHD;


/***    nsr_integ - Logical Volume Integrity Descriptor (3/10.10)
 *
 *      nsr_integ_destag.destag_Ident = DESTAG_ID_NSR_LVINTEG
 *
 *      WARNING: WARNING: WARNING: nsr_integ is a multi-variant structure!
 *
 *      The starting address of nsr_integ_Size is not acurrate.
 *      Compensate for this nsr_integ_Size problem by adding the value of
 *      (nsr_integ_PartitionCount-1) to the ULONG ARRAY INDEX.
 *
 *      The starting address of nsr_integ_ImpUse[0] is not accurate.
 *      Compensate for this nsr_integ_ImpUse problem by adding the value of
 *      ((nsr_integ_PartitionCount-1)<<3) to the UCHAR ARRAY INDEX.
 *
 *      This descriptor is padded with zero bytes to the end of the last
 *      logical sector it occupies.
 *
 *      The Logical Volume Contents Use field is specified here as a
 *      Logical Volume Header Descriptor.  See (4/3.1) second last point.
 */

typedef struct  NSR_INTEG {
    DESTAG      Destag;                 // Descriptor Tag (NSR_LVINTEG)
    TIMESTAMP   Time;                   // Recording Date
    ULONG       Type;                   // Integrity Type (INTEG_T_...)
    EXTENTAD    Next;                   // Next Integrity Extent
    NSR_LVHD    LVHD;                   // Logical Volume Contents Use
    ULONG       PartitionCount;         // Number of Partitions
    ULONG       ImpUseLength;           // Length of Implementation Use
    ULONG       Free[1];                // Free Space Table

//  nsr_integ_Free has a variant length = (4*nsr_integ_PartitionCount)

    ULONG       Size[1];                // Size Table

//  nsr_integ_Size has a variant starting offset due to nsr_integ_Free
//  nsr_integ_Size has a variant length = (4*nsr_integ_PartitionCount)

    UCHAR       ImpUse[0];              // Implementation Use

//  nsr_integ_ImpUse has a variant starting offset due to nsr_integ_Free and
//  nsr_integ_Size.
//  nsr_integ_ImpUse has a variant length = (nsr_integ_ImpUseLength)

} NSR_INTEG, *PNSR_INTEG;

// Values for nsr_integ_Type

#define NSR_INTEG_T_OPEN        0           // Open Integrity Descriptor
#define NSR_INTEG_T_CLOSE       1           // Close Integrity Descriptor


/***    ISO 13346 Part 4: File Structure
 *
 *      See DESTAG structure in Part 3 for definitions found in (4/7.2).
 *
 */


/***    nsr_fsd - File Set Descriptor (4/14.1)
 *
 *      nsr_fsd_destag.destag_Ident = DESTAG_ID_NSR_FSD
 */

typedef struct  NSR_FSD {
    DESTAG      Destag;                     // Descriptor Tag (NSR_LVOL)
    TIMESTAMP   Time;                       // Recording Time
    USHORT      Level;                      // Interchange Level
    USHORT      LevelMax;                   // Maximum Interchange Level
    ULONG       CharSetList;                // Character Set List (See 1/7.2.11)
    ULONG       CharSetListMax;             // Maximum Character Set List
    ULONG       FileSet;                    // File Set Number
    ULONG       FileSetDesc;                // File Set Descriptor Number
    CHARSPEC    CharspecVolID;              // Volume ID Character Set
    UCHAR       VolID[128];                 // Volume ID
    CHARSPEC    CharspecFileSet;            // File Set Character Set
    UCHAR       FileSetID[32];              // File Set ID
    UCHAR       Copyright[32];              // Copyright File Name
    UCHAR       Abstract[32];               // Abstract File Name
    LONGAD      IcbRoot;                    // Root Directory ICB Address
    REGID       DomainID;                   // Domain Identifier
    LONGAD      NextExtent;                 // Next FSD Extent
    UCHAR       Res464[48];                 // Reserved Zeros
} NSR_FSD, *PNSR_FSD;


/***    nsr_part_h - Partition Header Descriptor (4/14.3)
 *
 *      No Descriptor Tag.
 *
 *      This descriptor is found in the nsr_part_ContentsUse field of
 *      an NSR02 Partition Descriptor.  See NSR_PART_CONTID_NSR02.
 *
 */

typedef struct  NSR_PART_H {
    SHORTAD     UASTable;                   // Unallocated Space Table
    SHORTAD     UASBitmap;                  // Unallocated Space Bitmap
    SHORTAD     IntegTable;                 // Integrity Table
    SHORTAD     FreedTable;                 // Freed Space Table
    SHORTAD     FreedBitmap;                // Freed Space Bitmap
    UCHAR       Res40[88];                  // Reserved Zeros
} NSR_PART_H, *PNSR_PART_H;


/***    nsr_fid - File Identifier Descriptor (4/14.4)
 *
 *      nsr_fid_destag.destag_Ident = DESTAG_ID_NSR_FID
 *
 *      WARNING: WARNING: WARNING: nsr_fid is a multi-variant structure!
 *
 *      The starting address of nsr_fid_FileID is not acurrate.
 *      Compensate for this nsr_fid_FileID problem by adding the value of
 *      (nsr_fid_ImpUseLen-1) to the UCHAR ARRAY INDEX.
 *
 *      The starting address of nsr_fid_Padding is not acurrate.
 *      Compensate for this nsr_fid_Padding problem by adding the value of
 *      (nsr_fid_ImpUseLen+nsr_fid_FileIDLen-2) to the UCHAR ARRAY INDEX.
 *
 *      The true total size of nsr_fid_s is
 *          ((38 + nsr_fid_FileIDLen + nsr_fid_ImpUseLen) + 3) & ~3)
 *
 */

typedef struct  NSR_FID {
    DESTAG      Destag;                     // Descriptor Tag (NSR_FID)
    USHORT      Version;                    // File Version Number
    UCHAR       Flags;                      // File Flags (NSR_FID_F_...)
    UCHAR       FileIDLen;                  // File ID Length
    LONGAD      Icb;                        // ICB (long) Address
    USHORT      ImpUseLen;                  // Implementation Use Length

    UCHAR       ImpUse[1];                  // Implementation Use Area

//  nsr_fid_ImpUse has a variant length = nsr_fid_ImpUseLen

    UCHAR       FileID[1];                  // File Identifier

//  nsr_fid_FileID has a variant starting offset due to nsr_fid_ImpUse
//  nsr_fid_FileID has a variant length = nsr_fid_FileIDLen

    UCHAR       Padding[1];                 // Padding

//  nsr_fid_Paddinghas a variant starting offset due to nsr_fid_ImpUse and
//  nsr_fid_FileID
//  nsr_fid_Padding has a variant length. Round up to the next ULONG boundary.

} NSR_FID, *PNSR_FID;

#define ISONsrFidConstantSize (ULONG)(FIELD_OFFSET( NSR_FID, ImpUse ))
#define ISONsrFidSize( F ) (ALIGN_UP( ISONsrFidConstantSize + (F)->FileIDLen + (F)->ImpUseLen, sizeof(ULONG) ))

//  NSR_FID_F_... - Definitions for nsr_fid_Flags (Characteristics, 4/14.4.3)

#define NSR_FID_F_HIDDEN        (0x01)  // Hidden Bit
#define NSR_FID_F_DIRECTORY     (0x02)  // Directory Bit
#define NSR_FID_F_DELETED       (0x04)  // Deleted Bit
#define NSR_FID_F_PARENT        (0x08)  // Parent Directory Bit

#define NSR_FID_OFFSET_FILEID   38      // Field Offset of nsr_fid_FileID[];


/***    nsr_alloc - Allocation Extent Descriptor (4/14.5)
 *
 *      nsr_alloc_destag.destag_Ident = DESTAG_ID_NSR_ALLOC
 *
 *      This descriptor is immediately followed by AllocLen bytes
 *      of allocation descriptors, which is not part of this
 *      descriptor (so CRC calculation doesn't include it).
 *
 */

typedef struct  NSR_ALLOC {
    DESTAG      Destag;                 // Descriptor Tag (NSR_ALLOC)
    ULONG       Prev;                   // Previous Allocation Descriptor
    ULONG       AllocLen;               // Length of Allocation Descriptors
} NSR_ALLOC, *PNSR_ALLOC;


/***    icbtag - Information Control Block Tag (4/14.6)
 *
 *      An ICBTAG is commonly preceeded by a Descriptor Tag (DESTAG).
 *
 */

typedef struct  ICBTAG {
    ULONG       PriorDirectCount;// Prior Direct Entry Count
    USHORT      StratType;       // Strategy Type (ICBTAG_STRAT_...)
    USHORT      StratParm;       // Strategy Parameter (2 bytes)
    USHORT      MaxEntries;      // Maximum Number of Entries in ICB
    UCHAR       Res10;           // Reserved Zero
    UCHAR       FileType;        // File Type (ICBTAG_FILE_T_...)
    NSRLBA      IcbParent;       // Parent ICB Location
    USHORT      Flags;           // ICB Flags (ICBTAG_F_...)
} ICBTAG, *PICBTAG;


//  ICBTAG_STRAT_T_... - ICB Strategy Types

#define ICBTAG_STRAT_NOTSPEC    0       // ICB Strategy Not Specified
#define ICBTAG_STRAT_TREE       1       // Strategy 1 (4/A.2) (Plain Tree)
#define ICBTAG_STRAT_MASTER     2       // Strategy 2 (4/A.3) (Master ICB)
#define ICBTAG_STRAT_BAL_TREE   3       // Strategy 3 (4/A.4) (Balanced Tree)
#define ICBTAG_STRAT_DIRECT     4       // Strategy 4 (4/A.5) (One Direct)

//  ICBTAG_FILE_T_... - Values for icbtag_FileType

#define ICBTAG_FILE_T_NOTSPEC    0      // Not Specified
#define ICBTAG_FILE_T_UASE       1      // Unallocated Space Entry
#define ICBTAG_FILE_T_PINTEG     2      // Partition Integrity Entry
#define ICBTAG_FILE_T_INDIRECT   3      // Indirect Entry
#define ICBTAG_FILE_T_DIRECTORY  4      // Directory
#define ICBTAG_FILE_T_FILE       5      // Ordinary File
#define ICBTAG_FILE_T_BLOCK_DEV  6      // Block Special Device
#define ICBTAG_FILE_T_CHAR_DEV   7      // Character Special Device
#define ICBTAG_FILE_T_XA         8      // Extended Attributes
#define ICBTAG_FILE_T_FIFO       9      // FIFO file
#define ICBTAG_FILE_T_C_ISSOCK  10      // Socket
#define ICBTAG_FILE_T_TERMINAL  11      // Terminal Entry
#define ICBTAG_FILE_T_PATHLINK  12      // Symbolic Link with a pathname

//  ICBTAG_F_... - Values for icbtag_Flags

#define ICBTAG_F_ALLOC_MASK     (0x0007)// Mask for Allocation Descriptor Info
#define ICBTAG_F_ALLOC_SHORT          0 // Short Allocation Descriptors Used
#define ICBTAG_F_ALLOC_LONG           1 // Long Allocation Descriptors Used
#define ICBTAG_F_ALLOC_EXTENDED       2 // Extended Allocation Descriptors Used
#define ICBTAG_F_ALLOC_IMMEDIATE      3 // File Data Recorded Immediately

#define ISOAllocationDescriptorSize(T) ( (T) == ICBTAG_F_ALLOC_SHORT ? sizeof(SHORTAD) : \
                                         (T) == ICBTAG_F_ALLOC_LONG ? sizeof(LONGAD) :   \
                                         sizeof(EXTAD) )

#define ICBTAG_F_SORTED         (0x0008)// Directory is Sorted (4/8.6.1)
#define ICBTAG_F_NO_RELOCATE    (0x0010)// Data is not relocateable
#define ICBTAG_F_ARCHIVE        (0x0020)// Archive Bit
#define ICBTAG_F_SETUID         (0x0040)// S_ISUID Bit
#define ICBTAG_F_SETGID         (0x0080)// S_ISGID Bit
#define ICBTAG_F_STICKY         (0x0100)// C_ISVTX Bit
#define ICBTAG_F_CONTIGUOUS     (0x0200)// File Data is Contiguous
#define ICBTAG_F_SYSTEM         (0x0400)// System Bit
#define ICBTAG_F_TRANSFORMED    (0x0800)// Data Transformed
#define ICBTAG_F_MULTIVERSIONS  (0x1000)// Multi-version Files in Directory


/***    icbind - Indirect ICB Entry (4/14.7)
 *
 */

typedef struct  ICBIND {
    DESTAG      Destag;                 // Descriptor Tag (ID_NSR_ICBIND)
    ICBTAG      Icbtag;                 // ICB Tag (ICBTAG_FILE_T_INDIRECT)
    LONGAD      Icb;                    // ICB Address
} ICBIND, *PICBIND;


/***    icbtrm - Terminal ICB Entry (4/14.8)
 *
 */

typedef struct  ICBTRM {
    DESTAG      Destag;                 // Descriptor Tag (ID_NSR_ICBTRM)
    ICBTAG      Icbtag;                 // ICB Tag (ICBTAG_FILE_T_TERMINAL)
} ICBTRM, *PICBTRM;


/***    icbfile - File ICB Entry (4/14.9)
 *
 *      WARNING: WARNING: WARNING: icbfile is a multi-variant structure!
 *
 *      The starting address of icbfile_Allocs is not acurrate.
 *      Compensate for this icbfile_Allocs problem by adding the value of
 *      (icbfile_XALength-1) to the UCHAR ARRAY INDEX.
 *
 *      icbfile_XALength is a multiple of 4.
 *
 */

typedef struct  ICBFILE {
    DESTAG      Destag;                 // Descriptor Tag (ID_NSR_FILE)
    ICBTAG      Icbtag;                 // ICB Tag (ICBTAG_FILE_T_FILE)
    ULONG       UID;                    // User ID of file's owner
    ULONG       GID;                    // Group ID of file's owner
    ULONG       Permissions;            // File Permissions
    USHORT      LinkCount;              // File hard-link count
    UCHAR       RecordFormat;           // Record Format
    UCHAR       RecordDisplay;          // Record Display Attributes
    ULONG       RecordLength;           // Record Length
    ULONGLONG   InfoLength;             // Information Length (file size)
    ULONGLONG   BlocksRecorded;         // Logical Blocks Recorded
    TIMESTAMP   AccessTime;             // Last-Accessed Time
    TIMESTAMP   ModifyTime;             // Last-Modification Time
    TIMESTAMP   AttributeTime;          // Last-Attribute-Change Time
    ULONG       Checkpoint;             // File Checkpoint
    LONGAD      IcbEA;                  // Extended Attribute ICB
    REGID       ImpUseID;               // Implementation Use Identifier
    ULONGLONG   UniqueID;               // Unique ID
    ULONG       EALength;               // Length of Extended Attributes
    ULONG       AllocLength;            // Length of Allocation Descriptors
    UCHAR       EAs[1];                 // Extended Attributes

//  icbfile_EAs has a variant length = icbfile_EALength

    UCHAR       Allocs[0];              // Allocation Descriptors.

//  icbfile_Allocs has a variant starting offset due to icbfile_EAs.
//  icbfile_Allocs has a variant length = icbfile_AllocLen.

} ICBFILE, *PICBFILE;


//  Definitions for icbfile_Permissions (4/14.9.6)

#define ICBFILE_PERM_OTH_X  (0x00000001)    // Other: Execute OK
#define ICBFILE_PERM_OTH_W  (0x00000002)    // Other: Write OK
#define ICBFILE_PERM_OTH_R  (0x00000004)    // Other: Read OK
#define ICBFILE_PERM_OTH_A  (0x00000008)    // Other: Set Attributes OK
#define ICBFILE_PERM_OTH_D  (0x00000010)    // Other: Delete OK
#define ICBFILE_PERM_GRP_X  (0x00000020)    // Group: Execute OK
#define ICBFILE_PERM_GRP_W  (0x00000040)    // Group: Write OK
#define ICBFILE_PERM_GRP_R  (0x00000080)    // Group: Read OK
#define ICBFILE_PERM_GRP_A  (0x00000100)    // Group: Set Attributes OK
#define ICBFILE_PERM_GRP_D  (0x00000200)    // Group: Delete OK
#define ICBFILE_PERM_OWN_X  (0x00000400)    // Owner: Execute OK
#define ICBFILE_PERM_OWN_W  (0x00000800)    // Owner: Write OK
#define ICBFILE_PERM_OWN_R  (0x00001000)    // Owner: Read OK
#define ICBFILE_PERM_OWN_A  (0x00002000)    // Owner: Set Attributes OK
#define ICBFILE_PERM_OWN_D  (0x00004000)    // Owner: Delete OK

//  (4/14.9.7) Record Format
//      Skipped

//  (4/14.9.8) Record Display Attributes
//      Skipped


/***    nsr_eah - Extended Attributes Header Descriptor (4/14.10.1)
 *
 */

typedef struct  NSR_EAH {
    DESTAG      Destag;                 // Descriptor Tag (ID_NSR_XA)
    ULONG       EAImp;                  // Implementation Attributes Location
    ULONG       EAApp;                  // Application Attributes Location
} NSR_EAH, *PNSR_EAH;


/***    nsr_ea_g - Generic Extended Attributes Format (4/14.10.2)
 *
 */

typedef struct  NSR_EA_GENERIC {
    ULONG       EAType;                 // Extended Attribute Type
    UCHAR       EASubType;              // Extended Attribute Sub Type
    UCHAR       Res5[3];                // Reserved Zeros
    ULONG       EALength;               // Extended Attribute Length
    UCHAR       EAData[0];              // Extended Attribute Data (variant!)

} NSR_EA_GENERIC, *PNSR_EA_GENERIC;

//
//  Extended Attribute Types (14.4.10)
//

#define EA_TYPE_CHARSET     1
#define EA_TYPE_ALTPERM     3
#define EA_TYPE_FILETIMES   5
#define EA_TYPE_INFOTIMES   6
#define EA_TYPE_DEVICESPEC  12
#define EA_TYPE_IMPUSE      2048
#define EA_TYPE_APPUSE      65536

#define EA_SUBTYPE_BASE     1


//  (4/14.10.3) Character Set Information Extended Attribute Format
//      Skipped

//  (4/14.10.4) Alternate Permissions Extended Attribute Format
//      Skipped

//  (4/14.10.5) File Times Extended Attribute Format

typedef struct  NSR_EA_FILETIMES {
    ULONG       EAType;                 // Extended Attribute Type
    UCHAR       EASubType;              // Extended Attribute Sub Type
    UCHAR       Res5[3];                // Reserved Zeros
    ULONG       EALength;               // Extended Attribute Length
    ULONG       DataLength;             // EAData Length
    ULONG       Existence;              // Specifies which times are recorded
    TIMESTAMP   Stamps[0];              // Timestamps (variant!)

} NSR_EA_FILETIMES, *PNSR_EA_FILETIMES;


//  Definitions for nsr_ea_filetimes_Existence (4/14.10.5.6)

#define EA_FILETIMES_E_CREATION     (0x00000001)
#define EA_FILETIMES_E_DELETION     (0x00000004)
#define EA_FILETIMES_E_EFFECTIVE    (0x00000008)
#define EA_FILETIMES_E_LASTBACKUP   (0x00000020)


//  (4/14.10.6) Information Times Extended Attribute Format
//
//  Exactly the same as an NSR_EA_FILETIMES

//  Definitions for nsr_ea_infotimes_Existence (4/14.10.6.6)

#define EA_INFOTIMES_E_CREATION     (0x00000001)
#define EA_INFOTIMES_E_MODIFICATION (0x00000002)
#define EA_INFOTIMES_E_EXPIRATION   (0x00000004)
#define EA_INFOTIMES_E_EFFECTIVE    (0x00000008)


//  (4/14.10.7) Device Specification Extended Attribute Format
//      Skipped

//  (4/14.10.8) Implementation Use Extended Attribute Format
//      Skipped

//  (4/14.10.9) Application Use Extended Attribute Format
//      Skipped


/***    icbuase - Unallocated Space Entry (4/14.11)
 *
 *      icbuase_destag.destag_Ident = DESTAG_ID_NSR_UASE
 *      icbuase_icbtag.icbtag_FileType = ICBTAG_FILE_T_UASE
 *
 */

typedef struct  ICBUASE {
    DESTAG      Destag;                 // Descriptor Tag (ID_NSR_ICBUASE)
    ICBTAG      Icbtag;                 // ICB Tag (ICBTAG_FILE_T_UASE)
    ULONG       AllocLen;               // Allocation Descriptors Length
    UCHAR       Allocs[0];              // Allocation Descriptors (variant!)

//  The true length of this structure may vary!
//  icbuase_Allocs has a variant length = icbuase_AllocLen;

} ICBUASE, *PICBUASE;


/***    nsr_sbd - Space Bitmap Descriptor (4/14.12)
 *
 *      nsr_sbd_destag.destag_Ident = DESTAG_ID_NSR_SBD
 *
 */

typedef struct  NSR_SBD {
    DESTAG      Destag;                 // Descriptor Tag (DESTAG_ID_NSR_SBD)
    ULONG       BitCount;               // Number of bits in Space Bitmap
    ULONG       ByteCount;              // Number of bytes in Space Bitmap
    UCHAR       Bits[0];                // Space Bitmap (variant!)

//  The true length of this structure may vary!
//  nsr_sbd_Bits has a variant length = nsr_sbd_ByteCount;

} NSR_SBD, *PNSR_SBD;


/***    icbpinteg - Partition Integrity ICB Entry (4/14.13)
 *
 */

typedef struct  ICBPINTEG {
    DESTAG      Destag;                 // Descriptor Tag (ID_NSR_PINTEG)
    ICBTAG      Icbtag;                 // ICB Tag (ICBTAG_FILE_T_PINTEG)
    TIMESTAMP   Recording;              // Recording Time
    UCHAR       IntegType;              // Integrity Type (ICBPINTEG_T_...)
    UCHAR       Res49[175];             // Reserved Zeros
    REGID       ImpUseID;               // Implemetation Use Identifier
    UCHAR       ImpUse[256];            // Implemetation Use Area
} ICBPINTEG, *PICBPINTEG;

//  ICBPINTEG_T_... - Values for icbpinteg_IntegType

#define ICBPINTEG_T_OPEN        0       // Open Partition Integrity Entry
#define ICBPINTEG_T_CLOSE       1       // Close Partition Integrity Entry
#define ICBPINTEG_T_STABLE      2       // Stable Partition Integrity Entry


/***    (4/14.14.1) Short Allocation Descriptor
 ***    (4/14.14.2) Long Allocation Descriptor
 ***    (4/14.14.3) Extended Allocation Descriptor
 *
 *      See SHORTAD, LONGAD, EXTAD, already defined above.
 *
 */


/***    nsr_lvhd - Logical Volume Header Descriptor (4/14.15)
 *
 *      The definition is moved to before Logical Volume Integrity
 *      Descriptor.
 *
 */


/***    nsr_path - Path Component (4/14.16)
 *
 */

typedef struct  NSR_PATH {
    UCHAR       Type;                   // Path Component Type (NSR_PATH_T_...)
    UCHAR       CompLen;                // Path Component Length
    UCHAR       CompVer;                // Path Component Version
    UCHAR       Comp[0];                // Path Component Identifier (variant!)

//  nsr_path_Comp has a variant length = nsr_path_CompLen

} NSR_PATH, *PNSR_PATH;

//  NSR_PATH_T_... - Values for nsr_path_Type

#define NSR_PATH_T_RESERVED     0       // Reserved Value
#define NSR_PATH_T_OTHER_ROOT   1       // Another root directory, by agreement
#define NSR_PATH_T_ROOTDIR      2       // Root Directory ('\')
#define NSR_PATH_T_PARENTDIR    3       // Parent Directory ('..')
#define NSR_PATH_T_CURDIR       4       // Current Directory ('.')
#define NSR_PATH_T_FILE         5       // File


/***    ISO 13346 Part 5: Record Structure
 *
 *      Skipped
 *
 */

//
//  Restore the standard structure packing.
//

#pragma pack()
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\udfx\read.c ===
/*++

Copyright (c) 2000-2001  Microsoft Corporation

Module Name:

    read.c

Abstract:

    This module implements routines related to handling IRP_MJ_READ.

--*/

#include "udfx.h"

NTSTATUS
UdfxNonCachedReadCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )
/*++

Routine Description:

    This routine is called to process the completion of a non-cached file read.

Arguments:

    DeviceObject - Specifies the device object that the I/O request is for.

    Irp - Specifies the packet that describes the I/O request.

    Context - Specifies the context that was supplied to IoSetCompletionRoutine.

Return Value:

    Status of operation.

--*/
{
    PIO_STACK_LOCATION IrpSp;
    PFILE_OBJECT FileObject;
    ULONG ReadLength;

    //
    // This completion routine is set to be called only on IRP success.
    //

    ASSERT(NT_SUCCESS(Irp->IoStatus.Status));

    IrpSp = IoGetCurrentIrpStackLocation(Irp);
    FileObject = IrpSp->FileObject;
    ReadLength = IrpSp->Parameters.Read.Length;

    //
    // Assert that the device handled as many bytes as we programmed it to.
    //

    ASSERT(Irp->IoStatus.Information == UDF_CD_SECTOR_ALIGN_UP(ReadLength));

    //
    // Propagate the pending flag up the IRP stack.
    //

    if (Irp->PendingReturned) {
        IoMarkIrpPending(Irp);
    }

    //
    // Fix the number of bytes read to the number that we computed inside
    // UdfxFsdRead.  This number may be less than the actual number of bytes
    // read from the device if we're at the end of file.
    //

    Irp->IoStatus.Information = ReadLength;

    //
    // If the file is open for synchronous I/O, then we need to update the
    // current file position.
    //

    if (UdfxIsFlagSet(FileObject->Flags, FO_SYNCHRONOUS_IO)) {
        FileObject->CurrentByteOffset.QuadPart =
            IrpSp->Parameters.Read.ByteOffset.QuadPart + ReadLength;
    }

    return STATUS_SUCCESS;
}

NTSTATUS
UdfxFsdRead(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    This routine is called by the I/O manager to handle IRP_MJ_READ requests.

Arguments:

    DeviceObject - Specifies the device object that the I/O request is for.

    Irp - Specifies the packet that describes the I/O request.

Return Value:

    Status of operation.

--*/
{
    NTSTATUS status;
    PUDF_VOLUME_EXTENSION VolumeExtension;
    PIO_STACK_LOCATION IrpSp;
    PIO_STACK_LOCATION NextIrpSp;
    PFILE_OBJECT FileObject;
    PUDF_FCB Fcb;
    ULONG ReadLength;
    BOOLEAN NonCachedEndOfFileTransfer;
    ULONGLONG FileBytesRemaining;
    ULONGLONG PhysicalByteOffset;

    VolumeExtension = (PUDF_VOLUME_EXTENSION)DeviceObject->DeviceExtension;
    IrpSp = IoGetCurrentIrpStackLocation(Irp);
    NextIrpSp = IoGetNextIrpStackLocation(Irp);
    FileObject = IrpSp->FileObject;
    Fcb = (PUDF_FCB)FileObject->FsContext;
    ReadLength = IrpSp->Parameters.Read.Length;
    NonCachedEndOfFileTransfer = FALSE;

    //
    // Check if the volume has been dismounted.
    //

    if (VolumeExtension->Dismounted) {
        status = STATUS_VOLUME_DISMOUNTED;
        goto CleanupAndExit;
    }

    //
    // Ensure that the file object is not for a directory.
    //

    if (UdfxIsFlagSet(Fcb->Flags, UDF_FCB_DIRECTORY)) {
        status = STATUS_INVALID_DEVICE_REQUEST;
        goto CleanupAndExit;
    }

    //
    // Disable support for reading from files with data embedded in the file
    // identifier descriptor.
    //

    if (UdfxIsFlagSet(Fcb->Flags, UDF_FCB_EMBEDDED_DATA)) {
        status = STATUS_ACCESS_DENIED;
        goto CleanupAndExit;
    }

    //
    // If this is a zero length request, then we can complete the IRP now.
    //

    if (ReadLength == 0) {
        Irp->IoStatus.Information = 0;
        status = STATUS_SUCCESS;
        goto CleanupAndExit;
    }

    //
    // Check if the starting offset is beyond the end of file.
    //

    if ((ULONGLONG)IrpSp->Parameters.Read.ByteOffset.QuadPart >=
        (ULONGLONG)Fcb->FileSize.QuadPart) {
        status = STATUS_END_OF_FILE;
        goto CleanupAndExit;
    }

    //
    // If the number of bytes to read is greater than the number of bytes
    // remaining in the file, then truncate the number of bytes we'll actually
    // read.
    //

    FileBytesRemaining = (ULONGLONG)Fcb->FileSize.QuadPart -
        (ULONGLONG)IrpSp->Parameters.Read.ByteOffset.QuadPart;

    if ((ULONGLONG)ReadLength >= FileBytesRemaining) {

        if (UdfxIsFlagClear(Fcb->Flags, UDF_FCB_VOLUME)) {

            //
            // If the user's buffer is large enough to hold the logical read
            // length rounded up to a sector boundary, then set a flag so that
            // the below code will potentially read this part of the file as
            // non cached.
            //

            if (ReadLength >= (UDF_CD_SECTOR_ALIGN_UP(Fcb->FileSize.LowPart) -
                IrpSp->Parameters.Read.ByteOffset.LowPart)) {
                NonCachedEndOfFileTransfer = TRUE;
            }
        }

        ReadLength = (ULONG)FileBytesRemaining;
    }

    ASSERT(ReadLength > 0);

    //
    // Check if we're supposed to bypass the file system cache.
    //
    // If this is a physical volume file control block, also bypass the cache.
    // This was the behavior of the old file systems and it also let's us avoid
    // having to deal with the volume case in the cached path.
    //

    if (UdfxIsFlagSet(Irp->Flags, IRP_NOCACHE) ||
        UdfxIsFlagSet(Fcb->Flags, UDF_FCB_VOLUME)) {

        IoCopyCurrentIrpStackLocationToNext(Irp);

        //
        // Lock the user's buffer into memory if necessary.
        //

        IoLockUserBuffer(Irp, IrpSp->Parameters.Read.Length);

        //
        // The file is contiguous on disk, so we can pass this IRP down to the
        // target device after adjusting the starting byte offset assuming this
        // isn't a volume file control block.
        //

        if (UdfxIsFlagClear(Fcb->Flags, UDF_FCB_VOLUME)) {
            NextIrpSp->Parameters.Read.ByteOffset.QuadPart +=
                ((ULONGLONG)(VolumeExtension->PartitionSectorStart +
                Fcb->AllocationSectorStart) << UDF_CD_SECTOR_SHIFT);
        }

        //
        // Limit the number of bytes physically read to the end of the file or
        // volume.
        //

        NextIrpSp->Parameters.Read.Length = UDF_CD_SECTOR_ALIGN_UP(ReadLength);

        //
        // If the actual number of bytes we're to read is less than the number
        // of bytes we'll read from the physical device, then set a completion
        // routine to fix IO_STATUS_BLOCK.Information to be the actual number
        // of bytes.  We'll store the actual number of bytes back in the IRP so
        // that we don't have to calculate it again.
        //
        // If this is a synchronous I/O operation, then set a completion routine
        // so that we can update the current file position.
        //
        // We don't have to do either of the above if the IRP completes with an
        // error.
        //

        if ((IrpSp->Parameters.Read.Length != ReadLength) ||
            UdfxIsFlagSet(FileObject->Flags, FO_SYNCHRONOUS_IO)) {

            IrpSp->Parameters.Read.Length = ReadLength;

            IoSetCompletionRoutine(Irp, UdfxNonCachedReadCompletion, NULL, TRUE,
                FALSE, FALSE);
        }

        //
        // Call down to the target device.
        //

        return IoCallDriver(VolumeExtension->TargetDeviceObject, Irp);
    }

    //
    // Scatter/gather operations are always non-cached.
    //

    ASSERT(UdfxIsFlagClear(Irp->Flags, IRP_SCATTER_GATHER_OPERATION));

    //
    // Otherwise, handle reading the data using the file cache.
    //

    PhysicalByteOffset = IrpSp->Parameters.Read.ByteOffset.QuadPart +
        ((ULONGLONG)(VolumeExtension->PartitionSectorStart +
        Fcb->AllocationSectorStart) << UDF_CD_SECTOR_SHIFT);

    status = FscCachedRead(&VolumeExtension->CacheExtension, Irp,
        PhysicalByteOffset, ReadLength, NonCachedEndOfFileTransfer);

CleanupAndExit:
    Irp->IoStatus.Status = status;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\udfx\mountvol.c ===
/*++

Copyright (c) 2000-2001  Microsoft Corporation

Module Name:

    mountvol.c

Abstract:

    This module implements routines related to the mounting of a UDF volume.

--*/

#include "udfx.h"

//
// Define a lookup table to map from VSD identifier string to its corresponding
// VSD identifier enumeration.
//

#include <pshpack1.h>

typedef struct _VSD_IDENT_LOOKUP_TABLE {
    UCHAR Ident[VSD_LENGTH_IDENT];
    UCHAR IdentEnum;
} VSD_IDENT_LOOKUP_TABLE, *PVSD_IDENT_LOOKUP_TABLE;

#include <poppack.h>

// C4295: array is too small to include a terminating null character
#pragma warning(disable:4295)

const VSD_IDENT_LOOKUP_TABLE UdfxVsdIdentLookupTable[] = {
    VSD_IDENT_BEA01, VsdIdentBEA01,
    VSD_IDENT_TEA01, VsdIdentTEA01,
    VSD_IDENT_CDROM, VsdIdentCDROM,
    VSD_IDENT_CD001, VsdIdentCD001,
    VSD_IDENT_NSR01, VsdIdentNSR01,
    VSD_IDENT_NSR02, VsdIdentNSR02,
    VSD_IDENT_CDW01, VsdIdentCDW01,
    VSD_IDENT_CDW02, VsdIdentCDW02,
    VSD_IDENT_BOOT2, VsdIdentBOOT2
};

#pragma warning(default:4295)

//
// Entity identifier for a ECMA-167 standard partition.
//
const UCHAR UdfxNSR02Regid[REGID_LENGTH_IDENT] = NSR_PART_CONTID_NSR02;

//
// Entity identifier for a UDF standard volume.
//
const UCHAR UdfxOSTAUdfRegid[REGID_LENGTH_IDENT] = "*OSTA UDF Compliant";

//
// Character set specification for a UDF partition.
//
const CHARSPEC UdfxCS0Identifier = {
    CHARSPEC_T_CS0, "OSTA Compressed Unicode"
};

NTSTATUS
UdfxCreateVolumeDevice(
    IN PDEVICE_OBJECT TargetDeviceObject,
    IN PDISK_GEOMETRY DiskGeometry,
    OUT PDEVICE_OBJECT *ReturnedVolumeDeviceObject
    )
/*++

Routine Description:

    This routine creates an instance of a volume device object.

Arguments:

    TargetDeviceObject - Specifies the device object that the volume object
        sends I/O requests to.

    DiskGeometry - Specifies the disk geometry of the target device.

    ReturnedVolumeDeviceObject - Specifies the buffer to receive the created
        device object.

Return Value:

    Status of operation.

--*/
{
    NTSTATUS status;
    PDEVICE_OBJECT VolumeDeviceObject;
    PUDF_VOLUME_EXTENSION VolumeExtension;
    PUDF_FCB VolumeFcb;

    //
    // Create the volume's device object.
    //

    status = IoCreateDevice(&UdfxDriverObject, sizeof(UDF_VOLUME_EXTENSION),
        NULL, FILE_DEVICE_CD_ROM_FILE_SYSTEM, FALSE, &VolumeDeviceObject);

    if (!NT_SUCCESS(status)) {
        return status;
    }

    //
    // Increase the volume's IRP stack size for requests that we pass down to
    // the target device object.
    //

    VolumeDeviceObject->StackSize = (UCHAR)(VolumeDeviceObject->StackSize +
        TargetDeviceObject->StackSize);

    //
    // Ensure that the alignment for this device matches the requirements of the
    // target device.
    //

    if (VolumeDeviceObject->AlignmentRequirement < TargetDeviceObject->AlignmentRequirement) {
        VolumeDeviceObject->AlignmentRequirement = TargetDeviceObject->AlignmentRequirement;
    }

    //
    // If the target device object supports scatter gather I/O, then indicate
    // that we can as well.
    //

    if (UdfxIsFlagSet(TargetDeviceObject->Flags, DO_SCATTER_GATHER_IO)) {
        VolumeDeviceObject->Flags |= DO_SCATTER_GATHER_IO;
    }

    //
    // Set the size of a sector for this device.
    //

    VolumeDeviceObject->SectorSize = UDF_CD_SECTOR_SIZE;

    //
    // Increment the reference count on the target device object since we'll be
    // holding a pointer to it.
    //

    ObReferenceObject(TargetDeviceObject);

    //
    // Initialize the volume's device extension data.
    //

    VolumeExtension = (PUDF_VOLUME_EXTENSION)VolumeDeviceObject->DeviceExtension;

    VolumeExtension->TargetDeviceObject = TargetDeviceObject;
    VolumeExtension->SectorSize = UDF_CD_SECTOR_SIZE;
    VolumeExtension->PhysicalSectorCount = DiskGeometry->Cylinders.LowPart;

    //
    // Allocate the file control block for the physical volume.
    //

    VolumeFcb = ExAllocatePoolWithTag(sizeof(UDF_FCB), 'cVxU');

    if (VolumeFcb == NULL) {
        UdfxDeleteVolumeDevice(VolumeDeviceObject);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    VolumeExtension->VolumeFcb = VolumeFcb;
    VolumeExtension->RootDirectoryFcb = NULL;

    //
    // Initialize the file control block for the physical volume.
    //

    RtlZeroMemory(VolumeFcb, sizeof(UDF_FCB));

    VolumeFcb->Flags = UDF_FCB_VOLUME;
    VolumeFcb->ReferenceCount = 1;

    InitializeListHead(&VolumeFcb->SiblingFcbLink);

    //
    // The device has finished initializing and is ready to accept requests.
    //

    VolumeDeviceObject->Flags &= ~DO_DEVICE_INITIALIZING;

    //
    // Return the device object to the caller.
    //

    *ReturnedVolumeDeviceObject = VolumeDeviceObject;

    return STATUS_SUCCESS;
}

VOID
UdfxDeleteVolumeDevice(
    IN PDEVICE_OBJECT VolumeDeviceObject
    )
/*++

Routine Description:

    This routine deletes an instance of a volume device object.

Arguments:

    VolumeDeviceObject - Specifies the volume device object to delete.

Return Value:

    Status of operation.

--*/
{
    PUDF_VOLUME_EXTENSION VolumeExtension;

    VolumeExtension = (PUDF_VOLUME_EXTENSION)VolumeDeviceObject->DeviceExtension;

    //
    // There shouldn't be any open files for this volume.
    //

    ASSERT(VolumeExtension->FileObjectCount == 0);

    //
    // Delete any file control blocks created by the volume.
    //

    if (VolumeExtension->VolumeFcb != NULL) {
        UdfxDereferenceFcb(VolumeExtension->VolumeFcb);
    }

    if (VolumeExtension->RootDirectoryFcb != NULL) {
        UdfxDereferenceFcb(VolumeExtension->RootDirectoryFcb);
    }

    //
    // Invalidate any file system cache buffers for this device.
    //

    FscInvalidateDevice(&VolumeExtension->CacheExtension);

    //
    // Release the reference on the target device object.
    //

    if (VolumeExtension->TargetDeviceObject != NULL) {
        ObDereferenceObject(VolumeExtension->TargetDeviceObject);
    }

    //
    // Delete the device object.
    //

    IoDeleteDevice(VolumeDeviceObject);
}

NTSTATUS
UdfxReadPhysicalSector(
    IN PUDF_VOLUME_EXTENSION VolumeExtension,
    IN ULONG PhysicalSectorNumber,
    OUT PVOID Buffer
    )
/*++

Routine Description:

    This routine reads from the supplied device object a single physical sector.

Arguments:

    VolumeExtension - Specifies the volume extension to read from.

    PhysicalSectorNumber - Specifies the physical sector number to read.

    Buffer - Specifies the buffer to read the data into.

Return Value:

    Status of operation.

--*/
{
    LARGE_INTEGER ByteOffset;

    //
    // Verify that the physical sector resides inside the disk.
    //

    if (PhysicalSectorNumber >= VolumeExtension->PhysicalSectorCount) {
        return STATUS_DISK_CORRUPT_ERROR;
    }

    //
    // Read the physical sector.
    //

    ByteOffset.QuadPart = (ULONGLONG)PhysicalSectorNumber << UDF_CD_SECTOR_SHIFT;

    return IoSynchronousFsdRequest(IRP_MJ_READ, VolumeExtension->TargetDeviceObject,
        Buffer, UDF_CD_SECTOR_SIZE, &ByteOffset);
}

NTSTATUS
UdfxRecognizeVolume(
    IN PUDF_VOLUME_EXTENSION VolumeExtension
    )
/*++

Routine Description:

    This routine checks if a UDF volume is in the specified device.

    Refer to ISO 13346 section 2/8.

Arguments:

    VolumeExtension - Specifies the extension for the volume to mount.

Return Value:

    Status of operation.

--*/
{
    NTSTATUS status;
    PVSD_GENERIC VolumeStructureDescriptor;
    ULONG PhysicalSectorNumber;
    ULONG LookupIndex;
    VSD_IDENT VsdIdent;
    BOOLEAN FoundBEA;

    //
    // Allocate a buffer to read the descriptors into.  The buffer size must be
    // aligned to the size of a CD-ROM sector.
    //

    VolumeStructureDescriptor = (PVSD_GENERIC)ExAllocatePoolWithTag(UDF_CD_SECTOR_SIZE,
        'sVxU');

    if (VolumeStructureDescriptor == NULL) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // The volume recognition area begins at VRA_BOUNDARY_LOCATION rounded up to
    // the next sector.
    //

    PhysicalSectorNumber = UDF_CD_SECTOR_ALIGN_UP(VRA_BOUNDARY_LOCATION) >>
        UDF_CD_SECTOR_SHIFT;

    //
    // Process the volume structure descriptors.
    //

    status = STATUS_UNRECOGNIZED_VOLUME;
    FoundBEA = FALSE;

    for (;;) {

        //
        // Verify that the physical sector is in the bounds of the disk.
        //

        if (PhysicalSectorNumber >= VolumeExtension->PhysicalSectorCount) {
            status = STATUS_UNRECOGNIZED_VOLUME;
            break;
        }

        //
        // Read the next volume structure descriptor.
        //

        status = UdfxReadPhysicalSector(VolumeExtension, PhysicalSectorNumber,
            VolumeStructureDescriptor);

        if (!NT_SUCCESS(status)) {
            break;
        }

        //
        // Set up the error code for an invalid UDF volume.
        //

        status = STATUS_UNRECOGNIZED_VOLUME;

        //
        // Map the VSD identifier string to its VSD identifier enumeration.  If
        // we find an unrecognized identifier, then this can't be a UDF volume
        // that we support.
        //

        VsdIdent = VsdIdentBad;

        for (LookupIndex = 0; LookupIndex <
            ARRAY_ELEMENTS(UdfxVsdIdentLookupTable); LookupIndex++) {

            if (RtlEqualMemory(VolumeStructureDescriptor->Ident,
                UdfxVsdIdentLookupTable[LookupIndex].Ident, VSD_LENGTH_IDENT)) {
                VsdIdent = UdfxVsdIdentLookupTable[LookupIndex].IdentEnum;
                break;
            }
        }

        if (VsdIdent == VsdIdentBad) {
            UdfxDbgPrint(("UDFX: unknown VSD identifier\n"));
            break;
        }

        //
        // Process the VSD type based on the VSD identifier.
        //

        if (VolumeStructureDescriptor->Type == 0) {

            if (VsdIdent == VsdIdentBEA01) {

                //
                // Beginning Extended Area descriptor.  There should be one and
                // only one of these descriptors.
                //

                if (FoundBEA) {
                    UdfxDbgPrint(("UDFX: found multiple BEA01 descriptors\n"));
                    break;
                }

                if (VolumeStructureDescriptor->Version != 1) {
                    UdfxDbgPrint(("UDFX: found BEA01 descriptor with unknown version\n"));
                    break;
                }

                FoundBEA = TRUE;

            } else if (VsdIdent == VsdIdentNSR02) {

                //
                // NSR02 descriptor.  There should be one of these descriptors
                // following the BEA01 descriptor.
                //

                if (FoundBEA) {

                    if (VolumeStructureDescriptor->Version != 1) {
                        UdfxDbgPrint(("UDFX: found NSR02 descriptor with unknown version\n"));
                        break;
                    }

                    status = STATUS_SUCCESS;
                    break;

                } else {

                    UdfxDbgPrint(("UDFX: found NSR02 descriptor without BEA01 descriptor\n"));
                    break;
                }

            } else if (VsdIdent == VsdIdentTEA01) {

                //
                // Terminating Extended Area descriptor.  This marks the end of
                // the descriptors that could mark a UDF volume.
                //

                break;
            }

        } else if ((VolumeStructureDescriptor->Type < 3) ||
            (VolumeStructureDescriptor->Type == 255)) {

            if (FoundBEA) {
                UdfxDbgPrint(("UDFX: found unexpected descriptors after BEA01\n"));
                break;
            }

            if ((VsdIdent != VsdIdentCDROM) && (VsdIdent != VsdIdentCD001)) {
                UdfxDbgPrint(("UDFX: unknown VSD type\n"));
                break;
            }

        } else {

            UdfxDbgPrint(("UDFX: unknown VSD type\n"));
            break;
        }

        //
        // Advance to the next sector.
        //

        PhysicalSectorNumber++;
    }

    ExFreePool(VolumeStructureDescriptor);

    return status;
}

NTSTATUS
UdfxProcessAnchorVolumeDescriptor(
    IN PUDF_VOLUME_EXTENSION VolumeExtension,
    OUT PEXTENTAD MainVolumeDescriptorSequenceExtent
    )
/*++

Routine Description:

    This routine finds the anchor volume descriptor from the supplied device.

    Refer to ISO 13346 section 3/8.4.

Arguments:

    VolumeExtension - Specifies the extension for the volume to mount.

    MainVolumeDescriptorSequenceExtent - Specifies the location to receive the
        main volume descriptor sequence extent from the anchor (3/10.2.2).

Return Value:

    Status of operation.

--*/
{
    NTSTATUS status;
    PNSR_ANCHOR AnchorVolumeDescriptor;

    //
    // Allocate a buffer to read the descriptors into.  The buffer size must be
    // aligned to the size of a CD-ROM sector.
    //

    AnchorVolumeDescriptor = (PNSR_ANCHOR)ExAllocatePoolWithTag(UDF_CD_SECTOR_SIZE,
        'vAxU');

    if (AnchorVolumeDescriptor == NULL) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // Read the anchor volume descriptor from its typical location.
    //

    status = UdfxReadPhysicalSector(VolumeExtension, ANCHOR_SECTOR,
        AnchorVolumeDescriptor);

    if (NT_SUCCESS(status)) {

        if (UdfxVerifyDescriptor(&AnchorVolumeDescriptor->Destag,
            sizeof(NSR_ANCHOR), DESTAG_ID_NSR_ANCHOR, ANCHOR_SECTOR)) {

            //
            // Return the interesting fields from the descriptor back to the
            // caller.
            //

            *MainVolumeDescriptorSequenceExtent = AnchorVolumeDescriptor->Main;

            status = STATUS_SUCCESS;

        } else {

            UdfxDbgPrint(("UDFX: anchor volume descriptor not valid\n"));
            status = STATUS_DISK_CORRUPT_ERROR;
        }
    }

    ExFreePool(AnchorVolumeDescriptor);

    return status;
}

BOOLEAN
UdfxProcessPrimaryVolumeDescriptor(
    IN PNSR_PVD PrimaryVolumeDescriptor
    )
/*++

Routine Description:

    This routine validates and pulls out any interesting information from the
    supplied primary volume descriptor.

    Refer to ISO 13346 section 3/10.1.

Arguments:

    PrimaryVolumeDescriptor - Specifies the descriptor to process.

Return Value:

    Returns TRUE if the descriptor is valid, else FALSE.

--*/
{
    //
    // Verify that the volume is a single volume set.  Note that we ignore
    // VolSetSeqMax because some DVDs are authored incorrectly (Snow White).
    //

    if (PrimaryVolumeDescriptor->VolSetSeq > 1) {
        UdfxDbgPrint(("UDFX: invalid primary volume descriptor (line %d)\n", __LINE__));
        return FALSE;
    }

    //
    // Verify that the volume is using only the CS0 character set.
    //

    if ((PrimaryVolumeDescriptor->CharSetList != (1 << CHARSPEC_T_CS0)) ||
        (PrimaryVolumeDescriptor->CharSetListMax != (1 << CHARSPEC_T_CS0))) {
        UdfxDbgPrint(("UDFX: invalid primary volume descriptor (line %d)\n", __LINE__));
        return FALSE;
    }

    //
    // Verify that the volume is using the UDF domain character set.
    //

    if (!RtlEqualMemory(&PrimaryVolumeDescriptor->CharsetDesc,
            &UdfxCS0Identifier, sizeof(CHARSPEC)) ||
        !RtlEqualMemory(&PrimaryVolumeDescriptor->CharsetExplan,
            &UdfxCS0Identifier, sizeof(CHARSPEC))) {
        UdfxDbgPrint(("UDFX: invalid primary volume descriptor (line %d)\n", __LINE__));
        return FALSE;
    }

    return TRUE;
}

BOOLEAN
UdfxProcessPartitionDescriptor(
    IN PNSR_PART PartitionDescriptor,
    IN PUDF_VOLUME_EXTENSION VolumeExtension,
    OUT PUSHORT PartitionNumber
    )
/*++

Routine Description:

    This routine validates and pulls out any interesting information from the
    supplied partition descriptor.

    Refer to ISO 13346 section 3/10.5.

Arguments:

    PartitionDescriptor - Specifies the descriptor to process.

    VolumeExtension - Specifies the extension for the volume to mount.

    PartitionNumber - Specifies the buffer to receive the expected partition
        number.

Return Value:

    Returns TRUE if the descriptor is valid, else FALSE.

--*/
{
    //
    // Verify that the partition's content identifier is valid.
    //

    if (!RtlEqualMemory(&PartitionDescriptor->ContentsID.Identifier,
        &UdfxNSR02Regid, REGID_LENGTH_IDENT)) {
        UdfxDbgPrint(("UDFX: invalid partition descriptor (line %d)\n", __LINE__));
        return FALSE;
    }

    //
    // The descriptor appears to be valid.  Return any interesting information
    // in the volume extension and to the caller.
    //

    VolumeExtension->PartitionSectorStart = PartitionDescriptor->Start;
    VolumeExtension->PartitionSectorCount = PartitionDescriptor->Length;

    VolumeExtension->PartitionLength.QuadPart =
    VolumeExtension->VolumeFcb->FileSize.QuadPart =
        ((ULONGLONG)VolumeExtension->PartitionSectorStart +
        VolumeExtension->PartitionSectorCount) << UDF_CD_SECTOR_SHIFT;

    *PartitionNumber = PartitionDescriptor->Number;

    return TRUE;
}

BOOLEAN
UdfxProcessLogicalVolumeDescriptor(
    IN PNSR_LVOL LogicalVolumeDescriptor,
    IN PLONGAD FileSetDescriptorExtent,
    IN PUSHORT PartitionNumber
    )
/*++

Routine Description:

    This routine validates and pulls out any interesting information from the
    supplied logical volume descriptor.

    Refer to ISO 13346 section 3/10.6.

Arguments:

    LogicalVolumeDescriptor - Specifies the descriptor to process.

    FileSetDescriptorExtent - Specifies the buffer to receive the extents of the
        file set descriptor for the volume.

    PartitionNumber - Specifies the buffer to receive the expected partition
        number.

Return Value:

    Returns TRUE if the descriptor is valid, else FALSE.

--*/
{
    USHORT UdfVersion;
    PPARTMAP_PHYSICAL PartitionMap;

    //
    // Verify that the descriptor's size doesn't exceed the size of a sector
    // and that the volume's block size is equal to the device's sector size.
    //

    if ((ISONsrLvolSize(LogicalVolumeDescriptor) > UDF_CD_SECTOR_SIZE) ||
        (LogicalVolumeDescriptor->BlockSize != UDF_CD_SECTOR_SIZE)) {
        UdfxDbgPrint(("UDFX: invalid logical volume descriptor (line %d)\n", __LINE__));
        return FALSE;
    }

    //
    // Verify that the volume is using the UDF domain.
    //

    if (!RtlEqualMemory(&LogicalVolumeDescriptor->DomainID.Identifier,
        &UdfxOSTAUdfRegid, REGID_LENGTH_IDENT)) {
        UdfxDbgPrint(("UDFX: invalid logical volume descriptor (line %d)\n", __LINE__));
        return FALSE;
    }

    //
    // Verify that this is a supported UDF version.
    //

    UdfVersion = *((PUSHORT)&LogicalVolumeDescriptor->DomainID.Suffix[0]);

    if ((UdfVersion < UDF_VERSION_MINIMUM) || (UdfVersion > UDF_VERSION_MAXIMUM)) {
        UdfxDbgPrint(("UDFX: unsupported UDF version %04x\n", UdfVersion));
        return FALSE;
    }

    //
    // Verify that the volume is using the UDF domain character set.
    //

    if (!RtlEqualMemory(&LogicalVolumeDescriptor->Charset, &UdfxCS0Identifier,
        sizeof(CHARSPEC))) {
        UdfxDbgPrint(("UDFX: invalid logical volume descriptor (line %d)\n", __LINE__));
        return FALSE;
    }

    //
    // Only allow one partition in the logical volume (level 1 medium
    // interchange).
    //

    if ((LogicalVolumeDescriptor->MapTableCount > 1) ||
        (LogicalVolumeDescriptor->MapTableLength < sizeof(PARTMAP_PHYSICAL))) {
        UdfxDbgPrint(("UDFX: invalid logical volume descriptor (line %d)\n", __LINE__));
        return FALSE;
    }

    //
    // Verify that this is a physical partition type of the expected size and
    // that this is a single volume set.
    //

    PartitionMap = (PPARTMAP_PHYSICAL)LogicalVolumeDescriptor->MapTable;

    if ((PartitionMap->Type != PARTMAP_TYPE_PHYSICAL) ||
        (PartitionMap->Length != sizeof(PARTMAP_PHYSICAL)) ||
        (PartitionMap->VolSetSeq > 1)) {
        UdfxDbgPrint(("UDFX: invalid partition map descriptor (line %d)\n", __LINE__));
        return FALSE;
    }

    //
    // The descriptor appears to be valid.  Return any interesting information
    // back to the caller.
    //

    *FileSetDescriptorExtent = LogicalVolumeDescriptor->FSD;
    *PartitionNumber = PartitionMap->Partition;

    return TRUE;
}

NTSTATUS
UdfxProcessVolumeDescriptorSequence(
    IN PUDF_VOLUME_EXTENSION VolumeExtension,
    IN PEXTENTAD VolumeDescriptorSequenceExtent,
    OUT PLONGAD FileSetDescriptorExtent
    )
/*++

Routine Description:

    This routine processes the volume data structures bounded by the supplied
    volume descriptor sequence extents.

Arguments:

    VolumeExtension - Specifies the extension for the volume to mount.

    VolumeDescriptorSequenceExtent - Specifies the extents of the volume
        descriptor sequence area.

    FileSetDescriptorExtent - Specifies the buffer to receive the extents of the
        file set descriptor for the volume.

Return Value:

    Status of operation.

--*/
{
    NTSTATUS status;
    PNSR_VD_GENERIC VolumeDataStructure;
    BOOLEAN SeenPrimaryVolumeDescriptor;
    ULONG PrevailingPVDVolDescSeqNum;
    BOOLEAN SeenPartitionDescriptor;
    ULONG PrevailingPartitionVolDescSeqNum;
    BOOLEAN SeenLogicalVolumeDescriptor;
    ULONG PrevailingLVOLVolDescSeqNum;
    USHORT PartitionNumber;
    USHORT ExpectedPartitionNumber;
    ULONG LogicalSectorNumber;
    ULONG EndingLogicalSectorNumber;
    PNSR_PVD PrimaryVolumeDescriptor;
    PNSR_LVOL LogicalVolumeDescriptor;
    PNSR_PART PartitionDescriptor;

    //
    // Verify that the extent is correctly formed (3/7.1).
    //

    if ((VolumeDescriptorSequenceExtent->Len == 0) ||
        !UdfxIsSectorAligned(VolumeDescriptorSequenceExtent->Len)) {
        return STATUS_DISK_CORRUPT_ERROR;
    }

    //
    // Allocate a buffer to read the descriptors into.  The buffer size must be
    // aligned to the size of a CD-ROM sector.
    //

    VolumeDataStructure = (PNSR_VD_GENERIC)ExAllocatePoolWithTag(UDF_CD_SECTOR_SIZE,
        'dVxU');

    if (VolumeDataStructure == NULL) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // Reset the state variables before we begin processing the descriptors.
    //

    SeenPrimaryVolumeDescriptor = FALSE;
    PrevailingPVDVolDescSeqNum = 0;
    SeenPartitionDescriptor = FALSE;
    PrevailingPartitionVolDescSeqNum = 0;
    SeenLogicalVolumeDescriptor = FALSE;
    PrevailingLVOLVolDescSeqNum = 0;
    PartitionNumber = 0;
    ExpectedPartitionNumber = 0;

    //
    // The volume descriptor sequence area starts at the sector given in the
    // supplied extent structure.
    //

    status = STATUS_UNRECOGNIZED_VOLUME;
    LogicalSectorNumber = VolumeDescriptorSequenceExtent->Lsn;
    EndingLogicalSectorNumber = LogicalSectorNumber +
        (VolumeDescriptorSequenceExtent->Len >> UDF_CD_SECTOR_SHIFT);

    //
    // Process the volume data structures.
    //

    while (LogicalSectorNumber < EndingLogicalSectorNumber) {

        //
        // Read the next volume data structure.
        //

        status = UdfxReadPhysicalSector(VolumeExtension, LogicalSectorNumber,
            VolumeDataStructure);

        if (!NT_SUCCESS(status)) {
            break;
        }

        //
        // Set up the error code for an invalid UDF volume.
        //

        status = STATUS_UNRECOGNIZED_VOLUME;

        //
        // Verify that this is a valid volume data structure.
        //

        if (!UdfxVerifyDescriptor(&VolumeDataStructure->Destag,
            sizeof(NSR_VD_GENERIC), VolumeDataStructure->Destag.Ident,
            LogicalSectorNumber)) {
            UdfxDbgPrint(("UDFX: invalid descriptor (line %d)\n", __LINE__));
            break;
        }

        //
        // Process the volume data structure.
        //

        if (VolumeDataStructure->Destag.Ident == DESTAG_ID_NSR_PVD) {

            //
            // If we find a primary volume descriptor, then process it if it's
            // the prevailing descriptor.
            //

            PrimaryVolumeDescriptor = (PNSR_PVD)VolumeDataStructure;

            if (PrimaryVolumeDescriptor->VolDescSeqNum >=
                PrevailingPVDVolDescSeqNum) {

                SeenPrimaryVolumeDescriptor =
                    UdfxProcessPrimaryVolumeDescriptor(PrimaryVolumeDescriptor);

                PrevailingPVDVolDescSeqNum =
                    PrimaryVolumeDescriptor->VolDescSeqNum;
            }

        } else if (VolumeDataStructure->Destag.Ident == DESTAG_ID_NSR_PART) {

            //
            // If we find a partition descriptor, then process it if it's the
            // prevailing descriptor.
            //

            PartitionDescriptor = (PNSR_PART)VolumeDataStructure;

            if (PartitionDescriptor->VolDescSeqNum >=
                PrevailingPartitionVolDescSeqNum) {

                SeenPartitionDescriptor =
                    UdfxProcessPartitionDescriptor(PartitionDescriptor,
                    VolumeExtension, &PartitionNumber);

                PrevailingPartitionVolDescSeqNum =
                    PartitionDescriptor->VolDescSeqNum;
            }

        } else if (VolumeDataStructure->Destag.Ident == DESTAG_ID_NSR_LVOL) {

            //
            // If we find a logical volume descriptor, then process it if it's
            // the prevailing descriptor.
            //

            LogicalVolumeDescriptor = (PNSR_LVOL)VolumeDataStructure;

            if (LogicalVolumeDescriptor->VolDescSeqNum >=
                PrevailingLVOLVolDescSeqNum) {

                SeenLogicalVolumeDescriptor =
                    UdfxProcessLogicalVolumeDescriptor(LogicalVolumeDescriptor,
                    FileSetDescriptorExtent, &ExpectedPartitionNumber);

                PrevailingLVOLVolDescSeqNum =
                    LogicalVolumeDescriptor->VolDescSeqNum;
            }

        } else if (VolumeDataStructure->Destag.Ident == DESTAG_ID_NSR_TERM) {

            //
            // If we find the terminating descriptor, then we're at the end of
            // the data structures we care about.
            //
            // Refer to ISO 13346 section 3/10.9.
            //

            if (SeenPrimaryVolumeDescriptor && SeenLogicalVolumeDescriptor &&
                SeenPartitionDescriptor &&
                (PartitionNumber == ExpectedPartitionNumber)) {
                status = STATUS_SUCCESS;
            }

            break;
        }

        //
        // Advance to the next sector.
        //

        LogicalSectorNumber++;
    }

    ExFreePool(VolumeDataStructure);

    return status;
}

NTSTATUS
UdfxProcessFileSetDescriptor(
    IN PUDF_VOLUME_EXTENSION VolumeExtension,
    IN PLONGAD FileSetDescriptorExtent,
    OUT PLONGAD IcbRoot
    )
/*++

Routine Description:

    This routine processes the file set descriptor.  The search for the
    prevailing descriptor begins at the supplied extent.

    Refer to ISO 13346 section 4/14.1.

Arguments:

    VolumeDeviceObject - Specifies the volume device object that's being
        mounted.

    FileSetDescriptorExtent - Specifies the extent of the file set descriptor.

    IcbRoot - Specifies the buffer to receive the extent of the root directory
        ICB.

Return Value:

    Returns TRUE if the descriptor is valid, else FALSE.

--*/
{
    NTSTATUS status;
    PNSR_VD_GENERIC VolumeDataStructure;
    BOOLEAN SeenFileSetDescriptor;
    ULONG PrevailingFSDFileSet;
    ULONG LogicalSectorNumber;
    ULONG EndingLogicalSectorNumber;
    PNSR_FSD FileSetDescriptor;

    //
    // Verify that the extent is correctly formed (4/14.1);
    //

    if ((FileSetDescriptorExtent->Length.Length == 0) ||
        (FileSetDescriptorExtent->Length.Type != NSRLENGTH_TYPE_RECORDED) ||
        !UdfxIsSectorAligned(FileSetDescriptorExtent->Length.Length)) {
        return STATUS_DISK_CORRUPT_ERROR;
    }

    //
    // Allocate a buffer to read the descriptors into.  The buffer size must be
    // aligned to the size of a CD-ROM sector.
    //

    VolumeDataStructure = (PNSR_VD_GENERIC)ExAllocatePoolWithTag(UDF_CD_SECTOR_SIZE,
        'dVxU');

    if (VolumeDataStructure == NULL) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // Reset the state variables before we begin processing the descriptors.
    //

    SeenFileSetDescriptor = FALSE;
    PrevailingFSDFileSet = 0;

    //
    // The first file set descriptor starts at the sector given in the
    // supplied extent structure.
    //

    status = STATUS_DISK_CORRUPT_ERROR;
    LogicalSectorNumber = FileSetDescriptorExtent->Start.Lbn;
    EndingLogicalSectorNumber = LogicalSectorNumber +
        (FileSetDescriptorExtent->Length.Length >> UDF_CD_SECTOR_SHIFT);

    //
    // Process the volume data structures.
    //

    while (LogicalSectorNumber < EndingLogicalSectorNumber) {

        //
        // Verify that the logical sector resides inside the physical partition.
        //

        if (LogicalSectorNumber >= VolumeExtension->PartitionSectorCount) {
            break;
        }

        //
        // Read the next volume data structure.
        //

        status = UdfxReadPhysicalSector(VolumeExtension,
            VolumeExtension->PartitionSectorStart + LogicalSectorNumber,
            VolumeDataStructure);

        if (!NT_SUCCESS(status)) {
            break;
        }

        //
        // Set up the error code for a corrupt UDF volume.
        //

        status = STATUS_DISK_CORRUPT_ERROR;

        //
        // Verify that this is a valid volume data structure.
        //

        if (!UdfxVerifyDescriptor(&VolumeDataStructure->Destag,
            sizeof(NSR_VD_GENERIC), VolumeDataStructure->Destag.Ident,
            LogicalSectorNumber)) {
            UdfxDbgPrint(("UDFX: invalid descriptor (line %d)\n", __LINE__));
            break;
        }

        //
        // Process the volume data structure.
        //

        if (VolumeDataStructure->Destag.Ident == DESTAG_ID_NSR_FSD) {

            //
            // If we find a file set descriptor, then process it if it's the
            // prevailing descriptor.
            //

            FileSetDescriptor = (PNSR_FSD)VolumeDataStructure;

            if (FileSetDescriptor->FileSet >= PrevailingFSDFileSet) {

                *IcbRoot = FileSetDescriptor->IcbRoot;

                PrevailingFSDFileSet = FileSetDescriptor->FileSet;
                SeenFileSetDescriptor = TRUE;

                if (FileSetDescriptor->NextExtent.Length.Length != 0) {

                    //
                    // The next extent is not zero, so verify that the extent is
                    // valid and restart the loop at the new extent.
                    //

                    if ((FileSetDescriptor->NextExtent.Length.Type != NSRLENGTH_TYPE_RECORDED) ||
                        !UdfxIsSectorAligned(FileSetDescriptor->NextExtent.Length.Length)) {
                        break;
                    }

                    LogicalSectorNumber = FileSetDescriptor->NextExtent.Start.Lbn;
                    EndingLogicalSectorNumber = LogicalSectorNumber +
                        (FileSetDescriptor->NextExtent.Length.Length >>
                        UDF_CD_SECTOR_SHIFT);

                    continue;
                }
            }

        } else if (VolumeDataStructure->Destag.Ident == DESTAG_ID_NSR_TERM) {

            //
            // If we find the terminating descriptor, then we're at the end of
            // the data structures we care about.
            //
            // Refer to ISO 13346 section 4/14.2.
            //

            if (SeenFileSetDescriptor) {
                status = STATUS_SUCCESS;
            }

            break;

        } else {

            //
            // An invalid descriptor was found.  Terminate the loop since we
            // have no idea what we're in the middle of now.
            //

            break;
        }

        //
        // Advance to the next sector.
        //

        LogicalSectorNumber++;
    }

    ExFreePool(VolumeDataStructure);

    return status;
}

NTSTATUS
UdfxMountVolume(
    IN PDEVICE_OBJECT TargetDeviceObject
    )
/*++

Routine Description:

    This routine is called by the I/O manager to attempt to mount this file
    system.

Arguments:

    TargetDeviceObject - Specifies the device object to attempt to mount.

Return Value:

    Status of operation.

--*/
{
    NTSTATUS status;
    PIRP Irp;
    PDEVICE_OBJECT VolumeDeviceObject;
    PUDF_VOLUME_EXTENSION VolumeExtension;
    DISK_GEOMETRY DiskGeometry;
    EXTENTAD MainVolumeDescriptorSequenceExtent;
    LONGAD FileSetDescriptorExtent;
    LONGAD IcbRoot;

    Irp = NULL;
    VolumeDeviceObject = NULL;

    UdfxAcquireGlobalMutexExclusive();

    //
    // Get the drive geometry from the device.
    //

    status = IoSynchronousDeviceIoControlRequest(IOCTL_CDROM_GET_DRIVE_GEOMETRY,
        TargetDeviceObject, NULL, 0, &DiskGeometry, sizeof(DISK_GEOMETRY), NULL,
        FALSE);

    if (!NT_SUCCESS(status)) {
        goto CleanupAndExit;
    }

    ASSERT(DiskGeometry.Cylinders.HighPart == 0);
    ASSERT(DiskGeometry.TracksPerCylinder == 1);
    ASSERT(DiskGeometry.SectorsPerTrack == 1);
    ASSERT(DiskGeometry.BytesPerSector == UDF_CD_SECTOR_SIZE);

    //
    // Create an I/O request packet in order to submit requests to the target
    // device.
    //

    Irp = IoAllocateIrp(TargetDeviceObject->StackSize);

    if (Irp == NULL) {
        status = STATUS_INSUFFICIENT_RESOURCES;
        goto CleanupAndExit;
    }

    //
    // Create the volume's device object.
    //

    status = UdfxCreateVolumeDevice(TargetDeviceObject, &DiskGeometry,
        &VolumeDeviceObject);

    if (!NT_SUCCESS(status)) {
        goto CleanupAndExit;
    }

    VolumeExtension = (PUDF_VOLUME_EXTENSION)VolumeDeviceObject->DeviceExtension;

    //
    // See if we can recognize a UDF volume in the device.
    //

    status = UdfxRecognizeVolume(VolumeExtension);

    if (!NT_SUCCESS(status)) {
        goto CleanupAndExit;
    }

    //
    // Process the anchor volume descriptor for the volume.
    //

    status = UdfxProcessAnchorVolumeDescriptor(VolumeExtension,
        &MainVolumeDescriptorSequenceExtent);

    if (!NT_SUCCESS(status)) {
        goto CleanupAndExit;
    }

    //
    // Process the volume data structures for the volume.
    //

    status = UdfxProcessVolumeDescriptorSequence(VolumeExtension,
        &MainVolumeDescriptorSequenceExtent, &FileSetDescriptorExtent);

    if (!NT_SUCCESS(status)) {
        goto CleanupAndExit;
    }

    //
    // Process the file set descriptor for the volume.
    //

    status = UdfxProcessFileSetDescriptor(VolumeExtension,
        &FileSetDescriptorExtent, &IcbRoot);

    if (!NT_SUCCESS(status)) {
        goto CleanupAndExit;
    }

    //
    // Create the file control block for the root directory.
    //

    status = UdfxCreateFcbFromFileEntry(VolumeExtension, Irp, &IcbRoot, NULL,
        NULL, &VolumeExtension->RootDirectoryFcb);

    if (!NT_SUCCESS(status)) {
        goto CleanupAndExit;
    }

    VolumeExtension->RootDirectoryFcb->Flags |= UDF_FCB_ROOT_DIRECTORY;

    //
    // Connect the volume device object to the target device object and return
    // success.
    //

    TargetDeviceObject->MountedOrSelfDevice = VolumeDeviceObject;
    VolumeDeviceObject = NULL;

    status = STATUS_SUCCESS;

CleanupAndExit:
    if (VolumeDeviceObject != NULL) {
        UdfxDeleteVolumeDevice(VolumeDeviceObject);
    }

    if (Irp != NULL) {
        IoFreeIrp(Irp);
    }

    UdfxReleaseGlobalMutex();

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\udfx\fsctrl.c ===
/*++

Copyright (c) 2000-2001  Microsoft Corporation

Module Name:

    fsctrl.c

Abstract:

    This module implements routines related to handling
    IRP_MJ_FILE_SYSTEM_CONTROL.

--*/

#include "udfx.h"

NTSTATUS
UdfxDismountVolume(
    IN PDEVICE_OBJECT DeviceObject
    )
/*++

Routine Description:

    This routine is indirectly called by the I/O manager to handle
    FSCTL_DISMOUNT_VOLUME requests.

Arguments:

    DeviceObject - Specifies the device object that the I/O request is for.

    Irp - Specifies the packet that describes the I/O request.

Return Value:

    Status of operation.

--*/
{
    NTSTATUS status;
    PUDF_VOLUME_EXTENSION VolumeExtension;
    KIRQL OldIrql;

    UdfxAcquireGlobalMutexExclusive();

    VolumeExtension = (PUDF_VOLUME_EXTENSION)DeviceObject->DeviceExtension;

    //
    // Check if the volume is already marked for dismount.  If not, mark it for
    // dismount.
    //

    if (VolumeExtension->Dismounted) {
        status = STATUS_VOLUME_DISMOUNTED;
        goto CleanupAndExit;
    }

    VolumeExtension->Dismounted = TRUE;

    //
    // Synchronize access to the MountedOrSelfDevice with the I/O manager by
    // raising to DISPATCH_LEVEL.
    //
    // Clear out the target device object's MountedOrSelfDevice field.  That
    // will cause future accesses to the target device object to mount a new
    // file system device object.
    //

    OldIrql = KeRaiseIrqlToDpcLevel();

    VolumeExtension->TargetDeviceObject->MountedOrSelfDevice = NULL;

    KeLowerIrql(OldIrql);

    //
    // Delete the volume device if the file object count is zero.
    //

    if (VolumeExtension->FileObjectCount == 0) {
        UdfxDeleteVolumeDevice(DeviceObject);
    } else if (VolumeExtension->FileObjectCount > 1) {
        UdfxDbgPrint(("UDFX: dismounting volume %p with %d open file handles\n",
            VolumeExtension, VolumeExtension->FileObjectCount));
    }

    status = STATUS_SUCCESS;

CleanupAndExit:
    UdfxReleaseGlobalMutex();

    return status;
}

NTSTATUS
UdfxFsdFileSystemControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    This routine is called by the I/O manager to handle
    IRP_MJ_FILE_SYSTEM_CONTROL requests.

Arguments:

    DeviceObject - Specifies the device object that the I/O request is for.

    Irp - Specifies the packet that describes the I/O request.

Return Value:

    Status of operation.

--*/
{
    NTSTATUS status;
    PIO_STACK_LOCATION IrpSp;

    IrpSp = IoGetCurrentIrpStackLocation(Irp);

    switch (IrpSp->Parameters.FileSystemControl.FsControlCode) {

        case FSCTL_DISMOUNT_VOLUME:
            //
            // Note that we call indirect through our driver object so that the
            // generated code ends up being identical between GDFX/RAWX/UDFX.
            //

            status = DeviceObject->DriverObject->DriverDismountVolume(DeviceObject);
            break;

        default:
            status = STATUS_INVALID_DEVICE_REQUEST;
            break;
    }

    Irp->IoStatus.Status = status;
    Irp->IoStatus.Information = 0;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\udfx\udfx.h ===
/*++

Copyright (c) 2000-2001  Microsoft Corporation

Module Name:

    udfx.h

Abstract:

    This module contains the private data structures and procedure prototypes
    for the UDF file system driver.

--*/

#ifndef _UDFX_
#define _UDFX_

#include <ntos.h>
#include <ntddcdrm.h>
#include <ntdddisk.h>
#include "iso13346.h"

#include <pshpack4.h>

//
// DBG sensitive DbgPrint wrapper.
//

#if DBG
#define UdfxDbgPrint(x)                         DbgPrint x
#else
#define UdfxDbgPrint(x)
#endif

//
// Bit flag macros.
//

#define UdfxIsFlagSet(flagset, flag)            (((flagset) & (flag)) != 0)
#define UdfxIsFlagClear(flagset, flag)          (((flagset) & (flag)) == 0)

//
// Returns the number of elements in the supplied array.
//

#define ARRAY_ELEMENTS(array)                                                 \
    (sizeof((array)) / sizeof((array)[0]))

//
// Define the recognized version numbers of the UDF specification.
//

#define UDF_VERSION_100                         0x0100
#define UDF_VERSION_101                         0x0101
#define UDF_VERSION_102                         0x0102
#define UDF_VERSION_150                         0x0150

#define UDF_VERSION_MINIMUM                     UDF_VERSION_100
#define UDF_VERSION_MAXIMUM                     UDF_VERSION_150

//
// Define the static drive geometry for a CD-ROM device supported by this file
// system.
//

#define UDF_CD_SECTOR_SHIFT                     11
#define UDF_CD_SECTOR_SIZE                      (1 << UDF_CD_SECTOR_SHIFT)
#define UDF_CD_SECTOR_MASK                      (UDF_CD_SECTOR_SIZE - 1)

//
// Define a macro to align the supplied number of bytes down or up to the next
// sector boundary.
//

#define UDF_CD_SECTOR_ALIGN_DOWN(cb) \
    (((SIZE_T)(cb) & (~UDF_CD_SECTOR_MASK))
#define UDF_CD_SECTOR_ALIGN_UP(cb) \
    (((SIZE_T)(cb) + UDF_CD_SECTOR_SIZE - 1) & (~UDF_CD_SECTOR_MASK))

//
// Define a macro to check if a length is sector aligned.
//

#define UdfxIsSectorAligned(value) \
    ((LOGICAL)(((ULONG)(value) & UDF_CD_SECTOR_MASK) == 0))

//
// Define file control block flags.
//

#define UDF_FCB_VOLUME                          0x01
#define UDF_FCB_DIRECTORY                       0x02
#define UDF_FCB_ROOT_DIRECTORY                  0x04
#define UDF_FCB_EMBEDDED_DATA                   0x08

//
// File control block.
//

typedef struct _UDF_FCB {
    UCHAR Flags;
    UCHAR FileNameLength;
    USHORT EmbeddedDataOffset;
    ULONG AllocationSectorStart;
    LARGE_INTEGER FileSize;
    TIMESTAMP ModifyTime;
    ULONG ReferenceCount;
    struct _UDF_FCB *ParentFcb;
    LIST_ENTRY SiblingFcbLink;
    LIST_ENTRY ChildFcbList;
    OCHAR FileName[0];
} UDF_FCB, *PUDF_FCB;

//
// Volume device extension data.
//

typedef struct _UDF_VOLUME_EXTENSION {
    union {
        FSCACHE_EXTENSION CacheExtension;
        FSCACHE_EXTENSION;
    };
    PUDF_FCB VolumeFcb;
    PUDF_FCB RootDirectoryFcb;
    ULONG PhysicalSectorCount;
    ULONG PartitionSectorStart;
    ULONG PartitionSectorCount;
    ULONG FileObjectCount;
    BOOLEAN Dismounted;
} UDF_VOLUME_EXTENSION, *PUDF_VOLUME_EXTENSION;

//
// File system dismount routine.
//

NTSTATUS
UdfxDismountVolume(
    IN PDEVICE_OBJECT DeviceObject
    );

//
// IRP dispatch routines.
//

NTSTATUS
UdfxFsdClose(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
UdfxFsdCreate(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
UdfxFsdDeviceControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
UdfxFsdDirectoryControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
UdfxFsdFileSystemControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
UdfxFsdQueryInformation(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
UdfxFsdQueryVolumeInformation(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
UdfxFsdRead(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
UdfxFsdSetInformation(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

//
// Cache support routines.
//

NTSTATUS
UdfxMapLogicalSector(
    IN PUDF_VOLUME_EXTENSION VolumeExtension,
    IN PIRP Irp,
    IN ULONG LogicalSectorNumber,
    OUT PVOID *CacheBuffer
    );

//
// File control block support routines.
//

NTSTATUS
UdfxCreateFcbFromFileEntry(
    IN PUDF_VOLUME_EXTENSION VolumeExtension,
    IN PIRP Irp,
    IN PLONGAD IcbExtent,
    IN PUDF_FCB ParentFcb OPTIONAL,
    IN POBJECT_STRING FileName OPTIONAL,
    OUT PUDF_FCB *ReturnedFcb
    );

BOOLEAN
UdfxFindOpenChildFcb(
    IN PUDF_FCB DirectoryFcb,
    IN POBJECT_STRING FileName,
    OUT PUDF_FCB *ReturnedFcb
    );

VOID
UdfxDereferenceFcb(
    IN PUDF_FCB Fcb
    );

//
// Synchronization routines.
//

#define UdfxAcquireGlobalMutexExclusive() \
    RtlEnterCriticalSectionAndRegion(&UdfxGlobalMutex)

#define UdfxReleaseGlobalMutex() \
    RtlLeaveCriticalSectionAndRegion(&UdfxGlobalMutex)

//
// Miscellaneous routines.
//

BOOLEAN
UdfxVerifyDescriptor(
    IN PDESTAG Descriptor,
    IN ULONG DescriptorSize,
    IN USHORT Ident,
    IN ULONG LogicalSectorNumber
    );

BOOLEAN
UdfxEqualOSTACS0StringAndObjectString(
    IN PUCHAR OSTACS0String,
    IN SIZE_T OSTACS0StringLength,
    IN POBJECT_STRING ObjectString
    );

NTSTATUS
UdfxOSTACS0StringToObjectString(
    IN PUCHAR OSTACS0String,
    IN SIZE_T OSTACS0StringLength,
    OUT POBJECT_STRING ObjectString
    );

LARGE_INTEGER
UdfxUdfTimestampToTime(
    IN PTIMESTAMP UdfTimestamp
    );

VOID
UdfxDeleteVolumeDevice(
    IN PDEVICE_OBJECT VolumeDeviceObject
    );

//
// External symbols.
//

extern DRIVER_OBJECT UdfxDriverObject;
extern RTL_CRITICAL_SECTION UdfxGlobalMutex;

#include <poppack.h>

#endif  // UDFX
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\udfx\volinfo.c ===
/*++

Copyright (c) 2000-2001  Microsoft Corporation

Module Name:

    volinfo.c

Abstract:

    This module implements routines related to handling
    IRP_MJ_QUERY_VOLUME_INFORMATION.

--*/

#include "udfx.h"

NTSTATUS
UdfxFsdQueryVolumeInformation(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    This routine is called by the I/O manager to handle
    IRP_MJ_QUERY_VOLUME_INFORMATION requests.

Arguments:

    DeviceObject - Specifies the device object that the I/O request is for.

    Irp - Specifies the packet that describes the I/O request.

Return Value:

    Status of operation.

--*/
{
    NTSTATUS status;
    PUDF_VOLUME_EXTENSION VolumeExtension;
    PIO_STACK_LOCATION IrpSp;
    ULONG BytesWritten;
    PFILE_FS_SIZE_INFORMATION SizeInformation;
    PFILE_FS_DEVICE_INFORMATION DeviceInformation;
    PFILE_FS_ATTRIBUTE_INFORMATION AttributeInformation;

    VolumeExtension = (PUDF_VOLUME_EXTENSION)DeviceObject->DeviceExtension;
    IrpSp = IoGetCurrentIrpStackLocation(Irp);

    //
    // Clear the output buffer.
    //

    RtlZeroMemory(Irp->UserBuffer, IrpSp->Parameters.QueryVolume.Length);

    //
    // Dispatch the information class function.
    //

    status = STATUS_SUCCESS;

    switch (IrpSp->Parameters.QueryVolume.FsInformationClass) {

        case FileFsVolumeInformation:
            NOTHING;
            BytesWritten = FIELD_OFFSET(FILE_FS_VOLUME_INFORMATION, VolumeLabel);
            break;

        case FileFsSizeInformation:
            SizeInformation = (PFILE_FS_SIZE_INFORMATION)Irp->UserBuffer;
            SizeInformation->TotalAllocationUnits.QuadPart =
                VolumeExtension->PartitionLength.QuadPart >> UDF_CD_SECTOR_SHIFT;
            SizeInformation->SectorsPerAllocationUnit = 1;
            SizeInformation->BytesPerSector = UDF_CD_SECTOR_SIZE;
            BytesWritten = sizeof(FILE_FS_SIZE_INFORMATION);
            break;

        case FileFsDeviceInformation:
            DeviceInformation = (PFILE_FS_DEVICE_INFORMATION)Irp->UserBuffer;
            DeviceInformation->DeviceType =
                VolumeExtension->TargetDeviceObject->DeviceType;
            DeviceInformation->Characteristics = 0;
            BytesWritten = sizeof(FILE_FS_DEVICE_INFORMATION);
            break;

        case FileFsAttributeInformation:
            AttributeInformation =
                (PFILE_FS_ATTRIBUTE_INFORMATION)Irp->UserBuffer;
            AttributeInformation->FileSystemAttributes = 0;
            AttributeInformation->MaximumComponentNameLength = 255;
            AttributeInformation->FileSystemNameLength = sizeof(OCHAR) * 4;

            if (IrpSp->Parameters.QueryVolume.Length <
                FIELD_OFFSET(FILE_FS_ATTRIBUTE_INFORMATION, FileSystemName) +
                sizeof(OCHAR) * 4) {
                BytesWritten = FIELD_OFFSET(FILE_FS_ATTRIBUTE_INFORMATION,
                    FileSystemName);
                status = STATUS_BUFFER_OVERFLOW;
            } else {
                RtlCopyMemory(AttributeInformation->FileSystemName, OTEXT("UDFX"),
                    sizeof(OCHAR) * 4);
                BytesWritten = FIELD_OFFSET(FILE_FS_ATTRIBUTE_INFORMATION,
                    FileSystemName) + sizeof(OCHAR) * 4;
            }
            break;

        default:
            BytesWritten = 0;
            status = STATUS_INVALID_PARAMETER;
            break;
    }

    //
    // Fill in the number of bytes that we wrote to the user's buffer.
    //

    Irp->IoStatus.Information = BytesWritten;

    //
    // Check that we didn't overflow the user's buffer.  The I/O manager does
    // the initial check to make sure there's enough space for the static
    // structure for a given information class, but we might overflow the buffer
    // when copying in the variable length file name.
    //

    ASSERT(Irp->IoStatus.Information <= IrpSp->Parameters.QueryVolume.Length);

    Irp->IoStatus.Status = status;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\udfx\udfsup.c ===
/*++

Copyright (c) 2000-2001  Microsoft Corporation

Module Name:

    udfsup.c

Abstract:

    This module implements UDF file system utility routines.

--*/

#include "udfx.h"

BOOLEAN
UdfxVerifyDescriptor(
    IN PDESTAG Descriptor,
    IN ULONG DescriptorSize,
    IN USHORT Ident,
    IN ULONG LogicalSectorNumber
    )
/*++

Routine Description:

    This routine checks if the supplied descriptor tag is structurally correct.

    Refer to ISO 13346 section 3/7.2.

Arguments:

    Descriptor - Specifies the descriptor tag to verify.

    DescriptorSize - Specifies the size in bytes of the descriptor.

    Ident - Specifies the expected identifier of the tag.

    LogicalSectorNumber - Specifies the expected sector number of the tag.

Return Value:

    Returns TRUE if the descriptor is structurally correct, else FALSE.

--*/
{
    if ((Descriptor->Version == DESTAG_VER_CURRENT) &&
        (Descriptor->Ident == Ident) &&
        (Descriptor->Lbn == LogicalSectorNumber)) {
        return TRUE;
    } else {
        return FALSE;
    }
}

BOOLEAN
UdfxEqualOSTACS0StringAndObjectString(
    IN PUCHAR OSTACS0String,
    IN SIZE_T OSTACS0StringLength,
    IN POBJECT_STRING ObjectString
    )
/*++

Routine Description:

    This routine does a case insensitive comparision of a OSTA CS0 string to an
    object manager string.

Arguments:

    OSTACS0String - Specifies the OSTA CS0 string to compare.

    OSTACS0StringLength - Specifies the length of the OSTA CS0 string.

    ObjectString - Specifies the object manager string to compare.

Return Value:

    Returns TRUE if the strings are equal, else FALSE.

--*/
{
    POSTR ObjectBuffer;
    OCHAR c1;
    OCHAR c2;

    //
    // The first byte of an OSTA Compressed Unicode string is the compression
    // format, which is either going to be 8-bits per character or 16-bits per
    // character.  All other values are reserved and we'll treat as a failed
    // compare.
    //

    if (*OSTACS0String != 8) {
        return FALSE;
    }

    //
    // Advance past the compression code.
    //

    OSTACS0String++;
    OSTACS0StringLength--;

    //
    // Check if the lengths of the strings match.
    //

    if (ObjectString->Length != OSTACS0StringLength * sizeof(OCHAR)) {
        return FALSE;
    }

    ObjectBuffer = ObjectString->Buffer;

    while (OSTACS0StringLength) {

        c1 = *ObjectBuffer++;
        c2 = (OCHAR)*OSTACS0String++;

        if ((c1 != c2) && (RtlUpperChar(c1) != RtlUpperChar(c2))) {
            return FALSE;
        }

        OSTACS0StringLength -= sizeof(CHAR);
    }

    return TRUE;
}

NTSTATUS
UdfxOSTACS0StringToObjectString(
    IN PUCHAR OSTACS0String,
    IN SIZE_T OSTACS0StringLength,
    OUT POBJECT_STRING ObjectString
    )
/*++

Routine Description:

    This routine converts a OSTA CS0 string to an object manager string.

Arguments:

    OSTACS0String - Specifies the source string to convert.

    OSTACS0StringLength - Specifies the length of the source string.

    ObjectString - Specifies the buffer to receive the converted object manager
        string.

Return Value:

    Status of operation.

--*/
{
    POSTR ObjectBuffer;

    ObjectString->Buffer = NULL;

    if (OSTACS0StringLength != 0) {

        //
        // The first byte of an OSTA Compressed Unicode string is the compression
        // format, which is either going to be 8-bits per character or 16-bits
        // per character.
        //

        if (*OSTACS0String == 8) {

            //
            // Advance past the compression code.
            //

            OSTACS0String++;
            OSTACS0StringLength--;

            //
            // Allocate a buffer to receive the object manager string.
            //

            ObjectBuffer = ExAllocatePoolWithTag(OSTACS0StringLength *
                sizeof(OCHAR), 'gSxU');

            if (ObjectBuffer == NULL) {
                return STATUS_INSUFFICIENT_RESOURCES;
            }

            ObjectString->Buffer = ObjectBuffer;
            ObjectString->Length = (USHORT)(OSTACS0StringLength * sizeof(OCHAR));
            ObjectString->MaximumLength = ObjectString->Length;

            //
            // Fill in the output buffer.
            //

            RtlCopyMemory(ObjectBuffer, OSTACS0String, OSTACS0StringLength);

            return STATUS_SUCCESS;
        }
    }

    return STATUS_INVALID_PARAMETER;
}

LARGE_INTEGER
UdfxUdfTimestampToTime(
    IN PTIMESTAMP UdfTimestamp
    )
/*++

Routine Description:

    This routine converts a UDF timestamp to a NT system time.

Arguments:

    UdfTimestamp - Specifies the timestamp to convert to NT system time.

Return Value:

    Conversion to NT system time.

--*/
{
    LARGE_INTEGER SystemTime;
    TIME_FIELDS TimeField;

    TimeField.Year = UdfTimestamp->Year;
    TimeField.Month = UdfTimestamp->Month;
    TimeField.Day = UdfTimestamp->Day;
    TimeField.Hour = UdfTimestamp->Hour;
    TimeField.Minute = UdfTimestamp->Minute;
    TimeField.Second = UdfTimestamp->Second;
    TimeField.Milliseconds = 0;

    //
    // Validate the timestamp is valid and convert it to a system time.
    //

    if ((UdfTimestamp->Type <= TIMESTAMP_T_LOCAL) &&
        ((UdfTimestamp->Zone >= TIMESTAMP_Z_MIN && UdfTimestamp->Zone <= TIMESTAMP_Z_MAX) ||
            (UdfTimestamp->Zone == TIMESTAMP_Z_NONE)) &&
        RtlTimeFieldsToTime(&TimeField, &SystemTime)) {

        //
        // If necessary, convert to coordinated universal time.
        //

        if ((UdfTimestamp->Type == TIMESTAMP_T_LOCAL) &&
            (UdfTimestamp->Zone != TIMESTAMP_Z_NONE)) {
            SystemTime.QuadPart -= (ULONGLONG)UdfTimestamp->Zone * 60 * 10 * 1000 * 1000;
        }

    } else {

        SystemTime.QuadPart = 0;
    }

    return SystemTime;
}

NTSTATUS
UdfxMapLogicalSector(
    IN PUDF_VOLUME_EXTENSION VolumeExtension,
    IN PIRP Irp,
    IN ULONG LogicalSectorNumber,
    OUT PVOID *CacheBuffer
    )
/*++

Routine Description:

    This routine maps the supplied logical sector number into the file system
    cache.

Arguments:

    VolumeExtension - Specifies the extension that the I/O request is for.

    Irp - Specifies the packet that describes the I/O request.

    LogicalSectorNumber - Specifies the number of the logical sector to map into
        the cache.

    CacheBuffer - Specifies the buffer to receive the address of the mapped
        cache buffer.

Return Value:

    Status of operation.

--*/
{
    ULONGLONG ByteOffset;

    //
    // Verify that the logical sector resides inside the physical partition.
    //

    if (LogicalSectorNumber >= VolumeExtension->PartitionSectorCount) {
        return STATUS_DISK_CORRUPT_ERROR;
    }

    //
    // Convert the logical sector to the disk offset.
    //

    ByteOffset = ((ULONGLONG)VolumeExtension->PartitionSectorStart +
        LogicalSectorNumber) << UDF_CD_SECTOR_SHIFT;

    //
    // Map the directory sector into the cache.
    //

    return FscMapBuffer(&VolumeExtension->CacheExtension, Irp, ByteOffset,
        FALSE, CacheBuffer);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\inc\minix.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    minix.h

Abstract:

    Contains declarations for minix    

--*/


typedef struct _MINIX_MODE_INFO
{
    LONG Width; 
    LONG Height; 
    LONG BitDepth;
    ULONG PushBase;
    ULONG PushLimit;
    ULONG NotificationBase;    
    ULONG NotificationLimit;
    ULONG HostMemoryBase;
    ULONG HostMemoryLimit;
    
    PVOID DevFlatDma;          // Filled by SetVideoMode 
    PVOID VidMemAddress;       // Filled by SetVideoMode
    PVOID NvBase;              // Filled by SetVideoMode

} MINIX_MODE_INFO, *PMINIX_MODE_INFO;




//
// Major function codes used for the to access functions in the dispatch table
// of the minix driver object. Since this is not a real driver, the dispatch 
// function is used to pass alternate functions
//

#define IRP_MJ_MINIX_CREATE                0x00    // PMINIX_CREATE
#define IRP_MJ_MINIX_SETVIDEOMODE          0x01    // PMINIX_SETVIDEOMODE
#define IRP_MJ_MINIX_ALLOCCONTEXTDMA       0x02    // PMINIX_ALLOCCONTEXTDMA


typedef
LONG
(*PMINIX_CREATE) (
    VOID
    );

typedef
LONG
(*PMINIX_SETVIDEOMODE) (
    IN OUT PMINIX_MODE_INFO ModeInfo
    );

typedef
LONG
(*PMINIX_ALLOCCONTEXTDMA)(
    IN ULONG Dma,
    IN ULONG Class,
    IN ULONG Flags,
    IN PVOID Base,
    IN ULONG Limit
        );



LONG
MxInitSystem(
    IN PVOID Argument1
    );
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\inc\video.h ===
/*++

Copyright (c) 1991-1999 Microsoft Corporation

Module Name:

    video.h

Abstract:

    Contains all structure and routine definitions common to the video port
    driver and the video miniport drivers.

Notes:

Revision History:

--*/

#ifndef __VIDEO_H__
#define __VIDEO_H__

#include <videoagp.h>

//
// Define port driver status code.
// The values for these are the Win32 error codes
//

typedef LONG VP_STATUS;
typedef VP_STATUS *PVP_STATUS;

//
// Defines for registry information and synchronization.
//

typedef enum VIDEO_SYNCHRONIZE_PRIORITY {
    VpLowPriority,
    VpMediumPriority,
    VpHighPriority
} VIDEO_SYNCHRONIZE_PRIORITY, *PVIDEO_SYNCHRONIZE_PRIORITY;

//
//  Opaque pointer type for miniport to be used to type PEVENTs received from
//  display driver.
//

typedef struct _VIDEO_PORT_EVENT * PEVENT;

//
// Type of information requested with GetDeviceData
//

typedef enum _VIDEO_DEVICE_DATA_TYPE {
    VpMachineData,
    VpCmosData,
    VpBusData,
    VpControllerData,
    VpMonitorData
} VIDEO_DEVICE_DATA_TYPE, *PVIDEO_DEVICE_DATA_TYPE;

//
// Data returned with VpControllerData
//

typedef struct _VIDEO_HARDWARE_CONFIGURATION_DATA {
    INTERFACE_TYPE InterfaceType;
    ULONG BusNumber;
    USHORT Version;
    USHORT Revision;
    USHORT Irql;
    USHORT Vector;
    ULONG ControlBase;
    ULONG ControlSize;
    ULONG CursorBase;
    ULONG CursorSize;
    ULONG FrameBase;
    ULONG FrameSize;
} VIDEO_HARDWARE_CONFIGURATION_DATA, *PVIDEO_HARDWARE_CONFIGURATION_DATA;

//
// Define structure used to call the BIOS int 10 function
//

typedef struct _VIDEO_X86_BIOS_ARGUMENTS {
    ULONG Eax;
    ULONG Ebx;
    ULONG Ecx;
    ULONG Edx;
    ULONG Esi;
    ULONG Edi;
    ULONG Ebp;
} VIDEO_X86_BIOS_ARGUMENTS, *PVIDEO_X86_BIOS_ARGUMENTS;

#define SIZE_OF_NT4_VIDEO_PORT_CONFIG_INFO           0x42
#define SIZE_OF_NT4_VIDEO_HW_INITIALIZATION_DATA     0x28
 
//
// Debugging statements. This will remove all the debug information from the
// "free" version.
//

#if DBG
#define VideoDebugPrint(arg) VideoPortDebugPrint arg
#else
#define VideoDebugPrint(arg)
#endif

//
// Allows us to remove lots of unused code.
//

#ifndef _NTOSDEF_

#define ALLOC_PRAGMA 1
#define VIDEOPORT_API __declspec(dllimport)

#if DBG
#define PAGED_CODE() \
    if (VideoPortGetCurrentIrql() > 1 /*APC_LEVEL*/) { \
        VideoPortDebugPrint(0, "Video: Pageable code called at IRQL %d\n", VideoPortGetCurrentIrql() ); \
        ASSERT(FALSE); \
        }

#else
#define PAGED_CODE()
#endif

ULONG
DriverEntry(
    PVOID Context1
    );

#else
#define VIDEOPORT_API
#endif


#ifndef _NTOS_

//
// These are the various function prototypes of the routines that are
// provided by the kernel driver to hook out access to io ports.
//

typedef
VP_STATUS
(*PDRIVER_IO_PORT_UCHAR ) (
    ULONG_PTR Context,
    ULONG Port,
    UCHAR AccessMode,
    PUCHAR Data
    );

typedef
VP_STATUS
(*PDRIVER_IO_PORT_UCHAR_STRING ) (
    ULONG_PTR Context,
    ULONG Port,
    UCHAR AccessMode,
    PUCHAR Data,
    ULONG DataLength
    );

typedef
VP_STATUS
(*PDRIVER_IO_PORT_USHORT ) (
    ULONG_PTR Context,
    ULONG Port,
    UCHAR AccessMode,
    PUSHORT Data
    );

typedef
VP_STATUS
(*PDRIVER_IO_PORT_USHORT_STRING ) (
    ULONG_PTR Context,
    ULONG Port,
    UCHAR AccessMode,
    PUSHORT Data,
    ULONG DataLength // number of words
    );

typedef
VP_STATUS
(*PDRIVER_IO_PORT_ULONG ) (
    ULONG_PTR Context,
    ULONG Port,
    UCHAR AccessMode,
    PULONG Data
    );

typedef
VP_STATUS
(*PDRIVER_IO_PORT_ULONG_STRING ) (
    ULONG_PTR Context,
    ULONG Port,
    UCHAR AccessMode,
    PULONG Data,
    ULONG DataLength  // number of dwords
    );

#endif // _NTOS_


//
// Definition of the request packet sent from the port driver to the
// miniport driver. It reflects the parameters passed from the
// DeviceIOControl call made by the windows display driver.
// 
// N.B. The definition of the STATUS_BLOCK must be the same as the
//      the definition of IO_STATUS_BLOCK defined in ntioapi.h.
//

typedef struct _STATUS_BLOCK {

    //
    // Contains the status code of the operation.
    // This value in one of the Win32 error codes that are defined for use
    // in the video miniport drivers.
    //

    union {
       VP_STATUS Status;
       PVOID Pointer;
    };

    //
    // Information returned to the callee.
    // The meaning of the information varies from function to function. It
    // is generally used to return the minimum size for the input buffer if
    // the function takes an input buffer, or the amount of data transfered
    // back to the caller if the operation returns output.
    //

    ULONG_PTR Information;

} STATUS_BLOCK, *PSTATUS_BLOCK;

typedef struct _VIDEO_REQUEST_PACKET {

    //
    // The IO control code passed to the DeviceIoControl function by the
    // caller.
    //

    ULONG IoControlCode;

    //
    // Pointer to a status block provided by the caller. This should be
    // filled out by the callee with the appropriate information.
    //

    PSTATUS_BLOCK StatusBlock;

    //
    // Pointer to an input buffer which contains the information passed in
    // by the caller.
    //

    PVOID InputBuffer;

    //
    // Size of the input buffer
    //

    ULONG InputBufferLength;

    //
    // Pointer to an output buffer into which the data returned to the caller
    // should be stored.
    //

    PVOID OutputBuffer;

    //
    // Length of the output buffer. This buffer can not be grown by the
    // callee.
    //

    ULONG OutputBufferLength;

} VIDEO_REQUEST_PACKET, *PVIDEO_REQUEST_PACKET;

//
//  typedef for scattergather array available via GET_VIDEO_SCATTERGATHER().
//

typedef struct __VRB_SG {
    __int64   PhysicalAddress;
    ULONG     Length;
    } VRB_SG, *PVRB_SG;

//
// Opaque type for dma handle
//

typedef struct __DMA_PARAMETERS * PDMA;

//
//  The following macro returns in Address the 32 bit physical address of
//  the VirtualAddress lying within the InputBuffer passed into EngDevIo
//

#define GET_VIDEO_PHYSICAL_ADDRESS(scatterList, VirtualAddress, InputBuffer, pLength, Address)    \
                                                                                           \
        do {                                                                               \
            ULONG_PTR          byteOffset;                                                  \
                                                                                           \
            byteOffset = (PCHAR) VirtualAddress - (PCHAR)InputBuffer;                \
                                                                                           \
            while (byteOffset >= scatterList->Length) {                                    \
                                                                                           \
                byteOffset -= scatterList->Length;                                         \
                scatterList++;                                                             \
            }                                                                              \
                                                                                           \
            *pLength = scatterList->Length - byteOffset;                                   \
                                                                                           \
            Address = (ULONG_PTR) (scatterList->PhysicalAddress + byteOffset);                  \
                                                                                           \
        } while (0)


#define GET_VIDEO_SCATTERGATHER(ppDma)   (**(PVRB_SG **)ppDma)

#define VIDEO_RANGE_PASSIVE_DECODE   0x1
#define VIDEO_RANGE_10_BIT_DECODE    0x2


//
// The following structure is used to define access ranges. The ranges are
// used to indicate which ports and memory adresses are being used by the
// card.
//

typedef struct _VIDEO_ACCESS_RANGE {

    //
    // Indicates the starting memory address or port number of the range.
    // This values should be stored before being transformed by
    // VideoPortGetDeviceBase() which returns the logical address that must
    // be used by the miniport driver when referencing physical addresses.
    //

    PHYSICAL_ADDRESS RangeStart;

    //
    // Indicates the length in bytes, or number of ports in the range. This
    // value should indicate the range actually decoded by the adapter. For
    // example, if the adapter uses 7 registers but responds to eight, the
    // RangeLength should be set to 8.

    ULONG RangeLength;

    //
    // Indicates if the range is in IO space (TRUE) or in memory space (FALSE).
    //

    UCHAR RangeInIoSpace;

    //
    // Indicates if the range should be visible by the Windows display driver.
    // This is done so that a Windows display driver can access certain
    // video ports directly. This will only be allowed if the caller has the
    // required privileges (is a trusted subsystem) to access the range.
    //
    // Synchronization of access to ports or memory in the range must be
    // done explicitly by the miniport driver and the user mode process so
    // that they both don't try to program the device simultaneously.
    //
    // Non visible ranges should include video memory, ROM addresses, etc.
    // which are not required to program the device for output purposes.
    //
    //

    UCHAR RangeVisible;

    //
    // This field determines if the range can be shared with another device.
    // The rule should be applied as follow.
    //
    // - If the range of memory or IO ports should be "owned" by this driver,
    //   and that any other driver trying to access this range may cause
    //   a problem, FALSE should be returned.
    //
    // - If the range can be shared with another co-operating device driver,
    //   then the share field should be set to TRUE.
    //
    // As a guideline, the VGA miniport driver will claim all of its resources
    // as shareable so that it can be used as a VGA compatible device with
    // any other driver (such as an S3 or XGA.
    //
    // Super VGA miniport drivers that implement all the VGA functionality
    // (declared in the Registry as VGACOMPATIBLE=1) should claim the range
    // as non-shareable since they don't want the VGA to run at the same time.
    //
    // Miniports for cards such as an S3 or XGA that have an XGA on the board
    // but do not implement the VGA functionality will run with the VGA
    // miniport loaded and should therefore claim all the resources shared
    // with the VGA as shareable.
    //
    // Miniports for cards that work with a pass-through and that can be
    // connected to any VGA/SVGA card should not be using any VGA ports or
    // memory ranges ! ... but if they do they should not claim those
    // resources since they will cause a conflict in the system because the
    // SVGA cards will have claimed them as non-shareable ...
    //

    UCHAR RangeShareable;

    //
    // Indicates that the range is decoded by the hardware, but that the
    // driver will never access this port.
    //

    UCHAR RangePassive;

} VIDEO_ACCESS_RANGE, *PVIDEO_ACCESS_RANGE;



typedef
PVOID
(*PVIDEO_PORT_GET_PROC_ADDRESS)(
    IN PVOID HwDeviceExtension,
    IN PUCHAR FunctionName
    );

//
// This structure contains the specific configuration information about the
// device. The information is initialized by the port driver and it should
// be completed by the miniport driver.
// The information is used to setup the device, as weel as providing
// information to the port driver so it can perform some of the requests on
// behalf of the miniport driver.
//

typedef struct _VIDEO_PORT_CONFIG_INFO {

    //
    // Specifies the length of the PVIDEO_PORT_CONFIG_INFO structure as
    // returned by sizeof(). Since this structure may grow in later
    // releases, the miniport driver should check that the length of the
    // structure is greater than or equal to the length it expects (since
    // it is guaranteed that defined fields will not change).
    //
    // This field is always initialized by the port driver.
    //

    ULONG Length;

    //
    // Specifies which IO bus is tp be scanned. This field is used as a
    // parameter to some VideoPortXXX calls.
    //
    // This field is always initialized by the port driver.
    //

    ULONG SystemIoBusNumber;

    //
    // Specifies the type of bus being scanned. This field is equal to the
    // value being passed into VideoPortInitialize in the
    // VIDEO_HW_INITIALIZATION_DATA structure.
    //
    // This field is always initialized by the port driver.
    //

    INTERFACE_TYPE AdapterInterfaceType;

    //
    // Specifies the bus interrupt request level. This level corresponds to
    // the IRQL on ISA and MCA buses.
    // This value is only used if the device supports interrupts, which is
    // determined by the presence of an interrupt service routine in the
    // VIDEO_HW_INITIALIZATION_DATA structure.
    //
    // The preset default value for this field is zero. Otherwise, it is the
    // value found in the device configuration information.
    //

    ULONG BusInterruptLevel;

    //
    // Specifies the bus vector returned by the adapter. This is used for
    // systems which have IO buses that use interrupt vectors. For ISA, MCA
    // and EISA buses, this field is unused.
    //
    // The preset default value for this field is zero.
    //

    ULONG BusInterruptVector;

    //
    // Specifies whether this adapter uses latched or edge-triggered type
    // interrupts.
    //
    // This field is always initialized by the port driver.
    //

    KINTERRUPT_MODE InterruptMode;

    //
    // Specifies the number of emulator access entries that the adapter
    // uses.  It indicates the number of array elements in the following field.
    //
    // This field can be reinitialized with the number of entries in the
    // EmulatorAccessEntries structure if the structure is statically
    // defined in the miniport driver. The EmulatorAccessEntries fields
    // should also be updated.
    //

    ULONG NumEmulatorAccessEntries;

    //
    // Supplies a pointer to an array of EMULATOR_ACCESS_ENTRY structures.
    // The number of elements in the array is indicated by the
    // NumEmulatorAccessEntries field. The driver should fill out each entry
    // for the adapter.
    //
    // The uninitialized value for the structure is NULL.
    // EmulatorAccessEntries will be NULL if NumEmulatorAccessEntries is
    // zero.
    //
    // A poiner to an array of emulator access entries can be passed back
    // if such a structure is defined statically in the miniport driver. The
    // NumEmulatorAccessEntries field should also be updated.
    //

    PVOID EmulatorAccessEntries;

    //
    // This is a context values that is passed with each call to the
    // emulator/validator functions defined in the EmulatorAccessEntries
    // defined above.
    // This parameter should in general be a pointer to the miniports
    // device extension or other such storage location.
    //
    // This pointer will allow the miniport to save some state temporarily
    // to allow for the batching of IO requests.
    //

    ULONG_PTR EmulatorAccessEntriesContext;

    //
    // Physical address of the video memory that must be mapped into a VDM's
    // address space for proper BIOS support
    //

    PHYSICAL_ADDRESS VdmPhysicalVideoMemoryAddress;

    //
    // Length of the video memory that must be mapped into a VDM's addres
    // space for proper BIOS support.
    //

    ULONG VdmPhysicalVideoMemoryLength;

    //
    // Determines the minimum size required to store the hardware state
    // information returned by IOCTL_VIDEO_SAVE_HARDWARE_STATE.
    //
    // The uninitialized value for this field is zero.
    //
    // If the field is left to zero, SAVE_HARDWARE_STATE will return an
    // ERROR_INVALID_FUNCTION status code.
    //

    ULONG HardwareStateSize;

    //
    // New for version 3.5
    //

    //
    // Optional DMA channel, if required by the device.
    // 0 for the Channel and Port indicates DMA is not used by the device.
    //

    ULONG DmaChannel;

    //
    // Optional DMA channel, if required by the device.
    // 0 for the Channel and Port indicates DMA is not used by the device.
    //

    ULONG DmaPort;

    //
    // Set to 1 if the DMA channel can be shared with another device.
    // Set to 0 if the DMA channel must be owned exclusively by the driver.
    //

    UCHAR DmaShareable;

    //
    // Set to 1 if the interrupt can be shared with another device.
    // Set to 0 if the interrupt must be owned exclusively by the driver.
    //

    UCHAR InterruptShareable;

    //
    //  Start new dma stuff
    //

    //
    // Set to TRUE if the DMA device is a busmaster, FALSE otherwise.
    //

    BOOLEAN Master;

    //
    // Set to number of bits wide. Consistent with DEVICE_DESCRIPTION.
    // See ntioapi.h
    //

    DMA_WIDTH   DmaWidth;

    //
    // Set to speed so miniport can set DEVICE_DESCRIPTION field.
    // See ntioapi.h
    //

    DMA_SPEED   DmaSpeed;

    //
    // Set to TRUE if the DMA device requires mapped buffers. Also
    // a DEVICE_DESCRIPTION  field.
    //

    BOOLEAN bMapBuffers;

    //
    // Set to TRUE if the DMA device requires physical addresses.
    //

    BOOLEAN NeedPhysicalAddresses;

    //
    // Set to TRUE if the DMA device supports demand mode, FALSE otherwise.
    // Also DEVICE_DESCRIPTION support.
    //

    BOOLEAN DemandMode;

    //
    // Set to max transfer length the DMA device supports.
    //

    ULONG   MaximumTransferLength;

    //
    // Set to max number of Physical breaks the DMA device supports.
    //

    ULONG   NumberOfPhysicalBreaks;

    //
    // Set to TRUE if the DMA device supports scatter gather, FALSE otherwise.
    //

    BOOLEAN ScatterGather;

    //
    // Maximal Length in PVRB_SG returned measured in bytes. If the device
    // has no maximum size, zero should be entered.
    //

    ULONG   MaximumScatterGatherChunkSize;

    //
    // Allow for 4.0/5.0 compatibilty
    //

    PVIDEO_PORT_GET_PROC_ADDRESS VideoPortGetProcAddress;

    //
    // Provide a pointer to the device's registry path
    //

    PWSTR DriverRegistryPath;

    //
    // Indicates to a driver the amount of physical memory in the system
    //

    ULONGLONG SystemMemorySize;

} VIDEO_PORT_CONFIG_INFO, *PVIDEO_PORT_CONFIG_INFO;


//
// Video Adapter Dependent Routines.
//

typedef
VP_STATUS
(*PVIDEO_HW_FIND_ADAPTER) (
    PVOID HwDeviceExtension,
    PVOID HwContext,
    PWSTR ArgumentString,
    PVIDEO_PORT_CONFIG_INFO ConfigInfo,
    PUCHAR Again
    );

typedef
BOOLEAN
(*PVIDEO_HW_INITIALIZE) (
    PVOID HwDeviceExtension
    );

typedef
BOOLEAN
(*PVIDEO_HW_INTERRUPT) (
    PVOID HwDeviceExtension
    );

typedef
VOID
(*PVIDEO_HW_LEGACYRESOURCES) (
    IN ULONG VendorId,
    IN ULONG DeviceId,
    IN OUT PVIDEO_ACCESS_RANGE *LegacyResourceList,
    IN OUT PULONG LegacyResourceCount
    );

//
// type to be returned by HwStartDma().
//

typedef enum _HW_DMA_RETURN {
    DmaAsyncReturn,
    DmaSyncReturn
    } HW_DMA_RETURN, *PHW_DMA_RETURN;


typedef
HW_DMA_RETURN
(*PVIDEO_HW_START_DMA) (
    PVOID                   HwDeviceExtension,
    PDMA                    pDma
    );

//
//  Flags to be passed into VideoPortLockPages() or VideoPortDoDma().
//

//
//  The flag VideoPortUnlockAfterDma tells the video port to unlock the pages
//  after the miniport signals that the dma is complete via the
//  pDmaCompletionEvent in HwStartDma. Failure to set this event at
//  dma completion may cause the memory to be unlocked at randon times.
//  This flag is best used when one wants to do one dma transfer which
//  occurs infrequently. It allows locking, dmaing and unlocking to be performed
//  in the context of 1 IOCTL.
//

//
//  The flag VideoPortKeepPagesLocked tells the video port to leave the pages
//  locked if possible.
//

//
//  The flag VideoPortDmaInitOnly tells the Video Port to lock the pages, but don't
//  call HwStartDma. Not applicable to VideoPortDoDma().
//


typedef enum {
    VideoPortUnlockAfterDma = 1,
    VideoPortKeepPagesLocked,
    VideoPortDmaInitOnly
    }   DMA_FLAGS;

//
// DMA Event flags
//

typedef ULONG DMA_EVENT_FLAGS;

#define SET_USER_EVENT    0x01
#define SET_DISPLAY_EVENT 0x02

//
// Child Enumeration structure passed in to the PVIDEO_HW_GET_CHILD_DESCRIPTOR
// function.
//
// All these parameters are input parameters and must not be modified by the
// callee
//
// Size - Size of the structure.  It can be used by the calle for versioning.
//
// ChildDescriptorSize - Size of the pChildDescriptor buffer passed in as the
//     third parameter to PVIDEO_HW_GET_CHILD_DESCRIPTOR.
//
// ChildIndex - Index of the device to be enumerated.  This field should be
//     used to enumerate devices not enumerated by ACPI or other operating
//     system components.  If this field is set to 0 it indicates the ACPIHwId
//     field.
//
// ACPIHwId - ID returned by the ACPI BIOS that represent the device being
//     queried.  The ACPIHwId returned by the firmware must match the HwIds
//     returned by the driver.  The System BIOS manufacturer and the graphics
//     IHV must synchronize these IDs.
//
// ChildHwDeviceExtension - Pointer to a device extension specific to this
//     child device.  This field will only be filled in if the miniport driver
//     filled the ChildHwDeviceExtensionSize to be non-NULL.
//

typedef struct _VIDEO_CHILD_ENUM_INFO {
    ULONG Size;
    ULONG ChildDescriptorSize;
    ULONG ChildIndex;
    ULONG ACPIHwId;
    PVOID ChildHwDeviceExtension;
} VIDEO_CHILD_ENUM_INFO, *PVIDEO_CHILD_ENUM_INFO;

//
//  VIDEO_CHILD_TYPE enum:
//
//  'Monitor' identifies a device which may have a DDC2 compliant EDID data
//  structure. If the video miniport detects such a device, it is to extract
//  the edid from the monitor and put that in the paged buffer provided by
//  videoprt.sys in the callback to PVIDEO_HW_GET_CHILD_DESCRIPTOR and return
//  this type in the the OUT PVIDEO_CHILD_TYPE parameter of that call. This
//  EDID, if available, will be written to the registry. If the EDID is not
//  available, nothing should be put in the buffer.
//
//  'NonPrimaryChip' identifies another VGA chip on the video board which
//  is not the primary VGA chip. This type is to be used if and only if the
//  miniport detects more than one VGA chip on the board. Such an identifier
//  will cause the videoprt to create another DEVICE_EXTENSION and associated
//  HW_DEVICE_EXTENSION to be associated with the chip so identified.
//
//  'Other' identifies some other video device attached to the video card. If
//  the miniport detects such a device, it is to put a wide char string
//  (WSTR) into the paged buffer provided by the videoprt.sys which is the
//  PNP hardware identifier of the device. This string will be used to create
//  a value of that name in the registry.
//

typedef enum {
    Monitor = 1,
    NonPrimaryChip,
    VideoChip,
    Other
} VIDEO_CHILD_TYPE, *PVIDEO_CHILD_TYPE;

//
//  define a constant that represents the display adapter self query.
//

#define DISPLAY_ADAPTER_HW_ID           0xFFFFFFFF

typedef struct _VIDEO_CHILD_STATE {
    ULONG   Id;
    ULONG   State;
} VIDEO_CHILD_STATE, *PVIDEO_CHILD_STATE;
    
typedef struct _VIDEO_CHILD_STATE_CONFIGURATION {
    ULONG             Count;
    VIDEO_CHILD_STATE ChildStateArray[ANYSIZE_ARRAY];
} VIDEO_CHILD_STATE_CONFIGURATION, *PVIDEO_CHILD_STATE_CONFIGURATION;

//
//  The following routine should return TRUE if successful. It should:
//      1)  put the type of the child device in VideoChildType.
//      2)  put the information from the device in Buffer. This
//          buffer is of size 256 bytes. If the type returned in
//          PVideoChildType is Monitor, this buffer must contain the
//          EDID of the monitor if readable. If the type returned in
//          PVideoChildType is Other, a wide character string representing
//          the PNP Device Id must be put in the buffer. This string will
//          be used to create a key for the device if the buffer contains
//          an EDID. Otherwise, it is used to obtain a PNP ID for the
//          device.
//      3)  Put a miniport determined HANDLE in HwId. This value will be
//          passed back to the miniport for Power management operations,
//          as well as other operations. This allows the miniport to define
//          the contract between the system and the miniport which defines a
//          particular device.
//
//  It should  only return FALSE if there are no devices attached to that
//  display adapter connector.
//

typedef
ULONG
(*PVIDEO_HW_GET_CHILD_DESCRIPTOR) (
    IN  PVOID                   HwDeviceExtension,
    IN  PVIDEO_CHILD_ENUM_INFO  ChildEnumInfo,
    OUT PVIDEO_CHILD_TYPE       VideoChildType,
    OUT PUCHAR                  pChildDescriptor,
    OUT PULONG                  UId,
    OUT PULONG                  pUnused
    );


//
// This routine is used to set the power on the graphics devices.
// These include all the Children enumerated by GET_CHILD_DESCRIPTOR callback
// as well as the graphics adapter itself.
//
// The HwDevice extension represent the adapter instance of the device.
//
// The HwId parameter is the unique ID as returned by the enumeration routine.
// The miniport will only be called to set the power on the devices it
// enumerated, as well as the graphics adapter itself.  A HwId of 0xFFFFFFFF
// will be passed in to identify the graphics adapter itself.
// The miniport driver should never turn off the power to the graphics adapter
// unless specifically request to.
//
// The VideoPowerControl is the level to which the device shold be set.
// The videoport driver will manage these states.
//

typedef
VP_STATUS
(*PVIDEO_HW_POWER_SET) (
    PVOID                   HwDeviceExtension,
    ULONG                   HwId,
    PVIDEO_POWER_MANAGEMENT VideoPowerControl
    );

//
// This routine simply returns whether or not the device can support the
// requested state.
//
// See HW_POWER_SET for a description of the parameters.
//

typedef
VP_STATUS
(*PVIDEO_HW_POWER_GET) (
    PVOID                   HwDeviceExtension,
    ULONG                   HwId,
    PVIDEO_POWER_MANAGEMENT VideoPowerControl
    );

//
// This structure should match the QueryInterface struct defined
// in io.h.
//

typedef struct _INTERFACE {
    USHORT Size;
    USHORT Version;
    PVOID Context;
    PINTERFACE_REFERENCE InterfaceReference;
    PINTERFACE_DEREFERENCE InterfaceDereference;
    // interface specific entries go here
} INTERFACE, *PINTERFACE;

typedef struct _QUERY_INTERFACE {
    CONST GUID *InterfaceType;
    USHORT Size;
    USHORT Version;
    PINTERFACE Interface;
    PVOID InterfaceSpecificData;
} QUERY_INTERFACE, *PQUERY_INTERFACE;

typedef
VP_STATUS
(*PVIDEO_HW_QUERY_INTERFACE) (
    PVOID HwDeviceExtension,
    PQUERY_INTERFACE QueryInterface
    );

typedef
VP_STATUS
(*PVIDEO_HW_CHILD_CALLBACK) (
    PVOID HwDeviceExtension,
    PVOID ChildDeviceExtension
    );

//
// Entry point for all IOCTL calls made to the miniport driver.
//

typedef
BOOLEAN
(*PVIDEO_HW_START_IO) (
    PVOID HwDeviceExtension,
    PVIDEO_REQUEST_PACKET RequestPacket
    );

//
// The return value determines if the mode was completely programmed (TRUE)
// or if an int10 should be done by the HAL to complete the modeset (FALSE).
//

typedef
BOOLEAN
(*PVIDEO_HW_RESET_HW) (
    PVOID HwDeviceExtension,
    ULONG Columns,
    ULONG Rows
    );

//
// Timer routine called every second.
//

typedef
VOID
(*PVIDEO_HW_TIMER) (
    PVOID HwDeviceExtension
    );


//
// Structure passed by the miniport entry point to the video port
// initialization routine.
//

typedef struct _VIDEO_HW_INITIALIZATION_DATA {

    //
    // Supplies the size of the structure in bytes as determined by sizeof().
    //

    ULONG HwInitDataSize;

    //
    // Indicates the bus type the adapter works with, such as Eisa, Isa, MCA.
    //

    INTERFACE_TYPE AdapterInterfaceType;

    //
    // Supplies a pointer to the miniport driver's find adapter routine.
    //

    PVIDEO_HW_FIND_ADAPTER HwFindAdapter;

    //
    // Supplies a pointer to the miniport driver's initialization routine.
    //

    PVIDEO_HW_INITIALIZE HwInitialize;

    //
    // Supplies a pointer to the miniport driver's interrupt service routine.
    //

    PVIDEO_HW_INTERRUPT HwInterrupt;

    //
    // Supplies a pointer to the miniport driver's start io routine.
    //

    PVIDEO_HW_START_IO HwStartIO;

    //
    // Supplies the size in bytes required for the miniport driver's private
    // device extension. This storage is used by the miniport driver to hold
    // per-adapter information. A pointer to this storage is provided with
    // every call made to the miniport driver. This data storage is
    // initialized to zero by the port driver.
    //

    ULONG HwDeviceExtensionSize;

    //
    // Supplies the number with which device numbering should be started.
    // The device numbering is used to determine which \DeviceX entry under
    // the \Parameters section in the registry should be used for parameters
    // to the miniport driver.
    // The number is *automatically* incremented when the miniport is called
    // back in it's FindAdapter routine due to an appropriate _Again_
    // parameter.
    //

    ULONG StartingDeviceNumber;


    //
    // New for version 3.5
    //

    //
    // Supplies a pointer to the miniport driver's HwResetHw routine.
    //
    // This function is called when the machine needs to bugchecks (go back
    // to the blue screen).
    //
    // This function should reset the video adapter to a character mode,
    // or at least to a state from which an int 10 can reset the card to
    // a character mode.
    //
    // This routine CAN NOT call int10.
    // It can only call Read\Write Port\Register functions from the port driver.
    //
    // The function must also be completely in non-paged pool since the IO\MM
    // subsystems may have crashed.
    //

    PVIDEO_HW_RESET_HW HwResetHw;

    //
    // Pointer to a timer routine to be called every second.
    //

    PVIDEO_HW_TIMER HwTimer;

    //
    //  Start of 5.0 stuff.
    //

    //
    //  Supplies a pointer to the miniport driver's start dma routine. This routine must
    //  return a HW_DMA_RETURN consistent with it's return behavior.
    //

    PVIDEO_HW_START_DMA HwStartDma;

    //
    //  HW dependent Power management routines.
    //

    PVIDEO_HW_POWER_SET HwSetPowerState;
    PVIDEO_HW_POWER_GET HwGetPowerState;

    //
    // Supplies a pointer to a miniport driver routine which can be called to
    // enumerate devices physically attached to the graphics adapter.
    //

    PVIDEO_HW_GET_CHILD_DESCRIPTOR HwGetVideoChildDescriptor;

    //
    // Supplies a pointer to a miniport driver routine which can be called to
    // query external programming interfaces supported in the miniport
    // driver.
    //

    PVIDEO_HW_QUERY_INTERFACE HwQueryInterface;

    //
    // Size of the device extension associated with the display output device.
    // This should only be set (to the approrpiate size) if the miniport driver
    // needs to manage the monitor configuration data separately from the
    // adapter board configuration (example - multiple output graphics devices).
    //

    ULONG HwChildDeviceExtensionSize;

    //
    // Allows the device to report legacy resources that should be
    // associated with the Plug and Play device.
    //

    PVIDEO_ACCESS_RANGE HwLegacyResourceList;

    //
    // Number of elements in the legacy resource list.
    //

    ULONG HwLegacyResourceCount;

    //
    // Call this routine to allow a driver to specify it's
    // legacy resources based on its device/vendor id.
    //

    PVIDEO_HW_LEGACYRESOURCES HwGetLegacyResources;

    //
    // Can HwGetVideoChildDescriptor be called before HwInitialize?
    //

    BOOLEAN AllowEarlyEnumeration;

} VIDEO_HW_INITIALIZATION_DATA, *PVIDEO_HW_INITIALIZATION_DATA;

//
// DDC help routines.
//

typedef
VOID
(*PVIDEO_WRITE_CLOCK_LINE)(
    PVOID HwDeviceExtension,
    UCHAR Data
    );

typedef
VOID
(*PVIDEO_WRITE_DATA_LINE)(
    PVOID HwDeviceExtension,
    UCHAR Data
    );

typedef
BOOLEAN
(*PVIDEO_READ_CLOCK_LINE)(
    PVOID HwDeviceExtension
    );

typedef
BOOLEAN
(*PVIDEO_READ_DATA_LINE)(
    PVOID HwDeviceExtension
    );

typedef
VOID
(*PVIDEO_WAIT_VSYNC_ACTIVE)(
    PVOID HwDeviceExtension
    );

//
// Data structures used I2C and DDC helper functions.
//

typedef struct _I2C_FNC_TABLE
{
    ULONG                    Size;
    PVIDEO_WRITE_CLOCK_LINE  WriteClockLine;
    PVIDEO_WRITE_DATA_LINE   WriteDataLine;
    PVIDEO_READ_CLOCK_LINE   ReadClockLine;
    PVIDEO_READ_DATA_LINE    ReadDataLine;
    PVIDEO_WAIT_VSYNC_ACTIVE WaitVsync;
    PVOID                    Reserved;
} I2C_FNC_TABLE, *PI2C_FNC_TABLE;

typedef struct _I2C_CALLBACKS
{
    PVIDEO_WRITE_CLOCK_LINE WriteClockLine;
    PVIDEO_WRITE_DATA_LINE  WriteDataLine;
    PVIDEO_READ_CLOCK_LINE  ReadClockLine;
    PVIDEO_READ_DATA_LINE   ReadDataLine;
} I2C_CALLBACKS, *PI2C_CALLBACKS;

typedef struct _DDC_CONTROL
{
    ULONG         Size;
    I2C_CALLBACKS I2CCallbacks;
    UCHAR         EdidSegment;
} DDC_CONTROL, *PDDC_CONTROL;

//
// Types of services exported by the VideoPortQueryServices().
//

typedef enum
{
    VideoPortServicesAGP = 1,
    VideoPortServicesI2C
} VIDEO_PORT_SERVICES;

//
// AGP services interface.
//

typedef struct _VIDEO_PORT_AGP_INTERFACE
{
    USHORT                 Size;
    USHORT                 Version;
    PVOID                  Context;
    PINTERFACE_REFERENCE   InterfaceReference;
    PINTERFACE_DEREFERENCE InterfaceDereference;
    PAGP_RESERVE_PHYSICAL  AgpReservePhysical;
    PAGP_RELEASE_PHYSICAL  AgpReleasePhysical;
    PAGP_COMMIT_PHYSICAL   AgpCommitPhysical;
    PAGP_FREE_PHYSICAL     AgpFreePhysical;
    PAGP_RESERVE_VIRTUAL   AgpReserveVirtual;
    PAGP_RELEASE_VIRTUAL   AgpReleaseVirtual;
    PAGP_COMMIT_VIRTUAL    AgpCommitVirtual;
    PAGP_FREE_VIRTUAL      AgpFreeVirtual;
    ULONGLONG              AgpAllocationLimit;
} VIDEO_PORT_AGP_INTERFACE, *PVIDEO_PORT_AGP_INTERFACE;

//
// I2C helper routines exported via VideoPortQueryServices().
//

typedef
BOOLEAN
(*PI2C_START)(
    IN PVOID HwDeviceExtension,
    IN PI2C_CALLBACKS I2CCallbacks
    );

typedef
BOOLEAN
(*PI2C_STOP)(
    IN PVOID HwDeviceExtension,
    IN PI2C_CALLBACKS I2CCallbacks
    );

typedef
BOOLEAN
(*PI2C_WRITE)(
    IN PVOID HwDeviceExtension,
    IN PI2C_CALLBACKS I2CCallbacks,
    IN PUCHAR Buffer,
    IN ULONG Length
    );

typedef
BOOLEAN
(*PI2C_READ)(
    IN PVOID HwDeviceExtension,
    IN PI2C_CALLBACKS I2CCallbacks,
    OUT PUCHAR Buffer,
    IN ULONG Length
    );

//
// I2C services interface.
//

typedef struct _VIDEO_PORT_I2C_INTERFACE
{
    USHORT                 Size;
    USHORT                 Version;
    PVOID                  Context;
    PINTERFACE_REFERENCE   InterfaceReference;
    PINTERFACE_DEREFERENCE InterfaceDereference;
    PI2C_START             I2CStart;
    PI2C_STOP              I2CStop;
    PI2C_WRITE             I2CWrite;
    PI2C_READ              I2CRead;
} VIDEO_PORT_I2C_INTERFACE, *PVIDEO_PORT_I2C_INTERFACE;

//
// Flags that can be passed to VideoPortGetDeviceBase or VideoPortMapMemory.
//

#define VIDEO_MEMORY_SPACE_MEMORY    0x00  // Should not be set by display driver
#define VIDEO_MEMORY_SPACE_IO        0x01  // Should not be set by display driver
#define VIDEO_MEMORY_SPACE_USER_MODE 0x02  // Memory pointer for application use
#define VIDEO_MEMORY_SPACE_DENSE     0x04  // Mapped dense, linearly (ALPHA)
#define VIDEO_MEMORY_SPACE_P6CACHE   0x08  // P6 MTRR caching (kernel and user)

//
// Define status codes returned by HwGetVideoChildDescriptor()
// miniport enumaration routine.
//
// Note: For backword compatibility reasons these values match
// existing WINERROR codes.
//

//
// Call again (ACPI and non-ACPI devices will be enumerated).
//

#define VIDEO_ENUM_MORE_DEVICES     ERROR_CONTINUE

//
// Stop enumeration.
//

#define VIDEO_ENUM_NO_MORE_DEVICES  ERROR_NO_MORE_DEVICES

//
// Call again, device could not be enumerated.
//

#define VIDEO_ENUM_INVALID_DEVICE   ERROR_INVALID_NAME

//
// Define the bits in VgaStatus.
//

#define DEVICE_VGA_ENABLED          1

//
// Port driver routines called by miniport driver and callbacks.
//

VIDEOPORT_API
VP_STATUS
VideoPortAllocateBuffer(
    IN PVOID HwDeviceExtension,
    IN ULONG Size,
    OUT PVOID *Buffer
    );

VIDEOPORT_API
VOID
VideoPortAcquireDeviceLock(
    IN PVOID HwDeviceExtension
    );

VIDEOPORT_API
ULONG
VideoPortCompareMemory(
    PVOID Source1,
    PVOID Source2,
    ULONG Length
    );

VIDEOPORT_API
BOOLEAN
VideoPortDDCMonitorHelper(
    IN PVOID HwDeviceExtension,
    IN PVOID DDCControl,
    IN OUT PUCHAR EdidBuffer,
    IN ULONG EdidBufferSize
    );

VIDEOPORT_API
VOID
VideoPortDebugPrint(
    ULONG DebugPrintLevel,
    PCHAR DebugMessage,
    ...
    );

VIDEOPORT_API
VP_STATUS
VideoPortDisableInterrupt(
    PVOID HwDeviceExtension
    );

VIDEOPORT_API
VP_STATUS
VideoPortEnableInterrupt(
    PVOID HwDeviceExtension
    );

VIDEOPORT_API
VP_STATUS
VideoPortEnumerateChildren(
    IN PVOID HwDeviceExtension,
    IN PVOID Reserved
    );

VIDEOPORT_API
VOID
VideoPortFreeDeviceBase(
    PVOID HwDeviceExtension,
    PVOID MappedAddress
    );

typedef
VP_STATUS
(*PMINIPORT_QUERY_DEVICE_ROUTINE)(
    PVOID HwDeviceExtension,
    PVOID Context,
    VIDEO_DEVICE_DATA_TYPE DeviceDataType,
    PVOID Identifier,
    ULONG IdentiferLength,
    PVOID ConfigurationData,
    ULONG ConfigurationDataLength,
    PVOID ComponentInformation,
    ULONG ComponentInformationLength
    );

VIDEOPORT_API
VP_STATUS
VideoPortGetAccessRanges(
    PVOID HwDeviceExtension,
    ULONG NumRequestedResources,
    PIO_RESOURCE_DESCRIPTOR RequestedResources OPTIONAL,
    ULONG NumAccessRanges,
    PVIDEO_ACCESS_RANGE AccessRanges,
    PVOID VendorId,
    PVOID DeviceId,
    PULONG Slot
    );

VIDEOPORT_API
PVOID
VideoPortGetAssociatedDeviceExtension(
    IN PVOID DeviceObject
    );

VIDEOPORT_API
ULONG
VideoPortGetBusData(
    PVOID HwDeviceExtension,
    BUS_DATA_TYPE BusDataType,
    ULONG SlotNumber,
    PVOID Buffer,
    ULONG Offset,
    ULONG Length
    );

VIDEOPORT_API
UCHAR
VideoPortGetCurrentIrql();

VIDEOPORT_API
PVOID
VideoPortGetDeviceBase(
    PVOID HwDeviceExtension,
    PHYSICAL_ADDRESS IoAddress,
    ULONG NumberOfUchars,
    UCHAR InIoSpace
    );

VIDEOPORT_API
VP_STATUS
VideoPortGetDeviceData(
    PVOID HwDeviceExtension,
    VIDEO_DEVICE_DATA_TYPE DeviceDataType,
    PMINIPORT_QUERY_DEVICE_ROUTINE CallbackRoutine,
    PVOID Context
    );

typedef
VP_STATUS
(*PMINIPORT_GET_REGISTRY_ROUTINE)(
    PVOID HwDeviceExtension,
    PVOID Context,
    PWSTR ValueName,
    PVOID ValueData,
    ULONG ValueLength
    );

VIDEOPORT_API
VP_STATUS
VideoPortGetRegistryParameters(
    PVOID HwDeviceExtension,
    PWSTR ParameterName,
    UCHAR IsParameterFileName,
    PMINIPORT_GET_REGISTRY_ROUTINE GetRegistryRoutine,
    PVOID Context
    );

VIDEOPORT_API
PVOID
VideoPortGetRomImage(
    IN PVOID HwDeviceExtension,
    IN PVOID Unused1,
    IN ULONG Unused2,
    IN ULONG Length
    );

VIDEOPORT_API
VP_STATUS
VideoPortGetVgaStatus(
    PVOID HwDeviceExtension,
    OUT PULONG VgaStatus
    );

VIDEOPORT_API
LONG
FASTCALL
VideoPortInterlockedDecrement(
    IN PLONG Addend
    );

VIDEOPORT_API
LONG
FASTCALL
VideoPortInterlockedIncrement(
    IN PLONG Addend
    );

VIDEOPORT_API
LONG
FASTCALL
VideoPortInterlockedExchange(
    IN OUT PLONG Target,
    IN LONG Value
    );

VIDEOPORT_API
ULONG
VideoPortInitialize(
    PVOID Argument1,
    PVOID Argument2,
    PVIDEO_HW_INITIALIZATION_DATA HwInitializationData,
    PVOID HwContext
    );

VIDEOPORT_API
VP_STATUS
VideoPortInt10(
    PVOID HwDeviceExtension,
    PVIDEO_X86_BIOS_ARGUMENTS BiosArguments
    );

VIDEOPORT_API
VOID
VideoPortLogError(
    PVOID HwDeviceExtension,
    PVIDEO_REQUEST_PACKET Vrp OPTIONAL,
    VP_STATUS ErrorCode,
    ULONG UniqueId
    );

VIDEOPORT_API
VP_STATUS
VideoPortMapMemory(
    PVOID HwDeviceExtension,
    PHYSICAL_ADDRESS PhysicalAddress,
    PULONG Length,
    PULONG InIoSpace,
    PVOID *VirtualAddress
    );

VIDEOPORT_API
VOID
VideoPortMoveMemory(
    PVOID Destination,
    PVOID Source,
    ULONG Length
    );

VIDEOPORT_API
VP_STATUS
VideoPortQueryServices(
    IN PVOID HwDeviceExtension,
    IN VIDEO_PORT_SERVICES ServicesType,
    IN OUT PINTERFACE Interface
    );

typedef
VOID
(*PMINIPORT_DPC_ROUTINE)(
    IN PVOID HwDeviceExtension,
    IN PVOID Context
    );

VIDEOPORT_API
BOOLEAN
VideoPortQueueDpc(
    IN PVOID HwDeviceExtension,
    IN PMINIPORT_DPC_ROUTINE CallbackRoutine,
    IN PVOID Context
    );

VIDEOPORT_API
UCHAR
VideoPortReadPortUchar(
    PUCHAR Port
    );

VIDEOPORT_API
USHORT
VideoPortReadPortUshort(
    PUSHORT Port
    );

VIDEOPORT_API
ULONG
VideoPortReadPortUlong(
    PULONG Port
    );

VIDEOPORT_API
VOID
VideoPortReadPortBufferUchar(
    PUCHAR Port,
    PUCHAR Buffer,
    ULONG Count
    );

VIDEOPORT_API
VOID
VideoPortReadPortBufferUshort(
    PUSHORT Port,
    PUSHORT Buffer,
    ULONG Count
    );

VIDEOPORT_API
VOID
VideoPortReadPortBufferUlong(
    PULONG Port,
    PULONG Buffer,
    ULONG Count
    );

VIDEOPORT_API
UCHAR
VideoPortReadRegisterUchar(
    PUCHAR Register
    );

VIDEOPORT_API
USHORT
VideoPortReadRegisterUshort(
    PUSHORT Register
    );

VIDEOPORT_API
ULONG
VideoPortReadRegisterUlong(
    PULONG Register
    );

VIDEOPORT_API
VOID
VideoPortReadRegisterBufferUchar(
    PUCHAR Register,
    PUCHAR Buffer,
    ULONG Count
    );

VIDEOPORT_API
VOID
VideoPortReadRegisterBufferUshort(
    PUSHORT Register,
    PUSHORT Buffer,
    ULONG Count
    );

VIDEOPORT_API
VOID
VideoPortReadRegisterBufferUlong(
    PULONG Register,
    PULONG Buffer,
    ULONG Count
    );

VIDEOPORT_API
VOID
VideoPortReleaseBuffer(
  IN PVOID HwDeviceExtension,
  IN PVOID Buffer
  );

VIDEOPORT_API
VOID
VideoPortReleaseDeviceLock(
    IN PVOID HwDeviceExtension
    );

VIDEOPORT_API
BOOLEAN
VideoPortScanRom(
    PVOID HwDeviceExtension,
    PUCHAR RomBase,
    ULONG RomLength,
    PUCHAR String
    );

VIDEOPORT_API
ULONG
VideoPortSetBusData(
    PVOID HwDeviceExtension,
    BUS_DATA_TYPE BusDataType,
    ULONG SlotNumber,
    PVOID Buffer,
    ULONG Offset,
    ULONG Length
    );

VIDEOPORT_API
VP_STATUS
VideoPortSetRegistryParameters(
    PVOID HwDeviceExtension,
    PWSTR ValueName,
    PVOID ValueData,
    ULONG ValueLength
    );

VIDEOPORT_API
VP_STATUS
VideoPortSetTrappedEmulatorPorts(
    PVOID HwDeviceExtension,
    ULONG NumAccessRanges,
    PVIDEO_ACCESS_RANGE AccessRange
    );

VIDEOPORT_API
VOID
VideoPortStallExecution(
    ULONG Microseconds
    );

VIDEOPORT_API
VOID
VideoPortStartTimer(
    PVOID HwDeviceExtension
    );

VIDEOPORT_API
VOID
VideoPortStopTimer(
    PVOID HwDeviceExtension
    );

typedef
BOOLEAN
(*PMINIPORT_SYNCHRONIZE_ROUTINE)(
    PVOID Context
    );

BOOLEAN
VIDEOPORT_API
VideoPortSynchronizeExecution(
    PVOID HwDeviceExtension,
    VIDEO_SYNCHRONIZE_PRIORITY Priority,
    PMINIPORT_SYNCHRONIZE_ROUTINE synchronizeRoutine,
    PVOID Context
    );

VIDEOPORT_API
VP_STATUS
VideoPortUnmapMemory(
    PVOID HwDeviceExtension,
    PVOID VirtualAddress,
    HANDLE ProcessHandle
    );

VIDEOPORT_API
VP_STATUS
VideoPortVerifyAccessRanges(
    PVOID HwDeviceExtension,
    ULONG NumAccessRanges,
    PVIDEO_ACCESS_RANGE AccessRanges
    );

VIDEOPORT_API
VOID
VideoPortWritePortUchar(
    PUCHAR Port,
    UCHAR Value
    );

VIDEOPORT_API
VOID
VideoPortWritePortUshort(
    PUSHORT Port,
    USHORT Value
    );

VIDEOPORT_API
VOID
VideoPortWritePortUlong(
    PULONG Port,
    ULONG Value
    );

VIDEOPORT_API
VOID
VideoPortWritePortBufferUchar(
    PUCHAR Port,
    PUCHAR Buffer,
    ULONG Count
    );

VIDEOPORT_API
VOID
VideoPortWritePortBufferUshort(
    PUSHORT Port,
    PUSHORT Buffer,
    ULONG Count
    );

VIDEOPORT_API
VOID
VideoPortWritePortBufferUlong(
    PULONG Port,
    PULONG Buffer,
    ULONG Count
    );

VIDEOPORT_API
VOID
VideoPortWriteRegisterUchar(
    PUCHAR Register,
    UCHAR Value
    );

VIDEOPORT_API
VOID
VideoPortWriteRegisterUshort(
    PUSHORT Register,
    USHORT Value
    );

VIDEOPORT_API
VOID
VideoPortWriteRegisterUlong(
    PULONG Register,
    ULONG Value
    );

VIDEOPORT_API
VOID
VideoPortWriteRegisterBufferUchar(
    PUCHAR Register,
    PUCHAR Buffer,
    ULONG Count
    );

VIDEOPORT_API
VOID
VideoPortWriteRegisterBufferUshort(
    PUSHORT Register,
    PUSHORT Buffer,
    ULONG Count
    );

VIDEOPORT_API
VOID
VideoPortWriteRegisterBufferUlong(
    PULONG Register,
    PULONG Buffer,
    ULONG Count
    );

VIDEOPORT_API
VOID
VideoPortZeroDeviceMemory(
    PVOID Destination,
    ULONG Length
    );

VIDEOPORT_API
VOID
VideoPortZeroMemory(
    PVOID Destination,
    ULONG Length
    );

//
// DMA support.
// TODO: Move to the separate module -- will be obsolete.
//

VIDEOPORT_API
PVOID
VideoPortAllocateContiguousMemory(
    IN  PVOID            HwDeviceExtension,
    IN  ULONG            NumberOfBytes,
    IN  PHYSICAL_ADDRESS HighestAcceptableAddress
    );

VIDEOPORT_API
PVOID
VideoPortGetCommonBuffer(
    IN  PVOID                       HwDeviceExtension,
    IN  ULONG                       DesiredLength,
    IN  ULONG                       Alignment,
    OUT PPHYSICAL_ADDRESS           LogicalAddress,
    OUT PULONG                      pActualLength,
    IN  BOOLEAN                     CacheEnabled
    );

VIDEOPORT_API
VOID
VideoPortFreeCommonBuffer(
    IN  PVOID            HwDeviceExtension,
    IN  ULONG            Length,
    IN  PVOID            VirtualAddress,
    IN  PHYSICAL_ADDRESS LogicalAddress,
    IN  BOOLEAN          CacheEnabled
    );

VIDEOPORT_API
PDMA
VideoPortDoDma(
    IN      PVOID                   HwDeviceExtension,
    IN      PDMA                    pDma,
    IN      DMA_FLAGS               DmaFlags
    );

VIDEOPORT_API
BOOLEAN
VideoPortLockPages(
    IN      PVOID                   HwDeviceExtension,
    IN OUT  PVIDEO_REQUEST_PACKET   pVrp,
    IN      PEVENT                  pUEvent,
    IN      PEVENT                  pDisplayEvent,
    IN      DMA_FLAGS               DmaFlags
    );

VIDEOPORT_API
BOOLEAN
VideoPortUnlockPages(
    PVOID   hwDeviceExtension,
    PDMA    pDma
    );

VIDEOPORT_API
BOOLEAN
VideoPortSignalDmaComplete(
    IN  PVOID               HwDeviceExtension,
    IN  PDMA                pDmaHandle
    );

VIDEOPORT_API
BOOLEAN
VideoPortCompleteDma(
    IN  PVOID           HwDeviceExtension,
    IN  PDMA            pDmaHandle,
    IN  DMA_EVENT_FLAGS CompletionFlags
    );

VIDEOPORT_API
PVOID
VideoPortGetMdl(
    IN  PVOID   HwDeviceExtension,
    IN  PDMA    pDma
    );

VIDEOPORT_API
PVOID
VideoPortGetDmaContext(
    IN  PVOID   HwDeviceExtension,
    IN  PDMA    pDma
    );

VIDEOPORT_API
VOID
VideoPortSetDmaContext(
    IN  PVOID   HwDeviceExtension,
    OUT PDMA    pDma,
    IN  PVOID   InstanceContext
    );

VIDEOPORT_API
ULONG
VideoPortGetBytesUsed(
    IN  PVOID   HwDeviceExtension,
    IN  PDMA    pDma
    );

VIDEOPORT_API
VOID
VideoPortSetBytesUsed(
    IN      PVOID   HwDeviceExtension,
    IN OUT  PDMA    pDma,
    IN      ULONG   BytesUsed
    );

VIDEOPORT_API
PDMA
VideoPortAssociateEventsWithDmaHandle(
    IN      PVOID                   HwDeviceExtension,
    IN OUT  PVIDEO_REQUEST_PACKET   pVrp,
    IN      PVOID                   MappedUserEvent,
    IN      PVOID                   DisplayDriverEvent
    );

VIDEOPORT_API
PDMA
VideoPortMapDmaMemory(
    IN      PVOID                   HwDeviceExtension,
    IN      PVIDEO_REQUEST_PACKET   pVrp,
    IN      PHYSICAL_ADDRESS        BoardAddress,
    IN      PULONG                  Length,
    IN      PULONG                  InIoSpace,
    IN      PVOID                   MappedUserEvent,
    IN      PVOID                   DisplayDriverEvent,
    IN OUT  PVOID                 * VirtualAddress
    );

VIDEOPORT_API
BOOLEAN
VideoPortUnmapDmaMemory(
    PVOID               HwDeviceExtension,
    PVOID               VirtualAddress,
    HANDLE              ProcessHandle,
    PDMA                BoardMemoryHandle
    );

//
// TODO: End of move block.
//

#endif // ifndef __VIDEO_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\minix\minixp.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    minixp.h

Abstract:

    This module contains the private data structures and procedure prototypes
    for the minix port driver.

--*/

#ifndef _MINIXP_
#define _MINIXP_

// Define ourselves as an NV20 to make life easy when including Nvidia
// header files:

#define NVARCH 0x20


#include <ntos.h>
#include <videoprt.h>
#include <pci.h>
#include <ntddvdeo.h>
#include <video.h>
#include <dderror.h>
#include <v86emul.h>   // needed by nv.h
#include <nv.h>
#include <minix.h>


BOOLEAN AgpUmaEnable();


typedef struct _MINIX_DRIVER_EXTENSION {

    VIDEO_DEVICE_EXTENSION VideoExtension;
    HW_DEVICE_EXTENSION HwExtension;

    ULONG Client;


} MINIX_DRIVER_EXTENSION, *PMINIX_DRIVER_EXTENSION;



LONG
MxCreatePort(
    VOID
    );


 
#endif  // _MINIXP_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\minix\agpuma.c ===
/*++

Copyright (c) 1990-2000  Microsoft Corporation

Module Name:

    agpuma.c

Abstract:

    This module maps all physical memory into the AGP address space.  It is
    used by the XBOX to simulate UMA.

--*/

// Nasty path, but there are only two files that need to make kernel calls.
#include <ntos.h>
#include <pci.h>
#include <ntddvdeo.h>
#include <ntagp.h>
#include <stdio.h>

#if defined(DBG)

    #define RIP(msg)            \
        {                       \
            DbgPrint msg;     \
            DbgPrint("\n");   \
            _asm { int 3 };     \
        }

#else

    #define RIP(msg) {}

#endif

//
// Conversions from APSIZE encoding to MB
//

#define AP_SIZE_4MB     0x3F
#define AP_SIZE_8MB     0x3E
#define AP_SIZE_16MB    0x3C
#define AP_SIZE_32MB    0x38
#define AP_SIZE_64MB    0x30
#define AP_SIZE_128MB   0x20
#define AP_SIZE_256MB   0x00

//
// Define the location of the GART aperture control registers
//

#define HOST_BUS                0
#define HOST_SLOT               0

//
// Define the location of the video card
//

#define CARD_BUS                1
#define CARD_SLOT               0

//
// Defines what mode we're using.  If the hardware doesn't support this then
// we'll RIP.
//

#define AGP_APERTURE_SIZE       AP_SIZE_64MB
#define AGP_APERTURE_BYTES      (64*1024*1024)
#define AGP_APERTURE_BASE       0xF8000000

//
// Offsets for host the registers we need to poke directly.
//

#define APBASE_OFFSET   0x10            // Aperture Base Address
#define APSIZE_OFFSET   0xB4            // Aperture Size Register
#define AGPCTRL_OFFSET  0xB0            // AGP Control Register
#define ATTBASE_OFFSET  0xB8            // Aperture Translation Table Base
#define RDCR_OFFSET     0x51            // RDRAM Control register
#define AGPBCTRL_OFFSET 0xE8            // AGP buffer control register
//
// Define the layout of the hardware registers
//

typedef struct _AGPCTRL 
{
    ULONG FourXOverride:1;              // forces AGP 2x mode
    ULONG FastWriteEnable:1;            // enables fast writes
    ULONG Reserved1:5;
    ULONG EnableGART:1;                 // enables the GART
    ULONG Reserved2:24;
} AGPCTRL;

typedef struct _RDCR
{
    UCHAR Reserved1:1;
    UCHAR ApertureEnable:1;             // enable AGP aperture
    UCHAR Reserved2:4;
    UCHAR PBS:1;
    UCHAR Reserved3:1;
} RDCR;

//
// GART entry structure
//

typedef struct _GART_PTE 
{
    ULONG Valid     :  1;
    ULONG Reserved  : 11;
    ULONG Page      : 20;
} GART_PTE, *PGART_PTE;

//
// Simple wrappers to make reading/writing host register values
// a little easier.
//

#define ReadHostRegister(_buf_, _offset_, _size_)           \
                                                            \
    ReadDeviceData(HOST_BUS,                                \
                   HOST_SLOT,                               \
                   (_buf_),                                 \
                   (_offset_),                              \
                   (_size_));                       

#define WriteHostRegister(_buf_, _offset_, _size_)          \
                                                            \
    WriteDeviceData(HOST_BUS,                               \
                    HOST_SLOT,                              \
                    (_buf_),                                \
                    (_offset_),                             \
                    (_size_));                      

//============================================================================
// AGP Code
//============================================================================

//----------------------------------------------------------------------------
// Read data from a PCI device.
//
static ULONG ReadDeviceData(
    ULONG Bus,
    ULONG Slot,
    PVOID Buffer,
    ULONG Offset,
    ULONG Length
    )
{
    ULONG Transferred;

    Transferred = HalGetBusDataByOffset(PCIConfiguration,
                                        Bus,
                                        Slot,
                                        Buffer,
                                        Offset,
                                        Length);

    return (Transferred == Length);
}

//----------------------------------------------------------------------------
// Write data to a PCI device.
//
static void WriteDeviceData(
    ULONG Bus,
    ULONG Slot,
    PVOID Buffer,
    ULONG Offset,
    ULONG Length
    )
{
    ULONG Transferred;

    Transferred = HalSetBusDataByOffset(PCIConfiguration,
                                        Bus,
                                        Slot,
                                        Buffer,
                                        Offset,
                                        Length);

    ASSERT(Transferred == Length);
}

//----------------------------------------------------------------------------
// Walk an AGP device's configuration space to find a specific capability.
//
static UCHAR ReadAgpCapability(
    ULONG Bus,
    ULONG Slot,
    PCI_AGP_CAPABILITY *Capability
    )
{
    PCI_COMMON_CONFIG Header;
    UCHAR CapabilityOffset;

    //
    // Read the PCI common header to get the capabilities pointer
    //

    ReadDeviceData(Bus, Slot, &Header, 0, sizeof(PCI_COMMON_CONFIG));

    //
    // Check the Status register to see if this device supports capability lists.
    // If not, it is not an AGP-compliant device.
    //

    if ((Header.Status & PCI_STATUS_CAPABILITIES_LIST) == 0) 
    {
        RIP(("FindAgpCapability - Device does not support Capabilities list, not an AGP device"));
        return 0;
    }

    //
    // The device supports capability lists, find the AGP capabilities.
    //

    if ((Header.HeaderType & (~PCI_MULTIFUNCTION)) == PCI_BRIDGE_TYPE) 
    {
        CapabilityOffset = Header.u.type1.CapabilitiesPtr;
    } 
    else 
    {
        ASSERT((Header.HeaderType & (~PCI_MULTIFUNCTION)) == PCI_DEVICE_TYPE);
        CapabilityOffset = Header.u.type0.CapabilitiesPtr;
    }

    while (CapabilityOffset != 0) 
    {
        //
        // Read the Capability at this offset
        //

        ReadDeviceData(Bus, Slot, Capability, CapabilityOffset, sizeof(PCI_AGP_CAPABILITY));

        // Find it?
        if (Capability->Header.CapabilityID == PCI_CAPABILITY_ID_AGP) 
        {
            break;
        } 
        else 
        {
            CapabilityOffset = Capability->Header.Next;
        }
    }

    if (CapabilityOffset == 0) 
    {
        // No AGP capability was found
        RIP(("FindAgpCapability - Device does not have an AGP Capability entry, not an AGP device"));
        return 0;
    }

    return CapabilityOffset;
}

//----------------------------------------------------------------------------
// Write a capability to a device.
//
static void WriteAgpCapability(
    ULONG Bus,
    ULONG Slot,
    UCHAR CapabilityOffset,
    PCI_AGP_CAPABILITY *Capability
    )
{
    // Write the new information.
    WriteDeviceData(Bus, 
                    Slot, 
                    Capability, 
                    CapabilityOffset, 
                    sizeof(PCI_AGP_CAPABILITY));
}

//----------------------------------------------------------------------------
// Set up the hardware to talk to each other.
//
static void SetupAgp()
{
    AGPCTRL agpctrl;

    PCI_AGP_CAPABILITY HostCap;
    PCI_AGP_CAPABILITY CardCap;    

    UCHAR HostCapOffset;
    UCHAR CardCapOffset;

    ULONG DataRate;
    
    //
    // Initialize the host to support fast writes.
    //

    ReadHostRegister(&agpctrl, AGPCTRL_OFFSET, sizeof(agpctrl));

    agpctrl.FastWriteEnable = 1;

    WriteHostRegister(&agpctrl, AGPCTRL_OFFSET, sizeof(agpctrl));

    //
    // Get the capabilities of both the host and the card.
    //

    HostCapOffset = ReadAgpCapability(HOST_BUS, HOST_SLOT, &HostCap);
    CardCapOffset = ReadAgpCapability(CARD_BUS, CARD_SLOT, &CardCap);

    //
    // Check the data rate.
    //

    DataRate = HostCap.AGPStatus.Rate & CardCap.AGPStatus.Rate;

    if (!(DataRate & PCI_AGP_RATE_4X))
    {
        RIP(("SetupAgp   - Mainboard/graphic card does not support 4x AGP."));
    }

    // 
    // The current graphics card does not support sideband addressing.  Note if 
    // this changes.
    //
    if (HostCap.AGPStatus.SideBandAddressing & CardCap.AGPStatus.SideBandAddressing)
    {
        RIP(("SetupAgp   - Sideband addressing is now available."));
    }

    // 
    // Note if fast writes go away.
    //

    if (!(HostCap.AGPStatus.FastWrite & CardCap.AGPStatus.FastWrite))
    {
        RIP(("SetupAgp   - Fast write are not available."));
    }

    //
    // Enable the host first.
    //

    HostCap.AGPCommand.Rate = PCI_AGP_RATE_4X;
    HostCap.AGPCommand.AGPEnable = 1;
    HostCap.AGPCommand.SBAEnable = 0;
    HostCap.AGPCommand.FastWriteEnable = 1;
    HostCap.AGPCommand.FourGBEnable = 0;  

    WriteAgpCapability(HOST_BUS, HOST_SLOT, HostCapOffset, &HostCap);

    //
    // Now enable the card
    //

    CardCap.AGPCommand.Rate = PCI_AGP_RATE_4X;
    CardCap.AGPCommand.AGPEnable = 1;
    CardCap.AGPCommand.SBAEnable = 0;
    CardCap.AGPCommand.FastWriteEnable = 1;
    CardCap.AGPCommand.FourGBEnable = 0;  
    CardCap.AGPCommand.RequestQueueDepth = HostCap.AGPStatus.RequestQueueDepthMaximum;

    WriteAgpCapability(CARD_BUS, CARD_SLOT, CardCapOffset, &CardCap);
}

//============================================================================
// GART code
//============================================================================

//----------------------------------------------------------------------------
// Initialize and enable the GART
//
static BOOLEAN SetupGART()
{
    ULONG GartLength;
    GART_PTE *Gart;
    ULONG_PTR GartPhysical;
    AGPCTRL agpctrl;
    RDCR rdcr;
    ULONG i;

#if DBG

    ULONG ApBase;
    UCHAR ApSize;

    //
    // Verity the current APBASE and APSIZE settings
    //

    ReadHostRegister(&ApBase, APBASE_OFFSET, sizeof(ApBase));
    ReadHostRegister(&ApSize, APSIZE_OFFSET, sizeof(ApSize));

    if (ApSize != AGP_APERTURE_SIZE)
    {
        RIP(("SetupGART - Bad aperture size."));
    }

    if ((ApBase & PCI_ADDRESS_MEMORY_ADDRESS_MASK) != AGP_APERTURE_BASE)
    {
        RIP(("SetupGART - Bad Aperature base."));
    }

#endif DBG

    //
    // Try and get a chunk of contiguous memory big enough to map the
    // entire aperture.
    //

    GartLength = BYTES_TO_PAGES(AGP_APERTURE_BYTES) * sizeof(GART_PTE);

    Gart = MmAllocateContiguousMemorySpecifyCache(GartLength, 0, MAXULONG_PTR, 0, MmNonCached);

    if (Gart == NULL) 
    {
        RIP(("SetupGART - MmAllocateContiguousMemory failed\n"));
        return FALSE;
    }

    //
    // We successfully allocated a contiguous chunk of memory.
    // It should be page aligned already.
    //

    ASSERT(((ULONG_PTR)Gart & (PAGE_SIZE - 1)) == 0);

    //
    // Get the physical address.
    //

    GartPhysical = MmGetPhysicalAddress(Gart);

    //
    // Initialize all the PTEs
    //

    for (i = 0; i < GartLength/sizeof(GART_PTE); i++) 
    {
        Gart[i].Valid = 1;
        Gart[i].Page  = i;
    }

    //
    // Update the configuration
    //

    WriteHostRegister(&GartPhysical, ATTBASE_OFFSET, sizeof(GartPhysical));

    // 
    // Enable the gart apeture.
    //

    ReadHostRegister(&agpctrl, AGPCTRL_OFFSET, sizeof(agpctrl));
    agpctrl.EnableGART = 1;
    WriteHostRegister(&agpctrl, AGPCTRL_OFFSET, sizeof(agpctrl));

    ReadHostRegister(&rdcr, RDCR_OFFSET, sizeof(RDCR));
    rdcr.ApertureEnable = 1;
    WriteHostRegister(&rdcr, RDCR_OFFSET, sizeof(RDCR));

    return TRUE;
}

//============================================================================
// Main entrypoint
//============================================================================

//----------------------------------------------------------------------------
// Entrypoint for AGP initializes.  Sets up all AGP stuff for both the host
// and the card.
//
BOOLEAN AgpUmaEnable()
{
    SetupAgp();

    if (!SetupGART())
    {
        return FALSE; 
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\minix\initx.c ===
/*++

Copyright (c) 1989-2000  Microsoft Corporation

Module Name:

    initx.c

Abstract:

    This module contains the code to initialize the video hardware

--*/


#include "minixp.h"


//
// Global variable to hold driver extension
//

PMINIX_DRIVER_EXTENSION MxDriverExtension;


//
// Local functions
//

BOOLEAN
MxPortInterrupt(
    IN PKINTERRUPT InterruptObject,
    IN PVOID ServiceContext
    );

VOID
MxDpcDispatcher(
    IN PKDPC Dpc,
    IN PVOID HwDeviceExtension,
    IN PVOID DpcRoutine,
    IN PVOID Context
    );


//
// Functions defined else where
//

VP_STATUS
NVFindAdapter(
    PVOID HwDeviceExtension,
    PVOID HwContext,
    PWSTR ArgumentString,
    PVIDEO_PORT_CONFIG_INFO ConfigInfo,
    PUCHAR Again
    );

BOOLEAN
NVInitialize(
    PVOID HwDeviceExtension
    );

BOOLEAN
NVStartIO(
    PVOID HwDeviceExtension,
    PVIDEO_REQUEST_PACKET RequestPacket
    );

BOOLEAN
NVInterrupt(
    PVOID HwDeviceExtension
    );

BOOL    
RmInitRm(
    VOID
    );


LONG
MxSetVideoMode(
    IN PMINIX_MODE_INFO ModeInfo
    );


LONG
MxAllocContextDma(
    IN ULONG Dma,
    IN ULONG Class,
    IN ULONG Flags,
    IN PVOID Base,
    IN ULONG Limit
    );




VOID
MxDpcDispatcher(
    IN PKDPC Dpc,
    IN PVOID HwDeviceExtension,
    IN PVOID DpcRoutine,
    IN PVOID Context
    )

/*++

Routine Description:

    This routine handles DPCs and forwards them to the miniport callback
    routine.

Arguments:

    Dpc - The DPC which is executing.

    HwDeviceExtension - The HwDeviceExtension for the device which scheduled
        the DPC.

    DpcRoutine - The callback in the miniport which needs to be called.

    Context - The miniport supplied context.

Returns:

    None.

--*/

{
    ((PMINIPORT_DPC_ROUTINE)(ULONG_PTR)DpcRoutine)(HwDeviceExtension, Context);
}



BOOLEAN
MxPortInterrupt(
    IN PKINTERRUPT InterruptObject,
    IN PVOID ServiceContext
    )
{
    BOOLEAN Handled;
    PVIDEO_DEVICE_EXTENSION VideoDeviceExtension;
    PHW_DEVICE_EXTENSION HwDeviceExtension;

    VideoDeviceExtension = &(MxDriverExtension->VideoExtension);
    HwDeviceExtension = &(MxDriverExtension->HwExtension);

    if (VideoDeviceExtension->InterruptsEnabled) {
        Handled = VideoDeviceExtension->HwInterrupt(HwDeviceExtension);
    } else {
        Handled = FALSE;
    }

    return Handled;
}





LONG
MxInitSystem(
    IN PVOID Argument1
    )
/*++

Routine Description:

    This routine initializes the I/O system.

Arguments:

    Argument1 - Supplies a pointer to the driver object

Return Value:

    Status of the operation

--*/
{
    NTSTATUS status;
    SYSTEM_BASIC_INFORMATION BasicInformation;
    PCI_SLOT_NUMBER SlotNumber;
    PCI_COMMON_CONFIG Configuration;
    VP_STATUS vpstatus;
    VIDEO_PORT_CONFIG_INFO ConfigInfo;
    UCHAR Again;
    ULONG InterruptVector;
    KIRQL InterruptIrql;
    PVIDEO_DEVICE_EXTENSION VideoDeviceExtension;
    PHW_DEVICE_EXTENSION HwDeviceExtension;
    PDRIVER_OBJECT DriverObject;

    DriverObject = (PDRIVER_OBJECT)Argument1;

    //
    // Initialize the Driver Object 
    //
    
    DriverObject->MajorFunction[IRP_MJ_MINIX_CREATE] = (PDRIVER_DISPATCH)MxCreatePort;
    DriverObject->MajorFunction[IRP_MJ_MINIX_SETVIDEOMODE] = (PDRIVER_DISPATCH)MxSetVideoMode;
    DriverObject->MajorFunction[IRP_MJ_MINIX_ALLOCCONTEXTDMA] = (PDRIVER_DISPATCH)MxAllocContextDma;

    MxDriverExtension = ExAllocatePoolWithTag(NonPagedPool, sizeof(MINIX_DRIVER_EXTENSION), 'rDxM');

    if (MxDriverExtension == NULL) {
        return (LONG)STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(MxDriverExtension, sizeof(MINIX_DRIVER_EXTENSION));

    VideoDeviceExtension = &(MxDriverExtension->VideoExtension);
    HwDeviceExtension = &(MxDriverExtension->HwExtension);
    
    //
    // Figure out how much physical memory is in the system.
    //

    status = NtQuerySystemInformation(SystemBasicInformation, &BasicInformation,
        sizeof(SYSTEM_BASIC_INFORMATION), NULL);

    if (!NT_SUCCESS(status)) {
        return (LONG)status;
    }

    //
    // Read the PCI configuration data for the adapter attached to the AGP440 bus.
    //

    SlotNumber.u.AsULONG = 0;
    SlotNumber.u.bits.DeviceNumber = AGP440_TARGET_DEVICE_NUMBER;
    SlotNumber.u.bits.FunctionNumber = AGP440_TARGET_FUNCTION_NUMBER;

    if (HalGetBusData(PCIConfiguration, 1, SlotNumber.u.AsULONG, &Configuration,
        sizeof(PCI_COMMON_CONFIG)) != sizeof(PCI_COMMON_CONFIG)) {
        return (LONG)STATUS_DEVICE_DOES_NOT_EXIST;
    }

    //
    // Verify that this looks something like an NVidia display controller and
    // that the configuration is in the state that we expect.
    //

    ASSERT(Configuration.BaseClass == PCI_CLASS_DISPLAY_CTLR);
    ASSERT(Configuration.VendorID == 0x10DE);
    ASSERT(VideoIsFlagSet(Configuration.Command, PCI_ENABLE_IO_SPACE));
    ASSERT(VideoIsFlagSet(Configuration.Command, PCI_ENABLE_BUS_MASTER));

    //
    // Initialize the video device extension.
    //

    VideoDeviceExtension->HwFindAdapter = NVFindAdapter;
    VideoDeviceExtension->HwInitialize = NVInitialize;
    VideoDeviceExtension->HwInterrupt = NVInterrupt;
    VideoDeviceExtension->HwStartIO = NVStartIO;

    RtlCopyMemory(VideoDeviceExtension->BaseAddresses, Configuration.u.type0.BaseAddresses,
        sizeof(ULONG) * PCI_TYPE0_ADDRESSES);

    KeInitializeDpc(&VideoDeviceExtension->Dpc, MxDpcDispatcher, HwDeviceExtension);  

    KeInitializeMutex(&VideoDeviceExtension->SyncMutex, 0);

    if (!AgpUmaEnable()) {
        return (LONG)STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // Invoke the miniport's HwFindAdapter routine.
    //

    RtlZeroMemory(&ConfigInfo, sizeof(VIDEO_PORT_CONFIG_INFO));

    ConfigInfo.Length = sizeof(VIDEO_PORT_CONFIG_INFO);
    ConfigInfo.BusInterruptLevel = 0xFF;
    ConfigInfo.BusInterruptVector = 0xFF;
    ConfigInfo.SystemMemorySize = (ULONGLONG)BasicInformation.NumberOfPhysicalPages << PAGE_SHIFT;

    vpstatus = VideoDeviceExtension->HwFindAdapter(HwDeviceExtension, NULL,
        NULL, &ConfigInfo, &Again);

    if (vpstatus != NO_ERROR) {
        return (LONG)STATUS_DEVICE_DOES_NOT_EXIST;
    }

    //
    // Connect to the device's interrupt.
    //

    VideoDeviceExtension->InterruptsEnabled = TRUE;

    InterruptVector = HalGetInterruptVector(PCIBus, 0,
        Configuration.u.type0.InterruptLine, Configuration.u.type0.InterruptLine,
        &InterruptIrql);

    status = IoConnectInterrupt(&(VideoDeviceExtension->InterruptObject),
        MxPortInterrupt, VideoDeviceExtension, InterruptVector,
        InterruptIrql, InterruptIrql, LevelSensitive, TRUE);

    if (!NT_SUCCESS(status)) {
        return (LONG)status;
    }
                         
    //
    // Initialize resource manager
    //
    if (!RmInitRm()) {
        return (LONG)STATUS_UNSUCCESSFUL;
    }


    return (LONG)STATUS_SUCCESS;
}



LONG
MxCreatePort(
    VOID
    )
{
    PVIDEO_DEVICE_EXTENSION VideoDeviceExtension;
    PHW_DEVICE_EXTENSION HwDeviceExtension;

    VideoDeviceExtension = &(MxDriverExtension->VideoExtension);
    HwDeviceExtension = &(MxDriverExtension->HwExtension);

    if (VideoDeviceExtension->DeviceOpened) {
        // 
        // Calling this function more than once has no effect
        //
        return (LONG)STATUS_SUCCESS;
    }

    //
    // Invoke the miniport's HwInitialize routine.
    //

    if (!VideoDeviceExtension->HwInitialize(HwDeviceExtension)) {
        return (LONG)STATUS_UNSUCCESSFUL;
    }

    VideoDeviceExtension->DeviceOpened = TRUE;
    
    return (LONG)STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\minix\drvx.c ===
/*++

Copyright (c) 1989-2000  Microsoft Corporation

Module Name:

    drvx.c

Abstract:

    This module contains the code to initialize the video hardware

--*/

#include "minixp.h"
#include <nvntioctl.h>
#include "nv32.h"
#include "nvddobj.h"
#include <nvos.h>

//
// Sends an IOCTL to the miniport by calling MxDeviceIoControl.  To use this macro
// your shoud have these 'status' and 'BytesReturned' locals defined and CleanupAndExit label
//

#define IOCTL_CMD(Code, InBuf, InLen, OutBuf, OutLen) { \
            status = MxDeviceIoControl(Code, InBuf, InLen, OutBuf, OutLen, &BytesReturned); \
            if (!NT_SUCCESS(status)) goto CleanupAndExit; }

//
// Helper macro to check status of the return call
//
#define CHECKSTATUS(x) { status = (x); if (!NT_SUCCESS(status)) goto CleanupAndExit; }
  

extern PMINIX_DRIVER_EXTENSION MxDriverExtension;



typedef struct _VIDEOMODEDEF
{
    USHORT  Mode;
    USHORT  Width;
    USHORT  Height;
    UCHAR   Depth;
    UCHAR   Refresh;

} VIDEOMODEDEF, *PVIDEOMODEDEF;


VIDEOMODEDEF g_VideoModeDef[] =
{
#define DEF_VIDEOMODE(Mode, Width, Height, Depth, Refresh) {Mode, Width, Height, Depth, Refresh},
#include "modes.h"
#undef DEF_VIDOEMODE
};






BOOLEAN
NVStartIO(
    PVOID HwDeviceExtension,
    PVIDEO_REQUEST_PACKET RequestPacket
    );



VOID
pVideoPortMapToNtStatus(
    IN PSTATUS_BLOCK StatusBlock
    );


//
// Nvidia object ids
//

#define DD_DEVICE_OBJECT_HANDLE                     (0x00002002)
#define DD_FRAME_BUFFER_OBJECT_HANDLE               (0x000C0006)

#define DD_CONTEXT_DMA_IN_MEMORY_VIDEO_MEM          (0x00001022)

//
// Nvidia alloc context dma flags
//
#define ALLOC_CTX_DMA_FLAGS_ACCESS_RD_WR                    0x00000000
#define ALLOC_CTX_DMA_FLAGS_ACCESS_READ_ONLY                0x00000001
#define ALLOC_CTX_DMA_FLAGS_ACCESS_WRITE_ONLY               0x00000002

#define ALLOC_CTX_DMA_FLAGS_CONTIGUOUS_PHYSICALITY          0x00000000
#define ALLOC_CTX_DMA_FLAGS_NONCONTIGUOUS_PHYSICALITY       0x00000010

#define ALLOC_CTX_DMA_FLAGS_LOCKED_ALWAYS                   0x00000000
#define ALLOC_CTX_DMA_FLAGS_LOCKED_IN_TRANSIT               0x00000100

#define ALLOC_CTX_DMA_FLAGS_COHERENCY_UNCACHED              0x00000000
#define ALLOC_CTX_DMA_FLAGS_COHERENCY_CACHED                0x00001000

#define ALLOC_CTX_DMA_FLAGS_LOCKED_CACHED                   ALLOC_CTX_DMA_FLAGS_LOCKED_ALWAYS + ALLOC_CTX_DMA_FLAGS_COHERENCY_CACHED



NTSTATUS
MxDeviceIoControl(
    IN ULONG IoControlCode,
    IN PVOID InputBuffer OPTIONAL,
    IN ULONG InputBufferLength,
    OUT PVOID OutputBuffer OPTIONAL,
    IN ULONG OutputBufferLength,
    OUT PULONG BytesReturned
    )

/*++

Routine Description:

    This routine builds an vrp and calls miniport start io function directly.

Arguments:

Return Value:

    Status of the operation

--*/

{
    NTSTATUS status;
    KEVENT event;
    STATUS_BLOCK StatusBlock;
    PHW_DEVICE_EXTENSION HwDeviceExtension;
    PVIDEO_DEVICE_EXTENSION VideoDeviceExtension;
    VIDEO_REQUEST_PACKET vrp;


    //
    // we only support METHOD_BUFFERED
    //

    if ((IoControlCode & 3) != METHOD_BUFFERED) {
        return STATUS_UNSUCCESSFUL;
    }


    HwDeviceExtension = &(MxDriverExtension->HwExtension);
    VideoDeviceExtension = &(MxDriverExtension->VideoExtension);

    KeInitializeEvent(&event, SynchronizationEvent, FALSE);


    //
    // Initialize the vrp
    //
    RtlZeroMemory(&StatusBlock, sizeof(STATUS_BLOCK));

    vrp.IoControlCode = IoControlCode;
    vrp.StatusBlock = &StatusBlock;
    vrp.InputBuffer = InputBuffer;
    vrp.InputBufferLength = InputBufferLength;
    vrp.OutputBuffer = OutputBuffer;
    vrp.OutputBufferLength = OutputBufferLength;

    //
    // Call the start io routine directly
    //

    ACQUIRE_DEVICE_LOCK(VideoDeviceExtension);

    VideoDeviceExtension->HwStartIO(HwDeviceExtension, &vrp);

    RELEASE_DEVICE_LOCK(VideoDeviceExtension);

    if (StatusBlock.Status != NO_ERROR) {
        pVideoPortMapToNtStatus(&StatusBlock);
    }

    status = StatusBlock.Status;

    //
    // If the call is synchronous, the IO is always completed
    // and the Status is the same as the Iosb.Status.
    //

    if (status == STATUS_PENDING) {

        KeWaitForSingleObject(&event, UserRequest, KernelMode, TRUE, NULL);
    }

    *BytesReturned = StatusBlock.Information;


    return status;
}



VOID
pVideoPortMapToNtStatus(
    IN PSTATUS_BLOCK StatusBlock
    )

/*++

Routine Description:

    This function maps a Win32 error code to an NT error code, making sure
    the inverse translation will map back to the original status code.

Arguments:

    StatusBlock - Pointer to the status block

Return Value:

    None.

--*/

{
    PNTSTATUS status = &StatusBlock->Status;

    switch (*status) {

    case ERROR_INVALID_FUNCTION:
        *status = STATUS_NOT_IMPLEMENTED;
        break;

    case ERROR_NOT_ENOUGH_MEMORY:
        *status = STATUS_INSUFFICIENT_RESOURCES;
        break;

    case ERROR_INVALID_PARAMETER:
        *status = STATUS_INVALID_PARAMETER;
        break;

    case ERROR_INSUFFICIENT_BUFFER:
        *status = STATUS_BUFFER_TOO_SMALL;

        //
        // Make sure we zero out the information block if we get an
        // insufficient buffer.
        //

        StatusBlock->Information = 0;
        break;

    case ERROR_MORE_DATA:
        *status = STATUS_BUFFER_OVERFLOW;
        break;

    case ERROR_DEV_NOT_EXIST:
        *status = STATUS_DEVICE_DOES_NOT_EXIST;
        break;

    case ERROR_IO_PENDING:
        ASSERT(FALSE);
        // Fall through.

    case NO_ERROR:
        *status = STATUS_SUCCESS;
        break;

    default:

        ASSERT(FALSE);

        *status = STATUS_UNSUCCESSFUL;

        break;

    }

    return;

} 



NTSTATUS
NvAllocRoot(
    ULONG hClass,
    ULONG *phClient
    )
{
    NVOS01_PARAMETERS parms;
    PVOID pParms;

    ULONG BytesReturned;
    NTSTATUS status;

    parms.hClass = hClass;
    pParms = &parms;


    IOCTL_CMD((ULONG)IOCTL_NV01_ALLOC_ROOT,
        (&pParms),
        sizeof(PVOID),
        (&parms),
        (ULONG)sizeof(NVOS01_PARAMETERS));

    *phClient = (ULONG)parms.hObjectNew;

    status = (parms.status == 0 ? STATUS_SUCCESS : STATUS_UNSUCCESSFUL);

CleanupAndExit:

    return status;

}


NTSTATUS
NvAllocDevice(
    ULONG hClient,
    ULONG hDevice,
    ULONG hClass,
    PUCHAR szName
    )
{
    NVOS06_PARAMETERS parms;
    PVOID pParms;

    ULONG BytesReturned;
    NTSTATUS status;

    parms.hObjectParent     = (NvV32)hClient;
    parms.hObjectNew        = (NvV32)hDevice;
    parms.hClass            = (NvV32)hClass;

#ifdef NV20MINIX
    parms.szName            = (NvP64)szName;
#else
    parms.szName            = (NvV32)szName;
#endif
    
    pParms = &parms;

    IOCTL_CMD((ULONG)IOCTL_NV01_ALLOC_DEVICE,
        (&pParms),
        sizeof(PVOID),
        (&parms),
        sizeof(NVOS06_PARAMETERS));

    status = (parms.status == 0 ? STATUS_SUCCESS : STATUS_UNSUCCESSFUL);

CleanupAndExit:

    return status;
}


NTSTATUS
NvAllocContextDma(
    ULONG hClient,
    ULONG hDma,
    ULONG hClass,
    ULONG flags,
    PVOID base,
    ULONG limit
    )
{
    NVOS03_PARAMETERS parms;
    PVOID pParms;

    ULONG BytesReturned;
    NTSTATUS status;

    parms.hObjectParent     = (NvV32)hClient;
    parms.hObjectNew        = (NvV32)hDma;
    parms.hClass            = (NvV32)hClass;
    parms.flags             = (NvV32)flags;
#ifdef NV20MINIX
    parms.pBase             = (NvP64)base;
    parms.limit             = (NvU64)limit;
#else    
    parms.pBase.selector    = 0x00000000;
    parms.pBase.offset      = (NvU32)base;
    parms.limit.high        = 0x00000000;
    parms.limit.low         = (NvU32)limit;
#endif

    pParms = &parms;

    IOCTL_CMD((ULONG)IOCTL_NV01_ALLOC_CONTEXT_DMA,
        (&pParms),
        sizeof(PVOID),
        (&parms),
        sizeof(NVOS03_PARAMETERS));

    status = (parms.status == 0 ? STATUS_SUCCESS : STATUS_UNSUCCESSFUL);

CleanupAndExit:

    return status;
}


NTSTATUS
NvAllocObject(
    ULONG hClient,
    ULONG hChannel,
    ULONG hObject,
    ULONG hClass
    )
{
    NVOS05_PARAMETERS parms;
    PVOID pParms;

    ULONG BytesReturned;
    NTSTATUS status;


    // set input parameters
    parms.hRoot             = (NvV32)hClient;
    parms.hObjectParent     = (NvV32)hChannel;
    parms.hObjectNew        = (NvV32)hObject;
    parms.hClass            = (NvV32)hClass;
    pParms = &parms;

    IOCTL_CMD((ULONG)IOCTL_NV01_ALLOC_OBJECT,
        (&pParms),
        sizeof(PVOID),
        (&parms),
        sizeof(NVOS05_PARAMETERS));

    status = (parms.status == 0 ? STATUS_SUCCESS : STATUS_UNSUCCESSFUL);

CleanupAndExit:

    return status;
}


NTSTATUS
NvAllocEvent(
    ULONG hClient,
    ULONG hParent,
    ULONG hObject,
    ULONG hClass,
    ULONG index,
    ULONG hEvent
    )
{
    NVOS10_PARAMETERS parms;
    PVOID pParms;

    ULONG BytesReturned;
    NTSTATUS status;

    // set input parameters
    parms.hRoot             = (NvV32)hClient;
    parms.hObjectParent     = (NvV32)hParent;
    parms.hObjectNew        = (NvV32)hObject;
    parms.hClass            = (NvV32)hClass;
    parms.index             = (NvV32)index;

#ifdef NV20MINIX
    parms.hEvent            = (NvU64)hEvent;
#else
    parms.hEvent.low        = (NvV32)hEvent;
    parms.hEvent.high       = (NvV32)0;
#endif

    pParms = &parms;

    IOCTL_CMD((ULONG)IOCTL_NV01_ALLOC_EVENT,
        (&pParms),
        sizeof(PVOID),
        (&parms),
        sizeof(NVOS10_PARAMETERS));

    status = (parms.status == 0 ? STATUS_SUCCESS : STATUS_UNSUCCESSFUL);

CleanupAndExit:

    return status;
}


NTSTATUS
NvFree(
    ULONG hClient,
    ULONG hParent,
    ULONG hObject
    )
{
    NVOS00_PARAMETERS parms;
    PVOID pParms;

    ULONG BytesReturned;
    NTSTATUS status;

    parms.hRoot             = (NvV32)hClient;
    parms.hObjectParent     = (NvV32)hParent;
    parms.hObjectOld        = (NvV32)hObject;
    pParms = &parms;

    IOCTL_CMD((ULONG)IOCTL_NV01_FREE,
        (&pParms),
        sizeof(PVOID),
        (&parms),
        sizeof(NVOS00_PARAMETERS));

    status = (parms.status == 0 ? STATUS_SUCCESS : STATUS_UNSUCCESSFUL);

CleanupAndExit:

    return status;
}


NTSTATUS
NvAllocMemory(
    ULONG hClient,
    ULONG hParent,
    ULONG hMemory,
    ULONG hClass,
    ULONG flags,
    PVOID *ppAddress,
    ULONG *pLimit
    )
{
    NVOS02_PARAMETERS parms;
    PVOID pParms;

    ULONG BytesReturned;
    NTSTATUS status;


    // set input parameters
    parms.hRoot             = (NvV32)hClient;
    parms.hObjectParent     = (NvV32)hParent;
    parms.hObjectNew        = (NvV32)hMemory;
    parms.hClass            = (NvV32)hClass;
    parms.flags             = (NvV32)flags;

#ifdef NV20MINIX
    parms.pMemory           = (NvP64)*ppAddress;
    parms.pLimit            = (NvU64)*pLimit;
#else
    parms.pMemory.selector  = 0x00000000;
    parms.pMemory.offset    = (NvU32)*ppAddress;
    parms.pLimit.high       = 0x00000000;
    parms.pLimit.low        = (NvU32)*pLimit;
#endif

    pParms = &parms;

    IOCTL_CMD((ULONG)IOCTL_NV01_ALLOC_MEMORY,
        (&pParms),
        sizeof(PVOID),
        (&parms),
        sizeof(NVOS02_PARAMETERS));

#ifdef NV20MINIX
    *ppAddress = (PVOID)((ULONG)parms.pMemory);
    *pLimit = (ULONG)parms.pLimit;
#else
    *ppAddress = (PVOID)parms.pMemory.offset;
    *pLimit = (ULONG)parms.pLimit.low;
#endif

    status = (parms.status == 0 ? STATUS_SUCCESS : STATUS_UNSUCCESSFUL);

CleanupAndExit:

    return status;
}



ULONG 
NvAllocChannelDma(
    ULONG hClient,
    ULONG hDevice,
    ULONG hChannel,
    ULONG hClass,
    ULONG hErrorCtx,
    ULONG hDataCtx,
    ULONG offset,
    PVOID *ppChannel
    )
{
    NVOS07_PARAMETERS parms;
    PVOID pParms;
    
    ULONG BytesReturned;
    NTSTATUS status;

    parms.hRoot             = (NvV32)hClient;
    parms.hObjectParent     = (NvV32)hDevice;
    parms.hObjectNew        = (NvV32)hChannel;
    parms.hClass            = (NvV32)hClass;
    parms.hObjectError      = (NvV32)hErrorCtx;
    parms.hObjectBuffer     = (NvV32)hDataCtx;
    parms.offset            = (NvU32)offset;
    pParms = &parms;

    IOCTL_CMD((ULONG)IOCTL_NV03_ALLOC_CHANNEL_DMA,
        (&pParms),
        sizeof(PVOID),
        (&parms),
        sizeof(NVOS07_PARAMETERS));

#ifdef NV20MINIX
    *ppChannel = (PVOID)((ULONG)parms.pControl);
#else
    *ppChannel = (PVOID)parms.pControl.offset;
#endif

    status = (parms.status == 0 ? STATUS_SUCCESS : STATUS_UNSUCCESSFUL);

CleanupAndExit:

    return status;
}





LONG
MxAllocContextDma(
    IN ULONG Dma,
    IN ULONG Class,
    IN ULONG Flags,
    IN PVOID Base,
    IN ULONG Limit
    )
{
    return NvAllocContextDma(MxDriverExtension->Client, Dma, Class, Flags, Base, Limit);
}





NTSTATUS
MxCreateObjects(
    VOID
    )
{

    NTSTATUS status;

    //
    // Create objects
    //

#if defined(NV20MINIX) && defined(KELVIN)

    CHECKSTATUS(NvAllocObject(MxDriverExtension->Client,
                           NV_DD_DEV_DMA,
                           D3D_KELVIN_PRIMITIVE,
                           NV20_KELVIN_PRIMITIVE));

#else

    CHECKSTATUS(NvAllocObject(MxDriverExtension->Client, 
                           NV_DD_DEV_DMA, 
                           D3D_CELSIUS_PRIMITIVE, 
                           NV10_CELSIUS_PRIMITIVE));

    CHECKSTATUS(NvAllocObject(MxDriverExtension->Client, 
                           NV_DD_DEV_DMA,
                           D3D_RENDER_SOLID_RECTANGLE, 
                           NV4_RENDER_SOLID_RECTANGLE));

#endif

    CHECKSTATUS(NvAllocObject(MxDriverExtension->Client, 
                           NV_DD_DEV_DMA,
                           NV_DD_SURFACES_2D, 
                           NV10_CONTEXT_SURFACES_2D));

    CHECKSTATUS(NvAllocObject(MxDriverExtension->Client, 
                           NV_DD_DEV_DMA,
                           NV_DD_VIDEO_LUT_CURSOR_DAC, 
                           NV05_VIDEO_LUT_CURSOR_DAC));

CleanupAndExit:

    return status;
}



NTSTATUS
MxAllocContextDmas(
    IN PMINIX_MODE_INFO ModeInfo,
    IN PVOID VidMemAddress,
    IN ULONG VidMemLength
    )
{

    NTSTATUS status;

    CHECKSTATUS(NvAllocContextDma(MxDriverExtension->Client, 
                                  DD_CONTEXT_DMA_IN_MEMORY_VIDEO_MEM,
                                  NV01_CONTEXT_DMA, 
                                  NVOS03_FLAGS_ACCESS_READ_WRITE, 
                                  VidMemAddress, 
                                  VidMemLength));


    CHECKSTATUS(NvAllocContextDma(MxDriverExtension->Client, 
                                  NV_DD_DMA_CONTEXT_DMA_IN_VIDEO_MEMORY,
                                  NV01_CONTEXT_DMA, 
                                  (ALLOC_CTX_DMA_FLAGS_ACCESS_RD_WR |
                                     ALLOC_CTX_DMA_FLAGS_COHERENCY_UNCACHED),
                                  VidMemAddress, 
                                  VidMemLength));


    CHECKSTATUS(NvAllocContextDma(MxDriverExtension->Client, 
                               NV_DD_DMA_CONTEXT_DMA_FROM_VIDEO_MEMORY,
                               NV01_CONTEXT_DMA, 
                               (ALLOC_CTX_DMA_FLAGS_ACCESS_READ_ONLY |
                                  ALLOC_CTX_DMA_FLAGS_COHERENCY_UNCACHED),
                               VidMemAddress, 
                               VidMemLength));

    
    CHECKSTATUS(NvAllocContextDma(MxDriverExtension->Client, 
                                  NV_DD_DMA_CONTEXT_DMA_TO_VIDEO_MEMORY,
                                  NV01_CONTEXT_DMA, 
                                  (ALLOC_CTX_DMA_FLAGS_ACCESS_WRITE_ONLY |
                                      ALLOC_CTX_DMA_FLAGS_COHERENCY_UNCACHED),
                                  VidMemAddress, 
                                  VidMemLength));

    //
    // Create DMA contexts for notifications
    //
    
    CHECKSTATUS(NvAllocContextDma(MxDriverExtension->Client, 
                                  NV_DD_DMA_PUSHER_SYNC_NOTIFIER_CONTEXT_DMA_TO_MEMORY,
                                  NV01_CONTEXT_DMA, 
                                  ALLOC_CTX_DMA_FLAGS_ACCESS_WRITE_ONLY,
                                  (PVOID)ModeInfo->NotificationBase,
                                  (2 * sizeof(NvNotification) - 1)) );


    //
    // Create DMA context for host memory
    //
    CHECKSTATUS(NvAllocContextDma(MxDriverExtension->Client, 
                                  D3D_CONTEXT_DMA_HOST_MEMORY, 
                                  NV01_CONTEXT_DMA,
                                  (ALLOC_CTX_DMA_FLAGS_ACCESS_READ_ONLY | 
                                      ALLOC_CTX_DMA_FLAGS_LOCKED_CACHED),
                                  (PVOID)ModeInfo->HostMemoryBase, 
                                  ModeInfo->HostMemoryLimit));


    //
    // Allocate context DMA for the push buffer
    //

#if defined(NV20MINIX) && defined(KELVIN)

    CHECKSTATUS(NvAllocContextDma(MxDriverExtension->Client, 
                                  NV_DD_DMA_PUSHER_CONTEXT_DMA_FROM_MEMORY, 
                                  NV01_CONTEXT_DMA,
                                  (ALLOC_CTX_DMA_FLAGS_ACCESS_READ_ONLY | 
                                      ALLOC_CTX_DMA_FLAGS_LOCKED_CACHED),
                                  (PVOID)ModeInfo->HostMemoryBase, 
                                  ModeInfo->HostMemoryLimit));

#else !KELVIN

    CHECKSTATUS(NvAllocContextDma(MxDriverExtension->Client, 
                                  NV_DD_DMA_PUSHER_CONTEXT_DMA_FROM_MEMORY, 
                                  NV01_CONTEXT_DMA,
                                  (ALLOC_CTX_DMA_FLAGS_ACCESS_READ_ONLY | 
                                      ALLOC_CTX_DMA_FLAGS_LOCKED_CACHED),
                                  (PVOID)ModeInfo->PushBase, 
                                  ModeInfo->PushLimit));

#endif !KELVIN

CleanupAndExit:

    return status;
}




LONG
MxSetVideoMode(
    IN OUT PMINIX_MODE_INFO ModeInfo
    )
{
    ULONG BytesReturned;
    NTSTATUS status;

    ULONG Device;
    ULONG DeviceReference;

    VIDEO_PUBLIC_ACCESS_RANGES VideoAccessRange[16];
    
    VIDEO_MEMORY VideoMemory;
    VIDEO_MEMORY_INFORMATION VideoMemoryInfo;

    union
    {
        ULONG osName;
        CHAR devName[128];
    } NameBuffer;


    ULONG Mode;
    ULONG ModeIndex;
    PVIDEOMODEDEF ModeDef;

    BOOLEAN HwVidOvl;

    VIDEO_MODE_INFORMATION VideoModeInfo;
    TV_CURSOR_ADJUST_INFO CursorAdjustInfo;

    PVOID VidMemAddress;
    PVOID Temp;
    ULONG VidMemLength;
    ULONG VidMemHandle;

    BOOLEAN FullInit;


    Device = DD_DEVICE_OBJECT_HANDLE;
    VidMemAddress = 0;

    //
    // Determine if we need to do full initialization
    //
    FullInit = (BOOLEAN)(ModeInfo->PushBase != 0);



    if (FullInit) {
        
        // 
        // Enable P6 write combining when mapping the video memory
        //
        IOCTL_CMD(IOCTL_VIDEO_ENABLE_WRITE_COMBINING,
            NULL,
            0,
            NULL,
            0);
    
        // 
        // Get the device reference from the miniport to the device class
        //
        IOCTL_CMD(IOCTL_VIDEO_GET_DEVICE_REF,
            NULL,
            0,
            &DeviceReference,
            sizeof(ULONG));
    
    
        //
        // Get virtual addresses for the memory ranges
        //
        IOCTL_CMD(IOCTL_VIDEO_QUERY_PUBLIC_ACCESS_RANGES,
            NULL,                     
            0,
            VideoAccessRange,         
            sizeof(VideoAccessRange));


        //
        // Get the linear memory address range for the video memory
        //
        VideoMemory.RequestedVirtualAddress = NULL;
    
        IOCTL_CMD(IOCTL_VIDEO_MAP_VIDEO_MEMORY,
            &VideoMemory,      
            sizeof(VIDEO_MEMORY),
            &VideoMemoryInfo,  
            sizeof(VideoMemoryInfo));

        VidMemAddress = VideoMemoryInfo.FrameBufferBase;

        // 
        // Register the client 
        //
        CHECKSTATUS(NvAllocRoot(NV01_ROOT, &(MxDriverExtension->Client)));
    
        //
        // Allocate the device
        //
        NameBuffer.osName = DeviceReference;
    
        CHECKSTATUS(NvAllocDevice(MxDriverExtension->Client, Device, NV03_DEVICE_XX, NameBuffer.devName));
    }

    //
    // Set the video mode
    //
    status = STATUS_INVALID_PARAMETER; 

    ModeDef = &g_VideoModeDef[0];
    for (ModeIndex = 0; ModeIndex < (sizeof(g_VideoModeDef) / sizeof(g_VideoModeDef[0])); 
         ModeIndex++) {
        
        if (ModeInfo->Width == ModeDef->Width && 
            ModeInfo->Height == ModeDef->Height &&
            ModeInfo->BitDepth == ModeDef->Depth) {
            
            Mode = ModeDef->Mode;
            status = STATUS_SUCCESS;
            break;
        }

        ModeDef++;
    }

    if (!NT_SUCCESS(status)) {
        goto CleanupAndExit;            
    }


    IOCTL_CMD(IOCTL_VIDEO_SET_CURRENT_MODE,
        &Mode,  
        sizeof(ULONG),
        &HwVidOvl,
        sizeof(BOOLEAN));


    //
    // Get video mode information
    //
    IOCTL_CMD(IOCTL_VIDEO_QUERY_CURRENT_MODE,
        NULL,
        0,
        &VideoModeInfo,
        sizeof(VideoModeInfo));


    //
    // Get cursor adjust information
    //
    IOCTL_CMD(IOCTL_VIDEO_GET_TV_CURSOR_ADJUST_INFO,
        NULL,
        0,
        &CursorAdjustInfo,
        sizeof(CursorAdjustInfo));


    if (FullInit) {
        
        //
        // Get the size for video memory from RM
        //
        Temp = (PVOID)1;  // NO_MAPPING
        VidMemHandle = DD_FRAME_BUFFER_OBJECT_HANDLE;
        CHECKSTATUS(NvAllocMemory(MxDriverExtension->Client, Device, VidMemHandle, NV01_MEMORY_LOCAL_USER, 0,
                                  &Temp, &VidMemLength));
    
        
        //
        // Return the video memory address
        //
        ModeInfo->VidMemAddress = VidMemAddress;
    
        //
        // Return the base address of the hardware.
        //
        ModeInfo->NvBase = VideoAccessRange[0].VirtualAddress;

        // BUGBUG: testcode: clear memory
        memset((PVOID)((unsigned char*)VidMemAddress), 0xFF, VidMemLength);
        // end test code

    
        //
        // Allocate DMA contexts to video memory. 
        //
        
        CHECKSTATUS(MxAllocContextDmas(ModeInfo, VidMemAddress, VidMemLength));

        //
        // Allocate channel DMA for the push buffer
        //

#if defined(NV20MINIX) && defined(KELVIN)

        CHECKSTATUS(NvAllocChannelDma(MxDriverExtension->Client,
                                      Device,
                                      NV_DD_DEV_DMA,
                                      NV20_CHANNEL_DMA,
                                      0,
                                      NV_DD_DMA_PUSHER_CONTEXT_DMA_FROM_MEMORY,
                                      0,
                                      (PVOID*)&(ModeInfo->DevFlatDma)));
#else
    
        CHECKSTATUS(NvAllocChannelDma(MxDriverExtension->Client, 
                                      Device, 
                                      NV_DD_DEV_DMA,
                                      NV10_CHANNEL_DMA, 
                                      0, 
                                      NV_DD_DMA_PUSHER_CONTEXT_DMA_FROM_MEMORY, 
                                      0,
                                      (PVOID*)&(ModeInfo->DevFlatDma)));
#endif

        //
        // Create objects
        //
    
        CHECKSTATUS(MxCreateObjects());
    }

 
    status = STATUS_SUCCESS;

CleanupAndExit:

    return (LONG)status;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\common\inc\CompileControl.h ===
/***************************************************************************\
|*                                                                           *|
|*       Copyright 1993-2000 NVIDIA, Corporation.  All rights reserved.      *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.  Users and possessors of this source code are     *|
|*     hereby granted a nonexclusive,  royalty-free copyright license to     *|
|*     use this code in individual and commercial software.                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY     *|
|*     OF  THIS SOURCE  CODE  FOR ANY PURPOSE.  IT IS  PROVIDED  "AS IS"     *|
|*     WITHOUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPOR-     *|
|*     ATION DISCLAIMS ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,     *|
|*     INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY, NONINFRINGE-     *|
|*     MENT,  AND FITNESS  FOR A PARTICULAR PURPOSE.   IN NO EVENT SHALL     *|
|*     NVIDIA, CORPORATION  BE LIABLE FOR ANY SPECIAL,  INDIRECT,  INCI-     *|
|*     DENTAL, OR CONSEQUENTIAL DAMAGES,  OR ANY DAMAGES  WHATSOEVER RE-     *|
|*     SULTING FROM LOSS OF USE,  DATA OR PROFITS,  WHETHER IN AN ACTION     *|
|*     OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  ARISING OUT OF     *|
|*     OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOURCE CODE.     *|
|*                                                                           *|
|*     U.S. Government  End  Users.   This source code  is a "commercial     *|
|*     item,"  as that  term is  defined at  48 C.F.R. 2.101 (OCT 1995),     *|
|*     consisting  of "commercial  computer  software"  and  "commercial     *|
|*     computer  software  documentation,"  as such  terms  are  used in     *|
|*     48 C.F.R. 12.212 (SEPT 1995)  and is provided to the U.S. Govern-     *|
|*     ment only as  a commercial end item.   Consistent with  48 C.F.R.     *|
|*     12.212 and  48 C.F.R. 227.7202-1 through  227.7202-4 (JUNE 1995),     *|
|*     all U.S. Government End Users  acquire the source code  with only     *|
|*     those rights set forth herein.                                        *|
|*                                                                           *|
 \***************************************************************************/
#ifndef _COMPILE_CONTROL_H_
#define _COMPILE_CONTROL_H_

// Activate this block to get an idea of what #defs are set if it isn't clear
#if 0
#if defined(_WIN32)
#pragma message("Got _WIN32")
#endif
#if defined(WIN32)
#pragma message("Got WIN32")
#endif
#if defined(WINNT)
#pragma message("Got WINNT")
#else
#pragma message("No WINNT")
#endif
#if defined(_WIN32_WINNT)
#pragma message("Got WIN32 NT version")
#endif
#if (_WIN32_WINNT < 0x0500)
#pragma message("NT VER <500")
#else
#pragma message("NT VER >=500")
#endif
#endif

// Use this to for all windows-NT-based systems (NT4,Win2k,WinXP...)
#ifdef WINNT
#define IS_WINNT (IS_WINNT4 || IS_WINNT5)
#endif
		
#if (defined(WINNT) && (_WIN32_WINNT < 0x0500))
#define IS_WINNT4 1
#else
#undef IS_WINNT4
#endif

#if (defined(WINNT) && (_WIN32_WINNT >= 0x0500))
#define IS_WINNT5 1
#else
#undef IS_WINNT5
#endif

#if (defined (WIN32) && !defined(WINNT))
#define IS_WIN9X 1
#else
#undef IS_WIN9X
#endif

#if 0
#if (IS_WIN9X)
#pragma message("Compiling for OS = WIN9X")
#elif IS_WINNT4
#pragma message("Compiling for OS = WINNT4")
#elif IS_WINNT5
#pragma message("Compiling for OS = WINNT5")
#else
#error Unrecognized OS!
#endif
#endif

#if !(IS_WIN9X || IS_WINNT4 || IS_WINNT5)
#error Unrecognized OS!
#endif

#define IS_WIN98 ^^^ // Use IS_WIN9X
#define IS_WIN95 ^^^ // Use IS_WIN9X
#define IS_WINME ^^^ // Use IS_WIN9X

#endif _COMPILE_CONTROL_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\minix\sources.inc ===
!IF 0

Copyright (c) 1989  Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


Author:

    Steve Wood (stevewo) 12-Apr-1990

NOTE:   Commented description of this file is in \nt\bak\bin\sources.tpl

!ENDIF

MAJORCOMP=ntos
MINORCOMP=minix

TARGETPATH=$(BASEDIR)\public\sdk\lib
TARGETTYPE=LIBRARY

         
MSC_WARNING_LEVEL=/W4 /WX


SOURCES= initx.c \
         drvx.c \
         agpuma.c
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\minix\nvddobj.h ===
;/*
;***************************************************************************
;                                                                           *
;   Copyright (C) 1995, 1998 NVidia Corporation. All Rights Reserved.       *
;                                                                           *
;***************************************************************************
;*/


#if defined NV10 || defined NV4
#define NV_IN_PROGRESS          0x8000
#else   /* !(NV10 || NV4) */
#define NV_IN_PROGRESS          0xFF
#endif  /* !(NV10 || NV4) */

#define NV_DD_COMMON_DMA_BUFFER_SIZE    32768
// win9x driver does not use these values anymore
#define NV_DD_DMA_PUSH_BUFFER_SIZE      (2*1024*1024)
#define NV_DD_DMA_PUSH_BUFFER_SIZE_LRG  (4*1024*1024)

#define NV_VIDEO_NOTIFIER_BUFFER_SIZE   32 * sizeof(NvNotification)

#define NV_STATUS_DONE_OK          0

#if defined NV10 || defined NV4

#define videoColorKey                  NVFF6_TYPEDEF
#define videoScaler                    NVFF7_TYPEDEF
#define videoFromMemory                NVFF8_TYPEDEF
#define videoColormap                  NVFF9_TYPEDEF
#define videoSink                      NVFFA_TYPEDEF
#define patchcordVideo                 NVFFB_TYPEDEF
#define contextDmaInMemory             NVFFC_TYPEDEF
#define contextDmaToMemory             NVFFD_TYPEDEF
#define contextDmaFromMemory           NVFFE_TYPEDEF

#undef  NVFF8_SET_CONTEXT_DMA_NOTIFIES
#define NVFF8_SET_CONTEXT_DMA_NOTIFIES                   (0x00000180)
#undef  NVFF8_SET_VIDEO_OUTPUT
#define NVFF8_SET_VIDEO_OUTPUT                           (0x00000200)
#undef  NVFF8_IMAGE_SCAN_OFFSET
#define NVFF8_IMAGE_SCAN_OFFSET                          (0x00000300)
#undef  NVFF9_SET_VIDEO_OUTPUT
#define NVFF9_SET_VIDEO_OUTPUT                           (0x00000200)
#undef  NVFFA_SET_VIDEO_INPUT
#define NVFFA_SET_VIDEO_INPUT                            (0x00000200)
#undef  NVFFF_SET_CONTEXT_DMA_NOTIFIES
#define NVFFF_SET_CONTEXT_DMA_NOTIFIES                   (0x00000180)
#undef  NVFFF_CREATE_OFFSET
#define NVFFF_CREATE_OFFSET                              (0x00000300)
#undef  NVFFF_DESTROY_OFFSET
#define NVFFF_DESTROY_OFFSET                             (0x00000304)

                                        // default object on this sub-channel
#define NV_DD_ROP                  0    // NV_DD_CONTEXT_ROP - NV03_CONTEXT_ROP (0x043)
#define NV_DD_SURFACES             1    // NV_DD_SURFACES_2D - NV4/10_CONTEXT_SURFACES_2D (0x042/0x062)
#define NV_DD_ROP_RECT_AND_TEXT    2    // NV_DD_ROP_GDI_RECT_AND_TEXT - NV4_GDI_RECTANGLE_TEXT (0x04a)
#define NV_DD_BLIT                 3    // NV_DD_IMAGE_BLIT  - NV4_IMAGE_BLIT (0x05f)
#define NV_DD_IMAGE                4    // NV_DD_IMAGE_FROM_CPU - NV4_IMAGE_FROM_CPU (0x061)
#define NV_DD_STRETCH              5    // NV_DD_STRETCHED_IMAGE_FROM_CPU/or one of many NV_DD_SCALED_IMAGE_FROM_MEMORY - NV04/05_STRETCHED/SCALED_IMAGE_FROM_CPU/MEMORY (0x066/0x076)
#define NV_DD_CELSIUS              6    // D3D_CELSIUS_PRIMITIVE - NV10_CELSIUS_PRIMITIVE (0x056)
#ifdef WINNT    // Remove this when DX7 port is complete
#define NV_DD_TRANSCOLOR           6
#endif // WINNT
#define NV_DD_SPARE                7

/* Default cached objects in Windows 95 Direct Draw patch */
#define dDrawRop                       subchannel[NV_DD_ROP].nv3ContextRop
#define dDrawSurfaces                  subchannel[NV_DD_SURFACES].nv4ContextSurfaces2D
#define dDrawRopRectAndText            subchannel[NV_DD_ROP_RECT_AND_TEXT].nv4GdiRectangleText
#define dDrawBlit                      subchannel[NV_DD_BLIT].nv1ImageBlit
#define dDrawImageFromCpu              subchannel[NV_DD_IMAGE].nv1ImageFromCpu
#define dDrawStretch                   subchannel[NV_DD_STRETCH]
#define dDrawTransColor                subchannel[NV_DD_TRANSCOLOR].nv4ContextColorKey
#define dDrawSpare                     subchannel[NV_DD_SPARE]

#define dDrawSubchannelOffset(I)       (I * 0x00002000)

#define dVideoControlHdr               subchannel[0]
#define dVideoControl                  subchannel[0].Nv10VideoLutCursorDac
#define dVideoOverlayHdr               subchannel[1]
#define dVideoOverlay                  subchannel[1].Nv10VideoOverlay
#define dVideoDVDSubPictureHdr         subchannel[2]
#define dVideoDVDSubPicture            subchannel[2].Nv10DvdSubpicture
#define dVideoImageBlitHdr             subchannel[3]
#define dVideoImageBlit                subchannel[3].Nv04ImageBlit
#define dVideoSurface2DHdr             subchannel[4]
#define dVideoSurface2D                subchannel[4].Nv10ContextSurfaces2d


#define NV_DMA_PUSHER_JUMP             0x20000000

/* DMA pusher offsets */
#define SET_ROP_OFFSET                                          NV043_SET_ROP5
#define SURFACES_2D_SET_COLOR_FORMAT_OFFSET                     NV042_SET_COLOR_FORMAT
#define SURFACES_2D_PITCH_OFFSET                                NV042_SET_PITCH
#define SURFACES_2D_DEST_OFFSET                                 NV042_SET_OFFSET_DESTIN
#define IMAGE_BLACK_RECTANGLE_POINT_OFFSET                      NV019_SET_POINT
#define RECT_AND_TEXT_NO_OPERATION_OFFSET                       NV04A_NO_OPERATION
#define RECT_AND_TEXT_NOTIFY_OFFSET                             NV04A_NOTIFY
#define RECT_AND_TEXT_COLOR1A_OFFSET                            NV04A_COLOR1_A
#define RECT_AND_TEXT_CLIPPOINT0B_OFFSET                        NV04A_CLIP_POINT0_B
#define RECT_AND_TEXT_CLIPPEDRECT_POINT0_OFFSET                 NV04A_CLIPPED_RECTANGLE(0)
#define BLIT_POINT_IN_OFFSET                                    NV05F_CONTROL_POINT_IN
#define IMAGE_FROM_CPU_POINT_OFFSET                             NV061_POINT
#define IMAGE_FROM_CPU_COLOR_OFFSET                             NV061_COLOR(0)
#define STRETCHED_IMAGE_SIZE_IN_OFFSET                          NV076_SIZE_IN
#define STRETCHED_IMAGE_COLOR_OFFSET                            NV076_COLOR(0)
#define SCALED_IMAGE_NOTIFY_OFFSET                              NV077_NOTIFY
#define SCALED_IMAGE_CONTEXT_DMA_IMAGE_OFFSET                   NV077_SET_CONTEXT_DMA_IMAGE
#define SCALED_IMAGE_SET_COLOR_FORMAT                           NV077_SET_COLOR_FORMAT
#define SCALED_IMAGE_CLIPPOINT_OFFSET                           NV077_CLIP_POINT
#define SCALED_IMAGE_DELTADUDX_OFFSET                           NV077_DELTA_DU_DX
#define SCALED_IMAGE_IMAGE_OUT_POINT_OFFSET                     NV077_IMAGE_OUT_POINT
#define SCALED_IMAGE_IMAGE_IN_SIZE_OFFSET                       NV077_IMAGE_IN_SIZE
#define SCALED_IMAGE_IMAGE_IN_POINT_OFFSET                      NV077_IMAGE_IN
#define SET_TRANSCOLOR_OFFSET                                   NV057_SET_COLOR
#define MEM_TO_MEM_FORMAT_BUFFER_IN_OFFSET                      NV039_SET_CONTEXT_DMA_BUFFER_IN
#define MEM_TO_MEM_FORMAT_BUFFER_OUT_OFFSET                     NV039_SET_CONTEXT_DMA_BUFFER_OUT
#define MEM_TO_MEM_FORMAT_OFFSET_IN_OFFSET                      NV039_OFFSET_IN
#define BETA4_SET_BETA_FACTOR_OFFSET                            NV072_SET_BETA_FACTOR
#define VIDEO_FROM_MEM_OFFSET_OFFSET                            NVFF8_IMAGE_SCAN_OFFSET
#define CONTEXT_DMA_FROM_MEM_NOTIFY_OFFSET                      NVFFE_NOTIFY
#define CONTEXT_DMA_FROM_MEM_SET_DMA_SPECIFIER_OFFSET           NVFFE_SET_DMA_SPECIFIER
#define CONTEXT_DMA_FROM_MEM_SET_DMA_SPECIFIER_LIMIT_OFFSET     NVFFE_SET_DMA_SPECIFIER_LIMIT


#else   /* !(NV10 || NV4) */

#define NV_DD_ROP                      0
#define NV_DD_IMAGE_IN_MEMORY          1
#define NV_DD_ROP_RECT_AND_TEXT        2
#define NV_DD_BLIT                     3
#define NV_DD_IMAGE                    4
#define NV_DD_STRETCH                  5
#define NV_DD_TRANSCOLOR               6
#define NV_DD_SPARE                    7

/* Default cached objects in Windows 95 Direct Draw patch */
#define dDrawRop                       subchannel[NV_DD_ROP].rop5Solid
#define dDrawImageInMemory             subchannel[NV_DD_IMAGE_IN_MEMORY].imageInMemory
#define dDrawRopRectAndText            subchannel[NV_DD_ROP_RECT_AND_TEXT].winRectAndTextFromCpu
#define dDrawBlit                      subchannel[NV_DD_BLIT].imageBlit
#define dDrawImageFromCpu              subchannel[NV_DD_IMAGE].imageFromCpu
#define dDrawStretch                   subchannel[NV_DD_STRETCH]
#define dDrawTransColor                subchannel[NV_DD_TRANSCOLOR].imageSolid
#define dDrawSpare                     subchannel[NV_DD_SPARE]

#endif  /* !(NV10 || NV4) */
/*
      7 subchannels contain the default cached objects.  These objects
are expected to be loaded at all times except when one or more of them gets
temporarily replaced for an unusual rendering operation.  If a default cached
object does get temporarily replaced, it is expected to be restored immediately
after completion of the rendering operation which caused it's replacement.
There is a spare subchannel in the Direct Draw patch which is lazy evaluated
similarly to the one used in the display driver.

        In the Windows 95 Direct Draw patch description below outlined objects are
those expected to be cached in the 8 subchannels.  Objects with corners
marked only are objects which temporarily replace cached objects or which are
loaded into the eighth subchannel when used.  All other objects are created,
patched together, then never loaded again until the patch is destroyed.  Most of
those objects are in the interior of the patch and are referenced by row for
clear identification.  Patchcord object names are derived from the object
where their output originates (their source).




/* Windows 95 Double Buffered Direct Draw ROP3 Patch */


/*

   Objects

   Context DMA  Context DMA
    To Memory    To Memory
          . |    | . .-------. .               . .         . .---------------.
           MemToMem  |  Rop  |   Image Pattern      Image    |  Image Solid  |
            Format   | Solid |  (Alpha Enabled)     Black    |(Alpha Enabled)|
          '        ' '-------' '               '  Rectangle  '---------------'
                           |        |            '         '         |
                          P|I       |              |                 |
                           |  .-----'     .--------'    .------------'
                           | P|I         P|I           P|I
 .               .         |  |           |             |
    (Sync) Rect     P      |  |           |             |       P
     And Text     ------------------------------------------------->.
 '               '  I      |  |           |             |       I   |
                           |  |           |             |           |
                          P|IP|I         P|I           P|I          |
 .---------------.         V  V           |             V           |
 |   Rop Rect    |  P   Image Rop  P      V     P     Image     P   |
 |   And Text    |----->   And   ------------------>Color Key------>|       1
 '---------------'  I   ^          I      |     I               I   |
                       P|I |  |           |             |           |
                        | P|IP|I         P|I           P|I          |
.----------------.         V  V           V             V           |
| Image From CPU |  P   Image Rop  P    Image   P     Image     P   |
|(Alpha Disabled)|----->   And   ----->Stencil----->Color Key------>|       2
'----------------'  I   ^          I            I               I   |
                       P|I |  |           |             |           |
                        | P|IP|I         P|I           P|I          |
.                .         V  V           V             V           |
  Image From CPU    P   Image Rop  P    Image   P     Image     P   |
 (Alt Pxl Depth)  ----->   And   ----->Stencil----->Color Key------>|       3
'                '  I   ^          I            I               I   |
 CtxDmaFromSysMem      P|I |  |           |             |           |
    |                   | P|IP|I         P|I           P|I          |
.---|------------.         V  V           |             V           |
|  Scaled RGB    |  P   Image Rop  P      V     P     Image     P   |
|ImageFromSysMem |----->   And   ------------------>Color Key------>|       4
|(Alpna Disabled)|  I   ^          I      |     I               I   |
'----------------'     P|I |  |           |             |           |
 CtxDmaFromVidMem       | P|IP|I         P|I           P|I          |
.          |     .         V  V           |             V           |
   Scaled RGB       P   Image Rop  P      V     P     Image     P   |
 ImageFromVidMem  ----->   And   ------------------>Color Key------>|       5
 (Alpna Disabled)   I   ^          I      |     I               I   |
'                '     P|I |  |           |             |           |
    |                   | P|IP|I         P|I           P|I          |
.   |            .      |  |  |           |             |           |
   Scaled UYVY      P   |  V  V    P      V     P       V       P   |
 ImageFromSysMem  ------------------------------------------------->|       6
 (Alpna Disabled)   I   ^  |  |    I      |     I       |       I   |
'                '     P|I |  |           |             |           |
           |            | P|IP|I         P|I           P|I          |
.          |     .         |  |           |             |           |
   Scaled UYVY      P   |  V  V    P      V     P       V       P   |
 ImageFromVidMem  ------------------------------------------------->|       7
 (Alpna Disabled)   I   ^  |  |    I      |     I       |       I   |
'                '     P|I |  |           |             |           |
    |                   | P|IP|I         P|I           P|I          |
.   |            .      |  |  |           |             |           |
   Scaled YUYV      P   |  V  V    P      V     P       V       P   |
 ImageFromSysMem  ------------------------------------------------->|       8
 (Alpna Disabled)   I   ^  |  |    I      |     I       |       I   |
'                '     P|I |  |           |             |           |
           |            | P|IP|I         P|I           P|I          |
.          |     .         |  |           |             |           |
   Scaled YUYV      P   |  V  V    P      V     P       V       P   |
 ImageFromVidMem  ------------------------------------------------->|       9
 (Alpna Disabled)   I   ^  |  |    I      |     I       |       I   |
'                '     P|I |  |           |             |           |
 CtxDmaFromSysMem       | P|IP|I         P|I           P|I          |
.       |        .      |  |  |           |             |           |
    Floating 0      P   |  V  V    P      V     P       V       P   |
   Scaled UYVY    ------------------------------------------------->|       A
 ImageFromSysMem    I   ^  |  |    I      |     I       |       I   |
'                '     P|I |  |           |             |           |
 CtxDmaFromSysMem       | P|IP|I         P|I           P|I          |
.       |        .         |  |           |             |           |
    Floating 1      P   |  V  V    P      V     P       V       P   |
   Scaled UYVY    ------------------------------------------------->|       B
 ImageFromSysMem    I   ^  |  |    I      |     I       |       I   |
'                '     P|I |  |           |             |           |
 CtxDmaFromSysMem       | P|IP|I         P|I           P|I          |
.       |        .      |  |  |           |             |           |
    Floating 0      P   |  V  V    P      V     P       V       P   |
   Scaled YUYV    ------------------------------------------------->|       C
 ImageFromSysMem    I   ^  |  |    I      |     I       |       I   |
'                '     P|I |  |           |             |           |
 CtxDmaFromSysMem       | P|IP|I         P|I           P|I          |
.       |        .         |  |           |             |           |
    Floating 1      P   |  V  V    P      V     P       V       P   |
   Scaled YUYV    ------------------------------------------------->|       D
 ImageFromSysMem    I   ^  |  |    I      |     I       |       I   |
'                '     P|I |  |           |             |           |
 CtxDmaFromSysMem       | P|IP|I         P|I           P|I          |
.       |        .      |  |  |           |             |           |
    Floating 0      P   |  V  V    P      V     P       V       P   |
   Scaled Y420    ------------------------------------------------->|       AA
 ImageFromSysMem    I   ^  |  |    I      |     I       |       I   |
'                '     P|I |  |           |             |           |
 CtxDmaFromSysMem       | P|IP|I         P|I           P|I          |
.       |        .         |  |           |             |           |
    Floating 1      P   |  V  V    P      V     P       V       P   |
   Scaled Y420    ------------------------------------------------->|       BB
 ImageFromSysMem    I   ^  |  |    I      |     I       |       I   |
'                '     P|I |  |           |             |           |
                        | P|IP|I         P|I           P|I          |
.                .         V  V           |             |           |
  Stretched UV      P   Image Rop  P      V     P       V       P   |
      Image       ----->   And   ---------------------------------->|       CC
 (Alpna Disabled)   I   ^          I      |     I       |       I   |
'                '     P|I |  |           |             |           |
                        | P|IP|I         P|I           P|I          |
.                .         V  V           |             V           |
    Stretched       P   Image Rop  P      V     P     Image     P   |
      Image       ----->   And   ------------------>Color Key------>|       DD
 (Alpna Disabled)   I   ^          I      |     I       |       I   |
'                '     P|I |  |           |             |           |
                        | P|IP|I         P|I           P|I          |
.----------------.         V  V           V             V           |
|   Image Blit   |  P   Image Rop  P    Image   P     Image     P   |
|(Alpha Disabled)|----->   And   ----->Stencil----->Color Key------>|       E
'------------^---'  I   ^          I            I               I   |
            P|I        P|I                                          |
             |          |                                           |
             |          |                                           |
             |          '------------------------------------.      |
             |                                               |      |
             |                                               |      |
             |                                              P|I    P|I
             |                                               |      |
            P|I                                              |      |
             |                                               |      |
             |                                               |      V
 .             .               .           .              .-------------.
     Source     --------------- Context DMA --------------| Destination |  P
  ImageInMemory                  InMemory                 |ImageInMemory|<----.
 '             '               '           '              '-------------'  I  |
                                  |    |                                      |
                                  |    '-------------------------.            |
                                  |                              |            |
 .              .          P      |                 P     .                .  |
  Render Solid   ----------------------------------------> Destination Zeta   |
  Zeta Rectangle           I      |                 I       ImageInMemory     |
 '              '                 |                       '                '  |
                                  |                                           |
                                  '------------------------------.            |
                                                                 |            |
                                                          .                .  |
 .             .      P                               P    Destination Zeta   |
   Render D3D   ----------------------------------------->  BufferInMemory    |
  Triangle Zeta       Z         P   Image    P        Z   '      ^         '  |
 '             '------------------>Stencil----------------------------------->| F
                                I            I                   |            |
                                                                P|Z           |
 .             .      P                               P          |            |
   Render D3D   -------------------------------------------------'            |
  Triangle Zeta       Z         P   Image    P        Z                       |
   From Video   ------------------>Stencil----------------------------------->' FF
     Memory                     I            I
 '             '

                            .                 .
  Floating Format               Y, U, V, UV
  Context DMA From --------- System Memory To  ---------------.
   System Memory             Vid Memory Format                |
                            '                 '               |
                                                       Context DMA To
                                                        Video Memory
                            .                 .               |
                                Y, U, V, UV                   |
         .------------------  Video Memory To  ---------------'
         |                   Vid Memory Format
 .                .         '                 '
  Context DMA From
    Video Memory
 ,                ,               .          .
       |    |                       Primary
       |    '--------------------- Video From ------Flip Primary Notifier
       |                             Memory         Context DMA To Memory
       |                          '          '
       |                            |      |
       |                            |      |
       |                           P|V    P|V
       |                            |      |
       |                            |      |   P   .            .
  .          .                      V      V//<---- Shared Video
     YUV422     P   .      .    P  .         . V      Colormap
   Video From -----> Video  ------>   Video        '            '
     Memory     V    Scaler     V   Color Key
  '          '      '      '       '         '
        |                               |
        |                               |
  Flip Overlay Notifier                P|V
  Context DMA To Memory                 |
                                        V
                                   .         .
                                      Video
                                      Sink
                                   '         '

*/


/* Video channel shared Display Driver and DDraw Object IDs */

#define NV_VIDEO_NOTIFIER_CONTEXT_DMA_TO_MEMORY                 0x00008000
#define NV_VIDEO_LUT_CURSOR_DAC_NOTIFIER_CONTEXT_DMA_TO_MEMORY  0x00008004
#define NV_VIDEO_OVERLAY_NOTIFIER_CONTEXT_DMA_TO_MEMORY         0x00008008
#define NV_VIDEO_CONTEXT_DMA_IN_MEMORY                          0x00008010
#define NV_VIDEO_LUT_CURSOR_DAC                                 0x00008020
#define NV_VIDEO_OVERLAY                                        0x00008030
#define NV_VIDEO_DVD_SUBPICTURE                                 0x00008040
#define NV_VIDEO_SURFACES_2D_A8R8G8B8                           0x00008050
#define NV_VIDEO_CONTEXT_BETA4                                  0x00008060
#define NV_VIDEO_SRCCOPY_PREMULT_A8R8G8B8_IMAGE_BLIT            0x00008070

/* Windows 9X Direct Draw Object IDs */


#define NV_DD_PIO_CONTEXT_DMA_FROM_SYSTEM_MEMORY                0xDD001000
#define NV_DD_DMA_CONTEXT_DMA_FROM_SYSTEM_MEMORY                0xDD001000
#define NV_DD_PIO_FLOATING_FORMAT_CONTEXT_DMA_FROM_SYSTEM_MEMORY 0xDD001001
#define NV_DD_DMA_FLOATING_FORMAT_CONTEXT_DMA_FROM_SYSTEM_MEMORY 0xDD001001
#define NV_DD_PIO_CONTEXT_DMA_FROM_VIDEO_MEMORY                 0xDD001002
#define NV_DD_DMA_CONTEXT_DMA_FROM_VIDEO_MEMORY                 0xDD001002
#define NV_DD_PIO_FLOATING0_UYVY_CONTEXT_DMA_FROM_SYSTEM_MEMORY 0xDD001003
#define NV_DD_DMA_FLOATING0_UYVY_CONTEXT_DMA_FROM_SYSTEM_MEMORY 0xDD001003
#define NV_DD_PIO_FLOATING1_UYVY_CONTEXT_DMA_FROM_SYSTEM_MEMORY 0xDD001004
#define NV_DD_DMA_FLOATING1_UYVY_CONTEXT_DMA_FROM_SYSTEM_MEMORY 0xDD001004
#define NV_DD_PIO_FLOATING0_YUYV_CONTEXT_DMA_FROM_SYSTEM_MEMORY 0xDD001005
#define NV_DD_DMA_FLOATING0_YUYV_CONTEXT_DMA_FROM_SYSTEM_MEMORY 0xDD001005
#define NV_DD_PIO_FLOATING1_YUYV_CONTEXT_DMA_FROM_SYSTEM_MEMORY 0xDD001006
#define NV_DD_DMA_FLOATING1_YUYV_CONTEXT_DMA_FROM_SYSTEM_MEMORY 0xDD001006
#define NV_DD_PIO_FLOATING_CONTEXT_DMA_IN_OVERLAY_SHADOW        0xDD001007
#define NV_DD_DMA_FLOATING_CONTEXT_DMA_IN_OVERLAY_SHADOW        0xDD001007
#define NV_DD_DMA_TEXTURE_CONTEXT_DMA_FROM_SYSTEM_MEMORY        0xDD001009
#define NV_DD_DMA_FLOATING_TEXTURE_CONTEXT_DMA_FROM_SYSTEM_MEMORY 0xDD00100A
#define NV_DD_DMA_TRIANGLE_CONTEXT_DMA_FROM_SYSTEM_MEMORY       0xDD00100B
#define NV_DD_PIO_CONTEXT_DMA_IN_VIDEO_MEMORY                   0xDD001010
#define NV_DD_DMA_CONTEXT_DMA_IN_VIDEO_MEMORY                   0xDD001010
#define NV_DD_PIO_COMBINER_EVENT_NOTIFIER                       0xDD001014
#define NV_DD_DMA_COMBINER_EVENT_NOTIFIER                       0xDD001014
#define NV_DD_PIO_TO_MEM_NOTIFIER_CONTEXT_DMA_TO_MEMORY         0xDD001015
#define NV_DD_DMA_TO_MEM_NOTIFIER_CONTEXT_DMA_TO_MEMORY         0xDD001015
#define NV_DD_PIO_FLIP_PRIMARY_NOTIFIER_CONTEXT_DMA_TO_MEMORY   0xDD001016
#define NV_DD_DMA_FLIP_PRIMARY_NOTIFIER_CONTEXT_DMA_TO_MEMORY   0xDD001016
#define NV_DD_PIO_FLIP_OVERLAY_NOTIFIER_CONTEXT_DMA_TO_MEMORY   0xDD001017
#define NV_DD_DMA_FLIP_OVERLAY_NOTIFIER_CONTEXT_DMA_TO_MEMORY   0xDD001017
#define NV_DD_PIO_FLIP_OVERLAY_NOTIFIER_CONTEXT_DMA_TO_MEMORY_0 0xDD001017
#define NV_DD_PIO_CONTEXT_DMA_TO_SYSTEM_MEMORY                  0xDD001018
#define NV_DD_DMA_CONTEXT_DMA_TO_SYSTEM_MEMORY                  0xDD001018
#define NV_DD_PIO_FROM_MEM_NOTIFIER_CONTEXT_DMA_TO_MEMORY       0xDD001019
#define NV_DD_DMA_FROM_MEM_NOTIFIER_CONTEXT_DMA_TO_MEMORY       0xDD001019
#define NV_DD_DMA_PUSHER_SYNC_NOTIFIER_CONTEXT_DMA_TO_MEMORY    0xDD00101A
#define NV_DD_PIO_BUFFER_NOTIFIER_CONTEXT_DMA_TO_MEMORY         0xDD00101B
#define NV_DD_DMA_BUFFER_NOTIFIER_CONTEXT_DMA_TO_MEMORY         0xDD00101B
#define NV_DD_PIO_CONTEXT_DMA_TO_VIDEO_MEMORY                   0xDD00101C
#define NV_DD_DMA_CONTEXT_DMA_TO_VIDEO_MEMORY                   0xDD00101C
#define NV_DD_PIO_SYNC_NOTIFIER_CONTEXT_DMA_TO_MEMORY           0xDD00101D
#define NV_DD_DMA_SYNC_NOTIFIER_CONTEXT_DMA_TO_MEMORY           0xDD00101D
#define NV_DD_PIO_FLIP_OVERLAY_NOTIFIER_CONTEXT_DMA_TO_MEMORY_1 0xDD00101E
#define NV_DD_PIO_COLOUR_CONTROL_EVENT_NOTIFIER                 0xDD00101F
#define NV_DD_DMA_COLOUR_CONTROL_EVENT_NOTIFIER                 0xDD00101F


#define NV_DD_VIDEO_MEMORY_TO_SYSTEM_MEMORY_FORMAT              0xDD001020
#define NV_DD_CONTEXT_ROP                                       0xDD001030
#define NV_DD_ROP5_SOLID                                        0xDD001030
#define NV_DD_P_I_ROP5_SOLID                                    0xDD001031
#define NV_DD_BETA_SOLID                                        0xDD001040
#define NV_DD_P_B_BETA_SOLID                                    0xDD001041
#define NV_DD_CONTEXT_PATTERN                                   0xDD001050
#define NV_DD_IMAGE_PATTERN                                     0xDD001050
#define NV_DD_P_I_IMAGE_PATTERN                                 0xDD001051
#define NV_DD_IMAGE_BLACK_RECTANGLE                             0xDD001060
#define NV_DD_P_I_IMAGE_BLACK_RECTANGLE                         0xDD001061
#define NV_DD_CONTEXT_COLOR_KEY                                 0xDD001070
#define NV_DD_COLOR_KEY_IMAGE_SOLID                             0xDD001070
#define NV_DD_P_I_COLOR_KEY_IMAGE_SOLID                         0xDD001071
#define NV_DD_CONTEXT_BETA4                                     0xDD001080

#define NV_DD_ROP_GDI_RECT_AND_TEXT                             0xDD001100
#define NV_DD_P_I_ROP_GDI_RECT_AND_TEXT                         0xDD001101
#define NV_DD_ABLEND_RECT_AND_TEXT                              0xDD001108
#define NV_DD_PUSHER_SYNC_RECT_AND_TEXT_FROM_CPU                0xDD00110A
#define NV_DD_P_I_PUSHER_SYNC_RECT_AND_TEXT_FROM_CPU            0xDD00110B
#define NV_DD_IMAGE_FROM_CPU                                    0xDD001200
#define NV_DD_P_I_IMAGE_FROM_CPU                                0xDD001201
#define NV_DD_SRCCOPY_IMAGE_FROM_CPU                            0xDD001208
#define NV_DD_IMAGE_BLEND_FROM_CPU                              0xDD001300
#define NV_DD_P_I_IMAGE_BLEND_FROM_CPU                          0xDD001301
#define NV_DD_ABLEND_NOSRCALPHA_IMAGE_FROM_CPU                  0xDD001308
#define NV_DD_ABLEND_IMAGE_FROM_CPU                             0xDD001309
#define NV_DD_STRETCHED_IMAGE_FROM_CPU                          0xDD001400
#define NV_DD_P_I_STRETCHED_IMAGE_FROM_CPU                      0xDD001401
#define NV_DD_SRCCOPY_STRETCHED_IMAGE_FROM_CPU                  0xDD001408
#define NV_DD_ABLEND_NOSRCALPHA_STRETCHED_IMAGE_FROM_CPU        0xDD001409
#define NV_DD_ABLEND_STRETCHED_IMAGE_FROM_CPU                   0xDD00140A
#define NV_DD_SCALED_RGB_IMAGE_FROM_SYSTEM_MEMORY               0xDD001500
#define NV_DD_P_I_SCALED_RGB_IMAGE_FROM_SYSTEM_MEMORY           0xDD001501
#define NV_DD_SRCCOPY_SCALED_RGB_IMAGE_FROM_SYSTEM_MEMORY       0xDD001508
#define NV_DD_ABLEND_NOSRCALPHA_SCALED_RGB_IMAGE_FROM_SYSTEM_MEMORY 0xDD001509
#define NV_DD_ABLEND_SCALED_RGB_IMAGE_FROM_SYSTEM_MEMORY        0xDD00150A
#define NV_DD_SCALED_RGB_IMAGE_FROM_VIDEO_MEMORY                0xDD001510
#define NV_DD_P_I_SCALED_RGB_IMAGE_FROM_VIDEO_MEMORY            0xDD001511
#define NV_DD_SRCCOPY_SCALED_RGB_IMAGE_FROM_VIDEO_MEMORY        0xDD001518
#define NV_DD_ABLEND_NOSRCALPHA_SCALED_RGB_IMAGE_FROM_VIDEO_MEMORY 0xDD001519
#define NV_DD_ABLEND_SCALED_RGB_IMAGE_FROM_VIDEO_MEMORY         0xDD00151A
#define NV_DD_SCALED_UYVY_IMAGE_FROM_SYSTEM_MEMORY              0xDD001520
#define NV_DD_P_I_SCALED_UYVY_IMAGE_FROM_SYSTEM_MEMORY          0xDD001521
#define NV_DD_SCALED_UYVY_IMAGE_FROM_VIDEO_MEMORY               0xDD001530
#define NV_DD_P_I_SCALED_UYVY_IMAGE_FROM_VIDEO_MEMORY           0xDD001531
#define NV_DD_SCALED_YUYV_IMAGE_FROM_SYSTEM_MEMORY              0xDD001540
#define NV_DD_P_I_SCALED_YUYV_IMAGE_FROM_SYSTEM_MEMORY          0xDD001541
#define NV_DD_SCALED_YUYV_IMAGE_FROM_VIDEO_MEMORY               0xDD001550
#define NV_DD_P_I_SCALED_YUYV_IMAGE_FROM_VIDEO_MEMORY           0xDD001551
#define NV_DD_FLOATING0_SCALED_UYVY_IMAGE_FROM_SYSTEM_MEMORY    0xDD001560
#define NV_DD_P_I_FLOATING0_SCALED_UYVY_IMAGE_FROM_SYSTEM_MEMORY 0xDD001561
#define NV_DD_FLOATING1_SCALED_UYVY_IMAGE_FROM_SYSTEM_MEMORY    0xDD001570
#define NV_DD_P_I_FLOATING1_SCALED_UYVY_IMAGE_FROM_SYSTEM_MEMORY 0xDD001571
#define NV_DD_FLOATING0_SCALED_YUYV_IMAGE_FROM_SYSTEM_MEMORY    0xDD001580
#define NV_DD_P_I_FLOATING0_SCALED_YUYV_IMAGE_FROM_SYSTEM_MEMORY 0xDD001581
#define NV_DD_FLOATING1_SCALED_YUYV_IMAGE_FROM_SYSTEM_MEMORY    0xDD001590
#define NV_DD_P_I_FLOATING1_SCALED_YUYV_IMAGE_FROM_SYSTEM_MEMORY 0xDD001591
#define NV_DD_GENERIC_SCALED_IMAGE                              0xDD0015A0
#define NV_DD_STRETCHED_UV_IMAGE_FROM_CPU                       0xDD001600
#define NV_DD_P_I_STRETCHED_UV_IMAGE_FROM_CPU                   0xDD001601
#define NV_DD_DVD_SUBPICTURE                                    0xDD001700

#define NV_DD_IMAGE_BLIT                                        0xDD001800
#define NV_DD_P_I_IMAGE_BLIT                                    0xDD001801
#define NV_DD_SRCCOPY_IMAGE_BLIT                                0xDD001808
#define NV_DD_SRCCOPY_PREMULT_A8R8G8B8_IMAGE_BLIT               0xDD00180A
#define NV_DD_ALT_IMAGE_FROM_CPU                                0xDD001900
#define NV_DD_P_I_ALT_IMAGE_FROM_CPU                            0xDD001901
#define NV_DD_RENDER_SOLID_ZETA_RECTANGLE                       0xDD001A00
#define NV_DD_P_I_RENDER_SOLID_ZETA_RECTANGLE                   0xDD001A01

#define NV_D3D_RENDER_TRIANGLE_ZETA                             0xDD001B00
#define NV_D3D_P_I_RENDER_TRIANGLE_ZETA                         0xDD001B01
#define NV_D3D_P_Z_RENDER_TRIANGLE_ZETA                         0xDD001B02
#define NV_D3D_RENDER_TRIANGLE_ZETA_FROM_VIDEO_MEMORY           0xDD001B03
#define NV_D3D_P_I_RENDER_TRIANGLE_ZETA_FROM_VIDEO_MEMORY       0xDD001B04
#define NV_D3D_P_Z_RENDER_TRIANGLE_ZETA_FROM_VIDEO_MEMORY       0xDD001B05
#define NV_D3D_FLOATING_RENDER_TRIANGLE_ZETA                    0xDD001B06
#define NV_D3D_FLOATING_P_I_RENDER_TRIANGLE_ZETA                0xDD001B07
#define NV_D3D_FLOATING_P_Z_RENDER_TRIANGLE_ZETA                0xDD001B08

// floating dma contexts for DVD acceleration
#define NV_DD_PIO_FLOATING_CONTEXT_DMA_IN_SYSTEM_S2V            0xDD001C00
#define NV_DD_DMA_FLOATING_CONTEXT_DMA_IN_SYSTEM_S2V            0xDD001C00
#define NV_DD_PIO_FLOATING_CONTEXT_DMA_IN_SYSTEM_S2V0           0xDD001C00
#define NV_DD_DMA_FLOATING_CONTEXT_DMA_IN_SYSTEM_S2V0           0xDD001C00
#define NV_DD_PIO_FLOATING_CONTEXT_DMA_IN_SYSTEM_S2V1           0xDD001C01
#define NV_DD_DMA_FLOATING_CONTEXT_DMA_IN_SYSTEM_S2V1           0xDD001C01
#define NV_DD_PIO_FLOATING_CONTEXT_DMA_IN_SYSTEM_S2V2           0xDD001C02
#define NV_DD_DMA_FLOATING_CONTEXT_DMA_IN_SYSTEM_S2V2           0xDD001C02
#define NV_DD_PIO_FLOATING_CONTEXT_DMA_IN_SYSTEM_S2V3           0xDD001C03
#define NV_DD_DMA_FLOATING_CONTEXT_DMA_IN_SYSTEM_S2V3           0xDD001C03
#define NV_DD_PIO_FLOATING_CONTEXT_DMA_IN_SYSTEM_S2V4           0xDD001C04
#define NV_DD_DMA_FLOATING_CONTEXT_DMA_IN_SYSTEM_S2V4           0xDD001C04
#define NV_DD_PIO_FLOATING_CONTEXT_DMA_IN_SYSTEM_S2V5           0xDD001C05
#define NV_DD_DMA_FLOATING_CONTEXT_DMA_IN_SYSTEM_S2V5           0xDD001C05
#define NV_DD_PIO_FLOATING_CONTEXT_DMA_IN_SYSTEM_S2V6           0xDD001C06
#define NV_DD_DMA_FLOATING_CONTEXT_DMA_IN_SYSTEM_S2V6           0xDD001C06
#define NV_DD_PIO_FLOATING_CONTEXT_DMA_IN_SYSTEM_S2V7           0xDD001C07
#define NV_DD_DMA_FLOATING_CONTEXT_DMA_IN_SYSTEM_S2V7           0xDD001C07
#define NV_DD_PIO_FLOATING_CONTEXT_DMA_IN_SYSTEM_S2V8           0xDD001C08
#define NV_DD_DMA_FLOATING_CONTEXT_DMA_IN_SYSTEM_S2V8           0xDD001C08
#define NV_DD_PIO_FLOATING_CONTEXT_DMA_IN_SYSTEM_S2V9           0xDD001C09
#define NV_DD_DMA_FLOATING_CONTEXT_DMA_IN_SYSTEM_S2V9           0xDD001C09
#define NV_DD_PIO_FLOATING_CONTEXT_DMA_IN_SYSTEM_S2VA           0xDD001C0A
#define NV_DD_DMA_FLOATING_CONTEXT_DMA_IN_SYSTEM_S2VA           0xDD001C0A
#define NV_DD_PIO_FLOATING_CONTEXT_DMA_IN_SYSTEM_S2VB           0xDD001C0B
#define NV_DD_DMA_FLOATING_CONTEXT_DMA_IN_SYSTEM_S2VB           0xDD001C0B
#define NV_DD_PIO_FLOATING_CONTEXT_DMA_IN_SYSTEM_S2VC           0xDD001C0C
#define NV_DD_DMA_FLOATING_CONTEXT_DMA_IN_SYSTEM_S2VC           0xDD001C0C
#define NV_DD_PIO_FLOATING_CONTEXT_DMA_IN_SYSTEM_S2VD           0xDD001C0D
#define NV_DD_DMA_FLOATING_CONTEXT_DMA_IN_SYSTEM_S2VD           0xDD001C0D
#define NV_DD_PIO_FLOATING_CONTEXT_DMA_IN_SYSTEM_S2VE           0xDD001C0E
#define NV_DD_DMA_FLOATING_CONTEXT_DMA_IN_SYSTEM_S2VE           0xDD001C0E
#define NV_DD_PIO_FLOATING_CONTEXT_DMA_IN_SYSTEM_S2VF           0xDD001C0F
#define NV_DD_DMA_FLOATING_CONTEXT_DMA_IN_SYSTEM_S2VF           0xDD001C0F

#define NV_DD_DMA_FLOATING_MC_IDCT0_CONTEXT_DMA_FROM_MEMORY     0xDD001D00
#define NV_DD_DMA_FLOATING_MC_IDCT1_CONTEXT_DMA_FROM_MEMORY     0xDD001D01
#define NV_DD_DMA_FLOATING_MC_IDCT2_CONTEXT_DMA_FROM_MEMORY     0xDD001D02
#define NV_DD_DMA_FLOATING_MC_IDCT3_CONTEXT_DMA_FROM_MEMORY     0xDD001D03


/* Patch interior */

#define NV_DD_IMAGE_ROP_AND_1                                   0xDD002110
#define NV_DD_P_I_IMAGE_ROP_AND_1                               0xDD002111
#define NV_DD_IMAGE_COLOR_KEY_1                                 0xDD002130
#define NV_DD_P_I_IMAGE_COLOR_KEY_1                             0xDD002131

#define NV_DD_IMAGE_ROP_AND_2                                   0xDD002210
#define NV_DD_P_I_IMAGE_ROP_AND_2                               0xDD002211
#define NV_DD_IMAGE_STENCIL_2                                   0xDD002220
#define NV_DD_P_I_IMAGE_STENCIL_2                               0xDD002221
#define NV_DD_IMAGE_COLOR_KEY_2                                 0xDD002230
#define NV_DD_P_I_IMAGE_COLOR_KEY_2                             0xDD002231

#define NV_DD_IMAGE_ROP_AND_3                                   0xDD002310
#define NV_DD_P_I_IMAGE_ROP_AND_3                               0xDD002311
#define NV_DD_IMAGE_STENCIL_3                                   0xDD002320
#define NV_DD_P_I_IMAGE_STENCIL_3                               0xDD002321
#define NV_DD_IMAGE_COLOR_KEY_3                                 0xDD002330
#define NV_DD_P_I_IMAGE_COLOR_KEY_3                             0xDD002331

#define NV_DD_IMAGE_ROP_AND_4                                   0xDD002410
#define NV_DD_P_I_IMAGE_ROP_AND_4                               0xDD002411
#define NV_DD_IMAGE_COLOR_KEY_4                                 0xDD002430
#define NV_DD_P_I_IMAGE_COLOR_KEY_4                             0xDD002431

#define NV_DD_IMAGE_ROP_AND_5                                   0xDD002510
#define NV_DD_P_I_IMAGE_ROP_AND_5                               0xDD002511
#define NV_DD_IMAGE_COLOR_KEY_5                                 0xDD002530
#define NV_DD_P_I_IMAGE_COLOR_KEY_5                             0xDD002531

#define NV_DD_IMAGE_ROP_AND_C                                   0xDD002C10
#define NV_DD_P_I_IMAGE_ROP_AND_C                               0xDD002C11

#define NV_DD_IMAGE_ROP_AND_D                                   0xDD002D10
#define NV_DD_P_I_IMAGE_ROP_AND_D                               0xDD002D11
#define NV_DD_IMAGE_COLOR_KEY_D                                 0xDD002D30
#define NV_DD_P_I_IMAGE_COLOR_KEY_D                             0xDD002D31

#define NV_DD_IMAGE_ROP_AND_E                                   0xDD002E10
#define NV_DD_P_I_IMAGE_ROP_AND_E                               0xDD002E11
#define NV_DD_IMAGE_STENCIL_E                                   0xDD002E20
#define NV_DD_P_I_IMAGE_STENCIL_E                               0xDD002E21
#define NV_DD_IMAGE_COLOR_KEY_E                                 0xDD002E30
#define NV_DD_P_I_IMAGE_COLOR_KEY_E                             0xDD002E31

#define NV_DD_IMAGE_STENCIL_F                                   0xDD002F20
#define NV_DD_P_I_IMAGE_STENCIL_F                               0xDD002F21

#define NV_DD_IMAGE_STENCIL_F3                                  0xDD002F30
#define NV_DD_P_I_IMAGE_STENCIL_F3                              0xDD002F31

#define NV_DD_IMAGE_STENCIL_FF                                  0xDD002FF0
#define NV_DD_P_I_IMAGE_STENCIL_FF                              0xDD002FF1


/* Patch back end */

#define NV_DD_SURFACES_2D                                       0xDD003F00
#define NV_DD_DST_IMAGE_IN_MEMORY                               0xDD003F00
#define NV_DD_P_I_DST_IMAGE_IN_MEMORY                           0xDD003F01
#define NV_DD_SURFACES_2D_A8R8G8B8                              0xDD003F02
#define NV_DD_SURFACES_3D                                       0xDD003F03
#define NV_DD_SURFACES_SWIZZLED                                 0xDD003F04
#define NV_DD_SRC_IMAGE_IN_MEMORY                               0xDD003F10
#define NV_DD_P_I_SRC_IMAGE_IN_MEMORY                           0xDD003F11
#define NV_DD_ZETA_IMAGE_IN_MEMORY                              0xDD003F20
#define NV_D3D_ZETA_BUFFER_IN_MEMORY                            0xDD003F30
#define NV_D3D_P_Z_ZETA_BUFFER_IN_MEMORY                        0xDD003F31

#define NV_DD_PRIMARY_VIDEO_FROM_MEMORY                         0xDD003F80
#define NV_DD_P_V_PRIMARY_VIDEO_FROM_MEMORY                     0xDD003F81
#define NV_DD_YUV422_VIDEO_FROM_MEMORY                          0xDD003F90
#define NV_DD_P_V_YUV422_VIDEO_FROM_MEMORY                      0xDD003F91
#define NV_DD_VIDEO_SCALER                                      0xDD003FA0
#define NV_DD_P_V_VIDEO_SCALER                                  0xDD003FA1
#define NV_DD_VIDEO_COLOR_KEY                                   0xDD003FB0
#define NV_DD_P_V_VIDEO_COLOR_KEY                               0xDD003FB1
#define NV_DD_SHARED_VIDEO_COLORMAP                             0xDD003FC0
#define NV_DD_P_V_SHARED_VIDEO_COLORMAP                         0xDD003FC1

#define NV_DD_SYSTEM_MEMORY_Y_TO_VIDEO_MEMORY_FORMAT            0xDD003FD0
#define NV_DD_SYSTEM_MEMORY_U_TO_VIDEO_MEMORY_FORMAT            0xDD003FD1
#define NV_DD_SYSTEM_MEMORY_V_TO_VIDEO_MEMORY_FORMAT            0xDD003FD2
#define NV_DD_SYSTEM_MEMORY_UV_TO_VIDEO_MEMORY_FORMAT           0xDD003FD3
#define NV_DD_VIDEO_MEMORY_Y_TO_VIDEO_MEMORY_FORMAT             0xDD003FE0
#define NV_DD_VIDEO_MEMORY_U_TO_VIDEO_MEMORY_FORMAT             0xDD003FE1
#define NV_DD_VIDEO_MEMORY_V_TO_VIDEO_MEMORY_FORMAT             0xDD003FE2
#define NV_DD_VIDEO_MEMORY_UV_TO_VIDEO_MEMORY_FORMAT            0xDD003FE3
#define NV_DD_VIDEO_MEMORY_TO_OVERLAY_SHADOW_FORMAT             0xDD003FE4
#define NV_DD_OVERLAY_SHADOW_TO_VIDEO_MEMORY_FORMAT             0xDD003FE5
#define NV_DD_DMABLT_TO_VID                                     0xDD003FE6
#define NV_DD_VIDEO_SINK                                        0xDD003FF0

#define NV_DD_COMMON_DMA_BUFFER                                 0xDD004000
#define NV_DD_PIO_CONTEXT_ERROR_TO_MEMORY                       0xDD004010
#define NV_DD_DEV_PIO                                           0xDD004020

#define NV_DD_DMA_PUSHER_CONTEXT_DMA_FROM_MEMORY                0xDD005000
#define NV_DD_DMA_CONTEXT_ERROR_TO_MEMORY                       0xDD005010
#define NV_DD_DEV_DMA                                           0xDD005020

#define NV_DD_DEV_VIDEO                                         0xDD006020

#define NV_DD_DEV_VPE                                           0xDD007020

#define NV_DD_VIDEO_LUT_CURSOR_DAC                              0xDD008000

#define NV_DD_GLOBALDATA_MEMORY                                 0xDD008020
#define NV_DD_GLOBALDATA_MEMORY_NVDD32_CONTEXT                  0xDD008021
#define NV_DD_IPM                                               0xDD008022
#define NV_DD_CONTEXTDMA_MEMORY                                 0xDD008030

#define NV_DD_INDEXED_IMAGE_FROM_CPU                            0xDD00A000

#ifdef WINNT
// Pushbuf ID needed for Win2k RM AGP allocator.
#define NV_DD_AGP_PUSHBUF                                       0xDD00A001
#endif // WINNT

// VPP objects
#define NV_DD_SWIZZLE_BLIT                                      0xDD00B000
#define NV_DD_DMA_OVERLAY                                       0xDD00B010
#define NV_DD_V2V_FORMAT_Y                                      0xDD00B020
#define NV_DD_ALPHA_BLIT                                        0xDD00B030

// Events
#define NV_DD_EVENT_IDLE_SYNC                                   0xDD00C000
#define NV_DD_EVENT_CONVERT_SYNC                                0xDD00C001
#define NV_DD_EVENT_DVD_SUBPICTURE                              0xDD00C002
#define NV_DD_EVENT_ALPHA_BLIT_SYNC                             0xDD00C003
#define NV_DD_EVENT_VIDEO_TO_SYSTEM_SYNC                        0xDD00C004
#define NV_DD_EVENT_SYSTEM_TO_VIDEO_SYNC                        0xDD00C005
#define NV_DD_EVENT_COMBINER_SYNC                               0xDD00C006
#define NV_DD_EVENT_DMABLT_TO_VID                               0xDD00C007
#define NV_DD_EVENT_OVL_FLIP1                                   0xDD00C008
#define NV_DD_EVENT_OVL_FLIP2                                   0xDD00C009
#define NV_DD_EVENT_DFILTER_SYNC                                0xDD00C00A

// Floating context DMA's for system surfaces (reserve a block of 512 for now)
#define MAX_FLOATING_CONTEXT_DMA                                0x200
#define MASK_FLOATING_CONTEXT_DMA_ID                            0xFFFFF001
#define FLOATING_CONTEXT_DMA_ID                                 0xDD00D001
#define NV_DD_FLOATING_CONTEXT_DMA_BASE                         0xDD00D001
#define NV_DD_FLOATING_CONTEXT_DMA_0                            0xDD00D001
#define NV_DD_FLOATING_CONTEXT_DMA_7FF                          0xDD00DFFF


// D3D objects

// naming convention:
// D3Dxxxyy
// where xxx = object class number
//        yy = enumerator, in case we have more than one object of type xxx

// DMA contexts.

#ifdef WINNT  // Still needed by old DX6 Win2k driver!!
#define D3D_CONTEXT_LINEAR_TEXTURE_FROM_MEMORY                  0xD3D00201
#define D3D_CONTEXT_SWIZZLED_TEXTURE_FROM_MEMORY                0xD3D00202
#endif // Still needed by old DX6 win2k driver

#define D3D_CONTEXT_xxx_unused_xxx                              0xD3D00201
#define D3D_CONTEXT_DMA_HOST_MEMORY                             0xD3D00202  // pci or agp context (growable for surfaces)

// Surface contexts.
#define D3D_CONTEXT_SURFACE_SWIZZLED                            0xD3D05201
#define D3D_CONTEXT_SURFACES_ARGB_ZS                            0xD3D05301

// D3D 2D rendering objects.
#define D3D_RENDER_SOLID_RECTANGLE                              0xD3D05E01  // Currently used for Z and Buffer Clears
#define D3D_RENDER_SOLID_RECTANGLE_2                            0xD3D05E02  // pseudo texblit notifiers
#define D3D_SCALED_IMAGE_FROM_MEMORY                            0xD3D07701  // Used for swizzling textures.

// D3D Triangle objects.
#define D3D_DX5_TEXTURED_TRIANGLE                               0xD3D05401  // DX5 class triangle renderer.
#define D3D_DX6_MULTI_TEXTURE_TRIANGLE                          0xD3D05501  // Multi Texture/Stencil triangle renderer.

// Celcius primitive
#define D3D_CELSIUS_PRIMITIVE                                   0xD3D05601

// Kelvin primitive
#define D3D_KELVIN_PRIMITIVE                                    0xD3D09701

// IPM allocator
#define IPM_MEMORY_OBJECT_LO                                    0x10000000  // low
#define IPM_MEMORY_OBJECT_HI                                    0x1fffffff  // high
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\minix\modes.h ===
/*++

Copyright (c) 1989-2000  Microsoft Corporation

Module Name:

    modes.h

Abstract:

    This module contains the available video modes

--*/



//                Mode  Width  Height Depth Refresh
    DEF_VIDEOMODE(0x9F, 640  , 480  , 32  , 60)
    DEF_VIDEOMODE(0xA6, 800  , 600  , 32  , 60)
    DEF_VIDEOMODE(0xAD, 1024 , 768  , 32  , 60)
    DEF_VIDEOMODE(0x46, 320  , 240  , 16  , 60)
    DEF_VIDEOMODE(0x4A, 400  , 300  , 16  , 60)
    DEF_VIDEOMODE(0x4E, 480  , 360  , 16  , 60)
    DEF_VIDEOMODE(0x52, 512  , 384  , 16  , 60)
    DEF_VIDEOMODE(0x5C, 640  , 480  , 16  , 60)
    DEF_VIDEOMODE(0x63, 800  , 600  , 16  , 60)
    DEF_VIDEOMODE(0x6A, 1024 , 768  , 16  , 60)
    DEF_VIDEOMODE(0x71, 1152 , 864  , 16  , 60)
    DEF_VIDEOMODE(0x78, 1280 , 1024 , 16  , 60)
    DEF_VIDEOMODE(0x7E, 1920 , 1080 , 16  , 60)
    DEF_VIDEOMODE(0x81, 1920 , 1200 , 16  , 60)
    DEF_VIDEOMODE(0x82, 1600 , 1200 , 16  , 60)
    DEF_VIDEOMODE(0x89, 320  , 240  , 32  , 60)
    DEF_VIDEOMODE(0x8D, 400  , 300  , 32  , 60)
    DEF_VIDEOMODE(0x91, 480  , 360  , 32  , 60)
    DEF_VIDEOMODE(0x95, 512  , 384  , 32  , 60)
    DEF_VIDEOMODE(0xB4, 1152 , 864  , 32  , 60)
    DEF_VIDEOMODE(0xBB, 1280 , 1024 , 32  , 60)
    DEF_VIDEOMODE(0xC1, 1920 , 1080 , 32  , 60)
    DEF_VIDEOMODE(0xC4, 1920 , 1200 , 32  , 60)
    DEF_VIDEOMODE(0xC5, 1600 , 1200 , 32  , 60)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\common\inc\nvBldVer.h ===
#ifndef _NVBLDVER_H_
#define _NVBLDVER_H_

#define NV_BUILD_BRANCH_VERSION "nvr10-61"

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\common\inc\eewinma2.h ===
//*****************************Module*Header******************************
//
// Module Name: eewinman2.h
//
// WINman display propterty page interface version 2
// for board detection, mode set,...
//
// FNicklisch 09/14/2000: 
//
// This part of code was taken from the code bought from ELSA. Parts of 
// it is used to get the workstation tools, application and features up
// and running. It is implemented on a temporary base and will be replaced
// by a NVIDIA propritary interface as soon as possible.
// Don't care about the code not necessariliy used.
//
// Copyright (c) 1998-2000, ELSA AG, Aachen (Germany)
// Copyright (c) 2000 NVidia Corporation. All Rights Reserved.
//
#ifndef _EeWINma2_h_
#define _EeWINma2_h_


/*
** $Header$
**
** MODULE:   EeWINma2.h
**
** AUTHOR:   Torsten Horn, Copyright (c) 1999 ELSA AG, Aachen (Germany)
**
** PROJECT:  ELSA Graphics Software
**
** PURPOSE:  ELSA Escape Windows driver functions for WINman
**
** NOTES:    1998-10-01 THorn: First release.
**           1999-05-04 THorn: Only comment extended/modified.
**           1999-08-03 THorn: New WINMAN_MOD_DFP and comments extended.
**           1999-08-18 THorn: New WINMAN_TIM_... flags.
**           1999-11-12 THorn: ET_WINMAN2_DDC_EDID_GET extended for EDID2.
*/


/*-----------------------------------------------------------------
  For the principle architecture of this kind of ELSA escape functions see 
  the header elsa\ElsaEsc.h (which must be included before this header).

  This header EeWINma2.h defines the escape functions:
    SUBESC_ET_WINMAN2_DATA_GET
    SUBESC_ET_WINMAN2_DATA_SET
    SUBESC_ET_WINMAN2_DDC_EDID_GET
  
  Simplyfied example for getting data from the driver (in case of 16 boards):
    ET_QUERY.dwSubEsc  = SUBESC_ET_WINMAN2_DATA_GET;
    ET_QUERY.dwSize    = sizeof(ET_QUERY);
    ET_QUERY.dwOutSize = sizeof(ET_WINMAN2_DATA_GET) +
                         sizeof(ET_WINMAN2_DATA_BRD_R) * 15;  // when 16 boards
    ExtEscape( hDC, ESC_ELSA_TOOLS,
               ET_QUERY.dwSize,    (LPCSTR)&ET_QUERY,
               ET_QUERY.dwOutSize,  (LPSTR)&ET_WINMAN2_DATA_GET );

  Simplyfied example for setting data to the driver (in case of 16 boards):
    ET_WINMAN2_DATA_SET.hdr.dwSubEsc  = SUBESC_ET_WINMAN2_DATA_SET;
    ET_WINMAN2_DATA_SET.hdr.dwSize    = sizeof(ET_WINMAN2_DATA_SET);
    ET_WINMAN2_DATA_SET.hdr.dwOutSize = sizeof(ET_WINMAN2_DATA_GET) +
                                        sizeof(ET_WINMAN2_DATA_BRD_R) * 15;
    ExtEscape( hDC, ESC_ELSA_TOOLS,
               ET_WINMAN2_DATA_SET.hdr.dwSize,    (LPCSTR)&ET_WINMAN2_DATA_SET,
               ET_WINMAN2_DATA_SET.hdr.dwOutSize,  (LPSTR)&ET_WINMAN2_DATA_GET );

  dwOutSize (in ET_QUERY and ET_WINMAN2_DATA_SET.hdr) must match
    sizeof(ET_WINMAN2_DATA_GET) + sizeof(ET_WINMAN2_DATA_BRD_R) * n;
  where n usually is equal to
    ET_WINMAN2_DATA_GET.dwNumBoardsInstalled - 1
  but n may be less eg. with WINMAN_SET_CHECK, see below.

  The first call usually is a SUBESC_ET_WINMAN2_DATA_GET with a return 
  structure size (dwOutSize) fitting for only one board. If
    ExtEscape() > 0  &&
    lResult == WINMAN_RESULT_ERROR_SIZE  &&
    dwNumBoardsInstalled > 1,
  then the next SUBESC_ET_WINMAN2_DATA_GET call has the correct 
  structure size in dwOutSize for getting the data of all boards.

  SUBESC_ET_WINMAN2_DATA_SET may be called for less than all boards 
  (especially with WINMAN_SET_CHECK). In this case the return structure 
  size (dwOutSize) may fit to this reduced number of boards (what should 
  not produce an error code).
  SUBESC_ET_WINMAN2_DATA_SET must always return either with 
  WINMAN_RESULT_ERROR or with valid and complete data in ET_WINMAN2_DATA_GET.

  You must carefully distinguish between the different return values:
    ExtEscape() must return:
      - zero if the escape function or the subescape is not implemented,
      - less than zero if an error in the escape interface occures (may 
        be ET_QUERY.dwSize is too small),
      - greater than zero if the escape interface is successful, even 
        when another error occures. Other error codes (for problems with 
        the data) are returned in lResult.
    ET_WINMAN2_DATA_GET.lResult must return the fitting WINMAN_RESULT_...
      When the size of the output structure was too small for all needed 
      boards, you must return WINMAN_RESULT_ERROR_SIZE.
      When all data send to the driver are ok, but eg. only the pixel 
      clock (may be of only one board) is too high, you either must return 
      WINMAN_RESULT_ERROR, or better would be, you would return 
      WINMAN_RESULT_MODIFIED and reduce the pixel clock to the max. allowed 
      value.
      With WINMAN_RESULT_ERROR the returned ET_WINMAN2_DATA_GET structure 
      may have invalid data. With WINMAN_RESULT_OK or WINMAN_RESULT_MODIFIED 
      the returned ET_WINMAN2_DATA_GET data must be o.k. and complete for 
      both kind of calls (SUBESC_ET_WINMAN2_DATA_GET and 
      SUBESC_ET_WINMAN2_DATA_SET).
    ET_WINMAN2_DATA_BRD_RW.dwFlags has flags for each board.
      With WINMAN_BRD_MODIFIED you can decide, for which board the data 
      were modified.
    ET_WINMAN2_DATA_GET.dwDrvModFlags returns with the WINMAN_MOD_... flag 
      bits some modification possibilities/capabilities (common for all 
      boards).

  -----------------------------------------------------------------*/


/* #include <elsa\ElsaEsc.h> */


/* Defines for driver result value in lResult
   (used eg. in ET_WINMAN2_DATA_GET and ET_WINMAN2_DDC_EDID_GET). */
#define WINMAN_RESULT_OK          0  /* o.k., no modification */
#define WINMAN_RESULT_ERROR      -1  /* error (returned data invalid) */
#define WINMAN_RESULT_ERROR_SIZE -2  /* error: dwOutSize wrong, 
                                        see comment to dwOutSize in header.
                                        Only the following members of 
                                        ET_WINMAN2_DATA_GET are guaranted to 
                                        be valid: dwSize, lResult, 
                                        dwNumBoardsInstalled, dwNumBoardsActive;
                                        other returned data may be invalid */
#define WINMAN_RESULT_MODIFIED    1  /* data modified;
                                        all data are ok, but only eg. the 
                                        pixel clock was too high; pixel 
                                        clock is reduced to max. allowed 
                                        value */

/* Defines for modification possibilities/capabilities flags in dwDrvModFlags
   (used in ET_WINMAN2_DATA_GET). */
#define WINMAN_MOD_BPP            1  /* bpp changable */
#define WINMAN_MOD_HZ             2  /* new Hz values definable */
#define WINMAN_MOD_TIM            4  /* complete timing definable */
#define WINMAN_MOD_PAN_HOR        8  /* horizontal panning possible */
#define WINMAN_MOD_PAN_VER       16  /* vertical panning possible */
#define WINMAN_MOD_MULTI_HOR     32  /* multiscreen hor. possible */
#define WINMAN_MOD_MULTI_VER     64  /* multiscreen ver. possible */
#define WINMAN_MOD_MULTI_H_V    128  /* multiscreen hor.+ver. both */
#define WINMAN_MOD_RES          256  /* new resolution values definable */
#define WINMAN_MOD_DFP          512  /* DFP Digital Flat Panel (different 
                                        resolutions with one fix timing) */

/* Defines for some board flags in dwFlags
   (used in ET_WINMAN2_DATA_BRD_RW). */
#define WINMAN_BRD_MODIFIED       1  /* data of this board modified */

/* Defines for some timing flags (sync polarity, interlace) in dwTimFlags
   (used in ET_WINMAN2_DATA_BRD_RW). */
#define WINMAN_TIM_HSYNC_POS      8  /* same as GFX_HSYNC_POS */
#define WINMAN_TIM_VSYNC_POS      4  /* same as GFX_VSYNC_POS */
#define WINMAN_TIM_ILC            1  /* same as GFX_ILC */
#define WINMAN_TIM_FIXED_TIMING  16  /* same as GFX_FIXED_TIMING */

/* Defines for action in dwCheckAddRemove
   (used in ET_WINMAN2_DATA_SET). */
#define WINMAN_SET_CHECK          1  /* check (may be modify) this mode */
#define WINMAN_SET_ADD            2  /* add this mode to allowed modes */
#define WINMAN_SET_REMOVE         3  /* remove this mode */
/* The following two are not used till now (for future use): */
#define WINMAN_SET_DO_TEST        4  /* switch only for test screen */
#define WINMAN_SET_DO_PERM        5  /* switch graphics mode permanent */


/* Read/write data of each board
   (used in ET_WINMAN2_DATA_GET and ..._DATA_SET). */
typedef struct tagET_WINMAN2_DATA_BRD_RW
{
  /* These values must always be valid: */
  DWORD dwPanOriginX;            /* panning x-origin */
  DWORD dwPanOriginY;            /* panning y-origin */
  DWORD dwVisOriginX;            /* visible x-origin */
  DWORD dwVisOriginY;            /* visible y-origin */
  DWORD dwPanSizeX;              /* panning x-size */
  DWORD dwPanSizeY;              /* panning y-size */
  DWORD dwVisSizeX;              /* visible x-size */
  DWORD dwVisSizeY;              /* visible y-size */
  DWORD dwBpp;                   /* bpp */
  DWORD dwColorsNum;             /* num. of colors */
  DWORD dwHz;                    /* Hz refresh rate */
  /* These values must be zero if not used: */
  DWORD dwFlags;                 /* flag bits, eg. WINMAN_BRD_MODIFIED */
  DWORD dwTimPixFreq;            /* pixel clock frequency in Hz */
  DWORD dwTimHTot;               /* horizontal total number of pixels */
  DWORD dwTimHFp;                /* horizontal frontporch in pixels */
  DWORD dwTimHSw;                /* horizontal sync width in pixels */
  DWORD dwTimHBp;                /* horizontal backporch in pixels */
  DWORD dwTimVTot;               /* vertical total number of lines */
  DWORD dwTimVFp;                /* vertical frontporch in lines */
  DWORD dwTimVSw;                /* vertical sync width in lines */
  DWORD dwTimVBp;                /* vertical backporch in lines */
  DWORD dwTimFlags;              /* tim. flag bits: WINMAN_TIM_... */
  DWORD dwReserved1;             /* == 0 (reserved) */
  DWORD dwReserved2;             /* == 0 (reserved) */
} ET_WINMAN2_DATA_BRD_RW, *PET_WINMAN2_DATA_BRD_RW;


/* Read-only data of each board
   (used in ET_WINMAN2_DATA_GET). */
typedef struct tagET_WINMAN2_DATA_BRD_R
{
  /* Board data used in ET_WINMAN2_DATA_GET and ..._DATA_SET: */
  ET_WINMAN2_DATA_BRD_RW rw;     /* read/write data */
  /* These values must be zero if not used: */
  DWORD dwPixFreqMax08;          /* max. possible pixel clock (in Hz) at  8bpp */
  DWORD dwPixFreqMax16;          /* max. possible pixel clock (in Hz) at 16bpp */
  DWORD dwPixFreqMax24;          /* max. possible pixel clock (in Hz) at 24bpp */
  DWORD dwPixFreqMax32;          /* max. possible pixel clock (in Hz) at 32bpp */
  DWORD dwMemSizePan;            /* RAM usable for visible and virtual screen */
  DWORD dwMemSizeAll;            /* size of all RAM (e.g. VRAM + DRAM) */
  DWORD dwReserved1;             /* == 0 (reserved) */
  DWORD dwReserved2;             /* == 0 (reserved) */
  char  sBoardname[40];          /* board name */
  char  sSerNum[24];             /* serial number */
} ET_WINMAN2_DATA_BRD_R, *PET_WINMAN2_DATA_BRD_R;


/* Data WINman gets from the Windows driver. */
typedef struct tagET_WINMAN2_DATA_GET
{
  DWORD dwSize;                  /* sizeof this struct with correct num of brd */
  LONG  lResult;                 /* WINMAN_RESULT_OK, ...ERROR..., ...MODIFIED */
  DWORD dwDrvModFlags;           /* driver modify flags WINMAN_MOD_... */
  DWORD dwReserved;              /* == 0 (reserved) */
  DWORD dwNumBoardsInstalled;    /* number of all installed boards */
  DWORD dwNumBoardsActive;       /* number of active used boards */
  /* The following struct as often as dwNumBoardsActive: */
  ET_WINMAN2_DATA_BRD_R brd[1];  /* data of all boards */
} ET_WINMAN2_DATA_GET, *PET_WINMAN2_DATA_GET;


/* Data WINman writes to the Windows driver. */
typedef struct tagET_WINMAN2_DATA_SET
{
  ET_QUERY hdr;
  DWORD dwCheckAddRemove;        /* WINMAN_SET_CHECK, ..._ADD, ..._DO_... */
  DWORD dwReserved1;             /* == 0 (reserved) */
  DWORD dwReserved2;             /* == 0 (reserved) */
  DWORD dwSizeX;                 /* x-size of desktop (over all monitors) */
  DWORD dwSizeY;                 /* y-size of desktop (over all monitors) */
  DWORD dwNumBoardsActive;       /* number of active used boards */
  /* The following struct as often as dwNumBoardsActive: */
  ET_WINMAN2_DATA_BRD_RW brd[1]; /* data of all boards */
} ET_WINMAN2_DATA_SET, *PET_WINMAN2_DATA_SET;


/*-----------------------------------------------------------------
  SUBESC_ET_WINMAN2_DDC_EDID_GET
  
  Example (m=0 for EDID1 and m=1 for EDID2):
    ET_QUERY.dwSubEsc  = SUBESC_ET_WINMAN2_DDC_EDID_GET;
    ET_QUERY.dwSize    = sizeof(ET_QUERY);
    ET_QUERY.dwOutSize = sizeof(ET_WINMAN2_DDC_EDID_GET) + m*128;
    ET_QUERY.dwBoard   = n;
    ExtEscape( hDC, ESC_ELSA_TOOLS,
               sizeof(  ET_QUERY ),
               (LPCSTR)&ET_QUERY,
               sizeof(  ET_WINMAN2_DDC_EDID_GET ) + m*128,
               (LPSTR) &ET_WINMAN2_DDC_EDID_GET );
  -----------------------------------------------------------------*/


/* DDC EDID structure WINman gets from the Windows driver.
   This structure  is for EDID 1.x with 128 bytes 
   of data as well as for EDID 2.x with 256 bytes.
   When WINman querries with wrong ET_QUERY.dwOutSize value, 
   the driver has to return WINMAN_RESULT_ERROR_SIZE. 
   Then WINman must try with another ET_QUERY.dwOutSize. */
typedef struct tagET_WINMAN2_DDC_EDID_GET
{
  DWORD dwSize;                   /* sizeof(ET_WINMAN2_DDC_EDID_GET)+m*128 */
  LONG  lResult;                  /* WINMAN_RESULT_OK, WINMAN_RESULT_ERROR... */
  unsigned char ddcEdid[128][1];  /* VESA DDC EDID structure */
} ET_WINMAN2_DDC_EDID_GET, *PET_WINMAN2_DDC_EDID_GET;


#endif  // #ifndef _EeWINma2_h_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\common\inc\elsaesc.h ===
//*****************************Module*Header******************************
//
// Module Name: elsaesc.h
//
// This file conatins all declarations for the ELSA Escape interface
// used by all tools and applications to access graphic driver data.
//
// FNicklisch 09/14/2000: 
//
// This part of code was taken from the code bought from ELSA. Parts of 
// it is used to get the workstation tools, application and features up
// and running. It is implemented on a temporary base and will be replaced
// by a NVIDIA propritary interface as soon as possible.
// Don't care about the code not necessariliy used.
//
// Copyright (c) 1998-2000, ELSA AG, Aachen (Germany)
// Copyright (c) 2000 NVidia Corporation. All Rights Reserved.
//
#ifndef __ELSAESC
#define __ELSAESC

/*
** $Header$
**
** MODULE:   ELSAESC.H
**
** AUTHOR:   Fred Nicklisch
**           Copyright (c) 1991-99 ELSA AG, Aachen (Germany)
**
** PROJECT:  ELSA Graphics Software
**
** PURPOSE:  define Escape interface between Windows 95/NT display driver
**           and tools
**
** DESCR:    All ELSA drivers will provide a escape interface to allow
**           user-applications (tools) to configure the display driver and
**           retrieve information. The application has to use ExtEscape.
**           The implementation depends on one single esc entry and
**           multiple subescapes.
**
**           WARNING: We only allow the basic types
**                    LONG, DWORD and char in all in and out structures!
**                    Don't use Tabs (blanks instead)
**                    Don't use german "Umlaute"
**
** NOTES:    01.12.97 FNicklis: First Release, basic functionality
**           02.12.97 MSuhre  : Added support for Monitor-Key,
**                              changed CHAR to char
**           03.12.97 SKuklik : Added support for DUO Boards
**           03.12.97 SKuklik : Added support for DUO Boards
**           04.12.97 FNicklis: struct packing and basic types
**           04.12.97 MSuhre  : #pragma pack (push/pop,..)
**                              push and pop are not valid for MS-C 1.52
**           06.03.98 tu      : Query and set value for string and dword added
**           06.03.98 FNicklis: Fixed "query and set value" to make it compilable
**           08.03.98 FNicklis: defined ET_SET_VALUE_RET
**           12.03.98 tu      : Added query and set value ID's for WinNT:
**                                HardwareInformation 0x20000500-0x200005ff
**                                Desktop coordinates 0x20000600-0x200006ff
**                                Some Basic/system values 0x20000002-0x20000004
**                              Added dwFlags to ET_VALUE_STRING and ET_VALUE_DWORD;
**                              Added return flags convention
**           12.03.98 THorn   : New grouping of the items in this file,
**                              no compiler relevant change.
**           13.03.98 tu      : Added value ID ET_VALUE_DW_ICDINTERFACE_SIZEOFBUFFER
**           13.04.98 db      : replaced dwAlign member of ET_QUERY with dwBoard
**                              Somehow we have to know for what board we want to read or write
**           13.04.98 db      : number of dma buffers is not number of subbuffers (used the same ID)
**           12.05.98 THorn   : SUBESC_ET_WINMAN_DDC_EDID_GET added.
**           09.06.98 tu      : Transfer ESCAPE calls from EDDESC.H (SUBESC_ET_EDD_xxx)
**           08.07.98 tu      : Added value ID ET_VALUE_DW_OPENGL_DISABLETEXTUREPATCHING (0x20000320)
**           14.08.98 FNicklis: Added value IDs ET_VALUE_DW_xx for NT driver
**           16.09.98 THorn   : SUBESC_ET_WINMAN2_... added.
**           25.09.98 tu      : added ET_VALUE_ERROR (0x80000000)
**                              added #pragma warning( disable:4201 ) at struct tagET_VERSION
**           30.09.98 FNicklis: Added version stamp and capabilities to ET_VERSION retrieved with
**                              SUBESC_ET_QUERY_VERSION_INFO
**           21.10.98 FNicklis: Extension to ET_VALUE_xx-interface (ET_VALUE_BLOCKED)
**           23.10.98 FNicklis: NT doesn't know FAR and somtimes doesn't know DWORD
**           25.10.98 FNicklis: Modified ET_VALUE_xx-interface to get reserved bits for OS internals
**           12.11.98 js:       ET_VALUE_DW_OPENGL_SUPPORTPRODESIGNER for OpenGL.SupportProDesigner added
**           21.11.98 FNicklis: ET_VALUE_DW_OPENGL_DMAMAXCOUNT, ET_VALUE_DW_OPENGL_DMAMINPUSHCOUNT added
**           25.11.98 MPietsch: ET_VALUE_DW_OPENGL_PIXELTUBE added
**                    FNicklis: Added some informational stuff regarding version stamp and version checking
**           02.12.98 FNicklis: New ET_VALUE_TYPE_DWORD_DEFAULT, ...
**           29.01.99 FNicklis: Registry Key-IDs 0x2000032A-0x2000032E
**           29.01.99 SKuklik:  Registry Key-IDs 0x20000069-0x2000006c, 0x20000097, 0x20000129, 0x20000208, 0x20000405 - 406, 0x20000601 - 602
**           03.02.99 CSkopins: Escape-Codes fuer Video-In/-Out hinzugefuegt.
**           11.02.99 SKuklik : Registry Key-ID  0x2000012B (ICDInterface.PFD_SWAP_EXCHANGE)
**           12.02.99 FNicklis: SUBESC_ET_QUERY_ICDCLIENTINFO
**           13.04.99 CSchalle: ET_VALUE_SZ_HARDWAREINFORMATION_BIOSSTRING
**           14.04.99 CSchalle: added ET_VALUE_DW_OPENGL_ALIGNED_SURFACES
**           22.04.99 CSchalle: added ET_VALUE_DW_OPENGL_FRAMEBUFFER_DMA
**           11.05.99 JS:       added ET_SUBESC_ET_xxx_VALUE_BINARY, ET_VALUE_BIN_GDI_GAMMARAMP
**                              added SUBESC_ET_EDD_xETGAMMARAMP
**           19.05.99 FNicklis: ET_VALUE_DW_OPENGL_AUTODESKEXTENSIONS fixed
**           28.06.99 HHornig : added RES_ESC_ELSA_TOOL call for generic drivers
**           30.06.99 FNicklis: added SUBESC_ET_MULTIBOARDSETUP for internal Display driver vs multiboard driver calls
**           25.08.99 CSkopins: added Capability flags for STEREO and OVERCLOCKING
**           22.09.99 HHornig : added ET_EDD_GETCOLORCAPSLIMITS
**           28.09.99 TU:       added SUBESC_ET_QUERY_TEMPERATURE for temperature and fan status
**           29.09.99 FNicklis: added SUBESC_ET_DPMS and sample code
**           18.10.99 CSkopins: added SUBESC_RMAPI_CONFIGSETGET for ERAZOR X TV-Out
**           20.10.99 CSchalle: added ET_VALUE_BIN_OEM_MODELIST
**           10.02.00 FNicklis: added ET_VALUE_DW_DMA_7DUMMYREADS, ET_VALUE_DW_DMA_DUMMYREADUC, ET_VALUE_DW_DMA_FORCEIOFLUSH
**           10.03.00 HHornig : added SUBESC_GET_OUTPUT_DEVICE_INFO / SUBESC_SET_OUTPUT_DEVICE
**           23.05.00 BSchwall: added ET_VALUE_DW_OPENGL_UNIGRAPHICS_TEXTURE_FIX
*/

// ********************************************************
// ********************************************************
// Basic defines
// -------------

// We need a common alignment for all structures:
// save current packing and switch to 8 byte (64bit)
#ifdef WIN32
#pragma pack (push, fixed_forELSAESC)
#endif
#pragma pack(8)

#define ET_MAX_PATH   260 // MAX_PATH is not available in all environments!
#define ET_MAX_STRING 260


#define ESC_ELSA_TOOLS 0xE15A // Escape for ELSA Tools
// HHORNIG : 28.6.99
// if we build generic drivers some tools are allowed to pop up
// to detect this the tool should use this call combined with
// a special code that is only used for this tool
#define RES_ESC_ELSA_TOOLS 0xE15B // restricted Escape for ELSA Tools

// FNicklis 23.10.98: Need it sometimes ;-)
#ifndef DWORD
typedef unsigned long DWORD;
#endif

// FNicklis 23.10.98: Under NT we don't have FAR and NEAR
#ifndef FAR
#define FAR
#endif

#ifdef NTMINIPORT
// FNicklis 29.01.1999: don't know HWND in NT miniport
#ifndef HWND
#define HWND PVOID
#endif
#endif// NTMINIPORT

// Subescapes: 0x00000000 - 0x0fffffffbasic sub escapes
//             0x10000000 - 0x1fffffff to be defined by Win95
//             0x20000000 - 0x2fffffff to be defined by NT (NTeam)
//             0x30000000 - 0xffffffff unused
// Naming: SUBESC_ET_xxxx, read: Sub escape for ELSA tools
//
// Note: Queries should use the same in structure ET_QUERY but different
//       query subescapes SUBESC_ET_QUERY_yyyy

// ********************************************************
// Sub escapes, common for Windows 95 and Windows NT:
#define SUBESC_ET_QUERY_VERSION_INFO        0x00000000

#define SUBESC_ET_QUERY_VALUE_STRING        0x00000010
#define SUBESC_ET_QUERY_VALUE_DWORD         0x00000011
#define SUBESC_ET_QUERY_VALUE_BINARY        0x00000012

#define SUBESC_ET_SET_VALUE_STRING          0x00000018
#define SUBESC_ET_SET_VALUE_DWORD           0x00000019
#define SUBESC_ET_SET_VALUE_BINARY          0x00000020

// 0x30-0x4F reserved for WINman
#define SUBESC_ET_WINMAN_DATA_GET           0x00000030
#define SUBESC_ET_WINMAN_DATA_SET           0x00000031
#define SUBESC_ET_WINMAN_DDC_EDID_GET       0x00000032
#define SUBESC_ET_WINMAN2_DATA_GET          0x00000035
#define SUBESC_ET_WINMAN2_DATA_SET          0x00000036
#define SUBESC_ET_WINMAN2_DDC_EDID_GET      0x00000037

// 0x50-0x6F reserved for elsa directdraw caps
#define SUBESC_ET_EDD_GETCAPS               0x00000050
#define SUBESC_ET_EDD_GETFEATURES           0x00000051
#define SUBESC_ET_EDD_SETFEATURES           0x00000052
#define SUBESC_ET_EDD_GETVIDMEMINFO         0x00000053
#define SUBESC_ET_EDD_GETCOLORADJUSTMENT    0x00000054
#define SUBESC_ET_EDD_SETCOLORADJUSTMENT    0x00000055
#define SUBESC_ET_EDD_SETGAMMARAMP          0x00000056
#define SUBESC_ET_EDD_GETGAMMARAMP          0x00000057
#define SUBESC_ET_EDD_GETCOLORCAPSLIMITS    0x00000058

// 0x100-0x11F reserved for Video-In / -Out Escapes
//
#define SUBESC_ET_VIDEO_DMACOPYSM           0x00000100
#define SUBESC_ET_VIDEO_OUTCONTROL          0x00000110
#define SUBESC_ET_RMAPI_CONFIGSETGET        0x0000011F

// 0x200-0x21F reserved for all tools to decide if they are
//             allowed to pop up, only to be used in combination
//             with a resctricted call RES_ESC_ELSA_TOOL
//
#define SUBESC_STEREO_TOOL                  0x00000200

// 0x300-0x3FF reserved for hardware status and control
//
#define SUBESC_ET_QUERY_TEMPERATURE         0x00000300

#define SUBESC_ET_GET_OUTPUT_DEVICE_INFO    0x00000310
#define SUBESC_ET_SET_OUTPUT_DEVICE         0x00000311


// ********************************************************
// Windows 95 sub escapes:

#define SUBESC_ET_QUERY_MONITORKEY_REGPATH  0x10000000
#define SUBESC_ET_QUERY_D3DSETTINGS_REGPATH 0x10000001

// ********************************************************
// Windows NT sub escapes:

#define SUBESC_ET_QUERY_OPENGLICD_REGPATH   0x20000000
#define SUBESC_ET_DUO_ESC_GETPANELINFO      0x20000002  //Returns Information on our Panel/PanelCaps
#define SUBESC_ET_DUO_ESC_SETPANELINFO      0x20000004  //Sets Panel Information
#define SUBESC_ET_POWERLIB_START            0x20000008  //Tells driver that one powerlib has started
#define SUBESC_ET_POWERLIB_EXIT             0x20000009  //Tells driver that one powerlib will end

// 0x10-0x2F reserved for driver internal escapes
#define SUBESC_ET_GETREGISTER               0x20000010  // direct hw access
#define SUBESC_ET_SETREGISTER               0x20000011
#define SUBESC_ET_MODIFYREGISTER            0x20000012
#define SUBESC_ET_SCROLL                    0x20000013
#define SUBESC_ET_GFXOPTIONQUERY            0x20000014

#define SUBESC_ET_NOTIFYDRIVER              0x20000015  // special support for video capture driver
#define SUBESC_ET_SAA                       0x20000016
#define SUBESC_ET_DDSURFOVERRIDE            0x20000017

#define SUBESC_ET_MULTIBOARDSETUP           0x20000018 // FNicklis: setup singleboard client with information from multiboard wrapper.
                                                       // IO structures ET_MULTIBOARDSETUP_IN and ET_MULTIBOARDSETUP_OUT are defined in driver code!
#define SUBESC_ET_DPMS                      0x20000019 // FNicklis: set DPMS power save mode; uses ET_DPMS_IN and ET_DPMS_OUT

// 0x30- ... Common driver Escapes
#define SUBESC_ET_SETWINDOW_STEREOMODE      0x20000030 // set the stereo mode of an OpenGL window
#define SUBESC_ET_QUERY_ICDCLIENTINFO       0x20000031 // receive information about OpenGL-Clients


// ********************************************************
// ********************************************************
// In structure (Tool -> driver):
// Input Query structure, common part of all subescape input structures
// --------------------------------------------------------------------
typedef struct tagET_QUERY
{
  DWORD dwSize;    // Length of this structure, sizeof(ET_QUERY)
  DWORD dwSubEsc;  // has to be (SUBESC_ET_QUERY_VERSION_INFO, SUBESC_ET_QUERY_OPENGLICD_REGPATH, ...)
  DWORD dwOutSize; // size of output data structure (if there is such data)
  DWORD dwBoard;   // for registry issues we need to know for what board we have to read/write @@db 130498
                   // Calls that affect all boards use ET_ALL_BOARDS to initialize dwBoard
                   // 0 -> board 0, 1 -> board 1, ET_ALL_BOARDS -> all boards
} ET_QUERY;

#define ET_ALL_BOARDS 0xFFFFFFFF   // FNicklis, 11.03.99 reserved key for all boards

// driver get's PVOIDs but needs a fast access to members
#define ET_QUERY_GET_SUBESC(pv)    (((ET_QUERY*)pv)->dwSubEsc)
#define ET_QUERY_GET_BOARD(pv)     (((ET_QUERY*)pv)->dwBoard)

// ********************************************************
// ********************************************************
// Version info and some other data from driver
// --------------------------------------------

#define MAX_ET_VERSION 64

#define ET_VER_RELEASE_DRIVER    0x0
#define ET_VER_WHQL_DRIVER       0x1 // Release driver for WHQL
#define ET_VER_BETA_DRIVER       0x2 // Beta driver neither release nor WHQL

// Out structure (Driver -> Tool):
// Version information used in ET_VERSION_INFO, retrieved by SUBESC_ET_QUERY_VERSION_INFO

#ifdef WIN32
#pragma warning( disable:4201 ) // nonstandard extension used : nameless struct/union
#endif

// Usage of ET_VERSION_STAMP:
//
// Allowes to check which bits of the capabilities fields are defined.
// You may only test the bits defined in the version matching the version
// stamp.
//
// NOTE: The version stamp is only valid for the ET_VERSION structure!
//   Don't validate other structures with this!
//
// NOTE: A tool may only test the capabilities defined for the version
//   matching the version stamp.
//
// NOTE: Newer versions must support the capabilites of older versions!
//
// NOTE: A tool must check for an equal version stamp as older drivers
//   didn't touch the reserved flags, and leaved them initialized!
//   It isn't allowed to do a greater equal test on the verstion stamp!
//
// example:
/*
// FNicklis 25.11.98 15:30:15: example program
BOOL bIsCVBoard(
  IN const ET_VERSION_INFO *pVersionInfo)  // pointer to version info (read outside)
{
  const ET_VERSION *pVersion;
  BOOL              bRet     = FALSE; // default is no CV board

  assert(NULL!=pVersionInfo);

  pVersion = &(pVersionInfo->Version);

  // as it is a union it must be the same!
  assert(pVersion->dwNTVersionStamp ==pVersion->dwW95VersionStamp);
  assert(pVersion->dwW95Capabilities==pVersion->dwNTCapabilities);

  //Not allowed! if ( pVersion->dwNTVersionStamp>ET_VERSION_STAMP10 )

  // ET_VERSION_STAMP10 was the first version that supported
  // this extenstion

  if ( ET_VERSION_STAMP10==pVersion->dwNTVersionStamp )
  {
    // it's a version 1.0, supported by our app

    // we may test 1.0 features: ET_VERSION_CAPS_CV_PRODUCT and ET_VERSION_CAPS_2D_BOARD_ONLY
    if ( pVersion->dwNTCapabilities & ET_VERSION_CAPS_CV_PRODUCT )
    {
      bRet = TRUE;
    }
  }
  else
  {
    // error, interface not valid
    // older board -> fallback
    // unknown board -> exit

    // .... add code here
  }

  return (bRet);
}
*/
// History:
// ???????? uninitialized and any other value than defined VERSION_STAMPS are
//          invalid and don't support the interface!
// 00000010: First version 1.0 valid and testableET_VERSION_CAPS_xx:
//     xx_CV_PRODUKT
//     xx_2D_BOARD
#define ET_VERSION_STAMP10 0x00000010         // FNicklis 30.09.1998 first version

// please don't use ET_VERSION_STAMP any longer!
#define ET_VERSION_STAMP  ET_VERSION_STAMP10  // Current version stamp is highest available, but better is
                                              // to use the stamp you know you support!
// capabilities
// defined in 1.0:
//                      CH == !CV product
#define ET_VERSION_CAPS_CV_PRODUCT     0x01 // The board is a CV product (GLoria, Synergy, ...)
                                            // GLoria Settings, POWERlib, ... must run
//                      3D == !2D
#define ET_VERSION_CAPS_2D_BOARD_ONLY  0x02 // The board has only 2D and no hardware 3D capabilities (Trio, S3 986,..)

//
#define ET_VERSION_CAPS_DIRECT3DSTEREO 0x04 // Driver supports REVELATOR type Stereo for Direct3D
#define ET_VERSION_CAPS_OPENGLSTEREO   0x08 // Driver supports REVELTAOR type Stereo for OpenGL
#define ET_VERSION_CAPS_OVERCLOCKING   0x10 // Driver supports overclocking
#define ET_VERSION_CAPS_TEMPERATURE    0x20 // Driver supports temperature control

// ... to be continued


// used with SUBESC_ET_QUERY_VERSION_INFO
typedef struct tagET_VERSION
{
  DWORD dwFlags;                     // Flags to define WHQL, BETA, ... driver
  DWORD dwAlign1;                    // needed to align on 8 byte boundaries

  // NT and Win95 version data is different, so use a union to match all
  union
  {
    struct // Windows 95 version information
    {
      DWORD dwW95Major;        //
      DWORD dwW95Minor;        //
      DWORD dwW95BuildMajor;   //
      DWORD dwW95BuildMinor;   //
      DWORD dwW95BuildPrivate; //
      DWORD dwW95Reserved1;    // unused
      DWORD dwW95Capabilities; // bitfield containing capabilities (ET_VERSION_CAPS_xx)
      DWORD dwW95VersionStamp; // == ET_VERSION_STAMP (read comment above!) Has to be verified before reading dwW95Capabilities!
    };
    struct // Windows NT version information
    {           // e.g 5.12.00.345
      DWORD dwNTMajor;      //   5
      DWORD dwNTMinor;      //  12
      DWORD dwNTBuildMajor; //  00
      DWORD dwNTBuildMinor; // 345
      DWORD dwNTReserved0;
      DWORD dwNTReserved1;
      DWORD dwNTCapabilities; // bitfield containing capabilities (ET_VERSION_CAPS_xx)
      DWORD dwNTVersionStamp; // == ET_VERSION_STAMP (read comment above!). Has to be verified before reading dwNTCapabilities!
    };
  };

  char  szVersion[MAX_ET_VERSION]; // Version string (ANSI/ASCCI)

} ET_VERSION;

#ifdef WIN32
#pragma warning( default:4201 ) // nonstandard extension used : nameless struct/union
#endif

// Out structure (Driver -> Tool):
// Structure to retrieve driver version and registry data
typedef struct tagET_VERSION_INFO
{
  DWORD dwSize;    // Length of this structure, sizeof(ET_VERSION_INFO)

  // Driver version information (system dependent!)
  ET_VERSION Version;

  // Complete path to drivers registry (be sure it is defined long enough!)
  char  szRegDriverKey[ET_MAX_PATH]; // e.g. NT:    "\Registry\Machine\System\CurrentControlSet\Services\EGLXLM"
                                 // e.g. Win95: "\Registry\Machine\System\CurrentControlSet\Services\Class\Display\0000"

} ET_VERSION_INFO;


// Out structure (Driver -> Tool):
// Structure to retrieve complete path to key where the monitor is defined
typedef struct tagET_MONITORKEY_REGPATH
{
  DWORD dwSize;    // Length of this structure, sizeof(ET_MONITORKEY_REGPATH)

  // Complete path to Key where the ICD is defined
  char  szRegMonitorKey[ET_MAX_PATH];  // e.g. Win95: "\Registry\Machine\System\CurrentControlSet\Services\Class\Monitor\0000"

} ET_MONITORKEY_REGPATH;


// Out structure (Driver -> Tool):
// Structure to retrieve complete path to key where D3DSettings store its settings
typedef struct tagET_D3DSETTINGS_REGPATH
{
  DWORD dwSize;    // Length of this structure, sizeof(ET_D3DSETTINGS_REGPATH)

  // Complete path to Key where the ICD is defined
  char  szRegD3DSettingsKey[ET_MAX_PATH];  // e.g. Win95: "\Registry\Machine\Software\ELSA\Erazor"

} ET_D3DSETTINGS_REGPATH;


// Out structure (Driver -> Tool):
// Structure to retrieve complete path to Key where the ICD is defined
typedef struct tagET_OPENGLICD_REGPATH
{
  DWORD dwSize;    // Length of this structure, sizeof(ET_OPENGLICD_REGPATH)

  // Complete path to Key where the ICD is defined
  char  szRegICDKey[ET_MAX_PATH];  // e.g. NT: "\Registry\Machine\Software\Microsoft\WindowsNT\OpenGLDrivers\ELSA EGLXLM driver"
  char  szRegICDName[ET_MAX_PATH]; // e.g. NT: "EOGLXL"

} ET_OPENGLICD_REGPATH;




// ET_EDD_GETVIDMEMINFO
// get surface counts
typedef struct tagET_EDD_GETVIDMEMINFODATA
{
  DWORD   dwSize;
  DWORD   dwPrimaryCount;
  DWORD   dwOffscreenCount;
  DWORD   dwOverlayCount;
} ET_EDD_GETVIDMEMINFODATA, FAR* LPET_EDD_GETVIDMEMINFODATA;


#define ET_COLOR_CAPS_CONTRAST    0x01    // driver supports contrast settings and limitations are valid
#define ET_COLOR_CAPS_BRIGHTNESS  0x02    // driver supports brightness settings and limitations are valid
#define ET_COLOR_CAPS_SATURATION  0x04    // driver supports saturation settings and limitations are valid
#define ET_COLOR_CAPS_HUE         0x08    // driver supports hue settings and limitations are valid

// ET_EDD_GETCOLORCAPSLIMITS
// get capability of contrast, brightness saturation and hue
// and their limits. The limits are only valid if the capability
// is set.
typedef struct tagET_EDD_GETCOLORCAPSLIMITS
{
  DWORD   dwSize;
  DWORD   dwColorCaps;
  long    lContrastMin;
  long    lContrastMax;
  long    lBrightnessMin;
  long    lBrightnessMax;
  long    lSaturationMin;
  long    lSaturationMax;
  long    lHueMin;
  long    lHueMax;
  long    reserved[20];     // some spare left for future
} ET_EDD_GETCOLORCAPSLIMITS, FAR* LPET_EDD_GETCOLORCAPSLIMITS;


// ET_EDD_SETCOLORADJUSTMENT
// set contrast, brightness saturation and hue
// values for each item is 0..9999
typedef struct tagET_EDD_SETCOLORADJUSTMENTDATA
{
  ET_QUERY hdr;				// size and subescape SUBESC_ET_EDD_SETCOLORADJUSTMENT
  long   dwContrast;
  long   dwBrightness;
  long   dwSaturation;
  long   dwHue;
} ET_EDD_SETCOLORADJUSTMENTDATA, FAR* LPET_EDD_SETCOLORADJUSTMENTDATA;


// ET_EDD_GETCOLORADJUSTMENT
// get contrast, brightness saturation and hue
// values for each item is 0..9999
typedef struct tagET_EDD_GETCOLORADJUSTMENTDATA
{
  DWORD   dwSize;
  long    dwContrast;
  long    dwBrightness;
  long    dwSaturation;
  long    dwHue;
  DWORD   dwYUVOverlayVisibleCount;
} ET_EDD_GETCOLORADJUSTMENTDATA, FAR* LPET_EDD_GETCOLORADJUSTMENTDATA;


// ET_EDD_SETFEATURES  set ELSA DirectDraw features
typedef struct tagET_EDD_SETFEATURESDATA
{
  ET_QUERY hdr;				// size and subescape SUBESC_ET_EDD_SETFEATURES
  DWORD   dwEddCaps0;
  DWORD   dwEddCaps1;
} ET_EDD_SETFEATURESDATA, FAR* LPET_EDD_SETFEATURESDATA;


// ET_EDD_GETFEATURES get ELSA DirectDraw features
typedef struct tagET_EDD_GETFEATURESDATA
{
  DWORD   dwSize;
  DWORD   dwEddCaps0;
  DWORD   dwEddCaps1;
} ET_EDD_GETFEATURESDATA, FAR* LPET_EDD_GETFEATURESDATA;


// ET_EDD_GETCAPS
//   retrieves capabilitie of ELSA DirectDraw features
//   capabilities depends on hardware, resolution and pixel depth
typedef struct tagET_EDD_GETCAPSDATA
{
  DWORD   dwSize;
  DWORD   dwEddCaps0;
  DWORD   dwEddCaps1;
} ET_EDD_GETCAPSDATA, FAR* LPET_EDD_GETCAPSDATA;

// ET_GAMMA_SET
//   _TEMPORARY_ set a gamma table.
//   This escape immediately sets the gamma table to the device. The table
//   is not stored permanently by the device. Means, after reboot, the
//   original 1:1 (or what ever else) table is reloaded by hardware.
//   To store the table, use the ELSA Subescape:
//      SUBESC_ET_SET_VALUE_BINARY::ET_VALUE_BIN_GDI_GAMMARAMP
//
//   Information about the success of the SET call is provided
//   via a ET_SET_VALUE_RET structure
//   If the hardware generally supports gamma ramps, but not in the current
//   mode (256 colors), the flags field in the output structure contains
//   ET_VALUE_BLOCKED.

typedef struct tagET_EDD_SETGAMMARAMP
{
  ET_QUERY hdr;       // size and subescape SUBESC_ET_EDD_SETGAMMARAMP
  WORD     red[256];
  WORD     green[256];
  WORD     blue[256];
} ET_EDD_SETGAMMARAMP, FAR* LPET_EDD_SETGAMMARAMP, * PET_EDD_SETGAMMARAMP;

typedef struct tagET_EDD_GETGAMMARAMP
{
  DWORD   dwSize;
  DWORD   dwResult;		// ET_VALUE_OK if succeeded and ET_VALUE_BLOCKED if Gamma not supported yet
  WORD    red[256];
  WORD    green[256];
  WORD    blue[256];
} ET_EDD_GETGAMMARAMP, FAR* LPET_EDD_GETGAMMARAMP, * PET_EDD_GETGAMMARAMP;

// ET_VIDEO_DMACOPYSM
//   copies video memory to system memory by DMA
typedef struct tagET_VIDEO_DMACOPYSMDATA
{
  ET_QUERY  hdr;

  DWORD     dwDstSel;       // Selector of destination memory (16Bit) / NULL (32Bit)
  DWORD     dwDstOfs;       // Offset of destination memory (16Bit) / Linear Address (32Bit)
  DWORD     dwDstStride;    //

  DWORD     dwSrcSel;       // Selector of source video memory (16Bit) / NULL (32Bit)
                            // The base of the selector points to the start of the video memory
  DWORD     dwSrcOfs;       // Offset of source video memory (16Bit) / Linear Address (32Bit)
                            // This is the offset relative to the beginning of video memory
  DWORD     dwSrcStride;    //

  DWORD     dwWidthBytes;   // Amount of bytes to transfer in one line (must be aligned to 4)
  DWORD     dwHeight;       // Anount of lines to transfer
} ET_VIDEO_DMACOPYSMDATA, FAR* LPET_VIDEO_DMACOPYSMDATA;

// ET_VIDEO_OUTCONTROL
//   controls video-out
typedef struct tagET_VIDEO_OUTCONTROL
{
  ET_QUERY  hdr;

  DWORD     dwEnable;
  DWORD     dwControl;
  DWORD     dwParam1;
  DWORD     dwParam2;
} ET_VIDEO_OUTCONTROL, FAR* LPET_VIDEO_OUTCONTROL, * PET_VIDEO_OUTCONTROL;

// ET_RMAPI_CONFIGSETGET
//   allows escape access to stateConfigGet [...] routines.
typedef struct tagET_RMAPI_CONFIGSETGET
{
  ET_QUERY  hdr;
  DWORD     dwSetGetCommand;
  DWORD     dwIndex;
  DWORD     dwlpParamStruct;
  DWORD     dwParamSize;
  DWORD     dwValue;
  DWORD     dwParam0;
  DWORD     dwParam1;
  DWORD     dwParam2;
} ET_RMAPI_CONFIGSETGET, FAR* LPET_RMAPI_CONFIGSETGET, * PET_RMAPI_CONFIGSETGET;

// Constants for ELSA DirectDraw features:
//
// dwEddCaps0:
#define EDDCAPS_DITHER              0x00000001
#define EDDCAPS_FILTERX             0x00000002
#define EDDCAPS_FILTERY             0x00000004
#define EDDCAPS_FILTERX_LIN02420    0x00000008
#define EDDCAPS_FILTERX_BILINEAR    0x00000010
#define EDDCAPS_FILTERX_LIN12221    0x00000020
#define EDDCAPS_OFFSCREENINHIBIT    0x00000040
#define EDDCAPS_OFFSCREENLINEAR     0x00000080
#define EDDCAPS_COLORADJUSTYUV_CB   0x00000100
#define EDDCAPS_COLORADJUSTYUV_HS   0x00000200
#define EDDCAPS_FILTERXY_BILINEAR   0x00000400
#define EDDCAPS_DITHER_ALWAYS_ON    0x00000800
#define EDDCAPS_ENABLE_332_TEXTURE  0x00001000

// 3D-Features
#define EDDCAPS_INHIBIT_ZBUFFER     0x00010000
#define EDDCAPS_INHIBIT_PERSCORRECT 0x00020000
#define EDDCAPS_INHIBIT_TEXTURE     0x00040000
#define EDDCAPS_INHIBIT_FOG         0x00080000
#define EDDCAPS_INHIBIT_FILTER      0x00100000
#define EDDCAPS_INHIBIT_ALPHA       0x00200000
// ViRGE/DX has a fast bilinear algorithm
#define EDDCAPS_FASTBILINEAR        0x00400000
// emuliere Colorkey for a Texture using texture alpha blending
#define EDDCAPS_EMULATE_TEX_CKEY    0x00800000
#define EDDCAPS_SIMULATE_MIPMAP     0x01000000

// Commands
#define EDDCMD_ALLOCFILTERYBUF      0x80000001

// Bedeutung der einzelnen Bits in dwEddCaps0 beim Aufruf von
// EDDESC_SETFEATURES:
//
// Achtung: Ein Bit darf nur gesetzt werden, wenn das entsprechende Bit
//          vorher bei einem Aufruf von EDD_GETCAPS als gueltig gemeldet
//          wurde.
//
// EDDCAPS_DITHER  : 1=Dithering ein. 0=Dithering aus.
//
// EDDCAPS_FILTERX : 1=Schalte einen Filter ein. Ggf. kann mit anderen
//                   Konstanten eine spezieller Filter definiert werden.
//                   Wird kein spezieller Filter ausgewaehlt (obwohl
//                   es moeglich waere) so sucht der Treiber einen adequaten
//                   Filter aus.
//                   0=Alle Filter aus.
//
// EDDCAPS_FILTERX_xxxxx : Schalte diesen speziellen Filter ein, wenn auch
//                         EDDCAPS_FILTERX gesetzt ist.
//
// EDDCAPS_OFFSCREENLINEAR: Weist den DirectDraw-Treiber an, linearen
//                          Offscreen falls moeglich (!) zu benutzen, um z.B.
//                          eine bessere Speicherausnutzung zu erreichen, oder
//                          die Erzeugung von Offscreen-Surfaces zu ermoeglichen,
//                          deren Breite (in Bytes) groesser ist als die Breite
//                          des Primary-Surface.
//                          Wenn dieses Bit beim Zuruecklesen gesetzt ist,
//                          ist der Offscreen tatsaechlich linear, ansonsten
//                          nicht.
//
//
// EDDCAPS_COLORADJUSTYUV_CB : 0=Kontrast/Helligkeit-Werte ohne Wirkung
//                             1=Kontrast/Helligkeit wird gemaess der per
//                               EDDESC_SETCOLORADJUSTMENT gewaehlten Werte
//                               eingestellt.
//
// EDDCAPS_COLORADJUSTYUV_HS : 0=Phase/Saettigungs-Werte ohne Wirkung
//                             1=Phase/Saettigung wird gemaess der per
//                               EDDESC_SETCOLORADJUSTMENT gewaehlten Werte
//                               eingestellt.

// Bedeutung der einzelnen Bits in dwEddCaps0 beim Aufruf von EDDESC_GETCAPS:
// -------------------------------------------------------------------------
//
// EDDCAPS_DITHER  : Der Treiber beherrscht Dithering zur Verbesserung der
//                   Bildqualitaet.
//
// EDDCAPS_FILTERX : Der Treiber beherrscht eine allgemeine Methode zum
//                   Filtern in X-Richtung. Ueber andere Bits
//                   EDDCAPS_FILTERX_xxxxx KANN der Treiber angeben, welche
//                   speziellen Filterfaehigkeiten er kennt.
//
// EDDCAPS_FILTERY : Der Treiber beherrscht eine allgemeine Methode zum
//                   Filtern in Y-Richtung.
//
// EDDCAPS_FILTERX_LIN02420
// EDDCAPS_FILTERX_BILINEAR
// EDDCAPS_FILTERX_LIN12221 : Der Treiber beherrscht diesen Filter in X-
//                            Richtung. Wenn diese Bit gesetzt ist, wird
//                            auch EDDCAPS_FILTERX gesetzt.
//
// EDDCAPS_OFFSCREENINHIBIT : Der Treiber bietet die Moeglichkeit, die
//                            Erzeugung von Offscreen-Surfaces zu
//                            unterbinden.
//
// EDDCAPS_OFFSCREENLINEAR : Der Treiber bietet die Moeglichkeit, lineare
//                           Offscreenverwaltung zu erwuenschen.
//                           Diesen Wunsch kann der Treiber erfuellen, er
//                           muss es aber nicht.
//
// EDDCAPS_COLORADJUSTYUV_CB : Der Treiber bietet die Moeglichkeit Kontrast
//                             und Helligkeit eines YUV-Videos einzustellen.
//
// EDDCAPS_COLORADJUSTYUV_HS : Der Treiber bietet die Moeglichkeit "Hue" und
//                             Saettigung eines YUV-Videos einzustellen.





// ********************************************************
// ********************************************************
// New *_VALUE_* Interface to replace registry accesses for driver data by escapes
// -------------------------------------------------------------------------------

// In structure (Tool -> driver):
// Input Structure to set a registry string
// Output Structure ET_SET_VALUE_RET
typedef struct tagET_SET_VALUE_STRING
{
  ET_QUERY hdr;   // size and subescape SUBESC_ET_SET_VALUE_STRING
                  // dwSize parameter of ET_QUERY holds length of this structure
                  //    i.e. hdr.dwSize >= sizeof(ET_SET_VALUE_STRING)
                  //   ET_MAX_STRING is the minimal length of the string!

  DWORD dwID;     // ID of string to set (ET_VALUE_SZ_...)
  char  szValue[ET_MAX_STRING];

} ET_SET_VALUE_STRING, *PET_SET_VALUE_STRING;

// In structure (Tool -> driver):
// Input Structure to set a registry DWORD
// Output Structure ET_SET_VALUE_RET
typedef struct tagET_SET_VALUE_DWORD
{
  ET_QUERY hdr;     // size and subescape SUBESC_ET_SET_VALUE_DWORD

  DWORD    dwID;    // ID of dword to set (ET_VALUE_DW_...)
  DWORD    dwValue; // value to set

} ET_SET_VALUE_DWORD, *PET_SET_VALUE_DWORD;

// In structure (Tool -> driver):
// Input Structure to set binary data to registry
// Output Structure ET_SET_VALUE_RET
typedef struct tagET_SET_VALUE_BINARY
{
  ET_QUERY hdr;       // size and subescape SUBESC_ET_SET_VALUE_DWORD

  DWORD    dwID;      // ID of dword to set (ET_VALUE_DW_...)
  char     ajData[1]; // array of binary data
  // The true size of this array can be re-calculated from hdr.dwSize

} ET_SET_VALUE_BINARY, *PET_SET_VALUE_BINARY;
// Size of the structure without the data array
#define ET_SET_VALUE_BINARY_HDR_SIZE (sizeof(ET_SET_VALUE_BINARY)-sizeof(DWORD))

// use in struct ET_QUERY_VALUE.dwType
#define ET_VALUE_TYPE_DWORD           0x00  // subesc SUBESC_ET_QUERY_VALUE_DWORD
#define ET_VALUE_TYPE_STRING          0x01  // subesc SUBESC_ET_VALUE_TYPE_STRING
#define ET_VALUE_TYPE_BINARY          0x02  // subesc SUBESC_ET_VALUE_TYPE_BINARY

// Query defaults: Same as ET_VALUE_TYPE_xx but driver allways returns the values default.
// If an ESC-error is returned, the driver doesn't support the default query!
#define ET_VALUE_DEFAULT_FLAG         0x80
#define ET_VALUE_TYPE_DEFAULT_DWORD   (ET_VALUE_DEFAULT_FLAG|ET_VALUE_TYPE_DWORD)   // subesc SUBESC_ET_QUERY_VALUE_DWORD
#define ET_VALUE_TYPE_DEFAULT_STRING  (ET_VALUE_DEFAULT_FLAG|ET_VALUE_TYPE_STRING)  // subesc SUBESC_ET_VALUE_TYPE_STRING

// In structure (Tool -> driver):
// Input Structure to query a registry DWORD
// Output data is returned in ET_VALUE_STRING or ET_VALUE_DWORD
typedef struct tagET_QUERY_VALUE
{
  ET_QUERY hdr;    // size and subescapes SUBESC_ET_QUERY_VALUE_STRING or SUBESC_ET_QUERY_VALUE_DWORD
                   // if outsize for strings > sizeof(ET_VALUE_STRING) the buffer can take longer than the
                   // default strings! Only check if the out buffer is to small to fit the data. The bigger
                   // the better!

  DWORD dwID;      // ID of dword to query (ET_VALUE_DW_..., ET_VALUE_SZ_...)
  DWORD dwType;    // This identifies what kind of data is requested (type of output structure) (ET_VALUE_TYPE_DWORD,...)
                   // Allways assign this value and be sure to set all necessary bits too!
} ET_QUERY_VALUE, *PET_QUERY_VALUE;


// Out structure (Driver -> Tool):
// Output Structure used to return a string from the driver in subesc SUBESC_ET_QUERY_VALUE_STRING
// used by input structure ET_QUERY_VALUE and dwType ET_VALUE_TYPE_STRING
typedef struct tagET_VALUE_STRING
{
  DWORD dwSize;    // Length of this structure (should be the same as ET_QUERY_VALUE's outbuffer size)
  DWORD dwID;      // identifier of string to query (additional and as alignment) (ET_VALUE_SZ_...)
                   // should be the same as in the calling ET_QUERY_VALUE
  DWORD dwFlags;   // return value, ET_VALUE_OK=value set and all is OK, others as ET_SET_VALUE_REBOOT are
                   // error codes or additional information flags
  char  szValue[ET_MAX_STRING]; // zero terminated ASCII/ANSI string (no UNICODE!)

} ET_VALUE_STRING, *PET_VALUE_STRING;


// Out structure (Driver -> Tool):
// Structure used to return a DWORD from the driver in subesc SUBESC_ET_QUERY_VALUE_DWORD
// used by input structure ET_QUERY_VALUE and dwType ET_VALUE_TYPE_DWORD
typedef struct tagET_VALUE_DWORD
{
  DWORD dwSize;    // Length of this structure, sizeof(ET_VALUE_DWORD)
                   // (should be the same as ET_QUERY_VALUE's outbuffer size)

  DWORD dwID;      // identifier of queried dword to query (additional and as alignment) (ET_VALUE_DW_...)
                   // should be the same as in the calling ET_QUERY_VALUE
  DWORD dwFlags;   // return value, ET_VALUE_OK=value set and all is OK, others as ET_SET_VALUE_REBOOT are
                   // error codes or additional information flags
  DWORD dwValue;   // return value

} ET_VALUE_DWORD, *PET_VALUE_DWORD;

// Out structure (Driver -> Tool):
// Structure used to return binary data from the driver in subesc
// SUBESC_ET_QUERY_VALUE_BINARY used by input structure ET_QUERY_VALUE
// and dwType ET_VALUE_TYPE_BINARY
typedef struct tagET_VALUE_BINARY
{
  DWORD dwSize;    // Length of this structure, at least ET_QUERY_VALUE_BINARY_HDR_SIZE
                   // (should be the same as ET_QUERY_VALUE's outbuffer size)
  DWORD dwID;      // identifier of binary to query (additional and as alignment) (ET_VALUE_DW_...)
                   // should be the same as in the calling ET_QUERY_VALUE
  DWORD dwFlags;   // return value,
                   // ET_VALUE_OK=value set and all is OK,
                   // ET_VALUE_ERROR_SIZE=structure is too short for all the data,
                   //                     see dwSizeData for the required size
                   // others are error codes or additional information flags
  DWORD dwSizeData; // size of binary data, especially the required size, when
                    // dwFlags return ET_VALUE_ERROR_SIZE

  char  ajData[1]; // dwSizeData bytes of data

} ET_VALUE_BINARY, *PET_VALUE_BINARY;
// Size of the structure without the data array
#define ET_QUERY_VALUE_BINARY_HDR_SIZE (sizeof(ET_VALUE_BINARY)-sizeof(DWORD))


// Flags used in ET_SET_VALUE_RET or ET_VALUE_XXX as return values
//   bit 31 (higest bit) == 0: function was successfull and additional information for values != 0
//   bit 31 (higest bit) == 1: error
#define IsError(Value)      ((Value & 0x80000000)!=0)
#define IsOK(Value)         ((Value & 0x80000000)==0)


//  ET_VALUE_xx return codes used in dwFlags are 32 bit values layed out as follows:

//   3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1              Bit No
//   1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
//  +---+-----------------------------------------------------------+
//  |0 r|                                       Bitfield            | success
//  +---+-----------------------------------------------------------+
//  |1 r|                                       ErrorCode           | error
//  +---+-----------------------------------------------------------+
//  r = reserved
//                            bitfield
#define ET_VALUE_OK         0x00000000 // Value function is successfull
#define ET_VALUE_REBOOT     0x00000001 // a reboot is necessary to acivate after value set
#define ET_VALUE_DEFAULT    0x00000002 // Value function had problems and returned defaults
#define ET_VALUE_BLOCKED    0x00000004 // Value is blocked by running application and not set in driver! (e.g. ask user to close application)

//                          Bit   Code
#define ET_VALUE_ERROR		  0x80000000 // application reserved value for ESCAPE failed (not used in driver!)
#define ET_VALUE_UNKNOWN    0x80000001 // Value to get/set is unknown or not supported (e.g. grey button)
#define ET_VALUE_ERROR_SIZE 0x80000002 // returnbuffer is smaller than the value to get

// Out structure (Driver -> Tool):
// structure passed back to caller
typedef struct tagET_SET_VALUE_RET
{
  DWORD dwSize;    // Length of this structure, sizeof(ET_SET_VALUE_RET)

  DWORD dwID;      // identifier of set value (additional and as alignment) (ET_VALUE_DW_...)

  DWORD dwFlags;   // return value, ET_VALUE_OK=value set and all is OK, others as ET_SET_VALUE_REBOOT are
                   // error codes or additional information flags

  DWORD dwAlign;   // unused
} ET_SET_VALUE_RET, *PET_SET_VALUE_RET;


// ********************************************************
// query/set values identifier:
//   3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1              Bit No
//   1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
//  +-------+-------+-----------------------------------------------+
//  |o o o o|r r r r|                                          code |
//  +-------+-------+-----------------------------------------------+
//
//  o = bitfield defining OS dependencies
//    0       = no specific OS
//    0x1     = Win9x
//    0x2     = Win NT
//    0x4,0x8 = unused
//  r = bitfield reserved for driver internal stuff.
//    This field must be 0 in all IDs-codes called via ExtEscape!
//
//    Use this code to check Esc-IDs validity:
//
//    DrvEscape (...)
//    {
//      // check if the caller gives us a valid dwID,
//      // All reserved bits have to be 0!
//      ASSERT( 0==(pEtValue->dwID & ET_VALUE_OS_RESERVED) ); // check the tool which called!
//      ...
//    }
//
//  code = number of identifer, no bitfield.
//    valid range: 0x000000 - 0xffffff (3 Byte)
//    New ID code increments by one.
//
//  Resulting ranges:
//    0x00000000 - 0x00ffffff basic values, common to all operating systems
//    0x10000000 - 0x10ffffff to be defined by Win95
//    0x20000000 - 0x20ffffff to be defined by NT (NTeam)
//    0x40000000 - 0x40ffffff unused
//    0x80000000 - 0x80ffffff unused
// Naming: ET_VALUE_DW_xxxx, read: ELSA tools value dword
//         ET_VALUE_SZ_xxxx, read: ELSA tools value zero terminated string (single byte char)
//

#define ET_VALUE_OS_WIN9x                                   0x10000000 // Bit defining IDs known by Windows 9x driver
#define ET_VALUE_OS_WINNT                                   0x20000000 // Bit defining IDs known by Windows NT driver
#define ET_VALUE_OS_unused0                                 0x40000000 //
#define ET_VALUE_OS_unused1                                 0x80000000 //

#define ET_VALUE_OS_RESERVED                                0x0F000000 // Bits that are reserved for the driver internaly

// Windows 9x
//
#define ET_VALUE_DW_D3DOGL_MCLK                             ( ET_VALUE_OS_WIN9x | 0x00CA0001 )
#define ET_VALUE_DW_D3DOGL_NVCLK                            ( ET_VALUE_OS_WIN9x | 0x00CA0002 )
#define ET_VALUE_DW_D3DOGL_OVERCLOCK_ENABLE                 ( ET_VALUE_OS_WIN9x | 0x00CA0003 )
#define ET_VALUE_DW_D3DOGL_OVERCLOCK_CRASHSTATUS            ( ET_VALUE_OS_WIN9x | 0x00CA0004 )
#define ET_VALUE_DW_D3DOGL_DEFAULT_MCLK                     ( ET_VALUE_OS_WIN9x | 0x00CA0005 )
#define ET_VALUE_DW_D3DOGL_DEFAULT_NVCLK                    ( ET_VALUE_OS_WIN9x | 0x00CA0006 )

// Windows NT
//
// Basic/system 0x20000000-0x200000ff
//#define ET_VALUE_SZ_IMAGEPATH                               0x20000000
//#define ET_VALUE_SZ_INSTALLEDDISPLAYDRIVERS                 0x20000001

#define ET_VALUE_DW_GDI_DESKTOPONMAXIMIZE                   0x20000050 // DesktopOnMaximize
#define ET_VALUE_DW_GDI_ENABLEDEVICEBITMAPS                 0x20000051 // EnableDeviceBitmaps
#define ET_VALUE_DW_GDI_ENABLEPCIDISCONNECT                 0x20000052 // PCIDisconnect
#define ET_VALUE_DW_GDI_EXPORTONLYDOUBLEBUFFERMODES         0x20000053 // ExportOnlyDoubleBufferModes
#define ET_VALUE_DW_GDI_NTEAMPRIVATEKEY                     0x20000054
#define ET_VALUE_DW_GDI_P6ENABLEUSWC                        0x20000055 // DRV_PPRO_ENABLE_WCB
#define ET_VALUE_DW_GDI_REVERSESCREENORDER                  0x20000056 // ReverseScreenOrder
#define ET_VALUE_DW_GDI_USEGETACCESSRANGES                  0x20000057 // UseGetAccessRanges
#define ET_VALUE_DW_GDI_USELCDPANEL                         0x20000058 // UseLCDPanel
#define ET_VALUE_DW_GDI_VERTICALSCREENORDER                 0x20000059 // VerticalScreenOrder
#define ET_VALUE_DW_GDI_WAITFORFIFOS                        0x2000005a // EngineSynchronization
#define ET_VALUE_DW_GDI_DEVICEORIGINX                       0x2000005b
#define ET_VALUE_DW_GDI_DEVICEORIGINY                       0x2000005c
#define ET_VALUE_DW_GDI_DEVICESIZEX                         0x2000005d
#define ET_VALUE_DW_GDI_DEVICESIZEY                         0x2000005e
#define ET_VALUE_DW_GDI_VISUALORIGINX                       0x2000005f
#define ET_VALUE_DW_GDI_VISUALORIGINY                       0x20000060
#define ET_VALUE_DW_GDI_VISUALSIZEX                         0x20000061
#define ET_VALUE_DW_GDI_VISUALSIZEY                         0x20000062
#define ET_VALUE_DW_GDI_DELLXXL                             0x20000063 // DELLXXL
#define ET_VALUE_DW_GDI_PERMEDIACLOCKSPEED                  0x20000064 // PermediaClockSpeed
#define ET_VALUE_DW_GDI_GLINTCLOCKSPEED                     0x20000065 // GlintClockSpeed
#define ET_VALUE_DW_GDI_GLINTGAMMACLOCKSPEED                0x20000066 // GlintGammaClockSpeed
#define ET_VALUE_DW_GDI_GLINTDELTACLOCKSPEED                0x20000067 // GlintDeltaClockSpeed
#define ET_VALUE_DW_GDI_HWLINES                             0x20000068 // TNT: interface to enable nonconformant but faster lines
#define ET_VALUE_DW_GDI_FIFOEXTRA_P2                        0x20000069 // GDI.FifoExtra
#define ET_VALUE_DW_GDI_FIFOEXTRA                           0x2000006a // GDI.FifoExtra
#define ET_VALUE_DW_GDI_FIFOUSAGE                           0x2000006b // GDI.FifoUsage
#define ET_VALUE_DW_GDI_EXPORTMULTIBOARDMODES               0x2000006c // ExportMultiboardModes
#define ET_VALUE_DW_GDI_SURFACESONBANKBOUNDARIES            0x2000006d // boolean
#define ET_VALUE_DW_GDI_DMABUFFERSIZE                       0x2000006e // ulong ( > 8kB)
#define ET_VALUE_DW_GDI_DMAPADDING                          0x2000006f // ulong (ET_VALUE_DW_GDI_DMAPADDING < ET_VALUE_DW_GDI_DMABUFFERSIZE)
#define ET_VALUE_DW_GDI_BOARD_PATTERN                       0x20000070 // binary: defines boards used for the mode (00 01 02,...)
#define ET_VALUE_DW_GDI_AGP_DMA                             0x20000071 // bool: 1=use AGP for display driver DMA, 0=don't use AGP
#define ET_VALUE_DW_GDI_FRAMEBUFFER_DMA                     0x20000072 // bool: 1=use framebuffer DMA for display driver

#define ET_VALUE_DW_MAP_FRAMEBUFFER                         0x20000090 // Map.FrameBuffer
#define ET_VALUE_DW_MAP_GLINTMMIO                           0x20000091 // Map.GLintMmio
#define ET_VALUE_DW_MAP_DELTAMMIO                           0x20000092 // Map.DeltaMmio
#define ET_VALUE_DW_MAP_LOCALBUFFER                         0x20000093 // Map.LocalBuffer

#define ET_VALUE_DW_PPRO_ENABLEWCB                          0x20000095 // PPro.EnableWCB
#define ET_VALUE_DW_ALPHA_MIATA                             0x20000096 // Alpha.Miata
#define ET_VALUE_DW_PRINTANDCHECKRENDERSTATE                0x20000097 //

#define ET_VALUE_BIN_GDI_GAMMARAMP                          0x200000A0 // Gammatable in the same format as in GDI::SetGammaRamp
#define ET_VALUE_BIN_OEM_MODELIST                           0x200000A1 // mode list override string: "bpp#1 width#1 height#1 refresh1#1 refresh2#1... 0 bpp#2 width#2 height#2 refresh1#2 refresh2#2... 0";

// ICDInterface.* 0x20000100-0x200001ff
#define ET_VALUE_DW_ICDINTERFACE_DISABLE                    0x20000100 // ICDInterface.Disable
//#define ET_VALUE_DW_ICDINTERFACE_DOUBLEBUFFER               0x20000101
//#define ET_VALUE_DW_ICDINTERFACE_MAXDOUBLEBUFFER            0x20000102
#define ET_VALUE_DW_ICDINTERFACE_NUMBEROFDISPLAYBUFFERS     0x20000101 // ICDInterface.NumberOfDisplayBuffers
#define ET_VALUE_DW_ICDINTERFACE_MAXNUMBEROFDISPLAYBUFFERS  0x20000102 // ICDInterface.MaxNumberOfDisplayBuffers
#define ET_VALUE_DW_ICDINTERFACE_SUPPORTSINGLEBUFFEREDGDI   0x20000103 // ICDInterface.SupportSingleBufferedGDI
#define ET_VALUE_DW_ICDINTERFACE_SUPPORTDOUBLEBUFFEREDGDI   0x20000104 // ICDInterface.SupportDoubleBufferedGDI
#define ET_VALUE_DW_ICDINTERFACE_EXPORTALPHA                0x20000105 // ICDInterface.ExportAlpha
#define ET_VALUE_DW_ICDINTERFACE_SUPPORTOVERLAYPLANES       0x20000106 // ICDInterface.SupportOverlayPlanes
#define ET_VALUE_DW_ICDINTERFACE_VBLANKWAIT                 0x20000107 // ICDInterface.VBlankWait
#define ET_VALUE_DW_ICDINTERFACE_PAGEFLIPPING               0x20000108 // ICDInterface.PageFlipping
#define ET_VALUE_DW_ICDINTERFACE_LBWIDTH                    0x20000109 // ICDInterface.LBWidth
#define ET_VALUE_DW_ICDINTERFACE_SIZEOFBUFFER               0x2000010A // ICDInterface.SizeOfBuffer

#define ET_VALUE_DW_ICDINTERFACE_DUALTXLBMOVES              0x2000010B // ICDInterface.DualTXLBMoves
#define ET_VALUE_DW_ICDINTERFACE_EXTENDEDPAGEFLIP           0x2000010C // ICDInterface.ExtendedPageFlip
#define ET_VALUE_DW_ICDINTERFACE_FNSENDDATATST              0x2000010D // ICDInterface.FNSendDataTst
#define ET_VALUE_DW_ICDINTERFACE_FULLSCNTOPBORDER           0x2000010E // DoubleBuffer.FullScnTopBorder
#define ET_VALUE_DW_ICDINTERFACE_LBSIZE                     0x2000010F // ICDInterface.LBSize
#define ET_VALUE_DW_ICDINTERFACE_P2ENABLEBYPASSDMA          0x20000110 // ICDInterface.P2EnableBypassDma
#define ET_VALUE_DW_ICDINTERFACE_P2ENABLEBYPASSPATCH        0x20000111 // ICDInterface.P2EnableBypassPatch
#define ET_VALUE_DW_ICDINTERFACE_PAGEFLIPFORCESYNC          0x20000112 // ICDInterface.PageFlipForceSync
#define ET_VALUE_DW_ICDINTERFACE_TEXTURESIZE                0x20000113 // ICDInterface.MaxTextureSize
#define ET_VALUE_DW_ICDINTERFACE_USESOFTWAREWRITEMASK       0x20000114 // ICDInterface.UseSoftwareWriteMask
#define ET_VALUE_DW_ICDINTERFACE_USESINGLETX                0x20000115 // ICDInterface.UseSingleTX

#define ET_VALUE_DW_ICDINTERFACE_EXPORTCOLORINDEX           0x20000116
#define ET_VALUE_DW_ICDINTERFACE_OPENGLICDNAME              0x20000117
#define ET_VALUE_DW_ICDINTERFACE_OPENGLICDELSAOGLNAME       0x20000118
#define ET_VALUE_DW_ICDINTERFACE_PFDREDUCTION               0x20000119 // ICDInterface.PFDReduction
#define ET_VALUE_DW_ICDINTERFACE_STEREOFORCEBUFFERS         0x2000011A // ICDInterface.StereoForceBuffers
#define ET_VALUE_DW_ICDINTERFACE_STEREOLEFTEYETOP           0x2000011B // ICDInterface.StereoLeftEyeTop
#define ET_VALUE_DW_ICDINTERFACE_STEREOSUPPORT              0x2000011C // ICDInterface.StereoSupport
#define ET_VALUE_DW_ICDINTERFACE_TEXTURESMARTCACHE          0x2000011D // ICDInterface.TextureSmartCache
#define ET_VALUE_DW_ICDINTERFACE_TEXTURETRANSIENTONLY       0x2000011E // ICDInterface.TextureTransientOnly

#define ET_VALUE_DW_ICDINTERFACE_MAXTEXTURESIZE             0x2000011F // ICDInterface.MaxTextureSize
#define ET_VALUE_DW_ICDINTERFACE_PFD_TYPE_COLORINDEX        0x20000120 // ICDInterface.PFD_TYPE_COLORINDEX
#define ET_VALUE_DW_ICDINTERFACE_LBPATCHED                  0x20000121 // ICDInterface.LBPatched
#define ET_VALUE_DW_ICDINTERFACE_DUALGLINTWINDOWMOVES       0x20000122 // ICDInterface.DualGlintWindowMoves
#define ET_VALUE_DW_ICDINTERFACE_FORCEGDIBROADCASTINGINOGLVIEWS 0x20000123 // ICDInterface.ForceGdiBroadCastingInOglViews
#define ET_VALUE_DW_ICDINTERFACE_PFD_STEREO                 0x20000124 // ICDInterface.PFD_STEREO
#define ET_VALUE_DW_ICDINTERFACE_PFD_SWAP_LAYER_BUFFERS     0x20000125 // ICDInterface.PFD_SWAP_LAYER_BUFFERS
#define ET_VALUE_DW_ICDINTERFACE_PFD_SUPPORT_GDI            0x20000126 // ICDInterface.PFD_SUPPORT_GDI

#define ET_VALUE_DW_ICDINTERFACE_FORCE_STENCIL              0x20000127 // ICDInterface.ForceStencil
#define ET_VALUE_DW_ICDINTERFACE_FORCE_MORETHAN16BITZ       0x20000128 // 0=default, else force to this value!
#define ET_VALUE_DW_ICDINTERFACE_TEXTURE_REDUCE_FACTOR      0x20000129 // ICDInterface.TextureReduceFactor
#define ET_VALUE_DW_ICDINTERFACE_PFD_SWAP_COPY              0x2000012A // ICDInterface.PFD_SWAP_COPY
#define ET_VALUE_DW_ICDINTERFACE_PFD_SWAP_EXCHANGE          0x2000012B // ICDInterface.PFD_SWAP_EXCHANGE

// GLintDMA.* 0x20000200-0x2000024f
#define ET_VALUE_DW_GLINTDMA_NUMBEROFBUFFERS                0x20000200 // GLintDMA.NumberOfBuffers
#define ET_VALUE_DW_GLINTDMA_NUMBEROFSUBBUFFERS             0x20000201 // GLintDMA.NumberOfSubBuffers
#define ET_VALUE_DW_GLINTDMA_SIZEOFBUFFERS                  0x20000202 // GLintDMA.SizeOfBuffer
#define ET_VALUE_DW_GLINTDMA_CACHEDBUFFERS                  0x20000203 // GLintDMA.CachedBuffers

#define ET_VALUE_DW_GLINTDMA_USEAGP                         0x20000204 // GLintDMA.UseAGP
#define ET_VALUE_DW_GLINTDMA_SUPPORTAGPONBX                 0x20000205 // GLintDMA.SupportAGPonBX

#define ET_VALUE_DW_AGP_ENABLE                              ET_VALUE_DW_GLINTDMA_USEAGP // AGP.Enable:  0, 1
#define ET_VALUE_DW_AGP_RATE                                0x20000206                  // AGP.Rate:    1, 2, 4
#define ET_VALUE_DW_AGP_SIDEBANDADDRESSING                  0x20000207                  // AGP.SBA:     0, 1
#define ET_VALUE_DW_AGP_REQUEST_DEPTH                       0x20000208                  // AGP.RQDepth: 1...255
#define ET_VALUE_DW_AGP_FAST_WRITES                         0x20000209                  // AGP.FW:      0, 1

#define ET_VALUE_DW_DMAWAITFORPOLL                          0x2000020A // DMAWaitForPoll

#define ET_VALUE_DW_AGP_CACHING                             0x2000020B // 0=No, 1=Yes (as used in AgpReservePhysical)
#define ET_VALUE_DW_AGP_MSWORKAROUND                        0x2000020C // 0=No, 1=Yes (to enable workaround for bug in MS W2K videoport.sys AGP mapping)

#define ET_VALUE_DW_DMA_7DUMMYREADS                         0x2000020D // 0=No, 1=Yes (7 dummy reads in dma buffer to flush writecombined caches)
#define ET_VALUE_DW_DMA_DUMMYREADUC                         0x2000020E // 0=No, 1=Yes (Perform a dummy read to the UC system memory but not WC to flush writecombined caches)

#define ET_VALUE_DW_DMA_FORCEIOFLUSH                        0x2000020F // 0=No, 1=Yes (Perform inp and outp to flush io buffers)

// GLintIRQ.* 0x20000250-0x200002ff
#define ET_VALUE_DW_GLINTIRQ_ENABLE                         0x20000250 // GLintIRQ.Enable

// OpenGL.* 0x20000300-0x200003ff
#define ET_VALUE_DW_OPENGL_USEHIQUALITYTEXTURE              0x20000300
#define ET_VALUE_DW_OPENGL_UNIXCONFORM                      0x20000301
#define ET_VALUE_DW_OPENGL_DOUBLEWRITE                      0x20000302
#define ET_VALUE_DW_OPENGL_DISABLEFASTCLEAR                 0x20000303 // OpenGL.DisableFastClear
#define ET_VALUE_DW_OPENGL_DISABLEMIPMAPS                   0x20000304
#define ET_VALUE_DW_OPENGL_TEXTURECOMPRESSION               0x20000305
#define ET_VALUE_DW_OPENGL_ENABLEP2ANTIALIAS                0x20000306
#define ET_VALUE_DW_OPENGL_SUPPORTOPENGLVERSION11           0x20000307
#define ET_VALUE_DW_OPENGL_FORCETRUECOLOR16BIT              0x20000308 // OpenGL.ForceTrueColorTexturesTo16bit
#define ET_VALUE_DW_OPENGL_SUPPORTSOFTIMAGE                 0x20000309 // OpenGL.SupportSoftimage
#define ET_VALUE_DW_OPENGL_SUPPORTSOFTIMAGE_351             0x2000030A // OpenGL.SupportSoftimage351

#define ET_VALUE_DW_OPENGL_DRAWLINEENDS                     0x2000030B
#define ET_VALUE_DW_OPENGL_ENABLEFIFOACCESS                 0x2000030C
#define ET_VALUE_DW_OPENGL_DISABLEDELTA                     0x2000030D
#define ET_VALUE_DW_OPENGL_MXDISABLEMIPMAPS                 0x2000030E
#define ET_VALUE_DW_OPENGL_FORCENNTEXFILTER                 0x2000030F
#define ET_VALUE_DW_OPENGL_DISABLEDMAFLUSHES                0x20000310
#define ET_VALUE_DW_OPENGL_DISABLEGXCULL                    0x20000311
#define ET_VALUE_DW_OPENGL_INVERTGXCFORMAT                  0x20000312
#define ET_VALUE_DW_OPENGL_PERSPECTIVECORRECTION            0x20000313
#define ET_VALUE_DW_OPENGL_REALLOCBLOCKSIZE                 0x20000314
#define ET_VALUE_DW_OPENGL_DISABLEDLISTTEXTURES             0x20000315
#define ET_VALUE_DW_OPENGL_DELTANODRAW                      0x20000316
#define ET_VALUE_DW_OPENGL_ENABLEBYPASSPATCH                0x20000317
#define ET_VALUE_DW_OPENGL_ENABLEBYPASSDMA                  0x20000318
#define ET_VALUE_DW_OPENGL_FORCENESTEDDMA                   0x20000319
#define ET_VALUE_DW_OPENGL_DISABLETRIANGLEPACKET            0x2000031A
#define ET_VALUE_DW_OPENGL_PRESERVETRUECOLORTEXTURES        0x2000031B // OpenGL.PreserveTrueColorTextures
#define ET_VALUE_DW_OPENGL_DUALTXPRO                        0x2000031C
#define ET_VALUE_DW_OPENGL_VERTEXCOOPTMAX                   0x2000031D
#define ET_VALUE_DW_OPENGL_NVVVOPTIMIZATION                 0x2000031E
#define ET_VALUE_DW_OPENGL_MIPMAPCONTROL                    0x2000031F
#define ET_VALUE_DW_OPENGL_DISABLETEXTUREPATCHING           0x20000320 // OpenGL.DisableTexturePatching

#define ET_VALUE_DW_OPENGL_USEGIDCLIPPING                   0x20000321 // OpenGL.UseGidClipping
#define ET_VALUE_DW_OPENGL_PLACEMIPMAPSINALTERNATEBANKS     0x20000322 // OpenGL.PlaceMipMapsInAlternateBanks
#define ET_VALUE_DW_OPENGL_DISABLETEXTUREMANAGERLRU         0x20000323 // OpenGL.DisableTextureManagerLRU
#define ET_VALUE_DW_OPENGL_SUPPORTPRODESIGNER               0x20000324 // OpenGL.SupportProDesigner

#define ET_VALUE_DW_OPENGL_DMAMAXCOUNT                      0x20000325 // TNT: OpenGL.DMAMaxCount (size of DMA buffer)
#define ET_VALUE_DW_OPENGL_DMAMINPUSHCOUNT                  0x20000326 // TNT: OpenGL.DMAMinPushCount (fill grade of buffer to force flush)
#define ET_VALUE_DW_OPENGL_MAXTEXTURESIZE                   0x20000327
#define ET_VALUE_DW_OPENGL_MINVIDMEMTEXWIDTH                0x20000328
#define ET_VALUE_DW_OPENGL_MAXTEXHEAPSIZE                   0x20000329
#define ET_VALUE_DW_OPENGL_LIGHTINGANALYSIS                 0x2000032A  // BITFIELD
#define ET_VALUE_DW_OPENGL_LIGHTPICKINGOVERRIDE             0x2000032B  // BITFIELD
#define ET_VALUE_DW_OPENGL_STATISTICS                       0x2000032C  // BITFIELD
#define ET_VALUE_DW_OPENGL_BENCHING                         0x2000032D  // OpenGL.Benching
#define ET_VALUE_DW_OPENGL_USEKATMAI                        0x2000032E // BOOLEAN
#define ET_VALUE_DW_OPENGL_VERTEXCACHESIZE                  0x2000032F // DWORD
#define ET_VALUE_DW_OPENGL_PIXELTUBE                        0x20000330 // DWORD

// OpenGL AGP settings
#define ET_VALUE_DW_OPENGL_AGP_DMA                          0x20000331  // OpenGL.AGP.DMA
#define ET_VALUE_DW_OPENGL_AGP_TEXTURES                     0x20000332  // OpenGL.AGP.Textures
#define ET_VALUE_DW_OPENGL_FORCE_AGP_TEXTURES               0x20000333  // OpenGL.ForceAGPTextures

#define ET_VALUE_DW_OPENGL_FORCE_CLIPPING                   0x20000334  // OpenGL.ForceClipping
#define ET_VALUE_DW_OPENGL_ERRORLOG                         0x20000335  // OpenGL.ErrorLog
#define ET_VALUE_DW_OPENGL_DUMPLOG                          0x20000336  // OpenGL.DumpLog
#define ET_VALUE_DW_OPENGL_MCAD_MODE                        0x20000337  // OpenGL.MCAD
#define ET_VALUE_DW_OPENGL_SUPPORT_P2_CI4TEXTURES           0x20000338  // OpenGL.SupportP2CI4Textures
#define ET_VALUE_DW_OPENGL_FORCE_SINGLEBUFFERED             0x20000339  // BOOLEAN
#define ET_VALUE_DW_OPENGL_ALIGNED_SURFACES                 0x2000033A  // ULONG
#define ET_VALUE_DW_OPENGL_FRAMEBUFFER_DMA                  0x2000033B  // OpenGL.FramebufferDMA
#define ET_VALUE_DW_OPENGL_AUTODESKEXTENSIONS               0x2000033C  // Bitfield enabling Autocad 2000 opengl extensions
#define ET_VALUE_DW_OPENGL_USESENDDATAESCAPE                0x2000033D  // ULONG (0:ICD accesses HW, 1:automatic (ICD or Escape), 2: ICD uses Escape to fire DMA), FNicklis 07.05.1999
#define ET_VALUE_DW_OPENGL_DISABLE_STENCIL                  0x2000033E  // BOOLEAN (0: default, export stencil, 1: remove stencil formats), FNicklis 11.06.199
#define ET_VALUE_DW_OPENGL_DISABLE_ALPHA                    0x2000033F  // BOOLEAN (0: default, export alpha,   1: remove alpha formats), FNicklis 11.06.199
#define ET_VALUE_DW_OPENGL_PREFER_AGP_TEXTURES              0x20000340  // BOOL ('OpenGL.PreferAGPTextures, 0=default)
#define ET_VALUE_DW_OPENGL_DMAMINPUSHCOUNT_SENDDATA         0x20000341  // TNT: OpenGL.DMAMinPushCountSendData (fill grade of buffer to force flush)
#define ET_VALUE_DW_OPENGL_MULTIBOARD                       0x20000342  // BOOLEAN (1:default, allow OpenGL; 0:OpenGl not in mulitboard) OpenGL.MultiBoard
#define ET_VALUE_DW_OPENGL_UNIGRAPHICS_TEXTURE_FIX          0x20000343  // Enable bug fix for Unigraphics 15, 16 (border color for texture)
#define ET_VALUE_DW_ICDINTERFACE_STEREOWAITCONCEPT          0x20000344  // ULONG  (0:default do not wait 1:allways use DPCs 2:do wait until VBlank occured
#define ET_VALUE_DW_ICDINTERFACE_STEREOWAITLINESBEFORE      0x20000345  // ULONG  ( default: 2 ) amount of rasterlines before VBlank until to loop and wait for VBlank 
#define ET_VALUE_DW_ICDINTERFACE_STEREOWAITLINESAFTER       0x20000346  // ULONG  ( default: 1 ) amount of rasterlines after VBlank when to trigger stereo glasses + offsets 

                                                          //0x20000347  ...

// Heidi/Kinetix.* 0x20000400-0x200004ff
#define ET_VALUE_DW_HEIDI_USEEXCLUSIVE                      0x20000400
#define ET_VALUE_DW_HEIDI_USELINEARTEXTUREFILTER            0x20000401
#define ET_VALUE_DW_KTX_BUFFERREGIONS                       0x20000402 // e.g. KTX.BufferRegions
#define ET_VALUE_DW_KTX_SWAPHINTS                           0x20000403 // e.g. KTX.SwapHints
#define ET_VALUE_DW_KTX_ELSABUFFERREGIONS                   0x20000404 // e.g. KTX.ElsaBufferRegions
#define ET_VALUE_DW_KTX_BUFFER_REGIONS_FULL                 0x20000405 // e.g. KTX.BufferRegionsFull
#define ET_VALUE_DW_KTX_BUFFER_REGIONS_FIX                  0x20000406 // e.g. KTX.BufferRegionsFix

// HardwareInformation.* 0x20000500-0x200005ff
#define ET_VALUE_SZ_HARDWAREINFORMATION_ADAPTERSTRING       0x20000500
#define ET_VALUE_SZ_HARDWAREINFORMATION_CHIPTYPE            0x20000501
#define ET_VALUE_SZ_HARDWAREINFORMATION_DACTYPE             0x20000502
#define ET_VALUE_DW_HARDWAREINFORMATION_MEMORYSIZE          0x20000503
#define ET_VALUE_SZ_BOARDNAME                               0x20000504
#define ET_VALUE_SZ_DESCRIPTION                             0x20000505
#define ET_VALUE_SZ_SERNUM                                  0x20000506
#define ET_VALUE_SZ_HARDWAREINFORMATION_BIOSSTRING          0x20000507

// DDraw ids    0x20000600-0x200006ff
#define ET_VALUE_DW_DDRAWMULTIBOARDPRIMARY                  0x20000600 // DirectDraw.MultiboardPrimary
#define ET_VALUE_DW_DDRAWENABLEVIDEOIO                      0x20000601 // EnableVideoIO
#define ET_VALUE_DW_DDRAWMULTIBOARDHW_ENABLE                0x20000602 // DirectDraw.MultiboardEnabled
#define ET_VALUE_DW_DDRAWSUPPORT_OVERLAYSHRINK              0x20000603 // DirectDraw.SupportOverlayshrink

// LCD Panel    0x20000700-0x200007ff
#define ET_VALUE_DW_LCDPANELBORDERLEFTRIGHT                 0x20000700 // DUO.PanningBorderLeftRight
#define ET_VALUE_DW_LCDPANELBORDERTOPBOTTOM                 0x20000701 // DUO.PanningBorderTopBottom
#define ET_VALUE_DW_LCDPANELSTEPLEFTRIGHT                   0x20000702 // DUO.PanningStepLeftRight
#define ET_VALUE_DW_LCDPANELSTEPTOPBOTTOM                   0x20000703 // DUO.PanningStepTopBottom
#define ET_VALUE_DW_LCDPANELPANSTARTXRES                    0x20000704 // DUO.PanningStartXResolution
#define ET_VALUE_DW_LCDPANELSTRETCHXRES                     0x20000705 // DUO.LcdExpand
#define ET_VALUE_DW_LCDPANELSINGLEMODE                      0x20000706 // DUO.SingleControllerMode
#define ET_VALUE_DW_LCDPANELENABLECRT                       0x20000707 // DUO.CrtEnable
#define ET_VALUE_DW_LCDPANELENABLELCD                       0x20000708 // DUO.LcdEnable
#define ET_VALUE_DW_LCDPANELENABLETV                        0x20000709 // DUO.TvEnable
#define ET_VALUE_DW_LCDPANELTRUECOLORDITHER                 0x2000070A // DUO.LcdTruecolorDither
#define ET_VALUE_DW_LCDPANELTVFLICKERFILTER                 0x2000070B // DUO.TvFlickerFilter

// ********************************************************
// ********************************************************
// NV10 / NV 15 boards
// -----------------------------
// #define SUBESC_ET_GET_OUTPUT_DEVICE_INFO    0x00000310
// #define SUBESC_ET_SET_OUTPUT_DEVICE         0x00000311

#define PANEL_RESOLUTION_STRETCHED	0x0001
#define PANEL_RESOLUTION_CENTERED	0x0002
#define PANEL_RESOLUTION_NATIVE	0x0004

#define DEVICE_TYPE_INVALID   0x0000
#define DEVICE_TYPE_CRT       0x0001
#define DEVICE_TYPE_LCD       0x0002
#define DEVICE_TYPE_TV        0x0004

typedef struct tagET_COMMON_OUTPUT_DEVICE_INFO
{
  DWORD   dwDeviceType;         // holds the type of the device (CRT/LCD/TV)
  DWORD   dwDeviceConnected;    // is this device connected to graphics board
  DWORD   dwDeviceOn;           // is the device switched on
  DWORD   dwHorSize;            // horizontal size of the device in pixel
  DWORD   dwVertSize;           // vertical size of the device in pixel
  DWORD   dwDisplayMode;        // display mode of device ( stretched, native, centered )
  DWORD   dwSupportedDisplayModes;   // supported display modes of device ( stretched, native, centered )
}ET_COMMON_OUTPUT_DEVICE_INFO, *PET_COMMON_OUTPUT_DEVICE_INFO;

typedef struct tagET_OUTPUT_DEVICE_INFO
{
  DWORD   dwSize;                   // size of structure
  DWORD   dwDevicesSupported;       // bitfield containing type of supported devices
  DWORD   dwSimultaniousDevices;      // bitfield containing type of devices supported at the same time
  ET_COMMON_OUTPUT_DEVICE_INFO  crt;  // information on the CRT
  ET_COMMON_OUTPUT_DEVICE_INFO  lcd;  // information on the LCD
  ET_COMMON_OUTPUT_DEVICE_INFO  tv;   // information on the tv set
  DWORD   dwNumAdditionalDevices;   // number of additional ET_COMMON_OUTPUT_DEVICE_INFO structures needed
  ET_COMMON_OUTPUT_DEVICE_INFO  *pAdditionalInformation;
} ET_OUTPUT_DEVICE_INFO, *PET_OUTPUT_DEVICE_INFO;

// Structure to set output device
typedef struct tagET_SET_OUTPUT_DEVICE
{
  ET_QUERY                    hdr;

  DWORD                       dwParam1;             //1 saves to registry, 0 for testing
  ET_OUTPUT_DEVICE_INFO       deviceInfo;
} ET_SET_OUTPUT_DEVICE, *PET_SET_OUTPUT_DEVICE;

//Structure to retrieve complete information on the output devices
typedef struct tagET_GET_OUTPUT_DEVICE_INFO
{
  DWORD                       dwSize;
  ET_OUTPUT_DEVICE_INFO       deviceInfo;
} ET_GET_OUTPUT_DEVICE_INFO,*PET_GET_OUTPUT_DEVICE_INFO;


// ********************************************************
// ********************************************************
// LCD panel with WINNER 1000DUO
// -----------------------------

// Common information on actual PANEL settings (used in Get and Set info)
typedef struct tagET_COMMON_PANEL_INFO
{
  LONG        lPanStepLR;           //Panning stepsize right/left panning
  LONG        lPanStepTB;           //Panning stepsize up/down panning
  LONG        lPanBorderLR;         //Area where panning begins before cursor hits panel end left/right
  LONG        lPanBorderTB;         //Area where panning begins before cursor hits panel end top/bottom
  LONG        lPanStartResX;        //We start panning if our Resolution exceeds this value
  LONG        lStretchEndXRes;      //Bitfield to describe the resolutions at which we want to stretch/expand
  DWORD       dwEnablePanel;        //We enable the LCD
  DWORD       dwEnableCrt;          //We enable the CRT
  DWORD       dwEnableTV;           //We enable the TV
  DWORD       dwPanelSingleMode;    //One Controller for both displays
  LONG        lTVFlickerFilter;     //1(disabled),2 or 3 line Flickerfilter
  DWORD       dwLCDTrueColorDither; //True Color dithering or reducing to 18bit
} ET_COMMON_PANEL_INFO, *PET_COMMON_PANEL_INFO;


// In structure (Tool -> driver):
// Structure to set the new Panel settings
typedef struct tagET_SET_PANEL_INFO
{
  ET_QUERY              hdr;

  DWORD                 dwParam1;             //1 saves to registry, 0 for testing
  ET_COMMON_PANEL_INFO  CommonPanelInfo;
} ET_SET_PANEL_INFO, *PET_SET_PANEL_INFO;


// Out structure (Driver -> Tool):
//Structure to retrieve complete information on the actual Panel
typedef struct tagET_GET_PANEL_INFO
{
  DWORD                 dwSize;

  DWORD                 dwPanelSupport;       //Does the Board support a LCD Panel
  LONG                  lXResPanel;           //X-Res of our Panel
  LONG                  lYResPanel;           //Y-Res of our Panel

  ET_COMMON_PANEL_INFO  CommonPanelInfo;

} ET_GET_PANEL_INFO, *PET_GET_PANEL_INFO;

// ********************************************************
// ********************************************************
//NEW: SK 13011999
//Interface for Maxtreme to enable/disable stereo for a given window

//In structure (Tool -> driver )
//Structure to set the Stereomode of a oglwindow. (for Maxtreme)
typedef struct tagET_SET_WINDOW_STEREOMODE
{
  ET_QUERY  hdr;

  PVOID     hwnd;   //Windowhandle // ELSA-FNicklis 27.04.00: not all of our code knows a HWND
  DWORD     dwMode; //STEREOMODE_ENABLE or STEREOMODE_DISABLE
} ET_SET_WINDOW_STEREOMODE, *PET_SET_WINDOW_STEREOMODE;

#define STEREOMODE_DISABLE  0x00000000
#define STEREOMODE_ENABLE   0x00000001

// ********************************************************


//
// NT direct hw access support - development only
//

// SUBESC_ET_GETREGISTER
typedef struct tagET_GETREG
{
  DWORD dwSize;
  DWORD dwRegister;
  DWORD dwValue;
  DWORD dwFlags;
}ET_GETREG, *PET_GETREG, FAR *LPET_GETREG;

// SUBESC_ET_SETREGISTER
typedef struct tagET_SETREG
{
  ET_QUERY hdr;     // size and subescape SUBESC_ET_SETREGISTER
  DWORD dwRegister;
  DWORD dwValue;
  DWORD dwFlags;
}ET_SETREG, *PET_SETREG, FAR *LPET_SETREG;

// SUBESC_ET_MODIFYREGISTER
typedef struct tagET_MODIFYREG
{
  ET_QUERY hdr;     // size and subescape SUBESC_ET_MODIFYREGISTER
  DWORD dwRegister;
  DWORD dwValue;
  DWORD dwFlags;
  DWORD dwMask; // (all bits to modify set to 1)
}ET_MODIFYREG, *PET_MODIFYREG, FAR *LPET_MODIFYREG;

//
// dwFlags values
//
#define MMIO_ACCESS             0x00 << 16  // default: mmio, sync + vblankwait
#define PIO_ACCESS              0x01 << 16
#define NO_SYNC                 0x02 << 16
#define NO_VBLANKWAIT           0x04 << 16
#define NO_FIFOWAIT             0x08 << 16

#define ACCESS_DWORD 0x01 << 0
#define ACCESS_WORD  0x02 << 0
#define ACCESS_BYTE  0x04 << 0



// SUBESC_ET_NOTIFYDRIVER
typedef struct tagET_NOTIFYDRIVER
{
  ET_QUERY hdr;     // size and subescape SUBESC_ET_NOTIFYDRIVER
  DWORD dwNotification;
}ET_NOTIFYDRIVER, *PET_NOTIFYDRIVER, FAR *LPET_NOTIFYDRIVER;

// notifications: video capture driver to display driver
#define EDDESC_VIO2DRVNOTIFY_TVOUTON   0x01
#define EDDESC_VIO2DRVNOTIFY_TVOUTOFF  0x02



// SUBESC_ET_SCROLL
// scrolling into offscreen (debug purposes)
typedef struct tagET_SCROLL_DATA
{
  ET_QUERY hdr;     // size and subescape SUBESC_ET_SCROLL
  LONG  cyLines;            // # of lines vertical panning
}ET_SCROLL_DATA, FAR *LPET_SCROLL_DATA;



// SUBESC_ET_GFXOPTIONQUERY
// GfxOptionQuery support
typedef struct tagET_GFXOPTIONQUERY
{
  ET_QUERY hdr;     // size and subescape SUBESC_ET_GFXOPTIONQUERY
  DWORD dwGfxOption;        // in/out parameter
}ET_GFXOPTIONQUERY_DATA, FAR *LPET_GFXOPTIONQUERY_DATA;

// SUBESC_ET_SAA
// video in/out related stuff, used by Windows NT video capture driver for hw access
typedef struct tagET_SAA_DATA
{
  ET_QUERY hdr;     // size and subescape SUBESC_ET_SAA
  DWORD dwSAACommand;       // = defines below
  DWORD dwData;
  DWORD dwRegister;
  DWORD dwReturn;
}ET_SAA_DATA, FAR *LPET_SAA_DATA;

#define I2COPEN                   1000
#define I2CCLOSE                  1001

#define CHECKSAA7111              1
#define WRITESAA7111              2
#define READSAA7111               3

#define CHECKSAA7125              101
#define WRITESAA7125              102
#define READSAA7125               103

// ********************************************************
// code for SUBESC_ET_QUERY_ICDCLIENTINFO:
// 12.02.1999 FNicklis

// input structure app -> driver
typedef struct tagET_QUERY_ICDCLIENTINFO_IN
{
  ET_QUERY hdr;  // size and subescape ET_QUERY_ICDCLIENTINFO
} ET_QUERY_ICDCLIENTINFO_IN;

typedef struct tagET_ICDCLIENTINFO
{
  DWORD  dwClientID;     // 1 per window
  DWORD  dwContextCount; // n per window > 0; 0==invalid
  DWORD  dwProcessID;    // 0==invalid/unused/unkown
  HANDLE hWnd;           // window handle
  LONG   lPixelFormat;   // used pixelformat number
} ET_ICDCLIENTINFO;

// output structure driver -> app
typedef struct tagET_QUERY_ICDCLIENTINFO_OUT
{
  DWORD  dwSize;          // Length of this out buffer
  DWORD  dwTotalClients;  // Total count of running OpenGL clients
  DWORD  dwReturnClients; // Count of information units returned to app

  ET_ICDCLIENTINFO aClientInfo[1]; // array of 1, ...
} ET_QUERY_ICDCLIENTINFO_OUT;


// ********************************************************
// code for SUBESC_ET_QUERY_TEMPERATURE:
// 28.09.1999 Thorsten Schumann

// bits used as caps and as status
#define ET_TEMPERATURE_FANSLOW     0x00000001   // fan slow or stop
#define ET_TEMPERATURE_FANSHORTVCC 0x00000002   // fan short VCC (only on boot phase available)
#define ET_TEMPERATURE_OVERTEMP    0x00000004   // over temperature
#define ET_TEMPERATURE_VALUE       0x00000008   // for future release, not yet used
                                                //    entry dwTemperatureValue is used

// output structure driver -> app
typedef struct tagET_QUERY_TEMPERATURE
{
  DWORD  dwSize;              // Length of this out buffer
  DWORD  dwTemperatureCaps;    // caps of valid record entries / hardware caps
  DWORD  dwTemperatureStatus; // status of flags
  DWORD  dwTemperatureValue;  // for future release, not yet used
  DWORD  dwReserved1;
  DWORD  dwReserved2;
} ET_QUERY_TEMPERATURE, FAR *LPET_QUERY_TEMPERATURE;


// ********************************************************
// begin of code for SUBESC_ET_DPMS:
//
// Set or query DPMS power save mode. Send ET_DPMS_IN structure
// with wanted DPMS mode to driver and always receive selected
// mode. If Escape fails, the DPMS mode was not set!
//
// FNicklis 29.09.1999: added SUBESC_ET_DPMS and sample code
//
// Sample code to set powersave mode:
//   taken from PowerSaver.scr Screen saver
//
  /*
//
// bSetDPMSMode
//
// enables ELSAESC-ET_DPMS power save mode via Escape call to driver.
//
// return: TRUE  - mode set successfully
//         FALSE - failed to set powersave mode
//
// FNicklis 29.09.1999: New
//
static BOOL bSetDPMSMode(
  IN ET_DPMS_MODE lMode)      // Power save mode to set
{
  BOOL        bRet=FALSE;     // pessimistic
  LONG        lResult;        // return value of extescape
  ET_DPMS_IN  etPowersaveIn;  // App -> Driver
  ET_DPMS_OUT etPowersaveOut; // Driver -> App
  HDC         hDC;            // Desktops HDC (to reach the display driver)

  ZeroMemory(&etPowersaveIn, sizeof(etPowersaveIn));

  etPowersaveIn.hdr.dwSize    = sizeof(etPowersaveIn);
  etPowersaveIn.hdr.dwSubEsc  = SUBESC_ET_DPMS;
  etPowersaveIn.hdr.dwOutSize = sizeof(etPowersaveOut);
  etPowersaveIn.hdr.dwBoard   = 0;
  etPowersaveIn.lMode         = lMode;

  hDC = GetDC(0);

  lResult = ExtEscape(hDC,
    ESC_ELSA_TOOLS,
    sizeof(etPowersaveIn),
    (PVOID)&etPowersaveIn,
    sizeof(etPowersaveOut),
    (PVOID)&etPowersaveOut);

  if (lResult>0)
  {
    assert(sizeof(etPowersaveOut)==etPowersaveOut.dwSize);
    assert((lMode==ET_DPMS_QUERY) || (etPowersaveIn.lMode==etPowersaveOut.lMode));
    bRet=TRUE;
  }
  else
  {
    // error: failed for call SUBESC_ET_DPMS");
  }

  return(bRet);
}
  */

// defines for DPMS-Power save modes
typedef enum tagET_DPMS_MODE
{
  ET_DPMS_ON,      // in/out: default mode, turn on monitor
                // Powersave modes:
  ET_DPMS_STANDBY, // in/out:
  ET_DPMS_SUSPEND, // in/out:
  ET_DPMS_OFF,     // in/out:

  ET_DPMS_QUERY    // in: return current mode in ET_DPMS_OUT. Only used in ET_DPMS_IN.ulMode!
} ET_DPMS_MODE;

// input structure app -> driver
typedef struct tagET_DPMS_IN
{
  ET_QUERY     hdr;    // size and subescape ET_DPMS_IN
  ET_DPMS_MODE lMode;  // type of mode to set or query
} ET_DPMS_IN;

// output structure driver -> app
typedef struct tagET_DPMS_OUT
{
  DWORD        dwSize; // Length of this out buffer
  ET_DPMS_MODE lMode;  // return current mode which is POWERSAVE_DISABLE or POWERSAVE_ENABLE
} ET_DPMS_OUT;

// end of code for SUBESC_ET_DPMS:
// ********************************************************

#ifdef WIN32
#pragma pack (pop, fixed_forELSAESC)
#else
#pragma pack ()
#endif

#endif //__ELSAESC
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\common\inc\nvBlit.h ===
/*
 * (C) Copyright NVIDIA Corporation Inc., 1996,1997,1998. All rights reserved.
 */
/********************************* Direct 3D *******************************\
*                                                                           *
* Module: nvBlit.h                                                          *
*    Definition file for:                                                   *
*       Blt832.c, Blt1632.c and Blt3232                                     *
*    Suggested new name for combined file:                                  *
*       nvBlit.c                                                            *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*       Paul van der Kouwe 06/16/99 - created.                              *
*                                                                           *
\***************************************************************************/

#ifndef _NVBLIT_H_
#define _NVBLIT_H_

#ifdef __cplusplus
extern "C" {
#endif

// workspace allocation flags
#define BLTWS_UNINITIALIZED     0x0
#define BLTWS_VIDEO             0x1
#define BLTWS_AGP               0x2
#define BLTWS_SYSTEM            0x4
#define BLTWS_PREFERRED_VIDEO   0x10
#define BLTWS_PREFERRED_AGP     0x20
#define BLTWS_PREFERRED_SYSTEM  0x40
#define BLTWS_REQUIRED_VIDEO    0x100
#define BLTWS_REQUIRED_AGP      0x200
#define BLTWS_REQUIRED_SYSTEM   0x400

// other defines (lore)
#define NV4_BLT_READ_AHEAD_BUFFER_SIZE  4096
#define NV10_BLT_READ_AHEAD_BUFFER_SIZE 8192

// abbreviated surface info
typedef struct tagSurfInfo {
    LPDDRAWI_DDRAWSURFACE_LCL pLcl;
    LPDDRAWI_DDRAWSURFACE_GBL pGbl;
    CNvObject *pObj;
    DWORD     dwFourCC;
    BOOL      bUseSwizzle;
    BOOL      bIsLocked;
    DWORD     dwCaps;
    DWORD     dwContextDma;
    FLATPTR   fpVidMem;
    DWORD     dwOffset;
    DWORD     dwPitch;
    DWORD     dwWidth;
    DWORD     dwHeight;
    DWORD     dwSubRectX;
    DWORD     dwSubRectY;
    DWORD     dwSubRectWidth;
    DWORD     dwSubRectHeight;
    BOOL      isPotentialFault;
    DWORD     dwBytesPerPixel;
    BOOL      bDefaultBlitChanged;
} SURFINFO, *LPSURFINFO;

// exports
DWORD __stdcall GetBltStatus32(LPDDHAL_GETBLTSTATUSDATA lpGetBltStatus);
DWORD __stdcall Blit32(LPDDHAL_BLTDATA pbd);

// utility functions
void  __stdcall bltInit(void);
DWORD __stdcall bltEarlyErrorCheck(LPDDHAL_BLTDATA pbd, LPSURFINFO pSrc, LPSURFINFO pDst);
DWORD __stdcall bltUpdateClip(GLOBALDATA *pDriverData);
DWORD __stdcall bltDestroyAllContextDMAs(LPDDRAWI_DIRECTDRAW_GBL lpDD);
DWORD __stdcall bltCreateContextDMA(LPDDHAL_BLTDATA pbd, LPSURFINFO pSurf);
DWORD __stdcall bltControlTraffic(LPSURFINFO pSrc, LPSURFINFO pDst);
DWORD __stdcall bltAllocWorkSpace(LPDDHAL_BLTDATA pbd, LPSURFINFO pSurf, DWORD dwFlags, LPDDRAWI_DIRECTDRAW_GBL lpDD);
DWORD __stdcall bltSetSurfaces2D(LPSURFINFO pSrc, LPSURFINFO pDst);
DWORD __stdcall bltSetBltState(LPDDHAL_BLTDATA pbd, LPSURFINFO src, LPSURFINFO dst);

// blt functions
DWORD __stdcall bltPotentialFaultHandler(LPDDHAL_BLTDATA pbd, LPSURFINFO pSrc, LPSURFINFO pDst);
DWORD __stdcall bltTexture(LPDDHAL_BLTDATA pbd, LPSURFINFO pSrc, LPSURFINFO pDst, BOOL bStretch);
DWORD __stdcall ScaleZFillDepth(LPDDHAL_BLTDATA pbd, LPSURFINFO pDst);
DWORD __stdcall bltColourFill(LPDDHAL_BLTDATA pbd, LPSURFINFO pDst, DWORD dwFillColour);
DWORD __stdcall blt4CCto4CC(LPDDHAL_BLTDATA pbd, LPSURFINFO pSrc, LPSURFINFO pDst);
DWORD __stdcall bltSimpleCopy(LPDDHAL_BLTDATA pbd, LPSURFINFO pSrc, LPSURFINFO pDst);
DWORD __stdcall bltSlowVtoSBlt(LPDDHAL_BLTDATA pbd, LPSURFINFO pSrc, LPSURFINFO pDst);
DWORD __stdcall bltSlowStoVBlt(LPDDHAL_BLTDATA pbd, LPSURFINFO pSrc, LPSURFINFO pDst);
DWORD __stdcall bltSimpleVtoVBlt(LPDDHAL_BLTDATA pbd, LPSURFINFO pSrc, LPSURFINFO pDst);
DWORD __stdcall blt8bppStrBlt(LPDDHAL_BLTDATA pbd, LPSURFINFO pSrc, LPSURFINFO pDst);
DWORD __stdcall bltStrBlt(LPDDHAL_BLTDATA pbd, LPSURFINFO pSrc, LPSURFINFO pDst, BOOL bFilter);

// internal use blit functions
DWORD __stdcall bltWriteDword(DWORD dwOffset, DWORD dwIndex, DWORD dwData);
DWORD __stdcall bltFillBlock(GLOBALDATA *pDriverData, DWORD dwColour, DWORD dwOffset, DWORD dwPitch, DWORD dwWidth, DWORD dwHeight, DWORD dwBytesPerPel);

// old fallback blt code
DWORD __stdcall Blt8bpp32  (LPDDHAL_BLTDATA pbd);
DWORD __stdcall Blt16bpp32 (LPDDHAL_BLTDATA pbd);
DWORD __stdcall Blt32bpp32 (LPDDHAL_BLTDATA pbd);

#ifdef __cplusplus
}
#endif // __cplusplus

#endif // _NVBLIT_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\common\inc\nvcom.h ===
#ifndef __NV_COM_H
#define __NV_COM_H

#include "nvOverlay.h"

// XXX Having to define this here sucks.  This is in mtexport.h but
// mtexport.h needs NVstate stuff :(   -paul
#ifndef WQ_MAX_THREAD
#define WQ_MAX_THREAD 2
#endif

typedef struct  __GLNVtagInfoRec {
    unsigned int  type;
    void          *address;
} __GLNVtagInfo;    

// Basic element of the pushbuffer
typedef union __GLNVdataRec {
    NvF32 f;
    NvS32 i;
    NvU32 u;
} __GLNVdata;

// Structure declarations to keep gcc happy
struct __GLNVstateRec;
struct __GLdrawablePrivateRec;

// Flags passed into the display driver when allocating or requesting
// info regarding the unified buffers.

enum  {
    SBD_BACK_1_OFFSET = 0,
    SBD_BACK_1_PITCH,
    SBD_BACK_2_OFFSET,
    SBD_BACK_2_PITCH,
    SBD_DEPTH_OFFSET,
    SBD_DEPTH_PITCH,
    SBD_FRONT_MAIN_OFFSET,
    SBD_FRONT_MAIN_PITCH,
    SBD_BACK_1_MAIN_OFFSET,
    SBD_BACK_1_MAIN_PITCH,
    SBD_FRONT_OVERLAY_OFFSET,
    SBD_FRONT_OVERLAY_PITCH,
    SBD_BACK_1_OVERLAY_OFFSET,
    SBD_BACK_1_OVERLAY_PITCH,
    // ogl api stereo buffers below
    SBD_FRONT_RIGHT_OFFSET,
    SBD_FRONT_RIGHT_PITCH,
    SBD_BACK_1_RIGHT_OFFSET,
    SBD_BACK_1_RIGHT_PITCH,
    SBD_BACK_2_RIGHT_OFFSET,
    SBD_BACK_2_RIGHT_PITCH,
    SBD_DEPTH_RIGHT_OFFSET,
    SBD_DEPTH_RIGHT_PITCH,
    SBD_FRONT_MAIN_RIGHT_OFFSET,
    SBD_FRONT_MAIN_RIGHT_PITCH,
    SBD_BACK_1_MAIN_RIGHT_OFFSET,
    SBD_BACK_1_MAIN_RIGHT_PITCH,
    SBD_FRONT_OVERLAY_RIGHT_OFFSET,
    SBD_FRONT_OVERLAY_RIGHT_PITCH,
    SBD_BACK_1_OVERLAY_RIGHT_OFFSET,
    SBD_BACK_1_OVERLAY_RIGHT_PITCH
};

typedef struct __GLNVsbdFlagsRec {
    int windowFlipping;  // Enable window flipping
    int overlaySupport;  // Allocate overlay buffers
    int surfaceInfoType;
    int depthCompressed;
} __GLNVsbdFlags;


typedef struct __GLNVpaletteDataRec {
  void         *windowHandle;
  unsigned int  entries[ICD_PALETTE_ENTRIES];
  unsigned int  crTransparent;
} __GLNVpaletteData;

typedef struct __GLMergeBlitDataRec
{
    NvU32 PrimaryFrontOffset; // offset of primary buffer (where DAC is working)
    NvU32 PrimaryFrontPitch ;
    NvU32 ScratchOffset     ; // offset of scratch buffer for mergeblit
    NvU32 ScratchPitch      ;

    NvU32 MainFrontOffset   ; // offset of main front plane (where overlay app has its main)
    NvU32 MainFrontPitch    ;
    NvU32 MainBackOffset    ; // offset of main back plane (where overlay app has its main)
    NvU32 MainBackPitch     ;

    NvU32 OverlayFrontOffset; // offset of overlay front plane (where overlay app has its overlay)
    NvU32 OverlayFrontPitch ;
    NvU32 OverlayBackOffset ; // offset of overlay back plane (where overlay app has its overlay)
    NvU32 OverlayBackPitch  ;

    int   colordepth        ; // 16 or 32, color depth of above buffers (UBB)

    NvU32 colorref          ; // colorkey for transparent color

    unsigned int   dwAction ; // NV_OVERLAY_xxx

    __GLregionRect *prclClip; // pointer to list of clip rects
    unsigned int    cClip;    // count of valid rects inside prclClip

    __GLregionRect rclUser  ; // single user clip rect 
} __GLMergeBlitData;

typedef struct __GLNVcmdInfoRec {

    struct __GLNVstateRec *state;

    // Channel information for syncing in NTx display driver
    NvU32        maskOtherChannels;
    unsigned int ourChannelId;
    void         *ntOther;      // PDEV pointer 
    void         *ntDrawable;   // clientDrawableInfo pointer 
    void         *ntClientInfo; // clientInfo pointer 

    // Number of hardware window clipping rectangles available.
    // Should be 8 for NV10GL and 1 for NV10 geForce.
    int numHWClipRects;

    // TRUE if rendering to the back buffer
    unsigned int backBufferIsEnabled;

    // Client size view of windowChangedCount at time of kickoff; this is
    // compared with the latest count inside the display driver.  If they
    // are out of sync and flushBetween2D is TRUE then fail the kick off
    // in the display driver.
    int windowChangedCount;
    int flushedBetween2D;

    unsigned char isClipped;
    unsigned char usingCopyBuf;
    int syncGdi;

    int nvDebugLevel;
    int nvDebugOptions;
    int nvDebugMask;
    int nvControlOptions;

    // Core Clip rectangle computed by wgl in screen coordinates
    __GLregionRect coreClipRect;

    int temp0;
    int temp1;
    int temp2;
    int temp3;
    int temp4;
} __GLNVcmdInfo;

//
// NV10 flush information structure
//
typedef struct __GLNVflushInfoRec {
    // flush type, client handle and window handle
//    ULONG        type;
    ULONG        hClient;

    // clip and mode switch info
    ULONG        localModeSwitchCount;

    __GLNVcmdInfo *cmdInfo;
    
    // Tells Display driver that scissor has changed.
    ULONG wndClipRectChanged;
    
    // Clip Changed Count 
    ULONG clipChangedCount;

    // return status from flush command
    unsigned int retStatus;   // status of flush in display driver
} __GLNVflushInfo;

typedef struct __GLNVswapInfoRec {
    ULONG        hClient;

    // window info
    __GLNVcmdInfo *cmdInfo;

    // clip and mode switch info
    ULONG        clipChangedCount;
    ULONG        localModeSwitchCount;
    PVOID        drawable;

    // SwapHintRect info
    unsigned int        numSwapHintRects;
    __GLregionRect*     pSwapHintRects;

    // return status
    ULONG        retStatus;
} __GLNVswapInfo;

// ***********************************************************************
// Command interface for OpenGL operations which must be performed inside
// the display driver (or mutexed, depending on the OS)
enum {
    NVOP_STATUS_ERROR,
    NVOP_STATUS_SUCCESS,
    NVOP_STATUS_NEED_UPDATE,
    NVOP_STATUS_UNKNOWN_OP
};

typedef enum {
    NVOP_CLEAR,
    NVOP_SWAP,
} __GLNVopcode;

typedef struct __GLNVclearCmdRec {
    GLbitfield mask;                        // buffers to clear
    __GLregionRect rect;                    // user clear rect
    GLint drawBufferMask;                   // mask of active buffers
    /* Color buffer */
    struct {
        GLfloat r, g, b, a;
    } clearColor;                           // clear color
    GLboolean rMask;                        // color buffer red mask
    GLboolean gMask;                        // color buffer green mask
    GLboolean bMask;                        // color buffer blue mask
    GLboolean aMask;                        // color buffer alpha mask
    /* Depth buffer */
    GLfloat clearDepth;                     // clear depth
    /* Stencil buffer */
    GLuint clearStencil;                    // clear stencil
    GLuint stencilMask;                     // stencil mask
} __GLNVclearCmd;

typedef struct __GLNVoperationRec {
    __GLNVopcode opCode;
    __GLNVcmdInfo *cmdInfo;
    struct __GLNVstateRec *state;             // can this be removed?
    struct __GLdrawablePrivateRec *dp;
    struct {
        GLint numRects;
        __GLregionRect *rects;
    } clip;
    union {
        __GLNVclearCmd clear;
    } u;
    GLint retStatus;
} __GLNVoperation;

// ***********************************************************************


// probably needs to be removed to better place
// bits used in __glNVOverlayMergeFastLock - dwAction
#define NV_OVERLAY_MERGE_BLIT        0x00000001 // do front overlay + front main -> scratch -> primary
#define NV_OVERLAY_UPDATE_OVERLAY    0x00000010 // overlay back -> overlay front (prior to merge)
#define NV_OVERLAY_UPDATE_MAIN       0x00000020 // main back -> overlay front (prior to merge)
#define NV_OVERLAY_USE_CLIPRECT      0x00000100 // only do mergeblit on given rect (else entire window)
#define NV_OVERLAY_DEFERRED          0x00001000 // defer merge blit (do update later)
#define NV_OVERLAY_RUN_IN_DD         0x00002000 // do mergeblit in display driver
#define NV_OVERLAY_NO_OVERLAY_PLANE  0x00010000 // there is no overlay plane, front main -> primary (will overwrite NV_OVERLAY_MERGE_BLIT)


//
// Derived from __GLNVswapInfo to support overlay merge blit through DD.
// Used with the ESC_NV_OPENGL_OVERLAY_MERGEBLIT escape 
// in __glNVOverlayMergeFastLock.
//
typedef struct __GLNVoverlayMergeBlitInfoRec {
    unsigned int hClient;
    
    // window info
    __GLNVcmdInfo *cmdInfo;

    // clip and mode switch info
    unsigned int localModeSwitchCount;

    // return status
    unsigned int retStatus;

    unsigned int dwAction; // NV_OVERLAY_xxx

    int          x;        // bounding rectangle if NV_OVERLAY_USE_CLIPRECT is set 
    int          y;
    int          width;
    int          height;

    // SwapHintRect info
    unsigned int numSwapHintRects;
    void *       pSwapHintRects;

} __GLNVoverlayMergeBlitInfo;

//
// These routines live in the shared lib and are called from both the ICD
// and from the display driver side of OGL escape calls.  -paul
//

// nvsharedpushbuf.c
extern void STDCALL __glNVMakeJumpSpaceInPushBuffer(__GLNVcmdInfo *cmdInfo);
extern GLboolean STDCALL __glNVSetupAndKickoff(__GLNVcmdInfo *cmdInfo,
                                          unsigned int numInclusiveRects,__GLregionRect *inclusiveRects,
                                          unsigned int numExclusiveRects,__GLregionRect *exclusiveRects,
                                          unsigned char failOnClipChange);
extern void STDCALL __glNVCopyPseudoKickoff(__GLNVcmdInfo *cmdInfo, int forceRealBuf);

// nvsharedutils.c
extern void STDCALL __glNVInitSharedFnPtrs(__GLNVcmdInfo *cmdInfo);
extern void STDCALL __glNVDoRegistryHacks(unsigned int hwGfxCaps,
                                          unsigned int *flippingControl,
                                          unsigned int *doUnifiedBuffers,
                                          unsigned int *doWindowFlipping,
                                          unsigned int *applicationKey,
                                          unsigned int *appSupportBits,
                                          unsigned int *overlaySupport,
                                          unsigned int *apiStereoSupport,
                                          unsigned int *apiStereoMode);
extern void STDCALL __glNVLoadRegistryDefaults(unsigned int hwGfxCaps,
                                               unsigned int *doUnifiedBuffers,
                                               unsigned int *doWindowFlipping,
                                               unsigned int *flippingControl,
                                               unsigned int *applicationKey,
                                               unsigned int *appSupportBits,
                                               unsigned int *overlaySupport,
                                               unsigned int *apiStereoSupport,
                                               unsigned int *apiStereoMode);

extern void STDCALL __glNVUpdateStereoBuffers(struct __GLdrawablePrivateRec *dp);

// nvsharedswap.c
extern GLboolean STDCALL __glNVWasFlipped(__GLNVcmdInfo *cmdInfo);
extern GLboolean STDCALL __glNVSetupSwap(__GLNVcmdInfo *cmdInfo, void *drawable,
                                         unsigned int numRects, __GLregionRect *rects,
                                         int screenWidth, int screenHeight);
extern int STDCALL __glNVIsVerticalInterlacedApiStereo(void *drawable);
extern GLboolean STDCALL __glNV4SetupSwap(__GLNVcmdInfo *cmdInfo, void *drawable,
                                          unsigned int numRects, __GLregionRect *rects,
                                          int screenWidth, int screenHeight);
extern GLboolean STDCALL __glNVPrepareStereoSwap(void *drawable,
                                                 int stereoBroadcastingNeeded);
extern GLboolean STDCALL __glNVSetupMergeBlit(__GLNVcmdInfo *cmdInfo, 
                                              struct __GLMergeBlitDataRec *pMergeBlitData);

// nv4sharedpushbuf.c
extern void STDCALL __glNV4SetupAndKickoff(__GLNVcmdInfo *cmdInfo,
                                           unsigned int numRects,
                                           __GLregionRect *rects);

// nvsharedclear.c
extern void STDCALL __glNVSetupClear(__GLNVoperation *op);

// oglexpor.c in DD
extern void CDECLCALL __glNVFlushInternal(__GLNVcmdInfo *cmdInfo, unsigned char forceRealBuf);
extern void CDECLCALL __glNV4FlushInternal(__GLNVcmdInfo *cmdInfo);

#endif  // __NV_COM_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\common\inc\nvCapture.h ===
/***************************************************************************\
|*                                                                           *|
|*       Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.      *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.  Users and possessors of this source code are     *|
|*     hereby granted a nonexclusive,  royalty-free copyright license to     *|
|*     use this code in individual and commercial software.                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*       Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.      *|
|*                                                                           *|
|*     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY     *|
|*     OF  THIS SOURCE  CODE  FOR ANY PURPOSE.  IT IS  PROVIDED  "AS IS"     *|
|*     WITHOUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPOR-     *|
|*     ATION DISCLAIMS ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,     *|
|*     INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY, NONINFRINGE-     *|
|*     MENT,  AND FITNESS  FOR A PARTICULAR PURPOSE.   IN NO EVENT SHALL     *|
|*     NVIDIA, CORPORATION  BE LIABLE FOR ANY SPECIAL,  INDIRECT,  INCI-     *|
|*     DENTAL, OR CONSEQUENTIAL DAMAGES,  OR ANY DAMAGES  WHATSOEVER RE-     *|
|*     SULTING FROM LOSS OF USE,  DATA OR PROFITS,  WHETHER IN AN ACTION     *|
|*     OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  ARISING OUT OF     *|
|*     OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOURCE CODE.     *|
|*                                                                           *|
|*     U.S. Government  End  Users.   This source code  is a "commercial     *|
|*     item,"  as that  term is  defined at  48 C.F.R. 2.101 (OCT 1995),     *|
|*     consisting  of "commercial  computer  software"  and  "commercial     *|
|*     computer  software  documentation,"  as such  terms  are  used in     *|
|*     48 C.F.R. 12.212 (SEPT 1995)  and is provided to the U.S. Govern-     *|
|*     ment only as  a commercial end item.   Consistent with  48 C.F.R.     *|
|*     12.212 and  48 C.F.R. 227.7202-1 through  227.7202-4 (JUNE 1995),     *|
|*     all U.S. Government End Users  acquire the source code  with only     *|
|*     those rights set forth herein.                                        *|
|*                                                                           *|
 \***************************************************************************/

//////////////////////////////////////////////////////////////////////////////
// schema history
// 1. original version
// 2. adds CAPTURE_OBJECT_FREE, ANNOTATION, CAPTURE_CONFIG settings
// 3. adds CAPTURE_SYNC3 and obsoletes CAPTURE_SYNC
// 4. adds CAPTURE_LOCK
// 5. adds CAPTURE_FLIP_CHAIN
//////////////////////////////////////////////////////////////////////////////

#ifndef _nvCapture_h
#define _nvCapture_h

#ifdef __cplusplus
extern "C"
{
#endif
#pragma pack(push,1)

//////////////////////////////////////////////////////////////////////////////
// constants
//
#define CAPTURE_JMP_COMMAND             0x20ffffff
#define CAPTURE_EXT_SIGNATURE           0x420352ec

#define CAPTURE_CTXDMA_TYPE_PCI         0x49435920
#define CAPTURE_CTXDMA_TYPE_AGP         0x50474120
#define CAPTURE_CTXDMA_TYPE_VID         0x44495620

#define CAPTURE_SURFACE_TYPE_NORMAL     0x4d524f4e  // 'NORM'  surface goes into normal space (tiled)
#define CAPTURE_SURFACE_TYPE_ZETA       0x4154455a  // 'ZETA'  surface goes into zeta space (tiled)
#define CAPTURE_SURFACE_TYPE_TEXTURE    0x54584554  // 'TEXT'  surface goes into texture space

#define CAPTURE_SURFACE_KIND_TARGET     0x54475254  // 'TRGT'  surface will be used as a render target
#define CAPTURE_SURFACE_KIND_ZETA       0x4154455a  // 'ZETA'  surface will be used as a z buffer
#define CAPTURE_SURFACE_KIND_TEXTURE    0x54584554  // 'TEXT'  surface will be used as a texture
#define CAPTURE_SURFACE_KIND_VERTEX     0x54524556  // 'VERT'  surface will be used as a vertex buffer
#define CAPTURE_SURFACE_KIND_PUSHER     0x48535550  // 'PUSH'  surface will be used as a push buffer
#define CAPTURE_SURFACE_KIND_UNKNOWN    0x4e4b4e55  // 'UNKN'  surface will be used as a push buffer
#define CAPTURE_SURFACE_KIND_COMMAND    0x4d4d4f43  // 'COMM'  surface will be used as a command buffer
#define CAPTURE_SURFACE_KIND_PALETTE    0x434c4150  // 'PALE'  surface will be used as a palette

#define CAPTURE_SURFACE_FORMAT_Y8                0
#define CAPTURE_SURFACE_FORMAT_AY8               1
#define CAPTURE_SURFACE_FORMAT_A1R5G5B5          2
#define CAPTURE_SURFACE_FORMAT_X1R5G5B5          3
#define CAPTURE_SURFACE_FORMAT_A4R4G4B4          4
#define CAPTURE_SURFACE_FORMAT_R5G6B5            5
#define CAPTURE_SURFACE_FORMAT_A8R8G8B8          6
#define CAPTURE_SURFACE_FORMAT_unknown1          7
#define CAPTURE_SURFACE_FORMAT_X8R8G8B8          8
#define CAPTURE_SURFACE_FORMAT_I8_A1R5G5B5       9
#define CAPTURE_SURFACE_FORMAT_I8_R5G6B5        10
#define CAPTURE_SURFACE_FORMAT_I8_A4R4G4B4      11
#define CAPTURE_SURFACE_FORMAT_I8_A8R8G8B8      12
#define CAPTURE_SURFACE_FORMAT_DXT1_A1R5G5B5    13
#define CAPTURE_SURFACE_FORMAT_DXT23_A8R8G8B8   14
#define CAPTURE_SURFACE_FORMAT_DXT45_A8R8G8B8   15
#define CAPTURE_SURFACE_FORMAT_IMAGE_A1R5G5B5   16
#define CAPTURE_SURFACE_FORMAT_IMAGE_R5G6B5     17
#define CAPTURE_SURFACE_FORMAT_IMAGE_A8R8G8B8   18
#define CAPTURE_SURFACE_FORMAT_IMAGE_Y8         19
#define CAPTURE_SURFACE_FORMAT_IMAGE_SY8        20
#define CAPTURE_SURFACE_FORMAT_IMAGE_X7SY9      21
#define CAPTURE_SURFACE_FORMAT_IMAGE_R8B8       22
#define CAPTURE_SURFACE_FORMAT_IMAGE_G8B8       23
#define CAPTURE_SURFACE_FORMAT_IMAGE_SG8SB8     24
#define CAPTURE_SURFACE_FORMAT_unknown2         25
#define CAPTURE_SURFACE_FORMAT_unknown3         26
#define CAPTURE_SURFACE_FORMAT_unknown4         27

#define CAPTURE_LOCK_TYPE_LOCK                   1
#define CAPTURE_LOCK_TYPE_UNLOCK                 2

#define CAPTURE_ANNOTATION_ALLOC4X               0

#define CAPTURE_SYNC_SPECIAL            0xffffffff
#define CAPTURE_SYNC_WAIT_ZEROCOMMANDS  0x00000001  // wait for command buffer to empty (put==get)
#define CAPTURE_SYNC_WAIT_CHIPIDLE      0x00000002  // wait fot call engines to go idle
#define CAPTURE_SYNC_WAIT_CHANNELS      0x00000003  // wait for other channels to complete

#define CAPTURE_SYNC3_TYPE_ZEROCOMMANDS 0x00000001  // wait for command buffer to empty (put==get)
#define CAPTURE_SYNC3_TYPE_CHIPIDLE     0x00000002  // wait fot call engines to go idle
#define CAPTURE_SYNC3_TYPE_CHANNELS     0x00000003  // wait for other channels to complete
#define CAPTURE_SYNC3_TYPE_NOTIFIER     0x00000004  // wait for a notifier
#define CAPTURE_SYNC3_TYPE_REFCOUNT     0x00000005  // wait for a refcount
#define CAPTURE_SYNC3_TYPE_SEMAPHORE    0x00000006  // wait for a semaphore

#define CAPTURE_SCHEMA_1                0x00000001
#define CAPTURE_SCHEMA_2                0x00000002
#define CAPTURE_SCHEMA_3                0x00000003
#define CAPTURE_SCHEMA_4                0x00000004
#define CAPTURE_SCHEMA_5                0x00000005

#define CAPTURE_CURRENT_SCHEMA          CAPTURE_SCHEMA_5

//
// INFORMATION
//
#define CAPTURE_XID_INFORMATION             0x4f464e49  // 'INFO'
typedef struct {
    DWORD dwJmpCommand;             // CAPTURE_JMP_COMMAND
    DWORD dwExtensionSignature;     // CAPTURE_EXT_SIGNATURE
    DWORD dwExtensionID;            // CAPTURE_XID_INFORMATION
    DWORD dwSchema;                 // file version (CAPTURE_CURRENT_SCHEMA)
    char  szInformation[256];       // creation info
} CAPTURE_INFORMATION;

//
// CTXDMA_CREATE
//
#define CAPTURE_XID_CTXDMA_CREATE           0x52435843  // 'CXCR'
typedef struct {
    DWORD dwJmpCommand;             // CAPTURE_JMP_COMMAND
    DWORD dwExtensionSignature;     // CAPTURE_EXT_SIGNATURE
    DWORD dwExtensionID;            // CAPTURE_XID_CTXDMA_CREATE
    DWORD dwHandle;                 // you figure it out, Tex
    DWORD dwType;                   // CAPTURE_CTXDMA_TYPE_xxx
    DWORD dwSize;                   // [bytes]
    DWORD dwBaseAddress;            // application base address
} CAPTURE_CTXDMA_CREATE;

//
// SURFACE_ALLOC
//
#define CAPTURE_XID_SURFACE_ALLOC           0x41465253  // 'SRFA'
typedef struct {
    DWORD dwJmpCommand;             // CAPTURE_JMP_COMMAND
    DWORD dwExtensionSignature;     // CAPTURE_EXT_SIGNATURE
    DWORD dwExtensionID;            // CAPTURE_XID_SURFACE_ALLOC
    DWORD dwCtxDMAHandle;           // you figure it out, Tex
    DWORD dwOffset;                 // offset in CTXDMA
    DWORD dwSize;                   // size of surface (in bytes)
    DWORD dwAlignment;              // alignment (if known, 0 - let interpreter infer from CTXDMA)
    DWORD dwType;                   // CAPTURE_SURFACE_TYPE_xxx
    DWORD dwKind;                   // usage hint - CAPTURE_SURFACE_KIND_xxx
    DWORD dwSurfaceType;            // CAPTURE_SURFACE_FORMAT_xxx
    DWORD dwIntendedPitch;          // pitch we think we will apply on this surface
    DWORD dwIntendedHeight;         // height we think we will apply on this surface
} CAPTURE_SURFACE_ALLOC;

//
// SURFACE_FREE
//
#define CAPTURE_XID_SURFACE_FREE            0x46465253  // 'SRFF'
typedef struct {
    DWORD dwJmpCommand;             // CAPTURE_JMP_COMMAND
    DWORD dwExtensionSignature;     // CAPTURE_EXT_SIGNATURE
    DWORD dwExtensionID;            // CAPTURE_XID_SURFACE_FREE
    DWORD dwCtxDMAHandle;           // you figure it out, Tex
    DWORD dwOffset;                 // offset in CTXDMA
} CAPTURE_SURFACE_FREE;

//
// MEMORY_WRITE
//
#define CAPTURE_XID_MEMORY_WRITE            0x574d454d  // 'MEMW'
typedef struct {
    DWORD dwJmpCommand;             // CAPTURE_JMP_COMMAND
    DWORD dwExtensionSignature;     // CAPTURE_EXT_SIGNATURE
    DWORD dwExtensionID;            // CAPTURE_XID_MEMORY_WRITE
    DWORD dwCtxDMAHandle;           // you figure it out, Tex
    DWORD dwOffset;                 // offset in CTXDMA
    DWORD dwSize;                   // number of bytes (multiple of 4)
    // [ data goes here ]
} CAPTURE_MEMORY_WRITE;

//
// SYNC - obsoleted in schema 3
//
#define CAPTURE_XID_SYNC                    0x434e5953  // 'SYNC'
typedef struct {
    DWORD dwJmpCommand;             // CAPTURE_JMP_COMMAND
    DWORD dwExtensionSignature;     // CAPTURE_EXT_SIGNATURE
    DWORD dwExtensionID;            // CAPTURE_XID_SYNC
    DWORD dwCtxDMAHandle;           //                  [ if special, undefined                              ]
    DWORD dwOffset;                 // offset in CTXDMA [ special case when dwOffset == CAPTURE_SYNC_SPECIAL ]
    DWORD dwValue;                  // value to match   [ if special, one of CAPTURE_SYNC_WAIT_xxx           ]
} CAPTURE_SYNC;

//
// SYNC3
//
#define CAPTURE_XID_SYNC3                   0x334e5953  // 'SYN3'
typedef struct {
    DWORD dwJmpCommand;             // CAPTURE_JMP_COMMAND
    DWORD dwExtensionSignature;     // CAPTURE_EXT_SIGNATURE
    DWORD dwExtensionID;            // CAPTURE_XID_SYNC3
    DWORD dwType;                   // CAPTURE_SYNC3_TYPE_xxx
    DWORD dwCtxDMAHandle;           // valid for type semaphore, else irrelevant
    DWORD dwOffset;                 // offset in CTXDMA, valid for type semaphore, else irrelevant
    DWORD dwValue;                  // value to match
} CAPTURE_SYNC3;

//
// OBJECT_CREATE
//
#define CAPTURE_XID_OBJECT_CREATE           0x5243424f  // 'OBCR'
typedef struct {
    DWORD dwJmpCommand;             // CAPTURE_JMP_COMMAND
    DWORD dwExtensionSignature;     // CAPTURE_EXT_SIGNATURE
    DWORD dwExtensionID;            // CAPTURE_XID_OBJECT_CREATE
    DWORD dwClassID;                // actual class this handle maps to
    DWORD dwHandle;                 // handle of the class
} CAPTURE_OBJECT_CREATE;

//
// OBJECT_FREE
//
#define CAPTURE_XID_OBJECT_FREE             0x5246424f  // 'OBFR'
typedef struct {
    DWORD dwJmpCommand;             // CAPTURE_JMP_COMMAND
    DWORD dwExtensionSignature;     // CAPTURE_EXT_SIGNATURE
    DWORD dwExtensionID;            // CAPTURE_XID_OBJECT_FREE
    DWORD dwHandle;                 // you figure it out, Tex
} CAPTURE_OBJECT_FREE;

//
// SCENE
//
#define CAPTURE_XID_SCENE                   0x454e4353  // 'SCNE'
typedef struct {
    DWORD dwJmpCommand;             // CAPTURE_JMP_COMMAND
    DWORD dwExtensionSignature;     // CAPTURE_EXT_SIGNATURE
    DWORD dwExtensionID;            // CAPTURE_XID_SCENE
} CAPTURE_SCENE;

//
// LOCK / UNLOCK
//
#define CAPTURE_XID_LOCK                    0x4b434f4c  // 'LOCK'
typedef struct {
    DWORD dwJmpCommand;             // CAPTURE_JMP_COMMAND
    DWORD dwExtensionSignature;     // CAPTURE_EXT_SIGNATURE
    DWORD dwExtensionID;            // CAPTURE_XID_LOCK
    DWORD dwType;                   // CAPTURE_LOCK_TYPE_xxx
    DWORD dwCtxDMAHandle;
    DWORD dwOffset;
} CAPTURE_LOCK;

//
// FLIP_CHAIN
//
#define CAPTURE_XID_FLIP_CHAIN              0x4e484346  // 'FCHN'
typedef struct {
    DWORD dwJmpCommand;             // CAPTURE_JMP_COMMAND
    DWORD dwExtensionSignature;     // CAPTURE_EXT_SIGNATURE
    DWORD dwExtensionID;            // CAPTURE_XID_FLIP_CHAIN
    DWORD dwCount;                  // number of surfaces in chain. addresses follow.
    // [ data here ]
} CAPTURE_FLIP_CHAIN;

//
// ANNOTATION
//
#define CAPTURE_XID_ANNOTATION              0x4f4e4e41  // 'ANNO'
typedef struct {
    DWORD dwJmpCommand;             // CAPTURE_JMP_COMMAND
    DWORD dwExtensionSignature;     // CAPTURE_EXT_SIGNATURE
    DWORD dwExtensionID;            // CAPTURE_XID_ANNOTATION
    DWORD dwValue;                  // CAPTURE_ANNOTATION_xxx
} CAPTURE_ANNOTATION;


//////////////////////////////////////////////////////////////////////////////
// procedures
//
int captureStartup   (char *szBasePath, char *szBaseFilename, DWORD dwBaseFilenum);
int captureShutdown  (void);
int captureSetParams (char *szBasePath, char *szBaseFilename, DWORD dwBaseFilenum);
int captureLog       (void *pBuffer, unsigned uCount);
int captureFileInc   (void);

int capturePlayStartup   (char *szBasePath, char *szBaseFilename, DWORD dwBaseFilenum);
int capturePlayShutdown  (void);
int capturePlaySetParams (char *szBasePath, char *szBaseFilename, DWORD dwBaseFilenum);
int capturePlay          (void *pRenderTarget, DWORD dwPitch, DWORD dwWidth, DWORD dwHeight);
int capturePlayFileInc   (void);

#pragma pack(pop)
#ifdef __cplusplus
}
#endif

#endif // _nvPM_h
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\common\inc\nvdbg.h ===
// **************************************************************************
//
//       Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.
//
//     NOTICE TO USER:   The source code  is copyrighted under  U.S. and
//     international laws.  Users and possessors of this source code are
//     hereby granted a nonexclusive,  royalty-free copyright license to
//     use this code in individual and commercial software.
//
//     Any use of this source code must include,  in the user documenta-
//     tion and  internal comments to the code,  notices to the end user
//     as follows:
//
//       Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.
//
//     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY
//     OF  THIS SOURCE  CODE  FOR ANY PURPOSE.  IT IS  PROVIDED  "AS IS"
//     WITHOUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPOR-
//     ATION DISCLAIMS ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,
//     INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY, NONINFRINGE-
//     MENT,  AND FITNESS  FOR A PARTICULAR PURPOSE.   IN NO EVENT SHALL
//     NVIDIA, CORPORATION  BE LIABLE FOR ANY SPECIAL,  INDIRECT,  INCI-
//     DENTAL, OR CONSEQUENTIAL DAMAGES,  OR ANY DAMAGES  WHATSOEVER RE-
//     SULTING FROM LOSS OF USE,  DATA OR PROFITS,  WHETHER IN AN ACTION
//     OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  ARISING OUT OF
//     OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOURCE CODE.
//
//     U.S. Government  End  Users.   This source code  is a "commercial
//     item,"  as that  term is  defined at  48 C.F.R. 2.101 (OCT 1995),
//     consisting  of "commercial  computer  software"  and  "commercial
//     computer  software  documentation,"  as such  terms  are  used in
//     48 C.F.R. 12.212 (SEPT 1995)  and is provided to the U.S. Govern-
//     ment only as  a commercial end item.   Consistent with  48 C.F.R.
//     12.212 and  48 C.F.R. 227.7202-1 through  227.7202-4 (JUNE 1995),
//     all U.S. Government End Users  acquire the source code  with only
//     those rights set forth herein.
//
// ********************************* NV Common ******************************
//
//  Module: nvDbg.h
//      Shared debugging routines for printing, tracing, etc.
//
// **************************************************************************
//
//  History:
//      Matt Lavoie             18Nov00         extracted from d3d
//      Craig Duttweiler        21Nov00         major rehash
//
// **************************************************************************

#ifndef _NVDBG_H_
#define _NVDBG_H_

#ifdef __cplusplus
extern "C" {
#endif

#include "NvTypes.h"

//-------------------------------------------------------------------------
// GLOBAL VARIABLES
//-------------------------------------------------------------------------

#ifdef DEBUG

    extern  int       dbgTrace;   // function call tracing
    extern  NvU32     dbgLevel;   // DPF printing control
    extern  NvU32     dbgLog;     // log DPFs to a file (TRUE/FALSE)
    #define NVDBG_TRACE_EXIT 0x10000000  // prints '.' on function exit

#else

    #define dbgTrace  0
    #define dbgLevel  0
    #define dbgLog    0

#endif

//-------------------------------------------------------------------------
// DEFINTIONS
//-------------------------------------------------------------------------

// printing defaults

#define DPF_START_STR  "NV: "
#define DPF_END_STR    "\r\n"
#define DPF_LOG_FILE   "\\nv.log"

// tracing defaults

#define NV_TRACE_MAX_COLS  76
#define NV_TRACE_MAX_DEPTH 20
#define NV_TRACE_START_STR "TRACE: "

//-------------------------------------------------------------------------
// PROTOTYPES
//-------------------------------------------------------------------------

// debug printing

void __cdecl PF (char *szFormat, ...);      // Available in Debug and Non-Debug Builds

#ifdef DEBUG

    void __cdecl DPF             (char *szFormat, ...);
    void __cdecl DPF_PLAIN       (char *szFormat, ...);
    void __cdecl DPF_LEVEL       (NvU32 dwLevel, char * szFormat, ...);
    void __cdecl DPF_LEVEL_PLAIN (NvU32 dwLevel, char * szFormat, ...);

#else  // !DEBUG

    #define DPF                  1 ? (void)0 : (void)
    #define DPF_PLAIN            1 ? (void)0 : (void)
    #define DPF_LEVEL            1 ? (void)0 : (void)
    #define DPF_LEVEL_PLAIN      1 ? (void)0 : (void)

#endif  // !DEBUG

// tracing

#ifdef DEBUG

    void __cdecl dbgTracePush       (char *szFormat, ...);
    void __cdecl dbgTracePop        (void);
    void __cdecl dbgResetTraceLevel (void);

#elif INSTRUMENT_ALL_CALLS

    void __cdecl dbgTracePush       (char *szFormat, ...);
    void __cdecl dbgTracePop        (void);
    #define      dbgResetTraceLevel()

#else  // !DEBUG && !INSTRUMENT_ALL_CALLS

    #define      dbgTracePush       1 ? (void)0 : (void)
    #define      dbgTracePop()
    #define      dbgResetTraceLevel()

#endif  // !DEBUG && !INSTRUMENT_ALL_CALLS

#ifdef HAVE_NV_FILE_FACILITY
void __cdecl createDPFLog();
void __cdecl closeDPFLog();
#endif


//---------------------------------------------------------------------------
// ERROR HANDLING
//---------------------------------------------------------------------------

#ifdef DEBUG

    int _nvAssertReport(const char *pszExpr, const char *pszFile, const int nLine);

    // The do-while is there so that an nvAssert w/o a semi will not compile
    #define nvAssert(expr)                                                      \
    do {                                                                        \
        if (!(expr) && (_nvAssertReport(#expr, __FILE__, __LINE__)))    \
            _asm int 3                                                          \
    } while(0)

#else  // !DEBUG

    #define nvAssert(expr) ((void)0)

#endif  // !DEBUG

// override normal assert
#undef  assert
#define assert nvAssert

//---------------------------------------------------------------------------

#ifdef DEBUG

    #define dbgError(string)                                                    \
    {                                                                           \
        DPF (string);                                                           \
        _asm int 3                                                              \
    }

#else  // !DEBUG

    #define dbgError(a)

#endif  // !DEBUG

#ifdef __cplusplus
}
#endif // __cplusplus

#endif // _NVDBG_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\common\inc\nvescdef32.h ===
/*
 * nvEscDef32.h
 *
 * Provides definitions for 32 bit views for nVidia ExtEscape strucures into
 * the 64 bit display driver.  Eventually we'll have a single source file.
 *
 * Copyright (c) 2000, Nvidia Corporation.  All rights reserved.
 * Portions Copyright (c) 1996, 1997, Silicon Graphics Inc.
 *
 * THE INFORMATION CONTAINED HEREIN IS PROPRIETARY AND CONFIDENTIAL TO
 * NVIDIA, CORPORATION.  USE, REPRODUCTION OR DISCLOSURE TO ANY THIRD PARTY
 * IS SUBJECT TO WRITTEN PRE-APPROVAL BY NVIDIA, CORPORATION.
 */

#ifndef NV_ESC_DEF32_INCLUDED
#define NV_ESC_DEF32_INCLUDED

typedef struct _NV_PRIMARY_INFO32
{
    ULONG          ulNVSignature;    // IN
    ULONG          ulNumDevices;     // IN
    ULONG          ulHeadNum;        // IN
    ULONG          ulReturnCode;     // IN
    ULONG          ulWidth;          // OUT from display driver
    ULONG          ulHeight;         // OUT from display driver
    ULONG          ulDepth;          // OUT from display driver
    ULONG          ulPitch;          // OUT from display driver
    ULONG          ulPrimaryOffset;  // OUT from display driver
    ULONG          ulNumDACs;        // OUT from display driver (NT only)
    ULONG          ulNumActiveDACs;  // OUT from display driver
    ULONG          ulActiveDACs;     // OUT from display driver (NT only)
    ULONG * __ptr32 ulPanningPtr;    // OUT from display driver (9x only)
    ULONG * __ptr32 ulFullscreenPtr; // OUT from display driver (9x only)
} NV_PRIMARY_INFO32;

typedef struct _NV_OPENGL_COMMAND32
{
    ULONG          NVSignature;
    ULONG          command;           // Handle to resource manager client used in NvFree
    ULONG          numDevices;        // Number of devices in the system
    VOID * __ptr32 hWnd;              // Window handle
    VOID * __ptr32 hDC;               // GDI device context handle
    ULONG          hClient;           // Handle to resource manager client
    ULONG          processHandle;     // Process handle from client associated with globalData
    VOID * __ptr32 globalData;        // Pointer to global shared data for destroy
    VOID * __ptr32 other;             // Pointer to whatever
} NV_OPENGL_COMMAND32;

typedef struct _NV_OPENGL_CLIP_LIST_DATA32
{
    int            clipChangedCount;
    int            rgnDataSize;
    void * __ptr32 rgnData;
    void * __ptr32 rect;
} NV_OPENGL_CLIP_LIST_DATA32;

typedef struct _NV_WNDOBJ_SETUP32
{
    ULONG          NVSignature;
    VOID * __ptr32 hWnd;                // Handle to window
    VOID * __ptr32 hDC;                 // handle to GDI device context
    ULONG          numDevices;          // Number of devices in the system
    PIXELFORMATDESCRIPTOR pfd;
} NV_WNDOBJ_SETUP32;

typedef struct {
    ULONG          type;
    CHAR * __ptr32 keyName;
    VOID * __ptr32 keyVal;
    ULONG          keyValSize;
    ULONG          keyValMaxSize;
    ULONG          retStatus;
} *__PNVRegKeyInfo32, __NVRegKeyInfo32;

#endif // NV_ESC_DEF32_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\common\inc\nvEscDef.h ===
/*
 * nvEscDef.h
 *
 * Provides definitions for nVidia ExtEscape calls into display driver.
 *
 * Copyright (c) 1998, Nvidia Corporation.  All rights reserved.
 * Portions Copyright (c) 1996, 1997, Silicon Graphics Inc.
 *
 * THE INFORMATION CONTAINED HEREIN IS PROPRIETARY AND CONFIDENTIAL TO
 * NVIDIA, CORPORATION.  USE, REPRODUCTION OR DISCLOSURE TO ANY THIRD PARTY
 * IS SUBJECT TO WRITTEN PRE-APPROVAL BY NVIDIA, CORPORATION.
 */

#ifndef NV_ESC_DEF_INCLUDED
#define NV_ESC_DEF_INCLUDED


////////////////////////////////////////////////////////////////////////
// nVidia private escapes

////////////////////////////////////////////////////////////////////////
// Bit to distinguish between 32 and 64 bit process
// (Make them the same for now until implementation is complete).

#define NV_ESC_64_BASE                  0x0000
#define NV_ESC_32_BASE                  0x0000

#if defined(_WIN64)
#define NV_ESC_BASE                     NV_ESC_64_BASE
#else
#define NV_ESC_BASE                     NV_ESC_32_BASE
#endif

////////////////////////////////////////////////////////////////////////
// Escapes destined for the Resource Manager

#ifdef UNIX
#define NV_ESC_RM_BASE                  0x0000
#else
#define NV_ESC_RM_BASE                  0x7000
#endif

#define NV_ESC_RM_OPEN                  (NV_ESC_RM_BASE + 0x20)
#define NV_ESC_RM_CLOSE                 (NV_ESC_RM_BASE + 0x21)
#define NV_ESC_RM_ALLOC_ROOT            (NV_ESC_RM_BASE + 0x22)
#define NV_ESC_RM_ALLOC_DEVICE          (NV_ESC_RM_BASE + 0x23)
#define NV_ESC_RM_ALLOC_CONTEXT_DMA     (NV_ESC_RM_BASE + 0x24)
#define NV_ESC_RM_ALLOC_CHANNEL_PIO     (NV_ESC_RM_BASE + 0x25)
#define NV_ESC_RM_ALLOC_CHANNEL_DMA     (NV_ESC_RM_BASE + 0x26)
#define NV_ESC_RM_ALLOC_MEMORY          (NV_ESC_RM_BASE + 0x27)
#define NV_ESC_RM_ALLOC_OBJECT          (NV_ESC_RM_BASE + 0x28)
#define NV_ESC_RM_FREE                  (NV_ESC_RM_BASE + 0x29)
#define NV_ESC_RM_DMA_PUSH_INFO         (NV_ESC_RM_BASE + 0x2A)
#define NV_ESC_RM_ALLOC                 (NV_ESC_RM_BASE + 0x2B)
#define NV_ESC_RM_CONFIG_VERSION        (NV_ESC_RM_BASE + 0x31)
#define NV_ESC_RM_CONFIG_GET            (NV_ESC_RM_BASE + 0x32)
#define NV_ESC_RM_CONFIG_SET            (NV_ESC_RM_BASE + 0x33)
#define NV_ESC_RM_CONFIG_UPDATE         (NV_ESC_RM_BASE + 0x34)
#define NV_ESC_RM_ARCH_HEAP             (NV_ESC_RM_BASE + 0x35)
#define NV_ESC_RM_DEBUG_CONTROL         (NV_ESC_RM_BASE + 0x36)
#define NV_ESC_RM_CONFIG_GET_EX         (NV_ESC_RM_BASE + 0x37)
#define NV_ESC_RM_CONFIG_SET_EX         (NV_ESC_RM_BASE + 0x38)
#define NV_ESC_RM_I2C_ACCESS            (NV_ESC_RM_BASE + 0x39)
#define NV_ESC_RM_POWER_MANAGEMENT      (NV_ESC_RM_BASE + 0x3A)
#define NV_ESC_RM_INTERRUPT             (NV_ESC_RM_BASE + 0x3B)
#define NV_ESC_RM_OS_CONFIG_GET         (NV_ESC_RM_BASE + 0x3C)
#define NV_ESC_RM_OS_CONFIG_SET         (NV_ESC_RM_BASE + 0x3D)
#define NV_ESC_RM_OS_CONFIG_GET_EX      (NV_ESC_RM_BASE + 0x3E)
#define NV_ESC_RM_OS_CONFIG_SET_EX      (NV_ESC_RM_BASE + 0x3F)
#define NV_ESC_RM_NVWATCH               (NV_ESC_RM_BASE + 0x40)
#define NV_ESC_RM_ALLOC_EVENT           (NV_ESC_RM_BASE + 0x44)

#ifdef UNIX
#define NV_ESC_RM_AGP_INIT              (NV_ESC_RM_BASE + 0x45)
#define NV_ESC_RM_AGP_TEARDOWN          (NV_ESC_RM_BASE + 0x46)
#define NV_ESC_RM_IO_FLUSH              (NV_ESC_RM_BASE + 0x47)
#endif
#define NV_ESC_RM_SWAP_EXT              (NV_ESC_RM_BASE + 0x49)

////////////////////////////////////////////////////////////////////////
// Nvidia OpenGL client information.

#define WNDOBJ_SETUP                            4354

#define ESC_NV_OPENGL_DMA_PUSH_GO               0x7001

#define ESC_NV_OPENGL_ESCAPE                      0x7101 // nVidia OpenGL escape
#define ESC_NV_OPENGL_DESTROY_DRAWABLE            0x0002 // destroy drawable client information
#define ESC_NV_OPENGL_START_STATE_CLIENT_TRACKING 0x0003  // start tracking of state->hClient
#define ESC_NV_OPENGL_STOP_STATE_CLIENT_TRACKING  0x0004 // stop tracking of state->hClient
#define ESC_NV_OPENGL_DMA_PUSH_GO_CMD             0x0005 // NV3 DMA push go command
#define ESC_NV_OPENGL_MEM_TO_SCREEN_SRCCOPY       0x0006 // memory to screen copy
#define ESC_NV_OPENGL_SCREEN_TO_SCREEN_SRCCOPY    0x0007 // screen to screen copy
#define ESC_NV_OPENGL_SUPPORT_ENABLED             0x0008 // OpenGL ICD enabled or NOT!
#define ESC_NV_OPENGL_ALLOC_SHARED_MEMORY         0x0009 // create shared memory area
#define ESC_NV_OPENGL_FREE_SHARED_MEMORY          0x000A // free shared memory area
#define ESC_NV_OPENGL_GET_DISPLAY_PITCH           0x000B // return pitch of display
#define ESC_NV4_OPENGL_SWAP_BUFFERS               0x000C // NV4 swap buffers...
#define ESC_NV4_OPENGL_FLUSH                      0x000D // NV4 flush...
#define ESC_NV_OPENGL_PURGE_DEVICE_BITMAP         0x000E // purge GDI device bitmaps...
#define ESC_NV_OPENGL_FLUSH                       0x000F // NV10 and up style flush...
#define ESC_NV_OPENGL_SWAP_BUFFERS                0x0010 // NV10 and up style swap buffers...
#define ESC_NV_OPENGL_CPUBLIT                     0x0011 // Generic CPU blit. Currently used for buffer region Ext.
#define ESC_NV_OPENGL_INIT_STATE                  0x0012 // Initialize HW state from the display driver side
#define ESC_NV_OPENGL_ALLOC_UNIFIED_SURFACES      0x0021 // alloc single back/depth in GDI display driver
#define ESC_NV_OPENGL_FREE_UNIFIED_SURFACES       0x0022 // free single back/depth in GDI display driver
#define ESC_NV_OPENGL_GET_SURFACE_INFO            0x0023 // get offset for single back
#define ESC_NV_OPENGL_DID_STATUS_CHANGE           0x0029 // clip list status call
#define ESC_NV_OPENGL_GET_CLIP_LIST_COUNT         0x002A // return count of rectangles in clip list
#define ESC_NV_OPENGL_GET_CLIP_LIST               0x002B // return list of rectangles for window clip
#define ESC_NV_OPENGL_SUPPORT                     0x002C // return TRUE if OpenGL supported...
#define ESC_NV_OPENGL_REGISTER_RM_CLIENT          0x002D // register RM client with display driver
#define ESC_NV_OPENGL_UNREGISTER_RM_CLIENT        0x002E // unregister RM client with display driver
#define ESC_NV_OPENGL_SET_DAC_BASE                0x002F // set the display base offset
#define ESC_NV_OPENGL_SYNC_CHANNEL                0x0030 // wait for FIFO and graphics engine to be !busy
#define ESC_NV_OPENGL_SET_LAYER_PALETTE           0x0031 // Overlay specific: set palette entries in the DD
#define ESC_NV_OPENGL_GET_LAYER_PALETTE           0x0032 // Overlay specific: get palette entries from the DD
#define ESC_NV_OPENGL_OVERLAY_MERGEBLIT           0x0033 // Overlay specific: do the merge blit fm+fo->scratch->primary
#define ESC_NV_OPENGL_PFD_CHECK                   0x0034 // Retrieve some caps from the driver
#define ESC_NV_OPENGL_COMMAND                     0x0035 // Command interface for e.g. locked clears
#define ESC_NV_OPENGL_SHARED_LIBRARY_SIZES        0x0036 // check __GLNVstate and __GLdrawablePrivate sizes
#define ESC_NV_OPENGL_NT4_GET_NUMBER_OF_MONITORS  0x0037 // multimon escape for NT4 
#define ESC_NV_OPENGL_NT4_GET_DEVICE_HANDLE       0x0038 // multimon escape for NT4
#define ESC_NV_OPENGL_NT4_GET_DEVICE_RECT         0x0039 // multimon escape for NT4
#define ESC_NV_OPENGL_NT4_GDI_LOCK                0x0040 // multimon escape for NT4

#define ESC_NV_CONVERT_RING3_TO_RING0             0x7200

#undef ESC_NV_OPENGL_MEM_TO_SCREEN_SRCCOPY // uses a separate escape...
#define ESC_NV_OPENGL_MEM_TO_SCREEN_SRCCOPY     0x7102


#define ESC_NV_QUERYSET_REGISTRY_KEY              0x7103
#define NV_QUERY_REGISTRY_KEY                     0x0001
#define NV_SET_REGISTRY_KEY                       0x0002
#define NV_QUERY_REGISTRY_BINARY_KEY              0x0004


#define ESC_NV_MAP_USER                 0x9000
#define ESC_NV_UNMAP_USER               0x9001

#ifndef NV_SIGNATURE
// This value also is defined in driver.h of display driver
#define NV_SIGNATURE 0x11223344
#endif

#define ESC_NV_QUERY_PCI_SLOT                   0x7105
#define ESC_NV_QUERY_HEAD_REFRESH_RATE          0x7106

#ifndef NV_ESC_PRIMARY_INFO
#define NV_ESC_PRIMARY_INFO 0x7104
typedef struct _NV_PRIMARY_INFO
{
    ULONG  ulNVSignature;   // IN
    ULONG  ulNumDevices;    // IN
    ULONG  ulHeadNum;       // IN
    ULONG  ulReturnCode;    // IN
    ULONG  ulWidth;         // OUT from display driver
    ULONG  ulHeight;        // OUT from display driver
    ULONG  ulDepth;         // OUT from display driver
    ULONG  ulPitch;         // OUT from display driver
    ULONG  ulPrimaryOffset; // OUT from display driver
    ULONG  ulNumDACs;       // OUT from display driver (NT only)
    ULONG  ulNumActiveDACs; // OUT from display driver
    ULONG  ulActiveDACs;    // OUT from display driver (NT only)
    ULONG *ulPanningPtr;    // OUT from display driver (9x only)
    ULONG *ulFullscreenPtr; // OUT from display driver (9x only)
} NV_PRIMARY_INFO;
#endif

#ifdef _WIN32 // rest of this file only needed for win32 interfaces

/* The defines for the escapes */
#define	OPENGL_CMD              4352
#define	OPENGL_GETINFO          4353

// Input structure for OPENGL_CMD ExtEscape.

typedef struct _OPENGLCMD
{
    ULONG    ulSubEsc;
    ULONG    fl;
    struct _WNDOBJ   *pwo;
    struct _XLATEOBJ *pxo;
} OPENGLCMD, *POPENGLCMD;

// Flags for OPENGL_CMD ExtEscape.

#define OGLCMD_NEEDWNDOBJ       0x01
#define OGLCMD_NEEDXLATEOBJ     0x02


#define NV_ESC_IS_64BIT_CLIENT   'SIX4'
#define NV_ESC_IS_32BIT_CLIENT   '3TWO'

#if defined(_WIN64)
#define NV_ESC_CLIENT_MODEL NV_ESC_IS_64BIT_CLIENT
#else
#define NV_ESC_CLIENT_MODEL NV_ESC_IS_32BIT_CLIENT
#endif

typedef struct _NV_OPENGL_COMMAND
{
    union                            // offset == 0 
    {
        OPENGLCMD openGLCmd;         // header needed for MS OpenGL escape call                                     
        ULONG     spaceUnifier[8];   // used to make sure the next element is aligned 
                                     // to 4x8bytes in 64 bit and 32 bit environment
    };
                                     // offset == 32
    ULONG       NVClientModel;       // can have only two values NV_ESC_IS_32BIT_CLIENT or NV_ESC_IS_64BIT_CLIENT 
                                     // to make sure it's used in a reliant way
                                     // Note: We can't or NV_ESC_64_BASE onto the escape cmd 
                                     // as long as we use the OPENGL_CMD escape 
                                     // To make life a bit easier the flag has an offset 
                                     // of 32bytes for both 64 and 32 bit Windows (guaranteed by spaceUnifier)
    ULONG       NVSignature;         // offset == 36
    ULONG       command;             // Handle to resource manager client used in NvFree
    ULONG       numDevices;          // Number of devices in the system
    union                            // offset == 48 (must be 8 byte aligned for 64bit Windows)
    { 
        HWND        hWnd;            // Window handle
        __int64     hWndSpaceUnifier;// used to make sure the next element has equal offsets on 
                                     // 64 and 32 bit Windows
    };                                     
    union                            // offset == 56 (must be 8 byte aligned for 64bit Windows)
    { 
        HDC         hDC;             // GDI device context handle
        __int64     hDCSpaceUnifier; // used to make sure the next element has equal offsets on 
                                     // 64 and 32 bit Windows
    };
    ULONG       hClient;             // Handle to resource manager client
    ULONG       processHandle;       // Process handle from client associated with globalData
    union                            // offset == 72 (must be 8 byte aligned for 64bit Windows)
    { 
        PVOID       globalData;      // Pointer to global shared data for destroy
        __int64     gDSpaceUnifier;  // used to make sure the next element has equal offsets on 
                                     // 64 and 32 bit Windows
    };
    union                            // offset == 80 (must be 8 byte aligned for 64bit Windows)
    { 
        PVOID       other;           // Pointer to whatever
        __int64     otherSpaceUnifier;// used to make sure the next element has equal offsets on 
                                     // 64 and 32 bit Windows
    };
    ULONG       devID;               // DevID of current device for NT4 multimon 
    ULONG       useOpenGLCmdEscape;  // use OPENGL_CMD escape if non zero (flush on front buffer 
                                     // rendering, clear, swap buffers)
    LONG        devOriginLeft;       // left origin of device: needed for multimon to identify device  (W2K)
    LONG        devOriginTop;        // top  origin of device: needed for multimon to identify device  (W2K)

} NV_OPENGL_COMMAND;



typedef struct _NV_OPENGL_CLIP_LIST_DATA
{
    int  clipChangedCount;
    int  rgnDataSize;
    void *rgnData;
    void *rect;
} NV_OPENGL_CLIP_LIST_DATA;

typedef struct _NV_OPENGL_GLOBAL_DATA
{
    ULONG oglMutex;
    ULONG oglModeSwitch;
    ULONG oglPFifoAddress;
    ULONG oglSystemMutex;
} NV_OPENGL_GLOBAL_DATA;

typedef struct _NV_WNDOBJ_SETUP
{
    ULONG       NVSignature;
    HWND        hWnd;       /* Handle to window */
    HDC         hDC;        /* handle to GDI device context */
    ULONG       numDevices; /* Number of devices in the system */
    PIXELFORMATDESCRIPTOR pfd;
    ULONG       devID;      // DevID of current device for NT4 multimon 
} NV_WNDOBJ_SETUP;

#define NV_CLIP_MUTEX_WAIT_IN_SECONDS       10 // 10 milliseconds
#define NV_WINDOW_CLIP_FULLYVISIBLE         0x0001
#define NV_WINDOW_CLIP_OCCLUDED             0x0002
#define NV_WINDOW_CLIP_SINGLERECTANGLE      0x0004
#define NV_WINDOW_CLIP_COMPLEX              0x0008
#define NV_WINDOW_CLIP_FULLSCREEN           0x0010
#define MAX_OGL_CLIP_RECTS                  250
#define MAX_OGL_CLIENTS                     512

// The following structure lives in shared memory between the display driver
// and OpenGL.  Put shared items in the front to ensure that data items line
// up between a 64 bit display driver and a 32 bit OpenGL client.
// In addition, only the first page (4096 bytes on most systems) is shared.
                                        // 
typedef struct _NV_OPENGL_DRAWABLE_INFO
{
                                        // BEGIN SHARED AREA

    ULONG       clipChangedCount;       // Number of times clip has changed since client registered
    ULONG       clipFlags;              // Clip status for last clip
    ULONG       numClipRects;           // Number of clip rectangles

    ULONG       flipChangedCount;       // Number of times flip has changed 
    int         bFlipping;              // TRUE=client is flipping; FALSE=client is blitting

    ULONG       ulSwapDoneByClient;     // set if the ICD takes care of the swap
                                        // END SHARED AREA

    ULONG       oglMutexPtr;            // Handle to resource manager client used in NvFree
    PVOID       oglGlobalPagePtr;       // Pointer to shared memory
    ULONG       mutexLock;              // Lock on this data structure
    PVOID       pClientInfoMdl;         // MDL for lock down pages
    PVOID       userVirtualAddress;     // user virtual address for clientInfo
    ULONG       hClient;                // handle to resource manager
    HANDLE      hWnd;                   // Handle to window tracked in DrvClipChanged
    HANDLE      hDC;                    // Handle to GDI device context
    LONG        iPixelFormat;           // pixel format associated with this client
    RECT        rect;                   // rectangle of window on screen
    RECTL       windowRect[MAX_OGL_CLIP_RECTS];
                                        // Clip region for client window
    PVOID       origClientDrawableInfoPtr; 
                                        // Original Ptr remembered to free memory

    RECTL       *cachedClipRectList;    // Cache the clip list so that we do not have to merge it
    ULONG       cachedNumClipRects;     // Number of rectangles.
    ULONG       cachedClipListSize;     // Currently allocated size of the clip list.
    BOOL        cachedClipListDirty;    // Flag to determine whether to recompute clip list.
    RECTL       *cachedExclusiveRectList;    // Cache the clip list so that we do not have to merge it
    ULONG       cachedNumExclusiveRects;     // Number of rectangles.
    RECTL       *copyWindowRect;           // Actual clip rectangle pointer used everywhere in NV4+ driver
    ULONG       sizeCopyWindowRectList;    // Size of clip rectangle pointer above.

    ULONG       bOrigClipList;            // TRUE means the original clip list is cached in this structure
    RECTL       *origWindowRectList;      // cache of the original unclipped rectangle list for this window

    ULONG       cxScreen, cyScreen;     // width and height of display
    ULONG       cxcyChanged;

    //
    // The following flag is used when UBB is ON, window flipping is OFF and there are no OGL windows
    // occluding the window this drawable structure references.  This is an optimization for window
    // clipping created for 3D Studio Max.  When 3D Studio Max is in No redraw on expose mode, an expose
    // event will not cause a re-render of the scene.  Compaq workstation did not like this and complained
    // that the image is wrong in comparison to other CAD graphics products.  Since the 3D pixels are 
    // clipped to a GDI window that is occluding our OGL window, it is possible to render those pixels
    // with UBB on without causing scribble.  But for this to work, the occluding window must NOT be a
    // OGL window and window flipping must be off.
    //
    // This flag is computed as part of the DrvClipChanged function.
    //
    ULONG       ubbWindowClipFlag;      // TRUE means use window bounds for clip; otherwise use copyWindowRect list
    ULONG       refCount;               // mainplane+overlay track the same window!, so we need a refCount, to securely destroy the drawable
    int         overlayMember;
    } NV_OPENGL_DRAWABLE_INFO;

typedef struct _NV_OPENGL_CONTEXT_INFO
    {
    HWND        hWnd;                   // Window/drawable associated with context
    HDC         hDC;                    // GDI device context
    ULONG       hClient;                // Handle to resource manager client
    } NV_OPENGL_CONTEXT_INFO;

// WARNING! This structure is shared with NT display driver in driver.h
#define OGL_ERROR_NO_ERROR             0x0000
#define OGL_ERROR_MODE_SWITCH          0x0001
#define OGL_ERROR_CLIENT_NOT_FOUND     0x0002
#define OGL_ERROR_CLIP_MUTEX_TIMEOUT   0x0003
#define OGL_ERROR_CLIP_LIST_BAD        0x0004
#define OGL_ERROR_LOAD_BUFFER_INFO     0x0005
#define OGL_ERROR_SIMPLE_TO_COMPLEX    0x0006
#define OGL_ERROR_COMPLEX_TO_SIMPLE    0x0007
#define OGL_ERROR_REALLOC_FAILURE      0x0008
#define OGL_ERROR_NO_SWAP              0x0009
#define OGL_ERROR_WINDOW_CHANGED_COUNT 0x000A
#define OGL_ERROR_SURFACE_INVALID      0x000B

#define OGL_ERROR_CLIP_CHANGE_NOTIFY   0x000C


#define NV_BLIT_MEM_TO_SCR 1
#define NV_BLIT_SCR_TO_MEM 2
typedef struct {
    ULONG       blitType;
    ULONG       useClipList;
    PVOID       pSrcBase; 
    ULONG       dwSrcByteWidth; 
    ULONG       dwSrcElementSize;
    ULONG       dstOffset; // offset in frame buffer
    PVOID       pDstBase; 
    ULONG       dwDstByteWidth; 
    ULONG       dwDstElementSize;
    ULONG       dwSrcLeft; 
    ULONG       dwSrcTop;
    ULONG       dwDstLeft; 
    ULONG       dwDstTop;
    ULONG       dwWidth; 
    ULONG       dwHeight;
    ULONG       retStatus;
} __GLNvCpuBltData;

typedef struct {
    ULONG       type;
    PCHAR       keyName;
    PVOID       keyVal;
    ULONG       keyValSize;
    ULONG       keyValMaxSize;
    ULONG       retStatus;
    ULONG       devID;               // DevID of current device for NT4 multimon 
} *__PNVRegKeyInfo, __NVRegKeyInfo;


// Desktop Manager private escapes
#define ESC_NV_DESKMGR_ZOOMBLIT         0x7107

#define NVDM_ESC_BLIT_VIDMEM            0x00000000
#define NVDM_ESC_BLIT_SYSMEM            0x00000001
#define NVDM_ESC_BLIT_SMOOTH            0x00000002

typedef struct {
    ULONG flags;
    int scale;
    union {
        RECTL srcRect;
        struct {
            ULONG format;
            int stride;
            PVOID bits;
        } srcMem;
    };
    RECTL dstRect;
    int clips;
    RECTL clipRects[1];
} __NVDMEscapeParams;


// ESC_NV_WKS_APP_SUPPORT - BEGIN
//
// Workstation application support escape
//
// The ESC_NV_WKS_APP_SUPPORT escape supports a couple of sub escapes through
// a common interface!
//
// WARNING:
//   Never change the escape number ESC_NV_WKS_APP_SUPPORT! 
//   This will break QuadroView, MaxTreme, PowerDraft and all other workstation apps!
//
// NOTES: 
// - all ExtEscape in-structures need to use NV_WKS_HEAD_IN at top of the structure
// - all out structures need to use NV_WKS_HEAD_OUT at top of the structure
// - all in and out structures must be initialized with 0 to clear unused members
// - changes to the interface structures must be downwards compatible
// - never change the size of a existing structure or the arrangement of the members
// - always check the exact strucure size and fail if not the same
// - if lResult returns an error only the NV_WKS_HEAD_OUT struct is valid and the 
//   members of the structure are used to specify the error (see error description)
#define ESC_NV_WKS_APP_SUPPORT          0x7108

//
// supported subescapes
//
                                          // 0x0000 unused
#define SUBESC_WKS_GET_CAPS                  0x0001 // uses NV_WKS_GET_CAPS_IN as in and NV_WKS_GET_CAPS_OUT as out structure 
#define SUBESC_WKS_WINDOW_STEREOMODE         0x0002 // uses NV_WKS_WINDOW_STEREOMODE_IN as in, and NULL as NV_WKS_WINDOW_STEREOMODE_OUT as out structure
//      add new subescapes here:             0x0003


//
// Common in and out header structures that must be used by all in and out structures
//

// must be used by all in structures
typedef struct _NV_WKS_HEAD_IN
{
    ULONG ulInSize;     // Length of entire in structure, e.g. sizeof(NV_WKS_GET_CAPS_IN)
    ULONG ulSubEsc;     // has to be (SUBESC_WKS_GET_CAPS, ...)
    ULONG ulOutSize;    // size of entire output data structure or 0 ()
    ULONG ulVersion;    // initialize with NV_WKS_VERSION; Version of ESC_NV_WKS_APP_SUPPORT interface
                        
    ULONG ulBoard;      // Calls that affect all boards use NV_WKS_ALLBOARDS to initialize dwBoard
                        // 0 -> board 0, 1 -> board 1, ET_ALL_BOARDS -> all boards (broadcast)  

    // reserved members are not allowed to be used!
    ULONG ulReserved0;
    ULONG ulReserved1;  // reserved for future extensions
    ULONG ulReserved2;
} NV_WKS_HEAD_IN;

// must be used by all out structures
typedef struct _NV_WKS_HEAD_OUT
{
    ULONG ulSize;       // Length of entire out structure, e.g. sizeof(NV_WKS_GET_CAPS_OUT)
                        // Should be same as NV_WKS_HEAD_IN.ulOutSize!
                        // NOTE: In error case used perhaps other meaning (see error description)!
    ULONG ulVersion;    // initialize with NV_WKS_VERSION; Version of ESC_NV_WKS_APP_SUPPORT interface
    LONG  lResult;      // If escapes succeeds ulResult contains more status information

    // reserved members are not allowed to be used!
    ULONG ulReserved0;  // reserved for future extensions
} NV_WKS_HEAD_OUT;

//
// defines for header variables
//
// NV_WKS_HEAD_IN.ulVersion, NV_WKS_HEAD_OUT.ulVersion
#define NV_WKS_VERSION                          1          // intial version

// NV_WKS_HEAD_IN.ulBoard
#define NV_WKS_ALLBOARDS                        0xFFFFFFFF // broadcast to all boards, 

// return values for NV_WKS_HEAD_OUT.lResult

// Success values lResult > 0
#define NV_WKS_RESULT_SUCCESS                      1 // wks escape succeeded

#define NV_WKS_RESULT_NOT_ALLOWED                  0 // unused valued, HEAD_OUT isn't valid at all!

// Error values lResult < 0
#define NV_WKS_RESULT_ERROR                       -1 // any unspecified error
#define NV_WKS_RESULT_ERROR_SUBESC_NOT_SUPPORTED  -2 // unsupported subescape
#define NV_WKS_RESULT_ERROR_INSIZE                -3 // input buffer has wrong size, expected size in NV_WKS_HEAD_OUT.ulSize
#define NV_WKS_RESULT_ERROR_OUTSIZE               -4 // output buffer has wrong size, expected size in NV_WKS_HEAD_OUT.ulSize
#define NV_WKS_RESULT_ERROR_INTERFACE             -5 // inconsisty in usage of interface, values in HEAD_IN do not match cjIn, cjOut, ...
#define NV_WKS_RESULT_ERROR_PARAMETER             -6 // interface correct, but a parameter is wrong and the escape couldn't be handled

// define that c
#define NV_WKS_INIT_HEAD_IN(pHdr, subEsc, sizeIn, sizeOut, board)   \
    ((NV_WKS_HEAD_IN *)(pHdr))->ulSubEsc  = subEsc;                 \
    ((NV_WKS_HEAD_IN *)(pHdr))->ulInSize  = sizeIn;                 \
    ((NV_WKS_HEAD_IN *)(pHdr))->ulOutSize = sizeOut;                \
    ((NV_WKS_HEAD_IN *)(pHdr))->ulVersion = NV_WKS_VERSION;         \
    ((NV_WKS_HEAD_IN *)(pHdr))->ulBoard   = board;


//
// SUBESC_WKS_GET_CAPS 
//
// Query workstation graphics capabilities.
//
// Example code can be found in .\drivers\display\winnt4\displays\nv_disp\wksappsupport.c
//
// input structure
typedef struct _NV_WKS_GET_CAPS_IN
{
    NV_WKS_HEAD_IN hdr;
} NV_WKS_GET_CAPS_IN;

// output structure
typedef struct _NV_WKS_GET_CAPS_OUT
{
    NV_WKS_HEAD_OUT hdr;

    ULONG flGraphicsCaps; // NV_WKS_GRAPHICS_CAPS_*, nearly same as NvRmConfigGet(NV_CFG_GRAPHICS_CAPS)
    ULONG ulMaxClipRects; // number of supported clip rects
    ULONG flWksCaps;      // NV_WKS_CAPS_*, workstation capabilities

    // reserved members are not allowed to be used!
    ULONG ulReserved0;    // reserved for future extensions
} NV_WKS_GET_CAPS_OUT;

// defines used in NV_WKS_GET_CAPS_OUT.flGraphicsCaps
#define NV_WKS_GRAPHICS_CAPS_AA_LINES           0x00000001 //NOTE: != NV_CFG_GRAPHICS_CAPS_AA_LINES
#define NV_WKS_GRAPHICS_CAPS_AA_POLYS           0x00000002
#define NV_WKS_GRAPHICS_CAPS_AKILL_USERCLIP     0x00000004
#define NV_WKS_GRAPHICS_CAPS_LOGIC_OPS          0x00000008
#define NV_WKS_GRAPHICS_CAPS_NV15_ALINES        0x00000010
#define NV_WKS_GRAPHICS_CAPS_2SIDED_LIGHTING    0x00000020
#define NV_WKS_GRAPHICS_CAPS_QUADRO_GENERIC     0x00000040
#define NV_WKS_GRAPHICS_CAPS_UBB                0x00000080

// defines used in NV_WKS_GET_CAPS_OUT.flWksCaps
#define NV_WKS_CAPS_WORKSTATION_BOARD           0x00000001
#define NV_WKS_CAPS_STERO_CAPABLE               0x00000010
#define NV_WKS_CAPS_OVERLAY_CAPABLE             0x00000020


//
// SUBESC_WKS_WINDOW_STEREOMODE
//
// Interface for workstation apps to enable/disable stereo toggle and 
// double pumping for a given window wiht a stereo-pfd
//
// Example code can be found in .\drivers\display\winnt4\displays\nv_disp\wksappsupport.c
//
// input structure
typedef struct _NV_WKS_WINDOW_STEREOMODE_IN
{
    NV_WKS_HEAD_IN hdr;

    PVOID          hwnd;   // handle of window to modify/query. If NULL current driver status is returned
    ULONG          ulMode; // NV_WKS_WINDOW_STEREOMODE_QUERY, NV_WKS_WINDOW_STEREOMODE_ENABLE, NV_WKS_WINDOW_STEREOMODE_DISABLE
} NV_WKS_WINDOW_STEREOMODE_IN;

// output structure
typedef struct _NV_WKS_WINDOW_STEREOMODE_OUT
{
    NV_WKS_HEAD_OUT hdr;

    PVOID           hwnd;   // handle of window queried, or NULL if not specified.
    ULONG           ulMode; // NV_WKS_WINDOW_STEREOMODE_ENABLED, NV_WKS_WINDOW_STEREOMODE_DISABLED, ...
} NV_WKS_WINDOW_STEREOMODE_OUT;

// IN.ulMode
#define NV_WKS_WINDOW_STEREOMODE_DISABLE           0 // disable stereo mode for IN.hwnd (must be valid stereo window)
#define NV_WKS_WINDOW_STEREOMODE_ENABLE            1 // enable stereo mode for IN.hwnd (must be valid stereo window)
#define NV_WKS_WINDOW_STEREOMODE_QUERY             2 // query status of IN.hwnd or system if IN.hwnd==NULL

// OUT.ulMode
#define NV_WKS_WINDOW_STEREOMODE_UNUSED            0 // value not set by driver, ignore value
#define NV_WKS_WINDOW_STEREOMODE_DISABLED          1 // stereo is disabled for OUT.hwnd
#define NV_WKS_WINDOW_STEREOMODE_ENABLED           3 // stereo is enabled for OUT.hwnd
#define NV_WKS_WINDOW_STEREOMODE_INVALID_HWND      4 // couldn't find hwnd in client list
#define NV_WKS_WINDOW_STEREOMODE_NO_STEREO_HWND    5 // hwnd isn't a stero window
#define NV_WKS_WINDOW_STEREOMODE_NO_STEREO         6 // currently no stereo active


// ESC_NV_WKS_APP_SUPPORT - END

#endif // _WIN32

#endif // NV_ESC_DEF_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\common\inc\nvfilenames.h ===
/*==========================================================================;
 *
 *  Copyright (C) 1995, 1999 NVidia Corporation. All Rights Reserved.
 *
 *  File:       files.h
 *  Content:    Contains defines for the various binary filenames
 *
 ***************************************************************************/

/*NV3 binaries*/
#define NV3_DDRAW_BINARY		"NV3DD32.DLL"
#define NV3_DISPLAY_BINARY		"NV3DISP.DRV"
#define NV3_OPENGL_BINARY		"NV3OGL.DLL"
#define NV3_MINIVDD_BINARY		"NV3.VXD"
#define NV3_MINIVDD2_BINARY		"NV3MINI2.VXD"
#define NV3_RM_32_BINARY		"NV3API.DLL"
#define NV3_RM_16_BINARY		"NV3SYS.DLL"
#define NV3_RM_KERNEL_BINARY		"NV3RM.VXD"
#define NV3_QUICK_TWEAK_BINARY		"NV3QTWK.DLL"
#define NV3_TWEAK_BINARY		"NV3TWEAK.DLL"
#define NV3_TWEAK_HELP_BINARY		"NV3TWEAK.HLP"

/*NV4 binaries*/
#define NV4_DDRAW_BINARY		"NVDD32.DLL"
#define NV4_DISPLAY_BINARY		"NVDISP.DRV"
#define NV4_MODESET_BINARY		"NVMODE.DLL"
#define NV4_OPENGL_BINARY		"NVOPENGL.DLL"
#define NV4_MINIVDD_BINARY		"NVMINI.VXD"
#define NV4_MINIVDD2_BINARY		"NVMINI2.VXD"
#define NV4_RM_32_BINARY		"NVARCH32.DLL"
#define NV4_RM_16_BINARY		"NVARCH16.DLL"
#define NV4_RM_KERNEL_BINARY		"NVCORE.VXD"
#define NV4_QUICK_TWEAK_BINARY		"NVQTWK.DLL"
#define NV4_STERCP_BINARY           "NVSTERCP.DLL"
#define NV4_TWEAK_BINARY		    "NVCPL.DLL"
#define NV4_TWEAK_SVC_BINARY        "NVSVC.EXE"
#define NV4_DESK_MGR_BINARY         "NVDESK32.DLL"
#define NV4_DESK_MGR_UI_BINARY      "NVDMCPL.DLL"
#define NV4_FSVM_BINARY		        "NVFSVM.EXE"
#define NV4_TWEAK_HELP_BINARY		"NVCPL.HLP"
#define NV4_INSTALL_LIB_BINARY      "NVINST32.DLL"
#define NV4_ARABIC_RESOURCE_BINARY	"NVRSAR.DLL"
#define NV4_ARABIC_HELP_BINARY		"NVCPAR.HLP"
#define NV4_CZECH_RESOURCE_BINARY	"NVRSCS.DLL"
#define NV4_CZECH_HELP_BINARY		"NVCPCS.HLP"
#define NV4_DANISH_RESOURCE_BINARY	"NVRSDA.DLL"
#define NV4_DANISH_HELP_BINARY		"NVCPDA.HLP"
#define NV4_GERMAN_RESOURCE_BINARY	"NVRSDE.DLL"
#define NV4_GERMAN_HELP_BINARY		"NVCPDE.HLP"
#define NV4_UKENGLISH_RESOURCE_BINARY	"NVRSENG.DLL"
#define NV4_UKENGLISH_HELP_BINARY	"NVCPENG.HLP"
#define NV4_SPANISH_RESOURCE_BINARY	"NVRSES.DLL"
#define NV4_SPANISH_HELP_BINARY		"NVCPES.HLP"
#define NV4_MSPANISH_RESOURCE_BINARY	"NVRSESM.DLL"
#define NV4_MSPANISH_HELP_BINARY	"NVCPESM.HLP"
#define NV4_LASPANISH_RESOURCE_BINARY	"NVRSES.DLL"
#define NV4_LASPANISH_HELP_BINARY	"NVCPES.HLP"
#define NV4_FINNISH_RESOURCE_BINARY	"NVRSFI.DLL"
#define NV4_FINNISH_HELP_BINARY		"NVCPFI.HLP"
#define NV4_FRENCH_RESOURCE_BINARY	"NVRSFR.DLL"
#define NV4_FRENCH_HELP_BINARY		"NVCPFR.HLP"
#define NV4_CAFRENCH_RESOURCE_BINARY	"NVRSFR.DLL"
#define NV4_CAFRENCH_HELP_BINARY	"NVCPFR.HLP"
#define NV4_GREEK_RESOURCE_BINARY	"NVRSEL.DLL"
#define NV4_GREEK_HELP_BINARY	"NVCPEL.HLP"
#define NV4_HEBREW_RESOURCE_BINARY	"NVRSHE.DLL"
#define NV4_HEBREW_HELP_BINARY	"NVCPHE.HLP"
#define NV4_HUNGARIAN_RESOURCE_BINARY	"NVRSHU.DLL"
#define NV4_HUNGARIAN_HELP_BINARY	"NVCPHU.HLP"
#define NV4_ITALIAN_RESOURCE_BINARY	"NVRSIT.DLL"
#define NV4_ITALIAN_HELP_BINARY		"NVCPIT.HLP"
#define NV4_JAPANESE_RESOURCE_BINARY	"NVRSJA.DLL"
#define NV4_JAPANESE_HELP_BINARY	"NVCPJA.HLP"
#define NV4_KOREAN_RESOURCE_BINARY	"NVRSKO.DLL"
#define NV4_KOREAN_HELP_BINARY		"NVCPKO.HLP"
#define NV4_DUTCH_RESOURCE_BINARY	"NVRSNL.DLL"
#define NV4_DUTCH_HELP_BINARY		"NVCPNL.HLP"
#define NV4_NORWEGIAN_RESOURCE_BINARY	"NVRSNO.DLL"
#define NV4_NORWEGIAN_HELP_BINARY	"NVCPNO.HLP"
#define NV4_POLISH_RESOURCE_BINARY	"NVRSPL.DLL"
#define NV4_POLISH_HELP_BINARY	"NVCPPL.HLP"
#define NV4_PORTUGUESE_RESOURCE_BINARY	"NVRSPT.DLL"
#define NV4_PORTUGUESE_HELP_BINARY	"NVCPPT.HLP"
#define NV4_BPORTUGUESE_RESOURCE_BINARY	"NVRSPTB.DLL"
#define NV4_BPORTUGUESE_HELP_BINARY	"NVCPPTB.HLP"
#define NV4_RUSSIAN_RESOURCE_BINARY	"NVRSRU.DLL"
#define NV4_RUSSIAN_HELP_BINARY		"NVCPRU.HLP"
#define NV4_SLOVAK_RESOURCE_BINARY	"NVRSSK.DLL"
#define NV4_SLOVAK_HELP_BINARY		"NVCPSK.HLP"
#define NV4_SLOVENIAN_RESOURCE_BINARY	"NVRSSL.DLL"
#define NV4_SLOVENIAN_HELP_BINARY		"NVCPSL.HLP"
#define NV4_SWEDISH_RESOURCE_BINARY	"NVRSSV.DLL"
#define NV4_SWEDISH_HELP_BINARY		"NVCPSV.HLP"
#define NV4_THAI_RESOURCE_BINARY	"NVRSTH.DLL"
#define NV4_THAI_HELP_BINARY		"NVCPTH.HLP"
#define NV4_TURKISH_RESOURCE_BINARY	"NVRSTR.DLL"
#define NV4_TURKISH_HELP_BINARY		"NVCPTR.HLP"
#define NV4_SIMCHINESE_RESOURCE_BINARY	"NVRSZHC.DLL"
#define NV4_SIMCHINESE_HELP_BINARY	"NVCPZHC.HLP"
#define NV4_TRDCHINESE_RESOURCE_BINARY	"NVRSZHT.DLL"
#define NV4_TRDCHINESE_HELP_BINARY	"NVCPZHT.HLP"

/*NV4 NT4 binaries*/
#define NV4_DISPLAY_BINARY_NT4		"NV4_DISP.DLL"
#define NV4_OPENGL_BINARY_NT4		"NVOGLNT.DLL"
#define NV4_MINIVDD_BINARY_NT4		"NV4_MINI.SYS"
#define NV4_QUICK_TWEAK_BINARY_NT4   NV4_QUICK_TWEAK_BINARY
#define NV4_TWEAK_BINARY_NT4         NV4_TWEAK_BINARY
#define NV4_TWEAK_HELP_BINARY_NT4    NV4_TWEAK_HELP_BINARY
#define NV4_DESK_MGR_BINARY_NT4      NV4_DESK_MGR_BINARY
#define NV4_TWEAK_SVC_BINARY_NT4     "NVSVC32.EXE"

/* Workstation Application binaries */
#define NV4_POWERDRAFT_BINARY		"NVDS15.DLL"
#define NV4_MAXTREME_BINARY			"MAXtreme.drv"
#define NV4_QUADROVIEW_BINARY		"QUADROVIEW.EXE"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\common\inc\nvDMAC.h ===
// (C) Copyright NVIDIA Corporation Inc., 1996,1998. All rights reserved.

/********************************* Direct 3D *******************************\
*                                                                           *
* Module: NVDMAC.H                                                          *
*   Define various macros used to interact with the hardware                *
*   Please put other more general D3D macros in nvd3dmac or elsewhere!      *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*       Charles Inman (chasi)       1/26/98 - Created                       *
*                                                                           *
\***************************************************************************/

#ifndef _NV4DMAC_H_
#define _NV4DMAC_H_

#ifdef __cplusplus
extern "C" {
#endif

// NV Reference Manual register access definitions.
#define BIT(b)                  (1<<(b))
#define DEVICE_BASE(d)          (0?d)
#define DEVICE_EXTENT(d)        (1?d)
#define DRF_SHIFT(drf)          ((0?drf) % 32)
#define DRF_MASK(drf)           (0xFFFFFFFF>>(31-((1?drf) % 32)+((0?drf) % 32)))
#define DRF_DEF(d,r,f,c)        ((NV ## d ## r ## f ## c)<<DRF_SHIFT(NV ## d ## r ## f))
#define DRF_NUM(d,r,f,n)        (((n)&DRF_MASK(NV ## d ## r ## f))<<DRF_SHIFT(NV ## d ## r ## f))
#define DRF_VAL(d,r,f,v)        (((v)>>DRF_SHIFT(NV ## d ## r ## f))&DRF_MASK(NV ## d ## r ## f))
#define REG_WR_DRF_NUM(d,r,f,n) REG_WR32(NV ## d ## r, DRF_NUM(d,r,f,n))
#define REG_WR_DRF_DEF(d,r,f,c) REG_WR32(NV ## d ## r, DRF_DEF(d,r,f,c))
#define FLD_WR_DRF_NUM(d,r,f,n) REG_WR32(NV##d##r,(REG_RD32(NV##d##r)&~(DRF_MASK(NV##d##r##f)<<DRF_SHIFT(NV##d##r##f)))|DRF_NUM(d,r,f,n))
#define FLD_WR_DRF_DEF(d,r,f,c) REG_WR32(NV##d##r,(REG_RD32(NV##d##r)&~(DRF_MASK(NV##d##r##f)<<DRF_SHIFT(NV##d##r##f)))|DRF_DEF(d,r,f,c))
#define REG_RD_DRF(d,r,f)       (((REG_RD32(NV ## d ## r))>>DRF_SHIFT(NV ## d ## r ## f))&DRF_MASK(NV ## d ## r ## f))

//-------------------------------------------------------------------------
//                 GENERIC DMA PUSH BUFFER OPERATIONS
//-------------------------------------------------------------------------

#define sizeSetObject                       2
#define nvglSetObject(ch, obj)                                              \
{                                                                           \
    nvPushData (0, (0x00040000 | ((ch) << 13)));                            \
    nvPushData (1, obj);                                                    \
    nvPusherAdjust (sizeSetObject);                                         \
}

#define sizeSetStartMethod                  1
#define nvglSetStartMethod(index, ch, method, methodcount)                  \
{                                                                           \
    nvPushData (index, ((((methodcount) << 2) << 16) | ((ch) << 13) | (method))); \
}

#define sizeSetData                         1
#define nvglSetData(index, data)                                            \
{                                                                           \
    nvPushData (index, (data));                                             \
}

#define nvglAdjust(size)                                                    \
{                                                                           \
    nvPusherAdjust (size);                                                  \
}

#define sizeDmaJump         1
#define nvglDmaJump(offset)                                                 \
{                                                                           \
    nvPushData (0, (0x20000000 | (offset)));                                \
    nvPusherAdjust (sizeDmaJump);                                           \
}

//-------------------------------------------------------------------------
//                              NV 002
//                   NV01_CONTEXT_DMA_FROM_MEMORY
//-------------------------------------------------------------------------

#define sizeSetDmaFromMemoryMthdCnt                 3
#define sizeSetDmaFromMemory                        4
#define nvglSetDmaFromMemory(ch, base, selector, limit)                     \
{                                                                           \
    nvPushData (0, (((sizeSetDmaFromMemoryMthdCnt << 2) << 16) | ((ch) << 13) | 0x300)); \
    nvPushData (1, (base));                                                 \
    nvPushData (2, (selector));                                             \
    nvPushData (3, (limit));                                                \
    nvPusherAdjust (sizeSetDmaFromMemory);                                  \
}

#define sizeSetDmaFromMemoryContextNotifyMthdCnt    1
#define sizeSetDmaFromMemoryContextNotify           2
#define nvglSetDmaFromMemoryContextNotify(ch, ctxdmanotify)                 \
{                                                                           \
    nvPushData (0, (((sizeSetDmaFromMemoryContextNotifyMthdCnt << 2) << 16) | ((ch) << 13) | 0x180)); \
    nvPushData (1, (ctxdmanotify));                                         \
    nvPusherAdjust (sizeSetDmaFromMemoryContextNotify);                     \
}

#define sizeSetDmaFromMemoryNotify                  7
#define nvglSetDmaFromMemoryNotify(ch, base, selector, limit, notify)       \
{                                                                           \
    nvPushData (0, (((2 << 2) << 16) | ((ch) << 13) | 0x300));              \
    nvPushData (1, (base));                                                 \
    nvPushData (2, (selector));                                             \
    nvPushData (3, (((1 << 2) << 16) | ((ch) << 13) | 0x104));              \
    nvPushData (4, (notify));                                               \
    nvPushData (5, (((1 << 2) << 16) | ((ch) << 13) | 0x308));              \
    nvPushData (6, (limit));                                                \
    nvPusherAdjust (sizeSetDmaFromMemoryNotify);                            \
}

//-------------------------------------------------------------------------
//                              NV 003
//                    NV01_CONTEXT_DMA_TO_MEMORY
//-------------------------------------------------------------------------

#define sizeSetDmaToMemoryMthdCnt                 3
#define sizeSetDmaToMemory                        4
#define nvglSetDmaToMemory(ch, base, selector, limit)                       \
{                                                                           \
    nvPushData (0, (((sizeSetDmaToMemoryMthdCnt << 2) << 16) | ((ch) << 13) | 0x300)); \
    nvPushData (1, (base));                                                 \
    nvPushData (2, (selector));                                             \
    nvPushData (3, (limit));                                                \
    nvPusherAdjust (sizeSetDmaToMemory);                                    \
}

#define sizeSetDmaToMemoryContextNotifyMthdCnt    1
#define sizeSetDmaToMemoryContextNotify           2
#define nvglSetDmaToMemoryContextNotify(ch, ctxdmanotify)                   \
{                                                                           \
    nvPushData (0, (((sizeSetDmaToMemoryContextNotifyMthdCnt << 2) << 16) | ((ch) << 13) | 0x180)); \
    nvPushData (1, (ctxdmanotify));                                         \
    nvPusherAdjust (sizeSetDmaToMemoryContextNotify);                       \
}

#define sizeSetDmaToMemoryNotify                  7
#define nvglSetDmaToMemoryNotify(ch, base, selector, limit, notify)         \
{                                                                           \
    nvPushData (0, (((2 << 2) << 16) | ((ch) << 13) | 0x300));              \
    nvPushData (1, (base));                                                 \
    nvPushData (2, (selector));                                             \
    nvPushData (3, (((1 << 2) << 16) | ((ch) << 13) | 0x104));              \
    nvPushData (4, (notify));                                               \
    nvPushData (5, (((1 << 2) << 16) | ((ch) << 13) | 0x308));              \
    nvPushData (6, (limit));                                                \
    nvPusherAdjust (sizeSetDmaToMemoryNotify);                              \
}

//-------------------------------------------------------------------------
//                              NV 019
//                    NV01_CONTEXT_CLIP_RECTANGLE
//-------------------------------------------------------------------------

#define sizeSetClipMthdCnt                          2
#define sizeSetClip                                 3
#define nvglSetClip(ch, x, y, w, h)                                         \
{                                                                           \
    nvPushData (0, (((sizeSetClipMthdCnt << 2) << 16) | ((ch) << 13) | NV019_SET_POINT)); \
    nvPushData (1, ((DWORD)y << 16) | (DWORD)x);                            \
    nvPushData (2, ((DWORD)h << 16) | (DWORD)w);                            \
    nvPusherAdjust (sizeSetClip);                                           \
}

//-------------------------------------------------------------------------
//                              NV 042
//                     NV04_CONTEXT_SURFACES_2D
//-------------------------------------------------------------------------

#define sizeSet2DSurfacesNoOpMthdCnt    1
#define sizeSet2DSurfacesNoOp           2
#define nvglSet2DSurfacesNoOp(ch)                                           \
{                                                                           \
    nvPushData (0, (((sizeSet2DSurfacesNoOpMthdCnt << 2) << 16) | ((ch) << 13) | NV042_NO_OPERATION)); \
    nvPushData (1, 0);                                                      \
    nvPusherAdjust (sizeSet2DSurfacesNoOp);                                 \
}

#define sizeSet2DSurfacesContextsMthdCnt            2
#define sizeSet2DSurfacesContexts                   3
#define nvglSet2DSurfacesContexts(ch, ctxsrc, ctxdest)                      \
{                                                                           \
    nvPushData (0, (((sizeSet2DSurfacesContextsMthdCnt << 2) << 16) | ((ch) << 13) | NV042_SET_CONTEXT_DMA_IMAGE_SOURCE)); \
    nvPushData (1, (ctxsrc));                                               \
    nvPushData (2, (ctxdest));                                              \
    nvPusherAdjust (sizeSet2DSurfacesContexts);                             \
}

#define sizeSet2DSurfacesColorFormatMthdCnt         1
#define sizeSet2DSurfacesColorFormat                2
#define nvglSet2DSurfacesColorFormat(ch, format)                            \
{                                                                           \
    if (pDriverData->bltData.dwLastColourFormat != format) {                \
        nvPushData (0, (((sizeSet2DSurfacesColorFormatMthdCnt << 2) << 16) | ((ch) << 13) | NV042_SET_COLOR_FORMAT)); \
        nvPushData (1, (format));                                           \
        nvPusherAdjust (sizeSet2DSurfacesColorFormat);                      \
        pDriverData->bltData.dwLastColourFormat = format;                   \
    }                                                                       \
}

#define sizeSet2DSurfacesPitchMthdCnt               1
#define sizeSet2DSurfacesPitch                      2
#define nvglSet2DSurfacesPitch(ch, srcpitch, dstpitch)                      \
{                                                                           \
DWORD dwCombinedPitch = ((((dstpitch) & 0x0000FFFF) << 16) | ((srcpitch) & 0x0000FFFF));   \
    if (pDriverData->bltData.dwLastCombinedPitch != dwCombinedPitch) {      \
        nvPushData (0, (((sizeSet2DSurfacesPitchMthdCnt << 2) << 16) | ((ch) << 13) | NV042_SET_PITCH)); \
        nvPushData (1, dwCombinedPitch);                                    \
        nvPusherAdjust (sizeSet2DSurfacesPitch);                            \
        pDriverData->bltData.dwLastCombinedPitch = dwCombinedPitch;         \
    }                                                                       \
}

#define sizeSet2DSurfacesDestinationMthdCnt         1
#define sizeSet2DSurfacesDestination                2
#define nvglSet2DSurfacesDestination(ch, offset)                            \
{                                                                           \
    if (pDriverData->bltData.dwLastDstOffset != offset) {                   \
        nvPushData (0, (((sizeSet2DSurfacesDestinationMthdCnt << 2) << 16) | ((ch) << 13) | NV042_SET_OFFSET_DESTIN)); \
        nvPushData (1, (offset));                                           \
        nvPusherAdjust (sizeSet2DSurfacesDestination);                      \
        pDriverData->bltData.dwLastDstOffset = offset;                      \
    }                                                                       \
}

//-------------------------------------------------------------------------
//                              NV 043
//                         NV03_CONTEXT_ROP
//-------------------------------------------------------------------------

#define sizeSetRop5MthdCnt                          1
#define sizeSetRop5                                 2
#define nvglSetRop5(ch, rop5)                                               \
{                                                                           \
    if (pDriverData->bltData.dwLastRop != rop5) {                           \
        nvPushData (0, (((sizeSetRop5MthdCnt << 2) << 16) | ((ch) << 13) | NV043_SET_ROP5)); \
        nvPushData (1, (rop5));                                             \
        nvPusherAdjust (sizeSetRop5);                                       \
        pDriverData->bltData.dwLastRop = rop5;                              \
    }                                                                       \
}

//-------------------------------------------------------------------------
//                              NV 044
//                       NV04_CONTEXT_PATTERN
//-------------------------------------------------------------------------

// 0x00000304
#define sizeSetNv4ContextPatternMonochromeFormatMthdCnt  1
#define sizeSetNv4ContextPatternMonochromeFormat         2
#define nvglSetNv4ContextPatternMonochromeFormat(ch, format)                \
{                                                                           \
    nvPushData (0, (((sizeSetNv4ContextPatternMonochromeFormatMthdCnt << 2) << 16) | ((ch) << 13) | NV044_SET_MONOCHROME_FORMAT)); \
    nvPushData (1, (format));                                               \
    nvPusherAdjust (sizeSetNv4ContextPatternMonochromeFormat);              \
}
// 0x00000308
#define sizeSetNv4ContextPatternMonochromeShapeMthdCnt  1
#define sizeSetNv4ContextPatternMonochromeShape         2
#define nvglSetNv4ContextPatternMonochromeShape(ch, shape)                  \
{                                                                           \
    nvPushData (0, (((sizeSetNv4ContextPatternMonochromeShapeMthdCnt << 2) << 16) | ((ch) << 13) | NV044_SET_MONOCHROME_SHAPE)); \
    nvPushData (1, (shape));                                                \
    nvPusherAdjust (sizeSetNv4ContextPatternMonochromeShape);               \
}
// 0x0000030c
#define sizeSetNv4ContextPatternPatternSelectMthdCnt  1
#define sizeSetNv4ContextPatternPatternSelect         2
#define nvglSetNv4ContextPatternPatternSelect(ch, select)                   \
{                                                                           \
    nvPushData (0, (((sizeSetNv4ContextPatternPatternSelectMthdCnt << 2) << 16) | ((ch) << 13) | NV044_SET_PATTERN_SELECT)); \
    nvPushData (1, (select));                                               \
    nvPusherAdjust (sizeSetNv4ContextPatternPatternSelect);                 \
}
// 0x00000310
#define sizeSetNv4ContextPatternMonochromeColorsMthdCnt  2
#define sizeSetNv4ContextPatternMonochromeColors         3
#define nvglSetNv4ContextPatternMonochromeColors(ch, c0, c1)                \
{                                                                           \
    nvPushData (0, (((sizeSetNv4ContextPatternMonochromeColorsMthdCnt << 2) << 16) | ((ch) << 13) | NV044_SET_MONOCHORME_COLOR0)); \
    nvPushData (1, (c0));                                                   \
    nvPushData (2, (c1));                                                   \
    nvPusherAdjust (sizeSetNv4ContextPatternMonochromeColors);              \
}
// 0x00000318
#define sizeSetNv4ContextPatternMonochromePatternsMthdCnt  2
#define sizeSetNv4ContextPatternMonochromePatterns         3
#define nvglSetNv4ContextPatternMonochromePatterns(ch, pattern0, pattern1)  \
{                                                                           \
    nvPushData (0, (((sizeSetNv4ContextPatternMonochromePatternsMthdCnt << 2) << 16) | ((ch) << 13) | NV044_SET_MONOCHORME_PATTERN0)); \
    nvPushData (1, (pattern0));                                             \
    nvPushData (2, (pattern1));                                             \
    nvPusherAdjust (sizeSetNv4ContextPatternMonochromePatterns);            \
}

//-------------------------------------------------------------------------
//                              NV 04A
//                     NV04_GDI_RECTANGLE_TEXT
//-------------------------------------------------------------------------

//0x00000300
#define sizeDrawRopRectAndTextSetColorFormatMthdCnt 1
#define sizeDrawRopRectAndTextSetColorFormat        2
#define nvglDrawRopRectAndTextSetColorFormat(ch, format)                    \
{                                                                           \
    nvPushData (0, (((sizeDrawRopRectAndTextSetColorFormatMthdCnt << 2) << 16) | ((ch) << 13) | NV04A_SET_COLOR_FORMAT)); \
    nvPushData (1, (format));                                               \
    nvPusherAdjust (sizeDrawRopRectAndTextSetColorFormat);                  \
}

//0x0000018C
#define sizeDrawRopRectAndTextSetROPMthdCnt 1
#define sizeDrawRopRectAndTextSetROP        2
#define nvglDrawRopRectAndTextSetROP(ch, rop)                               \
{                                                                           \
    nvPushData (0, (((sizeDrawRopRectAndTextSetROPMthdCnt << 2) << 16) | ((ch) << 13) | NV04A_SET_CONTEXT_ROP)); \
    nvPushData (1, (rop));                                                  \
    nvPusherAdjust (sizeDrawRopRectAndTextSetROP);                          \
}

//0x00000188
#define sizeDrawPatternRectAndTextSetPatternMthdCnt 1
#define sizeDrawPatternRectAndTextSetPattern        2
#define nvglDrawPatternRectAndTextSetPattern(ch, pattern)                   \
{                                                                           \
    nvPushData (0, (((sizeDrawPatternRectAndTextSetPatternMthdCnt << 2) << 16) | ((ch) << 13) | NV04A_SET_CONTEXT_PATTERN)); \
    nvPushData (1, (pattern));                                              \
    nvPusherAdjust (sizeDrawPatternRectAndTextSetPattern);                  \
}

//0x00000198
#define sizeDrawRopRectAndTextSetSurfaceMthdCnt 1
#define sizeDrawRopRectAndTextSetSurface        2
#define nvglDrawRopRectAndTextSetSurface(ch, surface)                       \
{                                                                           \
    nvPushData (0, (((sizeDrawRopRectAndTextSetSurfaceMthdCnt << 2) << 16) | ((ch) << 13) | NV04A_SET_CONTEXT_SURFACE)); \
    nvPushData (1, (surface));                                              \
    nvPusherAdjust (sizeDrawRopRectAndTextSetSurface);                      \
}

//0x000002FC
#define sizeDrawRopRectAndTextSetOperatioonMthdCnt 1
#define sizeDrawRopRectAndTextSetOperation         2
#define nvglDrawRopRectAndTextSetOperation(ch, operation)                   \
{                                                                           \
    nvPushData (0, (((sizeDrawRopRectAndTextSetOperatioonMthdCnt << 2) << 16) | ((ch) << 13) | NV04A_SET_OPERATION)); \
    nvPushData (1, (operation));                                            \
    nvPusherAdjust (sizeDrawRopRectAndTextSetOperation);                    \
}

#define sizeDrawRopRectAndTextColor1AMthdCnt        1
#define sizeDrawRopRectAndTextColor1A               2
#define nvglDrawRopRectAndTextColor1A(ch, color)                            \
{                                                                           \
    nvPushData (0, (((sizeDrawRopRectAndTextColor1AMthdCnt << 2) << 16) | ((ch) << 13) | NV04A_COLOR1_A)); \
    nvPushData (1, (color));                                                \
    nvPusherAdjust (sizeDrawRopRectAndTextColor1A);                         \
}

#define sizeDrawRopRectAndTextPointSizeMthdCnt      2
#define sizeDrawRopRectAndTextPointSize             3
#define nvglDrawRopRectAndTextPointSize(ch, x, y, width, height)            \
{                                                                           \
    nvPushData (0, (((sizeDrawRopRectAndTextPointSizeMthdCnt << 2) << 16) | ((ch) << 13) | NV04A_UNCLIPPED_RECTANGLE_POINT(0))); \
    nvPushData (1, ((((x) & 0x0000FFFF) << 16) | ((y) & 0x0000FFFF)));      \
    nvPushData (2, ((((width) & 0x0000FFFF) << 16) | ((height) & 0x0000FFFF))); \
    nvPusherAdjust (sizeDrawRopRectAndTextPointSize);                       \
}

//-------------------------------------------------------------------------
//                              NV 052
//                   NV04_CONTEXT_SURFACE_SWIZZLED
//-------------------------------------------------------------------------

#define sizeSetSwizzledSurfaceContextImageMthdCnt   1
#define sizeSetSwizzledSurfaceContextImage          2
#define nvglSetSwizzledSurfaceContextImage(ch, ctxdmaimage)                 \
{                                                                           \
    nvPushData (0, (((sizeSetSwizzledSurfaceContextImageMthdCnt << 2) << 16) | ((ch) << 13) | NV052_SET_CONTEXT_DMA_IMAGE)); \
    nvPushData (1, (ctxdmaimage));                                          \
    nvPusherAdjust (sizeSetSwizzledSurfaceContextImage);                    \
}

#define sizeSetSwizzledSurfaceMthdCnt        2
#define sizeSetSwizzledSurface               3
#define nvglSetSwizzledSurface(ch, format, offset)                          \
{                                                                           \
    nvPushData (0, (((sizeSetSwizzledSurfaceMthdCnt << 2) << 16) | ((ch) << 13) | NV052_SET_FORMAT)); \
    nvPushData (1, (format));                                               \
    nvPushData (2, (offset));                                               \
    nvPusherAdjust (sizeSetSwizzledSurface);                                \
}

//-------------------------------------------------------------------------
//                              NV 053
//                     NV04_CONTEXT_SURFACES_3D
//-------------------------------------------------------------------------

#define sizeSetRenderTargetContextsMthdCnt  2
#define sizeSetRenderTargetContexts         3
#define nvglSetRenderTargetContexts(ch, ctxdmacolor, ctxdmazeta)            \
{                                                                           \
    nvPushData (0, (((sizeSetRenderTargetContextsMthdCnt << 2) << 16) | ((ch) << 13) | NV053_SET_CONTEXT_DMA_COLOR)); \
    nvPushData (1, (ctxdmacolor));                                          \
    nvPushData (2, (ctxdmazeta));                                           \
    nvPusherAdjust (sizeSetRenderTargetContexts);                           \
}

#define sizeSetRenderTarget                 8
#define nvglSetRenderTarget(ch, cliphorizontal, clipvertical, format,       \
                            pitch, coloroffset, zetaoffset)                 \
{                                                                           \
    nvPushData (0, (((3 << 2) << 16) | ((ch) << 13) | NV053_SET_CLIP_HORIZONTAL)); \
    nvPushData (1, (cliphorizontal));                                       \
    nvPushData (2, (clipvertical));                                         \
    nvPushData (3, (format));                                               \
    nvPushData (4, (((3 << 2) << 16) | ((ch) << 13) | NV053_SET_PITCH));    \
    nvPushData (5, (pitch));                                                \
    nvPushData (6, (coloroffset));                                          \
    nvPushData (7, (zetaoffset));                                           \
    nvPusherAdjust (sizeSetRenderTarget);                                   \
}

#define sizeSetRenderTarget2MthdCnt         5
#define sizeSetRenderTarget2                6
#define nvglSetRenderTarget2(ch, format, clipsize, pitch,                   \
                             coloroffset, zetaoffset)                       \
{                                                                           \
    nvPushData (0, (((sizeSetRenderTarget2MthdCnt << 2) << 16) | ((ch) << 13) | NV053_SET_FORMAT)); \
    nvPushData (1, (format));                                               \
    nvPushData (2, (clipsize));                                             \
    nvPushData (3, (pitch));                                                \
    nvPushData (4, (coloroffset));                                          \
    nvPushData (5, (zetaoffset));                                           \
    nvPusherAdjust (sizeSetRenderTarget2);                                  \
}

#define sizeSetRenderTargetViewportMthdCnt  2
#define sizeSetRenderTargetViewport         3
#define nvglSetRenderTargetViewport(ch, cliphorizontal, clipvertical)       \
{                                                                           \
    nvPushData (0, (((sizeSetRenderTargetViewportMthdCnt << 2) << 16) | ((ch) << 13) | NV053_SET_CLIP_HORIZONTAL)); \
    nvPushData (1, (cliphorizontal));                                       \
    nvPushData (2, (clipvertical));                                         \
    nvPusherAdjust (sizeSetRenderTargetViewport);                           \
}

//-------------------------------------------------------------------------
//                              NV 054
//                     NV04_DX5_TEXTURED_TRIANGLE
//-------------------------------------------------------------------------

#define sizeSetDx5TriangleContextsMthdCnt   2
#define sizeSetDx5TriangleContexts          3
#define nvglSetDx5TriangleContexts(ch, ctxa, ctxb)                          \
{                                                                           \
    nvPushData (0, (((sizeSetDx5TriangleContextsMthdCnt << 2) << 16) | ((ch) << 13) | NV054_SET_CONTEXT_DMA_A)); \
    nvPushData (1, (ctxa));                                                 \
    nvPushData (2, (ctxb));                                                 \
    nvPusherAdjust (sizeSetDx5TriangleContexts);                            \
}

#define sizeSetDx5TriangleSurfaceMthdCnt    1
#define sizeSetDx5TriangleSurface           2
#define nvglSetDx5TriangleSurface(ch, ctxs)                                 \
{                                                                           \
    nvPushData (0, (((sizeSetDx5TriangleSurfaceMthdCnt << 2) << 16) | ((ch) << 13) | NV054_SET_CONTEXT_SURFACES)); \
    nvPushData (1, (ctxs));                                                 \
    nvPusherAdjust (sizeSetDx5TriangleSurface);                             \
}

#define sizeDx5TriangleStateMthdCnt         7
#define sizeDx5TriangleState                8
#define nvglDx5TriangleState(ch, ckey, offset, format, filter,              \
                             blend, control, fogcolor)                      \
{                                                                           \
    nvPushData (0, (((sizeDx5TriangleStateMthdCnt << 2) << 16) | ((ch) << 13) | NV054_COLOR_KEY)); \
    nvPushData (1, (ckey));                                                 \
    nvPushData (2, (offset));                                               \
    nvPushData (3, (format));                                               \
    nvPushData (4, (filter));                                               \
    nvPushData (5, (blend));                                                \
    nvPushData (6, (control));                                              \
    nvPushData (7, (fogcolor));                                             \
    nvPusherAdjust (sizeDx5TriangleState);                                  \
}

#define sizeDx5TriangleDrawPrimitiveMthdCnt 1
#define sizeDx5TriangleDrawPrimitive        2
#define nvglDx5TriangleDrawPrimitive(ch, alias, vertices)                   \
{                                                                           \
    nvPushData (0, (((sizeDx5TriangleDrawPrimitiveMthdCnt << 2) << 16) | ((ch) << 13) | NV054_DRAW_PRIMITIVE((alias)))); \
    nvPushData (1, (vertices));                                             \
    nvPusherAdjust (sizeDx5TriangleDrawPrimitive);                          \
}

#define sizeDx5TriangleNotify               4
#define nvglDx5TriangleNotify(ch)                                           \
{                                                                           \
    nvPushData (0, (((1 << 2) << 16) | ((ch) << 13) | NV054_NOTIFY));       \
    nvPushData (1, NV054_NOTIFY_WRITE_ONLY);                                \
    nvPushData (2, (((1 << 2) << 16) | ((ch) << 13) | NV054_NO_OPERATION)); \
    nvPushData (3, 0x00000000);                                             \
    nvPusherAdjust (sizeDx5TriangleNotify);                                 \
}

//-------------------------------------------------------------------------
//                              NV 055
//                   NV04_DX6_MULTI_TEXTURE_TRIANGLE
//-------------------------------------------------------------------------

#define sizeSetDx6TriangleContextsMthdCnt   2
#define sizeSetDx6TriangleContexts          3
#define nvglSetDx6TriangleContexts(ch, ctxa, ctxb)                          \
{                                                                           \
    nvPushData (0, (((sizeSetDx6TriangleContextsMthdCnt << 2) << 16) | ((ch) << 13) | NV055_SET_CONTEXT_DMA_A)); \
    nvPushData (1, (ctxa));                                                 \
    nvPushData (2, (ctxb));                                                 \
    nvPusherAdjust (sizeSetDx6TriangleContexts);                            \
}

#define sizeSetDx6TriangleSurfaceMthdCnt    1
#define sizeSetDx6TriangleSurface           2
#define nvglSetDx6TriangleSurface(ch, ctxs)                                 \
{                                                                           \
    nvPushData (0, (((sizeSetDx6TriangleSurfaceMthdCnt << 2) << 16) | ((ch) << 13) | NV055_SET_CONTEXT_SURFACES)); \
    nvPushData (1, (ctxs));                                                 \
    nvPusherAdjust (sizeSetDx6TriangleSurface);                             \
}

#define sizeDx6TriangleOffsetMthdCnt        1
#define sizeDx6TriangleOffset               2
#define nvglDx6TriangleOffset(ch, offset, buffer)                           \
{                                                                           \
    nvPushData (0, (((sizeDx6TriangleOffsetMthdCnt << 2) << 16) | ((ch) << 13) | NV055_OFFSET(buffer))); \
    nvPushData (1, (offset));                                               \
    nvPusherAdjust (sizeDx6TriangleOffset);                                 \
}

#define sizeDx6TriangleFormatMthdCnt        1
#define sizeDx6TriangleFormat               2
#define nvglDx6TriangleFormat(ch, format, buffer)                           \
{                                                                           \
    nvPushData (0, (((sizeDx6TriangleFormatMthdCnt << 2) << 16) | ((ch) << 13) | NV055_FORMAT(buffer))); \
    nvPushData (1, (format));                                               \
    nvPusherAdjust (sizeDx6TriangleFormat);                                 \
}

#define sizeDx6TriangleFilterMthdCnt        1
#define sizeDx6TriangleFilter               2
#define nvglDx6TriangleFilter(ch, filter, buffer)                           \
{                                                                           \
    nvPushData (0, (((sizeDx6TriangleFilterMthdCnt << 2) << 16) | ((ch) << 13) | NV055_FILTER(buffer))); \
    nvPushData (1, (filter));                                               \
    nvPusherAdjust (sizeDx6TriangleFilter);                                 \
}

#define sizeDx6TriangleStageState           12
#define nvglDx6TriangleStageState(ch, c0alpha, c0color, c1alpha, c1color,   \
                                  factor, blend,                            \
                                  control0, control1, control2,             \
                                  fogcolor)                                 \
{                                                                           \
    nvPushData (0, (((2 << 2) << 16) | ((ch) << 13) | NV055_COMBINE_0_ALPHA)); \
    nvPushData (1, (c0alpha));                                              \
    nvPushData (2, (c0color));                                              \
    nvPushData (3, (((8 << 2) << 16) | ((ch) << 13) | NV055_COMBINE_1_ALPHA)); \
    nvPushData (4, (c1alpha));                                              \
    nvPushData (5, (c1color));                                              \
    nvPushData (6, (factor));                                               \
    nvPushData (7, (blend));                                                \
    nvPushData (8, (control0));                                             \
    nvPushData (9, (control1));                                             \
    nvPushData (10, (control2));                                            \
    nvPushData (11, (fogcolor));                                            \
    nvPusherAdjust (sizeDx6TriangleStageState);                             \
}

#define sizeDX6TriangleState    (((sizeDx6TriangleOffset + sizeDx6TriangleFormat + sizeDx6TriangleFilter) * 2) + sizeDx6TriangleStageState)

#define sizeDx6TriangleTLVertexMthdCnt      10
#define sizeDx6TriangleTLVertex1            11
#define nvglDx6TriangleTLVertex(ch, alias, vd)                              \
{                                                                           \
    nvPushData (0, (((sizeDx6TriangleTLVertexMthdCnt << 2) << 16) | ((ch) << 13) | NV055_TLMTVERTEX((alias)))); \
    nvPushData (1, *(U032 *)&(vd.sx));                                      \
    nvPushData (2, *(U032 *)&(vd.sy));                                      \
    nvPushData (3, *(U032 *)&(vd.sz));                                      \
    nvPushData (4, *(U032 *)&(vd.rhw));                                     \
    nvPushData (5, (vd.color));                                             \
    nvPushData (6, (vd.specular));                                          \
    nvPushData (7, *(U032 *)&(vd.tu));                                      \
    nvPushData (8, *(U032 *)&(vd.tv));                                      \
    nvPushData (9, 0);                                                      \
    nvPushData (10, 0);                                                     \
    nvPusherAdjust (sizeDx6TriangleTLVertex1);                              \
    dbgDisplayVertexData(FALSE, (DWORD *)&(vd.sx));                         \
}

#define sizeDx6TriangleDrawPrimitiveMthdCnt 1
#define sizeDx6TriangleDrawPrimitive        2
#define nvglDx6TriangleDrawPrimitive(ch, alias, vertices)                   \
{                                                                           \
    nvPushData (0, (((sizeDx6TriangleDrawPrimitiveMthdCnt << 2) << 16) | ((ch) << 13) | NV055_DRAW_PRIMITIVE((alias)))); \
    nvPushData (1, (vertices));                                             \
    nvPusherAdjust (sizeDx6TriangleDrawPrimitive);                          \
}

//-------------------------------------------------------------------------
//                              NV 056
//                      NV10_CELSIUS_PRIMITIVE
//-------------------------------------------------------------------------
#if (NVARCH >= 0x010)
#define NV056_SET_VERTEX_FORMAT_SHADOW      NV056_SET_INVERSE_MODEL_VIEW_MATRIX1(15)

// 0x00000100
#define sizeSetNv10CelsiusNoOpMthdCnt    1
#define sizeSetNv10CelsiusNoOp           2
#define nvglSetNv10CelsiusNoOp(ch)                                          \
{                                                                           \
    nvPushData (0, (((sizeSetNv10CelsiusNoOpMthdCnt << 2) << 16) | ((ch) << 13) | NV056_NO_OPERATION)); \
    nvPushData (1, 0);                                                      \
    nvPusherAdjust (sizeSetNv10CelsiusNoOp);                                \
}
// 0x00000104
#define sizeSetNv10CelsiusNotifyMthdCnt    1
#define sizeSetNv10CelsiusNotify           2
#define nvglSetNv10CelsiusNotify(ch, type)                                  \
{                                                                           \
    nvPushData (0, (((sizeSetNv10CelsiusNotifyMthdCnt << 2) << 16) | ((ch) << 13) | NV056_NOTIFY)); \
    nvPushData (1, (type));                                                 \
    nvPusherAdjust (sizeSetNv10CelsiusNotify);                              \
}
// 0x00000180
#define sizeSetNv10CelsiusContextDMAsMthdCnt    7
#define sizeSetNv10CelsiusContextDMAs           8
#define nvglSetNv10CelsiusContextDMAs(ch, notifies, dmaa, dmab, vertex, state, color, zeta) \
{                                                                           \
    nvPushData (0, (((sizeSetNv10CelsiusContextDMAsMthdCnt << 2) << 16) | ((ch) << 13) | NV056_SET_CONTEXT_DMA_NOTIFIES)); \
    nvPushData (1, (notifies));                                             \
    nvPushData (2, (dmaa));                                                 \
    nvPushData (3, (dmab));                                                 \
    nvPushData (4, (vertex));                                               \
    nvPushData (5, (state));                                                \
    nvPushData (6, (color));                                                \
    nvPushData (7, (zeta));                                                 \
    nvPusherAdjust (sizeSetNv10CelsiusContextDMAs);                         \
}
// 0x00000180
#define sizeSetNv10CelsiusNotifierContextDMAMthdCnt    1
#define sizeSetNv10CelsiusNotifierContextDMA           2
#define nvglSetNv10CelsiusNotifierContextDMA(ch, notifies)                  \
{                                                                           \
    nvPushData (0, (((sizeSetNv10CelsiusNotifierContextDMAMthdCnt << 2) << 16) | ((ch) << 13) | NV056_SET_CONTEXT_DMA_NOTIFIES)); \
    nvPushData (1, (notifies));                                             \
    nvPusherAdjust (sizeSetNv10CelsiusNotifierContextDMA);                  \
}
// 0x00000184
#define sizeSetNv10CelsiusTextureAndVertexContextDMAsMthdCnt    3
#define sizeSetNv10CelsiusTextureAndVertexContextDMAs           4
#define nvglSetNv10CelsiusTextureAndVertexContextDMAs(ch, dmaa, dmab, vertex) \
{                                                                           \
    nvPushData (0, (((sizeSetNv10CelsiusTextureAndVertexContextDMAsMthdCnt << 2) << 16) | ((ch) << 13) | NV056_SET_CONTEXT_DMA_A)); \
    nvPushData (1, (dmaa));                                                 \
    nvPushData (2, (dmab));                                                 \
    nvPushData (3, (vertex));                                               \
    nvPusherAdjust (sizeSetNv10CelsiusTextureAndVertexContextDMAs);         \
}
// 0x0000072c
#define sizeSetNv10CelsiusEyeDirectionMthdCnt                   3
#define sizeSetNv10CelsiusEyeDirection                          4
#define nvglSetNv10CelsiusEyeDirection(ch, x, y, z)                         \
{                                                                           \
    float x1 = x, y1 = y, z1 = z;                                           \
    nvPushData (0, (((sizeSetNv10CelsiusEyeDirectionMthdCnt << 2) << 16) | ((ch) << 13) | NV056_SET_EYE_DIRECTION_SW(0))); \
    nvPushData (1, *(DWORD*)&x1);                                           \
    nvPushData (2, *(DWORD*)&y1);                                           \
    nvPushData (3, *(DWORD*)&z1);                                           \
    nvPusherAdjust (sizeSetNv10CelsiusEyeDirection);                        \
}
// 0x00000cf0
#define sizeSetNv10CelsiusInvalidateVertexCacheMthdCnt    1
#define sizeSetNv10CelsiusInvalidateVertexCache           2
#define nvglSetNv10CelsiusInvalidateVertexCache(ch)                         \
{                                                                           \
    nvPushData (0, (((sizeSetNv10CelsiusInvalidateVertexCacheMthdCnt << 2) << 16) | ((ch) << 13) | NV056_INVALIDATE_VERTEX_CACHE_FILE)); \
    nvPushData (1, 0);                                                      \
    nvPusherAdjust (sizeSetNv10CelsiusInvalidateVertexCache);               \
}
// 0x00000dfc
#define sizeSetNv10CelsiusBeginEndMthdCnt    1
#define sizeSetNv10CelsiusBeginEnd           2
#define nvglSetNv10CelsiusBeginEnd(ch, op)                                  \
{                                                                           \
    nvPushData (0, (((sizeSetNv10CelsiusBeginEndMthdCnt << 2) << 16) | ((ch) << 13) | NV056_SET_BEGIN_END)); \
    nvPushData (1, (op));                                                   \
    nvPusherAdjust (sizeSetNv10CelsiusBeginEnd);                            \
}
// 0x000010fc
#define sizeSetNv10CelsiusBeginEnd2MthdCnt    1
#define sizeSetNv10CelsiusBeginEnd2           2
#define nvglSetNv10CelsiusBeginEnd2(ch, op)                                  \
{                                                                           \
    nvPushData (0, (((sizeSetNv10CelsiusBeginEnd2MthdCnt << 2) << 16) | ((ch) << 13) | NV056_SET_BEGIN_END2)); \
    nvPushData (1, (op));                                                   \
    nvPusherAdjust (sizeSetNv10CelsiusBeginEnd2);                            \
}
// 0x000013fc
#define sizeSetNv10CelsiusBeginEnd3MthdCnt    1
#define sizeSetNv10CelsiusBeginEnd3           2
#define nvglSetNv10CelsiusBeginEnd3(ch, op)                                 \
{                                                                           \
    nvPushData (0, (((sizeSetNv10CelsiusBeginEnd3MthdCnt << 2) << 16) | ((ch) << 13) | NV056_SET_BEGIN_END3)); \
    nvPushData (1, (op));                                                   \
    nvPusherAdjust (sizeSetNv10CelsiusBeginEnd3);                           \
}
// 0x000017fc
#define sizeSetNv10CelsiusBeginEnd4MthdCnt    1
#define sizeSetNv10CelsiusBeginEnd4           2
#define nvglSetNv10CelsiusBeginEnd4(ch, op)                                 \
{                                                                           \
    nvPushData (0, (((sizeSetNv10CelsiusBeginEnd4MthdCnt << 2) << 16) | ((ch) << 13) | NV056_SET_BEGIN_END4)); \
    nvPushData (1, (op));                                                   \
    nvPusherAdjust (sizeSetNv10CelsiusBeginEnd4);                           \
}
// 0x00001400
#define sizeSetNv10CelsiusDrawArraysMthdCnt    1
#define sizeSetNv10CelsiusDrawArrays           2
#define nvglSetNv10CelsiusDrawArrays(ch, data)                              \
{                                                                           \
    nvPushData (0, (((sizeSetNv10CelsiusDrawArraysMthdCnt << 2) << 16) | ((ch) << 13) | NV056_DRAW_ARRAYS(0))); \
    nvPushData (1, (data));                                                 \
    nvPusherAdjust (sizeSetNv10CelsiusDrawArrays);                          \
}
#endif  // NVARCH >= 0x010

//-------------------------------------------------------------------------
//                              NV 097
//                       NV20_KELVIN_PRIMITIVE
//-------------------------------------------------------------------------
#if (NVARCH >= 0x020)
// 0x00000100
#define sizeSetNv20KelvinNoOpMthdCnt    1
#define sizeSetNv20KelvinNoOp           2
#define nvglSetNv20KelvinNoOp(ch)                                           \
{                                                                           \
    nvPushData (0, (((sizeSetNv20KelvinNoOpMthdCnt << 2) << 16) | ((ch) << 13) | NV097_NO_OPERATION)); \
    nvPushData (1, 0);                                                      \
    nvPusherAdjust (sizeSetNv20KelvinNoOp);                                 \
}
// 0x00000104
#define sizeSetNv20KelvinNotifyMthdCnt    1
#define sizeSetNv20KelvinNotify           2
#define nvglSetNv20KelvinNotify(ch, type)                                   \
{                                                                           \
    nvPushData (0, (((sizeSetNv20KelvinNotifyMthdCnt << 2) << 16) | ((ch) << 13) | NV097_NOTIFY)); \
    nvPushData (1, (type));                                                 \
    nvPusherAdjust (sizeSetNv20KelvinNotify);                               \
}
// 0x00000180
#define sizeSetNv20KelvinNotifierContextDMAMthdCnt    1
#define sizeSetNv20KelvinNotifierContextDMA           2
#define nvglSetNv20KelvinNotifierContextDMA(ch, notifies)                   \
{                                                                           \
    nvPushData (0, (((sizeSetNv20KelvinNotifierContextDMAMthdCnt << 2) << 16) | ((ch) << 13) | NV097_SET_CONTEXT_DMA_NOTIFIES)); \
    nvPushData (1, (notifies));                                             \
    nvPusherAdjust (sizeSetNv20KelvinNotifierContextDMA);                   \
}
// 0x00000180
#define sizeSetNv20KelvinContextDMAsMthdCnt1    3
#define sizeSetNv20KelvinContextDMAs1           4
#define sizeSetNv20KelvinContextDMAsMthdCnt2    7
#define sizeSetNv20KelvinContextDMAs2           8
#define nvglSetNv20KelvinContextDMAs(ch, notifies, dmaa, dmab, state, color, zeta, vertexa, vertexb, semaphore, report) \
{                                                                           \
    nvPushData (0, (((sizeSetNv20KelvinContextDMAsMthdCnt1 << 2) << 16) | ((ch) << 13) | NV097_SET_CONTEXT_DMA_NOTIFIES)); \
    nvPushData (1, (notifies));                                             \
    nvPushData (2, (dmaa));                                                 \
    nvPushData (3, (dmab));                                                 \
    nvPusherAdjust (sizeSetNv20KelvinContextDMAs1);                         \
    nvPushData (0, (((sizeSetNv20KelvinContextDMAsMthdCnt2 << 2) << 16) | ((ch) << 13) | NV097_SET_CONTEXT_DMA_STATE)); \
    nvPushData (1, (state));                                                \
    nvPushData (2, (color));                                                \
    nvPushData (3, (zeta));                                                 \
    nvPushData (4, (vertexa));                                              \
    nvPushData (5, (vertexb));                                              \
    nvPushData (6, (semaphore));                                            \
    nvPushData (7, (report));                                               \
    nvPusherAdjust (sizeSetNv20KelvinContextDMAs2);                         \
}
// 0x00000184
#define sizeSetNv20KelvinTextureContextDMAsMthdCnt    2
#define sizeSetNv20KelvinTextureContextDMAs           3
#define nvglSetNv20KelvinTextureContextDMAs(ch, dmaa, dmab)                 \
{                                                                           \
    nvPushData (0, (((sizeSetNv20KelvinTextureContextDMAsMthdCnt << 2) << 16) | ((ch) << 13) | NV097_SET_CONTEXT_DMA_A)); \
    nvPushData (1, (dmaa));                                                 \
    nvPushData (2, (dmab));                                                 \
    nvPusherAdjust (sizeSetNv20KelvinTextureContextDMAs);                   \
}
// 0x0000019c
#define sizeSetNv20KelvinVertexContextDMAsMthdCnt    2
#define sizeSetNv20KelvinVertexContextDMAs           3
#define nvglSetNv20KelvinVertexContextDMAs(ch, vertexa, vertexb)            \
{                                                                           \
    nvPushData (0, (((sizeSetNv20KelvinVertexContextDMAsMthdCnt << 2) << 16) | ((ch) << 13) | NV097_SET_CONTEXT_DMA_VERTEX_A)); \
    nvPushData (1, (vertexa));                                              \
    nvPushData (2, (vertexb));                                              \
    nvPusherAdjust (sizeSetNv20KelvinVertexContextDMAs);                    \
}
// 0x00001710
#define sizeSetNv20KelvinInvalidateVertexCacheMthdCnt    1
#define sizeSetNv20KelvinInvalidateVertexCache           2
#define nvglSetNv20KelvinInvalidateVertexCache(ch)                          \
{                                                                           \
    nvPushData (0, (((sizeSetNv20KelvinInvalidateVertexCacheMthdCnt << 2) << 16) | ((ch) << 13) | NV097_INVALIDATE_VERTEX_CACHE_FILE)); \
    nvPushData (1, 0);                                                      \
    nvPusherAdjust (sizeSetNv20KelvinInvalidateVertexCache);                \
}
// 0x000017fc
#define sizeSetNv20KelvinBeginEndMthdCnt    1
#define sizeSetNv20KelvinBeginEnd           2
#define nvglSetNv20KelvinBeginEnd(ch, op)                                   \
{                                                                           \
    nvPushData (0, (((sizeSetNv20KelvinBeginEndMthdCnt << 2) << 16) | ((ch) << 13) | NV097_SET_BEGIN_END)); \
    nvPushData (1, (op));                                                   \
    nvPusherAdjust (sizeSetNv20KelvinBeginEnd);                             \
}
// 0x00001810
#define sizeSetNv20KelvinDrawArraysMthdCnt    1
#define sizeSetNv20KelvinDrawArrays           2
#define nvglSetNv20KelvinDrawArrays(ch, data)                               \
{                                                                           \
    nvPushData (0, (((sizeSetNv20KelvinDrawArraysMthdCnt << 2) << 16) | ((ch) << 13) | NONINC_METHOD(NV097_DRAW_ARRAYS))); \
    nvPushData (1, (data));                                                 \
    nvPusherAdjust (sizeSetNv20KelvinDrawArrays);                           \
}

#endif // (NVARCH >= 0x020)

//-------------------------------------------------------------------------
//                              NV 05E
//                    NV04_RENDER_SOLID_RECTANGLE
//-------------------------------------------------------------------------

// 0x00000100
#define sizeSetNv4SolidRectangleNoOpMthdCnt    1
#define sizeSetNv4SolidRectangleNoOp           2
#define nvglSetNv4SolidRectangleNoOp(ch)                                    \
{                                                                           \
    nvPushData (0, (((sizeSetNv4SolidRectangleNoOpMthdCnt << 2) << 16) | ((ch) << 13) | NV05E_NO_OPERATION)); \
    nvPushData (1, 0);                                                      \
    nvPusherAdjust (sizeSetNv4SolidRectangleNoOp);                          \
}
// 0x00000184
#define sizeSetNv4SolidRectangleClipRectangleMthdCnt  1
#define sizeSetNv4SolidRectangleClipRectangle         2
#define nvglSetNv4SolidRectangleClipRectangle(ch, rect)                     \
{                                                                           \
    nvPushData (0, (((sizeSetNv4SolidRectangleClipRectangleMthdCnt << 2) << 16) | ((ch) << 13) | NV05E_SET_CONTEXT_CLIP_RECTANGLE)); \
    nvPushData (1, (rect));                                                 \
    nvPusherAdjust (sizeSetNv4SolidRectangleClipRectangle);                 \
}
// 0x00000188
#define sizeSetNv4SolidRectanglePatternMthdCnt  1
#define sizeSetNv4SolidRectanglePattern         2
#define nvglSetNv4SolidRectanglePattern(ch, pattern)                        \
{                                                                           \
    nvPushData (0, (((sizeSetNv4SolidRectanglePatternMthdCnt << 2) << 16) | ((ch) << 13) | NV05E_SET_CONTEXT_PATTERN)); \
    nvPushData (1, (pattern));                                              \
    nvPusherAdjust (sizeSetNv4SolidRectanglePattern);                       \
}
// 0x0000018c
#define sizeSetNv4SolidRectangleRopMthdCnt  1
#define sizeSetNv4SolidRectangleRop         2
#define nvglSetNv4SolidRectangleRop(ch, rop)                                \
{                                                                           \
    nvPushData (0, (((sizeSetNv4SolidRectangleRopMthdCnt << 2) << 16) | ((ch) << 13) | NV05E_SET_CONTEXT_ROP)); \
    nvPushData (1, (rop));                                                  \
    nvPusherAdjust (sizeSetNv4SolidRectangleRop);                           \
}
// 0x00000198
#define sizeSetNv4SolidRectangleSurfaceMthdCnt  1
#define sizeSetNv4SolidRectangleSurface         2
#define nvglSetNv4SolidRectangleSurface(ch, surface)                        \
{                                                                           \
    nvPushData (0, (((sizeSetNv4SolidRectangleSurfaceMthdCnt << 2) << 16) | ((ch) << 13) | NV05E_SET_CONTEXT_SURFACE)); \
    nvPushData (1, (surface));                                              \
    nvPusherAdjust (sizeSetNv4SolidRectangleSurface);                       \
}
// 0x000002fc
#define sizeSetNv4SolidRectangleOperationMthdCnt    1
#define sizeSetNv4SolidRectangleOperation           2
#define nvglSetNv4SolidRectangleOperation(ch, op)                           \
{                                                                           \
    nvPushData (0, (((sizeSetNv4SolidRectangleOperationMthdCnt << 2) << 16) | ((ch) << 13) | NV05E_SET_OPERATION)); \
    nvPushData (1, (op));                                                   \
    nvPusherAdjust (sizeSetNv4SolidRectangleOperation);                     \
}
// 0x00000300
#define sizeSetNv4SolidRectangleColorFormatMthdCnt  1
#define sizeSetNv4SolidRectangleColorFormat         2
#define nvglSetNv4SolidRectangleColorFormat(ch, cfmt)                       \
{                                                                           \
    nvPushData (0, (((sizeSetNv4SolidRectangleColorFormatMthdCnt << 2) << 16) | ((ch) << 13) | NV05E_SET_COLOR_FORMAT)); \
    nvPushData (1, (cfmt));                                                 \
    nvPusherAdjust (sizeSetNv4SolidRectangleColorFormat);                   \
}
// 0x00000304
#define sizeNv4SolidRectangleColorMthdCnt           1
#define sizeNv4SolidRectangleColor                  2
#define nvglNv4SolidRectangleColor(ch, color)                               \
{                                                                           \
    nvPushData (0, (((sizeNv4SolidRectangleColorMthdCnt << 2) << 16) | ((ch) << 13) | NV05E_COLOR)); \
    nvPushData (1, (color));                                                \
    nvPusherAdjust (sizeNv4SolidRectangleColor);                            \
}
// 0x00000400
#define sizeNv4SolidRectanglePointSizeMthdCnt       2
#define sizeNv4SolidRectanglePointSize              3
#define nvglNv4SolidRectanglePointSize(ch, x, y, width, height)             \
{                                                                           \
    nvPushData (0, (((sizeNv4SolidRectanglePointSizeMthdCnt << 2) << 16) | ((ch) << 13) | NV05E_RECTANGLE(0))); \
    nvPushData (1, ((((y) & 0x0000FFFF) << 16) | ((x) & 0x0000FFFF)));      \
    nvPushData (2, ((((height) & 0x0000FFFF) << 16) | ((width) & 0x0000FFFF))); \
    nvPusherAdjust (sizeNv4SolidRectanglePointSize);                        \
}

//-------------------------------------------------------------------------
//                              NV 05F
//                         NV04_IMAGE_BLIT
//-------------------------------------------------------------------------

// 0x00000188
#define sizeSetNv4ImageBlitClipRectangleMthdCnt     1
#define sizeSetNv4ImageBlitClipRectangle            2
#define nvglSetNv4ImageBlitClipRectangle(ch, rect)                          \
{                                                                           \
    nvPushData (0, (((sizeSetNv4ImageBlitClipRectangleMthdCnt << 2) << 16) | ((ch) << 13) | NV05F_SET_CONTEXT_CLIP_RECTANGLE)); \
    nvPushData (1, (rect));                                                 \
    nvPusherAdjust (sizeSetNv4ImageBlitClipRectangle);                      \
}
// 0x0000018c
#define sizeSetNv4ImageBlitContextPatternMthdCnt     1
#define sizeSetNv4ImageBlitContextPattern            2
#define nvglSetNv4ImageBlitContextPattern(ch, pattern)                      \
{                                                                           \
    nvPushData (0, (((sizeSetNv4ImageBlitContextPatternMthdCnt << 2) << 16) | ((ch) << 13) | NV05F_SET_CONTEXT_PATTERN)); \
    nvPushData (1, (pattern));                                              \
    nvPusherAdjust (sizeSetNv4ImageBlitContextPattern);                     \
}
// 0x00000190
#define sizeSetNv4ImageBlitContextRopMthdCnt     1
#define sizeSetNv4ImageBlitContextRop            2
#define nvglSetNv4ImageBlitContextRop(ch, rop)                              \
{                                                                           \
    nvPushData (0, (((sizeSetNv4ImageBlitContextRopMthdCnt << 2) << 16) | ((ch) << 13) | NV05F_SET_CONTEXT_ROP)); \
    nvPushData (1, (rop));                                                  \
    nvPusherAdjust (sizeSetNv4ImageBlitContextRop);                         \
}
// 0x0000019c
#define sizeSetNv4ImageBlitContextSurfacesMthdCnt     1
#define sizeSetNv4ImageBlitContextSurfaces            2
#define nvglSetNv4ImageBlitContextSurfaces(ch, surface)                     \
{                                                                           \
    nvPushData (0, (((sizeSetNv4ImageBlitContextSurfacesMthdCnt << 2) << 16) | ((ch) << 13) | NV05F_SET_CONTEXT_SURFACES)); \
    nvPushData (1, (surface));                                              \
    nvPusherAdjust (sizeSetNv4ImageBlitContextSurfaces);                    \
}
// 0x000002fc
#define sizeSetNv4ImageBlitOperationMthdCnt     1
#define sizeSetNv4ImageBlitOperation            2
#define nvglSetNv4ImageBlitOperation(ch, op)                                \
{                                                                           \
    nvPushData (0, (((sizeSetNv4ImageBlitOperationMthdCnt << 2) << 16) | ((ch) << 13) | NV05F_SET_OPERATION)); \
    nvPushData (1, (op));                                                   \
    nvPusherAdjust (sizeSetNv4ImageBlitOperation);                          \
}
// 0x00000300
#define sizeSetNv4ImageBlitControlPointsMthdCnt     2
#define sizeSetNv4ImageBlitControlPoints            3
#define nvglSetNv4ImageBlitControlPoints(ch, xin, yin, xout, yout)          \
{                                                                           \
    nvPushData (0, (((sizeSetNv4ImageBlitControlPointsMthdCnt << 2) << 16) | ((ch) << 13) | NV05F_CONTROL_POINT_IN)); \
    nvPushData (1, (((xin)  & 0xffff) | ((yin)  << 16)));                   \
    nvPushData (2, (((xout) & 0xffff) | ((yout) << 16)));                   \
    nvPusherAdjust (sizeSetNv4ImageBlitControlPoints);                      \
}
// 0x00000308
#define sizeSetNv4ImageBlitSizeMthdCnt     1
#define sizeSetNv4ImageBlitSize            2
#define nvglSetNv4ImageBlitSize(ch, width, height)                          \
{                                                                           \
    nvPushData (0, (((sizeSetNv4ImageBlitSizeMthdCnt << 2) << 16) | ((ch) << 13) | NV05F_SIZE)); \
    nvPushData (1, (((width)  & 0xffff) | ((height)  << 16)));              \
    nvPusherAdjust (sizeSetNv4ImageBlitSize);                               \
}

//-------------------------------------------------------------------------
//                              NV 060
//                    NV04_INDEXED_IMAGE_FROM_CPU
//-------------------------------------------------------------------------

#define sizeSetIndexedImageDmaNotifiesMthdCnt           1
#define sizeSetIndexedImageDmaNotifies                  2
#define nvglSetIndexedImageDmaNotifies(ch, ctxdmanotify)                    \
{                                                                           \
    nvPushData (0, (((sizeSetIndexedImageDmaNotifiesMthdCnt << 2) << 16) | ((ch) << 13) | NV060_SET_CONTEXT_DMA_NOTIFIES)); \
    nvPushData (1, (ctxdmanotify));                                         \
    nvPusherAdjust (sizeSetIndexedImageDmaNotifies);                        \
}

#define sizeSetIndexedImageContextDmaLUTMthdCnt           1
#define sizeSetIndexedImageContextDmaLUT                  2
#define nvglSetIndexedImageContextDmaLUT(ch, handle)                        \
{                                                                           \
    nvPushData (0, (((sizeSetIndexedImageContextDmaLUTMthdCnt << 2) << 16) | ((ch) << 13) | NV060_SET_CONTEXT_DMA_LUT)); \
    nvPushData (1, (handle));                                               \
    nvPusherAdjust (sizeSetIndexedImageContextDmaLUT);                      \
}

#define sizeSetIndexedImageContextSurfaceMthdCnt        1
#define sizeSetIndexedImageContextSurface               2
#define nvglSetIndexedImageContextSurface(ch, surface)                      \
{                                                                           \
    nvPushData (0, (((sizeSetIndexedImageContextSurfaceMthdCnt << 2) << 16) | ((ch) << 13) | NV060_SET_CONTEXT_SURFACE)); \
    nvPushData (1, (surface));                                              \
    nvPusherAdjust (sizeSetIndexedImageContextSurface);                     \
}

#define sizeSetIndexedImageOperationMthdCnt     1
#define sizeSetIndexedImageOperation            2
#define nvglSetIndexedImageOperation(ch, operation)                         \
{                                                                           \
    nvPushData (0, (((sizeSetIndexedImageOperationMthdCnt << 2) << 16) | ((ch) << 13) | NV060_SET_OPERATION)); \
    nvPushData (1, (operation));                                            \
    nvPusherAdjust (sizeSetIndexedImageOperation);                          \
}

#define sizeSetIndexedImageColorFormatMthdCnt   1
#define sizeSetIndexedImageColorFormat          2
#define nvglSetIndexedImageColorFormat(ch, colorformat)                     \
{                                                                           \
    nvPushData (0, (((sizeSetIndexedImageColorFormatMthdCnt << 2) << 16) | ((ch) << 13) | NV060_SET_COLOR_FORMAT)); \
    nvPushData (1, (colorformat));                                          \
    nvPusherAdjust (sizeSetIndexedImageColorFormat);                        \
}

#define sizeSetIndexedImageIndexFormatMthdCnt   1
#define sizeSetIndexedImageIndexFormat          2
#define nvglSetIndexedImageIndexFormat(ch, indexformat)                     \
{                                                                           \
    nvPushData (0, (((sizeSetIndexedImageIndexFormatMthdCnt << 2) << 16) | ((ch) << 13) | NV060_INDEX_FORMAT)); \
    nvPushData (1, (indexformat));                                          \
    nvPusherAdjust (sizeSetIndexedImageIndexFormat);                        \
}

#define sizeSetIndexedImageLUTOffsetMthdCnt     1
#define sizeSetIndexedImageLUTOffset            2
#define nvglSetIndexedImageLUTOffset(ch, offset)                            \
{                                                                           \
    nvPushData (0, (((sizeSetIndexedImageLUTOffsetMthdCnt << 2) << 16) | ((ch) << 13) | NV060_LUT_OFFSET)); \
    nvPushData (1, (offset));                                               \
    nvPusherAdjust (sizeSetIndexedImageLUTOffset);                          \
}

//-------------------------------------------------------------------------
//                              NV 077
//                   NV04_SCALED_IMAGE_FROM_MEMORY
//-------------------------------------------------------------------------

#define sizeSetScaledImageContextNotifiesMthdCnt    1
#define sizeSetScaledImageContextNotifies           2
#define nvglSetScaledImageContextNotifies(ch, ctxdmanotify)                 \
{                                                                           \
    nvPushData (0, (((sizeSetScaledImageContextNotifiesMthdCnt << 2) << 16) | ((ch) << 13) | NV077_SET_CONTEXT_DMA_NOTIFIES)); \
    nvPushData (1, (ctxdmanotify));                                         \
    nvPusherAdjust (sizeSetScaledImageContextNotifies);                     \
}

#define sizeSetScaledImageContextImageMthdCnt       1
#define sizeSetScaledImageContextImage              2
#define nvglSetScaledImageContextImage(ch, ctxdmaimage)                     \
{                                                                           \
    nvPushData (0, (((sizeSetScaledImageContextImageMthdCnt << 2) << 16) | ((ch) << 13) | NV077_SET_CONTEXT_DMA_IMAGE)); \
    nvPushData (1, (ctxdmaimage));                                          \
    nvPusherAdjust (sizeSetScaledImageContextImage);                        \
}

#define sizeSetScaledImageContextSurfaceMthdCnt     1
#define sizeSetScaledImageContextSurface            2
#define nvglSetScaledImageContextSurface(ch, ctxdmasurface)                 \
{                                                                           \
    nvPushData (0, (((sizeSetScaledImageContextSurfaceMthdCnt << 2) << 16) | ((ch) << 13) | NV077_SET_CONTEXT_SURFACE)); \
    nvPushData (1, (ctxdmasurface));                                        \
    nvPusherAdjust (sizeSetScaledImageContextSurface);                      \
}

#define sizeSetScaledImageFormatMthdCnt             1
#define sizeSetScaledImageFormat                    2
#define nvglSetScaledImageFormat(ch, format)                                \
{                                                                           \
    nvPushData (0, (((sizeSetScaledImageFormatMthdCnt << 2) << 16) | ((ch) << 13) | NV077_SET_COLOR_FORMAT)); \
    nvPushData (1, (format));                                               \
    nvPusherAdjust (sizeSetScaledImageFormat);                              \
}

#define sizeSetScaledImageOperationMthdCnt          1
#define sizeSetScaledImageOperation                 2
#define nvglSetScaledImageOperation(ch, operation)                          \
{                                                                           \
    nvPushData (0, (((sizeSetScaledImageOperationMthdCnt << 2) << 16) | ((ch) << 13) | NV077_SET_OPERATION)); \
    nvPushData (1, (operation));                                            \
    nvPusherAdjust (sizeSetScaledImageOperation);                           \
}

#define sizeScaledImageClipMthdCnt                  2
#define sizeScaledImageClip                         3
#define nvglScaledImageClip(ch, x, y, width, height)                        \
{                                                                           \
    nvPushData (0, (((sizeScaledImageClipMthdCnt << 2) << 16) | ((ch) << 13) | NV077_CLIP_POINT)); \
    nvPushData (1, ((((y) & 0x0000FFFF) << 16) | ((x) & 0x0000FFFF)));      \
    nvPushData (2, ((((height) & 0x0000FFFF) << 16) | ((width) & 0x0000FFFF))); \
    nvPusherAdjust (sizeScaledImageClip);                                   \
}

#define sizeScaledImageOutMthdCnt                   2
#define sizeScaledImageOut                          3
#define nvglScaledImageOut(ch, x, y, width, height)                         \
{                                                                           \
    nvPushData (0, (((sizeScaledImageOutMthdCnt << 2) << 16) | ((ch) << 13) | NV077_IMAGE_OUT_POINT)); \
    nvPushData (1, ((((y) & 0x0000FFFF) << 16) | ((x) & 0x0000FFFF)));      \
    nvPushData (2, ((((height) & 0x0000FFFF) << 16) | ((width) & 0x0000FFFF))); \
    nvPusherAdjust (sizeScaledImageOut);                                    \
}

#define sizeScaledImageDeltaDuDxDvDyMthdCnt         2
#define sizeScaledImageDeltaDuDxDvDy                3
#define nvglScaledImageDeltaDuDxDvDy(ch, dudx, dvdy)                        \
{                                                                           \
    nvPushData (0, (((sizeScaledImageDeltaDuDxDvDyMthdCnt << 2) << 16) | ((ch) << 13) | NV077_DELTA_DU_DX)); \
    nvPushData (1, (dudx));                                                 \
    nvPushData (2, (dvdy));                                                 \
    nvPusherAdjust (sizeScaledImageDeltaDuDxDvDy);                          \
}

#define sizeScaledImageInSizeMthdCnt                1
#define sizeScaledImageInSize                       2
#define nvglScaledImageInSize(ch, width, height)                            \
{                                                                           \
    nvPushData (0, (((sizeScaledImageInSizeMthdCnt << 2) << 16) | ((ch) << 13) | NV077_IMAGE_IN_SIZE)); \
    nvPushData (1, ((((height) & 0x0000FFFF) << 16) | ((width) & 0x0000FFFF))); \
    nvPusherAdjust (sizeScaledImageInSize);                                 \
}

#define sizeScaledImageInFormatMthdCnt              1
#define sizeScaledImageInFormat                     2
#define nvglScaledImageInFormat(ch, format)                                 \
{                                                                           \
    nvPushData (0, (((sizeScaledImageInFormatMthdCnt << 2) << 16) | ((ch) << 13) | NV077_IMAGE_IN_FORMAT)); \
    nvPushData (1, (format));                                               \
    nvPusherAdjust (sizeScaledImageInFormat);                               \
}

#define sizeScaledImageInOffsetMthdCnt              1
#define sizeScaledImageInOffset                     2
#define nvglScaledImageInOffset(ch, offset)                                 \
{                                                                           \
    nvPushData (0, (((sizeScaledImageInOffsetMthdCnt << 2) << 16) | ((ch) << 13) | NV077_IMAGE_IN_OFFSET)); \
    nvPushData (1, (offset));                                               \
    nvPusherAdjust (sizeScaledImageInOffset);                               \
}

#define sizeScaledImageInPointMthdCnt               1
#define sizeScaledImageInPoint                      2
#define nvglScaledImageInPoint(ch, x, y)                                    \
{                                                                           \
    nvPushData (0, (((sizeScaledImageInPointMthdCnt << 2) << 16) | ((ch) << 13) | NV077_IMAGE_IN)); \
    nvPushData (1, ((((y) & 0x0000FFFF) << 16) | ((x) & 0x0000FFFF))); \
    nvPusherAdjust (sizeScaledImageInPoint); \
}

#define sizeScaledImageNotify                       4
#define nvglScaledImageNotify(ch)                                           \
{                                                                           \
    nvPushData (0, (((1 << 2) << 16) | ((ch) << 13) | NV077_NOTIFY));       \
    nvPushData (1, NV077_NOTIFY_WRITE_ONLY);                                \
    nvPushData (2, (((1 << 2) << 16) | ((ch) << 13) | NV077_NO_OPERATION)); \
    nvPushData (3, 0);                                                      \
    nvPusherAdjust (sizeScaledImageNotify);                                 \
}

//-------------------------------------------------------------------------
//                              NV 07C
//                     NV15_VIDEO_LUT_CURSOR_DAC
//-------------------------------------------------------------------------

// 0x00000300
#define sizeSetNv15VideoLUTCursorDACImageDataMthdCnt   2
#define sizeSetNv15VideoLUTCursorDACImageData          3
#define nvglSetNv15VideoLUTCursorDACImageData(ch, index, offset, format)    \
{                                                                           \
    nvPushData (0, (((sizeSetNv15VideoLUTCursorDACImageDataMthdCnt << 2) << 16) | ((ch) << 13) | NV07C_SET_IMAGE_OFFSET(index))); \
    nvPushData (1, offset);                                                 \
    nvPushData (2, format);                                                 \
    nvPusherAdjust (sizeSetNv15VideoLUTCursorDACImageData);                 \
}

//-------------------------------------------------------------------------
//                              NV 096
//                      NV15_CELSIUS_PRIMITIVE
//-------------------------------------------------------------------------

// 0x00000120
#define sizeSetNv15CelsiusSyncSetRWMMthdCnt        3
#define sizeSetNv15CelsiusSyncSetRWM               4
#define nvglSetNv15CelsiusSyncSetRWM(ch, read, write, modulo)               \
{                                                                           \
    nvPushData (0, (((sizeSetNv15CelsiusSyncSetRWMMthdCnt << 2) << 16) | ((ch) << 13) | NV096_SYNC_SET_READ)); \
    nvPushData (1, (read));                                                 \
    nvPushData (2, (write));                                                \
    nvPushData (3, (modulo));                                               \
    nvPusherAdjust (sizeSetNv15CelsiusSyncSetRWM);                          \
}
// 0x0000012c
#define sizeSetNv15CelsiusSyncIncWriteMthdCnt      1
#define sizeSetNv15CelsiusSyncIncWrite             2
#define nvglSetNv15CelsiusSyncIncWrite(ch)                                  \
{                                                                           \
    nvPushData (0, (((sizeSetNv15CelsiusSyncIncWriteMthdCnt << 2) << 16) | ((ch) << 13) | NV096_SYNC_INCREMENT_WRITE)); \
    nvPushData (1, 0);                                                      \
    nvPusherAdjust (sizeSetNv15CelsiusSyncIncWrite);                        \
}
// 0x00000130
#define sizeSetNv15CelsiusSyncStallMthdCnt         1
#define sizeSetNv15CelsiusSyncStall                2
#define nvglSetNv15CelsiusSyncStall(ch)                                     \
{                                                                           \
    nvPushData (0, (((sizeSetNv15CelsiusSyncStallMthdCnt << 2) << 16) | ((ch) << 13) | NV096_SYNC_STALL)); \
    nvPushData (1, 0);                                                      \
    nvPusherAdjust (sizeSetNv15CelsiusSyncStall);                           \
}

#ifdef __cplusplus
}
#endif // __cplusplus

#endif // _NV4DMAC_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\common\inc\nvMultiMon.h ===
/***************************************************************************\
|*                                                                           *|
|*       Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.      *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.  Users and possessors of this source code are     *|
|*     hereby granted a nonexclusive,  royalty-free copyright license to     *|
|*     use this code in individual and commercial software.                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*       Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.      *|
|*                                                                           *|
|*     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY     *|
|*     OF  THIS SOURCE  CODE  FOR ANY PURPOSE.  IT IS  PROVIDED  "AS IS"     *|
|*     WITHOUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPOR-     *|
|*     ATION DISCLAIMS ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,     *|
|*     INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY, NONINFRINGE-     *|
|*     MENT,  AND FITNESS  FOR A PARTICULAR PURPOSE.   IN NO EVENT SHALL     *|
|*     NVIDIA, CORPORATION  BE LIABLE FOR ANY SPECIAL,  INDIRECT,  INCI-     *|
|*     DENTAL, OR CONSEQUENTIAL DAMAGES,  OR ANY DAMAGES  WHATSOEVER RE-     *|
|*     SULTING FROM LOSS OF USE,  DATA OR PROFITS,  WHETHER IN AN ACTION     *|
|*     OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  ARISING OUT OF     *|
|*     OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOURCE CODE.     *|
|*                                                                           *|
|*     U.S. Government  End  Users.   This source code  is a "commercial     *|
|*     item,"  as that  term is  defined at  48 C.F.R. 2.101 (OCT 1995),     *|
|*     consisting  of "commercial  computer  software"  and  "commercial     *|
|*     computer  software  documentation,"  as such  terms  are  used in     *|
|*     48 C.F.R. 12.212 (SEPT 1995)  and is provided to the U.S. Govern-     *|
|*     ment only as  a commercial end item.   Consistent with  48 C.F.R.     *|
|*     12.212 and  48 C.F.R. 227.7202-1 through  227.7202-4 (JUNE 1995),     *|
|*     all U.S. Government End Users  acquire the source code  with only     *|
|*     those rights set forth herein.                                        *|
|*                                                                           *|
 \***************************************************************************/
#ifndef _nvMultiMon_h
#define _nvMultiMon_h

//
// This file contains constants shared between the display and miniport drivers for NT40 and Win2K.
// These are used for the MultiMon modes for NV11 dual head cards.
// This file also contains the TwinView definitions (previously in win9x\inc\escape.h) used by Win9x driver and 
// the NT40/Win2K drivers.
//

#ifdef __cplusplus
extern "C"
{
#endif

// Uncomment this line to enable the Win2K hot key driver code  for laptops
#define ENABLE_WIN2K_HOTKEY_CODE

// maximum number of heads this driver supports
#define NV_MAX_HEADS   2

// Some special bitmask definitions for the new head API of resman.
#define BITMASK_CRT0    0x1
#define BITMASK_CRT1    0x2
#define BITMASK_DFP0    0x10000
#define BITMASK_TV0     0x100
#define BITMASK_INVALID_DEVICE 0x0
#define BITMASK_ALL_CRT 0xff
#define BITMASK_ALL_TV 0xff00
#define BITMASK_ALL_DFP 0xff0000

    
//
// The table entries were taken from the GTF table in the miniport in vesadata.c
// Returns true if the resolution specified by (modeWidth, modeHeight) is a horizontally doubled resolution.
//
#define HORIZONTAL_MODE(modeWidth, modeHeight) \
        (\
            (modeWidth == 2048 * 2 && modeHeight == 1536 * 1) ||\
            (modeWidth == 1920 * 2 && modeHeight == 1440 * 1) ||\
            (modeWidth == 1920 * 2 && modeHeight == 1200 * 1) ||\
            (modeWidth == 1920 * 2 && modeHeight == 1080 * 1) ||\
            (modeWidth == 1856 * 2 && modeHeight == 1392 * 1) ||\
            (modeWidth == 1800 * 2 && modeHeight == 1440 * 1) ||\
            (modeWidth == 1792 * 2 && modeHeight == 1344 * 1) ||\
            (modeWidth == 1600 * 2 && modeHeight == 1200 * 1) ||\
            (modeWidth == 1600 * 2 && modeHeight == 1024 * 1) ||\
            (modeWidth == 1600 * 2 && modeHeight == 1000 * 1) ||\
            (modeWidth == 1600 * 2 && modeHeight == 900 * 1) ||\
            (modeWidth == 1600 * 2 && modeHeight == 880 * 1) ||\
            (modeWidth == 1400 * 2 && modeHeight == 1050 * 1) ||\
            (modeWidth == 1360 * 2 && modeHeight == 768 * 1) ||\
            (modeWidth == 1280 * 2 && modeHeight == 1024 * 1) ||\
            (modeWidth == 1280 * 2 && modeHeight == 960 * 1) ||\
            (modeWidth == 1280 * 2 && modeHeight == 800 * 1) ||\
            (modeWidth == 1280 * 2 && modeHeight == 768 * 1) ||\
            (modeWidth == 1152 * 2 && modeHeight == 864 * 1) ||\
            (modeWidth == 1024 * 2 && modeHeight == 768 * 1) ||\
            (modeWidth == 960 * 2 && modeHeight == 720 * 1) ||\
            (modeWidth == 864 * 2 && modeHeight == 480 * 1) ||\
            (modeWidth == 856 * 2 && modeHeight == 480 * 1) ||\
            (modeWidth == 852 * 2 && modeHeight == 480 * 1) ||\
            (modeWidth == 848 * 2 && modeHeight == 480 * 1) ||\
            (modeWidth == 800 * 2 && modeHeight == 600 * 1) ||\
            (modeWidth == 720 * 2 && modeHeight == 480 * 1) ||\
            (modeWidth == 640 * 2 && modeHeight == 480 * 1) ||\
            (modeWidth == 640 * 2 && modeHeight == 400 * 1) ||\
            (modeWidth == 512 * 2 && modeHeight == 384 * 1) ||\
            (modeWidth == 480 * 2 && modeHeight == 360 * 1) ||\
            (modeWidth == 400 * 2 && modeHeight == 300 * 1) ||\
            (modeWidth == 320 * 2 && modeHeight == 240 * 1) ||\
            (modeWidth == 320 * 2 && modeHeight == 200 * 1)\
        )

//
// The table entries were taken from the GTF table in the miniport in vesata.c
// Returns true if the resolution specified by (modeWidth, modeHeight) is a vertically doubled resolution.
//
#define VERTICAL_MODE(modeWidth, modeHeight) \
        (\
            (modeWidth == 2048 * 1 && modeHeight == 1536 * 2) ||\
            (modeWidth == 1920 * 1 && modeHeight == 1440 * 2) ||\
            (modeWidth == 1920 * 1 && modeHeight == 1200 * 2) ||\
            (modeWidth == 1920 * 1 && modeHeight == 1080 * 2) ||\
            (modeWidth == 1856 * 1 && modeHeight == 1392 * 2) ||\
            (modeWidth == 1800 * 1 && modeHeight == 1440 * 2) ||\
            (modeWidth == 1792 * 1 && modeHeight == 1344 * 2) ||\
            (modeWidth == 1600 * 1 && modeHeight == 1200 * 2) ||\
            (modeWidth == 1600 * 1 && modeHeight == 1024 * 2) ||\
            (modeWidth == 1600 * 1 && modeHeight == 1000 * 2) ||\
            (modeWidth == 1600 * 1 && modeHeight == 900 * 2) ||\
            (modeWidth == 1600 * 1 && modeHeight == 880 * 2) ||\
            (modeWidth == 1400 * 1 && modeHeight == 1050 * 2) ||\
            (modeWidth == 1360 * 1 && modeHeight == 768 * 2) ||\
            (modeWidth == 1280 * 1 && modeHeight == 1024 * 2) ||\
            (modeWidth == 1280 * 1 && modeHeight == 960 * 2) ||\
            (modeWidth == 1280 * 1 && modeHeight == 800 * 2) ||\
            (modeWidth == 1280 * 1 && modeHeight == 768 * 2) ||\
            (modeWidth == 1152 * 1 && modeHeight == 864 * 2) ||\
            (modeWidth == 1024 * 1 && modeHeight == 768 * 2) ||\
            (modeWidth == 960 * 1 && modeHeight == 720 * 2) ||\
            (modeWidth == 864 * 1 && modeHeight == 480 * 2) ||\
            (modeWidth == 856 * 1 && modeHeight == 480 * 2) ||\
            (modeWidth == 852 * 1 && modeHeight == 480 * 2) ||\
            (modeWidth == 848 * 1 && modeHeight == 480 * 2) ||\
            (modeWidth == 800 * 1 && modeHeight == 600 * 2) ||\
            (modeWidth == 720 * 1 && modeHeight == 480 * 2) ||\
            (modeWidth == 640 * 1 && modeHeight == 480 * 2) ||\
            (modeWidth == 640 * 1 && modeHeight == 400 * 2) ||\
            (modeWidth == 512 * 1 && modeHeight == 384 * 2) ||\
            (modeWidth == 480 * 1 && modeHeight == 360 * 2) ||\
            (modeWidth == 400 * 1 && modeHeight == 300 * 2) ||\
            (modeWidth == 320 * 1 && modeHeight == 240 * 2) ||\
            (modeWidth == 320 * 1 && modeHeight == 200 * 2)\
        )

//
// Returns TRUE if the mode is a dual screen multi mon mode. It can beeither horizontal or vertical.
//
#define MULTIMON_MODE(modeWidth, modeHeight)\
        (HORIZONTAL_MODE(modeWidth, modeHeight) || VERTICAL_MODE(modeWidth, modeHeight))

//
// Fills in a nvRECTL structure (which is the same structure as RECTL).
//
#define SET_RECT(nvRECTLPtr, leftVal, topVal, rightVal, bottomVal)\
{\
    (nvRECTLPtr)->left = (leftVal);\
    (nvRECTLPtr)->top =  (topVal);\
    (nvRECTLPtr)->right =  (rightVal);\
    (nvRECTLPtr)->bottom =  (bottomVal);\
}



//******************************************************************************
// Bitmask flag for support desktop
// NOTE: These definitions must match those in the NV miniport's 'NV.h'!
//******************************************************************************
//
// 31            24 23           16                               0
// .-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-.
// |  Secondary        Primary             Master Flag             |
// `-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-'
//
// Master Flag            : bit 0 - bit 15
// Primary Display Flag   : bit 16 - bit 23
// Secondary Display Flag : bit 24 - bit 31
//
//******************************************************************************
#define NV_VIRTUAL_DESKTOP_1        0x00010000
#define NV_VIRTUAL_DESKTOP_2        0x01000000

// NV_SPANNING_MODE is virtual desktop (cxScreen, cyScreen) enabled.
// ie, ppdev->ulMode to mode table resolution does not match to (cxScreen, cyScreen)
// additional information for set mode is passed from IOCTL_VIDEO_SET_DESKTOP_INFO_MODE
// to miniport driver.

#define NV_TWO_DACS                 0x01
#define NV_CLONE_DESKTOP            0x02
#define NV_SPANNING_MODE            0x04
#define NV_ENABLE_CLASS_SET_MODE    0x08

#define NV_ENABLE_VIRTUAL_DESKTOP   (NV_VIRTUAL_DESKTOP_1 | NV_VIRTUAL_DESKTOP_2)
//
// Values for the ppdev->ulDACStatus[NV_NO_DACS]
//
#define DAC_STATUS_ON_BOARD      1   // The DAC is onboard.
#define DAC_STATUS_CONNECTED    2   // The DAC is connected to a device (CRT/DFP/TV).
#define DAC_STATUS_ACTIVE       4   // The DAC is active. For example, in spanning mode and clone mode, both dacs are active.
                                    // In normal mode, only one head is active.
//
// Registry key "PanScanSelection"
// absent or 0: pan-scan in only secondary monitor of clone mode.
// 1: Enable pan-scan in all modes.
// 2: Disable pan-scan in all modes. 
//
#define PAN_SCAN_SELECTION_CLONE_SECONDARY_ONLY 0
#define PAN_SCAN_SELECTION_ENABLE_ALL           1
#define PAN_SCAN_SELECTION_DISABLE_ALL          2

//
// A private named event between the control panel and miniport on Win2K.
//
#define NVCPL_EVENT_HOTKEY "NVCplHotKeyEvent"
#define NVCPL_EVENT_HOTKEY_DRIVER "\\BaseNamedObjects\\"NVCPL_EVENT_HOTKEY


//
// Actions to be performed on named events for Win2K/NT4.0
//
#define EVENT_ACTION_CREATE 1
#define EVENT_ACTION_SIGNAL 2
#define EVENT_ACTION_CLEAR  3


//*****************************************************************************
//
// NV11 TwiNView definitions for controlling dual CRTC functionality
// (previously in Win9x\inc\escape.h).
//
typedef struct  _nvRECTL
{
    long    left;
    long    top;
    long    right;
    long    bottom;
}   nvRECTL;
#define NV_NO_DACS  2

//
// The device scan bit flags. Used in Win2K/NT4.0 only.
// These are used for the "ulHeadDeviceOptions" field in the GET_DEVICE_SCAN_DATA escape call.
//
#define HEAD_DEVICE_OPTION_CRT 0x1
#define HEAD_DEVICE_OPTION_DFP 0x2
#define HEAD_DEVICE_OPTION_TV  0x4

//
// This indicates that nothing is connected on this head
//
#define INVALID_DEVICE_TYPE 0x9999

// - Added escapes for the control panel to Get the deviceOptions matrix and to initiate the device scan. And
// - to set the timing mode override.
// - This is for TwinView for Win2K/NT4.0 only.
#define NV_ESC_GET_DEVICE_SCAN_DATA                 0x6992
#define NV_ESC_INDUCE_DEVICE_SCAN                   0x6993

typedef struct _GET_DEVICE_SCAN_DATA_TYPE {
    unsigned long ulNumberDacsOnBoard;
    unsigned long ulNumberDacsConnected;
    unsigned long ulNumberDacsActive;
    unsigned long ulHeadDeviceOptions[NV_NO_DACS];
} GET_DEVICE_SCAN_DATA_TYPE;


// escape for control panel to get the desired deviceMask after the NVSVC is signalled for a device change.
#define NV_ESC_GET_DEVICE_MASK                   0x6994
typedef struct _GET_DEVICE_MASK_DATA_TYPE {
    unsigned long ulDeviceMask;
} GET_DEVICE_MASK_DATA_TYPE;

//
// Support for the hardware icons (such as the battery status for Gateway/Quantas). Used in Win2K/NT4.0 and Win9X/WinME.
// NV_ESC_DISPLAY_ICON: Displays the requested icon as a hardware cursor after caching current cursor.
// NV_ESC_HIDE_ICON: Removes the displayed Icon and restores the desktop cursor to the cached cursor.
//
typedef struct _DISPLAY_ICON_DATA_TYPE {
    unsigned long ulStartX;
    unsigned long ulStartY; // The position of upper left corner of the icon
    unsigned long ulWidth;
    unsigned long ulHeight; // dimensions of the icon bitmap
    void * pvBitmap;        // Bitmap pointer for the 32BPP, ARGB icon
    unsigned long ulFlag;   // For future usage
} DISPLAY_ICON_DATA_TYPE;
#define NV_ESC_DISPLAY_ICON                 0x6996
#define NV_ESC_HIDE_ICON                    0x6997

// DrvEscape function call to disable HW cursor with *(ULONG *)pvIn != FALSE
// if *(ULONG *)pvIn == FALSE, the HW cursor will be re-enabled.
#define NV_ESC_DISABLE_HW_CURSOR            0x6998

//
// DrvEscape() call for the NVSVC to report its current status to the display driver.
//
#define NV_ESC_SET_NVSVC_STATUS            0x6999
//
// The possible NVSVC_STATUS values. At bootup time, display driver will assume a STOPPED status till
// NVSVC makes this call.
//
#define NVSVC_STATUS_STOPPED    0
#define NVSVC_STATUS_STARTED    1
#define NVSVC_STATUS_PAUSED     2

// escape call for the control panel to query the saved settings.
// The input is the QUERY_SAVE_SETTINGS structure and the output is the NVTWINVIEWDATA structure for the
// requested device combo. The caller must have preallocated the memory for the output structure which is
// sizeof(NVTWINVIEWDATA). The display driver saves the settings for standard/clone and span modes. 
// WinXP DualView is not saved since it is all handled directly by the OS and the OS panel.
#define NV_ESC_QUERY_SAVE_SETTINGS            0x7010
// Number of entries in the save settings table. The display driver saves the TwinViewInfo for each
// device and for each device combo in clone and span modes. Currently the devices are CRT0, LCD, TV and CRT1. 
#define NUM_ENTRIES_SAVE_SETTINGS 28
// Input to the query to get the saved settings. Caller should fill up all fields.
typedef struct _QUERY_SAVE_SETTINGS
{
    unsigned long ulState;
    unsigned long ulOrientation;
    unsigned long ulDeviceMask[NV_NO_DACS];
    unsigned long ulDeviceDisplay[NV_NO_DACS]; // Per requirments for example, LCD+CRT is treated 
                                               // as the same combo as CRT+LCD.
} QUERY_SAVE_SETTINGS;
// Input is a fully constructed NVTWINVIEWDATA structure. This structure will be saved in the correct slot
// in the registry "SaveSettings" table for the State+device combo of the NVTWINVIEWDATA structure. 
// No sanity check or validation will be done on
// this input structure. There is no output structure for this escape call.
#define NV_ESC_FORCE_SAVE_SETTINGS  0x7011



// use these values for the "dwFlag" member of NVTWINVIEWDATA
#define NVTWINVIEW_FLAG_GET                      0
#define NVTWINVIEW_FLAG_SET                      1
// use these values for the "dwAction" member of NVTWINVIEWDATA
#define NVTWINVIEW_ACTION_SETGET_STATE           1
#define NVTWINVIEW_ACTION_SETGET_DEVICE_TYPE     2
#define NVTWINVIEW_ACTION_SETGET_VIRTUALDESKTOP  3
#define NVTWINVIEW_ACTION_SETGET_FREEZE_ORIGIN   4
#define NVTWINVIEW_ACTION_SETGET_PRIMARY_CRTC    5
#define NVTWINVIEW_ACTION_SETGET_VIRTUAL_MODE    6
#define NVTWINVIEW_ACTION_SETGET_PHYSICAL_MODE   7

// The following actions are applicable only for NT40 and Win2K. Win9X can ignore this.
#define NVTWINVIEW_ACTION_SETGET_PHYSICAL_VIRTUAL_MODELIST   8
#define NVTWINVIEW_ACTION_SETGET_GDI_MODELIST    9
#define NVTWINVIEW_ACTION_SETGET_PHYSICAL_VIRTUAL_MODE     11

#define NVTWINVIEW_ACTION_VALIDATE_VIRTUAL_MODE  20
#define NVTWINVIEW_ACTION_VALIDATE_PHYSICAL_MODE 21
#define NVTWINVIEW_ACTION_SETGET_TIMING_OVERRIDE 22

// returns the last used TV format in the dwTVFormat member of NVTWINVIEW_DEVICE_TYPE_DATA
#define NVTWINVIEW_ACTION_GET_LAST_TV_FORMAT     23

// These escapes are to support DVD ZOOM under Win9X. (and maybe NT?)
#define NVTWINVIEW_ACTION_LOCK_HWCRTC                       30
#define NVTWINVIEW_ACTION_UNLOCK_HWCRTC                     31
#define NVTWINVIEW_ACTION_SETGET_PHYSICAL_MODE_IMMEDIATE    32

// The following is for Win9X. Win2K/NT4.0 can ignore this.
#define NVTWINVIEW_ACTION_MAP_LOG_TO_PHYS_HEAD   40

#define NVTWINVIEW_ACTION_SETGET_CLONE_GAMMA    41
#define NVTWINVIEW_ACTION_ROTATE_CLONE_DEVICES  42
#define NVTWINVIEW_ACTION_BEGIN_DISPLAY_CHANGE  43
#define NVTWINVIEW_ACTION_END_DISPLAY_CHANGE    44
#define NVTWINVIEW_ACTION_GET_LARGEST_EDID_MODE 45

#ifndef WINNT
// This escape allows changing the display device configration
// all in one escape. The caller can specify STANDARD or CLONE
// state and all the display devices necessary for the state specified.
// Note that this sub-escape only uses the dwFlag and dwAction fields
// from NVTWINVIEWDATA. All other data pertinent to this call are
// in the structure _NVTWINVIEW_DISPLAY_CONFIG below.
//
// On a NVTWINVIEW_FLAG_SET, the structure fields should be as follows:
// dwActiveDevices should contain a 1 bit for each display they want to
//   turn on.
//   Bit 0 -- the primary display
//   Bit 1 -- first clone display
//   etc....
//   (Hopefully this is forward looking to the day when we have N heads).
//   Note that with two heads, as we have at the time of this writing,
//   dwState will either equal 1 for STANDARD mode or 3 for CLONE mode.
//
// dwDeviceMask should contain a 1 bit for each device the caller wants
// to be used.
//   Bits 7:0 indicate CRTs:  Bit 0  = CRT0,  Bit 1  = CRT1, etc...
//   Bits 15:8 indiate TVs:   Bit 8  = TV0,   Bit 9  = TV1,  etc...
//   Bits 23:16 indiate DFPs: Bit 16 = DFP0,  Bit 17 = DFP1, etc...
//   Bits 31:24 are not used.
//
// dwPrimaryDeviceMask should contain a 1 bit in the bit position to
//   indicate which device should be the primary.  The bit defintions
//   are the same as for dwDeviceMask.  Note that only 1 bit should be
//   set in this mask and that the same bit in dwDeviceMask must also
//   be a 1.
//
// dwPhysicalModeFlags should contain a 1 in the same bit positions
//   as the dwDeviceMask for every device that the caller is specifying
//   a new physical mode for. Note that you should never have a 1 in
//   any bit position where dwDeviceMask has a 0.
//   Bits 31:24 are not used.
//
// PhysModes[]  If bit position N of dwPhysicalModeFlags has a 1 in it,
//   then PhysModes[N] is the physical mode to use for that device. Note
//   that the pixel depth is not settable here -- it is determined by the
//   desktop (the virtual mode.) There are two special "physical modes."
//
//   If dwXRes = 0, then the xres and yres for the physical mode will be
//   set to the largest resolution the display device is capable of that
//   does not exceed the desktop resolution.
//
//   If dwXRes = -1, then the xres and yres for the physical mode will be
//   set to the same resolution that the display device had the last time
//   that it was used.
//
// dwSetModesNow   If this is non-0, then the display driver will remap
//   all the display devices and set all the modes within the context of
//   this escape call. If this variable is 0, the display driver just saves
//   the desired state change and expects the caller to issue a
//   ChangeDisplaySettingsEx() in order to get the new state banged into
//   the hardware.
//
// -----------------------------------------------------------------------
// On a NVTWINVIEW_FLAG_GET, the caller fills in the
//   dwPhysicalModeFlags field as described a little ways below. The
//   display driver fills in the following fields on return.
//
// dwActiveDevices will contain a 1 bit for each display that is on
//   Bit 0 -- the primary display
//   Bit 1 -- first clone display
//   etc....
//
// dwDeviceMask will contain a 1 bit for each device in use
//   Bits 7:0 indicate CRTs:  Bit 0  = CRT0,  Bit 1  = CRT1, etc...
//   Bits 15:8 indiate TVs:   Bit 8  = TV0,   Bit 9  = TV1,  etc...
//   Bits 23:16 indiate DFPs: Bit 16 = DFP0,  Bit 17 = DFP1, etc...
//   Bits 31:24 are not used.
//
// dwPrimaryDeviceMask will contain a 1 bit in the bit position to
//   indicate which device is the primary.  The bit defintions
//   are the same as for dwDeviceMask.
//
// PhysModes[]  If bit position N of dwDeviceMask has a 1 in it,
//   then PhysModes[N] is the physical mode either currently set
//   on that device or the maximum physical mode settable on that
//   device depending upon how the caller set the dwPhysicalModeFlags.
//
//  dwPhysicalModeFlags is set by the CALLER. If bit N is a 1,
//   then the driver fills in PhysModes[N] with the CURRENT physical
//   mode on the display device. If bit N is a 0, then the driver
//   fills in PhysModes[N] with the maximal physical mode on the
//   display device.

typedef struct  _PHYSICAL_MODE
{
    unsigned long   dwXRes;
    unsigned long   dwYRes;
    unsigned long   dwRefreshRate;
}   PHYSICAL_MODE;

#define NVTWINVIEW_ACTION_SETGET_DISPLAY_CONFIG 50
typedef struct  _NVTWINVIEW_DISPLAY_CONFIG
{
    unsigned long   dwActiveDevices;
    unsigned long   dwDeviceMask;
    unsigned long   dwPrimaryDeviceMask;
    unsigned long   dwPhysicalModeFlags;
    PHYSICAL_MODE   PhysModes[24];
    unsigned long   dwSetModesNow;
}   NVTWINVIEW_DISPLAY_CONFIG;
#endif

// use these values for the "dwState" member of NVTWINVIEWDATA
#define NVTWINVIEW_STATE_NORMAL                 0
#define NVTWINVIEW_STATE_MULTIMON               1 // to be deleted
#define NVTWINVIEW_STATE_DUALVIEW               1
#define NVTWINVIEW_STATE_CLONE                  2
#define NVTWINVIEW_STATE_SPAN                   3

// When the NVTWINVIEW_ACTION_SETGET_STATE escape is issued,
// a return of the following values in dwSuccess of NVTINWVIEWDATA
// indicates what is needed to make the state change happen.
#define NVTWINVIEW_STATE_CHANGE_FAILED          0
#define NVTWINVIEW_STATE_CHANGE_DONE            1
#define NVTWINVIEW_STATE_CHANGE_NEEDS_REBOOT    2

// use these values for the "dwAutoPan" member of NVTWINVIEW_AUTOPAN_DATA
#define NVTWINVIEW_VIRTUALDESKTOP_OFF           0
#define NVTWINVIEW_VIRTUALDESKTOP_ON            1

// use these values for the "dwState" member of NVTWINVIEWDATA
#define NVTWINVIEW_STATE_AUTO                   0
#define NVTWINVIEW_STATE_DMT                    1
#define NVTWINVIEW_STATE_GTF                    2

// use these values for the "ulTimingOverRide" field of NVTWINVIEW_DEVICE_TYPE_DATA. Used only in Win2K and NT4.0
#define TIMING_OVERRIDE_AUTO                    0
#define TIMING_OVERRIDE_DMT                     1
#define TIMING_OVERRIDE_GTF                     2

typedef struct {
unsigned long dwDeviceMask;        // A unique bitmask in a 32 bit Dword identifying
                                    // this specific output device. (as defined in NVCM.H)

   unsigned long dwDeviceType;      // Monitor, DFP, TV (as defined in NVCM.H)
   unsigned long dwTVFormat;        // Format for TV    (as defined in NVCM.H)
   unsigned long dwXRes;            // Horizontal resolution of secondary device in clone mode (in pixels). Used only by Win9X.
   unsigned long dwYRes;            // Vertical resolution of secondary device in clone mode (in Pixels). Used only by Win9X.
   unsigned long dwBpp;             // For Win9X: color depth of secondary device in clone mode (in Bits per pixel)
                                    // For Win2K/NT40: color depth of this head. The color depths of both heads will be the same.
   unsigned long dwRefresh;         // For Win9X: refresh rate of secondary device in clone mode (actual rate in Hz or 1 for "optimal" or 0 for "default")
                                    // For Win2K/NT40: refresh rate of this head (actual rate in Hz or 1 for "optimal" or 0 for "default"), the
                                    // refresh rates can be different for each head.

   // The following fields are applicable only for NT40 and Win2K. Win9X can ignore this.
   unsigned long dwNumPhysModes;    // The number of physical modes supported by the device. This list is obtained after
                                    // an intersection of EDID and the registry modes. If the device has no EDID, then this
                                    // list simply equals the registry modelist.
   unsigned long dwNumVirtualModes; // The number of virtual modes supported by the device. This list is obtained after
                                    // an intersection of registry modes and the board frame buffer size. 
   nvRECTL    PhysicalRectl;        // Physical coordinates of the device.
   nvRECTL    VirtualRectl;         // Virtual coordinates of the device.
   unsigned long dwEnableDDC; 
   unsigned long dwEnablePanScan;   // Enables the virtual desktop to let the physical resolution
                                    // to be less than the virtual resolution.
   unsigned long dwFreezePanScan;   // Freeze the pan-scan
   unsigned long dwFreezeOriginX;   // The user specified upper left corner for freezing the pan-scan.
   unsigned long dwFreezeOriginY;   // The user specified upper left corner for freezing the pan-scan.
   unsigned long dwTimingOverRide;  // GTF or DMT preference by the user.


} NVTWINVIEW_DEVICE_TYPE_DATA;

typedef struct {
   unsigned long dwVirtualDesktop;  // Virtual Desktop On/Off (clone mode only)
   unsigned long dwPad;
}  NVTWINVIEW_VIRTUALDESKTOP_DATA;

typedef struct {
   unsigned long dwFreezeOrigin;    // Freeze Origin On/Off (clone mode only)
   unsigned long dwOriginX;         // freeze mode x origin (clone mode only)
   unsigned long dwOriginY;         // freeze mode y origin (clone mode only)
}  NVTWINVIEW_FREEZE_ORIGIN_DATA;

typedef struct {
   unsigned long pHWCrtcCX;
   unsigned long pGNLogdevCX;
   unsigned long dwLogicalCrtcIndex;
   unsigned long dwPad;
}  NVTWINVIEW_LOCK_UNLOCK_HWCRTC_DATA;

typedef struct {
   unsigned long pHWCrtcCX;
   unsigned long pGNLogdevCX;
   unsigned long dwLogicalCrtcIndex;
   unsigned long dwPad;
}  NVTWINVIEW_SETGET_PHYSICAL_MODE_IMMEDIATE;




// The mode_entry structure is copied from miniport\nv_mini\nv.h. Anychanges in one file should be reflected
// in the other.
struct Mode_Entry
   {
   unsigned short  ValidMode;
   unsigned short  Width;
   unsigned short  Height;
   unsigned short  Depth;
   unsigned short  RefreshRate;
#ifndef WINNT
   unsigned short  wPad;
   unsigned long   dwPad;
#endif
   };
typedef struct Mode_Entry *PMODE_ENTRY, MODE_ENTRY;

// Toshiba wants to keep the same desktop on hotkey switches.
typedef MODE_ENTRY TOSHIBA_HOTKEY_MODE;

// This is per head information
typedef struct {
   MODE_ENTRY * PhysModeEntries;         // Pointer to alloced memory for the physical mode list.
   unsigned long dwNumPhysModeEntries;   // The number of mode entries in the alloced memory for the physical mode list.
   MODE_ENTRY * VirtualModeEntries;         // Pointer to alloced memory for the physical mode list.
   unsigned long dwNumVirtualModeEntries;   // The number of mode entries in the alloced memory for the physical mode list.

   unsigned long dwDeviceMask;  // Return the modelist info for this deviceMask

   unsigned long dwDeviceType;  // Return the modelist info for this deviceType on this head
   unsigned long dwTVFormat;    // Return the modelist info for this TV format on this head
}  NVTWINVIEW_MODELIST_DATA;

// Values for the dwOrientation field
#define HORIZONTAL_ORIENTATION  1
#define VERTICAL_ORIENTATION    2


typedef struct {
   unsigned long dwFlag;            // flag indicating GET or SET
   unsigned long dwAction;          // indicates action to be performed
   unsigned long dwState;           // normal, multi-mon, clone
   unsigned long dwCrtc;            // indicates CRT number for which action is performed. Used only by Win9X.
                                    // The actions apply to all the heads in Win2K and NT40.
   unsigned long dwSuccess;         // indicates success of call. Driver should return non-zero in this member
                                    // if the escape is successfully handled, or zero for failure
   nvRECTL    DeskTopRectl;           // The overall desktop rectangle. The (left,top) is always (0, 0).
                                    // Applicable only for Win2K and NT40. Win9X can ignore it.
   unsigned long dwBoard;           // The board number in a multi-adapter system.
                                    // Applicable only for NT40. Win9X and Win2K can ignore it.
   unsigned long dwOrientation;     // Horizontal or vertical. For multi-mon mode only.
                                    // Applicable only for NT4.0 and Win2K. Win9x can ignore this.
   unsigned long dwDeviceDisplay[NV_NO_DACS]; // Dynamically switch device; ulDeviceDisplay[0] will be primary; head 0 or head 1
                                    // Applicable only for NT4.0 and Win2K. Win9x can ignore this.

   unsigned long dwAllDeviceMask;  // Bitmask for all the output device connectors in the board. NT4.0/Win2K only.
   unsigned long dwConnectedDeviceMask;  // Bitmask for all the output device connectors in the board. NT4.0/Win2K only.
                                    


   union {
       NVTWINVIEW_DEVICE_TYPE_DATA nvtwdevdata[NV_NO_DACS]; // use with action NVTWINVIEW_ACTION_SETGET_DEVICE_TYPE and NVTWINVIEW_ACTION_SETGET_STATE (if
                                    // dwState == NVTWINVIEW_STATE_CLONE)

       NVTWINVIEW_VIRTUALDESKTOP_DATA    nvtwvirtualdesktopdata;  // use with action NVTWINVIEW_ACTION_SETGET_VIRTUALDESKTOP

       NVTWINVIEW_FREEZE_ORIGIN_DATA nvtwfreezedata; // use with action NVTWINVIEW_ACTION_SETGET_FREEZE_ORIGIN
                                      // Note: union is ignored for  and NVTWINVIEW_ACTION_SETGET_PRIMARY_CRTC and
                                      // NVTWINVIEW_ACTION_SETGET_STATE (if dwState != NVTWINVIEW_STATE_CLONE)

       NVTWINVIEW_MODELIST_DATA   nvtwModeListData[NV_NO_DACS]; // Applicable only for Win2K and NT40. Win9X can ignore it.
                                                    // Use with actions NVTWINVIEW_ACTION_SETGET_PHYS_MODELIST and
                                                    // NVTWINVIEW_ACTION_SETGET_GDI_MODELIST.
#ifndef WINNT
        NVTWINVIEW_DISPLAY_CONFIG  nvtwDisplayConfig;
        unsigned long adwGammaTable[256];
#endif
   } NVTWINVIEWUNION;

   NVTWINVIEW_LOCK_UNLOCK_HWCRTC_DATA nvtwLockUnlockHwcrtc;
   NVTWINVIEW_SETGET_PHYSICAL_MODE_IMMEDIATE nvtwPhysicalModeImmediate;
} NVTWINVIEWDATA;


#ifdef __cplusplus
}
#endif

#endif // _nvPM_h
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\common\inc\nvFourCC.h ===
// **************************************************************************
//
//       Copyright 1993-2000 NVIDIA, Corporation.  All rights reserved.
//
//     NOTICE TO USER:   The source code  is copyrighted under  U.S. and
//     international laws.  Users and possessors of this source code are
//     hereby granted a nonexclusive,  royalty-free copyright license to
//     use this code in individual and commercial software.
//
//     Any use of this source code must include,  in the user documenta-
//     tion and  internal comments to the code,  notices to the end user
//     as follows:
//
//     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY
//     OF  THIS SOURCE  CODE  FOR ANY PURPOSE.  IT IS  PROVIDED  "AS IS"
//     WITHOUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPOR-
//     ATION DISCLAIMS ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,
//     INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY, NONINFRINGE-
//     MENT,  AND FITNESS  FOR A PARTICULAR PURPOSE.   IN NO EVENT SHALL
//     NVIDIA, CORPORATION  BE LIABLE FOR ANY SPECIAL,  INDIRECT,  INCI-
//     DENTAL, OR CONSEQUENTIAL DAMAGES,  OR ANY DAMAGES  WHATSOEVER RE-
//     SULTING FROM LOSS OF USE,  DATA OR PROFITS,  WHETHER IN AN ACTION
//     OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  ARISING OUT OF
//     OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOURCE CODE.
//
//     U.S. Government  End  Users.   This source code  is a "commercial
//     item,"  as that  term is  defined at  48 C.F.R. 2.101 (OCT 1995),
//     consisting  of "commercial  computer  software"  and  "commercial
//     computer  software  documentation,"  as such  terms  are  used in
//     48 C.F.R. 12.212 (SEPT 1995)  and is provided to the U.S. Govern-
//     ment only as  a commercial end item.   Consistent with  48 C.F.R.
//     12.212 and  48 C.F.R. 227.7202-1 through  227.7202-4 (JUNE 1995),
//     all U.S. Government End Users  acquire the source code  with only
//     those rights set forth herein.
//
// **************************************************************************
//  Content:    FOURCC codes used in the nVidia drivers
//
//  Note that this file is meant to be used across ALL operating systems.
//  Do not create any dependency on non-nVidia code.
//
// **************************************************************************
#ifndef _NVFOURCC_H_
#define _NVFOURCC_H_

#include "nvTypes.h"

/* MMIO macros */
#ifndef mmioFOURCC
#define mmioFOURCC( ch0, ch1, ch2, ch3 )                                \
                ( (NvU32)(NvU8)(ch0) | ( (NvU32)(NvU8)(ch1) << 8 ) |    \
                ( (NvU32)(NvU8)(ch2) << 16 ) | ( (NvU32)(NvU8)(ch3) << 24 ) )
#endif // mmioFOURCC

/* FOURCC video formats we support */
#ifndef FOURCC_UYVY
#define FOURCC_UYVY                        mmioFOURCC('U','Y','V','Y')
#endif
#ifndef FOURCC_YUY2
#define FOURCC_YUY2                        mmioFOURCC('Y','U','Y','2')
#endif
#ifndef FOURCC_UYNV
#define FOURCC_UYNV                        mmioFOURCC('U','Y','N','V')
#endif
#ifndef FOURCC_YUNV
#define FOURCC_YUNV                        mmioFOURCC('Y','U','N','V')
#endif
#ifndef FOURCC_YV12
#define FOURCC_YV12                        mmioFOURCC('Y','V','1','2')
#endif
#ifndef FOURCC_NVDS
#define FOURCC_NVDS                        mmioFOURCC('N','V','D','S')
#endif
#ifndef FOURCC_NVMC
#define FOURCC_NVMC                        mmioFOURCC('N','V','M','C')
#endif
#ifndef FOURCC_NV12
#define FOURCC_NV12                        mmioFOURCC('N','V','1','2')
#endif
#ifndef FOURCC_NVID
#define FOURCC_NVID                        mmioFOURCC('N','V','I','D')
#endif
#ifndef FOURCC_NVSP
#define FOURCC_NVSP                        mmioFOURCC('N','V','S','P')
#endif
#ifndef FOURCC_420i
#define FOURCC_420i                        mmioFOURCC('4','2','0','i')
#endif
#ifndef FOURCC_IF09
#define FOURCC_IF09                        mmioFOURCC('I','F','0','9')
#endif
#ifndef FOURCC_YVU9
#define FOURCC_YVU9                        mmioFOURCC('Y','V','U','9')
#endif
#ifndef FOURCC_IV32
#define FOURCC_IV32                        mmioFOURCC('I','V','3','2')
#endif
#ifndef FOURCC_IV31
#define FOURCC_IV31                        mmioFOURCC('I','V','3','1')
#endif
#ifndef FOURCC_RAW8
#define FOURCC_RAW8                        mmioFOURCC('R','A','W','8')
#endif
#ifndef FOURCC_RGB0
#define FOURCC_RGB0                        0 // ?? @mjl@
#endif
#ifndef FOURCC_UBAD
#define FOURCC_UBAD                        mmioFOURCC('U','B','A','D')
#endif

/* FOURCC formats we support for 3d textures */
#ifndef FOURCC_NVT0
#define FOURCC_NVT0                        mmioFOURCC('N','V','T','0')
#endif
#ifndef FOURCC_NVT1
#define FOURCC_NVT1                        mmioFOURCC('N','V','T','1')
#endif
#ifndef FOURCC_NVT2
#define FOURCC_NVT2                        mmioFOURCC('N','V','T','2')
#endif
#ifndef FOURCC_NVT3
#define FOURCC_NVT3                        mmioFOURCC('N','V','T','3')
#endif
#ifndef FOURCC_NVT4
#define FOURCC_NVT4                        mmioFOURCC('N','V','T','4')
#endif
#ifndef FOURCC_NVT5
#define FOURCC_NVT5                        mmioFOURCC('N','V','T','5')
#endif
#ifndef FOURCC_NVT6
#define FOURCC_NVT6                        mmioFOURCC('N','V','T','6')
#endif
#ifndef FOURCC_NVT7
#define FOURCC_NVT7                        mmioFOURCC('N','V','T','7')
#endif
#ifndef FOURCC_NVT8
#define FOURCC_NVT8                        mmioFOURCC('N','V','T','8')
#endif
#ifndef FOURCC_NVT9
#define FOURCC_NVT9                        mmioFOURCC('N','V','T','9')
#endif
#ifndef FOURCC_NVTx
#define FOURCC_NVTx                        mmioFOURCC('N','V','T', 0)
#endif
#ifndef FOURCC_NVT_MASK
#define FOURCC_NVT_MASK                    mmioFOURCC(0xff, 0xff, 0xff, 0)
#endif
#ifndef FOURCC_NVS0
#define FOURCC_NVS0                        mmioFOURCC('N','V','S','0')
#endif
#ifndef FOURCC_NVS1
#define FOURCC_NVS1                        mmioFOURCC('N','V','S','1')
#endif
#ifndef FOURCC_NVS2
#define FOURCC_NVS2                        mmioFOURCC('N','V','S','2')
#endif
#ifndef FOURCC_NVS3
#define FOURCC_NVS3                        mmioFOURCC('N','V','S','3')
#endif
#ifndef FOURCC_NVS4
#define FOURCC_NVS4                        mmioFOURCC('N','V','S','4')
#endif
#ifndef FOURCC_NVS5
#define FOURCC_NVS5                        mmioFOURCC('N','V','S','5')
#endif
#ifndef FOURCC_NVS6
#define FOURCC_NVS6                        mmioFOURCC('N','V','S','6')
#endif
#ifndef FOURCC_NVS7
#define FOURCC_NVS7                        mmioFOURCC('N','V','S','7')
#endif
#ifndef FOURCC_NVS8
#define FOURCC_NVS8                        mmioFOURCC('N','V','S','8')
#endif
#ifndef FOURCC_NVS9
#define FOURCC_NVS9                        mmioFOURCC('N','V','S','9')
#endif
#ifndef FOURCC_NVSx
#define FOURCC_NVSx                        mmioFOURCC('N','V','S', 0)
#endif
#ifndef FOURCC_NVS_MASK
#define FOURCC_NVS_MASK                    mmioFOURCC(0xff, 0xff, 0xff, 0)
#endif
#ifndef FOURCC_NVHU
#define FOURCC_NVHU                        mmioFOURCC('N','V','H','U')
#endif
#ifndef FOURCC_NVHS
#define FOURCC_NVHS                        mmioFOURCC('N','V','H','S')
#endif
#ifndef FOURCC_DXT1
#define FOURCC_DXT1                        mmioFOURCC('D','X','T','1') // Compressed Texture
#endif
#ifndef FOURCC_DXT2
#define FOURCC_DXT2                        mmioFOURCC('D','X','T','2')
#endif
#ifndef FOURCC_DXT3
#define FOURCC_DXT3                        mmioFOURCC('D','X','T','3')
#endif
#ifndef FOURCC_DXT4
#define FOURCC_DXT4                        mmioFOURCC('D','X','T','4')
#endif
#ifndef FOURCC_DXT5
#define FOURCC_DXT5                        mmioFOURCC('D','X','T','5')
#endif


// Note!! The number below is UNRELATED to the number of fourcc's defined above.  
// This is the number that will be USED by the driver. This should be redone! @mjl@

/* total number of fourcc formats we support */
#define NV_MAX_FOURCC_REGULAR (10 + 12)     // 10 ddraw/video, 12 texture

#ifdef DXT_SUPPORT
#define NV_MAX_FOURCC_COMPRESSED 5          // 5 compressed texture
#else
#define NV_MAX_FOURCC_COMPRESSED 0
#endif

#define NV_MAX_FOURCC                       (NV_MAX_FOURCC_REGULAR+NV_MAX_FOURCC_COMPRESSED)

#endif // _NVFOURCC_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\common\inc\nvOverlay.h ===
#ifndef __gl_nvOverlay_h_
#define __gl_nvOverlay_h_

/*
 * Copyright (c) 2000, Nvidia Corporation.  All rights reserved.
 * Portions Copyright (c) 1996, 1997, Silicon Graphics Inc.
 */

// RBiermann: add global definitions for OpenGL Overlay Planes here:

// the number of palette entries
#define ICD_PALETTE_ENTRIES 256

// layer palette transparent index
#define ICD_PALETTE_TRANSPARENT_INDEX 0

// the transparent color is black
#define ICD_PALETTE_TRANSPARENT_COLOR 0

#endif  /* __gl_nvOverlay_h_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\common\inc\nvioctl.h ===
#ifndef _nvioctl_h_
#define _nvioctl_h_

/*
** Copyright 1991-1999, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
**
** $Header$
*/

#include <sys/ioctl.h>

/*
** IOCTLs defines and structures common between the kernel and the GL
*/

/* ---  first the defines --- */
#define IOCTL_NV_OPENGL                         1

#define IOCTL_NV_OPENGL_GET_SINGLE_BACK_1       1
#define IOCTL_NV_OPENGL_GET_SINGLE_DEPTH        2
#define IOCTL_NV_OPENGL_FREE_SINGLE_BACK_DEPTH  3

/* --- now the structure definitions --- */

typedef struct NvOpenGLCommandRec {
    int 	command;
    void *      ret;
} NvOpenGLCommand;

#endif /* _nvioctl_h_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\common\inc\nvPixelFmt.h ===
#ifndef __gl_nvPixelFmt_h_
#define __gl_nvPixelFmt_h_

/*
 * Copyright (c) 1997, Nvidia Corporation.  All rights reserved.
 * Portions Copyright (c) 1996, 1997, Silicon Graphics Inc.
 */

#if defined(WIN32)
/* Remember, this file is used by non-Win32 OpenGL drivers, too. */

int STDCALL __wglNVDescribePixelFormat(int bpp, int iLayerPlane, int iPixelFormat,
                                       unsigned int nBytes,
                                       PIXELFORMATDESCRIPTOR *ppfd,
                                       LAYERPLANEDESCRIPTOR *plpd,
                                       int flags,
                                       int showExtended);

#define NUM_PIXELFORMATS_16 6
#define NUM_PIXELFORMATS_16_OVERLAY 10
#define NUM_PIXELFORMATS_16_STEREO  8
#define NUM_NV20_PIXELFORMATS_16 6
#define NUM_PIXELFORMATS_32 10
#define NUM_PIXELFORMATS_32_OVERLAY 16
#define NUM_PIXELFORMATS_32_STEREO  12
#define NUM_NV11_PIXELFORMATS_32 15

extern PIXELFORMATDESCRIPTOR *NV4PixelFormats16[NUM_PIXELFORMATS_16];
extern PIXELFORMATDESCRIPTOR *NV4PixelFormats16Stereo[NUM_PIXELFORMATS_16_STEREO];
extern PIXELFORMATDESCRIPTOR *NV20PixelFormats16[NUM_NV20_PIXELFORMATS_16];
extern PIXELFORMATDESCRIPTOR *NV4PixelFormats32[NUM_PIXELFORMATS_32];
extern PIXELFORMATDESCRIPTOR *NV4PixelFormats32Overlay[NUM_PIXELFORMATS_32_OVERLAY];
extern PIXELFORMATDESCRIPTOR *NV4PixelFormats32Stereo[NUM_PIXELFORMATS_32_STEREO];
extern PIXELFORMATDESCRIPTOR *NV11PixelFormats32[NUM_NV11_PIXELFORMATS_32];

#endif /* defined(WIN32) */

#define NV_PFD_SUPPORTS_COLOR32_DEPTH16    0x00000001 /* nv11 */
#define NV_PFD_SUPPORTS_COLOR16_DEPTH32    0x00000002 /* nv20 */
#define NV_PFD_SUPPORTS_OVERLAYS           0x00000004
#define NV_PFD_SUPPORTS_SWAPCOPYONLY       0x00000008
#define NV_PFD_SUPPORTS_SWAP_LAYER_BUFFERS 0x00000010
#define NV_PFD_SUPPORTS_STEREO             0x00000020
#define NV_PFD_SUPPORTS_PBUFFERS           0x00000040
#define NV_PFD_SUPPORTS_MULTISAMPLE        0x00000080

// ---------- Internal Nvidia Pixel Format structure ---------------------

// bits for flags1
#define NVPF_DRAW_TO_WINDOW       0x00000001
#define NVPF_DRAW_TO_BITMAP       0x00000002
#define NVPF_DRAW_TO_PBUFFER      0x00000004
#define NVPF_NEED_PALETTE         0x00000008
#define NVPF_NEED_SYSTEM_PALETTE  0x00000010
#define NVPF_SWAP_LAYER_BUFFERS   0x00000020
#define NVPF_SUPPORT_GDI          0x00000040
#define NVPF_SUPPORT_OPENGL       0x00000080
#define NVPF_DOUBLE_BUFFER        0x00000100
#define NVPF_STEREO               0x00000200
#define NVPF_SHARE_DEPTH          0x00000400
#define NVPF_SHARE_STENCIL        0x00000800
#define NVPF_SHARE_ACCUM          0x00001000
#define NVPF_TRANSPARENCY         0x00002000

typedef enum {
	NVPF_SWAP_UNDEFINED,
    NVPF_SWAP_COPY,
    NVPF_SWAP_EXCHANGE
} __GLNVswapMethod;

typedef enum {
    NVPF_PIXEL_RGBA,
    NVPF_PIXEL_COLOR_INDEX
} __GLNVpixelType;

typedef struct __GLNVpixelFormatRec {
    NvU32            flags1;
    __GLNVswapMethod swapMethod;
    __GLNVpixelType  pixelType;
    unsigned int     numOverlays;
    unsigned int     numUnderlays;
    unsigned int     colorBits;
    unsigned int     redBits;
    unsigned int     redShift;
    unsigned int     greenBits;
    unsigned int     greenShift;
    unsigned int     blueBits;
    unsigned int     blueShift;
    unsigned int     alphaBits;
    unsigned int     alphaShift;
    unsigned int     accumBits;
    unsigned int     accumRedBits;
    unsigned int     accumGreenBits;
    unsigned int     accumBlueBits;
    unsigned int     accumAlphaBits;
    unsigned int     depthBits;
    unsigned int     stencilBits;
    unsigned int     auxBuffers;
    unsigned int     transparentRed;
    unsigned int     transparentGreen;
    unsigned int     transparentBlue;
    unsigned int     transparentAlpha;
    unsigned int     transparentIndex;
    unsigned int     maxPbufferPixels;
    unsigned int     maxPbufferWidth;
    unsigned int     maxPbufferHeight;
    unsigned int     sampleBuffers;
    unsigned int     samples;
} __GLNVpixelFormat;

#endif  /* __gl_nvPixelFmt_h_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\common\inc\nvOverlaySurf.h ===
/***************************************************************************\
|*                                                                           *|
|*       Copyright 1993-2000 NVIDIA, Corporation.  All rights reserved.      *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.  Users and possessors of this source code are     *|
|*     hereby granted a nonexclusive,  royalty-free copyright license to     *|
|*     use this code in individual and commercial software.                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY     *|
|*     OF  THIS SOURCE  CODE  FOR ANY PURPOSE.  IT IS  PROVIDED  "AS IS"     *|
|*     WITHOUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPOR-     *|
|*     ATION DISCLAIMS ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,     *|
|*     INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY, NONINFRINGE-     *|
|*     MENT,  AND FITNESS  FOR A PARTICULAR PURPOSE.   IN NO EVENT SHALL     *|
|*     NVIDIA, CORPORATION  BE LIABLE FOR ANY SPECIAL,  INDIRECT,  INCI-     *|
|*     DENTAL, OR CONSEQUENTIAL DAMAGES,  OR ANY DAMAGES  WHATSOEVER RE-     *|
|*     SULTING FROM LOSS OF USE,  DATA OR PROFITS,  WHETHER IN AN ACTION     *|
|*     OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  ARISING OUT OF     *|
|*     OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOURCE CODE.     *|
|*                                                                           *|
|*     U.S. Government  End  Users.   This source code  is a "commercial     *|
|*     item,"  as that  term is  defined at  48 C.F.R. 2.101 (OCT 1995),     *|
|*     consisting  of "commercial  computer  software"  and  "commercial     *|
|*     computer  software  documentation,"  as such  terms  are  used in     *|
|*     48 C.F.R. 12.212 (SEPT 1995)  and is provided to the U.S. Govern-     *|
|*     ment only as  a commercial end item.   Consistent with  48 C.F.R.     *|
|*     12.212 and  48 C.F.R. 227.7202-1 through  227.7202-4 (JUNE 1995),     *|
|*     all U.S. Government End Users  acquire the source code  with only     *|
|*     those rights set forth herein.                                        *|
|*                                                                           *|
 \***************************************************************************/

#ifndef _NVOVERLAYSURF_H_
#define _NVOVERLAYSURF_H_

#define NVDBG_LEVEL_OVERLAY_INFO 0x80000000

#ifdef DEBUG

#define NV_DBG_SHOW_FOURCC()                                                    \
    char fourCCStr[5];                                                          \
    fourCCStr[0] = (char)pSurf->lpGbl->ddpfSurface.dwFourCC & 0xFF;             \
    fourCCStr[1] = (char)(pSurf->lpGbl->ddpfSurface.dwFourCC >> 8) & 0xFF;      \
    fourCCStr[2] = (char)(pSurf->lpGbl->ddpfSurface.dwFourCC >> 16) & 0xFF;     \
    fourCCStr[3] = (char)(pSurf->lpGbl->ddpfSurface.dwFourCC >> 24) & 0xFF;     \
    fourCCStr[4] = 0;                                                           \
    DPF_LEVEL (NVDBG_LEVEL_OVERLAY_INFO, "FOURCC %s allocation: size=%u bytes", \
               &fourCCStr, dwBlockSize );

#else // NOT DEBUG

#define NV_DBG_SHOW_FOURCC()

#endif // DEBUG

// external functions

extern DWORD VppCreateFourCCSurface(Vpp_t *pVpp, LPDDRAWI_DDRAWSURFACE_LCL pSurf, LPDDRAWI_DIRECTDRAW_GBL pDDGbl, DWORD dwExtraSize, DWORD dwExtraNumSurfaces, DWORD dwBlockHeight);
extern void VppCalcExtraSurfaceSpace(Vpp_t *pVpp, LPDDRAWI_DDRAWSURFACE_LCL pDDSLcl, NvU32 displayHeight, NvU32 dwRequestedSurfaces, NvU32 *dwExtraSize, NvU32 *dwExtraNumSurfaces, NvU32 *dwBlockHeight);
#endif // _DDSURF4CC_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\common\inc\nvPatchInterface.h ===
//**************************************************************************
//
//       Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.
//
//     NOTICE TO USER:   The source code  is copyrighted under  U.S. and
//     international laws.  Users and possessors of this source code are
//     hereby granted a nonexclusive,  royalty-free copyright license to
//     use this code in individual and commercial software.
//
//     Any use of this source code must include,  in the user documenta-
//     tion and  internal comments to the code,  notices to the end user
//     as follows:
//
//       Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.
//
//     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY
//     OF  THIS SOURCE  CODE  FOR ANY PURPOSE.  IT IS  PROVIDED  "AS IS"
//     WITHOUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPOR-
//     ATION DISCLAIMS ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,
//     INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY, NONINFRINGE-
//     MENT,  AND FITNESS  FOR A PARTICULAR PURPOSE.   IN NO EVENT SHALL
//     NVIDIA, CORPORATION  BE LIABLE FOR ANY SPECIAL,  INDIRECT,  INCI-
//     DENTAL, OR CONSEQUENTIAL DAMAGES,  OR ANY DAMAGES  WHATSOEVER RE-
//     SULTING FROM LOSS OF USE,  DATA OR PROFITS,  WHETHER IN AN ACTION
//     OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  ARISING OUT OF
//     OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOURCE CODE.
//
//     U.S. Government  End  Users.   This source code  is a "commercial
//     item,"  as that  term is  defined at  48 C.F.R. 2.101 (OCT 1995),
//     consisting  of "commercial  computer  software"  and  "commercial
//     computer  software  documentation,"  as such  terms  are  used in
//     48 C.F.R. 12.212 (SEPT 1995)  and is provided to the U.S. Govern-
//     ment only as  a commercial end item.   Consistent with  48 C.F.R.
//     12.212 and  48 C.F.R. 227.7202-1 through  227.7202-4 (JUNE 1995),
//     all U.S. Government End Users  acquire the source code  with only
//     those rights set forth herein.
//
// **************************************************************************
//
//  Module: nvPatchInterface.h
//        nvPatchInterface specification to allow for shared ogl/d3d access
//
//  History:
//        Daniel Rohrer    (drohrer)      23Jun00      created
//
// **************************************************************************

// using generic C structs for shared library compatability with OGL.

#ifndef __NV_PATCH_INTERFACE_H
#define __NV_PATCH_INTERFACE_H

#include "nvUniversal.h"
#if !defined(IS_OPENGL)
    #define FASTCALL _fastcall
#else
    #include "os.h"
#endif

// FD mutual exclusion 
#define FD_SEMAPHORE_HANDLE                                     0xDDFD0000
#define FD_SEMAPHORE_206E_CONTEXT_DMA                           0xDDFD0001
#define FD_SEMAPHORE_097_CONTEXT_DMA                            0xDDFD0002
//          ... 1-32 should be considered used here for our channels ... 
//#define FD_SEMAPHORE_CONTEXT_DMA                              0xDDFD0020

/*
** Standard polymorphic data types that are not present in older header files.
*/
#if defined(_WIN32) && (_MSC_VER < 1300)

typedef int            intptr_t;
typedef unsigned int   uintptr_t;

#endif

/*****************************************************************************/
// Eval memory allocation. Avoid seperate malloc for each section of memory.
// allocate a big chunk with EV_ALLOC_INIT
// and dole it out efficiently with EV_ALLOC
// free it with EV_FREE
// Only one DECL per routine.
// Use EV_ALLOC_INIT/EV_FREE to alloc/free within a routine.

// To alloc something that will persist to parallel or higher routines,
// use EV_ALLOC_INIT_WITH_CACHE with a NV_PATCH_ALLOC_CACHE
// The higher level routines must free with EV_FREE_CACHE

// Use EV_ALLOC_RESET to use memory chunk allocated by higher level routine.
//
// Use EV_ROUND if necessary to ensure allocations have pointer sized
// granularity to avoid address exceptions on the IA64.

// used by cached-alloc algorithm to avoid allocs on each imm mode call
// Each call to EV_ALLOC_INIT_WITH_CACHE can specify a cache to use.
// The coder must be careful that a cache is not used twice at a time.
#if !defined(IS_OPENGL)
typedef struct {
        void *pBaseCache;
        int bytesAllocCache;
        int countFreeCheck;     // count times past a potential free point
        int inUse;              // for debug check
        void *contextCache;     // for debug check
} NV_PATCH_ALLOC_CACHE;
#define MAX_EV_CACHE                        10

#else
// for OpenGL, these are defined in eval.h
#endif

typedef struct {
        void *context;
        void *pBase;
        void *pAvail;
        void *pAllocatedBase;
        int bytesAlloc;
        int bytesUsed;
        NV_PATCH_ALLOC_CACHE *pCache; // ptr to higher level cache structure
} NV_PATCH_ALLOC_CONTROL;

#define EV_ALLOC_BYTE_ALIGN              0x10
#define EV_CACHE_INFO_SCRATCH               0
#define EV_CACHE_QUADINFO_ETC               1
#define EV_CACHE_9FDMATRICES                2
#define EV_CACHE_AUTO_NORMAL_SETUP          3
#define EV_CACHE_UV_SETUP                   4
#define EV_CACHE_TRI_WEIGHTS                5
#define EV_CACHE_RETESS0                    6
#define EV_CACHE_RETESS1                    7
#define EV_CACHE_DRAW_SW                    8
#define EV_CACHE_SWATHING                   9
// if you add more after '9', you must change MAX_EV_CACHE


#define EV_ALLOC_DECL() NV_PATCH_ALLOC_CONTROL evMemory = {NULL, 0}

#define EV_ALLOC_INIT_WITH_CACHE(CONTEXT, TBYTES, errorLabel, PCACHE) \
        if (evAllocInitWithCache(info, CONTEXT, &evMemory, TBYTES, PCACHE)) { \
evAllocError: \
            nvAssert(("EV_ALLOC_INIT FAILURE",0)); \
            info->retVal |= NV_PATCH_EVAL_ERR_OUT_OF_MEMORY; \
            goto errorLabel; \
        } \

#define EV_ALLOC_INIT_WITH_CACHE2(CONTEXT, TBYTES, errorLabel, PCACHE) \
        if (evAllocInitWithCache(info, CONTEXT, &evMemory, TBYTES, PCACHE)) { \
            nvAssert(("EV_ALLOC_INIT FAILURE",0)); \
            info->retVal |= NV_PATCH_EVAL_ERR_OUT_OF_MEMORY; \
            goto errorLabel; \
        } \

#define EV_ALLOC_INIT(CONTEXT, TBYTES, errorLabel) \
        EV_ALLOC_INIT_WITH_CACHE(CONTEXT, TBYTES, errorLabel, NULL)

#if defined(IS_OPENGL)
#define EV_ALLOC(VAR, CONTEXT, BYTES) {                             \
        int __nBytes;                                               \
        nvAssert(CONTEXT == evMemory.context);                      \
        nvAssert(!((BYTES) & (EV_ALLOC_BYTE_ALIGN - 1)));           \
        evMemory.bytesUsed += (__nBytes = (BYTES));                 \
        nvAssert(evMemory.bytesUsed <= evMemory.bytesAlloc);        \
        if (evMemory.bytesUsed <= evMemory.bytesAlloc) {            \
            *(void **)(&(VAR)) = evMemory.pAvail;                   \
            evMemory.pAvail = (char *)evMemory.pAvail + __nBytes;   \
            nvAssert(!((uintptr_t)evMemory.pAvail & ((sizeof(void *) - 1)))); \
        } else {                                                    \
            VAR = NULL;                                             \
        }                                                           \
        if (!VAR) goto evAllocError;                                \
    }
#else
#define EV_ALLOC(VAR, CONTEXT, BYTES) {                             \
        int __nBytes;                                               \
        nvAssert(!((BYTES) & (EV_ALLOC_BYTE_ALIGN - 1)));           \
        evMemory.bytesUsed += (__nBytes = (BYTES));                 \
        nvAssert(evMemory.bytesUsed <= evMemory.bytesAlloc);        \
        if (evMemory.bytesUsed <= evMemory.bytesAlloc) {            \
            *(void **)(&(VAR)) = evMemory.pAvail;                   \
            evMemory.pAvail = (char *)evMemory.pAvail + __nBytes;   \
            nvAssert(!((uintptr_t)evMemory.pAvail & ((sizeof(void *) - 1)))); \
        } else {                                                    \
            VAR = NULL;                                             \
        }                                                           \
        if (!VAR) goto evAllocError;                                \
    }
#endif

#define EV_ALLOC_FULL(CONTEXT) \
        /* expect equal if pre-calc was accurate */ \
        nvAssert(evMemory.bytesUsed == evMemory.bytesAlloc);

#define EV_FREE(VAR, CONTEXT) { \
        nvAssert(CONTEXT == evMemory.context); \
        if (evMemory.pBase && (VAR)) { \
            if (!evMemory.pCache) { \
                info->callbacks->free(CONTEXT, evMemory.pAllocatedBase); \
            } else { \
                evMemory.pCache->inUse = 0; \
            } \
            evMemory.pBase = NULL; \
            evMemory.pAllocatedBase = NULL; \
        } \
        VAR = NULL; \
    }

#define EV_FREE_CACHE(PCACHE, CONTEXT) { \
        if ((PCACHE)->pBaseCache) { \
            info->callbacks->free((PCACHE)->CONTEXT, (PCACHE)->pBaseCache); \
            (PCACHE)->pBaseCache = NULL; \
        } \
        (PCACHE)->inUse = 0; \
    } \

//#define EV_ROUND(BYTES) \
//    (((BYTES) + (sizeof(void *) - 1)) & ~(sizeof(void *) - 1))

//force 16 byte alignment...
#define EV_ROUND(BYTES) \
    (((BYTES) + (EV_ALLOC_BYTE_ALIGN - 1)) & ~(EV_ALLOC_BYTE_ALIGN - 1))

/*****************************************************************************/
#define NV_PATCH_ATTRIB_POSITION            0
#define NV_PATCH_ATTRIB_VERTEX_WEIGHT       1
#define NV_PATCH_ATTRIB_NORMAL              2
#define NV_PATCH_ATTRIB_COLOR               3
#define NV_PATCH_ATTRIB_SECONDARY_COLOR     4
#define NV_PATCH_ATTRIB_FOG_COORD           5
#define NV_PATCH_ATTRIB_UNUSED0             6
#define NV_PATCH_ATTRIB_UNUSED1             7
#define NV_PATCH_ATTRIB_TEXCOORD0           8
#define NV_PATCH_ATTRIB_TEXCOORD1           9
#define NV_PATCH_ATTRIB_TEXCOORD2           10
#define NV_PATCH_ATTRIB_TEXCOORD3           11
#define NV_PATCH_ATTRIB_TEXCOORD4           12
#define NV_PATCH_ATTRIB_TEXCOORD5           13
#define NV_PATCH_ATTRIB_TEXCOORD6           14
#define NV_PATCH_ATTRIB_TEXCOORD7           15

// Some of the ATTR bit names are used so much, and are so long, 
// they were making line lengths in excess of 140 characters.
// Rather than split the lines, these names have abbreviations
#define ATTR_V  NV_PATCH_ATTRIB_POSITION
#define ATTR_N  NV_PATCH_ATTRIB_NORMAL

//return codes for EvalPatch
#define NV_PATCH_EVAL_OK                 0x1
#define NV_PATCH_EVAL_ERR_OUT_OF_MEMORY  0x10
#define NV_PATCH_EVAL_ERR_NOT_HANDLED    0x20

// D3D, OGL, and Kelvin all use 16 separate vertex attributes.
#define NV_PATCH_NUMBER_OF_ATTRIBS      16

// D3D supports up to 5, OGL supports up to 8, and Kelvin supports up to 16.
// Note that when computing normal patches, an 8th-order nonrational patch
// becomes a 14th-order rational patch, and an 8th-order rational patch
// exceeds the Kelvin limit easily.
#define NV_PATCH_MAX_ORDER              16
#define NV_PATCH_MAX_RETESS             (1+NV_PATCH_MAX_ORDER)

// The maximum size of a swatch is determined by the size of the vertex
// file.   Henry says this is the magic number.  16 might work better, but
// it's not clear.
#define NV_PATCH_KELVIN_SWATCH_SIZE     17


#define NV_PATCH_MAX_TOTAL_STEP 1000    // total steps allowed
#define NV_PATCH_MAX_SWATCH_STEP 40     // max steps within a sub-patch

// When drawing stitch in SW modes, the buffer is this many vertices.
//  +1 because n steps means (n+1) vertices
//  +2 because may need to share 2 vertices between groups of n steps
#define NV_PATCH_MAX_SW_VERTICES (NV_PATCH_MAX_SWATCH_STEP+1+2)

#define EV_AS_INT(x)     (*((int *) &(x)))

typedef float NV_PATCH_CURVE_COEFFS[NV_PATCH_MAX_ORDER][4];
typedef double NV_PATCH_CURVE_COEFFS_D[NV_PATCH_MAX_ORDER][4];

// Matrix structure for matrix math
typedef struct {
    int rows, columns;
    int pad[2];
    NV_PATCH_CURVE_COEFFS data[NV_PATCH_MAX_ORDER];     // [row][col][xyzw]
} FDMatrix;

typedef struct {
    int rows, columns;
    int pad[2];
    NV_PATCH_CURVE_COEFFS_D data[NV_PATCH_MAX_ORDER];   // [row][col][xyzw]
} FDMatrixd;
#define FDMATRIX_HEADER_SIZE    4*sizeof(int)

// For swathing, an array of ptrs to FDMatrices is used to
// find a pointer to a particular FDMatrix given an attribute number
typedef FDMatrix *FDMatrixAttrSet[NV_PATCH_NUMBER_OF_ATTRIBS];

// Evaluated vertex attributes
typedef struct {
   float vertexAttribs[NV_PATCH_MAX_SW_VERTICES][NV_PATCH_NUMBER_OF_ATTRIBS][4];
} NV_PATCH_EVAL_OUTPUT;


// This is given to beginPrimitive to indicate what type of primitive to draw.
typedef enum {
    NV_PATCH_PRIMITIVE_TSTRIP = 1,
    NV_PATCH_PRIMITIVE_TFAN   = 2,
} NV_PATCH_PRIMITIVE_TYPE;

// Information for forward differencing one curve
typedef struct {
    int order;
    int pad[3];
    NV_PATCH_CURVE_COEFFS coeffs;
} NV_PATCH_CURVE_INFO;
#define PATCH_CURVE_HEADER_SIZE     4*sizeof(int)

// For swathing, an array of ptrs to NV_PATCH_CURVE_INFOs is used to
// find a pointer to a particular guard curve given an attribute number
typedef NV_PATCH_CURVE_INFO *FDCurveAttrSet[NV_PATCH_NUMBER_OF_ATTRIBS];

// Enumerant for what basis the patch is defined on
typedef enum {
    NV_PATCH_BASIS_BEZIER      = 0,
    NV_PATCH_BASIS_BSPLINE     = 1,
    NV_PATCH_BASIS_CATMULL_ROM = 2,
} NV_PATCH_BASIS_TYPE;

// Enumerant for the format of the control points
typedef enum {
    NV_PATCH_VERTEX_FORMAT_FLOAT_1 = 0, // Expand to (value,   0.0,   0.0, 1.0)
    NV_PATCH_VERTEX_FORMAT_FLOAT_2 = 1, // Expand to (value, value,   0.0, 1.0);
    NV_PATCH_VERTEX_FORMAT_FLOAT_3 = 2, // Expand to (value, value, value, 1.0);
    NV_PATCH_VERTEX_FORMAT_FLOAT_4 = 3, // No expansion required
    NV_PATCH_VERTEX_FORMAT_D3DCOLOR= 4, // Unpack bytes and remap to [0,1.0]
    NV_PATCH_VERTEX_FORMAT_UBYTE   = 5, // Unpack bytes and remap to [0,1.0]
    NV_PATCH_VERTEX_FORMAT_SHORT_2 = 5, // 2D signed short expanded to (value, value, 0., 1.)
    NV_PATCH_VERTEX_FORMAT_SHORT_4 = 7  // 4D signed short
} NV_PATCH_VERTEX_FORMAT_TYPE;

// Dirty flags for each map
#define NV_PATCH_DIRTY_NONE             0x00000000
#define NV_PATCH_DIRTY_CONTROL_POINTS   0x00000001
#define NV_PATCH_DIRTY_TESSELLATION     0x00000002

// Enumerant for the type of backend
typedef enum {
    NV_PATCH_BACKEND_IMMEDIATE = 1, // call immediately into a NV_PATCH_BACKEND
    NV_PATCH_BACKEND_CELSIUS   = 2, // write a Celsius pushbuffer
    NV_PATCH_BACKEND_KELVIN    = 3, // write a Kelvin pushbuffer
    NV_PATCH_BACKEND_DP2       = 4, // write a DP2 command stream
} NV_PATCH_BACKEND_TYPE;

// Guard information for a single subquad within a fractional tesselation
typedef struct {                                //     |              |
    NV_PATCH_CURVE_INFO *guardU0;               //     |              |center
    NV_PATCH_CURVE_INFO *guardV0;               // Vmid*---UCenter----*-----
    NV_PATCH_CURVE_INFO *guardUCenter;          //     |              |
    NV_PATCH_CURVE_INFO *guardVCenter;          //     |    _         |
    float *uMid;                                //     |   _/|      VCenter
    float *vMid;                                //    V0 _/           |
    float *center;                              //     |/             |
} NV_PATCH_FRAC_GUARD_INFO;                     //     +------U0------*------
                                                //                  Umid

// Guard information for a single attribute for a fractionally tesselated
// tensor product patch
typedef struct {                            //                    u1Mid
    NV_PATCH_CURVE_INFO guardU00;           //       *------U01---->*<-----U11-----*
    NV_PATCH_CURVE_INFO guardU01;           //       |\_            |            _/|
    NV_PATCH_CURVE_INFO guardU10;           //       |  \_          |          _/  |
    NV_PATCH_CURVE_INFO guardU11;           //      V01  _\| 01    VC1    11 |/_  V11
    NV_PATCH_CURVE_INFO guardV00;           //       |              |              |
    NV_PATCH_CURVE_INFO guardV01;           //       v              vcenter        v
    NV_PATCH_CURVE_INFO guardV10;           //  v0Mid*------UC0---->*<-----UC1-----* v1Mid
    NV_PATCH_CURVE_INFO guardV11;           //       ^              ^              ^
    NV_PATCH_CURVE_INFO guardUCenter0;      //       |    _         |         _    |
    NV_PATCH_CURVE_INFO guardUCenter1;      //      V00  _/|  00   VC0    10 |\_  V10
    NV_PATCH_CURVE_INFO guardVCenter0;      //       | _/           |           \_ |
    NV_PATCH_CURVE_INFO guardVCenter1;      //       |/             |             \|
    float u0Mid[4], v0Mid[4], u1Mid[4];     //       *------U00---->*<-----U10-----*
    float v1Mid[4], center[4];              //                    u0Mid
} NV_PATCH_FRAC_QUAD_GUARD_INFO;


// Guard information for a single attribute for a fractionally tesselated
// triangular patch
typedef struct {                            //                +                -
    NV_PATCH_CURVE_INFO guard[3][2];        //               / \               -
    NV_PATCH_CURVE_INFO guardCenter[3];     //              /   \              -
    float mid[3][4];                        //             /     \             -
    float center[4];                        //           g20     g11           -
} NV_PATCH_FRAC_TRI_GUARD_INFO;             //           /         \           -
                                            //          /           \          -
                                            //    mid? +             + mid?    -
                                            //        / \_         _/ \        -
                                            //       /    gc?    gc?   \       -
                                            //      /       \_ _/       \      -
                                            //    g21         + center  g10    -
                                            //    /           |           \    -
                                            //   /           gc?           \   -
                                            //  /             |             \  -
                                            // +------g00-----+------g01-----+ -
                                            //               mid?



// Illustration of quadInfo information.
// Used by all patch styles at the low level swathing and drawing routines
// This is a connonical view assuming that uDir=1 and vDir=1
// The U coordinates are reversed if uDir=0
// The V coordinates are reversed if vDir=0
// Also, pUInner and pVInner may be on the other side of the quad.
//
//     c01                     c11
//      *--------pU1------------*
//      |                    __/|
//      |                   /   |
//      +-----pUInner-------+   |
//      |                   |   |
//      |                   |   |
//      |                   |   |
//     pV0             pVInner pV1
//      |                   |   |
//      |                   |   |
//      |                   |   |
//      |                   |   |
//      |                   |   |
//      +--------pU0--------+---*
//     c00                 pVB c10



// This fake picture of quadInfo below shows transitions on all sides.
// This can never happen, but serves to illustrate the meaning of the
// stitchUBegin/End and stitchVBegin/End values.
// These may be slightly counterintuitive, but that depends on who you are.
// The thing to note is that the regions specified by quadInfo->stitchU* 
// are between curves specified with V. U regions and V curves mix.
// Again, like above, the coordinates of U and V may be reversed if
// the u/vDir is flipped.

//                                 __ quadInfo->stitchVEnd
//                                /
//               c01             /       c11
//                *--------pU1--/---------*  <-- ppGuardSetUEnd at top of regular grid
//                |\__         o       __/|
//                |   \               /   |
// quadInfo->     |   +-pUInnerT------+   |  <-- ppGuardSetUEnd is here if top stitch, quadInfo->pSwatchUEnd for "top" of swatch
//   stitchUBegin---o |               |   |
//                |   pVInnerL        | o---- quadInfo->stitchUEnd
//                |   |               |   |
//               pV0  |        pVInnerR  pV1
//                |   |               |   |
//                |   |               |   |
//                |   +-pUInnerB------+   |  <-- ppGuardSetUBegin is here if bot stitch, quadInfo->pSwatchUBegin for "bot" of swatch
//                | __/         o     \__ |
//                |/             \       \|
//                +--------pU0----\-------*  <-- ppGuardSetUBegin at bot of regular grid
//               c00               \     c10
//                                  \
//                                   -- quadInfo->stitchVBegin

// Following statements use U, but analogously apply equally to V
// ppGuardSetUBegin/UEnd are for the boundaries of the regular grid.
// ppGuardSetUBegin/UEnd may be either pU0, pUInnerL, pUInnerR, or pU1
// see "BEGIN SIMILAR CODE" in nvpatchutil.c
// Some cases are not so obvious, like when the height of the quad
// is only one segment, and there's a top stitch, then
// both ppGuardSetUBegin and UEnd are set to pU0.
// If height is 1, and bot stitch, then both are set to pU1.
// This simplifies other code which must pick off values at the edges of the regular grid.
// Also, ppStitchUInner may be either pU0 or pU1 in degenerate cases.

//
typedef struct {
    // corners of the original control points
    float corners[2][2][4]; // [v][u][xyzw]
} NV_PATCH_CORNER_INFO;

// Common information for any quad drawn by the lower level swathing and drawing code.
// This is for INT/FRAC and QUAD/TRI patches.
typedef struct {
    int nu0, nu1, nv0, nv1;                     // actual number of segments along each edge
    int uMaxSegs, vMaxSegs, uMinSegs, vMinSegs; // MIN and MAX comparing nu0:nu1 and nv0:nv1
    int needUInner, needVInner;                 // set if U/V Inner guards required

    // flags for transitions required.
    // Names refer to original LRTB, not flipped versions or anything
    // HW must render INT and FRAC stitches in order TOP/RIGHT/BOTTOM/LEFT
    int stitchTop, stitchRight, stitchBottom, stitchLeft;

    // These begin/end's mean in the direction of U (L/R) and V (B/T)
    // note: you may find these names confusing, since they don't correspond
    // to U0, U1. In other words, stitchVBegin means U0/UInner create a stitch
    // (in the canonical view).
    // But, we decided to leave things well enough alone.
    int stitchUBegin, stitchUEnd, stitchVBegin, stitchVEnd;

    int u0Dir, v0Dir, u1Dir, v1Dir; // '1' means normal direction (For u this is L-->R, for v this is B-->T)
    int oldu0Dir, oldv0Dir, oldu1Dir, oldv1Dir;

    // MaxDir are directions of regular grid
    int uMaxDir, vMaxDir;
    int olduMaxDir, oldvMaxDir;

    float du0, du1, dv0, dv1, duMax, dvMax; // small step size along edges, and for regular grid

    FDCurveAttrSet pU0;
    FDCurveAttrSet pU1;
    FDCurveAttrSet pV0;
    FDCurveAttrSet pV1;
    FDCurveAttrSet pUInner;
    FDCurveAttrSet pVInner;

    NV_PATCH_CORNER_INFO cornAttr[NV_PATCH_NUMBER_OF_ATTRIBS];      // general guard info
    float *pCorners[NV_PATCH_NUMBER_OF_ATTRIBS][2][2];

    // ptrs to set of edge curves for a given swatch
    FDCurveAttrSet *pSwatchUBegin, *pSwatchUEnd;
    FDCurveAttrSet *pSwatchVBegin, *pSwatchVEnd;

    FDCurveAttrSet *pCurvesTop, *pCurvesBot;
    NV_PATCH_EVAL_OUTPUT *pOut1, *pOut2;

    // CACHED DATA
    // the driver should allocate memory for these data members BEFORE
    // calling into the shared code.  Shared code should not be responsible
    // for the life time of these data members.
    FDMatrix *m00[NV_PATCH_NUMBER_OF_ATTRIBS], *m01[NV_PATCH_NUMBER_OF_ATTRIBS],
             *m10[NV_PATCH_NUMBER_OF_ATTRIBS], *m11[NV_PATCH_NUMBER_OF_ATTRIBS];    //[attribute]  (sub-patch index = 0 for bezier types)

    //we should probably union these....
    NV_PATCH_FRAC_QUAD_GUARD_INFO *guardQF[NV_PATCH_NUMBER_OF_ATTRIBS];             //[attribute]  (sub-patch index = 0 bezier types)
    NV_PATCH_FRAC_TRI_GUARD_INFO  *guardTF[NV_PATCH_NUMBER_OF_ATTRIBS];
} NV_PATCH_QUAD_INFO;

// for quadInfo->setGridCorner
#define NV_PATCH_SET_GRID_CORNER00      0x1
#define NV_PATCH_SET_GRID_CORNER10      0x2
#define NV_PATCH_SET_GRID_CORNER01      0x4
#define NV_PATCH_SET_GRID_CORNER11      0x8
#define NV_PATCH_SET_GRID_CORNER_ALL    0xf

// Information for one map within the current patch
typedef struct {
    unsigned int uorder, vorder;
    float *rawData;
    int stride;         // OGL: stride == typesize*sizeof(float)
    int pitch;          // OGL: pitch == uorder, number of coords
    int ufStride;       // u stride in floats (i.e. 4 floats is 4, not 16)
    int vfStride;       // v stride in floats
    NV_PATCH_VERTEX_FORMAT_TYPE maptype;
    NV_PATCH_VERTEX_FORMAT_TYPE Originaltype;
    unsigned int dirtyFlags;          // Currently ignored
} NV_PATCH_MAP_INFO;

// Declaration of an immediate-mode-style backend
typedef struct {    
    void (*InitBackend)(void *info);
    void (*DestroyBackend)(void *info);
    void (*beginPrimitive)(void *info, NV_PATCH_PRIMITIVE_TYPE primType);
    void (*endPrimitive)(void *info);
    void (*sendVertex)(void *info, NV_PATCH_EVAL_OUTPUT *pData, int index);
    void (*setFrontFace)(void *info, int reversed);
    void (*beginPatch)(void *info);
    void (*endPatch)(void *info);
} NV_PATCH_BACKEND;

// These are the callbacks that the shared code needs access to.  It is NOT SAFE
// to call C standard library or Windows API functions from the shared code!
typedef struct {
    void *(*malloc)(void *context, size_t bytes);
    void (*free)(void *context, void *ptr);
    void (*memcpy)(void *dst, const void *src, size_t bytes);
    void (*flushOutput)(void *context, unsigned int bytesWritten);
} NV_PATCH_DRIVER_CALLBACKS;

#if defined(IS_OPENGL)
  #define __NV_MALLOC(TAG, SIZE)        __GL_MALLOC(TAG, SIZE)
  #define __NV_FREE(TAG, ADDR)          __GL_FREE(TAG, ADDR)
  #define __NV_MEMCPY(DST, SRC, BYTES)  __GL_MEMCOPY(DST, SRC, BYTES)
#else
  #define __NV_MALLOC(TAG, SIZE)        info->callbacks->malloc(TAG, SIZE)
  #define __NV_FREE(TAG, ADDR)          info->callbacks->free(TAG, ADDR)
  #define __NV_MEMCPY(DST, SRC, BYTES)  info->callbacks->memcpy(DST, SRC, BYTES)
#endif

/*****************************************************************************/

// ***** bits for info->swatchFlags
#define NV_PATCH_SWATCH                 0x00000001      // set when swathing
#define NV_PATCH_SWATCH_FLIPUV          0x00000002      // for tri frac

#define NV_PATCH_SWATCH_FIRST_ROW       0x00000100
#define NV_PATCH_SWATCH_LAST_ROW        0x00000200
#define NV_PATCH_SWATCH_FIRST_COL       0x00000400
#define NV_PATCH_SWATCH_LAST_COL        0x00000800

#define NV_PATCH_SWATCH_SAVE_FIRST_ROW  0x00001000
#define NV_PATCH_SWATCH_SAVE_LAST_ROW   0x00002000
#define NV_PATCH_SWATCH_SAVE_FIRST_COL  0x00004000
#define NV_PATCH_SWATCH_SAVE_LAST_COL   0x00008000

#define NV_PATCH_HAS_NORMAL             0x00010000      // indicates to emit normal guard curves
#define NV_PATCH_NO_REGULAR_GRID        0x00020000      // indicates there is no regular grid -- only transitions

// ***** bits for info->flags
#define NV_PATCH_FLAG_TYPE_MASK         0x00000001
#define NV_PATCH_FLAG_TYPE_TRIANGULAR   0x00000001
#define NV_PATCH_FLAG_TYPE_PATCH        0x00000000

#define NV_PATCH_FLAG_TESS_MASK         0x00000002
#define NV_PATCH_FLAG_TESS_FRACTIONAL   0x00000002
#define NV_PATCH_FLAG_TESS_INTEGER      0x00000000

#define NV_PATCH_FLAG_AUTO_MASK         0x0000000C
#define NV_PATCH_FLAG_AUTO_NORMAL       0x00000004
#define NV_PATCH_FLAG_AUTO_UV           0x00000008
#define NV_PATCH_FLAG_AUTO_NONE         0x00000000

#define NV_PATCH_FLAG_CACHE_MASK        0x00000010
#define NV_PATCH_FLAG_DO_NOT_CACHE      0x00000010
#define NV_PATCH_FLAG_SOME_DIRTY_TESS   0x00000100

#define NV_PATCH_FLAG_TRANSPOSE         0x00001000
#define NV_PATCH_FLAG_FLIPPED_U         0x00002000
#define NV_PATCH_FLAG_FLIPPED_V         0x00004000

// bits for transition flag 
#define FIRST_ROW 0x1   //first row transition
#define LAST_ROW  0x2   //last row transition
#define FIRST_COL 0x4   //first column transition
#define LAST_COL  0x8   //last column transition
#define USE_ITE   0x10  //send an inner transition endpoint

// Information about the current patch
typedef struct {
    // Bitmask of which attributes to evaluate (bits 0..15)
    unsigned int evalEnables;   // as specified to the HW interface
    unsigned int swEnables;     // as presented by the SW interface
    // currently, all attributes handled in the shared code are processed
    // and passed to the back-end without any remapping.
    // For D3D, this is totally handeled in higher level code.
    // So, for D3D, all indices in the shared code are HW indices.
    // For OpenGL, when calling the immediate mode interface, the imm mode
    // calls remap from SW to HW indices.
    // For OpenGL, when calling the Kelvin HW, the remap occurs in
    // __glNVEvalMaps as info is copied from the 'gc' to 'info'

    int nAttr;              // number of active attrs
    int maxAttr;            // max attributes required for malloc's
    int firstAttr;          // first attribute found -- used in memcopies
    unsigned int maxOrder;  // max order of all enabled attributes
    int maxSwatch;          // set according to HW or SW swathing
    int nSwatchU, nSwatchV; // swatches in patch, including Begin/End stitch
    int fracSwatchU, fracSwatchV; // swatches not counting inner frac stitches

    int swatchFlags;        // control during swathing using NV_PATCH_SWATCH_*
    int usingHW;            // set if using Kelvin HW
    int cpuType;            // as provided by the RM
    unsigned long counter;  // temporary storage for the current semphore count

    // Evaluation flags
    unsigned int flags;     // NV_PATCH_FLAG_*
    int flipT;              // set if (flags & NV_PATCH_FLAG_FLAG_TRANSPOSE)
    int flipU;              // set if (flags & NV_PATCH_FLAG_FLIPPED_U)
    int flipV;              // set if (flags & NV_PATCH_FLAG_FLIPPED_V)
    int flipUV;             // for stitches
    int flipTUV;            // combine transpose and both flips

    //MOVE TO QUADINFO ---------------->
    unsigned char* cachedPB;        // cached push buffer
    unsigned long  cachedPBSize;    // cached push buffer size
    unsigned long  cachedPBCounter; // hit count
    //<-------------------------

    // CW/CCW reversal for FRAC layered on INT
    int reverse;

    // Description of tesselation factors
    union {
        struct { float nu0, nu1, nv0, nv1; } tensor;
        struct { float n1, n2, n3;         } tri;
    } tess, originaltess;

    // The basis for the patch
    NV_PATCH_BASIS_TYPE basis;

    // Source and destination of AUTO_NORMAL calculations
    int srcNormal, dstNormal;
    int rational;
    float startu, endu, startv, endv;
    // Destination of AUTO_UV calculations
    int srcUV[8], dstUV[8]; //can have up to 8 sets??

    // Information for each map
    NV_PATCH_MAP_INFO maps[NV_PATCH_NUMBER_OF_ATTRIBS];

    // What type of backend we are writing to or calling to
    NV_PATCH_BACKEND_TYPE backendType;

    // Function pointers for shared code to call into
    NV_PATCH_BACKEND *backend;
    NV_PATCH_DRIVER_CALLBACKS *callbacks;

    // Output buffer (pushbuffer, DP2 stream, ...)
    //MAY BE DEPRECATED?????
    unsigned char *buffer;
    unsigned int bufferLength; // in bytes
    int vertexSize;            // expected # of dwords to output per vertex

    // Opaque context pointer
    void *context;

    // for cache-able info
    NV_PATCH_ALLOC_CACHE *pCache[MAX_EV_CACHE];
    unsigned int retVal;    // for deeply nested alloc errors

    float *normalPatch;     // for NV_PATCH_FLAG_AUTO_NORMAL
    float *UVPatch;         // for NV_PATCH_FLAG_AUTO_UV

    // These point to the guard corners of the regular grid. They are in this
    // top-level structure to be used by all patch types.
    // Instead of fancy attribute arrays, they are simply enumerated for
    // the two attributes which require guard corners: vertex, normal
    // Think of drawing the regular grid from lower-left to upper-right.
    // These names match that orientation so the regular grid routine doesn't
    // need to worry about various orientation flipping and swatching cases.
    // Perhaps LL and LR are not needed for HW, but they're set up for now.
    // Generally these points are the corners of the regular grid,
    // except for LL and LR on the bottom row with a bottom stitch.
    // In this case, they correspond to the swatch corners, and must be stepped
    // up if you want the regular grid.
    //  UL=[0][1]   UR=[1][1]
    //  LL=[0][0]   LR=[0][1]
    float *pSwatchCorner[NV_PATCH_NUMBER_OF_ATTRIBS][2][2]; // [v][u]

    // These are available storage for the corners of the regular grid on
    // the outside of all swatches.
    // Whereas, pSwatchCornerVertex and pSwatchCornerNormal will be
    // correct per sub-patch, these need only be fully valid
    // after all swatches are done
    // Here, the indices are "absolute" because the stitch code was written
    // to draw stitches on the Left, Right, Bot, Top, not relative to the
    // regular grid.
    float gridCorner[NV_PATCH_NUMBER_OF_ATTRIBS][2][2][4]; // [v][u][xyzw]
    int setGridCorner;  // mask indicating which gridCorner to assign

    // 'fracCorner' is for the additional corners created by the 
    // top and right frac stitches. Only used by SW. For HW, HW does it.
    // fracCorner[i][0][0] is the same as gridCorner[i][0][0]
    float fracCorner[NV_PATCH_NUMBER_OF_ATTRIBS][2][2][4]; // [v][u][xyzw]

    // SCRATCH SPACE
    // alloced once with the structure to prevent LOTS of malloc/free's later.
    // IMPORTANT! USE THE MACROs BEGIN/END_USING_TEMP_MATRIX() to help
    // catch cases where nested routines use the same temp
    NV_PATCH_CURVE_INFO tempCurve;
    FDMatrix tempMatrix;
    FDMatrix tempMatrix_m0;    
    FDMatrix tempMatrix_m1;
    FDMatrix tempMatrix_m2;
    FDMatrix reparam;                        // used for Tri INT and FRAC
    FDMatrix *reduceTri[NV_PATCH_MAX_ORDER]; // see ReparameterizeTriPatch()

    #define BEGIN_USING_TEMP_MATRIX(MATRIX)     \
        nvAssert(!(MATRIX).rows);               \
        nvAssert(!(MATRIX).columns);            \

    #define END_USING_TEMP_MATRIX(MATRIX)       \
        nvAssert(((MATRIX).rows = 0, 1));       \
        nvAssert(((MATRIX).columns = 0, 1));    \

    int bytesGuardCurve;        // bytes in truncated NV_PATCH_CURVE_INFO
    int bytesGuardCurveAllAttr; // bytes for one curve set (one curve for each active attribute)

    NV_PATCH_QUAD_INFO *quadInfo;   // alloc'd by callers

    // temp storage allocated in DrawIntPatch() and used by lower routines
    void *pScratchBase; // ptr to group of all scratch stuff for free

    // temp FD matrix for reg grid, small steps in V and U
    FDMatrix *ppMatrixSetSS0[NV_PATCH_NUMBER_OF_ATTRIBS];

    // temp* curves are for boundary curves in regular grid
    NV_PATCH_CURVE_INFO *tempVBegin[NV_PATCH_NUMBER_OF_ATTRIBS];
    NV_PATCH_CURVE_INFO *tempVEnd[NV_PATCH_NUMBER_OF_ATTRIBS];

    // guard sets. Now only for FRAC. Later for more.
    FDCurveAttrSet guardSetUInnerFrac;  // for non-swathing
    FDCurveAttrSet guardSetVInnerFrac;  // for non-swathing
    FDCurveAttrSet *ppGuardSetUInnerFrac1[1];   // for non-swathing
    FDCurveAttrSet *ppGuardSetVInnerFrac1[1];   // for non-swathing
    FDCurveAttrSet **ppGuardSetUInnerFrac;
    FDCurveAttrSet **ppGuardSetVInnerFrac;
} NV_PATCH_INFO;

/*****************************************************************************/
// forward declarations
int nvAllocInfoScratch(NV_PATCH_INFO *info);
int nvAllocFDMatricesEtc(NV_PATCH_INFO *info);
unsigned int nvEvalPatchSetup(NV_PATCH_INFO *info);
unsigned int nvEvalPatch(NV_PATCH_INFO *info);
unsigned int nvEvalPatchCleanup(NV_PATCH_INFO *info);

unsigned int DrawKelvinIntPatchGrid(NV_PATCH_INFO *info, NV_PATCH_QUAD_INFO *quadInfo, FDMatrix **matrices);
void SendGuardCurve(unsigned long curvetype, NV_PATCH_INFO *info, NV_PATCH_QUAD_INFO *quadInfo, unsigned long flags);
void ComputeKelvinHOSControlWords(NV_PATCH_INFO *info, NV_PATCH_QUAD_INFO *quadInfo, long flags);
void CopyCurve(NV_PATCH_INFO *info, NV_PATCH_CURVE_INFO *dst, NV_PATCH_CURVE_INFO *src);

void OffsetFDMatrix(NV_PATCH_INFO *info, FDMatrix *m, int a, int b);
void OffsetCurve(NV_PATCH_INFO *info, NV_PATCH_CURVE_INFO *curve, int n);
void ExtractUCurve(NV_PATCH_INFO *info, NV_PATCH_CURVE_INFO *dst, const FDMatrix *m);
void ExtractVCurve(NV_PATCH_INFO *info, NV_PATCH_CURVE_INFO *dst, const FDMatrix *m);
void RetessellateFDCurve(NV_PATCH_INFO *info, float stepOld, float stepNew,
                                NV_PATCH_CURVE_INFO *curve, int reversedirection);
void RetessellateFDMatrix(NV_PATCH_INFO *info, float stepOldU, float stepOldV,
                             float stepNewU, float stepNewV, FDMatrix *matrix);

int evAllocInitWithCache(NV_PATCH_INFO *info, void *context, 
                            NV_PATCH_ALLOC_CONTROL *pevMemory,
                            int tBytes, NV_PATCH_ALLOC_CACHE *pCache);

extern const int attrHwToSw[NV_PATCH_NUMBER_OF_ATTRIBS];
extern const int attrSwToHw[NV_PATCH_NUMBER_OF_ATTRIBS];

//#define HOS_DEBUG
#if !defined(IS_OPENGL)
    //d3d defs
    #define VIEW_AS_DWORD(f) (*(DWORD *)(&(f)))
    #define HOS_KELVIN_CHANNEL                  NV_DD_KELVIN

    #define HOS_CREATE_AND_ASSIGN_PUSHBUF_LOCALS() \
            extern int fakeFunc(int ii)         // make declaration instead of <null> so macro may be called with ";"

    #ifdef HOS_DEBUG                            //for debug builds output debug info rather than actual pushbuffer methods
        #define HOS_PUSH(index, method)         { getDC()->nvPusher.push(index, method); \
                                                  DPF_LEVEL(NVDBG_LEVEL_HOS_INFO,"HOS: 0x%08x", (method)); } 
  
        #define HOS_PUSHF(index, method)        { getDC()->nvPusher.push(index, method); \
                                                  DPF_LEVEL(NVDBG_LEVEL_HOS_INFO,"HOS: %f", (*(float *)(&(method)))); }   
    
        #define HOS_PUSH_ADJUST(num_dwords)     getDC()->nvPusher.adjust(num_dwords)
        #define HOS_NOTE(a)                     DPF_LEVEL(NVDBG_LEVEL_HOS_INFO,"HOS: %s",a)                    
        #define HOS_FLUSH()                     //getDC()->nvPusher.flush(TRUE,CPushBuffer::FLUSH_HEAVY_POLLING)       
    #else
        #define HOS_PUSH(index, method)         getDC()->nvPusher.push(index, method)
        #define HOS_PUSHF(index, method)        HOS_PUSH(index,method)      //remap to same push method.
        #define HOS_PUSH_ADJUST(num_dwords)     getDC()->nvPusher.adjust(num_dwords)
        #define HOS_NOTE(a)                     //DPF_LEVEL(NVDBG_LEVEL_HOS_INFO,"HOS: %s",a)
        #define HOS_FLUSH()                     //getDC()->nvPusher.flush(TRUE,CPushBuffer::FLUSH_HEAVY_POLLING)
    #endif

#else   // !defined(IS_OPENGL)
    //OGL defs
    #define VIEW_AS_DWORD(f) (*(NvU32 *)(&(f)))
    #define HOS_KELVIN_CHANNEL NV_SC_3D         // define kelvin channel for OGL
    #define MAX_CHECK_PUSH_WORDS    100

    static NV_INLINE int dbgPushCheckCount(int nWritten, int *count)
    {
        int ii;

        for (ii = 0;  ii < nWritten;  ii++) {
            if (ii >= MAX_CHECK_PUSH_WORDS) {
                break;
            }
            assert(count[ii] == 1);
        }
        for (ii = 0;  ii < MAX_CHECK_PUSH_WORDS;  ii++) {
            count[ii] = 0;
        }
        return 0;
    }

    #define HOS_CREATE_AND_ASSIGN_PUSHBUF_LOCALS() \
            NV_TRACE_CODE( \
                int dbgPushCount[MAX_CHECK_PUSH_WORDS]; \
                int dbgPushFoo = nvDebugLevel >= 2 ? \
                                    dbgPushCheckCount(0, dbgPushCount) : 0; \
                const int setupForMT = MT_PENDING; \
            ) \
            __GLNVcontext *hwcx = NV_GET_HWCX(info->context); \
            __GLNVstate *state = NV_GET_HWSTATE(info->context) \
            /* NV_CREATE_AND_ASSIGN_PUSHBUF_LOCALS() */ \

    #define HOS_PUSH(index, data) \
            /* nvCurrent[index].u = data; */ \
            hwcx->u.pushBuf.current[index].u = data; \
            NV_TRACE_CODE( \
                assert((index) >= 0); \
                if ((index) < MAX_CHECK_PUSH_WORDS) { \
                    dbgPushCount[index]++; \
                } \
            ); \

    #define HOS_PUSHF(index, data) HOS_PUSH(index,data)

    #define HOS_PUSH_ADJUST(num_dwords) { \
            NV_CREATE_AND_ASSIGN_PUSHBUF_LOCALS(); \
            NV_TRACE_CODE( \
                if (nvDebugLevel >= 2) { \
                    dbgPushCheckCount(num_dwords, dbgPushCount); \
                } \
            ); \
            nvCurrent += (num_dwords); \
            NV_SYNC_PUSHBUF_LOCALS(); \
            NV_GET_VARIABLE_SPACE_IF_NEEDED(128); \
            nvAssert(nvCurrent < hwcx->u.pushBuf.fence); \
        }

    #define HOS_NOTE(a)

    #define HOS_FLUSH() { \
            NV_CREATE_AND_ASSIGN_PUSHBUF_LOCALS(); \
            NV_GET_SKID_SPACE_IF_NEEDED(); \
            NV_FLUSH(state); \
        }

    extern int enableUniqueCheck;
    extern int nUniqueVertices;
    void drawUniqueVertices(void);
#endif  // else !defined(IS_OPENGL)

#define HOS_PUSH4F(index, method)       { HOS_PUSHF(index+0, VIEW_AS_DWORD(method[0])); \
                                          HOS_PUSHF(index+1, VIEW_AS_DWORD(method[1])); \
                                          HOS_PUSHF(index+2, VIEW_AS_DWORD(method[2])); \
                                          HOS_PUSHF(index+3, VIEW_AS_DWORD(method[3])); }


// Assembly inner loops storage, constants, and defines
extern int bFirstTimeInit;           //global value to indicate if we've built dynamic inner loops yet or not.
typedef void (FASTCALL *PFOFSTMED)(NV_PATCH_CURVE_INFO *dst, int dir, FDMatrix *m, int a, int b);
typedef void (FASTCALL *PFOFSTM)(FDMatrix *m, int a, int b);
typedef void (FASTCALL *PFOFSC)(NV_PATCH_CURVE_INFO *curve, int n);
typedef void (FASTCALL *PFMM)(FDMatrix *dst, FDMatrix *a, FDMatrix *b);

#define MAX_PATCH_INNERLOOPS          16
#define OFFSET_FDMATRIX_ED_2x2      0
#define OFFSET_FDMATRIX_ED_4x4      1
#define OFFSET_FDMATRIX_ED_6x6      2
#define OFFSET_FDMATRIX_ED_DEF      3
#define OFFSET_FDMATRIX_2x2         4
#define OFFSET_FDMATRIX_4x4         5
#define OFFSET_FDMATRIX_6x6         6
#define OFFSET_FDMATRIX_DEF         7
#define OFFSET_CURVE_2x2            8
#define OFFSET_CURVE_4x4            9
#define OFFSET_CURVE_6x6            10
#define OFFSET_CURVE_DEF            11
#define OFFSET_MATRIX_MULT_2x2      12
#define OFFSET_MATRIX_MULT_4x4      13
#define OFFSET_MATRIX_MULT_6x6      14
#define OFFSET_MATRIX_MULT_DEF      15

typedef struct {
    //ptrs for inner loops
    void *HOSInnerLoops[MAX_PATCH_INNERLOOPS];  //function mappings

    //small FDMatrix cache to get rid of extra 
    unsigned int RetessFDtag[2][2];           //tags for a retessellation matrix cache
    FDMatrix *RetessFDCache[2];               //ptrs for retessellation matrix cache
    int RetessFDMRU;                          //MRU bit for the above cache
    
    //EV_ALLOC data structures to minimize the number of malloc/frees in shared code
    NV_PATCH_ALLOC_CACHE pCache[MAX_EV_CACHE];
    
    //callback ptrs for HOS routines
    NV_PATCH_DRIVER_CALLBACKS *callbacks;
} NV_PATCH_STATIC_DATA;


//forward declarations for functions used elsewhere
void OffsetFDMatrix_Extract_Discard(NV_PATCH_INFO *info, NV_PATCH_CURVE_INFO *dst, int dir, FDMatrix *m, int a, int b);
void nvPatchDestroyFD();
void nvPatchInitFD(NV_PATCH_INFO *info);

typedef struct{    
    //semaphore data members
    long *FDSynchCounter;
    unsigned char *baseAllocation;
    unsigned char *alignedAllocation;
    unsigned long FDContextDMA;    
    unsigned long cpuType;
    int bForceSoftware;                  //indicates we failed to set up semaphore -- force a SW fallback
    int bFirstTimeInit;    
    //inner loop data members
    void *HOSInnerLoops[MAX_PATCH_INNERLOOPS];  //function mappings
    //retessellation cache members
    unsigned int RetessFDtag[2][2];           //tags for a retessellation matrix cache
    FDMatrix *RetessFDCache[2];               //ptrs for retessellation matrix cache
    int RetessFDMRU;                          //MRU bit for the above cache

} NV_PATCH_GLOBAL_DATA;
//this should match the intiialization of the above default structure
#define DEFAULT_PATCH_GLOBAL_DATA {NULL,NULL,NULL,0,0,0,1, {NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL, \
                                                            NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL}, \
                                   {{0xFFFFFFFF,0xFFFFFFFF},{0xFFFFFFFF,0xFFFFFFFF}}, \
                                   {NULL,NULL}, 0} \

extern NV_PATCH_ALLOC_CACHE MyCache[MAX_EV_CACHE];
extern NV_PATCH_GLOBAL_DATA g_FDGlobalData;
//#define DCR_SEMAPHORE
//extern NV_PATCH_MUTEX_DATA g_FDMutexData;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\common\inc\nvPM.h ===
/***************************************************************************\
|*                                                                           *|
|*       Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.      *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.  Users and possessors of this source code are     *|
|*     hereby granted a nonexclusive,  royalty-free copyright license to     *|
|*     use this code in individual and commercial software.                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*       Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.      *|
|*                                                                           *|
|*     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY     *|
|*     OF  THIS SOURCE  CODE  FOR ANY PURPOSE.  IT IS  PROVIDED  "AS IS"     *|
|*     WITHOUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPOR-     *|
|*     ATION DISCLAIMS ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,     *|
|*     INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY, NONINFRINGE-     *|
|*     MENT,  AND FITNESS  FOR A PARTICULAR PURPOSE.   IN NO EVENT SHALL     *|
|*     NVIDIA, CORPORATION  BE LIABLE FOR ANY SPECIAL,  INDIRECT,  INCI-     *|
|*     DENTAL, OR CONSEQUENTIAL DAMAGES,  OR ANY DAMAGES  WHATSOEVER RE-     *|
|*     SULTING FROM LOSS OF USE,  DATA OR PROFITS,  WHETHER IN AN ACTION     *|
|*     OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  ARISING OUT OF     *|
|*     OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOURCE CODE.     *|
|*                                                                           *|
|*     U.S. Government  End  Users.   This source code  is a "commercial     *|
|*     item,"  as that  term is  defined at  48 C.F.R. 2.101 (OCT 1995),     *|
|*     consisting  of "commercial  computer  software"  and  "commercial     *|
|*     computer  software  documentation,"  as such  terms  are  used in     *|
|*     48 C.F.R. 12.212 (SEPT 1995)  and is provided to the U.S. Govern-     *|
|*     ment only as  a commercial end item.   Consistent with  48 C.F.R.     *|
|*     12.212 and  48 C.F.R. 227.7202-1 through  227.7202-4 (JUNE 1995),     *|
|*     all U.S. Government End Users  acquire the source code  with only     *|
|*     those rights set forth herein.                                        *|
|*                                                                           *|
 \***************************************************************************/
#ifndef _nvPM_h
#define _nvPM_h

#ifdef __cplusplus
extern "C"
{
#endif

/*
 * constants
 */

// registry related
#define PM_REGISTRY_SUBKEY          "PerformanceMonitor"

#define PM_REG_LOGFILENAME          "logFileName"
#define PM_REG_CONNECTCOUNT         "connectCount"
#define PM_REG_PMTRIGGER            "trigger"
#define PM_REG_TRIGGERCOUNT         "triggerCount"
#define PM_REG_FLAGS                "flags"
#define PM_REG_PROGRAM_SETUP        "programSetup"
#define PM_REG_PROGRAM_START        "programStart"
#define PM_REG_PROGRAM_SAMPLE       "programSample"

#define PM_REG_PMTRIGGER_DISABLED   0                   // disabled
#define PM_REG_PMTRIGGER_ENDSCENE   1                   // emit trigger at end of frame
#define PM_REG_PMTRIGGER_1MS        2                   // emit trigger at 1ms intervals (not exact)
#define PM_REG_PMTRIGGER_RESV00     3
#define PM_REG_PMTRIGGER_CUSTOM0    4
#define PM_REG_PMTRIGGER_CUSTOM1    5
#define PM_REG_PMTRIGGER_CUSTOM2    6
#define PM_REG_PMTRIGGER_CUSTOM3    7
#define PM_REG_PMTRIGGER_MAX        7

#define PM_LOG_ID                   "events \0"
#define PM_PGM_ID                   "program\0"

#define PM_LOG_VERSION              0x00000001
#define PM_PGM_VERSION              0x00000001

#define PM_PGM_MASK_SIZE            0x0000000f
#define PM_PGM_VAL_SIZE_8               0x00000000
#define PM_PGM_VAL_SIZE_16              0x00000001
#define PM_PGM_VAL_SIZE_32              0x00000002
#define PM_PGM_VAL_SIZE_40              0x00000003
#define PM_PGM_FLAG_READ            0x80000000

#define PM_LOG_EVENT_BUFFER_SIZE    (65536 / 8)

// flags bits
#define PM_FLAGS_NO_WAIT 0x1
#define PM_FLAGS_NO_RESET 0x2
#define PM_FLAGS_IN_QUAKE3 0x4

/*
 * macros
 */
#define PM_SIGNAL(match)            if (g_dwPMTrigger == (match)) { if (!(--g_dwPMTriggerValue)) { pmSignal(); g_dwPMTriggerValue = g_dwPMTriggerCount; } }

/*
 * structures
 */
#pragma pack(push,1)

//////
// log event
typedef struct
{
    DWORD dwValueLo;
    DWORD dwValueHi;
} PM_LOG_EVENT;

// log header
typedef struct
{
    char         szID[8];
    DWORD        dwVersion;
    PM_LOG_EVENT Event[1];
} PM_LOG_HEADER;

//////
// program entry
typedef struct
{
    DWORD dwFlags;
    DWORD dwOffset;
    DWORD dwValueLo;
    DWORD dwValueHi;
} PM_PGM_ENTRY;

// program header
typedef struct
{
    char         szID[8];
    DWORD        dwVersion;
    DWORD        dwEntryCount;
    PM_PGM_ENTRY Entry[1];
} PM_PGM_HEADER;

#pragma pack(pop)

/*
 * exported globals
 */
extern DWORD g_dwPMTrigger;
extern DWORD g_dwPMTriggerCount;
extern DWORD g_dwPMTriggerValue;

/*
 * public functions
 */
#if defined(IS_OPENGL)
BOOL pmConnect    (HDC hEscapeDC,DWORD dwHWLinearBase,DWORD dwArch);    // arch: nv4 -> 0x04, nv10 -> 0x10
#else
BOOL pmConnect    (DWORD dwHeadNumber,DWORD dwHWLinearBase,DWORD dwArch);    // arch: nv4 -> 0x04, nv10 -> 0x10
#endif
BOOL pmDisconnect (void);
BOOL pmSignal     (void);

#ifdef __cplusplus
}
#endif

#endif // _nvPM_h
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\common\inc\nvPusher.h ===
// **************************************************************************
//
//       Copyright 1993-2000 NVIDIA, Corporation.  All rights reserved.
//
//     NOTICE TO USER:   The source code  is copyrighted under  U.S. and
//     international laws.  Users and possessors of this source code are
//     hereby granted a nonexclusive,  royalty-free copyright license to
//     use this code in individual and commercial software.
//
//     Any use of this source code must include,  in the user documenta-
//     tion and  internal comments to the code,  notices to the end user
//     as follows:
//
//     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY
//     OF  THIS SOURCE  CODE  FOR ANY PURPOSE.  IT IS  PROVIDED  "AS IS"
//     WITHOUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPOR-
//     ATION DISCLAIMS ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,
//     INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY, NONINFRINGE-
//     MENT,  AND FITNESS  FOR A PARTICULAR PURPOSE.   IN NO EVENT SHALL
//     NVIDIA, CORPORATION  BE LIABLE FOR ANY SPECIAL,  INDIRECT,  INCI-
//     DENTAL, OR CONSEQUENTIAL DAMAGES,  OR ANY DAMAGES  WHATSOEVER RE-
//     SULTING FROM LOSS OF USE,  DATA OR PROFITS,  WHETHER IN AN ACTION
//     OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  ARISING OUT OF
//     OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOURCE CODE.
//
//     U.S. Government  End  Users.   This source code  is a "commercial
//     item,"  as that  term is  defined at  48 C.F.R. 2.101 (OCT 1995),
//     consisting  of "commercial  computer  software"  and  "commercial
//     computer  software  documentation,"  as such  terms  are  used in
//     48 C.F.R. 12.212 (SEPT 1995)  and is provided to the U.S. Govern-
//     ment only as  a commercial end item.   Consistent with  48 C.F.R.
//     12.212 and  48 C.F.R. 227.7202-1 through  227.7202-4 (JUNE 1995),
//     all U.S. Government End Users  acquire the source code  with only
//     those rights set forth herein.
//
// **************************************************************************
//
//  Module: nvPusher.h
//      routines for creating, destroying, and interacting with a push buffer
//
// **************************************************************************
//
//  History:
//      Ben DeWaal              07Apr1999         original code
//      Craig Duttweiler        05Apr2000         cleanup, consolidation,
//                                                and C++'ification
//
// **************************************************************************

#ifndef _NVPUSHER_H
#define _NVPUSHER_H

#include "CompileControl.h"
#include "nvUniversal.h"
#include "nv32.h"
#include "nvDbg.h"

#if IS_WINNT4
typedef PDD_DIRECTDRAW_GLOBAL           LPDDRAWI_DIRECTDRAW_GBL;
#endif

typedef struct _PDEV PDEV;

#if (NVARCH < 0x04)

typedef void *CPushBuffer;   // Not avail on NV3, but let's compile go through easier

#else // (NVARCH >= 0x04)

//---------------------------------------------------------------------------

// pusher debugging switches (available in retail builds too)

//#define _PC_PRINTPUT                      // print kick-offs (slow)
//#define _PC_PRINT                         // print important pusher transactions
//#define _PC_CHECK                         // check for push buffer problems
//#define _PC_BREAK                         // break at specific class (define CHECK also)
//#define _PC_FLUSH_ON_ADJUST               // force flush on every call to nvPusherAdjust
//#define _PC_CAPTURE_METHOD_DATA           // captures method data and allows you to view it (good to check object state)
//#define _PC_CAPTURE                       // writes contents of the the push buffer to a file

// debug switch logic

// for now we enable push buffer validation for all debug builds
#if defined(DEBUG) || defined(_PC_CAPTURE_METHOD_DATA) || defined(_PC_CAPTURE)
#define _PC_CHECK
#endif

// don't allow inline functions if we have certain other debug bits enabled
#undef _NO_INLINE
#if defined(DEBUG) || defined(_PC_PRINTPUT) || defined(_PC_PRINT) || defined(_PC_CHECK) || defined(_PC_BREAK)
#define _NO_INLINE
#endif
#if defined(_PC_FLUSH_ON_ADJUST) || defined(_PC_CAPTURE_METHOD_DATA) || defined(_PC_CAPTURE)
#define _NO_INLINE
#endif

//---------------------------------------------------------------------------

// pusher constants and macros

#define NVPUSHER_MAX_METHOD_COUNT   (2048 - 1)  // maximum method count = 2 ^ 11 - 1
#define NVPUSHER_THRESHOLD_SIZE     128         // words of data always available (4 triangles)
#define NVPUSHER_MINIMUM            1024        // bytes of data for option kick-off

#define NVPUSHER_JUMP(offset)       (0x20000000 | (offset))
#define NVPUSHER_NOINC(method)      (0x40000000 | (method))
#define NVPUSHER_CALL(offset)       (0x00000002 | (offset))
#define NVPUSHER_RETURN()           (0x00020000)

//---------------------------------------------------------------------------

#ifdef _PC_CAPTURE

extern HANDLE hPusherFileBinary;
extern HANDLE hPusherFileAscii;
extern BOOL   bPusherCapture;

#define NV_PC_CAPTURE_BEGIN(filename)                                               \
{                                                                                   \
    char fullname[64];                                                              \
    nvSprintf (fullname, "%s.bin", filename);                                       \
    hPusherFileBinary = CreateFile (fullname,GENERIC_WRITE,0,0,OPEN_ALWAYS,0,0);    \
    if (hPusherFileBinary == INVALID_HANDLE_VALUE) {                                \
        DPF ("NV_PC_CAPTURE_BEGIN: Binary file open failed");                       \
        nvAssert(0);                                                                  \
    }                                                                               \
    SetFilePointer (hPusherFileBinary, 0,0, FILE_END);                              \
    nvSprintf (fullname, "%s.txt", filename);                                       \
    hPusherFileAscii = CreateFile (fullname,GENERIC_WRITE,0,0,OPEN_ALWAYS,0,0);     \
    if (hPusherFileAscii == INVALID_HANDLE_VALUE) {                                 \
        DPF ("NV_PC_CAPTURE_BEGIN: Ascii file open failed");                        \
        nvAssert(0);                                                                  \
    }                                                                               \
    SetFilePointer (hPusherFileAscii, 0,0, FILE_END);                               \
    bPusherCapture = TRUE;                                                          \
}

#define NV_PC_CAPTURE_END                                                           \
{                                                                                   \
    if (bPusherCapture) {                                                           \
        getDC()->nvPusher.flush (TRUE, CPushBuffer::FLUSH_WITH_DELAY);              \
        FlushFileBuffers (hPusherFileBinary);                                       \
        FlushFileBuffers(hPusherFileAscii);                                         \
        CloseHandle (hPusherFileBinary);                                            \
        CloseHandle (hPusherFileAscii);                                             \
        bPusherCapture = FALSE;                                                     \
    }                                                                               \
}

#endif

//---------------------------------------------------------------------------

// pusher aliases
// alias these to point to appropriate data for your particular implementation

// hw get
#ifndef _pdwHWGet
#define _pdwHWGet       ((volatile DWORD)(((Nv4ControlDma*)m_dwControlDMA)->Get))
#endif

// hw put
#ifndef _pdwHWPut
#define _pdwHWPut       ((volatile DWORD)(((Nv4ControlDma*)m_dwControlDMA)->Put))
#endif

// hw reference count
#ifndef _pdwHWRef
#define _pdwHWRef       ((volatile DWORD)(((Nv10ControlDma*)m_dwControlDMA)->Reference))
#endif

// true when HW is busy
#ifndef _pbHWBusy
#define _pbHWBusy       (*(volatile DWORD *)(pDriverData->NvBaseFlat + 0x400700))
#endif

// cache1 ownership: bits 0:4 give the channel that currently owns the cache
#ifndef _ffCache1Push1
#define _ffCache1Push1  (*(volatile DWORD *)(pDriverData->NvBaseFlat + 0x003204))
#endif

// cache1 status: bit 4 is set when the cache is empty
#ifndef _ffCache1Status
#define _ffCache1Status (*(volatile DWORD *)(pDriverData->NvBaseFlat + 0x003214))
#endif

// true if we have KNI support
#ifndef _hasKNI
#define _hasKNI         (pDriverData->nvD3DPerfData.dwCPUFeatureSet & FS_KATMAI)
#endif

// true if we have 3DNOW support
#ifndef _has3DNOW
#define _has3DNOW       (pDriverData->nvD3DPerfData.dwCPUFeatureSet & FS_3DNOW)
#endif

// true if we have SFENCE support
#ifndef _hasSFENCE
#define _hasSFENCE      (pDriverData->nvD3DPerfData.dwCPUFeatureSet & FS_SFENCE)
#endif

// Defines which classes are present on the chip and other system information
#ifndef _systemInfo
#define _systemInfo (pDriverData->nvD3DPerfData)
#endif

#ifndef _dmaPusherChannelIndex
#define _dmaPusherChannelIndex (pDriverData->dwDDDmaPusherChannelIndex)
#endif

#ifndef _dwRootHandle
#define _dwRootHandle (pDriverData->dwRootHandle)
#endif

#ifndef _nvBaseFlat
#define _nvBaseFlat ((volatile DWORD*)pDriverData->NvBaseFlat)
#endif

#ifndef _pCurrentChannelID
#define _pCurrentChannelID ((DWORD*)(pDriverData->pCurrentChannelID))
#endif

#ifndef _pDriverData
#define _pDriverData (pDriverData)
#endif

#ifndef _hDevice
#define _hDevice (NV_WIN_DEVICE)
#endif


//---------------------------------------------------------------------------

// pusher-related macros

// the if is to allow for a string of Function such as Flip(A->B), Clear(A), Blit(C), such that the Blit to C
// does not destroy the pending waitforflip on Clear(A).  We only wait on surfaces that are just becoming a
// target and not an arbitrary surface
#define nvPusherSignalWaitForFlip(fpVidMem, dwDDSFlags)          \
{                                                                \
    if (getDC()->flipPrimaryRecord.fpFlipFrom == (fpVidMem)) {   \
        getDC()->nvPusher.setSyncFlipFlag();                     \
        getDC()->nvPusher.setFlipSurface(fpVidMem);              \
        getDC()->nvPusher.setFlipSurfaceFlags(dwDDSFlags);       \
    }                                                            \
}

// i'd really rather see these eventually just be substituted, but i'll make that mess later
#define nvPushData(a,b)    getDC()->nvPusher.push(a,b)
#define nvPusherAdjust(a)  getDC()->nvPusher.adjust(a)
#define nvPusherStart(a)   getDC()->nvPusher.start(a)
#define nvPusherFlush(a)   getDC()->nvPusher.flush(a,0)     // 0 = FLUSH_WITH_DELAY

//---------------------------------------------------------------------------

struct _CPushBuffer
{
    // members
    DWORD m_dwChannel;          // handle for channel used by this push buffer
    DWORD m_dwContextDMA;       // handle for context DMA
    DWORD m_dwContextDMASize;   // size of context dma allocated for this push buffer
    DWORD m_dwControlDMA;       // controlDMA structure for this channel
    DWORD m_dwPCIHeapHandle;    // pci heap handle (if any)
    DWORD m_dwPCIHeapBase;      // pci heap base (if any)
    DWORD m_dwHeap;             // heap from which push buffer is allocated
    // bank
    DWORD m_dwBase;             // base of push buffer
    DWORD m_dwSize;             // size of push buffer
    DWORD m_dwPut;              // current put pointer
    DWORD m_dwPutLast;          // last put wrote to HW
    DWORD m_dwGet;              // cached get pointer
    DWORD m_dwThreshold;        // threshold value
    DWORD m_dwWrapCount;        // # of wrap arounds
#if (IS_WIN9X || IS_WINNT5)
    DWORD m_dwPad01[1];
#elif IS_WINNT4
    PDEV *m_ppdev;     // On NT4 systems when there is no D3D, this pointer is used to get to a valid context
#endif
    // bank
    DWORD m_dwFlipSurfaceAddr;  // what surface to wait on during getFrameStatus
    DWORD m_dwFlipSurfaceFlags; // DDS caps flags, identifying the type of surface
    DWORD m_dwFlags;            // pusher flags
    DWORD m_dwPad02[5];
};

#ifdef __cplusplus

// forward definitions

struct  _def_nv_d3d_context;
typedef _def_nv_d3d_context *PNVD3DCONTEXT;


//---------------------------------------------------------------------------


class CPushBuffer : public _CPushBuffer
{
private:

    // pusher flags
    const enum {
        PB_FLAG_VALID          = (1 << ( 0)),  // push buffer is allocated, context DMA is allocated, and channel is open
        PB_FLAG_CHANNEL_SYNC   = (1 << ( 1)),  // signal to sync other channels b4 put
        PB_FLAG_FLIP_SYNC      = (1 << ( 2))   // will wait for flip before writing put
    };

public:

    // flush modes
    const enum {
        FLUSH_WITH_DELAY       = 0,            // flush with a delays when polling    (detrimental to CPU performance)
        FLUSH_HEAVY_POLLING    = 1             // flush & poll hw as fast as possible (detrimental to HW performance)
    };

public:

#if (IS_WINNT4)
    inline void  setPdev              (PDEV *ppdev)            {   m_ppdev =  ppdev;  }
#endif

    inline DWORD getChannel           (void)            {   return (m_dwChannel);      }
    inline DWORD getContextDMA        (void)            {   return (m_dwContextDMA);   }

    inline DWORD getHeap              (void)            {   return (m_dwHeap);   }
    inline DWORD getBase              (void)            {   return (m_dwBase);   }
    inline DWORD getSize              (void)            {   return (m_dwSize);   }

    inline void  setPut               (DWORD dwPut)     {   m_dwPut = dwPut;    }
    inline DWORD getPut               (void)            {   return (m_dwPut);   }

    inline DWORD getThreshold         (void)            {   return (m_dwThreshold);   }
    inline DWORD getWrapCount         (void)            {   return (m_dwWrapCount);   }
    inline DWORD getRefCount          (void)            {   return (_pdwHWRef);       }

    inline void  setSyncFlipFlag      (void)            {   m_dwFlags |=  PB_FLAG_FLIP_SYNC;    }
    inline void  clearSyncFlipFlag    (void)            {   m_dwFlags &= ~PB_FLAG_FLIP_SYNC;    }
    inline void  setSyncChannelFlag   (void)            {   m_dwFlags |=  PB_FLAG_CHANNEL_SYNC; }
    inline void  clearSyncChannelFlag (void)            {   m_dwFlags &= ~PB_FLAG_CHANNEL_SYNC; }

    inline void  setFlipSurface       (DWORD dwAddr)    {   m_dwFlipSurfaceAddr = dwAddr;   }
    inline void  setFlipSurfaceFlags  (DWORD dwFlags)   {   m_dwFlipSurfaceFlags = dwFlags;   }

    inline BOOL  isValid              (void)            {   return ((m_dwFlags & PB_FLAG_VALID) ? TRUE : FALSE);   }
    inline void  invalidate           (void)            {   m_dwFlags &= ~PB_FLAG_VALID;   }

    // prototypes for functions in nvPusher.cpp

           BOOL  allocate             (DWORD dwChannel);
           BOOL  free                 (void);

           void  start                (BOOL bRequired);                     // kick off
           void  flush                (BOOL bWaitForHWIdle, DWORD dwMode);  // kick off & wait for idle
           void  resetPut             (void);                               // set put to base & read get
           BOOL  isIdle               (BOOL bCheckHWAlso);                  // check if idle
           void  waitForOtherChannels (void);                               // idle other channels
           void  makeSpace            (DWORD dwCount);                      // makes space for large transfers (use inc instead of adjust)

    #ifdef _NO_INLINE

           void  push                 (DWORD dwOffset, DWORD dwData);
           BOOL  adjust               (DWORD dwCount);
           void  inc                  (DWORD dwCount);

    #else  // !_NO_INLINE

    FORCE_INLINE void  push           (DWORD dwOffset, DWORD dwData)
                {
                    ((DWORD*)m_dwPut)[dwOffset] = dwData;
                };

    FORCE_INLINE BOOL  adjust         (DWORD dwCount)
                {   m_dwPut += ((dwCount) << 2);
                    if (m_dwPut >= m_dwThreshold) {
                        return getSpace();
                    }
                    return FALSE;
                }
    FORCE_INLINE void  inc            (DWORD dwCount)
                {
                    m_dwPut += ((dwCount) << 2);
                }

    #endif  // !_NO_INLINE

    inline void setObject(NvU32 subChannel,NvU32 objId)
    {
        nvAssert((subChannel >= 0) && (subChannel<=7));
        nvAssert(objId != 0);
        push(0, (subChannel << 13) | 0x40000);
        push(1, objId);
        adjust(2);
    }
private:

    // prototypes for functions in nvPusher.cpp

    inline void    setChannel         (DWORD dwChannel)                 {   m_dwChannel    = dwChannel;
                                                                            m_dwContextDMA = dwChannel+1;   }

           void    setBase            (DWORD dwBase);   // set buffer base
           void    setSize            (DWORD dwSize);   // set buffer size

           BOOL    allocateMemory     (void);
           BOOL    freeMemory         (void);
           BOOL    allocateContextDMA (void);
           BOOL    freeContextDMA     (void);
           BOOL    openChannel        (void);
           BOOL    closeChannel       (void);

           FLATPTR getfpVidMem        (void);           // FLATPTR of pusher base

    inline void    syncAndFlushWC     (void);
           void    kickOff            (void);

           BOOL    getSpace           (void);
           BOOL    calcThreshold      (void);           // read get
           void    wrapAround         (void);

    #ifdef _PC_CHECK
           BOOL    validate           (DWORD dwStart, DWORD dwEnd);
    #endif
    #ifdef _PC_CAPTURE_METHOD_DATA
           DWORD   parseMethod        (DWORD dwAddress);
           void    captureState       (DWORD dwSubChannel);
    #endif

public:

    // creation and destruction

    inline         CPushBuffer        (void)            {   memset (this, 0, sizeof(*this));  }
    inline        ~CPushBuffer        (void)            {}

    // friends

    friend void    nvCelsiusILCompile_beginEnd        (DWORD dwPrimType);
    friend DWORD   nvCelsiusILCompile_inline_prim     (PNVD3DCONTEXT pContext, DWORD dwFlags);
    friend DWORD   nvCelsiusILCompile_inline_tri_list (PNVD3DCONTEXT pContext, DWORD dwFlags);
    friend DWORD   nvCelsiusILCompile_super_tri_list  (PNVD3DCONTEXT pContext, DWORD dwFlags);
    friend DWORD   nvCelsiusILCompile_vb_prim         (PNVD3DCONTEXT pContext, DWORD dwFlags);

    //friend void    nvKelvinILCompile_beginEnd         (DWORD dwPrimType);
    friend DWORD   nvKelvinILCompile_inline_prim      (PNVD3DCONTEXT pContext, DWORD dwFlags);
    //friend DWORD   nvKelvinILCompile_inline_tri_list  (PNVD3DCONTEXT pContext, DWORD dwFlags);
    //friend DWORD   nvKelvinILCompile_super_tri_list   (PNVD3DCONTEXT pContext, DWORD dwFlags);
    friend DWORD   nvKelvinILCompile_vb_prim          (PNVD3DCONTEXT pContext, DWORD dwFlags);

};

#else  // !cplusplus

typedef struct _CPushBuffer CPushBuffer;

#endif  // !cplusplus

#endif  // (NVARCH >= 0x04)

#endif  //!_NVPUSHER_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\common\inc\nvprocman.h ===
/***************************************************************************\
|*                                                                           *|
|*       Copyright 1993-2000 NVIDIA, Corporation.  All rights reserved.      *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.  Users and possessors of this source code are     *|
|*     hereby granted a nonexclusive,  royalty-free copyright license to     *|
|*     use this code in individual and commercial software.                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY     *|
|*     OF  THIS SOURCE  CODE  FOR ANY PURPOSE.  IT IS  PROVIDED  "AS IS"     *|
|*     WITHOUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPOR-     *|
|*     ATION DISCLAIMS ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,     *|
|*     INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY, NONINFRINGE-     *|
|*     MENT,  AND FITNESS  FOR A PARTICULAR PURPOSE.   IN NO EVENT SHALL     *|
|*     NVIDIA, CORPORATION  BE LIABLE FOR ANY SPECIAL,  INDIRECT,  INCI-     *|
|*     DENTAL, OR CONSEQUENTIAL DAMAGES,  OR ANY DAMAGES  WHATSOEVER RE-     *|
|*     SULTING FROM LOSS OF USE,  DATA OR PROFITS,  WHETHER IN AN ACTION     *|
|*     OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  ARISING OUT OF     *|
|*     OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOURCE CODE.     *|
|*                                                                           *|
|*     U.S. Government  End  Users.   This source code  is a "commercial     *|
|*     item,"  as that  term is  defined at  48 C.F.R. 2.101 (OCT 1995),     *|
|*     consisting  of "commercial  computer  software"  and  "commercial     *|
|*     computer  software  documentation,"  as such  terms  are  used in     *|
|*     48 C.F.R. 12.212 (SEPT 1995)  and is provided to the U.S. Govern-     *|
|*     ment only as  a commercial end item.   Consistent with  48 C.F.R.     *|
|*     12.212 and  48 C.F.R. 227.7202-1 through  227.7202-4 (JUNE 1995),     *|
|*     all U.S. Government End Users  acquire the source code  with only     *|
|*     those rights set forth herein.                                        *|
|*                                                                           *|
 \***************************************************************************/

#ifndef __NVPROCMAN_H_
#define __NVPROCMAN_H_

#include "CompileControl.h"

#ifndef NV3
#if IS_WINNT5
#include <dx95type.h>
#include "nvntd3d.h"
#endif

#ifndef NVQTWKVER // include DDKMMINI.H only if control panel not being built
#if !IS_WINNT4
#include "ddkmmini.h"
#endif
#endif // ifndef NVQTWKVER
#endif // NV3

#define EVENTNAME_IDLE                  "NV_Idle"
#define EVENTNAME_OVL_FLIP_EVEN         "NV_OvlFlipEven"
#define EVENTNAME_OVL_FLIP_ODD          "NV_OvlFlipOdd"
#define EVENTNAME_DMA_TO_VID            "NV_DMAToVid"
#define EVENTNAME_CONVERT               "NV_Convert"
#define EVENTNAME_SUBPICTURE            "NV_SubPicture"
#define EVENTNAME_PRESCALE              "NV_PreScale"
#define EVENTNAME_COLOURCONTROL         "NV_ColourControl"
#define EVENTNAME_TFILTER               "NV_TFilter"
#define EVENTNAME_DFILTER               "NV_DFilter"
#define EVENTNAME_DISPATCH_GO           "NV_DispatchGo"
#define EVENTNAME_DISPATCH_DONE         "NV_DispatchDone"
#define EVENTNAME_FSMIRROR              "NV_FSMirror"
#define EVENTNAME_FOURCCBLT             "NV_FourCCBlt"
#define EVENTNAME_PRIMARY0_FLIP_EVEN    "NV_Primary0FlipEven"
#define EVENTNAME_PRIMARY0_FLIP_ODD     "NV_Primary0FlipOdd"
#define EVENTNAME_PRIMARY1_FLIP_EVEN    "NV_Primary1FlipEven"
#define EVENTNAME_PRIMARY1_FLIP_ODD     "NV_Primary1FlipOdd"
#define EVENTNAME_TIMER                 "NV_Timer"
#define EVENTNAME_DXEXCLUSIVEMODE       "NV_DXExclusiveMode"

#if IS_WINNT5

#define CREATE_EVENT(pHandle) EngCreateEvent(pHandle)
#define DELETE_EVENT(handle) EngDeleteEvent(handle)
#define HDRVEVENT PEVENT
#define EVENT_ERROR

#elif IS_WINNT4

// TBD - mlavoie: resolve issues with events on NT4

// VERY unsure as to whether the ddraw portion of the display can call these.
//   the miniport can so we may need to find another way -mlavoie
// Also very unsure as to whether these 2 funcs correspond to create & delete
#define CREATE_EVENT(pHandle) KeInitializeEvent(pHandle,NotificationEvent,FALSE)
#define DELETE_EVENT(handle) KeResetEvent(&(handle))
//KeWaitForSingleObject
#define HDRVEVENT NvU32
#define EVENT_ERROR

#elif IS_WIN9X

#define HDRVEVENT HANDLE
#define EVENT_ERROR {   \
    pmDeleteProcess(lpProcInfo->dwProcessID);   \
    pmAddProcess(pDriverData, GetCurrentProcessId());        }

#else
#error Unhandled OS.
#endif

// process manager structure
typedef struct tagProcessInfo {
    unsigned long dwProcessID;
    HDRVEVENT     hIdleSyncEvent0;
    HDRVEVENT     hIdleSyncEvent3;
    HDRVEVENT     hOvlFlipEvenEvent0;
    HDRVEVENT     hOvlFlipEvenEvent3;
    HDRVEVENT     hOvlFlipOddEvent0;
    HDRVEVENT     hOvlFlipOddEvent3;
    HDRVEVENT     hDMABlitToVid0;
    HDRVEVENT     hDMABlitToVid3;
    HDRVEVENT     hConvert0;
    HDRVEVENT     hConvert3;
    HDRVEVENT     hSubPicture0;
    HDRVEVENT     hSubPicture3;
    HDRVEVENT     hColourControl0;
    HDRVEVENT     hColourControl3;
    HDRVEVENT     hTFilter0;
    HDRVEVENT     hTFilter3;
    HDRVEVENT     hDFilter0;
    HDRVEVENT     hDFilter3;
    HDRVEVENT     hFSMirror0;
    HDRVEVENT     hFSMirror3;
    HDRVEVENT     hFourCCBlt0;
    HDRVEVENT     hFourCCBlt3;
    HDRVEVENT     hPrimary0FlipEven0;
    HDRVEVENT     hPrimary0FlipEven3;
    HDRVEVENT     hPrimary0FlipOdd0;
    HDRVEVENT     hPrimary0FlipOdd3;
    HDRVEVENT     hPrimary1FlipEven0;
    HDRVEVENT     hPrimary1FlipEven3;
    HDRVEVENT     hPrimary1FlipOdd0;
    HDRVEVENT     hPrimary1FlipOdd3;
    HDRVEVENT     hTimer0;
    HDRVEVENT     hTimer3;
    struct tagProcessInfo *lpNext;
} PROCESSINFO, *LPPROCESSINFO;

#ifdef __cplusplus
extern "C" {
#endif

// public
#ifndef WINNT
HANDLE        ConvertRing3EventToRing0 (HDRVEVENT hEventRing3);
BOOL          CloseRing0Handle         (HDRVEVENT hEventRing0);
#endif // WINNT
typedef struct _GLOBALDATA GLOBALDATA;
LPPROCESSINFO pmGetProcess             (GLOBALDATA *pDriverData, DWORD processID);
BOOL          pmAddProcess             (GLOBALDATA *pDriverData, DWORD processID);
BOOL          pmDeleteProcess          (DWORD processID);
void          pmDeleteAllProcesses     (GLOBALDATA *pDriverData);

HRESULT NvResetEvent(HDRVEVENT hEvent);
HRESULT NvSetEvent(HDRVEVENT hEvent);
HRESULT NvWaitEvent(HDRVEVENT hEvent, DWORD timeout);

#ifdef __cplusplus
}
#endif // __cplusplus

#endif // __NVPROCMAN_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\common\inc\nvPriv.h ===
#ifndef _NVPRIV_H_
#define _NVPRIV_H_

#include "CompileControl.h"
#include "nvUtil.h"

/*==========================================================================;
 *
 *  Copyright (C) 1995, 1999 NVidia Corporation. All Rights Reserved.
 *
 *  File:       nvPriv.h
 *  Content:    header for nvPriv.cpp
 *
 ***************************************************************************/

typedef struct _MYDCICMD
{
	ULONG	dwCommand;
	ULONG	dwParam1;
	ULONG 	dwParam2;
	ULONG	dwVersion;
	ULONG	dwReserved;
} MYDCICMD;

typedef struct _MYDD32BITDRIVERDATA
{
    UCHAR   szName[260];            // 32-bit driver name
    UCHAR   szEntryPoint[64];       // entry point
    ULONG   dwContext;              // context to pass to entry point
} MYDD32BITDRIVERDATA;

#define DD_VERSION              0x00000200l
#define DDCREATEDRIVEROBJECT    10
#define DDGET32BITDRIVERNAME    11
#define DDNEWCALLBACKFNS        12
#define DDVERSIONINFO           13
#define DDDESTROYDRIVEROBJECT   99

// The nvPriv functions provide a private API within the nVidia driver.
// Since they are called outside the context of an OS API (ie the DirectDraw HAL)
// we need a way to identify the appropriate global data structures.  This array of 
// ptrs must be updated as devices are added or removed.
//
// stores a list of display adapters with the global data structures associated with each
//
#define MAX_ADAPTERS            9

typedef struct tagDISPDRVDIRECTXCOMMON DISPDRVDIRECTXCOMMON;
typedef struct _GLOBALDATA GLOBALDATA;

typedef struct
{
#if IS_WIN9X
    DISPDRVDIRECTXCOMMON *pDXShare;
    GLOBALDATA       *pDriverData;
#elif IS_WINNT5
    GLOBALDATA       *pDriverData;
#elif IS_WINNT4
    GLOBALDATA           *pDriverData;
#endif
} NV_ADAPTER_TYPE;

EXTERN_C NV_ADAPTER_TYPE g_adapterData[MAX_ADAPTERS];	// Declared in nvPriv.cpp


#ifdef WINNT
#ifndef NV_ESC_DDPRIV_DMABLIT
// lpIn = pointer to input structure to nvMoComp
// lpOut = pointer to a DWORD return code
#define NV_ESC_DDPRIV_DMABLIT               0x6E88
#endif

#ifndef NV_ESC_DDPRIV_OVERLAYCONTROL
// lpIn = pointer to input structure to nvOverlayControl
// lpOut = pointer to a DWORD return code
#define NV_ESC_DDPRIV_OVERLAYCONTROL        0x6E89
#endif
#endif // WINNT

// --------------------------------------------------------------------------
// nvOverlayControl
//      Overlay control callback
//
// Command Structure
// -----------------
// NVOCCMD_IDENTIFY
//      dwSize
//      dwDevice
//      caps.dwCaps1
//          NVOCID1_INTERVIDEO
//          NVOCID1_MEDIAMATICS
//          NVOCID1_RAVISENT
//          NVOCID1_CYBERLINK
//          NVOCID1_NEC
//          NVOCID1_MGI
//          NVOCID1_CANOPUS
//          NVOCID1_AVID
//          NVOCID1_REAL
//          NVOCID1_MADONION
//          NVOCID1_MICROSOFT
//      caps.dwCaps2
//          NVOCID2_OS_SCHEDULED
//              Set this cap if your decoder uses OS scheduling, i.e. multithreaded
//              Do not set if your decoder is self scheduled, i.e. multifibre
//          NVOCID2_CAN_HANDLE_60HZ
//              Set this cap if your decoder can handle 60 fps content on 60 Hz resolutions
//          NVOCID2_PIPELINED
//              Set this cap if your decoder is pipelined.  If you do not know, do not set this
//          NVOCID2_NEED_OVERLAY
//              Set this cap if your decoder cannot use FOURCC blits if overlay is absent
//          NVOCID2_SINGLE_MONITOR
//              Set this cap if your decoder is not multimon capable
// NVOCCMD_GETCAPS
//      dwSize
//      dwDevice
//      returns caps
//          dwCaps1
//              NVOCCAPS1_BRIGHTNESS
//              NVOCCAPS1_CONTRAST
//              NVOCCAPS1_HUE
//              NVOCCAPS1_SATURATION
//              NVOCCAPS1_SHARPNESS
//              NVOCCAPS1_GAMMA
//          dwCaps2
//              NVOCCAPS2_HQVUPSCALE
//              NVOCCAPS2_TFILTER
//              NVOCCAPS2_DFILTER
//              NVOCCAPS2_FSMIRROR
//              NVOCCAPS2_OVLZOOM
//          dwCaps3
//              NVOCCAPS3_SUBPICTURE
//              NVOCCAPS3_LATEFLIPSYNC
//              NVOCCAPS3_SPLITVPP
//              NVOCCAPS3_DELIVERYCONTROL
//              NVOCCAPS3_BLTCAPS
//          dwCaps4
//              NVOCCAPS4_SMA
//              NVOCCAPS4_IMB
//              NVOCCAPS4_DEVICEHASOVL
//              NVOCCAPS4_MULTIHEADNUM (number of display heads on this device)
//              NVOCCAPS4_MULTIHEADMODE (0 = single, 1 = span, 2 = clone)
//              NVOCCAPS4_HEAD0_TYPE (0 = CRT, 1 = NTSC, 2 = PAL, 3 = DFP, -1 = inactive)
//              NVOCCAPS4_HEAD1_TYPE (0 = CRT, 1 = NTSC, 2 = PAL, 3 = DFP, -1 = inactive)
//          dwCaps5
//              NVOCCAPS5_BLT_YUV9_2_YUV422
//              NVOCCAPS5_BLT_YUV12_2_YUV422
//              NVOCCAPS5_BLT_YC12_2_YUV422
//              NVOCCAPS5_BLT_YUV422_2_YUV422
//              NVOCCAPS5_BLT_YUV422_2_RGB8
//              NVOCCAPS5_BLT_YUV422_2_RGB15
//              NVOCCAPS5_BLT_YUV422_2_RGB16
//              NVOCCAPS5_BLT_YUV422_2_RGB32
//              NVOCCAPS5_BLT_SYUV2VYUV
//              NVOCCAPS5_BLT_VYUV2VYUV
//              NVOCCAPS5_BLT_VYUV2SYUV
//              NVOCCAPS5_BLT_SYUV2VRGB
//              NVOCCAPS5_BLT_VYUV2VRGB
//              NVOCCAPS5_BLT_VYUV2SRGB
//              NVOCCAPS5_BLT_SRGB2VRGB
//              NVOCCAPS5_BLT_VRGB2VRGB
//              NVOCCAPS5_BLT_VRGB2SRGB
//              NVOCCAPS5_BLT_2RGBTEX
// NVOCCMD_SETCOLORCONTROL
//      dwSize
//      dwDevice
//      ccData
//          dwEnable (ignored for NV10 and above, always enabled)
//              0 = disable
//              1 = enable with vertical chroma subsampling
//              2 = enable with full chroma sampling (do not use)
//          dwCCFlags
//              NVOCCC_BRIGHTNESS
//                  lBrightness (range is -256 to +255)
//              NVOCCC_CONTRAST
//                  lContrast (range is 0 to 200)
//              NVOCCC_HUE
//                  lHue (range is 0 to 360)
//              NVOCCC_SATURATION
//                  lSaturation (range is 0 to 200)
// NVOCCMD_GETCOLORCONTROL
//      dwSize
//      dwDevice
//      returns ccData
//          returns dwEnable
//              0 = disable
//              1 = enable with vertical chroma subsampling
//              2 = enable with full chroma sampling (do not use)
//          returns dwCCFlags
//              NVOCCC_BRIGHTNESS
//                  returns lBrightness
//              NVOCCC_CONTRAST
//                  returns lContrast
//              NVOCCC_HUE
//                  returns lHue
//              NVOCCC_SATURATION
//                  returns lSaturation
// NVOCCMD_SETFEATURE (enables feature)
//      dwSize
//      dwDevice
//      dwFeature1
//          NVOCF1_HQVUPSCALE (always enable if enough memory (8M))
//          NVOCF1_TFILTER (only enable in BOB mode if enough memory (16M))
//              lCoefficient[0] (recommended value = 0xA4)
//              dwCmdFlags (optional)
//                  NVOCF_TF_PRECOPY
//          NVOCF1_DFILTER (only enable in BOB mode if enough memory (16M))
//              lCoefficient[1] (recommended value = 0xA4)
//              dwCmdFlags (optional)
//                  NVOCF_DF_PRECOPY
//          NVOCF1_FSMIRROR (only enable with dual head and large memory)
//              lCoefficient[4]:
//                  bits 0-3: head number
//                            0 = disable FSVM
//                            1 = display 1
//                            2 = display 2
//                            15 = autoselect display
//                  bits 4-7: aspect ratio
//                            0 = stretch to display full screen
//                            1 = preserve aspect of source (assume square pixels)
//                            3 = force anamorphic 16:9
//                            5 = track overlay aspect
//                            9 = force TV 4:3
//                  bits 8-11: zoom quadrant
//                             0 = disable zoom
//                             1 = top left
//                             2 = top right
//                             3 = bottom left
//                             4 = bottom right
//                             5 = center
//                  bits 12-19: zoom factor, 0 = 1x, 255 = 2x
//                  bit 20: 0 = use current display size
//                          1 = let driver pick the display size
//                  bit 21: 0 = independent FS and overlay zoom
//                          1 = FS zoom tracks overlay zoom controls
//                  bit 22: 0 = disable DVD output to TV
//                          1 = enable DVD output to TV
//          NVOCF1_OVLZOOM
//              lCoefficient[5]:
//                  bits 8-11: zoom quadrant
//                             0 = disable zoom
//                             1 = top left
//                             2 = top right
//                             3 = bottom left
//                             4 = bottom right
//                             5 = center
//                  bits 12-23: zoom factor, 0 = 1x, 255 = 2x
//          NVOCF1_DELIVERYCONTROL
//              lCoefficient[6]: low 32 bits of frame period (in ns)
//              lCoefficient[7]: high 32 bits of frame period (in ns)
//              returns lCoefficient[6]: pointer to 64 bit absolute timecode 0
//                      lCoefficient[7]: pointer to 64 bit absolute timecode 1
//          NVOCF1_LATEFLIPSYNC
//      dwFeature2
//          NVOCF2_VPPMAXSURFACES
//              lCoefficient[2] = set to 0, 2, 3, 4, or 6
//              lCoefficient[3] = reserved
// NVOCCMD_RESETFEATURE (disables feature)
//      dwSize
//      dwDevice
//      dwFeature1
//          NVOCF1_HQVUPSCALE
//          NVOCF1_TFILTER
//          NVOCF1_DFILTER
//          NVOCF1_FSMIRROR
//          NVOCF1_OVLZOOM
//          NVOCF1_DELIVERYCONTROL
//          NVOCF1_LATEFLIPSYNC
// NVOCCMD_GETFEATURE
//      dwSize
//      dwDevice
//      returns dwFeature1
//          NVOCF1_HQVUPSCALE
//          NVOCF1_TFILTER
//              returns lCoefficient[0]
//          NVOCF1_DFILTER
//              returns lCoefficient[1]
//          NVOCF1_FSMIRROR
//              returns lCoefficient[4]
//          NVOCF1_OVLZOOM
//              returns lCoefficient[5]
//          NVOCF1_DELIVERYCONTROL
//              returns lCoefficient[6] low 32 bits of frame period
//                      lCoefficient[7] high 32 bits of frame period
//                      lCoefficient[8] low 32 bits of absolute timecode 0
//                      lCoefficient[9] high 32 bits of absolute timecode 0
//                      lCoefficient[10] low 32 bits of absolute timecode 1
//                      lCoefficient[11] high 32 bits of absolute timecode 1
//          NVOCF1_LATEFLIPSYNC
//      returns dwFeature2
//          NVOCF2_VPPMAXSURFACES
//              lCoefficient[2] = max VPP work surfaces
//              lCoefficient[3] = VPP work surfaces currently allocated
//

#define OVERLAYCONTROLCALLBACK "nvOverlayControl"

typedef enum { 
    NVOCERR_OK              = 0,
    NVOCERR_GENERIC_WARN    = 1,
    NVOCERR_GENERIC_FATAL   = 0x80000001,
    NVOCERR_BAD_COMMAND     = 0x80000002,
    NVOCERR_INVALID_PARMS   = 0x80000003,
    NVOCERR_ALREADY_ACTIVE  = 0x80000004,
    NVOCERR_NOT_SUPPORTED   = 5,
    NVOCERR_BAD_DEVICE      = 0x80000006
} NVOCERROR;

typedef enum {
    NVOCCMD_NOOP            = 0,
    NVOCCMD_GETCAPS         = 1,
    NVOCCMD_SETCOLORCONTROL = 2,
    NVOCCMD_GETCOLORCONTROL = 3,
    NVOCCMD_SETFEATURE      = 4,
    NVOCCMD_RESETFEATURE    = 5,
    NVOCCMD_GETFEATURE      = 6,
    NVOCCMD_IDENTIFY        = 7
} NVOCCOMMAND;

typedef struct {
    unsigned long   dwCCFlags;
    unsigned long   dwEnable;
    long            lBrightness;
    long            lContrast;
    long            lHue;
    long            lSaturation;
    long            lSharpness;
    long            lGamma;
} NVOCCCDATA, *LPNVOCCCDATA;

#define NVOCCC_BRIGHTNESS   0x1
#define NVOCCC_CONTRAST     0x2
#define NVOCCC_HUE          0x4
#define NVOCCC_SATURATION   0x8
#define NVOCCC_SHARPNESS    0x10
#define NVOCCC_GAMMA        0x20

typedef struct {
    unsigned long dwCaps1;
    unsigned long dwCaps2;
    unsigned long dwCaps3;
    unsigned long dwCaps4;
    unsigned long dwCaps5;
} NVOCCAPS, *LPNVOCCAPS;

#define NVOCCAPS1_BRIGHTNESS    0x1
#define NVOCCAPS1_CONTRAST      0x2
#define NVOCCAPS1_HUE           0x4
#define NVOCCAPS1_SATURATION    0x8
#define NVOCCAPS1_SHARPNESS     0x10
#define NVOCCAPS1_GAMMA         0x20

#define NVOCCAPS2_HQVUPSCALE    0x1
#define NVOCCAPS2_TFILTER       0x2
#define NVOCCAPS2_DFILTER       0x4
#define NVOCCAPS2_FSMIRROR      0x8
#define NVOCCAPS2_OVLZOOM       0x10

#define NVOCCAPS3_SUBPICTURE        0x1
#define NVOCCAPS3_LATEFLIPSYNC      0x2
#define NVOCCAPS3_SPLITVPP          0x4
#define NVOCCAPS3_DELIVERYCONTROL   0x8
#define NVOCCAPS3_BLTCAPS           0x80000000

#define NVOCCAPS4_IMB           0x1
#define NVOCCAPS4_SMA           0x2
#define NVOCCAPS4_DEVICEHASOVL  0x4
#define NVOCCAPS4_MULTIHEADNUM  0x000F0000
#define NVOCCAPS4_MULTIHEADMODE 0x00F00000
#define NVOCCAPS4_HEAD0_TYPE    0x0F000000
#define NVOCCAPS4_HEAD1_TYPE    0xF0000000

#define NVOCCAPS5_BLT_YUV9_2_YUV422     0x00000001
#define NVOCCAPS5_BLT_YUV12_2_YUV422    0x00000002
#define NVOCCAPS5_BLT_YC12_2_YUV422     0x00000004
#define NVOCCAPS5_BLT_YUV422_2_YUV422   0x00000008
#define NVOCCAPS5_BLT_YUV422_2_RGB8     0x00000100
#define NVOCCAPS5_BLT_YUV422_2_RGB15    0x00000200
#define NVOCCAPS5_BLT_YUV422_2_RGB16    0x00000400
#define NVOCCAPS5_BLT_YUV422_2_RGB32    0x00000800
#define NVOCCAPS5_BLT_RGB16_2_RGB32     0x00001000
#define NVOCCAPS5_BLT_RGB32_2_RGB32     0x00002000
#define NVOCCAPS5_BLT_SYUV2VYUV         0x00010000
#define NVOCCAPS5_BLT_VYUV2VYUV         0x00020000
#define NVOCCAPS5_BLT_VYUV2SYUV         0x00040000
#define NVOCCAPS5_BLT_SYUV2VRGB         0x00100000
#define NVOCCAPS5_BLT_VYUV2VRGB         0x00200000
#define NVOCCAPS5_BLT_VYUV2SRGB         0x00400000
#define NVOCCAPS5_BLT_SRGB2VRGB         0x01000000
#define NVOCCAPS5_BLT_VRGB2VRGB         0x02000000
#define NVOCCAPS5_BLT_VRGB2SRGB         0x04000000
#define NVOCCAPS5_BLT_2RGBTEX           0x80000000

#define NVOCID1_UNKNOWN                 0
#define NVOCID1_INTERVIDEO              MAKEFOURCC('I','V','I',' ')
#define NVOCID1_MEDIAMATICS             MAKEFOURCC('M','D','M','X')
#define NVOCID1_RAVISENT                MAKEFOURCC('R','V','S','T')
#define NVOCID1_CYBERLINK               MAKEFOURCC('C','Y','B','R')
#define NVOCID1_NEC                     MAKEFOURCC('N','E','C',' ')
#define NVOCID1_MGI                     MAKEFOURCC('M','G','I',' ')
#define NVOCID1_CANOPUS                 MAKEFOURCC('C','N','P','S')
#define NVOCID1_AVID                    MAKEFOURCC('A','V','I','D')
#define NVOCID1_REAL                    MAKEFOURCC('R','E','A','L')
#define NVOCID1_MADONION                MAKEFOURCC('M','A','D','O')
#define NVOCID1_MICROSOFT               MAKEFOURCC('M','S','F','T')

#define NVOCID2_OS_SCHEDULED            0x00000001
#define NVOCID2_CAN_HANDLE_60HZ         0x00000002
#define NVOCID2_PIPELINED               0x00000004
#define NVOCID2_NEED_OVERLAY            0x00000008
#define NVOCID2_SINGLE_MONITOR          0x00000010

typedef struct {
    unsigned long dwFeature1;
    unsigned long dwFeature2;
    unsigned long dwFeature3;
    unsigned long dwFeature4;
    long          lCoefficient[16];
} NVOCFEATUREDATA;

#define NVOCF1_HQVUPSCALE       0x1
#define NVOCF1_TFILTER          0x2
#define NVOCF1_LATEFLIPSYNC     0x4
#define NVOCF1_DFILTER          0x8
#define NVOCF1_FSMIRROR         0x10
#define NVOCF1_OVLZOOM          0x20
#define NVOCF1_DELIVERYCONTROL  0x40

#define NVOCF2_VPPMAXSURFACES   0x1

#define NVOCF_TF_PRECOPY   0x00000001
#define NVOCF_DF_PRECOPY   0x00000002

typedef struct {
    unsigned long dwSize;
    unsigned long dwDevice;

    // command
    NVOCCOMMAND cmd;
    unsigned long dwCmdFlags;

    // data
    union {
        NVOCCAPS        caps;
        NVOCCCDATA      ccData;
        NVOCFEATUREDATA featureData;
    };

    unsigned long dwReserved[40];
} NVOCDATATYPE, *LPNVOCDATATYPE;

typedef NVOCERROR (__stdcall *NVOVERLAYCONTROL)(LPNVOCDATATYPE data);


// --------------------------------------------------------------------------
// nvSetOverlayColorControl
//      Obsolete.  Only use with rel3 drivers
//      If lpDDCC is NULL, callback returns caps
//
//      dwDevice            always 1
//      lpDDCC->dwSize      sizeof(DDCOLORCONTROL)
//      lpDDCC->dwFlags     DDCOLOR_CONTRAST | DDCOLOR_BRIGHTNESS | DDCOLOR_HUE | DDCOLOR_SATURATION
//                          determines which members hold valid data
//      lpDDCC->lBrightness range is from -256 to +255
//      lpDDCC->lContrast   range is from 0 to 200
//      lpDDCC->lHue        range is from 0 to 360
//      lpDDCC->lSaturation range is from 0 to 200
//      lpDDCC->dwReserved1 0 = disable colour controls
//                          1 = enable with vertical chroma subsampling
//                          2 = enable with full chroma sampling
// #define SETOVERLAYCOLORCONTROLCALLBACK "nvSetOverlayColorControl"

//typedef DWORD (__stdcall *NVSETOVERLAYCOLORCONTROL)(DWORD dwDevice, LPDDCOLORCONTROL lpDDCC);


// --------------------------------------------------------------------------
// nvMoComp
//      Backdoor DMA blits and formatting for video
// 
// Command Structure
// -----------------
// NVS2VCMD_INIT
//      dwSize
//      dwDevice
//      dwIndex
//      dwHeight
//      dwSrcType
//          NVS2V_YUYV:
//              fpSrc
//          NVS2V_UYVY:
//              fpSrc
//          NVS2V_RGB16:
//              fpSrc
//          NVS2V_RGB32:
//              fpSrc
//          NVS2V_YC12
//              SrcYC12.fpY
//          NVS2V_YUV12
//              SrcYUV12.fpY (points to start of surface)
//      dwSrcPitch
//      dwDstFlags (optional)
//          NVS2VF_OFFSET
//      dwDstType (required only if using INDEXED type on BLIT)
//          NVS2V_YUYV
//              fpDst
//          NVS2V_UYVY
//              fpDst
//          NVS2V_DDSURF
//              lpDstDirectDrawSurface
// NVS2VCMD_RELEASE
//      dwSize
//      dwDevice
//      dwIndex
// NVS2VCMD_BLIT
//      dwSize
//      dwDevice
//      dwIndex
//      dwWidth
//      dwHeight
//      dwSrcFlags (optional)
//          NVS2VF_OFFSET (only use for V->S blits)
//          NVS2VF_LOCAL
//          NVS2VF_SYSTEM (default)
//      dwSrcType
//          NVS2V_YC12
//              SrcYC12.fpY
//              SrcYC12.fpC
//          NVS2V_YUV12
//              SrcYUV12.fpY
//              SrcYUV12.fpU
//              SrcYUV12.fpV
//          NVS2V_YUYV
//              fpSrc
//          NVS2V_UYVY
//              fpSrc
//          NVS2V_YV12
//              SrcYUV12.fpY
//              SrcYUV12.fpU
//              SrcYUV12.fpV
//              dwSrcYV12ChromaPitch
//      dwSrcPitch
//      dwDstFlags (optional)
//          NVS2VF_OFFSET (only use for S->V blits)
//          NVS2VF_LOCAL (default)
//          NVS2VF_SYSTEM
//      dwDstType
//          NVS2V_YUYV
//              fpDst
//          NVS2V_UYVY
//              fpDst
//          NVS2V_DDSURF
//              lpDstDirectDrawSurface
//          NVS2V_INDEXED (uses last YUY2 or UYVY state)
//              dwDstSize
//      dwDstPitch
//      bWaitForCompletion
//          dwTimeoutTime
// NVS2VCMD_QUERY_IDLE
//      dwSize
//      dwDevice
// NVS2VCMD_WAIT_FOR_IDLE
//      dwSize
//      dwDevice
//      dwTimeoutTime
// NVS2VCMD_SET_SUBPICTURE
//      dwSize
//      dwDevice
//      dwSPFlags (optional)
//          NVS2VF_OFFSET
//          NVS2VF_SP_SUBRECT
//              dwSubRectX
//              dwSubRectY
//              dwSubRectWidth
//              dwSubRectHeight
//      dwSPType
//      dwSPPitch
//      fpSP
// NVS2VCMD_VPP_START
//      dwSize
//      dwDevice
//      dwWidth
//      dwHeight
//      dwSrcType
//          NVS2V_YUYV
//              fpSrc
//          NVS2V_UYVY
//              fpSrc
//      dwSrcPitch
//      dwSrcFlags (optional)
//          NVS2VF_OFFSET
//          NVS2VF_VPP_ODD
//          NVS2VF_VPP_EVEN
//          NVS2VF_VPP_BOB
//          NVS2VF_VPP_INTERLEAVED
// NVS2VCMD_VPP_QUERY
//      dwSize
//      dwDevice
// NVS2VCMD_VPP_FLIP
//      dwSize
//      dwDevice
// NVS2VCMD_4CC_TO_VRGB
//      dwSize
//      dwIndex (0xFFFFFFFF means use video memory)
//      dwCmdFlags (optional)
//          NVS2VF_CRTC_SYNC
//              dwHead
//              dwScanline (blit will not begin until CRTC of specified head reaches this scanline)
//              dwTimeoutTime
//          NVS2VF_USE_DELIVERY_CTL
//              dwTimeoutTime
//      dwDevice
//      dwWidth
//      dwHeight
//      dwSrcFlags (optional)
//          NVS2VF_OFFSET
//          NVS2VF_LOCAL
//          NVS2VF_SYSTEM (default)
//      dwSrcType
//          NVS2V_RGB16
//              fpSrc (not required if in system memory)
//              dwSrcPixelBias (31:16 is the Y pixel bias in 12.4 fixed point, 15:0 is the X pixel bias in 12.4 fixed point)
//          NVS2V_RGB32
//              fpSrc (not required if in system memory)
//              dwSrcPixelBias (31:16 is the Y pixel bias in 12.4 fixed point, 15:0 is the X pixel bias in 12.4 fixed point)
//          NVS2V_YUYV
//              fpSrc (not required if in system memory)
//              dwSrcPixelBias (31:16 is the Y pixel bias in 12.4 fixed point, 15:0 is the X pixel bias in 12.4 fixed point)
//          NVS2V_UYVY
//              fpSrc (not required if in system memory)
//              dwSrcPixelBias (31:16 is the Y pixel bias in 12.4 fixed point, 15:0 is the X pixel bias in 12.4 fixed point)
//      dwSrcPitch
//      dwDstFlags (optional)
//          NVS2VF_OFFSET
//          NVS2VF_LOCAL (default)
//          NVS2VF_SYSTEM
//          NVS2VF_SWIZZLED
//      dwDstType
//          NVS2V_RGB16
//              DstRGB.fpRGB
//              DstRGB.dwDstWidth
//              DstRGB.dwDstHeight
//          NVS2V_RGB32
//              DstRGB.fpRGB
//              DstRGB.dwDstWidth
//              DstRGB.dwDstHeight
//      dwDstPitch
//      bWaitForCompletion
//          dwTimeoutTime
// NVS2VCMD_GET_TEXTURE_OFFSET
//      dwSize
//      dwDevice
//      fpTexture
//      returns fpTexture


#define MOCOMPCALLBACK "nvMoComp"

typedef enum {
    NVS2V_YC12      = 1,
    NVS2V_YUV12     = 2,
    NVS2V_YUYV      = 3,
    NVS2V_UYVY      = 4,
    NVS2V_DDSURF    = 5,
    NVS2V_INDEXED   = 6,
    NVS2V_YUVA16    = 7,
    NVS2V_YUVA32    = 8,
    NVS2V_YV12      = 9,
    NVS2V_RGB8      = 0x10,
    NVS2V_RGB16     = 0x11,
    NVS2V_RGB24     = 0x12,
    NVS2V_RGB32     = 0x13
} NVS2VSURFTYPE;

typedef enum {
    NVS2VCMD_NOOP               = 0,
    NVS2VCMD_INIT               = 1,
    NVS2VCMD_RELEASE            = 2,
    NVS2VCMD_BLIT               = 3,
    NVS2VCMD_QUERY_IDLE         = 4,
    NVS2VCMD_WAIT_FOR_IDLE      = 5,
    NVS2VCMD_SET_SUBPICTURE     = 6,
    NVS2VCMD_VPP_START          = 7,
    NVS2VCMD_VPP_QUERY          = 8,
    NVS2VCMD_VPP_FLIP           = 9,
    NVS2VCMD_4CC_TO_VRGB        = 0xA,
    NVS2VCMD_GET_TEXTURE_OFFSET = 0xB
} NVS2VCOMMAND;

typedef enum {
    NVS2VERR_OK             = 0,
    NVS2VERR_GENERIC_WARN   = 1,
    NVS2VERR_GENERIC_FATAL  = 0x80000001,
    NVS2VERR_BAD_COMMAND    = 0x80000002,
    NVS2VERR_INVALID_PARMS  = 0x80000003,
    NVS2VERR_INIT_FAILED    = 0x80000004,
    NVS2VERR_NO_EVENT       = 5,
    NVS2VERR_BUSY           = 6,
    NVS2VERR_TIMEOUT        = 7,
    NVS2VERR_BAD_DEVICE     = 0x80000008,
    NVS2VERR_NOT_READY      = 0x80000009, // The VPP has not been initialized
} NVS2VERROR;

#define NVS2VF_OFFSET           0x00000001
#define NVS2VF_SP_SUBRECT       0x00000002
#define NVS2VF_SP_ODD           0x00000004
#define NVS2VF_SP_EVEN          0x00000008
#define NVS2VF_VPP_ODD          0x00000010
#define NVS2VF_VPP_EVEN         0x00000020
#define NVS2VF_VPP_BOB          0x00000040
#define NVS2VF_VPP_INTERLEAVED  0x00000080
#define NVS2VF_LOCAL            0x00000100
#define NVS2VF_SYSTEM           0x00000200
#define NVS2VF_SWIZZLED         0x00000400
#define NVS2VF_CRTC_SYNC        0x00000800
#define NVS2VF_USE_DELIVERY_CTL 0x00001000

typedef struct {
    unsigned long dwSize;               // sizeof(NVS2VDATATYPE)
    
    // command data
    NVS2VCOMMAND  dwCmd;
    unsigned long dwCmdFlags;
    BOOL          bWaitForCompletion;
    unsigned long dwTimeoutTime;        // in ms
    unsigned long dwIndex;
    unsigned long dwDevice;
    unsigned long dwHead;
    unsigned long dwScanline;
    unsigned long dwReserved1[55];

    // neutral data
    unsigned long dwWidth;              // in pixels
    unsigned long dwHeight;             // in lines

    // source data
    unsigned long dwSrcFlags;
    NVS2VSURFTYPE dwSrcType;
    unsigned long dwSrcPitch;           // in bytes
    union {
        void  *fpTexture;
        void  *fpSrc;                   // used with NVS2V_YUYV or NVS2V_UYVY or NVS2V_RGB32 or NVS2V_RGB16
        void  *lpSrcDirectDrawSurface;  // used with NVS2V_DDSURF (not implemented)
        unsigned long dwSrcSize;        // used with NVS2V_INDEXED (not implemented)
        struct {
            void  *fpY;
            void  *fpC;
        } SrcYC12;                      // used with NVS2V_YC12 (Y and C must be contiguous)
        struct {
            void  *fpY;
            void  *fpU;
            void  *fpV;
        } SrcYUV12;                     // used with NVS2V_YUV12 (not implemented)
    };

    // destination data
    unsigned long dwDstFlags;
    NVS2VSURFTYPE dwDstType;
    unsigned long dwDstPitch;           // in bytes
    union {
        void  *fpDst;                   // used with NVS2V_YUYV or NVS2V_UYVY or NVS2V_RGB32 or NVS2V_RGB16
        void  *lpDstDirectDrawSurface;  // used with NVS2V_DDSURF
        unsigned long dwDstSize;        // used with NVS2V_INDEXED
        struct {
            void *fpY;
            void *fpC;
        } DstYC12;                      // used with NVS2V_YC12 (not implemented)
        struct {
            void *fpY;
            void *fpU;
            void *fpV;
        } DstYUV12;                     // used with NVS2V_YUV12 (not implemented)
        struct {
            void *fpRGB;
            unsigned long dwDstWidth;
            unsigned long dwDstHeight;
        } DstRGB;                       // used with the RGB surface types
    };

    // subpicture data
    unsigned long dwSPFlags;
    NVS2VSURFTYPE dwSPType;
    unsigned long dwSPPitch;
    unsigned long fpSP;
    unsigned long dwSubRectX;
    unsigned long dwSubRectY;
    unsigned long dwSubRectWidth;
    unsigned long dwSubRectHeight;

    // more source data
    unsigned long dwSrcYV12ChromaPitch;
    unsigned long dwSrcPixelBias;

    // pad
    unsigned long dwReserved2[40];
} NVS2VDATATYPE, *LPNVS2VDATATYPE;

typedef NVS2VERROR (__stdcall *NVMOCOMP)(LPNVS2VDATATYPE data);

#endif // _NVPRIV_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\common\inc\nvtracecom.h ===
#ifndef __NV_TRACECOM_H
#define __NV_TRACECOM_H
// This struct is used for debug code.

typedef struct nvFunRec {
    char *uname;
    char *name;
    int class;
    int level;
    struct nvFunRec *next;
    int count;
    struct {
        int msh, lsh;
    } time;
} nvFunRec;

extern int nvDebugOptions;
extern int nvDebugMask;
extern int nvDebugLevel;
extern int nvControlOptions;

#endif // __NV_TRACECOM_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\common\inc\nvregionshared.h ===
/***********************************************************

Copyright (c) 1987, 1988, 1989  X Consortium

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
X CONSORTIUM BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

Except as contained in this notice, the name of the X Consortium shall not be
used in advertising or otherwise to promote the sale, use or other dealings
in this Software without prior written authorization from the X Consortium.


Copyright 1987, 1988, 1989 by
Digital Equipment Corporation, Maynard, Massachusetts.

                        All Rights Reserved

Permission to use, copy, modify, and distribute this software and its
documentation for any purpose and without fee is hereby granted,
provided that the above copyright notice appear in all copies and that
both that copyright notice and this permission notice appear in
supporting documentation, and that the name of Digital not be
used in advertising or publicity pertaining to distribution of the
software without specific, written prior permission.

DIGITAL DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL
DIGITAL BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR
ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
SOFTWARE.

******************************************************************/
/* $XConsortium: miregion.c,v 1.60 94/04/17 20:27:49 dpw Exp $ */


#ifndef __NVREGIONSHARED_H
#define __NVREGIONSHARED_H

#if !defined(XFree86LOADER)
typedef struct _Box {
    short x1, y1, x2, y2;
} BoxRec;

typedef struct _Box *BoxPtr;
#else
# include <miscstruct.h>
#endif /* XFree86LOADER */

/* 
 *   clip region
 */

typedef struct _RegData {
    int    size;
    int    numRects;
/*  BoxRec rects[size];   in memory but not explicitly declared */
} RegDataRec, *RegDataPtr;

typedef struct _Region {
    BoxRec  extents;
    RegDataPtr  data;
} RegionRec, *RegionPtr;


#define REGION_NIL(reg) ((reg)->data && !(reg)->data->numRects)
#define REGION_NUM_RECTS(reg) ((reg)->data ? (reg)->data->numRects : 1)
#define REGION_SIZE(reg) ((reg)->data ? (reg)->data->size : 0)
#define REGION_RECTS(reg) ((reg)->data ? (BoxPtr)((reg)->data + 1) \
                           : &(reg)->extents)
#define REGION_BOXPTR(reg) ((BoxPtr)((reg)->data + 1))
#define REGION_BOX(reg,i) (&REGION_BOXPTR(reg)[i])
#define REGION_TOP(reg) REGION_BOX(reg, (reg)->data->numRects)
#define REGION_END(reg) REGION_BOX(reg, (reg)->data->numRects - 1)
#define REGION_SZOF(n) (sizeof(RegDataRec) + ((n) * sizeof(BoxRec)))

#define good(a)

extern void * NV_STDCALL oglXAlloc(size_t size);
extern void  NV_STDCALL oglXFree(void *ptr);
extern void * NV_STDCALL oglXRealloc(void *oldPtr, size_t oldSize, size_t newSize);

extern RegDataPtr  NV_STDCALL oglXAllocData(int n);
extern void  NV_STDCALL oglXFreeData(RegionPtr reg);

extern int  NV_STDCALL nvInverse(RegionPtr newReg, RegionPtr reg1, BoxPtr invRect);
extern int  NV_STDCALL nvIntersect(RegionPtr newReg, RegionPtr reg1, RegionPtr reg2);
extern void  NV_STDCALL nvOptimizeRegion(RegionPtr nvRegion);
   
#endif // __NVREGIONSHARED_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\common\inc\nvsvc_public.h ===
//
// File:         nvsvc_public.h
// Author(s):    Viet-Tam Luu
// Description:  Public exports and definitions for NVSVC clients.
// Target OS:    Windows NT, Windows 2000, Windows XP, Windows 98, Windows ME
// Platform:     IA32, IA64
//
// Copyright 2001 NVIDIA Corporation.
//

#ifndef __nvsvc_public_h__
#define __nvsvc_public_h__

#ifdef __cplusplus
extern "C" {
#endif


// Filenames of NVSVC binary under various OSes.
#define NV_SERVICE_FILE_WINNT   "nvsvc32.exe"
#define NV_SERVICE_FILE_WIN64   "nvsvc64.exe"
#define NV_SERVICE_FILE_WIN9X   "nvsvc.exe"

// Magic args to run Win9x service.
#define NV_SERVICE_ARG_W9XSTART "-runservice"
#define NV_SERVICE_ARG_W9XSTOP  "-stop"

// NVSVC service name and description strings.
#define NV_SERVICE_NAME         "NVSvc"
#define NV_SERVICE_DESC         "NVIDIA Driver Helper Service"

// Client events handled by NVSVC.
#define NVSVC_EVENT_STOP        "NVSvcStop"
#define NVSVC_EVENT_ICONBEGIN   "NVIconBeginEvent"
#define NVSVC_EVENT_ICONEND     "NVIconEndEvent"
#define NVSVC_EVENT_MODESWITCH  "NVModeSwitchEvent"
#define NVSVC_EVENT_DSWHOTKEY   "NVDisplaySwitchHotKey"
#define NVSVC_EVENT_PMM         "NVPMMEvent"

// Maximum length of any named events supported by nVidia drivers.
// This includes any prefixes to the name.
#define NVSVC_EVENT_NAME_MAX_LENGTH    256

// Event names as seen by the Win2K/NT4 drivers.
// We need to prepend a prefix to the name strings.
#define NVSVC_EVENT_ICONBEGIN_DRIVER   "\\BaseNamedObjects\\"NVSVC_EVENT_ICONBEGIN
#define NVSVC_EVENT_ICONEND_DRIVER     "\\BaseNamedObjects\\"NVSVC_EVENT_ICONEND
#define NVSVC_EVENT_MODESWITCH_DRIVER  "\\BaseNamedObjects\\"NVSVC_EVENT_MODESWITCH
#define NVSVC_EVENT_DSWHOTKEY_DRIVER   "\\BaseNamedObjects\\"NVSVC_EVENT_DSWHOTKEY

// Identifier for NVSVC's RM client.
#define NVSVC_RM_CLIENT_HANDLE  0x95510933

// Named mutex taken by first running NVSVC service (Win9x only).
#define NVSVC_MUTEX_INSTANCE    "NVSvcInstanceMutex"

#ifdef __cplusplus
}   // extern "C"
#endif

#endif	// #ifndef __nvsvc_public_h__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\common\inc\nvReg.h ===
/*
 * nvReg.h
 *
 * Registry keys and functions for the NVIDIA drivers
 *
 * Copyright (c) 1997-1999, NVIDIA Corporation.  All rights reserved.
 *
 * THE INFORMATION CONTAINED HEREIN IS PROPRIETARY AND CONFIDENTIAL TO
 * NVIDIA, CORPORATION.  USE, REPRODUCTION OR DISCLOSURE TO ANY THIRD PARTY
 * IS SUBJECT TO WRITTEN PRE-APPROVAL BY NVIDIA, CORPORATION.
 */

/* Note to OEMs:
   Please leave these strings intact.  There are utilities published on the
   net which let users edit these registry keys, and the utils expect the
   values to be in this location.  It will also allow us to occasionally post
   messages in RIVA-related web sites discussing how these values can affect
   performance and quality.  Thanks!
*/

//*****************************************************************************
// ----------------------------  NOTE  ----------------------------------------
//
// Only #define constants belong in this file.  This file is used for other
// operating systems besides Windows and should be kept clean of Windows
// specific types.
//
// ----------------------------------------------------------------------------
//*****************************************************************************


//-----------------------------------------------------------------------------
// Base
//-----------------------------------------------------------------------------

#define NV_MAX_REG_KEYNAME_LEN 256

#define NV04_REG_PRODUCT_NAME                   "RIVA TNT"
#define NV10_REG_PRODUCT_NAME                   "GeForce 256"
#define NV10GL_REG_PRODUCT_NAME                 "Quadro"

//  There are keys which are global and apply to all NVidia boards in a
//  system and those keys which are board specific. The global keys all
//  use the following path as a base:
#if defined(unix)
#define NV4_REG_GLOBAL_BASE_KEY     ""
#define NV4_REG_GLOBAL_BASE_PATH    "_NV_"
#else
#define NV4_REG_GLOBAL_BASE_KEY     HKEY_LOCAL_MACHINE
#define NV4_REG_GLOBAL_BASE_PATH    "SOFTWARE\\NVIDIA Corporation\\Global"
#endif
#define NV4_REG_MAX_STR_SIZE        256

//  For each sub-system, the following key should be tacked onto the
//  GLOBAL_BASE_PATH given above and specific registry values for that
// sub-system placed inside the resulting key.
#define NV4_REG_SUBKEY                  "NVidia"
#define NV4_REG_DISPLAY_DRIVER_SUBKEY   "Display"
#define NV4_REG_DIRECT_DRAW_SUBKEY      "DirectDraw"
#define NV4_REG_DIRECT3D_SUBKEY         "Direct3D"
#define NV4_REG_RESOURCE_MANAGER_SUBKEY "System"
#define NV4_REG_OGL_SUBKEY              "OpenGL"
#define NV4_REG_OGL_DEBUG_SUBKEY        "OpenGL\\Debug"
#define NV4_REG_CONTROL_PANEL_SUBKEY    "NVTweak"
#define NV4_REG_DESKTOP_MANAGER_SUBKEY  "NVDesk"
#define NV4_REG_MEDIA_PORT_SUBKEY       "MediaPort"
#define NV4_REG_STEREO_SUBKEY           "Stereo3D"

// For the board specific keys (also called "local" keys), the registry
// path must be run-time determined. An escape has been added to the
// display driver to return a registry path string. Each instance of the
// display driver in a multi-mon system will return a different
// registry path that is specific to the board/slot/device, etc. You
// should use this as the base path for local keys and, as with the
// global keys, tack on one of the above sub-system strings and then
// place your registry values in the resulting key. The escape to
// return the local base path is defined in
// ...drivers\common\win9x\inc\escape.h

//-----------------------------------------------------------------------------
// Display Driver
//-----------------------------------------------------------------------------

// These may be used by many labels
#define NV4_REG_DRV_TRUE                         "1"
#define NV4_REG_DRV_FALSE                        "0"

// This is for QA, so that any mode can be set.
#define NV4_REG_DRV_ALLOW_ALL_MODES             "AllowAllModes"

// This is to allow any mode up to 2048x1536 to be set as the desktop.
#define NV4_REG_DRV_ALLOW_MIGHTY_MODES          "AllowMightyModes"

// This tells what the boot device will be.
#define NV4_REG_DRV_BOOT_DEVICE_TYPE            "ForcedBootDeviceType"

// This tells us whether to use the RM or the reg for getting a
// forced boot device type.
#define NV4_REG_DRV_USE_HW_SELECTED_DEVICE      "UseHwSelectedDevice"

// This tells us whether or not to use a separate registry key for the
// clone desktop mode and the standard desktop mode.
#define NV4_REG_DRV_USE_CLONE_DESKTOP_MODE      "UseCloneDesktopMode"

// This tells us whether to restrict the desktop mode to the greatest
// EDID mode of the lesser display device.
#define NV4_REG_DRV_RESTRICT_LARGEST_MODE       "RestrictLargestMode"

// This tells us whether we should invalidate 1400x1050 as a mode when
// we are not on a 1400x1050 panel.
#define NV4_REG_DRV_1400x1050_OVERRIDE          "Override1400x1050"

// This tells us whether to send a StopImage method to the VideoLutCursorDac
// class after a modeset. This will blank the screen.                                                                 
#define NV4_REG_DRV_MODESET_STOP_IMAGE          "ModesetStopImage"

// If this key exists, it tells us the maximum allowable mode for the DFP.
#define NV4_REG_DRV_MAX_DFP_MODE                "MaxDfpMode"

// The physical device attachments are given as PhysicalDevice0,
// PhysicalDevice1, etc. This is the base string.
#define NV4_REG_DRV_PHYSICAL_DEVICE             "PhysicalDevice"

// The following reg keys are string values which always look like
// "xres,yres,bpp"  e.g. "1024,768,16"
#define NV4_REG_DRV_FORCED_DESKTOP_MODE         "ForcedDesktopMode"
#define NV4_REG_DRV_LAST_DESKTOP_MODE           "LastDesktopMode"
#define NV4_REG_DRV_LAST_CLONE_DESKTOP_MODE     "LastCloneDesktopMode"

// This keeps track of the last tv format
#define NV4_REG_DRV_LAST_TV_FORMAT              "LastTVFormat"

// These are possible values for the LastTVFormat
#define NV4_REG_DRV_NTSCM_TVFORMAT              "NTSCM"
#define NV4_REG_DRV_NTSCJ_TVFORMAT              "NTSCJ"
#define NV4_REG_DRV_PALM_TVFORMAT               "PALM"
#define NV4_REG_DRV_PALA_TVFORMAT               "PALA"
#define NV4_REG_DRV_PALN_TVFORMAT               "PALN"
#define NV4_REG_DRV_PALNC_TVFORMAT              "PALNC"

// The following reg keys are string values which always look like
// "xres,yres,bpp,refresh_rate"  e.g. "1024,768,16,75"
// These are local keys.
#define NV4_REG_DRV_LAST_CRT_MODE               "LastCRTMode"
#define NV4_REG_DRV_LAST_DFP_MODE               "LastDFPMode"
#define NV4_REG_DRV_LAST_NTSCM_MODE             "LastNTSCMMode"
#define NV4_REG_DRV_LAST_NTSCJ_MODE             "LastNTSCJMode"
#define NV4_REG_DRV_LAST_PALM_MODE              "LastPALMMode"
#define NV4_REG_DRV_LAST_PALA_MODE              "LastPALAMode"
#define NV4_REG_DRV_LAST_PALN_MODE              "LastPALNMode"
#define NV4_REG_DRV_LAST_PALNC_MODE             "LastPALNCMode"

// The following reg keys are string values which always look like
// "xres,yres,bpp,refresh_rate"  e.g. "1024,768,16,75"
// These are local keys.
#define NV4_REG_DRV_FORCED_MODE                 "ForcedMode"
#define NV4_REG_DRV_LAST_MODE                   "LastMode"

// The following registry values are used when the user requests adapter
// default refresh rate. They are all string values which look like:
// "60" or "75" etc. If the keys do not exist, the adapter default value
// is obtained in another way.
// These are local keys.
#define NV4_REG_DRV_DEFAULT_CRT_VERT_REFRESH_RATE   "DefaultCRTRefreshRate"
#define NV4_REG_DRV_DEFAULT_DFP_VERT_REFRESH_RATE   "DefaultDFPRefreshRate"

// The following registry values are used when the user requests optimal
// refresh rate. They are all string values which look like:
// "60" or "75" etc. If the keys do not exist, the optimal refresh value
// is obtained in another way.
// These are local keys.
#define NV4_REG_DRV_OPTIMAL_CRT_VERT_REFRESH_RATE   "OptimalCRTRefreshRate"
#define NV4_REG_DRV_OPTIMAL_DFP_VERT_REFRESH_RATE   "OptimalDFPRefreshRate"

// This registry value is used to override the timing standard used
// for the monitor.
#define NV4_REG_DRV_MONITOR_TIMING                  "MonitorTiming"
#define NV4_REG_DRV_MONITOR_TIMING_DMT              "DMT"
#define NV4_REG_DRV_MONITOR_TIMING_GTF              "GTF"

// This is used for the cursor alpha amount
#define NV4_REG_DRV_CURSOR_ALPHA                    "CursorAlpha"

// The following key is used to indicate that the driver should
// read the EDID and use it. It is a string value and the
// possible options are "0" and "1".
#define NV4_REG_DRV_FORCE_EDID_READ                 "ForceEdidRead"

// The following reg key ius a string value which always looks like
// "xres,yres,bpp,refresh_rate"  e.g. "1024,768,16,75"
// It is a local key. It gives the highest permissable mode when
// their is no EDID and no INF installed for the monitor.
#define NV4_REG_DRV_MONITOR_LIMIT_MODE              "NoEdidNoInfLimitMode"

// The RestrictOptimal key causes the modeset DLL to look for an
// exact Xres,Yres match with an EDID mode. If one exists, then
// that refresh rate will be the one used. If not, then other
// logic determines the refresh rate. The possible values are
// NV4_REG_DRV_TRUE or NV4_REG_DRV_FALSE
#define NV4_REG_DRV_USE_REFRESH_RATE_OF_XYRES_EDID_MODE_MATCH   "RestrictOptimal"

// These are erased by the driver at boot time.
#define POWERUPFLAGS                                "PowerUpFlags"

// These are used by the driver for dual-head support
#define NV4_REG_DRV_VIRTUALDESKTOP                  "VirtualDesktop"
#define NV4_REG_DRV_AUTOPANMODE                     "AutoPanMode"

// This key is read to indicate whether we should run single monitor,
// multimon or clone mode.
#define NV4_REG_DRV_DESKTOPSTATE                    "DesktopState"
#define NV4_REG_DRV_DESKTOP_STATE_NORMAL            "Single"
#define NV4_REG_DRV_DESKTOP_STATE_MULTI_MON         "Multi"
#define NV4_REG_DRV_DESKTOP_STATE_CLONE             "Clone"

// This key is read to determine whether or not to check for an SXGA Panel.
#define NV4_REG_DRV_CHECK_SXGA_PANEL                "CheckSXGAPanel"

// This key is read to determine whether or not to set panning for the clone device.
#define NV4_REG_DRV_PANNING_FLAG                    "CloneDevicePanningFlag"


//-----------------------------------------------------------------------------
// DirectDraw
//-----------------------------------------------------------------------------

// default is enabled, define and set to zero to disable
#define NV4_REG_VPE_ENABLE              "VPEENABLE"

// EnumDDRefresh (default = 0)
//      0 = do not enumerate refresh rates
//      1 = only enumerate refresh rates of modes above 640x480
//      2 = enumerate all refresh rates
#define NV4_REG_ENUM_REFRESH                "EnumDDRefresh"
#define   NV4_REG_ENUM_REFRESH_DISABLE      0
#define   NV4_REG_ENUM_REFRESH_ENABLEBIG    1
#define   NV4_REG_ENUM_REFRESH_ENABLEALL    2

// all the overlay settings are local

// OverlayMode (default = 0)
//      0 = always use overlay upscale
//      1 = use vertical blt upscale if sufficient resources
//      2 = use temporal filter
//      3 = this is not the first frame (gets autoset after 1 frame)
//      8-15 = temporal filter factor
#define NV4_REG_OVL_MODE                "OverlayMode"
#define   NV4_REG_OVL_MODE_VUPSCALE     0x1
#define   NV4_REG_OVL_MODE_TFILTER      0x2
#define   NV4_REG_OVL_MODE_NOTFIRST     0x4
#define   NV4_REG_OVL_MODE_TF_PRECOPY   0x8
#define   NV4_REG_OVL_MODE_LATEFLIPSYNC 0x10
#define   NV4_REG_OVL_MODE_DFILTER      0x20
#define   NV4_REG_OVL_MODE_DF_PRECOPY   0x40
#define   NV4_REG_OVL_MODE_TFACTOR      15:8
#define   NV4_REG_OVL_MODE_DFACTOR      23:16

// OverlayMode2 (default = 0)
//   bits 0-3 = Full screen mirror device number (1 based, zero means disable)
//      bit 4 = Preserve aspect in full screen mirror mode
//      bit 5 = Fix aspect ratio to 16:9, bit 4 must be set also
//      bit 6 = Track aspect ratio of overlay, bit 4 must be set also
//      bit 7 = Fix aspect ratio to 4:3, bit 4 must also be set
//      bits 8-11 = Video zoom quadrant
//                  0: zoom disabled
//                  1: top left quadrant
//                  2: top right quadrant
//                  3: bottom left quadrant
//                  4: bottom right quadrant
//                  5: center
//      bits 12-23 = Video zoom factor, 0 = 1x, 255 = 2x
//      bit 24 = Let the driver pick the full screen display mode
//      bit 25 = Track overlay zoom
//      bit 26 = Enable TV devices
#define NV4_REG_OVL_MODE2                       "OverlayMode2"
#define     NV4_REG_OVL_MODE2_FSMASK            0x007FFFFF
#define     NV4_REG_OVL_MODE2_FSDEVICEMASK      0x0000000F
#define     NV4_REG_OVL_MODE2_FSASPECTMASK      0x000000F0
#define     NV4_REG_OVL_MODE2_FSZOOMQUADMASK    0x00000F00
#define     NV4_REG_OVL_MODE2_FSZOOMFACTORMASK  0x000FF000
#define     NV4_REG_OVL_MODE2_FSDEVICE          0:3
#define     NV4_REG_OVL_MODE2_FSASPECT          0x00000010
#define     NV4_REG_OVL_MODE2_FSFIXEDANIMORPHIC 0x00000020
#define     NV4_REG_OVL_MODE2_FSTRACKOVLASPECT  0x00000040
#define     NV4_REG_OVL_MODE2_FSFIXEDTV         0x00000080
#define     NV4_REG_OVL_MODE2_FSZOOMQUAD        8:11
#define     NV4_REG_OVL_MODE2_FSZOOMFACTOR      12:23
#define     NV4_REG_OVL_MODE2_FSSETMODE         0x00100000
#define     NV4_REG_OVL_MODE2_FSTRACKOVLZOOM    0x00200000
#define     NV4_REG_OVL_MODE2_FSENABLETV        0x00400000

// OverlayMode3 (default = 0);
//   bit 0 = Allow overlay creation in clone mode and win2k span mode
//   bits 8-11 = Overlay zoom quadrant
//               0: zoom disabled
//               1: top left quadrant
//               2: top right quadrant
//               3: bottom left quadrant
//               4: bottom right quadrant
//               5: center
//   bits 12-23: Overlay zoom factor, 0 = 1x, 255 = 2x
#define NV4_REG_OVL_MODE3                                   "OverlayMode3"
#define     NV4_REG_OVL_MODE3_ALLOWOVL                      0x00000001
#define     NV4_REG_OVL_MODE3_DXVA_BACK_END_ALPHA_PREFERRED 0x00000002
#define     NV4_REG_OVL_MODE3_OVLZOOMMASK                   0x000FFF00
#define     NV4_REG_OVL_MODE3_OVLZOOMQUADMASK               0x00000F00
#define     NV4_REG_OVL_MODE3_OVLZOOMFACTORMASK             0x000FF000
#define     NV4_REG_OVL_MODE3_OVLZOOMQUAD                   8:11
#define     NV4_REG_OVL_MODE3_OVLZOOMFACTOR                 12:23

// VPPInvMask (default = 0)
//      Inverse mask for all VPP function enables.  Should exactly match
//      command flags defined in ddVPP.h
#define NV4_REG_VPP_INV_MASK                "VPPInvMask"
#define   NV4_REG_VPP_INV_MASK_ODD          0x1
#define   NV4_REG_VPP_INV_MASK_EVEN         0x2
#define   NV4_REG_VPP_INV_MASK_BOB          0x4
#define   NV4_REG_VPP_INV_MASK_INTERLEAVED  0x8
#define   NV4_REG_VPP_INV_MASK_VIDEOPORT    0x10
#define   NV4_REG_VPP_INV_MASK_WAIT         0x20
#define   NV4_REG_VPP_SAVE_STATE_DISABLE    0x40
#define   NV4_REG_VPP_RESTORE_STATE_DISABLE 0x80
#define   NV4_REG_VPP_CONVERT_DISABLE       0x100
#define   NV4_REG_VPP_SUBPICTURE_DISABLE    0x200
#define   NV4_REG_VPP_PRESCALE_DISABLE      0x400
#define   NV4_REG_VPP_COLOURCONTROL_DISABLE 0x800
#define   NV4_REG_VPP_TEMPORAL_DISABLE      0x1000
#define   NV4_REG_VPP_OPTIMIZEFLIP_DISABLE  0x2000
#define   NV4_REG_VPP_DEINTERLACE_DISABLE   0x4000
#define   NV4_REG_VPP_FSMIRROR_DISABLE      0x8000
#define   NV4_REG_VPP_DMABLIT_DISABLE       0x10000
#define   NV4_REG_VPP_MASTER_DISABLE        0x80000000

// VPPMaxSurfaces
//      Determines the maximum number of work surfaces VPP is allowed to use.
//      Legal values are:
//          6 - Full functionality and performance
//          4 - Full functionality, no superpipelining
//          3 - One stage allowed, superpipelined
//          2 - One stage allowed, no superpipelining
//          0 - VPP disabled
#define NV4_REG_VPP_MAX_SURFACES            "VPPMaxSurfaces"

// OverlayColorControlEnable (default = 0)
//      0 = disable
//      1 = enable with vertical chroma subsampling enabled (use this one)
//      2 = enable with vertical chroma subsampling disabled
// OverlayBrightness (default = 0)
// OverlayContrast (default = 100)
// OverlayHue (default = 0)
// OverlaySaturation (default = 100)
// OverlayGamma (not implemented)
// OverlaySharpness (not implemented)
#define NV4_REG_OVLCC_ENABLE            "OverlayColorControlEnable"
#define NV4_REG_OVLCC_BRIGHTNESS        "OverlayBrightness"
#define NV4_REG_OVLCC_CONTRAST          "OverlayContrast"
#define NV4_REG_OVLCC_HUE               "OverlayHue"
#define NV4_REG_OVLCC_SATURATION        "OverlaySaturation"
#define NV4_REG_OVLCC_GAMMA             "OverlayGamma"
#define NV4_REG_OVLCC_SHARPNESS         "OverlaySharpness"

#define NV4_REG_OVLCC_BRIGHTNESS_DEFAULT  0
#define NV4_REG_OVLCC_CONTRAST_DEFAULT    100
#define NV4_REG_OVLCC_HUE_DEFAULT         0
#define NV4_REG_OVLCC_SATURATION_DEFAULT  100

// VideoBusMasterMode (default = 0)
//      Determine which hacks to implement for bus mastering TV tuners (will not work on WINNT)
//      0 = No special hacks
//      1 = If no flips detected and 1 overlay surface, force into autoflip mode
//      2 = If 1 overlay surface, force autoflip
//      3 = Force autoflip
#define NV4_REG_VIDEO_BUS_MASTER_MODE   "VideoBusMasterMode"
#define   NV4_REG_VBMM_NOHACK           0
#define   NV4_REG_VBMM_DETECT           1
#define   NV4_REG_VBMM_SINGLEOVL        2
#define   NV4_REG_VBMM_FORCE            3

//-----------------------------------------------------------------------------
// Direct3D
//-----------------------------------------------------------------------------

// To add registry settings:
// 1. choose a category:
//    boolean, enumerated non-boolean, non-enumerated non-boolean, or string
// 2. add definitions as required for that category. make sure to include a definition
//    for the default value (and PLEASE ALPHABETIZE and use the same ordering for ALL
//    OF WHAT FOLLOWS!)
// 3. add a reg_entry to the definition of reg_struc in global.h
// 4. add the string to the initialization of reg_struc in global.cpp
// 5. add the default value to the initializations at the top of D3DReadRegistry()
// 6. add a routine to actually read and cache the registry value in D3DReadRegistry()

// ------------ Boolean enables / disables ------------------------------------

// Each boolean enable gets one bit in a control word.
#define D3D_REG_BIT_ALTERNATEZENABLE                    0
#define D3D_REG_BIT_ANTIALIASENABLE                     1
#define D3D_REG_BIT_ANTIALIASDYNAMICENABLE              2
#define D3D_REG_BIT_ANTIALIASFORCEENABLE                3
#define D3D_REG_BIT_ANTIALIASCONVOLUTIONFASTMODE        4
#define D3D_REG_BIT_CKCOMPATABILITYENABLE               5
#define D3D_REG_BIT_CONTROLTRAFFICENABLE                6
// unused                       7
#define D3D_REG_BIT_DIRECTMAPENABLE                     8
// unused                       9
#define D3D_REG_BIT_ENFORCESTRICTTRILINEAR              10
// unused                       11
#define D3D_REG_BIT_FLUSHAFTERBLITENABLE                12
#define D3D_REG_BIT_FOGTABLEENABLE                      13
#define D3D_REG_BIT_FORCEBLITWAITFLAGENABLE             14
#define D3D_REG_BIT_LIMITQUEUEDFBBLITSENABLE            15
// unused                       16
#define D3D_REG_BIT_LOGOENABLE                          17
#ifdef TEXFORMAT_CRD
// unused                       18
#else
#define D3D_REG_BIT_PALETTEENABLE                       18
#endif
#define D3D_REG_BIT_SQUASHWENABLE                       19
#define D3D_REG_BIT_SSYNCENABLE                         20
#ifdef TEXFORMAT_CRD
// unused                       21
#else
#define D3D_REG_BIT_TEXTURECOMPRESSIONENABLE            21
#endif
// unused                       22
#define D3D_REG_BIT_TEXTUREMANAGEMENTENABLE             23
#define D3D_REG_BIT_TILINGENABLE                        24
#define D3D_REG_BIT_ZCULLENABLE                         25
#define D3D_REG_BIT_USERMIPMAPENABLE                    26
#define D3D_REG_BIT_VIDEOTEXTUREENABLE                  27
#define D3D_REG_BIT_VS_HOS_EMULATION                    28
#define D3D_REG_BIT_WBUFFERENABLE                       29
#define D3D_REG_BIT_Z24ENABLE                           30
#define D3D_REG_BIT_ZCOMPRESSENABLE                     31

// ALTERNATEZENABLE
#define D3D_REG_ALTERNATEZENABLE_STRING                 "ALTERNATEZENABLE"
#define D3D_REG_ALTERNATEZENABLE_MASK                   (1 << D3D_REG_BIT_ALTERNATEZENABLE)
#define D3D_REG_ALTERNATEZENABLE_DISABLE                (0 << D3D_REG_BIT_ALTERNATEZENABLE)
#define D3D_REG_ALTERNATEZENABLE_ENABLE                 (1 << D3D_REG_BIT_ALTERNATEZENABLE)

// ANTIALIASENABLE
#define D3D_REG_ANTIALIASENABLE_STRING                  "ANTIALIASENABLE"
#define D3D_REG_ANTIALIASENABLE_MASK                    (1 << D3D_REG_BIT_ANTIALIASENABLE)         // Enable Anti-Aliasing support.
#define D3D_REG_ANTIALIASENABLE_DISABLE                 (0 << D3D_REG_BIT_ANTIALIASENABLE)         // Disable Anti-Aliasing support.
#define D3D_REG_ANTIALIASENABLE_ENABLE                  (1 << D3D_REG_BIT_ANTIALIASENABLE)         // Enable Anti-Aliasing support.

// ANTIALIASDYNAMICENABLE
#define D3D_REG_ANTIALIASDYNAMICENABLE_STRING           "ANTIALIASDYNAMICENABLE"
#define D3D_REG_ANTIALIASDYNAMICENABLE_MASK             (1 << D3D_REG_BIT_ANTIALIASDYNAMICENABLE)  // Enable Dynamic Anti-Aliasing support.
#define D3D_REG_ANTIALIASDYNAMICENABLE_DISABLE          (0 << D3D_REG_BIT_ANTIALIASDYNAMICENABLE)  // Disable Dynamic Anti-Aliasing support.
#define D3D_REG_ANTIALIASDYNAMICENABLE_ENABLE           (1 << D3D_REG_BIT_ANTIALIASDYNAMICENABLE)  // Enable Dynamic Anti-Aliasing support.

// ANTIALIASFORCEENABLE
#define D3D_REG_ANTIALIASFORCEENABLE_STRING             "ANTIALIASFORCEENABLE"
#define D3D_REG_ANTIALIASFORCEENABLE_MASK               (1 << D3D_REG_BIT_ANTIALIASFORCEENABLE)
#define D3D_REG_ANTIALIASFORCEENABLE_DISABLE            (0 << D3D_REG_BIT_ANTIALIASFORCEENABLE)
#define D3D_REG_ANTIALIASFORCEENABLE_ENABLE             (1 << D3D_REG_BIT_ANTIALIASFORCEENABLE)

// ANTIALIASCONVOLUTIONFASTMODE
#define D3D_REG_ANTIALIASCONVOLUTIONFASTMODE_STRING     "ANTIALIASCONVOLUTIONFASTMODE"
#define D3D_REG_ANTIALIASCONVOLUTIONFASTMODE_MASK       (1 << D3D_REG_BIT_ANTIALIASCONVOLUTIONFASTMODE)
#define D3D_REG_ANTIALIASCONVOLUTIONFASTMODE_DISABLE    (0 << D3D_REG_BIT_ANTIALIASCONVOLUTIONFASTMODE)
#define D3D_REG_ANTIALIASCONVOLUTIONFASTMODE_ENABLE     (1 << D3D_REG_BIT_ANTIALIASCONVOLUTIONFASTMODE)

// COLORKEYCOMPATIBILITYENABLE
#define D3D_REG_CKCOMPATABILITYENABLE_STRING            "COLORKEYCOMPATABILITYENABLE"
#define D3D_REG_CKCOMPATABILITYENABLE_MASK              (1 << D3D_REG_BIT_CKCOMPATABILITYENABLE)
#define D3D_REG_CKCOMPATABILITYENABLE_DISABLE           (0 << D3D_REG_BIT_CKCOMPATABILITYENABLE)
#define D3D_REG_CKCOMPATABILITYENABLE_ENABLE            (1 << D3D_REG_BIT_CKCOMPATABILITYENABLE)

// CONTROLTRAFFIC
#define D3D_REG_CONTROLTRAFFICENABLE_STRING             "CONTROLTRAFFIC"
#define D3D_REG_CONTROLTRAFFICENABLE_MASK               (1 << D3D_REG_BIT_CONTROLTRAFFICENABLE)
#define D3D_REG_CONTROLTRAFFICENABLE_DISABLE            (0 << D3D_REG_BIT_CONTROLTRAFFICENABLE)
#define D3D_REG_CONTROLTRAFFICENABLE_ENABLE             (1 << D3D_REG_BIT_CONTROLTRAFFICENABLE)

// DIRECTMAPENABLE
#define D3D_REG_DIRECTMAPENABLE_STRING                  "DIRECTMAPENABLE"
#define D3D_REG_DIRECTMAPENABLE_MASK                    (1 << D3D_REG_BIT_DIRECTMAPENABLE)
#define D3D_REG_DIRECTMAPENABLE_DISABLE                 (0 << D3D_REG_BIT_DIRECTMAPENABLE)
#define D3D_REG_DIRECTMAPENABLE_ENABLE                  (1 << D3D_REG_BIT_DIRECTMAPENABLE)

// ENFORCESTRICTTRILINEAR
#define D3D_REG_ENFORCESTRICTTRILINEAR_STRING           "ENFORCESTRICTTRILINEAR"
#define D3D_REG_ENFORCESTRICTTRILINEAR_MASK             (1 << D3D_REG_BIT_ENFORCESTRICTTRILINEAR)
#define D3D_REG_ENFORCESTRICTTRILINEAR_DISABLE          (0 << D3D_REG_BIT_ENFORCESTRICTTRILINEAR)
#define D3D_REG_ENFORCESTRICTTRILINEAR_ENABLE           (1 << D3D_REG_BIT_ENFORCESTRICTTRILINEAR)

// FLUSHAFTERBLITENABLE
#define D3D_REG_FLUSHAFTERBLITENABLE_STRING             "FLUSHAFTERBLITENABLE"
#define D3D_REG_FLUSHAFTERBLITENABLE_MASK               (1 << D3D_REG_BIT_FLUSHAFTERBLITENABLE)
#define D3D_REG_FLUSHAFTERBLITENABLE_DISABLE            (0 << D3D_REG_BIT_FLUSHAFTERBLITENABLE)
#define D3D_REG_FLUSHAFTERBLITENABLE_ENABLE             (1 << D3D_REG_BIT_FLUSHAFTERBLITENABLE)

// FOGTABLEENABLE
#define D3D_REG_FOGTABLEENABLE_STRING                   "FOGTABLEENABLE"
#define D3D_REG_FOGTABLEENABLE_MASK                     (1 << D3D_REG_BIT_FOGTABLEENABLE)       // Enable Fog Table support
#define D3D_REG_FOGTABLEENABLE_DISABLE                  (0 << D3D_REG_BIT_FOGTABLEENABLE)       // Disable Fog Table support.
#define D3D_REG_FOGTABLEENABLE_ENABLE                   (1 << D3D_REG_BIT_FOGTABLEENABLE)       // Enable Fog Table support

// FORCEBLITWAITFLAGENABLE
#define D3D_REG_FORCEBLITWAITFLAGENABLE_STRING          "FORCEBLITWAITFLAGENABLE"
#define D3D_REG_FORCEBLITWAITFLAGENABLE_MASK            (1 << D3D_REG_BIT_FORCEBLITWAITFLAGENABLE)
#define D3D_REG_FORCEBLITWAITFLAGENABLE_DISABLE         (0 << D3D_REG_BIT_FORCEBLITWAITFLAGENABLE)
#define D3D_REG_FORCEBLITWAITFLAGENABLE_ENABLE          (1 << D3D_REG_BIT_FORCEBLITWAITFLAGENABLE)

// LIMITQUEUEDFBBLITSENABLE
#define D3D_REG_LIMITQUEUEDFBBLITSENABLE_STRING         "LIMITQUEUEDFBBLITSENABLE"
#define D3D_REG_LIMITQUEUEDFBBLITSENABLE_MASK           (1 << D3D_REG_BIT_LIMITQUEUEDFBBLITSENABLE)
#define D3D_REG_LIMITQUEUEDFBBLITSENABLE_DISABLE        (0 << D3D_REG_BIT_LIMITQUEUEDFBBLITSENABLE)
#define D3D_REG_LIMITQUEUEDFBBLITSENABLE_ENABLE         (1 << D3D_REG_BIT_LIMITQUEUEDFBBLITSENABLE)

// LOGOENABLE
#define D3D_REG_LOGOENABLE_STRING                       "LOGOENABLE"
#define D3D_REG_LOGOENABLE_MASK                         (1 << D3D_REG_BIT_LOGOENABLE)            // Enable NVIDIA logo
#define D3D_REG_LOGOENABLE_DISABLE                      (0 << D3D_REG_BIT_LOGOENABLE)            // Disable NVIDIA logo
#define D3D_REG_LOGOENABLE_ENABLE                       (1 << D3D_REG_BIT_LOGOENABLE)            // Enable NVIDIA logo

#ifndef TEXFORMAT_CRD
// PALETTEENABLE
#define D3D_REG_PALETTEENABLE_STRING                    "PALETTEENABLE"
#define D3D_REG_PALETTEENABLE_MASK                      (1 << D3D_REG_BIT_PALETTEENABLE)
#define D3D_REG_PALETTEENABLE_DISABLE                   (0 << D3D_REG_BIT_PALETTEENABLE)
#define D3D_REG_PALETTEENABLE_ENABLE                    (1 << D3D_REG_BIT_PALETTEENABLE)
#endif

// SQUASHW
#define D3D_REG_SQUASHW_STRING                          "SQUASHW"
#define D3D_REG_SQUASHW_MASK                            (1 << D3D_REG_BIT_SQUASHWENABLE)
#define D3D_REG_SQUASHW_DISABLE                         (0 << D3D_REG_BIT_SQUASHWENABLE)
#define D3D_REG_SQUASHW_ENABLE                          (1 << D3D_REG_BIT_SQUASHWENABLE)

// SSYNCENABLE
// This is a major hack to work around input lag in stupid applications that
// want to use blits instead of flips to do there screen updates but then don't
// make any getblitstatus calls to see if the blit has completed before beginning
// to render the next frame.
// This is not something that you want to have enabled unless you absolutely need
// to have it enabled.
#define D3D_REG_SSYNCENABLE_STRING                      "SCENESYNCENABLE"
#define D3D_REG_SSYNCENABLE_MASK                        (1 << D3D_REG_BIT_SSYNCENABLE)
#define D3D_REG_SSYNCENABLE_DISABLE                     (0 << D3D_REG_BIT_SSYNCENABLE)
#define D3D_REG_SSYNCENABLE_ENABLE                      (1 << D3D_REG_BIT_SSYNCENABLE)

#ifndef TEXFORMAT_CRD
// TEXTURECOMPRESSIONENABLE
#define D3D_REG_TEXTURECOMPRESSIONENABLE_STRING         "TEXTURECOMPRESSIONENABLE"
#define D3D_REG_TEXTURECOMPRESSIONENABLE_MASK           (1 << D3D_REG_BIT_TEXTURECOMPRESSIONENABLE)
#define D3D_REG_TEXTURECOMPRESSIONENABLE_DISABLE        (0 << D3D_REG_BIT_TEXTURECOMPRESSIONENABLE)
#define D3D_REG_TEXTURECOMPRESSIONENABLE_ENABLE         (1 << D3D_REG_BIT_TEXTURECOMPRESSIONENABLE)
#endif

// TEXTUREMANAGEMENTENABLE
#define D3D_REG_TEXTUREMANAGEMENTENABLE_STRING          "TEXTUREMANAGEMENTENABLE"
#define D3D_REG_TEXTUREMANAGEMENTENABLE_MASK            (1 << D3D_REG_BIT_TEXTUREMANAGEMENTENABLE)
#define D3D_REG_TEXTUREMANAGEMENTENABLE_DISABLE         (0 << D3D_REG_BIT_TEXTUREMANAGEMENTENABLE)
#define D3D_REG_TEXTUREMANAGEMENTENABLE_ENABLE          (1 << D3D_REG_BIT_TEXTUREMANAGEMENTENABLE)

// TILINGENABLE
#define D3D_REG_TILINGENABLE_STRING                     "TILINGENABLE"
#define D3D_REG_TILINGENABLE_MASK                       (1 << D3D_REG_BIT_TILINGENABLE)
#define D3D_REG_TILINGENABLE_DISABLE                    (0 << D3D_REG_BIT_TILINGENABLE)
#define D3D_REG_TILINGENABLE_ENABLE                     (1 << D3D_REG_BIT_TILINGENABLE)

// ZCULLENABLE
#define D3D_REG_ZCULLENABLE_STRING                      "ZCULLENABLE"
#define D3D_REG_ZCULLENABLE_MASK                        (1 << D3D_REG_BIT_ZCULLENABLE)
#define D3D_REG_ZCULLENABLE_DISABLE                     (0 << D3D_REG_BIT_ZCULLENABLE)
#define D3D_REG_ZCULLENABLE_ENABLE                      (1 << D3D_REG_BIT_ZCULLENABLE)

// USERMIPMAPENABLE - enable User supplied mipmaps
#define D3D_REG_USERMIPMAPENABLE_STRING                 "USERMIPMAPENABLE"
#define D3D_REG_USERMIPMAPENABLE_MASK                   (1 << D3D_REG_BIT_USERMIPMAPENABLE)
#define D3D_REG_USERMIPMAPENABLE_DISABLE                (0 << D3D_REG_BIT_USERMIPMAPENABLE)
#define D3D_REG_USERMIPMAPENABLE_ENABLE                 (1 << D3D_REG_BIT_USERMIPMAPENABLE)

// VIDEOTEXTUREENABLE - enable texturing from video memory
#define D3D_REG_VIDEOTEXTUREENABLE_STRING               "VIDEOTEXTUREENABLE"
#define D3D_REG_VIDEOTEXTUREENABLE_MASK                 (1 << D3D_REG_BIT_VIDEOTEXTUREENABLE)
#define D3D_REG_VIDEOTEXTUREENABLE_DISABLE              (0 << D3D_REG_BIT_VIDEOTEXTUREENABLE)
#define D3D_REG_VIDEOTEXTUREENABLE_ENABLE               (1 << D3D_REG_BIT_VIDEOTEXTUREENABLE)

// VertexShader/Higher order surface emulation for NV10/NV15 class parts
#define D3D_REG_BIT_VS_HOS_EMULATION                    28
#define D3D_REG_VS_HOS_EMULATION_STRING                 "VS_HOS_EMULATION"
#define D3D_REG_VS_HOS_EMULATION_MASK                   (1 << D3D_REG_BIT_VS_HOS_EMULATION)
#define D3D_REG_VS_HOS_EMULATION_DISABLE                (0 << D3D_REG_BIT_VS_HOS_EMULATION)
#define D3D_REG_VS_HOS_EMULATION_ENABLE                 (1 << D3D_REG_BIT_VS_HOS_EMULATION)

// WBUFFERING
#define D3D_REG_WBUFFERENABLE_STRING                    "WENABLE"
#define D3D_REG_WBUFFERENABLE_MASK                      (1 << D3D_REG_BIT_WBUFFERENABLE)
#define D3D_REG_WBUFFERENABLE_DISABLE                   (0 << D3D_REG_BIT_WBUFFERENABLE)
#define D3D_REG_WBUFFERENABLE_ENABLE                    (1 << D3D_REG_BIT_WBUFFERENABLE)

// Z24ENABLE
#define D3D_REG_Z24ENABLE_STRING                        "Z24ENABLE"
#define D3D_REG_Z24ENABLE_MASK                          (1 << D3D_REG_BIT_Z24ENABLE)
#define D3D_REG_Z24ENABLE_DISABLE                       (0 << D3D_REG_BIT_Z24ENABLE)
#define D3D_REG_Z24ENABLE_ENABLE                        (1 << D3D_REG_BIT_Z24ENABLE)

// ZCOMPRESSENABLE
#define D3D_REG_ZCOMPRESSENABLE_STRING                  "ZCOMPRESSENABLE"
#define D3D_REG_ZCOMPRESSENABLE_MASK                    (1 << D3D_REG_BIT_ZCOMPRESSENABLE)
#define D3D_REG_ZCOMPRESSENABLE_DISABLE                 (0 << D3D_REG_BIT_ZCOMPRESSENABLE)
#define D3D_REG_ZCOMPRESSENABLE_ENABLE                  (1 << D3D_REG_BIT_ZCOMPRESSENABLE)

//// not currently in use - rel6 maybe?
// ANTIALIASENABLE
#define D3D_REG_ANTIALIASDYNAMICENABLE_STRING           "ANTIALIASDYNAMICENABLE"
#define D3D_REG_ANTIALIASDYNAMICENABLE_MASK             (1 << D3D_REG_BIT_ANTIALIASDYNAMICENABLE)         // Enable Dynamic Anti-Aliasing support.
#define D3D_REG_ANTIALIASDYNAMICENABLE_DISABLE          (0 << D3D_REG_BIT_ANTIALIASDYNAMICENABLE)         // Disable Dynamic Anti-Aliasing support.
#define D3D_REG_ANTIALIASDYNAMICENABLE_ENABLE           (1 << D3D_REG_BIT_ANTIALIASDYNAMICENABLE)         // Enable Dynamic Anti-Aliasing support.

// Default values for registry configurable driver settings.
#define D3D_REG_DEFAULT_ALTERNATEZENABLE                D3D_REG_ALTERNATEZENABLE_DISABLE
#define D3D_REG_DEFAULT_ANTIALIASENABLE                 D3D_REG_ANTIALIASENABLE_ENABLE            // enable Anti Aliasing.
#define D3D_REG_DEFAULT_ANTIALIASDYNAMICENABLE          D3D_REG_ANTIALIASDYNAMICENABLE_ENABLE     // enable dynamic Anti Aliasing.
#define D3D_REG_DEFAULT_ANTIALIASFORCEENABLE            D3D_REG_ANTIALIASFORCEENABLE_DISABLE      // Disable forced Anti Aliasing.
#define D3D_REG_DEFAULT_ANTIALIASCONVOLUTIONFASTMODE    D3D_REG_ANTIALIASCONVOLUTIONFASTMODE_DISABLE // Disable the fast mode for 5x and 9x AA by default
#define D3D_REG_DEFAULT_CKCOMPATABILITYENABLE           D3D_REG_CKCOMPATABILITYENABLE_ENABLE      // Perform application colorkey fixups.
#define D3D_REG_DEFAULT_CONTROLTRAFFICENABLE            D3D_REG_CONTROLTRAFFICENABLE_ENABLE
#define D3D_REG_DEFAULT_DIRECTMAPENABLE                 D3D_REG_DIRECTMAPENABLE_ENABLE            // Enable Direct Mapping of Texture Combiners by default.
#define D3D_REG_DEFAULT_ENFORCESTRICTTRILINEAR          D3D_REG_ENFORCESTRICTTRILINEAR_ENABLE     // Enforces multitexture-trilinear ot NOT use dithering approximation
#define D3D_REG_DEFAULT_FLUSHAFTERBLITENABLE            D3D_REG_FLUSHAFTERBLITENABLE_DISABLE      // Disable flush after blit on wait flag
#define D3D_REG_DEFAULT_FOGTABLEENABLE                  D3D_REG_FOGTABLEENABLE_ENABLE             // Enable software implemented fog table support.
#define D3D_REG_DEFAULT_FORCEBLITWAITFLAGENABLE         D3D_REG_FORCEBLITWAITFLAGENABLE_DISABLE   // Disable force the BLT_WAIT flag
#define D3D_REG_DEFAULT_LIMITQUEUEDFBBLITSENABLE        D3D_REG_LIMITQUEUEDFBBLITSENABLE_DISABLE  // Disable limiting the max number of queued FB blits
#define D3D_REG_DEFAULT_LOGOENABLE                      D3D_REG_LOGOENABLE_DISABLE
#ifndef TEXFORMAT_CRD
#define D3D_REG_DEFAULT_PALETTEENABLE                   D3D_REG_PALETTEENABLE_ENABLE              // Enable 8-bit textures (relevant only >=DX8. always disabled for <=DX7)
#endif
#define D3D_REG_DEFAULT_SQUASHW                         D3D_REG_SQUASHW_DISABLE
#define D3D_REG_DEFAULT_SSYNCENABLE                     D3D_REG_SSYNCENABLE_DISABLE               // MAJOR APP HACK should never be enbled by default!!
#ifndef TEXFORMAT_CRD
#define D3D_REG_DEFAULT_TEXTURECOMPRESSIONENABLE        D3D_REG_TEXTURECOMPRESSIONENABLE_ENABLE   // Enable Texture compression so we can 'disable' for badly behaving apps
#endif
#define D3D_REG_DEFAULT_TEXTUREMANAGEMENTENABLE         D3D_REG_TEXTUREMANAGEMENTENABLE_ENABLE    // enable driver-based texture management
#define D3D_REG_DEFAULT_TILINGENABLE                    D3D_REG_TILINGENABLE_ENABLE
#define D3D_REG_DEFAULT_ZCULLENABLE                     D3D_REG_ZCULLENABLE_ENABLE                // Enable z occlusion culling by default (applicable to nv20 ff.)
#define D3D_REG_DEFAULT_USERMIPMAPENABLE                D3D_REG_USERMIPMAPENABLE_ENABLE           // Enable use of user supplied mip maps
#define D3D_REG_DEFAULT_VIDEOTEXTUREENABLE              D3D_REG_VIDEOTEXTUREENABLE_ENABLE         // Enable texturing from video memory
#define D3D_REG_DEFAULT_WBUFFERENABLE                   D3D_REG_WBUFFERENABLE_ENABLE
#define D3D_REG_DEFAULT_Z24ENABLE                       D3D_REG_Z24ENABLE_ENABLE                  // Enable 24bit z-exports by default
#define D3D_REG_DEFAULT_ZCOMPRESSENABLE                 D3D_REG_ZCOMPRESSENABLE_ENABLE            // Enable z compression by default (applicable to nv20 ff.)

// ----------- Non-boolean settings with enumerated values ------------------

// AntiAliasQuality definitions.
#define D3D_REG_ANTIALIASQUALITY_STRING                 "ANTIALIASQUALITY"
#define D3D_REG_ANTIALIASQUALITY_MIN                    0
#define D3D_REG_ANTIALIASQUALITY_MAX                    7

//// not currently in use - rel6 maybe?
// AntiAliasDynamicFPS definitions.
#define D3D_REG_ANTIALIASDYNAMICFPS_STRING              "ANTIALIASDYNAMICFPS"
#define D3D_REG_ANTIALIASDYNAMICFPS_MIN                 10
#define D3D_REG_ANTIALIASDYNAMICFPS_MAX                 500

// CAPTURE CONFIG
#define D3D_REG_CAPTURECONFIG_STRING                    "CAPTURECONFIG"
#define D3D_REG_CAPTURECONFIG_ALLOC4X                   0x01
#define D3D_REG_CAPTURECONFIG_FORCEPCI                  0x02

// CAPTUREENABLE
#define D3D_REG_CAPTUREENABLE_STRING                    "CAPTUREENABLE"
#define D3D_REG_CAPTUREENABLE_DISABLE                   0x00
#define D3D_REG_CAPTUREENABLE_RECORD                    0x01
#define D3D_REG_CAPTUREENABLE_PLAY                      0x02

// Colorkey Reference Values range.
#define D3D_REG_CKREF_STRING                            "CKREF"
#define D3D_REG_CKREF_MIN                               0x00
#define D3D_REG_CKREF_MAX                               0x7F

// Force Anisotropic definitions.
#define D3D_REG_ANISOTROPICLEVEL_STRING                 "ANISOTROPICLEVEL"
#define D3D_REG_ANISOTROPICLEVEL_PASSIVE                0xFFFFFFFF  // do what the app wants (else force to the value specified)

// MipMapDitherEnable definitions.
#define D3D_REG_MIPMAPDITHERMODE_STRING                 "ANISOTROPIC4TAP"
#define D3D_REG_MIPMAPDITHERMODE_DISABLE                0           // Disable mipmap dithering (true trilinear)
#define D3D_REG_MIPMAPDITHERMODE_ENABLE                 1           // Enable mipmap dithering (fake trilinear)
#define D3D_REG_MIPMAPDITHERMODE_SMART                  2           // smart dithering (enabled at higher resolutions)
#define D3D_REG_MIPMAPDITHERMODE_MAX                    2

#ifdef TEXFORMAT_CRD
// surface formats exported
#define D3D_REG_SURFACEFORMATSDX7_STRING                "SURFACEFORMATSDX7"
#define D3D_REG_SURFACEFORMATSDX8_STRING                "SURFACEFORMATSDX8"
#define D3D_REG_SURFACEFORMATS_BASIC                    0x00000001
#define D3D_REG_SURFACEFORMATS_BUMPMAP                  0x00000002
#define D3D_REG_SURFACEFORMATS_DXT                      0x00000004
#define D3D_REG_SURFACEFORMATS_PALETTIZED               0x00000008
#define D3D_REG_SURFACEFORMATS_NVXN                     0x00000010
#define D3D_REG_SURFACEFORMATS_HILO                     0x00000020
#define D3D_REG_SURFACEFORMATS_ZETA                     0x00000040
#define D3D_REG_SURFACEFORMATS_MISC                     0x00000080
#endif  // TEXFORMAT_CRD

// TexelAlignment definitions.
// Bit flags (bit 0 = ZOH, bit 1 = FOH, bit 2 = Texel Origin)
#define D3D_REG_TEXELALIGNMENT_STRING                   "TEXELALIGNMENT"
#define D3D_REG_TEXELALIGNMENT_ZOH_CENTER               0x00
#define D3D_REG_TEXELALIGNMENT_ZOH_CORNER               0x01
#define D3D_REG_TEXELALIGNMENT_ZOH_MASK                 0x01
#define D3D_REG_TEXELALIGNMENT_FOH_CENTER               0x00
#define D3D_REG_TEXELALIGNMENT_FOH_CORNER               0x02
#define D3D_REG_TEXELALIGNMENT_FOH_MASK                 0x02
#define D3D_REG_TEXELALIGNMENT_TEXEL_CENTER             0x00
#define D3D_REG_TEXELALIGNMENT_TEXEL_CORNER             0x04
#define D3D_REG_TEXELALIGNMENT_TEXEL_MASK               0x04
#define D3D_REG_TEXELALIGNMENT_MAX                      0x07

// TEXTUREMANAGESTRATEGY
#define D3D_REG_TEXTUREMANAGESTRATEGY_STRING            "TEXTUREMANAGESTRATEGY"
#define D3D_REG_TEXTUREMANAGESTRATEGY_AGGRESSIVE        0x1
#define D3D_REG_TEXTUREMANAGESTRATEGY_LAZY              0x0

// ValidateZMethod definitions.
#define D3D_REG_VALIDATEZMETHOD_STRING                  "VALIDATEZMETHOD"
#define D3D_REG_VALIDATEZMETHOD_FLEXIBLE                0           // Driver will match z-buffer to rendering depth.
#define D3D_REG_VALIDATEZMETHOD_SRTRETURNNOTHANDLED     1           // Same as FLEXIBLE but returns NOTHANDLED from Set Render Target.
#define D3D_REG_VALIDATEZMETHOD_STRICT                  2           // Z-Buffer must always match rendering depth.
#define D3D_REG_VALIDATEZMETHOD_MIXED                   3           // DX6 applications = STRICT, DX5 applications = flexible
#define D3D_REG_VALIDATEZMETHOD_MAX                     3

// V-Sync modes
#define D3D_REG_VSYNCMODE_STRING                        "VSYNCMODE"
#define D3D_REG_VSYNCMODE_PASSIVE                       0           // just do what the app tells us to do
#define D3D_REG_VSYNCMODE_FORCEOFF                      1           // override app and don't vsync
#define D3D_REG_VSYNCMODE_FORCEON                       2           // override app and vsync
#define D3D_REG_VSYNCMODE_MAX                           2

// WFormat definitions.
#define D3D_REG_WFORMAT16_STRING                        "W16FORMAT"
#define D3D_REG_WFORMAT32_STRING                        "W32FORMAT"
#define D3D_REG_WFORMAT_FIXED                           0x1
#define D3D_REG_WFORMAT_FLOAT                           0x2
#define D3D_REG_WFORMAT_MIN                             0x1
#define D3D_REG_WFORMAT_MAX                             0x2

// defaults for the non-boolean enumerated values
#define D3D_REG_DEFAULT_CAPTURCONFIG                    (D3D_REG_CAPTURECONFIG_ALLOC4X | D3D_REG_CAPTURECONFIG_FORCEPCI)
#define D3D_REG_DEFAULT_CAPTURENABLE                    D3D_REG_CAPTUREENABLE_RECORD
#define D3D_REG_DEFAULT_ANISOTROPICLEVEL                D3D_REG_ANISOTROPICLEVEL_PASSIVE
#define D3D_REG_DEFAULT_MIPMAPDITHERMODE                D3D_REG_MIPMAPDITHERMODE_SMART          // use true trilinear sometimes
#ifdef TEXFORMAT_CRD
#define D3D_REG_DEFAULT_SURFACEFORMATSDX7               (D3D_REG_SURFACEFORMATS_BASIC | D3D_REG_SURFACEFORMATS_BUMPMAP    |  \
                                                         D3D_REG_SURFACEFORMATS_DXT   | D3D_REG_SURFACEFORMATS_PALETTIZED |  \
                                                         D3D_REG_SURFACEFORMATS_ZETA  | D3D_REG_SURFACEFORMATS_MISC)
#define D3D_REG_DEFAULT_SURFACEFORMATSDX8               (D3D_REG_SURFACEFORMATS_BASIC | D3D_REG_SURFACEFORMATS_BUMPMAP    |  \
                                                         D3D_REG_SURFACEFORMATS_DXT   | D3D_REG_SURFACEFORMATS_PALETTIZED |  \
                                                         D3D_REG_SURFACEFORMATS_NVXN  | D3D_REG_SURFACEFORMATS_HILO       |  \
                                                         D3D_REG_SURFACEFORMATS_ZETA  | D3D_REG_SURFACEFORMATS_MISC)
#endif  // TEXFORMAT_CRD
#define D3D_REG_DEFAULT_TEXELALIGNMENT                  (D3D_REG_TEXELALIGNMENT_ZOH_CORNER | D3D_REG_TEXELALIGNMENT_FOH_CORNER | D3D_REG_TEXELALIGNMENT_TEXEL_CENTER)
#define D3D_REG_DEFAULT_TEXTUREMANAGESTRATEGY           D3D_REG_TEXTUREMANAGESTRATEGY_AGGRESSIVE
#define D3D_REG_DEFAULT_VALIDATEZMETHOD                 D3D_REG_VALIDATEZMETHOD_FLEXIBLE        // D3D_REG_VALIDATEZMETHOD_MIXED
#define D3D_REG_DEFAULT_VSYNCMODE                       D3D_REG_VSYNCMODE_PASSIVE
#define D3D_REG_DEFAULT_W16FORMAT                       D3D_REG_WFORMAT_FIXED
#define D3D_REG_DEFAULT_W32FORMAT                       D3D_REG_WFORMAT_FLOAT

// ------- Non-boolean settings with non-enumerated values ------------------

// NOT of address of pointer to command-line string
#define D3D_REG_AACOMPATIBILITYBITS_STRING              "AACOMPATIBILITYBITS"

// Reads nvCelsiusAACompatibility.h
#define D3D_REG_AAREADCOMPATIBILITYFILE_STRING          "AAREADCOMPATIBILITYFILE"

// AntiAliasQuality definitions.
#define D3D_REG_ANTIALIASQUALITY_STRING                 "ANTIALIASQUALITY"
#define D3D_REG_ANTIALIASQUALITY_MIN                    0
#define D3D_REG_ANTIALIASQUALITY_MAX                    7

// AntiAliasDynamicFPS definitions.
#define D3D_REG_ANTIALIASDYNAMICFPS_STRING              "ANTIALIASDYNAMICFPS"
#define D3D_REG_ANTIALIASDYNAMICFPS_MIN                 10
#define D3D_REG_ANTIALIASDYNAMICFPS_MAX                 500

// AGP texture cutoff
#define D3D_REG_AGPTEXCUTOFF_STRING                     "AGPTEXCUTOFF"

// starting number for played capture files
#define D3D_REG_CAPTUREPLAYFILENUM_STRING               "CAPTUREPLAYFILENUM"

// starting number for recorded capture files
#define D3D_REG_CAPTURERECORDFILENUM_STRING             "CAPTURERECORDFILENUM"

// Colorkey Reference Values range.
#define D3D_REG_CKREF_STRING                            "CKREF"
#define D3D_REG_CKREF_MIN                               0x00
#define D3D_REG_CKREF_MAX                               0x7F

// D3D contexts
#define D3D_REG_D3DCONTEXTMAX_STRING                    "D3DCONTEXTMAX"

// D3D contexts
#define D3D_REG_D3DTEXTUREMAX_STRING                    "D3DTEXTUREMAX"

// DPF debug level
#define D3D_REG_DEBUGLEVEL_STRING                       "DEBUGLEVEL"

// LOD bias adjust
#define D3D_REG_LODBIAS_STRING                          "LODBIASADJUST"

// minimum video texture size
#define D3D_REG_MINVIDTEXSIZE_STRING                    "MINVIDEOTEXSIZE"

// size of the pci texture heap. non-zero value will override value determined by the driver
#define D3D_REG_PCITEXHEAPSIZE_STRING                   "PCITEXHEAPSIZE"

// performance strategy
#define D3D_REG_PERFSTRATEGYOR_STRING                   "PSOR"
#define D3D_REG_PERFSTRATEGYAND_STRING                  "PSAND"

// Prerender limits
#define D3D_REG_PRERENDERLIMIT_STRING                   "PRERENDERLIMIT"
#define D3D_REG_PRERENDERLIMIT_MIN                      1
#define D3D_REG_PRERENDERLIMIT_MAX                      1000

// maximum push buffer size
#define D3D_REG_PUSHBUFFERSIZEMAX_STRING                "DMAPUSHBUFFERSIZEMAX"

// WScale 16/24 definitions.
#define D3D_REG_WSCALE16_STRING                         "WSCALE16"
#define D3D_REG_WSCALE24_STRING                         "WSCALE24"
#define D3D_REG_WSCALE16_MAX                            0x00010000
#define D3D_REG_WSCALE24_MAX                            0x01000000

// positively shift z to accomodate apps that give us slightly negtive z
#define D3D_REG_ZBIAS_STRING                            "ZBIAS"

// defaults for the non-boolean, non-enumerated values
#define D3D_REG_DEFAULT_AACOMPATIBILITYBITS             0
#define D3D_REG_DEFAULT_AAREADCOMPATIBILITYFILE         0
#define D3D_REG_DEFAULT_ANTIALIASQUALITY                1
#define D3D_REG_DEFAULT_ANTIALIASDYNAMICFPS             (1000 / 30)
#define D3D_REG_DEFAULT_AGPTEXCUTOFF                    1024
#define D3D_REG_DEFAULT_CAPTUREPLAYFILENUM              0
#define D3D_REG_DEFAULT_CAPTURERECORDFILENUM            0
#define D3D_REG_DEFAULT_CKREF                           D3D_REG_CKREF_MIN
#define D3D_REG_DEFAULT_D3DCONTEXTMAX                   64                  // D3D Context heap allocation max.
#define D3D_REG_DEFAULT_D3DTEXTUREMAX                   1024                // D3D Texture heap allocation max.
#define D3D_REG_DEFAULT_DEBUGLEVEL                      0                   // no debug output
#define D3D_REG_DEFAULT_LODBIASADJUST                   0
#define D3D_REG_DEFAULT_MINVIDEOTEXSIZE                 1                   // minimum texture size to be placed in video memory.
#define D3D_REG_DEFAULT_PCITEXHEAPSIZE                  0                   // size of PCI texture heap. (0 => driver-determined value)
#define D3D_REG_DEFAULT_PRERENDERLIMIT                  3
#define D3D_REG_DEFAULT_PUSHBUFFERSIZEMAX               0x40000             // maximum push buffer size.
#define D3D_REG_DEFAULT_WSCALE16                        D3D_REG_WSCALE16_MAX
#define D3D_REG_DEFAULT_WSCALE24                        D3D_REG_WSCALE24_MAX
#define D3D_REG_DEFAULT_ZBIAS                           0.f

// ------------------------------- Strings ----------------------------------

#define D3D_REG_STRING_LENGTH                           64                  // maximum allowed string length

// push-buffer capture playback file name
#define D3D_REG_CAPTUREPLAYFILENAME_STRING              "CAPTUREPLAYFILENAME"

// push-buffer capture playback path
#define D3D_REG_CAPTUREPLAYPATH_STRING                  "CAPTUREPLAYPATH"

// push-buffer capture recording path
#define D3D_REG_CAPTURERECORDFILENAME_STRING            "CAPTURERECORDFILENAME"

// push-buffer capture recording path
#define D3D_REG_CAPTURERECORDPATH_STRING                "CAPTURERECORDPATH"

// string defaults
#define D3D_REG_DEFAULT_CAPTUREPLAYFILENAME             "capture"
#define D3D_REG_DEFAULT_CAPTUREPLAYPATH                 "c:\\"
#define D3D_REG_DEFAULT_CAPTURERECORDFILENAME           "capture"
#define D3D_REG_DEFAULT_CAPTURERECORDPATH               "c:\\"


//-----------------------------------------------------------------------------
// OpenGL
//-----------------------------------------------------------------------------

#define NV4_REG_OGL_BUFFER_FLIPPING_CONTROL             "FlippingControl"
#define   NV4_REG_OGL_BUFFER_FLIPPING_CONTROL_BLIT      0
#define   NV4_REG_OGL_BUFFER_FLIPPING_CONTROL_FLIP      1
#define   NV4_REG_OGL_BUFFER_FLIPPING_CONTROL_AUTO      2
#define   NV4_REG_OGL_BUFFER_FLIPPING_CONTROL_DEFAULT   NV4_REG_OGL_BUFFER_FLIPPING_CONTROL_AUTO

#define NV_REG_OGL_BUFFER_REGION_EXT                    "BufferRegionExt"
#define   NV_REG_OGL_BUFFER_REGION_EXT_OFF              0
#define   NV_REG_OGL_BUFFER_REGION_EXT_ON               1
#define   NV_REG_OGL_BUFFER_REGION_EXT_DEFAULT          NV_REG_OGL_BUFFER_REGION_EXT_ON

#define NV_REG_OGL_BUFFER_REGION_USE_VIDMEM             "BufferRegionUseVidMem"
#define   NV_REG_OGL_BUFFER_REGION_USE_VIDMEM_OFF       0
#define   NV_REG_OGL_BUFFER_REGION_USE_VIDMEM_ON        1
#define   NV_REG_OGL_BUFFER_REGION_USE_VIDMEM_DEFAULT   NV_REG_OGL_BUFFER_REGION_USE_VIDMEM_ON

#define NV_REG_OGL_DEBUG_RENDERER                       "Renderer"
#define   NV_REG_OGL_DEBUG_RENDERER_NVIDIA              0
#define   NV_REG_OGL_DEBUG_RENDERER_SOFTWARE            1
#define   NV_REG_OGL_DEBUG_RENDERER_MICROSOFT           2
#define   NV_REG_OGL_DEFAULT_DEBUG_RENDERER             NV_REG_OGL_DEBUG_RENDERER_NVIDIA

#define NV_REG_OGL_DEBUG_PMENABLE                       "PMEnable"
#define   NV_REG_OGL_DEBUG_PMENABLE_ENABLED             1
#define   NV_REG_OGL_DEBUG_PMENABLE_DISABLED            0
#define   NV_REG_OGL_DEFAULT_DEBUG_PMENABLE             NV_REG_OGL_DEBUG_PMENABLE_DISABLED

#define NV_REG_OGL_DEFAULT_SWAP_INTERVAL                "DefaultSwapInterval"
#define   NV_REG_OGL_DEFAULT_SWAP_INTERVAL_TEAR         0
#define   NV_REG_OGL_DEFAULT_SWAP_INTERVAL_VSYNC        1
#define   NV_REG_OGL_DEFAULT_SWAP_INTERVAL_DISABLE      0xffffffff
#define   NV_REG_OGL_DEFAULT_SWAP_INTERVAL_DEFAULT      NV_REG_OGL_DEFAULT_SWAP_INTERVAL_VSYNC

#define NV_REG_OGL_MAX_NVACCEL                          "MaxNVACCEL"
#define NV_REG_OGL_DEFAULT_MAX_NVACCEL                  0

#define NV_REG_OGL_NV15_ALINES                          "NV15Alines"
#define   NV_REG_OGL_DEFAULT_NV15_ALINES                0
#define   NV_REG_OGL_NV15_ALINES_ACTUAL                 0
#define   NV_REG_OGL_NV15_ALINES_FORCE                  1
#define   NV_REG_OGL_NV15_ALINES_DISABLE                2

#define NV_REG_OGL_CLIPPED_ALINES                       "77345d17C"
#define   NV_REG_OGL_CLIPPED_ALINES_DEFAULT             0
#define   NV_REG_OGL_CLIPPED_ALINES_ENABLE              1

#define NV_REG_OGL_VERTEX_PROGRAM                       "VertexProgram"
#define   NV_REG_OGL_VERTEX_PROGRAM_OPTIMIZE            0
#define   NV_REG_OGL_VERTEX_PROGRAM_NO_LIVEDEAD         1

#define NV_REG_OGL_VPIPE                                "Vpipe"
#define   NV_REG_OGL_VPIPE_OPTIMIZE                     0
#define   NV_REG_OGL_VPIPE_DISABLE_BATCHED_IMMEDIATE    2
#define   NV_REG_OGL_VPIPE_DISABLE_BATCHED_DLISTS       4
#define   NV_REG_OGL_VPIPE_DISABLE_CDE                  8
#define   NV_REG_OGL_VPIPE_FORCE_GENERIC_CPU            0x0400
#define   NV_REG_OGL_VPIPE_REREAD_REGISTRY_ON_CLEAR     0x8000
#define   NV_REG_OGL_VPIPE_TOGGLE_BATCHING_ON_CLEAR     0x00040000

#define NV_REG_OGL_TRIPLE_BUFFER                        "EnableTripleBuffer"
#define   NV_REG_OGL_TRIPLE_BUFFER_DISABLE              0
#define   NV_REG_OGL_TRIPLE_BUFFER_ENABLE               1
#define   NV_REG_OGL_TRIPLE_BUFFER_DEFAULT              NV_REG_OGL_TRIPLE_BUFFER_DISABLE

#define NV_REG_OGL_WINDOW_FLIPPING                      "EnableWindowFlipping"
#define   NV_REG_OGL_WINDOW_FLIPPING_ENABLE             1
#define   NV_REG_OGL_WINDOW_FLIPPING_DISABLE            0
#define   NV_REG_OGL_WINDOW_FLIPPING_DEFAULT            NV_REG_OGL_WINDOW_FLIPPING_DISABLE
#define   NV_REG_OGL_WINDOW_FLIPPING_DEFAULT_GL         NV_REG_OGL_WINDOW_FLIPPING_ENABLE

#define NV_REG_OGL_OVERLAY_SUPPORT                      "EnableOverlaySupport"
#define NV_REG_OGL_OVERLAY_SUPPORT_OFF                  0
#define NV_REG_OGL_OVERLAY_SUPPORT_ON                   1
#define NV_REG_OGL_OVERLAY_SUPPORT_DEFAULT              NV_REG_OGL_OVERLAY_SUPPORT_OFF

#define NV_REG_OGL_OVERLAY_MERGEBLIT_TIMER_MS           "OverlayMergeBlitTimerMs"
#define NV_REG_OGL_OVERLAY_MERGEBLIT_TIMER_MS_DEFAULT   40 //ms
#define NV_REG_OGL_OVERLAY_MERGEBLIT_TIMER_MS_OFF       0  //0ms => off

#define NV_REG_OGL_STEREO_SUPPORT                       "EnableStereoSupport"
#define NV_REG_OGL_STEREO_SUPPORT_OFF                   0
#define NV_REG_OGL_STEREO_SUPPORT_ON                    1
#define NV_REG_OGL_STEREO_SUPPORT_DEFAULT               NV_REG_OGL_STEREO_SUPPORT_OFF

#define NV_REG_OGL_API_STEREO_MODE                              "APIStereoMode"
#define NV_REG_OGL_API_STEREO_MODE_SHUTTER_GLASSES              0 // stereo through shutter glasses
#define NV_REG_OGL_API_STEREO_MODE_VERTICAL_INTERLACED_RIGHT_0  1 // use vertical interlace monitor, right eye on first column
#define NV_REG_OGL_API_STEREO_MODE_VERTICAL_INTERLACED_LEFT_0   2 // use vertical interlace monitor, left eye on first column
#define NV_REG_OGL_API_STEREO_MODE_TVINVIEW_LEFT_DAC0           3 // use two dacs, dac 0 will show left eye
#define NV_REG_OGL_API_STEREO_MODE_TVINVIEW_RIGHT_DAC0          4 // use two dacs, dac 0 will show right eye
#define NV_REG_OGL_API_STEREO_MODE_DEFAULT                      NV_REG_OGL_API_STEREO_MODE_SHUTTER_GLASSES

// MSchwarzer 9/28/00 these keys are used to enable bundles of bugfixes for special applications
#define NV_REG_OGL_APPLICATION_KEY                      "ApplicationKey"
#define NV_REG_OGL_APPLICATION_KEY_NONE                 0
#define NV_REG_OGL_APPLICATION_KEY_STANDARD             1
#define NV_REG_OGL_APPLICATION_KEY_SOFTIMAGE3D          2
#define NV_REG_OGL_APPLICATION_KEY_3DSMAX               3
#define NV_REG_OGL_APPLICATION_KEY_3DPAINT              4
#define NV_REG_OGL_APPLICATION_KEY_MAYA                 5
#define NV_REG_OGL_APPLICATION_KEY_LIGHTSCAPE           6
#define NV_REG_OGL_APPLICATION_KEY_DEFAULT              NV_REG_OGL_APPLICATION_KEY_NONE

#define NV_REG_OGL_FORCE_16BIT_Z                        "EnableForce16BitZ"
#define NV_REG_OGL_FORCE_16BIT_Z_DISABLE                0
#define NV_REG_OGL_FORCE_16BIT_Z_ENABLE                 1
#define NV_REG_OGL_FORCE_16BIT_Z_DEFAULT                NV_REG_OGL_FORCE_16BIT_Z_DISABLE

#define NV_REG_OGL_SINGLE_BACKDEPTH_BUFFER              "EnableSingleBackDepthBuffer"
#define NV_REG_OGL_SINGLE_BACKDEPTH_DISABLE             0
#define NV_REG_OGL_SINGLE_BACKDEPTH_ENABLE              1
#define NV_REG_OGL_SINGLE_BACKDEPTH_BUFFER_DEFAULT      NV_REG_OGL_SINGLE_BACKDEPTH_DISABLE
#define NV_REG_OGL_SINGLE_BACKDEPTH_BUFFER_DEFAULT_GL   NV_REG_OGL_SINGLE_BACKDEPTH_ENABLE

#define NV_REG_OGL_DMAPUSH_BUFSIZE_WORDS                "CmdBufSizeWords"

#define NV_REG_OGL_DMAPUSH_MIN_PUSH_COUNT               "CmdBufMinWords"

#define NV_REG_OGL_DL_STAGING_BUFFER_SIZE_WORDS         "DLStagingBufferSizeWords"
#define NV_REG_OGL_DL_STAGING_BUFFER_SIZE_WORDS_DEFAULT ((9*1024*1024)/4)

#define NV_REG_OGL_TARGET_FLUSHCOUNT                    "TargetFlushCount"

#define NV_REG_OGL_FORCE_MULTITEX                       "ForceMultiTexture"
#define NV_REG_OGL_DISABLE_MULTITEX                     0
#define NV_REG_OGL_ENABLE_MULTITEX                      1
#define NV_REG_OGL_DEFAULT_MULTITEX                     NV_REG_OGL_ENABLE_MULTITEX

#define NV_REG_OGL_MAX_FRAMES_ALLOWED                   "MaxFramesAllowed"
#define NV_OGL_DEFAULT_MAX_FRAMES_ALLOWED               2
#define NV_MAX_FRAMES_ALLOWED                           10

#define NV_REG_OGL_MAX_TEX_SIZE                         "MaxTexSize"
#define NV_OGL_DEFAULT_MAX_TEX_SIZE                     2048

#define NV_REG_OGL_PCI_TEXHEAP_SIZE                     "MaxPCITexHeapSize"
#define NV_REG_OGL_PCI_TEXHEAP_SIZE_DEFAULT             (5*1024*1024)
#define NV_REG_OGL_PCI_TEXHEAP_SIZE_MAX_NT              (16*1024*1024)

#define NV_REG_MULTI_MONITOR_ADVANCED_ENABLE            "MultiMonAdvEnable"
#define NV_OGL_DEFAULT_MULTI_MONITOR_ADVANCED_ENABLE    0

#define NV_REG_OGL_DEFAULT_LOG_ANISO                    "DefaultLogAniso"
#define NV_REG_OGL_DEFAULT_LOG_ANISO_DEFAULT            0

#define NV_REG_OGL_RENDER_QUALITY_FLAGS                 "RenderQualityFlags"
#define NV_REG_OGL_RENDER_QUALITY_FLAGS_MMDITHER        0x00000001

// XXXmjc delete this flag ASAP!
#define NV_REG_OGL_RENDER_QUALITY_FLAGS_ANISOENABLE     0x00000002

/* Default texel size */
#define NV_REG_OGL_RENDER_QUALITY_FLAGS_TEXBITS_MASK     0x0000000c
#define NV_REG_OGL_RENDER_QUALITY_FLAGS_TEXBITS_AUTO     0x00000000
#define NV_REG_OGL_RENDER_QUALITY_FLAGS_TEXBITS_16       0x00000004
#define NV_REG_OGL_RENDER_QUALITY_FLAGS_TEXBITS_32       0x00000008
#define NV_REG_OGL_RENDER_QUALITY_FLAGS_TEXBITS_RESERVED 0x0000000c

#define NV_REG_OGL_TEX_DIRECT_LOAD                      "TextureDirectLoad"
#define NV_REG_OGL_TEX_DIRECT_LOAD_DISABLE              0
#define NV_REG_OGL_TEX_DIRECT_LOAD_ALLOW                1
#define NV_REG_OGL_TEX_DIRECT_LOAD_FORCE                2
#define NV_REG_OGL_TEX_DIRECT_LOAD_AUTO                 3
#define NV_REG_OGL_TEX_DIRECT_LOAD_DEFAULT              NV_REG_OGL_TEX_DIRECT_LOAD_DISABLE

/* One Minus Depth Buffering */
#define NV_REG_OGL_RENDER_QUALITY_FLAGS_ONE_MINUS_Z     0x00000010

#define NV_REG_OGL_RENDER_QUALITY_FLAGS_DEFAULT         (0)

#define NV_REG_OGL_TEX_MEMORY_SPACE_ENABLES             "TexMemorySpaceEnables"
#define NV_REG_OGL_TEX_MEMORY_SPACE_ENABLES_NONE        0
#define NV_REG_OGL_TEX_MEMORY_SPACE_ENABLES_SYS         1
#define NV_REG_OGL_TEX_MEMORY_SPACE_ENABLES_VID         2
#define NV_REG_OGL_TEX_MEMORY_SPACE_ENABLES_VIDSYS      3
#define NV_REG_OGL_TEX_MEMORY_SPACE_ENABLES_DEFAULT     3

#define NV4_REG_OGL_PALETTED_TEX_IN_VID_MEM             "PalettedTexInVidMem"
#define NV4_REG_OGL_DEFAULT_PALETTED_TEX_IN_VID_MEM     1

#define NV4_REG_OGL_TEX_PRECACHE                        "TexturePrecache"

#define NV4_REG_OGL_TEX_STAGING_BUFFER_SIZE             "TexStagingBufferSize"
#define NV4_REG_OGL_TEX_STAGING_BUFFER_SIZE_DEFAULT     (512*1024)

#define NV4_REG_OGL_TEX_STAGING_BUFFER_MULT_SIZE        "TexStagingBufferMultSize"
#define NV4_REG_OGL_STAGING_BUFFER_MULT_SIZE_DEFAULT    (256*1024)

// XXXmjc delete this key ASAP!
#define NV_REG_OGL_FULLSCENE_ANTIALIASING               "EnableFSAA"
#define NV_REG_OGL_FULLSCENE_ANTIALIASING_ENABLED       1
#define NV_REG_OGL_FULLSCENE_ANTIALIASING_DISABLED      0
#define NV_REG_OGL_FULLSCENE_ANTIALIASING_DEFAULT       NV_REG_OGL_FULLSCENE_ANTIALIASING_DISABLED

// XXXmjc delete this key ASAP!
#define NV_REG_OGL_FSAA_QUALITY                         "FSAAQuality"
#define NV_REG_OGL_FSAA_QUALITY_15x15                   0 // 1.5x1.5
#define NV_REG_OGL_FSAA_QUALITY_2x2_LODBIAS             1
#define NV_REG_OGL_FSAA_QUALITY_2x2                     2
#define NV_REG_OGL_FSAA_QUALITY_DEFAULT                 NV_REG_OGL_FSAA_QUALITY_15x15
#define NV_REG_OGL_FSAA_QUALITY_MAXIMUM                 2 // clamp to [0,this]

/*
** The way this key works has changed dramatically between rel6 and rel7.
** There used to be one key that controlled whether FSAA was on at all,
** and another to determine the quality.  Now, there's just one key.
** NV10 has 4 levels of FSAA (none, 1.5x1.5, 2x2 LOD-bias, 2x2).  NV20
** has 3 levels of FSAA (none, 2x, 4x).  The way each setting is interpreted
** on each chip is as follows:
**
** Setting                            NV10 Meaning            NV20 Meaning
** NV_REG_OGL_FSAA_MODE_NONE          No AA                   No AA
** NV_REG_OGL_FSAA_MODE_2x            Invalid                 2x AA bilinear
** NV_REG_OGL_FSAA_MODE_2x_5t         Invalid                 2x AA quincunx
** NV_REG_OGL_FSAA_MODE_15x15         1.5x1.5 AA              Invalid
** NV_REG_OGL_FSAA_MODE_4x            2x2 AA                  4x AA bilinear
** NV_REG_OGL_FSAA_MODE_4x_9t         Invalid                 4x AA gaussian
**
** If a setting is invalid, the driver will treat it the same as no AA.
** The panel should not allow the user to set this key to an invalid value
** on the current chip, and the UI needs to be chip-dependent.
*/
#define NV_REG_OGL_FSAA_MODE                            "FSAAMode"
#define NV_REG_OGL_FSAA_MODE_NONE                       0
#define NV_REG_OGL_FSAA_MODE_2x                         1
#define NV_REG_OGL_FSAA_MODE_2x_5t                      2
#define NV_REG_OGL_FSAA_MODE_15x15                      3
#define NV_REG_OGL_FSAA_MODE_4x                         4
#define NV_REG_OGL_FSAA_MODE_4x_9t                      5
#define NV_REG_OGL_FSAA_MODE_DEFAULT                    NV_REG_OGL_FSAA_MODE_NONE
#define NV_REG_OGL_FSAA_MODE_MAXIMUM                    5 // clamp to [0,this]

#define NV_REG_OGL_S3TC_QUALITY                         "S3TCQuality"
#define NV_REG_OGL_S3TC_QUALITY_FORCE_DXT3              1
#define NV_REG_OGL_S3TC_QUALITY_DEFAULT                 0

#define NV_REG_OGL_FORCE_GENERIC_CPU                    "ForceGenericCPU"
#define NV_REG_OGL_FORCE_GENERIC_CPU_ON                 1
#define NV_REG_OGL_FORCE_GENERIC_CPU_OFF                0
#define NV_REG_OGL_FORCE_GENERIC_CPU_DEFAULT            NV_REG_OGL_FORCE_GENERIC_CPU_OFF

#define NV_REG_OGL_APP_SOFTIMAGE                        "App_SoftImage"
#define NV_REG_OGL_APP_SOFTIMAGE_DEFAULT                0
#define NV_REG_OGL_APP_SOFTIMAGE_38                     38
#define NV_REG_OGL_APP_SOFTIMAGE_39                     39

#define NV_REG_OGL_APP_SUPPORTBITS                      "App_SupportBits"
#define NV_REG_OGL_APP_SUPPORTBITS_DEFAULT              0
#define NV_REG_OGL_APP_SUPPORTBITS_SYNCGDI              0x00000001
#define NV_REG_OGL_APP_SUPPORTBITS_PROE_2000I2          0x00000002

#define NV_REG_OGL_NV20_EMULATE                         "NV20Emulate"
#define NV_REG_OGL_NV20_EMULATE_ON                      1
#define NV_REG_OGL_NV20_EMULATE_OFF                     0
#define NV_REG_OGL_NV20_EMULATE_DEFAULT                 NV_REG_OGL_FORCE_GENERIC_CPU_OFF

#define NV_REG_OGL_SERVER_SWAP_NT4                      "ServerSwapNT4"
#define NV_REG_OGL_SERVER_SWAP_NT4_DEFAULT              0

#define NV_REG_OGL_PERF_STRAT_IMM_MODE                  "094313"
#define NV_REG_OGL_PERF_STRAT_IMM_MODE_FORCE_DIRECT     0x09431392
#define NV_REG_OGL_PERF_STRAT_IMM_MODE_FORCE_BATCH      0x29313490
#define NV_REG_OGL_PERF_STRAT_IMM_MODE_FORCE_CACHE      0x13920943
#define NV_REG_OGL_PERF_STRAT_IMM_MODE_DEFAULT          0

/* OGL Capture file */
#define NV_REG_OGL_CAPTURE_ENABLE                       "CaptureEnable"
#define NV_REG_OGL_CAPTURE_ENABLE_DISABLE               0x00
#define NV_REG_OGL_CAPTURE_ENABLE_RECORD                0x01
#define NV_REG_OGL_CAPTURE_ENABLE_PLAY                  0x02
#define NV_REG_OGL_CAPTURE_ENABLE_DEFAULT               NV_REG_OGL_CAPTURE_ENABLE_RECORD

#define NV_REG_OGL_CAPTURE_RECORD_PATH                  "CaptureRecordPath"
#define NV_REG_OGL_CAPTURE_RECORD_PATH_DEFAULT          "c:\\"
#define NV_REG_OGL_CAPTURE_RECORD_FILENAME              "CaptureRecordFilename"
#define NV_REG_OGL_CAPTURE_RECORD_FILENAME_DEFAULT      "capture"

#define NV_REG_OGL_CAPTURE_PLAY_PATH                    "CapturePlayPath"
#define NV_REG_OGL_CAPTURE_PLAY_PATH_DEFAULT            "c:\\"
#define NV_REG_OGL_CAPTURE_PLAY_FILENAME                "CapturePlayFilename"
#define NV_REG_OGL_CAPTURE_PLAY_FILENAME_DEFAULT        "capture"

#define NV_REG_OGL_CAPTURE_WHEN_FLIP                    1
#define NV_REG_OGL_CAPTURE_WHEN_READPIXELS              2

#define NV_REG_OGL_CAPTURE_RECORD_WHEN                  "CaptureRecordWhen"
#define NV_REG_OGL_CAPTURE_RECORD_WHEN_DEFAULT          NV_REG_OGL_CAPTURE_WHEN_FLIP

#define NV_REG_OGL_CAPTURE_PLAY_WHEN                    "CapturePlayWhen"
#define NV_REG_OGL_CAPTURE_PLAY_WHEN_DEFAULT            NV_REG_OGL_CAPTURE_WHEN_FLIP

#define NV_REG_OGL_CAPTURE_PLAY_WHERE                   "CapturePlayWhere"
#define NV_REG_OGL_CAPTURE_PLAY_WHERE_FRONT             0
#define NV_REG_OGL_CAPTURE_PLAY_WHERE_BACK              1
#define NV_REG_OGL_CAPTURE_PLAY_WHERE_DEFAULT           NV_REG_OGL_CAPTURE_PLAY_WHERE_FRONT

// NV_REG_OGL_TEXCLAMP defines texture clamping behavior when GL_CLAMP is set.
//   EDGE means always use CLAMP_TO_EDGE.
//   USE_HW means use CLAMP if the HW supports it, otherwise CLAMP_TO_EDGE.
//   SPEC means follow the spec, even if it means software rasterization.
#define NV_REG_OGL_TEXCLAMP                             "TextureClampBehavior"
#define NV_REG_OGL_TEXCLAMP_EDGE                        0
#define NV_REG_OGL_TEXCLAMP_USE_HW                      1
#define NV_REG_OGL_TEXCLAMP_SPEC                        2
#define NV_REG_OGL_TEXCLAMP_NVALUES                     3
#define NV_REG_OGL_TEXCLAMP_DEFAULT                     NV_REG_OGL_TEXCLAMP_EDGE


//-----------------------------------------------------------------------------
// ResMan
//-----------------------------------------------------------------------------

#define NV_REG_SYS_SUPER7_COMPATIBILITY                 "Super7Compat"
#define NV_REG_OGL_DEFAULT_ALLOW_AGP_PUSH_BUF_FOR_MAC   0
#define NV_REG_OGL_DEFAULT_ALLOW_AGP_PUSH_BUF           1
#define NV_REG_OGL_DEFAULT_ALLOW_VID_PUSH_BUF           0
#define NV_REG_OGL_DISABLE_AGP_PUSH_BUF                 0
#define NV_REG_OGL_ENABLE_AGP_PUSH_BUF                  1

#define PERSISTENT_AGP_SIZE                             "PersistAGPSize"
#define NV_MAX_AGP_SIZE                                 "MaxAGPSize"
#define NV5_REG_SYS_HSYNC_FLIP                          "FlipOnHSync"
#define MAXREFRESHRATE                                  "MaxRefreshRate"
#define MAXOPTIMALREFRESHRATE                           "MaxOptimalRefreshRate"
#define OPTIMALREFRESHNOTFROMEDID                       "OptimalRefreshNotFromEDID"
#define DMTOVERRIDE                                     "DMTOVERRIDE"
#define MONITORTIMING                                   "MonitorTiming"
#define CURSORCACHE                                     "CursorCache"
#define DISPLAY_TYPE                                    "Display Type"
#define DISPLAY2_TYPE                                   "Display2 Type"
#define TV_TYPE                                         "TV Type"
#define POWERUPFLAGS                                    "PowerUpFlags"
#define TV_OUT                                          "TV Out"
#define NEWSTYLEMODESET                                 "NewStyleModeSet"
#define FLATPANELMODE                                   "FlatPanelMode"
#define RESOURCE_MANAGER_SUBKEY_ADDITION                "NVIDIA"


// Forces the push buffer to reside in a particular location.  Used by ddraw
// and OGL.  This is a local key.  Setting this will override the Super7Compat key
#define NV_REG_SYS_PB_LOCATION                          "PushBufferLocale"
#define   NV_REG_SYS_PB_LOCATION_DEFAULT                0
#define   NV_REG_SYS_PB_LOCATION_SYSTEM                 1
#define   NV_REG_SYS_PB_LOCATION_AGP                    2
#define   NV_REG_SYS_PB_LOCATION_VIDEO                  3

//-----------------------------------------------------------------------------
// Control Panel
//-----------------------------------------------------------------------------

#define NV_REG_CPL_D3D_SETTINGS_SUBKEY                   NV4_REG_DIRECT3D_SUBKEY
#define NV_REG_CPL_OGL_SETTINGS_SUBKEY                   NV4_REG_OGL_SUBKEY

#define NV_REG_CPL_COLOR_SUBKEY                          "Color"
#define NV_REG_CPL_COLOR_VALUE_CURRENT                   "Current"

#define NV_REG_CPL_COLOR_SCHEMES_SUBKEY                  "Schemes"

#define NV_REG_CPL_TV_OUT_SUBKEY                         "TVOut"

#define NV_REG_CPL_OEM_DEFAULTS_SUBKEY                   "Defaults"

#define NV_REG_CPL_DISPLAY_MODES_SUBKEY                  "DisplayModes"
#define NV_REG_CPL_DISPLAY_MODES_VALUE_MONITOR           "Analog Monitor"
#define NV_REG_CPL_DISPLAY_MODES_VALUE_DFP               "Digital Flat Panel"
#define NV_REG_CPL_DISPLAY_MODES_VALUE_TV                "TV"

#define NV_REG_CPL_OVL_SETTINGS_SUBKEY                   "Overlay"

// path to "skins" DLL provided by OEMs or IHVs
#define NV_REG_CPL_OEM_GRAPHICS_LIB                      "NvCplGfxLib"

#define NV_REG_CPL_VALUE_UNLOCK_GOODIES                  "CoolBits"
#define NV_REG_CPL_DATA_UNLOCK_GOODIES_VSYNC             0x00000001
#define NV_REG_CPL_DATA_UNLOCK_GOODIES_HWCLOCK           0x00000002

#define NV_REG_HARDWARE_SUBKEY                           "Hardware"
#define NV_REG_HARDWARE_CLOCK_ENABLE                     "Marge"    // overclocking enable
#define NV_REG_HARDWARE_CLOCK_CONTROL_USER               "Krusty"   // user defined clock speeds
#define NV_REG_HARDWARE_CLOCK_CONTROL_DEFAULT            "Bart"     // BIOS default clock speeds
#define NV_REG_HARDWARE_CLOCK_ENCRYPT_FLAGS              "Homer"    // encryption flags
#define NV_REG_HARDWARE_CLOCK_NO_WARN_DLG                "Lisa"     // turn off warning dialog
#define NV_REG_HARDWARE_CLOCK_DETECT_VALUE               "NvHardwareControl"
#define NV_REG_HARDWARE_CLOCK_DETECT_CMD_LINE            "RUNDLL32.EXE NVQTWK.DLL,NvHWCtl"
#define NV_REG_HARDWARE_CLOCK_INIT_VALUE                 "NvInitialize"
#define NV_REG_HARDWARE_CLOCK_INIT_CMD_LINE              "RUNDLL32.EXE NVQTWK.DLL,NvXTInit"

#define NV_REG_DESK_MANAGER_VALUE_NAME                   "DesktopManager"   //XXX deprecated!
#define NV_REG_DESK_MANAGER_HOTKEY_SUBKEY                "HotKeys"  //XXX deprecated!
#define NV_REG_DESK_MANAGER_APPASSOC_SUBKEY              "Apps"
#define NV_REG_DESK_MANAGER_APPASSOC_DESKTOP             "Desktop"
#define NV_REG_DESK_MANAGER_APPASSOC_MONITOR             "StartingMonitor"
#define NV_REG_DESK_MANAGER_APPASSOC_FLAGS               "Flags"
#define NV_REG_DESK_MANAGER_APPASSOC_PLACEMENT           "Placement"
#define NV_REG_DESK_MANAGER_APPASSOC_CLASS               "Class"
#define NV_REG_DESK_MANAGER_GLOBALS_SUBKEY               "Globals"
#define NV_REG_DESK_MANAGER_GLOBALS_FLAGS                "Flags"
#define NV_REG_DESK_MANAGER_GLOBALS_TLSCREEN             "TLScreen"
#define NV_REG_DESK_MANAGER_GLOBALS_HKMOVE               "HKMove"
#define NV_REG_DESK_MANAGER_GLOBALS_HKMOVEALL            "HKMoveAll"
#define NV_REG_DESK_MANAGER_GLOBALS_HKSWITCH             "HKSwitch"
#define NV_REG_DESK_MANAGER_GLOBALS_HKGATHER             "HKGather"
#define NV_REG_DESK_MANAGER_GLOBALS_HKZOOM               "HKZoom"
#define NV_REG_DESK_MANAGER_GLOBALS_HKZOOMIN             "HKZoomIn"
#define NV_REG_DESK_MANAGER_GLOBALS_HKZOOMOUT            "HKZoomOut"
#define NV_REG_DESK_MANAGER_GLOBALS_ALTTABMON            "CoolSwitchMon"
#define NV_REG_DESK_MANAGER_GLOBALS_ZOOMLEVEL            "DefaultZoomLevel"
#define NV_REG_DESK_MANAGER_GLOBALS_ZOOMREFRESH          "ZoomRefreshRate"
#define NV_REG_DESK_MANAGER_GLOBALS_ZOOMWKEYS            "ZoomWheelKeys"
#define NV_REG_DESK_MANAGER_GLOBALS_ZOOMDELAY            "ZoomSwitchDelay"
#define NV_REG_DESK_MANAGER_CPLPOS                       "PanelPos"

/////////////////////////////////////
// bit flags for the QuickTweak properties settings

#define NV_REG_CPL_GLOBAL_VALUE_QUICKTWEAK_FLAGS         "QuickTweak"

#define NV_REG_CPL_GLOBAL_DATA_QUICKTWEAK_DEFAULT        0x00010020

#define NV_REG_FLAGS_NOCONFIRM                           0x00000001
#define NV_REG_FLAGS_LBUTTON                             0x00000010
#define NV_REG_FLAGS_RBUTTON                             0x00000020
#define NV_REG_FLAGS_BOTHBUTTONS                         0x00000030
#define NV_REG_FLAGS_COOLMENUS                           0x00000100
#define NV_REG_FLAGS_QUICKTWEAK_ALWAYS                   0x00000200
#define NV_REG_FLAGS_QUICKTWEAK_HIDDEN                   0x00000400
#define NV_REG_FLAGS_SUPPORT_INDUCE                      0x00000800
#define NV_REG_FLAGS_RESTORE_VIRTUAL                     0x00001000
#define NV_REG_FLAGS_TASKBAR_LOGO                        0x00010000
#define NV_REG_FLAGS_TASKBAR_BLUE                        0x00020000
#define NV_REG_FLAGS_TASKBAR_RED                         0x00040000

#define NV_REG_FLAGS_DEFAULT                             (NV_REG_FLAGS_RBUTTON | NV_REG_FLAGS_TASKBAR_LOGO)

/////////////////////////////////////
// Flag to turn on the control panel agp/hardware page
#define NV_REG_CPL_ENABLE_HARDWARE_PAGE "NvCplEnableHardwarePage"
#define NV_REG_CPL_ENABLE_HARDWARE_PAGE_ENABLE  1
#define NV_REG_CPL_ENABLE_HARDWARE_PAGE_DISABLE 0
#define NV_REG_CPL_ENABLE_HARDWARE_PAGE_DEFAULT NV_REG_CPL_ENABLE_HARDWARE_PAGE_DISABLE

/////////////////////////////////////
// bit flags for hiding particular property pages or dialogs
#define NV_REG_CPL_HIDE_PROPPAGES          "NoPages"

#define NVCPL_HIDE_COLOR_PAGE              0x00000001
#define NVCPL_HIDE_D3D_PAGE                0x00000002
#define NVCPL_HIDE_OGL_PAGE                0x00000004
#define NVCPL_HIDE_OVERLAY_PAGE            0x00000008
#define NVCPL_HIDE_OPTIONS_PAGE            0x00000010
#define NVCPL_HIDE_TASKBAR_PAGE            NVCPL_HIDE_OPTIONS_PAGE
#define NVCPL_HIDE_OUTPUT_DEVICE_PAGE      0x00000020
#define NVCPL_HIDE_CRT_POSITIONING_DLG     0x00000040
#define NVCPL_HIDE_DFP_POSITIONING_DLG     0x00000080
#define NVCPL_HIDE_TV_POSITIONING_DLG      0x00000100
#define NVCPL_HIDE_INTERNET_OPTIONS        0x00000200
#define NVCPL_HIDE_CRT_TIMING_DLG          0x00000400
#define NVCPL_HIDE_ALL_CRT_SETTINGS        (NVCPL_HIDE_CRT_POSITIONING_DLG | NVCPL_HIDE_CRT_TIMING_DLG)
#define NVCPL_HIDE_AA_PAGE                 0x00000800
#define NVCPL_HIDE_MONITOR_SCALING_OPTION  0x00002000
#define NVCPL_HIDE_BIOS_FLASH_CAPS         0x00004000
#define NVCPL_HIDE_EXTENDED_OVERLAY_DIALOG 0x00008000
#define NVCPL_HIDE_HARDWARE_DIALOG         0x00010000
#define NVCPL_HIDE_POWERMIZER_DIALOG       0x00020000
#define NVCPL_HIDE_WATERMARK               0x00040000

#ifdef  STEREO_SUPPORT
//-----------------------------------------------------------------------------
// Registry settings for stereo support. For now are sitting in the Global section.
//-----------------------------------------------------------------------------
#define NV_REG_STEREO_ENABLED                            "StereoEnable"                //Stereo can be potentially activated.
#define NV_REG_STEREO_STEREOVIEWER                       "StereoViewer"                //Defines the name of the stereo viewer driver.
#define NV_REG_STEREO_STEREOVIEWERTYPE                   "StereoViewerType"            //Defines the stereo viewer type.
#define NV_REG_STEREO_ADJUSTENABLED                      "StereoAdjustEnable"          //Allow stereo adjustments by hot keys.
#define NV_REG_STEREO_DISABLE_TnL                        "StereoDisableTnL"            //Disables hardware T&L. Allowes to reach more stereo effect.
#define NV_REG_STEREO_SEPARATION                         "StereoSeparation"            //Pre-transformed separation (ProjectMatrix.31).
#define NV_REG_STEREO_CONVERGENCE                        "StereoConvergence"           //Pre-transformed convergence (ProjectMatrix.41).
#define NV_REG_STEREO_CONVERGENCEMULTIPLIER              "StereoConvergenceMultiplier" //Defines correlation between pre and post-transformed convergence.
#define NV_REG_STEREO_RHW2DDETECTIONMIN                  "RHW2DDetectionMin"           //RHW far limit for 2D object detection.
#define NV_REG_STEREO_RHWGREATERATSCREEN                 "RHWGreaterAtScreen"          //Objects closer than this boundary are 2D.
#define NV_REG_STEREO_RHWEQUALATSCREEN                   "RHWEqualAtScreen"            //All objects parallel to screen are 2D.
#define NV_REG_STEREO_RHWLESSATSCREEN                    "RHWLessAtScreen"             //All objects parallel to screen are 2D.
#define NV_REG_STEREO_AUTOCONVERGENCE                    "AutoConvergence"             //Automatically focus on the closest object.
#define NV_REG_STEREO_CONVERGENCEADJUSTPACE              "AutoConvergenceAdjustPace"   //Per frame Convergence adjust pace in AutoConvergence mode.
#define NV_REG_STEREO_HOTKEY_TOGGLE                      "StereoToggle"                //The hot key to toggle stereo.
#define NV_REG_STEREO_HOTKEY_VERTICALADJUST_MORE         "StereoVerticalAdjustMore"    //The hot key to increase the vertical separation.
#define NV_REG_STEREO_HOTKEY_VERTICALADJUST_LESS         "StereoVerticalAdjustLess"    //The hot key to reduce the vertical separation.
#define NV_REG_STEREO_HOTKEY_HORIZONTALADJUST_MORE       "StereoHorizontalAdjustMore"  //The hot key to increase the horizontal separation.
#define NV_REG_STEREO_HOTKEY_HORIZONTALADJUST_LESS       "StereoHorizontalAdjustLess"  //The hot key to reduce the horizontal separation.
#define NV_REG_STEREO_HOTKEY_SEPARATIONADJUST_MORE       "StereoSeparationAdjustMore"  //The hot key to increase the stereo separation.
#define NV_REG_STEREO_HOTKEY_SEPARATIONADJUST_LESS       "StereoSeparationAdjustLess"  //The hot key to increase the stereo separation.
#define NV_REG_STEREO_HOTKEY_CONVERGENCEADJUST_MORE      "StereoConvergenceAdjustMore" //The hot key to increase the convergence degree.
#define NV_REG_STEREO_HOTKEY_CONVERGENCEADJUST_LESS      "StereoConvergenceAdjustLess" //The hot key to reduce the convergence degree.
#define NV_REG_STEREO_HOTKEY_SUGGESTSETTINGS             "StereoSuggestSettings"       //The hot key to automatically set suggested stereo settings.
#define NV_REG_STEREO_HOTKEY_UNSUGGESTSETTINGS           "StereoUnsuggestSettings"     //The hot key to restore stereo settings before suggestion.
#define NV_REG_STEREO_HOTKEY_LASER_X_PLUS                "LaserAdjustXPlus"            //The hot key to increase the laser sight X position
#define NV_REG_STEREO_HOTKEY_LASER_X_MINUS               "LaserAdjustXMinus"           //The hot key to decrease the laser sight X position
#define NV_REG_STEREO_HOTKEY_LASER_Y_PLUS                "LaserAdjustYPlus"            //The hot key to increase the laser sight Y position
#define NV_REG_STEREO_HOTKEY_LASER_Y_MINUS               "LaserAdjustYMinus"           //The hot key to decrease the laser sight Y position
#define NV_REG_STEREO_FAVORSZ                            "FavorSZ"                     //Rather use SZ in stereo calculations than RHW
#define NV_REG_STEREO_LASERSIGHT                         "LaserSight"                  //Use Nvidia proprietary laser sight.
#define NV_REG_STEREO_LASERSIGHTFILE                     "LaserSightFile"              //Defines the BMP file used as a laser sight.
#define NV_REG_STEREO_LASERSIGHTENABLED                  "LaserSightEnabled"           //Masks on/off use of a laser sight.
#define NV_REG_STEREO_LASERSIGHTPROPERTY                 "LaserSightProperty"          //Laser sight min/max size and transparency.
#define NV_REG_STEREO_DEFAULTON                          "StereoDefaultOn"             //Turn stereo on when the game starts
#define NV_REG_STEREO_FRUSTUMADJUSTMODE                  "FrustumAdjustMode"           //0 - do nothing, 1 - stretch in X, 2 - clear corresponding edges for each eye.
#define NV_REG_STEREO_MONITORSIZE                        "MonitorSize"                 //The monitor diagonal for max. stereo separation calculation.
#define NV_REG_STEREO_NOORTHOSTEREO                      "NoOrthoStereo"               //Assumes that Ortho porjection is used for 2D objects (OpenGL).
#define NV_REG_STEREO_MAXVERTEXCOUNT                     "MaxVertexCount"              //Max. amount of vertices we allow in VB (for D3D SW TnL games only).
#define NV_REG_STEREO_PARTIALCLEARMODE                   "PartialClearMode"            //0 - do as requested, 1 - do full clear instad, 2 - ignore
#define NV_REG_STEREO_LASERXADJUST                       "LaserXAdjust"
#define NV_REG_STEREO_LASERYADJUST                       "LaserYAdjust"
#define NV_REG_STEREO_POPUP_ENABLED                      "PopupAgents"                  //Use Nvidia proprietary popup agents
#define NV_REG_STEREO_POPUP_SUBKEY                       "PopupAgentOptions"            //subkey under which options lies
#define NV_REG_STEREO_POPUP_STAT                         "PopupStat"                    //on/off Stereo statistics
#define NV_REG_STEREO_POPUP_FPS                          "PopupFPS"                     //on/off frame rate info popup
#define NV_REG_STEREO_POPUP_HOTKEY                       "PopupHotkey"                  //what hotkey will toggle all popups
#define NV_REG_STEREO_POPUP_FPS_HOTKEY                   "FPSHotkey"                    //what hotkey will toggle FPS popup
#define NV_REG_STEREO_POPUP_STATS_HOTKEY                 "StatHotkey"                   //what hotkey will toggle StereoStat popup
#endif  //STEREO_SUPPORT

//----------------End of file NVREG.H----(do not edit below this line or remove this line) -----
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\common\inc\nvRegTool.h ===
/***************************************************************************\
|*                                                                           *|
|*       Copyright 1993-2001 NVIDIA, Corporation.  All rights reserved.      *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.  Users and possessors of this source code are     *|
|*     hereby granted a nonexclusive,  royalty-free copyright license to     *|
|*     use this code in individual and commercial software.                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY     *|
|*     OF  THIS SOURCE  CODE  FOR ANY PURPOSE.  IT IS  PROVIDED  "AS IS"     *|
|*     WITHOUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPOR-     *|
|*     ATION DISCLAIMS ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,     *|
|*     INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY, NONINFRINGE-     *|
|*     MENT,  AND FITNESS  FOR A PARTICULAR PURPOSE.   IN NO EVENT SHALL     *|
|*     NVIDIA, CORPORATION  BE LIABLE FOR ANY SPECIAL,  INDIRECT,  INCI-     *|
|*     DENTAL, OR CONSEQUENTIAL DAMAGES,  OR ANY DAMAGES  WHATSOEVER RE-     *|
|*     SULTING FROM LOSS OF USE,  DATA OR PROFITS,  WHETHER IN AN ACTION     *|
|*     OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  ARISING OUT OF     *|
|*     OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOURCE CODE.     *|
|*                                                                           *|
|*     U.S. Government  End  Users.   This source code  is a "commercial     *|
|*     item,"  as that  term is  defined at  48 C.F.R. 2.101 (OCT 1995),     *|
|*     consisting  of "commercial  computer  software"  and  "commercial     *|
|*     computer  software  documentation,"  as such  terms  are  used in     *|
|*     48 C.F.R. 12.212 (SEPT 1995)  and is provided to the U.S. Govern-     *|
|*     ment only as  a commercial end item.   Consistent with  48 C.F.R.     *|
|*     12.212 and  48 C.F.R. 227.7202-1 through  227.7202-4 (JUNE 1995),     *|
|*     all U.S. Government End Users  acquire the source code  with only     *|
|*     those rights set forth herein.                                        *|
|*                                                                           *|
 \***************************************************************************/
#ifndef _NVREGTOOL_H_
#define _NVREGTOOL_H_

#include "nvTypes.h"

typedef void * NV_DRIVER_HANDLE;
typedef void * NV_REGISTRY_HANDLE;

#ifdef __cplusplus
class CRegTool
{
private:
#else
typedef struct CRegTool
{
#endif

#if IS_WIN9X
    NV_REGISTRY_HANDLE m_hKey;
#elif IS_WINNT
    NV_DRIVER_HANDLE m_hDriver;
#endif

#ifdef __cplusplus

public:
    NvU8 Open(NV_DRIVER_HANDLE hDriver, int logicalHeadID, char *subKeyName);
    NvU8 Read(char *keyName, NvU32 &val);
    NvU8 Read(char *keyName, NvS32 &val);
    void Close();
};
#else
} CRegTool;
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\common\inc\nvUtil.h ===
/***************************************************************************\
|*                                                                           *|
|*       Copyright 1993-2000 NVIDIA, Corporation.  All rights reserved.      *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.  Users and possessors of this source code are     *|
|*     hereby granted a nonexclusive,  royalty-free copyright license to     *|
|*     use this code in individual and commercial software.                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY     *|
|*     OF  THIS SOURCE  CODE  FOR ANY PURPOSE.  IT IS  PROVIDED  "AS IS"     *|
|*     WITHOUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPOR-     *|
|*     ATION DISCLAIMS ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,     *|
|*     INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY, NONINFRINGE-     *|
|*     MENT,  AND FITNESS  FOR A PARTICULAR PURPOSE.   IN NO EVENT SHALL     *|
|*     NVIDIA, CORPORATION  BE LIABLE FOR ANY SPECIAL,  INDIRECT,  INCI-     *|
|*     DENTAL, OR CONSEQUENTIAL DAMAGES,  OR ANY DAMAGES  WHATSOEVER RE-     *|
|*     SULTING FROM LOSS OF USE,  DATA OR PROFITS,  WHETHER IN AN ACTION     *|
|*     OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  ARISING OUT OF     *|
|*     OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOURCE CODE.     *|
|*                                                                           *|
|*     U.S. Government  End  Users.   This source code  is a "commercial     *|
|*     item,"  as that  term is  defined at  48 C.F.R. 2.101 (OCT 1995),     *|
|*     consisting  of "commercial  computer  software"  and  "commercial     *|
|*     computer  software  documentation,"  as such  terms  are  used in     *|
|*     48 C.F.R. 12.212 (SEPT 1995)  and is provided to the U.S. Govern-     *|
|*     ment only as  a commercial end item.   Consistent with  48 C.F.R.     *|
|*     12.212 and  48 C.F.R. 227.7202-1 through  227.7202-4 (JUNE 1995),     *|
|*     all U.S. Government End Users  acquire the source code  with only     *|
|*     those rights set forth herein.                                        *|
|*                                                                           *|
 \***************************************************************************/
 /***************************************************************************\
|*                                                                           *|
|*                       General nVidia Utilties                             *|
|*                                                                           *|
|* Includes a variety of miscelaneous but commonly useful functions & macros *|
|*                                                                           *|
|* This file is OS independent.  Use ONLY nVidia types and names.            *|
|*                                [eg. No DWORD, use NvU32]                  *|
|*                                                                           *|
 \***************************************************************************/

#ifndef _NVUTIL_H_
#define _NVUTIL_H_

#include "nvTypes.h"
#include <StdArg.h>

#ifdef __cplusplus
    #define EXTERN_C    extern "C"
#else
    #define EXTERN_C    extern
#endif

//---------------------------------------------------------------------------
//
//  Common definitions
//
//---------------------------------------------------------------------------

#ifndef ABS
#define ABS(a)  (a>0?a:-a)
#endif
#ifndef MIN
#define MIN(x,y) (((x)<(y))?(x):(y))
#endif
#ifndef MAX
#define MAX(x,y) (((x)>(y))?(x):(y))
#endif

#ifndef VOID
#define VOID            void
#endif
#ifndef TRUE
#define TRUE            ~0
#endif
#ifndef FALSE
#define FALSE           0
#endif
#ifndef NULL
#define NULL            0L
#endif

// ================================================================
// floating point bit munging
// ================================================================

// convert an FP representation into a DWORD or vice-versa
#define DWORD_FROM_FLOAT(fp) (*(NvU32 *)&(fp))
#define FLOAT_FROM_DWORD(dw) (*(float *)&(dw))

#define FP_SIGN_BIT(fp) (DWORD_FROM_FLOAT(fp)&0x80000000)
#define FP_ABS_BITS(fp) (DWORD_FROM_FLOAT(fp)&0x7FFFFFFF)
#define FP_EXP_BITS(fp) (DWORD_FROM_FLOAT(fp)&0x7F800000)
#define FP_MAN_BITS(fp) (DWORD_FROM_FLOAT(fp)&0x007FFFFF)

#define FP_EXP_VAL(fp)  (FP_EXP_BITS(fp) >> 27)
#define FP_MAN_VAL(fp)  (FP_MAN_BITS(fp) >>  0)

#define FP_ONE_BITS          0x3F800000
#define FP_INFINITY_BITS     0x7F800000
#define FP_MIN_INFINITY_BITS 0xFF800000

// ================================================================
// Fun with Powers of 2
// ================================================================

// returns the index of the least significant bit = log2(x) if x=2^n
#define ASM_LOG2(x)     __asm mov eax,[x]   __asm bsf ecx,eax   __asm mov [x],ecx
// returns the index of the most significant bit = log2(x) if x=2^n
#define ASM_LOG2_R(x)   __asm mov eax,[x]   __asm bsr ecx,eax   __asm mov [x],ecx

// ================================================================
// Our very own string utils
// ================================================================
// NV string routines necessary because the analogs don't exist under NT. ugh.

EXTERN_C int   __cdecl nvStrCmp     (char *szStr1, char *szStr2);
EXTERN_C int   __cdecl nvStrLen     (char *szStr);
EXTERN_C int   __cdecl nvStrNLen    (char *szStr, int n);
EXTERN_C void  __cdecl nvStrCpy     (char *szDst, char *szSrc);
EXTERN_C void  __cdecl nvStrNCpy    (char *szDst, char *szSrc, int n);
EXTERN_C void  __cdecl nvStrCat     (char *szStr1, char *szStr2);
EXTERN_C char* __cdecl nvStrChr     (char *szStr, NvU8 c);
EXTERN_C char* __cdecl nvStrRChr    (char *szStr, NvU8 c);
EXTERN_C void  __cdecl nvSprintfVAL (char *szDest, char *szFormat, va_list vaArgs);
EXTERN_C void  __cdecl nvSprintf    (char *szDest, char *szFormat, ...);

EXTERN_C NvU32 nvGetCurrentProcessId();
EXTERN_C void  nvQueryPerformanceCounter(__int64  *pPerformanceCount);

// This is the same as nvDelay, but takes a parameter instead of referencing a global
EXTERN_C void nvSpin(NvU32 loopCount);

#endif  // !_NVUTIL_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\common\inc\nvUniversal.h ===
/***************************************************************************\
|*                                                                           *|
|*       Copyright 1993-2000 NVIDIA, Corporation.  All rights reserved.      *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.  Users and possessors of this source code are     *|
|*     hereby granted a nonexclusive,  royalty-free copyright license to     *|
|*     use this code in individual and commercial software.                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY     *|
|*     OF  THIS SOURCE  CODE  FOR ANY PURPOSE.  IT IS  PROVIDED  "AS IS"     *|
|*     WITHOUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPOR-     *|
|*     ATION DISCLAIMS ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,     *|
|*     INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY, NONINFRINGE-     *|
|*     MENT,  AND FITNESS  FOR A PARTICULAR PURPOSE.   IN NO EVENT SHALL     *|
|*     NVIDIA, CORPORATION  BE LIABLE FOR ANY SPECIAL,  INDIRECT,  INCI-     *|
|*     DENTAL, OR CONSEQUENTIAL DAMAGES,  OR ANY DAMAGES  WHATSOEVER RE-     *|
|*     SULTING FROM LOSS OF USE,  DATA OR PROFITS,  WHETHER IN AN ACTION     *|
|*     OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  ARISING OUT OF     *|
|*     OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOURCE CODE.     *|
|*                                                                           *|
|*     U.S. Government  End  Users.   This source code  is a "commercial     *|
|*     item,"  as that  term is  defined at  48 C.F.R. 2.101 (OCT 1995),     *|
|*     consisting  of "commercial  computer  software"  and  "commercial     *|
|*     computer  software  documentation,"  as such  terms  are  used in     *|
|*     48 C.F.R. 12.212 (SEPT 1995)  and is provided to the U.S. Govern-     *|
|*     ment only as  a commercial end item.   Consistent with  48 C.F.R.     *|
|*     12.212 and  48 C.F.R. 227.7202-1 through  227.7202-4 (JUNE 1995),     *|
|*     all U.S. Government End Users  acquire the source code  with only     *|
|*     those rights set forth herein.                                        *|
|*                                                                           *|
 \***************************************************************************/
#ifndef _NVUNIVERSAL_H_
#define _NVUNIVERSAL_H_

#include "nvtypes.h"

/*==========================================================================;
 *
 *  File:       NvUniversal.h
 *
 *  Content:    Defines, constants, macros, and miscellaneous constructs that
 *              are commonly needed across all operating system platforms.
 *
 *              If the code is specific to Windows, or Mac, or Linux it doesn't
 *              go here.
 *
 ***************************************************************************/

#ifndef NVARCH
#error NVARCH must be defined. Definition of NV3, NV4, NV10, etc. is obsolete.
ERROR! NVARCH must be defined. Definition of NV3, NV4, NV10, etc. is obsolete.
#endif

// TBD: have everyone use this from here... -mlavoie
#if 0
#if (NVARCH >= 0x04)
#define NV_IN_PROGRESS          0x8000
#else
#define NV_IN_PROGRESS          0xFF
#endif
#endif

// TBD: move device version (and other appropos stuff) into this @mjl@
typedef struct _NVD3D_PERFDATA
{
    // bank
    NvU32 dwCPUFeatureSet;
    NvU32 dwProcessorSpeed;
    NvU32 dwSystemMemory;                   // MB of system memory, rounded to the nearest 8
    NvU32 dwNVClasses;
    NvU32 dwNVClasses1;
    NvU32 dwPerformanceStrategy;
    NvU32 dwSpinLoopCount;
    NvU32 dwPad_0[1];
    // bank
    NvU32 dwRecommendedPushBufferSize;      // default pusher size in BYTES
    NvU32 dwRecommendedStageBufferSize;     // default stage buffer size in BYTES
    NvU32 dwRecommendedPCITexHeapSize;      // recommended size of PCI texture heap in BYTES
    NvU32 dwMaxTextureSize;
    NvU32 dwMaxVolumeTextureSize;
    NvU32 dwHaveVolumeTextures;             // RM tells us if we do
    NvU32 dwHaveAALines;
    NvU32 dwHaveAnisotropic;
} NV_SystemInfo_t;

//---------------------------------------------------------------------------
// perf data

// nvD3DPerfData.dwCPUFeatureSet
#define FS_MMX              0x00000001      // ) do not change - some code
#define FS_KATMAI           0x00000002      //  )          relies on the macros to match these numbers
#define FS_3DNOW            0x00000004      // )
#define FS_HALFFASTWRITE    0x00000008      // camino with agp4x and 1/2 nv fast writes
#define FS_FULLFASTWRITE    0x00000010      // camino with agp4x and 1/1 nv fast writes
#define FS_WILLAMETTE       0x00000020      //  Pentium 4 support
#define FS_ATHLON           0x00000040      // AMD Athlon
#define FS_PREFETCH         0x00000080      // supports prefetchNTA, prefetchT0, movntq
#define FS_SFENCE           0x00001000      // has sfence support
#define FS_64BIT            0x00008000      // 64-bit back end (VANTA)
#define FS_PCIBUS           0x00010000      // PCI Bus

// nvD3DPerfData.dwPerformanceStrategy
#define PS_TEXTURE_RENAME       0x00000001  // allow textures to be renamed
#define PS_TEXTURE_USEHW        0x00000002  // allow HW to swizzle (better for lower back-end bandwidth)
#define PS_TEXTURE_PREFER_AGP   0x00000004  // put textures in AGP first (expensive blt to HW)
#define PS_CONTROL_TRAFFIC_16   0x00000008  // allow CPU to control back-end bus traffic
#define PS_CONTROL_TRAFFIC_32   0x00000010  // allow CPU to control back-end bus traffic
#define PS_VB_RENAME            0x00000020  // allow vertex buffers to be renamed
#define PS_VB_PREFER_AGP        0x00000040  // put VBs in agp
#define PS_PUSH_VID             0x00000080  // put push buffer & default VB in video memory
#define PS_SUPERTRI             0x00000100  // super triangle processing
#define PS_MUSH                 0x00000200  // limit performance
#define PS_AUTOPALETTE          0x00000400  // auto-palettize 32 bit textures with 256 colours or less
#define PS_ST_XFORMCLIP         0x00000800  // super triangle - transform and clip check
#define PS_ST_MODEL             0x00001000  // super tri - model space cull
#define PS_ALT_STENCIL          0x00002000  // alternate stencil mode
#define PS_CT_11M               0x00004000  // special CT mode for NV11M

#define PS_ST_MASK              (PS_ST_XFORMCLIP | PS_ST_MODEL)

//---------------------------------------------------------------------------

// nvD3DPerfData.dwCPUFeatureSet
#define CPU_FS_MMX              0x00000001      // ) do not change - some code
#define CPU_FS_KATMAI           0x00000002      //  )          relies on the macros to match these numbers
#define CPU_FS_3DNOW            0x00000004      // )
#define CPU_FS_HALFFASTWRITE    0x00000008      // camino with agp4x and 1/2 nv fast writes
#define CPU_FS_FULLFASTWRITE    0x00000010      // camino with agp4x and 1/1 nv fast writes
#define CPU_FS_WILLAMETTE       0x00000020      //  Pentium 4 support
#define CPU_FS_ATHLON           0x00000040      // AMD Athlon
#define CPU_FS_PREFETCH         0x00000080      // supports prefetchNTA, prefetchT0, movntq
#define CPU_FS_SFENCE           0x00001000      // has sfence support
#define CPU_FS_64BIT            0x00008000      // 64-bit back end (VANTA)

// These are IDs used to identify the last module to use a given object (if more than one
// module (subsystem) is using a given object in the same channel.
//
#define MODULE_ID_NONE                 0  // No subsystem has yet used the object
#define MODULE_ID_D3D                  1
#define MODULE_ID_DDRAW                2
#define MODULE_ID_DDRAW_VPP            3

// NV_SYSTEM_INFO.dwNVClasses
// ordered from "worst" to "best" within each class
#define NVCLASS_0055_DX6TRI     0x00000001
#define NVCLASS_0095_DX6TRI     0x00000002

#define NVCLASS_0054_DX5TRI     0x00000004
#define NVCLASS_0094_DX5TRI     0x00000008

#define NVCLASS_0056_CELSIUS    0x00000010
#define NVCLASS_0096_CELSIUS    0x00000020
#define NVCLASS_1196_CELSIUS    0x00000040

#define NVCLASS_0097_KELVIN     0x00000080

#define NVCLASS_0046_DAC        0x00000100
#define NVCLASS_0049_DAC        0x00000200
#define NVCLASS_0067_DAC        0x00000400
#define NVCLASS_007C_DAC        0x00000800

#define NVCLASS_0042_CTXSURF2D  0x00001000
#define NVCLASS_0062_CTXSURF2D  0x00002000

#define NVCLASS_0060_IDXIMAGE   0x00004000
#define NVCLASS_0064_IDXIMAGE   0x00008000

#define NVCLASS_0077_SCALEDIMG  0x00010000
#define NVCLASS_0063_SCALEDIMG  0x00020000
#define NVCLASS_0089_SCALEDIMG  0x00040000

#define NVCLASS_0038_DVDPICT    0x00100000
#define NVCLASS_0088_DVDPICT    0x00200000

#define NVCLASS_007A_OVERLAY    0x00400000

#define NVCLASS_0053_CTXSURF3D  0x01000000
#define NVCLASS_0093_CTXSURF3D  0x02000000

#define NVCLASS_004A_GDIRECT    0x04000000
#define NVCLASS_005E_SOLIDRECT  0x08000000

#define NVCLASS_0052_CTXSURFSWZ 0x10000000
#define NVCLASS_009E_CTXSURFSWZ 0x20000000
#define NVCLASS_0004_TIMER      0x40000000

// class 0 collectives
#define NVCLASS_FAMILY_DXTRI    (NVCLASS_0094_DX5TRI  | NVCLASS_0054_DX5TRI  | NVCLASS_0095_DX6TRI | NVCLASS_0055_DX6TRI)
#define NVCLASS_FAMILY_CELSIUS  (NVCLASS_0056_CELSIUS | NVCLASS_0096_CELSIUS | NVCLASS_1196_CELSIUS)
#define NVCLASS_FAMILY_KELVIN   (NVCLASS_0097_KELVIN)

// NV_SYSTEM_INFO.dwNVClasses1
// ordered from "worst" to "best" within each class
#define NVCLASS1_006C_CHANNELDMA 0x00000001
#define NVCLASS1_006E_CHANNELDMA 0x00000002
#define NVCLASS1_206E_CHANNELDMA 0x00000004

// class 1 collectives
// none yet

#define SUB_CHANNEL(I) (I * 0x00002000) // Computes subchannel offset given a simple ndx 0-7

// Convert Microsoft Specific modifier (not available on all MS compilers either)
#if defined(__forceinline)
#define FORCE_INLINE __forceinline
#else
#define FORCE_INLINE inline
#endif

#endif // _NVUNIVERSAL_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\common\inc\OEMSupport.h ===
/**************************************************************
 * File:	OEMSupport.h
 * Descr:	Has definitions for any OEM specific features
 *		    such as NT4.0 power management for gateway etc..
 **************************************************************/


//
// Following are the definitions and escape call to support NT4.0 power management for Gateway.
// Escape call made by NVSVC to set the power state.
// Input: ULONG:    Indicating the "PowerEvent". 
//                  For nVidia, this can be either POWER_EVENT_SUSPEND or POWER_EVENT_RESUME_NORMAL.
// Output: None: The call is always assumed to pass.
//
#define NV_ESC_GW_NT40_PM  0x7012

//
// possible values for 'PowerEvent' above
//
#define	POWER_EVENT_QUERY_SUSPEND	0x01
#define	POWER_EVENT_SUSPEND		0x02
#define	POWER_EVENT_RESUME_CRITICAL	0x03
#define	POWER_EVENT_RESUME_NORMAL	0x03

//
// The registry entry "APMSupport" will control if the NT4.0 APM support features are enabled for 
// a specific OEM. Possible values are given below
//
#define APM_SUPPORT_REGENTRY "APMSupport"
#define APM_SUPPORT_NONE    0
#define APM_SUPPORT_GATEWAY 1
#define APM_SUPPORT_IBM     2
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\common\inc\nvVPP.h ===
/***************************************************************************\
|*                                                                           *|
|*       Copyright 1993-2001 NVIDIA, Corporation.  All rights reserved.      *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.  Users and possessors of this source code are     *|
|*     hereby granted a nonexclusive,  royalty-free copyright license to     *|
|*     use this code in individual and commercial software.                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY     *|
|*     OF  THIS SOURCE  CODE  FOR ANY PURPOSE.  IT IS  PROVIDED  "AS IS"     *|
|*     WITHOUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPOR-     *|
|*     ATION DISCLAIMS ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,     *|
|*     INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY, NONINFRINGE-     *|
|*     MENT,  AND FITNESS  FOR A PARTICULAR PURPOSE.   IN NO EVENT SHALL     *|
|*     NVIDIA, CORPORATION  BE LIABLE FOR ANY SPECIAL,  INDIRECT,  INCI-     *|
|*     DENTAL, OR CONSEQUENTIAL DAMAGES,  OR ANY DAMAGES  WHATSOEVER RE-     *|
|*     SULTING FROM LOSS OF USE,  DATA OR PROFITS,  WHETHER IN AN ACTION     *|
|*     OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  ARISING OUT OF     *|
|*     OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOURCE CODE.     *|
|*                                                                           *|
|*     U.S. Government  End  Users.   This source code  is a "commercial     *|
|*     item,"  as that  term is  defined at  48 C.F.R. 2.101 (OCT 1995),     *|
|*     consisting  of "commercial  computer  software"  and  "commercial     *|
|*     computer  software  documentation,"  as such  terms  are  used in     *|
|*     48 C.F.R. 12.212 (SEPT 1995)  and is provided to the U.S. Govern-     *|
|*     ment only as  a commercial end item.   Consistent with  48 C.F.R.     *|
|*     12.212 and  48 C.F.R. 227.7202-1 through  227.7202-4 (JUNE 1995),     *|
|*     all U.S. Government End Users  acquire the source code  with only     *|
|*     those rights set forth herein.                                        *|
|*                                                                           *|
 \***************************************************************************/

/*==========================================================================;
 *
 *  File:       nvVPP.h
 *  Content:    Video Post Processing
 *
 ***************************************************************************/

#ifndef _NVVPP_H_
#define _NVVPP_H_

#include "CompileControl.h"

#include "nvTypes.h"
#include "nvProcMan.h"
#include "nvPusher.h"
#include "nvRegTool.h"
#include "nvUniversal.h"
#include "nvMultiMon.h" // Need twinview definition

// {BFD51181-16C4-11d4-8E67-00104B9D3738}
static const GUID GUID_NV_OVERLAY_INFO = { 0xbfd51181, 0x16c4, 0x11d4, { 0x8e, 0x67, 0x0, 0x10, 0x4b, 0x9d, 0x37, 0x38 } };

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

// Objects created and destroyed by the VPP code
//  Note: IID = instance ID
// TBD: lots of the code in ddraw common assumes these objects exist and interact with them
//   directly.  They should be changed to access them only through VPP routines. -@mjl@
#define NV_VPP_SWIZZLE_BLIT_IID     0xBB00B000
#define NV_VPP_OVERLAY_IID          0xBB00B010
#define NV_VPP_V2V_FORMAT_Y_IID     0xBB00B020
#define NV_VPP_ALPHA_BLIT_IID       0xBB00B030
#define NV_VPP_TIMER_IID            0xBB00B040
#define NV_VPP_V2OSH_FORMAT_IID     0xBB00B050  // Video Mem -> Overlay SHadow (OSH)
#define NV_VPP_OSH2V_FORMAT_IID     0xBB00B060
#define NV_VPP_SCALED_IMAGE1_IID    0xBB00B070
#define NV_VPP_SCALED_IMAGE2_IID    0xBB00B080
#define NV_VPP_DMABLT_TO_VID_IID    0xBB00B090
#define NV_VPP_DVD_SUBPICTURE_IID   0xBB00B0A0

#define NV_VPP_SWIZZLE_BLIT_CONTEXT_IID             0xBB00C000
#define NV_VPP_OVERLAY_CONTEXT_IID                  0xBB00C010
#define NV_VPP_V2V_FORMAT_Y_CONTEXT_IID             0xBB00C020
#define NV_VPP_ALPHA_BLIT_CONTEXT_IID               0xBB00C030
#define NV_VPP_TIMER_CONTEXT_IID                    0xBB00C040
#define NV_VPP_V2OSH_FORMAT_CONTEXT_IID             0xBB00C050
#define NV_VPP_OSH2V_FORMAT_CONTEXT_IID             0xBB00C060
#define NV_VPP_SCALED_IMAGE1_CONTEXT_IID            0xBB00C070
#define NV_VPP_SCALED_IMAGE2_CONTEXT_IID            0xBB00C080
#define NV_VPP_DMABLT_TO_VID_CONTEXT_IID            0xBB00C090
#define NV_VPP_DVD_SUBPICTURE_CONTEXT_IID           0xBB00C0A0

#define NV_VPP_CONTEXT_DMA_MEMORY_IID               0xBB00C990  // Used only on Win9x systems


#define NV_VPP_MAX_OVERLAY_SURFACES  10
#define NV_VPP_MAX_EXTRA_SURFACES    6
#define NV_VPP_MAX_EXTRA_FS_SURFACES 4


// vppVPPandFlip flags
#define VPP_ODD             NV4_REG_VPP_INV_MASK_ODD
#define VPP_EVEN            NV4_REG_VPP_INV_MASK_EVEN
#define VPP_BOB             NV4_REG_VPP_INV_MASK_BOB
#define VPP_INTERLEAVED     NV4_REG_VPP_INV_MASK_INTERLEAVED
#define VPP_VIDEOPORT       NV4_REG_VPP_INV_MASK_VIDEOPORT
#define VPP_WAIT            NV4_REG_VPP_INV_MASK_WAIT
#define VPP_SAVE_STATE      NV4_REG_VPP_SAVE_STATE_DISABLE
#define VPP_RESTORE_STATE   NV4_REG_VPP_RESTORE_STATE_DISABLE
#define VPP_CONVERT         NV4_REG_VPP_CONVERT_DISABLE
#define VPP_SUBPICTURE      NV4_REG_VPP_SUBPICTURE_DISABLE
#define VPP_PRESCALE        NV4_REG_VPP_PRESCALE_DISABLE
#define VPP_COLOURCONTROL   NV4_REG_VPP_COLOURCONTROL_DISABLE
#define VPP_TEMPORAL        NV4_REG_VPP_TEMPORAL_DISABLE
#define VPP_OPTIMIZEFLIP    NV4_REG_VPP_OPTIMIZEFLIP_DISABLE
#define VPP_DEINTERLACE     NV4_REG_VPP_DEINTERLACE_DISABLE
#define VPP_FSMIRROR        NV4_REG_VPP_FSMIRROR_DISABLE
#define VPP_DMABLIT_DISABLE NV4_REG_VPP_DMABLIT_DISABLE
#define VPP_MASTER_DISABLE  NV4_REG_VPP_MASTER_DISABLE
// TBD: why redefine these?  Note that master disable WAS being used directly anyway. - @mjl@

#define VPP_ALL             (VPP_CONVERT | VPP_SUBPICTURE | VPP_PRESCALE | VPP_COLOURCONTROL | VPP_DEINTERLACE | VPP_TEMPORAL | VPP_FSMIRROR)
#define VPP_STATIC          (VPP_CONVERT | VPP_SUBPICTURE | VPP_PRESCALE | VPP_COLOURCONTROL | VPP_FSMIRROR)
#define VPP_MOCOMP          (VPP_PRESCALE | VPP_FSMIRROR)

#define IS_OVERLAY(caps,fourcc) ((caps & DDSCAPS_OVERLAY) && (fourcc != FOURCC_NVDS) && (fourcc != FOURCC_NVMC))
#define IS_FIELD(f) ((f & (VPP_INTERLEAVED | VPP_BOB)) && (f & (VPP_ODD | VPP_EVEN)))

#ifdef ENABLE_VPP_DISPATCH_CODE
// This code is no longer used but may someday be useful.

// dispatcher commands
#define VPPDISPATCH_NOOP            0x0
#define VPPDISPATCH_DISPATCH        0x1
#define VPPDISPATCH_SETPRIORITY     0x2
#define VPPDISPATCH_RESTOREPRIORITY 0x4
#define VPPDISPATCH_EXIT            0xFFFFFFFF

// dispatcher state
#define VPPDSTATE_WAITING           0x1
#define VPPDSTATE_BUSY              0x2
#define VPPDSTATE_INITERROR         0x10000
#define VPPDSTATE_CMDERROR          0x20000
#define VPPDSTATE_TERMINATED        0x80000000

#endif

#ifdef DEBUG
    // so we know when something is drastically wrong
    #define VPP_TIMEOUT_TIME    250
    // snooping automatically enabled unless we're on NT where it doesn't work
    #ifndef WINNT
    #define VPP_SNOOP           1
    #endif
#else  // !DEBUG
    // maximum time we can spend on a frame
    #define VPP_TIMEOUT_TIME    42
    #ifdef DEVELOP
        #ifndef WINNT
        #define VPP_SNOOP       1
        #endif
    #endif  // DEVELOP
#endif  // !DEBUG

typedef struct {
  NvF32 sx;
  NvF32 sy;
  NvF32 sz;
  NvF32 rhw;
  NvV32 color;
  NvV32 specular;
  NvF32 tu0;
  NvF32 tv0;
  NvF32 tu1;
  NvF32 tv1;
} Tlmtvertex;

typedef struct Vpp_s Vpp_t;

//
// Exported functions
//
#ifdef WINNT
extern NvU8 VppConstructor(PDEV *ppdev, Vpp_t *pVpp, NV_SystemInfo_t *pSysInfo);
#else
extern NvU8 VppConstructor(GLOBALDATA *pDriverData, Vpp_t *pVpp, NV_SystemInfo_t *pSysInfo);
#endif
extern void VppDestructor(Vpp_t *pVpp);
extern NvU8 VppReadRegistry(Vpp_t *pVpp, HANDLE hDriver, NvU32 logicalHeadID);
extern void VppBltWriteDword(Vpp_t *pVpp, NvU32 dwOffset, NvU32 dwIndex, NvU32 dwData);
extern NvU8 VppIsOverlayActive(Vpp_t *pVpp);
extern NvU8 VppIsConstructed(Vpp_t *pVpp);
extern NvU8 VppGetVideoScalerBandwidthStatus(Vpp_t *pVpp, NvU16 wWidth);

extern int  VppWaitForNotification(NvNotification* pNotify, HDRVEVENT hEvent, unsigned long timeOut);
extern void VppResetNotification(NvNotification* pNotify, HDRVEVENT hEvent);

// Exported Functions
NvU8 VppEnable(
    Vpp_t           *pVpp,
    PDEV            *ppdev,
    CPushBuffer     *pPusher,
    NvU32            hChannel, 
    NvU32            hThreeDClass,
    NvU32            threeDClassSubCh,
    NvU32           *pThreeDClassLastUser,
    NvU32            hInVideoMemContextDma,
    NvU32            hFromVideoMemContextDma,
    NvU32            hToVideoMemContextDma,
    NvU32            hLutCursorDac,
    NvU32            hMiscEventNotifier,
    NvU32            hContextSurfaceSwizzled,
    NvU32            hContextBeta4,
    NvU32            hSurfaces2D,
    NvU32            surfaces2DSubCh,
    NvU32            hVideoMemUtoVideoMemFormat,    // U-conversion object
    NvU32            hVideoMemVtoVideoMemFormat,    // V-conversion object
    NvU32            hVideoMemUVtoVideoMemFormat,    // UV-conversion object
    NvU32            hDvdSubpicture,
    NvU32            hContextPattern,
    NvU32            hContextRop,
    NvU32            hContextColorKey,
    NvU32            hFloatingContextDmaInOverlayShadow,

    NvNotification  *pFlipPrimaryNotifier,  
    NvNotification  *pPusherSyncNotifier,
    NvNotification  *pUnused,

    NvU32            hContextSurfacesARGB_ZS,
    NvU32            hDX6MultiTextureTriangle,
    NvU32            hImageBlackRect,

    NvU32            ropRectTextSubCh,
    NvU32            ropSubCh,
    NvU32            spareSubCh);


NvU8 VppSetOverlayColourControl(Vpp_t *pVpp);

BOOL VppCreateOverlay(Vpp_t *pVpp);
void VppDestroyOverlay(Vpp_t *pVpp);
void VppDisable(Vpp_t *pVpp);
BOOL VppCreateFSMirror(Vpp_t *pVpp, DWORD dwWidth, DWORD dwHeight);
void VppDestroyFSMirror(Vpp_t *pVpp);
BOOL VppDoFlip(Vpp_t *pVpp,DWORD dwOffset, DWORD dwPitch, DWORD dwWidth,
                   DWORD dwHeight, DWORD dwFourCC, DWORD dwFlags);

#if (IS_WINNT5 | IS_WIN9X)
#define NV_GET_VIDEO_HEAP_FREE() (DWORD)vpp.pDriverData->VideoHeapFree

#elif (IS_WINNT4)
#define NV_GET_VIDEO_HEAP_FREE() (DWORD)vpp.pDriverData->ppdev->VideoHeapFree

#else
#error Unsupported OS.
#endif

/*
 * NV_ColorControl_t
 *    'Derived' from DDCOLORCONTROL for multi-OS compatibility
 */
#define NV_VPP_COLOR_BRIGHTNESS		0x00000001l // Field validity flags
#define NV_VPP_COLOR_CONTRAST		0x00000002l
#define NV_VPP_COLOR_HUE			0x00000004l
#define NV_VPP_COLOR_SATURATION		0x00000008l
#define NV_VPP_COLOR_SHARPNESS		0x00000010l
#define NV_VPP_COLOR_GAMMA			0x00000020l
#define NV_VPP_COLOR_COLORENABLE	0x00000040l

typedef struct {
    NvU32               dwLastFlags;
    NvU32               dwLastExec;
    NvU32               dwMarker1;
    NvU32               dwReserved1;

    LONGLONG            qwCount;    // TBD: what to do with LONGLONG? -@mjl@
    
    LONGLONG            qwInterFrameTime;
    LONGLONG            qwInterFrameAcc;
    LONGLONG            qwInterFramePeak;
    LONGLONG            qwInterFrameDelta;
    LONGLONG            qwInterFrameJitterAcc;
    LONGLONG            qwInterFrameJitterPeak;

    LONGLONG            qwIntraFrameAcc;
    LONGLONG            qwIntraFramePeak;
    LONGLONG            qwIntraFrameDelta;
    LONGLONG            qwIntraFrameJitterAcc;
    LONGLONG            qwIntraFrameJitterPeak;

    LONGLONG            qwMarker2;
    LONGLONG            qwReserved2;
} Vpp_snoop_t;


typedef struct NV_ColorControl_s
{
    NvU32 		dwSize;
    NvU32		dwFlags;
    NvS32		lBrightness;
    NvS32		lContrast;
    NvS32		lHue;
    NvS32 		lSaturation;
    NvS32		lSharpness;
    NvS32		lGamma;
    NvS32		lColorEnable;
    NvU32		dwReserved1;
} Nv_ColorControl_t;

// Experimental struct (may replace overlay corresponding vars with this as well)
typedef struct Nv_Surface_s
{
    NvU32       format; // TBD: enumerate - @mjl@
    NvU32       originX;
    NvU32       originY;
    NvU32       pitch;
    NvU32       width;
    NvU32       height;
    NvU32       offset; // General offset?  Unsure -@mjl@
} Nv_Surface_t;


typedef struct {
    NvU32               dwOpCount;
    HDRVEVENT           hLastStage;
    NvNotification     *pLastStageNotifier;
    HDRVEVENT           hLastFSStage;
    NvNotification     *pLastFSStageNotifier;
    NvU8                doLateFlipSync;
    NvU8                doFSMirror;
    NvU16               unused_01;
    NvU32               dwIndex;
    NvU32               dwSrcOffset;
    NvU32               dwSrcPitch;
    NvU32               dwWidth;
    NvU32               dwHeight;
    NvU32               dwFourCC;
    NvU32               dwFlags;
    NvU32               dwWorkSurfaces;
    NvU32               vppExec;
    NvU32               dwPrescaleFactorX;
    NvU32               dwPrescaleFactorY;
#ifdef VPP_SNOOP
    LONGLONG            qwTime1;
    LONGLONG            qwTime2;
    LONGLONG            qwDelta;
    LONGLONG            qwJitter;
#endif
} Vpp_pipeline_state_t;

// *********************************************************************
// Notesf on m_obj_a array:
//
// Note that the 2nd field is sometimes overwritten depending on the hardware.  Usually
// to conditionally 'upgrade' the class.
//
// The entries MUST remain in the order that corresponds to the indexes (see nvVPP.h)
//
// Any entries with NV_DD_ names are allocated by the main driver and NOT the vpp.  They are in
// this array to provide a consistent access point to a notifier pointer.  Since the status
// is set to VPP_OBJ_NA, the alloc/dealloc routines will ignore the object.
//  [NB: there are none like this right now - @mjl@]
//
// *********************************************************************

typedef struct {
	NvU16 status;	            // Allocated by VPP, FREED, NA or ERROR
	NvU16 classNdx;             // Index that identifies the class
	NvU32 classIID;	         	// Instance of this class
	NvU32 contextIID;	        // Instance of a DMA context used by this class
	int notifierCount;          // # of notifier slots used by <classNdx>
    NvNotification* notifier_a; // Length of array depends on the object
} VppObjectRecord_t;

#define  VPP_OBJECT_COUNT 11

// This list MUST match the one in nvVPP.cpp -- need a better way to do this...@mjl@
#define OVERLAY_NDX         0
#define SWIZZLE_NDX         1 
#define TIMER_NDX           2 
#define ALPHA_BLT_NDX       3 
#define V2V_FORMAT_NDX      4  
#define V2OSH_FORMAT_NDX    5 
#define OSH2V_FORMAT_NDX    6
#define SCALED_IMAGE1_NDX   7
#define SCALED_IMAGE2_NDX   8
#define DMABLT_TO_VID_NDX   9
#define DVDPICT_NDX        10


// Note: The 3D class object is used for "advanced" blts that are not possible
//  using the normal bltter.  Surfaces are treated as textures and texture ops
//  are applied to get the desired results.
//
// TBD: turn this into a proper class (if we can get away from C enough) - @mjl@
//
typedef struct Vpp_s
{
    NvU32            dwFlags; // General flags detailing state of the VPP object (see VPP_FLAG_*)

	NvU32            m_pContextDMABase;	// Address of a context DMA memory for VPP use

    DWORD            dwOverlayEventsAllocated;        // used to keep track of overlay event allocation

    GLOBALDATA      *pDriverData;           // Hope to eliminate this some day. -@mjl@

    PDEV            *m_ppdev;              // Hope to eliminate this some day. -@mjl@

    CPushBuffer     *pPusher;              // A cmd pusher class attached to a DMA push buffer
    NV_SystemInfo_t *pSysInfo;             // System Information
    NvU32           *pThreeDClassLastUser; // Last user of the 3d superclass (kelvin,celsius,...)

    CRegTool         regTool;              // A tool to access the system registry

    // Handles to objects created outside of the VPP
    NvU32            hImageBlackRect;
    NvU32            hContextPattern;
    NvU32            hContextRop;
    NvU32            hContextColorKey;
    NvU32            hFloatingContextDmaInOverlayShadow;
    NvU32            hVideoMemUtoVideoMemFormat;        // U-conversion object
    NvU32            hVideoMemVtoVideoMemFormat;        // V-conversion object
    NvU32            hVideoMemUVtoVideoMemFormat;       // UV-conversion object
    NvU32            hLutCursorDacBase;                 // Base object ID for DACs (1 per head)
    NvU32            hMiscEventNotifier;                // Used as the notifier in many cases
    NvU32            hContextSurfaceSwizzled;
    NvU32            hContextBeta4;
    NvU32            hSurfaces2D;
    NvU32            hChannel;
    NvU32            hThreeDClass;        // Unique object ID for the 3D object to be used
    NvU32            hInVideoMemContextDma;      // DMA context for V2V 
    NvU32            hFromVideoMemContextDma;    // DMA context for V2S
    NvU32            hToVideoMemContextDma;      // DMA context for S2V
    NvU32            hContextSurfacesARGB_ZS;
    NvU32            hDX6MultiTextureTriangle;

    // Notifiers created outside of the VPP

    NvNotification  *pFlipPrimaryNotifier;
    NvNotification  *pPusherSyncNotifier;

    // Sub-channel definitions

    NvU32            ropRectTextSubCh;
    NvU32            ropSubCh;
    NvU32            spareSubCh;          // General use subchannel (SetObject always done first)
    NvU32            surfaces2DSubCh;       // May be able to just use spare? -@mjl@
    NvU32            threeDClassSubCh;    // Subchannel that _always_ holds the 3D class object

    // TBD:hMiscEventNotifier was using NV_DD_DMA_COLOUR_CONTROL_EVENT_NOTIFIER which IS NV_DD_PIO_COLOUR_CONTROL_EVENT_NOTIFIER -@mjl@

    NvU32            dwOverlayFSNumSurfaces;
    NvU32            dwOverlayFSHead;    //what head is overlay on over is head on
    NvU32            dwOverlayFSOvlHead; // where mirror is
    NvU32            dwOverlayFSOvlHeadSaved;
    NvU32            dwOverlayFSOvlLost;

    NvU32            dwOverlayFSWidth;
    NvU32            dwOverlayFSHeight;
    NvU32            dwOverlayFSPitch;
    NvU32            dwOverlayFSFormat;
    NvU32            dwOverlayFSOffset[NV_VPP_MAX_EXTRA_FS_SURFACES];

    NvU32            dwOverlayFSIndex;
    NvU32            dwOverlayFSDeltaX;
    NvU32            dwOverlayFSDeltaY;

    // Size & offset of each of the extra surfaces used to run the VPP engine
    NvU32   extraOverlayOffset[NV_VPP_MAX_EXTRA_SURFACES];   // can be up to n "chunks" longer original surface
    NvU32   extraPitch;
    NvU32   extraNumSurfaces;
    NvU32   extraIndex; // Next 'extra' surface to be used

    NvU32   dwOverlaySurfaces;
    NvU32   dwOverlayOwner;
    NvU32   dwOverlaySurfaceLCL[NV_VPP_MAX_OVERLAY_SURFACES];
    NvU32   dwOverlaySrcWidth;
    NvU32   dwOverlaySrcHeight;
    NvU32   dwOverlayDstWidth;
    NvU32   dwOverlayDstHeight;
    NvU32   dwOverlayDeltaX;
    NvU32   dwOverlayDeltaY;

    NvU32   dwOverlaySrcX;          // overlay source starting point
    NvU32   dwOverlaySrcY;
    NvU32   dwOverlayDstX;        // overlay Dst starting point
    NvU32   dwOverlayDstY;
    NvU32   dwOverlaySrcOffset;
    NvU32   dwOverlayFormat;      // current overlay format - used so VDD knows what's up!
    NvU32   dwOverlaySrcPitch;    // current overlay pitch   - used so VDD knows what's up!
///
    NvU32   dwOverlayLastVisibleSurfaceLCL;
    NvU32   dwOverlayLastVisibleFpVidMem;
    NvU32   dwOverlayLastVisiblePitch;
    NvU32   dwOverlayLastVisiblePixelFormat;
    NvU32   dwOverlayFlipCount;
    NvU16   overlayBufferIndex;
    NvU16   overlayRelaxOwnerCheck;
    NvU32   dwOverlaySrcSize;
    NvU32   dwOverlayColorKey;

    NvU32                       dwOverlayCachedFlags;
    NvU32                       dwOverlayFSSrcWidth;
    NvU32                       dwOverlayFSSrcHeight;
    NvU32                       dwOverlayFSSrcMinX;
    NvU32                       dwOverlayFSSrcMinY;
    NVTWINVIEWDATA              dwOverlayFSTwinData;
    NvU32                       fpOverlayShadow;
    NvU32                       dwOverlayMaxDownScale;
    NvU32                       dwOverlayMaxDownScaleX;
    NvU32                       dwOverlayMaxDownScaleY;
    NvU32                       regOverlayColourControlEnable;
    NvU32                       dwOverlayByteAlignmentPad;
    NvU32                       regOverlayMode;
    NvU32                       regOverlayMode2;
    NvU32                       regOverlayMode3;
    NvU32                       regVPPInvMask;
    NvU32                       regVPPMaxSurfaces;

    NvU32                       dwDecoderIdentity;
    NvU32                       dwDecoderCaps;

    NvU32                       regRing0ColourCtlInterlockFlags;    // bit0 = 1 -> ring0 should run; bit2 = 1 ring0 in progress

    NvU32                       dwOverlayMode;            // used to tell if we're doing interleaved or what...
//    VPPDISPATCH                 vppDispatch;          No longer used.
///

    NvU32                       dwPrevFrameOffset;

    __int64                     llDeliveryPeriod;    // in ns
    __int64                     llDeliveryTime;      // in ns
    __int64                     llDeliveryStart;     // in ns

    Nv_ColorControl_t    colorCtrl;

    Nv_Surface_t         subPicture; // Dvd Subpicture

    Vpp_pipeline_state_t pipeState;

    Vpp_snoop_t          snoop;

    NvU32                dwNVOverlayFlags;

    VppObjectRecord_t    m_obj_a[VPP_OBJECT_COUNT];
} Vpp_t;

#define KELVIN_Z_SCALE24                16777215.0f  // 2^24 - 1

#define DEFAULT_KELVIN_ALPHA_OCW   (NV097_SET_COMBINER_ALPHA_OCW_OPERATION_NOSHIFT << 15) |        \
                                   (NV097_SET_COMBINER_ALPHA_OCW_MUX_ENABLE_FALSE << 14) |         \
                                   (NV097_SET_COMBINER_ALPHA_OCW_SUM_DST_REG_C << 8) |             \
                                   (NV097_SET_COMBINER_ALPHA_OCW_AB_DST_REG_0 << 4) |              \
                                    NV097_SET_COMBINER_ALPHA_OCW_CD_DST_REG_0

#define DEFAULT_KELVIN_COLOR_OCW (NV097_SET_COMBINER_COLOR_OCW_BLUETOALPHA_AB_DISABLE << 19) |  \
                                 (NV097_SET_COMBINER_COLOR_OCW_BLUETOALPHA_CD_DISABLE << 18) |  \
                                 (NV097_SET_COMBINER_COLOR_OCW_OP_NOSHIFT << 15) |              \
                                 (NV097_SET_COMBINER_COLOR_OCW_MUX_ENABLE_FALSE << 14) |        \
                                 (NV097_SET_COMBINER_COLOR_OCW_AB_DOT_ENABLE_FALSE << 13) |     \
                                 (NV097_SET_COMBINER_COLOR_OCW_CD_DOT_ENABLE_FALSE << 12) |     \
                                 (NV097_SET_COMBINER_COLOR_OCW_SUM_DST_REG_C << 8) |            \
                                 (NV097_SET_COMBINER_COLOR_OCW_AB_DST_REG_0 << 4) |             \
                                  NV097_SET_COMBINER_COLOR_OCW_CD_DST_REG_0

#define DEFAULT_KELVIN_ALPHA_ICW   (NV097_SET_COMBINER_ALPHA_ICW_A_MAP_UNSIGNED_IDENTITY << 29) |  \
                                   (NV097_SET_COMBINER_ALPHA_ICW_A_ALPHA_TRUE << 28) |             \
                                   (NV097_SET_COMBINER_ALPHA_ICW_A_SOURCE_REG_4 << 24) |           \
                                                                                                   \
                                   (NV097_SET_COMBINER_ALPHA_ICW_B_MAP_UNSIGNED_INVERT << 21) |    \
                                   (NV097_SET_COMBINER_ALPHA_ICW_B_ALPHA_TRUE << 20) |             \
                                   (NV097_SET_COMBINER_ALPHA_ICW_B_SOURCE_REG_0 << 16) |           \
                                                                                                   \
                                   (NV097_SET_COMBINER_ALPHA_ICW_C_MAP_UNSIGNED_IDENTITY << 13) |  \
                                   (NV097_SET_COMBINER_ALPHA_ICW_C_ALPHA_TRUE << 12) |             \
                                   (NV097_SET_COMBINER_ALPHA_ICW_C_SOURCE_REG_0 << 8) |            \
                                                                                                   \
                                   (NV097_SET_COMBINER_ALPHA_ICW_D_MAP_UNSIGNED_IDENTITY << 5) |   \
                                   (NV097_SET_COMBINER_ALPHA_ICW_D_ALPHA_TRUE << 4) |              \
                                    NV097_SET_COMBINER_ALPHA_ICW_D_SOURCE_REG_0

#define DEFAULT_KELVIN_COLOR_ICW   (NV097_SET_COMBINER_COLOR_ICW_A_MAP_UNSIGNED_IDENTITY << 29) |  \
                                   (NV097_SET_COMBINER_COLOR_ICW_A_ALPHA_FALSE << 28) |            \
                                   (NV097_SET_COMBINER_COLOR_ICW_A_SOURCE_REG_4 << 24) |           \
                                                                                                   \
                                   (NV097_SET_COMBINER_COLOR_ICW_B_MAP_UNSIGNED_INVERT << 21) |    \
                                   (NV097_SET_COMBINER_COLOR_ICW_B_ALPHA_FALSE << 20) |            \
                                   (NV097_SET_COMBINER_COLOR_ICW_B_SOURCE_REG_0 << 16) |           \
                                                                                                   \
                                   (NV097_SET_COMBINER_COLOR_ICW_C_MAP_UNSIGNED_IDENTITY << 13) |  \
                                   (NV097_SET_COMBINER_COLOR_ICW_C_ALPHA_FALSE << 12) |            \
                                   (NV097_SET_COMBINER_COLOR_ICW_C_SOURCE_REG_0 << 8) |            \
                                                                                                   \
                                   (NV097_SET_COMBINER_COLOR_ICW_D_MAP_UNSIGNED_IDENTITY << 5) |   \
                                   (NV097_SET_COMBINER_COLOR_ICW_D_ALPHA_FALSE << 4) |             \
                                    NV097_SET_COMBINER_COLOR_ICW_D_SOURCE_REG_0

#define DEFAULT_FINAL_CW0   (NV056_SET_COMBINER_SPECULAR_FOG_CW0_A_INVERSE_FALSE << 29) |   \
                            (NV056_SET_COMBINER_SPECULAR_FOG_CW0_A_ALPHA_FALSE << 28) |     \
                            (NV056_SET_COMBINER_SPECULAR_FOG_CW0_A_SOURCE_REG_0 << 24) |    \
                                                                                            \
                            (NV056_SET_COMBINER_SPECULAR_FOG_CW0_B_INVERSE_FALSE << 21) |   \
                            (NV056_SET_COMBINER_SPECULAR_FOG_CW0_B_ALPHA_FALSE << 20) |     \
                            (NV056_SET_COMBINER_SPECULAR_FOG_CW0_B_SOURCE_REG_0 << 16) |    \
                                                                                            \
                            (NV056_SET_COMBINER_SPECULAR_FOG_CW0_C_INVERSE_FALSE << 13) |   \
                            (NV056_SET_COMBINER_SPECULAR_FOG_CW0_C_ALPHA_FALSE << 12) |     \
                            (NV056_SET_COMBINER_SPECULAR_FOG_CW0_C_SOURCE_REG_0 << 8) |     \
                                                                                            \
                            (NV056_SET_COMBINER_SPECULAR_FOG_CW0_D_INVERSE_FALSE << 5) |    \
                            (NV056_SET_COMBINER_SPECULAR_FOG_CW0_D_ALPHA_FALSE << 4) |      \
                             NV056_SET_COMBINER_SPECULAR_FOG_CW0_D_SOURCE_REG_C

#define DEFAULT_KELVIN_FINAL_CW0   (NV097_SET_COMBINER_SPECULAR_FOG_CW0_A_INVERSE_FALSE << 29) |   \
                                   (NV097_SET_COMBINER_SPECULAR_FOG_CW0_A_ALPHA_FALSE << 28) |     \
                                   (NV097_SET_COMBINER_SPECULAR_FOG_CW0_A_SOURCE_REG_0 << 24) |    \
                                                                                                   \
                                   (NV097_SET_COMBINER_SPECULAR_FOG_CW0_B_INVERSE_FALSE << 21) |   \
                                   (NV097_SET_COMBINER_SPECULAR_FOG_CW0_B_ALPHA_FALSE << 20) |     \
                                   (NV097_SET_COMBINER_SPECULAR_FOG_CW0_B_SOURCE_REG_0 << 16) |    \
                                                                                                   \
                                   (NV097_SET_COMBINER_SPECULAR_FOG_CW0_C_INVERSE_FALSE << 13) |   \
                                   (NV097_SET_COMBINER_SPECULAR_FOG_CW0_C_ALPHA_FALSE << 12) |     \
                                   (NV097_SET_COMBINER_SPECULAR_FOG_CW0_C_SOURCE_REG_0 << 8) |     \
                                                                                                   \
                                   (NV097_SET_COMBINER_SPECULAR_FOG_CW0_D_INVERSE_FALSE << 5) |    \
                                   (NV097_SET_COMBINER_SPECULAR_FOG_CW0_D_ALPHA_FALSE << 4) |      \
                                    NV097_SET_COMBINER_SPECULAR_FOG_CW0_D_SOURCE_REG_C

// TBD: add CELSIUS to the following - @mjl@
#define DEFAULT_FINAL_CW1   (NV056_SET_COMBINER_SPECULAR_FOG_CW1_E_INVERSE_FALSE << 29) |   \
                            (NV056_SET_COMBINER_SPECULAR_FOG_CW1_E_ALPHA_FALSE << 28) |     \
                            (NV056_SET_COMBINER_SPECULAR_FOG_CW1_E_SOURCE_REG_0 << 24) |    \
                                                                                            \
                            (NV056_SET_COMBINER_SPECULAR_FOG_CW1_F_INVERSE_FALSE << 21) |   \
                            (NV056_SET_COMBINER_SPECULAR_FOG_CW1_F_ALPHA_FALSE << 20) |     \
                            (NV056_SET_COMBINER_SPECULAR_FOG_CW1_F_SOURCE_REG_0 << 16) |    \
                                                                                            \
                            (NV056_SET_COMBINER_SPECULAR_FOG_CW1_G_INVERSE_FALSE << 13) |   \
                            (NV056_SET_COMBINER_SPECULAR_FOG_CW1_G_ALPHA_TRUE << 12) |      \
                            (NV056_SET_COMBINER_SPECULAR_FOG_CW1_G_SOURCE_REG_C << 8) |     \
                                                                                            \
                            (NV056_SET_COMBINER_SPECULAR_FOG_CW1_SPECULAR_CLAMP_TRUE << 7) | \
                            (NV056_SET_COMBINER_SPECULAR_FOG_CW1_SPECULAR_ADD_INVERT_R5_FALSE << 6) | \
                             NV056_SET_COMBINER_SPECULAR_FOG_CW1_SPECULAR_ADD_INVERT_R12_FALSE

#define DEFAULT_KELVIN_FINAL_CW1   (NV097_SET_COMBINER_SPECULAR_FOG_CW1_E_INVERSE_FALSE << 29) |   \
                                   (NV097_SET_COMBINER_SPECULAR_FOG_CW1_E_ALPHA_FALSE << 28) |     \
                                   (NV097_SET_COMBINER_SPECULAR_FOG_CW1_E_SOURCE_REG_0 << 24) |    \
                                                                                                   \
                                   (NV097_SET_COMBINER_SPECULAR_FOG_CW1_F_INVERSE_FALSE << 21) |   \
                                   (NV097_SET_COMBINER_SPECULAR_FOG_CW1_F_ALPHA_FALSE << 20) |     \
                                   (NV097_SET_COMBINER_SPECULAR_FOG_CW1_F_SOURCE_REG_0 << 16) |    \
                                                                                                   \
                                   (NV097_SET_COMBINER_SPECULAR_FOG_CW1_G_INVERSE_FALSE << 13) |   \
                                   (NV097_SET_COMBINER_SPECULAR_FOG_CW1_G_ALPHA_TRUE << 12) |      \
                                   (NV097_SET_COMBINER_SPECULAR_FOG_CW1_G_SOURCE_REG_C << 8) |     \
                                                                                                   \
                                   (NV097_SET_COMBINER_SPECULAR_FOG_CW1_SPECULAR_CLAMP_TRUE << 7) | \
                                   (NV097_SET_COMBINER_SPECULAR_FOG_CW1_SPECULAR_ADD_INVERT_R5_FALSE << 6) | \
                                    NV097_SET_COMBINER_SPECULAR_FOG_CW1_SPECULAR_ADD_INVERT_R12_FALSE

#ifdef __cplusplus
}
#endif // __cplusplus

#define NV_MAX_EXTRA_FS_SURFACES 4

// Flags for vpp.dwFlags field
#define VPP_FLAG_CONSTRUCTED    0x00000001 // VPP class has been initialized
#define VPP_FLAG_ENABLED        0x00000002 // Resources have been assigned and VPP is ready to start
#define VPP_FLAG_OVERLAY_READY  0x00000004 // VPP is ready to run the overlay
#define VPP_FLAG_MIRROR_READY   0x00000008 // VPP is ready to run the full screen mirror
#define VPP_FLAG_CELSIUS_3D     0x00000010 // VPP is using a celsius class as it's 3D object
#define VPP_FLAG_KELVIN_3D      0x00000020 // VPP is using a kelvin class as it's 3D object


// Values for the status field of the m_obj_a[] array
//
#define VPP_OBJ_NA        0	// Ignore this entry.  Object is not applicable.
#define VPP_OBJ_FREED     1 // Needs to be allocated before next use
#define VPP_OBJ_ALLOCATED 2 // Has been allocated
#define VPP_OBJ_ERROR     3 // An error occured during allocation

// dwNVOverlayFlags values
#define OVERLAY_FLAG_ON_PANEL        0x00000001

// Using polling notifiers ALWAYS on an IKOS or NT4 build
//    events do not work properly on IKOS and are not available on NT4
//
//#if 1
#if defined(IKOS) || IS_WINNT4
#undef VPP_USE_EVENT_NOTIFIERS   // use event notifiers if this is defined, else use polling
#else
#define VPP_USE_EVENT_NOTIFIERS  // Win2k, Win9x...
#endif


// Note: The following assumes that all the WRITE_ONLY and WRITE_THEN_AWAKEN values are the
//    same for all objects. (NV039, NV056...) this IS the case.
//
#ifdef VPP_USE_EVENT_NOTIFIERS
#define VPP_NOTIFY_TYPE (NV039_BUFFER_NOTIFY_WRITE_THEN_AWAKEN)
#else
#define VPP_NOTIFY_TYPE (NV039_BUFFER_NOTIFY_WRITE_ONLY)
#pragma message ("VPP will not use events.")
#endif

#endif _NVVPP_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\common\inc\nvVer.h ===
// nvver.h
//      Versions of NV drivers
//
// Copyright (C) Microsoft Corporation 1993.
// Portions Copyright 1993,1996 NVidia Corporation. All Rights Reserved.
//

// The following version numbers are owned by Microsoft.  We have permission
// to change the last 3 digits of each version string but no other digits
// until the next major Microsoft release.
//
// NOTE: This release must be bumped up to 4.10... (0x040A...) when starting
// to build Win98 drivers
//
//
// The following #defines are used for the driver version number. They should be
// updated for each build and they should agree with each other.
//
// Also, because NV_DRIVER_VERSION has a leading 0, it can't be used as a number
// in drivers (it'll be interpretted as octal). And since it does contain non-octal
// values drivers should use NV_DRIVER_VERSION_NUMBER instead.
//
#ifndef WIN31
#define NV_DRIVER_VERSION              1440
#endif
#define NV_DRIVER_VERSION_NUMBER       1440
#define NV_VERSION_NUMBER               4,13,01,NV_DRIVER_VERSION
#define NV_VERSION_NUMBER_NT4           4,00,1381,NV_DRIVER_VERSION
#define NV_VERSION_NUMBER_NT5           5,13,01,NV_DRIVER_VERSION
#define NV_VERSION_NUMBER_DW            (0x0413010 | NV_DRIVER_VERSION)
#define NV_VERSION_STRING              "14.40"
#define NV_VERSION_MS_STRING           "4.13.01.1440\0"
#define NV_VERSION_MS_STRING_NT4       "4.00.1381.1440\0"
#define NV_VERSION_MS_STRING_NT5       "5.13.01.1440\0"

#define NV_COMPANY_NAME_STRING_SHORT    "NVIDIA"
#define NV_COMPANY_NAME_STRING_FULL     "NVIDIA Corporation"
#define NV_COMPANY_NAME_STRING          NV_COMPANY_NAME_STRING_FULL

#define NV04_PART_NAME_STRING           "RIVA TNT"
#define NV05_PART_NAME_STRING           "RIVA TNT2"
#define NV10_PART_NAME_STRING           "GeForce 256"
#define NV10GL_PART_NAME_STRING         "Quadro"
#define NV11_PART_NAME_STRING           "GeForce2 MX"
#define NV11GL_PART_NAME_STRING         "Quadro2 MXR"
#define NV15_PART_NAME_STRING           "GeForce2 GTS"
#define NV15GL_PART_NAME_STRING         "Quadro2 Pro"
#define NV20_PART_NAME_STRING           "GeForce3"
#define NV04_COMPAT_PART_NAME_STRING    NV_COMPANY_NAME_STRING_SHORT " Compatible"

#define NV_PART_NAME_STRING             NV04_COMPAT_PART_NAME_STRING



// #define MSBLD               // Defined for MS source builds only
                               // comment out for NVidia builds.
#ifndef MSBLD
#ifndef WIN32
#define VERSION                     NV_VERSION_MS_STRING
#endif


#ifndef _WIN32_WINNT
//
// Use NVidia standard version numbers for Win9x builds.
//
#define VER_PRODUCTVERSION_STR      NV_VERSION_MS_STRING
#define VER_PRODUCTVERSION          NV_VERSION_NUMBER
#define VER_PRODUCTVERSION_DW       NV_VERSION_NUMBER_DW
#else

//
// Use "standard" NT version numbers.
//
#include "ntverp.h"
#endif // #ifdef _WIN32_WINNT
#endif // #ifdef MSBLD




//
// NVDISP.drv NVidia Display Driver
//          Please update version in string below, DO NOT change
//          string, just the Number after Version.  It should
//          always look like this
//                  "NVidia Display driver, Version X.XX\0"
//
#define NV_NVDISPVER95  NV_PART_NAME_STRING " Windows 95/98 Display driver, Version " NV_VERSION_STRING " \0"

//
//

//
// NV.vxd NVidia Display MiniVDD
//          Please update version in string below, DO NOT change
//          string, just the Number after Version.  It should
//          always look like this
//                  "NVidia Display MiniVDD, Version X.XX\0"
//
#define NV_NVVDDVER     NV_PART_NAME_STRING " Display MiniVDD, Version " NV_VERSION_STRING " \0"
//
//


//
// NVDD32.DLL NVidia Direct Draw Driver
//          Please update version in string below, DO NOT change
//          string, just the Number after Version.  It should
//          always look like this
//                  "NVidia Direct Draw Driver, Version X.XX\0"
//
#define NV_NVDD32VER    NV_PART_NAME_STRING " Direct Draw Driver, Version " NV_VERSION_STRING " \0"
//
//
//
// NVCPL.DLL NVidia Control Panel Extension
//          Please update version in string below, DO NOT change
//          string, just the Number after Version.  It should
//          always look like this
//                  "NVidia Direct Draw Driver, Version X.XX\0"
//
#define NV_NVCPLVER    NV_COMPANY_NAME_STRING_SHORT " Display Properties Extension\0"


// NVQTWK.DLL NVidia Taskbar Utility Library
//          Please update version in string below, DO NOT change
//          string, just the Number after Version.  It should
//          always look like this
//                  "NVidia Direct Draw Driver, Version X.XX\0"
//
#define NV_NVTASKBARVER   NV_COMPANY_NAME_STRING_SHORT " Taskbar Utility Library\0"


// NVDESK32.DLL NVidia Desktop Manager Library
//          Please update version in string below, DO NOT change
//          string, just the Number after Version.  It should
//          always look like this
//                  "NVidia Direct Draw Driver, Version X.XX\0"
//
#define NV_NVDESKMGRVER   NV_COMPANY_NAME_STRING_SHORT " Desktop Manager Hook Library\0"


// NVSTERCP.DLL NVidia Stereo Control Panel
//          Please update version in string below, DO NOT change
//          string, just the Number after Version.  It should
//          always look like this
//                  "NVidia Direct Draw Driver, Version X.XX\0"
//
#define NV_NVSTERCPVER   NV_COMPANY_NAME_STRING_SHORT " Stereo Properties Extension\0"


// NVSVC*.DLL NVIDIA Driver Helper Service
//          Please update version in string below, DO NOT change
//          string, just the Number after Version.  It should
//          always look like this
//                  "NVidia Direct Draw Driver, Version X.XX\0"
//
#define NV_NVSVCVER   NV_COMPANY_NAME_STRING_SHORT " Driver Helper Service, Version " NV_VERSION_STRING "\0"


//
// NVDCI.drv NVidia DCI Driver
//          Please update version in string below, DO NOT change
//          string, just the Number after Version.  It should
//          always look like this
//                  "NVidia DCI driver, Version X.XX\0"
//
#define NV_NVDCIVER     NV_PART_NAME_STRING " DCI driver, Version " NV_VERSION_STRING " \0"
//
//

//
//
//
// NVINST32.DLL NVidia Driver Installation Library
//          Please update version in string below, DO NOT change
//          string, just the Number after Version.  It should
//          always look like this
//                  "NVidia Driver Insatllation Library, Version X.XX\0"
//
#define NV_NVINST32VER      NV_PART_NAME_STRING " Driver Install Library, Version " NV_VERSION_STRING " \0"

//
//
//
// NVINSTNT.DLL NVidia Driver Installation Library
//          Please update version in string below, DO NOT change
//          string, just the Number after Version.  It should
//          always look like this
//                  "NVidia Driver Insatllation Library, Version X.XX\0"
//
#define NV_NVINSTNTVER      NV_PART_NAME_STRING " Driver Install Library, Version " NV_VERSION_STRING " \0"

//
// NVRM NVidia Resource Manager
//          Please update version in string below, DO NOT change
//          string, just the Number after Version.  It should
//          always look like this
//                  "NVidia Resource Manager DLL, Version X.XX\0"
//
#define NV_NVRMVER      NV_PART_NAME_STRING " Resource Manager, Version " NV_VERSION_STRING " \0"
//
//


//
//
//
// NVDD32.DLL NVidia Direct Draw/Direct 3D Driver
//          Please update version in string below, DO NOT change
//          string, just the Number after Version.  It should
//          always look like this
//                  "NVidia Direct Draw 2.x Driver, Version X.XX\0"
//
//#define NV_D3D32VER     NV_PART_NAME_STRING " Direct Draw/Direct 3D Driver, Version " NV_VERSION_STRING " \0"
#define NV_DD32VER      NV_PART_NAME_STRING " Direct Draw/Direct 3D Driver, Version " NV_VERSION_STRING " \0"

//
//
//
// NV4_MINI.SYS NVidia Windows NT Miniport Driver
//          Please update version in string below, DO NOT change
//          string, just the Number after Version.  It should
//          always look like this
//                  "NVidia Windows NT Miniport Driver, Version X.XX\0"
//
#ifdef _WIN32_WINNT
#if (_WIN32_WINNT < 0x0500)
#define NV_NTMINIVER    NV_PART_NAME_STRING " Windows NT 4.0 Miniport Driver, Version " NV_VERSION_STRING " \0"
#else
#define NV_NTMINIVER    NV_PART_NAME_STRING " Windows 2000 Miniport Driver, Version " NV_VERSION_STRING " \0"
#endif // #else
#endif // #ifdef _WIN32_WINNT

//
//
//
// NV4_DISP.DLL NVidia Windows NT Display Driver
//          Please update version in string below, DO NOT change
//          string, just the Number after Version.  It should
//          always look like this
//                  "NVidia Windows NT Display Driver, Version X.XX\0"
//
#ifdef _WIN32_WINNT
#if (_WIN32_WINNT < 0x0500)
#define NV_NTDISPVER    NV_PART_NAME_STRING " Windows NT 4.0 Display driver, Version " NV_VERSION_STRING " \0"
#else
#define NV_NTDISPVER    NV_PART_NAME_STRING " Windows 2000 Display driver, Version " NV_VERSION_STRING " \0"
#endif // #else
#endif // #ifdef _WIN32_WINNT
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\common\inc\nv_name.h ===
typedef struct _CHIP_INFO
{
	ULONG   ulDevID;
	PWSTR   pwszChip;
	PWSTR   pwszAdapterString;
} CHIP_INFO;

CHIP_INFO   sChipInfo[] =
{
 // DEVICE ID  Chip ID name              Adapter ID Name
{0x0020,	L"RIVA TNT",		L"RIVA TNT"		},
{0x0028,	L"RIVA TNT2",		L"RIVA TNT2"		},
{0x002C,	L"Vanta",		L"Vanta"		},
{0x0029,	L"RIVA TNT2 Ultra",	L"RIVA TNT2 Ultra"	},
{0x002D,	L"RIVA TNT2 Model 64",	L"RIVA TNT2 Model 64"	},
{0x00A0,	L"Aladdin TNT2",	L"Aladdin TNT2"		},
{0x0100,	L"GeForce 256",		L"GeForce 256"		},
{0x0101,	L"GeForce DDR",		L"GeForce DDR"		},
{0x0103,	L"Quadro",		L"Quadro"		},
{0x0110,	L"GeForce2 MX",		L"GeForce2 MX"		},
{0x0111,	L"GeForce2 MX 100",	L"GeForce2 MX 100"	},
{0x0113,	L"Quadro2 MXR",		L"Quadro2 MXR"		},
{0x01A0,	L"GeForce2 Integrated GPU",	L"GeForce2 Integrated GPU"	},
{0x0150,	L"GeForce2 GTS",	L"GeForce2 GTS"		},
{0x0151,	L"GeForce2 GTS",	L"GeForce2 GTS"		},
{0x0152,	L"GeForce2 Ultra",	L"GeForce2 Ultra"	},
{0x0153,	L"Quadro2 Pro",		L"Quadro2 Pro"		},
{0x0200,	L"GeForce3",		L"GeForce3"		},
{0x0203,	L"Quadro DCC",		L"Quadro DCC"		},
{0x0112,	L"GeForce2 Go",		L"GeForce2 Go"	}
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\common\inc\StereoStats.h ===
/***************************************************************************\
* Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.            *
* THE INFORMATION CONTAINED HEREIN IS PROPRIETARY AND CONFIDENTIAL TO       *
* NVIDIA, CORPORATION.  USE, REPRODUCTION OR DISCLOSURE TO ANY THIRD PARTY  *
* IS SUBJECT TO WRITTEN PRE-APPROVAL BY NVIDIA, CORPORATION.                *
*                                                                           *
*  Portions: Copyright (C) 1995 Microsoft Corporation.  All Rights Reserved.*
*                                                                           *
* Module: StereoStats.h                                                     *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*       Andrei Osnovich    03/13/01  Created                                *
*                                                                           *
\***************************************************************************/

#ifndef _STEREO_STATS_H_
#define _STEREO_STATS_H_

// This structure is provided in return to the GetStereoStats call to the drivers. It contains all 
// stereo information required to build and display the application behaviour graph. 
typedef struct _Stereo_Stats_S {
    DWORD   dwFlags;
    // General settings.
    DWORD   dwWidth;
    DWORD   dwHeight;
    DWORD   dwBpp;
    // General stereo settings.
    float   StereoSeparation;
    float   StereoConvergence;
    // Frustum settings defined for HW TnL only.
    float   ZNear;
    float   ZFar;
    // Stereo settings defined for D3D & SW TnL only.
    float   RHWGreaterAtScreen; //No Stereo Start RHW boundary from the front side
    float   RHWLessAtScreen;    //No Stereo Start RHW boundary from the back side
    // Various useful stereo stats defined for D3D & SW TnL only (Used in ConfigAssist mode).
    float   rhwMin;
    float   rhwMax;
    float   rhwMin2D;
    float   rhwMax2D;
} STEREOSTATS, *LPSTEREOSTATS;

// Values that can be ORed in the dwFlags field of the STEREOSTATS structure
#define OPENGL_API              0x00000001      //If not present then D3D.
#define HW_TnL                  0x00000002      //If not present then SW TnL.
#define RHWGREATERATSCREEN      0x00000004      //RHWGreaterAtScreen is valid.
#define RHWLESSATSCREEN         0x00000008      //RHWLessAtScreen is valid.
#define CONFIGASSISTON          0x00000010      //ConfigAssist data is valid.

#endif  //_STEREO_STATS_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\common\inc\targa.h ===
// **************************************************************************
//
//       Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.
//
//     NOTICE TO USER:   The source code  is copyrighted under  U.S. and
//     international laws.  Users and possessors of this source code are
//     hereby granted a nonexclusive,  royalty-free copyright license to
//     use this code in individual and commercial software.
//
//     Any use of this source code must include,  in the user documenta-
//     tion and  internal comments to the code,  notices to the end user
//     as follows:
//
//       Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.
//
//     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY
//     OF  THIS SOURCE  CODE  FOR ANY PURPOSE.  IT IS  PROVIDED  "AS IS"
//     WITHOUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPOR-
//     ATION DISCLAIMS ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,
//     INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY, NONINFRINGE-
//     MENT,  AND FITNESS  FOR A PARTICULAR PURPOSE.   IN NO EVENT SHALL
//     NVIDIA, CORPORATION  BE LIABLE FOR ANY SPECIAL,  INDIRECT,  INCI-
//     DENTAL, OR CONSEQUENTIAL DAMAGES,  OR ANY DAMAGES  WHATSOEVER RE-
//     SULTING FROM LOSS OF USE,  DATA OR PROFITS,  WHETHER IN AN ACTION
//     OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  ARISING OUT OF
//     OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOURCE CODE.
//
//     U.S. Government  End  Users.   This source code  is a "commercial
//     item,"  as that  term is  defined at  48 C.F.R. 2.101 (OCT 1995),
//     consisting  of "commercial  computer  software"  and  "commercial
//     computer  software  documentation,"  as such  terms  are  used in
//     48 C.F.R. 12.212 (SEPT 1995)  and is provided to the U.S. Govern-
//     ment only as  a commercial end item.   Consistent with  48 C.F.R.
//     12.212 and  48 C.F.R. 227.7202-1 through  227.7202-4 (JUNE 1995),
//     all U.S. Government End Users  acquire the source code  with only
//     those rights set forth herein.
//
// ********************************* Direct 3D ******************************
//
//  Module: targa.h
//      header files for targa.c
//
// **************************************************************************
//
//  History:
//      Craig Duttweiler        12Jun00         filched from architects
//
// **************************************************************************

#ifndef __TARGA_H
#define __TARGA_H

typedef char int8;
typedef int int16;
typedef int int32;
typedef unsigned char uint8;
typedef unsigned int uint16;
typedef unsigned int uint32;

/* Header definition. */
typedef struct TGA_Header_  {
    unsigned char ImageIDLength;        /* length of Identifier String. */
    unsigned char CoMapType;            /* 0 = no map */
    unsigned char ImgType;              /* image type (see below for values) */
    unsigned char Index_lo, Index_hi;   /* index of first color map entry */
    unsigned char Length_lo, Length_hi; /* number of entries in color map */
    unsigned char CoSize;               /* size of color map entry (15,16,24,32) */
    unsigned char X_org_lo, X_org_hi;   /* x origin of image */
    unsigned char Y_org_lo, Y_org_hi;   /* y origin of image */
    unsigned char Width_lo, Width_hi;   /* width of image */
    unsigned char Height_lo, Height_hi; /* height of image */
    unsigned char PixelSize;            /* pixel size (8,16,24,32) */
    unsigned char Desc;         /* 4 bits, number of attribute bits per pixel */
} TGA_Header;

/* if we create the tga file, we will put the following in the ImageID field */
typedef struct TGA_ImageId_ {
        unsigned char Magic;            /* must be a specific magic value */
        unsigned char ImageFmt;         /* encodes special raster formats */
} TGA_ImageId;

/* Definitions for image types. */
#define TGA_NULL 0
#define TGA_MAP 1
#define TGA_RGB 2
#define TGA_MONO 3
#define TGA_RLEMAP 9
#define TGA_RLERGB 10
#define TGA_RLEMONO 11

#define TGA_DESC_ALPHA_MASK     ((unsigned char)0xF)    /* number of alpha channel bits */
#define TGA_DESC_ORG_MASK       ((unsigned char)0x30)   /* origin mask */
#define TGA_ORG_BOTTOM_LEFT     0x00
#define TGA_ORG_BOTTOM_RIGHT    0x10
#define TGA_ORG_TOP_LEFT        0x20
#define TGA_ORG_TOP_RIGHT       0x30har)0x30)   /* origin mask */
#define TGA_ORG_BOTTOM_LEFT     0x00
#define TGA_ORG_BOTTOM_RIGHT    0x10

#define TGA_NVIDIA_MAGIC        0xAF            /* not an ascii char so unlikely... */

typedef enum RasterFormat_ {
/* WARNING WARNING WARNING WARNING WARNING WARNING WARNING WARNING WARNING WARNING WARNING
 * **** The RasterFormat defs _must_ be identical to the defs in vmodels/rasterDefs.vh ***
 * **** Do not change this enum without also updating rasterDefs.vh!                   ***
 * WARNING WARNING WARNING WARNING WARNING WARNING WARNING WARNING WARNING WARNING WARNING */
        RASTER_A1R5G5B5 = 0,
        RASTER_X1R5G5B5 = 1,
        RASTER_A4R4G4B4 = 2,
        RASTER_R5G6B5 = 3,
        RASTER_A8R8G8B8 = 4,
        RASTER_X8R8G8B8 = 5,
        RASTER_Y8 = 6,
        RASTER_V8YB8U8YA8 = 7,
        RASTER_YB8V8YA8U8 = 8,
        RASTER_A8V8U8Y8 = 9,                    // A8Y8U8V8 was incorrect channel ordering, name changed
        RASTER_A4V6YB6A4U6YA6 = 10,
        RASTER_AY8 = 11,
        RASTER_Z16 = 12,                                // 16 bit Z/W buffer
        RASTER_Z24S8 = 13,                              // 24 bit Z/W plus 8 bit stencil in low 8 bits
// additional non-Nvidia formats for ease of use with tga
        RASTER_VOID32 = 100,                    // generic 32 bits/pixel format
        RASTER_R8G8B8 = 101,                    // 24 bits/pixel
        RASTER_VOID16 = 102,                    // generic 16 bits/pixel format
        RASTER_FORCELONG = 0x7FFFFFFFL  // force this enum to be a long
} RasterFormat;

// Read targa file "filename"
// Put pixels into **xbgr, and set *width and *height
// Pixels are xbgr words on the PC
// This routine copes with raw RGB and run-length encoded RGB targa files only

int read_targa_file(char *filename, unsigned char **xrgb, int *width, int *height);

#endif  // __TARGA_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\common\inc\popupagent.h ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright 1993-2001 NVIDIA, Corporation.  All rights reserved.
// THE INFORMATION CONTAINED HEREIN IS PROPRIETARY AND CONFIDENTIAL TO
// NVIDIA, CORPORATION.  USE, REPRODUCTION OR DISCLOSURE TO ANY THIRD PARTY
// IS SUBJECT TO WRITTEN PRE-APPROVAL BY NVIDIA, CORPORATION
//
// Module: pupagent.h
//
// Description: This header describes the API for creating a popup tool
//				that works with the NVIDIA Stereo Driver.
//
///////////////////////////////////////////////////////////////////////////////
#ifndef		STEREO_POPUP_AGENTS_DECL
#define		STEREO_POPUP_AGENTS_DECL

#include "StereoStats.h"
#include <windows.h>

///////////////////////////////////////////////////////////
// Forward declarations
//////////////////////////////////////////////////////////
class CPopupAgentBase;
class CVertexBuffer;
class CVertexShader;

class Vertex {
public:
	float sx; /* Screen coordinates */
	float sy;
	float sz;
	float rhw; /* Reciprocal of homogeneous w */
	DWORD color; /* Vertex color */
	DWORD specular; /* Specular component of vertex */
	float tu; /* Texture coordinates */
	float tv;
};

#define D3DFVF_POPUP_VERTEX (D3DFVF_XYZRHW|D3DFVF_DIFFUSE|D3DFVF_SPECULAR|D3DFVF_TEX1)

///////////////////////////////////////////////////////////
// Function prototypes
///////////////////////////////////////////////////////////
// Callback for each flip
typedef HRESULT (__cdecl *FlipCallbackType)(CPopupAgentBase *pPopupAgent);

// Function defined by the agent provider and accessed/called by the driver to enable the popup
typedef HRESULT (__cdecl *InitPopupAgentType)(CPopupAgentBase *pPopupAgent);
typedef HRESULT (__cdecl *DestroyPopupAgentType)(CPopupAgentBase *pPopupAgent);

///////////////////////////////////////////////////////////
// Flags
///////////////////////////////////////////////////////////
#define RTF_NOTEXTURE 1 // This flag tells the RenderTriangle(...) call to not use the texture when rendering the triangles

///////////////////////////////////////////////////////////
// CPopupAgent: Interface specification for the popup 
// agent, holds all of the information passed from the 
// driver to the external popup code.
///////////////////////////////////////////////////////////
class CPopupAgentBase {
public:
	enum // Popup Agent IDs. Used to distinguish the type of the agent.
	{
		LASER_SIGHT_ID		= 1,   
		NVIDIA_LOGO_ID		= 2,
		PERF_STATS_ID		= 3,
		STEREO_STATS_ID		= 4,
		MESSENGER_ID		= 5,
		CUSTOM_ID			= 9999,
		UNKNOWN_ID			= 0xFFFFFFFF
	};
public:
	CPopupAgentBase() : m_pvUserData(NULL), m_dwAgentID(UNKNOWN_ID), m_pNextAgent(NULL), m_dwTexture(0), m_pFlipCallback(NULL) {}

	// Sets the callback called every frame, this is where the agent will do the drawing
	void SetFlipCallback(FlipCallbackType pFlipCallback) {m_pFlipCallback = pFlipCallback;}
	FlipCallbackType GetFlipCallback() {return(m_pFlipCallback);}

	// User data functions
	void*					GetUserData() {return(m_pvUserData);}
	void					SetUserData(void *pvUserData) {m_pvUserData = pvUserData;}
	// Agent IDs allowing multiple agent providers
	DWORD					GetAgentID() {return(m_dwAgentID);}
	//void					SetAgentID(DWORD dwAgentID) {m_dwAgentID = dwAgentID;}
	CPopupAgentBase*		GetNextAgent() {return m_pNextAgent;};
    void                    SetNextAgent(CPopupAgentBase* pThat) {m_pNextAgent = pThat;};
	// Create the 16bit texture map available from the driver, initialize it with pusData
	virtual HRESULT			CreateTextureMap(DWORD dwWidth, DWORD dwHeight, DWORD dwColorKey, unsigned short *pusData) = 0;
	// Call through to the driver to render triangles
	virtual HRESULT			RenderTriangles(Vertex *pVertexData, unsigned short *pusIndexData, int nIndexCount, DWORD dwFlags) = 0;

protected:
	void                   *m_pvUserData;
	DWORD                   m_dwAgentID;
	CPopupAgentBase        *m_pNextAgent; // Points to the next agent in the list
	DWORD                   m_dwTexture;
	FlipCallbackType        m_pFlipCallback;
};

class CTexture;
class CNvObject;

class CPopupAgent : public CPopupAgentBase 
{
protected: //attributes
	CTexture*				pTexture;
	CNvObject*				pTextureObj;
	NVD3DCONTEXT*			pContext;
	HMODULE					hMod;
	CVertexBuffer*			pVB;
	CVertexShader*			pVS;
protected: //methods
	void					destroyTexture();
	void					destroyVertexData();
	HRESULT					createVertexData();
	HRESULT					setupStates(DWORD dwFlags);
	HRESULT					restoreStates(DWORD dwFlags);

public: //methods
	CPopupAgent();
	virtual ~CPopupAgent();
	
    HRESULT         bindPopupAgent( HMODULE hmod );
	HRESULT			unbindPopupAgent( );
	void			setContext(NVD3DCONTEXT* aContext) {pContext = aContext;};
	
	virtual HRESULT CreateTextureMap(DWORD dwWidth, DWORD dwHeight, DWORD dwColorKey, unsigned short *pusData);
	virtual HRESULT RenderTriangles(Vertex *pVertexData, unsigned short *pusIndexData, int nIndexCount, DWORD dwFlags);
};
/*
class CPerfStatPopup: public CPopupAgent, protected STEREOSTATS  
{
public:
	CPerfStatPopup();
	virtual ~CPerfStatPopup();
	
	STEREOSTATS*	get() {return (STEREOSTATS*)this;}; 
	void			setContext(NVD3DCONTEXT* aContext); //extract performance data from context
};

class CPopupAgentList
{
protected:
	CPopupAgent*	popupAgentList;
public:
	CPopupAgentList();
	~CPopupAgentList();
	HRESULT			create();
	HRESULT			destroy();
	HRESULT			render(NVD3DCONTEXT *pContext);
};
  */
  /*
//exported functions (to nvStereo.cpp)
extern	HRESULT			createPopupList();
extern	HRESULT			destroyPopupList();
extern	HRESULT			renderPopupList(NVD3DCONTEXT *pContext);
*/
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\common\inc\StereoDDK.h ===
/***************************************************************************\
* Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.            *
* THE INFORMATION CONTAINED HEREIN IS PROPRIETARY AND CONFIDENTIAL TO       *
* NVIDIA, CORPORATION.  USE, REPRODUCTION OR DISCLOSURE TO ANY THIRD PARTY  *
* IS SUBJECT TO WRITTEN PRE-APPROVAL BY NVIDIA, CORPORATION.                *
*                                                                           *
*  Portions: Copyright (C) 1995 Microsoft Corporation.  All Rights Reserved.*
*                                                                           *
* Module: StereoDDK.h                                                       *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*       Andrei Osnovich    02/02/00  Created                                *
*                                                                           *
\***************************************************************************/

#ifndef _STEREO_DDK_H_
#define _STEREO_DDK_H_

/*
 * Bit flags defining supported stereo viewing formats.
 */
#define SVF_NONE                0
#define SVF_OVERANDUNDER        0x00000001
#define SVF_FRAMESEQUENTIAL     0x00000002
#define SVF_MULTIMONITOR        0x00000004
#define SVF_LEFTANDRIGHT        0x00000008
#define SVF_LINEINTERLEAVE      0x00000010

/*
 * Activation Methods.
 */
#define SAM_VRAMPATTERN         0x00000001
#define SAM_DDC                 0x00000002
#define SAM_MANUAL              0x00000004

typedef DWORD   (WINAPI *LPDEACTIVATESTEREO)(void);

typedef struct _GraphicsServices_s
{
    DWORD               dwSize;
    DWORD               dwFlags;
    LPDEACTIVATESTEREO  DeactivateStereo;
} GRAPHICSSERVICES, *LPGRAPHICSSERVICES;

typedef DWORD   (FAR PASCAL *LPONFLIP)(void);

typedef struct _StereoViewerServices_s
{
    DWORD            dwSize;
    DWORD            dwFlags;
    LPONFLIP         OnFlip;
} STEREOVIEWERSERVICES, *LPSTEREOVIEWERSERVICES;

/*
 * Bits defining valid fields in the StereoCaps structure.
 */
#define STEREOCAPS_SUPPORTEDFORMATS     0x00000001
#define STEREOCAPS_PREFERREDFORMAT      0x00000002
#define STEREOCAPS_MINREFRESHRATE       0x00000004
#define STEREOCAPS_MAXREFRESHRATE       0x00000008
#define STEREOCAPS_ACTIVATIONMETHOD     0x00000010
#define STEREOCAPS_SERVICECALLBACKS     0x00000020

typedef struct StereoCaps
{
    DWORD dwSize;               //Indicates the version both ways.
    DWORD dwFlags;              //Indicates the valid fields both ways.
    DWORD dwSupportedFormats;
    DWORD dwPreferredFormat;
    WORD  dwMinRefreshRate;
    WORD  dwMaxRefreshRate;
    DWORD dwActivationMethod;
    union 
    {
        LPGRAPHICSSERVICES       pGraphicsServices;    
        LPSTEREOVIEWERSERVICES   pStereoViewerServices;
    };
} STEREOCAPS, *LPSTEREOCAPS;

#ifdef __cplusplus

typedef class CStereoViewer
{
    /*
     * methods
     */
public:
    virtual DWORD WINAPI DestroyStereoViewer(void);
	virtual DWORD WINAPI GetCaps(LPSTEREOCAPS);
    virtual DWORD WINAPI ActivateStereo(LPDDHALMODEINFO pVideoMode, LPVOID pScreenAddr, DWORD StereoFormat);
    virtual DWORD WINAPI DeactivateStereo(LPDDHALMODEINFO pVideoMode, LPVOID pScreenAddr, DWORD StereoFormat);
} STEREOVIEWER, *LPSTEREOVIEWER;

#else   //__cplusplus==0

typedef struct CStereoViewer
{
    struct  CStereoViewerVtbl FAR *lpVtbl;
} STEREOVIEWER, *LPSTEREOVIEWER;

struct  CStereoViewerVtbl {
    DWORD (WINAPI *DestroyStereoViewer)(LPSTEREOVIEWER);
	DWORD (WINAPI *GetCaps)(LPSTEREOVIEWER, LPSTEREOCAPS);
    DWORD (WINAPI *ActivateStereo)(LPSTEREOVIEWER, LPVOID pVideoMode, LPVOID pScreenAddr, DWORD StereoFormat);
    DWORD (WINAPI *DeactivateStereo)(LPSTEREOVIEWER, LPVOID pVideoMode, LPVOID pScreenAddr, DWORD StereoFormat);
};

#endif  //__cplusplus==0


typedef DWORD (WINAPI *LPCREATESTEREOVIEWER)(LPSTEREOVIEWER *);

#define _FACSTEREO  (*(WORD *)"NV")
#define MAKE_STEREOHRESULT( code )  MAKE_HRESULT( 1, _FACSTEREO, code )

/*
 * Error codes
 */
#define STEREO_OK                               0
#define STEREO_UNSUPPORTED_STEREO_FORMAT        MAKE_STEREOHRESULT(1)
#define STEREO_UNSUPPORTED_VIDEO_MODE           MAKE_STEREOHRESULT(2)
#define STEREO_UNSUPPORTED_REFRESHRATE          MAKE_STEREOHRESULT(3)
#define STEREO_INVALID_PARAMETERS               MAKE_STEREOHRESULT(4)
#define STEREO_HARDWARE_NOT_FOUND               MAKE_STEREOHRESULT(5)
#define STEREO_UNKNOWN_ERROR                    MAKE_STEREOHRESULT(6)

#endif  //_STEREO_DDK_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\common\inc\vtxpgmcomp.h ===
/*
** vtxpgmcomp.h
**
** Vertex Program Declarations.
**
** Copyright 2000 NVIDIA, Corporation.  All rights reserved.
**
** THE INFORMATION CONTAINED HEREIN IS PROPRIETARY AND CONFIDENTIAL TO
** NVIDIA, CORPORATION.  USE, REPRODUCTION OR DISCLOSURE TO ANY THIRD PARTY
** IS SUBJECT TO WRITTEN PRE-APPROVAL BY NVIDIA, CORPORATION.
*/

/*
** This file is shared between OpenGL and D3D so don't mess with it!
**
** In particular, don't use any OpenGL or D3D specific types.  There are
** plenty of perfectly good types in the C language itself.
**
*/

#ifndef __gl_vtxpgmcomp_h_
#define __gl_vtxpgmcomp_h_

#include "vtxpgmconsts.h"

#define NV_INTERNAL_OPCODES 1

/*
** Optimization flags:
*/

#define OPT_LIVE_DEAD 1
#define OPT_HPOS_ONLY 2
#define OPT_ALL       1

/*
** Structures for instruction description.
*/

typedef enum OpcodeClasses_Enum {
    CLASS_ARL = 0,
    CLASS_VECTOR,
    CLASS_SCALAR,
    CLASS_BIN,
    CLASS_TRI,
#if defined(NV_INTERNAL_OPCODES)
    CLASS_NOP,
#endif
    CLASS_END,
} OpcodeClasses;

typedef enum Opcodes_Enum {

    // END op:

    OP_END = 0,
#if defined(NV_INTERNAL_OPCODES)
    OP_NOP,
#endif

    // ARL op:

    OP_ARL,

    // VECTOR ops:

    OP_LIT, OP_MOV,
#if defined(NV_INTERNAL_OPCODES)
    OP_IMV,
#endif

    // SCALAR ops:

    OP_EXP, OP_LOG, OP_RCP, OP_RSQ,
#if defined(NV_INTERNAL_OPCODES)
    OP_RCC,
#endif

    // BIN ops:

    OP_ADD, OP_DP3, OP_DP4, OP_DST, OP_MAX, OP_MIN, OP_MUL, OP_SGE, OP_SLT,
#if defined(NV_INTERNAL_OPCODES)
    OP_DPH,
#endif

    // TRI op:

    OP_MAD,
} Opcodes;

#define VERTEX_PROGRAM_OPCODE_NAMES                                         \
    "END", "NOP",                                                           \
    "ARL",                                                                  \
    "LIT", "MOV", "IMV",                                                    \
    "EXP", "LOG", "RCP", "RSQ", "RCC",                                      \
    "ADD", "DP3", "DP4", "DST", "MAX", "MIN", "MUL", "SGE", "SLT", "DPH",   \
    "MAD",

typedef enum Component_Enum {
    XX = 0, YY, ZZ, WW,
} Component_t;

typedef enum Component4_Enum {
    XYZW = (XX | YY << 2 | ZZ << 4 | WW << 6),
} Component4;

typedef enum DestMaskBits_Enum {
    DST_NONE_BITS = 0,
    DST_X_BIT = 1, DST_Y_BIT = 2, DST_Z_BIT = 4, DST_W_BIT = 8,
    DST_YZ_BITS = 6,
    DST_XYZ_BITS = 7,
    DST_XYW_BITS = 11,
    DST_XYZW_BITS = 15,
} DestMaskBits;

typedef enum Register_Enum {

    VA_0 = 0,   VA_OPOS = 0,  VA_1 = 1,   VA_WGHT = 1,
    VA_2 = 2,   VA_NRML = 2,  VA_3 = 3,   VA_COL0 = 3,
    VA_4 = 4,   VA_COL1 = 4,  VA_5 = 5,   VA_FOGC = 5,
    VA_6 = 6,                 VA_7 = 7,
    VA_8 = 8,   VA_TEX0 = 8,  VA_9 = 9,   VA_TEX1 = 9,
    VA_10 = 10, VA_TEX2 = 10, VA_11 = 11, VA_TEX3 = 11,
    VA_12 = 12, VA_TEX4 = 12, VA_13 = 13, VA_TEX5 = 13,
    VA_14 = 14, VA_TEX6 = 14, VA_15 = 15, VA_TEX7 = 15,

    VR_0 = 16,  VR_HPOS = VR_0,
    VR_1 = 17,  
    VR_2 = 18,  
    VR_3 = 19,  VR_COL0 = VR_3,
    VR_4 = 20,  VR_COL1 = VR_4,
    VR_5 = 21,  VR_FOGC = VR_5,
    VR_6 = 22,  VR_PSIZ = VR_6,
    VR_7 = 23,  VR_BFC0 = VR_7,
    VR_8 = 24,  VR_BFC1 = VR_8,
    VR_9 = 25,  VR_TEX0 = VR_9,
    VR_10 = 26, VR_TEX1 = VR_10,
    VR_11 = 27, VR_TEX2 = VR_11,
    VR_12 = 28, VR_TEX3 = VR_12,
    VR_13 = 29, VR_TEX4 = VR_13,
    VR_14 = 30, VR_TEX5 = VR_14,
    VR_15 = 31, VR_TEX6 = VR_15, VR_TEX7 = VR_15,

    PR_0 = 32,   PR_1 = 33,   PR_2 = 34,   PR_3 = 35,
    PR_4 = 36,   PR_5 = 37,   PR_6 = 38,   PR_7 = 39,
    PR_8 = 40,   PR_9 = 41,   PR_10 = 42,  PR_11 = 43,
    PR_12 = 44,  PR_13 = 45,  PR_14 = 46,  PR_15 = 47,
    PR_16 = 48,  PR_17 = 49,  PR_18 = 50,  PR_19 = 51,
    PR_20 = 52,  PR_21 = 53,  PR_22 = 54,  PR_23 = 55,
    PR_24 = 56,  PR_25 = 57,  PR_26 = 58,  PR_27 = 59,
    PR_28 = 60,  PR_29 = 61,  PR_30 = 62,  PR_31 = 63,
    PR_32 = 64,  PR_33 = 65,  PR_34 = 66,  PR_35 = 67,
    PR_36 = 68,  PR_37 = 69,  PR_38 = 70,  PR_39 = 71,
    PR_40 = 72,  PR_41 = 73,  PR_42 = 74,  PR_43 = 75,
    PR_44 = 76,  PR_45 = 77,  PR_46 = 78,  PR_47 = 79,
    PR_48 = 80,  PR_49 = 81,  PR_50 = 82,  PR_51 = 83,
    PR_52 = 84,  PR_53 = 85,  PR_54 = 86,  PR_55 = 87,
    PR_56 = 88,  PR_57 = 89,  PR_58 = 90,  PR_59 = 91,
    PR_60 = 92,  PR_61 = 93,  PR_62 = 94,  PR_63 = 95,
    PR_64 = 96,  PR_65 = 97,  PR_66 = 98,  PR_67 = 99,
    PR_68 = 100, PR_69 = 101, PR_70 = 102, PR_71 = 103,
    PR_72 = 104, PR_73 = 105, PR_74 = 106, PR_75 = 107,
    PR_76 = 108, PR_77 = 109, PR_78 = 110, PR_79 = 111,
    PR_80 = 112, PR_81 = 113, PR_82 = 114, PR_83 = 115,
    PR_84 = 116, PR_85 = 117, PR_86 = 118, PR_87 = 119,
    PR_88 = 120, PR_89 = 121, PR_90 = 122, PR_91 = 123,
    PR_92 = 124, PR_93 = 125, PR_94 = 126, PR_95 = 127,

    TR_0 = 128,  TR_1 = 129,  TR_2 = 130,  TR_3 = 131,
    TR_4 = 132,  TR_5 = 133,  TR_6 = 134,  TR_7 = 135,
    TR_8 = 136,  TR_9 = 137,  TR_10 = 138, TR_11 = 139,
    TR_12 = 140, TR_13 = 141, TR_14 = 142, TR_15 = 143,

    ARL = 144,

    ZER = 145,

    PPR_0 = 146, PPR_23 = 169, PPR_58 = 204, PPR_59 = 205, PPR_62 = 208,

} Register_t;

typedef struct SrcReg_Rec {
    Register_t reg;
    unsigned char AddrReg;
    int addrRegOffset;
} SrcReg;

typedef struct ScalarSrcReg_Rec {
    SrcReg reg;
    Component_t com;
    unsigned char Signed;
} ScalarSrcReg;

typedef struct SwizzleSrcReg_Rec {
    SrcReg reg;
    unsigned char com4;
    unsigned char Signed;
} SwizzleSrcReg;

typedef struct MaskedDstReg_Rec {
    Register_t reg;
    unsigned char mask;
} MaskedDstReg;

typedef struct Arl_Instruction_Rec {
    Opcodes opcode;
    OpcodeClasses opclass;

    ScalarSrcReg src;
} Arl_Instruction;

typedef struct Vector_Instruction_Rec {
    Opcodes opcode;
    OpcodeClasses opclass;

    MaskedDstReg dst;
    SwizzleSrcReg src;
} Vector_Instruction;

typedef struct Scalar_Instruction_Rec {
    Opcodes opcode;
    OpcodeClasses opclass;

    MaskedDstReg dst;
    ScalarSrcReg src;
} Scalar_Instruction;

typedef struct Bin_Instruction_Rec {
    Opcodes opcode;
    OpcodeClasses opclass;

    MaskedDstReg dst;
    SwizzleSrcReg srcA;
    SwizzleSrcReg srcB;
} Bin_Instruction;

typedef struct Tri_Instruction_Rec {
    Opcodes opcode;
    OpcodeClasses opclass;

    MaskedDstReg dst;
    SwizzleSrcReg srcA;
    SwizzleSrcReg srcB;
    SwizzleSrcReg srcC;
} Tri_Instruction;

typedef struct End_Instruction_Rec {
    Opcodes opcode;
    OpcodeClasses opclass;
} End_Instruction;

typedef union Instruction_Rec {
    Arl_Instruction arl_op;
    Vector_Instruction vector_op;
    Scalar_Instruction scalar_op;
    Bin_Instruction bin_op;
    Tri_Instruction tri_op;
    End_Instruction end_op;
} Instruction;

typedef struct ParsedProgram_Rec {
    Instruction *firstInstruction;  // Pointer to array of instructions
    unsigned int liveOnEntry;       // Mask of "live" temp registers upon entry
    unsigned char resultRegsWritten[__GL_NUMBER_OF_RESULT_REGISTERS];
                                    // Mask of result registers written
    int IsStateProgram;             // True if this is a state program
    Instruction instArray[1];
} ParsedProgram;

void vp_Optimize(ParsedProgram *parsed, int numInstructions, int optimizeMask);

/*
** Common structure for X86 compilation of vertex programs
*/

#define CALLER_ID_D3D    0xD3D
#define CALLER_ID_OPENGL 0xD4D

typedef struct VtxProgCompileX86_Rec {
    void *(* malloc)(void *tag, size_t size);
    void (* free)(void *tag, void *address);
    void *(* exec_malloc)(void *tag, size_t size);
    void *mallocArg;
    float (* expf)(float f);
    float (* logf)(float f);
    int caller_id;
    int attrib_offset;
    int temp_offset;
    int result_offset;
    int param_offset;
    int float_zero_offset;
    int float_one_offset;
    // Used to compile code to fill pushbuffer directly:
    int channel_number;
    int enables_offset;
} VtxProgCompileX86;

typedef struct VertexProgramOutput_Rec {
    void *residentProgram;
    size_t residentSize;
    int residentNumInstructions;
} VertexProgramOutput;

int vp_CompileX86(VtxProgCompileX86 *, ParsedProgram *, int numInstructions,
                  VertexProgramOutput *);
int vp_OutputCelsiusX86(VtxProgCompileX86 *, ParsedProgram *, int numInstructions,
                  VertexProgramOutput *);

/*
** Common structure for Kelvin compilation of vertex programs
*/

typedef struct vtxpgmInstPacked_Rec {
    unsigned int x, y, z, w;
} vtxpgmInstPacked;

typedef struct VtxProgCompileKelvin_Rec {
    void *(* malloc)(void *tag, size_t size);
    void (* free)(void *tag, void *address);
    void *mallocArg;
    int caller_id;
    int inputRegMap[16];
    int outputRegMap[16];
    int userMode;
    // No need to init by D3D.  OpenGL only.
    unsigned int textureScaling;
    int passthroughMode;
    // Internally used members.  No need to initialize by caller:
    struct vtxpgmTLiveDead_Rec *tLiveDead;
    int numExtraInstructions;
} VtxProgCompileKelvin;

int vp_CompileKelvin(VtxProgCompileKelvin *, ParsedProgram *, int numInstructions,
                     VertexProgramOutput *);

/*
** Static global data used in shared code to call imported functions:
**
** TEMPORARY!!!!!!!
*/


struct VtxProgImports_Rec {
    float (* expf)(float f);
    float (* logf)(float f);
};


extern struct VtxProgImports_Rec VtxProgImports;

#endif /* __gl_vtxpgmcomp_h_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\common\inc\wglcommon.h ===
#ifndef __WGLCOMMON_H_
#define __WGLCOMMON_H_

/*
 * Copyright (c) 1997, Nvidia Corporation.  All rights reserved.
 * Portions Copyright (c) 1996, 1997, Silicon Graphics Inc.
 */

extern int STDCALL __wglNVDescribePixelFormat(int bpp, 
                                              int iLayerPlane, 
                                              int iPixelFormat, 
                                              unsigned int nBytes,
                                              PIXELFORMATDESCRIPTOR *ppfd, 
                                              LAYERPLANEDESCRIPTOR *plpd,
                                              __WINpixelFormat *winPixelFormat,
                                              struct __WINNVpixelFormatFlagsRec *winPFFlags, 
                                              int showExtended,
                                              void *osother);

#endif  /* __WGLCOMMON_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\common\inc\wincommon.h ===
#ifndef __WINCOMMON_H_
#define __WINCOMMON_H_

/*
 * Copyright (c) 1997, Nvidia Corporation.  All rights reserved.
 * Portions Copyright (c) 1996, 1997, Silicon Graphics Inc.
 */

/* Remember, this file is used by non-Win32 OpenGL drivers, too. */

// the high two bits are the severity code, see ntstatus.h and winerror.h
// the low 8 bits are unexplained in the windows docs, but don't indicate an error
#define IS_EVENT_ERROR(a) (((a & 0xC0000000) != 0) || (a >= 0x100))

typedef struct __WINNVpixelFormatFlagsRec {
    int unifiedBuffers;
    int color32depth16;
    int color16depth32;
    int multisample;
    int pbuffers;
    int flippingControl;
} __WINNVpixelFormatFlags;

#define WIN_PFD_SUPPORTS_COLOR32_DEPTH16    0x00000001 /* nv11 */
#define WIN_PFD_SUPPORTS_COLOR16_DEPTH32    0x00000002 /* nv20 */
#define WIN_PFD_SUPPORTS_OVERLAYS           0x00000004
#define WIN_PFD_SUPPORTS_SWAPCOPYONLY       0x00000008
#define WIN_PFD_SUPPORTS_SWAP_LAYER_BUFFERS 0x00000010
#define WIN_PFD_SUPPORTS_STEREO             0x00000020
#define WIN_PFD_SUPPORTS_PBUFFERS           0x00000040
#define WIN_PFD_SUPPORTS_MULTISAMPLE        0x00000080

// ---------- Internal Nvidia Pixel Format structure ---------------------

// bits for flags1
#define WINPF_DRAW_TO_WINDOW       0x00000001
#define WINPF_DRAW_TO_BITMAP       0x00000002
#define WINPF_DRAW_TO_PBUFFER      0x00000004
#define WINPF_NEED_PALETTE         0x00000008
#define WINPF_NEED_SYSTEM_PALETTE  0x00000010
#define WINPF_SWAP_LAYER_BUFFERS   0x00000020
#define WINPF_SUPPORT_GDI          0x00000040
#define WINPF_OPENGL_COMPLIANT     0x00000080
#define WINPF_DOUBLE_BUFFER        0x00000100
#define WINPF_STEREO               0x00000200
#define WINPF_SHARE_DEPTH          0x00000400
#define WINPF_SHARE_STENCIL        0x00000800
#define WINPF_SHARE_ACCUM          0x00001000
#define WINPF_TRANSPARENCY         0x00002000

typedef enum {
	WINPF_SWAP_UNDEFINED,
    WINPF_SWAP_COPY,
    WINPF_SWAP_EXCHANGE
} __WINswapMethod;

typedef enum {
    WINPF_PIXEL_RGBA,
    WINPF_PIXEL_COLOR_INDEX
} __WINpixelType;

typedef struct __WINpixelFormatRec {
    unsigned int     flags1;
    __WINswapMethod  swapMethod;
    __WINpixelType   pixelType;
    unsigned int     numOverlays;
    unsigned int     numUnderlays;
    unsigned int     colorBits;
    unsigned int     redBits;
    unsigned int     redShift;
    unsigned int     greenBits;
    unsigned int     greenShift;
    unsigned int     blueBits;
    unsigned int     blueShift;
    unsigned int     alphaBits;
    unsigned int     alphaShift;
    unsigned int     accumBits;
    unsigned int     accumRedBits;
    unsigned int     accumGreenBits;
    unsigned int     accumBlueBits;
    unsigned int     accumAlphaBits;
    unsigned int     depthBits;
    unsigned int     stencilBits;
    unsigned int     auxBuffers;
    unsigned int     transparentRed;
    unsigned int     transparentGreen;
    unsigned int     transparentBlue;
    unsigned int     transparentAlpha;
    unsigned int     transparentIndex;
    unsigned int     maxPbufferPixels;
    unsigned int     maxPbufferWidth;
    unsigned int     maxPbufferHeight;
    unsigned int     sampleBuffers;
    unsigned int     samples;
    unsigned int     layerPlane;
} __WINpixelFormat;

// nvsharedpixelfmt.c
extern int STDCALL __winNVProcessWinFlags(__WINNVpixelFormatFlags *winPFFlags);
extern int __winDescribePixelFormat(struct __WINpixelFormatRec *winPixelFormat, int desktopBPP,
                                    int iLayerPlane, int pixelFormat, unsigned int flags,
                                    int *startNonVisible); 
#endif  /* __WINCOMMON_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\common\mac\inc\macEnv.h ===
#ifndef __MACENV__
#define __MACENV__


#ifdef __cplusplus
extern "C" {
#endif



char * GetEnv( char * inKey );
void SetEnv( char * inKey, char * inValue );



#ifdef __cplusplus
}
#endif

#endif /* __MACENV__ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\common\inc\vtxpgmconsts.h ===
/*
** vtxpgmconsts.h
**
** Vertex Program Constant Declarations.
**
** Copyright 2000 NVIDIA, Corporation.  All rights reserved.
** 
** THE INFORMATION CONTAINED HEREIN IS PROPRIETARY AND CONFIDENTIAL TO
** NVIDIA, CORPORATION.  USE, REPRODUCTION OR DISCLOSURE TO ANY THIRD PARTY
** IS SUBJECT TO WRITTEN PRE-APPROVAL BY NVIDIA, CORPORATION.
*/

#ifndef __gl_vtxpgmconsts_h_
#define __gl_vtxpgmconsts_h_

#pragma warning (disable:4244)  /* Disable bogus VC++ 4.2 conversion warnings. */
#pragma warning (disable:4305)  /* VC++ 5.0 version of above warning. */

/*
** This file is shared between OpenGL and D3D so don't mess with it!
*/

/*
** Constants used for programs:
*/

#define __GL_NUMBER_OF_VERTEX_ATTRIBS       16
#define __GL_NUMBER_OF_PROGRAM_MATRICES     8
#define __GL_NUMBER_OF_TEMPORARY_REGISTERS  12
#define __GL_NUMBER_OF_RESULT_REGISTERS     16
#define __GL_NUMBER_OF_CONSTANT_REGISTERS   96
#define __GL_NUMBER_OF_PADDING_REGISTERS    128
#define __GL_MAX_NUMBER_OF_INSTRUCTIONS     128

#define __GL_ACTUAL_NUMBER_OF_INSTRUCTIONS_KELVIN   134

#define __GL_KELVIN_FIRST_USER_CONSTANT_REGISTER    96


/*
** Names for each of the vertex attributes
*/

#define __GL_ATTRIB_POSITION            0
#define __GL_ATTRIB_VERTEX_WEIGHT       1
#define __GL_ATTRIB_NORMAL              2
#define __GL_ATTRIB_COLOR               3
#define __GL_ATTRIB_SECONDARY_COLOR     4
#define __GL_ATTRIB_FOG_COORD           5
#define __GL_ATTRIB_UNUSED0             6
#define __GL_ATTRIB_UNUSED1             7
#define __GL_ATTRIB_TEXCOORD0           8
#define __GL_ATTRIB_TEXCOORD1           9
#define __GL_ATTRIB_TEXCOORD2           10
#define __GL_ATTRIB_TEXCOORD3           11
#define __GL_ATTRIB_TEXCOORD4           12
#define __GL_ATTRIB_TEXCOORD5           13
#define __GL_ATTRIB_TEXCOORD6           14
#define __GL_ATTRIB_TEXCOORD7           15

/*
** Names for the output components:
*/

#define __GL_ATTRIB_OUTPUT_HPOS         0
#define __GL_ATTRIB_OUTPUT_COL0         3
#define __GL_ATTRIB_OUTPUT_COL1         4
#define __GL_ATTRIB_OUTPUT_BFC0         7
#define __GL_ATTRIB_OUTPUT_BFC1         8
#define __GL_ATTRIB_OUTPUT_FOGC         5
#define __GL_ATTRIB_OUTPUT_PSIZ         6
#define __GL_ATTRIB_OUTPUT_TEX0         9
#define __GL_ATTRIB_OUTPUT_TEX1         10
#define __GL_ATTRIB_OUTPUT_TEX2         11
#define __GL_ATTRIB_OUTPUT_TEX3         12
#define __GL_ATTRIB_OUTPUT_TEX4         13
#define __GL_ATTRIB_OUTPUT_TEX5         14
#define __GL_ATTRIB_OUTPUT_TEX6         15
#define __GL_ATTRIB_OUTPUT_TEX7         15

/*
** Enable bits tested by compiled x886 code:
*/

#define __GL_PROGRAM_ENABLE_TEXTURE0    1
#define __GL_PROGRAM_ENABLE_TEXTURE1    2

#endif /* __gl_vtxpgmconsts_h_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\common\mac\inc\naming.h ===
/*
	naming.h -- use 'Monica' or NVIDIA naming scheme
*/

#ifndef __NAMING__
#define __NAMING__

#define MONICA_NAMES	0		// Set to 1 if drivers use 'Monica' names, 0 if NVIDIA names

#if MONICA_NAMES
#define PROP_PREFIX		"MNCA,"	// prefix value for Name Registry properties
#else
#define PROP_PREFIX		"NVDA,"
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\common\mac\inc\driverinfo.h ===
/*
	driverinfo.h
*/

#include "naming.h"			// For Monica or NVIDIA names

#define FB_OFFSET	(16 * 1024)		// Offset (in bytes) of the frame buffer's first displayed pixel

#ifndef DEVICENAMESTRING
// This is the name of the NVIDIA board's Name Registry node, assigned by FCode.  If you have
//	multiple NV boards in your system, you'll have multiple "NVDA,NVMac" nodes and will need to
//	figure out (with bus and slot information) which one you want to use.
#if MONICA_NAMES	// Value set in naming.h
#define DEVICENAMESTRING	"MNCA,Monica"	// Generic NV with Mac ROM
#else
#define DEVICENAMESTRING	"NVDA,NVMac"	// Generic NV with Mac ROM
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\common\mac\qdregions\DebugBuild.h ===
/******************************************************************************

 DebugBuild.h -- for the Resource-Manager-aware display driver

 *****************************************************************************/

#define DEBUG_BUILD			0	// Disable debugging until we resolve the link issues
#define PROFILE_BUILD		0
#define STANDALONE_BUILD	0
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\common\inc\x86.h ===
/*
 * Copyright 1993-1998 NVIDIA, Corporation.  All rights reserved.
 *
 * THE INFORMATION CONTAINED HEREIN IS PROPRIETARY AND CONFIDENTIAL TO
 * NVIDIA, CORPORATION.  USE, REPRODUCTION OR DISCLOSURE TO ANY THIRD PARTY
 * IS SUBJECT TO WRITTEN PRE-APPROVAL BY NVIDIA, CORPORATION.
 */
/********************************* Direct 3D *******************************\
*                                                                           *
* Module: x86.h                                                             *
*   x86 architexture specific macros - used mainly to generate assembly     *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*       Ben de Waal                 02/10/98 - wrote it.                    *
*                                                                           *
\***************************************************************************/

/*****************************************************************************
 * constants
 *****************************************************************************/

#ifndef _x86_h
#define _x86_h

#ifdef __cplusplus
extern "C" {
#endif

/*
 * registers
 */
#define rEAX            0
#define rECX            1
#define rEDX            2
#define rEBX            3
#define rESP            4
#define rEBP            5
#define rESI            6
#define rEDI            7

#define rAX             0
#define rCX             1
#define rDX             2
#define rBX             3
#define rSP             4
#define rBP             5
#define rSI             6
#define rDI             7

#define rAL             0
#define rCL             1
#define rDL             2
#define rBL             3
#define rAH             4
#define rCH             5
#define rDH             6
#define rBH             7

#define rMM0            0
#define rMM1            1
#define rMM2            2
#define rMM3            3
#define rMM4            4
#define rMM5            5
#define rMM6            6
#define rMM7            7

#define rXMM0           0
#define rXMM1           1
#define rXMM2           2
#define rXMM3           3
#define rXMM4           4
#define rXMM5           5
#define rXMM6           6
#define rXMM7           7

#define rST0            0
#define rST1            1
#define rST2            2
#define rST3            3
#define rST4            4
#define rST5            5
#define rST6            6
#define rST7            7

/*
 * op codes
 *  alphabetically sorted
 */
#define xADC_rEAX_imm(i)        x86s(5) x86b(0x15) x86d(i)
#define xADD_r_rm(r,rm)         x86s(2) x86b(0x03) x86b(mREG(r) | (rm))
#define xADD_r_i32(r,a)         x86s(6) x86b(0x03) x86b(mREG(r) | mOFS32) x86d(a)
#define xADD_rm_imm8(rm,i)      x86s(3) x86b(0x83) x86b(mREG(0) | (rm)) x86b(i)
#define xADD_rm_imm(rm,i)       x86s(6) x86b(0x81) x86b(mREG(0) | (rm)) x86d(i)
#define xADD_rm_r(rm,r)         x86s(2) x86b(0x01) x86b(mREG(r) | (rm))
#define xADD_i32_r(a,r)         x86s(6) x86b(0x01) x86b(mREG(r) | mOFS32) x86d(a)

#define xAND_r_rm(r,rm)         x86s(2) x86b(0x23) x86b(mREG(r) | (rm))
#define xAND_r_i32(r,a)         x86s(6) x86b(0x23) x86b(mREG(r) | mOFS32) x86d(a)
#define xAND_rm_imm8(rm,i)      x86s(3) x86b(0x83) x86b(mREG(4) | (rm)) x86b(i)
#define xAND_rm_imm(rm,i)       x86s(6) x86b(0x81) x86b(mREG(4) | (rm)) x86d(i)

#define xCALL_rm(rm)            x86s(2) x86b(0xff) x86b(mREG(2) | (rm))

#define xCMOVA_r_i32(r,a)       x86s(7) x86b(0x0f) x86b(0x47) x86b(mREG(r) | mOFS32) x86d(a)
#define xCMOVA_r_rm(r,rm)       x86s(3) x86b(0x0f) x86b(0x47) x86b(mREG(r) | (rm))
#define xCMOVB_r_i32(r,a)       x86s(7) x86b(0x0f) x86b(0x42) x86b(mREG(r) | mOFS32) x86d(a)
#define xCMOVB_r_rm(r,rm)       x86s(3) x86b(0x0f) x86b(0x42) x86b(mREG(r) | (rm))
#define xCMOVG_r_rm(r,rm)       x86s(3) x86b(0x0f) x86b(0x4f) x86b(mREG(r) | (rm))
#define xCMOVL_r_rm(r,rm)       x86s(3) x86b(0x0f) x86b(0x4c) x86b(mREG(r) | (rm))

#define xCMP_r_rm(r,rm)         x86s(2) x86b(0x3b) x86b(mREG(r) | (rm))
#define xCMP_r_i32(r,a)         x86s(6) x86b(0x3b) x86b(mREG(r) | mOFS32) x86d(a)
#define xCMP_rm_imm(rm,i)       x86s(6) x86b(0x81) x86b(mREG(7) | (rm)) x86d(i)

#define xDEC_r(r)               x86s(1) x86b(0x48 | (r))
#define xDEC_rm(rm)             x86s(2) x86b(0xff) x86b(mREG(1) | (rm))
#define xDEC_i32(a)             x86s(6) x86b(0xff) x86b(mREG(1) | mOFS32) x86d(a)

#define xDIV_rm(rm)             x86s(2) x86b(0xf7) x86b(mREG(6) | (rm))

#define xFABS()                 x86s(2) x86b(0xd9) x86b(0xe1)

#define xFADD_rm(rm)            x86s(2) x86b(0xd8) x86b(mREG(0) | (rm))
#define xFADD_i32(a)            x86s(6) x86b(0xd8) x86b(mREG(0) | mOFS32) x86d(a)
#define xFADD_st(r)             x86s(2) x86b(0xd8) x86b(0xc0 + (r))
#define xFADDP_st(r)            x86s(2) x86b(0xde) x86b(0xc0 + (r))

#define xFDECSTP                x86s(2) x86b(0xd9) x86b(0xf6)

#define xFCHS                   x86s(2) x86b(0xd9) x86b(0xe0)

#define xFCOM_rm(rm)            x86s(2) x86b(0xd8) x86b(mREG(2) | (rm))
#define xFCOM_i32(a)            x86s(6) x86b(0xd8) x86b(mREG(2) | mOFS32) x86d(a)
#define xFCOM_st(r)             x86s(2) x86b(0xd8) x86b(0xd0 + (r))
#define xFCOMI_st(r)            x86s(2) x86b(0xdb) x86b(0xf0 + (r))
#define xFCOMIP_st(r)           x86s(2) x86b(0xdf) x86b(0xf0 + (r))
#define xFCOMP_rm(rm)           x86s(2) x86b(0xd8) x86b(mREG(3) | (rm))
#define xFCOMPP()               x86s(2) x86b(0xde) x86b(0xd9)

#define xFDIV_rm(rm)            x86s(2) x86b(0xd8) x86b(mREG(6) | (rm))
#define xFDIVR_rm(rm)           x86s(2) x86b(0xd8) x86b(mREG(7) | (rm))

#define xFFREE_st(r)            x86s(2) x86b(0xdd) x86b(0xc0 + (r))

#define xFILD_rm(rm)            x86s(2) x86b(0xdb) x86b(mREG(0) | (rm))
#define xFILD_rm16(rm)          x86s(2) x86b(0xdf) x86b(mREG(0) | (rm))
#define xFILD_rm64(rm)          x86s(2) x86b(0xdf) x86b(mREG(5) | (rm))

#define xFINCSTP                x86s(2) x86b(0xd9) x86b(0xf7)

#define xFIST_rm(rm)            x86s(2) x86b(0xdb) x86b(mREG(2) | (rm))
#define xFISTP_rm(rm)           x86s(2) x86b(0xdb) x86b(mREG(3) | (rm))
#define xFISTP_i32(a)           x86s(6) x86b(0xdb) x86b(mREG(3) | mOFS32) x86d(a)

#define xFLD_rm(rm)             x86s(2) x86b(0xd9) x86b(mREG(0) | (rm))
#define xFLD_rm32(rm)           x86s(2) x86b(0xd9) x86b(mREG(0) | (rm))
#define xFLD_rm64(rm)           x86s(2) x86b(0xdd) x86b(mREG(0) | (rm))
#define xFLD_i32(a)             x86s(6) x86b(0xd9) x86b(mREG(0) | mOFS32) x86d(a)
#define xFLD_st(r)              x86s(2) x86b(0xd9) x86b(0xc0 + (r))
#define xFLD1                   x86s(2) x86b(0xd9) x86b(0xe8)
#define xFLDZ                   x86s(2) x86b(0xd9) x86b(0xee)

#define xFMUL_st(r)             x86s(2) x86b(0xd8) x86b(0xc8 + (r))
#define xFMUL_rm(rm)            x86s(2) x86b(0xd8) x86b(mREG(1) | (rm))
#define xFMUL_i32(a)            x86s(6) x86b(0xd8) x86b(mREG(1) | mOFS32) x86d(a)
#define xFMULP_st(r)            x86s(2) x86b(0xde) x86b(0xc8 + (r))
#define xFNSTSW                 x86s(2) x86b(0xdf) x86b(0xe0)

#define xFSQRT()                x86s(2) x86b(0xd9) x86b(0xfa)

#define xFSUB_rm(rm)            x86s(2) x86b(0xd8) x86b(mREG(4) | (rm))
#define xFSUBP_st(r)            x86s(2) x86b(0xde) x86b(0xe8 + (r))
#define xFSUBR_rm(rm)           x86s(2) x86b(0xd8) x86b(mREG(5) | (rm))
#define xFSUBRP_st(r)           x86s(2) x86b(0xde) x86b(0xe0 + (r))

#define xFST_rm(rm)             x86s(2) x86b(0xd9) x86b(mREG(2) | (rm))
#define xFSTP_rm(rm)            x86s(2) x86b(0xd9) x86b(mREG(3) | (rm))
#define xFSTP_i32(a)            x86s(6) x86b(0xd9) x86b(mREG(3) | mOFS32) x86d(a)
#define xFSTP_st(r)             x86s(2) x86b(0xdd) x86b(0xd8 + (r))

#define xFLDCW_rm(rm)           x86s(2) x86b(0xd9) x86b(mREG(5) | (rm))
#define xFSTCW_rm(rm)           x86s(2) x86b(0xd9) x86b(mREG(7) | (rm))


#define xFXCH_st(r)             x86s(2) x86b(0xd9) x86b(0xc8 + (r))

#define xFYL2X()                x86s(2) x86b(0xd9) x86b(0xf1)
#define xF2XM1()                x86s(2) x86b(0xd9) x86b(0xf0)

#define xINC_r(r)               x86s(1) x86b(0x40 | (r))
#define xINC_rm(rm)             x86s(2) x86b(0xff) x86b(mREG(0) | (rm))

#define xIMUL_r_rm(r,rm)        x86s(3) x86b(0x0f) x86b(0xaf) x86b(mREG(r) | (rm))
#define xIMUL_r_i32(r,a)        x86s(7) x86b(0x0f) x86b(0xaf) x86b(mREG(r) | mOFS32) x86d(a)
#define xIMUL_r_r_imm(r1,r2,i)  x86s(6) x86b(0x69) x86b(0xc0 | ((r1) << 3) | (r2)) x86d(i)

#define xINT3                   x86s(1) x86b(0xcc)

#define xJA(disp)               { unsigned int _x = (disp)-(ilcCount+2); x86s(2) x86b(0x77) x86b(_x) }
#define xJA32(disp)             { unsigned int _x = (disp)-(ilcCount+6); x86s(6) x86b(0x0f) x86b(0x87) x86d(_x) }
#define xJAE(disp)              { unsigned int _x = (disp)-(ilcCount+2); x86s(2) x86b(0x73) x86b(_x) }
#define xJAE32(disp)            { unsigned int _x = (disp)-(ilcCount+6); x86s(6) x86b(0x0f) x86b(0x83) x86d(_x) }
#define xJB(disp)               { unsigned int _x = (disp)-(ilcCount+2); x86s(2) x86b(0x72) x86b(_x) }
#define xJB32(disp)             { unsigned int _x = (disp)-(ilcCount+6); x86s(6) x86b(0x0f) x86b(0x82) x86d(_x) }
#define xJBE(disp)              { unsigned int _x = (disp)-(ilcCount+2); x86s(2) x86b(0x76) x86b(_x) }
#define xJBE32(disp)            { unsigned int _x = (disp)-(ilcCount+6); x86s(6) x86b(0x0f) x86b(0x86) x86d(_x) }
#define xJG(disp)               { unsigned int _x = (disp)-(ilcCount+2); x86s(2) x86b(0x7f) x86b(_x) }
#define xJG32(disp)             { unsigned int _x = (disp)-(ilcCount+6); x86s(6) x86b(0x0f) x86b(0x8f) x86d(_x) }
#define xJGE(disp)              { unsigned int _x = (disp)-(ilcCount+2); x86s(2) x86b(0x7d) x86b(_x) }
#define xJGE32(disp)            { unsigned int _x = (disp)-(ilcCount+6); x86s(6) x86b(0x0f) x86b(0x8d) x86d(_x) }
#define xJL(disp)               { unsigned int _x = (disp)-(ilcCount+2); x86s(2) x86b(0x7c) x86b(_x) }
#define xJL32(disp)             { unsigned int _x = (disp)-(ilcCount+6); x86s(6) x86b(0x0f) x86b(0x8c) x86d(_x) }
#define xJLE(disp)              { unsigned int _x = (disp)-(ilcCount+2); x86s(2) x86b(0x7e) x86b(_x) }
#define xJLE32(disp)            { unsigned int _x = (disp)-(ilcCount+6); x86s(6) x86b(0x0f) x86b(0x8e) x86d(_x) }
#define xJNZ(disp)              { unsigned int _x = (disp)-(ilcCount+2); x86s(2) x86b(0x75) x86b(_x) }
#define xJNZ32(disp)            { unsigned int _x = (disp)-(ilcCount+6); x86s(6) x86b(0x0f) x86b(0x85) x86d(_x) }
#define xJZ(disp)               { unsigned int _x = (disp)-(ilcCount+2); x86s(2) x86b(0x74) x86b(_x) }
#define xJZ32(disp)             { unsigned int _x = (disp)-(ilcCount+6); x86s(6) x86b(0x0f) x86b(0x84) x86d(_x) }


#define xJMP8(disp)             { unsigned int _x = (disp)-(ilcCount+2); x86s(2) x86b(0xeb) x86b(_x) }
#define xJMP(disp)              { unsigned int _x = (disp)-(ilcCount+5); x86s(5) x86b(0xe9) x86d(_x) }

#define xLEA_r_rm(r,rm)         x86s(2) x86b(0x8d) x86b(mREG(r) | (rm))

#define xMOV_r_rm(r,rm)         x86s(2) x86b(0x8b) x86b(mREG(r) | (rm))                     // mov eax,[ebx]
#define xMOV_r_i32(r,a)         x86s(6) x86b(0x8b) x86b(mREG(r) | mOFS32) x86d(a)           // mov eax,[1234h]
#define xMOV_rm_imm(rm,i)       x86s(6) x86b(0xc7) x86b(mREG(0) | (rm)) x86d(i)             // mov ebp,12345678
#define xMOV_r_imm(rm,i)        x86s(5) x86b(0xb8 | (rm)) x86d(i)                           // mov eax,12345678
#define xMOV_rm_r(rm,r)         x86s(2) x86b(0x89) x86b(mREG(r) | (rm))                     // mov [ebx],eax
#define xMOV_i32_r(a,r)         x86s(6) x86b(0x89) x86b(mREG(r) | mOFS32) x86d(a)           // mov [1234h],eax
#define xMOV_r_rm8(r,rm)        x86s(2) x86b(0x8a) x86b(mREG(r) | (rm))                     // mov al,[ebx]
#define xMOV_rm8_r(rm,r)        x86s(2) x86b(0x88) x86b(mREG(r) | (rm))                     // mov [ebx],al
#define xMOVSB                  x86s(1) x86b(0xa4)
#define xMOVSD                  x86s(1) x86b(0xa5)
#define xMOVSX_r_rm8(r,rm)      x86s(3) x86b(0x0f) x86b(0xbe) x86b(mREG(r) | (rm))
#define xMOVSX_r_rm16(r,rm)     x86s(3) x86b(0x0f) x86b(0xbf) x86b(mREG(r) | (rm))
#define xMOVZX_r_rm8(r,rm)      x86s(3) x86b(0x0f) x86b(0xb6) x86b(mREG(r) | (rm))
#define xMOVZX_r_rm16(r,rm)     x86s(3) x86b(0x0f) x86b(0xb7) x86b(mREG(r) | (rm))

#define xNEG_rm(rm)             x86s(2) x86b(0xf7) x86b(mREG(3) | (rm))

#define xNOP                    x86s(1) x86b(0x90)

#define xNOT_rm(rm)             x86s(2) x86b(0xf7) x86b(mREG(2) | (rm))

#define xOR_r_rm(r,rm)          x86s(2) x86b(0x0b) x86b(mREG(r) | (rm))
#define xOR_r_i32(r,a)          x86s(6) x86b(0x0b) x86b(mREG(r) | mOFS32) x86d(a)
#define xOR_rm_r(rm,r)          x86s(2) x86b(0x09) x86b(mREG(r) | (rm))
#define xOR_i32_r(a,r)          x86s(6) x86b(0x09) x86b(mREG(r) | mOFS32) x86d(a)
#define xOR_rm_imm(rm,i)        x86s(6) x86b(0x81) x86b(mREG(1) | (rm)) x86d(i)

#define xPOP_r(r)               x86s(1) x86b(0x58 | (r))
#define xPOP_rm(rm)             x86s(2) x86b(0xff) x86b(0x30 | (rm))
#define xPOPAD                  x86s(1) x86b(0x61)

#define xPUSH_r(r)              x86s(1) x86b(0x50 | (r))
#define xPUSH_rm(rm)            x86s(2) x86b(0xff) x86b(mREG(6) | (rm))
#define xPUSH_i32(a)            x86s(6) x86b(0xff) x86b(mREG(6) | mOFS32) x86d(a)
#define xPUSH_imm(i)            x86s(5) x86b(0x68) x86d(i)
#define xPUSHAD                 x86s(1) x86b(0x60)

#define xREP                    x86s(1) x86b(0xf3)
#define xRET                    x86s(1) x86b(0xc3)
#define xRET_imm(i)             x86s(3) x86b(0xc2) x86w(i)

#define xSAHF                   x86s(1) x86b(0x9e)

#define xSAL_rm_imm8(rm,i)      x86s(3) x86b(0xc1) x86b(mREG(4) | (rm)) x86b(i)
#define xSAR_rm_imm8(rm,i)      x86s(3) x86b(0xc1) x86b(mREG(7) | (rm)) x86b(i)

#define xSBB_r_rm(r,rm)         x86s(2) x86b(0x1b) x86b(mREG(r) | (rm))
#define xSBB_r_i32(r,a)         x86s(6) x86b(0x1b) x86b(mREG(r) | mOFS32) x86d(a)
#define xSBB_rm_r(rm,r)         x86s(2) x86b(0x19) x86b(mREG(r) | (rm))

#define xSETAE_rm8(rm)          x86s(3) x86b(0x0f) x86b(0x93) x86b(rm)
#define xSETG_rm8(rm)           x86s(3) x86b(0x0f) x86b(0x9f) x86b(rm)
#define xSETGE_rm8(rm)          x86s(3) x86b(0x0f) x86b(0x9d) x86b(rm)
#define xSETL_rm8(rm)           x86s(3) x86b(0x0f) x86b(0x9c) x86b(rm)
#define xSETLE_rm8(rm)          x86s(3) x86b(0x0f) x86b(0x9e) x86b(rm)
#define xSETNZ_rm8(rm)          x86s(3) x86b(0x0f) x86b(0x95) x86b(rm)
#define xSETZ_rm8(rm)           x86s(3) x86b(0x0f) x86b(0x94) x86b(rm)

#define xSHL_rm_1(rm)           x86s(2) x86b(0xd1) x86b(mREG(4) | (rm))
#define xSHL_rm_CL(rm)          x86s(2) x86b(0xd3) x86b(mREG(4) | (rm))
#define xSHL_rm_imm8(rm,i)      x86s(3) x86b(0xc1) x86b(mREG(4) | (rm)) x86b(i)
#define xSHR_rm_1(rm)           x86s(2) x86b(0xd1) x86b(mREG(5) | (rm))
#define xSHR_rm_CL(rm)          x86s(2) x86b(0xd3) x86b(mREG(5) | (rm))
#define xSHR_rm_imm8(rm,i)      x86s(3) x86b(0xc1) x86b(mREG(5) | (rm)) x86b(i)

#define xSTOSD                 x86s(1) x86b(0xab)

#define xSUB_r_rm(r,rm)         x86s(2) x86b(0x2b) x86b(mREG(r) | (rm))
#define xSUB_r_i32(r,a)         x86s(6) x86b(0x2b) x86b(mREG(r) | mOFS32) x86d(a)
#define xSUB_rm_r(rm,r)         x86s(2) x86b(0x29) x86b(mREG(r) | (rm))
#define xSUB_i32_r(a,r)         x86s(6) x86b(0x29) x86b(mREG(r) | mOFS32) x86d(a)
#define xSUB_rm_imm8(rm,i)      x86s(3) x86b(0x83) x86b(mREG(5) | (rm)) x86b(i)
#define xSUB_rm_imm(rm,i)       x86s(6) x86b(0x81) x86b(mREG(5) | (rm)) x86d(i)

#define xTEST_rm_r(rm,r)        x86s(2) x86b(0x85) x86b(mREG(r) | (rm))
#define xTEST_r_rm(r,rm)        x86s(2) x86b(0x85) x86b(mREG(r) | (rm))
#define xTEST_i32_r(a,r)        x86s(6) x86b(0x85) x86b(mREG(r) | mOFS32) x86d(a)
#define xTEST_r_i32(r,a)        x86s(6) x86b(0x85) x86b(mREG(r) | mOFS32) x86d(a)
#define xTEST_rm_imm8(rm,i)     x86s(3) x86b(0xf6) x86b(mREG(0) | (rm)) x86b(i)
#define xTEST_rm_imm(rm,i)      x86s(6) x86b(0xf7) x86b(mREG(0) | (rm)) x86d(i)

#define xXOR_r_rm(r,rm)         x86s(2) x86b(0x33) x86b(mREG(r) | (rm))
#define xXOR_r_i32(r,a)         x86s(6) x86b(0x33) x86b(mREG(r) | mOFS32) x86d(a)
#define xXOR_rm_r(rm,r)         x86s(2) x86b(0x31) x86b(mREG(r) | (rm))
#define xXOR_i32_r(a,r)         x86s(6) x86b(0x31) x86b(mREG(r) | mOFS32) x86d(a)
#define xXOR_rm_imm(rm,i)       x86s(6) x86b(0x81) x86b(mREG(6) | (rm)) x86d(i)

/*
 * mmx opcodes
 */
#define xMOVD_r_rm(r,rm)        x86s(3) x86b(0x0f) x86b(0x6e) x86b(mREG(r) | (rm))
#define xMOVD_r_i32(r,a)        x86s(7) x86b(0x0f) x86b(0x6e) x86b(mREG(r) | mOFS32) x86d(a)
#define xMOVD_rm_r(rm,r)        x86s(3) x86b(0x0f) x86b(0x7e) x86b(mREG(r) | (rm))
#define xMOVD_i32_r(a,r)        x86s(7) x86b(0x0f) x86b(0x7e) x86b(mREG(r) | mOFS32) x86d(a)
#define xMOVNTQ_rm_r(rm,r)      x86s(3) x86b(0x0f) x86b(0xe7) x86b(mREG(r) | (rm))
#define xMOVQ_r_rm(r,rm)        x86s(3) x86b(0x0f) x86b(0x6f) x86b(mREG(r) | (rm))
#define xMOVQ_rm_r(rm,r)        x86s(3) x86b(0x0f) x86b(0x7f) x86b(mREG(r) | (rm))
#define xMOVQ_i64_r(a,r)        x86s(7) x86b(0x0f) x86b(0x7f) x86b(mREG(r) | mOFS32) x86d(a)
#define xMOVQ_r_i64(r,a)        x86s(7) x86b(0x0f) x86b(0x6f) x86b(mREG(r) | mOFS32) x86d(a)
#define xPADDB_r_rm(r,rm)       x86s(3) x86b(0x0f) x86b(0xfc) x86b(mREG(r) | (rm))
#define xPADDB_r_i64(r,a)       x86s(7) x86b(0x0f) x86b(0xfc) x86b(mREG(4) | mOFS32) x86d(a)
#define xPADDW_r_rm(r,rm)       x86s(3) x86b(0x0f) x86b(0xfd) x86b(mREG(r) | (rm))
#define xPADDW_r_i64(r,a)       x86s(7) x86b(0x0f) x86b(0xfd) x86b(mREG(4) | mOFS32) x86d(a)
#define xPADDD_r_rm(r,rm)       x86s(3) x86b(0x0f) x86b(0xfe) x86b(mREG(r) | (rm))
#define xPADDD_r_i64(r,a)       x86s(7) x86b(0x0f) x86b(0xfe) x86b(mREG(4) | mOFS32) x86d(a)

#define xPMOVMSKB_r_r(r1, r2)   x86s(3) x86b(0x0f) x86b(0xd7) x86b(mREG(r1) | rmREG(r2))

#define xPUNPCKLBW_r_rm(r,rm)   x86s(3) x86b(0x0f) x86b(0x60) x86b(mREG(r) | (rm))
#define xPUNPCKLBW_r_i128(r,a)  x86s(7) x86b(0x0f) x86b(0x60) x86b(mREG(r) | mOFS32) x86d(a)
#define xPUNPCKLWD_r_rm(r,rm)   x86s(3) x86b(0x0f) x86b(0x61) x86b(mREG(r) | (rm))
#define xPUNPCKLWD_r_i128(r,a)  x86s(7) x86b(0x0f) x86b(0x61) x86b(mREG(r) | mOFS32) x86d(a)
#define xPUNPCKLDQ_r_rm(r,rm)   x86s(3) x86b(0x0f) x86b(0x62) x86b(mREG(r) | (rm))
#define xPUNPCKLDQ_r_i128(r,a)  x86s(7) x86b(0x0f) x86b(0x62) x86b(mREG(r) | mOFS32) x86d(a)

#define xEMMS                   x86s(2) x86b(0x0f) x86b(0x77)

/*
 * katmai opcodes
 */
#define xADDPS_r_rm(r,rm)       x86s(3) x86b(0x0f) x86b(0x58) x86b(mREG(r) | (rm))
#define xADDSS_r_rm(r,rm)       x86s(4) x86b(0xf3) x86b(0x0f) x86b(0x58) x86b(mREG(r) | (rm))

#define xCOMISS_r_rm(r,rm)      x86s(3) x86b(0x0f) x86b(0x2f) x86b(mREG(r) | (rm))
#define xCMPPSZ_r_rm(r,rm)      x86s(4) x86b(0x0f) x86b(0xc2) x86b(mREG(r) | (rm)) x86b(0)
#define xCMPPSL_r_rm(r,rm)      x86s(4) x86b(0x0f) x86b(0xc2) x86b(mREG(r) | (rm)) x86b(1)
#define xCMPPSLE_r_rm(r,rm)     x86s(4) x86b(0x0f) x86b(0xc2) x86b(mREG(r) | (rm)) x86b(2)
#define xCMPPSNZ_r_rm(r,rm)     x86s(4) x86b(0x0f) x86b(0xc2) x86b(mREG(r) | (rm)) x86b(4)
#define xCMPPSGE_r_rm(r,rm)     x86s(4) x86b(0x0f) x86b(0xc2) x86b(mREG(r) | (rm)) x86b(5)
#define xCMPPSG_r_rm(r,rm)      x86s(4) x86b(0x0f) x86b(0xc2) x86b(mREG(r) | (rm)) x86b(6)

#define xCVTPS2PI_r_rm(r,rm)    x86s(3) x86b(0x0f) x86b(0x2c) x86b(mREG(r) | (rm))

#define xDIVPS_r_rm(r,rm)       x86s(3) x86b(0x0f) x86b(0x5e) x86b(mREG(r) | (rm))

#define xMAXPS_r_rm(r,rm)       x86s(3) x86b(0x0f) x86b(0x5f) x86b(mREG(r) | (rm))
#define xMAXPS_r_i128(r,a)      x86s(7) x86b(0x0f) x86b(0x5f) x86b(mREG(r) | mOFS32) x86d(a)

#define xMINPS_r_rm(r,rm)       x86s(3) x86b(0x0f) x86b(0x5d) x86b(mREG(r) | (rm))
#define xMINPS_r_i128(r,a)      x86s(7) x86b(0x0f) x86b(0x5d) x86b(mREG(r) | mOFS32) x86d(a)

#define xMOVAPS_r_rm(r,rm)      x86s(3) x86b(0x0f) x86b(0x28) x86b(mREG(r) | (rm))
#define xMOVAPS_r_i128(r,a)     x86s(7) x86b(0x0f) x86b(0x28) x86b(mREG(r) | mOFS32) x86d(a)
#define xMOVAPS_rm_r(rm,r)      x86s(3) x86b(0x0f) x86b(0x29) x86b(mREG(r) | (rm))
#define xMOVAPS_i128_r(a,r)     x86s(7) x86b(0x0f) x86b(0x29) x86b(mREG(r) | mOFS32) x86d(a)

#define xMOVHLPS_r_r(r1,r2)     x86s(3) x86b(0x0f) x86b(0x12) x86b(mREG(r1) | rmREG(r2)) // special movlps
#define xMOVLHPS_r_r(r1,r2)     x86s(3) x86b(0x0f) x86b(0x16) x86b(mREG(r1) | rmREG(r2)) // special movhps

#define xMOVHPS_r_rm(r,rm)      x86s(3) x86b(0x0f) x86b(0x16) x86b(mREG(r) | (rm))
#define xMOVHPS_r_i64(r,a)      x86s(7) x86b(0x0f) x86b(0x16) x86b(mREG(r) | mOFS32) x86d(a)
#define xMOVHPS_i64_r(a,r)      x86s(7) x86b(0x0f) x86b(0x17) x86b(mREG(r) | mOFS32) x86d(a)
#define xMOVHPS_rm_r(rm,r)      x86s(3) x86b(0x0f) x86b(0x17) x86b(mREG(r) | (rm))

#define xMOVLPS_r_rm(r,rm)      x86s(3) x86b(0x0f) x86b(0x12) x86b(mREG(r) | (rm))
#define xMOVLPS_r_i64(r,a)      x86s(7) x86b(0x0f) x86b(0x12) x86b(mREG(r) | mOFS32) x86d(a)
#define xMOVLPS_i64_r(a,r)      x86s(7) x86b(0x0f) x86b(0x13) x86b(mREG(r) | mOFS32) x86d(a)
#define xMOVLPS_rm_r(rm,r)      x86s(3) x86b(0x0f) x86b(0x13) x86b(mREG(r) | (rm))

#define xMOVMSKPS_r_r(r1,r2)    x86s(3) x86b(0x0f) x86b(0x50) x86b(mREG(r1) | rmREG(r2))

#define xMOVNTPS_i128_r(a,r)    x86s(7) x86b(0x0f) x86b(0x2b) x86b(mREG(r) | mOFS32) x86d(a)
#define xMOVNTPS_rm_r(rm,r)     x86s(3) x86b(0x0f) x86b(0x2b) x86b(mREG(r) | (rm))

#define xMOVUPS_r_rm(r,rm)      x86s(3) x86b(0x0f) x86b(0x10) x86b(mREG(r) | (rm))
#define xMOVUPS_r_i128(r,a)     x86s(7) x86b(0x0f) x86b(0x10) x86b(mREG(r) | mOFS32) x86d(a)
#define xMOVUPS_rm_r(rm,r)      x86s(3) x86b(0x0f) x86b(0x11) x86b(mREG(r) | (rm))
#define xMOVUPS_i128_r(a,r)     x86s(7) x86b(0x0f) x86b(0x11) x86b(mREG(r) | mOFS32) x86d(a)

#define xMOVSS_r_rm(r,rm)       x86s(4) x86b(0xf3) x86b(0x0f) x86b(0x10) x86b(mREG(r) | (rm))
#define xMOVSS_r_i32(r,a)       x86s(8) x86b(0xf3) x86b(0x0f) x86b(0x10) x86b(mREG(r) | mOFS32) x86d(a)
#define xMOVSS_i32_r(a,r)       x86s(8) x86b(0xf3) x86b(0x0f) x86b(0x11) x86b(mREG(r) | mOFS32) x86d(a)

#define xMULPS_r_rm(r,rm)       x86s(3) x86b(0x0f) x86b(0x59) x86b(mREG(r) | (rm))
#define xMULPS_r_i128(r,a)      x86s(7) x86b(0x0f) x86b(0x59) x86b(mREG(r) | mOFS32) x86d(a)

#define xMULSS_r_rm(r,rm)       x86s(4) x86b(0xf3) x86b(0x0f) x86b(0x59) x86b(mREG(r) | (rm))

#define xRCPPS_r_rm(r,rm)       x86s(3) x86b(0x0f) x86b(0x53) x86b(mREG(r) | (rm))

#define xPREFETCH_rm8(h,rm,ofs) x86s(4) x86b(0x0f) x86b(0x18) x86b(mREG(h) | (rm)) x86b(ofs)

#define xPSHUFW_r_i64_imm(r,a,i) x86s(8) x86b(0xf) x86b(0x70) x86b(mREG(r) | mOFS32) x86d(a) x86b(i)
#define xPSHUFW_r_rm_imm(r,rm,i) x86s(4) x86b(0xf) x86b(0x70) x86b(mREG(r) | (rm)) x86b(i)

#define xSHUFPS_r_i64_imm(r,a,i) x86s(8) x86b(0x0f) x86b(0xc6) x86b(mREG(r) | mOFS32) x86d(a) x86b(i)
#define xSHUFPS_r_rm_imm(r,rm,i) x86s(4) x86b(0x0f) x86b(0xc6) x86b(mREG(r) | (rm)) x86b(i)

#define xSUBPS_r_rm(r,rm)       x86s(3) x86b(0x0f) x86b(0x5c) x86b(mREG(r) | (rm))
#define xSUBSS_r_rm(r,rm)       x86s(4) x86b(0xf3) x86b(0x0f) x86b(0x5c) x86b(mREG(r) | (rm))
#define xXORPS_r_rm(r,rm)       x86s(3) x86b(0x0f) x86b(0x57) x86b(mREG(r) | (rm))

 /*
 * Pentium 4 opcodes
 *
 * Note: Pentium 4 contains many equivalents to MMX instructions that use XMM registers instead of MM registers.
 * These new instructions are suffixed with an X after the opcode name.
 * example:
 *      MOVD    XMM0, ECX
 *  is
 *      xMOVDX_r_rm(rXMM0, rmREG(rECX))
 *
 *  do not write xMOVD_r_rm(rXMM0, rmREG(rECX)), as this actually generates MOVD    MM0, ECX   
 *
 * You would think that the macros would be smart enough to distinguish between XMM and MM registers, but they 
 * aren't. Sorry.
 */

#define xMOVDX_r_rm(r,rm)       x86s(4) x86b(0x66) x86b(0x0f) x86b(0x6e) x86b(mREG(r) | (rm))
#define xMOVDX_r_i32(r,a)       x86s(8) x86b(0x66) x86b(0x0f) x86b(0x6e) x86b(mREG(r) | mOFS32) x86d(a)
#define xMOVDX_rm_r(rm,r)       x86s(4) x86b(0x66) x86b(0x0f) x86b(0x7e) x86b(mREG(r) | (rm))
#define xMOVDX_i32_r(a,r)       x86s(8) x86b(0x66) x86b(0x0f) x86b(0x7e) x86b(mREG(r) | mOFS32) x86d(a)
#define xMOVSD_r_rm(r,rm)       x86s(4) x86b(0xf2) x86b(0x0f) x86b(0x10) x86b(mREG(r) | (rm))
#define xMOVSD_r_i128(r,a)      x86s(8) x86b(0xf2) x86b(0x0f) x86b(0x10) x86b(mREG(r) | mOFS32) x86d(a)
#define xMOVSD_rm_r(rm,r)       x86s(4) x86b(0xf2) x86b(0x0f) x86b(0x11) x86b(mREG(r) | (rm))
#define xMOVSD_i128_r(a,r)      x86s(8) x86b(0xf2) x86b(0x0f) x86b(0x11) x86b(mREG(r) | mOFS32) x86d(a)
#define xPADDBX_r_rm(r,rm)      x86s(4) x86b(0x66) x86b(0x0f) x86b(0xfc) x86b(mREG(r) | (rm))
#define xPADDBX_r_i64(r,a)      x86s(8) x86b(0x66) x86b(0x0f) x86b(0xfc) x86b(mREG(4) | mOFS32) x86d(a)
#define xPADDWX_r_rm(r,rm)      x86s(4) x86b(0x66) x86b(0x0f) x86b(0xfd) x86b(mREG(r) | (rm))
#define xPADDWX_r_i64(r,a)      x86s(8) x86b(0x66) x86b(0x0f) x86b(0xfd) x86b(mREG(4) | mOFS32) x86d(a)
#define xPADDDX_r_rm(r,rm)      x86s(4) x86b(0x66) x86b(0x0f) x86b(0xfe) x86b(mREG(r) | (rm))
#define xPADDDX_r_i64(r,a)      x86s(8) x86b(0x66) x86b(0x0f) x86b(0xfe) x86b(mREG(4) | mOFS32) x86d(a)
#define xPSHUFLW_r_i128_imm(r,a,i)  x86s(9) x86b(0xf2) x86b(0x0f) x86b(0x70) x86b(mREG(r) | mOFS32) x86d(a) x86b(i)
#define xPSHUFLW_r_rm_imm(r,rm,i)   x86s(5) x86b(0xf2) x86b(0x0f) x86b(0x70) x86b(mREG(r) | (rm)) x86b(i)
#define xPSHUFHW_r_i128_imm(r,a,i)  x86s(9) x86b(0xf3) x86b(0x0f) x86b(0x70) x86b(mREG(r) | mOFS32) x86d(a) x86b(i)
#define xPSHUFHW_r_rm_imm(r,rm,i)   x86s(5) x86b(0xf3) x86b(0x0f) x86b(0x70) x86b(mREG(r) | (rm)) x86b(i)
#define xPUNPCKLBWX_r_rm(r,rm)      x86s(4) x86b(0x66) x86b(0x0f) x86b(0x60) x86b(mREG(r) | (rm))
#define xPUNPCKLBWX_r_i128(r,a)     x86s(8) x86b(0x66) x86b(0x0f) x86b(0x60) x86b(mREG(r) | mOFS32) x86d(a)
#define xPUNPCKLWDX_r_rm(r,rm)      x86s(4) x86b(0x66) x86b(0x0f) x86b(0x61) x86b(mREG(r) | (rm))
#define xPUNPCKLWDX_r_i128(r,a)     x86s(8) x86b(0x66) x86b(0x0f) x86b(0x61) x86b(mREG(r) | mOFS32) x86d(a)
#define xPUNPCKLDQX_r_rm(r,rm)      x86s(4) x86b(0x66) x86b(0x0f) x86b(0x62) x86b(mREG(r) | (rm))
#define xPUNPCKLDQX_r_i128(r,a)     x86s(8) x86b(0x66) x86b(0x0f) x86b(0x62) x86b(mREG(r) | mOFS32) x86d(a)

 /*
 * 3dnow opcodes
 */
#define xFEMMS                  x86s(2) x86b(0x0f) x86b(0x0e)
#define xPFMUL_r_rm(r,rm)       x86s(4) x86b(0x0f) x86b(0x0f) x86b(mREG(r) | (rm)) x86b(0xb4)
#define xPFSUB_r_rm(r,rm)       x86s(4) x86b(0x0f) x86b(0x0f) x86b(mREG(r) | (rm)) x86b(0x9a)
#define xPFADD_r_rm(r,rm)       x86s(4) x86b(0x0f) x86b(0x0f) x86b(mREG(r) | (rm)) x86b(0x9e)
#define xPUNPCKHDQ_r_rm(r,rm)   x86s(3) x86b(0x0f) x86b(0x6a) x86b(mREG(r) | (rm))
#define xPUNPCKLDQ_r_rm(r,rm)   x86s(3) x86b(0x0f) x86b(0x62) x86b(mREG(r) | (rm))
#define xPFRCP_r_rm(r,rm) x86s(4) x86b(0x0f) x86b(0x0f) x86b(mREG(r) | (rm)) x86b(0x96)
#define xPFRCPIT1_r_rm(r,rm) x86s(4) x86b(0x0f) x86b(0x0f) x86b(mREG(r) | (rm)) x86b(0xa6)
#define xPFRCPIT2_r_rm(r,rm) x86s(4) x86b(0x0f) x86b(0x0f) x86b(mREG(r) | (rm)) x86b(0xb6)
#define xPSWAPD_r_rm(r,rm) x86s(4) x86b(0x0f) x86b(0x0f) x86b(mREG(r) | (rm)) x86b(0xbb)
#define xPFNACC_r_rm(r,rm) x86s(4) x86b(0x0f) x86b(0x0f) x86b(mREG(r) | (rm)) x86b(0x8a)

/*****************************************************************************
 * macros
 *****************************************************************************/

#if defined(IS_OPENGL)

#define ILC_GROW_TO(x) assert(!"can't grow ilcCount")

#else

/*****************************************************************************
 * externals
 *****************************************************************************/
void ILCGrowTo(unsigned long dwNeed);

#define ILC_GROW_TO(x) ILCGrowTo(x)

#endif

/*
 * emission
 */
#define x86s(x)                 if ((ilcCount+(x)) > ilcMax) ILC_GROW_TO(ilcCount+(x));
#define x86b(x)                 ilcData[ilcCount]=(unsigned char) (x); ilcCount++;
#define x86w(x)					*(unsigned short *) (ilcData + ilcCount) = (unsigned short) (x); ilcCount += 2;
#define x86d(x)                 *(unsigned int *) (ilcData+ilcCount) = (unsigned int) (x); ilcCount+=4;

/*
 * mod r/m
 */
#define mOFS32                  rmIND(rEBP)
#define mREG(x)                 ((x) << 3)

#define rmIND(x)                (0x00 | (x))
#define rmIND8(x)               (0x40 | (x))
#define rmIND32(x)              (0x80 | (x))
#define rmREG(x)                (0xc0 | (x))
#define rmSIB                   rmIND(rESP)
#define rmSIB8                  rmIND8(rESP)
#define rmSIB32                 rmIND32(rESP)

#define times1                  0
#define times2                  1
#define times4                  2
#define times8                  3

#if !defined(IS_OPENGL)
////// Don't use these macro names!  They are used everywhere as vars and members!
#define x1                      times1
#define x2                      times2
#define x4                      times4
#define x8                      times8
#else
////// Don't use these macro names!  They are used everywhere as vars and members!
#endif // !defined(IS_OPENGL)


// xSIBID is used to write expressions like "mov    eax, [ebx*4+0x01234567]" (index + displacement)
// Note that you can't use EBP as a base in an SIB expression the way you think you can:
// 
// mov  eax, [ebp+edx*4] != xMOV_r_rm    (rEAX, rmSIB) xSIB(rEBP,rEDX,x4)
// Specifying EBP in xSIB like this is interpreted as a 32 bit displacement. So you
// have to write:
// xMOV_r_rm    (rEAX, rmSIB8) xSIB(rEBP, rEDX, x4) xOFS8(0) which is technically:
// mov eax, [ebp+edx*4+0]

#define xSIB(r1,r2,s)           x86s(1) x86b((r1) | ((r2)<<3) | ((s)<<6))
#define xSIB32(r1,r2,e)         x86s(1) x86b((r1) | ((r2)<<3) | ((times1)<<6)) xOFS32(e)
#define xSIBID(r2,s)            x86s(1) x86b((rEBP) | ((r2)<<3) | ((s)<<6))
#define xSIB_esp                xSIB(rESP, rESP, times1)
#define xSIB8_esp(e)            xSIB_esp xOFS8(e)
#define xSIB32_esp(e)           xSIB_esp xOFS32(e)

#define x16r                    x86s(1) x86b(0x66)
#define x16m                    x86s(1) x86b(0x67)

#define xDS                     x86s(1) x86b(0x3e)

#define xOFS8(e)                x86s(1) x86b(e)
#define xOFS32(e)               x86s(4) x86d(e)

#define mMEM8(x)               ((unsigned int) &(x))
#define mMEM32(x)              ((unsigned int) &(x))
#define mMEM64(x)              ((unsigned int) &(x))
#define mMEM128(x)             ((unsigned int) &(x))

/*
 * jumps * branches
 */
#define xLABEL(x)               (x) = ilcCount;
#define xTARGET_b8(x)           *(unsigned char *) (ilcData + (x) + 1) = (unsigned char) (ilcCount - ((x) + 2));
#define xTARGET_b32(x)          *(unsigned int *) (ilcData + (x) + 2) = (unsigned int) (ilcCount - ((x) + 6));
#define xTARGET_jmp(x)          *(unsigned int *) (ilcData + (x) + 1) = (unsigned int) (ilcCount - ((x) + 5));

/*
 * inline instructions not supported by built-in asm
 */
#define rdtsc  __asm _emit 0x0f __asm _emit 0x31
#define sfence __asm _emit 0x0f __asm _emit 0xae __asm _emit 0xf8

// For tracking codegen position across function calls
#define X86_CODE_DECLARE            \
    unsigned int ilcCount, ilcMax;  \
    unsigned char *ilcData

#define X86_CODE_LOAD(p)            \
    ilcCount = (p)->ilcCount;       \
    ilcMax = (p)->ilcMax;           \
    ilcData = (p)->ilcData

#define X86_CODE_RESTORE(p)         \
    (p)->ilcCount = ilcCount;       \
    (p)->ilcMax = ilcMax;           \
    (p)->ilcData = ilcData

#ifdef __cplusplus
}
#endif

#endif // x86.h
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\common\mac\qdregions\debug.h ===
/*
	debug.h

	Change history (most recent first):

	Date		By		Comments
	----		--		--------

	02-13-2000	SF		Added new routines, tweaked some old routine names 
	02-09-2000	SF		Added definitions for the font-drawing code
	11-16-1999	SF		DEBUGGER & SYSDEBUGSTR abstracted

*/

#include <MacTypes.h>
#include <stdarg.h>

/* Examples of debugging macro usage:

	DBUG();
		Drops into MacsBug with a user break, and no message.
	DBUGSTR("This is a message\n");
		Drops into MacsBug and prints the literal C string.
	DBUGPRINTF(("Max count = %d, address = 0x%X\n", max, addr));
		Drops into MacsBug and prints the printf-style formatted C string,
		such as "Max count = 25, address = 0x259A0E".
		Note that the formatted string and numeric arguments have to be
		enclosed in an extra set of parentheses in order to hide the
		variable number of arguments from the macro preprocessor.
		Currently, the %c, %u, %d, %x, %X, %f, and %s data types are implemented.
	DBUGIF(x != 7);
		Drops into MacsBug with a user break (no message) if the
		condition is true.
	DBUGSTRIF(handle == nil, "We got a bad handle!\n");
		Drops into MacsBug if the condition is true and prints the literal C string.
	DBUGPRINTFIF(freenodes < 10, ("Node count = %d, header at 0x%x\n", freenodes, hdraddr));
		Drops into MacsBug if the condition is true and prints the printf-style
		formatted C string, such as "Node count = 7, header at 0x8B207C".
		Note that the formatted string and numeric arguments have to be
		enclosed in an extra set of parentheses in order to hide the
		variable number of arguments from the macro preprocessor.
		Currently, the %c, %u, %d, %x, %X, %f, and %s data types are implemented.
	DBUGASSERT(x >= 0);
		Drops into MacsBug if the asserted condition is false, printing a message
		that lists the failed assertion condition and the file name and line
		number of the ASSERT statement, such as:
		"ASSERT(x >= 0) failed: 'main.c' line 324"

	// These are the 'drawing directly to the screen' equivalents
	_RAWSTR("This is a message\n");
		Draws the literal C string directly to the screen.  It doesn't invoke MacsBug.
	_RAWPRINTF(("Max count = %d, address = 0x%X\n", max, addr));
		Draws the printf-style formatted C string directly to the screen,
		such as "Max count = 25, address = 0x259A0E".  It doesn't invoke MacsBug.
		Note that the formatted string and numeric arguments have to be
		enclosed in an extra set of parentheses in order to hide the
		variable number of arguments from the macro preprocessor.
		Currently, the %c, %u, %d, %x, %X, %f, and %s data types are implemented.
	_RAWSTRIF(handle == nil, "We got a bad handle (it was nil)!\n");
		If the condition is true, it draws the literal C string directly to the screen.
		It doesn't invoke MacsBug.
	_RAWPRINTFIF(freenodes < 10, ("Node count = %d, header at 0x%x\n", freenodes, hdraddr));
		If the condition is true, it draws the printf-style formatted C string directly
		to the screen, such as "Node count = 7, header at 0x8B207C".  It doesn't invoke
		MacsBug.  Note that the formatted string and numeric arguments have to be
		enclosed in an extra set of parentheses in order to hide the
		variable number of arguments from the macro preprocessor.
		Currently, the %c, %u, %d, %x, %X, %f, and %s data types are implemented.
	_RAWASSERT(x >= 0);
		If the asserted condition is false, it prints a message directly to the screen
		that lists the failed assertion condition and the file name and line
		number of the ASSERT statement, such as:
		"ASSERT(x >= 0) failed: 'main.c' line 324"  It doesn't invoke MacsBug.
*/


#if DEBUG_BUILD	// All the macros are enabled and generate code for debug builds

// allow overrides via a Makefile
#ifndef _LOGTOMEM
#define _LOGTOMEM	0       	// Set to 1 to log to memory
#endif

#ifndef _RAWDRAW
#define _RAWDRAW	0			// Set to 1 for raw screen printfs, 0 to suppress
#endif

#define DEBUGGER	if ((*(UInt8 *)0xBFF & 0x20) != 0) Debugger	// Debugger for apps, SysDebug for drivers
#define DEBUGSTR	if ((*(UInt8 *)0xBFF & 0x20) != 0) DebugStr	// DebugStr for regular apps, SysDebugStr for drivers

#define DBUG()						\
			DEBUGGER()
#define DBUGSTR(str)				\
			DEBUGSTR("\p" str)
#define DBUGPRINTF(parenargs)		\
			DEBUGSTR(dbugfmttopstr parenargs)
#define DBUGIF(cond)				\
			if (cond)				\
				DEBUGGER()
#define DBUGSTRIF(cond, str)		\
			if (cond)				\
				DEBUGSTR("\p" str)
#define DBUGPRINTFIF(cond, parenargs)	\
			if (cond)				\
				DEBUGSTR(dbugfmttopstr parenargs)

/* The following two macros are utilities to do argument-to-string conversion. */
#define _QUOTE(_x)					#_x
#define _MAKESTR(_x)				_QUOTE(_x)

/* The DBUGASSERT macro tells us what file and line the assertion failed at. */
#define DBUGASSERT(cond)			\
			if (!(cond))			\
				DEBUGSTR("\pASSERT(" #cond ") failed: '" __FILE__	\
							"' line " _MAKESTR(__LINE__))
#if _LOGTOMEM

typedef struct {
	UInt32		signature;
	UInt32		memType;
	UInt8		*bufBase;
	UInt32		bufSize;
	UInt32		putOffset;
	UInt32		getOffset;
} LogHdr, *LogHdrPtr;

#define NOWRAP			0				// Don't wrap output in the buffer
#define DOWRAP			1				// Wrap output in the buffer
#define BUFFERWRAP		NOWRAP			// Set to DOWRAP or NOWRAP
#define SYSTEMMEM		0
#define VIDEOMEM		1
#define LOGMEM			SYSTEMMEM		// Set to SYSTEMMEM or VIDEOMEM
#define VIDEOBUFSIZE	(2*1024*1024)
#define VIDEOBUFOFFSET	(24*1024*1024)
#define SYSTEMBUFSIZE	(2*1024*1024)

#define LOGPROPERTY					"LOG"			// Our logging property name
#define LOGONSIGNATURE				'LOG1'			// Signature showing we're logging
#define LOGOFFSIGNATURE				'LOG0'			// Signature showing logging is disabled
#define DEVICENAME					"NVDA,NVMac"	// C string
#define DEVICEPNAMEANDNULL			"\p" DEVICENAME "\0"

#define LOGSTR(str)					\
			dbglogstr(str)
#define LOGPRINTF(parenargs)		\
			dbglogstr(dbugfmttostr parenargs)
#define LOGPRINTFIF(cond, parenargs)	\
			if (cond)				\
				dbglogstr(dbugfmttostr parenargs)
#else

#define LOGSTR(str)
#define LOGPRINTF(parenargs)
#define LOGPRINTFIF(cond, parenargs)

#endif


#if _RAWDRAW

#define _RAWSTR(str)				\
			dbgdrawstr(str)
#define _RAWPRINTF(parenargs)		\
			dbgdrawstr(dbugfmttostr parenargs)
#define _RAWSTRIF(cond, str)		\
			if (cond)				\
				dbgdrawstr(str)
#define _RAWPRINTFIF(cond, parenargs)	\
			if (cond)				\
				dbgdrawstr(dbugfmttostr parenargs)
#define _RAWASSERT(cond)			\
			if (!(cond))			\
				dbgdrawstr("ASSERT(" #cond ") failed: '" __FILE__	\
							"' line " _MAKESTR(__LINE__) "\n")

#else

#define _RAWSTR(str)
#define _RAWPRINTF(parenargs)
#define _RAWSTRIF(cond, str)
#define _RAWPRINTFIF(cond, parenargs)
#define _RAWASSERT(cond)				

#endif

//=====================================================================================================
//
// Routines exported from debug.c (see that file for full descriptions)
//
//=====================================================================================================

extern char *dbugfmttostr(const char *fmt, ...);
extern UInt8 *dbugfmttopstr(const char *fmt, ...);
extern int dbugsprintf(char *dest, const char *fmt, ...);
extern int dbugvsprintf(char *dest, const char *fmt, va_list args);
extern void dbglogstr(char *str);
extern void dbgdrawstr(char *str);

// The following are utility routines used by dbugsprintf() to format different types
//	of data values.  Most of the time you won't need to use them directly, but they're
//	listed here for completeness.  Consult the code in debug.c for sprintf() for
//	examples of how to use them.
extern int int32todecfmtstr(SInt32 s32val, UInt8 *dest, int fieldwidth, int flags);
extern int uint32tohexfmtstr(UInt32 u32val,  UInt8 *dest, int fieldwidth, int flags);
extern int float64todecfmtstr(Float64 f64val, UInt8 *dest, int fieldwidth,
								int precision, int flags);
extern int strtofmtstr(UInt8 *src, UInt8 *dest, int fieldwidth, int flags);
extern int millisectimestampfmtstr(UInt8 *dest, int fieldwidth, int flags);

// Numeric & string conversion flags (used if you call the 'XtoYfmtstr' routines directly)
enum {
	DONTTERMINATE = 1,	// Don't null-terminate the string if this flag is set
	UNSIGNED_F = 2,		// Force an unsigned number conversion (other sign options are ignored)
	PLUSSIGN_F = 4,		// For signed numbers >= 0, force a '+' in the sign position
	SPACESIGN_F = 8,	// For signed numbers >= 0, force a space in the sign position
	LEFTALIGN_F = 16,	// Left-justify the result in the destination field (overrides zero fill)
	ZEROFILL_F = 32,	// Use leading zeros for padding to a field width
	LOWERCASE_F = 64	// Use lower case hex digits: a-f instead of A-F
};


#else	// All the macros are disabled and don't generate any code for release builds


#define DBUG()
#define DBUGSTR(str)
#define DBUGPRINTF(parenargs)
#define DBUGIF(cond)
#define DBUGSTRIF(cond, str)
#define DBUGPRINTFIF(cond, parenargs)
#define DBUGASSERT(cond)

#define _LOGTOMEM	0	// Don't do logging if we're not doing a debug build
#define LOGSTR(str)
#define LOGPRINTF(parenargs)
#define LOGPRINTFIF(cond, parenargs)

#define _RAWDRAW	0	// Don't do raw drawing if we're not doing a debug build
#define _RAWSTR(str)
#define _RAWPRINTF(parenargs)
#define _RAWSTRIF(cond, str)
#define _RAWPRINTFIF(cond, parenargs)
#define _RAWASSERT(cond)				

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\common\mac\qdregions\ReleaseBuild.h ===
/******************************************************************************

 ReleaseBuild.h -- for the Resource-Manager-aware display driver

 *****************************************************************************/

#define DEBUG_BUILD			0
#define PROFILE_BUILD		0
#define STANDALONE_BUILD	0
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\common\mac\utils\QD app\DebugBuild.h ===
/******************************************************************************

 DebugBuild.h -- for the Resource-Manager-aware display driver

 *****************************************************************************/

#define DEBUG_BUILD			1
#define PROFILE_BUILD		0
#define STANDALONE_BUILD	0
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\common\mac\utils\QD app\debug.c ===
/*
	debug.c

	Change history (most recent first):

	Date		By		Comments
	----		--		--------

	02-13-2000	SF		Reorganized the code, added more comments
	02-11-2000	SF		Added 'u', 's', 'f', field width, and precision support ('f' only)
	02-09-2000	SF		Added font-drawing tables and code for tough debugs
	12-08-1999	SF		Added 'c', 'X', and 'x' support, skip width specifier
	11-16-1999	SF		Basic macros and procedure names

*/

#include <stdarg.h>
#include <stdio.h>
#include <string.h>
#include <MacTypes.h>
#include <QuickDraw.h>
#include "debug.h"


#if DEBUG_BUILD		// Only generate code if we're doing a debug build

static char dbugstrbuf[512];	// Should be big enough for our usage


//=====================================================================================================
//
// dbugfmttostr()
//
//	This renders a printf-style argument list into a C string in a static buffer, and
//	returns a pointer to the beginning of the C string.  The arguments are the same as
//	what printf() uses.  See the description of dbugsprintf() for comments on the supported
//	print formatting options.
//
//=====================================================================================================

char *dbugfmttostr(const char *fmt, ...)
{
	va_list args;

	va_start(args, fmt);
	dbugvsprintf(&dbugstrbuf[0], fmt, args);
	va_end(args);
	return(dbugstrbuf);		// Point to the Pascal string (length byte first)
}

//=====================================================================================================
//
// dbugfmttopstr()
//
//	This renders a printf-style argument list into a Pascal string in a static buffer, and
//	returns a pointer to the beginning of the Pascal string.  The arguments are the same as
//	what printf() uses.  See the description of dbugsprintf() for comments on the supported
//	print formatting options.
//
//=====================================================================================================

UInt8 *dbugfmttopstr(const char *fmt, ...)
{
	va_list args;

	va_start(args, fmt);
	dbugstrbuf[0] = dbugvsprintf(&dbugstrbuf[1], fmt, args);	// Set the Pascal length byte
	va_end(args);
	return((UInt8 *)dbugstrbuf);	// Point to the Pascal string (length byte first)
}

//=====================================================================================================
//
// dbugsprintf()
//
//	It's equivalent to sprintf() -- it operates on C strings, recognizes many of the same
//	formatting options as sprintf, and returns the number of characters written to the
//	destination buffer.  It supports the following format types: c, u, d, x, X, f, and s,
//	with optional flags field width, and precision support ('f' only)
//	The 'precision' specifier is only implemented for floating point numbers, and '%f'
//	is the only floating point format implemented.  The field width specifier is fully
//	implemented for the options where it makes sense.  (See printf() documentation.)
//
//=====================================================================================================

int dbugsprintf(char *dest, const char *fmt, ...)
{
	int n;
	va_list args;

	va_start(args, fmt);
	n = dbugvsprintf(dest, fmt, args);
	va_end(args);
	return(n);		// Return the number of characters transferred
}

//=====================================================================================================
//
// dbugvsprintf()
//
//	This does the guts of dbugsprintf(), and takes a var-arg list instead of '...'
//
//=====================================================================================================

int dbugvsprintf(char *dest, const char *fmt, va_list args)
{
	int ch, fieldwidth, precision, flags;
	int usedefaultprecision;
	SInt32 s32val;
	UInt32 u32val;
	Float64 f64val;
	UInt8 *f, *d, *specptr;
	UInt8 *strpval;

	if (dest == nil)
		return(0);	// If we don't have a destination, we didn't do any characters

	f = (UInt8 *)fmt;
	d = (UInt8 *)dest;

	while ((ch = *f++) != 0) {
		if (ch != '%') {
			*d++ = ch;
			continue;
		}
		specptr = f - 1;	// Save a pointer to the '%' specifier, in case of syntax errors
		ch = *f++;

		flags = DONTTERMINATE;	// Don't terminate substrings -- we'll null-terminate when we're all done
		// Check for left-alignment
		if (ch == '-') {
			flags |= LEFTALIGN_F;
			ch = *f++;
		}
		// Check for using a plus sign for non-negative numbers
		if (ch == '+') {
			flags |= PLUSSIGN_F;
			ch = *f++;
		}
		// Check for using a space character (sign place-holder) for non-negative numbers
		if (ch == ' ') {
			flags |= SPACESIGN_F;
			ch = *f++;
		}
		// Check for leading zero fill
		if (ch == '0') {
			flags |= ZEROFILL_F;
			// Don't bump the character pointer in case '0' was the only digit
		}
		// Collect the field width specifier
		fieldwidth = 0;	// Default field width
		while (ch >= '0' && ch <= '9') {
			fieldwidth = fieldwidth * 10 + ch - '0';
			ch = *f++;
		}
		usedefaultprecision = true;	// In case a precision wasn't specified
		// Check for a precision specifier
		if (ch == '.') {	// We have a precision specifier, skip the '.'
			ch = *f++;
			precision = 0;	// Start with 0
			while (ch >= '0' && ch <= '9') {
				precision = precision * 10 + ch - '0';
				ch = *f++;
			}
			usedefaultprecision = false;
		}

		// Perform the conversion operation
		switch (ch) {
		case 'c':	// Copy an ASCII character
			u32val = va_arg(args, int);
			*d++ = u32val;
			break;
		case 'u':	// Copy a formatted, unsigned decimal number
			flags |= UNSIGNED_F;
		case 'd':	// Copy a formatted, signed decimal number
			s32val = va_arg(args, int);
			// Format the number, increment the dest pointer by the characters copied
			d += int32todecfmtstr(s32val, d, fieldwidth, flags);
			break;
		case 'x':	// Copy a formatted, lower-case hexadecimal number
			flags |= LOWERCASE_F;
		case 'X':	// Copy a formatted, upper-case hexadecimal number
			u32val = va_arg(args, int);
			// Format the number, increment the dest pointer by the characters copied
			d += uint32tohexfmtstr(u32val, d, fieldwidth, flags);
			break;
		case 'f':	// Copy a formatted floating point number
			f64val = va_arg(args, Float64);
			if (usedefaultprecision)
				precision = 6;
			// Format the number, increment the dest pointer by the characters copied
			d += float64todecfmtstr(f64val, d, fieldwidth, precision, flags);
			break;
		case 's':	// Copy a formatted string
			strpval = va_arg(args, UInt8 *);
			d += strtofmtstr(strpval, d, fieldwidth, flags);
			break;
		case '%':	// Copy a formatted '%' sign
			d += strtofmtstr((UInt8 *)"%", d, fieldwidth, flags);
			break;
		case 0:		// Gracefully handle premature end-of-string
			f--;	// Back up, now f points to the null character again
		default:	// Unexpected conversion operator, so just echo to the destination
			while (specptr < f)
				*d++ = *specptr++;
			if (ch == 0)
				goto stringdone;
			break;
		}
	}

stringdone:
	*d = 0;	// Null-terminate the string
	return(d - (UInt8 *)dest);	// Return the number of characters we transferred
}

enum {	// Padding option definitions
	PRESPACE_O = 1,
	PREZERO_O = 2,
	POSTSPACE_O = 4
};


#define NUMBUFSIZE	16	// Should be enough for 32-bit integers in decimal or hex

//=====================================================================================================
//
// int32todecfmtstr()
//
//	This takes a 32-bit integer value and converts it to a formatted decimal string,
//	using options (field width and flags) like those provided by sprintf().  The 32-bit
//	number is assumed to be signed unless the UNSIGNED_F flag is set.  Look at the code
//	for dbugsprintf() above to see which formatting options are implemented.
//
//=====================================================================================================

int int32todecfmtstr(SInt32 s32val, UInt8 *dest, int fieldwidth, int flags)
{
	int i, digitcount, destcount;
	int sign, signchar;
	int fillcount;
	int pad_options;
	UInt32 u32val, quotient, remainder;
	UInt8 *intdigp;
	UInt8 nbuf[NUMBUFSIZE];

	// Process the sign-related options
	if (flags & UNSIGNED_F) {	// Unsigned conversion
		sign = 0;	// No sign character
	} else {	// We're doing a signed conversion
		sign = 1;	// Assume we'll have a sign character
		if (s32val < 0) {
			signchar = '-';
			s32val = -s32val;	// Make the number positive now so we can 'digitize' it
		} else {	// s32val >= 0
			if (flags & PLUSSIGN_F)
				signchar = '+';
			else if (flags & SPACESIGN_F)
				signchar = ' ';
			else
				sign = 0;	// No sign character
		}
	}
	u32val = s32val;	// Do unsigned math from here on out

	// Convert the number into ASCII decimal digits in our local buffer, counting them
	intdigp = &nbuf[NUMBUFSIZE];	// Point past the last character in the buffer
	digitcount = 0;	// Nothing written to our local buffer yet
	do {
		quotient = u32val / 10;
		remainder = u32val - quotient * 10;
		*--intdigp = remainder + '0';	// Put the digit into the next lower buffer slot
		digitcount++;
		u32val = quotient;
	} while (u32val > 0);

	// Process the field-padding options
	pad_options = 0;	// Assume we won't be doing any padding
	fillcount = fieldwidth - (sign + digitcount);	// Account for the sign, if used
	if (fillcount > 0) {	// We need to do left or right padding
		if (flags & LEFTALIGN_F) {
			pad_options = POSTSPACE_O;
		} else {	// Right-aligned, fill with zeros or spaces
			if (flags & ZEROFILL_F)
				pad_options = PREZERO_O;
			else
				pad_options = PRESPACE_O;
		}
	}

	destcount = 0;	// Nothing written out to the destination yet

	// Copy any leading spaces
	if (pad_options & PRESPACE_O) {
		for (i = 0; i < fillcount; i++)	// Copy the pad character(s)
			*dest++ = ' ';
		destcount += fillcount;
	}
	// Copy the sign character, if any
	if (sign) {
		*dest++ = signchar;
		destcount++;
	}
	// Copy any leading zeros
	if (pad_options & PREZERO_O) {
		for (i = 0; i < fillcount; i++)	// Copy the pad character(s)
			*dest++ = '0';
		destcount += fillcount;
	}
	// Copy the decimal digits from our local buffer
	for (i = 0; i < digitcount; i++)
		*dest++ = *intdigp++;
	destcount += digitcount;

	// Copy any trailing spaces
	if (pad_options & POSTSPACE_O) {
		for (i = 0; i < fillcount; i++)	// Copy the pad character(s)
			*dest++ = ' ';
		destcount += fillcount;
	}
	if ((flags & DONTTERMINATE) == 0)	// Null-terminate the string unless requested not to
		*dest = 0;
	return(destcount);	// Return the character count, not including the null
}

//=====================================================================================================
//
// uint32tohexfmtstr()
//
//	This takes a 32-bit unsigned integer value and converts it to a formatted hexadecimal
//	string, using options (field width and flags) like those provided by sprintf().  Look
//	at the code for dbugsprintf() above to see which formatting options are implemented.
//
//=====================================================================================================

int uint32tohexfmtstr(UInt32 u32val,  UInt8 *dest, int fieldwidth, int flags)
{
	int i, digitcount, destcount;
	int c, hexadjust;
	int fillcount;
	UInt8 fillchar;
	int pad_options;
	UInt32 quotient;
	UInt8 *intdigp;
	UInt8 nbuf[NUMBUFSIZE];

	hexadjust = 'A' - '9' - 1;
	if (flags & LOWERCASE_F)
		hexadjust += 'a' - 'A';

	// Convert the number into ASCII hex digits in our local buffer, counting them
	intdigp = &nbuf[NUMBUFSIZE];	// Point past the last character in the buffer
	digitcount = 0;	// Nothing written to our local buffer yet
	do {
		quotient = u32val / 16;
		c = u32val % 16 + '0';
		if (c > '9')	/* A-F */
			c += hexadjust;
		*--intdigp = c;	// Put the digit into the next lower buffer slot
		digitcount++;
		u32val /= 16;
	} while (u32val > 0);

	// Process the field-padding options
	pad_options = 0;	// Assume we won't be doing any padding
	fillcount = fieldwidth - digitcount;	// No sign to worry about
	if (fillcount > 0) {	// We need to do left or right padding
		fillchar = ' ';		// Most common fill character is the space
		if (flags & LEFTALIGN_F) {
			pad_options = POSTSPACE_O;
		} else {	// Right-aligned, fill with zeros or spaces
			if (flags & ZEROFILL_F) {
				pad_options = PREZERO_O;
				fillchar = '0';
			} else {
				pad_options = PRESPACE_O;
			}
		}
	}

	destcount = 0;	// Nothing written out to the destination yet

	// Copy any leading zeros or spaces
	if (pad_options & (PREZERO_O | PRESPACE_O)) {
		for (i = 0; i < fillcount; i++)	// Copy the pad character(s)
			*dest++ = fillchar;
		destcount += fillcount;
	}
	// Copy the hex digits from our local buffer
	for (i = 0; i < digitcount; i++)
		*dest++ = *intdigp++;
	destcount += digitcount;

	// Copy any trailing spaces
	if (pad_options & POSTSPACE_O) {
		for (i = 0; i < fillcount; i++)	// Copy the pad character(s)
			*dest++ = fillchar;
		destcount += fillcount;
	}
	if ((flags & DONTTERMINATE) == 0)	// Null-terminate the string unless requested not to
		*dest = 0;
	return(destcount);	// Return the character count, not including the null
}

//=====================================================================================================
//
// float64todecfmtstr()
//
//	This takes a 64-bit floating-point value and converts it to a formatted decimal
//	string, using options (field width, precision, and flags) like those provided by
//	sprintf().  Look at the code for dbugsprintf() above to see which formatting options
//	are implemented.
//
//=====================================================================================================

int float64todecfmtstr(Float64 f64val, UInt8 *dest, int fieldwidth,
								int precision, int flags)
{
	int i, firstcount, destcount;
	int sign, signchar, decpt;
	int fillcount;
	int pad_options;
	int reducecount, loopdigits, digitsleft;
	UInt32 u32val, quotient, remainder;
	Float64 f64mant9, f64mant9factor, fone, ften, fbillion, powerof10;
	UInt8 *digp;
	UInt8 nbuf[NUMBUFSIZE];	// This only needs to hold the first 9 digits of the integer part

	// Process the sign-related options
	sign = 1;	// Assume at first we'll have a sign character
	if (f64val < 0.0) {
		signchar = '-';
		f64val = -f64val;	// Make the number positive now so we can 'digitize' it
	} else {	// f64val >= 0.0
		if (flags & PLUSSIGN_F)
			signchar = '+';
		else if (flags & SPACESIGN_F)
			signchar = ' ';
		else
			sign = 0;	// No sign character
	}

	// Round the number to N decimal places.  We add 0.5 x 10^(-N), which is
	//	equivalent to adding 1 / (2*10^N).  We'll use this latter formula.
	fone = 1.0;		// Keep the compiler from always loading these constants from memory
	ften = 10.0;
	powerof10 = fone;	// 10 ^ 0
	for (i = 0; i < precision; i++)
		powerof10 *= ften;	// Build 10 ^ N
	f64val += fone / (2.0 * powerof10);
	// f64val now contains the properly rounded number

	f64mant9 = f64val;	// Start hunting for the mantissa's 9 uppermost decimal digits
	fbillion = 1e9;		// Keep it in a register
	f64mant9factor = fone;
	// Reduce the mantissa to less than 1 billion, so it will fit in a 32-bit integer
	for (reducecount = 0; f64mant9 >= fbillion; reducecount++) {
		f64mant9 /= fbillion;
		f64mant9factor *= fbillion;
	}

	// Process the highest 32-bits of the mantissa so we can count those digits first

	f64mant9 = f64val / f64mant9factor;	// Grab highest 9 integer decimal digits
	u32val = f64mant9;	// Drop any fraction
	f64mant9 = u32val;	// Now we have a float with only an integer part
	f64val -= f64mant9 * f64mant9factor;	// Subtract out the previous high digits
	f64mant9factor /= fbillion;		// Adjust our division factor

	// Convert the binary into ASCII decimal digits in our local buffer, counting them
	digp = &nbuf[NUMBUFSIZE];	// Point past the last char. of these 9 digits
	firstcount = 0;	// No digits of the first 32-bit integer part yet
	do {
		quotient = u32val / 10;
		remainder = u32val - quotient * 10;
		*--digp = remainder + '0';	// Put the digit into the next lower buffer slot
		firstcount++;
		u32val = quotient;
	} while (u32val > 0);

	// Figure out whether we'll have a decimal point
	decpt = (precision > 0);	// Don't use a decimal point if no fractional part

	// Process the field-padding options
	pad_options = 0;	// Assume we won't be doing any padding
	// We have the information we need to calculate how many output characters we'll have
	fillcount = fieldwidth - (sign + firstcount + (reducecount * 9) + decpt + precision);
	if (fillcount > 0) {	// We need to do left or right padding
		if (flags & LEFTALIGN_F) {
			pad_options = POSTSPACE_O;
		} else {	// Right-aligned, fill with zeros or spaces
			if (flags & ZEROFILL_F)
				pad_options = PREZERO_O;
			else
				pad_options = PRESPACE_O;
		}
	}

	destcount = 0;	// Nothing written out to the destination yet

	// Copy any leading spaces
	if (pad_options & PRESPACE_O) {
		for (i = 0; i < fillcount; i++)	// Copy the pad character(s)
			*dest++ = ' ';
		destcount += fillcount;
	}
	// Copy the sign character, if any
	if (sign) {
		*dest++ = signchar;
		destcount++;
	}
	// Copy any leading zeros
	if (pad_options & PREZERO_O) {
		for (i = 0; i < fillcount; i++)	// Copy the pad character(s)
			*dest++ = '0';
		destcount += fillcount;
	}
	// Copy the highest chunk of integer digits from the local buffer
	for (i = 0; i < firstcount; i++)
		*dest++ = *digp++;
	destcount += firstcount;

	// Now we need to convert the remaining integer digits, if any
	for (i = 0; i < reducecount; i++) {
		f64mant9 = f64val / f64mant9factor;	// Grab 9 more decimal digits
		u32val = f64mant9;		// Drop any fraction
		f64mant9 = u32val;		// Now we have a float with only an integer part
		f64val -= f64mant9 * f64mant9factor;	// Subtract out the previous high digits
		f64mant9factor /= fbillion;			// Adjust our division factor
		// Convert the integer part into ASCII decimal digits, directly to the destination
		dest += 9;				// Point past the last char. of this 9-digit chunk
		digp = dest;
		for (loopdigits = 0; loopdigits < 9; loopdigits++) {
			quotient = u32val / 10;
			remainder = u32val - quotient * 10;
			*--digp = remainder + '0';	// Put the digit into the next lower buffer slot
			u32val = quotient;
		}
		destcount += 9;
	}
	// f64val has only the fractional part now

	if (!decpt)
		goto checktrailing;	// Skip the laborious fraction-processing part

	// Copy the decimal point
	*dest++ = '.';
	destcount++;

	// Similar to how we handled the integer part processing, we'll process up to
	//	9 digits at a time, by multiplying the fraction by a power of 10,
	//	converting to an integer, and converting digits to the destination.

	digitsleft = precision;
	do {
		loopdigits = digitsleft;
		if (loopdigits > 9)
			loopdigits = 9;
		powerof10 = fone;	// 10 ^ 0
		for (i = 0; i < loopdigits; i++)
			powerof10 *= ften;	// Build 10 ^ N
		f64val *= powerof10;	// Push some fractional digits into the integer part
		u32val = f64val;	// Conversion truncates any remaining fraction
		f64val -= u32val;	// Remove the integer part, leave remaining fraction digits
		digp = dest + loopdigits;	// Point past the last char. of this chunk
		for (i = 0; i < loopdigits; i++) {
			quotient = u32val / 10;
			remainder = u32val - quotient * 10;
			*--digp = remainder + '0';	// Put the digit into the next lower buffer slot
			u32val = quotient;
		}
		dest += loopdigits;
		destcount += loopdigits;
		digitsleft -= loopdigits;
	} while (digitsleft > 0);

checktrailing:
	// Copy any trailing spaces
	if (pad_options & POSTSPACE_O) {
		for (i = 0; i < fillcount; i++)	// Copy the pad character(s)
			*dest++ = ' ';
		destcount += fillcount;
	}
	if ((flags & DONTTERMINATE) == 0)	// Null-terminate the string unless requested not to
		*dest = 0;
	return(destcount);	// Return the character count, not including the null
}

//=====================================================================================================
//
// strtofmtstr()
//
//	This takes a source C string and converts it to a formatted output C string,
//	using options (field width and flags) like those provided by sprintf().  Look at
//	the code for dbugsprintf() above to see which formatting options are implemented.
//
//=====================================================================================================

int strtofmtstr(UInt8 *src, UInt8 *dest, int fieldwidth, int flags)
{
	int i, srclen;
	int fillcount;
	UInt8 fillchar;
	int pad_options;
	UInt8 *s, *d;

	// For padding calculations, we need to know the source string length
	for (s = src, srclen = 0; *s != 0; s++)
		srclen++;
	// Process the field-padding options
	pad_options = 0;	// Assume we won't be doing any padding
	fillcount = fieldwidth - srclen;

	if (fillcount > 0) {	// We need to do left or right padding
		fillchar = ' ';		// Most common fill character is the space
		if (flags & LEFTALIGN_F) {
			pad_options = POSTSPACE_O;
		} else {	// Right-aligned, fill with zeros or spaces
			if (flags & ZEROFILL_F) {
				pad_options = PREZERO_O;
				fillchar = '0';
			} else {
				pad_options = PRESPACE_O;
			}
		}
	}

	s = src;
	d = dest;

	// Copy any leading zeros or spaces
	if (pad_options & (PREZERO_O | PRESPACE_O)) {
		for (i = 0; i < fillcount; i++)	// Copy the pad character(s)
			*d++ = fillchar;
	}
	// Copy the characters from the source string
	for (i = 0; i < srclen; i++)
		*d++ = *s++;

	// Copy any trailing spaces
	if (pad_options & POSTSPACE_O) {
		for (i = 0; i < fillcount; i++)	// Copy the pad character(s)
			*d++ = fillchar;
	}

	if ((flags & DONTTERMINATE) == 0)	// Null-terminate the string unless requested not to
		*d = 0;
	return(d - dest);	// Return the character count, not including the null
}


#if _RAWDRAW

typedef struct {
	UInt8	ascent;
	UInt8	height;
	UInt16	rowbytes;
	UInt8	charwidth[256];
	UInt16	startoffset[256];
} fontdef, *fontdefptr;

static fontdef dbgfontdef = {   // Monaco 9
    // Ascent, height, rowbytes
     9, 11, 192,
    {   // Character width data
        0,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  0,  6,  6,
        6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,
        6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,
        6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,
        6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,
        6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,
        6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,
        6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  0,
        6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,
        6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,
        6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,
        6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,
        6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,
        6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,
        6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,
        6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6
    },
    {   // Character starting offset data
           0,      0,      6,     12,     18,     24,     30,     36,
          42,     48,     54,     60,     66,     72,     72,     78,
          84,     90,     96,    102,    108,    114,    120,    126,
         132,    138,    144,    150,    156,    162,    168,    174,
         180,    186,    192,    198,    204,    210,    216,    222,
         228,    234,    240,    246,    252,    258,    264,    270,
         276,    282,    288,    294,    300,    306,    312,    318,
         324,    330,    336,    342,    348,    354,    360,    366,
         372,    378,    384,    390,    396,    402,    408,    414,
         420,    426,    432,    438,    444,    450,    456,    462,
         468,    474,    480,    486,    492,    498,    504,    510,
         516,    522,    528,    534,    540,    546,    552,    558,
         564,    570,    576,    582,    588,    594,    600,    606,
         612,    618,    624,    630,    636,    642,    648,    654,
         660,    666,    672,    678,    684,    690,    696,    702,
         708,    714,    720,    726,    732,    738,    744,    750,
         750,    756,    762,    768,    774,    780,    786,    792,
         798,    804,    810,    816,    822,    828,    834,    840,
         846,    852,    858,    864,    870,    876,    882,    888,
         894,    900,    906,    912,    918,    924,    930,    936,
         942,    948,    954,    960,    966,    972,    978,    984,
         990,    996,   1002,   1008,   1014,   1020,   1026,   1032,
        1038,   1044,   1050,   1056,   1062,   1068,   1074,   1080,
        1086,   1092,   1098,   1104,   1110,   1116,   1122,   1128,
        1134,   1140,   1146,   1152,   1158,   1164,   1170,   1176,
        1182,   1188,   1194,   1200,   1206,   1212,   1218,   1224,
        1230,   1236,   1242,   1248,   1254,   1260,   1266,   1272,
        1278,   1284,   1290,   1296,   1302,   1308,   1314,   1320,
        1326,   1332,   1338,   1344,   1350,   1356,   1362,   1368,
        1374,   1380,   1386,   1392,   1398,   1404,   1410,   1416,
        1422,   1428,   1434,   1440,   1446,   1452,   1458,   1464,
        1470,   1476,   1482,   1488,   1494,   1500,   1506,   1512
    }
};

static UInt32 dbgfontdata[] = { // Monaco 9
    0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00001000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000008, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000002, 0x00014200,
    0x11A51400, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00C00000, 0x00000000,
    0x00000000, 0x00000000, 0x00060000, 0x00000000,
    0x00600000, 0x000041A6, 0x80000000, 0x00000000,
    0x05000000, 0x00000000, 0x00020411, 0x44082142,
    0x04200404, 0x21000000, 0x000C0002, 0x80880000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00020000, 0x81080000,
    0x00001000, 0x00000000, 0x00000000, 0x00000700,
    0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x000000C8, 0x0C100400, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000042, 0x08000500,
    0x22C00010, 0x82006880, 0x04408004, 0x40801A11,
    0x02006844, 0x08000300, 0x31201F30, 0x00000800,
    0x00000000, 0x00000000, 0x00080000, 0x00000000,
    0x00800000, 0x000022CB, 0x00000000, 0x00000000,
    0x00020000, 0x00000000, 0x00050A20, 0x02105001,
    0x08500208, 0x50800869, 0xE44C2002, 0x80500000,
    0x79E79E79, 0xE79E01E7, 0x9E79E79E, 0x79E79E79,
    0xE79E79E7, 0x9E79E008, 0x51471260, 0x82042000,
    0x00002708, 0x71C13E73, 0xE71C0000, 0x8041C89C,
    0xF1CF3EF9, 0xC8880A28, 0x2289CF1C, 0xF1CFA28A,
    0x28A2F884, 0x04280200, 0x80008018, 0x08082202,
    0x00000000, 0x00020000, 0x00000082, 0x0469C21C,
    0xFA272220, 0x4514B140, 0x08214508, 0x21452C20,
    0x8514B082, 0x14508480, 0x41003A4B, 0xCF3D1140,
    0x1E740204, 0x222008FB, 0xF00838C7, 0x00008100,
    0x00800000, 0x000071C7, 0x1E00000A, 0x78430001,
    0x48823800, 0x0C388000, 0x01071F73, 0xEF800080,
    0x1C702722, 0x022014B0, 0x03805005, 0x00200000,
    0x49249249, 0x24920124, 0x92492492, 0x49249249,
    0x24924924, 0x92492008, 0x53EAAA90, 0x8204A880,
    0x00002898, 0x8A232080, 0x28A23181, 0x002228A2,
    0x8A28A082, 0x28880A48, 0x36CA28A2, 0x8A22228A,
    0x25220884, 0x04440100, 0x80008020, 0x08000202,
    0x00000000, 0x00020000, 0x00000082, 0x04B22722,
    0x8328A200, 0x00000080, 0x00000000, 0x00000000,
    0x00000000, 0x0001C488, 0x40873A88, 0x20972001,
    0x28880208, 0x12200449, 0x20084928, 0x80040000,
    0x18808800, 0x00008A28, 0xA8000014, 0x28810820,
    0x08844400, 0x10488000, 0x02A8908A, 0x08082082,
    0x228848A2, 0x8A202200, 0x00002000, 0x00000000,
    0x49249249, 0x24920124, 0x92492492, 0x49249249,
    0x24924924, 0x92492008, 0x514A14A0, 0x04027080,
    0x00004988, 0x08253CF0, 0x28A23182, 0x3E102AA2,
    0x8A08A082, 0x08880A88, 0x2AAA28A2, 0x8A02228A,
    0x22221082, 0x0400001E, 0xF1C79C71, 0xEF082242,
    0x3CB1CF1E, 0xB1E7A28A, 0xA8A2F882, 0x040228A0,
    0x82A8A279, 0xE79E79E7, 0x1C71C708, 0x20822C71,
    0xC71C7228, 0xA288831C, 0xE14FBA93, 0x2697000F,
    0xA89B6F90, 0x09490621, 0x2F885928, 0x9C788100,
    0x11C7084A, 0x40008A28, 0xA870001E, 0x50C20052,
    0x2884F082, 0x3EE9C300, 0x0148908A, 0x08082082,
    0x2289B8A2, 0x8A220000, 0x00000000, 0x00000000,
    0x49249249, 0x24920124, 0x92492492, 0x49249249,
    0x24924924, 0x92492008, 0x03E70840, 0x0402ABE0,
    0x3E004A88, 0x10C90288, 0x47220004, 0x00084EBE,
    0xF208BCF2, 0x6F880B08, 0x229A2F22, 0xF1C22252,
    0x22142082, 0x04000022, 0x8A28A222, 0x28882282,
    0x2ACA28A2, 0xCA02228A, 0xA5221102, 0x0203E8A0,
    0xF268A28A, 0x28A28A28, 0xA28A2888, 0x2082328A,
    0x28A28A28, 0xA288802A, 0x412F9E92, 0xA8800002,
    0x3CAAA208, 0x13E90A11, 0x250828C8, 0xAA99013E,
    0x20889491, 0x2000FBE8, 0xACA9CFC0, 0x00003E8A,
    0x25084101, 0x12488300, 0x008F9EFB, 0xCF082082,
    0x228BE8A2, 0x8A220000, 0x00000000, 0x00000000,
    0x49249249, 0x24920124, 0x92492492, 0x49249249,
    0x24924924, 0x92492008, 0x014294A8, 0x04022080,
    0x00008C88, 0x202F8288, 0x889E0002, 0x3E108B22,
    0x8A08A082, 0x28888A88, 0x228A2822, 0x88222252,
    0xA2084081, 0x04000022, 0x8A08BE22, 0x28882382,
    0x2A8A28A2, 0x81C22252, 0xA2222082, 0x04022FA0,
    0x8228A28A, 0x28A28A28, 0x3EFBEF88, 0x2082228A,
    0x28A28A28, 0xA2888028, 0x40AF8A8B, 0x2880000F,
    0xA8CB6204, 0x20891221, 0x25080008, 0xAEAA0102,
    0xA0871491, 0x20008A28, 0xA8B80000, 0x00000052,
    0x2210F101, 0x12488000, 0x0128908A, 0x08082082,
    0x228BE8A2, 0x8A220000, 0x00000000, 0x00000000,
    0x49249249, 0x24920124, 0x92492492, 0x49249249,
    0x24924924, 0x92492000, 0x000AAA90, 0x02040086,
    0x00308888, 0x42212288, 0x88823181, 0x00200822,
    0x8A28A082, 0x28888A48, 0x228A2822, 0x8A222223,
    0x65088081, 0x04000026, 0x8A08A022, 0x28882242,
    0x2A8A28A2, 0x80222652, 0xA5224082, 0x040228A2,
    0x8228A29A, 0x69A69A68, 0x20820808, 0x2082228A,
    0x28A28A69, 0xA698802A, 0x48470A8A, 0xA6800004,
    0x28880000, 0x03E91249, 0x250879E5, 0x28CA2102,
    0x4088224A, 0x40008A28, 0xA8A00000, 0x00000822,
    0x22104482, 0x1248800C, 0x7AD8908A, 0x08082082,
    0x228BF8A2, 0x8A220000, 0x00000000, 0x00000000,
    0x79E79E79, 0xE79E01E7, 0x9E79E79E, 0x79E79E79,
    0xE79E79E7, 0x9E79E008, 0x00072468, 0x02040006,
    0x00310708, 0xF9C11C70, 0x871C3180, 0x804088A2,
    0xF1CF3E81, 0xC888722F, 0xA289C81C, 0x89C21C22,
    0x2888F880, 0x8403F01A, 0xF1E79E21, 0xE8882223,
    0x2A89CF1E, 0x83C19A21, 0x489EF882, 0x0402289C,
    0xFA271C69, 0xA69A69A7, 0x9E79E788, 0x20822271,
    0xC71C71A6, 0x9A68001C, 0xB0200BB0, 0x20800000,
    0x2F700F9E, 0x788E8CF9, 0x2508000D, 0x9EF1C100,
    0x40803E00, 0x0A808A27, 0x1E580000, 0x00000001,
    0xE2203800, 0x1249C00C, 0x29289F8B, 0xEF882082,
    0x1C71E71C, 0x71C20000, 0x00000080, 0x04000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00020000, 0x01080002,
    0x00010000, 0x00000000, 0x00000080, 0x00000700,
    0x00000000, 0x00000000, 0x00000002, 0x00000000,
    0x000000C0, 0x8C000000, 0x00000000, 0x20002000,
    0x00000802, 0x00000000, 0x00020042, 0x08000008,
    0x00000000, 0x00000002, 0x00000000, 0x00000000,
    0x00000000, 0x00000008, 0x01200083, 0xCF000000,
    0x00000000, 0x00880000, 0x00080000, 0x01000000,
    0x03000000, 0x00000000, 0x00000000, 0x00000000,
    0x20200000, 0x00008004, 0x50000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000040, 0x08000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000004,
    0x00000000, 0x00000000, 0x00000100, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000001, 0xC000C000,
    0x00000802, 0x00000000, 0x001C0002, 0x00000010,
    0x00000000, 0x00000004, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00C00000, 0x00000000,
    0x00000000, 0x00080000, 0x00300000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000001,
    0xC0000000, 0x00008008, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000080, 0x04000000
};

//=====================================================================================================
//
// dbgdrawstr()
//
//	Note: This routine assumes the maximum font character width is 32 pixels
//
//=====================================================================================================

void dbgdrawstr(char *str)	// Takes a C string
{
	static UInt32 gLineCount = 0;	// Counts how many lines we've printed
	static GDHandle gDrawingGDevH;
	static SInt32 gDrawX;	// Screen coords of top-left pixel of dest char box
	static SInt32 gDrawY;
	static SInt32 gStartX;	// Starting H coord. on the screen after horizontal wrap
	static SInt32 gStartY;	// Starting V coord. on the screen after vertical wrap
	static UInt32 gLastPageRight = 0;	// Max. right edge of the previous 'page'
	static UInt32 gCurPageRight = 0;	// Max. right edge of the current 'page'
	static UInt8 gDidEndOfLine = false;
	static UInt8 sbuf[512];
	Ptr destbase;
	UInt32 destrowbytes, destpixelshift;
	UInt32 clipheight, clipwidth;
	SInt32 destX, destY;
	SInt32 startX, startY;
	UInt32 i, j, ch;
	SInt32 clearwidth;
	UInt32 charheight, charwidth;
	UInt32 bitoffset, longindex, fontrowbytes;
	UInt32 shift, long0, long1;
	Ptr deststringrowptr, destpixrowptr, destpixptr;
	UInt32 *fontlongrowptr;
	UInt8 *bufp, *destp;
	GDHandle gdh;
	PixMapPtr pmp;
#define STARTX		0	// If set to a negative number, it insets from the right edge
#define STARTY		0	// If set to a negative number, it insets from the bottom edge
#define FGCOLOR8	0xFF
#define BGCOLOR8	0x00
#define FGCOLOR16	0x0000
#define BGCOLOR16	0x7FFF
#define FGCOLOR32	0x00000000
#define BGCOLOR32	0x00FFFFFF

	if (gLineCount == 0) {	// First-time initialization
		// We want to avoid the MacsBug screen above all, since we might be
		//	trying to debug graphics drivers that MacsBug may interact with.
		gdh = GetDeviceList();	// First device in list is the MacsBug device
		for (gdh = GetNextDevice(gdh); gdh != nil; gdh = GetNextDevice(gdh)) {
			// Secondarily, we want to avoid the menubar screen.
			if (gdh == GetMainDevice())	// Avoid the menu bar device if possible
				continue;
			goto gotgdev;	// Grab the first non-MacsBug, non-menubar screen
		}
		// Otherwise we'll just take the menubar device
		gdh = GetMainDevice();
gotgdev:
		gDrawingGDevH = gdh;
		gDidEndOfLine = true;	// Kick out a line number this time
	}

	pmp = *(*gDrawingGDevH)->gdPMap;
	destbase = pmp->baseAddr;
	destrowbytes = pmp->rowBytes & 0x7FFF;	// Mask the PixMap bit
	destpixelshift = pmp->pixelSize / 16;	// Map 8,16,32 onto 0,1,2
	clipheight = pmp->bounds.bottom - pmp->bounds.top;
	clipwidth = pmp->bounds.right - pmp->bounds.left;
	if (gLineCount == 0) {	// First-time initialization
		startY = STARTY;
		if (startY < 0)
			startY += clipheight;
		gStartY = startY;
		gDrawY = startY;

		startX = STARTX;
		if (startX < 0)
			startX += clipwidth;
		gStartX = startX;
		gDrawX = startX;
	}
	startY = gStartY;
	startX = gStartX;

	charheight = dbgfontdef.height;
	fontrowbytes = dbgfontdef.rowbytes;
	destY = gDrawY;
	destX = gDrawX;

	bufp = (UInt8 *)str;	// Get the start of the string

	if (gDidEndOfLine) {
		destp = sbuf;
		*destp++ = ' ';	// Put in a leading space for aesthetics
		// Convert the current line number into a string, as a prefix
		destp += int32todecfmtstr(gLineCount, destp, 4, DONTTERMINATE);
		*destp++ = ':';
		*destp++ = ' ';
		// Copy the rest of the source string into our buffer
		while ((*destp++ = *bufp++) != 0)
			;
		*destp = 0;	// Null-terminate the resulting string
		bufp = sbuf;
		gDidEndOfLine = false;
		gLineCount++;
	}

	for (ch = *bufp++; ch != 0; ch = *bufp++) {
		charwidth = dbgfontdef.charwidth[ch];
		deststringrowptr = destbase + destY * destrowbytes + (startX << destpixelshift);
		if (ch == '\n') {	// Check to see if we need to erase to a known width
			clearwidth = gLastPageRight - destX;
			if (clearwidth > 0) {	// We need to erase the rest of the line
				destpixrowptr = deststringrowptr + ((destX - startX) << destpixelshift);
				switch (destpixelshift) {
				case 0:		// 8 bits
					for (i = 0; i < charheight; i++) {
						destpixptr = destpixrowptr;
						for (j = 0; j < clearwidth; j++) {
							*(UInt8 *)destpixptr = BGCOLOR8;
							destpixptr += sizeof(UInt8);
						}
						destpixrowptr += destrowbytes;
					}
					break;
				case 1:		// 16 bits
					for (i = 0; i < charheight; i++) {
						destpixptr = destpixrowptr;
						for (j = 0; j < clearwidth; j++) {
							*(UInt16 *)destpixptr = BGCOLOR16;
							destpixptr += sizeof(UInt16);
						}
						destpixrowptr += destrowbytes;
					}
					break;
				default:	// 32 bits
					for (i = 0; i < charheight; i++) {
						destpixptr = destpixrowptr;
						for (j = 0; j < clearwidth; j++) {
							*(UInt32 *)destpixptr = BGCOLOR32;
							destpixptr += sizeof(UInt32);
						}
						destpixrowptr += destrowbytes;
					}
					break;
				}
			}
			gDidEndOfLine = true;	// Kick out a line number next time
		}
		// Wrap to beginning of next line if we get a newline or hit the right edge
		if (ch == '\n' || destX + charwidth > clipwidth) {
			// First save the width of the line just finished
			if (destX > gCurPageRight)
				gCurPageRight = destX;
			destX = startX;
			destY += charheight;
		}
		if (destY + charheight > clipheight) {	// Wrap vertically
			destY = startY;
			gLastPageRight = gCurPageRight;
			gCurPageRight = 0;
		}

		if (ch == '\n')	// Don't draw anything for newline
			continue;

		deststringrowptr = destbase + destY * destrowbytes + (destX << destpixelshift);
		destpixrowptr = deststringrowptr;
		bitoffset = dbgfontdef.startoffset[ch];	// Get the bit offset to the character
		longindex = bitoffset / 32;
		fontlongrowptr = &dbgfontdata[longindex];

		switch (destpixelshift) {
		case 0:		// 8 bits
			for (i = 0; i < charheight; i++) {
				// Extract and align the character's scan line data (max 32 bits)
				long0 = *fontlongrowptr;
				shift = bitoffset - longindex * 32;
				if (shift > 0) {	// Need to extract a 32-bit unaligned bitfield
					long1 = *(fontlongrowptr+1);
					long0 <<= shift;
					long1 >>= 32 - shift;
					long0 |= long1;
				}
				destpixptr = destpixrowptr;
				for (j = 0; j < charwidth; j++) {
					if (long0 & 0x80000000)	// Use foreground color
						*(UInt8 *)destpixptr = FGCOLOR8;
					else	// Use background color
						*(UInt8 *)destpixptr = BGCOLOR8;
					long0 <<= 1;
					destpixptr += sizeof(UInt8);
				}
				fontlongrowptr = (UInt32 *)((Ptr)fontlongrowptr + fontrowbytes);
				destpixrowptr += destrowbytes;
			}
			break;
		case 1:		// 16 bits
			for (i = 0; i < charheight; i++) {
				// Extract and align the character's scan line data (max 32 bits)
				long0 = *fontlongrowptr;
				shift = bitoffset - longindex * 32;
				if (shift > 0) {	// Need to extract a 32-bit unaligned bitfield
					long1 = *(fontlongrowptr+1);
					long0 <<= shift;
					long1 >>= 32 - shift;
					long0 |= long1;
				}
				destpixptr = destpixrowptr;
				for (j = 0; j < charwidth; j++) {
					if (long0 & 0x80000000)	// Use foreground color
						*(UInt16 *)destpixptr = FGCOLOR16;
					else	// Use background color
						*(UInt16 *)destpixptr = BGCOLOR16;
					long0 <<= 1;
					destpixptr += sizeof(UInt16);
				}
				fontlongrowptr = (UInt32 *)((Ptr)fontlongrowptr + fontrowbytes);
				destpixrowptr += destrowbytes;
			}
			break;
		default:	// 32 bits
			for (i = 0; i < charheight; i++) {
				// Extract and align the character's scan line data (max 32 bits)
				long0 = *fontlongrowptr;
				shift = bitoffset - longindex * 32;
				if (shift > 0) {	// Need to extract a 32-bit unaligned bitfield
					long1 = *(fontlongrowptr+1);
					long0 <<= shift;
					long1 >>= 32 - shift;
					long0 |= long1;
				}
				destpixptr = destpixrowptr;
				for (j = 0; j < charwidth; j++) {
					if (long0 & 0x80000000)	// Use foreground color
						*(UInt32 *)destpixptr = FGCOLOR32;
					else	// Use background color
						*(UInt32 *)destpixptr = BGCOLOR32;
					long0 <<= 1;
					destpixptr += sizeof(UInt32);
				}
				fontlongrowptr = (UInt32 *)((Ptr)fontlongrowptr + fontrowbytes);
				destpixrowptr += destrowbytes;
			}
			break;
		}

		destX += charwidth;
	}

	// Update the global state
	gDrawY = destY;
	gDrawX = destX;
}

#endif	// #if _RAWDRAW
#endif	// #if DEBUG_BUILD
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\common\mac\qdregions\regionparse.c ===
/******************************************************************************
 *
 *       Copyright 1993-2000 NVIDIA, Corporation.  All rights reserved.
 *
 *     NOTICE TO USER:   The source code  is copyrighted under  U.S. and
 *     international laws.  Users and possessors of this source code are
 *     hereby granted a nonexclusive,  royalty-free copyright license to
 *     use this code in individual and commercial software.
 *
 *     Any use of this source code must include,  in the user documenta-
 *     tion and  internal comments to the code,  notices to the end user
 *     as follows:
 *
 *       Copyright 1993-2000 NVIDIA, Corporation.  All rights reserved.
 *
 *     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY
 *     OF  THIS SOURCE  CODE  FOR ANY PURPOSE.  IT IS  PROVIDED  "AS IS"
 *     WITHOUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPOR-
 *     ATION DISCLAIMS ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,
 *     INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY, NONINFRINGE-
 *     MENT,  AND FITNESS  FOR A PARTICULAR PURPOSE.   IN NO EVENT SHALL
 *     NVIDIA, CORPORATION  BE LIABLE FOR ANY SPECIAL,  INDIRECT,  INCI-
 *     DENTAL, OR CONSEQUENTIAL DAMAGES,  OR ANY DAMAGES  WHATSOEVER RE-
 *     SULTING FROM LOSS OF USE,  DATA OR PROFITS,  WHETHER IN AN ACTION
 *     OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  ARISING OUT OF
 *     OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOURCE CODE.
 *
 *     U.S. Government  End  Users.   This source code  is a "commercial
 *     item,"  as that  term is  defined at  48 C.F.R. 2.101 (OCT 1995),
 *     consisting  of "commercial  computer  software"  and  "commercial
 *     computer  software  documentation,"  as such  terms  are  used in
 *     48 C.F.R. 12.212 (SEPT 1995)  and is provided to the U.S. Govern-
 *     ment only as  a commercial end item.   Consistent with  48 C.F.R.
 *     12.212 and  48 C.F.R. 227.7202-1 through  227.7202-4 (JUNE 1995),
 *     all U.S. Government End Users  acquire the source code  with only
 *     those rights set forth herein.
 *
 ******************************************************************************
 *
 * MODULE:  regionparse.c
 *
 * PURPOSE: Contains the code to decompose regions into a list of rectangles.
 *
 ******************************************************************************/

#include <Quickdraw.h>
#include <Memory.h>
#include <stdio.h>

#include "regionparse.h"
#include "debug.h"


//=====================================================================================================
//
// Definitions
//
//=====================================================================================================

#define ENDMARKER		32767	// Marks 'end of line' and 'end of region'
#define UNINITIALIZEDV	65536	// Will never match valid coordinates (-32767 to 32767)
#define MAXCOORDS		3000	// Maximum allowable complexity per line


//=====================================================================================================
//
// Declarations
// This is duplicated from OpenGL Header files
// This is present in source file instead of header to avoid duplicate
// definition of the same structure while compiling OpenGL source files
//
//=====================================================================================================

typedef struct {			// OpenGL rectangle
    int		x0;  
    int		y0;
    int		x1; 
    int		y1; 
} __GLregionRect, *__GLregionRectPtr;

//=====================================================================================================
//
// Globals
//
//=====================================================================================================

static SInt16 gXcoord[MAXCOORDS];	// Horizontal coordinates for the line's region change information
static SInt8 gRgnID[MAXCOORDS];	// Identifies which region(s) each coordinate belongs to (max 8 regions)

//=====================================================================================================
//
// Prototypes for local procedures
//
//=====================================================================================================

static int parse1rgn(Rect *mincliprectp, RgnHandle rh1, RectListInfoPtr rectlistinfop,
						RectCallbackProcPtr callbackProcPtr, void *dataPtr, int flags);
static int parseNrgns(Rect *mincliprectp, int rgncount, RgnHandle *rhap, RectListInfoPtr rectlistinfop,
						RectCallbackProcPtr callbackProcPtr, void *dataPtr, int flags);


//=====================================================================================================
//
// parse_rgns()
//
//	This is the exported procedure that intersects and clips 1-3 input regions, and outputs a list
//	of hardware-efficient rectangles that make up the resulting region.  It does some parameter
//	checking and clipping, then dispatches to the subroutines that handle the one or N-way
//	intersecting region cases.
//
//=====================================================================================================
int parse_rgns(void *startcliprectp,
				RgnHandle rh1, RgnHandle rh2, RgnHandle rh3,
				RectListInfoPtr rectlistinfop, int flags)
{
	int cliptop, clipleft, clipbottom, clipright;	// Minimum rectangle we have to clip to
	int top, left, bottom, right;
	int i, rgncount, rectcount;
	RgnPtr rgnp;
	RgnHandle rh;
	RgnHandle inrgnh[3];	// Up to 3 input regions
	RgnHandle outrgnh[3];	// List of (output) regions we actually have to parse
	void *rectp;			// Generic rectangle pointer cast to the appropriate type
	Rect mergedcliprect;	// Rect resulting from merged cliprect and the region bounding boxes
#if DEBUG_BUILD
	SInt8 hstate[3];		// Hold the prior handle state for the regions
#endif

	if (startcliprectp == nil) {	// No clip rectangle, so start with wide-open bounds
		cliptop = -32767;
		clipleft = -32767;
		clipbottom = 32767;
		clipright = 32767;
	} else if (flags & USE_GLRECT_FMT) {	// GLRect format
		clipleft = ((__GLregionRectPtr)startcliprectp)->x0;
		cliptop = ((__GLregionRectPtr)startcliprectp)->y0;
		clipright = ((__GLregionRectPtr)startcliprectp)->x1;
		clipbottom = ((__GLregionRectPtr)startcliprectp)->y1;
	} else {	// QuickDraw rect format
		cliptop = ((Rect *)startcliprectp)->top;
		clipleft = ((Rect *)startcliprectp)->left;
		clipbottom = ((Rect *)startcliprectp)->bottom;
		clipright = ((Rect *)startcliprectp)->right;
	}

	inrgnh[0] = rh1;
	inrgnh[1] = rh2;
	inrgnh[2] = rh3;
	rgncount = 0;
	rectcount = 0;

	// Check each region, updating the clip rect and collecting non-rectangular regions

	for (i = 0; i < 3; i++) {
		rh = inrgnh[i];
		if (rh == nil)	// Make sure the region handle is good
			continue;
		rgnp = *rh;
		top = rgnp->rgnBBox.top;
		left = rgnp->rgnBBox.left;
		bottom = rgnp->rgnBBox.bottom;
		right = rgnp->rgnBBox.right;
		if (top >= bottom || left >= right)	// Empty region, nothing gets drawn
			goto done;
		if (rgnp->rgnSize > 10)	// A non-rectangular region we have to parse
			outrgnh[rgncount++] = rh;
		// Update the minimum clipping rectangle if the new bounds are smaller
		if (top > cliptop)
			cliptop = top;
		if (left > clipleft)
			clipleft = left;
		if (bottom < clipbottom)
			clipbottom = bottom;
		if (right < clipright)
			clipright = right;
	}

	// If none of the regions were non-rectangular, just return the cliprect
	if (rgncount == 0) {
		rectp = rectlistinfop->rectListPtr;
		if (flags & USE_GLRECT_FMT) {	// GLRect format
			((__GLregionRectPtr)rectp)->x0 = clipleft;
			((__GLregionRectPtr)rectp)->y0 = cliptop;
			((__GLregionRectPtr)rectp)->x1 = clipright;
			((__GLregionRectPtr)rectp)->y1 = clipbottom;
		} else {	// QuickDraw rect format
			((Rect *)rectp)->top = cliptop;
			((Rect *)rectp)->left = clipleft;
			((Rect *)rectp)->bottom = clipbottom;
			((Rect *)rectp)->right = clipright;
		}
		rectlistinfop->rectCount = 1;
		return(1);
	}

	mergedcliprect.top = cliptop;
	mergedcliprect.left = clipleft;
	mergedcliprect.bottom = clipbottom;
	mergedcliprect.right = clipright;

#if DEBUG_BUILD	// Lock down the region so they don't slide if we're using GUI debuggers that can move memory
	for (i = 0; i < rgncount; i++) {
		hstate[i] = HGetState((Handle)outrgnh[i]);
		HLock((Handle)outrgnh[i]);
	}
#endif

	if (rgncount == 1)	// Use a faster routine for the one-region case
		rectcount = parse1rgn(&mergedcliprect, outrgnh[0], rectlistinfop, nil, nil, flags);
	else
		rectcount = parseNrgns(&mergedcliprect, rgncount, outrgnh, rectlistinfop, nil, nil, flags);

#if DEBUG_BUILD
	for (i = 0; i < rgncount; i++) {
		HSetState((Handle)outrgnh[i], hstate[i]);
	}
#endif

done:
	return(rectcount);
}

//=====================================================================================================
//
// parse_rgns_callback()
//
//	This is the exported procedure that intersects and clips 1-3 input regions, and calls back
//	(using the supplied procptr) a routine that gets passed each rectangle discovered in the
//	region decomposition.  (The non-callback version passes back a list of all the rectangles.)
//
//=====================================================================================================
int parse_rgns_callback(void *startcliprectp,	// Points to QuickDraw or OpenGL rectangle, or is nil
						RgnHandle rh1, RgnHandle rh2, RgnHandle rh3,	// Set unused handles to nil
						RectCallbackProcPtr callbackProcPtr, void *dataPtr,	// dataPtr is passed to callback proc
						int flags)
{
	int cliptop, clipleft, clipbottom, clipright;	// Minimum rectangle we have to clip to
	int top, left, bottom, right;
	int i, rgncount, rectcount;
	RgnPtr rgnp;
	RgnHandle rh;
	RgnHandle inrgnh[3];	// Up to 3 input regions
	RgnHandle outrgnh[3];	// List of (output) regions we actually have to parse
	void *rectp;			// Generic rectangle pointer cast to the appropriate type
	Rect mergedcliprect;	// Rect resulting from merged cliprect and the region bounding boxes
	__GLregionRect mergedcliprect_gl;	// OpenGL rect version of merged cliprect
#if DEBUG_BUILD
	SInt8 hstate[3];		// Hold the prior handle state for the regions
#endif

	if (startcliprectp == nil) {	// No clip rectangle, so start with wide-open bounds
		cliptop = -32767;
		clipleft = -32767;
		clipbottom = 32767;
		clipright = 32767;
	} else if (flags & USE_GLRECT_FMT) {	// GLRect format
		clipleft = ((__GLregionRectPtr)startcliprectp)->x0;
		cliptop = ((__GLregionRectPtr)startcliprectp)->y0;
		clipright = ((__GLregionRectPtr)startcliprectp)->x1;
		clipbottom = ((__GLregionRectPtr)startcliprectp)->y1;
	} else {	// QuickDraw rect format
		cliptop = ((Rect *)startcliprectp)->top;
		clipleft = ((Rect *)startcliprectp)->left;
		clipbottom = ((Rect *)startcliprectp)->bottom;
		clipright = ((Rect *)startcliprectp)->right;
	}

	inrgnh[0] = rh1;
	inrgnh[1] = rh2;
	inrgnh[2] = rh3;
	rgncount = 0;
	rectcount = 0;

	// Check each region, updating the clip rect and collecting non-rectangular regions

	for (i = 0; i < 3; i++) {
		rh = inrgnh[i];
		if (rh == nil)	// Make sure the region handle is good
			continue;
		rgnp = *rh;
		top = rgnp->rgnBBox.top;
		left = rgnp->rgnBBox.left;
		bottom = rgnp->rgnBBox.bottom;
		right = rgnp->rgnBBox.right;
		if (top >= bottom || left >= right)	// Empty region, nothing gets drawn
			goto done;
		if (rgnp->rgnSize > 10)	// A non-rectangular region we have to parse
			outrgnh[rgncount++] = rh;
		// Update the minimum clipping rectangle if the new bounds are smaller
		if (top > cliptop)
			cliptop = top;
		if (left > clipleft)
			clipleft = left;
		if (bottom < clipbottom)
			clipbottom = bottom;
		if (right < clipright)
			clipright = right;
	}

	// If none of the regions were non-rectangular, just return the cliprect
	if (rgncount == 0) {
		if (flags & USE_GLRECT_FMT) {	// GLRect format
			mergedcliprect_gl.x0 = clipleft;
			mergedcliprect_gl.y0 = cliptop;
			mergedcliprect_gl.x1 = clipright;
			mergedcliprect_gl.y1 = clipbottom;
			rectp = (void *)&mergedcliprect_gl;
		} else {	// QuickDraw rect format
			mergedcliprect.top = cliptop;
			mergedcliprect.left = clipleft;
			mergedcliprect.bottom = clipbottom;
			mergedcliprect.right = clipright;
			rectp = (void *)&mergedcliprect;
		}
		(*callbackProcPtr)(rectp, dataPtr);	// Do the callback for the cliprect
		return(1);
	}

	mergedcliprect.top = cliptop;
	mergedcliprect.left = clipleft;
	mergedcliprect.bottom = clipbottom;
	mergedcliprect.right = clipright;

#if DEBUG_BUILD	// Lock down the region so they don't slide if we're using GUI debuggers that can move memory
	for (i = 0; i < rgncount; i++) {
		hstate[i] = HGetState((Handle)outrgnh[i]);
		HLock((Handle)outrgnh[i]);
	}
#endif

	if (rgncount == 1)	// Use a faster routine for the one-region case
		rectcount = parse1rgn(&mergedcliprect, outrgnh[0], nil, callbackProcPtr, dataPtr, flags);
	else
		rectcount = parseNrgns(&mergedcliprect, rgncount, outrgnh, nil, callbackProcPtr, dataPtr, flags);

#if DEBUG_BUILD
	for (i = 0; i < rgncount; i++) {
		HSetState((Handle)outrgnh[i], hstate[i]);
	}
#endif

done:
	return(rectcount);
}

static int parse1rgn(Rect *mincliprectp, RgnHandle rh1, RectListInfoPtr rectlistinfop,
						RectCallbackProcPtr callbackProcPtr, void *dataPtr, int flags)
{
	int i, j, start, stop, increment, searchstart;
	int rectcount, maxrectcount;
	int rectopenv, rectclosev;
	int recttop, rectbottom, rectleft, rectright;
	int cliptop, clipleft, clipbottom, clipright;
	int horizcoord, coord;
	int xcoordcount, coordcntparity;
	void *rectp;
	RgnPtr rgnp;
	SInt16 *rgnstartp, *rgnlinep, *rgndatap;
	Rect newrect;
	__GLregionRect newrect_gl;	// OpenGL version of newrect

	rgnp = *rh1;
	rgnstartp = (SInt16 *)((Ptr)rgnp + sizeof(Region));	// Skip over the region header

	if (flags & BOTTOM_TO_TOP) {	// Scan the region lines bottom-to-top
		// Skip to the end of the region, and back up to the last two 0x7FFFs
		rgnlinep = (SInt16 *)((Ptr)rgnp + rgnp->rgnSize - 2*sizeof(SInt16));
		// Back up and find the end of the previous line's data
		do {
			// We always back up by two shorts at a time.  The region change points always come
			//	in pairs, and the line vertical coordinate is always preceded by 0x7FFF (pairs
			//	again), except for the very first line in a region.  Since non-rectangular
			//	regions must always have at least two lines of data, we're guaranteed the last
			//	line is preceded by a previous line's 0x7FFF end marker.
			rgnlinep -= 2;
		} while (*rgnlinep != ENDMARKER);
		rgnlinep++;	// rgnlinep now points to the beginning of the line's data (Y coord)
	} else {	// Top to bottom
		rgnlinep = rgnstartp;
	}

	xcoordcount = 0;
	rgndatap = rgnlinep;
	rectopenv = *rgndatap++;	// First data on the line is the vertical coordinate
	// Pre-load the first line of X coordinates into the gXcoord array
	coordcntparity = 0;
	for (horizcoord = *rgndatap++; horizcoord != ENDMARKER || coordcntparity != 0; horizcoord = *rgndatap++) {
		gXcoord[xcoordcount++] = horizcoord;
		coordcntparity ^= 1;
	}

	cliptop = mincliprectp->top;
	clipleft = mincliprectp->left;
	clipbottom = mincliprectp->bottom;
	clipright = mincliprectp->right;

	rectcount = 0;
	if (rectlistinfop != nil) {	// We're building a rectangle list
		maxrectcount = rectlistinfop->maxRectCount;
		rectp = rectlistinfop->rectListPtr;
	}

	do {	// Keep processing lines of the region definition until we're done

		if (flags & BOTTOM_TO_TOP) {	// Scan the region lines bottom-to-top
			if (rgnlinep <= rgnstartp)
				break;
			rgnlinep--;	// Point to the even-earlier line's 0x7FFF end marker
			// Back up and find the end of the previous line's data.
			do {
				// We always back up by two shorts at a time.  The region change points always come
				//	in pairs, and the line vertical coordinate is always preceded by 0x7FFF (pairs
				//	again), except for the very first line in a region, which we also check for.
				rgnlinep -= 2;
			} while (*rgnlinep != ENDMARKER && rgnlinep > rgnstartp);
			rgnlinep++;	// rgnlinep now points to the beginning of the current line's data (Y coord)
			rgndatap = rgnlinep;
			rectclosev = *rgndatap++;
			recttop = rectclosev;	// Going bottom to top, the top Y coordinate is the latest one
			rectbottom = rectopenv;
		} else {	// Doing top to bottom
			rectclosev = *rgndatap++;
			if (rectclosev == ENDMARKER)
				break;
			recttop = rectopenv;	// Going top to bottom, the top Y coordinate was the earlier one
			rectbottom = rectclosev;
		}
		// Clip top and bottom to our clipping vertical bounds
		if (recttop < cliptop)
			recttop = cliptop;
		if (rectbottom > clipbottom)
			rectbottom = clipbottom;

		if (recttop < rectbottom) {	// Don't output rectangles clipped to zero height

			// Each new region definition line will flush out the old rectangles

			if (flags & RIGHT_TO_LEFT) {	// Do the reverse (right-to-left) horizontal rectangle order
				start = xcoordcount - 2;
				stop = -2;
				increment = -2;
			} else {			// Do the normal (left-to-right) horizontal rectangle order
				start = 0;
				stop = xcoordcount;
				increment = 2;
			}
			for (i = start; i != stop; i += increment) {
				rectleft = gXcoord[i];
				rectright = gXcoord[i+1];
				// Eliminate any rectangles horizontally outside the clipping rectangle
				if (rectleft >= clipright || rectright <= clipleft)
					continue;	// Completely skip this rectangle
				if (rectlistinfop != nil) {	// Doing the rectangle list
					if (rectcount < maxrectcount) {	// Don't overflow the rectangle list
						// Clip the horizontal coordinates to the clipping rectangle
						if (rectleft < clipleft)	// Partial or full clipping
							rectleft = clipleft;
						if (rectright > clipright)
							rectright = clipright;
						if (flags & USE_GLRECT_FMT) {
							((__GLregionRectPtr)rectp)[rectcount].x0 = rectleft;
							((__GLregionRectPtr)rectp)[rectcount].y0 = recttop;
							((__GLregionRectPtr)rectp)[rectcount].x1 = rectright;
							((__GLregionRectPtr)rectp)[rectcount].y1 = rectbottom;
						} else {
							((Rect *)rectp)[rectcount].top = recttop;
							((Rect *)rectp)[rectcount].left = rectleft;
							((Rect *)rectp)[rectcount].bottom = rectbottom;
							((Rect *)rectp)[rectcount].right = rectright;
						}
						rectlistinfop->rectCount = rectcount + 1;
					}
				} else {	// Doing the rectangle callback
					// Clip the horizontal coordinates to the clipping rectangle
					if (rectleft < clipleft)	// Partial or full clipping
						rectleft = clipleft;
					if (rectright > clipright)
						rectright = clipright;
					if (flags & USE_GLRECT_FMT) {
						newrect_gl.x0 = rectleft;
						newrect_gl.y0 = recttop;
						newrect_gl.x1 = rectright;
						newrect_gl.y1 = rectbottom;
						rectp = (void *)&newrect_gl;
					} else {	// QuickDraw rect format
						newrect.top = recttop;
						newrect.left = rectleft;
						newrect.bottom = rectbottom;
						newrect.right = rectright;
						rectp = (void *)&newrect;
					}
					(*callbackProcPtr)(rectp, dataPtr);	// Do the callback for newrect
				}
				rectcount++;	// Update the count even if we didn't store the rectangle
			}
		}

		// Update with the new coordinate information

		searchstart = 0;
		coordcntparity = 0;
		for (horizcoord = *rgndatap++; horizcoord != ENDMARKER || coordcntparity != 0; horizcoord = *rgndatap++) {
			coordcntparity ^= 1;
			// See whether the new point needs to be inserted into the coordinate
			//	array, or if it 'cancels' a point already in there.  Since the region's
			//	horizontal coordinates are sorted in increasing order, we know that the
			//	next coordinate to add to or delete from our array won't be any earlier
			//	than we've already searched.  So we save the array index where we did the
			//	last insert or delete, so we don't have to unnecessarily compare the
			//	array's previous entries.  ('searchstart' is used for this.)
			for (i = searchstart; i < xcoordcount; i++) {
				coord = gXcoord[i];
				if (horizcoord > coord)	// New point comes after this one
					continue;	// Keep looking for where to put it
				if (horizcoord < coord) {	// Insert the new point here
					if (xcoordcount == MAXCOORDS)	// Array is already full
						break;	// Prevent overflow
					// Shuffle each point up one slot in the array
					for (j = xcoordcount; j > i; j--)
						gXcoord[j] = gXcoord[j-1];
					goto newpoint;
				} else {	// horizcoord == coord, 'cancel' out this point
					// Shuffle each point down one slot in the array
					for (j = i+1; j < xcoordcount; j++)
						gXcoord[j-1] = gXcoord[j];
					xcoordcount--;
					goto savesearchstart;
				}
			}
			// If we reached here, we add the point at the end of the array
newpoint:
			gXcoord[i] = horizcoord;	// Put the new coordinate here
			xcoordcount++;
savesearchstart:
			searchstart = i;	// Optimize the start of our next search
		}

		rectopenv = rectclosev;	// New rect shares a border with the old one

	} while(1);	// Repeat until we 'break' from the loop

	return(rectcount);
}

#if 0	// Was #if DEBUG_BUILD
static void DUMPRGN(RgnHandle rgnh, int rgnnum)
{
	int newline, i, coordcntparity;
	UInt32 size, offset;
	RgnPtr rgnp;
	Ptr p;

	rgnp = *rgnh;
	size = rgnp->rgnSize;
	LOGPRINTF(("Region %d @ 0x%X: size = %d bytes\n", rgnnum, rgnp, size));
	LOGPRINTF(("Bounding rect (TLBR): %d, %d, %d, %d",
			rgnp->rgnBBox.top, rgnp->rgnBBox.left,
			rgnp->rgnBBox.bottom, rgnp->rgnBBox.right));
	p = (Ptr)rgnp;
	newline = true;
	for (offset = sizeof(Region); offset < size; offset += sizeof(SInt16)) {
		i = *(SInt16 *)(p + offset);
		if (newline) {
			LOGPRINTF(("\n%5d:\t", i));
			newline = false;
			coordcntparity = 0;
		} else {
			LOGPRINTF((" %6d", i));
			if (i == ENDMARKER && coordcntparity == 0)
				newline = true;
			coordcntparity ^= 1;
		}
	}
	LOGPRINTF(("\n"));
}
#else
#define DUMPRGN(rgnh, rgnnum)
#endif

static int parseNrgns(Rect *mincliprectp, int rgncount, RgnHandle *rhap, RectListInfoPtr rectlistinfop,
						RectCallbackProcPtr callbackProcPtr, void *dataPtr, int flags)
{
#define MAXRGNS	3
	int rgniter, i, j, searchstart;
	int rectcount, maxrectcount, intersectstartv, newv;
	int recttop, rectbottom, rectleft, rectright;
	int cliptop, clipleft, clipbottom, clipright;
	int horizcoord, coord;
	int xcoordcount, coordcntparity;
	UInt32 morergndatamask, mask, allrgnmask, rgnID;
	void *rectp;
	RgnPtr rgnp;
	SInt16 *rgndata1p, *rgndata2p;
	SInt16 *rgnlinestartp[MAXRGNS], *rgncoordp[MAXRGNS], *rgnendp[MAXRGNS];
	SInt16 *linestartp, *coordp, *endp;
	Rect newrect;
	__GLregionRect newrect_gl;	// OpenGL version of newrect

#if DEBUG_BUILD
	if (rgncount > MAXRGNS) {
		DBUGPRINTF(("parseNrgns: region count %d exceeds max %d\n", rgncount, MAXRGNS));
		return(0);
	}
#endif

	for (rgniter = 0; rgniter < rgncount; rgniter++) {
		rgnp = *rhap[rgniter];
		rgndata1p = (SInt16 *)((Ptr)rgnp + sizeof(Region));	// Skip over the region header
		rgndata2p = (SInt16 *)((Ptr)rgnp + rgnp->rgnSize - sizeof(SInt16));
		if (flags & BOTTOM_TO_TOP) {	// Scan the region lines bottom-to-top
			rgnlinestartp[rgniter] = rgndata2p;	// Points to the last 0x7FFF marker
			rgncoordp[rgniter] = rgndata2p;		// Also points to the last 0x7FFF marker
			rgnendp[rgniter] = rgndata1p;	// Top line is the last in bottom-to-top order
		} else {	// Top to bottom
			rgnlinestartp[rgniter] = rgndata1p;	// Top line is the first
			rgncoordp[rgniter] = rgndata1p;		// Also points to the first line
			rgnendp[rgniter] = rgndata2p;	// Bottom line is the last
		}
		LOGPRINTF(("parseNrgns(%d): rgn %d at 0x%08X, size = %d bytes\n", rgncount, rgniter, rgnp, rgnp->rgnSize));
//		DUMPRGN(rhap[rgniter], rgniter);
	}

	xcoordcount = 0;
	intersectstartv = UNINITIALIZEDV;	// Means we don't have a region intersection started yet
	cliptop = mincliprectp->top;
	clipleft = mincliprectp->left;
	clipbottom = mincliprectp->bottom;
	clipright = mincliprectp->right;
	allrgnmask = (1 << rgncount) - 1;	// Mask with 'rgncount' bits set

	rectcount = 0;
	if (rectlistinfop != nil) {	// We're building a rectangle list
		maxrectcount = rectlistinfop->maxRectCount;
		rectp = rectlistinfop->rectListPtr;
	}

	goto dowehavergndata;	// Kick off the loop (test the enormous loop condition)

	do {

		if (intersectstartv == UNINITIALIZEDV)	// Don't output rectangles if we haven't intersected yet
			goto mergergndata;

		if (flags & BOTTOM_TO_TOP) {
			recttop = newv;
			rectbottom = intersectstartv;
		} else {	// Top to bottom
			recttop = intersectstartv;
			rectbottom = newv;
		}
		// Clip top and bottom to our clipping vertical bounds
		if (recttop < cliptop)
			recttop = cliptop;
		if (rectbottom > clipbottom)
			rectbottom = clipbottom;
		if (recttop >= rectbottom)	// Don't output rectangles clipped to zero height
			goto mergergndata;

		rgnID = 0;	// Initialize for 'no regions active'

		/* The region ID operations are the key to making sure we only output
			rectangles that are in the intersection of ALL the regions.  We keep
			XORing in each coordinate's saved regionID(s), until the accumulated
			ID mask has all the bits set, indicating this coordinate was included
			in all the regions.  This is one of the rectangle sides, and the other
			is the very next coordinate in scanning order (L-R or R-L). */

		if (flags & RIGHT_TO_LEFT) {	// Do the reverse (right-to-left) horizontal rectangle order
			for (i = xcoordcount-1; i > 0; i--) {
				rgnID ^= gRgnID[i];
				if (rgnID != allrgnmask)
					continue;
				rectleft = gXcoord[i-1];
				rectright = gXcoord[i];
				// Eliminate any rectangles horizontally outside the clipping rectangle
				if (rectleft >= clipright || rectright <= clipleft)
					continue;	// Completely skip this rectangle
				if (rectlistinfop != nil) {	// Doing the rectangle list
					if (rectcount < maxrectcount) {	// Don't overflow the rectangle list
						// Clip the horizontal coordinates to the clipping rectangle
						if (rectleft < clipleft)	// Partial or full clipping
							rectleft = clipleft;
						if (rectright > clipright)
							rectright = clipright;
						LOGPRINTF(("\t\tGot a rect (TLBR): %3d, %3d, %3d, %3d\n", recttop, rectleft, rectbottom, rectright));
						if (flags & USE_GLRECT_FMT) {
							((__GLregionRectPtr)rectp)[rectcount].x0 = rectleft;
							((__GLregionRectPtr)rectp)[rectcount].y0 = recttop;
							((__GLregionRectPtr)rectp)[rectcount].x1 = rectright;
							((__GLregionRectPtr)rectp)[rectcount].y1 = rectbottom;
						} else {
							((Rect *)rectp)[rectcount].top = recttop;
							((Rect *)rectp)[rectcount].left = rectleft;
							((Rect *)rectp)[rectcount].bottom = rectbottom;
							((Rect *)rectp)[rectcount].right = rectright;
						}
						rectlistinfop->rectCount = rectcount + 1;
					}
				} else {	// Doing the rectangle callback
					// Clip the horizontal coordinates to the clipping rectangle
					if (rectleft < clipleft)	// Partial or full clipping
						rectleft = clipleft;
					if (rectright > clipright)
						rectright = clipright;
					if (flags & USE_GLRECT_FMT) {
						newrect_gl.x0 = rectleft;
						newrect_gl.y0 = recttop;
						newrect_gl.x1 = rectright;
						newrect_gl.y1 = rectbottom;
						rectp = (void *)&newrect_gl;
					} else {	// QuickDraw rect format
						newrect.top = recttop;
						newrect.left = rectleft;
						newrect.bottom = rectbottom;
						newrect.right = rectright;
						rectp = (void *)&newrect;
					}
					LOGPRINTF(("\t\tGot a rect (TLBR): %3d, %3d, %3d, %3d\n", recttop, rectleft, rectbottom, rectright));
					(*callbackProcPtr)(rectp, dataPtr);	// Do the callback for newrect
				}
				rectcount++;	// Update the count even if we didn't store the rectangle
			}
		} else {	// Do the normal (left-to-right) horizontal rectangle order
			for (i = 0; i < xcoordcount-1; i++) {
				rgnID ^= gRgnID[i];
				if (rgnID != allrgnmask)
					continue;
				rectleft = gXcoord[i];
				rectright = gXcoord[i+1];
				// Eliminate any rectangles horizontally outside the clipping rectangle
				if (rectleft >= clipright || rectright <= clipleft)
					continue;	// Completely skip this rectangle
				if (rectlistinfop != nil) {	// Doing the rectangle list
					if (rectcount < maxrectcount) {	// Don't overflow the rectangle list
						// Clip the horizontal coordinates to the clipping rectangle
						if (rectleft < clipleft)	// Partial or full clipping
							rectleft = clipleft;
						if (rectright > clipright)
							rectright = clipright;
						LOGPRINTF(("\t\tGot a rect (TLBR): %3d, %3d, %3d, %3d\n", recttop, rectleft, rectbottom, rectright));
						if (flags & USE_GLRECT_FMT) {
							((__GLregionRectPtr)rectp)[rectcount].x0 = rectleft;
							((__GLregionRectPtr)rectp)[rectcount].y0 = recttop;
							((__GLregionRectPtr)rectp)[rectcount].x1 = rectright;
							((__GLregionRectPtr)rectp)[rectcount].y1 = rectbottom;
						} else {
							((Rect *)rectp)[rectcount].top = recttop;
							((Rect *)rectp)[rectcount].left = rectleft;
							((Rect *)rectp)[rectcount].bottom = rectbottom;
							((Rect *)rectp)[rectcount].right = rectright;
						}
						rectlistinfop->rectCount = rectcount + 1;
					}
				} else {	// Doing the rectangle callback
					// Clip the horizontal coordinates to the clipping rectangle
					if (rectleft < clipleft)	// Partial or full clipping
						rectleft = clipleft;
					if (rectright > clipright)
						rectright = clipright;
					LOGPRINTF(("\t\tGot a rect (TLBR): %3d, %3d, %3d, %3d\n", recttop, rectleft, rectbottom, rectright));
					if (flags & USE_GLRECT_FMT) {
						newrect_gl.x0 = rectleft;
						newrect_gl.y0 = recttop;
						newrect_gl.x1 = rectright;
						newrect_gl.y1 = rectbottom;
						rectp = (void *)&newrect_gl;
					} else {	// QuickDraw rect format
						newrect.top = recttop;
						newrect.left = rectleft;
						newrect.bottom = rectbottom;
						newrect.right = rectright;
						rectp = (void *)&newrect;
					}
					(*callbackProcPtr)(rectp, dataPtr);	// Do the callback for newrect
				}
				rectcount++;	// Update the count even if we didn't store the rectangle
			}
		}

mergergndata:
		// Merge in one or more regions to the current span definition
		for (rgniter = 0, mask = 1; rgniter < rgncount; rgniter++, mask <<= 1) {
			if ((morergndatamask & mask) == 0)
				continue;	// Skip exhausted regions
			coordp = rgncoordp[rgniter];
			if (*coordp != newv)	// It's not this region's turn yet
				continue;
			coordp++;		// Skip the v coordinate, now point to the h coordinates
			searchstart = 0;
			horizcoord = *coordp;
			coordcntparity = 0;
			while (horizcoord != ENDMARKER || coordcntparity != 0) {
				coordp++;
				coordcntparity ^= 1;
				// See whether the new point needs to be inserted into the coordinate
				//	array, or if it 'cancels' a point already in there.  Since the region's
				//	horizontal coordinates are sorted in increasing order, we know that the
				//	next coordinate to add to or delete from our array won't be any earlier
				//	than we've already searched.  So we save the array index where we did the
				//	last insert or delete, so we don't have to unnecessarily compare the
				//	array's previous entries.  ('searchstart' is used for this.)
				for (i = searchstart; i < xcoordcount; i++) {
					coord = gXcoord[i];
					if (horizcoord > coord)	// New point comes after this one
						continue;	// Keep looking for where to put it
					if (horizcoord < coord) {	// Insert the new point here
						if (xcoordcount == MAXCOORDS)	// Array is already full
							break;	// Prevent overflow
						// Shuffle each point up one array slot
						for (j = xcoordcount; j > i; j--) {
							gXcoord[j] = gXcoord[j-1];
							gRgnID[j] = gRgnID[j-1];
						}
						goto newpoint;
					} else {	// horizcoord == coord, XOR the region IDs to see if they cancel
						rgnID = gRgnID[i] ^ mask;
						if (rgnID != 0) {	// Save back the update region ID mask
							gRgnID[i] = rgnID;
						} else {	// This region was the last to reference this point, so remove it
							// Shuffle each point down one array slot
							for (j = i+1; j < xcoordcount; j++) {
								gXcoord[j-1] = gXcoord[j];
								gRgnID[j-1] = gRgnID[j];
							}
							xcoordcount--;
						}
						goto savesearchstart;
					}
				}
				// If we reached here, we add the point at the end of the array
newpoint:
				gXcoord[i] = horizcoord;	// Put the new coordinate here
				gRgnID[i] = mask;			// Store the region ID as a bit mask
				xcoordcount++;
savesearchstart:
				searchstart = i;	// Optimize the start of our next search
				horizcoord = *coordp;
			}
			// Save away the current region pointer (points to ENDMARKER)
			rgncoordp[rgniter] = coordp;
#if DEBUG_BUILD
			LOGPRINTF(("parseNrgns(%d) after rgn %d --", rgncount, rgniter));
			linestartp = rgnlinestartp[rgniter];
			LOGPRINTF((" %4d:", *linestartp));
			coordcntparity = 0;
			for (linestartp++; *linestartp != ENDMARKER || coordcntparity != 0; linestartp++) {
				LOGPRINTF((" %4d", *linestartp));
				coordcntparity ^= 1;
			}
			LOGPRINTF(("\n"));
			LOGPRINTF(("\tgXcoord =\t"));
			for (i = 0; i < xcoordcount; i++)
				LOGPRINTF((" %4d", gXcoord[i]));
			LOGPRINTF(("\n"));
			LOGPRINTF(("\t gRgnID =\t"));
			for (i = 0; i < xcoordcount; i++)
				LOGPRINTF((" %4d", gRgnID[i]));
			LOGPRINTF(("\n"));
#endif
		}
		intersectstartv = UNINITIALIZEDV;	// We need to look for the start of an intersection again
		rgnID = 0;
		for (i = 0; i < xcoordcount-1; i++) {
			rgnID ^= gRgnID[i];
			if (rgnID != allrgnmask)
				continue;
			// We have a region intersection in this line of data
			intersectstartv = newv;	// Save this vertical coordinate for later rectangle output
			goto dowehavergndata;	// Don't need to check the rest of the line data
		}

dowehavergndata:
		// Update region pointers as needed, and find the next vertical coordinate to process
		morergndatamask = 0;
		if (flags & BOTTOM_TO_TOP) {
			newv = -32767;
			for (rgniter = 0, mask = 1; rgniter < rgncount; rgniter++, mask <<= 1) {
				linestartp = rgnlinestartp[rgniter];
				endp = rgnendp[rgniter];
				if (linestartp == endp)	// No more data in this region
					continue;
				coordp = rgncoordp[rgniter];
				coord = *coordp;
				if (coord == ENDMARKER) {	// Means we need to find the next line beginning
					linestartp--;	// Back up to previous marker
					do {
						// We always back up by two shorts at a time.  The region change points always come
						//	in pairs, and the line vertical coordinate is always preceded by 0x7FFF (pairs
						//	again), except for the very first line in a region, which we also check for.
						//	('endp' points to the highest line in the region, since we're going btm-to-top.)
						linestartp -= 2;
					} while (*linestartp != ENDMARKER && linestartp > endp);
					linestartp++;	// This now points to the beginning of the current line's data (Y coord)
					rgnlinestartp[rgniter] = linestartp;	// Save away the new line start
					rgncoordp[rgniter] = linestartp;	// Update the copy in memory
					coord = *linestartp;	// Get new vertical coordinate
				}
				if (coord > newv)	// Identify the next highest v coordinate (min rectangle height)
					newv = coord;
				morergndatamask |= mask;	// Mark that this region still has data left
			}
		} else {	// Top to bottom
			newv = 32767;
			for (rgniter = 0, mask = 1; rgniter < rgncount; rgniter++, mask <<= 1) {
				linestartp = rgnlinestartp[rgniter];
				endp = rgnendp[rgniter];
				if (linestartp == endp)	// No more data in this region
					continue;
				coordp = rgncoordp[rgniter];
				coord = *coordp;
				if (coord == ENDMARKER) {	// Means we need to go to the next line
					linestartp = coordp + 1;	// Next line starts after the marker
					rgnlinestartp[rgniter] = linestartp;	// Save away the new line start
					rgncoordp[rgniter] = linestartp;	// Update the copy in memory
					if (linestartp == endp)	// No more data in this region
						continue;
					coord = *linestartp;	// Get new vertical coordinate
				}
				if (coord < newv)	// Identify the next lowest v coordinate (min rectangle height)
					newv = coord;
				morergndatamask |= mask;	// Mark that this region still has data left
			}
		}

	} while (morergndatamask != 0);

	return(rectcount);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\common\mac\qdregions\regionparse.h ===
/******************************************************************************
 *
 *       Copyright 1993-2000 NVIDIA, Corporation.  All rights reserved.
 *
 *     NOTICE TO USER:   The source code  is copyrighted under  U.S. and
 *     international laws.  Users and possessors of this source code are
 *     hereby granted a nonexclusive,  royalty-free copyright license to
 *     use this code in individual and commercial software.
 *
 *     Any use of this source code must include,  in the user documenta-
 *     tion and  internal comments to the code,  notices to the end user
 *     as follows:
 *
 *       Copyright 1993-2000 NVIDIA, Corporation.  All rights reserved.
 *
 *     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY
 *     OF  THIS SOURCE  CODE  FOR ANY PURPOSE.  IT IS  PROVIDED  "AS IS"
 *     WITHOUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPOR-
 *     ATION DISCLAIMS ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,
 *     INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY, NONINFRINGE-
 *     MENT,  AND FITNESS  FOR A PARTICULAR PURPOSE.   IN NO EVENT SHALL
 *     NVIDIA, CORPORATION  BE LIABLE FOR ANY SPECIAL,  INDIRECT,  INCI-
 *     DENTAL, OR CONSEQUENTIAL DAMAGES,  OR ANY DAMAGES  WHATSOEVER RE-
 *     SULTING FROM LOSS OF USE,  DATA OR PROFITS,  WHETHER IN AN ACTION
 *     OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  ARISING OUT OF
 *     OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOURCE CODE.
 *
 *     U.S. Government  End  Users.   This source code  is a "commercial
 *     item,"  as that  term is  defined at  48 C.F.R. 2.101 (OCT 1995),
 *     consisting  of "commercial  computer  software"  and  "commercial
 *     computer  software  documentation,"  as such  terms  are  used in
 *     48 C.F.R. 12.212 (SEPT 1995)  and is provided to the U.S. Govern-
 *     ment only as  a commercial end item.   Consistent with  48 C.F.R.
 *     12.212 and  48 C.F.R. 227.7202-1 through  227.7202-4 (JUNE 1995),
 *     all U.S. Government End Users  acquire the source code  with only
 *     those rights set forth herein.
 *
 ******************************************************************************
 *
 * MODULE:  regionparse.h
 *
 * PURPOSE: Contains definitions for region-parsing code.
 *
 ******************************************************************************/

#ifndef __QUICKDRAW__
#include <QuickDraw.h>
#endif

//=====================================================================================================
//
// Definitions
//
//=====================================================================================================

// Flag values for the region parser (parse_rgns and parse_rgns_callback)
#define RIGHT_TO_LEFT	1	// Emit rectangles in right-to-left order (default is left-to-right)
#define BOTTOM_TO_TOP	2	// Emit rectangles in bottom-to-top order (default is top-to-bottom)
#define USE_GLRECT_FMT	4	// Return rectangles in GLRect format (default is QuickDraw rects)

typedef struct {			// Rectangle list information
	int		maxRectCount;		// Maximum allocated rectangles in the list
	int		rectCount;			// How many rectangles were parsed
	void	*rectListPtr;		// Points to QuickDraw or OpenGL rectangles
} RectListInfo, *RectListInfoPtr;

typedef void (*RectCallbackProcPtr)(const void *rectPtr, void *dataPtr);	// dataPtr was passed into parse_rgns_callback

//=====================================================================================================
//
// Prototypes
//
//=====================================================================================================

extern int parse_rgns(void *startcliprectp,	// Points to QuickDraw or OpenGL rectangle, or is nil
						RgnHandle rh1, RgnHandle rh2, RgnHandle rh3,	// Set unused handles to nil
						RectListInfoPtr rectlistinfop, int flags);

extern int parse_rgns_callback(void *startcliprectp,	// Points to QuickDraw or OpenGL rectangle, or is nil
						RgnHandle rh1, RgnHandle rh2, RgnHandle rh3,	// Set unused handles to nil
						RectCallbackProcPtr callbackProcPtr, void *dataPtr,	// dataPtr is passed to callback proc
						int flags);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\common\mac\utils\QD app\ReleaseBuild.h ===
/******************************************************************************

 ReleaseBuild.h -- for the Resource-Manager-aware display driver

 *****************************************************************************/

#define DEBUG_BUILD			0
#define PROFILE_BUILD		0
#define STANDALONE_BUILD	0
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\common\mac\utils\QD app\main.c ===
#include <Types.h>
#include <Quickdraw.h>
#include <Devices.h>
#include <Dialogs.h>
#include <Fonts.h>
#include <LowMem.h>
#include <Menus.h>
#include <QDOffscreen.h>
#include <Resources.h>
#include <Scrap.h>
#include <Sound.h>
#include <TextUtils.h>
#include <ToolUtils.h>
#include <Windows.h>

#include "debug.h"

#if DEBUG_BUILD

#define	kludgeKeyMap(i)		(*((/*volatile*/ unsigned long*) (0x174+(i*4))))
#define	OptionIsDown		((kludgeKeyMap(1)&0x0004)!=0)
#define	ShiftIsDown			((kludgeKeyMap(1)&0x0001)!=0)
#define	CapsLockIsDown		((kludgeKeyMap(1)&0x0002)!=0)
#define	ControlIsDown		((kludgeKeyMap(1)&0x0008)!=0)
#define	CmdIsDown			((kludgeKeyMap(1)&0x8000)!=0)

#endif

/* Miscellaneous definitions */

#define RECTINSET		48
#define RRECT_CURVATURE	50
#define ARC_STARTANGLE	135
#define ARC_DEGREES		90

#define DESTWIND_ID			128
#define SOURCEWIND_ID		129
#define STATUSWIND_ID		130
#define DESTWINDREFCON		DESTWIND_ID
#define SRCWINDREFCON		SOURCEWIND_ID
#define STATUSWINDREFCON	STATUSWIND_ID
#define ERRORALERT_ID		128
#define ABOUTDLOG_ID		129
#define BOUNDRECTDLOG_ID	130
#define OTHERRECTDLOG_ID	131
enum {
	OK_BRDITM=1,
	DEFLTBTN_BRDITM,
	TITLE_BRDITM,
	HORIZ_BRDITM,
	HTITLE_BRDITM,
	VERT_BRDITM,
	VTITLE_BRDITM
};

/* Error values, closely tied to application error string indices */
#define NONQDMISC_ERR			1

#define ERRORSTR_ID			128		// Error strings
#define NONQDMISC_NDX			NONQDMISC_ERR
#define CANTGETWIND_NDX			2
#define CANTGETMENU_NDX			3
#define CANTGETDLOG_NDX			4
#define CANTGETPICT_NDX			5
#define CANTGETCTABLE_NDX		6
#define CANTGETGWORLD_NDX		7
#define CANTGETREGION_NDX		8
#define CANTGETPIXPAT_NDX		9
#define CANTGETNVBOARD_NDX		10
#define NEEDMILLIONS_NDX		11
#define DESTNOTONNV_NDX			12

#define PARAMSTR_ID			130		// Parameterized strings
#define DESTLOC_NDX				1
#define SOURCELOC_NDX			2
#define WINDTITLE_NDX			3
#define UNNAMEDPICT_NDX			4
#define UNNAMEDPIXPAT_NDX		5
#define TIMING_NDX				6
#define ADDR_NDX				7

#define PICT_BASEID			128		// Base resource IDs for PICTs

/* Definitions for the main application menus */

#define APPLEMENU_ID		128
enum {
	ABOUT_ITEM = 1
};
static MenuHandle gAppleMenu;

#define FILEMENU_ID			129
enum {
	QUIT_ITEM = 1
};
static MenuHandle gFileMenu;

#define EDITMENU_ID			130
enum {
	UNDO_ITEM = 1,
	EDITSEP1_ITEM,
	CUT_ITEM,
	COPY_ITEM,
	PASTE_ITEM,
	CLEAR_ITEM
};
static MenuHandle gEditMenu;

#define TESTMENU_ID			131
enum {
	RUN_ITEM = 1,
	NOREFRESH_ITEM,
	NOCURSORHIDE_ITEM,
	TESTSEP1_ITEM,
	COPYBITS_ITEM,
	LINES_ITEM,
	TEXT_ITEM,
	FRAMESHAPE_ITEM,
	PAINTSHAPE_ITEM,
	ERASESHAPE_ITEM,
	INVERTSHAPE_ITEM,
	PATFILLSHAPE_ITEM,
	TESTSEP2_ITEM,
	RECTANGLE_ITEM,
	REGION_ITEM,
	OVAL_ITEM,
	ROUNDRECT_ITEM,
	ARC_ITEM,
	POLYGON_ITEM,
	TESTSEP3_ITEM,
	BOUNDRECT_ITEM,
	RGNSHAPE_ITEM
};
static MenuHandle gTestMenu;
static UInt8 gNoRefresh = false;
static UInt8 gNoCursorHide = false;
static UInt8 gTest = PAINTSHAPE_ITEM;
static UInt8 gShape = RECTANGLE_ITEM;

#define DESTMENU_ID			132
enum {
	DESTLOCATION_ITEM = 1,
	DESTDIM_ITEM,
	DESTIMAGE_ITEM,
	DESTDITHER_ITEM,
	DESTSEP1_ITEM,
	FGCOLOR_ITEM,
	BGCOLOR_ITEM,
	SWAPFGBG_ITEM,
	RESETCOLORS_ITEM,
	DESTSEP2_ITEM,
	PENSIZE_ITEM,
	PENMODE_ITEM,
	PENPATTERN_ITEM,
	BGPATTERN_ITEM,
	FILLPATTERN_ITEM,
	DESTSEP3_ITEM,
	USECLIPRGN_ITEM,
	CLIPRGN_ITEM
};
static MenuHandle gDestMenu;
static UInt8 gDitherDest = false;
static UInt8 gSwapFgBg = false;
static UInt8 gUseClipRgn = false;

#define COPYBITSMENU_ID		133
enum {
	USESEPSRC_ITEM = 1,
	SRCLOCATION_ITEM,
	SRCDIM_ITEM,
	SRCIMAGE_ITEM,
	SRCDITHER_ITEM,
	COPYBITSSEP1_ITEM,
	TRANSFERMODE_ITEM,
	SOURCERECT_ITEM,
	DESTRECT_ITEM,
	USEMASKRGN_ITEM,
	MASKRGN_ITEM
};
static MenuHandle gCopyBitsMenu;
static UInt8 gSepSrc = false;
static UInt8 gDitherSrc = false;
static UInt8 gUseMaskRgn = false;

#define LINESMENU_ID		134
enum {
	HORIZONTAL_ITEM = 1,
	VERTICAL_ITEM,
	DIAGONAL_ITEM,
	SLANTED_ITEM
};
static MenuHandle gLinesMenu;
static UInt8 gLines = HORIZONTAL_ITEM;

#define TEXTMENU_ID			135
enum {
	TEXTMODE_ITEM = 1,
	STRING_ITEM,
	TEXTSEP1_ITEM,
	FONT_ITEM,
	SIZE_ITEM
};
static MenuHandle gTextMenu;

#define EXPMENU_ID			136
enum {
	LUTDITHER_ITEM = 1,
	SPATIALDITHER_ITEM
};
static MenuHandle gExpMenu;

#define RGNSHAPEMENU_ID		140
// RgnShape, ClipRgn, and MaskRgn menus use identical items
enum {
	TRIOVALRGN_ITEM = 1,
	RRECTRGN_ITEM,
	RECTHOLERGN_ITEM,
	MEDRECTRGN_ITEM,
	SMALLRECTRGN_ITEM,
	EMPTYRGN_ITEM,
	NUM_REGIONS
};
static MenuHandle gRgnShapeMenu;
static UInt8 gRgnShape = TRIOVALRGN_ITEM;

#define CLIPRGNMENU_ID		141
// RgnShape, ClipRgn, and MaskRgn menus use identical items
static MenuHandle gClipRgnMenu;
static UInt8 gClipRgn = RRECTRGN_ITEM;

#define MASKRGNMENU_ID		142
// RgnShape, ClipRgn, and MaskRgn menus use identical items
static MenuHandle gMaskRgnMenu;
static UInt8 gMaskRgn = RECTHOLERGN_ITEM;

/* Definitions for the hierarchical menus */

#define DESTLOCMENU_ID		150
// DestLoc and SrcLoc menus use identical items
enum {
	WINDOW_ITEM = 1,
	OFFSCRN1BW_ITEM,
	OFFSCRN8G_ITEM,
	OFFSCRN8C_ITEM,
	OFFSCRN16C_ITEM,
	OFFSCRN24C_ITEM
};
static MenuHandle gDestLocMenu;
static UInt8 gDestLoc = WINDOW_ITEM;

#define DESTDIMMENU_ID		151
// DestDim and SrcDim menus use identical items
enum {
	DIM_512X384_ITEM = 1,
	DIM_600X450_ITEM,
	DIM_640X480_ITEM,
	DIM_1024X768_ITEM
};
static MenuHandle gDestDimMenu;
static UInt8 gDestDim = DIM_600X450_ITEM;

#define DESTIMAGEMENU_ID	152
// DestImage and SrcImage menus use identical items (from PICT resources)
static MenuHandle gDestImageMenu;
static UInt16 gDestImage = 1;	// First picture is default

#define FGCOLORMENU_ID		153
// FgColor and BgColor menus use identical items
enum {
	BLACK_ITEM = 1,
	WHITE_ITEM,
	RED_ITEM,
	GREEN_ITEM,
	BLUE_ITEM,
	CYAN_ITEM,
	MAGENTA_ITEM,
	YELLOW_ITEM,
	GRAY53_ITEM,
	HILITE_ITEM,
	RANDOM_ITEM,
	OTHERCOLOR_ITEM
};
static MenuHandle gFgColorMenu;
static UInt8 gFgColor = BLACK_ITEM;
static RGBColor gFgOtherRGB = { 0, 0, 0 };
static RGBColor gFgSaveRGB = { 0, 0, 0 };

#define BGCOLORMENU_ID		154
// FgColor and BgColor menus use identical items
static MenuHandle gBgColorMenu;
static UInt8 gBgColor = WHITE_ITEM;
static RGBColor gBgOtherRGB = { 0xFFFF, 0xFFFF, 0xFFFF };
static RGBColor gBgSaveRGB = { 0xFFFF, 0xFFFF, 0xFFFF };

#define PENSIZEMENU_ID		155
enum {
	PS_1X1_ITEM = 1,
	PS_2X2_ITEM,
	PS_4X4_ITEM,
	PS_8X8_ITEM,
	PS_16X16_ITEM,
	PS_OTHER_ITEM
};
static MenuHandle gPenSizeMenu;
static UInt8 gPenSize = PS_1X1_ITEM;

#define PENMODEMENU_ID		156
enum {
	PATCOPY_ITEM = 1,
	PATOR_ITEM,
	PATXOR_ITEM,
	PATBIC_ITEM,
	NOTPATCOPY_ITEM,
	NOTPATOR_ITEM,
	NOTPATXOR_ITEM,
	NOTPATBIC_ITEM,
	PATCOPYPLUSTRANSP_ITEM,
	PENMODESEP1_ITEM,
	PM_PLUSHILITE_ITEM
};
static MenuHandle gPenModeMenu;
static UInt8 gPenMode = PATCOPY_ITEM;
static UInt8 gPMPlusHilite = false;

#define PENPATMENU_ID		157
// PenPat, BgPat, and FillPat menus use identical items
enum {
	BLACKPAT_ITEM = 1,
	WHITEPAT_ITEM,
	GRAY50PAT_ITEM,
	LTGRAYPAT_ITEM,
	DKGRAYPAT_ITEM,
	HSTRIPESPAT_ITEM,
	VSTRIPESPAT_ITEM,
	DSTRIPESPAT_ITEM,
	NUMNIBBLESPAT_ITEM,
	PATSEP1_ITEM,
	FIRSTPIXPAT_ITEM
};
static MenuHandle gPenPatMenu;
static UInt8 gPenPat = BLACKPAT_ITEM;
static UInt8 gPixPat = FIRSTPIXPAT_ITEM;

#define BGPATMENU_ID		158
// PenPat, BgPat, and FillPat menus use identical items
static MenuHandle gBgPatMenu;
static UInt8 gBgPat = WHITEPAT_ITEM;

#define FILLPATMENU_ID		159
// PenPat, BgPat, and FillPat menus use identical items
static MenuHandle gFillPatMenu;
static UInt8 gFillPat = GRAY50PAT_ITEM;

#define SRCLOCMENU_ID		170
// DestLoc and SrcLoc menus use identical items
static MenuHandle gSrcLocMenu;
static UInt8 gSrcLoc = WINDOW_ITEM;

#define SRCDIMMENU_ID		171
// DestDim and SrcDim menus use identical items
static MenuHandle gSrcDimMenu;
static UInt8 gSrcDim = DIM_600X450_ITEM;

#define SRCIMAGEMENU_ID		172
// DestImage and SrcImage menus use identical items (from PICT resources)
static MenuHandle gSrcImageMenu;
static UInt16 gSrcImage = 2;	// First picture is default

#define XFERMODEMENU_ID		173
enum {
	X_SRCCOPY_ITEM = 1,
	X_SRCOR_ITEM,
	X_SRCXOR_ITEM,
	X_SRCBIC_ITEM,
	X_NOTSRCCOPY_ITEM,
	X_NOTSRCOR_ITEM,
	X_NOTSRCXOR_ITEM,
	X_NOTSRCBIC_ITEM,
	X_ADDOVER_ITEM,
	X_ADDPIN_ITEM,
	X_SUBOVER_ITEM,
	X_SUBPIN_ITEM,
	X_ADMAX_ITEM,
	X_ADMIN_ITEM,
	X_BLEND_ITEM,
	X_TRANSPARENT_ITEM,
	X_HILITE_ITEM,
	XFERMODESEP1_ITEM,
	X_PLUSDITHER_ITEM
};
static MenuHandle gXferModeMenu;
static UInt8 gXferMode = X_SRCCOPY_ITEM;
static UInt8 gXPlusDither = false;

#define SRCRECTMENU_ID		174
// SrcRect and DestRect menus use identical items
enum {
	TOP50_ITEM = 1,
	BOTTOM50_ITEM,
	LEFT50_ITEM,
	RIGHT50_ITEM,
	TOP99_ITEM,
	BOTTOM99_ITEM,
	LEFT99_ITEM,
	RIGHT99_ITEM,
	FULLSIZE_ITEM,
	OTHERRECT_ITEM
};
static MenuHandle gSrcRectMenu;
static UInt8 gSrcRect = TOP50_ITEM;
static Rect gSrcOtherRect = { 100, 100, 300, 300 };	// Should be safe

#define DESTRECTMENU_ID		175
static MenuHandle gDestRectMenu;
static UInt8 gDestRect = BOTTOM50_ITEM;
static Rect gDestOtherRect = { 100, 100, 300, 300 };	// Should be safe

#define TEXTMODEMENU_ID		190
enum {
	T_SRCCOPY_ITEM = 1,
	T_SRCOR_ITEM,
	T_SRCXOR_ITEM,
	T_SRCBIC_ITEM,
	T_NOTSRCCOPY_ITEM,
	T_NOTSRCOR_ITEM,
	T_NOTSRCXOR_ITEM,
	T_NOTSRCBIC_ITEM,
	T_ADDOVER_ITEM,
	T_ADDPIN_ITEM,
	T_SUBOVER_ITEM,
	T_SUBPIN_ITEM,
	T_ADMAX_ITEM,
	T_ADMIN_ITEM,
	T_BLEND_ITEM,
	T_TRANSPARENT_ITEM,
	T_GRAYISHTEXTOR_ITEM,
	TEXTMODESEP1_ITEM,
	T_PLUSHILITE_ITEM,
	T_PLUSMASK_ITEM
};
static MenuHandle gTextModeMenu;
static UInt8 gTextMode = T_SRCOR_ITEM;
static UInt8 gTPlusHilite = false;
static UInt8 gTPlusMask = false;


/* Miscellaneous definitions */

#define MAX_PIXPATS		40		/* Maximum number of PixPats we handle */
#define BEEPTICKS		3		/* Number of ticks for beep duration */
#define TESTTICKS		4*60	/* Number of ticks to run each test */

#define UNIMPTRAP		0xA89F
#define NQDMISCTRAP		0xABC3


/* Other global variables visible in this file only */

static UInt8 gQuitFlag = false;	// Set to true when the user wants to quit
static WindowPtr gDestWind;	// Pointer to destination window 
static GWorldPtr gDestPictBufGW = nil;	// Pointer to dest pict buffer GWorld
static GWorldPtr gDestGW = nil;	// Pointer to dest offscreen GWorld
static WindowPtr gSrcWind;	// Pointer to separate source window
static GWorldPtr gSrcPictBufGW = nil;	// Pointer to source pict buffer GWorld
static GWorldPtr gSrcGW = nil;	// Pointer to source offscreen GWorld
static WindowPtr gStatusWind;	// Pointer to Status window
static CTabHandle gCTab1BW;	// Handle to 1-bit black & white color table
static CTabHandle gCTab8G;	// Handle to 8-bit gray-scale color table
static CTabHandle gCTab8C;	// Handle to standard 8-bit color table
static UInt32 gLastTest = 0;	// Last test number that was run
static UInt32 gTestBeginTicks = 0;	// Tick count at beginning of a test
static UInt32 gTestEndTicks = 0;	// Tick count at end of a test
static UInt32 gTestIterations = 0;	// Number of times a test was performed
static UInt32 gTestDestAddr = 0;	// Address of 0,0 in destination memory
static UInt32 gTestSrcAddr = 0;	// Address of 0,0 in source memory
static UInt32 gBoundRectHInset = RECTINSET;	// Horizontal inset for shape bounding rect
static UInt32 gBoundRectVInset = RECTINSET;	// Vertical inset for shape bounding rect
static RgnHandle gRgnh[NUM_REGIONS];	// Handles to the various regions
static PixPatHandle gPixPath[MAX_PIXPATS];	// Handles to the PixPats

/* Procedures visible in this file only */
static void doeventloop(void);
static void updatedestwind(WindowPtr wind);
static SInt32 initdest(void);
static void cleanupdest(void);
static SInt32 initsource(void);
static void cleanupsrc(void);
static SInt32 initstatus(void);
static void cleanupstatus(void);
static SInt32 initregions(void);
static void setlocdimtitle(WindowPtr wind);
static SInt32 allocgworld(UInt32 item, Rect *rectp, GWorldPtr *gwpp);
static void rectitemtorect(UInt32 rectitem, Rect *inr, Rect *otherr, Rect *outr);
static void copyGWtoGW(GWorldPtr srcgwp, GWorldPtr destgwp, UInt32 dither);
static SInt32 drawpicttogworld(UInt32 pictitem, GWorldPtr gwp);
static void invalwind(WindowPtr wind);
static void dimtowh(UInt32 dimitem, UInt32 *widthp, UInt32 *heightp);
static void runtest(UInt32 test);
static void sint32todstr(SInt32 num, unsigned char *strp);
static void uint32todstr(UInt32 num, unsigned char *strp);
static void uint32tohstr(UInt32 num, unsigned char *strp);
static void paramstr(unsigned char *dest, SInt32 index, unsigned char *sub0, unsigned char *sub1,
						unsigned char *sub2, unsigned char *sub3);

static void erroralert(SInt32 strindex)
{
	unsigned char str[256];

	GetIndString(str, ERRORSTR_ID, strindex);
	ParamText(str, nil, nil, nil);
	NoteAlert(ERRORALERT_ID, nil);
}

static void keepwindowonmain(WindowPtr wind)
{
	SInt32 x, y, yextra;
	GrafPtr oldport;
	Point topleft, btmright;

#define EDGEFACTOR	2	// Leave this many pixels between screen edge & window frame
	GetPort(&oldport);
	SetPort(wind);
	topleft = *(Point *)&wind->portRect.top;
	btmright = *(Point *)&wind->portRect.bottom;
	LocalToGlobal(&topleft);
	LocalToGlobal(&btmright);
	SetPort(oldport);

	yextra = GetMBarHeight() + 20;	/* Menu bar height + title bar */
	x = topleft.h + EDGEFACTOR;
	if (btmright.h > qd.screenBits.bounds.right)
		x = qd.screenBits.bounds.right -
			(btmright.h - topleft.h) - EDGEFACTOR-2;
	if (topleft.h < qd.screenBits.bounds.left + EDGEFACTOR)
		x = qd.screenBits.bounds.left + EDGEFACTOR+1;
	y = topleft.v;
	if (btmright.v > qd.screenBits.bounds.bottom)
		y = qd.screenBits.bounds.bottom -
			(btmright.v - topleft.v) - EDGEFACTOR-2;
	if (topleft.v < qd.screenBits.bounds.top + yextra + EDGEFACTOR)
		y = qd.screenBits.bounds.top + yextra + EDGEFACTOR+1;
	if (x != topleft.h || y != topleft.v)
		MoveWindow(wind, x, y, false);
}

static SInt32 checkconfig(void)
{
	if (NGetTrapAddress(NQDMISCTRAP, ToolTrap) == NGetTrapAddress(UNIMPTRAP, ToolTrap))
		return(NONQDMISC_ERR);
	return(0);
}

static SInt32 setupmenus(void)
{
	SInt16 resID;
	SInt32 i, pictcount, pixpatcount;
	Handle h;
	ResType restype;
	unsigned char str[256], countstr[16];
	/* Set up the main menus */

	if ((gAppleMenu = GetMenu(APPLEMENU_ID)) == nil)
		return(CANTGETMENU_NDX);
	AppendResMenu(gAppleMenu, 'DRVR');	/* Add items to the Apple menu */
	InsertMenu(gAppleMenu, 0);

	if ((gFileMenu = GetMenu(FILEMENU_ID)) == nil)
		return(CANTGETMENU_NDX);
	InsertMenu(gFileMenu, 0);

	if ((gEditMenu = GetMenu(EDITMENU_ID)) == nil)
		return(CANTGETMENU_NDX);
	InsertMenu(gEditMenu, 0);

	if ((gTestMenu = GetMenu(TESTMENU_ID)) == nil)
		return(CANTGETMENU_NDX);
	InsertMenu(gTestMenu, 0);
	CheckItem(gTestMenu, NOREFRESH_ITEM, gNoRefresh);
	CheckItem(gTestMenu, NOCURSORHIDE_ITEM, gNoCursorHide);
	CheckItem(gTestMenu, gTest, true);
	CheckItem(gTestMenu, gShape, true);

	if ((gDestMenu = GetMenu(DESTMENU_ID)) == nil)
		return(CANTGETMENU_NDX);
	InsertMenu(gDestMenu, 0);
	CheckItem(gDestMenu, DESTDITHER_ITEM, gDitherDest);
	CheckItem(gDestMenu, SWAPFGBG_ITEM, gSwapFgBg);
	CheckItem(gDestMenu, USECLIPRGN_ITEM, gUseClipRgn);

	if ((gCopyBitsMenu = GetMenu(COPYBITSMENU_ID)) == nil)
		return(CANTGETMENU_NDX);
	InsertMenu(gCopyBitsMenu, 0);
	CheckItem(gCopyBitsMenu, USESEPSRC_ITEM, gSepSrc);
	CheckItem(gCopyBitsMenu, SRCDITHER_ITEM, gDitherSrc);
	CheckItem(gCopyBitsMenu, USEMASKRGN_ITEM, gUseMaskRgn);
	if (gTest != COPYBITS_ITEM)	// Need to disable entire menu
		DisableItem(gCopyBitsMenu, 0);

	if ((gLinesMenu = GetMenu(LINESMENU_ID)) == nil)
		return(CANTGETMENU_NDX);
	InsertMenu(gLinesMenu, 0);
	CheckItem(gLinesMenu, gLines, true);
	if (gTest != LINES_ITEM)	// Need to disable entire menu
		DisableItem(gLinesMenu, 0);

	if ((gTextMenu = GetMenu(TEXTMENU_ID)) == nil)
		return(CANTGETMENU_NDX);
	InsertMenu(gTextMenu, 0);
	if (gTest != TEXT_ITEM)	// Need to disable entire menu
		DisableItem(gTextMenu, 0);

	if ((gExpMenu = GetMenu(EXPMENU_ID)) == nil)
		return(CANTGETMENU_NDX);
	InsertMenu(gExpMenu, 0);

	/* Set up the hierarchical menus */

	if ((gRgnShapeMenu = GetMenu(RGNSHAPEMENU_ID)) == nil)
		return(CANTGETMENU_NDX);
	InsertMenu(gRgnShapeMenu, -1);
	CheckItem(gRgnShapeMenu, gRgnShape, true);

	if ((gClipRgnMenu = GetMenu(CLIPRGNMENU_ID)) == nil)
		return(CANTGETMENU_NDX);
	InsertMenu(gClipRgnMenu, -1);
	CheckItem(gClipRgnMenu, gClipRgn, true);

	if ((gMaskRgnMenu = GetMenu(MASKRGNMENU_ID)) == nil)
		return(CANTGETMENU_NDX);
	InsertMenu(gMaskRgnMenu, -1);
	CheckItem(gMaskRgnMenu, gMaskRgn, true);

	if ((gDestLocMenu = GetMenu(DESTLOCMENU_ID)) == nil)
		return(CANTGETMENU_NDX);
	InsertMenu(gDestLocMenu, -1);
	CheckItem(gDestLocMenu, gDestLoc, true);

	if ((gDestDimMenu = GetMenu(DESTDIMMENU_ID)) == nil)
		return(CANTGETMENU_NDX);
	InsertMenu(gDestDimMenu, -1);
	CheckItem(gDestDimMenu, gDestDim, true);

	/* The dest and source image selection menus are done together,
		since they both are populated from the resource names of
		the PICT resources. */
	if ((gDestImageMenu = GetMenu(DESTIMAGEMENU_ID)) == nil)
		return(CANTGETMENU_NDX);
	if ((gSrcImageMenu = GetMenu(SRCIMAGEMENU_ID)) == nil)
		return(CANTGETMENU_NDX);
	if ((pictcount = Count1Resources('PICT')) == 0)
		return(CANTGETPICT_NDX);
	for (i = 1; i <= pictcount; i++) {
		SetResLoad(false);
		h = Get1Resource('PICT', PICT_BASEID - 1 + i);
		SetResLoad(true);
		if (h != nil) {
			GetResInfo(h, &resID, &restype, str);
			if (ResError() == noErr) {
				if (str[0] == 0) {
					/* The resource had no name, so we'll create one like
						'Unnamed Picture 1'. */
					sint32todstr(i, countstr);
					paramstr(str, UNNAMEDPICT_NDX, countstr, nil, nil, nil);
				}
				/* Now we append an empty name as the menu item,
					then we do a SetMenuItemText in case the picture name
					contains any metacharacters.  This makes it look clean. */
				AppendMenu(gDestImageMenu, "\p ");
				SetMenuItemText(gDestImageMenu, i, str);
				AppendMenu(gSrcImageMenu, "\p ");
				SetMenuItemText(gSrcImageMenu, i, str);
			}
		}
	}
	InsertMenu(gDestImageMenu, -1);
	if (gDestImage > pictcount)
		gDestImage = pictcount;
	CheckItem(gDestImageMenu, gDestImage, true);
	InsertMenu(gSrcImageMenu, -1);
	if (gSrcImage > pictcount)
		gSrcImage = pictcount;
	CheckItem(gSrcImageMenu, gSrcImage, true);

	if ((gFgColorMenu = GetMenu(FGCOLORMENU_ID)) == nil)
		return(CANTGETMENU_NDX);
	InsertMenu(gFgColorMenu, -1);
	CheckItem(gFgColorMenu, gFgColor, true);

	if ((gBgColorMenu = GetMenu(BGCOLORMENU_ID)) == nil)
		return(CANTGETMENU_NDX);
	InsertMenu(gBgColorMenu, -1);
	CheckItem(gBgColorMenu, gBgColor, true);

	if ((gPenSizeMenu = GetMenu(PENSIZEMENU_ID)) == nil)
		return(CANTGETMENU_NDX);
	InsertMenu(gPenSizeMenu, -1);
	CheckItem(gPenSizeMenu, gPenSize, true);

	if ((gPenModeMenu = GetMenu(PENMODEMENU_ID)) == nil)
		return(CANTGETMENU_NDX);
	InsertMenu(gPenModeMenu, -1);
	CheckItem(gPenModeMenu, gPenMode, true);
	CheckItem(gPenModeMenu, PM_PLUSHILITE_ITEM, gPMPlusHilite);

	// Get all three pattern menus
	if ((gPenPatMenu = GetMenu(PENPATMENU_ID)) == nil)
		return(CANTGETMENU_NDX);
	if ((gBgPatMenu = GetMenu(BGPATMENU_ID)) == nil)
		return(CANTGETMENU_NDX);
	if ((gFillPatMenu = GetMenu(FILLPATMENU_ID)) == nil)
		return(CANTGETMENU_NDX);

	// See how many PixPats we have in our resources
	if ((pixpatcount = Count1Resources('ppat')) == 0)
		return(CANTGETPIXPAT_NDX);
	if (pixpatcount > MAX_PIXPATS)
		pixpatcount = MAX_PIXPATS;

	// Add the PixPats to the end of all three pattern menus
	for (i = 1; i <= pixpatcount; i++) {
		SetResLoad(false);
		h = Get1IndResource('ppat', i);
		SetResLoad(true);
		if (h == nil)
			return(CANTGETPIXPAT_NDX);
		GetResInfo(h, &resID, &restype, str);
		if (ResError() == noErr) {
			if (str[0] == 0) {
				/* The resource had no name, so we'll create one like
					'Unnamed PixPat 1'. */
				sint32todstr(i, countstr);
				paramstr(str, UNNAMEDPIXPAT_NDX, countstr, nil, nil, nil);
			}
			/* Now we append an empty name as the menu item,
				then we do a SetMenuItemText in case the picture name
				contains any metacharacters.  This makes it look clean. */
			AppendMenu(gPenPatMenu, "\p ");
			SetMenuItemText(gPenPatMenu, i+FIRSTPIXPAT_ITEM-1, str);
			AppendMenu(gBgPatMenu, "\p ");
			SetMenuItemText(gBgPatMenu, i+FIRSTPIXPAT_ITEM-1, str);
			AppendMenu(gFillPatMenu, "\p ");
			SetMenuItemText(gFillPatMenu, i+FIRSTPIXPAT_ITEM-1, str);
		} else {
			DBUGSTR("ResError() returned error after getting PixPat ResInfo");
		}
		h = (Handle)GetPixPat(resID);
		if (h == nil)
			return(CANTGETPIXPAT_NDX);
		gPixPath[i-1] = (PixPatHandle)h;
	}
	InsertMenu(gPenPatMenu, -1);
	if (gPenPat > pixpatcount)
		gPenPat = pixpatcount + FIRSTPIXPAT_ITEM - 1;
	CheckItem(gPenPatMenu, gPenPat, true);

	InsertMenu(gBgPatMenu, -1);
	if (gBgPat > pixpatcount)
		gBgPat = pixpatcount + FIRSTPIXPAT_ITEM - 1;
	CheckItem(gBgPatMenu, gBgPat, true);

	InsertMenu(gFillPatMenu, -1);
	if (gFillPat > pixpatcount)
		gFillPat = pixpatcount + FIRSTPIXPAT_ITEM - 1;
	CheckItem(gFillPatMenu, gFillPat, true);

	if ((gSrcLocMenu = GetMenu(SRCLOCMENU_ID)) == nil)
		return(CANTGETMENU_NDX);
	InsertMenu(gSrcLocMenu, -1);
	CheckItem(gSrcLocMenu, gSrcLoc, true);

	if ((gSrcDimMenu = GetMenu(SRCDIMMENU_ID)) == nil)
		return(CANTGETMENU_NDX);
	InsertMenu(gSrcDimMenu, -1);
	if (!gSepSrc)	// Sync source & dest dimensions unless activated
		gSrcDim = gDestDim;
	CheckItem(gSrcDimMenu, gSrcDim, true);

	// SrcImage menu already set up with DestImage menu

	if ((gXferModeMenu = GetMenu(XFERMODEMENU_ID)) == nil)
		return(CANTGETMENU_NDX);
	InsertMenu(gXferModeMenu, -1);
	CheckItem(gXferModeMenu, gXferMode, true);
	CheckItem(gXferModeMenu, X_PLUSDITHER_ITEM, gXPlusDither);

	if ((gSrcRectMenu = GetMenu(SRCRECTMENU_ID)) == nil)
		return(CANTGETMENU_NDX);
	InsertMenu(gSrcRectMenu, -1);
	CheckItem(gSrcRectMenu, gSrcRect, true);

	if ((gDestRectMenu = GetMenu(DESTRECTMENU_ID)) == nil)
		return(CANTGETMENU_NDX);
	InsertMenu(gDestRectMenu, -1);
	CheckItem(gDestRectMenu, gDestRect, true);

	if ((gTextModeMenu = GetMenu(TEXTMODEMENU_ID)) == nil)
		return(CANTGETMENU_NDX);
	InsertMenu(gTextModeMenu, -1);
	CheckItem(gTextModeMenu, gTextMode, true);
	CheckItem(gTextModeMenu, T_PLUSHILITE_ITEM, gTPlusHilite);
	CheckItem(gTextModeMenu, T_PLUSMASK_ITEM, gTPlusMask);

	return(0);
}

int main(void)
{
	SInt32 err;

	/* The usual invocations */
	InitGraf(&qd.thePort);	/* Initialize Quickdraw */
	InitFonts();			/* Font Manager */
	InitWindows();			/* Window Manager */
	InitMenus();			/* Menu Manager */
	TEInit(); 				/* TextEdit */
	InitDialogs(nil);		/* Dialog Manager (no resume procedure) */
	InitCursor(); 			/* Initialize the cursor to an arrow */
	FlushEvents(everyEvent, 0);	/* Clear the event queue of all events */

	/* Do the application-specific setup */
	if ((err = checkconfig()) != 0) {
		erroralert(err);
		return(err);
	}
	if ((err = setupmenus()) != 0) {
		erroralert(err);
		return(err);
	}
	if ((err = initdest()) != 0 || (err = initsource()) != 0) {
		erroralert(err);
		return(err);
	}
	if ((err = initstatus()) != 0) {
		erroralert(err);
		return(err);
	}
	if ((err = initregions()) != 0) {
		erroralert(err);
		return(err);
	}
	/* Let there be menus and windows */
	DrawMenuBar();
	ShowWindow(gDestWind);
	if (gSepSrc && gSrcLoc == WINDOW_ITEM)
		ShowWindow(gSrcWind);
	ShowWindow(gStatusWind);

	doeventloop();	// Main event dispatching

	cleanupdest();
	cleanupsrc();
	cleanupstatus();

	return(0);
}

static void uint32tohstr(UInt32 num, unsigned char *strp)
{
	SInt32 i, digit;
	char numbuf[20];

	i = 0;
	do {	/* Convert the number to a reversed ASCII string */
		digit = num & 0x0F;
		if (digit >= 10)
			digit += ('A' - 10);
		else
			digit += '0';
		numbuf[i++] = digit;
	} while ((num >>= 4) > 0);
	*strp++ = i;		/* Copy the length byte */
	while (--i >= 0)	/* Copy the string forwards to its destination */
		*strp++ = numbuf[i];
}

static void uint32todstr(UInt32 num, unsigned char *strp)
{
	SInt32 i;
	char numbuf[20];

	i = 0;
	do {	/* Convert the number to a reversed ASCII string */
		numbuf[i++] = num % 10 + '0';
	} while ((num /= 10) > 0);
	*strp++ = i;		/* Copy the length byte */
	while (--i >= 0)	/* Copy the string forwards to its destination */
		*strp++ = numbuf[i];
}

static void sint32todstr(SInt32 num, unsigned char *strp)
{
	Boolean neg;
	SInt32 i;
	char numbuf[20];

	if (num < 0) {
		neg = true;
		num = -num;
	} else {
		neg = false;
	}
	i = 0;
	do {	/* Convert the number to a reversed ASCII string */
		numbuf[i++] = num % 10 + '0';
	} while ((num /= 10) > 0);
	if (neg)
		numbuf[i++] = '-';
	*strp++ = i;		/* Copy the length byte */
	while (--i >= 0)	/* Copy the string forwards to its destination */
		*strp++ = numbuf[i];
}

/* Note: all of these are Pascal strings */
static void paramstr(unsigned char *dest, SInt32 index, unsigned char *sub0, unsigned char *sub1,
			unsigned char *sub2, unsigned char *sub3)
{
	SInt32 srclen, substlen, destindex;
	unsigned char str[256], *source, *substitute;

	GetIndString(str, PARAMSTR_ID, index);
	source = str;

	srclen = *source++;
	destindex = 0;

	while (srclen > 0) {
		if (*source == '^') {	/* Substitution marker */
			if (srclen == 1) {	/* Last character in string was '^' */
				goto storedest;
			} else {
				switch (*(source+1)) {
				case '0':
					substitute = sub0;
					break;
				case '1':
					substitute = sub1;
					break;
				case '2':
					substitute = sub2;
					break;
				case '3':
					substitute = sub3;
					break;
				default:
					goto storedest;
				}
			}
			source += 2;	/* Skip over the '^n' characters */
			srclen -= 2;
			if (substitute != nil) {	/* Guard against NIL pointers */
				substlen = *substitute++;
				while (substlen) {
					destindex++;
					dest[destindex] = *substitute++;
					substlen--;
				}
			}
		} else {	/* Not doing a substitution, so copy a byte from the source */
storedest:
			destindex++;
			dest[destindex] = *source++;
			srclen--;
		}
	}

	dest[0] = destindex;	/* Finally, fill in the length byte */
}

static void coloritemtoRGB(UInt32 item, RGBColor *otherp, RGBColor *colorp)
{
	switch (item) {
	case BLACK_ITEM:
		colorp->red = 0;
		colorp->green = 0;
		colorp->blue = 0;
		break;
	case WHITE_ITEM:
		colorp->red = 0xFFFF;
		colorp->green = 0xFFFF;
		colorp->blue = 0xFFFF;
		break;
	case RED_ITEM:
		colorp->red = 0xFFFF;
		colorp->green = 0;
		colorp->blue = 0;
		break;
	case GREEN_ITEM:
		colorp->red = 0;
		colorp->green = 0xFFFF;
		colorp->blue = 0;
		break;
	case BLUE_ITEM:
		colorp->red = 0;
		colorp->green = 0;
		colorp->blue = 0xFFFF;
		break;
	case CYAN_ITEM:
		colorp->red = 0;
		colorp->green = 0xFFFF;
		colorp->blue = 0xFFFF;
		break;
	case MAGENTA_ITEM:
		colorp->red = 0xFFFF;
		colorp->green = 0;
		colorp->blue = 0xFFFF;
		break;
	case YELLOW_ITEM:
		colorp->red = 0xFFFF;
		colorp->green = 0xFFFF;
		colorp->blue = 0;
		break;
	case GRAY53_ITEM:
		colorp->red = 0x8888;
		colorp->green = 0x8888;
		colorp->blue = 0x8888;
		break;
	case HILITE_ITEM:
		LMGetHiliteRGB(colorp);
		break;
	case RANDOM_ITEM:
		colorp->red = Random();
		colorp->green = Random();
		colorp->blue = Random();
		break;
	case OTHERCOLOR_ITEM:
		*colorp = *otherp;
		break;
	}
}

static UInt32 windpttoaddr(WindowPtr wind, Point *originp)
{
	UInt32 v, h, addr;
	GrafPtr oldport;
	GDPtr gdp;
	GDHandle gdh;
	PixMapPtr pmp;
	Point pt;

	GetPort(&oldport);
	SetPort(wind);
	pt = *originp;	// Get top-left origin point
	LocalToGlobal(&pt);
	SetPort(oldport);

	for (gdh = GetDeviceList(); gdh != nil; gdh = GetNextDevice(gdh)) {
		if (!TestDeviceAttribute(gdh, screenDevice) ||
				!TestDeviceAttribute(gdh, screenActive))
			continue;
		gdp = *gdh;
		/* See if the window is on this GDevice */
		if (PtInRect(pt, &gdp->gdRect))
			goto gotgdev;
	}
	return(0);

gotgdev:
	v = pt.v - gdp->gdRect.top;
	h = pt.h - gdp->gdRect.left;
	pmp = *gdp->gdPMap;
	addr = (UInt32)pmp->baseAddr + v * ((UInt32)pmp->rowBytes & 0x3FFF);
	addr += h << (pmp->pixelSize >> 4);
	return(addr);
}

static UInt32 gwpixmappttoaddr(PixMapHandle pmh, Point *originp)
{
	UInt32 v, h, addr;
	PixMapPtr pmp;
	Point pt;

	addr = (UInt32)GetPixBaseAddr(pmh);
	pt = *originp;
	pmp = *pmh;
	v = pt.v - pmp->bounds.top;
	h = pt.h - pmp->bounds.left;
	addr += v * ((UInt32)pmp->rowBytes & 0x3FFF);
	addr += h << (pmp->pixelSize >> 4);
	return(addr);
}

static void docopybitstest(WindowPtr wind)
{
	UInt32 mode, width, height;
	UInt32 iter, beginticks, curticks, stopticks;
	BitMapPtr srcbits, destbits;
	CGrafPtr oldport;
	GDHandle oldgdh;
	PixMapHandle destpmh, srcpmh;
	RgnHandle maskrgnh;
	Rect srcrect, destrect, portrect, r;
	RGBColor foreRGB, backRGB, opRGB;

	switch (gXferMode) {
	case X_SRCCOPY_ITEM:
		mode = srcCopy;
		break;
	case X_SRCOR_ITEM:
		mode = srcOr;
		break;
	case X_SRCXOR_ITEM:
		mode = srcXor;
		break;
	case X_SRCBIC_ITEM:
		mode = srcBic;
		break;
	case X_NOTSRCCOPY_ITEM:
		mode = notSrcCopy;
		break;
	case X_NOTSRCOR_ITEM:
		mode = notSrcOr;
		break;
	case X_NOTSRCXOR_ITEM:
		mode = notSrcXor;
		break;
	case X_NOTSRCBIC_ITEM:
		mode = notSrcBic;
		break;
	case X_ADDOVER_ITEM:
		mode = addOver;
		break;
	case X_ADDPIN_ITEM:
		mode = addPin;
		opRGB.red = 0xFFFF;
		opRGB.green = 0xFFFF;
		opRGB.blue = 0xFFFF;
		OpColor(&opRGB);
		break;
	case X_SUBOVER_ITEM:
		mode = subOver;
		break;
	case X_SUBPIN_ITEM:
		mode = subPin;
		opRGB.red = 0;
		opRGB.green = 0;
		opRGB.blue = 0;
		OpColor(&opRGB);
		break;
	case X_ADMAX_ITEM:
		mode = adMax;
		break;
	case X_ADMIN_ITEM:
		mode = adMin;
		break;
	case X_BLEND_ITEM:
		mode = blend;
		opRGB.red = 0x4040;
		opRGB.green = 0x4040;
		opRGB.blue = 0x4040;
		OpColor(&opRGB);
		break;
	case X_TRANSPARENT_ITEM:
		mode = transparent;
		break;
	case X_HILITE_ITEM:
		mode = hilitetransfermode;
		break;
	}
	if (gXPlusDither)
		mode += ditherCopy;

	/* Get the source and destination rectangles */
	r.top = 0;
	r.left = 0;
	dimtowh(gSrcDim, &width, &height);
	r.bottom = height;
	r.right = width;
	rectitemtorect(gSrcRect, &r, &gSrcOtherRect, &srcrect);
	dimtowh(gDestDim, &width, &height);
	r.bottom = height;
	r.right = width;
	rectitemtorect(gDestRect, &r, &gDestOtherRect, &destrect);

	if (gDestLoc != WINDOW_ITEM) {	// Destination is offscreen
		GetGWorld(&oldport, &oldgdh);
		SetGWorld(gDestGW, nil);
		destpmh = GetGWorldPixMap(gDestGW);
		LockPixels(destpmh);
		destbits = &((GrafPtr)gDestGW)->portBits;
		portrect = ((GrafPtr)gDestGW)->portRect;
		gTestDestAddr = gwpixmappttoaddr(destpmh, (Point *)&destrect);
	} else {	// Destination is onscreen
		// The current port is already set to the window
		destbits = &wind->portBits;
		portrect = wind->portRect;
		gTestDestAddr = windpttoaddr(wind, (Point *)&destrect);
	}
	if (gSepSrc) {
		if (gSrcLoc != WINDOW_ITEM) {	// Source is offscreen
			srcpmh = GetGWorldPixMap(gSrcGW);
			LockPixels(srcpmh);
			srcbits = &((GrafPtr)gSrcGW)->portBits;
			gTestSrcAddr = gwpixmappttoaddr(srcpmh, (Point *)&srcrect);
		} else {	// Source is onscreen
			srcbits = &gSrcWind->portBits;
			gTestSrcAddr = windpttoaddr(gSrcWind, (Point *)&srcrect);
		}
	} else {	// No separate source, so source loc = destination
		srcbits = destbits;
		if (gDestLoc != WINDOW_ITEM)	// Destination is offscreen
			gTestSrcAddr = gwpixmappttoaddr(destpmh, (Point *)&srcrect);
		else	// Destination is onscreen
			gTestSrcAddr = windpttoaddr(wind, (Point *)&srcrect);
	}
	if (gUseClipRgn)
		SetClip(gRgnh[gClipRgn]);
	else
		ClipRect(&portrect);

	/* Set up any custom colors we might have */
	coloritemtoRGB(gFgColor, &gFgOtherRGB, &foreRGB);
	coloritemtoRGB(gBgColor, &gBgOtherRGB, &backRGB);
	RGBForeColor(&foreRGB);
	RGBBackColor(&backRGB);

	/* Grab the mask region, if it's being used */
	maskrgnh = nil;
	if (gUseMaskRgn)
		maskrgnh = gRgnh[gMaskRgn];

	/* Perform the actual test, gathering timing information */
	beginticks = TickCount();
	stopticks = beginticks + TESTTICKS;
	for (iter = 0; (curticks = TickCount()) < stopticks; iter++) {
		CopyBits(srcbits, destbits, &srcrect, &destrect, mode, maskrgnh);
	}
	gTestBeginTicks = beginticks;
	gTestEndTicks = curticks;
	gTestIterations = iter;

	/* Restore the foreground and background colors to black & white */
	coloritemtoRGB(BLACK_ITEM, &gFgOtherRGB, &foreRGB);
	coloritemtoRGB(WHITE_ITEM, &gBgOtherRGB, &backRGB);
	RGBForeColor(&foreRGB);
	RGBBackColor(&backRGB);

	ClipRect(&portrect);	// Restore the full clipping

	if (gDestLoc != WINDOW_ITEM) {	// Destination was offscreen
		SetGWorld(oldport, oldgdh);
		UnlockPixels(destpmh);
	}
	if (gSepSrc && gSrcLoc != WINDOW_ITEM)	// Source was offscreen
		UnlockPixels(srcpmh);
}

static void dotexttest(WindowPtr wind)
{
	UInt32 mode, width, height, fontheight, fontascent, v;
	UInt32 iter, beginticks, curticks, stopticks;
	BitMapPtr destbits;
	CGrafPtr oldport;
	GDHandle oldgdh;
	PixMapHandle destpmh;
	Rect destrect, portrect, r;
	RGBColor foreRGB, backRGB, opRGB;
	FontInfo fi;

	switch (gTextMode) {
	case T_SRCCOPY_ITEM:
		mode = srcCopy;
		break;
	case T_SRCOR_ITEM:
		mode = srcOr;
		break;
	case T_SRCXOR_ITEM:
		mode = srcXor;
		break;
	case T_SRCBIC_ITEM:
		mode = srcBic;
		break;
	case T_NOTSRCCOPY_ITEM:
		mode = notSrcCopy;
		break;
	case T_NOTSRCOR_ITEM:
		mode = notSrcOr;
		break;
	case T_NOTSRCXOR_ITEM:
		mode = notSrcXor;
		break;
	case T_NOTSRCBIC_ITEM:
		mode = notSrcBic;
		break;
	case T_ADDOVER_ITEM:
		mode = addOver;
		break;
	case T_ADDPIN_ITEM:
		mode = addPin;
		opRGB.red = 0xFFFF;
		opRGB.green = 0xFFFF;
		opRGB.blue = 0xFFFF;
		OpColor(&opRGB);
		break;
	case T_SUBOVER_ITEM:
		mode = subOver;
		break;
	case T_SUBPIN_ITEM:
		mode = subPin;
		opRGB.red = 0;
		opRGB.green = 0;
		opRGB.blue = 0;
		OpColor(&opRGB);
		break;
	case T_ADMAX_ITEM:
		mode = adMax;
		break;
	case T_ADMIN_ITEM:
		mode = adMin;
		break;
	case T_BLEND_ITEM:
		mode = blend;
		opRGB.red = 0x4040;
		opRGB.green = 0x4040;
		opRGB.blue = 0x4040;
		OpColor(&opRGB);
		break;
	case T_TRANSPARENT_ITEM:
		mode = transparent;
		break;
	case T_GRAYISHTEXTOR_ITEM:
		mode = grayishTextOr;
		break;
	}
	if (gTPlusHilite)
		mode += hilitetransfermode;
	if (gTPlusMask)
		mode += 64;

	/* Get the destination rectangle */
	r.top = 0;
	r.left = 0;
	dimtowh(gDestDim, &width, &height);
	r.bottom = height;
	r.right = width;
	rectitemtorect(gDestRect, &r, &gDestOtherRect, &destrect);

	if (gDestLoc != WINDOW_ITEM) {	// Destination is offscreen
		GetGWorld(&oldport, &oldgdh);
		SetGWorld(gDestGW, nil);
		destpmh = GetGWorldPixMap(gDestGW);
		LockPixels(destpmh);
		destbits = &((GrafPtr)gDestGW)->portBits;
		portrect = ((GrafPtr)gDestGW)->portRect;
		gTestDestAddr = gwpixmappttoaddr(destpmh, (Point *)&destrect);
	} else {	// Destination is onscreen
		// The current port is already set to the window
		destbits = &wind->portBits;
		portrect = wind->portRect;
		gTestDestAddr = windpttoaddr(wind, (Point *)&destrect);
	}
	gTestSrcAddr = 0;
	if (gUseClipRgn)
		SetClip(gRgnh[gClipRgn]);
	else
		ClipRect(&portrect);

	/* Set the Text parameters */
	TextFont(0);
	TextSize(20);
	TextFace(0);
	TextMode(mode);
	GetFontInfo(&fi);
	fontascent = fi.ascent;
	fontheight = fontascent + fi.descent;

	/* Set up any custom colors we might have */
	coloritemtoRGB(gFgColor, &gFgOtherRGB, &foreRGB);
	coloritemtoRGB(gBgColor, &gBgOtherRGB, &backRGB);
	RGBForeColor(&foreRGB);
	RGBBackColor(&backRGB);

	v = 0;

	/* Perform the actual test, gathering timing information */
	beginticks = TickCount();
	stopticks = beginticks + TESTTICKS;
	for (iter = 0; (curticks = TickCount()) < stopticks; iter++) {
		MoveTo(0, v + fontascent);
		DrawString("\pThe quick red fox jumped over the lazy brown dog.");
		v += fontascent;
		if (v >= destrect.bottom)
			v = 0;
	}
	gTestBeginTicks = beginticks;
	gTestEndTicks = curticks;
	gTestIterations = iter;

	/* Restore the foreground and background colors to black & white */
	coloritemtoRGB(BLACK_ITEM, &gFgOtherRGB, &foreRGB);
	coloritemtoRGB(WHITE_ITEM, &gBgOtherRGB, &backRGB);
	RGBForeColor(&foreRGB);
	RGBBackColor(&backRGB);

	/* Restore the transfer mode */
	TextMode(srcOr);

	ClipRect(&portrect);	// Restore the full clipping

	if (gDestLoc != WINDOW_ITEM) {	// Destination was offscreen
		SetGWorld(oldport, oldgdh);
		UnlockPixels(destpmh);
	}
}

static void patitemtopat(UInt32 patitem, PatPtr patptr)
{
	static Pattern gHStripes =
		{ 0xFF, 0x00, 0xFF, 0x00, 0x00, 0xFF, 0xFF, 0x00 };
	static Pattern gVStripes =
		{ 0xA6, 0xA6, 0xA6, 0xA6, 0xA6, 0xA6, 0xA6, 0xA6 };
	static Pattern gDStripes =
		{ 0x84, 0x42, 0x21, 0x90, 0x48, 0x24, 0x12, 0x09 };
	static Pattern gNumNibbles =
		{ 0x01, 0x23, 0x45, 0x67, 0x89, 0xAB, 0xCD, 0xEF };

	switch (patitem) {
	case BLACKPAT_ITEM:
		*patptr = qd.black;
		break;
	case WHITEPAT_ITEM:
		*patptr = qd.white;
		break;
	case GRAY50PAT_ITEM:
		*patptr = qd.gray;
		break;
	case LTGRAYPAT_ITEM:
		*patptr = qd.ltGray;
		break;
	case DKGRAYPAT_ITEM:
		*patptr = qd.dkGray;
		break;
	case HSTRIPESPAT_ITEM:
		*patptr = gHStripes;
		break;
	case VSTRIPESPAT_ITEM:
		*patptr = gVStripes;
		break;
	case DSTRIPESPAT_ITEM:
		*patptr = gDStripes;
		break;
	case NUMNIBBLESPAT_ITEM:
		*patptr = gNumNibbles;
		break;
	default:
		DBUGPRINTF(("Unknown patitem %d", patitem));
		break;
	}
}

static void pensizeitemtopt(UInt32 pensizeitem, Point *ptp)
{
	switch (pensizeitem) {
	case PS_1X1_ITEM:
		ptp->v = 1;
		ptp->h = 1;
		break;
	case PS_2X2_ITEM:
		ptp->v = 2;
		ptp->h = 2;
		break;
	case PS_4X4_ITEM:
		ptp->v = 4;
		ptp->h = 4;
		break;
	case PS_8X8_ITEM:
		ptp->v = 8;
		ptp->h = 8;
		break;
	case PS_16X16_ITEM:
		ptp->v = 16;
		ptp->h = 16;
		break;
	}
}

static void doshapetest(WindowPtr wind, UInt32 test)
{
	UInt32 mode, h, v, width, height;
	UInt32 iter, beginticks, curticks, stopticks;
	CGrafPtr oldport;
	GDHandle oldgdh;
	PixMapHandle destpmh;
	RgnHandle rgnh;
	PixPatHandle pixpath;
	Point pensize;
	Rect destrect, portrect;
	Pattern pat;
	RGBColor foreRGB, backRGB;

	switch (gPenMode) {
	case PATCOPY_ITEM:
		mode = patCopy;
		break;
	case PATOR_ITEM:
		mode = patOr;
		break;
	case PATXOR_ITEM:
		mode = patXor;
		break;
	case PATBIC_ITEM:
		mode = patBic;
		break;
	case NOTPATCOPY_ITEM:
		mode = notPatCopy;
		break;
	case NOTPATOR_ITEM:
		mode = notPatOr;
		break;
	case NOTPATXOR_ITEM:
		mode = notPatXor;
		break;
	case NOTPATBIC_ITEM:
		mode = notPatBic;
		break;
	case PATCOPYPLUSTRANSP_ITEM:
		mode = patCopy + transparent;
		break;
	}
	if (gPMPlusHilite)
		mode += hilitetransfermode;

	if (gDestLoc != WINDOW_ITEM) {	// Destination is offscreen
		GetGWorld(&oldport, &oldgdh);
		SetGWorld(gDestGW, nil);
		destpmh = GetGWorldPixMap(gDestGW);
		LockPixels(destpmh);
		destrect = ((GrafPtr)gDestGW)->portRect;
		portrect = destrect;
		InsetRect(&destrect, gBoundRectHInset, gBoundRectVInset);
		gTestDestAddr = gwpixmappttoaddr(destpmh, (Point *)&destrect);
	} else {	// Destination is onscreen
		// The current port is already set to the window
		destrect = wind->portRect;
		portrect = destrect;
		InsetRect(&destrect, gBoundRectHInset, gBoundRectVInset);
		gTestDestAddr = windpttoaddr(wind, (Point *)&destrect);
	}
	gTestSrcAddr = 0;
	if (gUseClipRgn)
		SetClip(gRgnh[gClipRgn]);
	else
		ClipRect(&portrect);

	switch (test) {
	case ERASESHAPE_ITEM:
		if (gBgPat >= FIRSTPIXPAT_ITEM) {
			/* It's a PixPat */
			BackPixPat(gPixPath[gBgPat-FIRSTPIXPAT_ITEM]);
		} else {
			/* Set the old-style background pattern */
			patitemtopat(gBgPat, &pat);
			BackPat(&pat);
		}
		break;
	case INVERTSHAPE_ITEM:
		break;	// Don't need to set the pen parameters
	case PATFILLSHAPE_ITEM:
		if (gFillPat >= FIRSTPIXPAT_ITEM) {
			/* It's a PixPat */
			pixpath = gPixPath[gFillPat-FIRSTPIXPAT_ITEM];
		} else {
			/* Set the old-style background pattern */
			patitemtopat(gFillPat, &pat);
			pixpath = nil;
		}
		break;
	default:
		/* Set the pen mode */
		PenMode(mode);
		/* Set the pen pixpat or pattern */
		if (gPenPat >= FIRSTPIXPAT_ITEM) {
			/* It's a PixPat */
			PenPixPat(gPixPath[gPenPat-FIRSTPIXPAT_ITEM]);
		} else {
			/* Set the old-style pen pattern */
			patitemtopat(gPenPat, &pat);
			PenPat(&pat);
		}
		/* Set the pen size */
		pensizeitemtopt(gPenSize, &pensize);
		PenSize(pensize.h, pensize.v);
		break;
	}

	/* Set up any custom colors we might have */
	coloritemtoRGB(gFgColor, &gFgOtherRGB, &foreRGB);
	coloritemtoRGB(gBgColor, &gBgOtherRGB, &backRGB);
	RGBForeColor(&foreRGB);
	RGBBackColor(&backRGB);

	if (gShape == REGION_ITEM)
		rgnh = gRgnh[gRgnShape];

	/* Perform the actual test, gathering timing information */
	beginticks = TickCount();
	stopticks = beginticks + TESTTICKS;

	switch (test) {
	case LINES_ITEM:
		switch (gLines) {
		case HORIZONTAL_ITEM:
			h = destrect.left;
			width = destrect.right - h;
			v = destrect.top;
			height = destrect.bottom - v;
			for (iter = 0; (curticks = TickCount()) < stopticks; iter++) {
				MoveTo(h, v);
				LineTo(h + width, v);
				v += pensize.v + 1;
				if (v >= destrect.bottom)
					v = destrect.top;
			}
			break;
		case VERTICAL_ITEM:
			h = destrect.left;
			width = destrect.right - h;
			v = destrect.top;
			height = destrect.bottom - v;
			for (iter = 0; (curticks = TickCount()) < stopticks; iter++) {
				MoveTo(h, v);
				LineTo(h, v + height);
				h += pensize.h + 1;
				if (h >= destrect.right)
					h = destrect.left;
			}
			break;
		case DIAGONAL_ITEM:
			h = destrect.left;
			width = destrect.right - h;
			v = destrect.top;
			height = destrect.bottom - v;
			for (iter = 0; (curticks = TickCount()) < stopticks; iter++) {
				MoveTo(h, v);
				LineTo(h + height, v + height);
			}
			break;
		case SLANTED_ITEM:
			break;
		}
		break;
	case FRAMESHAPE_ITEM:
		switch (gShape) {
		case RECTANGLE_ITEM:
			for (iter = 0; (curticks = TickCount()) < stopticks; iter++) {
				FrameRect(&destrect);
			}
			break;
		case REGION_ITEM:
			for (iter = 0; (curticks = TickCount()) < stopticks; iter++) {
				FrameRgn(rgnh);
			}
			break;
		case OVAL_ITEM:
			for (iter = 0; (curticks = TickCount()) < stopticks; iter++) {
				FrameOval(&destrect);
			}
			break;
		case ROUNDRECT_ITEM:
			for (iter = 0; (curticks = TickCount()) < stopticks; iter++) {
				FrameRoundRect(&destrect, RRECT_CURVATURE, RRECT_CURVATURE);
			}
			break;
		case ARC_ITEM:
			for (iter = 0; (curticks = TickCount()) < stopticks; iter++) {
				FrameArc(&destrect, ARC_STARTANGLE, ARC_DEGREES);
			}
			break;
		default:
			DBUGPRINTF(("Unimplemented Frame Shape %d", gShape));
			break;
		}
		break;
	case PAINTSHAPE_ITEM:
		switch (gShape) {
		case RECTANGLE_ITEM:
			for (iter = 0; (curticks = TickCount()) < stopticks; iter++) {
				PaintRect(&destrect);
			}
			break;
		case REGION_ITEM:
			for (iter = 0; (curticks = TickCount()) < stopticks; iter++) {
				PaintRgn(rgnh);
			}
			break;
		case OVAL_ITEM:
			for (iter = 0; (curticks = TickCount()) < stopticks; iter++) {
				PaintOval(&destrect);
			}
			break;
		case ROUNDRECT_ITEM:
			for (iter = 0; (curticks = TickCount()) < stopticks; iter++) {
				PaintRoundRect(&destrect, RRECT_CURVATURE, RRECT_CURVATURE);
			}
			break;
		case ARC_ITEM:
			for (iter = 0; (curticks = TickCount()) < stopticks; iter++) {
				PaintArc(&destrect, ARC_STARTANGLE, ARC_DEGREES);
			}
			break;
		default:
			DBUGPRINTF(("Unimplemented Paint Shape %d", gShape));
			break;
		}
		break;
	case ERASESHAPE_ITEM:
		switch (gShape) {
		case RECTANGLE_ITEM:
			for (iter = 0; (curticks = TickCount()) < stopticks; iter++) {
				EraseRect(&destrect);
			}
			break;
		case REGION_ITEM:
			for (iter = 0; (curticks = TickCount()) < stopticks; iter++) {
				EraseRgn(rgnh);
			}
			break;
		case OVAL_ITEM:
			for (iter = 0; (curticks = TickCount()) < stopticks; iter++) {
				EraseOval(&destrect);
			}
			break;
		case ROUNDRECT_ITEM:
			for (iter = 0; (curticks = TickCount()) < stopticks; iter++) {
				EraseRoundRect(&destrect, RRECT_CURVATURE, RRECT_CURVATURE);
			}
			break;
		case ARC_ITEM:
			for (iter = 0; (curticks = TickCount()) < stopticks; iter++) {
				EraseArc(&destrect, ARC_STARTANGLE, ARC_DEGREES);
			}
			break;
		default:
			DBUGPRINTF(("Unimplemented Erase Shape %d", gShape));
			break;
		}
		break;
	case INVERTSHAPE_ITEM:
		switch (gShape) {
		case RECTANGLE_ITEM:
			for (iter = 0; (curticks = TickCount()) < stopticks; iter++) {
				InvertRect(&destrect);
			}
			break;
		case REGION_ITEM:
			for (iter = 0; (curticks = TickCount()) < stopticks; iter++) {
				InvertRgn(rgnh);
			}
			break;
		case OVAL_ITEM:
			for (iter = 0; (curticks = TickCount()) < stopticks; iter++) {
				InvertOval(&destrect);
			}
			break;
		case ROUNDRECT_ITEM:
			for (iter = 0; (curticks = TickCount()) < stopticks; iter++) {
				InvertRoundRect(&destrect, RRECT_CURVATURE, RRECT_CURVATURE);
			}
			break;
		case ARC_ITEM:
			for (iter = 0; (curticks = TickCount()) < stopticks; iter++) {
				InvertArc(&destrect, ARC_STARTANGLE, ARC_DEGREES);
			}
			break;
		default:
			DBUGPRINTF(("Unimplemented Invert Shape %d", gShape));
			break;
		}
		break;
	case PATFILLSHAPE_ITEM:
		switch (gShape) {
		case RECTANGLE_ITEM:
			if (pixpath == nil) {
				for (iter = 0; (curticks = TickCount()) < stopticks; iter++) {
					FillRect(&destrect, &pat);
				}
			} else {
				for (iter = 0; (curticks = TickCount()) < stopticks; iter++) {
					FillCRect(&destrect, pixpath);
				}
			}
			break;
		case REGION_ITEM:
			if (pixpath == nil) {
				for (iter = 0; (curticks = TickCount()) < stopticks; iter++) {
					FillRgn(rgnh, &pat);
				}
			} else {
				for (iter = 0; (curticks = TickCount()) < stopticks; iter++) {
					FillCRgn(rgnh, pixpath);
				}
			}
			break;
		case OVAL_ITEM:
			if (pixpath == nil) {
				for (iter = 0; (curticks = TickCount()) < stopticks; iter++) {
					FillOval(&destrect, &pat);
				}
			} else {
				for (iter = 0; (curticks = TickCount()) < stopticks; iter++) {
					FillCOval(&destrect, pixpath);
				}
			}
			break;
		case ROUNDRECT_ITEM:
			if (pixpath == nil) {
				for (iter = 0; (curticks = TickCount()) < stopticks; iter++) {
					FillRoundRect(&destrect, RRECT_CURVATURE, RRECT_CURVATURE, &pat);
				}
			} else {
				for (iter = 0; (curticks = TickCount()) < stopticks; iter++) {
					FillCRoundRect(&destrect, RRECT_CURVATURE, RRECT_CURVATURE, pixpath);
				}
			}
			break;
		case ARC_ITEM:
			if (pixpath == nil) {
				for (iter = 0; (curticks = TickCount()) < stopticks; iter++) {
					FillArc(&destrect, ARC_STARTANGLE, ARC_DEGREES, &pat);
				}
			} else {
				for (iter = 0; (curticks = TickCount()) < stopticks; iter++) {
					FillCArc(&destrect, ARC_STARTANGLE, ARC_DEGREES, pixpath);
				}
			}
			break;
		default:
			DBUGPRINTF(("Unimplemented Pattern Fill Shape %d", gShape));
			break;
		}
		break;
	}

	gTestBeginTicks = beginticks;
	gTestEndTicks = curticks;
	gTestIterations = iter;

	/* Restore the foreground and background colors to black & white */
	coloritemtoRGB(BLACK_ITEM, &gFgOtherRGB, &foreRGB);
	coloritemtoRGB(WHITE_ITEM, &gBgOtherRGB, &backRGB);
	RGBForeColor(&foreRGB);
	RGBBackColor(&backRGB);

	/* Restore the default pen settings */
	PenNormal();

	ClipRect(&portrect);	// Restore the full clipping

	if (gDestLoc != WINDOW_ITEM) {	// Destination was offscreen
		SetGWorld(oldport, oldgdh);
		UnlockPixels(destpmh);
	}
}

static void runtest(UInt32 test)
{
	GrafPtr oldport;
	WindowPtr wind;

	if (gDestPictBufGW == nil || (gDestLoc != WINDOW_ITEM && gDestGW == nil)) {
		erroralert(CANTGETGWORLD_NDX);
		return;
	}
	if (gTest == COPYBITS_ITEM && gSepSrc) {
		if (gSrcPictBufGW == nil || (gSrcLoc != WINDOW_ITEM && gSrcGW == nil)) {
			erroralert(CANTGETGWORLD_NDX);
			return;
		}
	}

	if (!gNoRefresh && gDestLoc != WINDOW_ITEM)	// Destination is offscreen GWorld
		copyGWtoGW(gDestPictBufGW, gDestGW, gDitherDest);
	if (!gNoCursorHide)
		HideCursor();

	GetPort(&oldport);
	wind = gDestWind;
	SetPort(wind);
	if (!gNoRefresh || gDestLoc != WINDOW_ITEM)
		updatedestwind(wind);

	switch (test) {
	case COPYBITS_ITEM:
		docopybitstest(wind);
		break;
	case TEXT_ITEM:
		dotexttest(wind);
		break;
	case LINES_ITEM:
	case FRAMESHAPE_ITEM:
	case PAINTSHAPE_ITEM:
	case ERASESHAPE_ITEM:
	case INVERTSHAPE_ITEM:
	case PATFILLSHAPE_ITEM:
		doshapetest(wind, test);
		break;
	default:
		test = 0;
		break;
	}

	if (gDestLoc != WINDOW_ITEM)	// Destination is offscreen GWorld
		updatedestwind(wind);	// Show the changed pixels

	SetPort(oldport);
	if (!gNoCursorHide)
		ShowCursor();

	gLastTest = test;
	invalwind(gStatusWind);	// Update the timing statistics
}

static void showdialog(SInt32 resid)
{
	short itemhit;
	DialogPtr dlog;

	if ((dlog = GetNewDialog(resid, nil, (WindowPtr)-1)) == nil) {
		erroralert(CANTGETDLOG_NDX);
		return;
	}
	ModalDialog(nil, &itemhit);	/* Get all events until an active item is hit */
	DisposeDialog(dlog);		/* Get rid of the dialog */
}

static void setitemstate(MenuHandle menu, UInt32 item, UInt32 enable)
{
	if (enable)
		EnableItem(menu, item);
	else
		DisableItem(menu, item);
}

static void configmenus(void)
{
	UInt32 i, enable;
	WindowPtr wind;

	// Edit menu
	if ((wind = FrontWindow()) && ((WindowPeek)wind)->windowKind < 0) {
		// It's a DA window
		enable = true;
	} else {
		// We won't allow editing commands
		enable = false;
	}
	setitemstate(gEditMenu, UNDO_ITEM, enable);
	setitemstate(gEditMenu, CUT_ITEM, enable);
	setitemstate(gEditMenu, COPY_ITEM, true);
	setitemstate(gEditMenu, PASTE_ITEM, enable);
	setitemstate(gEditMenu, CLEAR_ITEM, enable);

	//  Test menu
	for (i = RECTANGLE_ITEM; i <= ARC_ITEM; i++)
		setitemstate(gTestMenu, i, gTest >= FRAMESHAPE_ITEM);
	enable = true;
	if (gTest == COPYBITS_ITEM || (gTest >= FRAMESHAPE_ITEM && gShape == REGION_ITEM))
		enable = false;
	setitemstate(gTestMenu, BOUNDRECT_ITEM, enable);
	enable = false;
	if (gTest >= FRAMESHAPE_ITEM && gShape == REGION_ITEM)
		enable = true;
	setitemstate(gTestMenu, RGNSHAPE_ITEM, enable);

	// Destination menu
	enable = true;
	if (gTest == INVERTSHAPE_ITEM || gTest == PATFILLSHAPE_ITEM)
		enable = false;
	setitemstate(gDestMenu, FGCOLOR_ITEM, enable);
	setitemstate(gDestMenu, BGCOLOR_ITEM, enable);
	setitemstate(gDestMenu, SWAPFGBG_ITEM, enable);
	setitemstate(gDestMenu, RESETCOLORS_ITEM, enable);
	enable = false;
	if (gTest == LINES_ITEM || gTest == FRAMESHAPE_ITEM)
		enable = true;
	setitemstate(gDestMenu, PENSIZE_ITEM, enable);
	enable = false;
	if (gTest == LINES_ITEM || gTest == FRAMESHAPE_ITEM ||
			gTest == PAINTSHAPE_ITEM)
		enable = true;
	setitemstate(gDestMenu, PENMODE_ITEM, enable);
	setitemstate(gDestMenu, PENPATTERN_ITEM, enable);
	setitemstate(gDestMenu, BGPATTERN_ITEM, gTest == ERASESHAPE_ITEM);
	setitemstate(gDestMenu, FILLPATTERN_ITEM, gTest == PATFILLSHAPE_ITEM);
	setitemstate(gDestMenu, CLIPRGN_ITEM, gUseClipRgn);

	// CopyBits menu
	for (i = SRCLOCATION_ITEM; i <= SRCDITHER_ITEM; i++)
		setitemstate(gCopyBitsMenu, i, gSepSrc);
	setitemstate(gCopyBitsMenu, MASKRGN_ITEM, gUseMaskRgn);
}

static void doapplemenu(UInt32 item)
{
	GrafPtr oldport;
	unsigned char str[256];

	if (item == ABOUT_ITEM) {
		showdialog(ABOUTDLOG_ID);
	} else {
		GetMenuItemText(gAppleMenu, item, str);	/* Get the DA name */
		GetPort(&oldport);		/* Preserve the current port in case the DA doesn't */
		OpenDeskAcc(str);		/* Open the DA */
		SetPort(oldport);		/* Restore the port */
	}
}

static void dofilemenu(UInt32 item)
{
	switch (item) {
	case QUIT_ITEM:
		gQuitFlag = true;	/* Set the flag so we leave the main event loop */
		break;
	}
}

static void docopy(void)
{

	SInt32 err;
	GrafPtr oldport;
	PicHandle pic;
	OpenCPicParams cpp;

	cpp.srcRect.top = 0;
	cpp.srcRect.left = 0;
	cpp.srcRect.bottom = 100;
	cpp.srcRect.right = 100;
	cpp.hRes = 0x00480000;
	cpp.vRes = 0x00480000;
	cpp.version = -2;
	cpp.reserved1 = 0;
	cpp.reserved2 = 0;
	GetPort(&oldport);
	SetPort(gDestWind);
	if ((pic = OpenCPicture(&cpp)) == nil) {
		DBUGSTR("OpenCPicture() failed");
		SetPort(oldport);	/* Restore the port */
		return;
	}
	ClipRect(&cpp.srcRect);
	/* Copy from the grafport to itself in order to record it */
	CopyBits((BitMap *)&gDestWind->portBits,
			 (BitMap *)&gDestWind->portBits,
			 &cpp.srcRect, &cpp.srcRect, srcCopy, nil);
#if 0
	MoveTo(2, 20);
DBUGSTR("About to call DrawString");
	DrawString("\pTest of a string!");
#endif
	ClosePicture();
	ClipRect(&gDestWind->portRect);

	if (*pic == nil) {
		DBUGSTR("Closed picture has null size");
		SetPort(oldport);	/* Restore the port */
		return;
	}

	HLock((Handle)pic);
	if (EmptyRect(&(*pic)->picFrame)) {	/* Did we run out of memory? */
		DBUGSTR("Closed picture has empty frame rectangle");
		KillPicture(pic);
		SetPort(oldport);	/* Restore the port */
		return;
	}
	ZeroScrap();
	err = PutScrap(GetHandleSize((Handle)pic), 'PICT', (Ptr)*pic);
	KillPicture(pic);
	if (err) {
		DBUGSTR("Error %d from PutScrap()");
		ZeroScrap();
	}
	SetPort(oldport);	/* Restore the port */
	return;
}

static void doeditmenu(UInt32 item)
{
	switch (item) {
	case COPY_ITEM:
		docopy();
		break;
	default:
		break;
	}
}

static SInt32 strtouint32(unsigned char *strp, UInt32 *valptr)
{
	UInt32 len, i, digits;
	long val;

	len = strp[0];
	strp++;
	i = 0;
	while (i < len) {	/* Ignore leading spaces */
		if (*strp != ' ')
			break;
		*strp++;
		i++;
	}
	digits = 0;
	val = 0;
	while (i < len && *strp >= '0' && *strp <= '9') {
		val = val * 10 + (*strp - '0');
		digits++;
		strp++;
		i++;
	}
	while (i < len) {	/* Ignore trailing spaces */
		if (*strp != ' ')
			break;
		*strp++;
		i++;
	}
	if (i < len || digits == 0 || digits > 9) {
		*valptr = 0;  /* Zero the number by default with errors!!! */
		return(1);
	} else {
		*valptr = val;
		return(0);
	}
}

static void doboundrectdlog(void)
{
	SInt16 itemhit, itemtype;
	UInt32 val, width, height;
	GrafPtr oldport;
	DialogPtr dlog;
	Handle horizitemh, vertitemh;
	Rect r;
	unsigned char str[256];

	if ((dlog = GetNewDialog(BOUNDRECTDLOG_ID, nil, (WindowPtr)-1)) == nil) {
		erroralert(CANTGETDLOG_NDX);
		return;
	}

	GetPort(&oldport);
	SetPort(dlog);

	dimtowh(gDestDim, &width, &height);

	GetDialogItem(dlog, HORIZ_BRDITM, &itemtype, &horizitemh, &r);
	GetDialogItem(dlog, VERT_BRDITM, &itemtype, &vertitemh, &r);
	uint32todstr(gBoundRectHInset, str);
	SetDialogItemText(horizitemh, str);
	uint32todstr(gBoundRectVInset, str);
	SetDialogItemText(vertitemh, str);
	/* Select the first editText item */
	SelectDialogItemText(dlog, HORIZ_BRDITM, 0, 32767);

	ShowWindow(dlog);

	do {
		ModalDialog(nil, &itemhit);
		switch (itemhit) {
		case OK_BRDITM:
			GetDialogItemText(horizitemh, str);
			if (strtouint32(str, &val) || val > (width/2 - 1)) {
				SysBeep(BEEPTICKS);
				uint32todstr(RECTINSET, str);
				SetDialogItemText(horizitemh, str);
				SelectDialogItemText(dlog, HORIZ_BRDITM, 0, 32767);
				break;
			}
			gBoundRectHInset = val;
			GetDialogItemText(vertitemh, str);
			if (strtouint32(str, &val) || val > (height/2 - 1)) {
				SysBeep(BEEPTICKS);
				uint32todstr(RECTINSET, str);
				SetDialogItemText(vertitemh, str);
				SelectDialogItemText(dlog, VERT_BRDITM, 0, 32767);
				break;
			}
			gBoundRectVInset = val;
			break;
		}
	} while (itemhit != OK_BRDITM);

	SetPort(oldport);
	DisposeDialog(dlog);
}

static void dotestmenu(UInt32 item)
{
	MenuHandle menu1, menu2;

	switch (item) {
	case RUN_ITEM:
		runtest(gTest);
		break;
	case NOREFRESH_ITEM:
		gNoRefresh = !gNoRefresh;
		CheckItem(gTestMenu, item, gNoRefresh);
		break;
	case NOCURSORHIDE_ITEM:
		gNoCursorHide = !gNoCursorHide;
		CheckItem(gTestMenu, item, gNoCursorHide);
		break;
	case COPYBITS_ITEM:
	case LINES_ITEM:
	case TEXT_ITEM:
	case FRAMESHAPE_ITEM:
	case PAINTSHAPE_ITEM:
	case ERASESHAPE_ITEM:
	case INVERTSHAPE_ITEM:
	case PATFILLSHAPE_ITEM:
		if (item == gTest)	// No change, we're done
			break;
		/* We're choosing a new test */
		CheckItem(gTestMenu, gTest, false);
		CheckItem(gTestMenu, item, true);
		menu1 = nil;
		if (gTest == COPYBITS_ITEM) {
			menu1 = gCopyBitsMenu;
		} else if (gTest == LINES_ITEM) {
			menu1 = gLinesMenu;
		} else if (gTest == TEXT_ITEM) {
			menu1 = gTextMenu;
		}
		if (menu1)
			DisableItem(menu1, 0);

		menu2 = nil;
		if (item == COPYBITS_ITEM) {
			menu2 = gCopyBitsMenu;
		} else if (item == LINES_ITEM) {
			menu2 = gLinesMenu;
		} else if (item == TEXT_ITEM) {
			menu2 = gTextMenu;
		}
		if (menu2)
			EnableItem(menu2, 0);
		if (menu1 || menu2)
			InvalMenuBar();
		gTest = item;
		break;
	case RECTANGLE_ITEM:
	case REGION_ITEM:
	case OVAL_ITEM:
	case ROUNDRECT_ITEM:
	case ARC_ITEM:
	case POLYGON_ITEM:
		if (item == gShape)	// No change, we're done
			break;
		CheckItem(gTestMenu, gShape, false);
		CheckItem(gTestMenu, item, true);
		gShape = item;
		break;
	case BOUNDRECT_ITEM:
		doboundrectdlog();
		break;
	}
}

static void dodestmenu(UInt32 item)
{
	UInt32 saveitem;

	switch (item) {
	case DESTDITHER_ITEM:
		gDitherDest = !gDitherDest;
		CheckItem(gDestMenu, DESTDITHER_ITEM, gDitherDest);
		if (gDestLoc != WINDOW_ITEM) {	// Destination is offscreen GWorld
			if (gDestPictBufGW == nil || gDestGW == nil)
				break;
			copyGWtoGW(gDestPictBufGW, gDestGW, gDitherDest);
		}
		invalwind(gDestWind);	// Invalidate so it redraws
		break;
	case SWAPFGBG_ITEM:
		gSwapFgBg = !gSwapFgBg;
		CheckItem(gDestMenu, SWAPFGBG_ITEM, gSwapFgBg);
		CheckItem(gFgColorMenu, gFgColor, false);
		CheckItem(gBgColorMenu, gBgColor, false);
		saveitem = gFgColor;
		gFgColor = gBgColor;
		gBgColor = saveitem;
		CheckItem(gFgColorMenu, gFgColor, true);
		CheckItem(gBgColorMenu, gBgColor, true);
		/* Keep 'Other' RGB values properly maintained */
		if (gFgColor == OTHERCOLOR_ITEM) {
			if (gSwapFgBg) {
				gFgSaveRGB = gFgOtherRGB;
				gFgOtherRGB = gBgOtherRGB;
			} else {
				gFgOtherRGB = gFgSaveRGB;
			}
		}
		if (gBgColor == OTHERCOLOR_ITEM) {
			if (gSwapFgBg) {
				gBgSaveRGB = gBgOtherRGB;
				gBgOtherRGB = gFgOtherRGB;
			} else {
				gBgOtherRGB = gBgSaveRGB;
			}
		}
		break;
	case RESETCOLORS_ITEM:
		gSwapFgBg = false;
		CheckItem(gDestMenu, SWAPFGBG_ITEM, false);
		CheckItem(gFgColorMenu, gFgColor, false);
		CheckItem(gBgColorMenu, gBgColor, false);
		gFgColor = BLACK_ITEM;
		gBgColor = WHITE_ITEM;
		CheckItem(gFgColorMenu, BLACK_ITEM, true);
		CheckItem(gBgColorMenu, WHITE_ITEM, true);
		break;
	case USECLIPRGN_ITEM:
		gUseClipRgn = !gUseClipRgn;
		CheckItem(gDestMenu, USECLIPRGN_ITEM, gUseClipRgn);
		break;
	case CLIPRGN_ITEM:
		DBUGPRINTF(("CLIPRGN_ITEM: supposed to be a hierarchical menu!!"));
		break;
	}
}

static void docopybitsmenu(UInt32 item)
{
	SInt32 err;
	UInt32 width, height;
	Rect r;

	switch (item) {
	case USESEPSRC_ITEM:
		gSepSrc = !gSepSrc;
		CheckItem(gCopyBitsMenu, USESEPSRC_ITEM, gSepSrc);
		if (gSepSrc) {
			dimtowh(gSrcDim, &width, &height);
			SizeWindow(gSrcWind, width, height, false);
			r = gSrcWind->portRect;
			/* Allocate the GWorld in main memory (keepLocal) */
			if ((err = NewGWorld(&gSrcPictBufGW, 32, &r, nil, nil, keepLocal)) != noErr) {
				erroralert(CANTGETGWORLD_NDX);
				break;
			}
			if (gSrcLoc != WINDOW_ITEM) {	// Source is offscreen GWorld
				if ((err = allocgworld(gSrcLoc, &r, &gSrcGW)) != 0) {
					erroralert(err);
					break;
				}
			}
			if ((err = drawpicttogworld(gSrcImage, gSrcPictBufGW)) != 0) {
				erroralert(err);
				break;
			}
			if (gSrcLoc != WINDOW_ITEM)	// Source is offscreen GWorld
				copyGWtoGW(gSrcPictBufGW, gSrcGW, gDitherSrc);
			ShowWindow(gSrcWind);
		} else {
			if (gSrcGW) {
				DisposeGWorld(gSrcGW);
				gSrcGW = nil;
			}
			if (gSrcPictBufGW) {	// Dispose of source picture buffer GWorld
				DisposeGWorld(gSrcPictBufGW);
				gSrcPictBufGW = nil;
			}
			HideWindow(gSrcWind);
		}
		break;
	case SRCDITHER_ITEM:
		gDitherSrc = !gDitherSrc;
		CheckItem(gCopyBitsMenu, SRCDITHER_ITEM, gDitherSrc);
		if (gSrcLoc != WINDOW_ITEM) {	// Source is offscreen GWorld
			if (gSrcPictBufGW == nil || gSrcGW == nil)
				break;
			copyGWtoGW(gSrcPictBufGW, gSrcGW, gDitherSrc);
		}
		invalwind(gSrcWind);	// Invalidate so it redraws
		break;
	case USEMASKRGN_ITEM:
		gUseMaskRgn = !gUseMaskRgn;
		CheckItem(gCopyBitsMenu, USEMASKRGN_ITEM, gUseMaskRgn);
		break;
	}
}

static void dolinesmenu(UInt32 item)
{
	if (item == gLines)	// No change, we're done
		return;
	/* We're choosing a new line type */
	CheckItem(gLinesMenu, gLines, false);
	CheckItem(gLinesMenu, item, true);
	gLines = item;
}

static void dotextmenu(UInt32 item)
{
	switch (item) {
	case STRING_ITEM:
		break;
	}
}

// Return non-zero if two Pascal-style strings are equal
static int pstrequal(unsigned char *strp1, unsigned char *strp2)
{
	int len, i;

	len = *strp1;	// Length byte
	for (i = 0; i <= len; i++) {	// Make sure the length bytes match, too
		if (strp1[i] != strp2[i])	// If they don't match, return zero
			return(0);
	}
	return(1);	// The length and the string characters are the same, return non-zero
}

static void dolutdither(void)
{
	int drvrrefnum;
	GrafPtr oldport;
	GDHandle gdh;
	GDPtr gdp;
	PixMapPtr pmp;
	unsigned int utableindex;
	AuxDCEHandle *unittable;
	AuxDCEPtr dcep;
	DRVRHeaderPtr drvrhdrp;
	Rect wr;
	static unsigned char *drivername = "\p.Display_NV";

	for (gdh = GetDeviceList(); gdh != nil; gdh = GetNextDevice(gdh)) {
		drvrrefnum = (*gdh)->gdRefNum;	// Signed number (should always be negative)
		utableindex = ~drvrrefnum;		// Convert negative refnum to positive Unit Table index
		unittable = (AuxDCEHandle *)LMGetUTableBase();	// Get the base address of the Unit Table
		dcep = *(unittable[utableindex]);	// Index into the table to get the handle to our AuxDCE
		drvrhdrp = (DRVRHeaderPtr)dcep->dCtlDriver;	// Get a pointer or handle to our driver header
		if (dcep->dCtlFlags & dRAMBasedMask)		// Means it was a handle, not a pointer
			drvrhdrp = *(DRVRHeaderHandle)drvrhdrp;	// De-reference to get the pointer
		if (pstrequal(drvrhdrp->drvrName, drivername))
			goto gotgdev;
	}
	erroralert(CANTGETNVBOARD_NDX);
	return;

gotgdev:
	pmp = *(*gdh)->gdPMap;
	if (pmp->pixelSize != 32) {
		erroralert(NEEDMILLIONS_NDX);
		return;
	}
	wr = gDestWind->portRect;
	GetPort(&oldport);
	SetPort(gDestWind);
	LocalToGlobal((Point *)&wr.top);
	LocalToGlobal((Point *)&wr.bottom);
	SetPort(oldport);
	// See if the window's global content rect is contained within the NV gdRect
	gdp = *gdh;
	if (wr.top < gdp->gdRect.top || wr.left < gdp->gdRect.left ||
			wr.bottom > gdp->gdRect.bottom || wr.right > gdp->gdRect.right) {
		erroralert(DESTNOTONNV_NDX);
		return;
	}
	// Now we have the destination window entirely on the 32-bit NVIDIA screen.
	
}

static void dospatialdither(void)
{
}

static void doexpmenu(UInt32 item)
{
	switch (item) {
	case LUTDITHER_ITEM:
		dolutdither();
		break;
	case SPATIALDITHER_ITEM:
		dospatialdither();
		break;
	}
}

static void dorgnshapemenu(UInt32 item)
{
	if (item == gRgnShape)	// No change, we're done
		return;
	/* We're choosing a new region */
	CheckItem(gRgnShapeMenu, gRgnShape, false);
	CheckItem(gRgnShapeMenu, item, true);
	gRgnShape = item;
}

static void docliprgnmenu(UInt32 item)
{
	if (item == gClipRgn)	// No change, we're done
		return;
	/* We're choosing a new region */
	CheckItem(gClipRgnMenu, gClipRgn, false);
	CheckItem(gClipRgnMenu, item, true);
	gClipRgn = item;
}

static void domaskrgnmenu(UInt32 item)
{
	if (item == gMaskRgn)	// No change, we're done
		return;
	/* We're choosing a new region */
	CheckItem(gMaskRgnMenu, gMaskRgn, false);
	CheckItem(gMaskRgnMenu, item, true);
	gMaskRgn = item;
}

static void dodestlocmenu(UInt32 item)
{
	SInt32 err;

	if (item == gDestLoc)	// No change, we're done
		return;
	/* We're choosing a new dest image location */
	CheckItem(gDestLocMenu, gDestLoc, false);
	CheckItem(gDestLocMenu, item, true);
	if (gDestLoc != WINDOW_ITEM) {	// Destination is offscreen GWorld
		if (gDestGW) {
			DisposeGWorld(gDestGW);
			gDestGW = nil;
		}
	}
	if (gDestPictBufGW == nil)
		return;
	if (item != WINDOW_ITEM) {	// New destination is offscreen GWorld
		if ((err = allocgworld(item, &gDestPictBufGW->portRect, &gDestGW)) != 0) {
			erroralert(err);
			return;
		}
		copyGWtoGW(gDestPictBufGW, gDestGW, gDitherDest);
	}
	gDestLoc = item;
	/* Invalidate the destination window so it will redraw */
	invalwind(gDestWind);
	setlocdimtitle(gDestWind);
}

static void dodestdimmenu(UInt32 item)
{
	SInt32 err;
	UInt32 width, height;
	Rect r;

	if (item == gDestDim)	// No change, we're done
		return;
	/* We're choosing new dest image dimensions */
	CheckItem(gDestDimMenu, gDestDim, false);
	CheckItem(gDestDimMenu, item, true);
	gDestDim = item;
	if (gDestLoc != WINDOW_ITEM) {	// Destination is offscreen GWorld
		if (gDestGW) {
			DisposeGWorld(gDestGW);
			gDestGW = nil;
		}
	}
	if (gDestPictBufGW) {	// Dispose of destination picture buffer GWorld
		DisposeGWorld(gDestPictBufGW);
		gDestPictBufGW = nil;
	}
	dimtowh(gDestDim, &width, &height);
	r.top = 0;
	r.left = 0;
	r.bottom = height;
	r.right = width;
	/* Allocate the GWorld in main memory (keepLocal) */
	if ((err = NewGWorld(&gDestPictBufGW, 32, &r, nil, nil, keepLocal)) != 0) {
		erroralert(CANTGETGWORLD_NDX);
		return;
	}
	if (gDestLoc != WINDOW_ITEM) {	// Destination is offscreen GWorld
		if ((err = allocgworld(gDestLoc, &r, &gDestGW)) != 0) {
			erroralert(err);
			return;
		}
	}
	if ((err = drawpicttogworld(gDestImage, gDestPictBufGW)) != 0) {
		erroralert(err);
		return;
	}
	if (gDestLoc != WINDOW_ITEM)	// Destination is offscreen GWorld
		copyGWtoGW(gDestPictBufGW, gDestGW, gDitherDest);

	SizeWindow(gDestWind, width, height, false);
	/* Invalidate the destination window so it will redraw */
	invalwind(gDestWind);
	setlocdimtitle(gDestWind);
}

static void dodestimagemenu(UInt32 item)
{
	SInt32 err;

	if (item == gDestImage)	// No change, we're done
		return;
	/* We're choosing a new dest image */
	CheckItem(gDestImageMenu, gDestImage, false);
	CheckItem(gDestImageMenu, item, true);
	gDestImage = item;
	if (gDestPictBufGW == nil)
		return;
	if ((err = drawpicttogworld(gDestImage, gDestPictBufGW)) != 0) {
		erroralert(err);
		return;
	}
	if (gDestLoc != WINDOW_ITEM) {	// Destination is offscreen GWorld
		if (gDestGW == nil)
			return;
		copyGWtoGW(gDestPictBufGW, gDestGW, gDitherDest);
	}
	/* Invalidate the destination window so it will redraw */
	invalwind(gDestWind);
}

static void dofgcolormenu(UInt32 item)
{
	if (item == OTHERCOLOR_ITEM) {	// Do a new custom color
	} else if (item == gFgColor) {	// No change, we're done
		return;
	}
	gSwapFgBg = false;
	CheckItem(gDestMenu, SWAPFGBG_ITEM, false);
	/* We've chosen a new foreground color item */
	CheckItem(gFgColorMenu, gFgColor, false);
	CheckItem(gFgColorMenu, item, true);
	gFgColor = item;
}

static void dobgcolormenu(UInt32 item)
{
	if (item == OTHERCOLOR_ITEM) {	// Do a new custom color
	} else if (item == gBgColor) {	// No change, we're done
		return;
	}
	gSwapFgBg = false;
	CheckItem(gDestMenu, SWAPFGBG_ITEM, false);
	/* We've chosen a new background color item */
	CheckItem(gBgColorMenu, gBgColor, false);
	CheckItem(gBgColorMenu, item, true);
	gBgColor = item;
}

static void dopensizemenu(UInt32 item)
{
	if (item == gPenSize)	// No change, we're done
		return;
	/* We're choosing a new pen size */
	CheckItem(gPenSizeMenu, gPenSize, false);
	CheckItem(gPenSizeMenu, item, true);
	gPenSize = item;
}

static void dopenmodemenu(UInt32 item)
{
	switch (item) {
	case PATCOPY_ITEM:
	case PATOR_ITEM:
	case PATXOR_ITEM:
	case PATBIC_ITEM:
	case NOTPATCOPY_ITEM:
	case NOTPATOR_ITEM:
	case NOTPATXOR_ITEM:
	case NOTPATBIC_ITEM:
	case PATCOPYPLUSTRANSP_ITEM:
		if (item == gPenMode) // No change, we're done
			break;
		/* We're choosing a new pen mode */
		CheckItem(gPenModeMenu, gPenMode, false);
		CheckItem(gPenModeMenu, item, true);
		gPenMode = item;
		break;
	case PM_PLUSHILITE_ITEM:
		gPMPlusHilite = !gPMPlusHilite;
		CheckItem(gPenModeMenu, PM_PLUSHILITE_ITEM, gPMPlusHilite);
		break;
	}
}

static void dopenpatmenu(UInt32 item)
{
	if (item == gPenPat) // No change, we're done
		return;
	/* We're choosing a new pen pattern */
	CheckItem(gPenPatMenu, gPenPat, false);
	CheckItem(gPenPatMenu, item, true);
	gPenPat = item;
}

static void dobgpatmenu(UInt32 item)
{
	if (item == gBgPat) // No change, we're done
		return;
	/* We're choosing a new background pattern */
	CheckItem(gBgPatMenu, gBgPat, false);
	CheckItem(gBgPatMenu, item, true);
	gBgPat = item;
}

static void dofillpatmenu(UInt32 item)
{
	if (item == gFillPat) // No change, we're done
		return;
	/* We're choosing a new fill pattern */
	CheckItem(gFillPatMenu, gFillPat, false);
	CheckItem(gFillPatMenu, item, true);
	gFillPat = item;
}

static void dosrclocmenu(UInt32 item)
{
	SInt32 err;

	if (item == gSrcLoc) // No change, we're done
		return;
	/* We're choosing a new source image location */
	CheckItem(gSrcLocMenu, gSrcLoc, false);
	CheckItem(gSrcLocMenu, item, true);
	if (gSrcLoc != WINDOW_ITEM) {	// Source is offscreen GWorld
		if (gSrcGW) {
			DisposeGWorld(gSrcGW);
			gSrcGW = nil;
		}
	}
	if (gSrcPictBufGW == nil)
		return;
	if (item != WINDOW_ITEM) {	// New source is offscreen GWorld
		if ((err = allocgworld(item, &gSrcPictBufGW->portRect, &gSrcGW)) != 0) {
			erroralert(err);
			return;
		}
		copyGWtoGW(gSrcPictBufGW, gSrcGW, gDitherSrc);
	}
	gSrcLoc = item;
	/* Invalidate the source window so it will redraw */
	invalwind(gSrcWind);
	setlocdimtitle(gSrcWind);
}

static void dosrcdimmenu(UInt32 item)
{
	SInt32 err;
	UInt32 width, height;
	Rect r;

	if (item == gSrcDim) // No change, we're done
		return;
	/* We're choosing new source image dimensions */
	CheckItem(gSrcDimMenu, gSrcDim, false);
	CheckItem(gSrcDimMenu, item, true);
	gSrcDim = item;

	if (gSrcLoc != WINDOW_ITEM) {	// Source is offscreen GWorld
		if (gSrcGW) {
			DisposeGWorld(gSrcGW);
			gSrcGW = nil;
		}
	}
	if (gSrcPictBufGW) {	// Dispose of source picture buffer GWorld
		DisposeGWorld(gSrcPictBufGW);
		gSrcPictBufGW = nil;
	}
	dimtowh(gSrcDim, &width, &height);
	r.top = 0;
	r.left = 0;
	r.bottom = height;
	r.right = width;
	/* Allocate the GWorld in main memory (keepLocal) */
	if ((err = NewGWorld(&gSrcPictBufGW, 32, &r, nil, nil, keepLocal)) != 0) {
		erroralert(CANTGETGWORLD_NDX);
		return;
	}
	if (gSrcLoc != WINDOW_ITEM) {	// Source is offscreen GWorld
		if ((err = allocgworld(gSrcLoc, &r, &gSrcGW)) != 0) {
			erroralert(err);
			return;
		}
	}
	if ((err = drawpicttogworld(gSrcImage, gSrcPictBufGW)) != 0) {
		erroralert(err);
		return;
	}
	if (gSrcLoc != WINDOW_ITEM)	// Source is offscreen GWorld
		copyGWtoGW(gSrcPictBufGW, gSrcGW, gDitherSrc);

	SizeWindow(gSrcWind, width, height, false);
	/* Invalidate the source window so it will redraw */
	invalwind(gSrcWind);
	setlocdimtitle(gSrcWind);
}

static void dosrcimagemenu(UInt32 item)
{
	SInt32 err;

	if (item == gSrcImage) // No change, we're done
		return;
	/* We're choosing a new source image */
	CheckItem(gSrcImageMenu, gSrcImage, false);
	CheckItem(gSrcImageMenu, item, true);
	gSrcImage = item;
	if (gSrcPictBufGW == nil)
		return;
	if ((err = drawpicttogworld(gSrcImage, gSrcPictBufGW)) != 0) {
		erroralert(err);
		return;
	}
	if (gSrcLoc != WINDOW_ITEM) {	// Source is offscreen GWorld
		if (gSrcGW == nil)
			return;
		copyGWtoGW(gSrcPictBufGW, gSrcGW, gDitherSrc);
	}
	/* Invalidate the source window so it will redraw */
	invalwind(gSrcWind);
}

static void doxfermodemenu(UInt32 item)
{
	switch (item) {
	case X_SRCCOPY_ITEM:
	case X_SRCOR_ITEM:
	case X_SRCXOR_ITEM:
	case X_SRCBIC_ITEM:
	case X_NOTSRCCOPY_ITEM:
	case X_NOTSRCOR_ITEM:
	case X_NOTSRCXOR_ITEM:
	case X_NOTSRCBIC_ITEM:
	case X_ADDOVER_ITEM:
	case X_ADDPIN_ITEM:
	case X_SUBOVER_ITEM:
	case X_SUBPIN_ITEM:
	case X_ADMAX_ITEM:
	case X_ADMIN_ITEM:
	case X_BLEND_ITEM:
	case X_TRANSPARENT_ITEM:
	case X_HILITE_ITEM:
		if (item == gXferMode) // No change, we're done
			break;
		/* We're choosing a new transfer mode */
		CheckItem(gXferModeMenu, gXferMode, false);
		CheckItem(gXferModeMenu, item, true);
		gXferMode = item;
		break;
	case X_PLUSDITHER_ITEM:
		gXPlusDither = !gXPlusDither;
		CheckItem(gXferModeMenu, X_PLUSDITHER_ITEM, gXPlusDither);
		break;
	}
}

static void dosrcrectmenu(UInt32 item)
{
	if (item == OTHERRECT_ITEM) {	/* Do a new custom rectangle */
	}
	if (item == gSrcRect) // No change, we're done
		return;
	/* We've chosen a new source rect */
	CheckItem(gSrcRectMenu, gSrcRect, false);
	CheckItem(gSrcRectMenu, item, true);
	gSrcRect = item;
}

static void dodestrectmenu(UInt32 item)
{
	if (item == OTHERRECT_ITEM) {	/* Do a new custom rectangle */
	}
	if (item == gDestRect) // No change, we're done
		return;
	/* We've chosen a new dest rect */
	CheckItem(gDestRectMenu, gDestRect, false);
	CheckItem(gDestRectMenu, item, true);
	gDestRect = item;
}

static void dotextmodemenu(UInt32 item)
{
	switch (item) {
	case T_SRCCOPY_ITEM:
	case T_SRCOR_ITEM:
	case T_SRCXOR_ITEM:
	case T_SRCBIC_ITEM:
	case T_NOTSRCCOPY_ITEM:
	case T_NOTSRCOR_ITEM:
	case T_NOTSRCXOR_ITEM:
	case T_NOTSRCBIC_ITEM:
	case T_ADDOVER_ITEM:
	case T_ADDPIN_ITEM:
	case T_SUBOVER_ITEM:
	case T_SUBPIN_ITEM:
	case T_ADMAX_ITEM:
	case T_ADMIN_ITEM:
	case T_BLEND_ITEM:
	case T_TRANSPARENT_ITEM:
	case T_GRAYISHTEXTOR_ITEM:
		if (item == gTextMode) // No change, we're done
			break;
		/* We're choosing a new transfer mode */
		CheckItem(gTextModeMenu, gTextMode, false);
		CheckItem(gTextModeMenu, item, true);
		gTextMode = item;
		break;
	case T_PLUSHILITE_ITEM:
		gTPlusHilite = !gTPlusHilite;
		CheckItem(gTextModeMenu, T_PLUSHILITE_ITEM, gTPlusHilite);
		break;
	case T_PLUSMASK_ITEM:
		gTPlusMask = !gTPlusMask;
		CheckItem(gTextModeMenu, T_PLUSMASK_ITEM, gTPlusMask);
		break;
	}
}


static void menucmd(long menuitem, short what)	/* Execute the appropriate routine */
{
#pragma unused(what)
	UInt32 menu, item;		/* Menu ID and item number */

	menu = menuitem >> 16;
	item = (UInt16)menuitem; //# check generated code for this

	switch (menu) {
	case APPLEMENU_ID:
		doapplemenu(item);
		break;
	case FILEMENU_ID:
		dofilemenu(item);
		break;
	case EDITMENU_ID:
		doeditmenu(item);
		break;
	case TESTMENU_ID:
		dotestmenu(item);
		break;
	case DESTMENU_ID:
		dodestmenu(item);
		break;
	case COPYBITSMENU_ID:
		docopybitsmenu(item);
		break;
	case LINESMENU_ID:
		dolinesmenu(item);
		break;
	case TEXTMENU_ID:
		dotextmenu(item);
		break;
	case EXPMENU_ID:
		doexpmenu(item);
		break;
	case RGNSHAPEMENU_ID:
		dorgnshapemenu(item);
		break;
	case CLIPRGNMENU_ID:
		docliprgnmenu(item);
		break;
	case MASKRGNMENU_ID:
		domaskrgnmenu(item);
		break;
	case DESTLOCMENU_ID:
		dodestlocmenu(item);
		break;
	case DESTDIMMENU_ID:
		dodestdimmenu(item);
		break;
	case DESTIMAGEMENU_ID:
		dodestimagemenu(item);
		break;
	case FGCOLORMENU_ID:
		dofgcolormenu(item);
		break;
	case BGCOLORMENU_ID:
		dobgcolormenu(item);
		break;
	case PENSIZEMENU_ID:
		dopensizemenu(item);
		break;
	case PENMODEMENU_ID:
		dopenmodemenu(item);
		break;
	case PENPATMENU_ID:
		dopenpatmenu(item);
		break;
	case BGPATMENU_ID:
		dobgpatmenu(item);
		break;
	case FILLPATMENU_ID:
		dofillpatmenu(item);
		break;
	case SRCLOCMENU_ID:
		dosrclocmenu(item);
		break;
	case SRCDIMMENU_ID:
		dosrcdimmenu(item);
		break;
	case SRCIMAGEMENU_ID:
		dosrcimagemenu(item);
		break;
	case XFERMODEMENU_ID:
		doxfermodemenu(item);
		break;
	case SRCRECTMENU_ID:
		dosrcrectmenu(item);
		break;
	case DESTRECTMENU_ID:
		dodestrectmenu(item);
		break;
	case TEXTMODEMENU_ID:
		dotextmodemenu(item);
		break;
	}

	HiliteMenu(0);			/* Invert the menu title back to normal */
}

static void closewind(WindowPtr wind)
{
	if (wind == nil)	/* No visible windows */
		return;
	if (((WindowPeek)wind)->windowKind < 0) {	/* Negative windowKind: it's a DA */
		CloseDeskAcc(((WindowPeek)wind)->windowKind);	/* windowKind = DA's refnum */
		return;
	}
	HideWindow(wind);	// Could dispose of it if we're sure we don't need it again
}

static void mouseclick(EventRecord *eventp)
{
	short part;
	WindowPtr wind;

	part = FindWindow(eventp->where, &wind);
	switch (part) {		/* Switch on the "window part" */
	case inMenuBar:
		configmenus();	/* Make sure the appropriate items are selected */
		menucmd(MenuSelect(eventp->where), eventp->what);	/* Process the selection */
		break;
	case inSysWindow:	/* DA or other system window */
		SystemClick(eventp, wind);
		break;
	case inContent:		/* Click in the content area of some window */
		if (wind != FrontWindow())	/* Is the window clicked on in front? */
			SelectWindow(wind); 		/* If not, bring it forward now */
		break;
	case inDrag:
		/* screenBits.bounds for the rect constrains to all GDevices */
		DragWindow(wind, eventp->where, &qd.screenBits.bounds);
		break;
	case inGoAway:
		if (TrackGoAway(wind, eventp->where))
			closewind(wind);
		break;
	}
}

static void keypress(EventRecord *eventp)	/* Handles command-key keyboard events */
{
	short key;

	key = eventp->message & charCodeMask;
	if (eventp->modifiers & cmdKey) {	/* Is the command key down? */
		configmenus();	/* Make sure the appropriate items are selected */
		/* Process the menu equivalent of that command key (if any) */
		menucmd(MenuKey(key), eventp->what);
	} else {	/* Not a command key */
	}
}

static void dimtowh(UInt32 dimitem, UInt32 *widthp, UInt32 *heightp)
{
	switch (dimitem) {
	case DIM_512X384_ITEM:
		*widthp = 512;
		*heightp = 384;
		break;
	case DIM_600X450_ITEM:
		*widthp = 600;
		*heightp = 450;
		break;
	case DIM_640X480_ITEM:
		*widthp = 640;
		*heightp = 480;
		break;
	case DIM_1024X768_ITEM:
		*widthp = 1024;
		*heightp = 768;
		break;
	}
}

static void rectitemtorect(UInt32 rectitem, Rect *inr, Rect *otherr, Rect *outr)
{
	*outr = *inr;	// Copy the whole input rect as default

	switch (rectitem) {
	case TOP50_ITEM:
		outr->bottom = (inr->top + inr->bottom) / 2;
		break;
	case BOTTOM50_ITEM:
		outr->top = (inr->top + inr->bottom) / 2;
		break;
	case LEFT50_ITEM:
		outr->right = (inr->left + inr->right) / 2;
		break;
	case RIGHT50_ITEM:
		outr->left = (inr->left + inr->right) / 2;
		break;
	case TOP99_ITEM:
		outr->bottom = inr->bottom - 1;
		break;
	case BOTTOM99_ITEM:
		outr->top = inr->top + 1;
		break;
	case LEFT99_ITEM:
		outr->right = inr->right - 1;
		break;
	case RIGHT99_ITEM:
		outr->left = inr->left + 1;
		break;
	case FULLSIZE_ITEM:
		// *outr = *inr
		break;
	case OTHERRECT_ITEM:
		*outr = *otherr;
		/* Constrain the 'other' rectangle to legal boundaries */
		if (outr->top < inr->top || outr->top >= inr->bottom)
			outr->top = inr->top;
		if (outr->left < inr->left || outr->left >= inr->right)
			outr->left = inr->left;
		if (outr->bottom > inr->bottom || outr->bottom <= inr->top)
			outr->bottom = inr->bottom;
		if (outr->right > inr->right || outr->right <= inr->left)
			outr->right = inr->right;
		break;
	}
}

static SInt32 allocgworld(UInt32 item, Rect *rectp, GWorldPtr *gwpp)
{
	SInt32 err;
	UInt32 depth;
	CTabHandle cth;

	switch (item) {
	case OFFSCRN1BW_ITEM:
		depth = 1;
		cth = gCTab1BW;
		break;
	case OFFSCRN8G_ITEM:
		depth = 8;
		cth = gCTab8G;
		break;
	case OFFSCRN8C_ITEM:
		depth = 8;
		cth = gCTab8C;
		break;
	case OFFSCRN16C_ITEM:
		depth = 16;
		cth = nil;
		break;
	case OFFSCRN24C_ITEM:
		depth = 32;
		cth = nil;
		break;
	}
	/* Allocate the GWorld in main memory (keepLocal) */
	if ((err = NewGWorld(gwpp, depth, rectp, cth, nil, keepLocal)) != 0) {
		return(CANTGETGWORLD_NDX);
	}
	return(0);
}

static SInt32 drawpicttogworld(UInt32 pictitem, GWorldPtr gwp)
{
	SInt32 err;
	CGrafPtr oldport;
	GDHandle oldgdh;
	PixMapHandle pmh;
	PicHandle pich;

	err = 0;
	if ((pich = (PicHandle)Get1Resource('PICT', PICT_BASEID - 1 + pictitem)) == nil)
		err = CANTGETPICT_NDX;
	GetGWorld(&oldport, &oldgdh);
	/* Draw the picture into the GWorld */
	SetGWorld(gwp, nil);
	pmh = GetGWorldPixMap(gwp);
	if (LockPixels(pmh)) {	// Drawing with the PixMap is OK
		if (pich) {
			EraseRect(&gwp->portRect);	// Set to a known state
			DrawPicture(pich, &gwp->portRect);
		} else {	// No picture, so fill it with something
			FillRect(&gwp->portRect, &qd.ltGray);
		}
		UnlockPixels(pmh);
	}
	SetGWorld(oldport, oldgdh);
	ReleaseResource((Handle)pich);
	return(err);
}

static void copyGWtoGW(GWorldPtr srcgwp, GWorldPtr destgwp, UInt32 dither)
{
	UInt32 mode;
	CGrafPtr oldport;
	GDHandle oldgdh;
	PixMapHandle srcpmh, destpmh;

	mode = srcCopy;
	if (dither)
		mode = srcCopy+ditherCopy;
	GetGWorld(&oldport, &oldgdh);
	/* Draw the picture into the GWorld */
	SetGWorld(destgwp, nil);
	srcpmh = GetGWorldPixMap(srcgwp);
	destpmh = GetGWorldPixMap(destgwp);
	if (LockPixels(srcpmh)) {
		if (LockPixels(destpmh)) {
			CopyBits(&((GrafPtr)srcgwp)->portBits, &((GrafPtr)destgwp)->portBits,
					&srcgwp->portRect, &destgwp->portRect, mode, nil);
			UnlockPixels(destpmh);
		}
		UnlockPixels(srcpmh);
	}
	SetGWorld(oldport, oldgdh);
}

static void setlocdimtitle(WindowPtr wind)
{
	unsigned char str[256], locstr[128], menuitemstr[128];

	if (wind == gSrcWind) {
		if (gSrcLoc == WINDOW_ITEM) {
			GetMenuItemText(gSrcLocMenu, WINDOW_ITEM, locstr);
		} else {
			GetMenuItemText(gSrcLocMenu, gSrcLoc, menuitemstr);
			paramstr(locstr, SOURCELOC_NDX, menuitemstr, nil, nil, nil);
		}
		GetMenuItemText(gSrcDimMenu, gSrcDim, menuitemstr);
	} else {	// Must be destination
		if (gDestLoc == WINDOW_ITEM) {
			GetMenuItemText(gDestLocMenu, WINDOW_ITEM, locstr);
		} else {
			GetMenuItemText(gDestLocMenu, gDestLoc, menuitemstr);
			paramstr(locstr, DESTLOC_NDX, menuitemstr, nil, nil, nil);
		}
		GetMenuItemText(gDestDimMenu, gDestDim, menuitemstr);
	}
	paramstr(str, WINDTITLE_NDX, locstr, menuitemstr, nil, nil);
	SetWTitle(wind, str);
}

static SInt32 initdest(void)
{
	SInt32 err;
	UInt32 width, height;
	Rect r;

	/* We initially bring up the window in a hidden state */
	if ((gDestWind = (GrafPtr)GetNewCWindow(DESTWIND_ID, 0L, (WindowPtr)-1L)) == nil)
		return(CANTGETWIND_NDX);
	dimtowh(gDestDim, &width, &height);
	SizeWindow(gDestWind, width, height, false);
	keepwindowonmain(gDestWind);	// Make sure it's not off the main display
	setlocdimtitle(gDestWind);

	if ((gCTab1BW = GetCTable(33)) == nil)	// 1-bit black & white table
		return(CANTGETCTABLE_NDX);
	if ((gCTab8G = GetCTable(40)) == nil)	// 8-bit gray-scale table
		return(CANTGETCTABLE_NDX);
	if ((gCTab8C = GetCTable(72)) == nil)	// 8-bit standard color table
		return(CANTGETCTABLE_NDX);

	r = gDestWind->portRect;
	/* Allocate the GWorld in main memory (keepLocal) */
	if ((err = NewGWorld(&gDestPictBufGW, 32, &r, nil, nil, keepLocal)) != 0) {
		return(CANTGETGWORLD_NDX);
	}
	if (gDestLoc != WINDOW_ITEM) {	// Destination is offscreen GWorld
		if ((err = allocgworld(gDestLoc, &r, &gDestGW)) != 0)
			return(err);
	}
	if ((err = drawpicttogworld(gDestImage, gDestPictBufGW)) != 0)
		return(err);
	if (gDestLoc != WINDOW_ITEM)	// Destination is offscreen GWorld
		copyGWtoGW(gDestPictBufGW, gDestGW, gDitherDest);
	return(0);
}

static void cleanupdest(void)
{
	if (gDestGW) {
		DisposeGWorld(gDestGW);
		gDestGW = nil;
	}
	if (gDestPictBufGW) {	// Dispose of destination picture buffer GWorld
		DisposeGWorld(gDestPictBufGW);
		gDestPictBufGW = nil;
	}
	DisposeCTable(gCTab8C);	// Dispose of the color tables we allocated
	DisposeCTable(gCTab8G);
	DisposeCTable(gCTab1BW);
	DisposeWindow(gDestWind);
}

static SInt32 initsource(void)
{
	SInt32 err;
	UInt32 width, height;
	Rect r;

	/* We initially bring up the window in a hidden state */
	if ((gSrcWind = (GrafPtr)GetNewCWindow(SOURCEWIND_ID, 0L, (WindowPtr)0L)) == nil)
		return(CANTGETWIND_NDX);
	dimtowh(gSrcDim, &width, &height);
	SizeWindow(gSrcWind, width, height, false);
	keepwindowonmain(gSrcWind);	// Make sure it's not off the main display
	setlocdimtitle(gSrcWind);

	if (!gSepSrc)	// No separate source, so we're done
		return(0);

	r = gSrcWind->portRect;
	/* Allocate the GWorld in main memory (keepLocal) */
	if ((err = NewGWorld(&gSrcPictBufGW, 32, &r, nil, nil, keepLocal)) != 0) {
		return(CANTGETGWORLD_NDX);
	}
	if (gSrcLoc != WINDOW_ITEM) {	// Source is offscreen GWorld
		if ((err = allocgworld(gSrcLoc, &r, &gSrcGW)) != 0)
			return(err);
	}
	if ((err = drawpicttogworld(gSrcImage, gSrcPictBufGW)) != 0)
		return(err);
	if (gSrcLoc != WINDOW_ITEM)	// Source is offscreen GWorld
		copyGWtoGW(gSrcPictBufGW, gSrcGW, gDitherSrc);
	return(0);
}

static void cleanupsrc(void)
{
	if (gSrcGW) {
		DisposeGWorld(gSrcGW);
		gSrcGW = nil;
	}
	if (gSrcPictBufGW) {	// Dispose of source picture buffer GWorld
		DisposeGWorld(gSrcPictBufGW);
		gSrcPictBufGW = nil;
	}
	DisposeWindow(gSrcWind);
}

static SInt32 initstatus(void)
{
	/* We initially bring up the window in a hidden state */
	if ((gStatusWind = (GrafPtr)GetNewCWindow(STATUSWIND_ID, 0L, (WindowPtr)0L)) == nil)
		return(CANTGETWIND_NDX);
	keepwindowonmain(gStatusWind);	// Make sure it's not off the main display
	return(0);
}

static void cleanupstatus(void)
{
	DisposeWindow(gStatusWind);
}

static SInt32 initregions(void)
{
	SInt32 err;
#define NUMPOLYPTS	17
	static SInt16 polypts[NUMPOLYPTS] = {
		0x0022, 0x001E, 0x001E, 0x0172, 0x023A, 0x0172, 0x001E, 0x0172,
		0x023A, 0x001E, 0x01B3, 0x0168, 0x012C, 0x001E, 0x00A5, 0x0172,
		0x001E
	};
	Rect maskrgnovalrect;
	static Rect bigrect = { 50, 50, 400, 550 };
	static Rect medrect = { 100, 100, 350, 500 };
	static Rect smallrect = { 150, 150, 300, 450 };
	PolyHandle polyh;
	RgnHandle rgnh, rgn2h;

	maskrgnovalrect = gDestWind->portRect;
	InsetRect(&maskrgnovalrect, 40, 140);

	/* Set up triangles and oval region */
	if ((polyh = (PolyHandle)NewHandle(NUMPOLYPTS*sizeof(SInt16))) == nil)
		return(CANTGETREGION_NDX);
	BlockMove((Ptr)polypts, (Ptr)*polyh, NUMPOLYPTS*sizeof(SInt16));
	if ((rgnh = NewRgn()) == nil)
		return(CANTGETREGION_NDX);
	OpenRgn();
	FramePoly(polyh);
	FrameOval(&maskrgnovalrect);
	CloseRgn(rgnh);
	err = QDError();
	DisposeHandle((Handle)polyh);
	if (err)
		return(CANTGETREGION_NDX);
	gRgnh[TRIOVALRGN_ITEM] = rgnh;

	/* Set up rounded rectangle region */
	if ((rgnh = NewRgn()) == nil)
		return(CANTGETREGION_NDX);
	OpenRgn();
	FrameRoundRect(&bigrect, RRECT_CURVATURE, RRECT_CURVATURE);
	CloseRgn(rgnh);
	err = QDError();
	if (err)
		return(CANTGETREGION_NDX);
	gRgnh[RRECTRGN_ITEM] = rgnh;

	/* Set up rectangle with hole region */
	if ((rgnh = NewRgn()) == nil)
		return(CANTGETREGION_NDX);
	OpenRgn();
	FrameRect(&bigrect);
	CloseRgn(rgnh);
	err = QDError();
	if (err)
		return(CANTGETREGION_NDX);
	if ((rgn2h = NewRgn()) == nil)
		return(CANTGETREGION_NDX);
	OpenRgn();
	FrameRect(&medrect);
	CloseRgn(rgn2h);
	err = QDError();
	if (err)
		return(CANTGETREGION_NDX);
	DiffRgn(rgnh, rgn2h, rgnh);
	DisposeRgn(rgn2h);
	gRgnh[RECTHOLERGN_ITEM] = rgnh;

	/* Set up the medium rectangular region */
	if ((rgnh = NewRgn()) == nil)
		return(CANTGETREGION_NDX);
	OpenRgn();
	FrameRect(&medrect);
	CloseRgn(rgnh);
	err = QDError();
	if (err)
		return(CANTGETREGION_NDX);
	gRgnh[MEDRECTRGN_ITEM] = rgnh;

	/* Set up the small rectangular region */
	if ((rgnh = NewRgn()) == nil)
		return(CANTGETREGION_NDX);
	OpenRgn();
	FrameRect(&smallrect);
	CloseRgn(rgnh);
	err = QDError();
	if (err)
		return(CANTGETREGION_NDX);
	gRgnh[SMALLRECTRGN_ITEM] = rgnh;

	/* Set up the empty region */
	if ((rgnh = NewRgn()) == nil)
		return(CANTGETREGION_NDX);
	OpenRgn();
	CloseRgn(rgnh);	// Open and Close Region with no other operations makes an empty region
	err = QDError();
	if (err)
		return(CANTGETREGION_NDX);
	gRgnh[EMPTYRGN_ITEM] = rgnh;

	return(0);
}

static void updatedestwind(WindowPtr wind)
{
	UInt32 mode;
	GWorldPtr gwp;
	PixMapHandle pmh;

	mode = srcCopy;	// Default
	if (gDestLoc == WINDOW_ITEM) {
		if (gDitherDest)
			mode = srcCopy+ditherCopy;
		gwp = gDestPictBufGW;
	} else {	// Offscreen GWorld
		gwp = gDestGW;
	}
	if (gwp == nil) {	// Must have run out of memory
		FillRect(&wind->portRect, &qd.ltGray);
		return;
	}
	pmh = GetGWorldPixMap(gwp);
	if (LockPixels(pmh)) {	// Drawing with the PixMap is OK
		CopyBits(&((GrafPtr)gwp)->portBits, &wind->portBits,
				&gwp->portRect, &wind->portRect, mode, nil);
		UnlockPixels(pmh);
	}
//InvertRect(&wind->portRect);
}

static void updatesrcwind(WindowPtr wind)
{
	UInt32 mode;
	GWorldPtr gwp;
	PixMapHandle pmh;

	mode = srcCopy;	// Default
	if (gSrcLoc == WINDOW_ITEM) {
		if (gDitherSrc)
			mode = srcCopy+ditherCopy;
		gwp = gSrcPictBufGW;
	} else {	// Offscreen GWorld
		gwp = gSrcGW;
	}
	if (gwp == nil) {	// Must have run out of memory
		FillRect(&wind->portRect, &qd.ltGray);
		return;
	}
	pmh = GetGWorldPixMap(gwp);
	if (LockPixels(pmh)) {	// Drawing with the PixMap is OK
		CopyBits(&((GrafPtr)gwp)->portBits, &wind->portBits,
				&gwp->portRect, &wind->portRect, mode, nil);
		UnlockPixels(pmh);
	}
}

static void updatestatuswind(WindowPtr wind)
{
	Rect r1, r2;
	unsigned char str[256], teststr[128], numstr1[16], numstr2[16];

	if (gLastTest == 0) {	// No tests have been run yet
		EraseRect(&wind->portRect);
		return;
	}
	r1 = wind->portRect;
	r2 = r1;
	r1.bottom = (r1.top + r1.bottom) / 2;
	r2.top = r1.bottom;
	GetMenuItemText(gTestMenu, gLastTest, teststr);
	sint32todstr(gTestEndTicks-gTestBeginTicks, numstr1);
	sint32todstr(gTestIterations, numstr2);
	paramstr(str, TIMING_NDX, teststr, numstr1, numstr2, nil);
	TETextBox(&str[1], str[0], &r1, teFlushDefault);
	uint32tohstr(gTestDestAddr, numstr1);
	uint32tohstr(gTestSrcAddr, numstr2);
	paramstr(str, ADDR_NDX, numstr1, numstr2, nil, nil);
	TETextBox(&str[1], str[0], &r2, teFlushDefault);
}

static void updatewind(WindowPtr wind)
{
	UInt32 refcon;
	GrafPtr oldport;

	GetPort(&oldport);
	SetPort(wind);
	BeginUpdate(wind);

	refcon = GetWRefCon(wind);
	if (refcon == DESTWINDREFCON)
		updatedestwind(wind);
	else if (refcon == SRCWINDREFCON)
		updatesrcwind(wind);
	else if (refcon == STATUSWINDREFCON)
		updatestatuswind(wind);

	EndUpdate(wind);
	SetPort(oldport);
}

static void invalwind(WindowPtr wind)
{
	GrafPtr oldport;

	GetPort(&oldport);
	SetPort(wind);
	InvalRect(&wind->portRect);
	SetPort(oldport);
}

static void activatewind(WindowPtr wind, short activate)
{
#pragma unused(wind, activate)
}

static void doeventloop(void)
{
	Boolean isourevent;
	EventRecord mainevent;

	do {
		isourevent = WaitNextEvent(everyEvent, &mainevent, 45, nil);
		if (isourevent) {
			switch (mainevent.what) {
			case mouseDown:
				mouseclick(&mainevent);
				break;
			case keyDown:
			case autoKey: 
				keypress(&mainevent);
				break;
			case updateEvt:
				updatewind((WindowPtr)mainevent.message);
				break;
			case activateEvt:
				activatewind((WindowPtr)mainevent.message,
								(mainevent.modifiers & activeFlag) != 0);
				break;
			}
		}
	} while (!gQuitFlag);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\common\mac\utils\QD app\debug.h ===
/*
	debug.h

	Change history (most recent first):

	Date		By		Comments
	----		--		--------

	02-13-2000	SF		Added new routines, tweaked some old routine names 
	02-09-2000	SF		Added definitions for the font-drawing code
	11-16-1999	SF		DEBUGGER & SYSDEBUGSTR abstracted

*/

#include <MacTypes.h>
#include <stdarg.h>

/* Examples of debugging macro usage:

	DBUG();
		Drops into MacsBug with a user break, and no message.
	DBUGSTR("This is a message\n");
		Drops into MacsBug and prints the literal C string.
	DBUGPRINTF(("Max count = %d, address = 0x%X\n", max, addr));
		Drops into MacsBug and prints the printf-style formatted C string,
		such as "Max count = 25, address = 0x259A0E".
		Note that the formatted string and numeric arguments have to be
		enclosed in an extra set of parentheses in order to hide the
		variable number of arguments from the macro preprocessor.
		Currently, the %c, %u, %d, %x, %X, %f, and %s data types are implemented.
	DBUGIF(x != 7);
		Drops into MacsBug with a user break (no message) if the
		condition is true.
	DBUGSTRIF(handle == nil, "We got a bad handle!\n");
		Drops into MacsBug if the condition is true and prints the literal C string.
	DBUGPRINTFIF(freenodes < 10, ("Node count = %d, header at 0x%x\n", freenodes, hdraddr));
		Drops into MacsBug if the condition is true and prints the printf-style
		formatted C string, such as "Node count = 7, header at 0x8B207C".
		Note that the formatted string and numeric arguments have to be
		enclosed in an extra set of parentheses in order to hide the
		variable number of arguments from the macro preprocessor.
		Currently, the %c, %u, %d, %x, %X, %f, and %s data types are implemented.
	DBUGASSERT(x >= 0);
		Drops into MacsBug if the asserted condition is false, printing a message
		that lists the failed assertion condition and the file name and line
		number of the ASSERT statement, such as:
		"ASSERT(x >= 0) failed: 'main.c' line 324"

	// These are the 'drawing directly to the screen' equivalents
	_RAWSTR("This is a message\n");
		Draws the literal C string directly to the screen.  It doesn't invoke MacsBug.
	_RAWPRINTF(("Max count = %d, address = 0x%X\n", max, addr));
		Draws the printf-style formatted C string directly to the screen,
		such as "Max count = 25, address = 0x259A0E".  It doesn't invoke MacsBug.
		Note that the formatted string and numeric arguments have to be
		enclosed in an extra set of parentheses in order to hide the
		variable number of arguments from the macro preprocessor.
		Currently, the %c, %u, %d, %x, %X, %f, and %s data types are implemented.
	_RAWSTRIF(handle == nil, "We got a bad handle (it was nil)!\n");
		If the condition is true, it draws the literal C string directly to the screen.
		It doesn't invoke MacsBug.
	_RAWPRINTFIF(freenodes < 10, ("Node count = %d, header at 0x%x\n", freenodes, hdraddr));
		If the condition is true, it draws the printf-style formatted C string directly
		to the screen, such as "Node count = 7, header at 0x8B207C".  It doesn't invoke
		MacsBug.  Note that the formatted string and numeric arguments have to be
		enclosed in an extra set of parentheses in order to hide the
		variable number of arguments from the macro preprocessor.
		Currently, the %c, %u, %d, %x, %X, %f, and %s data types are implemented.
	_RAWASSERT(x >= 0);
		If the asserted condition is false, it prints a message directly to the screen
		that lists the failed assertion condition and the file name and line
		number of the ASSERT statement, such as:
		"ASSERT(x >= 0) failed: 'main.c' line 324"  It doesn't invoke MacsBug.
*/


#if DEBUG_BUILD	// All the macros are enabled and generate code for debug builds

#define _RAWDRAW	0			// Set to 1 for raw screen printfs, 0 to suppress

#define DEBUGGER	Debugger	// Debugger for apps, SysDebug for drivers
#define DEBUGSTR	DebugStr	// DebugStr for regular apps, SysDebugStr for drivers

#define DBUG()						\
			DEBUGGER()
#define DBUGSTR(str)				\
			DEBUGSTR("\p" str)
#define DBUGPRINTF(parenargs)		\
			DEBUGSTR(dbugfmttopstr parenargs)
#define DBUGIF(cond)				\
			if (cond)				\
				DEBUGGER()
#define DBUGSTRIF(cond, str)		\
			if (cond)				\
				DEBUGSTR("\p" str)
#define DBUGPRINTFIF(cond, parenargs)	\
			if (cond)				\
				DEBUGSTR(dbugfmttopstr parenargs)

/* The following two macros are utilities to do argument-to-string conversion. */
#define _QUOTE(_x)					#_x
#define _MAKESTR(_x)				_QUOTE(_x)

/* The DBUGASSERT macro tells us what file and line the assertion failed at. */
#define DBUGASSERT(cond)			\
			if (!(cond))			\
				DEBUGSTR("\pASSERT(" #cond ") failed: '" __FILE__	\
							"' line " _MAKESTR(__LINE__))

#if _RAWDRAW

#define _RAWSTR(str)				\
			dbgdrawstr(str)
#define _RAWPRINTF(parenargs)		\
			dbgdrawstr(dbugfmttostr parenargs)
#define _RAWSTRIF(cond, str)		\
			if (cond)				\
				dbgdrawstr(str)
#define _RAWPRINTFIF(cond, parenargs)	\
			if (cond)				\
				dbgdrawstr(dbugfmttostr parenargs)
#define _RAWASSERT(cond)			\
			if (!(cond))			\
				dbgdrawstr("ASSERT(" #cond ") failed: '" __FILE__	\
							"' line " _MAKESTR(__LINE__) "\n")

#else

#define _RAWSTR(str)
#define _RAWPRINTF(parenargs)
#define _RAWSTRIF(cond, str)
#define _RAWPRINTFIF(cond, parenargs)
#define _RAWASSERT(cond)				

#endif

//=====================================================================================================
//
// Routines exported from debug.c (see that file for full descriptions)
//
//=====================================================================================================

extern char *dbugfmttostr(const char *fmt, ...);
extern UInt8 *dbugfmttopstr(const char *fmt, ...);
extern int dbugsprintf(char *dest, const char *fmt, ...);
extern int dbugvsprintf(char *dest, const char *fmt, va_list args);
extern void dbgdrawstr(char *str);

// The following are utility routines used by dbugsprintf() to format different types
//	of data values.  Most of the time you won't need to use them directly, but they're
//	listed here for completeness.  Consult the code in debug.c for sprintf() for
//	examples of how to use them.
extern int int32todecfmtstr(SInt32 s32val, UInt8 *dest, int fieldwidth, int flags);
extern int uint32tohexfmtstr(UInt32 u32val,  UInt8 *dest, int fieldwidth, int flags);
extern int float64todecfmtstr(Float64 f64val, UInt8 *dest, int fieldwidth,
								int precision, int flags);
extern int strtofmtstr(UInt8 *src, UInt8 *dest, int fieldwidth, int flags);

// Numeric & string conversion flags (used if you call the 'XtoYfmtstr' routines directly)
enum {
	DONTTERMINATE = 1,	// Don't null-terminate the string if this flag is set
	UNSIGNED_F = 2,		// Force an unsigned number conversion (other sign options are ignored)
	PLUSSIGN_F = 4,		// For signed numbers >= 0, force a '+' in the sign position
	SPACESIGN_F = 8,	// For signed numbers >= 0, force a space in the sign position
	LEFTALIGN_F = 16,	// Left-justify the result in the destination field (overrides zero fill)
	ZEROFILL_F = 32,	// Use leading zeros for padding to a field width
	LOWERCASE_F = 64	// Use lower case hex digits: a-f instead of A-F
};


#else	// All the macros are disabled and don't generate any code for release builds


#define DBUG()						
#define DBUGSTR(str)				
#define DBUGPRINTF(parenargs)		
#define DBUGIF(cond)				
#define DBUGSTRIF(cond, str)		
#define DBUGPRINTFIF(cond, parenargs)	
#define DBUGASSERT(cond)				
#define _RAWDRAW	0	// Don't do raw drawing if we're not doing a debug build
#define _RAWSTR(str)
#define _RAWPRINTF(parenargs)
#define _RAWSTRIF(cond, str)
#define _RAWPRINTFIF(cond, parenargs)
#define _RAWASSERT(cond)				

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\common\nv10\inc\nv10ppm.h ===
#ifndef _NV10PPM_H_
#define _NV10PPM_H_

 /***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-1997 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-1997  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

//
// This is a portion of the chip REF file used for direct access to the 
// device performance monitor engine.
//

#define NV_PPM                                0x0000AFFF:0x0000A000 /* RW--D */
#define NV_PPM_NV_TRIG0_SEL                              0x0000A400 /* RW-4R */
#define NV_PPM_NV_TRIG0_SEL_SEL0                                7:0 /* RWXUF */
#define NV_PPM_NV_TRIG0_SEL_SEL1                               15:8 /* RWXUF */
#define NV_PPM_NV_TRIG0_SEL_SEL2                              23:16 /* RWXUF */
#define NV_PPM_NV_TRIG0_SEL_SEL3                              31:24 /* RWXUF */
#define NV_PPM_NV_TRIG0_OP                               0x0000A404 /* RW-4R */
#define NV_PPM_NV_TRIG0_OP_FUNC                                15:0 /* RWXUF */
#define NV_PPM_NV_TRIG0_OP_DSEL0                              16:16 /* RWXUF */
#define NV_PPM_NV_TRIG0_OP_DSEL1                              17:17 /* RWXUF */
#define NV_PPM_NV_TRIG1_SEL                              0x0000A408 /* RW-4R */
#define NV_PPM_NV_TRIG1_SEL_SEL0                                7:0 /* RWXUF */
#define NV_PPM_NV_TRIG1_SEL_SEL1                               15:8 /* RWXUF */
#define NV_PPM_NV_TRIG1_SEL_SEL2                              23:16 /* RWXUF */
#define NV_PPM_NV_TRIG1_SEL_SEL3                              31:24 /* RWXUF */
#define NV_PPM_NV_TRIG1_OP                               0x0000A40C /* RW-4R */
#define NV_PPM_NV_TRIG1_OP_FUNC                                15:0 /* RWXUF */
#define NV_PPM_NV_TRIG1_OP_DSEL0                              16:16 /* RWXUF */
#define NV_PPM_NV_TRIG1_OP_DSEL1                              17:17 /* RWXUF */
#define NV_PPM_NV_EVENT_SEL                              0x0000A410 /* RW-4R */
#define NV_PPM_NV_EVENT_SEL_SEL0                                7:0 /* RWXUF */
#define NV_PPM_NV_EVENT_SEL_SEL1                               15:8 /* RWXUF */
#define NV_PPM_NV_EVENT_SEL_SEL2                              23:16 /* RWXUF */
#define NV_PPM_NV_EVENT_SEL_SEL3                              31:24 /* RWXUF */
#define NV_PPM_NV_EVENT_OP                               0x0000A414 /* RW-4R */
#define NV_PPM_NV_EVENT_OP_FUNC                                15:0 /* RWXUF */
#define NV_PPM_NV_EVENT_OP_DSEL0                              16:16 /* RWXUF */
#define NV_PPM_NV_EVENT_OP_DSEL1                              17:17 /* RWXUF */
#define NV_PPM_NV_SAMPLE_SEL                             0x0000A418 /* RW-4R */
#define NV_PPM_NV_SAMPLE_SEL_SEL0                               7:0 /* RWXUF */
#define NV_PPM_NV_SAMPLE_SEL_SEL1                              15:8 /* RWXUF */
#define NV_PPM_NV_SAMPLE_SEL_SEL2                             23:16 /* RWXUF */
#define NV_PPM_NV_SAMPLE_SEL_SEL3                             31:24 /* RWXUF */
#define NV_PPM_NV_SAMPLE_OP                              0x0000A41C /* RW-4R */
#define NV_PPM_NV_SAMPLE_OP_FUNC                               15:0 /* RWXUF */
#define NV_PPM_NV_SAMPLE_OP_DSEL0                             16:16 /* RWXUF */
#define NV_PPM_NV_SAMPLE_OP_DSEL1                             17:17 /* RWXUF */
#define NV_PPM_NV_SETFLAG_SEL                            0x0000A420 /* RW-4R */
#define NV_PPM_NV_SETFLAG_SEL_SEL0                              7:0 /* RWXUF */
#define NV_PPM_NV_SETFLAG_SEL_SEL1                             15:8 /* RWXUF */
#define NV_PPM_NV_SETFLAG_SEL_SEL2                            23:16 /* RWXUF */
#define NV_PPM_NV_SETFLAG_SEL_SEL3                            31:24 /* RWXUF */
#define NV_PPM_NV_SETFLAG_OP                             0x0000A424 /* RW-4R */
#define NV_PPM_NV_SETFLAG_OP_FUNC                              15:0 /* RWXUF */
#define NV_PPM_NV_SETFLAG_OP_DSEL0                            16:16 /* RWXUF */
#define NV_PPM_NV_SETFLAG_OP_DSEL1                            17:17 /* RWXUF */
#define NV_PPM_NV_CLRFLAG_SEL                            0x0000A428 /* RW-4R */
#define NV_PPM_NV_CLRFLAG_SEL_SEL0                              7:0 /* RWXUF */
#define NV_PPM_NV_CLRFLAG_SEL_SEL1                             15:8 /* RWXUF */
#define NV_PPM_NV_CLRFLAG_SEL_SEL2                            23:16 /* RWXUF */
#define NV_PPM_NV_CLRFLAG_SEL_SEL3                            31:24 /* RWXUF */
#define NV_PPM_NV_CLRFLAG_OP                             0x0000A42C /* RW-4R */
#define NV_PPM_NV_CLRFLAG_OP_FUNC                              15:0 /* RWXUF */
#define NV_PPM_NV_CLRFLAG_OP_DSEL0                            16:16 /* RWXUF */
#define NV_PPM_NV_CLRFLAG_OP_DSEL1                            17:17 /* RWXUF */
#define NV_PPM_NV_ELAPSED_0                              0x0000A600 /* RR-4R */
#define NV_PPM_NV_ELAPSED_0_VAL                                31:0 /* RR-UF */
#define NV_PPM_NV_ELAPSED_1                              0x0000A604 /* RR-4R */
#define NV_PPM_NV_ELAPSED_1_VAL                                 7:0 /* RR-UF */
#define NV_PPM_NV_CYCLECNT_0                             0x0000A608 /* RR-4R */
#define NV_PPM_NV_CYCLECNT_0_VAL                               31:0 /* RR-UF */
#define NV_PPM_NV_CYCLECNT_1                             0x0000A60C /* RR-4R */
#define NV_PPM_NV_CYCLECNT_1_VAL                                7:0 /* RR-UF */
#define NV_PPM_NV_EVENTCNT_0                             0x0000A610 /* RR-4R */
#define NV_PPM_NV_EVENTCNT_0_VAL                               31:0 /* RR-UF */
#define NV_PPM_NV_EVENTCNT_1                             0x0000A614 /* RR-4R */
#define NV_PPM_NV_EVENTCNT_1_VAL                                7:0 /* RR-UF */
#define NV_PPM_NV_THRESHCNT_0                            0x0000A618 /* RR-4R */
#define NV_PPM_NV_THRESHCNT_0_VAL                              31:0 /* RR-UF */
#define NV_PPM_NV_THRESHCNT_1                            0x0000A61C /* RR-4R */
#define NV_PPM_NV_THRESHCNT_1_VAL                               7:0 /* RR-UF */
#define NV_PPM_NV_TRIGGERCNT                             0x0000A620 /* RW-4R */
#define NV_PPM_NV_TRIGGERCNT_VAL                               31:0 /* RWXUF */
#define NV_PPM_NV_SAMPLECNT                              0x0000A624 /* RW-4R */
#define NV_PPM_NV_SAMPLECNT_VAL                                31:0 /* RWXUF */
#define NV_PPM_NV_THRESHOLD_0                            0x0000A628 /* RW-4R */
#define NV_PPM_NV_THRESHOLD_0_VAL                              31:0 /* RWXUF */
#define NV_PPM_NV_THRESHOLD_1                            0x0000A62C /* RW-4R */
#define NV_PPM_NV_THRESHOLD_1_VAL                               7:0 /* RWXUF */
#define NV_PPM_NV_WATCH0                                 0x0000A430 /* RR-4R */
#define NV_PPM_NV_WATCH0_GR_XF2PM_XF_IDLE                      0: 0 /* RR-UF */
#define NV_PPM_NV_WATCH0_GR_XF2PM_XF2VTX_DATA_VALID            1: 1 /* RR-UF */
#define NV_PPM_NV_WATCH0_GR_XF2PM_XF2IDX_BUSY                  2: 2 /* RR-UF */
#define NV_PPM_NV_WATCH0_GR_VTX2PM_VTXPRIMIDLE                 3: 3 /* RR-UF */
#define NV_PPM_NV_WATCH0_GR_VTX2PM_VTX2STP_PRIMVALID           4: 4 /* RR-UF */
#define NV_PPM_NV_WATCH0_GR_VTX2PM_VTX2IDX_BUSY                5: 5 /* RR-UF */
#define NV_PPM_NV_WATCH0_GR_VTX2PM_VTX2COL_VALID               6: 6 /* RR-UF */
#define NV_PPM_NV_WATCH0_GR_TEX2PM_TP1_REPLACER_STALL          7: 7 /* RR-UF */
#define NV_PPM_NV_WATCH0_GR_TEX2PM_TP1_MP_QUEUE_STALL          8: 8 /* RR-UF */
#define NV_PPM_NV_WATCH0_GR_TEX2PM_TP1_COALESCER_STALL         9: 9 /* RR-UF */
#define NV_PPM_NV_WATCH0_GR_TEX2PM_TP0_REPLACER_STALL         10:10 /* RR-UF */
#define NV_PPM_NV_WATCH0_GR_TEX2PM_TP0_MP_QUEUE_STALL         11:11 /* RR-UF */
#define NV_PPM_NV_WATCH0_GR_TEX2PM_TP0_COALESCER_STALL        12:12 /* RR-UF */
#define NV_PPM_NV_WATCH0_GR_TEX2PM_TEX2MATH_TP1_BUSY          13:13 /* RR-UF */
#define NV_PPM_NV_WATCH0_GR_TEX2PM_TEX2MATH_TP0_BUSY          14:14 /* RR-UF */
#define NV_PPM_NV_WATCH0_GR_TEX2PM_TEX2LIT_REQ                15:15 /* RR-UF */
#define NV_PPM_NV_WATCH0_GR_TEX2PM_TEX2LIT_REGLD              16:16 /* RR-UF */
#define NV_PPM_NV_WATCH0_GR_TEX2PM_SNAP_PULSE                 17:17 /* RR-UF */
#define NV_PPM_NV_WATCH0_GR_TEX2PM_RBFR_FULL_STALL            18:18 /* RR-UF */
#define NV_PPM_NV_WATCH0_GR_TEX2PM_CACHE_IDLE                 19:19 /* RR-UF */
#define NV_PPM_NV_WATCH0_GR_TEX2PM_C2DMA_DV                   20:20 /* RR-UF */
#define NV_PPM_NV_WATCH0_GR_STP2PM_VTX_OFFSCREEN              21:21 /* RR-UF */
#define NV_PPM_NV_WATCH0_GR_STP2PM_STP_IDLE                   22:22 /* RR-UF */
#define NV_PPM_NV_WATCH0_GR_STP2PM_STP2VTX_BUSY               23:23 /* RR-UF */
#define NV_PPM_NV_WATCH0_GR_STP2PM_STP2RSTR_VALID             24:24 /* RR-UF */
#define NV_PPM_NV_WATCH0_GR_STP2PM_STP2RSTR_DO_SWATHS         25:25 /* RR-UF */
#define NV_PPM_NV_WATCH0_GR_STP2PM_STP2CLP_VALID              26:26 /* RR-UF */
#define NV_PPM_NV_WATCH0_GR_STP2PM_START_PRIM                 27:27 /* RR-UF */
#define NV_PPM_NV_WATCH0_GR_STP2PM_POLYMODE                   28:28 /* RR-UF */
#define NV_PPM_NV_WATCH0_GR_STP2PM_DUAL_TEXTURE               29:29 /* RR-UF */
#define NV_PPM_NV_WATCH0_GR_STP2PM_DO_POINT                   30:30 /* RR-UF */
#define NV_PPM_NV_WATCH0_GR_STP2PM_DO_LINE                    31:31 /* RR-UF */
#define NV_PPM_NV_WATCH1                                 0x0000A434 /* RR-4R */
#define NV_PPM_NV_WATCH1_GR_STP2PM_CYL_WRAP                    0: 0 /* RR-UF */
#define NV_PPM_NV_WATCH1_GR_STP2PM_CULL_SMALL                  1: 1 /* RR-UF */
#define NV_PPM_NV_WATCH1_GR_STP2PM_CULL_NEAR                   2: 2 /* RR-UF */
#define NV_PPM_NV_WATCH1_GR_STP2PM_CULL_FRONT                  3: 3 /* RR-UF */
#define NV_PPM_NV_WATCH1_GR_STP2PM_CULL_FAR                    4: 4 /* RR-UF */
#define NV_PPM_NV_WATCH1_GR_STP2PM_CULL_ENA                    5: 5 /* RR-UF */
#define NV_PPM_NV_WATCH1_GR_STP2PM_CULL_BBOX                   6: 6 /* RR-UF */
#define NV_PPM_NV_WATCH1_GR_STP2PM_CULL_BACK                   7: 7 /* RR-UF */
#define NV_PPM_NV_WATCH1_GR_RSTR2PM_SEARCH_MODE                8: 8 /* RR-UF */
#define NV_PPM_NV_WATCH1_GR_RSTR2PM_RSTR_EOPRIM                9: 9 /* RR-UF */
#define NV_PPM_NV_WATCH1_GR_RSTR2PM_RSTR2PIPE_XY_VALID        10:10 /* RR-UF */
#define NV_PPM_NV_WATCH1_GR_RSTR2PM_RSTR2PIPE_EOPOLY          11:11 /* RR-UF */
#define NV_PPM_NV_WATCH1_GR_RSTR2PM_RSTR2MATH_NEWLINE         12:12 /* RR-UF */
#define NV_PPM_NV_WATCH1_GR_RSTR2PM_RSTR2MATH_ABC_VALID       13:13 /* RR-UF */
#define NV_PPM_NV_WATCH1_GR_RSTR2PM_PIXCNT_0                  14:14 /* RR-UF */
#define NV_PPM_NV_WATCH1_GR_RSTR2PM_PIXCNT_1                  15:15 /* RR-UF */
#define NV_PPM_NV_WATCH1_GR_RSTR2PM_PIXCNT_2                  16:16 /* RR-UF */
#define NV_PPM_NV_WATCH1_GR_RSTR2PM_FINE_STALL                17:17 /* RR-UF */
#define NV_PPM_NV_WATCH1_GR_RSTR2PM_FINE_IDLE                 18:18 /* RR-UF */
#define NV_PPM_NV_WATCH1_GR_RSTR2PM_FINE_EDGE_EVAL            19:19 /* RR-UF */
#define NV_PPM_NV_WATCH1_GR_RSTR2PM_FINE_ALIASED              20:20 /* RR-UF */
#define NV_PPM_NV_WATCH1_GR_RSTR2PM_COARSE_VALID              21:21 /* RR-UF */
#define NV_PPM_NV_WATCH1_GR_RSTR2PM_COARSE_STALL              22:22 /* RR-UF */
#define NV_PPM_NV_WATCH1_GR_RSTR2PM_COARSE_IDLE               23:23 /* RR-UF */
#define NV_PPM_NV_WATCH1_GR_ROP2PM_ZWRITE                     24:24 /* RR-UF */
#define NV_PPM_NV_WATCH1_GR_ROP2PM_ZPARTIAL                   25:25 /* RR-UF */
#define NV_PPM_NV_WATCH1_GR_ROP2PM_WAITMEMWR                  26:26 /* RR-UF */
#define NV_PPM_NV_WATCH1_GR_ROP2PM_WAITMEMRD                  27:27 /* RR-UF */
#define NV_PPM_NV_WATCH1_GR_ROP2PM_WAIT_BUF                   28:28 /* RR-UF */
#define NV_PPM_NV_WATCH1_GR_ROP2PM_ROP_IDLE                   29:29 /* RR-UF */
#define NV_PPM_NV_WATCH1_GR_ROP2PM_ROP2FB_REQ                 30:30 /* RR-UF */
#define NV_PPM_NV_WATCH1_GR_ROP2PM_ROP2FB_RD                  31:31 /* RR-UF */
#define NV_PPM_NV_WATCH2                                 0x0000A438 /* RR-4R */
#define NV_PPM_NV_WATCH2_GR_ROP2PM_ROP2FB_ALOM                 0: 0 /* RR-UF */
#define NV_PPM_NV_WATCH2_GR_ROP2PM_CWRITE                      1: 1 /* RR-UF */
#define NV_PPM_NV_WATCH2_GR_R2D2PM_PRE_OUTPUT_BUSY             2: 2 /* RR-UF */
#define NV_PPM_NV_WATCH2_GR_R2D2PM_R2D2MATH_IM_NEWLINE         3: 3 /* RR-UF */
#define NV_PPM_NV_WATCH2_GR_R2D2PM_RSTR2D_IDLE                 4: 4 /* RR-UF */
#define NV_PPM_NV_WATCH2_GR_R2D2PM_R2D2FE_RSTR2D_BUSY          5: 5 /* RR-UF */
#define NV_PPM_NV_WATCH2_GR_R2D2PM_MATH_CACHE_BUSY             6: 6 /* RR-UF */
#define NV_PPM_NV_WATCH2_GR_R2D2PM_R2D2PRE_OUTPUT_REQ          7: 7 /* RR-UF */
#define NV_PPM_NV_WATCH2_GR_R2D2PM_R2D2PRE_OUTPUT_NOP          8: 8 /* RR-UF */
#define NV_PPM_NV_WATCH2_GR_R2D2PM_R2D2MATH_IM_RIGHT_DV        9: 9 /* RR-UF */
#define NV_PPM_NV_WATCH2_GR_R2D2PM_R2D2MATH_IM_LEFT_DV        10:10 /* RR-UF */
#define NV_PPM_NV_WATCH2_GR_R2D2PM_FE_REQ                     11:11 /* RR-UF */
#define NV_PPM_NV_WATCH2_GR_PRE2PM_PREROP_IDLE                12:12 /* RR-UF */
#define NV_PPM_NV_WATCH2_GR_PRE2PM_PRE2ROP_ROP_REQ            13:13 /* RR-UF */
#define NV_PPM_NV_WATCH2_GR_PRE2PM_PRE2ROP_POSTING_BUFFER     14:14 /* RR-UF */
#define NV_PPM_NV_WATCH2_GR_PRE2PM_PRE2R2D_OUTPUT_BUSY        15:15 /* RR-UF */
#define NV_PPM_NV_WATCH2_GR_PRE2PM_PRE2PIPE_BUSY              16:16 /* RR-UF */
#define NV_PPM_NV_WATCH2_GR_PRE2PM_PRE2LIT_BUSY               17:17 /* RR-UF */
#define NV_PPM_NV_WATCH2_GR_PRE2PM_COALESCE                   18:18 /* RR-UF */
#define NV_PPM_NV_WATCH2_GR_PRE2PM_ALL3D_REQ                  19:19 /* RR-UF */
#define NV_PPM_NV_WATCH2_GR_PIPE2PM_PIPE_XY_RDY               20:20 /* RR-UF */
#define NV_PPM_NV_WATCH2_GR_PIPE2PM_PIPE_IDLE                 21:21 /* RR-UF */
#define NV_PPM_NV_WATCH2_GR_MATH2PM_MATH2TEX_TP1_REQ          22:22 /* RR-UF */
#define NV_PPM_NV_WATCH2_GR_MATH2PM_MATH2TEX_TP0_REQ          23:23 /* RR-UF */
#define NV_PPM_NV_WATCH2_GR_MATH2PM_MATH2TEX_MAGNIFY          24:24 /* RR-UF */
#define NV_PPM_NV_WATCH2_GR_MATH2PM_MATH2TEX_ANISO_SAMPLE     25:25 /* RR-UF */
#define NV_PPM_NV_WATCH2_GR_MATH2PM_MATH2RSTR_RDY             26:26 /* RR-UF */
#define NV_PPM_NV_WATCH2_GR_MATH2PM_MATH2RSTR_ABC_RDY         27:27 /* RR-UF */
#define NV_PPM_NV_WATCH2_GR_LIT2PM_RECIRC_CYCLE               28:28 /* RR-UF */
#define NV_PPM_NV_WATCH2_GR_LIT2PM_LIT2TEX_BUSY               29:29 /* RR-UF */
#define NV_PPM_NV_WATCH2_GR_LIT2PM_LIT2PRE_REQ                30:30 /* RR-UF */
#define NV_PPM_NV_WATCH2_GR_LIT2PM_LIT2COL_BUSY               31:31 /* RR-UF */
#define NV_PPM_NV_WATCH3                                 0x0000A43C /* RR-4R */
#define NV_PPM_NV_WATCH3_GR_IDX2PM_THREADSTALLED               0: 0 /* RR-UF */
#define NV_PPM_NV_WATCH3_GR_IDX2PM_PTEBUSY                     1: 1 /* RR-UF */
#define NV_PPM_NV_WATCH3_GR_IDX2PM_INTALIGN                    2: 2 /* RR-UF */
#define NV_PPM_NV_WATCH3_GR_IDX2PM_IDXFRONTIDLE                3: 3 /* RR-UF */
#define NV_PPM_NV_WATCH3_GR_IDX2PM_IDX2XF_VALID_0              4: 4 /* RR-UF */
#define NV_PPM_NV_WATCH3_GR_IDX2PM_IDX2XF_VALID_1              5: 5 /* RR-UF */
#define NV_PPM_NV_WATCH3_GR_IDX2PM_IDX2VTX_VALID               6: 6 /* RR-UF */
#define NV_PPM_NV_WATCH3_GR_IDX2PM_IDX2PMI_VALID               7: 7 /* RR-UF */
#define NV_PPM_NV_WATCH3_GR_IDX2PM_IDX2FBI_VALID               8: 8 /* RR-UF */
#define NV_PPM_NV_WATCH3_GR_IDX2PM_IDX2DEC_BUSY                9: 9 /* RR-UF */
#define NV_PPM_NV_WATCH3_GR_IDX2PM_COMPOVFL                   10:10 /* RR-UF */
#define NV_PPM_NV_WATCH3_GR_IDX2PM_CACHETHRASH                11:11 /* RR-UF */
#define NV_PPM_NV_WATCH3_GR_FF2PM_FF_GR_RDY                   12:12 /* RR-UF */
#define NV_PPM_NV_WATCH3_GR_FF2PM_FF_GR_B2B                   13:13 /* RR-UF */
#define NV_PPM_NV_WATCH3_GR_FE2PM_NVINTR_GR                   14:14 /* RR-UF */
#define NV_PPM_NV_WATCH3_GR_FE2PM_WAIT_GR_IDLE                15:15 /* RR-UF */
#define NV_PPM_NV_WATCH3_GR_FE2PM_NOP                         16:16 /* RR-UF */
#define NV_PPM_NV_WATCH3_GR_FE2PM_GR_SWITCH                   17:17 /* RR-UF */
#define NV_PPM_NV_WATCH3_GR_FE2PM_GR_IDLE                     18:18 /* RR-UF */
#define NV_PPM_NV_WATCH3_GR_FE2PM_FBI_REQ_BURST               19:19 /* RR-UF */
#define NV_PPM_NV_WATCH3_GR_FE2PM_FBI_REQ                     20:20 /* RR-UF */
#define NV_PPM_NV_WATCH3_GR_FE2PM_FBI_RD                      21:21 /* RR-UF */
#define NV_PPM_NV_WATCH3_GR_FE2PM_FBI_INST                    22:22 /* RR-UF */
#define NV_PPM_NV_WATCH3_GR_FE2PM_CACHE_INVALIDATE            23:23 /* RR-UF */
#define NV_PPM_NV_WATCH3_GR_FBI2PM_FBI2IDX_BUSY               24:24 /* RR-UF */
#define NV_PPM_NV_WATCH3_GR_DMA2PM_DMA2C_DV                   25:25 /* RR-UF */
#define NV_PPM_NV_WATCH3_GR_DMA2PM_DMA2C_ASTALL               26:26 /* RR-UF */
#define NV_PPM_NV_WATCH3_GR_DEC2PM_DEC2IDX_VALID_0            27:27 /* RR-UF */
#define NV_PPM_NV_WATCH3_GR_DEC2PM_DEC2IDX_VALID_1            28:28 /* RR-UF */
#define NV_PPM_NV_WATCH3_GR_COL2PM_SPECULAR_RECIRC            29:29 /* RR-UF */
#define NV_PPM_NV_WATCH3_GR_COL2PM_COLOR_IDLE                 30:30 /* RR-UF */
#define NV_PPM_NV_WATCH3_GR_COL2PM_COL2XYPIPE_BUSY            31:31 /* RR-UF */
#define NV_PPM_NV_WATCH4                                 0x0000A630 /* RR-4R */
#define NV_PPM_NV_WATCH4_GR_COL2PM_COL2VTX_BUSY                0: 0 /* RR-UF */
#define NV_PPM_NV_WATCH4_GR_COL2PM_COL2LIT_REQ                 1: 1 /* RR-UF */
#define NV_PPM_NV_WATCH4_GR_COL2PM_COL2FCOMB_REQ               2: 2 /* RR-UF */
#define NV_PPM_NV_WATCH4_GR_COL2PM_COL2CLP_BUSY                3: 3 /* RR-UF */
#define NV_PPM_NV_WATCH4_GR_CLP2PM_CLP2STP_BUSY                4: 4 /* RR-UF */
#define NV_PPM_NV_WATCH4_TOP_PMI2PM_PMI2IDX_VALID              5: 5 /* RR-UF */
#define NV_PPM_NV_WATCH4_TOP_PMI2PM_PMI2IDX_BUSY               6: 6 /* RR-UF */
#define NV_PPM_NV_WATCH4_TOP_HOST2PM_TIMER_262US               7: 7 /* RR-UF */
#define NV_PPM_NV_WATCH4_TOP_HOST2PM_FF_GR_MDV                 8: 8 /* RR-UF */
#define NV_PPM_NV_WATCH4_TOP_HOST2PM_FF_DHV                    9: 9 /* RR-UF */
#define NV_PPM_NV_WATCH4_TOP_HOST2PM_FF_CHSW                  10:10 /* RR-UF */
#define NV_PPM_NV_WATCH4_TOP_FBI2PM_X_DLY                     11:11 /* RR-UF */
#define NV_PPM_NV_WATCH4_TOP_FBI2PM_S_DLY                     12:12 /* RR-UF */
#define NV_PPM_NV_WATCH4_TOP_FBI2PM_R2W_DLY                   13:13 /* RR-UF */
#define NV_PPM_NV_WATCH4_TOP_FBI2PM_H_DLY                     14:14 /* RR-UF */
#define NV_PPM_NV_WATCH4_TOP_FB2PM_FB2ROP_BUSY                15:15 /* RR-UF */
#define NV_PPM_NV_WATCH4_TOP_FBI2PM_D_DLY                     16:16 /* RR-UF */
#define NV_PPM_NV_WATCH4_TOP_FBI2PM_BC                        17:17 /* RR-UF */
#define NV_PPM_NV_WATCH4_TOP_CRTC2PM_CRTC2DAC_VSYNC2DAC       18:18 /* RR-UF */
#define NV_PPM_CONTROL                                   0x0000A73C /* RW-4R */
#define NV_PPM_CONTROL_OUT_SEL                                  0:0 /* RWXUF */
#define NV_PPM_CONTROL_OUT_SEL_PM                        0x00000000 /* RWI-V */
#define NV_PPM_CONTROL_OUT_SEL_FBIDEBUG                  0x00000001 /* RWI-V */
#define NV_PPM_CONTROL_DRIVE_OUT                                1:1 /* RWXUF */
#define NV_PPM_CONTROL_DRIVE_OUT_NORMAL                  0x00000000 /* RWI-V */
#define NV_PPM_CONTROL_DRIVE_OUT_OBSERVE                 0x00000001 /* RWI-V */
#define NV_PPM_CONTROL_NV_ADDTOEVENT                            2:2 /* RWXUF */
#define NV_PPM_CONTROL_NV_ADDTOEVENT_INCR                0x00000000 /* RWI-V */
#define NV_PPM_CONTROL_NV_ADDTOEVENT_ADDTRIG1            0x00000001 /* RWI-V */
#define NV_PPM_CONTROL_NV_STATE                                 4:3 /* RRIUF */
#define NV_PPM_CONTROL_STATE_IDLE                        0x00000000 /* RWI-V */
#define NV_PPM_CONTROL_STATE_WAIT_TRIG0                  0x00000001 /* RWI-V */
#define NV_PPM_CONTROL_STATE_WAIT_TRIG1                  0x00000002 /* RWI-V */
#define NV_PPM_CONTROL_STATE_CAPTURE                     0x00000003 /* RWI-V */

#endif // _NV10PPM_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\common\nv20\src\vpcompilekelvin.c ===
/*
 * vpcompilekelvin.c
 *
 * Copyright 2000 NVIDIA, Corporation.  All rights reserved.
 *
 * THE INFORMATION CONTAINED HEREIN IS PROPRIETARY AND CONFIDENTIAL TO
 * NVIDIA, CORPORATION.  USE, REPRODUCTION OR DISCLOSURE TO ANY THIRD PARTY
 * IS SUBJECT TO WRITTEN PRE-APPROVAL BY NVIDIA, CORPORATION.
 */

/*
** This file should only be compiled if it's needed.  The normal OpenGL ifdefs:
**
**      #if defined(GL_NV_vertex_program) && __NV_ACCEL>=10
**      #ifdef __GL_USE_OG_INTEL_ASM
**
** and any OpenGL includes like:
**
**      #include "context.h"
**
** can't be used since this is used by D3D as well.
**
*/

#include <stddef.h>

#if defined(IS_OPENGL)
#include "nvassert.h"
#endif

#include "vtxpgmconsts.h"
#include "vtxpgmcomp.h"

#if !defined(FALSE)
#define FALSE 0
#endif

#if !defined(TRUE)
#define TRUE 1
#endif

// Duplicate values so they can be seen by the common code:

#define __GLNV20_TEX_SCALE_FIELD_BITS                4 // 4 bits per field

#define __GLNV20_TEX_SCALE_IDENTITY                  0x0 // no scaling needed (MUST be zero value)
#define __GLNV20_TEX_SCALE_R_65535                   0x1 // scale R by 2^16-1 for 16-bit shadow mapping
#define __GLNV20_TEX_SCALE_R_16777215                0x2 // scale R by 2^24-1 for 24-bit shadow mapping
#define __GLNV20_TEX_SCALE_STR_65535                 0x3 // scale STR by 2^16-1 for 16-bit depth replace
#define __GLNV20_TEX_SCALE_STR_16777215              0x4 // scale STR by 2^24-1 for 24-bit depth replace
#define __GLNV20_NUM_TEX_SCALES                      5
#define __GLNV20_TEX_SCALE_MASK                      ((1 << __GLNV20_TEX_SCALE_FIELD_BITS) - 1)

// End duplicate values

#if defined(IS_OPENGL)

// Definitions so we can include nvTrace.h:

#define CDECLCALL
#define GL_POLYGON 9
typedef int GLenum;

#include "nvTrace.h"

#else // !IS_OPENGL

#define NV_FUN_NAME(X, Y, Z)
#define NV_TRACE_FUNC(A)
#define NV_TRACE_PUSH()
#define NV_TRACE_POP()

#ifdef DEBUG
    #define NV_TRACE(X, Y, Z)           if (dbgLevel & NVDBG_LEVEL_VSHADER_INS) { DPF_PLAIN Z; }
    #define NV_TRACE_COND(X, Y, Z)      Z
    #define NV_TRACE_CODE(X)            X
    #define TPRINTF(X)                  if (dbgLevel & NVDBG_LEVEL_VSHADER_INS) { DPF_PLAIN X; }
#else // !DEBUG
    #define NV_TRACE(X, Y, Z)
    #define NV_TRACE_COND(X, Y, Z)
    #define NV_TRACE_CODE(X)
    #define TPRINTF(X)
#endif // !DEBUG

#endif // !IS_OPENGL

typedef enum ILUop_Enum {
    ILU_NOP = 0x0, ILU_MOV = 0x1, ILU_RCP = 0x2, ILU_RCC = 0x3,
    ILU_RSQ = 0x4, ILU_EXP = 0x5, ILU_LOG = 0x6, ILU_LIT = 0x7,
} ILUop;

typedef enum MACop_Enum {
    MAC_NOP = 0x0, MAC_MOV = 0x1, MAC_MUL = 0x2, MAC_ADD = 0x3,
    MAC_MAD = 0x4, MAC_DP3 = 0x5, MAC_DPH = 0x6, MAC_DP4 = 0x7,
    MAC_DST = 0x8, MAC_MIN = 0x9, MAC_MAX = 0xa, MAC_SLT = 0xb,
    MAC_SGE = 0xc, MAC_ARL = 0xd,
} MACop;

typedef enum MUXVals_Enum {
    IN_MUX_CA = 3, IN_MUX_VA = 2, IN_MUX_RR = 1, IN_MUX_M_ILLEGAL = 0,
    OUT_MUX_OM_ALU = 0, OUT_MUX_OM_ILU = 1,
    OC_SELECT_CONTEXT = 0x000, OC_SELECT_OUTPUT = 0x100,
} MUXVals;

typedef enum WRITEMask_Enum {
    OUT_MASK_X = 8, OUT_MASK_Y = 4, OUT_MASK_Z = 2, OUT_MASK_W = 1,
    OUT_MASK_XYZW = 0xf,
} WRITEMask;

typedef struct SwizzleSrcReg20_Rec {
    unsigned char ne;
    unsigned char xs;
    unsigned char ys;
    unsigned char zs;
    unsigned char ws;
    unsigned char rr;
    unsigned char mx;
} SwizzleSrcReg20;

typedef struct vtxpgmInst_Rec {
    ILUop ilu;
    MACop mac;
    unsigned char ca;
    unsigned char va;
    SwizzleSrcReg20 a;
    SwizzleSrcReg20 b;
    SwizzleSrcReg20 c;
    unsigned char rwm;
    unsigned char rw;
    unsigned char swm;
    unsigned char owm;
    unsigned short oc;
    unsigned char om;
    unsigned char cin;
    unsigned char eos;
} vtxpgmInst;

#define ALU_TEMP 0x40
#define ILU_TEMP 0x00

///////////////////////////////////////////////////////////////////////////////

static void lInitInst(vtxpgmInst *pInst)
{
    char *pCode;
    int ii;

    pCode = (char *) pInst;
    for (ii = 0; ii < sizeof(vtxpgmInst); ii++)
        pCode[ii] = 0;

    // Setting unused inputs to IN_MUX_RR can cause unnecessary stalls, so we now use IN_MUX_VA.

    pInst->a.mx = IN_MUX_VA;
    pInst->b.mx = IN_MUX_VA;
    pInst->c.mx = IN_MUX_VA;
    pInst->oc = 0x1ff;
} // lInitInst

///////////////////////////////////////////////////////////////////////////////

typedef struct vtxpgmTLiveDead_Rec {
    unsigned char v[__GL_NUMBER_OF_TEMPORARY_REGISTERS], tmpReg;
} vtxpgmTLiveDead;

/*
** lDeftMaskedDstReg() - Mark registers set as "dead" prior to this point.
*/

static void lDefMaskedDstReg(VtxProgCompileKelvin *env, vtxpgmTLiveDead *pLive,
                             MaskedDstReg *reg, int IsALU)
{
    unsigned char *LiveDead;
    int mask, lreg, ii, jj, bits;

    lreg = reg->reg;
    if (lreg >= TR_0 && lreg <= TR_11) {

        // Mark any registers set as dead:

        LiveDead = &pLive->v[lreg - TR_0];
        mask = reg->mask;
        *LiveDead &= ~mask;
    } else {
        if (lreg >= VR_TEX0 && lreg <= VR_TEX3) {

            // Potential patch needed:

            ii = lreg - VR_TEX0;
            bits = (env->textureScaling >> (ii*__GLNV20_TEX_SCALE_FIELD_BITS)) &
                   __GLNV20_TEX_SCALE_MASK;
            if (bits) {

                // We need to scale it.  Find a dead scratch register:

                for (jj = __GL_NUMBER_OF_TEMPORARY_REGISTERS - 1; jj >= 0; jj--) {
                    if (!pLive->v[jj]) {
                        pLive->tmpReg = jj | 0x80;
                        if (IsALU)
                            pLive->tmpReg |= ALU_TEMP;
                        // Always use 2 instructions for now.  Could be optimized.
                        env->numExtraInstructions += 2;
                        break;
                    }
                }
                if (!pLive->tmpReg) {
                    assert(!"Can't find a dead temp register");
                }
            }
        }
    }
} // lDefMaskedDstReg

/*
** lRefScalarSrcReg() - Mark referenced registers as "live" prior to this point.
*/

static void lRefScalarSrcReg(vtxpgmTLiveDead *pLive, char mask, ScalarSrcReg *reg)
{
    int lreg;

    lreg = reg->reg.reg;
    if (lreg >= TR_0 && lreg <= TR_11) {
        if (mask) // Any output means we need the input
            pLive->v[lreg - TR_0] |= 1 << (reg->com & 3);
    }
} // lRefScalarSrcReg

/*
** lRefSwizzleSrcReg() - Mark referenced registers as "live" prior to this point.
*/

static void lRefSwizzleSrcReg(vtxpgmTLiveDead *pLive, char mask, SwizzleSrcReg *reg)
{
    unsigned char *LiveDead;
    int lreg;

    lreg = reg->reg.reg;
    if (lreg >= TR_0 && lreg <= TR_11) {
        LiveDead = &pLive->v[lreg - TR_0];
        if (mask & DST_X_BIT)
            *LiveDead |= 1 << (reg->com4 & 3);
        if (mask & DST_Y_BIT)
            *LiveDead |= 1 << ((reg->com4 >> 2) & 3);
        if (mask & DST_Z_BIT)
            *LiveDead |= 1 << ((reg->com4 >> 4) & 3);
        if (mask & DST_W_BIT)
            *LiveDead |= 1 << ((reg->com4 >> 6) & 3);
    }
} // lRefSwizzleSrcReg

/*
** lInitTempLiveDead() - Build live/dead vectors for temp registers.  Needed for hidden
**         texture coordinate scaling used by depth replace, etc.
*/

static void lInitTempLiveDead(VtxProgCompileKelvin *env, ParsedProgram *parsed,
                              int numInstructions)
{
    vtxpgmTLiveDead *pLive;
    Instruction *inst;
    Arl_Instruction *ainst;
    Scalar_Instruction *sinst;
    Vector_Instruction *vinst;
    Bin_Instruction *binst;
    Tri_Instruction *tinst;
    int ii, lop, pc;

    env->tLiveDead = (struct vtxpgmTLiveDead_Rec *) NULL;
    env->numExtraInstructions = 0;
    if (!env->textureScaling) {
        return;
    }

    pLive = env->tLiveDead = (vtxpgmTLiveDead *)
                     (env->malloc (env->mallocArg, sizeof(vtxpgmTLiveDead)*(numInstructions + 1)));
    for (pc = numInstructions; pc >= 0; pc--) {
        for (ii = __GL_NUMBER_OF_TEMPORARY_REGISTERS - 1; ii >= 0; ii--)
            pLive->v[ii] = 0;
        pLive->tmpReg = 0;
        pLive++;
    }

    // Walk the code backwards marking live temp registers:

    for (pc = numInstructions - 1; pc >= 0; pc--) {
        pLive = &env->tLiveDead[pc];
        *pLive = env->tLiveDead[pc + 1];
        pLive->tmpReg = 0;
        inst = &parsed->firstInstruction[pc];
        lop = inst->end_op.opcode;
        switch (lop) {

        // ARL op:

        case OP_ARL:
            ainst = (Arl_Instruction *) inst;
            lRefScalarSrcReg(pLive, DST_X_BIT, &ainst->src);
            break;

        // SCALAR ops:

        case OP_EXP:
        case OP_LOG:
#if defined(NV_INTERNAL_OPCODES)
        case OP_RCC:
#endif // NV_INTERNAL_OPCODES
        case OP_RCP:
        case OP_RSQ:
            sinst = (Scalar_Instruction *) inst;
            lDefMaskedDstReg(env, pLive, &sinst->dst, 0);
            lRefScalarSrcReg(pLive, sinst->dst.mask, &sinst->src);
            break;

        // VECTOR ops:

        case OP_LIT:
            vinst = (Vector_Instruction *) inst;
            lDefMaskedDstReg(env, pLive, &vinst->dst, 0);
            lRefSwizzleSrcReg(pLive, DST_XYW_BITS, &vinst->src);
            break;

#if defined(NV_INTERNAL_OPCODES)
        case OP_IMV:
            vinst = (Vector_Instruction *) inst;
            lDefMaskedDstReg(env, pLive, &vinst->dst, 0);
            lRefSwizzleSrcReg(pLive, vinst->dst.mask, &vinst->src);
            break;
#endif // NV_INTERNAL_OPCODES
        case OP_MOV:
            vinst = (Vector_Instruction *) inst;
            lDefMaskedDstReg(env, pLive, &vinst->dst, 1);
            lRefSwizzleSrcReg(pLive, vinst->dst.mask, &vinst->src);
            break;

        // BIN ops:

        case OP_ADD:
        case OP_MAX:
        case OP_MIN:
        case OP_MUL:
        case OP_SGE:
        case OP_SLT:
            binst = (Bin_Instruction *) inst;
            lDefMaskedDstReg(env, pLive, &binst->dst, 1);
            lRefSwizzleSrcReg(pLive, binst->dst.mask, &binst->srcA);
            lRefSwizzleSrcReg(pLive, binst->dst.mask, &binst->srcB);
            break;

        case OP_DP3:
            binst = (Bin_Instruction *) inst;
            lDefMaskedDstReg(env, pLive, &binst->dst, 1);
            lRefSwizzleSrcReg(pLive, DST_XYZ_BITS, &binst->srcA);
            lRefSwizzleSrcReg(pLive, DST_XYZ_BITS, &binst->srcB);
            break;

        case OP_DP4:
            binst = (Bin_Instruction *) inst;
            lDefMaskedDstReg(env, pLive, &binst->dst, 1);
            lRefSwizzleSrcReg(pLive, DST_XYZW_BITS, &binst->srcA);
            lRefSwizzleSrcReg(pLive, DST_XYZW_BITS, &binst->srcB);
            break;

#if defined(NV_INTERNAL_OPCODES)
        case OP_DPH:
            binst = (Bin_Instruction *) inst;
            lDefMaskedDstReg(env, pLive, &binst->dst, 1);
            lRefSwizzleSrcReg(pLive, DST_XYZ_BITS, &binst->srcA);
            lRefSwizzleSrcReg(pLive, DST_XYZW_BITS, &binst->srcB);
            break;
#endif // NV_INTERNAL_OPCODES

        case OP_DST:
            binst = (Bin_Instruction *) inst;
            lDefMaskedDstReg(env, pLive, &binst->dst, 1);
            lRefSwizzleSrcReg(pLive, DST_Y_BIT | DST_Z_BIT, &binst->srcA);
            lRefSwizzleSrcReg(pLive, DST_Y_BIT | DST_W_BIT, &binst->srcB);
            break;

       // TRIops:

        case OP_MAD:
            tinst = (Tri_Instruction *) inst;
            lDefMaskedDstReg(env, pLive, &tinst->dst, 1);
            lRefSwizzleSrcReg(pLive, tinst->dst.mask, &tinst->srcA);
            lRefSwizzleSrcReg(pLive, tinst->dst.mask, &tinst->srcB);
            lRefSwizzleSrcReg(pLive, tinst->dst.mask, &tinst->srcC);
            break;

        // NOPops:

        case OP_NOP:
            break;

        // ENDops:

        case OP_END:
            break;

        default:
            break;
        }
    }
} // lInitTempLiveDead

/*
** lDestroyTempLiveDead()
*/

static void lDestroyTempLiveDead(VtxProgCompileKelvin *env)
{
    if (env->tLiveDead) {
        env->free(env->mallocArg, env->tLiveDead);
        env->tLiveDead = NULL;
    }
} // lDestroyTempLiveDead

/*
** lInsertTextureScaling() - Insert the required scaling instructions.
*/

static void lInsertTextureScaling(VtxProgCompileKelvin *env, Instruction *fInsts,
                                  Instruction *tInsts, int fNum, int tNum)
{
#if 000
    const static int swizzles[] = {
        XX | (XX << 2) | (XX << 4) | (XX << 6), // __GLNV20_TEX_SCALE_IDENTITY
        XX | (XX << 2) | (YY << 4) | (XX << 6), // __GLNV20_TEX_SCALE_R_65535
        XX | (XX << 2) | (ZZ << 4) | (XX << 6), // __GLNV20_TEX_SCALE_R_16777215
        YY | (YY << 2) | (YY << 4) | (XX << 6), // __GLNV20_TEX_SCALE_STR_65535
        ZZ | (ZZ << 2) | (ZZ << 4) | (XX << 6), // __GLNV20_TEX_SCALE_STR_16777215
    };
#endif
    const static int scalemasks[] = {
        0,              // __GLNV20_TEX_SCALE_IDENTITY
        DST_Z_BIT,      // __GLNV20_TEX_SCALE_R_65535
        DST_Z_BIT,      // __GLNV20_TEX_SCALE_R_16777215
        DST_XYZ_BITS,   // __GLNV20_TEX_SCALE_STR_65535
        DST_XYZ_BITS,   // __GLNV20_TEX_SCALE_STR_16777215
    };
    const static int constreg[] = {
        0,        // __GLNV20_TEX_SCALE_IDENTITY
        PPR_58,   // __GLNV20_TEX_SCALE_R_65535
        PPR_59,   // __GLNV20_TEX_SCALE_R_16777215
        PPR_58,   // __GLNV20_TEX_SCALE_STR_65535
        PPR_59,   // __GLNV20_TEX_SCALE_STR_16777215
    };
    Instruction *frinst, *toinst;
    int fpc, tpc, tregno, texno, scaleinx, dstmask, count = 0;
    MaskedDstReg *dst;
    Scalar_Instruction *sinst;
    Vector_Instruction *vinst;
    Bin_Instruction *binst;
    Tri_Instruction *tinst;

    for (fpc = tpc = 0; fpc < fNum; fpc++, tpc++) {
        frinst = &fInsts[fpc];
        toinst = &tInsts[tpc];
        *toinst = *frinst;
        if (env->tLiveDead[fpc].tmpReg) {
            switch (frinst->bin_op.opclass) {
            case CLASS_VECTOR:
                vinst = (Vector_Instruction *) toinst;
                dst = &vinst->dst;
                break;
            case CLASS_SCALAR:
                sinst = (Scalar_Instruction *) toinst;
                dst = &sinst->dst;
                break;
            case CLASS_BIN:
                binst = (Bin_Instruction *) toinst;
                dst = &binst->dst;
                break;
            case CLASS_TRI:
                tinst = (Tri_Instruction *) toinst;
                dst = &tinst->dst;
                break;
            case CLASS_END:
            case CLASS_ARL:
            case CLASS_NOP:
            default:
                assert(0);
                continue;
            }
            texno = dst->reg - VR_TEX0;
            dstmask = dst->mask;
            tregno = env->tLiveDead[fpc].tmpReg & 0xf;
            scaleinx = (env->textureScaling >> (texno*__GLNV20_TEX_SCALE_FIELD_BITS)) &
                         __GLNV20_TEX_SCALE_MASK;
            // Patch old instruction to write to scratch register:

            dst->reg = (Register_t) (TR_0 + tregno);

#if 000
            // Build new instruction to scale temp value into final destination:
            // MUL o[TEXi].mask, Rtmp, c[23];  // c[23] = 1.0, 65535.0, 16777215.0

            count++;
            binst = (Bin_Instruction *) &tInsts[++tpc];
            binst->opclass = CLASS_BIN;
            binst->opcode = OP_MUL;
            binst->srcA.reg.reg = TR_0 + tregno;
            binst->srcA.reg.AddrReg = 0;
            binst->srcA.reg.addrRegOffset = 0;
            binst->srcA.com4 = XYZW;
            binst->srcA.Signed = 0;

            binst->srcB.reg.reg = PPR_23;
            binst->srcB.reg.AddrReg = 0;
            binst->srcB.reg.addrRegOffset = 0;
            binst->srcB.com4 = swizzles[scaleinx];
            binst->srcB.Signed = 0;

            binst->dst.reg = VR_TEX0 + texno;
            binst->dst.mask = dstmask;
#endif
            
            // Build two new instruction to scale temp value into final destination:
            // MUL o[TEXi].mask, Rtmp, c[58/59].w; // c[58].w = 65535, c[59].w = 16777215

            count++;
            binst = (Bin_Instruction *) &tInsts[++tpc];
            binst->opclass = CLASS_BIN;
            binst->opcode = OP_MUL;
            binst->srcA.reg.reg = (Register_t) (TR_0 + tregno);
            binst->srcA.reg.AddrReg = 0;
            binst->srcA.reg.addrRegOffset = 0;
            binst->srcA.com4 = XYZW;
            binst->srcA.Signed = 0;

            binst->srcB.reg.reg = (Register_t) constreg[scaleinx];
            binst->srcB.reg.AddrReg = 0;
            binst->srcB.reg.addrRegOffset = 0;
            binst->srcB.com4 = (WW | WW << 2 | WW << 4 | WW << 6);
            binst->srcB.Signed = 0;

            binst->dst.reg = (Register_t) (VR_TEX0 + texno);
            binst->dst.mask = dstmask & scalemasks[scaleinx];

            // MOV o[TEXi].mask, Rtmp;

            count++;
            vinst = (Vector_Instruction *) &tInsts[++tpc];
            vinst->opclass = CLASS_VECTOR;
            vinst->opcode = OP_MOV;
            vinst->src.reg.reg = (Register_t) (TR_0 + tregno);
            vinst->src.reg.AddrReg = 0;
            vinst->src.reg.addrRegOffset = 0;
            vinst->src.com4 = XYZW;
            vinst->src.Signed = 0;

            vinst->dst.reg = (Register_t) (VR_TEX0 + texno);
            vinst->dst.mask = dstmask & ~scalemasks[scaleinx];

            NV_TRACE(TR_PROGRAM, 50, ("Inserting texture scaling instruction(s) at: %03x\n", fpc));
        }
    }
    assert(count == env->numExtraInstructions);
} // lInsertTextureScaling

///////////////////////////////////////////////////////////////////////////////

/*
** lGenSrcReg()
*/

static void lGenSrcReg(VtxProgCompileKelvin *env, vtxpgmInst *pInst, SwizzleSrcReg20 *r, SrcReg *reg)
{
    int lreg = reg->reg;

    switch (lreg) {
    case VA_0:  case VA_1:  case VA_2:  case VA_3:
    case VA_4:  case VA_5:  case VA_6:  case VA_7:
    case VA_8:  case VA_9:  case VA_10: case VA_11:
    case VA_12: case VA_13: case VA_14: case VA_15:
        r->mx = IN_MUX_VA;
        pInst->va = (unsigned char) env->inputRegMap[lreg - VA_0];
        NV_TRACE(TR_PROGRAM, 50, ("v[%i]", pInst->va));
        break;
    case PR_0:  case PR_1:  case PR_2:  case PR_3:
    case PR_4:  case PR_5:  case PR_6:  case PR_7:
    case PR_8:  case PR_9:  case PR_10: case PR_11:
    case PR_12: case PR_13: case PR_14: case PR_15:
    case PR_16: case PR_17: case PR_18: case PR_19:
    case PR_20: case PR_21: case PR_22: case PR_23:
    case PR_24: case PR_25: case PR_26: case PR_27:
    case PR_28: case PR_29: case PR_30: case PR_31:
    case PR_32: case PR_33: case PR_34: case PR_35:
    case PR_36: case PR_37: case PR_38: case PR_39:
    case PR_40: case PR_41: case PR_42: case PR_43:
    case PR_44: case PR_45: case PR_46: case PR_47:
    case PR_48: case PR_49: case PR_50: case PR_51:
    case PR_52: case PR_53: case PR_54: case PR_55:
    case PR_56: case PR_57: case PR_58: case PR_59:
    case PR_60: case PR_61: case PR_62: case PR_63:
    case PR_64: case PR_65: case PR_66: case PR_67:
    case PR_68: case PR_69: case PR_70: case PR_71:
    case PR_72: case PR_73: case PR_74: case PR_75:
    case PR_76: case PR_77: case PR_78: case PR_79:
    case PR_80: case PR_81: case PR_82: case PR_83:
    case PR_84: case PR_85: case PR_86: case PR_87:
    case PR_88: case PR_89: case PR_90: case PR_91:
    case PR_92: case PR_93: case PR_94: case PR_95:
        if (reg->AddrReg) {
            r->mx = IN_MUX_CA;
            pInst->ca = (unsigned char) reg->addrRegOffset;
            if (env->userMode)
                pInst->ca += 96;
            pInst->cin = 1;
            NV_TRACE(TR_PROGRAM, 50, ("c[A0.x+%i]", pInst->ca));
        } else {
            r->mx = IN_MUX_CA;
            pInst->ca = lreg - PR_0;
            if (env->userMode)
                pInst->ca += 96;
            NV_TRACE(TR_PROGRAM, 50, ("c[%i]", pInst->ca));
        }
        break;
    case PPR_23:
    case PPR_58:
    case PPR_59:
    case PPR_62:
        // Special hook into priveledged (lower 96) registers:
        if (reg->AddrReg) {
            r->mx = IN_MUX_CA;
            pInst->ca = (unsigned char) reg->addrRegOffset;
            pInst->cin = 1;
            NV_TRACE(TR_PROGRAM, 50, ("ppr[A0.x+%i]", pInst->ca));
        } else {
            r->mx = IN_MUX_CA;
            pInst->ca = lreg - PPR_0;
            NV_TRACE(TR_PROGRAM, 50, ("ppr[%i]", pInst->ca));
        }
        break;
    case TR_0:  case TR_1:  case TR_2:  case TR_3:
    case TR_4:  case TR_5:  case TR_6:  case TR_7:
    case TR_8:  case TR_9:  case TR_10: case TR_11:
    case TR_12: case TR_13: case TR_14: case TR_15:
        r->mx = IN_MUX_RR;
        r->rr = lreg - TR_0;
        NV_TRACE(TR_PROGRAM, 50, ("R%i", r->rr));
        break;
    default:
        assert(!"lGenSrcReg() - Bad register number");
        NV_TRACE(TR_PROGRAM, 50, ("BAD-REG!"));
        break;
    }
} // lGenSrcReg

////////////////////////// NV20 Level Code Generation /////////////////////////

/*
** lGenScalarSrcReg()
*/
char *TEXT_XYZW = "xyzw";

static void lGenScalarSrcReg(VtxProgCompileKelvin *env, vtxpgmInst *pInst, SwizzleSrcReg20 *r, ScalarSrcReg *reg)
{
    // ???? Is there anything special about ScalarSrcReg?  ???? //
    // ???? I swizzled the input to all inputs;  I don't know if that's right/wrong/doesn't-matter ???? //
    NV_TRACE(TR_PROGRAM, 50, (", %s", reg->Signed ? "-" : ""));
    lGenSrcReg(env, pInst, r, &reg->reg);
    r->ne = reg->Signed;
    r->xs = reg->com;
    r->ys = reg->com;
    r->zs = reg->com;
    r->ws = reg->com;
    NV_TRACE(TR_PROGRAM, 50, (".%c", TEXT_XYZW[reg->com]));
} // lGenScalarSrcReg

/*
** lGenSwizzleSrcReg()
*/

static void lGenSwizzleSrcReg(VtxProgCompileKelvin *env, vtxpgmInst *pInst, SwizzleSrcReg20 *r, SwizzleSrcReg *reg)
{
    NV_TRACE(TR_PROGRAM, 50, (", %s", reg->Signed ? "-" : ""));
    lGenSrcReg(env, pInst, r, &reg->reg);
    r->ne = reg->Signed;
    r->xs = reg->com4 & 0x03;
    r->ys = (reg->com4 & 0x0c) >> 2;
    r->zs = (reg->com4 & 0x30) >> 4;
    r->ws = (reg->com4 & 0xc0) >> 6;
    NV_TRACE_COND(TR_PROGRAM, 50,
        if (reg->com4 != XYZW) {
            NV_TRACE(TR_PROGRAM, 50, (".%c", TEXT_XYZW[r->xs]));
            NV_TRACE(TR_PROGRAM, 50, ("%c", TEXT_XYZW[r->ys]));
            NV_TRACE(TR_PROGRAM, 50, ("%c", TEXT_XYZW[r->zs]));
            NV_TRACE(TR_PROGRAM, 50, ("%c", TEXT_XYZW[r->ws]));
        }
    )
} // lGenSwizzleSrcReg

/*
**
*/

static unsigned char lMakeWriteMask(int fval)
{
    unsigned char result = 0;

    if (fval & DST_X_BIT)
        result |= OUT_MASK_X;
    if (fval & DST_Y_BIT)
        result |= OUT_MASK_Y;
    if (fval & DST_Z_BIT)
        result |= OUT_MASK_Z;
    if (fval & DST_W_BIT)
        result |= OUT_MASK_W;
    return result;
} // lMakeWriteMask

/*
** lGenMaskedDstILU() - Store the masked output of the ILU in "reg".
*/

static void lGenMaskedDstILU(VtxProgCompileKelvin *env, vtxpgmInst *pInst, MaskedDstReg *reg)
{
    NV_TRACE_CODE(int mask);

    if (reg->reg >= TR_0 && reg->reg <= TR_15) {
        // Target is a scratch register.  Use swm:
        pInst->swm = lMakeWriteMask(reg->mask);
        pInst->rw = reg->reg - TR_0;
        NV_TRACE(TR_PROGRAM, 50, ("R%i", pInst->rw));
        NV_TRACE_CODE(mask = pInst->swm);
    } else {
        // Target is a context or output register.  Use owm:
        pInst->om = OUT_MUX_OM_ILU;
        pInst->owm = lMakeWriteMask(reg->mask);
        if (reg->reg >= PR_0 && reg->reg <= PR_95) {
            pInst->oc = (reg->reg - PR_0) | OC_SELECT_CONTEXT;
            if (env->userMode)
                pInst->oc += 96;
            NV_TRACE(TR_PROGRAM, 50, ("c[%i]", pInst->oc & 0x0ff));
        } else {
            assert(reg->reg >= VR_0 && reg->reg <= VR_15);
            pInst->oc = env->outputRegMap[(reg->reg - VR_0)] | OC_SELECT_OUTPUT;
            NV_TRACE(TR_PROGRAM, 50, ("o[%i]", pInst->oc & 0x0ff));
        }
        NV_TRACE_CODE(mask = pInst->owm);
    }
    NV_TRACE_COND(TR_PROGRAM, 50,
        if (mask != OUT_MASK_XYZW) {
            TPRINTF(("."));
            if (mask & OUT_MASK_X)
                TPRINTF(("x"));
            if (mask & OUT_MASK_Y)
                TPRINTF(("y"));
            if (mask & OUT_MASK_Z)
                TPRINTF(("z"));
            if (mask & OUT_MASK_W)
                TPRINTF(("w"));
        }
    );
} // lGenMaskedDstILU

/*
** lGenMaskedDstALU() - Store the masked output of the ALU in "reg".
*/

static void lGenMaskedDstALU(VtxProgCompileKelvin *env, vtxpgmInst *pInst, MaskedDstReg *reg)
{
    NV_TRACE_CODE(int mask);

    if (reg->reg >= TR_0 && reg->reg <= TR_15) {
        // Target is a scratch register.  Use rwm:
        pInst->rwm = lMakeWriteMask(reg->mask);
        pInst->rw = reg->reg - TR_0;
        NV_TRACE(TR_PROGRAM, 50, ("R%i", pInst->rw));
        NV_TRACE_CODE(mask = pInst->rwm);
    } else {
        // Target is a context or output register.  Use owm:
        pInst->om = OUT_MUX_OM_ALU;
        pInst->owm = lMakeWriteMask(reg->mask);
        if (reg->reg >= PR_0 && reg->reg <= PR_95) {
            pInst->oc = (reg->reg - PR_0) | OC_SELECT_CONTEXT;
            if (env->userMode)
                pInst->oc += 96;
            NV_TRACE(TR_PROGRAM, 50, ("c[%i]", pInst->oc & 0x0ff));
        } else {
            assert(reg->reg >= VR_0 && reg->reg <= VR_15);
            pInst->oc = env->outputRegMap[(reg->reg - VR_0)] | OC_SELECT_OUTPUT;
            NV_TRACE(TR_PROGRAM, 50, ("o[%i]", pInst->oc & 0x0ff));
        }
        NV_TRACE_CODE(mask = pInst->owm);
    }
    NV_TRACE_COND(TR_PROGRAM, 50,
        if (mask != OUT_MASK_XYZW) {
            TPRINTF(("."));
            if (mask & OUT_MASK_X)
                TPRINTF(("x"));
            if (mask & OUT_MASK_Y)
                TPRINTF(("y"));
            if (mask & OUT_MASK_Z)
                TPRINTF(("z"));
            if (mask & OUT_MASK_W)
                TPRINTF(("w"));
        }
    );
} // lGenMaskedDstALU

/*
** lAppendViewportXform(pCode, &pc);
*/

static void lAppendViewportXform(VtxProgCompileKelvin *env, vtxpgmInst *pCode, int *ppc)
{
    vtxpgmInst *curInst;
    int pc = *ppc;
    SwizzleSrcReg srcA, srcB, srcC;
    ScalarSrcReg src;
    MaskedDstReg dst;

    NV_TRACE(TR_PROGRAM, 50, ("--- Viewport Xform ---\n"));

    env->userMode = 0;

    curInst = &pCode[pc - 1];
    curInst->eos = 0;

    if (env->passthroughMode) {
        // If this vertex program is the passthrough vertex program, then
        // only apply the zscale and viewport offset.  Do not apply W-divide
        // since the vertices will already be in screen coordinates.

        // MUL o[HPOS].xyz, R12, c[58];
        srcA.reg.reg = TR_12;
        srcA.reg.AddrReg = FALSE;
        srcA.reg.addrRegOffset = 0;
        srcA.com4 = XYZW;
        srcA.Signed = 0;

        srcB.reg.reg = PPR_58;
        srcB.reg.AddrReg = FALSE;
        srcB.reg.addrRegOffset = 0;
        srcB.com4 = XYZW;
        srcB.Signed = 0;

        dst.reg = VR_HPOS;
        dst.mask = DST_XYZ_BITS;

        curInst = &pCode[pc];
        NV_TRACE(TR_PROGRAM, 50, ("%03x:  MUL ", pc));
        curInst->mac = MAC_MUL;
        lGenMaskedDstALU(env, curInst, &dst);
        lGenSwizzleSrcReg(env, curInst, &curInst->a, &srcA);
        lGenSwizzleSrcReg(env, curInst, &curInst->b, &srcB);
        NV_TRACE(TR_PROGRAM, 50, ("\n"));
        pc++;

        // ADD o[HPOS].xyz, R12, c[59]
        srcA.reg.reg = TR_12;
        srcA.reg.AddrReg = FALSE;
        srcA.reg.addrRegOffset = 0;
        srcA.com4 = XYZW;
        srcA.Signed = 0;

        srcC.reg.reg = PPR_59;
        srcC.reg.AddrReg = FALSE;
        srcC.reg.addrRegOffset = 0;
        srcC.com4 = XYZW;
        srcC.Signed = 0;

        dst.reg = VR_HPOS;
        dst.mask = DST_XYZ_BITS;

        curInst = &pCode[pc];
        NV_TRACE(TR_PROGRAM, 50, ("%03x:  ADD ", pc));
        curInst->mac = MAC_ADD;
        lGenMaskedDstALU(env, curInst, &dst);
        lGenSwizzleSrcReg(env, curInst, &curInst->a, &srcA);
        lGenSwizzleSrcReg(env, curInst, &curInst->c, &srcC);
        curInst->eos = 1;
        NV_TRACE(TR_PROGRAM, 50, ("\n"));
        pc++;
/*
        // MAD o[HPOS].xyz, R12, c[58], c[59];

        srcA.reg.reg = TR_12;
        srcA.reg.AddrReg = FALSE;
        srcA.reg.addrRegOffset = 0;
        srcA.com4 = XYZW;
        srcA.Signed = 0;

        srcB.reg.reg = PPR_58;
        srcB.reg.AddrReg = FALSE;
        srcB.reg.addrRegOffset = 0;
        srcB.com4 = XYZW;
        srcB.Signed = 0;

        srcC.reg.reg = PPR_59;
        srcC.reg.AddrReg = FALSE;
        srcC.reg.addrRegOffset = 0;
        srcC.com4 = XYZW;
        srcC.Signed = 0;

        dst.reg = VR_HPOS;
        dst.mask = DST_XYZ_BITS;

        curInst = &pCode[pc];
        NV_TRACE(TR_PROGRAM, 50, ("%03x:  MAD ", pc));
        curInst->mac = MAC_MAD;
        lGenMaskedDstALU(env, curInst, &dst);
        lGenSwizzleSrcReg(env, curInst, &curInst->a, &srcA);
        lGenSwizzleSrcReg(env, curInst, &curInst->b, &srcB);
        lGenSwizzleSrcReg(env, curInst, &curInst->c, &srcC);
        curInst->eos = 1;
        NV_TRACE(TR_PROGRAM, 50, ("\n"));
        pc++;
        */
    } else {
    // MUL R11.xyz, R12, c[58];

    srcA.reg.reg = TR_12;
    srcA.reg.AddrReg = FALSE;
    srcA.reg.addrRegOffset = 0;
    srcA.com4 = XYZW;
    srcA.Signed = 0;

    srcB.reg.reg = PPR_58;
    srcB.reg.AddrReg = FALSE;
    srcB.reg.addrRegOffset = 0;
    srcB.com4 = XYZW;
    srcB.Signed = 0;

    dst.reg = TR_11;
    dst.mask = DST_XYZ_BITS;

    curInst = &pCode[pc];
    NV_TRACE(TR_PROGRAM, 50, ("%03x:  MUL ", pc));
    curInst->mac = MAC_MUL;
    lGenMaskedDstALU(env, curInst, &dst);
    lGenSwizzleSrcReg(env, curInst, &curInst->a, &srcA);
    lGenSwizzleSrcReg(env, curInst, &curInst->b, &srcB);
    NV_TRACE(TR_PROGRAM, 50, ("\n"));
    pc++;

    // RCC R1, R12.w;  <<---<< Can be combined with previous instruction

    src.reg.reg = TR_12;
    src.reg.AddrReg = FALSE;
    src.reg.addrRegOffset = 0;
    src.com = WW;
    src.Signed = FALSE;

    dst.reg = TR_1;
    dst.mask = DST_XYZW_BITS;

    curInst = &pCode[pc];
    NV_TRACE(TR_PROGRAM, 50, ("%03x:  RCC ", pc));
    curInst->ilu = ILU_RCC;
    lGenMaskedDstILU(env, curInst, &dst);
    lGenScalarSrcReg(env, curInst, &curInst->c, &src);
    NV_TRACE(TR_PROGRAM, 50, ("\n"));
    pc++;

    // MAD o[HPOS].xyz, R1.w, R11, c[59];

    srcA.reg.reg = TR_1;
    srcA.reg.AddrReg = FALSE;
    srcA.reg.addrRegOffset = 0;
    srcA.com4 = WW | (WW << 2) | (WW << 4) | (WW << 6);
    srcA.Signed = 0;

    srcB.reg.reg = TR_11;
    srcB.reg.AddrReg = FALSE;
    srcB.reg.addrRegOffset = 0;
    srcB.com4 = XYZW;
    srcB.Signed = 0;

    srcC.reg.reg = PPR_59;
    srcC.reg.AddrReg = FALSE;
    srcC.reg.addrRegOffset = 0;
    srcC.com4 = XYZW;
    srcC.Signed = 0;

    dst.reg = VR_HPOS;
    dst.mask = DST_XYZ_BITS;

    curInst = &pCode[pc];
    NV_TRACE(TR_PROGRAM, 50, ("%03x:  MAD ", pc));
    curInst->mac = MAC_MAD;
    lGenMaskedDstALU(env, curInst, &dst);
    lGenSwizzleSrcReg(env, curInst, &curInst->a, &srcA);
    lGenSwizzleSrcReg(env, curInst, &curInst->b, &srcB);
    lGenSwizzleSrcReg(env, curInst, &curInst->c, &srcC);
    curInst->eos = 1;
    NV_TRACE(TR_PROGRAM, 50, ("\n"));
    pc++;
    }
    *ppc = pc;
} // lApendViewportXform

/*
** lPackCode() - Pack instruction fields into NV20 microcode format.
*/

static void lPackCode(vtxpgmInstPacked *theCode, vtxpgmInst *pCode, int pc)
{
    int ii;

    for (ii = 0; ii < pc; ii++) {
        theCode->x = 0;
        theCode->y = (pCode->ilu  << 25) |
                     (pCode->mac  << 21) |
                     (pCode->ca   << 13) |
                     (pCode->va   <<  9) |
                     (pCode->a.ne <<  8) |
                     (pCode->a.xs <<  6) |
                     (pCode->a.ys <<  4) |
                     (pCode->a.zs <<  2) |
                     (pCode->a.ws <<  0);
        theCode->z = (pCode->a.rr << 28) |
                     (pCode->a.mx << 26) |
                     (pCode->b.ne << 25) |
                     (pCode->b.xs << 23) |
                     (pCode->b.ys << 21) |
                     (pCode->b.zs << 19) |
                     (pCode->b.ws << 17) |
                     (pCode->b.rr << 13) |
                     (pCode->b.mx << 11) |
                     (pCode->c.ne << 10) |
                     (pCode->c.xs <<  8) |
                     (pCode->c.ys <<  6) |
                     (pCode->c.zs <<  4) |
                     (pCode->c.ws <<  2) |
                     (pCode->c.rr >>  2);
        theCode->w = (pCode->c.rr << 30) |
                     (pCode->c.mx << 28) |
                     (pCode->rwm  << 24) |
                     (pCode->rw   << 20) |
                     (pCode->swm  << 16) |
                     (pCode->owm  << 12) |
                     (pCode->oc   <<  3) |
                     (pCode->om   <<  2) |
                     (pCode->cin  <<  1) |
                     (pCode->eos  <<  0);
        NV_TRACE_COND(TR_PROGRAM, 50,
            if (!(ii & 0x1f)) {
                TPRINTF(("\n"));
                TPRINTF(("                                "));
                TPRINTF(("-I M       N              N              N              R   S O       C E\n"));
                TPRINTF(("                                "));
                TPRINTF(("-L A -C V  E X Y Z W R M  E X Y Z W R M  E X Y Z W R M  W R W W -O- O I O\n"));
                TPRINTF(("                                "));
                TPRINTF(("-U C -A A  G S S S S R X  G S S S S R X  G S S S S R X  M W M M -C- M N S\n"));
            }
        );
        NV_TRACE(TR_PROGRAM, 50, ("%02x: %08x %08x %08x: ",
                                  ii, theCode->y, theCode->z, theCode->w));
        NV_TRACE(TR_PROGRAM, 50, ("%02x %01x %02x %01x",
                                  (theCode->y >> 25) & 0x7f,
                                  (theCode->y >> 21) & 0xf,
                                  (theCode->y >> 13) & 0xff,
                                  (theCode->y >> 9) & 0xf
                                  ));
        NV_TRACE(TR_PROGRAM, 50, ("  %01x %01x %01x %01x %01x %01x %01x",
                                  (theCode->y >> 8) & 0x1,
                                  (theCode->y >> 6) & 0x3,
                                  (theCode->y >> 4) & 0x3,
                                  (theCode->y >> 2) & 0x3,
                                  (theCode->y >> 0) & 0x3,
                                  (theCode->z >> 28) & 0xf,
                                  (theCode->z >> 26) & 0x3
                                  ));
        NV_TRACE(TR_PROGRAM, 50, ("  %01x %01x %01x %01x %01x %01x %01x",
                                  (theCode->z >> 25) & 0x1,
                                  (theCode->z >> 23) & 0x3,
                                  (theCode->z >> 21) & 0x3,
                                  (theCode->z >> 19) & 0x3,
                                  (theCode->z >> 17) & 0x3,
                                  (theCode->z >> 13) & 0xf,
                                  (theCode->z >> 11) & 0x3
                                  ));
        NV_TRACE(TR_PROGRAM, 50, ("  %01x %01x %01x %01x %01x %01x %01x",
                                  (theCode->z >> 10) & 0x1,
                                  (theCode->z >> 8) & 0x3,
                                  (theCode->z >> 6) & 0x3,
                                  (theCode->z >> 4) & 0x3,
                                  (theCode->z >> 2) & 0x3,
                                  ((theCode->z << 2) | ((theCode->w >> 30) & 0x3)) & 0xf,
                                  (theCode->w >> 28) & 0x3
                                  ));
        NV_TRACE(TR_PROGRAM, 50, ("  %01x %01x %01x %01x %03x %01x %01x %01x",
                                  (theCode->w >> 24) & 0xf,
                                  (theCode->w >> 20) & 0xf,
                                  (theCode->w >> 16) & 0xf,
                                  (theCode->w >> 12) & 0xf,
                                  (theCode->w >> 3) & 0x1ff,
                                  (theCode->w >> 2) & 0x1,
                                  (theCode->w >> 1) & 0x1,
                                  (theCode->w >> 0) & 0x1
                                  ));
        NV_TRACE(TR_PROGRAM, 50, ("\n"));
        pCode++;
        theCode++;
    }
    NV_TRACE(TR_PROGRAM, 50, ("\n"));
} // lPackCode

/*
** vp_CompileKelvin() - Compile a vertex program into NV20 microcode.
*/

int vp_CompileKelvin(VtxProgCompileKelvin *env, ParsedProgram *fParsed,
                     int numInstructions, VertexProgramOutput *outArgs)
{
    NV_FUN_NAME(__glNV20MakeProgramResident, TR_PROGRAM, 20)
    vtxpgmInst *pCode, *curInst;
    vtxpgmInstPacked *theCode;
    Instruction *inst, *newinst;
    Arl_Instruction *ainst;
    Scalar_Instruction *sinst;
    Vector_Instruction *vinst;
    Bin_Instruction *binst;
    Tri_Instruction *tinst;
    int lop, lsize;
    int lNumInstructions;
    int pc, skipping, offset;

    NV_TRACE_FUNC(("ppi", env, fParsed, numInstructions));
    NV_TRACE_PUSH();

#if !defined(IS_OPENGL)
    env->textureScaling = __GLNV20_TEX_SCALE_IDENTITY;
    env->passthroughMode = 0;
#endif

    lInitTempLiveDead(env, fParsed, numInstructions);
    lNumInstructions = numInstructions + env->numExtraInstructions;
    if (env->numExtraInstructions > 0) {
        if (lNumInstructions > __GL_MAX_NUMBER_OF_INSTRUCTIONS) {
            // Too big!  Can't create program.
            assert(!"Program too big.  Can't add texture scaling instructions.");
            return FALSE;
        }
        newinst = (Instruction *) env->malloc(env->mallocArg,
                                                sizeof(Instruction)*(lNumInstructions));
        lInsertTextureScaling(env, fParsed->firstInstruction, newinst, numInstructions, lNumInstructions);
    } else {
        newinst = NULL;
    }

    pCode = (vtxpgmInst *) env->malloc(env->mallocArg,
                sizeof(vtxpgmInst)*(__GL_MAX_NUMBER_OF_INSTRUCTIONS + 3));
    if (!pCode) {
        NV_TRACE_POP();
        return FALSE;
    }

    // Initialize instructions:

    for (pc = 0; pc < (__GL_MAX_NUMBER_OF_INSTRUCTIONS + 3); pc++)
        lInitInst(&pCode[pc]);

    env->userMode = 1;

    offset = 0; skipping = 0;
    NV_TRACE(TR_PROGRAM, 50, ("\n"));
    inst = newinst ? newinst : fParsed->firstInstruction;
    for (pc = 0; pc < lNumInstructions; inst++, pc++) {

#if defined(ENABLE_TRACE_CODE)
        if (env->tLiveDead) {
            int ii;
            
            if (skipping) {
                NV_TRACE(TR_PROGRAM, 50, ("               "));
                skipping--;
                offset++;
            } else {
                for (ii = 0; ii < __GL_NUMBER_OF_TEMPORARY_REGISTERS; ii++) {
                    NV_TRACE(TR_PROGRAM, 50, ("%1x", env->tLiveDead[pc - offset].v[ii]));
                }
                if (env->tLiveDead[pc - offset].tmpReg) {
                    if (env->tLiveDead[pc - offset].tmpReg & ALU_TEMP) {
                        NV_TRACE(TR_PROGRAM, 50, ("A%1x ", env->tLiveDead[pc - offset].tmpReg & 0xf));
                    } else {
                        NV_TRACE(TR_PROGRAM, 50, ("I%1x ", env->tLiveDead[pc - offset].tmpReg & 0xf));
                    }
                    skipping = 2;
                } else {
                    NV_TRACE(TR_PROGRAM, 50, ("   "));
                }
            }
        }
#endif // defined(ENABLE_TRACE_CODE)

        curInst = &pCode[pc];
        lop = inst->end_op.opcode;
        switch (lop) {

        // ARL op:

        case OP_ARL:
            NV_TRACE(TR_PROGRAM, 50, ("%03x:  ARL ", pc));
            ainst = (Arl_Instruction *) inst;
            curInst->mac = MAC_ARL;
            NV_TRACE(TR_PROGRAM, 50, ("A0.x"));
            lGenScalarSrcReg(env, curInst, &curInst->a, &ainst->src);
            break;

        // SCALAR ops:

        case OP_EXP:
            NV_TRACE(TR_PROGRAM, 50, ("%03x:  EXP ", pc));
            sinst = (Scalar_Instruction *) inst;
            curInst->ilu = ILU_EXP;
            lGenMaskedDstILU(env, curInst, &sinst->dst);
            lGenScalarSrcReg(env, curInst, &curInst->c, &sinst->src);
            break;

        case OP_LOG:
            NV_TRACE(TR_PROGRAM, 50, ("%03x:  LOG ", pc));
            sinst = (Scalar_Instruction *) inst;
            curInst->ilu = ILU_LOG;
            lGenMaskedDstILU(env, curInst, &sinst->dst);
            lGenScalarSrcReg(env, curInst, &curInst->c, &sinst->src);
            break;

#if defined(NV_INTERNAL_OPCODES)
        case OP_RCC:
            NV_TRACE(TR_PROGRAM, 50, ("%03x:  RCC ", pc));
            sinst = (Scalar_Instruction *) inst;
            curInst->ilu = ILU_RCC;
            lGenMaskedDstILU(env, curInst, &sinst->dst);
            lGenScalarSrcReg(env, curInst, &curInst->c, &sinst->src);
            break;
#endif // NV_INTERNAL_OPCODES

        case OP_RCP:
            NV_TRACE(TR_PROGRAM, 50, ("%03x:  RCP ", pc));
            sinst = (Scalar_Instruction *) inst;
            curInst->ilu = ILU_RCP;
            lGenMaskedDstILU(env, curInst, &sinst->dst);
            lGenScalarSrcReg(env, curInst, &curInst->c, &sinst->src);
            break;

        case OP_RSQ:
            NV_TRACE(TR_PROGRAM, 50, ("%03x:  RSQ ", pc));
            sinst = (Scalar_Instruction *) inst;
            curInst->ilu = ILU_RSQ;
            lGenMaskedDstILU(env, curInst, &sinst->dst);
            lGenScalarSrcReg(env, curInst, &curInst->c, &sinst->src);
            break;

        // VECTOR ops:

        case OP_LIT:
            NV_TRACE(TR_PROGRAM, 50, ("%03x:  LIT ", pc));
            vinst = (Vector_Instruction *) inst;
            curInst->ilu = ILU_LIT;
            lGenMaskedDstILU(env, curInst, &vinst->dst);
            lGenSwizzleSrcReg/*lGenSwizzleSrcILU*/(env, curInst, &curInst->c, &vinst->src);
            break;

#if defined(NV_INTERNAL_OPCODES)
        case OP_IMV:
            NV_TRACE(TR_PROGRAM, 50, ("%03x:  IMV ", pc));
            vinst = (Vector_Instruction *) inst;
            curInst->ilu = ILU_MOV; // ???? Is there a separate ILU_IMV instruction? ???
            lGenMaskedDstILU(env, curInst, &vinst->dst);
            lGenSwizzleSrcReg/*lGenSwizzleSrcILU*/(env, curInst, &curInst->c, &vinst->src);
            break;
#endif // NV_INTERNAL_OPCODES

        case OP_MOV:
            NV_TRACE(TR_PROGRAM, 50, ("%03x:  MOV ", pc));
            vinst = (Vector_Instruction *) inst;
            curInst->ilu = ILU_MOV;
            lGenMaskedDstILU(env, curInst, &vinst->dst);
            lGenSwizzleSrcReg/*lGenSwizzleSrcILU*/(env, curInst, &curInst->c, &vinst->src);
            break;

        // BIN ops:

        case OP_ADD:
            NV_TRACE(TR_PROGRAM, 50, ("%03x:  ADD ", pc));
            binst = (Bin_Instruction *) inst;
            curInst->mac = MAC_ADD;
            lGenMaskedDstALU(env, curInst, &binst->dst);
            lGenSwizzleSrcReg(env, curInst, &curInst->a, &binst->srcA);
            lGenSwizzleSrcReg(env, curInst, &curInst->c, &binst->srcB);
            break;

        case OP_DP3:
            NV_TRACE(TR_PROGRAM, 50, ("%03x:  DP3 ", pc));
            binst = (Bin_Instruction *) inst;
            curInst->mac = MAC_DP3;
            lGenMaskedDstALU(env, curInst, &binst->dst);
            lGenSwizzleSrcReg(env, curInst, &curInst->a, &binst->srcA);
            lGenSwizzleSrcReg(env, curInst, &curInst->b, &binst->srcB);
            break;

        case OP_DP4:
            NV_TRACE(TR_PROGRAM, 50, ("%03x:  DP4 ", pc));
            binst = (Bin_Instruction *) inst;
            curInst->mac = MAC_DP4;
            lGenMaskedDstALU(env, curInst, &binst->dst);
            lGenSwizzleSrcReg(env, curInst, &curInst->a, &binst->srcA);
            lGenSwizzleSrcReg(env, curInst, &curInst->b, &binst->srcB);
            break;

#if defined(NV_INTERNAL_OPCODES)
        case OP_DPH:
            NV_TRACE(TR_PROGRAM, 50, ("%03x:  DPH ", pc));
            binst = (Bin_Instruction *) inst;
            curInst->mac = MAC_DPH;
            lGenMaskedDstALU(env, curInst, &binst->dst);
            lGenSwizzleSrcReg(env, curInst, &curInst->a, &binst->srcA);
            lGenSwizzleSrcReg(env, curInst, &curInst->b, &binst->srcB);
            break;
#endif // NV_INTERNAL_OPCODES

        case OP_DST:
            NV_TRACE(TR_PROGRAM, 50, ("%03x:  DST ", pc));
            binst = (Bin_Instruction *) inst;
            curInst->mac = MAC_DST;
            lGenMaskedDstALU(env, curInst, &binst->dst);
            lGenSwizzleSrcReg(env, curInst, &curInst->a, &binst->srcA);
            lGenSwizzleSrcReg(env, curInst, &curInst->b, &binst->srcB);
            break;

        case OP_MAX:
            NV_TRACE(TR_PROGRAM, 50, ("%03x:  MAX ", pc));
            binst = (Bin_Instruction *) inst;
            curInst->mac = MAC_MAX;
            lGenMaskedDstALU(env, curInst, &binst->dst);
            lGenSwizzleSrcReg(env, curInst, &curInst->a, &binst->srcA);
            lGenSwizzleSrcReg(env, curInst, &curInst->b, &binst->srcB);
            break;

        case OP_MIN:
            NV_TRACE(TR_PROGRAM, 50, ("%03x:  MIN ", pc));
            binst = (Bin_Instruction *) inst;
            curInst->mac = MAC_MIN;
            lGenMaskedDstALU(env, curInst, &binst->dst);
            lGenSwizzleSrcReg(env, curInst, &curInst->a, &binst->srcA);
            lGenSwizzleSrcReg(env, curInst, &curInst->b, &binst->srcB);
            break;

        case OP_MUL:
            NV_TRACE(TR_PROGRAM, 50, ("%03x:  MUL ", pc));
            binst = (Bin_Instruction *) inst;
            curInst->mac = MAC_MUL;
            lGenMaskedDstALU(env, curInst, &binst->dst);
            lGenSwizzleSrcReg(env, curInst, &curInst->a, &binst->srcA);
            lGenSwizzleSrcReg(env, curInst, &curInst->b, &binst->srcB);
            break;

        case OP_SGE:
            NV_TRACE(TR_PROGRAM, 50, ("%03x:  SGE ", pc));
            binst = (Bin_Instruction *) inst;
            curInst->mac = MAC_SGE;
            lGenMaskedDstALU(env, curInst, &binst->dst);
            lGenSwizzleSrcReg(env, curInst, &curInst->a, &binst->srcA);
            lGenSwizzleSrcReg(env, curInst, &curInst->b, &binst->srcB);
            break;

        case OP_SLT:
            NV_TRACE(TR_PROGRAM, 50, ("%03x:  SLT ", pc));
            binst = (Bin_Instruction *) inst;
            curInst->mac = MAC_SLT;
            lGenMaskedDstALU(env, curInst, &binst->dst);
            lGenSwizzleSrcReg(env, curInst, &curInst->a, &binst->srcA);
            lGenSwizzleSrcReg(env, curInst, &curInst->b, &binst->srcB);
            break;

        // TRIops:

        case OP_MAD:
            NV_TRACE(TR_PROGRAM, 50, ("%03x:  MAD ", pc));
            tinst = (Tri_Instruction *) inst;
            curInst->mac = MAC_MAD;
            lGenMaskedDstALU(env, curInst, &tinst->dst);
            lGenSwizzleSrcReg(env, curInst, &curInst->a, &tinst->srcA);
            lGenSwizzleSrcReg(env, curInst, &curInst->b, &tinst->srcB);
            lGenSwizzleSrcReg(env, curInst, &curInst->c, &tinst->srcC);
            break;

        // ENDops:

        case OP_END:
            curInst = &pCode[pc - 1];
            curInst->eos = 1;
            break;

        default:
            break;
        }
        NV_TRACE(TR_PROGRAM, 50, ("\n"));
    }

    --pc;   // Don't need the last "end" instruction.

    // Append the viewport xfrom code:

    if (!fParsed->IsStateProgram)
        lAppendViewportXform(env, pCode, &pc);

    lsize = pc*sizeof(vtxpgmInstPacked);
    theCode = (vtxpgmInstPacked *) env->malloc(env->mallocArg, lsize);
    if (theCode) {
        lPackCode(theCode, pCode, pc);
        outArgs->residentProgram = theCode;
        outArgs->residentSize = lsize;
        outArgs->residentNumInstructions = pc;
    } else {
        outArgs->residentProgram = NULL;
        outArgs->residentSize = 0;
        outArgs->residentNumInstructions = 0;
    }

    env->free(env->mallocArg, pCode);
    if (newinst)
        env->free(env->mallocArg, newinst);

    NV_TRACE_POP();
    return TRUE;
} // vp_CompileKelvin
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\common\NVUCL\disasm.h ===
/*
 * (C) Copyright NVIDIA Corporation Inc., 1996,1997,1998. All rights reserved.
 */
/********************************* Direct 3D *******************************\
*                                                                           *
* Module: DISASM.H                                                          *
*   Push buffer disassembler private interface                              *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*       Ben de Waal                 07/21/98 - Created                      *
*                                                                           *
\***************************************************************************/
#ifndef _disasm_h
#define _disasm_h

struct UCL_DISASM : public NVUCL_DISASM
{
    /*
     * exported
     */
public:
    NVUCL_RESULT NVUCL_STDCALL attach        (void);
    NVUCL_RESULT NVUCL_STDCALL detach        (void);

    NVUCL_RESULT NVUCL_STDCALL redirect      (char* pszFilename);
    NVUCL_RESULT NVUCL_STDCALL traverse      (void* pBuffer,DWORD dwByteCount);

    /*
     * private
     */
protected:
    /*
     * variables
     */
    char  *m_pszFilename;
    DWORD  m_dwRefCount;
    BOOL   m_bToDebugger;
    FILE  *m_hFile;          // if NULL we go to debugger also

    /*
     * methods
     */
    void emit (char *szFormat,...);

    /*
     * construction
     */
public:
    UCL_DISASM (void);
    virtual ~UCL_DISASM (void);
};

#endif //_disasm_h
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\common\NVUCL\matrix.cpp ===
/*
 * (C) Copyright NVIDIA Corporation Inc., 1996,1997,1998. All rights reserved.
 */
/********************************* Direct 3D *******************************\
*                                                                           *
* Module: MATRIX.CPP                                                        *
*   Matrix private implementation                                           *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*       Ben de Waal                 07/07/98 - Created                      *
*                                                                           *
\***************************************************************************/
#include "precomp.h"
#include "matrix.h"

/*
 * attach
 *
 * bump reference count up
 */
NVUCL_RESULT NVUCL_STDCALL UCL_MATRIX::attach
(
    void
)
{
    m_dwRefCount++;
    return NVUCL_OK;
}

/*
 * detach
 *
 * bump reference count down & delete object if it reaches zero
 */
NVUCL_RESULT NVUCL_STDCALL UCL_MATRIX::detach
(
    void
)
{
    if (--m_dwRefCount)
    {
        return NVUCL_OK;
    }
    /*
     * kill self
     */
    delete this;
    return NVUCL_OK;
}

/*
 * setStore
 *
 * redirect matrix element storage
 */
NVUCL_RESULT NVUCL_STDCALL UCL_MATRIX::setStore
(
    float *pfAddress
)
{
    m_fElement = pfAddress;
    classify();
    return NVUCL_OK;
}


/*
 * setUnit
 *
 * sets the matrix to unity
 */
NVUCL_RESULT NVUCL_STDCALL UCL_MATRIX::setUnit
(
    void
)
{
    /*
     * set to unit
     */
    memset (m_fElement,0,sizeof(float) * 16);
    m_fElement[0] = m_fElement[5] = m_fElement[10] = m_fElement[15] = 1.0f;
    m_eClass = unit;
    /*
     * done
     */
    return NVUCL_OK;
}

/*
 * setElement
 * 
 * set a specific element
 */
NVUCL_RESULT NVUCL_STDCALL UCL_MATRIX::setElement
(
    DWORD dwIndex,
    float fValue
)
{
    /*
     * check parameters
     */
    if (dwIndex > 15)
    {
        return NVUCL_ERROR_INVALIDPARAM;
    }
    /*
     * assign
     */
    m_fElement[dwIndex] = fValue;

    /*
     * reclassify matrix
     */
    classify();

    /*
     * done
     */
    return NVUCL_OK;
}

/*
 * setRow
 *
 * set an entire row
 */
NVUCL_RESULT NVUCL_STDCALL UCL_MATRIX::setRow
(
    DWORD dwRow,
    float *pfValue
)
{
    /*
     * check parameters
     */
    if (dwRow > 3)
    {
        return NVUCL_ERROR_INVALIDPARAM;
    }
    /*
     * assign
     */
    memcpy (m_fElement + (dwRow << 2),pfValue,sizeof(float) * 4);

    /*
     * reclassify matrix
     */
    classify();

    /*
     * done
     */
    return NVUCL_OK;
}

/*
 * setAll
 *
 * set all elements in matrix
 */
NVUCL_RESULT NVUCL_STDCALL UCL_MATRIX::setAll
(
    float *pfValue
)
{
    return NVUCL_ERROR_NOTIMLEMENTED;
}

/*
 * getElement
 *
 * get a specific element
 */
NVUCL_RESULT NVUCL_STDCALL UCL_MATRIX::getElement
(
    DWORD dwIndex,
    float *pfValue
)
{
    return NVUCL_ERROR_NOTIMLEMENTED;
}

/*
 * getRow
 *
 * get a whole row of elements
 */
NVUCL_RESULT NVUCL_STDCALL UCL_MATRIX::getRow
(
    DWORD dwRow,
    float *pfValue
)
{
    return NVUCL_ERROR_NOTIMLEMENTED;
}


/*
 * getAll
 *
 * get all the elements
 */
NVUCL_RESULT NVUCL_STDCALL UCL_MATRIX::getAll
(
    float *pfValue
)
{
    return NVUCL_ERROR_NOTIMLEMENTED;
}

/*
 * multiply
 *
 * multiply tow matrices
 */
NVUCL_RESULT NVUCL_STDCALL UCL_MATRIX::multiply
(
    void *pMatrix
)
{
    return NVUCL_ERROR_NOTIMLEMENTED;
}

/*
 * invert
 *
 * invert matrix
 */
NVUCL_RESULT NVUCL_STDCALL UCL_MATRIX::invert
(
    void
)
{
    return NVUCL_ERROR_NOTIMLEMENTED;
}

/*
 * classify
 *
 * look at elements in matrix and classify acorrdingly
 */
void UCL_MATRIX::classify
(
    void
)
{
    /*
     * test for general
     */
    if (m_fElement[3] || m_fElement[7] || m_fElement[11] || (m_fElement[15] != 1.0f))
    {
        m_eClass = general;
        return;
    }

    /*
     * test for translation
     */
    if (m_fElement[12] || m_fElement[13] || m_fElement[14])
    {
        m_eClass = translation;
    }
    else
    {
        m_eClass = unit;
    }

    /*
     * test for rotation
     */
    if ((m_fElement[0] != 1.0f) || (m_fElement[5] != 1.0f) || (m_fElement[10] != 1.0f)
     || m_fElement[1] || m_fElement[2] 
     || m_fElement[4] || m_fElement[6]
     || m_fElement[8] || m_fElement[9])
    {
        m_eClass = (m_eClass == unit) ? rotation : threebyfour;
    }
}

/*
 * construction
 */
UCL_MATRIX::UCL_MATRIX (void)
{
    m_dwRefCount = 1;
    m_fElement   = m_fInternalStorage;
    setUnit();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\common\NVUCL\matrix.h ===
/*
 * (C) Copyright NVIDIA Corporation Inc., 1996,1997,1998. All rights reserved.
 */
/********************************* Direct 3D *******************************\
*                                                                           *
* Module: MATRIX.H                                                          *
*   Matrix private interface                                                *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*       Ben de Waal                 07/07/98 - Created                      *
*                                                                           *
\***************************************************************************/
#ifndef _matrix_h
#define _matrix_h

struct UCL_MATRIX : public NVUCL_MATRIX
{
    /*
     * exported
     */
public:
    NVUCL_RESULT NVUCL_STDCALL attach        (void);
    NVUCL_RESULT NVUCL_STDCALL detach        (void);

    NVUCL_RESULT NVUCL_STDCALL setStore      (float *pfAddress);
    NVUCL_RESULT NVUCL_STDCALL setUnit       (void);

    NVUCL_RESULT NVUCL_STDCALL setElement    (DWORD dwIndex,float  fValue);
    NVUCL_RESULT NVUCL_STDCALL setRow        (DWORD dwRow,  float *pfValue);
    NVUCL_RESULT NVUCL_STDCALL setAll        (float *pfValue);

    NVUCL_RESULT NVUCL_STDCALL getElement    (DWORD dwIndex,float *pfValue);
    NVUCL_RESULT NVUCL_STDCALL getRow        (DWORD dwRow,  float *pfValue);
    NVUCL_RESULT NVUCL_STDCALL getAll        (float *pfValue);

    NVUCL_RESULT NVUCL_STDCALL multiply      (void *pMatrix);
    NVUCL_RESULT NVUCL_STDCALL invert        (void);

    /*
     * private
     */
protected:
    /*
     * variables
     */
    float  m_fInternalStorage[16];
    float *m_fElement;
    DWORD  m_dwRefCount;
    enum e_Class { unit,rotation,translation,threebyfour,general } m_eClass;

    /*
     * methods
     */
    void classify (void);

    /*
     * construction
     */
public:
    UCL_MATRIX (void);
};

#endif //_matrix_h
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\common\NVUCL\nvucl.cpp ===
/*
 * (C) Copyright NVIDIA Corporation Inc., 1996,1997,1998. All rights reserved.
 */
/********************************* Direct 3D *******************************\
*                                                                           *
* Module: NVUCL.CPP                                                         *
*   Basic interface fulfillment routines                                    *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*       Ben de Waal                 07/06/98 - Created                      *
*                                                                           *
\***************************************************************************/
#include "precomp.h"
#include "disasm.h"
#include "matrix.h"
#include "profiler.h"

DWORD g_dwLastError;

/*
 * nvuclGetInterface
 *
 * instanciate a object of class dwIdentifier & returns it through 
 * ppInterface
 */
NVUCL_RESULT NVUCL_EXPORT NVUCL_STDCALL nvuclGetInterface
(
    DWORD   dwIdentifier,
    void  **ppInterface
)
{
    /*
     * setup
     */
    *ppInterface  = NULL;
    g_dwLastError = NVUCL_ERROR_UNKNOWN;

    /*
     * create object
     */
    switch (dwIdentifier)
    {
        /*
         * profiler
         */
        case NVUCL_PROFILER_ID:
            *ppInterface = (void*)(new UCL_PROFILER);
            break;
        /*
         * matrix
         */
        case NVUCL_MATRIX_ID:
            *ppInterface = (void*)(new UCL_MATRIX);
            break;
        case NVUCL_DISASM_ID:
            *ppInterface = (void*)(new UCL_DISASM);
            break;
        /*
         * unknown
         */
        default:
            return NVUCL_ERROR_UNKNOWNINTERFACE;
    }

    /*
     * return
     */
    return (*ppInterface) ? NVUCL_OK : g_dwLastError;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\common\nv4\src\ddmini16.c ===
/*==========================================================================;
 *
 *  Copyright (C) 1995 Microsoft Corporation.  All Rights Reserved.
 *  Portions Copyright (C) 1995,1997 NVidia Corporation.  All Rights Reserved.
 *
 *  File:       ddmini16.c
 *  Content:    Windows95 Direct Draw driver
 *
 *  exported functions:
 *      ddEnable
 *      ddDisable
 *      Control
 *
 *  internal functions:
 *      FindMode
 *      GetRegInt
 *      GetFlatSel
 *
 *  public functions:
 *      none
 *
 ***************************************************************************/

#ifndef WINNT
#include "ddmini.h"
//#include "opengl.h"
#include "windows.h"
#else
#include "nv32.h"
#include "nvd3ddrv.h"
#endif // #ifdef WINNT
#include "nvcm.h"
#include "nvos.h"
#include "tvout.h"
#include  "escape.h"
#define  MSVC
#ifndef WINNT
#include "display.inc"
#endif // #ifndef WINNT
#ifdef  MULTI_MON
#include "nv432.h"
#include "nvrmarch.inc"
#include "nvddobj.h"
#endif  // MULTI_MON
#include "nvver.h"

#ifndef WINNT
#define NV_ERROR_NOTIFIER          0x0FF5
#define NV_DD_COMMON_DMA_BUFFER_SIZE 32768
#else // #ifdef WINNT
#define NV_ERROR_NOTIFIER           NV01_CONTEXT_DMA
#define SIZEOF_NVNOTIFICATION 16

//
// Redefine Obsolete class.
//
#ifdef NV01_CONTEXT_DMA_TO_MEMORY
#undef NV01_CONTEXT_DMA_TO_MEMORY
#endif // #ifdef NV01_CONTEXT_DMA_TO_MEMORY
#define NV01_CONTEXT_DMA_TO_MEMORY  NV01_CONTEXT_DMA
#endif // #ifdef WINNT


//
// Video RAM types
//
#define BUFFER_DRAM                     0
#define BUFFER_SGRAM                    1
#define BUFFER_SDRAM                    2
//
// Monitor types
//
#define NV_MONITOR_VGA                  0
#define NV_MONITOR_NTSC                 2
#define NV_MONITOR_PAL                  3
//
// TV Out Device
//
#define NV_TV_OUT_NO_DEVICE             0
#define NV_TV_OUT_CHRONTEL7003          1
#define NV_TV_OUT_BT868                 2
#define NV_TV_OUT_BT869                 3

typedef VIDEOPARAMETERS FAR *LPVIDEOPARAMETERS;

#ifndef  MULTI_MON  // Generate the old structure used by the old code

typedef struct {
    DWORD function;
    DWORD device;
    WORD  owner[2];
    DWORD type;
    DWORD depth;
    DWORD width;
    DWORD height;
    DWORD pitch;
    DWORD offset;
    DWORD size;
    DWORD address;
    DWORD limit;
    DWORD total;
    DWORD free;
    DWORD status;
} NVIOControl_ParamX;

#endif   // NOT MULTI_MON

#ifndef WINNT
extern void (FAR PASCAL *NVSYSCLOSE)(DWORD);
#ifdef  MULTI_MON
extern void (FAR PASCAL *NVALLOCBUFFER)(BYTE FAR *lpBufferFlat, BYTE FAR *lpBuffer, DWORD numPages, DWORD dwDeviceID);
#else   // MULTI_MON
extern void (FAR PASCAL *NVALLOCBUFFER)(BYTE FAR *lpBufferFlat, BYTE FAR *lpBuffer, DWORD numPages);
#endif  // MULTI_MON

#ifdef  MULTI_MON
extern DWORD (FAR PASCAL *NvGetConfig)(DWORD dwConfigID, DWORD dwDeviceID);
extern DWORD (FAR PASCAL *NvGetRAMInfo)(DWORD dwDeviceID);
extern DWORD (FAR PASCAL *NvGetScreenSize)(DWORD dwDeviceID);
extern DWORD (FAR PASCAL *NvGetFrameBufferInfo)(DWORD dwDeviceID);
extern DWORD (FAR PASCAL *NvGetDeviceBase)(DWORD, DWORD dwDeviceID);
extern DWORD (FAR PASCAL *NvGetDeviceLimit)(DWORD, DWORD dwDeviceID);
extern void (FAR PASCAL *Nv01AllocContextDma)(Alloc_Ctx_DMA_Param FAR *);
extern void (FAR PASCAL *Nv01Free)(NV01Free_Param FAR *);
#else   // MULTI_MON
extern DWORD (FAR PASCAL *NvGetConfig)(DWORD dwConfigID);
extern DWORD (FAR PASCAL *NvGetRAMInfo)(VOID);
extern DWORD (FAR PASCAL *NvGetScreenSize)(VOID);
extern DWORD (FAR PASCAL *NvGetFrameBufferInfo)(VOID);
extern DWORD (FAR PASCAL *NvGetDeviceBase)(DWORD);
extern DWORD (FAR PASCAL *NvGetDeviceLimit)(DWORD);
#endif  // MULTI_MON
extern DWORD (FAR PASCAL *NvIOControl)(DWORD Function, LPVOID pParameters);
extern WORD FAR PASCAL UnsDwordDiv(DWORD dividend, DWORD divisor);
extern DWORD FAR PASCAL UnsDwordMul(DWORD multiplicand, DWORD multiplier);
extern DWORD FAR PASCAL GetFlatAddress(DWORD);
extern DWORD FAR PASCAL SetMacrovisionMode(DWORD mode);
#else // #ifdef WINNT
#define NVALLOCBUFFER(pflatptr, nop, numpages, nop1) \
    (pflatptr) = EngAllocMem(FL_ZERO_MEMORY, (numpages) * 4096, ALLOC_TAG)

#define NV_ALLOC_CONTEXT_DMA(hPar, hObj, clas, fl, offs, sel, limlo, limhi) \
    NvAllocContextDma(lpDevice->hDriver, (hPar), (hObj), (clas), (fl), (offs), (limlo))
#define NvGetConfig(dwConfigID, dwDeviceID) \
    (NvConfigGet(lpDevice->hDriver, lpDevice->hClient, lpDevice->hDevice, dwConfigID, &lpDevice->DummyReturn) == NVOS13_STATUS_SUCCESS ? lpDevice->DummyReturn : 0)
#define NvGetRAMInfo(dwDeviceID)            \
    ((lpDevice->cbFrameBuf >> 19) << 20)
#define NvGetScreenSize(dwDeviceID) \
    ((lpDevice->cyScreen << 16) | (lpDevice->cxScreen & 0xffff))
#define NvGetFrameBufferInfo(dwDeviceID) \
    (lpDevice->cBitsPerPel)
#define NvGetDeviceBase(dev, dwDeviceID) \
    (lpDevice->NvBaseAddr)
#define NvGetDeviceLimit(dev, dwDeviceID) \
    (lpDevice->cbFrameBuf + 1)
#define NV01Free_Param  NVOS00_PARAMETERS
#define Nv01Free(param) \
    NvFree(lpDevice->hDriver, (ULONG)param.hRoot, (ULONG)param.hObjectParent, (ULONG)param.hObjectOld)
#define NVSYSCLOSE(channel) \
    NvFree(lpDevice->hDriver, lpDevice->hClient, lpDevice->hDevice, channel)
#define dmaD3DPusherNotifier \
    (lpDevice->dmaD3DPusherNotifier)
#define dmaGDIPusherNotifier \
    (lpDevice->NvSyncNotifierFlat)
#define UnsDwordDiv(a, b) \
    (a / b)
#define UnsDwordMul(a, b) \
    (a * b)
#endif // #ifdef WINNT



#ifndef WINNT
extern LONG FAR PASCAL Control32(DIBENGINE FAR *, UINT, LPVOID, LPVOID);
extern void (FAR PASCAL DepopulateOffscreenCache)(void);

extern WORD PASCAL wSurfaceBUSY;
extern DWORD PASCAL NV_ddDmaBuffer;
extern DWORD PASCAL dmaGDIPusherNotifier;
extern DWORD PASCAL dmaD3DPusherNotifier;
extern OFFSCREENINITPARAMS PASCAL offscreenData;
extern DDHALMODEINFO NEAR *ModeList;

extern DDHALMODEINFO NEAR *ModeList;
extern DDHALMODEINFO NEAR NV4VGAModeList[];
extern DDHALMODEINFO NEAR NV4NTSCModeList[];
extern DDHALMODEINFO NEAR NV4PALModeList[];
extern int numModes;
extern int numNV4VGAModes;
extern int numNV4PALModes;
extern int numNV4NTSCModes;
#endif // #ifndef WINNT

#ifndef WINNT
extern int PASCAL videoRamSize;
extern int PASCAL wMonitorType;
extern DWORD PASCAL dwTVOutDeviceID;
#else
extern int videoRamSize;
extern int wMonitorType;
extern DWORD dwTVOutDeviceID;
#endif

#ifdef  MULTI_MON
#ifndef WINNT
// Global variables for multimonitor support
extern  DWORD PASCAL dwRoot_Handle;         // From ENABLE.ASM - RM id for client
extern  DWORD PASCAL dwDevice_ID_Num;       // From ENABLE.ASM - RM id for display
extern  DWORD        dwDeviceHandle;        // From DRV2.C - VDD id for display
extern  WORD  PASCAL wFlatSelector;         // From ENABLE.ASM - Ring3 flat selector
#else
#define dwRoot_Handle (lpDevice->hClient)
#define dwDevice_ID_Num (lpDevice->ulDeviceReference)
#define wFlatSelector 0
#endif // #ifdef WINNT
#endif  // MULTI_MON

/***************************************************************************
 *
 * globals
 *
 ***************************************************************************/

int             firstTimeCall = 1;
#ifndef WINNT
GLOBALDATA      DriverData;
#else // #ifdef WINNT
#define DriverData (*(lpDevice->pDriverData))
#endif // #ifdef WINNT
DWORD           macrovisionKey = 0x9999;
DWORD           macrovisionMode = 0;

/***************************************************************************
 *
 * internal functions.
 *
 ***************************************************************************/

UINT  GetFlatSel(void);
BOOL  DDCreateDriverObject(BOOL bReset);

#ifndef WINNT
/***************************************************************************
 *
 * FindMode
 *
 *  search through the mode table and find a mode that matchs
 *  call the HWTestMode function in setmode.c to make sure the
 *  mode is valid.
 *
 *  returns mode number 0-N if we found a valid mode
 *  returns -1 if we cant find a valid mode.
 *
 ***************************************************************************/

int PASCAL FindMode(DWORD dwWidth, DWORD dwHeight, DWORD dwBPP)
{
    int i;

    for (i=0; ModeList[i].dwWidth!=0; i++)
    {
        if (ModeList[i].dwWidth == dwWidth &&
            ModeList[i].dwHeight == dwHeight &&
            ModeList[i].dwBPP == dwBPP &&
            HWTestMode(i))
        {
            return i;
        }
    }

    return -1;
}
#endif // #ifndef WINNT

/***************************************************************************
 *
 * ddEnable   called by Enable to enable the device and set the video mode
 *
 ***************************************************************************/
#ifndef WINNT
UINT FAR PASCAL _loadds ddEnable(LPVOID lpDevice, UINT style, LPSTR lpDeviceType, LPSTR lpOutput, LPVOID lpStuff)
#else
ULONG ddEnable(PDEV *lpDevice)
#endif // #ifdef WINNT
{
    int   ModeNumber = 0;
    DWORD dwResolutionX;
    DWORD dwResolutionY;
    DWORD dwBPP;
    DWORD dwFrameBufferInfo;
    DWORD dwResolutionInfo;
    DWORD mclk;
    DWORD videoRamType;
#ifdef  MULTI_MON
    NVOS00_PARAMETERS freeParams;
#endif  // MULTI_MON

    //
    // If firstTimeCall connect to NV Resource Manager
    //
    if (firstTimeCall) {
        DriverData.NvFirstCall = 1;    // let 32 bit DDraw driver know to reset NV
        DriverData.dwGlobalStructSize = sizeof(GLOBALDATA); // let 32 bit DDraw driver know current struct size

#ifdef  MULTI_MON
        DriverData.TotalVRAM = NvGetRAMInfo( dwDevice_ID_Num ) >> 16;
        DriverData.TotalVRAM <<= 20; // convert MB to bytes
        DriverData.dwRootHandle = dwRoot_Handle;
  #ifndef WINNT
        DriverData.dwDeviceHandle = dwDeviceHandle;
        DriverData.dwDeviceIDNum = dwDevice_ID_Num;
        DriverData.dwDeviceClass = dwDevice_ID_Num + (NV01_DEVICE_0 - 1); // RM numbering starts at 1
        NVALLOCBUFFER((BYTE FAR *)&DriverData.NvCommonDmaBufferFlat,
            (BYTE FAR *)&DriverData.lpNvDmaBuffer, 8, DriverData.dwDeviceIDNum);
  #else
        DriverData.dwDeviceHandle = (DWORD)lpDevice->hDevice;
        DriverData.dwDeviceIDNum = dwDevice_ID_Num;
        DriverData.dwDeviceClass = dwDevice_ID_Num + (NV01_DEVICE_0 - 1); // RM numbering starts at 1
        NVALLOCBUFFER((PVOID)DriverData.NvCommonDmaBufferFlat, 0, 8, 0);
  #endif // #ifdef WINNT

#else   // MULTI_MON
        DriverData.TotalVRAM = NvGetRAMInfo() >> 16;
        DriverData.TotalVRAM <<= 20; // convert MB to bytes

        NVALLOCBUFFER((BYTE FAR *)&DriverData.NvCommonDmaBufferFlat,
            (BYTE FAR *)&DriverData.lpNvDmaBuffer, 8);
#endif  // MULTI_MON

        if (DriverData.NvCommonDmaBufferFlat == 0)
            return FALSE;

#ifdef  MULTI_MON

        /*
         * Allocate the Context Dmas that don't change until this board gets disabled
         *    They are never freed by us, we depend on the root closure in WEP to
         *    destroy them for us when the display driver gets unloaded.
         */

        NV_ALLOC_CONTEXT_DMA(DriverData.dwRootHandle,
            NV_DD_DMA_CONTEXT_ERROR_TO_MEMORY,
            NV_ERROR_NOTIFIER,
            ALLOC_CTX_DMA_FLAGS_LOCKED_CACHED,
            (PVOID)DriverData.NvCommonDmaBufferFlat,
            (DWORD)wFlatSelector,
            SIZEOF_NVNOTIFICATION - 1, /* required size for notifier */
            0);

//        Nv01AllocContextDma((Alloc_Ctx_DMA_Param FAR *)&allocContextDmaParams);

//        if (allocContextDmaParams.status != ALLOC_CTX_DMA_STATUS_SUCCESS)
//            return FALSE;

        NV_ALLOC_CONTEXT_DMA(DriverData.dwRootHandle,
            NV_DD_DMA_TO_MEM_NOTIFIER_CONTEXT_DMA_TO_MEMORY,
            NV01_CONTEXT_DMA,
            ALLOC_CTX_DMA_FLAGS_ACCESS_WRITE_ONLY,
            (PVOID)DriverData.NvCommonDmaBufferFlat,
            (DWORD)wFlatSelector,
            SIZEOF_NVNOTIFICATION - 1, /* required size for notifier */
            0);

//        Nv01AllocContextDma((Alloc_Ctx_DMA_Param FAR *)&allocContextDmaParams);

//        if (allocContextDmaParams.status != ALLOC_CTX_DMA_STATUS_SUCCESS)
//            return FALSE;

        NV_ALLOC_CONTEXT_DMA(DriverData.dwRootHandle,
            NV_DD_DMA_BUFFER_NOTIFIER_CONTEXT_DMA_TO_MEMORY,
            NV01_CONTEXT_DMA,
            ALLOC_CTX_DMA_FLAGS_ACCESS_WRITE_ONLY,
            (PVOID)DriverData.NvCommonDmaBufferFlat,
            (DWORD)wFlatSelector,
            (2 * SIZEOF_NVNOTIFICATION) - 1, /* required size for notifier */
            0);

//        Nv01AllocContextDma((Alloc_Ctx_DMA_Param FAR *)&allocContextDmaParams);

//        if (allocContextDmaParams.status != ALLOC_CTX_DMA_STATUS_SUCCESS)
//            return FALSE;

        NV_ALLOC_CONTEXT_DMA(DriverData.dwRootHandle,
            NV_DD_DMA_FROM_MEM_NOTIFIER_CONTEXT_DMA_TO_MEMORY,
            NV01_CONTEXT_DMA,
            ALLOC_CTX_DMA_FLAGS_ACCESS_WRITE_ONLY,
            (PVOID)(DriverData.NvCommonDmaBufferFlat + (SIZEOF_NVNOTIFICATION << 1)),
            (DWORD)wFlatSelector,
            SIZEOF_NVNOTIFICATION - 1, /* required size for notifier */
            0);

//        Nv01AllocContextDma((Alloc_Ctx_DMA_Param FAR *)&allocContextDmaParams);
//
//        if (allocContextDmaParams.status != ALLOC_CTX_DMA_STATUS_SUCCESS)
//            return FALSE;

        NV_ALLOC_CONTEXT_DMA(DriverData.dwRootHandle,
            NV_DD_DMA_PUSHER_SYNC_NOTIFIER_CONTEXT_DMA_TO_MEMORY,
            NV01_CONTEXT_DMA,
            ALLOC_CTX_DMA_FLAGS_ACCESS_WRITE_ONLY,
            (PVOID)(DriverData.NvCommonDmaBufferFlat + (SIZEOF_NVNOTIFICATION << 1) +
            SIZEOF_NVNOTIFICATION),
            (DWORD)wFlatSelector,
            SIZEOF_NVNOTIFICATION - 1, /* required size for notifier */
            0);

//        Nv01AllocContextDma((Alloc_Ctx_DMA_Param FAR *)&allocContextDmaParams);
//
//        if (allocContextDmaParams.status != ALLOC_CTX_DMA_STATUS_SUCCESS)
//            return FALSE;

        NV_ALLOC_CONTEXT_DMA(DriverData.dwRootHandle,
            NV_DD_DMA_SYNC_NOTIFIER_CONTEXT_DMA_TO_MEMORY,
            NV01_CONTEXT_DMA,
            ALLOC_CTX_DMA_FLAGS_ACCESS_WRITE_ONLY,
            (PVOID)(DriverData.NvCommonDmaBufferFlat + (SIZEOF_NVNOTIFICATION << 2)),
            (DWORD)wFlatSelector,
            SIZEOF_NVNOTIFICATION - 1, /* required size for notifier */
            0);

//        Nv01AllocContextDma((Alloc_Ctx_DMA_Param FAR *)&allocContextDmaParams);
//
//        if (allocContextDmaParams.status != ALLOC_CTX_DMA_STATUS_SUCCESS)
//            return FALSE;

        NV_ALLOC_CONTEXT_DMA(DriverData.dwRootHandle,
            NV_DD_DMA_FLIP_PRIMARY_NOTIFIER_CONTEXT_DMA_TO_MEMORY,
            NV01_CONTEXT_DMA,
            ALLOC_CTX_DMA_FLAGS_ACCESS_WRITE_ONLY,
            (PVOID)(DriverData.NvCommonDmaBufferFlat + (SIZEOF_NVNOTIFICATION << 2) +
            SIZEOF_NVNOTIFICATION),
            (DWORD)wFlatSelector,
            (5 * SIZEOF_NVNOTIFICATION) - 1, /* required size for notifier */
            0);

//        Nv01AllocContextDma((Alloc_Ctx_DMA_Param FAR *)&allocContextDmaParams);
//
//        if (allocContextDmaParams.status != ALLOC_CTX_DMA_STATUS_SUCCESS)
//            return FALSE;

        NV_ALLOC_CONTEXT_DMA(DriverData.dwRootHandle,
            NV_DD_PIO_FLIP_OVERLAY_NOTIFIER_CONTEXT_DMA_TO_MEMORY,
            NV01_CONTEXT_DMA,
            ALLOC_CTX_DMA_FLAGS_ACCESS_WRITE_ONLY,
            (PVOID)(DriverData.NvCommonDmaBufferFlat + (SIZEOF_NVNOTIFICATION << 3) +
            (SIZEOF_NVNOTIFICATION << 1)),
            (DWORD)wFlatSelector,
            (5 * SIZEOF_NVNOTIFICATION) - 1, /* required size for notifier */
            0);

//        Nv01AllocContextDma((Alloc_Ctx_DMA_Param FAR *)&allocContextDmaParams);
//
//        if (allocContextDmaParams.status != ALLOC_CTX_DMA_STATUS_SUCCESS)
//            return FALSE;

        NV_ALLOC_CONTEXT_DMA(DriverData.dwRootHandle,
            NV_DD_DMA_CONTEXT_DMA_TO_SYSTEM_MEMORY,
            NV01_CONTEXT_DMA,
            ALLOC_CTX_DMA_FLAGS_ACCESS_WRITE_ONLY,
            (PVOID)DriverData.NvCommonDmaBufferFlat,
            (DWORD)wFlatSelector,
            NV_DD_COMMON_DMA_BUFFER_SIZE - 1,
            0);

//        Nv01AllocContextDma((Alloc_Ctx_DMA_Param FAR *)&allocContextDmaParams);
//
//        if (allocContextDmaParams.status != ALLOC_CTX_DMA_STATUS_SUCCESS)
//            return FALSE;

        NV_ALLOC_CONTEXT_DMA(DriverData.dwRootHandle,
            NV_DD_DMA_CONTEXT_DMA_FROM_SYSTEM_MEMORY,
            NV01_CONTEXT_DMA,
            ALLOC_CTX_DMA_FLAGS_ACCESS_READ_ONLY,
            (PVOID)DriverData.NvCommonDmaBufferFlat,
            (DWORD)wFlatSelector,
            NV_DD_COMMON_DMA_BUFFER_SIZE - 1,
            0);

//        Nv01AllocContextDma((Alloc_Ctx_DMA_Param FAR *)&allocContextDmaParams);
//
//        if (allocContextDmaParams.status != ALLOC_CTX_DMA_STATUS_SUCCESS)
//            return FALSE;

        /*
         * Let the 32 bit DDraw code know that the following Context Dmas have not yet
         * been allocated.
         */

        DriverData.dwVidMemCtxDmaSize = 0;
        DriverData.dwDmaPusherCtxDmaSize = 0;


#endif  /* MULTI_MON */

        DriverData.NvDevFlatDma = 0;
        DriverData.NvDmaPusherBufferHandle = 0;
        DriverData.NvDmaPusherBufferBase = 0;
        DriverData.NvDevVideoFlatPio = 0;
        DriverData.NvDevFlatVPE = 0;
        DriverData.DDrawVideoSurfaceCount = 0;
        DriverData.GARTLinearBase = 0;
        DriverData.GARTPhysicalBase = 0;
        DriverData.NvAGPDmaPusherBufferBase = 0;
        DriverData.NvDmaPusherBufferSize = 0;
        DriverData.NvDmaPusherBufferEnd = 0;

        // initialize mode switch counter
        DriverData.dwModeSwitchCount = 0;

        // initialize shared clip change counter
        DriverData.dwSharedClipChangeCount = 0;
        DriverData.dwDDMostRecentClipChangeCount = 0;

        DriverData.wDDrawActive = 0;

        DriverData.dwMacrovisionNavigatorID = 0;
#ifndef WINNT
        firstTimeCall = 0;
#endif
    } else {
#ifdef  MULTI_MON
        if (DriverData.NvDevFlatDma != 0) {
            freeParams.hRoot = DriverData.dwRootHandle;
            freeParams.hObjectParent = NV_WIN_DEVICE;
            freeParams.hObjectOld = NV_DD_DEV_DMA;

#ifndef WINNT
            Nv01Free((NV01Free_Param FAR *)&freeParams);
#else
            Nv01Free(&freeParams);
#endif

            DriverData.NvDevFlatDma = 0;
        }
        if (DriverData.NvDevVideoFlatPio != 0) {
            freeParams.hRoot = DriverData.dwRootHandle;
            freeParams.hObjectParent = NV_WIN_DEVICE;
            freeParams.hObjectOld = NV_DD_DEV_VIDEO;

#ifndef WINNT
            Nv01Free((NV01Free_Param FAR *)&freeParams);
#else
            Nv01Free(&freeParams);
#endif

            DriverData.NvDevVideoFlatPio = 0;
        }
        if (DriverData.NvDevFlatVPE != 0) {
            freeParams.hRoot = DriverData.dwRootHandle;
            freeParams.hObjectParent = NV_WIN_DEVICE;
            freeParams.hObjectOld = NV_DD_DEV_VPE;

#ifndef WINNT
            Nv01Free((NV01Free_Param FAR *)&freeParams);
#else
            Nv01Free(&freeParams);
#endif

            DriverData.NvDevFlatVPE = 0;
        }
#else   /* MULTI_MON */
        if (DriverData.NvDevFlatDma != 0) {
            NVSYSCLOSE(DriverData.NvDevFlatDma);
            DriverData.NvDevFlatDma = 0;
        }
        if (DriverData.NvDevVideoFlatPio != 0) {
            NVSYSCLOSE(DriverData.NvDevVideoFlatPio);
            DriverData.NvDevVideoFlatPio = 0;
        }
        if (DriverData.NvDevFlatVPE != 0) {
            NVSYSCLOSE(DriverData.NvDevFlatVPE);
            DriverData.NvDevFlatVPE = 0;
        }
#endif  /* MULTI_MON */
    }

#ifdef  MULTI_MON
    dwResolutionInfo  = NvGetScreenSize( DriverData.dwDeviceIDNum );
    dwFrameBufferInfo = NvGetFrameBufferInfo( DriverData.dwDeviceIDNum );
#else   // MULTI_MON
    dwResolutionInfo  = NvGetScreenSize();
    dwFrameBufferInfo = NvGetFrameBufferInfo();
#endif  // MULTI_MON
    dwResolutionX = LOWORD(dwResolutionInfo);
    dwResolutionY = HIWORD(dwResolutionInfo);
    dwBPP = dwFrameBufferInfo & 0xFFFF;

#ifdef  MULTI_MON
    mclk = NvGetConfig( NV_CFG_DAC_MEMORY_CLOCK, DriverData.dwDeviceIDNum );
    videoRamType = NvGetConfig( NV_CFG_RAM_TYPE, DriverData.dwDeviceIDNum );
#else   // MULTI_MON
    mclk = NvGetConfig( NV_CFG_DAC_MEMORY_CLOCK );
    videoRamType = NvGetConfig( NV_CFG_RAM_TYPE );
#endif  // MULTI_MON

#ifndef WINNT
    ModeList = &NV4VGAModeList[0];
    numModes = numNV4VGAModes;

    if (wMonitorType == NV_MONITOR_PAL) {
        ModeList = &NV4PALModeList[0];
        numModes = numNV4PALModes;
    }

    if (wMonitorType == NV_MONITOR_NTSC) {
        ModeList = &NV4NTSCModeList[0];
        numModes = numNV4NTSCModes;
    }

    //
    // see if the mode is valid.
    // if it is not a mode we can support we fail
    //
    ModeNumber = FindMode(dwResolutionX, dwResolutionY, dwBPP);

    //
    // InquireInfo means fill in a GDIINFO structure
    // that describes the mode and the capabilities of the device
    //
    // we call DIB_Enable() and modify the fields specific to our
    // driver.
    //
    // NOTE you should never set (ie assign to) the dpRasterCaps
    // or dpCaps1 fields.  you should set specific bits (|=val), or in
    // rare cases clear a bit (&=~val).
    //
    // return the size of the structure we filled in.
    //
    if (style == InquireInfo) {
        return TRUE;
    }
    //
    //  EnableDevice means actualy set the mode.
    //  return zero for fail, non zero for success.
    //
    if (style == EnableDevice)
#endif // #ifndef WINNT
    {
#ifndef WINNT
        DIBENGINE FAR *pde;
#endif // #ifndef WINNT

        //
        // call the code in setmode.c to set the mode
        //
        // if HWSetMode works we expect the following globals
        // to be set.
        //
        //      DriverData.TotalVRAM        ; total amount of VRAM
        //      DriverData.BaseAddress      ; *flat* address of frame buffer (if flat)
        //      DriverData.ScreenSel        ; selector to framebuffer (if vflatd)
        //

//        HWSetMode(ModeNumber);

#if defined(NVHP) && !defined(WINNT)
        if (ModeNumber >= 0)
        {
            //
            // Allocate the primary display surface from the heap.
            //

            //
            // First clear out anything lying around.
            //
#ifdef  MULTI_MON
            NVIOControl_Param   heapParams;


            heapParams.hRoot         = DriverData.dwRootHandle;
            heapParams.hObjectParent = NV_WIN_DEVICE;
            heapParams.owner         = (((DWORD)'NV') << 16) + 'DD';
#else   // MULTI_MON
            NVIOControl_ParamX  heapParams;


            heapParams.device   = 0;
            heapParams.owner[0] = 'DD';
            heapParams.owner[1] = 'NV';
#endif  // MULTI_MON
            heapParams.function = NVIOCONTROL_HEAP_PURGE;
            NvIOControl( NVIOCONTROL_ARCH_HEAP, (LPVOID)&heapParams );

            //
            // Allocate  primary surface.
            //
#ifdef  MULTI_MON
            heapParams.hRoot         = DriverData.dwRootHandle;
            heapParams.hObjectParent = NV_WIN_DEVICE;
            heapParams.owner         = (((DWORD)'NV') << 16) + 'DD';
#else   // MULTI_MON
            heapParams.device   = 0;
            heapParams.owner[0] = 'DD';
            heapParams.owner[1] = 'NV';
#endif  // MULTI_MON
            heapParams.function = NVIOCONTROL_HEAP_ALLOC_DEPTH_WIDTH_HEIGHT;
            heapParams.type     = NVIOCONTROL_TYPE_PRIMARY;
            heapParams.depth    = dwBPP;
            heapParams.width    = ModeList[ModeNumber].dwWidth;
            heapParams.height   = ModeList[ModeNumber].dwHeight;
            NvIOControl( NVIOCONTROL_ARCH_HEAP, (LPVOID)&heapParams );

            DriverData.BaseAddress    = heapParams.address;  // *flat* address
            DriverData.VideoHeapBase  = heapParams.limit + 1;
            DriverData.VideoHeapTotal = heapParams.free;
            DriverData.VideoHeapFree  = heapParams.free;
        }
#else   // NVHP
        // fill in the framebuffer address
#ifdef  MULTI_MON
#ifndef WINNT
        DriverData.BaseAddress = NvGetDeviceBase( NV_DEV_BUFFER_0, DriverData.dwDeviceIDNum ); // *flat* address
#else // WINNT
        DriverData.BaseAddress = 0;
#endif // #ifdef WINNT
#else   // MULTI_MON
        DriverData.BaseAddress = NvGetDeviceBase( NV_DEV_BUFFER_0 );  // *flat* address
#endif  // MULTI_MON
        if (ModeNumber >= 0)
#ifndef WINNT
            DriverData.VideoHeapBase = DriverData.BaseAddress +
                UnsDwordMul(ModeList[ModeNumber].lPitch, ModeList[ModeNumber].dwHeight);
#else
            DriverData.VideoHeapBase = DriverData.BaseAddress +
                UnsDwordMul(lpDevice->lDelta, lpDevice->cyScreen);
 #endif // #ifdef WINNT

#endif  // NVHP

#ifdef  MULTI_MON
#ifndef WINNT
        DriverData.NvBaseFlat = NvGetDeviceBase( NV_DEV_BASE, DriverData.dwDeviceIDNum );  // *flat* address
#else
        DriverData.NvBaseFlat = (DWORD)lpDevice->NvBaseAddr;
#endif // #ifdef WINNT
#else   // MULTI_MON
        DriverData.NvBaseFlat = NvGetDeviceBase( NV_DEV_BASE );  // *flat* address
#endif  // MULTI_MON
        DriverData.ScreenSel     = GetFlatSel();
        DriverData.flatSelector = (USHORT)GetFlatSel();
#ifdef  MULTI_MON
        dwResolutionInfo = NvGetScreenSize( DriverData.dwDeviceIDNum );
        dwFrameBufferInfo = NvGetFrameBufferInfo( DriverData.dwDeviceIDNum );
#else   // MULTI_MON
        dwResolutionInfo = NvGetScreenSize();
        dwFrameBufferInfo = NvGetFrameBufferInfo();
#endif  // MULTI_MON

        dwFrameBufferInfo &= 0xFFFF;

        if (dwFrameBufferInfo == 8) { // Pixel depth
            DriverData.physicalColorMask = 0xFF;
        } else if (dwFrameBufferInfo == 16) {
            DriverData.physicalColorMask = 0xFFFF;
        } else if (dwFrameBufferInfo == 32) {
            DriverData.physicalColorMask = 0xFFFFFF;
        }

#ifdef  MULTI_MON
#ifndef WINNT
        DriverData.VideoHeapEnd = NvGetDeviceLimit( NV_DEV_BUFFER_0, DriverData.dwDeviceIDNum );
#else
        DriverData.VideoHeapEnd = lpDevice->cbFrameBuf - 1;
#endif // #ifdef WINNT
#else   // MULTI_MON
        DriverData.VideoHeapEnd = NvGetDeviceLimit( NV_DEV_BUFFER_0 );
#endif  // MULTI_MON
#ifndef WINNT
        /* Let display driver caching mechanism know it's usable range */
        offscreenData.left   = 0;
        offscreenData.top    = (unsigned short) dwResolutionY;

        if (ModeNumber >= 0)
            DriverData.maxOffScreenY =
                UnsDwordDiv(DriverData.VideoHeapEnd, ModeList[ModeNumber].lPitch);
#else

//
// Now initialized in ResetNV
//
DriverData.maxOffScreenY =
            UnsDwordDiv(DriverData.VideoHeapEnd, lpDevice->lDelta);
#endif // #ifdef WINNT

#ifndef WINNT
        offscreenData.right  = (unsigned short) dwResolutionX;
        offscreenData.bottom = (unsigned short) DriverData.maxOffScreenY;
#endif // #ifndef WINNT
        DriverData.VideoHeapEnd += DriverData.BaseAddress;

        //
        // now fill in a BITMAPINFO that describes our mode
        // and call the DIBENG function CreateDIBPDevice to
        // fill in our PDevice
        //
        DriverData.bi.biSize        = sizeof(BITMAPINFOHEADER);
        DriverData.bi.biPlanes      = 1;
#ifdef WINNT
        DriverData.bi.biWidth       = lpDevice->cxScreen;
        DriverData.bi.biHeight      = lpDevice->cyScreen;
        DriverData.bi.biBitCount    = (USHORT)lpDevice->cBitsPerPel;
        DriverData.bi.biCompression = 0;
        DriverData.color_table[0]   = lpDevice->flRed;
        DriverData.color_table[1]   = lpDevice->flGreen;
        DriverData.color_table[2]   = lpDevice->flBlue;
#else // #ifndef WINNT
        if (ModeNumber >= 0) {
            DriverData.bi.biWidth       = ModeList[ModeNumber].dwWidth;
            DriverData.bi.biHeight      = ModeList[ModeNumber].dwHeight;
            DriverData.bi.biBitCount    = (BYTE)ModeList[ModeNumber].dwBPP;
            DriverData.bi.biCompression = 0; // ModeList[ModeNumber].dwBPP <= 8 ? 0 : 3;
            DriverData.color_table[0]   = ModeList[ModeNumber].dwRBitMask;
            DriverData.color_table[1]   = ModeList[ModeNumber].dwGBitMask;
            DriverData.color_table[2]   = ModeList[ModeNumber].dwBBitMask;
        } else {
            DriverData.ModeNumber       = ModeNumber; // 32 bit code needs this
            DriverData.bi.biWidth       = dwResolutionInfo & 0xFFFF;
            DriverData.bi.biHeight      = dwResolutionInfo >> 16;
            DriverData.bi.biBitCount = (BYTE)dwBPP;
            DriverData.bi.biCompression = 0; // ModeList[ModeNumber].dwBPP <= 8 ? 0 : 3;
            DriverData.NvPrevDepth = 0;
            return FALSE;
        }

        //
        //  set a few things in the DIBENGINE structure that CreateDIBPDevice
        //  did not do.
        //
        pde = (DIBENGINE FAR *)lpDevice;

        pde->deBitsSelector = (UINT)DriverData.ScreenSel;
        pde->deBits = (void NVFAR *)DriverData.BaseAddress;

        if (ModeNumber >= 0)
            pde->deDeltaScan = ModeList[ModeNumber].lPitch;

        pde->deDriverReserved = 0x42;
        pde->deBeginAccess = (void FAR *)BeginAccess;
        pde->deEndAccess = (void FAR *)EndAccess;

        if (dwFrameBufferInfo == 8)
            pde->deFlags |= PALETTIZED;
        else
            pde->deFlags &= ~PALETTIZED;

        if (dwFrameBufferInfo == 16)
            pde->deFlags |= FIVE6FIVE;
        else
            pde->deFlags &= ~FIVE6FIVE;

        pde->deFlags &= ~BUSY;       // device is not BUSY
        pde->deFlags &= ~BANKEDVRAM;
        wSurfaceBUSY = 0;
#endif // #ifndef WINNT
        //
        // Everything worked remember the mode number and the driver
        // PDevice and return success
        //
        DriverData.dwVersion = DDMINI_VERSION;
        DriverData.ModeNumber = ModeNumber;
#ifndef WINNT
        DriverData.lpPDevice = (void FAR *)lpDevice;
#else
        DriverData.lpPDevice = (DWORD)lpDevice;
#endif
        DriverData.fReset = TRUE;

        DriverData.fVidMemLocked = FALSE;

        //
        // Let 32 bit Direct Draw know that there are currently no external users
        // (like NVLIB, NVDDX, etc)
        //
        DriverData.fActiveExternalUser = FALSE;

        //
        // Let Direct Draw know about Display Driver's notifier
        //
        DriverData.NvWinDmaPusherNotifierFlat = (DWORD)dmaGDIPusherNotifier;

        //
        // Let Display Driver know about Direct Draw's DMA pusher sync notifier
        //
        dmaD3DPusherNotifier = (DWORD *)DriverData.NvCommonDmaBufferFlat;
        dmaD3DPusherNotifier += (SIZEOF_NVNOTIFICATION << 1) + SIZEOF_NVNOTIFICATION;
#ifndef WINNT
        //
        // Now re-register with DirectDraw so it knows all about the
        // new display mode.
        //
        if (DriverData.HALCallbacks.lpSetInfo)
        {
            DDCreateDriverObject(TRUE);
        }
#endif // #ifndef WINNT
        return TRUE;
    }

    return FALSE;
}

/***************************************************************************
 *
 * Disable
 *
 ***************************************************************************/
#ifndef WINNT
UINT FAR PASCAL _loadds ddDisable(DIBENGINE FAR *pde)
#else
UINT FAR PASCAL _loadds ddDisable(PDEV *lpDevice)
#endif
{
#ifdef  MULTI_MON
    NV01Free_Param freeParams;
#endif  // MULTI_MON

#ifndef WINNT
    pde->deFlags |= BUSY;       // device is BUSY
    wSurfaceBUSY = 1;
#else

    /*
     * Free the Context Dmas.
     */

    NvFree(DriverData.ppdev->hDriver,
        DriverData.dwRootHandle,
        DriverData.dwRootHandle,
        NV_DD_DMA_CONTEXT_ERROR_TO_MEMORY
        );

    NvFree(DriverData.ppdev->hDriver,
        DriverData.dwRootHandle,
        DriverData.dwRootHandle,
        NV_DD_DMA_TO_MEM_NOTIFIER_CONTEXT_DMA_TO_MEMORY
        );

    NvFree(DriverData.ppdev->hDriver,
        DriverData.dwRootHandle,
        DriverData.dwRootHandle,
        NV_DD_DMA_BUFFER_NOTIFIER_CONTEXT_DMA_TO_MEMORY
        );

    NvFree(DriverData.ppdev->hDriver,
        DriverData.dwRootHandle,
        DriverData.dwRootHandle,
        NV_DD_DMA_FROM_MEM_NOTIFIER_CONTEXT_DMA_TO_MEMORY
        );

    NvFree(DriverData.ppdev->hDriver,
        DriverData.dwRootHandle,
        DriverData.dwRootHandle,
        NV_DD_DMA_PUSHER_SYNC_NOTIFIER_CONTEXT_DMA_TO_MEMORY
        );

    NvFree(DriverData.ppdev->hDriver,
        DriverData.dwRootHandle,
        DriverData.dwRootHandle,
        NV_DD_DMA_SYNC_NOTIFIER_CONTEXT_DMA_TO_MEMORY
        );

    NvFree(DriverData.ppdev->hDriver,
        DriverData.dwRootHandle,
        DriverData.dwRootHandle,
        NV_DD_DMA_FLIP_PRIMARY_NOTIFIER_CONTEXT_DMA_TO_MEMORY
        );

    NvFree(DriverData.ppdev->hDriver,
        DriverData.dwRootHandle,
        DriverData.dwRootHandle,
        NV_DD_PIO_FLIP_OVERLAY_NOTIFIER_CONTEXT_DMA_TO_MEMORY
        );

    NvFree(DriverData.ppdev->hDriver,
        DriverData.dwRootHandle,
        DriverData.dwRootHandle,
        NV_DD_DMA_CONTEXT_DMA_TO_SYSTEM_MEMORY
        );

    NvFree(DriverData.ppdev->hDriver,
        DriverData.dwRootHandle,
        DriverData.dwRootHandle,
        NV_DD_DMA_CONTEXT_DMA_FROM_SYSTEM_MEMORY
        );

    /*
     * If this is WINNT we need to free per device common DMA buffer
     * which under Win9x is freed when the 16 bit driver instance (created
     * for each device) is destroyed.
     */
    if (DriverData.NvCommonDmaBufferFlat != 0) {
        EngFreeMem((PVOID)DriverData.NvCommonDmaBufferFlat);
        DriverData.NvCommonDmaBufferFlat = 0;
    }

    /*
     * Under WINNT we also need to free the DMA push buffer, which under
     * Win9x is freed by the 16 bit display driver's WEP exit point.
     */
    if (DriverData.NvDmaPusherBufferHandle != 0) {
        EngFreeMem((PVOID)DriverData.NvDmaPusherBufferBase);
        DriverData.NvDmaPusherBufferHandle =
        DriverData.NvDmaPusherBufferBase = 0;
    }

#endif // #ifdef WINNT

    DriverData.ModeNumber = 0xDEADDEAD;

#ifdef  MULTI_MON
        if (DriverData.NvDevFlatDma != 0) {
            freeParams.hRoot = DriverData.dwRootHandle;
            freeParams.hObjectParent = NV_WIN_DEVICE;
            freeParams.hObjectOld = NV_DD_DEV_DMA;

            Nv01Free((NV01Free_Param FAR *)&freeParams);

            DriverData.NvDevFlatDma = 0;
        }
        if (DriverData.NvDevVideoFlatPio != 0) {
            freeParams.hRoot = DriverData.dwRootHandle;
            freeParams.hObjectParent = NV_WIN_DEVICE;
            freeParams.hObjectOld = NV_DD_DEV_VIDEO;

            Nv01Free((NV01Free_Param FAR *)&freeParams);

            DriverData.NvDevVideoFlatPio = 0;
        }
        if (DriverData.NvDevFlatVPE != 0) {
            freeParams.hRoot = DriverData.dwRootHandle;
            freeParams.hObjectParent = NV_WIN_DEVICE;
            freeParams.hObjectOld = NV_DD_DEV_VPE;

            Nv01Free((NV01Free_Param FAR *)&freeParams);

            DriverData.NvDevFlatVPE = 0;
        }
#else   /* MULTI_MON */
        if (DriverData.NvDevFlatDma != 0) {
            NVSYSCLOSE(DriverData.NvDevFlatDma);
            DriverData.NvDevFlatDma = 0;
        }
        if (DriverData.NvDevVideoFlatPio != 0) {
            NVSYSCLOSE(DriverData.NvDevVideoFlatPio);
            DriverData.NvDevVideoFlatPio = 0;
        }
        if (DriverData.NvDevFlatVPE != 0) {
            NVSYSCLOSE(DriverData.NvDevFlatVPE);
            DriverData.NvDevFlatVPE = 0;
        }
#endif  /* MULTI_MON */

#if defined(NVHP) && !defined(WINNT)
    {

#ifdef  MULTI_MON
        NVIOControl_Param   heapParams;

        heapParams.hRoot         = DriverData.dwRootHandle;
        heapParams.hObjectParent = NV_WIN_DEVICE;
        heapParams.owner         = (((DWORD)'NV') << 16) + 'DD';
#else   // MULTI_MON
        NVIOControl_ParamX  heapParams;

        heapParams.device   = 0;
        heapParams.owner[0] = 'DD';
        heapParams.owner[1] = 'NV';
#endif  // MULTI_MON
        heapParams.function = NVIOCONTROL_HEAP_PURGE;
        NvIOControl( NVIOCONTROL_ARCH_HEAP, (LPVOID)&heapParams );
    }
#endif  // NVHP

    return 1;
}
#ifndef WINNT
/***************************************************************************
 *
 * BeginAccess
 *
 ***************************************************************************/

void FAR PASCAL _loadds BeginAccess(DIBENGINE FAR *pde, int left, int top, int right, int bottom, UINT flags)
{
    // call device specific code to access the frame buffer

    //***********************************************************************
    // Call nvPixelDev because it will wait for the NV Engine to complete
    // before continuing on.  We simply do a GetPixel (specify DrawMode=0)
    //
    // lpDestDev         -> DWORD            Need to specify '5250' and VRAM
    // X = 10 ; Y = 20   -> 2 bytes each     Dummy values, no significance
    // Color = 30        -> DWORD            Dummy value, no significance
    // Drawmode = 0      -> DWORD            Drawmode = 0 means GetPixel
    //
    //***********************************************************************
    if (!DriverData.fVidMemLocked)
        HWBeginAccess(DriverData.lpPDevice,10,20,(DWORD)30,(DWORD)0);
}

/***************************************************************************
 *
 * EndAccess
 *
 ***************************************************************************/

void FAR PASCAL _loadds EndAccess(DIBENGINE FAR *pde, UINT flags)
{
    // call device specific code to release the frame buffer
    HWEndAccess();
}

/***************************************************************************
 *
 * Control
 *
 * this is what GDI calls when a app calles Escape or ExtEscape
 * if you dont handle a escape make sure to pass it to the DIBENG
 *
 ***************************************************************************/

LONG FAR PASCAL _loadds Control(
    DIBENGINE FAR * lpDevice,
    UINT            function,
    LPVOID          lpInput,
    LPVOID          lpOutput)
{
    DCICMD        FAR  *pdci;
    unsigned long FAR  *lpResult;
    LPVIDEOPARAMETERS   lpTVparams;

    switch (function)
    {
        case QUERYESCSUPPORT:

            //
            // QUERYESCSUPPORT is sent to ask
            // "do you support this" lpInput points
            // the function code to query
            //
            switch (*(UINT FAR *)lpInput)
            {
                // QUERYDIBSUPPORT MUST BE PASSED ON TO DIB ENGINE

                case DCICOMMAND:
                    return DD_HAL_VERSION;
                    break;

                case OPENGL_GETINFO:
                    return TRUE;  // return non-zero if supported
                    break;

                case OPENGL_CMD:
                    return FALSE; // return non-zero if supported
                    break;

                case VIDEO_PARAMETERS:
                    return TRUE;  // return non-zero if supported
                    break;

                case DVD_MACROVISION_CMD:
                    return TRUE;  // return non-zero if supported
                    break;


            }
            break;

        case GETNVCHANNELPTR:
            lpResult = (unsigned long FAR *)lpOutput;
            *lpResult = (unsigned long)DriverData.NvDevFlatDma;
            DriverData.fActiveExternalUser = TRUE; // NVLIB, NVDDX, etc. is active
            return TRUE;

        case NVGETAGPBASE:
            lpResult = (unsigned long FAR *)lpOutput;
            *lpResult = (DWORD)DriverData.GARTLinearBase;
            return TRUE;

        case NVDMAPUSHMODESWITCHCOUNT:
            lpResult = (unsigned long FAR *)lpOutput;
            *lpResult = (DWORD)
                GetFlatAddress((DWORD)((void FAR *)&(DriverData.dwModeSwitchCount)));
            return TRUE;

        case NVDMAPUSH3DOCCUR:
            lpResult = (unsigned long FAR *)lpOutput;
            *lpResult = (DWORD)
                GetFlatAddress((DWORD)((void FAR *)&(DriverData.ThreeDRenderingOccurred)));
            return TRUE;

        case NVDMAPUSHSYNCNOTIFIER:
            lpResult = (unsigned long FAR *)lpOutput;
            *lpResult = (unsigned long)DriverData.NvDmaPusherSyncNotifierFlat;
            return TRUE;

        case NV_ESC_DVD_MACROVISION_CMD: /* No NV3 generation chip supports Macrovision */
            if ((DriverData.dwMacrovisionNavigatorID != 0) &&
                (DriverData.dwMacrovisionNavigatorID != ((MACROVISION_INFO FAR *)lpInput)->dwMacrovisionNavigatorID)) {
                ((MACROVISION_INFO FAR *)lpOutput)->dwMacrovisionData = FOURCC_UBAD; /* Invalid Navigator ID */
                return FALSE;
            }
            if ((wMonitorType == NV_MONITOR_NTSC) || (wMonitorType == NV_MONITOR_PAL)) {
                if (DriverData.dwMacrovisionNavigatorID == 0) {
                    DriverData.dwMacrovisionNavigatorID = ((MACROVISION_INFO FAR *)lpInput)->dwMacrovisionNavigatorID;
                    return FALSE;
                }
            }
            return TRUE;

        case RECONFIGNVOFFSCREEN:
            DepopulateOffscreenCache(); // in misc.asm

            return TRUE;

        case NVSETDDRAWMODE:
            HWSetMode();  // in ddmode.c

            return TRUE;

        case OPENGL_GETINFO:
            if (*((unsigned long *) lpInput) == OPENGL_GETINFO_DRVNAME) {
                (void) lstrcpy(((LP_OPENGL_INFO) lpOutput)->awch, OPENGL_KEY_NAME );
                ((LP_OPENGL_INFO) lpOutput)->ulVersion = OPENGL_ICD_VER;            // DDI version
                ((LP_OPENGL_INFO) lpOutput)->ulDriverVersion = OPENGL_DRIVER_VER;   // driver version
                return TRUE;
            } else {
                return FALSE;
            }

        case OPENGL_CMD:
            return FALSE;

        case DCICOMMAND:
            pdci = (DCICMD FAR *)lpInput;

            if (pdci == NULL || pdci->dwVersion != DD_VERSION)
                break;

            /*
             * this request gives us our direct draw routines to call
             */
            if (pdci->dwCommand == DDNEWCALLBACKFNS) {
                DriverData.HALCallbacks = *((LPDDHALDDRAWFNS)pdci->dwParam1);
                return TRUE;
            }
            /*
             * return information about our 32-bit DLL
             *
             * we pass a pointer to our shared global Data
             * to the 32-bit driver so we can talk to each
             * other by reading each others mind.
             */
            else if (pdci->dwCommand == DDGET32BITDRIVERNAME) {
                LPDD32BITDRIVERDATA p32dd = (LPDD32BITDRIVERDATA)lpOutput;

                lstrcpy(p32dd->szName, DIRECTDRAW_DLLNAME);
                lstrcpy(p32dd->szEntryPoint, "DriverInit");
                p32dd->dwContext = GetFlatAddress((DWORD)((void FAR *)&DriverData));

                return TRUE;
            }
            /*
             * handle the request to create a driver
             * NOTE we must return our HINSTANCE in *lpOutput
             */
            else if (pdci->dwCommand == DDCREATEDRIVEROBJECT) {
                DDCreateDriverObject(FALSE);
                *(DWORD FAR *)lpOutput = DriverData.HALInfo.hInstance;
                return TRUE;
            }

            break;

        // This is the new Windows98 tv out API extension.
        case VIDEO_PARAMETERS:
            lpTVparams = ((LPVIDEOPARAMETERS) lpInput);

            switch (lpTVparams->dwCommand) {

                case VP_COMMAND_GET:

                    if (lpTVparams->dwFlags & VP_FLAGS_TV_MODE)
                        lpTVparams->dwMode = VP_MODE_WIN_GRAPHICS;

                    if (lpTVparams->dwFlags & VP_FLAGS_TV_STANDARD) {
                        lpTVparams->dwTVStandard = 0;

                        if (wMonitorType == NV_MONITOR_VGA)
                            lpTVparams->dwTVStandard = VP_TV_STANDARD_WIN_VGA;
                        else if (wMonitorType == NV_MONITOR_NTSC)
                            lpTVparams->dwTVStandard = VP_TV_STANDARD_NTSC_M;
                        else if (wMonitorType == NV_MONITOR_PAL)
                            lpTVparams->dwTVStandard = VP_TV_STANDARD_PAL_B;
                    }

                    lpTVparams->dwAvailableModes = VP_MODE_WIN_GRAPHICS;

                    lpTVparams->dwAvailableTVStandard = 0;

                    /* Currently we support only 1 mode at a time controlled by physical connections */
                    if (wMonitorType == NV_MONITOR_VGA)
                        lpTVparams->dwAvailableTVStandard = VP_TV_STANDARD_WIN_VGA;
                    else if (wMonitorType == NV_MONITOR_NTSC)
                        lpTVparams->dwAvailableTVStandard = VP_TV_STANDARD_NTSC_M;
                    else if (wMonitorType == NV_MONITOR_PAL)
                        lpTVparams->dwAvailableTVStandard = VP_TV_STANDARD_PAL_B;

                    if (lpTVparams->dwFlags & VP_FLAGS_FLICKER)
                        lpTVparams->dwFlickerFilter = 0;

                    if (lpTVparams->dwFlags & VP_FLAGS_OVERSCAN) {
                        lpTVparams->dwOverScanX = 0;
                        lpTVparams->dwOverScanY = 0;
                    }

                    if (lpTVparams->dwFlags & VP_FLAGS_MAX_UNSCALED) {
                        lpTVparams->dwMaxUnscaledX = DriverData.bi.biWidth;
                        lpTVparams->dwMaxUnscaledY = DriverData.bi.biHeight;
                    }

                    if (lpTVparams->dwFlags & VP_FLAGS_POSITION) {
                        lpTVparams->dwPositionX = 0;
                        lpTVparams->dwPositionY = 0;
                    }

                    if (lpTVparams->dwFlags & VP_FLAGS_BRIGHTNESS)
                        lpTVparams->dwBrightness = 100;

                    if (lpTVparams->dwFlags & VP_FLAGS_CONTRAST)
                        lpTVparams->dwContrast = 100;

                    if (lpTVparams->dwFlags & VP_FLAGS_COPYPROTECT) {
                        lpTVparams->dwCPType = 0;
                        lpTVparams->dwCPStandard = 0;

                        if (dwTVOutDeviceID == NV_TV_OUT_BT869) {
//                              lpTVparams->dwCPType = VP_CP_TYPE_APS_TRIGGER |
//                                                      VP_CP_TYPE_MACROVISION;
                            lpTVparams->dwCPType = VP_CP_TYPE_APS_TRIGGER;
                            lpTVparams->bCP_APSTriggerBits = macrovisionMode;
                            if (wMonitorType == NV_MONITOR_NTSC)
                                lpTVparams->dwCPStandard = VP_TV_STANDARD_NTSC_M;
                            else if (wMonitorType == NV_MONITOR_PAL)
                                lpTVparams->dwCPStandard = VP_TV_STANDARD_PAL_B;
                        }
                    }

                    return TRUE;
                    break;

                case VP_COMMAND_SET:

                    if (lpTVparams->dwFlags & VP_FLAGS_COPYPROTECT) {
                        /* If not connected to a device that supports Macrovision copy protection */
                        if (dwTVOutDeviceID != NV_TV_OUT_BT869) {
                            return FALSE;
                        }
                        /* Currently we only support APS trigger bits */
                        if (lpTVparams->dwCPType != VP_CP_TYPE_APS_TRIGGER)
                            return FALSE;

                        if (lpTVparams->dwCPCommand == VP_CP_CMD_ACTIVATE) {
                            macrovisionMode = lpTVparams->bCP_APSTriggerBits & 3;
                            if (SetMacrovisionMode(macrovisionMode)) {
                                lpTVparams->dwCPKey = macrovisionKey;
                                return TRUE;
                            }
                        } else if (lpTVparams->dwCPCommand == VP_CP_CMD_DEACTIVATE) {
                            if (lpTVparams->dwCPKey != macrovisionKey)
                                return FALSE;
                            macrovisionMode = 0;
                            if (SetMacrovisionMode(macrovisionMode))
                                return TRUE;
                        } else if (lpTVparams->dwCPCommand == VP_CP_CMD_CHANGE) {
                            if (lpTVparams->dwCPKey != macrovisionKey)
                                return FALSE;
                            macrovisionMode = lpTVparams->bCP_APSTriggerBits & 3;
                            if (SetMacrovisionMode(macrovisionMode))
                                return TRUE;
                        } else return FALSE;
                    }

                    return FALSE;
                    break;

                default:
                    return FALSE;
                    break;
            }

            break;

#ifdef  NV_ESCAPE_ID
        case NV_ESCAPE_ID:
            lpResult = (unsigned long FAR *)lpOutput;
            if (lpResult != NULL) {
                *lpResult = (unsigned long) NV_ESCAPE_ID_RETURN;
                return TRUE;
            } else
                return FALSE;
#endif  // NV_ESCAPE_ID

    }

    if (lpDevice != 0)
        return DIB_Control(lpDevice,function,lpInput,lpOutput);
    else
        return FALSE;
}

/***************************************************************************
 * GetRegInt
 *
 *   read a integer from the HKEY_CURRENT_CONFIG\Display\Settings
 *   key in the registy.
 *
 *   will read a string value and return a integer, if the string is of
 *   the form X,Y will return X<<16+Y
 *
 * Entry:
 *       valname     name of value to read (ie "Resolution")
 *       default     default value to use if not found (ie 0)
 *
 * Returns:
 *       int from registry, or default if not there
 *
 ***************************************************************************/

/*
DWORD GetRegInt(LPSTR valname, DWORD def)
{
    HKEY    hkey;
    char    ach[20];
    DWORD   cb;
    int     i;

    if (RegOpenKey(HKEY_CURRENT_CONFIG, "Display\\Settings", &hkey) == 0)
    {
        ach[0] = 0;
        cb = sizeof(ach);

        if (RegQueryValueEx(hkey, valname, NULL, NULL, ach, &cb) == 0)
        {
            for (def=i=0; ach[i]; i++)
            {
                if (ach[i] >= '0' && ach[i] <= '9')
                    *((WORD*)&def) = LOWORD(def) * 10 + ach[i]-'0';

                if (ach[i] == ',')
                    def = def << 16;
            }
        }

        RegCloseKey(hkey);
    }

    return def;
}
*/
#endif // #ifndef WINNT
/***************************************************************************
 * GetFlatSel
 ***************************************************************************/

UINT GetFlatSel()
{
#ifndef WINNT
    extern WORD PASCAL NVVD_API_DATA;
    return NVVD_API_DATA;
#else
    return(0);
#endif // #ifdef WINNT
}

#ifdef MSDEBUG

#define START_STR "DDMINI: "

void __cdecl DPF(LPSTR szFormat, ...)
{
    static int (WINAPI *fpwvsprintf)(LPSTR lpszOut, LPCSTR lpszFmt, const void FAR* lpParams);
    char        str[256];

    if (fpwvsprintf == NULL)
    {
        fpwvsprintf = (LPVOID) GetProcAddress(GetModuleHandle("USER"),"wvsprintf");
        if (fpwvsprintf == NULL)
            return;
    }

    lstrcpy(str, START_STR);
    fpwvsprintf(str+lstrlen(str), szFormat, (LPVOID)(&szFormat+1));
    lstrcat(str, "\r\n");
    OutputDebugString(str);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\common\NVUCL\disasm.cpp ===
/*
 * (C) Copyright NVIDIA Corporation Inc., 1996,1997,1998. All rights reserved.
 */
/********************************* Direct 3D *******************************\
*                                                                           *
* Module: MATRIX.CPP                                                        *
*   Push buffer diassembler private implementation                          *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*       Ben de Waal                 07/21/98 - Created                      *
*                                                                           *
\***************************************************************************/
#include "precomp.h"
#include "disasm.h"

/*
 * attach
 *
 * bump reference count up
 */
NVUCL_RESULT NVUCL_STDCALL UCL_DISASM::attach
(
    void
)
{
    m_dwRefCount++;
    return NVUCL_OK;
}

/*
 * detach
 *
 * bump reference count down & delete object if it reaches zero
 */
NVUCL_RESULT NVUCL_STDCALL UCL_DISASM::detach
(
    void
)
{
    if (--m_dwRefCount)
    {
        return NVUCL_OK;
    }
    /*
     * kill self
     */
    delete this;
    return NVUCL_OK;
}

/*
 * redirect
 *
 * redirects output to the specified file
 */
NVUCL_RESULT NVUCL_STDCALL UCL_DISASM::redirect
(
    char* pszFilename
)
{
    /*
     * copy filename
     */
    m_pszFilename = strdup(pszFilename);

    /*
     * open file
     */
    m_hFile = fopen(pszFilename,"wt");
    if (!m_hFile)
    {
        /*
         * fail
         */
        return NVUCL_ERROR_ACCESSDENIED;
    }
    m_bToDebugger = FALSE;

    /*
     * banner
     */
    //todo

    /*
     * close file
     */
    fclose (m_hFile);
    m_hFile = 0;

    /*
     * done
     */
    return NVUCL_OK;
}

/*
 * traverse
 *
 * disassembles a push buffer
 */
NVUCL_RESULT NVUCL_STDCALL UCL_DISASM::traverse
(
    void* pBuffer,
    DWORD dwByteCount
)
{
    DWORD dwBuffer;

    /*
     * open file
     */
    if (!m_bToDebugger)
    {
        m_hFile = fopen(m_pszFilename,"a+t");
        if (!m_hFile)
        {
            /*
             * fail
             */
            return NVUCL_ERROR_ACCESSDENIED;
        }
    }

    emit ("PushBuffer %08x, ByteCount = %d\n",pBuffer,dwByteCount);

    dwBuffer = (DWORD)pBuffer;
    while (dwByteCount)
    {
        DWORD method  = *(DWORD*)dwBuffer;
        DWORD count   = (method & 0x00fc0000) >> 16;

        if (method & 0xff000000)
        {
            /*
             * not a method
             */
            emit ("   other: %08x - count=%d\n",method,count/4);

            /*
             * next
             */
            dwBuffer    += 4;
            dwByteCount -= 4;

            /*
             * show contents
             */
            while (count)
            {
                DWORD data = *(DWORD*)dwBuffer;

                /*
                 * print
                 */
                emit ("        : %08x\n",data);

                /*
                 * next
                 */
                count       -= 4;
                dwBuffer    += 4;
                dwByteCount -= 4;
            }
        }
        else
        {
            DWORD channel = (method & 0x0003e000) >> 13;
            DWORD addr    = (method & 0x00001fff) >>  0;

            emit ("\n  method: %08x - ch=%d, start=0x%x, count = %d\n",method,channel,addr,count/4);

            /*
             * next
             */
            dwBuffer    += 4;
            dwByteCount -= 4;

            /*
             * show contents
             */
            while (count)
            {
                DWORD data = *(DWORD*)dwBuffer;

                /*
                 * print
                 */
                emit ("%08x: %08x\n",addr,data);

                /*
                 * next
                 */
                addr        += 4;
                count       -= 4;
                dwBuffer    += 4;
                dwByteCount -= 4;
            }
        }
    }

    emit ("\n");

    /*
     * close file
     */
    if (!m_bToDebugger)
    {
        fflush (m_hFile);
        fclose (m_hFile);
        m_hFile = 0;
    }

    /*
     * done
     */
    return NVUCL_OK;
}

/*
 * emit
 *
 * helper function that either fprintf or sprintf/OutDB depending on file handle
 */
void UCL_DISASM::emit 
(
    char *szFormat,
    ...
)
{
    if (m_hFile)
    {
        vfprintf (m_hFile,szFormat,(char*)(((DWORD)&szFormat)+4));
    }
    else
    {
        char sz[1024];
        vsprintf (sz,szFormat,(char*)(((DWORD)&szFormat)+4));
        OutputDebugString (sz);
    }
}

/*
 * construction
 */
UCL_DISASM::UCL_DISASM (void)
{
    m_dwRefCount  = 1;
    m_bToDebugger = TRUE;
    m_hFile       = NULL;
    m_pszFilename = NULL;
}

UCL_DISASM::~UCL_DISASM (void)
{
    if (m_hFile)
    {
        fclose (m_hFile);
    }
    if (m_pszFilename)
    {
        free (m_pszFilename);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\common\NVUCL\nvucl.h ===
/*
 * (C) Copyright NVIDIA Corporation Inc., 1996,1997,1998. All rights reserved.
 */
/********************************* Direct 3D *******************************\
*                                                                           *
* Module: NVUCL.H                                                           *
*   NVIDIA Unified Component Library Public Interface                       *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*       Ben de Waal                 07/06/98 - Created                      *
*                                                                           *
\***************************************************************************/
#ifndef _nvucl_h
#define _nvucl_h
#pragma pack(push,1)

/*
 *---------------------------------------------------------------------------
 * Constants
 *---------------------------------------------------------------------------
 */

/*
 * interface identifiers
 */
#define NVUCL_PROFILER_ID               0x4e560001
#define NVUCL_MATRIX_ID                 0x4e560002
#define NVUCL_DISASM_ID                 0x4e560003

/*
 * error codes
 */
#define NVUCL_OK                        0
#define NVUCL_ERROR_INVALIDPARAM        1
#define NVUCL_ERROR_UNKNOWNINTERFACE    2
#define NVUCL_ERROR_UNKNOWN             3
#define NVUCL_ERROR_OUTOFRESOURCE       4
#define NVUCL_ERROR_INVALIDCALL         5
#define NVUCL_ERROR_UNKNOWNENTITY       6
#define NVUCL_ERROR_NOTIMLEMENTED       7
#define NVUCL_ERROR_ACCESSDENIED        8

/*
 *---------------------------------------------------------------------------
 * Types
 *---------------------------------------------------------------------------
 */
typedef DWORD                           NVUCL_RESULT;

/*
 *---------------------------------------------------------------------------
 * Macros
 *---------------------------------------------------------------------------
 */

/*
 * compiler specific
 */
#ifdef __cplusplus
#define NVUCL_INTERFACE_BEGIN           struct NVUCL_INTERFACE : public NVUCL_BASE {
#define NVUCL_INTERFACE_END             };
#define NVUCL_METHOD(x)                 virtual NVUCL_RESULT NVUCL_STDCALL x (
#define NVUCL_METHOD_(x)                virtual NVUCL_RESULT NVUCL_STDCALL x (void
#define NVUCL_PURE                      )=0
#else //!__cplusplus
#define NVUCL_INTERFACE_BEGIN           typedef struct { struct {
#define NVUCL_INTERFACE_END             } *pVPtr; } *NVUCL_INTERFACE;
#define NVUCL_METHOD(x)                 NVUCL_RESULT (NVUCL_STDCALL *x) (void*,
#define NVUCL_METHOD_(x)                NVUCL_RESULT (NVUCL_STDCALL *x) (void*
#define NVUCL_PURE                      )
#endif //!__cplusplus
#define NVUCL_STDCALL                   __stdcall
#ifdef __NVUCL_INCLUDED
#define NVUCL_EXPORT                    __declspec(dllexport)
#else //!__NVUCL_INCLUDED
#define NVUCL_EXPORT
#endif //!__NVUCL_INCLUDED

/*
 * Dynamic Binding
 */
#define NVUCL_IMPORT                                                           \
    typedef NVUCL_RESULT (NVUCL_STDCALL *_nvuclGetInterfacePtr)(DWORD,void**); \
    _nvuclGetInterfacePtr nvuclGetInterfaceProc = 0;                           \
    HANDLE                _nvuclModule          = 0;

#define NVUCL_LOAD(x)                                                          \
    _nvuclModule = LoadLibrary(x);                                             \
    if (_nvuclModule)                                                          \
    {                                                                          \
        nvuclGetInterfaceProc = (_nvuclGetInterfacePtr)GetProcAddress(_nvuclModule,"_nvuclGetInterface@8");\
    }

#define NVUCL_UNLOAD                                                           \
    if (_nvuclModule) FreeLibrary(_nvuclModule);                               \
    _nvuclModule = 0;

/*
 *---------------------------------------------------------------------------
 * Structures
 *---------------------------------------------------------------------------
 */

/*
 *---------------------------------------------------------------------------
 * Interfaces
 *---------------------------------------------------------------------------
 */

/*
 * Base
 */
#ifdef __cplusplus
#undef  NVUCL_INTERFACE
#define NVUCL_INTERFACE     NVUCL_BASE
struct NVUCL_INTERFACE {
    NVUCL_METHOD_(attach) NVUCL_PURE;
    NVUCL_METHOD_(detach) NVUCL_PURE;
};
#endif //__cplusplus

/*
 * Profiler
 */
#undef  NVUCL_INTERFACE
#define NVUCL_INTERFACE     NVUCL_PROFILER
NVUCL_INTERFACE_BEGIN
    NVUCL_METHOD_(attach)                                   NVUCL_PURE;
    NVUCL_METHOD_(detach)                                   NVUCL_PURE;

    NVUCL_METHOD (registerEvent) LPCSTR cszName,DWORD dwID  NVUCL_PURE;
    NVUCL_METHOD (registerCount) LPCSTR cszName,DWORD dwID  NVUCL_PURE;
    NVUCL_METHOD (registerTime)  LPCSTR cszName,DWORD dwID  NVUCL_PURE;

    NVUCL_METHOD (logEvent)      DWORD  dwID                NVUCL_PURE;
    NVUCL_METHOD (logCount)      DWORD  dwID,int iCount     NVUCL_PURE;
    NVUCL_METHOD (logTime)       DWORD  dwID,__int64 iTime  NVUCL_PURE;

    NVUCL_METHOD (startCapture)  LPCSTR cszFileName         NVUCL_PURE;
    NVUCL_METHOD_(stopCapture)                              NVUCL_PURE;
    NVUCL_METHOD (flush)         BOOL bOptional             NVUCL_PURE;

    NVUCL_METHOD (getCPUTime)    __int64 *pdwTicks          NVUCL_PURE;
    NVUCL_METHOD (getCPUSpeed)   DWORD *pdwSpeed            NVUCL_PURE;
NVUCL_INTERFACE_END

/*
 * Matrix
 */
#undef  NVUCL_INTERFACE
#define NVUCL_INTERFACE     NVUCL_MATRIX
NVUCL_INTERFACE_BEGIN
    NVUCL_METHOD_(attach)                                       NVUCL_PURE;
    NVUCL_METHOD_(detach)                                       NVUCL_PURE;

    NVUCL_METHOD (setStore)     float *pfAddress                NVUCL_PURE;
    NVUCL_METHOD_(setUnit)                                      NVUCL_PURE;

    NVUCL_METHOD (setElement)   DWORD dwIndex,float fValue      NVUCL_PURE;
    NVUCL_METHOD (setRow)       DWORD dwRow,  float *pfValue    NVUCL_PURE;
    NVUCL_METHOD (setAll)       float *pfValue                  NVUCL_PURE;

    NVUCL_METHOD (getElement)   DWORD dwIndex,float *pfValue    NVUCL_PURE;
    NVUCL_METHOD (getRow)       DWORD dwRow,  float *pfValue    NVUCL_PURE;
    NVUCL_METHOD (getAll)       float *pfValue                  NVUCL_PURE;

    NVUCL_METHOD (multiply)     void *pMatrix                   NVUCL_PURE;
    NVUCL_METHOD_(invert)                                       NVUCL_PURE;
NVUCL_INTERFACE_END

/*
 * Push-buffer disassembler
 */
#undef  NVUCL_INTERFACE
#define NVUCL_INTERFACE     NVUCL_DISASM
NVUCL_INTERFACE_BEGIN
    NVUCL_METHOD_(attach)                                       NVUCL_PURE;
    NVUCL_METHOD_(detach)                                       NVUCL_PURE;

    NVUCL_METHOD (redirect)     char* pszFilename               NVUCL_PURE;
    NVUCL_METHOD (traverse)     void* pBuffer,DWORD dwByteCount NVUCL_PURE;
NVUCL_INTERFACE_END

/*
 *---------------------------------------------------------------------------
 * Publics
 *---------------------------------------------------------------------------
 */
#ifdef __cplusplus
extern "C" {
#endif //!__cplusplus
NVUCL_RESULT NVUCL_EXPORT NVUCL_STDCALL nvuclGetInterface (DWORD,void**);
#ifdef __cplusplus
}
#endif //!__cplusplus

#pragma pack(pop)
#endif //_nvucl_h
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\common\NVUCL\precomp.h ===
#define WIN32_LEAN_AND_MEAN
#include <windows.h>
#include <stdio.h>
#include <math.h>
#include <string.h>
#include <malloc.h>

#define __NVUCL_INCLUDED
#include "nvucl.h"

/*
 * global macros
 */
#define PREFETCH(x)     (volatile DWORD)*(DWORD*)(x)

/*
struct UCL_BASE : public NVUCL_BASE
{
private:
    DWORD m_dwRefCount;
public:
    virtual NVUCL_RESULT NVUCL_STDCALL attach (void)
    {
        m_dwRefCount++;
        return NVUCL_OK;
    }
    virtual NVUCL_RESULT NVUCL_STDCALL detach (void)
    {
        if (--m_dwRefCount) return NVUCL_OK;
        delete this;
        return NVUCL_OK;
    }
    virtual ~UCL_BASE (void)
    {
    }
};
*/
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\common\nvUtil\nvdetect.h ===
#ifndef _nvdetect_h
#define _nvdetect_h

DWORD nvGetCPUSpeed  (void);
BOOL  nvDetectMMX    (void);
BOOL  nvDetectKATMAI (void);

#endif //!_nvdetect_h
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\common\NVUCL\profiler.cpp ===
/*
 * (C) Copyright NVIDIA Corporation Inc., 1996,1997,1998. All rights reserved.
 */
/********************************* Direct 3D *******************************\
*                                                                           *
* Module: PROFILER.CPP                                                      *
*   Profiler routines                                                       *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*       Ben de Waal                 07/06/98 - Created                      *
*                                                                           *
\***************************************************************************/
#include "precomp.h"
#include "profiler.h"

/*
 * local constants
 */
#define BTFT_1              0x42EC5201  // version 1 file header
#define BTRT_EOF            0xff

#define BTAA_EVENT          0x00000000  // event
#define BTAA_TIME           0x00000001  // time
#define BTAA_COUNT          0x00000002  // count

/*
 * attach
 *
 * bump reference count up
 */
NVUCL_RESULT NVUCL_STDCALL UCL_PROFILER::attach
(
    void
)
{
    m_dwRefCount++;
    return NVUCL_OK;
}

/*
 * detach
 *
 * bump reference count down & delete object if it reaches zero
 */
NVUCL_RESULT NVUCL_STDCALL UCL_PROFILER::detach
(
    void
)
{
    if (--m_dwRefCount)
    {
        return NVUCL_OK;
    }
    /*
     * kill self
     */
    delete this;
    return NVUCL_OK;
}

/*
 * registerEvent
 *
 * register a Locutus Event ID for profile usage
 */
NVUCL_RESULT NVUCL_STDCALL UCL_PROFILER::registerEvent
(
    LPCSTR cszName,
    DWORD  dwID
)
{
    /*
     * program translation
     */
    m_bTranslate[dwID] = (BYTE)m_dwTranslationCount;

    /*
     * make sure we have enough space
     */
    if (m_dwTranslationCount >= m_dwCount)
    {
        allocAlphabet (m_dwTranslationCount);
    }

    /*
     * register entry
     */
    strncpy (m_pAlphabet[m_dwTranslationCount].szName,cszName,15);
    m_pAlphabet[m_dwTranslationCount].szName[15]   = 0;
    m_pAlphabet[m_dwTranslationCount].dwRecordSize = 0;
    m_pAlphabet[m_dwTranslationCount].dwAttributes = BTAA_EVENT;
    m_dwTranslationCount++;

    /*
     * done
     */
    return NVUCL_OK;
}

/*
 * registerCount
 *
 * register a Locutus Count ID for profile usage
 */
NVUCL_RESULT NVUCL_STDCALL UCL_PROFILER::registerCount
(
    LPCSTR cszName,
    DWORD  dwID
)
{
    /*
     * program translation
     */
    m_bTranslate[dwID] = (BYTE)m_dwTranslationCount;

    /*
     * make sure we have enough space
     */
    if (m_dwTranslationCount >= m_dwCount)
    {
        allocAlphabet (m_dwTranslationCount);
    }

    /*
     * register entry
     */
    strncpy (m_pAlphabet[m_dwTranslationCount].szName,cszName,15);
    m_pAlphabet[m_dwTranslationCount].szName[15]   = 0;
    m_pAlphabet[m_dwTranslationCount].dwRecordSize = sizeof(DWORD);
    m_pAlphabet[m_dwTranslationCount].dwAttributes = BTAA_COUNT;
    m_dwTranslationCount++;

    /*
     * done
     */
    return NVUCL_OK;
}

/*
 * registerTime
 *
 * register a Locutus Time ID for profile usage
 */
NVUCL_RESULT NVUCL_STDCALL UCL_PROFILER::registerTime
(
    LPCSTR cszName,
    DWORD  dwID
)
{
    /*
     * program translation
     */
    m_bTranslate[dwID] = (BYTE)m_dwTranslationCount;

    /*
     * make sure we have enough space
     */
    if (m_dwTranslationCount >= m_dwCount)
    {
        allocAlphabet (m_dwTranslationCount);
    }

    /*
     * register entry
     */
    strncpy (m_pAlphabet[m_dwTranslationCount].szName,cszName,15);
    m_pAlphabet[m_dwTranslationCount].szName[15]   = 0;
    m_pAlphabet[m_dwTranslationCount].dwRecordSize = sizeof(__int64);
    m_pAlphabet[m_dwTranslationCount].dwAttributes = BTAA_TIME;
    m_dwTranslationCount++;

    /*
     * done
     */
    return NVUCL_OK;
}

/*
 * logEvent
 *
 * logs a Locutus event
 */
NVUCL_RESULT NVUCL_STDCALL UCL_PROFILER::logEvent
(
    DWORD dwID
)
{
    /*
     * log
     */
    m_pBuffer[m_dwIndex++] = m_bTranslate[dwID];

    /*
     * flush if buffer is full
     */
    if (m_dwIndex > CAPMARK) flush (FALSE);

    /*
     * done
     */
    return NVUCL_OK;
}

/*
 * logCount
 *
 * logs a Locutus count
 */
NVUCL_RESULT NVUCL_STDCALL UCL_PROFILER::logCount
(
    DWORD dwID,
    int   iCount
)
{
    /*
     * log
     */
    m_pBuffer[m_dwIndex++] = m_bTranslate[dwID];
    *(int*)(m_pBuffer + m_dwIndex) = iCount;
    m_dwIndex += 4;

    /*
     * flush if buffer is full
     */
    if (m_dwIndex > CAPMARK) flush (FALSE);

    /*
     * done
     */
    return NVUCL_OK;
}

/*
 * logTime
 *
 * logs a Locutus time
 */
NVUCL_RESULT NVUCL_STDCALL UCL_PROFILER::logTime
(
    DWORD   dwID,
    __int64 iTime
)
{
    /*
     * log
     */
    m_pBuffer[m_dwIndex++] = m_bTranslate[dwID];
    *(__int64*)(m_pBuffer + m_dwIndex) = iTime;
    m_dwIndex += 8;

    /*
     * flush if buffer is full
     */
    if (m_dwIndex > CAPMARK) flush (FALSE);

    /*
     * done
     */
    return NVUCL_OK;
}

/*
 * startCapture
 *
 * starts a capture session
 */
NVUCL_RESULT NVUCL_STDCALL UCL_PROFILER::startCapture
(
    LPCSTR cszFileName
)
{
    /*
     * make sure we have at least one alphabet entry
     */
    if (!m_dwCount)
    {
        return NVUCL_ERROR_INVALIDCALL;
    }

    /*
     * open up file
     */
    m_hFile = CreateFile(cszFileName,GENERIC_WRITE,0,0,CREATE_ALWAYS,0,0);
    if (m_hFile == INVALID_HANDLE_VALUE) {
        return NVUCL_ERROR_OUTOFRESOURCE;
    }

    /*
     * place header information
     */
    m_dwIndex = 0;
    *(DWORD*)(m_pBuffer + m_dwIndex) = BTFT_1;
    m_dwIndex += 4;
    DWORD dw = 1;
    getCPUSpeed (&dw);
    *(DWORD*)(m_pBuffer + m_dwIndex) = dw;
    m_dwIndex += 4;
    *(DWORD*)(m_pBuffer + m_dwIndex) = m_dwCount;
    m_dwIndex += 4;
    memcpy (m_pBuffer + m_dwIndex,m_pAlphabet,sizeof(ALPHABET) * m_dwCount);
    m_dwIndex += sizeof(ALPHABET) * m_dwCount;

    /*
     * done
     */
    return NVUCL_OK;
}

/*
 * stopCapture
 *
 * ends off a capture session
 */
NVUCL_RESULT NVUCL_STDCALL UCL_PROFILER::stopCapture 
(
    void
)
{
    /*
     * make sure we have a capture in progress
     */
    if (!m_hFile)
    {
        return NVUCL_ERROR_INVALIDCALL;
    }

    /*
     * finish off capture
     */
    m_pBuffer[m_dwIndex++] = BTRT_EOF;
    flush (FALSE);
    CloseHandle (m_hFile);
    m_hFile = NULL; // tag as closed

    /*                     
     * done
     */
    return NVUCL_OK;
}

/*
 * flush
 *
 * flush a Locutus batch to disk
 */
NVUCL_RESULT NVUCL_STDCALL UCL_PROFILER::flush
(
    BOOL bOptional
)
{
    /*
     * flush only when we have enough data (50% full)
     */
    if (bOptional && (m_dwIndex < (CAPMAX / 2)))
    {
        return NVUCL_OK;
    }

    /*
     * send data if any
     */
    if (m_dwIndex) {
        /*
         * write data
         */
        DWORD dw;
        if (!WriteFile(m_hFile,m_pBuffer,m_dwIndex,&dw,0)) {
            return NVUCL_ERROR_OUTOFRESOURCE;
        }
        /*
         * make sure it is comitted now
         */
        FlushFileBuffers (m_hFile);
        /*
         * reset index
         */
        m_dwIndex = 0;
    }

    /*
     * done
     */
    return NVUCL_OK;
}

/*
 * getCPUTime
 *
 * get # of clock ticks elasped since startup
 */
NVUCL_RESULT NVUCL_STDCALL UCL_PROFILER::getCPUTime
(
    __int64 *pdwTicks
)
{
    __asm 
    {
        mov ebx,[pdwTicks]
        _emit 0x0f 
        _emit 0x31
        mov dword ptr [ebx],eax
        mov dword ptr [ebx+4],edx
    }
    return NVUCL_OK;
}

/*
 * getCPUSpeed
 *
 * measure the CPU speed (& latch to know values)
 */
NVUCL_RESULT NVUCL_STDCALL UCL_PROFILER::getCPUSpeed
(
    DWORD *pdwSpeed
)
{
    double      speed;
    SYSTEM_INFO si;

    GetSystemInfo (&si);
    if (si.wProcessorArchitecture != PROCESSOR_ARCHITECTURE_INTEL) return NVUCL_ERROR_UNKNOWNENTITY; // unknown
    if (si.dwProcessorType        != PROCESSOR_INTEL_PENTIUM)      return NVUCL_ERROR_UNKNOWNENTITY; // not pentium

    SetPriorityClass  (GetCurrentProcess(),REALTIME_PRIORITY_CLASS);
    SetThreadPriority (GetCurrentThread(), THREAD_PRIORITY_TIME_CRITICAL);
    GetTickCount(); // break in cache
    {
	    DWORD   start,stop;
        __int64 clock_ticks;

	    start = GetTickCount();
	    __asm {
		    pushad
            lea esi,[clock_ticks]

		    _emit 0x0f
		    _emit 0x31
		    mov ebp,eax
		    mov ebx,edx

		    mov ecx,8000000h
	    here:
		    loop here

		    _emit 0x0f
		    _emit 0x31
		    sub eax,ebp
		    sbb edx,ebx

		    mov [dword ptr esi+0],eax
		    mov [dword ptr esi+4],edx

		    popad
	    }
	    stop = GetTickCount();
        speed = ((double)clock_ticks)/(1000.0*(double)(stop-start));
    }
    SetPriorityClass  (GetCurrentProcess(),NORMAL_PRIORITY_CLASS);
    SetThreadPriority (GetCurrentThread(), THREAD_PRIORITY_NORMAL);
 
    /*
     * normalize to known values
     */
#define LATCH_VALUE(x,y)    if (fabs(((x)-(y))/(y)) < 0.05) { *pdwSpeed = (DWORD)(y); return NVUCL_OK; }
    LATCH_VALUE (speed, 90);
    LATCH_VALUE (speed,100);
    LATCH_VALUE (speed,166);
    LATCH_VALUE (speed,200);
    LATCH_VALUE (speed,233);
    LATCH_VALUE (speed,266);
    LATCH_VALUE (speed,300);
    LATCH_VALUE (speed,333);
    LATCH_VALUE (speed,400);
    LATCH_VALUE (speed,450);
    LATCH_VALUE (speed,500);

    /*
     * did not latch - return unaltered (can be up to 10% off)
     */
    *pdwSpeed = (DWORD)(speed);
    return NVUCL_OK;
}

/*
 * allocAlphabet
 *
 * allocates enough space in alphabet to register the dwPlace'th alphabet
 * entry
 */
void UCL_PROFILER::allocAlphabet
(
    DWORD dwPlace
)
{
    /*
     * bump alphabet count if needed
     */
    if (dwPlace >= m_dwCount)
    {
        m_dwCount = dwPlace + 1;
    }

    /*
     * Do we have enough space?
     */
    if (m_dwCount > m_dwMax)
    {
        /*
         * alloc enough space
         */
        m_dwMax     = (m_dwCount + 15) & ~15;        
        m_pAlphabet = (ALPHABET*)realloc(m_pAlphabet,sizeof(ALPHABET) * m_dwMax);
    }
}

/*
 * constructor
 */
UCL_PROFILER::UCL_PROFILER
(
    void
)
{
    m_dwRefCount = 1;
    m_dwMax      = 0;
    m_dwCount    = 0;
    m_pAlphabet  = NULL;
    m_hFile      = NULL;
    m_dwIndex    = 0;
    m_dwTranslationCount = 0;
}

UCL_PROFILER::~UCL_PROFILER
(
    void
)
{
    if (m_hFile)
    {
        CloseHandle (m_hFile);
    }
    if (m_pAlphabet)
    {
        free (m_pAlphabet);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\common\NVUCL\Sample\Sample.c ===
/*
 * Some standard libraries
 */
#define WIN32_LEAN_AND_MEAN
#include <windows.h>
#include <stdlib.h>

/*
 * include NVUCL
 */
#include "..\nvucl.h"
#pragma hdrstop

/*
 * globals
 */
NVUCL_PROFILER profiler = NULL;

/*
 * creation code
 */
int createProfiler (void)
{
    if (nvuclGetInterface(NVUCL_PROFILER_ID,&profiler))
    {
        return 0; // fail
    }
    return 1; // success
}
int destroyProfiler (void)
{
    profiler->pVPtr->detach(profiler);
    return 1;
}


/*
 * main entry point
 */
int main (void) 
{
    DWORD i;
    
    /*
     * create a profiler instance
     */
    if (!createProfiler()) return 1;

    /*
     * create alphabet
     */
    profiler->pVPtr->registerEvent (profiler,"event.1",0x00);
    profiler->pVPtr->registerCount (profiler,"count.1",0x11);
    profiler->pVPtr->registerCount (profiler,"count.2",0x22);
    profiler->pVPtr->registerTime  (profiler,"time.1", 0x33);

    /*
     * start capture
     */
    profiler->pVPtr->startCapture(profiler,"test.btd");

    /*
     * do something
     */
    for (i=0; i<1000; i++)
    {
        /*
         * flush the file buffers at known times so that we can work around
         * timing the HDD writing. logXXX functions will flush if internal
         * buffer overflows - but we consider that uncontrolled
         */
        if ((i % 100) == 99)
        {
            /*
             * stop all active timers here
             */
            // ...
            /*
             * flush
             */
            profiler->pVPtr->flush(profiler);
            /*
             * restart all active timers here
             */
            // ...
        }

        switch (rand() & 3)
        {
            case 0: profiler->pVPtr->logEvent (profiler,0x00);
                    break;
            case 1: profiler->pVPtr->logCount (profiler,0x11,rand());
                    break;
            case 2: profiler->pVPtr->logCount (profiler,0x22,rand());
                    break;
            case 3: {
                __int64 time1,time2;
                profiler->pVPtr->getCPUTime (profiler,&time1);
                Sleep (rand() & 15);
                profiler->pVPtr->getCPUTime (profiler,&time2);
                profiler->pVPtr->logTime    (profiler,0x33,time2-time1);
                break;
            }
        }
    }
 
    /*
     * stop capture
     */
    profiler->pVPtr->stopCapture(profiler);

    /*
     * done
     */
    if (!destroyProfiler()) return 1;
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\common\nvUtil\nvinit.h ===
#ifndef _nvinit_h
#define _nvinit_h

/*
 * globals
 */
extern DWORD g_dwCPUFeatureSet;
extern DWORD g_dwCPUClockSpeed;

#endif //!_nvinit_h
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\common\nvUtil\nvdetect.cpp ===
/*
 * Copyright 1993-1998 NVIDIA, Corporation.  All rights reserved.
 *
 * THE INFORMATION CONTAINED HEREIN IS PROPRIETARY AND CONFIDENTIAL TO
 * NVIDIA, CORPORATION.  USE, REPRODUCTION OR DISCLOSURE TO ANY THIRD PARTY
 * IS SUBJECT TO WRITTEN PRE-APPROVAL BY NVIDIA, CORPORATION.
 */
/********************************* Direct 3D *******************************\
*                                                                           *
* Module: NVDETECT.CPP                                                      *
*   Detects CPU family and capabilities                                     *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*       Ben de Waal                 10/20/98 - wrote it                     *
*                                                                           *
\***************************************************************************/
#include "precomp.h"
#include "nvutil.h"
#include "nvdetect.h"

/*
 * macros
 */
#define LATCH_VALUE(x,y)    if (fabs(((x)-(y))/(y)) < 0.05) return (DWORD)(y)


/*
 * nvGetCPUSpeed
 *
 * detects CPU speed
 */
__int64 _clock_ticks;
DWORD nvGetCPUSpeed
(
    void
)
{
    double      speed;
    DWORD       dwCaps;
    SYSTEM_INFO si;

    GetSystemInfo (&si);
    if (si.wProcessorArchitecture != PROCESSOR_ARCHITECTURE_INTEL) return 1; // unknown
    if (si.dwProcessorType != PROCESSOR_INTEL_PENTIUM) return 1; // not pentium

    __asm
    {
        mov eax,1
        // cpuid
        _emit 0x0f
        _emit 0xa2
        mov [dwCaps],edx
    }
    if (!(dwCaps & 0x00000010)) return 1; // does not have tsc


    SetPriorityClass  (GetCurrentProcess(),REALTIME_PRIORITY_CLASS);
    SetThreadPriority (GetCurrentThread(), THREAD_PRIORITY_TIME_CRITICAL);
    GetTickCount(); // break in cache
    {
        DWORD start,stop;

        start = GetTickCount();
        __asm {
            pushad

            // rdtsc
            _emit 0x0f
            _emit 0x31
            mov ebp,eax
            mov ebx,edx
#ifdef NV_PROFILE
            mov ecx,8000000h
#else
            mov ecx,1000000h
#endif
        here:
            loop here

            // rdtsc
            _emit 0x0f
            _emit 0x31
            sub eax,ebp
            sbb edx,ebx

            mov [dword ptr _clock_ticks  ],eax
            mov [dword ptr _clock_ticks+4],edx

            popad
        }
        stop = GetTickCount();
        speed = ((double)_clock_ticks)/(1000.0*(double)(stop-start));
    }
    SetPriorityClass  (GetCurrentProcess(),NORMAL_PRIORITY_CLASS);
    SetThreadPriority (GetCurrentThread(), THREAD_PRIORITY_NORMAL);

// normalize to known values
    LATCH_VALUE (speed, 90);
    LATCH_VALUE (speed,100);
    LATCH_VALUE (speed,166);
    LATCH_VALUE (speed,200);
    LATCH_VALUE (speed,233);
    LATCH_VALUE (speed,266);
    LATCH_VALUE (speed,300);
    LATCH_VALUE (speed,333);
    LATCH_VALUE (speed,400);
    LATCH_VALUE (speed,450);
    LATCH_VALUE (speed,500);
    LATCH_VALUE (speed,550);
    LATCH_VALUE (speed,600);
// did not latch - return unaltered (can be up to 10% off)
    return (DWORD)speed;
}

/*
 * nvDetectMMX
 *
 * detect MMX capability
 */
BOOL nvDetectMMX
(
    void
)
{
    DWORD       dwCaps;
    SYSTEM_INFO si;

    GetSystemInfo (&si);
    if (si.wProcessorArchitecture != PROCESSOR_ARCHITECTURE_INTEL) return FALSE; // unknown
    if (si.dwProcessorType != PROCESSOR_INTEL_PENTIUM) return FALSE; // not pentium

    __asm
    {
        mov eax,1
        // cpuid
        _emit 0x0f
        _emit 0xa2
        mov [dwCaps],edx
    }

    return (dwCaps & 0x00800000) ? TRUE : FALSE;
}

/*
 * nvDetectKATMAI
 *
 * detect P3 capability and OS support for it
 */
BOOL nvDetectKATMAI
(
    void
)
{
    DWORD         dwCaps;
    SYSTEM_INFO   si;
    OSVERSIONINFO osvi;
    BOOL          bIsWindows98orLater;

    GetSystemInfo (&si);
    if (si.wProcessorArchitecture != PROCESSOR_ARCHITECTURE_INTEL) return FALSE; // unknown
    if (si.dwProcessorType != PROCESSOR_INTEL_PENTIUM) return FALSE; // not pentium

    __asm
    {
        mov eax,1
        // cpuid
        _emit 0x0f
        _emit 0xa2
        mov [dwCaps],edx

/*
        //mov eax,cr4
        _emit 0x0f
        _emit 0x20
        _emit 0xe0
        mov [dwCR4],eax
*/
    }

    /*
     * detect at least win 98
     */
    osvi.dwOSVersionInfoSize = sizeof(osvi);
    GetVersionEx (&osvi);
    bIsWindows98orLater = (osvi.dwPlatformId == VER_PLATFORM_WIN32_WINDOWS)
                       && ((osvi.dwMajorVersion > 4)
                        || ((osvi.dwMajorVersion == 4)
                         && (osvi.dwMinorVersion > 0)));

    return ((dwCaps & 0x02000000) && bIsWindows98orLater/*&& (dwCR4 & 0x200)*/) ? TRUE : FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\common\NVUCL\profiler.h ===
/*
 * (C) Copyright NVIDIA Corporation Inc., 1996,1997,1998. All rights reserved.
 */
/********************************* Direct 3D *******************************\
*                                                                           *
* Module: PROFILER.H                                                        *
*   Profiler private interface                                              *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*       Ben de Waal                 07/06/98 - Created                      *
*                                                                           *
\***************************************************************************/
#ifndef _profiler_h
#define _profiler_h

/*
 * constants
 */
#define CAPMAX          65536*2
#define CAPMARK         (CAPMAX - 32)

/*
 * implementation interface
 */
struct UCL_PROFILER : public NVUCL_PROFILER
{
    /*
     * exported
     */
public:
    NVUCL_RESULT NVUCL_STDCALL attach        (void);
    NVUCL_RESULT NVUCL_STDCALL detach        (void);

    NVUCL_RESULT NVUCL_STDCALL registerEvent (LPCSTR cszName,DWORD dwID);
    NVUCL_RESULT NVUCL_STDCALL registerCount (LPCSTR cszName,DWORD dwID);
    NVUCL_RESULT NVUCL_STDCALL registerTime  (LPCSTR cszName,DWORD dwID);

    NVUCL_RESULT NVUCL_STDCALL logEvent      (DWORD  dwID);
    NVUCL_RESULT NVUCL_STDCALL logCount      (DWORD  dwID,int iCount);
    NVUCL_RESULT NVUCL_STDCALL logTime       (DWORD  dwID,__int64 iTime);

    NVUCL_RESULT NVUCL_STDCALL startCapture  (LPCSTR cszFileName);
    NVUCL_RESULT NVUCL_STDCALL stopCapture   (void);
    NVUCL_RESULT NVUCL_STDCALL flush         (BOOL bOptional);

    NVUCL_RESULT NVUCL_STDCALL getCPUTime    (__int64 *pdwTicks);
    NVUCL_RESULT NVUCL_STDCALL getCPUSpeed   (DWORD *pdwSpeed);

    /*
     * private
     */
protected:

    /*
     * structures
     */
    struct ALPHABET
    {
        char  szName[16];               // human readable description
        DWORD dwRecordSize;             // size of record
        DWORD dwAttributes;             // Record description
    };
    
    /*
     * member variables
     */
    DWORD     m_dwRefCount;             // reference count
    DWORD     m_dwMax;                  // alphabet max allocated
    DWORD     m_dwCount;                // alphabet count
    HANDLE    m_hFile;                  // capture file handle
    DWORD     m_dwIndex;                // index in local capture file
    ALPHABET *m_pAlphabet;              // alphabet (may be NULL)
    DWORD     _pad[2];
    BYTE      m_pBuffer[CAPMAX];        // capture buffer
    DWORD     m_dwTranslationCount;     // max number registered
    BYTE      m_bTranslate[256];        // translation table

    /*
     * methods
     */
    void allocAlphabet (DWORD dwPlace);

    /*
     * constructors
     */
public:
    UCL_PROFILER (void);
    virtual ~UCL_PROFILER (void);
};
  
#endif //_profiler_h
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\common\nvUtil\nvmem.cpp ===
/*
 * Copyright 1993-1998 NVIDIA, Corporation.  All rights reserved.
 *
 * THE INFORMATION CONTAINED HEREIN IS PROPRIETARY AND CONFIDENTIAL TO
 * NVIDIA, CORPORATION.  USE, REPRODUCTION OR DISCLOSURE TO ANY THIRD PARTY
 * IS SUBJECT TO WRITTEN PRE-APPROVAL BY NVIDIA, CORPORATION.
 */
/********************************* Direct 3D *******************************\
*                                                                           *
* Module: NVMEM.CPP                                                         *
*   NVIDIA Fast memory copy loops - copyright strictly enforced             *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*       Ben de Waal                 11/05/98 - Created                      *
*                                                                           *
\***************************************************************************/
#include "precomp.h"
#include "nvutil.h"
#include "nvinit.h"

/*
 * local macros
 */
#define movaps_r_rm8(r,rm,ofs)      __asm _emit 0x0f __asm _emit 0x28 __asm _emit (mREG(r) | (rm)) __asm _emit (ofs)
#define movaps_rm8_r(rm,ofs,r)      __asm _emit 0x0f __asm _emit 0x29 __asm _emit (mREG(r) | (rm)) __asm _emit (ofs)
#define movups_r_rm8(r,rm,ofs)      __asm _emit 0x0f __asm _emit 0x10 __asm _emit (mREG(r) | (rm)) __asm _emit (ofs)
#define movups_rm8_r(rm,ofs,r)      __asm _emit 0x0f __asm _emit 0x11 __asm _emit (mREG(r) | (rm)) __asm _emit (ofs)
#define prefetch_rm8(h,rm,ofs)      __asm _emit 0x0f __asm _emit 0x18 __asm _emit (mREG(h) | (rm)) __asm _emit (ofs)

/*
 * nvMemCopy1
 *
 * copies src to dest using byte atoms
 */
__inline void nvMemCopy1
(
    DWORD dwDest,
    DWORD dwSrc,
    DWORD dwCount
)
{
    while (dwCount)
    {
        *(BYTE*)dwDest = *(BYTE*)dwSrc;
        dwSrc  ++;
        dwDest ++;
        dwCount--;
    }
}

/*
 * nvMemCopy4
 *
 * copies src to dest using dword atoms.
 */
__inline void nvMemCopy4
(
    DWORD dwDest,
    DWORD dwSrc,
    DWORD dwCount   // in dwords
)
{
    while (dwCount)
    {
        *(DWORD*)dwDest = *(DWORD*)dwSrc;
        dwSrc  += 4;
        dwDest += 4;
        dwCount--;
    }
}

/*
 * nvMemCopy16
 *
 * copies src to dest using 4*dword atoms (if possible).
 */
__inline void nvMemCopy16
(
    DWORD dwDest,
    DWORD dwSrc,
    DWORD dwCount
)
{
    if (g_dwCPUFeatureSet & NV_FS_KATMAI)
    {
        if (dwSrc & 15)
        {
            if (dwDest & 15)
            {
                __asm
                {
                    mov ebx,[dwSrc]
                    mov edx,[dwDest]
                    mov ecx,[dwCount]
            mc16_11: movups_r_rm8 (rXMM0,rmIND8(rEBX),0)
                     add ebx,16
                     movups_rm8_r (rmIND8(rEDX),rXMM0,0)
                     add edx,16
                     dec ecx
                    jnz mc16_11
                }
            }
            else
            {
                __asm
                {
                    mov ebx,[dwSrc]
                    mov edx,[dwDest]
                    mov ecx,[dwCount]
            mc16_12: movups_r_rm8 (rXMM0,rmIND8(rEBX),0)
                     add ebx,16
                     movaps_rm8_r (rmIND8(rEDX),rXMM0,0)
                     add edx,16
                     dec ecx
                    jnz mc16_12
                }
            }
        }
        else
        {
            if (dwDest & 15)
            {
                __asm
                {
                    mov ebx,[dwSrc]
                    mov edx,[dwDest]
                    mov ecx,[dwCount]
            mc16_13: movaps_r_rm8 (rXMM0,rmIND8(rEBX),0)
                     add ebx,16
                     movups_rm8_r (rmIND8(rEDX),rXMM0,0)
                     add edx,16
                     dec ecx
                    jnz mc16_13
                }
            }
            else
            {
                __asm
                {
                    mov ebx,[dwSrc]
                    mov edx,[dwDest]
                    mov ecx,[dwCount]
            mc16_14: movaps_r_rm8 (rXMM0,rmIND8(rEBX),0)
                     add ebx,16
                     movaps_rm8_r (rmIND8(rEDX),rXMM0,0)
                     add edx,16
                     dec ecx
                    jnz mc16_14
                }
            }
        }
    }
    else if (g_dwCPUFeatureSet & NV_FS_MMX)
    {
        __asm
        {
            mov ebx,[dwSrc]
            mov edx,[dwDest]
            mov ecx,[dwCount]
mc16_2:      movq mm0,[ebx]
             movq mm1,[ebx+8]
             add ebx,16
             movq [edx],mm0
             movq [edx+8],mm1
             add edx,16
             dec ecx
            jnz mc16_2
            emms
        }
    }
    else
    {
        nvMemCopy4 (dwDest,dwSrc,dwCount*4);
    }
}

/*
 * nvMemCopy64
 *
 * copies src to dest using 16*dword atoms (if possible).
 */
__inline void nvMemCopy64
(
    DWORD dwDest,
    DWORD dwSrc,
    DWORD dwCount   // in dwords
)
{
    if (g_dwCPUFeatureSet & NV_FS_KATMAI)
    {
        if (dwSrc & 15)
        {
            if (dwDest & 15)
            {
                __asm
                {
                    mov ebx,[dwSrc]
                    mov edx,[dwDest]
                    mov ecx,[dwCount]
        mc64_11:     movups_r_rm8 (rXMM0,rmIND8(rEBX), 0)
                     movups_r_rm8 (rXMM1,rmIND8(rEBX),16)
                     movups_r_rm8 (rXMM2,rmIND8(rEBX),32)
                     movups_r_rm8 (rXMM3,rmIND8(rEBX),48)
                     add ebx,64
                     movups_rm8_r (rmIND8(rEDX), 0,rXMM0)
                     movups_rm8_r (rmIND8(rEDX),16,rXMM1)
                     movups_rm8_r (rmIND8(rEDX),32,rXMM2)
                     movups_rm8_r (rmIND8(rEDX),48,rXMM3)
                     add edx,64
                     dec ecx
                    jnz mc64_11
                }
            }
            else
            {
                __asm
                {
                    mov ebx,[dwSrc]
                    mov edx,[dwDest]
                    mov ecx,[dwCount]
        mc64_12:     movups_r_rm8 (rXMM0,rmIND8(rEBX), 0)
                     movups_r_rm8 (rXMM1,rmIND8(rEBX),16)
                     movups_r_rm8 (rXMM2,rmIND8(rEBX),32)
                     movups_r_rm8 (rXMM3,rmIND8(rEBX),48)
                     add ebx,64
                     movaps_rm8_r (rmIND8(rEDX), 0,rXMM0)
                     movaps_rm8_r (rmIND8(rEDX),16,rXMM1)
                     movaps_rm8_r (rmIND8(rEDX),32,rXMM2)
                     movaps_rm8_r (rmIND8(rEDX),48,rXMM3)
                     add edx,64
                     dec ecx
                    jnz mc64_12
                }
            }
        }
        else
        {
            if (dwDest & 15)
            {
                __asm
                {
                    mov ebx,[dwSrc]
                    mov edx,[dwDest]
                    mov ecx,[dwCount]
        mc64_13:     movaps_r_rm8 (rXMM0,rmIND8(rEBX), 0)
                     movaps_r_rm8 (rXMM1,rmIND8(rEBX),16)
                     movaps_r_rm8 (rXMM2,rmIND8(rEBX),32)
                     movaps_r_rm8 (rXMM3,rmIND8(rEBX),48)
                     add ebx,64
                     movups_rm8_r (rmIND8(rEDX), 0,rXMM0)
                     movups_rm8_r (rmIND8(rEDX),16,rXMM1)
                     movups_rm8_r (rmIND8(rEDX),32,rXMM2)
                     movups_rm8_r (rmIND8(rEDX),48,rXMM3)
                     add edx,64
                     dec ecx
                    jnz mc64_13
                }
            }
            else
            {
                __asm
                {
                    mov ebx,[dwSrc]
                    mov edx,[dwDest]
                    mov ecx,[dwCount]
        mc64_14:     movaps_r_rm8 (rXMM0,rmIND8(rEBX), 0)
                     movaps_r_rm8 (rXMM1,rmIND8(rEBX),16)
                     movaps_r_rm8 (rXMM2,rmIND8(rEBX),32)
                     movaps_r_rm8 (rXMM3,rmIND8(rEBX),48)
                     add ebx,64

                     movaps_rm8_r (rmIND8(rEDX), 0,rXMM0)
                     movaps_rm8_r (rmIND8(rEDX),16,rXMM1)
                     movaps_rm8_r (rmIND8(rEDX),32,rXMM2)
                     movaps_rm8_r (rmIND8(rEDX),48,rXMM3)

                     add edx,64