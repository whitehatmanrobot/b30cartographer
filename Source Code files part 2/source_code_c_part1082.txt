fine isalnum(_c) ( (_ctype+1)[_c] & (_UPPER|_LOWER|_DIGIT) )
#define isprint(_c) ( (_ctype+1)[_c] & (_BLANK|_PUNCT|_UPPER|_LOWER|_DIGIT) )
#define isgraph(_c) ( (_ctype+1)[_c] & (_PUNCT|_UPPER|_LOWER|_DIGIT) )
#define iscntrl(_c) ( (_ctype+1)[_c] & _CONTROL )
#ifndef __STDC__
#define toupper(_c) ( (islower(_c)) ? _toupper(_c) : (_c) )
#define tolower(_c) ( (isupper(_c)) ? _tolower(_c) : (_c) )
#endif 
#define _tolower(_c)    ( (_c)-'A'+'a' )
#define _toupper(_c)    ( (_c)-'a'+'A' )
#define __isascii(_c)   ( (unsigned)(_c) < 0x80 )
#define __toascii(_c)   ( (_c) & 0x7f )

#ifndef isleadbyte
#ifdef _INTL
#define isleadbyte(_c)  __isleadbyte(_c)
#else 
#define isleadbyte(_c)  (0)
#endif 
#endif 

/* extended ctype macros */

#define __iscsymf(_c)   (isalpha(_c) || ((_c) == '_'))
#define __iscsym(_c)    (isalnum(_c) || ((_c) == '_'))

#ifndef __STDC__
/* Non-ANSI names for compatibility */
#ifndef _CTYPE_DEFINED
int __cdecl isascii(int);
int __cdecl toascii(int);
int __cdecl iscsymf(int);
int __cdecl iscsym(int);
#else 
#define isascii __isascii
#define toascii __toascii
#define iscsymf __iscsymf
#define iscsym  __iscsym
#endif 
#endif 

#ifdef __cplusplus
}
#endif 

#define _INC_CTYPE
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\tools\c816\inc\errno.h ===
/***
*errno.h - system wide error numbers (set by system calls)
*
*   Copyright (c) 1985-1992, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*   This file defines the system-wide error numbers (set by
*   system calls).  Conforms to the XENIX standard.  Extended
*   for compatibility with Uniforum standard.
*   [ANSI/System V]
*
****/

#ifndef _INC_ERRNO

#ifdef __cplusplus
extern "C" {
#endif 

#if (_MSC_VER <= 600)
#define __cdecl     _cdecl
#define __far       _far
#define __near      _near
#endif 

/* declare reference to errno */

#ifdef _MT
extern int __far * __cdecl __far volatile _errno(void);
#define errno   (*_errno())
#else 
extern int __near __cdecl volatile errno;
#endif 

/* Error Codes */

#define EZERO       0
#define EPERM       1
#define ENOENT      2
#define ESRCH       3
#define EINTR       4
#define EIO     5
#define ENXIO       6
#define E2BIG       7
#define ENOEXEC     8
#define EBADF       9
#define ECHILD      10
#define EAGAIN      11
#define ENOMEM      12
#define EACCES      13
#define EFAULT      14
#define ENOTBLK     15
#define EBUSY       16
#define EEXIST      17
#define EXDEV       18
#define ENODEV      19
#define ENOTDIR     20
#define EISDIR      21
#define EINVAL      22
#define ENFILE      23
#define EMFILE      24
#define ENOTTY      25
#define ETXTBSY     26
#define EFBIG       27
#define ENOSPC      28
#define ESPIPE      29
#define EROFS       30
#define EMLINK      31
#define EPIPE       32
#define EDOM        33
#define ERANGE      34
#define EUCLEAN     35
#define EDEADLOCK   36

#ifdef __cplusplus
}
#endif 

#define _INC_ERRNO
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\tools\c816\inc\dos.h ===
/***
*dos.h - definitions for MS-DOS interface routines
*
*   Copyright (c) 1985-1992, Microsoft Corporation. All rights reserved.
*
*Purpose:
*   Defines the structs and unions used for the direct DOS interface
*   routines; includes macros to access the segment and offset
*   values of far pointers, so that they may be used by the routines; and
*   provides function prototypes for direct DOS interface functions.
*
****/

#ifndef _INC_DOS

#ifdef __cplusplus
extern "C" {
#endif 

#if (_MSC_VER <= 600)
#define __cdecl     _cdecl
#define __far       _far
#define __interrupt _interrupt
#define __near      _near
#endif 

#ifndef _REGS_DEFINED

/* word registers */

struct _WORDREGS {
    unsigned int ax;
    unsigned int bx;
    unsigned int cx;
    unsigned int dx;
    unsigned int si;
    unsigned int di;
    unsigned int cflag;
    };

/* byte registers */

struct _BYTEREGS {
    unsigned char al, ah;
    unsigned char bl, bh;
    unsigned char cl, ch;
    unsigned char dl, dh;
    };

/* general purpose registers union -
 *  overlays the corresponding word and byte registers.
 */

union _REGS {
    struct _WORDREGS x;
    struct _BYTEREGS h;
    };

/* segment registers */

struct _SREGS {
    unsigned int es;
    unsigned int cs;
    unsigned int ss;
    unsigned int ds;
    };

#ifndef __STDC__
/* Non-ANSI names for compatibility */

struct WORDREGS {
    unsigned int ax;
    unsigned int bx;
    unsigned int cx;
    unsigned int dx;
    unsigned int si;
    unsigned int di;
    unsigned int cflag;
    };

struct BYTEREGS {
    unsigned char al, ah;
    unsigned char bl, bh;
    unsigned char cl, ch;
    unsigned char dl, dh;
    };

union REGS {
    struct WORDREGS x;
    struct BYTEREGS h;
    };

struct SREGS {
    unsigned int es;
    unsigned int cs;
    unsigned int ss;
    unsigned int ds;
    };

#endif 

#define _REGS_DEFINED
#endif 


/* dosexterror structure */

#ifndef _DOSERROR_DEFINED
#pragma pack(2)

struct _DOSERROR {
    int exterror;
    char errclass;
    char action;
    char locus;
    };

#if ((!defined (__STDC__)) && (!defined (__cplusplus)))
/* Non-ANSI name for compatibility */
struct DOSERROR {
    int exterror;
    char class;
    char action;
    char locus;
    };
#endif 

#pragma pack()
#define _DOSERROR_DEFINED
#endif 


/* _dos_findfirst structure */

#ifndef _FIND_T_DEFINED
#pragma pack(2)

struct _find_t {
    char reserved[21];
    char attrib;
    unsigned wr_time;
    unsigned wr_date;
    long size;
    char name[13];
    };

#ifndef __STDC__
/* Non-ANSI name for compatibility */
#define find_t _find_t
#endif 

#pragma pack()
#define _FIND_T_DEFINED
#endif 


/* _dos_getdate/_dossetdate and _dos_gettime/_dos_settime structures */

#ifndef _DATETIME_T_DEFINED
#pragma pack(2)

struct _dosdate_t {
    unsigned char day;      /* 1-31 */
    unsigned char month;        /* 1-12 */
    unsigned int year;      /* 1980-2099 */
    unsigned char dayofweek;    /* 0-6, 0=Sunday */
    };

struct _dostime_t {
    unsigned char hour; /* 0-23 */
    unsigned char minute;   /* 0-59 */
    unsigned char second;   /* 0-59 */
    unsigned char hsecond;  /* 0-99 */
    };

#ifndef __STDC__
/* Non-ANSI names for compatibility */
#define dosdate_t _dosdate_t
#define dostime_t _dostime_t
#endif 

#pragma pack()
#define _DATETIME_T_DEFINED
#endif 


/* _dos_getdiskfree structure */

#ifndef _DISKFREE_T_DEFINED

struct _diskfree_t {
    unsigned total_clusters;
    unsigned avail_clusters;
    unsigned sectors_per_cluster;
    unsigned bytes_per_sector;
    };

#ifndef __STDC__
/* Non-ANSI name for compatibility */
#define diskfree_t _diskfree_t
#endif 

#define _DISKFREE_T_DEFINED
#endif 


/* manifest constants for _hardresume result parameter */

#define _HARDERR_IGNORE     0   /* Ignore the error */
#define _HARDERR_RETRY      1   /* Retry the operation */
#define _HARDERR_ABORT      2   /* Abort program issuing Interrupt 23h */
#define _HARDERR_FAIL       3   /* Fail the system call in progress */
                    /* _HARDERR_FAIL is not supported on DOS 2.x */

/* File attribute constants */

#define _A_NORMAL   0x00    /* Normal file - No read/write restrictions */
#define _A_RDONLY   0x01    /* Read only file */
#define _A_HIDDEN   0x02    /* Hidden file */
#define _A_SYSTEM   0x04    /* System file */
#define _A_VOLID    0x08    /* Volume ID file */
#define _A_SUBDIR   0x10    /* Subdirectory */
#define _A_ARCH     0x20    /* Archive file */

/* macros to break C "far" pointers into their segment and offset components
 */

#define _FP_SEG(fp) (*((unsigned __far *)&(fp)+1))
#define _FP_OFF(fp) (*((unsigned __far *)&(fp)))

/* macro to construct a far pointer from segment and offset values
 */

#define _MK_FP(seg, offset) (void __far *)(((unsigned long)seg << 16) \
    + (unsigned long)(unsigned)offset)

/* external variable declarations */

extern unsigned int __near __cdecl _osversion;


/* function prototypes */

#ifndef _MT
int __cdecl _bdos(int, unsigned int, unsigned int);
#ifndef _WINDOWS
void __cdecl _chain_intr(void (__cdecl __interrupt __far *)());
#endif 
void __cdecl _disable(void);
#ifndef _WINDOWS
unsigned __cdecl _dos_allocmem(unsigned, unsigned *);
#endif 
unsigned __cdecl _dos_close(int);
unsigned __cdecl _dos_commit(int);
unsigned __cdecl _dos_creat(const char *, unsigned, int *);
unsigned __cdecl _dos_creatnew(const char *, unsigned, int *);
unsigned __cdecl _dos_findfirst(const char *, unsigned, struct _find_t *);
unsigned __cdecl _dos_findnext(struct _find_t *);
#ifndef _WINDOWS
unsigned __cdecl _dos_freemem(unsigned);
#endif 
void __cdecl _dos_getdate(struct _dosdate_t *);
void __cdecl _dos_getdrive(unsigned *);
unsigned __cdecl _dos_getdiskfree(unsigned, struct _diskfree_t *);
unsigned __cdecl _dos_getfileattr(const char *, unsigned *);
unsigned __cdecl _dos_getftime(int, unsigned *, unsigned *);
void __cdecl _dos_gettime(struct _dostime_t *);
void (__cdecl __interrupt __far * __cdecl _dos_getvect(unsigned))();
#ifndef _WINDOWS
void __cdecl _dos_keep(unsigned, unsigned);
#endif 
unsigned __cdecl _dos_lock(int, int, unsigned long, unsigned long);
unsigned __cdecl _dos_open(const char *, unsigned, int *);
unsigned __cdecl _dos_read(int, void __far *, unsigned, unsigned *);
unsigned long __cdecl _dos_seek(int, unsigned long, int);
#ifndef _WINDOWS
unsigned __cdecl _dos_setblock(unsigned, unsigned, unsigned *);
#endif 
unsigned __cdecl _dos_setdate(struct _dosdate_t *);
void __cdecl _dos_setdrive(unsigned, unsigned *);
unsigned __cdecl _dos_setfileattr(const char *, unsigned);
unsigned __cdecl _dos_setftime(int, unsigned, unsigned);
unsigned __cdecl _dos_settime(struct _dostime_t *);
#ifndef _WINDOWS
void __cdecl _dos_setvect(unsigned, void (__cdecl __interrupt __far *)());
#endif 
unsigned __cdecl _dos_write(int, const void __far *, unsigned, unsigned *);
int __cdecl _dosexterr(struct _DOSERROR *);
void __cdecl _enable(void);
#ifndef _WINDOWS
void __cdecl _harderr(void (__far __cdecl *)(unsigned, unsigned,
    unsigned __far *));
void __cdecl _hardresume(int);
void __cdecl _hardretn(int);
#endif 
int __cdecl _intdos(union _REGS *, union _REGS *);
int __cdecl _intdosx(union _REGS *, union _REGS *, struct _SREGS *);
int __cdecl _int86(int, union _REGS *, union _REGS *);
int __cdecl _int86x(int, union _REGS *, union _REGS *, struct _SREGS *);
#endif 

void __cdecl _segread(struct _SREGS *);

#ifndef __STDC__
/* Non-ANSI names for compatibility */

#define FP_SEG     _FP_SEG
#define FP_OFF     _FP_OFF
#define MK_FP      _MK_FP

#ifndef _MT
int __cdecl bdos(int, unsigned int, unsigned int);
int __cdecl intdos(union REGS *, union REGS *);
int __cdecl intdosx(union REGS *, union REGS *, struct SREGS *);
int __cdecl int86(int, union REGS *, union REGS *);
int __cdecl int86x(int, union REGS *, union REGS *, struct SREGS *);
#ifndef __cplusplus
int __cdecl dosexterr(struct DOSERROR *);
#endif 
#endif 
void __cdecl segread(struct SREGS *);

#endif 

#ifdef __cplusplus
}
#endif 

#define _INC_DOS
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\tools\c816\inc\fcntl.h ===
/***
*fcntl.h - file control options used by open()
*
*   Copyright (c) 1985-1992, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*   This file defines constants for the file control options used
*   by the open() function.
*   [System V]
*
****/

#ifndef _INC_FCNTL

#define _O_RDONLY   0x0000  /* open for reading only */
#define _O_WRONLY   0x0001  /* open for writing only */
#define _O_RDWR     0x0002  /* open for reading and writing */
#define _O_APPEND   0x0008  /* writes done at eof */

#define _O_CREAT    0x0100  /* create and open file */
#define _O_TRUNC    0x0200  /* open and truncate */
#define _O_EXCL     0x0400  /* open only if file doesn't already exist */

/* _O_TEXT files have <cr><lf> sequences translated to <lf> on read()'s,
** and <lf> sequences translated to <cr><lf> on write()'s
*/

#define _O_TEXT     0x4000  /* file mode is text (translated) */
#define _O_BINARY   0x8000  /* file mode is binary (untranslated) */

/* macro to translate the C 2.0 name used to force binary mode for files */

#define _O_RAW  _O_BINARY

/* Open handle inherit bit */

#define _O_NOINHERIT    0x0080  /* child process doesn't inherit file */

#ifndef __STDC__
/* Non-ANSI names for compatibility */
#define O_RDONLY    _O_RDONLY
#define O_WRONLY    _O_WRONLY
#define O_RDWR      _O_RDWR
#define O_APPEND    _O_APPEND
#define O_CREAT     _O_CREAT
#define O_TRUNC     _O_TRUNC
#define O_EXCL      _O_EXCL
#define O_TEXT      _O_TEXT
#define O_BINARY    _O_BINARY
#define O_NOINHERIT _O_NOINHERIT
#endif 

#define _INC_FCNTL
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\tools\c816\inc\float.h ===
/***
*float.h - constants for floating point values
*
*   Copyright (c) 1985-1992, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*   This file contains defines for a number of implementation dependent
*   values which are commonly used by sophisticated numerical (floating
*   point) programs.
*   [ANSI]
*
****/

#ifndef _INC_FLOAT

#ifdef __cplusplus
extern "C" {
#endif 

#if (_MSC_VER <= 600)
#define __cdecl     _cdecl
#define __far       _far
#endif 

#define DBL_DIG     15          /* # of decimal digits of precision */
#define DBL_EPSILON 2.2204460492503131e-016 /* smallest such that 1.0+DBL_EPSILON != 1.0 */
#define DBL_MANT_DIG    53          /* # of bits in mantissa */
#define DBL_MAX     1.7976931348623158e+308 /* max value */
#define DBL_MAX_10_EXP  308         /* max decimal exponent */
#define DBL_MAX_EXP 1024            /* max binary exponent */
#define DBL_MIN     2.2250738585072014e-308 /* min positive value */
#define DBL_MIN_10_EXP  (-307)          /* min decimal exponent */
#define DBL_MIN_EXP (-1021)         /* min binary exponent */
#define _DBL_RADIX  2           /* exponent radix */
#define _DBL_ROUNDS 1           /* addition rounding: near */

#define FLT_DIG     6           /* # of decimal digits of precision */
#define FLT_EPSILON 1.192092896e-07F    /* smallest such that 1.0+FLT_EPSILON != 1.0 */
#define FLT_GUARD   0
#define FLT_MANT_DIG    24          /* # of bits in mantissa */
#define FLT_MAX     3.402823466e+38F    /* max value */
#define FLT_MAX_10_EXP  38          /* max decimal exponent */
#define FLT_MAX_EXP 128         /* max binary exponent */
#define FLT_MIN     1.175494351e-38F    /* min positive value */
#define FLT_MIN_10_EXP  (-37)           /* min decimal exponent */
#define FLT_MIN_EXP (-125)          /* min binary exponent */
#define FLT_NORMALIZE   0
#define FLT_RADIX   2           /* exponent radix */
#define FLT_ROUNDS  1           /* addition rounding: near */

#define LDBL_DIG    18          /* # of decimal digits of precision */
#define LDBL_EPSILON    1.084202172485504434e-019L /* smallest such that 1.0+LDBL_EPSILON != 1.0 */
#define LDBL_MANT_DIG   64          /* # of bits in mantissa */
#define LDBL_MAX    1.189731495357231765e+4932L /* max value */
#define LDBL_MAX_10_EXP 4932            /* max decimal exponent */
#define LDBL_MAX_EXP    16384           /* max binary exponent */
#define LDBL_MIN    3.3621031431120935063e-4932L /* min positive value */
#define LDBL_MIN_10_EXP (-4931)         /* min decimal exponent */
#define LDBL_MIN_EXP    (-16381)        /* min binary exponent */
#define _LDBL_RADIX 2           /* exponent radix */
#define _LDBL_ROUNDS    1           /* addition rounding: near */


/*
 *  8087/80287 math control information
 */


/* User Control Word Mask and bit definitions.
 * These definitions match the 8087/80287
 */

#define _MCW_EM     0x003f      /* interrupt Exception Masks */
#define _EM_INVALID 0x0001      /*   invalid */
#define _EM_DENORMAL    0x0002      /*   denormal */
#define _EM_ZERODIVIDE  0x0004      /*   zero divide */
#define _EM_OVERFLOW    0x0008      /*   overflow */
#define _EM_UNDERFLOW   0x0010      /*   underflow */
#define _EM_INEXACT 0x0020      /*   inexact (precision) */

#define _MCW_IC     0x1000      /* Infinity Control */
#define _IC_AFFINE  0x1000      /*   affine */
#define _IC_PROJECTIVE  0x0000      /*   projective */

#define _MCW_RC     0x0c00      /* Rounding Control */
#define _RC_CHOP    0x0c00      /*   chop */
#define _RC_UP      0x0800      /*   up */
#define _RC_DOWN    0x0400      /*   down */
#define _RC_NEAR    0x0000      /*   near */

#define _MCW_PC     0x0300      /* Precision Control */
#define _PC_24      0x0000      /*    24 bits */
#define _PC_53      0x0200      /*    53 bits */
#define _PC_64      0x0300      /*    64 bits */


/* initial Control Word value */

#define _CW_DEFAULT ( _IC_AFFINE + _RC_NEAR + _PC_64 + _EM_DENORMAL + _EM_UNDERFLOW + _EM_INEXACT )


/* user Status Word bit definitions */

#define _SW_INVALID 0x0001  /* invalid */
#define _SW_DENORMAL    0x0002  /* denormal */
#define _SW_ZERODIVIDE  0x0004  /* zero divide */
#define _SW_OVERFLOW    0x0008  /* overflow */
#define _SW_UNDERFLOW   0x0010  /* underflow */
#define _SW_INEXACT 0x0020  /* inexact (precision) */


/* invalid subconditions (_SW_INVALID also set) */

#define _SW_UNEMULATED      0x0040  /* unemulated instruction */
#define _SW_SQRTNEG     0x0080  /* square root of a neg number */
#define _SW_STACKOVERFLOW   0x0200  /* FP stack overflow */
#define _SW_STACKUNDERFLOW  0x0400  /* FP stack underflow */


/*  Floating point error signals and return codes */

#define _FPE_INVALID        0x81
#define _FPE_DENORMAL       0x82
#define _FPE_ZERODIVIDE     0x83
#define _FPE_OVERFLOW       0x84
#define _FPE_UNDERFLOW      0x85
#define _FPE_INEXACT        0x86

#define _FPE_UNEMULATED     0x87
#define _FPE_SQRTNEG        0x88
#define _FPE_STACKOVERFLOW  0x8a
#define _FPE_STACKUNDERFLOW 0x8b

#define _FPE_EXPLICITGEN    0x8c    /* raise( SIGFPE ); */


/* function prototypes */

unsigned int __cdecl _clear87(void);
unsigned int __cdecl _control87(unsigned int, unsigned int);
void __cdecl _fpreset(void);
unsigned int __cdecl _status87(void);


#ifndef __STDC__
/* Non-ANSI names for compatibility */

#define DBL_RADIX       _DBL_RADIX
#define DBL_ROUNDS      _DBL_ROUNDS

#define LDBL_RADIX      _LDBL_RADIX
#define LDBL_ROUNDS     _LDBL_ROUNDS

#define MCW_EM          _MCW_EM
#define EM_INVALID      _EM_INVALID
#define EM_DENORMAL     _EM_DENORMAL
#define EM_ZERODIVIDE       _EM_ZERODIVIDE
#define EM_OVERFLOW     _EM_OVERFLOW
#define EM_UNDERFLOW        _EM_UNDERFLOW
#define EM_INEXACT      _EM_INEXACT

#define MCW_IC          _MCW_IC
#define IC_AFFINE       _IC_AFFINE
#define IC_PROJECTIVE       _IC_PROJECTIVE

#define MCW_RC          _MCW_RC
#define RC_CHOP         _RC_CHOP
#define RC_UP           _RC_UP
#define RC_DOWN         _RC_DOWN
#define RC_NEAR         _RC_NEAR

#define MCW_PC          _MCW_PC
#define PC_24           _PC_24
#define PC_53           _PC_53
#define PC_64           _PC_64

#define CW_DEFAULT      _CW_DEFAULT

#define SW_INVALID      _SW_INVALID
#define SW_DENORMAL     _SW_DENORMAL
#define SW_ZERODIVIDE       _SW_ZERODIVIDE
#define SW_OVERFLOW     _SW_OVERFLOW
#define SW_UNDERFLOW        _SW_UNDERFLOW
#define SW_INEXACT      _SW_INEXACT

#define SW_UNEMULATED       _SW_UNEMULATED
#define SW_SQRTNEG      _SW_SQRTNEG
#define SW_STACKOVERFLOW    _SW_STACKOVERFLOW
#define SW_STACKUNDERFLOW   _SW_STACKUNDERFLOW

#define FPE_INVALID     _FPE_INVALID
#define FPE_DENORMAL        _FPE_DENORMAL
#define FPE_ZERODIVIDE      _FPE_ZERODIVIDE
#define FPE_OVERFLOW        _FPE_OVERFLOW
#define FPE_UNDERFLOW       _FPE_UNDERFLOW
#define FPE_INEXACT     _FPE_INEXACT

#define FPE_UNEMULATED      _FPE_UNEMULATED
#define FPE_SQRTNEG     _FPE_SQRTNEG
#define FPE_STACKOVERFLOW   _FPE_STACKOVERFLOW
#define FPE_STACKUNDERFLOW  _FPE_STACKUNDERFLOW

#define FPE_EXPLICITGEN     _FPE_EXPLICITGEN

#endif 


#ifdef __cplusplus
}
#endif 

#define _INC_FLOAT
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\tools\c816\inc\graph.h ===
/***
*graph.h - declare constants, functions, and macros for graphics library
*
*   Copyright (c) 1987 - 1992, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*   This file declares the graphics library functions and the
*   structures and manifest constants that are used with them.
*
***************************************************************************/

#ifndef	_WINDOWS
/* Force graphics.lib to be linked in if graph.h used */
#pragma comment(lib,"graphics.lib")
#endif

#ifdef __cplusplus
extern "C" {			/* allow use with C++ */
#endif

#if (_MSC_VER <= 600)
#define	__cdecl	_cdecl
#define	__far	_far
#define	__huge	_huge
#endif

/* force word packing to avoid possible -Zp override */
#pragma pack(2)


/* user-visible declarations for Quick-C Graphics Library */

#ifndef _VIDEOCONFIG_DEFINED
/* structure for _getvideoconfig() as visible to user */
struct _videoconfig {
	short numxpixels;	/* number of pixels on X axis */
	short numypixels;	/* number of pixels on Y axis */
	short numtextcols;	/* number of text columns available */
	short numtextrows;	/* number of text rows available */
	short numcolors;	/* number of actual colors */
	short bitsperpixel;	/* number of bits per pixel */
	short numvideopages;	/* number of available video pages */
	short mode;		/* current video mode */
	short adapter;		/* active display adapter */
	short monitor;		/* active display monitor */
	short memory;		/* adapter video memory in K bytes */
};
#define _VIDEOCONFIG_DEFINED
#endif

#ifndef _XYCOORD_DEFINED
/* return value of _setvieworg(), etc. */
struct _xycoord {
	short xcoord;
	short ycoord;
};
#define _XYCOORD_DEFINED
#endif

/* structure for text position */
#ifndef _RCCOORD_DEFINED
struct _rccoord {
	short row;
	short col;
};
#define _RCCOORD_DEFINED
#endif

#ifndef __STDC__
/* Non-ANSI names for compatibility */
#define videoconfig	_videoconfig
#define xycoord		_xycoord
#define rccoord		_rccoord
#endif


/* ERROR HANDLING */
short __far __cdecl _grstatus(void);

/* Error Status Information returned by _grstatus() */

/* successful */
#define	_GROK                        0

/* errors */
#define _GRERROR                    (-1)
#define	_GRMODENOTSUPPORTED	    (-2)
#define	_GRNOTINPROPERMODE          (-3)
#define _GRINVALIDPARAMETER         (-4)
#define	_GRFONTFILENOTFOUND         (-5)
#define	_GRINVALIDFONTFILE          (-6)
#define _GRCORRUPTEDFONTFILE        (-7)
#define _GRINSUFFICIENTMEMORY       (-8)
#define _GRINVALIDIMAGEBUFFER       (-9)

/* warnings */
#define _GRNOOUTPUT                  1
#define _GRCLIPPED                   2
#define _GRPARAMETERALTERED          3
#define _GRTEXTNOTSUPPORTED          4


/* SETUP AND CONFIGURATION */

short __far __cdecl _setvideomode(short);
short __far __cdecl _setvideomoderows(short,short); /* return rows; 0 if error */

/* arguments to _setvideomode() */
#define _MAXRESMODE	(-3)	/* graphics mode with highest resolution */
#define _MAXCOLORMODE	(-2)	/* graphics mode with most colors */
#define _DEFAULTMODE	(-1)	/* restore screen to original mode */
#define _TEXTBW40	0	/* 40-column text, 16 grey */
#define _TEXTC40	1	/* 40-column text, 16/8 color */
#define _TEXTBW80	2	/* 80-column text, 16 grey */
#define _TEXTC80	3	/* 80-column text, 16/8 color */
#define _MRES4COLOR	4	/* 320 x 200, 4 color */
#define _MRESNOCOLOR	5	/* 320 x 200, 4 grey */
#define _HRESBW		6	/* 640 x 200, BW */
#define _TEXTMONO	7	/* 80-column text, BW */
#define _HERCMONO	8	/* 720 x 348, BW for HGC */
#define _MRES16COLOR	13	/* 320 x 200, 16 color */
#define _HRES16COLOR	14	/* 640 x 200, 16 color */
#define _ERESNOCOLOR	15	/* 640 x 350, BW */
#define _ERESCOLOR	16	/* 640 x 350, 4 or 16 color */
#define _VRES2COLOR	17	/* 640 x 480, BW */
#define _VRES16COLOR	18	/* 640 x 480, 16 color */
#define _MRES256COLOR	19	/* 320 x 200, 256 color */
#define _ORESCOLOR	64	/* 640 x 400, 1 of 16 colors (Olivetti only) */

/* the following 8 modes require VESA SuperVGA BIOS extensions */
#define	_ORES256COLOR	0x0100	/* 640 x 400, 256 color */
#define	_VRES256COLOR	0x0101	/* 640 x 480, 256 color */

/* WARNING: DO NOT attempt to set the following modes without ensuring that
   your monitor can safely handle that resolution.  Otherwise, you may risk
   damaging your display monitor!  Consult your owner's manual for details.
   Note: _MAXRESMODE and _MAXCOLORMODE never select SRES, XRES, or ZRES modes */

/* requires NEC MultiSync 3D or equivalent, or better */
#define	_SRES16COLOR	0x0102	/* 800 x 600, 16 color */
#define	_SRES256COLOR	0x0103	/* 800 x 600, 256 color */

/* requires NEC MultiSync 4D or equivalent, or better */
#define	_XRES16COLOR	0x0104	/* 1024 x 768, 16 color */
#define	_XRES256COLOR	0x0105	/* 1024 x 768, 256 color */

/* requires NEC MultiSync 5D or equivalent, or better */
#define	_ZRES16COLOR	0x0106	/* 1280 x 1024, 16 color */
#define	_ZRES256COLOR	0x0107	/* 1280 x 1024, 256 color */


short __far __cdecl _setactivepage(short);
short __far __cdecl _setvisualpage(short);
short __far __cdecl _getactivepage(void);
short __far __cdecl _getvisualpage(void);

/* _videoconfig adapter values */
/* these manifest constants can be used to determine the type of the active  */
/* adapter, using either simple comparisons or the bitwise-AND operator (&)  */
#define _MDPA		0x0001	/* Monochrome Display Adapter	      (MDPA) */
#define _CGA		0x0002	/* Color Graphics Adapter	      (CGA)  */
#define _EGA		0x0004	/* Enhanced Graphics Adapter	      (EGA)  */
#define _VGA		0x0008	/* Video Graphics Array		      (VGA)  */
#define _MCGA		0x0010	/* MultiColor Graphics Array	      (MCGA) */
#define _HGC		0x0020	/* Hercules Graphics Card	      (HGC)  */
#define _OCGA		0x0042	/* Olivetti Color Graphics Adapter    (OCGA) */
#define _OEGA		0x0044	/* Olivetti Enhanced Graphics Adapter (OEGA) */
#define _OVGA		0x0048	/* Olivetti Video Graphics Array      (OVGA) */
#define _SVGA		0x0088	/* Super VGA with VESA BIOS support   (SVGA) */

/* _videoconfig monitor values */
/* these manifest constants can be used to determine the type of monitor in */
/* use, using either simple comparisons or the bitwise-AND operator (&) */
#define _MONO		0x0001	/* Monochrome */
#define _COLOR		0x0002	/* Color (or Enhanced emulating color) */
#define _ENHCOLOR	0x0004	/* Enhanced Color */
#define _ANALOGMONO	0x0008	/* Analog Monochrome only */
#define _ANALOGCOLOR	0x0010	/* Analog Color only */
#define _ANALOG		0x0018	/* Analog Monochrome and Color modes */

struct _videoconfig __far * __far __cdecl _getvideoconfig(struct _videoconfig __far *);


/* COORDINATE SYSTEMS */

struct _xycoord __far __cdecl _setvieworg(short, short);
#define _setlogorg _setvieworg		/* obsolescent */

struct _xycoord __far __cdecl _getviewcoord(short, short);
#define _getlogcoord _getviewcoord	/* obsolescent */

struct _xycoord __far __cdecl _getphyscoord(short, short);

void __far __cdecl _setcliprgn(short, short, short, short);
void __far __cdecl _setviewport(short, short, short, short);


/* OUTPUT ROUTINES */

/* control parameters for _ellipse, _rectangle, _pie and _polygon */
#define _GBORDER	2	/* draw outline only */
#define _GFILLINTERIOR	3	/* fill using current fill mask */

/* parameters for _clearscreen */
#define _GCLEARSCREEN	0
#define _GVIEWPORT	1
#define _GWINDOW	2

void __far __cdecl _clearscreen(short);

struct _xycoord __far __cdecl _moveto(short, short);
struct _xycoord __far __cdecl _getcurrentposition(void);

short __far __cdecl _lineto(short, short);
short __far __cdecl _rectangle(short, short, short, short, short);
short __far __cdecl _polygon(short, const struct _xycoord __far *, short);
short __far __cdecl _arc(short, short, short, short, short, short, short, short);
short __far __cdecl _ellipse(short, short, short, short, short);
short __far __cdecl _pie(short, short, short, short, short, short, short, short, short);

short __far __cdecl _getarcinfo(struct _xycoord __far *, struct _xycoord __far *, struct _xycoord __far *);

short __far __cdecl _setpixel(short, short);
short __far __cdecl _getpixel(short, short);
short __far __cdecl _floodfill(short, short, short);


/* PEN COLOR, LINE STYLE, WRITE MODE, FILL PATTERN */

short __far __cdecl _setcolor(short);
short __far __cdecl _getcolor(void);

void __far __cdecl _setlinestyle(unsigned short);
unsigned short __far __cdecl _getlinestyle(void);

short __far __cdecl _setwritemode(short);
short __far __cdecl _getwritemode(void);

void __far __cdecl _setfillmask(const unsigned char __far *);
unsigned char __far * __far __cdecl _getfillmask(unsigned char __far *);


/* COLOR SELECTION */

long __far __cdecl _setbkcolor(long);
long __far __cdecl _getbkcolor(void);

long __far __cdecl _remappalette(short, long);
short __far __cdecl _remapallpalette(const long __far *);
short __far __cdecl _selectpalette(short);


/* TEXT */
/* parameters for _displaycursor */
#define _GCURSOROFF	0
#define _GCURSORON	1

/* parameters for _wrapon */
#define _GWRAPOFF	0
#define _GWRAPON	1


/* direction parameters for _scrolltextwindow */
#define _GSCROLLUP	1
#define _GSCROLLDOWN	(-1)

/* request maximum number of rows in _settextrows and _setvideomoderows */
#define _MAXTEXTROWS	(-1)

short __far __cdecl _settextrows(short); /* returns # rows set; 0 if error */
void __far __cdecl _settextwindow(short, short, short, short);
void __far __cdecl _gettextwindow(short __far *, short __far *, short __far *, short __far *);
void __far __cdecl _scrolltextwindow(short);
void __far __cdecl _outmem(const char __far *, short);
void __far __cdecl _outtext(const char __far *);
short __far __cdecl _inchar(void);
short __far __cdecl _wrapon(short);

short __far __cdecl _displaycursor(short);
short __far __cdecl _settextcursor(short);
short __far __cdecl _gettextcursor(void);

struct _rccoord __far __cdecl _settextposition(short, short);
struct _rccoord __far __cdecl _gettextposition(void);

short __far __cdecl _settextcolor(short);
short __far __cdecl _gettextcolor(void);


/* SCREEN IMAGES */

void __far __cdecl _getimage(short, short, short, short, char __huge *);
void __far __cdecl _putimage(short, short, char __huge *, short);
long __far __cdecl _imagesize(short, short, short, short);

/* "action verbs" for _putimage() and _setwritemode() */
#define _GPSET		3
#define _GPRESET	2
#define _GAND		1
#define _GOR		0
#define _GXOR		4


/* Color values are used with _setbkcolor in graphics modes and also by
   _remappalette and _remapallpalette.  Also known as palette colors.
   Not to be confused with color indices (aka. color attributes).  */

/* universal color values (all color modes): */
#define _BLACK		0x000000L
#define _BLUE		0x2a0000L
#define _GREEN		0x002a00L
#define _CYAN		0x2a2a00L
#define _RED		0x00002aL
#define _MAGENTA	0x2a002aL
#define _BROWN		0x00152aL
#define _WHITE		0x2a2a2aL
#define _GRAY		0x151515L
#define _LIGHTBLUE	0x3F1515L
#define _LIGHTGREEN	0x153f15L
#define _LIGHTCYAN	0x3f3f15L
#define _LIGHTRED	0x15153fL
#define _LIGHTMAGENTA	0x3f153fL
#define _YELLOW		0x153f3fL
#define _BRIGHTWHITE	0x3f3f3fL

/* the following is obsolescent and defined only for backward compatibility */
#define _LIGHTYELLOW	_YELLOW

/* mono mode F (_ERESNOCOLOR) color values: */
#define _MODEFOFF	0L
#define _MODEFOFFTOON	1L
#define _MODEFOFFTOHI	2L
#define _MODEFONTOOFF	3L
#define _MODEFON	4L
#define _MODEFONTOHI	5L
#define _MODEFHITOOFF	6L
#define _MODEFHITOON	7L
#define _MODEFHI	8L

/* mono mode 7 (_TEXTMONO) color values: */
#define _MODE7OFF	0L
#define _MODE7ON	1L
#define _MODE7HI	2L


/* Warning:  these '_xy' entrypoints are undocumented.
   They may or may not be supported in future versions. */
struct _xycoord __far __cdecl _moveto_xy(struct _xycoord);
short __far __cdecl _lineto_xy(struct _xycoord);
short __far __cdecl _rectangle_xy(short,struct _xycoord,struct _xycoord);
short __far __cdecl _arc_xy(struct _xycoord, struct _xycoord, struct _xycoord, struct _xycoord);
short __far __cdecl _ellipse_xy(short, struct _xycoord, struct _xycoord);
short __far __cdecl _pie_xy(short, struct _xycoord, struct _xycoord, struct _xycoord, struct _xycoord);
short __far __cdecl _getpixel_xy(struct _xycoord);
short __far __cdecl _setpixel_xy(struct _xycoord);
short __far __cdecl _floodfill_xy(struct _xycoord, short);
void __far __cdecl _getimage_xy(struct _xycoord,struct _xycoord, char __huge *);
long __far __cdecl _imagesize_xy(struct _xycoord,struct _xycoord);
void __far __cdecl _putimage_xy(struct _xycoord, char __huge *, short);


/* WINDOW COORDINATE SYSTEM */

#ifndef _WXYCOORD_DEFINED
/* structure for window coordinate pair */
struct _wxycoord {
	double wx;	/* window x coordinate */
	double wy;	/* window y coordinate */
	};
#define _WXYCOORD_DEFINED
#endif


/* define real coordinate window - returns non-zero if successful */
short __far __cdecl _setwindow(short,double,double,double,double);

/* convert from view to window coordinates */
struct _wxycoord __far __cdecl _getwindowcoord(short,short);
struct _wxycoord __far __cdecl _getwindowcoord_xy(struct _xycoord);

/* convert from window to view coordinates */
struct _xycoord __far __cdecl _getviewcoord_w(double,double);
struct _xycoord __far __cdecl _getviewcoord_wxy(const struct _wxycoord __far *);

/*	return the window coordinates of the current graphics output
	position as an _wxycoord structure. no error return. */
struct _wxycoord __far __cdecl _getcurrentposition_w(void);


/* window coordinate entry points for graphics output routines */

/*	returns nonzero if successful; otherwise 0	*/
short __far __cdecl _arc_w(double, double, double, double, double, double, double, double);
short __far __cdecl _arc_wxy(const struct _wxycoord __far *, const struct _wxycoord __far *, const struct _wxycoord __far *, const struct _wxycoord __far *);

/*	returns nonzero if successful; otherwise 0	*/
short __far __cdecl _ellipse_w(short, double, double, double, double);
short __far __cdecl _ellipse_wxy(short, const struct _wxycoord __far *, const struct _wxycoord __far *);

/*	returns nonzero if successful; otherwise 0	*/
short __far __cdecl _floodfill_w(double, double, short);

/*	returns pixel value at given point; -1 if unsuccessful. */
short __far __cdecl _getpixel_w(double, double);

/*	returns nonzero if successful; otherwise 0	*/
short __far __cdecl _lineto_w(double, double);

/*	returns the view coordinates of the previous output
	position as a _wxycoord structure. no error return */
struct _wxycoord __far __cdecl _moveto_w(double, double);

/*	returns nonzero if successful; otherwise 0	*/
short __far __cdecl _pie_w(short, double, double, double, double, double, double, double, double);
short __far __cdecl _pie_wxy(short, const struct _wxycoord __far *, const struct _wxycoord __far *, const struct _wxycoord __far *, const struct _wxycoord __far *);

/*	returns nonzero if successful; otherwise 0	*/
short __far __cdecl _rectangle_w(short, double, double, double, double);
short __far __cdecl _rectangle_wxy(short, const struct _wxycoord __far *, const struct _wxycoord __far *);

/*	returns nonzero if successful; otherwise 0	*/
short __far __cdecl _polygon_w(short, const double __far *, short);
short __far __cdecl _polygon_wxy(short, const struct _wxycoord __far *, short);

/*	returns previous color; -1 if unsuccessful */
short __far __cdecl _setpixel_w(double, double);


/* window coordinate image routines */

/*	no return value */
void __far __cdecl _getimage_w(double, double, double, double, char __huge *);
void __far __cdecl _getimage_wxy(const struct _wxycoord __far *, const struct _wxycoord __far *, char __huge *);

/*	returns the image's storage size in bytes */
long __far __cdecl _imagesize_w(double, double, double, double);
long __far __cdecl _imagesize_wxy(const struct _wxycoord __far *, const struct _wxycoord __far *);

/*	no return value */
void __far __cdecl _putimage_w(double, double ,char __huge * ,short);


/* FONTS */

#ifndef _FONTINFO_DEFINED
/* structure for _getfontinfo() */
struct _fontinfo {
	int	type;		/* b0 set = vector,clear = bit map	*/
	int	ascent;		/* pix dist from top to baseline	*/
	int	pixwidth;	/* character width in pixels, 0=prop	*/
	int	pixheight;	/* character height in pixels		*/
	int	avgwidth;	/* average character width in pixels	*/
	char	filename[81];	/* file name including path		*/
	char	facename[32];	/* font name				*/
};
#define _FONTINFO_DEFINED
#endif


/* font function prototypes */
short	__far __cdecl	_registerfonts( const char __far *);
void	__far __cdecl	_unregisterfonts( void );
short	__far __cdecl	_setfont( const char __far * );
short	__far __cdecl	_getfontinfo( struct _fontinfo __far * );
void	__far __cdecl	_outgtext( const char __far * );
short	__far __cdecl	_getgtextextent( const char __far * );
struct _xycoord __far __cdecl _setgtextvector( short, short );
struct _xycoord __far __cdecl _getgtextvector(void);


#ifdef _WINDOWS
/* QuickWin graphics extension prototypes */
int __far __cdecl _wgclose( int );
int __far __cdecl _wggetactive( void );
int __far __cdecl _wgopen( char __far * );
int __far __cdecl _wgsetactive( int );
#endif


/* restore default packing */
#pragma pack()

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\tools\c816\inc\iomanip.h ===
/***
*iomanip.h - definitions/declarations for iostream's parameterized manipulators
*
*   Copyright (c) 1991-1992, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*   This file defines the classes, values, macros, and functions
*   used by the iostream classes' paramterized manipulators.
*   [AT&T C++]
*
****/

#ifndef _INC_IOMANIP
#define _INC_IOMANIP
#include <iostream.h>

// Force word packing to avoid possible -Zp override
#pragma pack(2)

#pragma warning(disable:4505)       // disable unwanted /W4 warning
// #pragma warning(default:4505)    // use this to reenable, if necessary

// CONSIDER: use macro to define these
// #define __MKMANIP(X) \#define X##(T) __##X##_ \#\# T
// __MKMANIP(SMANIP);
// __MKMANIP(SAPP);
// __MKMANIP(IMANIP);
// __MKMANIP(IAPP);
// __MKMANIP(OMANIP);
// __MKMANIP(OAPP);
// __MKMANIP(IOMANIP);
// __MKMANIP(IOAPP);

#define SMANIP(T) __SMANIP_##T
#define SAPP(T) __SAPP_##T
#define IMANIP(T) __IMANIP_##T
#define IAPP(T) __IAPP_##T
#define OMANIP(T) __OMANIP_##T
#define OAPP(T) __OAPP_##T
#define IOMANIP(T) __IOMANIP_##T
#define IOAPP(T) __IOAPP_##T

#define IOMANIPdeclare(T)  \
class SMANIP(T) { \
public: \
    SMANIP(T)(ios& (*f)(ios&,T), T t) { _fp = f; _tp = t; } \
    friend istream& operator>>(istream& s, SMANIP(T) & sm) { (*(sm._fp))(s,sm._tp); return s; } \
    friend ostream& operator<<(ostream& s, SMANIP(T) & sm) { (*(sm._fp))(s,sm._tp); return s; } \
private:    \
    ios& (* _fp)(ios&,T); \
    T _tp; \
};  \
class SAPP(T) { \
public: \
    SAPP(T)( ios& (*f)(ios&,T)) { _fp = f; }    \
    SMANIP(T) operator()(T t) { return SMANIP(T)(_fp,t); }  \
private:    \
    ios& (* _fp)(ios&,T); \
};  \
class IMANIP(T) { \
public: \
    IMANIP(T)(istream& (*f)(istream&,T), T t) { _fp = f; _tp = t; } \
    friend istream& operator>>(istream& s, IMANIP(T) & sm) { (*sm._fp)(s,sm._tp); return s; } \
private:    \
    istream& (* _fp)(istream&,T); \
    T _tp;  \
};  \
class IAPP(T) { \
public: \
    IAPP(T)( istream& (*f)(istream&,T)) { _fp = f; }    \
    IMANIP(T) operator()(T t) { return IMANIP(T)(_fp,t); }  \
private:    \
    istream& (* _fp)(istream&,T); \
};  \
class OMANIP(T) { \
public: \
    OMANIP(T)(ostream& (*f)(ostream&,T), T t) { _fp = f; _tp = t; } \
    friend ostream& operator<<(ostream& s, OMANIP(T) & sm) { (*sm._fp)(s,sm._tp); return s; } \
private:    \
    ostream& (* _fp)(ostream&,T); \
    T _tp; \
};  \
class OAPP(T) { \
public: \
    OAPP(T)(ostream& (*f)(ostream&,T)) { _fp = f; } \
    OMANIP(T) operator()(T t) { return OMANIP(T)(_fp,t); } \
private:    \
    ostream& (* _fp)(ostream&,T); \
};  \
\
class IOMANIP(T) { \
public: \
    IOMANIP(T)(iostream& (*f)(iostream&,T), T t) { _fp = f; _tp = t; } \
    friend istream& operator>>(iostream& s, IOMANIP(T) & sm) { (*sm._fp)(s,sm._tp); return s; } \
    friend ostream& operator<<(iostream& s, IOMANIP(T) & sm) { (*sm._fp)(s,sm._tp); return s; } \
private:    \
    iostream& (* _fp)(iostream&,T); \
    T _tp; \
};  \
class IOAPP(T) {    \
public: \
    IOAPP(T)( iostream& (*f)(iostream&,T)) { _fp = f; } \
    IOMANIP(T) operator()(T t) { return IOMANIP(T)(_fp,t); }    \
private:    \
    iostream& (* _fp)(iostream&,T); \
}; \


IOMANIPdeclare(int)

IOMANIPdeclare(long)

inline ios& __resetiosflags(ios& s, long _flg) { s.setf(0,_flg); return s; }
inline ios& __setfill(ios& s, int _fc) { s.fill((char)_fc); return s; }
inline ios& __setiosflags(ios& s, long _flg) { s.setf(_flg); return s; }
inline ios& __setprecision(ios& s, int _pre) { s.precision(_pre); return s; }
inline ios& __setw(ios& s, int _wid) { s.width(_wid); return s; }

inline SMANIP(long) resetiosflags(long _l) { return SMANIP(long)(__resetiosflags, _l); }
inline SMANIP(int)  setfill(int _m) {return SMANIP(int)(__setfill, _m); }
inline SMANIP(long) setiosflags(long _l) {return SMANIP(long)(__setiosflags, _l); }
inline SMANIP(int)  setprecision(int _p) {return SMANIP(int)(__setprecision, _p); }
inline SMANIP(int)  setw(int _w) { return SMANIP(int)(__setw, _w); }

// Restore default packing
#pragma pack()

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\tools\c816\inc\iostream.h ===
/***
*iostream.h - definitions/declarations for iostream classes
*
*   Copyright (c) 1990-1992, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*   This file defines the classes, values, macros, and functions
*   used by the iostream classes.
*   [AT&T C++]
*
****/

#ifndef _INC_IOSTREAM
#define _INC_IOSTREAM

typedef long streamoff, streampos;

#include <ios.h>        // Define ios.

#include <streamb.h>        // Define streambuf.

#include <istream.h>        // Define istream.

#include <ostream.h>        // Define ostream.

// Force word packing to avoid possible -Zp override
#pragma pack(2)

#pragma warning(disable:4505)       // disable unwanted /W4 warning
// #pragma warning(default:4505)    // use this to reenable, if necessary

class iostream : public istream, public ostream {
public:
    iostream(streambuf*);
    virtual ~iostream();
protected:
// consider: make private??
    iostream();
    iostream(const iostream&);
inline iostream& operator=(streambuf*);
inline iostream& operator=(iostream&);
private:
    iostream(ios&);
    iostream(istream&);
    iostream(ostream&);
};

inline iostream& iostream::operator=(streambuf* _sb) { istream::operator=(_sb); ostream::operator=(_sb); return *this; }

inline iostream& iostream::operator=(iostream& _strm) { return operator=(_strm.rdbuf()); }

class Iostream_init {
public:
    Iostream_init();
    Iostream_init(ios &, int =0);   // treat as private
    ~Iostream_init();
};

// used internally
// static Iostream_init __iostreaminit; // initializes cin/cout/cerr/clog

// Restore default packing
#pragma pack()

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\tools\c816\inc\istream.h ===
/***
*istream.h - definitions/declarations for the istream class
*
*   Copyright (c) 1990-1992, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*   This file defines the classes, values, macros, and functions
*   used by the istream class.
*   [AT&T C++]
*
****/

#ifndef _INC_ISTREAM
#define _INC_ISTREAM

#include <ios.h>

// Force word packing to avoid possible -Zp override
#pragma pack(2)

#pragma warning(disable:4505)       // disable unwanted /W4 warning
// #pragma warning(default:4505)    // use this to reenable, if necessary


#ifdef M_I86HM
#define _HFAR_ __far
#else 
#define _HFAR_
#endif 

typedef long streamoff, streampos;

class istream : virtual public ios {

public:
    istream(streambuf*);
    virtual ~istream();

    int  ipfx(int =0);
    void isfx() { }

    inline istream& operator>>(istream& (*_f)(istream&));
    inline istream& operator>>(ios& (*_f)(ios&));
    istream& operator>>(char _HFAR_ *);
    inline istream& operator>>(unsigned char _HFAR_ *);
    inline istream& operator>>(signed char _HFAR_ *);
    istream& operator>>(char _HFAR_ &);
    inline istream& operator>>(unsigned char _HFAR_ &);
    inline istream& operator>>(signed char _HFAR_ &);
    istream& operator>>(short _HFAR_ &);
    istream& operator>>(unsigned short _HFAR_ &);
    istream& operator>>(int _HFAR_ &);
    istream& operator>>(unsigned int _HFAR_ &);
    istream& operator>>(long _HFAR_ &);
    istream& operator>>(unsigned long _HFAR_ &);
    istream& operator>>(float _HFAR_ &);
    istream& operator>>(double _HFAR_ &);
    istream& operator>>(long double _HFAR_ &);
    istream& operator>>(streambuf*);

    int get();
    istream& get(char _HFAR_ *,int,char ='\n');
    inline istream& get(unsigned char _HFAR_ *,int,char ='\n');
    inline istream& get(signed char _HFAR_ *,int,char ='\n');
    istream& get(char _HFAR_ &);
    inline istream& get(unsigned char _HFAR_ &);
    inline istream& get(signed char _HFAR_ &);
    istream& get(streambuf&,char ='\n');
    inline istream& getline(char _HFAR_ *,int,char ='\n');
    inline istream& getline(unsigned char _HFAR_ *,int,char ='\n');
    inline istream& getline(signed char _HFAR_ *,int,char ='\n');

    inline istream& ignore(int =1,int =EOF);
    istream& read(char _HFAR_ *,int);
    inline istream& read(unsigned char _HFAR_ *,int);
    inline istream& read(signed char _HFAR_ *,int);

    int gcount() const { return x_gcount; }
    int peek();
    istream& putback(char);
    int sync();

    istream& seekg(streampos);
    istream& seekg(streamoff,ios::seek_dir);
    streampos tellg();

    void eatwhite();    // consider: protect and friend with manipulator ws
protected:
    istream();
    istream(const istream&);    // treat as private
    istream& operator=(streambuf* _isb); // treat as private
    istream& operator=(const istream& _is) { return operator=(_is.rdbuf()); }
    int do_ipfx(int);

private:
    istream(ios&);
    int getint(char _HFAR_ *);
    int getdouble(char _HFAR_ *, int);
    int _fGline;
    int x_gcount;
};

    inline istream& istream::operator>>(istream& (*_f)(istream&)) { (*_f)(*this); return *this; }
    inline istream& istream::operator>>(ios& (*_f)(ios&)) { (*_f)(*this); return *this; }

    inline istream& istream::operator>>(unsigned char _HFAR_ * _s) { return operator>>((char _HFAR_ *)_s); }
    inline istream& istream::operator>>(signed char _HFAR_ * _s) { return operator>>((char _HFAR_ *)_s); }

    inline istream& istream::operator>>(unsigned char _HFAR_ & _c) { return operator>>((char _HFAR_ &) _c); }
    inline istream& istream::operator>>(signed char _HFAR_ & _c) { return operator>>((char _HFAR_ &) _c); }

    inline istream& istream::get(unsigned char _HFAR_ * b, int lim ,char delim) { return get((char _HFAR_ *)b, lim, delim); }
    inline istream& istream::get(signed char _HFAR_ * b, int lim, char delim) { return get((char _HFAR_ *)b, lim, delim); }

    inline istream& istream::get(unsigned char _HFAR_ & _c) { return get((char _HFAR_ &)_c); }
    inline istream& istream::get(signed char _HFAR_ & _c) { return get((char _HFAR_ &)_c); }

    inline istream& istream::getline(char _HFAR_ * _b,int _lim,char _delim) { _fGline++; return get(_b, _lim, _delim); }
    inline istream& istream::getline(unsigned char _HFAR_ * _b,int _lim,char _delim) { _fGline++; return get((char _HFAR_ *)_b, _lim, _delim); }
    inline istream& istream::getline(signed char _HFAR_ * _b,int _lim,char _delim) { _fGline++; return get((char _HFAR_ *)_b, _lim, _delim); }

    inline istream& istream::ignore(int _n,int delim) { _fGline++; return get((char _HFAR_ *)0, _n+1, (char)delim); }

    inline istream& istream::read(unsigned char _HFAR_ * _ptr, int _n) { return read((char _HFAR_ *) _ptr, _n); }
    inline istream& istream::read(signed char _HFAR_ * _ptr, int _n) { return read((char _HFAR_ *) _ptr, _n); }

class istream_withassign : public istream {
    public:
        istream_withassign();
        istream_withassign(streambuf*);
        ~istream_withassign();
    istream& operator=(const istream& _is) { return istream::operator=(_is); }
    istream& operator=(streambuf* _isb) { return istream::operator=(_isb); }
};

#ifndef _WINDLL
extern istream_withassign cin;
#endif 

inline istream& ws(istream& _ins) { _ins.eatwhite(); return _ins; }

ios&        dec(ios&);
ios&        hex(ios&);
ios&        oct(ios&);

// Restore default packing
#pragma pack()

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\tools\c816\inc\limits.h ===
/***
*limits.h - implementation dependent values
*
*   Copyright (c) 1985-1992, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*   Contains defines for a number of implementation dependent values
*   which are commonly used in C programs.
*   [ANSI]
*
****/

#ifndef _INC_LIMITS

#define CHAR_BIT      8     /* number of bits in a char */
#define SCHAR_MIN   (-127)      /* minimum signed char value */
#define SCHAR_MAX     127       /* maximum signed char value */
#define UCHAR_MAX     0xff      /* maximum unsigned char value */
#ifndef _CHAR_UNSIGNED
#define CHAR_MIN    SCHAR_MIN   /* mimimum char value */
#define CHAR_MAX    SCHAR_MAX   /* maximum char value */
#else 
#define CHAR_MIN      0
#define CHAR_MAX    UCHAR_MAX
#ifndef __cplusplus
unsigned int _charmax;          /* unsigned CHAR_MAX value */
#else 
extern "C" unsigned int _charmax;   /* unsigned CHAR_MAX value */
static unsigned int *_char_max = &_charmax;
#endif 
#endif 
#define MB_LEN_MAX    2     /* max. # bytes in multibyte char */
#define SHRT_MIN    (-32767)    /* minimum (signed) short value */
#define SHRT_MAX      32767     /* maximum (signed) short value */
#define USHRT_MAX     0xffff    /* maximum unsigned short value */
#define INT_MIN     (-32767)    /* minimum (signed) int value */
#define INT_MAX       32767     /* maximum (signed) int value */
#define UINT_MAX      0xffff    /* maximum unsigned int value */
#define LONG_MIN    (-2147483647)   /* minimum (signed) long value */
#define LONG_MAX      2147483647    /* maximum (signed) long value */
#define ULONG_MAX     0xffffffff    /* maximum unsigned long value */

#define _INC_LIMITS
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\tools\c816\inc\ios.h ===
/***
*ios.h - definitions/declarations for the ios class.
*
*   Copyright (c) 1990-1992, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*   This file defines the classes, values, macros, and functions
*   used by the ios class.
*   [AT&T C++]
*
****/

#ifndef _INC_IOS
#define _INC_IOS


#ifdef M_I86HM
#define _HFAR_ __far
#else 
#define _HFAR_
#endif 

#ifndef NULL
#define NULL    0
#endif 

#ifndef EOF
#define EOF (-1)
#endif 

// Force word packing to avoid possible -Zp override
#pragma pack(2)

#pragma warning(disable:4505)       // disable unwanted /W4 warning
// #pragma warning(default:4505)    // use this to reenable, if necessary

class streambuf;
class ostream;

class ios {

public:
    enum io_state {  goodbit = 0x00,
             eofbit  = 0x01,
             failbit = 0x02,
             badbit  = 0x04 };

    enum open_mode { in        = 0x01,
             out       = 0x02,
             ate       = 0x04,
             app       = 0x08,
             trunc     = 0x10,
             nocreate  = 0x20,
             noreplace = 0x40,
             binary    = 0x80 };    // CONSIDER: not in latest spec.

    enum seek_dir { beg=0, cur=1, end=2 };

    enum {  skipws     = 0x0001,
        left       = 0x0002,
        right      = 0x0004,
        internal   = 0x0008,
        dec        = 0x0010,
        oct        = 0x0020,
        hex        = 0x0040,
        showbase   = 0x0080,
        showpoint  = 0x0100,
        uppercase  = 0x0200,
        showpos    = 0x0400,
        scientific = 0x0800,
        fixed      = 0x1000,
        unitbuf    = 0x2000,
        stdio      = 0x4000
                 };

    static const long basefield;    // dec | oct | hex
    static const long adjustfield;  // left | right | internal
    static const long floatfield;   // scientific | fixed

    ios(streambuf*);            // differs from ANSI
    virtual ~ios();

    inline long flags() const;
    inline long flags(long _l);

    inline long setf(long _f,long _m);
    inline long setf(long _l);
    inline long unsetf(long _l);

    inline int width() const;
    inline int width(int _i);

    inline ostream* tie(ostream* _os);
    inline ostream* tie() const;

    inline char fill() const;
    inline char fill(char _c);

    inline int precision(int _i);
    inline int precision() const;

    inline int rdstate() const;
    inline void clear(int _i = 0);

//  inline operator void*() const;
    operator void *() const { if(state&(badbit|failbit) ) return 0; return (void *)this; }
    inline int operator!() const;

    inline int  good() const;
    inline int  eof() const;
    inline int  fail() const;
    inline int  bad() const;

    inline streambuf* rdbuf() const;

    inline long _HFAR_ & iword(int) const;
    inline void _HFAR_ * _HFAR_ & pword(int) const;

    static long bitalloc();
    static int xalloc();
    static void sync_with_stdio();

protected:
    ios();
    ios(const ios&);            // treat as private
    ios& operator=(const ios&);
    void init(streambuf*);

    enum { skipping, tied };
    streambuf*  bp;

    int     state;
    int     ispecial;           // not used
    int     ospecial;           // not used
    int     isfx_special;       // not used
    int     osfx_special;       // not used
    int     x_delbuf;           // if set, rdbuf() deleted by ~ios

    ostream* x_tie;
    long    x_flags;
    int     x_precision;
    int     x_width;
    char    x_fill;

    static void (*stdioflush)();    // not used
public:
    int delbuf() const { return x_delbuf; }
    void    delbuf(int _i) { x_delbuf = _i; }

private:
    static long x_maxbit;
    static long _HFAR_ * x_statebuf;  // used by xalloc()
    static int x_curindex;
// consider: make interal static to ios::sync_with_stdio()
    static int sunk_with_stdio;     // make sure sync_with done only once
};

inline ios& dec(ios& _strm) { _strm.setf(ios::dec,ios::basefield); return _strm; }
inline ios& hex(ios& _strm) { _strm.setf(ios::hex,ios::basefield); return _strm; }
inline ios& oct(ios& _strm) { _strm.setf(ios::oct,ios::basefield); return _strm; }

inline long ios::flags() const { return x_flags; }
inline long ios::flags(long _l){ long _lO; _lO = x_flags; x_flags = _l; return _lO; }

inline long ios::setf(long _l,long _m){ long _lO; _lO = x_flags; x_flags = (_l&_m) | (x_flags&(~_m)); return _lO; }
inline long ios::setf(long _l){ long _lO; _lO = x_flags; x_flags |= _l; return _lO; }
inline long ios::unsetf(long _l){ long _lO; _lO = x_flags; x_flags &= (~_l); return _lO; }

inline int ios::width() const { return x_width; }
inline int ios::width(int _i){ int _iO; _iO = (int)x_width; x_width = _i; return _iO; }

inline ostream* ios::tie(ostream* _os){ ostream* _osO; _osO = x_tie; x_tie = _os; return _osO; }
inline ostream* ios::tie() const { return x_tie; }
inline char ios::fill() const { return x_fill; }
inline char ios::fill(char _c){ char _cO; _cO = x_fill; x_fill = _c; return _cO; }
inline int ios::precision(int _i){ int _iO; _iO = (int)x_precision; x_precision = _i; return _iO; }
inline int ios::precision() const { return x_precision; }

inline int ios::rdstate() const { return state; }

// inline ios::operator void *() const { if(state&(badbit|failbit) ) return 0; return (void *)this; }
inline int ios::operator!() const { return state&(badbit|failbit); }

inline int  ios::bad() const { return state & badbit; }
inline void ios::clear(int _i){ state = _i; }
inline int  ios::eof() const { return state & eofbit; }
inline int  ios::fail() const { return state & (badbit | failbit); }
inline int  ios::good() const { return state == 0; }

inline streambuf* ios::rdbuf() const { return bp; }

inline long _HFAR_ & ios::iword(int _i) const { return x_statebuf[_i] ; }
inline void _HFAR_ * _HFAR_ & ios::pword(int _i) const { return (void _HFAR_ * _HFAR_ &)x_statebuf[_i]; }

// Restore default packing
#pragma pack()

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\tools\c816\inc\fstream.h ===
/***
*fstream.h - definitions/declarations for filebuf and fstream classes
*
*   Copyright (c) 1991-1992, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*   This file defines the classes, values, macros, and functions
*   used by the filebuf and fstream classes.
*   [AT&T C++]
*
****/

#ifndef _INC_FSTREAM
#define _INC_FSTREAM

#include <iostream.h>

// Force word packing to avoid possible -Zp override
#pragma pack(2)

#pragma warning(disable:4505)       // disable unwanted /W4 warning
// #pragma warning(default:4505)    // use this to reenable, if necessary

#ifdef M_I86HM
#define _HFAR_ __far
#else 
#define _HFAR_
#endif 

typedef int filedesc;

class filebuf : public streambuf {
public:
static  const int   openprot;   // default share/prot mode for open

// optional share values for 3rd argument (prot) of open or constructor
static  const int   sh_compat;  // compatibility share mode
static  const int   sh_none;    // exclusive mode no sharing
static  const int   sh_read;    // allow read sharing
static  const int   sh_write;   // allow write sharing
// use (sh_read | sh_write) to allow both read and write sharing

// options for setmode member function
static  const int   binary;
static  const int   text;

            filebuf();
            filebuf(filedesc);
            filebuf(filedesc, char _HFAR_ *, int);
            ~filebuf();

    filebuf*    attach(filedesc);
    filedesc    fd() const { return (x_fd==-1) ? EOF : x_fd; }
    int     is_open() const { return (x_fd!=-1); }
    filebuf*    open(const char _HFAR_ *, int, int = filebuf::openprot);
    filebuf*    close();
    int     setmode(int = filebuf::text);

virtual int     overflow(int=EOF);
virtual int     underflow();

virtual streambuf*  setbuf(char _HFAR_ *, int);
virtual streampos   seekoff(streamoff, ios::seek_dir, int);
// virtual  streampos   seekpos(streampos, int);
virtual int     sync();

private:
    filedesc    x_fd;
    int     x_fOpened;
};

class ifstream : public istream {
public:
    ifstream();
    ifstream(const char _HFAR_ *, int =ios::in, int = filebuf::openprot);
    ifstream(filedesc);
    ifstream(filedesc, char _HFAR_ *, int);
    ~ifstream();

    streambuf * setbuf(char _HFAR_ *, int);
    filebuf* rdbuf() const { return (filebuf*) ios::rdbuf(); }

    void attach(filedesc);
    filedesc fd() const { return rdbuf()->fd(); }

    int is_open() const { return rdbuf()->is_open(); }
    void open(const char _HFAR_ *, int =ios::in, int = filebuf::openprot);
    void close();
    int setmode(int mode = filebuf::text) { return rdbuf()->setmode(mode); }
};

class ofstream : public ostream {
public:
    ofstream();
    ofstream(const char _HFAR_ *, int =ios::out, int = filebuf::openprot);
    ofstream(filedesc);
    ofstream(filedesc, char _HFAR_ *, int);
    ~ofstream();

    streambuf * setbuf(char _HFAR_ *, int);
    filebuf* rdbuf() const { return (filebuf*) ios::rdbuf(); }

    void attach(filedesc);
    filedesc fd() const { return rdbuf()->fd(); }

    int is_open() const { return rdbuf()->is_open(); }
    void open(const char _HFAR_ *, int =ios::out, int = filebuf::openprot);
    void close();
    int setmode(int mode = filebuf::text) { return rdbuf()->setmode(mode); }
};

class fstream : public iostream {
public:
    fstream();
    fstream(const char _HFAR_ *, int, int = filebuf::openprot);
    fstream(filedesc);
    fstream(filedesc, char _HFAR_ *, int);
    ~fstream();

    streambuf * setbuf(char _HFAR_ *, int);
    filebuf* rdbuf() const { return (filebuf*) ostream::rdbuf(); }

    void attach(filedesc);
    filedesc fd() const { return rdbuf()->fd(); }

    int is_open() const { return rdbuf()->is_open(); }
    void open(const char _HFAR_ *, int, int = filebuf::openprot);
    void close();
    int setmode(int mode = filebuf::text) { return rdbuf()->setmode(mode); }
};

// manipulators to dynamically change file access mode (filebufs only)
inline  ios& binary(ios& _fstrm) \
   { ((filebuf*)_fstrm.rdbuf())->setmode(filebuf::binary); return _fstrm; }
inline  ios& text(ios& _fstrm) \
   { ((filebuf*)_fstrm.rdbuf())->setmode(filebuf::text); return _fstrm; }

// Restore default packing
#pragma pack()

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\tools\c816\inc\io.h ===
/***
*io.h - declarations for low-level file handling and I/O functions
*
*   Copyright (c) 1985-1992, Microsoft Corporation. All rights reserved.
*
*Purpose:
*   This file contains the function declarations for the low-level
*   file handling and I/O functions.
*
****/

#ifndef _INC_IO

#ifdef __cplusplus
extern "C" {
#endif 

#if (_MSC_VER <= 600)
#define __cdecl     _cdecl
#define __far       _far
#endif 

#ifdef _WINDOWS
#ifndef _WINDLL
#ifndef _WINFO_DEFINED
/* interface version number */
#define _QWINVER    0

/* max number of windows */
#define _WFILE      20

/* values for windows screen buffer size */
#define _WINBUFINF  0
#define _WINBUFDEF  -1

/* size/move settings */
#define _WINSIZEMIN 1
#define _WINSIZEMAX 2
#define _WINSIZERESTORE 3
#define _WINSIZECHAR    4

/* size/move query types */
#define _WINMAXREQ  100
#define _WINCURRREQ 101

/* values for closing window */
#define _WINPERSIST 1
#define _WINNOPERSIST   0

/* pseudo file handle for frame window */
#define _WINFRAMEHAND   -1

/* menu items */
#define _WINSTATBAR 1
#define _WINTILE    2
#define _WINCASCADE 3
#define _WINARRANGE 4

/* quickwin exit options */
#define _WINEXITPROMPT      1
#define _WINEXITNOPERSIST   2
#define _WINEXITPERSIST     3

/* open structure */
#pragma pack(2)
struct _wopeninfo {
    unsigned int _version;
    const char __far * _title;
    long _wbufsize;
    };
#pragma pack()

/* size/move structure */
struct _wsizeinfo {
    unsigned int _version;
    unsigned int _type;
    unsigned int _x;
    unsigned int _y;
    unsigned int _h;
    unsigned int _w;
    };

#define _WINFO_DEFINED
#endif 
#endif 
#endif 

/* function prototypes */

int __cdecl _access(const char *, int);
int __cdecl _chmod(const char *, int);
int __cdecl _chsize(int, long);
int __cdecl _close(int);
int __cdecl _commit(int);
int __cdecl _creat(const char *, int);
int __cdecl _dup(int);
int __cdecl _dup2(int, int);
int __cdecl _eof(int);
long __cdecl _filelength(int);
int __cdecl _isatty(int);
int __cdecl _locking(int, int, long);
long __cdecl _lseek(int, long, int);
char * __cdecl _mktemp(char *);
int __cdecl _open(const char *, int, ...);
int __cdecl _read(int, void *, unsigned int);
int __cdecl remove(const char *);
int __cdecl rename(const char *, const char *);
int __cdecl _setmode(int, int);
int __cdecl _sopen(const char *, int, int, ...);
long __cdecl _tell(int);
int __cdecl _umask(int);
int __cdecl _unlink(const char *);
int __cdecl _write(int, const void *, unsigned int);
#ifdef _WINDOWS
#ifndef _WINDLL
int __cdecl _wabout(char *);
int __cdecl _wclose(int, int);
int __cdecl _wgetexit(void);
int __cdecl _wgetfocus(void);
long __cdecl _wgetscreenbuf(int);
int __cdecl _wgetsize(int, int, struct _wsizeinfo *);
int __cdecl _wmenuclick(int);
int __cdecl _wopen(struct _wopeninfo *, struct _wsizeinfo *, int);
int __cdecl _wsetexit(int);
int __cdecl _wsetfocus(int);
int __cdecl _wsetscreenbuf(int, long);
int __cdecl _wsetsize(int, struct _wsizeinfo *);
void __cdecl _wyield(void);
#endif 
#endif 

#ifndef __STDC__
/* Non-ANSI names for compatibility */
int __cdecl access(const char *, int);
int __cdecl chmod(const char *, int);
int __cdecl chsize(int, long);
int __cdecl close(int);
int __cdecl creat(const char *, int);
int __cdecl dup(int);
int __cdecl dup2(int, int);
int __cdecl eof(int);
long __cdecl filelength(int);
int __cdecl isatty(int);
int __cdecl locking(int, int, long);
long __cdecl lseek(int, long, int);
char * __cdecl mktemp(char *);
int __cdecl open(const char *, int, ...);
int __cdecl read(int, void *, unsigned int);
int __cdecl setmode(int, int);
int __cdecl sopen(const char *, int, int, ...);
long __cdecl tell(int);
int __cdecl umask(int);
int __cdecl unlink(const char *);
int __cdecl write(int, const void *, unsigned int);
#endif 

#ifdef __cplusplus
}
#endif 

#define _INC_IO
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\tools\c816\inc\lzdos.h ===
/* OBSOLETE: Replaced by #define LIB/#include <lzexpand.h> */
#ifndef LIB
#define LIB
#endif
#include <lzexpand.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\tools\c816\inc\locale.h ===
/***
*locale.h - definitions/declarations for localization routines
*
*   Copyright (c) 1988-1992, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*   This file defines the structures, values, macros, and functions
*   used by the localization routines.
*   [ANSI]
*
****/

#ifndef _INC_LOCALE

#ifdef __cplusplus
extern "C" {
#endif 

#if (_MSC_VER <= 600)
#define __cdecl     _cdecl
#define __far       _far
#endif 

/* define NULL pointer value */

#ifndef NULL
#ifdef __cplusplus
#define NULL    0
#else 
#define NULL    ((void *)0)
#endif 
#endif 


/* Locale categories */

#define LC_ALL      0
#define LC_COLLATE  1
#define LC_CTYPE    2
#define LC_MONETARY 3
#define LC_NUMERIC  4
#define LC_TIME     5

#define LC_MIN      LC_ALL
#define LC_MAX      LC_TIME


/* Locale convention structure */

#ifndef _LCONV_DEFINED
struct lconv {
    char *decimal_point;
    char *thousands_sep;
    char *grouping;
    char *int_curr_symbol;
    char *currency_symbol;
    char *mon_decimal_point;
    char *mon_thousands_sep;
    char *mon_grouping;
    char *positive_sign;
    char *negative_sign;
    char int_frac_digits;
    char frac_digits;
    char p_cs_precedes;
    char p_sep_by_space;
    char n_cs_precedes;
    char n_sep_by_space;
    char p_sign_posn;
    char n_sign_posn;
    };
#define _LCONV_DEFINED
#endif 

/* function prototypes */

char * __cdecl setlocale(int, const char *);
struct lconv * __cdecl localeconv(void);

#ifdef __cplusplus
}
#endif 

#define _INC_LOCALE
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\tools\c816\inc\malloc.h ===
/***
*malloc.h - declarations and definitions for memory allocation functions
*
*   Copyright (c) 1985-1992, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*   Contains the function declarations for memory allocation functions;
*   also defines manifest constants and types used by the heap routines.
*   [System V]
*
****/

#ifndef _INC_MALLOC

#ifdef __cplusplus
extern "C" {
#endif 

#if (_MSC_VER <= 600)
#define __based     _based
#define __cdecl     _cdecl
#define __far       _far
#define __huge      _huge
#define __near      _near
#define __segment   _segment
#endif 

/* constants for based heap routines */

#define _NULLSEG    ((__segment)0)
#define _NULLOFF    ((void __based(void) *)0xffff)

/* constants for _heapchk/_heapset/_heapwalk routines */

#define _HEAPEMPTY  (-1)
#define _HEAPOK     (-2)
#define _HEAPBADBEGIN   (-3)
#define _HEAPBADNODE    (-4)
#define _HEAPEND    (-5)
#define _HEAPBADPTR (-6)
#define _FREEENTRY  0
#define _USEDENTRY  1

/* maximum heap request that can ever be honored */

#ifdef _WINDOWS
#define _HEAP_MAXREQ    0xFFE6
#else 
#define _HEAP_MAXREQ    0xFFE8
#endif 

/* types and structures */

#ifndef _SIZE_T_DEFINED
typedef unsigned int size_t;
#define _SIZE_T_DEFINED
#endif 

#ifndef _HEAPINFO_DEFINED
typedef struct _heapinfo {
    int __far * _pentry;
    size_t _size;
    int _useflag;
    } _HEAPINFO;
#define _HEAPINFO_DEFINED
#endif 


/* external variable declarations */

extern unsigned int __near __cdecl _amblksiz;


/* based heap function prototypes */

void __based(void) * __cdecl _bcalloc(__segment, size_t, size_t);
void __based(void) * __cdecl _bexpand(__segment,
    void __based(void) *, size_t);
void __cdecl _bfree(__segment, void __based(void) *);
int __cdecl _bfreeseg(__segment);
int __cdecl _bheapadd(__segment, void __based(void) *, size_t);
int __cdecl _bheapchk(__segment);
int __cdecl _bheapmin(__segment);
__segment __cdecl _bheapseg(size_t);
int __cdecl _bheapset(__segment, unsigned int);
int __cdecl _bheapwalk(__segment, _HEAPINFO *);
void __based(void) * __cdecl _bmalloc(__segment, size_t);
size_t __cdecl _bmsize(__segment, void __based(void) *);
void __based(void) * __cdecl _brealloc(__segment,
    void __based(void) *, size_t);


/* function prototypes */

void * __cdecl _alloca(size_t);
void * __cdecl calloc(size_t, size_t);
void * __cdecl _expand(void *, size_t);
void __far * __cdecl _fcalloc(size_t, size_t);
void __far * __cdecl _fexpand(void __far *, size_t);
void __cdecl _ffree(void __far *);
int __cdecl _fheapchk(void);
int __cdecl _fheapmin(void);
int __cdecl _fheapset(unsigned int);
int __cdecl _fheapwalk(_HEAPINFO *);
void __far * __cdecl _fmalloc(size_t);
size_t __cdecl _fmsize(void __far *);
void __far * __cdecl _frealloc(void __far *, size_t);
unsigned int __cdecl _freect(size_t);
void __cdecl free(void *);
void __huge * __cdecl _halloc(long, size_t);
void __cdecl _hfree(void __huge *);
#ifndef _WINDOWS
int __cdecl _heapadd(void __far *, size_t);
int __cdecl _heapchk(void);
#endif 
int __cdecl _heapmin(void);
#ifndef _WINDOWS
int __cdecl _heapset(unsigned int);
int __cdecl _heapwalk(_HEAPINFO *);
#endif 
void * __cdecl malloc(size_t);
size_t __cdecl _memavl(void);
size_t __cdecl _memmax(void);
size_t __cdecl _msize(void *);
void __near * __cdecl _ncalloc(size_t, size_t);
void __near * __cdecl _nexpand(void __near *, size_t);
void __cdecl _nfree(void __near *);
#ifndef _WINDOWS
int __cdecl _nheapchk(void);
#endif 
int __cdecl _nheapmin(void);
#ifndef _WINDOWS
int __cdecl _nheapset(unsigned int);
int __cdecl _nheapwalk(_HEAPINFO *);
#endif 
void __near * __cdecl _nmalloc(size_t);
size_t __cdecl _nmsize(void __near *);
void __near * __cdecl _nrealloc(void __near *, size_t);
void * __cdecl realloc(void *, size_t);
size_t __cdecl _stackavail(void);

#ifndef __STDC__
/* Non-ANSI names for compatibility */
void * __cdecl alloca(size_t);
void __huge * __cdecl halloc(long, size_t);
void __cdecl hfree(void __huge *);
size_t __cdecl stackavail(void);
#endif 

#ifdef __cplusplus
}
#endif 

#define _INC_MALLOC
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\tools\c816\inc\new.h ===
/***
*new.h - declarations and definitions for C++ memory allocation functions
*
*   Copyright (c) 1990-1992, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*   Contains the function declarations for C++ memory allocation functions.
*
****/

#ifndef _INC_NEW

#ifdef __cplusplus


/* constants for based heap routines */

#define _NULLSEG    ((__segment)0)
#define _NULLOFF    ((void __based(void) *)0xffff)

/* types and structures */

#ifndef _SIZE_T_DEFINED
typedef unsigned int size_t;
#define _SIZE_T_DEFINED
#endif 

typedef int (__cdecl * _PNH)( size_t );
typedef int (__cdecl * _PNHH)( unsigned long, size_t );
typedef int (__cdecl * _PNHB)( __segment, size_t );

/* function prototypes */

_PNH __cdecl _set_new_handler( _PNH );
_PNH __cdecl _set_nnew_handler( _PNH );
_PNH __cdecl _set_fnew_handler( _PNH );
_PNHH __cdecl _set_hnew_handler( _PNHH );
_PNHB __cdecl _set_bnew_handler( _PNHB );

#else 

/* handler functions only supported in C++, emit appropriate error */
#error Functions declared in new.h can only be used in C++ source

#endif 

#define _INC_NEW
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\tools\c816\inc\memory.h ===
/***
*memory.h - declarations for buffer (memory) manipulation routines
*
*   Copyright (c) 1985-1992, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*   This include file contains the function declarations for the
*   buffer (memory) manipulation routines.
*   [System V]
*
****/

#ifndef _INC_MEMORY

#ifdef __cplusplus
extern "C" {
#endif 

#if (_MSC_VER <= 600)
#define __cdecl     _cdecl
#define __far       _far
#endif 

#ifndef _SIZE_T_DEFINED
typedef unsigned int size_t;
#define _SIZE_T_DEFINED
#endif 


/* function prototypes */

void * __cdecl _memccpy(void *, const void *,
    int, unsigned int);
void * __cdecl memchr(const void *, int, size_t);
int __cdecl memcmp(const void *, const void *,
    size_t);
void * __cdecl memcpy(void *, const void *,
    size_t);
int __cdecl _memicmp(const void *, const void *,
    unsigned int);
void * __cdecl memset(void *, int, size_t);
void __cdecl _movedata(unsigned int, unsigned int, unsigned int,
    unsigned int, unsigned int);


/* model independent function prototypes */

void __far * __far __cdecl _fmemccpy(void __far *, const void __far *,
    int, unsigned int);
void __far * __far __cdecl _fmemchr(const void __far *, int, size_t);
int __far __cdecl _fmemcmp(const void __far *, const void __far *,
    size_t);
void __far * __far __cdecl _fmemcpy(void __far *, const void __far *,
    size_t);
int __far __cdecl _fmemicmp(const void __far *, const void __far *,
    unsigned int);
void __far * __far __cdecl _fmemset(void __far *, int, size_t);


#ifndef __STDC__
/* Non-ANSI names for compatibility */
void * __cdecl memccpy(void *, const void *,
    int, unsigned int);
int __cdecl memicmp(const void *, const void *,
    unsigned int);
void __cdecl movedata(unsigned int, unsigned int, unsigned int,
    unsigned int, unsigned int);
#endif 

#ifdef __cplusplus
}
#endif 

#define _INC_MEMORY
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\tools\c816\inc\ostream.h ===
/***
*ostream.h - definitions/declarations for the ostream class
*
*   Copyright (c) 1991-1992, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*   This file defines the classes, values, macros, and functions
*   used by the ostream class.
*   [AT&T C++]
*
****/

#ifndef _INC_OSTREAM
#define _INC_OSTREAM

#include <ios.h>

// Force word packing to avoid possible -Zp override
#pragma pack(2)

#pragma warning(disable:4505)       // disable unwanted /W4 warning
// #pragma warning(default:4505)    // use this to reenable, if necessary

#ifdef M_I86HM
#define _HFAR_ __far
#else 
#define _HFAR_
#endif 

typedef long streamoff, streampos;

class ostream : virtual public ios {

public:
    ostream(streambuf*);
    virtual ~ostream();

    ostream& flush();
    int  opfx();
    void osfx();

inline  ostream& operator<<(ostream& (*f)(ostream&));
inline  ostream& operator<<(ios& (*f)(ios&));
    ostream& operator<<(const char _HFAR_ *);
inline  ostream& operator<<(const unsigned char _HFAR_ *);
inline  ostream& operator<<(const signed char _HFAR_ *);
inline  ostream& operator<<(char);
    ostream& operator<<(unsigned char);
inline  ostream& operator<<(signed char);
    ostream& operator<<(short);
    ostream& operator<<(unsigned short);
    ostream& operator<<(int);
    ostream& operator<<(unsigned int);
    ostream& operator<<(long);
    ostream& operator<<(unsigned long);
inline  ostream& operator<<(float);
    ostream& operator<<(double);
    ostream& operator<<(long double);
    ostream& operator<<(const void _HFAR_ *);
    ostream& operator<<(streambuf*);
inline  ostream& put(char);
    ostream& put(unsigned char);
inline  ostream& put(signed char);
    ostream& write(const char _HFAR_ *,int);
inline  ostream& write(const unsigned char _HFAR_ *,int);
inline  ostream& write(const signed char _HFAR_ *,int);
    ostream& seekp(streampos);
    ostream& seekp(streamoff,ios::seek_dir);
    streampos tellp();

protected:
    ostream();
    ostream(const ostream&);    // treat as private
    ostream& operator=(streambuf*); // treat as private
    ostream& operator=(const ostream& _os) {return operator=(_os.rdbuf()); }
    int do_opfx(int);       // not used
    void do_osfx();         // not used

private:
    ostream(ios&);
    ostream& writepad(const char _HFAR_ *, const char _HFAR_ *);
    int x_floatused;
};

inline ostream& ostream::operator<<(ostream& (*f)(ostream&)) { (*f)(*this); return *this; }
inline ostream& ostream::operator<<(ios& (*f)(ios& )) { (*f)(*this); return *this; }

inline  ostream& ostream::operator<<(char c) { return operator<<((unsigned char) c); }
inline  ostream& ostream::operator<<(signed char c) { return operator<<((unsigned char) c); }

inline  ostream& ostream::operator<<(const unsigned char _HFAR_ * s) { return operator<<((const char _HFAR_ *) s); }
inline  ostream& ostream::operator<<(const signed char _HFAR_ * s) { return operator<<((const char _HFAR_ *) s); }

inline  ostream& ostream::operator<<(float f) { x_floatused = 1; return operator<<((double) f); }

inline  ostream& ostream::put(char c) { return put((unsigned char) c); }
inline  ostream& ostream::put(signed char c) { return put((unsigned char) c); }

inline  ostream& ostream::write(const unsigned char _HFAR_ * s, int n) { return write((char _HFAR_ *) s, n); }
inline  ostream& ostream::write(const signed char _HFAR_ * s, int n) { return write((char _HFAR_ *) s, n); }


class ostream_withassign : public ostream {
    public:
        ostream_withassign();
        ostream_withassign(streambuf* _is);
        ~ostream_withassign();
    ostream& operator=(const ostream& _os) { return ostream::operator=(_os.rdbuf()); }
    ostream& operator=(streambuf* _sb) { return ostream::operator=(_sb); }
};

#ifndef _WINDLL
extern ostream_withassign cout;
extern ostream_withassign cerr;
extern ostream_withassign clog;
#endif 

inline ostream& flush(ostream& _outs) { return _outs.flush(); }
inline ostream& endl(ostream& _outs) { return _outs << '\n' << flush; }
inline ostream& ends(ostream& _outs) { return _outs << char('\0'); }

ios&        dec(ios&);
ios&        hex(ios&);
ios&        oct(ios&);

// Restore default packing
#pragma pack()

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\tools\c816\inc\math.h ===
/***
*math.h - definitions and declarations for math library
*
*   Copyright (c) 1985-1992, Microsoft Corporation. All rights reserved.
*
*Purpose:
*   This file contains constant definitions and external subroutine
*   declarations for the math subroutine library.
*   [ANSI/System V]
*
****/

#ifndef _INC_MATH

#ifdef __cplusplus
extern "C" {
#endif 

#if (_MSC_VER <= 600)
#define __cdecl     _cdecl
#define __far       _far
#define __near      _near
#define __pascal    _pascal
#endif 

/* definition of _exception struct - this struct is passed to the _matherr
 * routine when a floating point exception is detected
 */

#ifndef _EXCEPTION_DEFINED
#pragma pack(2)

struct _exception {
    int type;       /* exception type - see below */
    char *name;   /* name of function where error occured */
    double arg1;        /* first argument to function */
    double arg2;        /* second argument (if any) to function */
    double retval;      /* value to be returned by function */
    } ;

#ifndef __STDC__
/* Non-ANSI name for compatibility */
#define exception _exception
#endif 

#pragma pack()
#define _EXCEPTION_DEFINED
#endif 


/* definition of a _complex struct to be used by those who use cabs and
 * want type checking on their argument
 */

#ifndef _COMPLEX_DEFINED

struct _complex {
    double x,y; /* real and imaginary parts */
    } ;

#ifndef __cplusplus
#ifndef __STDC__
/* Non-ANSI name for compatibility */
struct complex {
    double x,y; /* real and imaginary parts */
    } ;
#endif 
#endif 

#define _COMPLEX_DEFINED
#endif 


/* Constant definitions for the exception type passed in the _exception struct
 */

#define _DOMAIN     1   /* argument domain error */
#define _SING       2   /* argument singularity */
#define _OVERFLOW   3   /* overflow range error */
#define _UNDERFLOW  4   /* underflow range error */
#define _TLOSS      5   /* total loss of precision */
#define _PLOSS      6   /* partial loss of precision */

#define EDOM        33
#define ERANGE      34


/* definitions of _HUGE (XENIX) and HUGE_VAL (ANSI) error return values used
 * by several floating point math routines
 */

extern double __near __cdecl _HUGE;
#define HUGE_VAL _HUGE


/* function prototypes */

#ifdef _MT
int __cdecl  abs(int);
double  __pascal acos(double);
double  __pascal asin(double);
double  __pascal atan(double);
double  __pascal atan2(double, double);
double  __pascal atof(const char *);
double  __pascal _cabs(struct _complex);
double  __pascal ceil(double);
double  __pascal cos(double);
double  __pascal cosh(double);
int __cdecl  _dieeetomsbin(double *, double *);
int __cdecl  _dmsbintoieee(double *, double *);
double  __pascal exp(double);
double  __pascal fabs(double);
int __cdecl  _fieeetomsbin(float *, float *);
double  __pascal floor(double);
double  __pascal fmod(double, double);
int __cdecl  _fmsbintoieee(float *, float *);
double  __pascal frexp(double, int *);
double  __pascal _hypot(double, double);
double  __pascal _j0(double);
double  __pascal _j1(double);
double  __pascal _jn(int, double);
long    __cdecl  labs(long);
double  __pascal ldexp(double, int);
double  __pascal log(double);
double  __pascal log10(double);
int __cdecl  _matherr(struct _exception *);
double  __pascal modf(double, double *);
double  __pascal pow(double, double);
double  __pascal sin(double);
double  __pascal sinh(double);
double  __pascal sqrt(double);
double  __pascal tan(double);
double  __pascal tanh(double);
double  __pascal _y0(double);
double  __pascal _y1(double);
double  __pascal _yn(int, double);

#else 
int __cdecl abs(int);
double  __cdecl acos(double);
double  __cdecl asin(double);
double  __cdecl atan(double);
double  __cdecl atan2(double, double);
double  __cdecl atof(const char *);
double  __cdecl _cabs(struct _complex);
double  __cdecl ceil(double);
double  __cdecl cos(double);
double  __cdecl cosh(double);
int __cdecl _dieeetomsbin(double *, double *);
int __cdecl _dmsbintoieee(double *, double *);
double  __cdecl exp(double);
double  __cdecl fabs(double);
int __cdecl _fieeetomsbin(float *, float *);
double  __cdecl floor(double);
double  __cdecl fmod(double, double);
int __cdecl _fmsbintoieee(float *, float *);
double  __cdecl frexp(double, int *);
double  __cdecl _hypot(double, double);
double  __cdecl _j0(double);
double  __cdecl _j1(double);
double  __cdecl _jn(int, double);
long    __cdecl labs(long);
double  __cdecl ldexp(double, int);
double  __cdecl log(double);
double  __cdecl log10(double);
int __cdecl _matherr(struct _exception *);
double  __cdecl modf(double, double *);
double  __cdecl pow(double, double);
double  __cdecl sin(double);
double  __cdecl sinh(double);
double  __cdecl sqrt(double);
double  __cdecl tan(double);
double  __cdecl tanh(double);
double  __cdecl _y0(double);
double  __cdecl _y1(double);
double  __cdecl _yn(int, double);
#endif 


/* definition of _exceptionl struct - this struct is passed to the _matherrl
 * routine when a floating point exception is detected in a long double routine
 */

#ifndef _LD_EXCEPTION_DEFINED
#pragma pack(2)
struct _exceptionl {
    int type;       /* exception type - see below */
    char *name;   /* name of function where error occured */
    long double arg1;   /* first argument to function */
    long double arg2;   /* second argument (if any) to function */
    long double retval; /* value to be returned by function */
    } ;
#pragma pack()
#define _LD_EXCEPTION_DEFINED
#endif 


/* definition of a _complexl struct to be used by those who use _cabsl and
 * want type checking on their argument
 */

#ifndef _LD_COMPLEX_DEFINED
#pragma pack(2)
struct _complexl {
    long double x,y;    /* real and imaginary parts */
    } ;
#pragma pack()
#define _LD_COMPLEX_DEFINED
#endif 

extern long double __near __cdecl _LHUGE;
#define _LHUGE_VAL _LHUGE


long double  __cdecl acosl(long double);
long double  __cdecl asinl(long double);
long double  __cdecl atanl(long double);
long double  __cdecl atan2l(long double, long double);
long double  __cdecl _atold(const char *);
long double  __cdecl _cabsl(struct _complexl);
long double  __cdecl ceill(long double);
long double  __cdecl cosl(long double);
long double  __cdecl coshl(long double);
long double  __cdecl expl(long double);
long double  __cdecl fabsl(long double);
long double  __cdecl floorl(long double);
long double  __cdecl fmodl(long double, long double);
long double  __cdecl frexpl(long double, int *);
long double  __cdecl _hypotl(long double, long double);
long double  __cdecl _j0l(long double);
long double  __cdecl _j1l(long double);
long double  __cdecl _jnl(int, long double);
long double  __cdecl ldexpl(long double, int);
long double  __cdecl logl(long double);
long double  __cdecl log10l(long double);
int      __cdecl _matherrl(struct _exceptionl *);
long double  __cdecl modfl(long double, long double *);
long double  __cdecl powl(long double, long double);
long double  __cdecl sinl(long double);
long double  __cdecl sinhl(long double);
long double  __cdecl sqrtl(long double);
long double  __cdecl tanl(long double);
long double  __cdecl tanhl(long double);
long double  __cdecl _y0l(long double);
long double  __cdecl _y1l(long double);
long double  __cdecl _ynl(int, long double);


#ifndef __STDC__
/* Non-ANSI names for compatibility */

#define DOMAIN      _DOMAIN
#define SING        _SING
#define OVERFLOW    _OVERFLOW
#define UNDERFLOW   _UNDERFLOW
#define TLOSS       _TLOSS
#define PLOSS       _PLOSS

#define matherr _matherr

extern double __near __cdecl HUGE;

#ifdef _MT
#ifndef __cplusplus
double  __pascal cabs(struct complex);
#endif 
double  __pascal hypot(double, double);
double  __pascal j0(double);
double  __pascal j1(double);
double  __pascal jn(int, double);
double  __pascal y0(double);
double  __pascal y1(double);
double  __pascal yn(int, double);
#else 
#ifndef __cplusplus
double  __cdecl cabs(struct complex);
#endif 
double  __cdecl hypot(double, double);
double  __cdecl j0(double);
double  __cdecl j1(double);
double  __cdecl jn(int, double);
double  __cdecl y0(double);
double  __cdecl y1(double);
double  __cdecl yn(int, double);
#endif 

int __cdecl dieeetomsbin(double *, double *);
int __cdecl dmsbintoieee(double *, double *);
int __cdecl fieeetomsbin(float *, float *);
int __cdecl fmsbintoieee(float *, float *);

long double  __cdecl cabsl(struct _complexl);
long double  __cdecl hypotl(long double, long double);

#endif 


#ifdef __cplusplus
}
#endif 

#define _INC_MATH
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\tools\c816\inc\pgchart.h ===
/***
*pgchart.h - Declare constants, functions and macros for charting library.
*
*  Copyright (c) 1988-1992, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*  This file declares the presentation graphics library functions and
*  the structures and manifest constants that are used with them.
*
***************************************************************************/


#ifdef __cplusplus
extern "C" {				/* allow use with C++ */
#endif

#if (_MSC_VER <= 600)
#define	__cdecl	_cdecl
#define	__far	_far
#endif

/* Force word alignment to avoid possible -Zp override */
#pragma	pack(2)


/* Required for the missing value definition */
#ifndef	FLT_MAX
#define FLT_MAX			3.402823466e+38F	/* max value */
#endif

#define _PG_PALETTELEN		16	/* Number of entries in internal palette */
#define _PG_MAXCHARTTYPE	5	/* Maximum available chart type */
#define _PG_MAXCHARTSTYLE	2	/* Maximum chart style */
#define _PG_TITLELEN		70	/* Maximum title text length */

#define _PG_LEFT		1	/* Positions used for titles and legends */
#define _PG_CENTER		2
#define _PG_RIGHT		3
#define _PG_BOTTOM		4
#define _PG_OVERLAY		5

#define _PG_LINEARAXIS		1	/* Used to specify axis types */
#define _PG_LOGAXIS		2

#define _PG_DECFORMAT		1	/* Used to specify tic mark label format */
#define _PG_EXPFORMAT		2

#define _PG_BARCHART		1	/* Charttype for a bar chart */
#define _PG_COLUMNCHART		2	/* Charttype for a column chart */
#define  _PG_PLAINBARS		1	/* Styles for bar and column charts */
#define  _PG_STACKEDBARS	2

#define _PG_LINECHART		3	/* Charttype for a line chart */
#define _PG_SCATTERCHART	4	/* Charttype for a scatter chart */
#define _PG_POINTANDLINE	1	/* Styles for line and scatter charts */
#define _PG_POINTONLY		2

#define _PG_PIECHART		5	/* Charttype for pie chart */
#define _PG_PERCENT		1	/* Styles for pie charts */
#define _PG_NOPERCENT		2

#define _PG_MISSINGVALUE	(-FLT_MAX) /* Indicates missing data values */


/* Error codes */

/* Numbers greater than 100 will terminate chart routine, others will cause
 * default values to be used
 */
#define	_PG_NOTINITIALIZED	102	/* If library not initialized */
#define	_PG_BADSCREENMODE	103	/* Graphics mode not set before charting */
#define	_PG_BADCHARTSTYLE	04	/* Chart style invalid */
#define	_PG_BADCHARTTYPE	104	/* Chart type invalid */
#define	_PG_BADLEGENDWINDOW	105	/* Invalid legend window specified */
#define	_PG_BADCHARTWINDOW	07	/* x1=x2 or y1=y2 in chart window spec. */
#define	_PG_BADDATAWINDOW	107	/* If chart window is too small */
#define	_PG_NOMEMORY		108	/* Not enough memory for data arrays */
#define	_PG_BADLOGBASE		05	/* Log base <= 0 */
#define	_PG_BADSCALEFACTOR	06	/* Scale factor = 0 */
#define	_PG_TOOSMALLN		109	/* Number of data points <= 0 */
#define	_PG_TOOFEWSERIES	110	/* Number of series <= 0 */


/* Typedefs */

/* Typedef for chart title */
#ifndef _TITLETYPE_DEFINED
typedef	struct	{
	char	title[_PG_TITLELEN];	/* Title text */
	short	titlecolor;		/* Internal palette color for title text */
	short	justify;		/* _PG_LEFT, _PG_CENTER, _PG_RIGHT */
} _titletype;
#define _TITLETYPE_DEFINED
#endif

/* Typedef for chart axes */
#ifndef _AXISTYPE_DEFINED
typedef	struct	{
	short		grid;		/* TRUE=grid lines drawn; FALSE no lines */
	short		gridstyle;	/* Style number from style pool for grid lines */
	_titletype	axistitle;	/* Title definition for axis */
	short		axiscolor;	/* Color for axis */
	short		labeled;	/* TRUE=tic marks and titles drawn */
	short		rangetype;	/* _PG_LINEARAXIS, _PG_LOGAXIS */
	float		logbase;	/* Base used if log axis */
	short		autoscale;	/* TRUE=next 7 values calculated by system */
	float		scalemin;	/* Minimum value of scale */
	float		scalemax;	/* Maximum value of scale */
	float		scalefactor;	/* Scale factor for data on this axis */
	_titletype	scaletitle;	/* Title definition for scaling factor */
	float		ticinterval;	/* Distance between tic marks (world coord.) */
	short		ticformat;	/* _PG_EXPFORMAT or _PG_DECFORMAT for tic labels */
	short		ticdecimals;	/* Number of decimals for tic labels (max=9)*/
} _axistype;
#define _AXISTYPE_DEFINED
#endif

/* Typedef used for defining chart and data windows */
#ifndef _WINDOWTYPE_DEFINED
typedef	struct	{
	short		x1;		/* Left edge of window in pixels */
	short		y1;		/* Top edge of window in pixels */
	short		x2;		/* Right edge of window in pixels */
	short		y2;		/* Bottom edge of window in pixels */
	short		border;		/* TRUE for border, FALSE otherwise */
	short		background;	/* Internal palette color for window bgnd */
	short		borderstyle;	/* Style bytes for window border */
	short		bordercolor;	/* Internal palette color for window border */
} _windowtype;
#define _WINDOWTYPE_DEFINED
#endif

/* Typedef for legend definition */
#ifndef _LEGENDTYPE_DEFINED
typedef struct	{
	short		legend;		/* TRUE=draw legend; FALSE=no legend */
	short		place;		/* _PG_RIGHT, _PG_BOTTOM, _PG_OVERLAY */
	short		textcolor;	/* Internal palette color for text */
	short		autosize;	/* TRUE=system calculates size */
	_windowtype	legendwindow;	/* Window definition for legend */
} _legendtype;
#define _LEGENDTYPE_DEFINED
#endif

/* Typedef for legend definition */
#ifndef _CHARTENV_DEFINED
typedef struct	{
	short		charttype;	/* _PG_BARCHART, _PG_COLUMNCHART,
					_PG_LINECHART, _PG_SCATTERCHART,
						 _PG_PIECHART */
	short		chartstyle;	/* Style for selected chart type */
	_windowtype	chartwindow;	/* Window definition for overall chart */
	_windowtype	datawindow;	/* Window definition for data part of chart */
	_titletype	maintitle;	/* Main chart title */
	_titletype	subtitle;	/* Chart sub-title */
	_axistype	xaxis;		/* Definition for X-axis */
	_axistype	yaxis;		/* Definition for Y-axis */
	_legendtype	legend;		/* Definition for legend */
} _chartenv;
#define _CHARTENV_DEFINED
#endif

/* Typedef for character bitmap */
#ifndef _CHARMAP_DEFINED
typedef unsigned char _charmap[8];
#define _CHARMAP_DEFINED
#endif

/* Typedef for pattern bitmap */
#ifndef _FILLMAP_DEFINED
typedef unsigned char _fillmap[8];
#define _FILLMAP_DEFINED
#endif

/* Typedef for palette entry definition */
#ifndef _PALETTEENTRY_DEFINED
typedef struct {
	unsigned short	color;
	unsigned short	style;
	_fillmap	fill;
	char		plotchar;
} _paletteentry;
#define _PALETTEENTRY_DEFINED
#endif

/* Typedef for palette definition */
#ifndef _PALETTETYPE_DEFINED
typedef _paletteentry _palettetype[_PG_PALETTELEN];
#define _PALETTETYPE_DEFINED
#endif

/* Typedef for style sets */
#ifndef _STYLESET_DEFINED
typedef unsigned short _styleset[_PG_PALETTELEN];
#define _STYLESET_DEFINED
#endif

#ifndef __STDC__ 
/* Non-ANSI names for compatibility */ 
#define titletype     _titletype 
#define axistype      _axistype 
#define windowtype    _windowtype 
#define legendtype    _legendtype 
#define chartenv      _chartenv 
#define charmap       _charmap 
#define fillmap       _fillmap 
#define paletteentry  _paletteentry 
#define palettetype   _palettetype 
#define styleset      _styleset 
#endif 


/* Function prototypes for charting routines	*/

short __far __cdecl _pg_initchart(void);
short __far __cdecl _pg_defaultchart(_chartenv __far *, short, short);

short __far __cdecl _pg_chart(_chartenv __far *, const char __far * const __far *, const float __far *, short);
short __far __cdecl _pg_chartms(_chartenv __far *, const char __far * const __far *, const float __far *, short, short, short, const char __far * const __far *);

short __far __cdecl _pg_chartscatter(_chartenv __far *, const float __far *, const float __far *, short);
short __far __cdecl _pg_chartscatterms(_chartenv __far *, const float __far *, const float __far *, short, short, short, const char __far * const __far *);

short __far __cdecl _pg_chartpie(_chartenv __far *, const char __far * const __far *, const float __far *, const short __far *, short);

/* Function prototypes for support routines	*/

short __far __cdecl _pg_hlabelchart(_chartenv __far *, short, short, short, const char __far *);
short __far __cdecl _pg_vlabelchart(_chartenv __far *, short, short, short, const char __far *);

short __far __cdecl _pg_analyzechart(_chartenv __far *, const char __far * const __far *, const float __far *, short);
short __far __cdecl _pg_analyzechartms(_chartenv __far *, const char __far * const __far *, const float __far *, short, short, short, const char __far * const __far *);

short __far __cdecl _pg_analyzescatter(_chartenv __far *, const float __far *, const float __far *, short);
short __far __cdecl _pg_analyzescatterms(_chartenv __far *, const float __far *, const float __far *, short, short, short, const char __far * const __far *);

short __far __cdecl _pg_analyzepie(_chartenv __far *, const char __far * const __far *, const float __far *, const short __far *, short);

short __far __cdecl _pg_getpalette(_paletteentry __far *);
short __far __cdecl _pg_setpalette(const _paletteentry __far *);
short __far __cdecl _pg_resetpalette(void);

void  __far __cdecl _pg_getstyleset(unsigned short __far *);
void  __far __cdecl _pg_setstyleset(const unsigned short __far *);
void  __far __cdecl _pg_resetstyleset(void);

short __far __cdecl _pg_getchardef(short, unsigned char __far *);
short __far __cdecl _pg_setchardef(short, const unsigned char __far *);


/* Restore default packing */
#pragma pack()

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\tools\c816\inc\search.h ===
/***
*search.h - declarations for searcing/sorting routines
*
*   Copyright (c) 1985-1992, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*   This file contains the declarations for the sorting and
*   searching routines.
*   [System V]
*
****/

#ifndef _INC_SEARCH

#ifdef __cplusplus
extern "C" {
#endif 

#if (_MSC_VER <= 600)
#define __cdecl     _cdecl
#define __far       _far
#endif 

#ifndef _SIZE_T_DEFINED
typedef unsigned int size_t;
#define _SIZE_T_DEFINED
#endif 


/* function prototypes */

void * __cdecl bsearch(const void *, const void *,
    size_t, size_t, int (__cdecl *)(const void *,
    const void *));
void * __cdecl _lfind(const void *, const void *,
    unsigned int *, unsigned int, int (__cdecl *)
    (const void *, const void *));
void * __cdecl _lsearch(const void *, void *,
    unsigned int *, unsigned int, int (__cdecl *)
    (const void *, const void *));
void __cdecl qsort(void *, size_t, size_t, int (__cdecl *)
    (const void *, const void *));

#ifndef __STDC__
/* Non-ANSI names for compatibility */
void * __cdecl lfind(const void *, const void *,
    unsigned int *, unsigned int, int (__cdecl *)
    (const void *, const void *));
void * __cdecl lsearch(const void *, void *,
    unsigned int *, unsigned int, int (__cdecl *)
    (const void *, const void *));
#endif 

#ifdef __cplusplus
}
#endif 

#define _INC_SEARCH
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\tools\c816\inc\setjmp.h ===
/***
*setjmp.h - definitions/declarations for setjmp/longjmp routines
*
*   Copyright (c) 1985-1993, Microsoft Corporation. All rights reserved.
*
*Purpose:
*   This file defines the machine-dependent buffer used by
*   setjmp/longjmp to save and restore the program state, and
*   declarations for those routines.
*   [ANSI/System V]
*
****/

#ifndef _INC_SETJMP

#ifndef __cplusplus

#if (_MSC_VER <= 600)
#define __cdecl     _cdecl
#define __far       _far
#endif 

/* define the buffer type for holding the state information */

#define _JBLEN  9  /* bp, di, si, sp, ret addr, ds */

#ifndef _JMP_BUF_DEFINED
typedef  int  jmp_buf[_JBLEN];
#define _JMP_BUF_DEFINED
#endif 

/* ANSI requires setjmp be a macro */

#define setjmp  _setjmp

/* function prototypes */

int  __cdecl _setjmp(jmp_buf);
int  __cdecl setjmp(jmp_buf); //JAH
void __cdecl longjmp(jmp_buf, int);

#endif 

#define _INC_SETJMP
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\tools\c816\inc\share.h ===
/***
*share.h - defines file sharing modes for sopen
*
*   Copyright (c) 1985-1992, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*   This file defines the file sharing modes for sopen().
*
****/

#ifndef _INC_SHARE

#define _SH_COMPAT  0x00    /* compatibility mode */
#define _SH_DENYRW  0x10    /* deny read/write mode */
#define _SH_DENYWR  0x20    /* deny write mode */
#define _SH_DENYRD  0x30    /* deny read mode */
#define _SH_DENYNO  0x40    /* deny none mode */

#ifndef __STDC__
/* Non-ANSI names for compatibility */
#define SH_COMPAT _SH_COMPAT
#define SH_DENYRW _SH_DENYRW
#define SH_DENYWR _SH_DENYWR
#define SH_DENYRD _SH_DENYRD
#define SH_DENYNO _SH_DENYNO
#endif 

#define _INC_SHARE
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\tools\c816\inc\signal.h ===
/***
*signal.h - defines signal values and routines
*
*   Copyright (c) 1985-1992, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*   This file defines the signal values and declares the signal functions.
*   [ANSI/System V]
*
****/

#ifndef _INC_SIGNAL

#ifdef __cplusplus
extern "C" {
#endif 

#if (_MSC_VER <= 600)
#define __cdecl     _cdecl
#define __far       _far
#endif 

#ifndef _SIG_ATOMIC_T_DEFINED
typedef int sig_atomic_t;
#define _SIG_ATOMIC_T_DEFINED
#endif 

#define NSIG 23     /* maximum signal number + 1 */


/* signal types */

#ifndef _WINDOWS
#define SIGINT      2   /* Ctrl-C sequence */
#define SIGILL      4   /* illegal instruction - invalid function image */
#endif 
#define SIGFPE      8   /* floating point exception */
#ifndef _WINDOWS
#define SIGSEGV     11  /* segment violation */
#define SIGTERM     15  /* Software termination signal from kill */
#define SIGABRT     22  /* abnormal termination triggered by abort call */
#endif 


/* signal action codes */

/* default signal action */
#define SIG_DFL (void (__cdecl *)(int))0

/* ignore */
#define SIG_IGN (void (__cdecl *)(int))1

/* signal error value (returned by signal call on error) */
#define SIG_ERR (void (__cdecl *)(int))-1


/* function prototypes */

void (__cdecl * __cdecl signal(int,
    void (__cdecl *)(int)))(int);
#ifndef _MT
int __cdecl raise(int);
#endif 

#ifdef __cplusplus
}
#endif 

#define _INC_SIGNAL
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\tools\c816\inc\stdarg.h ===
/***
*stdarg.h - defines ANSI-style macros for variable argument functions
*
*   Copyright (c) 1985-1992, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*   This file defines ANSI-style macros for accessing arguments
*   of functions which take a variable number of arguments.
*   [ANSI]
*
****/

#ifndef _INC_STDARG

#ifdef __cplusplus
extern "C" {
#endif 

#ifdef _WINDLL
#define _FARARG_ __far
#else 
#define _FARARG_
#endif 

#if (_MSC_VER <= 600)
#define __far       _far
#endif 

#ifndef _VA_LIST_DEFINED
typedef char _FARARG_ *va_list;
#define _VA_LIST_DEFINED
#endif 

/*
 * define a macro to compute the size of a type, variable or expression,
 * rounded up to the nearest multiple of sizeof(int). This number is its
 * size as function argument (Intel architecture). Note that the macro
 * depends on sizeof(int) being a power of 2!
 */

#define _INTSIZEOF(n)    ( (sizeof(n) + sizeof(int) - 1) & ~(sizeof(int) - 1) )

#define va_start(ap,v) ap = (va_list)&v + _INTSIZEOF(v)
#define va_arg(ap,t) ( *(t _FARARG_ *)((ap += _INTSIZEOF(t)) - _INTSIZEOF(t)) )
#define va_end(ap) ap = (va_list)0

#ifdef __cplusplus
}
#endif 

#define _INC_STDARG
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\tools\c816\inc\stddef.h ===
/***
*stddef.h - definitions/declarations for common constants, types, variables
*
*   Copyright (c) 1985-1992, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*   This file contains definitions and declarations for some commonly
*   used constants, types, and variables.
*   [ANSI]
*
****/

#ifndef _INC_STDDEF

#ifdef __cplusplus
extern "C" {
#endif 

#if (_MSC_VER <= 600)
#define __cdecl     _cdecl
#define __far       _far
#define __near      _near
#endif 

/* define the NULL pointer value and the offsetof() macro */

#ifndef NULL
#ifdef __cplusplus
#define NULL    0
#else 
#define NULL    ((void *)0)
#endif 
#endif 


/* offset of field m in a struct s */

#define offsetof(s,m)   (size_t)( (char *)&(((s *)0)->m) - (char *)0 )


/* errno declaration */

#ifdef _MT
extern int __far * __cdecl __far volatile _errno(void);
#define errno   (*_errno())
#else 
extern int __near __cdecl volatile errno;
#endif 


/* define the implementation dependent size types */

#ifndef _PTRDIFF_T_DEFINED
typedef int ptrdiff_t;
#define _PTRDIFF_T_DEFINED
#endif 

#ifndef _SIZE_T_DEFINED
typedef unsigned int size_t;
#define _SIZE_T_DEFINED
#endif 

#ifndef _WCHAR_T_DEFINED
typedef unsigned short wchar_t;
#define _WCHAR_T_DEFINED
#endif 


#ifdef _MT
/* define pointer to thread id value */

extern int __far *_threadid;
#endif 

#ifdef __cplusplus
}
#endif 

#define _INC_STDDEF
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\tools\c816\inc\stdiostr.h ===
/***
*stdiostr.h - definitions/declarations for stdiobuf, stdiostream
*
*   Copyright (c) 1991-1992, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*   This file defines the classes, values, macros, and functions
*   used by the stdiostream and stdiobuf classes.
*   [AT&T C++]
*
****/

#include <iostream.h>
#include <stdio.h>

// Force word packing to avoid possible -Zp override
#pragma pack(2)

#pragma warning(disable:4505)       // disable unwanted /W4 warning
// #pragma warning(default:4505)    // use this to reenable, if necessary

#ifndef _INC_STDIOSTREAM
#define _INC_STDIOSTREAM
class stdiobuf : public streambuf  {
public:
    stdiobuf(FILE* f);
FILE *  stdiofile() { return _str; }

virtual int pbackfail(int c);
virtual int overflow(int c = EOF);
virtual int underflow();
virtual streampos seekoff( streamoff, ios::seek_dir, int =ios::in|ios::out);
virtual int sync();
    ~stdiobuf();
    int setrwbuf(int _rsize, int _wsize); // CONSIDER: move to ios::
// protected:
// virtual int doallocate();
private:
    FILE * _str;
};

// obsolescent
class stdiostream : public iostream {   // note: spec.'d as : public IOS...
public:
    stdiostream(FILE *);
    ~stdiostream();
    stdiobuf* rdbuf() const { return (stdiobuf*) ostream::rdbuf(); }

private:
};

// Restore default packing
#pragma pack()

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\tools\c816\inc\stdio.h ===
/***
*stdio.h - definitions/declarations for standard I/O routines
*
*   Copyright (c) 1985-1992, Microsoft Corporation. All rights reserved.
*
*Purpose:
*   This file defines the structures, values, macros, and functions
*   used by the level 2 I/O ("standard I/O") routines.
*   [ANSI/System V]
*
****/

#ifndef _INC_STDIO

#ifdef __cplusplus
extern "C" {
#endif 

#if (_MSC_VER <= 600)
#define __cdecl     _cdecl
#define __far       _far
#define __near      _near
#endif 

#ifndef _SIZE_T_DEFINED
typedef unsigned int size_t;
#define _SIZE_T_DEFINED
#endif 

#ifndef _VA_LIST_DEFINED
typedef char *va_list;
#define _VA_LIST_DEFINED
#endif 

/* buffered I/O macros */

#define BUFSIZ  512
#ifdef _MT
#define _NFILE  40
#else 
#define _NFILE  20
#endif 
#define EOF (-1)

#ifndef _FILE_DEFINED
#pragma pack(2)
struct _iobuf {
    char *_ptr;
    int   _cnt;
    char *_base;
    char  _flag;
    char  _file;
    };
typedef struct _iobuf FILE;
#pragma pack()
#define _FILE_DEFINED
#endif 


/* _P_tmpnam: Directory where temporary files may be created.
 * L_tmpnam size =  size of _P_tmpdir
 *  + 1 (in case _P_tmpdir does not end in "\\")
 *  + 6 (for the temp number string)
 *  + 1 (for the null terminator)
 */

#define  _P_tmpdir "\\"
#define  L_tmpnam sizeof(_P_tmpdir)+8


/* fseek constants */

#define SEEK_CUR 1
#define SEEK_END 2
#define SEEK_SET 0


/* minimum guaranteed filename length, open file count, and unique
 * tmpnam filenames.
 */

#define FILENAME_MAX 128
#define FOPEN_MAX 18
#define TMP_MAX 32767
#define _SYS_OPEN 20


/* define NULL pointer value */

#ifndef NULL
#ifdef __cplusplus
#define NULL    0
#else 
#define NULL    ((void *)0)
#endif 
#endif 


/* declare _iob[] array */

#ifndef _STDIO_DEFINED
extern FILE __near __cdecl _iob[];
#endif 


/* define file position type */

#ifndef _FPOS_T_DEFINED
typedef long fpos_t;
#define _FPOS_T_DEFINED
#endif 


/* standard file pointers */

#ifndef _WINDLL
#define stdin  (&_iob[0])
#define stdout (&_iob[1])
#define stderr (&_iob[2])
#endif 
#ifndef _WINDOWS
#define _stdaux (&_iob[3])
#define _stdprn (&_iob[4])
#endif 


#define _IOREAD     0x01
#define _IOWRT      0x02

#define _IOFBF      0x0
#define _IOLBF      0x40
#define _IONBF      0x04

#define _IOMYBUF    0x08
#define _IOEOF      0x10
#define _IOERR      0x20
#define _IOSTRG     0x40
#define _IORW       0x80


#ifdef _WINDOWS
#ifndef _WINDLL
#ifndef _WINFO_DEFINED
/* interface version number */
#define _QWINVER    0

/* max number of windows */
#define _WFILE      20

/* values for windows screen buffer size */
#define _WINBUFINF  0
#define _WINBUFDEF  -1

/* size/move settings */
#define _WINSIZEMIN 1
#define _WINSIZEMAX 2
#define _WINSIZERESTORE 3
#define _WINSIZECHAR    4

/* size/move query types */
#define _WINMAXREQ  100
#define _WINCURRREQ 101

/* values for closing window */
#define _WINPERSIST 1
#define _WINNOPERSIST   0

/* pseudo file handle for frame window */
#define _WINFRAMEHAND   -1

/* menu items */
#define _WINSTATBAR 1
#define _WINTILE    2
#define _WINCASCADE 3
#define _WINARRANGE 4

/* quickwin exit options */
#define _WINEXITPROMPT      1
#define _WINEXITNOPERSIST   2
#define _WINEXITPERSIST     3

/* open structure */
#pragma pack(2)
struct _wopeninfo {
    unsigned int _version;
    const char __far * _title;
    long _wbufsize;
    };
#pragma pack()

/* size/move structure */
struct _wsizeinfo {
    unsigned int _version;
    unsigned int _type;
    unsigned int _x;
    unsigned int _y;
    unsigned int _h;
    unsigned int _w;
    };
#define _WINFO_DEFINED
#endif 
#endif 
#endif 

/* function prototypes */

#ifndef _STDIO_DEFINED
int __cdecl _filbuf(FILE *);
int __cdecl _flsbuf(int, FILE *);
FILE * __cdecl _fsopen(const char *,
    const char *, int);
void __cdecl clearerr(FILE *);
int __cdecl fclose(FILE *);
int __cdecl _fcloseall(void);
FILE * __cdecl _fdopen(int, const char *);
int __cdecl feof(FILE *);
int __cdecl ferror(FILE *);
int __cdecl fflush(FILE *);
int __cdecl fgetc(FILE *);
#ifndef _WINDLL
int __cdecl _fgetchar(void);
#endif 
int __cdecl fgetpos(FILE *, fpos_t *);
char * __cdecl fgets(char *, int, FILE *);
int __cdecl _fileno(FILE *);
int __cdecl _flushall(void);
FILE * __cdecl fopen(const char *,
    const char *);
int __cdecl fprintf(FILE *, const char *, ...);
int __cdecl fputc(int, FILE *);
#ifndef _WINDLL
int __cdecl _fputchar(int);
#endif 
int __cdecl fputs(const char *, FILE *);
size_t __cdecl fread(void *, size_t, size_t, FILE *);
FILE * __cdecl freopen(const char *,
    const char *, FILE *);
#ifndef _WINDLL
int __cdecl fscanf(FILE *, const char *, ...);
#endif 
int __cdecl fsetpos(FILE *, const fpos_t *);
int __cdecl fseek(FILE *, long, int);
long __cdecl ftell(FILE *);
#ifdef _WINDOWS
#ifndef _WINDLL
FILE * __cdecl _fwopen(struct _wopeninfo *, struct _wsizeinfo *, const char *);
#endif 
#endif 
size_t __cdecl fwrite(const void *, size_t, size_t,
    FILE *);
int __cdecl getc(FILE *);
#ifndef _WINDLL
int __cdecl getchar(void);
char * __cdecl gets(char *);
#endif 
int __cdecl _getw(FILE *);
#ifndef _WINDLL
void __cdecl perror(const char *);
#endif 
#ifndef _WINDLL
int __cdecl printf(const char *, ...);
#endif 
int __cdecl putc(int, FILE *);
#ifndef _WINDLL
int __cdecl putchar(int);
int __cdecl puts(const char *);
#endif 
int __cdecl _putw(int, FILE *);
int __cdecl remove(const char *);
int __cdecl rename(const char *, const char *);
void __cdecl rewind(FILE *);
int __cdecl _rmtmp(void);
#ifndef _WINDLL
int __cdecl scanf(const char *, ...);
#endif 
void __cdecl setbuf(FILE *, char *);
int __cdecl setvbuf(FILE *, char *, int, size_t);
int __cdecl _snprintf(char *, size_t, const char *, ...);
int __cdecl sprintf(char *, const char *, ...);
#ifndef _WINDLL
int __cdecl sscanf(const char *, const char *, ...);
#endif 
char * __cdecl _tempnam(char *, char *);
FILE * __cdecl tmpfile(void);
char * __cdecl tmpnam(char *);
int __cdecl ungetc(int, FILE *);
int __cdecl _unlink(const char *);
int __cdecl vfprintf(FILE *, const char *, va_list);
#ifndef _WINDLL
int __cdecl vprintf(const char *, va_list);
#endif 
int __cdecl _vsnprintf(char *, size_t, const char *, va_list);
int __cdecl vsprintf(char *, const char *, va_list);
#define _STDIO_DEFINED
#endif 

/* macro definitions */

#define feof(_stream)     ((_stream)->_flag & _IOEOF)
#define ferror(_stream)   ((_stream)->_flag & _IOERR)
#define _fileno(_stream)  ((int)(unsigned char)(_stream)->_file)
#define getc(_stream)     (--(_stream)->_cnt >= 0 ? 0xff & *(_stream)->_ptr++ \
    : _filbuf(_stream))
#define putc(_c,_stream)  (--(_stream)->_cnt >= 0 \
    ? 0xff & (*(_stream)->_ptr++ = (char)(_c)) :  _flsbuf((_c),(_stream)))
#ifndef _WINDLL
#define getchar()     getc(stdin)
#define putchar(_c)   putc((_c),stdout)
#endif 

#ifdef _MT
#undef  getc
#undef  putc
#undef  getchar
#undef  putchar
#endif 

#ifndef __STDC__
/* Non-ANSI names for compatibility */

#define P_tmpdir  _P_tmpdir
#define SYS_OPEN  _SYS_OPEN

#ifndef _WINDOWS
#define stdaux    _stdaux
#define stdprn    _stdprn
#endif 

int __cdecl fcloseall(void);
FILE * __cdecl fdopen(int, const char *);
#ifndef _WINDLL
int __cdecl fgetchar(void);
#endif 
int __cdecl fileno(FILE *);
int __cdecl flushall(void);
#ifndef _WINDLL
int __cdecl fputchar(int);
#endif 
int __cdecl getw(FILE *);
int __cdecl putw(int, FILE *);
int __cdecl rmtmp(void);
char * __cdecl tempnam(char *, char *);
int __cdecl unlink(const char *);

#endif 

#ifdef __cplusplus
}
#endif 

#define _INC_STDIO
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\tools\c816\inc\streamb.h ===
/***
*streamb.h - definitions/declarations for the streambuf class
*
*   Copyright (c) 1990-1992, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*   This file defines the classes, values, macros, and functions
*   used by the streambuf class.
*   [AT&T C++]
*
****/

#ifndef _INC_STREAMB
#define _INC_STREAMB


#ifdef M_I86HM
#define _HFAR_ __far
#else 
#define _HFAR_
#endif 

#ifndef NULL
#define NULL    0
#endif 

#ifndef EOF
#define EOF (-1)
#endif 

// Force word packing to avoid possible -Zp override
#pragma pack(2)

#pragma warning(disable:4505)       // disable unwanted /W4 warning
// #pragma warning(default:4505)    // use this to reenable, if necessary

typedef long streampos, streamoff;

class streambuf {
public:

    virtual ~streambuf();

    inline int in_avail() const;
    inline int out_waiting() const;
    int sgetc();
    int snextc();
    int sbumpc();
    void stossc();

    inline int sputbackc(char);

    inline int sputc(int);
    inline int sputn(const char _HFAR_ *,int);
    inline int sgetn(char _HFAR_ *,int);

    virtual int sync();

//  enum seek_dir { beg=0, cur=1, end=2 };  // CONSIDER: needed ???

    virtual streambuf* setbuf(char _HFAR_ *, int);
    virtual streampos seekoff(streamoff,ios::seek_dir,int =ios::in|ios::out);
    virtual streampos seekpos(streampos,int =ios::in|ios::out);

    virtual int xsputn(const char _HFAR_ *,int);
    virtual int xsgetn(char _HFAR_ *,int);

    virtual int overflow(int =EOF) = 0; // pure virtual function
    virtual int underflow() = 0;    // pure virtual function

    virtual int pbackfail(int);

    void dbp();

protected:
    streambuf();
    streambuf(char _HFAR_ *,int);

    inline char _HFAR_ * base() const;
    inline char _HFAR_ * ebuf() const;
    inline char _HFAR_ * pbase() const;
    inline char _HFAR_ * pptr() const;
    inline char _HFAR_ * epptr() const;
    inline char _HFAR_ * eback() const;
    inline char _HFAR_ * gptr() const;
    inline char _HFAR_ * egptr() const;
    inline int blen() const;
    inline void setp(char _HFAR_ *,char _HFAR_ *);
    inline void setg(char _HFAR_ *,char _HFAR_ *,char _HFAR_ *);
    inline void pbump(int);
    inline void gbump(int);

    void setb(char _HFAR_ *,char _HFAR_ *,int =0);
    inline int unbuffered() const;
    inline void unbuffered(int);
    int allocate();
    virtual int doallocate();

private:
    int _fAlloc;
    int _fUnbuf;
    int x_lastc;
    char _HFAR_ * _base;
    char _HFAR_ * _ebuf;
    char _HFAR_ * _pbase;
    char _HFAR_ * _pptr;
    char _HFAR_ * _epptr;
    char _HFAR_ * _eback;
    char _HFAR_ * _gptr;
    char _HFAR_ * _egptr;
};

inline int streambuf::in_avail() const { return (gptr()<_egptr) ? (_egptr-gptr()) : 0; }
inline int streambuf::out_waiting() const { return (_pptr>=_pbase) ? (_pptr-_pbase) : 0; }

inline int streambuf::sputbackc(char _c){ return (_eback<gptr()) ? *(--_gptr)=_c : pbackfail(_c); }

inline int streambuf::sputc(int _i){ return (_pptr<_epptr) ? (unsigned char)(*(_pptr++)=(char)_i) : overflow(_i); }

inline int streambuf::sputn(const char _HFAR_ * _str,int _n) { return xsputn(_str, _n); }
inline int streambuf::sgetn(char _HFAR_ * _str,int _n) { return xsgetn(_str, _n); }

inline char _HFAR_ * streambuf::base() const { return _base; }
inline char _HFAR_ * streambuf::ebuf() const { return _ebuf; }
inline int streambuf::blen() const  {return ((_ebuf > _base) ? (_ebuf-_base) : 0); }
inline char _HFAR_ * streambuf::pbase() const { return _pbase; }
inline char _HFAR_ * streambuf::pptr() const { return _pptr; }
inline char _HFAR_ * streambuf::epptr() const { return _epptr; }
inline char _HFAR_ * streambuf::eback() const { return _eback; }
inline char _HFAR_ * streambuf::gptr() const { return _gptr; }
inline char _HFAR_ * streambuf::egptr() const { return _egptr; }
inline void streambuf::gbump(int n) { if (_egptr) _gptr += n; }
inline void streambuf::pbump(int n) { if (_epptr) _pptr += n; }
inline void streambuf::setg(char _HFAR_ * eb, char _HFAR_ * g, char _HFAR_ * eg) {_eback=eb; _gptr=g; _egptr=eg; x_lastc=EOF; }
inline void streambuf::setp(char _HFAR_ * p, char _HFAR_ * ep) {_pptr=_pbase=p; _epptr=ep; }
inline int streambuf::unbuffered() const { return _fUnbuf; }
inline void streambuf::unbuffered(int fUnbuf) { _fUnbuf = fUnbuf; }

// Restore default packing
#pragma pack()

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\tools\c816\inc\stress.h ===
/*****************************************************************************\
*                                                                             *
* stress.h -    Stress functions definitions                                  *
*                                                                             *
*               Version 1.0                                                   *
*                                                                             *
*               Copyright (c) 1992, Microsoft Corp. All rights reserved.      *
*                                                                             *
*******************************************************************************/

#ifndef _INC_STRESS
#define _INC_STRESS

#ifndef RC_INVOKED
#pragma pack(1)         /* Assume byte packing throughout */
#endif  /* RC_INVOKED */

#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif	/* __cplusplus */

/****** Simple types & common helper macros *********************************/

#ifndef _INC_WINDOWS    /* If included with 3.0 headers... */
#define UINT        WORD
#define WINAPI      FAR PASCAL
#endif  /* _INC_WINDOWS */

/* stuff for AllocDiskSpace() */
#define  EDS_WIN     1
#define  EDS_CUR     2
#define  EDS_TEMP    3


/* function prototypes */
BOOL    WINAPI AllocMem(DWORD);
void    WINAPI FreeAllMem(void);
int     WINAPI AllocFileHandles(int);
void    WINAPI UnAllocFileHandles(void);
int     WINAPI GetFreeFileHandles(void);
int     WINAPI AllocDiskSpace(long,UINT);
void    WINAPI UnAllocDiskSpace(UINT);
BOOL    WINAPI AllocUserMem(UINT);
void    WINAPI FreeAllUserMem(void);
BOOL    WINAPI AllocGDIMem(UINT);
void    WINAPI FreeAllGDIMem(void);

#ifdef __cplusplus
}
#endif	/* __cplusplus */

#ifndef RC_INVOKED
#pragma pack()
#endif  /* RC_INVOKED */

#endif  /* _INC_STRESS */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\tools\c816\inc\process.h ===
/***
*process.h - definition and declarations for process control functions
*
*   Copyright (c) 1985-1992, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*   This file contains the declarations and definitions for the
*   spawnxx, execxx, and various other process control routines.
*
****/

#ifndef _INC_PROCESS

#ifdef __cplusplus
extern "C" {
#endif 

#if (_MSC_VER <= 600)
#define __cdecl     _cdecl
#define __far       _far
#define __near      _near
#endif 

/* mode values for spawnxx routines
 * (only P_WAIT and P_OVERLAY are supported on MS-DOS)
 */

#ifndef _MT
extern int __near __cdecl _p_overlay;
#endif 

#define _P_WAIT     0
#define _P_NOWAIT   1
#ifdef _MT
#define _P_OVERLAY  2
#else 
#define _P_OVERLAY  _p_overlay
#endif 
#define _OLD_P_OVERLAY  2
#define _P_NOWAITO  3
#define _P_DETACH   4


/* function prototypes */

#ifdef _MT
int __cdecl _beginthread(void(__cdecl *)(void *),
    void *, unsigned, void *);
void __cdecl _endthread(void);
#endif 
void __cdecl abort(void);
void __cdecl _cexit(void);
void __cdecl _c_exit(void);
#ifndef _WINDOWS
int __cdecl _execl(const char *, const char *, ...);
int __cdecl _execle(const char *, const char *, ...);
int __cdecl _execlp(const char *, const char *, ...);
int __cdecl _execlpe(const char *, const char *, ...);
int __cdecl _execv(const char *,
    const char * const *);
int __cdecl _execve(const char *,
    const char * const *, const char * const *);
int __cdecl _execvp(const char *,
    const char * const *);
int __cdecl _execvpe(const char *,
    const char * const *, const char * const *);
#endif 
#ifndef _WINDLL
void __cdecl exit(int);
void __cdecl _exit(int);
#endif 
int __cdecl _getpid(void);
#ifndef _WINDOWS
int __cdecl _spawnl(int, const char *, const char *,
    ...);
int __cdecl _spawnle(int, const char *, const char *,
    ...);
int __cdecl _spawnlp(int, const char *, const char *,
    ...);
int __cdecl _spawnlpe(int, const char *, const char *,
    ...);
int __cdecl _spawnv(int, const char *,
    const char * const *);
int __cdecl _spawnve(int, const char *,
    const char * const *, const char * const *);
int __cdecl _spawnvp(int, const char *,
    const char * const *);
int __cdecl _spawnvpe(int, const char *,
    const char * const *, const char * const *);
int __cdecl system(const char *);
#endif 

#ifndef __STDC__
/* Non-ANSI names for compatibility */

#define P_WAIT      _P_WAIT
#define P_NOWAIT    _P_NOWAIT
#define P_OVERLAY   _P_OVERLAY
#define OLD_P_OVERLAY   _OLD_P_OVERLAY
#define P_NOWAITO   _P_NOWAITO
#define P_DETACH    _P_DETACH

#ifndef _WINDOWS
int __cdecl execl(const char *, const char *, ...);
int __cdecl execle(const char *, const char *, ...);
int __cdecl execlp(const char *, const char *, ...);
int __cdecl execlpe(const char *, const char *, ...);
int __cdecl execv(const char *,
    const char * const *);
int __cdecl execve(const char *,
    const char * const *, const char * const *);
int __cdecl execvp(const char *,
    const char * const *);
int __cdecl execvpe(const char *,
    const char * const *, const char * const *);
#endif 
int __cdecl getpid(void);
#ifndef _WINDOWS
int __cdecl spawnl(int, const char *, const char *,
    ...);
int __cdecl spawnle(int, const char *, const char *,
    ...);
int __cdecl spawnlp(int, const char *, const char *,
    ...);
int __cdecl spawnlpe(int, const char *, const char *,
    ...);
int __cdecl spawnv(int, const char *,
    const char * const *);
int __cdecl spawnve(int, const char *,
    const char * const *, const char * const *);
int __cdecl spawnvp(int, const char *,
    const char * const *);
int __cdecl spawnvpe(int, const char *,
    const char * const *, const char * const *);
#endif 

#endif 

#ifdef __cplusplus
}
#endif 

#define _INC_PROCESS
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\tools\c816\inc\strstrea.h ===
/***
*strstream.h - definitions/declarations for strstreambuf, strstream
*
*   Copyright (c) 1991-1992, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*   This file defines the classes, values, macros, and functions
*   used by the strstream and strstreambuf classes.
*   [AT&T C++]
*
****/

#ifndef _INC_STRSTREAM
#define _INC_STRSTREAM

#include <iostream.h>

// Force word packing to avoid possible -Zp override
#pragma pack(2)

#pragma warning(disable:4505)       // disable unwanted /W4 warning
// #pragma warning(default:4505)    // use this to reenable, if necessary

#ifdef M_I86HM
#define _HFAR_ __far
#else 
#define _HFAR_
#endif 

class strstreambuf : public streambuf  {
public:
        strstreambuf();
        strstreambuf(int);
        strstreambuf(char _HFAR_ *, int, char _HFAR_ * = 0);
        strstreambuf(unsigned char _HFAR_ *, int, unsigned char _HFAR_ * = 0);
        strstreambuf(signed char _HFAR_ _HFAR_ *, int, signed char _HFAR_ * = 0);
        strstreambuf(void _HFAR_ * (*a)(long), void (*f) (void _HFAR_ *));
        ~strstreambuf();

    void    freeze(int =1);
    char _HFAR_ * str();

virtual int overflow(int);
virtual int underflow();
virtual streambuf* setbuf(char  _HFAR_ *, int);
virtual streampos seekoff(streamoff, ios::seek_dir, int);
virtual int sync();     // not in spec.

protected:
virtual int doallocate();
private:
    int x_dynamic;
    int     x_bufmin;
    int     _fAlloc;
    int x_static;
    void _HFAR_ * (* x_alloc)(long);
    void    (* x_free)(void _HFAR_ *);
};

class istrstream : public istream {
public:
        istrstream(char _HFAR_ *);
        istrstream(char _HFAR_ *, int);
        ~istrstream();

inline  strstreambuf* rdbuf() const { return (strstreambuf*) ios::rdbuf(); }
inline  char _HFAR_ *   str() { return rdbuf()->str(); }
};

class ostrstream : public ostream {
public:
        ostrstream();
        ostrstream(char _HFAR_ *, int, int = ios::out);
        ~ostrstream();

inline  int pcount() const { return rdbuf()->out_waiting(); }
inline  strstreambuf* rdbuf() const { return (strstreambuf*) ios::rdbuf(); }
inline  char _HFAR_ *   str() { return rdbuf()->str(); }
};

class strstream : public iostream { // strstreambase ???
public:
        strstream();
        strstream(char _HFAR_ *, int, int);
        ~strstream();

inline  int pcount() const { return rdbuf()->out_waiting(); } // not in spec.
inline  strstreambuf* rdbuf() const { return (strstreambuf*) ostream::rdbuf(); }
inline  char _HFAR_ *   str() { return rdbuf()->str(); }
};

// Restore default packing
#pragma pack()

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\tools\c816\inc\stdlib.h ===
/***
*stdlib.h - declarations/definitions for commonly used library functions
*
*   Copyright (c) 1985-1992, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*   This include file contains the function declarations for
*   commonly used library functions which either don't fit somewhere
*   else, or, like toupper/tolower, can't be declared in the normal
*   place for other reasons.
*   [ANSI]
*
****/

#ifndef _INC_STDLIB

#ifdef __cplusplus
extern "C" {
#endif 

#if (_MSC_VER <= 600)
#define __cdecl     _cdecl
#define __far       _far
#define __near      _near
#define __pascal    _pascal
#endif 

#ifndef _SIZE_T_DEFINED
typedef unsigned int size_t;
#define _SIZE_T_DEFINED
#endif 

#ifndef _WCHAR_T_DEFINED
typedef unsigned short wchar_t;
#define _WCHAR_T_DEFINED
#endif 

/* define NULL pointer value */

#ifndef NULL
#ifdef __cplusplus
#define NULL    0
#else 
#define NULL    ((void *)0)
#endif 
#endif 

/* exit() arg values */

#define EXIT_SUCCESS    0
#define EXIT_FAILURE    1

#ifndef _ONEXIT_T_DEFINED
typedef int (__cdecl * _onexit_t)();
typedef int (__far __cdecl * _fonexit_t)();
#ifndef __STDC__
/* Non-ANSI name for compatibility */
typedef int (__cdecl * onexit_t)();
#endif 
#define _ONEXIT_T_DEFINED
#endif 


/* data structure definitions for div and ldiv runtimes. */

#ifndef _DIV_T_DEFINED

typedef struct _div_t {
    int quot;
    int rem;
} div_t;

typedef struct _ldiv_t {
    long quot;
    long rem;
} ldiv_t;

#define _DIV_T_DEFINED
#endif 

/* maximum value that can be returned by the rand function. */

#define RAND_MAX 0x7fff

extern unsigned short __mb_cur_max; /* mb-len for curr. locale */
#define MB_CUR_MAX __mb_cur_max


/* min and max macros */

#define __max(a,b)  (((a) > (b)) ? (a) : (b))
#define __min(a,b)  (((a) < (b)) ? (a) : (b))


/* sizes for buffers used by the _makepath() and _splitpath() functions.
 * note that the sizes include space for 0-terminator
 */

#define _MAX_PATH   260 /* max. length of full pathname */
#define _MAX_DRIVE  3   /* max. length of drive component */
#define _MAX_DIR    256 /* max. length of path component */
#define _MAX_FNAME  256 /* max. length of file name component */
#define _MAX_EXT    256 /* max. length of extension component */

/* external variable declarations */

#ifdef _MT
extern int __far * __cdecl __far volatile _errno(void);
extern int __far * __cdecl __far __doserrno(void);
#define errno       (*_errno())
#define _doserrno   (*__doserrno())
#else 
extern int __near __cdecl volatile errno;   /* error value */
extern int __near __cdecl _doserrno;        /* OS system error value */
#endif 

extern char * __near __cdecl _sys_errlist[];    /* perror error message table */
extern int __near __cdecl _sys_nerr;        /* # of entries in sys_errlist table */
extern char ** __near __cdecl _environ;     /* pointer to environment table */
extern int __near __cdecl _fmode;       /* default file translation mode */
#ifndef _WINDOWS
extern int __near __cdecl _fileinfo;        /* open file info mode (for spawn) */
#endif 

extern unsigned int __near __cdecl _psp;    /* Program Segment Prefix */

extern char __far * __near __cdecl _pgmptr; /* Pointer to Program name */

/* DOS and Windows major/minor version numbers */

extern unsigned int __near __cdecl _osver;
extern unsigned char __near __cdecl _osmajor;
extern unsigned char __near __cdecl _osminor;
extern unsigned int __near __cdecl _winver;
extern unsigned char __near __cdecl _winmajor;
extern unsigned char __near __cdecl _winminor;

/* OS mode */

#define _DOS_MODE   0   /* DOS */
#define _OS2_MODE   1   /* OS/2 */
#define _WIN_MODE   2   /* Windows */

extern unsigned char __near __cdecl _osmode;

/* CPU mode */

#define _REAL_MODE  0   /* real mode */
#define _PROT_MODE  1   /* protect mode */

extern unsigned char __near __cdecl _cpumode;

/* function prototypes */

#ifdef _MT
double __pascal atof(const char *);
double __pascal strtod(const char *, char * *);
ldiv_t __pascal ldiv(long, long);
#else 
double __cdecl atof(const char *);
double __cdecl strtod(const char *, char * *);
ldiv_t __cdecl ldiv(long, long);
#endif 

void __cdecl abort(void);
int __cdecl abs(int);
int __cdecl atexit(void (__cdecl *)(void));
int __cdecl atoi(const char *);
long __cdecl atol(const char *);
long double __cdecl _atold(const char *);
void * __cdecl bsearch(const void *, const void *,
    size_t, size_t, int (__cdecl *)(const void *,
    const void *));
void * __cdecl calloc(size_t, size_t);
div_t __cdecl div(int, int);
char * __cdecl _ecvt(double, int, int *, int *);
#ifndef _WINDLL
void __cdecl exit(int);
void __cdecl _exit(int);
#endif 
int __far __cdecl _fatexit(void (__cdecl __far *)(void));
char * __cdecl _fcvt(double, int, int *, int *);
_fonexit_t __far __cdecl _fonexit(_fonexit_t);
void __cdecl free(void *);
char * __cdecl _fullpath(char *, const char *,
    size_t);
char * __cdecl _gcvt(double, int, char *);
char * __cdecl getenv(const char *);
char * __cdecl _itoa(int, char *, int);
long __cdecl labs(long);
unsigned long __cdecl _lrotl(unsigned long, int);
unsigned long __cdecl _lrotr(unsigned long, int);
char * __cdecl _ltoa(long, char *, int);
void __cdecl _makepath(char *, const char *,
    const char *, const char *, const char *);
void * __cdecl malloc(size_t);
_onexit_t __cdecl _onexit(_onexit_t);
#ifndef _WINDLL
void __cdecl perror(const char *);
#endif 
int __cdecl _putenv(const char *);
void __cdecl qsort(void *, size_t, size_t, int (__cdecl *)
    (const void *, const void *));
unsigned int __cdecl _rotl(unsigned int, int);
unsigned int __cdecl _rotr(unsigned int, int);
int __cdecl rand(void);
void * __cdecl realloc(void *, size_t);
void __cdecl _searchenv(const char *, const char *,
    char *);
void __cdecl _splitpath(const char *, char *,
    char *, char *, char *);
void __cdecl srand(unsigned int);
long __cdecl strtol(const char *, char * *,
    int);
long double __cdecl _strtold(const char *,
    char * *);
unsigned long __cdecl strtoul(const char *,
    char * *, int);
void __cdecl _swab(char *, char *, int);
#ifndef _WINDOWS
int __cdecl system(const char *);
#endif 
char * __cdecl _ultoa(unsigned long, char *, int);

int __cdecl mblen(const char *, size_t);
int __cdecl mbtowc(wchar_t *, const char *, size_t);
int __cdecl wctomb(char *, wchar_t);
size_t __cdecl mbstowcs(wchar_t *, const char *, size_t);
size_t __cdecl wcstombs(char *, const wchar_t *, size_t);

/* model-independent function prototypes */

int __far __cdecl _fmblen(const char __far *, size_t);
int __far __cdecl _fmbtowc(wchar_t __far *, const char __far *,
    size_t);
int __far __cdecl _fwctomb(char __far *, wchar_t);
size_t __far __cdecl _fmbstowcs(wchar_t __far *, const char __far *,
    size_t);
size_t __far __cdecl _fwcstombs(char __far *, const wchar_t __far *,
    size_t);

#ifndef tolower
int __cdecl tolower(int);
#endif 

#ifndef toupper
int __cdecl toupper(int);
#endif 

#ifndef __STDC__
/* Non-ANSI names for compatibility */

#ifndef __cplusplus
#define max(a,b)    (((a) > (b)) ? (a) : (b))
#define min(a,b)    (((a) < (b)) ? (a) : (b))
#endif 

extern char * __near __cdecl sys_errlist[];
extern int __near __cdecl sys_nerr;
extern char ** __near __cdecl environ;

#define DOS_MODE    _DOS_MODE
#define OS2_MODE    _OS2_MODE

char * __cdecl ecvt(double, int, int *, int *);
char * __cdecl fcvt(double, int, int *, int *);
char * __cdecl gcvt(double, int, char *);
char * __cdecl itoa(int, char *, int);
char * __cdecl ltoa(long, char *, int);
onexit_t __cdecl onexit(onexit_t);
int __cdecl putenv(const char *);
void __cdecl swab(char *, char *, int);
char * __cdecl ultoa(unsigned long, char *, int);

#endif 

#ifdef __cplusplus
}
#endif 

#define _INC_STDLIB
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\tools\c816\inc\time.h ===
/***
*time.h - definitions/declarations for time routines
*
*   Copyright (c) 1985-1992, Microsoft Corporation. All rights reserved.
*
*Purpose:
*   This file contains the various declarations and definitions
*   for the time routines.
*   [ANSI/System V]
*
****/

#ifndef _INC_TIME

#ifdef __cplusplus
extern "C" {
#endif 

#if (_MSC_VER <= 600)
#define __cdecl     _cdecl
#define __far       _far
#define __near      _near
#define __pascal    _pascal
#endif 

/* implementation defined time types */

#ifndef _TIME_T_DEFINED
typedef long    time_t;
#define _TIME_T_DEFINED
#endif 

#ifndef _CLOCK_T_DEFINED
typedef long clock_t;
#define _CLOCK_T_DEFINED
#endif 

#ifndef _SIZE_T_DEFINED
typedef unsigned int size_t;
#define _SIZE_T_DEFINED
#endif 

/* structure for use with localtime(), gmtime(), etc. */

#ifndef _TM_DEFINED
struct tm {
    int tm_sec; /* seconds after the minute - [0,59] */
    int tm_min; /* minutes after the hour - [0,59] */
    int tm_hour;    /* hours since midnight - [0,23] */
    int tm_mday;    /* day of the month - [1,31] */
    int tm_mon; /* months since January - [0,11] */
    int tm_year;    /* years since 1900 */
    int tm_wday;    /* days since Sunday - [0,6] */
    int tm_yday;    /* days since January 1 - [0,365] */
    int tm_isdst;   /* daylight savings time flag */
    };
#define _TM_DEFINED
#endif 


/* define NULL pointer value */

#ifndef NULL
#ifdef __cplusplus
#define NULL    0
#else 
#define NULL    ((void *)0)
#endif 
#endif 


/* clock ticks macro - ANSI version */

#define CLOCKS_PER_SEC  1000


/* extern declarations for the global variables used by the ctime family of
 * routines.
 */

extern int __near __cdecl _daylight;    /* non-zero if daylight savings time is used */
extern long __near __cdecl _timezone;   /* difference in seconds between GMT and local time */
extern char * __near __cdecl _tzname[2];/* standard/daylight savings time zone names */


/* function prototypes */

#ifdef _MT
double __pascal difftime(time_t, time_t);
#else 
double __cdecl difftime(time_t, time_t);
#endif 

char * __cdecl asctime(const struct tm *);
char * __cdecl ctime(const time_t *);
#ifndef _WINDLL
clock_t __cdecl clock(void);
#endif 
struct tm * __cdecl gmtime(const time_t *);
struct tm * __cdecl localtime(const time_t *);
time_t __cdecl mktime(struct tm *);
#ifndef _WINDLL
size_t __cdecl strftime(char *, size_t, const char *,
    const struct tm *);
#endif 
char * __cdecl _strdate(char *);
char * __cdecl _strtime(char *);
time_t __cdecl time(time_t *);
void __cdecl _tzset(void);

#ifndef __STDC__
/* Non-ANSI names for compatibility */

#define CLK_TCK  CLOCKS_PER_SEC

extern int __near __cdecl daylight;
extern long __near __cdecl timezone;
extern char * __near __cdecl tzname[2];

void __cdecl tzset(void);

#endif 

#ifdef __cplusplus
}
#endif 

#define _INC_TIME
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\tools\c816\inc\varargs.h ===
/***
*varargs.h - XENIX style macros for variable argument functions
*
*   Copyright (c) 1985-1992, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*   This file defines XENIX style macros for accessing arguments of a
*   function which takes a variable number of arguments.
*   [System V]
*
****/

#ifdef __cplusplus
extern "C" {
#endif 

#ifdef _WINDLL
#define _FARARG_ __far
#else 
#define _FARARG_
#endif 

#if (_MSC_VER <= 600)
#define __far       _far
#endif 

#ifdef __STDC__
#error varargs.h incompatible with ANSI (use stdarg.h)
#endif 

#ifndef _VA_LIST_DEFINED
typedef char _FARARG_ *va_list;
#define _VA_LIST_DEFINED
#endif 

/*
 * define a macro to compute the size of a type, variable or expression,
 * rounded up to the nearest multiple of sizeof(int). This number is its
 * size as function argument (Intel architecture). Note that the macro
 * depends on sizeof(int) being a power of 2!
 */

#define _INTSIZEOF(n)    ( (sizeof(n) + sizeof(int) - 1) & ~(sizeof(int) - 1) )

#define va_dcl va_list va_alist;
#define va_start(ap) ap = (va_list)&va_alist
#define va_arg(ap,t) ( *(t _FARARG_ *)((ap += _INTSIZEOF(t)) - _INTSIZEOF(t)) )
#define va_end(ap) ap = (va_list)0

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\tools\c816\inc\string.h ===
/***
*string.h - declarations for string manipulation functions
*
*   Copyright (c) 1985-1992, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*   This file contains the function declarations for the string
*   manipulation functions.
*   [ANSI/System V]
*
****/

#ifndef _INC_STRING

#ifdef __cplusplus
extern "C" {
#endif 

#if (_MSC_VER <= 600)
#define __cdecl     _cdecl
#define __far       _far
#define __near      _near
#endif 

#ifndef _SIZE_T_DEFINED
typedef unsigned int size_t;
#define _SIZE_T_DEFINED
#endif 

#ifndef _WCHAR_T_DEFINED
typedef unsigned short wchar_t;
#define _WCHAR_T_DEFINED
#endif 

/* define NULL pointer value */

#ifndef NULL
#ifdef __cplusplus
#define NULL    0
#else 
#define NULL    ((void *)0)
#endif 
#endif 

/* function prototypes */

void * __cdecl _memccpy(void *, const void *,
    int, unsigned int);
void * __cdecl memchr(const void *, int, size_t);
int __cdecl memcmp(const void *, const void *,
    size_t);
int __cdecl _memicmp(const void *, const void *,
    unsigned int);
void * __cdecl memcpy(void *, const void *,
    size_t);
void * __cdecl memmove(void *, const void *,
    size_t);
void * __cdecl memset(void *, int, size_t);
void __cdecl _movedata(unsigned int, unsigned int, unsigned int,
    unsigned int, unsigned int);
char * __cdecl strcat(char *, const char *);
char * __cdecl strchr(const char *, int);
int __cdecl strcmp(const char *, const char *);
int __cdecl _strcmpi(const char *, const char *);
int __cdecl strcoll(const char *, const char *);
int __cdecl _stricmp(const char *, const char *);
char * __cdecl strcpy(char *, const char *);
size_t __cdecl strcspn(const char *, const char *);
char * __cdecl _strdup(const char *);
char * __cdecl _strerror(const char *);
char * __cdecl strerror(int);
size_t __cdecl strlen(const char *);
char * __cdecl _strlwr(char *);
char * __cdecl strncat(char *, const char *,
    size_t);
int __cdecl strncmp(const char *, const char *,
    size_t);
int __cdecl _strnicmp(const char *, const char *,
    size_t);
char * __cdecl strncpy(char *, const char *,
    size_t);
char * __cdecl _strnset(char *, int, size_t);
char * __cdecl strpbrk(const char *,
    const char *);
char * __cdecl strrchr(const char *, int);
char * __cdecl _strrev(char *);
char * __cdecl _strset(char *, int);
size_t __cdecl strspn(const char *, const char *);
char * __cdecl strstr(const char *,
    const char *);
char * __cdecl strtok(char *, const char *);
char * __cdecl _strupr(char *);
size_t __cdecl strxfrm (char *, const char *,
    size_t);


/* model independent function prototypes */

void __far * __far __cdecl _fmemccpy(void __far *, const void __far *,
    int, unsigned int);
void __far * __far __cdecl _fmemchr(const void __far *, int, size_t);
int __far __cdecl _fmemcmp(const void __far *, const void __far *,
    size_t);
void __far * __far __cdecl _fmemcpy(void __far *, const void __far *,
    size_t);
int __far __cdecl _fmemicmp(const void __far *, const void __far *,
    unsigned int);
void __far * __far __cdecl _fmemmove(void __far *, const void __far *,
    size_t);
void __far * __far __cdecl _fmemset(void __far *, int, size_t);
char __far * __far __cdecl _fstrcat(char __far *, const char __far *);
char __far * __far __cdecl _fstrchr(const char __far *, int);
int __far __cdecl _fstrcmp(const char __far *, const char __far *);
int __far __cdecl _fstricmp(const char __far *, const char __far *);
char __far * __far __cdecl _fstrcpy(char __far *, const char __far *);
size_t __far __cdecl _fstrcspn(const char __far *, const char __far *);
char __far * __far __cdecl _fstrdup(const char __far *);
char __near * __far __cdecl _nstrdup(const char __far *);
size_t __far __cdecl _fstrlen(const char __far *);
char __far * __far __cdecl _fstrlwr(char __far *);
char __far * __far __cdecl _fstrncat(char __far *, const char __far *,
    size_t);
int __far __cdecl _fstrncmp(const char __far *, const char __far *,
    size_t);
int __far __cdecl _fstrnicmp(const char __far *, const char __far *,
    size_t);
char __far * __far __cdecl _fstrncpy(char __far *, const char __far *,
    size_t);
char __far * __far __cdecl _fstrnset(char __far *, int, size_t);
char __far * __far __cdecl _fstrpbrk(const char __far *,
    const char __far *);
char __far * __far __cdecl _fstrrchr(const char __far *, int);
char __far * __far __cdecl _fstrrev(char __far *);
char __far * __far __cdecl _fstrset(char __far *, int);
size_t __far __cdecl _fstrspn(const char __far *, const char __far *);
char __far * __far __cdecl _fstrstr(const char __far *,
    const char __far *);
char __far * __far __cdecl _fstrtok(char __far *, const char __far *);
char __far * __far __cdecl _fstrupr(char __far *);


#ifndef __STDC__
/* Non-ANSI names for compatibility */
void * __cdecl memccpy(void *, const void *,
    int, unsigned int);
int __cdecl memicmp(const void *, const void *,
    unsigned int);
void __cdecl movedata(unsigned int, unsigned int, unsigned int,
    unsigned int, unsigned int);
int __cdecl strcmpi(const char *, const char *);
int __cdecl stricmp(const char *, const char *);
char * __cdecl strdup(const char *);
char * __cdecl strlwr(char *);
int __cdecl strnicmp(const char *, const char *,
    size_t);
char * __cdecl strnset(char *, int, size_t);
char * __cdecl strrev(char *);
char * __cdecl strset(char *, int);
char * __cdecl strupr(char *);
#endif 

#ifdef __cplusplus
}
#endif 

#define _INC_STRING
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\tools\c816\inc\ver.h ===
/*****************************************************************************\
*                                                                             *
* ver.h -       Version management functions, types, and definitions          *
*                                                                             *
*               Include file for VER.DLL and VER.LIB.  These libraries are    *
*               designed to allow version stamping of Windows executable files*
*               and of special .VER files for DOS executable files.           *
*                                                                             *
*               The API is unchanged for LIB and DLL versions.                *
*                                                                             *
*               Copyright (c) 1992, Microsoft Corp.  All rights reserved      *
*                                                                             *
*******************************************************************************
*
* #define LIB   - To be used with VER.LIB (default is for VER.DLL)
*
\*****************************************************************************/

#ifndef _INC_VER
#define _INC_VER

#ifndef RC_INVOKED
#pragma pack(1)         /* Assume byte packing throughout */
#endif /* RC_INVOKED */

#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif	/* __cplusplus */

/*
 * If .lib version is being used, declare types used in this file.
 */
#ifdef LIB

#ifndef WINAPI                      /* don't declare if they're already declared */
#define WINAPI      _far _pascal
#define NEAR        _near
#define FAR         _far
#define PASCAL      _pascal
typedef int             BOOL;
#define TRUE        1
#define FALSE       0
typedef unsigned char   BYTE;
typedef unsigned short  WORD;
typedef unsigned int    UINT;
typedef signed long     LONG;
typedef unsigned long   DWORD;
typedef char far*       LPSTR;
typedef const char far* LPCSTR;
typedef int             HFILE;
#define OFSTRUCT    void            /* Not used by the .lib version */
#define LOWORD(l)		((WORD)(l))
#define HIWORD(l)		((WORD)(((DWORD)(l) >> 16) & 0xFFFF))
#define MAKEINTRESOURCE(i)	(LPSTR)((DWORD)((WORD)(i)))
#endif  /* WINAPI */

#else   /* LIB */

/* If .dll version is being used and we're being included with
 * the 3.0 windows.h, #define compatible type aliases.
 * If included with the 3.0 windows.h, #define compatible aliases
 */
#ifndef _INC_WINDOWS
#define UINT        WORD
#define LPCSTR      LPSTR
#define HFILE       int
#endif  /* !_INC_WINDOWS */

#endif  /* !LIB */

/* ----- RC defines ----- */
#ifdef RC_INVOKED
#define ID(id)			id
#else
#define ID(id)			MAKEINTRESOURCE(id)
#endif

/* ----- Symbols ----- */
#define VS_FILE_INFO		ID(16)		/* Version stamp res type */
#define VS_VERSION_INFO		ID(1)  		/* Version stamp res ID */
#define VS_USER_DEFINED		ID(100)		/* User-defined res IDs */

/* ----- VS_VERSION.dwFileFlags ----- */
#define	VS_FFI_SIGNATURE	0xFEEF04BDL
#define	VS_FFI_STRUCVERSION	0x00010000L
#define	VS_FFI_FILEFLAGSMASK	0x0000003FL

/* ----- VS_VERSION.dwFileFlags ----- */
#define	VS_FF_DEBUG		0x00000001L
#define	VS_FF_PRERELEASE	0x00000002L
#define	VS_FF_PATCHED		0x00000004L
#define	VS_FF_PRIVATEBUILD	0x00000008L
#define	VS_FF_INFOINFERRED	0x00000010L
#define	VS_FF_SPECIALBUILD	0x00000020L

/* ----- VS_VERSION.dwFileOS ----- */
#define	VOS_UNKNOWN		0x00000000L
#define	VOS_DOS			0x00010000L
#define	VOS_OS216		0x00020000L
#define	VOS_OS232		0x00030000L
#define	VOS_NT			0x00040000L

#define	VOS__BASE		0x00000000L
#define	VOS__WINDOWS16		0x00000001L
#define	VOS__PM16		0x00000002L
#define	VOS__PM32		0x00000003L
#define	VOS__WINDOWS32		0x00000004L

#define	VOS_DOS_WINDOWS16	0x00010001L
#define	VOS_DOS_WINDOWS32	0x00010004L
#define	VOS_OS216_PM16		0x00020002L
#define	VOS_OS232_PM32		0x00030003L
#define	VOS_NT_WINDOWS32	0x00040004L

/* ----- VS_VERSION.dwFileType ----- */
#define	VFT_UNKNOWN		0x00000000L
#define	VFT_APP			0x00000001L
#define	VFT_DLL			0x00000002L
#define	VFT_DRV			0x00000003L
#define	VFT_FONT		0x00000004L
#define	VFT_VXD			0x00000005L
#define	VFT_STATIC_LIB		0x00000007L

/* ----- VS_VERSION.dwFileSubtype for VFT_WINDOWS_DRV ----- */
#define	VFT2_UNKNOWN		0x00000000L
#define VFT2_DRV_PRINTER	0x00000001L
#define	VFT2_DRV_KEYBOARD	0x00000002L
#define	VFT2_DRV_LANGUAGE	0x00000003L
#define	VFT2_DRV_DISPLAY	0x00000004L
#define	VFT2_DRV_MOUSE		0x00000005L
#define	VFT2_DRV_NETWORK	0x00000006L
#define	VFT2_DRV_SYSTEM		0x00000007L
#define	VFT2_DRV_INSTALLABLE	0x00000008L
#define	VFT2_DRV_SOUND		0x00000009L
#define	VFT2_DRV_COMM		0x0000000AL
#define VFT2_DRV_INPUTMETHOD    0x0000000BL

/* ----- VS_VERSION.dwFileSubtype for VFT_WINDOWS_FONT ----- */
#define VFT2_FONT_RASTER	0x00000001L
#define	VFT2_FONT_VECTOR	0x00000002L
#define	VFT2_FONT_TRUETYPE	0x00000003L

/* ----- VerFindFile() flags ----- */
#define VFFF_ISSHAREDFILE	0x0001

#define VFF_CURNEDEST		0x0001
#define VFF_FILEINUSE		0x0002
#define VFF_BUFFTOOSMALL	0x0004

/* ----- VerInstallFile() flags ----- */
#define VIFF_FORCEINSTALL	0x0001
#define VIFF_DONTDELETEOLD	0x0002

#define VIF_TEMPFILE		0x00000001L
#define VIF_MISMATCH		0x00000002L
#define VIF_SRCOLD		0x00000004L

#define VIF_DIFFLANG		0x00000008L
#define VIF_DIFFCODEPG		0x00000010L
#define VIF_DIFFTYPE		0x00000020L

#define VIF_WRITEPROT		0x00000040L
#define VIF_FILEINUSE		0x00000080L
#define VIF_OUTOFSPACE		0x00000100L
#define VIF_ACCESSVIOLATION	0x00000200L
#define VIF_SHARINGVIOLATION	0x00000400L
#define VIF_CANNOTCREATE	0x00000800L
#define VIF_CANNOTDELETE	0x00001000L
#define VIF_CANNOTRENAME	0x00002000L
#define VIF_CANNOTDELETECUR	0x00004000L
#define VIF_OUTOFMEMORY		0x00008000L

#define VIF_CANNOTREADSRC	0x00010000L
#define VIF_CANNOTREADDST	0x00020000L

#define VIF_BUFFTOOSMALL	0x00040000L

#ifndef RC_INVOKED              /* RC doesn't need to see the rest of this */

/* ----- Types and structures ----- */

typedef signed short int SHORT;

typedef struct tagVS_FIXEDFILEINFO
{
    DWORD   dwSignature;            /* e.g. 0xfeef04bd */
    DWORD   dwStrucVersion;         /* e.g. 0x00000042 = "0.42" */
    DWORD   dwFileVersionMS;        /* e.g. 0x00030075 = "3.75" */
    DWORD   dwFileVersionLS;        /* e.g. 0x00000031 = "0.31" */
    DWORD   dwProductVersionMS;     /* e.g. 0x00030010 = "3.10" */
    DWORD   dwProductVersionLS;     /* e.g. 0x00000031 = "0.31" */
    DWORD   dwFileFlagsMask;        /* = 0x3F for version "0.42" */
    DWORD   dwFileFlags;            /* e.g. VFF_DEBUG | VFF_PRERELEASE */
    DWORD   dwFileOS;               /* e.g. VOS_DOS_WINDOWS16 */
    DWORD   dwFileType;             /* e.g. VFT_DRIVER */
    DWORD   dwFileSubtype;          /* e.g. VFT2_DRV_KEYBOARD */
    DWORD   dwFileDateMS;           /* e.g. 0 */
    DWORD   dwFileDateLS;           /* e.g. 0 */
} VS_FIXEDFILEINFO;

/* ----- Function prototypes ----- */

UINT WINAPI VerFindFile(UINT uFlags, LPCSTR szFileName,
      LPCSTR szWinDir, LPCSTR szAppDir,
      LPSTR szCurDir, UINT FAR* lpuCurDirLen,
      LPSTR szDestDir, UINT FAR* lpuDestDirLen);

DWORD WINAPI VerInstallFile(UINT uFlags,
      LPCSTR szSrcFileName, LPCSTR szDestFileName, LPCSTR szSrcDir,
      LPCSTR szDestDir, LPCSTR szCurDir, LPSTR szTmpFile, UINT FAR* lpuTmpFileLen);

/* Returns size of version info in bytes */
DWORD WINAPI GetFileVersionInfoSize(
      LPCSTR lpstrFilename,     /* Filename of version stamped file */
      DWORD FAR *lpdwHandle);   /* Information for use by GetFileVersionInfo */

/* Read version info into buffer */
BOOL WINAPI GetFileVersionInfo(
      LPCSTR lpstrFilename,     /* Filename of version stamped file */
      DWORD dwHandle,           /* Information from GetFileVersionSize */
      DWORD dwLen,              /* Length of buffer for info */
      void FAR* lpData);        /* Buffer to place the data structure */

/* Returns size of resource in bytes */
DWORD WINAPI GetFileResourceSize(
      LPCSTR lpstrFilename,     /* Filename of version stamped file */
      LPCSTR lpstrResType,      /* Type:  normally VS_FILE_INFO */
      LPCSTR lpstrResID,        /* ID:  normally VS_VERSION_INFO */
      DWORD FAR *lpdwFileOffset); /* Returns file offset of resource */

/* Reads file resource into buffer */
BOOL WINAPI GetFileResource(
      LPCSTR lpstrFilename,     /* Filename of version stamped file */
      LPCSTR lpstrResType,      /* Type:  normally VS_FILE_INFO */
      LPCSTR lpstrResID,        /* ID:  normally VS_VERSION_INFO */
      DWORD dwFileOffset,       /* File offset or NULL */
      DWORD dwResLen,           /* Length of resource to read or NULL */
      void FAR* lpData);        /* Pointer to data buffer */

UINT WINAPI VerLanguageName(UINT wLang, LPSTR szLang, UINT nSize);

UINT WINAPI GetWindowsDir(LPCSTR szAppDir, LPSTR lpBuffer, int nSize);

UINT WINAPI GetSystemDir(LPCSTR szAppDir, LPSTR lpBuffer, int nSize);

BOOL WINAPI VerQueryValue(const void FAR* pBlock, LPCSTR lpSubBlock,
      void FAR* FAR* lplpBuffer, UINT FAR* lpuLen);

#ifdef __cplusplus
}
#endif	/* __cplusplus */

#pragma pack()

#endif  /* !RC_INVOKED */
#endif  /* !_INC_VER */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\tools\c816\inc\wfext.h ===
/*****************************************************************************\
*                                                                             *
* wfext.h -     Windows File Manager Extensions definitions		      *
*                                                                             *
*               Version 3.10                                                  *                   *
*                                                                             *
*               Copyright (c) 1991-1992, Microsoft Corp. All rights reserved. *
*                                                                             *
*******************************************************************************/

#ifndef _INC_WFEXT
#define _INC_WFEXT    /* #defined if wfext.h has been included */

#ifndef RC_INVOKED
#pragma pack(1)         /* Assume byte packing throughout */
#endif  /* RC_INVOKED */

#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif	/* __cplusplus */

#define MENU_TEXT_LEN		40

#define FMMENU_FIRST		1
#define FMMENU_LAST		99

#define FMEVENT_LOAD		100
#define FMEVENT_UNLOAD		101
#define FMEVENT_INITMENU	102
#define FMEVENT_USER_REFRESH	103
#define FMEVENT_SELCHANGE	104

#define FMFOCUS_DIR		1
#define FMFOCUS_TREE		2
#define FMFOCUS_DRIVES		3
#define FMFOCUS_SEARCH		4

#define FM_GETFOCUS		(WM_USER + 0x0200)
#define FM_GETDRIVEINFO		(WM_USER + 0x0201)
#define FM_GETSELCOUNT		(WM_USER + 0x0202)
#define FM_GETSELCOUNTLFN	(WM_USER + 0x0203)	/* LFN versions are odd */
#define FM_GETFILESEL		(WM_USER + 0x0204)
#define FM_GETFILESELLFN	(WM_USER + 0x0205)	/* LFN versions are odd */
#define FM_REFRESH_WINDOWS	(WM_USER + 0x0206)
#define FM_RELOAD_EXTENSIONS	(WM_USER + 0x0207)

typedef struct tagFMS_GETFILESEL
{
        UINT wTime;
        UINT wDate;
	DWORD dwSize;
	BYTE bAttr;
        char szName[260];               /* always fully qualified */
} FMS_GETFILESEL, FAR *LPFMS_GETFILESEL;

typedef struct tagFMS_GETDRIVEINFO       /* for drive */
{
	DWORD dwTotalSpace;
	DWORD dwFreeSpace;
	char szPath[260];		/* current directory */
	char szVolume[14];		/* volume label */
	char szShare[128];		/* if this is a net drive */
} FMS_GETDRIVEINFO, FAR *LPFMS_GETDRIVEINFO;

typedef struct tagFMS_LOAD
{
	DWORD dwSize;				/* for version checks */
	char  szMenuName[MENU_TEXT_LEN];	/* output */
	HMENU hMenu;				/* output */
        UINT  wMenuDelta;                       /* input */
} FMS_LOAD, FAR *LPFMS_LOAD;

typedef DWORD (CALLBACK *FM_EXT_PROC)(HWND, UINT, LONG);
typedef DWORD (CALLBACK *FM_UNDELETE_PROC)(HWND, LPSTR);

#ifndef RC_INVOKED
#pragma pack()          /* Revert to default packing */
#endif  /* RC_INVOKED */

#ifdef __cplusplus
}                       /* End of extern "C" { */
#endif	/* __cplusplus */

#endif  /* _INC_WFEXT */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\tools\c816\inc\sys\stat.h ===
/***
*sys\stat.h - defines structure used by stat() and fstat()
*
*   Copyright (c) 1985-1992, Microsoft Corporation. All rights reserved.
*
*Purpose:
*   This file defines the structure used by the stat() and fstat()
*   routines.
*   [System V]
*
****/

#ifndef _INC_STAT

#ifndef _INC_TYPES
#include <sys/types.h>
#endif 

#ifdef __cplusplus
extern "C" {
#endif 

#if (_MSC_VER <= 600)
#define __cdecl     _cdecl
#define __far       _far
#endif 

#ifndef _TIME_T_DEFINED
typedef long    time_t;
#define _TIME_T_DEFINED
#endif 

/* define structure for returning status information */

#ifndef _STAT_DEFINED
#pragma pack(2)

struct _stat {
    _dev_t st_dev;
    _ino_t st_ino;
    unsigned short st_mode;
    short st_nlink;
    short st_uid;
    short st_gid;
    _dev_t st_rdev;
    _off_t st_size;
    time_t st_atime;
    time_t st_mtime;
    time_t st_ctime;
    };

#ifndef __STDC__
/* Non-ANSI name for compatibility */
struct stat {
    _dev_t st_dev;
    _ino_t st_ino;
    unsigned short st_mode;
    short st_nlink;
    short st_uid;
    short st_gid;
    _dev_t st_rdev;
    _off_t st_size;
    time_t st_atime;
    time_t st_mtime;
    time_t st_ctime;
    };
#endif 

#pragma pack()
#define _STAT_DEFINED
#endif 

#define _S_IFMT     0170000     /* file type mask */
#define _S_IFDIR    0040000     /* directory */
#define _S_IFCHR    0020000     /* character special */
#define _S_IFREG    0100000     /* regular */
#define _S_IREAD    0000400     /* read permission, owner */
#define _S_IWRITE   0000200     /* write permission, owner */
#define _S_IEXEC    0000100     /* execute/search permission, owner */


/* function prototypes */

int __cdecl _fstat(int, struct _stat *);
int __cdecl _stat(const char *, struct _stat *);

#ifndef __STDC__
/* Non-ANSI names for compatibility */

#define S_IFMT   _S_IFMT
#define S_IFDIR  _S_IFDIR
#define S_IFCHR  _S_IFCHR
#define S_IFREG  _S_IFREG
#define S_IREAD  _S_IREAD
#define S_IWRITE _S_IWRITE
#define S_IEXEC  _S_IEXEC

int __cdecl fstat(int, struct stat *);
int __cdecl stat(const char *, struct stat *);

#endif 

#ifdef __cplusplus
}
#endif 

#define _INC_STAT
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\tools\c816\inc\sys\types.h ===
/***
*sys\types.h - types returned by system level calls for file and time info
*
*   Copyright (c) 1985-1992, Microsoft Corporation. All rights reserved.
*
*Purpose:
*   This file defines types used in defining values returned by system
*   level calls for file status and time information.
*   [System V]
*
****/

#ifndef _INC_TYPES

#ifndef _TIME_T_DEFINED
typedef unsigned long time_t;
#define _TIME_T_DEFINED
#endif 

#ifndef _INO_T_DEFINED
typedef unsigned short _ino_t;      /* i-node number (not used on DOS) */
#ifndef __STDC__
/* Non-ANSI name for compatibility */
typedef unsigned short ino_t;
#endif 
#define _INO_T_DEFINED
#endif 

#ifndef _DEV_T_DEFINED
typedef short _dev_t;           /* device code */
#ifndef __STDC__
/* Non-ANSI name for compatibility */
typedef short dev_t;
#endif 
#define _DEV_T_DEFINED
#endif 

#ifndef _OFF_T_DEFINED
typedef long _off_t;            /* file offset value */
#ifndef __STDC__
/* Non-ANSI name for compatibility */
typedef long off_t;
#endif 
#define _OFF_T_DEFINED
#endif 

#define _INC_TYPES
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\tools\c816\inc\vmemory.h ===
/***
* vmemory.h - Virtual Memory (VM) Management Routines
*
*	Copyright (c) 1989-1992, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*	This include file provides prototypes and definitions for
*	the virtual memory management routines.
*
*******************************************************************************/

#ifndef _INC_VMEMORY

#if (_MSC_VER <= 600)
#define __far       _far
#define __pascal    _pascal
#endif

/* virtual memory handle type */
typedef unsigned long _vmhnd_t;

/* null handle value */
#define _VM_NULL	((_vmhnd_t) 0)

/* use all available DOS memory for virtual heap */
#define _VM_ALLDOS	0

/* swap areas */
#define _VM_EMS 	1
#define _VM_XMS 	2
#define _VM_DISK	4
#define _VM_ALLSWAP	(_VM_EMS | _VM_XMS | _VM_DISK)

/* clean/dirty flags */
#define _VM_CLEAN	0
#define _VM_DIRTY	1

/* function prototypes */

#ifdef __cplusplus
extern "C" {
#endif

void __far __pascal _vfree(_vmhnd_t);
int __far __pascal _vheapinit(unsigned int, unsigned int, unsigned int);
void __far __pascal _vheapterm(void);
void __far * __far __pascal _vload(_vmhnd_t, int);
void __far * __far __pascal _vlock(_vmhnd_t);
unsigned int __far __pascal _vlockcnt(_vmhnd_t);
_vmhnd_t __far __pascal _vmalloc(unsigned long);
unsigned long __far __pascal _vmsize(_vmhnd_t);
_vmhnd_t __far __pascal _vrealloc(_vmhnd_t , unsigned long);
void __far __pascal _vunlock(_vmhnd_t, int);

#ifdef __cplusplus
}
#endif

#define _INC_VMEMORY
#endif /* _INC_VMEMORY */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\tools\c816\inc\sys\timeb.h ===
/***
*sys\timeb.h - definition/declarations for ftime()
*
*   Copyright (c) 1985-1992, Microsoft Corporation. All rights reserved.
*
*Purpose:
*   This file define the ftime() function and the types it uses.
*   [System V]
*
****/

#ifndef _INC_TIMEB

#ifdef __cplusplus
extern "C" {
#endif 

#if (_MSC_VER <= 600)
#define __cdecl     _cdecl
#define __far       _far
#endif 

#ifndef _TIME_T_DEFINED
typedef long    time_t;
#define _TIME_T_DEFINED
#endif 

/* structure returned by ftime system call */

#ifndef _TIMEB_DEFINED
#pragma pack(2)

struct _timeb {
    time_t time;
    unsigned short millitm;
    short timezone;
    short dstflag;
    };

#ifndef __STDC__
/* Non-ANSI name for compatibility */
struct timeb {
    time_t time;
    unsigned short millitm;
    short timezone;
    short dstflag;
    };
#endif 

#pragma pack()
#define _TIMEB_DEFINED
#endif 


/* function prototypes */

void __cdecl _ftime(struct _timeb *);

#ifndef __STDC__
/* Non-ANSI name for compatibility */
void __cdecl ftime(struct timeb *);
#endif 

#ifdef __cplusplus
}
#endif 

#define _INC_TIMEB
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\tools\c816\inc\sys\locking.h ===
/***
*sys\locking.h - flags for locking() function
*
*   Copyright (c) 1985-1992, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*   This file defines the flags for the locking() function.
*   [System V]
*
****/

#ifndef _INC_LOCKING

#define _LK_UNLCK   0   /* unlock the file region */
#define _LK_LOCK    1   /* lock the file region */
#define _LK_NBLCK   2   /* non-blocking lock */
#define _LK_RLCK    3   /* lock for writing */
#define _LK_NBRLCK  4   /* non-blocking lock for writing */

#ifndef __STDC__
/* Non-ANSI names for compatibility */
#define LK_UNLCK       _LK_UNLCK
#define LK_LOCK        _LK_LOCK
#define LK_NBLCK       _LK_NBLCK
#define LK_RLCK        _LK_RLCK
#define LK_NBRLCK      _LK_NBRLCK
#endif 

#define _INC_LOCKING
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\tools\c816\inc\sys\utime.h ===
/***
*sys\utime.h - definitions/declarations for utime()
*
*   Copyright (c) 1985-1992, Microsoft Corporation. All rights reserved.
*
*Purpose:
*   This file defines the structure used by the utime routine to set
*   new file access and modification times.  NOTE - MS-DOS
*   does not recognize access time, so this field will
*   always be ignored and the modification time field will be
*   used to set the new time.
*
****/

#ifndef _INC_UTIME

#ifdef __cplusplus
extern "C" {
#endif 

#if (_MSC_VER <= 600)
#define __cdecl     _cdecl
#define __far       _far
#endif 

#ifndef _TIME_T_DEFINED
typedef long    time_t;
#define _TIME_T_DEFINED
#endif 

/* define struct used by utime() function */

#ifndef _UTIMBUF_DEFINED

struct _utimbuf {
    time_t actime;      /* access time */
    time_t modtime;     /* modification time */
    };

#ifndef __STDC__
/* Non-ANSI name for compatibility */
struct utimbuf {
    time_t actime;      /* access time */
    time_t modtime;     /* modification time */
    };
#endif 

#define _UTIMBUF_DEFINED
#endif 


/* function prototypes */

int __cdecl _utime(const char *, struct _utimbuf *);

#ifndef __STDC__
/* Non-ANSI name for compatibility */
int __cdecl utime(const char *, struct utimbuf *);
#endif 

#ifdef __cplusplus
}
#endif 

#define _INC_UTIME
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\tools\c932\inc\assert.h ===
/***
*assert.h - define the assert macro
*
*	Copyright (c) 1985-1994, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	Defines the assert(exp) macro.
*	[ANSI/System V]
*
****/

#ifndef _INC_ASSERT
#define _INC_ASSERT


/* Define _CRTAPI1 (for compatibility with the NT SDK) */

#ifndef _CRTAPI1
#if	( (_MSC_VER >= 800) && (_M_IX86 >= 300) )
#define _CRTAPI1 __cdecl
#else
#define _CRTAPI1
#endif
#endif


/* Define _CRTAPI2 (for compatibility with the NT SDK) */

#ifndef _CRTAPI2
#if	( (_MSC_VER >= 800) && (_M_IX86 >= 300) )
#define _CRTAPI2 __cdecl
#else
#define _CRTAPI2
#endif
#endif


/* Define _CRTIMP */

#ifndef _CRTIMP
#ifdef	_NTSDK
/* definition compatible with NT SDK */
#define _CRTIMP
#else	/* ndef _NTSDK */
/* current definition */
#ifdef	_DLL
#define _CRTIMP __declspec(dllimport)
#else	/* ndef _DLL */
#define _CRTIMP
#endif	/* _DLL */
#endif	/* _NTSDK */
#endif	/* _CRTIMP */


/* Define __cdecl for non-Microsoft compilers */

#if	( !defined(_MSC_VER) && !defined(__cdecl) )
#define __cdecl
#endif


#undef	assert

#ifdef NDEBUG

#define assert(exp)	((void)0)

#else

#ifdef __cplusplus
extern "C" {
#endif

_CRTIMP void __cdecl _assert(void *, void *, unsigned);

#ifdef __cplusplus
}
#endif

#define assert(exp) (void)( (exp) || (_assert(#exp, __FILE__, __LINE__), 0) )

#endif	/* NDEBUG */

#endif	/* _INC_ASSERT */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\tools\c932\inc\commdlg.h ===
/*++

Copyright (c) 1992-1993  Microsoft Corporation

Module Name:

    commdlg.h

Abstract:

    common dialog definitions; #include <windows.h> must be precluded

Revision History:

--*/

#ifndef _INC_COMMDLG
#define _INC_COMMDLG

#ifndef RC_INVOKED
#pragma pack(1)         /* Assume byte packing throughout */
#endif /* !RC_INVOKED */

#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif  /* __cplusplus */

typedef UINT (APIENTRY *LPOFNHOOKPROC) (HWND, UINT, WPARAM, LPARAM);

typedef struct tagOFNA {
   DWORD   lStructSize;
   HWND    hwndOwner;
   HINSTANCE  hInstance;
   LPCSTR   lpstrFilter;
   LPSTR   lpstrCustomFilter;
   DWORD   nMaxCustFilter;
   DWORD   nFilterIndex;
   LPSTR   lpstrFile;
   DWORD   nMaxFile;
   LPSTR   lpstrFileTitle;
   DWORD   nMaxFileTitle;
   LPCSTR   lpstrInitialDir;
   LPCSTR   lpstrTitle;
   DWORD   Flags;
   WORD    nFileOffset;
   WORD    nFileExtension;
   LPCSTR   lpstrDefExt;
   LPARAM   lCustData;
   LPOFNHOOKPROC lpfnHook;
   LPCSTR   lpTemplateName;
} OPENFILENAMEA;

typedef struct tagOFNW {
   DWORD   lStructSize;
   HWND    hwndOwner;
   HINSTANCE  hInstance;
   LPCWSTR  lpstrFilter;
   LPWSTR  lpstrCustomFilter;
   DWORD   nMaxCustFilter;
   DWORD   nFilterIndex;
   LPWSTR  lpstrFile;
   DWORD   nMaxFile;
   LPWSTR  lpstrFileTitle;
   DWORD   nMaxFileTitle;
   LPCWSTR  lpstrInitialDir;
   LPCWSTR  lpstrTitle;
   DWORD   Flags;
   WORD    nFileOffset;
   WORD    nFileExtension;
   LPCWSTR  lpstrDefExt;
   LPARAM   lCustData;
   LPOFNHOOKPROC lpfnHook;
   LPCWSTR   lpTemplateName;
} OPENFILENAMEW;

#ifdef UNICODE
#define OPENFILENAME OPENFILENAMEW
#else
#define OPENFILENAME OPENFILENAMEA
#endif // ! UNICODE

typedef OPENFILENAMEA * LPOPENFILENAMEA;
typedef OPENFILENAMEW * LPOPENFILENAMEW;
typedef OPENFILENAME * LPOPENFILENAME;

BOOL  APIENTRY     GetOpenFileNameA(LPOPENFILENAMEA);
BOOL  APIENTRY     GetOpenFileNameW(LPOPENFILENAMEW);

#ifdef UNICODE
#define GetOpenFileName GetOpenFileNameW
#else
#define GetOpenFileName GetOpenFileNameA
#endif // ! UNICODE

BOOL  APIENTRY     GetSaveFileNameA(LPOPENFILENAMEA);
BOOL  APIENTRY     GetSaveFileNameW(LPOPENFILENAMEW);
#ifdef UNICODE
#define GetSaveFileName GetSaveFileNameW
#else
#define GetSaveFileName GetSaveFileNameA
#endif // ! UNICODE

short APIENTRY     GetFileTitleA(LPCSTR, LPSTR, WORD);
short APIENTRY     GetFileTitleW(LPCWSTR, LPWSTR, WORD);

#ifdef UNICODE
#define GetFileTitle GetFileTitleW
#else
#define GetFileTitle GetFileTitleA
#endif // ! UNICODE

#define OFN_READONLY                 0x00000001
#define OFN_OVERWRITEPROMPT          0x00000002
#define OFN_HIDEREADONLY             0x00000004
#define OFN_NOCHANGEDIR              0x00000008
#define OFN_SHOWHELP                 0x00000010
#define OFN_ENABLEHOOK               0x00000020
#define OFN_ENABLETEMPLATE           0x00000040
#define OFN_ENABLETEMPLATEHANDLE     0x00000080
#define OFN_NOVALIDATE               0x00000100
#define OFN_ALLOWMULTISELECT         0x00000200
#define OFN_EXTENSIONDIFFERENT       0x00000400
#define OFN_PATHMUSTEXIST            0x00000800
#define OFN_FILEMUSTEXIST            0x00001000
#define OFN_CREATEPROMPT             0x00002000
#define OFN_SHAREAWARE               0x00004000
#define OFN_NOREADONLYRETURN         0x00008000
#define OFN_NOTESTFILECREATE         0x00010000
#define OFN_NONETWORKBUTTON          0x00020000
#define OFN_NOLONGNAMES              0x00040000

// Return values for the registered message sent to the hook function
// when a sharing violation occurs.  OFN_SHAREFALLTHROUGH allows the
// filename to be accepted, OFN_SHARENOWARN rejects the name but puts
// up no warning (returned when the app has already put up a warning
// message), and OFN_SHAREWARN puts up the default warning message
// for sharing violations.
//
// Note:  Undefined return values map to OFN_SHAREWARN, but are
//        reserved for future use.

#define OFN_SHAREFALLTHROUGH     2
#define OFN_SHARENOWARN          1
#define OFN_SHAREWARN            0

typedef UINT (APIENTRY *LPCCHOOKPROC) (HWND, UINT, WPARAM, LPARAM);

typedef struct tagCHOOSECOLORA {
   DWORD   lStructSize;
   HWND    hwndOwner;
   HWND    hInstance;
   COLORREF  rgbResult;
   COLORREF* lpCustColors;
   DWORD   Flags;
   LPARAM  lCustData;
   LPCCHOOKPROC lpfnHook;
   LPCSTR   lpTemplateName;
} CHOOSECOLORA;

typedef struct tagCHOOSECOLORW {
   DWORD   lStructSize;
   HWND    hwndOwner;
   HWND    hInstance;
   COLORREF  rgbResult;
   COLORREF* lpCustColors;
   DWORD   Flags;
   LPARAM  lCustData;
   LPCCHOOKPROC lpfnHook;
   LPCWSTR   lpTemplateName;
} CHOOSECOLORW;

#ifdef UNICODE
#define CHOOSECOLOR CHOOSECOLORW
#else
#define CHOOSECOLOR CHOOSECOLORA
#endif // ! UNICODE

typedef CHOOSECOLORA *LPCHOOSECOLORA;
typedef CHOOSECOLORW *LPCHOOSECOLORW;
typedef CHOOSECOLOR *LPCHOOSECOLOR;

BOOL  APIENTRY ChooseColorA(LPCHOOSECOLORA);
BOOL  APIENTRY ChooseColorW(LPCHOOSECOLORW);

#ifdef UNICODE
#define ChooseColor ChooseColorW
#else
#define ChooseColor ChooseColorA
#endif // ! UNICODE

#define CC_RGBINIT               0x00000001
#define CC_FULLOPEN              0x00000002
#define CC_PREVENTFULLOPEN       0x00000004
#define CC_SHOWHELP              0x00000008
#define CC_ENABLEHOOK            0x00000010
#define CC_ENABLETEMPLATE        0x00000020
#define CC_ENABLETEMPLATEHANDLE  0x00000040

typedef UINT (APIENTRY *LPFRHOOKPROC) (HWND, UINT, WPARAM, LPARAM);

typedef struct tagFINDREPLACEA {
   DWORD    lStructSize;        // size of this struct 0x20
   HWND     hwndOwner;          // handle to owner's window
   HINSTANCE hInstance;          // instance handle of.EXE that
                                //   contains cust. dlg. template
   DWORD    Flags;              // one or more of the FR_??
   LPSTR    lpstrFindWhat;      // ptr. to search string
   LPSTR    lpstrReplaceWith;   // ptr. to replace string
   WORD     wFindWhatLen;       // size of find buffer
   WORD     wReplaceWithLen;    // size of replace buffer
   LPARAM   lCustData;          // data passed to hook fn.
   LPFRHOOKPROC lpfnHook;       // ptr. to hook fn. or NULL
   LPCSTR    lpTemplateName;     // custom template name
} FINDREPLACEA;

typedef struct tagFINDREPLACEW {
   DWORD    lStructSize;        // size of this struct 0x20
   HWND     hwndOwner;          // handle to owner's window
   HINSTANCE hInstance;          // instance handle of.EXE that
                                //   contains cust. dlg. template
   DWORD    Flags;              // one or more of the FR_??
   LPWSTR   lpstrFindWhat;      // ptr. to search string
   LPWSTR   lpstrReplaceWith;   // ptr. to replace string
   WORD     wFindWhatLen;       // size of find buffer
   WORD     wReplaceWithLen;    // size of replace buffer
   LPARAM   lCustData;          // data passed to hook fn.
   LPFRHOOKPROC lpfnHook;       // ptr. to hook fn. or NULL
   LPCWSTR   lpTemplateName;     // custom template name
} FINDREPLACEW;

#ifdef UNICODE
#define FINDREPLACE FINDREPLACEW
#else
#define FINDREPLACE FINDREPLACEA
#endif // ! UNICODE

typedef FINDREPLACEA  *LPFINDREPLACEA;
typedef FINDREPLACEW *LPFINDREPLACEW;
typedef FINDREPLACE *LPFINDREPLACE;

#define FR_DOWN                         0x00000001
#define FR_WHOLEWORD                    0x00000002
#define FR_MATCHCASE                    0x00000004
#define FR_FINDNEXT                     0x00000008
#define FR_REPLACE                      0x00000010
#define FR_REPLACEALL                   0x00000020
#define FR_DIALOGTERM                   0x00000040
#define FR_SHOWHELP                     0x00000080
#define FR_ENABLEHOOK                   0x00000100
#define FR_ENABLETEMPLATE               0x00000200
#define FR_NOUPDOWN                     0x00000400
#define FR_NOMATCHCASE                  0x00000800
#define FR_NOWHOLEWORD                  0x00001000
#define FR_ENABLETEMPLATEHANDLE         0x00002000
#define FR_HIDEUPDOWN                   0x00004000
#define FR_HIDEMATCHCASE                0x00008000
#define FR_HIDEWHOLEWORD                0x00010000

HWND  APIENTRY    FindTextA(LPFINDREPLACEA);
HWND  APIENTRY    FindTextW(LPFINDREPLACEW);

#ifdef UNICODE
#define FindText FindTextW
#else
#define FindText FindTextA
#endif // ! UNICODE

HWND  APIENTRY    ReplaceTextA(LPFINDREPLACEA);
HWND  APIENTRY    ReplaceTextW(LPFINDREPLACEW);

#ifdef UNICODE
#define ReplaceText ReplaceTextW
#else
#define ReplaceText ReplaceTextA
#endif // ! UNICODE

typedef UINT (APIENTRY *LPCFHOOKPROC) (HWND, UINT, WPARAM, LPARAM);

typedef struct tagCHOOSEFONTA {
   DWORD           lStructSize;
   HWND            hwndOwner;          // caller's window handle
   HDC             hDC;                // printer DC/IC or NULL
   LPLOGFONTA      lpLogFont;          // ptr. to a LOGFONT struct
   INT             iPointSize;         // 10 * size in points of selected font
   DWORD           Flags;              // enum. type flags
   COLORREF        rgbColors;          // returned text color
   LPARAM          lCustData;          // data passed to hook fn.
   LPCFHOOKPROC    lpfnHook;           // ptr. to hook function
   LPCSTR           lpTemplateName;     // custom template name
   HINSTANCE       hInstance;          // instance handle of.EXE that
                                       //   contains cust. dlg. template
   LPSTR           lpszStyle;          // return the style field here
                                       // must be LF_FACESIZE or bigger
   WORD            nFontType;          // same value reported to the EnumFonts
                                       //   call back with the extra FONTTYPE_
                                       //   bits added
   WORD            ___MISSING_ALIGNMENT__;
   INT             nSizeMin;           // minimum pt size allowed &
   INT             nSizeMax;           // max pt size allowed if
                                       //   CF_LIMITSIZE is used
} CHOOSEFONTA;

typedef struct tagCHOOSEFONTW {
   DWORD           lStructSize;
   HWND            hwndOwner;          // caller's window handle
   HDC             hDC;                // printer DC/IC or NULL
   LPLOGFONTW      lpLogFont;          // ptr. to a LOGFONT struct
   INT             iPointSize;         // 10 * size in points of selected font
   DWORD           Flags;              // enum. type flags
   COLORREF        rgbColors;          // returned text color
   LPARAM          lCustData;          // data passed to hook fn.
   LPCFHOOKPROC lpfnHook;              // ptr. to hook function
   LPCWSTR          lpTemplateName;     // custom template name
   HINSTANCE       hInstance;          // instance handle of.EXE that
                                       // contains cust. dlg. template
   LPWSTR          lpszStyle;          // return the style field here
                                       // must be LF_FACESIZE or bigger
   WORD            nFontType;          // same value reported to the EnumFonts
                                       //   call back with the extra FONTTYPE_
                                       //   bits added
   WORD            ___MISSING_ALIGNMENT__;
   INT             nSizeMin;           // minimum pt size allowed &
   INT             nSizeMax;           // max pt size allowed if
                                       //   CF_LIMITSIZE is used
} CHOOSEFONTW;

#ifdef UNICODE
#define CHOOSEFONT CHOOSEFONTW
#else
#define CHOOSEFONT CHOOSEFONTA
#endif // ! UNICODE

typedef CHOOSEFONTA *LPCHOOSEFONTA;
typedef CHOOSEFONTW *LPCHOOSEFONTW;
typedef CHOOSEFONT *LPCHOOSEFONT;

BOOL APIENTRY ChooseFontA(LPCHOOSEFONTA);
BOOL APIENTRY ChooseFontW(LPCHOOSEFONTW);

#ifdef UNICODE
#define ChooseFont ChooseFontW
#else
#define ChooseFont ChooseFontA
#endif // !UNICODE

#define CF_SCREENFONTS             0x00000001
#define CF_PRINTERFONTS            0x00000002
#define CF_BOTH                    (CF_SCREENFONTS | CF_PRINTERFONTS)
#define CF_SHOWHELP                0x00000004L
#define CF_ENABLEHOOK              0x00000008L
#define CF_ENABLETEMPLATE          0x00000010L
#define CF_ENABLETEMPLATEHANDLE    0x00000020L
#define CF_INITTOLOGFONTSTRUCT     0x00000040L
#define CF_USESTYLE                0x00000080L
#define CF_EFFECTS                 0x00000100L
#define CF_APPLY                   0x00000200L
#define CF_ANSIONLY                0x00000400L
#define CF_NOVECTORFONTS           0x00000800L
#define CF_NOOEMFONTS              CF_NOVECTORFONTS
#define CF_NOSIMULATIONS           0x00001000L
#define CF_LIMITSIZE               0x00002000L
#define CF_FIXEDPITCHONLY          0x00004000L
#define CF_WYSIWYG                 0x00008000L // must also have CF_SCREENFONTS & CF_PRINTERFONTS
#define CF_FORCEFONTEXIST          0x00010000L
#define CF_SCALABLEONLY            0x00020000L
#define CF_TTONLY                  0x00040000L
#define CF_NOFACESEL               0x00080000L
#define CF_NOSTYLESEL              0x00100000L
#define CF_NOSIZESEL               0x00200000L

// these are extra nFontType bits that are added to what is returned to the
// EnumFonts callback routine

#define SIMULATED_FONTTYPE    0x8000
#define PRINTER_FONTTYPE      0x4000
#define SCREEN_FONTTYPE       0x2000
#define BOLD_FONTTYPE         0x0100
#define ITALIC_FONTTYPE       0x0200
#define REGULAR_FONTTYPE      0x0400

#define WM_CHOOSEFONT_GETLOGFONT      (WM_USER + 1)

// strings used to obtain unique window message for communication
// between dialog and caller

#define LBSELCHSTRINGA  "commdlg_LBSelChangedNotify"
#define SHAREVISTRINGA  "commdlg_ShareViolation"
#define FILEOKSTRINGA   "commdlg_FileNameOK"
#define COLOROKSTRINGA  "commdlg_ColorOK"
#define SETRGBSTRINGA   "commdlg_SetRGBColor"
#define HELPMSGSTRINGA  "commdlg_help"
#define FINDMSGSTRINGA  "commdlg_FindReplace"

#define LBSELCHSTRINGW  L"commdlg_LBSelChangedNotify"
#define SHAREVISTRINGW  L"commdlg_ShareViolation"
#define FILEOKSTRINGW   L"commdlg_FileNameOK"
#define COLOROKSTRINGW  L"commdlg_ColorOK"
#define SETRGBSTRINGW   L"commdlg_SetRGBColor"
#define HELPMSGSTRINGW  L"commdlg_help"
#define FINDMSGSTRINGW  L"commdlg_FindReplace"

#ifdef UNICODE
#define LBSELCHSTRING  LBSELCHSTRINGW
#define SHAREVISTRING  SHAREVISTRINGW
#define FILEOKSTRING   FILEOKSTRINGW
#define COLOROKSTRING  COLOROKSTRINGW
#define SETRGBSTRING   SETRGBSTRINGW
#define HELPMSGSTRING  HELPMSGSTRINGW
#define FINDMSGSTRING  FINDMSGSTRINGW
#else
#define LBSELCHSTRING  LBSELCHSTRINGA
#define SHAREVISTRING  SHAREVISTRINGA
#define FILEOKSTRING   FILEOKSTRINGA
#define COLOROKSTRING  COLOROKSTRINGA
#define SETRGBSTRING   SETRGBSTRINGA
#define HELPMSGSTRING  HELPMSGSTRINGA
#define FINDMSGSTRING  FINDMSGSTRINGA
#endif

// HIWORD values for lParam of commdlg_LBSelChangeNotify message
#define CD_LBSELNOITEMS -1
#define CD_LBSELCHANGE   0
#define CD_LBSELSUB      1
#define CD_LBSELADD      2

typedef UINT (APIENTRY *LPPRINTHOOKPROC) (HWND, UINT, WPARAM, LPARAM);
typedef UINT (APIENTRY *LPSETUPHOOKPROC) (HWND, UINT, WPARAM, LPARAM);

typedef struct tagPDA {
   DWORD   lStructSize;
   HWND    hwndOwner;
   HGLOBAL hDevMode;
   HGLOBAL hDevNames;
   HDC     hDC;
   DWORD   Flags;
   WORD    nFromPage;
   WORD    nToPage;
   WORD    nMinPage;
   WORD    nMaxPage;
   WORD    nCopies;
   HINSTANCE hInstance;
   LPARAM  lCustData;
   LPPRINTHOOKPROC lpfnPrintHook;
   LPSETUPHOOKPROC lpfnSetupHook;
   LPCSTR   lpPrintTemplateName;
   LPCSTR   lpSetupTemplateName;
   HGLOBAL  hPrintTemplate;
   HGLOBAL  hSetupTemplate;
} PRINTDLGA;

typedef struct tagPDW {
   DWORD   lStructSize;
   HWND    hwndOwner;
   HGLOBAL hDevMode;
   HGLOBAL  hDevNames;
   HDC     hDC;
   DWORD   Flags;
   WORD    nFromPage;
   WORD    nToPage;
   WORD    nMinPage;
   WORD    nMaxPage;
   WORD    nCopies;
   HINSTANCE hInstance;
   LPARAM  lCustData;
   LPPRINTHOOKPROC lpfnPrintHook;
   LPSETUPHOOKPROC lpfnSetupHook;
   LPCWSTR  lpPrintTemplateName;
   LPCWSTR  lpSetupTemplateName;
   HGLOBAL  hPrintTemplate;
   HGLOBAL  hSetupTemplate;
}  PRINTDLGW;

#ifdef UNICODE
#define PRINTDLG PRINTDLGW
#else
#define PRINTDLG PRINTDLGA
#endif // ! UNICODE

typedef PRINTDLGA * LPPRINTDLGA;
typedef PRINTDLGW * LPPRINTDLGW;
typedef PRINTDLG  * LPPRINTDLG;

BOOL  APIENTRY     PrintDlgA(LPPRINTDLGA);
BOOL  APIENTRY     PrintDlgW(LPPRINTDLGW);

#ifdef UNICODE
#define PrintDlg PrintDlgW
#else
#define PrintDlg PrintDlgA
#endif // ! UNICODE

#define PD_ALLPAGES                  0x00000000
#define PD_SELECTION                 0x00000001
#define PD_PAGENUMS                  0x00000002
#define PD_NOSELECTION               0x00000004
#define PD_NOPAGENUMS                0x00000008
#define PD_COLLATE                   0x00000010
#define PD_PRINTTOFILE               0x00000020
#define PD_PRINTSETUP                0x00000040
#define PD_NOWARNING                 0x00000080
#define PD_RETURNDC                  0x00000100
#define PD_RETURNIC                  0x00000200
#define PD_RETURNDEFAULT             0x00000400
#define PD_SHOWHELP                  0x00000800
#define PD_ENABLEPRINTHOOK           0x00001000
#define PD_ENABLESETUPHOOK           0x00002000
#define PD_ENABLEPRINTTEMPLATE       0x00004000
#define PD_ENABLESETUPTEMPLATE       0x00008000
#define PD_ENABLEPRINTTEMPLATEHANDLE 0x00010000
#define PD_ENABLESETUPTEMPLATEHANDLE 0x00020000
#define PD_USEDEVMODECOPIES          0x00040000
#define PD_DISABLEPRINTTOFILE        0x00080000
#define PD_HIDEPRINTTOFILE           0x00100000
#define PD_NONETWORKBUTTON           0x00200000

typedef struct tagDEVNAMES {
   WORD wDriverOffset;
   WORD wDeviceOffset;
   WORD wOutputOffset;
   WORD wDefault;
} DEVNAMES;

typedef DEVNAMES * LPDEVNAMES;

#define DN_DEFAULTPRN      0x0001

DWORD APIENTRY     CommDlgExtendedError(VOID);

#ifdef __cplusplus
}
#endif  /* __cplusplus */

#ifndef RC_INVOKED
#pragma pack()
#endif  /* !RC_INVOKED */

#endif  /* !_INC_COMMDLG */

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\tools\c932\inc\ctype.h ===
/***
*ctype.h - character conversion macros and ctype macros
*
*	Copyright (c) 1985-1994, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	Defines macros for character classification/conversion.
*	[ANSI/System V]
*
****/

#ifndef _INC_CTYPE
#define _INC_CTYPE

#ifdef __cplusplus
extern "C" {
#endif


/* Define _CRTAPI1 (for compatibility with the NT SDK) */

#ifndef _CRTAPI1
#if	( (_MSC_VER >= 800) && (_M_IX86 >= 300) )
#define _CRTAPI1 __cdecl
#else
#define _CRTAPI1
#endif
#endif


/* Define _CRTAPI2 (for compatibility with the NT SDK) */

#ifndef _CRTAPI2
#if	( (_MSC_VER >= 800) && (_M_IX86 >= 300) )
#define _CRTAPI2 __cdecl
#else
#define _CRTAPI2
#endif
#endif


/* Define _CRTIMP */

#ifndef _CRTIMP
#ifdef	_NTSDK
/* definition compatible with NT SDK */
#define _CRTIMP
#else	/* ndef _NTSDK */
/* current definition */
#ifdef	_DLL
#define _CRTIMP __declspec(dllimport)
#else	/* ndef _DLL */
#define _CRTIMP
#endif	/* _DLL */
#endif	/* _NTSDK */
#endif	/* _CRTIMP */


/* Define __cdecl for non-Microsoft compilers */

#if	( !defined(_MSC_VER) && !defined(__cdecl) )
#define __cdecl
#endif


#ifndef _WCHAR_T_DEFINED
typedef unsigned short wchar_t;
#define _WCHAR_T_DEFINED
#endif

#ifndef _WCTYPE_T_DEFINED
typedef wchar_t wint_t;
typedef wchar_t wctype_t;
#define _WCTYPE_T_DEFINED
#endif

#ifndef WEOF
#define WEOF (wint_t)(0xFFFF)
#endif

/*
 * These declarations allow the user access to the ctype look-up
 * array _ctype defined in ctype.obj by simply including ctype.h
 */
#ifndef _CTYPE_DISABLE_MACROS

#ifdef	_NTSDK

/* Definitions and declarations compatible with the NT SDK */

#ifdef	_DLL

extern unsigned short * _ctype;
#define _pctype     (*_pctype_dll)
extern unsigned short **_pctype_dll;
#define _pwctype    (*_pwctype_dll)
extern unsigned short **_pwctype_dll;

#else	/* _DLL */


extern unsigned short _ctype[];
extern unsigned short *_pctype;
extern wctype_t *_pwctype;

#endif	/* _DLL */

#else	/* ndef _NTSDK */

/* Current declarations */

_CRTIMP extern unsigned short _ctype[];

#if	defined(_DLL) && defined(_M_IX86)

#define _pctype     (*__p__pctype())
_CRTIMP unsigned short ** __cdecl __p__pctype(void);

#define _pwctype    (*__p__pwctype())
_CRTIMP wctype_t ** __cdecl ___p__pwctype(void);

#else	/* !(defined(_DLL) && defined(_M_IX86)) */

_CRTIMP extern unsigned short *_pctype;
_CRTIMP extern wctype_t *_pwctype;

#endif	/* defined(_DLL) && defined(_M_IX86) */

#endif	/* _NTSDK */

#endif	/* _CTYPE_DISABLE_MACROS */

/* set bit masks for the possible character types */

#define _UPPER		0x1	/* upper case letter */
#define _LOWER		0x2	/* lower case letter */
#define _DIGIT		0x4	/* digit[0-9] */
#define _SPACE		0x8	/* tab, carriage return, newline, */
				/* vertical tab or form feed */
#define _PUNCT		0x10	/* punctuation character */
#define _CONTROL	0x20	/* control character */
#define _BLANK		0x40	/* space char */
#define _HEX		0x80	/* hexadecimal digit */

#define _LEADBYTE	0x8000			/* multibyte leadbyte */
#define _ALPHA		(0x0100|_UPPER|_LOWER)	/* alphabetic character */


/* character classification function prototypes */

#ifndef _CTYPE_DEFINED

_CRTIMP int __cdecl _isctype(int, int);

_CRTIMP int __cdecl isalpha(int);
_CRTIMP int __cdecl isupper(int);
_CRTIMP int __cdecl islower(int);
_CRTIMP int __cdecl isdigit(int);
_CRTIMP int __cdecl isxdigit(int);
_CRTIMP int __cdecl isspace(int);
_CRTIMP int __cdecl ispunct(int);
_CRTIMP int __cdecl isalnum(int);
_CRTIMP int __cdecl isprint(int);
_CRTIMP int __cdecl isgraph(int);
_CRTIMP int __cdecl iscntrl(int);
_CRTIMP int __cdecl toupper(int);
_CRTIMP int __cdecl tolower(int);
_CRTIMP int __cdecl _tolower(int);
_CRTIMP int __cdecl _toupper(int);
_CRTIMP int __cdecl __isascii(int);
_CRTIMP int __cdecl __toascii(int);
_CRTIMP int __cdecl __iscsymf(int);
_CRTIMP int __cdecl __iscsym(int);
#define _CTYPE_DEFINED
#endif

#ifndef _WCTYPE_DEFINED

/* wide function prototypes, also declared in wchar.h  */

/* character classification function prototypes */

_CRTIMP int __cdecl iswalpha(wint_t);
_CRTIMP int __cdecl iswupper(wint_t);
_CRTIMP int __cdecl iswlower(wint_t);
_CRTIMP int __cdecl iswdigit(wint_t);
_CRTIMP int __cdecl iswxdigit(wint_t);
_CRTIMP int __cdecl iswspace(wint_t);
_CRTIMP int __cdecl iswpunct(wint_t);
_CRTIMP int __cdecl iswalnum(wint_t);
_CRTIMP int __cdecl iswprint(wint_t);
_CRTIMP int __cdecl iswgraph(wint_t);
_CRTIMP int __cdecl iswcntrl(wint_t);
_CRTIMP int __cdecl iswascii(wint_t);
_CRTIMP int __cdecl isleadbyte(int);

_CRTIMP wchar_t __cdecl towupper(wchar_t);
_CRTIMP wchar_t __cdecl towlower(wchar_t);

_CRTIMP int __cdecl iswctype(wint_t, wctype_t);

/* --------- The following functions are OBSOLETE --------- */
_CRTIMP int __cdecl is_wctype(wint_t, wctype_t);
/*  --------- The preceding functions are OBSOLETE --------- */

#define _WCTYPE_DEFINED
#endif

/* the character classification macro definitions */

#ifndef _CTYPE_DISABLE_MACROS


/*
 * Maximum number of bytes in multi-byte character in the current locale
 * (also defined in stdlib.h).
 */
#ifndef MB_CUR_MAX

#ifdef	_NTSDK

/* definition compatible with NT SDK */
#ifdef	_DLL
#define __mb_cur_max	(*__mb_cur_max_dll)
#define MB_CUR_MAX	(*__mb_cur_max_dll)
extern	unsigned short *__mb_cur_max_dll;
#else	/* ndef _DLL */
#define MB_CUR_MAX __mb_cur_max
extern	unsigned short __mb_cur_max;
#endif	/* _DLL */

#else	/* ndef _NTSDK */

/* current definition */
#if	defined(_DLL) && defined(_M_IX86)
#define MB_CUR_MAX (*__p___mb_cur_max())
_CRTIMP int * __cdecl __p___mb_cur_max(void);
#else	/* !(defined(_DLL) && defined(_M_IX86)) */
#define MB_CUR_MAX __mb_cur_max
_CRTIMP extern int __mb_cur_max;
#endif	/* defined(_DLL) && defined(_M_IX86) */

#endif	/* _NTSDK */

#endif	/* MB_CUR_MAX */

#define isalpha(_c)	(MB_CUR_MAX > 1 ? _isctype(_c,_ALPHA) : _pctype[_c] & _ALPHA)
#define isupper(_c)	(MB_CUR_MAX > 1 ? _isctype(_c,_UPPER) : _pctype[_c] & _UPPER)
#define islower(_c)	(MB_CUR_MAX > 1 ? _isctype(_c,_LOWER) : _pctype[_c] & _LOWER)
#define isdigit(_c)	(MB_CUR_MAX > 1 ? _isctype(_c,_DIGIT) : _pctype[_c] & _DIGIT)
#define isxdigit(_c)	(MB_CUR_MAX > 1 ? _isctype(_c,_HEX)   : _pctype[_c] & _HEX)
#define isspace(_c)	(MB_CUR_MAX > 1 ? _isctype(_c,_SPACE) : _pctype[_c] & _SPACE)
#define ispunct(_c)	(MB_CUR_MAX > 1 ? _isctype(_c,_PUNCT) : _pctype[_c] & _PUNCT)
#define isalnum(_c)	(MB_CUR_MAX > 1 ? _isctype(_c,_ALPHA|_DIGIT) : _pctype[_c] & (_ALPHA|_DIGIT))
#define isprint(_c)	(MB_CUR_MAX > 1 ? _isctype(_c,_BLANK|_PUNCT|_ALPHA|_DIGIT) : _pctype[_c] & (_BLANK|_PUNCT|_ALPHA|_DIGIT))
#define isgraph(_c)	(MB_CUR_MAX > 1 ? _isctype(_c,_PUNCT|_ALPHA|_DIGIT) : _pctype[_c] & (_PUNCT|_ALPHA|_DIGIT))
#define iscntrl(_c)	(MB_CUR_MAX > 1 ? _isctype(_c,_CONTROL) : _pctype[_c] & _CONTROL)


#define _tolower(_c)	( (_c)-'A'+'a' )
#define _toupper(_c)	( (_c)-'a'+'A' )

#define __isascii(_c)	( (unsigned)(_c) < 0x80 )
#define __toascii(_c)	( (_c) & 0x7f )

#define iswalpha(_c)	( iswctype(_c,_ALPHA) )
#define iswupper(_c)	( iswctype(_c,_UPPER) )
#define iswlower(_c)	( iswctype(_c,_LOWER) )
#define iswdigit(_c)	( iswctype(_c,_DIGIT) )
#define iswxdigit(_c)	( iswctype(_c,_HEX) )
#define iswspace(_c)	( iswctype(_c,_SPACE) )
#define iswpunct(_c)	( iswctype(_c,_PUNCT) )
#define iswalnum(_c)	( iswctype(_c,_ALPHA|_DIGIT) )
#define iswprint(_c)	( iswctype(_c,_BLANK|_PUNCT|_ALPHA|_DIGIT) )
#define iswgraph(_c)	( iswctype(_c,_PUNCT|_ALPHA|_DIGIT) )
#define iswcntrl(_c)	( iswctype(_c,_CONTROL) )
#define iswascii(_c)	( (unsigned)(_c) < 0x80 )


#define isleadbyte(_c)	(_pctype[(unsigned char)(_c)] & _LEADBYTE)


/* MS C version 2.0 extended ctype macros */

#define __iscsymf(_c)	(isalpha(_c) || ((_c) == '_'))
#define __iscsym(_c)	(isalnum(_c) || ((_c) == '_'))

#endif /* _CTYPE_DISABLE_MACROS */

#if	!__STDC__

/* Non-ANSI names for compatibility */

#ifdef	_NTSDK

#define isascii __isascii
#define toascii __toascii
#define iscsymf __iscsymf
#define iscsym	__iscsym

#else	/* ndef _NTSDK */

#ifndef _CTYPE_DEFINED
_CRTIMP int __cdecl isascii(int);
_CRTIMP int __cdecl toascii(int);
_CRTIMP int __cdecl iscsymf(int);
_CRTIMP int __cdecl iscsym(int);
#else
#define isascii __isascii
#define toascii __toascii
#define iscsymf __iscsymf
#define iscsym	__iscsym
#endif

#endif	/* _NTSDK */

#endif	/* __STDC__ */

#ifdef __cplusplus
}
#endif


#endif	/* _INC_CTYPE */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\tools\c932\inc\cderr.h ===
#ifndef _CDERR_INCLUDED_
#define _CDERR_INCLUDED_

#define CDERR_DIALOGFAILURE   0xFFFF

#define CDERR_GENERALCODES     0x0000
#define CDERR_STRUCTSIZE       0x0001
#define CDERR_INITIALIZATION   0x0002
#define CDERR_NOTEMPLATE       0x0003
#define CDERR_NOHINSTANCE      0x0004
#define CDERR_LOADSTRFAILURE   0x0005
#define CDERR_FINDRESFAILURE   0x0006
#define CDERR_LOADRESFAILURE   0x0007
#define CDERR_LOCKRESFAILURE   0x0008
#define CDERR_MEMALLOCFAILURE  0x0009
#define CDERR_MEMLOCKFAILURE   0x000A
#define CDERR_NOHOOK           0x000B
#define CDERR_REGISTERMSGFAIL  0x000C

#define PDERR_PRINTERCODES     0x1000
#define PDERR_SETUPFAILURE     0x1001
#define PDERR_PARSEFAILURE     0x1002
#define PDERR_RETDEFFAILURE    0x1003
#define PDERR_LOADDRVFAILURE   0x1004
#define PDERR_GETDEVMODEFAIL   0x1005
#define PDERR_INITFAILURE      0x1006
#define PDERR_NODEVICES        0x1007
#define PDERR_NODEFAULTPRN     0x1008
#define PDERR_DNDMMISMATCH     0x1009
#define PDERR_CREATEICFAILURE  0x100A
#define PDERR_PRINTERNOTFOUND  0x100B
#define PDERR_DEFAULTDIFFERENT 0x100C

#define CFERR_CHOOSEFONTCODES  0x2000
#define CFERR_NOFONTS          0x2001
#define CFERR_MAXLESSTHANMIN   0x2002

#define FNERR_FILENAMECODES    0x3000
#define FNERR_SUBCLASSFAILURE  0x3001
#define FNERR_INVALIDFILENAME  0x3002
#define FNERR_BUFFERTOOSMALL   0x3003

#define FRERR_FINDREPLACECODES 0x4000
#define FRERR_BUFFERLENGTHZERO 0x4001

#define CCERR_CHOOSECOLORCODES 0x5000

#endif // _CDERR_INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\tools\c932\inc\conio.h ===
/***
*conio.h - console and port I/O declarations
*
*	Copyright (c) 1985-1994, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	This include file contains the function declarations for
*	the MS C V2.03 compatible console I/O routines.
*
****/

#ifndef _INC_CONIO
#define _INC_CONIO

#ifdef __cplusplus
extern "C" {
#endif


/* Define _CRTAPI1 (for compatibility with the NT SDK) */

#ifndef _CRTAPI1
#if	( (_MSC_VER >= 800) && (_M_IX86 >= 300) )
#define _CRTAPI1 __cdecl
#else
#define _CRTAPI1
#endif
#endif


/* Define _CRTAPI2 (for compatibility with the NT SDK) */

#ifndef _CRTAPI2
#if	( (_MSC_VER >= 800) && (_M_IX86 >= 300) )
#define _CRTAPI2 __cdecl
#else
#define _CRTAPI2
#endif
#endif


/* Define _CRTIMP */

#ifndef _CRTIMP
#ifdef	_NTSDK
/* definition compatible with NT SDK */
#define _CRTIMP
#else	/* ndef _NTSDK */
/* current definition */
#ifdef	_DLL
#define _CRTIMP __declspec(dllimport)
#else	/* ndef _DLL */
#define _CRTIMP
#endif	/* _DLL */
#endif	/* _NTSDK */
#endif	/* _CRTIMP */


/* Define __cdecl for non-Microsoft compilers */

#if	( !defined(_MSC_VER) && !defined(__cdecl) )
#define __cdecl
#endif


/* Function prototypes */

_CRTIMP char * __cdecl _cgets(char *);
_CRTIMP int __cdecl _cprintf(const char *, ...);
_CRTIMP int __cdecl _cputs(const char *);
_CRTIMP int __cdecl _cscanf(const char *, ...);
_CRTIMP int __cdecl _getch(void);
_CRTIMP int __cdecl _getche(void);
#ifdef	_M_IX86
int __cdecl _inp(unsigned short);
unsigned short __cdecl _inpw(unsigned short);
unsigned long __cdecl _inpd(unsigned short);
#endif	/* _M_IX86 */
_CRTIMP int __cdecl _kbhit(void);
#ifdef	_M_IX86
int __cdecl _outp(unsigned short, int);
unsigned short __cdecl _outpw(unsigned short, unsigned short);
unsigned long __cdecl _outpd(unsigned short, unsigned long);
#endif	/* _M_IX86 */
_CRTIMP int __cdecl _putch(int);
_CRTIMP int __cdecl _ungetch(int);


#if	!__STDC__

/* Non-ANSI names for compatibility */

#ifdef	_NTSDK

#define cgets	_cgets
#define cprintf _cprintf
#define cputs	_cputs
#define cscanf	_cscanf
#define getch	_getch
#define getche	_getche
#define kbhit	_kbhit
#define putch	_putch
#define ungetch _ungetch

#else	/* ndef _NTSDK */

_CRTIMP char * __cdecl cgets(char *);
_CRTIMP int __cdecl cprintf(const char *, ...);
_CRTIMP int __cdecl cputs(const char *);
_CRTIMP int __cdecl cscanf(const char *, ...);
#ifdef	_M_IX86
int __cdecl inp(unsigned short);
unsigned short __cdecl inpw(unsigned short);
#endif	/* _M_IX86 */
_CRTIMP int __cdecl getch(void);
_CRTIMP int __cdecl getche(void);
_CRTIMP int __cdecl kbhit(void);
#ifdef	_M_IX86
int __cdecl outp(unsigned short, int);
unsigned short __cdecl outpw(unsigned short, unsigned short);
#endif	/* _M_IX86 */
_CRTIMP int __cdecl putch(int);
_CRTIMP int __cdecl ungetch(int);

#endif	/* _NTSDK */

#endif	/* __STDC__ */

#ifdef __cplusplus
}
#endif

#endif	/* _INC_CONIO */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\tools\c932\inc\custcntl.h ===
/*****************************************************************************\
*                                                                             *
* custcntl.h -  Custom Control Library header file                            *
*                                                                             *
*               Copyright (c) 1992-1993, Microsoft Corp.  All rights reserved *
*                                                                             *
\*****************************************************************************/

#ifndef _INC_CUSTCNTL
#define _INC_CUSTCNTL

#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif  /* __cplusplus */


/*
 * General size defines.
 */
#define CCHCCCLASS          32          // Max chars in a class name.
#define CCHCCDESC           32          // Max chars in a control description.
#define CCHCCTEXT           256         // Max chars in a text field.


/*
 * CCSTYLE - Custom Control Style structure.  This structure is passed
 * tp the Custom Control Style function when the user wants to edit the
 * styles of the custom control.
 */
typedef struct tagCCSTYLEA {
    DWORD   flStyle;                    // Style of the control.
    DWORD   flExtStyle;                 // Extended style of the control.
    CHAR    szText[CCHCCTEXT];          // Text of the control.
    LANGID  lgid;                       // Language Id of the control's dialog.
    WORD    wReserved1;                 // Reserved value.  Do not change.
} CCSTYLEA, *LPCCSTYLEA;

typedef struct tagCCSTYLEW {
    DWORD   flStyle;                    // Style of the control.
    DWORD   flExtStyle;                 // Extended style of the control.
    WCHAR   szText[CCHCCTEXT];          // Text of the control.
    LANGID  lgid;                       // Language Id of the control's dialog.
    WORD    wReserved1;                 // Reserved value.  Do not change.
} CCSTYLEW, *LPCCSTYLEW;

#ifdef UNICODE
#define CCSTYLE     CCSTYLEW
#define LPCCSTYLE   LPCCSTYLEW
#else
#define CCSTYLE     CCSTYLEA
#define LPCCSTYLE   LPCCSTYLEA
#endif // UNICODE


/*
 * The Style function prototype.  This will be called when the user
 * wants to edit the styles of a custom control.  It should display a
 * dialog to edit the styles, update the styles in the pccs structure,
 * then return TRUE for success.  If an error occurs or the user
 * cancels the dialog, FALSE should be returned.
 */
typedef BOOL (CALLBACK* LPFNCCSTYLEA)(HWND hwndParent,  LPCCSTYLEA pccs);
typedef BOOL (CALLBACK* LPFNCCSTYLEW)(HWND hwndParent,  LPCCSTYLEW pccs);

#ifdef UNICODE
#define LPFNCCSTYLE LPFNCCSTYLEW
#else
#define LPFNCCSTYLE LPFNCCSTYLEA
#endif  // UNICODE


/*
 * The SizeToText function prototype.  This will be called if the user
 * requests that the custom control be sized to fit it's text.  It
 * should use the specified styles, text and font to determine how
 * large the control must be to accommodate the text, then return this
 * value in pixels.  The value of -1 should be returned if an error
 * occurs.
 */
typedef INT (CALLBACK* LPFNCCSIZETOTEXTA)(DWORD flStyle, DWORD flExtStyle,
    HFONT hfont, LPSTR pszText);
typedef INT (CALLBACK* LPFNCCSIZETOTEXTW)(DWORD flStyle, DWORD flExtStyle,
    HFONT hfont, LPWSTR pszText);

#ifdef UNICODE
#define LPFNCCSIZETOTEXT    LPFNCCSIZETOTEXTW
#else
#define LPFNCCSIZETOTEXT    LPFNCCSIZETOTEXTA
#endif  // UNICODE


/*
 * CCSTYLEFLAG - Custom Control Style Flag structure.  A table of these
 * structures is used to specify the define strings that match the
 * different styles for a custom control.
 */
typedef struct tagCCSTYLEFLAGA {
    DWORD flStyle;                      // Style bits for this style.
    DWORD flStyleMask;                  // Mask for the style.  Can be zero.
    LPSTR pszStyle;                     // Points to the style define string.
} CCSTYLEFLAGA, *LPCCSTYLEFLAGA;

typedef struct tagCCSTYLEFLAGW {
    DWORD flStyle;                      // Style bits for this style.
    DWORD flStyleMask;                  // Mask for the style.  Can be zero.
    LPWSTR pszStyle;                    // Points to the style define string.
} CCSTYLEFLAGW, *LPCCSTYLEFLAGW;

#ifdef UNICODE
#define CCSTYLEFLAG     CCSTYLEFLAGW
#define LPCCSTYLEFLAG   LPCCSTYLEFLAGW
#else
#define CCSTYLEFLAG     CCSTYLEFLAGA
#define LPCCSTYLEFLAG   LPCCSTYLEFLAGA
#endif // UNICODE


/*
 * CCF_* defines.  These flags are used for the flOptions field of the
 * CCINFO structure, and describe some basic characteristics of the
 * custom control.
 */
#define CCF_NOTEXT          0x00000001  // Control cannot have text.


/*
 * CCINFO - Custom Control Info structure.  This structure provides
 * the dialog editor with information about the control types that the
 * DLL supports.
 */
typedef struct tagCCINFOA {
    CHAR    szClass[CCHCCCLASS];        // Class name for the control.
    DWORD   flOptions;                  // Option flags (CCF_* defines).
    CHAR    szDesc[CCHCCDESC];          // Short, descriptive text for the ctrl.
    UINT    cxDefault;                  // Default width (in dialog units).
    UINT    cyDefault;                  // Default height (in dialog units).
    DWORD   flStyleDefault;             // Default style (WS_CHILD | WS_VISIBLE).
    DWORD   flExtStyleDefault;          // Default extended style.
    DWORD   flCtrlTypeMask;             // Mask for control type styles.
    CHAR    szTextDefault[CCHCCTEXT];   // Default text.
    INT     cStyleFlags;                // Entries in the following style table.
    LPCCSTYLEFLAGA aStyleFlags;         // Points to style flag table.
    LPFNCCSTYLEA lpfnStyle;             // Pointer to the Styles function.
    LPFNCCSIZETOTEXTA lpfnSizeToText;   // Pointer to the SizeToText function.
    DWORD   dwReserved1;                // Reserved.  Must be zero.
    DWORD   dwReserved2;                // Reserved.  Must be zero.
} CCINFOA, *LPCCINFOA;

typedef struct tagCCINFOW {
    WCHAR   szClass[CCHCCCLASS];        // Class name for the control.
    DWORD   flOptions;                  // Option flags (CCF_* defines).
    WCHAR   szDesc[CCHCCDESC];          // Short, descriptive text for the ctrl.
    UINT    cxDefault;                  // Default width (in dialog units).
    UINT    cyDefault;                  // Default height (in dialog units).
    DWORD   flStyleDefault;             // Default style (WS_CHILD | WS_VISIBLE).
    DWORD   flExtStyleDefault;          // Default extended style.
    DWORD   flCtrlTypeMask;             // Mask for control type styles.
    INT     cStyleFlags;                // Entries in the following style table.
    LPCCSTYLEFLAGW aStyleFlags;         // Points to style flag table.
    WCHAR   szTextDefault[CCHCCTEXT];   // Default text.
    LPFNCCSTYLEW lpfnStyle;             // Pointer to the Styles function.
    LPFNCCSIZETOTEXTW lpfnSizeToText;   // Pointer to the SizeToText function.
    DWORD   dwReserved1;                // Reserved.  Must be zero.
    DWORD   dwReserved2;                // Reserved.  Must be zero.
} CCINFOW, *LPCCINFOW;

#ifdef UNICODE
#define CCINFO      CCINFOW
#define LPCCINFO    LPCCINFOW
#else
#define CCINFO      CCINFOA
#define LPCCINFO    LPCCINFOA
#endif // UNICODE


/*
 * The Info function prototype.  This function is the first one
 * called by the dialog editor.  Custom control DLL's must export
 * one or both of the following functions by name (the ordinal
 * used for the export does not matter):
 *
 *  UINT CALLBACK CustomControlInfoA(LPCCINFOA acci)
 *  UINT CALLBACK CustomControlInfoW(LPCCINFOW acci)
 *
 * This function must return the number of controls that the DLL
 * supports, or NULL if an error occurs.  If the acci parameter is
 * not NULL, it will be pointing to an array of CCINFOA or CCINFOW
 * structures that should be filled in with the information about
 * the different control types supported by the DLL.
 *
 * If both functions are present, the CustomControlInfoW function
 * will be used by the dialog editor.
 */
typedef UINT (CALLBACK* LPFNCCINFOA)(LPCCINFOA acci);
typedef UINT (CALLBACK* LPFNCCINFOW)(LPCCINFOW acci);

#ifdef UNICODE
#define LPFNCCINFO  LPFNCCINFOW
#else
#define LPFNCCINFO  LPFNCCINFOA
#endif  // UNICODE


#ifdef __cplusplus
}
#endif  /* __cplusplus */

#endif  /* _INC_CUSTCNTL */

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\tools\c932\inc\drivinit.h ===
// All items moved to wingdi.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\tools\c932\inc\except.h ===
/***
*except.h - defines exception values, types and routines
*
*	Copyright (c) 1990-1994, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	This file defines the exception values, types and declares the
*	associated functions.
*
****/

#ifndef _INC_EXCEPT

#ifdef __cplusplus
extern "C" {
#endif


#if (_MSC_VER <= 600)
#define __cdecl _cdecl
#endif

/*
 * exception codes defined by the host OS
 *
 * NOTE: THE UNDERSCORE PREFIX IN THE FOLLOWING NAMES WAS ADDED TO CONFORM
 * WITH ANSI NAMESPACE REQUIREMENTS.
 */

#define _XCPT_GUARD_PAGE_VIOLATION		0x80000001
#define _XCPT_UNABLE_TO_GROW_STACK		0x80010001
#define _XCPT_DATATYPE_MISALIGNMENT		0xC000009E
#define _XCPT_BREAKPOINT			0xC000009F
#define _XCPT_SINGLESTEP			0xC00000A0
#define _XCPT_ACCESS_VIOLATION			0xC0000005
#define _XCPT_ILLEGAL_INSTRUCTION		0xC000001C
#define _XCPT_FLOATING_DENORMAL_OPERAND 	0xC0000094
#define _XCPT_FLOATING_DIVIDE_BY_ZERO		0xC0000095
#define _XCPT_FLOATING_INEXACT_RESULT		0xC0000096
#define _XCPT_FLOATING_INVALID_OPERATION	0xC0000097
#define _XCPT_FLOATING_OVERFLOW 		0xC0000098
#define _XCPT_FLOATING_STACK_CHECK		0xC0000099
#define _XCPT_FLOATING_UNDERFLOW		0xC000009A
#define _XCPT_INTEGER_DIVIDE_BY_ZERO		0xC000009B
#define _XCPT_INTEGER_OVERFLOW			0xC000009C
#define _XCPT_PRIVILEGED_INSTRUCTION		0xC000009D
#define _XCPT_IN_PAGE_ERROR			0xC0000006
#define _XCPT_PROCESS_TERMINATE 		0xC0010001
#define _XCPT_ASYNC_PROCESS_TERMINATE		0xC0010002
#define _XCPT_NONCONTINUABLE_EXCEPTION		0xC0000024
#define _XCPT_INVALID_DISPOSITION		0xC0000025
#define _XCPT_INVALID_LOCK_SEQUENCE		0xC000001D
#define _XCPT_ARRAY_BOUNDS_EXCEEDED		0xC0000093
#define _XCPT_B1NPX_ERRATA_02			0xC0010004
#define _XCPT_UNWIND				0xC0000026
#define _XCPT_BAD_STACK 			0xC0000027
#define _XCPT_INVALID_UNWIND_TARGET		0xC0000028
#define _XCPT_SIGNAL				0xC0010003


/*
 * exception codes defined by the C runtime
 */

#define _XCPT_SIGABRT				0x20000001
#define _XCPT_SIGUSR1				0x20000002
#define _XCPT_SIGUSR2				0x20000003
#define _XCPT_SIGUSR3				0x20000004
#define _XCPT_FLOATING_EXPLICITGEN		0x20000005


/*
 * constants, structs and types used in exception handling at the OS level
 *
 * NOTE: MANY OF IDENTIFIERS DEFINED BELOW ARE FROM DCR 1024. HOWEVER, THEY
 * HAVE BEEN CHANGED TO CONFORM WITH ANSI NAMESPACE RESTRICTIONS.
 */

#define _EXCEPTION_MAXIMUM_PARAMETERS	4

struct __EXCEPTIONREPORTRECORD {
	unsigned long ExceptionNum;
	unsigned long fHandlerFlags;
	struct __EXCEPTIONREPORTRECORD * NestedExceptionReportRecord;
	void * ExceptionAddress;
	unsigned long cParameters;
	unsigned long ExceptionInfo[_EXCEPTION_MAXIMUM_PARAMETERS];
};

typedef struct __EXCEPTIONREPORTRECORD _EXCEPTIONREPORTRECORD;
typedef struct __EXCEPTIONREPORTRECORD * _PEXCEPTIONREPORTRECORD;

/*
 * values of ExceptionInfo[0] for _XCPT_SIGNAL.
 */

#define _XCPT_SIGNAL_INTR	 1	/* corresponds to SIGINT */
#define _XCPT_SIGNAL_KILLPROC	 3	/* corresponds to SIGTERM */
#define _XCPT_SIGNAL_BREAK	 4	/* corresponds to SIGBREAK */

/*
 * NOTE: THE FOLLOWING DEFINITION FOR _PCONTEXTRECORD IS INCORRECT, BUT I
 * DON'T ACTUALLY USE IT FOR ANYTHING AND REAL DEFINITION WOULD TAKE A GOOD
 * TWO PAGES. SEE PAGES 16 AND 17 OF VOL1.TXT FOR THE CORRECT DEFINITION.
 */

typedef void * _PCONTEXTRECORD;

/*
 * structure used by SEH support function and intrinsics. the information
 * passed by the exception dispatcher is repackaged in this form by the
 * runtime (_except_handler()).
 */

struct __EXCEPTION_INFO_PTRS {
	_PEXCEPTIONREPORTRECORD preport;
	_PCONTEXTRECORD pcontext;
};

typedef struct __EXCEPTION_INFO_PTRS * _PEXCEPTION_INFO_PTRS;


#ifndef _MAC_
/*
 * prototypes for intrinsic SEH functions
 */

unsigned long __cdecl _exception_code(void);
void * __cdecl _exception_info(void);
int __cdecl _abnormal_termination(void);
#endif	/* ndef _MAC_ */


#ifdef __cplusplus
}
#endif

#define _INC_EXCEPT
#endif	/* _INC_EXCEPT */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\tools\c932\inc\dde.h ===
#ifndef _DDEHEADER_INCLUDED_
#define _DDEHEADER_INCLUDED_

#ifndef _WINDEF_
#include <windef.h>
#endif

#ifdef __cplusplus
extern "C" {
#endif

/* DDE window messages */

#define WM_DDE_FIRST	    0x03E0
#define WM_DDE_INITIATE     (WM_DDE_FIRST)
#define WM_DDE_TERMINATE    (WM_DDE_FIRST+1)
#define WM_DDE_ADVISE	    (WM_DDE_FIRST+2)
#define WM_DDE_UNADVISE     (WM_DDE_FIRST+3)
#define WM_DDE_ACK	        (WM_DDE_FIRST+4)
#define WM_DDE_DATA	        (WM_DDE_FIRST+5)
#define WM_DDE_REQUEST	    (WM_DDE_FIRST+6)
#define WM_DDE_POKE	        (WM_DDE_FIRST+7)
#define WM_DDE_EXECUTE	    (WM_DDE_FIRST+8)
#define WM_DDE_LAST	        (WM_DDE_FIRST+8)

/*----------------------------------------------------------------------------
|       DDEACK structure
|
|	Structure of wStatus (LOWORD(lParam)) in WM_DDE_ACK message
|       sent in response to a WM_DDE_DATA, WM_DDE_REQUEST, WM_DDE_POKE,
|       WM_DDE_ADVISE, or WM_DDE_UNADVISE message.
|
----------------------------------------------------------------------------*/

typedef struct {
        unsigned short bAppReturnCode:8,
                 reserved:6,
                 fBusy:1,
		 fAck:1;
} DDEACK;


/*----------------------------------------------------------------------------
|       DDEADVISE structure
|
|	WM_DDE_ADVISE parameter structure for hOptions (LOWORD(lParam))
|
----------------------------------------------------------------------------*/

typedef struct {
        unsigned short reserved:14,
                 fDeferUpd:1,
		 fAckReq:1;
	short     cfFormat;
} DDEADVISE;


/*----------------------------------------------------------------------------
|       DDEDATA structure
|
|       WM_DDE_DATA parameter structure for hData (LOWORD(lParam)).
|       The actual size of this structure depends on the size of
|       the Value array.
|
----------------------------------------------------------------------------*/

typedef struct {
	unsigned short unused:12,
                 fResponse:1,
                 fRelease:1,
                 reserved:1,
                 fAckReq:1;
	short	 cfFormat;
	BYTE	 Value[1];
} DDEDATA;


/*----------------------------------------------------------------------------
|	DDEPOKE structure
|
|	WM_DDE_POKE parameter structure for hData (LOWORD(lParam)).
|       The actual size of this structure depends on the size of
|       the Value array.
|
----------------------------------------------------------------------------*/

typedef struct {
	unsigned short unused:13,  /* Earlier versions of DDE.H incorrectly */
                             /* 12 unused bits.                       */
		 fRelease:1,
		 fReserved:2;
	short    cfFormat;
	BYTE	 Value[1];  /* This member was named rgb[1] in previous */
                            /* versions of DDE.H                        */

} DDEPOKE;

/*----------------------------------------------------------------------------
The following typedef's were used in previous versions of the Windows SDK.
They are still valid.  The above typedef's define exactly the same structures
as those below.  The above typedef names are recommended, however, as they
are more meaningful.

Note that the DDEPOKE structure typedef'ed in earlier versions of DDE.H did
not correctly define the bit positions.
----------------------------------------------------------------------------*/

typedef struct {
        unsigned short unused:13,
                 fRelease:1,
                 fDeferUpd:1,
		 fAckReq:1;
	short	 cfFormat;
} DDELN;

typedef struct {
	unsigned short unused:12,
                 fAck:1,
                 fRelease:1,
                 fReserved:1,
                 fAckReq:1;
	short	 cfFormat;
	BYTE	 rgb[1];
} DDEUP;


/*
 * DDE SECURITY
 */

BOOL
WINAPI
DdeSetQualityOfService(
    HWND hwndClient,
    CONST SECURITY_QUALITY_OF_SERVICE *pqosNew,
    PSECURITY_QUALITY_OF_SERVICE pqosPrev);

BOOL
WINAPI
ImpersonateDdeClientWindow(
    HWND hWndClient,
    HWND hWndServer);

/*
 * DDE message packing APIs
 */
LONG APIENTRY PackDDElParam(UINT msg, UINT uiLo, UINT uiHi);
BOOL APIENTRY UnpackDDElParam(UINT msg, LONG lParam, PUINT puiLo, PUINT puiHi);
BOOL APIENTRY FreeDDElParam(UINT msg, LONG lParam);
LONG APIENTRY ReuseDDElParam(LONG lParam, UINT msgIn, UINT msgOut, UINT uiLo, UINT uiHi);

#ifdef __cplusplus
}
#endif

#endif // _DDEHEADER_INCLUDED_

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\tools\c932\inc\direct.h ===
/***
*direct.h - function declarations for directory handling/creation
*
*	Copyright (c) 1985-1994, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	This include file contains the function declarations for the library
*	functions related to directory handling and creation.
*
****/

#ifndef _INC_DIRECT
#define _INC_DIRECT

#ifdef __cplusplus
extern "C" {
#endif


/* Define _CRTAPI1 (for compatibility with the NT SDK) */

#ifndef _CRTAPI1
#if	( (_MSC_VER >= 800) && (_M_IX86 >= 300) )
#define _CRTAPI1 __cdecl
#else
#define _CRTAPI1
#endif
#endif


/* Define _CRTAPI2 (for compatibility with the NT SDK) */

#ifndef _CRTAPI2
#if	( (_MSC_VER >= 800) && (_M_IX86 >= 300) )
#define _CRTAPI2 __cdecl
#else
#define _CRTAPI2
#endif
#endif


/* Define _CRTIMP */

#ifndef _CRTIMP
#ifdef	_NTSDK
/* definition compatible with NT SDK */
#define _CRTIMP
#else	/* ndef _NTSDK */
/* current definition */
#ifdef	_DLL
#define _CRTIMP __declspec(dllimport)
#else	/* ndef _DLL */
#define _CRTIMP
#endif	/* _DLL */
#endif	/* _NTSDK */
#endif	/* _CRTIMP */


/* Define __cdecl for non-Microsoft compilers */

#if	( !defined(_MSC_VER) && !defined(__cdecl) )
#define __cdecl
#endif

#ifndef _WCHAR_T_DEFINED
typedef unsigned short wchar_t;
#define _WCHAR_T_DEFINED
#endif

#ifndef _SIZE_T_DEFINED
typedef unsigned int size_t;
#define _SIZE_T_DEFINED
#endif

/* _getdiskfree structure for _getdiskfree() */

#ifndef _DISKFREE_T_DEFINED

struct _diskfree_t {
	unsigned total_clusters;
	unsigned avail_clusters;
	unsigned sectors_per_cluster;
	unsigned bytes_per_sector;
	};

#define _DISKFREE_T_DEFINED
#endif

/* function prototypes */

_CRTIMP int __cdecl _chdir(const char *);
_CRTIMP int __cdecl _chdrive(int);
_CRTIMP char * __cdecl _getcwd(char *, int);
_CRTIMP char * __cdecl _getdcwd(int, char *, int);
_CRTIMP int __cdecl _getdrive(void);
_CRTIMP int __cdecl _mkdir(const char *);
_CRTIMP int __cdecl _rmdir(const char *);
_CRTIMP unsigned __cdecl _getdiskfree(unsigned, struct _diskfree_t *);
_CRTIMP unsigned long __cdecl _getdrives(void);

#ifndef _WDIRECT_DEFINED

/* wide function prototypes, also declared in wchar.h  */

_CRTIMP int __cdecl _wchdir(const wchar_t *);
_CRTIMP wchar_t * __cdecl _wgetcwd(wchar_t *, int);
_CRTIMP wchar_t * __cdecl _wgetdcwd(int, wchar_t *, int);
_CRTIMP int __cdecl _wmkdir(const wchar_t *);
_CRTIMP int __cdecl _wrmdir(const wchar_t *);

#define _WDIRECT_DEFINED
#endif



#if	!__STDC__

/* Non-ANSI names for compatibility */

#ifdef	_NTSDK

#define chdir	_chdir
#define getcwd	_getcwd
#define mkdir	_mkdir
#define rmdir	_rmdir

#else	/* _NTSDK */

_CRTIMP int __cdecl chdir(const char *);
_CRTIMP char * __cdecl getcwd(char *, int);
_CRTIMP int __cdecl mkdir(const char *);
_CRTIMP int __cdecl rmdir(const char *);

#endif	/* _NTSDK */

#define diskfree_t  _diskfree_t

#endif	/* __STDC__ */

#ifdef __cplusplus
}
#endif

#endif	/* _INC_DIRECT */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\tools\c932\inc\ddeml.h ===
/*++ BUILD Version: 0001 // Increment this if a change has global effects --*/

/*****************************************************************************\
*                                                                             *
*  ddeml.h -    DDEML API header file
*                                                                             *
*               Version 3.10                                                  *                   *
*                                                                             *
*               Copyright (c) 1993, Microsoft Corp.  All rights reserved.     *
*                                                                             *
\*****************************************************************************/
#ifndef _INC_DDEMLH
#define _INC_DDEMLH

#ifdef __cplusplus
extern "C" {
#endif /* __cplusplus */

/******** public types ********/

DECLARE_HANDLE(HCONVLIST);
DECLARE_HANDLE(HCONV);
DECLARE_HANDLE(HSZ);
DECLARE_HANDLE(HDDEDATA);

// typedef DWORD           HCONVLIST;
// typedef DWORD           HCONV;
// typedef DWORD           HSZ;
// typedef DWORD           HDDEDATA;
#define EXPENTRY        CALLBACK

/* the following structure is for use with XTYP_WILDCONNECT processing. */

typedef struct tagHSZPAIR {
    HSZ hszSvc;
    HSZ hszTopic;
} HSZPAIR;
typedef HSZPAIR FAR *PHSZPAIR;

/* The following structure is used by DdeConnect() and DdeConnectList() and
   by XTYP_CONNECT and XTYP_WILDCONNECT callbacks. */

typedef struct tagCONVCONTEXT {
    UINT        cb;             /* set to sizeof(CONVCONTEXT) */
    UINT        wFlags;         /* none currently defined. */
    UINT        wCountryID;     /* country code for topic/item strings used. */
    int         iCodePage;      /* codepage used for topic/item strings. */
    DWORD       dwLangID;       /* language ID for topic/item strings. */
    DWORD       dwSecurity;     /* Private security code. */
    SECURITY_QUALITY_OF_SERVICE qos;  /* client side's quality of service */
} CONVCONTEXT;
typedef CONVCONTEXT FAR *PCONVCONTEXT;


/* The following structure is used by DdeQueryConvInfo(): */

typedef struct tagCONVINFO {
    DWORD   cb;            /* sizeof(CONVINFO)  */
    DWORD   hUser;         /* user specified field  */
    HCONV   hConvPartner;  /* hConv on other end or 0 if non-ddemgr partner  */
    HSZ     hszSvcPartner; /* app name of partner if obtainable  */
    HSZ     hszServiceReq; /* AppName requested for connection  */
    HSZ     hszTopic;      /* Topic name for conversation  */
    HSZ     hszItem;       /* transaction item name or NULL if quiescent  */
    UINT    wFmt;          /* transaction format or NULL if quiescent  */
    UINT    wType;         /* XTYP_ for current transaction  */
    UINT    wStatus;       /* ST_ constant for current conversation  */
    UINT    wConvst;       /* XST_ constant for current transaction  */
    UINT    wLastError;    /* last transaction error.  */
    HCONVLIST hConvList;   /* parent hConvList if this conversation is in a list */
    CONVCONTEXT ConvCtxt;  /* conversation context */
    HWND    hwnd;          /* window handle for this conversation */
    HWND    hwndPartner;   /* partner window handle for this conversation */
} CONVINFO;
typedef CONVINFO FAR *PCONVINFO;

/***** conversation states (usState) *****/

#define     XST_NULL              0  /* quiescent states */
#define     XST_INCOMPLETE        1
#define     XST_CONNECTED         2
#define     XST_INIT1             3  /* mid-initiation states */
#define     XST_INIT2             4
#define     XST_REQSENT           5  /* active conversation states */
#define     XST_DATARCVD          6
#define     XST_POKESENT          7
#define     XST_POKEACKRCVD       8
#define     XST_EXECSENT          9
#define     XST_EXECACKRCVD      10
#define     XST_ADVSENT          11
#define     XST_UNADVSENT        12
#define     XST_ADVACKRCVD       13
#define     XST_UNADVACKRCVD     14
#define     XST_ADVDATASENT      15
#define     XST_ADVDATAACKRCVD   16

/* used in LOWORD(dwData1) of XTYP_ADVREQ callbacks... */
#define     CADV_LATEACK         0xFFFF

/***** conversation status bits (fsStatus) *****/

#define     ST_CONNECTED            0x0001
#define     ST_ADVISE               0x0002
#define     ST_ISLOCAL              0x0004
#define     ST_BLOCKED              0x0008
#define     ST_CLIENT               0x0010
#define     ST_TERMINATED           0x0020
#define     ST_INLIST               0x0040
#define     ST_BLOCKNEXT            0x0080
#define     ST_ISSELF               0x0100


/* DDE constants for wStatus field */

#define DDE_FACK                0x8000
#define DDE_FBUSY               0x4000
#define DDE_FDEFERUPD           0x4000
#define DDE_FACKREQ             0x8000
#define DDE_FRELEASE            0x2000
#define DDE_FREQUESTED          0x1000
#define DDE_FAPPSTATUS          0x00ff
#define DDE_FNOTPROCESSED       0x0000

#define DDE_FACKRESERVED        (~(DDE_FACK | DDE_FBUSY | DDE_FAPPSTATUS))
#define DDE_FADVRESERVED        (~(DDE_FACKREQ | DDE_FDEFERUPD))
#define DDE_FDATRESERVED        (~(DDE_FACKREQ | DDE_FRELEASE | DDE_FREQUESTED))
#define DDE_FPOKRESERVED        (~(DDE_FRELEASE))

/***** message filter hook types *****/

#define     MSGF_DDEMGR             0x8001

/***** codepage constants ****/

#define CP_WINANSI      1004    /* default codepage for windows & old DDE convs. */
#define CP_WINUNICODE   1200

/***** transaction types *****/

#define     XTYPF_NOBLOCK            0x0002  /* CBR_BLOCK will not work */
#define     XTYPF_NODATA             0x0004  /* DDE_FDEFERUPD */
#define     XTYPF_ACKREQ             0x0008  /* DDE_FACKREQ */

#define     XCLASS_MASK              0xFC00
#define     XCLASS_BOOL              0x1000
#define     XCLASS_DATA              0x2000
#define     XCLASS_FLAGS             0x4000
#define     XCLASS_NOTIFICATION      0x8000

#define     XTYP_ERROR              (0x0000 | XCLASS_NOTIFICATION | XTYPF_NOBLOCK )
#define     XTYP_ADVDATA            (0x0010 | XCLASS_FLAGS         )
#define     XTYP_ADVREQ             (0x0020 | XCLASS_DATA | XTYPF_NOBLOCK )
#define     XTYP_ADVSTART           (0x0030 | XCLASS_BOOL          )
#define     XTYP_ADVSTOP            (0x0040 | XCLASS_NOTIFICATION)
#define     XTYP_EXECUTE            (0x0050 | XCLASS_FLAGS         )
#define     XTYP_CONNECT            (0x0060 | XCLASS_BOOL | XTYPF_NOBLOCK)
#define     XTYP_CONNECT_CONFIRM    (0x0070 | XCLASS_NOTIFICATION | XTYPF_NOBLOCK)
#define     XTYP_XACT_COMPLETE      (0x0080 | XCLASS_NOTIFICATION  )
#define     XTYP_POKE               (0x0090 | XCLASS_FLAGS         )
#define     XTYP_REGISTER           (0x00A0 | XCLASS_NOTIFICATION | XTYPF_NOBLOCK)
#define     XTYP_REQUEST            (0x00B0 | XCLASS_DATA          )
#define     XTYP_DISCONNECT         (0x00C0 | XCLASS_NOTIFICATION | XTYPF_NOBLOCK)
#define     XTYP_UNREGISTER         (0x00D0 | XCLASS_NOTIFICATION | XTYPF_NOBLOCK)
#define     XTYP_WILDCONNECT        (0x00E0 | XCLASS_DATA | XTYPF_NOBLOCK)

#define     XTYP_MASK                0x00F0
#define     XTYP_SHIFT               4  /* shift to turn XTYP_ into an index */

/***** Timeout constants *****/

#define     TIMEOUT_ASYNC           0xFFFFFFFF

/***** Transaction ID constants *****/

#define     QID_SYNC                0xFFFFFFFF

/****** public strings used in DDE ******/

#define SZDDESYS_TOPIC          "System"
#define SZDDESYS_ITEM_TOPICS    "Topics"
#define SZDDESYS_ITEM_SYSITEMS  "SysItems"
#define SZDDESYS_ITEM_RTNMSG    "ReturnMessage"
#define SZDDESYS_ITEM_STATUS    "Status"
#define SZDDESYS_ITEM_FORMATS   "Formats"
#define SZDDESYS_ITEM_HELP      "Help"
#define SZDDE_ITEM_ITEMLIST     "TopicItemList"


/****** API entry points ******/

typedef HDDEDATA CALLBACK FNCALLBACK(UINT wType, UINT wFmt, HCONV hConv,
        HSZ hsz1, HSZ hsz2, HDDEDATA hData, DWORD dwData1, DWORD dwData2);
typedef HDDEDATA (CALLBACK *PFNCALLBACK)(UINT wType, UINT wFmt, HCONV hConv,
        HSZ hsz1, HSZ hsz2, HDDEDATA hData, DWORD dwData1, DWORD dwData2);

#define     CBR_BLOCK                0xffffffffL

/* DLL registration functions */

UINT WINAPI DdeInitializeA(LPDWORD pidInst, PFNCALLBACK pfnCallback,
        DWORD afCmd, DWORD ulRes);
UINT WINAPI DdeInitializeW(LPDWORD pidInst, PFNCALLBACK pfnCallback,
        DWORD afCmd, DWORD ulRes);
#ifdef UNICODE
#define DdeInitialize  DdeInitializeW
#else
#define DdeInitialize  DdeInitializeA
#endif // !UNICODE

/*
 * Callback filter flags for use with standard apps.
 */

#define     CBF_FAIL_SELFCONNECTIONS     0x00001000
#define     CBF_FAIL_CONNECTIONS         0x00002000
#define     CBF_FAIL_ADVISES             0x00004000
#define     CBF_FAIL_EXECUTES            0x00008000
#define     CBF_FAIL_POKES               0x00010000
#define     CBF_FAIL_REQUESTS            0x00020000
#define     CBF_FAIL_ALLSVRXACTIONS      0x0003f000

#define     CBF_SKIP_CONNECT_CONFIRMS    0x00040000
#define     CBF_SKIP_REGISTRATIONS       0x00080000
#define     CBF_SKIP_UNREGISTRATIONS     0x00100000
#define     CBF_SKIP_DISCONNECTS         0x00200000
#define     CBF_SKIP_ALLNOTIFICATIONS    0x003c0000

/*
 * Application command flags
 */
#define     APPCMD_CLIENTONLY            0x00000010L
#define     APPCMD_FILTERINITS           0x00000020L
#define     APPCMD_MASK                  0x00000FF0L

/*
 * Application classification flags
 */
#define     APPCLASS_STANDARD            0x00000000L
#define     APPCLASS_MASK                0x0000000FL



BOOL WINAPI DdeUninitialize(DWORD idInst);

/*
 * conversation enumeration functions
 */

HCONVLIST WINAPI DdeConnectList(DWORD idInst, HSZ hszService, HSZ hszTopic,
        HCONVLIST hConvList, PCONVCONTEXT pCC);
HCONV WINAPI DdeQueryNextServer(HCONVLIST hConvList, HCONV hConvPrev);
BOOL WINAPI DdeDisconnectList(HCONVLIST hConvList);

/*
 * conversation control functions
 */

HCONV WINAPI DdeConnect(DWORD idInst, HSZ hszService, HSZ hszTopic,
        PCONVCONTEXT pCC);
BOOL WINAPI DdeDisconnect(HCONV hConv);
HCONV WINAPI DdeReconnect(HCONV hConv);
UINT WINAPI DdeQueryConvInfo(HCONV hConv, DWORD idTransaction, PCONVINFO pConvInfo);
BOOL WINAPI DdeSetUserHandle(HCONV hConv, DWORD id, DWORD hUser);
BOOL WINAPI DdeAbandonTransaction(DWORD idInst, HCONV hConv, DWORD idTransaction);


/*
 * app server interface functions
 */

BOOL WINAPI DdePostAdvise(DWORD idInst, HSZ hszTopic, HSZ hszItem);
BOOL WINAPI DdeEnableCallback(DWORD idInst, HCONV hConv, UINT wCmd);
BOOL WINAPI DdeImpersonateClient(HCONV hConv);

#define EC_ENABLEALL            0
#define EC_ENABLEONE            ST_BLOCKNEXT
#define EC_DISABLE              ST_BLOCKED
#define EC_QUERYWAITING         2


HDDEDATA WINAPI DdeNameService(DWORD idInst, HSZ hsz1, HSZ hsz2, UINT afCmd);

#define DNS_REGISTER        0x0001
#define DNS_UNREGISTER      0x0002
#define DNS_FILTERON        0x0004
#define DNS_FILTEROFF       0x0008

/*
 * app client interface functions
 */

HDDEDATA WINAPI DdeClientTransaction(LPVOID pData, DWORD cbData,
        HCONV hConv, HSZ hszItem, UINT wFmt, UINT wType,
        DWORD dwTimeout, LPDWORD pdwResult);

/*
 *data transfer functions
 */

HDDEDATA WINAPI DdeCreateDataHandle(DWORD idInst, LPVOID pSrc, DWORD cb,
        DWORD cbOff, HSZ hszItem, UINT wFmt, UINT afCmd);
HDDEDATA WINAPI DdeAddData(HDDEDATA hData, LPVOID pSrc, DWORD cb, DWORD cbOff);
DWORD WINAPI DdeGetData(HDDEDATA hData, LPVOID pDst, DWORD cbMax, DWORD cbOff);
LPBYTE WINAPI DdeAccessData(HDDEDATA hData, LPDWORD pcbDataSize);
BOOL WINAPI DdeUnaccessData(HDDEDATA hData);
BOOL WINAPI DdeFreeDataHandle(HDDEDATA hData);

#define     HDATA_APPOWNED          0x0001


UINT WINAPI DdeGetLastError(DWORD idInst);

#define     DMLERR_NO_ERROR                    0       /* must be 0 */

#define     DMLERR_FIRST                       0x4000

#define     DMLERR_ADVACKTIMEOUT               0x4000
#define     DMLERR_BUSY                        0x4001
#define     DMLERR_DATAACKTIMEOUT              0x4002
#define     DMLERR_DLL_NOT_INITIALIZED         0x4003
#define     DMLERR_DLL_USAGE                   0x4004
#define     DMLERR_EXECACKTIMEOUT              0x4005
#define     DMLERR_INVALIDPARAMETER            0x4006
#define     DMLERR_LOW_MEMORY                  0x4007
#define     DMLERR_MEMORY_ERROR                0x4008
#define     DMLERR_NOTPROCESSED                0x4009
#define     DMLERR_NO_CONV_ESTABLISHED         0x400a
#define     DMLERR_POKEACKTIMEOUT              0x400b
#define     DMLERR_POSTMSG_FAILED              0x400c
#define     DMLERR_REENTRANCY                  0x400d
#define     DMLERR_SERVER_DIED                 0x400e
#define     DMLERR_SYS_ERROR                   0x400f
#define     DMLERR_UNADVACKTIMEOUT             0x4010
#define     DMLERR_UNFOUND_QUEUE_ID            0x4011

#define     DMLERR_LAST                        0x4011

HSZ  WINAPI DdeCreateStringHandleA(DWORD idInst, LPCSTR psz, int iCodePage);
HSZ  WINAPI DdeCreateStringHandleW(DWORD idInst, LPWSTR psz, int iCodePage);
#ifdef UNICODE
#define DdeCreateStringHandle  DdeCreateStringHandleW
#else
#define DdeCreateStringHandle  DdeCreateStringHandleA
#endif // !UNICODE
DWORD WINAPI DdeQueryStringA(DWORD idInst, HSZ hsz, LPSTR psz, DWORD cchMax, int iCodePage);
DWORD WINAPI DdeQueryStringW(DWORD idInst, HSZ hsz, LPWSTR psz, DWORD cchMax, int iCodePage);
#ifdef UNICODE
#define DdeQueryString  DdeQueryStringW
#else
#define DdeQueryString  DdeQueryStringA
#endif // !UNICODE
BOOL WINAPI DdeFreeStringHandle(DWORD idInst, HSZ hsz);
BOOL WINAPI DdeKeepStringHandle(DWORD idInst, HSZ hsz);
int WINAPI DdeCmpStringHandles(HSZ hsz1, HSZ hsz2);


#ifndef NODDEMLSPY
/*
 * DDEML public debugging header file info
 */

typedef struct tagDDEML_MSG_HOOK_DATA {    // new for NT
    UINT uiLo;      // unpacked lo and hi parts of lParam
    UINT uiHi;
    DWORD cbData;   // amount of data in message, if any. May be > than 32 bytes.
    DWORD Data[8];  // data peeking by DDESPY is limited to 32 bytes.
} DDEML_MSG_HOOK_DATA, *PDDEML_MSG_HOOK_DATA;


typedef struct tagMONMSGSTRUCT {
    UINT    cb;
    HWND    hwndTo;
    DWORD   dwTime;
    HANDLE  hTask;
    UINT    wMsg;
    WPARAM  wParam;
    LPARAM  lParam;
    DDEML_MSG_HOOK_DATA dmhd;       // new for NT
} MONMSGSTRUCT;

typedef struct tagMONCBSTRUCT {
    UINT   cb;
    DWORD  dwTime;
    HANDLE hTask;
    DWORD  dwRet;
    UINT   wType;
    UINT   wFmt;
    HCONV  hConv;
    HSZ    hsz1;
    HSZ    hsz2;
    HDDEDATA hData;
    DWORD  dwData1;
    DWORD  dwData2;
    CONVCONTEXT cc;                 // new for NT for XTYP_CONNECT callbacks
    DWORD  cbData;                  // new for NT for data peeking
    DWORD  Data[8];                 // new for NT for data peeking
} MONCBSTRUCT;

typedef struct tagMONHSZSTRUCT {
    UINT   cb;
    BOOL   fsAction;    /* MH_ value */
    DWORD  dwTime;
    HSZ    hsz;
    HANDLE hTask;
    char   str[1];
} MONHSZSTRUCT;

#define MH_CREATE   1
#define MH_KEEP     2
#define MH_DELETE   3
#define MH_CLEANUP  4

typedef struct tagMONERRSTRUCT {
    UINT    cb;
    UINT    wLastError;
    DWORD   dwTime;
    HANDLE  hTask;
} MONERRSTRUCT;

typedef struct tagMONLINKSTRUCT {
    UINT    cb;
    DWORD   dwTime;
    HANDLE  hTask;
    BOOL    fEstablished;
    BOOL    fNoData;
    HSZ     hszSvc;
    HSZ     hszTopic;
    HSZ     hszItem;
    UINT    wFmt;
    BOOL    fServer;
    HCONV   hConvServer;
    HCONV   hConvClient;
} MONLINKSTRUCT;

typedef struct tagMONCONVSTRUCT {
    UINT    cb;
    BOOL    fConnect;
    DWORD   dwTime;
    HANDLE  hTask;
    HSZ     hszSvc;
    HSZ     hszTopic;
    HCONV   hConvClient;        // Globally unique value != apps local hConv
    HCONV   hConvServer;        // Globally unique value != apps local hConv
} MONCONVSTRUCT;

#define     MAX_MONITORS            4
#define     APPCLASS_MONITOR        0x00000001L
#define     XTYP_MONITOR            (0x00F0 | XCLASS_NOTIFICATION | XTYPF_NOBLOCK)

/*
 * Callback filter flags for use with MONITOR apps - 0 implies no monitor
 * callbacks.
 */
#define     MF_HSZ_INFO                  0x01000000
#define     MF_SENDMSGS                  0x02000000
#define     MF_POSTMSGS                  0x04000000
#define     MF_CALLBACKS                 0x08000000
#define     MF_ERRORS                    0x10000000
#define     MF_LINKS                     0x20000000
#define     MF_CONV                      0x40000000

#define     MF_MASK                      0xFF000000
#endif /* NODDEMLSPY */

#ifdef __cplusplus
}
#endif  /* __cplusplus */

#endif /* _INC_DDEMLH */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\tools\c932\inc\dlcapi.h ===
/*++

Copyright (c) 1991-1993  Microsoft Corporation

Module Name:

    dlcapi.h

Abstract:

    This module defines 32-bit Windows/NT DLC structures and manifests

Revision History:

--*/

#ifndef _DLCAPI_
#define _DLCAPI_

#ifdef __cplusplus
extern "C" {
#endif

//
// DLC Command Codes
//

#define LLC_DIR_INTERRUPT               0x00
#define LLC_DIR_OPEN_ADAPTER            0x03
#define LLC_DIR_CLOSE_ADAPTER           0x04
#define LLC_DIR_SET_MULTICAST_ADDRESS   0x05
#define LLC_DIR_SET_GROUP_ADDRESS       0x06
#define LLC_DIR_SET_FUNCTIONAL_ADDRESS  0x07
#define LLC_DIR_READ_LOG                0x08
#define LLC_TRANSMIT_FRAMES             0x09
#define LLC_TRANSMIT_DIR_FRAME          0x0A
#define LLC_TRANSMIT_I_FRAME            0x0B
#define LLC_TRANSMIT_UI_FRAME           0x0D
#define LLC_TRANSMIT_XID_CMD            0x0E
#define LLC_TRANSMIT_XID_RESP_FINAL     0x0F
#define LLC_TRANSMIT_XID_RESP_NOT_FINAL 0x10
#define LLC_TRANSMIT_TEST_CMD           0x11
#define LLC_DLC_RESET                   0x14
#define LLC_DLC_OPEN_SAP                0x15
#define LLC_DLC_CLOSE_SAP               0x16
#define LLC_DLC_REALLOCATE_STATIONS     0x17
#define LLC_DLC_OPEN_STATION            0x19
#define LLC_DLC_CLOSE_STATION           0x1A
#define LLC_DLC_CONNECT_STATION         0x1B
#define LLC_DLC_MODIFY                  0x1C
#define LLC_DLC_FLOW_CONTROL            0x1D
#define LLC_DLC_STATISTICS              0x1E
#define LLC_DIR_INITIALIZE              0x20
#define LLC_DIR_STATUS                  0x21
#define LLC_DIR_TIMER_SET               0x22
#define LLC_DIR_TIMER_CANCEL            0x23
#define LLC_BUFFER_GET                  0x26
#define LLC_BUFFER_FREE                 0x27
#define LLC_RECEIVE                     0x28
#define LLC_RECEIVE_CANCEL              0x29
#define LLC_RECEIVE_MODIFY              0x2A
#define LLC_DIR_TIMER_CANCEL_GROUP      0x2C
#define LLC_DIR_SET_EXCEPTION_FLAGS     0x2D
#define LLC_BUFFER_CREATE               0x30
#define LLC_READ                        0x31
#define LLC_READ_CANCEL                 0x32
#define LLC_DLC_SET_THRESHOLD           0x33
#define LLC_DIR_CLOSE_DIRECT            0x34
#define LLC_DIR_OPEN_DIRECT             0x35
#define LLC_MAX_DLC_COMMAND             0x37

//
// forward definitions
//

union _LLC_PARMS;
typedef union _LLC_PARMS LLC_PARMS, *PLLC_PARMS;

//
// Parameters. Can be pointer to a parameter table (32-bit flat address),
// a single 32-bit ULONG, 2 16-bit USHORTs or 4 8-bit BYTEs
//

typedef union {

    PLLC_PARMS pParameterTable;     // pointer to the parameter table

    struct {
        USHORT usStationId;         // Station id
        USHORT usParameter;         // optional parameter
    } dlc;

    struct {
        USHORT usParameter0;        // first optional parameter
        USHORT usParameter1;        // second optional parameter
    } dir;

    UCHAR auchBuffer[4];            // group/functional address

    ULONG ulParameter;

} CCB_PARMS;

//
// LLC_CCB - the Command Control Block structure
//

typedef struct _LLC_CCB {
    UCHAR uchAdapterNumber;         // Adapter 0 or 1
    UCHAR uchDlcCommand;            // DLC command
    UCHAR uchDlcStatus;             // DLC command completion code
    UCHAR uchReserved1;             // reserved for DLC DLL
    struct _LLC_CCB* pNext;         // CCB chain
    ULONG ulCompletionFlag;         // used in command completion
    CCB_PARMS u;                    // parameters
    HANDLE hCompletionEvent;        // event for command completion
    UCHAR uchReserved2;             // reserved for DLC DLL
    UCHAR uchReadFlag;              // set when special READ CCB chained
    USHORT usReserved3;             // reserved for DLC DLL
} LLC_CCB, *PLLC_CCB;

//
// transmit/receive buffers
//

union _LLC_BUFFER;
typedef union _LLC_BUFFER LLC_BUFFER, *PLLC_BUFFER;

typedef struct {
    PLLC_BUFFER pNextBuffer;        // next DLC buffer in frame
    USHORT cbFrame;                 // length of the whole received frame
    USHORT cbBuffer;                // length of this segment
    USHORT offUserData;             // offset of data from descriptor header
    USHORT cbUserData;              // length of the data
} LLC_NEXT_BUFFER;

typedef struct {
    PLLC_BUFFER pNextBuffer;        // next buffer of frame
    USHORT cbFrame;                 // length of entire frame
    USHORT cbBuffer;                // length of this buffer
    USHORT offUserData;             // user data in this struct
    USHORT cbUserData;              // length of user data
    USHORT usStationId;             // ssnn station id
    UCHAR uchOptions;               // option byte from RECEIVE param tbl
    UCHAR uchMsgType;               // the message type
    USHORT cBuffersLeft;            // number of basic buffer units left
    UCHAR uchRcvFS;                 // the reveived frame status
    UCHAR uchAdapterNumber;         // adapter number
    PLLC_BUFFER pNextFrame;         // pointer to next frame
    UCHAR cbLanHeader;              // length of the lan header
    UCHAR cbDlcHeader;              // length of the DLC header
    UCHAR auchLanHeader[32];        // lan header of the received frame
    UCHAR auchDlcHeader[4];         // dlc header of the received frame
    USHORT usPadding;               // data begins from offset 64 !!!
} LLC_NOT_CONTIGUOUS_BUFFER;

typedef struct {
    PLLC_BUFFER pNextBuffer;        // next buffer of frame
    USHORT cbFrame;                 // length of entire frame
    USHORT cbBuffer;                // length of this buffer
    USHORT offUserData;             // user data in this struct
    USHORT cbUserData;              // length of user data
    USHORT usStationId;             // ssnn station id
    UCHAR uchOptions;               // option byte from RECEIVE param tbl
    UCHAR uchMsgType;               // the message type
    USHORT cBuffersLeft;            // number of basic buffer units left
    UCHAR uchRcvFS;                 // the reveived frame status
    UCHAR uchAdapterNumber;         // adapter number
    PLLC_BUFFER pNextFrame;         // pointer to next frame
} LLC_CONTIGUOUS_BUFFER;

//
// Received frames are returned in these data structures
//

union _LLC_BUFFER {

    PLLC_BUFFER pNext;

    LLC_NEXT_BUFFER Next;

    struct LlcNextBuffer {
        LLC_NEXT_BUFFER Header;
        UCHAR auchData[];
    } Buffer;

    LLC_NOT_CONTIGUOUS_BUFFER NotContiguous;

    struct {
        LLC_NOT_CONTIGUOUS_BUFFER Header;
        UCHAR auchData[];
    } NotCont;

    LLC_CONTIGUOUS_BUFFER Contiguous;

    struct {
        LLC_CONTIGUOUS_BUFFER Header;
        UCHAR auchData[];
    } Cont;

};

//
// This structure is used by BUFFER.GET, BUFFER.FREE and TRANSMIT
//

struct _LLC_XMIT_BUFFER;
typedef struct _LLC_XMIT_BUFFER LLC_XMIT_BUFFER, *PLLC_XMIT_BUFFER;

struct _LLC_XMIT_BUFFER {
    PLLC_XMIT_BUFFER pNext;         // next buffer (or NULL)
    USHORT usReserved1;             //
    USHORT cbBuffer;                // length of transmitted data
    USHORT usReserved2;             //
    USHORT cbUserData;              // length of optional header
    UCHAR auchData[];               // optional header and transmitted data
};

#define LLC_XMIT_BUFFER_SIZE sizeof(LLC_XMIT_BUFFER)

//
// CCB parameter tables
//

typedef struct {
    HANDLE hBufferPool;             // handle of new buffer pool
    PVOID pBuffer;                  // any buffer in memory
    ULONG cbBufferSize;             // buffer size in bytes
    ULONG cbMinimumSizeThreshold;   // minimum locked size
} LLC_BUFFER_CREATE_PARMS, *PLLC_BUFFER_CREATE_PARMS;

typedef struct {
    USHORT usReserved1;             // Station id is not used
    USHORT cBuffersLeft;            // free 256 buffer segments
    ULONG ulReserved;
    PLLC_XMIT_BUFFER pFirstBuffer;  // buffer chain
} LLC_BUFFER_FREE_PARMS, *PLLC_BUFFER_FREE_PARMS;

typedef struct {
    USHORT usReserved1;             // Station id is not used
    USHORT cBuffersLeft;            // free 256 buffer segments

    //
    // cBuffersToGet: number of buffers to get. If 0, the returned buffer list
    // may consist of segment of different size
    //

    USHORT cBuffersToGet;

    //
    // cbBufferSize: size of the requested buffers. This will be rounded up to
    // the next largest segment size: 256, 512, 1024, 2048 or 4096
    //

    USHORT cbBufferSize;
    PLLC_XMIT_BUFFER pFirstBuffer;
} LLC_BUFFER_GET_PARMS, *PLLC_BUFFER_GET_PARMS;

//
// parameter table for DLC.CONNECT.STATION
//

typedef struct {
    USHORT usStationId;             // SAP or direct station ID, defines the pool
    USHORT usReserved;
    PUCHAR pRoutingInfo;            // offset to the routing info
} LLC_DLC_CONNECT_PARMS, *PLLC_DLC_CONNECT_PARMS;

//
// DLC_FLOW_CONTROL Options:
//

#define LLC_RESET_LOCAL_BUSY_USER   0x80
#define LLC_RESET_LOCAL_BUSY_BUFFER 0xC0
#define LLC_SET_LOCAL_BUSY_USER     0

typedef struct {
    USHORT usRes;
    USHORT usStationId;             // SAP or link station id
    UCHAR uchT1;                    // response timer
    UCHAR uchT2;                    // aknowledgment timer
    UCHAR uchTi;                    // inactivity timer
    UCHAR uchMaxOut;                // max transmits without ack
    UCHAR uchMaxIn;                 // max receives without ack
    UCHAR uchMaxOutIncr;            // dynamic window increment value
    UCHAR uchMaxRetryCnt;           // N2 value (retries)
    UCHAR uchReserved1;
    USHORT usMaxInfoFieldLength;    // Only for link stations, NEW!!!
    UCHAR uchAccessPriority;        // token ring access priority
    UCHAR auchReserved3[4];
    UCHAR cGroupCount;              // number of group SAPs of this SAP
    PUCHAR pGroupList;              // offset to the group list
} LLC_DLC_MODIFY_PARMS, *PLLC_DLC_MODIFY_PARMS;

#define LLC_XID_HANDLING_IN_APPLICATION 0x08
#define LLC_XID_HANDLING_IN_DLC         0
#define LLC_INDIVIDUAL_SAP              0x04
#define LLC_GROUP_SAP                   0x02
#define LLC_MEMBER_OF_GROUP_SAP         0x01

typedef struct {
    USHORT usStationId;             // SAP or link station id
    USHORT usUserStatValue;         // reserved for user
    UCHAR uchT1;                    // response timer
    UCHAR uchT2;                    // aknowledgment timer
    UCHAR uchTi;                    // inactivity timer
    UCHAR uchMaxOut;                // max tramists without ack
    UCHAR uchMaxIn;                 // max receives without ack
    UCHAR uchMaxOutIncr;            // dynamic window increment value
    UCHAR uchMaxRetryCnt;           // N2 value (retries)
    UCHAR uchMaxMembers;            // maximum members for group SAP
    USHORT usMaxI_Field;            // maximum length of the Info field
    UCHAR uchSapValue;              // SAP value to be assigned
    UCHAR uchOptionsPriority;       // SAP options and access priority
    UCHAR uchcStationCount;         // maximum number of link stations in sap
    UCHAR uchReserved2[2];          //
    UCHAR cGroupCount;              // number of group SAPs of this SAP
    PUCHAR pGroupList;              // offset to the group list
    ULONG DlcStatusFlags;           // User notify flag for DLC status changes
    UCHAR uchReserved3[8];          // reserved
    UCHAR cLinkStationsAvail;       // total number of available link stations
} LLC_DLC_OPEN_SAP_PARMS, *PLLC_DLC_OPEN_SAP_PARMS;

typedef struct {
    USHORT usSapStationId;          // SAP station id
    USHORT usLinkStationId;         // Link station id
    UCHAR uchT1;                    // response timer
    UCHAR uchT2;                    // aknowledgment timer
    UCHAR uchTi;                    // inactivity timer
    UCHAR uchMaxOut;                // max tramists without ack
    UCHAR uchMaxIn;                 // max receives without ack
    UCHAR uchMaxOutIncr;            // dynamic window increment value
    UCHAR uchMaxRetryCnt;           // N2 value (retries)
    UCHAR uchRemoteSap;             // remote SAP of the link
    USHORT usMaxI_Field;            // max I field length
    UCHAR uchAccessPriority;        // token ring access priority
    PVOID pRemoteNodeAddress;       // pointer to the destination address
} LLC_DLC_OPEN_STATION_PARMS, *PLLC_DLC_OPEN_STATION_PARMS;

#define LLC_INCREASE_LINK_STATIONS  0
#define LLC_DECREASE_LINK_STATIONS  0x80

typedef struct {
    USHORT usStationId;             // ID of affected SAP
    UCHAR uchOption;                // increase of decrease indicator
    UCHAR uchStationCount;
    UCHAR uchStationsAvailOnAdapter;
    UCHAR uchStationsAvailOnSap;
    UCHAR uchTotalStationsOnAdapter;
    UCHAR uchTotalStationsOnSap;
} LLC_DLC_REALLOCATE_PARMS, *PLLC_DLC_REALLOCATE_PARMS;

typedef struct {
    USHORT usStationId;             // SAP station ID
    USHORT cBufferThreshold;        // SAP buffer pool Threshold number
    PVOID AlertEvent;               // alerting event
} LLC_DLC_SET_THRESHOLD_PARMS, *PLLC_DLC_SET_THRESHOLD_PARMS;

typedef struct {
    PVOID TraceBuffer;              // trace buffer
    ULONG TraceBufferSize;          // trace buffer size
    ULONG TraceFlags;               // various trace flags
} LLC_TRACE_INITIALIZE_PARMS, *PLLC_TRACE_INITIALIZE_PARMS;

#define LLC_DLC_RESET_STATISTICS    0x80
#define LLC_DLC_READ_STATISTICS     0

typedef struct {
    ULONG cTransmittedFrames;
    ULONG cReceivedFrames;
    ULONG cDiscardedFrames;
    ULONG cDataLost;
    USHORT cBuffersAvailable;
} DLC_SAP_LOG, *PDLC_SAP_LOG;

typedef struct {
    USHORT cI_FramesTransmitted;
    USHORT cI_FramesReceived;
    UCHAR cI_FrameReceiveErrors;
    UCHAR cI_FrameTransmissionErrors;
    USHORT cT1_ExpirationCount;     // Note: not OUT data xfer mode
    UCHAR uchLastCmdRespReceived;
    UCHAR uchLastCmdRespTransmitted;
    UCHAR uchPrimaryState;
    UCHAR uchSecondaryState;
    UCHAR uchSendStateVariable;
    UCHAR uchReceiveStateVariable;
    UCHAR uchLastNr;                // last received NR
    UCHAR cbLanHeader;
    UCHAR auchLanHeader[32];
} DLC_LINK_LOG, *PDLC_LINK_LOG;

typedef union {
    DLC_SAP_LOG Sap;
    DLC_LINK_LOG Link;
} LLC_DLC_LOG_BUFFER, *PLLC_DLC_LOG_BUFFER;

typedef struct {
    USHORT usStationId;             // ID of a SAP or a link station
    USHORT cbLogBufSize;            //
    PLLC_DLC_LOG_BUFFER pLogBuf;    // offset to the log buffer
    USHORT usActLogLength;          // length of returned log
    UCHAR uchOptions;               // command options (bit7 resets log params)
} LLC_DLC_STATISTICS_PARMS, *PLLC_DLC_STATISTICS_PARMS;

typedef struct {
    USHORT usBringUps;              // Token Ring adapter bring up error code
    UCHAR Reserved[30];             // everything else specific to DOS or OS/2
} LLC_DIR_INITIALIZE_PARMS, *PLLC_DIR_INITIALIZE_PARMS;

typedef struct {
    USHORT usOpenErrorCode;         // open adapter errors detected
    USHORT usOpenOptions;           // various options
    UCHAR auchNodeAddress[6];       // adapters LAN address
    UCHAR auchGroupAddress[4];      // multicast address added in the open
    UCHAR auchFunctionalAddress[4]; // added token ring functional address
    USHORT usReserved1;
    USHORT usReserved2;
    USHORT usMaxFrameSize;          // maximum frame size defined in NDIS
    USHORT usReserved3[4];
    USHORT usBringUps;              // Bring up errors, TR only
    USHORT InitWarnings;
    USHORT usReserved4[3];
} LLC_ADAPTER_OPEN_PARMS, *PLLC_ADAPTER_OPEN_PARMS;

typedef struct {
    UCHAR uchDlcMaxSaps;
    UCHAR uchDlcMaxStations;
    UCHAR uchDlcMaxGroupSaps;
    UCHAR uchDlcMaxGroupMembers;
    UCHAR uchT1_TickOne;            // Short timer interval (for 1 - 5)
    UCHAR uchT2_TickOne;
    UCHAR uchTi_TickOne;
    UCHAR uchT1_TickTwo;            // Long timer interval (for 6 - 10)
    UCHAR uchT2_TickTwo;
    UCHAR uchTi_TickTwo;
} LLC_DLC_PARMS, *PLLC_DLC_PARMS;

//
// The ethernet mode selects the LAN header format of ethernet. SNA
// applications should use the default parameter, that has been defined in the
// registry. The applications using connectionless DLC services should select
// the ethernet LLC LAN header format they are using (usually 802.3)
//

typedef enum {
    LLC_ETHERNET_TYPE_DEFAULT,      // use the parameter value set in registry
    LLC_ETHERNET_TYPE_AUTO,         // automatic header type selction for links
    LLC_ETHERNET_TYPE_802_3,        // use always 802.3 lan headers
    LLC_ETHERNET_TYPE_DIX           // use always LLC on DIX SNA type.
} LLC_ETHERNET_TYPE, *PLLC_ETHERNET_TYPE;

typedef struct {
    PVOID hBufferPool;
    PVOID pSecurityDescriptor;
    LLC_ETHERNET_TYPE LlcEthernetType;
} LLC_EXTENDED_ADAPTER_PARMS, *PLLC_EXTENDED_ADAPTER_PARMS;

typedef struct {
    PLLC_ADAPTER_OPEN_PARMS pAdapterParms;      // ADAPTER_PARMS
    PLLC_EXTENDED_ADAPTER_PARMS pExtendedParms; // DIRECT_PARMS
    PLLC_DLC_PARMS pDlcParms;                   // DLC_PARMS
    PVOID pReserved1;                           // NCB_PARMS
} LLC_DIR_OPEN_ADAPTER_PARMS, *PLLC_DIR_OPEN_ADAPTER_PARMS;

typedef struct {
    UCHAR auchMulticastAddress[6];  // 48 bit multicast address
} LLC_DIR_MULTICAST_ADDRESS, *PLLC_DIR_MULTICAST_ADDRESS;

#define LLC_DIRECT_OPTIONS_ALL_MACS 0x1880

typedef struct {
    USHORT Reserved[4];
    USHORT usOpenOptions;
    USHORT usEthernetType;
    ULONG ulProtocolTypeMask;
    ULONG ulProtocolTypeMatch;
    USHORT usProtocolTypeOffset;
} LLC_DIR_OPEN_DIRECT_PARMS, *PLLC_DIR_OPEN_DIRECT_PARMS;

typedef struct {
    UCHAR cLineError;
    UCHAR cInternalError;
    UCHAR cBurstError;
    UCHAR cAC_Error;
    UCHAR cAbortDelimiter;
    UCHAR uchReserved1;
    UCHAR cLostFrame;
    UCHAR cReceiveCongestion;
    UCHAR cFrameCopiedError;
    UCHAR cFrequencyError;
    UCHAR cTokenError;
    UCHAR uchReserved2;
    UCHAR uchReserved3;
    UCHAR uchReserved4;
} LLC_ADAPTER_LOG_TR, *PLLC_ADAPTER_LOG_TR;

typedef struct {
    UCHAR cCRC_Error;
    UCHAR uchReserved1;
    UCHAR cAlignmentError;
    UCHAR uchReserved2;
    UCHAR cTransmitError;
    UCHAR uchReserved3;
    UCHAR cCollisionError;
    UCHAR cReceiveCongestion;
    UCHAR uchReserved[6];
} LLC_ADAPTER_LOG_ETH, *PLLC_ADAPTER_LOG_ETH;

typedef union {
    LLC_ADAPTER_LOG_TR Tr;
    LLC_ADAPTER_LOG_ETH Eth;
} LLC_ADAPTER_LOG, *PLLC_ADAPTER_LOG;

typedef struct {
    ULONG cTransmittedFrames;
    ULONG cReceivedFrames;
    ULONG cDiscardedFrames;
    ULONG cDataLost;
    USHORT cBuffersAvailable;
} LLC_DIRECT_LOG, *PLLC_DIRECT_LOG;

typedef union {
    LLC_ADAPTER_LOG Adapter;
    LLC_DIRECT_LOG Dir;

    struct {
        LLC_ADAPTER_LOG Adapter;
        LLC_DIRECT_LOG Dir;
    } both;

} LLC_DIR_READ_LOG_BUFFER, *PLLC_DIR_READ_LOG_BUFFER;

#define LLC_DIR_READ_LOG_ADAPTER    0
#define LLC_DIR_READ_LOG_DIRECT     1
#define LLC_DIR_READ_LOG_BOTH       2

typedef struct {
    USHORT usTypeId;                    // 0=adapter, 1=direct, 2=both logs
    USHORT cbLogBuffer;                 // size of log buffer
    PLLC_DIR_READ_LOG_BUFFER pLogBuffer;// pointer to log buffer
    USHORT cbActualLength;              // returned size of log buffer
} LLC_DIR_READ_LOG_PARMS, *PLLC_DIR_READ_LOG_PARMS;

typedef struct {
    ULONG ulAdapterCheckFlag;
    ULONG ulNetworkStatusFlag;
    ULONG ulPcErrorFlag;
    ULONG ulSystemActionFlag;
} LLC_DIR_SET_EFLAG_PARMS, *PLLC_DIR_SET_EFLAG_PARMS;

#define LLC_ADAPTER_ETHERNET    0x0010
#define LLC_ADAPTER_TOKEN_RING  0x0040

typedef struct {
    UCHAR auchPermanentAddress[6];  // permanent encoded address
    UCHAR auchNodeAddress[6];       // adapter's network address
    UCHAR auchGroupAddress[4];      // adapter's group address
    UCHAR auchFunctAddr[4];         // adapter's functional address
    UCHAR uchMaxSap;                // maximum allowable SAP
    UCHAR uchOpenSaps;              // number of currently open saps
    UCHAR uchMaxStations;           // max number of stations (always 253)
    UCHAR uchOpenStation;           // number of open stations (only up to 253)
    UCHAR uchAvailStations;         // number of available stations (always 253)
    UCHAR uchAdapterConfig;         // adapter configuration flags
    UCHAR auchReserved1[10];        // microcode level
    ULONG ulReserved1;
    ULONG ulReserved2;
    ULONG ulMaxFrameLength;         // maximum frame length (only in Windows/Nt)
    USHORT usLastNetworkStatus;
    USHORT usAdapterType;           // THIS BYTE IS NOT USED IN DOS DLC !!!
} LLC_DIR_STATUS_PARMS, *PLLC_DIR_STATUS_PARMS;


#define LLC_OPTION_READ_STATION 0
#define LLC_OPTION_READ_SAP     1
#define LLC_OPTION_READ_ALL     2

#define LLC_EVENT_SYSTEM_ACTION         0x0040
#define LLC_EVENT_NETWORK_STATUS        0x0020
#define LLC_EVENT_CRITICAL_EXCEPTION    0x0010
#define LLC_EVENT_STATUS_CHANGE         0x0008
#define LLC_EVENT_RECEIVE_DATA          0x0004
#define LLC_EVENT_TRANSMIT_COMPLETION   0x0002
#define LLC_EVENT_COMMAND_COMPLETION    0x0001
#define LLC_READ_ALL_EVENTS             0x007F

//
// LLC_STATUS_CHANGE indications
// The returned status value may be an inclusive-OR of several flags
//

#define LLC_INDICATE_LINK_LOST              0x8000
#define LLC_INDICATE_DM_DISC_RECEIVED       0x4000
#define LLC_INDICATE_FRMR_RECEIVED          0x2000
#define LLC_INDICATE_FRMR_SENT              0x1000
#define LLC_INDICATE_RESET                  0x0800
#define LLC_INDICATE_CONNECT_REQUEST        0x0400
#define LLC_INDICATE_REMOTE_BUSY            0x0200
#define LLC_INDICATE_REMOTE_READY           0x0100
#define LLC_INDICATE_TI_TIMER_EXPIRED       0x0080
#define LLC_INDICATE_DLC_COUNTER_OVERFLOW   0x0040
#define LLC_INDICATE_ACCESS_PRTY_LOWERED    0x0020
#define LLC_INDICATE_LOCAL_STATION_BUSY     0x0001

typedef struct {
    USHORT usStationId;
    UCHAR uchOptionIndicator;
    UCHAR uchEventSet;
    UCHAR uchEvent;
    UCHAR uchCriticalSubset;
    ULONG ulNotificationFlag;

    union {

        struct {
            USHORT usCcbCount;
            PLLC_CCB pCcbCompletionList;
            USHORT usBufferCount;
            PLLC_BUFFER pFirstBuffer;
            USHORT usReceivedFrameCount;
            PLLC_BUFFER pReceivedFrame;
            USHORT usEventErrorCode;
            USHORT usEventErrorData[3];
        } Event;

        struct {
            USHORT usStationId;
            USHORT usDlcStatusCode;
            UCHAR uchFrmrData[5];
            UCHAR uchAccessPritority;
            UCHAR uchRemoteNodeAddress[6];
            UCHAR uchRemoteSap;
            UCHAR uchReserved;
            USHORT usUserStatusValue;
        } Status;

    } Type;

} LLC_READ_PARMS, *PLLC_READ_PARMS;

//
// This data structure gives the best performance in Windows/Nt: The DLC driver
// must copy the CCB and the parameter table. If the driver knows that the
// parameter table is concatenated to the CCB, it can copy both structures at
// once. NOTE: The pointer to the parameter table MUST still be present in the
// CCB
//

typedef struct {
    LLC_CCB Ccb;
    LLC_READ_PARMS Parms;
} LLC_READ_COMMAND, *PLLC_READ_COMMAND;

//
// New receive types for direct stations, these types are ignored if the direct
// station was opened with a specific ethernet type
//

#define LLC_DIR_RCV_ALL_TR_FRAMES       0
#define LLC_DIR_RCV_ALL_MAC_FRAMES      1
#define LLC_DIR_RCV_ALL_8022_FRAMES     2
#define LLC_DIR_RCV_ALL_FRAMES          4
#define LLC_DIR_RCV_ALL_ETHERNET_TYPES  5

#define LLC_CONTIGUOUS_MAC      0x80
#define LLC_CONTIGUOUS_DATA     0x40
#define LLC_NOT_CONTIGUOUS_DATA 0x00

//
// LLC_BREAK (0x20) is not supported by Windows/Nt
//

#define LLC_RCV_READ_INDIVIDUAL_FRAMES  0
#define LLC_RCV_CHAIN_FRAMES_ON_LINK    1
#define LLC_RCV_CHAIN_FRAMES_ON_SAP     2

typedef struct {
    USHORT usStationId;             // SAP, link station or direct id
    USHORT usUserLength;            // length of user data in buffer header
    ULONG ulReceiveFlag;            // the received data handler
    PLLC_BUFFER pFirstBuffer;       // first buffer in the pool
    UCHAR uchOptions;               // defines how the frame is received
    UCHAR auchReserved1[3];
    UCHAR uchRcvReadOption;         // defines if rcv frames are chained
} LLC_RECEIVE_PARMS, *PLLC_RECEIVE_PARMS;

#define LLC_CHAIN_XMIT_COMMANDS_ON_LINK 0
#define LLC_COMPLETE_SINGLE_XMIT_FRAME  1
#define LLC_CHAIN_XMIT_COMMANDS_ON_SAP  2

typedef struct {
    USHORT usStationId;             // SAP, link station or direct id
    UCHAR uchTransmitFs;            // token-ring frame status
    UCHAR uchRemoteSap;             // remote destination SAP
    PLLC_XMIT_BUFFER pXmitQueue1;   // first link list of frame segments
    PLLC_XMIT_BUFFER pXmitQueue2;   // another segment list returuned to pool
    USHORT cbBuffer1;               // length of buffer 1
    USHORT cbBuffer2;               // length of buffer 2
    PVOID pBuffer1;                 // yet another segment
    PVOID pBuffer2;                 // this is the last segment of frame
    UCHAR uchXmitReadOption;        // defines completion event for READ
} LLC_TRANSMIT_PARMS,  *PLLC_TRANSMIT_PARMS;

#define LLC_FIRST_DATA_SEGMENT  0x01
#define LLC_NEXT_DATA_SEGMENT   0x02

typedef struct {
    UCHAR eSegmentType;             // defines if first or next segment of frame
    UCHAR boolFreeBuffer;           // if set, this buffer is released to pool
    USHORT cbBuffer;                // length of this buffer
    PVOID pBuffer;
} LLC_TRANSMIT_DESCRIPTOR, *PLLC_TRANSMIT_DESCRIPTOR;

//
// The frames types returned in the first receive buffer or used with the
// TRANSMIT_FRAMES command.  A direct station may also send only ethernet
// frames. The ethernet types are only for transmit. Types 0x0019 - 0x05DC
// are reserved
//

enum _LLC_FRAME_TYPES {                     // Purpose:
    LLC_DIRECT_TRANSMIT         = 0x0000,   // transmit
    LLC_DIRECT_MAC              = 0x0002,   // receive
    LLC_I_FRAME                 = 0x0004,   // receive & transmit
    LLC_UI_FRAME                = 0x0006,   // receive & transmit
    LLC_XID_COMMAND_POLL        = 0x0008,   // receive & transmit
    LLC_XID_COMMAND_NOT_POLL    = 0x000A,   // receive & transmit
    LLC_XID_RESPONSE_FINAL      = 0x000C,   // receive & transmit
    LLC_XID_RESPONSE_NOT_FINAL  = 0x000E,   // receive & transmit
    LLC_TEST_RESPONSE_FINAL     = 0x0010,   // receive & transmit
    LLC_TEST_RESPONSE_NOT_FINAL = 0x0012,   // receive & transmit
    LLC_DIRECT_8022             = 0x0014,   // receive (direct station)
    LLC_TEST_COMMAND_POLL       = 0x0016,   // transmit
    LLC_DIRECT_ETHERNET_TYPE    = 0x0018,   // receive (direct station)
    LLC_LAST_FRAME_TYPE         = 0x001a,   // reserved
    LLC_FIRST_ETHERNET_TYPE     = 0x05DD    // transmit (>)
};

typedef struct {
    LLC_CCB Ccb;                    // use this as transmit CCB
    USHORT usStationId;
    USHORT usFrameType;             // DLC frame or ethernet type
    UCHAR uchRemoteSap;             // used with UI, TEST, XID frames
    UCHAR uchXmitReadOption;
    UCHAR Reserved2[2];
    ULONG cXmitBufferCount;
    LLC_TRANSMIT_DESCRIPTOR aXmitBuffer[1];
} LLC_TRANSMIT2_COMMAND, *PLLC_TRANSMIT2_COMMAND;

//
// LLC_TRANSMIT2_VAR_PARMS - this macro allocates space for variable length
// descriptor array, eg: LLC_TRANSMIT2_VAR_PARMS(8) TransmitParms;
//

#define LLC_TRANSMIT2_VAR_PARMS(a)\
struct {\
    LLC_CCB Ccb;\
    USHORT usStationId;\
    USHORT usFrameType;\
    UCHAR uchRemoteSap;\
    UCHAR uchXmitReadOption;\
    UCHAR uchReserved2[2];\
    ULONG cXmitBufferCount;\
    LLC_TRANSMIT_DESCRIPTOR XmitBuffer[(a)];\
}

//
// LLC_PARMS - All CCB parameter tables can be referred to using this union
//

union _LLC_PARMS {
    LLC_BUFFER_FREE_PARMS BufferFree;
    LLC_BUFFER_GET_PARMS BufferGet;
    LLC_DLC_CONNECT_PARMS DlcConnectStation;
    LLC_DLC_MODIFY_PARMS DlcModify;
    LLC_DLC_OPEN_SAP_PARMS DlcOpenSap;
    LLC_DLC_OPEN_STATION_PARMS DlcOpenStation;
    LLC_DLC_REALLOCATE_PARMS DlcReallocate;
    LLC_DLC_SET_THRESHOLD_PARMS DlcSetThreshold;
    LLC_DLC_STATISTICS_PARMS DlcStatistics;
    LLC_DIR_INITIALIZE_PARMS DirInitialize;
    LLC_DIR_OPEN_ADAPTER_PARMS DirOpenAdapter;
    LLC_DIR_OPEN_DIRECT_PARMS DirOpenDirect;
    LLC_DIR_READ_LOG_PARMS DirReadLog;
    LLC_DIR_SET_EFLAG_PARMS DirSetEventFlag;
    LLC_DIR_STATUS_PARMS DirStatus;
    LLC_READ_PARMS Read;
    LLC_RECEIVE_PARMS Receive;
    LLC_TRANSMIT_PARMS Transmit;
    LLC_TRANSMIT2_COMMAND Transmit2;
    LLC_TRACE_INITIALIZE_PARMS TraceInitialize;
};

//
// LLC_STATUS - enumerates the return codes which appear in the CCB uchDlcStatus
// field
//

typedef enum _LLC_STATUS {
    LLC_STATUS_SUCCESS                      = 0x00,
    LLC_STATUS_INVALID_COMMAND              = 0x01,
    LLC_STATUS_DUPLICATE_COMMAND            = 0x02,
    LLC_STATUS_ADAPTER_OPEN                 = 0x03,
    LLC_STATUS_ADAPTER_CLOSED               = 0x04,
    LLC_STATUS_PARAMETER_MISSING            = 0x05,
    LLC_STATUS_INVALID_OPTION               = 0x06,
    LLC_STATUS_COMMAND_CANCELLED_FAILURE    = 0x07,
    LLC_STATUS_ACCESS_DENIED                = 0x08,   // not used in Windows/Nt
    LLC_STATUS_ADAPTER_NOT_INITIALIZED      = 0x09,   // not used in Windows/Nt
    LLC_STATUS_CANCELLED_BY_USER            = 0x0A,
    LLC_STATUS_COMMAND_CANCELLED_CLOSED     = 0x0B,   // not used in Windows/Nt
    LLC_STATUS_SUCCESS_NOT_OPEN             = 0x0C,
    LLC_STATUS_TIMER_ERROR                  = 0x11,
    LLC_STATUS_NO_MEMORY                    = 0x12,
    LLC_STATUS_INVALID_LOG_ID               = 0x13,   // not used in Windows/Nt
    LLC_STATUS_LOST_LOG_DATA                = 0x15,
    LLC_STATUS_BUFFER_SIZE_EXCEEDED         = 0x16,
    LLC_STATUS_INVALID_BUFFER_LENGTH        = 0x18,
    LLC_STATUS_INADEQUATE_BUFFERS           = 0x19,
    LLC_STATUS_USER_LENGTH_TOO_LARGE        = 0x1A,
    LLC_STATUS_INVALID_PARAMETER_TABLE      = 0x1B,
    LLC_STATUS_INVALID_POINTER_IN_CCB       = 0x1C,
    LLC_STATUS_INVALID_ADAPTER              = 0x1D,
    LLC_STATUS_LOST_DATA_NO_BUFFERS         = 0x20,
    LLC_STATUS_LOST_DATA_INADEQUATE_SPACE   = 0x21,
    LLC_STATUS_TRANSMIT_ERROR_FS            = 0x22,
    LLC_STATUS_TRANSMIT_ERROR               = 0x23,
    LLC_STATUS_UNAUTHORIZED_MAC             = 0x24,   // not used in Windows/Nt
    LLC_STATUS_MAX_COMMANDS_EXCEEDED        = 0x25,   // not used in Windows/Nt
    LLC_STATUS_LINK_NOT_TRANSMITTING        = 0x27,
    LLC_STATUS_INVALID_FRAME_LENGTH         = 0x28,
    LLC_STATUS_INADEQUATE_RECEIVE           = 0x30,   // not used in Windows/Nt
    LLC_STATUS_INVALID_NODE_ADDRESS         = 0x32,
    LLC_STATUS_INVALID_RCV_BUFFER_LENGTH    = 0x33,
    LLC_STATUS_INVALID_XMIT_BUFFER_LENGTH   = 0x34,
    LLC_STATUS_INVALID_STATION_ID           = 0x40,
    LLC_STATUS_LINK_PROTOCOL_ERROR          = 0x41,
    LLC_STATUS_PARMETERS_EXCEEDED_MAX       = 0x42,
    LLC_STATUS_INVALID_SAP_VALUE            = 0x43,
    LLC_STATUS_INVALID_ROUTING_INFO         = 0x44,
    LLC_STATUS_RESOURCES_NOT_AVAILABLE      = 0x46,   // not used in Windows/Nt
    LLC_STATUS_LINK_STATIONS_OPEN           = 0x47,
    LLC_STATUS_INCOMPATIBLE_COMMANDS        = 0x4A,
    LLC_STATUS_OUTSTANDING_COMMANDS         = 0x4C,   // not used in Windows/Nt
    LLC_STATUS_CONNECT_FAILED               = 0x4D,
    LLC_STATUS_INVALID_REMOTE_ADDRESS       = 0x4F,
    LLC_STATUS_CCB_POINTER_FIELD            = 0x50,
    LLC_STATUS_INVALID_APPLICATION_ID       = 0x52,   // not used in Windows/Nt
    LLC_STATUS_NO_SYSTEM_PROCESS            = 0x56,   // not used in Windows/Nt
    LLC_STATUS_INADEQUATE_LINKS             = 0x57,
    LLC_STATUS_INVALID_PARAMETER_1          = 0x58,
    LLC_STATUS_DIRECT_STATIONS_NOT_ASSIGNED = 0x5C,
    LLC_STATUS_DEVICE_DRIVER_NOT_INSTALLED  = 0x5d,
    LLC_STATUS_ADAPTER_NOT_INSTALLED        = 0x5e,
    LLC_STATUS_CHAINED_DIFFERENT_ADAPTERS   = 0x5f,
    LLC_STATUS_INIT_COMMAND_STARTED         = 0x60,
    LLC_STATUS_TOO_MANY_USERS               = 0x61,   // not used in Windows/Nt
    LLC_STATUS_CANCELLED_BY_SYSTEM_ACTION   = 0x62,
    LLC_STATUS_DIR_STATIONS_NOT_AVAILABLE   = 0x63,   // not used in Windows/Nt
    LLC_STATUS_NO_GDT_SELECTORS             = 0x65,
    LLC_STATUS_MEMORY_LOCK_FAILED           = 0x69,

    //
    // New NT DLC specific error codes begin from 0x80
    // These error codes are for new Windows/Nt DLC apps.
    //

    LLC_STATUS_INVALID_BUFFER_ADDRESS       = 0x80,
    LLC_STATUS_BUFFER_ALREADY_RELEASED      = 0x81,
    LLC_STATUS_BIND_ERROR                   = 0xA0,   // not used in Windows/Nt
    LLC_STATUS_INVALID_VERSION              = 0xA1,
    LLC_STATUS_NT_ERROR_STATUS              = 0xA2,
    LLC_STATUS_PENDING                      = 0xFF
} LLC_STATUS;

#define LLC_STATUS_MAX_ERROR 0xFF

//
// ACSLAN_STATUS - status codes which are returned from AcsLan
//

typedef enum {
    ACSLAN_STATUS_COMMAND_ACCEPTED = 0,
    ACSLAN_STATUS_INVALID_CCB_POINTER = 1,
    ACSLAN_STATUS_CCB_IN_ERROR = 2,
    ACSLAN_STATUS_CHAINED_CCB_IN_ERROR = 3,
    ACSLAN_STATUS_SYSTEM_ERROR = 4,
    ACSLAN_STATUS_SYSTEM_STATUS = 5,
    ACSLAN_STATUS_INVALID_COMMAND = 6
} ACSLAN_STATUS;

//
// prototypes
//

ACSLAN_STATUS
APIENTRY
AcsLan(
    IN OUT PLLC_CCB pCcb,
    OUT PLLC_CCB* ppBadCcb
    );

#ifdef __cplusplus
}
#endif

#endif // _DLCAPI_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\tools\c932\inc\errno.h ===
/***
*errno.h - system wide error numbers (set by system calls)
*
*	Copyright (c) 1985-1994, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	This file defines the system-wide error numbers (set by
*	system calls).	Conforms to the XENIX standard.  Extended
*	for compatibility with Uniforum standard.
*	[System V]
*
****/

#ifndef _INC_ERRNO
#define _INC_ERRNO

#ifdef __cplusplus
extern "C" {
#endif


/* Define _CRTAPI1 (for compatibility with the NT SDK) */

#ifndef _CRTAPI1
#if	( (_MSC_VER >= 800) && (_M_IX86 >= 300) )
#define _CRTAPI1 __cdecl
#else
#define _CRTAPI1
#endif
#endif


/* Define _CRTAPI2 (for compatibility with the NT SDK) */

#ifndef _CRTAPI2
#if	( (_MSC_VER >= 800) && (_M_IX86 >= 300) )
#define _CRTAPI2 __cdecl
#else
#define _CRTAPI2
#endif
#endif


/* Define _CRTIMP */

#ifndef _CRTIMP
#ifdef	_NTSDK
/* definition compatible with NT SDK */
#define _CRTIMP
#else	/* ndef _NTSDK */
/* current definition */
#ifdef	_DLL
#define _CRTIMP __declspec(dllimport)
#else	/* ndef _DLL */
#define _CRTIMP
#endif	/* _DLL */
#endif	/* _NTSDK */
#endif	/* _CRTIMP */


/* Define __cdecl for non-Microsoft compilers */

#if	( !defined(_MSC_VER) && !defined(__cdecl) )
#define __cdecl
#endif


/* declare reference to errno */

#ifdef	_MT
_CRTIMP extern int * __cdecl _errno(void);
#define errno	(*_errno())
#else	/* ndef _MT */
extern int errno;
#endif	/* _MT */

/* Error Codes */

#define EPERM		1
#define ENOENT		2
#define ESRCH		3
#define EINTR		4
#define EIO		5
#define ENXIO		6
#define E2BIG		7
#define ENOEXEC 	8
#define EBADF		9
#define ECHILD		10
#define EAGAIN		11
#define ENOMEM		12
#define EACCES		13
#define EFAULT		14
#define EBUSY		16
#define EEXIST		17
#define EXDEV		18
#define ENODEV		19
#define ENOTDIR 	20
#define EISDIR		21
#define EINVAL		22
#define ENFILE		23
#define EMFILE		24
#define ENOTTY		25
#define EFBIG		27
#define ENOSPC		28
#define ESPIPE		29
#define EROFS		30
#define EMLINK		31
#define EPIPE		32
#define EDOM		33
#define ERANGE		34
#define EDEADLK		36
#define ENAMETOOLONG	38
#define ENOLCK		39
#define ENOSYS		40
#define ENOTEMPTY	41
#define EILSEQ		42

/*
 * Support EDEADLOCK for compatibiity with older MS-C versions.
 */
#define EDEADLOCK	EDEADLK

#ifdef __cplusplus
}
#endif

#endif	/* _INC_ERRNO */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\tools\c932\inc\dlgs.h ===
#ifndef _DLGSH_INCLUDED_
#define _DLGSH_INCLUDED_

/*---------------------------------------------------------------------------*/
/* Dlgs.h : UI dialog header                                                 */
/*                                                                           */
/* Copyright (c) Microsoft Corporation, 1990-1993                            */
/*---------------------------------------------------------------------------*/

/*----Constants--------------------------------------------------------------*/
#define ctlFirst    0x0400
#define ctlLast     0x04ff
    /* Push buttons */
#define psh1        0x0400
#define psh2        0x0401
#define psh3        0x0402
#define psh4        0x0403
#define psh5        0x0404
#define psh6        0x0405
#define psh7        0x0406
#define psh8        0x0407
#define psh9        0x0408
#define psh10       0x0409
#define psh11       0x040a
#define psh12       0x040b
#define psh13       0x040c
#define psh14       0x040d
#define psh15       0x040e
#define pshHelp     psh15
#define psh16       0x040f
    /* Checkboxes */
#define chx1        0x0410
#define chx2        0x0411
#define chx3        0x0412
#define chx4        0x0413
#define chx5        0x0414
#define chx6        0x0415
#define chx7        0x0416
#define chx8        0x0417
#define chx9        0x0418
#define chx10       0x0419
#define chx11       0x041a
#define chx12       0x041b
#define chx13       0x041c
#define chx14       0x041d
#define chx15       0x041e
#define chx16       0x041d
    /* Radio buttons */
#define rad1        0x0420
#define rad2        0x0421
#define rad3        0x0422
#define rad4        0x0423
#define rad5        0x0424
#define rad6        0x0425
#define rad7        0x0426
#define rad8        0x0427
#define rad9        0x0428
#define rad10       0x0429
#define rad11       0x042a
#define rad12       0x042b
#define rad13       0x042c
#define rad14       0x042d
#define rad15       0x042e
#define rad16       0x042f
    /* Groups, frames, rectangles, and icons */
#define grp1        0x0430
#define grp2        0x0431
#define grp3        0x0432
#define grp4        0x0433
#define frm1        0x0434
#define frm2        0x0435
#define frm3        0x0436
#define frm4        0x0437
#define rct1        0x0438
#define rct2        0x0439
#define rct3        0x043a
#define rct4        0x043b
#define ico1        0x043c
#define ico2        0x043d
#define ico3        0x043e
#define ico4        0x043f
    /* Static text */
#define stc1        0x0440
#define stc2        0x0441
#define stc3        0x0442
#define stc4        0x0443
#define stc5        0x0444
#define stc6        0x0445
#define stc7        0x0446
#define stc8        0x0447
#define stc9        0x0448
#define stc10       0x0449
#define stc11       0x044a
#define stc12       0x044b
#define stc13       0x044c
#define stc14       0x044d
#define stc15       0x044e
#define stc16       0x044f
#define stc17       0x0450
#define stc18       0x0451
#define stc19       0x0452
#define stc20       0x0453
#define stc21       0x0454
#define stc22       0x0455
#define stc23       0x0456
#define stc24       0x0457
#define stc25       0x0458
#define stc26       0x0459
#define stc27       0x045a
#define stc28       0x045b
#define stc29       0x045c
#define stc30       0x045d
#define stc31       0x045e
#define stc32       0x045f
    /* Listboxes */
#define lst1        0x0460
#define lst2        0x0461
#define lst3        0x0462
#define lst4        0x0463
#define lst5        0x0464
#define lst6        0x0465
#define lst7        0x0466
#define lst8        0x0467
#define lst9        0x0468
#define lst10       0x0469
#define lst11       0x046a
#define lst12       0x046b
#define lst13       0x046c
#define lst14       0x046d
#define lst15       0x046e
#define lst16       0x046f
    /* Combo boxes */
#define cmb1        0x0470
#define cmb2        0x0471
#define cmb3        0x0472
#define cmb4        0x0473
#define cmb5        0x0474
#define cmb6        0x0475
#define cmb7        0x0476
#define cmb8        0x0477
#define cmb9        0x0478
#define cmb10       0x0479
#define cmb11       0x047a
#define cmb12       0x047b
#define cmb13       0x047c
#define cmb14       0x047d
#define cmb15       0x047e
#define cmb16       0x047f
    /* Edit controls */
#define edt1        0x0480
#define edt2        0x0481
#define edt3        0x0482
#define edt4        0x0483
#define edt5        0x0484
#define edt6        0x0485
#define edt7        0x0486
#define edt8        0x0487
#define edt9        0x0488
#define edt10       0x0489
#define edt11       0x048a
#define edt12       0x048b
#define edt13       0x048c
#define edt14       0x048d
#define edt15       0x048e
#define edt16       0x048f
    /* Scroll bars */
#define scr1        0x0490
#define scr2        0x0491
#define scr3        0x0492
#define scr4        0x0493
#define scr5        0x0494
#define scr6        0x0495
#define scr7        0x0496
#define scr8        0x0497

/* These dialog resource ordinals really start at 0x0600, but the
 * RC Compiler can't handle hex for resource IDs, hence the decimal.
 * 27 March 1991        clarkc
 */
#define FILEOPENORD      1536
#define MULTIFILEOPENORD 1537
#define PRINTDLGORD      1538
#define PRNSETUPDLGORD   1539
#define FINDDLGORD       1540
#define REPLACEDLGORD    1541
#define FONTDLGORD       1542
#define FORMATDLGORD31   1543
#define FORMATDLGORD30   1544

/*----Types------------------------------------------------------------------*/
typedef struct tagCRGB
    {
    BYTE    bRed;
    BYTE    bGreen;
    BYTE    bBlue;
    BYTE    bExtra;
    }
CRGB;           /* RGB Color */


#endif // _DLGSH_INCLUDED_

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\tools\c932\inc\dos.h ===
/***
*dos.h - definitions for MS-DOS interface routines
*
*	Copyright (c) 1985-1994, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	Defines the structs and unions used for the direct DOS interface
*	routines; includes macros to access the segment and offset
*	values of far pointers, so that they may be used by the routines; and
*	provides function prototypes for direct DOS interface functions.
*
****/

#ifndef _INC_DOS
#define _INC_DOS

#ifdef __cplusplus
extern "C" {
#endif


/* Define _CRTAPI1 (for compatibility with the NT SDK) */

#ifndef _CRTAPI1
#if	( (_MSC_VER >= 800) && (_M_IX86 >= 300) )
#define _CRTAPI1 __cdecl
#else
#define _CRTAPI1
#endif
#endif


/* Define _CRTAPI2 (for compatibility with the NT SDK) */

#ifndef _CRTAPI2
#if	( (_MSC_VER >= 800) && (_M_IX86 >= 300) )
#define _CRTAPI2 __cdecl
#else
#define _CRTAPI2
#endif
#endif


/* Define _CRTIMP */

#ifndef _CRTIMP
#ifdef	_NTSDK
/* definition compatible with NT SDK */
#define _CRTIMP
#else	/* ndef _NTSDK */
/* current definition */
#ifdef	_DLL
#define _CRTIMP __declspec(dllimport)
#else	/* ndef _DLL */
#define _CRTIMP
#endif	/* _DLL */
#endif	/* _NTSDK */
#endif	/* _CRTIMP */


/* Define __cdecl for non-Microsoft compilers */

#if	( !defined(_MSC_VER) && !defined(__cdecl) )
#define __cdecl
#endif

#ifndef _WCHAR_T_DEFINED
typedef unsigned short wchar_t;
#define _WCHAR_T_DEFINED
#endif

/* _getdiskfree structure (duplicated in DIRECT.H) */

#ifndef _DISKFREE_T_DEFINED
struct _diskfree_t {
	unsigned total_clusters;
	unsigned avail_clusters;
	unsigned sectors_per_cluster;
	unsigned bytes_per_sector;
	};

#define _DISKFREE_T_DEFINED
#endif

/* File attribute constants */

#define _A_NORMAL	0x00	/* Normal file - No read/write restrictions */
#define _A_RDONLY	0x01	/* Read only file */
#define _A_HIDDEN	0x02	/* Hidden file */
#define _A_SYSTEM	0x04	/* System file */
#define _A_SUBDIR	0x10	/* Subdirectory */
#define _A_ARCH 	0x20	/* Archive file */

#ifdef	_NTSDK

/* External variable declarations */

/*
 * WARNING! The _osversion, _osmajor, _osminor, _baseversion, _basemajor and
 * _baseminor variables were never meaningfully defined in the C runtime
 * libraries for Win32 platforms. Any code which references these variables
 * should be revised (see the declarations for version information variables
 * in stdlib.h).
 */

#ifdef	_DLL

/* --------- The following block is OBSOLETE --------- */

#define _osversion   (*_osversion_dll)
#define _osmajor     (*_osmajor_dll)
#define _osminor     (*_osminor_dll)
#define _baseversion (*_baseversion_dll)
#define _basemajor   (*_basemajor_dll)
#define _baseminor   (*_baseminor_dll)

extern unsigned int * _osversion_dll;
extern unsigned int * _osmajor_dll;
extern unsigned int * _osminor_dll;
extern unsigned int * _baseversion_dll;
extern unsigned int * _basemajor_dll;
extern unsigned int * _baseminor_dll;

/* --------- The preceding block is OBSOLETE --------- */

#define _pgmptr      (*_pgmptr_dll)
#define _wpgmptr     (*_wpgmptr_dll)
extern char ** _pgmptr_dll;
extern wchar_t ** _wpgmptr_dll;

#else	/* ndef _DLL */

/* --------- The following block is OBSOLETE --------- */


extern unsigned int _osversion;
extern unsigned int _osmajor;
extern unsigned int _osminor;
extern unsigned int _baseversion;
extern unsigned int _basemajor;
extern unsigned int _baseminor;

/* --------- The preceding block is OBSOLETE --------- */

extern char * _pgmptr;
extern wchar_t * _wpgmptr;

#endif	/* _DLL */

#endif	/* _NTSDK */


/* Function prototypes */

_CRTIMP unsigned __cdecl _getdiskfree(unsigned, struct _diskfree_t *);
#ifdef	_M_IX86
void __cdecl _disable(void);
void __cdecl _enable(void);
#endif	/* _M_IX86 */

#if	!__STDC__
/* Non-ANSI name for compatibility */
#define diskfree_t  _diskfree_t
#endif	/* __STDC__ */

#ifdef __cplusplus
}
#endif

#endif	/* _INC_DOS */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\tools\c932\inc\fpieee.h ===
/***
*fpieee.h - Definitions for floating point IEEE exception handling
*
*	Copyright (c) 1991-1994, Microsoft Corporation.	All rights reserved.
*
*Purpose:
*	This file contains constant and type definitions for handling
*	floating point exceptions [ANSI/IEEE std. 754]
*
****/

#ifndef _INC_FPIEEE
#define _INC_FPIEEE

#ifdef __cplusplus
extern "C" {
#endif


/* Define _CRTAPI1 (for compatibility with the NT SDK) */

#ifndef _CRTAPI1
#if	( (_MSC_VER >= 800) && (_M_IX86 >= 300) )
#define _CRTAPI1 __cdecl
#else
#define _CRTAPI1
#endif
#endif


/* Define _CRTAPI2 (for compatibility with the NT SDK) */

#ifndef _CRTAPI2
#if	( (_MSC_VER >= 800) && (_M_IX86 >= 300) )
#define _CRTAPI2 __cdecl
#else
#define _CRTAPI2
#endif
#endif


/* Define _CRTIMP */

#ifndef _CRTIMP
#ifdef	_NTSDK
/* definition compatible with NT SDK */
#define _CRTIMP
#else	/* ndef _NTSDK */
/* current definition */
#ifdef	_DLL
#define _CRTIMP __declspec(dllimport)
#else	/* ndef _DLL */
#define _CRTIMP
#endif	/* _DLL */
#endif	/* _NTSDK */
#endif	/* _CRTIMP */


/* Define __cdecl for non-Microsoft compilers */

#if	( !defined(_MSC_VER) && !defined(__cdecl) )
#define __cdecl
#endif

/*
 * Define floating point IEEE compare result values.
 */

typedef enum {
    _FpCompareEqual,
    _FpCompareGreater,
    _FpCompareLess,
    _FpCompareUnordered
} _FPIEEE_COMPARE_RESULT;

/*
 * Define floating point format and result precision values.
 */

typedef enum {
    _FpFormatFp32,
    _FpFormatFp64,
    _FpFormatFp80,
    _FpFormatFp128,
    _FpFormatI16,
    _FpFormatI32,
    _FpFormatI64,
    _FpFormatU16,
    _FpFormatU32,
    _FpFormatU64,
    _FpFormatBcd80,
    _FpFormatCompare,
    _FpFormatString
} _FPIEEE_FORMAT;

/*
 * Define operation code values.
 */

typedef enum {
    _FpCodeUnspecified,
    _FpCodeAdd,
    _FpCodeSubtract,
    _FpCodeMultiply,
    _FpCodeDivide,
    _FpCodeSquareRoot,
    _FpCodeRemainder,
    _FpCodeCompare,
    _FpCodeConvert,
    _FpCodeRound,
    _FpCodeTruncate,
    _FpCodeFloor,
    _FpCodeCeil,
    _FpCodeAcos,
    _FpCodeAsin,
    _FpCodeAtan,
    _FpCodeAtan2,
    _FpCodeCabs,
    _FpCodeCos,
    _FpCodeCosh,
    _FpCodeExp,
    _FpCodeFabs,
    _FpCodeFmod,
    _FpCodeFrexp,
    _FpCodeHypot,
    _FpCodeLdexp,
    _FpCodeLog,
    _FpCodeLog10,
    _FpCodeModf,
    _FpCodePow,
    _FpCodeSin,
    _FpCodeSinh,
    _FpCodeTan,
    _FpCodeTanh,
    _FpCodeY0,
    _FpCodeY1,
    _FpCodeYn,
    _FpCodeLogb,
    _FpCodeNextafter,
    _FpCodeNegate

} _FP_OPERATION_CODE;


/*
 * Define rounding modes.
 */

typedef enum {
    _FpRoundNearest,
    _FpRoundMinusInfinity,
    _FpRoundPlusInfinity,
    _FpRoundChopped
} _FPIEEE_ROUNDING_MODE;

typedef enum {
    _FpPrecisionFull,
    _FpPrecision53,
    _FpPrecision24
} _FPIEEE_PRECISION;


/*
 * Define floating point context record
 */

typedef float		_FP32;
typedef double		_FP64;
typedef short		_I16;
typedef int		_I32;
typedef unsigned short	_U16;
typedef unsigned int	_U32;


typedef struct {
    unsigned short W[5];
} _FP80;

typedef struct {
    unsigned long W[4];
} _FP128;

typedef struct {
    unsigned long W[2];
} _I64;

typedef struct {
    unsigned long W[2];
} _U64;

typedef struct {
    unsigned short W[5];
} _BCD80;


typedef struct {
    union {
	_FP32	     Fp32Value;
	_FP64	     Fp64Value;
	_FP80	     Fp80Value;
	_FP128	     Fp128Value;
	_I16	     I16Value;
	_I32	     I32Value;
	_I64	     I64Value;
	_U16	     U16Value;
	_U32	     U32Value;
	_U64	     U64Value;
	_BCD80	     Bcd80Value;
	char	     *StringValue;
	int	     CompareValue;
    } Value;

    unsigned int OperandValid : 1;
    unsigned int Format : 4;

} _FPIEEE_VALUE;


typedef struct {
    unsigned int Inexact : 1;
    unsigned int Underflow : 1;
    unsigned int Overflow : 1;
    unsigned int ZeroDivide : 1;
    unsigned int InvalidOperation : 1;
} _FPIEEE_EXCEPTION_FLAGS;


typedef struct {
    unsigned int RoundingMode : 2;
    unsigned int Precision : 3;
    unsigned int Operation :12;
    _FPIEEE_EXCEPTION_FLAGS Cause;
    _FPIEEE_EXCEPTION_FLAGS Enable;
    _FPIEEE_EXCEPTION_FLAGS Status;
    _FPIEEE_VALUE Operand1;
    _FPIEEE_VALUE Operand2;
    _FPIEEE_VALUE Result;
} _FPIEEE_RECORD;


struct _EXCEPTION_POINTERS;

/*
 * Floating point IEEE exception filter routine
 */

_CRTIMP int __cdecl _fpieee_flt(
	unsigned long,
	struct _EXCEPTION_POINTERS *,
	int (__cdecl *)(_FPIEEE_RECORD *)
	);

#ifdef __cplusplus
}
#endif

#endif	/* _INC_FPIEEE */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\tools\c932\inc\float.h ===
/***
*float.h - constants for floating point values
*
*	Copyright (c) 1985-1994, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	This file contains defines for a number of implementation dependent
*	values which are commonly used by sophisticated numerical (floating
*	point) programs.
*	[ANSI]
*
****/

#ifndef _INC_FLOAT
#define _INC_FLOAT

#ifdef __cplusplus
extern "C" {
#endif


/* Define _CRTAPI1 (for compatibility with the NT SDK) */

#ifndef _CRTAPI1
#if	( (_MSC_VER >= 800) && (_M_IX86 >= 300) )
#define _CRTAPI1 __cdecl
#else
#define _CRTAPI1
#endif
#endif


/* Define _CRTAPI2 (for compatibility with the NT SDK) */

#ifndef _CRTAPI2
#if	( (_MSC_VER >= 800) && (_M_IX86 >= 300) )
#define _CRTAPI2 __cdecl
#else
#define _CRTAPI2
#endif
#endif


/* Define _CRTIMP */

#ifndef _CRTIMP
#ifdef	_NTSDK
/* definition compatible with NT SDK */
#define _CRTIMP
#else	/* ndef _NTSDK */
/* current definition */
#ifdef	_DLL
#define _CRTIMP __declspec(dllimport)
#else	/* ndef _DLL */
#define _CRTIMP
#endif	/* _DLL */
#endif	/* _NTSDK */
#endif	/* _CRTIMP */


/* Define __cdecl for non-Microsoft compilers */

#if	( !defined(_MSC_VER) && !defined(__cdecl) )
#define __cdecl
#endif


#define DBL_DIG 	15			/* # of decimal digits of precision */
#define DBL_EPSILON	2.2204460492503131e-016 /* smallest such that 1.0+DBL_EPSILON != 1.0 */
#define DBL_MANT_DIG	53			/* # of bits in mantissa */
#define DBL_MAX 	1.7976931348623158e+308 /* max value */
#define DBL_MAX_10_EXP	308			/* max decimal exponent */
#define DBL_MAX_EXP	1024			/* max binary exponent */
#define DBL_MIN 	2.2250738585072014e-308 /* min positive value */
#define DBL_MIN_10_EXP	(-307)			/* min decimal exponent */
#define DBL_MIN_EXP	(-1021) 		/* min binary exponent */
#define _DBL_RADIX	2			/* exponent radix */
#define _DBL_ROUNDS	1			/* addition rounding: near */

#define FLT_DIG 	6			/* # of decimal digits of precision */
#define FLT_EPSILON	1.192092896e-07F	/* smallest such that 1.0+FLT_EPSILON != 1.0 */
#define FLT_GUARD	0
#define FLT_MANT_DIG	24			/* # of bits in mantissa */
#define FLT_MAX 	3.402823466e+38F	/* max value */
#define FLT_MAX_10_EXP	38			/* max decimal exponent */
#define FLT_MAX_EXP	128			/* max binary exponent */
#define FLT_MIN 	1.175494351e-38F	/* min positive value */
#define FLT_MIN_10_EXP	(-37)			/* min decimal exponent */
#define FLT_MIN_EXP	(-125)			/* min binary exponent */
#define FLT_NORMALIZE	0
#define FLT_RADIX	2			/* exponent radix */
#define FLT_ROUNDS	1			/* addition rounding: near */

#define LDBL_DIG	DBL_DIG 		/* # of decimal digits of precision */
#define LDBL_EPSILON	DBL_EPSILON		/* smallest such that 1.0+LDBL_EPSILON != 1.0 */
#define LDBL_MANT_DIG	DBL_MANT_DIG		/* # of bits in mantissa */
#define LDBL_MAX	DBL_MAX 		/* max value */
#define LDBL_MAX_10_EXP DBL_MAX_10_EXP		/* max decimal exponent */
#define LDBL_MAX_EXP	DBL_MAX_EXP		/* max binary exponent */
#define LDBL_MIN	DBL_MIN 		/* min positive value */
#define LDBL_MIN_10_EXP DBL_MIN_10_EXP		/* min decimal exponent */
#define LDBL_MIN_EXP	DBL_MIN_EXP		/* min binary exponent */
#define _LDBL_RADIX	DBL_RADIX		/* exponent radix */
#define _LDBL_ROUNDS	DBL_ROUNDS		/* addition rounding: near */


/* Function prototypes */

_CRTIMP unsigned int __cdecl _clearfp(void);
_CRTIMP unsigned int __cdecl _controlfp(unsigned int,unsigned int);
_CRTIMP unsigned int __cdecl _statusfp(void);
_CRTIMP void __cdecl _fpreset(void);

#define _clear87	_clearfp
#define _status87	_statusfp

/*
 * Abstract User Control Word Mask and bit definitions
 */

#define _MCW_EM 	0x0008001f		/* interrupt Exception Masks */
#define _EM_INEXACT	0x00000001		/*   inexact (precision) */
#define _EM_UNDERFLOW	0x00000002		/*   underflow */
#define _EM_OVERFLOW	0x00000004		/*   overflow */
#define _EM_ZERODIVIDE	0x00000008		/*   zero divide */
#define _EM_INVALID	0x00000010		/*   invalid */

#define _MCW_RC 	0x00000300		/* Rounding Control */
#define _RC_NEAR	0x00000000		/*   near */
#define _RC_DOWN	0x00000100		/*   down */
#define _RC_UP		0x00000200		/*   up */
#define _RC_CHOP	0x00000300		/*   chop */

/*
 * Abstract User Status Word bit definitions
 */

#define _SW_INEXACT	0x00000001		/* inexact (precision) */
#define _SW_UNDERFLOW	0x00000002		/* underflow */
#define _SW_OVERFLOW	0x00000004		/* overflow */
#define _SW_ZERODIVIDE	0x00000008		/* zero divide */
#define _SW_INVALID	0x00000010		/* invalid */


/*
 * i386 specific definitions
 */

#define _MCW_PC 	0x00030000		/* Precision Control */
#define _PC_64		0x00000000		/*    64 bits */
#define _PC_53		0x00010000		/*    53 bits */
#define _PC_24		0x00020000		/*    24 bits */

#define _MCW_IC 	0x00040000		/* Infinity Control */
#define _IC_AFFINE	0x00040000		/*   affine */
#define _IC_PROJECTIVE	0x00000000		/*   projective */

#define _EM_DENORMAL	0x00080000		/* denormal exception mask (_control87 only) */

#define _SW_DENORMAL	0x00080000		/* denormal status bit */


_CRTIMP unsigned int __cdecl _control87(unsigned int,unsigned int);


/*
 * MIPS R4000 specific definitions
 */

#define _MCW_DN 	0x01000000		/* Denormal Control (R4000) */
#define _DN_FLUSH	0x01000000		/*   flush to zero */
#define _DN_SAVE	0x00000000		/*   save */


/* initial Control Word value */

#ifdef	_M_IX86

#define _CW_DEFAULT ( _RC_NEAR + _PC_64 + _EM_INVALID + _EM_ZERODIVIDE + _EM_OVERFLOW + _EM_UNDERFLOW + _EM_INEXACT )

#elif	defined(_M_MRX000) || defined (_M_ALPHA)

#define _CW_DEFAULT ( _RC_NEAR + _DN_FLUSH + _EM_INVALID + _EM_ZERODIVIDE + _EM_OVERFLOW + _EM_UNDERFLOW + _EM_INEXACT )

#endif

/* Global variable holding floating point error code */

#ifdef	_MT
_CRTIMP extern int * __cdecl __fpecode(void);
#define _fpecode	(*__fpecode())
#else
extern int _fpecode;
#endif

/* invalid subconditions (_SW_INVALID also set) */

#define _SW_UNEMULATED		0x0040	/* unemulated instruction */
#define _SW_SQRTNEG		0x0080	/* square root of a neg number */
#define _SW_STACKOVERFLOW	0x0200	/* FP stack overflow */
#define _SW_STACKUNDERFLOW	0x0400	/* FP stack underflow */

/*  Floating point error signals and return codes */

#define _FPE_INVALID		0x81
#define _FPE_DENORMAL		0x82
#define _FPE_ZERODIVIDE 	0x83
#define _FPE_OVERFLOW		0x84
#define _FPE_UNDERFLOW		0x85
#define _FPE_INEXACT		0x86

#define _FPE_UNEMULATED 	0x87
#define _FPE_SQRTNEG		0x88
#define _FPE_STACKOVERFLOW	0x8a
#define _FPE_STACKUNDERFLOW	0x8b

#define _FPE_EXPLICITGEN	0x8c	/* raise( SIGFPE ); */


/* IEEE recommended functions */

_CRTIMP double __cdecl _copysign (double, double);
_CRTIMP double __cdecl _chgsign (double);
_CRTIMP double __cdecl _scalb(double, long);
_CRTIMP double __cdecl _logb(double);
_CRTIMP double __cdecl _nextafter(double, double);
_CRTIMP int    __cdecl _finite(double);
_CRTIMP int    __cdecl _isnan(double);
_CRTIMP int    __cdecl _fpclass(double);

#define _FPCLASS_SNAN	0x0001	/* signaling NaN */
#define _FPCLASS_QNAN	0x0002	/* quiet NaN */
#define _FPCLASS_NINF	0x0004	/* negative infinity */
#define _FPCLASS_NN	0x0008	/* negative normal */
#define _FPCLASS_ND	0x0010	/* negative denormal */
#define _FPCLASS_NZ	0x0020	/* -0 */
#define _FPCLASS_PZ	0x0040	/* +0 */
#define _FPCLASS_PD	0x0080	/* positive denormal */
#define _FPCLASS_PN	0x0100	/* positive normal */
#define _FPCLASS_PINF	0x0200	/* positive infinity */


#if	!__STDC__

/* Non-ANSI names for compatibility */

#ifdef	_NTSDK

#define clear87			_clear87
#define status87		_status87
#define control87		_control87
#define fpreset			_fpreset

#else	/* ndef _NTSDK */

_CRTIMP unsigned int __cdecl clear87(void);
_CRTIMP unsigned int __cdecl control87(unsigned int,unsigned int);
_CRTIMP unsigned int __cdecl status87(void);
_CRTIMP void __cdecl fpreset(void);

#endif	/* _NTSDK */

#define DBL_RADIX		_DBL_RADIX
#define DBL_ROUNDS		_DBL_ROUNDS

#define LDBL_RADIX		_LDBL_RADIX
#define LDBL_ROUNDS		_LDBL_ROUNDS

#define MCW_EM			_MCW_EM
#define EM_INVALID		_EM_INVALID
#define EM_DENORMAL		_EM_DENORMAL
#define EM_ZERODIVIDE		_EM_ZERODIVIDE
#define EM_OVERFLOW		_EM_OVERFLOW
#define EM_UNDERFLOW		_EM_UNDERFLOW
#define EM_INEXACT		_EM_INEXACT

#define MCW_IC			_MCW_IC
#define IC_AFFINE		_IC_AFFINE
#define IC_PROJECTIVE		_IC_PROJECTIVE

#define MCW_RC			_MCW_RC
#define RC_CHOP 		_RC_CHOP
#define RC_UP			_RC_UP
#define RC_DOWN 		_RC_DOWN
#define RC_NEAR 		_RC_NEAR

#define MCW_PC			_MCW_PC
#define PC_24			_PC_24
#define PC_53			_PC_53
#define PC_64			_PC_64

#define CW_DEFAULT		_CW_DEFAULT

#define SW_INVALID		_SW_INVALID
#define SW_DENORMAL		_SW_DENORMAL
#define SW_ZERODIVIDE		_SW_ZERODIVIDE
#define SW_OVERFLOW		_SW_OVERFLOW
#define SW_UNDERFLOW		_SW_UNDERFLOW
#define SW_INEXACT		_SW_INEXACT

#define SW_UNEMULATED		_SW_UNEMULATED
#define SW_SQRTNEG		_SW_SQRTNEG
#define SW_STACKOVERFLOW	_SW_STACKOVERFLOW
#define SW_STACKUNDERFLOW	_SW_STACKUNDERFLOW

#define FPE_INVALID		_FPE_INVALID
#define FPE_DENORMAL		_FPE_DENORMAL
#define FPE_ZERODIVIDE		_FPE_ZERODIVIDE
#define FPE_OVERFLOW		_FPE_OVERFLOW
#define FPE_UNDERFLOW		_FPE_UNDERFLOW
#define FPE_INEXACT		_FPE_INEXACT

#define FPE_UNEMULATED		_FPE_UNEMULATED
#define FPE_SQRTNEG		_FPE_SQRTNEG
#define FPE_STACKOVERFLOW	_FPE_STACKOVERFLOW
#define FPE_STACKUNDERFLOW	_FPE_STACKUNDERFLOW

#define FPE_EXPLICITGEN 	_FPE_EXPLICITGEN

#endif	/* __STDC__ */

#ifdef __cplusplus
}
#endif

#endif	/* _INC_FLOAT */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\tools\c932\inc\excpt.h ===
/***
*excpt.h - defines exception values, types and routines
*
*	Copyright (c) 1990-1994, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	This file contains the definitions and prototypes for the compiler-
*	dependent intrinsics, support functions and keywords which implement
*	the structured exception handling extensions.
*
****/

#ifndef _INC_EXCPT
#define _INC_EXCPT

#ifdef __cplusplus
extern "C" {
#endif


/* Define _CRTAPI1 (for compatibility with the NT SDK) */

#ifndef _CRTAPI1
#if	( (_MSC_VER >= 800) && (_M_IX86 >= 300) )
#define _CRTAPI1 __cdecl
#else
#define _CRTAPI1
#endif
#endif


/* Define _CRTAPI2 (for compatibility with the NT SDK) */

#ifndef _CRTAPI2
#if	( (_MSC_VER >= 800) && (_M_IX86 >= 300) )
#define _CRTAPI2 __cdecl
#else
#define _CRTAPI2
#endif
#endif


/* Define _CRTIMP */

#ifndef _CRTIMP
#ifdef	_NTSDK
/* definition compatible with NT SDK */
#define _CRTIMP
#else	/* ndef _NTSDK */
/* current definition */
#ifdef	_DLL
#define _CRTIMP __declspec(dllimport)
#else	/* ndef _DLL */
#define _CRTIMP
#endif	/* _DLL */
#endif	/* _NTSDK */
#endif	/* _CRTIMP */


/* Define __cdecl for non-Microsoft compilers */

#if	( !defined(_MSC_VER) && !defined(__cdecl) )
#define __cdecl
#endif


/*
 * Exception disposition return values.
 */
typedef enum _EXCEPTION_DISPOSITION {
    ExceptionContinueExecution,
    ExceptionContinueSearch,
    ExceptionNestedException,
    ExceptionCollidedUnwind
} EXCEPTION_DISPOSITION;


/*
 * Prototype for SEH support function.
 */

#ifdef	_M_IX86

/*
 * Declarations to keep MS C 8 (386/486) compiler happy
 */
struct _EXCEPTION_RECORD;
struct _CONTEXT;

EXCEPTION_DISPOSITION __cdecl _except_handler (
	struct _EXCEPTION_RECORD *ExceptionRecord,
	void * EstablisherFrame,
	struct _CONTEXT *ContextRecord,
	void * DispatcherContext
	);

#elif	defined(_M_MRX000) || defined(_M_ALPHA)

/*
 * Declarations to keep MIPS and ALPHA compiler happy
 */
typedef struct _EXCEPTION_POINTERS *Exception_info_ptr;
struct _EXCEPTION_RECORD;
struct _CONTEXT;
struct _DISPATCHER_CONTEXT;


EXCEPTION_DISPOSITION __C_specific_handler (
	struct _EXCEPTION_RECORD *ExceptionRecord,
	void *EstablisherFrame,
	struct _CONTEXT *ContextRecord,
	struct _DISPATCHER_CONTEXT *DispatcherContext
	);

#endif


/*
 * Keywords and intrinsics for SEH
 */

#ifdef	_MSC_VER

#if	defined(_NTSDK) && !defined(__cplusplus)
#define try				__try
#define except				__except
#define finally 			__finally
#define leave				__leave
#endif	/* _NTSDK */
#define GetExceptionCode		_exception_code
#define exception_code			_exception_code
#define GetExceptionInformation 	(struct _EXCEPTION_POINTERS *)_exception_info
#define exception_info			(struct _EXCEPTION_POINTERS *)_exception_info
#define AbnormalTermination		_abnormal_termination
#define abnormal_termination		_abnormal_termination

unsigned long __cdecl _exception_code(void);
void *	      __cdecl _exception_info(void);
int	      __cdecl _abnormal_termination(void);

#endif


/*
 * Legal values for expression in except().
 */

#define EXCEPTION_EXECUTE_HANDLER	 1
#define EXCEPTION_CONTINUE_SEARCH	 0
#define EXCEPTION_CONTINUE_EXECUTION	-1



#ifdef __cplusplus
}
#endif

#endif	/* _INC_EXCPT */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\tools\c932\inc\fstream.h ===
/***
*fstream.h - definitions/declarations for filebuf and fstream classes
*
*	Copyright (c) 1991-1994, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*	This file defines the classes, values, macros, and functions
*	used by the filebuf and fstream classes.
*	[AT&T C++]
*
****/

#ifndef _INC_FSTREAM
#define _INC_FSTREAM


/* Define _CRTIMP */

#ifndef _CRTIMP
#ifdef	_NTSDK
/* definition compatible with NT SDK */
#define _CRTIMP
#else	/* ndef _NTSDK */
/* current definition */
#ifdef	_DLL
#define _CRTIMP __declspec(dllimport)
#else	/* ndef _DLL */
#define _CRTIMP
#endif	/* _DLL */
#endif	/* _NTSDK */
#endif	/* _CRTIMP */


#include <iostream.h>

#ifdef _MSC_VER
// C4505: "unreferenced local function has been removed"
#pragma warning(disable:4505) // disable C4505 warning
// #pragma warning(default:4505)	// use this to reenable, if desired

// Force word packing to avoid possible -Zp override
#pragma pack(push,4)
#endif	// _MSC_VER

typedef int filedesc;

class _CRTIMP filebuf : public streambuf {
public:
static	const int	openprot;	// default share/prot mode for open

// optional share values for 3rd argument (prot) of open or constructor
static	const int	sh_none;	// exclusive mode no sharing
static	const int	sh_read;	// allow read sharing
static	const int	sh_write;	// allow write sharing
// use (sh_read | sh_write) to allow both read and write sharing

// options for setmode member function
static	const int	binary;
static	const int	text;

			filebuf();
			filebuf(filedesc);
			filebuf(filedesc, char *, int);
			~filebuf();

	filebuf*	attach(filedesc);
	filedesc	fd() const { return (x_fd==-1) ? EOF : x_fd; }
	int		is_open() const { return (x_fd!=-1); }
	filebuf*	open(const char *, int, int = filebuf::openprot);
	filebuf*	close();
	int		setmode(int = filebuf::text);

virtual	int		overflow(int=EOF);
virtual	int		underflow();

virtual	streambuf*	setbuf(char *, int);
virtual	streampos	seekoff(streamoff, ios::seek_dir, int);
// virtual	streampos	seekpos(streampos, int);
virtual	int		sync();

private:
	filedesc	x_fd;
	int		x_fOpened;
};

class _CRTIMP ifstream : public istream {
public:
	ifstream();
	ifstream(const char *, int =ios::in, int = filebuf::openprot);
	ifstream(filedesc);
	ifstream(filedesc, char *, int);
	~ifstream();

	streambuf * setbuf(char *, int);
	filebuf* rdbuf() const { return (filebuf*) ios::rdbuf(); }

	void attach(filedesc);
	filedesc fd() const { return rdbuf()->fd(); }

	int is_open() const { return rdbuf()->is_open(); }
	void open(const char *, int =ios::in, int = filebuf::openprot);
	void close();
	int setmode(int mode = filebuf::text) { return rdbuf()->setmode(mode); }
};

class _CRTIMP ofstream : public ostream {
public:
	ofstream();
	ofstream(const char *, int =ios::out, int = filebuf::openprot);
	ofstream(filedesc);
	ofstream(filedesc, char *, int);
	~ofstream();

	streambuf * setbuf(char *, int);
	filebuf* rdbuf() const { return (filebuf*) ios::rdbuf(); }

	void attach(filedesc);
	filedesc fd() const { return rdbuf()->fd(); }

	int is_open() const { return rdbuf()->is_open(); }
	void open(const char *, int =ios::out, int = filebuf::openprot);
	void close();
	int setmode(int mode = filebuf::text) { return rdbuf()->setmode(mode); }
};
	
class _CRTIMP fstream : public iostream {
public:
	fstream();
	fstream(const char *, int, int = filebuf::openprot);
	fstream(filedesc);
	fstream(filedesc, char *, int);
	~fstream();

	streambuf * setbuf(char *, int);
	filebuf* rdbuf() const { return (filebuf*) ostream::rdbuf(); }

	void attach(filedesc);
	filedesc fd() const { return rdbuf()->fd(); }

	int is_open() const { return rdbuf()->is_open(); }
	void open(const char *, int, int = filebuf::openprot);
	void close();
	int setmode(int mode = filebuf::text) { return rdbuf()->setmode(mode); }
};
	
// manipulators to dynamically change file access mode (filebufs only)
inline	ios& binary(ios& _fstrm) \
   { ((filebuf*)_fstrm.rdbuf())->setmode(filebuf::binary); return _fstrm; }
inline	ios& text(ios& _fstrm) \
   { ((filebuf*)_fstrm.rdbuf())->setmode(filebuf::text); return _fstrm; }

#ifdef	_MSC_VER
// Restore previous packing
#pragma pack(pop)
#endif	// _MSC_VER

#endif		// !_INC_FSTREAM
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\tools\c932\inc\fcntl.h ===
/***
*fcntl.h - file control options used by open()
*
*	Copyright (c) 1985-1994, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	This file defines constants for the file control options used
*	by the _open() function.
*	[System V]
*
****/

#ifndef _INC_FCNTL
#define _INC_FCNTL

#define _O_RDONLY	0x0000	/* open for reading only */
#define _O_WRONLY	0x0001	/* open for writing only */
#define _O_RDWR 	0x0002	/* open for reading and writing */
#define _O_APPEND	0x0008	/* writes done at eof */

#define _O_CREAT	0x0100	/* create and open file */
#define _O_TRUNC	0x0200	/* open and truncate */
#define _O_EXCL 	0x0400	/* open only if file doesn't already exist */

/* O_TEXT files have <cr><lf> sequences translated to <lf> on read()'s,
** and <lf> sequences translated to <cr><lf> on write()'s
*/

#define _O_TEXT 	0x4000	/* file mode is text (translated) */
#define _O_BINARY	0x8000	/* file mode is binary (untranslated) */

/* macro to translate the C 2.0 name used to force binary mode for files */

#define _O_RAW	_O_BINARY

/* Open handle inherit bit */

#define _O_NOINHERIT	0x0080	/* child process doesn't inherit file */

/* Temporary file bit - file is deleted when last handle is closed */

#define _O_TEMPORARY	0x0040	/* temporary file bit */

/* temporary access hint */

#define _O_SHORT_LIVED	0x1000	/* temporary storage file, try not to flush */

/* sequential/random access hints */

#define _O_SEQUENTIAL	0x0020	/* file access is primarily sequential */
#define _O_RANDOM	0x0010	/* file access is primarily random */

#if !__STDC__ || defined(_POSIX_)
/* Non-ANSI names for compatibility */
#define O_RDONLY	_O_RDONLY
#define O_WRONLY	_O_WRONLY
#define O_RDWR		_O_RDWR
#define O_APPEND	_O_APPEND
#define O_CREAT 	_O_CREAT
#define O_TRUNC 	_O_TRUNC
#define O_EXCL		_O_EXCL
#define O_TEXT		_O_TEXT
#define O_BINARY	_O_BINARY
#define O_RAW		_O_BINARY
#define O_TEMPORARY	_O_TEMPORARY
#define O_NOINHERIT	_O_NOINHERIT
#define O_SEQUENTIAL	_O_SEQUENTIAL
#define O_RANDOM	_O_RANDOM
#endif /* __STDC__ */

#endif /* _INC_FCNTL */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\tools\c932\inc\io.h ===
/***
*io.h - declarations for low-level file handling and I/O functions
*
*	Copyright (c) 1985-1994, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	This file contains the function declarations for the low-level
*	file handling and I/O functions.
*
****/

#ifndef _INC_IO
#define _INC_IO

#ifndef _POSIX_

#ifdef __cplusplus
extern "C" {
#endif


/* Define _CRTAPI1 (for compatibility with the NT SDK) */

#ifndef _CRTAPI1
#if	( (_MSC_VER >= 800) && (_M_IX86 >= 300) )
#define _CRTAPI1 __cdecl
#else
#define _CRTAPI1
#endif
#endif


/* Define _CRTAPI2 (for compatibility with the NT SDK) */

#ifndef _CRTAPI2
#if	( (_MSC_VER >= 800) && (_M_IX86 >= 300) )
#define _CRTAPI2 __cdecl
#else
#define _CRTAPI2
#endif
#endif


/* Define _CRTIMP */

#ifndef _CRTIMP
#ifdef	_NTSDK
/* definition compatible with NT SDK */
#define _CRTIMP
#else	/* ndef _NTSDK */
/* current definition */
#ifdef	_DLL
#define _CRTIMP __declspec(dllimport)
#else	/* ndef _DLL */
#define _CRTIMP
#endif	/* _DLL */
#endif	/* _NTSDK */
#endif	/* _CRTIMP */


/* Define __cdecl for non-Microsoft compilers */

#if	( !defined(_MSC_VER) && !defined(__cdecl) )
#define __cdecl
#endif

#ifndef _WCHAR_T_DEFINED
typedef unsigned short wchar_t;
#define _WCHAR_T_DEFINED
#endif

#ifndef _TIME_T_DEFINED
typedef long time_t;		/* time value */
#define _TIME_T_DEFINED 	/* avoid multiple def's of time_t */
#endif

#ifndef _FSIZE_T_DEFINED
typedef unsigned long _fsize_t; /* Could be 64 bits for Win32 */
#define _FSIZE_T_DEFINED
#endif

#ifndef _FINDDATA_T_DEFINED

struct _finddata_t {
    unsigned	attrib;
    time_t	time_create;	/* -1 for FAT file systems */
    time_t	time_access;	/* -1 for FAT file systems */
    time_t	time_write;
    _fsize_t	size;
    char	name[260];
};

#define _FINDDATA_T_DEFINED
#endif

#ifndef _WFINDDATA_T_DEFINED

struct _wfinddata_t {
    unsigned	attrib;
    time_t	time_create;	/* -1 for FAT file systems */
    time_t	time_access;	/* -1 for FAT file systems */
    time_t	time_write;
    _fsize_t	size;
    wchar_t	name[260];
};

#define _WFINDDATA_T_DEFINED
#endif

/* File attribute constants for _findfirst() */

#define _A_NORMAL	0x00	/* Normal file - No read/write restrictions */
#define _A_RDONLY	0x01	/* Read only file */
#define _A_HIDDEN	0x02	/* Hidden file */
#define _A_SYSTEM	0x04	/* System file */
#define _A_SUBDIR	0x10	/* Subdirectory */
#define _A_ARCH 	0x20	/* Archive file */

/* function prototypes */

_CRTIMP int __cdecl _access(const char *, int);
_CRTIMP int __cdecl _chmod(const char *, int);
_CRTIMP int __cdecl _chsize(int, long);
_CRTIMP int __cdecl _close(int);
_CRTIMP int __cdecl _commit(int);
_CRTIMP int __cdecl _creat(const char *, int);
_CRTIMP int __cdecl _dup(int);
_CRTIMP int __cdecl _dup2(int, int);
_CRTIMP int __cdecl _eof(int);
_CRTIMP long __cdecl _filelength(int);
_CRTIMP long __cdecl _findfirst(char *, struct _finddata_t *);
_CRTIMP int __cdecl _findnext(long, struct _finddata_t *);
_CRTIMP int __cdecl _findclose(long);
_CRTIMP int __cdecl _isatty(int);
_CRTIMP int __cdecl _locking(int, int, long);
_CRTIMP long __cdecl _lseek(int, long, int);
_CRTIMP char * __cdecl _mktemp(char *);
_CRTIMP int __cdecl _open(const char *, int, ...);
_CRTIMP int __cdecl _pipe(int *, unsigned int, int);
_CRTIMP int __cdecl _read(int, void *, unsigned int);
_CRTIMP int __cdecl remove(const char *);
_CRTIMP int __cdecl rename(const char *, const char *);
_CRTIMP int __cdecl _setmode(int, int);
_CRTIMP int __cdecl _sopen(const char *, int, int, ...);
_CRTIMP long __cdecl _tell(int);
_CRTIMP int __cdecl _umask(int);
_CRTIMP int __cdecl _unlink(const char *);
_CRTIMP int __cdecl _write(int, const void *, unsigned int);


#ifndef _WIO_DEFINED

/* wide function prototypes, also declared in wchar.h  */

_CRTIMP int __cdecl _waccess(const wchar_t *, int);
_CRTIMP int __cdecl _wchmod(const wchar_t *, int);
_CRTIMP int __cdecl _wcreat(const wchar_t *, int);
_CRTIMP long __cdecl _wfindfirst(wchar_t *, struct _wfinddata_t *);
_CRTIMP int __cdecl _wfindnext(long, struct _wfinddata_t *);
_CRTIMP int __cdecl _wunlink(const wchar_t *);
_CRTIMP int __cdecl _wrename(const wchar_t *, const wchar_t *);
_CRTIMP int __cdecl _wopen(const wchar_t *, int, ...);
_CRTIMP int __cdecl _wsopen(const wchar_t *, int, int, ...);
_CRTIMP wchar_t * __cdecl _wmktemp(wchar_t *);

#define _WIO_DEFINED
#endif


_CRTIMP long __cdecl _get_osfhandle(int);
_CRTIMP int __cdecl _open_osfhandle(long, int);

#if	!__STDC__

/* Non-ANSI names for compatibility */

#ifdef	_NTSDK

#ifndef __cplusplus
#define access	   _access
#define chmod	   _chmod
#define chsize	   _chsize
#define close	   _close
#define creat	   _creat
#define dup	   _dup
#define dup2	   _dup2
#define eof	   _eof
#define filelength _filelength
#define isatty	   _isatty
#define locking    _locking
#define lseek	   _lseek
#define mktemp	   _mktemp
#define open	   _open
#define read	   _read
#define setmode    _setmode
#define sopen	   _sopen
#define tell	   _tell
#define umask	   _umask
#define unlink	   _unlink
#define write	   _write
#endif	/* __cplusplus */

#else	/* ndef _NTSDK */

_CRTIMP int __cdecl access(const char *, int);
_CRTIMP int __cdecl chmod(const char *, int);
_CRTIMP int __cdecl chsize(int, long);
_CRTIMP int __cdecl close(int);
_CRTIMP int __cdecl creat(const char *, int);
_CRTIMP int __cdecl dup(int);
_CRTIMP int __cdecl dup2(int, int);
_CRTIMP int __cdecl eof(int);
_CRTIMP long __cdecl filelength(int);
_CRTIMP int __cdecl isatty(int);
_CRTIMP int __cdecl locking(int, int, long);
_CRTIMP long __cdecl lseek(int, long, int);
_CRTIMP char * __cdecl mktemp(char *);
_CRTIMP int __cdecl open(const char *, int, ...);
_CRTIMP int __cdecl read(int, void *, unsigned int);
_CRTIMP int __cdecl setmode(int, int);
_CRTIMP int __cdecl sopen(const char *, int, int, ...);
_CRTIMP long __cdecl tell(int);
_CRTIMP int __cdecl umask(int);
_CRTIMP int __cdecl unlink(const char *);
_CRTIMP int __cdecl write(int, const void *, unsigned int);

#endif	/* _NTSDK */

#endif	/* __STDC__ */

#ifdef __cplusplus
}
#endif

#endif	/* _POSIX_ */

#endif	/* _INC_IO */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\tools\c932\inc\iomanip.h ===
/***
*iomanip.h - definitions/declarations for iostream's parameterized manipulators
*
*	Copyright (c) 1991-1994, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*	This file defines the classes, values, macros, and functions
*	used by the iostream classes' paramterized manipulators.
*	[AT&T C++]
*
****/

#ifndef _INC_IOMANIP
#define _INC_IOMANIP
#include <iostream.h>

#ifdef	_MSC_VER
// Force word packing to avoid possible -Zp override
#pragma pack(push,4)

#pragma warning(disable:4505)		// disable unwanted /W4 warning
// #pragma warning(default:4505)	// use this to reenable, if necessary
#endif	// _MSC_VER

// CONSIDER: use macro to define these
// #define __MKMANIP(X) \#define X##(T) __##X##_ \#\# T
// __MKMANIP(SMANIP);
// __MKMANIP(SAPP);
// __MKMANIP(IMANIP);
// __MKMANIP(IAPP);
// __MKMANIP(OMANIP);
// __MKMANIP(OAPP);
// __MKMANIP(IOMANIP);
// __MKMANIP(IOAPP);

#define SMANIP(T) __SMANIP_##T
#define SAPP(T) __SAPP_##T
#define IMANIP(T) __IMANIP_##T
#define IAPP(T) __IAPP_##T
#define OMANIP(T) __OMANIP_##T
#define OAPP(T) __OAPP_##T
#define IOMANIP(T) __IOMANIP_##T
#define IOAPP(T) __IOAPP_##T

#define IOMANIPdeclare(T)  \
class SMANIP(T) { \
public:	\
	SMANIP(T)(ios& (*f)(ios&,T), T t) { _fp = f; _tp = t; } \
	friend istream& operator>>(istream& s, const SMANIP(T) & sm) { (*(sm._fp))(s,sm._tp); return s; } \
	friend ostream& operator<<(ostream& s, const SMANIP(T) & sm) { (*(sm._fp))(s,sm._tp); return s; } \
private:	\
	ios& (* _fp)(ios&,T); \
	T _tp; \
};	\
class SAPP(T) {	\
public:	\
	SAPP(T)( ios& (*f)(ios&,T)) { _fp = f; }	\
	SMANIP(T) operator()(T t) { return SMANIP(T)(_fp,t); } 	\
private:	\
	ios& (* _fp)(ios&,T); \
};	\
class IMANIP(T) { \
public:	\
	IMANIP(T)(istream& (*f)(istream&,T), T t) { _fp = f; _tp = t; } \
	friend istream& operator>>(istream& s, IMANIP(T) & sm) { (*sm._fp)(s,sm._tp); return s; } \
private:	\
	istream& (* _fp)(istream&,T); \
	T _tp;	\
};	\
class IAPP(T) {	\
public:	\
	IAPP(T)( istream& (*f)(istream&,T)) { _fp = f; }	\
	IMANIP(T) operator()(T t) { return IMANIP(T)(_fp,t); } 	\
private:	\
	istream& (* _fp)(istream&,T); \
};	\
class OMANIP(T) { \
public:	\
	OMANIP(T)(ostream& (*f)(ostream&,T), T t) { _fp = f; _tp = t; } \
	friend ostream& operator<<(ostream& s, OMANIP(T) & sm) { (*sm._fp)(s,sm._tp); return s; } \
private:	\
	ostream& (* _fp)(ostream&,T); \
	T _tp; \
};	\
class OAPP(T) {	\
public:	\
	OAPP(T)(ostream& (*f)(ostream&,T)) { _fp = f; }	\
	OMANIP(T) operator()(T t) { return OMANIP(T)(_fp,t); } \
private:	\
	ostream& (* _fp)(ostream&,T); \
};	\
\
class IOMANIP(T) { \
public:	\
	IOMANIP(T)(iostream& (*f)(iostream&,T), T t) { _fp = f; _tp = t; } \
	friend istream& operator>>(iostream& s, IOMANIP(T) & sm) { (*sm._fp)(s,sm._tp); return s; } \
	friend ostream& operator<<(iostream& s, IOMANIP(T) & sm) { (*sm._fp)(s,sm._tp); return s; } \
private:	\
	iostream& (* _fp)(iostream&,T); \
	T _tp; \
};	\
class IOAPP(T) {	\
public:	\
	IOAPP(T)( iostream& (*f)(iostream&,T)) { _fp = f; }	\
	IOMANIP(T) operator()(T t) { return IOMANIP(T)(_fp,t); } 	\
private:	\
	iostream& (* _fp)(iostream&,T); \
}; \

	
IOMANIPdeclare(int)

IOMANIPdeclare(long)

inline ios& __resetiosflags(ios& s, long _flg) { s.setf(0,_flg); return s; }
inline ios& __setfill(ios& s, int _fc) { s.fill((char)_fc); return s; }
inline ios& __setiosflags(ios& s, long _flg) { s.setf(_flg); return s; }
inline ios& __setprecision(ios& s, int _pre) { s.precision(_pre); return s; }
inline ios& __setw(ios& s, int _wid) { s.width(_wid); return s; }

inline SMANIP(long)	resetiosflags(long _l) { return SMANIP(long)(__resetiosflags, _l); }
inline SMANIP(int)	setfill(int _m) {return SMANIP(int)(__setfill, _m); }
inline SMANIP(long)	setiosflags(long _l) {return SMANIP(long)(__setiosflags, _l); }
inline SMANIP(int)	setprecision(int _p) {return SMANIP(int)(__setprecision, _p); }
inline SMANIP(int)	setw(int _w) { return SMANIP(int)(__setw, _w); }

// Restore previous packing
#ifdef	_MSC_VER
#pragma pack(pop)
#endif	// _MSC_VER

#endif		// !_INC_IOMANIP
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\tools\c932\inc\ios.h ===
/***
*ios.h - definitions/declarations for the ios class.
*
*	Copyright (c) 1990-1994, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*	This file defines the classes, values, macros, and functions
*	used by the ios class.
*	[AT&T C++]
*
****/

#ifndef _INC_IOS
#define _INC_IOS


/* Define _CRTIMP */

#ifndef _CRTIMP
#ifdef	_NTSDK
/* definition compatible with NT SDK */
#define _CRTIMP
#else	/* ndef _NTSDK */
/* current definition */
#ifdef	_DLL
#define _CRTIMP __declspec(dllimport)
#else	/* ndef _DLL */
#define _CRTIMP
#endif	/* _DLL */
#endif	/* _NTSDK */
#endif	/* _CRTIMP */


#ifdef	_MT
#include <windows.h>   // critical section declarations

extern "C" {
_CRTIMP void __cdecl _mtlock(PRTL_CRITICAL_SECTION);
_CRTIMP void __cdecl _mtunlock(PRTL_CRITICAL_SECTION);
}
#endif

#ifndef NULL
#define NULL	0
#endif

#ifndef EOF
#define EOF	(-1)
#endif

#ifdef	_MSC_VER
// C4505: "unreferenced local function has been removed"
#pragma warning(disable:4505) // disable C4505 warning
// #pragma warning(default:4505)	// use this to reenable, if desired

// Force word packing to avoid possible -Zp override
#pragma pack(push,4)
#endif	// _MSC_VER

class _CRTIMP streambuf;
class _CRTIMP ostream;

class _CRTIMP ios {

public:
    enum io_state {  goodbit = 0x00,
		     eofbit  = 0x01,
		     failbit = 0x02,
		     badbit  = 0x04 };

    enum open_mode { in        = 0x01,
		     out       = 0x02,
		     ate       = 0x04,
		     app       = 0x08,
		     trunc     = 0x10,
		     nocreate  = 0x20,
		     noreplace = 0x40,
		     binary    = 0x80 };	// CONSIDER: not in latest spec.

    enum seek_dir { beg=0, cur=1, end=2 };

    enum {  skipws     = 0x0001,
	    left       = 0x0002,
	    right      = 0x0004,
	    internal   = 0x0008,
	    dec        = 0x0010,
	    oct        = 0x0020,
	    hex        = 0x0040,
	    showbase   = 0x0080,
	    showpoint  = 0x0100,
	    uppercase  = 0x0200,
	    showpos    = 0x0400,
	    scientific = 0x0800,
	    fixed      = 0x1000,
	    unitbuf    = 0x2000,
	    stdio      = 0x4000
				 };

    static const long basefield;	// dec | oct | hex
    static const long adjustfield;	// left | right | internal
    static const long floatfield;	// scientific | fixed

    ios(streambuf*);			// differs from ANSI
    virtual ~ios();

    inline long flags() const;
    inline long flags(long _l);

    inline long setf(long _f,long _m);
    inline long setf(long _l);
    inline long unsetf(long _l);

    inline int width() const;
    inline int width(int _i);

    inline ostream* tie(ostream* _os);
    inline ostream* tie() const;

    inline char fill() const;
    inline char fill(char _c);

    inline int precision(int _i);
    inline int precision() const;

    inline int rdstate() const;
    inline void clear(int _i = 0);

//  inline operator void*() const;
    operator void *() const { if(state&(badbit|failbit) ) return 0; return (void *)this; }
    inline int operator!() const;

    inline int  good() const;
    inline int  eof() const;
    inline int  fail() const;
    inline int  bad() const;

    inline streambuf* rdbuf() const;

    inline long & iword(int) const;
    inline void * & pword(int) const;

    static long bitalloc();
    static int xalloc();
    static void sync_with_stdio();

#ifdef	_MT
    inline void __cdecl setlock();
    inline void __cdecl clrlock();
    void __cdecl lock() { if (LockFlg<0) _mtlock(lockptr()); };
    void __cdecl unlock() { if (LockFlg<0) _mtunlock(lockptr()); }
    inline void __cdecl lockbuf();
    inline void __cdecl unlockbuf();
#else
    void __cdecl lock() { }
    void __cdecl unlock() { }
    void __cdecl lockbuf() { }
    void __cdecl unlockbuf() { }
#endif

protected:
    ios();
    ios(const ios&);			// treat as private
    ios& operator=(const ios&);
    void init(streambuf*);

    enum { skipping, tied };
    streambuf*	bp;

    int     state;
    int     ispecial;			// not used
    int     ospecial;			// not used
    int     isfx_special;		// not used
    int     osfx_special;		// not used
    int     x_delbuf;			// if set, rdbuf() deleted by ~ios

    ostream* x_tie;
    long    x_flags;
    int     x_precision;
    char    x_fill;
    int     x_width;

    static void (*stdioflush)();	// not used

#ifdef	_MT
    static void lockc() { _mtlock(& x_lockc); }
    static void unlockc() { _mtunlock( & x_lockc); }
    PRTL_CRITICAL_SECTION lockptr() { return & x_lock; }
#else
    static void lockc() { }
    static void unlockc() { }
#endif

public:
    int	delbuf() const { return x_delbuf; }
    void    delbuf(int _i) { x_delbuf = _i; }

private:
    static long x_maxbit;
    static int x_curindex;
// consider: make interal static to ios::sync_with_stdio()
    static int sunk_with_stdio;		// make sure sync_with done only once
#ifdef	_MT
#define MAXINDEX 7
    static long x_statebuf[MAXINDEX+1];  // used by xalloc()
    static int fLockcInit;		// used to see if x_lockc initialized
    static RTL_CRITICAL_SECTION x_lockc; // used to lock static (class) data members
// consider: make pointer and allocate elsewhere
    int LockFlg;			// enable locking flag
    RTL_CRITICAL_SECTION x_lock;	// used for multi-thread lock on object
#else
    static long * x_statebuf;  // used by xalloc()
#endif
};

#include <streamb.h>

inline _CRTIMP ios& __cdecl dec(ios& _strm) { _strm.setf(ios::dec,ios::basefield); return _strm; }
inline _CRTIMP ios& __cdecl hex(ios& _strm) { _strm.setf(ios::hex,ios::basefield); return _strm; }
inline _CRTIMP ios& __cdecl oct(ios& _strm) { _strm.setf(ios::oct,ios::basefield); return _strm; }

inline long ios::flags() const { return x_flags; }
inline long ios::flags(long _l){ long _lO; _lO = x_flags; x_flags = _l; return _lO; }

inline long ios::setf(long _l,long _m){ long _lO; lock(); _lO = x_flags; x_flags = (_l&_m) | (x_flags&(~_m)); unlock(); return _lO; }
inline long ios::setf(long _l){ long _lO; lock(); _lO = x_flags; x_flags |= _l; unlock(); return _lO; }
inline long ios::unsetf(long _l){ long _lO; lock(); _lO = x_flags; x_flags &= (~_l); unlock(); return _lO; }

inline int ios::width() const { return x_width; }
inline int ios::width(int _i){ int _iO; _iO = (int)x_width; x_width = _i; return _iO; }

inline ostream* ios::tie(ostream* _os){ ostream* _osO; _osO = x_tie; x_tie = _os; return _osO; }
inline ostream* ios::tie() const { return x_tie; }
inline char ios::fill() const { return x_fill; }
inline char ios::fill(char _c){ char _cO; _cO = x_fill; x_fill = _c; return _cO; }
inline int ios::precision(int _i){ int _iO; _iO = (int)x_precision; x_precision = _i; return _iO; }
inline int ios::precision() const { return x_precision; }

inline int ios::rdstate() const { return state; }

// inline ios::operator void *() const { if(state&(badbit|failbit) ) return 0; return (void *)this; }
inline int ios::operator!() const { return state&(badbit|failbit); }

inline int  ios::bad() const { return state & badbit; }
// consider: are locks needed on clear() ?
inline void ios::clear(int _i){ lock(); state = _i; unlock(); }
inline int  ios::eof() const { return state & eofbit; }
inline int  ios::fail() const { return state & (badbit | failbit); }
inline int  ios::good() const { return state == 0; }

inline streambuf* ios::rdbuf() const { return bp; }

inline long & ios::iword(int _i) const { return x_statebuf[_i] ; }
inline void * & ios::pword(int _i) const { return (void * &)x_statebuf[_i]; }

#ifdef	_MT
    inline void ios::setlock() { LockFlg--; if (bp) bp->setlock(); }
    inline void ios::clrlock() { if (LockFlg <= 0) LockFlg++; if (bp) bp->clrlock(); }
    inline void ios::lockbuf() { bp->lock(); }
    inline void ios::unlockbuf() { bp->unlock(); }
#endif

#ifdef	_MSC_VER
// Restore default packing
#pragma pack(pop)
#endif	// _MSC_VER

#endif		// !_INC_IOS
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\tools\c932\inc\limits.h ===
/***
*limits.h - implementation dependent values
*
*	Copyright (c) 1985-1994, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*	Contains defines for a number of implementation dependent values
*	which are commonly used in C programs.
*	[ANSI]
*
****/

#ifndef _INC_LIMITS
#define _INC_LIMITS

#define CHAR_BIT	  8		/* number of bits in a char */
#define SCHAR_MIN	(-128)		/* minimum signed char value */
#define SCHAR_MAX	  127		/* maximum signed char value */
#define UCHAR_MAX	  0xff		/* maximum unsigned char value */

#ifndef _CHAR_UNSIGNED
#define CHAR_MIN	SCHAR_MIN	/* mimimum char value */
#define CHAR_MAX	SCHAR_MAX	/* maximum char value */
#else
#define CHAR_MIN	  0
#define CHAR_MAX	UCHAR_MAX
#endif	/* _CHAR_UNSIGNED */

#define	MB_LEN_MAX	  2		/* max. # bytes in multibyte char */
#define SHRT_MIN	(-32768)	/* minimum (signed) short value */
#define SHRT_MAX	  32767 	/* maximum (signed) short value */
#define USHRT_MAX	  0xffff	/* maximum unsigned short value */
#define INT_MIN 	(-2147483647 - 1) /* minimum (signed) int value */
#define INT_MAX 	  2147483647	/* maximum (signed) int value */
#define UINT_MAX	  0xffffffff	/* maximum unsigned int value */
#define LONG_MIN	(-2147483647L - 1) /* minimum (signed) long value */
#define LONG_MAX	  2147483647L	/* maximum (signed) long value */
#define ULONG_MAX	  0xffffffffUL	/* maximum unsigned long value */

#if	_INTEGRAL_MAX_BITS >= 8
#define _I8_MIN 	(-127i8 - 1)	/* minimum signed 8 bit value */
#define _I8_MAX 	  127i8		/* maximum signed 8 bit value */
#define _UI8_MAX	  0xffui8	/* maximum unsigned 8 bit value */
#endif

#if	_INTEGRAL_MAX_BITS >= 16
#define _I16_MIN	(-32767i16 - 1)	/* minimum signed 16 bit value */
#define _I16_MAX	  32767i16	/* maximum signed 16 bit value */
#define _UI16_MAX	  0xffffui16	/* maximum unsigned 16 bit value */
#endif

#if	_INTEGRAL_MAX_BITS >= 32
#define _I32_MIN	(-2147483647i32 - 1) /* minimum signed 32 bit value */
#define _I32_MAX	  2147483647i32 /* maximum signed 32 bit value */
#define _UI32_MAX	  0xffffffffui32 /* maximum unsigned 32 bit value */
#endif

#if	_INTEGRAL_MAX_BITS >= 64
/* minimum signed 64 bit value */
#define _I64_MIN	(-9223372036854775807i64 - 1)
/* maximum signed 64 bit value */
#define _I64_MAX	  9223372036854775807i64
/* maximum unsigned 64 bit value */
#define _UI64_MAX	  0xffffffffffffffffui64
#endif

#if	_INTEGRAL_MAX_BITS >= 128
/* minimum signed 128 bit value */
#define _I128_MIN	(-170141183460469231731687303715884105727i128 - 1)
/* maximum signed 128 bit value */
#define _I128_MAX	  170141183460469231731687303715884105727i128
/* maximum unsigned 128 bit value */
#define _UI128_MAX	  0xffffffffffffffffffffffffffffffffui128
#endif

#ifdef _POSIX_

#define _POSIX_ARG_MAX          4096
#define _POSIX_CHILD_MAX        6
#define _POSIX_LINK_MAX         8
#define _POSIX_MAX_CANON        255
#define _POSIX_MAX_INPUT        255
#define _POSIX_NAME_MAX         14
#define _POSIX_NGROUPS_MAX      0
#define _POSIX_OPEN_MAX         16
#define _POSIX_PATH_MAX         255
#define _POSIX_PIPE_BUF         512
#define _POSIX_SSIZE_MAX	32767
#define _POSIX_STREAM_MAX	8
#define _POSIX_TZNAME_MAX	3

#define ARG_MAX                 14500	/* 16k heap, minus overhead */
#define MAX_CANON               _POSIX_MAX_CANON
#define MAX_INPUT               _POSIX_MAX_INPUT
#define NAME_MAX		255
#define NGROUPS_MAX             16
#define OPEN_MAX                32
#define PATH_MAX                512
#define PIPE_BUF                _POSIX_PIPE_BUF
#define SSIZE_MAX		_POSIX_SSIZE_MAX
#define STREAM_MAX		20
#define TZNAME_MAX		10

#endif /* POSIX */

#endif	/* _INC_LIMITS */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\tools\c932\inc\lm.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1991-1993  Microsoft Corporation

Module Name:

    lm.h

Abstract:

    This is the top level include file that includes all the files
    necessary for writing Lan Manager Application.

Author:

    Dan Lafferty (danl) 10-Mar-1991

[Environment:]

    User Mode - Win32

Revision History:

    10-Mar-1991 danl
        Created
    30-Jul-1992 JohnRo
        RAID 2553: lmrepl.h not in public include tree.

--*/

#ifndef _LM_
#define _LM_

#include <lmcons.h>     // LAN Manager common definitions
#include <lmerr.h>      // LAN Manager network error definitions

#include <lmaccess.h>   // Access, Domain, Group and User classes
#include <lmalert.h>    // Alerter
#include <lmchdev.h>    // Character Device and Handle classes
#include <lmshare.h>    // Connection, File, Session and Share classes
#include <lmmsg.h>      // Message class
#include <lmremutl.h>   // Remote Utility class
#include <lmrepl.h>     // Replicator class
#include <lmserver.h>   // Server class
#include <lmsvc.h>      // Service class
#include <lmuse.h>      // Use class
#include <lmwksta.h>    // Workstation class
#include <lmapibuf.h>   // NetApiBuffer class
#include <lmerrlog.h>   // NetErrorLog class
#include <lmconfig.h>   // NetConfig class
#include <lmstats.h>    // NetStats class
#include <lmaudit.h>    // NetAudit class

#endif // _LM_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\tools\c932\inc\istream.h ===
/***
*istream.h - definitions/declarations for the istream class
*
*	Copyright (c) 1990-1994, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*	This file defines the classes, values, macros, and functions
*	used by the istream class.
*	[AT&T C++]
*
****/

#ifndef _INC_ISTREAM
#define _INC_ISTREAM


/* Define _CRTIMP */

#ifndef _CRTIMP
#ifdef	_NTSDK
/* definition compatible with NT SDK */
#define _CRTIMP
#else	/* ndef _NTSDK */
/* current definition */
#ifdef	_DLL
#define _CRTIMP __declspec(dllimport)
#else	/* ndef _DLL */
#define _CRTIMP
#endif	/* _DLL */
#endif	/* _NTSDK */
#endif	/* _CRTIMP */


#include <ios.h>

#ifdef	_MSC_VER
// C4069: "long double != double"
#pragma warning(disable:4069)	// disable C4069 warning
// #pragma warning(default:4069)	// use this to reenable, if desired

// C4505: "unreferenced local function has been removed"
#pragma warning(disable:4505) // disable C4505 warning
// #pragma warning(default:4505)	// use this to reenable, if desired

// Force word packing to avoid possible -Zp override
#pragma pack(push,4)
#endif	// _MSC_VER


typedef long streamoff, streampos;

class _CRTIMP istream : virtual public ios {

public:
    istream(streambuf*);
    virtual ~istream();

    int  ipfx(int =0);
    void isfx() { unlockbuf(); unlock(); }

    inline istream& operator>>(istream& (__cdecl * _f)(istream&));
    inline istream& operator>>(ios& (__cdecl * _f)(ios&));
    istream& operator>>(char *);
    inline istream& operator>>(unsigned char *);
    inline istream& operator>>(signed char *);
    istream& operator>>(char &);
    inline istream& operator>>(unsigned char &);
    inline istream& operator>>(signed char &);
    istream& operator>>(short &);
    istream& operator>>(unsigned short &);
    istream& operator>>(int &);
    istream& operator>>(unsigned int &);
    istream& operator>>(long &);
    istream& operator>>(unsigned long &);
    istream& operator>>(float &);
    istream& operator>>(double &);
    istream& operator>>(long double &);
    istream& operator>>(streambuf*);

    int get();
    istream& get(char *,int,char ='\n');
    inline istream& get(unsigned char *,int,char ='\n');
    inline istream& get(signed char *,int,char ='\n');
    istream& get(char &);
    inline istream& get(unsigned char &);
    inline istream& get(signed char &);
    istream& get(streambuf&,char ='\n');
    inline istream& getline(char *,int,char ='\n');
    inline istream& getline(unsigned char *,int,char ='\n');
    inline istream& getline(signed char *,int,char ='\n');

    inline istream& ignore(int =1,int =EOF);
    istream& read(char *,int);
    inline istream& read(unsigned char *,int);
    inline istream& read(signed char *,int);

    int gcount() const { return x_gcount; }
    int peek();
    istream& putback(char);
    int sync();

    istream& seekg(streampos);
    istream& seekg(streamoff,ios::seek_dir);
    streampos tellg();

    void eatwhite();	// consider: protect and friend with manipulator ws
protected:
    istream();
    istream(const istream&);	// treat as private
    istream& operator=(streambuf* _isb); // treat as private
    istream& operator=(const istream& _is) { return operator=(_is.rdbuf()); }
    int do_ipfx(int);

private:
    istream(ios&);
    int getint(char *);
    int getdouble(char *, int);
    int _fGline;
    int x_gcount;
};

    inline istream& istream::operator>>(istream& (__cdecl * _f)(istream&)) { (*_f)(*this); return *this; }
    inline istream& istream::operator>>(ios& (__cdecl * _f)(ios&)) { (*_f)(*this); return *this; }

    inline istream& istream::operator>>(unsigned char * _s) { return operator>>((char *)_s); }
    inline istream& istream::operator>>(signed char * _s) { return operator>>((char *)_s); }

    inline istream& istream::operator>>(unsigned char & _c) { return operator>>((char &) _c); }
    inline istream& istream::operator>>(signed char & _c) { return operator>>((char &) _c); }

    inline istream& istream::get(unsigned char * _b, int _lim, char _delim) { return get((char *)_b, _lim, _delim); }
    inline istream& istream::get(signed char * _b, int _lim, char _delim) { return get((char *)_b, _lim, _delim); }

    inline istream& istream::get(unsigned char & _c) { return get((char &)_c); }
    inline istream& istream::get(signed char & _c) { return get((char &)_c); }

    inline istream& istream::getline(char * _b,int _lim,char _delim) { lock(); _fGline++; get(_b, _lim, _delim); unlock(); return *this; }
    inline istream& istream::getline(unsigned char * _b,int _lim,char _delim) { lock(); _fGline++; get((char *)_b, _lim, _delim); unlock(); return *this; }
    inline istream& istream::getline(signed char * _b,int _lim,char _delim) { lock(); _fGline++; get((char *)_b, _lim, _delim); unlock(); return *this; }

    inline istream& istream::ignore(int _n,int _delim) { lock(); _fGline++; return get((char *)0, _n+1, (char)_delim); unlock(); return *this; }

    inline istream& istream::read(unsigned char * _ptr, int _n) { return read((char *) _ptr, _n); }
    inline istream& istream::read(signed char * _ptr, int _n) { return read((char *) _ptr, _n); }

class _CRTIMP istream_withassign : public istream {
	public:
		istream_withassign();
		istream_withassign(streambuf*);
		~istream_withassign();
    istream& operator=(const istream& _is) { return istream::operator=(_is); }
    istream& operator=(streambuf* _isb) { return istream::operator=(_isb); }
};

#ifndef _WINDLL	   // Warning!  Not available under Windows without QuickWin:
extern _CRTIMP istream_withassign cin;
#endif

inline _CRTIMP istream& __cdecl ws(istream& _ins) { _ins.eatwhite(); return _ins; }

_CRTIMP ios&		__cdecl dec(ios&);
_CRTIMP ios&		__cdecl hex(ios&);
_CRTIMP ios&		__cdecl oct(ios&);

#ifdef	_MSC_VER
// Restore default packing
#pragma pack(pop)
#endif	// _MSC_VER

#endif 		// !_INC_ISTREAM
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\tools\c932\inc\iostream.h ===
/***
*iostream.h - definitions/declarations for iostream classes
*
*	Copyright (c) 1990-1994, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*	This file defines the classes, values, macros, and functions
*	used by the iostream classes.
*	[AT&T C++]
*
****/

#ifndef _INC_IOSTREAM
#define _INC_IOSTREAM


/* Define _CRTIMP */

#ifndef _CRTIMP
#ifdef	_NTSDK
/* definition compatible with NT SDK */
#define _CRTIMP
#else	/* ndef _NTSDK */
/* current definition */
#ifdef	_DLL
#define _CRTIMP __declspec(dllimport)
#else	/* ndef _DLL */
#define _CRTIMP
#endif	/* _DLL */
#endif	/* _NTSDK */
#endif	/* _CRTIMP */

typedef long streamoff, streampos;

#include <ios.h>		// Define ios.

#include <streamb.h>		// Define streambuf.

#include <istream.h>		// Define istream.

#include <ostream.h>		// Define ostream.

#ifdef	_MSC_VER
// C4505: "unreferenced local function has been removed"
#pragma warning(disable:4505) // disable C4505 warning
// #pragma warning(default:4505)	// use this to reenable, if desired

// Force word packing to avoid possible -Zp override
#pragma pack(push,4)
#endif	// _MSC_VER

class _CRTIMP iostream : public istream, public ostream {
public:
	iostream(streambuf*);
	virtual ~iostream();
protected:
// consider: make private??
	iostream();
	iostream(const iostream&);
inline iostream& operator=(streambuf*);
inline iostream& operator=(iostream&);
private:
	iostream(ios&);
	iostream(istream&);
	iostream(ostream&);
};

inline iostream& iostream::operator=(streambuf* _sb) { istream::operator=(_sb); ostream::operator=(_sb); return *this; }

inline iostream& iostream::operator=(iostream& _strm) { return operator=(_strm.rdbuf()); }

class _CRTIMP Iostream_init {
public:
	Iostream_init();
	Iostream_init(ios &, int =0);	// treat as private
	~Iostream_init();
};

// used internally
// static Iostream_init __iostreaminit;	// initializes cin/cout/cerr/clog

#ifdef	_MSC_VER
// Restore previous packing
#pragma pack(pop)
#endif	// _MSC_VER

#endif	/* !_INC_IOSTREAM */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\tools\c932\inc\lmalert.h ===
/*++ BUILD Version: 0003    // Increment this if a change has global effects

Copyright (c) 1991-1993  Microsoft Corporation

Module Name:

    alert.h

Abstract:

    This file contains structures for communication with the Alerter
    service.

Author:

    Dan Lafferty (danl) 12-Mar-1991

Environment:

    User Mode - Win32

Notes:

    You must include LmCons.H before this file, since this file depends
    on values defined in LmCons.H.

    ALERT.H includes ALERTMSG.H which defines the alert message numbers

Revision History:

    12-Mar-1991 danl
        Created from LM2.0 header files and NT-LAN API Spec.
    14-Mar-1991 JohnRo
        Temporarily commented-out include of "alertmsg.h".
    22-July-1991 ritaw
        Removed NetAlert API prototypes.
        STD_ALERT structure holds offsets to strings rather than string
        pointers.
        Renamed file from lmalert.h back to alert.h and put in the net inc
        directory since this file is private to LAN Man components.
    24-July-1990 ritaw
        Due to LAN Man 2.0 assumptions, the event and service names of the
        STD_ALERT structure must be embedded strings.   All LAN Man 2.0 code
        which write to alert structures can be ported without additional
        changes.
    04-Apr-1992 JohnRo
        Added NetAlertRaise and NetAlertRaiseEx APIs.
        Changed ALERT_xxx_EVENT equates to be TCHAR strings.
        Fixed definition of LPSTD_ALERT (used by NetAlertRaise API).

--*/


#ifndef _ALERT_
#define _ALERT_


#ifdef __cplusplus
extern "C" {
#endif

//
// Function Prototypes
//

NET_API_STATUS NET_API_FUNCTION
NetAlertRaise(
    IN LPTSTR AlertEventName,
    IN LPVOID Buffer,
    IN DWORD BufferSize
    );

NET_API_STATUS NET_API_FUNCTION
NetAlertRaiseEx(
    IN LPTSTR AlertEventName,
    IN LPVOID VariableInfo,
    IN DWORD VariableInfoSize,
    IN LPTSTR ServiceName
    );


//
//  Data Structures
//

typedef struct _STD_ALERT {
    DWORD  alrt_timestamp;
    TCHAR  alrt_eventname[EVLEN + 1];
    TCHAR  alrt_servicename[SNLEN + 1];
}STD_ALERT, *PSTD_ALERT, *LPSTD_ALERT;

typedef struct _ADMIN_OTHER_INFO {
    DWORD  alrtad_errcode;
    DWORD  alrtad_numstrings;
}ADMIN_OTHER_INFO, *PADMIN_OTHER_INFO, *LPADMIN_OTHER_INFO;

typedef struct _ERRLOG_OTHER_INFO {
    DWORD  alrter_errcode;
    DWORD  alrter_offset;
}ERRLOG_OTHER_INFO, *PERRLOG_OTHER_INFO, *LPERRLOG_OTHER_INFO;

typedef struct _PRINT_OTHER_INFO {
    DWORD  alrtpr_jobid;
    DWORD  alrtpr_status;
    DWORD  alrtpr_submitted;
    DWORD  alrtpr_size;
}PRINT_OTHER_INFO, *PPRINT_OTHER_INFO, *LPPRINT_OTHER_INFO;

typedef struct _USER_OTHER_INFO {
    DWORD  alrtus_errcode;
    DWORD  alrtus_numstrings;
}USER_OTHER_INFO, *PUSER_OTHER_INFO, *LPUSER_OTHER_INFO;

//
// Special Values and Constants
//

//
// Name of mailslot to send alert notifications
//
#define ALERTER_MAILSLOT          TEXT("\\\\.\\MAILSLOT\\Alerter")

//
// The following macro gives a pointer to the other_info data.
// It takes an alert structure and returns a pointer to structure
// beyond the standard portion.
//

#define ALERT_OTHER_INFO(x)    ((LPBYTE)(x) + sizeof(STD_ALERT))

//
// The following macro gives a pointer to the variable-length data.
// It takes a pointer to one of the other-info structs and returns a
// pointer to the variable data portion.
//

#define ALERT_VAR_DATA(p)      ((LPBYTE)(p) + sizeof(*p))

//
//      Names of standard Microsoft-defined alert events.
//

#define ALERT_PRINT_EVENT           TEXT("PRINTING")
#define ALERT_MESSAGE_EVENT         TEXT("MESSAGE")
#define ALERT_ERRORLOG_EVENT        TEXT("ERRORLOG")
#define ALERT_ADMIN_EVENT           TEXT("ADMIN")
#define ALERT_USER_EVENT            TEXT("USER")

//
//      Bitmap masks for prjob_status field of PRINTJOB.
//

// 2-7 bits also used in device status

#define PRJOB_QSTATUS       0x3         // Bits 0,1
#define PRJOB_DEVSTATUS     0x1fc       // 2-8 bits
#define PRJOB_COMPLETE      0x4         // Bit 2
#define PRJOB_INTERV        0x8         // Bit 3
#define PRJOB_ERROR         0x10        // Bit 4
#define PRJOB_DESTOFFLINE   0x20        // Bit 5
#define PRJOB_DESTPAUSED    0x40        // Bit 6
#define PRJOB_NOTIFY        0x80        // BIT 7
#define PRJOB_DESTNOPAPER   0x100       // BIT 8
#define PRJOB_DELETED       0x8000      // BIT 15

//
//      Values of PRJOB_QSTATUS bits in prjob_status field of PRINTJOB.
//

#define PRJOB_QS_QUEUED                 0
#define PRJOB_QS_PAUSED                 1
#define PRJOB_QS_SPOOLING               2
#define PRJOB_QS_PRINTING               3


#ifdef __cplusplus
}
#endif

#endif // _ALERT_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\tools\c932\inc\lmaccess.h ===
/*++ BUILD Version: 0002    // Increment this if a change has global effects

Copyright (c) 1991-1993  Microsoft Corporation

Module Name:

    lmaccess.h

Abstract:

    This file contains structures, function prototypes, and definitions
    for the NetUser, NetUserModals, NetGroup, NetAccess, and NetLogon API.

Author:

    Dan Lafferty (danl) 10-Mar-1991

Environment:

    User Mode - Win32

Notes:

    You must include NETCONS.H before this file, since this file depends
    on values defined in NETCONS.H.

Revision History:

    10-Mar-1991 danl
    Created from LM2.0 header files and NT-LAN API Spec.

    11-Apr-1991 danhi
    Changed usrmod0_passwd_hist_len to usrmod0_password_hist_len to match
    the LM 2.0 name.

    12-Apr-1991 cliffv
    Moved internal info level 99 out of this public file.

    14-Apr-1991 w-shanku
    Changed ParmNum constants to allow consistency with OS/2 parmnums.

    17-Apr-1991 cliffv
    Added OPTIONAL keyword to function prototypes.

    29-Apr-1991 w-shanku
    Fixed USER_LOGON_INFO structure definition - was given without
    'typedef' keyword.

    21-Jun-1991 cliffv
    Converted to UNICODE.  Added info level for each parmnum.

    16-Jul-1991 JohnRo
    Clarify that NetGetDCName's domain name is OPTIONAL (default is primary
    domain.)

    18-Jul-1991 RFirth
        Created XXX_XXX_INFOLEVELs as counterparts of XXX_XXX_PARMNUMs

    21-Jan-1992 madana
        Sundry API changes

    26-Nov-1992 ritaw
        Added NetLocalGroup APIs.

--*/

//
// User Class
//

#ifndef _LMUSER_
#define _LMUSER_

#ifdef __cplusplus
extern "C" {
#endif

#include <lmcons.h>     // unfortunately created a dependence on this

//
// Function Prototypes - User
//

NET_API_STATUS NET_API_FUNCTION
NetUserAdd (
    IN  LPWSTR     servername OPTIONAL,
    IN  DWORD      level,
    IN  LPBYTE     buf,
    OUT LPDWORD    parm_err OPTIONAL
    );

NET_API_STATUS NET_API_FUNCTION
NetUserEnum (
    IN  LPWSTR     servername OPTIONAL,
    IN  DWORD      level,
    IN  DWORD      filter,
    OUT LPBYTE     *bufptr,
    IN  DWORD      prefmaxlen,
    OUT LPDWORD    entriesread,
    OUT LPDWORD    totalentries,
    IN OUT LPDWORD resume_handle OPTIONAL
    );

NET_API_STATUS NET_API_FUNCTION
NetUserGetInfo (
    IN  LPWSTR     servername OPTIONAL,
    IN  LPWSTR     username,
    IN  DWORD      level,
    OUT LPBYTE     *bufptr
    );

NET_API_STATUS NET_API_FUNCTION
NetUserSetInfo (
    IN  LPWSTR    servername OPTIONAL,
    IN  LPWSTR    username,
    IN  DWORD     level,
    IN  LPBYTE    buf,
    OUT LPDWORD   parm_err OPTIONAL
    );

NET_API_STATUS NET_API_FUNCTION
NetUserDel (
    IN  LPWSTR    servername OPTIONAL,
    IN  LPWSTR    username
    );

NET_API_STATUS NET_API_FUNCTION
NetUserGetGroups (
    IN  LPWSTR    servername OPTIONAL,
    IN  LPWSTR    username,
    IN  DWORD     level,
    OUT LPBYTE    *bufptr,
    IN  DWORD     prefmaxlen,
    OUT LPDWORD   entriesread,
    OUT LPDWORD   totalentries
    );

NET_API_STATUS NET_API_FUNCTION
NetUserSetGroups (
    IN  LPWSTR    servername OPTIONAL,
    IN  LPWSTR    username,
    IN  DWORD     level,
    IN  LPBYTE    buf,
    IN  DWORD     num_entries
    );

NET_API_STATUS NET_API_FUNCTION
NetUserGetLocalGroups (
    IN  LPWSTR    servername OPTIONAL,
    IN  LPWSTR    username,
    IN  DWORD     level,
    IN  DWORD     flags,
    OUT LPBYTE    *bufptr,
    IN  DWORD     prefmaxlen,
    OUT LPDWORD   entriesread,
    OUT LPDWORD   totalentries
    );

NET_API_STATUS NET_API_FUNCTION
NetUserModalsGet (
    IN  LPWSTR    servername OPTIONAL,
    IN  DWORD     level,
    OUT LPBYTE    *bufptr
    );

NET_API_STATUS NET_API_FUNCTION
NetUserModalsSet (
    IN  LPWSTR    servername OPTIONAL,
    IN  DWORD     level,
    IN  LPBYTE    buf,
    OUT LPDWORD   parm_err OPTIONAL
    );

//
//  Data Structures - User
//

typedef struct _USER_INFO_0 {
    LPWSTR   usri0_name;
}USER_INFO_0, *PUSER_INFO_0, *LPUSER_INFO_0;

typedef struct _USER_INFO_1 {
    LPWSTR   usri1_name;
    LPWSTR   usri1_password;
    DWORD    usri1_password_age;
    DWORD    usri1_priv;
    LPWSTR   usri1_home_dir;
    LPWSTR   usri1_comment;
    DWORD    usri1_flags;
    LPWSTR   usri1_script_path;
}USER_INFO_1, *PUSER_INFO_1, *LPUSER_INFO_1;

typedef struct _USER_INFO_2 {
    LPWSTR   usri2_name;
    LPWSTR   usri2_password;
    DWORD    usri2_password_age;
    DWORD    usri2_priv;
    LPWSTR   usri2_home_dir;
    LPWSTR   usri2_comment;
    DWORD    usri2_flags;
    LPWSTR   usri2_script_path;
    DWORD    usri2_auth_flags;
    LPWSTR   usri2_full_name;
    LPWSTR   usri2_usr_comment;
    LPWSTR   usri2_parms;
    LPWSTR   usri2_workstations;
    DWORD    usri2_last_logon;
    DWORD    usri2_last_logoff;
    DWORD    usri2_acct_expires;
    DWORD    usri2_max_storage;
    DWORD    usri2_units_per_week;
    PBYTE    usri2_logon_hours;
    DWORD    usri2_bad_pw_count;
    DWORD    usri2_num_logons;
    LPWSTR   usri2_logon_server;
    DWORD    usri2_country_code;
    DWORD    usri2_code_page;
}USER_INFO_2, *PUSER_INFO_2, *LPUSER_INFO_2;

typedef struct _USER_INFO_3 {
    LPWSTR   usri3_name;
    LPWSTR   usri3_password;
    DWORD    usri3_password_age;
    DWORD    usri3_priv;
    LPWSTR   usri3_home_dir;
    LPWSTR   usri3_comment;
    DWORD    usri3_flags;
    LPWSTR   usri3_script_path;
    DWORD    usri3_auth_flags;
    LPWSTR   usri3_full_name;
    LPWSTR   usri3_usr_comment;
    LPWSTR   usri3_parms;
    LPWSTR   usri3_workstations;
    DWORD    usri3_last_logon;
    DWORD    usri3_last_logoff;
    DWORD    usri3_acct_expires;
    DWORD    usri3_max_storage;
    DWORD    usri3_units_per_week;
    PBYTE    usri3_logon_hours;
    DWORD    usri3_bad_pw_count;
    DWORD    usri3_num_logons;
    LPWSTR   usri3_logon_server;
    DWORD    usri3_country_code;
    DWORD    usri3_code_page;
    DWORD    usri3_user_id;
    DWORD    usri3_primary_group_id;
    LPWSTR   usri3_profile;
    LPWSTR   usri3_home_dir_drive;
    DWORD    usri3_password_expired;
}USER_INFO_3, *PUSER_INFO_3, *LPUSER_INFO_3;

typedef struct _USER_INFO_10 {
    LPWSTR   usri10_name;
    LPWSTR   usri10_comment;
    LPWSTR   usri10_usr_comment;
    LPWSTR   usri10_full_name;
}USER_INFO_10, *PUSER_INFO_10, *LPUSER_INFO_10;

typedef struct _USER_INFO_11 {
    LPWSTR   usri11_name;
    LPWSTR   usri11_comment;
    LPWSTR   usri11_usr_comment;
    LPWSTR   usri11_full_name;
    DWORD    usri11_priv;
    DWORD    usri11_auth_flags;
    DWORD    usri11_password_age;
    LPWSTR   usri11_home_dir;
    LPWSTR   usri11_parms;
    DWORD    usri11_last_logon;
    DWORD    usri11_last_logoff;
    DWORD    usri11_bad_pw_count;
    DWORD    usri11_num_logons;
    LPWSTR   usri11_logon_server;
    DWORD    usri11_country_code;
    LPWSTR   usri11_workstations;
    DWORD    usri11_max_storage;
    DWORD    usri11_units_per_week;
    PBYTE    usri11_logon_hours;
    DWORD    usri11_code_page;
}USER_INFO_11, *PUSER_INFO_11, *LPUSER_INFO_11;

typedef struct _USER_INFO_20 {
    LPWSTR   usri20_name;
    LPWSTR   usri20_full_name;
    LPWSTR   usri20_comment;
    DWORD    usri20_flags;
    DWORD    usri20_user_id;
}USER_INFO_20, *PUSER_INFO_20, *LPUSER_INFO_20;

typedef struct _USER_INFO_21 {
    BYTE     usri21_password[ENCRYPTED_PWLEN];
}USER_INFO_21, *PUSER_INFO_21, *LPUSER_INFO_21;

typedef struct _USER_INFO_22 {
    LPWSTR   usri22_name;
    BYTE     usri22_password[ENCRYPTED_PWLEN];
    DWORD    usri22_password_age;
    DWORD    usri22_priv;
    LPWSTR   usri22_home_dir;
    LPWSTR   usri22_comment;
    DWORD    usri22_flags;
    LPWSTR   usri22_script_path;
    DWORD    usri22_auth_flags;
    LPWSTR   usri22_full_name;
    LPWSTR   usri22_usr_comment;
    LPWSTR   usri22_parms;
    LPWSTR   usri22_workstations;
    DWORD    usri22_last_logon;
    DWORD    usri22_last_logoff;
    DWORD    usri22_acct_expires;
    DWORD    usri22_max_storage;
    DWORD    usri22_units_per_week;
    PBYTE    usri22_logon_hours;
    DWORD    usri22_bad_pw_count;
    DWORD    usri22_num_logons;
    LPWSTR   usri22_logon_server;
    DWORD    usri22_country_code;
    DWORD    usri22_code_page;
}USER_INFO_22, *PUSER_INFO_22, *LPUSER_INFO_22;

typedef struct _USER_INFO_1003 {
     LPWSTR  usri1003_password;
} USER_INFO_1003, *PUSER_INFO_1003, *LPUSER_INFO_1003;

typedef struct _USER_INFO_1005 {
     DWORD   usri1005_priv;
} USER_INFO_1005, *PUSER_INFO_1005, *LPUSER_INFO_1005;

typedef struct _USER_INFO_1006 {
     LPWSTR  usri1006_home_dir;
} USER_INFO_1006, *PUSER_INFO_1006, *LPUSER_INFO_1006;

typedef struct _USER_INFO_1007 {
     LPWSTR  usri1007_comment;
} USER_INFO_1007, *PUSER_INFO_1007, *LPUSER_INFO_1007;

typedef struct _USER_INFO_1008 {
     DWORD   usri1008_flags;
} USER_INFO_1008, *PUSER_INFO_1008, *LPUSER_INFO_1008;

typedef struct _USER_INFO_1009 {
     LPWSTR  usri1009_script_path;
} USER_INFO_1009, *PUSER_INFO_1009, *LPUSER_INFO_1009;

typedef struct _USER_INFO_1010 {
     DWORD   usri1010_auth_flags;
} USER_INFO_1010, *PUSER_INFO_1010, *LPUSER_INFO_1010;

typedef struct _USER_INFO_1011 {
     LPWSTR  usri1011_full_name;
} USER_INFO_1011, *PUSER_INFO_1011, *LPUSER_INFO_1011;

typedef struct _USER_INFO_1012 {
     LPWSTR  usri1012_usr_comment;
} USER_INFO_1012, *PUSER_INFO_1012, *LPUSER_INFO_1012;

typedef struct _USER_INFO_1013 {
     LPWSTR  usri1013_parms;
} USER_INFO_1013, *PUSER_INFO_1013, *LPUSER_INFO_1013;

typedef struct _USER_INFO_1014 {
     LPWSTR  usri1014_workstations;
} USER_INFO_1014, *PUSER_INFO_1014, *LPUSER_INFO_1014;

typedef struct _USER_INFO_1017 {
     DWORD   usri1017_acct_expires;
} USER_INFO_1017, *PUSER_INFO_1017, *LPUSER_INFO_1017;

typedef struct _USER_INFO_1018 {
     DWORD   usri1018_max_storage;
} USER_INFO_1018, *PUSER_INFO_1018, *LPUSER_INFO_1018;

typedef struct _USER_INFO_1020 {
    DWORD   usri1020_units_per_week;
    LPBYTE  usri1020_logon_hours;
} USER_INFO_1020, *PUSER_INFO_1020, *LPUSER_INFO_1020;

typedef struct _USER_INFO_1023 {
     LPWSTR  usri1023_logon_server;
} USER_INFO_1023, *PUSER_INFO_1023, *LPUSER_INFO_1023;

typedef struct _USER_INFO_1024 {
     DWORD   usri1024_country_code;
} USER_INFO_1024, *PUSER_INFO_1024, *LPUSER_INFO_1024;

typedef struct _USER_INFO_1025 {
     DWORD   usri1025_code_page;
} USER_INFO_1025, *PUSER_INFO_1025, *LPUSER_INFO_1025;

typedef struct _USER_INFO_1051 {
     DWORD   usri1051_primary_group_id;
} USER_INFO_1051, *PUSER_INFO_1051, *LPUSER_INFO_1051;

typedef struct _USER_INFO_1052 {
     LPWSTR  usri1052_profile;
} USER_INFO_1052, *PUSER_INFO_1052, *LPUSER_INFO_1052;

typedef struct _USER_INFO_1053 {
     LPWSTR  usri1053_home_dir_drive;
} USER_INFO_1053, *PUSER_INFO_1053, *LPUSER_INFO_1053;


//
//  Data Structures - User Modals
//

typedef struct _USER_MODALS_INFO_0 {
    DWORD    usrmod0_min_passwd_len;
    DWORD    usrmod0_max_passwd_age;
    DWORD    usrmod0_min_passwd_age;
    DWORD    usrmod0_force_logoff;
    DWORD    usrmod0_password_hist_len;
}USER_MODALS_INFO_0, *PUSER_MODALS_INFO_0, *LPUSER_MODALS_INFO_0;

typedef struct _USER_MODALS_INFO_1 {
    DWORD    usrmod1_role;
    LPWSTR   usrmod1_primary;
}USER_MODALS_INFO_1, *PUSER_MODALS_INFO_1, *LPUSER_MODALS_INFO_1;

typedef struct _USER_MODALS_INFO_2 {
    LPWSTR  usrmod2_domain_name;
    PSID    usrmod2_domain_id;
}USER_MODALS_INFO_2, *PUSER_MODALS_INFO_2, *LPUSER_MODALS_INFO_2;

typedef struct _USER_MODALS_INFO_3 {
    DWORD   usrmod3_lockout_duration;
    DWORD   usrmod3_lockout_observation_window;
    DWORD   usrmod3_lockout_threshold;
}USER_MODALS_INFO_3, *PUSER_MODALS_INFO_3, *LPUSER_MODALS_INFO_3;

typedef struct _USER_MODALS_INFO_1001 {
     DWORD   usrmod1001_min_passwd_len;
} USER_MODALS_INFO_1001, *PUSER_MODALS_INFO_1001, *LPUSER_MODALS_INFO_1001;

typedef struct _USER_MODALS_INFO_1002 {
     DWORD   usrmod1002_max_passwd_age;
} USER_MODALS_INFO_1002, *PUSER_MODALS_INFO_1002, *LPUSER_MODALS_INFO_1002;

typedef struct _USER_MODALS_INFO_1003 {
     DWORD   usrmod1003_min_passwd_age;
} USER_MODALS_INFO_1003, *PUSER_MODALS_INFO_1003, *LPUSER_MODALS_INFO_1003;

typedef struct _USER_MODALS_INFO_1004 {
     DWORD   usrmod1004_force_logoff;
} USER_MODALS_INFO_1004, *PUSER_MODALS_INFO_1004, *LPUSER_MODALS_INFO_1004;

typedef struct _USER_MODALS_INFO_1005 {
     DWORD   usrmod1005_password_hist_len;
} USER_MODALS_INFO_1005, *PUSER_MODALS_INFO_1005, *LPUSER_MODALS_INFO_1005;

typedef struct _USER_MODALS_INFO_1006 {
     DWORD   usrmod1006_role;
} USER_MODALS_INFO_1006, *PUSER_MODALS_INFO_1006, *LPUSER_MODALS_INFO_1006;

typedef struct _USER_MODALS_INFO_1007 {
     LPWSTR  usrmod1007_primary;
} USER_MODALS_INFO_1007, *PUSER_MODALS_INFO_1007, *LPUSER_MODALS_INFO_1007;


//
// Special Values and Constants - User
//

//
//  Bit masks for field usriX_flags of USER_INFO_X (X = 0/1).
//

#define UF_SCRIPT               0x0001
#define UF_ACCOUNTDISABLE       0x0002
#define UF_HOMEDIR_REQUIRED     0x0008
#define UF_LOCKOUT              0x0010
#define UF_PASSWD_NOTREQD       0x0020
#define UF_PASSWD_CANT_CHANGE   0x0040

//
// Account type bits as part of usri_flags.
//

#define UF_TEMP_DUPLICATE_ACCOUNT       0x0100
#define UF_NORMAL_ACCOUNT               0x0200
#define UF_INTERDOMAIN_TRUST_ACCOUNT    0x0800
#define UF_WORKSTATION_TRUST_ACCOUNT    0x1000
#define UF_SERVER_TRUST_ACCOUNT         0x2000

#define UF_MACHINE_ACCOUNT_MASK ( UF_INTERDOMAIN_TRUST_ACCOUNT | \
                                  UF_WORKSTATION_TRUST_ACCOUNT | \
                                  UF_SERVER_TRUST_ACCOUNT )

#define UF_ACCOUNT_TYPE_MASK         ( \
                    UF_TEMP_DUPLICATE_ACCOUNT | \
                    UF_NORMAL_ACCOUNT | \
                    UF_INTERDOMAIN_TRUST_ACCOUNT | \
                    UF_WORKSTATION_TRUST_ACCOUNT | \
                    UF_SERVER_TRUST_ACCOUNT \
                )

#define UF_DONT_EXPIRE_PASSWD           0x10000


#define UF_SETTABLE_BITS        ( \
                    UF_SCRIPT | \
                    UF_ACCOUNTDISABLE | \
                    UF_LOCKOUT | \
                    UF_HOMEDIR_REQUIRED  | \
                    UF_PASSWD_NOTREQD | \
                    UF_PASSWD_CANT_CHANGE | \
                    UF_ACCOUNT_TYPE_MASK | \
                    UF_DONT_EXPIRE_PASSWD \
                )

//
// bit masks for the NetUserEnum filter parameter.
//

#define FILTER_TEMP_DUPLICATE_ACCOUNT       (0x0001)
#define FILTER_NORMAL_ACCOUNT               (0x0002)
// #define FILTER_PROXY_ACCOUNT                (0x0004)
#define FILTER_INTERDOMAIN_TRUST_ACCOUNT    (0x0008)
#define FILTER_WORKSTATION_TRUST_ACCOUNT    (0x0010)
#define FILTER_SERVER_TRUST_ACCOUNT         (0x0020)

//
// bit masks for the NetUserGetLocalGroups flags
//
#define LG_INCLUDE_INDIRECT         (0x0001)

//
//  Bit masks for field usri2_auth_flags of USER_INFO_2.
//

#define AF_OP_PRINT             0x1
#define AF_OP_COMM              0x2
#define AF_OP_SERVER            0x4
#define AF_OP_ACCOUNTS          0x8
#define AF_SETTABLE_BITS        (AF_OP_PRINT | AF_OP_COMM | \
                                AF_OP_SERVER | AF_OP_ACCOUNTS)

//
//  UAS role manifests under NETLOGON
//

#define UAS_ROLE_STANDALONE     0
#define UAS_ROLE_MEMBER         1
#define UAS_ROLE_BACKUP         2
#define UAS_ROLE_PRIMARY        3

//
//  Values for ParmError for NetUserSetInfo.
//

#define USER_NAME_PARMNUM               1
#define USER_PASSWORD_PARMNUM           3
#define USER_PASSWORD_AGE_PARMNUM       4
#define USER_PRIV_PARMNUM               5
#define USER_HOME_DIR_PARMNUM           6
#define USER_COMMENT_PARMNUM            7
#define USER_FLAGS_PARMNUM              8
#define USER_SCRIPT_PATH_PARMNUM        9
#define USER_AUTH_FLAGS_PARMNUM         10
#define USER_FULL_NAME_PARMNUM          11
#define USER_USR_COMMENT_PARMNUM        12
#define USER_PARMS_PARMNUM              13
#define USER_WORKSTATIONS_PARMNUM       14
#define USER_LAST_LOGON_PARMNUM         15
#define USER_LAST_LOGOFF_PARMNUM        16
#define USER_ACCT_EXPIRES_PARMNUM       17
#define USER_MAX_STORAGE_PARMNUM        18
#define USER_UNITS_PER_WEEK_PARMNUM     19
#define USER_LOGON_HOURS_PARMNUM        20
#define USER_PAD_PW_COUNT_PARMNUM       21
#define USER_NUM_LOGONS_PARMNUM         22
#define USER_LOGON_SERVER_PARMNUM       23
#define USER_COUNTRY_CODE_PARMNUM       24
#define USER_CODE_PAGE_PARMNUM          25
#define USER_PRIMARY_GROUP_PARMNUM      51
#define USER_PROFILE                    52 // ?? Delete when convenient
#define USER_PROFILE_PARMNUM            52
#define USER_HOME_DIR_DRIVE_PARMNUM     53

//
// the new infolevel counterparts of the old info level + parmnum
//

#define USER_NAME_INFOLEVEL             \
            (PARMNUM_BASE_INFOLEVEL + USER_NAME_PARMNUM)
#define USER_PASSWORD_INFOLEVEL         \
            (PARMNUM_BASE_INFOLEVEL + USER_PASSWORD_PARMNUM)
#define USER_PASSWORD_AGE_INFOLEVEL     \
            (PARMNUM_BASE_INFOLEVEL + USER_PASSWORD_AGE_PARMNUM)
#define USER_PRIV_INFOLEVEL             \
            (PARMNUM_BASE_INFOLEVEL + USER_PRIV_PARMNUM)
#define USER_HOME_DIR_INFOLEVEL         \
            (PARMNUM_BASE_INFOLEVEL + USER_HOME_DIR_PARMNUM)
#define USER_COMMENT_INFOLEVEL          \
            (PARMNUM_BASE_INFOLEVEL + USER_COMMENT_PARMNUM)
#define USER_FLAGS_INFOLEVEL            \
            (PARMNUM_BASE_INFOLEVEL + USER_FLAGS_PARMNUM)
#define USER_SCRIPT_PATH_INFOLEVEL      \
            (PARMNUM_BASE_INFOLEVEL + USER_SCRIPT_PATH_PARMNUM)
#define USER_AUTH_FLAGS_INFOLEVEL       \
            (PARMNUM_BASE_INFOLEVEL + USER_AUTH_FLAGS_PARMNUM)
#define USER_FULL_NAME_INFOLEVEL        \
            (PARMNUM_BASE_INFOLEVEL + USER_FULL_NAME_PARMNUM)
#define USER_USR_COMMENT_INFOLEVEL      \
            (PARMNUM_BASE_INFOLEVEL + USER_USR_COMMENT_PARMNUM)
#define USER_PARMS_INFOLEVEL            \
            (PARMNUM_BASE_INFOLEVEL + USER_PARMS_PARMNUM)
#define USER_WORKSTATIONS_INFOLEVEL     \
            (PARMNUM_BASE_INFOLEVEL + USER_WORKSTATIONS_PARMNUM)
#define USER_LAST_LOGON_INFOLEVEL       \
            (PARMNUM_BASE_INFOLEVEL + USER_LAST_LOGON_PARMNUM)
#define USER_LAST_LOGOFF_INFOLEVEL      \
            (PARMNUM_BASE_INFOLEVEL + USER_LAST_LOGOFF_PARMNUM)
#define USER_ACCT_EXPIRES_INFOLEVEL     \
            (PARMNUM_BASE_INFOLEVEL + USER_ACCT_EXPIRES_PARMNUM)
#define USER_MAX_STORAGE_INFOLEVEL      \
            (PARMNUM_BASE_INFOLEVEL + USER_MAX_STORAGE_PARMNUM)
#define USER_UNITS_PER_WEEK_INFOLEVEL   \
            (PARMNUM_BASE_INFOLEVEL + USER_UNITS_PER_WEEK_PARMNUM)
#define USER_LOGON_HOURS_INFOLEVEL      \
            (PARMNUM_BASE_INFOLEVEL + USER_LOGON_HOURS_PARMNUM)
#define USER_PAD_PW_COUNT_INFOLEVEL     \
            (PARMNUM_BASE_INFOLEVEL + USER_PAD_PW_COUNT_PARMNUM)
#define USER_NUM_LOGONS_INFOLEVEL       \
            (PARMNUM_BASE_INFOLEVEL + USER_NUM_LOGONS_PARMNUM)
#define USER_LOGON_SERVER_INFOLEVEL     \
            (PARMNUM_BASE_INFOLEVEL + USER_LOGON_SERVER_PARMNUM)
#define USER_COUNTRY_CODE_INFOLEVEL     \
            (PARMNUM_BASE_INFOLEVEL + USER_COUNTRY_CODE_PARMNUM)
#define USER_CODE_PAGE_INFOLEVEL        \
            (PARMNUM_BASE_INFOLEVEL + USER_CODE_PAGE_PARMNUM)
#define USER_PRIMARY_GROUP_INFOLEVEL    \
            (PARMNUM_BASE_INFOLEVEL + USER_PRIMARY_GROUP_PARMNUM)
#define USER_POSIX_ID_INFOLEVEL         \
            (PARMNUM_BASE_INFOLEVEL + USER_POSIX_ID_PARMNUM)
#define USER_HOME_DIR_DRIVE_INFOLEVEL         \
            (PARMNUM_BASE_INFOLEVEL + USER_HOME_DIR_DRIVE_PARMNUM)

//
//  For SetInfo call (parmnum 0) when password change not required
//

#define NULL_USERSETINFO_PASSWD     "              "

#define TIMEQ_FOREVER               ((unsigned long) -1L)
#define USER_MAXSTORAGE_UNLIMITED   ((unsigned long) -1L)
#define USER_NO_LOGOFF              ((unsigned long) -1L)
#define UNITS_PER_DAY               24
#define UNITS_PER_WEEK              UNITS_PER_DAY * 7

//
// Privilege levels (USER_INFO_X field usriX_priv (X = 0/1)).
//

#define USER_PRIV_MASK      0x3
#define USER_PRIV_GUEST     0
#define USER_PRIV_USER      1
#define USER_PRIV_ADMIN     2

//
// user modals related defaults
//

#define MAX_PASSWD_LEN      PWLEN
#define DEF_MIN_PWLEN       6
#define DEF_PWUNIQUENESS    5
#define DEF_MAX_PWHIST      8

#define DEF_MAX_PWAGE       TIMEQ_FOREVER               // forever
#define DEF_MIN_PWAGE       (unsigned long) 0L          // 0 days
#define DEF_FORCE_LOGOFF    (unsigned long) 0xffffffff  // never
#define DEF_MAX_BADPW       0                           // no limit
#define ONE_DAY             (unsigned long) 01*24*3600  // 01 day

//
// User Logon Validation (codes returned)
//

#define VALIDATED_LOGON         0
#define PASSWORD_EXPIRED        2
#define NON_VALIDATED_LOGON     3

#define VALID_LOGOFF            1

//
// parmnum manifests for user modals
//

#define MODALS_MIN_PASSWD_LEN_PARMNUM       1
#define MODALS_MAX_PASSWD_AGE_PARMNUM       2
#define MODALS_MIN_PASSWD_AGE_PARMNUM       3
#define MODALS_FORCE_LOGOFF_PARMNUM         4
#define MODALS_PASSWD_HIST_LEN_PARMNUM      5
#define MODALS_ROLE_PARMNUM                 6
#define MODALS_PRIMARY_PARMNUM              7
#define MODALS_DOMAIN_NAME_PARMNUM          8
#define MODALS_DOMAIN_ID_PARMNUM            9
#define MODALS_LOCKOUT_DURATION_PARMNUM     10
#define MODALS_LOCKOUT_OBSERVATION_WINDOW_PARMNUM 11
#define MODALS_LOCKOUT_THRESHOLD_PARMNUM    12

//
// the new infolevel counterparts of the old info level + parmnum
//

#define MODALS_MIN_PASSWD_LEN_INFOLEVEL     \
            (PARMNUM_BASE_INFOLEVEL + MODALS_MIN_PASSWD_LEN_PARMNUM)
#define MODALS_MAX_PASSWD_AGE_INFOLEVEL     \
            (PARMNUM_BASE_INFOLEVEL + MODALS_MAX_PASSWD_AGE_PARMNUM)
#define MODALS_MIN_PASSWD_AGE_INFOLEVEL     \
            (PARMNUM_BASE_INFOLEVEL + MODALS_MIN_PASSWD_AGE_PARMNUM)
#define MODALS_FORCE_LOGOFF_INFOLEVEL       \
            (PARMNUM_BASE_INFOLEVEL + MODALS_FORCE_LOGOFF_PARMNUM)
#define MODALS_PASSWD_HIST_LEN_INFOLEVEL    \
            (PARMNUM_BASE_INFOLEVEL + MODALS_PASSWD_HIST_LEN_PARMNUM)
#define MODALS_ROLE_INFOLEVEL               \
            (PARMNUM_BASE_INFOLEVEL + MODALS_ROLE_PARMNUM)
#define MODALS_PRIMARY_INFOLEVEL            \
            (PARMNUM_BASE_INFOLEVEL + MODALS_PRIMARY_PARMNUM)
#define MODALS_DOMAIN_NAME_INFOLEVEL        \
            (PARMNUM_BASE_INFOLEVEL + MODALS_DOMAIN_NAME_PARMNUM)
#define MODALS_DOMAIN_ID_INFOLEVEL          \
            (PARMNUM_BASE_INFOLEVEL + MODALS_DOMAIN_ID_PARMNUM)

#endif // _LMUSER_

//
// Group Class
//

#ifndef _LMGROUP_
#define _LMGROUP_

//
// Function Prototypes
//

NET_API_STATUS NET_API_FUNCTION
NetGroupAdd (
    IN  LPWSTR   servername OPTIONAL,
    IN  DWORD    level,
    IN  LPBYTE   buf,
    OUT LPDWORD  parm_err OPTIONAL
    );

NET_API_STATUS NET_API_FUNCTION
NetGroupAddUser (
    IN  LPWSTR   servername OPTIONAL,
    IN  LPWSTR   GroupName,
    IN  LPWSTR   username
    );

NET_API_STATUS NET_API_FUNCTION
NetGroupEnum (
    IN  LPWSTR      servername OPTIONAL,
    IN  DWORD       level,
    OUT LPBYTE      *bufptr,
    IN  DWORD       prefmaxlen,
    OUT LPDWORD     entriesread,
    OUT LPDWORD     totalentries,
    IN OUT LPDWORD  resume_handle OPTIONAL
    );

NET_API_STATUS NET_API_FUNCTION
NetGroupGetInfo (
    IN  LPWSTR   servername OPTIONAL,
    IN  LPWSTR   groupname,
    IN  DWORD    level,
    OUT LPBYTE   *bufptr
    );

NET_API_STATUS NET_API_FUNCTION
NetGroupSetInfo (
    IN  LPWSTR   servername OPTIONAL,
    IN  LPWSTR   groupname,
    IN  DWORD    level,
    IN  LPBYTE   buf,
    OUT LPDWORD  parm_err OPTIONAL
    );

NET_API_STATUS NET_API_FUNCTION
NetGroupDel (
    IN  LPWSTR   servername OPTIONAL,
    IN  LPWSTR   groupname
    );

NET_API_STATUS NET_API_FUNCTION
NetGroupDelUser (
    IN  LPWSTR   servername OPTIONAL,
    IN  LPWSTR   GroupName,
    IN  LPWSTR   Username
    );

NET_API_STATUS NET_API_FUNCTION
NetGroupGetUsers (
    IN  LPWSTR     servername OPTIONAL,
    IN  LPWSTR     groupname,
    IN  DWORD      level,
    OUT LPBYTE     *bufptr,
    IN  DWORD      prefmaxlen,
    OUT LPDWORD    entriesread,
    OUT LPDWORD    totalentries,
    IN OUT LPDWORD ResumeHandle
    );

NET_API_STATUS NET_API_FUNCTION
NetGroupSetUsers (
    IN  LPWSTR     servername OPTIONAL,
    IN  LPWSTR     groupname,
    IN  DWORD      level,
    IN  LPBYTE     buf,
    IN  DWORD      totalentries
    );

//
//  Data Structures - Group
//

typedef struct _GROUP_INFO_0 {
    LPWSTR   grpi0_name;
}GROUP_INFO_0, *PGROUP_INFO_0, *LPGROUP_INFO_0;

typedef struct _GROUP_INFO_1 {
    LPWSTR   grpi1_name;
    LPWSTR   grpi1_comment;
}GROUP_INFO_1, *PGROUP_INFO_1, *LPGROUP_INFO_1;

typedef struct _GROUP_INFO_2 {
    LPWSTR   grpi2_name;
    LPWSTR   grpi2_comment;
    DWORD    grpi2_group_id;
    DWORD    grpi2_attributes;
}GROUP_INFO_2, *PGROUP_INFO_2;

typedef struct _GROUP_INFO_1002 {
     LPWSTR  grpi1002_comment;
} GROUP_INFO_1002, *PGROUP_INFO_1002, *LPGROUP_INFO_1002;

typedef struct _GROUP_INFO_1005 {
     DWORD  grpi1005_attributes;
} GROUP_INFO_1005, *PGROUP_INFO_1005, *LPGROUP_INFO_1005;


typedef struct _GROUP_USERS_INFO_0 {
     LPWSTR  grui0_name;
} GROUP_USERS_INFO_0, *PGROUP_USERS_INFO_0, *LPGROUP_USERS_INFO_0;

typedef struct _GROUP_USERS_INFO_1 {
     LPWSTR  grui1_name;
     DWORD   grui1_attributes;
} GROUP_USERS_INFO_1, *PGROUP_USERS_INFO_1, *LPGROUP_USERS_INFO_1;

//
// Special Values and Constants - Group
//

#define GROUPIDMASK                 0x8000      // MSB set if uid refers
                                                // to a group

//
// Predefined group for all normal users, administrators and guests
// LOCAL is a special group for pinball local security.
//

#define GROUP_SPECIALGRP_USERS      L"USERS"
#define GROUP_SPECIALGRP_ADMINS     L"ADMINS"
#define GROUP_SPECIALGRP_GUESTS     L"GUESTS"
#define GROUP_SPECIALGRP_LOCAL      L"LOCAL"

//
// parmnum manifests for SetInfo calls (only comment is settable)
//

#define GROUP_ALL_PARMNUM           0
#define GROUP_NAME_PARMNUM          1
#define GROUP_COMMENT_PARMNUM       2
#define GROUP_ATTRIBUTES_PARMNUM    3

//
// the new infolevel counterparts of the old info level + parmnum
//

#define GROUP_ALL_INFOLEVEL             \
            (PARMNUM_BASE_INFOLEVEL + GROUP_ALL_PARMNUM)
#define GROUP_NAME_INFOLEVEL            \
            (PARMNUM_BASE_INFOLEVEL + GROUP_NAME_PARMNUM)
#define GROUP_COMMENT_INFOLEVEL         \
            (PARMNUM_BASE_INFOLEVEL + GROUP_COMMENT_PARMNUM)
#define GROUP_ATTRIBUTES_INFOLEVEL      \
            (PARMNUM_BASE_INFOLEVEL + GROUP_ATTRIBUTES_PARMNUM)
#define GROUP_POSIX_ID_INFOLEVEL        \
            (PARMNUM_BASE_INFOLEVEL + GROUP_POSIX_ID_PARMNUM)

#endif  // _LMGROUP_

//
// LocalGroup Class
//

#ifndef _LMLOCALGROUP_
#define _LMLOCALGROUP_

//
// Function Prototypes
//

NET_API_STATUS NET_API_FUNCTION
NetLocalGroupAdd (
    IN  LPWSTR   servername OPTIONAL,
    IN  DWORD    level,
    IN  LPBYTE   buf,
    OUT LPDWORD  parm_err OPTIONAL
    );

NET_API_STATUS NET_API_FUNCTION
NetLocalGroupAddMember (
    IN  LPWSTR   servername OPTIONAL,
    IN  LPWSTR   groupname,
    IN  PSID     membersid
    );

NET_API_STATUS NET_API_FUNCTION
NetLocalGroupEnum (
    IN  LPWSTR      servername OPTIONAL,
    IN  DWORD       level,
    OUT LPBYTE      *bufptr,
    IN  DWORD       prefmaxlen,
    OUT LPDWORD     entriesread,
    OUT LPDWORD     totalentries,
    IN OUT LPDWORD  resumehandle OPTIONAL
    );

NET_API_STATUS NET_API_FUNCTION
NetLocalGroupGetInfo (
    IN  LPWSTR   servername OPTIONAL,
    IN  LPWSTR   groupname,
    IN  DWORD    level,
    OUT LPBYTE   *bufptr
    );

NET_API_STATUS NET_API_FUNCTION
NetLocalGroupSetInfo (
    IN  LPWSTR   servername OPTIONAL,
    IN  LPWSTR   groupname,
    IN  DWORD    level,
    IN  LPBYTE   buf,
    OUT LPDWORD  parm_err OPTIONAL
    );

NET_API_STATUS NET_API_FUNCTION
NetLocalGroupDel (
    IN  LPWSTR   servername OPTIONAL,
    IN  LPWSTR   groupname
    );

NET_API_STATUS NET_API_FUNCTION
NetLocalGroupDelMember (
    IN  LPWSTR   servername OPTIONAL,
    IN  LPWSTR   groupname,
    IN  PSID     membersid
    );

NET_API_STATUS NET_API_FUNCTION
NetLocalGroupGetMembers (
    IN  LPWSTR     servername OPTIONAL,
    IN  LPWSTR     localgroupname,
    IN  DWORD      level,
    OUT LPBYTE     *bufptr,
    IN  DWORD      prefmaxlen,
    OUT LPDWORD    entriesread,
    OUT LPDWORD    totalentries,
    IN OUT LPDWORD resumehandle
    );

NET_API_STATUS NET_API_FUNCTION
NetLocalGroupSetMembers (
    IN  LPWSTR     servername OPTIONAL,
    IN  LPWSTR     groupname,
    IN  DWORD      level,
    IN  LPBYTE     buf,
    IN  DWORD      totalentries
    );

//
//  Data Structures - LocalGroup
//

typedef struct _LOCALGROUP_INFO_0 {
    LPWSTR   lgrpi0_name;
}LOCALGROUP_INFO_0, *PLOCALGROUP_INFO_0, *LPLOCALGROUP_INFO_0;

typedef struct _LOCALGROUP_INFO_1 {
    LPWSTR   lgrpi1_name;
    LPWSTR   lgrpi1_comment;
}LOCALGROUP_INFO_1, *PLOCALGROUP_INFO_1, *LPLOCALGROUP_INFO_1;

typedef struct _LOCALGROUP_INFO_1002 {
     LPWSTR  lgrpi1002_comment;
}LOCALGROUP_INFO_1002, *PLOCALGROUP_INFO_1002, *LPLOCALGROUP_INFO_1002;

typedef struct _LOCALGROUP_MEMBERS_INFO_0 {
     PSID    lgrmi0_sid;
} LOCALGROUP_MEMBERS_INFO_0, *PLOCALGROUP_MEMBERS_INFO_0,
  *LPLOCALGROUP_MEMBERS_INFO_0;

typedef struct _LOCALGROUP_MEMBERS_INFO_1 {
     PSID         lgrmi1_sid;
     SID_NAME_USE lgrmi1_sidusage;
     LPWSTR       lgrmi1_name;
} LOCALGROUP_MEMBERS_INFO_1, *PLOCALGROUP_MEMBERS_INFO_1,
  *LPLOCALGROUP_MEMBERS_INFO_1;

typedef struct _LOCALGROUP_USERS_INFO_0 {
     LPWSTR  lgrui0_name;
} LOCALGROUP_USERS_INFO_0, *PLOCALGROUP_USERS_INFO_0,
  *LPLOCALGROUP_USERS_INFO_0;


#define LOCALGROUP_NAME_PARMNUM          1
#define LOCALGROUP_COMMENT_PARMNUM       2

#endif  // _LMLOCALGROUP_

//
// Access Class
//

#ifndef _LMACCESS_
#define _LMACCESS_



//
// Function Prototypes - Access
//
//
// The NetAccess APIs are only available to downlevel
//

#define NetAccessAdd RxNetAccessAdd

NET_API_STATUS NET_API_FUNCTION
NetAccessAdd (
    IN  LPTSTR   servername OPTIONAL,
    IN  DWORD    level,
    IN  LPBYTE   buf,
    OUT LPDWORD  parm_err OPTIONAL
    );

#define NetAccessEnum RxNetAccessEnum

NET_API_STATUS NET_API_FUNCTION
NetAccessEnum (
    IN  LPTSTR     servername OPTIONAL,
    IN  LPTSTR     BasePath,
    IN  DWORD      Recursive,
    IN  DWORD      level,
    OUT LPBYTE     *bufptr,
    IN  DWORD      prefmaxlen,
    OUT LPDWORD    entriesread,
    OUT LPDWORD    totalentries,
    IN OUT LPDWORD resume_handle OPTIONAL
    );

#define NetAccessGetInfo RxNetAccessGetInfo

NET_API_STATUS NET_API_FUNCTION
NetAccessGetInfo (
    IN  LPTSTR   servername OPTIONAL,
    IN  LPTSTR   resource,
    IN  DWORD    level,
    OUT LPBYTE   *bufptr
    );

#define NetAccessSetInfo RxNetAccessSetInfo

NET_API_STATUS NET_API_FUNCTION
NetAccessSetInfo (
    IN  LPTSTR   servername OPTIONAL,
    IN  LPTSTR   resource,
    IN  DWORD    level,
    IN  LPBYTE   buf,
    OUT LPDWORD  parm_err OPTIONAL
    );

#define NetAccessDel RxNetAccessDel

NET_API_STATUS NET_API_FUNCTION
NetAccessDel (
    IN  LPTSTR   servername OPTIONAL,
    IN  LPTSTR   resource
    );

#define NetAccessGetUserPerms RxNetAccessGetUserPerms

NET_API_STATUS NET_API_FUNCTION
NetAccessGetUserPerms (
    IN  LPTSTR   servername OPTIONAL,
    IN  LPTSTR   UGname,
    IN  LPTSTR   resource,
    OUT LPDWORD  Perms
    );

//
// Data Structures - Access
//

typedef struct _ACCESS_INFO_0 {
    LPTSTR   acc0_resource_name;
}ACCESS_INFO_0, *PACCESS_INFO_0, *LPACCESS_INFO_0;

typedef struct _ACCESS_INFO_1 {
    LPTSTR   acc1_resource_name;
    DWORD    acc1_attr;
    DWORD    acc1_count;
}ACCESS_INFO_1, *PACCESS_INFO_1, *LPACCESS_INFO_1;

typedef struct _ACCESS_INFO_1002 {
     DWORD   acc1002_attr;
} ACCESS_INFO_1002, *PACCESS_INFO_1002, *LPACCESS_INFO_1002;


typedef struct _ACCESS_LIST {
    LPTSTR   acl_ugname;
    DWORD    acl_access;
}ACCESS_LIST, *PACCESS_LIST, *LPACCESS_LIST;

//
// Special Values and Constants - Access
//

//
// Maximum number of permission entries for each resource.
//

#define MAXPERMENTRIES      64

//
//  Bit values for the access permissions.  ACCESS_ALL is a handy
//  way to specify maximum permissions.  These are used in
//  acl_access field of access_list structures.
//

#define ACCESS_NONE         0
#define ACCESS_ALL          ( ACCESS_READ | \
                                ACCESS_WRITE | \
                                ACCESS_CREATE | \
                                ACCESS_EXEC | \
                                ACCESS_DELETE | \
                                ACCESS_ATRIB | \
                                ACCESS_PERM \
                            )

#define ACCESS_READ         0x01
#define ACCESS_WRITE        0x02
#define ACCESS_CREATE       0x04
#define ACCESS_EXEC         0x08
#define ACCESS_DELETE       0x10
#define ACCESS_ATRIB        0x20
#define ACCESS_PERM         0x40

#define ACCESS_GROUP        0x8000

//
// Bit values for the acc1_attr field of the ACCESS_INFO_1 structure.
//

#define ACCESS_AUDIT        0x1

#define ACCESS_SUCCESS_OPEN         0x10
#define ACCESS_SUCCESS_WRITE        0x20
#define ACCESS_SUCCESS_DELETE       0x40
#define ACCESS_SUCCESS_ACL          0x80
#define ACCESS_SUCCESS_MASK         0xF0

#define ACCESS_FAIL_OPEN            0x100
#define ACCESS_FAIL_WRITE           0x200
#define ACCESS_FAIL_DELETE          0x400
#define ACCESS_FAIL_ACL             0x800
#define ACCESS_FAIL_MASK            0xF00

#define ACCESS_FAIL_SHIFT           4

//
// Parmnum value for NetAccessSetInfo.
//

#define ACCESS_RESOURCE_NAME_PARMNUM    1
#define ACCESS_ATTR_PARMNUM             2
#define ACCESS_COUNT_PARMNUM            3
#define ACCESS_ACCESS_LIST_PARMNUM      4

//
// the new infolevel counterparts of the old info level + parmnum
//

#define ACCESS_RESOURCE_NAME_INFOLEVEL  \
            (PARMNUM_BASE_INFOLEVEL + ACCESS_RESOURCE_NAME_PARMNUM)
#define ACCESS_ATTR_INFOLEVEL           \
            (PARMNUM_BASE_INFOLEVEL + ACCESS_ATTR_PARMNUM)
#define ACCESS_COUNT_INFOLEVEL          \
            (PARMNUM_BASE_INFOLEVEL + ACCESS_COUNT_PARMNUM)
#define ACCESS_ACCESS_LIST_INFOLEVEL    \
            (PARMNUM_BASE_INFOLEVEL + ACCESS_ACCESS_LIST_PARMNUM)

//
// ACCESS_LETTERS defines a letter for each bit position in
// the acl_access field of struct access_list.  Note that some
// bits have a corresponding letter of ' ' (space).
//

#define ACCESS_LETTERS      "RWCXDAP         "

#endif // _LMACCESS_

//
// Domain Class
//

#ifndef _LMDOMAIN_
#define _LMDOMAIN_

//
// Function Prototypes - Domain
//

NET_API_STATUS NET_API_FUNCTION
NetGetDCName (
    IN  LPWSTR   servername OPTIONAL,
    IN  LPWSTR   domainname OPTIONAL,
    OUT LPBYTE  *bufptr
    );

NET_API_STATUS NET_API_FUNCTION
NetGetAnyDCName (
    IN  LPWSTR   servername OPTIONAL,
    IN  LPWSTR   domainname OPTIONAL,
    OUT LPBYTE  *bufptr
    );


NET_API_STATUS NET_API_FUNCTION
I_NetLogonControl(
    IN LPWSTR ServerName OPTIONAL,
    IN DWORD FunctionCode,
    IN DWORD QueryLevel,
    OUT LPBYTE *Buffer
    );

NET_API_STATUS NET_API_FUNCTION
I_NetLogonControl2(
    IN LPWSTR ServerName OPTIONAL,
    IN DWORD FunctionCode,
    IN DWORD QueryLevel,
    IN LPBYTE Data,
    OUT LPBYTE *Buffer
    );



//
// Special Values and Constants - Domain
//

//
// FunctionCode values for I_NetLogonControl.
//
// NOTE : if you change the following NETLOGON_CONTROL_* values,
// change them in net\svcdlls\logonsrv\logon.idl file also.
//

#define NETLOGON_CONTROL_QUERY         1    // No-op: just query
#define NETLOGON_CONTROL_REPLICATE     2    // Force replicate on BDC
#define NETLOGON_CONTROL_SYNCHRONIZE   3    // Force synchronize on BDC
#define NETLOGON_CONTROL_PDC_REPLICATE 4    // Force PDC to broadcast change
#define NETLOGON_CONTROL_REDISCOVER    5    // Force to re-discover trusted domain DCs
#define NETLOGON_CONTROL_TC_QUERY      6    // Query status of specified trusted channel status

// Debug function codes

#define NETLOGON_CONTROL_BACKUP_CHANGE_LOG  0xFFFC
#define NETLOGON_CONTROL_TRUNCATE_LOG       0xFFFD
#define NETLOGON_CONTROL_SET_DBFLAG         0xFFFE
#define NETLOGON_CONTROL_BREAKPOINT         0xFFFF

//
// Query level 1 for I_NetLogonControl
//

typedef struct _NETLOGON_INFO_1 {
        DWORD netlog1_flags;
        NET_API_STATUS netlog1_pdc_connection_status;
} NETLOGON_INFO_1, *PNETLOGON_INFO_1;

typedef struct _NETLOGON_INFO_2 {
        DWORD netlog2_flags;
        NET_API_STATUS netlog2_pdc_connection_status;
#ifdef MIDL_PASS
        [string] wchar_t * netlog2_trusted_dc_name;
#else
        LPWSTR netlog2_trusted_dc_name;
#endif // MIDL_PASS
        NET_API_STATUS netlog2_tc_connection_status;
} NETLOGON_INFO_2, *PNETLOGON_INFO_2;

//
// Values of netlog1_flags
//

#define NETLOGON_REPLICATION_NEEDED       0x01  // Database is out of date
#define NETLOGON_REPLICATION_IN_PROGRESS  0x02  // Replication is happening now
#define NETLOGON_FULL_SYNC_REPLICATION    0x04  // full sync replication required/progress

#ifdef __cplusplus
}
#endif

#endif // _LMDOMAIN_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\tools\c932\inc\lmapibuf.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1991-1993  Microsoft Corporation

Module Name:

    lmapibuf.h

Abstract:

    This file contains information about NetApiBuffer APIs.

Author:

    Dan Lafferty (Danl) 15-Mar-1991

Environment:

    User Mode - Win32

Notes:

    You must include LMCONS.H before this file, since this file depends
    on values defined in LMCONS.H.

Revision History:

    15-Mar-1991  Danl
        Attached NT-style header
    03-Dec-1991  JohnRo
        Added public NetApiBufferAllocate, NetApiBufferReallocate, and
        NetApiBufferSize APIs.

--*/

#ifndef _LMAPIBUF_
#define _LMAPIBUF_

#ifdef __cplusplus
extern "C" {
#endif

//
// Function Prototypes
//

NET_API_STATUS NET_API_FUNCTION
NetApiBufferAllocate(
    IN DWORD ByteCount,
    OUT LPVOID * Buffer
    );

NET_API_STATUS NET_API_FUNCTION
NetApiBufferFree (
    IN LPVOID Buffer
    );

NET_API_STATUS NET_API_FUNCTION
NetApiBufferReallocate(
    IN LPVOID OldBuffer OPTIONAL,
    IN DWORD NewByteCount,
    OUT LPVOID * NewBuffer
    );

NET_API_STATUS NET_API_FUNCTION
NetApiBufferSize(
    IN LPVOID Buffer,
    OUT LPDWORD ByteCount
    );


//
// The following private function will go away eventually.
// Call NetApiBufferAllocate instead.
//
NET_API_STATUS NET_API_FUNCTION
NetapipBufferAllocate (                 // Internal Function
    IN DWORD ByteCount,
    OUT LPVOID * Buffer
    );

#ifdef __cplusplus
}
#endif

#endif // _LMAPIBUF_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\tools\c932\inc\lmat.h ===
/*++ BUILD Version: 0006    // Increment this if a change has global effects

Copyright (c) 1992  Microsoft Corporation

Module Name:

    lmat.h

Abstract:

    This file contains structures, function prototypes, and definitions
    for the schedule service API-s.

Author:

    Vladimir Z. Vulovic     (vladimv)       06 - November - 1992

Environment:

    User Mode - Win32
    Portable to any flat, 32-bit environment.  (Uses Win32 typedefs.)
    Requires ANSI C extensions: slash-slash comments, long external names.

Notes:

    You must include NETCONS.H before this file, since this file depends
    on values defined in NETCONS.H.

Revision History:

--*/

#ifndef _LMAT_
#define _LMAT_

#ifdef __cplusplus
extern "C" {
#endif

//
//  The following bits are used with Flags field in structures below.
//

//
//  Do we exec programs for this job periodically (/EVERY switch) 
//  or one time (/NEXT switch).
//
#define JOB_RUN_PERIODICALLY            0x01    //  set if EVERY


//
//  Was there an error last time we tried to exec a program on behalf of
//  this job.
//  This flag is meaningfull on output only!
//
#define JOB_EXEC_ERROR                  0x02    //  set if error

//
//  Will this job run today or tomorrow.
//  This flag is meaningfull on output only!
//
#define JOB_RUNS_TODAY                  0x04    //  set if today

//
//  Add current day of the month to DaysOfMonth input.
//  This flag is meaningfull on input only!
//
#define JOB_ADD_CURRENT_DATE            0x08    // set if to add current date


#define JOB_INPUT_FLAGS     (   JOB_RUN_PERIODICALLY        |   \
                                JOB_ADD_CURRENT_DATE    )

#define JOB_OUTPUT_FLAGS    (   JOB_RUN_PERIODICALLY        |   \
                                JOB_EXEC_ERROR              |   \
                                JOB_RUNS_TODAY      )



typedef struct _AT_INFO {
    DWORD   JobTime;
    DWORD   DaysOfMonth;
    UCHAR   DaysOfWeek;
    UCHAR   Flags;
    LPWSTR  Command;
} AT_INFO, *PAT_INFO, *LPAT_INFO;

typedef struct _AT_ENUM {
    DWORD   JobId;
    DWORD   JobTime;
    DWORD   DaysOfMonth;
    UCHAR   DaysOfWeek;
    UCHAR   Flags;
    LPWSTR  Command;
} AT_ENUM, *PAT_ENUM, *LPAT_ENUM;

NET_API_STATUS NET_API_FUNCTION
NetScheduleJobAdd(
    IN      LPWSTR          Servername  OPTIONAL,
    IN      LPBYTE          Buffer,
    OUT     LPDWORD         JobId
    );

NET_API_STATUS NET_API_FUNCTION
NetScheduleJobDel(
    IN      LPWSTR          Servername  OPTIONAL,
    IN      DWORD           MinJobId,
    IN      DWORD           MaxJobId
    );

NET_API_STATUS NET_API_FUNCTION
NetScheduleJobEnum(
    IN      LPWSTR          Servername              OPTIONAL,
    OUT     LPBYTE *        PointerToBuffer,
    IN      DWORD           PrefferedMaximumLength,
    OUT     LPDWORD         EntriesRead,
    OUT     LPDWORD         TotalEntries,
    IN OUT  LPDWORD         ResumeHandle
    );

NET_API_STATUS NET_API_FUNCTION
NetScheduleJobGetInfo(
    IN      LPWSTR          Servername              OPTIONAL,
    IN      DWORD           JobId,
    OUT     LPBYTE *        PointerToBuffer
    );

#ifdef __cplusplus
}
#endif

#endif // _LMAT_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\tools\c932\inc\lmchdev.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1991-1993  Microsoft Corporation

Module Name:

    lmchdev.h

Abstract:

    This module defines the API function prototypes and data structures
    for the following groups of NT API functions:
        NetCharDev
        NetCharDevQ
        NetHandle

Author:

    Dan Lafferty (danl)  11-Mar-1991

[Environment:]

    User Mode - Win32

[Notes:]

    You must include NETCONS.H before this file, since this file depends
    on values defined in NETCONS.H.

Revision History:

    11-Mar-1991  Danl
        Created from LM2.0 header files and NT-LAN API Spec.
    14-Apr-1991 w-shanku
        Changed ParmNum constants to be more consistent with OS/2 parmnums.

--*/

#ifndef _LMCHDEV_
#define _LMCHDEV_

#ifdef __cplusplus
extern "C" {
#endif

//
// CharDev Class
//

//
// Function Prototypes - CharDev
//

NET_API_STATUS NET_API_FUNCTION
NetCharDevEnum (
    IN  LPTSTR      servername,
    IN  DWORD       level,
    OUT LPBYTE      *bufptr,
    IN  DWORD       prefmaxlen,
    OUT LPDWORD     entriesread,
    OUT LPDWORD     totalentries,
    IN OUT LPDWORD  resume_handle
    );

NET_API_STATUS NET_API_FUNCTION
NetCharDevGetInfo (
    IN  LPTSTR  servername,
    IN  LPTSTR  devname,
    IN  DWORD   level,
    OUT LPBYTE  *bufptr
    );

NET_API_STATUS NET_API_FUNCTION
NetCharDevControl (
    IN  LPTSTR  servername,
    IN  LPTSTR  devname,
    IN  DWORD   opcode
    );

//
// Data Structures - CharDev
//

typedef struct _CHARDEV_INFO_0 {
    LPTSTR  ch0_dev;
} CHARDEV_INFO_0, *PCHARDEV_INFO_0, *LPCHARDEV_INFO_0;

typedef struct _CHARDEV_INFO_1 {
    LPTSTR  ch1_dev;
    DWORD   ch1_status;
    LPTSTR  ch1_username;
    DWORD   ch1_time;
} CHARDEV_INFO_1, *PCHARDEV_INFO_1, *LPCHARDEV_INFO_1;


//
// CharDevQ Class
//

//
// Function Prototypes - CharDevQ
//

NET_API_STATUS NET_API_FUNCTION
NetCharDevQEnum (
    IN  LPTSTR      servername,
    IN  LPTSTR      username,
    IN  DWORD       level,
    OUT LPBYTE      *bufptr,
    IN  DWORD       prefmaxlen,
    OUT LPDWORD     entriesread,
    OUT LPDWORD     totalentries,
    IN OUT LPDWORD  resume_handle
    );

NET_API_STATUS NET_API_FUNCTION
NetCharDevQGetInfo (
    IN  LPTSTR  servername,
    IN  LPTSTR  queuename,
    IN  LPTSTR  username,
    IN  DWORD   level,
    OUT LPBYTE  *bufptr
    );

NET_API_STATUS NET_API_FUNCTION
NetCharDevQSetInfo (
    IN  LPTSTR  servername,
    IN  LPTSTR  queuename,
    IN  DWORD   level,
    IN  LPBYTE  buf,
    OUT LPDWORD parm_err
    );

NET_API_STATUS NET_API_FUNCTION
NetCharDevQPurge (
    IN  LPTSTR  servername,
    IN  LPTSTR  queuename
    );

NET_API_STATUS NET_API_FUNCTION
NetCharDevQPurgeSelf (
    IN  LPTSTR  servername,
    IN  LPTSTR  queuename,
    IN  LPTSTR  computername
    );

//
// Data Structures - CharDevQ
//

typedef struct _CHARDEVQ_INFO_0 {
    LPTSTR  cq0_dev;
} CHARDEVQ_INFO_0, *PCHARDEVQ_INFO_0, *LPCHARDEVQ_INFO_0;

typedef struct _CHARDEVQ_INFO_1 {
    LPTSTR  cq1_dev;
    DWORD   cq1_priority;
    LPTSTR  cq1_devs;
    DWORD   cq1_numusers;
    DWORD   cq1_numahead;
} CHARDEVQ_INFO_1, *PCHARDEVQ_INFO_1, *LPCHARDEVQ_INFO_1;

typedef struct _CHARDEVQ_INFO_1002 {
    DWORD   cq1002_priority;
} CHARDEVQ_INFO_1002, *PCHARDEVQ_INFO_1002, *LPCHARDEVQ_INFO_1002;

typedef struct _CHARDEVQ_INFO_1003 {
    LPTSTR  cq1003_devs;
} CHARDEVQ_INFO_1003, *PCHARDEVQ_INFO_1003, *LPCHARDEVQ_INFO_1003;


//
// Special Values and Constants
//

//
//      Bits for chardev_info_1 field ch1_status.
//

#define CHARDEV_STAT_OPENED             0x02
#define CHARDEV_STAT_ERROR              0x04

//
//      Opcodes for NetCharDevControl
//

#define CHARDEV_CLOSE                   0

//
// Values for parm_err parameter.
//

#define CHARDEVQ_DEV_PARMNUM        1
#define CHARDEVQ_PRIORITY_PARMNUM   2
#define CHARDEVQ_DEVS_PARMNUM       3
#define CHARDEVQ_NUMUSERS_PARMNUM   4
#define CHARDEVQ_NUMAHEAD_PARMNUM   5

//
// Single-field infolevels for NetCharDevQSetInfo.
//

#define CHARDEVQ_PRIORITY_INFOLEVEL     \
            (PARMNUM_BASE_INFOLEVEL + CHARDEVQ_PRIORITY_PARMNUM)
#define CHARDEVQ_DEVS_INFOLEVEL         \
            (PARMNUM_BASE_INFOLEVEL + CHARDEVQ_DEVS_PARMNUM)

//
//      Minimum, maximum, and recommended default for priority.
//

#define CHARDEVQ_MAX_PRIORITY           1
#define CHARDEVQ_MIN_PRIORITY           9
#define CHARDEVQ_DEF_PRIORITY           5

//
//      Value indicating no requests in the queue.
//

#define CHARDEVQ_NO_REQUESTS            -1

#endif // _LMCHDEV_

//
// Handle Class
//

#ifndef _LMHANDLE_
#define _LMHANDLE_

//
// Function Prototypes
//

NET_API_STATUS NET_API_FUNCTION
NetHandleGetInfo (
    IN  HANDLE  handle,
    IN  DWORD   level,
    OUT LPBYTE  *bufptr
    );

NET_API_STATUS NET_API_FUNCTION
NetHandleSetInfo (
    IN  HANDLE  handle,
    IN  DWORD   level,
    IN  LPBYTE  buf,
    IN  DWORD   parmnum,
    OUT LPDWORD parmerr
    );

//
//  Data Structures
//

typedef struct _HANDLE_INFO_1 {
    DWORD   hdli1_chartime;
    DWORD   hdli1_charcount;
}HANDLE_INFO_1, *PHANDLE_INFO_1, *LPHANDLE_INFO_1;

//
// Special Values and Constants
//

//
//      Handle Get Info Levels
//

#define HANDLE_INFO_LEVEL_1                 1

//
//      Handle Set Info parm numbers
//

#define HANDLE_CHARTIME_PARMNUM     1
#define HANDLE_CHARCOUNT_PARMNUM    2

#ifdef __cplusplus
}
#endif

#endif // _LMHANDLE_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\tools\c932\inc\lmaudit.h ===
/*++ BUILD Version: 0003    // Increment this if a change has global effects

Copyright (c) 1991-1993  Microsoft Corporation

Module Name:

    lmaudit.h

Abstract:

    This module defines the API function prototypes and data structures
    for the following groups of NT API functions:
        NetAudit

Author:

    Dan Lafferty (danl)  29-Mar-1991

Environment:

    User Mode - Win32

Notes:

    You must include NETCONS.H before this file, since this file depends
    on values defined in NETCONS.H.

Revision History:

    28-Mar-1991  Danl
        Ported from LM2.0 and the LMNETAPI spec.
    25-Apr-1991  DanHi
	Added define for HLOG used by both audit and error logs, surrounded
	by a protective ifdef.	Changed ae_ss_status to ae_sv_status to match
	LanMan
    12-Nov-1991 JohnRo
        AUDIT_ENTRY structure needs changes to prevent alignment/padding bugs.
        Added OPTIONAL keyword as applicable.   Work toward UNICODE.
    26-Oct-1992 JohnRo
        Correct typedef name for pointer to AE_SRVSTATUS.
        Added AE_LOCKOUT structure and typedef.

--*/

#ifndef _LMAUDIT_
#define _LMAUDIT_

#ifdef __cplusplus
extern "C" {
#endif

#ifndef _LMHLOGDEFINED_
#define _LMHLOGDEFINED_

typedef struct _HLOG {
     DWORD          time;
     DWORD          last_flags;
     DWORD          offset;
     DWORD          rec_offset;
} HLOG, *PHLOG, *LPHLOG;

#define LOGFLAGS_FORWARD	0
#define LOGFLAGS_BACKWARD	0x1
#define LOGFLAGS_SEEK		0x2

#endif

//
// Function Prototypes - Audit
//

NET_API_STATUS NET_API_FUNCTION
NetAuditClear (
    IN  LPTSTR  server OPTIONAL,
    IN  LPTSTR  backupfile OPTIONAL,
    IN  LPTSTR  service OPTIONAL  // WARNING: buggy support before LM 2.0C!!
    );

NET_API_STATUS NET_API_FUNCTION
NetAuditRead (
    IN  LPTSTR  server OPTIONAL,
    IN  LPTSTR  service OPTIONAL,  // WARNING: buggy support before LM 2.0C!!
    IN  LPHLOG  auditloghandle,
    IN  DWORD   offset,
    IN  LPDWORD reserved1 OPTIONAL,
    IN  DWORD   reserved2,
    IN  DWORD   offsetflag,
    OUT LPBYTE  *bufptr,
    IN  DWORD   prefmaxlen,
    OUT LPDWORD bytesread,
    OUT LPDWORD totalavailable
    );

NET_API_STATUS NET_API_FUNCTION
NetAuditWrite (
    IN  DWORD   type,
    IN  LPBYTE  buf,
    IN  DWORD   numbytes,
    IN  LPTSTR  service OPTIONAL,
    IN  LPBYTE  reserved OPTIONAL
    );


//
// Data Structures - Audit
//

typedef struct _AUDIT_ENTRY {
     DWORD          ae_len;
     DWORD          ae_reserved;
     DWORD          ae_time;
     DWORD          ae_type;
     DWORD          ae_data_offset;  /* Offset from beginning
                              address of audit_entry */
     DWORD          ae_data_size;  // byte count of ae_data area (not incl pad).
} AUDIT_ENTRY, *PAUDIT_ENTRY, *LPAUDIT_ENTRY;

// BUGBUG: Temporary to let users ifdef on this struct layout.
#define REVISED_AUDIT_ENTRY_STRUCT


typedef struct _AE_SRVSTATUS {
     DWORD	    ae_sv_status;
} AE_SRVSTATUS, *PAE_SRVSTATUS, *LPAE_SRVSTATUS;

typedef struct _AE_SESSLOGON {
     DWORD          ae_so_compname;
     DWORD          ae_so_username;
     DWORD          ae_so_privilege;
} AE_SESSLOGON, *PAE_SESSLOGON, *LPAE_SESSLOGON;

typedef struct _AE_SESSLOGOFF {
     DWORD          ae_sf_compname;
     DWORD          ae_sf_username;
     DWORD          ae_sf_reason;
} AE_SESSLOGOFF, *PAE_SESSLOGOFF, *LPAE_SESSLOGOFF;

typedef struct _AE_SESSPWERR {
     DWORD          ae_sp_compname;
     DWORD          ae_sp_username;
} AE_SESSPWERR, *PAE_SESSPWERR, *LPAE_SESSPWERR;

typedef struct _AE_CONNSTART {
     DWORD          ae_ct_compname;
     DWORD          ae_ct_username;
     DWORD          ae_ct_netname;
     DWORD          ae_ct_connid;
} AE_CONNSTART, *PAE_CONNSTART, *LPAE_CONNSTART;

typedef struct _AE_CONNSTOP {
     DWORD          ae_cp_compname;
     DWORD          ae_cp_username;
     DWORD          ae_cp_netname;
     DWORD          ae_cp_connid;
     DWORD          ae_cp_reason;
} AE_CONNSTOP, *PAE_CONNSTOP, *LPAE_CONNSTOP;

typedef struct _AE_CONNREJ {
     DWORD          ae_cr_compname;
     DWORD          ae_cr_username;
     DWORD          ae_cr_netname;
     DWORD          ae_cr_reason;
} AE_CONNREJ, *PAE_CONNREJ, *LPAE_CONNREJ;

typedef struct _AE_RESACCESS {
     DWORD          ae_ra_compname;
     DWORD          ae_ra_username;
     DWORD          ae_ra_resname;
     DWORD          ae_ra_operation;
     DWORD          ae_ra_returncode;
     DWORD          ae_ra_restype;
     DWORD          ae_ra_fileid;
} AE_RESACCESS, *PAE_RESACCESS, *LPAE_RESACCESS;

typedef struct _AE_RESACCESSREJ {
     DWORD          ae_rr_compname;
     DWORD          ae_rr_username;
     DWORD          ae_rr_resname;
     DWORD          ae_rr_operation;
} AE_RESACCESSREJ, *PAE_RESACCESSREJ, *LPAE_RESACCESSREJ;

typedef struct _AE_CLOSEFILE {
     DWORD          ae_cf_compname;
     DWORD          ae_cf_username;
     DWORD          ae_cf_resname;
     DWORD          ae_cf_fileid;
     DWORD          ae_cf_duration;
     DWORD          ae_cf_reason;
} AE_CLOSEFILE, *PAE_CLOSEFILE, *LPAE_CLOSEFILE;

typedef struct _AE_SERVICESTAT {
     DWORD          ae_ss_compname;
     DWORD          ae_ss_username;
     DWORD          ae_ss_svcname;
     DWORD          ae_ss_status;
     DWORD          ae_ss_code;
     DWORD          ae_ss_text;
     DWORD          ae_ss_returnval;
} AE_SERVICESTAT, *PAE_SERVICESTAT, *LPAE_SERVICESTAT;

typedef struct _AE_ACLMOD {
     DWORD          ae_am_compname;
     DWORD          ae_am_username;
     DWORD          ae_am_resname;
     DWORD          ae_am_action;
     DWORD          ae_am_datalen;
} AE_ACLMOD, *PAE_ACLMOD, *LPAE_ACLMOD;

typedef struct _AE_UASMOD {
     DWORD          ae_um_compname;
     DWORD          ae_um_username;
     DWORD          ae_um_resname;
     DWORD          ae_um_rectype;
     DWORD          ae_um_action;
     DWORD          ae_um_datalen;
} AE_UASMOD, *PAE_UASMOD, *LPAE_UASMOD;

typedef struct _AE_NETLOGON {
     DWORD          ae_no_compname;
     DWORD          ae_no_username;
     DWORD          ae_no_privilege;
     DWORD          ae_no_authflags;
} AE_NETLOGON, *PAE_NETLOGON, *LPAE_NETLOGON;

typedef struct _AE_NETLOGOFF {
     DWORD          ae_nf_compname;
     DWORD          ae_nf_username;
     DWORD          ae_nf_reserved1;
     DWORD          ae_nf_reserved2;
} AE_NETLOGOFF, *PAE_NETLOGOFF, *LPAE_NETLOGOFF;

typedef struct _AE_ACCLIM {
     DWORD          ae_al_compname;
     DWORD          ae_al_username;
     DWORD          ae_al_resname;
     DWORD          ae_al_limit;
} AE_ACCLIM, *PAE_ACCLIM, *LPAE_ACCLIM;

#define ACTION_LOCKOUT          00
#define ACTION_ADMINUNLOCK      01

typedef struct _AE_LOCKOUT {
    DWORD           ae_lk_compname;     // Ptr to computername of client.
    DWORD           ae_lk_username;     // Ptr to username of client (NULL
                                        //  if same as computername).
    DWORD           ae_lk_action;       // Action taken on account:
                                        // 0 means locked out, 1 means not.
    DWORD           ae_lk_bad_pw_count; // Bad password count at the time
                                        // of lockout.
} AE_LOCKOUT, *PAE_LOCKOUT, *LPAE_LOCKOUT;

typedef struct _AE_GENERIC {
     DWORD          ae_ge_msgfile;
     DWORD          ae_ge_msgnum;
     DWORD          ae_ge_params;
     DWORD          ae_ge_param1;
     DWORD          ae_ge_param2;
     DWORD          ae_ge_param3;
     DWORD          ae_ge_param4;
     DWORD          ae_ge_param5;
     DWORD          ae_ge_param6;
     DWORD          ae_ge_param7;
     DWORD          ae_ge_param8;
     DWORD          ae_ge_param9;
} AE_GENERIC, *PAE_GENERIC, *LPAE_GENERIC;

//
// Special Values and Constants - Audit
//

//
// 	Audit entry types (field ae_type in audit_entry).
//

#define AE_SRVSTATUS	0
#define AE_SESSLOGON	1
#define AE_SESSLOGOFF	2
#define AE_SESSPWERR	3
#define AE_CONNSTART	4
#define AE_CONNSTOP	5
#define AE_CONNREJ	6
#define AE_RESACCESS	7
#define AE_RESACCESSREJ	8
#define AE_CLOSEFILE	9
#define AE_SERVICESTAT	11
#define AE_ACLMOD	12
#define AE_UASMOD	13
#define AE_NETLOGON	14
#define AE_NETLOGOFF	15
#define AE_NETLOGDENIED 16
#define AE_ACCLIMITEXCD 17
#define AE_RESACCESS2	18
#define AE_ACLMODFAIL	19
#define AE_LOCKOUT      20
#define AE_GENERIC_TYPE 21
//
//	Values for ae_ss_status field of ae_srvstatus.
//

#define AE_SRVSTART	0
#define AE_SRVPAUSED	1
#define AE_SRVCONT	2
#define AE_SRVSTOP	3

//
// 	Values for ae_so_privilege field of ae_sesslogon.
//

#define AE_GUEST	0		
#define AE_USER		1
#define AE_ADMIN	2

//
//	Values for various ae_XX_reason fields.
//

#define AE_NORMAL	0		
#define AE_USERLIMIT	0
#define AE_GENERAL	0
#define AE_ERROR	1
#define AE_SESSDIS	1
#define AE_BADPW	1
#define AE_AUTODIS	2
#define AE_UNSHARE	2
#define AE_ADMINPRIVREQD 2
#define AE_ADMINDIS	3
#define AE_NOACCESSPERM 3
#define AE_ACCRESTRICT	4

#define	AE_NORMAL_CLOSE	0
#define	AE_SES_CLOSE	1
#define	AE_ADMIN_CLOSE	2

//
// Values for xx_subreason fields.
//

#define AE_LIM_UNKNOWN	    0
#define AE_LIM_LOGONHOURS   1
#define AE_LIM_EXPIRED	    2
#define AE_LIM_INVAL_WKSTA  3
#define AE_LIM_DISABLED     4
#define AE_LIM_DELETED	    5

//
// Values for xx_action fields
//

#define AE_MOD		0
#define AE_DELETE	1
#define AE_ADD		2

//
// Types of UAS record for um_rectype field
//

#define AE_UAS_USER	    0
#define AE_UAS_GROUP	    1
#define AE_UAS_MODALS	    2

//
// Bitmasks for auditing events
//
// The parentheses around the hex constants broke h_to_inc
// and have been purged from the face of the earth.
//

#define SVAUD_SERVICE           0x1
#define SVAUD_GOODSESSLOGON     0x6
#define SVAUD_BADSESSLOGON      0x18
#define SVAUD_SESSLOGON         (SVAUD_GOODSESSLOGON | SVAUD_BADSESSLOGON)
#define SVAUD_GOODNETLOGON      0x60
#define SVAUD_BADNETLOGON       0x180
#define SVAUD_NETLOGON          (SVAUD_GOODNETLOGON | SVAUD_BADNETLOGON)
#define SVAUD_LOGON             (SVAUD_NETLOGON | SVAUD_SESSLOGON)
#define SVAUD_GOODUSE           0x600
#define SVAUD_BADUSE            0x1800
#define SVAUD_USE               (SVAUD_GOODUSE | SVAUD_BADUSE)
#define SVAUD_USERLIST          0x2000
#define SVAUD_PERMISSIONS       0x4000
#define SVAUD_RESOURCE          0x8000
#define SVAUD_LOGONLIM		0x00010000

//
// Resource access audit bitmasks.
//

#define AA_AUDIT_ALL	    0x0001
#define AA_A_OWNER	    0x0004
#define AA_CLOSE	    0x0008
#define AA_S_OPEN	    0x0010
#define AA_S_WRITE	    0x0020
#define AA_S_CREATE	    0x0020
#define AA_S_DELETE	    0x0040
#define AA_S_ACL	    0x0080
#define AA_S_ALL	    ( AA_S_OPEN | AA_S_WRITE | AA_S_DELETE | AA_S_ACL)
#define AA_F_OPEN	    0x0100
#define AA_F_WRITE	    0x0200
#define AA_F_CREATE	    0x0200
#define AA_F_DELETE	    0x0400
#define AA_F_ACL	    0x0800
#define AA_F_ALL	    ( AA_F_OPEN | AA_F_WRITE | AA_F_DELETE | AA_F_ACL)

// Pinball-specific
#define AA_A_OPEN	    0x1000
#define AA_A_WRITE	    0x2000
#define AA_A_CREATE	    0x2000
#define AA_A_DELETE	    0x4000
#define AA_A_ACL	    0x8000
#define AA_A_ALL	    ( AA_F_OPEN | AA_F_WRITE | AA_F_DELETE | AA_F_ACL)


#ifdef __cplusplus
}
#endif

#endif  // _LMAUDIT_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\tools\c932\inc\lmbrowsr.h ===
/*++ BUILD Version: 0007    // Increment this if a change has global effects

Copyright (c) 1990-1993  Microsoft Corporation

Module Name:

    lmbrowsr.h

Abstract:

    This file contains information about browser stubbed versions of the
    NetServer APIs.
        Function Prototypes
        Data Structures
        Definition of special values

Author:

    Dan Lafferty (danl)  24-Jan-1991

Environment:

    User Mode - Win32

Notes:

    You must include NETCONS.H before this file, since this file depends
    on values defined in NETCONS.H.

Revision History:

    25-Jan-1991  Danl
        Ported from LM2.0
    12-Feb-1991  danl
        Changed info levels to match current spec - no more info level 3.
    14-Apr-1991  w-shanku
        Changed parmnum constants to be more consistent with OS/2 parmnums.
    19-Apr-1991 JohnRo
        Added OPTIONAL keywords to APIs.  Added SV_MAX_SRV_HEUR_LEN from LM 2.x
    09-May-1991 JohnRo
        Implement UNICODE.
    22-May-1991 JohnRo
        Added three new SV_TYPE equates from LM 2.x source.
    23-May-1991 JohnRo
        Added sv403_autopath.
    26-May-1991 JohnRo
        Corrected value of SV_ERRORALERT_PARMNUM.
    18-Jun-1991 JohnRo
        Changed sv102_disc to be signed, and changed SV_NODISC to be 32-bits.
        Added sv102_licenses.

--*/

#ifndef _LMBROWSR_
#define _LMBROWSR_

#ifdef __cplusplus
extern "C" {
#endif


typedef struct _BROWSER_STATISTICS {
    LARGE_INTEGER   StatisticsStartTime;
    LARGE_INTEGER   NumberOfServerAnnouncements;
    LARGE_INTEGER   NumberOfDomainAnnouncements;
    ULONG           NumberOfElectionPackets;
    ULONG           NumberOfMailslotWrites;
    ULONG           NumberOfGetBrowserServerListRequests;
    ULONG           NumberOfServerEnumerations;
    ULONG           NumberOfDomainEnumerations;
    ULONG           NumberOfOtherEnumerations;
    ULONG           NumberOfMissedServerAnnouncements;
    ULONG           NumberOfMissedMailslotDatagrams;
    ULONG           NumberOfMissedGetBrowserServerListRequests;
    ULONG           NumberOfFailedServerAnnounceAllocations;
    ULONG           NumberOfFailedMailslotAllocations;
    ULONG           NumberOfFailedMailslotReceives;
    ULONG           NumberOfFailedMailslotWrites;
    ULONG           NumberOfFailedMailslotOpens;
    ULONG           NumberOfDuplicateMasterAnnouncements;
    LARGE_INTEGER   NumberOfIllegalDatagrams;
} BROWSER_STATISTICS, *PBROWSER_STATISTICS, *LPBROWSER_STATISTICS;


//
// Function Prototypes - BROWSER
//

NET_API_STATUS NET_API_FUNCTION
I_BrowserServerEnum (
    IN  LPTSTR      servername OPTIONAL,
    IN  LPTSTR      transport OPTIONAL,
    IN  LPTSTR      clientname OPTIONAL,
    IN  DWORD       level,
    OUT LPBYTE      *bufptr,
    IN  DWORD       prefmaxlen,
    OUT LPDWORD     entriesread,
    OUT LPDWORD     totalentries,
    IN  DWORD       servertype,
    IN  LPTSTR      domain OPTIONAL,
    IN OUT LPDWORD  resume_handle OPTIONAL
    );


NET_API_STATUS
I_BrowserQueryOtherDomains (
    IN  LPTSTR      servername OPTIONAL,
    OUT LPBYTE      *bufptr,
    OUT LPDWORD     entriesread,
    OUT LPDWORD     totalentries
    );

NET_API_STATUS
I_BrowserResetNetlogonState (
    IN  LPTSTR      servername OPTIONAL
    );

NET_API_STATUS
I_BrowserQueryStatistics (
    IN  LPTSTR      servername OPTIONAL,
    OUT LPBROWSER_STATISTICS *statistics
    );

NET_API_STATUS
I_BrowserResetStatistics (
    IN  LPTSTR      servername OPTIONAL
    );


WORD
I_BrowserServerEnumForXactsrv(
    IN LPTSTR TransportName OPTIONAL,
    IN LPTSTR ClientName OPTIONAL,

    IN ULONG NtLevel,
    IN USHORT ClientLevel,

    OUT PVOID Buffer,
    IN WORD BufferLength,
    IN DWORD PreferedMaximumLength,

    OUT LPDWORD EntriesRead,
    OUT LPDWORD TotalEntries,

    IN DWORD ServerType,
    IN LPTSTR Domain,

    OUT PWORD Converter

    );

#ifdef __cplusplus
}
#endif

#if DBG
NET_API_STATUS
I_BrowserDebugTrace(
    PWCHAR Server,
    PCHAR Buffer
    );

#endif

#endif // _LMBROWSR_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\tools\c932\inc\lmconfig.h ===
/*++ BUILD Version: 0003    // Increment this if a change has global effects

Copyright (c) 1991-1993  Microsoft Corporation

Module Name:

    lmconfig.h

Abstract:

    This module defines the API function prototypes and data structures
    for the following groups of NT API functions:
        NetConfig

Author:

    Dan Lafferty (danl)  29-Mar-1991

Environment:

    User Mode - Win32

Notes:

    You must include NETCONS.H before this file, since this file depends
    on values defined in NETCONS.H.

Revision History:

    28-Mar-1991  Danl
        Ported from LM2.0 and the LMNETAPI spec.
    20-Nov-1991  JohnRo
        Implemented remote NetConfig APIs.  Changed LPSTR to LPTSTR.
        NetConfigGet and NetConfigGetAll shouldn't return total available.
        Don't use ULONG.
    08-Apr-1992 JohnRo
        Fixed UNICODE handling.

--*/

#ifndef _LMCONFIG_
#define _LMCONFIG_

#ifdef __cplusplus
extern "C" {
#endif

#define REVISED_CONFIG_APIS

//
// Function Prototypes - Config
//

NET_API_STATUS NET_API_FUNCTION
NetConfigGet (
    IN  LPTSTR  server OPTIONAL,
    IN  LPTSTR  component,
    IN  LPTSTR  parameter,
#ifdef REVISED_CONFIG_APIS
    OUT LPBYTE  *bufptr
#else
    OUT LPBYTE  *bufptr,
    OUT LPDWORD totalavailable
#endif
    );

NET_API_STATUS NET_API_FUNCTION
NetConfigGetAll (
    IN  LPTSTR  server OPTIONAL,
    IN  LPTSTR  component,
#ifdef REVISED_CONFIG_APIS
    OUT LPBYTE  *bufptr
#else
    OUT LPBYTE  *bufptr,
    OUT LPDWORD totalavailable
#endif
    );


NET_API_STATUS NET_API_FUNCTION
NetConfigSet (
    IN  LPTSTR  server OPTIONAL,
    IN  LPTSTR  reserved1 OPTIONAL,
    IN  LPTSTR  component,
    IN  DWORD   level,
    IN  DWORD   reserved2,
    IN  LPBYTE  buf,
    IN  DWORD   reserved3
    );

//
// Data Structures - Config
//

typedef struct _CONFIG_INFO_0 {
     LPTSTR         cfgi0_key;
     LPTSTR         cfgi0_data;
} CONFIG_INFO_0, *PCONFIG_INFO_0, *LPCONFIG_INFO_0;


#ifdef __cplusplus
}
#endif

#endif  // _LMCONFIG_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\tools\c932\inc\lmcons.h ===
/*++ BUILD Version: 0003    // Increment this if a change has global effects

Copyright (c) 1990-1993  Microsoft Corporation

Module Name:

    LMCONS.H (was NETCONS.H in LM 2.x)

Abstract:

    This file contains constants used throughout the LAN Manager
    API header files.  It should be included in any source file
    that is going to include other LAN Manager API header files or
    call a LAN Manager API.

    NOTE:  Lengths of strings are given as the maximum lengths of the
    string in characters (not bytes).  This does not include space for the
    terminating 0-characters.  When allocating space for such an item,
    use the form:

        TCHAR username[UNLEN+1];

    Definitions of the form LN20_* define those values in effect for
    LanMan 2.0.


Author:

    unknown

Revision History:

    25-Jan-1991     Danl
        Added NET_API_STATUS and NET_API_FUNCTION
    04-Feb-1991     JohnRo
        Avoid conflicts with <windef.h> (defines IN, OUT, but not OPTIONAL).
    26-Feb-1991     JohnRo
        Added PARM_ERROR_UNKNOWN and PARM_ERROR_NONE.
    09-May-1991     JohnRo
        Make PARM_ERROR_UNKNOWN a legal DWORD.  Got rid of tabs, to keep ChuckL
        happy.  Change NULL to ((void *)0) for portability.  Make sure all
        includes and defines start in column 1, to avoid MIPS problems.
        Changed to use slash-slash comments.
    20-May-1991     CliffV
        Removed several unused definitions.  Changed limits to be windows
        and NT compatible.  Added LM20_* definitions.
    18-Jul-1991 RFirth
        Added PARMNUM_BASE_INFOLEVEL
    30-Jul-1991 DanHi
        Changed definitions of *_FILENAME to NT values and deleted *_FILE
    04-Apr-1992 JohnRo
        Added MAX_PREFERRED_LENGTH.

--*/

/*NOINC*/
#ifndef NETCONS_INCLUDED

#define NETCONS_INCLUDED
/*INC*/

#ifndef PASCAL
#define PASCAL                          // pascal on OS/2
#endif

#ifndef FAR
#define FAR                             // far on OS/2
#endif

//
// String Lengths for various LanMan names
//

#define CNLEN       15                  // Computer name length
#define LM20_CNLEN  15                  // LM 2.0 Computer name length
#define DNLEN       CNLEN               // Maximum domain name length
#define LM20_DNLEN  LM20_CNLEN          // LM 2.0 Maximum domain name length

#if (CNLEN != DNLEN)
#error CNLEN and DNLEN are not equal
#endif

#define UNCLEN      (CNLEN+2)           // UNC computer name length
#define LM20_UNCLEN (LM20_CNLEN+2)      // LM 2.0 UNC computer name length

#define NNLEN       80                  // Net name length (share name)
#define LM20_NNLEN  12                  // LM 2.0 Net name length

#define RMLEN       (UNCLEN+1+NNLEN)    // Max remote name length
#define LM20_RMLEN  (LM20_UNCLEN+1+LM20_NNLEN) // LM 2.0 Max remote name length

#define SNLEN       80                  // Service name length
#define LM20_SNLEN  15                  // LM 2.0 Service name length
#define STXTLEN     256                 // Service text length
#define LM20_STXTLEN 63                 // LM 2.0 Service text length

#define PATHLEN     256                 // Max. path (not including drive name)
#define LM20_PATHLEN 256                // LM 2.0 Max. path

#define DEVLEN      80                  // Device name length
#define LM20_DEVLEN 8                   // LM 2.0 Device name length

#define EVLEN       16                  // Event name length

//
// User, Group and Password lengths
//

#define UNLEN       256                 // Maximum user name length
#define LM20_UNLEN  20                  // LM 2.0 Maximum user name length

#define GNLEN       UNLEN               // Group name
#define LM20_GNLEN  LM20_UNLEN          // LM 2.0 Group name

#define PWLEN       256                 // Maximum password length
#define LM20_PWLEN  14                  // LM 2.0 Maximum password length

#define SHPWLEN     8                   // Share password length (bytes)


#define CLTYPE_LEN  12                  // Length of client type string


#define MAXCOMMENTSZ 256                // Multipurpose comment length
#define LM20_MAXCOMMENTSZ 48            // LM 2.0 Multipurpose comment length

#define QNLEN       NNLEN               // Queue name maximum length
#define LM20_QNLEN  LM20_NNLEN          // LM 2.0 Queue name maximum length
#if (QNLEN != NNLEN)
# error QNLEN and NNLEN are not equal
#endif

//
// The ALERTSZ and MAXDEVENTRIES defines have not yet been NT'ized.
// Whoever ports these components should change these values appropriately.
//

#define ALERTSZ     128                 // size of alert string in server
#define MAXDEVENTRIES (sizeof (int)*8)  // Max number of device entries

                                        //
                                        // We use int bitmap to represent
                                        //

#define NETBIOS_NAME_LEN  16            // NetBIOS net name (bytes)

//
// Value to be used with APIs which have a "preferred maximum length"
// parameter.  This value indicates that the API should just allocate
// "as much as it takes."
//

#define MAX_PREFERRED_LENGTH    ((DWORD) -1)

//
//        Constants used with encryption
//

#define CRYPT_KEY_LEN           7
#define CRYPT_TXT_LEN           8
#define ENCRYPTED_PWLEN         16
#define SESSION_PWLEN           24
#define SESSION_CRYPT_KLEN      21

//
//  Value to be used with SetInfo calls to allow setting of all
//  settable parameters (parmnum zero option)
//
#ifndef PARMNUM_ALL
#define PARMNUM_ALL             0
#endif

#define PARM_ERROR_UNKNOWN      ( (DWORD) (-1) )
#define PARM_ERROR_NONE         0
#define PARMNUM_BASE_INFOLEVEL  1000

//
//        Message File Names
//

#define MESSAGE_FILENAME        TEXT("NETMSG")
#define OS2MSG_FILENAME         TEXT("BASE")
#define HELP_MSG_FILENAME       TEXT("NETH")

/**INTERNAL_ONLY**/

// The backup message file named here is a duplicate of net.msg. It
// is not shipped with the product, but is used at buildtime to
// msgbind certain messages to netapi.dll and some of the services.
// This allows for OEMs to modify the message text in net.msg and
// have those changes show up.        Only in case there is an error in
// retrieving the messages from net.msg do we then get the bound
// messages out of bak.msg (really out of the message segment).

#define BACKUP_MSG_FILENAME     TEXT("BAK.MSG")

/**END_INTERNAL**/

#ifndef NULL
#ifdef __cplusplus
#define NULL	0
#else
#define NULL	((void *)0)
#endif
#endif

//
// Keywords used in Function Prototypes
//

#define NET_API_STATUS          DWORD
#define API_RET_TYPE            NET_API_STATUS      // Old value: do not use
#if (_MSC_VER >= 800)
#define NET_API_FUNCTION    __stdcall
#else
#define NET_API_FUNCTION
#endif

// Define pseudo-keywords.
#ifndef IN
#define IN
#endif

#ifndef OPTIONAL
#define OPTIONAL
#endif

#ifndef OUT
#define OUT
#endif
/*INC*/



//
// The platform ID indicates the levels to use for platform-specific
// information.
//

#define PLATFORM_ID_DOS 300
#define PLATFORM_ID_OS2 400
#define PLATFORM_ID_NT  500
#define PLATFORM_ID_OSF 600
#define PLATFORM_ID_VMS 700

//
//      There message numbers assigned to different LANMAN components
//      are as defined below.
//
//      lmerr.h:        2100 - 2999     NERR_BASE
//      alertmsg.h:     3000 - 3049     ALERT_BASE
//      lmsvc.h:        3050 - 3099     SERVICE_BASE
//      lmerrlog.h:     3100 - 3299     ERRLOG_BASE
//      msgtext.h:      3300 - 3499     MTXT_BASE
//      apperr.h:       3500 - 3999     APPERR_BASE
//      apperrfs.h:     4000 - 4299     APPERRFS_BASE
//      apperr2.h:      4300 - 5299     APPERR2_BASE
//      ncberr.h:       5300 - 5499     NRCERR_BASE
//      alertmsg.h:     5500 - 5599     ALERT2_BASE
//      lmsvc.h:        5600 - 5699     SERVICE2_BASE
//      lmerrlog.h      5700 - 5799     ERRLOG2_BASE
//

#define MIN_LANMAN_MESSAGE_ID  NERR_BASE
#define MAX_LANMAN_MESSAGE_ID  5799

/*NOINC*/
#endif // NETCONS_INCLUDED
/*INC*/

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\tools\c932\inc\lmerr.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects
*/
/********************************************************************/
/**                     Microsoft LAN Manager                      **/
/**               Copyright(c) Microsoft Corp., 1987-1993          **/
/********************************************************************/

/***    lmerr.h - network error definitions
 *
 */


/**INTERNAL_ONLY**/

/***********WARNING ****************
 *See the comment in lmcons.h for  *
 *info on the allocation of errors *
 ***********************************/

/**END_INTERNAL**/

/*NOINC*/
#ifndef NETERR_INCLUDED

#define NETERR_INCLUDED
/*INC*/


#define NERR_Success            0       /* Success */

// ERROR_ equates can be intermixed with NERR_ equates.
#include <winerror.h>



/***    NERR_BASE is the base of error codes from network utilities,
 *      chosen to avoid conflict with system and redirector error codes.
 *      2100 is a value that has been assigned to us by system.
 */
#define NERR_BASE       2100


/**INTERNAL_ONLY**/

/***********WARNING ****************
 *See the comment in lmcons.h for  *
 *info on the allocation of errors *
 ***********************************/

/***********WARNING ****************
 *The range 2750-2799 has been     *
 *allocated to the IBM LAN Server  *
 ***********************************/

/***********WARNING ****************
 *The range 2900-2999 has been     *
 *reserved for Microsoft OEMs      *
 ***********************************/

/**END_INTERNAL**/

/* UNUSED BASE+0 */
/* UNUSED BASE+1 */
#define NERR_NetNotStarted      (NERR_BASE+2)   /* The workstation driver is not installed. */
#define NERR_UnknownServer      (NERR_BASE+3)   /* The server could not be located. */
#define NERR_ShareMem           (NERR_BASE+4)   /* An internal error occurred.  The network cannot access a shared memory segment. */

#define NERR_NoNetworkResource  (NERR_BASE+5)   /* A network resource shortage occurred . */
#define NERR_RemoteOnly         (NERR_BASE+6)   /* This operation is not supported on workstations. */
#define NERR_DevNotRedirected   (NERR_BASE+7)   /* The device is not connected. */
/* UNUSED BASE+8 */
/* UNUSED BASE+9 */
/* UNUSED BASE+10 */
/* UNUSED BASE+11 */
/* UNUSED BASE+12 */
/* UNUSED BASE+13 */
#define NERR_ServerNotStarted   (NERR_BASE+14)  /* The Server service is not started. */
#define NERR_ItemNotFound       (NERR_BASE+15)  /* The queue is empty. */
#define NERR_UnknownDevDir      (NERR_BASE+16)  /* The device or directory does not exist. */
#define NERR_RedirectedPath     (NERR_BASE+17)  /* The operation is invalid on a redirected resource. */
#define NERR_DuplicateShare     (NERR_BASE+18)  /* The name has already been shared. */
#define NERR_NoRoom             (NERR_BASE+19)  /* The server is currently out of the requested resource. */
/* UNUSED BASE+20 */
#define NERR_TooManyItems       (NERR_BASE+21)  /* Requested addition of items exceeds the maximum allowed. */
#define NERR_InvalidMaxUsers    (NERR_BASE+22)  /* The Peer service supports only two simultaneous users. */
#define NERR_BufTooSmall        (NERR_BASE+23)  /* The API return buffer is too small. */
/* UNUSED BASE+24 */
/* UNUSED BASE+25 */
/* UNUSED BASE+26 */
#define NERR_RemoteErr          (NERR_BASE+27)  /* A remote API error occurred.  */
/* UNUSED BASE+28 */
/* UNUSED BASE+29 */
/* UNUSED BASE+30 */
#define NERR_LanmanIniError     (NERR_BASE+31)  /* An error occurred when opening or reading the configuration file. */
/* UNUSED BASE+32 */
/* UNUSED BASE+33 */
/* UNUSED BASE+34 */
/* UNUSED BASE+35 */
#define NERR_NetworkError       (NERR_BASE+36)  /* A general network error occurred. */
#define NERR_WkstaInconsistentState (NERR_BASE+37)
    /* The Workstation service is in an inconsistent state. Restart the computer before restarting the Workstation service. */
#define NERR_WkstaNotStarted    (NERR_BASE+38)  /* The Workstation service has not been started. */
#define NERR_BrowserNotStarted  (NERR_BASE+39)  /* The requested information is not available. */
#define NERR_InternalError      (NERR_BASE+40)  /* An internal Windows NT error occurred.*/
#define NERR_BadTransactConfig  (NERR_BASE+41)  /* The server is not configured for transactions. */
#define NERR_InvalidAPI         (NERR_BASE+42)  /* The requested API is not supported on the remote server. */
#define NERR_BadEventName       (NERR_BASE+43)  /* The event name is invalid. */
#define NERR_DupNameReboot      (NERR_BASE+44)  /* The computer name already exists on the network. Change it and restart the computer. */
/*
 *      Config API related
 *              Error codes from BASE+45 to BASE+49
 */

/* UNUSED BASE+45 */
#define NERR_CfgCompNotFound    (NERR_BASE+46)  /* The specified component could not be found in the configuration information. */
#define NERR_CfgParamNotFound   (NERR_BASE+47)  /* The specified parameter could not be found in the configuration information. */
#define NERR_LineTooLong        (NERR_BASE+49)  /* A line in the configuration file is too long. */

/*
 *      Spooler API related
 *              Error codes from BASE+50 to BASE+79
 */

#define NERR_QNotFound          (NERR_BASE+50)  /* The printer does not exist. */
#define NERR_JobNotFound        (NERR_BASE+51)  /* The print job does not exist. */
#define NERR_DestNotFound       (NERR_BASE+52)  /* The printer destination cannot be found. */
#define NERR_DestExists         (NERR_BASE+53)  /* The printer destination already exists. */
#define NERR_QExists            (NERR_BASE+54)  /* The printer queue already exists. */
#define NERR_QNoRoom            (NERR_BASE+55)  /* No more printers can be added. */
#define NERR_JobNoRoom          (NERR_BASE+56)  /* No more print jobs can be added.  */
#define NERR_DestNoRoom         (NERR_BASE+57)  /* No more printer destinations can be added. */
#define NERR_DestIdle           (NERR_BASE+58)  /* This printer destination is idle and cannot accept control operations. */
#define NERR_DestInvalidOp      (NERR_BASE+59)  /* This printer destination request contains an invalid control function. */
#define NERR_ProcNoRespond      (NERR_BASE+60)  /* The print processor is not responding. */
#define NERR_SpoolerNotLoaded   (NERR_BASE+61)  /* The spooler is not running. */
#define NERR_DestInvalidState   (NERR_BASE+62)  /* This operation cannot be performed on the print destination in its current state. */
#define NERR_QInvalidState      (NERR_BASE+63)  /* This operation cannot be performed on the printer queue in its current state. */
#define NERR_JobInvalidState    (NERR_BASE+64)  /* This operation cannot be performed on the print job in its current state. */
#define NERR_SpoolNoMemory      (NERR_BASE+65)  /* A spooler memory allocation failure occurred. */
#define NERR_DriverNotFound     (NERR_BASE+66)  /* The device driver does not exist. */
#define NERR_DataTypeInvalid    (NERR_BASE+67)  /* The data type is not supported by the print processor. */
#define NERR_ProcNotFound       (NERR_BASE+68)  /* The print processor is not installed. */

/*
 *      Service API related
 *              Error codes from BASE+80 to BASE+99
 */

#define NERR_ServiceTableLocked (NERR_BASE+80)  /* The service does not respond to control actions. */
#define NERR_ServiceTableFull   (NERR_BASE+81)  /* The service table is full. */
#define NERR_ServiceInstalled   (NERR_BASE+82)  /* The requested service has already been started. */
#define NERR_ServiceEntryLocked (NERR_BASE+83)  /* The service does not respond to control actions. */
#define NERR_ServiceNotInstalled (NERR_BASE+84) /* The service has not been started. */
#define NERR_BadServiceName     (NERR_BASE+85)  /* The service name is invalid. */
#define NERR_ServiceCtlTimeout  (NERR_BASE+86)  /* The service is not responding to the control function. */
#define NERR_ServiceCtlBusy     (NERR_BASE+87)  /* The service control is busy. */
#define NERR_BadServiceProgName (NERR_BASE+88)  /* The configuration file contains an invalid service program name. */
#define NERR_ServiceNotCtrl     (NERR_BASE+89)  /* The service could not be controlled in its present state. */
#define NERR_ServiceKillProc    (NERR_BASE+90)  /* The service ended abnormally. */
#define NERR_ServiceCtlNotValid (NERR_BASE+91)  /* The requested pause or stop is not valid for this service. */
#define NERR_NotInDispatchTbl   (NERR_BASE+92)  /* The service control dispatcher could not find the service name in the dispatch table. */
#define NERR_BadControlRecv     (NERR_BASE+93)  /* The service control dispatcher pipe read failed. */
#define NERR_ServiceNotStarting (NERR_BASE+94)  /* A thread for the new service could not be created. */

/*
 *      Wksta and Logon API related
 *              Error codes from BASE+100 to BASE+118
 */

#define NERR_AlreadyLoggedOn    (NERR_BASE+100) /* This workstation is already logged on to the local-area network. */
#define NERR_NotLoggedOn        (NERR_BASE+101) /* The workstation is not logged on to the local-area network. */
#define NERR_BadUsername        (NERR_BASE+102) /* The user name or group name parameter is invalid.  */
#define NERR_BadPassword        (NERR_BASE+103) /* The password parameter is invalid. */
#define NERR_UnableToAddName_W  (NERR_BASE+104) /* @W The logon processor did not add the message alias. */
#define NERR_UnableToAddName_F  (NERR_BASE+105) /* The logon processor did not add the message alias. */
#define NERR_UnableToDelName_W  (NERR_BASE+106) /* @W The logoff processor did not delete the message alias. */
#define NERR_UnableToDelName_F  (NERR_BASE+107) /* The logoff processor did not delete the message alias. */
/* UNUSED BASE+108 */
#define NERR_LogonsPaused       (NERR_BASE+109) /* Network logons are paused. */
#define NERR_LogonServerConflict (NERR_BASE+110)/* A centralized logon-server conflict occurred. */
#define NERR_LogonNoUserPath    (NERR_BASE+111) /* The server is configured without a valid user path. */
#define NERR_LogonScriptError   (NERR_BASE+112) /* An error occurred while loading or running the logon script. */
/* UNUSED BASE+113 */
#define NERR_StandaloneLogon    (NERR_BASE+114) /* The logon server was not specified.  Your computer will be logged on as STANDALONE. */
#define NERR_LogonServerNotFound (NERR_BASE+115) /* The logon server could not be found.  */
#define NERR_LogonDomainExists  (NERR_BASE+116) /* There is already a logon domain for this computer.  */
#define NERR_NonValidatedLogon  (NERR_BASE+117) /* The logon server could not validate the logon. */

/*
 *      ACF API related (access, user, group)
 *              Error codes from BASE+119 to BASE+149
 */

#define NERR_ACFNotFound        (NERR_BASE+119) /* The security database could not be found. */
#define NERR_GroupNotFound      (NERR_BASE+120) /* The group name could not be found. */
#define NERR_UserNotFound       (NERR_BASE+121) /* The user name could not be found. */
#define NERR_ResourceNotFound   (NERR_BASE+122) /* The resource name could not be found.  */
#define NERR_GroupExists        (NERR_BASE+123) /* The group already exists. */
#define NERR_UserExists         (NERR_BASE+124) /* The user account already exists. */
#define NERR_ResourceExists     (NERR_BASE+125) /* The resource permission list already exists. */
#define NERR_NotPrimary         (NERR_BASE+126) /* This operation is only allowed on the domain controller of the domain. */
#define NERR_ACFNotLoaded       (NERR_BASE+127) /* The security database has not been started. */
#define NERR_ACFNoRoom          (NERR_BASE+128) /* There are too many names in the user accounts database. */
#define NERR_ACFFileIOFail      (NERR_BASE+129) /* A disk I/O failure occurred.*/
#define NERR_ACFTooManyLists    (NERR_BASE+130) /* The limit of 64 entries per resource was exceeded. */
#define NERR_UserLogon          (NERR_BASE+131) /* Deleting a user with a session is not allowed. */
#define NERR_ACFNoParent        (NERR_BASE+132) /* The parent directory could not be located. */
#define NERR_CanNotGrowSegment  (NERR_BASE+133) /* Unable to add to the security database session cache segment. */
#define NERR_SpeGroupOp         (NERR_BASE+134) /* This operation is not allowed on this special group. */
#define NERR_NotInCache         (NERR_BASE+135) /* This user is not cached in user accounts database session cache. */
#define NERR_UserInGroup        (NERR_BASE+136) /* The user already belongs to this group. */
#define NERR_UserNotInGroup     (NERR_BASE+137) /* The user does not belong to this group. */
#define NERR_AccountUndefined   (NERR_BASE+138) /* This user account is undefined. */
#define NERR_AccountExpired     (NERR_BASE+139) /* This user account has expired. */
#define NERR_InvalidWorkstation (NERR_BASE+140) /* The user is not allowed to log on from this workstation. */
#define NERR_InvalidLogonHours  (NERR_BASE+141) /* The user is not allowed to log on at this time.  */
#define NERR_PasswordExpired    (NERR_BASE+142) /* The password of this user has expired. */
#define NERR_PasswordCantChange (NERR_BASE+143) /* The password of this user cannot change. */
#define NERR_PasswordHistConflict (NERR_BASE+144) /* This password cannot be used now. */
#define NERR_PasswordTooShort   (NERR_BASE+145) /* The password is shorter than required. */
#define NERR_PasswordTooRecent  (NERR_BASE+146) /* The password of this user is too recent to change.  */
#define NERR_InvalidDatabase    (NERR_BASE+147) /* The security database is corrupted. */
#define NERR_DatabaseUpToDate   (NERR_BASE+148) /* No updates are necessary to this replicant network/local security database. */
#define NERR_SyncRequired       (NERR_BASE+149) /* This replicant database is outdated; synchronization is required. */

/*
 *      Use API related
 *              Error codes from BASE+150 to BASE+169
 */

#define NERR_UseNotFound        (NERR_BASE+150) /* The network connection could not be found. */
#define NERR_BadAsgType         (NERR_BASE+151) /* This asg_type is invalid. */
#define NERR_DeviceIsShared     (NERR_BASE+152) /* This device is currently being shared. */

/*
 *      Message Server related
 *              Error codes BASE+170 to BASE+209
 */

#define NERR_NoComputerName     (NERR_BASE+170) /* The computer name could not be added as a message alias.  The name may already exist on the network. */
#define NERR_MsgAlreadyStarted  (NERR_BASE+171) /* The Messenger service is already started. */
#define NERR_MsgInitFailed      (NERR_BASE+172) /* The Messenger service failed to start.  */
#define NERR_NameNotFound       (NERR_BASE+173) /* The message alias could not be found on the network. */
#define NERR_AlreadyForwarded   (NERR_BASE+174) /* This message alias has already been forwarded. */
#define NERR_AddForwarded       (NERR_BASE+175) /* This message alias has been added but is still forwarded. */
#define NERR_AlreadyExists      (NERR_BASE+176) /* This message alias already exists locally. */
#define NERR_TooManyNames       (NERR_BASE+177) /* The maximum number of added message aliases has been exceeded. */
#define NERR_DelComputerName    (NERR_BASE+178) /* The computer name could not be deleted.*/
#define NERR_LocalForward       (NERR_BASE+179) /* Messages cannot be forwarded back to the same workstation. */
#define NERR_GrpMsgProcessor    (NERR_BASE+180) /* An error occurred in the domain message processor. */
#define NERR_PausedRemote       (NERR_BASE+181) /* The message was sent, but the recipient has paused the Messenger service. */
#define NERR_BadReceive         (NERR_BASE+182) /* The message was sent but not received. */
#define NERR_NameInUse          (NERR_BASE+183) /* The message alias is currently in use. Try again later. */
#define NERR_MsgNotStarted      (NERR_BASE+184) /* The Messenger service has not been started. */
#define NERR_NotLocalName       (NERR_BASE+185) /* The name is not on the local computer. */
#define NERR_NoForwardName      (NERR_BASE+186) /* The forwarded message alias could not be found on the network. */
#define NERR_RemoteFull         (NERR_BASE+187) /* The message alias table on the remote station is full. */
#define NERR_NameNotForwarded   (NERR_BASE+188) /* Messages for this alias are not currently being forwarded. */
#define NERR_TruncatedBroadcast (NERR_BASE+189) /* The broadcast message was truncated. */
#define NERR_InvalidDevice      (NERR_BASE+194) /* This is an invalid device name. */
#define NERR_WriteFault         (NERR_BASE+195) /* A write fault occurred. */
/* UNUSED BASE+196 */
#define NERR_DuplicateName      (NERR_BASE+197) /* A duplicate message alias exists on the network. */
#define NERR_DeleteLater        (NERR_BASE+198) /* @W This message alias will be deleted later. */
#define NERR_IncompleteDel      (NERR_BASE+199) /* The message alias was not successfully deleted from all networks. */
#define NERR_MultipleNets       (NERR_BASE+200) /* This operation is not supported on computers with multiple networks. */

/*
 *      Server API related
 *              Error codes BASE+210 to BASE+229
 */

#define NERR_NetNameNotFound    (NERR_BASE+210) /* This shared resource does not exist.*/
#define NERR_DeviceNotShared    (NERR_BASE+211) /* This device is not shared. */
#define NERR_ClientNameNotFound (NERR_BASE+212) /* A session does not exist with that computer name. */
#define NERR_FileIdNotFound     (NERR_BASE+214) /* There is not an open file with that identification number. */
#define NERR_ExecFailure        (NERR_BASE+215) /* A failure occurred when executing a remote administration command. */
#define NERR_TmpFile            (NERR_BASE+216) /* A failure occurred when opening a remote temporary file. */
#define NERR_TooMuchData        (NERR_BASE+217) /* The data returned from a remote administration command has been truncated to 64K. */
#define NERR_DeviceShareConflict (NERR_BASE+218) /* This device cannot be shared as both a spooled and a non-spooled resource. */
#define NERR_BrowserTableIncomplete (NERR_BASE+219)  /* The information in the list of servers may be incorrect. */
#define NERR_NotLocalDomain     (NERR_BASE+220) /* The computer is not active in this domain. */

/*
 *      CharDev API related
 *              Error codes BASE+230 to BASE+249
 */

/* UNUSED BASE+230 */
#define NERR_DevInvalidOpCode   (NERR_BASE+231) /* The operation is invalid for this device. */
#define NERR_DevNotFound        (NERR_BASE+232) /* This device cannot be shared. */
#define NERR_DevNotOpen         (NERR_BASE+233) /* This device was not open. */
#define NERR_BadQueueDevString  (NERR_BASE+234) /* This device name list is invalid. */
#define NERR_BadQueuePriority   (NERR_BASE+235) /* The queue priority is invalid. */
#define NERR_NoCommDevs         (NERR_BASE+237) /* There are no shared communication devices. */
#define NERR_QueueNotFound      (NERR_BASE+238) /* The queue you specified does not exist. */
#define NERR_BadDevString       (NERR_BASE+240) /* This list of devices is invalid. */
#define NERR_BadDev             (NERR_BASE+241) /* The requested device is invalid. */
#define NERR_InUseBySpooler     (NERR_BASE+242) /* This device is already in use by the spooler. */
#define NERR_CommDevInUse       (NERR_BASE+243) /* This device is already in use as a communication device. */

/*
 *      NetICanonicalize and NetIType and NetIMakeLMFileName
 *      NetIListCanon and NetINameCheck
 *              Error codes BASE+250 to BASE+269
 */

#define NERR_InvalidComputer   (NERR_BASE+251) /* This computer name is invalid. */
/* UNUSED BASE+252 */
/* UNUSED BASE+253 */
#define NERR_MaxLenExceeded    (NERR_BASE+254) /* The string and prefix specified are too long. */
/* UNUSED BASE+255 */
#define NERR_BadComponent      (NERR_BASE+256) /* This path component is invalid. */
#define NERR_CantType          (NERR_BASE+257) /* Could not determine the type of input. */
/* UNUSED BASE+258 */
/* UNUSED BASE+259 */
#define NERR_TooManyEntries    (NERR_BASE+262) /* The buffer for types is not big enough. */

/*
 *      NetProfile
 *              Error codes BASE+270 to BASE+276
 */

#define NERR_ProfileFileTooBig  (NERR_BASE+270) /* Profile files cannot exceed 64K. */
#define NERR_ProfileOffset      (NERR_BASE+271) /* The start offset is out of range. */
#define NERR_ProfileCleanup     (NERR_BASE+272) /* The system cannot delete current connections to network resources. */
#define NERR_ProfileUnknownCmd  (NERR_BASE+273) /* The system was unable to parse the command line in this file.*/
#define NERR_ProfileLoadErr     (NERR_BASE+274) /* An error occurred while loading the profile file. */
#define NERR_ProfileSaveErr     (NERR_BASE+275) /* @W Errors occurred while saving the profile file.  The profile was partially saved. */


/*
 *      NetAudit and NetErrorLog
 *              Error codes BASE+277 to BASE+279
 */

#define NERR_LogOverflow           (NERR_BASE+277)      /* Log file %1 is full. */
#define NERR_LogFileChanged        (NERR_BASE+278)      /* This log file has changed between reads. */
#define NERR_LogFileCorrupt        (NERR_BASE+279)      /* Log file %1 is corrupt. */


/*
 *      NetRemote
 *              Error codes BASE+280 to BASE+299
 */
#define NERR_SourceIsDir   (NERR_BASE+280) /* The source path cannot be a directory. */
#define NERR_BadSource     (NERR_BASE+281) /* The source path is illegal. */
#define NERR_BadDest       (NERR_BASE+282) /* The destination path is illegal. */
#define NERR_DifferentServers   (NERR_BASE+283) /* The source and destination paths are on different servers. */
/* UNUSED BASE+284 */
#define NERR_RunSrvPaused       (NERR_BASE+285) /* The Run server you requested is paused. */
/* UNUSED BASE+286 */
/* UNUSED BASE+287 */
/* UNUSED BASE+288 */
#define NERR_ErrCommRunSrv      (NERR_BASE+289) /* An error occurred when communicating with a Run server. */
/* UNUSED BASE+290 */
#define NERR_ErrorExecingGhost  (NERR_BASE+291) /* An error occurred when starting a background process. */
#define NERR_ShareNotFound      (NERR_BASE+292) /* The shared resource you are connected to could not be found.*/
/* UNUSED BASE+293 */
/* UNUSED BASE+294 */


/*
 *  NetWksta.sys (redir) returned error codes.
 *
 *          NERR_BASE + (300-329)
 */

#define NERR_InvalidLana        (NERR_BASE+300) /* The LAN adapter number is invalid.  */
#define NERR_OpenFiles          (NERR_BASE+301) /* There are open files on the connection.    */
#define NERR_ActiveConns        (NERR_BASE+302) /* Active connections still exist. */
#define NERR_BadPasswordCore    (NERR_BASE+303) /* This share name or password is invalid. */
#define NERR_DevInUse           (NERR_BASE+304) /* The device is being accessed by an active process. */
#define NERR_LocalDrive         (NERR_BASE+305) /* The drive letter is in use locally. */

/*
 *  Alert error codes.
 *
 *          NERR_BASE + (330-339)
 */
#define NERR_AlertExists        (NERR_BASE+330) /* The specified client is already registered for the specified event. */
#define NERR_TooManyAlerts      (NERR_BASE+331) /* The alert table is full. */
#define NERR_NoSuchAlert        (NERR_BASE+332) /* An invalid or nonexistent alert name was raised. */
#define NERR_BadRecipient       (NERR_BASE+333) /* The alert recipient is invalid.*/
#define NERR_AcctLimitExceeded  (NERR_BASE+334) /* A user's session with this server has been deleted
                                                 * because the user's logon hours are no longer valid. */

/*
 *  Additional Error and Audit log codes.
 *
 *          NERR_BASE +(340-343)
 */
#define NERR_InvalidLogSeek     (NERR_BASE+340) /* The log file does not contain the requested record number. */
/* UNUSED BASE+341 */
/* UNUSED BASE+342 */
/* UNUSED BASE+343 */

/*
 *  Additional UAS and NETLOGON codes
 *
 *          NERR_BASE +(350-359)
 */
#define NERR_BadUasConfig       (NERR_BASE+350) /* The user accounts database is not configured correctly. */
#define NERR_InvalidUASOp       (NERR_BASE+351) /* This operation is not permitted when the Netlogon service is running. */
#define NERR_LastAdmin          (NERR_BASE+352) /* This operation is not allowed on the last administrative account. */
#define NERR_DCNotFound         (NERR_BASE+353) /* Could not find domain controller for this domain. */
#define NERR_LogonTrackingError (NERR_BASE+354) /* Could not set logon information for this user. */
#define NERR_NetlogonNotStarted (NERR_BASE+355) /* The Netlogon service has not been started. */
#define NERR_CanNotGrowUASFile  (NERR_BASE+356) /* Unable to add to the user accounts database. */
#define NERR_TimeDiffAtDC       (NERR_BASE+357) /* This server's clock is not synchronized with the domain controller's clock. */
#define NERR_PasswordMismatch   (NERR_BASE+358) /* A password mismatch has been detected. */


/*
 *  Server Integration error codes.
 *
 *          NERR_BASE +(360-369)
 */
#define NERR_NoSuchServer       (NERR_BASE+360) /* The server identification does not specify a valid server. */
#define NERR_NoSuchSession      (NERR_BASE+361) /* The session identification does not specify a valid session. */
#define NERR_NoSuchConnection   (NERR_BASE+362) /* The connection identification does not specify a valid connection. */
#define NERR_TooManyServers     (NERR_BASE+363) /* There is no space for another entry in the table of available servers. */
#define NERR_TooManySessions    (NERR_BASE+364) /* The server has reached the maximum number of sessions it supports. */
#define NERR_TooManyConnections (NERR_BASE+365) /* The server has reached the maximum number of connections it supports. */
#define NERR_TooManyFiles       (NERR_BASE+366) /* The server cannot open more files because it has reached its maximum number. */
#define NERR_NoAlternateServers (NERR_BASE+367) /* There are no alternate servers registered on this server. */
/* UNUSED BASE+368 */
/* UNUSED BASE+369 */

#define NERR_TryDownLevel       (NERR_BASE+370) /* Try down-level (remote admin protocol) version of API instead. */

/*
 *  UPS error codes.
 *
 *          NERR_BASE + (380-384)
 */
#define NERR_UPSDriverNotStarted    (NERR_BASE+380) /* The UPS driver could not be accessed by the UPS service. */
#define NERR_UPSInvalidConfig       (NERR_BASE+381) /* The UPS service is not configured correctly. */
#define NERR_UPSInvalidCommPort     (NERR_BASE+382) /* The UPS service could not access the specified Comm Port. */
#define NERR_UPSSignalAsserted      (NERR_BASE+383) /* The UPS indicated a line fail or low battery situation. Service not started. */
#define NERR_UPSShutdownFailed      (NERR_BASE+384) /* The UPS service failed to perform a system shut down. */

/*
 *  Remoteboot error codes.
 *
 *          NERR_BASE + (400-419)
 *          Error codes 400 - 405 are used by RPLBOOT.SYS.
 *          Error codes 403, 407 - 416 are used by RPLLOADR.COM,
 *          Error code 417 is the alerter message of REMOTEBOOT (RPLSERVR.EXE).
 *          Error code 418 is for when REMOTEBOOT can't start
 *          Error code 419 is for a disallowed 2nd rpl connection
 *
 *          (Currently not used in NT)
 */

/*
 *  FTADMIN API error codes
 *
 *       NERR_BASE + (425-434)
 *
 *       (Currently not used in NT)
 *
 */

/*
 *  Browser service API error codes
 *
 *       NERR_BASE + (450-475)
 *
 */
#define NERR_BrowserConfiguredToNotRun     (NERR_BASE+450) /* The browser service was configured with MaintainServerList=No. */

/**INTERNAL_ONLY**/

/***********WARNING ****************
 *The range 2750-2799 has been     *
 *allocated to the IBM LAN Server  *
 ***********************************/

/***********WARNING ****************
 *The range 2900-2999 has been     *
 *reserved for Microsoft OEMs      *
 ***********************************/

/**END_INTERNAL**/

#define MAX_NERR                (NERR_BASE+899) /* This is the last error in NERR range. */

/*
 * end of list
 *
 *    WARNING:  Do not exceed MAX_NERR; values above this are used by
 *              other error code ranges (errlog.h, service.h, apperr.h).
 */


/*NOINC*/
#endif /* NETERR_INCLUDED */
/*INC*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\tools\c932\inc\lmmsg.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1991-1993  Microsoft Corporation

Module Name:

    lmmsg.h

Abstract:

    This file contains structures, function prototypes, and definitions
    for the NetMessage API.

Author:

    Dan Lafferty (danl) 10-Mar-1991

[Environment:]

    User Mode - Win32

[Notes:]

    You must include NETCONS.H before this file, since this file depends
    on values defined in NETCONS.H.

Revision History:

    10-Mar-1991 danl
        Created from LM2.0 header files and NT-LAN API Spec.

--*/

#ifndef _LMMSG_
#define _LMMSG_

#ifdef __cplusplus
extern "C" {
#endif

//
// Function Prototypes
//

NET_API_STATUS NET_API_FUNCTION
NetMessageNameAdd (
    IN  LPTSTR  servername,
    IN  LPTSTR  msgname
    );

NET_API_STATUS NET_API_FUNCTION
NetMessageNameEnum (
    IN  LPTSTR      servername,
    IN  DWORD       level,
    OUT LPBYTE      *bufptr,
    IN  DWORD       prefmaxlen,
    OUT LPDWORD     entriesread,
    OUT LPDWORD     totalentries,
    IN OUT LPDWORD  resume_handle
    );

NET_API_STATUS NET_API_FUNCTION
NetMessageNameGetInfo (
    IN  LPTSTR  servername,
    IN  LPTSTR  msgname,
    IN  DWORD   level,
    OUT LPBYTE  *bufptr
    );

NET_API_STATUS NET_API_FUNCTION
NetMessageNameDel (
    IN  LPTSTR   servername,
    IN  LPTSTR   msgname
    );

NET_API_STATUS NET_API_FUNCTION
NetMessageBufferSend (
    IN  LPTSTR  servername,
    IN  LPTSTR  msgname,
    IN  LPTSTR  fromname,
    IN  LPBYTE  buf,
    IN  DWORD   buflen
    );

//
//  Data Structures
//

typedef struct _MSG_INFO_0 {
    LPTSTR  msgi0_name;
}MSG_INFO_0, *PMSG_INFO_0, *LPMSG_INFO_0;

typedef struct _MSG_INFO_1 {
    LPTSTR  msgi1_name;
    DWORD   msgi1_forward_flag;
    LPTSTR  msgi1_forward;
}MSG_INFO_1, *PMSG_INFO_1, *LPMSG_INFO_1;

//
// Special Values and Constants
//

//
// Values for msgi1_forward_flag.
//

#define MSGNAME_NOT_FORWARDED   0       // Name not forwarded
#define MSGNAME_FORWARDED_TO    0x04    // Name forward to remote station
#define MSGNAME_FORWARDED_FROM  0x10    // Name forwarded from remote station

#ifdef __cplusplus
}
#endif

#endif //_LMMSG_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\tools\c932\inc\lmerrlog.h ===
/*++ BUILD Version: 0002    // Increment this if a change has global effects

Copyright (c) 1991-1993  Microsoft Corporation

Module Name:

    lmerrlog.h

Abstract:

    This module defines the API function prototypes and data structures
    for the following groups of NT API functions:
        NetErrorLog

Author:

    Dan Lafferty (danl)  29-Mar-1991

Environment:

    User Mode - Win32

Notes:

    You must include NETCONS.H before this file, since this file depends
    on values defined in NETCONS.H.

Revision History:

    28-Mar-1991  Danl
        Ported from LM2.0 and the LMNETAPI spec.
    25-Apr-1991  DanHi
         Surrounded define for HLOG (used by both audit and error logs),
         by a protective ifdef since I added the define to lmaudit.h
    29-Jul-1991  DanHi
        Change comments after manifest constants for error messages to a format
        that is recognized by mapmsg.exe
    12-Nov-1991 JohnRo
        ERROR_LOG structure needs changes to prevent alignment/padding problems.
        Also change offset fields to pointers where possible.
        Clarify UNICODE (TCHAR) handling.

    28-Jul-1992 Madana
        Created another range of error log code ERRLOG2_BASE
        (5800 - 5899) and added several new error log codes for netlogon
        service.

--*/

#ifndef _LMERRLOG_
#define _LMERRLOG_

//
// Data Structures - Config
//

typedef struct _ERROR_LOG {
     DWORD          el_len;
     DWORD          el_reserved;
     DWORD          el_time;
     DWORD          el_error;
     LPTSTR         el_name;             // pointer to service name
     LPTSTR         el_text;             // pointer to string array
     LPBYTE         el_data;             // pointer to BYTE array
     DWORD          el_data_size;        // byte count of el_data area
     DWORD          el_nstrings;         // number of strings in el_text.
} ERROR_LOG, *PERROR_LOG, *LPERROR_LOG;


// BUGBUG: Temporary to let users ifdef on this struct layout.
#define REVISED_ERROR_LOG_STRUCT


#ifndef _LMHLOGDEFINED_
#define _LMHLOGDEFINED_

typedef struct _HLOG {
     DWORD          time;
     DWORD          last_flags;
     DWORD          offset;
     DWORD          rec_offset;
} HLOG, *PHLOG, *LPHLOG;

#define LOGFLAGS_FORWARD    0
#define LOGFLAGS_BACKWARD   0x1
#define LOGFLAGS_SEEK       0x2

#endif

//
// Function Prototypes - ErrorLog
//

NET_API_STATUS NET_API_FUNCTION
NetErrorLogClear (
    IN LPTSTR server,
    IN LPTSTR backupfile,
    IN LPBYTE reserved
    );

NET_API_STATUS NET_API_FUNCTION
NetErrorLogRead (
    IN LPTSTR server,
    IN LPTSTR reserved1,
    IN LPHLOG errloghandle,
    IN DWORD offset,
    IN LPDWORD reserved2,
    IN DWORD reserved3,
    IN DWORD offsetflag,
    OUT LPBYTE * bufptr,
    IN DWORD prefmaxlen,
    OUT LPDWORD bytesread,
    OUT LPDWORD totalbytes
    );

NET_API_STATUS NET_API_FUNCTION
NetErrorLogWrite (
    IN LPBYTE reserved1,
    IN DWORD code,
    IN LPTSTR component,
    IN LPBYTE buffer,
    IN DWORD numbytes,
    IN LPBYTE msgbuf,
    IN DWORD strcount,
    IN LPBYTE reserved2
    );

//
// Special Values and Constants
//


//
//  Generic (could be used by more than one service)
//   error log messages from 0 to 25
//
// Do not change the comments following the manifest constants without
// understanding how mapmsg works.
//

#define ERRLOG_BASE 3100        /* NELOG errors start here */

#define NELOG_Internal_Error        (ERRLOG_BASE + 0)
    /*
    * The operation failed because a network software error occurred.
    */

#define NELOG_Resource_Shortage     (ERRLOG_BASE + 1)
    /*
    * The system ran out of a resource controlled by the %1 option.
    */

#define NELOG_Unable_To_Lock_Segment    (ERRLOG_BASE + 2)
    /*
    * The service failed to obtain a long-term lock on the
    *  segment for network control blocks (NCBs). The error code is the data.
    */

#define NELOG_Unable_To_Unlock_Segment  (ERRLOG_BASE + 3)
    /*
    * The service failed to release the long-term lock on the
    *  segment for network control blocks (NCBs). The error code is the data.
    */

#define NELOG_Uninstall_Service     (ERRLOG_BASE + 4)
    /*
    * There was an error stopping service %1.
    *  The error code from NetServiceControl is the data.
    */

#define NELOG_Init_Exec_Fail        (ERRLOG_BASE + 5)
    /*
    * Initialization failed because of a system execution failure on
    *  path %1. The system error code is the data.
    */

#define NELOG_Ncb_Error         (ERRLOG_BASE + 6)
    /*
    * An unexpected network control block (NCB) was received. The NCB is the data.
    */

#define NELOG_Net_Not_Started       (ERRLOG_BASE + 7)
    /*
    * The network is not started.
    */

#define NELOG_Ioctl_Error       (ERRLOG_BASE + 8)
    /*
    * A DosDevIoctl or DosFsCtl to NETWKSTA.SYS failed.
    * The data shown is in this format:
    *     DWORD  approx CS:IP of call to ioctl or fsctl
    *     WORD   error code
    *     WORD   ioctl or fsctl number
    */

#define NELOG_System_Semaphore      (ERRLOG_BASE + 9)
    /*
    * Unable to create or open system semaphore %1.
    *  The error code is the data.
    */

#define NELOG_Init_OpenCreate_Err   (ERRLOG_BASE + 10)
    /*
    * Initialization failed because of an open/create error on the
    *  file %1. The system error code is the data.
    */

#define NELOG_NetBios           (ERRLOG_BASE + 11)
    /*
    * An unexpected NetBIOS error occurred.
    *  The error code is the data.
    */

#define NELOG_SMB_Illegal       (ERRLOG_BASE + 12)
    /*
    * An illegal server message block (SMB) was received.
    *  The SMB is the data.
    */

#define NELOG_Service_Fail      (ERRLOG_BASE + 13)
    /*
    * Initialization failed because the requested service %1
    *  could not be started.
   */

#define NELOG_Entries_Lost      (ERRLOG_BASE + 14)
    /*
    * Some entries in the error log were lost because of a buffer
    * overflow.
    */


//
//  Server specific error log messages from 20 to 40
//

#define NELOG_Init_Seg_Overflow     (ERRLOG_BASE + 20)
    /*
    * Initialization parameters controlling resource usage other
    *  than net buffers are sized so that too much memory is needed.
    */

#define NELOG_Srv_No_Mem_Grow       (ERRLOG_BASE + 21)
    /*
    * The server cannot increase the size of a memory segment.
    */

#define NELOG_Access_File_Bad       (ERRLOG_BASE + 22)
    /*
    * Initialization failed because account file %1 is either incorrect
    * or not present.
    */

#define NELOG_Srvnet_Not_Started    (ERRLOG_BASE + 23)
    /*
    * Initialization failed because network %1 was not started.
    */

#define NELOG_Init_Chardev_Err      (ERRLOG_BASE + 24)
    /*
    * The server failed to start. Either all three chdev
    *  parameters must be zero or all three must be nonzero.
    */

#define NELOG_Remote_API        (ERRLOG_BASE + 25)
    /* A remote API request was halted due to the following
    * invalid description string: %1.
    */

#define NELOG_Ncb_TooManyErr        (ERRLOG_BASE + 26)
    /* The network %1 ran out of network control blocks (NCBs).  You may need to increase NCBs
    * for this network.  The following information includes the
    * number of NCBs submitted by the server when this error occurred:
    */

#define NELOG_Mailslot_err      (ERRLOG_BASE + 27)
    /* The server cannot create the %1 mailslot needed to send
    * the ReleaseMemory alert message.  The error received is:
    */

#define NELOG_ReleaseMem_Alert      (ERRLOG_BASE + 28)
    /* The server failed to register for the ReleaseMemory alert,
    * with recipient %1. The error code from
    * NetAlertStart is the data.
    */

#define NELOG_AT_cannot_write       (ERRLOG_BASE + 29)
    /* The server cannot update the AT schedule file. The file
    * is corrupted.
    */

#define NELOG_Cant_Make_Msg_File    (ERRLOG_BASE + 30)
    /* The server encountered an error when calling
    * NetIMakeLMFileName. The error code is the data.
    */

#define NELOG_Exec_Netservr_NoMem   (ERRLOG_BASE + 31)
    /* Initialization failed because of a system execution failure on
    * path %1. There is not enough memory to start the process.
    * The system error code is the data.
    */

#define NELOG_Server_Lock_Failure   (ERRLOG_BASE + 32)
    /* Longterm lock of the server buffers failed.
    * Check swap disk's free space and restart the system to start the server.
    */

//
//  Message service and POPUP specific error log messages from 40 to 55
//

#define NELOG_Msg_Shutdown      (ERRLOG_BASE + 40)
    /*
    * The service has stopped due to repeated consecutive
    *  occurrences of a network control block (NCB) error.  The last bad NCB follows
    *  in raw data.
    */

#define NELOG_Msg_Sem_Shutdown      (ERRLOG_BASE + 41)
    /*
    * The Message server has stopped due to a lock on the
    *  Message server shared data segment.
    */

#define NELOG_Msg_Log_Err       (ERRLOG_BASE + 50)
    /*
    * A file system error occurred while opening or writing to the
    *  system message log file %1. Message logging has been
    *  switched off due to the error. The error code is the data.
    */



#define NELOG_VIO_POPUP_ERR     (ERRLOG_BASE + 51)
    /*
    * Unable to display message POPUP due to system VIO call error.
    *  The error code is the data.
    */

#define NELOG_Msg_Unexpected_SMB_Type   (ERRLOG_BASE + 52)
    /*
    * An illegal server message block (SMB) was received.  The SMB is the data.
    */

//
//  Workstation specific error log messages from 60 to 75
//


#define NELOG_Wksta_Infoseg     (ERRLOG_BASE + 60)
    /*
    * The workstation information segment is bigger than 64K.
    *  The size follows, in DWORD format:
    */

#define NELOG_Wksta_Compname        (ERRLOG_BASE + 61)
    /*
    * The workstation was unable to get the name-number of the computer.
    */

#define NELOG_Wksta_BiosThreadFailure   (ERRLOG_BASE + 62)
    /*
    * The workstation could not initialize the Async NetBIOS Thread.
    *  The error code is the data.
    */

#define NELOG_Wksta_IniSeg      (ERRLOG_BASE + 63)
    /*
    * The workstation could not open the initial shared segment.
    *  The error code is the data.
    */

#define NELOG_Wksta_HostTab_Full    (ERRLOG_BASE + 64)
    /*
    * The workstation host table is full.
    */

#define NELOG_Wksta_Bad_Mailslot_SMB    (ERRLOG_BASE + 65)
    /*
    * A bad mailslot server message block (SMB) was received.  The SMB is the data.
    */

#define NELOG_Wksta_UASInit     (ERRLOG_BASE + 66)
    /*
    * The workstation encountered an error while trying to start the user accounts database.
    *  The error code is the data.
    */

#define NELOG_Wksta_SSIRelogon      (ERRLOG_BASE + 67)
    /*
    * The workstation encountered an error while responding to an SSI revalidation request.
    *  The function code and the error codes are the data.
    */

//
//  Alerter service specific error log messages from 70 to 79
//


#define NELOG_Build_Name        (ERRLOG_BASE + 70)
    /*
    * The Alerter service had a problem creating the list of
    * alert recipients.  The error code is %1.
    */

#define NELOG_Name_Expansion        (ERRLOG_BASE + 71)
    /*
    * There was an error expanding %1 as a group name. Try
    *  splitting the group into two or more smaller groups.
    */

#define NELOG_Message_Send      (ERRLOG_BASE + 72)
    /*
    * There was an error sending %2 the alert message -
    *  (
    *  %3 )
    *  The error code is %1.
    */

#define NELOG_Mail_Slt_Err      (ERRLOG_BASE + 73)
    /*
    * There was an error in creating or reading the alerter mailslot.
    *  The error code is %1.
    */

#define NELOG_AT_cannot_read        (ERRLOG_BASE + 74)
    /*
    * The server could not read the AT schedule file.
    */

#define NELOG_AT_sched_err      (ERRLOG_BASE + 75)
    /*
    * The server found an invalid AT schedule record.
    */

#define NELOG_AT_schedule_file_created  (ERRLOG_BASE + 76)
    /*
    * The server could not find an AT schedule file so it created one.
    */

#define NELOG_Srvnet_NB_Open        (ERRLOG_BASE + 77)
    /*
    * The server could not access the %1 network with NetBiosOpen.
    */

#define NELOG_AT_Exec_Err       (ERRLOG_BASE + 78)
    /*
    * The AT command processor could not run %1.
   */

//
//      Cache Lazy Write and HPFS386 specific error log messages from 80 to 89
//

#define NELOG_Lazy_Write_Err            (ERRLOG_BASE + 80)
        /*
        * WARNING:  Because of a lazy-write error, drive %1 now
        *  contains some corrupted data.  The cache is stopped.
        */

#define NELOG_HotFix            (ERRLOG_BASE + 81)
    /*
    * A defective sector on drive %1 has been replaced (hotfixed).
    * No data was lost.  You should run CHKDSK soon to restore full
    * performance and replenish the volume's spare sector pool.
    *
    * The hotfix occurred while processing a remote request.
    */

#define NELOG_HardErr_From_Server   (ERRLOG_BASE + 82)
    /*
    * A disk error occurred on the HPFS volume in drive %1.
    * The error occurred while processing a remote request.
    */

#define NELOG_LocalSecFail1 (ERRLOG_BASE + 83)
    /*
    * The user accounts database (NET.ACC) is corrupted.  The local security
    * system is replacing the corrupted NET.ACC with the backup
    * made at %1.
    * Any updates made to the database after this time are lost.
    *
    */

#define NELOG_LocalSecFail2 (ERRLOG_BASE + 84)
    /*
    * The user accounts database (NET.ACC) is missing.  The local
    * security system is restoring the backup database
    * made at %1.
    * Any updates made to the database made after this time are lost.
    *
    */

#define NELOG_LocalSecFail3 (ERRLOG_BASE + 85)
    /*
    * Local security could not be started because the user accounts database
    * (NET.ACC) was missing or corrupted, and no usable backup
    * database was present.
    *
    * THE SYSTEM IS NOT SECURE.
    */

#define NELOG_LocalSecGeneralFail   (ERRLOG_BASE + 86)
    /*
    * Local security could not be started because an error
    * occurred during initialization. The error code returned is %1.
    *
    * THE SYSTEM IS NOT SECURE.
    *
    */

//
//  NETWKSTA.SYS specific error log messages from 90 to 99
//

#define NELOG_NetWkSta_Internal_Error   (ERRLOG_BASE + 90)
    /*
    * A NetWksta internal error has occurred:
    *  %1
    */

#define NELOG_NetWkSta_No_Resource  (ERRLOG_BASE + 91)
    /*
    * The redirector is out of a resource: %1.
    */

#define NELOG_NetWkSta_SMB_Err      (ERRLOG_BASE + 92)
    /*
    * A server message block (SMB) error occurred on the connection to %1.
    *  The SMB header is the data.
    */

#define NELOG_NetWkSta_VC_Err       (ERRLOG_BASE + 93)
    /*
    * A virtual circuit error occurred on the session to %1.
    *  The network control block (NCB) command and return code is the data.
    */

#define NELOG_NetWkSta_Stuck_VC_Err (ERRLOG_BASE + 94)
    /*
    * Hanging up a stuck session to %1.
    */

#define NELOG_NetWkSta_NCB_Err      (ERRLOG_BASE + 95)
    /*
    * A network control block (NCB) error occurred (%1).
    *  The NCB is the data.
    */

#define NELOG_NetWkSta_Write_Behind_Err (ERRLOG_BASE + 96)
    /*
    * A write operation to %1 failed.
    *  Data may have been lost.
    */

#define NELOG_NetWkSta_Reset_Err    (ERRLOG_BASE + 97)
    /*
    * Reset of driver %1 failed to complete the network control block (NCB).
    *  The NCB is the data.
    */

#define NELOG_NetWkSta_Too_Many     (ERRLOG_BASE + 98)
    /*
    * The amount of resource %1 requested was more
    *  than the maximum. The maximum amount was allocated.
    */

//
//  Spooler specific error log messages from 100 to 103
//

#define NELOG_Srv_Thread_Failure        (ERRLOG_BASE + 104)
    /*
    * The server could not create a thread.
    *  The THREADS parameter in the CONFIG.SYS file should be increased.
    */

#define NELOG_Srv_Close_Failure         (ERRLOG_BASE + 105)
    /*
    * The server could not close %1.
    *  The file is probably corrupted.
    */

#define NELOG_ReplUserCurDir               (ERRLOG_BASE + 106)
    /*
    *The replicator cannot update directory %1. It has tree integrity
    * and is the current directory for some process.
    */

#define NELOG_ReplCannotMasterDir       (ERRLOG_BASE + 107)
    /*
    *The server cannot export directory %1 to client %2.
    * It is exported from another server.
    */

#define NELOG_ReplUpdateError           (ERRLOG_BASE + 108)
    /*
    *The replication server could not update directory %2 from the source
    * on %3 due to error %1.
    */

#define NELOG_ReplLostMaster            (ERRLOG_BASE + 109)
    /*
    *Master %1 did not send an update notice for directory %2 at the expected
    * time.
    */

#define NELOG_NetlogonAuthDCFail        (ERRLOG_BASE + 110)
    /*
    *Failed to authenticate with %2, a Windows NT Advanced Server for domain %1.
    */

#define NELOG_ReplLogonFailed           (ERRLOG_BASE + 111)
    /*
    *The replicator attempted to log on at %2 as %1 and failed.
    */

#define NELOG_ReplNetErr            (ERRLOG_BASE + 112)
    /*
    *  Network error %1 occurred.
    */

#define NELOG_ReplMaxFiles            (ERRLOG_BASE + 113)
    /*
    *  Replicator limit for files in a directory has been exceeded.
    */


#define NELOG_ReplMaxTreeDepth            (ERRLOG_BASE + 114)
    /*
    *  Replicator limit for tree depth has been exceeded.
    */

#define NELOG_ReplBadMsg             (ERRLOG_BASE + 115)
    /*
    *  Unrecognized message received in mailslot.
    */

#define NELOG_ReplSysErr            (ERRLOG_BASE + 116)
    /*
    *  System error %1 occurred.
    */

#define NELOG_ReplUserLoged          (ERRLOG_BASE + 117)
    /*
    *  Cannot log on. User is currently logged on and argument TRYUSER
    *  is set to NO.
    */

#define NELOG_ReplBadImport           (ERRLOG_BASE + 118)
    /*
    *  IMPORT path %1 cannot be found.
    */

#define NELOG_ReplBadExport           (ERRLOG_BASE + 119)
    /*
    *  EXPORT path %1 cannot be found.
    */

#define NELOG_ReplSignalFileErr           (ERRLOG_BASE + 120)
    /*
    *  Replicator failed to update signal file in directory %2 due to
    *  %1 system error.
    */

#define NELOG_DiskFT                (ERRLOG_BASE+121)
    /*
    * Disk Fault Tolerance Error
    *
    * %1
    */

#define NELOG_ReplAccessDenied           (ERRLOG_BASE + 122)
    /*
    *  Replicator could not access %2
    *  on %3 due to system error %1.
    */

#define NELOG_NetlogonFailedPrimary      (ERRLOG_BASE + 123)
    /*
    *The domain controller for domain %1 has apparently failed.
    */

#define NELOG_NetlogonPasswdSetFailed (ERRLOG_BASE + 124)
    /*
    * Changing machine account password for account %1 failed with
    * the following error: %n%2
    */

#define NELOG_NetlogonTrackingError      (ERRLOG_BASE + 125)
    /*
    *An error occurred while updating the logon or logoff information for %1.
    */

#define NELOG_NetlogonSyncError          (ERRLOG_BASE + 126)
    /*
    *An error occurred while synchronizing with domain controller %1
    */

//
//  UPS service specific error log messages from 130 to 135
//

#define NELOG_UPS_PowerOut      (ERRLOG_BASE + 130)
    /*
    * A power failure was detected at the server.
    */

#define NELOG_UPS_Shutdown      (ERRLOG_BASE + 131)
    /*
    * The UPS service performed server shut down.
    */

#define NELOG_UPS_CmdFileError      (ERRLOG_BASE + 132)
    /*
    * The UPS service did not complete execution of the
    * user specified shut down command file.
    */

#define NELOG_UPS_CannotOpenDriver  (ERRLOG_BASE+133)
    /*
    * The UPS driver could not be opened.  The error code is
    * the data.
    */

#define NELOG_UPS_PowerBack     (ERRLOG_BASE + 134)
    /*
    * Power has been restored.
    */

#define NELOG_UPS_CmdFileConfig     (ERRLOG_BASE + 135)
    /*
    * There is a problem with a configuration of user specified
    * shut down command file.
    */

#define NELOG_UPS_CmdFileExec       (ERRLOG_BASE + 136)
    /*
    * The UPS service failed to execute a user specified shutdown
    * command file %1.  The error code is the data.
    */

//
//  Remoteboot server specific error log messages are from 150 to 157
//

#define NELOG_Missing_Parameter     (ERRLOG_BASE + 150)
    /*
    * Initialization failed because of an invalid or missing
    *  parameter in the configuration file %1.
    */

#define NELOG_Invalid_Config_Line   (ERRLOG_BASE + 151)
    /*
    * Initialization failed because of an invalid line in the
    *  configuration file %1. The invalid line is the data.
    */

#define NELOG_Invalid_Config_File   (ERRLOG_BASE + 152)
    /*
    * Initialization failed because of an error in the configuration
    *  file %1.
    */

#define NELOG_File_Changed      (ERRLOG_BASE + 153)
    /*
    * The file %1 has been changed after initialization.
    *  The boot-block loading was temporarily terminated.
    */

#define NELOG_Files_Dont_Fit        (ERRLOG_BASE + 154)
    /*
    * The files do not fit to the boot-block configuration
    * file %1. Change the BASE and ORG definitions or the order
    * of the files.
    */

#define NELOG_Wrong_DLL_Version     (ERRLOG_BASE + 155)
    /*
    * Initialization failed because the dynamic-link
    *  library %1 returned an incorrect version number.
    */

#define NELOG_Error_in_DLL      (ERRLOG_BASE + 156)
    /*
    * There was an unrecoverable error in the dynamic-
    *  link library of the service.
    */

#define NELOG_System_Error      (ERRLOG_BASE + 157)
    /*
    * The system returned an unexpected error code.
    *  The error code is the data.
    */

#define NELOG_FT_ErrLog_Too_Large (ERRLOG_BASE + 158)
    /*
    * The fault-tolerance error log file, LANROOT\LOGS\FT.LOG,
    *  is more than 64K.
    */

#define NELOG_FT_Update_In_Progress (ERRLOG_BASE + 159)
    /*
    * The fault-tolerance error-log file, LANROOT\LOGS\FT.LOG, had the
    * update in progress bit set upon opening, which means that the
    * system crashed while working on the error log.
    */


//
// Microsoft has created a generic error log entry for OEMs to use to
// log errors from OEM value added services.  The code, which is the
// 2nd arg to NetErrorLogWrite, is 3299.  This value is manifest in
// NET/H/ERRLOG.H as NELOG_OEM_Code.  The text for error log entry
// NELOG_OEM_Code is:  "%1 %2 %3 %4 %5 %6 %7 %8 %9.".
//
// Microsoft suggests that OEMs use the insertion strings as follows:
// %1:  OEM System Name (e.g. 3+Open)
// %2:  OEM Service Name (e.g. 3+Mail)
// %3:  Severity level (e.g.  error, warning, etc.)
// %4:  OEM error log entry sub-identifier  (e.g. error code #)
// %5 - % 9:  Text.
//
// The call to NetErrorWrite must set nstrings = 9, and provide 9
// ASCIIZ strings.  If the caller does not have 9 insertion strings,
// provide null strings for the empty insertion strings.
//

#define NELOG_OEM_Code              (ERRLOG_BASE + 199)
    /*
    * %1 %2 %3 %4 %5 %6 %7 %8 %9.
    */

//
// another error log range defined for NT Lanman.
//

#define ERRLOG2_BASE 5700        /* New NT NELOG errors start here */

#define NELOG_NetlogonSSIInitError              (ERRLOG2_BASE + 0)
    /*
     * The Netlogon service could not initialize the replication data
     * structures successfully. The service was terminated.  The following
     * error occurred: %n%1
     */

#define NELOG_NetlogonFailedToUpdateTrustList   (ERRLOG2_BASE + 1)
    /*
     * The Netlogon service failed to update the domain trust list.  The
     * following error occurred: %n%1
     */

#define NELOG_NetlogonFailedToAddRpcInterface   (ERRLOG2_BASE + 2)
    /*
     * The Netlogon service could not add the RPC interface.  The
     * service was terminated. The following error occurred: %n%1
     */

#define NELOG_NetlogonFailedToReadMailslot      (ERRLOG2_BASE + 3)
    /*
     * The Netlogon service could not read a mailslot message from %1 due
     * to the following error: %n%2
     */

#define NELOG_NetlogonFailedToRegisterSC        (ERRLOG2_BASE + 4)
    /*
     * The Netlogon service failed to register the service with the
     * service controller. The service was terminated. The following
     * error occurred: %n%1
     */

#define NELOG_NetlogonChangeLogCorrupt          (ERRLOG2_BASE + 5)
    /*
     * The change log cache maintained by the Netlogon service for
     * database changes is corrupted. The Netlogon service is resetting
     * the change log.
     */

#define NELOG_NetlogonFailedToCreateShare       (ERRLOG2_BASE + 6)
    /*
     * The Netlogon service could not create server share %1.  The following
     * error occurred: %n%2
     */

#define NELOG_NetlogonDownLevelLogonFailed      (ERRLOG2_BASE + 7)
    /*
     * The down-level logon request for the user %1 from %2 failed.
     */

#define NELOG_NetlogonDownLevelLogoffFailed     (ERRLOG2_BASE + 8)
    /*
     * The down-level logoff request for the user %1 from %2 failed.
     */

#define NELOG_NetlogonNTLogonFailed             (ERRLOG2_BASE + 9)
    /*
     * The Windows NT %1 logon request for the user %2\%3 from %4 (via %5)
     * failed.
     */

#define NELOG_NetlogonNTLogoffFailed            (ERRLOG2_BASE + 10)
    /*
     * The Windows NT %1 logoff request for the user %2\%3 from %4
     * failed.
     */

#define NELOG_NetlogonPartialSyncCallSuccess    (ERRLOG2_BASE + 11)
    /*
     * The partial synchronization request from the server %1 completed
     * successfully. %2 changes(s) has(have) been returned to the
     * caller.
     */

#define NELOG_NetlogonPartialSyncCallFailed     (ERRLOG2_BASE + 12)
    /*
     * The partial synchronization request from the server %1 failed with
     * the following error: %n%2
     */

#define NELOG_NetlogonFullSyncCallSuccess       (ERRLOG2_BASE + 13)
    /*
     * The full synchronization request from the server %1 completed
     * successfully. %2 object(s) has(have) been returned to
     * the caller.
     */

#define NELOG_NetlogonFullSyncCallFailed        (ERRLOG2_BASE + 14)
    /*
     * The full synchronization request from the server %1 failed with
     * the following error: %n%2
     */

#define NELOG_NetlogonPartialSyncSuccess        (ERRLOG2_BASE + 15)
    /*
     * The partial synchronization replication of the %1 database from the
     * domain controller %2 completed successfully. %3 change(s) is(are)
     * applied to the database.
     */


#define NELOG_NetlogonPartialSyncFailed         (ERRLOG2_BASE + 16)
    /*
     * The partial synchronization replication of the %1 database from the
     * domain controller %2 failed with the following error: %n%3
     */

#define NELOG_NetlogonFullSyncSuccess           (ERRLOG2_BASE + 17)
    /*
     * The full synchronization replication of the %1 database from the
     * domain controller %2 completed successfully.
     */


#define NELOG_NetlogonFullSyncFailed            (ERRLOG2_BASE + 18)
    /*
     * The full synchronization replication of the %1 database from the
     * domain controller %2 failed with the following error: %n%3
     */

#define NELOG_NetlogonAuthNoDomainController    (ERRLOG2_BASE + 19)
    /*
     *  No Windows NT Advanced Server is available for domain %1 for
     *  the following reason: %n%2
     */

#define NELOG_NetlogonAuthNoTrustLsaSecret      (ERRLOG2_BASE + 20)
    /*
     * The session setup to the Windows NT Advanced Server %1 for the domain %2
     * failed because the computer %3 does not have a local security database account.
     */

#define NELOG_NetlogonAuthNoTrustSamAccount     (ERRLOG2_BASE + 21)
    /*
     * The session setup to the Windows NT Advanced Server %1 for the domain %2
     * failed because the Windows NT Advanced Server does not have an account
     * for the computer %3.
     */

#define NELOG_NetlogonServerAuthFailed          (ERRLOG2_BASE + 22)
    /*
     * The session setup from the computer %1 failed to authenticate.
     * The name of the account referenced in the security database is
     * %2.  The following error occurred: %n%3
     */

#define NELOG_NetlogonServerAuthNoTrustSamAccount (ERRLOG2_BASE + 23)
    /*
     * The session setup from the computer %1 failed because there is
     * no trust account in the security database for this computer. The name of
     * the account referenced in the security database is %2.
     */

//
// General log messages for NT services.
//

#define NELOG_FailedToRegisterSC                  (ERRLOG2_BASE + 24)
    /*
     * Could not register control handler with service controller %1.
     */

#define NELOG_FailedToSetServiceStatus            (ERRLOG2_BASE + 25)
    /*
     * Could not set service status with service controller %1.
     */

#define NELOG_FailedToGetComputerName             (ERRLOG2_BASE + 26)
    /*
     * Could not find the computer name %1.
     */

#define NELOG_DriverNotLoaded                     (ERRLOG2_BASE + 27)
    /*
     * Could not load %1 device driver.
     */

#define NELOG_NoTranportLoaded                    (ERRLOG2_BASE + 28)
    /*
     * Could not load any transport.
     */

//
// More Netlogon service events
//

#define NELOG_NetlogonFailedDomainDelta           (ERRLOG2_BASE + 29)
    /*
     * Replication of the %1 Domain Object "%2" from domain controller
     * %3 failed with the following error: %n%4
     */

#define NELOG_NetlogonFailedGlobalGroupDelta      (ERRLOG2_BASE + 30)
    /*
     * Replication of the %1 Global Group "%2" from domain controller
     * %3 failed with the following error: %n%4
     */

#define NELOG_NetlogonFailedLocalGroupDelta       (ERRLOG2_BASE + 31)
    /*
     * Replication of the %1 Local Group "%2" from domain controller
     * %3 failed with the following error: %n%4
     */

#define NELOG_NetlogonFailedUserDelta             (ERRLOG2_BASE + 32)
    /*
     * Replication of the %1 User "%2" from domain controller
     * %3 failed with the following error: %n%4
     */

#define NELOG_NetlogonFailedPolicyDelta           (ERRLOG2_BASE + 33)
    /*
     * Replication of the %1 Policy Object "%2" from domain controller
     * %3 failed with the following error: %n%4
     */

#define NELOG_NetlogonFailedTrustedDomainDelta    (ERRLOG2_BASE + 34)
    /*
     * Replication of the %1 Trusted Domain Object "%2" from domain controller
     * %3 failed with the following error: %n%4
     */

#define NELOG_NetlogonFailedAccountDelta          (ERRLOG2_BASE + 35)
    /*
     * Replication of the %1 Account Object "%2" from domain controller
     * %3 failed with the following error: %n%4
     */

#define NELOG_NetlogonFailedSecretDelta           (ERRLOG2_BASE + 36)
    /*
     * Replication of the %1 Secret "%2" from domain controller
     * %3 failed with the following error: %n%4
     */

#define NELOG_NetlogonSystemError                 (ERRLOG2_BASE + 37)
    /*
    * The system returned the following unexpected error code: %n%1
    */

#define NELOG_NetlogonDuplicateMachineAccounts    (ERRLOG2_BASE + 38)
    /*
    * Netlogon has detected two machine accounts for server "%1".
    * The server can be either an NTAS server that is a member of the domain
    * or the server can be a Lanman server with an account in the SERVERS
    * global group.  It cannot be both.
    */

#define NELOG_NetlogonTooManyGlobalGroups         (ERRLOG2_BASE + 39)
    /*
    * This domain has more global groups than can be replicated to a LanMan
    * BDC.  Either delete some of your global groups or remove the LanMan
    * BDCs from the domain.
    */

#define NELOG_NetlogonBrowserDriver               (ERRLOG2_BASE + 40)
    /*
    * The Browser driver returned the following error to Netlogon: %n%1
    */

//
//  More Remoteboot service events.
//
#define NELOG_RplMessages                         (ERRLOG2_BASE + 42)
    /*
    * Service failed to retrieve messages needed to boot remote boot clients.
    */

#define NELOG_RplXnsBoot                          (ERRLOG2_BASE + 43)
    /*
    * Service experienced a severe error and can no longer provide remote boot
    * for 3Com 3Start remote boot clients.
    */

#define NELOG_RplSystem                           (ERRLOG2_BASE + 44)
    /*
    * Service experienced a severe system error and will shut itself down.
    */

#define NELOG_RplWkstaTimeout                     (ERRLOG2_BASE + 45)
    /*
    * Client with computer name %1 failed to ackowledge receipt of the
    * boot data.  Remote boot of this client was not completed.
    */

#define NELOG_RplWkstaFileOpen                    (ERRLOG2_BASE + 46)
    /*
    * Client with computer name %1 was not booted due to an error in opening
    * file %2.
    */

#define NELOG_RplWkstaFileRead                    (ERRLOG2_BASE + 47)
    /*
    * Client with computer name %1 was not booted due to an error in reading
    * file %2.
    */

#define NELOG_RplWkstaMemory                      (ERRLOG2_BASE + 48)
    /*
    * Client with computer name %1 was not booted due to insufficent memory
    * at the remote boot server.
    */

#define NELOG_RplWkstaFileChecksum                (ERRLOG2_BASE + 49)
    /*
    * Client with computer name %1 will be booted without using checksums
    * because checksum for file %2 could not be calculated.
    */

#define NELOG_RplWkstaFileLineCount               (ERRLOG2_BASE + 50)
    /*
    * Client with computer name %1 was not booted due to too many lines in
    * file %2.
    */

#define NELOG_RplWkstaBbcFile                     (ERRLOG2_BASE + 51)
    /*
    * Client with computer name %1 was not booted because the boot block
    * configuration file %2 for this client does not contain boot block
    * line and/or loader line.
    */

#define NELOG_RplWkstaFileSize                    (ERRLOG2_BASE + 52)
    /*
    * Client with computer name %1 was not booted due to a bad size of
    * file %2.
    */

#define NELOG_RplWkstaInternal                    (ERRLOG2_BASE + 53)
    /*
    * Client with computer name %1 was not booted due to remote boot
    * service internal error.
    */

#define NELOG_RplWkstaWrongVersion                (ERRLOG2_BASE + 54)
    /*
    * Client with computer name %1 was not booted because file %2 has an
    * invalid boot header.
    */

#define NELOG_RplWkstaNetwork                     (ERRLOG2_BASE + 55)
    /*
    * Client with computer name %1 was not booted due to network error.
    */

#define NELOG_RplAdapterResource                  (ERRLOG2_BASE + 56)
    /*
    * Client with adapter id %1 was not booted due to lack of resources.
    */

#define NELOG_RplFileCopy                         (ERRLOG2_BASE + 57)
    /*
    * Service experienced error copying file or directory %1.
    */

#define NELOG_RplFileDelete                       (ERRLOG2_BASE + 58)
    /*
    * Service experienced error deleting file or directory %1.
    */

#define NELOG_RplFilePerms                        (ERRLOG2_BASE + 59)
    /*
    * Service experienced error setting permissions on file or directory %1.
    */

#endif // _LMERRLOG_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\tools\c932\inc\lmsname.h ===
/*++ BUILD Version: 0002    // Increment this if a change has global effects

Copyright (c) 1991-1993  Microsoft Corporation

Module Name:

    lmsname.h

Abstract:

    This file contains service name strings.  It is included by lmsvc.h.

Author:

    Rita Wong (ritaw)     14-Feb-1992

Environment:

    User Mode -Win32

Revision History:

    01-May-1992 JohnRo
        Added equates for old-style names (SERVICE_LM20_xxx).

--*/

#ifndef _LMSNAME_
#define _LMSNAME_

//
//  Standard LAN Manager service names.
//

#define SERVICE_WORKSTATION       TEXT("LanmanWorkstation")
#define SERVICE_LM20_WORKSTATION  TEXT("WORKSTATION")
#define WORKSTATION_DISPLAY_NAME  TEXT("Workstation")

#define SERVICE_SERVER            TEXT("LanmanServer")
#define SERVICE_LM20_SERVER       TEXT("SERVER")
#define SERVER_DISPLAY_NAME       TEXT("Server")

#define SERVICE_BROWSER           TEXT("BROWSER")
#define SERVICE_LM20_BROWSER      SERVICE_BROWSER

#define SERVICE_MESSENGER         TEXT("MESSENGER")
#define SERVICE_LM20_MESSENGER    SERVICE_MESSENGER

#define SERVICE_NETRUN            TEXT("NETRUN")
#define SERVICE_LM20_NETRUN       SERVICE_NETRUN

#define SERVICE_SPOOLER           TEXT("SPOOLER")
#define SERVICE_LM20_SPOOLER      SERVICE_SPOOLER

#define SERVICE_ALERTER           TEXT("ALERTER")
#define SERVICE_LM20_ALERTER      SERVICE_ALERTER

#define SERVICE_NETLOGON          TEXT("NETLOGON")
#define SERVICE_LM20_NETLOGON     SERVICE_NETLOGON

#define SERVICE_NETPOPUP          TEXT("NETPOPUP")
#define SERVICE_LM20_NETPOPUP     SERVICE_NETPOPUP

#define SERVICE_SQLSERVER         TEXT("SQLSERVER")
#define SERVICE_LM20_SQLSERVER    SERVICE_SQLSERVER

#define SERVICE_REPL              TEXT("REPLICATOR")
#define SERVICE_LM20_REPL         SERVICE_REPL

#define SERVICE_RIPL              TEXT("REMOTEBOOT")
#define SERVICE_LM20_RIPL         SERVICE_RIPL

#define SERVICE_TIMESOURCE        TEXT("TIMESOURCE")
#define SERVICE_LM20_TIMESOURCE   SERVICE_TIMESOURCE

#define SERVICE_AFP               TEXT("AFP")
#define SERVICE_LM20_AFP          SERVICE_AFP

#define SERVICE_UPS               TEXT("UPS")
#define SERVICE_LM20_UPS          SERVICE_UPS

#define SERVICE_XACTSRV           TEXT("XACTSRV")
#define SERVICE_LM20_XACTSRV      SERVICE_XACTSRV

#define SERVICE_TCPIP             TEXT("TCPIP")
#define SERVICE_LM20_TCPIP        SERVICE_TCPIP

#define SERVICE_NBT               TEXT("NBT")
#define SERVICE_LM20_NBT          SERVICE_NBT

#define SERVICE_LMHOSTS           TEXT("LMHOSTS")
#define SERVICE_LM20_LMHOSTS      SERVICE_LMHOSTS

#define SERVICE_TELNET            TEXT("Telnet")
#define SERVICE_LM20_TELNET       SERVICE_TELNET

#define SERVICE_SCHEDULE          TEXT("Schedule")
#define SERVICE_LM20_SCHEDULE     SERVICE_SCHEDULE

#define SERVICE_NTLMSSP           TEXT("NtLmSsp")

#define SERVICE_DHCP              TEXT("DHCP")
#define SERVICE_LM20_DHCP         SERVICE_DHCP

#define SERVICE_NWSAP             TEXT("NwSapAgent")
#define SERVICE_LM20_NWSAP        SERVICE_NWSAP
#define NWSAP_DISPLAY_NAME        TEXT("NW Sap Agent")

#endif

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\tools\c932\inc\lmremutl.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1991-1993  Microsoft Corporation

Module Name:

    lmremutl.h

Abstract:

    This file contains structures, function prototypes, and definitions
    for the NetRemote API.

Author:

    Dan Lafferty (danl) 10-Mar-1991

Environment:

    User Mode - Win32
    Portable to any flat, 32-bit environment.  (Uses Win32 typedefs.)
    Requires ANSI C extensions: slash-slash comments, long external names.

Revision History:

    10-Mar-1991 danl
        Created from LM2.0 header files and NT-LAN API Spec.
    14-Mar-1991 JohnRo
        Delete password case-sensitivity bit.
        Change time of day structure to be NT style names.
    22-Mar-1991 JohnRo
        Changed tod_timezone to be signed.  Got rid of tabs in file.
    06-May-1991 JohnRo
        Implement UNICODE.
    31-Oct-1991 JohnRo
        RAID 3414: allow explicit local server name.  Also allow use of
        NetRemoteComputerSupports() for local computer.
    06-May-1993 JohnRo
        RAID 8849: Export RxRemoteApi for general use.

--*/

#ifndef _LMREMUTL_
#define _LMREMUTL_

#ifdef __cplusplus
extern "C" {
#endif


//
// Type Definitions
//

#ifndef DESC_CHAR_UNICODE

typedef CHAR DESC_CHAR;

#else // DESC_CHAR_UNICODE is defined

typedef WCHAR DESC_CHAR;

#endif // DESC_CHAR_UNICODE is defined


typedef DESC_CHAR * LPDESC;


//
// Function Prototypes
//

NET_API_STATUS NET_API_FUNCTION
NetRemoteTOD (
    IN LPTSTR UncServerName,
    OUT LPBYTE *BufferPtr
    );

NET_API_STATUS NET_API_FUNCTION
NetRemoteComputerSupports(
    IN LPTSTR UncServerName OPTIONAL,   // Must start with "\\".
    IN DWORD OptionsWanted,             // Set SUPPORTS_ bits wanted.
    OUT LPDWORD OptionsSupported        // Supported features, masked.
    );

NET_API_STATUS
RxRemoteApi(
    IN DWORD ApiNumber,
    IN LPTSTR UncServerName,                    // Required, with \\name.
    IN LPDESC ParmDescString,
    IN LPDESC DataDesc16 OPTIONAL,
    IN LPDESC DataDesc32 OPTIONAL,
    IN LPDESC DataDescSmb OPTIONAL,
    IN LPDESC AuxDesc16 OPTIONAL,
    IN LPDESC AuxDesc32 OPTIONAL,
    IN LPDESC AuxDescSmb OPTIONAL,
    IN DWORD  Flags,
    ...                                         // rest of API's arguments
    );



//
//  Data Structures
//

typedef struct _TIME_OF_DAY_INFO {
    DWORD      tod_elapsedt;
    DWORD      tod_msecs;
    DWORD      tod_hours;
    DWORD      tod_mins;
    DWORD      tod_secs;
    DWORD      tod_hunds;
    LONG       tod_timezone;
    DWORD      tod_tinterval;
    DWORD      tod_day;
    DWORD      tod_month;
    DWORD      tod_year;
    DWORD      tod_weekday;
} TIME_OF_DAY_INFO, *PTIME_OF_DAY_INFO, *LPTIME_OF_DAY_INFO;

//
// Special Values and Constants
//

//
// Mask bits for use with NetRemoteComputerSupports:
//

#define SUPPORTS_REMOTE_ADMIN_PROTOCOL  0x00000002L
#define SUPPORTS_RPC                    0x00000004L
#define SUPPORTS_SAM_PROTOCOL           0x00000008L
#define SUPPORTS_UNICODE                0x00000010L
#define SUPPORTS_LOCAL                  0x00000020L
#define SUPPORTS_ANY                    0xFFFFFFFFL

//
// Flag bits for RxRemoteApi:
//

#define NO_PERMISSION_REQUIRED  0x00000001      // set if use NULL session
#define ALLOCATE_RESPONSE       0x00000002      // set if RxRemoteApi allocates response buffer
#define USE_SPECIFIC_TRANSPORT  0x80000000

#ifdef __cplusplus
}
#endif

#endif //_LMREMUTL_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\tools\c932\inc\lmstats.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1991-1993  Microsoft Corporation

Module Name:

    lmstats.h

Abstract:

    This module defines the API function prototypes and data structures
    for the following groups of NT API functions:
        NetStatistics

Author:

    Dan Lafferty (danl)  29-Mar-1991

Environment:

    User Mode - Win32

Notes:

    You must include NETCONS.H before this file, since this file depends
    on values defined in NETCONS.H.

Revision History:

    28-Mar-1991  Danl
        Ported from LM2.0 and the LMNETAPI spec.

--*/

#ifndef _LMSTATS_
#define _LMSTATS_

#ifdef __cplusplus
extern "C" {
#endif

//
// Function Prototypes - Statistics
//

NET_API_STATUS NET_API_FUNCTION
NetStatisticsGet (
    IN  LPTSTR  server,
    IN  LPTSTR  service,
    IN  DWORD   level,
    IN  DWORD   options,
    OUT LPBYTE  *bufptr
    );

//
// Data Structures - Statistics
//

#ifdef LM20_WORKSTATION_STATISTICS
typedef struct _STAT_WORKSTATION_0 {
     DWORD          stw0_start;
     DWORD          stw0_numNCB_r;
     DWORD          stw0_numNCB_s;
     DWORD          stw0_numNCB_a;
     DWORD          stw0_fiNCB_r;
     DWORD          stw0_fiNCB_s;
     DWORD          stw0_fiNCB_a;
     DWORD          stw0_fcNCB_r;
     DWORD          stw0_fcNCB_s;
     DWORD          stw0_fcNCB_a;
     DWORD          stw0_sesstart;
     DWORD          stw0_sessfailcon;
     DWORD          stw0_sessbroke;
     DWORD          stw0_uses;
     DWORD          stw0_usefail;
     DWORD          stw0_autorec;
     DWORD          stw0_bytessent_r_lo;
     DWORD          stw0_bytessent_r_hi;
     DWORD          stw0_bytesrcvd_r_lo;
     DWORD          stw0_bytesrcvd_r_hi;
     DWORD          stw0_bytessent_s_lo;
     DWORD          stw0_bytessent_s_hi;
     DWORD          stw0_bytesrcvd_s_lo;
     DWORD          stw0_bytesrcvd_s_hi;
     DWORD          stw0_bytessent_a_lo;
     DWORD          stw0_bytessent_a_hi;
     DWORD          stw0_bytesrcvd_a_lo;
     DWORD          stw0_bytesrcvd_a_hi;
     DWORD          stw0_reqbufneed;
     DWORD          stw0_bigbufneed;
} STAT_WORKSTATION_0, *PSTAT_WORKSTATION_0, *LPSTAT_WORKSTATION_0;
#else

//
// NB: The following structure is REDIR_STATISTICS in sdk\inc\ntddnfs.h. If you
//     change the structure, change it in both places
//

typedef struct _STAT_WORKSTATION_0 {
    LARGE_INTEGER   StatisticsStartTime;

    LARGE_INTEGER   BytesReceived;
    LARGE_INTEGER   SmbsReceived;
    LARGE_INTEGER   PagingReadBytesRequested;
    LARGE_INTEGER   NonPagingReadBytesRequested;
    LARGE_INTEGER   CacheReadBytesRequested;
    LARGE_INTEGER   NetworkReadBytesRequested;

    LARGE_INTEGER   BytesTransmitted;
    LARGE_INTEGER   SmbsTransmitted;
    LARGE_INTEGER   PagingWriteBytesRequested;
    LARGE_INTEGER   NonPagingWriteBytesRequested;
    LARGE_INTEGER   CacheWriteBytesRequested;
    LARGE_INTEGER   NetworkWriteBytesRequested;

    DWORD           InitiallyFailedOperations;
    DWORD           FailedCompletionOperations;

    DWORD           ReadOperations;
    DWORD           RandomReadOperations;
    DWORD           ReadSmbs;
    DWORD           LargeReadSmbs;
    DWORD           SmallReadSmbs;

    DWORD           WriteOperations;
    DWORD           RandomWriteOperations;
    DWORD           WriteSmbs;
    DWORD           LargeWriteSmbs;
    DWORD           SmallWriteSmbs;

    DWORD           RawReadsDenied;
    DWORD           RawWritesDenied;

    DWORD           NetworkErrors;

    //  Connection/Session counts
    DWORD           Sessions;
    DWORD           FailedSessions;
    DWORD           Reconnects;
    DWORD           CoreConnects;
    DWORD           Lanman20Connects;
    DWORD           Lanman21Connects;
    DWORD           LanmanNtConnects;
    DWORD           ServerDisconnects;
    DWORD           HungSessions;
    DWORD           UseCount;
    DWORD           FailedUseCount;

    //
    //  Queue Lengths (updates protected by RdrMpxTableSpinLock NOT
    //  RdrStatisticsSpinlock)
    //

    DWORD           CurrentCommands;

} STAT_WORKSTATION_0, *PSTAT_WORKSTATION_0, *LPSTAT_WORKSTATION_0;
#endif

typedef struct _STAT_SERVER_0 {
     DWORD          sts0_start;
     DWORD          sts0_fopens;
     DWORD          sts0_devopens;
     DWORD          sts0_jobsqueued;
     DWORD          sts0_sopens;
     DWORD          sts0_stimedout;
     DWORD          sts0_serrorout;
     DWORD          sts0_pwerrors;
     DWORD          sts0_permerrors;
     DWORD          sts0_syserrors;
     DWORD          sts0_bytessent_low;
     DWORD          sts0_bytessent_high;
     DWORD          sts0_bytesrcvd_low;
     DWORD          sts0_bytesrcvd_high;
     DWORD          sts0_avresponse;
     DWORD          sts0_reqbufneed;
     DWORD          sts0_bigbufneed;
} STAT_SERVER_0, *PSTAT_SERVER_0, *LPSTAT_SERVER_0;


//
// Special Values and Constants
//

#define STATSOPT_CLR    1
#define STATS_NO_VALUE  ((unsigned long) -1L)
#define STATS_OVERFLOW  ((unsigned long) -2L)


#ifdef __cplusplus
}
#endif

#endif // _LMSTATS.H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\tools\c932\inc\lmrepl.h ===
/*++ BUILD Version: 0004    // Increment this if a change has global effects

Copyright (c) 1991-1993  Microsoft Corporation

Module Name:

    LmRepl.h

Abstract:

    This file contains structures, function prototypes, and definitions
    for the replicator APIs.

Author:

    John Rogers (JohnRo) 17-Dec-1991

Environment:

    User Mode - Win32
    Portable to any flat, 32-bit environment.  (Uses Win32 typedefs.)
    Requires ANSI C extensions: slash-slash comments, long external names.

Notes:

    You must include LmCons.h before this file.

Revision History:

    17-Dec-1991 JohnRo
        Created from RitaW's replicator API spec.
    26-Dec-1991 JohnRo
        Added REPL_EDIR_INFO_2 and subsetted REPL_EDIR_INFO_1.
        Added INFOLEVEL equates.
        Changed values of REPL_EXTENT_FILE and REPL_EXTENT_TREE.
    07-Jan-1992 JohnRo
        Corrected typedef name (LPREPL_INFO_100 s.b. LPREPL_INFO_0).
    24-Jan-1992 JohnRo
        Changed to use LPTSTR etc.
    27-Feb-1992 JohnRo
        Changed state not started to state never replicated.

--*/

#ifndef _LMREPL_
#define _LMREPL_

#ifdef __cplusplus
extern "C" {
#endif

//
// Replicator Configuration APIs
//

#define REPL_ROLE_EXPORT        1
#define REPL_ROLE_IMPORT        2
#define REPL_ROLE_BOTH          3


#define REPL_INTERVAL_INFOLEVEL         (PARMNUM_BASE_INFOLEVEL + 0)
#define REPL_PULSE_INFOLEVEL            (PARMNUM_BASE_INFOLEVEL + 1)
#define REPL_GUARDTIME_INFOLEVEL        (PARMNUM_BASE_INFOLEVEL + 2)
#define REPL_RANDOM_INFOLEVEL           (PARMNUM_BASE_INFOLEVEL + 3)


typedef struct _REPL_INFO_0 {
    DWORD          rp0_role;
    LPTSTR         rp0_exportpath;
    LPTSTR         rp0_exportlist;
    LPTSTR         rp0_importpath;
    LPTSTR         rp0_importlist;
    LPTSTR         rp0_logonusername;
    DWORD          rp0_interval;
    DWORD          rp0_pulse;
    DWORD          rp0_guardtime;
    DWORD          rp0_random;
} REPL_INFO_0, *PREPL_INFO_0, *LPREPL_INFO_0;

typedef struct _REPL_INFO_1000 {
    DWORD          rp1000_interval;
} REPL_INFO_1000, *PREPL_INFO_1000, *LPREPL_INFO_1000;

typedef struct _REPL_INFO_1001 {
    DWORD          rp1001_pulse;
} REPL_INFO_1001, *PREPL_INFO_1001, *LPREPL_INFO_1001;

typedef struct _REPL_INFO_1002 {
    DWORD          rp1002_guardtime;
} REPL_INFO_1002, *PREPL_INFO_1002, *LPREPL_INFO_1002;

typedef struct _REPL_INFO_1003 {
    DWORD          rp1003_random;
} REPL_INFO_1003, *PREPL_INFO_1003, *LPREPL_INFO_1003;


NET_API_STATUS NET_API_FUNCTION
NetReplGetInfo (
    IN LPTSTR servername OPTIONAL,
    IN DWORD level,
    OUT LPBYTE * bufptr
    );

NET_API_STATUS NET_API_FUNCTION
NetReplSetInfo (
    IN LPTSTR servername OPTIONAL,
    IN DWORD level,
    IN LPBYTE buf,
    OUT LPDWORD parm_err OPTIONAL
    );


//
// Replicator Export Directory APIs
//

#define REPL_INTEGRITY_FILE     1
#define REPL_INTEGRITY_TREE     2


#define REPL_EXTENT_FILE        1
#define REPL_EXTENT_TREE        2


#define REPL_EXPORT_INTEGRITY_INFOLEVEL (PARMNUM_BASE_INFOLEVEL + 0)
#define REPL_EXPORT_EXTENT_INFOLEVEL    (PARMNUM_BASE_INFOLEVEL + 1)


typedef struct _REPL_EDIR_INFO_0 {
    LPTSTR         rped0_dirname;
} REPL_EDIR_INFO_0, *PREPL_EDIR_INFO_0, *LPREPL_EDIR_INFO_0;

typedef struct _REPL_EDIR_INFO_1 {
    LPTSTR         rped1_dirname;
    DWORD          rped1_integrity;
    DWORD          rped1_extent;
} REPL_EDIR_INFO_1, *PREPL_EDIR_INFO_1, *LPREPL_EDIR_INFO_1;

typedef struct _REPL_EDIR_INFO_2 {
    LPTSTR         rped2_dirname;
    DWORD          rped2_integrity;
    DWORD          rped2_extent;
    DWORD          rped2_lockcount;
    DWORD          rped2_locktime;
} REPL_EDIR_INFO_2, *PREPL_EDIR_INFO_2, *LPREPL_EDIR_INFO_2;

typedef struct _REPL_EDIR_INFO_1000 {
    DWORD          rped1000_integrity;
} REPL_EDIR_INFO_1000, *PREPL_EDIR_INFO_1000, *LPREPL_EDIR_INFO_1000;

typedef struct _REPL_EDIR_INFO_1001 {
    DWORD          rped1001_extent;
} REPL_EDIR_INFO_1001, *PREPL_EDIR_INFO_1001, *LPREPL_EDIR_INFO_1001;


NET_API_STATUS NET_API_FUNCTION
NetReplExportDirAdd (
    IN LPTSTR servername OPTIONAL,
    IN DWORD level,
    IN LPBYTE buf,
    OUT LPDWORD parm_err OPTIONAL
    );

NET_API_STATUS NET_API_FUNCTION
NetReplExportDirDel (
    IN LPTSTR servername OPTIONAL,
    IN LPTSTR dirname
    );

NET_API_STATUS NET_API_FUNCTION
NetReplExportDirEnum (
    IN LPTSTR servername OPTIONAL,
    IN DWORD level,
    OUT LPBYTE * bufptr,
    IN DWORD prefmaxlen,
    OUT LPDWORD entriesread,
    OUT LPDWORD totalentries,
    IN OUT LPDWORD resumehandle OPTIONAL
    );

NET_API_STATUS NET_API_FUNCTION
NetReplExportDirGetInfo (
    IN LPTSTR servername OPTIONAL,
    IN LPTSTR dirname,
    IN DWORD level,
    OUT LPBYTE * bufptr
    );

NET_API_STATUS NET_API_FUNCTION
NetReplExportDirSetInfo (
    IN LPTSTR servername OPTIONAL,
    IN LPTSTR dirname,
    IN DWORD level,
    IN LPBYTE buf,
    OUT LPDWORD parm_err OPTIONAL
    );

NET_API_STATUS NET_API_FUNCTION
NetReplExportDirLock (
    IN LPTSTR servername OPTIONAL,
    IN LPTSTR dirname
    );

NET_API_STATUS NET_API_FUNCTION
NetReplExportDirUnlock (
    IN LPTSTR servername OPTIONAL,
    IN LPTSTR dirname,
    IN DWORD unlockforce
    );


#define REPL_UNLOCK_NOFORCE     0
#define REPL_UNLOCK_FORCE       1


//
// Replicator Import Directory APIs
//


typedef struct _REPL_IDIR_INFO_0 {
    LPTSTR         rpid0_dirname;
} REPL_IDIR_INFO_0, *PREPL_IDIR_INFO_0, *LPREPL_IDIR_INFO_0;

typedef struct _REPL_IDIR_INFO_1 {
    LPTSTR         rpid1_dirname;
    DWORD          rpid1_state;
    LPTSTR         rpid1_mastername;
    DWORD          rpid1_last_update_time;
    DWORD          rpid1_lockcount;
    DWORD          rpid1_locktime;
} REPL_IDIR_INFO_1, *PREPL_IDIR_INFO_1, *LPREPL_IDIR_INFO_1;


NET_API_STATUS NET_API_FUNCTION
NetReplImportDirAdd (
    IN LPTSTR servername OPTIONAL,
    IN DWORD level,
    IN LPBYTE buf,
    OUT LPDWORD parm_err OPTIONAL
    );

NET_API_STATUS NET_API_FUNCTION
NetReplImportDirDel (
    IN LPTSTR servername OPTIONAL,
    IN LPTSTR dirname
    );

NET_API_STATUS NET_API_FUNCTION
NetReplImportDirEnum (
    IN LPTSTR servername OPTIONAL,
    IN DWORD level,
    OUT LPBYTE * bufptr,
    IN DWORD prefmaxlen,
    OUT LPDWORD entriesread,
    OUT LPDWORD totalentries,
    IN OUT LPDWORD resumehandle OPTIONAL
    );

NET_API_STATUS NET_API_FUNCTION
NetReplImportDirGetInfo (
    IN LPTSTR servername OPTIONAL,
    IN LPTSTR dirname,
    IN DWORD level,
    OUT LPBYTE * bufptr
    );

NET_API_STATUS NET_API_FUNCTION
NetReplImportDirLock (
    IN LPTSTR servername OPTIONAL,
    IN LPTSTR dirname
    );


NET_API_STATUS NET_API_FUNCTION
NetReplImportDirUnlock (
    IN LPTSTR servername OPTIONAL,
    IN LPTSTR dirname,
    IN DWORD unlockforce
    );


#define REPL_STATE_OK                   0
#define REPL_STATE_NO_MASTER            1
#define REPL_STATE_NO_SYNC              2
#define REPL_STATE_NEVER_REPLICATED     3


#ifdef __cplusplus
}
#endif

#endif //_LMREPL_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\tools\c932\inc\lmserver.h ===
/*++ BUILD Version: 0007    // Increment this if a change has global effects

Copyright (c) 1990-1993  Microsoft Corporation

Module Name:

    lmserver.h

Abstract:

    This file contains information about NetServer APIs.
        Function Prototypes
        Data Structures
        Definition of special values

Author:

    Dan Lafferty (danl)  24-Jan-1991

Environment:

    User Mode - Win32

Notes:

    You must include NETCONS.H before this file, since this file depends
    on values defined in NETCONS.H.

Revision History:

    25-Jan-1991  Danl
        Ported from LM2.0
    12-Feb-1991  danl
        Changed info levels to match current spec - no more info level 3.
    14-Apr-1991  w-shanku
        Changed parmnum constants to be more consistent with OS/2 parmnums.
    19-Apr-1991 JohnRo
        Added OPTIONAL keywords to APIs.  Added SV_MAX_SRV_HEUR_LEN from LM 2.x
    09-May-1991 JohnRo
        Implement UNICODE.
    22-May-1991 JohnRo
        Added three new SV_TYPE equates from LM 2.x source.
    23-May-1991 JohnRo
        Added sv403_autopath.
    26-May-1991 JohnRo
        Corrected value of SV_ERRORALERT_PARMNUM.
    18-Jun-1991 JohnRo
        Changed sv102_disc to be signed, and changed SV_NODISC to be 32-bits.
        Added sv102_licenses.
    03-May-1993 JohnRo
        Added correct name of SV_TYPE_SERVER_UNIX as alias for
        SV_TYPE_XENIX_SERVER (the name as someone accidentally defined for NT).


--*/

#ifndef _LMSERVER_
#define _LMSERVER_

#ifdef __cplusplus
extern "C" {
#endif

#include <winsvc.h>     // SERVICE_STATUS_HANDLE

//
// Function Prototypes - SERVER
//

NET_API_STATUS NET_API_FUNCTION
NetServerEnum (
    IN  LPTSTR      servername OPTIONAL,
    IN  DWORD       level,
    OUT LPBYTE      *bufptr,
    IN  DWORD       prefmaxlen,
    OUT LPDWORD     entriesread,
    OUT LPDWORD     totalentries,
    IN  DWORD       servertype,
    IN  LPTSTR      domain OPTIONAL,
    IN OUT LPDWORD  resume_handle OPTIONAL
    );

NET_API_STATUS NET_API_FUNCTION
NetServerGetInfo (
    IN  LPTSTR  servername OPTIONAL,
    IN  DWORD   level,
    OUT LPBYTE  *bufptr
    );

NET_API_STATUS NET_API_FUNCTION
NetServerSetInfo (
    IN  LPTSTR  servername OPTIONAL,
    IN  DWORD   level,
    IN  LPBYTE  buf,
    OUT LPDWORD ParmError OPTIONAL
    );

//
// Temporary hack function.
//

NET_API_STATUS
NetServerSetInfoCommandLine (
    IN WORD argc,
    IN LPTSTR argv[]
    );

NET_API_STATUS NET_API_FUNCTION
NetServerDiskEnum (
    IN  LPTSTR      servername OPTIONAL,
    IN  DWORD       level,
    OUT LPBYTE      *bufptr,
    IN  DWORD       prefmaxlen,
    OUT LPDWORD     entriesread,
    OUT LPDWORD     totalentries,
    IN OUT LPDWORD  resume_handle OPTIONAL
    );

NET_API_STATUS NET_API_FUNCTION
NetServerTransportAdd (
    IN  LPTSTR  servername,
    IN  DWORD   level,
    IN  LPBYTE  bufptr
    );

NET_API_STATUS NET_API_FUNCTION
NetServerTransportDel (
    IN  LPTSTR  servername,
    IN  DWORD   level,
    IN  LPBYTE  bufptr
    );

NET_API_STATUS NET_API_FUNCTION
NetServerTransportEnum (
    IN  LPTSTR      servername,
    IN  DWORD       level,
    OUT LPBYTE      *bufptr,
    IN  DWORD       prefmaxlen,
    OUT LPDWORD     entriesread,
    OUT LPDWORD     totalentries,
    IN OUT LPDWORD  resumehandle
    );

//
// The following function can be called by Win NT services to register
// their service type.  This function is exported from advapi32.dll.
// Therefore, if this is the only function called by that service, then
// it is not necessary to link to netapi32.lib.
//
BOOL
SetServiceBits(
    IN SERVICE_STATUS_HANDLE    hServiceStatus,
    IN DWORD                    dwServiceBits,
    IN BOOL                     bSetBitsOn,
    IN BOOL                     bUpdateImmediately
    );

//
// Data Structures - SERVER
//

typedef struct _SERVER_INFO_100 {
    DWORD           sv100_platform_id;
    LPTSTR          sv100_name;
} SERVER_INFO_100, *PSERVER_INFO_100, *LPSERVER_INFO_100;

typedef struct _SERVER_INFO_101 {
    DWORD           sv101_platform_id;
    LPTSTR          sv101_name;
    DWORD           sv101_version_major;
    DWORD           sv101_version_minor;
    DWORD           sv101_type;
    LPTSTR          sv101_comment;
} SERVER_INFO_101, *PSERVER_INFO_101, *LPSERVER_INFO_101;

typedef struct _SERVER_INFO_102 {
     DWORD          sv102_platform_id;
     LPTSTR         sv102_name;
     DWORD          sv102_version_major;
     DWORD          sv102_version_minor;
     DWORD          sv102_type;
     LPTSTR         sv102_comment;
     DWORD          sv102_users;
     LONG           sv102_disc;
     BOOL           sv102_hidden;
     DWORD          sv102_announce;
     DWORD          sv102_anndelta;
     DWORD          sv102_licenses;
     LPTSTR         sv102_userpath;
} SERVER_INFO_102, *PSERVER_INFO_102, *LPSERVER_INFO_102;

typedef struct _SERVER_INFO_402 {
     DWORD          sv402_ulist_mtime;
     DWORD          sv402_glist_mtime;
     DWORD          sv402_alist_mtime;
     LPTSTR         sv402_alerts;
     DWORD          sv402_security;
     DWORD          sv402_numadmin;
     DWORD          sv402_lanmask;
     LPTSTR         sv402_guestacct;
     DWORD          sv402_chdevs;
     DWORD          sv402_chdevq;
     DWORD          sv402_chdevjobs;
     DWORD          sv402_connections;
     DWORD          sv402_shares;
     DWORD          sv402_openfiles;
     DWORD          sv402_sessopens;
     DWORD          sv402_sessvcs;
     DWORD          sv402_sessreqs;
     DWORD          sv402_opensearch;
     DWORD          sv402_activelocks;
     DWORD          sv402_numreqbuf;
     DWORD          sv402_sizreqbuf;
     DWORD          sv402_numbigbuf;
     DWORD          sv402_numfiletasks;
     DWORD          sv402_alertsched;
     DWORD          sv402_erroralert;
     DWORD          sv402_logonalert;
     DWORD          sv402_accessalert;
     DWORD          sv402_diskalert;
     DWORD          sv402_netioalert;
     DWORD          sv402_maxauditsz;
     LPTSTR         sv402_srvheuristics;
} SERVER_INFO_402, *PSERVER_INFO_402, *LPSERVER_INFO_402;

typedef struct _SERVER_INFO_403 {
     DWORD          sv403_ulist_mtime;
     DWORD          sv403_glist_mtime;
     DWORD          sv403_alist_mtime;
     LPTSTR         sv403_alerts;
     DWORD          sv403_security;
     DWORD          sv403_numadmin;
     DWORD          sv403_lanmask;
     LPTSTR         sv403_guestacct;
     DWORD          sv403_chdevs;
     DWORD          sv403_chdevq;
     DWORD          sv403_chdevjobs;
     DWORD          sv403_connections;
     DWORD          sv403_shares;
     DWORD          sv403_openfiles;
     DWORD          sv403_sessopens;
     DWORD          sv403_sessvcs;
     DWORD          sv403_sessreqs;
     DWORD          sv403_opensearch;
     DWORD          sv403_activelocks;
     DWORD          sv403_numreqbuf;
     DWORD          sv403_sizreqbuf;
     DWORD          sv403_numbigbuf;
     DWORD          sv403_numfiletasks;
     DWORD          sv403_alertsched;
     DWORD          sv403_erroralert;
     DWORD          sv403_logonalert;
     DWORD          sv403_accessalert;
     DWORD          sv403_diskalert;
     DWORD          sv403_netioalert;
     DWORD          sv403_maxauditsz;
     LPTSTR         sv403_srvheuristics;
     DWORD          sv403_auditedevents;
     DWORD          sv403_autoprofile;
     LPTSTR         sv403_autopath;
} SERVER_INFO_403, *PSERVER_INFO_403, *LPSERVER_INFO_403;

typedef struct _SERVER_INFO_502 {
    DWORD           sv502_sessopens;
    DWORD           sv502_sessvcs;
    DWORD           sv502_opensearch;
    DWORD           sv502_sizreqbuf;
    DWORD           sv502_initworkitems;
    DWORD           sv502_maxworkitems;
    DWORD           sv502_rawworkitems;
    DWORD           sv502_irpstacksize;
    DWORD           sv502_maxrawbuflen;
    DWORD           sv502_sessusers;
    DWORD           sv502_sessconns;
    DWORD           sv502_maxpagedmemoryusage;
    DWORD           sv502_maxnonpagedmemoryusage;
    BOOL            sv502_enablesoftcompat;
    BOOL            sv502_enableforcedlogoff;
    BOOL            sv502_timesource;
    BOOL            sv502_acceptdownlevelapis;
    BOOL            sv502_lmannounce;
} SERVER_INFO_502, *PSERVER_INFO_502, *LPSERVER_INFO_502;

typedef struct _SERVER_INFO_503 {
    DWORD           sv503_sessopens;
    DWORD           sv503_sessvcs;
    DWORD           sv503_opensearch;
    DWORD           sv503_sizreqbuf;
    DWORD           sv503_initworkitems;
    DWORD           sv503_maxworkitems;
    DWORD           sv503_rawworkitems;
    DWORD           sv503_irpstacksize;
    DWORD           sv503_maxrawbuflen;
    DWORD           sv503_sessusers;
    DWORD           sv503_sessconns;
    DWORD           sv503_maxpagedmemoryusage;
    DWORD           sv503_maxnonpagedmemoryusage;
    BOOL            sv503_enablesoftcompat;
    BOOL            sv503_enableforcedlogoff;
    BOOL            sv503_timesource;
    BOOL            sv503_acceptdownlevelapis;
    BOOL            sv503_lmannounce;
    LPTSTR          sv503_domain;
    DWORD           sv503_maxcopyreadlen;
    DWORD           sv503_maxcopywritelen;
    DWORD           sv503_minkeepsearch;
    DWORD           sv503_maxkeepsearch;
    DWORD           sv503_minkeepcomplsearch;
    DWORD           sv503_maxkeepcomplsearch;
    DWORD           sv503_threadcountadd;
    DWORD           sv503_numblockthreads;
    DWORD           sv503_scavtimeout;
    DWORD           sv503_minrcvqueue;
    DWORD           sv503_minfreeworkitems;
    DWORD           sv503_xactmemsize;
    DWORD           sv503_threadpriority;
    DWORD           sv503_maxmpxct;
    DWORD           sv503_oplockbreakwait;
    DWORD           sv503_oplockbreakresponsewait;
    BOOL            sv503_enableoplocks;
    BOOL            sv503_enableoplockforceclose;
    BOOL            sv503_enablefcbopens;
    BOOL            sv503_enableraw;
    BOOL            sv503_enablesharednetdrives;
    DWORD           sv503_minfreeconnections;
    DWORD           sv503_maxfreeconnections;
} SERVER_INFO_503, *PSERVER_INFO_503, *LPSERVER_INFO_503;

typedef struct _SERVER_INFO_599 {
    DWORD           sv599_sessopens;
    DWORD           sv599_sessvcs;
    DWORD           sv599_opensearch;
    DWORD           sv599_sizreqbuf;
    DWORD           sv599_initworkitems;
    DWORD           sv599_maxworkitems;
    DWORD           sv599_rawworkitems;
    DWORD           sv599_irpstacksize;
    DWORD           sv599_maxrawbuflen;
    DWORD           sv599_sessusers;
    DWORD           sv599_sessconns;
    DWORD           sv599_maxpagedmemoryusage;
    DWORD           sv599_maxnonpagedmemoryusage;
    BOOL            sv599_enablesoftcompat;
    BOOL            sv599_enableforcedlogoff;
    BOOL            sv599_timesource;
    BOOL            sv599_acceptdownlevelapis;
    BOOL            sv599_lmannounce;
    LPTSTR          sv599_domain;
    DWORD           sv599_maxcopyreadlen;
    DWORD           sv599_maxcopywritelen;
    DWORD           sv599_minkeepsearch;
    DWORD           sv599_maxkeepsearch;
    DWORD           sv599_minkeepcomplsearch;
    DWORD           sv599_maxkeepcomplsearch;
    DWORD           sv599_threadcountadd;
    DWORD           sv599_numblockthreads;
    DWORD           sv599_scavtimeout;
    DWORD           sv599_minrcvqueue;
    DWORD           sv599_minfreeworkitems;
    DWORD           sv599_xactmemsize;
    DWORD           sv599_threadpriority;
    DWORD           sv599_maxmpxct;
    DWORD           sv599_oplockbreakwait;
    DWORD           sv599_oplockbreakresponsewait;
    BOOL            sv599_enableoplocks;
    BOOL            sv599_enableoplockforceclose;
    BOOL            sv599_enablefcbopens;
    BOOL            sv599_enableraw;
    BOOL            sv599_enablesharednetdrives;
    DWORD           sv599_minfreeconnections;
    DWORD           sv599_maxfreeconnections;
    DWORD           sv599_initsesstable;
    DWORD           sv599_initconntable;
    DWORD           sv599_initfiletable;
    DWORD           sv599_initsearchtable;
    DWORD           sv599_alertschedule;
    DWORD           sv599_errorthreshold;
    DWORD           sv599_networkerrorthreshold;
    DWORD           sv599_diskspacethreshold;
    DWORD           sv599_diskconfiguration;
    DWORD           sv599_maxlinkdelay;
    DWORD           sv599_minlinkthroughput;
    DWORD           sv599_linkinfovalidtime;
    DWORD           sv599_scavqosinfoupdatetime;
    DWORD           sv599_maxworkitemidletime;
} SERVER_INFO_599, *PSERVER_INFO_599, *LPSERVER_INFO_599;

typedef struct _SERVER_INFO_598 {
    DWORD           sv598_maxrawworkitems;
    DWORD           sv598_nonblockingthreads;
    DWORD           sv598_blockingthreads;
    DWORD           sv598_producttype;
    DWORD           sv598_serversize;
    DWORD           sv598_connectionlessautodisc;
    DWORD           sv598_sharingviolationretries;
    DWORD           sv598_sharingviolationdelay;
    DWORD           sv598_maxglobalopensearch;
    DWORD           sv598_removeduplicatesearches;
    DWORD           sv598_lockviolationoffset;
    DWORD           sv598_lockviolationdelay;
    DWORD           sv598_mdlreadswitchover;
    DWORD           sv598_reserved4;
    DWORD           sv598_reserved5;
    DWORD           sv598_reserved6;
    DWORD           sv598_reserved7;
    DWORD           sv598_reserved8;
    DWORD           sv598_reserved9;
    DWORD           sv598_reserved10;
} SERVER_INFO_598, *PSERVER_INFO_598, *LPSERVER_INFO_598;

typedef struct _SERVER_INFO_1005 {
    LPTSTR          sv1005_comment;
} SERVER_INFO_1005, *PSERVER_INFO_1005, *LPSERVER_INFO_1005;

typedef struct _SERVER_INFO_1107 {
    DWORD           sv1107_users;
} SERVER_INFO_1107, *PSERVER_INFO_1107, *LPSERVER_INFO_1107;

typedef struct _SERVER_INFO_1010 {
    LONG            sv1010_disc;
} SERVER_INFO_1010, *PSERVER_INFO_1010, *LPSERVER_INFO_1010;

typedef struct _SERVER_INFO_1016 {
    BOOL            sv1016_hidden;
} SERVER_INFO_1016, *PSERVER_INFO_1016, *LPSERVER_INFO_1016;

typedef struct _SERVER_INFO_1017 {
    DWORD           sv1017_announce;
} SERVER_INFO_1017, *PSERVER_INFO_1017, *LPSERVER_INFO_1017;

typedef struct _SERVER_INFO_1018 {
    DWORD           sv1018_anndelta;
} SERVER_INFO_1018, *PSERVER_INFO_1018, *LPSERVER_INFO_1018;

typedef struct _SERVER_INFO_1501 {
    DWORD           sv1501_sessopens;
} SERVER_INFO_1501, *PSERVER_INFO_1501, *LPSERVER_INFO_1501;

typedef struct _SERVER_INFO_1502 {
    DWORD           sv1502_sessvcs;
} SERVER_INFO_1502, *PSERVER_INFO_1502, *LPSERVER_INFO_1502;

typedef struct _SERVER_INFO_1503 {
    DWORD           sv1503_opensearch;
} SERVER_INFO_1503, *PSERVER_INFO_1503, *LPSERVER_INFO_1503;

typedef struct _SERVER_INFO_1506 {
    DWORD           sv1506_maxworkitems;
} SERVER_INFO_1506, *PSERVER_INFO_1506, *LPSERVER_INFO_1506;

typedef struct _SERVER_INFO_1509 {
    DWORD           sv1509_maxrawbuflen;
} SERVER_INFO_1509, *PSERVER_INFO_1509, *LPSERVER_INFO_1509;

typedef struct _SERVER_INFO_1510 {
    DWORD           sv1510_sessusers;
} SERVER_INFO_1510, *PSERVER_INFO_1510, *LPSERVER_INFO_1510;

typedef struct _SERVER_INFO_1511 {
    DWORD           sv1511_sessconns;
} SERVER_INFO_1511, *PSERVER_INFO_1511, *LPSERVER_INFO_1511;

typedef struct _SERVER_INFO_1512 {
    DWORD           sv1512_maxnonpagedmemoryusage;
} SERVER_INFO_1512, *PSERVER_INFO_1512, *LPSERVER_INFO_1512;

typedef struct _SERVER_INFO_1513 {
    DWORD           sv1513_maxpagedmemoryusage;
} SERVER_INFO_1513, *PSERVER_INFO_1513, *LPSERVER_INFO_1513;

typedef struct _SERVER_INFO_1514 {
    BOOL            sv1514_enablesoftcompat;
} SERVER_INFO_1514, *PSERVER_INFO_1514, *LPSERVER_INFO_1514;

typedef struct _SERVER_INFO_1515 {
    BOOL            sv1515_enableforcedlogoff;
} SERVER_INFO_1515, *PSERVER_INFO_1515, *LPSERVER_INFO_1515;

typedef struct _SERVER_INFO_1516 {
    BOOL            sv1516_timesource;
} SERVER_INFO_1516, *PSERVER_INFO_1516, *LPSERVER_INFO_1516;

typedef struct _SERVER_INFO_1518 {
    BOOL            sv1518_lmannounce;
} SERVER_INFO_1518, *PSERVER_INFO_1518, *LPSERVER_INFO_1518;

typedef struct _SERVER_INFO_1520 {
    DWORD           sv1520_maxcopyreadlen;
} SERVER_INFO_1520, *PSERVER_INFO_1520, *LPSERVER_INFO_1520;

typedef struct _SERVER_INFO_1521 {
    DWORD           sv1521_maxcopywritelen;
} SERVER_INFO_1521, *PSERVER_INFO_1521, *LPSERVER_INFO_1521;

typedef struct _SERVER_INFO_1522 {
    DWORD           sv1522_minkeepsearch;
} SERVER_INFO_1522, *PSERVER_INFO_1522, *LPSERVER_INFO_1522;

typedef struct _SERVER_INFO_1523 {
    DWORD           sv1523_maxkeepsearch;
} SERVER_INFO_1523, *PSERVER_INFO_1523, *LPSERVER_INFO_1523;

typedef struct _SERVER_INFO_1524 {
    DWORD           sv1524_minkeepcomplsearch;
} SERVER_INFO_1524, *PSERVER_INFO_1524, *LPSERVER_INFO_1524;

typedef struct _SERVER_INFO_1525 {
    DWORD           sv1525_maxkeepcomplsearch;
} SERVER_INFO_1525, *PSERVER_INFO_1525, *LPSERVER_INFO_1525;

typedef struct _SERVER_INFO_1528 {
    DWORD           sv1528_scavtimeout;
} SERVER_INFO_1528, *PSERVER_INFO_1528, *LPSERVER_INFO_1528;

typedef struct _SERVER_INFO_1529 {
    DWORD           sv1529_minrcvqueue;
} SERVER_INFO_1529, *PSERVER_INFO_1529, *LPSERVER_INFO_1529;

typedef struct _SERVER_INFO_1530 {
    DWORD           sv1530_minfreeworkitems;
} SERVER_INFO_1530, *PSERVER_INFO_1530, *LPSERVER_INFO_1530;

typedef struct _SERVER_INFO_1533 {
    DWORD           sv1533_maxmpxct;
} SERVER_INFO_1533, *PSERVER_INFO_1533, *LPSERVER_INFO_1533;

typedef struct _SERVER_INFO_1534 {
    DWORD           sv1534_oplockbreakwait;
} SERVER_INFO_1534, *PSERVER_INFO_1534, *LPSERVER_INFO_1534;

typedef struct _SERVER_INFO_1535 {
    DWORD           sv1535_oplockbreakresponsewait;
} SERVER_INFO_1535, *PSERVER_INFO_1535, *LPSERVER_INFO_1535;

typedef struct _SERVER_INFO_1536 {
    BOOL            sv1536_enableoplocks;
} SERVER_INFO_1536, *PSERVER_INFO_1536, *LPSERVER_INFO_1536;

typedef struct _SERVER_INFO_1537 {
    BOOL            sv1537_enableoplockforceclose;
} SERVER_INFO_1537, *PSERVER_INFO_1537, *LPSERVER_INFO_1537;

typedef struct _SERVER_INFO_1538 {
    BOOL            sv1538_enablefcbopens;
} SERVER_INFO_1538, *PSERVER_INFO_1538, *LPSERVER_INFO_1538;

typedef struct _SERVER_INFO_1539 {
    BOOL            sv1539_enableraw;
} SERVER_INFO_1539, *PSERVER_INFO_1539, *LPSERVER_INFO_1539;

typedef struct _SERVER_INFO_1540 {
    BOOL            sv1540_enablesharednetdrives;
} SERVER_INFO_1540, *PSERVER_INFO_1540, *LPSERVER_INFO_1540;

typedef struct _SERVER_INFO_1541 {
    BOOL            sv1541_minfreeconnections;
} SERVER_INFO_1541, *PSERVER_INFO_1541, *LPSERVER_INFO_1541;

typedef struct _SERVER_INFO_1542 {
    BOOL            sv1542_maxfreeconnections;
} SERVER_INFO_1542, *PSERVER_INFO_1542, *LPSERVER_INFO_1542;

typedef struct _SERVER_INFO_1543 {
    DWORD           sv1543_initsesstable;
} SERVER_INFO_1543, *PSERVER_INFO_1543, *LPSERVER_INFO_1543;

typedef struct _SERVER_INFO_1544 {
    DWORD           sv1544_initconntable;
} SERVER_INFO_1544, *PSERVER_INFO_1544, *LPSERVER_INFO_1544;

typedef struct _SERVER_INFO_1545 {
    DWORD           sv1545_initfiletable;
} SERVER_INFO_1545, *PSERVER_INFO_1545, *LPSERVER_INFO_1545;

typedef struct _SERVER_INFO_1546 {
    DWORD           sv1546_initsearchtable;
} SERVER_INFO_1546, *PSERVER_INFO_1546, *LPSERVER_INFO_1546;

typedef struct _SERVER_INFO_1547 {
    DWORD           sv1547_alertschedule;
} SERVER_INFO_1547, *PSERVER_INFO_1547, *LPSERVER_INFO_1547;

typedef struct _SERVER_INFO_1548 {
    DWORD           sv1548_errorthreshold;
} SERVER_INFO_1548, *PSERVER_INFO_1548, *LPSERVER_INFO_1548;

typedef struct _SERVER_INFO_1549 {
    DWORD           sv1549_networkerrorthreshold;
} SERVER_INFO_1549, *PSERVER_INFO_1549, *LPSERVER_INFO_1549;

typedef struct _SERVER_INFO_1550 {
    DWORD           sv1550_diskspacethreshold;
} SERVER_INFO_1550, *PSERVER_INFO_1550, *LPSERVER_INFO_1550;

typedef struct _SERVER_INFO_1552 {
    DWORD           sv1552_maxlinkdelay;
} SERVER_INFO_1552, *PSERVER_INFO_1552, *LPSERVER_INFO_1552;

typedef struct _SERVER_INFO_1553 {
    DWORD           sv1553_minlinkthroughput;
} SERVER_INFO_1553, *PSERVER_INFO_1553, *LPSERVER_INFO_1553;

typedef struct _SERVER_INFO_1554 {
    DWORD           sv1554_linkinfovalidtime;
} SERVER_INFO_1554, *PSERVER_INFO_1554, *LPSERVER_INFO_1554;

typedef struct _SERVER_INFO_1555 {
    DWORD           sv1555_scavqosinfoupdatetime;
} SERVER_INFO_1555, *PSERVER_INFO_1555, *LPSERVER_INFO_1555;

typedef struct _SERVER_INFO_1556 {
    DWORD           sv1556_maxworkitemidletime;
} SERVER_INFO_1556, *PSERVER_INFO_1556, *LPSERVER_INFO_1556;

typedef struct _SERVER_INFO_1557 {
    DWORD           sv1557_maxrawworkitems;
} SERVER_INFO_1557, *PSERVER_INFO_1557, *LPSERVER_INFO_1557;

typedef struct _SERVER_INFO_1558 {
    DWORD           sv1558_nonblockingthreads;
} SERVER_INFO_1558, *PSERVER_INFO_1558, *LPSERVER_INFO_1558;

typedef struct _SERVER_INFO_1559 {
    DWORD           sv1559_blockingthreads;
} SERVER_INFO_1559, *PSERVER_INFO_1559, *LPSERVER_INFO_1559;

typedef struct _SERVER_INFO_1560 {
    DWORD           sv1560_producttype;
} SERVER_INFO_1560, *PSERVER_INFO_1560, *LPSERVER_INFO_1560;

typedef struct _SERVER_INFO_1561 {
    DWORD           sv1561_serversize;
} SERVER_INFO_1561, *PSERVER_INFO_1561, *LPSERVER_INFO_1561;

typedef struct _SERVER_INFO_1562 {
    DWORD           sv1562_connectionlessautodisc;
} SERVER_INFO_1562, *PSERVER_INFO_1562, *LPSERVER_INFO_1562;

typedef struct _SERVER_INFO_1563 {
    DWORD           sv1563_sharingviolationretries;
} SERVER_INFO_1563, *PSERVER_INFO_1563, *LPSERVER_INFO_1563;

typedef struct _SERVER_INFO_1564 {
    DWORD           sv1564_sharingviolationdelay;
} SERVER_INFO_1564, *PSERVER_INFO_1564, *LPSERVER_INFO_1564;

typedef struct _SERVER_INFO_1565 {
    DWORD           sv1565_maxglobalopensearch;
} SERVER_INFO_1565, *PSERVER_INFO_1565, *LPSERVER_INFO_1565;

typedef struct _SERVER_INFO_1566 {
    BOOL           sv1566_removeduplicatesearches;
} SERVER_INFO_1566, *PSERVER_INFO_1566, *LPSERVER_INFO_1566;

typedef struct _SERVER_INFO_1567 {
    DWORD           sv1567_lockviolationretries;
} SERVER_INFO_1567, *PSERVER_INFO_1567, *LPSERVER_INFO_1567;

typedef struct _SERVER_INFO_1568 {
    DWORD           sv1568_lockviolationoffset;
} SERVER_INFO_1568, *PSERVER_INFO_1568, *LPSERVER_INFO_1568;

typedef struct _SERVER_INFO_1569 {
    DWORD           sv1569_lockviolationdelay;
} SERVER_INFO_1569, *PSERVER_INFO_1569, *LPSERVER_INFO_1569;

typedef struct _SERVER_INFO_1570 {
    DWORD           sv1570_mdlreadswitchover;
} SERVER_INFO_1570, *PSERVER_INFO_1570, *LPSERVER_INFO_1570;

//
// A special structure definition is required in order for this
// structure to work with RPC.  The problem is that having addresslength
// indicate the number of bytes in address means that RPC must know the
// link between the two.
//

#ifdef MIDL_PASS

typedef struct _SERVER_TRANSPORT_INFO_0 {
    DWORD           svti0_numberofvcs;
    LPTSTR          svti0_transportname;
    [size_is(svti0_transportaddresslength)]  LPBYTE svti0_transportaddress;
    DWORD           svti0_transportaddresslength;
    LPTSTR          svti0_networkaddress;
} SERVER_TRANSPORT_INFO_0, *PSERVER_TRANSPORT_INFO_0, *LPSERVER_TRANSPORT_INFO_0;

#else

typedef struct _SERVER_TRANSPORT_INFO_0 {
    DWORD           svti0_numberofvcs;
    LPTSTR          svti0_transportname;
    LPBYTE          svti0_transportaddress;
    DWORD           svti0_transportaddresslength;
    LPTSTR          svti0_networkaddress;
} SERVER_TRANSPORT_INFO_0, *PSERVER_TRANSPORT_INFO_0, *LPSERVER_TRANSPORT_INFO_0;

#endif

//
// Defines - SERVER
//

//
// The platform ID indicates the levels to use for platform-specific
// information.
//

#define SV_PLATFORM_ID_OS2 400
#define SV_PLATFORM_ID_NT  500

//
//      Mask to be applied to svX_version_major in order to obtain
//      the major version number.
//

#define MAJOR_VERSION_MASK  0x0F

//
//      Bit-mapped values for svX_type fields. X = 1, 2 or 3.
//

#define SV_TYPE_WORKSTATION         0x00000001
#define SV_TYPE_SERVER              0x00000002
#define SV_TYPE_SQLSERVER           0x00000004
#define SV_TYPE_DOMAIN_CTRL         0x00000008
#define SV_TYPE_DOMAIN_BAKCTRL      0x00000010
#define SV_TYPE_TIME_SOURCE         0x00000020
#define SV_TYPE_AFP                 0x00000040
#define SV_TYPE_NOVELL              0x00000080
#define SV_TYPE_DOMAIN_MEMBER       0x00000100
#define SV_TYPE_PRINTQ_SERVER       0x00000200
#define SV_TYPE_DIALIN_SERVER       0x00000400
#define SV_TYPE_XENIX_SERVER        0x00000800
#define SV_TYPE_SERVER_UNIX         SV_TYPE_XENIX_SERVER
#define SV_TYPE_NT                  0x00001000
#define SV_TYPE_WFW                 0x00002000
#define SV_TYPE_POTENTIAL_BROWSER   0x00010000
#define SV_TYPE_BACKUP_BROWSER      0x00020000
#define SV_TYPE_MASTER_BROWSER      0x00040000
#define SV_TYPE_DOMAIN_MASTER       0x00080000
#define SV_TYPE_SERVER_OSF          0x00100000
#define SV_TYPE_SERVER_VMS          0x00200000
#define SV_TYPE_ALTERNATE_XPORT     0x20000000  /* return list for alternate transport */
#define SV_TYPE_LOCAL_LIST_ONLY     0x40000000  /* Return local list only */
#define SV_TYPE_DOMAIN_ENUM         0x80000000
#define SV_TYPE_ALL                 0xFFFFFFFF  /* handy for NetServerEnum2 */

//
//      Special value for sv102_disc that specifies infinite disconnect
//      time.
//

#define SV_NODISC           (-1L)  /* No autodisconnect timeout enforced */

//
//      Values of svX_security field. X = 2 or 3.
//

#define SV_USERSECURITY     1
#define SV_SHARESECURITY    0

//
//      Values of svX_hidden field. X = 2 or 3.
//

#define SV_HIDDEN       1
#define SV_VISIBLE      0

//
//      Values for ParmError parameter to NetServerSetInfo.
//

#define SV_PLATFORM_ID_PARMNUM          101
#define SV_NAME_PARMNUM                 102
#define SV_VERSION_MAJOR_PARMNUM        103
#define SV_VERSION_MINOR_PARMNUM        104
#define SV_TYPE_PARMNUM                 105
#define SV_COMMENT_PARMNUM              5
#define SV_USERS_PARMNUM                107
#define SV_DISC_PARMNUM                 10
#define SV_HIDDEN_PARMNUM               16
#define SV_ANNOUNCE_PARMNUM             17
#define SV_ANNDELTA_PARMNUM             18
#define SV_USERPATH_PARMNUM             112

#define SV_ULIST_MTIME_PARMNUM          401
#define SV_GLIST_MTIME_PARMNUM          402
#define SV_ALIST_MTIME_PARMNUM          403
#define SV_ALERTS_PARMNUM               11
#define SV_SECURITY_PARMNUM             405
#define SV_NUMADMIN_PARMNUM             406
#define SV_LANMASK_PARMNUM              407
#define SV_GUESTACC_PARMNUM             408
#define SV_CHDEVQ_PARMNUM               410
#define SV_CHDEVJOBS_PARMNUM            411
#define SV_CONNECTIONS_PARMNUM          412
#define SV_SHARES_PARMNUM               413
#define SV_OPENFILES_PARMNUM            414
#define SV_SESSREQS_PARMNUM             417
#define SV_ACTIVELOCKS_PARMNUM          419
#define SV_NUMREQBUF_PARMNUM            420
#define SV_NUMBIGBUF_PARMNUM            422
#define SV_NUMFILETASKS_PARMNUM         423
#define SV_ALERTSCHED_PARMNUM           37
#define SV_ERRORALERT_PARMNUM           38
#define SV_LOGONALERT_PARMNUM           39
#define SV_ACCESSALERT_PARMNUM          40
#define SV_DISKALERT_PARMNUM            41
#define SV_NETIOALERT_PARMNUM           42
#define SV_MAXAUDITSZ_PARMNUM           43
#define SV_SRVHEURISTICS_PARMNUM        431

#define SV_SESSOPENS_PARMNUM                501
#define SV_SESSVCS_PARMNUM                  502
#define SV_OPENSEARCH_PARMNUM               503
#define SV_SIZREQBUF_PARMNUM                504
#define SV_INITWORKITEMS_PARMNUM            505
#define SV_MAXWORKITEMS_PARMNUM             506
#define SV_RAWWORKITEMS_PARMNUM             507
#define SV_IRPSTACKSIZE_PARMNUM             508
#define SV_MAXRAWBUFLEN_PARMNUM             509
#define SV_SESSUSERS_PARMNUM                510
#define SV_SESSCONNS_PARMNUM                511
#define SV_MAXNONPAGEDMEMORYUSAGE_PARMNUM   512
#define SV_MAXPAGEDMEMORYUSAGE_PARMNUM      513
#define SV_ENABLESOFTCOMPAT_PARMNUM         514
#define SV_ENABLEFORCEDLOGOFF_PARMNUM       515
#define SV_TIMESOURCE_PARMNUM               516
#define SV_ACCEPTDOWNLEVELAPIS_PARMNUM      517
#define SV_LMANNOUNCE_PARMNUM               518
#define SV_DOMAIN_PARMNUM                   519
#define SV_MAXCOPYREADLEN_PARMNUM           520
#define SV_MAXCOPYWRITELEN_PARMNUM          521
#define SV_MINKEEPSEARCH_PARMNUM            522
#define SV_MAXKEEPSEARCH_PARMNUM            523
#define SV_MINKEEPCOMPLSEARCH_PARMNUM       524
#define SV_MAXKEEPCOMPLSEARCH_PARMNUM       525
#define SV_THREADCOUNTADD_PARMNUM           526
#define SV_NUMBLOCKTHREADS_PARMNUM          527
#define SV_SCAVTIMEOUT_PARMNUM              528
#define SV_MINRCVQUEUE_PARMNUM              529
#define SV_MINFREEWORKITEMS_PARMNUM         530
#define SV_XACTMEMSIZE_PARMNUM              531
#define SV_THREADPRIORITY_PARMNUM           532
#define SV_MAXMPXCT_PARMNUM                 533
#define SV_OPLOCKBREAKWAIT_PARMNUM          534
#define SV_OPLOCKBREAKRESPONSEWAIT_PARMNUM  535
#define SV_ENABLEOPLOCKS_PARMNUM            536
#define SV_ENABLEOPLOCKFORCECLOSE_PARMNUM   537
#define SV_ENABLEFCBOPENS_PARMNUM           538
#define SV_ENABLERAW_PARMNUM                539
#define SV_ENABLESHAREDNETDRIVES_PARMNUM    540
#define SV_MINFREECONNECTIONS_PARMNUM       541
#define SV_MAXFREECONNECTIONS_PARMNUM       542
#define SV_INITSESSTABLE_PARMNUM            543
#define SV_INITCONNTABLE_PARMNUM            544
#define SV_INITFILETABLE_PARMNUM            545
#define SV_INITSEARCHTABLE_PARMNUM          546
#define SV_ALERTSCHEDULE_PARMNUM            547
#define SV_ERRORTHRESHOLD_PARMNUM           548
#define SV_NETWORKERRORTHRESHOLD_PARMNUM    549
#define SV_DISKSPACETHRESHOLD_PARMNUM       550
#define SV_DISKCONFIGURATION_PARMNUM        551
#define SV_MAXLINKDELAY_PARMNUM             552
#define SV_MINLINKTHROUGHPUT_PARMNUM        553
#define SV_LINKINFOVALIDTIME_PARMNUM        554
#define SV_SCAVQOSINFOUPDATETIME_PARMNUM    555
#define SV_MAXWORKITEMIDLETIME_PARMNUM      556
#define SV_MAXRAWWORKITEMS_PARMNUM          557
#define SV_NONBLOCKINGTHREADS_PARMNUM       558
#define SV_BLOCKINGTHREADS_PARMNUM          559
#define SV_PRODUCTTYPE_PARMNUM              560
#define SV_SERVERSIZE_PARMNUM               561
#define SV_CONNECTIONLESSAUTODISC_PARMNUM   562
#define SV_SHARINGVIOLATIONRETRIES_PARMNUM  563
#define SV_SHARINGVIOLATIONDELAY_PARMNUM    564
#define SV_MAXGLOBALOPENSEARCH_PARMNUM      565
#define SV_REMOVEDUPLICATESEARCHES_PARMNUM  566
#define SV_LOCKVIOLATIONRETRIES_PARMNUM     567
#define SV_LOCKVIOLATIONOFFSET_PARMNUM      568
#define SV_LOCKVIOLATIONDELAY_PARMNUM       569
#define SV_MDLREADSWITCHOVER_PARMNUM        570

//
// Single-field infolevels for NetServerSetInfo.
//

#define SV_COMMENT_INFOLEVEL                    \
            (PARMNUM_BASE_INFOLEVEL + SV_COMMENT_PARMNUM)
#define SV_USERS_INFOLEVEL                      \
            (PARMNUM_BASE_INFOLEVEL + SV_USERS_PARMNUM)
#define SV_DISC_INFOLEVEL                       \
            (PARMNUM_BASE_INFOLEVEL + SV_DISC_PARMNUM)
#define SV_HIDDEN_INFOLEVEL                     \
            (PARMNUM_BASE_INFOLEVEL + SV_HIDDEN_PARMNUM)
#define SV_ANNOUNCE_INFOLEVEL                   \
            (PARMNUM_BASE_INFOLEVEL + SV_ANNOUNCE_PARMNUM)
#define SV_ANNDELTA_INFOLEVEL                   \
            (PARMNUM_BASE_INFOLEVEL + SV_ANNDELTA_PARMNUM)
#define SV_SESSOPENS_INFOLEVEL                  \
            (PARMNUM_BASE_INFOLEVEL + SV_SESSOPENS_PARMNUM)
#define SV_SESSVCS_INFOLEVEL                    \
            (PARMNUM_BASE_INFOLEVEL + SV_SESSVCS_PARMNUM)
#define SV_OPENSEARCH_INFOLEVEL                 \
            (PARMNUM_BASE_INFOLEVEL + SV_OPENSEARCH_PARMNUM)
#define SV_MAXWORKITEMS_INFOLEVEL               \
            (PARMNUM_BASE_INFOLEVEL + SV_MAXWORKITEMS_PARMNUM)
#define SV_MAXRAWBUFLEN_INFOLEVEL               \
            (PARMNUM_BASE_INFOLEVEL + SV_MAXRAWBUFLEN_PARMNUM)
#define SV_SESSUSERS_INFOLEVEL                  \
            (PARMNUM_BASE_INFOLEVEL + SV_SESSUSERS_PARMNUM)
#define SV_SESSCONNS_INFOLEVEL                  \
            (PARMNUM_BASE_INFOLEVEL + SV_SESSCONNS_PARMNUM)
#define SV_MAXNONPAGEDMEMORYUSAGE_INFOLEVEL     \
            (PARMNUM_BASE_INFOLEVEL + SV_MAXNONPAGEDMEMORYUSAGE_PARMNUM)
#define SV_MAXPAGEDMEMORYUSAGE_INFOLEVEL        \
            (PARMNUM_BASE_INFOLEVEL + SV_MAXPAGEDMEMORYUSAGE_PARMNUM)
#define SV_ENABLESOFTCOMPAT_INFOLEVEL           \
            (PARMNUM_BASE_INFOLEVEL + SV_ENABLESOFTCOMPAT_PARMNUM)
#define SV_ENABLEFORCEDLOGOFF_INFOLEVEL         \
            (PARMNUM_BASE_INFOLEVEL + SV_ENABLEFORCEDLOGOFF_PARMNUM)
#define SV_TIMESOURCE_INFOLEVEL                 \
            (PARMNUM_BASE_INFOLEVEL + SV_TIMESOURCE_PARMNUM)
#define SV_LMANNOUNCE_INFOLEVEL                 \
            (PARMNUM_BASE_INFOLEVEL + SV_LMANNOUNCE_PARMNUM)
#define SV_MAXCOPYREADLEN_INFOLEVEL             \
            (PARMNUM_BASE_INFOLEVEL + SV_MAXCOPYREADLEN_PARMNUM)
#define SV_MAXCOPYWRITELEN_INFOLEVEL            \
            (PARMNUM_BASE_INFOLEVEL + SV_MAXCOPYWRITELEN_PARMNUM)
#define SV_MINKEEPSEARCH_INFOLEVEL              \
            (PARMNUM_BASE_INFOLEVEL + SV_MINKEEPSEARCH_PARMNUM)
#define SV_MAXKEEPSEARCH_INFOLEVEL              \
            (PARMNUM_BASE_INFOLEVEL + SV_MAXKEEPSEARCH_PARMNUM)
#define SV_MINKEEPCOMPLSEARCH_INFOLEVEL         \
            (PARMNUM_BASE_INFOLEVEL + SV_MINKEEPCOMPLSEARCH_PARMNUM)
#define SV_MAXKEEPCOMPLSEARCH_INFOLEVEL         \
            (PARMNUM_BASE_INFOLEVEL + SV_MAXKEEPCOMPLSEARCH_PARMNUM)
#define SV_SCAVTIMEOUT_INFOLEVEL                \
            (PARMNUM_BASE_INFOLEVEL + SV_SCAVTIMEOUT_PARMNUM)
#define SV_MINRCVQUEUE_INFOLEVEL                \
            (PARMNUM_BASE_INFOLEVEL + SV_MINRCVQUEUE_PARMNUM)
#define SV_MINFREEWORKITEMS_INFOLEVEL           \
            (PARMNUM_BASE_INFOLEVEL + SV_MINFREEWORKITEMS_PARMNUM)
#define SV_MAXMPXCT_INFOLEVEL                   \
            (PARMNUM_BASE_INFOLEVEL + SV_MAXMPXCT_PARMNUM)
#define SV_OPLOCKBREAKWAIT_INFOLEVEL            \
            (PARMNUM_BASE_INFOLEVEL + SV_OPLOCKBREAKWAIT_PARMNUM)
#define SV_OPLOCKBREAKRESPONSEWAIT_INFOLEVEL    \
            (PARMNUM_BASE_INFOLEVEL + SV_OPLOCKBREAKRESPONSEWAIT_PARMNUM)
#define SV_ENABLEOPLOCKS_INFOLEVEL              \
            (PARMNUM_BASE_INFOLEVEL + SV_ENABLEOPLOCKS_PARMNUM)
#define SV_ENABLEOPLOCKFORCECLOSE_INFOLEVEL     \
            (PARMNUM_BASE_INFOLEVEL + SV_ENABLEOPLOCKFORCECLOSE_PARMNUM)
#define SV_ENABLEFCBOPENS_INFOLEVEL             \
            (PARMNUM_BASE_INFOLEVEL + SV_ENABLEFCBOPENS_PARMNUM)
#define SV_ENABLERAW_INFOLEVEL                  \
            (PARMNUM_BASE_INFOLEVEL + SV_ENABLERAW_PARMNUM)
#define SV_ENABLESHAREDNETDRIVES_INFOLEVEL      \
            (PARMNUM_BASE_INFOLEVEL + SV_ENABLESHAREDNETDRIVES_PARMNUM)
#define SV_MINFREECONNECTIONS_INFOLEVEL         \
            (PARMNUM_BASE_INFOLEVEL + SV_MINFREECONNECTIONS_PARMNUM)
#define SV_MAXFREECONNECTIONS_INFOLEVEL         \
            (PARMNUM_BASE_INFOLEVEL + SV_MAXFREECONNECTIONS_PARMNUM)
#define SV_INITSESSTABLE_INFOLEVEL              \
            (PARMNUM_BASE_INFOLEVEL + SV_INITSESSTABLE_PARMNUM)
#define SV_INITCONNTABLE_INFOLEVEL              \
            (PARMNUM_BASE_INFOLEVEL + SV_INITCONNTABLE_PARMNUM)
#define SV_INITFILETABLE_INFOLEVEL              \
            (PARMNUM_BASE_INFOLEVEL + SV_INITFILETABLE_PARMNUM)
#define SV_INITSEARCHTABLE_INFOLEVEL            \
            (PARMNUM_BASE_INFOLEVEL + SV_INITSEARCHTABLE_PARMNUM)
#define SV_ALERTSCHEDULE_INFOLEVEL              \
            (PARMNUM_BASE_INFOLEVEL + SV_ALERTSCHEDULE_PARMNUM)
#define SV_ERRORTHRESHOLD_INFOLEVEL             \
            (PARMNUM_BASE_INFOLEVEL + SV_ERRORTHRESHOLD_PARMNUM)
#define SV_NETWORKERRORTHRESHOLD_INFOLEVEL      \
            (PARMNUM_BASE_INFOLEVEL + SV_NETWORKERRORTHRESHOLD_PARMNUM)
#define SV_DISKSPACETHRESHOLD_INFOLEVEL         \
            (PARMNUM_BASE_INFOLEVEL + SV_DISKSPACETHRESHOLD_PARMNUM)
#define SV_MAXLINKDELAY_INFOLEVEL               \
            (PARMNUM_BASE_INFOLEVEL + SV_MAXLINKDELAY_PARMNUM)
#define SV_MINLINKTHROUGHPUT_INFOLEVEL          \
            (PARMNUM_BASE_INFOLEVEL + SV_MINLINKTHROUGHPUT_PARMNUM)
#define SV_LINKINFOVALIDTIME_INFOLEVEL          \
            (PARMNUM_BASE_INFOLEVEL + SV_LINKINFOVALIDTIME_PARMNUM)
#define SV_SCAVQOSINFOUPDATETIME_INFOLEVEL      \
            (PARMNUM_BASE_INFOLEVEL + SV_SCAVQOSINFOUPDATETIME_PARMNUM)
#define SV_MAXWORKITEMIDLETIME_INFOLEVEL        \
            (PARMNUM_BASE_INFOLEVEL + SV_MAXWORKITEMIDLETIME_PARMNUM)
#define SV_MAXRAWWORKITEMS_INFOLOEVEL           \
            (PARMNUM_BASE_INFOLEVEL + SV_MAXRAWWORKITEMS_PARMNUM)
#define SV_NONBLOCKINGTHREADS_INFOLOEVEL    \
            (PARMNUM_BASE_INFOLEVEL + SV_NONBLOCKINGTHREADS_PARMNUM)
#define SV_BLOCKINGTHREADS_INFOLOEVEL       \
            (PARMNUM_BASE_INFOLEVEL + SV_BLOCKINGTHREADS_PARMNUM)
#define SV_PRODUCTTYPE_INFOLOEVEL                \
            (PARMNUM_BASE_INFOLEVEL + SV_PRODUCTTYPE_PARMNUM)
#define SV_SERVERSIZE_INFOLOEVEL                \
            (PARMNUM_BASE_INFOLEVEL + SV_SERVERSIZE_PARMNUM)
#define SV_CONNECTIONLESSAUTODISC_INFOLOEVEL    \
            (PARMNUM_BASE_INFOLEVEL + SV_CONNECTIONLESSAUTODISC_PARMNUM)
#define SV_SHARINGVIOLATIONRETRIES_INFOLOEVEL   \
            (PARMNUM_BASE_INFOLEVEL + SV_SHARINGVIOLATIONRETRIES_PARMNUM)
#define SV_SHARINGVIOLATIONDELAY_INFOLOEVEL     \
            (PARMNUM_BASE_INFOLEVEL + SV_SHARINGVIOLATIONDELAY_PARMNUM)
#define SV_MAXGLOBALOPENSEARCH_INFOLOEVEL       \
            (PARMNUM_BASE_INFOLEVEL + SV_MAXGLOBALOPENSEARCH_PARMNUM)
#define SV_REMOVEDUPLICATESEARCHES_INFOLOEVEL       \
            (PARMNUM_BASE_INFOLEVEL + SV_REMOVEDUPLICATESEARCHES_PARMNUM)
#define SV_LOCKVIOLATIONRETRIES_INFOLOEVEL   \
            (PARMNUM_BASE_INFOLEVEL + SV_LOCKVIOLATIONRETRIES_PARMNUM)
#define SV_LOCKVIOLATIONOFFSET_INFOLOEVEL     \
            (PARMNUM_BASE_INFOLEVEL + SV_LOCKVIOLATIONOFFSET_PARMNUM)
#define SV_LOCKVIOLATIONDELAY_INFOLOEVEL     \
            (PARMNUM_BASE_INFOLEVEL + SV_LOCKVIOLATIONDELAY_PARMNUM)
#define SV_MDLREADSWITCHOVER_INFOLOEVEL     \
            (PARMNUM_BASE_INFOLEVEL + SV_MDLREADSWITCHOVER_PARMNUM)

#define SVI1_NUM_ELEMENTS       5
#define SVI2_NUM_ELEMENTS       40
#define SVI3_NUM_ELEMENTS       44

//
//      Maxmimum length for command string to NetServerAdminCommand.
//

#define SV_MAX_CMD_LEN          PATHLEN

//
//      Masks describing AUTOPROFILE parameters
//

#define SW_AUTOPROF_LOAD_MASK   0x1
#define SW_AUTOPROF_SAVE_MASK   0x2

//
//      Max size of svX_srvheuristics.
//

#define SV_MAX_SRV_HEUR_LEN     32      // Max heuristics info string length.

//
//      Equate for use with sv102_licenses.
//

#define SV_USERS_PER_LICENSE    5

#ifdef __cplusplus
}
#endif

#endif // _LMSERVER_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\tools\c932\inc\lmshare.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1990-1993  Microsoft Corporation

Module Name:

    lmshare.h

Abstract:

    This module defines the API function prototypes and data structures
    for the following groups of NT API functions:
        NetShare
        NetSession
        NetFile
        NetConnection

Author:

    Dan Lafferty (danl)  25-Jan-1991

Environment:

    User Mode - Win32

Notes:

    You must include <windef.h> and <lmcons.h> before this file.

Revision History:

    25-Jan-1991 Danl
        Ported from LM2.0
    14-Apr-1991 w-shanku
        Changed parmnum values to be more consistent with OS/2 parmnums.
    19-Jul-1991 JohnRo
        Added some OPTIONAL equates to NetConnectionEnum.
    20-Aug-1991 JohnRo
        Added some OPTIONAL equates to NetFile APIs.
        Changed LPSTR to LPTSTR.
    20-Nov-1991 JohnRo
        Implement remote NetSession APIs.  (Added OPTIONAL to NetSession APIs.)
        Clarify that client name (arg to NetSession APIs) is a UNC computer
        name, whereas the session info structures contain non-UNC names.

--*/

//
// SHARE API
//

#ifndef _LMSHARE_
#define _LMSHARE_

#ifdef __cplusplus
extern "C" {
#endif

//
// Function Prototypes - Share
//

NET_API_STATUS NET_API_FUNCTION
NetShareAdd (
    IN  LPTSTR  servername,
    IN  DWORD   level,
    IN  LPBYTE  buf,
    OUT LPDWORD parm_err
    );

NET_API_STATUS NET_API_FUNCTION
NetShareEnum (
    IN  LPTSTR      servername,
    IN  DWORD       level,
    OUT LPBYTE      *bufptr,
    IN  DWORD       prefmaxlen,
    OUT LPDWORD     entriesread,
    OUT LPDWORD     totalentries,
    IN OUT LPDWORD  resume_handle
    );

NET_API_STATUS NET_API_FUNCTION
NetShareEnumSticky (
    IN  LPTSTR      servername,
    IN  DWORD       level,
    OUT LPBYTE      *bufptr,
    IN  DWORD       prefmaxlen,
    OUT LPDWORD     entriesread,
    OUT LPDWORD     totalentries,
    IN OUT LPDWORD  resume_handle
    );

NET_API_STATUS NET_API_FUNCTION
NetShareGetInfo (
    IN  LPTSTR  servername,
    IN  LPTSTR  netname,
    IN  DWORD   level,
    OUT LPBYTE  *bufptr
    );

NET_API_STATUS NET_API_FUNCTION
NetShareSetInfo (
    IN  LPTSTR  servername,
    IN  LPTSTR  netname,
    IN  DWORD   level,
    IN  LPBYTE  buf,
    OUT LPDWORD parm_err
    );

NET_API_STATUS NET_API_FUNCTION
NetShareDel     (
    IN  LPTSTR  servername,
    IN  LPTSTR  netname,
    IN  DWORD   reserved
    );

NET_API_STATUS NET_API_FUNCTION
NetShareDelSticky (
    IN  LPTSTR  servername,
    IN  LPTSTR  netname,
    IN  DWORD   reserved
    );

NET_API_STATUS NET_API_FUNCTION
NetShareCheck   (
    IN  LPTSTR  servername,
    IN  LPTSTR  device,
    OUT LPDWORD type
    );

//
// Data Structures - Share
//

typedef struct _SHARE_INFO_0 {
    LPTSTR  shi0_netname;
} SHARE_INFO_0, *PSHARE_INFO_0, *LPSHARE_INFO_0;

typedef struct _SHARE_INFO_1 {
    LPTSTR  shi1_netname;
    DWORD   shi1_type;
    LPTSTR  shi1_remark;
} SHARE_INFO_1, *PSHARE_INFO_1, *LPSHARE_INFO_1;

typedef struct _SHARE_INFO_2 {
    LPTSTR  shi2_netname;
    DWORD   shi2_type;
    LPTSTR  shi2_remark;
    DWORD   shi2_permissions;
    DWORD   shi2_max_uses;
    DWORD   shi2_current_uses;
    LPTSTR  shi2_path;
    LPTSTR  shi2_passwd;
} SHARE_INFO_2, *PSHARE_INFO_2, *LPSHARE_INFO_2;

typedef struct _SHARE_INFO_502 {
    LPTSTR  shi502_netname;
    DWORD   shi502_type;
    LPTSTR  shi502_remark;
    DWORD   shi502_permissions;
    DWORD   shi502_max_uses;
    DWORD   shi502_current_uses;
    LPTSTR  shi502_path;
    LPTSTR  shi502_passwd;
    DWORD   shi502_reserved;
    PSECURITY_DESCRIPTOR  shi502_security_descriptor;
} SHARE_INFO_502, *PSHARE_INFO_502, *LPSHARE_INFO_502;

typedef struct _SHARE_INFO_1004 {
    LPTSTR  shi1004_remark;
} SHARE_INFO_1004, *PSHARE_INFO_1004, *LPSHARE_INFO_1004;

typedef struct _SHARE_INFO_1006 {
    DWORD   shi1006_max_uses;
} SHARE_INFO_1006, *PSHARE_INFO_1006, *LPSHARE_INFO_1006;

typedef struct _SHARE_INFO_1501 {
    DWORD   shi1501_reserved;
    PSECURITY_DESCRIPTOR  shi1501_security_descriptor;
} SHARE_INFO_1501, *PSHARE_INFO_1501, *LPSHARE_INFO_1501;

//
// Special Values and Constants - Share
//

//
// Values for parm_err parameter.
//

#define SHARE_NETNAME_PARMNUM         1
#define SHARE_TYPE_PARMNUM            3
#define SHARE_REMARK_PARMNUM          4
#define SHARE_PERMISSIONS_PARMNUM     5
#define SHARE_MAX_USES_PARMNUM        6
#define SHARE_CURRENT_USES_PARMNUM    7
#define SHARE_PATH_PARMNUM            8
#define SHARE_PASSWD_PARMNUM          9
#define SHARE_FILE_SD_PARMNUM       501

//
// Single-field infolevels for NetShareSetInfo.
//

#define SHARE_REMARK_INFOLEVEL          \
            (PARMNUM_BASE_INFOLEVEL + SHARE_REMARK_PARMNUM)
#define SHARE_MAX_USES_INFOLEVEL        \
            (PARMNUM_BASE_INFOLEVEL + SHARE_MAX_USES_PARMNUM)
#define SHARE_FILE_SD_INFOLEVEL         \
            (PARMNUM_BASE_INFOLEVEL + SHARE_FILE_SD_PARMNUM)

#define SHI1_NUM_ELEMENTS       4
#define SHI2_NUM_ELEMENTS       10


//
// Share types (shi1_type and shi2_type fields).
//

#define STYPE_DISKTREE          0
#define STYPE_PRINTQ            1
#define STYPE_DEVICE            2
#define STYPE_IPC               3
#define STYPE_DFS               100

#define STYPE_SPECIAL           0x80000000

#define SHI_USES_UNLIMITED      (DWORD)-1

#endif // _LMSHARE_

//
// SESSION API
//

#ifndef _LMSESSION_
#define _LMSESSION_

//
// Function Prototypes Session
//

NET_API_STATUS NET_API_FUNCTION
NetSessionEnum (
    IN  LPTSTR      servername OPTIONAL,
    IN  LPTSTR      UncClientName OPTIONAL,
    IN  LPTSTR      username OPTIONAL,
    IN  DWORD       level,
    OUT LPBYTE      *bufptr,
    IN  DWORD       prefmaxlen,
    OUT LPDWORD     entriesread,
    OUT LPDWORD     totalentries,
    IN OUT LPDWORD  resume_handle OPTIONAL
    );

NET_API_STATUS NET_API_FUNCTION
NetSessionDel (
    IN  LPTSTR      servername OPTIONAL,
    IN  LPTSTR      UncClientName,
    IN  LPTSTR      username
    );

NET_API_STATUS NET_API_FUNCTION
NetSessionGetInfo (
    IN  LPTSTR      servername OPTIONAL,
    IN  LPTSTR      UncClientName,
    IN  LPTSTR      username,
    IN  DWORD       level,
    OUT LPBYTE      *bufptr
    );


//
// Data Structures - Session
//

typedef struct _SESSION_INFO_0 {
    LPTSTR    sesi0_cname;              // client name (no backslashes)
} SESSION_INFO_0, *PSESSION_INFO_0, *LPSESSION_INFO_0;

typedef struct _SESSION_INFO_1 {
    LPTSTR    sesi1_cname;              // client name (no backslashes)
    LPTSTR    sesi1_username;
    DWORD     sesi1_num_opens;
    DWORD     sesi1_time;
    DWORD     sesi1_idle_time;
    DWORD     sesi1_user_flags;
} SESSION_INFO_1, *PSESSION_INFO_1, *LPSESSION_INFO_1;

typedef struct _SESSION_INFO_2 {
    LPTSTR    sesi2_cname;              // client name (no backslashes)
    LPTSTR    sesi2_username;
    DWORD     sesi2_num_opens;
    DWORD     sesi2_time;
    DWORD     sesi2_idle_time;
    DWORD     sesi2_user_flags;
    LPTSTR    sesi2_cltype_name;
} SESSION_INFO_2, *PSESSION_INFO_2, *LPSESSION_INFO_2;

typedef struct _SESSION_INFO_10 {
    LPTSTR    sesi10_cname;             // client name (no backslashes)
    LPTSTR    sesi10_username;
    DWORD     sesi10_time;
    DWORD     sesi10_idle_time;
} SESSION_INFO_10, *PSESSION_INFO_10, *LPSESSION_INFO_10;

typedef struct _SESSION_INFO_502 {
    LPTSTR    sesi502_cname;             // client name (no backslashes)
    LPTSTR    sesi502_username;
    DWORD     sesi502_num_opens;
    DWORD     sesi502_time;
    DWORD     sesi502_idle_time;
    DWORD     sesi502_user_flags;
    LPTSTR    sesi502_cltype_name;
    LPTSTR    sesi502_transport;
} SESSION_INFO_502, *PSESSION_INFO_502, *LPSESSION_INFO_502;


//
// Special Values and Constants - Session
//


//
// Bits defined in sesi1_user_flags.
//

#define SESS_GUEST          0x00000001  // session is logged on as a guest
#define SESS_NOENCRYPTION   0x00000002  // session is not using encryption

#define SESI1_NUM_ELEMENTS  8
#define SESI2_NUM_ELEMENTS  9

#endif // _LMSESSION_

//
// CONNECTION API
//

#ifndef _LMCONNECTION_

#define _LMCONNECTION_

//
// Function Prototypes - CONNECTION
//

NET_API_STATUS NET_API_FUNCTION
NetConnectionEnum (
    IN  LPTSTR  servername OPTIONAL,
    IN  LPTSTR  qualifier,
    IN  DWORD   level,
    OUT LPBYTE  *bufptr,
    IN  DWORD   prefmaxlen,
    OUT LPDWORD entriesread,
    OUT LPDWORD totalentries,
    IN OUT LPDWORD resume_handle OPTIONAL
    );

//
// Data Structures - CONNECTION
//

typedef struct _CONNECTION_INFO_0 {
    DWORD   coni0_id;
} CONNECTION_INFO_0, *PCONNECTION_INFO_0, *LPCONNECTION_INFO_0;

typedef struct _CONNECTION_INFO_1 {
    DWORD   coni1_id;
    DWORD   coni1_type;
    DWORD   coni1_num_opens;
    DWORD   coni1_num_users;
    DWORD   coni1_time;
    LPTSTR  coni1_username;
    LPTSTR  coni1_netname;
} CONNECTION_INFO_1, *PCONNECTION_INFO_1, *LPCONNECTION_INFO_1;

#endif // _LMCONNECTION_

//
// FILE API
//

#ifndef _LMFILE_
#define _LMFILE_

//
// Function Prototypes - FILE
//

NET_API_STATUS NET_API_FUNCTION
NetFileClose (
    IN LPTSTR   servername OPTIONAL,
    IN DWORD    fileid
    );

NET_API_STATUS NET_API_FUNCTION
NetFileEnum (
    IN  LPTSTR      servername OPTIONAL,
    IN  LPTSTR      basepath OPTIONAL,
    IN  LPTSTR      username OPTIONAL,
    IN  DWORD       level,
    OUT LPBYTE      *bufptr,
    IN  DWORD       prefmaxlen,
    OUT LPDWORD     entriesread,
    OUT LPDWORD     totalentries,
    IN OUT LPDWORD  resume_handle OPTIONAL
    );

NET_API_STATUS NET_API_FUNCTION
NetFileGetInfo (
    IN  LPTSTR  servername OPTIONAL,
    IN  DWORD   fileid,
    IN  DWORD   level,
    OUT LPBYTE  *bufptr
    );

//
// Data Structures - File
//

//  File APIs are available at information levels 2 & 3 only. Levels 0 &
//  1 are not supported.
//

typedef struct _FILE_INFO_2 {
    DWORD     fi2_id;
} FILE_INFO_2, *PFILE_INFO_2, *LPFILE_INFO_2;

typedef struct _FILE_INFO_3 {
    DWORD     fi3_id;
    DWORD     fi3_permissions;
    DWORD     fi3_num_locks;
    LPTSTR    fi3_pathname;
    LPTSTR    fi3_username;
} FILE_INFO_3, *PFILE_INFO_3, *LPFILE_INFO_3;

//
// Special Values and Constants - File
//

//
// bit values for permissions
//

#define PERM_FILE_READ      0x1 // user has read access
#define PERM_FILE_WRITE     0x2 // user has write access
#define PERM_FILE_CREATE    0x4 // user has create access

#ifdef __cplusplus
}
#endif

#endif // _LMFILE_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\tools\c932\inc\lmuseflg.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1991-1993  Microsoft Corporation

Module Name:

    lmuseflg.h

Abstract:

    This file contains deletion force levels for deleting a connection.

Author:

    Rita Wong (ritaw) 16-June-1991

Environment:

    User Mode - Win32

Notes:

    This file has no dependencies.  It is included by lmwksta.h and
    lmuse.h.

Revision History:

--*/

#ifndef _LMUSEFLG_
#define _LMUSEFLG_

//
// Definition for NetWkstaTransportDel and NetUseDel deletion force levels
//

#define USE_NOFORCE             0
#define USE_FORCE               1
#define USE_LOTS_OF_FORCE       2


#endif // _LMUSEFLG_

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\tools\c932\inc\lmuse.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1991-1993  Microsoft Corporation

Module Name:

    lmuse.c

Abstract:

    This file contains structures, function prototypes, and definitions
    for the NetUse API.

Author:

    Dan Lafferty (danl) 10-Mar-1991


Environment:

    User Mode - Win32
    Portable to any flat, 32-bit environment.  (Uses Win32 typedefs.)
    Requires ANSI C extensions: slash-slash comments, long external names.

Notes:

    You must include NETCONS.H before this file, since this file depends
    on values defined in NETCONS.H.

Revision History:

    10-Mar-1991 danl
        Created from LM2.0 header files and NT-LAN API Spec.
    14-Mar-91 JohnRo
        Put OPTIONAL keywords back in.
    19-Mar-91 ritaw
        Added info structure for level 2, and indicies to the parameters in
        this info structure.
    10-Apr-1991 JohnRo
        Clarify argument names for NetpSetParmError use.
    12-Jun-1991 JohnRo
        Changed to use UNICODE types.  Clarify parameter names.

--*/

#ifndef _LMUSE_
#define _LMUSE_

#ifdef __cplusplus
extern "C" {
#endif

#include <lmuseflg.h>                   // Deletion force level flags

//
// Function Prototypes
//

NET_API_STATUS NET_API_FUNCTION
NetUseAdd (
    IN LPTSTR UncServerName OPTIONAL,
    IN DWORD Level,
    IN LPBYTE Buf,
    OUT LPDWORD ParmError OPTIONAL
    );

NET_API_STATUS NET_API_FUNCTION
NetUseDel (
    IN LPTSTR UncServerName OPTIONAL,
    IN LPTSTR UseName,
    IN DWORD ForceCond
    );

NET_API_STATUS NET_API_FUNCTION
NetUseEnum (
    IN LPTSTR UncServerName OPTIONAL,
    IN DWORD Level,
    OUT LPBYTE *BufPtr,
    IN DWORD PreferedMaximumSize,
    OUT LPDWORD EntriesRead,
    OUT LPDWORD TotalEntries,
    IN OUT LPDWORD ResumeHandle
    );

NET_API_STATUS NET_API_FUNCTION
NetUseGetInfo (
    IN LPTSTR UncServerName OPTIONAL,
    IN LPTSTR UseName,
    IN DWORD Level,
    OUT LPBYTE *BufPtr
    );

//
//  Data Structures
//

typedef struct _USE_INFO_0 {
    LPTSTR  ui0_local;
    LPTSTR  ui0_remote;
}USE_INFO_0, *PUSE_INFO_0, *LPUSE_INFO_0;

typedef struct _USE_INFO_1 {
    LPTSTR  ui1_local;
    LPTSTR  ui1_remote;
    LPTSTR  ui1_password;
    DWORD   ui1_status;
    DWORD   ui1_asg_type;
    DWORD   ui1_refcount;
    DWORD   ui1_usecount;
}USE_INFO_1, *PUSE_INFO_1, *LPUSE_INFO_1;

typedef struct _USE_INFO_2 {
    LPTSTR   ui2_local;
    LPTSTR   ui2_remote;
    LPTSTR   ui2_password;
    DWORD    ui2_status;
    DWORD    ui2_asg_type;
    DWORD    ui2_refcount;
    DWORD    ui2_usecount;
    LPTSTR   ui2_username;
    LPTSTR   ui2_domainname;
}USE_INFO_2, *PUSE_INFO_2, *LPUSE_INFO_2;


//
// Special Values and Constants
//

//
// One of these values indicates the parameter within an information
// structure that is invalid when ERROR_INVALID_PARAMETER is returned by
// NetUseAdd.
//

#define USE_LOCAL_PARMNUM       1
#define USE_REMOTE_PARMNUM      2
#define USE_PASSWORD_PARMNUM    3
#define USE_ASGTYPE_PARMNUM     4
#define USE_USERNAME_PARMNUM    5
#define USE_DOMAINNAME_PARMNUM  6

//
// Values appearing in the ui1_status field of use_info_1 structure.
// Note that USE_SESSLOST and USE_DISCONN are synonyms.
//

#define USE_OK                  0
#define USE_PAUSED              1
#define USE_SESSLOST            2
#define USE_DISCONN             2
#define USE_NETERR              3
#define USE_CONN                4
#define USE_RECONN              5


//
// Values of the ui1_asg_type field of use_info_1 structure
//

#define USE_WILDCARD            ( (DWORD) (-1) )
#define USE_DISKDEV             0
#define USE_SPOOLDEV            1
#define USE_CHARDEV             2
#define USE_IPC                 3

#ifdef __cplusplus
}
#endif

#endif // _LMUSE_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\tools\c932\inc\lmsvc.h ===
/*++ BUILD Version: 0002    // Increment this if a change has global effects

Copyright (c) 1991-1993  Microsoft Corporation

Module Name:

    lmsvc.h

Abstract:

    This file contains structures, function prototypes, and definitions
    for the NetService API.

Author:

    Dan Lafferty (danl)     08-Mar-1991

[Environment:]

    User Mode -Win32

[Notes:]

    You must include NETCONS.H before this file, since this file depends
    on values defined in NETCONS.H.

Revision History:

    10-Mar-1991     danl
        Created from LM2.0 header files and NT-LAN API Spec.
    29-Jul-1991  DanHi
        Change comments after manifest constants for error messages to a format
        that is recognized by mapmsg.exe
    06-Sep-1991 JohnRo
        Added OPTIONAL keywords as applicable.
    16-Sep-1991 CliffV
        Added TEXT() around SERVICE_ service named.
        Added Netlogon specific uninstall codes.
    16-Sep-1991 JohnRo
        Correct UNICODE use of SERVICE_ENCRYPT.
    25-Sep-1991 CliffV
        Added SERVICE2_BASE and SERVICE_UIC_M_NETLOGON_PATH from LM 2.1.
    14-Feb-1992 RitaW
        Moved service name strings to lmsname.h.
    02-Jun-1992 JohnRo
        RAID 9829: Avoid winsvc.h compiler warnings.
    31-Mar-1993 Danl
        Used upper bits in the code field to extend the max possible waithint
        to FFFF.  Created macros for accessing this.  (SERVICE_NT...).

--*/

#ifndef _LMSVC_
#define _LMSVC_

#ifdef __cplusplus
extern "C" {
#endif

//
// Include the file which contains all the service name strings.
//
#include <lmsname.h>

//
//  Data Structures
//

typedef struct _SERVICE_INFO_0 {
    LPTSTR  svci0_name;
} SERVICE_INFO_0, *PSERVICE_INFO_0, * LPSERVICE_INFO_0;

typedef struct _SERVICE_INFO_1 {
    LPTSTR  svci1_name;
    DWORD   svci1_status;
    DWORD   svci1_code;
    DWORD   svci1_pid;
} SERVICE_INFO_1, *PSERVICE_INFO_1, * LPSERVICE_INFO_1;

typedef struct _SERVICE_INFO_2 {
    LPTSTR  svci2_name;
    DWORD   svci2_status;
    DWORD   svci2_code;
    DWORD   svci2_pid;
    LPTSTR  svci2_text;
    DWORD   svci2_specific_error;
    LPTSTR  svci2_display_name;
} SERVICE_INFO_2, *PSERVICE_INFO_2, * LPSERVICE_INFO_2;

//
// Function Prototypes
//

NET_API_STATUS NET_API_FUNCTION
NetServiceControl (
    IN  LPTSTR  servername OPTIONAL,
    IN  LPTSTR  service,
    IN  DWORD   opcode,
    IN  DWORD   arg,
    OUT LPBYTE  *bufptr
    );

NET_API_STATUS NET_API_FUNCTION
NetServiceEnum (
    IN  LPTSTR      servername OPTIONAL,
    IN  DWORD       level,
    OUT LPBYTE      *bufptr,
    IN  DWORD       prefmaxlen,
    OUT LPDWORD     entriesread,
    OUT LPDWORD     totalentries,
    IN OUT LPDWORD  resume_handle OPTIONAL
    );

NET_API_STATUS NET_API_FUNCTION
NetServiceGetInfo (
    IN  LPTSTR  servername OPTIONAL,
    IN  LPTSTR  service,
    IN  DWORD   level,
    OUT LPBYTE   *bufptr
    );

NET_API_STATUS NET_API_FUNCTION
NetServiceInstall (
    IN  LPTSTR  servername OPTIONAL,
    IN  LPTSTR  service,
    IN  DWORD   argc,
    IN  LPTSTR  argv[],
    OUT LPBYTE  *bufptr
    );

//
// Special Values and Constants
//

//
//  Bitmask and bit values for svci1_status, and svci2_status
//  fields.  For each "subfield", there is a mask defined,
//  and a number of constants representing the value
//  obtained by doing (status & mask).
//

// Bits 0,1 -- general status

#define SERVICE_INSTALL_STATE       0x03
#define SERVICE_UNINSTALLED         0x00
#define SERVICE_INSTALL_PENDING     0x01
#define SERVICE_UNINSTALL_PENDING   0x02
#define SERVICE_INSTALLED           0x03

// Bits 2,3 -- paused/active status

#define SERVICE_PAUSE_STATE              0x0C
#define LM20_SERVICE_ACTIVE              0x00
#define LM20_SERVICE_CONTINUE_PENDING    0x04
#define LM20_SERVICE_PAUSE_PENDING       0x08
#define LM20_SERVICE_PAUSED              0x0C

// Bit 4 -- uninstallable indication

#define SERVICE_NOT_UNINSTALLABLE   0x00
#define SERVICE_UNINSTALLABLE       0x10

// Bit 5 -- pausable indication

#define SERVICE_NOT_PAUSABLE        0x00
#define SERVICE_PAUSABLE            0x20

// Workstation service only:
// Bits 8,9,10 -- redirection paused/active

#define SERVICE_REDIR_PAUSED        0x700
#define SERVICE_REDIR_DISK_PAUSED   0x100
#define SERVICE_REDIR_PRINT_PAUSED  0x200
#define SERVICE_REDIR_COMM_PAUSED   0x400

//
//  Additional standard LAN Manager for MS-DOS services
//

#define SERVICE_DOS_ENCRYPTION  TEXT("ENCRYPT")

//
//  NetServiceControl opcodes.
//

#define SERVICE_CTRL_INTERROGATE    0
#define SERVICE_CTRL_PAUSE          1
#define SERVICE_CTRL_CONTINUE       2
#define SERVICE_CTRL_UNINSTALL      3

//
//  Workstation service only:  Bits used in the "arg" parameter
//  to NetServiceControl in conjunction with the opcode
//  SERVICE_CTRL_PAUSE or SERVICE_CTRL_CONTINUE, to pause or
//  continue redirection.
//

#define SERVICE_CTRL_REDIR_DISK     0x1
#define SERVICE_CTRL_REDIR_PRINT    0x2
#define SERVICE_CTRL_REDIR_COMM     0x4

//
//  Values for svci1_code, and svci2_code when status
//  of the service is SERVICE_INSTALL_PENDING or
//  SERVICE_UNINSTALL_PENDING.
//  A service can optionally provide a hint to the installer
//  that the install is proceeding and how long to wait
//  (in 0.1 second increments) before querying status again.
//

#define SERVICE_IP_NO_HINT          0x0
#define SERVICE_CCP_NO_HINT         0x0

#define SERVICE_IP_QUERY_HINT       0x10000
#define SERVICE_CCP_QUERY_HINT      0x10000

//
// Mask for install proceeding checkpoint number
//

#define SERVICE_IP_CHKPT_NUM        0x0FF
#define SERVICE_CCP_CHKPT_NUM       0x0FF

//
// Mask for wait time hint before querying again
//

#define SERVICE_IP_WAIT_TIME        0x0FF00
#define SERVICE_CCP_WAIT_TIME       0x0FF00

//
// Shift count for building wait time _code values
//

#define SERVICE_IP_WAITTIME_SHIFT   8
#define SERVICE_NTIP_WAITTIME_SHIFT 12

//
// Mask used for upper and lower portions of wait hint time.
//
#define UPPER_HINT_MASK     0x0000FF00
#define LOWER_HINT_MASK     0x000000FF
#define UPPER_GET_HINT_MASK 0x0FF00000
#define LOWER_GET_HINT_MASK 0x0000FF00
#define SERVICE_NT_MAXTIME  0x0000FFFF
#define SERVICE_RESRV_MASK  0x0001FFFF
#define SERVICE_MAXTIME     0x000000FF

//
//  SERVICE_BASE is the base of service error codes,
//  chosen to avoid conflict with OS, redirector,
//  netapi, and errlog codes.
//
// Don't change the comments following the manifest constants without
// understanding how mapmsg works.
//

#define SERVICE_BASE                3050
#define SERVICE_UIC_NORMAL          0
/*
 *  Uninstall codes, to be used in high byte of 'code' on final NetStatus,
 *  which sets the status to UNINSTALLED.
 */

#define SERVICE_UIC_BADPARMVAL          (SERVICE_BASE + 1)
/*
 * The Registry or the information you just typed includes an illegal
 * value for "%1".
 */

#define SERVICE_UIC_MISSPARM            (SERVICE_BASE + 2)
/*
 * The required parameter was not provided on the command
 * line or in the configuration file.
 */

#define SERVICE_UIC_UNKPARM             (SERVICE_BASE + 3)
/*
 * LAN Manager does not recognize "%1" as a valid option.
 */

#define SERVICE_UIC_RESOURCE            (SERVICE_BASE + 4)
/*
 * A request for resource could not be satisfied.
 */

#define SERVICE_UIC_CONFIG              (SERVICE_BASE + 5)
/*
 * A problem exists with the system configuration.
 */

#define SERVICE_UIC_SYSTEM              (SERVICE_BASE + 6)
/*
 * A system error has occurred.
 */

#define SERVICE_UIC_INTERNAL            (SERVICE_BASE + 7)
/*
 * An internal consistency error has occurred.
 */

#define SERVICE_UIC_AMBIGPARM           (SERVICE_BASE + 8)
/*
 * The configuration file or the command line has an ambiguous option.
 */

#define SERVICE_UIC_DUPPARM             (SERVICE_BASE + 9)
/*
 * The configuration file or the command line has a duplicate parameter.
 */

#define SERVICE_UIC_KILL                (SERVICE_BASE + 10)
/*
 * The service did not respond to control and was stopped with
 * the DosKillProc function.
 */

#define SERVICE_UIC_EXEC                (SERVICE_BASE + 11)
/*
 * An error occurred when attempting to run the service program.
 */

#define SERVICE_UIC_SUBSERV             (SERVICE_BASE + 12)
/*
 * The sub-service failed to start.
 */

#define SERVICE_UIC_CONFLPARM           (SERVICE_BASE + 13)
/*
 * There is a conflict in the value or use of these options: %1.
 */

#define SERVICE_UIC_FILE                (SERVICE_BASE + 14)
/*
 * There is a problem with the file.
 */



//
//  The modifiers
//

//
// General:
//

#define SERVICE_UIC_M_NULL  0

//
//  RESOURCE:
//

#define SERVICE_UIC_M_MEMORY    (SERVICE_BASE + 20)     /* memory */
#define SERVICE_UIC_M_DISK      (SERVICE_BASE + 21)     /* disk space */
#define SERVICE_UIC_M_THREADS   (SERVICE_BASE + 22)     /* thread */
#define SERVICE_UIC_M_PROCESSES (SERVICE_BASE + 23)     /* process */

//
//  CONFIG:
//

//
// Security failure
//

#define SERVICE_UIC_M_SECURITY          (SERVICE_BASE + 24)
/* Security Failure. %0 */

#define SERVICE_UIC_M_LANROOT           (SERVICE_BASE + 25)
/*
 * Bad or missing LAN Manager root directory.
 */

#define SERVICE_UIC_M_REDIR             (SERVICE_BASE + 26)
/*
 * The network software is not installed.
 */

#define SERVICE_UIC_M_SERVER            (SERVICE_BASE + 27)
/*
 * The server is not started.
 */

#define SERVICE_UIC_M_SEC_FILE_ERR      (SERVICE_BASE + 28)
/*
 * The server cannot access the user accounts database (NET.ACC).
 */

#define SERVICE_UIC_M_FILES             (SERVICE_BASE + 29)
/*
 * Incompatible files are installed in the LANMAN tree.
 */

#define SERVICE_UIC_M_LOGS              (SERVICE_BASE + 30)
/*
 * The LANMAN\LOGS directory is invalid.
 */

#define SERVICE_UIC_M_LANGROUP          (SERVICE_BASE + 31)
/*
 * The domain specified could not be used.
 */

#define SERVICE_UIC_M_MSGNAME           (SERVICE_BASE + 32)
/*
 * The computer name is being used as a message alias on another computer.
 */

#define SERVICE_UIC_M_ANNOUNCE          (SERVICE_BASE + 33)
/*
 * The announcement of the server name failed.
 */

#define SERVICE_UIC_M_UAS               (SERVICE_BASE + 34)
/*
 * The user accounts database is not configured correctly.
 */

#define SERVICE_UIC_M_SERVER_SEC_ERR    (SERVICE_BASE + 35)
/*
 * The server is not running with user-level security.
 */

#define SERVICE_UIC_M_WKSTA             (SERVICE_BASE + 37)
/*
 * The workstation is not configured properly.
 */

#define SERVICE_UIC_M_ERRLOG            (SERVICE_BASE + 38)
/*
 * View your error log for details.
 */

#define SERVICE_UIC_M_FILE_UW           (SERVICE_BASE + 39)
/*
 * Unable to write to this file.
 */

#define SERVICE_UIC_M_ADDPAK            (SERVICE_BASE + 40)
/*
 * ADDPAK file is corrupted.  Delete LANMAN\NETPROG\ADDPAK.SER
 * and reapply all ADDPAKs.
 */

#define SERVICE_UIC_M_LAZY              (SERVICE_BASE + 41)
/*
 * The LM386 server cannot be started because CACHE.EXE is not running.
 */

#define SERVICE_UIC_M_UAS_MACHINE_ACCT  (SERVICE_BASE + 42)
/*
 * There is no account for this computer in the security database.
 */

#define SERVICE_UIC_M_UAS_SERVERS_NMEMB (SERVICE_BASE + 43)
/*
 * This computer is not a member of the group SERVERS.
 */

#define SERVICE_UIC_M_UAS_SERVERS_NOGRP (SERVICE_BASE + 44)
/*
 * The group SERVERS is not present in the local security database.
 */

#define SERVICE_UIC_M_UAS_INVALID_ROLE  (SERVICE_BASE + 45)
/*
 * This Windows NT computer is configured as a member of a workgroup, not as
 * a member of a domain. The Netlogon service does not need to run in this
 * configuration.
 */

#define SERVICE_UIC_M_NETLOGON_NO_DC    (SERVICE_BASE + 46)
/*
 * The Windows NT domain controller for this domain could not be located.
 */

#define SERVICE_UIC_M_NETLOGON_DC_CFLCT (SERVICE_BASE + 47)
/*
 * A domain controller is already running in this domain.
 */

#define SERVICE_UIC_M_NETLOGON_AUTH     (SERVICE_BASE + 48)
/*
 * The service failed to authenticate with the primary domain controller.
 */

#define SERVICE_UIC_M_UAS_PROLOG        (SERVICE_BASE + 49)
/*
 * There is a problem with the security database creation date or serial number.
 */


#define SERVICE2_BASE    5600
/* new SEVICE_UIC messages go here */

#define SERVICE_UIC_M_NETLOGON_MPATH    (SERVICE2_BASE + 0)
/*
 * Could not share the User or Script path.
 */

#define SERVICE_UIC_M_LSA_MACHINE_ACCT  (SERVICE2_BASE + 1)
/*
 * The password for this computer is not found in the local security
 * database.
 */

#define SERVICE_UIC_M_DATABASE_ERROR    (SERVICE2_BASE + 2)
/*
 * An internal error occurred while accessing the computer's 
 * local or network security database.
 */


//
//  End modifiers
//

//
// Commonly used Macros:
//

#define SERVICE_IP_CODE(tt,nn) \
  ((long)SERVICE_IP_QUERY_HINT|(long)(nn|(tt<<SERVICE_IP_WAITTIME_SHIFT)))

#define SERVICE_CCP_CODE(tt,nn) \
  ((long)SERVICE_CCP_QUERY_HINT|(long)(nn|(tt<<SERVICE_IP_WAITTIME_SHIFT)))

#define SERVICE_UIC_CODE(cc,mm) \
  ((long)(((long)cc<<16)|(long)(unsigned short)mm))

//
// This macro takes a wait hint (tt) which can have a maximum value of
// 0xFFFF and puts it into the service status code field.
// 0x0FF1FFnn  (where nn is the checkpoint information).
//
#define SERVICE_NT_CCP_CODE(tt,nn)  \
  (  \
    ((long)SERVICE_CCP_QUERY_HINT)   | \
    ((long)(nn))   | \
    (((tt)&LOWER_HINT_MASK) << SERVICE_IP_WAITTIME_SHIFT)   | \
    (((tt)&UPPER_HINT_MASK) << SERVICE_NTIP_WAITTIME_SHIFT)   \
  )

//
// This macro takes a status code field, and strips out the wait hint
// from the upper and lower sections.
// 0x0FF1FFnn results in 0x0000FFFF.
//
#define SERVICE_NT_WAIT_GET(code) \
    (   \
      (((code) & UPPER_GET_HINT_MASK) >> SERVICE_NTIP_WAITTIME_SHIFT)  |  \
      (((code) & LOWER_GET_HINT_MASK) >> SERVICE_IP_WAITTIME_SHIFT)  \
    )

#ifdef __cplusplus
}
#endif

#endif // _LMSVC_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\tools\c932\inc\midles.h ===
/*++

Copyright (c) 1991-1995 Microsoft Corporation

Module Name:

    midles.h

Abstract:

    This module contains definitions needed for encoding/decoding
    support (serializing/deserializing a.k.a. pickling).

--*/

#ifndef __MIDLES_H__
#define __MIDLES_H__

#include <rpcndr.h>

//
// Set the packing level for RPC structures for Dos and Windows.
//

#if defined(__RPC_DOS__) || defined(__RPC_WIN16__)
#pragma pack(2)
#endif

#ifdef __cplusplus
extern "C" {
#endif

/*
 *  Pickling support
 */
typedef enum
{
    MES_ENCODE,
    MES_DECODE,
} MIDL_ES_CODE;

typedef enum
{
    MES_INCREMENTAL_HANDLE,
    MES_FIXED_BUFFER_HANDLE,
    MES_DYNAMIC_BUFFER_HANDLE
} MIDL_ES_HANDLE_STYLE;


typedef void (__RPC_USER *  MIDL_ES_ALLOC )
                ( IN OUT  void __RPC_FAR * state,
                  OUT     char __RPC_FAR *  __RPC_FAR * pbuffer,
                  IN OUT  unsigned int __RPC_FAR * psize );

typedef void (__RPC_USER *  MIDL_ES_WRITE)
                ( IN OUT  void __RPC_FAR * state,
                  IN      char __RPC_FAR * buffer,
                  IN      unsigned int  size );

typedef void (__RPC_USER *  MIDL_ES_READ)
                ( IN OUT  void __RPC_FAR * state,
                  OUT     char __RPC_FAR *  __RPC_FAR * pbuffer,
                  IN OUT     unsigned int __RPC_FAR * psize );

typedef struct _MIDL_ES_MESSAGE
{
    MIDL_STUB_MESSAGE                       StubMsg;
    MIDL_ES_CODE                            Operation;
    void __RPC_FAR *                        UserState;
    unsigned long                           MesVersion:8;
    unsigned long                           HandleStyle:8;
    unsigned long                           HandleFlags:8;
    unsigned long                           Reserve:8;
    MIDL_ES_ALLOC                           Alloc;
    MIDL_ES_WRITE                           Write;
    MIDL_ES_READ                            Read;
    unsigned char __RPC_FAR *               Buffer;
    unsigned long                           BufferSize;
    unsigned char __RPC_FAR * __RPC_FAR *   pDynBuffer;
    unsigned long __RPC_FAR *               pEncodedSize;
    RPC_SYNTAX_IDENTIFIER                   InterfaceId;
    unsigned long                           ProcNumber;
    unsigned long                           AlienDataRep;
    unsigned long                           IncrDataSize;
    unsigned long                           ByteCount;
} MIDL_ES_MESSAGE, __RPC_FAR * PMIDL_ES_MESSAGE;

typedef  PMIDL_ES_MESSAGE  MIDL_ES_HANDLE;

RPC_STATUS  RPC_ENTRY
MesEncodeIncrementalHandleCreate(
    void      __RPC_FAR *  UserState,
    MIDL_ES_ALLOC          AllocFn,
    MIDL_ES_WRITE          WriteFn,
    handle_t  __RPC_FAR *  pHandle );

RPC_STATUS  RPC_ENTRY
MesDecodeIncrementalHandleCreate(
    void      __RPC_FAR *  UserState,
    MIDL_ES_READ           ReadFn,
    handle_t  __RPC_FAR *  pHandle );


RPC_STATUS  RPC_ENTRY
MesIncrementalHandleReset(
    handle_t             Handle,
    void    __RPC_FAR *  UserState,
    MIDL_ES_ALLOC        AllocFn,
    MIDL_ES_WRITE        WriteFn,
    MIDL_ES_READ         ReadFn,
    MIDL_ES_CODE         Operation );


RPC_STATUS  RPC_ENTRY
MesEncodeFixedBufferHandleCreate(
    char __RPC_FAR *            pBuffer,
    unsigned long               BufferSize,
    unsigned long __RPC_FAR *   pEncodedSize,
    handle_t  __RPC_FAR *       pHandle );

RPC_STATUS  RPC_ENTRY
MesEncodeDynBufferHandleCreate(
    char __RPC_FAR * __RPC_FAR *    pBuffer,
    unsigned long    __RPC_FAR *    pEncodedSize,
    handle_t  __RPC_FAR *           pHandle );

RPC_STATUS  RPC_ENTRY
MesDecodeBufferHandleCreate(
    char __RPC_FAR *        pBuffer,
    unsigned long           BufferSize,
    handle_t  __RPC_FAR *   pHandle );


RPC_STATUS  RPC_ENTRY
MesBufferHandleReset(
    handle_t                        Handle,
    unsigned long                   HandleStyle,
    MIDL_ES_CODE                    Operation,
    char __RPC_FAR * __RPC_FAR *    pBuffer,
    unsigned long                   BufferSize,
    unsigned long __RPC_FAR *       pEncodedSize );


RPC_STATUS  RPC_ENTRY
MesHandleFree( handle_t  Handle );

RPC_STATUS  RPC_ENTRY
MesInqProcEncodingId(
    handle_t                    Handle,
    PRPC_SYNTAX_IDENTIFIER      pInterfaceId,
    unsigned long __RPC_FAR *   pProcNum );


#if defined(_MIPS_) || defined(_ALPHA_) || defined(_PPC_)
#define __RPC_UNALIGNED   __unaligned
#else
#define __RPC_UNALIGNED
#endif

void  RPC_ENTRY    I_NdrMesMessageInit( PMIDL_STUB_MESSAGE );

size_t  RPC_ENTRY
NdrMesSimpleTypeAlignSize ( handle_t );

void  RPC_ENTRY
NdrMesSimpleTypeDecode(
    handle_t            Handle,
    void __RPC_FAR *    pObject,
    short               Size );

void  RPC_ENTRY
NdrMesSimpleTypeEncode(
    handle_t            Handle,
    PMIDL_STUB_DESC     pStubDesc,
    void __RPC_FAR *    pObject,
    short               Size );


size_t  RPC_ENTRY
NdrMesTypeAlignSize(
    handle_t            Handle,
    PMIDL_STUB_DESC     pStubDesc,
    PFORMAT_STRING      pFormatString,
    void __RPC_FAR *    pObject );

void  RPC_ENTRY
NdrMesTypeEncode(
    handle_t            Handle,
    PMIDL_STUB_DESC     pStubDesc,
    PFORMAT_STRING      pFormatString,
    void __RPC_FAR *    pObject );

void  RPC_ENTRY
NdrMesTypeDecode(
    handle_t            Handle,
    PMIDL_STUB_DESC     pStubDesc,
    PFORMAT_STRING      pFormatString,
    void __RPC_FAR *    pObject );

void  RPC_VAR_ENTRY
NdrMesProcEncodeDecode(
    handle_t            Handle,
    PMIDL_STUB_DESC     pStubDesc,
    PFORMAT_STRING      pFormatString,
    ... );


#ifdef __cplusplus
}
#endif

// Reset the packing level for DOS and Windows.

#if defined(__RPC_DOS__) || defined(__RPC_WIN16__)
#pragma pack()
#endif

#endif /* __MIDLES_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\tools\c932\inc\locale.h ===
/***
*locale.h - definitions/declarations for localization routines
*
*	Copyright (c) 1988-1994, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	This file defines the structures, values, macros, and functions
*	used by the localization routines.
*
****/

#ifndef _INC_LOCALE
#define _INC_LOCALE

#ifdef __cplusplus
extern "C" {
#endif


/* Define _CRTAPI1 (for compatibility with the NT SDK) */

#ifndef _CRTAPI1
#if	( (_MSC_VER >= 800) && (_M_IX86 >= 300) )
#define _CRTAPI1 __cdecl
#else
#define _CRTAPI1
#endif
#endif


/* Define _CRTAPI2 (for compatibility with the NT SDK) */

#ifndef _CRTAPI2
#if	( (_MSC_VER >= 800) && (_M_IX86 >= 300) )
#define _CRTAPI2 __cdecl
#else
#define _CRTAPI2
#endif
#endif


/* Define _CRTIMP */

#ifndef _CRTIMP
#ifdef	_NTSDK
/* definition compatible with NT SDK */
#define _CRTIMP
#else	/* ndef _NTSDK */
/* current definition */
#ifdef	_DLL
#define _CRTIMP __declspec(dllimport)
#else	/* ndef _DLL */
#define _CRTIMP
#endif	/* _DLL */
#endif	/* _NTSDK */
#endif	/* _CRTIMP */


/* Define __cdecl for non-Microsoft compilers */

#if	( !defined(_MSC_VER) && !defined(__cdecl) )
#define __cdecl
#endif


#ifndef _WCHAR_T_DEFINED
typedef unsigned short wchar_t;
#define _WCHAR_T_DEFINED
#endif


/* define NULL pointer value */

#ifndef NULL
#ifdef __cplusplus
#define NULL	0
#else
#define NULL	((void *)0)
#endif
#endif

/* Locale categories */

#define LC_ALL		0
#define LC_COLLATE	1
#define LC_CTYPE	2
#define LC_MONETARY	3
#define LC_NUMERIC	4
#define LC_TIME 	5

#define LC_MIN		LC_ALL
#define LC_MAX		LC_TIME

/* Locale convention structure */

#ifndef _LCONV_DEFINED
struct lconv {
	char *decimal_point;
	char *thousands_sep;
	char *grouping;
	char *int_curr_symbol;
	char *currency_symbol;
	char *mon_decimal_point;
	char *mon_thousands_sep;
	char *mon_grouping;
	char *positive_sign;
	char *negative_sign;
	char int_frac_digits;
	char frac_digits;
	char p_cs_precedes;
	char p_sep_by_space;
	char n_cs_precedes;
	char n_sep_by_space;
	char p_sign_posn;
	char n_sign_posn;
	};
#define _LCONV_DEFINED
#endif

/* ANSI: char lconv members default is CHAR_MAX which is compile time
   dependent. Defining and using _charmax here causes CRT startup code
   to initialize lconv members properly */

#ifdef	_CHAR_UNSIGNED
extern int _charmax;
extern __inline int __dummy() { return _charmax; }
#endif

/* function prototypes */

_CRTIMP char * __cdecl setlocale(int, const char *);
_CRTIMP struct lconv * __cdecl localeconv(void);

#ifndef _WLOCALE_DEFINED

/* wide function prototypes, also declared in wchar.h  */

_CRTIMP wchar_t * __cdecl _wsetlocale(int, const wchar_t *);

#define _WLOCALE_DEFINED
#endif

#ifdef __cplusplus
}
#endif

#endif	/* _INC_LOCALE */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\tools\c932\inc\lmwksta.h ===
/*++ BUILD Version: 0006    // Increment this if a change has global effects

Copyright (c) 1991-1993  Microsoft Corporation

Module Name:

    lmwksta.h

Abstract:

    This file contains structures, function prototypes, and definitions
    for the NetWorkstation and NetWkstaTransport API.

Author:

    Dan Lafferty (danl) 10-Mar-1991

Environment:

    User Mode - Win32
    Portable to any flat, 32-bit environment.  (Uses Win32 typedefs.)
    Requires ANSI C extensions: slash-slash comments, long external names.

Notes:

    You must include NETCONS.H before this file, since this file depends
    on values defined in NETCONS.H.

Revision History:

    10-Mar-1991 danl
        Created from LM2.0 header files and NT-LAN API Spec.
    14-Mar-91 JohnRo
        Added OPTIONAL keyword again.  Fixed NetWkstaGetInfo parm list
        (it shouldn't have a trailing comma).
    19-Mar-91 ritaw
        Added parm_err to NetWkstaTransportAdd.
        Removed UseOpBatch and PadValue1 fields from WKSTA_INFO_502.
    29-Mar-91 ritaw
        Added NetWkstaUserGetInfo and NetWkstaUserEnum, removed
        WKSTA_INFO_201, and WKSTA_INFO_202.
    14-Apr-91 w-shanku
        Moved oth_domains and lanroot fields to same order as OS/2
        structures, changed ParmNum constants to be consistent with
        OS/2 parmnums.
    1-May-1991  larryo
        Added cached file timeout parameter.
    9-May-1991 ritaw
        Changed LPSTR to LPTSTR.
        Moved oth_domains to DOS and OS/2 specific info structures.
        Added max_threads and char_wait to WKSTA_INFO_502.
        Renamed wki502_session_timeout to wki502_sess_timeout.
        Added lan_root to WKSTA_INFO_101.
    29-Jul-1991 JohnRo
        Implement downlevel NetWksta APIs (set info parm_err is OPTIONAL).
    16-Aug-1991 JohnRo
        NetWksta parmnum changes (for downlevel support).
    18-Sep-1991 ritaw
        Moved oth_domains from DOS and OS/2 specific info structures
        to WKSTA_USER_INFO_1.
    16-Mar-1992 colinw
        Remove wki502_siz_work_buf (now a constant) and wki502_num_work_buf ( Use
        wki502_max_cmds instead).

--*/

#ifndef _LMWKSTA_
#define _LMWKSTA_

#ifdef __cplusplus
extern "C" {
#endif

#include <lmuseflg.h>                   // Deletion force level flags

//
// Function Prototypes
//

NET_API_STATUS NET_API_FUNCTION
NetWkstaGetInfo (
    IN  LPTSTR  servername OPTIONAL,
    IN  DWORD   level,
    OUT LPBYTE  *bufptr
    );

NET_API_STATUS NET_API_FUNCTION
NetWkstaSetInfo (
    IN  LPTSTR  servername OPTIONAL,
    IN  DWORD   level,
    IN  LPBYTE  buffer,
    OUT LPDWORD parm_err OPTIONAL
    );

NET_API_STATUS NET_API_FUNCTION
NetWkstaUserGetInfo (
    IN  LPTSTR reserved,
    IN  DWORD   level,
    OUT LPBYTE  *bufptr
    );

NET_API_STATUS NET_API_FUNCTION
NetWkstaUserSetInfo (
    IN  LPTSTR reserved,
    IN  DWORD   level,
    OUT LPBYTE  buf,
    OUT LPDWORD parm_err OPTIONAL
    );

NET_API_STATUS NET_API_FUNCTION
NetWkstaUserEnum (
    IN  LPTSTR      servername OPTIONAL,
    IN  DWORD       level,
    OUT LPBYTE      *bufptr,
    IN  DWORD       prefmaxlen,
    OUT LPDWORD     entriesread,
    OUT LPDWORD     totalentries,
    IN  OUT LPDWORD resumehandle OPTIONAL
    );

NET_API_STATUS NET_API_FUNCTION
NetWkstaTransportAdd (
    IN  LPTSTR  servername OPTIONAL,
    IN  DWORD   level,
    IN  LPBYTE  buf,
    OUT LPDWORD parm_err
    );

NET_API_STATUS NET_API_FUNCTION
NetWkstaTransportDel (
    IN  LPTSTR  servername OPTIONAL,
    IN  LPTSTR  transportname,
    IN  DWORD   ucond
    );

NET_API_STATUS NET_API_FUNCTION
NetWkstaTransportEnum (
    IN  LPTSTR      servername OPTIONAL,
    IN  DWORD       level,
    OUT LPBYTE      *bufptr,
    IN  DWORD       prefmaxlen,
    OUT LPDWORD     entriesread,
    OUT LPDWORD     totalentries,
    IN  OUT LPDWORD resumehandle OPTIONAL
    );

//
//  Data Structures
//

//
// NetWkstaGetInfo and NetWkstaSetInfo
//

//
// NetWkstaGetInfo only.  System information - guest access
//
typedef struct _WKSTA_INFO_100 {
    DWORD   wki100_platform_id;
    LPTSTR  wki100_computername;
    LPTSTR  wki100_langroup;
    DWORD   wki100_ver_major;
    DWORD   wki100_ver_minor;
}WKSTA_INFO_100, *PWKSTA_INFO_100, *LPWKSTA_INFO_100;

//
// NetWkstaGetInfo only.  System information - user access
//
typedef struct _WKSTA_INFO_101 {
    DWORD   wki101_platform_id;
    LPTSTR  wki101_computername;
    LPTSTR  wki101_langroup;
    DWORD   wki101_ver_major;
    DWORD   wki101_ver_minor;
    LPTSTR  wki101_lanroot;
}WKSTA_INFO_101, *PWKSTA_INFO_101, *LPWKSTA_INFO_101;

//
// NetWkstaGetInfo only.  System information - admin or operator access
//
typedef struct _WKSTA_INFO_102 {
    DWORD   wki102_platform_id;
    LPTSTR  wki102_computername;
    LPTSTR  wki102_langroup;
    DWORD   wki102_ver_major;
    DWORD   wki102_ver_minor;
    LPTSTR  wki102_lanroot;
    DWORD   wki102_logged_on_users;
}WKSTA_INFO_102, *PWKSTA_INFO_102, *LPWKSTA_INFO_102;

//
// Down-level NetWkstaGetInfo and NetWkstaSetInfo.
//
// DOS specific workstation information -
//    admin or domain operator access
//
typedef struct _WKSTA_INFO_302{
    DWORD   wki302_char_wait;
    DWORD   wki302_collection_time;
    DWORD   wki302_maximum_collection_count;
    DWORD   wki302_keep_conn;
    DWORD   wki302_keep_search;
    DWORD   wki302_max_cmds;
    DWORD   wki302_num_work_buf;
    DWORD   wki302_siz_work_buf;
    DWORD   wki302_max_wrk_cache;
    DWORD   wki302_sess_timeout;
    DWORD   wki302_siz_error;
    DWORD   wki302_num_alerts;
    DWORD   wki302_num_services;
    DWORD   wki302_errlog_sz;
    DWORD   wki302_print_buf_time;
    DWORD   wki302_num_char_buf;
    DWORD   wki302_siz_char_buf;
    LPTSTR  wki302_wrk_heuristics;
    DWORD   wki302_mailslots;
    DWORD   wki302_num_dgram_buf;
}WKSTA_INFO_302, *PWKSTA_INFO_302, *LPWKSTA_INFO_302;

//
// Down-level NetWkstaGetInfo and NetWkstaSetInfo
//
// OS/2 specific workstation information -
//    admin or domain operator access
//
typedef struct _WKSTA_INFO_402{
    DWORD   wki402_char_wait;
    DWORD   wki402_collection_time;
    DWORD   wki402_maximum_collection_count;
    DWORD   wki402_keep_conn;
    DWORD   wki402_keep_search;
    DWORD   wki402_max_cmds;
    DWORD   wki402_num_work_buf;
    DWORD   wki402_siz_work_buf;
    DWORD   wki402_max_wrk_cache;
    DWORD   wki402_sess_timeout;
    DWORD   wki402_siz_error;
    DWORD   wki402_num_alerts;
    DWORD   wki402_num_services;
    DWORD   wki402_errlog_sz;
    DWORD   wki402_print_buf_time;
    DWORD   wki402_num_char_buf;
    DWORD   wki402_siz_char_buf;
    LPTSTR  wki402_wrk_heuristics;
    DWORD   wki402_mailslots;
    DWORD   wki402_num_dgram_buf;
    DWORD   wki402_max_threads;
}WKSTA_INFO_402, *PWKSTA_INFO_402, *LPWKSTA_INFO_402;

//
// Same-level NetWkstaGetInfo and NetWkstaSetInfo.
//
// NT specific workstation information -
//    admin or domain operator access
//
typedef struct _WKSTA_INFO_502{
    DWORD   wki502_char_wait;
    DWORD   wki502_collection_time;
    DWORD   wki502_maximum_collection_count;
    DWORD   wki502_keep_conn;
    DWORD   wki502_max_cmds;
    DWORD   wki502_sess_timeout;
    DWORD   wki502_siz_char_buf;
    DWORD   wki502_max_threads;

    DWORD   wki502_lock_quota;
    DWORD   wki502_lock_increment;
    DWORD   wki502_lock_maximum;
    DWORD   wki502_pipe_increment;
    DWORD   wki502_pipe_maximum;
    DWORD   wki502_cache_file_timeout;
    DWORD   wki502_dormant_file_limit;
    DWORD   wki502_read_ahead_throughput;

    DWORD   wki502_num_mailslot_buffers;
    DWORD   wki502_num_srv_announce_buffers;
    DWORD   wki502_max_illegal_datagram_events;
    DWORD   wki502_illegal_datagram_event_reset_frequency;
    BOOL    wki502_log_election_packets;

    BOOL    wki502_use_opportunistic_locking;
    BOOL    wki502_use_unlock_behind;
    BOOL    wki502_use_close_behind;
    BOOL    wki502_buf_named_pipes;
    BOOL    wki502_use_lock_read_unlock;
    BOOL    wki502_utilize_nt_caching;
    BOOL    wki502_use_raw_read;
    BOOL    wki502_use_raw_write;
    BOOL    wki502_use_write_raw_data;
    BOOL    wki502_use_encryption;
    BOOL    wki502_buf_files_deny_write;
    BOOL    wki502_buf_read_only_files;
    BOOL    wki502_force_core_create_mode;
    BOOL    wki502_use_512_byte_max_transfer;
}WKSTA_INFO_502, *PWKSTA_INFO_502, *LPWKSTA_INFO_502;


//
// The following info-levels are only valid for NetWkstaSetInfo
//

//
// The following levels are supported on down-level systems (LAN Man 2.x)
// as well as NT systems:
//
typedef struct _WKSTA_INFO_1010 {
     DWORD  wki1010_char_wait;
} WKSTA_INFO_1010, *PWKSTA_INFO_1010, *LPWKSTA_INFO_1010;

typedef struct _WKSTA_INFO_1011 {
     DWORD  wki1011_collection_time;
} WKSTA_INFO_1011, *PWKSTA_INFO_1011, *LPWKSTA_INFO_1011;

typedef struct _WKSTA_INFO_1012 {
     DWORD  wki1012_maximum_collection_count;
} WKSTA_INFO_1012, *PWKSTA_INFO_1012, *LPWKSTA_INFO_1012;

//
// The following level are supported on down-level systems (LAN Man 2.x)
// only:
//
typedef struct _WKSTA_INFO_1027 {
     DWORD  wki1027_errlog_sz;
} WKSTA_INFO_1027, *PWKSTA_INFO_1027, *LPWKSTA_INFO_1027;

typedef struct _WKSTA_INFO_1028 {
     DWORD  wki1028_print_buf_time;
} WKSTA_INFO_1028, *PWKSTA_INFO_1028, *LPWKSTA_INFO_1028;

typedef struct _WKSTA_INFO_1032 {
     DWORD  wki1032_wrk_heuristics;
} WKSTA_INFO_1032, *PWKSTA_INFO_1032, *LPWKSTA_INFO_1032;

//
// The following levels are settable on NT systems, and have no
// effect on down-level systems (i.e. LANMan 2.x) since these
// fields cannot be set on them:
//
typedef struct _WKSTA_INFO_1013 {
     DWORD  wki1013_keep_conn;
} WKSTA_INFO_1013, *PWKSTA_INFO_1013, *LPWKSTA_INFO_1013;

typedef struct _WKSTA_INFO_1018 {
     DWORD  wki1018_sess_timeout;
} WKSTA_INFO_1018, *PWKSTA_INFO_1018, *LPWKSTA_INFO_1018;

typedef struct _WKSTA_INFO_1023 {
     DWORD  wki1023_siz_char_buf;
} WKSTA_INFO_1023, *PWKSTA_INFO_1023, *LPWKSTA_INFO_1023;

typedef struct _WKSTA_INFO_1033 {
     DWORD  wki1033_max_threads;
} WKSTA_INFO_1033, *PWKSTA_INFO_1033, *LPWKSTA_INFO_1033;

//
// The following levels are only supported on NT systems:
//
typedef struct _WKSTA_INFO_1041 {
    DWORD   wki1041_lock_quota;
} WKSTA_INFO_1041, *PWKSTA_INFO_1041, *LPWKSTA_INFO_1041;

typedef struct _WKSTA_INFO_1042 {
    DWORD   wki1042_lock_increment;
} WKSTA_INFO_1042, *PWKSTA_INFO_1042, *LPWKSTA_INFO_1042;

typedef struct _WKSTA_INFO_1043 {
    DWORD   wki1043_lock_maximum;
} WKSTA_INFO_1043, *PWKSTA_INFO_1043, *LPWKSTA_INFO_1043;

typedef struct _WKSTA_INFO_1044 {
    DWORD   wki1044_pipe_increment;
} WKSTA_INFO_1044, *PWKSTA_INFO_1044, *LPWKSTA_INFO_1044;

typedef struct _WKSTA_INFO_1045 {
    DWORD   wki1045_pipe_maximum;
} WKSTA_INFO_1045, *PWKSTA_INFO_1045, *LPWKSTA_INFO_1045;

typedef struct _WKSTA_INFO_1046 {
    DWORD   wki1046_dormant_file_limit;
} WKSTA_INFO_1046, *PWKSTA_INFO_1046, *LPWKSTA_INFO_1046;

typedef struct _WKSTA_INFO_1047 {
    DWORD    wki1047_cache_file_timeout;
} WKSTA_INFO_1047, *PWKSTA_INFO_1047, *LPWKSTA_INFO_1047;

typedef struct _WKSTA_INFO_1048 {
    BOOL     wki1048_use_opportunistic_locking;
} WKSTA_INFO_1048, *PWKSTA_INFO_1048, *LPWKSTA_INFO_1048;

typedef struct _WKSTA_INFO_1049 {
    BOOL     wki1049_use_unlock_behind;
} WKSTA_INFO_1049, *PWKSTA_INFO_1049, *LPWKSTA_INFO_1049;

typedef struct _WKSTA_INFO_1050 {
    BOOL     wki1050_use_close_behind;
} WKSTA_INFO_1050, *PWKSTA_INFO_1050, *LPWKSTA_INFO_1050;

typedef struct _WKSTA_INFO_1051 {
    BOOL     wki1051_buf_named_pipes;
} WKSTA_INFO_1051, *PWKSTA_INFO_1051, *LPWKSTA_INFO_1051;

typedef struct _WKSTA_INFO_1052 {
    BOOL     wki1052_use_lock_read_unlock;
} WKSTA_INFO_1052, *PWKSTA_INFO_1052, *LPWKSTA_INFO_1052;

typedef struct _WKSTA_INFO_1053 {
    BOOL     wki1053_utilize_nt_caching;
} WKSTA_INFO_1053, *PWKSTA_INFO_1053, *LPWKSTA_INFO_1053;

typedef struct _WKSTA_INFO_1054 {
    BOOL     wki1054_use_raw_read;
} WKSTA_INFO_1054, *PWKSTA_INFO_1054, *LPWKSTA_INFO_1054;

typedef struct _WKSTA_INFO_1055 {
    BOOL     wki1055_use_raw_write;
} WKSTA_INFO_1055, *PWKSTA_INFO_1055, *LPWKSTA_INFO_1055;

typedef struct _WKSTA_INFO_1056 {
    BOOL     wki1056_use_write_raw_data;
} WKSTA_INFO_1056, *PWKSTA_INFO_1056, *LPWKSTA_INFO_1056;

typedef struct _WKSTA_INFO_1057 {
    BOOL     wki1057_use_encryption;
} WKSTA_INFO_1057, *PWKSTA_INFO_1057, *LPWKSTA_INFO_1057;

typedef struct _WKSTA_INFO_1058 {
    BOOL     wki1058_buf_files_deny_write;
} WKSTA_INFO_1058, *PWKSTA_INFO_1058, *LPWKSTA_INFO_1058;

typedef struct _WKSTA_INFO_1059 {
    BOOL     wki1059_buf_read_only_files;
} WKSTA_INFO_1059, *PWKSTA_INFO_1059, *LPWKSTA_INFO_1059;

typedef struct _WKSTA_INFO_1060 {
    BOOL     wki1060_force_core_create_mode;
} WKSTA_INFO_1060, *PWKSTA_INFO_1060, *LPWKSTA_INFO_1060;

typedef struct _WKSTA_INFO_1061 {
    BOOL     wki1061_use_512_byte_max_transfer;
} WKSTA_INFO_1061, *PWKSTA_INFO_1061, *LPWKSTA_INFO_1061;

typedef struct _WKSTA_INFO_1062 {
    DWORD   wki1062_read_ahead_throughput;
} WKSTA_INFO_1062, *PWKSTA_INFO_1062, *LPWKSTA_INFO_1062;


//
// NetWkstaUserGetInfo (local only) and NetWkstaUserEnum -
//     no access restrictions.
//
typedef struct _WKSTA_USER_INFO_0 {
    LPTSTR  wkui0_username;
}WKSTA_USER_INFO_0, *PWKSTA_USER_INFO_0, *LPWKSTA_USER_INFO_0;

//
// NetWkstaUserGetInfo (local only) and NetWkstaUserEnum -
//     no access restrictions.
//
typedef struct _WKSTA_USER_INFO_1 {
    LPTSTR  wkui1_username;
    LPTSTR  wkui1_logon_domain;
    LPTSTR  wkui1_oth_domains;
    LPTSTR  wkui1_logon_server;
}WKSTA_USER_INFO_1, *PWKSTA_USER_INFO_1, *LPWKSTA_USER_INFO_1;

//
// NetWkstaUserSetInfo - local access.
//
typedef struct _WKSTA_USER_INFO_1101 {
     LPTSTR  wkui1101_oth_domains;
} WKSTA_USER_INFO_1101, *PWKSTA_USER_INFO_1101,
  *LPWKSTA_USER_INFO_1101;


//
// NetWkstaTransportAdd - admin access
//
typedef struct _WKSTA_TRANSPORT_INFO_0 {
    DWORD   wkti0_quality_of_service;
    DWORD   wkti0_number_of_vcs;
    LPTSTR  wkti0_transport_name;
    LPTSTR  wkti0_transport_address;
    BOOL    wkti0_wan_ish;
}WKSTA_TRANSPORT_INFO_0, *PWKSTA_TRANSPORT_INFO_0,
 *LPWKSTA_TRANSPORT_INFO_0;


//
// Special Values and Constants
//

//
//  Identifiers for use as NetWkstaSetInfo parmnum parameter
//

//
// One of these values indicates the parameter within an information
// structure that is invalid when ERROR_INVALID_PARAMETER is returned by
// NetWkstaSetInfo.
//

#define WKSTA_PLATFORM_ID_PARMNUM               100
#define WKSTA_COMPUTERNAME_PARMNUM              1
#define WKSTA_LANGROUP_PARMNUM                  2
#define WKSTA_VER_MAJOR_PARMNUM                 4
#define WKSTA_VER_MINOR_PARMNUM                 5
#define WKSTA_LOGGED_ON_USERS_PARMNUM           6
#define WKSTA_LANROOT_PARMNUM                   7
#define WKSTA_LOGON_DOMAIN_PARMNUM              8
#define WKSTA_LOGON_SERVER_PARMNUM              9
#define WKSTA_CHARWAIT_PARMNUM                  10  // Supported by down-level.
#define WKSTA_CHARTIME_PARMNUM                  11  // Supported by down-level.
#define WKSTA_CHARCOUNT_PARMNUM                 12  // Supported by down-level.
#define WKSTA_KEEPCONN_PARMNUM                  13
#define WKSTA_KEEPSEARCH_PARMNUM                14
#define WKSTA_MAXCMDS_PARMNUM                   15
#define WKSTA_NUMWORKBUF_PARMNUM                16
#define WKSTA_MAXWRKCACHE_PARMNUM               17
#define WKSTA_SESSTIMEOUT_PARMNUM               18
#define WKSTA_SIZERROR_PARMNUM                  19
#define WKSTA_NUMALERTS_PARMNUM                 20
#define WKSTA_NUMSERVICES_PARMNUM               21
#define WKSTA_NUMCHARBUF_PARMNUM                22
#define WKSTA_SIZCHARBUF_PARMNUM                23
#define WKSTA_ERRLOGSZ_PARMNUM                  27  // Supported by down-level.
#define WKSTA_PRINTBUFTIME_PARMNUM              28  // Supported by down-level.
#define WKSTA_SIZWORKBUF_PARMNUM                29
#define WKSTA_MAILSLOTS_PARMNUM                 30
#define WKSTA_NUMDGRAMBUF_PARMNUM               31
#define WKSTA_WRKHEURISTICS_PARMNUM             32  // Supported by down-level.
#define WKSTA_MAXTHREADS_PARMNUM                33

#define WKSTA_LOCKQUOTA_PARMNUM                 41
#define WKSTA_LOCKINCREMENT_PARMNUM             42
#define WKSTA_LOCKMAXIMUM_PARMNUM               43
#define WKSTA_PIPEINCREMENT_PARMNUM             44
#define WKSTA_PIPEMAXIMUM_PARMNUM               45
#define WKSTA_DORMANTFILELIMIT_PARMNUM          46
#define WKSTA_CACHEFILETIMEOUT_PARMNUM          47
#define WKSTA_USEOPPORTUNISTICLOCKING_PARMNUM   48
#define WKSTA_USEUNLOCKBEHIND_PARMNUM           49
#define WKSTA_USECLOSEBEHIND_PARMNUM            50
#define WKSTA_BUFFERNAMEDPIPES_PARMNUM          51
#define WKSTA_USELOCKANDREADANDUNLOCK_PARMNUM   52
#define WKSTA_UTILIZENTCACHING_PARMNUM          53
#define WKSTA_USERAWREAD_PARMNUM                54
#define WKSTA_USERAWWRITE_PARMNUM               55
#define WKSTA_USEWRITERAWWITHDATA_PARMNUM       56
#define WKSTA_USEENCRYPTION_PARMNUM             57
#define WKSTA_BUFFILESWITHDENYWRITE_PARMNUM     58
#define WKSTA_BUFFERREADONLYFILES_PARMNUM       59
#define WKSTA_FORCECORECREATEMODE_PARMNUM       60
#define WKSTA_USE512BYTESMAXTRANSFER_PARMNUM    61
#define WKSTA_READAHEADTHRUPUT_PARMNUM          62


//
// One of these values indicates the parameter within an information
// structure that is invalid when ERROR_INVALID_PARAMETER is returned by
// NetWkstaUserSetInfo.
//

#define WKSTA_OTH_DOMAINS_PARMNUM              101


//
// One of these values indicates the parameter within an information
// structure that is invalid when ERROR_INVALID_PARAMETER is returned by
// NetWkstaTransportAdd.
//

#define TRANSPORT_QUALITYOFSERVICE_PARMNUM     201
#define TRANSPORT_NAME_PARMNUM                 202

#ifdef __cplusplus
}
#endif

#endif // _LMWKSTA_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\tools\c932\inc\lzexpand.h ===
/*
** lzdos.h - Public interface to LZEXP?.LIB.
*/

#ifndef _LZEXPAND_
#define _LZEXPAND_

#ifdef __cplusplus
extern "C" {
#endif

/*
** Error Return Codes
*/

#define LZERROR_BADINHANDLE   (-1)  /* invalid input handle */
#define LZERROR_BADOUTHANDLE  (-2)  /* invalid output handle */
#define LZERROR_READ          (-3)  /* corrupt compressed file format */
#define LZERROR_WRITE         (-4)  /* out of space for output file */
#define LZERROR_GLOBALLOC     (-5)  /* insufficient memory for LZFile struct */
#define LZERROR_GLOBLOCK      (-6)  /* bad global handle */
#define LZERROR_BADVALUE      (-7)  /* input parameter out of acceptable range*/
#define LZERROR_UNKNOWNALG    (-8)  /* compression algorithm not recognized */


/*
** Prototypes
*/

INT
APIENTRY
LZStart(
	VOID
	);

VOID
APIENTRY
LZDone(
	VOID
	);

LONG
APIENTRY
CopyLZFile(
	INT,
	INT
	);

LONG
APIENTRY
LZCopy(
	INT,
	INT
	);

INT
APIENTRY
LZInit(
	INT
	);

INT
APIENTRY
GetExpandedNameA(
	LPSTR,
	LPSTR
	);
INT
APIENTRY
GetExpandedNameW(
	LPWSTR,
	LPWSTR
	);
#ifdef UNICODE
#define GetExpandedName  GetExpandedNameW
#else
#define GetExpandedName  GetExpandedNameA
#endif // !UNICODE

INT
APIENTRY
LZOpenFileA(
	LPSTR,
	LPOFSTRUCT,
	WORD
	);
INT
APIENTRY
LZOpenFileW(
	LPWSTR,
	LPOFSTRUCT,
	WORD
	);
#ifdef UNICODE
#define LZOpenFile  LZOpenFileW
#else
#define LZOpenFile  LZOpenFileA
#endif // !UNICODE

LONG
APIENTRY
LZSeek(
	INT,
	LONG,
	INT
	);

INT
APIENTRY
LZRead(
	INT,
	LPSTR,
	INT
	);

VOID
APIENTRY
LZClose(
	INT
	);

#ifdef __cplusplus
}
#endif


#endif // _LZEXPAND_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\tools\c932\inc\math.h ===
/***
*math.h - definitions and declarations for math library
*
*	Copyright (c) 1985-1994, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	This file contains constant definitions and external subroutine
*	declarations for the math subroutine library.
*	[ANSI/System V]
*
****/

#ifndef _INC_MATH
#define _INC_MATH

#ifdef __cplusplus
extern "C" {
#endif


/* Define _CRTAPI1 (for compatibility with the NT SDK) */

#ifndef _CRTAPI1
#if	( (_MSC_VER >= 800) && (_M_IX86 >= 300) )
#define _CRTAPI1 __cdecl
#else
#define _CRTAPI1
#endif
#endif


/* Define _CRTAPI2 (for compatibility with the NT SDK) */

#ifndef _CRTAPI2
#if	( (_MSC_VER >= 800) && (_M_IX86 >= 300) )
#define _CRTAPI2 __cdecl
#else
#define _CRTAPI2
#endif
#endif


/* Define _CRTIMP */

#ifndef _CRTIMP
#ifdef	_NTSDK
/* definition compatible with NT SDK */
#define _CRTIMP
#else	/* ndef _NTSDK */
/* current definition */
#ifdef	_DLL
#define _CRTIMP __declspec(dllimport)
#else	/* ndef _DLL */
#define _CRTIMP
#endif	/* _DLL */
#endif	/* _NTSDK */
#endif	/* _CRTIMP */


/* Define __cdecl for non-Microsoft compilers */

#if	( !defined(_MSC_VER) && !defined(__cdecl) )
#define __cdecl
#endif


/* Definition of _exception struct - this struct is passed to the matherr
 * routine when a floating point exception is detected
 */

#ifndef _EXCEPTION_DEFINED
struct _exception {
	int type;		/* exception type - see below */
	char *name;		/* name of function where error occured */
	double arg1;		/* first argument to function */
	double arg2;		/* second argument (if any) to function */
	double retval;		/* value to be returned by function */
	} ;

#if	!__STDC__
/* Non-ANSI name for compatibility */
#define exception _exception
#endif

#define _EXCEPTION_DEFINED
#endif


/* Definition of a _complex struct to be used by those who use cabs and
 * want type checking on their argument
 */

#ifndef _COMPLEX_DEFINED
struct _complex {
	double x,y;	/* real and imaginary parts */
	} ;

#if	!__STDC__
/* Non-ANSI name for compatibility */
#define complex _complex
#endif

#define _COMPLEX_DEFINED
#endif


/* Constant definitions for the exception type passed in the _exception struct
 */

#define _DOMAIN 	1	/* argument domain error */
#define _SING		2	/* argument singularity */
#define _OVERFLOW	3	/* overflow range error */
#define _UNDERFLOW	4	/* underflow range error */
#define _TLOSS		5	/* total loss of precision */
#define _PLOSS		6	/* partial loss of precision */

#define EDOM		33
#define ERANGE		34


/* Definitions of _HUGE and HUGE_VAL - respectively the XENIX and ANSI names
 * for a value returned in case of error by a number of the floating point
 * math routines
 */
#ifdef	_NTSDK
/* definition compatible with NT SDK */
#ifdef	_DLL
#define _HUGE	(*_HUGE_dll)
extern double * _HUGE_dll;
#else	/* ndef _DLL */
extern double _HUGE;
#endif	/* _DLL */
#else	/* ndef _NTSDK */
/* current definition */
_CRTIMP extern double _HUGE;
#endif	/* _NTSDK */

#define HUGE_VAL _HUGE


/* Function prototypes */

	int	__cdecl abs(int);
	double	__cdecl acos(double);
	double	__cdecl asin(double);
	double	__cdecl atan(double);
	double	__cdecl atan2(double, double);
_CRTIMP double	__cdecl atof(const char *);
_CRTIMP double	__cdecl _cabs(struct _complex);
_CRTIMP double	__cdecl ceil(double);
	double	__cdecl cos(double);
	double	__cdecl cosh(double);
	double	__cdecl exp(double);
	double	__cdecl fabs(double);
_CRTIMP double	__cdecl floor(double);
	double	__cdecl fmod(double, double);
_CRTIMP double	__cdecl frexp(double, int *);
_CRTIMP double	__cdecl _hypot(double, double);
_CRTIMP double	__cdecl _j0(double);
_CRTIMP double	__cdecl _j1(double);
_CRTIMP double	__cdecl _jn(int, double);
	long	__cdecl labs(long);
_CRTIMP double	__cdecl ldexp(double, int);
	double	__cdecl log(double);
	double	__cdecl log10(double);
_CRTIMP int	__cdecl _matherr(struct _exception *);
_CRTIMP double	__cdecl modf(double, double *);
	double	__cdecl pow(double, double);
	double	__cdecl sin(double);
	double	__cdecl sinh(double);
	double	__cdecl sqrt(double);
	double	__cdecl tan(double);
	double	__cdecl tanh(double);
_CRTIMP double	__cdecl _y0(double);
_CRTIMP double	__cdecl _y1(double);
_CRTIMP double	__cdecl _yn(int, double);


#ifdef _M_MRX000

/* MIPS fast prototypes for float */
/* ANSI C, 4.5 Mathematics             */

/* 4.5.2 Trigonometric functions */

float  __cdecl acosf( float );
float  __cdecl asinf( float );
float  __cdecl atanf( float );
float  __cdecl atan2f( float , float );
float  __cdecl cosf( float );
float  __cdecl sinf( float );
float  __cdecl tanf( float );

/* 4.5.3 Hyperbolic functions */
float  __cdecl coshf( float );
float  __cdecl sinhf( float );
float  __cdecl tanhf( float );

/* 4.5.4 Exponential and logarithmic functions */
float  __cdecl expf( float );
float  __cdecl logf( float );
float  __cdecl log10f( float );
float  __cdecl modff( float , float* );

/* 4.5.5 Power functions */
float  __cdecl powf( float , float );
float  __cdecl sqrtf( float );

/* 4.5.6 Nearest integer, absolute value, and remainder functions */
float  __cdecl ceilf( float );
float  __cdecl fabsf( float );
float  __cdecl floorf( float );
float  __cdecl fmodf( float , float );

#endif /* _M_MRX000 */


/* Macros defining long double functions to be their double counterparts
 * (long double is synonymous with double in this implementation).
 */

#define acosl(x)	((long double)acos((double)(x)))
#define asinl(x)	((long double)asin((double)(x)))
#define atanl(x)	((long double)atan((double)(x)))
#define atan2l(x,y)	((long double)atan2((double)(x), (double)(y)))
#define _cabsl		_cabs
#define ceill(x)	((long double)ceil((double)(x)))
#define cosl(x)		((long double)cos((double)(x)))
#define coshl(x)	((long double)cosh((double)(x)))
#define expl(x)		((long double)exp((double)(x)))
#define fabsl(x)	((long double)fabs((double)(x)))
#define floorl(x)	((long double)floor((double)(x)))
#define fmodl(x,y)	((long double)fmod((double)(x), (double)(y)))
#define frexpl(x,y)	((long double)frexp((double)(x), (y)))
#define _hypotl(x,y)	((long double)_hypot((double)(x), (double)(y)))
#define ldexpl(x,y)	((long double)ldexp((double)(x), (y)))
#define logl(x)		((long double)log((double)(x)))
#define log10l(x)	((long double)log10((double)(x)))
#define _matherrl	_matherr
#define modfl(x,y)	((long double)modf((double)(x), (double *)(y)))
#define powl(x,y)	((long double)pow((double)(x), (double)(y)))
#define sinl(x)		((long double)sin((double)(x)))
#define sinhl(x)	((long double)sinh((double)(x)))
#define sqrtl(x)	((long double)sqrt((double)(x)))
#define tanl(x)		((long double)tan((double)(x)))
#define tanhl(x)	((long double)tanh((double)(x)))

#if	!__STDC__

/* Non-ANSI names for compatibility */

#define DOMAIN		_DOMAIN
#define SING		_SING
#define OVERFLOW	_OVERFLOW
#define UNDERFLOW	_UNDERFLOW
#define TLOSS		_TLOSS
#define PLOSS		_PLOSS

#define matherr 	_matherr

#ifdef	_NTSDK

/* Definitions and declarations compatible with NT SDK */

#ifdef	_DLL
#define HUGE	(*HUGE_dll)
extern double * HUGE_dll;
#else	/* ndef _DLL */
extern double HUGE;
#endif	/* _DLL */

#define cabs		_cabs
#define hypot		_hypot
#define j0		_j0
#define j1		_j1
#define jn		_jn
#define matherr 	_matherr
#define y0		_y0
#define y1		_y1
#define yn		_yn

#else	/* ndef _NTSDK */

/* Current definitions and declarations */

_CRTIMP extern double HUGE;

_CRTIMP double	__cdecl cabs(struct complex);
_CRTIMP double	__cdecl hypot(double, double);
_CRTIMP double	__cdecl j0(double);
_CRTIMP double	__cdecl j1(double);
_CRTIMP double	__cdecl jn(int, double);
_CRTIMP int	__cdecl matherr(struct _exception *);
_CRTIMP double	__cdecl y0(double);
_CRTIMP double	__cdecl y1(double);
_CRTIMP double	__cdecl yn(int, double);

#endif	/* _NTSDK */

#endif	/* __STDC__ */

#ifdef __cplusplus
}
#endif

#endif	/* _INC_MATH */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\tools\c932\inc\nb30.h ===
//*++
//
// Copyright (c) 1991-1993  Microsoft Corporation
//
// Module Name:
//
//  nb30.h
//
// Abstract:
//
//  This module contains the definitions for portable NetBIOS 3.0
//  support.
//
// Author:
//
//  Colin Watson (ColinW) 06-Jun-1991
//
// Revision History:
//
//--*/

#ifndef NCB_INCLUDED
#define NCB_INCLUDED

#ifdef __cplusplus
extern "C" {
#endif

/****************************************************************
 *                                                              *
 *              Data structure templates                        *
 *                                                              *
 ****************************************************************/

#define NCBNAMSZ        16    /* absolute length of a net name                */
#define MAX_LANA        72    /* lana's in range 0 to MAX_LANA                */

/*
 * Network Control Block
 */

typedef struct _NCB {
    UCHAR   ncb_command;            /* command code                   */
    UCHAR   ncb_retcode;            /* return code                    */
    UCHAR   ncb_lsn;                /* local session number           */
    UCHAR   ncb_num;                /* number of our network name     */
    PUCHAR  ncb_buffer;             /* address of message buffer      */
    WORD    ncb_length;             /* size of message buffer         */
    UCHAR   ncb_callname[NCBNAMSZ]; /* blank-padded name of remote    */
    UCHAR   ncb_name[NCBNAMSZ];     /* our blank-padded netname       */
    UCHAR   ncb_rto;                /* rcv timeout/retry count        */
    UCHAR   ncb_sto;                /* send timeout/sys timeout       */
    void (CALLBACK *ncb_post)( struct _NCB * ); /* POST routine address        */
    UCHAR   ncb_lana_num;           /* lana (adapter) number          */
    UCHAR   ncb_cmd_cplt;           /* 0xff => commmand pending       */
    UCHAR   ncb_reserve[10];        /* reserved, used by BIOS         */
    HANDLE  ncb_event;              /* HANDLE to Win32 event which    */
                                    /* will be set to the signalled   */
                                    /* state when an ASYNCH command   */
                                    /* completes                      */
} NCB, *PNCB;

/*
 *  Structure returned to the NCB command NCBASTAT is ADAPTER_STATUS followed
 *  by an array of NAME_BUFFER structures.
 */

typedef struct _ADAPTER_STATUS {
    UCHAR   adapter_address[6];
    UCHAR   rev_major;
    UCHAR   reserved0;
    UCHAR   adapter_type;
    UCHAR   rev_minor;
    WORD    duration;
    WORD    frmr_recv;
    WORD    frmr_xmit;

    WORD    iframe_recv_err;

    WORD    xmit_aborts;
    DWORD   xmit_success;
    DWORD   recv_success;

    WORD    iframe_xmit_err;

    WORD    recv_buff_unavail;
    WORD    t1_timeouts;
    WORD    ti_timeouts;
    DWORD   reserved1;
    WORD    free_ncbs;
    WORD    max_cfg_ncbs;
    WORD    max_ncbs;
    WORD    xmit_buf_unavail;
    WORD    max_dgram_size;
    WORD    pending_sess;
    WORD    max_cfg_sess;
    WORD    max_sess;
    WORD    max_sess_pkt_size;
    WORD    name_count;
} ADAPTER_STATUS, *PADAPTER_STATUS;

typedef struct _NAME_BUFFER {
    UCHAR   name[NCBNAMSZ];
    UCHAR   name_num;
    UCHAR   name_flags;
} NAME_BUFFER, *PNAME_BUFFER;

//  values for name_flags bits.

#define NAME_FLAGS_MASK 0x87

#define GROUP_NAME      0x80
#define UNIQUE_NAME     0x00

#define REGISTERING     0x00
#define REGISTERED      0x04
#define DEREGISTERED    0x05
#define DUPLICATE       0x06
#define DUPLICATE_DEREG 0x07

/*
 *  Structure returned to the NCB command NCBSSTAT is SESSION_HEADER followed
 *  by an array of SESSION_BUFFER structures. If the NCB_NAME starts with an
 *  asterisk then an array of these structures is returned containing the
 *  status for all names.
 */

typedef struct _SESSION_HEADER {
    UCHAR   sess_name;
    UCHAR   num_sess;
    UCHAR   rcv_dg_outstanding;
    UCHAR   rcv_any_outstanding;
} SESSION_HEADER, *PSESSION_HEADER;

typedef struct _SESSION_BUFFER {
    UCHAR   lsn;
    UCHAR   state;
    UCHAR   local_name[NCBNAMSZ];
    UCHAR   remote_name[NCBNAMSZ];
    UCHAR   rcvs_outstanding;
    UCHAR   sends_outstanding;
} SESSION_BUFFER, *PSESSION_BUFFER;

//  Values for state

#define LISTEN_OUTSTANDING      0x01
#define CALL_PENDING            0x02
#define SESSION_ESTABLISHED     0x03
#define HANGUP_PENDING          0x04
#define HANGUP_COMPLETE         0x05
#define SESSION_ABORTED         0x06

/*
 *  Structure returned to the NCB command NCBENUM.
 *
 *  On a system containing lana's 0, 2 and 3, a structure with
 *  length =3, lana[0]=0, lana[1]=2 and lana[2]=3 will be returned.
 */

typedef struct _LANA_ENUM {
    UCHAR   length;         //  Number of valid entries in lana[]
    UCHAR   lana[MAX_LANA];
} LANA_ENUM, *PLANA_ENUM;

/*
 *  Structure returned to the NCB command NCBFINDNAME is FIND_NAME_HEADER followed
 *  by an array of FIND_NAME_BUFFER structures.
 */

typedef struct _FIND_NAME_HEADER {
    WORD    node_count;
    UCHAR   reserved;
    UCHAR   unique_group;
} FIND_NAME_HEADER, *PFIND_NAME_HEADER;

typedef struct _FIND_NAME_BUFFER {
    UCHAR   length;
    UCHAR   access_control;
    UCHAR   frame_control;
    UCHAR   destination_addr[6];
    UCHAR   source_addr[6];
    UCHAR   routing_info[18];
} FIND_NAME_BUFFER, *PFIND_NAME_BUFFER;

/*
 *  Structure provided with NCBACTION. The purpose of NCBACTION is to provide
 *  transport specific extensions to netbios.
 */

typedef struct _ACTION_HEADER {
    ULONG   transport_id;
    USHORT  action_code;
    USHORT  reserved;
} ACTION_HEADER, *PACTION_HEADER;

//  Values for transport_id

#define ALL_TRANSPORTS  "M\0\0\0"
#define MS_NBF          "MNBF"


/****************************************************************
 *                                                              *
 *              Special values and constants                    *
 *                                                              *
 ****************************************************************/

/*
 *      NCB Command codes
 */

#define NCBCALL         0x10            /* NCB CALL                           */
#define NCBLISTEN       0x11            /* NCB LISTEN                         */
#define NCBHANGUP       0x12            /* NCB HANG UP                        */
#define NCBSEND         0x14            /* NCB SEND                           */
#define NCBRECV         0x15            /* NCB RECEIVE                        */
#define NCBRECVANY      0x16            /* NCB RECEIVE ANY                    */
#define NCBCHAINSEND    0x17            /* NCB CHAIN SEND                     */
#define NCBDGSEND       0x20            /* NCB SEND DATAGRAM                  */
#define NCBDGRECV       0x21            /* NCB RECEIVE DATAGRAM               */
#define NCBDGSENDBC     0x22            /* NCB SEND BROADCAST DATAGRAM        */
#define NCBDGRECVBC     0x23            /* NCB RECEIVE BROADCAST DATAGRAM     */
#define NCBADDNAME      0x30            /* NCB ADD NAME                       */
#define NCBDELNAME      0x31            /* NCB DELETE NAME                    */
#define NCBRESET        0x32            /* NCB RESET                          */
#define NCBASTAT        0x33            /* NCB ADAPTER STATUS                 */
#define NCBSSTAT        0x34            /* NCB SESSION STATUS                 */
#define NCBCANCEL       0x35            /* NCB CANCEL                         */
#define NCBADDGRNAME    0x36            /* NCB ADD GROUP NAME                 */
#define NCBENUM         0x37            /* NCB ENUMERATE LANA NUMBERS         */
#define NCBUNLINK       0x70            /* NCB UNLINK                         */
#define NCBSENDNA       0x71            /* NCB SEND NO ACK                    */
#define NCBCHAINSENDNA  0x72            /* NCB CHAIN SEND NO ACK              */
#define NCBLANSTALERT   0x73            /* NCB LAN STATUS ALERT               */
#define NCBACTION       0x77            /* NCB ACTION                         */
#define NCBFINDNAME     0x78            /* NCB FIND NAME                      */
#define NCBTRACE        0x79            /* NCB TRACE                          */


#define ASYNCH          0x80            /* high bit set == asynchronous       */

/*
 *      NCB Return codes
 */

#define NRC_GOODRET     0x00    /* good return                                */
                                /* also returned when ASYNCH request accepted */
#define NRC_BUFLEN      0x01    /* illegal buffer length                      */
#define NRC_ILLCMD      0x03    /* illegal command                            */
#define NRC_CMDTMO      0x05    /* command timed out                          */
#define NRC_INCOMP      0x06    /* message incomplete, issue another command  */
#define NRC_BADDR       0x07    /* illegal buffer address                     */
#define NRC_SNUMOUT     0x08    /* session number out of range                */
#define NRC_NORES       0x09    /* no resource available                      */
#define NRC_SCLOSED     0x0a    /* session closed                             */
#define NRC_CMDCAN      0x0b    /* command cancelled                          */
#define NRC_DUPNAME     0x0d    /* duplicate name                             */
#define NRC_NAMTFUL     0x0e    /* name table full                            */
#define NRC_ACTSES      0x0f    /* no deletions, name has active sessions     */
#define NRC_LOCTFUL     0x11    /* local session table full                   */
#define NRC_REMTFUL     0x12    /* remote session table full                  */
#define NRC_ILLNN       0x13    /* illegal name number                        */
#define NRC_NOCALL      0x14    /* no callname                                */
#define NRC_NOWILD      0x15    /* cannot put * in NCB_NAME                   */
#define NRC_INUSE       0x16    /* name in use on remote adapter              */
#define NRC_NAMERR      0x17    /* name deleted                               */
#define NRC_SABORT      0x18    /* session ended abnormally                   */
#define NRC_NAMCONF     0x19    /* name conflict detected                     */
#define NRC_IFBUSY      0x21    /* interface busy, IRET before retrying       */
#define NRC_TOOMANY     0x22    /* too many commands outstanding, retry later */
#define NRC_BRIDGE      0x23    /* ncb_lana_num field invalid                 */
#define NRC_CANOCCR     0x24    /* command completed while cancel occurring   */
#define NRC_CANCEL      0x26    /* command not valid to cancel                */
#define NRC_DUPENV      0x30    /* name defined by anther local process       */
#define NRC_ENVNOTDEF   0x34    /* environment undefined. RESET required      */
#define NRC_OSRESNOTAV  0x35    /* required OS resources exhausted            */
#define NRC_MAXAPPS     0x36    /* max number of applications exceeded        */
#define NRC_NOSAPS      0x37    /* no saps available for netbios              */
#define NRC_NORESOURCES 0x38    /* requested resources are not available      */
#define NRC_INVADDRESS  0x39    /* invalid ncb address or length > segment    */
#define NRC_INVDDID     0x3B    /* invalid NCB DDID                           */
#define NRC_LOCKFAIL    0x3C    /* lock of user area failed                   */
#define NRC_OPENERR     0x3f    /* NETBIOS not loaded                         */
#define NRC_SYSTEM      0x40    /* system error                               */

#define NRC_PENDING     0xff    /* asynchronous command is not yet finished   */

/****************************************************************
 *                                                              *
 *              main user entry point for NetBIOS 3.0           *
 *                                                              *
 * Usage: result = Netbios( pncb );                             *
 ****************************************************************/

UCHAR
APIENTRY
Netbios(
    PNCB pncb
    );

/****************************************************************
 *                                                              *
 *              Prefix for callback routines                    *
 *                                                              *
 * Usage in a declaration: NCB_POST MyPostRoutine( PNCB pncb ); *
 ****************************************************************/

#define NCB_POST void CALLBACK

#ifdef __cplusplus
}
#endif

#endif /* NCB_INCLUDED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\tools\c932\inc\malloc.h ===
/***
*malloc.h - declarations and definitions for memory allocation functions
*
*	Copyright (c) 1985-1994, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	Contains the function declarations for memory allocation functions;
*	also defines manifest constants and types used by the heap routines.
*	[System V]
*
****/

#ifndef _INC_MALLOC
#define _INC_MALLOC

#ifdef	__cplusplus
extern "C" {
#endif


/* Define _CRTAPI1 (for compatibility with the NT SDK) */

#ifndef _CRTAPI1
#if	( (_MSC_VER >= 800) && (_M_IX86 >= 300) )
#define _CRTAPI1 __cdecl
#else
#define _CRTAPI1
#endif
#endif


/* Define _CRTAPI2 (for compatibility with the NT SDK) */

#ifndef _CRTAPI2
#if	( (_MSC_VER >= 800) && (_M_IX86 >= 300) )
#define _CRTAPI2 __cdecl
#else
#define _CRTAPI2
#endif
#endif


/* Define _CRTIMP */

#ifndef _CRTIMP
#ifdef	_NTSDK
/* definition compatible with NT SDK */
#define _CRTIMP
#else	/* ndef _NTSDK */
/* current definition */
#ifdef	_DLL
#define _CRTIMP __declspec(dllimport)
#else	/* ndef _DLL */
#define _CRTIMP
#endif	/* _DLL */
#endif	/* _NTSDK */
#endif	/* _CRTIMP */


/* Define __cdecl for non-Microsoft compilers */

#if	( !defined(_MSC_VER) && !defined(__cdecl) )
#define __cdecl
#endif


#ifndef _SIZE_T_DEFINED
typedef unsigned int size_t;
#define _SIZE_T_DEFINED
#endif

#ifndef _NTSDK

/* Maximum heap request the heap manager will attempt */

#define _HEAP_MAXREQ	0xFFFFD000


/* Constants for _heapchk/_heapset/_heapwalk routines */

#define _HEAPEMPTY	(-1)
#define _HEAPOK 	(-2)
#define _HEAPBADBEGIN	(-3)
#define _HEAPBADNODE	(-4)
#define _HEAPEND	(-5)
#define _HEAPBADPTR	(-6)
#define _FREEENTRY	0
#define _USEDENTRY	1


#ifndef _HEAPINFO_DEFINED
typedef struct _heapinfo {
	int * _pentry;
	size_t _size;
	int _useflag;
	} _HEAPINFO;
#define _HEAPINFO_DEFINED
#endif


/* External variable declarations */

#if	defined(_DLL) && defined(_M_IX86)

#define _amblksiz   (*__p__amblksiz())
_CRTIMP unsigned int * __cdecl __p__amblksiz(void);

#else	/* !(defined(_DLL) && defined(_M_IX86)) */

extern unsigned int _amblksiz;

#endif	/* defined(_DLL) && defined(_M_IX86) */

#endif	/* _NTSDK */


/* Function prototypes */

_CRTIMP void * __cdecl calloc(size_t, size_t);
_CRTIMP void   __cdecl free(void *);
_CRTIMP void * __cdecl malloc(size_t);
_CRTIMP void * __cdecl realloc(void *, size_t);

#ifndef _POSIX_

void * __cdecl _alloca(size_t);
_CRTIMP void * __cdecl _expand(void *, size_t);
#ifndef _NTSDK
_CRTIMP int __cdecl _heapadd(void *, size_t);
_CRTIMP int __cdecl _heapchk(void);
_CRTIMP int __cdecl _heapmin(void);
_CRTIMP int __cdecl _heapset(unsigned int);
_CRTIMP int __cdecl _heapwalk(_HEAPINFO *);
_CRTIMP size_t __cdecl _heapused(size_t *, size_t *);
#endif	/* _NTSDK */
_CRTIMP size_t __cdecl _msize(void *);

#if	!__STDC__
/* Non-ANSI names for compatibility */
#define alloca	_alloca
#endif	/* __STDC__*/

#ifdef	_M_MRX000
#pragma intrinsic(_alloca)
#endif

#endif	/* _POSIX_ */

#ifdef	__cplusplus
}
#endif


#endif	/* _INC_MALLOC */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\tools\c932\inc\memory.h ===
/***
*memory.h - declarations for buffer (memory) manipulation routines
*
*	Copyright (c) 1985-1994, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	This include file contains the function declarations for the
*	buffer (memory) manipulation routines.
*	[System V]
*
****/

#ifndef _INC_MEMORY
#define _INC_MEMORY

#ifdef __cplusplus
extern "C" {
#endif


/* Define _CRTAPI1 (for compatibility with the NT SDK) */

#ifndef _CRTAPI1
#if	( (_MSC_VER >= 800) && (_M_IX86 >= 300) )
#define _CRTAPI1 __cdecl
#else
#define _CRTAPI1
#endif
#endif


/* Define _CRTAPI2 (for compatibility with the NT SDK) */

#ifndef _CRTAPI2
#if	( (_MSC_VER >= 800) && (_M_IX86 >= 300) )
#define _CRTAPI2 __cdecl
#else
#define _CRTAPI2
#endif
#endif


/* Define _CRTIMP */

#ifndef _CRTIMP
#ifdef	_NTSDK
/* definition compatible with NT SDK */
#define _CRTIMP
#else	/* ndef _NTSDK */
/* current definition */
#ifdef	_DLL
#define _CRTIMP __declspec(dllimport)
#else	/* ndef _DLL */
#define _CRTIMP
#endif	/* _DLL */
#endif	/* _NTSDK */
#endif	/* _CRTIMP */


/* Define __cdecl for non-Microsoft compilers */

#if	( !defined(_MSC_VER) && !defined(__cdecl) )
#define __cdecl
#endif


#ifndef _SIZE_T_DEFINED
typedef unsigned int size_t;
#define _SIZE_T_DEFINED
#endif

/* Function prototypes */

_CRTIMP void * __cdecl _memccpy(void *, const void *, int, unsigned int);
_CRTIMP void * __cdecl memchr(const void *, int, size_t);
	int __cdecl memcmp(const void *, const void *, size_t);
	void * __cdecl memcpy(void *, const void *, size_t);
_CRTIMP int __cdecl _memicmp(const void *, const void *, unsigned int);
	void * __cdecl memset(void *, int, size_t);

#if !__STDC__

/* Non-ANSI names for compatibility */

#ifdef	_NTSDK
/* definitions compatible with the NT SDK */
#define memccpy  _memccpy
#define memicmp  _memicmp
#else	/* _NTSDK */
/* current declarations */
_CRTIMP void * __cdecl memccpy(void *, const void *, int, unsigned int);
_CRTIMP int __cdecl memicmp(const void *, const void *, unsigned int);
#endif	/* _NTSDK */

#endif	/* __STDC__ */

#ifdef __cplusplus
}
#endif

#endif	/* _INC_MEMORY */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\tools\c932\inc\nddesec.h ===
#ifndef          _INC_NDDESEC
#define          _INC_NDDESEC

#define NDDE_SHAREDB_ADD	   (0x00000001)
#define NDDE_SHAREDB_DELETE	   (0x00000002)
#define NDDE_SHAREDB_LIST	   (0x00000004)

#define NDDE_SHAREDB_ADMIN	(NDDE_SHAREDB_ADD |			\
			         NDDE_SHAREDB_DELETE |			\
				 NDDE_SHAREDB_LIST |			\
				 READ_CONTROL |				\
				 WRITE_DAC |				\
				 WRITE_OWNER)

#define NDDE_SHAREDB_OPER	(NDDE_SHAREDB_ADD |			\
			         NDDE_SHAREDB_DELETE |			\
				 NDDE_SHAREDB_LIST)

#define NDDE_SHAREDB_POWER	(NDDE_SHAREDB_ADD |			\
			         NDDE_SHAREDB_DELETE |			\
				 NDDE_SHAREDB_LIST)

#define NDDE_SHAREDB_USER	(NDDE_SHAREDB_ADD |			\
			         NDDE_SHAREDB_DELETE |			\
				 NDDE_SHAREDB_LIST)

#define NDDE_SHAREDB_EVERYONE	(NDDE_SHAREDB_LIST)

#define NDDE_SHARE_READ		   (0x00000001)
#define NDDE_SHARE_WRITE	   (0x00000002)
#define NDDE_SHARE_INITIATE_STATIC (0x00000004)
#define NDDE_SHARE_INITIATE_LINK   (0x00000008)
#define NDDE_SHARE_REQUEST	   (0x00000010)
#define NDDE_SHARE_ADVISE	   (0x00000020)
#define NDDE_SHARE_POKE		   (0x00000040)
#define NDDE_SHARE_EXECUTE	   (0x00000080)
#define NDDE_SHARE_ADD_ITEMS	   (0x00000100)
#define NDDE_SHARE_LIST_ITEMS	   (0x00000200)

#define NDDE_SHARE_GENERIC_READ	(NDDE_SHARE_READ |			\
			         NDDE_SHARE_INITIATE_STATIC |		\
				 NDDE_SHARE_REQUEST |			\
				 NDDE_SHARE_ADVISE |			\
				 NDDE_SHARE_LIST_ITEMS)

#define NDDE_SHARE_GENERIC_WRITE (NDDE_SHARE_INITIATE_STATIC |		\
			          NDDE_SHARE_INITIATE_LINK |		\
				  NDDE_SHARE_POKE |			\
				  DELETE)

#define NDDE_SHARE_GENERIC_EXECUTE (NDDE_SHARE_INITIATE_STATIC |	\
			            NDDE_SHARE_INITIATE_LINK |		\
				    NDDE_SHARE_EXECUTE)

#define NDDE_SHARE_GENERIC_ALL (NDDE_SHARE_READ |			\
				NDDE_SHARE_WRITE |			\
			        NDDE_SHARE_INITIATE_STATIC |		\
			        NDDE_SHARE_INITIATE_LINK |		\
				NDDE_SHARE_REQUEST |			\
				NDDE_SHARE_ADVISE |			\
				NDDE_SHARE_POKE |			\
				NDDE_SHARE_EXECUTE |			\
				NDDE_SHARE_ADD_ITEMS |			\
				NDDE_SHARE_LIST_ITEMS |			\
				DELETE |				\
				READ_CONTROL |				\
				WRITE_DAC |				\
				WRITE_OWNER)


#define NDDE_ITEM_REQUEST	   (0x00000001)
#define NDDE_ITEM_ADVISE	   (0x00000002)
#define NDDE_ITEM_POKE		   (0x00000004)

#define NDDE_ITEM_GENERIC_READ	  (NDDE_ITEM_REQUEST | NDDE_ITEM_ADVISE)
#define NDDE_ITEM_GENERIC_WRITE   (NDDE_ITEM_POKE)
#define NDDE_ITEM_GENERIC_EXECUTE (0)
#define NDDE_ITEM_GENERIC_ALL     (NDDE_ITEM_REQUEST |			\
				   NDDE_ITEM_ADVISE |			\
				   NDDE_ITEM_POKE |			\
				   DELETE |				\
				   READ_CONTROL |			\
				   WRITE_DAC |				\
				   WRITE_OWNER)

#define NDDE_GUI_NONE	  	(0)

#define NDDE_GUI_READ		(NDDE_SHARE_GENERIC_READ)

#define NDDE_GUI_READ_LINK	(NDDE_SHARE_GENERIC_READ |		\
				 NDDE_SHARE_INITIATE_LINK)

#define NDDE_GUI_CHANGE		(NDDE_SHARE_GENERIC_READ |		\
				 NDDE_SHARE_GENERIC_WRITE |		\
				 NDDE_SHARE_GENERIC_EXECUTE)

#define NDDE_GUI_FULL_CONTROL	(NDDE_SHARE_GENERIC_ALL)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\tools\c932\inc\new.h ===
/***
*new.h - declarations and definitions for C++ memory allocation functions
*
*	Copyright (c) 1990-1994, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	Contains the declarations for C++ memory allocation functions.
*
****/

#ifndef __INC_NEW
#define __INC_NEW


/* Define _CRTAPI1 (for compatibility with the NT SDK) */

#ifndef _CRTAPI1
#if	( (_MSC_VER >= 800) && (_M_IX86 >= 300) )
#define _CRTAPI1 __cdecl
#else
#define _CRTAPI1
#endif
#endif


/* Define _CRTAPI2 (for compatibility with the NT SDK) */

#ifndef _CRTAPI2
#if	( (_MSC_VER >= 800) && (_M_IX86 >= 300) )
#define _CRTAPI2 __cdecl
#else
#define _CRTAPI2
#endif
#endif


/* Define _CRTIMP */

#ifndef _CRTIMP
#ifdef	_NTSDK
/* definition compatible with NT SDK */
#define _CRTIMP
#else	/* ndef _NTSDK */
/* current definition */
#ifdef	_DLL
#define _CRTIMP __declspec(dllimport)
#else	/* ndef _DLL */
#define _CRTIMP
#endif	/* _DLL */
#endif	/* _NTSDK */
#endif	/* _CRTIMP */


/* Define __cdecl for non-Microsoft compilers */

#if	( !defined(_MSC_VER) && !defined(__cdecl) )
#define __cdecl
#endif


/* types and structures */

#ifndef _SIZE_T_DEFINED
typedef unsigned int size_t;
#define _SIZE_T_DEFINED
#endif

#ifndef _PNH_DEFINED
typedef int (__cdecl * _PNH)( size_t );
#define _PNH_DEFINED
#endif

/* function prototypes */

_CRTIMP int __cdecl _query_new_mode( void );
_CRTIMP int __cdecl _set_new_mode( int );
_CRTIMP _PNH __cdecl _query_new_handler( void );
_CRTIMP _PNH __cdecl set_new_handler( _PNH );
_CRTIMP _PNH __cdecl _set_new_handler( _PNH );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\tools\c932\inc\ntimage.h ===
/*++ BUILD Version: 0004    // Increment this if a change has global effects

Copyright (c) 1989-1993  Microsoft Corporation

Module Name:

    ntimage.h

Abstract:

    This is the include file that describes all image structures.

Author:

    Mike O'Leary (mikeol) 21-Mar-1991

Revision History:

--*/

#ifndef _NTIMAGE_
#define _NTIMAGE_

//
// Define the linker version number.  This is temporary to aid
// in debugging with people trying to load images built with
// an older linker.  This is not required in the final product.
//

#define IMAGE_MAJOR_LINKER_VERSION 2

// begin_winnt


//
// Image Format
//

#ifndef RC_INVOKED
#pragma pack (1)
#endif // !RC_INVOKED

#define IMAGE_DOS_SIGNATURE                 0x5A4D      // MZ
#define IMAGE_OS2_SIGNATURE                 0x454E      // NE
#define IMAGE_OS2_SIGNATURE_LE              0x454C      // LE
#define IMAGE_NT_SIGNATURE                  0x00004550  // PE00

typedef struct _IMAGE_DOS_HEADER {      // DOS .EXE header
    USHORT e_magic;                     // Magic number
    USHORT e_cblp;                      // Bytes on last page of file
    USHORT e_cp;                        // Pages in file
    USHORT e_crlc;                      // Relocations
    USHORT e_cparhdr;                   // Size of header in paragraphs
    USHORT e_minalloc;                  // Minimum extra paragraphs needed
    USHORT e_maxalloc;                  // Maximum extra paragraphs needed
    USHORT e_ss;                        // Initial (relative) SS value
    USHORT e_sp;                        // Initial SP value
    USHORT e_csum;                      // Checksum
    USHORT e_ip;                        // Initial IP value
    USHORT e_cs;                        // Initial (relative) CS value
    USHORT e_lfarlc;                    // File address of relocation table
    USHORT e_ovno;                      // Overlay number
    USHORT e_res[4];                    // Reserved words
    USHORT e_oemid;                     // OEM identifier (for e_oeminfo)
    USHORT e_oeminfo;                   // OEM information; e_oemid specific
    USHORT e_res2[10];                  // Reserved words
    LONG   e_lfanew;                    // File address of new exe header
  } IMAGE_DOS_HEADER, *PIMAGE_DOS_HEADER;

typedef struct _IMAGE_OS2_HEADER {      // OS/2 .EXE header
    USHORT ne_magic;                    // Magic number
    CHAR   ne_ver;                      // Version number
    CHAR   ne_rev;                      // Revision number
    USHORT ne_enttab;                   // Offset of Entry Table
    USHORT ne_cbenttab;                 // Number of bytes in Entry Table
    LONG   ne_crc;                      // Checksum of whole file
    USHORT ne_flags;                    // Flag word
    USHORT ne_autodata;                 // Automatic data segment number
    USHORT ne_heap;                     // Initial heap allocation
    USHORT ne_stack;                    // Initial stack allocation
    LONG   ne_csip;                     // Initial CS:IP setting
    LONG   ne_sssp;                     // Initial SS:SP setting
    USHORT ne_cseg;                     // Count of file segments
    USHORT ne_cmod;                     // Entries in Module Reference Table
    USHORT ne_cbnrestab;                // Size of non-resident name table
    USHORT ne_segtab;                   // Offset of Segment Table
    USHORT ne_rsrctab;                  // Offset of Resource Table
    USHORT ne_restab;                   // Offset of resident name table
    USHORT ne_modtab;                   // Offset of Module Reference Table
    USHORT ne_imptab;                   // Offset of Imported Names Table
    LONG   ne_nrestab;                  // Offset of Non-resident Names Table
    USHORT ne_cmovent;                  // Count of movable entries
    USHORT ne_align;                    // Segment alignment shift count
    USHORT ne_cres;                     // Count of resource segments
    UCHAR  ne_exetyp;                   // Target Operating system
    UCHAR  ne_flagsothers;              // Other .EXE flags
    USHORT ne_pretthunks;               // offset to return thunks
    USHORT ne_psegrefbytes;             // offset to segment ref. bytes
    USHORT ne_swaparea;                 // Minimum code swap area size
    USHORT ne_expver;                   // Expected Windows version number
  } IMAGE_OS2_HEADER, *PIMAGE_OS2_HEADER;

//
// File header format.
//

typedef struct _IMAGE_FILE_HEADER {
    USHORT  Machine;
    USHORT  NumberOfSections;
    ULONG   TimeDateStamp;
    ULONG   PointerToSymbolTable;
    ULONG   NumberOfSymbols;
    USHORT  SizeOfOptionalHeader;
    USHORT  Characteristics;
} IMAGE_FILE_HEADER, *PIMAGE_FILE_HEADER;

#define IMAGE_SIZEOF_FILE_HEADER             20

#define IMAGE_FILE_RELOCS_STRIPPED           0x0001  // Relocation info stripped from file.
#define IMAGE_FILE_EXECUTABLE_IMAGE          0x0002  // File is executable  (i.e. no unresolved externel references).
#define IMAGE_FILE_LINE_NUMS_STRIPPED        0x0004  // Line nunbers stripped from file.
#define IMAGE_FILE_LOCAL_SYMS_STRIPPED       0x0008  // Local symbols stripped from file.
#define IMAGE_FILE_MINIMAL_OBJECT            0x0010  // Reserved.
#define IMAGE_FILE_UPDATE_OBJECT             0x0020  // Reserved.
#define IMAGE_FILE_16BIT_MACHINE             0x0040  // 16 bit word machine.
#define IMAGE_FILE_BYTES_REVERSED_LO         0x0080  // Bytes of machine word are reversed.
#define IMAGE_FILE_32BIT_MACHINE             0x0100  // 32 bit word machine.
#define IMAGE_FILE_DEBUG_STRIPPED            0x0200  // Debugging info stripped from file in .DBG file
#define IMAGE_FILE_PATCH                     0x0400  // Reserved.
#define IMAGE_FILE_SYSTEM                    0x1000  // System File.
#define IMAGE_FILE_DLL                       0x2000  // File is a DLL.
#define IMAGE_FILE_BYTES_REVERSED_HI         0x8000  // Bytes of machine word are reversed.

#define IMAGE_FILE_MACHINE_UNKNOWN           0
#define IMAGE_FILE_MACHINE_I386              0x14c   // Intel 386.
#define IMAGE_FILE_MACHINE_R3000             0x162   // MIPS little-endian, 0540 big-endian
#define IMAGE_FILE_MACHINE_R4000             0x166   // MIPS little-endian
#define IMAGE_FILE_MACHINE_ALPHA             0x184   // Alpha_AXP

//
// Directory format.
//

typedef struct _IMAGE_DATA_DIRECTORY {
    ULONG   VirtualAddress;
    ULONG   Size;
} IMAGE_DATA_DIRECTORY, *PIMAGE_DATA_DIRECTORY;

#define IMAGE_NUMBEROF_DIRECTORY_ENTRIES    16

//
// Optional header format.
//

typedef struct _IMAGE_OPTIONAL_HEADER {
    //
    // Standard fields.
    //

    USHORT  Magic;
    UCHAR   MajorLinkerVersion;
    UCHAR   MinorLinkerVersion;
    ULONG   SizeOfCode;
    ULONG   SizeOfInitializedData;
    ULONG   SizeOfUninitializedData;
    ULONG   AddressOfEntryPoint;
    ULONG   BaseOfCode;
    ULONG   BaseOfData;

    //
    // NT additional fields.
    //

    ULONG   ImageBase;
    ULONG   SectionAlignment;
    ULONG   FileAlignment;
    USHORT  MajorOperatingSystemVersion;
    USHORT  MinorOperatingSystemVersion;
    USHORT  MajorImageVersion;
    USHORT  MinorImageVersion;
    USHORT  MajorSubsystemVersion;
    USHORT  MinorSubsystemVersion;
    ULONG   Reserved1;
    ULONG   SizeOfImage;
    ULONG   SizeOfHeaders;
    ULONG   CheckSum;
    USHORT  Subsystem;
    USHORT  DllCharacteristics;
    ULONG   SizeOfStackReserve;
    ULONG   SizeOfStackCommit;
    ULONG   SizeOfHeapReserve;
    ULONG   SizeOfHeapCommit;
    ULONG   LoaderFlags;
    ULONG   NumberOfRvaAndSizes;
    IMAGE_DATA_DIRECTORY DataDirectory[IMAGE_NUMBEROF_DIRECTORY_ENTRIES];
} IMAGE_OPTIONAL_HEADER, *PIMAGE_OPTIONAL_HEADER;

typedef struct _IMAGE_ROM_OPTIONAL_HEADER {
    USHORT Magic;
    UCHAR  MajorLinkerVersion;
    UCHAR  MinorLinkerVersion;
    ULONG  SizeOfCode;
    ULONG  SizeOfInitializedData;
    ULONG  SizeOfUninitializedData;
    ULONG  AddressOfEntryPoint;
    ULONG  BaseOfCode;
    ULONG  BaseOfData;
    ULONG  BaseOfBss;
    ULONG  GprMask;
    ULONG  CprMask[4];
    ULONG  GpValue;
} IMAGE_ROM_OPTIONAL_HEADER, *PIMAGE_ROM_OPTIONAL_HEADER;

#define IMAGE_SIZEOF_ROM_OPTIONAL_HEADER      56
#define IMAGE_SIZEOF_STD_OPTIONAL_HEADER      28
#define IMAGE_SIZEOF_NT_OPTIONAL_HEADER      224

#define IMAGE_NT_OPTIONAL_HDR_MAGIC        0x10b
#define IMAGE_ROM_OPTIONAL_HDR_MAGIC       0x107

typedef struct _IMAGE_NT_HEADERS {
    ULONG Signature;
    IMAGE_FILE_HEADER FileHeader;
    IMAGE_OPTIONAL_HEADER OptionalHeader;
} IMAGE_NT_HEADERS, *PIMAGE_NT_HEADERS;

typedef struct _IMAGE_ROM_HEADERS {
    IMAGE_FILE_HEADER FileHeader;
    IMAGE_ROM_OPTIONAL_HEADER OptionalHeader;
} IMAGE_ROM_HEADERS, *PIMAGE_ROM_HEADERS;

#define IMAGE_FIRST_SECTION( ntheader ) ((PIMAGE_SECTION_HEADER)        \
    ((ULONG)ntheader +                                                  \
     FIELD_OFFSET( IMAGE_NT_HEADERS, OptionalHeader ) +                 \
     ((PIMAGE_NT_HEADERS)(ntheader))->FileHeader.SizeOfOptionalHeader   \
    ))


// Subsystem Values

#define IMAGE_SUBSYSTEM_UNKNOWN              0   // Unknown subsystem.
#define IMAGE_SUBSYSTEM_NATIVE               1   // Image doesn't require a subsystem.
#define IMAGE_SUBSYSTEM_WINDOWS_GUI          2   // Image runs in the Windows GUI subsystem.
#define IMAGE_SUBSYSTEM_WINDOWS_CUI          3   // Image runs in the Windows character subsystem.
#define IMAGE_SUBSYSTEM_OS2_CUI              5   // image runs in the OS/2 character subsystem.
#define IMAGE_SUBSYSTEM_POSIX_CUI            7   // image run  in the Posix character subsystem.

// Dll Characteristics

#define IMAGE_LIBRARY_PROCESS_INIT           1   // Dll has a process initialization routine.
#define IMAGE_LIBRARY_PROCESS_TERM           2   // Dll has a thread termination routine.
#define IMAGE_LIBRARY_THREAD_INIT            4   // Dll has a thread initialization routine.
#define IMAGE_LIBRARY_THREAD_TERM            8   // Dll has a thread termination routine.

//
// Loader Flags
//

#define IMAGE_LOADER_FLAGS_BREAK_ON_LOAD    0x00000001
#define IMAGE_LOADER_FLAGS_DEBUG_ON_LOAD    0x00000002


// Directory Entries

#define IMAGE_DIRECTORY_ENTRY_EXPORT         0   // Export Directory
#define IMAGE_DIRECTORY_ENTRY_IMPORT         1   // Import Directory
#define IMAGE_DIRECTORY_ENTRY_RESOURCE       2   // Resource Directory
#define IMAGE_DIRECTORY_ENTRY_EXCEPTION      3   // Exception Directory
#define IMAGE_DIRECTORY_ENTRY_SECURITY       4   // Security Directory
#define IMAGE_DIRECTORY_ENTRY_BASERELOC      5   // Base Relocation Table
#define IMAGE_DIRECTORY_ENTRY_DEBUG          6   // Debug Directory
#define IMAGE_DIRECTORY_ENTRY_COPYRIGHT      7   // Description String
#define IMAGE_DIRECTORY_ENTRY_GLOBALPTR      8   // Machine Value (MIPS GP)
#define IMAGE_DIRECTORY_ENTRY_TLS            9   // TLS Directory
#define IMAGE_DIRECTORY_ENTRY_LOAD_CONFIG   10   // Load Configuration Directory

//
// Section header format.
//

#define IMAGE_SIZEOF_SHORT_NAME              8

typedef struct _IMAGE_SECTION_HEADER {
    UCHAR   Name[IMAGE_SIZEOF_SHORT_NAME];
    union {
            ULONG   PhysicalAddress;
            ULONG   VirtualSize;
    } Misc;
    ULONG   VirtualAddress;
    ULONG   SizeOfRawData;
    ULONG   PointerToRawData;
    ULONG   PointerToRelocations;
    ULONG   PointerToLinenumbers;
    USHORT  NumberOfRelocations;
    USHORT  NumberOfLinenumbers;
    ULONG   Characteristics;
} IMAGE_SECTION_HEADER, *PIMAGE_SECTION_HEADER;

#define IMAGE_SIZEOF_SECTION_HEADER          40

#define IMAGE_SCN_TYPE_REGULAR               0x00000000  //
#define IMAGE_SCN_TYPE_DUMMY                 0x00000001  // Reserved.
#define IMAGE_SCN_TYPE_NO_LOAD               0x00000002  // Reserved.
#define IMAGE_SCN_TYPE_GROUPED               0x00000004  // Used for 16-bit offset code.
#define IMAGE_SCN_TYPE_NO_PAD                0x00000008  // Reserved.
#define IMAGE_SCN_TYPE_COPY                  0x00000010  // Reserved.

#define IMAGE_SCN_CNT_CODE                   0x00000020  // Section contains code.
#define IMAGE_SCN_CNT_INITIALIZED_DATA       0x00000040  // Section contains initialized data.
#define IMAGE_SCN_CNT_UNINITIALIZED_DATA     0x00000080  // Section contains uninitialized data.

#define IMAGE_SCN_LNK_OTHER                  0x00000100  // Reserved.
#define IMAGE_SCN_LNK_INFO                   0x00000200  // Section contains comments or some other type of information.
#define IMAGE_SCN_LNK_OVERLAY                0x00000400  // Section contains an overlay.
#define IMAGE_SCN_LNK_REMOVE                 0x00000800  // Section contents will not become part of image.
#define IMAGE_SCN_LNK_COMDAT                 0x00001000  // Section contents comdat.

#define IMAGE_SCN_ALIGN_1BYTES               0x00100000  //
#define IMAGE_SCN_ALIGN_2BYTES               0x00200000  //
#define IMAGE_SCN_ALIGN_4BYTES               0x00300000  //
#define IMAGE_SCN_ALIGN_8BYTES               0x00400000  //
#define IMAGE_SCN_ALIGN_16BYTES              0x00500000  // Default alignment if no others are specified.
#define IMAGE_SCN_ALIGN_32BYTES              0x00600000  //
#define IMAGE_SCN_ALIGN_64BYTES              0x00700000  //

#define IMAGE_SCN_MEM_DISCARDABLE            0x02000000  // Section can be discarded.
#define IMAGE_SCN_MEM_NOT_CACHED             0x04000000  // Section is not cachable.
#define IMAGE_SCN_MEM_NOT_PAGED              0x08000000  // Section is not pageable.
#define IMAGE_SCN_MEM_SHARED                 0x10000000  // Section is shareable.
#define IMAGE_SCN_MEM_EXECUTE                0x20000000  // Section is executable.
#define IMAGE_SCN_MEM_READ                   0x40000000  // Section is readable.
#define IMAGE_SCN_MEM_WRITE                  0x80000000  // Section is writeable.

//
// Symbol format.
//

typedef struct _IMAGE_SYMBOL {
    union {
        UCHAR   ShortName[8];
        struct {
            ULONG   Short;     // if 0, use LongName
            ULONG   Long;      // offset into string table
        } Name;
        PUCHAR  LongName[2];
    } N;
    ULONG   Value;
    SHORT   SectionNumber;
    USHORT  Type;
    UCHAR   StorageClass;
    UCHAR   NumberOfAuxSymbols;
} IMAGE_SYMBOL;
typedef IMAGE_SYMBOL UNALIGNED *PIMAGE_SYMBOL;

#define IMAGE_SIZEOF_SYMBOL                  18

//
// Section values.
//
// Symbols have a section number of the section in which they are
// defined. Otherwise, section numbers have the following meanings:
//

#define IMAGE_SYM_UNDEFINED           (SHORT)0           // Symbol is undefined or is common.
#define IMAGE_SYM_ABSOLUTE            (SHORT)-1          // Symbol is an absolute value.
#define IMAGE_SYM_DEBUG               (SHORT)-2          // Symbol is a special debug item.

//
// Type (fundamental) values.
//

#define IMAGE_SYM_TYPE_NULL                  0           // no type.
#define IMAGE_SYM_TYPE_VOID                  1           //
#define IMAGE_SYM_TYPE_CHAR                  2           // type character.
#define IMAGE_SYM_TYPE_SHORT                 3           // type short integer.
#define IMAGE_SYM_TYPE_INT                   4           //
#define IMAGE_SYM_TYPE_LONG                  5           //
#define IMAGE_SYM_TYPE_FLOAT                 6           //
#define IMAGE_SYM_TYPE_DOUBLE                7           //
#define IMAGE_SYM_TYPE_STRUCT                8           //
#define IMAGE_SYM_TYPE_UNION                 9           //
#define IMAGE_SYM_TYPE_ENUM                  10          // enumeration.
#define IMAGE_SYM_TYPE_MOE                   11          // member of enumeration.
#define IMAGE_SYM_TYPE_UCHAR                 12          //
#define IMAGE_SYM_TYPE_USHORT                13          //
#define IMAGE_SYM_TYPE_UINT                  14          //
#define IMAGE_SYM_TYPE_ULONG                 15          //

//
// Type (derived) values.
//

#define IMAGE_SYM_DTYPE_NULL                 0           // no derived type.
#define IMAGE_SYM_DTYPE_POINTER              1           // pointer.
#define IMAGE_SYM_DTYPE_FUNCTION             2           // function.
#define IMAGE_SYM_DTYPE_ARRAY                3           // array.

//
// Storage classes.
//

#define IMAGE_SYM_CLASS_END_OF_FUNCTION      (UCHAR)-1
#define IMAGE_SYM_CLASS_NULL                 0
#define IMAGE_SYM_CLASS_AUTOMATIC            1
#define IMAGE_SYM_CLASS_EXTERNAL             2
#define IMAGE_SYM_CLASS_STATIC               3
#define IMAGE_SYM_CLASS_REGISTER             4
#define IMAGE_SYM_CLASS_EXTERNAL_DEF         5
#define IMAGE_SYM_CLASS_LABEL                6
#define IMAGE_SYM_CLASS_UNDEFINED_LABEL      7
#define IMAGE_SYM_CLASS_MEMBER_OF_STRUCT     8
#define IMAGE_SYM_CLASS_ARGUMENT             9
#define IMAGE_SYM_CLASS_STRUCT_TAG           10
#define IMAGE_SYM_CLASS_MEMBER_OF_UNION      11
#define IMAGE_SYM_CLASS_UNION_TAG            12
#define IMAGE_SYM_CLASS_TYPE_DEFINITION      13
#define IMAGE_SYM_CLASS_UNDEFINED_STATIC     14
#define IMAGE_SYM_CLASS_ENUM_TAG             15
#define IMAGE_SYM_CLASS_MEMBER_OF_ENUM       16
#define IMAGE_SYM_CLASS_REGISTER_PARAM       17
#define IMAGE_SYM_CLASS_BIT_FIELD            18
#define IMAGE_SYM_CLASS_BLOCK                100
#define IMAGE_SYM_CLASS_FUNCTION             101
#define IMAGE_SYM_CLASS_END_OF_STRUCT        102
#define IMAGE_SYM_CLASS_FILE                 103
// new
#define IMAGE_SYM_CLASS_SECTION              104
#define IMAGE_SYM_CLASS_WEAK_EXTERNAL        105

// type packing constants

#define N_BTMASK                            017
#define N_TMASK                             060
#define N_TMASK1                            0300
#define N_TMASK2                            0360
#define N_BTSHFT                            4
#define N_TSHIFT                            2

// MACROS

// Basic Type of  x
#define BTYPE(x) ((x) & N_BTMASK)

// Is x a pointer?
#ifndef ISPTR
#define ISPTR(x) (((x) & N_TMASK) == (IMAGE_SYM_DTYPE_POINTER << N_BTSHFT))
#endif

// Is x a function?
#ifndef ISFCN
#define ISFCN(x) (((x) & N_TMASK) == (IMAGE_SYM_DTYPE_FUNCTION << N_BTSHFT))
#endif

// Is x an array?

#ifndef ISARY
#define ISARY(x) (((x) & N_TMASK) == (IMAGE_SYM_DTYPE_ARRAY << N_BTSHFT))
#endif

// Is x a structure, union, or enumeration TAG?
#ifndef ISTAG
#define ISTAG(x) ((x)==IMAGE_SYM_CLASS_STRUCT_TAG || (x)==IMAGE_SYM_CLASS_UNION_TAG || (x)==IMAGE_SYM_CLASS_ENUM_TAG)
#endif

#ifndef INCREF
#define INCREF(x) ((((x)&~N_BTMASK)<<N_TSHIFT)|(IMAGE_SYM_DTYPE_POINTER<<N_BTSHFT)|((x)&N_BTMASK))
#endif
#ifndef DECREF
#define DECREF(x) ((((x)>>N_TSHIFT)&~N_BTMASK)|((x)&N_BTMASK))
#endif

//
// Auxiliary entry format.
//

typedef union _IMAGE_AUX_SYMBOL {
    struct {
        ULONG    TagIndex;                      // struct, union, or enum tag index
        union {
            struct {
                USHORT  Linenumber;             // declaration line number
                USHORT  Size;                   // size of struct, union, or enum
            } LnSz;
           ULONG    TotalSize;
        } Misc;
        union {
            struct {                            // if ISFCN, tag, or .bb
                ULONG    PointerToLinenumber;
                ULONG    PointerToNextFunction;
            } Function;
            struct {                            // if ISARY, up to 4 dimen.
                USHORT   Dimension[4];
            } Array;
        } FcnAry;
        USHORT  TvIndex;                        // tv index
    } Sym;
    struct {
        UCHAR   Name[IMAGE_SIZEOF_SYMBOL];
    } File;
    struct {
        ULONG   Length;                         // section length
        USHORT  NumberOfRelocations;            // number of relocation entries
        USHORT  NumberOfLinenumbers;            // number of line numbers
        ULONG   CheckSum;                       // checksum for communal
        SHORT   Number;                         // section number to associate with
        UCHAR   Selection;                      // communal selection type
    } Section;
} IMAGE_AUX_SYMBOL;
typedef IMAGE_AUX_SYMBOL UNALIGNED *PIMAGE_AUX_SYMBOL;

#define IMAGE_SIZEOF_AUX_SYMBOL              18

//
// Communal selection types.
//

#define IMAGE_COMDAT_SELECT_UNKNOWN        0
#define IMAGE_COMDAT_SELECT_NODUPLICATES   1
#define IMAGE_COMDAT_SELECT_ANY            2
#define IMAGE_COMDAT_SELECT_SAME_SIZE      3
#define IMAGE_COMDAT_SELECT_EXACT_MATCH    4
#define IMAGE_COMDAT_SELECT_ASSOCIATIVE    5

#define IMAGE_WEAK_EXTERN_SEARCH_UNKNOWN   0
#define IMAGE_WEAK_EXTERN_SEARCH_NOLIBRARY 1
#define IMAGE_WEAK_EXTERN_SEARCH_LIBRARY   2


//
// Relocation format.
//

typedef struct _IMAGE_RELOCATION {
    ULONG   VirtualAddress;
    ULONG   SymbolTableIndex;
    USHORT  Type;
} IMAGE_RELOCATION;
typedef IMAGE_RELOCATION UNALIGNED *PIMAGE_RELOCATION;

#define IMAGE_SIZEOF_RELOCATION              10

//
// I386 relocation types.
//

#define IMAGE_REL_I386_ABSOLUTE              0           // Reference is absolute, no relocation is necessary
#define IMAGE_REL_I386_DIR16                 01          // Direct 16-bit reference to the symbols virtual address
#define IMAGE_REL_I386_REL16                 02          // PC-relative 16-bit reference to the symbols virtual address
#define IMAGE_REL_I386_DIR32                 06          // Direct 32-bit reference to the symbols virtual address
#define IMAGE_REL_I386_DIR32NB               07          // Direct 32-bit reference to the symbols virtual address, base not included
#define IMAGE_REL_I386_SEG12                 011         // Direct 16-bit reference to the segment-selector bits of a 32-bit virtual address
#define IMAGE_REL_I386_SECTION               012
#define IMAGE_REL_I386_SECREL                013
#define IMAGE_REL_I386_REL32                 024         // PC-relative 32-bit reference to the symbols virtual address

//
// MIPS relocation types.
//

#define IMAGE_REL_MIPS_ABSOLUTE              0           // Reference is absolute, no relocation is necessary
#define IMAGE_REL_MIPS_REFHALF               01
#define IMAGE_REL_MIPS_REFWORD               02
#define IMAGE_REL_MIPS_JMPADDR               03
#define IMAGE_REL_MIPS_REFHI                 04
#define IMAGE_REL_MIPS_REFLO                 05
#define IMAGE_REL_MIPS_GPREL                 06
#define IMAGE_REL_MIPS_LITERAL               07
#define IMAGE_REL_MIPS_SECTION               012
#define IMAGE_REL_MIPS_SECREL                013
#define IMAGE_REL_MIPS_REFWORDNB             042
#define IMAGE_REL_MIPS_PAIR                  045

//
// Alpha Relocation types.
//

#define IMAGE_REL_ALPHA_ABSOLUTE             0x0
#define IMAGE_REL_ALPHA_REFLONG              0x1
#define IMAGE_REL_ALPHA_REFQUAD              0x2
#define IMAGE_REL_ALPHA_GPREL32              0x3
#define IMAGE_REL_ALPHA_LITERAL              0x4
#define IMAGE_REL_ALPHA_LITUSE               0x5
#define IMAGE_REL_ALPHA_GPDISP               0x6
#define IMAGE_REL_ALPHA_BRADDR               0x7
#define IMAGE_REL_ALPHA_HINT                 0x8
#define IMAGE_REL_ALPHA_INLINE_REFLONG       0x9
#define IMAGE_REL_ALPHA_REFHI                0xA
#define IMAGE_REL_ALPHA_REFLO                0xB
#define IMAGE_REL_ALPHA_PAIR                 0xC
#define IMAGE_REL_ALPHA_MATCH                0xD
#define IMAGE_REL_ALPHA_SECTION              0xE
#define IMAGE_REL_ALPHA_SECREL               0xF
#define IMAGE_REL_ALPHA_REFLONGNB            0x10

//
// Based relocation format.
//

typedef struct _IMAGE_BASE_RELOCATION {
    ULONG   VirtualAddress;
    ULONG   SizeOfBlock;
//  USHORT  TypeOffset[1];
} IMAGE_BASE_RELOCATION, *PIMAGE_BASE_RELOCATION;

#define IMAGE_SIZEOF_BASE_RELOCATION         8

//
// Based relocation types.
//

#define IMAGE_REL_BASED_ABSOLUTE              0
#define IMAGE_REL_BASED_HIGH                  1
#define IMAGE_REL_BASED_LOW                   2
#define IMAGE_REL_BASED_HIGHLOW               3
#define IMAGE_REL_BASED_HIGHADJ               4
#define IMAGE_REL_BASED_MIPS_JMPADDR          5

//
// Line number format.
//

typedef struct _IMAGE_LINENUMBER {
    union {
        ULONG   SymbolTableIndex;                       // Symbol table index of function name if Linenumber is 0.
        ULONG   VirtualAddress;                         // Virtual address of line number.
    } Type;
    USHORT  Linenumber;                                 // Line number.
} IMAGE_LINENUMBER;
typedef IMAGE_LINENUMBER UNALIGNED *PIMAGE_LINENUMBER;

#define IMAGE_SIZEOF_LINENUMBER              6

//
// Archive format.
//

#define IMAGE_ARCHIVE_START_SIZE             8
#define IMAGE_ARCHIVE_START                  "!<arch>\n"
#define IMAGE_ARCHIVE_END                    "`\n"
#define IMAGE_ARCHIVE_PAD                    "\n"
#define IMAGE_ARCHIVE_LINKER_MEMBER          "/               "
#define IMAGE_ARCHIVE_LONGNAMES_MEMBER       "//              "

typedef struct _IMAGE_ARCHIVE_MEMBER_HEADER {
    UCHAR    Name[16];                                  // File member name - `/' terminated.
    UCHAR    Date[12];                                  // File member date - decimal.
    UCHAR    UserID[6];                                 // File member user id - decimal.
    UCHAR    GroupID[6];                                // File member group id - decimal.
    UCHAR    Mode[8];                                   // File member mode - octal.
    UCHAR    Size[10];                                  // File member size - decimal.
    UCHAR    EndHeader[2];                              // String to end header.
} IMAGE_ARCHIVE_MEMBER_HEADER, *PIMAGE_ARCHIVE_MEMBER_HEADER;

#define IMAGE_SIZEOF_ARCHIVE_MEMBER_HDR      60

//
// DLL support.
//

//
// Export Format
//

typedef struct _IMAGE_EXPORT_DIRECTORY {
    ULONG   Characteristics;
    ULONG   TimeDateStamp;
    USHORT  MajorVersion;
    USHORT  MinorVersion;
    ULONG   Name;
    ULONG   Base;
    ULONG   NumberOfFunctions;
    ULONG   NumberOfNames;
    PULONG  *AddressOfFunctions;
    PULONG  *AddressOfNames;
    PUSHORT *AddressOfNameOrdinals;
} IMAGE_EXPORT_DIRECTORY, *PIMAGE_EXPORT_DIRECTORY;

//
// Import Format
//

typedef struct _IMAGE_IMPORT_BY_NAME {
    USHORT  Hint;
    UCHAR   Name[1];
} IMAGE_IMPORT_BY_NAME, *PIMAGE_IMPORT_BY_NAME;

typedef struct _IMAGE_THUNK_DATA {
    union {
        PULONG Function;
        ULONG Ordinal;
        PIMAGE_IMPORT_BY_NAME AddressOfData;
    } u1;
} IMAGE_THUNK_DATA, *PIMAGE_THUNK_DATA;

#define IMAGE_ORDINAL_FLAG 0x80000000
#define IMAGE_SNAP_BY_ORDINAL(Ordinal) ((Ordinal & IMAGE_ORDINAL_FLAG) != 0)
#define IMAGE_ORDINAL(Ordinal) (Ordinal & 0xffff)

typedef struct _IMAGE_IMPORT_DESCRIPTOR {
    ULONG   Characteristics;
    ULONG   TimeDateStamp;
    ULONG   ForwarderChain;
    ULONG   Name;
    PIMAGE_THUNK_DATA FirstThunk;
} IMAGE_IMPORT_DESCRIPTOR, *PIMAGE_IMPORT_DESCRIPTOR;

//
// Thread Local Storage
//

typedef VOID
(NTAPI *PIMAGE_TLS_CALLBACK) (
    PVOID DllHandle,
    ULONG Reason,
    PVOID Reserved
    );

typedef struct _IMAGE_TLS_DIRECTORY {
    ULONG   StartAddressOfRawData;
    ULONG   EndAddressOfRawData;
    PULONG  AddressOfIndex;
    PIMAGE_TLS_CALLBACK *AddressOfCallBacks;
    ULONG   SizeOfZeroFill;
    ULONG   Characteristics;
} IMAGE_TLS_DIRECTORY, *PIMAGE_TLS_DIRECTORY;


//
// Resource Format.
//

//
// Resource directory consists of two counts, following by a variable length
// array of directory entries.  The first count is the number of entries at
// beginning of the array that have actual names associated with each entry.
// The entries are in ascending order, case insensitive strings.  The second
// count is the number of entries that immediately follow the named entries.
// This second count identifies the number of entries that have 31-bit integer
// Ids as their name.  These entries are also sorted in ascending order.
//
// This structure allows fast lookup by either name or number, but for any
// given resource entry only one form of lookup is supported, not both.
// This is consistant with the syntax of the .RC file and the .RES file.
//

typedef struct _IMAGE_RESOURCE_DIRECTORY {
    ULONG   Characteristics;
    ULONG   TimeDateStamp;
    USHORT  MajorVersion;
    USHORT  MinorVersion;
    USHORT  NumberOfNamedEntries;
    USHORT  NumberOfIdEntries;
//  IMAGE_RESOURCE_DIRECTORY_ENTRY DirectoryEntries[];
} IMAGE_RESOURCE_DIRECTORY, *PIMAGE_RESOURCE_DIRECTORY;

#define IMAGE_RESOURCE_NAME_IS_STRING        0x80000000
#define IMAGE_RESOURCE_DATA_IS_DIRECTORY     0x80000000

//
// Each directory contains the 32-bit Name of the entry and an offset,
// relative to the beginning of the resource directory of the data associated
// with this directory entry.  If the name of the entry is an actual text
// string instead of an integer Id, then the high order bit of the name field
// is set to one and the low order 31-bits are an offset, relative to the
// beginning of the resource directory of the string, which is of type
// IMAGE_RESOURCE_DIRECTORY_STRING.  Otherwise the high bit is clear and the
// low-order 31-bits are the integer Id that identify this resource directory
// entry. If the directory entry is yet another resource directory (i.e. a
// subdirectory), then the high order bit of the offset field will be
// set to indicate this.  Otherwise the high bit is clear and the offset
// field points to a resource data entry.
//

typedef struct _IMAGE_RESOURCE_DIRECTORY_ENTRY {
    ULONG   Name;
    ULONG   OffsetToData;
} IMAGE_RESOURCE_DIRECTORY_ENTRY, *PIMAGE_RESOURCE_DIRECTORY_ENTRY;

//
// For resource directory entries that have actual string names, the Name
// field of the directory entry points to an object of the following type.
// All of these string objects are stored together after the last resource
// directory entry and before the first resource data object.  This minimizes
// the impact of these variable length objects on the alignment of the fixed
// size directory entry objects.
//

typedef struct _IMAGE_RESOURCE_DIRECTORY_STRING {
    USHORT  Length;
    CHAR    NameString[ 1 ];
} IMAGE_RESOURCE_DIRECTORY_STRING, *PIMAGE_RESOURCE_DIRECTORY_STRING;


typedef struct _IMAGE_RESOURCE_DIR_STRING_U {
    USHORT  Length;
    WCHAR   NameString[ 1 ];
} IMAGE_RESOURCE_DIR_STRING_U, *PIMAGE_RESOURCE_DIR_STRING_U;


//
// Each resource data entry describes a leaf node in the resource directory
// tree.  It contains an offset, relative to the beginning of the resource
// directory of the data for the resource, a size field that gives the number
// of bytes of data at that offset, a CodePage that should be used when
// decoding code point values within the resource data.  Typically for new
// applications the code page would be the unicode code page.
//

typedef struct _IMAGE_RESOURCE_DATA_ENTRY {
    ULONG   OffsetToData;
    ULONG   Size;
    ULONG   CodePage;
    ULONG   Reserved;
} IMAGE_RESOURCE_DATA_ENTRY, *PIMAGE_RESOURCE_DATA_ENTRY;

//
// Load Configuration Directory Entry
//

typedef struct _IMAGE_LOAD_CONFIG_DIRECTORY {
    ULONG   Characteristics;
    ULONG   TimeDateStamp;
    USHORT  MajorVersion;
    USHORT  MinorVersion;
    ULONG   GlobalFlagsClear;
    ULONG   GlobalFlagsSet;
    ULONG   CriticalSectionDefaultTimeout;
    ULONG   DeCommitFreeBlockThreshold;
    ULONG   DeCommitTotalFreeThreshold;
    PVOID   LockPrefixTable;
    ULONG   MaximumAllocationSize;
    ULONG   VirtualMemoryThreshold;
    ULONG   Reserved[ 5 ];
} IMAGE_LOAD_CONFIG_DIRECTORY, *PIMAGE_LOAD_CONFIG_DIRECTORY;


//
// Function table entry format for MIPS/ALPHA images.  Function table is
// pointed to by the IMAGE_DIRECTORY_ENTRY_EXCEPTION directory entry.
// This definition duplicates ones in ntmips.h and ntalpha.h for use
// by portable image file mungers.
//

typedef struct _IMAGE_RUNTIME_FUNCTION_ENTRY {
    ULONG BeginAddress;
    ULONG EndAddress;
    PVOID ExceptionHandler;
    PVOID HandlerData;
    ULONG PrologEndAddress;
} IMAGE_RUNTIME_FUNCTION_ENTRY, *PIMAGE_RUNTIME_FUNCTION_ENTRY;

//
// Debug Format
//

typedef struct _IMAGE_DEBUG_DIRECTORY {
    ULONG   Characteristics;
    ULONG   TimeDateStamp;
    USHORT  MajorVersion;
    USHORT  MinorVersion;
    ULONG   Type;
    ULONG   SizeOfData;
    ULONG   AddressOfRawData;
    ULONG   PointerToRawData;
} IMAGE_DEBUG_DIRECTORY, *PIMAGE_DEBUG_DIRECTORY;

#define IMAGE_DEBUG_TYPE_UNKNOWN          0
#define IMAGE_DEBUG_TYPE_COFF             1
#define IMAGE_DEBUG_TYPE_CODEVIEW         2
#define IMAGE_DEBUG_TYPE_FPO              3
#define IMAGE_DEBUG_TYPE_MISC             4
#define IMAGE_DEBUG_TYPE_EXCEPTION        5
#define IMAGE_DEBUG_TYPE_FIXUP            6
#define IMAGE_DEBUG_TYPE_OMAP_TO_SRC      7
#define IMAGE_DEBUG_TYPE_OMAP_FROM_SRC    8

typedef struct _IMAGE_COFF_SYMBOLS_HEADER {
    ULONG   NumberOfSymbols;
    ULONG   LvaToFirstSymbol;
    ULONG   NumberOfLinenumbers;
    ULONG   LvaToFirstLinenumber;
    ULONG   RvaToFirstByteOfCode;
    ULONG   RvaToLastByteOfCode;
    ULONG   RvaToFirstByteOfData;
    ULONG   RvaToLastByteOfData;
} IMAGE_COFF_SYMBOLS_HEADER, *PIMAGE_COFF_SYMBOLS_HEADER;

#define FRAME_FPO   0
#define FRAME_TRAP  1
#define FRAME_TSS   2

typedef struct _FPO_DATA {
    ULONG       ulOffStart;             // offset 1st byte of function code
    ULONG       cbProcSize;             // # bytes in function
    ULONG       cdwLocals;              // # bytes in locals/4
    USHORT      cdwParams;              // # bytes in params/4
    USHORT      cbProlog : 8;           // # bytes in prolog
    USHORT      cbRegs   : 3;           // # regs saved
    USHORT      fHasSEH  : 1;           // TRUE if SEH in func
    USHORT      fUseBP   : 1;           // TRUE if EBP has been allocated
    USHORT      reserved : 1;           // reserved for future use
    USHORT      cbFrame  : 2;           // frame type
} FPO_DATA, *PFPO_DATA;
#define SIZEOF_RFPO_DATA 16


#define IMAGE_DEBUG_MISC_EXENAME    1

typedef struct _IMAGE_DEBUG_MISC {
    ULONG       DataType;               // type of misc data, see defines
    ULONG       Length;                 // total length of record, rounded to four
                                        // byte multiple.
    BOOLEAN     Unicode;                // TRUE if data is unicode string
    UCHAR       Reserved[ 3 ];
    UCHAR       Data[ 1 ];              // Actual data
} IMAGE_DEBUG_MISC, *PIMAGE_DEBUG_MISC;


//
// Debugging information can be stripped from an image file and placed
// in a separate .DBG file, whose file name part is the same as the
// image file name part (e.g. symbols for CMD.EXE could be stripped
// and placed in CMD.DBG).  This is indicated by the IMAGE_FILE_DEBUG_STRIPPED
// flag in the Characteristics field of the file header.  The beginning of
// the .DBG file contains the following structure which captures certain
// information from the image file.  This allows a debug to proceed even if
// the original image file is not accessable.  This header is followed by
// zero of more IMAGE_SECTION_HEADER structures, followed by zero or more
// IMAGE_DEBUG_DIRECTORY structures.  The latter structures and those in
// the image file contain file offsets relative to the beginning of the
// .DBG file.
//
// If symbols have been stripped from an image, the IMAGE_DEBUG_MISC structure
// is left in the image file, but not mapped.  This allows a debugger to
// compute the name of the .DBG file, from the name of the image in the
// IMAGE_DEBUG_MISC structure.
//

typedef struct _IMAGE_SEPARATE_DEBUG_HEADER {
    USHORT      Signature;
    USHORT      Flags;
    USHORT      Machine;
    USHORT      Characteristics;
    ULONG       TimeDateStamp;
    ULONG       CheckSum;
    ULONG       ImageBase;
    ULONG       SizeOfImage;
    ULONG       NumberOfSections;
    ULONG       ExportedNamesSize;
    ULONG       DebugDirectorySize;
    ULONG       Reserved[ 3 ];
} IMAGE_SEPARATE_DEBUG_HEADER, *PIMAGE_SEPARATE_DEBUG_HEADER;

#define IMAGE_SEPARATE_DEBUG_SIGNATURE 0x4944

#ifndef RC_INVOKED
#pragma pack ()
#endif  // !RC_INVOKED

//
// End Image Format
//

// end_winnt

#endif // _NTIMAGE_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\tools\c932\inc\nddeapi.h ===
/************************************************************************
* Copyright (c) Wonderware Software Development Corp. 1991-1993.        *
*               All Rights Reserved.                                    *
* Copyright (c) Microsoft Inc. 1994                                     *
*               All Rights Reserved.                                    *
************************************************************************/

#ifndef          _INC_NDDEAPI
#define          _INC_NDDEAPI

#ifndef RC_INVOKED
#pragma pack(1)         /* Assume byte packing throughout */
#endif /* !RC_INVOKED */

#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif    /* __cplusplus */

#ifndef CNLEN           /* If not included with netapi header */
#define CNLEN           15                  /* Computer name length     */
#define UNCLEN          (CNLEN+2)           /* UNC computer name length */
#endif /* CNLEN */

// the choice of this char affects legal share,topic, etc. names
#define SEP_CHAR    ','
#define BAR_CHAR    "|"
#define SEP_WCHAR   L','
#define BAR_WCHAR   L"|"

/* API error codes  */
#define NDDE_NO_ERROR                  0
#define NDDE_ACCESS_DENIED             1
#define NDDE_BUF_TOO_SMALL             2
#define NDDE_ERROR_MORE_DATA           3
#define NDDE_INVALID_SERVER            4
#define NDDE_INVALID_SHARE             5
#define NDDE_INVALID_PARAMETER         6
#define NDDE_INVALID_LEVEL             7
#define NDDE_INVALID_PASSWORD          8
#define NDDE_INVALID_ITEMNAME          9
#define NDDE_INVALID_TOPIC             10
#define NDDE_INTERNAL_ERROR            11
#define NDDE_OUT_OF_MEMORY             12
#define NDDE_INVALID_APPNAME           13
#define NDDE_NOT_IMPLEMENTED           14
#define NDDE_SHARE_ALREADY_EXIST       15
#define NDDE_SHARE_NOT_EXIST           16
#define NDDE_INVALID_FILENAME          17
#define NDDE_NOT_RUNNING               18
#define NDDE_INVALID_WINDOW            19
#define NDDE_INVALID_SESSION           20
#define NDDE_INVALID_ITEM_LIST         21
#define NDDE_SHARE_DATA_CORRUPTED      22
#define NDDE_REGISTRY_ERROR            23
#define NDDE_CANT_ACCESS_SERVER        24
#define NDDE_INVALID_SPECIAL_COMMAND   25
#define NDDE_INVALID_SECURITY_DESC     26
#define NDDE_TRUST_SHARE_FAIL          27

/* string size constants */
#define MAX_NDDESHARENAME       256
#define MAX_USERNAME            15
#define MAX_DOMAINNAME          15
#define MAX_APPNAME             255
#define MAX_TOPICNAME           255
#define MAX_ITEMNAME            255

/* connectFlags bits for ndde service affix */
#define NDDEF_NOPASSWORDPROMPT  0x0001
#define NDDEF_NOCACHELOOKUP     0x0002
#define NDDEF_STRIP_NDDE        0x0004


/* NDDESHAREINFO - contains information about a NDDE share */

struct NDdeShareInfo_tag {
    LONG                    lRevision;
    LPTSTR                  lpszShareName;
    LONG                    lShareType;
    LPTSTR                  lpszAppTopicList;
    LONG                    fSharedFlag;
    LONG                    fService;
    LONG                    fStartAppFlag;
    LONG                    nCmdShow;
    LONG                    qModifyId[2];
    LONG                    cNumItems;
    LPTSTR                  lpszItemList;
};
typedef struct NDdeShareInfo_tag   NDDESHAREINFO;
typedef struct NDdeShareInfo_tag * PNDDESHAREINFO;

/*  Share Types */
#define SHARE_TYPE_OLD      0x01                // Excel|sheet1.xls
#define SHARE_TYPE_NEW      0x02                // ExcelWorksheet|sheet1.xls
#define SHARE_TYPE_STATIC   0x04                // ClipSrv|SalesData


/*
    Add new share
*/
UINT WINAPI
NDdeShareAddA (
    LPSTR                   lpszServer, // server to execute on (NULL=Local)
    UINT                    nLevel,     // info level must be 2
    PSECURITY_DESCRIPTOR    pSD,        // initial security descriptor (optional)
    LPBYTE                  lpBuffer,   // contains (NDDESHAREINFO) + data
    DWORD                   cBufSize    // sizeof supplied buffer
);

UINT WINAPI
NDdeShareAddW (
    LPWSTR                  lpszServer, // server to execute on (NULL=Local)
    UINT                    nLevel,     // info level must be 2
    PSECURITY_DESCRIPTOR    pSD,        // initial security descriptor (optional)
    LPBYTE                  lpBuffer,   // contains (NDDESHAREINFO) + data
    DWORD                   cBufSize    // sizeof supplied buffer
);

/*
    Delete a share
*/
UINT WINAPI
NDdeShareDelA (
    LPSTR   lpszServer,     // server to execute on (NULL=Local)
    LPSTR   lpszShareName,  // name of share to delete
    UINT    wReserved       // 0
);

UINT WINAPI
NDdeShareDelW (
    LPWSTR  lpszServer,     // server to execute on (NULL=Local)
    LPWSTR  lpszShareName,  // name of share to delete
    UINT    wReserved       // 0
);

/*
    Get Share Security Descriptor
*/

UINT WINAPI
NDdeGetShareSecurityA(
    LPSTR                   lpszServer,     // server to execute on (NULL=Local)
    LPSTR                   lpszShareName,  // name of share
    SECURITY_INFORMATION    si,             // requested information
    PSECURITY_DESCRIPTOR    pSD,            // address of security descriptor
    DWORD                   cbSD,           // size of buffer for security descriptor
    LPDWORD                 lpcbsdRequired  // address of required size of buffer
);

UINT WINAPI
NDdeGetShareSecurityW(
    LPWSTR                  lpszServer,     // server to execute on (NULL=Local)
    LPWSTR                  lpszShareName,  // name of share
    SECURITY_INFORMATION    si,             // requested information
    PSECURITY_DESCRIPTOR    pSD,            // address of security descriptor
    DWORD                   cbSD,           // size of buffer for security descriptor
    LPDWORD                 lpcbsdRequired  // address of required size of buffer
);

/*
    Set Share Security Descriptor
*/

UINT WINAPI
NDdeSetShareSecurityA(
    LPSTR                   lpszServer,     // server to execute on (NULL=Local)
    LPSTR                   lpszShareName,  // name of share
    SECURITY_INFORMATION    si,             // type of information to set
    PSECURITY_DESCRIPTOR    pSD             // address of security descriptor
);

UINT WINAPI
NDdeSetShareSecurityW(
    LPWSTR                  lpszServer,     // server to execute on (NULL=Local)
    LPWSTR                  lpszShareName,  // name of share
    SECURITY_INFORMATION    si,             // type of information to set
    PSECURITY_DESCRIPTOR    pSD             // address of security descriptor
);

/*
    Enumerate shares
*/
UINT WINAPI
NDdeShareEnumA (
    LPSTR   lpszServer,         // server to execute on ( NULL for local )
    UINT    nLevel,             //  0 for null separated 00 terminated list
    LPBYTE  lpBuffer,           // pointer to buffer
    DWORD   cBufSize,           // size of buffer
    LPDWORD lpnEntriesRead,     // number of names returned
    LPDWORD lpcbTotalAvailable  // number of bytes available
);

UINT WINAPI
NDdeShareEnumW (
    LPWSTR  lpszServer,         // server to execute on (NULL=local)
    UINT    nLevel,             // 0 for null separated 00 terminated list
    LPBYTE  lpBuffer,           // pointer to buffer
    DWORD   cBufSize,           // size of buffer
    LPDWORD lpnEntriesRead,     // number of names returned
    LPDWORD lpcbTotalAvailable  // number of bytes available
);

/*
    Get information on a share
*/
UINT WINAPI
NDdeShareGetInfoA (
    LPSTR   lpszServer,         // server to execute on (NULL=Local)
    LPSTR   lpszShareName,      // name of share
    UINT    nLevel,             // info level must be 2
    LPBYTE  lpBuffer,           // gets struct containing (NDDESHAREINFO) + data
    DWORD   cBufSize,           // sizeof buffer
    LPDWORD lpnTotalAvailable,  // number of bytes available
    LPWORD  lpnItems            // item mask for partial getinfo (must be 0)
);

UINT WINAPI
NDdeShareGetInfoW (
    LPWSTR  lpszServer,         // server to execute on (NULL=Local)
    LPWSTR  lpszShareName,      // name of share
    UINT    nLevel,             // info level must be 2
    LPBYTE  lpBuffer,           // gets struct containing (NDDESHAREINFO) + data
    DWORD   cBufSize,           // sizeof buffer
    LPDWORD lpnTotalAvailable,  // number of bytes available
    LPWORD  lpnItems            // item mask for partial getinfo (must be 0)
);

/*
    Modify DDE share data
*/
UINT WINAPI
NDdeShareSetInfoA (
    LPSTR   lpszServer,         // server to execute on (NULL=Local)
    LPSTR   lpszShareName,      // name of share
    UINT    nLevel,             // info level must be 2
    LPBYTE  lpBuffer,           // points to struct with (NDDESHAREINFO) + data
    DWORD   cBufSize,           // sizeof buffer
    WORD    sParmNum            // Parameter index ( must be 0 - entire )
);

UINT WINAPI
NDdeShareSetInfoW (
    LPWSTR  lpszServer,         // server to execute on (NULL=Local)
    LPWSTR  lpszShareName,      // name of share
    UINT    nLevel,             // info level must be 2
    LPBYTE  lpBuffer,           // points to struct with (NDDESHAREINFO) + data
    DWORD   cBufSize,           // sizeof buffer
    WORD    sParmNum            // Parameter index ( must be 0 - entire )
);

/*
    Set/Create a trusted share
*/

UINT WINAPI
NDdeSetTrustedShareA (
    LPSTR   lpszServer,         // server to execute on (NULL=Local)
    LPSTR   lpszShareName,      // name of share to delete
    DWORD   dwTrustOptions      // trust options to apply
);

UINT WINAPI
NDdeSetTrustedShareW (
    LPWSTR  lpszServer,         // server to execute on (NULL=Local)
    LPWSTR  lpszShareName,      // name of share to delete
    DWORD   dwTrustOptions      // trust options to apply
);

                                            /*  Trusted share options       */
#define NDDE_TRUST_SHARE_START  0x80000000L     // Start App Allowed
#define NDDE_TRUST_SHARE_INIT   0x40000000L     // Init Conv Allowed
#define NDDE_TRUST_SHARE_DEL    0x20000000L     // Delete Trusted Share (on set)
#define NDDE_TRUST_CMD_SHOW     0x10000000L     // Use supplied cmd show
#define NDDE_CMD_SHOW_MASK      0x0000FFFFL     // Command Show mask

/*
    Get a trusted share options
*/

UINT WINAPI
NDdeGetTrustedShareA (
    LPSTR       lpszServer,         // server to execute on (NULL=Local)
    LPSTR       lpszShareName,      // name of share
    LPDWORD     lpdwTrustOptions,   // trust options in effect
    LPDWORD     lpdwShareModId0,    // first word of share mod id
    LPDWORD     lpdwShareModId1     // second word of share mod id
);

UINT WINAPI
NDdeGetTrustedShareW (
    LPWSTR      lpszServer,         // server to execute on (NULL=Local)
    LPWSTR      lpszShareName,      // name of share
    LPDWORD     lpdwTrustOptions,   // trust options in effect
    LPDWORD     lpdwShareModId0,    // first word of share mod id
    LPDWORD     lpdwShareModId1     // second word of share mod id
);


/*
    Enumerate trusted shares
*/
UINT WINAPI
NDdeTrustedShareEnumA (
    LPSTR   lpszServer,         // server to execute on ( NULL for local )
    UINT    nLevel,             // 0 for null separated 00 terminated list
    LPBYTE  lpBuffer,           // pointer to buffer
    DWORD   cBufSize,           // size of buffer
    LPDWORD lpnEntriesRead,     // number of names returned
    LPDWORD lpcbTotalAvailable  // number of bytes available
);

UINT WINAPI
NDdeTrustedShareEnumW (
    LPWSTR  lpszServer,         // server to execute on ( NULL for local )
    UINT    nLevel,             // 0 for null separated 00 terminated list
    LPBYTE  lpBuffer,           // pointer to buffer
    DWORD   cBufSize,           // size of buffer
    LPDWORD lpnEntriesRead,     // number of names returned
    LPDWORD lpcbTotalAvailable  // number of bytes available
);

/*
    Convert error code to string value
*/
UINT WINAPI
NDdeGetErrorStringA (
    UINT    uErrorCode,         // Error code to get string for
    LPSTR   lpszErrorString,    // buffer to hold error string
    DWORD   cBufSize            // sizeof buffer
);

UINT WINAPI
NDdeGetErrorStringW (
    UINT    uErrorCode,         // Error code to get string for
    LPWSTR  lpszErrorString,    // buffer to hold error string
    DWORD   cBufSize            // sizeof buffer
);

/*
    Validate share name format
*/
BOOL WINAPI
NDdeIsValidShareNameA (
    LPSTR shareName             // share name
);

BOOL WINAPI
NDdeIsValidShareNameW (
    LPWSTR shareName            // share name
);

/*
    Validate application/topic list format
*/
BOOL WINAPI
NDdeIsValidAppTopicListA (
    LPSTR targetTopic           // AppTopic list to validate
);

BOOL WINAPI
NDdeIsValidAppTopicListW (
    LPWSTR targetTopic          // AppTopic list to validate
);

#ifdef UNICODE
#define NDdeShareAdd            NDdeShareAddW
#define NDdeShareDel            NDdeShareDelW
#define NDdeSetShareSecurity    NDdeSetShareSecurityW
#define NDdeGetShareSecurity    NDdeGetShareSecurityW
#define NDdeShareEnum           NDdeShareEnumW
#define NDdeShareGetInfo        NDdeShareGetInfoW
#define NDdeShareSetInfo        NDdeShareSetInfoW
#define NDdeGetErrorString      NDdeGetErrorStringW
#define NDdeIsValidShareName    NDdeIsValidShareNameW
#define NDdeIsValidAppTopicList NDdeIsValidAppTopicListW
#define NDdeSetTrustedShare     NDdeSetTrustedShareW
#define NDdeGetTrustedShare     NDdeGetTrustedShareW
#define NDdeTrustedShareEnum    NDdeTrustedShareEnumW
#else
#define NDdeShareAdd            NDdeShareAddA
#define NDdeShareDel            NDdeShareDelA
#define NDdeSetShareSecurity    NDdeSetShareSecurityA
#define NDdeGetShareSecurity    NDdeGetShareSecurityA
#define NDdeShareEnum           NDdeShareEnumA
#define NDdeShareGetInfo        NDdeShareGetInfoA
#define NDdeShareSetInfo        NDdeShareSetInfoA
#define NDdeGetErrorString      NDdeGetErrorStringA
#define NDdeIsValidShareName    NDdeIsValidShareNameA
#define NDdeIsValidAppTopicList NDdeIsValidAppTopicListA
#define NDdeSetTrustedShare     NDdeSetTrustedShareA
#define NDdeGetTrustedShare     NDdeGetTrustedShareA
#define NDdeTrustedShareEnum    NDdeTrustedShareEnumA
#endif

#ifdef __cplusplus
}
#endif    /* __cplusplus */

#ifndef RC_INVOKED
#pragma pack()
#endif  /* !RC_INVOKED */

#endif  /* _INC_NDDEAPI */



=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\tools\c932\inc\ntsdexts.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1990-1993  Microsoft Corporation

Module Name:

    ntsdexts.h

Abstract:

    This file contains procedure prototypes and structures
    needed to write NTSD and KD debugger extensions.

Author:

    Mark Lucovsky (markl) 09-Apr-1991

Environment:

    runs in the Win32 NTSD debug environment.

Revision History:

--*/

#ifndef _NTSDEXTNS_
#define _NTSDEXTNS_

#ifdef __cplusplus
extern "C" {
#endif

typedef
VOID
(*PNTSD_OUTPUT_ROUTINE)(
    char *,
    ...
    );

typedef
DWORD
(*PNTSD_GET_EXPRESSION)(
    char *
    );

typedef
VOID
(*PNTSD_GET_SYMBOL)(
    LPVOID offset,
    PUCHAR pchBuffer,
    LPDWORD pDisplacement
    );

typedef
DWORD
(*PNTSD_DISASM)(
    LPDWORD lpOffset,
    LPSTR lpBuffer,
    BOOL fShowEfeectiveAddress
    );

typedef
BOOL
(*PNTSD_CHECK_CONTROL_C)(
    VOID
    );

typedef struct _NTSD_EXTENSION_APIS {
    DWORD nSize;
    PNTSD_OUTPUT_ROUTINE lpOutputRoutine;
    PNTSD_GET_EXPRESSION lpGetExpressionRoutine;
    PNTSD_GET_SYMBOL lpGetSymbolRoutine;
    PNTSD_DISASM lpDisasmRoutine;
    PNTSD_CHECK_CONTROL_C lpCheckControlCRoutine;
} NTSD_EXTENSION_APIS, *PNTSD_EXTENSION_APIS;

typedef
VOID
(*PNTSD_EXTENSION_ROUTINE)(
    HANDLE hCurrentProcess,
    HANDLE hCurrentThread,
    DWORD dwCurrentPc,
    PNTSD_EXTENSION_APIS lpExtensionApis,
    LPSTR lpArgumentString
    );

#ifdef __cplusplus
}
#endif


#endif // _NTSDEXTNS_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\tools\c932\inc\ole.h ===
/*****************************************************************************\
*                                                                             *
* ole.h -       Object Linking and Embedding functions, types, and definitions*
*                                                                             *
*               Version 1.0                                                   *
*                                                                             *
*               NOTE: windows.h must be #included first                       *
*                                                                             *
*               Copyright (c) 1990-1993, Microsoft Corp.  All rights reserved.*
*                                                                             *
\*****************************************************************************/

#ifndef _INC_OLE
#define _INC_OLE

#ifdef WIN16
#ifndef RC_INVOKED
#pragma pack(1)         /* Assume byte packing throughout */
#endif /* !RC_INVOKED */
#endif

#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif  /* __cplusplus */

#ifndef WINAPI          /* If not included with 3.1 headers... */
#define WINAPI      FAR PASCAL
#define CALLBACK    FAR PASCAL
#define LPCSTR      LPSTR
#define LRESULT     LONG
#define HGLOBAL     HANDLE
#endif  /* _INC_WINDOWS */


#ifdef STRICT
#define OLE_LPCSTR  LPCSTR
#define OLE_CONST   const
#else   /* STRICT */
#define OLE_LPCSTR  LPSTR
#define OLE_CONST
#endif /* !STRICT */

#define LRESULT     LONG
#define HGLOBAL     HANDLE


/* Object types */
#define OT_LINK             1L
#define OT_EMBEDDED         2L
#define OT_STATIC           3L

/* activate verbs */
#define OLEVERB_PRIMARY     0

/* target device info structure */
typedef struct _OLETARGETDEVICE
{
    UINT otdDeviceNameOffset;
    UINT otdDriverNameOffset;
    UINT otdPortNameOffset;
    UINT otdExtDevmodeOffset;
    UINT otdExtDevmodeSize;
    UINT otdEnvironmentOffset;
    UINT otdEnvironmentSize;
    BYTE otdData[1];
} OLETARGETDEVICE;
typedef OLETARGETDEVICE FAR* LPOLETARGETDEVICE;

/* flags used in some methods */
#define OF_SET              0x0001
#define OF_GET              0x0002
#define OF_HANDLER          0x0004

/* return codes for OLE functions */
typedef enum
{
    OLE_OK,                     /* 0   Function operated correctly             */

    OLE_WAIT_FOR_RELEASE,       /* 1   Command has been initiated, client      */
                                /*     must wait for release. keep dispatching */
                                /*     messages till OLE_RELESE in callback    */

    OLE_BUSY,                   /* 2   Tried to execute a method while another */
                                /*     method is in progress.                  */

    OLE_ERROR_PROTECT_ONLY,     /* 3   Ole APIs are called in real mode        */
    OLE_ERROR_MEMORY,           /* 4   Could not alloc or lock memory          */
    OLE_ERROR_STREAM,           /* 5  (OLESTREAM) stream error                 */
    OLE_ERROR_STATIC,           /* 6   Non static object expected              */
    OLE_ERROR_BLANK,            /* 7   Critical data missing                   */
    OLE_ERROR_DRAW,             /* 8   Error while drawing                     */
    OLE_ERROR_METAFILE,         /* 9   Invalid metafile                        */
    OLE_ERROR_ABORT,            /* 10  Client chose to abort metafile drawing  */
    OLE_ERROR_CLIPBOARD,        /* 11  Failed to get/set clipboard data        */
    OLE_ERROR_FORMAT,           /* 12  Requested format is not available       */
    OLE_ERROR_OBJECT,           /* 13  Not a valid object                      */
    OLE_ERROR_OPTION,           /* 14  Invalid option(link update / render)    */
    OLE_ERROR_PROTOCOL,         /* 15  Invalid protocol                        */
    OLE_ERROR_ADDRESS,          /* 16  One of the pointers is invalid          */
    OLE_ERROR_NOT_EQUAL,        /* 17  Objects are not equal                   */
    OLE_ERROR_HANDLE,           /* 18  Invalid handle encountered              */
    OLE_ERROR_GENERIC,          /* 19  Some general error                      */
    OLE_ERROR_CLASS,            /* 20  Invalid class                           */
    OLE_ERROR_SYNTAX,           /* 21  Command syntax is invalid               */
    OLE_ERROR_DATATYPE,         /* 22  Data format is not supported            */
    OLE_ERROR_PALETTE,          /* 23  Invalid color palette                   */
    OLE_ERROR_NOT_LINK,         /* 24  Not a linked object                     */
    OLE_ERROR_NOT_EMPTY,        /* 25  Client doc contains objects.            */
    OLE_ERROR_SIZE,             /* 26  Incorrect buffer size passed to the api */
                                /*     that places some string in caller's     */
                                /*     buffer                                  */

    OLE_ERROR_DRIVE,            /* 27  Drive letter in doc name is invalid     */
    OLE_ERROR_NETWORK,          /* 28  Failed to establish connection to a     */
                                /*     network share on which the document     */
                                /*     is located                              */

    OLE_ERROR_NAME,             /* 29  Invalid name(doc name, object name),    */
                                /*     etc.. passed to the APIs                */

    OLE_ERROR_TEMPLATE,         /* 30  Server failed to load template          */
    OLE_ERROR_NEW,              /* 31  Server failed to create new doc         */
    OLE_ERROR_EDIT,             /* 32  Server failed to create embedded        */
                                /*     instance                                */
    OLE_ERROR_OPEN,             /* 33  Server failed to open document,         */
                                /*     possible invalid link                   */

    OLE_ERROR_NOT_OPEN,         /* 34  Object is not open for editing          */
    OLE_ERROR_LAUNCH,           /* 35  Failed to launch server                 */
    OLE_ERROR_COMM,             /* 36  Failed to communicate with server       */
    OLE_ERROR_TERMINATE,        /* 37  Error in termination                    */
    OLE_ERROR_COMMAND,          /* 38  Error in execute                        */
    OLE_ERROR_SHOW,             /* 39  Error in show                           */
    OLE_ERROR_DOVERB,           /* 40  Error in sending do verb, or invalid    */
                                /*     verb                                    */
    OLE_ERROR_ADVISE_NATIVE,    /* 41  Item could be missing                   */
    OLE_ERROR_ADVISE_PICT,      /* 42  Item could be missing or server doesn't */
                                /*     this format.                            */

    OLE_ERROR_ADVISE_RENAME,    /* 43  Server doesn't support rename           */
    OLE_ERROR_POKE_NATIVE,      /* 44  Failure of poking native data to server */
    OLE_ERROR_REQUEST_NATIVE,   /* 45  Server failed to render native data     */
    OLE_ERROR_REQUEST_PICT,     /* 46  Server failed to render presentation    */
                                /*     data                                    */
    OLE_ERROR_SERVER_BLOCKED,   /* 47  Trying to block a blocked server or     */
                                /*     trying to revoke a blocked server       */
                                /*     or document                             */

    OLE_ERROR_REGISTRATION,     /* 48  Server is not registered in regestation */
                                /*     data base                               */
    OLE_ERROR_ALREADY_REGISTERED,/*49  Trying to register same doc multiple    */
                                 /*    times                                   */
    OLE_ERROR_TASK,             /* 50  Server or client task is invalid        */
    OLE_ERROR_OUTOFDATE,        /* 51  Object is out of date                   */
    OLE_ERROR_CANT_UPDATE_CLIENT,/* 52 Embed doc's client doesn't accept       */
                                /*     updates                                 */
    OLE_ERROR_UPDATE,           /* 53  erorr while trying to update            */
    OLE_ERROR_SETDATA_FORMAT,   /* 54  Server app doesn't understand the       */
                                /*     format given to its SetData method      */
    OLE_ERROR_STATIC_FROM_OTHER_OS,/* 55 trying to load a static object created */
                                   /*    on another Operating System           */
    OLE_ERROR_FILE_VER,

    /*  Following are warnings */
    OLE_WARN_DELETE_DATA = 1000 /*     Caller must delete the data when he is  */
                                /*     done with it.                           */
} OLESTATUS;



/* Codes for CallBack events */
typedef enum
{
    OLE_CHANGED,            /* 0                                             */
    OLE_SAVED,              /* 1                                             */
    OLE_CLOSED,             /* 2                                             */
    OLE_RENAMED,            /* 3                                             */
    OLE_QUERY_PAINT,        /* 4  Interruptible paint support                */
    OLE_RELEASE,            /* 5  Object is released(asynchronous operation  */
                            /*    is completed)                              */
    OLE_QUERY_RETRY        /* 6  Query for retry when server sends busy ACK */
} OLE_NOTIFICATION;

typedef enum
{
    OLE_NONE,               /* 0  no method active                           */
    OLE_DELETE,             /* 1  object delete                              */
    OLE_LNKPASTE,           /* 2  PasteLink(auto reconnect)                  */
    OLE_EMBPASTE,           /* 3  paste(and update)                          */
    OLE_SHOW,               /* 4  Show                                       */
    OLE_RUN,                /* 5  Run                                        */
    OLE_ACTIVATE,           /* 6  Activate                                   */
    OLE_UPDATE,             /* 7  Update                                     */
    OLE_CLOSE,              /* 8  Close                                      */
    OLE_RECONNECT,          /* 9  Reconnect                                  */
    OLE_SETUPDATEOPTIONS,   /* 10 setting update options                     */
    OLE_SERVERUNLAUNCH,     /* 11 server is being unlaunched                 */
    OLE_LOADFROMSTREAM,     /* 12 LoadFromStream(auto reconnect)             */
    OLE_SETDATA,            /* 13 OleSetData                                 */
    OLE_REQUESTDATA,        /* 14 OleRequestData                             */
    OLE_OTHER,              /* 15 other misc async operations                */
    OLE_CREATE,             /* 16 create                                     */
    OLE_CREATEFROMTEMPLATE, /* 17 CreatefromTemplate                         */
    OLE_CREATELINKFROMFILE, /* 18 CreateLinkFromFile                         */
    OLE_COPYFROMLNK,        /* 19 CopyFromLink(auto reconnect)               */
    OLE_CREATEFROMFILE,     /* 20 CreateFromFile                             */
    OLE_CREATEINVISIBLE     /* 21 CreateInvisible                            */
} OLE_RELEASE_METHOD;

/* rendering options */
typedef enum
{
    olerender_none,
    olerender_draw,
    olerender_format
} OLEOPT_RENDER;

/* standard clipboard format type */
typedef WORD OLECLIPFORMAT;

/* Link update options */
typedef enum
{
    oleupdate_always,
    oleupdate_onsave,
#ifdef OLE_INTERNAL
    oleupdate_oncall,
    oleupdate_onclose
#else
    oleupdate_oncall
#endif  /* OLE_INTERNAL */
} OLEOPT_UPDATE;

typedef HANDLE  HOBJECT;
typedef LONG    LHSERVER;
typedef LONG    LHCLIENTDOC;
typedef LONG    LHSERVERDOC;

typedef struct _OLEOBJECT FAR*  LPOLEOBJECT;
typedef struct _OLESTREAM FAR*  LPOLESTREAM;
typedef struct _OLECLIENT FAR*  LPOLECLIENT;


/* object method table definitions. */
typedef struct _OLEOBJECTVTBL
{
    void FAR*      (CALLBACK* QueryProtocol)        (LPOLEOBJECT, OLE_LPCSTR);
    OLESTATUS      (CALLBACK* Release)              (LPOLEOBJECT);
    OLESTATUS      (CALLBACK* Show)                 (LPOLEOBJECT, BOOL);
    OLESTATUS      (CALLBACK* DoVerb)               (LPOLEOBJECT, UINT, BOOL, BOOL);
    OLESTATUS      (CALLBACK* GetData)              (LPOLEOBJECT, OLECLIPFORMAT, HANDLE FAR*);
    OLESTATUS      (CALLBACK* SetData)              (LPOLEOBJECT, OLECLIPFORMAT, HANDLE);
    OLESTATUS      (CALLBACK* SetTargetDevice)      (LPOLEOBJECT, HGLOBAL);
    OLESTATUS      (CALLBACK* SetBounds)            (LPOLEOBJECT, OLE_CONST RECT FAR*);
    OLECLIPFORMAT  (CALLBACK* EnumFormats)          (LPOLEOBJECT, OLECLIPFORMAT);
    OLESTATUS      (CALLBACK* SetColorScheme)       (LPOLEOBJECT, OLE_CONST LOGPALETTE FAR*);
    /* Server has to implement only the above methods. */

#ifndef SERVERONLY
    /* Extra methods required for client. */
    OLESTATUS      (CALLBACK* Delete)               (LPOLEOBJECT);
    OLESTATUS      (CALLBACK* SetHostNames)         (LPOLEOBJECT, OLE_LPCSTR, OLE_LPCSTR);
    OLESTATUS      (CALLBACK* SaveToStream)         (LPOLEOBJECT, LPOLESTREAM);
    OLESTATUS      (CALLBACK* Clone)                (LPOLEOBJECT, LPOLECLIENT, LHCLIENTDOC, OLE_LPCSTR, LPOLEOBJECT FAR*);
    OLESTATUS      (CALLBACK* CopyFromLink)         (LPOLEOBJECT, LPOLECLIENT, LHCLIENTDOC, OLE_LPCSTR, LPOLEOBJECT FAR*);
    OLESTATUS      (CALLBACK* Equal)                (LPOLEOBJECT, LPOLEOBJECT);
    OLESTATUS      (CALLBACK* CopyToClipboard)      (LPOLEOBJECT);
    OLESTATUS      (CALLBACK* Draw)                 (LPOLEOBJECT, HDC, OLE_CONST RECT FAR*, OLE_CONST RECT FAR*, HDC);
    OLESTATUS      (CALLBACK* Activate)             (LPOLEOBJECT, UINT, BOOL, BOOL, HWND, OLE_CONST RECT FAR*);
    OLESTATUS      (CALLBACK* Execute)              (LPOLEOBJECT, HGLOBAL, UINT);
    OLESTATUS      (CALLBACK* Close)                (LPOLEOBJECT);
    OLESTATUS      (CALLBACK* Update)               (LPOLEOBJECT);
    OLESTATUS      (CALLBACK* Reconnect)            (LPOLEOBJECT);

    OLESTATUS      (CALLBACK* ObjectConvert)        (LPOLEOBJECT, OLE_LPCSTR, LPOLECLIENT, LHCLIENTDOC, OLE_LPCSTR, LPOLEOBJECT FAR*);
    OLESTATUS      (CALLBACK* GetLinkUpdateOptions) (LPOLEOBJECT, OLEOPT_UPDATE FAR*);
    OLESTATUS      (CALLBACK* SetLinkUpdateOptions) (LPOLEOBJECT, OLEOPT_UPDATE);

    OLESTATUS      (CALLBACK* Rename)               (LPOLEOBJECT, OLE_LPCSTR);
    OLESTATUS      (CALLBACK* QueryName)            (LPOLEOBJECT, LPSTR, UINT FAR*);

    OLESTATUS      (CALLBACK* QueryType)            (LPOLEOBJECT, LONG FAR*);
    OLESTATUS      (CALLBACK* QueryBounds)          (LPOLEOBJECT, RECT FAR*);
    OLESTATUS      (CALLBACK* QuerySize)            (LPOLEOBJECT, DWORD FAR*);
    OLESTATUS      (CALLBACK* QueryOpen)            (LPOLEOBJECT);
    OLESTATUS      (CALLBACK* QueryOutOfDate)       (LPOLEOBJECT);

    OLESTATUS      (CALLBACK* QueryReleaseStatus)   (LPOLEOBJECT);
    OLESTATUS      (CALLBACK* QueryReleaseError)    (LPOLEOBJECT);
    OLE_RELEASE_METHOD (CALLBACK* QueryReleaseMethod)(LPOLEOBJECT);

    OLESTATUS      (CALLBACK* RequestData)          (LPOLEOBJECT, OLECLIPFORMAT);
    OLESTATUS      (CALLBACK* ObjectLong)           (LPOLEOBJECT, UINT, LONG FAR*);

/* This method is internal only */
    OLESTATUS      (CALLBACK* ChangeData)           (LPOLEOBJECT, HANDLE, LPOLECLIENT, BOOL);
#endif  /* !SERVERONLY */
} OLEOBJECTVTBL;
typedef  OLEOBJECTVTBL FAR* LPOLEOBJECTVTBL;

#ifndef OLE_INTERNAL
typedef struct _OLEOBJECT
{
    LPOLEOBJECTVTBL    lpvtbl;
} OLEOBJECT;
#endif

/* ole client definitions */
typedef struct _OLECLIENTVTBL
{
    int (CALLBACK* CallBack)(LPOLECLIENT, OLE_NOTIFICATION, LPOLEOBJECT);
} OLECLIENTVTBL;

typedef  OLECLIENTVTBL FAR*  LPOLECLIENTVTBL;

typedef struct _OLECLIENT
{
    LPOLECLIENTVTBL   lpvtbl;
} OLECLIENT;

/* Stream definitions */
typedef struct _OLESTREAMVTBL
{
    DWORD (CALLBACK* Get)(LPOLESTREAM, void FAR*, DWORD);
    DWORD (CALLBACK* Put)(LPOLESTREAM, OLE_CONST void FAR*, DWORD);
} OLESTREAMVTBL;
typedef  OLESTREAMVTBL FAR*  LPOLESTREAMVTBL;

typedef struct _OLESTREAM
{
    LPOLESTREAMVTBL      lpstbl;
} OLESTREAM;

/* Public Function Prototypes */
OLESTATUS   WINAPI  OleDelete(LPOLEOBJECT);
OLESTATUS   WINAPI  OleRelease(LPOLEOBJECT);
OLESTATUS   WINAPI  OleSaveToStream(LPOLEOBJECT, LPOLESTREAM);
OLESTATUS   WINAPI  OleEqual(LPOLEOBJECT, LPOLEOBJECT );
OLESTATUS   WINAPI  OleCopyToClipboard(LPOLEOBJECT);
OLESTATUS   WINAPI  OleSetHostNames(LPOLEOBJECT, LPCSTR, LPCSTR);
OLESTATUS   WINAPI  OleSetTargetDevice(LPOLEOBJECT, HGLOBAL);
OLESTATUS   WINAPI  OleSetBounds(LPOLEOBJECT, const RECT FAR*);
OLESTATUS   WINAPI  OleSetColorScheme(LPOLEOBJECT, const LOGPALETTE FAR*);
OLESTATUS   WINAPI  OleQueryBounds(LPOLEOBJECT, RECT FAR*);
OLESTATUS   WINAPI  OleQuerySize(LPOLEOBJECT, DWORD FAR*);
OLESTATUS   WINAPI  OleDraw(LPOLEOBJECT, HDC, const RECT FAR*, const RECT FAR*, HDC);
OLESTATUS   WINAPI  OleQueryOpen(LPOLEOBJECT);
OLESTATUS   WINAPI  OleActivate(LPOLEOBJECT, UINT, BOOL, BOOL, HWND, const RECT FAR*);
OLESTATUS   WINAPI  OleExecute(LPOLEOBJECT, HGLOBAL, UINT);
OLESTATUS   WINAPI  OleClose(LPOLEOBJECT);
OLESTATUS   WINAPI  OleUpdate(LPOLEOBJECT);
OLESTATUS   WINAPI  OleReconnect(LPOLEOBJECT);
OLESTATUS   WINAPI  OleGetLinkUpdateOptions(LPOLEOBJECT, OLEOPT_UPDATE FAR*);
OLESTATUS   WINAPI  OleSetLinkUpdateOptions(LPOLEOBJECT, OLEOPT_UPDATE);
void FAR*   WINAPI  OleQueryProtocol(LPOLEOBJECT, LPCSTR);

/* Routines related to asynchronous operations. */
OLESTATUS   WINAPI  OleQueryReleaseStatus(LPOLEOBJECT);
OLESTATUS   WINAPI  OleQueryReleaseError(LPOLEOBJECT);
OLE_RELEASE_METHOD WINAPI OleQueryReleaseMethod(LPOLEOBJECT);

OLESTATUS   WINAPI  OleQueryType(LPOLEOBJECT, LONG FAR*);

/* LOWORD is major version, HIWORD is minor version */
DWORD       WINAPI  OleQueryClientVersion(void);
DWORD       WINAPI  OleQueryServerVersion(void);

/* Converting to format (as in clipboard): */
OLECLIPFORMAT  WINAPI  OleEnumFormats(LPOLEOBJECT, OLECLIPFORMAT);
OLESTATUS   WINAPI  OleGetData(LPOLEOBJECT, OLECLIPFORMAT, HANDLE FAR*);
OLESTATUS   WINAPI  OleSetData(LPOLEOBJECT, OLECLIPFORMAT, HANDLE);
OLESTATUS   WINAPI  OleQueryOutOfDate(LPOLEOBJECT);
OLESTATUS   WINAPI  OleRequestData(LPOLEOBJECT, OLECLIPFORMAT);

/* Query apis for creation from clipboard */
OLESTATUS   WINAPI  OleQueryLinkFromClip(LPCSTR, OLEOPT_RENDER, OLECLIPFORMAT);
OLESTATUS   WINAPI  OleQueryCreateFromClip(LPCSTR, OLEOPT_RENDER, OLECLIPFORMAT);

/* Object creation functions */
OLESTATUS   WINAPI  OleCreateFromClip(LPCSTR, LPOLECLIENT, LHCLIENTDOC, LPCSTR,  LPOLEOBJECT FAR*, OLEOPT_RENDER, OLECLIPFORMAT);
OLESTATUS   WINAPI  OleCreateLinkFromClip(LPCSTR, LPOLECLIENT, LHCLIENTDOC, LPCSTR, LPOLEOBJECT FAR*, OLEOPT_RENDER, OLECLIPFORMAT);
OLESTATUS   WINAPI  OleCreateFromFile(LPCSTR, LPOLECLIENT, LPCSTR, LPCSTR, LHCLIENTDOC, LPCSTR, LPOLEOBJECT FAR*, OLEOPT_RENDER, OLECLIPFORMAT);
OLESTATUS   WINAPI  OleCreateLinkFromFile(LPCSTR, LPOLECLIENT, LPCSTR, LPCSTR, LPCSTR, LHCLIENTDOC, LPCSTR, LPOLEOBJECT FAR*, OLEOPT_RENDER, OLECLIPFORMAT);
OLESTATUS   WINAPI  OleLoadFromStream(LPOLESTREAM, LPCSTR, LPOLECLIENT, LHCLIENTDOC, LPCSTR, LPOLEOBJECT FAR*);
OLESTATUS   WINAPI  OleCreate(LPCSTR, LPOLECLIENT, LPCSTR, LHCLIENTDOC, LPCSTR, LPOLEOBJECT FAR*, OLEOPT_RENDER, OLECLIPFORMAT);
OLESTATUS   WINAPI  OleCreateInvisible(LPCSTR, LPOLECLIENT, LPCSTR, LHCLIENTDOC, LPCSTR, LPOLEOBJECT FAR*, OLEOPT_RENDER, OLECLIPFORMAT, BOOL);
OLESTATUS   WINAPI  OleCreateFromTemplate(LPCSTR, LPOLECLIENT, LPCSTR, LHCLIENTDOC, LPCSTR, LPOLEOBJECT FAR*, OLEOPT_RENDER, OLECLIPFORMAT);
OLESTATUS   WINAPI  OleClone(LPOLEOBJECT, LPOLECLIENT, LHCLIENTDOC, LPCSTR, LPOLEOBJECT FAR*);
OLESTATUS   WINAPI  OleCopyFromLink(LPOLEOBJECT, LPCSTR, LPOLECLIENT, LHCLIENTDOC, LPCSTR, LPOLEOBJECT FAR*);
OLESTATUS   WINAPI  OleObjectConvert(LPOLEOBJECT, LPCSTR, LPOLECLIENT, LHCLIENTDOC, LPCSTR, LPOLEOBJECT FAR*);
OLESTATUS   WINAPI  OleRename(LPOLEOBJECT, LPCSTR);
OLESTATUS   WINAPI  OleQueryName(LPOLEOBJECT, LPSTR, UINT FAR*);
OLESTATUS   WINAPI  OleRevokeObject(LPOLECLIENT);
BOOL        WINAPI  OleIsDcMeta(HDC);

/* client document API */
OLESTATUS   WINAPI  OleRegisterClientDoc(LPCSTR, LPCSTR, LONG, LHCLIENTDOC FAR*);
OLESTATUS   WINAPI  OleRevokeClientDoc(LHCLIENTDOC);
OLESTATUS   WINAPI  OleRenameClientDoc(LHCLIENTDOC, LPCSTR);
OLESTATUS   WINAPI  OleRevertClientDoc(LHCLIENTDOC);
OLESTATUS   WINAPI  OleSavedClientDoc(LHCLIENTDOC);
OLESTATUS   WINAPI  OleEnumObjects(LHCLIENTDOC, LPOLEOBJECT FAR*);

/* server usage definitions */
typedef enum {
    OLE_SERVER_MULTI,           /* multiple instances */
    OLE_SERVER_SINGLE           /* single instance(multiple document) */
} OLE_SERVER_USE;

/* Server API */
typedef struct _OLESERVER FAR*  LPOLESERVER;

OLESTATUS   WINAPI  OleRegisterServer(LPCSTR, LPOLESERVER, LHSERVER FAR*, HINSTANCE, OLE_SERVER_USE);
OLESTATUS   WINAPI  OleRevokeServer(LHSERVER);
OLESTATUS   WINAPI  OleBlockServer(LHSERVER);
OLESTATUS   WINAPI  OleUnblockServer(LHSERVER, BOOL FAR*);

/* APIs to keep server open */
OLESTATUS   WINAPI  OleLockServer(LPOLEOBJECT, LHSERVER FAR*);
OLESTATUS   WINAPI  OleUnlockServer(LHSERVER);

/* Server document API */

typedef struct _OLESERVERDOC FAR*  LPOLESERVERDOC;

OLESTATUS   WINAPI  OleRegisterServerDoc(LHSERVER, LPCSTR, LPOLESERVERDOC, LHSERVERDOC FAR*);
OLESTATUS   WINAPI  OleRevokeServerDoc(LHSERVERDOC);
OLESTATUS   WINAPI  OleRenameServerDoc(LHSERVERDOC, LPCSTR);
OLESTATUS   WINAPI  OleRevertServerDoc(LHSERVERDOC);
OLESTATUS   WINAPI  OleSavedServerDoc(LHSERVERDOC);

typedef struct _OLESERVERVTBL
{
    OLESTATUS (CALLBACK* Open)  (LPOLESERVER, LHSERVERDOC, OLE_LPCSTR, LPOLESERVERDOC FAR*);
                                    /* long handle to doc(privtate to DLL)  */
                                    /* lp to OLESERVER                      */
                                    /* document name                        */
                                    /* place holder for returning oledoc.   */

    OLESTATUS (CALLBACK* Create)(LPOLESERVER, LHSERVERDOC, OLE_LPCSTR, OLE_LPCSTR, LPOLESERVERDOC FAR*);
                                    /* long handle to doc(privtate to DLL)  */
                                    /* lp to OLESERVER                      */
                                    /* lp class name                        */
                                    /* lp doc name                          */
                                    /* place holder for returning oledoc.   */

    OLESTATUS (CALLBACK* CreateFromTemplate)(LPOLESERVER, LHSERVERDOC, OLE_LPCSTR, OLE_LPCSTR, OLE_LPCSTR, LPOLESERVERDOC FAR*);
                                    /* long handle to doc(privtate to DLL)  */
                                    /* lp to OLESERVER                      */
                                    /* lp class name                        */
                                    /* lp doc name                          */
                                    /* lp template name                     */
                                    /* place holder for returning oledoc.   */

    OLESTATUS (CALLBACK* Edit)  (LPOLESERVER, LHSERVERDOC, OLE_LPCSTR, OLE_LPCSTR, LPOLESERVERDOC FAR*);
                                    /* long handle to doc(privtate to DLL)  */
                                    /* lp to OLESERVER                      */
                                    /* lp class name                        */
                                    /* lp doc name                          */
                                    /* place holder for returning oledoc.   */

    OLESTATUS (CALLBACK* Exit)  (LPOLESERVER);
                                    /* lp OLESERVER                         */

    OLESTATUS (CALLBACK* Release)  (LPOLESERVER);
                                    /* lp OLESERVER                         */

    OLESTATUS (CALLBACK* Execute)(LPOLESERVER, HGLOBAL);
                                    /* lp OLESERVER                         */
                                    /* handle to command strings            */
} OLESERVERVTBL;
typedef  OLESERVERVTBL FAR*  LPOLESERVERVTBL;

typedef struct _OLESERVER
{
    LPOLESERVERVTBL    lpvtbl;
} OLESERVER;

typedef struct _OLESERVERDOCVTBL
{
    OLESTATUS (CALLBACK* Save)      (LPOLESERVERDOC);
    OLESTATUS (CALLBACK* Close)     (LPOLESERVERDOC);
    OLESTATUS (CALLBACK* SetHostNames)(LPOLESERVERDOC, OLE_LPCSTR, OLE_LPCSTR);
    OLESTATUS (CALLBACK* SetDocDimensions)(LPOLESERVERDOC, OLE_CONST RECT FAR*);
    OLESTATUS (CALLBACK* GetObject) (LPOLESERVERDOC, OLE_LPCSTR, LPOLEOBJECT FAR*, LPOLECLIENT);
    OLESTATUS (CALLBACK* Release)   (LPOLESERVERDOC);
    OLESTATUS (CALLBACK* SetColorScheme)(LPOLESERVERDOC, OLE_CONST LOGPALETTE FAR*);
    OLESTATUS (CALLBACK* Execute)  (LPOLESERVERDOC, HGLOBAL);
} OLESERVERDOCVTBL;
typedef  OLESERVERDOCVTBL FAR*  LPOLESERVERDOCVTBL;

typedef struct _OLESERVERDOC
{
    LPOLESERVERDOCVTBL lpvtbl;
} OLESERVERDOC;

#ifdef __cplusplus
}
#endif  /* __cplusplus */

#ifndef RC_INVOKED
#pragma pack()
#endif  /* !RC_INVOKED */

#endif  /* !_INC_OLE */

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\tools\c932\inc\ostream.h ===
/***
*ostream.h - definitions/declarations for the ostream class
*
*	Copyright (c) 1991-1994, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*	This file defines the classes, values, macros, and functions
*	used by the ostream class.
*	[AT&T C++]
*
****/

#ifndef _INC_OSTREAM
#define _INC_OSTREAM


/* Define _CRTIMP */

#ifndef _CRTIMP
#ifdef	_NTSDK
/* definition compatible with NT SDK */
#define _CRTIMP
#else	/* ndef _NTSDK */
/* current definition */
#ifdef	_DLL
#define _CRTIMP __declspec(dllimport)
#else	/* ndef _DLL */
#define _CRTIMP
#endif	/* _DLL */
#endif	/* _NTSDK */
#endif	/* _CRTIMP */


#include <ios.h>

#ifdef	_MSC_VER
// C4505: "unreferenced local function has been removed"
#pragma warning(disable:4505) // disable C4505 warning
// #pragma warning(default:4505)	// use this to reenable, if desired

// Force word packing to avoid possible -Zp override
#pragma pack(push,4)
#endif	// _MSC_VER

typedef long streamoff, streampos;

class _CRTIMP ostream : virtual public ios {

public:
	ostream(streambuf*);
	virtual ~ostream();

	ostream& flush();
	int  opfx();
	void osfx();

inline	ostream& operator<<(ostream& (__cdecl * _f)(ostream&));
inline	ostream& operator<<(ios& (__cdecl * _f)(ios&));
	ostream& operator<<(const char *);
inline	ostream& operator<<(const unsigned char *);
inline	ostream& operator<<(const signed char *);
inline	ostream& operator<<(char);
	ostream& operator<<(unsigned char);
inline	ostream& operator<<(signed char);
	ostream& operator<<(short);
	ostream& operator<<(unsigned short);
	ostream& operator<<(int);
	ostream& operator<<(unsigned int);
	ostream& operator<<(long);
	ostream& operator<<(unsigned long);
inline	ostream& operator<<(float);
	ostream& operator<<(double);
	ostream& operator<<(long double);
	ostream& operator<<(const void *);
	ostream& operator<<(streambuf*);
inline	ostream& put(char);
	ostream& put(unsigned char);
inline	ostream& put(signed char);
	ostream& write(const char *,int);
inline	ostream& write(const unsigned char *,int);
inline	ostream& write(const signed char *,int);
	ostream& seekp(streampos);
	ostream& seekp(streamoff,ios::seek_dir);
	streampos tellp();

protected:
	ostream();
	ostream(const ostream&);	// treat as private
	ostream& operator=(streambuf*);	// treat as private
	ostream& operator=(const ostream& _os) {return operator=(_os.rdbuf()); }
	int do_opfx(int);		// not used
	void do_osfx();			// not used

private:
	ostream(ios&);
	ostream& writepad(const char *, const char *);
	int x_floatused;
};

inline ostream& ostream::operator<<(ostream& (__cdecl * _f)(ostream&)) { (*_f)(*this); return *this; }
inline ostream& ostream::operator<<(ios& (__cdecl * _f)(ios& )) { (*_f)(*this); return *this; }

inline	ostream& ostream::operator<<(char _c) { return operator<<((unsigned char) _c); }
inline	ostream& ostream::operator<<(signed char _c) { return operator<<((unsigned char) _c); }

inline	ostream& ostream::operator<<(const unsigned char * _s) { return operator<<((const char *) _s); }
inline	ostream& ostream::operator<<(const signed char * _s) { return operator<<((const char *) _s); }

inline	ostream& ostream::operator<<(float _f) { x_floatused = 1; return operator<<((double) _f); }

inline	ostream& ostream::put(char _c) { return put((unsigned char) _c); }
inline	ostream& ostream::put(signed char _c) { return put((unsigned char) _c); }

inline	ostream& ostream::write(const unsigned char * _s, int _n) { return write((char *) _s, _n); }
inline	ostream& ostream::write(const signed char * _s, int _n) { return write((char *) _s, _n); }


class _CRTIMP ostream_withassign : public ostream {
	public:
		ostream_withassign();
		ostream_withassign(streambuf* _is);
		~ostream_withassign();
    ostream& operator=(const ostream& _os) { return ostream::operator=(_os.rdbuf()); }
    ostream& operator=(streambuf* _sb) { return ostream::operator=(_sb); }
};

#ifndef _WINDLL	   // Warning!  Not available under Windows without QuickWin:
extern ostream_withassign _CRTIMP cout;
extern ostream_withassign _CRTIMP cerr;
extern ostream_withassign _CRTIMP clog;
#endif

inline _CRTIMP ostream& __cdecl flush(ostream& _outs) { return _outs.flush(); }
inline _CRTIMP ostream& __cdecl endl(ostream& _outs) { return _outs << '\n' << flush; }
inline _CRTIMP ostream& __cdecl ends(ostream& _outs) { return _outs << char('\0'); }

_CRTIMP ios&		__cdecl dec(ios&);
_CRTIMP ios&		__cdecl hex(ios&);
_CRTIMP ios&		__cdecl oct(ios&);

#ifdef	_MSC_VER
// Restore default packing
#pragma pack(pop)
#endif	// _MSC_VER

#endif		// !_INC_OSTREAM
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\tools\c932\inc\ras.h ===
/* Copyright (c) 1992-1996, Microsoft Corporation, all rights reserved
**
** ras.h
** Remote Access external API
** Public header for external API clients
**
** WINVER values in this file:
**      WINVER < 0x400 = Windows NT 3.5, Windows NT 3.51
**      WINVER = 0x400 = Windows 95, Windows NT SUR (default)
**      WINVER > 0x400 = Windows NT SUR enhancements
*/

#ifndef _RAS_H_
#define _RAS_H_

#ifdef __cplusplus
extern "C" {
#endif

#ifndef UNLEN
#include <lmcons.h>
#endif

#include <pshpack4.h>

#define RAS_MaxDeviceType     16
#define RAS_MaxPhoneNumber    128
#define RAS_MaxIpAddress      15
#define RAS_MaxIpxAddress     21

#if (WINVER >= 0x400)
#define RAS_MaxEntryName      256
#define RAS_MaxDeviceName     128
#define RAS_MaxCallbackNumber RAS_MaxPhoneNumber
#else
#define RAS_MaxEntryName      20
#define RAS_MaxDeviceName     32
#define RAS_MaxCallbackNumber 48
#endif

#define RAS_MaxAreaCode       10
#define RAS_MaxPadType        32
#define RAS_MaxX25Address     200
#define RAS_MaxFacilities     200
#define RAS_MaxUserData       200

DECLARE_HANDLE( HRASCONN );
#define LPHRASCONN HRASCONN*


/* Identifies an active RAS connection.  (See RasEnumConnections)
*/
#define RASCONNW struct tagRASCONNW
RASCONNW
{
    DWORD    dwSize;
    HRASCONN hrasconn;
    WCHAR    szEntryName[ RAS_MaxEntryName + 1 ];

#if (WINVER >= 0x400)
    WCHAR    szDeviceType[ RAS_MaxDeviceType + 1 ];
    WCHAR    szDeviceName[ RAS_MaxDeviceName + 1 ];
#endif
#if (WINVER >= 0x401)
    WCHAR    szPhonebook [ MAX_PATH ];
    DWORD    dwSubEntry;
#endif
};

#define RASCONNA struct tagRASCONNA
RASCONNA
{
    DWORD    dwSize;
    HRASCONN hrasconn;
    CHAR     szEntryName[ RAS_MaxEntryName + 1 ];

#if (WINVER >= 0x400)
    CHAR     szDeviceType[ RAS_MaxDeviceType + 1 ];
    CHAR     szDeviceName[ RAS_MaxDeviceName + 1 ];
#endif
#if (WINVER >= 0x401)
    CHAR     szPhonebook [ MAX_PATH ];
    DWORD    dwSubEntry;
#endif
};

#ifdef UNICODE
#define RASCONN RASCONNW
#else
#define RASCONN RASCONNA
#endif

#define LPRASCONNW RASCONNW*
#define LPRASCONNA RASCONNA*
#define LPRASCONN  RASCONN*


/* Enumerates intermediate states to a connection.  (See RasDial)
*/
#define RASCS_PAUSED 0x1000
#define RASCS_DONE   0x2000

#define RASCONNSTATE enum tagRASCONNSTATE
RASCONNSTATE
{
    RASCS_OpenPort = 0,
    RASCS_PortOpened,
    RASCS_ConnectDevice,
    RASCS_DeviceConnected,
    RASCS_AllDevicesConnected,
    RASCS_Authenticate,
    RASCS_AuthNotify,
    RASCS_AuthRetry,
    RASCS_AuthCallback,
    RASCS_AuthChangePassword,
    RASCS_AuthProject,
    RASCS_AuthLinkSpeed,
    RASCS_AuthAck,
    RASCS_ReAuthenticate,
    RASCS_Authenticated,
    RASCS_PrepareForCallback,
    RASCS_WaitForModemReset,
    RASCS_WaitForCallback,
    RASCS_Projected,

#if (WINVER >= 0x400)
    RASCS_StartAuthentication,
    RASCS_CallbackComplete,
    RASCS_LogonNetwork,
#endif
    RASCS_SubEntryConnected,
    RASCS_SubEntryDisconnected,

    RASCS_Interactive = RASCS_PAUSED,
    RASCS_RetryAuthentication,
    RASCS_CallbackSetByCaller,
    RASCS_PasswordExpired,

    RASCS_Connected = RASCS_DONE,
    RASCS_Disconnected
};

#define LPRASCONNSTATE RASCONNSTATE*


/* Describes the status of a RAS connection.  (See RasConnectionStatus)
*/
#define RASCONNSTATUSW struct tagRASCONNSTATUSW
RASCONNSTATUSW
{
    DWORD        dwSize;
    RASCONNSTATE rasconnstate;
    DWORD        dwError;
    WCHAR        szDeviceType[ RAS_MaxDeviceType + 1 ];
    WCHAR        szDeviceName[ RAS_MaxDeviceName + 1 ];
#if (WINVER >= 0x401)
    WCHAR        szPhoneNumber[ RAS_MaxPhoneNumber + 1 ];
#endif
};

#define RASCONNSTATUSA struct tagRASCONNSTATUSA
RASCONNSTATUSA
{
    DWORD        dwSize;
    RASCONNSTATE rasconnstate;
    DWORD        dwError;
    CHAR         szDeviceType[ RAS_MaxDeviceType + 1 ];
    CHAR         szDeviceName[ RAS_MaxDeviceName + 1 ];
#if (WINVER >= 0x401)
    CHAR         szPhoneNumber[ RAS_MaxPhoneNumber + 1 ];
#endif
};

#ifdef UNICODE
#define RASCONNSTATUS RASCONNSTATUSW
#else
#define RASCONNSTATUS RASCONNSTATUSA
#endif

#define LPRASCONNSTATUSW RASCONNSTATUSW*
#define LPRASCONNSTATUSA RASCONNSTATUSA*
#define LPRASCONNSTATUS  RASCONNSTATUS*


/* Describes connection establishment parameters.  (See RasDial)
*/
#define RASDIALPARAMSW struct tagRASDIALPARAMSW
RASDIALPARAMSW
{
    DWORD dwSize;
    WCHAR szEntryName[ RAS_MaxEntryName + 1 ];
    WCHAR szPhoneNumber[ RAS_MaxPhoneNumber + 1 ];
    WCHAR szCallbackNumber[ RAS_MaxCallbackNumber + 1 ];
    WCHAR szUserName[ UNLEN + 1 ];
    WCHAR szPassword[ PWLEN + 1 ];
    WCHAR szDomain[ DNLEN + 1 ];
#if (WINVER >= 0x401)
    DWORD dwSubEntry;
    DWORD dwCallbackId;
#endif
};

#define RASDIALPARAMSA struct tagRASDIALPARAMSA
RASDIALPARAMSA
{
    DWORD dwSize;
    CHAR  szEntryName[ RAS_MaxEntryName + 1 ];
    CHAR  szPhoneNumber[ RAS_MaxPhoneNumber + 1 ];
    CHAR  szCallbackNumber[ RAS_MaxCallbackNumber + 1 ];
    CHAR  szUserName[ UNLEN + 1 ];
    CHAR  szPassword[ PWLEN + 1 ];
    CHAR  szDomain[ DNLEN + 1 ];
#if (WINVER >= 0x401)
    DWORD dwSubEntry;
    DWORD dwCallbackId;
#endif
};

#ifdef UNICODE
#define RASDIALPARAMS RASDIALPARAMSW
#else
#define RASDIALPARAMS RASDIALPARAMSA
#endif

#define LPRASDIALPARAMSW RASDIALPARAMSW*
#define LPRASDIALPARAMSA RASDIALPARAMSA*
#define LPRASDIALPARAMS  RASDIALPARAMS*


/* Describes extended connection establishment options.  (See RasDial)
*/
#define RASDIALEXTENSIONS struct tagRASDIALEXTENSIONS
RASDIALEXTENSIONS
{
    DWORD dwSize;
    DWORD dwfOptions;
    HWND  hwndParent;
    DWORD reserved;
};

#define LPRASDIALEXTENSIONS RASDIALEXTENSIONS*

/* 'dwfOptions' bit flags.
*/
#define RDEOPT_UsePrefixSuffix           0x00000001
#define RDEOPT_PausedStates              0x00000002
#define RDEOPT_IgnoreModemSpeaker        0x00000004
#define RDEOPT_SetModemSpeaker           0x00000008
#define RDEOPT_IgnoreSoftwareCompression 0x00000010
#define RDEOPT_SetSoftwareCompression    0x00000020
#define RDEOPT_DisableConnectedUI        0x00000040
#define RDEOPT_DisableReconnectUI        0x00000080
#define RDEOPT_DisableReconnect          0x00000100
#define RDEOPT_NoUser                    0x00000200
#define RDEOPT_PauseOnScript             0x00000400


/* Describes an enumerated RAS phone book entry name.  (See RasEntryEnum)
*/
#define RASENTRYNAMEW struct tagRASENTRYNAMEW
RASENTRYNAMEW
{
    DWORD dwSize;
    WCHAR szEntryName[ RAS_MaxEntryName + 1 ];
};

#define RASENTRYNAMEA struct tagRASENTRYNAMEA
RASENTRYNAMEA
{
    DWORD dwSize;
    CHAR  szEntryName[ RAS_MaxEntryName + 1 ];
};

#ifdef UNICODE
#define RASENTRYNAME RASENTRYNAMEW
#else
#define RASENTRYNAME RASENTRYNAMEA
#endif

#define LPRASENTRYNAMEW RASENTRYNAMEW*
#define LPRASENTRYNAMEA RASENTRYNAMEA*
#define LPRASENTRYNAME  RASENTRYNAME*


/* Protocol code to projection data structure mapping.
*/
#define RASPROJECTION enum tagRASPROJECTION
RASPROJECTION
{
    RASP_Amb = 0x10000,
    RASP_PppNbf = 0x803F,
    RASP_PppIpx = 0x802B,
    RASP_PppIp = 0x8021,
#if (WINVER >= 0x40A)
    RASP_PppCcp = 0x80FD,
#endif
    RASP_PppLcp = 0xC021,
    RASP_Slip = 0x20000
};

#define LPRASPROJECTION RASPROJECTION*


/* Describes the result of a RAS AMB (Authentication Message Block)
** projection.  This protocol is used with NT 3.1 and OS/2 1.3 downlevel
** RAS servers.
*/
#define RASAMBW struct tagRASAMBW
RASAMBW
{
    DWORD dwSize;
    DWORD dwError;
    WCHAR szNetBiosError[ NETBIOS_NAME_LEN + 1 ];
    BYTE  bLana;
};

#define RASAMBA struct tagRASAMBA
RASAMBA
{
    DWORD dwSize;
    DWORD dwError;
    CHAR  szNetBiosError[ NETBIOS_NAME_LEN + 1 ];
    BYTE  bLana;
};

#ifdef UNICODE
#define RASAMB RASAMBW
#else
#define RASAMB RASAMBA
#endif

#define LPRASAMBW RASAMBW*
#define LPRASAMBA RASAMBA*
#define LPRASAMB  RASAMB*


/* Describes the result of a PPP NBF (NetBEUI) projection.
*/
#define RASPPPNBFW struct tagRASPPPNBFW
RASPPPNBFW
{
    DWORD dwSize;
    DWORD dwError;
    DWORD dwNetBiosError;
    WCHAR szNetBiosError[ NETBIOS_NAME_LEN + 1 ];
    WCHAR szWorkstationName[ NETBIOS_NAME_LEN + 1 ];
    BYTE  bLana;
};

#define RASPPPNBFA struct tagRASPPPNBFA
RASPPPNBFA
{
    DWORD dwSize;
    DWORD dwError;
    DWORD dwNetBiosError;
    CHAR  szNetBiosError[ NETBIOS_NAME_LEN + 1 ];
    CHAR  szWorkstationName[ NETBIOS_NAME_LEN + 1 ];
    BYTE  bLana;
};

#ifdef UNICODE
#define RASPPPNBF RASPPPNBFW
#else
#define RASPPPNBF RASPPPNBFA
#endif

#define LPRASPPPNBFW RASPPPNBFW*
#define LPRASPPPNBFA RASPPPNBFA*
#define LPRASPPPNBF  RASPPPNBF*


/* Describes the results of a PPP IPX (Internetwork Packet Exchange)
** projection.
*/
#define RASPPPIPXW struct tagRASIPXW
RASPPPIPXW
{
    DWORD dwSize;
    DWORD dwError;
    WCHAR szIpxAddress[ RAS_MaxIpxAddress + 1 ];
};


#define RASPPPIPXA struct tagRASPPPIPXA
RASPPPIPXA
{
    DWORD dwSize;
    DWORD dwError;
    CHAR  szIpxAddress[ RAS_MaxIpxAddress + 1 ];
};

#ifdef UNICODE
#define RASPPPIPX RASPPPIPXW
#else
#define RASPPPIPX RASPPPIPXA
#endif

#define LPRASPPPIPXW RASPPPIPXW*
#define LPRASPPPIPXA RASPPPIPXA*
#define LPRASPPPIPX  RASPPPIPX*


/* Describes the results of a PPP IP (Internet) projection.
*/
#define RASPPPIPW struct tagRASPPPIPW
RASPPPIPW
{
    DWORD dwSize;
    DWORD dwError;
    WCHAR szIpAddress[ RAS_MaxIpAddress + 1 ];

#ifndef WINNT35COMPATIBLE

    /* This field was added between Windows NT 3.51 beta and Windows NT 3.51
    ** final, and between Windows 95 M8 beta and Windows 95 final.  If you do
    ** not require the server address and wish to retrieve PPP IP information
    ** from Windows NT 3.5 or early Windows NT 3.51 betas, or on early Windows
    ** 95 betas, define WINNT35COMPATIBLE.
    **
    ** The server IP address is not provided by all PPP implementations,
    ** though Windows NT server's do provide it.
    */
    WCHAR szServerIpAddress[ RAS_MaxIpAddress + 1 ];

#endif
};

#define RASPPPIPA struct tagRASPPPIPA
RASPPPIPA
{
    DWORD dwSize;
    DWORD dwError;
    CHAR  szIpAddress[ RAS_MaxIpAddress + 1 ];

#ifndef WINNT35COMPATIBLE

    /* See RASPPPIPW comment.
    */
    CHAR  szServerIpAddress[ RAS_MaxIpAddress + 1 ];

#endif
};

#ifdef UNICODE
#define RASPPPIP RASPPPIPW
#else
#define RASPPPIP RASPPPIPA
#endif

#define LPRASPPPIPW RASPPPIPW*
#define LPRASPPPIPA RASPPPIPA*
#define LPRASPPPIP  RASPPPIP*


#if (WINVER >= 0x40A)

/* Describes the results of a PPP CCP (Compression Control Protocol) projection.
*/

/* RASPPPCCP 'dwCompressionAlgorithm' values.
*/
#define RASCCPCA_MPPC         0x00000012
#define RASCCPCA_STAC         0x00000011

/* RASPPPCCP 'dwOptions' values.
*/
#define RASCCPO_Compression   0x00000001
#define RASCCPO_Encryption1   0x00000010
#define RASCCPO_Encryption2   0x00000020
#define RASCCPO_Encryption3   0x00000040

#define RASPPPCCPW struct tagRASCCPW
RASPPPCCPW
{
    DWORD dwSize;
    DWORD dwError;
    DWORD dwCompressionAlgorithm;
    DWORD dwOptions;
    DWORD dwServerCompressionAlgorithm;
    DWORD dwServerOptions;
};


#define RASPPPCCPA struct tagRASPPPCCPA
RASPPPCCPA
{
    DWORD dwSize;
    DWORD dwError;
    DWORD dwCompressionAlgorithm;
    DWORD dwOptions;
    DWORD dwServerCompressionAlgorithm;
    DWORD dwServerOptions;
};

#ifdef UNICODE
#define RASPPPCCP RASPPPCCPW
#else
#define RASPPPCCP RASPPPCCPA
#endif

#define LPRASPPPCCPW RASPPPCCPW*
#define LPRASPPPCCPA RASPPPCCPA*
#define LPRASPPPCCP  RASPPPCCP*


/* Describes the results of a PPP LCP (Link Control Protocol) projection.
*/

/* RASPPPLCP 'dwAuthenticatonProtocol' values.
*/
#define RASLCPAP_PAP          0xC023
#define RASLCPAP_SPAP         0xC027
#define RASLCPAP_SPAP_OLD     0xC123
#define RASLCPAP_CHAP         0xC223
#define RASLCPAP_EAP          0xC227

/* RASPPPLCP 'dwAuthenticatonData' values.
*/
#define RASLCPAD_CHAP_MD5     0x05
#define RASLCPAD_CHAP_MS      0x80

#define RASPPPLCPW struct tagRASLCPW
RASPPPLCPW
{
    DWORD dwSize;
    DWORD dwError;
    DWORD dwAuthenticationProtocol;
    DWORD dwAuthenticationData;
    DWORD dwServerAuthenticationProtocol;
    DWORD dwServerAuthenticationData;
    BOOL  fMultilink;
};


#define RASPPPLCPA struct tagRASPPPLCPA
RASPPPLCPA
{
    DWORD dwSize;
    DWORD dwError;
    DWORD dwAuthenticationProtocol;
    DWORD dwAuthenticationData;
    DWORD dwServerAuthenticationProtocol;
    DWORD dwServerAuthenticationData;
    BOOL fMultilink;
};

#ifdef UNICODE
#define RASPPPLCP RASPPPLCPW
#else
#define RASPPPLCP RASPPPLCPA
#endif

#define LPRASPPPLCPW RASPPPLCPW*
#define LPRASPPPLCPA RASPPPLCPA*
#define LPRASPPPLCP  RASPPPLCP*

#else
/* Describes the results of a PPP LCP/multi-link negotiation.
*/

#define RASPPPLCP struct tagRASPPPLCP
RASPPPLCP
{
    DWORD dwSize;
    BOOL  fBundled;
};

#define LPRASPPPLCP RASPPPLCP*


#endif








/* Describes the results of a SLIP (Serial Line IP) projection.
*/
#define RASSLIPW struct tagRASSLIPW
RASSLIPW
{
    DWORD dwSize;
    DWORD dwError;
    WCHAR szIpAddress[ RAS_MaxIpAddress + 1 ];
};


#define RASSLIPA struct tagRASSLIPA
RASSLIPA
{
    DWORD dwSize;
    DWORD dwError;
    CHAR  szIpAddress[ RAS_MaxIpAddress + 1 ];
};

#ifdef UNICODE
#define RASSLIP RASSLIPW
#else
#define RASSLIP RASSLIPA
#endif

#define LPRASSLIPW RASSLIPW*
#define LPRASSLIPA RASSLIPA*
#define LPRASSLIP  RASSLIP*


/* If using RasDial message notifications, get the notification message code
** by passing this string to the RegisterWindowMessageA() API.
** WM_RASDIALEVENT is used only if a unique message cannot be registered.
*/
#define RASDIALEVENT    "RasDialEvent"
#define WM_RASDIALEVENT 0xCCCD

/* Prototypes for caller's RasDial callback handler.  Arguments are the
** message ID (currently always WM_RASDIALEVENT), the current RASCONNSTATE and
** the error that has occurred (or 0 if none).  Extended arguments are the
** handle of the RAS connection and an extended error code.
**
** For RASDIALFUNC2, subsequent callback notifications for all
** subentries can be cancelled by returning FALSE.
*/
typedef VOID (WINAPI *RASDIALFUNC)( UINT, RASCONNSTATE, DWORD );
typedef VOID (WINAPI *RASDIALFUNC1)( HRASCONN, UINT, RASCONNSTATE, DWORD, DWORD );
typedef DWORD (WINAPI *RASDIALFUNC2)( DWORD, DWORD, HRASCONN, UINT, RASCONNSTATE, DWORD, DWORD );


/* Information describing a RAS-capable device.
*/
#define RASDEVINFOW struct tagRASDEVINFOW
RASDEVINFOW
{
    DWORD    dwSize;
    WCHAR    szDeviceType[ RAS_MaxDeviceType + 1 ];
    WCHAR    szDeviceName[ RAS_MaxDeviceName + 1 ];
};

#define RASDEVINFOA struct tagRASDEVINFOA
RASDEVINFOA
{
    DWORD    dwSize;
    CHAR     szDeviceType[ RAS_MaxDeviceType + 1 ];
    CHAR     szDeviceName[ RAS_MaxDeviceName + 1 ];
};

#ifdef UNICODE
#define RASDEVINFO RASDEVINFOW
#else
#define RASDEVINFO RASDEVINFOA
#endif

#define LPRASDEVINFOW RASDEVINFOW*
#define LPRASDEVINFOA RASDEVINFOA*
#define LPRASDEVINFO  RASDEVINFO*

/* RAS country information (currently retrieved from TAPI).
*/
#define RASCTRYINFO struct RASCTRYINFO
RASCTRYINFO
{
    DWORD   dwSize;
    DWORD   dwCountryID;
    DWORD   dwNextCountryID;
    DWORD   dwCountryCode;
    DWORD   dwCountryNameOffset;
};

/* There is currently no difference between
** RASCTRYINFOA and RASCTRYINFOW.  This may
** change in the future.
*/
#define RASCTRYINFOW   RASCTRYINFO
#define RASCTRYINFOA   RASCTRYINFO

#define LPRASCTRYINFOW RASCTRYINFOW*
#define LPRASCTRYINFOA RASCTRYINFOW*
#define LPRASCTRYINFO  RASCTRYINFO*

/* A RAS IP address.
*/
#define RASIPADDR struct RASIPADDR
RASIPADDR
{
    BYTE a;
    BYTE b;
    BYTE c;
    BYTE d;
};

#define LPRASIPADDR RASIPADDR*

/* A RAS phone book entry.
*/
#define RASENTRYA struct tagRASENTRYA
RASENTRYA
{
    DWORD       dwSize;
    DWORD       dwfOptions;
    //
    // Location/phone number.
    //
    DWORD       dwCountryID;
    DWORD       dwCountryCode;
    CHAR        szAreaCode[ RAS_MaxAreaCode + 1 ];
    CHAR        szLocalPhoneNumber[ RAS_MaxPhoneNumber + 1 ];
    DWORD       dwAlternateOffset;
    //
    // PPP/Ip
    //
    RASIPADDR   ipaddr;
    RASIPADDR   ipaddrDns;
    RASIPADDR   ipaddrDnsAlt;
    RASIPADDR   ipaddrWins;
    RASIPADDR   ipaddrWinsAlt;
    //
    // Framing
    //
    DWORD       dwFrameSize;
    DWORD       dwfNetProtocols;
    DWORD       dwFramingProtocol;
    //
    // Scripting
    //
    CHAR        szScript[ MAX_PATH ];
    //
    // AutoDial
    //
    CHAR        szAutodialDll[ MAX_PATH ];
    CHAR        szAutodialFunc[ MAX_PATH ];
    //
    // Device
    //
    CHAR        szDeviceType[ RAS_MaxDeviceType + 1 ];
    CHAR        szDeviceName[ RAS_MaxDeviceName + 1 ];
    //
    // X.25
    //
    CHAR        szX25PadType[ RAS_MaxPadType + 1 ];
    CHAR        szX25Address[ RAS_MaxX25Address + 1 ];
    CHAR        szX25Facilities[ RAS_MaxFacilities + 1 ];
    CHAR        szX25UserData[ RAS_MaxUserData + 1 ];
    DWORD       dwChannels;
    //
    // Reserved
    //
    DWORD       dwReserved1;
    DWORD       dwReserved2;
#if (WINVER >= 0x401)
    //
    // Multilink
    //
    DWORD       dwSubEntries;
    DWORD       dwDialMode;
    DWORD       dwDialExtraPercent;
    DWORD       dwDialExtraSampleSeconds;
    DWORD       dwHangUpExtraPercent;
    DWORD       dwHangUpExtraSampleSeconds;
    //
    // Idle timeout
    //
    DWORD       dwIdleDisconnectSeconds;
#endif
};

#define RASENTRYW struct tagRASENTRYW
RASENTRYW
{
    DWORD       dwSize;
    DWORD       dwfOptions;
    //
    // Location/phone number
    //
    DWORD       dwCountryID;
    DWORD       dwCountryCode;
    WCHAR       szAreaCode[ RAS_MaxAreaCode + 1 ];
    WCHAR       szLocalPhoneNumber[ RAS_MaxPhoneNumber + 1 ];
    DWORD       dwAlternateOffset;
    //
    // PPP/Ip
    //
    RASIPADDR   ipaddr;
    RASIPADDR   ipaddrDns;
    RASIPADDR   ipaddrDnsAlt;
    RASIPADDR   ipaddrWins;
    RASIPADDR   ipaddrWinsAlt;
    //
    // Framing
    //
    DWORD       dwFrameSize;
    DWORD       dwfNetProtocols;
    DWORD       dwFramingProtocol;
    //
    // Scripting
    //
    WCHAR       szScript[ MAX_PATH ];
    //
    // AutoDial
    //
    WCHAR       szAutodialDll[ MAX_PATH ];
    WCHAR       szAutodialFunc[ MAX_PATH ];
    //
    // Device
    //
    WCHAR       szDeviceType[ RAS_MaxDeviceType + 1 ];
    WCHAR       szDeviceName[ RAS_MaxDeviceName + 1 ];
    //
    // X.25
    //
    WCHAR       szX25PadType[ RAS_MaxPadType + 1 ];
    WCHAR       szX25Address[ RAS_MaxX25Address + 1 ];
    WCHAR       szX25Facilities[ RAS_MaxFacilities + 1 ];
    WCHAR       szX25UserData[ RAS_MaxUserData + 1 ];
    DWORD       dwChannels;
    //
    // Reserved
    //
    DWORD       dwReserved1;
    DWORD       dwReserved2;
#if (WINVER >= 0x401)
    //
    // Multilink
    //
    DWORD       dwSubEntries;
    DWORD       dwDialMode;
    DWORD       dwDialExtraPercent;
    DWORD       dwDialExtraSampleSeconds;
    DWORD       dwHangUpExtraPercent;
    DWORD       dwHangUpExtraSampleSeconds;
    //
    // Idle timeout
    //
    DWORD       dwIdleDisconnectSeconds;
#endif
};

#ifdef UNICODE
#define RASENTRY RASENTRYW
#else
#define RASENTRY RASENTRYA
#endif

#define LPRASENTRYW RASENTRYW*
#define LPRASENTRYA RASENTRYA*
#define LPRASENTRY  RASENTRY*

/* RASENTRY 'dwfOptions' bit flags.
*/
#define RASEO_UseCountryAndAreaCodes    0x00000001
#define RASEO_SpecificIpAddr            0x00000002
#define RASEO_SpecificNameServers       0x00000004
#define RASEO_IpHeaderCompression       0x00000008
#define RASEO_RemoteDefaultGateway      0x00000010
#define RASEO_DisableLcpExtensions      0x00000020
#define RASEO_TerminalBeforeDial        0x00000040
#define RASEO_TerminalAfterDial         0x00000080
#define RASEO_ModemLights               0x00000100
#define RASEO_SwCompression             0x00000200
#define RASEO_RequireEncryptedPw        0x00000400
#define RASEO_RequireMsEncryptedPw      0x00000800
#define RASEO_RequireDataEncryption     0x00001000
#define RASEO_NetworkLogon              0x00002000
#define RASEO_UseLogonCredentials       0x00004000
#define RASEO_PromoteAlternates         0x00008000
#if (WINVER >= 0x401)
#define RASEO_SecureLocalFiles          0x00010000
#endif

/* RASENTRY 'dwProtocols' bit flags.
*/
#define RASNP_NetBEUI                   0x00000001
#define RASNP_Ipx                       0x00000002
#define RASNP_Ip                        0x00000004

/* RASENTRY 'dwFramingProtocols' bit flags.
*/
#define RASFP_Ppp                       0x00000001
#define RASFP_Slip                      0x00000002
#define RASFP_Ras                       0x00000004

/* RASENTRY 'szDeviceType' default strings.
*/
#define RASDT_Modem                     TEXT("modem")
#define RASDT_Isdn                      TEXT("isdn")
#define RASDT_X25                       TEXT("x25")

/* Old AutoDial DLL function prototype.
**
** This prototype is documented for backward-compatibility
** purposes only.  It is superceded by the RASADFUNCA
** and RASADFUNCW definitions below.  DO NOT USE THIS
** PROTOTYPE IN NEW CODE.  SUPPORT FOR IT MAY BE REMOVED
** IN FUTURE VERSIONS OF RAS.
*/
typedef BOOL (WINAPI *ORASADFUNC)( HWND, LPSTR, DWORD, LPDWORD );

#if (WINVER >= 0x401)
/* Flags for RasConnectionNotification().
*/
#define RASCN_Connection        0x00000001
#define RASCN_Disconnection     0x00000002
#define RASCN_BandwidthAdded    0x00000004
#define RASCN_BandwidthRemoved  0x00000008

/* RASENTRY 'dwDialMode' values.
*/
#define RASEDM_DialAll                  1
#define RASEDM_DialAsNeeded             2

/* RASENTRY 'dwIdleDisconnectSeconds' constants.
*/
#define RASIDS_Disabled                 0xffffffff
#define RASIDS_UseGlobalValue           0

/* AutoDial DLL function parameter block.
*/
#define RASADPARAMS struct tagRASADPARAMS
RASADPARAMS
{
    DWORD       dwSize;
    HWND        hwndOwner;
    DWORD       dwFlags;
    LONG        xDlg;
    LONG        yDlg;
};

#define LPRASADPARAMS RASADPARAMS*

/* AutoDial DLL function parameter block 'dwFlags.'
*/
#define RASADFLG_PositionDlg            0x00000001

/* Prototype AutoDial DLL function.
*/
typedef BOOL (WINAPI *RASADFUNCA)( LPSTR, LPSTR, LPRASADPARAMS, LPDWORD );
typedef BOOL (WINAPI *RASADFUNCW)( LPWSTR, LPWSTR, LPRASADPARAMS, LPDWORD );

#ifdef UNICODE
#define RASADFUNC RASADFUNCW
#else
#define RASADFUNC RASADFUNCA
#endif

/* A RAS phone book multilinked sub-entry.
*/
#define RASSUBENTRYA struct tagRASSUBENTRYA
RASSUBENTRYA
{
    DWORD       dwSize;
    DWORD       dwfFlags;
    //
    // Device
    //
    CHAR        szDeviceType[ RAS_MaxDeviceType + 1 ];
    CHAR        szDeviceName[ RAS_MaxDeviceName + 1 ];
    //
    // Phone numbers
    //
    CHAR        szLocalPhoneNumber[ RAS_MaxPhoneNumber + 1 ];
    DWORD       dwAlternateOffset;
};

#define RASSUBENTRYW struct tagRASSUBENTRYW
RASSUBENTRYW
{
    DWORD       dwSize;
    DWORD       dwfFlags;
    //
    // Device
    //
    WCHAR       szDeviceType[ RAS_MaxDeviceType + 1 ];
    WCHAR       szDeviceName[ RAS_MaxDeviceName + 1 ];
    //
    // Phone numbers
    //
    WCHAR       szLocalPhoneNumber[ RAS_MaxPhoneNumber + 1 ];
    DWORD       dwAlternateOffset;
};

#ifdef UNICODE
#define RASSUBENTRY RASSUBENTRYW
#else
#define RASSUBENTRY RASSUBENTRYA
#endif

#define LPRASSUBENTRYW RASSUBENTRYW*
#define LPRASSUBENTRYA RASSUBENTRYA*
#define LPRASSUBENTRY  RASSUBENTRY*

/* Ras{Get,Set}Credentials structure.  These calls
** supercede Ras{Get,Set}EntryDialParams.
*/
#define RASCREDENTIALSA struct tagRASCREDENTIALSA
RASCREDENTIALSA
{
    DWORD dwSize;
    DWORD dwMask;
    CHAR szUserName[ UNLEN + 1 ];
    CHAR szPassword[ PWLEN + 1 ];
    CHAR szDomain[ DNLEN + 1 ];
};

#define RASCREDENTIALSW struct tagRASCREDENTIALSW
RASCREDENTIALSW
{
    DWORD dwSize;
    DWORD dwMask;
    WCHAR szUserName[ UNLEN + 1 ];
    WCHAR szPassword[ PWLEN + 1 ];
    WCHAR szDomain[ DNLEN + 1 ];
};

#ifdef UNICODE
#define RASCREDENTIALS RASCREDENTIALSW
#else
#define RASCREDENTIALS RASCREDENTIALSA
#endif

#define LPRASCREDENTIALSW RASCREDENTIALSW*
#define LPRASCREDENTIALSA RASCREDENTIALSA*
#define LPRASCREDENTIALS  RASCREDENTIALS*

/* RASCREDENTIALS 'dwMask' values.
*/
#define RASCM_UserName       0x00000001
#define RASCM_Password       0x00000002
#define RASCM_Domain         0x00000004

/* AutoDial address properties.
*/
#define RASAUTODIALENTRYA struct tagRASAUTODIALENTRYA
RASAUTODIALENTRYA
{
    DWORD dwSize;
    DWORD dwFlags;
    DWORD dwDialingLocation;
    CHAR szEntry[ RAS_MaxEntryName + 1];
};

#define RASAUTODIALENTRYW struct tagRASAUTODIALENTRYW
RASAUTODIALENTRYW
{
    DWORD dwSize;
    DWORD dwFlags;
    DWORD dwDialingLocation;
    WCHAR szEntry[ RAS_MaxEntryName + 1];
};

#ifdef UNICODE
#define RASAUTODIALENTRY RASAUTODIALENTRYW
#else
#define RASAUTODIALENTRY RASAUTODIALENTRYA
#endif

#define LPRASAUTODIALENTRYW RASAUTODIALENTRYW*
#define LPRASAUTODIALENTRYA RASAUTODIALENTRYA*
#define LPRASAUTODIALENTRY  RASAUTODIALENTRY*

/* AutoDial control parameter values for
** Ras{Get,Set}AutodialParam.
*/
#define RASADP_DisableConnectionQuery           0
#define RASADP_LoginSessionDisable              1
#define RASADP_SavedAddressesLimit              2
#define RASADP_FailedConnectionTimeout          3
#define RASADP_ConnectionQueryTimeout           4

#endif // (WINVER >= 0x401)


/* External RAS API function prototypes.
*/
DWORD APIENTRY RasDialA( LPRASDIALEXTENSIONS, LPSTR, LPRASDIALPARAMSA, DWORD,
                   LPVOID, LPHRASCONN );

DWORD APIENTRY RasDialW( LPRASDIALEXTENSIONS, LPWSTR, LPRASDIALPARAMSW, DWORD,
                   LPVOID, LPHRASCONN );

DWORD APIENTRY RasEnumConnectionsA( LPRASCONNA, LPDWORD, LPDWORD );

DWORD APIENTRY RasEnumConnectionsW( LPRASCONNW, LPDWORD, LPDWORD );

DWORD APIENTRY RasEnumEntriesA( LPSTR, LPSTR, LPRASENTRYNAMEA, LPDWORD,
                   LPDWORD );

DWORD APIENTRY RasEnumEntriesW( LPWSTR, LPWSTR, LPRASENTRYNAMEW, LPDWORD,
                   LPDWORD );

DWORD APIENTRY RasGetConnectStatusA( HRASCONN, LPRASCONNSTATUSA );

DWORD APIENTRY RasGetConnectStatusW( HRASCONN, LPRASCONNSTATUSW );

DWORD APIENTRY RasGetErrorStringA( UINT, LPSTR, DWORD );

DWORD APIENTRY RasGetErrorStringW( UINT, LPWSTR, DWORD );

DWORD APIENTRY RasHangUpA( HRASCONN );

DWORD APIENTRY RasHangUpW( HRASCONN );

DWORD APIENTRY RasGetProjectionInfoA( HRASCONN, RASPROJECTION, LPVOID,
                   LPDWORD );

DWORD APIENTRY RasGetProjectionInfoW( HRASCONN, RASPROJECTION, LPVOID,
                   LPDWORD );

DWORD APIENTRY RasCreatePhonebookEntryA( HWND, LPSTR );

DWORD APIENTRY RasCreatePhonebookEntryW( HWND, LPWSTR );

DWORD APIENTRY RasEditPhonebookEntryA( HWND, LPSTR, LPSTR );

DWORD APIENTRY RasEditPhonebookEntryW( HWND, LPWSTR, LPWSTR );

DWORD APIENTRY RasSetEntryDialParamsA( LPSTR, LPRASDIALPARAMSA, BOOL );

DWORD APIENTRY RasSetEntryDialParamsW( LPWSTR, LPRASDIALPARAMSW, BOOL );

DWORD APIENTRY RasGetEntryDialParamsA( LPSTR, LPRASDIALPARAMSA, LPBOOL );

DWORD APIENTRY RasGetEntryDialParamsW( LPWSTR, LPRASDIALPARAMSW, LPBOOL );

DWORD APIENTRY RasEnumDevicesA( LPRASDEVINFOA, LPDWORD, LPDWORD );

DWORD APIENTRY RasEnumDevicesW( LPRASDEVINFOW, LPDWORD, LPDWORD );

DWORD APIENTRY RasGetCountryInfoA( LPRASCTRYINFOA, LPDWORD );

DWORD APIENTRY RasGetCountryInfoW( LPRASCTRYINFOW, LPDWORD );

DWORD APIENTRY RasGetEntryPropertiesA( LPSTR, LPSTR, LPRASENTRYA, LPDWORD, LPBYTE, LPDWORD );

DWORD APIENTRY RasGetEntryPropertiesW( LPWSTR, LPWSTR, LPRASENTRYW, LPDWORD, LPBYTE, LPDWORD );

DWORD APIENTRY RasSetEntryPropertiesA( LPSTR, LPSTR, LPRASENTRYA, DWORD, LPBYTE, DWORD );

DWORD APIENTRY RasSetEntryPropertiesW( LPWSTR, LPWSTR, LPRASENTRYW, DWORD, LPBYTE, DWORD );

DWORD APIENTRY RasRenameEntryA( LPSTR, LPSTR, LPSTR );

DWORD APIENTRY RasRenameEntryW( LPWSTR, LPWSTR, LPWSTR );

DWORD APIENTRY RasDeleteEntryA( LPSTR, LPSTR );

DWORD APIENTRY RasDeleteEntryW( LPWSTR, LPWSTR );

DWORD APIENTRY RasValidateEntryNameA( LPSTR, LPSTR );

DWORD APIENTRY RasValidateEntryNameW( LPWSTR, LPWSTR );

#if (WINVER >= 0x401)
DWORD APIENTRY RasGetSubEntryHandleA( HRASCONN, DWORD, LPHRASCONN );

DWORD APIENTRY RasGetSubEntryHandleW( HRASCONN, DWORD, LPHRASCONN );

DWORD APIENTRY RasGetCredentialsA( LPSTR, LPSTR, LPRASCREDENTIALSA);

DWORD APIENTRY RasGetCredentialsW( LPWSTR, LPWSTR, LPRASCREDENTIALSW );

DWORD APIENTRY RasSetCredentialsA( LPSTR, LPSTR, LPRASCREDENTIALSA, BOOL );

DWORD APIENTRY RasSetCredentialsW( LPWSTR, LPWSTR, LPRASCREDENTIALSW, BOOL );

DWORD APIENTRY RasConnectionNotificationA( HRASCONN, HANDLE, DWORD );

DWORD APIENTRY RasConnectionNotificationW( HRASCONN, HANDLE, DWORD );

DWORD APIENTRY RasGetSubEntryPropertiesA( LPSTR, LPSTR, DWORD,
                    LPRASSUBENTRYA, LPDWORD, LPBYTE, LPDWORD );

DWORD APIENTRY RasGetSubEntryPropertiesW( LPWSTR, LPWSTR, DWORD,
                    LPRASSUBENTRYW, LPDWORD, LPBYTE, LPDWORD );

DWORD APIENTRY RasSetSubEntryPropertiesA( LPSTR, LPSTR, DWORD,
                    LPRASSUBENTRYA, DWORD, LPBYTE, DWORD );

DWORD APIENTRY RasSetSubEntryPropertiesW( LPWSTR, LPWSTR, DWORD,
                    LPRASSUBENTRYW, DWORD, LPBYTE, DWORD );

DWORD APIENTRY RasDeleteSubEntryA( LPSTR, LPSTR, DWORD );

DWORD APIENTRY RasDeleteSubEntryW( LPWSTR, LPWSTR, DWORD );

DWORD APIENTRY RasGetAutodialAddressA( LPSTR, LPDWORD, LPRASAUTODIALENTRYA,
                    LPDWORD, LPDWORD );

DWORD APIENTRY RasGetAutodialAddressW( LPWSTR, LPDWORD, LPRASAUTODIALENTRYW,
                    LPDWORD, LPDWORD);

DWORD APIENTRY RasSetAutodialAddressA( LPSTR, DWORD, LPRASAUTODIALENTRYA,
                    DWORD, DWORD );

DWORD APIENTRY RasSetAutodialAddressW( LPWSTR, DWORD, LPRASAUTODIALENTRYW,
                    DWORD, DWORD );

DWORD APIENTRY RasEnumAutodialAddressesA( LPSTR *, LPDWORD, LPDWORD );

DWORD APIENTRY RasEnumAutodialAddressesW( LPWSTR *, LPDWORD, LPDWORD );

DWORD APIENTRY RasGetAutodialEnableA( DWORD, LPBOOL );

DWORD APIENTRY RasGetAutodialEnableW( DWORD, LPBOOL );

DWORD APIENTRY RasSetAutodialEnableA( DWORD, BOOL );

DWORD APIENTRY RasSetAutodialEnableW( DWORD, BOOL );

DWORD APIENTRY RasGetAutodialParamA( DWORD, LPVOID, LPDWORD );

DWORD APIENTRY RasGetAutodialParamW( DWORD, LPVOID, LPDWORD );

DWORD APIENTRY RasSetAutodialParamA( DWORD, LPVOID, DWORD );

DWORD APIENTRY RasSetAutodialParamW( DWORD, LPVOID, DWORD );
#endif


#ifdef UNICODE
#define RasDial                 RasDialW
#define RasEnumConnections      RasEnumConnectionsW
#define RasEnumEntries          RasEnumEntriesW
#define RasGetConnectStatus     RasGetConnectStatusW
#define RasGetErrorString       RasGetErrorStringW
#define RasHangUp               RasHangUpW
#define RasGetProjectionInfo    RasGetProjectionInfoW
#define RasCreatePhonebookEntry RasCreatePhonebookEntryW
#define RasEditPhonebookEntry   RasEditPhonebookEntryW
#define RasSetEntryDialParams   RasSetEntryDialParamsW
#define RasGetEntryDialParams   RasGetEntryDialParamsW
#define RasEnumDevices          RasEnumDevicesW
#define RasGetCountryInfo       RasGetCountryInfoW
#define RasGetEntryProperties   RasGetEntryPropertiesW
#define RasSetEntryProperties   RasSetEntryPropertiesW
#define RasRenameEntry          RasRenameEntryW
#define RasDeleteEntry          RasDeleteEntryW
#define RasValidateEntryName    RasValidateEntryNameW
#if (WINVER >= 0x401)
#define RasGetSubEntryHandle        RasGetSubEntryHandleW
#define RasConnectionNotification   RasConnectionNotificationW
#define RasGetSubEntryProperties    RasGetSubEntryPropertiesW
#define RasSetSubEntryProperties    RasSetSubEntryPropertiesW
#define RasDeleteSubEntry           RasDeleteSubEntryW
#define RasGetCredentials           RasGetCredentialsW
#define RasSetCredentials           RasSetCredentialsW
#define RasGetAutodialAddress       RasGetAutodialAddressW
#define RasSetAutodialAddress       RasSetAutodialAddressW
#define RasEnumAutodialAddresses    RasEnumAutodialAddressesW
#define RasGetAutodialEnable        RasGetAutodialEnableW
#define RasSetAutodialEnable        RasSetAutodialEnableW
#define RasGetAutodialParam         RasGetAutodialParamW
#define RasSetAutodialParam         RasSetAutodialParamW
#endif
#else
#define RasDial                 RasDialA
#define RasEnumConnections      RasEnumConnectionsA
#define RasEnumEntries          RasEnumEntriesA
#define RasGetConnectStatus     RasGetConnectStatusA
#define RasGetErrorString       RasGetErrorStringA
#define RasHangUp               RasHangUpA
#define RasGetProjectionInfo    RasGetProjectionInfoA
#define RasCreatePhonebookEntry RasCreatePhonebookEntryA
#define RasEditPhonebookEntry   RasEditPhonebookEntryA
#define RasSetEntryDialParams   RasSetEntryDialParamsA
#define RasGetEntryDialParams   RasGetEntryDialParamsA
#define RasEnumDevices          RasEnumDevicesA
#define RasGetCountryInfo       RasGetCountryInfoA
#define RasGetEntryProperties   RasGetEntryPropertiesA
#define RasSetEntryProperties   RasSetEntryPropertiesA
#define RasRenameEntry          RasRenameEntryA
#define RasDeleteEntry          RasDeleteEntryA
#define RasValidateEntryName    RasValidateEntryNameA
#if (WINVER >= 0x401)
#define RasGetSubEntryHandle        RasGetSubEntryHandleA
#define RasConnectionNotification   RasConnectionNotificationA
#define RasGetSubEntryProperties    RasGetSubEntryPropertiesA
#define RasSetSubEntryProperties    RasSetSubEntryPropertiesA
#define RasDeleteSubEntry           RasDeleteSubEntryA
#define RasGetCredentials           RasGetCredentialsA
#define RasSetCredentials           RasSetCredentialsA
#define RasGetAutodialAddress       RasGetAutodialAddressA
#define RasSetAutodialAddress       RasSetAutodialAddressA
#define RasEnumAutodialAddresses    RasEnumAutodialAddressesA
#define RasGetAutodialEnable        RasGetAutodialEnableA
#define RasSetAutodialEnable        RasSetAutodialEnableA
#define RasGetAutodialParam         RasGetAutodialParamA
#define RasSetAutodialParam         RasSetAutodialParamA
#endif
#endif

#ifdef __cplusplus
}
#endif

#include <poppack.h>

#endif // _RAS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\tools\c932\inc\rpc.h ===
/*++

Copyright (c) 1991-1995 Microsoft Corporation

Module Name:

    rpc.h

Abstract:

    Master include file for RPC applications.

--*/

#ifndef RPC_NO_WINDOWS_H
#include <windows.h>
#endif // RPC_NO_WINDOWS_H

#ifndef __RPC_H__
#define __RPC_H__

#ifdef __cplusplus
extern "C" {
#endif

#define __RPC_WIN32__

#ifndef __MIDL_USER_DEFINED
#define midl_user_allocate MIDL_user_allocate
#define midl_user_free     MIDL_user_free
#define __MIDL_USER_DEFINED
#endif

typedef void * I_RPC_HANDLE;
typedef long RPC_STATUS;

#define RPC_UNICODE_SUPPORTED
#if   (_MSC_VER >= 800)
#define __RPC_FAR
#define __RPC_API  __stdcall
#define __RPC_USER __stdcall
#define __RPC_STUB __stdcall
#define RPC_ENTRY  __stdcall
#else
#define __RPC_FAR
#define __RPC_API
#define __RPC_USER
#define __RPC_STUB
#define RPC_ENTRY
#endif

#ifdef IN
#undef IN
#undef OUT
#undef OPTIONAL
#endif /* IN */

#include "rpcdce.h"
#include "rpcnsi.h"
#include "rpcnterr.h"


#include <excpt.h>
#include <winerror.h>

#define RpcTryExcept \
    __try \
        {

// trystmts

#define RpcExcept(expr) \
        } \
    __except (expr) \
        {

// exceptstmts

#define RpcEndExcept \
        }

#define RpcTryFinally \
    __try \
        {

// trystmts

#define RpcFinally \
        } \
    __finally \
        {

// finallystmts

#define RpcEndFinally \
        }

#define RpcExceptionCode() GetExceptionCode()
#define RpcAbnormalTermination() AbnormalTermination()

RPC_STATUS RPC_ENTRY
RpcImpersonateClient (
    IN RPC_BINDING_HANDLE BindingHandle OPTIONAL
    );

RPC_STATUS RPC_ENTRY
RpcRevertToSelf (
    );

long RPC_ENTRY
I_RpcMapWin32Status (
    IN RPC_STATUS Status
    );

#ifdef __cplusplus
}
#endif

#endif // __RPC_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\tools\c932\inc\raserror.h ===
/* Copyright (c) 1992, Microsoft Corporation, all rights reserved
**
** raserror.h
** Remote Access external API
** RAS specific error codes
*/

#ifndef _RASERROR_H_
#define _RASERROR_H_


#define RASBASE 600
#define SUCCESS 0


#define PENDING                              (RASBASE+0)
#define ERROR_INVALID_PORT_HANDLE            (RASBASE+1)
#define ERROR_PORT_ALREADY_OPEN              (RASBASE+2)
#define ERROR_BUFFER_TOO_SMALL               (RASBASE+3)
#define ERROR_WRONG_INFO_SPECIFIED           (RASBASE+4)
#define ERROR_CANNOT_SET_PORT_INFO           (RASBASE+5)
#define ERROR_PORT_NOT_CONNECTED             (RASBASE+6)
#define ERROR_EVENT_INVALID                  (RASBASE+7)
#define ERROR_DEVICE_DOES_NOT_EXIST          (RASBASE+8)
#define ERROR_DEVICETYPE_DOES_NOT_EXIST      (RASBASE+9)
#define ERROR_BUFFER_INVALID                 (RASBASE+10)
#define ERROR_ROUTE_NOT_AVAILABLE            (RASBASE+11)
#define ERROR_ROUTE_NOT_ALLOCATED            (RASBASE+12)
#define ERROR_INVALID_COMPRESSION_SPECIFIED  (RASBASE+13)
#define ERROR_OUT_OF_BUFFERS                 (RASBASE+14)
#define ERROR_PORT_NOT_FOUND                 (RASBASE+15)
#define ERROR_ASYNC_REQUEST_PENDING          (RASBASE+16)
#define ERROR_ALREADY_DISCONNECTING          (RASBASE+17)
#define ERROR_PORT_NOT_OPEN                  (RASBASE+18)
#define ERROR_PORT_DISCONNECTED              (RASBASE+19)
#define ERROR_NO_ENDPOINTS                   (RASBASE+20)
#define ERROR_CANNOT_OPEN_PHONEBOOK          (RASBASE+21)
#define ERROR_CANNOT_LOAD_PHONEBOOK          (RASBASE+22)
#define ERROR_CANNOT_FIND_PHONEBOOK_ENTRY    (RASBASE+23)
#define ERROR_CANNOT_WRITE_PHONEBOOK         (RASBASE+24)
#define ERROR_CORRUPT_PHONEBOOK              (RASBASE+25)
#define ERROR_CANNOT_LOAD_STRING             (RASBASE+26)
#define ERROR_KEY_NOT_FOUND                  (RASBASE+27)
#define ERROR_DISCONNECTION                  (RASBASE+28)
#define ERROR_REMOTE_DISCONNECTION           (RASBASE+29)
#define ERROR_HARDWARE_FAILURE               (RASBASE+30)
#define ERROR_USER_DISCONNECTION             (RASBASE+31)
#define ERROR_INVALID_SIZE                   (RASBASE+32)
#define ERROR_PORT_NOT_AVAILABLE             (RASBASE+33)
#define ERROR_CANNOT_PROJECT_CLIENT          (RASBASE+34)
#define ERROR_UNKNOWN                        (RASBASE+35)
#define ERROR_WRONG_DEVICE_ATTACHED          (RASBASE+36)
#define ERROR_BAD_STRING                     (RASBASE+37)
#define ERROR_REQUEST_TIMEOUT                (RASBASE+38)
#define ERROR_CANNOT_GET_LANA                (RASBASE+39)
#define ERROR_NETBIOS_ERROR                  (RASBASE+40)
#define ERROR_SERVER_OUT_OF_RESOURCES        (RASBASE+41)
#define ERROR_NAME_EXISTS_ON_NET             (RASBASE+42)
#define ERROR_SERVER_GENERAL_NET_FAILURE     (RASBASE+43)
#define WARNING_MSG_ALIAS_NOT_ADDED          (RASBASE+44)
#define ERROR_AUTH_INTERNAL                  (RASBASE+45)
#define ERROR_RESTRICTED_LOGON_HOURS         (RASBASE+46)
#define ERROR_ACCT_DISABLED                  (RASBASE+47)
#define ERROR_PASSWD_EXPIRED                 (RASBASE+48)
#define ERROR_NO_DIALIN_PERMISSION           (RASBASE+49)
#define ERROR_SERVER_NOT_RESPONDING          (RASBASE+50)
#define ERROR_FROM_DEVICE                    (RASBASE+51)
#define ERROR_UNRECOGNIZED_RESPONSE          (RASBASE+52)
#define ERROR_MACRO_NOT_FOUND                (RASBASE+53)
#define ERROR_MACRO_NOT_DEFINED              (RASBASE+54)
#define ERROR_MESSAGE_MACRO_NOT_FOUND        (RASBASE+55)
#define ERROR_DEFAULTOFF_MACRO_NOT_FOUND     (RASBASE+56)
#define ERROR_FILE_COULD_NOT_BE_OPENED       (RASBASE+57)
#define ERROR_DEVICENAME_TOO_LONG            (RASBASE+58)
#define ERROR_DEVICENAME_NOT_FOUND           (RASBASE+59)
#define ERROR_NO_RESPONSES                   (RASBASE+60)
#define ERROR_NO_COMMAND_FOUND               (RASBASE+61)
#define ERROR_WRONG_KEY_SPECIFIED            (RASBASE+62)
#define ERROR_UNKNOWN_DEVICE_TYPE            (RASBASE+63)
#define ERROR_ALLOCATING_MEMORY              (RASBASE+64)
#define ERROR_PORT_NOT_CONFIGURED            (RASBASE+65)
#define ERROR_DEVICE_NOT_READY               (RASBASE+66)
#define ERROR_READING_INI_FILE               (RASBASE+67)
#define ERROR_NO_CONNECTION                  (RASBASE+68)
#define ERROR_BAD_USAGE_IN_INI_FILE          (RASBASE+69)
#define ERROR_READING_SECTIONNAME            (RASBASE+70)
#define ERROR_READING_DEVICETYPE             (RASBASE+71)
#define ERROR_READING_DEVICENAME             (RASBASE+72)
#define ERROR_READING_USAGE                  (RASBASE+73)
#define ERROR_READING_MAXCONNECTBPS          (RASBASE+74)
#define ERROR_READING_MAXCARRIERBPS          (RASBASE+75)
#define ERROR_LINE_BUSY                      (RASBASE+76)
#define ERROR_VOICE_ANSWER                   (RASBASE+77)
#define ERROR_NO_ANSWER                      (RASBASE+78)
#define ERROR_NO_CARRIER                     (RASBASE+79)
#define ERROR_NO_DIALTONE                    (RASBASE+80)
#define ERROR_IN_COMMAND                     (RASBASE+81)
#define ERROR_WRITING_SECTIONNAME            (RASBASE+82)
#define ERROR_WRITING_DEVICETYPE             (RASBASE+83)
#define ERROR_WRITING_DEVICENAME             (RASBASE+84)
#define ERROR_WRITING_MAXCONNECTBPS          (RASBASE+85)
#define ERROR_WRITING_MAXCARRIERBPS          (RASBASE+86)
#define ERROR_WRITING_USAGE                  (RASBASE+87)
#define ERROR_WRITING_DEFAULTOFF             (RASBASE+88)
#define ERROR_READING_DEFAULTOFF             (RASBASE+89)
#define ERROR_EMPTY_INI_FILE                 (RASBASE+90)
#define ERROR_AUTHENTICATION_FAILURE         (RASBASE+91)
#define ERROR_PORT_OR_DEVICE                 (RASBASE+92)
#define ERROR_NOT_BINARY_MACRO               (RASBASE+93)
#define ERROR_DCB_NOT_FOUND                  (RASBASE+94)
#define ERROR_STATE_MACHINES_NOT_STARTED     (RASBASE+95)
#define ERROR_STATE_MACHINES_ALREADY_STARTED (RASBASE+96)
#define ERROR_PARTIAL_RESPONSE_LOOPING       (RASBASE+97)
#define ERROR_UNKNOWN_RESPONSE_KEY           (RASBASE+98)
#define ERROR_RECV_BUF_FULL                  (RASBASE+99)
#define ERROR_CMD_TOO_LONG                   (RASBASE+100)
#define ERROR_UNSUPPORTED_BPS                (RASBASE+101)
#define ERROR_UNEXPECTED_RESPONSE            (RASBASE+102)
#define ERROR_INTERACTIVE_MODE               (RASBASE+103)
#define ERROR_BAD_CALLBACK_NUMBER            (RASBASE+104)
#define ERROR_INVALID_AUTH_STATE             (RASBASE+105)
#define ERROR_WRITING_INITBPS                (RASBASE+106)
#define ERROR_X25_DIAGNOSTIC                 (RASBASE+107)
#define ERROR_ACCT_EXPIRED                   (RASBASE+108)
#define ERROR_CHANGING_PASSWORD              (RASBASE+109)
#define ERROR_OVERRUN                        (RASBASE+110)
#define ERROR_RASMAN_CANNOT_INITIALIZE	     (RASBASE+111)
#define ERROR_BIPLEX_PORT_NOT_AVAILABLE      (RASBASE+112)
#define ERROR_NO_ACTIVE_ISDN_LINES           (RASBASE+113)
#define ERROR_NO_ISDN_CHANNELS_AVAILABLE     (RASBASE+114)
#define ERROR_TOO_MANY_LINE_ERRORS	     (RASBASE+115)
#define ERROR_IP_CONFIGURATION		     (RASBASE+116)
#define ERROR_NO_IP_ADDRESSES		     (RASBASE+117)
#define ERROR_PPP_TIMEOUT                    (RASBASE+118)
#define ERROR_PPP_REMOTE_TERMINATED          (RASBASE+119)
#define ERROR_PPP_NO_PROTOCOLS_CONFIGURED    (RASBASE+120)
#define ERROR_PPP_NO_RESPONSE                (RASBASE+121)
#define ERROR_PPP_INVALID_PACKET             (RASBASE+122)
#define ERROR_PHONE_NUMBER_TOO_LONG          (RASBASE+123)
#define ERROR_IPXCP_NO_DIALOUT_CONFIGURED    (RASBASE+124)
#define ERROR_IPXCP_NO_DIALIN_CONFIGURED     (RASBASE+125)
#define ERROR_IPXCP_DIALOUT_ALREADY_ACTIVE   (RASBASE+126)
#define ERROR_ACCESSING_TCPCFGDLL            (RASBASE+127)
#define ERROR_NO_IP_RAS_ADAPTER              (RASBASE+128)
#define ERROR_SLIP_REQUIRES_IP               (RASBASE+129)
#define ERROR_PROJECTION_NOT_COMPLETE        (RASBASE+130)
#define ERROR_PROTOCOL_NOT_CONFIGURED        (RASBASE+131)
#define ERROR_PPP_NOT_CONVERGING             (RASBASE+132)
#define ERROR_PPP_CP_REJECTED                (RASBASE+133)
#define ERROR_PPP_LCP_TERMINATED             (RASBASE+134)
#define ERROR_PPP_REQUIRED_ADDRESS_REJECTED  (RASBASE+135)
#define ERROR_PPP_NCP_TERMINATED             (RASBASE+136)
#define ERROR_PPP_LOOPBACK_DETECTED          (RASBASE+137)
#define ERROR_PPP_NO_ADDRESS_ASSIGNED        (RASBASE+138)

#define RASBASEEND			     (RASBASE+138)


#endif // _RASERROR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\tools\c932\inc\rpcnsip.h ===
/*++

Copyright (c) 1992-1995 Microsoft Corporation

Module Name:

    rpcnsip.h

Abstract:

    This file contains the types and function definitions to use the
    to implement the autohandle features of the runtime.

--*/

#ifndef __RPCNSIP_H__
#define __RPCNSIP_H__

#ifdef __cplusplus
extern "C" {
#endif

typedef struct
{
   RPC_NS_HANDLE        LookupContext;
   RPC_BINDING_HANDLE   ProposedHandle;
   RPC_BINDING_VECTOR * Bindings;

} RPC_IMPORT_CONTEXT_P, * PRPC_IMPORT_CONTEXT_P;


/* Stub Auto Binding routines. */

RPC_STATUS RPC_ENTRY
I_RpcNsGetBuffer(
    IN PRPC_MESSAGE Message
    );

RPC_STATUS RPC_ENTRY
I_RpcNsSendReceive(
    IN PRPC_MESSAGE Message,
    OUT RPC_BINDING_HANDLE __RPC_FAR * Handle
    );

void RPC_ENTRY
I_RpcNsRaiseException(
    IN PRPC_MESSAGE Message,
    IN RPC_STATUS Status
    );

RPC_STATUS RPC_ENTRY
I_RpcReBindBuffer(
    IN PRPC_MESSAGE Message
    );

RPC_STATUS RPC_ENTRY
I_NsServerBindSearch(
    );

RPC_STATUS RPC_ENTRY
I_NsClientBindSearch(
    );

void RPC_ENTRY
I_NsClientBindDone(
    );

#ifdef __cplusplus
}
#endif

#endif /* __RPCNSIP_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\tools\c932\inc\rpcnterr.h ===
/*********************************************************/
/**               Microsoft LAN Manager                 **/
/**       Copyright(c) Microsoft Corp., 1987-1995       **/
/**                                                     **/
/**     Rpc Error Codes from the compiler and runtime   **/
/**                                                     **/
/*********************************************************/

/*
If you change this file, you must also change rpcerr.h.
*/

#ifndef __RPCNTERR_H__
#define __RPCNTERR_H__

#define RPC_S_OK                          ERROR_SUCCESS
#define RPC_S_INVALID_ARG                 ERROR_INVALID_PARAMETER
#define RPC_S_OUT_OF_MEMORY               ERROR_OUTOFMEMORY
#define RPC_S_OUT_OF_THREADS              ERROR_MAX_THRDS_REACHED
#define RPC_S_INVALID_LEVEL               ERROR_INVALID_PARAMETER
#define RPC_S_BUFFER_TOO_SMALL            ERROR_INSUFFICIENT_BUFFER
#define RPC_S_INVALID_SECURITY_DESC       ERROR_INVALID_SECURITY_DESCR
#define RPC_S_ACCESS_DENIED               ERROR_ACCESS_DENIED
#define RPC_S_SERVER_OUT_OF_MEMORY        ERROR_NOT_ENOUGH_SERVER_MEMORY

#define RPC_X_NO_MEMORY                   RPC_S_OUT_OF_MEMORY
#define RPC_X_INVALID_BOUND               RPC_S_INVALID_BOUND
#define RPC_X_INVALID_TAG                 RPC_S_INVALID_TAG
#define RPC_X_ENUM_VALUE_TOO_LARGE        RPC_X_ENUM_VALUE_OUT_OF_RANGE
#define RPC_X_SS_CONTEXT_MISMATCH         ERROR_INVALID_HANDLE
#define RPC_X_INVALID_BUFFER              ERROR_INVALID_USER_BUFFER

#endif /* __RPCNTERR_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\tools\c932\inc\rpcdce.h ===
/*++

Copyright (c) 1991-1995 Microsoft Corporation

Module Name:

    rpcdce.h

Abstract:

    This module contains the DCE RPC runtime APIs.

--*/

#ifndef __RPCDCE_H__
#define __RPCDCE_H__

#ifdef __cplusplus
extern "C" {
#endif

#define IN
#define OUT
#define OPTIONAL

/*typedef char small;*/
/*typedef unsigned char byte;*/
/*typedef unsigned char boolean;*/

typedef I_RPC_HANDLE RPC_BINDING_HANDLE;
typedef RPC_BINDING_HANDLE handle_t;
#define rpc_binding_handle_t RPC_BINDING_HANDLE

#ifndef GUID_DEFINED
#define GUID_DEFINED
typedef struct _GUID
{
    unsigned long Data1;
    unsigned short Data2;
    unsigned short Data3;
    unsigned char Data4[8];
} GUID;
#endif /* GUID_DEFINED */

#ifndef UUID_DEFINED
#define UUID_DEFINED
typedef GUID UUID;
#ifndef uuid_t
#define uuid_t UUID
#endif
#endif

typedef struct _RPC_BINDING_VECTOR
{
    unsigned long Count;
    RPC_BINDING_HANDLE BindingH[1];
} RPC_BINDING_VECTOR;
#ifndef rpc_binding_vector_t
#define rpc_binding_vector_t RPC_BINDING_VECTOR
#endif

typedef struct _UUID_VECTOR
{
  unsigned long Count;
  UUID *Uuid[1];
} UUID_VECTOR;
#ifndef uuid_vector_t
#define uuid_vector_t UUID_VECTOR
#endif

typedef void __RPC_FAR * RPC_IF_HANDLE;

#ifndef IFID_DEFINED
#define IFID_DEFINED
typedef struct _RPC_IF_ID
{
    UUID Uuid;
    unsigned short VersMajor;
    unsigned short VersMinor;
} RPC_IF_ID;
#endif

#define RPC_C_BINDING_INFINITE_TIMEOUT 10
#define RPC_C_BINDING_MIN_TIMEOUT 0
#define RPC_C_BINDING_DEFAULT_TIMEOUT 5
#define RPC_C_BINDING_MAX_TIMEOUT 9

#define RPC_C_CANCEL_INFINITE_TIMEOUT -1

#define RPC_C_LISTEN_MAX_CALLS_DEFAULT 1234
#define RPC_C_PROTSEQ_MAX_REQS_DEFAULT 10

#ifdef RPC_UNICODE_SUPPORTED

typedef struct _RPC_PROTSEQ_VECTORA
{
    unsigned int Count;
    unsigned char __RPC_FAR * Protseq[1];
} RPC_PROTSEQ_VECTORA;

typedef struct _RPC_PROTSEQ_VECTORW
{
    unsigned int Count;
    unsigned short __RPC_FAR * Protseq[1];
} RPC_PROTSEQ_VECTORW;

#ifdef UNICODE
#define RPC_PROTSEQ_VECTOR RPC_PROTSEQ_VECTORW
#else /* UNICODE */
#define RPC_PROTSEQ_VECTOR RPC_PROTSEQ_VECTORA
#endif /* UNICODE */

#else /* RPC_UNICODE_SUPPORTED */

typedef struct _RPC_PROTSEQ_VECTOR
{
    unsigned int Count;
    unsigned char __RPC_FAR * Protseq[1];
} RPC_PROTSEQ_VECTOR;

#endif /* RPC_UNICODE_SUPPORTED */

typedef void __RPC_USER
RPC_OBJECT_INQ_FN (
    IN UUID __RPC_FAR * ObjectUuid,
    OUT UUID __RPC_FAR * TypeUuid,
    OUT RPC_STATUS __RPC_FAR * Status
    );

#define RPC_MGR_EPV void

typedef struct
{
    unsigned int Count;
    unsigned long Stats[1];
} RPC_STATS_VECTOR;

#define RPC_C_STATS_CALLS_IN 0
#define RPC_C_STATS_CALLS_OUT 1
#define RPC_C_STATS_PKTS_IN 2
#define RPC_C_STATS_PKTS_OUT 3

typedef struct
{
  unsigned long Count;
  RPC_IF_ID __RPC_FAR * IfId[1];
} RPC_IF_ID_VECTOR;

/* client */
RPC_STATUS RPC_ENTRY
RpcBindingCopy (
    IN RPC_BINDING_HANDLE SourceBinding,
    OUT RPC_BINDING_HANDLE __RPC_FAR * DestinationBinding
    );

/* client */
RPC_STATUS RPC_ENTRY
RpcBindingFree (
    IN OUT RPC_BINDING_HANDLE __RPC_FAR * Binding
    );

/* client */

#ifdef RPC_UNICODE_SUPPORTED

RPC_STATUS RPC_ENTRY
RpcBindingFromStringBindingA (
    IN unsigned char __RPC_FAR * StringBinding,
    OUT RPC_BINDING_HANDLE __RPC_FAR * Binding
    );

RPC_STATUS RPC_ENTRY
RpcBindingFromStringBindingW (
    IN unsigned short __RPC_FAR * StringBinding,
    OUT RPC_BINDING_HANDLE __RPC_FAR * Binding
    );

#ifdef UNICODE
#define RpcBindingFromStringBinding RpcBindingFromStringBindingW
#else /* UNICODE */
#define RpcBindingFromStringBinding RpcBindingFromStringBindingA
#endif /* UNICODE */

#else /* RPC_UNICODE_SUPPORTED */

RPC_STATUS RPC_ENTRY
RpcBindingFromStringBinding (
    IN unsigned char __RPC_FAR * StringBinding,
    OUT RPC_BINDING_HANDLE __RPC_FAR * Binding
    );

#endif /* RPC_UNICODE_SUPPORTED */

/* RpcBindingInqAuthClient */
/* RpcBindingInqAuthInfo */

/* client/server */
RPC_STATUS RPC_ENTRY
RpcBindingInqObject (
    IN RPC_BINDING_HANDLE Binding,
    OUT UUID __RPC_FAR * ObjectUuid
    );

/* client */
RPC_STATUS RPC_ENTRY
RpcBindingReset (
    IN RPC_BINDING_HANDLE Binding
    );

/* RpcBindingServerFromClient : UNSUPPORTED */
/* RpcBindingSetAuthInfo */

/* client */
RPC_STATUS RPC_ENTRY
RpcBindingSetObject (
    IN RPC_BINDING_HANDLE Binding,
    IN UUID __RPC_FAR * ObjectUuid
    );

/* client/server */
RPC_STATUS RPC_ENTRY
RpcMgmtInqDefaultProtectLevel(
    IN  unsigned long AuthnSvc,
    OUT unsigned long __RPC_FAR *AuthnLevel
    );

/* client/server */

#ifdef RPC_UNICODE_SUPPORTED

RPC_STATUS RPC_ENTRY
RpcBindingToStringBindingA (
    IN RPC_BINDING_HANDLE Binding,
    OUT unsigned char __RPC_FAR * __RPC_FAR * StringBinding
    );

RPC_STATUS RPC_ENTRY
RpcBindingToStringBindingW (
    IN RPC_BINDING_HANDLE Binding,
    OUT unsigned short __RPC_FAR * __RPC_FAR * StringBinding
    );

#ifdef UNICODE
#define RpcBindingToStringBinding RpcBindingToStringBindingW
#else /* UNICODE */
#define RpcBindingToStringBinding RpcBindingToStringBindingA
#endif /* UNICODE */

#else /* RPC_UNICODE_SUPPORTED */

RPC_STATUS RPC_ENTRY
RpcBindingToStringBinding (
    IN RPC_BINDING_HANDLE Binding,
    OUT unsigned char __RPC_FAR * __RPC_FAR * StringBinding
    );

#endif /* RPC_UNICODE_SUPPORTED */

/* client/server */
RPC_STATUS RPC_ENTRY
RpcBindingVectorFree (
    IN OUT RPC_BINDING_VECTOR __RPC_FAR * __RPC_FAR * BindingVector
    );

/* client/server */

#ifdef RPC_UNICODE_SUPPORTED

RPC_STATUS RPC_ENTRY
RpcStringBindingComposeA (
    IN unsigned char __RPC_FAR * ObjUuid OPTIONAL,
    IN unsigned char __RPC_FAR * Protseq OPTIONAL,
    IN unsigned char __RPC_FAR * NetworkAddr OPTIONAL,
    IN unsigned char __RPC_FAR * Endpoint OPTIONAL,
    IN unsigned char __RPC_FAR * Options OPTIONAL,
    OUT unsigned char __RPC_FAR * __RPC_FAR * StringBinding OPTIONAL
    );

RPC_STATUS RPC_ENTRY
RpcStringBindingComposeW (
    IN unsigned short __RPC_FAR * ObjUuid OPTIONAL,
    IN unsigned short __RPC_FAR * Protseq OPTIONAL,
    IN unsigned short __RPC_FAR * NetworkAddr OPTIONAL,
    IN unsigned short __RPC_FAR * Endpoint OPTIONAL,
    IN unsigned short __RPC_FAR * Options OPTIONAL,
    OUT unsigned short __RPC_FAR * __RPC_FAR * StringBinding OPTIONAL
    );

#ifdef UNICODE
#define RpcStringBindingCompose RpcStringBindingComposeW
#else /* UNICODE */
#define RpcStringBindingCompose RpcStringBindingComposeA
#endif /* UNICODE */

#else /* RPC_UNICODE_SUPPORTED */

RPC_STATUS RPC_ENTRY
RpcStringBindingCompose (
    IN unsigned char __RPC_FAR * ObjUuid OPTIONAL,
    IN unsigned char __RPC_FAR * Protseq OPTIONAL,
    IN unsigned char __RPC_FAR * NetworkAddr OPTIONAL,
    IN unsigned char __RPC_FAR * Endpoint OPTIONAL,
    IN unsigned char __RPC_FAR * Options OPTIONAL,
    OUT unsigned char __RPC_FAR * __RPC_FAR * StringBinding OPTIONAL
    );

#endif /* RPC_UNICODE_SUPPORTED */

/* client/server */

#ifdef RPC_UNICODE_SUPPORTED

RPC_STATUS RPC_ENTRY
RpcStringBindingParseA (
    IN unsigned char __RPC_FAR * StringBinding,
    OUT unsigned char __RPC_FAR * __RPC_FAR * ObjUuid OPTIONAL,
    OUT unsigned char __RPC_FAR * __RPC_FAR * Protseq OPTIONAL,
    OUT unsigned char __RPC_FAR * __RPC_FAR * NetworkAddr OPTIONAL,
    OUT unsigned char __RPC_FAR * __RPC_FAR * Endpoint OPTIONAL,
    OUT unsigned char __RPC_FAR * __RPC_FAR * NetworkOptions OPTIONAL
    );

RPC_STATUS RPC_ENTRY
RpcStringBindingParseW (
    IN unsigned short __RPC_FAR * StringBinding,
    OUT unsigned short __RPC_FAR * __RPC_FAR * ObjUuid OPTIONAL,
    OUT unsigned short __RPC_FAR * __RPC_FAR * Protseq OPTIONAL,
    OUT unsigned short __RPC_FAR * __RPC_FAR * NetworkAddr OPTIONAL,
    OUT unsigned short __RPC_FAR * __RPC_FAR * Endpoint OPTIONAL,
    OUT unsigned short __RPC_FAR * __RPC_FAR * NetworkOptions OPTIONAL
    );

#ifdef UNICODE
#define RpcStringBindingParse RpcStringBindingParseW
#else /* UNICODE */
#define RpcStringBindingParse RpcStringBindingParseA
#endif /* UNICODE */

#else /* RPC_UNICODE_SUPPORTED */

RPC_STATUS RPC_ENTRY
RpcStringBindingParse (
    IN unsigned char __RPC_FAR * StringBinding,
    OUT unsigned char __RPC_FAR * __RPC_FAR * ObjUuid OPTIONAL,
    OUT unsigned char __RPC_FAR * __RPC_FAR * Protseq OPTIONAL,
    OUT unsigned char __RPC_FAR * __RPC_FAR * NetworkAddr OPTIONAL,
    OUT unsigned char __RPC_FAR * __RPC_FAR * Endpoint OPTIONAL,
    OUT unsigned char __RPC_FAR * __RPC_FAR * NetworkOptions OPTIONAL
    );

#endif /* RPC_UNICODE_SUPPORTED */

/* client/server */

#ifdef RPC_UNICODE_SUPPORTED

RPC_STATUS RPC_ENTRY
RpcStringFreeA (
    IN OUT unsigned char __RPC_FAR * __RPC_FAR * String
    );

RPC_STATUS RPC_ENTRY
RpcStringFreeW (
    IN OUT unsigned short __RPC_FAR * __RPC_FAR * String
    );

#ifdef UNICODE
#define RpcStringFree RpcStringFreeW
#else /* UNICODE */
#define RpcStringFree RpcStringFreeA
#endif /* UNICODE */

#else /* RPC_UNICODE_SUPPORTED */

RPC_STATUS RPC_ENTRY
RpcStringFree (
    IN OUT unsigned char __RPC_FAR * __RPC_FAR * String
    );

#endif /* RPC_UNICODE_SUPPORTED */

/* client/server */
RPC_STATUS RPC_ENTRY
RpcIfInqId (
    IN RPC_IF_HANDLE RpcIfHandle,
    OUT RPC_IF_ID __RPC_FAR * RpcIfId
    );

/* client/server */

#ifdef RPC_UNICODE_SUPPORTED

RPC_STATUS RPC_ENTRY
RpcNetworkIsProtseqValidA (
    IN unsigned char __RPC_FAR * Protseq
    );

RPC_STATUS RPC_ENTRY
RpcNetworkIsProtseqValidW (
    IN unsigned short __RPC_FAR * Protseq
    );

#ifdef UNICODE
#define RpcNetworkIsProtseqValid RpcNetworkIsProtseqValidW
#else /* UNICODE */
#define RpcNetworkIsProtseqValid RpcNetworkIsProtseqValidA
#endif /* UNICODE */

#else /* RPC_UNICODE_SUPPORTED */

RPC_STATUS RPC_ENTRY
RpcNetworkIsProtseqValid (
    IN unsigned char __RPC_FAR * Protseq
    );

#endif /* RPC_UNICODE_SUPPORTED */

/* client */
RPC_STATUS RPC_ENTRY
RpcMgmtInqComTimeout (
    IN RPC_BINDING_HANDLE Binding,
    OUT unsigned int __RPC_FAR * Timeout
    );

/* client */
RPC_STATUS RPC_ENTRY
RpcMgmtSetComTimeout (
    IN RPC_BINDING_HANDLE Binding,
    IN unsigned int Timeout
    );

/* client */
RPC_STATUS RPC_ENTRY
RpcMgmtSetCancelTimeout(
    long Timeout
    );


/* server */

#ifdef RPC_UNICODE_SUPPORTED

RPC_STATUS RPC_ENTRY
RpcNetworkInqProtseqsA (
    OUT RPC_PROTSEQ_VECTORA __RPC_FAR * __RPC_FAR * ProtseqVector
    );

RPC_STATUS RPC_ENTRY
RpcNetworkInqProtseqsW (
    OUT RPC_PROTSEQ_VECTORW __RPC_FAR * __RPC_FAR * ProtseqVector
    );

#ifdef UNICODE
#define RpcNetworkInqProtseqs RpcNetworkInqProtseqsW
#else /* UNICODE */
#define RpcNetworkInqProtseqs RpcNetworkInqProtseqsA
#endif /* UNICODE */

#else /* RPC_UNICODE_SUPPORTED */

RPC_STATUS RPC_ENTRY
RpcNetworkInqProtseqs (
    OUT RPC_PROTSEQ_VECTOR __RPC_FAR * __RPC_FAR * ProtseqVector
    );

#endif /* RPC_UNICODE_SUPPORTED */

/* server */
RPC_STATUS RPC_ENTRY
RpcObjectInqType (
    IN UUID __RPC_FAR * ObjUuid,
    OUT UUID __RPC_FAR * TypeUuid OPTIONAL
    );

/* server */
RPC_STATUS RPC_ENTRY
RpcObjectSetInqFn (
    IN RPC_OBJECT_INQ_FN __RPC_FAR * InquiryFn
    );

/* server */
RPC_STATUS RPC_ENTRY
RpcObjectSetType (
    IN UUID __RPC_FAR * ObjUuid,
    IN UUID __RPC_FAR * TypeUuid OPTIONAL
    );

/* server */

#ifdef RPC_UNICODE_SUPPORTED

RPC_STATUS RPC_ENTRY
RpcProtseqVectorFreeA (
    IN OUT RPC_PROTSEQ_VECTORA __RPC_FAR * __RPC_FAR * ProtseqVector
    );

RPC_STATUS RPC_ENTRY
RpcProtseqVectorFreeW (
    IN OUT RPC_PROTSEQ_VECTORW __RPC_FAR * __RPC_FAR * ProtseqVector
    );

#ifdef UNICODE
#define RpcProtseqVectorFree RpcProtseqVectorFreeW
#else /* UNICODE */
#define RpcProtseqVectorFree RpcProtseqVectorFreeA
#endif /* UNICODE */

#else /* RPC_UNICODE_SUPPORTED */

RPC_STATUS RPC_ENTRY
RpcProtseqVectorFree (
    IN OUT RPC_PROTSEQ_VECTOR __RPC_FAR * __RPC_FAR * ProtseqVector
    );

#endif /* RPC_UNICODE_SUPPORTED */

/* server */
RPC_STATUS RPC_ENTRY
RpcServerInqBindings (
    OUT RPC_BINDING_VECTOR __RPC_FAR * __RPC_FAR * BindingVector
    );

/* server */
RPC_STATUS RPC_ENTRY
RpcServerInqIf (
    IN RPC_IF_HANDLE IfSpec,
    IN UUID __RPC_FAR * MgrTypeUuid, OPTIONAL
    OUT RPC_MGR_EPV __RPC_FAR * __RPC_FAR * MgrEpv
    );

/* server */
RPC_STATUS RPC_ENTRY
RpcServerListen (
    IN unsigned int MinimumCallThreads,
    IN unsigned int MaxCalls,
    IN unsigned int DontWait
    );

/* server */
RPC_STATUS RPC_ENTRY
RpcServerRegisterIf (
    IN RPC_IF_HANDLE IfSpec,
    IN UUID __RPC_FAR * MgrTypeUuid OPTIONAL,
    IN RPC_MGR_EPV __RPC_FAR * MgrEpv OPTIONAL
    );

/* server */
RPC_STATUS RPC_ENTRY
RpcServerUnregisterIf (
    IN RPC_IF_HANDLE IfSpec,
    IN UUID __RPC_FAR * MgrTypeUuid, OPTIONAL
    IN unsigned int WaitForCallsToComplete
    );

/* server */
RPC_STATUS RPC_ENTRY
RpcServerUseAllProtseqs (
    IN unsigned int MaxCalls,
    IN void __RPC_FAR * SecurityDescriptor OPTIONAL
    );

/* server */
RPC_STATUS RPC_ENTRY
RpcServerUseAllProtseqsIf (
    IN unsigned int MaxCalls,
    IN RPC_IF_HANDLE IfSpec,
    IN void __RPC_FAR * SecurityDescriptor OPTIONAL
    );

/* server */

#ifdef RPC_UNICODE_SUPPORTED

RPC_STATUS RPC_ENTRY
RpcServerUseProtseqA (
    IN unsigned char __RPC_FAR * Protseq,
    IN unsigned int MaxCalls,
    IN void __RPC_FAR * SecurityDescriptor OPTIONAL
    );

RPC_STATUS RPC_ENTRY
RpcServerUseProtseqW (
    IN unsigned short __RPC_FAR * Protseq,
    IN unsigned int MaxCalls,
    IN void __RPC_FAR * SecurityDescriptor OPTIONAL
    );

#ifdef UNICODE
#define RpcServerUseProtseq RpcServerUseProtseqW
#else /* UNICODE */
#define RpcServerUseProtseq RpcServerUseProtseqA
#endif /* UNICODE */

#else /* RPC_UNICODE_SUPPORTED */

RPC_STATUS RPC_ENTRY
RpcServerUseProtseq (
    IN unsigned char __RPC_FAR * Protseq,
    IN unsigned int MaxCalls,
    IN void __RPC_FAR * SecurityDescriptor OPTIONAL
    );

#endif /* RPC_UNICODE_SUPPORTED */

/* server */

#ifdef RPC_UNICODE_SUPPORTED

RPC_STATUS RPC_ENTRY
RpcServerUseProtseqEpA (
    IN unsigned char __RPC_FAR * Protseq,
    IN unsigned int MaxCalls,
    IN unsigned char __RPC_FAR * Endpoint,
    IN void __RPC_FAR * SecurityDescriptor OPTIONAL
    );

RPC_STATUS RPC_ENTRY
RpcServerUseProtseqEpW (
    IN unsigned short __RPC_FAR * Protseq,
    IN unsigned int MaxCalls,
    IN unsigned short __RPC_FAR * Endpoint,
    IN void __RPC_FAR * SecurityDescriptor OPTIONAL
    );

#ifdef UNICODE
#define RpcServerUseProtseqEp RpcServerUseProtseqEpW
#else /* UNICODE */
#define RpcServerUseProtseqEp RpcServerUseProtseqEpA
#endif /* UNICODE */

#else /* RPC_UNICODE_SUPPORTED */

RPC_STATUS RPC_ENTRY
RpcServerUseProtseqEp (
    IN unsigned char __RPC_FAR * Protseq,
    IN unsigned int MaxCalls,
    IN unsigned char __RPC_FAR * Endpoint,
    IN void __RPC_FAR * SecurityDescriptor OPTIONAL
    );

#endif /* RPC_UNICODE_SUPPORTED */

/* server */

#ifdef RPC_UNICODE_SUPPORTED

RPC_STATUS RPC_ENTRY
RpcServerUseProtseqIfA (
    IN unsigned char __RPC_FAR * Protseq,
    IN unsigned int MaxCalls,
    IN RPC_IF_HANDLE IfSpec,
    IN void __RPC_FAR * SecurityDescriptor OPTIONAL
    );

RPC_STATUS RPC_ENTRY
RpcServerUseProtseqIfW (
    IN unsigned short __RPC_FAR * Protseq,
    IN unsigned int MaxCalls,
    IN RPC_IF_HANDLE IfSpec,
    IN void __RPC_FAR * SecurityDescriptor OPTIONAL
    );

#ifdef UNICODE
#define RpcServerUseProtseqIf RpcServerUseProtseqIfW
#else /* UNICODE */
#define RpcServerUseProtseqIf RpcServerUseProtseqIfA
#endif /* UNICODE */

#else /* RPC_UNICODE_SUPPORTED */

RPC_STATUS RPC_ENTRY
RpcServerUseProtseqIf (
    IN unsigned char __RPC_FAR * Protseq,
    IN unsigned int MaxCalls,
    IN RPC_IF_HANDLE IfSpec,
    IN void __RPC_FAR * SecurityDescriptor OPTIONAL
    );

#endif /* RPC_UNICODE_SUPPORTED */

/* server */
RPC_STATUS RPC_ENTRY
RpcMgmtStatsVectorFree (
    IN RPC_STATS_VECTOR ** StatsVector
    );

/* server */
RPC_STATUS RPC_ENTRY
RpcMgmtInqStats (
    IN RPC_BINDING_HANDLE Binding,
    OUT RPC_STATS_VECTOR ** Statistics
    );

/* server */
RPC_STATUS RPC_ENTRY
RpcMgmtIsServerListening (
    IN RPC_BINDING_HANDLE Binding
    );

/* server */
RPC_STATUS RPC_ENTRY
RpcMgmtStopServerListening (
    IN RPC_BINDING_HANDLE Binding
    );

/* server */
RPC_STATUS RPC_ENTRY
RpcMgmtWaitServerListen (
    void
    );

/* server */
RPC_STATUS RPC_ENTRY
RpcMgmtSetServerStackSize (
    IN unsigned long ThreadStackSize
    );

/* client */
RPC_STATUS RPC_ENTRY
RpcMgmtEnableIdleCleanup (
    void
    );

RPC_STATUS RPC_ENTRY
RpcMgmtInqIfIds (
    IN RPC_BINDING_HANDLE Binding,
    OUT RPC_IF_ID_VECTOR __RPC_FAR * __RPC_FAR * IfIdVector
    );

RPC_STATUS RPC_ENTRY
RpcIfIdVectorFree (
    IN OUT RPC_IF_ID_VECTOR __RPC_FAR * __RPC_FAR * IfIdVector
    );

#ifdef RPC_UNICODE_SUPPORTED

RPC_STATUS RPC_ENTRY
RpcMgmtInqServerPrincNameA (
    IN RPC_BINDING_HANDLE Binding,
    IN unsigned long AuthnSvc,
    OUT unsigned char __RPC_FAR * __RPC_FAR * ServerPrincName
    );

RPC_STATUS RPC_ENTRY
RpcMgmtInqServerPrincNameW (
    IN RPC_BINDING_HANDLE Binding,
    IN unsigned long AuthnSvc,
    OUT unsigned short __RPC_FAR * __RPC_FAR * ServerPrincName
    );

#ifdef UNICODE
#define RpcMgmtInqServerPrincName RpcMgmtInqServerPrincNameW
#else /* UNICODE */
#define RpcMgmtInqServerPrincName RpcMgmtInqServerPrincNameA
#endif /* UNICODE */

#else /* RPC_UNICODE_SUPPORTED */

RPC_STATUS RPC_ENTRY
RpcMgmtInqServerPrincName (
    IN RPC_BINDING_HANDLE Binding,
    IN unsigned long AuthnSvc,
    OUT unsigned char __RPC_FAR * __RPC_FAR * ServerPrincName
    );

#endif /* RPC_UNICODE_SUPPORTED */

#ifdef RPC_UNICODE_SUPPORTED

RPC_STATUS RPC_ENTRY
RpcServerInqDefaultPrincNameA (
    IN unsigned long AuthnSvc,
    OUT unsigned char __RPC_FAR * __RPC_FAR * PrincName
    );

RPC_STATUS RPC_ENTRY
RpcServerInqDefaultPrincNameW (
    IN unsigned long AuthnSvc,
    OUT unsigned short __RPC_FAR * __RPC_FAR * PrincName
    );

#ifdef UNICODE
#define RpcServerInqDefaultPrincName RpcServerInqDefaultPrincNameW
#else /* UNICODE */
#define RpcServerInqDefaultPrincName RpcServerInqDefaultPrincNameA
#endif /* UNICODE */

#else /* RPC_UNICODE_SUPPORTED */

RPC_STATUS RPC_ENTRY
RpcServerInqDefaultPrincName (
    IN unsigned long AuthnSvc,
    OUT unsigned char __RPC_FAR * __RPC_FAR * PrincName
    );

#endif /* RPC_UNICODE_SUPPORTED */

/* client */
RPC_STATUS RPC_ENTRY
RpcEpResolveBinding (
    IN RPC_BINDING_HANDLE Binding,
    IN RPC_IF_HANDLE IfSpec
    );

/* client */

#ifdef RPC_UNICODE_SUPPORTED

RPC_STATUS RPC_ENTRY
RpcNsBindingInqEntryNameA (
    IN RPC_BINDING_HANDLE Binding,
    IN unsigned long EntryNameSyntax,
    OUT unsigned char __RPC_FAR * __RPC_FAR * EntryName
    );

RPC_STATUS RPC_ENTRY
RpcNsBindingInqEntryNameW (
    IN RPC_BINDING_HANDLE Binding,
    IN unsigned long EntryNameSyntax,
    OUT unsigned short __RPC_FAR * __RPC_FAR * EntryName
    );

#ifdef UNICODE
#define RpcNsBindingInqEntryName RpcNsBindingInqEntryNameW
#else /* UNICODE */
#define RpcNsBindingInqEntryName RpcNsBindingInqEntryNameA
#endif /* UNICODE */

#else /* RPC_UNICODE_SUPPORTED */

RPC_STATUS RPC_ENTRY
RpcNsBindingInqEntryName (
    IN RPC_BINDING_HANDLE Binding,
    IN unsigned long EntryNameSyntax,
    OUT unsigned char __RPC_FAR * __RPC_FAR * EntryName
    );

#endif /* RPC_UNICODE_SUPPORTED */

typedef void __RPC_FAR * RPC_AUTH_IDENTITY_HANDLE;
typedef void __RPC_FAR * RPC_AUTHZ_HANDLE;

#define RPC_C_AUTHN_LEVEL_DEFAULT 0
#define RPC_C_AUTHN_LEVEL_NONE 1
#define RPC_C_AUTHN_LEVEL_CONNECT 2
#define RPC_C_AUTHN_LEVEL_CALL 3
#define RPC_C_AUTHN_LEVEL_PKT 4
#define RPC_C_AUTHN_LEVEL_PKT_INTEGRITY 5
#define RPC_C_AUTHN_LEVEL_PKT_PRIVACY 6


#define RPC_C_PROTECT_LEVEL_DEFAULT       (RPC_C_AUTHN_LEVEL_DEFAULT)
#define RPC_C_PROTECT_LEVEL_NONE          (RPC_C_AUTHN_LEVEL_NONE)
#define RPC_C_PROTECT_LEVEL_CONNECT       (RPC_C_AUTHN_LEVEL_CONNECT)
#define RPC_C_PROTECT_LEVEL_CALL          (RPC_C_AUTHN_LEVEL_CALL)
#define RPC_C_PROTECT_LEVEL_PKT           (RPC_C_AUTHN_LEVEL_PKT)
#define RPC_C_PROTECT_LEVEL_PKT_INTEGRITY (RPC_C_AUTHN_LEVEL_PKT_INTEGRITY)
#define RPC_C_PROTECT_LEVEL_PKT_PRIVACY   (RPC_C_AUTHN_LEVEL_PKT_PRIVACY)

#define RPC_C_AUTHN_NONE 0
#define RPC_C_AUTHN_DCE_PRIVATE 1
#define RPC_C_AUTHN_DCE_PUBLIC 2
#define RPC_C_AUTHN_DEC_PUBLIC 4
#define RPC_C_AUTHN_WINNT       10
#define RPC_C_AUTHN_DEFAULT 0xFFFFFFFFL

#if defined(__RPC_DOS__) || defined(__RPC_WIN16__)
typedef struct _SEC_WINNT_AUTH_IDENTITY
{
  char __RPC_FAR *User;
  char __RPC_FAR *Domain;
  char __RPC_FAR *Password;
} SEC_WINNT_AUTH_IDENTITY;
#else


#define SEC_WINNT_AUTH_IDENTITY_ANSI 0x1
#define SEC_WINNT_AUTH_IDENTITY_UNICODE 0x2

typedef struct _SEC_WINNT_AUTH_IDENTITY_W {
  unsigned short __RPC_FAR *User;
  unsigned long UserLength;
  unsigned short __RPC_FAR *Domain;
  unsigned long DomainLength;
  unsigned short __RPC_FAR *Password;
  unsigned long PasswordLength;
  unsigned long Flags;
} SEC_WINNT_AUTH_IDENTITY_W, *PSEC_WINNT_AUTH_IDENTITY_W;

typedef struct _SEC_WINNT_AUTH_IDENTITY_A {
  unsigned char __RPC_FAR *User;
  unsigned long UserLength;
  unsigned char __RPC_FAR *Domain;
  unsigned long DomainLength;
  unsigned char __RPC_FAR *Password;
  unsigned long PasswordLength;
  unsigned long Flags;
} SEC_WINNT_AUTH_IDENTITY_A, *PSEC_WINNT_AUTH_IDENTITY_A;

#ifdef UNICODE
#define SEC_WINNT_AUTH_IDENTITY SEC_WINNT_AUTH_IDENTITY_W
#define PSEC_WINNT_AUTH_IDENTITY PSEC_WINNT_AUTH_IDENTITY_W
#define _SEC_WINNT_AUTH_IDENTITY _SEC_WINNT_AUTH_IDENTITY_W
#else // UNICODE
#define SEC_WINNT_AUTH_IDENTITY SEC_WINNT_AUTH_IDENTITY_A
#define PSEC_WINNT_AUTH_IDENTITY PSEC_WINNT_AUTH_IDENTITY_A
#define _SEC_WINNT_AUTH_IDENTITY _SEC_WINNT_AUTH_IDENTITY_A
#endif // UNICODE
#endif // defined(__RPC_DOS__) || defined(__RPC_WIN16__)

#define RPC_C_AUTHZ_NONE 0
#define RPC_C_AUTHZ_NAME 1
#define RPC_C_AUTHZ_DCE 2

#ifdef RPC_UNICODE_SUPPORTED

RPC_STATUS RPC_ENTRY
RpcBindingInqAuthClientA (
    IN RPC_BINDING_HANDLE ClientBinding, OPTIONAL
    OUT RPC_AUTHZ_HANDLE __RPC_FAR * Privs,
    OUT unsigned char __RPC_FAR * __RPC_FAR * ServerPrincName, OPTIONAL
    OUT unsigned long __RPC_FAR * AuthnLevel, OPTIONAL
    OUT unsigned long __RPC_FAR * AuthnSvc, OPTIONAL
    OUT unsigned long __RPC_FAR * AuthzSvc OPTIONAL
    );

RPC_STATUS RPC_ENTRY
RpcBindingInqAuthClientW (
    IN RPC_BINDING_HANDLE ClientBinding, OPTIONAL
    OUT RPC_AUTHZ_HANDLE __RPC_FAR * Privs,
    OUT unsigned short __RPC_FAR * __RPC_FAR * ServerPrincName, OPTIONAL
    OUT unsigned long __RPC_FAR * AuthnLevel, OPTIONAL
    OUT unsigned long __RPC_FAR * AuthnSvc, OPTIONAL
    OUT unsigned long __RPC_FAR * AuthzSvc OPTIONAL
    );

RPC_STATUS RPC_ENTRY
RpcBindingInqAuthInfoA (
    IN RPC_BINDING_HANDLE Binding,
    OUT unsigned char __RPC_FAR * __RPC_FAR * ServerPrincName, OPTIONAL
    OUT unsigned long __RPC_FAR * AuthnLevel, OPTIONAL
    OUT unsigned long __RPC_FAR * AuthnSvc, OPTIONAL
    OUT RPC_AUTH_IDENTITY_HANDLE __RPC_FAR * AuthIdentity, OPTIONAL
    OUT unsigned long __RPC_FAR * AuthzSvc OPTIONAL
    );

RPC_STATUS RPC_ENTRY
RpcBindingInqAuthInfoW (
    IN RPC_BINDING_HANDLE Binding,
    OUT unsigned short __RPC_FAR * __RPC_FAR * ServerPrincName, OPTIONAL
    OUT unsigned long __RPC_FAR * AuthnLevel, OPTIONAL
    OUT unsigned long __RPC_FAR * AuthnSvc, OPTIONAL
    OUT RPC_AUTH_IDENTITY_HANDLE __RPC_FAR * AuthIdentity, OPTIONAL
    OUT unsigned long __RPC_FAR * AuthzSvc OPTIONAL
    );

RPC_STATUS RPC_ENTRY
RpcBindingSetAuthInfoA (
    IN RPC_BINDING_HANDLE Binding,
    IN unsigned char __RPC_FAR * ServerPrincName,
    IN unsigned long AuthnLevel,
    IN unsigned long AuthnSvc,
    IN RPC_AUTH_IDENTITY_HANDLE AuthIdentity, OPTIONAL
    IN unsigned long AuthzSvc
    );

RPC_STATUS RPC_ENTRY
RpcBindingSetAuthInfoW (
    IN RPC_BINDING_HANDLE Binding,
    IN unsigned short __RPC_FAR * ServerPrincName,
    IN unsigned long AuthnLevel,
    IN unsigned long AuthnSvc,
    IN RPC_AUTH_IDENTITY_HANDLE AuthIdentity, OPTIONAL
    IN unsigned long AuthzSvc
    );

typedef void
(__RPC_USER * RPC_AUTH_KEY_RETRIEVAL_FN) (
    IN void __RPC_FAR * Arg,
    IN unsigned short __RPC_FAR * ServerPrincName,
    IN unsigned long KeyVer,
    OUT void __RPC_FAR * __RPC_FAR * Key,
    OUT RPC_STATUS __RPC_FAR * Status
    );

RPC_STATUS RPC_ENTRY
RpcServerRegisterAuthInfoA (
    IN unsigned char __RPC_FAR * ServerPrincName,
    IN unsigned long AuthnSvc,
    IN RPC_AUTH_KEY_RETRIEVAL_FN GetKeyFn OPTIONAL,
    IN void __RPC_FAR * Arg OPTIONAL
    );

RPC_STATUS RPC_ENTRY
RpcServerRegisterAuthInfoW (
    IN unsigned short __RPC_FAR * ServerPrincName,
    IN unsigned long AuthnSvc,
    IN RPC_AUTH_KEY_RETRIEVAL_FN GetKeyFn OPTIONAL,
    IN void __RPC_FAR * Arg OPTIONAL
    );

#ifdef UNICODE
#define RpcBindingInqAuthClient RpcBindingInqAuthClientW
#define RpcBindingInqAuthInfo RpcBindingInqAuthInfoW
#define RpcBindingSetAuthInfo RpcBindingSetAuthInfoW
#define RpcServerRegisterAuthInfo RpcServerRegisterAuthInfoW
#else /* UNICODE */
#define RpcBindingInqAuthClient RpcBindingInqAuthClientA
#define RpcBindingInqAuthInfo RpcBindingInqAuthInfoA
#define RpcBindingSetAuthInfo RpcBindingSetAuthInfoA
#define RpcServerRegisterAuthInfo RpcServerRegisterAuthInfoA
#endif /* UNICODE */

#else /* RPC_UNICODE_SUPPORTED */

RPC_STATUS RPC_ENTRY
RpcBindingInqAuthClient (
    IN RPC_BINDING_HANDLE ClientBinding, OPTIONAL
    OUT RPC_AUTHZ_HANDLE __RPC_FAR * Privs,
    OUT unsigned char __RPC_FAR * __RPC_FAR * ServerPrincName, OPTIONAL
    OUT unsigned long __RPC_FAR * AuthnLevel, OPTIONAL
    OUT unsigned long __RPC_FAR * AuthnSvc, OPTIONAL
    OUT unsigned long __RPC_FAR * AuthzSvc OPTIONAL
    );

RPC_STATUS RPC_ENTRY
RpcBindingInqAuthInfo (
    IN RPC_BINDING_HANDLE Binding,
    OUT unsigned char __RPC_FAR * __RPC_FAR * ServerPrincName, OPTIONAL
    OUT unsigned long __RPC_FAR * AuthnLevel, OPTIONAL
    OUT unsigned long __RPC_FAR * AuthnSvc, OPTIONAL
    OUT RPC_AUTH_IDENTITY_HANDLE __RPC_FAR * AuthIdentity, OPTIONAL
    OUT unsigned long __RPC_FAR * AuthzSvc OPTIONAL
    );

RPC_STATUS RPC_ENTRY
RpcBindingSetAuthInfo (
    IN RPC_BINDING_HANDLE Binding,
    IN unsigned char __RPC_FAR * ServerPrincName,
    IN unsigned long AuthnLevel,
    IN unsigned long AuthnSvc,
    IN RPC_AUTH_IDENTITY_HANDLE AuthIdentity, OPTIONAL
    IN unsigned long AuthzSvc
    );

typedef void
(__RPC_USER * RPC_AUTH_KEY_RETRIEVAL_FN) (
    IN void __RPC_FAR * Arg,
    IN unsigned char __RPC_FAR * ServerPrincName,
    IN unsigned long KeyVer,
    OUT void __RPC_FAR * __RPC_FAR * Key,
    OUT RPC_STATUS __RPC_FAR * Status
    );

RPC_STATUS RPC_ENTRY
RpcServerRegisterAuthInfo (
    IN unsigned char __RPC_FAR * ServerPrincName,
    IN unsigned long AuthnSvc,
    IN RPC_AUTH_KEY_RETRIEVAL_FN GetKeyFn OPTIONAL,
    IN void __RPC_FAR * Arg OPTIONAL
    );

#endif /* RPC_UNICODE_SUPPORTED */

typedef struct {
    unsigned char __RPC_FAR * UserName;
    unsigned char __RPC_FAR * ComputerName;
    unsigned short Privilege;
    unsigned long AuthFlags;
} RPC_CLIENT_INFORMATION1, __RPC_FAR * PRPC_CLIENT_INFORMATION1;

RPC_STATUS RPC_ENTRY
RpcBindingServerFromClient (
    IN RPC_BINDING_HANDLE ClientBinding,
    OUT RPC_BINDING_HANDLE __RPC_FAR * ServerBinding
    );

void RPC_ENTRY
RpcRaiseException (
    IN RPC_STATUS exception
    );

RPC_STATUS RPC_ENTRY
RpcTestCancel(
    );

RPC_STATUS RPC_ENTRY
RpcCancelThread(
    IN void * Thread
    );

/* client/server */
RPC_STATUS RPC_ENTRY
UuidCreate (
    OUT UUID __RPC_FAR * Uuid
    );

#ifdef RPC_UNICODE_SUPPORTED

/* client/server */
RPC_STATUS RPC_ENTRY
UuidToStringA (
    IN UUID __RPC_FAR * Uuid,
    OUT unsigned char __RPC_FAR * __RPC_FAR * StringUuid
    );

/* client/server */
RPC_STATUS RPC_ENTRY
UuidFromStringA (
    IN unsigned char __RPC_FAR * StringUuid,
    OUT UUID __RPC_FAR * Uuid
    );

/* client/server */
RPC_STATUS RPC_ENTRY
UuidToStringW (
    IN UUID __RPC_FAR * Uuid,
    OUT unsigned short __RPC_FAR * __RPC_FAR * StringUuid
    );

/* client/server */
RPC_STATUS RPC_ENTRY
UuidFromStringW (
    IN unsigned short __RPC_FAR * StringUuid,
    OUT UUID __RPC_FAR * Uuid
    );

#ifdef UNICODE
#define UuidFromString UuidFromStringW
#define UuidToString UuidToStringW
#else /* UNICODE */
#define UuidFromString UuidFromStringA
#define UuidToString UuidToStringA
#endif /* UNICODE */

#else /* RPC_UNICODE_SUPPORTED */

/* client/server */
RPC_STATUS RPC_ENTRY
UuidToString (
    IN UUID __RPC_FAR * Uuid,
    OUT unsigned char __RPC_FAR * __RPC_FAR * StringUuid
    );

/* client/server */
RPC_STATUS RPC_ENTRY
UuidFromString (
    IN unsigned char __RPC_FAR * StringUuid,
    OUT UUID __RPC_FAR * Uuid
    );

#endif /* RPC_UNICODE_SUPPORTED */

signed int RPC_ENTRY
UuidCompare (
    IN UUID __RPC_FAR * Uuid1,
    IN UUID __RPC_FAR * Uuid2,
    OUT RPC_STATUS __RPC_FAR * Status
    );

RPC_STATUS RPC_ENTRY
UuidCreateNil (
    OUT UUID __RPC_FAR * NilUuid
    );

int RPC_ENTRY
UuidEqual (
    IN UUID __RPC_FAR * Uuid1,
    IN UUID __RPC_FAR * Uuid2,
    OUT RPC_STATUS __RPC_FAR * Status
    );

unsigned short RPC_ENTRY
UuidHash (
    IN UUID __RPC_FAR * Uuid,
    OUT RPC_STATUS __RPC_FAR * Status
    );

int RPC_ENTRY
UuidIsNil (
    IN UUID __RPC_FAR * Uuid,
    OUT RPC_STATUS __RPC_FAR * Status
    );

#ifdef RPC_UNICODE_SUPPORTED

RPC_STATUS RPC_ENTRY
RpcEpRegisterNoReplaceA (
    IN RPC_IF_HANDLE IfSpec,
    IN RPC_BINDING_VECTOR * BindingVector,
    IN UUID_VECTOR * UuidVector OPTIONAL,
    IN unsigned char * Annotation
    );

RPC_STATUS RPC_ENTRY
RpcEpRegisterNoReplaceW (
    IN RPC_IF_HANDLE IfSpec,
    IN RPC_BINDING_VECTOR * BindingVector,
    IN UUID_VECTOR * UuidVector OPTIONAL,
    IN unsigned short  * Annotation
    );

RPC_STATUS RPC_ENTRY
RpcEpRegisterA (
    IN RPC_IF_HANDLE IfSpec,
    IN RPC_BINDING_VECTOR * BindingVector,
    IN UUID_VECTOR * UuidVector OPTIONAL,
    IN unsigned char * Annotation
    );

RPC_STATUS RPC_ENTRY
RpcEpRegisterW (
    IN RPC_IF_HANDLE IfSpec,
    IN RPC_BINDING_VECTOR * BindingVector,
    IN UUID_VECTOR * UuidVector OPTIONAL,
    IN unsigned short * Annotation
    );

#ifdef UNICODE
#define RpcEpRegisterNoReplace RpcEpRegisterNoReplaceW
#define RpcEpRegister RpcEpRegisterW
#else /* UNICODE */
#define RpcEpRegisterNoReplace RpcEpRegisterNoReplaceA
#define RpcEpRegister RpcEpRegisterA
#endif /* UNICODE */

#else /* RPC_UNICODE_SUPPORTED */

RPC_STATUS RPC_ENTRY
RpcEpRegisterNoReplace (
    IN RPC_IF_HANDLE IfSpec,
    IN RPC_BINDING_VECTOR * BindingVector,
    IN UUID_VECTOR * UuidVector OPTIONAL,
    IN unsigned  char * Annotation
    );

RPC_STATUS RPC_ENTRY
RpcEpRegister (
    IN RPC_IF_HANDLE IfSpec,
    IN RPC_BINDING_VECTOR * BindingVector,
    IN UUID_VECTOR * UuidVector OPTIONAL,
    IN unsigned char * Annotation
    );

#endif /* RPC_UNICODE_SUPPORTED */


RPC_STATUS RPC_ENTRY
RpcEpUnregister(
    IN RPC_IF_HANDLE IfSpec,
    IN RPC_BINDING_VECTOR * BindingVector,
    IN UUID_VECTOR * UuidVector
    );

#ifdef RPC_UNICODE_SUPPORTED

RPC_STATUS RPC_ENTRY
DceErrorInqTextA (
    IN RPC_STATUS RpcStatus,
    OUT unsigned char __RPC_FAR * ErrorText
    );

RPC_STATUS RPC_ENTRY
DceErrorInqTextW (
    IN RPC_STATUS RpcStatus,
    OUT unsigned short __RPC_FAR * ErrorText
    );

#ifdef UNICODE
#define DceErrorInqText DceErrorInqTextW
#else /* UNICODE */
#define DceErrorInqText DceErrorInqTextA
#endif /* UNICODE */

#else /* RPC_UNICODE_SUPPORTED */

RPC_STATUS RPC_ENTRY
DceErrorInqText (
    IN RPC_STATUS RpcStatus,
    OUT unsigned char __RPC_FAR * ErrorText
    );

#endif /* RPC_UNICODE_SUPPORTED */

#define DCE_C_ERROR_STRING_LEN 256

typedef I_RPC_HANDLE * RPC_EP_INQ_HANDLE;

#define  RPC_C_EP_ALL_ELTS        0
#define  RPC_C_EP_MATCH_BY_IF     1
#define  RPC_C_EP_MATCH_BY_OBJ    2
#define  RPC_C_EP_MATCH_BY_BOTH   3

#define  RPC_C_VERS_ALL           1
#define  RPC_C_VERS_COMPATIBLE    2
#define  RPC_C_VERS_EXACT         3
#define  RPC_C_VERS_MAJOR_ONLY    4
#define  RPC_C_VERS_UPTO          5

RPC_STATUS RPC_ENTRY
RpcMgmtEpEltInqBegin (
    IN RPC_BINDING_HANDLE EpBinding OPTIONAL,
    IN unsigned long InquiryType,
    IN RPC_IF_ID __RPC_FAR * IfId OPTIONAL,
    IN unsigned long VersOption OPTIONAL,
    IN UUID __RPC_FAR * ObjectUuid OPTIONAL,
    OUT RPC_EP_INQ_HANDLE __RPC_FAR * InquiryContext
    );

RPC_STATUS RPC_ENTRY
RpcMgmtEpEltInqDone (
    IN OUT RPC_EP_INQ_HANDLE __RPC_FAR * InquiryContext
    );

#ifdef RPC_UNICODE_SUPPORTED

RPC_STATUS RPC_ENTRY
RpcMgmtEpEltInqNextA (
    IN RPC_EP_INQ_HANDLE InquiryContext,
    OUT RPC_IF_ID __RPC_FAR * IfId,
    OUT RPC_BINDING_HANDLE __RPC_FAR * Binding OPTIONAL,
    OUT UUID __RPC_FAR * ObjectUuid OPTIONAL,
    OUT unsigned char __RPC_FAR * __RPC_FAR * Annotation OPTIONAL
    );

RPC_STATUS RPC_ENTRY
RpcMgmtEpEltInqNextW (
    IN RPC_EP_INQ_HANDLE InquiryContext,
    OUT RPC_IF_ID __RPC_FAR * IfId,
    OUT RPC_BINDING_HANDLE __RPC_FAR * Binding OPTIONAL,
    OUT UUID __RPC_FAR * ObjectUuid OPTIONAL,
    OUT unsigned short __RPC_FAR * __RPC_FAR * Annotation OPTIONAL
    );

#ifdef UNICODE
#define RpcMgmtEpEltInqNext RpcMgmtEpEltInqNextW
#else /* UNICODE */
#define RpcMgmtEpEltInqNext RpcMgmtEpEltInqNextA
#endif /* UNICODE */

#else /* RPC_UNICODE_SUPPORTED */

RPC_STATUS RPC_ENTRY
RpcMgmtEpEltInqNext (
    IN RPC_EP_INQ_HANDLE InquiryContext,
    OUT RPC_IF_ID __RPC_FAR * IfId,
    OUT RPC_BINDING_HANDLE __RPC_FAR * Binding OPTIONAL,
    OUT unsigned char __RPC_FAR * __RPC_FAR * Annotation OPTIONAL
    );

#endif /* RPC_UNICODE_SUPPORTED */

RPC_STATUS RPC_ENTRY
RpcMgmtEpUnregister (
    IN RPC_BINDING_HANDLE EpBinding OPTIONAL,
    IN RPC_IF_ID __RPC_FAR * IfId,
    IN RPC_BINDING_HANDLE Binding,
    IN UUID __RPC_FAR * ObjectUuid OPTIONAL
    );

typedef int
(__RPC_API * RPC_MGMT_AUTHORIZATION_FN) (
    IN RPC_BINDING_HANDLE ClientBinding,
    IN unsigned long RequestedMgmtOperation,
    OUT RPC_STATUS __RPC_FAR * Status
    );

#define RPC_C_MGMT_INQ_IF_IDS         0
#define RPC_C_MGMT_INQ_PRINC_NAME     1
#define RPC_C_MGMT_INQ_STATS          2
#define RPC_C_MGMT_IS_SERVER_LISTEN   3
#define RPC_C_MGMT_STOP_SERVER_LISTEN 4

RPC_STATUS RPC_ENTRY
RpcMgmtSetAuthorizationFn (
    IN RPC_MGMT_AUTHORIZATION_FN AuthorizationFn
    );

#include "rpcdcep.h"

#ifdef __cplusplus
}
#endif

#endif /* __RPCDCE_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\tools\c932\inc\rpcdcep.h ===
/*++

Copyright (c) 1991-1995 Microsoft Corporation

Module Name:

    rpcdcep.h

Abstract:

    This module contains the private RPC runtime APIs for use by the
    stubs and by support libraries.  Applications must not call these
    routines.

--*/

#ifndef __RPCDCEP_H__
#define __RPCDCEP_H__

// Set the packing level for RPC structures for Dos and Windows.

#if defined(__RPC_DOS__) || defined(__RPC_WIN16__)
#pragma pack(2)
#endif

#ifdef __cplusplus
extern "C" {
#endif

typedef struct _RPC_VERSION {
    unsigned short MajorVersion;
    unsigned short MinorVersion;
} RPC_VERSION;

typedef struct _RPC_SYNTAX_IDENTIFIER {
    GUID SyntaxGUID;
    RPC_VERSION SyntaxVersion;
} RPC_SYNTAX_IDENTIFIER, __RPC_FAR * PRPC_SYNTAX_IDENTIFIER;

typedef struct _RPC_MESSAGE
{
    RPC_BINDING_HANDLE Handle;
    unsigned long DataRepresentation;
    void __RPC_FAR * Buffer;
    unsigned int BufferLength;
    unsigned int ProcNum;
    PRPC_SYNTAX_IDENTIFIER TransferSyntax;
    void __RPC_FAR * RpcInterfaceInformation;
    void __RPC_FAR * ReservedForRuntime;
    RPC_MGR_EPV __RPC_FAR * ManagerEpv;
    void __RPC_FAR * ImportContext;
    unsigned long RpcFlags;
} RPC_MESSAGE, __RPC_FAR * PRPC_MESSAGE;


typedef RPC_STATUS RPC_FORWARD_FUNCTION(
                       IN UUID             __RPC_FAR * InterfaceId,
                       IN RPC_VERSION      __RPC_FAR * InterfaceVersion,
                       IN UUID             __RPC_FAR * ObjectId,
                       IN unsigned char         __RPC_FAR * Rpcpro,
                       IN void __RPC_FAR * __RPC_FAR * ppDestEndpoint);

/*
 * Types of function calls for datagram and COM rpc
 */

#define RPC_NCA_FLAGS_DEFAULT       0x00000000  /* 0b000...000 */
#define RPC_NCA_FLAGS_IDEMPOTENT    0x00000001  /* 0b000...001 */
#define RPC_NCA_FLAGS_BROADCAST     0x00000002  /* 0b000...010 */
#define RPC_NCA_FLAGS_MAYBE         0x00000004  /* 0b000...100 */
#define RPCFLG_ASYNCHRONOUS         0x40000000UL
#define RPCFLG_INPUT_SYNCHRONOUS    0x20000000UL

#if defined(__RPC_DOS__) || defined(__RPC_WIN16__)
#define RPC_FLAGS_VALID_BIT 0x8000
#endif

#if defined(__RPC_WIN32__) || defined(__RPC_MAC__)
#define RPC_FLAGS_VALID_BIT 0x00008000
#endif

typedef
void
(__RPC_STUB __RPC_FAR * RPC_DISPATCH_FUNCTION) (
    IN OUT PRPC_MESSAGE Message
    );

typedef struct {
    unsigned int DispatchTableCount;
    RPC_DISPATCH_FUNCTION __RPC_FAR * DispatchTable;
    int Reserved;
} RPC_DISPATCH_TABLE, __RPC_FAR * PRPC_DISPATCH_TABLE;

typedef struct _RPC_PROTSEQ_ENDPOINT
{
    unsigned char __RPC_FAR * RpcProtocolSequence;
    unsigned char __RPC_FAR * Endpoint;
} RPC_PROTSEQ_ENDPOINT, __RPC_FAR * PRPC_PROTSEQ_ENDPOINT;

/*
Both of these types MUST start with the InterfaceId and TransferSyntax.
Look at RpcIfInqId and I_RpcIfInqTransferSyntaxes to see why.
*/

typedef struct _RPC_SERVER_INTERFACE
{
    unsigned int Length;
    RPC_SYNTAX_IDENTIFIER InterfaceId;
    RPC_SYNTAX_IDENTIFIER TransferSyntax;
    PRPC_DISPATCH_TABLE DispatchTable;
    unsigned int RpcProtseqEndpointCount;
    PRPC_PROTSEQ_ENDPOINT RpcProtseqEndpoint;
    RPC_MGR_EPV __RPC_FAR *DefaultManagerEpv;
    void const __RPC_FAR *InterpreterInfo;
} RPC_SERVER_INTERFACE, __RPC_FAR * PRPC_SERVER_INTERFACE;

typedef struct _RPC_CLIENT_INTERFACE
{
    unsigned int Length;
    RPC_SYNTAX_IDENTIFIER InterfaceId;
    RPC_SYNTAX_IDENTIFIER TransferSyntax;
    PRPC_DISPATCH_TABLE DispatchTable;
    unsigned int RpcProtseqEndpointCount;
    PRPC_PROTSEQ_ENDPOINT RpcProtseqEndpoint;
    unsigned long Reserved;
    void const __RPC_FAR * InterpreterInfo;
} RPC_CLIENT_INTERFACE, __RPC_FAR * PRPC_CLIENT_INTERFACE;

RPC_STATUS RPC_ENTRY
I_RpcGetBuffer (
    IN OUT RPC_MESSAGE __RPC_FAR * Message
    );

RPC_STATUS RPC_ENTRY
I_RpcSendReceive (
    IN OUT RPC_MESSAGE __RPC_FAR * Message
    );

RPC_STATUS RPC_ENTRY
I_RpcFreeBuffer (
    IN OUT RPC_MESSAGE __RPC_FAR * Message
    );

typedef void * I_RPC_MUTEX;

void RPC_ENTRY
I_RpcRequestMutex (
    IN OUT I_RPC_MUTEX * Mutex
    );

void RPC_ENTRY
I_RpcClearMutex (
    IN I_RPC_MUTEX Mutex
    );

void RPC_ENTRY
I_RpcDeleteMutex (
    IN I_RPC_MUTEX Mutex
    );

void __RPC_FAR * RPC_ENTRY
I_RpcAllocate (
    IN unsigned int Size
    );

void RPC_ENTRY
I_RpcFree (
    IN void __RPC_FAR * Object
    );

void RPC_ENTRY
I_RpcPauseExecution (
    IN unsigned long Milliseconds
    );

typedef
void
(__RPC_USER __RPC_FAR * PRPC_RUNDOWN) (
    void __RPC_FAR * AssociationContext
    );

RPC_STATUS RPC_ENTRY
I_RpcMonitorAssociation (
    IN RPC_BINDING_HANDLE Handle,
    IN PRPC_RUNDOWN RundownRoutine,
    IN void * Context
    );

RPC_STATUS RPC_ENTRY
I_RpcStopMonitorAssociation (
    IN RPC_BINDING_HANDLE Handle
    );

RPC_BINDING_HANDLE RPC_ENTRY
I_RpcGetCurrentCallHandle(
    void
    );

RPC_STATUS RPC_ENTRY
I_RpcGetAssociationContext (
    OUT void __RPC_FAR * __RPC_FAR * AssociationContext
    );

RPC_STATUS RPC_ENTRY
I_RpcSetAssociationContext (
    IN void __RPC_FAR * AssociationContext
    );

#ifdef __RPC_NT__

RPC_STATUS RPC_ENTRY
I_RpcNsBindingSetEntryName (
    IN RPC_BINDING_HANDLE Binding,
    IN unsigned long EntryNameSyntax,
    IN unsigned short __RPC_FAR * EntryName
    );

#else 

RPC_STATUS RPC_ENTRY
I_RpcNsBindingSetEntryName (
    IN RPC_BINDING_HANDLE Binding,
    IN unsigned long EntryNameSyntax,
    IN unsigned char __RPC_FAR * EntryName
    );

#endif 

#ifdef __RPC_NT__

RPC_STATUS RPC_ENTRY
I_RpcBindingInqDynamicEndpoint (
    IN RPC_BINDING_HANDLE Binding,
    OUT unsigned short __RPC_FAR * __RPC_FAR * DynamicEndpoint
    );

#else 

RPC_STATUS RPC_ENTRY
I_RpcBindingInqDynamicEndpoint (
    IN RPC_BINDING_HANDLE Binding,
    OUT unsigned char __RPC_FAR * __RPC_FAR * DynamicEndpoint
    );

#endif 

#define TRANSPORT_TYPE_CN   0x1
#define TRANSPORT_TYPE_DG   0x2
#define TRANSPORT_TYPE_LPC  0x4
#define TRANSPORT_TYPE_WMSG 0x8

RPC_STATUS RPC_ENTRY
I_RpcBindingInqTransportType (
    IN RPC_BINDING_HANDLE Binding,
    OUT unsigned int __RPC_FAR * Type
    );

typedef struct _RPC_TRANSFER_SYNTAX
{
    UUID Uuid;
    unsigned short VersMajor;
    unsigned short VersMinor;
} RPC_TRANSFER_SYNTAX;

RPC_STATUS RPC_ENTRY
I_RpcIfInqTransferSyntaxes (
    IN RPC_IF_HANDLE RpcIfHandle,
    OUT RPC_TRANSFER_SYNTAX __RPC_FAR * TransferSyntaxes,
    IN unsigned int TransferSyntaxSize,
    OUT unsigned int __RPC_FAR * TransferSyntaxCount
    );

RPC_STATUS RPC_ENTRY
I_UuidCreate (
    OUT UUID __RPC_FAR * Uuid
    );

RPC_STATUS RPC_ENTRY
I_RpcBindingCopy (
    IN RPC_BINDING_HANDLE SourceBinding,
    OUT RPC_BINDING_HANDLE __RPC_FAR * DestinationBinding
    );

RPC_STATUS RPC_ENTRY
I_RpcBindingIsClientLocal (
    IN RPC_BINDING_HANDLE BindingHandle OPTIONAL,
    OUT unsigned int __RPC_FAR * ClientLocalFlag
    );

void RPC_ENTRY
I_RpcSsDontSerializeContext (
    void
    );


RPC_STATUS RPC_ENTRY
I_RpcServerRegisterForwardFunction (
    IN RPC_FORWARD_FUNCTION __RPC_FAR * pForwardFunction
                       );

#ifdef __RPC_WIN32__

typedef
RPC_STATUS
(__RPC_USER __RPC_FAR * RPC_BLOCKING_FUNCTION) (
    IN void __RPC_FAR *RpcWindowHandle,
    IN void __RPC_FAR *Context
    );

RPC_STATUS RPC_ENTRY
I_RpcBindingSetAsync(
    IN RPC_BINDING_HANDLE Binding,
    IN RPC_BLOCKING_FUNCTION BlockingHook
    );

RPC_STATUS RPC_ENTRY
I_RpcAsyncSendReceive(
    IN OUT RPC_MESSAGE __RPC_FAR * Message,
    IN void __RPC_FAR * Context
    );

RPC_STATUS RPC_ENTRY
I_RpcGetThreadWindowHandle(
    OUT void __RPC_FAR * __RPC_FAR * WindowHandle
    );

RPC_STATUS RPC_ENTRY
I_RpcServerThreadPauseListening(
    );

RPC_STATUS RPC_ENTRY
I_RpcServerThreadContinueListening(
    );

RPC_STATUS RPC_ENTRY
I_RpcServerUnregisterEndpointA (
    IN unsigned char * Protseq,
    IN unsigned char * Endpoint
    );

RPC_STATUS RPC_ENTRY
I_RpcServerUnregisterEndpointW (
    IN unsigned short * Protseq,
    IN unsigned short * Endpoint
    );

#ifdef UNICODE
#define I_RpcServerUnregisterEndpoint I_RpcServerUnregisterEndpointW
#else
#define I_RpcServerUnregisterEndpoint I_RpcServerUnregisterEndpointA
#endif

#endif // __RPC_WIN32__

#ifdef __cplusplus
}
#endif

// Reset the packing level for Dos and Windows.

#if defined(__RPC_DOS__) || defined(__RPC_WIN16__)
#pragma pack()
#endif

#endif /* __RPCDCEP_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\tools\c932\inc\rpcferr.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:      rpc.mc
//
//  Contents:  Errors for RPC facility.  Some historical from 16 bit,
//             some new ones.
//
//  History:   dd-mmm-yy Author    Comment
//             20-Sep-93 AlexMit   Created
//
//  Notes:
//  .mc file is compiled by the MC tool to generate a .h file and
//  .rc (resource compiler script) file.
//
// Comments in .mc files start with a ";".
// Comment lines are generated directly in the .h file, without
// the leading ";"
//
// See mc.hlp for more help on .mc files and the MC tool.
//
//
// Instructions for the transition to moleerror.mc:
//
//
// Use this sample file as template for constructing .mc files for
// your project.
//
// The project .mc files will be merged into a single .mc file for
// Cairo: oleerror.mc
//
// Reserve a range of error codes within a FACILITY defined in
// oleerror.mc.  Reserve this range within oleerror.mc, by locating the
// appropraite facility in oleerror.mc and placing a comment block
// within oleerror.mc of the form:
//
//
//--------------------------------------------------------------------------
#ifndef _RPCFERR_H_
#define _RPCFERR_H_
// **** START OF COPIED DATA ****
// The following information is copied from oleerror.mc.
// It should not be merged into oleerror.mc
// Define the status type.
// Define the severities
// Define the severities
// Define the facilities
//
// FACILITY_RPC is for compatibilty with OLE2 and is not used
// in later versions of OLE

// **** END OF COPIED DATA ****
//
// Error definitions follow
//
// ******************
// FACILITY_RPC
// ******************
//
// Codes 0x0-0x11 are propogated from 16 bit OLE.
//
//
//  Values are 32 bit values layed out as follows:
//
//   3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
//   1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
//  +-+-+-+-+-+---------------------+-------------------------------+
//  |S|R|C|N|r|    Facility         |               Code            |
//  +-+-+-+-+-+---------------------+-------------------------------+
//
//  where
//
//      S - Severity - indicates success/fail
//
//          0 - Success
//          1 - Fail (COERROR)
//
//      R - reserved portion of the facility code, corresponds to NT's
//              second severity bit.
//
//      C - reserved portion of the facility code, corresponds to NT's
//              C field.
//
//      N - reserved portion of the facility code. Used to indicate a
//              mapped NT status value.
//
//      r - reserved portion of the facility code. Reserved for internal
//              use. Used to indicate HRESULT values that are not status
//              values, but are instead message ids for display strings.
//
//      Facility - is the facility code
//
//      Code - is the facility's status code
//
//
// Define the facility codes
//
#define FACILITY_WINDOWS                 0x8
#define FACILITY_WIN32                   0x7
#define FACILITY_STORAGE                 0x3
#define FACILITY_RPC                     0x1
#define FACILITY_NULL                    0x0
#define FACILITY_ITF                     0x4
#define FACILITY_DISPATCH                0x2


//
// Define the severity codes
//
#define STATUS_SEVERITY_SUCCESS          0x0
#define STATUS_SEVERITY_COERROR          0x2


//
// MessageId: RPC_E_CALL_REJECTED
//
// MessageText:
//
//  Call was rejected by callee.
//
#define RPC_E_CALL_REJECTED              ((HRESULT)0x80010001L)

//
// MessageId: RPC_E_CALL_CANCELED
//
// MessageText:
//
//  Call was canceld by call - returned by MessagePending.
//  This code only occurs if MessagePending return cancel.
//
#define RPC_E_CALL_CANCELED              ((HRESULT)0x80010002L)

//
// MessageId: RPC_E_CANTPOST_INSENDCALL
//
// MessageText:
//
//  The caller is dispatching an intertask SendMessage call and
//  can NOT call out via PostMessage.
//
#define RPC_E_CANTPOST_INSENDCALL        ((HRESULT)0x80010003L)

//
// MessageId: RPC_E_CANTCALLOUT_INASYNCCALL
//
// MessageText:
//
//  The caller is dispatching an asynchronus call can NOT
//  make an outgoing call on behalf of this call.
//
#define RPC_E_CANTCALLOUT_INASYNCCALL    ((HRESULT)0x80010004L)

//
// MessageId: RPC_E_CANTCALLOUT_INEXTERNALCALL
//
// MessageText:
//
//  The caller is not in a state where an outgoing call can be made.
//  This is the case if the caller has an outstanding call and
//  another incoming call was excepted by HIC; now the caller is
//  not allowed to call out again.
//
#define RPC_E_CANTCALLOUT_INEXTERNALCALL ((HRESULT)0x80010005L)

//
// MessageId: RPC_E_CONNECTION_TERMINATED
//
// MessageText:
//
//  The connection terminated or is in a bogus state
//  and can not be used any more. Other connections
//  are still valid.
//
#define RPC_E_CONNECTION_TERMINATED      ((HRESULT)0x80010006L)

//
// MessageId: RPC_E_SERVER_DIED
//
// MessageText:
//
//  The callee (server [not server application]) is not available
//  and disappeared; all connections are invalid.  The call may
//  have executed.
//
#define RPC_E_SERVER_DIED                ((HRESULT)0x80010007L)

//
// MessageId: RPC_E_CLIENT_DIED
//
// MessageText:
//
//  The caller (client ) disappeared while the callee (server) was
//  processing a call.
//
#define RPC_E_CLIENT_DIED                ((HRESULT)0x80010008L)

//
// MessageId: RPC_E_INVALID_DATAPACKET
//
// MessageText:
//
//  The date packet with the marshalled parameter data is incorrect.
//
#define RPC_E_INVALID_DATAPACKET         ((HRESULT)0x80010009L)

//
// MessageId: RPC_E_CANTTRANSMIT_CALL
//
// MessageText:
//
//  The call was not transmitted properly; the message queue
//  was full and was not emptied after yielding.
//
#define RPC_E_CANTTRANSMIT_CALL          ((HRESULT)0x8001000AL)

//
// MessageId: RPC_E_CLIENT_CANTMARSHAL_DATA
//
// MessageText:
//
//  The client (caller) can not marshall the parameter data - low memory etc.
//
#define RPC_E_CLIENT_CANTMARSHAL_DATA    ((HRESULT)0x8001000BL)

//
// MessageId: RPC_E_CLIENT_CANTUNMARSHAL_DATA
//
// MessageText:
//
//  The client (caller) can not unmarshall the return data - low memory etc.
//
#define RPC_E_CLIENT_CANTUNMARSHAL_DATA  ((HRESULT)0x8001000CL)

//
// MessageId: RPC_E_SERVER_CANTMARSHAL_DATA
//
// MessageText:
//
//  The server (callee) can not marshall the return data - low memory etc.
//
#define RPC_E_SERVER_CANTMARSHAL_DATA    ((HRESULT)0x8001000DL)

//
// MessageId: RPC_E_SERVER_CANTUNMARSHAL_DATA
//
// MessageText:
//
//  The server (callee) can not unmarshall the parameter data - low memory etc.
//
#define RPC_E_SERVER_CANTUNMARSHAL_DATA  ((HRESULT)0x8001000EL)

//
// MessageId: RPC_E_INVALID_DATA
//
// MessageText:
//
//  Received data are invalid; can be server or client data.
//
#define RPC_E_INVALID_DATA               ((HRESULT)0x8001000FL)

//
// MessageId: RPC_E_INVALID_PARAMETER
//
// MessageText:
//
//  A particular parameter is invalid and can not be un/marshalled.
//
#define RPC_E_INVALID_PARAMETER          ((HRESULT)0x80010010L)

//
// MessageId: RPC_E_CANTCALLOUT_AGAIN
//
// MessageText:
//
//  There is no second outgoing call on same channel in DDE conversation.
//
#define RPC_E_CANTCALLOUT_AGAIN          ((HRESULT)0x80010011L)

//
// MessageId: RPC_E_SERVER_DIED_DNE
//
// MessageText:
//
//  The callee (server [not server application]) is not available
//  and disappeared; all connections are invalid.  The call did not execute.
//
#define RPC_E_SERVER_DIED_DNE            ((HRESULT)0x80010012L)

//
// MessageId: RPC_E_SYS_CALL_FAILED
//
// MessageText:
//
//  System call failed.
//
#define RPC_E_SYS_CALL_FAILED            ((HRESULT)0x80010100L)

//
// MessageId: RPC_E_OUT_OF_RESOURCES
//
// MessageText:
//
//  Could not allocate some required resource (memory, events, ...)
//
#define RPC_E_OUT_OF_RESOURCES           ((HRESULT)0x80010101L)

//
// MessageId: RPC_E_ATTEMPTED_MULTITHREAD
//
// MessageText:
//
//  Attempted to make calls on more then one thread in single threaded mode.
//
#define RPC_E_ATTEMPTED_MULTITHREAD      ((HRESULT)0x80010102L)

//
// MessageId: RPC_E_NOT_REGISTERED
//
// MessageText:
//
//  The requested interface is not registered on the server object.
//
#define RPC_E_NOT_REGISTERED             ((HRESULT)0x80010103L)

//
// MessageId: RPC_E_FAULT
//
// MessageText:
//
//  RPC could not call the server or could not return the results of calling the server.
//
#define RPC_E_FAULT                      ((HRESULT)0x80010104L)

//
// MessageId: RPC_E_SERVERFAULT
//
// MessageText:
//
//  The server threw an exception.
//
#define RPC_E_SERVERFAULT                ((HRESULT)0x80010105L)

//
// MessageId: RPC_E_CHANGED_MODE
//
// MessageText:
//
//  Cannot change thread mode after it is set.
//
#define RPC_E_CHANGED_MODE               ((HRESULT)0x80010106L)

//
// MessageId: RPC_E_INVALIDMETHOD
//
// MessageText:
//
//  The method called does not exist on the server.
//
#define RPC_E_INVALIDMETHOD              ((HRESULT)0x80010107L)

//
// MessageId: RPC_E_DISCONNECTED
//
// MessageText:
//
//  The object invoked has disconnected from its clients.
//
#define RPC_E_DISCONNECTED               ((HRESULT)0x80010108L)

//
// MessageId: RPC_E_RETRY
//
// MessageText:
//
//  The object invoked choose not to process the call now.  Try again later.
//
#define RPC_E_RETRY                      ((HRESULT)0x80010109L)

//
// MessageId: RPC_E_SERVERCALL_RETRYLATER
//
// MessageText:
//
//  The messagefilter indicated that the app is bussy.
//
#define RPC_E_SERVERCALL_RETRYLATER      ((HRESULT)0x8001010AL)

//
// MessageId: RPC_E_SERVERCALL_REJECTED
//
// MessageText:
//
//  The messagefilter rejected the call.
//
#define RPC_E_SERVERCALL_REJECTED        ((HRESULT)0x8001010BL)

//
// MessageId: RPC_E_INVALID_CALLDATA
//
// MessageText:
//
//  The call control interfaces was called with invalid data.
//
#define RPC_E_INVALID_CALLDATA           ((HRESULT)0x8001010CL)

//
// MessageId: RPC_E_CANTCALLOUT_ININPUTSYNCCALL
//
// MessageText:
//
//  An outgoing call can not be made since the app is dispatching an input-sync call.
//
#define RPC_E_CANTCALLOUT_ININPUTSYNCCALL ((HRESULT)0x8001010DL)

//
// MessageId: RPC_E_WRONG_THREAD
//
// MessageText:
//
//  The app called an interface that was marshalled for a different thread.
//
#define RPC_E_WRONG_THREAD               ((HRESULT)0x8001010EL)

//
// MessageId: RPC_E_THREAD_NOT_INIT
//
// MessageText:
//
//  The CoInitialize has not been called on the current thread.
//
#define RPC_E_THREAD_NOT_INIT            ((HRESULT)0x8001010FL)

//
// MessageId: RPC_E_UNEXPECTED
//
// MessageText:
//
//  An internal error occured.
//
#define RPC_E_UNEXPECTED                 ((HRESULT)0x8001FFFFL)

#endif // _RPCFERR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\tools\c932\inc\rpcndr.h ===
/*++

Copyright (c) 1992 Microsoft Corporation

Module Name:

    rpcndr.h

Abstract:

    Definitions for stub data structures and prototypes of helper functions.

Author:

    DonnaLi (01-01-91)

Environment:

    DOS, Win 3.X, and Win/NT.

Revision History:

   DONNALI  08-29-91     Start recording history
   donnali  09-11-91     change conversion macros
   donnali  09-18-91     check in files for moving
   STEVEZ   10-15-91     Merge with NT tree
   donnali  10-28-91     add prototype
   donnali  11-19-91     bugfix for strings
   MIKEMON  12-17-91     DCE runtime API conversion
   donnali  03-24-92     change rpc public header f
   STEVEZ   04-04-92     add nsi include
   mikemon  04-18-92     security support and misc
   DovhH    04-24-24     Changed signature of <int>_from_ndr
                         (to unsigned <int>)
                         Added <base_type>_array_from_ndr routines
   RyszardK 06-17-93     Added support for hyper
   VibhasC  09-11-93     Created rpcndrn.h
   DKays    10-14-93     Fixed up rpcndrn.h MIDL 2.0
   RyszardK 01-15-94     Merged in the midl 2.0 changes from rpcndrn.h

--*/

#ifndef __RPCNDR_H__
#define __RPCNDR_H__

//
// Set the packing level for RPC structures for Dos, Windows and Mac.
//

#if defined(__RPC_DOS__) || defined(__RPC_WIN16__) || defined(__RPC_MAC__)
#pragma pack(2)
#endif

#if defined(__RPC_MAC__)
#define _MAC_
#endif

#include "rpcnsip.h"

#ifdef __cplusplus
extern "C" {
#endif

/****************************************************************************

     Network Computing Architecture (NCA) definition:

     Network Data Representation: (NDR) Label format:
     An unsigned long (32 bits) with the following layout:

     3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
     1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
    +---------------+---------------+---------------+-------+-------+
    |   Reserved    |   Reserved    |Floating point | Int   | Char  |
    |               |               |Representation | Rep.  | Rep.  |
    +---------------+---------------+---------------+-------+-------+

     Where

         Reserved:

             Must be zero (0) for NCA 1.5 and NCA 2.0.

         Floating point Representation is:

             0 - IEEE
             1 - VAX
             2 - Cray
             3 - IBM

         Int Rep. is Integer Representation:

             0 - Big Endian
             1 - Little Endian

         Char Rep. is Character Representation:

             0 - ASCII
             1 - EBCDIC

     The Microsoft Local Data Representation (for all platforms which are
     of interest currently is edefined below:

 ****************************************************************************/

#define NDR_CHAR_REP_MASK               (unsigned long)0X0000000FL
#define NDR_INT_REP_MASK                (unsigned long)0X000000F0L
#define NDR_FLOAT_REP_MASK              (unsigned long)0X0000FF00L

#define NDR_LITTLE_ENDIAN               (unsigned long)0X00000010L
#define NDR_BIG_ENDIAN                  (unsigned long)0X00000000L

#define NDR_IEEE_FLOAT                  (unsigned long)0X00000000L
#define NDR_VAX_FLOAT                   (unsigned long)0X00000100L

#define NDR_ASCII_CHAR                  (unsigned long)0X00000000L
#define NDR_EBCDIC_CHAR                 (unsigned long)0X00000001L

#if defined(__RPC_MAC__)
#define NDR_LOCAL_DATA_REPRESENTATION   (unsigned long)0X00000000L
#define NDR_LOCAL_ENDIAN                NDR_BIG_ENDIAN
#else
#define NDR_LOCAL_DATA_REPRESENTATION   (unsigned long)0X00000010L
#define NDR_LOCAL_ENDIAN                NDR_LITTLE_ENDIAN
#endif

/****************************************************************************
 *  Other MIDL base types / predefined types:
 ****************************************************************************/

#define small char
typedef unsigned char byte;
typedef unsigned char boolean;

#ifndef _HYPER_DEFINED
#define _HYPER_DEFINED

#if !defined(__RPC_DOS__) && !defined(__RPC_WIN16__) && !defined(__RPC_MAC__) && (!defined(_M_IX86) || (defined(_INTEGRAL_MAX_BITS) && _INTEGRAL_MAX_BITS >= 64))
#define  hyper           __int64
#define MIDL_uhyper  unsigned __int64
#else
typedef double  hyper;
typedef double MIDL_uhyper;
#endif

#endif // _HYPER_DEFINED

#ifndef _WCHAR_T_DEFINED
typedef unsigned short wchar_t;
#define _WCHAR_T_DEFINED
#endif

#ifndef _SIZE_T_DEFINED
typedef unsigned int size_t;
#define _SIZE_T_DEFINED
#endif

#ifdef __RPC_DOS__
#define __RPC_CALLEE       __far __pascal
#endif

#ifdef __RPC_WIN16__
#define __RPC_CALLEE       __far __pascal __export
#endif

#ifdef __RPC_WIN32__
#if   (_MSC_VER >= 800)
#define __RPC_CALLEE       __stdcall
#else
#define __RPC_CALLEE
#endif
#endif

#ifdef __RPC_MAC__
#define __RPC_CALLEE __far
#endif

#ifndef __MIDL_USER_DEFINED
#define midl_user_allocate MIDL_user_allocate
#define midl_user_free     MIDL_user_free
#define __MIDL_USER_DEFINED
#endif

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void             __RPC_USER MIDL_user_free( void __RPC_FAR * ); 

#ifdef __RPC_WIN16__
#define RPC_VAR_ENTRY __export __cdecl
#else
#define RPC_VAR_ENTRY __cdecl
#endif


/* winnt only */
#if defined(_M_MRX000) || defined(_M_IX86) || defined(_M_ALPHA)
#define __MIDL_DECLSPEC_DLLIMPORT   __declspec(dllimport)
#define __MIDL_DECLSPEC_DLLEXPORT   __declspec(dllexport)
#else
#define __MIDL_DECLSPEC_DLLIMPORT
#define __MIDL_DECLSPEC_DLLEXPORT
#endif

/****************************************************************************
 * Context handle management related definitions:
 *
 * Client and Server Contexts. 
 *
 ****************************************************************************/

typedef void __RPC_FAR * NDR_CCONTEXT;

typedef struct
    {
    void __RPC_FAR * pad[2];
    void __RPC_FAR * userContext;
    } __RPC_FAR * NDR_SCONTEXT;

#define NDRSContextValue(hContext) (&(hContext)->userContext)

#define cbNDRContext 20         /* size of context on WIRE */

typedef void (__RPC_USER __RPC_FAR * NDR_RUNDOWN)(void __RPC_FAR * context);

typedef struct _SCONTEXT_QUEUE {
    unsigned long   NumberOfObjects;
    NDR_SCONTEXT  * ArrayOfObjects;
    } SCONTEXT_QUEUE, __RPC_FAR * PSCONTEXT_QUEUE;

RPC_BINDING_HANDLE RPC_ENTRY
NDRCContextBinding (
    IN NDR_CCONTEXT CContext
    );

void RPC_ENTRY
NDRCContextMarshall (
        IN  NDR_CCONTEXT CContext,
        OUT void __RPC_FAR *pBuff
        );

void RPC_ENTRY
NDRCContextUnmarshall (
        OUT NDR_CCONTEXT __RPC_FAR *pCContext,
        IN  RPC_BINDING_HANDLE hBinding,
        IN  void __RPC_FAR *pBuff,
        IN  unsigned long DataRepresentation
        );

void RPC_ENTRY
NDRSContextMarshall (
        IN  NDR_SCONTEXT CContext,
        OUT void __RPC_FAR *pBuff,
        IN  NDR_RUNDOWN userRunDownIn
        );

NDR_SCONTEXT RPC_ENTRY
NDRSContextUnmarshall (
    IN  void __RPC_FAR *pBuff,
    IN  unsigned long DataRepresentation
    );

void RPC_ENTRY
RpcSsDestroyClientContext (
    IN void __RPC_FAR * __RPC_FAR * ContextHandle
    );


/****************************************************************************
    NDR conversion related definitions.
 ****************************************************************************/

#define byte_from_ndr(source, target) \
    { \
    *(target) = *(*(char __RPC_FAR * __RPC_FAR *)&(source)->Buffer)++; \
    }

#define byte_array_from_ndr(Source, LowerIndex, UpperIndex, Target) \
    { \
    NDRcopy ( \
        (((char __RPC_FAR *)(Target))+(LowerIndex)), \
        (Source)->Buffer, \
        (unsigned int)((UpperIndex)-(LowerIndex))); \
    *(unsigned long __RPC_FAR *)&(Source)->Buffer += ((UpperIndex)-(LowerIndex)); \
    }

#define boolean_from_ndr(source, target) \
    { \
    *(target) = *(*(char __RPC_FAR * __RPC_FAR *)&(source)->Buffer)++; \
    }

#define boolean_array_from_ndr(Source, LowerIndex, UpperIndex, Target) \
    { \
    NDRcopy ( \
        (((char __RPC_FAR *)(Target))+(LowerIndex)), \
        (Source)->Buffer, \
        (unsigned int)((UpperIndex)-(LowerIndex))); \
    *(unsigned long __RPC_FAR *)&(Source)->Buffer += ((UpperIndex)-(LowerIndex)); \
    }

#define small_from_ndr(source, target) \
    { \
    *(target) = *(*(char __RPC_FAR * __RPC_FAR *)&(source)->Buffer)++; \
    }

#define small_from_ndr_temp(source, target, format) \
    { \
    *(target) = *(*(char __RPC_FAR * __RPC_FAR *)(source))++; \
    }

#define small_array_from_ndr(Source, LowerIndex, UpperIndex, Target) \
    { \
    NDRcopy ( \
        (((char __RPC_FAR *)(Target))+(LowerIndex)), \
        (Source)->Buffer, \
        (unsigned int)((UpperIndex)-(LowerIndex))); \
    *(unsigned long __RPC_FAR *)&(Source)->Buffer += ((UpperIndex)-(LowerIndex)); \
    }

/****************************************************************************
    Platform specific mapping of c-runtime functions.
 ****************************************************************************/

#ifdef __RPC_DOS__
#define MIDL_ascii_strlen(string) \
    _fstrlen(string)
#define MIDL_ascii_strcpy(target,source) \
    _fstrcpy(target,source)
#define MIDL_memset(s,c,n) \
    _fmemset(s,c,n)
#endif

#ifdef __RPC_WIN16__
#define MIDL_ascii_strlen(string) \
    _fstrlen(string)
#define MIDL_ascii_strcpy(target,source) \
    _fstrcpy(target,source)
#define MIDL_memset(s,c,n) \
    _fmemset(s,c,n)
#endif

#if defined(__RPC_WIN32__) || defined(__RPC_MAC__)
#define MIDL_ascii_strlen(string) \
    strlen(string)
#define MIDL_ascii_strcpy(target,source) \
    strcpy(target,source)
#define MIDL_memset(s,c,n) \
    memset(s,c,n)
#endif

/****************************************************************************
    Ndr Library helper function prototypes for MIDL 1.0 ndr functions.
 ****************************************************************************/

void RPC_ENTRY
NDRcopy (
    IN void __RPC_FAR *pTarget,
    IN void __RPC_FAR *pSource,
    IN unsigned int size
    );

size_t RPC_ENTRY
MIDL_wchar_strlen (
    IN wchar_t __RPC_FAR *   s
    );

void RPC_ENTRY
MIDL_wchar_strcpy (
    OUT void __RPC_FAR *     t,
    IN wchar_t __RPC_FAR *   s
    );

void RPC_ENTRY
char_from_ndr (
    IN OUT PRPC_MESSAGE                           SourceMessage,
    OUT unsigned char __RPC_FAR *                 Target
    );

void RPC_ENTRY
char_array_from_ndr (
    IN OUT PRPC_MESSAGE                           SourceMessage,
    IN unsigned long                              LowerIndex,
    IN unsigned long                              UpperIndex,
    OUT unsigned char __RPC_FAR *                 Target
    );

void RPC_ENTRY
short_from_ndr (
    IN OUT PRPC_MESSAGE                           source,
    OUT unsigned short __RPC_FAR *                target
    );

void RPC_ENTRY
short_array_from_ndr(
    IN OUT PRPC_MESSAGE                           SourceMessage,
    IN unsigned long                              LowerIndex,
    IN unsigned long                              UpperIndex,
    OUT unsigned short __RPC_FAR *                Target
    );

void RPC_ENTRY
short_from_ndr_temp (
    IN OUT unsigned char __RPC_FAR * __RPC_FAR *  source,
    OUT unsigned short __RPC_FAR *                target,
    IN unsigned long                              format
    );

void RPC_ENTRY
long_from_ndr (
    IN OUT PRPC_MESSAGE                           source,
    OUT unsigned long __RPC_FAR *                 target
    );

void RPC_ENTRY
long_array_from_ndr(
    IN OUT PRPC_MESSAGE                           SourceMessage,
    IN unsigned long                              LowerIndex,
    IN unsigned long                              UpperIndex,
    OUT unsigned long __RPC_FAR *                 Target
    );

void RPC_ENTRY
long_from_ndr_temp (
    IN OUT unsigned char __RPC_FAR * __RPC_FAR *  source,
    OUT unsigned long __RPC_FAR *                 target,
    IN unsigned long                              format
    );

void RPC_ENTRY
enum_from_ndr(
    IN OUT PRPC_MESSAGE                           SourceMessage,
    OUT unsigned int __RPC_FAR *                  Target
    );

void RPC_ENTRY
float_from_ndr (
    IN OUT PRPC_MESSAGE                           SourceMessage,
    OUT void __RPC_FAR *                          Target
    );

void RPC_ENTRY
float_array_from_ndr (
    IN OUT PRPC_MESSAGE                           SourceMessage,
    IN unsigned long                              LowerIndex,
    IN unsigned long                              UpperIndex,
    OUT void __RPC_FAR *                          Target
    );

void RPC_ENTRY
double_from_ndr (
    IN OUT PRPC_MESSAGE                           SourceMessage,
    OUT void __RPC_FAR *                          Target
    );

void RPC_ENTRY
double_array_from_ndr (
    IN OUT PRPC_MESSAGE                           SourceMessage,
    IN unsigned long                              LowerIndex,
    IN unsigned long                              UpperIndex,
    OUT void __RPC_FAR *                          Target
    );

void RPC_ENTRY
hyper_from_ndr (
    IN OUT PRPC_MESSAGE                           source,
    OUT    hyper __RPC_FAR *                      target
    );

void RPC_ENTRY
hyper_array_from_ndr(
    IN OUT PRPC_MESSAGE                           SourceMessage,
    IN unsigned long                              LowerIndex,
    IN unsigned long                              UpperIndex,
    OUT          hyper __RPC_FAR *                Target
    );

void RPC_ENTRY
hyper_from_ndr_temp (
    IN OUT unsigned char __RPC_FAR * __RPC_FAR *  source,
    OUT             hyper __RPC_FAR *             target,
    IN   unsigned   long                          format
    );

void RPC_ENTRY
data_from_ndr (
    PRPC_MESSAGE                                  source,
    void __RPC_FAR *                              target,
    char __RPC_FAR *                              format,
    unsigned char                                 MscPak
    );

void RPC_ENTRY
data_into_ndr (
    void __RPC_FAR *                              source,
    PRPC_MESSAGE                                  target,
    char __RPC_FAR *                              format,
    unsigned char                                 MscPak
    );

void RPC_ENTRY
tree_into_ndr (
    void __RPC_FAR *                              source,
    PRPC_MESSAGE                                  target,
    char __RPC_FAR *                              format,
    unsigned char                                 MscPak
    );

void RPC_ENTRY
data_size_ndr (
    void __RPC_FAR *                              source,
    PRPC_MESSAGE                                  target,
    char __RPC_FAR *                              format,
    unsigned char                                 MscPak
    );

void RPC_ENTRY
tree_size_ndr (
    void __RPC_FAR *                              source,
    PRPC_MESSAGE                                  target,
    char __RPC_FAR *                              format,
    unsigned char                                 MscPak
    );

void RPC_ENTRY
tree_peek_ndr (
    PRPC_MESSAGE                                  source,
    unsigned char __RPC_FAR * __RPC_FAR *         buffer,
    char __RPC_FAR *                              format,
    unsigned char                                 MscPak
    );

void __RPC_FAR * RPC_ENTRY
midl_allocate (
    size_t      size
    );

/****************************************************************************
    MIDL 2.0 ndr definitions.
 ****************************************************************************/

typedef unsigned long error_status_t;

#define _midl_ma1( p, cast )    *(*( cast **)&p)++
#define _midl_ma2( p, cast )    *(*( cast **)&p)++
#define _midl_ma4( p, cast )    *(*( cast **)&p)++
#define _midl_ma8( p, cast )    *(*( cast **)&p)++

#define _midl_unma1( p, cast )  *(( cast *)p)++
#define _midl_unma2( p, cast )  *(( cast *)p)++
#define _midl_unma3( p, cast )  *(( cast *)p)++
#define _midl_unma4( p, cast )  *(( cast *)p)++

// Some alignment specific macros.


#define _midl_fa2( p )          (p = (RPC_BUFPTR )((unsigned long)(p+1) & 0xfffffffe))
#define _midl_fa4( p )          (p = (RPC_BUFPTR )((unsigned long)(p+3) & 0xfffffffc))
#define _midl_fa8( p )          (p = (RPC_BUFPTR )((unsigned long)(p+7) & 0xfffffff8))

#define _midl_addp( p, n )      (p += n)

// Marshalling macros

#define _midl_marsh_lhs( p, cast )  *(*( cast **)&p)++
#define _midl_marsh_up( mp, p )     *(*(unsigned long **)&mp)++ = (unsigned long)p
#define _midl_advmp( mp )           *(*(unsigned long **)&mp)++
#define _midl_unmarsh_up( p )       (*(*(unsigned long **)&p)++) 


////////////////////////////////////////////////////////////////////////////
// Ndr macros.
////////////////////////////////////////////////////////////////////////////

#define NdrMarshConfStringHdr( p, s, l )    (_midl_ma4( p, unsigned long) = s, \
                                            _midl_ma4( p, unsigned long) = 0, \
                                            _midl_ma4( p, unsigned long) = l)

#define NdrUnMarshConfStringHdr(p, s, l)    ((s=_midl_unma4(p,unsigned long),\
                                            (_midl_addp(p,4)),               \
                                            (l=_midl_unma4(p,unsigned long))
        
#define NdrMarshCCtxtHdl(pc,p)  (NDRCContextMarshall( (NDR_CCONTEXT)pc, p ),p+20)

#define NdrUnMarshCCtxtHdl(pc,p,h,drep) \
        (NDRCContextUnmarshall((NDR_CONTEXT)pc,h,p,drep), p+20)

#define NdrUnMarshSCtxtHdl(pc, p,drep)  (pc = NdrSContextUnMarshall(p,drep ))
    

#define NdrMarshSCtxtHdl(pc,p,rd)   (NdrSContextMarshall((NDR_SCONTEXT)pc,p, (NDR_RUNDOWN)rd)

#define NdrFieldOffset(s,f)     (long)(& (((s __RPC_FAR *)0)->f))
#define NdrFieldPad(s,f,p,t)    (NdrFieldOffset(s,f) - NdrFieldOffset(s,p) - sizeof(t))

#if defined(__RPC_MAC__)
#define NdrFcShort(s)   (unsigned char)(s >> 8), (unsigned char)(s & 0xff)
#define NdrFcLong(s)    (unsigned char)(s >> 24), (unsigned char)((s & 0x00ff0000) >> 16), \
                        (unsigned char)((s & 0x0000ff00) >> 8), (unsigned char)(s & 0xff)
#else
#define NdrFcShort(s)   (unsigned char)(s & 0xff), (unsigned char)(s >> 8)
#define NdrFcLong(s)    (unsigned char)(s & 0xff), (unsigned char)((s & 0x0000ff00) >> 8), \
                        (unsigned char)((s & 0x00ff0000) >> 16), (unsigned char)(s >> 24)
#endif //  Mac

/////////////////////////////////////////////////////////////////////////////
// Some stub helper functions.
/////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////
// Stub helper structures.
////////////////////////////////////////////////////////////////////////////

struct _MIDL_STUB_MESSAGE;
struct _MIDL_STUB_DESC;
struct _FULL_PTR_XLAT_TABLES;

typedef unsigned char __RPC_FAR * RPC_BUFPTR;
typedef unsigned long             RPC_LENGTH;

// Expression evaluation callback routine prototype.
typedef void (__RPC_USER __RPC_FAR * EXPR_EVAL)( struct _MIDL_STUB_MESSAGE __RPC_FAR * );

typedef const unsigned char __RPC_FAR * PFORMAT_STRING;

/*
 * Multidimensional conformant/varying array struct.
 */
typedef struct 
    {
    long                            Dimension;

    /* These fields MUST be (unsigned long *) */
    unsigned long __RPC_FAR *       BufferConformanceMark;
    unsigned long __RPC_FAR *       BufferVarianceMark;

    /* Count arrays, used for top level arrays in -Os stubs */
    unsigned long __RPC_FAR *       MaxCountArray;
    unsigned long __RPC_FAR *       OffsetArray;
    unsigned long __RPC_FAR *       ActualCountArray;
    } ARRAY_INFO, __RPC_FAR *PARRAY_INFO;

/*
 * MIDL Stub Message
 */
#if !defined(__RPC_DOS__) && !defined(__RPC_WIN16__) && !defined(__RPC_MAC__)
#include "pshpack4.h"
#endif 

typedef struct _MIDL_STUB_MESSAGE
    {
    /* RPC message structure. */
    PRPC_MESSAGE                RpcMsg;

    /* Pointer into RPC message buffer. */
    unsigned char __RPC_FAR *   Buffer;

    /*
     * These are used internally by the Ndr routines to mark the beginning
     * and end of an incoming RPC buffer.
     */
    unsigned char __RPC_FAR *   BufferStart;
    unsigned char __RPC_FAR *   BufferEnd;

    /*
     * Used internally by the Ndr routines as a place holder in the buffer.
     * On the marshalling side it's used to mark the location where conformance
     * size should be marshalled.
     * On the unmarshalling side it's used to mark the location in the buffer
     * used during pointer unmarshalling to base pointer offsets off of.
     */
    unsigned char __RPC_FAR *   BufferMark;

    /* Set by the buffer sizing routines. */
    unsigned long               BufferLength;

    /* Set by the memory sizing routines. */
    unsigned long               MemorySize;

    /* Pointer to user memory. */
    unsigned char __RPC_FAR *   Memory;

    /* Is the Ndr routine begin called from a client side stub. */
    int                         IsClient;

    /* Can the buffer be re-used for memory on unmarshalling. */
    int                         ReuseBuffer;    

    /* Holds the current pointer to an allocate all nodes memory block. */
    unsigned char __RPC_FAR *   AllocAllNodesMemory;

    /* Used for debugging asserts only, remove later. */
    unsigned char __RPC_FAR *   AllocAllNodesMemoryEnd;

    /* 
     * Stuff needed while handling complex structures 
     */

    /* Ignore imbeded pointers while computing buffer or memory sizes. */
    int                         IgnoreEmbeddedPointers;

    /* 
     * This marks the location in the buffer where pointees of a complex
     * struct reside.
     */
    unsigned char __RPC_FAR *   PointerBufferMark;

    /*
     * Used to catch errors in SendReceive.
     */
    unsigned char               fBufferValid;

    /*
     * Obsolete unused field (formerly MaxContextHandleNumber).
     */
    unsigned char               Unused;

    /* 
     * Used internally by the Ndr routines.  Holds the max counts for 
     * a conformant array.
     */
    unsigned long               MaxCount;

    /* 
     * Used internally by the Ndr routines.  Holds the offsets for a varying
     * array.
     */
    unsigned long               Offset;

    /* 
     * Used internally by the Ndr routines.  Holds the actual counts for 
     * a varying array.
     */
    unsigned long               ActualCount;

    /* Allocation and Free routine to be used by the Ndr routines. */
    void __RPC_FAR *    (__RPC_FAR __RPC_API * pfnAllocate)(size_t);
    void                (__RPC_FAR __RPC_API * pfnFree)(void __RPC_FAR *);

    /*
     * Top of parameter stack.  Used for "single call" stubs during marshalling 
     * to hold the beginning of the parameter list on the stack.  Needed to 
     * extract parameters which hold attribute values for top level arrays and 
     * pointers. 
     */
    unsigned char __RPC_FAR *       StackTop;

    /*
     *  Fields used for the transmit_as and represent_as objects.
     *  For represent_as the mapping is: presented=local, transmit=named.
     */
    unsigned char __RPC_FAR *       pPresentedType;
    unsigned char __RPC_FAR *       pTransmitType;

    /* 
     * When we first construct a binding on the client side, stick it
     * in the rpcmessage and later call RpcGetBuffer, the handle field
     * in the rpcmessage is changed. That's fine except that we need to
     * have that original handle for use in unmarshalling context handles
     * (the second argument in NDRCContextUnmarshall to be exact). So
     * stash the contructed handle here and extract it when needed.
     */
    handle_t                        SavedHandle;

    /*
     * Pointer back to the stub descriptor.  Use this to get all handle info.
     */
    const struct _MIDL_STUB_DESC __RPC_FAR *    StubDesc;

    /*
     * Full pointer stuff.
     */
    struct _FULL_PTR_XLAT_TABLES __RPC_FAR *    FullPtrXlatTables;

    unsigned long                   FullPtrRefId;

    /*
     * flags
     */

    int                             fCheckBounds;

    int                             fInDontFree       :1;
    int                             fDontCallFreeInst :1;
    int                             fInOnlyParam      :1;
    int                             fHasReturn        :1;

    unsigned long                   dwDestContext;
    void __RPC_FAR *                pvDestContext;

    NDR_SCONTEXT *                  SavedContextHandles;

    long                            ParamNumber;

    struct IRpcChannelBuffer __RPC_FAR *    pRpcChannelBuffer;

    PARRAY_INFO                     pArrayInfo;

    /* 
     * This is where the Beta2 stub message ends.
     */

    unsigned long __RPC_FAR *       SizePtrCountArray;
    unsigned long __RPC_FAR *       SizePtrOffsetArray;
    unsigned long __RPC_FAR *       SizePtrLengthArray;

    /*
     * Interpreter argument queue.  Used on server side only.
     */
    void __RPC_FAR *                pArgQueue;

    unsigned long                   dwStubPhase;

    /*
     * Reserved for future use.
     */
    
    unsigned long                   Reserved[5];

    } MIDL_STUB_MESSAGE, __RPC_FAR *PMIDL_STUB_MESSAGE;

#if !defined(__RPC_DOS__) && !defined(__RPC_WIN16__) && !defined(__RPC_MAC__)
#include "poppack.h"
#endif 

/*
 * Generic handle bind/unbind routine pair.
 */
typedef void __RPC_FAR * 
        (__RPC_FAR __RPC_API * GENERIC_BINDING_ROUTINE)
        (void __RPC_FAR *);
typedef void             
        (__RPC_FAR __RPC_API * GENERIC_UNBIND_ROUTINE)
        (void __RPC_FAR *, unsigned char __RPC_FAR *);

typedef struct _GENERIC_BINDING_ROUTINE_PAIR
    {
    GENERIC_BINDING_ROUTINE     pfnBind;
    GENERIC_UNBIND_ROUTINE      pfnUnbind;
    } GENERIC_BINDING_ROUTINE_PAIR, __RPC_FAR *PGENERIC_BINDING_ROUTINE_PAIR;

typedef struct __GENERIC_BINDING_INFO 
    {
    void __RPC_FAR *            pObj;
    unsigned int                Size;
    GENERIC_BINDING_ROUTINE     pfnBind;
    GENERIC_UNBIND_ROUTINE      pfnUnbind;
    } GENERIC_BINDING_INFO, __RPC_FAR *PGENERIC_BINDING_INFO;

// typedef EXPR_EVAL - see above

typedef void (__RPC_FAR __RPC_USER * XMIT_HELPER_ROUTINE)( PMIDL_STUB_MESSAGE );

typedef struct _XMIT_ROUTINE_QUINTUPLE
    {
    XMIT_HELPER_ROUTINE     pfnTranslateToXmit;
    XMIT_HELPER_ROUTINE     pfnTranslateFromXmit;
    XMIT_HELPER_ROUTINE     pfnFreeXmit;
    XMIT_HELPER_ROUTINE     pfnFreeInst;
    } XMIT_ROUTINE_QUINTUPLE, __RPC_FAR *PXMIT_ROUTINE_QUINTUPLE;

typedef struct _MALLOC_FREE_STRUCT
    {
    void __RPC_FAR *	(__RPC_FAR __RPC_USER * pfnAllocate)(size_t);
    void                (__RPC_FAR __RPC_USER * pfnFree)(void __RPC_FAR *);
    } MALLOC_FREE_STRUCT;

typedef struct _COMM_FAULT_OFFSETS
    {
    short       CommOffset;
    short       FaultOffset;
    } COMM_FAULT_OFFSETS;

/*
 * MIDL Stub Descriptor
 */
typedef struct _MIDL_STUB_DESC
    {

    void __RPC_FAR *    RpcInterfaceInformation;

    void __RPC_FAR *    (__RPC_FAR __RPC_API * pfnAllocate)(size_t);
    void                (__RPC_FAR __RPC_API * pfnFree)(void __RPC_FAR *);

    union
        {
        handle_t __RPC_FAR *            pAutoHandle;
        handle_t __RPC_FAR *            pPrimitiveHandle;
        PGENERIC_BINDING_INFO           pGenericBindingInfo;
        } IMPLICIT_HANDLE_INFO;

    const NDR_RUNDOWN __RPC_FAR *                   apfnNdrRundownRoutines;
    const GENERIC_BINDING_ROUTINE_PAIR __RPC_FAR *  aGenericBindingRoutinePairs;

    const EXPR_EVAL __RPC_FAR *                     apfnExprEval;

    const XMIT_ROUTINE_QUINTUPLE __RPC_FAR *        aXmitQuintuple;

    const unsigned char __RPC_FAR *             pFormatTypes;

    int                                 fCheckBounds;

    /* Ndr library version. */
    unsigned long                       Version;

    /*
     * Reserved for future use.
     */

    MALLOC_FREE_STRUCT __RPC_FAR *      pMallocFreeStruct;

    long                                MIDLVersion;

    const COMM_FAULT_OFFSETS __RPC_FAR *    CommFaultOffsets;

    } MIDL_STUB_DESC; 

typedef const MIDL_STUB_DESC __RPC_FAR * PMIDL_STUB_DESC;

typedef void __RPC_FAR * PMIDL_XMIT_TYPE;

/*
 * MIDL Stub Format String.  This is a const in the stub.
 */
#if !defined( RC_INVOKED )
#pragma warning( disable:4200 )
#endif
typedef struct _MIDL_FORMAT_STRING
    {
    short               Pad;
    unsigned char       Format[];
    } MIDL_FORMAT_STRING;
#if !defined( RC_INVOKED )
#pragma warning( default:4200 )
#endif

/*
 * Stub thunk used for some interpreted server stubs.
 */
typedef void (__RPC_FAR __RPC_API * STUB_THUNK)( PMIDL_STUB_MESSAGE );

typedef long (__RPC_FAR __RPC_API * SERVER_ROUTINE)();

/*
 * Server Interpreter's information strucuture.
 */ 
typedef struct  _MIDL_SERVER_INFO_ 
    {
    PMIDL_STUB_DESC             pStubDesc;
    const SERVER_ROUTINE *      DispatchTable;
    PFORMAT_STRING              ProcString;
    const unsigned short *      FmtStringOffset;
    const STUB_THUNK *          ThunkTable;
    } MIDL_SERVER_INFO, *PMIDL_SERVER_INFO;

/*
 * Stubless object proxy information structure.
 */
typedef struct _MIDL_STUBLESS_PROXY_INFO 
    {
    PMIDL_STUB_DESC                     pStubDesc;
    PFORMAT_STRING                      ProcFormatString;
    const unsigned short __RPC_FAR *    FormatStringOffset;
    } MIDL_STUBLESS_PROXY_INFO;

typedef MIDL_STUBLESS_PROXY_INFO __RPC_FAR * PMIDL_STUBLESS_PROXY_INFO;

/* 
 * This is the return value from NdrClientCall.
 */
typedef union _CLIENT_CALL_RETURN 
    {
    void __RPC_FAR *        Pointer;
    long                    Simple;
    } CLIENT_CALL_RETURN;

/*
 * Full pointer data structures.
 */

typedef enum 
        {
        XLAT_SERVER = 1,
        XLAT_CLIENT
        } XLAT_SIDE;

/*
 * Stores the translation for the conversion from a full pointer into it's
 * corresponding ref id.
 */
typedef struct _FULL_PTR_TO_REFID_ELEMENT
    {
    struct _FULL_PTR_TO_REFID_ELEMENT __RPC_FAR *  Next;

    void __RPC_FAR *            Pointer;
    unsigned long       RefId;
    unsigned char       State;
    } FULL_PTR_TO_REFID_ELEMENT, __RPC_FAR *PFULL_PTR_TO_REFID_ELEMENT;

/*
 * Full pointer translation tables.
 */
typedef struct _FULL_PTR_XLAT_TABLES
    {
    /*
     * Ref id to pointer translation information.
     */
    struct
        {
        void __RPC_FAR *__RPC_FAR *             XlatTable;
        unsigned char __RPC_FAR *     StateTable;
        unsigned long       NumberOfEntries;
        } RefIdToPointer;

    /*
     * Pointer to ref id translation information.
     */
    struct
        {
        PFULL_PTR_TO_REFID_ELEMENT __RPC_FAR *  XlatTable;
        unsigned long                   NumberOfBuckets;
        unsigned long                   HashMask;
        } PointerToRefId;

    /*
     * Next ref id to use.
     */
    unsigned long           NextRefId;

    /*
     * Keep track of the translation size we're handling : server or client.
     * This tells us when we have to do reverse translations when we insert
     * new translations.  On the server we must insert a pointer-to-refid 
     * translation whenever we insert a refid-to-pointer translation, and 
     * vica versa for the client.
     */
    XLAT_SIDE               XlatSide;
    } FULL_PTR_XLAT_TABLES, __RPC_FAR *PFULL_PTR_XLAT_TABLES;

/***************************************************************************
 ** New MIDL 2.0 Ndr routine templates
 ***************************************************************************/

/*
 * Marshall routines
 */

void RPC_ENTRY
NdrSimpleTypeMarshall( 
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char __RPC_FAR *                       pMemory, 
    unsigned char                       FormatChar   
    );

unsigned char __RPC_FAR * RPC_ENTRY
NdrPointerMarshall( 
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char __RPC_FAR *           pMemory, 
    PFORMAT_STRING                      pFormat   
    );

/* Structures */

unsigned char __RPC_FAR * RPC_ENTRY
NdrSimpleStructMarshall( 
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char __RPC_FAR *           pMemory, 
    PFORMAT_STRING                      pFormat   
    );

unsigned char __RPC_FAR * RPC_ENTRY
NdrConformantStructMarshall( 
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char __RPC_FAR *           pMemory, 
    PFORMAT_STRING                      pFormat   
    );

unsigned char __RPC_FAR * RPC_ENTRY
NdrConformantVaryingStructMarshall( 
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char __RPC_FAR *           pMemory, 
    PFORMAT_STRING                      pFormat   
    );

unsigned char __RPC_FAR * RPC_ENTRY
NdrHardStructMarshall( 
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char __RPC_FAR *           pMemory, 
    PFORMAT_STRING                      pFormat   
    );

unsigned char __RPC_FAR * RPC_ENTRY
NdrComplexStructMarshall( 
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char __RPC_FAR *           pMemory, 
    PFORMAT_STRING                      pFormat   
    );

/* Arrays */

unsigned char __RPC_FAR * RPC_ENTRY
NdrFixedArrayMarshall( 
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char __RPC_FAR *           pMemory, 
    PFORMAT_STRING                      pFormat   
    );

unsigned char __RPC_FAR * RPC_ENTRY
NdrConformantArrayMarshall( 
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char __RPC_FAR *           pMemory, 
    PFORMAT_STRING                      pFormat   
    );

unsigned char __RPC_FAR * RPC_ENTRY
NdrConformantVaryingArrayMarshall( 
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char __RPC_FAR *           pMemory, 
    PFORMAT_STRING                      pFormat   
    );

unsigned char __RPC_FAR * RPC_ENTRY
NdrVaryingArrayMarshall( 
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char __RPC_FAR *           pMemory, 
    PFORMAT_STRING                      pFormat   
    );

unsigned char __RPC_FAR * RPC_ENTRY
NdrComplexArrayMarshall( 
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char __RPC_FAR *           pMemory, 
    PFORMAT_STRING                      pFormat   
    );

/* Strings */

unsigned char __RPC_FAR * RPC_ENTRY
NdrNonConformantStringMarshall( 
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char __RPC_FAR *           pMemory, 
    PFORMAT_STRING                      pFormat   
    );

unsigned char __RPC_FAR * RPC_ENTRY
NdrConformantStringMarshall( 
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char __RPC_FAR *           pMemory, 
    PFORMAT_STRING                      pFormat   
    );

/* Unions */

unsigned char __RPC_FAR * RPC_ENTRY
NdrEncapsulatedUnionMarshall( 
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char __RPC_FAR *           pMemory, 
    PFORMAT_STRING                      pFormat   
    );

unsigned char __RPC_FAR * RPC_ENTRY
NdrNonEncapsulatedUnionMarshall( 
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char __RPC_FAR *           pMemory, 
    PFORMAT_STRING                      pFormat   
    );

/* Byte count pointer */

unsigned char __RPC_FAR * RPC_ENTRY
NdrByteCountPointerMarshall( 
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char __RPC_FAR *           pMemory, 
    PFORMAT_STRING                      pFormat   
    );

/* Transmit as and represent as*/

unsigned char __RPC_FAR * RPC_ENTRY
NdrXmitOrRepAsMarshall( 
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char __RPC_FAR *           pMemory, 
    PFORMAT_STRING                      pFormat   
    );

/* Cairo interface pointer */

unsigned char __RPC_FAR * RPC_ENTRY
NdrInterfacePointerMarshall( 
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char __RPC_FAR *           pMemory, 
    PFORMAT_STRING                      pFormat   
    );

/* Context handles */

void RPC_ENTRY
NdrClientContextMarshall( 
    PMIDL_STUB_MESSAGE    pStubMsg,
    NDR_CCONTEXT          ContextHandle,
    int                   fCheck 
    );

void RPC_ENTRY
NdrServerContextMarshall( 
    PMIDL_STUB_MESSAGE    pStubMsg,
    NDR_SCONTEXT          ContextHandle,
    NDR_RUNDOWN           RundownRoutine 
    );

/*
 * Unmarshall routines
 */

void RPC_ENTRY 
NdrSimpleTypeUnmarshall( 
    PMIDL_STUB_MESSAGE                  pStubMsg, 
    unsigned char __RPC_FAR *           pMemory, 
    unsigned char                       FormatChar
    );

unsigned char __RPC_FAR * RPC_ENTRY 
NdrPointerUnmarshall( 
    PMIDL_STUB_MESSAGE                      pStubMsg, 
    unsigned char __RPC_FAR * __RPC_FAR *   ppMemory, 
    PFORMAT_STRING                          pFormat,
    unsigned char                           fMustAlloc
    );

/* Structures */

unsigned char __RPC_FAR * RPC_ENTRY
NdrSimpleStructUnmarshall( 
    PMIDL_STUB_MESSAGE                      pStubMsg, 
    unsigned char __RPC_FAR * __RPC_FAR *   ppMemory, 
    PFORMAT_STRING                          pFormat,
    unsigned char                           fMustAlloc 
    );

unsigned char __RPC_FAR * RPC_ENTRY
NdrConformantStructUnmarshall( 
    PMIDL_STUB_MESSAGE                      pStubMsg, 
    unsigned char __RPC_FAR * __RPC_FAR *   ppMemory, 
    PFORMAT_STRING                          pFormat,
    unsigned char                           fMustAlloc 
    );

unsigned char __RPC_FAR * RPC_ENTRY
NdrConformantVaryingStructUnmarshall( 
    PMIDL_STUB_MESSAGE                      pStubMsg, 
    unsigned char __RPC_FAR * __RPC_FAR *   ppMemory, 
    PFORMAT_STRING                          pFormat,
    unsigned char                           fMustAlloc 
    );

unsigned char __RPC_FAR * RPC_ENTRY 
NdrHardStructUnmarshall( 
    PMIDL_STUB_MESSAGE                      pStubMsg, 
    unsigned char __RPC_FAR * __RPC_FAR *   ppMemory, 
    PFORMAT_STRING                          pFormat,
    unsigned char                           fMustAlloc 
    );

unsigned char __RPC_FAR * RPC_ENTRY 
NdrComplexStructUnmarshall( 
    PMIDL_STUB_MESSAGE                      pStubMsg, 
    unsigned char __RPC_FAR * __RPC_FAR *   ppMemory, 
    PFORMAT_STRING                          pFormat,
    unsigned char                           fMustAlloc 
    );

/* Arrays */

unsigned char __RPC_FAR * RPC_ENTRY
NdrFixedArrayUnmarshall( 
    PMIDL_STUB_MESSAGE                      pStubMsg, 
    unsigned char __RPC_FAR * __RPC_FAR *   ppMemory, 
    PFORMAT_STRING                          pFormat,
    unsigned char                           fMustAlloc 
    );

unsigned char __RPC_FAR * RPC_ENTRY
NdrConformantArrayUnmarshall( 
    PMIDL_STUB_MESSAGE                      pStubMsg, 
    unsigned char __RPC_FAR * __RPC_FAR *   ppMemory, 
    PFORMAT_STRING                          pFormat,
    unsigned char                           fMustAlloc 
    );

unsigned char __RPC_FAR * RPC_ENTRY
NdrConformantVaryingArrayUnmarshall( 
    PMIDL_STUB_MESSAGE                      pStubMsg, 
    unsigned char __RPC_FAR * __RPC_FAR *   ppMemory, 
    PFORMAT_STRING                          pFormat,
    unsigned char                           fMustAlloc 
    );

unsigned char __RPC_FAR * RPC_ENTRY
NdrVaryingArrayUnmarshall( 
    PMIDL_STUB_MESSAGE                      pStubMsg, 
    unsigned char __RPC_FAR * __RPC_FAR *   ppMemory, 
    PFORMAT_STRING                          pFormat,
    unsigned char                           fMustAlloc 
    );

unsigned char __RPC_FAR * RPC_ENTRY
NdrComplexArrayUnmarshall( 
    PMIDL_STUB_MESSAGE                      pStubMsg, 
    unsigned char __RPC_FAR * __RPC_FAR *   ppMemory, 
    PFORMAT_STRING                          pFormat,   
    unsigned char                           fMustAlloc 
    );

/* Strings */

unsigned char __RPC_FAR * RPC_ENTRY
NdrNonConformantStringUnmarshall( 
    PMIDL_STUB_MESSAGE                      pStubMsg, 
    unsigned char __RPC_FAR * __RPC_FAR *   ppMemory, 
    PFORMAT_STRING                          pFormat,
    unsigned char                           fMustAlloc 
    );

unsigned char __RPC_FAR * RPC_ENTRY
NdrConformantStringUnmarshall( 
    PMIDL_STUB_MESSAGE                      pStubMsg, 
    unsigned char __RPC_FAR * __RPC_FAR *   ppMemory, 
    PFORMAT_STRING                          pFormat,   
    unsigned char                           fMustAlloc 
    );

/* Unions */

unsigned char __RPC_FAR * RPC_ENTRY
NdrEncapsulatedUnionUnmarshall( 
    PMIDL_STUB_MESSAGE                      pStubMsg, 
    unsigned char __RPC_FAR * __RPC_FAR *   ppMemory, 
    PFORMAT_STRING                          pFormat,   
    unsigned char                           fMustAlloc 
    );

unsigned char __RPC_FAR * RPC_ENTRY
NdrNonEncapsulatedUnionUnmarshall( 
    PMIDL_STUB_MESSAGE                      pStubMsg, 
    unsigned char __RPC_FAR * __RPC_FAR *   ppMemory, 
    PFORMAT_STRING                          pFormat,   
    unsigned char                           fMustAlloc 
    );

/* Byte count pointer */

unsigned char __RPC_FAR * RPC_ENTRY 
NdrByteCountPointerUnmarshall( 
    PMIDL_STUB_MESSAGE                      pStubMsg, 
    unsigned char __RPC_FAR * __RPC_FAR *   ppMemory, 
    PFORMAT_STRING                          pFormat,   
    unsigned char                           fMustAlloc
    );

/* Transmit as and represent as*/

unsigned char __RPC_FAR * RPC_ENTRY 
NdrXmitOrRepAsUnmarshall( 
    PMIDL_STUB_MESSAGE                      pStubMsg, 
    unsigned char __RPC_FAR * __RPC_FAR *   ppMemory, 
    PFORMAT_STRING                          pFormat,   
    unsigned char                           fMustAlloc
    );

/* Cairo interface pointer */

unsigned char __RPC_FAR * RPC_ENTRY 
NdrInterfacePointerUnmarshall( 
    PMIDL_STUB_MESSAGE                      pStubMsg, 
    unsigned char __RPC_FAR * __RPC_FAR *   ppMemory, 
    PFORMAT_STRING                          pFormat,   
    unsigned char                           fMustAlloc
    );

/* Context handles */

void RPC_ENTRY
NdrClientContextUnmarshall( 
    PMIDL_STUB_MESSAGE          pStubMsg,
    NDR_CCONTEXT __RPC_FAR *    pContextHandle,
    RPC_BINDING_HANDLE          BindHandle 
    );

NDR_SCONTEXT RPC_ENTRY
NdrServerContextUnmarshall( 
    PMIDL_STUB_MESSAGE          pStubMsg 
    );

/*
 * Buffer sizing routines
 */

void RPC_ENTRY
NdrPointerBufferSize(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char __RPC_FAR *           pMemory, 
    PFORMAT_STRING                      pFormat   
    );

/* Structures */

void RPC_ENTRY
NdrSimpleStructBufferSize( 
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char __RPC_FAR *           pMemory, 
    PFORMAT_STRING                      pFormat   
    );

void RPC_ENTRY 
NdrConformantStructBufferSize( 
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char __RPC_FAR *           pMemory, 
    PFORMAT_STRING                      pFormat   
    );

void RPC_ENTRY 
NdrConformantVaryingStructBufferSize( 
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char __RPC_FAR *           pMemory, 
    PFORMAT_STRING                      pFormat   
    );

void RPC_ENTRY 
NdrHardStructBufferSize( 
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char __RPC_FAR *           pMemory, 
    PFORMAT_STRING                      pFormat   
    );

void RPC_ENTRY 
NdrComplexStructBufferSize( 
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char __RPC_FAR *           pMemory, 
    PFORMAT_STRING                      pFormat   
    );

/* Arrays */

void RPC_ENTRY 
NdrFixedArrayBufferSize( 
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char __RPC_FAR *           pMemory, 
    PFORMAT_STRING                      pFormat   
    );

void RPC_ENTRY 
NdrConformantArrayBufferSize( 
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char __RPC_FAR *           pMemory, 
    PFORMAT_STRING                      pFormat   
    );

void RPC_ENTRY 
NdrConformantVaryingArrayBufferSize( 
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char __RPC_FAR *           pMemory, 
    PFORMAT_STRING                      pFormat   
    );

void RPC_ENTRY 
NdrVaryingArrayBufferSize( 
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char __RPC_FAR *           pMemory, 
    PFORMAT_STRING                      pFormat   
    );

void RPC_ENTRY
NdrComplexArrayBufferSize( 
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char __RPC_FAR *           pMemory, 
    PFORMAT_STRING                      pFormat   
    );

/* Strings */

void RPC_ENTRY 
NdrConformantStringBufferSize( 
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char __RPC_FAR *           pMemory, 
    PFORMAT_STRING                      pFormat   
    );

void RPC_ENTRY 
NdrNonConformantStringBufferSize( 
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char __RPC_FAR *           pMemory, 
    PFORMAT_STRING                      pFormat   
    );

/* Unions */

void RPC_ENTRY 
NdrEncapsulatedUnionBufferSize( 
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char __RPC_FAR *           pMemory, 
    PFORMAT_STRING                      pFormat   
    );

void RPC_ENTRY 
NdrNonEncapsulatedUnionBufferSize( 
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char __RPC_FAR *           pMemory, 
    PFORMAT_STRING                      pFormat   
    );

/* Byte count pointer */

void RPC_ENTRY
NdrByteCountPointerBufferSize(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char __RPC_FAR *           pMemory, 
    PFORMAT_STRING                      pFormat   
    );

/* Transmit as and represent as*/

void RPC_ENTRY
NdrXmitOrRepAsBufferSize(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char __RPC_FAR *           pMemory, 
    PFORMAT_STRING                      pFormat   
    );

/* Cairo Interface pointer */

void RPC_ENTRY
NdrInterfacePointerBufferSize(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char __RPC_FAR *           pMemory, 
    PFORMAT_STRING                      pFormat   
    );

// Context Handle size
//
void RPC_ENTRY
NdrContextHandleSize(
    PMIDL_STUB_MESSAGE          pStubMsg,
    unsigned char __RPC_FAR *           pMemory, 
    PFORMAT_STRING                      pFormat   
    );

/*
 * Memory sizing routines
 */

unsigned long RPC_ENTRY
NdrPointerMemorySize(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    PFORMAT_STRING                      pFormat
    );

/* Structures */

unsigned long RPC_ENTRY
NdrSimpleStructMemorySize( 
    PMIDL_STUB_MESSAGE                  pStubMsg,
    PFORMAT_STRING                      pFormat
    );

unsigned long RPC_ENTRY 
NdrConformantStructMemorySize( 
    PMIDL_STUB_MESSAGE                  pStubMsg,
    PFORMAT_STRING                      pFormat
    );

unsigned long RPC_ENTRY 
NdrConformantVaryingStructMemorySize( 
    PMIDL_STUB_MESSAGE                  pStubMsg,
    PFORMAT_STRING                      pFormat
    );

unsigned long RPC_ENTRY 
NdrHardStructMemorySize( 
    PMIDL_STUB_MESSAGE                  pStubMsg,
    PFORMAT_STRING                      pFormat
    );

unsigned long RPC_ENTRY 
NdrComplexStructMemorySize( 
    PMIDL_STUB_MESSAGE                  pStubMsg,
    PFORMAT_STRING                      pFormat
    );

/* Arrays */

unsigned long RPC_ENTRY 
NdrFixedArrayMemorySize( 
    PMIDL_STUB_MESSAGE                  pStubMsg,
    PFORMAT_STRING                      pFormat
    );

unsigned long RPC_ENTRY 
NdrConformantArrayMemorySize( 
    PMIDL_STUB_MESSAGE                  pStubMsg,
    PFORMAT_STRING                      pFormat
    );

unsigned long RPC_ENTRY 
NdrConformantVaryingArrayMemorySize( 
    PMIDL_STUB_MESSAGE                  pStubMsg,
    PFORMAT_STRING                      pFormat
    );

unsigned long RPC_ENTRY 
NdrVaryingArrayMemorySize( 
    PMIDL_STUB_MESSAGE                  pStubMsg,
    PFORMAT_STRING                      pFormat
    );

unsigned long RPC_ENTRY 
NdrComplexArrayMemorySize( 
    PMIDL_STUB_MESSAGE                  pStubMsg,
    PFORMAT_STRING                      pFormat
    );

/* Strings */

unsigned long RPC_ENTRY 
NdrConformantStringMemorySize( 
    PMIDL_STUB_MESSAGE                  pStubMsg,
    PFORMAT_STRING                      pFormat
    );

unsigned long RPC_ENTRY 
NdrNonConformantStringMemorySize( 
    PMIDL_STUB_MESSAGE                  pStubMsg,
    PFORMAT_STRING                      pFormat
    );

/* Unions */

unsigned long RPC_ENTRY 
NdrEncapsulatedUnionMemorySize( 
    PMIDL_STUB_MESSAGE                  pStubMsg,
    PFORMAT_STRING                      pFormat
    );

unsigned long RPC_ENTRY 
NdrNonEncapsulatedUnionMemorySize( 
    PMIDL_STUB_MESSAGE                  pStubMsg,
    PFORMAT_STRING                      pFormat
    );

/* Transmit as and represent as*/

unsigned long RPC_ENTRY
NdrXmitOrRepAsMemorySize(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    PFORMAT_STRING                      pFormat
    );

/* Cairo Interface pointer */

unsigned long RPC_ENTRY
NdrInterfacePointerMemorySize(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    PFORMAT_STRING                      pFormat
    );

/*
 * Freeing routines
 */

void RPC_ENTRY
NdrPointerFree(
    PMIDL_STUB_MESSAGE                  pStubMsg, 
    unsigned char __RPC_FAR *           pMemory, 
    PFORMAT_STRING                      pFormat   
    );

/* Structures */

void RPC_ENTRY 
NdrSimpleStructFree( 
    PMIDL_STUB_MESSAGE                  pStubMsg, 
    unsigned char __RPC_FAR *           pMemory, 
    PFORMAT_STRING                      pFormat   
    );

void RPC_ENTRY 
NdrConformantStructFree( 
    PMIDL_STUB_MESSAGE                  pStubMsg, 
    unsigned char __RPC_FAR *           pMemory, 
    PFORMAT_STRING                      pFormat   
    );

void RPC_ENTRY 
NdrConformantVaryingStructFree( 
    PMIDL_STUB_MESSAGE                  pStubMsg, 
    unsigned char __RPC_FAR *           pMemory, 
    PFORMAT_STRING                      pFormat   
    );

void RPC_ENTRY
NdrHardStructFree( 
    PMIDL_STUB_MESSAGE                  pStubMsg, 
    unsigned char __RPC_FAR *           pMemory, 
    PFORMAT_STRING                      pFormat   
    );

void RPC_ENTRY
NdrComplexStructFree( 
    PMIDL_STUB_MESSAGE                  pStubMsg, 
    unsigned char __RPC_FAR *           pMemory, 
    PFORMAT_STRING                      pFormat   
    );

/* Arrays */

void RPC_ENTRY 
NdrFixedArrayFree( 
    PMIDL_STUB_MESSAGE                  pStubMsg, 
    unsigned char __RPC_FAR *           pMemory, 
    PFORMAT_STRING                      pFormat   
    );

void RPC_ENTRY 
NdrConformantArrayFree( 
    PMIDL_STUB_MESSAGE                  pStubMsg, 
    unsigned char __RPC_FAR *           pMemory, 
    PFORMAT_STRING                      pFormat   
    );

void RPC_ENTRY 
NdrConformantVaryingArrayFree( 
    PMIDL_STUB_MESSAGE                  pStubMsg, 
    unsigned char __RPC_FAR *           pMemory, 
    PFORMAT_STRING                      pFormat   
    );

void RPC_ENTRY 
NdrVaryingArrayFree( 
    PMIDL_STUB_MESSAGE                  pStubMsg, 
    unsigned char __RPC_FAR *           pMemory, 
    PFORMAT_STRING                      pFormat   
    );

void RPC_ENTRY 
NdrComplexArrayFree( 
    PMIDL_STUB_MESSAGE                  pStubMsg, 
    unsigned char __RPC_FAR *           pMemory, 
    PFORMAT_STRING                      pFormat   
    );

/* Unions */

void RPC_ENTRY 
NdrEncapsulatedUnionFree( 
    PMIDL_STUB_MESSAGE                  pStubMsg, 
    unsigned char __RPC_FAR *           pMemory, 
    PFORMAT_STRING                      pFormat   
    );

void RPC_ENTRY 
NdrNonEncapsulatedUnionFree(  
    PMIDL_STUB_MESSAGE                  pStubMsg, 
    unsigned char __RPC_FAR *           pMemory, 
    PFORMAT_STRING                      pFormat   
    );

/* Byte count */

void RPC_ENTRY 
NdrByteCountPointerFree( 
    PMIDL_STUB_MESSAGE                  pStubMsg, 
    unsigned char __RPC_FAR *           pMemory, 
    PFORMAT_STRING                      pFormat   
    );

/* Transmit as and represent as*/

void RPC_ENTRY 
NdrXmitOrRepAsFree( 
    PMIDL_STUB_MESSAGE                  pStubMsg, 
    unsigned char __RPC_FAR *           pMemory, 
    PFORMAT_STRING                      pFormat   
    );

/* Cairo Interface pointer */

void RPC_ENTRY 
NdrInterfacePointerFree( 
    PMIDL_STUB_MESSAGE                  pStubMsg, 
    unsigned char __RPC_FAR *           pMemory, 
    PFORMAT_STRING                      pFormat   
    );

/*
 * Endian conversion routine.
 */

void RPC_ENTRY 
NdrConvert( 
    PMIDL_STUB_MESSAGE                  pStubMsg, 
    PFORMAT_STRING                      pFormat   
    );

/* 
 * Auxilary routines
 */

void RPC_ENTRY 
NdrClientInitializeNew( 
    PRPC_MESSAGE                        pRpcMsg,
    PMIDL_STUB_MESSAGE                  pStubMsg,
    PMIDL_STUB_DESC                     pStubDescriptor,
    unsigned int                        ProcNum
    );

unsigned char __RPC_FAR * RPC_ENTRY
NdrServerInitializeNew( 
    PRPC_MESSAGE                        pRpcMsg,
    PMIDL_STUB_MESSAGE                  pStubMsg,
    PMIDL_STUB_DESC                     pStubDescriptor
    );

void RPC_ENTRY 
NdrClientInitialize( 
    PRPC_MESSAGE                        pRpcMsg,
    PMIDL_STUB_MESSAGE                  pStubMsg,
    PMIDL_STUB_DESC                     pStubDescriptor,
    unsigned int                        ProcNum
    );

unsigned char __RPC_FAR * RPC_ENTRY
NdrServerInitialize( 
    PRPC_MESSAGE                        pRpcMsg,
    PMIDL_STUB_MESSAGE                  pStubMsg,
    PMIDL_STUB_DESC                     pStubDescriptor
    );

unsigned char __RPC_FAR * RPC_ENTRY
NdrServerInitializeUnmarshall ( 
    PMIDL_STUB_MESSAGE                  pStubMsg,
    PMIDL_STUB_DESC                     pStubDescriptor,
    PRPC_MESSAGE                        pRpcMsg 
    );

void RPC_ENTRY
NdrServerInitializeMarshall ( 
    PRPC_MESSAGE                        pRpcMsg,
    PMIDL_STUB_MESSAGE                  pStubMsg 
    );

unsigned char __RPC_FAR * RPC_ENTRY
NdrGetBuffer( 
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned long                       BufferLength,
    RPC_BINDING_HANDLE                  Handle
    );

unsigned char __RPC_FAR * RPC_ENTRY
NdrNsGetBuffer( 
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned long                       BufferLength,
    RPC_BINDING_HANDLE                  Handle
    );

unsigned char __RPC_FAR * RPC_ENTRY
NdrSendReceive(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char __RPC_FAR*                        pBufferEnd
    );

unsigned char __RPC_FAR * RPC_ENTRY
NdrNsSendReceive(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char __RPC_FAR *                       pBufferEnd,
    RPC_BINDING_HANDLE __RPC_FAR *              pAutoHandle
    );

void RPC_ENTRY
NdrFreeBuffer(
    PMIDL_STUB_MESSAGE                  pStubMsg
    );

/* 
 * Interpeter calls.
 */

/* client */

CLIENT_CALL_RETURN RPC_VAR_ENTRY
NdrClientCall( 
    PMIDL_STUB_DESC                     pStubDescriptor,
    PFORMAT_STRING                      pFormat,
    ...
    );

/* server */
typedef enum {
    STUB_UNMARSHAL,
    STUB_CALL_SERVER,
    STUB_MARSHAL,
    STUB_CALL_SERVER_NO_HRESULT
}STUB_PHASE;

typedef enum {
    PROXY_CALCSIZE,
    PROXY_GETBUFFER,
    PROXY_MARSHAL,
    PROXY_SENDRECEIVE,
    PROXY_UNMARSHAL
}PROXY_PHASE;


long RPC_ENTRY
NdrStubCall (
    struct IRpcStubBuffer __RPC_FAR *    pThis,
    struct IRpcChannelBuffer __RPC_FAR * pChannel,
    PRPC_MESSAGE                         pRpcMsg,
    unsigned long __RPC_FAR *            pdwStubPhase
    );

void RPC_ENTRY
NdrServerCall(
    PRPC_MESSAGE                        pRpcMsg
    );

int RPC_ENTRY
NdrServerUnmarshall( 
    struct IRpcChannelBuffer __RPC_FAR * pChannel,
    PRPC_MESSAGE                         pRpcMsg,
    PMIDL_STUB_MESSAGE                   pStubMsg,
    PMIDL_STUB_DESC                      pStubDescriptor,
    PFORMAT_STRING                       pFormat,
    void __RPC_FAR *                     pParamList
    );

void RPC_ENTRY
NdrServerMarshall(
    struct IRpcStubBuffer __RPC_FAR *    pThis,
    struct IRpcChannelBuffer __RPC_FAR * pChannel,
    PMIDL_STUB_MESSAGE                   pStubMsg,
    PFORMAT_STRING                       pFormat
    );

/* Comm and Fault status */

RPC_STATUS RPC_ENTRY
NdrMapCommAndFaultStatus(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned long __RPC_FAR *                       pCommStatus,
    unsigned long __RPC_FAR *                       pFaultStatus,
    RPC_STATUS                          Status
    );

/* Helper routines */

int RPC_ENTRY
NdrSH_UPDecision(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char           __RPC_FAR *__RPC_FAR *          pPtrInMem,
    RPC_BUFPTR                          pBuffer
    );

int RPC_ENTRY
NdrSH_TLUPDecision(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char           __RPC_FAR *__RPC_FAR *          pPtrInMem
    );

int RPC_ENTRY
NdrSH_TLUPDecisionBuffer(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char           __RPC_FAR *__RPC_FAR *          pPtrInMem
    );

int RPC_ENTRY
NdrSH_IfAlloc(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char           __RPC_FAR *__RPC_FAR *          pPtrInMem,
    unsigned long                       Count
    );

int RPC_ENTRY
NdrSH_IfAllocRef(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char           __RPC_FAR *__RPC_FAR *          pPtrInMem,
    unsigned long                       Count
    );

int RPC_ENTRY
NdrSH_IfAllocSet(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char           __RPC_FAR *__RPC_FAR *          pPtrInMem,
    unsigned long                       Count
    );

RPC_BUFPTR RPC_ENTRY
NdrSH_IfCopy(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char           __RPC_FAR *__RPC_FAR *          pPtrInMem,
    unsigned long                       Count
    );

RPC_BUFPTR RPC_ENTRY
NdrSH_IfAllocCopy(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char           __RPC_FAR *__RPC_FAR *          pPtrInMem,
    unsigned long                       Count
    );

unsigned long RPC_ENTRY
NdrSH_Copy(
    unsigned char           __RPC_FAR *         pStubMsg,
    unsigned char           __RPC_FAR *         pPtrInMem,
    unsigned long                       Count
    );

void RPC_ENTRY
NdrSH_IfFree(
    PMIDL_STUB_MESSAGE                  pMessage,
    unsigned char           __RPC_FAR *         pPtr );


RPC_BUFPTR  RPC_ENTRY
NdrSH_StringMarshall(
    PMIDL_STUB_MESSAGE                  pMessage,
    unsigned char           __RPC_FAR *         pMemory,
    unsigned long                       Count,
    int                                 Size );

RPC_BUFPTR  RPC_ENTRY
NdrSH_StringUnMarshall(
    PMIDL_STUB_MESSAGE                  pMessage,
    unsigned char           __RPC_FAR *__RPC_FAR *          pMemory,
    int                                 Size );

/****************************************************************************
    MIDL 2.0 memory package: rpc_ss_* rpc_sm_*
 ****************************************************************************/

typedef void __RPC_FAR * RPC_SS_THREAD_HANDLE;

typedef void __RPC_FAR * __RPC_API 
RPC_CLIENT_ALLOC (
    IN size_t Size
    );

typedef void __RPC_API 
RPC_CLIENT_FREE (
    IN void __RPC_FAR * Ptr
    );

/*++
     RpcSs* package
--*/

void __RPC_FAR * RPC_ENTRY
RpcSsAllocate (
    IN size_t Size
    );

void RPC_ENTRY
RpcSsDisableAllocate (
    void
    );

void RPC_ENTRY
RpcSsEnableAllocate (
    void
    );

void RPC_ENTRY
RpcSsFree (
    IN void __RPC_FAR * NodeToFree
    );

RPC_SS_THREAD_HANDLE RPC_ENTRY
RpcSsGetThreadHandle (
    void
    );

void RPC_ENTRY
RpcSsSetClientAllocFree (
    IN RPC_CLIENT_ALLOC __RPC_FAR * ClientAlloc,
    IN RPC_CLIENT_FREE __RPC_FAR * ClientFree
    );

void RPC_ENTRY
RpcSsSetThreadHandle (
    IN RPC_SS_THREAD_HANDLE Id
    );

void RPC_ENTRY
RpcSsSwapClientAllocFree (
    IN RPC_CLIENT_ALLOC __RPC_FAR * ClientAlloc,
    IN RPC_CLIENT_FREE __RPC_FAR * ClientFree,
    OUT RPC_CLIENT_ALLOC __RPC_FAR * __RPC_FAR * OldClientAlloc,
    OUT RPC_CLIENT_FREE __RPC_FAR * __RPC_FAR * OldClientFree
    );

/*++
     RpcSm* package
--*/

void __RPC_FAR * RPC_ENTRY
RpcSmAllocate (
    IN  size_t          Size,
    OUT RPC_STATUS __RPC_FAR *    pStatus
    );

RPC_STATUS RPC_ENTRY
RpcSmClientFree (
    IN  void __RPC_FAR * pNodeToFree
    );

RPC_STATUS  RPC_ENTRY
RpcSmDestroyClientContext (
    IN void __RPC_FAR * __RPC_FAR * ContextHandle
    );

RPC_STATUS  RPC_ENTRY
RpcSmDisableAllocate (
    void
    );

RPC_STATUS  RPC_ENTRY
RpcSmEnableAllocate (
    void
    );

RPC_STATUS  RPC_ENTRY
RpcSmFree (
    IN void __RPC_FAR * NodeToFree
    );

RPC_SS_THREAD_HANDLE RPC_ENTRY
RpcSmGetThreadHandle (
    OUT RPC_STATUS __RPC_FAR *    pStatus
    );

RPC_STATUS  RPC_ENTRY
RpcSmSetClientAllocFree (
    IN RPC_CLIENT_ALLOC __RPC_FAR * ClientAlloc,
    IN RPC_CLIENT_FREE __RPC_FAR * ClientFree
    );

RPC_STATUS  RPC_ENTRY
RpcSmSetThreadHandle (
    IN RPC_SS_THREAD_HANDLE Id
    );

RPC_STATUS  RPC_ENTRY
RpcSmSwapClientAllocFree (
    IN RPC_CLIENT_ALLOC __RPC_FAR * ClientAlloc,
    IN RPC_CLIENT_FREE __RPC_FAR * ClientFree,
    OUT RPC_CLIENT_ALLOC __RPC_FAR * __RPC_FAR * OldClientAlloc,
    OUT RPC_CLIENT_FREE __RPC_FAR * __RPC_FAR * OldClientFree
    );

/*++
     Ndr stub entry points
--*/

void RPC_ENTRY
NdrRpcSsEnableAllocate(
    PMIDL_STUB_MESSAGE      pMessage );

void RPC_ENTRY
NdrRpcSsDisableAllocate(
    PMIDL_STUB_MESSAGE      pMessage );

void RPC_ENTRY
NdrRpcSmSetClientToOsf(
    PMIDL_STUB_MESSAGE      pMessage );

void __RPC_FAR *  RPC_ENTRY
NdrRpcSmClientAllocate (
    IN size_t Size
    );

void  RPC_ENTRY
NdrRpcSmClientFree (
    IN void __RPC_FAR * NodeToFree
    );

void __RPC_FAR *  RPC_ENTRY
NdrRpcSsDefaultAllocate (
    IN size_t Size
    );

void  RPC_ENTRY
NdrRpcSsDefaultFree (
    IN void __RPC_FAR * NodeToFree
    );

/****************************************************************************
    end of memory package: rpc_ss_* rpc_sm_*
 ****************************************************************************/

/****************************************************************************
 * Full Pointer APIs
 ****************************************************************************/

PFULL_PTR_XLAT_TABLES RPC_ENTRY
NdrFullPointerXlatInit( 
    unsigned long           NumberOfPointers,
    XLAT_SIDE               XlatSide
    );

void RPC_ENTRY
NdrFullPointerXlatFree( 
    PFULL_PTR_XLAT_TABLES   pXlatTables
    );

int RPC_ENTRY
NdrFullPointerQueryPointer( 
    PFULL_PTR_XLAT_TABLES   pXlatTables,
    void __RPC_FAR *                    pPointer,
    unsigned char           QueryType,
    unsigned long __RPC_FAR *           pRefId
    );

int RPC_ENTRY
NdrFullPointerQueryRefId( 
    PFULL_PTR_XLAT_TABLES   pXlatTables,
    unsigned long           RefId,
    unsigned char           QueryType,
    void __RPC_FAR *__RPC_FAR *                 ppPointer
    );

void RPC_ENTRY
NdrFullPointerInsertRefId( 
    PFULL_PTR_XLAT_TABLES   pXlatTables,
    unsigned long           RefId,
    void __RPC_FAR *                    pPointer
    );

int RPC_ENTRY
NdrFullPointerFree( 
    PFULL_PTR_XLAT_TABLES   pXlatTables,
    void __RPC_FAR *                    Pointer
    );

void __RPC_FAR *  RPC_ENTRY
NdrAllocate( 
    PMIDL_STUB_MESSAGE      pStubMsg,
    size_t                  Len 
    );

void RPC_ENTRY
NdrClearOutParameters(
    PMIDL_STUB_MESSAGE      pStubMsg,
    PFORMAT_STRING          pFormat,
    void __RPC_FAR *        ArgAddr
    );


/****************************************************************************
 * Proxy APIs
 ****************************************************************************/

void __RPC_FAR * RPC_ENTRY
NdrOleAllocate (
    IN size_t Size
    );

void RPC_ENTRY
NdrOleFree (
    IN void __RPC_FAR * NodeToFree
    );

#ifdef CONST_VTABLE
#define CONST_VTBL const
#else
#define CONST_VTBL
#endif




#ifdef __cplusplus
}
#endif

// Reset the packing level for DOS, Windows and Mac.

#if defined(__RPC_DOS__) || defined(__RPC_WIN16__) || defined(__RPC_MAC__)
#pragma pack()
#endif

#endif /* __RPCNDR_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\tools\c932\inc\process.h ===
/***
*process.h - definition and declarations for process control functions
*
*	Copyright (c) 1985-1994, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	This file defines the modeflag values for spawnxx calls.
*	Only P_WAIT and P_OVERLAY are currently implemented on MS-DOS.
*	Also contains the function argument declarations for all
*	process control related routines.
*
****/

#ifndef _INC_PROCESS
#define _INC_PROCESS

#ifndef _POSIX_

#ifdef __cplusplus
extern "C" {
#endif


/* Define _CRTAPI1 (for compatibility with the NT SDK) */

#ifndef _CRTAPI1
#if	( (_MSC_VER >= 800) && (_M_IX86 >= 300) )
#define _CRTAPI1 __cdecl
#else
#define _CRTAPI1
#endif
#endif


/* Define _CRTAPI2 (for compatibility with the NT SDK) */

#ifndef _CRTAPI2
#if	( (_MSC_VER >= 800) && (_M_IX86 >= 300) )
#define _CRTAPI2 __cdecl
#else
#define _CRTAPI2
#endif
#endif


/* Define _CRTIMP */

#ifndef _CRTIMP
#ifdef	_NTSDK
/* definition compatible with NT SDK */
#define _CRTIMP
#else	/* ndef _NTSDK */
/* current definition */
#ifdef	_DLL
#define _CRTIMP __declspec(dllimport)
#else	/* ndef _DLL */
#define _CRTIMP
#endif	/* _DLL */
#endif	/* _NTSDK */
#endif	/* _CRTIMP */


/* Define __cdecl for non-Microsoft compilers */

#if	( !defined(_MSC_VER) && !defined(__cdecl) )
#define __cdecl
#endif


#ifndef _WCHAR_T_DEFINED
typedef unsigned short wchar_t;
#define _WCHAR_T_DEFINED
#endif


/* modeflag values for _spawnxx routines */

#ifndef _MT
extern int _p_overlay;
#endif

#define _P_WAIT 	0
#define _P_NOWAIT	1
#ifdef	_MT
#define _P_OVERLAY	2
#else
#define _P_OVERLAY	_p_overlay
#endif
#define _OLD_P_OVERLAY	2
#define _P_NOWAITO	3
#define _P_DETACH	4


/* Action codes for _cwait(). The action code argument to _cwait is ignored
   on Win32 though it is accepted for compatibilty with OS/2 */

#define _WAIT_CHILD	 0
#define _WAIT_GRANDCHILD 1


/* function prototypes */

#ifdef	_MT
_CRTIMP unsigned long  __cdecl _beginthread (void (__cdecl *) (void *),
	unsigned, void *);
_CRTIMP void __cdecl _endthread(void);
_CRTIMP unsigned long __cdecl _beginthreadex(void *, unsigned,
	unsigned (__stdcall *) (void *), void *, unsigned, unsigned *);
_CRTIMP void __cdecl _endthreadex(unsigned);
#endif
_CRTIMP void __cdecl abort(void);
_CRTIMP void __cdecl _cexit(void);
_CRTIMP void __cdecl _c_exit(void);
_CRTIMP int __cdecl _cwait(int *, int, int);
_CRTIMP int __cdecl _execl(const char *, const char *, ...);
_CRTIMP int __cdecl _execle(const char *, const char *, ...);
_CRTIMP int __cdecl _execlp(const char *, const char *, ...);
_CRTIMP int __cdecl _execlpe(const char *, const char *, ...);
_CRTIMP int __cdecl _execv(const char *, const char * const *);
_CRTIMP int __cdecl _execve(const char *, const char * const *, const char * const *);
_CRTIMP int __cdecl _execvp(const char *, const char * const *);
_CRTIMP int __cdecl _execvpe(const char *, const char * const *, const char * const *);
_CRTIMP void __cdecl exit(int);
_CRTIMP void __cdecl _exit(int);
_CRTIMP int __cdecl _getpid(void);
_CRTIMP int __cdecl _spawnl(int, const char *, const char *, ...);
_CRTIMP int __cdecl _spawnle(int, const char *, const char *, ...);
_CRTIMP int __cdecl _spawnlp(int, const char *, const char *, ...);
_CRTIMP int __cdecl _spawnlpe(int, const char *, const char *, ...);
_CRTIMP int __cdecl _spawnv(int, const char *, const char * const *);
_CRTIMP int __cdecl _spawnve(int, const char *, const char * const *,
	const char * const *);
_CRTIMP int __cdecl _spawnvp(int, const char *, const char * const *);
_CRTIMP int __cdecl _spawnvpe(int, const char *, const char * const *,
	const char * const *);
_CRTIMP int __cdecl system(const char *);

#ifndef _WPROCESS_DEFINED

/* wide function prototypes, also declared in wchar.h  */

_CRTIMP int __cdecl _wexecl(const wchar_t *, const wchar_t *, ...);
_CRTIMP int __cdecl _wexecle(const wchar_t *, const wchar_t *, ...);
_CRTIMP int __cdecl _wexeclp(const wchar_t *, const wchar_t *, ...);
_CRTIMP int __cdecl _wexeclpe(const wchar_t *, const wchar_t *, ...);
_CRTIMP int __cdecl _wexecv(const wchar_t *, const wchar_t * const *);
_CRTIMP int __cdecl _wexecve(const wchar_t *, const wchar_t * const *, const wchar_t * const *);
_CRTIMP int __cdecl _wexecvp(const wchar_t *, const wchar_t * const *);
_CRTIMP int __cdecl _wexecvpe(const wchar_t *, const wchar_t * const *, const wchar_t * const *);
_CRTIMP int __cdecl _wspawnl(int, const wchar_t *, const wchar_t *, ...);
_CRTIMP int __cdecl _wspawnle(int, const wchar_t *, const wchar_t *, ...);
_CRTIMP int __cdecl _wspawnlp(int, const wchar_t *, const wchar_t *, ...);
_CRTIMP int __cdecl _wspawnlpe(int, const wchar_t *, const wchar_t *, ...);
_CRTIMP int __cdecl _wspawnv(int, const wchar_t *, const wchar_t * const *);
_CRTIMP int __cdecl _wspawnve(int, const wchar_t *, const wchar_t * const *,
	const wchar_t * const *);
_CRTIMP int __cdecl _wspawnvp(int, const wchar_t *, const wchar_t * const *);
_CRTIMP int __cdecl _wspawnvpe(int, const wchar_t *, const wchar_t * const *,
	const wchar_t * const *);
_CRTIMP int __cdecl _wsystem(const wchar_t *);

#define _WPROCESS_DEFINED
#endif

/* --------- The following functions are OBSOLETE --------- */
/*
 * The Win32 API LoadLibrary, FreeLibrary and GetProcAddress should be used
 * instead.
 */
int __cdecl _loaddll(char *);
int __cdecl _unloaddll(int);
int (__cdecl * __cdecl _getdllprocaddr(int, char *, int))();
/* --------- The preceding functions are OBSOLETE --------- */


#ifdef	_DECL_DLLMAIN
/*
 * Declare DLL notification (initialization/termination) routines
 *	The preferred method is for the user to provide DllMain() which will
 *	be called automatically by the DLL entry point defined by the C run-
 *	time library code.  If the user wants to define the DLL entry point
 *	routine, the user's entry point must call _CRT_INIT on all types of
 *	notifications, as the very first thing on attach notifications and
 *	as the very last thing on detach notifications.
 */
#ifdef	_WINDOWS_	/* Use types from WINDOWS.H */
BOOL WINAPI DllMain(HANDLE, DWORD, LPVOID);
BOOL WINAPI _CRT_INIT(HANDLE, DWORD, LPVOID);
BOOL WINAPI _wCRT_INIT(HANDLE, DWORD, LPVOID);
#else
int __stdcall DllMain(void *, unsigned, void *);
int __stdcall _CRT_INIT(void *, unsigned, void *);
int __stdcall _wCRT_INIT(void *, unsigned, void *);
#endif	/* _WINDOWS_ */
#endif

#if	!__STDC__

/* Non-ANSI names for compatibility */

#define P_WAIT		_P_WAIT
#define P_NOWAIT	_P_NOWAIT
#define P_OVERLAY	_P_OVERLAY
#define OLD_P_OVERLAY	_OLD_P_OVERLAY
#define P_NOWAITO	_P_NOWAITO
#define P_DETACH	_P_DETACH

#define WAIT_CHILD	_WAIT_CHILD
#define WAIT_GRANDCHILD _WAIT_GRANDCHILD

#ifdef	_NTSDK
/* definitions compatible with NT SDK */
#define cwait	 _cwait
#define execl	 _execl
#define execle	 _execle
#define execlp	 _execlp
#define execlpe  _execlpe
#define execv	 _execv
#define execve	 _execve
#define execvp	 _execvp
#define execvpe  _execvpe
#define getpid	 _getpid
#define spawnl	 _spawnl
#define spawnle  _spawnle
#define spawnlp  _spawnlp
#define spawnlpe _spawnlpe
#define spawnv	 _spawnv
#define spawnve  _spawnve
#define spawnvp  _spawnvp
#define spawnvpe _spawnvpe
#else	/* ndef _NTSDK */
/* current declarations */
_CRTIMP int __cdecl cwait(int *, int, int);
_CRTIMP int __cdecl execl(const char *, const char *, ...);
_CRTIMP int __cdecl execle(const char *, const char *, ...);
_CRTIMP int __cdecl execlp(const char *, const char *, ...);
_CRTIMP int __cdecl execlpe(const char *, const char *, ...);
_CRTIMP int __cdecl execv(const char *, const char * const *);
_CRTIMP int __cdecl execve(const char *, const char * const *, const char * const *);
_CRTIMP int __cdecl execvp(const char *, const char * const *);
_CRTIMP int __cdecl execvpe(const char *, const char * const *, const char * const *);
_CRTIMP int __cdecl getpid(void);
_CRTIMP int __cdecl spawnl(int, const char *, const char *, ...);
_CRTIMP int __cdecl spawnle(int, const char *, const char *, ...);
_CRTIMP int __cdecl spawnlp(int, const char *, const char *, ...);
_CRTIMP int __cdecl spawnlpe(int, const char *, const char *, ...);
_CRTIMP int __cdecl spawnv(int, const char *, const char * const *);
_CRTIMP int __cdecl spawnve(int, const char *, const char * const *,
	const char * const *);
_CRTIMP int __cdecl spawnvp(int, const char *, const char * const *);
_CRTIMP int __cdecl spawnvpe(int, const char *, const char * const *,
	const char * const *);
#endif	/* _NTSDK */

#endif	/* __STDC__ */

#ifdef __cplusplus
}
#endif

#endif	/* _POSIX_ */

#endif	/* _INC_PROCESS */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\tools\c932\inc\rpcnsi.h ===
/*++

Copyright (c) 1992-1995 Microsoft Corporation

Module Name:

    rpcnsi.h

Abstract:

    This file contains the types and function definitions to use the
    Name Service Independent APIs.

--*/

#ifndef __RPCNSI_H__
#define __RPCNSI_H__

typedef void __RPC_FAR * RPC_NS_HANDLE;

#define RPC_C_NS_SYNTAX_DEFAULT 0
#define RPC_C_NS_SYNTAX_DCE 3

#define RPC_C_PROFILE_DEFAULT_ELT 0
#define RPC_C_PROFILE_ALL_ELT 1
#define RPC_C_PROFILE_MATCH_BY_IF 2
#define RPC_C_PROFILE_MATCH_BY_MBR 3
#define RPC_C_PROFILE_MATCH_BY_BOTH 4

#define RPC_C_NS_DEFAULT_EXP_AGE -1

/* Server APIs */

RPC_STATUS RPC_ENTRY
RpcNsBindingExportA(
    IN unsigned long EntryNameSyntax OPTIONAL,
    IN unsigned char __RPC_FAR * EntryName,
    IN RPC_IF_HANDLE IfSpec OPTIONAL,
    IN RPC_BINDING_VECTOR __RPC_FAR * BindingVec OPTIONAL,
    IN UUID_VECTOR __RPC_FAR * ObjectUuidVec OPTIONAL
    );


RPC_STATUS RPC_ENTRY
RpcNsBindingUnexportA(
    IN unsigned long EntryNameSyntax OPTIONAL,
    IN unsigned char __RPC_FAR * EntryName,
    IN RPC_IF_HANDLE IfSpec OPTIONAL,
    IN UUID_VECTOR __RPC_FAR * ObjectUuidVec OPTIONAL
    );

#ifdef RPC_UNICODE_SUPPORTED

RPC_STATUS RPC_ENTRY
RpcNsBindingExportW(
    IN unsigned long EntryNameSyntax OPTIONAL,
    IN unsigned short __RPC_FAR * EntryName,
    IN RPC_IF_HANDLE IfSpec OPTIONAL,
    IN RPC_BINDING_VECTOR __RPC_FAR * BindingVec OPTIONAL,
    IN UUID_VECTOR __RPC_FAR * ObjectUuidVec OPTIONAL
    );

RPC_STATUS RPC_ENTRY
RpcNsBindingUnexportW(
    IN unsigned long EntryNameSyntax OPTIONAL,
    IN unsigned short __RPC_FAR * EntryName,
    IN RPC_IF_HANDLE IfSpec OPTIONAL,
    IN UUID_VECTOR __RPC_FAR * ObjectUuidVec OPTIONAL
    );

#endif

/* Client APIs */

RPC_STATUS RPC_ENTRY
RpcNsBindingLookupBeginA(
    IN unsigned long EntryNameSyntax OPTIONAL,
    IN unsigned char __RPC_FAR * EntryName OPTIONAL,
    IN RPC_IF_HANDLE IfSpec OPTIONAL,
    IN UUID __RPC_FAR * ObjUuid OPTIONAL,
    IN unsigned long BindingMaxCount OPTIONAL,
    OUT RPC_NS_HANDLE __RPC_FAR * LookupContext
    );

#ifdef RPC_UNICODE_SUPPORTED

RPC_STATUS RPC_ENTRY
RpcNsBindingLookupBeginW(
    IN unsigned long EntryNameSyntax OPTIONAL,
    IN unsigned short __RPC_FAR * EntryName OPTIONAL,
    IN RPC_IF_HANDLE IfSpec OPTIONAL,
    IN UUID __RPC_FAR * ObjUuid OPTIONAL,
    IN unsigned long BindingMaxCount OPTIONAL,
    OUT RPC_NS_HANDLE __RPC_FAR * LookupContext
    );
#endif

RPC_STATUS RPC_ENTRY
RpcNsBindingLookupNext(
    IN  RPC_NS_HANDLE LookupContext,
    OUT RPC_BINDING_VECTOR __RPC_FAR * __RPC_FAR * BindingVec
    );

RPC_STATUS RPC_ENTRY
RpcNsBindingLookupDone(
    IN OUT RPC_NS_HANDLE __RPC_FAR * LookupContext
    );

/* Group APIs */

RPC_STATUS RPC_ENTRY
RpcNsGroupDeleteA(
    IN unsigned long GroupNameSyntax OPTIONAL,
    IN unsigned char __RPC_FAR * GroupName
    );

RPC_STATUS RPC_ENTRY
RpcNsGroupMbrAddA(
    IN unsigned long GroupNameSyntax OPTIONAL,
    IN unsigned char __RPC_FAR * GroupName,
    IN unsigned long MemberNameSyntax OPTIONAL,
    IN unsigned char __RPC_FAR * MemberName
    );

RPC_STATUS RPC_ENTRY
RpcNsGroupMbrRemoveA(
    IN unsigned long GroupNameSyntax OPTIONAL,
    IN unsigned char __RPC_FAR * GroupName,
    IN unsigned long MemberNameSyntax OPTIONAL,
    IN unsigned char __RPC_FAR * MemberName
    );

RPC_STATUS RPC_ENTRY
RpcNsGroupMbrInqBeginA(
    IN unsigned long GroupNameSyntax OPTIONAL,
    IN unsigned char __RPC_FAR * GroupName,
    IN unsigned long MemberNameSyntax OPTIONAL,
    OUT RPC_NS_HANDLE __RPC_FAR * InquiryContext
    );

RPC_STATUS RPC_ENTRY
RpcNsGroupMbrInqNextA(
    IN  RPC_NS_HANDLE InquiryContext,
    OUT unsigned char __RPC_FAR * __RPC_FAR * MemberName
    );

#ifdef RPC_UNICODE_SUPPORTED

RPC_STATUS RPC_ENTRY
RpcNsGroupDeleteW(
    IN unsigned long GroupNameSyntax OPTIONAL,
    IN unsigned short __RPC_FAR * GroupName
    );

RPC_STATUS RPC_ENTRY
RpcNsGroupMbrAddW(
    IN unsigned long GroupNameSyntax OPTIONAL,
    IN unsigned short __RPC_FAR * GroupName,
    IN unsigned long MemberNameSyntax OPTIONAL,
    IN unsigned short __RPC_FAR * MemberName
    );

RPC_STATUS RPC_ENTRY
RpcNsGroupMbrRemoveW(
    IN unsigned long GroupNameSyntax OPTIONAL,
    IN unsigned short __RPC_FAR * GroupName,
    IN unsigned long MemberNameSyntax OPTIONAL,
    IN unsigned short __RPC_FAR * MemberName
    );

RPC_STATUS RPC_ENTRY
RpcNsGroupMbrInqBeginW(
    IN unsigned long GroupNameSyntax OPTIONAL,
    IN unsigned short __RPC_FAR * GroupName,
    IN unsigned long MemberNameSyntax OPTIONAL,
    OUT RPC_NS_HANDLE __RPC_FAR * InquiryContext
    );

RPC_STATUS RPC_ENTRY
RpcNsGroupMbrInqNextW(
    IN  RPC_NS_HANDLE InquiryContext,
    OUT unsigned short __RPC_FAR * __RPC_FAR * MemberName
    );

#endif

RPC_STATUS RPC_ENTRY
RpcNsGroupMbrInqDone(
    IN OUT RPC_NS_HANDLE __RPC_FAR * InquiryContext
    );

/* Profile APIs */

RPC_STATUS RPC_ENTRY
RpcNsProfileDeleteA(
    IN unsigned long ProfileNameSyntax OPTIONAL,
    IN unsigned char __RPC_FAR * ProfileName
    );

RPC_STATUS RPC_ENTRY
RpcNsProfileEltAddA(
    IN unsigned long ProfileNameSyntax OPTIONAL,
    IN unsigned char __RPC_FAR * ProfileName,
    IN RPC_IF_ID __RPC_FAR * IfId OPTIONAL,
    IN unsigned long MemberNameSyntax OPTIONAL,
    IN unsigned char __RPC_FAR * MemberName,
    IN unsigned long Priority,
    IN unsigned char __RPC_FAR * Annotation OPTIONAL
    );

RPC_STATUS RPC_ENTRY
RpcNsProfileEltRemoveA(
    IN unsigned long ProfileNameSyntax OPTIONAL,
    IN unsigned char __RPC_FAR * ProfileName,
    IN RPC_IF_ID __RPC_FAR * IfId OPTIONAL,
    IN unsigned long MemberNameSyntax OPTIONAL,
    IN unsigned char __RPC_FAR * MemberName
    );

RPC_STATUS RPC_ENTRY
RpcNsProfileEltInqBeginA(
    IN unsigned long ProfileNameSyntax OPTIONAL,
    IN unsigned char __RPC_FAR * ProfileName,
    IN unsigned long InquiryType,
    IN RPC_IF_ID __RPC_FAR * IfId OPTIONAL,
    IN unsigned long VersOption,
    IN unsigned long MemberNameSyntax OPTIONAL,
    IN unsigned char __RPC_FAR * MemberName OPTIONAL,
    OUT RPC_NS_HANDLE __RPC_FAR * InquiryContext
    );

RPC_STATUS RPC_ENTRY
RpcNsProfileEltInqNextA(
    IN RPC_NS_HANDLE InquiryContext,
    OUT RPC_IF_ID __RPC_FAR * IfId,
    OUT unsigned char __RPC_FAR * __RPC_FAR * MemberName,
    OUT unsigned long __RPC_FAR * Priority,
    OUT unsigned char __RPC_FAR * __RPC_FAR * Annotation
    );

#ifdef RPC_UNICODE_SUPPORTED

RPC_STATUS RPC_ENTRY
RpcNsProfileDeleteW(
    IN unsigned long ProfileNameSyntax OPTIONAL,
    IN unsigned short __RPC_FAR * ProfileName
    );

RPC_STATUS RPC_ENTRY
RpcNsProfileEltAddW(
    IN unsigned long ProfileNameSyntax OPTIONAL,
    IN unsigned short __RPC_FAR * ProfileName,
    IN RPC_IF_ID __RPC_FAR * IfId OPTIONAL,
    IN unsigned long MemberNameSyntax OPTIONAL,
    IN unsigned short __RPC_FAR * MemberName,
    IN unsigned long Priority,
    IN unsigned short __RPC_FAR * Annotation OPTIONAL
    );

RPC_STATUS RPC_ENTRY
RpcNsProfileEltRemoveW(
    IN unsigned long ProfileNameSyntax OPTIONAL,
    IN unsigned short __RPC_FAR * ProfileName,
    IN RPC_IF_ID __RPC_FAR * IfId OPTIONAL,
    IN unsigned long MemberNameSyntax OPTIONAL,
    IN unsigned short __RPC_FAR * MemberName
    );

RPC_STATUS RPC_ENTRY
RpcNsProfileEltInqBeginW(
    IN unsigned long ProfileNameSyntax OPTIONAL,
    IN unsigned short __RPC_FAR * ProfileName,
    IN unsigned long InquiryType,
    IN RPC_IF_ID __RPC_FAR * IfId OPTIONAL,
    IN unsigned long VersOption,
    IN unsigned long MemberNameSyntax OPTIONAL,
    IN unsigned short __RPC_FAR * MemberName OPTIONAL,
    OUT RPC_NS_HANDLE __RPC_FAR * InquiryContext
    );

RPC_STATUS RPC_ENTRY
RpcNsProfileEltInqNextW(
    IN RPC_NS_HANDLE InquiryContext,
    OUT RPC_IF_ID __RPC_FAR * IfId,
    OUT unsigned short __RPC_FAR * __RPC_FAR * MemberName,
    OUT unsigned long __RPC_FAR * Priority,
    OUT unsigned short __RPC_FAR * __RPC_FAR * Annotation
    );

#endif

RPC_STATUS RPC_ENTRY
RpcNsProfileEltInqDone(
    IN OUT RPC_NS_HANDLE __RPC_FAR * InquiryContext
    );

/* Entry object APIs */

RPC_STATUS RPC_ENTRY
RpcNsEntryObjectInqBeginA(
    IN unsigned long EntryNameSyntax OPTIONAL,
    IN unsigned char __RPC_FAR * EntryName,
    OUT RPC_NS_HANDLE __RPC_FAR * InquiryContext
    );

#ifdef RPC_UNICODE_SUPPORTED

RPC_STATUS RPC_ENTRY
RpcNsEntryObjectInqBeginW(
    IN unsigned long EntryNameSyntax OPTIONAL,
    IN unsigned short __RPC_FAR * EntryName,
    OUT RPC_NS_HANDLE __RPC_FAR * InquiryContext
    );

#endif

RPC_STATUS RPC_ENTRY
RpcNsEntryObjectInqNext(
    IN  RPC_NS_HANDLE InquiryContext,
    OUT UUID __RPC_FAR * ObjUuid
    );

RPC_STATUS RPC_ENTRY
RpcNsEntryObjectInqDone(
    IN OUT RPC_NS_HANDLE __RPC_FAR * InquiryContext
    );

/* Management and MISC APIs */

RPC_STATUS RPC_ENTRY
RpcNsEntryExpandNameA(
    IN unsigned long EntryNameSyntax OPTIONAL,
    IN unsigned char __RPC_FAR * EntryName,
    OUT unsigned char __RPC_FAR * __RPC_FAR * ExpandedName
    );

RPC_STATUS RPC_ENTRY
RpcNsMgmtBindingUnexportA(
    IN unsigned long EntryNameSyntax OPTIONAL,
    IN unsigned char __RPC_FAR * EntryName,
    IN RPC_IF_ID __RPC_FAR * IfId OPTIONAL,
    IN unsigned long VersOption,
    IN UUID_VECTOR __RPC_FAR * ObjectUuidVec OPTIONAL
    );

RPC_STATUS RPC_ENTRY
RpcNsMgmtEntryCreateA(
    IN unsigned long EntryNameSyntax OPTIONAL,
    IN unsigned char __RPC_FAR * EntryName
    );

RPC_STATUS RPC_ENTRY
RpcNsMgmtEntryDeleteA(
    IN unsigned long EntryNameSyntax OPTIONAL,
    IN unsigned char __RPC_FAR * EntryName
    );

RPC_STATUS RPC_ENTRY
RpcNsMgmtEntryInqIfIdsA(
    IN unsigned long EntryNameSyntax OPTIONAL,
    IN unsigned char __RPC_FAR * EntryName,
    OUT RPC_IF_ID_VECTOR __RPC_FAR * __RPC_FAR * IfIdVec
    );

RPC_STATUS RPC_ENTRY
RpcNsMgmtHandleSetExpAge(
    IN RPC_NS_HANDLE NsHandle,
    IN unsigned long ExpirationAge
    );

RPC_STATUS RPC_ENTRY
RpcNsMgmtInqExpAge(
    OUT unsigned long __RPC_FAR * ExpirationAge
    );

RPC_STATUS RPC_ENTRY
RpcNsMgmtSetExpAge(
    IN unsigned long ExpirationAge
    );

#ifdef RPC_UNICODE_SUPPORTED

RPC_STATUS RPC_ENTRY
RpcNsEntryExpandNameW(
    IN unsigned long EntryNameSyntax OPTIONAL,
    IN unsigned short __RPC_FAR * EntryName,
    OUT unsigned short __RPC_FAR * __RPC_FAR * ExpandedName
    );

RPC_STATUS RPC_ENTRY
RpcNsMgmtBindingUnexportW(
    IN unsigned long EntryNameSyntax OPTIONAL,
    IN unsigned short __RPC_FAR * EntryName,
    IN RPC_IF_ID __RPC_FAR * IfId OPTIONAL,
    IN unsigned long VersOption,
    IN UUID_VECTOR __RPC_FAR * ObjectUuidVec OPTIONAL
    );

RPC_STATUS RPC_ENTRY
RpcNsMgmtEntryCreateW(
    IN unsigned long EntryNameSyntax OPTIONAL,
    IN unsigned short __RPC_FAR * EntryName
    );

RPC_STATUS RPC_ENTRY
RpcNsMgmtEntryDeleteW(
    IN unsigned long EntryNameSyntax OPTIONAL,
    IN unsigned short __RPC_FAR * EntryName
    );

RPC_STATUS RPC_ENTRY
RpcNsMgmtEntryInqIfIdsW(
    IN unsigned long EntryNameSyntax OPTIONAL,
    IN unsigned short __RPC_FAR * EntryName,
    OUT RPC_IF_ID_VECTOR __RPC_FAR * __RPC_FAR * IfIdVec
    );

#endif

/* Client API's implemented in wrappers. */

RPC_STATUS RPC_ENTRY
RpcNsBindingImportBeginA(
    IN unsigned long EntryNameSyntax OPTIONAL,
    IN unsigned char __RPC_FAR * EntryName OPTIONAL,
    IN RPC_IF_HANDLE IfSpec OPTIONAL,
    IN UUID __RPC_FAR * ObjUuid OPTIONAL,
    OUT RPC_NS_HANDLE __RPC_FAR * ImportContext
    );

#ifdef RPC_UNICODE_SUPPORTED

RPC_STATUS RPC_ENTRY
RpcNsBindingImportBeginW(
    IN unsigned long EntryNameSyntax OPTIONAL,
    IN unsigned short __RPC_FAR * EntryName OPTIONAL,
    IN RPC_IF_HANDLE IfSpec OPTIONAL,
    IN UUID __RPC_FAR * ObjUuid OPTIONAL,
    OUT RPC_NS_HANDLE __RPC_FAR * ImportContext
    );

#endif

RPC_STATUS RPC_ENTRY
RpcNsBindingImportNext(
    IN RPC_NS_HANDLE ImportContext,
    OUT RPC_BINDING_HANDLE  __RPC_FAR * Binding
    );

RPC_STATUS RPC_ENTRY
RpcNsBindingImportDone(
    IN OUT RPC_NS_HANDLE __RPC_FAR * ImportContext
    );

RPC_STATUS RPC_ENTRY
RpcNsBindingSelect(
    IN OUT RPC_BINDING_VECTOR __RPC_FAR * BindingVec,
    OUT RPC_BINDING_HANDLE  __RPC_FAR * Binding
    );

#ifdef UNICODE

#define RpcNsBindingLookupBegin RpcNsBindingLookupBeginW
#define RpcNsBindingImportBegin RpcNsBindingImportBeginW
#define RpcNsBindingExport RpcNsBindingExportW
#define RpcNsBindingUnexport RpcNsBindingUnexportW
#define RpcNsGroupDelete RpcNsGroupDeleteW
#define RpcNsGroupMbrAdd RpcNsGroupMbrAddW
#define RpcNsGroupMbrRemove RpcNsGroupMbrRemoveW
#define RpcNsGroupMbrInqBegin RpcNsGroupMbrInqBeginW
#define RpcNsGroupMbrInqNext RpcNsGroupMbrInqNextW
#define RpcNsEntryExpandName RpcNsEntryExpandNameW
#define RpcNsEntryObjectInqBegin RpcNsEntryObjectInqBeginW
#define RpcNsMgmtBindingUnexport RpcNsMgmtBindingUnexportW
#define RpcNsMgmtEntryCreate RpcNsMgmtEntryCreateW
#define RpcNsMgmtEntryDelete RpcNsMgmtEntryDeleteW
#define RpcNsMgmtEntryInqIfIds RpcNsMgmtEntryInqIfIdsW
#define RpcNsProfileDelete RpcNsProfileDeleteW
#define RpcNsProfileEltAdd RpcNsProfileEltAddW
#define RpcNsProfileEltRemove RpcNsProfileEltRemoveW
#define RpcNsProfileEltInqBegin RpcNsProfileEltInqBeginW
#define RpcNsProfileEltInqNext RpcNsProfileEltInqNextW

#else

#define RpcNsBindingLookupBegin RpcNsBindingLookupBeginA
#define RpcNsBindingImportBegin RpcNsBindingImportBeginA
#define RpcNsBindingExport RpcNsBindingExportA
#define RpcNsBindingUnexport RpcNsBindingUnexportA
#define RpcNsGroupDelete RpcNsGroupDeleteA
#define RpcNsGroupMbrAdd RpcNsGroupMbrAddA
#define RpcNsGroupMbrRemove RpcNsGroupMbrRemoveA
#define RpcNsGroupMbrInqBegin RpcNsGroupMbrInqBeginA
#define RpcNsGroupMbrInqNext RpcNsGroupMbrInqNextA
#define RpcNsEntryExpandName RpcNsEntryExpandNameA
#define RpcNsEntryObjectInqBegin RpcNsEntryObjectInqBeginA
#define RpcNsMgmtBindingUnexport RpcNsMgmtBindingUnexportA
#define RpcNsMgmtEntryCreate RpcNsMgmtEntryCreateA
#define RpcNsMgmtEntryDelete RpcNsMgmtEntryDeleteA
#define RpcNsMgmtEntryInqIfIds RpcNsMgmtEntryInqIfIdsA
#define RpcNsProfileDelete RpcNsProfileDeleteA
#define RpcNsProfileEltAdd RpcNsProfileEltAddA
#define RpcNsProfileEltRemove RpcNsProfileEltRemoveA
#define RpcNsProfileEltInqBegin RpcNsProfileEltInqBeginA
#define RpcNsProfileEltInqNext RpcNsProfileEltInqNextA

#endif /* UNICODE */

#endif /* __RPCNSI_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\tools\c932\inc\setjmp.h ===
/***
*setjmp.h - definitions/declarations for setjmp/longjmp routines
*
*	Copyright (c) 1985-1994, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	This file defines the machine-dependent buffer used by
*	setjmp/longjmp to save and restore the program state, and
*	declarations for those routines.
*	[ANSI/System V]
*
****/

#ifndef _INC_SETJMP
#define _INC_SETJMP

#ifdef	__cplusplus
extern "C" {
#endif


/* Define _CRTAPI1 (for compatibility with the NT SDK) */

#ifndef _CRTAPI1
#if	( (_MSC_VER >= 800) && (_M_IX86 >= 300) )
#define _CRTAPI1 __cdecl
#else
#define _CRTAPI1
#endif
#endif


/* Define _CRTAPI2 (for compatibility with the NT SDK) */

#ifndef _CRTAPI2
#if	( (_MSC_VER >= 800) && (_M_IX86 >= 300) )
#define _CRTAPI2 __cdecl
#else
#define _CRTAPI2
#endif
#endif


/* Define _CRTIMP */

#ifndef _CRTIMP
#ifdef	_NTSDK
/* definition compatible with NT SDK */
#define _CRTIMP
#else	/* ndef _NTSDK */
/* current definition */
#ifdef	_DLL
#define _CRTIMP __declspec(dllimport)
#else	/* ndef _DLL */
#define _CRTIMP
#endif	/* _DLL */
#endif	/* _NTSDK */
#endif	/* _CRTIMP */


/* Define __cdecl for non-Microsoft compilers */

#if	( !defined(_MSC_VER) && !defined(__cdecl) )
#define __cdecl
#endif


/*
 * Definitions specific to particular setjmp implementations.
 */

#if	defined(_M_IX86)

/*
 * MS compiler for x86
 */

#ifndef _INC_SETJMPEX
#define setjmp	_setjmp
#endif

#define _JBLEN	16
#define _JBTYPE int

/*
 * Define jump buffer layout for x86 setjmp/longjmp.
 */
typedef struct __JUMP_BUFFER {
    unsigned long Ebp;
    unsigned long Ebx;
    unsigned long Edi;
    unsigned long Esi;
    unsigned long Esp;
    unsigned long Eip;
    unsigned long Registration;
    unsigned long TryLevel;
    unsigned long Cookie;
    unsigned long UnwindFunc;
    unsigned long UnwindData[6];
} _JUMP_BUFFER;


#elif	defined(_M_MRX000)

/*
 * All MIPS implementations need _JBLEN of 16
 */
#define _JBLEN  16
#define _JBTYPE double

/*
 * Define jump buffer layout for MIPS setjmp/longjmp.
 */
typedef struct __JUMP_BUFFER {
    unsigned long FltF20;
    unsigned long FltF21;
    unsigned long FltF22;
    unsigned long FltF23;
    unsigned long FltF24;
    unsigned long FltF25;
    unsigned long FltF26;
    unsigned long FltF27;
    unsigned long FltF28;
    unsigned long FltF29;
    unsigned long FltF30;
    unsigned long FltF31;
    unsigned long IntS0;
    unsigned long IntS1;
    unsigned long IntS2;
    unsigned long IntS3;
    unsigned long IntS4;
    unsigned long IntS5;
    unsigned long IntS6;
    unsigned long IntS7;
    unsigned long IntS8;
    unsigned long IntSp;
    unsigned long Type;
    unsigned long Fir;
} _JUMP_BUFFER;


#elif	defined(_M_ALPHA)

/*
 * The Alpha C8/GEM C compiler uses an intrinsic _setjmp.
 * The Alpha acc compiler implements setjmp as a function.
 */
#ifdef	_MSC_VER
#ifndef _INC_SETJMPEX
#define setjmp	_setjmp
#endif
#endif

/*
 * Alpha implementations use a _JBLEN of 24 quadwords.
 * A double is used only to obtain quadword size and alignment.
 */
#define _JBLEN  24
#define _JBTYPE double

/* 
 * Define jump buffer layout for Alpha setjmp/longjmp.
 * A double is used only to obtain quadword size and alignment.
 */
typedef struct __JUMP_BUFFER {
    unsigned long Fp;
    unsigned long Pc;
    unsigned long Seb;
    unsigned long Type;
    double FltF2;
    double FltF3;
    double FltF4;
    double FltF5;
    double FltF6;
    double FltF7;
    double FltF8;
    double FltF9;
    double IntS0;
    double IntS1;
    double IntS2;
    double IntS3;
    double IntS4;
    double IntS5;
    double IntS6;
    double IntSp;
    double Fir;
    double Fill[5];
} _JUMP_BUFFER;


#endif


/* Define the buffer type for holding the state information */

#ifndef _JMP_BUF_DEFINED
typedef _JBTYPE jmp_buf[_JBLEN];
#define _JMP_BUF_DEFINED
#endif


/* Function prototypes */

int __cdecl setjmp(jmp_buf);
_CRTIMP void __cdecl longjmp(jmp_buf, int);

#ifdef	__cplusplus
}
#endif

#endif	/* _INC_SETJMP */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\tools\c932\inc\scrnsave.h ===
/*****************************************************************************\
*                                                                             *
* scrnsave.h    Windows NT 3.1 screensaver defines and definitions.           *
*                                                                             *
*               Version 1.0                                                   *
*                                                                             *
*               NOTE: windows.h must be #included first                       *
*                                                                             *
*  Windows NT NOTE:   (Differences from Win 3.1 Screensavers)                 *
*                                                                             *
*               All Screensavers are required to have a Description string    *
*               of no more than 25 chars for display by the Control Panel's   *
*               Desktop applet.  This is string 1 in the resource string      *
*               table of the Windows 32-bit screen saver .SCR (.EXE) file.    *
*                                                                             *
*               Passwords for Windows NT Screen Savers are handled by the     *
*               Winlogon process.  If the registry value:                     *
*                                                                             *
*               HKEY_CURRENT_USER\Control Panel\Desktop\ScreenSaverIsSecure   *
*                                                                             *
*               is nonzero, Winlogon will ask for the User's login password   *
*               before allowing the Screen Saver to exit.  All password data  *
*               and dialogs have been removed from individual Screensavers.   *
*                                                                             *
*                                                                             *
*               Copyright (c) 1992, Microsoft Corp.  All rights reserved.     *
*                                                                             *
\*****************************************************************************/

#ifndef _INC_SCRNSAVE
#define _INC_SCRNSAVE

#ifndef RC_INVOKED
#pragma pack(1)         /* Assume byte packing throughout */
#endif /* !RC_INVOKED */

#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif	/* __cplusplus */


/* MANDATORY string required in .RC file 
 * This string should contain a less than 25 char name/description of the
 * screen saver.  This string is what will be seen by the user in the Control
 * Panel's Desktop applet screen saver listbox.
 */

#define IDS_DESCRIPTION      1

/* Icon resource ID.
 *
 * This should be the first icon used and must have this resource number.
 * This is needed as the first icon in the file will be grabbed
 */
#define ID_APP      100
#define DLG_SCRNSAVECONFIGURE   2003

#define idsIsPassword           1000
#define idsIniFile              1001
#define idsScreenSaver          1002
#define idsPassword             1003
#define idsDifferentPW          1004
#define idsChangePW             1005
#define idsBadOldPW             1006
#define idsAppName              1007
#define idsNoHelpMemory         1008
#define idsHelpFile             1009

/* This function is the Window Procedure for the screen saver.  It is
 * up to the programmer to handle any of the messages that wish to be
 * interpretted.  Any unused messages are then passed back to
 * DefScreenSaverProc if desired which will take default action on any
 * unprocessed message...
 */
LRESULT WINAPI ScreenSaverProc (HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam);

/* This function performs default message processing.  Currently handles
 * the following messages:
 *
 * WM_SYSCOMMAND:   return FALSE if wParam is SC_SCREENSAVE or SC_CLOSE
 *
 * WM_DESTROY:      PostQuitMessage(0)
 *
 * WM_SETCURSOR:    By default, this will set the cursor to a null cursor,
 *                  thereby removing it from the screen.
 *
 * WM_LBUTTONDOWN:
 * WM_MBUTTONDOWN:
 * WM_RBUTTONDOWN:
 * WM_KEYDOWN:
 * WM_KEYUP:
 * WM_MOUSEMOVE:    By default, these will cause the program to terminate.
 *                  Unless the password option is enabled.  In that case
 *                  the DlgGetPassword() dialog box is brought up.
 *
 * WM_NCACTIVATE:
 * WM_ACTIVATEAPP:
 * WM_ACTIVATE:     By default, if the wParam parameter is FALSE (signifying
 *                  that transfer is being taken away from the application),
 *                  then the program will terminate.  Termination is
 *                  accomplished by generating a WM_CLOSE message.  This way,
 *                  if the user sets something up in the WM_CREATE, a
 *                  WM_DESTROY will be generated and it can be destroyed
 *                  properly.
 *                  This message is ignored, however is the password option
 *                  is enabled.
 */
LRESULT WINAPI DefScreenSaverProc (HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam);

/* A function is also needed for configuring the screen saver.  The function
 * should be exactly like it is below and must be exported such that the
 * program can use MAKEPROCINSTANCE on it and call up a dialog box. Further-
 * more, the template used for the dialog must be called
 * ScreenSaverConfigure to allow the main function to access it...
 */
BOOL WINAPI ScreenSaverConfigureDialog (HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);

/* To allow the programmer the ability to register child control windows, this
 * function is called prior to the creation of the dialog box.  Any
 * registering that is required should be done here, or return TRUE if none
 * is needed...
 */
BOOL WINAPI RegisterDialogClasses (HANDLE hInst);

/* The following functions are called by DefScreenSaverProc and must
 * be exported by all screensavers using this model.
 */

/*
 * There are only three other points that should be of notice:
 * 1) The screen saver must have a string declared as 'szAppName' contaning the
 *     name of the screen saver, and it must be declared as a global.
 * 2) The screen saver EXE file should be renamed to a file with a SCR
 *     extension so that the screen saver dialog from the control panel can
 *     find it when is searches for screen savers.
 */
#define WS_GT   (WS_GROUP | WS_TABSTOP)

#define MAXFILELEN         13
#define TITLEBARNAMELEN    40
#define APPNAMEBUFFERLEN   40
#define BUFFLEN           255

/* The following globals are defined in scrnsave.lib */
extern HANDLE hMainInstance;
extern HWND   hMainWindow;
extern TCHAR  szName[TITLEBARNAMELEN];
extern TCHAR  szAppName[APPNAMEBUFFERLEN];
extern TCHAR  szIniFile[MAXFILELEN];
extern TCHAR  szScreenSaver[22];
extern TCHAR  szHelpFile[MAXFILELEN];
extern TCHAR  szNoHelpMemory[BUFFLEN];
extern UINT   MyHelpMessage;

#ifdef __cplusplus
}
#endif	/* __cplusplus */

#ifndef RC_INVOKED
#pragma pack()
#endif  /* !RC_INVOKED */

#endif  /* !_INC_SCRNSAVE */

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\tools\c932\inc\search.h ===
/***
*search.h - declarations for searcing/sorting routines
*
*	Copyright (c) 1985-1994, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	This file contains the declarations for the sorting and
*	searching routines.
*	[System V]
*
****/

#ifndef _INC_SEARCH
#define _INC_SEARCH

#ifdef __cplusplus
extern "C" {
#endif


/* Define _CRTAPI1 (for compatibility with the NT SDK) */

#ifndef _CRTAPI1
#if	( (_MSC_VER >= 800) && (_M_IX86 >= 300) )
#define _CRTAPI1 __cdecl
#else
#define _CRTAPI1
#endif
#endif


/* Define _CRTAPI2 (for compatibility with the NT SDK) */

#ifndef _CRTAPI2
#if	( (_MSC_VER >= 800) && (_M_IX86 >= 300) )
#define _CRTAPI2 __cdecl
#else
#define _CRTAPI2
#endif
#endif


/* Define _CRTIMP */

#ifndef _CRTIMP
#ifdef	_NTSDK
/* definition compatible with NT SDK */
#define _CRTIMP
#else	/* ndef _NTSDK */
/* current definition */
#ifdef	_DLL
#define _CRTIMP __declspec(dllimport)
#else	/* ndef _DLL */
#define _CRTIMP
#endif	/* _DLL */
#endif	/* _NTSDK */
#endif	/* _CRTIMP */


/* Define __cdecl for non-Microsoft compilers */

#if	( !defined(_MSC_VER) && !defined(__cdecl) )
#define __cdecl
#endif


#ifndef _SIZE_T_DEFINED
typedef unsigned int size_t;
#define _SIZE_T_DEFINED
#endif


/* Function prototypes */

_CRTIMP void * __cdecl bsearch(const void *, const void *, size_t, size_t,
	int (__cdecl *)(const void *, const void *));
_CRTIMP void * __cdecl _lfind(const void *, const void *, unsigned int *, unsigned int,
	int (__cdecl *)(const void *, const void *));
_CRTIMP void * __cdecl _lsearch(const void *, void  *, unsigned int *, unsigned int,
	int (__cdecl *)(const void *, const void *));
_CRTIMP void __cdecl qsort(void *, size_t, size_t, int (__cdecl *)(const void *,
	const void *));


#if	!__STDC__
/* Non-ANSI names for compatibility */
#ifdef	_NTSDK
/* definitions compatible with NT SDK */
#define lfind	_lfind
#define lsearch _lsearch
#else	/* ndef _NTSDK */
/* current declarations */
_CRTIMP void * __cdecl lfind(const void *, const void *, unsigned int *, unsigned int,
	int (__cdecl *)(const void *, const void *));
_CRTIMP void * __cdecl lsearch(const void *, void  *, unsigned int *, unsigned int,
	int (__cdecl *)(const void *, const void *));
#endif	/* _NTSDK */
#endif	/* __STDC__ */


#ifdef __cplusplus
}
#endif

#endif	/* _INC_SEARCH */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\tools\c932\inc\signal.h ===
/***
*signal.h - defines signal values and routines
*
*	Copyright (c) 1985-1994, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	This file defines the signal values and declares the signal functions.
*	[ANSI/System V]
*
****/

#ifndef _INC_SIGNAL
#define _INC_SIGNAL

#ifdef __cplusplus
extern "C" {
#endif


/* Define _CRTAPI1 (for compatibility with the NT SDK) */

#ifndef _CRTAPI1
#if	( (_MSC_VER >= 800) && (_M_IX86 >= 300) )
#define _CRTAPI1 __cdecl
#else
#define _CRTAPI1
#endif
#endif


/* Define _CRTAPI2 (for compatibility with the NT SDK) */

#ifndef _CRTAPI2
#if	( (_MSC_VER >= 800) && (_M_IX86 >= 300) )
#define _CRTAPI2 __cdecl
#else
#define _CRTAPI2
#endif
#endif


/* Define _CRTIMP */

#ifndef _CRTIMP
#ifdef	_NTSDK
/* definition compatible with NT SDK */
#define _CRTIMP
#else	/* ndef _NTSDK */
/* current definition */
#ifdef	_DLL
#define _CRTIMP __declspec(dllimport)
#else	/* ndef _DLL */
#define _CRTIMP
#endif	/* _DLL */
#endif	/* _NTSDK */
#endif	/* _CRTIMP */


/* Define __cdecl for non-Microsoft compilers */

#if	( !defined(_MSC_VER) && !defined(__cdecl) )
#define __cdecl
#endif


#ifndef _SIG_ATOMIC_T_DEFINED
typedef int sig_atomic_t;
#define _SIG_ATOMIC_T_DEFINED
#endif


#define NSIG 23     /* maximum signal number + 1 */


/* Signal types */

#define SIGINT		2	/* interrupt */
#define SIGILL		4	/* illegal instruction - invalid function image */
#define SIGFPE		8	/* floating point exception */
#define SIGSEGV 	11	/* segment violation */
#define SIGTERM 	15	/* Software termination signal from kill */
#define SIGBREAK	21	/* Ctrl-Break sequence */
#define SIGABRT 	22	/* abnormal termination triggered by abort call */


/* signal action codes */

#define SIG_DFL (void (__cdecl *)(int))0	   /* default signal action */
#define SIG_IGN (void (__cdecl *)(int))1	   /* ignore signal */
#define SIG_SGE (void (__cdecl *)(int))3	   /* signal gets error */
#define SIG_ACK (void (__cdecl *)(int))4	   /* acknowledge */


/* signal error value (returned by signal call on error) */

#define SIG_ERR (void (__cdecl *)(int))-1	   /* signal error value */


/* pointer to exception information pointers structure */

#ifdef	_MT
extern void * * __cdecl __pxcptinfoptrs(void);
#define _pxcptinfoptrs	(*__pxcptinfoptrs())
#else
extern void * _pxcptinfoptrs;
#endif


/* Function prototypes */

_CRTIMP void (__cdecl * __cdecl signal(int, void (__cdecl *)(int)))(int);
_CRTIMP int __cdecl raise(int);


#ifdef __cplusplus
}
#endif

#endif	/* _INC_SIGNAL */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\tools\c932\inc\share.h ===
/***
*share.h - defines file sharing modes for sopen
*
*	Copyright (c) 1985-1994, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	This file defines the file sharing modes for sopen().
*
****/

#ifndef _INC_SHARE
#define _INC_SHARE

#define _SH_DENYRW	0x10	/* deny read/write mode */
#define _SH_DENYWR	0x20	/* deny write mode */
#define _SH_DENYRD	0x30	/* deny read mode */
#define _SH_DENYNO	0x40	/* deny none mode */

#if !__STDC__
/* Non-ANSI names for compatibility */
#define SH_DENYRW _SH_DENYRW
#define SH_DENYWR _SH_DENYWR
#define SH_DENYRD _SH_DENYRD
#define SH_DENYNO _SH_DENYNO
#endif

#endif	/* _INC_SHARE */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\tools\c932\inc\stdarg.h ===
/***
*stdarg.h - defines ANSI-style macros for variable argument functions
*
*	Copyright (c) 1985-1994, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	This file defines ANSI-style macros for accessing arguments
*	of functions which take a variable number of arguments.
*	[ANSI]
*
****/

#ifndef _INC_STDARG
#define _INC_STDARG

#ifdef __cplusplus
extern "C" {
#endif



#ifndef _VA_LIST_DEFINED
#ifdef	_M_ALPHA
typedef struct {
	char *a0;	/* pointer to first homed integer argument */
	int offset;	/* byte offset of next parameter */
} va_list;
#else
typedef char *	va_list;
#endif
#define _VA_LIST_DEFINED
#endif

#ifdef	_M_IX86


#define _INTSIZEOF(n)	( (sizeof(n) + sizeof(int) - 1) & ~(sizeof(int) - 1) ) 

#define va_start(ap,v)	( ap = (va_list)&v + _INTSIZEOF(v) )
#define va_arg(ap,t)	( *(t *)((ap += _INTSIZEOF(t)) - _INTSIZEOF(t)) )
#define va_end(ap)	( ap = (va_list)0 )


#elif	defined(_M_MRX000)


/* Use these types and definitions if generating code for MIPS */

#define va_start(ap,v) ap  = (va_list)&v + sizeof(v)
#define va_end(list)
#define va_arg(list, mode) ((mode *)(list =\
 (char *) ((((int)list + (__builtin_alignof(mode)<=4?3:7)) &\
 (__builtin_alignof(mode)<=4?-4:-8))+sizeof(mode))))[-1]

/*  +++++++++++++++++++++++++++++++++++++++++++
    Because of parameter passing conventions in C:
    use mode=int for char, and short types
    use mode=double for float types
    use a pointer for array types
    +++++++++++++++++++++++++++++++++++++++++++ */


#elif	defined(_M_ALPHA)


/* Use these types and definitions if generating code for ALPHA */

/*
 * The Alpha compiler supports two builtin functions that are used to
 * implement stdarg/varargs.  The __builtin_va_start function is used
 * by va_start to initialize the data structure that locates the next
 * argument.  The __builtin_isfloat function is used by va_arg to pick
 * which part of the home area a given register argument is stored in.
 * The home area is where up to six integer and/or six floating point
 * register arguments are stored down (so they can also be referenced
 * by a pointer like any arguments passed on the stack).
 */

extern void * __builtin_va_start(va_list, ...);

#ifdef	_CFRONT
#define __builtin_isfloat(a) __builtin_alignof(a)
#endif

#define va_start(list, v) __builtin_va_start(list, v, 1)
#define va_end(list)
#define va_arg(list, mode) \
    ( *(        ((list).offset += ((int)sizeof(mode) + 7) & -8) , \
        (mode *)((list).a0 + (list).offset - \
                    ((__builtin_isfloat(mode) && (list).offset <= (6 * 8)) ? \
                        (6 * 8) + 8 : ((int)sizeof(mode) + 7) & -8) \
                ) \
       ) \
    )


#else


/* A guess at the proper definitions for other platforms */

#define _INTSIZEOF(n)	( (sizeof(n) + sizeof(int) - 1) & ~(sizeof(int) - 1) )

#define va_start(ap,v)	( ap = (va_list)&v + _INTSIZEOF(v) )
#define va_arg(ap,t)	( *(t *)((ap += _INTSIZEOF(t)) - _INTSIZEOF(t)) )
#define va_end(ap)	( ap = (va_list)0 )


#endif


#ifdef __cplusplus
}
#endif

#endif	/* _INC_STDARG */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\tools\c932\inc\stddef.h ===
/***
*stddef.h - definitions/declarations for common constants, types, variables
*
*	Copyright (c) 1985-1994, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	This file contains definitions and declarations for some commonly
*	used constants, types, and variables.
*	[ANSI]
*
****/

#ifndef _INC_STDDEF
#define _INC_STDDEF

#ifdef __cplusplus
extern "C" {
#endif


/* Define _CRTAPI1 (for compatibility with the NT SDK) */

#ifndef _CRTAPI1
#if	( (_MSC_VER >= 800) && (_M_IX86 >= 300) )
#define _CRTAPI1 __cdecl
#else
#define _CRTAPI1
#endif
#endif


/* Define _CRTAPI2 (for compatibility with the NT SDK) */

#ifndef _CRTAPI2
#if	( (_MSC_VER >= 800) && (_M_IX86 >= 300) )
#define _CRTAPI2 __cdecl
#else
#define _CRTAPI2
#endif
#endif


/* Define _CRTIMP */

#ifndef _CRTIMP
#ifdef	_NTSDK
/* definition compatible with NT SDK */
#define _CRTIMP
#else	/* ndef _NTSDK */
/* current definition */
#ifdef	_DLL
#define _CRTIMP __declspec(dllimport)
#else	/* ndef _DLL */
#define _CRTIMP
#endif	/* _DLL */
#endif	/* _NTSDK */
#endif	/* _CRTIMP */


/* Define __cdecl for non-Microsoft compilers */

#if	( !defined(_MSC_VER) && !defined(__cdecl) )
#define __cdecl
#endif


/* Define NULL pointer value and the offset() macro */

#ifndef NULL
#ifdef __cplusplus
#define NULL	0
#else
#define NULL	((void *)0)
#endif
#endif


#define offsetof(s,m)	(size_t)&(((s *)0)->m)


/* Declare reference to errno */

#ifdef	_MT
_CRTIMP extern int * __cdecl _errno(void);
#define errno	(*_errno())
#else
_CRTIMP extern int errno;
#endif


/* define the implementation dependent size types */

#ifndef _PTRDIFF_T_DEFINED
typedef int ptrdiff_t;
#define _PTRDIFF_T_DEFINED
#endif


#ifndef _SIZE_T_DEFINED
typedef unsigned int size_t;
#define _SIZE_T_DEFINED
#endif


#ifndef _WCHAR_T_DEFINED
typedef unsigned short wchar_t;
#define _WCHAR_T_DEFINED
#endif


#ifdef	_MT
_CRTIMP extern unsigned long  __cdecl __threadid(void);
#define _threadid	(__threadid())
_CRTIMP extern unsigned long  __cdecl __threadhandle(void);
#endif


#ifdef __cplusplus
}
#endif

#endif	/* _INC_STDDEF */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\tools\c932\inc\rpcproxy.h ===
/*++

Copyright (c) 1992-1994 Microsoft Corporation

Module Name:

    rpcproxy.h

Abstract:

    Definitions for rpc proxy  stubs. 

Compiler switches:

    -DREGISTER_PROXY_DLL 
        Generates DllMain, DllRegisterServer, and DllUnregisterServer functions
        for automatically registering a proxy DLL.

    -DPROXY_CLSID=clsid
        Specifies a class ID to be used by the proxy DLL.

    -DPROXY_CLSID_IS={0x6f11fe5c,0x2fc5,0x101b,{0x9e,0x45,0x00,0x00,0x0b,0x65,0xc7,0xef}}
        Specifies the value of the class ID to be used by the proxy DLL.

    -DNT35_STRICT 
        Specifies that the target platform is Windows NT 3.5. This switch disables
        the new functions added after the Windows NT 3.5 release.

--*/

#ifndef __RPCPROXY_H__
#define __RPCPROXY_H__
#define __midl_proxy

#ifndef INC_OLE2
#define INC_OLE2
#endif

#if !defined(__RPC_DOS__) && !defined(__RPC_WIN16__)

//We need to define REFIID, REFCLSID and REFGUID here so that the
//proxy code won't get the const GUID *const definition.
#ifndef GUID_DEFINED
#define GUID_DEFINED
typedef struct _GUID
{
    unsigned long Data1;
    unsigned short Data2;
    unsigned short Data3;
    unsigned char Data4[8];
} GUID;
#endif /* GUID_DEFINED */

#if !defined( __IID_DEFINED__ )
    #define __IID_DEFINED__

    typedef GUID IID;
    typedef IID *LPIID;
    #define IID_NULL            GUID_NULL
    #define IsEqualIID(riid1, riid2) IsEqualGUID(riid1, riid2)
    typedef GUID CLSID;
    typedef CLSID *LPCLSID;
    #define CLSID_NULL          GUID_NULL
    #define IsEqualCLSID(rclsid1, rclsid2) IsEqualGUID(rclsid1, rclsid2)

    #ifndef _REFGUID_DEFINED
        #define _REFGUID_DEFINED
        typedef const GUID *REFGUID;
    #endif // !_REFGUID_DEFINED

    #ifndef _REFIID_DEFINED
        #define _REFIID_DEFINED
        typedef const IID *REFIID;
    #endif // !_REFIID_DEFINED

    #ifndef _REFCLSID_DEFINED
        #define _REFCLSID_DEFINED
        typedef const CLSID *REFCLSID;
    #endif // !_REFCLSID_DEFINED

#endif // !__IID_DEFINED__

// forward declarations
struct tagCInterfaceStubVtbl;
struct tagCInterfaceProxyVtbl;

typedef struct tagCInterfaceStubVtbl *  PCInterfaceStubVtblList;
typedef struct tagCInterfaceProxyVtbl *  PCInterfaceProxyVtblList;
typedef const char *                    PCInterfaceName;
typedef int (__stdcall *PIIDLookup)( const IID * pIID, int * pIndex );

// pointers to arrays of CInterfaceProxyVtbl's and CInterfaceStubVtbls
typedef struct tagProxyFileInfo
{
    const PCInterfaceProxyVtblList *pProxyVtblList;
    const PCInterfaceStubVtblList *pStubVtblList;
    const PCInterfaceName *     pNamesArray;
    const IID **                pDelegatedIIDs;
    const PIIDLookup            pIIDLookupRtn;
    unsigned short              TableSize;
    unsigned short              TableVersion;
    unsigned long               Filler1;
    unsigned long               Filler2;
    unsigned long               Filler3;
    unsigned long               Filler4;
}ProxyFileInfo;

// extended info with list of interface names
typedef ProxyFileInfo ExtendedProxyFileInfo;

#include "rpc.h"
#include "rpcndr.h"
#include <string.h>
#include <memory.h>

typedef struct tagCInterfaceProxyHeader
{
    //
    // New fields should be added here, at the beginning of the structure.
    //
#ifdef USE_STUBLESS_PROXY
    const void *    pStublessProxyInfo;
#endif
    const IID *     piid;
} CInterfaceProxyHeader;

#pragma warning( disable:4200 )
typedef struct tagCInterfaceProxyVtbl
{
    CInterfaceProxyHeader header;
    void *Vtbl[];
} CInterfaceProxyVtbl;
#pragma warning( default:4200 )

typedef
void
(__RPC_STUB __RPC_FAR * PRPC_STUB_FUNCTION) (
    IRpcStubBuffer *This,
    IRpcChannelBuffer * _pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD __RPC_FAR *pdwStubPhase);

typedef struct tagCInterfaceStubHeader
{
    //New fields should be added here, at the beginning of the structure.
    const IID *piid;
    const MIDL_SERVER_INFO *pServerInfo;
    unsigned long DispatchTableCount;
    const PRPC_STUB_FUNCTION *pDispatchTable;
} CInterfaceStubHeader;

typedef struct tagCInterfaceStubVtbl
{
    CInterfaceStubHeader header;
    IRpcStubBufferVtbl Vtbl;
} CInterfaceStubVtbl;

typedef struct tagCStdStubBuffer
{
    const struct IRpcStubBufferVtbl *   lpVtbl; //Points to Vtbl field in CInterfaceStubVtbl.
    long                                RefCount;
    struct IUnknown *                   pvServerObject;
} CStdStubBuffer;

typedef struct tagCStdPSFactoryBuffer
{
    const IPSFactoryBufferVtbl *lpVtbl;
    long                    RefCount;
    const ProxyFileInfo **  pProxyFileList;
    long                    Filler1;  //Reserved for future use.
} CStdPSFactoryBuffer;

void RPC_ENTRY
NdrProxyInitialize(
    void *              This,
    PRPC_MESSAGE        pRpcMsg, 
    PMIDL_STUB_MESSAGE  pStubMsg,
    PMIDL_STUB_DESC     pStubDescriptor,
    unsigned int        ProcNum );

void RPC_ENTRY
NdrProxyGetBuffer(
    void *              This,
    PMIDL_STUB_MESSAGE pStubMsg);

void RPC_ENTRY
NdrProxySendReceive(
    void                *This,
    MIDL_STUB_MESSAGE   *pStubMsg);

void RPC_ENTRY
NdrProxyFreeBuffer(
    void                *This,
    MIDL_STUB_MESSAGE   *pStubMsg);

HRESULT RPC_ENTRY
NdrProxyErrorHandler(
    DWORD dwExceptionCode);

void RPC_ENTRY
NdrStubInitialize(
    PRPC_MESSAGE        pRpcMsg, 
    PMIDL_STUB_MESSAGE  pStubMsg, 
    PMIDL_STUB_DESC     pStubDescriptor,
    IRpcChannelBuffer * pRpcChannelBuffer);

void __RPC_STUB NdrStubForwardingFunction(
    IN  IRpcStubBuffer *    This,
    IN  IRpcChannelBuffer * pChannel,
    IN  PRPC_MESSAGE        pmsg,
    OUT DWORD __RPC_FAR *   pdwStubPhase);

void RPC_ENTRY
NdrStubGetBuffer(
    IRpcStubBuffer *    This,
    IRpcChannelBuffer * pRpcChannelBuffer, 
    PMIDL_STUB_MESSAGE  pStubMsg);

HRESULT RPC_ENTRY
NdrStubErrorHandler(
    DWORD dwExceptionCode);

HRESULT STDMETHODCALLTYPE
CStdStubBuffer_QueryInterface(
    IRpcStubBuffer *This, 
    REFIID riid, 
    void **ppvObject);

ULONG STDMETHODCALLTYPE
CStdStubBuffer_AddRef(
    IRpcStubBuffer *This);

ULONG STDMETHODCALLTYPE
CStdStubBuffer_Release(
    IRpcStubBuffer *This);

ULONG STDMETHODCALLTYPE
NdrCStdStubBuffer_Release(
    IRpcStubBuffer *This,
    IPSFactoryBuffer * pPSF);

HRESULT STDMETHODCALLTYPE
CStdStubBuffer_Connect(
    IRpcStubBuffer *This, 
    IUnknown *pUnkServer);

void STDMETHODCALLTYPE
CStdStubBuffer_Disconnect(
    IRpcStubBuffer *This);

HRESULT STDMETHODCALLTYPE
CStdStubBuffer_Invoke(
    IRpcStubBuffer *This,
    RPCOLEMESSAGE *pRpcMsg,
    IRpcChannelBuffer *pRpcChannelBuffer);

IRpcStubBuffer * STDMETHODCALLTYPE
CStdStubBuffer_IsIIDSupported(
    IRpcStubBuffer *This,
    REFIID riid);

ULONG STDMETHODCALLTYPE
CStdStubBuffer_CountRefs(
    IRpcStubBuffer *This);

HRESULT STDMETHODCALLTYPE
CStdStubBuffer_DebugServerQueryInterface(
    IRpcStubBuffer *This, 
    void **ppv);

void STDMETHODCALLTYPE
CStdStubBuffer_DebugServerRelease(
    IRpcStubBuffer *This,
    void *pv);

#define CStdStubBuffer_METHODS \
    CStdStubBuffer_QueryInterface,\
    CStdStubBuffer_AddRef, \
    CStdStubBuffer_Release, \
    CStdStubBuffer_Connect, \
    CStdStubBuffer_Disconnect, \
    CStdStubBuffer_Invoke, \
    CStdStubBuffer_IsIIDSupported, \
    CStdStubBuffer_CountRefs, \
    CStdStubBuffer_DebugServerQueryInterface, \
    CStdStubBuffer_DebugServerRelease

//+-------------------------------------------------------------------------
//
//  Macro definitions for the proxy file
//
//--------------------------------------------------------------------------

#define IID_GENERIC_CHECK_IID(name,pIID,index) memcmp( pIID, name##_ProxyVtblList[ index ]->header.piid, 16 )

#define IID_BS_LOOKUP_SETUP     int result, low=-1;

#define IID_BS_LOOKUP_INITIAL_TEST(name, sz, split)   \
    if ( ( result = name##_CHECK_IID( split ) ) > 0 ) \
        { low = sz - split; }                      \
    else if ( !result )                               \
        { low = split; goto found_label; }

#define IID_BS_LOOKUP_NEXT_TEST(name, split )         \
    if ( ( result = name##_CHECK_IID( low + split )) >= 0 )  \
        { low = low + split; if ( !result ) goto found_label; }

#define IID_BS_LOOKUP_RETURN_RESULT(name, sz, index )                  \
    low = low + 1;                                          \
    if ( ( low >= sz ) || (result = name##_CHECK_IID( low ) )) goto not_found_label; \
    found_label: (index) = low; return 1;                         \
    not_found_label: return 0;

//+-------------------------------------------------------------------------
//
//  Macro and routine definitions for the dlldata file
//
//--------------------------------------------------------------------------

/****************************************************************************
 * Proxy Dll APIs
 ****************************************************************************/

HRESULT RPC_ENTRY 
NdrDllGetClassObject (
    IN  REFCLSID                rclsid,
    IN  REFIID                  riid,
    OUT void **                 ppv,
    IN const ProxyFileInfo **   pProxyFileList, 
    IN const CLSID *            pclsid,
    IN CStdPSFactoryBuffer *    pPSFactoryBuffer);

HRESULT RPC_ENTRY 
NdrDllCanUnloadNow(
    IN CStdPSFactoryBuffer * pPSFactoryBuffer);

/*************************************************************************
The following new functions were added after the Windows NT 3.5 release.
Programs intended to run on Windows NT 3.5 should define NT35_STRICT to 
ensure that no new functions are used.
*************************************************************************/
#ifndef NT35_STRICT

HRESULT RPC_ENTRY NdrDllRegisterProxy(
    IN HMODULE                  hDll,
    IN const ProxyFileInfo **   pProxyFileList, 
    IN const CLSID *            pclsid);

HRESULT RPC_ENTRY NdrDllUnregisterProxy(
    IN HMODULE                  hDll,
    IN const ProxyFileInfo **   pProxyFileList, 
    IN const CLSID *            pclsid);


#define REGISTER_PROXY_DLL_ROUTINES(pProxyFileList, pClsID) \
    \
    HINSTANCE hProxyDll = 0; \
    \
    /*DllMain saves the DLL module handle for later use by DllRegisterServer */ \
    BOOL WINAPI DllMain( \
        HINSTANCE  hinstDLL, \
        DWORD  fdwReason, \
        LPVOID  lpvReserved) \
    { \
        if(fdwReason == DLL_PROCESS_ATTACH) \
            hProxyDll = hinstDLL; \
        return TRUE; \
    } \
    \
    /* DllRegisterServer registers the interfaces contained in the proxy DLL. */ \
    HRESULT STDAPICALLTYPE DllRegisterServer() \
    { \
        return NdrDllRegisterProxy(hProxyDll, pProxyFileList, pClsID); \
    }  \
    \
    /* DllUnregisterServer unregisters the interfaces contained in the proxy DLL. */ \
    HRESULT STDAPICALLTYPE DllUnregisterServer() \
    { \
        return NdrDllUnregisterProxy(hProxyDll, pProxyFileList, pClsID); \
    }  

//Delegation support.
#define STUB_FORWARDING_FUNCTION        NdrStubForwardingFunction

ULONG STDMETHODCALLTYPE
CStdStubBuffer2_Release(IRpcStubBuffer *This);

ULONG STDMETHODCALLTYPE
NdrCStdStubBuffer2_Release(IRpcStubBuffer *This,IPSFactoryBuffer * pPSF);

#define CStdStubBuffer_DELEGATING_METHODS 0, 0, CStdStubBuffer2_Release, 0, 0, 0, 0, 0, 0, 0

#endif //NT35_STRICT
/*************************************************************************
End of new functions.
*************************************************************************/

// PROXY_CLSID has precedence over PROXY_CLSID_IS

#ifdef PROXY_CLSID

#define CLSID_PSFACTORYBUFFER extern CLSID PROXY_CLSID;

#else // PROXY_CLSID

#ifdef PROXY_CLSID_IS
#define CLSID_PSFACTORYBUFFER const CLSID CLSID_PSFactoryBuffer = PROXY_CLSID_IS;
#define PROXY_CLSID     CLSID_PSFactoryBuffer
#else // PROXY_CLSID_IS
#define CLSID_PSFACTORYBUFFER
#endif //PROXY_CLSID_IS

#endif //PROXY_CLSID

// if the user specified an override for the class id, it is
// PROXY_CLSID at this point

#ifndef PROXY_CLSID
#define GET_DLL_CLSID   \
    ( aProxyFileList[0]->pStubVtblList[0] != 0 ? \
    aProxyFileList[0]->pStubVtblList[0]->header.piid : 0)
#else  //PROXY_CLSID
#define GET_DLL_CLSID   &PROXY_CLSID
#endif //PROXY_CLSID




#define EXTERN_PROXY_FILE(name) \
    EXTERN_C const ProxyFileInfo name##_ProxyFileInfo;

#define PROXYFILE_LIST_START    \
    const ProxyFileInfo  *  aProxyFileList[]    = {

#define REFERENCE_PROXY_FILE(name)  \
    & name##_ProxyFileInfo 

#define PROXYFILE_LIST_END      \
    0 };

// return pointers to the class information

#define DLLDATA_GETPROXYDLLINFO(pPFList,pClsid) \
    void RPC_ENTRY GetProxyDllInfo( const ProxyFileInfo*** pInfo, const CLSID ** pId )  \
        {   \
        *pInfo  = pPFList;  \
        *pId    = pClsid;   \
        };

// ole entry points:
#define DLLGETCLASSOBJECTROUTINE(pPFlist, pClsid,pFactory)    \
 HRESULT STDAPICALLTYPE DllGetClassObject ( \
     REFCLSID rclsid, \
     REFIID riid, \
     void ** ppv ) \
        { \
        return  \
            NdrDllGetClassObject(rclsid,riid,ppv,pPFlist,pClsid,pFactory ); \
        }

#define DLLCANUNLOADNOW(pFactory)   \
 HRESULT STDAPICALLTYPE DllCanUnloadNow()    \
    {   \
    return NdrDllCanUnloadNow( pFactory );    \
    }

   
#define DLLDUMMYPURECALL    \
    void __cdecl _purecall(void)    \
        {   \
        }

#define CSTDSTUBBUFFERRELEASE(pFactory)   \
ULONG STDMETHODCALLTYPE CStdStubBuffer_Release(IRpcStubBuffer *This) \
    {   \
    return NdrCStdStubBuffer_Release(This,(IPSFactoryBuffer *)pFactory);   \
    }   \

#ifdef PROXY_DELEGATION
#define CSTDSTUBBUFFER2RELEASE(pFactory)   \
ULONG STDMETHODCALLTYPE CStdStubBuffer2_Release(IRpcStubBuffer *This) \
    {   \
    return NdrCStdStubBuffer2_Release(This,(IPSFactoryBuffer *)pFactory);   \
    }
#else
#define CSTDSTUBBUFFER2RELEASE(pFactory)   
#endif //PROXY_DELEGATION


#ifdef REGISTER_PROXY_DLL
#define DLLREGISTRY_ROUTINES(pProxyFileList,pClsID ) REGISTER_PROXY_DLL_ROUTINES(pProxyFileList,pClsID )
#else
#define DLLREGISTRY_ROUTINES(pProxyFileList,pClsID )    
#endif //REGISTER_PROXY_DLL


// the dll entry points that must be defined
#define DLLDATA_ROUTINES(pProxyFileList,pClsID )    \
    \
    CLSID_PSFACTORYBUFFER \
    \
    CStdPSFactoryBuffer       gPFactory = {0,0,0,0};  \
    \
    DLLDATA_GETPROXYDLLINFO(pProxyFileList,pClsID) \
    \
    DLLGETCLASSOBJECTROUTINE(pProxyFileList,pClsID,&gPFactory)    \
    \
    DLLCANUNLOADNOW(&gPFactory)   \
    \
    CSTDSTUBBUFFERRELEASE(&gPFactory)   \
    \
    CSTDSTUBBUFFER2RELEASE(&gPFactory) \
    \
    DLLDUMMYPURECALL    \
    \
    DLLREGISTRY_ROUTINES(pProxyFileList, pClsID) \
    \

    // more code goes here...


#define DLLDATA_STANDARD_ROUTINES   \
    DLLDATA_ROUTINES( (const ProxyFileInfo**) pProxyFileList, &CLSID_PSFactoryBuffer )  \

#else  // !defined(__RPC_DOS__) && !defined(__RPC_WIN16__)

//+-------------------------------------------------------------------------
//
//  16-bit definitions (all empty)
//
//--------------------------------------------------------------------------

#endif // !defined(__RPC_DOS__) && !defined(__RPC_WIN16__)

#endif // __RPCPROXY_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\tools\c932\inc\stdiostr.h ===
/***
*stdiostr.h - definitions/declarations for stdiobuf, stdiostream
*
*	Copyright (c) 1991-1994, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*	This file defines the classes, values, macros, and functions
*	used by the stdiostream and stdiobuf classes.
*	[AT&T C++]
*
****/

#ifndef _INC_STDIOSTREAM
#define _INC_STDIOSTREAM


/* Define _CRTIMP */

#ifndef _CRTIMP
#ifdef	_NTSDK
/* definition compatible with NT SDK */
#define _CRTIMP
#else	/* ndef _NTSDK */
/* current definition */
#ifdef	_DLL
#define _CRTIMP __declspec(dllimport)
#else	/* ndef _DLL */
#define _CRTIMP
#endif	/* _DLL */
#endif	/* _NTSDK */
#endif	/* _CRTIMP */

#include <iostream.h>
#include <stdio.h>

#ifdef	_MSC_VER
// Force word packing to avoid possible -Zp override
#pragma pack(push,4)

#pragma warning(disable:4505)		// disable unwanted /W4 warning
// #pragma warning(default:4505)	// use this to reenable, if necessary
#endif	// _MSC_VER

class _CRTIMP stdiobuf : public streambuf  {
public:
	stdiobuf(FILE* f);
FILE *	stdiofile() { return _str; }

virtual int pbackfail(int c);
virtual int overflow(int c = EOF);
virtual int underflow();
virtual streampos seekoff( streamoff, ios::seek_dir, int =ios::in|ios::out);
virtual int sync();
	~stdiobuf();
	int setrwbuf(int _rsize, int _wsize); // CONSIDER: move to ios::
// protected:
// virtual int doallocate();
private:
	FILE * _str;
};

// obsolescent
class _CRTIMP stdiostream : public iostream {	// note: spec.'d as : public IOS...
public:
	stdiostream(FILE *);
	~stdiostream();
	stdiobuf* rdbuf() const { return (stdiobuf*) ostream::rdbuf(); }
	
private:
};

#ifdef	_MSC_VER
// Restore default packing
#pragma pack(pop)
#endif	// _MSC_VER

#endif		// !_INC_STDIOSTREAM
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\tools\c932\inc\stdlib.h ===
/***
*stdlib.h - declarations/definitions for commonly used library functions
*
*	Copyright (c) 1985-1994, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	This include file contains the function declarations for
*	commonly used library functions which either don't fit somewhere
*	else, or, like toupper/tolower, can't be declared in the normal
*	place for other reasons.
*	[ANSI]
*
****/

#ifndef _INC_STDLIB
#define _INC_STDLIB

#ifdef __cplusplus
extern "C" {
#endif


/* Define _CRTAPI1 (for compatibility with the NT SDK) */

#ifndef _CRTAPI1
#if	( (_MSC_VER >= 800) && (_M_IX86 >= 300) )
#define _CRTAPI1 __cdecl
#else
#define _CRTAPI1
#endif
#endif


/* Define _CRTAPI2 (for compatibility with the NT SDK) */

#ifndef _CRTAPI2
#if	( (_MSC_VER >= 800) && (_M_IX86 >= 300) )
#define _CRTAPI2 __cdecl
#else
#define _CRTAPI2
#endif
#endif


/* Define _CRTIMP */

#ifndef _CRTIMP
#ifdef	_NTSDK
/* definition compatible with NT SDK */
#define _CRTIMP
#else	/* ndef _NTSDK */
/* current definition */
#ifdef	_DLL
#define _CRTIMP __declspec(dllimport)
#else	/* ndef _DLL */
#define _CRTIMP
#endif	/* _DLL */
#endif	/* _NTSDK */
#endif	/* _CRTIMP */


/* Define __cdecl for non-Microsoft compilers */

#if	( !defined(_MSC_VER) && !defined(__cdecl) )
#define __cdecl
#endif


#ifndef _SIZE_T_DEFINED
typedef unsigned int size_t;
#define _SIZE_T_DEFINED
#endif


#ifndef _WCHAR_T_DEFINED
typedef unsigned short wchar_t;
#define _WCHAR_T_DEFINED
#endif


/* Define NULL pointer value */

#ifndef NULL
#ifdef __cplusplus
#define NULL	0
#else
#define NULL	((void *)0)
#endif
#endif


/* Definition of the argument values for the exit() function */

#define EXIT_SUCCESS	0
#define EXIT_FAILURE	1


#ifndef _ONEXIT_T_DEFINED
typedef int (__cdecl * _onexit_t)(void);
#if !__STDC__
/* Non-ANSI name for compatibility */
#define onexit_t _onexit_t
#endif
#define _ONEXIT_T_DEFINED
#endif


/* Data structure definitions for div and ldiv runtimes. */

#ifndef _DIV_T_DEFINED

typedef struct _div_t {
	int quot;
	int rem;
} div_t;

typedef struct _ldiv_t {
	long quot;
	long rem;
} ldiv_t;

#define _DIV_T_DEFINED
#endif

/* Maximum value that can be returned by the rand function. */

#define RAND_MAX 0x7fff

/*
 * Maximum number of bytes in multi-byte character in the current locale
 * (also defined in ctype.h).
 */
#ifndef MB_CUR_MAX

#ifdef	_NTSDK

/* definition compatible with NT SDK */
#ifdef	_DLL
#define __mb_cur_max	(*__mb_cur_max_dll)
#define MB_CUR_MAX	(*__mb_cur_max_dll)
extern	int *__mb_cur_max_dll;
#else	/* ndef _DLL */
#define MB_CUR_MAX __mb_cur_max
extern	int __mb_cur_max;
#endif	/* _DLL */

#else	/* ndef _NTSDK */

/* current definition */
#if	defined(_DLL) && defined(_M_IX86)
#define MB_CUR_MAX	(*__p___mb_cur_max())
_CRTIMP int * __cdecl __p___mb_cur_max(void);
#else	/* !(defined(_DLL) && defined(_M_IX86)) */
#define MB_CUR_MAX __mb_cur_max
_CRTIMP extern int __mb_cur_max;
#endif	/* defined(_DLL) && defined(_M_IX86) */

#endif	/* _NTSDK */

#endif	/* MB_CUR_MAX */


/* Minimum and maximum macros */

#define __max(a,b)	(((a) > (b)) ? (a) : (b))
#define __min(a,b)	(((a) < (b)) ? (a) : (b))

/*
 * Sizes for buffers used by the _makepath() and _splitpath() functions.
 * note that the sizes include space for 0-terminator
 */
#define _MAX_PATH	260	/* max. length of full pathname */
#define _MAX_DRIVE	3	/* max. length of drive component */
#define _MAX_DIR	256	/* max. length of path component */
#define _MAX_FNAME	256	/* max. length of file name component */
#define _MAX_EXT	256	/* max. length of extension component */


/* External variable declarations */

#ifdef	_MT
_CRTIMP int * __cdecl _errno(void);
_CRTIMP unsigned long * __cdecl __doserrno(void);
#define errno	    (*_errno())
#define _doserrno   (*__doserrno())
#else	/* ndef _MT */
_CRTIMP extern int errno;			/* XENIX style error number */
_CRTIMP extern unsigned long _doserrno; 	/* OS system error value */
#endif	/* _MT */

#ifdef	_NTSDK

/* Definitions and declarations compatible with the NT SDK */

#ifdef	_DLL

extern char ** _sys_errlist;	/* perror error message table */

#define _sys_nerr   (*_sys_nerr_dll)
#define __argc      (*__argc_dll)
#define __argc      (*__argc_dll)
#define __argv      (*__argv_dll)
#define __wargv     (*__wargv_dll)
#define _environ    (*_environ_dll)
#define _wenviron   (*_wenviron_dll)
#define _fmode	    (*_fmode_dll)
#define _fileinfo   (*_fileinfo_dll)

extern int * _sys_nerr_dll;	/* # of entries in sys_errlist table */
extern int * __argc_dll;	/* count of cmd line args */
extern char *** __argv_dll;	/* pointer to table of cmd line args */
extern wchar_t *** __wargv_dll;	/* pointer to table of wide cmd line args */
extern char *** _environ_dll;	/* pointer to environment table */
extern wchar_t *** _wenviron_dll;	/* pointer to wide environment table */
extern int * _fmode_dll;	/* default file translation mode */
extern int * _fileinfo_dll;	/* open file info mode (for spawn) */

#define _pgmptr     (*_pgmptr_dll)
#define _wpgmptr    (*_wpgmptr_dll)

#define _osver      (*_osver_dll)
#define _winver     (*_winver_dll)
#define _winmajor   (*_winmajor_dll)
#define _winminor   (*_winminor_dll)

extern char ** _pgmptr_dll;
extern wchar_t ** _wpgmptr_dll;

extern unsigned int * _osver_dll;
extern unsigned int * _winver_dll;
extern unsigned int * _winmajor_dll;
extern unsigned int * _winminor_dll;

#else	/* ndef _DLL */


extern char * _sys_errlist[];	/* perror error message table */
extern int _sys_nerr;		/* # of entries in sys_errlist table */

extern int __argc;		/* count of cmd line args */
extern char ** __argv;		/* pointer to table of cmd line args */
extern wchar_t ** __wargv;	/* pointer to table of wide cmd line args */

#ifdef _POSIX_
extern char ** environ;		/* pointer to environment table */
#else
extern char **    _environ;     /* pointer to environment table */
extern wchar_t ** _wenviron;    /* pointer to wide environment table */
#endif

extern int _fmode;		/* default file translation mode */
extern int _fileinfo;		/* open file info mode (for spawn) */

extern char * _pgmptr;		/* points to the module (EXE) name */
extern wchar_t * _wpgmptr;	/* points to the module (EXE) wide name */

/* Windows major/minor and O.S. version numbers */

extern unsigned int _osver;
extern unsigned int _winver;
extern unsigned int _winmajor;
extern unsigned int _winminor;

#endif	/* _DLL */

#else	/* ndef _NTSDK */

/* Current definitions and declarations */

_CRTIMP extern char * _sys_errlist[];	/* perror error message table */
_CRTIMP extern int _sys_nerr;		/* # of entries in sys_errlist table */

#if	defined(_DLL) && defined(_M_IX86)

#define __argc	    (*__p___argc())	/* count of cmd line args */
#define __argv	    (*__p___argv())	/* pointer to table of cmd line args */
#define __wargv     (*__p___wargv())	/* pointer to table of wide cmd line args */
#define _environ    (*__p__environ())	/* pointer to environment table */
#define _wenviron   (*__p__wenviron())	/* pointer to wide environment table */
#define _fmode	    (*__p__fmode())
#define _osver	    (*__p__osver())
#define _pgmptr     (*__p__pgmptr())	/* points to the module (EXE) name */
#define _wpgmptr    (*__p__wpgmptr())	/* points to the module (EXE) wide name */
#define _winver     (*__p__winver())
#define _winmajor   (*__p__winmajor())
#define _winminor   (*__p__winminor())

_CRTIMP int *	       __cdecl __p___argc(void);
_CRTIMP char ***       __cdecl __p___argv(void);
_CRTIMP wchar_t ***    __cdecl __p___wargv(void);
_CRTIMP char ***       __cdecl __p__environ(void);
_CRTIMP wchar_t ***    __cdecl __p__wenviron(void);
_CRTIMP int *	       __cdecl __p__fmode(void);
_CRTIMP unsigned int * __cdecl __p__osver(void);
_CRTIMP char **	       __cdecl __p__pgmptr(void);
_CRTIMP wchar_t **     __cdecl __p__wpgmptr(void);
_CRTIMP unsigned int * __cdecl __p__winver(void);
_CRTIMP unsigned int * __cdecl __p__winmajor(void);
_CRTIMP unsigned int * __cdecl __p__winminor(void);

#else	/* !(defined(_DLL) && defined(_M_IX86)) */
_CRTIMP extern int __argc;		/* count of cmd line args */
_CRTIMP extern char ** __argv;		/* pointer to table of cmd line args */
_CRTIMP extern wchar_t ** __wargv;	/* pointer to table of wide cmd line args */

_CRTIMP extern char **    _environ;     /* pointer to environment table */
_CRTIMP extern wchar_t ** _wenviron;    /* pointer to wide environment table */

_CRTIMP extern int _fmode;		/* default file translation mode */
_CRTIMP extern int _fileinfo;		/* open file info mode (for spawn) */

_CRTIMP extern char * _pgmptr;		/* points to the module (EXE) name */
_CRTIMP extern wchar_t * _wpgmptr;	/* points to the module (EXE) wide name */

/* Windows major/minor and O.S. version numbers */

_CRTIMP extern unsigned int _osver;
_CRTIMP extern unsigned int _winver;
_CRTIMP extern unsigned int _winmajor;
_CRTIMP extern unsigned int _winminor;
#endif	/* defined(_DLL) && defined(_M_IX86) */

#endif	/* _NTSDK */

/* function prototypes */

_CRTIMP void   __cdecl abort(void);
	int    __cdecl abs(int);
	int    __cdecl atexit(void (__cdecl *)(void));
_CRTIMP double __cdecl atof(const char *);
_CRTIMP int    __cdecl atoi(const char *);
_CRTIMP long   __cdecl atol(const char *);
_CRTIMP void * __cdecl bsearch(const void *, const void *, size_t, size_t,
	int (__cdecl *)(const void *, const void *));
_CRTIMP void * __cdecl calloc(size_t, size_t);
_CRTIMP div_t  __cdecl div(int, int);
_CRTIMP void   __cdecl exit(int);
_CRTIMP void   __cdecl free(void *);
_CRTIMP char * __cdecl getenv(const char *);
_CRTIMP char * __cdecl _itoa(int, char *, int);
	long __cdecl labs(long);
_CRTIMP ldiv_t __cdecl ldiv(long, long);
_CRTIMP char * __cdecl _ltoa(long, char *, int);
_CRTIMP void * __cdecl malloc(size_t);
_CRTIMP int    __cdecl mblen(const char *, size_t);
_CRTIMP size_t __cdecl _mbstrlen(const char *s);
_CRTIMP int    __cdecl mbtowc(wchar_t *, const char *, size_t);
_CRTIMP size_t __cdecl mbstowcs(wchar_t *, const char *, size_t);
_CRTIMP void   __cdecl qsort(void *, size_t, size_t, int (__cdecl *)
	(const void *, const void *));
_CRTIMP int    __cdecl rand(void);
_CRTIMP void * __cdecl realloc(void *, size_t);
_CRTIMP void   __cdecl srand(unsigned int);
_CRTIMP double __cdecl strtod(const char *, char **);
_CRTIMP long   __cdecl strtol(const char *, char **, int);
_CRTIMP unsigned long __cdecl strtoul(const char *, char **, int);
_CRTIMP int    __cdecl system(const char *);
_CRTIMP char * __cdecl _ultoa(unsigned long, char *, int);
_CRTIMP int    __cdecl wctomb(char *, wchar_t);
_CRTIMP size_t __cdecl wcstombs(char *, const wchar_t *, size_t);

#ifndef _WSTDLIB_DEFINED

/* wide function prototypes, also declared in wchar.h  */

_CRTIMP wchar_t * __cdecl _itow (int, wchar_t *, int);
_CRTIMP wchar_t * __cdecl _ltow (long, wchar_t *, int);
_CRTIMP wchar_t * __cdecl _ultow (unsigned long, wchar_t *, int);
_CRTIMP double __cdecl wcstod(const wchar_t *, wchar_t **);
_CRTIMP long   __cdecl wcstol(const wchar_t *, wchar_t **, int);
_CRTIMP unsigned long __cdecl wcstoul(const wchar_t *, wchar_t **, int);
_CRTIMP wchar_t * __cdecl _wgetenv(const wchar_t *);
_CRTIMP int    __cdecl _wsystem(const wchar_t *);
_CRTIMP int __cdecl _wtoi(const wchar_t *);
_CRTIMP long __cdecl _wtol(const wchar_t *);

#define _WSTDLIB_DEFINED
#endif

#ifndef _POSIX_

_CRTIMP char * __cdecl _ecvt(double, int, int *, int *);
_CRTIMP void   __cdecl _exit(int);
_CRTIMP char * __cdecl _fcvt(double, int, int *, int *);
_CRTIMP char * __cdecl _fullpath(char *, const char *, size_t);
_CRTIMP char * __cdecl _gcvt(double, int, char *);
	unsigned long __cdecl _lrotl(unsigned long, int);
	unsigned long __cdecl _lrotr(unsigned long, int);
_CRTIMP void   __cdecl _makepath(char *, const char *, const char *, const char *,
	const char *);
	_onexit_t __cdecl _onexit(_onexit_t);
_CRTIMP void   __cdecl perror(const char *);
_CRTIMP int    __cdecl _putenv(const char *);
	unsigned int __cdecl _rotl(unsigned int, int);
	unsigned int __cdecl _rotr(unsigned int, int);
_CRTIMP void   __cdecl _searchenv(const char *, const char *, char *);
_CRTIMP void   __cdecl _splitpath(const char *, char *, char *, char *, char *);
_CRTIMP void   __cdecl _swab(char *, char *, int);

#ifndef _WSTDLIBP_DEFINED

/* wide function prototypes, also declared in wchar.h  */

_CRTIMP wchar_t * __cdecl _wfullpath(wchar_t *, const wchar_t *, size_t);
_CRTIMP void   __cdecl _wmakepath(wchar_t *, const wchar_t *, const wchar_t *, const wchar_t *,
	const wchar_t *);
_CRTIMP void   __cdecl _wperror(const wchar_t *);
_CRTIMP int    __cdecl _wputenv(const wchar_t *);
_CRTIMP void   __cdecl _wsearchenv(const wchar_t *, const wchar_t *, wchar_t *);
_CRTIMP void   __cdecl _wsplitpath(const wchar_t *, wchar_t *, wchar_t *, wchar_t *, wchar_t *);

#define _WSTDLIBP_DEFINED
#endif

/* --------- The following functions are OBSOLETE --------- */
/* The Win32 API SetErrorMode, Beep and Sleep should be used instead. */
_CRTIMP void _seterrormode(int);
_CRTIMP void _beep(unsigned, unsigned);
_CRTIMP void _sleep(unsigned long);
/*  --------- The preceding functions are OBSOLETE --------- */

#endif	/* _POSIX_ */

#ifndef tolower 	/* tolower has been undefined - use function */
_CRTIMP int __cdecl tolower(int);
#endif	/* tolower */

#ifndef toupper 	/* toupper has been undefined - use function */
_CRTIMP int __cdecl toupper(int);
#endif	/* toupper */


#if	!__STDC__

/* Non-ANSI names for compatibility */

#ifdef	_NTSDK

#ifndef _POSIX_

#ifndef __cplusplus
#define max(a,b)	(((a) > (b)) ? (a) : (b))
#define min(a,b)	(((a) < (b)) ? (a) : (b))
#endif

#define sys_errlist _sys_errlist
#define sys_nerr    _sys_nerr
#define environ     _environ

#define DOS_MODE    _DOS_MODE
#define OS2_MODE    _OS2_MODE

#define ecvt	    _ecvt
#define fcvt	    _fcvt
#define gcvt	    _gcvt
#define itoa	    _itoa
#define ltoa	    _ltoa
#define onexit	    _onexit
#define putenv	    _putenv
#define swab	    _swab
#define ultoa	    _ultoa

#endif	/* _POSIX_ */

#else	/* ndef _NTSDK */

#ifndef __cplusplus
#define max(a,b)	(((a) > (b)) ? (a) : (b))
#define min(a,b)	(((a) < (b)) ? (a) : (b))
#endif

#define sys_errlist _sys_errlist
#define sys_nerr    _sys_nerr
#define environ     _environ

_CRTIMP char * __cdecl ecvt(double, int, int *, int *);
_CRTIMP char * __cdecl fcvt(double, int, int *, int *);
_CRTIMP char * __cdecl gcvt(double, int, char *);
_CRTIMP char * __cdecl itoa(int, char *, int);
_CRTIMP char * __cdecl ltoa(long, char *, int);
	onexit_t __cdecl onexit(onexit_t);
_CRTIMP int    __cdecl putenv(const char *);
_CRTIMP void   __cdecl swab(char *, char *, int);
_CRTIMP char * __cdecl ultoa(unsigned long, char *, int);

#endif	/* _NTSDK */

#endif	/* __STDC__ */

#ifdef __cplusplus
}
#endif


#endif	/* _INC_STDLIB */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\tools\c932\inc\time.h ===
/***
*time.h - definitions/declarations for time routines
*
*	Copyright (c) 1985-1994, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	This file has declarations of time routines and defines
*	the structure returned by the localtime and gmtime routines and
*	used by asctime.
*	[ANSI/System V]
*
****/

#ifndef _INC_TIME
#define _INC_TIME

#ifdef __cplusplus
extern "C" {
#endif


/* Define _CRTAPI1 (for compatibility with the NT SDK) */

#ifndef _CRTAPI1
#if	( (_MSC_VER >= 800) && (_M_IX86 >= 300) )
#define _CRTAPI1 __cdecl
#else
#define _CRTAPI1
#endif
#endif


/* Define _CRTAPI2 (for compatibility with the NT SDK) */

#ifndef _CRTAPI2
#if	( (_MSC_VER >= 800) && (_M_IX86 >= 300) )
#define _CRTAPI2 __cdecl
#else
#define _CRTAPI2
#endif
#endif


/* Define _CRTIMP */

#ifndef _CRTIMP
#ifdef	_NTSDK
/* definition compatible with NT SDK */
#define _CRTIMP
#else	/* ndef _NTSDK */
/* current definition */
#ifdef	_DLL
#define _CRTIMP __declspec(dllimport)
#else	/* ndef _DLL */
#define _CRTIMP
#endif	/* _DLL */
#endif	/* _NTSDK */
#endif	/* _CRTIMP */


/* Define __cdecl for non-Microsoft compilers */

#if	( !defined(_MSC_VER) && !defined(__cdecl) )
#define __cdecl
#endif

#ifndef _WCHAR_T_DEFINED
typedef unsigned short wchar_t;
#define _WCHAR_T_DEFINED
#endif

/* Define the implementation defined time type */

#ifndef _TIME_T_DEFINED
typedef long time_t;		/* time value */
#define _TIME_T_DEFINED 	/* avoid multiple def's of time_t */
#endif

#ifndef _CLOCK_T_DEFINED
typedef long clock_t;
#define _CLOCK_T_DEFINED
#endif

#ifndef _SIZE_T_DEFINED
typedef unsigned int size_t;
#define _SIZE_T_DEFINED
#endif


/* Define NULL pointer value */

#ifndef NULL
#ifdef __cplusplus
#define NULL	0
#else
#define NULL	((void *)0)
#endif
#endif


#ifndef _TM_DEFINED
struct tm {
	int tm_sec;	/* seconds after the minute - [0,59] */
	int tm_min;	/* minutes after the hour - [0,59] */
	int tm_hour;	/* hours since midnight - [0,23] */
	int tm_mday;	/* day of the month - [1,31] */
	int tm_mon;	/* months since January - [0,11] */
	int tm_year;	/* years since 1900 */
	int tm_wday;	/* days since Sunday - [0,6] */
	int tm_yday;	/* days since January 1 - [0,365] */
	int tm_isdst;	/* daylight savings time flag */
	};
#define _TM_DEFINED
#endif


/* Clock ticks macro - ANSI version */

#define CLOCKS_PER_SEC	1000


/* Extern declarations for the global variables used by the ctime family of
 * routines.
 */

#ifdef	_NTSDK

#ifdef	_DLL

/* Declarations and definitions compatible with the NT SDK */

#define _daylight   (*_daylight_dll)
#define _timezone   (*_timezone_dll)

/* non-zero if daylight savings time is used */
extern int * _daylight_dll;

/* difference in seconds between GMT and local time */
extern long * _timezone_dll;

/* standard/daylight savings time zone names */
extern char ** _tzname;

#else	/* ndef _DLL */


#ifdef	_POSIX_
extern char * _rule;
#endif	/* _POSIX_ */

/* non-zero if daylight savings time is used */
extern int _daylight;

/* difference in seconds between GMT and local time */
extern long _timezone;

/* standard/daylight savings time zone names */
#ifdef	_POSIX_
extern char * tzname[2];
#else	/* ndef _POSIX_ */
extern char * _tzname[2];
#endif	/* _POSIX_ */

#endif	/* _DLL */

#else	/* ndef _NTSDK */

/* Current declarations and definitions */

#if	defined(_DLL) && defined(_M_IX86)

#define _daylight   (*__p__daylight())
_CRTIMP int * __cdecl __p__daylight(void);

#define _timezone   (*__p__timezone())
_CRTIMP long * __cdecl __p__timezone(void);

#define _tzname     (__p__tzname())
_CRTIMP char ** __cdecl __p__tzname(void);

#else	/* !(defined(_DLL) && defined(_M_IX86)) */

/* non-zero if daylight savings time is used */
_CRTIMP extern int _daylight;

/* difference in seconds between GMT and local time */
_CRTIMP extern long _timezone;

/* standard/daylight savings time zone names */
_CRTIMP extern char * _tzname[2];

#endif	/* defined(_DLL) && defined(_M_IX86) */

#endif	/* _NTSDK */


/* Function prototypes */

_CRTIMP char * __cdecl asctime(const struct tm *);
_CRTIMP char * __cdecl ctime(const time_t *);
_CRTIMP clock_t __cdecl clock(void);
_CRTIMP double __cdecl difftime(time_t, time_t);
_CRTIMP struct tm * __cdecl gmtime(const time_t *);
_CRTIMP struct tm * __cdecl localtime(const time_t *);
_CRTIMP time_t __cdecl mktime(struct tm *);
_CRTIMP size_t __cdecl strftime(char *, size_t, const char *,
	const struct tm *);
_CRTIMP char * __cdecl _strdate(char *);
_CRTIMP char * __cdecl _strtime(char *);
_CRTIMP time_t __cdecl time(time_t *);

#ifdef	_POSIX_
_CRTIMP void __cdecl tzset(void);
#else
_CRTIMP void __cdecl _tzset(void);
#endif

/* --------- The following functions are OBSOLETE --------- */
/* The Win32 API GetLocalTime and SetLocalTime should be used instead. */
unsigned __cdecl _getsystime(struct tm *);
unsigned __cdecl _setsystime(struct tm *, unsigned);
/* --------- The preceding functions are OBSOLETE --------- */


#ifndef _SIZE_T_DEFINED
typedef unsigned int size_t;
#define _SIZE_T_DEFINED
#endif

#ifndef _WTIME_DEFINED

/* wide function prototypes, also declared in wchar.h */
 
_CRTIMP wchar_t * __cdecl _wasctime(const struct tm *);
_CRTIMP wchar_t * __cdecl _wctime(const time_t *);
_CRTIMP size_t __cdecl wcsftime(wchar_t *, size_t, const char *,
	const struct tm *);
_CRTIMP wchar_t * __cdecl _wstrdate(wchar_t *);
_CRTIMP wchar_t * __cdecl _wstrtime(wchar_t *);

#define _WTIME_DEFINED
#endif


#if	!__STDC__ || defined(_POSIX_)

/* Non-ANSI names for compatibility */

#define CLK_TCK  CLOCKS_PER_SEC

#ifdef	_NTSDK

/* Declarations and definitions compatible with the NT SDK */

#define daylight _daylight
/* timezone cannot be #defined to _timezone because of <sys/timeb.h> */

#ifndef _POSIX_
#define tzname	_tzname
#define tzset	_tzset
#endif /* _POSIX_ */

#else	/* ndef _NTSDK */

/* Current declarations */

_CRTIMP extern int daylight;
_CRTIMP extern long timezone;
_CRTIMP extern char * tzname[2];

_CRTIMP void __cdecl tzset(void);

#endif	/* _NTSDK */

#endif	/* __STDC__ */


#ifdef __cplusplus
}
#endif


#endif	/* _INC_TIME */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\tools\c932\inc\streamb.h ===
/***
*streamb.h - definitions/declarations for the streambuf class
*
*	Copyright (c) 1990-1994, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*	This file defines the classes, values, macros, and functions
*	used by the streambuf class.
*	[AT&T C++]
*
****/

#ifndef _INC_STREAMB
#define _INC_STREAMB

/* Define _CRTIMP */

#ifndef _CRTIMP
#ifdef	_NTSDK
/* definition compatible with NT SDK */
#define _CRTIMP
#else	/* ndef _NTSDK */
/* current definition */
#ifdef	_DLL
#define _CRTIMP __declspec(dllimport)
#else	/* ndef _DLL */
#define _CRTIMP
#endif	/* _DLL */
#endif	/* _NTSDK */
#endif	/* _CRTIMP */


#include <ios.h>	// need ios::seek_dir definition
#ifdef	_MT		// defined in ios.h
extern "C" {
_CRTIMP void __cdecl _mtlock(PRTL_CRITICAL_SECTION);
_CRTIMP void __cdecl _mtunlock(PRTL_CRITICAL_SECTION);
}
#endif

#ifndef NULL
#define NULL	0
#endif

#ifndef EOF
#define EOF	(-1)
#endif

#ifdef	_MSC_VER
// C4505: "unreferenced local function has been removed"
#pragma warning(disable:4505) // disable C4505 warning
// #pragma warning(default:4505)	// use this to reenable, if desired

// Force word packing to avoid possible -Zp override
#pragma pack(push,4)
#endif	// _MSC_VER

typedef long streampos, streamoff;

class _CRTIMP ios;

class _CRTIMP streambuf {
public:

    virtual ~streambuf();

    inline int in_avail() const;
    inline int out_waiting() const;
    int sgetc();
    int snextc();
    int sbumpc();
    void stossc();

    inline int sputbackc(char);

    inline int sputc(int);
    inline int sputn(const char *,int);
    inline int sgetn(char *,int);

    virtual int sync();

//  enum seek_dir { beg=0, cur=1, end=2 };  // CONSIDER: needed ???

    virtual streambuf* setbuf(char *, int);
    virtual streampos seekoff(streamoff,ios::seek_dir,int =ios::in|ios::out);
    virtual streampos seekpos(streampos,int =ios::in|ios::out);

    virtual int xsputn(const char *,int);
    virtual int xsgetn(char *,int);

    virtual int overflow(int =EOF) = 0;	// pure virtual function
    virtual int underflow() = 0;	// pure virtual function

    virtual int pbackfail(int);

    void dbp();

#ifdef	_MT
    void setlock() { LockFlg--; }	// <0 indicates lock required;
    void clrlock() { if (LockFlg <= 0) LockFlg++; }
    void lock() { if (LockFlg<0) _mtlock(lockptr()); };
    void unlock() { if (LockFlg<0) _mtunlock(lockptr()); }
#else
    void lock() { }
    void unlock() { }
#endif

protected:
    streambuf();
    streambuf(char *,int);

    inline char * base() const;
    inline char * ebuf() const;
    inline char * pbase() const;
    inline char * pptr() const;
    inline char * epptr() const;
    inline char * eback() const;
    inline char * gptr() const;
    inline char * egptr() const;
    inline int blen() const;
    inline void setp(char *,char *);
    inline void setg(char *,char *,char *);
    inline void pbump(int);
    inline void gbump(int);

    void setb(char *,char *,int =0);
    inline int unbuffered() const;
    inline void unbuffered(int);
    int allocate();
    virtual int doallocate();
#ifdef	_MT
    PRTL_CRITICAL_SECTION lockptr() { return & x_lock; }
#endif

private:
    int _fAlloc;
    int _fUnbuf;
    int x_lastc;
    char * _base;
    char * _ebuf;
    char * _pbase;
    char * _pptr;
    char * _epptr;
    char * _eback;
    char * _gptr;
    char * _egptr;
#ifdef	_MT
    int LockFlg;		// <0 indicates locking required
   RTL_CRITICAL_SECTION x_lock;	// lock needed only for multi-thread operation
#endif
};

inline int streambuf::in_avail() const { return (gptr()<_egptr) ? (_egptr-gptr()) : 0; }
inline int streambuf::out_waiting() const { return (_pptr>=_pbase) ? (_pptr-_pbase) : 0; }

inline int streambuf::sputbackc(char _c){ return (_eback<gptr()) ? *(--_gptr)=_c : pbackfail(_c); }

inline int streambuf::sputc(int _i){ return (_pptr<_epptr) ? (unsigned char)(*(_pptr++)=(char)_i) : overflow(_i); }

inline int streambuf::sputn(const char * _str,int _n) { return xsputn(_str, _n); }
inline int streambuf::sgetn(char * _str,int _n) { return xsgetn(_str, _n); }

inline char * streambuf::base() const { return _base; }
inline char * streambuf::ebuf() const { return _ebuf; }
inline int streambuf::blen() const  {return ((_ebuf > _base) ? (_ebuf-_base) : 0); }
inline char * streambuf::pbase() const { return _pbase; }
inline char * streambuf::pptr() const { return _pptr; }
inline char * streambuf::epptr() const { return _epptr; }
inline char * streambuf::eback() const { return _eback; }
inline char * streambuf::gptr() const { return _gptr; }
inline char * streambuf::egptr() const { return _egptr; }
inline void streambuf::gbump(int _n) { if (_egptr) _gptr += _n; }
inline void streambuf::pbump(int _n) { if (_epptr) _pptr += _n; }
inline void streambuf::setg(char * _eb, char * _g, char * _eg) {_eback=_eb; _gptr=_g; _egptr=_eg; x_lastc=EOF; }
inline void streambuf::setp(char * _p, char * _ep) {_pptr=_pbase=_p; _epptr=_ep; }
inline int streambuf::unbuffered() const { return _fUnbuf; }
inline void streambuf::unbuffered(int _f) { _fUnbuf = _f; }

#ifdef	_MSC_VER
// Restore previous packing
#pragma pack(pop)
#endif	// _MSC_VER

#endif /* !_INC_STREAMB */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\tools\c932\inc\strstrea.h ===
/***
*strstream.h - definitions/declarations for strstreambuf, strstream
*
*	Copyright (c) 1991-1994, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*	This file defines the classes, values, macros, and functions
*	used by the strstream and strstreambuf classes.
*	[AT&T C++]
*
****/

#ifndef _INC_STRSTREAM
#define _INC_STRSTREAM


/* Define _CRTIMP */

#ifndef _CRTIMP
#ifdef	_NTSDK
/* definition compatible with NT SDK */
#define _CRTIMP
#else	/* ndef _NTSDK */
/* current definition */
#ifdef	_DLL
#define _CRTIMP __declspec(dllimport)
#else	/* ndef _DLL */
#define _CRTIMP
#endif	/* _DLL */
#endif	/* _NTSDK */
#endif	/* _CRTIMP */


#include <iostream.h>

#ifdef	_MSC_VER
// Force word packing to avoid possible -Zp override
#pragma pack(push,4)

#pragma warning(disable:4505)		// disable unwanted /W4 warning
// #pragma warning(default:4505)	// use this to reenable, if necessary
#endif	// _MSC_VER

class _CRTIMP strstreambuf : public streambuf  {
public:
		strstreambuf();
		strstreambuf(int);
		strstreambuf(char *, int, char * = 0);
		strstreambuf(unsigned char *, int, unsigned char * = 0);
		strstreambuf(signed char *, int, signed char * = 0);
		strstreambuf(void * (*a)(long), void (*f) (void *));
		~strstreambuf();

	void	freeze(int =1);
	char * str();

virtual	int	overflow(int);
virtual	int	underflow();
virtual streambuf* setbuf(char *, int);
virtual	streampos seekoff(streamoff, ios::seek_dir, int);
virtual int	sync();		// not in spec.

protected:
virtual	int	doallocate();
private:
	int	x_dynamic;
	int 	x_bufmin;
	int 	_fAlloc;
	int	x_static;
	void * (* x_alloc)(long);
	void 	(* x_free)(void *);
};

class _CRTIMP istrstream : public istream {
public:
		istrstream(char *);
		istrstream(char *, int);
		~istrstream();

inline	strstreambuf* rdbuf() const { return (strstreambuf*) ios::rdbuf(); }
inline	char * str() { return rdbuf()->str(); }
};

class _CRTIMP ostrstream : public ostream {
public:
		ostrstream();
		ostrstream(char *, int, int = ios::out);
		~ostrstream();

inline	int	pcount() const { return rdbuf()->out_waiting(); }
inline	strstreambuf* rdbuf() const { return (strstreambuf*) ios::rdbuf(); }
inline	char *	str() { return rdbuf()->str(); }
};

class _CRTIMP strstream : public iostream {	// strstreambase ???
public:
		strstream();
		strstream(char *, int, int);
		~strstream();

inline	int	pcount() const { return rdbuf()->out_waiting(); } // not in spec.
inline	strstreambuf* rdbuf() const { return (strstreambuf*) ostream::rdbuf(); }
inline	char * str() { return rdbuf()->str(); }
};

#ifdef	_MSC_VER
// Restore previous packing
#pragma pack(pop)
#endif	// _MSC_VER

#endif		// !_INC_STRSTREAM
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\tools\c932\inc\stdio.h ===
/***
*stdio.h - definitions/declarations for standard I/O routines
*
*	Copyright (c) 1985-1994, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	This file defines the structures, values, macros, and functions
*	used by the level 2 I/O ("standard I/O") routines.
*	[ANSI/System V]
*
****/

#ifndef _INC_STDIO
#define _INC_STDIO

#ifdef	__cplusplus
extern "C" {
#endif


/* Define _CRTAPI1 (for compatibility with the NT SDK) */

#ifndef _CRTAPI1
#if	( (_MSC_VER >= 800) && (_M_IX86 >= 300) )
#define _CRTAPI1 __cdecl
#else
#define _CRTAPI1
#endif
#endif


/* Define _CRTAPI2 (for compatibility with the NT SDK) */

#ifndef _CRTAPI2
#if	( (_MSC_VER >= 800) && (_M_IX86 >= 300) )
#define _CRTAPI2 __cdecl
#else
#define _CRTAPI2
#endif
#endif


/* Define _CRTIMP */

#ifndef _CRTIMP
#ifdef	_NTSDK
/* definition compatible with NT SDK */
#define _CRTIMP
#else	/* ndef _NTSDK */
/* current definition */
#ifdef	_DLL
#define _CRTIMP __declspec(dllimport)
#else	/* ndef _DLL */
#define _CRTIMP
#endif	/* _DLL */
#endif	/* _NTSDK */
#endif	/* _CRTIMP */


/* Define __cdecl for non-Microsoft compilers */

#if	( !defined(_MSC_VER) && !defined(__cdecl) )
#define __cdecl
#endif


#ifndef _SIZE_T_DEFINED
typedef unsigned int size_t;
#define _SIZE_T_DEFINED
#endif


#ifndef _WCHAR_T_DEFINED
typedef unsigned short wchar_t;
#define _WCHAR_T_DEFINED
#endif


#ifndef _WCTYPE_T_DEFINED
typedef wchar_t wint_t;
typedef wchar_t wctype_t;
#define _WCTYPE_T_DEFINED
#endif


#ifndef _VA_LIST_DEFINED
#ifdef	_M_ALPHA
typedef struct {
	char *a0;	/* pointer to first homed integer argument */
	int offset;	/* byte offset of next parameter */
} va_list;
#else
typedef char *	va_list;
#endif
#define _VA_LIST_DEFINED
#endif


/* Buffered I/O macros */

#define BUFSIZ	512


/*
 * Number of supported streams. _NFILE is confusing and obsolete, but
 * supported anyway for backwards compatibility.
 */
#define _NFILE	    _NSTREAM_
#ifdef	_MT
#define _NSTREAM_   40
#else
#define _NSTREAM_   20
#endif


#define EOF	(-1)


#ifndef _FILE_DEFINED
struct _iobuf {
	char *_ptr;
	int   _cnt;
	char *_base;
	int   _flag;
	int   _file;
	int   _charbuf;
	int   _bufsiz;
	char *_tmpfname;
	};
typedef struct _iobuf FILE;
#define _FILE_DEFINED
#endif


/* Directory where temporary files may be created. */

#ifdef	_POSIX_
#define _P_tmpdir   "/"
#define _wP_tmpdir  L"/"
#else
#define _P_tmpdir   "\\"
#define _wP_tmpdir  L"\\"
#endif


/* L_tmpnam = size of P_tmpdir
 *	      + 1 (in case P_tmpdir does not end in "/")
 *	      + 12 (for the filename string)
 *	      + 1 (for the null terminator)
 */
#define L_tmpnam sizeof(_P_tmpdir)+12


#ifdef	_POSIX_
#define L_ctermid   9
#define L_cuserid   32
#endif


/* Seek method constants */

#define SEEK_CUR    1
#define SEEK_END    2
#define SEEK_SET    0


#define FILENAME_MAX	260
#define FOPEN_MAX	20
#define _SYS_OPEN	20
#define TMP_MAX 	32767


/* Define NULL pointer value */

#ifndef NULL
#ifdef	__cplusplus
#define NULL	0
#else
#define NULL	((void *)0)
#endif
#endif


/* Declare _iob[] array */

#ifndef _STDIO_DEFINED

#ifdef	_NTSDK

#ifdef	_DLL
extern FILE * _iob;
#else
extern FILE _iob[];
#endif

#else	/* ndef _NTSDK */

#if	defined(_DLL) && defined(_M_IX86)

#define _iob	(__p__iob())
_CRTIMP extern FILE * __cdecl __p__iob(void);

#else	/* !(defined(_DLL) && defined(_M_IX86)) */

_CRTIMP extern FILE _iob[];

#endif	/* defined(_DLL) && defined(_M_IX86) */

#endif	/* _NTSDK */

#endif	/* _STDIO_DEFINED */


/* Define file position type */

#ifndef _FPOS_T_DEFINED
typedef long fpos_t;
#define _FPOS_T_DEFINED
#endif


#define stdin  (&_iob[0])
#define stdout (&_iob[1])
#define stderr (&_iob[2])


#define _IOREAD 	0x0001
#define _IOWRT		0x0002

#define _IOFBF		0x0000
#define _IOLBF		0x0040
#define _IONBF		0x0004

#define _IOMYBUF	0x0008
#define _IOEOF		0x0010
#define _IOERR		0x0020
#define _IOSTRG 	0x0040
#define _IORW		0x0080
#ifdef _POSIX_
#define	_IOAPPEND	0x0200
#endif


/* Function prototypes */

#ifndef _STDIO_DEFINED

_CRTIMP int __cdecl _filbuf(FILE *);
_CRTIMP int __cdecl _flsbuf(int, FILE *);

#ifdef	_POSIX_
_CRTIMP FILE * __cdecl _fsopen(const char *, const char *);
#else
_CRTIMP FILE * __cdecl _fsopen(const char *, const char *, int);
#endif

_CRTIMP void __cdecl clearerr(FILE *);
_CRTIMP int __cdecl fclose(FILE *);
_CRTIMP int __cdecl _fcloseall(void);

#ifdef	_POSIX_
_CRTIMP FILE * __cdecl fdopen(int, const char *);
#else
_CRTIMP FILE * __cdecl _fdopen(int, const char *);
#endif

_CRTIMP int __cdecl feof(FILE *);
_CRTIMP int __cdecl ferror(FILE *);
_CRTIMP int __cdecl fflush(FILE *);
_CRTIMP int __cdecl fgetc(FILE *);
_CRTIMP int __cdecl _fgetchar(void);
_CRTIMP int __cdecl fgetpos(FILE *, fpos_t *);
_CRTIMP char * __cdecl fgets(char *, int, FILE *);

#ifdef	_POSIX_
_CRTIMP int __cdecl fileno(FILE *);
#else
_CRTIMP int __cdecl _fileno(FILE *);
#endif

_CRTIMP int __cdecl _flushall(void);
_CRTIMP FILE * __cdecl fopen(const char *, const char *);
_CRTIMP int __cdecl fprintf(FILE *, const char *, ...);
_CRTIMP int __cdecl fputc(int, FILE *);
_CRTIMP int __cdecl _fputchar(int);
_CRTIMP int __cdecl fputs(const char *, FILE *);
_CRTIMP size_t __cdecl fread(void *, size_t, size_t, FILE *);
_CRTIMP FILE * __cdecl freopen(const char *, const char *, FILE *);
_CRTIMP int __cdecl fscanf(FILE *, const char *, ...);
_CRTIMP int __cdecl fsetpos(FILE *, const fpos_t *);
_CRTIMP int __cdecl fseek(FILE *, long, int);
_CRTIMP long __cdecl ftell(FILE *);
_CRTIMP size_t __cdecl fwrite(const void *, size_t, size_t, FILE *);
_CRTIMP int __cdecl getc(FILE *);
_CRTIMP int __cdecl getchar(void);
_CRTIMP char * __cdecl gets(char *);
_CRTIMP int __cdecl _getw(FILE *);
_CRTIMP void __cdecl perror(const char *);
_CRTIMP int __cdecl _pclose(FILE *);
_CRTIMP FILE * __cdecl _popen(const char *, const char *);
_CRTIMP int __cdecl printf(const char *, ...);
_CRTIMP int __cdecl putc(int, FILE *);
_CRTIMP int __cdecl putchar(int);
_CRTIMP int __cdecl puts(const char *);
_CRTIMP int __cdecl _putw(int, FILE *);
_CRTIMP int __cdecl remove(const char *);
_CRTIMP int __cdecl rename(const char *, const char *);
_CRTIMP void __cdecl rewind(FILE *);
_CRTIMP int __cdecl _rmtmp(void);
_CRTIMP int __cdecl scanf(const char *, ...);
_CRTIMP void __cdecl setbuf(FILE *, char *);
_CRTIMP int __cdecl setvbuf(FILE *, char *, int, size_t);
_CRTIMP int __cdecl _snprintf(char *, size_t, const char *, ...);
_CRTIMP int __cdecl sprintf(char *, const char *, ...);
_CRTIMP int __cdecl sscanf(const char *, const char *, ...);
_CRTIMP char * __cdecl _tempnam(char *, char *);
_CRTIMP FILE * __cdecl tmpfile(void);
_CRTIMP char * __cdecl tmpnam(char *);
_CRTIMP int __cdecl ungetc(int, FILE *);
_CRTIMP int __cdecl _unlink(const char *);
_CRTIMP int __cdecl vfprintf(FILE *, const char *, va_list);
_CRTIMP int __cdecl vprintf(const char *, va_list);
_CRTIMP int __cdecl _vsnprintf(char *, size_t, const char *, va_list);
_CRTIMP int __cdecl vsprintf(char *, const char *, va_list);

#ifndef _WSTDIO_DEFINED

/* wide function prototypes, also declared in wchar.h  */

#ifndef WEOF
#define WEOF (wint_t)(0xFFFF)
#endif

#ifdef	_POSIX_
_CRTIMP FILE * __cdecl _wfsopen(const wchar_t *, const wchar_t *);
#else
_CRTIMP FILE * __cdecl _wfsopen(const wchar_t *, const wchar_t *, int);
#endif

_CRTIMP wint_t __cdecl fgetwc(FILE *);
_CRTIMP wint_t __cdecl _fgetwchar(void);
_CRTIMP wint_t __cdecl fputwc(wint_t, FILE *);
_CRTIMP wint_t __cdecl _fputwchar(wint_t);
_CRTIMP wint_t __cdecl getwc(FILE *);
_CRTIMP wint_t __cdecl getwchar(void);
_CRTIMP wint_t __cdecl putwc(wint_t, FILE *);
_CRTIMP wint_t __cdecl putwchar(wint_t);
_CRTIMP wint_t __cdecl ungetwc(wint_t, FILE *);

_CRTIMP wchar_t * __cdecl fgetws(wchar_t *, int, FILE *);
_CRTIMP int __cdecl fputws(const wchar_t *, FILE *);
_CRTIMP wchar_t * __cdecl _getws(wchar_t *);
_CRTIMP int __cdecl _putws(const wchar_t *);

_CRTIMP int __cdecl fwprintf(FILE *, const wchar_t *, ...);
_CRTIMP int __cdecl wprintf(const wchar_t *, ...);
_CRTIMP int __cdecl _snwprintf(wchar_t *, size_t, const wchar_t *, ...);
_CRTIMP int __cdecl swprintf(wchar_t *, const wchar_t *, ...);
_CRTIMP int __cdecl vfwprintf(FILE *, const wchar_t *, va_list);
_CRTIMP int __cdecl vwprintf(const wchar_t *, va_list);
_CRTIMP int __cdecl _vsnwprintf(wchar_t *, size_t, const wchar_t *, va_list);
_CRTIMP int __cdecl vswprintf(wchar_t *, const wchar_t *, va_list);
_CRTIMP int __cdecl fwscanf(FILE *, const wchar_t *, ...);
_CRTIMP int __cdecl swscanf(const wchar_t *, const wchar_t *, ...);
_CRTIMP int __cdecl wscanf(const wchar_t *, ...);

#define getwchar()		fgetwc(stdin)
#define putwchar(_c)		fputwc((_c),stdout)
#define getwc(_stm)		fgetwc(_stm)
#define putwc(_c,_stm)		fputwc(_c,_stm)

_CRTIMP FILE * __cdecl _wfdopen(int, const wchar_t *);
_CRTIMP FILE * __cdecl _wfopen(const wchar_t *, const wchar_t *);
_CRTIMP FILE * __cdecl _wfreopen(const wchar_t *, const wchar_t *, FILE *);
_CRTIMP void __cdecl _wperror(const wchar_t *);
_CRTIMP FILE * __cdecl _wpopen(const wchar_t *, const wchar_t *);
_CRTIMP int __cdecl _wremove(const wchar_t *);
_CRTIMP wchar_t * __cdecl _wtempnam(wchar_t *, wchar_t *);
_CRTIMP wchar_t * __cdecl _wtmpnam(wchar_t *);


#define _WSTDIO_DEFINED
#endif	/* _WSTDIO_DEFINED */

#define _STDIO_DEFINED
#endif	/* _STDIO_DEFINED */


/* Macro definitions */

#define feof(_stream)	  ((_stream)->_flag & _IOEOF)
#define ferror(_stream)   ((_stream)->_flag & _IOERR)
#define _fileno(_stream)  ((_stream)->_file)
#define getc(_stream)	  (--(_stream)->_cnt >= 0 \
		? 0xff & *(_stream)->_ptr++ : _filbuf(_stream))
#define putc(_c,_stream)  (--(_stream)->_cnt >= 0 \
		? 0xff & (*(_stream)->_ptr++ = (char)(_c)) :  _flsbuf((_c),(_stream)))
#define getchar()	  getc(stdin)
#define putchar(_c)	  putc((_c),stdout)



#ifdef	_MT
#undef	getc
#undef	putc
#undef	getchar
#undef	putchar
#endif


#if	!__STDC__ && !defined(_POSIX_)

/* Non-ANSI names for compatibility */

#define P_tmpdir  _P_tmpdir
#define SYS_OPEN  _SYS_OPEN

#ifdef	_NTSDK

#define fcloseall _fcloseall
#define fdopen	  _fdopen
#define fgetchar  _fgetchar
#define fileno	  _fileno
#define flushall  _flushall
#define fputchar  _fputchar
#define getw	  _getw
#define putw	  _putw
#define rmtmp	  _rmtmp
#define tempnam   _tempnam
#define unlink	  _unlink

#else	/* ndef _NTSDK */

_CRTIMP int __cdecl fcloseall(void);
_CRTIMP FILE * __cdecl fdopen(int, const char *);
_CRTIMP int __cdecl fgetchar(void);
_CRTIMP int __cdecl fileno(FILE *);
_CRTIMP int __cdecl flushall(void);
_CRTIMP int __cdecl fputchar(int);
_CRTIMP int __cdecl getw(FILE *);
_CRTIMP int __cdecl putw(int, FILE *);
_CRTIMP int __cdecl rmtmp(void);
_CRTIMP char * __cdecl tempnam(char *, char *);
_CRTIMP int __cdecl unlink(const char *);

#endif	/* _NTSDK */

#endif	/* __STDC__ */

#ifdef	__cplusplus
}
#endif


#endif	/* _INC_STDIO */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\tools\c932\inc\wcstr.h ===
/***
* wcstr.h - declarations for wide character string manipulation functions
*
*       Copyright (c) 1985-1992, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This file contains the function declarations for the string
*       manipulation functions.
*       [OBSOLETE][UNICODE/ISO]
*
*	WARNING: OBSOLETE FILE: use wchar.h/stdlib.h instead!!!
*	This file provided only for short-term compatibility.  It will
*	disappear in the near future after a brief transitional period.
*
****/

#ifndef _INC_WCSTR

#include <wchar.h>
#define wcswcs wcsstr

#define _wcscmpi _wcsicmp
#if !__STDC__
#define wcscmpi	_wcsicmp
#endif

/* from stdlib.h */
int    _CRTAPI1 wctomb(char *, wchar_t);
size_t _CRTAPI1 wcstombs(char*, const wchar_t *, size_t);

#define _INC_WCSTR
#endif  /* _INC_WCSTR */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\tools\c932\inc\tchar.h ===
/***
*tchar.h - definitions for generic international text functions
*
*	Copyright (c) 1991-1994, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	Definitions for generic international functions, mostly defines
*	which map string/formatted-io/ctype functions to char, wchar_t, or
*	MBCS versions.  To be used for compatibility between single-byte,
*	multi-byte and Unicode text models.
*
****/

#ifndef _INC_TCHAR
#define _INC_TCHAR

#ifdef	_MSC_VER
#pragma warning(disable:4505)		/* disable unwanted C++ /W4 warning */
/* #pragma warning(default:4505) */	/* use this to reenable, if necessary */
#endif	/* _MSC_VER */

#ifdef	__cplusplus
extern "C" {
#endif


/* Define __cdecl for non-Microsoft compilers */

#if	( !defined(_MSC_VER) && !defined(__cdecl) )
#define __cdecl
#endif


/* No Model-independent functions under Win32 */

#define __far


/* Default for Win32 is no inlining. Define _USE_INLINING to overide */

#ifndef _USE_INLINING
#define _NO_INLINING
#endif


/* No model-independent string functions for Win32 */

#define _ftcscat	_tcscat
#define _ftcschr	_tcschr
#define _ftcscmp	_tcscmp
#define _ftcscpy	_tcscpy
#define _ftcscspn	_tcscspn
#define _ftcslen	_tcslen
#define _ftcsncat	_tcsncat
#define _ftcsncmp	_tcsncmp
#define _ftcsncpy	_tcsncpy
#define _ftcspbrk	_tcspbrk
#define _ftcsrchr	_tcsrchr
#define _ftcsspn	_tcsspn
#define _ftcsstr	_tcsstr
#define _ftcstok	_tcstok

#define _ftcsdup	_tcsdup
#define _ftcsicmp	_tcsicmp
#define _ftcsnicmp	_tcsnicmp
#define _ftcsnset	_tcsnset
#define _ftcsrev	_tcsrev
#define _ftcsset	_tcsset


/* Redundant "logical-character" mappings */

#define _ftcsclen	_tcsclen
#define _ftcsnccat	_tcsnccat
#define _ftcsnccpy	_tcsnccpy
#define _ftcsnccmp	_tcsnccmp
#define _ftcsncicmp	_tcsncicmp
#define _ftcsncset	_tcsncset

#define	_ftcsdec	_tcsdec
#define	_ftcsinc	_tcsinc
#define	_ftcsnbcnt	_tcsnccnt
#define	_ftcsnccnt	_tcsnccnt
#define	_ftcsnextc	_tcsnextc
#define	_ftcsninc	_tcsninc
#define	_ftcsspnp	_tcsspnp

#define _ftcslwr	_tcslwr
#define _ftcsupr	_tcsupr

#define _ftclen		_tclen
#define	_ftccpy		_tccpy
#define _ftccmp		_tccmp


#ifdef	_UNICODE

/* ++++++++++++++++++++ UNICODE ++++++++++++++++++++ */

#include <wchar.h>


#ifndef _WCTYPE_T_DEFINED
typedef wchar_t wint_t;
typedef wchar_t wctype_t;
#define _WCTYPE_T_DEFINED
#endif

#ifndef __TCHAR_DEFINED
typedef wchar_t     _TCHAR;
typedef wchar_t     _TSCHAR;
typedef wchar_t     _TUCHAR;
typedef wchar_t     _TXCHAR;
typedef wint_t      _TINT;
#define __TCHAR_DEFINED
#endif

#ifndef _TCHAR_DEFINED
#if	!__STDC__
typedef wchar_t		TCHAR;
#endif
#define _TCHAR_DEFINED
#endif

#define _TEOF		WEOF

#define __T(x)		L ## x


/* Program */

#define _tmain      wmain
#define _tWinMain   wWinMain
#define _tenviron   _wenviron


/* Formatted i/o */
  
#define _tprintf	wprintf
#define _ftprintf	fwprintf
#define _stprintf	swprintf
#define _sntprintf	_snwprintf
#define _vtprintf	vwprintf
#define _vftprintf	vfwprintf
#define _vstprintf	vswprintf
#define _vsntprintf	_vsnwprintf
#define _tscanf		wscanf
#define _ftscanf	fwscanf
#define _stscanf	swscanf


/* Unformatted i/o */

#define _fgettc		fgetwc
#define _fgettchar	_fgetwchar
#define _fgetts		fgetws
#define _fputtc		fputwc
#define _fputtchar	_fputwchar
#define _fputts		fputws
#define _gettc		getwc
#define _gettchar	getwchar
#define _getts		_getws
#define _puttc		putwc
#define _puttchar	putwchar
#define _putts      _putws
#define _ungettc	ungetwc


/* String conversion functions */

#define _tcstod		wcstod
#define _tcstol		wcstol
#define _tcstoul	wcstoul

#define _itot       _itow
#define _ltot       _ltow
#define _ultot      _ultow
#define _ttoi       _wtoi
#define _ttol       _wtol


/* String functions */

#define _tcscat		wcscat
#define _tcschr		wcschr
#define _tcscmp		wcscmp
#define _tcscpy		wcscpy
#define _tcscspn	wcscspn
#define _tcslen		wcslen
#define _tcsncat	wcsncat
#define _tcsncmp	wcsncmp
#define _tcsncpy	wcsncpy
#define _tcspbrk	wcspbrk
#define _tcsrchr	wcsrchr
#define _tcsspn		wcsspn
#define _tcsstr		wcsstr
#define _tcstok		wcstok

#define _tcsdup		_wcsdup
#define _tcsicmp	_wcsicmp
#define _tcsnicmp	_wcsnicmp
#define _tcsnset	_wcsnset
#define _tcsrev		_wcsrev
#define _tcsset		_wcsset


/* Execute functions */

#define _texecl     _wexecl
#define _texecle    _wexecle
#define _texeclp    _wexeclp
#define _texeclpe   _wexeclpe
#define _texecv     _wexecv
#define _texecve    _wexecve
#define _texecvp    _wexecvp
#define _texecvpe   _wexecvpe

#define _tspawnl    _wspawnl
#define _tspawnle   _wspawnle
#define _tspawnlp   _wspawnlp
#define _tspawnlpe  _wspawnlpe
#define _tspawnv    _wspawnv
#define _tspawnve   _wspawnve
#define _tspawnvp   _wspawnvp
#define _tspawnvp   _wspawnvp
#define _tspawnvpe  _wspawnvpe

#define _tsystem    _wsystem


/* Time functions */

#define _tasctime   _wasctime
#define _tctime     _wctime
#define _tstrdate   _wstrdate
#define _tstrtime   _wstrtime
#define _tutime     _wutime
#define _tcsftime   wcsftime


/* Directory functions */

#define _tchdir     _wchdir
#define _tgetcwd    _wgetcwd
#define _tgetdcwd   _wgetdcwd
#define _tmkdir     _wmkdir
#define _trmdir     _wrmdir


/* Environment/Path functions */

#define _tfullpath  _wfullpath
#define _tgetenv    _wgetenv
#define _tmakepath  _wmakepath
#define _tputenv    _wputenv
#define _tsearchenv _wsearchenv
#define _tsplitpath _wsplitpath


/* Stdio functions */

#define _tfdopen    _wfdopen
#define _tfsopen    _wfsopen
#define _tfopen     _wfopen
#define _tfreopen   _wfreopen
#define _tperror    _wperror
#define _tpopen     _wpopen
#define _ttempnam   _wtempnam
#define _ttmpnam    _wtmpnam


/* Io functions */

#define _taccess    _waccess
#define _tchmod     _wchmod
#define _tcreat     _wcreat
#define _tfindfirst _wfindfirst
#define _tfindnext  _wfindnext
#define _tmktemp    _wmktemp
#define _topen      _wopen
#define _tremove    _wremove
#define _trename    _wrename
#define _tsopen     _wsopen
#define _tunlink    _wunlink

#define _tfinddata_t    _wfinddata_t


/* Stat functions */

#define _tstat      _wstat


/* Setlocale functions */

#define _tsetlocale _wsetlocale


/* Redundant "logical-character" mappings */

#define _tcsclen	wcslen
#define _tcsnccat	wcsncat
#define _tcsnccpy	wcsncpy
#define _tcsnccmp	wcsncmp
#define _tcsncicmp	_wcsnicmp
#define _tcsncset	_wcsnset

#define	_tcsdec		_wcsdec
#define	_tcsinc		_wcsinc
#define	_tcsnbcnt	_wcsncnt
#define	_tcsnccnt	_wcsncnt
#define	_tcsnextc	_wcsnextc
#define	_tcsninc	_wcsninc
#define	_tcsspnp	_wcsspnp

#define _tcslwr		_wcslwr
#define _tcsupr		_wcsupr
#define _tcsxfrm	wcsxfrm
#define _tcscoll	wcscoll
#define _tcsicoll	_wcsicoll
#define _tcsnicoll	_wcsnicoll

#if	__STDC__ || defined(_NO_INLINING)
#define _tclen(_pc)	(1)
#define _tccpy(_pc1,_cpc2) ((*(_pc1) = *(_cpc2)))
#define _tccmp(_cpc1,_cpc2) ((*(_cpc1))-(*(_cpc2)))
#else	/* __STDC__ */
__inline size_t __cdecl _tclen(const wchar_t *_cpc) { return (_cpc,1); }
__inline void __cdecl _tccpy(wchar_t *_pc1, const wchar_t *_cpc2) { *_pc1 = (wchar_t)*_cpc2; }
__inline int __cdecl _tccmp(const wchar_t *_cpc1, const wchar_t *_cpc2) { return (int) ((*_cpc1)-(*_cpc2)); }
#endif	/* __STDC__ */


/* ctype functions */

#define _istalnum	iswalnum
#define _istalpha	iswalpha
#define _istascii	iswascii
#define _istcntrl	iswcntrl
#define _istdigit	iswdigit
#define _istgraph	iswgraph
#define _istlower	iswlower
#define _istprint	iswprint
#define _istpunct	iswpunct
#define _istspace	iswspace
#define _istupper	iswupper
#define _istxdigit	iswxdigit

#define _totupper	towupper
#define _totlower	towlower

#define _istlegal(_c)   (1)
#define _istlead(_c)    (0)
#define _istleadbyte(_c)    (0)


#if	__STDC__ || defined(_NO_INLINING)
#define _wcsdec(_cpc, _pc) ((_pc)-1)
#define _wcsinc(_pc)	((_pc)+1)
#define _wcsnextc(_cpc)	((unsigned int) *(_cpc))
#define _wcsninc(_pc, _sz) (((_pc)+(_sz)))
#define _wcsncnt(_cpc, _sz) ((wcslen(_cpc)>_sz) ? _sz : wcslen(_cpc))
#define _wcsspnp(_cpc1, _cpc2) ((*((_cpc1)+wcsspn(_cpc1,_cpc2))) ? ((_cpc1)+wcsspn(_cpc1,_cpc2)) : NULL)
#else	/* __STDC__ */
__inline wchar_t * __cdecl _wcsdec(const wchar_t * _cpc, wchar_t * _pc) { return (wchar_t *)(_cpc,(_pc-1)); }
__inline wchar_t * __cdecl _wcsinc(const wchar_t * _pc) { return (wchar_t *)(_pc+1); }
__inline unsigned int __cdecl _wcsnextc(const wchar_t * _cpc) { return (unsigned int)*_cpc; }
__inline wchar_t * __cdecl _wcsninc(const wchar_t * _pc, size_t _sz) { return (wchar_t *)(_pc+_sz); }
__inline size_t __cdecl _wcsncnt( const wchar_t * _cpc, size_t _sz) { size_t len; len = wcslen(_cpc); return (len>_sz) ? _sz : len; }
__inline wchar_t * __cdecl _wcsspnp( const wchar_t * _cpc1, const wchar_t * _cpc2) { return (*(_cpc1 += wcsspn(_cpc1,_cpc2))!='\0') ? (wchar_t*)_cpc1 : NULL; }
#endif	/* __STDC__ */


#else	/* ndef _UNICODE */

/* ++++++++++++++++++++ SBCS and MBCS ++++++++++++++++++++ */

#include <string.h>


#define _TEOF		EOF

#define __T(x)		x


/* Program */

#define _tmain      main
#define _tWinMain   WinMain
#ifdef	_POSIX_
#define _tenviron   environ
#else
#define _tenviron  _environ
#endif


/* Formatted i/o */

#define _tprintf    printf
#define _ftprintf   fprintf
#define _stprintf   sprintf
#define _sntprintf  _snprintf
#define _vtprintf   vprintf
#define _vftprintf  vfprintf
#define _vstprintf  vsprintf
#define _vsntprintf _vsnprintf
#define _tscanf     scanf
#define _ftscanf    fscanf
#define _stscanf    sscanf


/* Unformatted i/o */

#define _fgettc     fgetc
#define _fgettchar  _fgetchar
#define _fgetts     fgets
#define _fputtc     fputc
#define _fputtchar  _fputchar
#define _fputts     fputs
#define _gettc      getc
#define _gettchar   getchar
#define _getts		gets
#define _puttc      putc
#define _puttchar   putchar
#define _putts      puts
#define _ungettc    ungetc


/* String conversion functions */

#define _tcstod     strtod
#define _tcstol     strtol
#define _tcstoul    strtoul

#define _itot       _itoa
#define _ltot       _ltoa
#define _ultot      _ultoa
#define _ttoi       atoi
#define _ttol       atol


/* String functions */

#define _tcscat     strcat
#define _tcscpy     strcpy
#define _tcslen     strlen
#define _tcsxfrm    strxfrm
#define _tcscoll	strcoll

#define _tcsdup		_strdup
#define _tcsicoll	_stricoll
#define _tcsnicoll	_strnicoll


/* Execute functions */

#define _texecl     _execl
#define _texecle    _execle
#define _texeclp    _execlp
#define _texeclpe   _execlpe
#define _texecv     _execv
#define _texecve    _execve
#define _texecvp    _execvp
#define _texecvpe   _execvpe

#define _tspawnl    _spawnl
#define _tspawnle   _spawnle
#define _tspawnlp   _spawnlp
#define _tspawnlpe  _spawnlpe
#define _tspawnv    _spawnv
#define _tspawnve   _spawnve
#define _tspawnvp   _spawnvp
#define _tspawnvpe  _spawnvpe

#define _tsystem    system


/* Time functions */

#define _tasctime   asctime
#define _tctime     ctime
#define _tstrdate   _strdate
#define _tstrtime   _strtime
#define _tutime     _utime
#define _tcsftime   strftime


/* Directory functions */

#define _tchdir     _chdir
#define _tgetcwd    _getcwd
#define _tgetdcwd   _getdcwd
#define _tmkdir     _mkdir
#define _trmdir     _rmdir


/* Environment/Path functions */

#define _tfullpath  _fullpath
#define _tgetenv    getenv
#define _tmakepath  _makepath
#define _tputenv    _putenv
#define _tsearchenv _searchenv
#define _tsplitpath _splitpath


/* Stdio functions */

#ifdef	_POSIX_
#define _tfdopen    fdopen
#else
#define _tfdopen    _fdopen
#endif
#define _tfsopen    _fsopen
#define _tfopen     fopen
#define _tfreopen   freopen
#define _tperror    perror
#define _tpopen     _popen
#define _ttempnam   _tempnam
#define _ttmpnam    tmpnam


/* Io functions */

#define _taccess    _access
#define _tchmod     _chmod
#define _tcreat     _creat
#define _tfindfirst _findfirst
#define _tfindnext  _findnext
#define _tmktemp    _mktemp
#define _topen      _open
#define _tremove    remove
#define _trename    rename
#define _tsopen     _sopen
#define _tunlink    _unlink

#define _tfinddata_t    _finddata_t


/* ctype functions */

#define _istascii   isascii
#define _istcntrl   iscntrl
#define _istxdigit  isxdigit


/* Stat functions */

#define _tstat      _stat


/* Setlocale functions */

#define _tsetlocale setlocale


#ifdef _MBCS

/* ++++++++++++++++++++ MBCS ++++++++++++++++++++ */


#include <mbstring.h>


#ifndef __TCHAR_DEFINED
typedef char            _TCHAR;
typedef signed char     _TSCHAR;
typedef unsigned char   _TUCHAR;
typedef unsigned char   _TXCHAR;
typedef unsigned int    _TINT;
#define __TCHAR_DEFINED
#endif

#ifndef _TCHAR_DEFINED
#if	!__STDC__
typedef char            TCHAR;
#endif
#define _TCHAR_DEFINED
#endif


#ifdef _MB_MAP_DIRECT

/* map directly to MBCS functions, use _TXCHAR */


/* String functions */

#define _tcschr     _mbschr
#define _tcscmp     _mbscmp
#define _tcscspn    _mbscspn
#define _tcsncat    _mbsnbcat
#define _tcsncmp    _mbsnbcmp
#define _tcsncpy    _mbsnbcpy
#define _tcspbrk    _mbspbrk
#define _tcsrchr    _mbsrchr
#define _tcsspn     _mbsspn
#define _tcsstr     _mbsstr
#define _tcstok     _mbstok

#define _tcsicmp    _mbsicmp
#define _tcsnicmp   _mbsnbicmp
#define _tcsnset    _mbsnbset
#define _tcsrev     _mbsrev
#define _tcsset     _mbsset


/* "logical-character" mappings */

#define _tcsclen    _mbslen
#define _tcsnccat   _mbsncat
#define _tcsnccpy   _mbsncpy
#define _tcsnccmp   _mbsncmp
#define _tcsncicmp  _mbsnicmp
#define _tcsncset   _mbsnset


/* MBCS-specific mappings */

#define	_tcsdec     _mbsdec
#define	_tcsinc     _mbsinc
#define	_tcsnbcnt   _mbsnbcnt
#define	_tcsnccnt   _mbsnccnt
#define	_tcsnextc   _mbsnextc
#define	_tcsninc    _mbsninc
#define	_tcsspnp    _mbsspnp

#define _tcslwr     _mbslwr
#define _tcsupr     _mbsupr

#define _tclen      _mbclen
#define _tccpy      _mbccpy

#define	_tccmp(_cpuc1,_cpuc2)   _tcsnccmp(_cpuc1,_cpuc2,1)


#else /* _MB_MAP_DIRECT */

/* map through type-safe thunks to MBCS functions, use _TCHAR */


#if	__STDC__ || defined(_NO_INLINING)


/* String functions */

_CRTIMP char * __cdecl _tcschr(const char *, unsigned int);
_CRTIMP int __cdecl _tcscmp(const char *, const char *);
_CRTIMP size_t __cdecl _tcscspn(const char *, const char *);
_CRTIMP char * __cdecl _tcsncat(char *, const char *, size_t);
_CRTIMP int __cdecl _tcsncmp(const char *, const char *, size_t);
_CRTIMP char * __cdecl _tcsncpy(char *, const char *, size_t);
_CRTIMP char * __cdecl _tcspbrk(const char *, const char *);
_CRTIMP char * __cdecl _tcsrchr(const char *, int);
_CRTIMP size_t __cdecl _tcsspn(const char *, const char *);
_CRTIMP char * __cdecl _tcsstr(const char *, const char *);
_CRTIMP char * __cdecl _tcstok(char *, const char *);

_CRTIMP int __cdecl _tcsicmp(const char *, const char *);
_CRTIMP int __cdecl _tcsnicmp(const char *, const char *, size_t);
_CRTIMP char * __cdecl _tcsnset(char *, unsigned int, size_t);
_CRTIMP char * __cdecl _tcsrev(char *);
_CRTIMP char * __cdecl _tcsset(char *, unsigned int);


/* "logical-character" mappings */

_CRTIMP size_t __cdecl _tcsclen(const char *);
_CRTIMP char * __cdecl _tcsnccat(char *, const char *, size_t);
_CRTIMP char * __cdecl _tcsnccpy(char *, const char *, size_t);
_CRTIMP int __cdecl _tcsnccmp(const char *, const char *, size_t);
_CRTIMP int __cdecl _tcsncicmp(const char *, const char *, size_t);
_CRTIMP char * __cdecl _tcsncset(char *, unsigned int, size_t);


/* MBCS-specific mappings */

_CRTIMP char * __cdecl _tcsdec(const char *, const char *);
_CRTIMP char * __cdecl _tcsinc(const char *);
_CRTIMP size_t __cdecl _tcsnbcnt(const char *, size_t);
_CRTIMP size_t __cdecl _tcsnccnt(const char *, size_t);
_CRTIMP unsigned int __cdecl _tcsnextc (const char *);
_CRTIMP char * __cdecl _tcsninc(const char *, size_t);
_CRTIMP char * __cdecl _tcsspnp(const char *, const char *);

_CRTIMP char * __cdecl _tcslwr(char *);
_CRTIMP char * __cdecl _tcsupr(char *);

_CRTIMP size_t __cdecl _tclen(const char *);
_CRTIMP void __cdecl _tccpy(char *, const char *);


#else	/* __STDC__ */


#define _PUC    unsigned char *
#define _CPUC   const unsigned char *
#define _PC     char *
#define _CPC    const char *
#define _UI     unsigned int


/* String functions */

__inline _PC _tcschr(_CPC _s1,_UI _c) {return (_PC)_mbschr((_CPUC)_s1,_c);}
__inline int _tcscmp(_CPC _s1,_CPC _s2) {return _mbscmp((_CPUC)_s1,(_CPUC)_s2);}
__inline size_t _tcscspn(_CPC _s1,_CPC _s2) {return _mbscspn((_CPUC)_s1,(_CPUC)_s2);}
__inline _PC _tcsncat(_PC _s1,_CPC _s2,size_t _n) {return (_PC)_mbsnbcat((_PUC)_s1,(_CPUC)_s2,_n);}
__inline int _tcsncmp(_CPC _s1,_CPC _s2,size_t _n) {return _mbsnbcmp((_CPUC)_s1,(_CPUC)_s2,_n);}
__inline _PC _tcsncpy(_PC _s1,_CPC _s2,size_t _n) {return (_PC)_mbsnbcpy((_PUC)_s1,(_CPUC)_s2,_n);}
__inline _PC _tcspbrk(_CPC _s1,_CPC _s2) {return (_PC)_mbspbrk((_CPUC)_s1,(_CPUC)_s2);}
__inline _PC _tcsrchr(_CPC _s1,_UI _c) {return (_PC)_mbsrchr((_CPUC)_s1,_c);}
__inline size_t _tcsspn(_CPC _s1,_CPC _s2) {return _mbsspn((_CPUC)_s1,(_CPUC)_s2);}
__inline _PC _tcsstr(_CPC _s1,_CPC _s2) {return (_PC)_mbsstr((_CPUC)_s1,(_CPUC)_s2);}
__inline _PC _tcstok(_PC _s1,_CPC _s2) {return (_PC)_mbstok((_PUC)_s1,(_CPUC)_s2);}

__inline int _tcsicmp(_CPC _s1,_CPC _s2) {return _mbsicmp((_CPUC)_s1,(_CPUC)_s2);}
__inline int _tcsnicmp(_CPC _s1,_CPC _s2,size_t _n) {return _mbsnbicmp((_CPUC)_s1,(_CPUC)_s2,_n);}
__inline _PC _tcsnset(_PC _s1,_UI _c,size_t _n) {return (_PC)_mbsnbset((_PUC)_s1,_c,_n);}
__inline _PC _tcsrev(_PC _s1) {return (_PC)_mbsrev((_PUC)_s1);}
__inline _PC _tcsset(_PC _s1,_UI _c) {return (_PC)_mbsset((_PUC)_s1,_c);}


/* "logical-character" mappings */

__inline size_t _tcsclen(_CPC _s1) {return _mbslen((_CPUC)_s1);}
__inline _PC _tcsnccat(_PC _s1,_CPC _s2,size_t _n) {return (_PC)_mbsncat((_PUC)_s1,(_CPUC)_s2,_n);}
__inline _PC _tcsnccpy(_PC _s1,_CPC _s2,size_t _n) {return (_PC)_mbsncpy((_PUC)_s1,(_CPUC)_s2,_n);}
__inline int _tcsnccmp(_CPC _s1,_CPC _s2,size_t _n) {return _mbsncmp((_CPUC)_s1,(_CPUC)_s2,_n);}
__inline int _tcsncicmp(_CPC _s1,_CPC _s2,size_t _n) {return _mbsnicmp((_CPUC)_s1,(_CPUC)_s2,_n);}
__inline _PC _tcsncset(_PC _s1,_UI _c,size_t _n) {return (_PC)_mbsnset((_PUC)_s1,_c,_n);}


/* MBCS-specific mappings */

__inline _PC _tcsdec(_CPC _s1,_CPC _s2) {return (_PC)_mbsdec((_CPUC)_s1,(_CPUC)_s2);}
__inline _PC _tcsinc(_CPC _s1) {return (_PC)_mbsinc((_CPUC)_s1);}
__inline size_t _tcsnbcnt(_CPC _s1,size_t _n) {return _mbsnbcnt((_CPUC)_s1,_n);}
__inline size_t _tcsnccnt(_CPC _s1,size_t _n) {return _mbsnccnt((_CPUC)_s1,_n);}
__inline _PC _tcsninc(_CPC _s1,size_t _n) {return (_PC)_mbsninc((_CPUC)_s1,_n);}
__inline _PC _tcsspnp(_CPC _s1,_CPC _s2) {return (_PC)_mbsspnp((_CPUC)_s1,(_CPUC)_s2);}
__inline _PC _tcslwr(_PC _s1) {return (_PC)_mbslwr((_PUC)_s1);}
__inline _PC _tcsupr(_PC _s1) {return (_PC)_mbsupr((_PUC)_s1);}

__inline size_t _tclen(_CPC _s1) {return _mbclen((_CPUC)_s1);}
__inline void _tccpy(_PC _s1,_CPC _s2) {_mbccpy((_PUC)_s1,(_CPUC)_s2); return;}


/* inline helper */
__inline _UI _tcsnextc(_CPC _s1) {_UI _n=0; if (_ismbblead((_UI)(_PUC)*_s1)) _n=((_UI)*_s1++)<<8; _n+=(_UI)*_s1; return(_n);}


#endif /* __STDC__ */

#endif /* _MB_MAP_DIRECT */


/* MBCS-specific mappings */

#define	_tccmp(_cp1,_cp2)   _tcsnccmp(_cp1,_cp2,1)


/* ctype functions */

#define _istalnum   _ismbcalnum
#define _istalpha   _ismbcalpha
#define _istdigit   _ismbcdigit
#define _istgraph   _ismbcgraph
#define _istlegal   _ismbclegal
#define _istlower   _ismbclower
#define _istprint   _ismbcprint
#define _istpunct   _ismbcpunct
#define _istspace   _ismbcspace
#define _istupper   _ismbcupper

#define _totupper   _mbctoupper
#define _totlower   _mbctolower

#define _istlead    _ismbblead
#define _istleadbyte    isleadbyte

#else	/* !_MBCS */

/* ++++++++++++++++++++ SBCS ++++++++++++++++++++ */


#ifndef __TCHAR_DEFINED
typedef char            _TCHAR;
typedef signed char     _TSCHAR;
typedef unsigned char   _TUCHAR;
typedef char            _TXCHAR;
typedef int             _TINT;
#define __TCHAR_DEFINED
#endif

#ifndef _TCHAR_DEFINED
#if	!__STDC__
typedef char            TCHAR;
#endif
#define _TCHAR_DEFINED
#endif


/* String functions */

#define _tcschr		strchr
#define _tcscmp		strcmp
#define _tcscspn	strcspn
#define _tcsncat	strncat
#define _tcsncmp	strncmp
#define _tcsncpy	strncpy
#define _tcspbrk	strpbrk
#define _tcsrchr	strrchr
#define _tcsspn		strspn
#define _tcsstr		strstr
#define _tcstok		strtok

#define _tcsicmp	_stricmp
#define _tcsnicmp	_strnicmp
#define _tcsnset	_strnset
#define _tcsrev		_strrev
#define _tcsset		_strset


/* "logical-character" mappings */

#define _tcsclen	strlen
#define _tcsnccat	strncat
#define _tcsnccpy	strncpy
#define _tcsnccmp	strncmp
#define _tcsncicmp	_strnicmp
#define _tcsncset	_strnset


/* MBCS-specific functions */

#define	_tcsdec		_strdec
#define	_tcsinc		_strinc
#define	_tcsnbcnt	_strncnt
#define	_tcsnccnt	_strncnt
#define	_tcsnextc	_strnextc
#define	_tcsninc	_strninc
#define	_tcsspnp	_strspnp

#define _tcslwr		_strlwr
#define _tcsupr		_strupr
#define _tcsxfrm	strxfrm

#define _istlead(_c)    (0)
#define _istleadbyte(_c)    (0)

#if	__STDC__ || defined(_NO_INLINING)
#define _tclen(_pc)	(1)
#define _tccpy(_pc1,_cpc2) (*(_pc1) = *(_cpc2))
#define _tccmp(_cpc1,_cpc2) (((unsigned char)*(_cpc1))-((unsigned char)*(_cpc2)))
#else	/* __STDC__ */
__inline size_t __cdecl _tclen(const char *_cpc) { return (_cpc,1); }
__inline void __cdecl _tccpy(char *_pc1, const char *_cpc2) { *_pc1 = *_cpc2; }
__inline int __cdecl _tccmp(const char *_cpc1, const char *_cpc2) { return (int) (((unsigned char)*_cpc1)-((unsigned char)*_cpc2)); }
#endif	/* __STDC__ */


/* ctype-functions */

#define _istalnum	isalnum
#define _istalpha	isalpha
#define _istdigit	isdigit
#define _istgraph	isgraph
#define _istlower	islower
#define _istprint	isprint
#define _istpunct	ispunct
#define _istspace	isspace
#define _istupper	isupper

#define _totupper	toupper
#define _totlower	tolower

#define _istlegal(_c)   (1)


/* the following is optional if functional versions are available */

/* define NULL pointer value */

#ifndef NULL
#ifdef __cplusplus
#define NULL	0
#else
#define NULL	((void *)0)
#endif
#endif


#if	__STDC__ || defined(_NO_INLINING)
#define _strdec(_cpc, _pc) ((_pc)-1)
#define _strinc(_pc)	((_pc)+1)
#define _strnextc(_cpc)	((unsigned int) *(_cpc))
#define _strninc(_pc, _sz) (((_pc)+(_sz)))
#define _strncnt(_cpc, _sz) ((strlen(_cpc)>_sz) ? _sz : strlen(_cpc))
#define _strspnp(_cpc1, _cpc2) ((*((_cpc1)+strspn(_cpc1,_cpc2))) ? ((_cpc1)+strspn(_cpc1,_cpc2)) : NULL)
#else	/* __STDC__ */
__inline char * __cdecl _strdec(const char * _cpc, char * _pc) { return (char *)(_cpc,(_pc-1)); }
__inline char * __cdecl _strinc(const char * _pc) { return (char *)(_pc+1); }
__inline unsigned int __cdecl _strnextc(const char * _cpc) { return (unsigned int)*_cpc; }
__inline char * __cdecl _strninc(const char * _pc, size_t _sz) { return (char *)(_pc+_sz); }
__inline size_t __cdecl _strncnt( const char * _cpc, size_t _sz) { size_t len; len = strlen(_cpc); return (len>_sz) ? _sz : len; }
__inline char * __cdecl _strspnp( const char * _cpc1, const char * _cpc2) { return (*(_cpc1 += strspn(_cpc1,_cpc2))!='\0') ? (char*)_cpc1 : NULL; }
#endif	/* __STDC__ */


#endif	/* _MBCS */

#endif	/* _UNICODE */


/* Generic text macros to be used with string literals and character constants.
   Will also allow symbolic constants that resolve to same. */
   
#define _T(x)		__T(x)
#define _TEXT(x)	__T(x)


#ifdef __cplusplus
}
#endif

#endif	/* _INC_TCHAR */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\tools\c932\inc\winmm.h ===
/*++ BUILD Version: 0002    Increment this if a change has global effects

Copyright (c) 1990-1993, Microsoft Corporation

Module Name:

    winmm.h

Abstract:

    This include file defines all the support for Multimedia applications.

    24-Apr-91 MMTIME structure added. NigelT.
    3-Dec-91  Wholesale changes.  LaurieGr.
    30-Jan-92 Avoid things only in portwin32 LPARAM,HFILE,WPARAM  LaurieGr
    19-Feb-92 Brave attempt to avoid collisions with rest of NT LaurieGr
    26-Feb-92 Moved to mmsystem.h - RobinSp.

--*/


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\tools\c932\inc\varargs.h ===
/***
*varargs.h - XENIX style macros for variable argument functions
*
*	Copyright (c) 1985-1994, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	This file defines XENIX style macros for accessing arguments of a
*	function which takes a variable number of arguments.
*	[System V]
*
****/

#ifndef _INC_VARARGS
#define _INC_VARARGS

#ifdef __cplusplus
extern "C" {
#endif

#if	__STDC__
#error varargs.h incompatible with ANSI (use stdarg.h)
#endif


#ifndef _VA_LIST_DEFINED

#ifdef _M_ALPHA
typedef struct {
    char *a0;           /* pointer to first homed integer argument */
    int offset;         /* byte offset of next parameter */
} va_list;
#else
typedef char *va_list;
#endif

#define _VA_LIST_DEFINED
#endif


#if	defined(_M_IX86)

/*
 * define a macro to compute the size of a type, variable or expression,
 * rounded up to the nearest multiple of sizeof(int). This number is its
 * size as function argument (Intel architecture). Note that the macro
 * depends on sizeof(int) being a power of 2!
 */
#define _INTSIZEOF(n)	 ( (sizeof(n) + sizeof(int) - 1) & ~(sizeof(int) - 1) )

#define va_dcl va_list va_alist;
#define va_start(ap) ap = (va_list)&va_alist
#define va_arg(ap,t)    ( *(t *)((ap += _INTSIZEOF(t)) - _INTSIZEOF(t)) )
#define va_end(ap) ap = (va_list)0


#elif	defined(_M_MRX000)	/* _MIPS_ */


#define va_dcl int va_alist;
#define va_start(list) list = (char *) &va_alist
#define va_end(list)
#define va_arg(list, mode) ((mode *)(list =\
 (char *) ((((int)list + (__builtin_alignof(mode)<=4?3:7)) &\
 (__builtin_alignof(mode)<=4?-4:-8))+sizeof(mode))))[-1]
/*  +++++++++++++++++++++++++++++++++++++++++++
    Because of parameter passing conventions in C:
    use mode=int for char, and short types
    use mode=double for float types
    use a pointer for array types
    +++++++++++++++++++++++++++++++++++++++++++ */


#elif	defined(_M_ALPHA)

/*
 * The Alpha compiler supports two builtin functions that are used to
 * implement stdarg/varargs.  The __builtin_va_start function is used
 * by va_start to initialize the data structure that locates the next
 * argument.  The __builtin_isfloat function is used by va_arg to pick
 * which part of the home area a given register argument is stored in.
 * The home area is where up to six integer and/or six floating point
 * register arguments are stored down (so they can also be referenced
 * by a pointer like any arguments passed on the stack).
 */
extern void * __builtin_va_start(va_list, ...);

#define va_dcl long va_alist;
#define va_start(list) __builtin_va_start(list, va_alist, 0)
#define va_end(list)
#define va_arg(list, mode) \
    ( *(        ((list).offset += ((int)sizeof(mode) + 7) & -8) , \
        (mode *)((list).a0 + (list).offset - \
                    ((__builtin_isfloat(mode) && (list).offset <= (6 * 8)) ? \
                        (6 * 8) + 8 : ((int)sizeof(mode) + 7) & -8) \
                ) \
       ) \
    )


#else


/* A guess at the proper definitions for other platforms */

#define _INTSIZEOF(n)	 ( (sizeof(n) + sizeof(int) - 1) & ~(sizeof(int) - 1) )

#define va_dcl va_list va_alist;
#define va_start(ap) ap = (va_list)&va_alist
#define va_arg(ap,t) ( *(t *)((ap += _INTSIZEOF(t)) - _INTSIZEOF(t)) )
#define va_end(ap) ap = (va_list)0


#endif


#ifdef __cplusplus
}
#endif

#endif	/* _INC_VARARGS */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\tools\c932\inc\string.h ===
/***
*string.h - declarations for string manipulation functions
*
*	Copyright (c) 1985-1994, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	This file contains the function declarations for the string
*	manipulation functions.
*	[ANSI/System V]
*
****/

#ifndef _INC_STRING
#define _INC_STRING

#ifdef __cplusplus
extern "C" {
#endif


/* Define _CRTAPI1 (for compatibility with the NT SDK) */

#ifndef _CRTAPI1
#if	( (_MSC_VER >= 800) && (_M_IX86 >= 300) )
#define _CRTAPI1 __cdecl
#else
#define _CRTAPI1
#endif
#endif


/* Define _CRTAPI2 (for compatibility with the NT SDK) */

#ifndef _CRTAPI2
#if	( (_MSC_VER >= 800) && (_M_IX86 >= 300) )
#define _CRTAPI2 __cdecl
#else
#define _CRTAPI2
#endif
#endif


/* Define _CRTIMP */

#ifndef _CRTIMP
#ifdef	_NTSDK
/* definition compatible with NT SDK */
#define _CRTIMP
#else	/* ndef _NTSDK */
/* current definition */
#ifdef	_DLL
#define _CRTIMP __declspec(dllimport)
#else	/* ndef _DLL */
#define _CRTIMP
#endif	/* _DLL */
#endif	/* _NTSDK */
#endif	/* _CRTIMP */


/* Define __cdecl for non-Microsoft compilers */

#if	( !defined(_MSC_VER) && !defined(__cdecl) )
#define __cdecl
#endif


#ifndef _SIZE_T_DEFINED
typedef unsigned int size_t;
#define _SIZE_T_DEFINED
#endif


#ifndef _WCHAR_T_DEFINED
typedef unsigned short wchar_t;
#define _WCHAR_T_DEFINED
#endif

#ifndef _NLSCMP_DEFINED
#define _NLSCMPERROR    2147483647	/* currently == INT_MAX */
#define _NLSCMP_DEFINED
#endif

/* Define NULL pointer value */

#ifndef NULL
#ifdef __cplusplus
#define NULL	0
#else
#define NULL	((void *)0)
#endif
#endif


/* Function prototypes */

_CRTIMP void * __cdecl _memccpy(void *, const void *, int, unsigned int);
_CRTIMP void * __cdecl memchr(const void *, int, size_t);
	int __cdecl memcmp(const void *, const void *, size_t);
_CRTIMP int __cdecl _memicmp(const void *, const void *, unsigned int);
	void * __cdecl memcpy(void *, const void *, size_t);
#ifdef	_M_ALPHA
	/* memmove is available as an intrinsic in the Alpha compiler */
	void * __cdecl memmove(void *, const void *, size_t);
#else
_CRTIMP void * __cdecl memmove(void *, const void *, size_t);
#endif
	void * __cdecl memset(void *, int, size_t);
	char * __cdecl strcat(char *, const char *);
_CRTIMP char * __cdecl strchr(const char *, int);
	int __cdecl strcmp(const char *, const char *);
_CRTIMP int __cdecl _strcmpi(const char *, const char *);
_CRTIMP int __cdecl _stricmp(const char *, const char *);
_CRTIMP int __cdecl strcoll(const char *, const char *);
_CRTIMP int __cdecl _stricoll(const char *, const char *);
_CRTIMP int __cdecl _strnicoll(const char *, const char *, size_t);
	char * __cdecl strcpy(char *, const char *);
_CRTIMP size_t __cdecl strcspn(const char *, const char *);
_CRTIMP char * __cdecl _strdup(const char *);
_CRTIMP char * __cdecl _strerror(const char *);
_CRTIMP char * __cdecl strerror(int);
	size_t __cdecl strlen(const char *);
_CRTIMP char * __cdecl _strlwr(char *);
_CRTIMP char * __cdecl strncat(char *, const char *, size_t);
_CRTIMP int __cdecl strncmp(const char *, const char *, size_t);
_CRTIMP int __cdecl _strnicmp(const char *, const char *, size_t);
_CRTIMP char * __cdecl strncpy(char *, const char *, size_t);
_CRTIMP char * __cdecl _strnset(char *, int, size_t);
_CRTIMP char * __cdecl strpbrk(const char *, const char *);
_CRTIMP char * __cdecl strrchr(const char *, int);
_CRTIMP char * __cdecl _strrev(char *);
	char * __cdecl _strset(char *, int);
_CRTIMP size_t __cdecl strspn(const char *, const char *);
_CRTIMP char * __cdecl strstr(const char *, const char *);
_CRTIMP char * __cdecl strtok(char *, const char *);
_CRTIMP char * __cdecl _strupr(char *);
_CRTIMP size_t __cdecl strxfrm (char *, const char *, size_t);

#if	!__STDC__

#ifdef	_NTSDK

/* Non-ANSI names for compatibility */
#define memccpy  _memccpy
#define memicmp  _memicmp
#define strcmpi  _strcmpi
#define stricmp  _stricmp
#define strdup	 _strdup
#define strlwr	 _strlwr
#define strnicmp _strnicmp
#define strnset  _strnset
#define strrev	 _strrev
#define strset	 _strset
#define strupr	 _strupr
#define stricoll _stricoll

#else	/* ndef _NTSDK */

/* prototypes for oldnames.lib functions */
_CRTIMP void * __cdecl memccpy(void *, const void *, int, unsigned int);
_CRTIMP int __cdecl memicmp(const void *, const void *, unsigned int);
_CRTIMP int __cdecl strcmpi(const char *, const char *);
_CRTIMP int __cdecl stricmp(const char *, const char *);
_CRTIMP char * __cdecl strdup(const char *);
_CRTIMP char * __cdecl strlwr(char *);
_CRTIMP int __cdecl strnicmp(const char *, const char *, size_t);
_CRTIMP char * __cdecl strnset(char *, int, size_t);
_CRTIMP char * __cdecl strrev(char *);
	char * __cdecl strset(char *, int);
_CRTIMP char * __cdecl strupr(char *);

#endif	/* ndef _NTSDK */

#endif	/* !__STDC__ */


#ifndef _WSTRING_DEFINED

/* wide function prototypes, also declared in wchar.h  */

_CRTIMP wchar_t * __cdecl wcscat(wchar_t *, const wchar_t *);
_CRTIMP wchar_t * __cdecl wcschr(const wchar_t *, wchar_t);
_CRTIMP int __cdecl wcscmp(const wchar_t *, const wchar_t *);
_CRTIMP wchar_t * __cdecl wcscpy(wchar_t *, const wchar_t *);
_CRTIMP size_t __cdecl wcscspn(const wchar_t *, const wchar_t *);
_CRTIMP size_t __cdecl wcslen(const wchar_t *);
_CRTIMP wchar_t * __cdecl wcsncat(wchar_t *, const wchar_t *, size_t);
_CRTIMP int __cdecl wcsncmp(const wchar_t *, const wchar_t *, size_t);
_CRTIMP wchar_t * __cdecl wcsncpy(wchar_t *, const wchar_t *, size_t);
_CRTIMP wchar_t * __cdecl wcspbrk(const wchar_t *, const wchar_t *);
_CRTIMP wchar_t * __cdecl wcsrchr(const wchar_t *, wchar_t);
_CRTIMP size_t __cdecl wcsspn(const wchar_t *, const wchar_t *);
_CRTIMP wchar_t * __cdecl wcsstr(const wchar_t *, const wchar_t *);
_CRTIMP wchar_t * __cdecl wcstok(wchar_t *, const wchar_t *);

_CRTIMP wchar_t * __cdecl _wcsdup(const wchar_t *);
_CRTIMP int __cdecl _wcsicmp(const wchar_t *, const wchar_t *);
_CRTIMP int __cdecl _wcsnicmp(const wchar_t *, const wchar_t *, size_t);
_CRTIMP wchar_t * __cdecl _wcsnset(wchar_t *, wchar_t, size_t);
_CRTIMP wchar_t * __cdecl _wcsrev(wchar_t *);
_CRTIMP wchar_t * __cdecl _wcsset(wchar_t *, wchar_t);

_CRTIMP wchar_t * __cdecl _wcslwr(wchar_t *);
_CRTIMP wchar_t * __cdecl _wcsupr(wchar_t *);
_CRTIMP size_t __cdecl wcsxfrm(wchar_t *, const wchar_t *, size_t);
_CRTIMP int __cdecl wcscoll(const wchar_t *, const wchar_t *);
_CRTIMP int __cdecl _wcsicoll(const wchar_t *, const wchar_t *);
_CRTIMP int __cdecl _wcsnicoll(const wchar_t *, const wchar_t *, size_t);

#if	!__STDC__

/* old names */
#define wcswcs wcsstr

#ifdef	_NTSDK

/* Non-ANSI names for compatibility */
#define wcsdup	_wcsdup
#define wcsicmp	_wcsicmp
#define wcsnicmp _wcsnicmp
#define wcsnset	_wcsnset
#define wcsrev	_wcsrev
#define wcsset	_wcsset
#define wcslwr	_wcslwr
#define wcsupr	_wcsupr
#define wcsicoll _wcsicoll

#else	/* ndef _NTSDK */

/* prototypes for oldnames.lib functions */
_CRTIMP wchar_t * __cdecl wcsdup(const wchar_t *);
_CRTIMP int __cdecl wcsicmp(const wchar_t *, const wchar_t *);
_CRTIMP int __cdecl wcsnicmp(const wchar_t *, const wchar_t *, size_t);
_CRTIMP wchar_t * __cdecl wcsnset(wchar_t *, wchar_t, size_t);
_CRTIMP wchar_t * __cdecl wcsrev(wchar_t *);
_CRTIMP wchar_t * __cdecl wcsset(wchar_t *, wchar_t);
_CRTIMP wchar_t * __cdecl wcslwr(wchar_t *);
_CRTIMP wchar_t * __cdecl wcsupr(wchar_t *);
_CRTIMP int __cdecl wcsicoll(const wchar_t *, const wchar_t *);

#endif	/* ndef _NTSDK */

#endif	/* !__STDC__ */

#define _WSTRING_DEFINED
#endif

#ifdef __cplusplus
}
#endif

#endif	/* _INC_STRING */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\tools\c932\inc\vdmdbg.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1985-1993, Microsoft Corporation

Module Name:

    vdmdbg.h

Abstract:

    Prodecure declarations, constant definitions, type definition and macros
    for the VDMDBG.DLL VDM Debugger interface.

--*/

#ifndef _VDMDBG_
#define _VDMDBG_

#ifdef __cplusplus
extern "C" {
#endif

#pragma pack(4)

#define STATUS_VDM_EVENT    STATUS_SEGMENT_NOTIFICATION

#ifndef DBG_SEGLOAD
#define DBG_SEGLOAD     0
#define DBG_SEGMOVE     1
#define DBG_SEGFREE     2
#define DBG_MODLOAD     3
#define DBG_MODFREE     4
#define DBG_SINGLESTEP  5
#define DBG_BREAK       6
#define DBG_GPFAULT     7
#define DBG_DIVOVERFLOW 8
#define DBG_INSTRFAULT  9
#define DBG_TASKSTART   10
#define DBG_TASKSTOP    11
#define DBG_DLLSTART    12
#define DBG_DLLSTOP     13
#define DBG_ATTACH      14
#endif

//
// The following flags control the contents of the CONTEXT structure.
//

#define VDMCONTEXT_i386    0x00010000    // this assumes that i386 and
#define VDMCONTEXT_i486    0x00010000    // i486 have identical context records

#define VDMCONTEXT_CONTROL         (VDMCONTEXT_i386 | 0x00000001L) // SS:SP, CS:IP, FLAGS, BP
#define VDMCONTEXT_INTEGER         (VDMCONTEXT_i386 | 0x00000002L) // AX, BX, CX, DX, SI, DI
#define VDMCONTEXT_SEGMENTS        (VDMCONTEXT_i386 | 0x00000004L) // DS, ES, FS, GS
#define VDMCONTEXT_FLOATING_POINT  (VDMCONTEXT_i386 | 0x00000008L) // 387 state
#define VDMCONTEXT_DEBUG_REGISTERS (VDMCONTEXT_i386 | 0x00000010L) // DB 0-3,6,7

#define VDMCONTEXT_FULL (VDMCONTEXT_CONTROL | VDMCONTEXT_INTEGER |\
                      VDMCONTEXT_SEGMENTS)


#ifdef _X86_

// On x86 machines, just copy the definition of the CONTEXT and LDT_ENTRY
// structures.
typedef struct _CONTEXT VDMCONTEXT;
typedef struct _LDT_ENTRY VDMLDT_ENTRY;

#else // _X86_

//
//  Define the size of the 80387 save area, which is in the context frame.
//

#define SIZE_OF_80387_REGISTERS      80

typedef struct _FLOATING_SAVE_AREA {
    ULONG   ControlWord;
    ULONG   StatusWord;
    ULONG   TagWord;
    ULONG   ErrorOffset;
    ULONG   ErrorSelector;
    ULONG   DataOffset;
    ULONG   DataSelector;
    UCHAR   RegisterArea[SIZE_OF_80387_REGISTERS];
    ULONG   Cr0NpxState;
} FLOATING_SAVE_AREA;

//
// Simulated context structure for the 16-bit environment
//

typedef struct _VDMCONTEXT {

    //
    // The flags values within this flag control the contents of
    // a CONTEXT record.
    //
    // If the context record is used as an input parameter, then
    // for each portion of the context record controlled by a flag
    // whose value is set, it is assumed that that portion of the
    // context record contains valid context. If the context record
    // is being used to modify a threads context, then only that
    // portion of the threads context will be modified.
    //
    // If the context record is used as an IN OUT parameter to capture
    // the context of a thread, then only those portions of the thread's
    // context corresponding to set flags will be returned.
    //
    // The context record is never used as an OUT only parameter.
    //
    // CONTEXT_FULL on some systems (MIPS namely) does not contain the
    // CONTEXT_SEGMENTS definition.  VDMDBG assumes that CONTEXT_INTEGER also
    // includes CONTEXT_SEGMENTS to account for this.
    //

    ULONG ContextFlags;

    //
    // This section is specified/returned if CONTEXT_DEBUG_REGISTERS is
    // set in ContextFlags.  Note that CONTEXT_DEBUG_REGISTERS is NOT
    // included in CONTEXT_FULL.
    //

    ULONG   Dr0;
    ULONG   Dr1;
    ULONG   Dr2;
    ULONG   Dr3;
    ULONG   Dr6;
    ULONG   Dr7;

    //
    // This section is specified/returned if the
    // ContextFlags word contians the flag CONTEXT_FLOATING_POINT.
    //

    FLOATING_SAVE_AREA FloatSave;

    //
    // This section is specified/returned if the
    // ContextFlags word contians the flag CONTEXT_SEGMENTS.
    //

    ULONG   SegGs;
    ULONG   SegFs;
    ULONG   SegEs;
    ULONG   SegDs;

    //
    // This section is specified/returned if the
    // ContextFlags word contians the flag CONTEXT_INTEGER.
    //

    ULONG   Edi;
    ULONG   Esi;
    ULONG   Ebx;
    ULONG   Edx;
    ULONG   Ecx;
    ULONG   Eax;

    //
    // This section is specified/returned if the
    // ContextFlags word contians the flag CONTEXT_CONTROL.
    //

    ULONG   Ebp;
    ULONG   Eip;
    ULONG   SegCs;              // MUST BE SANITIZED
    ULONG   EFlags;             // MUST BE SANITIZED
    ULONG   Esp;
    ULONG   SegSs;

} VDMCONTEXT;

//
//  LDT descriptor entry
//

typedef struct _VDMLDT_ENTRY {
    USHORT  LimitLow;
    USHORT  BaseLow;
    union {
        struct {
            UCHAR   BaseMid;
            UCHAR   Flags1;     // Declare as bytes to avoid alignment
            UCHAR   Flags2;     // Problems.
            UCHAR   BaseHi;
        } Bytes;
        struct {
            ULONG   BaseMid : 8;
            ULONG   Type : 5;
            ULONG   Dpl : 2;
            ULONG   Pres : 1;
            ULONG   LimitHi : 4;
            ULONG   Sys : 1;
            ULONG   Reserved_0 : 1;
            ULONG   Default_Big : 1;
            ULONG   Granularity : 1;
            ULONG   BaseHi : 8;
        } Bits;
    } HighWord;
} VDMLDT_ENTRY;


#endif // _X86_

typedef VDMCONTEXT *LPVDMCONTEXT;
typedef VDMLDT_ENTRY *LPVDMLDT_ENTRY;

#define VDMCONTEXT_TO_PROGRAM_COUNTER(Context) (PVOID)((Context)->Eip)

#define VDMCONTEXT_LENGTH  (sizeof(VDMCONTEXT))
#define VDMCONTEXT_ALIGN   (sizeof(ULONG))
#define VDMCONTEXT_ROUND   (VDMCONTEXT_ALIGN - 1)

#define V86FLAGS_CARRY      0x00001
#define V86FLAGS_PARITY     0x00004
#define V86FLAGS_AUXCARRY   0x00010
#define V86FLAGS_ZERO       0x00040
#define V86FLAGS_SIGN       0x00080
#define V86FLAGS_TRACE      0x00100
#define V86FLAGS_INTERRUPT  0x00200
#define V86FLAGS_DIRECTION  0x00400
#define V86FLAGS_OVERFLOW   0x00800
#define V86FLAGS_IOPL       0x03000
#define V86FLAGS_IOPL_BITS  0x12
#define V86FLAGS_RESUME     0x10000
#define V86FLAGS_V86        0x20000     // Used to detect RealMode v. ProtMode
#define V86FLAGS_ALIGNMENT  0x40000

#define MAX_MODULE_NAME  8 + 1
#define MAX_PATH16      255

typedef struct _SEGMENT_NOTE {
    WORD    Selector1;                      // Selector of operation
    WORD    Selector2;                      // Dest. Sel. for moving segments
    WORD    Segment;                        // Segment within Module
    CHAR    Module[MAX_MODULE_NAME+1];      // Module name
    CHAR    FileName[MAX_PATH16+1];         // PathName to executable image
    WORD    Type;                           // Code / Data, etc.
    DWORD   Length;                         // Length of image
} SEGMENT_NOTE;

typedef struct _IMAGE_NOTE {
    CHAR    Module[MAX_MODULE_NAME+1];      // Module
    CHAR    FileName[MAX_PATH16+1];         // Path to executable image
    WORD    hModule;                        // 16-bit hModule
    WORD    hTask;                          // 16-bit hTask
} IMAGE_NOTE;

typedef struct {
    DWORD   dwSize;
    char    szModule[MAX_MODULE_NAME+1];
    HANDLE  hModule;
    WORD    wcUsage;
    char    szExePath[MAX_PATH16+1];
    WORD    wNext;
} MODULEENTRY, *LPMODULEENTRY;

/* GlobalFirst()/GlobalNext() flags */
#define GLOBAL_ALL      0
#define GLOBAL_LRU      1
#define GLOBAL_FREE     2

/* GLOBALENTRY.wType entries */
#define GT_UNKNOWN      0
#define GT_DGROUP       1
#define GT_DATA         2
#define GT_CODE         3
#define GT_TASK         4
#define GT_RESOURCE     5
#define GT_MODULE       6
#define GT_FREE         7
#define GT_INTERNAL     8
#define GT_SENTINEL     9
#define GT_BURGERMASTER 10

/* If GLOBALENTRY.wType==GT_RESOURCE, the following is GLOBALENTRY.wData: */
#define GD_USERDEFINED      0
#define GD_CURSORCOMPONENT  1
#define GD_BITMAP           2
#define GD_ICONCOMPONENT    3
#define GD_MENU             4
#define GD_DIALOG           5
#define GD_STRING           6
#define GD_FONTDIR          7
#define GD_FONT             8
#define GD_ACCELERATORS     9
#define GD_RCDATA           10
#define GD_ERRTABLE         11
#define GD_CURSOR           12
#define GD_ICON             14
#define GD_NAMETABLE        15
#define GD_MAX_RESOURCE     15

typedef struct {
    DWORD   dwSize;
    DWORD   dwAddress;
    DWORD   dwBlockSize;
    HANDLE  hBlock;
    WORD    wcLock;
    WORD    wcPageLock;
    WORD    wFlags;
    BOOL    wHeapPresent;
    HANDLE  hOwner;
    WORD    wType;
    WORD    wData;
    DWORD   dwNext;
    DWORD   dwNextAlt;
} GLOBALENTRY, *LPGLOBALENTRY;

typedef DWORD (CALLBACK* DEBUGEVENTPROC)( LPDEBUG_EVENT, LPVOID );

// Macros to access VDM_EVENT parameters
#define W1(x) ((USHORT)(x.ExceptionInformation[0]))
#define W2(x) ((USHORT)(x.ExceptionInformation[0] >> 16))
#define W3(x) ((USHORT)(x.ExceptionInformation[1]))
#define W4(x) ((USHORT)(x.ExceptionInformation[1] >> 16))
#define DW3(x) (x.ExceptionInformation[2])
#define DW4(x) (x.ExceptionInformation[3])

#pragma pack()

BOOL
WINAPI
VDMProcessException(
    LPDEBUG_EVENT   lpDebugEvent
    );

BOOL
WINAPI
VDMGetThreadSelectorEntry(
    HANDLE          hProcess,
    HANDLE          hThread,
    WORD            wSelector,
    LPVDMLDT_ENTRY  lpSelectorEntry
    );

ULONG
WINAPI
VDMGetPointer(
    HANDLE          hProcess,
    HANDLE          hThread,
    WORD            wSelector,
    DWORD           dwOffset,
    BOOL            fProtMode
    );

BOOL
WINAPI
VDMGetThreadContext(
    LPDEBUG_EVENT   lpDebugEvent,
    LPVDMCONTEXT    lpVDMContext
);

BOOL
WINAPI
VDMSetThreadContext(
    LPDEBUG_EVENT   lpDebugEvent,
    LPVDMCONTEXT    lpVDMContext
);

BOOL
WINAPI
VDMGetSelectorModule(
    HANDLE          hProcess,
    HANDLE          hThread,
    WORD            wSelector,
    PUINT           lpSegmentNumber,
    LPSTR           lpModuleName,
    UINT            nNameSize,
    LPSTR           lpModulePath,
    UINT            nPathSize
);

BOOL
WINAPI
VDMGetModuleSelector(
    HANDLE          hProcess,
    HANDLE          hThread,
    UINT            wSegmentNumber,
    LPSTR           lpModuleName,
    LPWORD          lpSelector
);

BOOL
WINAPI
VDMModuleFirst(
    HANDLE          hProcess,
    HANDLE          hThread,
    LPMODULEENTRY   lpModuleEntry,
    DEBUGEVENTPROC  lpEventProc,
    LPVOID          lpData
);

BOOL
WINAPI
VDMModuleNext(
    HANDLE          hProcess,
    HANDLE          hThread,
    LPMODULEENTRY   lpModuleEntry,
    DEBUGEVENTPROC  lpEventProc,
    LPVOID          lpData
);

BOOL
WINAPI
VDMGlobalFirst(
    HANDLE          hProcess,
    HANDLE          hThread,
    LPGLOBALENTRY   lpGlobalEntry,
    WORD            wFlags,
    DEBUGEVENTPROC  lpEventProc,
    LPVOID          lpData
);

BOOL
WINAPI
VDMGlobalNext(
    HANDLE          hProcess,
    HANDLE          hThread,
    LPGLOBALENTRY   lpGlobalEntry,
    WORD            wFlags,
    DEBUGEVENTPROC  lpEventProc,
    LPVOID          lpData
);

typedef BOOL (WINAPI *PROCESSENUMPROC)( DWORD dwProcessId, DWORD dwAttributes, LPARAM lpUserDefined );
typedef BOOL (WINAPI *TASKENUMPROC)( DWORD dwThreadId, WORD hMod16, WORD hTask16, LPARAM lpUserDefined );

#define WOW_SYSTEM  (DWORD)0x0001

INT
WINAPI
VDMEnumProcessWOW(
    PROCESSENUMPROC fp,
    LPARAM          lparam
);

INT
WINAPI
VDMEnumTaskWOW(
    DWORD           dwProcessId,
    TASKENUMPROC    fp,
    LPARAM          lparam
);

BOOL
WINAPI
VDMKillWOW(
    VOID
);

BOOL
WINAPI
VDMDetectWOW(
    VOID
);

BOOL
WINAPI
VDMBreakThread(
    HANDLE          hProcess,
    HANDLE          hThread
);

#ifdef __cplusplus
}
#endif

#endif // _VDMDBG_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\tools\c932\inc\wfext.h ===
/*****************************************************************************\
*                                                                             *
* wfext.h -     Windows File Manager Extensions definitions (Win32 variant)   *
*                                                                             *
*               Version 3.10                                                  *
*                                                                             *
*               Copyright (c) 1991-1993, Microsoft Corp. All rights reserved. *
*                                                                             *
*******************************************************************************/

#ifndef _INC_WFEXT
#define _INC_WFEXT            /* #defined if wfext.h has been included */

#ifdef __cplusplus            /* Assume C declaration for C++ */
extern "C" {
#endif  /* __cplusplus */

#define MENU_TEXT_LEN           40

#define FMMENU_FIRST            1
#define FMMENU_LAST             99

#define FMEVENT_LOAD            100
#define FMEVENT_UNLOAD          101
#define FMEVENT_INITMENU        102
#define FMEVENT_USER_REFRESH    103
#define FMEVENT_SELCHANGE       104
#define FMEVENT_TOOLBARLOAD     105
#define FMEVENT_HELPSTRING      106
#define FMEVENT_HELPMENUITEM    107

#define FMFOCUS_DIR             1
#define FMFOCUS_TREE            2
#define FMFOCUS_DRIVES          3
#define FMFOCUS_SEARCH          4

#define FM_GETFOCUS           (WM_USER + 0x0200)
#define FM_GETSELCOUNT        (WM_USER + 0x0202)
#define FM_GETSELCOUNTLFN     (WM_USER + 0x0203)  /* LFN versions are odd */
#define FM_REFRESH_WINDOWS    (WM_USER + 0x0206)
#define FM_RELOAD_EXTENSIONS  (WM_USER + 0x0207)

#define FM_GETDRIVEINFOA      (WM_USER + 0x0201)
#define FM_GETFILESELA        (WM_USER + 0x0204)
#define FM_GETFILESELLFNA     (WM_USER + 0x0205)  /* LFN versions are odd */

#define FM_GETDRIVEINFOW      (WM_USER + 0x0211)
#define FM_GETFILESELW        (WM_USER + 0x0214)
#define FM_GETFILESELLFNW     (WM_USER + 0x0215)  /* LFN versions are odd */

#ifdef UNICODE
#define FM_GETDRIVEINFO    FM_GETDRIVEINFOW
#define FM_GETFILESEL      FM_GETFILESELW
#define FM_GETFILESELLFN   FM_GETFILESELLFNW
#else
#define FM_GETDRIVEINFO    FM_GETDRIVEINFOA
#define FM_GETFILESEL      FM_GETFILESELA
#define FM_GETFILESELLFN   FM_GETFILESELLFNA
#endif


typedef struct _FMS_GETFILESELA {
   FILETIME ftTime;
   DWORD dwSize;
   BYTE bAttr;
   CHAR szName[260];          // always fully qualified
} FMS_GETFILESELA, FAR *LPFMS_GETFILESELA;

typedef struct _FMS_GETFILESELW {
   FILETIME ftTime ;
   DWORD dwSize;
   BYTE bAttr;
   WCHAR szName[260];          // always fully qualified
} FMS_GETFILESELW, FAR *LPFMS_GETFILESELW;

#ifdef UNICODE
#define FMS_GETFILESEL   FMS_GETFILESELW
#define LPFMS_GETFILESEL LPFMS_GETFILESELW
#else
#define FMS_GETFILESEL   FMS_GETFILESELA
#define LPFMS_GETFILESEL LPFMS_GETFILESELA
#endif


typedef struct _FMS_GETDRIVEINFOA {      // for drive
   DWORD dwTotalSpace;
   DWORD dwFreeSpace;
   CHAR  szPath[260];                    // current directory
   CHAR  szVolume[14];                   // volume label
   CHAR  szShare[128];                   // if this is a net drive
} FMS_GETDRIVEINFOA, FAR *LPFMS_GETDRIVEINFOA;

typedef struct _FMS_GETDRIVEINFOW {      // for drive
   DWORD dwTotalSpace;
   DWORD dwFreeSpace;
   WCHAR szPath[260];                    // current directory
   WCHAR szVolume[14];                   // volume label
   WCHAR szShare[128];                   // if this is a net drive
} FMS_GETDRIVEINFOW, FAR *LPFMS_GETDRIVEINFOW;

#ifdef UNICODE
#define FMS_GETDRIVEINFO   FMS_GETDRIVEINFOW
#define LPFMS_GETDRIVEINFO LPFMS_GETDRIVEINFOW
#else
#define FMS_GETDRIVEINFO   FMS_GETDRIVEINFOA
#define LPFMS_GETDRIVEINFO LPFMS_GETDRIVEINFOA
#endif


typedef struct _FMS_LOADA {
   DWORD dwSize;                        // for version checks
   CHAR  szMenuName[MENU_TEXT_LEN];     // output
   HMENU hMenu;                         // output
   UINT  wMenuDelta;                    // input
} FMS_LOADA, FAR *LPFMS_LOADA;

typedef struct _FMS_LOADW {
   DWORD dwSize;                        // for version checks
   WCHAR szMenuName[MENU_TEXT_LEN];     // output
   HMENU hMenu;                         // output
   UINT  wMenuDelta;                    // input
} FMS_LOADW, FAR *LPFMS_LOADW;

#ifdef UNICODE
#define FMS_LOAD   FMS_LOADW
#define LPFMS_LOAD LPFMS_LOADW
#else
#define FMS_LOAD   FMS_LOADA
#define LPFMS_LOAD LPFMS_LOADA
#endif


// Toolbar definitions

typedef struct tagEXT_BUTTON {
   WORD idCommand;                 /* menu command to trigger */
   WORD idsHelp;                   /* help string ID */
   WORD fsStyle;                   /* button style */
} EXT_BUTTON, FAR *LPEXT_BUTTON;

typedef struct tagFMS_TOOLBARLOAD {
   DWORD dwSize;                   /* for version checks */
   LPEXT_BUTTON lpButtons;         /* output */
   WORD cButtons;                  /* output, 0==>no buttons */
   WORD cBitmaps;                  /* number of non-sep buttons */
   WORD idBitmap;                  /* output */
   HBITMAP hBitmap;                /* output if idBitmap==0 */
} FMS_TOOLBARLOAD, FAR *LPFMS_TOOLBARLOAD;

typedef struct tagFMS_HELPSTRINGA {
   INT   idCommand;       /* input, -1==>the menu was selected */
   HMENU hMenu;           /* input, the extensions menu */
   CHAR  szHelp[128];     /* output, the help string */
} FMS_HELPSTRINGA, FAR *LPFMS_HELPSTRINGA;

typedef struct tagFMS_HELPSTRINGW {
   INT   idCommand;       /* input, -1==>the menu was selected */
   HMENU hMenu;           /* input, the extensions menu */
   WCHAR szHelp[128];     /* output, the help string */
} FMS_HELPSTRINGW, FAR *LPFMS_HELPSTRINGW;

#ifdef UNICODE
#define FMS_HELPSTRING   FMS_HELPSTRINGW
#define LPFMS_HELPSTRING LPFMS_HELPSTRINGW
#else
#define FMS_HELPSTRING   FMS_HELPSTRINGA
#define LPFMS_HELPSTRING LPFMS_HELPSTRINGA
#endif


typedef DWORD (APIENTRY *FM_EXT_PROC)(HWND, WORD, LONG);
typedef DWORD (APIENTRY *FM_UNDELETE_PROC)(HWND, LPTSTR);

#ifdef UNICODE
LONG WINAPI FMExtensionProcW(HWND hwnd, WORD wEvent, LONG lParam);
#else
LONG WINAPI FMExtensionProc(HWND hwnd, WORD wEvent, LONG lParam);
#endif

#ifdef __cplusplus
}                  /* End of extern "C" { */
#endif             /* __cplusplus */

#endif             /* _INC_WFEXT */


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\tools\c932\inc\wdbgexts.h ===
/*++

Copyright (c) 1992-1993  Microsoft Corporation

Module Name:

    wdbgexts.h

Abstract:

    This file contains procedure prototypes and structures needed to port
    NTSD debugger extensions so that they can be invoked remotely in WinDbg
    command window. This file is to be included by cmdexec0.c and wdbgexts.c.
    To maintain compatibilty with NTSD extensions(or to call the original NTSD
    extensions like "ntsdexts" without modification), definitions in this file
    are incremental by first doing **#include <ntsdexts.h>**.

Author:

    Peter Sun (t-petes) 29-July-1992

Environment:

    runs in the Win32 WinDbg environment.

Revision History:

--*/

#ifndef _WDBGEXTS_
#define _WDBGEXTS_

#include <ntsdexts.h>


#ifdef __cplusplus
extern "C" {
#endif

typedef LARGE_INTEGER PHYSICAL_ADDRESS, *PPHYSICAL_ADDRESS;

typedef
VOID
(*PWINDBG_OUTPUT_ROUTINE)(
    char *,
    ...
    );

typedef
DWORD
(*PWINDBG_GET_EXPRESSION)(
    char *
    );

typedef
VOID
(*PWINDBG_GET_SYMBOL)(
    LPVOID offset,
    PUCHAR pchBuffer,
    LPDWORD pDisplacement
    );

typedef
DWORD
(*PWINDBG_DISASM)(
    LPDWORD lpOffset,
    LPSTR lpBuffer,
    BOOL fShowEfeectiveAddress
    );

typedef
BOOL
(*PWINDBG_CHECK_CONTROL_C)(
    VOID
    );

typedef
BOOL
(*PWINDBG_READ_PROCESS_MEMORY_ROUTINE)(
    DWORD   offset,
    LPVOID  lpBuffer,
    DWORD   cb,
    LPDWORD lpcbBytesRead
    );

typedef
BOOL
(*PWINDBG_WRITE_PROCESS_MEMORY_ROUTINE)(
    DWORD   offset,
    LPVOID  lpBuffer,
    DWORD   cb,
    LPDWORD lpcbBytesWritten
    );

typedef
BOOL
(*PWINDBG_GET_THREAD_CONTEXT_ROUTINE)(
    LPCONTEXT   lpContext,
    DWORD       cbSizeOfContext
    );

typedef
BOOL
(*PWINDBG_SET_THREAD_CONTEXT_ROUTINE)(
    LPCONTEXT   lpContext,
    DWORD       cbSizeOfContext
    );

typedef
BOOL
(*PWINDBG_IOCTL_ROUTINE)(
    USHORT   IoctlType,
    LPVOID   lpvData,
    DWORD    cbSize
    );


typedef struct _tagEXTSTACKTRACE {
    DWORD       FramePointer;
    DWORD       ProgramCounter;
    DWORD       ReturnAddress;
    DWORD       Args[4];
} EXTSTACKTRACE, *PEXTSTACKTRACE;


typedef
DWORD
(*PWINDBG_STACKTRACE_ROUTINE)(
    DWORD             FramePointer,
    DWORD             StackPointer,
    DWORD             ProgramCounter,
    PEXTSTACKTRACE    StackFrames,
    DWORD             Frames
    );

typedef struct _WINDBG_EXTENSION_APIS {
    DWORD nSize;
    PWINDBG_OUTPUT_ROUTINE lpOutputRoutine;
    PWINDBG_GET_EXPRESSION lpGetExpressionRoutine;
    PWINDBG_GET_SYMBOL lpGetSymbolRoutine;
    PWINDBG_DISASM lpDisasmRoutine;
    PWINDBG_CHECK_CONTROL_C lpCheckControlCRoutine;
    PWINDBG_READ_PROCESS_MEMORY_ROUTINE lpReadProcessMemoryRoutine;
    PWINDBG_WRITE_PROCESS_MEMORY_ROUTINE lpWriteProcessMemoryRoutine;
    PWINDBG_GET_THREAD_CONTEXT_ROUTINE lpGetThreadContextRoutine;
    PWINDBG_SET_THREAD_CONTEXT_ROUTINE lpSetThreadContextRoutine;
    PWINDBG_IOCTL_ROUTINE lpIoctlRoutine;
    PWINDBG_STACKTRACE_ROUTINE lpStackTraceRoutine;
} WINDBG_EXTENSION_APIS, *PWINDBG_EXTENSION_APIS;


typedef
VOID
(*PWINDBG_OLD_EXTENSION_ROUTINE)(
    HANDLE                  hCurrentProcess,
    HANDLE                  hCurrentThread,
    DWORD                   dwCurrentPc,
    PWINDBG_EXTENSION_APIS  lpExtensionApis,
    LPSTR                   lpArgumentString
    );

typedef
VOID
(*PWINDBG_EXTENSION_ROUTINE)(
    HANDLE                  hCurrentProcess,
    HANDLE                  hCurrentThread,
    DWORD                   dwCurrentPc,
    LPSTR                   lpArgumentString
    );

typedef
VOID
(*PWINDBG_EXTENSION_DLL_INIT)(
    PWINDBG_EXTENSION_APIS lpExtensionApis
    );

#define IG_KD_CONTEXT               1
#define IG_READ_CONTROL_SPACE       2
#define IG_WRITE_CONTROL_SPACE      3
#define IG_READ_IO_SPACE            4
#define IG_WRITE_IO_SPACE           5
#define IG_READ_PHYSICAL            6
#define IG_WRITE_PHYSICAL           7
#define IG_READ_IO_SPACE_EX         8
#define IG_WRITE_IO_SPACE_EX        9

typedef struct _tagPROCESSORINFO {
    USHORT      Processor;                // current processor
    USHORT      NumberProcessors;         // total number of processors
} PROCESSORINFO, *PPROCESSORINFO;

typedef struct _tagREADCONTROLSPACE {
    ULONG       Processor;
    ULONG       Address;
    ULONG       BufLen;
    BYTE        Buf[1];
} READCONTROLSPACE, *PREADCONTROLSPACE;

typedef struct _tagIOSPACE {
    ULONG       Address;
    ULONG       Length;                   // 1, 2, or 4 bytes
    ULONG       Data;
} IOSPACE, *PIOSPACE;

typedef struct _tagIOSPACE_EX {
    ULONG       Address;
    ULONG       Length;                   // 1, 2, or 4 bytes
    ULONG       Data;
    ULONG       InterfaceType;
    ULONG       BusNumber;
    ULONG       AddressSpace;
} IOSPACE_EX, *PIOSPACE_EX;

typedef struct _tagPHYSICAL {
    PHYSICAL_ADDRESS       Address;
    ULONG                  BufLen;
    BYTE                   Buf[1];
} PHYSICAL, *PPHYSICAL;


#ifdef WDBGEXTS_NEW

#define dprintf          (ExtensionApis.lpOutputRoutine)
#define GetExpression    (ExtensionApis.lpGetExpressionRoutine)
#define GetSymbol        (ExtensionApis.lpGetSymbolRoutine)
#define Disassm          (ExtensionApis.lpDisasmRoutine)
#define CheckControlC    (ExtensionApis.lpCheckControlCRoutine)
#define ReadMemory       (ExtensionApis.lpReadProcessMemoryRoutine)
#define WriteMemory      (ExtensionApis.lpWriteProcessMemoryRoutine)
#define GetContext       (ExtensionApis.lpGetThreadContextRoutine)
#define SetContext       (ExtensionApis.lpSetThreadContextRoutine)
#define Ioctl            (ExtensionApis.lpIoctlRoutine)
#define StackTrace       (ExtensionApis.lpStackTraceRoutine)


#define DECLARE_API(s)                             \
    VOID                                           \
    s(                                             \
        HANDLE                 hCurrentProcess,    \
        HANDLE                 hCurrentThread,     \
        DWORD                  dwCurrentPc,        \
        LPSTR                  args                \
     )

#define GetKdContext(ppi) \
    Ioctl( IG_KD_CONTEXT, (LPVOID)ppi, sizeof(*ppi) )

#define ReadControlSpace(processor,address,buf,size) \
    { \
        PREADCONTROLSPACE prc; \
        prc = malloc( sizeof(*prc) + size ); \
        ZeroMemory( prc->Buf, size ); \
        prc->Processor = (DWORD)processor; \
        prc->Address = (DWORD)address; \
        prc->BufLen = size; \
        Ioctl( IG_READ_CONTROL_SPACE, (LPVOID)prc, sizeof(*prc) + size ); \
        memcpy( buf, prc->Buf, size ); \
        free( prc ); \
    }

#define ReadIoSpace(address,data,size) \
    { \
        IOSPACE is; \
        is.Address = (DWORD)address; \
        is.Length = *size; \
        is.Data = 0; \
        Ioctl( IG_READ_IO_SPACE, (LPVOID)&is, sizeof(is) ); \
        *data = is.Data; \
        *size = is.Length; \
    }

#define WriteIoSpace(address,data,size) \
    { \
        IOSPACE is; \
        is.Address = (DWORD)address; \
        is.Length = *size; \
        is.Data = data; \
        Ioctl( IG_WRITE_IO_SPACE, (LPVOID)&is, sizeof(is) ); \
        *size = is.Length; \
    }

#define ReadIoSpaceEx(address,data,size,interfacetype,busnumber,addressspace) \
    { \
        IOSPACE_EX is; \
        is.Address = (DWORD)address; \
        is.Length = *size; \
        is.Data = 0; \
        is.InterfaceType = interfacetype; \
        is.BusNumber = busnumber; \
        is.AddressSpace = addressspace; \
        Ioctl( IG_READ_IO_SPACE_EX, (LPVOID)&is, sizeof(is) ); \
        *data = is.Data; \
        *size = is.Length; \
    }

#define WriteIoSpaceEx(address,data,size,interfacetype,busnumber,addressspace) \
    { \
        IOSPACE_EX is; \
        is.Address = (DWORD)address; \
        is.Length = *size; \
        is.Data = data; \
        is.InterfaceType = interfacetype; \
        is.BusNumber = busnumber; \
        is.AddressSpace = addressspace; \
        Ioctl( IG_WRITE_IO_SPACE_EX, (LPVOID)&is, sizeof(is) ); \
        *size = is.Length; \
    }


#define ReadPhysical(address,buf,size,sizer) \
    { \
        PPHYSICAL phy; \
        phy = malloc( sizeof(*phy) + size ); \
        ZeroMemory( phy->Buf, size ); \
        phy->Address = address; \
        phy->BufLen = size; \
        Ioctl( IG_READ_PHYSICAL, (LPVOID)phy, sizeof(*phy) + size ); \
        *sizer = phy->BufLen; \
        memcpy( buf, phy->Buf, *sizer ); \
        free( phy ); \
    }

#define WritePhysical(address,buf,size,sizew) \
    { \
        PPHYSICAL phy; \
        phy = malloc( sizeof(*phy) + size ); \
        ZeroMemory( phy->Buf, size ); \
        phy->Address = address; \
        phy->BufLen = size; \
        memcpy( phy->Buf, buf, size ); \
        Ioctl( IG_WRITE_PHYSICAL, (LPVOID)phy, sizeof(*phy) + size ); \
        *sizew = phy->BufLen; \
        free( phy ); \
    }

#endif


#ifdef __cplusplus
}
#endif

#endif // _WDBGEXTS_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\tools\c932\inc\wchar.h ===
/***
*wchar.h - declarations for wide character functions
*
*	Copyright (c) 1992-1994, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	This file contains the types, macros and function declarations for
*	all wide character-related functions.  They may also be declared in
*	individual header files on a functional basis.
*	[ISO]
*
*	Note: keep in sync with ctype.h, stdio.h, stdlib.h, string.h, time.h.
*
****/

#ifndef _INC_WCHAR
#define _INC_WCHAR

#ifdef __cplusplus
extern "C" {
#endif


/* Define _CRTAPI1 (for compatibility with the NT SDK) */

#ifndef _CRTAPI1
#if	( (_MSC_VER >= 800) && (_M_IX86 >= 300) )
#define _CRTAPI1 __cdecl
#else
#define _CRTAPI1
#endif
#endif


/* Define _CRTAPI2 (for compatibility with the NT SDK) */

#ifndef _CRTAPI2
#if	( (_MSC_VER >= 800) && (_M_IX86 >= 300) )
#define _CRTAPI2 __cdecl
#else
#define _CRTAPI2
#endif
#endif


/* Define _CRTIMP */

#ifndef _CRTIMP
#ifdef	_NTSDK
/* definition compatible with NT SDK */
#define _CRTIMP
#else	/* ndef _NTSDK */
/* current definition */
#ifdef	_DLL
#define _CRTIMP __declspec(dllimport)
#else	/* ndef _DLL */
#define _CRTIMP
#endif	/* _DLL */
#endif	/* _NTSDK */
#endif	/* _CRTIMP */


/* Define __cdecl for non-Microsoft compilers */

#if	( !defined(_MSC_VER) && !defined(__cdecl) )
#define __cdecl
#endif


#ifndef _SIZE_T_DEFINED
typedef unsigned int size_t;
#define _SIZE_T_DEFINED
#endif

#ifndef _TIME_T_DEFINED
typedef long time_t;
#define _TIME_T_DEFINED
#endif

#ifndef _WCHAR_T_DEFINED
typedef unsigned short wchar_t;
#define _WCHAR_T_DEFINED
#endif


#ifndef _WCTYPE_T_DEFINED
typedef wchar_t wint_t;
typedef wchar_t wctype_t;
#define _WCTYPE_T_DEFINED
#endif


#ifndef _VA_LIST_DEFINED
#ifdef	_M_ALPHA
typedef struct {
	char *a0;	/* pointer to first homed integer argument */
	int offset;	/* byte offset of next parameter */
} va_list;
#else
typedef char *	va_list;
#endif
#define _VA_LIST_DEFINED
#endif

#ifndef WEOF
#define WEOF (wint_t)(0xFFFF)
#endif

#ifndef _FILE_DEFINED
struct _iobuf {
	char *_ptr;
	int   _cnt;
	char *_base;
	int   _flag;
	int   _file;
	int   _charbuf;
	int   _bufsiz;
	char *_tmpfname;
	};
typedef struct _iobuf FILE;
#define _FILE_DEFINED
#endif

#ifndef _FSIZE_T_DEFINED
typedef unsigned long _fsize_t; /* Could be 64 bits for Win32 */
#define _FSIZE_T_DEFINED
#endif

#ifndef _WFINDDATA_T_DEFINED

struct _wfinddata_t {
    unsigned	attrib;
    time_t	time_create;	/* -1 for FAT file systems */
    time_t	time_access;	/* -1 for FAT file systems */
    time_t	time_write;
    _fsize_t	size;
    wchar_t	name[260];
};

#define _WFINDDATA_T_DEFINED
#endif

/* define NULL pointer value */

#ifndef NULL
#ifdef __cplusplus
#define NULL	0
#else
#define NULL	((void *)0)
#endif
#endif

/*
 * This declaration allows the user access to the ctype look-up
 * array _ctype defined in ctype.obj by simply including ctype.h
 */

#ifdef	_NTSDK

/* definitions and declarations compatible with NT SDK */

#ifdef	_DLL
extern unsigned short * _ctype;
#define _pctype     (*_pctype_dll)
extern unsigned short **_pctype_dll;
#define _pwctype    (*_pwctype_dll)
extern unsigned short **_pwctype_dll;
#else	/* ndef _DLL */
extern unsigned short _ctype[];
extern unsigned short *_pctype;
extern wctype_t *_pwctype;
#endif	/* _DLL */

#else	/* ndef _NTSDK */

/* current declarations */

_CRTIMP extern unsigned short _ctype[];

#if	defined(_DLL) && defined(_M_IX86)

#define _pctype     (*__p__pctype())
_CRTIMP unsigned short ** __cdecl __p__pctype(void);

#define _pwctype    (*__p__pwctype())
_CRTIMP wctype_t ** __cdecl ___p__pwctype(void);

#else	/* !(defined(_DLL) && defined(_M_IX86)) */

_CRTIMP extern unsigned short *_pctype;
_CRTIMP extern wctype_t *_pwctype;

#endif	/* defined(_DLL) && defined(_M_IX86) */

#endif	/* _NTSDK */


/* set bit masks for the possible character types */

#define _UPPER		0x1	/* upper case letter */
#define _LOWER		0x2	/* lower case letter */
#define _DIGIT		0x4	/* digit[0-9] */
#define _SPACE		0x8	/* tab, carriage return, newline, */
				/* vertical tab or form feed */
#define _PUNCT		0x10	/* punctuation character */
#define _CONTROL	0x20	/* control character */
#define _BLANK		0x40	/* space char */
#define _HEX		0x80	/* hexadecimal digit */

#define _LEADBYTE	0x8000			/* multibyte leadbyte */
#define _ALPHA		(0x0100|_UPPER|_LOWER)	/* alphabetic character */


/* Function prototypes */

#ifndef _WCTYPE_DEFINED

/* Character classification function prototypes */
/* also declared in ctype.h */

_CRTIMP int __cdecl iswalpha(wint_t);
_CRTIMP int __cdecl iswupper(wint_t);
_CRTIMP int __cdecl iswlower(wint_t);
_CRTIMP int __cdecl iswdigit(wint_t);
_CRTIMP int __cdecl iswxdigit(wint_t);
_CRTIMP int __cdecl iswspace(wint_t);
_CRTIMP int __cdecl iswpunct(wint_t);
_CRTIMP int __cdecl iswalnum(wint_t);
_CRTIMP int __cdecl iswprint(wint_t);
_CRTIMP int __cdecl iswgraph(wint_t);
_CRTIMP int __cdecl iswcntrl(wint_t);
_CRTIMP int __cdecl iswascii(wint_t);
_CRTIMP int __cdecl isleadbyte(int);

_CRTIMP wchar_t __cdecl towupper(wchar_t);
_CRTIMP wchar_t __cdecl towlower(wchar_t);

_CRTIMP int __cdecl iswctype(wint_t, wctype_t);

/* --------- The following functions are OBSOLETE --------- */
_CRTIMP int __cdecl is_wctype(wint_t, wctype_t);
/*  --------- The preceding functions are OBSOLETE --------- */

#define _WCTYPE_DEFINED
#endif

#ifndef _WDIRECT_DEFINED

/* also declared in direct.h */

_CRTIMP int __cdecl _wchdir(const wchar_t *);
_CRTIMP wchar_t * __cdecl _wgetcwd(wchar_t *, int);
_CRTIMP wchar_t * __cdecl _wgetdcwd(int, wchar_t *, int);
_CRTIMP int __cdecl _wmkdir(const wchar_t *);
_CRTIMP int __cdecl _wrmdir(const wchar_t *);

#define _WDIRECT_DEFINED
#endif

#ifndef _WIO_DEFINED

/* also declared in io.h */

_CRTIMP int __cdecl _waccess(const wchar_t *, int);
_CRTIMP int __cdecl _wchmod(const wchar_t *, int);
_CRTIMP int __cdecl _wcreat(const wchar_t *, int);
_CRTIMP long __cdecl _wfindfirst(wchar_t *, struct _wfinddata_t *);
_CRTIMP int __cdecl _wfindnext(long, struct _wfinddata_t *);
_CRTIMP int __cdecl _wunlink(const wchar_t *);
_CRTIMP int __cdecl _wrename(const wchar_t *, const wchar_t *);
_CRTIMP int __cdecl _wopen(const wchar_t *, int, ...);
_CRTIMP int __cdecl _wsopen(const wchar_t *, int, int, ...);
_CRTIMP wchar_t * __cdecl _wmktemp(wchar_t *);

#define _WIO_DEFINED
#endif

#ifndef _WLOCALE_DEFINED

/* wide function prototypes, also declared in wchar.h  */

_CRTIMP wchar_t * __cdecl _wsetlocale(int, const wchar_t *);

#define _WLOCALE_DEFINED
#endif

#ifndef _WPROCESS_DEFINED

/* also declared in process.h */

_CRTIMP int __cdecl _wexecl(const wchar_t *, const wchar_t *, ...);
_CRTIMP int __cdecl _wexecle(const wchar_t *, const wchar_t *, ...);
_CRTIMP int __cdecl _wexeclp(const wchar_t *, const wchar_t *, ...);
_CRTIMP int __cdecl _wexeclpe(const wchar_t *, const wchar_t *, ...);
_CRTIMP int __cdecl _wexecv(const wchar_t *, const wchar_t * const *);
_CRTIMP int __cdecl _wexecve(const wchar_t *, const wchar_t * const *, const wchar_t * const *);
_CRTIMP int __cdecl _wexecvp(const wchar_t *, const wchar_t * const *);
_CRTIMP int __cdecl _wexecvpe(const wchar_t *, const wchar_t * const *, const wchar_t * const *);
_CRTIMP int __cdecl _wspawnl(int, const wchar_t *, const wchar_t *, ...);
_CRTIMP int __cdecl _wspawnle(int, const wchar_t *, const wchar_t *, ...);
_CRTIMP int __cdecl _wspawnlp(int, const wchar_t *, const wchar_t *, ...);
_CRTIMP int __cdecl _wspawnlpe(int, const wchar_t *, const wchar_t *, ...);
_CRTIMP int __cdecl _wspawnv(int, const wchar_t *, const wchar_t * const *);
_CRTIMP int __cdecl _wspawnve(int, const wchar_t *, const wchar_t * const *,
	const wchar_t * const *);
_CRTIMP int __cdecl _wspawnvp(int, const wchar_t *, const wchar_t * const *);
_CRTIMP int __cdecl _wspawnvpe(int, const wchar_t *, const wchar_t * const *,
	const wchar_t * const *);
_CRTIMP int __cdecl _wsystem(const wchar_t *);

#define _WPROCESS_DEFINED
#endif

#define iswalpha(_c)	( iswctype(_c,_ALPHA) )
#define iswupper(_c)	( iswctype(_c,_UPPER) )
#define iswlower(_c)	( iswctype(_c,_LOWER) )
#define iswdigit(_c)	( iswctype(_c,_DIGIT) )
#define iswxdigit(_c)	( iswctype(_c,_HEX) )
#define iswspace(_c)	( iswctype(_c,_SPACE) )
#define iswpunct(_c)	( iswctype(_c,_PUNCT) )
#define iswalnum(_c)	( iswctype(_c,_ALPHA|_DIGIT) )
#define iswprint(_c)	( iswctype(_c,_BLANK|_PUNCT|_ALPHA|_DIGIT) )
#define iswgraph(_c)	( iswctype(_c,_PUNCT|_ALPHA|_DIGIT) )
#define iswcntrl(_c)	( iswctype(_c,_CONTROL) )
#define iswascii(_c)	( (unsigned)(_c) < 0x80 )

#define isleadbyte(_c)	(_pctype[(unsigned char)(_c)] & _LEADBYTE)

/* define structure for returning status information */

#ifndef _INO_T_DEFINED

typedef unsigned short _ino_t;		/* i-node number (not used on DOS) */

#if	!__STDC__
/* Non-ANSI name for compatibility */
#ifdef	_NTSDK
#define ino_t _ino_t
#else	/* ndef _NTSDK */
typedef unsigned short ino_t;
#endif	/* _NTSDK */
#endif

#define _INO_T_DEFINED
#endif


#ifndef _DEV_T_DEFINED

#ifdef	_NTSDK
typedef short _dev_t;			/* device code */
#else	/* ndef _NTSDK */
typedef unsigned int _dev_t;		/* device code */
#endif	/* _NTSDK */

#if	!__STDC__
/* Non-ANSI name for compatibility */
#ifdef	_NTSDK
#define dev_t _dev_t
#else	/* ndef _NTSDK */
typedef unsigned int dev_t;
#endif	/* _NTSDK */
#endif

#define _DEV_T_DEFINED
#endif

#ifndef _OFF_T_DEFINED

typedef long _off_t;			/* file offset value */

#if	!__STDC__
/* Non-ANSI name for compatibility */
#ifdef	_NTSDK
#define off_t _off_t
#else	/* ndef _NTSDK */
typedef long off_t;
#endif	/* _NTSDK */
#endif

#define _OFF_T_DEFINED
#endif

#ifndef _STAT_DEFINED

#ifdef	_MSC_VER
#pragma pack(push,4)
#endif	/* _MSC_VER */

struct _stat {
	_dev_t st_dev;
	_ino_t st_ino;
	unsigned short st_mode;
	short st_nlink;
	short st_uid;
	short st_gid;
	_dev_t st_rdev;
	_off_t st_size;
	time_t st_atime;
	time_t st_mtime;
	time_t st_ctime;
	};

#if	!__STDC__ && !defined(_NTSDK)

/* Non-ANSI names for compatibility */

struct stat {
	_dev_t st_dev;
	_ino_t st_ino;
	unsigned short st_mode;
	short st_nlink;
	short st_uid;
	short st_gid;
	_dev_t st_rdev;
	_off_t st_size;
	time_t st_atime;
	time_t st_mtime;
	time_t st_ctime;
	};

#endif	/* __STDC__ */

#ifdef	_MSC_VER
#pragma pack(pop)
#endif	/* _MSC_VER */

#define _STAT_DEFINED
#endif


#ifndef _WSTAT_DEFINED

/* also declared in stat.h */

_CRTIMP int __cdecl _wstat(const wchar_t *, struct _stat *);
#define _WSTAT_DEFINED
#endif


#ifndef _WSTDIO_DEFINED

/* also declared in stdio.h */

#ifdef	_POSIX_
_CRTIMP FILE * __cdecl _wfsopen(const wchar_t *, const wchar_t *);
#else
_CRTIMP FILE * __cdecl _wfsopen(const wchar_t *, const wchar_t *, int);
#endif

_CRTIMP wint_t __cdecl fgetwc(FILE *);
_CRTIMP wint_t __cdecl _fgetwchar(void);
_CRTIMP wint_t __cdecl fputwc(wint_t, FILE *);
_CRTIMP wint_t __cdecl _fputwchar(wint_t);
_CRTIMP wint_t __cdecl getwc(FILE *);
_CRTIMP wint_t __cdecl getwchar(void);
_CRTIMP wint_t __cdecl putwc(wint_t, FILE *);
_CRTIMP wint_t __cdecl putwchar(wint_t);
_CRTIMP wint_t __cdecl ungetwc(wint_t, FILE *);

_CRTIMP wchar_t * __cdecl fgetws(wchar_t *, int, FILE *);
_CRTIMP int __cdecl fputws(const wchar_t *, FILE *);
_CRTIMP wchar_t * __cdecl _getws(wchar_t *);
_CRTIMP int __cdecl _putws(const wchar_t *);

_CRTIMP int __cdecl fwprintf(FILE *, const wchar_t *, ...);
_CRTIMP int __cdecl wprintf(const wchar_t *, ...);
_CRTIMP int __cdecl _snwprintf(wchar_t *, size_t, const wchar_t *, ...);
_CRTIMP int __cdecl swprintf(wchar_t *, const wchar_t *, ...);
_CRTIMP int __cdecl vfwprintf(FILE *, const wchar_t *, va_list);
_CRTIMP int __cdecl vwprintf(const wchar_t *, va_list);
_CRTIMP int __cdecl _vsnwprintf(wchar_t *, size_t, const wchar_t *, va_list);
_CRTIMP int __cdecl vswprintf(wchar_t *, const wchar_t *, va_list);
_CRTIMP int __cdecl fwscanf(FILE *, const wchar_t *, ...);
_CRTIMP int __cdecl swscanf(const wchar_t *, const wchar_t *, ...);
_CRTIMP int __cdecl wscanf(const wchar_t *, ...);

#define getwchar()		fgetwc(stdin)
#define putwchar(_c)		fputwc((_c),stdout)
#define getwc(_stm)		fgetwc(_stm)
#define putwc(_c,_stm)		fputwc(_c,_stm)

_CRTIMP FILE * __cdecl _wfdopen(int, const wchar_t *);
_CRTIMP FILE * __cdecl _wfopen(const wchar_t *, const wchar_t *);
_CRTIMP FILE * __cdecl _wfreopen(const wchar_t *, const wchar_t *, FILE *);
_CRTIMP void __cdecl _wperror(const wchar_t *);
_CRTIMP FILE * __cdecl _wpopen(const wchar_t *, const wchar_t *);
_CRTIMP int __cdecl _wremove(const wchar_t *);
_CRTIMP wchar_t * __cdecl _wtempnam(wchar_t *, wchar_t *);
_CRTIMP wchar_t * __cdecl _wtmpnam(wchar_t *);

#define _WSTDIO_DEFINED
#endif


#ifndef _WSTDLIB_DEFINED

/* also declared in stdlib.h */

_CRTIMP wchar_t * __cdecl _itow (int, wchar_t *, int);
_CRTIMP wchar_t * __cdecl _ltow (long, wchar_t *, int);
_CRTIMP wchar_t * __cdecl _ultow (unsigned long, wchar_t *, int);
_CRTIMP double __cdecl wcstod(const wchar_t *, wchar_t **);
_CRTIMP long   __cdecl wcstol(const wchar_t *, wchar_t **, int);
_CRTIMP unsigned long __cdecl wcstoul(const wchar_t *, wchar_t **, int);
_CRTIMP wchar_t * __cdecl _wgetenv(const wchar_t *);
_CRTIMP int    __cdecl _wsystem(const wchar_t *);
_CRTIMP int __cdecl _wtoi(const wchar_t *);
_CRTIMP long __cdecl _wtol(const wchar_t *);

#define _WSTDLIB_DEFINED
#endif

#ifndef _POSIX_

#ifndef _WSTDLIBP_DEFINED

/* also declared in stdlib.h  */

_CRTIMP wchar_t * __cdecl _wfullpath(wchar_t *, const wchar_t *, size_t);
_CRTIMP void   __cdecl _wmakepath(wchar_t *, const wchar_t *, const wchar_t *, const wchar_t *,
	const wchar_t *);
_CRTIMP void   __cdecl _wperror(const wchar_t *);
_CRTIMP int    __cdecl _wputenv(const wchar_t *);
_CRTIMP void   __cdecl _wsearchenv(const wchar_t *, const wchar_t *, wchar_t *);
_CRTIMP void   __cdecl _wsplitpath(const wchar_t *, wchar_t *, wchar_t *, wchar_t *, wchar_t *);

#define _WSTDLIBP_DEFINED
#endif

#endif /* _POSIX_ */


#ifndef _WSTRING_DEFINED

/* also declared in string.h */

_CRTIMP wchar_t * __cdecl wcscat(wchar_t *, const wchar_t *);
_CRTIMP wchar_t * __cdecl wcschr(const wchar_t *, wchar_t);
_CRTIMP int __cdecl wcscmp(const wchar_t *, const wchar_t *);
_CRTIMP wchar_t * __cdecl wcscpy(wchar_t *, const wchar_t *);
_CRTIMP size_t __cdecl wcscspn(const wchar_t *, const wchar_t *);
_CRTIMP size_t __cdecl wcslen(const wchar_t *);
_CRTIMP wchar_t * __cdecl wcsncat(wchar_t *, const wchar_t *, size_t);
_CRTIMP int __cdecl wcsncmp(const wchar_t *, const wchar_t *, size_t);
_CRTIMP wchar_t * __cdecl wcsncpy(wchar_t *, const wchar_t *, size_t);
_CRTIMP wchar_t * __cdecl wcspbrk(const wchar_t *, const wchar_t *);
_CRTIMP wchar_t * __cdecl wcsrchr(const wchar_t *, wchar_t);
_CRTIMP size_t __cdecl wcsspn(const wchar_t *, const wchar_t *);
_CRTIMP wchar_t * __cdecl wcsstr(const wchar_t *, const wchar_t *);
_CRTIMP wchar_t * __cdecl wcstok(wchar_t *, const wchar_t *);

_CRTIMP wchar_t * __cdecl _wcsdup(const wchar_t *);
_CRTIMP int __cdecl _wcsicmp(const wchar_t *, const wchar_t *);
_CRTIMP int __cdecl _wcsnicmp(const wchar_t *, const wchar_t *, size_t);
_CRTIMP wchar_t * __cdecl _wcsnset(wchar_t *, wchar_t, size_t);
_CRTIMP wchar_t * __cdecl _wcsrev(wchar_t *);
_CRTIMP wchar_t * __cdecl _wcsset(wchar_t *, wchar_t);

_CRTIMP wchar_t * __cdecl _wcslwr(wchar_t *);
_CRTIMP wchar_t * __cdecl _wcsupr(wchar_t *);
_CRTIMP size_t __cdecl wcsxfrm(wchar_t *, const wchar_t *, size_t);
_CRTIMP int __cdecl wcscoll(const wchar_t *, const wchar_t *);
_CRTIMP int __cdecl _wcsicoll(const wchar_t *, const wchar_t *);
_CRTIMP int __cdecl _wcsnicoll(const wchar_t *, const wchar_t *, size_t);

/* Old names */
#define wcswcs wcsstr

#if	!__STDC__

#ifdef _NTSDK

/* Non-ANSI names for compatibility */
#define wcsdup	_wcsdup
#define wcsicmp	_wcsicmp
#define wcsnicmp _wcsnicmp
#define wcsnset	_wcsnset
#define wcsrev	_wcsrev
#define wcsset	_wcsset
#define wcslwr	_wcslwr
#define wcsupr	_wcsupr
#define wcsicoll _wcsicoll

#else /* ndef _NTSDK */

/* prototypes for oldnames.lib functions */
_CRTIMP wchar_t * __cdecl wcsdup(const wchar_t *);
_CRTIMP int __cdecl wcsicmp(const wchar_t *, const wchar_t *);
_CRTIMP int __cdecl wcsnicmp(const wchar_t *, const wchar_t *, size_t);
_CRTIMP wchar_t * __cdecl wcsnset(wchar_t *, wchar_t, size_t);
_CRTIMP wchar_t * __cdecl wcsrev(wchar_t *);
_CRTIMP wchar_t * __cdecl wcsset(wchar_t *, wchar_t);
_CRTIMP wchar_t * __cdecl wcslwr(wchar_t *);
_CRTIMP wchar_t * __cdecl wcsupr(wchar_t *);
_CRTIMP int __cdecl wcsicoll(const wchar_t *, const wchar_t *);

#endif /* ndef _NTSDK */

#endif /* !__STDC__ */

#define _WSTRING_DEFINED
#endif

#ifndef _TM_DEFINED
struct tm {
	int tm_sec;	/* seconds after the minute - [0,59] */
	int tm_min;	/* minutes after the hour - [0,59] */
	int tm_hour;	/* hours since midnight - [0,23] */
	int tm_mday;	/* day of the month - [1,31] */
	int tm_mon;	/* months since January - [0,11] */
	int tm_year;	/* years since 1900 */
	int tm_wday;	/* days since Sunday - [0,6] */
	int tm_yday;	/* days since January 1 - [0,365] */
	int tm_isdst;	/* daylight savings time flag */
	};
#define _TM_DEFINED
#endif

#ifndef _WTIME_DEFINED

/* also declared in time.h */
 
_CRTIMP wchar_t * __cdecl _wasctime(const struct tm *);
_CRTIMP wchar_t * __cdecl _wctime(const time_t *);
_CRTIMP size_t __cdecl wcsftime(wchar_t *, size_t, const char *,
	const struct tm *);
_CRTIMP wchar_t * __cdecl _wstrdate(wchar_t *);
_CRTIMP wchar_t * __cdecl _wstrtime(wchar_t *);

#define _WTIME_DEFINED
#endif


#ifdef __cplusplus
}
#endif

#endif	/* _INC_WCHAR */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\tools\c932\inc\winioctl.h ===
/*++ BUILD Version: 0012    // Increment this if a change has global effects

Copyright (c) 1990-1992  Microsoft Corporation

Module Name:

    winioctl.h

Abstract:

    This module defines the 32-Bit Windows Device I/O control codes.

Revision History:

--*/

#ifndef _WINIOCTL_
#define _WINIOCTL_


#ifndef _DEVIOCTL_
#define _DEVIOCTL_

// begin_ntddk begin_nthal begin_ntifs
//
// Define the various device type values.  Note that values used by Microsoft
// Corporation are in the range 0-32767, and 32768-65535 are reserved for use
// by customers.
//

#define DEVICE_TYPE DWORD

#define FILE_DEVICE_BEEP                0x00000001
#define FILE_DEVICE_CD_ROM              0x00000002
#define FILE_DEVICE_CD_ROM_FILE_SYSTEM  0x00000003
#define FILE_DEVICE_CONTROLLER          0x00000004
#define FILE_DEVICE_DATALINK            0x00000005
#define FILE_DEVICE_DFS                 0x00000006
#define FILE_DEVICE_DISK                0x00000007
#define FILE_DEVICE_DISK_FILE_SYSTEM    0x00000008
#define FILE_DEVICE_FILE_SYSTEM         0x00000009
#define FILE_DEVICE_INPORT_PORT         0x0000000a
#define FILE_DEVICE_KEYBOARD            0x0000000b
#define FILE_DEVICE_MAILSLOT            0x0000000c
#define FILE_DEVICE_MIDI_IN             0x0000000d
#define FILE_DEVICE_MIDI_OUT            0x0000000e
#define FILE_DEVICE_MOUSE               0x0000000f
#define FILE_DEVICE_MULTI_UNC_PROVIDER  0x00000010
#define FILE_DEVICE_NAMED_PIPE          0x00000011
#define FILE_DEVICE_NETWORK             0x00000012
#define FILE_DEVICE_NETWORK_BROWSER     0x00000013
#define FILE_DEVICE_NETWORK_FILE_SYSTEM 0x00000014
#define FILE_DEVICE_NULL                0x00000015
#define FILE_DEVICE_PARALLEL_PORT       0x00000016
#define FILE_DEVICE_PHYSICAL_NETCARD    0x00000017
#define FILE_DEVICE_PRINTER             0x00000018
#define FILE_DEVICE_SCANNER             0x00000019
#define FILE_DEVICE_SERIAL_MOUSE_PORT   0x0000001a
#define FILE_DEVICE_SERIAL_PORT         0x0000001b
#define FILE_DEVICE_SCREEN              0x0000001c
#define FILE_DEVICE_SOUND               0x0000001d
#define FILE_DEVICE_STREAMS             0x0000001e
#define FILE_DEVICE_TAPE                0x0000001f
#define FILE_DEVICE_TAPE_FILE_SYSTEM    0x00000020
#define FILE_DEVICE_TRANSPORT           0x00000021
#define FILE_DEVICE_UNKNOWN             0x00000022
#define FILE_DEVICE_VIDEO               0x00000023
#define FILE_DEVICE_VIRTUAL_DISK        0x00000024
#define FILE_DEVICE_WAVE_IN             0x00000025
#define FILE_DEVICE_WAVE_OUT            0x00000026
#define FILE_DEVICE_8042_PORT           0x00000027
#define FILE_DEVICE_NETWORK_REDIRECTOR  0x00000028

//
// Macro definition for defining IOCTL and FSCTL function control codes.  Note
// that function codes 0-2047 are reserved for Microsoft Corporation, and
// 2048-4095 are reserved for customers.
//

#define CTL_CODE( DeviceType, Function, Method, Access ) (                 \
    ((DeviceType) << 16) | ((Access) << 14) | ((Function) << 2) | (Method) \
)

//
// Define the method codes for how buffers are passed for I/O and FS controls
//

#define METHOD_BUFFERED                 0
#define METHOD_IN_DIRECT                1
#define METHOD_OUT_DIRECT               2
#define METHOD_NEITHER                  3

//
// Define the access check value for any access
//
//
// The FILE_READ_ACCESS and FILE_WRITE_ACCESS constants are also defined in
// ntioapi.h as FILE_READ_DATA and FILE_WRITE_DATA. The values for these
// constants *MUST* always be in sync.
//


#define FILE_ANY_ACCESS                 0
#define FILE_READ_ACCESS          ( 0x0001 )    // file & pipe
#define FILE_WRITE_ACCESS         ( 0x0002 )    // file & pipe

// end_ntddk end_nthal end_ntifs

#endif // _DEVIOCTL_


//
// IoControlCode values for disk devices.
//

#define IOCTL_DISK_BASE                 FILE_DEVICE_DISK
#define IOCTL_DISK_GET_DRIVE_GEOMETRY   CTL_CODE(IOCTL_DISK_BASE, 0x0000, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_DISK_GET_PARTITION_INFO   CTL_CODE(IOCTL_DISK_BASE, 0x0001, METHOD_BUFFERED, FILE_READ_ACCESS)
#define IOCTL_DISK_SET_PARTITION_INFO   CTL_CODE(IOCTL_DISK_BASE, 0x0002, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS)
#define IOCTL_DISK_GET_DRIVE_LAYOUT     CTL_CODE(IOCTL_DISK_BASE, 0x0003, METHOD_BUFFERED, FILE_READ_ACCESS)
#define IOCTL_DISK_SET_DRIVE_LAYOUT     CTL_CODE(IOCTL_DISK_BASE, 0x0004, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS)
#define IOCTL_DISK_VERIFY               CTL_CODE(IOCTL_DISK_BASE, 0x0005, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_DISK_FORMAT_TRACKS        CTL_CODE(IOCTL_DISK_BASE, 0x0006, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS)
#define IOCTL_DISK_REASSIGN_BLOCKS      CTL_CODE(IOCTL_DISK_BASE, 0x0007, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS)
#define IOCTL_DISK_PERFORMANCE          CTL_CODE(IOCTL_DISK_BASE, 0x0008, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_DISK_IS_WRITABLE          CTL_CODE(IOCTL_DISK_BASE, 0x0009, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_DISK_LOGGING              CTL_CODE(IOCTL_DISK_BASE, 0x000a, METHOD_BUFFERED, FILE_ANY_ACCESS)

//
// The following device control codes are common for all class drivers.  The
// functions codes defined here must match all of the other class drivers.
//

#define IOCTL_DISK_CHECK_VERIFY     CTL_CODE(IOCTL_DISK_BASE, 0x0200, METHOD_BUFFERED, FILE_READ_ACCESS)
#define IOCTL_DISK_MEDIA_REMOVAL    CTL_CODE(IOCTL_DISK_BASE, 0x0201, METHOD_BUFFERED, FILE_READ_ACCESS)
#define IOCTL_DISK_EJECT_MEDIA      CTL_CODE(IOCTL_DISK_BASE, 0x0202, METHOD_BUFFERED, FILE_READ_ACCESS)
#define IOCTL_DISK_LOAD_MEDIA       CTL_CODE(IOCTL_DISK_BASE, 0x0203, METHOD_BUFFERED, FILE_READ_ACCESS)
#define IOCTL_DISK_RESERVE          CTL_CODE(IOCTL_DISK_BASE, 0x0204, METHOD_BUFFERED, FILE_READ_ACCESS)
#define IOCTL_DISK_RELEASE          CTL_CODE(IOCTL_DISK_BASE, 0x0205, METHOD_BUFFERED, FILE_READ_ACCESS)
#define IOCTL_DISK_FIND_NEW_DEVICES CTL_CODE(IOCTL_DISK_BASE, 0x0206, METHOD_BUFFERED, FILE_READ_ACCESS)

#define IOCTL_DISK_GET_MEDIA_TYPES CTL_CODE(IOCTL_DISK_BASE, 0x0300, METHOD_BUFFERED, FILE_ANY_ACCESS)

//
// Define the partition types returnable by known disk drivers.
//

#define PARTITION_ENTRY_UNUSED          0x00      // Entry unused
#define PARTITION_FAT_12                0x01      // 12-bit FAT entries
#define PARTITION_XENIX_1               0x02      // Xenix
#define PARTITION_XENIX_2               0x03      // Xenix
#define PARTITION_FAT_16                0x04      // 16-bit FAT entries
#define PARTITION_EXTENDED              0x05      // Extended partition entry
#define PARTITION_HUGE                  0x06      // Huge partition MS-DOS V4
#define PARTITION_IFS                   0x07      // IFS Partition
#define PARTITION_UNIX                  0x63      // Unix

#define VALID_NTFT                      0xC0      // NTFT uses high order bits

//
// The following macro is used to determine which partitions should be
// assigned drive letters.
//

//++
//
// BOOLEAN
// IsRecognizedPartition(
//     IN DWORD PartitionType
//     )
//
// Routine Description:
//
//     This macro is used to determine to which partitions drive letters
//     should be assigned.
//
// Arguments:
//
//     PartitionType - Supplies the type of the partition being examined.
//
// Return Value:
//
//     The return value is TRUE if the partition type is recognized,
//     otherwise FALSE is returned.
//
//--

#define IsRecognizedPartition( PartitionType ) (       \
    (((PartitionType & ~0xC0) == PARTITION_FAT_12) ||  \
     ((PartitionType & ~0xC0) == PARTITION_FAT_16) ||  \
     ((PartitionType & ~0xC0) == PARTITION_IFS)    ||  \
     ((PartitionType & ~0xC0) == PARTITION_HUGE)) )

//
// The high bit of the partition type code indicates that a partition
// is part of an NTFT mirror or striped array.
//

#define PARTITION_NTFT                  0x80     // NTFT partition

//
// Define the media types supported by the driver.
//

typedef enum _MEDIA_TYPE {
    Unknown,                // Format is unknown
    F5_1Pt2_512,            // 5.25", 1.2MB,  512 bytes/sector
    F3_1Pt44_512,           // 3.5",  1.44MB, 512 bytes/sector
    F3_2Pt88_512,           // 3.5",  2.88MB, 512 bytes/sector
    F3_20Pt8_512,           // 3.5",  20.8MB, 512 bytes/sector
    F3_720_512,             // 3.5",  720KB,  512 bytes/sector
    F5_360_512,             // 5.25", 360KB,  512 bytes/sector
    F5_320_512,             // 5.25", 320KB,  512 bytes/sector
    F5_320_1024,            // 5.25", 320KB,  1024 bytes/sector
    F5_180_512,             // 5.25", 180KB,  512 bytes/sector
    F5_160_512,             // 5.25", 160KB,  512 bytes/sector
    RemovableMedia,         // Removable media other than floppy
    FixedMedia              // Fixed hard disk media
} MEDIA_TYPE, *PMEDIA_TYPE;

//
// Define the input buffer structure for the driver, when
// it is called with IOCTL_DISK_FORMAT_TRACKS.
//

typedef struct _FORMAT_PARAMETERS {
   MEDIA_TYPE MediaType;
   DWORD StartCylinderNumber;
   DWORD EndCylinderNumber;
   DWORD StartHeadNumber;
   DWORD EndHeadNumber;
} FORMAT_PARAMETERS, *PFORMAT_PARAMETERS;

//
// Define the BAD_TRACK_NUMBER type. An array of elements of this type is
// returned by the driver on IOCTL_DISK_FORMAT_TRACKS requests, to indicate
// what tracks were bad during formatting. The length of that array is
// reported in the `Information' field of the I/O Status Block.
//

typedef WORD   BAD_TRACK_NUMBER;
typedef WORD   *PBAD_TRACK_NUMBER;

//
// The following structure is returned on an IOCTL_DISK_GET_DRIVE_GEOMETRY
// request and an array of them is returned on an IOCTL_DISK_GET_MEDIA_TYPES
// request.
//

typedef struct _DISK_GEOMETRY {
    LARGE_INTEGER Cylinders;
    MEDIA_TYPE MediaType;
    DWORD TracksPerCylinder;
    DWORD SectorsPerTrack;
    DWORD BytesPerSector;
} DISK_GEOMETRY, *PDISK_GEOMETRY;

//
// The following structure is returned on an IOCTL_DISK_GET_PARTITION_INFO
// and an IOCTL_DISK_GET_DRIVE_LAYOUT request.  It is also used in a request
// to change the drive layout, IOCTL_DISK_SET_DRIVE_LAYOUT.
//

typedef struct _PARTITION_INFORMATION {
    LARGE_INTEGER StartingOffset;
    LARGE_INTEGER PartitionLength;
    DWORD HiddenSectors;
    DWORD PartitionNumber;
    BYTE  PartitionType;
    BOOLEAN BootIndicator;
    BOOLEAN RecognizedPartition;
    BOOLEAN RewritePartition;
} PARTITION_INFORMATION, *PPARTITION_INFORMATION;

//
// The following structure is used to change the partition type of a
// specified disk partition using an IOCTL_DISK_SET_PARTITION_INFO
// request.
//

typedef struct _SET_PARTITION_INFORMATION {
    BYTE  PartitionType;
} SET_PARTITION_INFORMATION, *PSET_PARTITION_INFORMATION;

//
// The following structures is returned on an IOCTL_DISK_GET_DRIVE_LAYOUT
// request and given as input to an IOCTL_DISK_SET_DRIVE_LAYOUT request.
//

typedef struct _DRIVE_LAYOUT_INFORMATION {
    DWORD PartitionCount;
    DWORD Signature;
    PARTITION_INFORMATION PartitionEntry[1];
} DRIVE_LAYOUT_INFORMATION, *PDRIVE_LAYOUT_INFORMATION;

//
// The following structure is passed in on an IOCTL_DISK_VERIFY request.
// The offset and length parameters are both given in bytes.
//

typedef struct _VERIFY_INFORMATION {
    LARGE_INTEGER StartingOffset;
    DWORD Length;
} VERIFY_INFORMATION, *PVERIFY_INFORMATION;

//
// The following structure is passed in on an IOCTL_DISK_REASSIGN_BLOCKS
// request.
//

typedef struct _REASSIGN_BLOCKS {
    WORD   Reserved;
    WORD   Count;
    DWORD BlockNumber[1];
} REASSIGN_BLOCKS, *PREASSIGN_BLOCKS;

//
// IOCTL_DISK_MEDIA_REMOVAL disables the mechanism
// on a SCSI device that ejects media. This function
// may or may not be supported on SCSI devices that
// support removable media.
//
// TRUE means prevent media from being removed.
// FALSE means allow media removal.
//

typedef struct _PREVENT_MEDIA_REMOVAL {
    BOOLEAN PreventMediaRemoval;
} PREVENT_MEDIA_REMOVAL, *PPREVENT_MEDIA_REMOVAL;

///////////////////////////////////////////////////////
//                                                   //
// The following structures define disk debugging    //
// capabilities. The IOCTLs are directed to one of   //
// the two disk filter drivers.                      //
//                                                   //
// DISKPERF is a utilty for collecting disk request  //
// statistics.                                       //
//                                                   //
// SIMBAD is a utility for injecting faults in       //
// IO requests to disks.                             //
//                                                   //
///////////////////////////////////////////////////////

//
// The following structure is exchanged on an IOCTL_DISK_GET_PERFORMANCE
// request. This ioctl collects summary disk request statistics used
// in measuring performance.
//

typedef struct _DISK_PERFORMANCE {
        LARGE_INTEGER BytesRead;
        LARGE_INTEGER BytesWritten;
        LARGE_INTEGER ReadTime;
        LARGE_INTEGER WriteTime;
        DWORD ReadCount;
        DWORD WriteCount;
        DWORD QueueDepth;
} DISK_PERFORMANCE, *PDISK_PERFORMANCE;

//
// This structure defines the disk logging record. When disk logging
// is enabled, one of these is written to an internal buffer for each
// disk request.
//

typedef struct _DISK_RECORD {
   LARGE_INTEGER ByteOffset;
   LARGE_INTEGER StartTime;
   LARGE_INTEGER EndTime;
   DWORD NumberOfBytes;
   BYTE  DeviceNumber;
   BOOLEAN ReadRequest;
} DISK_RECORD, *PDISK_RECORD;

//
// The following structure is exchanged on an IOCTL_DISK_LOG request.
// Not all fields are valid with each function type.
//

typedef struct _DISK_LOGGING {
    BYTE  Function;
    PVOID BufferAddress;
    DWORD BufferSize;
} DISK_LOGGING, *PDISK_LOGGING;

//
// Disk logging functions
//
// Start disk logging. Only the Function and BufferSize fields are valid.
//

#define DISK_LOGGING_START    0

//
// Stop disk logging. Only the Function field is valid.
//

#define DISK_LOGGING_STOP     1

//
// Return disk log. All fields are valid. Data will be copied from internal
// buffer to buffer specified for the number of bytes requested.
//

#define DISK_LOGGING_DUMP     2


#define IOCTL_SERIAL_LSRMST_INSERT      CTL_CODE(FILE_DEVICE_SERIAL_PORT,31,METHOD_BUFFERED,FILE_ANY_ACCESS)


//
// The following values follow the escape designator in the
// data stream if the LSRMST_INSERT mode has been turned on.
//
#define SERIAL_LSRMST_ESCAPE     ((BYTE )0x00)

//
// Following this value is the contents of the line status
// register, and then the character in the RX hardware when
// the line status register was encountered.
//
#define SERIAL_LSRMST_LSR_DATA   ((BYTE )0x01)

//
// Following this value is the contents of the line status
// register.  No error character follows
//
#define SERIAL_LSRMST_LSR_NODATA ((BYTE )0x02)

//
// Following this value is the contents of the modem status
// register.
//
#define SERIAL_LSRMST_MST        ((BYTE )0x03)


#define FSCTL_LOCK_VOLUME               CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 6, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define FSCTL_UNLOCK_VOLUME             CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 7, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define FSCTL_DISMOUNT_VOLUME           CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 8, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define FSCTL_MOUNT_DBLS_VOLUME         CTL_CODE(FILE_DEVICE_FILE_SYSTEM,13, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define FSCTL_GET_COMPRESSION           CTL_CODE(FILE_DEVICE_FILE_SYSTEM,15, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define FSCTL_SET_COMPRESSION           CTL_CODE(FILE_DEVICE_FILE_SYSTEM,16, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define FSCTL_READ_COMPRESSION          CTL_CODE(FILE_DEVICE_FILE_SYSTEM,17, METHOD_NEITHER,  FILE_ANY_ACCESS)
#define FSCTL_WRITE_COMPRESSION         CTL_CODE(FILE_DEVICE_FILE_SYSTEM,18, METHOD_NEITHER,  FILE_ANY_ACCESS)


#endif // _WINIOCTL_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\tools\c932\inc\winsock.h ===
/* WINSOCK.H--definitions to be used with the WINSOCK.DLL
 *
 * This header file corresponds to version 1.1 of the Windows Sockets specification.
 *
 * This file includes parts which are Copyright (c) 1982-1986 Regents
 * of the University of California.  All rights reserved.  The
 * Berkeley Software License Agreement specifies the terms and
 * conditions for redistribution.
 *
 */

#ifndef _WINSOCKAPI_
#define _WINSOCKAPI_

/*
 * Pull in WINDOWS.H if necessary
 */
#ifndef _INC_WINDOWS
#include <windows.h>
#endif /* _INC_WINDOWS */

/*
 * Basic system type definitions, taken from the BSD file sys/types.h.
 */
typedef unsigned char   u_char;
typedef unsigned short  u_short;
typedef unsigned int    u_int;
typedef unsigned long   u_long;

/*
 * The new type to be used in all
 * instances which refer to sockets.
 */
typedef u_int           SOCKET;

/*
 * Select uses arrays of SOCKETs.  These macros manipulate such
 * arrays.  FD_SETSIZE may be defined by the user before including
 * this file, but the default here should be >= 64.
 *
 * CAVEAT IMPLEMENTOR and USER: THESE MACROS AND TYPES MUST BE
 * INCLUDED IN WINSOCK.H EXACTLY AS SHOWN HERE.
 */
#ifndef FD_SETSIZE
#define FD_SETSIZE      64
#endif /* FD_SETSIZE */

typedef struct fd_set {
        u_int   fd_count;               /* how many are SET? */
        SOCKET  fd_array[FD_SETSIZE];   /* an array of SOCKETs */
} fd_set;

#ifdef __cplusplus
extern "C" {
#endif

extern int PASCAL FAR __WSAFDIsSet(SOCKET, fd_set FAR *);

#ifdef __cplusplus
}
#endif


#define FD_CLR(fd, set) do { \
    u_int __i; \
    for (__i = 0; __i < ((fd_set FAR *)(set))->fd_count ; __i++) { \
        if (((fd_set FAR *)(set))->fd_array[__i] == fd) { \
            while (__i < ((fd_set FAR *)(set))->fd_count-1) { \
                ((fd_set FAR *)(set))->fd_array[__i] = \
                    ((fd_set FAR *)(set))->fd_array[__i+1]; \
                __i++; \
            } \
            ((fd_set FAR *)(set))->fd_count--; \
            break; \
        } \
    } \
} while(0)

#define FD_SET(fd, set) do { \
    if (((fd_set FAR *)(set))->fd_count < FD_SETSIZE) \
        ((fd_set FAR *)(set))->fd_array[((fd_set FAR *)(set))->fd_count++]=(fd);\
} while(0)

#define FD_ZERO(set) (((fd_set FAR *)(set))->fd_count=0)

#define FD_ISSET(fd, set) __WSAFDIsSet((SOCKET)(fd), (fd_set FAR *)(set))

/*
 * Structure used in select() call, taken from the BSD file sys/time.h.
 */
struct timeval {
        long    tv_sec;         /* seconds */
        long    tv_usec;        /* and microseconds */
};

/*
 * Operations on timevals.
 *
 * NB: timercmp does not work for >= or <=.
 */
#define timerisset(tvp)         ((tvp)->tv_sec || (tvp)->tv_usec)
#define timercmp(tvp, uvp, cmp) \
        ((tvp)->tv_sec cmp (uvp)->tv_sec || \
         (tvp)->tv_sec == (uvp)->tv_sec && (tvp)->tv_usec cmp (uvp)->tv_usec)
#define timerclear(tvp)         (tvp)->tv_sec = (tvp)->tv_usec = 0

/*
 * Commands for ioctlsocket(),  taken from the BSD file fcntl.h.
 *
 *
 * Ioctl's have the command encoded in the lower word,
 * and the size of any in or out parameters in the upper
 * word.  The high 2 bits of the upper word are used
 * to encode the in/out status of the parameter; for now
 * we restrict parameters to at most 128 bytes.
 */
#define IOCPARM_MASK    0x7f            /* parameters must be < 128 bytes */
#define IOC_VOID        0x20000000      /* no parameters */
#define IOC_OUT         0x40000000      /* copy out parameters */
#define IOC_IN          0x80000000      /* copy in parameters */
#define IOC_INOUT       (IOC_IN|IOC_OUT)
                                        /* 0x20000000 distinguishes new &
                                           old ioctl's */
#define _IO(x,y)        (IOC_VOID|((x)<<8)|(y))

#define _IOR(x,y,t)     (IOC_OUT|(((long)sizeof(t)&IOCPARM_MASK)<<16)|((x)<<8)|(y))

#define _IOW(x,y,t)     (IOC_IN|(((long)sizeof(t)&IOCPARM_MASK)<<16)|((x)<<8)|(y))

#define FIONREAD    _IOR('f', 127, u_long) /* get # bytes to read */
#define FIONBIO     _IOW('f', 126, u_long) /* set/clear non-blocking i/o */
#define FIOASYNC    _IOW('f', 125, u_long) /* set/clear async i/o */

/* Socket I/O Controls */
#define SIOCSHIWAT  _IOW('s',  0, u_long)  /* set high watermark */
#define SIOCGHIWAT  _IOR('s',  1, u_long)  /* get high watermark */
#define SIOCSLOWAT  _IOW('s',  2, u_long)  /* set low watermark */
#define SIOCGLOWAT  _IOR('s',  3, u_long)  /* get low watermark */
#define SIOCATMARK  _IOR('s',  7, u_long)  /* at oob mark? */

/*
 * Structures returned by network data base library, taken from the
 * BSD file netdb.h.  All addresses are supplied in host order, and
 * returned in network order (suitable for use in system calls).
 */

struct  hostent {
        char    FAR * h_name;           /* official name of host */
        char    FAR * FAR * h_aliases;  /* alias list */
        short   h_addrtype;             /* host address type */
        short   h_length;               /* length of address */
        char    FAR * FAR * h_addr_list; /* list of addresses */
#define h_addr  h_addr_list[0]          /* address, for backward compat */
};

/*
 * It is assumed here that a network number
 * fits in 32 bits.
 */
struct  netent {
        char    FAR * n_name;           /* official name of net */
        char    FAR * FAR * n_aliases;  /* alias list */
        short   n_addrtype;             /* net address type */
        u_long  n_net;                  /* network # */
};

struct  servent {
        char    FAR * s_name;           /* official service name */
        char    FAR * FAR * s_aliases;  /* alias list */
        short   s_port;                 /* port # */
        char    FAR * s_proto;          /* protocol to use */
};

struct  protoent {
        char    FAR * p_name;           /* official protocol name */
        char    FAR * FAR * p_aliases;  /* alias list */
        short   p_proto;                /* protocol # */
};

/*
 * Constants and structures defined by the internet system,
 * Per RFC 790, September 1981, taken from the BSD file netinet/in.h.
 */

/*
 * Protocols
 */
#define IPPROTO_IP              0               /* dummy for IP */
#define IPPROTO_ICMP            1               /* control message protocol */
#define IPPROTO_GGP             2               /* gateway^2 (deprecated) */
#define IPPROTO_TCP             6               /* tcp */
#define IPPROTO_PUP             12              /* pup */
#define IPPROTO_UDP             17              /* user datagram protocol */
#define IPPROTO_IDP             22              /* xns idp */
#define IPPROTO_ND              77              /* UNOFFICIAL net disk proto */

#define IPPROTO_RAW             255             /* raw IP packet */
#define IPPROTO_MAX             256

/*
 * Port/socket numbers: network standard functions
 */
#define IPPORT_ECHO             7
#define IPPORT_DISCARD          9
#define IPPORT_SYSTAT           11
#define IPPORT_DAYTIME          13
#define IPPORT_NETSTAT          15
#define IPPORT_FTP              21
#define IPPORT_TELNET           23
#define IPPORT_SMTP             25
#define IPPORT_TIMESERVER       37
#define IPPORT_NAMESERVER       42
#define IPPORT_WHOIS            43
#define IPPORT_MTP              57

/*
 * Port/socket numbers: host specific functions
 */
#define IPPORT_TFTP             69
#define IPPORT_RJE              77
#define IPPORT_FINGER           79
#define IPPORT_TTYLINK          87
#define IPPORT_SUPDUP           95

/*
 * UNIX TCP sockets
 */
#define IPPORT_EXECSERVER       512
#define IPPORT_LOGINSERVER      513
#define IPPORT_CMDSERVER        514
#define IPPORT_EFSSERVER        520

/*
 * UNIX UDP sockets
 */
#define IPPORT_BIFFUDP          512
#define IPPORT_WHOSERVER        513
#define IPPORT_ROUTESERVER      520
                                        /* 520+1 also used */

/*
 * Ports < IPPORT_RESERVED are reserved for
 * privileged processes (e.g. root).
 */
#define IPPORT_RESERVED         1024

/*
 * Link numbers
 */
#define IMPLINK_IP              155
#define IMPLINK_LOWEXPER        156
#define IMPLINK_HIGHEXPER       158

/*
 * Internet address (old style... should be updated)
 */
struct in_addr {
        union {
                struct { u_char s_b1,s_b2,s_b3,s_b4; } S_un_b;
                struct { u_short s_w1,s_w2; } S_un_w;
                u_long S_addr;
        } S_un;
#define s_addr  S_un.S_addr
                                /* can be used for most tcp & ip code */
#define s_host  S_un.S_un_b.s_b2
                                /* host on imp */
#define s_net   S_un.S_un_b.s_b1
                                /* network */
#define s_imp   S_un.S_un_w.s_w2
                                /* imp */
#define s_impno S_un.S_un_b.s_b4
                                /* imp # */
#define s_lh    S_un.S_un_b.s_b3
                                /* logical host */
};

/*
 * Definitions of bits in internet address integers.
 * On subnets, the decomposition of addresses to host and net parts
 * is done according to subnet mask, not the masks here.
 */
#define IN_CLASSA(i)            (((long)(i) & 0x80000000) == 0)
#define IN_CLASSA_NET           0xff000000
#define IN_CLASSA_NSHIFT        24
#define IN_CLASSA_HOST          0x00ffffff
#define IN_CLASSA_MAX           128

#define IN_CLASSB(i)            (((long)(i) & 0xc0000000) == 0x80000000)
#define IN_CLASSB_NET           0xffff0000
#define IN_CLASSB_NSHIFT        16
#define IN_CLASSB_HOST          0x0000ffff
#define IN_CLASSB_MAX           65536

#define IN_CLASSC(i)            (((long)(i) & 0xe0000000) == 0xc0000000)
#define IN_CLASSC_NET           0xffffff00
#define IN_CLASSC_NSHIFT        8
#define IN_CLASSC_HOST          0x000000ff

#define INADDR_ANY              (u_long)0x00000000
#define INADDR_LOOPBACK         0x7f000001
#define INADDR_BROADCAST        (u_long)0xffffffff
#define INADDR_NONE             0xffffffff

/*
 * Socket address, internet style.
 */
struct sockaddr_in {
        short   sin_family;
        u_short sin_port;
        struct  in_addr sin_addr;
        char    sin_zero[8];
};

#define WSADESCRIPTION_LEN      256
#define WSASYS_STATUS_LEN       128

typedef struct WSAData {
        WORD                    wVersion;
        WORD                    wHighVersion;
        char                    szDescription[WSADESCRIPTION_LEN+1];
        char                    szSystemStatus[WSASYS_STATUS_LEN+1];
        unsigned short          iMaxSockets;
        unsigned short          iMaxUdpDg;
        char FAR *              lpVendorInfo;
} WSADATA;

typedef WSADATA FAR *LPWSADATA;

/*
 * Options for use with [gs]etsockopt at the IP level.
 */
#define IP_OPTIONS          1           /* set/get IP per-packet options    */
#define IP_MULTICAST_IF     2           /* set/get IP multicast interface   */
#define IP_MULTICAST_TTL    3           /* set/get IP multicast timetolive  */
#define IP_MULTICAST_LOOP   4           /* set/get IP multicast loopback    */
#define IP_ADD_MEMBERSHIP   5           /* add  an IP group membership      */
#define IP_DROP_MEMBERSHIP  6           /* drop an IP group membership      */

#define IP_DEFAULT_MULTICAST_TTL   1    /* normally limit m'casts to 1 hop  */
#define IP_DEFAULT_MULTICAST_LOOP  1    /* normally hear sends if a member  */
#define IP_MAX_MEMBERSHIPS         20   /* per socket; must fit in one mbuf */

/*
 * Argument structure for IP_ADD_MEMBERSHIP and IP_DROP_MEMBERSHIP.
 */
struct ip_mreq {
        struct in_addr  imr_multiaddr;  /* IP multicast address of group */
        struct in_addr  imr_interface;  /* local IP address of interface */
};

/*
 * Definitions related to sockets: types, address families, options,
 * taken from the BSD file sys/socket.h.
 */

/*
 * This is used instead of -1, since the
 * SOCKET type is unsigned.
 */
#define INVALID_SOCKET  (SOCKET)(~0)
#define SOCKET_ERROR            (-1)

/*
 * Types
 */
#define SOCK_STREAM     1               /* stream socket */
#define SOCK_DGRAM      2               /* datagram socket */
#define SOCK_RAW        3               /* raw-protocol interface */
#define SOCK_RDM        4               /* reliably-delivered message */
#define SOCK_SEQPACKET  5               /* sequenced packet stream */

/*
 * Option flags per-socket.
 */
#define SO_DEBUG        0x0001          /* turn on debugging info recording */
#define SO_ACCEPTCONN   0x0002          /* socket has had listen() */
#define SO_REUSEADDR    0x0004          /* allow local address reuse */
#define SO_KEEPALIVE    0x0008          /* keep connections alive */
#define SO_DONTROUTE    0x0010          /* just use interface addresses */
#define SO_BROADCAST    0x0020          /* permit sending of broadcast msgs */
#define SO_USELOOPBACK  0x0040          /* bypass hardware when possible */
#define SO_LINGER       0x0080          /* linger on close if data present */
#define SO_OOBINLINE    0x0100          /* leave received OOB data in line */

#define SO_DONTLINGER   (u_int)(~SO_LINGER)

/*
 * Additional options.
 */
#define SO_SNDBUF       0x1001          /* send buffer size */
#define SO_RCVBUF       0x1002          /* receive buffer size */
#define SO_SNDLOWAT     0x1003          /* send low-water mark */
#define SO_RCVLOWAT     0x1004          /* receive low-water mark */
#define SO_SNDTIMEO     0x1005          /* send timeout */
#define SO_RCVTIMEO     0x1006          /* receive timeout */
#define SO_ERROR        0x1007          /* get error status and clear */
#define SO_TYPE         0x1008          /* get socket type */

/*
 * Options for connect and disconnect data and options.  Used only by
 * non-TCP/IP transports such as DECNet, OSI TP4, etc.
 */
#define SO_CONNDATA     0x7000
#define SO_CONNOPT      0x7001
#define SO_DISCDATA     0x7002
#define SO_DISCOPT      0x7003
#define SO_CONNDATALEN  0x7004
#define SO_CONNOPTLEN   0x7005
#define SO_DISCDATALEN  0x7006
#define SO_DISCOPTLEN   0x7007

/*
 * Option for opening sockets for synchronous access.
 */
#define SO_OPENTYPE     0x7008

#define SO_SYNCHRONOUS_ALERT    0x10
#define SO_SYNCHRONOUS_NONALERT 0x20

/*
 * Other NT-specific options.
 */
#define SO_MAXDG        0x7009
#define SO_MAXPATHDG    0x700A

/*
 * TCP options.
 */
#define TCP_NODELAY     0x0001
#define TCP_BSDURGENT   0x7000

/*
 * Address families.
 */
#define AF_UNSPEC       0               /* unspecified */
#define AF_UNIX         1               /* local to host (pipes, portals) */
#define AF_INET         2               /* internetwork: UDP, TCP, etc. */
#define AF_IMPLINK      3               /* arpanet imp addresses */
#define AF_PUP          4               /* pup protocols: e.g. BSP */
#define AF_CHAOS        5               /* mit CHAOS protocols */
#define AF_IPX          6               /* IPX and SPX */
#define AF_NS           6               /* XEROX NS protocols */
#define AF_ISO          7               /* ISO protocols */
#define AF_OSI          AF_ISO          /* OSI is ISO */
#define AF_ECMA         8               /* european computer manufacturers */
#define AF_DATAKIT      9               /* datakit protocols */
#define AF_CCITT        10              /* CCITT protocols, X.25 etc */
#define AF_SNA          11              /* IBM SNA */
#define AF_DECnet       12              /* DECnet */
#define AF_DLI          13              /* Direct data link interface */
#define AF_LAT          14              /* LAT */
#define AF_HYLINK       15              /* NSC Hyperchannel */
#define AF_APPLETALK    16              /* AppleTalk */
#define AF_NETBIOS      17              /* NetBios-style addresses */
#define AF_VOICEVIEW    18              /* VoiceView */

#define AF_MAX          19

/*
 * Structure used by kernel to store most
 * addresses.
 */
struct sockaddr {
        u_short sa_family;              /* address family */
        char    sa_data[14];            /* up to 14 bytes of direct address */
};

/*
 * Structure used by kernel to pass protocol
 * information in raw sockets.
 */
struct sockproto {
        u_short sp_family;              /* address family */
        u_short sp_protocol;            /* protocol */
};

/*
 * Protocol families, same as address families for now.
 */
#define PF_UNSPEC       AF_UNSPEC
#define PF_UNIX         AF_UNIX
#define PF_INET         AF_INET
#define PF_IMPLINK      AF_IMPLINK
#define PF_PUP          AF_PUP
#define PF_CHAOS        AF_CHAOS
#define PF_NS           AF_NS
#define PF_IPX          AF_IPX
#define PF_ISO          AF_ISO
#define PF_OSI          AF_OSI
#define PF_ECMA         AF_ECMA
#define PF_DATAKIT      AF_DATAKIT
#define PF_CCITT        AF_CCITT
#define PF_SNA          AF_SNA
#define PF_DECnet       AF_DECnet
#define PF_DLI          AF_DLI
#define PF_LAT          AF_LAT
#define PF_HYLINK       AF_HYLINK
#define PF_APPLETALK    AF_APPLETALK
#define PF_VOICEVIEW    AF_VOICEVIEW

#define PF_MAX          AF_MAX

/*
 * Structure used for manipulating linger option.
 */
struct  linger {
        u_short l_onoff;                /* option on/off */
        u_short l_linger;               /* linger time */
};

/*
 * Level number for (get/set)sockopt() to apply to socket itself.
 */
#define SOL_SOCKET      0xffff          /* options for socket level */

/*
 * Maximum queue length specifiable by listen.
 */
#define SOMAXCONN       5

#define MSG_OOB         0x1             /* process out-of-band data */
#define MSG_PEEK        0x2             /* peek at incoming message */
#define MSG_DONTROUTE   0x4             /* send without using routing tables */

#define MSG_MAXIOVLEN   16

#define MSG_PARTIAL     0x8000          /* partial send or recv for message xport */

/*
 * Define constant based on rfc883, used by gethostbyxxxx() calls.
 */
#define MAXGETHOSTSTRUCT        1024

/*
 * Define flags to be used with the WSAAsyncSelect() call.
 */
#define FD_READ         0x01
#define FD_WRITE        0x02
#define FD_OOB          0x04
#define FD_ACCEPT       0x08
#define FD_CONNECT      0x10
#define FD_CLOSE        0x20

/*
 * All Windows Sockets error constants are biased by WSABASEERR from
 * the "normal"
 */
#define WSABASEERR              10000
/*
 * Windows Sockets definitions of regular Microsoft C error constants
 */
#define WSAEINTR                (WSABASEERR+4)
#define WSAEBADF                (WSABASEERR+9)
#define WSAEACCES               (WSABASEERR+13)
#define WSAEFAULT               (WSABASEERR+14)
#define WSAEINVAL               (WSABASEERR+22)
#define WSAEMFILE               (WSABASEERR+24)

/*
 * Windows Sockets definitions of regular Berkeley error constants
 */
#define WSAEWOULDBLOCK          (WSABASEERR+35)
#define WSAEINPROGRESS          (WSABASEERR+36)
#define WSAEALREADY             (WSABASEERR+37)
#define WSAENOTSOCK             (WSABASEERR+38)
#define WSAEDESTADDRREQ         (WSABASEERR+39)
#define WSAEMSGSIZE             (WSABASEERR+40)
#define WSAEPROTOTYPE           (WSABASEERR+41)
#define WSAENOPROTOOPT          (WSABASEERR+42)
#define WSAEPROTONOSUPPORT      (WSABASEERR+43)
#define WSAESOCKTNOSUPPORT      (WSABASEERR+44)
#define WSAEOPNOTSUPP           (WSABASEERR+45)
#define WSAEPFNOSUPPORT         (WSABASEERR+46)
#define WSAEAFNOSUPPORT         (WSABASEERR+47)
#define WSAEADDRINUSE           (WSABASEERR+48)
#define WSAEADDRNOTAVAIL        (WSABASEERR+49)
#define WSAENETDOWN             (WSABASEERR+50)
#define WSAENETUNREACH          (WSABASEERR+51)
#define WSAENETRESET            (WSABASEERR+52)
#define WSAECONNABORTED         (WSABASEERR+53)
#define WSAECONNRESET           (WSABASEERR+54)
#define WSAENOBUFS              (WSABASEERR+55)
#define WSAEISCONN              (WSABASEERR+56)
#define WSAENOTCONN             (WSABASEERR+57)
#define WSAESHUTDOWN            (WSABASEERR+58)
#define WSAETOOMANYREFS         (WSABASEERR+59)
#define WSAETIMEDOUT            (WSABASEERR+60)
#define WSAECONNREFUSED         (WSABASEERR+61)
#define WSAELOOP                (WSABASEERR+62)
#define WSAENAMETOOLONG         (WSABASEERR+63)
#define WSAEHOSTDOWN            (WSABASEERR+64)
#define WSAEHOSTUNREACH         (WSABASEERR+65)
#define WSAENOTEMPTY            (WSABASEERR+66)
#define WSAEPROCLIM             (WSABASEERR+67)
#define WSAEUSERS               (WSABASEERR+68)
#define WSAEDQUOT               (WSABASEERR+69)
#define WSAESTALE               (WSABASEERR+70)
#define WSAEREMOTE              (WSABASEERR+71)

#define WSAEDISCON              (WSABASEERR+101)

/*
 * Extended Windows Sockets error constant definitions
 */
#define WSASYSNOTREADY          (WSABASEERR+91)
#define WSAVERNOTSUPPORTED      (WSABASEERR+92)
#define WSANOTINITIALISED       (WSABASEERR+93)

/*
 * Error return codes from gethostbyname() and gethostbyaddr()
 * (when using the resolver). Note that these errors are
 * retrieved via WSAGetLastError() and must therefore follow
 * the rules for avoiding clashes with error numbers from
 * specific implementations or language run-time systems.
 * For this reason the codes are based at WSABASEERR+1001.
 * Note also that [WSA]NO_ADDRESS is defined only for
 * compatibility purposes.
 */

#define h_errno         WSAGetLastError()

/* Authoritative Answer: Host not found */
#define WSAHOST_NOT_FOUND       (WSABASEERR+1001)
#define HOST_NOT_FOUND          WSAHOST_NOT_FOUND

/* Non-Authoritative: Host not found, or SERVERFAIL */
#define WSATRY_AGAIN            (WSABASEERR+1002)
#define TRY_AGAIN               WSATRY_AGAIN

/* Non recoverable errors, FORMERR, REFUSED, NOTIMP */
#define WSANO_RECOVERY          (WSABASEERR+1003)
#define NO_RECOVERY             WSANO_RECOVERY

/* Valid name, no data record of requested type */
#define WSANO_DATA              (WSABASEERR+1004)
#define NO_DATA                 WSANO_DATA

/* no address, look for MX record */
#define WSANO_ADDRESS           WSANO_DATA
#define NO_ADDRESS              WSANO_ADDRESS

/*
 * Windows Sockets errors redefined as regular Berkeley error constants.
 * These are commented out in Windows NT to avoid conflicts with errno.h.
 * Use the WSA constants instead.
 */
#if 0
#define EWOULDBLOCK             WSAEWOULDBLOCK
#define EINPROGRESS             WSAEINPROGRESS
#define EALREADY                WSAEALREADY
#define ENOTSOCK                WSAENOTSOCK
#define EDESTADDRREQ            WSAEDESTADDRREQ
#define EMSGSIZE                WSAEMSGSIZE
#define EPROTOTYPE              WSAEPROTOTYPE
#define ENOPROTOOPT             WSAENOPROTOOPT
#define EPROTONOSUPPORT         WSAEPROTONOSUPPORT
#define ESOCKTNOSUPPORT         WSAESOCKTNOSUPPORT
#define EOPNOTSUPP              WSAEOPNOTSUPP
#define EPFNOSUPPORT            WSAEPFNOSUPPORT
#define EAFNOSUPPORT            WSAEAFNOSUPPORT
#define EADDRINUSE              WSAEADDRINUSE
#define EADDRNOTAVAIL           WSAEADDRNOTAVAIL
#define ENETDOWN                WSAENETDOWN
#define ENETUNREACH             WSAENETUNREACH
#define ENETRESET               WSAENETRESET
#define ECONNABORTED            WSAECONNABORTED
#define ECONNRESET              WSAECONNRESET
#define ENOBUFS                 WSAENOBUFS
#define EISCONN                 WSAEISCONN
#define ENOTCONN                WSAENOTCONN
#define ESHUTDOWN               WSAESHUTDOWN
#define ETOOMANYREFS            WSAETOOMANYREFS
#define ETIMEDOUT               WSAETIMEDOUT
#define ECONNREFUSED            WSAECONNREFUSED
#define ELOOP                   WSAELOOP
#define ENAMETOOLONG            WSAENAMETOOLONG
#define EHOSTDOWN               WSAEHOSTDOWN
#define EHOSTUNREACH            WSAEHOSTUNREACH
#define ENOTEMPTY               WSAENOTEMPTY
#define EPROCLIM                WSAEPROCLIM
#define EUSERS                  WSAEUSERS
#define EDQUOT                  WSAEDQUOT
#define ESTALE                  WSAESTALE
#define EREMOTE                 WSAEREMOTE
#endif

/* Socket function prototypes */

#ifdef __cplusplus
extern "C" {
#endif

SOCKET PASCAL FAR accept (SOCKET s, struct sockaddr FAR *addr,
                          int FAR *addrlen);

int PASCAL FAR bind (SOCKET s, const struct sockaddr FAR *addr, int namelen);

int PASCAL FAR closesocket (SOCKET s);

int PASCAL FAR connect (SOCKET s, const struct sockaddr FAR *name, int namelen);

int PASCAL FAR ioctlsocket (SOCKET s, long cmd, u_long FAR *argp);

int PASCAL FAR getpeername (SOCKET s, struct sockaddr FAR *name,
                            int FAR * namelen);

int PASCAL FAR getsockname (SOCKET s, struct sockaddr FAR *name,
                            int FAR * namelen);

int PASCAL FAR getsockopt (SOCKET s, int level, int optname,
                           char FAR * optval, int FAR *optlen);

u_long PASCAL FAR htonl (u_long hostlong);

u_short PASCAL FAR htons (u_short hostshort);

unsigned long PASCAL FAR inet_addr (const char FAR * cp);

char FAR * PASCAL FAR inet_ntoa (struct in_addr in);

int PASCAL FAR listen (SOCKET s, int backlog);

u_long PASCAL FAR ntohl (u_long netlong);

u_short PASCAL FAR ntohs (u_short netshort);

int PASCAL FAR recv (SOCKET s, char FAR * buf, int len, int flags);

int PASCAL FAR recvfrom (SOCKET s, char FAR * buf, int len, int flags,
                         struct sockaddr FAR *from, int FAR * fromlen);

int PASCAL FAR select (int nfds, fd_set FAR *readfds, fd_set FAR *writefds,
                       fd_set FAR *exceptfds, const struct timeval FAR *timeout);

int PASCAL FAR send (SOCKET s, const char FAR * buf, int len, int flags);

int PASCAL FAR sendto (SOCKET s, const char FAR * buf, int len, int flags,
                       const struct sockaddr FAR *to, int tolen);

int PASCAL FAR setsockopt (SOCKET s, int level, int optname,
                           const char FAR * optval, int optlen);

int PASCAL FAR shutdown (SOCKET s, int how);

SOCKET PASCAL FAR socket (int af, int type, int protocol);

/* Database function prototypes */

struct hostent FAR * PASCAL FAR gethostbyaddr(const char FAR * addr,
                                              int len, int type);

struct hostent FAR * PASCAL FAR gethostbyname(const char FAR * name);

int PASCAL FAR gethostname (char FAR * name, int namelen);

struct servent FAR * PASCAL FAR getservbyport(int port, const char FAR * proto);

struct servent FAR * PASCAL FAR getservbyname(const char FAR * name,
                                              const char FAR * proto);

struct protoent FAR * PASCAL FAR getprotobynumber(int proto);

struct protoent FAR * PASCAL FAR getprotobyname(const char FAR * name);

/* Microsoft Windows Extension function prototypes */

int PASCAL FAR WSAStartup(WORD wVersionRequired, LPWSADATA lpWSAData);

int PASCAL FAR WSACleanup(void);

void PASCAL FAR WSASetLastError(int iError);

int PASCAL FAR WSAGetLastError(void);

BOOL PASCAL FAR WSAIsBlocking(void);

int PASCAL FAR WSAUnhookBlockingHook(void);

FARPROC PASCAL FAR WSASetBlockingHook(FARPROC lpBlockFunc);

int PASCAL FAR WSACancelBlockingCall(void);

HANDLE PASCAL FAR WSAAsyncGetServByName(HWND hWnd, u_int wMsg,
                                        const char FAR * name,
                                        const char FAR * proto,
                                        char FAR * buf, int buflen);

HANDLE PASCAL FAR WSAAsyncGetServByPort(HWND hWnd, u_int wMsg, int port,
                                        const char FAR * proto, char FAR * buf,
                                        int buflen);

HANDLE PASCAL FAR WSAAsyncGetProtoByName(HWND hWnd, u_int wMsg,
                                         const char FAR * name, char FAR * buf,
                                         int buflen);

HANDLE PASCAL FAR WSAAsyncGetProtoByNumber(HWND hWnd, u_int wMsg,
                                           int number, char FAR * buf,
                                           int buflen);

HANDLE PASCAL FAR WSAAsyncGetHostByName(HWND hWnd, u_int wMsg,
                                        const char FAR * name, char FAR * buf,
                                        int buflen);

HANDLE PASCAL FAR WSAAsyncGetHostByAddr(HWND hWnd, u_int wMsg,
                                        const char FAR * addr, int len, int type,
                                        char FAR * buf, int buflen);

int PASCAL FAR WSACancelAsyncRequest(HANDLE hAsyncTaskHandle);

int PASCAL FAR WSAAsyncSelect(SOCKET s, HWND hWnd, u_int wMsg,
                               long lEvent);

int PASCAL FAR WSARecvEx (SOCKET s, char FAR * buf, int len, int FAR *flags);

typedef struct _TRANSMIT_FILE_BUFFERS {
    PVOID Head;
    DWORD HeadLength;
    PVOID Tail;
    DWORD TailLength;
} TRANSMIT_FILE_BUFFERS, *PTRANSMIT_FILE_BUFFERS, *LPTRANSMIT_FILE_BUFFERS;

BOOL
PASCAL FAR
TransmitFile (
    IN SOCKET hSocket,
    IN HANDLE hFile,
    IN DWORD nNumberOfBytesToWrite,
    IN DWORD nNumberOfBytesPerSend,
    IN LPOVERLAPPED lpOverlapped,
    IN LPTRANSMIT_FILE_BUFFERS lpTransmitBuffers,
    IN DWORD dwReserved
    );

#ifdef __cplusplus
}
#endif

/* Microsoft Windows Extended data types */
typedef struct sockaddr SOCKADDR;
typedef struct sockaddr *PSOCKADDR;
typedef struct sockaddr FAR *LPSOCKADDR;

typedef struct sockaddr_in SOCKADDR_IN;
typedef struct sockaddr_in *PSOCKADDR_IN;
typedef struct sockaddr_in FAR *LPSOCKADDR_IN;

typedef struct linger LINGER;
typedef struct linger *PLINGER;
typedef struct linger FAR *LPLINGER;

typedef struct in_addr IN_ADDR;
typedef struct in_addr *PIN_ADDR;
typedef struct in_addr FAR *LPIN_ADDR;

typedef struct fd_set FD_SET;
typedef struct fd_set *PFD_SET;
typedef struct fd_set FAR *LPFD_SET;

typedef struct hostent HOSTENT;
typedef struct hostent *PHOSTENT;
typedef struct hostent FAR *LPHOSTENT;

typedef struct servent SERVENT;
typedef struct servent *PSERVENT;
typedef struct servent FAR *LPSERVENT;

typedef struct protoent PROTOENT;
typedef struct protoent *PPROTOENT;
typedef struct protoent FAR *LPPROTOENT;

typedef struct timeval TIMEVAL;
typedef struct timeval *PTIMEVAL;
typedef struct timeval FAR *LPTIMEVAL;

/*
 * Windows message parameter composition and decomposition
 * macros.
 *
 * WSAMAKEASYNCREPLY is intended for use by the Windows Sockets implementation
 * when constructing the response to a WSAAsyncGetXByY() routine.
 */
#define WSAMAKEASYNCREPLY(buflen,error)     MAKELONG(buflen,error)
/*
 * WSAMAKESELECTREPLY is intended for use by the Windows Sockets implementation
 * when constructing the response to WSAAsyncSelect().
 */
#define WSAMAKESELECTREPLY(event,error)     MAKELONG(event,error)
/*
 * WSAGETASYNCBUFLEN is intended for use by the Windows Sockets application
 * to extract the buffer length from the lParam in the response
 * to a WSAGetXByY().
 */
#define WSAGETASYNCBUFLEN(lParam)           LOWORD(lParam)
/*
 * WSAGETASYNCERROR is intended for use by the Windows Sockets application
 * to extract the error code from the lParam in the response
 * to a WSAGetXByY().
 */
#define WSAGETASYNCERROR(lParam)            HIWORD(lParam)
/*
 * WSAGETSELECTEVENT is intended for use by the Windows Sockets application
 * to extract the event code from the lParam in the response
 * to a WSAAsyncSelect().
 */
#define WSAGETSELECTEVENT(lParam)           LOWORD(lParam)
/*
 * WSAGETSELECTERROR is intended for use by the Windows Sockets application
 * to extract the error code from the lParam in the response
 * to a WSAAsyncSelect().
 */
#define WSAGETSELECTERROR(lParam)           HIWORD(lParam)

#endif  /* _WINSOCKAPI_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\tools\c932\inc\winperf.h ===
/*++

Copyright (c) 1993 Microsoft Corporation

Module Name:

    winperf.h

Abstract:

    Header file for the Performance Monitor data.

    This file contains the definitions of the data structures returned
    by the Configuration Registry in response to a request for
    performance data.  This file is used by both the Configuration
    Registry and the Performance Monitor to define their interface.
    The complete interface is described here, except for the name
    of the node to query in the registry.  It is

                   HKEY_PERFORMANCE_DATA.

    By querying that node with a subkey of "Global" the caller will
    retrieve the structures described here.

    There is no need to RegOpenKey() the reserved handle HKEY_PERFORMANCE_DATA,
    but the caller should RegCloseKey() the handle so that network transports
    and drivers can be removed or installed (which cannot happen while
    they are open for monitoring.)  Remote requests must first
    RegConnectRegistry().

--*/

#ifndef _WINPERF_
#define _WINPERF_

//  Data structure definitions.

//  In order for data to be returned through the Configuration Registry
//  in a system-independent fashion, it must be self-describing.

//  In the following, all offsets are in bytes.

//
//  Data is returned through the Configuration Registry in a
//  a data block which begins with a _PERF_DATA_BLOCK structure.
//

#define PERF_DATA_VERSION   1
#define PERF_DATA_REVISION  1


typedef struct _PERF_DATA_BLOCK {
    WCHAR           Signature[4];       // Signature: Unicode "PERF"
    DWORD           LittleEndian;       // 0 = Big Endian, 1 = Little Endian
    DWORD           Version;            // Version of these data structures
                                        // starting at 1
    DWORD           Revision;           // Revision of these data structures
                                        // starting at 0 for each Version
    DWORD           TotalByteLength;    // Total length of data block
    DWORD           HeaderLength;       // Length of this structure
    DWORD           NumObjectTypes;     // Number of types of objects
                                        // being reported
    LONG            DefaultObject;      // Object Title Index of default
                                        // object to display when data from
                                        // this system is retrieved (-1 =
                                        // none, but this is not expected to
                                        // be used)
    SYSTEMTIME      SystemTime;         // Time at the system under
                                        // measurement
    LARGE_INTEGER   PerfTime;           // Performance counter value
                                        // at the system under measurement
    LARGE_INTEGER   PerfFreq;           // Performance counter frequency
                                        // at the system under measurement
    LARGE_INTEGER   PerfTime100nSec;    // Performance counter time in 100 nsec
                                        // units at the system under measurement
    DWORD           SystemNameLength;   // Length of the system name
    DWORD           SystemNameOffset;   // Offset, from beginning of this
                                        // structure, to name of system
                                        // being measured
} PERF_DATA_BLOCK, *PPERF_DATA_BLOCK;


//
//  The _PERF_DATA_BLOCK structure is followed by NumObjectTypes of
//  data sections, one for each type of object measured.  Each object
//  type section begins with a _PERF_OBJECT_TYPE structure.
//


typedef struct _PERF_OBJECT_TYPE {
    DWORD           TotalByteLength;    // Length of this object definition
                                        // including this structure, the
                                        // counter definitions, and the
                                        // instance definitions and the
                                        // counter blocks for each instance:
                                        // This is the offset from this
                                        // structure to the next object, if
                                        // any
    DWORD           DefinitionLength;   // Length of object definition,
                                        // which includes this structure
                                        // and the counter definition
                                        // structures for this object: this
                                        // is the offset of the first
                                        // instance or of the counters
                                        // for this object if there is
                                        // no instance
    DWORD           HeaderLength;       // Length of this structure: this
                                        // is the offset to the first
                                        // counter definition for this
                                        // object
    DWORD           ObjectNameTitleIndex;
                                        // Index to name in Title Database
    LPWSTR          ObjectNameTitle;    // Initially NULL, for use by
                                        // analysis program to point to
                                        // retrieved title string
    DWORD           ObjectHelpTitleIndex;
                                        // Index to Help in Title Database
    LPWSTR          ObjectHelpTitle;    // Initially NULL, for use by
                                        // analysis program to point to
                                        // retrieved title string
    DWORD           DetailLevel;        // Object level of detail (for
                                        // controlling display complexity);
                                        // will be min of detail levels
                                        // for all this object's counters
    DWORD           NumCounters;        // Number of counters in each
                                        // counter block (one counter
                                        // block per instance)
    LONG            DefaultCounter;     // Default counter to display when
                                        // this object is selected, index
                                        // starting at 0 (-1 = none, but
                                        // this is not expected to be used)
    LONG            NumInstances;       // Number of object instances
                                        // for which counters are being
                                        // returned from the system under
                                        // measurement. If the object defined
                                        // will never have any instance data
                                        // structures (PERF_INSTANCE_DEFINITION)
                                        // then this value should be -1, if the
                                        // object can have 0 or more instances,
                                        // but has none present, then this
                                        // should be 0, otherwise this field
                                        // contains the number of instances of
                                        // this counter.
    DWORD           CodePage;           // 0 if instance strings are in
                                        // UNICODE, else the Code Page of
                                        // the instance names
    LARGE_INTEGER   PerfTime;           // Sample Time in "Object" units
                                        //
    LARGE_INTEGER   PerfFreq;           // Frequency of "Object" units in 
                                        // counts per second.
} PERF_OBJECT_TYPE, *PPERF_OBJECT_TYPE;

#define PERF_NO_INSTANCES           -1  // no instances (see NumInstances above)
//
// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
//
//  PERF_COUNTER_DEFINITION.CounterType field values
//
//
//        Counter ID Field Definition:
//
//   3      2        2    2    2        1        1    1
//   1      8        4    2    0        6        2    0    8                0
//  +--------+--------+----+----+--------+--------+----+----+----------------+
//  |Display |Calculation  |Time|Counter |        |Ctr |Size|                |
//  |Flags   |Modifiers    |Base|SubType |Reserved|Type|Fld |   Reserved     |
//  +--------+--------+----+----+--------+--------+----+----+----------------+
//
//
//  The counter type is the "or" of the following values as described below
//
//  select one of the following to indicate the counter's data size
//
#define PERF_SIZE_DWORD         0x00000000
#define PERF_SIZE_LARGE         0x00000100
#define PERF_SIZE_ZERO          0x00000200  // for Zero Length fields
#define PERF_SIZE_VARIABLE_LEN  0x00000300  // length is in CounterLength field
                                            //  of Counter Definition struct
//
//  select one of the following values to indicate the counter field usage
//
#define PERF_TYPE_NUMBER        0x00000000  // a number (not a counter)
#define PERF_TYPE_COUNTER       0x00000400  // an increasing numeric value
#define PERF_TYPE_TEXT          0x00000800  // a text field
#define PERF_TYPE_ZERO          0x00000C00  // displays a zero
//
//  If the PERF_TYPE_NUMBER field was selected, then select one of the 
//  following to describe the Number
//
#define PERF_NUMBER_HEX         0x00000000  // display as HEX value
#define PERF_NUMBER_DECIMAL     0x00010000  // display as a decimal integer
#define PERF_NUMBER_DEC_1000    0x00020000  // display as a decimal/1000
//
//  If the PERF_TYPE_COUNTER value was selected then select one of the
//  following to indicate the type of counter
//
#define PERF_COUNTER_VALUE      0x00000000  // display counter value
#define PERF_COUNTER_RATE       0x00010000  // divide ctr / delta time
#define PERF_COUNTER_FRACTION   0x00020000  // divide ctr / base
#define PERF_COUNTER_BASE       0x00030000  // base value used in fractions
#define PERF_COUNTER_ELAPSED    0x00040000  // subtract counter from current time 
#define PERF_COUNTER_QUEUELEN   0x00050000  // Use Queuelen processing func.
#define PERF_COUNTER_HISTOGRAM  0x00060000  // Counter begins or ends a histogram
//
//  If the PERF_TYPE_TEXT value was selected, then select one of the 
//  following to indicate the type of TEXT data.
//
#define PERF_TEXT_UNICODE       0x00000000  // type of text in text field
#define PERF_TEXT_ASCII         0x00010000  // ASCII using the CodePage field
//
//  Timer SubTypes
//
#define PERF_TIMER_TICK         0x00000000  // use system perf. freq for base
#define PERF_TIMER_100NS        0x00100000  // use 100 NS timer time base units
#define PERF_OBJECT_TIMER       0x00200000  // use the object timer freq
//
//  Any types that have calculations performed can use one or more of 
//  the following calculation modification flags listed here
//
#define PERF_DELTA_COUNTER      0x00400000  // compute difference first
#define PERF_DELTA_BASE         0x00800000  // compute base diff as well
#define PERF_INVERSE_COUNTER    0x01000000  // show as 1.00-value (assumes:
#define PERF_MULTI_COUNTER      0x02000000  // sum of multiple instances
//
//  Select one of the following values to indicate the display suffix (if any)
//
#define PERF_DISPLAY_NO_SUFFIX  0x00000000  // no suffix
#define PERF_DISPLAY_PER_SEC    0x10000000  // "/sec"
#define PERF_DISPLAY_PERCENT    0x20000000  // "%"
#define PERF_DISPLAY_SECONDS    0x30000000  // "secs"
#define PERF_DISPLAY_NOSHOW     0x40000000  // value is not displayed
//
//  Predefined counter types 
//

// 32-bit Counter.  Divide delta by delta time.  Display suffix: "/sec"
#define PERF_COUNTER_COUNTER        \
            (PERF_SIZE_DWORD | PERF_TYPE_COUNTER | PERF_COUNTER_RATE |\
            PERF_TIMER_TICK | PERF_DELTA_COUNTER | PERF_DISPLAY_PER_SEC)
                     
                                                       
// 64-bit Timer.  Divide delta by delta time.  Display suffix: "%"
#define PERF_COUNTER_TIMER          \
            (PERF_SIZE_LARGE | PERF_TYPE_COUNTER | PERF_COUNTER_RATE |\
            PERF_TIMER_TICK | PERF_DELTA_COUNTER | PERF_DISPLAY_PERCENT)

// Queue Length Space-Time Product. Divide delta by delta time. No Display Suffix.
#define PERF_COUNTER_QUEUELEN_TYPE  \
            (PERF_SIZE_DWORD | PERF_TYPE_COUNTER | PERF_COUNTER_QUEUELEN |\
            PERF_TIMER_TICK | PERF_DELTA_COUNTER | PERF_DISPLAY_NO_SUFFIX)

// 64-bit Counter.  Divide delta by delta time. Display Suffix: "/sec"
#define PERF_COUNTER_BULK_COUNT     \
            (PERF_SIZE_LARGE | PERF_TYPE_COUNTER | PERF_COUNTER_RATE |\
            PERF_TIMER_TICK | PERF_DELTA_COUNTER | PERF_DISPLAY_PER_SEC)

// Indicates the counter is not a  counter but rather Unicode text Display as text.
#define PERF_COUNTER_TEXT           \
            (PERF_SIZE_VARIABLE_LEN | PERF_TYPE_TEXT | PERF_TEXT_UNICODE |\
            PERF_DISPLAY_NO_SUFFIX)

// Indicates the data is a counter  which should not be
// time averaged on display (such as an error counter on a serial line)
// Display as is.  No Display Suffix.
#define PERF_COUNTER_RAWCOUNT       \
            (PERF_SIZE_DWORD | PERF_TYPE_NUMBER | PERF_NUMBER_DECIMAL |\
            PERF_DISPLAY_NO_SUFFIX)

// Same as PERF_COUNTER_RAWCOUNT except its size is a large integer
#define PERF_COUNTER_LARGE_RAWCOUNT       \
            (PERF_SIZE_LARGE | PERF_TYPE_NUMBER | PERF_NUMBER_DECIMAL |\
            PERF_DISPLAY_NO_SUFFIX)

// Special case for RAWCOUNT that want to be displayed in hex
// Indicates the data is a counter  which should not be
// time averaged on display (such as an error counter on a serial line)
// Display as is.  No Display Suffix.
#define PERF_COUNTER_RAWCOUNT_HEX       \
            (PERF_SIZE_DWORD | PERF_TYPE_NUMBER | PERF_NUMBER_HEX |\
            PERF_DISPLAY_NO_SUFFIX)

// Same as PERF_COUNTER_RAWCOUNT_HEX except its size is a large integer
#define PERF_COUNTER_LARGE_RAWCOUNT_HEX       \
            (PERF_SIZE_LARGE | PERF_TYPE_NUMBER | PERF_NUMBER_HEX |\
            PERF_DISPLAY_NO_SUFFIX)


// A count which is either 1 or 0 on each sampling interrupt (% busy)
// Divide delta by delta base. Display Suffix: "%"
#define PERF_SAMPLE_FRACTION        \
            (PERF_SIZE_DWORD | PERF_TYPE_COUNTER | PERF_COUNTER_FRACTION |\
            PERF_DELTA_COUNTER | PERF_DELTA_BASE | PERF_DISPLAY_PERCENT)

// A count which is sampled on each sampling interrupt (queue length)
// Divide delta by delta time. No Display Suffix.
#define PERF_SAMPLE_COUNTER         \
            (PERF_SIZE_DWORD | PERF_TYPE_COUNTER | PERF_COUNTER_RATE |\
            PERF_TIMER_TICK | PERF_DELTA_COUNTER | PERF_DISPLAY_NO_SUFFIX)

// A label: no data is associated with this counter (it has 0 length)
// Do not display.
#define PERF_COUNTER_NODATA         \
            (PERF_SIZE_ZERO | PERF_DISPLAY_NOSHOW)

// 64-bit Timer inverse (e.g., idle is measured, but display busy %)
// Display 100 - delta divided by delta time.  Display suffix: "%"
#define PERF_COUNTER_TIMER_INV      \
            (PERF_SIZE_LARGE | PERF_TYPE_COUNTER | PERF_COUNTER_RATE |\
            PERF_TIMER_TICK | PERF_DELTA_COUNTER | PERF_INVERSE_COUNTER | \
            PERF_DISPLAY_PERCENT)

// The divisor for a sample, used with the previous counter to form a
// sampled %.  You must check for >0 before dividing by this!  This
// counter will directly follow the  numerator counter.  It should not
// be displayed to the user.
#define PERF_SAMPLE_BASE            \
            (PERF_SIZE_DWORD | PERF_TYPE_COUNTER | PERF_COUNTER_BASE |\
            PERF_DISPLAY_NOSHOW |\
            0x00000001)  // for compatibility with pre-beta versions

// A timer which, when divided by an average base, produces a time
// in seconds which is the average time of some operation.  This
// timer times total operations, and  the base is the number of opera-
// tions.  Display Suffix: "sec"
#define PERF_AVERAGE_TIMER          \
            (PERF_SIZE_DWORD | PERF_TYPE_COUNTER | PERF_COUNTER_FRACTION |\
            PERF_DISPLAY_SECONDS)

// Used as the denominator in the computation of time or count
// averages.  Must directly follow the numerator counter.  Not dis-
// played to the user.
#define PERF_AVERAGE_BASE           \
            (PERF_SIZE_DWORD | PERF_TYPE_COUNTER | PERF_COUNTER_BASE |\
            PERF_DISPLAY_NOSHOW |\
            0x00000002)  // for compatibility with pre-beta versions


// A bulk count which, when divided (typically) by the number of
// operations, gives (typically) the number of bytes per operation.
// No Display Suffix.
#define PERF_AVERAGE_BULK           \
            (PERF_SIZE_LARGE | PERF_TYPE_COUNTER | PERF_COUNTER_FRACTION  |\
            PERF_DISPLAY_NOSHOW)

// 64-bit Timer in 100 nsec units. Display delta divided by
// delta time.  Display suffix: "%"
#define PERF_100NSEC_TIMER          \
            (PERF_SIZE_LARGE | PERF_TYPE_COUNTER | PERF_COUNTER_RATE |\
            PERF_TIMER_100NS | PERF_DELTA_COUNTER | PERF_DISPLAY_PERCENT)

// 64-bit Timer inverse (e.g., idle is measured, but display busy %)
// Display 100 - delta divided by delta time.  Display suffix: "%"
#define PERF_100NSEC_TIMER_INV      \
            (PERF_SIZE_LARGE | PERF_TYPE_COUNTER | PERF_COUNTER_RATE |\
            PERF_TIMER_100NS | PERF_DELTA_COUNTER | PERF_INVERSE_COUNTER  |\
            PERF_DISPLAY_PERCENT)
     
// 64-bit Timer.  Divide delta by delta time.  Display suffix: "%"
// Timer for multiple instances, so result can exceed 100%.
#define PERF_COUNTER_MULTI_TIMER    \
            (PERF_SIZE_LARGE | PERF_TYPE_COUNTER | PERF_COUNTER_RATE |\
            PERF_DELTA_COUNTER | PERF_TIMER_TICK | PERF_MULTI_COUNTER |\
            PERF_DISPLAY_PERCENT)
  
// 64-bit Timer inverse (e.g., idle is measured, but display busy %)
// Display 100 * _MULTI_BASE - delta divided by delta time.
// Display suffix: "%" Timer for multiple instances, so result
// can exceed 100%.  Followed by a counter of type _MULTI_BASE.
#define PERF_COUNTER_MULTI_TIMER_INV \
            (PERF_SIZE_LARGE | PERF_TYPE_COUNTER | PERF_COUNTER_RATE |\
            PERF_DELTA_COUNTER | PERF_MULTI_COUNTER | PERF_TIMER_TICK |\
            PERF_INVERSE_COUNTER | PERF_DISPLAY_PERCENT)
    
// Number of instances to which the preceding _MULTI_..._INV counter
// applies.  Used as a factor to get the percentage.
#define PERF_COUNTER_MULTI_BASE     \
            (PERF_SIZE_LARGE | PERF_TYPE_COUNTER | PERF_COUNTER_BASE |\
            PERF_MULTI_COUNTER | PERF_DISPLAY_NOSHOW)

// 64-bit Timer in 100 nsec units. Display delta divided by delta time.  
// Display suffix: "%" Timer for multiple instances, so result can exceed 100%.
#define PERF_100NSEC_MULTI_TIMER   \
            (PERF_SIZE_LARGE | PERF_TYPE_COUNTER | PERF_DELTA_COUNTER  |\
            PERF_COUNTER_RATE | PERF_TIMER_100NS | PERF_MULTI_COUNTER |\
            PERF_DISPLAY_PERCENT)
            
// 64-bit Timer inverse (e.g., idle is measured, but display busy %)
// Display 100 * _MULTI_BASE - delta divided by delta time.
// Display suffix: "%" Timer for multiple instances, so result
// can exceed 100%.  Followed by a counter of type _MULTI_BASE.
#define PERF_100NSEC_MULTI_TIMER_INV \
            (PERF_SIZE_LARGE | PERF_TYPE_COUNTER | PERF_DELTA_COUNTER  |\
            PERF_COUNTER_RATE | PERF_TIMER_100NS | PERF_MULTI_COUNTER |\
            PERF_INVERSE_COUNTER | PERF_DISPLAY_PERCENT)
            
// Indicates the data is a fraction of the following counter  which 
// should not be time averaged on display (such as free space over 
// total space.) Display as is.  Display the quotient as "%".
#define PERF_RAW_FRACTION           \
            (PERF_SIZE_DWORD | PERF_TYPE_COUNTER | PERF_COUNTER_FRACTION |\
            PERF_DISPLAY_PERCENT)
                                    
// Indicates the data is a base for the preceding counter which should
// not be time averaged on display (such as free space over total space.)
#define PERF_RAW_BASE               \
            (PERF_SIZE_DWORD | PERF_TYPE_COUNTER | PERF_COUNTER_BASE |\
            PERF_DISPLAY_NOSHOW |\
            0x00000003)  // for compatibility with pre-beta versions

// The data collected in this counter is actually the start time of the
// item being measured. For display, this data is subtracted from the 
// sample time to yield the elapsed time as the difference between the two.
// In the definition below, the PerfTime field of the Object contains
// the sample time as indicated by the PERF_OBJECT_TIMER bit and the 
// difference is scaled by the PerfFreq of the Object to convert the time
// units into seconds.
#define PERF_ELAPSED_TIME           \
            (PERF_SIZE_LARGE | PERF_TYPE_COUNTER | PERF_COUNTER_ELAPSED |\
            PERF_OBJECT_TIMER | PERF_DISPLAY_SECONDS)
//
//  The following counter type can be used with the preceding types to
//  define a range of values to be displayed in a histogram.
//

#define PERF_COUNTER_HISTOGRAM_TYPE   0x80000000
                                        // Counter begins or ends a histogram

//
//  The following are used to determine the level of detail associated
//  with the counter.  The user will be setting the level of detail
//  that should be displayed at any given time.
//

#define PERF_DETAIL_NOVICE          100 // The uninformed can understand it
#define PERF_DETAIL_ADVANCED        200 // For the advanced user
#define PERF_DETAIL_EXPERT          300 // For the expert user
#define PERF_DETAIL_WIZARD          400 // For the system designer


//
//  There is one of the following for each of the
//  PERF_OBJECT_TYPE.NumCounters.  The Unicode names in this structure MUST
//  come from a message file.
//

typedef struct _PERF_COUNTER_DEFINITION {
    DWORD           ByteLength;         // Length in bytes of this structure
    DWORD           CounterNameTitleIndex;
                                        // Index of Counter name into
                                        // Title Database
    LPWSTR          CounterNameTitle;   // Initially NULL, for use by
                                        // analysis program to point to
                                        // retrieved title string
    DWORD           CounterHelpTitleIndex;
                                        // Index of Counter Help into
                                        // Title Database
    LPWSTR          CounterHelpTitle;   // Initially NULL, for use by
                                        // analysis program to point to
                                        // retrieved title string
    LONG            DefaultScale;       // Power of 10 by which to scale
                                        // chart line if vertical axis is 100
                                        // 0 ==> 1, 1 ==> 10, -1 ==>1/10, etc.
    DWORD           DetailLevel;        // Counter level of detail (for
                                        // controlling display complexity)
    DWORD           CounterType;        // Type of counter
    DWORD           CounterSize;        // Size of counter in bytes
    DWORD           CounterOffset;      // Offset from the start of the
                                        // PERF_COUNTER_BLOCK to the first
                                        // byte of this counter
} PERF_COUNTER_DEFINITION, *PPERF_COUNTER_DEFINITION;

//
//  If (PERF_DATA_BLOCK.NumInstances >= 0) then there will be
//  PERF_DATA_BLOCK.NumInstances of a (PERF_INSTANCE_DEFINITION
//  followed by a PERF_COUNTER_BLOCK followed by the counter data fields)
//  for each instance.
//
//  If (PERF_DATA_BLOCK.NumInstances < 0) then the counter definition
//  strucutre above will be followed by only a PERF_COUNTER_BLOCK and the
//  counter data for that COUNTER.
//

#define PERF_NO_UNIQUE_ID -1

typedef struct _PERF_INSTANCE_DEFINITION {
    DWORD           ByteLength;         // Length in bytes of this structure,
                                        // including the subsequent name
    DWORD           ParentObjectTitleIndex;
                                        // Title Index to name of "parent"
                                        // object (e.g., if thread, then
                                        // process is parent object type);
                                        // if logical drive, the physical
                                        // drive is parent object type
    DWORD           ParentObjectInstance;
                                        // Index to instance of parent object
                                        // type which is the parent of this
                                        // instance.
    LONG            UniqueID;           // A unique ID used instead of
                                        // matching the name to identify
                                        // this instance, -1 = none
    DWORD           NameOffset;         // Offset from beginning of
                                        // this struct to the Unicode name
                                        // of this instance
    DWORD           NameLength;         // Length in bytes of name; 0 = none

} PERF_INSTANCE_DEFINITION, *PPERF_INSTANCE_DEFINITION;
//
//  If .ParentObjectName is 0, there
//  is no parent-child hierarchy for this object type.  Otherwise,
//   the .ParentObjectInstance is an index, starting at 0, into the
//  instances reported for the parent object type.  It is only
//  meaningful if .ParentObjectName is not 0.  The purpose of all this
//  is to permit reporting/summation of object instances like threads
//  within processes, and logical drives within physical drives.
//
//
//  The PERF_INSTANCE_DEFINITION will be followed by a PERF_COUNTER_BLOCK.
//

typedef struct _PERF_COUNTER_BLOCK {
    DWORD           ByteLength;         // Length in bytes of this structure,
                                        // including the following counters
} PERF_COUNTER_BLOCK, *PPERF_COUNTER_BLOCK;

//
//  The PERF_COUNTER_BLOCK is followed by PERF_OBJECT_TYPE.NumCounters
//  number of counters.
//

//
//  function typedefs for extensible counter function prototypes
//
typedef DWORD (APIENTRY PM_OPEN_PROC) (LPWSTR);
typedef DWORD (APIENTRY PM_COLLECT_PROC) (LPWSTR, LPVOID *, LPDWORD, LPDWORD);
typedef DWORD (APIENTRY PM_CLOSE_PROC) (void);

#endif // _WINPERF_



=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\tools\c932\inc\winsvc.h ===
/*++ BUILD Version: 0010    // Increment this if a change has global effects

Copyright (c) 1993-1994  Microsoft Corporation

Module Name:

    winsvc.h

Abstract:

    Header file for the Service Control Manager

--*/
#ifndef _WINSVC_
#define _WINSVC_

//
// Define API decoration for direct importing of DLL references.
//

#if !defined(WINADVAPI)
#if !defined(_ADVAPI32_)
#define WINADVAPI DECLSPEC_IMPORT
#else
#define WINADVAPI
#endif
#endif

#ifdef __cplusplus
extern "C" {
#endif

//
// Constants
//

//
// Service database names
//

#define SERVICES_ACTIVE_DATABASEW      L"ServicesActive"
#define SERVICES_FAILED_DATABASEW      L"ServicesFailed"

#define SERVICES_ACTIVE_DATABASEA      "ServicesActive"
#define SERVICES_FAILED_DATABASEA      "ServicesFailed"

//
// Character to designate that a name is a group
//

#define SC_GROUP_IDENTIFIERW           L'+'
#define SC_GROUP_IDENTIFIERA           '+'

#ifdef UNICODE

#define SERVICES_ACTIVE_DATABASE       SERVICES_ACTIVE_DATABASEW
#define SERVICES_FAILED_DATABASE       SERVICES_FAILED_DATABASEW


#define SC_GROUP_IDENTIFIER            SC_GROUP_IDENTIFIERW

#else // ndef UNICODE

#define SERVICES_ACTIVE_DATABASE       SERVICES_ACTIVE_DATABASEA
#define SERVICES_FAILED_DATABASE       SERVICES_FAILED_DATABASEA

#define SC_GROUP_IDENTIFIER            SC_GROUP_IDENTIFIERA
#endif // ndef UNICODE


//
// Value to indicate no change to an optional parameter
//
#define SERVICE_NO_CHANGE              0xffffffff

//
// Service State -- for Enum Requests (Bit Mask)
//
#define SERVICE_ACTIVE                 0x00000001
#define SERVICE_INACTIVE               0x00000002
#define SERVICE_STATE_ALL              (SERVICE_ACTIVE   | \
                                        SERVICE_INACTIVE)

//
// Controls
//
#define SERVICE_CONTROL_STOP           0x00000001
#define SERVICE_CONTROL_PAUSE          0x00000002
#define SERVICE_CONTROL_CONTINUE       0x00000003
#define SERVICE_CONTROL_INTERROGATE    0x00000004
#define SERVICE_CONTROL_SHUTDOWN       0x00000005

//
// Service State -- for CurrentState
//
#define SERVICE_STOPPED                0x00000001
#define SERVICE_START_PENDING          0x00000002
#define SERVICE_STOP_PENDING           0x00000003
#define SERVICE_RUNNING                0x00000004
#define SERVICE_CONTINUE_PENDING       0x00000005
#define SERVICE_PAUSE_PENDING          0x00000006
#define SERVICE_PAUSED                 0x00000007

//
// Controls Accepted  (Bit Mask)
//
#define SERVICE_ACCEPT_STOP            0x00000001
#define SERVICE_ACCEPT_PAUSE_CONTINUE  0x00000002
#define SERVICE_ACCEPT_SHUTDOWN        0x00000004

//
// Service Control Manager object specific access types
//
#define SC_MANAGER_CONNECT             0x0001
#define SC_MANAGER_CREATE_SERVICE      0x0002
#define SC_MANAGER_ENUMERATE_SERVICE   0x0004
#define SC_MANAGER_LOCK                0x0008
#define SC_MANAGER_QUERY_LOCK_STATUS   0x0010
#define SC_MANAGER_MODIFY_BOOT_CONFIG  0x0020

#define SC_MANAGER_ALL_ACCESS          (STANDARD_RIGHTS_REQUIRED      | \
                                        SC_MANAGER_CONNECT            | \
                                        SC_MANAGER_CREATE_SERVICE     | \
                                        SC_MANAGER_ENUMERATE_SERVICE  | \
                                        SC_MANAGER_LOCK               | \
                                        SC_MANAGER_QUERY_LOCK_STATUS  | \
                                        SC_MANAGER_MODIFY_BOOT_CONFIG)



//
// Service object specific access type
//
#define SERVICE_QUERY_CONFIG           0x0001
#define SERVICE_CHANGE_CONFIG          0x0002
#define SERVICE_QUERY_STATUS           0x0004
#define SERVICE_ENUMERATE_DEPENDENTS   0x0008
#define SERVICE_START                  0x0010
#define SERVICE_STOP                   0x0020
#define SERVICE_PAUSE_CONTINUE         0x0040
#define SERVICE_INTERROGATE            0x0080
#define SERVICE_USER_DEFINED_CONTROL   0x0100

#define SERVICE_ALL_ACCESS             (STANDARD_RIGHTS_REQUIRED     | \
                                        SERVICE_QUERY_CONFIG         | \
                                        SERVICE_CHANGE_CONFIG        | \
                                        SERVICE_QUERY_STATUS         | \
                                        SERVICE_ENUMERATE_DEPENDENTS | \
                                        SERVICE_START                | \
                                        SERVICE_STOP                 | \
                                        SERVICE_PAUSE_CONTINUE       | \
                                        SERVICE_INTERROGATE          | \
                                        SERVICE_USER_DEFINED_CONTROL)


//
// Handle Types
//

typedef HANDLE      SC_HANDLE;
typedef SC_HANDLE   *LPSC_HANDLE;

typedef DWORD       SERVICE_STATUS_HANDLE;

//
// Service Status Structure
//

typedef struct _SERVICE_STATUS {
    DWORD   dwServiceType;
    DWORD   dwCurrentState;
    DWORD   dwControlsAccepted;
    DWORD   dwWin32ExitCode;
    DWORD   dwServiceSpecificExitCode;
    DWORD   dwCheckPoint;
    DWORD   dwWaitHint;
} SERVICE_STATUS, *LPSERVICE_STATUS;



//
// Service Status Enumeration Structure
//

typedef struct _ENUM_SERVICE_STATUSA {
    LPSTR          lpServiceName;
    LPSTR          lpDisplayName;
    SERVICE_STATUS ServiceStatus;
} ENUM_SERVICE_STATUSA, *LPENUM_SERVICE_STATUSA;
typedef struct _ENUM_SERVICE_STATUSW {
    LPWSTR         lpServiceName;
    LPWSTR         lpDisplayName;
    SERVICE_STATUS ServiceStatus;
} ENUM_SERVICE_STATUSW, *LPENUM_SERVICE_STATUSW;
#ifdef UNICODE
typedef ENUM_SERVICE_STATUSW ENUM_SERVICE_STATUS;
typedef LPENUM_SERVICE_STATUSW LPENUM_SERVICE_STATUS;
#else
typedef ENUM_SERVICE_STATUSA ENUM_SERVICE_STATUS;
typedef LPENUM_SERVICE_STATUSA LPENUM_SERVICE_STATUS;
#endif // UNICODE


//
// Structures for the Lock API functions
//

typedef LPVOID  SC_LOCK;

typedef struct _QUERY_SERVICE_LOCK_STATUSA {
    DWORD   fIsLocked;
    LPSTR   lpLockOwner;
    DWORD   dwLockDuration;
} QUERY_SERVICE_LOCK_STATUSA, *LPQUERY_SERVICE_LOCK_STATUSA;
typedef struct _QUERY_SERVICE_LOCK_STATUSW {
    DWORD   fIsLocked;
    LPWSTR  lpLockOwner;
    DWORD   dwLockDuration;
} QUERY_SERVICE_LOCK_STATUSW, *LPQUERY_SERVICE_LOCK_STATUSW;
#ifdef UNICODE
typedef QUERY_SERVICE_LOCK_STATUSW QUERY_SERVICE_LOCK_STATUS;
typedef LPQUERY_SERVICE_LOCK_STATUSW LPQUERY_SERVICE_LOCK_STATUS;
#else
typedef QUERY_SERVICE_LOCK_STATUSA QUERY_SERVICE_LOCK_STATUS;
typedef LPQUERY_SERVICE_LOCK_STATUSA LPQUERY_SERVICE_LOCK_STATUS;
#endif // UNICODE



//
// Query Service Configuration Structure
//

typedef struct _QUERY_SERVICE_CONFIGA {
    DWORD   dwServiceType;
    DWORD   dwStartType;
    DWORD   dwErrorControl;
    LPSTR   lpBinaryPathName;
    LPSTR   lpLoadOrderGroup;
    DWORD   dwTagId;
    LPSTR   lpDependencies;
    LPSTR   lpServiceStartName;
    LPSTR   lpDisplayName;
} QUERY_SERVICE_CONFIGA, *LPQUERY_SERVICE_CONFIGA;
typedef struct _QUERY_SERVICE_CONFIGW {
    DWORD   dwServiceType;
    DWORD   dwStartType;
    DWORD   dwErrorControl;
    LPWSTR  lpBinaryPathName;
    LPWSTR  lpLoadOrderGroup;
    DWORD   dwTagId;
    LPWSTR  lpDependencies;
    LPWSTR  lpServiceStartName;
    LPWSTR  lpDisplayName;
} QUERY_SERVICE_CONFIGW, *LPQUERY_SERVICE_CONFIGW;
#ifdef UNICODE
typedef QUERY_SERVICE_CONFIGW QUERY_SERVICE_CONFIG;
typedef LPQUERY_SERVICE_CONFIGW LPQUERY_SERVICE_CONFIG;
#else
typedef QUERY_SERVICE_CONFIGA QUERY_SERVICE_CONFIG;
typedef LPQUERY_SERVICE_CONFIGA LPQUERY_SERVICE_CONFIG;
#endif // UNICODE



//
// Function Prototype for the Service Main Function
//

typedef VOID (WINAPI *LPSERVICE_MAIN_FUNCTIONW)(
    DWORD   dwNumServicesArgs,
    LPWSTR  *lpServiceArgVectors
    );

typedef VOID (WINAPI *LPSERVICE_MAIN_FUNCTIONA)(
    DWORD   dwNumServicesArgs,
    LPSTR   *lpServiceArgVectors
    );

#ifdef UNICODE
#define LPSERVICE_MAIN_FUNCTION LPSERVICE_MAIN_FUNCTIONW
#else
#define LPSERVICE_MAIN_FUNCTION LPSERVICE_MAIN_FUNCTIONA
#endif //UNICODE


//
// Service Start Table
//

typedef struct _SERVICE_TABLE_ENTRYA {
    LPSTR                       lpServiceName;
    LPSERVICE_MAIN_FUNCTIONA    lpServiceProc;
}SERVICE_TABLE_ENTRYA, *LPSERVICE_TABLE_ENTRYA;
typedef struct _SERVICE_TABLE_ENTRYW {
    LPWSTR                      lpServiceName;
    LPSERVICE_MAIN_FUNCTIONW    lpServiceProc;
}SERVICE_TABLE_ENTRYW, *LPSERVICE_TABLE_ENTRYW;
#ifdef UNICODE
typedef SERVICE_TABLE_ENTRYW SERVICE_TABLE_ENTRY;
typedef LPSERVICE_TABLE_ENTRYW LPSERVICE_TABLE_ENTRY;
#else
typedef SERVICE_TABLE_ENTRYA SERVICE_TABLE_ENTRY;
typedef LPSERVICE_TABLE_ENTRYA LPSERVICE_TABLE_ENTRY;
#endif // UNICODE

//
// Prototype for the Service Control Handler Function
//

typedef VOID (WINAPI *LPHANDLER_FUNCTION)(
    DWORD    dwControl
    );



///////////////////////////////////////////////////////////////////////////
// API Function Prototypes
///////////////////////////////////////////////////////////////////////////

WINADVAPI
BOOL
WINAPI
ChangeServiceConfigA(
    SC_HANDLE    hService,
    DWORD        dwServiceType,
    DWORD        dwStartType,
    DWORD        dwErrorControl,
    LPCSTR     lpBinaryPathName,
    LPCSTR     lpLoadOrderGroup,
    LPDWORD      lpdwTagId,
    LPCSTR     lpDependencies,
    LPCSTR     lpServiceStartName,
    LPCSTR     lpPassword,
    LPCSTR     lpDisplayName
    );
WINADVAPI
BOOL
WINAPI
ChangeServiceConfigW(
    SC_HANDLE    hService,
    DWORD        dwServiceType,
    DWORD        dwStartType,
    DWORD        dwErrorControl,
    LPCWSTR     lpBinaryPathName,
    LPCWSTR     lpLoadOrderGroup,
    LPDWORD      lpdwTagId,
    LPCWSTR     lpDependencies,
    LPCWSTR     lpServiceStartName,
    LPCWSTR     lpPassword,
    LPCWSTR     lpDisplayName
    );
#ifdef UNICODE
#define ChangeServiceConfig  ChangeServiceConfigW
#else
#define ChangeServiceConfig  ChangeServiceConfigA
#endif // !UNICODE

WINADVAPI
BOOL
WINAPI
CloseServiceHandle(
    SC_HANDLE   hSCObject
    );

WINADVAPI
BOOL
WINAPI
ControlService(
    SC_HANDLE           hService,
    DWORD               dwControl,
    LPSERVICE_STATUS    lpServiceStatus
    );

WINADVAPI
SC_HANDLE
WINAPI
CreateServiceA(
    SC_HANDLE    hSCManager,
    LPCSTR     lpServiceName,
    LPCSTR     lpDisplayName,
    DWORD        dwDesiredAccess,
    DWORD        dwServiceType,
    DWORD        dwStartType,
    DWORD        dwErrorControl,
    LPCSTR     lpBinaryPathName,
    LPCSTR     lpLoadOrderGroup,
    LPDWORD      lpdwTagId,
    LPCSTR     lpDependencies,
    LPCSTR     lpServiceStartName,
    LPCSTR     lpPassword
    );
WINADVAPI
SC_HANDLE
WINAPI
CreateServiceW(
    SC_HANDLE    hSCManager,
    LPCWSTR     lpServiceName,
    LPCWSTR     lpDisplayName,
    DWORD        dwDesiredAccess,
    DWORD        dwServiceType,
    DWORD        dwStartType,
    DWORD        dwErrorControl,
    LPCWSTR     lpBinaryPathName,
    LPCWSTR     lpLoadOrderGroup,
    LPDWORD      lpdwTagId,
    LPCWSTR     lpDependencies,
    LPCWSTR     lpServiceStartName,
    LPCWSTR     lpPassword
    );
#ifdef UNICODE
#define CreateService  CreateServiceW
#else
#define CreateService  CreateServiceA
#endif // !UNICODE

WINADVAPI
BOOL
WINAPI
DeleteService(
    SC_HANDLE   hService
    );

WINADVAPI
BOOL
WINAPI
EnumDependentServicesA(
    SC_HANDLE               hService,
    DWORD                   dwServiceState,
    LPENUM_SERVICE_STATUSA  lpServices,
    DWORD                   cbBufSize,
    LPDWORD                 pcbBytesNeeded,
    LPDWORD                 lpServicesReturned
    );
WINADVAPI
BOOL
WINAPI
EnumDependentServicesW(
    SC_HANDLE               hService,
    DWORD                   dwServiceState,
    LPENUM_SERVICE_STATUSW  lpServices,
    DWORD                   cbBufSize,
    LPDWORD                 pcbBytesNeeded,
    LPDWORD                 lpServicesReturned
    );
#ifdef UNICODE
#define EnumDependentServices  EnumDependentServicesW
#else
#define EnumDependentServices  EnumDependentServicesA
#endif // !UNICODE

WINADVAPI
BOOL
WINAPI
EnumServicesStatusA(
    SC_HANDLE               hSCManager,
    DWORD                   dwServiceType,
    DWORD                   dwServiceState,
    LPENUM_SERVICE_STATUSA  lpServices,
    DWORD                   cbBufSize,
    LPDWORD                 pcbBytesNeeded,
    LPDWORD                 lpServicesReturned,
    LPDWORD                 lpResumeHandle
    );
WINADVAPI
BOOL
WINAPI
EnumServicesStatusW(
    SC_HANDLE               hSCManager,
    DWORD                   dwServiceType,
    DWORD                   dwServiceState,
    LPENUM_SERVICE_STATUSW  lpServices,
    DWORD                   cbBufSize,
    LPDWORD                 pcbBytesNeeded,
    LPDWORD                 lpServicesReturned,
    LPDWORD                 lpResumeHandle
    );
#ifdef UNICODE
#define EnumServicesStatus  EnumServicesStatusW
#else
#define EnumServicesStatus  EnumServicesStatusA
#endif // !UNICODE

WINADVAPI
BOOL
WINAPI
GetServiceKeyNameA(
    SC_HANDLE               hSCManager,
    LPCSTR                lpDisplayName,
    LPSTR                 lpServiceName,
    LPDWORD                 lpcchBuffer
    );
WINADVAPI
BOOL
WINAPI
GetServiceKeyNameW(
    SC_HANDLE               hSCManager,
    LPCWSTR                lpDisplayName,
    LPWSTR                 lpServiceName,
    LPDWORD                 lpcchBuffer
    );
#ifdef UNICODE
#define GetServiceKeyName  GetServiceKeyNameW
#else
#define GetServiceKeyName  GetServiceKeyNameA
#endif // !UNICODE

WINADVAPI
BOOL
WINAPI
GetServiceDisplayNameA(
    SC_HANDLE               hSCManager,
    LPCSTR                lpServiceName,
    LPSTR                 lpDisplayName,
    LPDWORD                 lpcchBuffer
    );
WINADVAPI
BOOL
WINAPI
GetServiceDisplayNameW(
    SC_HANDLE               hSCManager,
    LPCWSTR                lpServiceName,
    LPWSTR                 lpDisplayName,
    LPDWORD                 lpcchBuffer
    );
#ifdef UNICODE
#define GetServiceDisplayName  GetServiceDisplayNameW
#else
#define GetServiceDisplayName  GetServiceDisplayNameA
#endif // !UNICODE

WINADVAPI
SC_LOCK
WINAPI
LockServiceDatabase(
    SC_HANDLE   hSCManager
    );

WINADVAPI
BOOL
WINAPI
NotifyBootConfigStatus(
    BOOL     BootAcceptable
    );

WINADVAPI
SC_HANDLE
WINAPI
OpenSCManagerA(
    LPCSTR lpMachineName,
    LPCSTR lpDatabaseName,
    DWORD   dwDesiredAccess
    );
WINADVAPI
SC_HANDLE
WINAPI
OpenSCManagerW(
    LPCWSTR lpMachineName,
    LPCWSTR lpDatabaseName,
    DWORD   dwDesiredAccess
    );
#ifdef UNICODE
#define OpenSCManager  OpenSCManagerW
#else
#define OpenSCManager  OpenSCManagerA
#endif // !UNICODE

WINADVAPI
SC_HANDLE
WINAPI
OpenServiceA(
    SC_HANDLE   hSCManager,
    LPCSTR    lpServiceName,
    DWORD       dwDesiredAccess
    );
WINADVAPI
SC_HANDLE
WINAPI
OpenServiceW(
    SC_HANDLE   hSCManager,
    LPCWSTR    lpServiceName,
    DWORD       dwDesiredAccess
    );
#ifdef UNICODE
#define OpenService  OpenServiceW
#else
#define OpenService  OpenServiceA
#endif // !UNICODE

WINADVAPI
BOOL
WINAPI
QueryServiceConfigA(
    SC_HANDLE               hService,
    LPQUERY_SERVICE_CONFIGA lpServiceConfig,
    DWORD                   cbBufSize,
    LPDWORD                 pcbBytesNeeded
    );
WINADVAPI
BOOL
WINAPI
QueryServiceConfigW(
    SC_HANDLE               hService,
    LPQUERY_SERVICE_CONFIGW lpServiceConfig,
    DWORD                   cbBufSize,
    LPDWORD                 pcbBytesNeeded
    );
#ifdef UNICODE
#define QueryServiceConfig  QueryServiceConfigW
#else
#define QueryServiceConfig  QueryServiceConfigA
#endif // !UNICODE

WINADVAPI
BOOL
WINAPI
QueryServiceLockStatusA(
    SC_HANDLE                       hSCManager,
    LPQUERY_SERVICE_LOCK_STATUSA    lpLockStatus,
    DWORD                           cbBufSize,
    LPDWORD                         pcbBytesNeeded
    );
WINADVAPI
BOOL
WINAPI
QueryServiceLockStatusW(
    SC_HANDLE                       hSCManager,
    LPQUERY_SERVICE_LOCK_STATUSW    lpLockStatus,
    DWORD                           cbBufSize,
    LPDWORD                         pcbBytesNeeded
    );
#ifdef UNICODE
#define QueryServiceLockStatus  QueryServiceLockStatusW
#else
#define QueryServiceLockStatus  QueryServiceLockStatusA
#endif // !UNICODE

WINADVAPI
BOOL
WINAPI
QueryServiceObjectSecurity(
    SC_HANDLE               hService,
    SECURITY_INFORMATION    dwSecurityInformation,
    PSECURITY_DESCRIPTOR    lpSecurityDescriptor,
    DWORD                   cbBufSize,
    LPDWORD                 pcbBytesNeeded
    );

WINADVAPI
BOOL
WINAPI
QueryServiceStatus(
    SC_HANDLE           hService,
    LPSERVICE_STATUS    lpServiceStatus
    );

WINADVAPI
SERVICE_STATUS_HANDLE
WINAPI
RegisterServiceCtrlHandlerA(
    LPCSTR             lpServiceName,
    LPHANDLER_FUNCTION   lpHandlerProc
    );
WINADVAPI
SERVICE_STATUS_HANDLE
WINAPI
RegisterServiceCtrlHandlerW(
    LPCWSTR             lpServiceName,
    LPHANDLER_FUNCTION   lpHandlerProc
    );
#ifdef UNICODE
#define RegisterServiceCtrlHandler  RegisterServiceCtrlHandlerW
#else
#define RegisterServiceCtrlHandler  RegisterServiceCtrlHandlerA
#endif // !UNICODE

WINADVAPI
BOOL
WINAPI
SetServiceObjectSecurity(
    SC_HANDLE               hService,
    SECURITY_INFORMATION    dwSecurityInformation,
    PSECURITY_DESCRIPTOR    lpSecurityDescriptor
    );

WINADVAPI
BOOL
WINAPI
SetServiceStatus(
    SERVICE_STATUS_HANDLE   hServiceStatus,
    LPSERVICE_STATUS        lpServiceStatus
    );

WINADVAPI
BOOL
WINAPI
StartServiceCtrlDispatcherA(
    LPSERVICE_TABLE_ENTRYA    lpServiceStartTable
    );
WINADVAPI
BOOL
WINAPI
StartServiceCtrlDispatcherW(
    LPSERVICE_TABLE_ENTRYW    lpServiceStartTable
    );
#ifdef UNICODE
#define StartServiceCtrlDispatcher  StartServiceCtrlDispatcherW
#else
#define StartServiceCtrlDispatcher  StartServiceCtrlDispatcherA
#endif // !UNICODE


WINADVAPI
BOOL
WINAPI
StartServiceA(
    SC_HANDLE            hService,
    DWORD                dwNumServiceArgs,
    LPCSTR             *lpServiceArgVectors
    );
WINADVAPI
BOOL
WINAPI
StartServiceW(
    SC_HANDLE            hService,
    DWORD                dwNumServiceArgs,
    LPCWSTR             *lpServiceArgVectors
    );
#ifdef UNICODE
#define StartService  StartServiceW
#else
#define StartService  StartServiceA
#endif // !UNICODE

WINADVAPI
BOOL
WINAPI
UnlockServiceDatabase(
    SC_LOCK     ScLock
    );


#ifdef __cplusplus
}
#endif

#endif // _WINSVC_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\tools\c932\inc\winver.h ===
/*****************************************************************************\
*                                                                             *
* winver.h -    Version management functions, types, and definitions          *
*                                                                             *
*               Include file for VER.DLL.  This library is                    *
*               designed to allow version stamping of Windows executable files*
*               and of special .VER files for DOS executable files.           *
*                                                                             *
*               Copyright (c) 1993-1995, Microsoft Corp.  All rights reserved *
*                                                                             *
\*****************************************************************************/

#ifndef VER_H
#define VER_H

#ifdef __cplusplus
extern "C" {
#endif

/* ----- Symbols ----- */
#define VS_FILE_INFO            RT_VERSION
#define VS_VERSION_INFO         1
#define VS_USER_DEFINED         100

/* ----- VS_VERSION.dwFileFlags ----- */
#define VS_FFI_SIGNATURE        0xFEEF04BDL
#define VS_FFI_STRUCVERSION     0x00010000L
#define VS_FFI_FILEFLAGSMASK    0x0000003FL

/* ----- VS_VERSION.dwFileFlags ----- */
#define VS_FF_DEBUG             0x00000001L
#define VS_FF_PRERELEASE        0x00000002L
#define VS_FF_PATCHED           0x00000004L
#define VS_FF_PRIVATEBUILD      0x00000008L
#define VS_FF_INFOINFERRED      0x00000010L
#define VS_FF_SPECIALBUILD      0x00000020L

/* ----- VS_VERSION.dwFileOS ----- */
#define VOS_UNKNOWN             0x00000000L
#define VOS_DOS                 0x00010000L
#define VOS_OS216               0x00020000L
#define VOS_OS232               0x00030000L
#define VOS_NT                  0x00040000L

#define VOS__BASE               0x00000000L
#define VOS__WINDOWS16          0x00000001L
#define VOS__PM16               0x00000002L
#define VOS__PM32               0x00000003L
#define VOS__WINDOWS32          0x00000004L

#define VOS_DOS_WINDOWS16       0x00010001L
#define VOS_DOS_WINDOWS32       0x00010004L
#define VOS_OS216_PM16          0x00020002L
#define VOS_OS232_PM32          0x00030003L
#define VOS_NT_WINDOWS32        0x00040004L

/* ----- VS_VERSION.dwFileType ----- */
#define VFT_UNKNOWN             0x00000000L
#define VFT_APP                 0x00000001L
#define VFT_DLL                 0x00000002L
#define VFT_DRV                 0x00000003L
#define VFT_FONT                0x00000004L
#define VFT_VXD                 0x00000005L
#define VFT_STATIC_LIB          0x00000007L

/* ----- VS_VERSION.dwFileSubtype for VFT_WINDOWS_DRV ----- */
#define VFT2_UNKNOWN            0x00000000L
#define VFT2_DRV_PRINTER        0x00000001L
#define VFT2_DRV_KEYBOARD       0x00000002L
#define VFT2_DRV_LANGUAGE       0x00000003L
#define VFT2_DRV_DISPLAY        0x00000004L
#define VFT2_DRV_MOUSE          0x00000005L
#define VFT2_DRV_NETWORK        0x00000006L
#define VFT2_DRV_SYSTEM         0x00000007L
#define VFT2_DRV_INSTALLABLE    0x00000008L
#define VFT2_DRV_SOUND          0x00000009L
#define VFT2_DRV_COMM           0x0000000AL
#define VFT2_DRV_INPUTMETHOD    0x0000000BL

/* ----- VS_VERSION.dwFileSubtype for VFT_WINDOWS_FONT ----- */
#define VFT2_FONT_RASTER        0x00000001L
#define VFT2_FONT_VECTOR        0x00000002L
#define VFT2_FONT_TRUETYPE      0x00000003L

/* ----- VerFindFile() flags ----- */
#define VFFF_ISSHAREDFILE       0x0001

#define VFF_CURNEDEST           0x0001
#define VFF_FILEINUSE           0x0002
#define VFF_BUFFTOOSMALL        0x0004

/* ----- VerInstallFile() flags ----- */
#define VIFF_FORCEINSTALL       0x0001
#define VIFF_DONTDELETEOLD      0x0002

#define VIF_TEMPFILE            0x00000001L
#define VIF_MISMATCH            0x00000002L
#define VIF_SRCOLD              0x00000004L

#define VIF_DIFFLANG            0x00000008L
#define VIF_DIFFCODEPG          0x00000010L
#define VIF_DIFFTYPE            0x00000020L

#define VIF_WRITEPROT           0x00000040L
#define VIF_FILEINUSE           0x00000080L
#define VIF_OUTOFSPACE          0x00000100L
#define VIF_ACCESSVIOLATION     0x00000200L
#define VIF_SHARINGVIOLATION    0x00000400L
#define VIF_CANNOTCREATE        0x00000800L
#define VIF_CANNOTDELETE        0x00001000L
#define VIF_CANNOTRENAME        0x00002000L
#define VIF_CANNOTDELETECUR     0x00004000L
#define VIF_OUTOFMEMORY         0x00008000L

#define VIF_CANNOTREADSRC       0x00010000L
#define VIF_CANNOTREADDST       0x00020000L

#define VIF_BUFFTOOSMALL        0x00040000L

#ifndef RC_INVOKED              /* RC doesn't need to see the rest of this */

/* ----- Types and structures ----- */

typedef struct tagVS_FIXEDFILEINFO
{
    DWORD   dwSignature;            /* e.g. 0xfeef04bd */
    DWORD   dwStrucVersion;         /* e.g. 0x00000042 = "0.42" */
    DWORD   dwFileVersionMS;        /* e.g. 0x00030075 = "3.75" */
    DWORD   dwFileVersionLS;        /* e.g. 0x00000031 = "0.31" */
    DWORD   dwProductVersionMS;     /* e.g. 0x00030010 = "3.10" */
    DWORD   dwProductVersionLS;     /* e.g. 0x00000031 = "0.31" */
    DWORD   dwFileFlagsMask;        /* = 0x3F for version "0.42" */
    DWORD   dwFileFlags;            /* e.g. VFF_DEBUG | VFF_PRERELEASE */
    DWORD   dwFileOS;               /* e.g. VOS_DOS_WINDOWS16 */
    DWORD   dwFileType;             /* e.g. VFT_DRIVER */
    DWORD   dwFileSubtype;          /* e.g. VFT2_DRV_KEYBOARD */
    DWORD   dwFileDateMS;           /* e.g. 0 */
    DWORD   dwFileDateLS;           /* e.g. 0 */
} VS_FIXEDFILEINFO;

/* ----- Function prototypes ----- */

DWORD
APIENTRY
VerFindFileA(
        DWORD uFlags,
        LPSTR szFileName,
        LPSTR szWinDir,
        LPSTR szAppDir,
        LPSTR szCurDir,
        PUINT lpuCurDirLen,
        LPSTR szDestDir,
        PUINT lpuDestDirLen
        );
DWORD
APIENTRY
VerFindFileW(
        DWORD uFlags,
        LPWSTR szFileName,
        LPWSTR szWinDir,
        LPWSTR szAppDir,
        LPWSTR szCurDir,
        PUINT lpuCurDirLen,
        LPWSTR szDestDir,
        PUINT lpuDestDirLen
        );
#ifdef UNICODE
#define VerFindFile  VerFindFileW
#else
#define VerFindFile  VerFindFileA
#endif // !UNICODE

DWORD
APIENTRY
VerInstallFileA(
        DWORD uFlags,
        LPSTR szSrcFileName,
        LPSTR szDestFileName,
        LPSTR szSrcDir,
        LPSTR szDestDir,
        LPSTR szCurDir,
        LPSTR szTmpFile,
        PUINT lpuTmpFileLen
        );
DWORD
APIENTRY
VerInstallFileW(
        DWORD uFlags,
        LPWSTR szSrcFileName,
        LPWSTR szDestFileName,
        LPWSTR szSrcDir,
        LPWSTR szDestDir,
        LPWSTR szCurDir,
        LPWSTR szTmpFile,
        PUINT lpuTmpFileLen
        );
#ifdef UNICODE
#define VerInstallFile  VerInstallFileW
#else
#define VerInstallFile  VerInstallFileA
#endif // !UNICODE

/* Returns size of version info in bytes */
DWORD
APIENTRY
GetFileVersionInfoSizeA(
        LPSTR lptstrFilename, /* Filename of version stamped file */
        LPDWORD lpdwHandle
        );                      /* Information for use by GetFileVersionInfo */
/* Returns size of version info in bytes */
DWORD
APIENTRY
GetFileVersionInfoSizeW(
        LPWSTR lptstrFilename, /* Filename of version stamped file */
        LPDWORD lpdwHandle
        );                      /* Information for use by GetFileVersionInfo */
#ifdef UNICODE
#define GetFileVersionInfoSize  GetFileVersionInfoSizeW
#else
#define GetFileVersionInfoSize  GetFileVersionInfoSizeA
#endif // !UNICODE

/* Read version info into buffer */
BOOL
APIENTRY
GetFileVersionInfoA(
        LPSTR lptstrFilename, /* Filename of version stamped file */
        DWORD dwHandle,         /* Information from GetFileVersionSize */
        DWORD dwLen,            /* Length of buffer for info */
        LPVOID lpData
        );                      /* Buffer to place the data structure */
/* Read version info into buffer */
BOOL
APIENTRY
GetFileVersionInfoW(
        LPWSTR lptstrFilename, /* Filename of version stamped file */
        DWORD dwHandle,         /* Information from GetFileVersionSize */
        DWORD dwLen,            /* Length of buffer for info */
        LPVOID lpData
        );                      /* Buffer to place the data structure */
#ifdef UNICODE
#define GetFileVersionInfo  GetFileVersionInfoW
#else
#define GetFileVersionInfo  GetFileVersionInfoA
#endif // !UNICODE

DWORD
APIENTRY
VerLanguageNameA(
        DWORD wLang,
        LPSTR szLang,
        DWORD nSize
        );
DWORD
APIENTRY
VerLanguageNameW(
        DWORD wLang,
        LPWSTR szLang,
        DWORD nSize
        );
#ifdef UNICODE
#define VerLanguageName  VerLanguageNameW
#else
#define VerLanguageName  VerLanguageNameA
#endif // !UNICODE

BOOL
APIENTRY
VerQueryValueA(
        const LPVOID pBlock,
        LPSTR lpSubBlock,
        LPVOID * lplpBuffer,
        PUINT puLen
        );
BOOL
APIENTRY
VerQueryValueW(
        const LPVOID pBlock,
        LPWSTR lpSubBlock,
        LPVOID * lplpBuffer,
        PUINT puLen
        );
#ifdef UNICODE
#define VerQueryValue  VerQueryValueW
#else
#define VerQueryValue  VerQueryValueA
#endif // !UNICODE

#endif  /* !RC_INVOKED */

#ifdef __cplusplus
}
#endif

#endif  /* !VER_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\v86\monitor\sources.inc ===
!IF 0

Copyright (c) 1989  Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


Author:

    Steve Wood (stevewo) 12-Apr-1990
    Dave Hastings (daveh) 24-Apr-1991

NOTE:   Commented description of this file is in \nt\bak\bin\sources.tpl

!ENDIF


MAJORCOMP=v86
MINORCOMP=monitor
TARGETNAME=monitor
TARGETPATH=obj
TARGETTYPE=LIBRARY

MVDMDIR=$(PROJECT_ROOT)\mvdm

INCLUDES=\
    ..\I386;\
    $(MVDMDIR)\inc;\
    $(MVDMDIR)\softpc.new\base\inc;\
    $(MVDMDIR)\softpc.new\host\inc

SOURCES=

!IFDEF PROFILE
C_DEFINES=-DCPU_30_STYLE -DMONITOR -DPROFILE
!ELSE
!IFDEF OLDBUILD
C_DEFINES=-DCPU_30_STYLE -DMONITOR -DOLDBUILD
!ELSE
C_DEFINES=-DCPU_30_STYLE -DMONITOR
!ENDIF
!ENDIF

UMTYPE=console
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\v86\monitor\i386\fastpm.asm ===
title "Fast Protected Mode services"
;++
;
; Copyright (c) 1989  Microsoft Corporation
;
; Module Name:
;
;    fastpm.asm
;
; Abstract:
;
;    This module implements a fast entry to and exit from protected mode
;
; Author:
;
;    Dave Hastings (daveh) 26-Jul-91
;
;--
.386p

include ks386.inc
include callconv.inc
include bop.inc
include vint.inc
include vdmtib.inc

_TEXT   SEGMENT PARA PUBLIC 'CODE'
        ASSUME  DS:NOTHING, ES:NOTHING, SS:FLAT, FS:NOTHING, GS:NOTHING
_TEXT   ENDS

_DATA   SEGMENT  DWORD PUBLIC 'DATA'

        public _NTVDMpLockPrefixTable
_NTVDMpLockPrefixTable    label dword
        dd offset FLAT:_ntvdmlock1
        dd offset FLAT:_ntvdmlock2
        dd 0

ClientPMStack   df      ?
ClientPMEntry   df      ?

_DATA   ENDS

_TEXT   SEGMENT

; Interrupt type definitions
CPU_YODA_INT            equ 4
BIT_CPU_YODA_INT        equ 0
CPU_HW_RESET            equ 0
BIT_CPU_HW_RESET        equ 1
CPU_TIMER_TICK          equ 1
BIT_CPU_TIMER_TICK      equ 2
CPU_HW_INT              equ 3
BIT_CPU_HW_INT          equ 3

        assume DS:NOTHING
cPublicProc _VdmTrapcHandler, 0

;
; On entry, [ebx]->VdmContext
;

;
; zero higher 16bit of esp. (The Iretd in kernel trap handler puts higher 16bit
; of kernel esp back to our user mode esp even though the higher 16bit of
; TrapFrame.HardwareEsp is zeroed.
;
        and     esp, 0ffffh
;@@:

;
; Note, here we use app's stack to do the far return
;

        push    [ebx].VtVdmContext.CsSegCs
        push    [ebx].VtVdmContext.CsEip
        mov     ebx, [ebx].VtVdmContext.CsEbx
        retf

stdENDP _VdmTrapcHandler

        page    ,132
        subttl "FastEnterPm"
;++
;
;   Routine Description:
;
;       This routine is a faster way to enter 16 bit vdm protected mode.
;       Instead of making a system call, we just save the 32 bit state
;       into the VdmTib, restore the Vdm state from the VdmTib, and do
;       a far return to the application.
;
;   Arguments:
;
;       ss:sp + 4 = pointer to VdmTib
;
;   Returns:
;
;       nothing.
;
        assume DS:FLAT
cPublicProc _FastEnterPm,0

        push    ebp
        mov     ebp,esp                         ; set up stack frame

        push    ebx                             ; free up reg for pointer

        mov     ebx, KGDT_R3_TEB OR RPL_MASK
        mov     fs, ebx
        mov     ebx, fs:[PcTeb]
        mov     ebx, dword ptr [ebx].TeVdm

        ; translate the interrupt flag to the virtual interrupt flag

        test    [ebx].VtVdmContext.CsEFlags,dword ptr EFLAGS_INTERRUPT_MASK
        jz      fe10

_ntvdmlock1:
        lock or dword ptr ds:FIXED_NTVDMSTATE_LINEAR,dword ptr VDM_VIRTUAL_INTERRUPTS
        test    dword ptr ds:FIXED_NTVDMSTATE_LINEAR,dword ptr VDM_INTERRUPT_PENDING
        jz      fe20

        ; set up event info for an interrupt acknowlege

        mov     word ptr [ebx].VtEventInfo.EiEvent,VdmIntAck
        mov     word ptr [ebx].VtEventInfo.EiInstructionSize,0
        mov     word ptr [ebx].VtEventInfo.EiIntAckInfo,0

        pop     ebx
        mov     esp,ebp
        pop     ebp
        stdRET  _FastEnterPm

fe10:
_ntvdmlock2:
        lock and dword ptr ds:FIXED_NTVDMSTATE_LINEAR, NOT VDM_VIRTUAL_INTERRUPTS
fe20:
        mov     [ebx].VtMonitorContext.CsEax,eax
        mov     eax,[ebp - 4]
        mov     [ebx].VtMonitorContext.CsEbx,eax
        mov     [ebx].VtMonitorContext.CsEcx,ecx
        mov     [ebx].VtMonitorContext.CsEdx,edx
        mov     [ebx].VtMonitorContext.CsEsi,esi
        mov     [ebx].VtMonitorContext.CsEdi,edi
        mov     eax,[ebp]
        mov     [ebx].VtMonitorContext.CsEbp,eax
        mov     eax,ebp

        add     eax,8                           ; pop ebp and ret addr

        mov     [ebx].VtMonitorContext.CsEsp,eax
        mov     eax,[ebp + 4]
        mov     [ebx].VtMonitorContext.CsEip,eax
        mov     eax,cs
        mov     [ebx].VtMonitorContext.CsSegCs,eax
        mov     eax,ss
        mov     [ebx].VtMonitorContext.CsSegSs,eax
        mov     eax,ds
        mov     [ebx].VtMonitorContext.CsSegDs,eax
        mov     eax,es
        mov     [ebx].VtMonitorContext.CsSegEs,eax
        mov     eax,fs
        mov     [ebx].VtMonitorContext.CsSegFs,eax
        mov     eax,gs
        mov     [ebx].VtMonitorContext.CsSegGs,eax
        pushfd
        pop     eax
        mov     [ebx].VtMonitorContext.CsEflags,eax


        test    [ebx].VtVdmContext.CsEflags, EFLAGS_TF_MASK ; debugging?
        jz      fe_atomic                       ; no, return the robust way

;
; Beginning STACK-BASED return
;
; The following code transitions us back to client code in protect mode
; using the client's stack. This is not a good thing to do in general
; since this is not how things worked on win31. But it is necessary if
; we are setting the trap flag in the EFLAGS register in order to break
; on the correct instruction.
;
        mov     eax,[ebx].VtVdmContext.CsSegSs
        mov     es,eax
        mov     edi,[ebx].VtVdmContext.CsEsp    ; es:edi -> stack
        lar     eax,eax
        test    eax,400000h                     ; big?
        jnz     fe30

        movzx   edi,di
fe30:   mov     eax,[ebx].VtVdmContext.CsEflags
        sub     edi,4
        mov     es:[edi],eax             ; push Eflags
        mov     eax,[ebx].VtVdmContext.CsSegCs
        sub     edi,4
        mov     es:[edi],eax             ; push cs
        mov     eax,[ebx].VtVdmContext.CsEip
        sub     edi,4
        mov     es:[edi],eax             ; push ip
        sub     edi,4
        mov     eax,[ebx].VtVdmContext.CsEbp ; push ebp
        mov     es:[edi],eax

fe40:   push    es
        push    edi                     ; push ss:esp for lss esp
        mov     eax,esp                 ; save sp for pushad

        ; simulate pushad
        push    dword ptr [ebx].VtVdmContext.CsEax
        push    dword ptr [ebx].VtVdmContext.CsEcx
        push    dword ptr [ebx].VtVdmContext.CsEdx
        push    dword ptr [ebx].VtVdmContext.CsEbx
        push    eax
        push    ebp                     ; save pointer to stack frame
        push    dword ptr [ebx].VtVdmContext.CsEsi
        push    dword ptr [ebx].VtVdmContext.CsEdi

        ; push seg regs
        push    dword ptr [ebx].VtVdmContext.CsSegFs
        push    dword ptr [ebx].VtVdmContext.CsSegGs
        push    dword ptr [ebx].VtVdmContext.CsSegDs
        push    dword ptr [ebx].VtVdmContext.CsSegEs

        ; set up VDM seg regs
        pop     es
        pop     ds
        pop     gs             ; pop es,fs,gs of invalid selectors are trapped in ntoskrnl,
        pop     fs             ; and handled by setting to zero

        ; set up VDM general regs
        popad

        ; set up vdm stack
        lss esp,[ebp - 12]

        ; restore ebp
        pop     ebp

        ; return to VDM
        iretd

;
; Beginning STACK-LESS return
;
; WARNING:
; The following code does the final dispatch to the Client code.
; It uses STATIC data to hold CS, EIP, SS, ESP. THAT MAKES THIS CODE
; NON-REENTRANT. For correct operation, the rest of this code in this
; routine must execute to completion before coming back through. All
; ntvdm support code must honor this arrangement.
;
; The reason this code has this restriction is to avoid using the
; client's stack. Originally, this routine built a stack frame on the
; client stack, and IRET'd to it. This breaks some DPMI applications,
; either at a point where they have a transient condition with an invalid
; stack pointer, or because they expect unused stack space to be left
; alone by the system.
;
fe_atomic:
        mov     eax,[ebx].VtVdmContext.CsSegCs
        mov     word ptr ClientPmEntry+4, ax
        mov     eax,[ebx].VtVdmContext.CsEip
        mov     dword ptr ClientPmEntry, eax
        mov     eax,[ebx].VtVdmContext.CsSegSs
        mov     word ptr ClientPmStack+4, ax
        mov     eax,[ebx].VtVdmContext.CsEsp    ; es:edi -> stack
        mov     dword ptr ClientPmStack, eax

        mov     eax,esp                 ; save sp for pushad

        ; simulate pushad
        push    dword ptr [ebx].VtVdmContext.CsEax
        push    dword ptr [ebx].VtVdmContext.CsEcx
        push    dword ptr [ebx].VtVdmContext.CsEdx
        push    dword ptr [ebx].VtVdmContext.CsEbx
        push    eax
        push    dword ptr [ebx].VtVdmContext.CsEbp
        push    dword ptr [ebx].VtVdmContext.CsEsi
        push    dword ptr [ebx].VtVdmContext.CsEdi

        ; push seg regs
        push    dword ptr [ebx].VtVdmContext.CsSegFs
        push    dword ptr [ebx].VtVdmContext.CsSegGs
        push    dword ptr [ebx].VtVdmContext.CsSegDs
        push    dword ptr [ebx].VtVdmContext.CsSegEs

        push    dword ptr [ebx].VtVdmContext.CsEflags
        popfd

        ; set up VDM seg regs
        pop     es
        pop     ds
        pop     gs             ; pop fs,gs of invalid selectors are trapped in ntoskrnl,
        pop     fs             ; and handled by setting to zero

        ; set up VDM general regs
        popad

        lss     esp, cs:ClientPMStack
        jmp     fword ptr cs:ClientPMEntry

stdENDP _FastEnterPm

        page    ,132
        subttl "GetFastBopEntry"
;++
;
;   Routine Description:
;
;       This routine supplies the address of the routine that segmented
;       protected mode code should call to switch to flat mode.
;
;   Arguments:
;
;       esp + 4 = pointer to VdmTib->VdmContext
;
;   Returns:
;
;       nothing.
;
        assume DS:FLAT
cPublicProc _GetFastBopEntryAddress,1

        push    ebp
        mov     ebp,esp
        push    ebx
        push    eax
        mov     ebx,[ebp + 8]
        mov     [ebx].CsSegEs,cs
        mov     eax,offset FLAT:_FastLeavePm
        mov     word ptr [ebx].CsEbx,ax
        shr     eax,16
        mov     word ptr [ebx].CsEdx,ax
        pop     eax
        pop     ebx
        mov     esp,ebp
        pop     ebp
        stdRET  _GetFastBopEntryAddress

stdENDP _GetFastBopEntryAddress

        page    ,132
        subttl "FastLeavePm"
;++
;
;   Routine Description:
;
;       This routine switches from the VDM context to the monitor context.
;
;   Arguments:
;
;       none
;
;   Returns:
;
;       executing with monitor context
;
        assume DS:Nothing,ES:Nothing,SS:Nothing
ALIGN 16
cPublicProc _FastLeavePm,0
        push    ebx

        mov     bx,ds
        push    bx                              ; so push and pop size same
        mov     bx,KGDT_R3_DATA OR RPL_MASK
        mov     ds,bx
        assume  ds:FLAT

        push    fs
        mov     ebx, KGDT_R3_TEB OR RPL_MASK
        mov     fs, bx
        mov     ebx, fs:[PcTeb]
        mov     ebx, dword ptr [ebx].TeVdm
        pop     fs

        pushfd
        mov     dword ptr [ebx].VtVdmContext.CsEax,eax
        pop     eax
        mov     dword ptr [ebx].VtVdmContext.CsEFlags,eax
        pop     ax
        mov     word ptr [ebx].VtVdmContext.CsSegDs,ax
        pop     eax
        mov     dword ptr [ebx].VtVdmContext.CsEbx,eax
        mov     dword ptr [ebx].VtVdmContext.CsEcx,ecx
        mov     dword ptr [ebx].VtVdmContext.CsEdx,edx
        mov     dword ptr [ebx].VtVdmContext.CsEsi,esi
        mov     dword ptr [ebx].VtVdmContext.CsEdi,edi
        mov     dword ptr [ebx].VtVdmContext.CsEbp,ebp
        mov     word ptr [ebx].VtVdmContext.CsSegEs,es
        mov     word ptr [ebx].VtVdmContext.CsSegFs,fs
        mov     word ptr [ebx].VtVdmContext.CsSegGs,gs
        pop     eax
        mov     dword ptr [ebx].VtVdmContext.CsEip,eax
        pop     eax
        mov     word ptr [ebx].VtVdmContext.CsSegCs,ax
        mov     dword ptr [ebx].VtVdmContext.CsEsp,esp
        mov     word ptr [ebx].VtVdmContext.CsSegSs,ss

        ; switch Stacks
.errnz  (CsEsp + 4 - CsSegSS)
        lss     esp, [ebx].VtMonitorContext.CsEsp

        ; Now running on Monitor stack

        ; set up event info
        mov     word ptr [ebx].VtEventInfo.EiEvent,VdmBop
        mov     dword ptr [ebx].VtEventInfo.EiInstructionSize,BOP_SIZE
        mov     ax,[ebx].VtVdmContext.CsSegCs
        mov     es,ax
        ; BUGBUG 16 or 32 bit !!!!!
        mov     di,[ebx].VtVdmContext.CsEip
        mov     al,byte ptr es:[di]
        movzx   eax,al
        mov     [ebx].VtEventInfo.EiBopNumber,eax
        sub     di,2
        mov     word ptr [ebx].VtVdmContext.CsEip,di  ; set up bop bias

        ; set up for IRET
        push    dword ptr [ebx].VtMonitorContext.CsEFlags
        push    dword ptr [ebx].VtMonitorContext.CsSegCs
        push    dword ptr [ebx].VtMonitorContext.CsEip

        ; simulate pushad
        mov     eax,esp
        push    dword ptr [ebx].VtMonitorContext.CsEax
        push    dword ptr [ebx].VtMonitorContext.CsEcx
        push    dword ptr [ebx].VtMonitorContext.CsEdx
        push    dword ptr [ebx].VtMonitorContext.CsEbx
        push    eax
        push    dword ptr [ebx].VtMonitorContext.CsEbp
        push    dword ptr [ebx].VtMonitorContext.CsEsi
        push    dword ptr [ebx].VtMonitorContext.CsEdi

        ; push seg regs
        push    dword ptr [ebx].VtMonitorContext.CsSegFs
        push    dword ptr [ebx].VtMonitorContext.CsSegGs
        push    dword ptr [ebx].VtMonitorContext.CsSegDs
        push    dword ptr [ebx].VtMonitorContext.CsSegEs

        test    ds:FIXED_NTVDMSTATE_LINEAR,dword ptr VDM_VIRTUAL_INTERRUPTS
        jz      fl10

        or      [ebx].VtVdmContext.CsEFlags,dword ptr EFLAGS_INTERRUPT_MASK
        jmp     fl20

fl10:   and     dword ptr [ebx].VtVdmContext.CsEFlags, NOT EFLAGS_INTERRUPT_MASK
fl20:
        ; set up Monitor seg regs
        pop     es
        pop     ds
        pop     gs
        pop     fs

        ; set up Monitor general regs
        popad

        xor eax,eax                     ; indicate success

        ; clear the NT bit in EFLAGS such that the iretd will not be GP-faulted.
        pushfd
        and     dword ptr [esp], 0ffffbfffH
        popfd
        iretd
stdENDP _FastLeavePm

_TEXT ends
        end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\v86\monitor\i386\sources.inc ===
i386_SOURCES=i386\monitor.c \
             i386\fastpm.asm\
             i386\sas.c \
             i386\spcstubs.c \
             i386\thread.c \
             i386\int.c
!IF 0
Note: to build with profiling support, add the following to the i386_sources

             i386\proflib.c \
!ENDIF
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\v86\monitor\i386\int.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    int.c

Abstract:

    This file contains interrupt support routines for the monitor

Author:

    Dave Hastings (daveh) 18-Apr-1992

Notes:

    The code in this file split out from monitor.c (18-Apr-1992)

Revision History:

--*/

#include <monitorp.h>

#if defined(NEC_98)
VOID WaitVsync();
#endif // NEC_98

BOOL
DpmiHwIntHandler(
    ULONG IntNumber
    );

VOID
IRQ13_Eoi(
    int IrqLine,
    int CallCount
    );

#if defined(NEC_98)
VOID
IRQ13_Eoi_real(
    int IrqLine,
    int CallCount
    );
#endif // NEC_98

BOOLEAN IRQ13BeingHandled;  // true until IRQ13 eoi'ed


VOID
InterruptInit(
    VOID
)
/*++

Routine Description:

    This routine initializes the interrupt code for the monitor.

Arguments:


Return Value:

    None.

--*/
{
    BOOL Bool;



#if defined(NEC_98)
    Bool = RegisterEOIHook( 8, IRQ13_Eoi);
    Bool = RegisterEOIHook( 14, IRQ13_Eoi_real);
#else  // !NEC_98
    Bool = RegisterEOIHook( 13, IRQ13_Eoi);
#endif // !NEC_98
    if (!Bool) {
#if DBG
        DbgPrint("NtVdm : Could not register IRQ 13 Eoi handler\n");
        DbgBreakPoint();
#endif
        TerminateVDM();
    }
}

VOID
InterruptTerminate(
    VOID
    )
/*++

Routine Description:

    This routine frees the resoures allocated by InterruptInit

Arguments:


Return Value:

    None.

--*/
{
}


VOID
cpu_interrupt(
    IN int Type,
    IN int Number
    )
/*++

Routine Description:

    This routine causes an interrupt of the specified type to be raised
    at the appropriate time.

Arguments:

    Type -- indicates the type of the interrupt.  One of HARDWARE, TIMER, YODA,
            or RESET

            YODA and RESET are ignored

Return Value:

    None.

Notes:

--*/
{
    NTSTATUS Status;
    HANDLE   MonitorThread;

    host_ica_lock();

    if (CurrentMonitorTeb == NtCurrentTeb() && !getIF() && (getMSW() & MSW_PE)) {
        VDM_PM_CLI_DATA cliData;

        cliData.Control = PM_CLI_CONTROL_CHECK;
        NtVdmControl(VdmPMCliControl, &cliData);
    }

    if (Type == CPU_TIMER_TICK) {

            //
            // Set the VDM State for timer tick int pending
            //
        _asm {
            mov     eax, FIXED_NTVDMSTATE_LINEAR
            lock or dword ptr [eax], VDM_INT_TIMER
        }
    } else if (Type == CPU_HW_INT) {


        if (*pNtVDMState & VDM_INT_HARDWARE) {
            goto EarlyExit;
            }

            //
            // Set the VDM State for Hardware Int pending
            //
        _asm {
            mov     eax, FIXED_NTVDMSTATE_LINEAR
            lock or dword ptr [eax], VDM_INT_HARDWARE
        }
    } else {
#if DBG
        DbgPrint("Monitor: Invalid Interrupt Type=%ld\n",Type);
#endif
        goto EarlyExit;
    }

    if (CurrentMonitorTeb != NtCurrentTeb()) {

        /*
         *  Look up the ThreadHandle and Queue and InterruptApc
         *  If no ThreadHandle found do nothing
         *
         *  The CurrentMonitorTeb may not be in the ThreadHandle\Teb list
         *  because upon task termination the the CurrentMonitorTeb variable
         *  cannot be updated until a new task is activated by the
         *  non-preemptive scheduler.
         */
        MonitorThread = ThreadLookUp(CurrentMonitorTeb);
        if (MonitorThread) {
            Status = NtVdmControl(VdmQueueInterrupt, (PVOID)MonitorThread);
            // nothing much we can do if this fails
#if DBG
            if (!NT_SUCCESS(Status) && Status != STATUS_UNSUCCESSFUL) {
                DbgPrint("NtVdmControl.VdmQueueInterrupt Status=%lx\n",Status);
            }
#endif
        }

    }

EarlyExit:

    host_ica_unlock();
}




VOID
DispatchInterrupts(
    )
/*++

Routine Description:

    This routine dispatches interrupts to their appropriate handler routine
    in priority order. The order is YODA, RESET, TIMER, HARDWARE. however
    the YODA and RESET interrupts do nothing. Hardware interrupts are not
    simulated unless the virtual interrupt enable flag is set.  Flags
    indicating which interrupts are pending appear in the pNtVDMState.


Arguments:

    None.

Return Value:

    None.

Notes:

--*/
{

    host_ica_lock();

       // If any delayed interrupts have expired
       // call the ica to restart interrupts
    if (UndelayIrqLine) {
        ica_RestartInterrupts(UndelayIrqLine);
        }


    if (*pNtVDMState & VDM_INT_TIMER) {
        *pNtVDMState &= ~VDM_INT_TIMER;
        host_ica_unlock();      // maybe don't need to unlock ? Jonle
        host_timer_event();
        host_ica_lock();
    }

    if ( getIF() && getMSW() & MSW_PE && *pNtVDMState & VDM_INT_HARDWARE) {
        //
        // Mark the vdm state as hw int dispatched. Must use the lock as
        // kernel mode DelayedIntApcRoutine changes the bit as well
        //
        _asm {
            mov  eax,FIXED_NTVDMSTATE_LINEAR
            lock and dword ptr [eax], NOT VDM_INT_HARDWARE
            }
        DispatchHwInterrupt();
    }

    host_ica_unlock();
}




VOID
DispatchHwInterrupt(
    )
/*++

Routine Description:

    This routine dispatches hardware interrupts to the vdm in Protect Mode.
    It calls the ICA to get the vector number and sets up the VDM stack
    appropriately. Real Mode interrupt dispatching has been moved to the
    kernel.

Arguments:

    None.

Return Value:

    None.

--*/
{
    int InterruptNumber;
    ULONG IretHookAddress = 0L;
    PVDM_TIB VdmTib;

    InterruptNumber = ica_intack(&IretHookAddress);
    if (InterruptNumber == -1) { // skip spurious ints
        return;
        }

    DpmiHwIntHandler(InterruptNumber);

    VdmTib = (PVDM_TIB)(NtCurrentTeb()->Vdm);
    if (IretHookAddress) {
        BOOL Frame32 = (BOOL) VdmTib->DpmiInfo.Flags;
        BOOL Stack32;
        USHORT SegSs, VdmCs;
        ULONG VdmSp, VdmEip;
        PUCHAR VdmStackPointer;
        ULONG StackOffset;

        SegSs = getSS();
        VdmStackPointer = Sim32GetVDMPointer(((ULONG)SegSs) << 16, 1, TRUE);

        //
        // Figure out how many bits of sp to use
        //

        if (Ldt[(SegSs & ~0x7)/sizeof(LDT_ENTRY)].HighWord.Bits.Default_Big) {
            VdmSp = getESP();
            StackOffset = 12;
        } else {
            VdmSp = getSP();
            StackOffset = 6;
        }

        (PCHAR)VdmStackPointer += VdmSp;

        //
        // BUGBUG need to add stack limit checking 15-Nov-1993 Jonle
        //
        setESP(VdmSp - StackOffset);

        //
        // Push info for Iret hook handler
        //
        VdmCs = (USHORT) ((IretHookAddress & 0xFFFF0000) >> 16);
        VdmEip = (IretHookAddress & 0xFFFF);

        if (Frame32) {
            *(PULONG)(VdmStackPointer - 4) = VdmTib->VdmContext.EFlags;
            *(PULONG)(VdmStackPointer - 8) = (ULONG) VdmCs;
            *(PULONG)(VdmStackPointer - 12) = VdmEip;
        } else {
            *(PUSHORT)(VdmStackPointer - 2) = (USHORT) VdmTib->VdmContext.EFlags;
            *(PUSHORT)(VdmStackPointer - 4) = VdmCs;
            *(PUSHORT)(VdmStackPointer - 6) = (USHORT) VdmEip;
        }
    }

#if defined(NEC_98)
        if(InterruptNumber == 0xA) {
                WaitVsync();
        }
#endif // NEC_98
}


VOID
IRQ13_Eoi(
    int IrqLine,
    int CallCount
    )
{
    UNREFERENCED_PARAMETER(IrqLine);
    UNREFERENCED_PARAMETER(CallCount);

       //
       //  if CallCount is less than Zero, then the interrupt request
       //  is being canceled.
       //
#if defined(NEC_98)
  if( getMSW() & MSW_PE ){
#endif // NEC_98
    if (CallCount < 0) {
        return;
        }

    IRQ13BeingHandled = FALSE;

#if defined(NEC_98)
  }
#endif // NEC_98
}

#if defined(NEC_98)
VOID
IRQ13_Eoi_real(
    int IrqLine,
    int CallCount
    )
{
    UNREFERENCED_PARAMETER(IrqLine);
    UNREFERENCED_PARAMETER(CallCount);

    if( !(getMSW() & MSW_PE) ){
        if (CallCount < 0) {
            return;
        }
        IRQ13BeingHandled = FALSE;
    }
}
#endif // NEC_98





VOID
MonitorEndIretHook(
    VOID
    )
/*++

Routine Description:


Arguments:

    None.

Return Value:

    None.

--*/
{

    PVOID VdmStackPointer;
    PVDM_TIB VdmTib;

    VdmTib = (PVDM_TIB)(NtCurrentTeb()->Vdm);
    if (VdmTib->IntelMSW & MSW_PE) {
        BOOL Frame32 = (BOOL) VdmTib->DpmiInfo.Flags;
        ULONG FrameSize;

        if (Frame32) {
            FrameSize = 12;
        } else {
            FrameSize = 6;
        }

        VdmStackPointer = Sim32GetVDMPointer(((ULONG)getSS() << 16),2,TRUE);

        if (Ldt[(getSS() & ~0x7)/sizeof(LDT_ENTRY)].HighWord.Bits.Default_Big) {
            (PCHAR)VdmStackPointer += getESP();
            setESP(getESP() + FrameSize);
        } else {
            (PCHAR)VdmStackPointer += getSP();
            setSP((USHORT) (getSP() + FrameSize));
        }

        if (Frame32) {

            VdmTib->VdmContext.EFlags = *(PULONG)((PCHAR)VdmStackPointer + 8);
            setCS(*(PUSHORT)((PCHAR)VdmStackPointer + 4));
            VdmTib->VdmContext.Eip = *((PULONG)VdmStackPointer);

        } else {

            VdmTib->VdmContext.EFlags = (VdmTib->VdmContext.EFlags & 0xFFFF0000) |
                                        ((ULONG) *(PUSHORT)((PCHAR)VdmStackPointer + 4));
            setCS(*(PUSHORT)((PCHAR)VdmStackPointer + 2));
            VdmTib->VdmContext.Eip = (VdmTib->VdmContext.Eip & 0xFFFF0000) |
                                        ((ULONG) *(PUSHORT)((PCHAR)VdmStackPointer));

        }

    } else {

        VdmStackPointer = Sim32GetVDMPointer(((ULONG)getSS() << 16) | getSP(),2,FALSE);

        setSP((USHORT) (getSP() + 6));

        (USHORT)(VdmTib->VdmContext.EFlags) = *((PUSHORT)((PCHAR)VdmStackPointer + 4));
        setCS(*((PUSHORT)((PCHAR)VdmStackPointer + 2)));
        setIP(*((PUSHORT)VdmStackPointer));

    }


}

VOID
host_clear_hw_int()
/*++

Routine Description:

    This routine "forgets" a previously requested hardware interrupt.

Arguments:

    None.

Return Value:

    None.

--*/
{
   /*
    *  We do nothing here to save a kernel call, because the
    *  interrupt if it hasn't been intacked yet or dispatched,
    *  will produce a harmless spurious int, which is dropped
    *  in the i386 interrupt dispatching code anyhow.
    */
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\v86\monitor\i386\proflib.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

   proflib.c

Abstract:

    This module contains the implementation of a rudimentry user-mode
    profiler.

Usage:

    There are 4 routines, RtlInitializeProfile, RtlStartProfile,
    RtlStopProfile, and RtlAnalyzeProfile.  To initialize profiling
    invoke RtlInitializeProfile, this routine is only called once and
    goes through the address space looking for code regions of images
    and DLLs.  To start profiling call RtlStartProfile.  To stop
    profiling call RtlStopProfile.  Note that RtlStartProfile and
    RtlStopProfile can be called repeatedly to profile only key
    "hot spots", For example:
                RtlStartProfile ();
                hot spot...
                RtlStopProfile ();
                ....
                RtlStartProfile ();
                hot spot...
                RtlStopProfile ();

    To analyze the results call RtlAnalyzeProfile.  This too can
    be called repeatedly (it stops profiling during the analysis
    phase and does NOT restart profiling).  It also does not
    zero out the values after reporting.

Author:

    Lou Perazzoli (loup) 4-Oct-1990

Revision History:

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <string.h>
#include <stdio.h>
#include "..\..\..\..\private\ntos\dll\ldrp.h"

NTSTATUS
InitializeKernelProfile ( VOID );

#define PAGE_SIZE 4096

typedef struct _PROFILE_BLOCK {
    HANDLE Handle;
    PVOID ImageBase;  //actual base in image header
    PULONG CodeStart;
    ULONG CodeLength;
    PULONG Buffer;
    ULONG BufferSize;
    ULONG TextNumber;
    ULONG BucketSize;
    PVOID MappedImageBase;  //actual base where mapped locally.
    PSZ ImageName;
} PROFILE_BLOCK;


#define MAX_PROFILE_COUNT 50

PROFILE_BLOCK ProfileObject[MAX_PROFILE_COUNT];

ULONG NumberOfProfileObjects = 0;
PIMAGE_DEBUG_INFO KernelDebugInfo;

//
// Image name to perform kernel mode analysis upon.
//

#define IMAGE_NAME "\\SystemRoot\\ntoskrnl.exe"

//
// Define map data file if the produced data file should be
// a mapped file (currently named "kernprof.dat").
//

// #define MAP_DATA_FILE

//
// Define map as image if the image to be profiled should be mapped
// as an image rather than as data.
//

// #define MAP_AS_IMAGE

#define MAX_PROFILE_COUNT 50

extern ULONG ProfInt;

NTSTATUS
RtlInitializeProfile (
    IN BOOLEAN KernelToo
    )

/*++

Routine Description:

    This routine initializes profiling for the current process.

Arguments:

    KernelToo - Set to TRUE if kernel code should be profiled as
                well as user code.

Return Value:

    Returns the status of the last NtCreateProfile.

--*/

{

    NTSTATUS status, LocalStatus;
    HANDLE CurrentProcessHandle;
    ULONG BufferSize;
    PVOID ImageBase;
    ULONG CodeLength;
    PULONG Buffer;
    PPEB Peb;
    PLDR_DATA_TABLE_ENTRY LdrDataTableEntry;
    PSZ ImageName;
    PLIST_ENTRY Next;
    ULONG ExportSize, DebugSize;
    PIMAGE_EXPORT_DIRECTORY ExportDirectory;
    PIMAGE_DEBUG_DIRECTORY DebugDirectory;
    PIMAGE_DEBUG_INFO DebugInfo;
    BOOLEAN PreviousPrivState;

    //
    // Locate all the executables in the address and create a
    // seperate profile object for each one.
    //

    CurrentProcessHandle = NtCurrentProcess();

    Peb = NtCurrentPeb();

    Next = Peb->Ldr->InMemoryOrderModuleList.Flink;
    while ( Next != &Peb->Ldr->InMemoryOrderModuleList) {
        LdrDataTableEntry
            = (PLDR_DATA_TABLE_ENTRY) (CONTAINING_RECORD(Next,LDR_DATA_TABLE_ENTRY,InMemoryOrderLinks));

        ImageBase = LdrDataTableEntry->DllBase;
        if ( Peb->ImageBaseAddress == ImageBase ) {
            ImageName = "TheApplication";
        } else {
            ExportDirectory = (PIMAGE_EXPORT_DIRECTORY)RtlImageDirectoryEntryToData(
                               ImageBase,
                               TRUE,
                               IMAGE_DIRECTORY_ENTRY_EXPORT,
                               &ExportSize);

            ImageName =  (PSZ)((ULONG)ImageBase + ExportDirectory->Name);
        }
        if (NumberOfProfileObjects > MAX_PROFILE_COUNT) {
            break;
        }

        ProfileObject[NumberOfProfileObjects].ImageBase = ImageBase;
        ProfileObject[NumberOfProfileObjects].ImageName = ImageName;
        ProfileObject[NumberOfProfileObjects].MappedImageBase = ImageBase;

        //
        // Locate the code range and start profiling.
        //

        DebugDirectory = (PIMAGE_DEBUG_DIRECTORY)RtlImageDirectoryEntryToData(
                    ImageBase, TRUE, IMAGE_DIRECTORY_ENTRY_DEBUG, &DebugSize);

        if (!DebugDirectory) {
            DbgPrint ("RtlInitializeProfile : No debug directory\n");
            return STATUS_INVALID_IMAGE_FORMAT;
        }

        DebugInfo = (PIMAGE_DEBUG_INFO)((ULONG)ImageBase + DebugDirectory->AddressOfRawData);

        ProfileObject[NumberOfProfileObjects].CodeStart = (PULONG)((ULONG)ImageBase + DebugInfo->RvaToFirstByteOfCode);
        CodeLength = (DebugInfo->RvaToLastByteOfCode - DebugInfo->RvaToFirstByteOfCode) - 1;
        ProfileObject[NumberOfProfileObjects].CodeLength = CodeLength;

        ProfileObject[NumberOfProfileObjects].TextNumber = 1;

        //
        // Analyze the size of the code and create a reasonably sized
        // profile object.
        //

        BufferSize = (CodeLength >> 1) + 4;
        Buffer = NULL;

        status = NtAllocateVirtualMemory (CurrentProcessHandle,
                                          (PVOID *)&Buffer,
                                          0,
                                          &BufferSize,
                                          MEM_RESERVE | MEM_COMMIT,
                                          PAGE_READWRITE);

        if (!NT_SUCCESS(status)) {
            DbgPrint ("alloc VM failed %lx\n",status);
            return status;
        }


        status = RtlAdjustPrivilege(
                     SE_PROF_SINGLE_PROCESS_PRIVILEGE,
                     TRUE,              //Enable
                     FALSE,             //not impersonating
                     &PreviousPrivState //Remember if it will need to be cleared
                     );

        if (!NT_SUCCESS(status) || status == STATUS_NOT_ALL_ASSIGNED) {
            DbgPrint("Enable system profile privilege failed - status 0x%lx\n",
                     status);
        }


        ProfileObject[NumberOfProfileObjects].Buffer = Buffer;
        ProfileObject[NumberOfProfileObjects].BufferSize = BufferSize;
        ProfileObject[NumberOfProfileObjects].BucketSize = 3;

        status = NtCreateProfile (
                    &ProfileObject[NumberOfProfileObjects].Handle,
                    CurrentProcessHandle,
                    ProfileObject[NumberOfProfileObjects].CodeStart,
                    CodeLength,
                    ProfileObject[NumberOfProfileObjects].BucketSize,
                    ProfileObject[NumberOfProfileObjects].Buffer ,
                    ProfileObject[NumberOfProfileObjects].BufferSize,
                    ProfileTime,
                    (KAFFINITY)-1);

        if (PreviousPrivState == FALSE) {
            LocalStatus = RtlAdjustPrivilege(
                             SE_PROF_SINGLE_PROCESS_PRIVILEGE,
                             FALSE,             //Disable
                             FALSE,             //not impersonating
                             &PreviousPrivState //Don't care if it was already enabled
                             );
            if (!NT_SUCCESS(LocalStatus) || LocalStatus == STATUS_NOT_ALL_ASSIGNED) {
                DbgPrint("Disable system profile privilege failed - status 0x%lx\n",
                         LocalStatus);
            }
        }

        if (status != STATUS_SUCCESS) {
            DbgPrint("create profile %x failed - status %lx\n",
                   ProfileObject[NumberOfProfileObjects].ImageName,status);
            return status;
        }

        NumberOfProfileObjects += 1;

        Next = Next->Flink;
    }

    if (KernelToo) {

        if (NumberOfProfileObjects > MAX_PROFILE_COUNT) {
            return status;
        }
        status = InitializeKernelProfile();
    }
    return status;

}
NTSTATUS
InitializeKernelProfile (
    VOID
    )

/*++

Routine Description:

    This routine initializes profiling for the kernel for the
    current process.

Arguments:

    None.

Return Value:

    Returns the status of the last NtCreateProfile.

--*/

{

    //BUGBUG daveh I think that the new working set size calculation is
    //             generating the number of pages, when the api expects
    //             the number of bytes.

    STRING Name3;
    IO_STATUS_BLOCK IoStatus;
    HANDLE FileHandle, KernelSection;
    OBJECT_ATTRIBUTES ObjectAttributes;
    PVOID ImageBase;
    ULONG ViewSize;
    ULONG CodeLength;
    NTSTATUS status, LocalStatus;
    HANDLE CurrentProcessHandle;
    QUOTA_LIMITS QuotaLimits;
    PVOID Buffer;
    ULONG Cells;
    ULONG BucketSize;
    UNICODE_STRING Unicode;
    ULONG DebugSize;
    PVOID KernelBase;
    PIMAGE_NT_HEADERS KernelNtHeaders;
    PIMAGE_DEBUG_DIRECTORY DebugDirectory;
    BOOLEAN PreviousPrivState;

    RtlInitString (&Name3, IMAGE_NAME);
    CurrentProcessHandle = NtCurrentProcess();

    status = RtlAnsiStringToUnicodeString(&Unicode,(PANSI_STRING)&Name3,TRUE);
    ASSERT(NT_SUCCESS(status));
    InitializeObjectAttributes( &ObjectAttributes,
                                &Unicode,
                                OBJ_CASE_INSENSITIVE,
                                NULL,
                                NULL );

    //
    // Open the file as readable and executable.
    //

    status = NtOpenFile ( &FileHandle,
                          FILE_READ_DATA | FILE_EXECUTE,
                          &ObjectAttributes,
                          &IoStatus,
                          FILE_SHARE_READ,
                          0L);
    RtlFreeUnicodeString(&Unicode);

    if (!NT_SUCCESS(status)) {
        DbgPrint("open file failed status %lx\n", status);
        NtTerminateProcess(NtCurrentProcess(),STATUS_SUCCESS);
    }

    InitializeObjectAttributes( &ObjectAttributes, NULL, 0, NULL, NULL );

    //
    // For normal images they would be mapped as an image, but
    // the kernel has no debug section (as yet) information, hence it
    // must be mapped as a file.
    //

    status = NtCreateSection (&KernelSection,
                              SECTION_MAP_EXECUTE,
                              &ObjectAttributes,
                              0,
                              PAGE_READONLY,
                              SEC_IMAGE,
                              FileHandle);

    if (!NT_SUCCESS(status)) {
        DbgPrint("create image section failed  status %lx\n", status);
        return(status);
    }

    ViewSize = 0;

    //
    // Map a view of the section into the address space.
    //

    KernelBase = NULL;

    status = NtMapViewOfSection (KernelSection,
                                 CurrentProcessHandle,
                                 (PVOID *)&KernelBase,
                                 0L,
                                 0,
                                 NULL,
                                 &ViewSize,
                                 ViewUnmap,
                                 0,
                                 PAGE_EXECUTE);

    if (!NT_SUCCESS(status)) {
        if (status != STATUS_IMAGE_NOT_AT_BASE) {
            DbgPrint("map section status %lx base %lx size %lx\n", status,
                KernelBase, ViewSize);
        }
    }

    KernelNtHeaders = (PIMAGE_NT_HEADERS)RtlImageNtHeader(KernelBase);

    ImageBase = (PVOID)KernelNtHeaders->OptionalHeader.ImageBase;

    DebugDirectory = (PIMAGE_DEBUG_DIRECTORY)RtlImageDirectoryEntryToData(
                KernelBase, TRUE, IMAGE_DIRECTORY_ENTRY_DEBUG, &DebugSize);

    if (!DebugDirectory) {
        DbgPrint("InitializeKernelProfile : No debug directory\n");
        return STATUS_INVALID_IMAGE_FORMAT;
    }

    KernelDebugInfo = (PIMAGE_DEBUG_INFO)((ULONG)KernelBase + DebugDirectory->AddressOfRawData);
    CodeLength = (KernelDebugInfo->RvaToLastByteOfCode - KernelDebugInfo->RvaToFirstByteOfCode) -1;

    //
    // Just create a 512K byte buffer.
    //

    ViewSize = 1024 * 512;
    Buffer = NULL;

    status = NtAllocateVirtualMemory (CurrentProcessHandle,
                                      (PVOID *)&Buffer,
                                      0,
                                      &ViewSize,
                                      MEM_RESERVE | MEM_COMMIT,
                                      PAGE_READWRITE);

    if (!NT_SUCCESS(status)) {
        DbgPrint ("alloc VM failed %lx\n",status);
        NtTerminateProcess(NtCurrentProcess(),STATUS_SUCCESS);
    }

    //
    // Calculate the bucket size for the profile.
    //

    Cells = ((CodeLength / (ViewSize >> 2)) >> 2);
    BucketSize = 2;

    while (Cells != 0) {
        Cells = Cells >> 1;
        BucketSize += 1;
    }

    ProfileObject[NumberOfProfileObjects].Buffer = Buffer;
    ProfileObject[NumberOfProfileObjects].MappedImageBase = KernelBase;
    ProfileObject[NumberOfProfileObjects].BufferSize = 1 + (CodeLength >> (BucketSize - 2));
    ProfileObject[NumberOfProfileObjects].CodeStart = (PULONG)((ULONG)ImageBase + KernelDebugInfo->RvaToFirstByteOfCode);
    ProfileObject[NumberOfProfileObjects].CodeLength = CodeLength;
    ProfileObject[NumberOfProfileObjects].TextNumber = 1;
    ProfileObject[NumberOfProfileObjects].ImageBase = ImageBase;
    ProfileObject[NumberOfProfileObjects].ImageName = "ntoskrnl";
    ProfileObject[NumberOfProfileObjects].BucketSize = BucketSize;


    //
    // Increase the working set to lock down a bigger buffer.
    //

    status = NtQueryInformationProcess (CurrentProcessHandle,
                                        ProcessQuotaLimits,
                                        &QuotaLimits,
                                        sizeof(QUOTA_LIMITS),
                                        NULL );

    if (!NT_SUCCESS(status)) {
        DbgPrint ("query process info failed %lx\n",status);
        NtTerminateProcess(NtCurrentProcess(),STATUS_SUCCESS);
    }

    QuotaLimits.MaximumWorkingSetSize += ViewSize / PAGE_SIZE;
    QuotaLimits.MinimumWorkingSetSize += ViewSize / PAGE_SIZE;

    status = NtSetInformationProcess (CurrentProcessHandle,
                                  ProcessQuotaLimits,
                                  &QuotaLimits,
                                  sizeof(QUOTA_LIMITS));
    if (!NT_SUCCESS(status)) {
        DbgPrint ("setting working set failed %lx\n",status);
        return status;
    }

    status = RtlAdjustPrivilege(
                 SE_PROF_SINGLE_PROCESS_PRIVILEGE,
                 TRUE,              //Enable
                 FALSE,             //not impersonating
                 &PreviousPrivState //Remember if it will need to be cleared
                 );

    if (!NT_SUCCESS(status) || status == STATUS_NOT_ALL_ASSIGNED) {
        DbgPrint("Enable process profile privilege failed - status 0x%lx\n",
                 status);
    }

    status = NtCreateProfile (
                &ProfileObject[NumberOfProfileObjects].Handle,
                CurrentProcessHandle,
                ProfileObject[NumberOfProfileObjects].CodeStart,
                CodeLength,
                ProfileObject[NumberOfProfileObjects].BucketSize,
                ProfileObject[NumberOfProfileObjects].Buffer ,
                ProfileObject[NumberOfProfileObjects].BufferSize,
                ProfileTime,
                (KAFFINITY)-1);

    if (PreviousPrivState == FALSE) {
        LocalStatus = RtlAdjustPrivilege(
                         SE_PROF_SINGLE_PROCESS_PRIVILEGE,
                         FALSE,             //Disable
                         FALSE,             //not impersonating
                         &PreviousPrivState //Don't care if it was already enabled
                         );
        if (!NT_SUCCESS(LocalStatus) || LocalStatus == STATUS_NOT_ALL_ASSIGNED) {
            DbgPrint("Disable system profile privilege failed - status 0x%lx\n",
                     LocalStatus);
        }
    }

    if (status != STATUS_SUCCESS) {
        DbgPrint("create kernel profile %s failed - status %lx\n",
                   ProfileObject[NumberOfProfileObjects].ImageName,status);
    }

    NumberOfProfileObjects += 1;

    return status;
}


VOID
RtlpWriteProfileLine(
    IN HANDLE ProfileHandle,
    IN PSZ Line,
    IN int nbytes
    )
{
    IO_STATUS_BLOCK IoStatusBlock;

    NtWriteFile(
        ProfileHandle,
        NULL,
        NULL,
        NULL,
        &IoStatusBlock,
        Line,
        (ULONG)nbytes,
        NULL,
        NULL
        );

}


HANDLE
RtlpOpenProfileOutputFile()
{
    NTSTATUS Status;
    OBJECT_ATTRIBUTES Obja;
    HANDLE Handle;
    UNICODE_STRING FileName;
    IO_STATUS_BLOCK IoStatusBlock;
    BOOLEAN TranslationStatus;
    RTL_RELATIVE_NAME RelativeName;
    PVOID FreeBuffer;


    TranslationStatus = RtlDosPathNameToNtPathName_U(
                            L"\\profile.out",
                            &FileName,
                            NULL,
                            &RelativeName
                            );

    if ( !TranslationStatus ) {
        return NULL;
        }
    FreeBuffer = FileName.Buffer;

    if ( RelativeName.RelativeName.Length ) {
        FileName = *(PUNICODE_STRING)&RelativeName.RelativeName;
        }
    else {
        RelativeName.ContainingDirectory = NULL;
        }

    InitializeObjectAttributes(
        &Obja,
        &FileName,
        OBJ_CASE_INSENSITIVE,
        RelativeName.ContainingDirectory,
        NULL
        );

    Status = NtCreateFile(
                &Handle,
                FILE_APPEND_DATA | SYNCHRONIZE,
                &Obja,
                &IoStatusBlock,
                NULL,
                FILE_ATTRIBUTE_NORMAL,
                FILE_SHARE_READ,
                FILE_OPEN_IF,
                FILE_SYNCHRONOUS_IO_NONALERT,
                NULL,
                0L
                );

    RtlFreeHeap(RtlProcessHeap(),0,FreeBuffer);
    if ( !NT_SUCCESS(Status) ) {
        return NULL;
        }

    return Handle;
}

VOID
RtlpDeleteProfileOutputFile()
{
    NTSTATUS Status;
    OBJECT_ATTRIBUTES Obja;
    HANDLE Handle;
    UNICODE_STRING FileName;
    IO_STATUS_BLOCK IoStatusBlock;
    FILE_DISPOSITION_INFORMATION Disposition;
    BOOLEAN TranslationStatus;
    RTL_RELATIVE_NAME RelativeName;
    PVOID FreeBuffer;

    TranslationStatus = RtlDosPathNameToNtPathName_U(
                            L"\\profile.out",
                            &FileName,
                            NULL,
                            &RelativeName
                            );

    if ( !TranslationStatus ) {
        return;
        }

    FreeBuffer = FileName.Buffer;

    if ( RelativeName.RelativeName.Length ) {
        FileName = *(PUNICODE_STRING)&RelativeName.RelativeName;
        }
    else {
        RelativeName.ContainingDirectory = NULL;
        }

    InitializeObjectAttributes(
        &Obja,
        &FileName,
        OBJ_CASE_INSENSITIVE,
        RelativeName.ContainingDirectory,
        NULL
        );

    //
    // Open the file for delete access
    //

    Status = NtOpenFile(
                &Handle,
                (ACCESS_MASK)DELETE | SYNCHRONIZE,
                &Obja,
                &IoStatusBlock,
                FILE_SHARE_DELETE,
                FILE_SYNCHRONOUS_IO_NONALERT | FILE_NON_DIRECTORY_FILE
                );
    RtlFreeHeap(RtlProcessHeap(),0,FreeBuffer);
    if ( !NT_SUCCESS(Status) ) {
        return;
        }

    //
    // Delete the file
    //
    Disposition.DeleteFile = TRUE;

    Status = NtSetInformationFile(
                Handle,
                &IoStatusBlock,
                &Disposition,
                sizeof(Disposition),
                FileDispositionInformation
                );

    NtClose(Handle);
}




NTSTATUS
RtlStartProfile (
    VOID
    )
/*++

Routine Description:

    This routine starts all profile objects which have been initialized.

Arguments:

    None.

Return Value:

    Returns the status of the last NtStartProfile.

--*/

{
    ULONG i;
    NTSTATUS status;
    QUOTA_LIMITS QuotaLimits;

    NtSetIntervalProfile(ProfInt,ProfileTime);
    RtlpDeleteProfileOutputFile();

    for (i = 0; i < NumberOfProfileObjects; i++) {

        status = NtStartProfile (ProfileObject[i].Handle);

        if (status == STATUS_WORKING_SET_QUOTA) {

           //
           // Increase the working set to lock down a bigger buffer.
           //

           status = NtQueryInformationProcess (NtCurrentProcess(),
                                               ProcessQuotaLimits,
                                               &QuotaLimits,
                                               sizeof(QUOTA_LIMITS),
                                               NULL );

           if (!NT_SUCCESS(status)) {
               DbgPrint ("query process info failed %lx\n",status);
               return status;

           }

           QuotaLimits.MaximumWorkingSetSize +=
                 10 * PAGE_SIZE + ProfileObject[i].BufferSize;
           QuotaLimits.MinimumWorkingSetSize +=
                 10 * PAGE_SIZE + ProfileObject[i].BufferSize;

           status = NtSetInformationProcess (NtCurrentProcess(),
                                         ProcessQuotaLimits,
                                         &QuotaLimits,
                                         sizeof(QUOTA_LIMITS));
           if (!NT_SUCCESS(status)) {
               DbgPrint ("setting working set failed %lx\n",status);
               return status;
           }
           status = NtStartProfile (ProfileObject[i].Handle);
        }

        if (status != STATUS_SUCCESS) {
            DbgPrint("start profile %s failed - status %lx\n",
                ProfileObject[i].ImageName, status);
            return status;
        }
    }
    return status;
}
NTSTATUS
RtlStopProfile (
    VOID
    )

/*++

Routine Description:

    This routine stops all profile objects which have been initialized.

Arguments:

    None.

Return Value:

    Returns the status of the last NtStopProfile.

--*/

{
    ULONG i;
    NTSTATUS status;

    for (i = 0; i < NumberOfProfileObjects; i++) {
        status = NtStopProfile (ProfileObject[i].Handle);
        if (status != STATUS_SUCCESS) {
            DbgPrint("stop profile %s failed - status %lx\n",
                   ProfileObject[i].ImageName,status);
            return status;
        }
    }
    return status;
}

NTSTATUS
RtlAnalyzeProfile (
    VOID
    )

/*++

Routine Description:

    This routine does the analysis of all the profile buffers and
    correlates hits to the appropriate symbol table.

Arguments:

    None.

Return Value:

    None.

--*/

{


    RTL_SYMBOL_INFORMATION ThisSymbol;
    RTL_SYMBOL_INFORMATION LastSymbol;
    ULONG CountAtSymbol;
    NTSTATUS Status;
    ULONG Va;
    HANDLE ProfileHandle;
    CHAR Line[512];
    int i,n;
    PULONG Buffer, BufferEnd, Counter;


    ProfileHandle = RtlpOpenProfileOutputFile();
    ASSERT(ProfileHandle);

    for (i = 0; i < NumberOfProfileObjects; i++) {
        Status = NtStopProfile (ProfileObject[i].Handle);
        }


    //
    // The new profiler
    //

    for (i = 0; i < NumberOfProfileObjects; i++)  {

        LastSymbol.Value = 0;
        CountAtSymbol = 0;

        //
        // Sum the total number of cells written.
        //

        BufferEnd = ProfileObject[i].Buffer + (
                    ProfileObject[i].BufferSize / sizeof(ULONG));
        Buffer = ProfileObject[i].Buffer;

        for ( Counter = Buffer; Counter < BufferEnd; Counter += 1 ) {
            if ( *Counter ) {

                //
                // Now we have an an address relative to the buffer
                // base.
                //

                Va = (ULONG)((PUCHAR)Counter - (PUCHAR)Buffer);
                Va = Va * ( 1 << (ProfileObject[i].BucketSize - 2));

                //
                // Add in the image base and the base of the
                // code to get the Va in the image
                //

                Va = Va + (ULONG)ProfileObject[i].CodeStart;

                Status = RtlLookupSymbolByAddress(
                            ProfileObject[i].ImageBase,
                            NULL,
                            (PVOID)Va,
                            0x4000,
                            &ThisSymbol,
                            NULL
                            );
                if ( NT_SUCCESS(Status) ) {
                    if ( LastSymbol.Value && LastSymbol.Value == ThisSymbol.Value ) {
                        CountAtSymbol += *Counter;
                    }
                    else {
                        if ( LastSymbol.Value ) {
                            if ( CountAtSymbol ) {
                                n= sprintf(Line,"%d,%s,%S\n",
                                    CountAtSymbol,
                                    ProfileObject[i].ImageName,
                                    &LastSymbol.Name
                                    );
                                RtlpWriteProfileLine(ProfileHandle,Line,n);
                            }
                        }
                        CountAtSymbol = *Counter;
                        LastSymbol = ThisSymbol;
                    }
                }
            }
        }
        if ( CountAtSymbol ) {
            n= sprintf(Line,"%d,%s,%S\n",
                CountAtSymbol,
                ProfileObject[i].ImageName,
                &LastSymbol.Name
                );
            RtlpWriteProfileLine(ProfileHandle,Line,n);
        }
    }

    for (i = 0; i < NumberOfProfileObjects; i++) {
        Buffer = ProfileObject[i].Buffer;
        RtlZeroMemory(Buffer,ProfileObject[i].BufferSize);
    }
    NtClose(ProfileHandle);
    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\v86\monitor\i386\sas.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    Monitor.c
Abstract:

    This module is the user mode portion of the x86 monitor

Author:

    Dave Hastings (daveh) 16 Mar 1991

Environment:

    User mode only

Revision History:
    William Hsieh   10-10-1992 Added A20 wrapping support
--*/

#define VDD_INTEG 1
#include "monitorp.h"
#include <windows.h>
#include <stdio.h>
#include <malloc.h>

// Tim Nov 92.
void sas_connect_memory(
    IN sys_addr Low,
    IN sys_addr High,
    IN int Type
    );

//BUGBUGBUGBUG Include file

// from base\inc\sas.h
/* memory types for sas */
#define SAS_RAM 0
#define SAS_VIDEO 1
#define SAS_ROM 2
#define SAS_WRAP 3
#define SAS_INACCESSIBLE 4
#define SAS_MAX_TYPE    SAS_INACCESSIBLE

#define SIXTYFOURK 0x10000L
#define ONEMEGA 0x100000L

void rom_init();
void rom_checksum();
void copyROM();
#if defined(NEC_98)         
BOOL fvdmromprotect = FALSE;        
#endif // NEC_98

USHORT get_lim_backfill_segment(void);
BOOL   HoldEMMBackFillMemory(ULONG Address, ULONG Size);

#if DBG
extern unsigned short get_emm_page_size(void);
extern unsigned short get_intel_page_size(void);
#endif

/* SYNC THESE DEFINITIONS WITH BASE\EMM.H, or sas_init will assert */
#define EMM_PAGE_SIZE		0x4000
#define INTEL_PAGE_SIZE 	0x1000

typedef struct
{
    ULONG (*b_read) ();
    ULONG (*w_read) ();
    VOID (*str_read) ();
} READ_POINTERS;

// Internal Data
PMEMTYPE MemType = NULL;

// External Data
extern READ_POINTERS read_pointers;

// M variables used by video.lib

host_addr Start_of_M_area;       /* host addr (char *) of start of M */
sys_addr Length_of_M_area;       /* sys addr (long) offset of end of M */

static  HANDLE A20SectionHandle = NULL;
static BOOL A20IsON = FALSE;
static	USHORT	BackFillSegment;



EXPORT
VOID
sas_init(
    IN sys_addr Size
    )

/*++

Routine Description:

    This routine initializes the SAS module, and allocates the linear
    address space for the VDM, and loads the ROM

Arguments:

    Size - Supplies the size of the VDMs linear address space.

Return Value:

    None.

--*/

{
    NTSTATUS Status;
    ULONG ViewSize;
    PVOID BaseAddress;
    OBJECT_ATTRIBUTES   A20ObjAttr;
    LARGE_INTEGER       SectionSize;
    UCHAR SectionAnsiName[80];
    WCHAR SectionUnicodeName[80];
    UNICODE_STRING UnicodeString;
    USHORT Pages;
    ULONG BackFillBase;

#define CONVENTIONAL_MEM_SECTION "\\BaseNamedObjects\\VdmConventionalMemory"

    //
    // Create a name for the Convetional memory section
    //
    sprintf(
        SectionAnsiName,
        "%s%d",
        CONVENTIONAL_MEM_SECTION,
        GetCurrentProcessId()
        );

    if (MultiByteToWideChar(0, 0, SectionAnsiName, -1, SectionUnicodeName,80)
        == 0
    ) {
#if DBG
        DbgBreakPoint();
#endif
    //    host_error(EG_MALLOC_FAILURE,ERR_QUIT,"");
        TerminateVDM();
    }

    RtlInitUnicodeString(&UnicodeString, SectionUnicodeName);

    InitializeObjectAttributes(
        &A20ObjAttr,
        &UnicodeString,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL
        );

    SectionSize.HighPart = 0L;
    SectionSize.LowPart = 640 * 1024 + 64 * 1024;

    Status = NtCreateSection(
        &A20SectionHandle,
        SECTION_MAP_WRITE|SECTION_MAP_EXECUTE,
        &A20ObjAttr,
        &SectionSize,
        PAGE_EXECUTE_READWRITE,
        SEC_RESERVE,
        NULL
        );

    if (!NT_SUCCESS(Status)) {
	// bugbug -williamh
	// we should pop up an approiate message before we
	// terminate the vdm.
#if DBG
	    DbgPrint("sas_init: can not create himem section, status = %lx\n",
		     Status);
#endif
        TerminateVDM();
    }
    VdmSize = Size;

    //
    // N.B.  We expect that process creation has reserved the first 16 MB
    //       for us already.  If not, then this won't work worth a darn

    // free the first 640KB virtual address.
    // This is done because it has been resevered before sas_init get called
    BaseAddress = (PVOID)1;
    ViewSize = 640 * 1024 - 1;
    Status = NtFreeVirtualMemory(
        NtCurrentProcess(),
        &BaseAddress,
        &ViewSize,
        MEM_RELEASE
        );


    if (!NT_SUCCESS(Status)) {
#if DBG
	DbgPrint("sas_init: cannot free 1st 640k virtual address, status = %lx\n",
		 Status);
#endif
        TerminateVDM();
    }

    BaseAddress =(PVOID) ONEMEGA;
    ViewSize = SIXTYFOURK;
    Status = NtFreeVirtualMemory(
        NtCurrentProcess(),
        &BaseAddress,
        &ViewSize,
        MEM_RELEASE
        );


    if (!NT_SUCCESS(Status)) {
#if DBG
	DbgPrint("sas_init: can not free himem virtual address, status = %lx\n",
		 Status);
#endif
        TerminateVDM();
    }

    BaseAddress = (PVOID)VDM_BASE_ADDRESS;
    ViewSize = SIXTYFOURK - (ULONG)VDM_BASE_ADDRESS;
    SectionSize.HighPart = SectionSize.LowPart = 0;

    Status = NtMapViewOfSection(
        A20SectionHandle,
        NtCurrentProcess(),
        &BaseAddress,
        0,
        ViewSize,
        &SectionSize,
        &ViewSize,
        ViewUnmap,
        MEM_DOS_LIM,
        PAGE_EXECUTE_READWRITE
        );

    if (!NT_SUCCESS(Status)){
#if DBG
	DbgPrint("sas_init: can not map view of 1st 64K, status = %ls\n",
		 Status);
#endif
        TerminateVDM();
    }
    BaseAddress = (PVOID) ONEMEGA;
    ViewSize = SIXTYFOURK;
    Status = NtMapViewOfSection(A20SectionHandle,
        NtCurrentProcess(),
        &BaseAddress,
        0,
        ViewSize,
        &SectionSize,
        &ViewSize,
        ViewUnmap,
        MEM_DOS_LIM,
        PAGE_EXECUTE_READWRITE
        );

    if (!NT_SUCCESS(Status)){
#if DBG
	DbgPrint("sas_init: can not map view of himem space, status = %lx\n",
		 Status);
#endif
        TerminateVDM();
    }

    // get emm back fill segment address from softpc
    // we cut the backfill memory area into pieces in EMM_PAGE_SIZE unit.
    // this is done so that EMM manager can grab the address space
    // as EMM page frame.
    // note that if EMM is disabled, the backfill segment will be
    // (640 * 1024 / 16).

    BackFillSegment = get_lim_backfill_segment();

    ASSERT(BackFillSegment <= 640 * 1024 / 16);

    //
    // Map the rest of conventional memory
    // only map up to the emm backfill segment.
    BaseAddress = (PVOID) (64 * 1024);
    ViewSize = BackFillSegment * 16 - 64 * 1024;
    SectionSize.LowPart = 64 * 1024;
    SectionSize.HighPart = 0;
    Status = NtMapViewOfSection(A20SectionHandle,
        NtCurrentProcess(),
        &BaseAddress,
        0,
        ViewSize,
        &SectionSize,
        &ViewSize,
        ViewUnmap,
        MEM_DOS_LIM,
        PAGE_EXECUTE_READWRITE
        );
    if (!NT_SUCCESS(Status)){
#if DBG
	DbgPrint("sas_init: can not map view of himem space, status = %lx\n",
		 Status);
#endif
        TerminateVDM();
    }

// if there are any backfill memory, map it to our section initially
    if (BackFillSegment < 640 * 1024 / 16) {

    /* make sure our constants are in sync with emm.h */
#if DBG
	ASSERT(EMM_PAGE_SIZE == get_emm_page_size());
	ASSERT(INTEL_PAGE_SIZE == get_intel_page_size());
#endif
	if (!HoldEMMBackFillMemory(BackFillSegment * 16,
				   (640 * 1024) - BackFillSegment * 16)
				  ) {

#if DBG
	    DbgPrint("sas_init: can not map backfill space, status = %lx\n",
		     Status);
#endif
	    TerminateVDM();
	}
    }

    //
    // Allocate ROM area
    //
    BaseAddress = (PVOID)(640 * 1024);
    ViewSize = 384 * 1024;
    Status = NtAllocateVirtualMemory(
        NtCurrentProcess(),
        &BaseAddress,
        0L,
        &ViewSize,
        MEM_COMMIT,
        PAGE_READWRITE
        );
    if (!NT_SUCCESS(Status)){
#if DBG
	DbgPrint("sas_init: can not map view of himem space, status = %lx\n",
		 Status);
#endif
        TerminateVDM();
    }

    A20IsON = FALSE;

    Start_of_M_area = 0;
    Length_of_M_area = VdmSize;
    sas_connect_memory(0, VdmSize + 2*SIXTYFOURK -1, SAS_RAM);
#if defined(NEC_98)         
    rom_init();                  
#endif // NEC_98
}

#if VDD_INTEG

EXPORT
VOID
sas_term(
    VOID
    )
/*++

Routine Description:

    Free memory prior to reallocing it

Arguments:

    None.

Return Value:

    None.
--*/
{
    PVOID BaseAddress;
    NTSTATUS Status;
    ULONG Size;

    BaseAddress = (PVOID)VDM_BASE_ADDRESS;
    Size = VdmSize;
    Status = NtFreeVirtualMemory(
        NtCurrentProcess(),
        &BaseAddress,
        &Size,
        MEM_DECOMMIT);

    if (!NT_SUCCESS(Status)) {
        VDprint(VDP_LEVEL_ERROR,
            ("SoftPc: NtDeCommitVirtualMemory failed !!!! Status = %lx\n",
            Status));
        VDbreak(VDB_LEVEL_ERROR);
    }
}


EXPORT
sys_addr
sas_memory_size(
    VOID
    )
/*++

Routine Description:

    This routine returns the size of Intel memory

Arguments:

    none

Return Value:

    size of intel memory

--*/
{
    return(VdmSize);
}


EXPORT
VOID
sas_connect_memory(
    IN sys_addr Low,
    IN sys_addr High,
    IN int Type
    )
/*++

Routine Description:

    This routine sets up a type record for the specified address region.
    If the specified address region was a different type, it is changed to
    the new type.

Arguments:

    Low -- the starting address of the region
    High -- the ending address of the region
    Type -- the type for the region, one of SAS_RAM, SAS_VIDEO, SAS_ROM,
        SAS_WRAP, SAS_INACCESSIBLE

Return Value:

    None.
--*/
{
    //bugbug do we handle new block contained in old block correctly?
    PMEMTYPE Current, Previous, New, Temp;
#if defined(NEC_98)         
    NTSTATUS        status;                      
    PVOID        BaseAddress;                    
    ULONG        RegionSize;                     
    ULONG        OldProtect;                     

    BaseAddress = (PVOID) Low;                   
    RegionSize = (ULONG) (High - Low);           

    if(fvdmromprotect) {                         
    if(Type == SAS_ROM){                         
        status = NtProtectVirtualMemory(         
            NtCurrentProcess(),                  
            &BaseAddress,                        
            &RegionSize,                         
            PAGE_EXECUTE_READ,                   
            &OldProtect                          
            );                                   
    } else {                                     
        status = NtProtectVirtualMemory(         
            NtCurrentProcess(),                  
            &BaseAddress,                        
            &RegionSize,                         
            PAGE_EXECUTE_READWRITE,              
            &OldProtect                          
            );                                   
    }                                            
    }                                            
#endif // NEC_98

    if (!MemType) {
        MemType = (PMEMTYPE) ch_malloc(sizeof(MEMTYPE));
        if ( NULL == MemType ) {
             TerminateVDM();
        }

        MemType->Previous = NULL;
        MemType->Next = NULL;
        MemType->Start = Low;
        MemType->End = High;
        MemType->Type = (half_word)Type;
        return;
    }

    Current = MemType;
    while (Current && (Low > Current->Start)) {
        Previous = Current;
        Current = Current->Next;
    }

    if ((Current) && (Low == Current->Start) && (High == Current->End)) {
        Current->Type = (half_word)Type;
        return;
    }

    New = (PMEMTYPE) ch_malloc(sizeof(MEMTYPE));
    if ( NULL == New ) {
        TerminateVDM();
    }

    if (!Current) {
        // Block goes at end of list

        Previous->Next = New;
        New->Previous = Previous;
        New->Start = Low;
        New->End = High;
        New->Type = (half_word)Type;
        New->Next = NULL;
    } else {
        // Block goes in front of Current

        New->Start = Low;
        New->Type = (half_word)Type;
        New->End = High;
        New->Previous = Current->Previous;
        New->Next = Current;
        Current->Previous = New;
        if (!New->Previous) {
            MemType = New;
        } else {
            New->Previous->Next = New;
        }
    }


    // Block overlaps one or more existing blocks

    if (New->Previous) {
        if (New->Previous->End > New->End) {
            // block contained in exising block
            Temp = (PMEMTYPE) ch_malloc(sizeof(MEMTYPE));
            Temp->Previous = New;
            Temp->Next = New->Next;
            New->Next = Temp;
            if (Temp->Next) {
                Temp->Next->Previous = Temp;
            }
            Temp->End = New->Previous->End;
            New->Previous->End = New->Start - 1;
            Temp->Start = New->End + 1;
            Temp->Type = New->Previous->Type;
            return;
        } else if (New->Previous->End >= New->Start){
            // block overlaps end of exising block
            New->Previous->End = New->Start - 1;
        }
    }

    // remove all blocks entirely contained in new block
    while ((New->Next) && (New->Next->End <= New->End)) {
        Temp = New->Next;
        New->Next = New->Next->Next;
        if (New->Next) {
            New->Next->Previous = New;
        }
        free(Temp);
    }

    // remove portion of next block overlapping new block
    if ((New->Next) && (New->Next->Start <= New->End)) {
        New->Next->Start = New->End + 1;
    }

}


EXPORT
half_word
sas_memory_type(
    IN sys_addr Address
    )
/*++

Routine Description:

    This routine returns the type of memory at a specific address

Arguments:

    Address -- linear address to return type for.

Return Value:

    the type for the region, one of SAS_RAM, SAS_VIDEO, SAS_ROM,
        SAS_WRAP, SAS_INACCESSIBLE
--*/
{
    PMEMTYPE Current;

    if (Address > VdmSize) {
        return SAS_INACCESSIBLE;
    }

    Current = MemType;
    while (Current && !((Address >= Current->Start) &&
        (Address <= Current->End))) {
        Current = Current->Next;
    }
    if (!Current) {
        return SAS_INACCESSIBLE;
    }
    return Current->Type;
}



EXPORT
VOID
sas_enable_20_bit_wrapping(
    VOID
    )
/*++

Routine Description:

    This routine causes memory addresses to wrap at 1MB

Arguments:

    None.

Return Value:

    None.

--*/
{
    NTSTATUS    Status;
    PVOID   BaseAddress;
    ULONG   Size;
    LARGE_INTEGER SectionOffset;
    // if A20 line is off already do nothing
    if (A20IsON == FALSE){
        return;
    }
    BaseAddress = (PVOID)ONEMEGA;
    Size = SIXTYFOURK;
    Status = NtUnmapViewOfSection(NtCurrentProcess(),
                                  BaseAddress
                                  );

    if (!NT_SUCCESS(Status)) {
#if DBG
	DbgPrint("A20OFF: Unable to unmap view of section, status = %lx\n",
                 Status);
#endif
        TerminateVDM();
    }
    SectionOffset.HighPart = SectionOffset.LowPart = 0;
    Status = NtMapViewOfSection(A20SectionHandle,
                                NtCurrentProcess(),
                                &BaseAddress,
                                0,
                                Size,
                                &SectionOffset,
                                &Size,
                                ViewUnmap,
                                MEM_DOS_LIM,
                                PAGE_EXECUTE_READWRITE
                                );

    if (!NT_SUCCESS(Status)) {
#if DBG
	DbgPrint("A20OFF: Unable to map view of section, status = %lx\n",
                 Status);
#endif
        TerminateVDM();
    }
    A20IsON = FALSE;
}

EXPORT
VOID
sas_disable_20_bit_wrapping(
    VOID
    )
/*++

Routine Description:

    This routine causes addressing to NOT wrap at 1MB

Arguments:

    None.

Return Value:

    None.

--*/
{
    NTSTATUS    Status;
    PVOID   BaseAddress;
    ULONG   Size;
    LARGE_INTEGER SectionOffset;

    // if A20 line is on already do nothing
    if (A20IsON == TRUE){
        return;
    }
    BaseAddress = (PVOID)ONEMEGA;
    Size = SIXTYFOURK;

    Status = NtUnmapViewOfSection(NtCurrentProcess(),
                                  BaseAddress
                                  );


    if (!NT_SUCCESS(Status)) {
#if DBG
	DbgPrint("A20ON: Unable to unmap view of section, status = %lx\n",
                 Status);
#endif
	TerminateVDM();
    }
    SectionOffset.HighPart = 0;
    SectionOffset.LowPart = 640 * 1024;
    Status = NtMapViewOfSection(A20SectionHandle,
                                NtCurrentProcess(),
                                &BaseAddress,
                                0,
                                Size,
                                &SectionOffset,
                                &Size,
                                ViewUnmap,
                                MEM_DOS_LIM,
                                PAGE_EXECUTE_READWRITE
                                );

    if (!NT_SUCCESS(Status)) {
#if DBG
	DbgPrint("A20ON: Unable to map view of section, status = %lx\n",
                 Status);
#endif
	TerminateVDM();
    }
    A20IsON = TRUE;
}



EXPORT
half_word
sas_hw_at(
    IN sys_addr Address
    )
/*++

Routine Description:

    This routine returns the byte at the specified address

Arguments:

    Address -- address of byte to return

Return Value:

    value of byte at specified address

--*/
{
    half_word RetVal;

    if (Address > VdmSize) {
        return 0xFE;
    }

    RetVal = *((half_word *)Address);
    return RetVal;
}


EXPORT
word
sas_w_at(
    IN sys_addr Address
    )
/*++

Routine Description:

    This routine returns the word at the specified address

Arguments:

    Address -- address of word to return

Return Value:

    value of word at specified address

--*/
{
    word RetVal;

//    DbgPrint("NtVdm : sas_w_at \n");
    if (Address > VdmSize) {
        return 0xFEFE;
    }

    RetVal = *((word *)Address);
    return RetVal;
}


EXPORT
double_word
sas_dw_at(
    IN sys_addr Address
    )
/*++

Routine Description:

    This routine returns the dword at the specified address

Arguments:

    Address -- address of dword to return

Return Value:

    value of dword at specified address

--*/
{
    double_word RetVal;

    //DbgPrint("NtVdm : sas_dw_at \n");
    RetVal = (double_word)(((ULONG)sas_w_at(Address + 2) << 16) +
        sas_w_at(Address));
    return RetVal;
}


EXPORT
VOID
sas_load(
    IN sys_addr Address,
    IN half_word *Value
    )
/*++

Routine Description:

    This routine stores the byte at the specified address in the supplied
    variable

Arguments:

    Address -- address of byte to return
    Value -- Variable to store the value in

Return Value:

    None.
--*/
{
    //DbgPrint("NtVdm : sas_load \n");
    if (Address > VdmSize) {
        *Value = 0xFE;
        return;
    }

    *Value = *((half_word *)Address);
    return;
}


EXPORT
VOID
sas_loadw(
    IN sys_addr Address,
    IN word *Value
    )
/*++

Routine Description:

    This routine stores the word at the specified address in the supplied
    variable

Arguments:

    Address -- address of word to return
    Value -- Variable to store the value in

Return Value:

    None.
--*/
{
    //DbgPrint("NtVdm : sas_loadw\n");
    if (Address > VdmSize) {
        *Value = 0xFEFE;
        return;
    }

    *Value = *((word *)Address);
    //DbgPrint("NtVdm : sas_loadw word at address %lx is %x (Not video)\n",Address,*Value);
    return;
}



EXPORT
VOID
sas_store(
    IN sys_addr Address,
    IN half_word Value
    )
/*++

Routine Description:

    This routine stores the specified byte at the specified address

Arguments:

    Address -- address of word to return
    Value -- value to store

Return Value:

    None.
--*/
{
    half_word Type;
    //DbgPrint("NtVdm : sas_store\n");
    if (Address <= VdmSize) {
        Type = sas_memory_type(Address);
        switch (Type) {
            case SAS_ROM:
                break;

            default:
                *((half_word *)Address) = Value;
                //DbgPrint("NtVdm : sas_store put byte %x at address %lx\n",Value,Address);
                break;
        }
    }
}



EXPORT
VOID
sas_storew(
    IN sys_addr Address,
    IN word Value
    )
/*++

Routine Description:

    This routine stores the specified word at the specified address

Arguments:

    Address -- address of word to return
    Value -- value to store at the specified address

Return Value:

    None.
--*/
{

    //DbgPrint("NtVdm : sas_storew\n");
    if (Address + 1 <= VdmSize) {
        switch (sas_memory_type(Address)) {

            case SAS_ROM:
                break;

            default:
                *((word *)Address) = Value;
                //DbgPrint("NtVdm : sas_storew put word %x at address %lx\n",Value,Address);
                break;
        }
    }
}



EXPORT
VOID
sas_storedw(
    IN sys_addr Address,
    IN double_word Value
    )
/*++

Routine Description:

    This routine stores the specified dword at the specified address

Arguments:

    Address -- address of word to return
    Value -- value to store at the specified address

Return Value:

    None.
--*/
{
    //_asm int 3;
    sas_storew(Address, (word)(Value & 0xFFFF));
    sas_storew(Address + 2, (word)((Value >> 16) & 0xFFFF));
}


EXPORT
VOID
sas_loads(
    IN sys_addr Source,
    IN host_addr Destination,
    IN sys_addr Length
    )
/*++

Routine Description:

     This routine copies the string from the specified intel address to the
     specified host address

Arguments:

    Source -- Intel address to copy from
    Destination -- host address to copy the string to
    Length -- length of the string to copy

Return Value:

    None.
--*/
{

    //DbgPrint("NtVdm : sas_loads\n");
    RtlCopyMemory((PVOID) Destination, (PVOID) Source, Length);
}



EXPORT
VOID
sas_stores(
    IN sys_addr Destination,
    IN host_addr Source,
    IN sys_addr Length
    )
/*++

Routine Description:

     This routine copies the string from the specified host address to the
     specified intel address

Arguments:

    Destination -- intel address to copy the string to
    Source -- host address to copy from
    Length -- length of the string to copy

Return Value:

    None.
--*/
{

    //DbgPrint("NtVdm : sas_stores\n");
    switch (sas_memory_type(Destination)) {

        case SAS_ROM:
            break;

        default:
            RtlCopyMemory((PVOID) Destination, (PVOID) Source, Length);
            break;
    }
}


EXPORT
VOID
sas_move_bytes_forward(
    IN sys_addr Source,
    IN sys_addr Destination,
    IN sys_addr Length
    )
/*++

Routine Description:

    This routine copies one region of intel memory to another.

Arguments:

    Source -- source intel address
    Destination -- destination intel address
    Length -- length of region to copy (in bytes)

Return Value:

    None.
--*/
{
    //DbgPrint("NtVdm : sas_move_bytes_forward\n");
    switch (sas_memory_type(Destination)) {

        case SAS_ROM:
            break;

        default:
            RtlCopyMemory((PVOID) Destination, (PVOID) Source, Length);
            break;
    }
}



EXPORT
VOID
sas_move_words_forward(
    IN sys_addr Source,
    IN sys_addr Destination,
    IN sys_addr Length
    )
/*++

Routine Description:

    This routine copies one region of intel memory to another.

Arguments:

    Source -- source intel address
    Destination -- destination intel address
    Length -- length of region to copy (in words)

Return Value:

    None.
--*/
{
    //_asm int 3;
    Length <<= 1;
    switch (sas_memory_type(Destination)) {

        case SAS_ROM:
            break;

        default:
            RtlCopyMemory((PVOID) Destination, (PVOID) Source, Length);
            break;
    }
}



EXPORT
VOID
sas_move_bytes_backward(
    IN sys_addr Source,
    IN sys_addr Destination,
    IN sys_addr Length
    )
/*++

Routine Description:

    This routine copies one region of intel memory to another.

Arguments:

    Source -- source intel address
    Destination -- destination intel address
    Length -- length of region to copy (in bytes)

Return Value:

    None.
--*/
{
    //_asm int 3;
    switch (sas_memory_type(Destination)) {

        case SAS_ROM:
            break;

        default:
            RtlCopyMemory((PVOID) (Destination - Length + 1),
                          (PVOID) (Source - Length + 1),
                          Length);
            break;
    }
}



EXPORT
VOID
sas_move_words_backward(
    IN sys_addr Source,
    IN sys_addr Destination,
    IN sys_addr Length
    )
/*++

Routine Description:

    This routine copies one region of intel memory to another.

Arguments:

    Source -- source intel address
    Destination -- destination intel address
    Length -- length of region to copy (in words)

Return Value:

    None.
--*/
{
    //_asm int 3;
    Length <<= 1;
    switch (sas_memory_type(Destination)) {

        case SAS_ROM:
            break;

        default:
            RtlCopyMemory((PVOID) (Destination - Length + 1),
                          (PVOID) (Source - Length + 1),
                          Length);
            break;
    }
}

EXPORT
VOID
sas_fills(
    IN sys_addr Address,
    IN half_word Value,
    IN sys_addr Length
    )
/*++

Routine Description:

    This routine fills a specified region of intel memory with a byte value

Arguments:

    Address -- address to fill at
    Value -- value to fill with
    Length -- length of region to fill

Return Value:

    None.
--*/
{
    half_word Type;

    //DbgPrint("NtVdm : sas_fills\n");
    Type = sas_memory_type(Address);
    switch (Type) {

        case SAS_ROM:
            break;

        default:
            RtlFillMemory((PVOID) Address, Length, Value);
            break;
    }
}

EXPORT
VOID
sas_fillsw(
    IN sys_addr Address,
    IN word Value,
    IN sys_addr Length
    )
/*++

Routine Description:

    This routine fills a specified region of intel memory with a word value

Arguments:

    Address -- address to fill at
    Value -- value to fill with
    Length -- length of region to fill

Return Value:

    None.
--*/
{

    word *p;
    half_word Type;

    //DbgPrint("NtVdm : sas_fillsw\n");
    Type = sas_memory_type(Address);
    switch (Type) {

        case SAS_ROM:
            break;

        default:
            p = (word *)Address;
            while (Length--) {
                *p++ = Value;
            }
            break;
    }
}

host_addr scratch = NULL;

EXPORT
host_addr
sas_scratch_address(
    IN sys_addr Length
    )
/*++

Routine Description:

    This routine supplies a scratch buffer for short term use

Arguments

    Length -- length of buffer needed

Return Value:

    None.

NOTE: Sudeepb 31-Oct-1993 Converted scratch to be allocated dynamically rather
      than as a static array.
--*/
{
    //DbgPrint("NtVdm : sas_scratch_address\n");
#if defined(NEC_98)         
    if (Length > 96 * 1024) {                      
#else  // !NEC_98
    if (Length > 64 * 1024) {
#endif // !NEC_98
        //DbgPrint("SoftPc: sas_scratch_address requet for buffer larger than 64K\n");
        return NULL;
    }

    if (scratch)
        return scratch;

#if defined(NEC_98)         
    if ((scratch = (host_addr) malloc (96 * 1024)) == NULL)  
#else  // !NEC_98
    if ((scratch = (host_addr) malloc (64 * 1024)) == NULL)
#endif // !NEC_98
        return NULL;

    return scratch;
}

EXPORT
half_word
sas_hw_at_no_check(
    sys_addr addr
    )
// bugbug comment
{
    //DbgPrint("NtVdm : sas_hw_at_no_check\n");
    //DbgPrint("NtVdm : sas_hw_at_no_check byte at %lx is %x\n",addr,*((half_word *)addr));
    return *((half_word *)addr);
}

EXPORT
word
sas_w_at_no_check(
    sys_addr addr
    )
// bugbug comment
{
    //DbgPrint("NtVdm : sas_w_at_no_check\n");
    //DbgPrint("NtVdm : sas_w_at_no_check word at %lx is %x\n",addr,*((word *)addr));
    return *((word *)addr);
}
EXPORT
double_word
sas_dw_at_no_check(
    sys_addr addr
    )
// bugbug comment
{
    //DbgPrint("NtVdm : sas_dw_at_no_check\n");
    //DbgPrint("NtVdm : sas_dw_at_no_check double word at %lx is %lx\n",addr,*((double_word *)addr));
    return *((double_word *)addr);
}


EXPORT
VOID
sas_store_no_check(
    sys_addr addr,
    half_word val
    )
// bugbug comment
{
    //DbgPrint("NtVdm : sas_store_no_check\n");
    *((half_word *)addr) = val;
    //DbgPrint("NtVdm : sas_store_no_check stored byte %x at %lx\n",val,addr);
}

EXPORT
VOID
sas_storew_no_check(
    sys_addr addr,
    word val
    )
// bugbug comment
{
    //DbgPrint("NtVdm : sas_storew_no_check\n");
    *((word *)addr) = val;
}
EXPORT
double_word
effective_addr(
    IN word Segment,
    IN word Offset
    )
/*++

Routine Description:

    This routine maps effective_addr to Sim32GetVdmPointer

Arguments:

    Segment -- segment of address
    Offset -- offset of address

Return Value:

    Actual Intel address corresponding to the address supplied
--*/
{
    //DbgPrint("NtVdm : effective_addr\n");
    return (ULONG)Sim32GetVDMPointer(((((ULONG)Segment) << 16) | Offset), 1,
        (UCHAR) (getMSW() & MSW_PE ? TRUE : FALSE));
}

typedef enum
{
    RAM,
    VIDEO,
    ROM,
    IN_FRAGMENT,
    NEXT_FRAGMENT
} mem_type;

typedef struct
{
    VOID    (*b_write)();
    VOID    (*w_write)();
    VOID    (*b_fill)();
    VOID    (*w_fill)();
    VOID    (*b_move)();
    VOID    (*w_move)();
} MEM_HANDLERS;
#define TYPE_RANGE ((int)SAS_INACCESSIBLE)
#define write_b_write_ptrs( offset, func )  ( b_write_ptrs[(offset)] = (func) )
#define write_w_write_ptrs( offset, func )  ( w_write_ptrs[(offset)] = (func) )
#define write_b_page_ptrs( offset, func )   ( b_move_ptrs[(offset)] = b_fill_ptrs[(offset)] = (func) )
#define write_w_page_ptrs( offset, func )   ( w_move_ptrs[(offset)] = w_fill_ptrs[(offset)] = (func) )
#define init_b_write_ptrs( offset, func )   ( b_write_ptrs[(offset)] = (func) )
#define init_w_write_ptrs( offset, func )   ( w_write_ptrs[(offset)] = (func) )
#define init_b_page_ptrs( offset, func )    ( b_move_ptrs[(offset)] = b_fill_ptrs[(offset)] = (func) )
#define init_w_page_ptrs( offset, func )    ( w_move_ptrs[(offset)] = w_fill_ptrs[(offset)] = (func) )
#define read_b_write_ptrs( offset )     ( b_write_ptrs[(offset)] )
#define read_w_write_ptrs( offset )     ( w_write_ptrs[(offset)] )
#define read_b_page_ptrs( offset )      ( b_move_ptrs[(offset)] )
#define read_w_page_ptrs( offset )      ( w_move_ptrs[(offset)] )
#define read_b_move_ptrs( offset )      ( b_move_ptrs[(offset)] )
#define read_w_move_ptrs( offset )      ( w_move_ptrs[(offset)] )
#define read_b_fill_ptrs( offset )      ( b_fill_ptrs[(offset)] )
#define read_w_fill_ptrs( offset )      ( w_fill_ptrs[(offset)] )

/*
*   The main gmi data structures are defined here
*/
void (*(b_write_ptrs[TYPE_RANGE]))() ; /* byte write function */
void (*(w_write_ptrs[TYPE_RANGE]))() ; /* word write function */
void (*(b_fill_ptrs[TYPE_RANGE]))() ;  /* byte str fill func */
void (*(w_fill_ptrs[TYPE_RANGE]))() ;  /* word str fill func */
void (*(b_move_ptrs[TYPE_RANGE]))() ;  /* byte str write func */
void (*(w_move_ptrs[TYPE_RANGE]))() ;  /* word str write func */

void    gmi_define_mem(type,handlers)
mem_type type;
MEM_HANDLERS *handlers;
{
    int int_type = (int)(type);
    init_b_write_ptrs(int_type, (void(*)())(handlers->b_write));
    init_w_write_ptrs(int_type, (void(*)())(handlers->w_write));
    b_move_ptrs[int_type] = (void(*)())(handlers->b_move);
    w_move_ptrs[int_type] = (void(*)())(handlers->w_move);
    b_fill_ptrs[int_type] = (void(*)())(handlers->b_fill);
    w_fill_ptrs[int_type] = (void(*)())(handlers->w_fill);
}
#endif
BOOL sas_twenty_bit_wrapping_enabled() {
    return (!A20IsON);
}

VOID sas_part_enable_20_bit_wrapping(){
}
VOID sas_part_disable_20_bit_wrapping(){
}


/*
 * This function maps the given EMM backfill memory to DOS conventional
 * memory. The function is provided to EMM manager to put back
 * unmapped backfill memory(hold its contents while it is not mapped).
 *
 * NOTE: The very first caller will be sas_init.
 *
 * Input: ULONG BaseAddress -- the starting address, must be in INTEL page
 *			       boundary
 *	  ULONG Size	    -- size of the range, must be a multiple of
 *			       EMM_PAGE_SIZE.
 *
 * According to LouP, a view costs about 400 bytes of memory. This is why
 * I make these function strictly to work on EMM_PAGE_SIZE instead of 4KB.
 */


BOOL
HoldEMMBackFillMemory(ULONG BaseAddress, ULONG Size)
{
    ULONG NewBase, Pages, i;
    LARGE_INTEGER   SectionOffset;
    ULONG ViewSize;
    NTSTATUS Status;

    /* this function can only be called if there is backfill at all */
    ASSERT(BackFillSegment < 640 * 1024 / 16);

    // size must be EMM_PAGE_SIZE multiple
    ASSERT((Size % EMM_PAGE_SIZE) == 0);

    // address must be on INTEL page boundary
    ASSERT((BaseAddress & (INTEL_PAGE_SIZE - 1)) == 0);

    for (Pages = Size / EMM_PAGE_SIZE; Pages; Pages--) {
	SectionOffset.LowPart = BaseAddress;
	SectionOffset.HighPart = 0;
	ViewSize = EMM_PAGE_SIZE;
	Status = NtMapViewOfSection(A20SectionHandle,
				    NtCurrentProcess(),
				    (PVOID *)&BaseAddress,
				    0,
				    ViewSize,
				    &SectionOffset,
				    &ViewSize,
				    ViewUnmap,
				    MEM_DOS_LIM,
				    PAGE_EXECUTE_READWRITE
				    );
	if (!NT_SUCCESS(Status))
	    break;
	BaseAddress += EMM_PAGE_SIZE;
    }
    return (NT_SUCCESS(Status));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\v86\monitor\i386\monitorp.h ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    Monitorp.h

Abstract:

    This contains the function prototypes, constants, and types for
    the monitor.

Author:

    Dave Hastings (daveh) 16 Mar 1991

Revision History:

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <vdm.h>
#include <vint.h>
#include "bop.h"
#include "softpc.h"
//bugbug
typedef unsigned int UINT;

#include <nt_mon.h>   // for softpc base definitions
#include <nt_reset.h>
#include <monregs.h>

//extern VDM_TIB VdmTib;

#define EFLAGS_INTERRUPT_MASK 0x00000200L
#define EFLAGS_V86_MASK       0x00020000L
#define VDM_BASE_ADDRESS      0x00000001L


#define RPL_MASK                  3
// Types borrowed from windef.h

typedef unsigned char       BYTE;

// Memory type record

typedef struct _Memory_Type {
    struct _Memory_Type *Previous;
    struct _Memory_Type *Next;
    ULONG Start;
    ULONG End;
    half_word Type;
} MEMTYPE, *PMEMTYPE;

//  private flags

#define VDM_IDLE              0x00000001L

// external data

extern ULONG VdmFlags;
extern ULONG VdmSize;
extern LDT_ENTRY *Ldt;
extern ULONG   IntelBase;          // base memory address
extern ULONG   VdmDebugLevel;      // used to control debugging
extern ULONG   VdmSize;            // Size of memory in VDM
extern PVOID  CurrentMonitorTeb;   // thread that is currently executing instructions.
extern BOOLEAN IRQ13BeingHandled;  // true until IRQ13 eoi'ed
extern CONTEXT InitialContext;     // Initial floating point context for all threads
extern BOOLEAN DebugContextActive;

#define MAX_BOP 256
VOID reset(VOID);
VOID dummy_int(VOID);
VOID unexpected_int(VOID);
VOID illegal_bop(VOID);
VOID illegal_op_int(VOID);
VOID print_screen(VOID);
VOID time_int(VOID);
VOID keyboard_int(VOID);
VOID diskette_int(VOID);
VOID video_io(VOID);
VOID equipment(VOID);
VOID memory_size(VOID);
VOID disk_io(VOID);
VOID rs232_io(VOID);
VOID cassette_io(VOID);
VOID keyboard_io(VOID);
VOID printer_io(VOID);
VOID rom_basic(VOID);
VOID bootstrap(VOID);
VOID time_of_day(VOID);
VOID critical_region(VOID);
VOID cmd_install(VOID);
VOID cmd_load(VOID);
VOID redirector(VOID);
VOID ega_video_io(VOID);
VOID MsBop0(VOID);
VOID MsBop1(VOID);
VOID MsBop2(VOID);
VOID MsBop3(VOID);
VOID MsBop4(VOID);
VOID MsBop5(VOID);
VOID MsBop6(VOID);
VOID MsBop7(VOID);
VOID MsBop8(VOID);
VOID MsBop9(VOID);
VOID MsBopA(VOID);
VOID MsBopB(VOID);
VOID MsBopC(VOID);
VOID MsBopD(VOID);
VOID MsBopE(VOID);
VOID MsBopF(VOID);
VOID emm_init(VOID);
VOID emm_io(VOID);
VOID return_from_call(VOID);
VOID rtc_int(VOID);
VOID re_direct(VOID);
VOID D11_int(VOID);
VOID int_287(VOID);
VOID worm_init(VOID);
VOID worm_io(VOID);
VOID ps_private_1(VOID);
VOID ps_private_2(VOID);
VOID ps_private_3(VOID);
VOID ps_private_4(VOID);
VOID ps_private_5(VOID);
VOID ps_private_6(VOID);
VOID ps_private_7(VOID);
VOID ps_private_8(VOID);
VOID ps_private_9(VOID);
VOID ps_private_10(VOID);
VOID ps_private_11(VOID);
VOID ps_private_12(VOID);
VOID ps_private_13(VOID);
VOID ps_private_14(VOID);
VOID ps_private_15(VOID);
VOID bootstrap1(VOID);
VOID bootstrap2(VOID);
VOID bootstrap3(VOID);
VOID ms_windows(VOID);
VOID msw_mouse(VOID);
VOID mouse_install1(VOID);
VOID mouse_install2(VOID);
VOID mouse_int1(VOID);
VOID mouse_int2(VOID);
VOID mouse_io_language(VOID);
VOID mouse_io_interrupt(VOID);
VOID mouse_video_io(VOID);
VOID switch_to_real_mode(VOID);
VOID control_bop(VOID);
VOID diskette_io(VOID);
VOID host_unsimulate(VOID);
VOID DispatchPageFault (ULONG,ULONG);

NTSTATUS
FastEnterPm(
    );

VOID
DispatchInterrupts(
    VOID
    );

VOID
DispatchHwInterrupt(
    );

ULONG
GetInterruptHandler(
    ULONG InterruptNumber,
    BOOLEAN ProtectedMode
    );

PVOID
GetInterruptStack(
    ULONG InterruptNumber,
    PUSHORT StackSelector,
    PUSHORT StackPointer,
    BOOLEAN ProtectedMode
    );


VOID
CpuOnetimeInit(
    VOID
    );

VOID
CpuOnetimeTerm(
    VOID
    );

VOID
cpu_createthread();

VOID
cpu_exitthread();

HANDLE
ThreadLookUp(
    PVOID
    );

VOID
cpu_exit();

VOID
InterruptInit(
    VOID
    );

VOID
InterruptTerminate(
    VOID
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\v86\monitor\i386\monitor.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    Monitor.c
Abstract:

    This module is the user mode portion of the x86 monitor

Author:

    Dave Hastings (daveh) 16 Mar 1991

Environment:

    User mode only

Revision History:
    Sudeep Bharati (sudeepb) 31-Dec-1991

    Converted all register manipulation interfaces to functions
    from macros. This is to make ntvdm an exe as well as a dll,
    and these register oriented routines are exported from ntvdm
    for WOW32 and other installable VDDs.

    Dave Hastings (daveh) 18-Apr-1992

    Split into multiple files. Track current monitor thread by
    Teb pointer.  Register initial thread.

    Sudeep Bharati (sudeepb) 22-Sep-1992

    Added Page Fault Handling For installable VDD support

--*/


#include "monitorp.h"
#include "dbgsvc.h"


//
// Internal functions
//

VOID
EventVdmIo(
    VOID
    );

VOID
EventVdmStringIo(
    VOID
    );

VOID
EventVdmMemAccess(
    VOID
    );

VOID
EventVdmIntAck(
    VOID
    );

VOID
EventVdmBop(
    VOID
    );

VOID
EventVdmError(
    VOID
    );

VOID
EventVdmIrq13(
    VOID
    );

VOID
CreateProfile(
    VOID
    );

VOID
StartProfile(
    VOID
    );

VOID
StopProfile(
    VOID
    );

VOID
AnalyzeProfile(
    VOID
    );

typedef ULONG (*MYFARPROC)();

extern  MYFARPROC   WOWEnterVxDMutex;
extern  MYFARPROC   WOWLeaveVxDMutex;

// [LATER]  how do you prevent a struct from straddling a page boundary?

ULONG   IntelBase;          // base memory address
ULONG   VdmSize;            // Size of memory in VDM
ULONG   VdmDebugLevel;      // used to control debugging
PVOID  CurrentMonitorTeb;   // thread that is currently executing instructions.
ULONG InitialBreakpoint = FALSE; // if set, breakpoint at end of cpu_init
ULONG InitialVdmTibFlags = INITIAL_VDM_TIB_FLAGS; // VdmTib flags picked up from here
CONTEXT InitialContext;     // Initial context for all threads
BOOLEAN DebugContextActive = FALSE;
ULONG VdmFeatureBits = 0;   // bit to indicate special features

extern PVOID NTVDMpLockPrefixTable;

IMAGE_LOAD_CONFIG_DIRECTORY _load_config_used = {
    0,                          // Reserved
    0,                          // Reserved
    0,                          // Reserved
    0,                          // Reserved
    0,                          // GlobalFlagsClear
    0,                          // GlobalFlagsSet
    0,                          // CriticalSectionTimeout (milliseconds)
    0,                          // DeCommitFreeBlockThreshold
    0,                          // DeCommitTotalFreeThreshold
    (ULONG)&NTVDMpLockPrefixTable,     // LockPrefixTable, defined in FASTPM.ASM
    0, 0, 0, 0, 0, 0, 0         // Reserved
};

// Bop dispatch table

extern void (*BIOS[])();

//
// Event Dispatch table
//

VOID (*EventDispatch[VdmMaxEvent])(VOID) = {
        EventVdmIo,
        EventVdmStringIo,
        EventVdmMemAccess,
        EventVdmIntAck,
        EventVdmBop,
        EventVdmError,
        EventVdmIrq13
        };

#if DBG
#if defined(NEC_98)
BOOLEAN fShowIO = FALSE;
WORD    fshowport[16] = {0xffff,0xffff,0xffff,0xffff,0xffff,0xffff,0xffff,0xffff,0xffff,0xffff,0xffff,0xffff,0xffff,0xffff,0xffff,0xffff};
WORD    fshownoport[16] = {0xffff,0xffff,0xffff,0xffff,0xffff,0xffff,0xffff,0xffff,0xffff,0xffff,0xffff,0xffff,0xffff,0xffff,0xffff,0xffff};
#endif // NEC_98
BOOLEAN fBreakInDebugger = FALSE;
#endif



EXPORT
VOID
cpu_init(
    )

/*++

Routine Description:

    This routine is used to prepare the IEU for instruction simulation.
    It will set the Intel registers to thier initial value, and perform
    any implementation specific initialization necessary.


Arguments:


Return Value:

    None.

--*/

{
    NTSTATUS Status;

    InitialVdmTibFlags |= RM_BIT_MASK;


    //
    // Find out if we are running with IOPL.  We call the kernel
    // rather than checking the registry ourselves, so that we can
    // insure that both the kernel and ntvdm.exe agree.  If they didn't,
    // it would result in unnecssary trapping instructions.  Whether or
    // not Vdms run with IOPL only changes on reboot
    //
    Status = NtVdmControl(VdmFeatures, &VdmFeatureBits);

#if DBG
    if (!NT_SUCCESS(Status)) {
        DbgPrint(
            "NTVDM: Could not find out whether to use IOPL, %lx\n",
            Status
            );
    }
#endif

    //
    // If we have fast v86 mode IF emulation set the bit that tells
    // the 16 bit IF macros they know.
    //
    if (VdmFeatureBits & V86_VIRTUAL_INT_EXTENSIONS) {
        InitialVdmTibFlags |= RI_BIT_MASK;
    }

    *pNtVDMState = InitialVdmTibFlags;

    // Switch the npx back to 80 bit mode.  Win32 apps start with
    // 64-bit precision for compatibility across platforms, but
    // DOS and Win16 apps expect 80 bit precision.
    //

    _asm fninit;

    //
    // We setup the InitialContext structure with the correct floating
    // point and debug register configuration, and cpu_createthread
    // uses this context to configure each 16-bit thread's floating
    // point and debug registers.
    //

    InitialContext.ContextFlags = CONTEXT_FLOATING_POINT | CONTEXT_DEBUG_REGISTERS;

    Status = NtGetContextThread(
        NtCurrentThread(),
        &InitialContext
        );

    if (!NT_SUCCESS(Status)) {
#if DBG
        DbgPrint("NtVdm terminating : Could not get float/debug context for\n"
                 "                    initial thread, status %lx\n", Status);
        DbgBreakPoint();
#endif
        TerminateVDM();
    }


    //
    //
    // Turn OFF em bit so that dos apps will work correctly.
    //
    // On machines without 387's the floating point flag will have been
    // cleared.
    //

    InitialContext.ContextFlags = CONTEXT_FLOATING_POINT;
    InitialContext.FloatSave.Cr0NpxState &= ~0x6; // CR0_EM | CR0_MP

    //
    // Do the rest of thread initialization
    //
    cpu_createthread( NtCurrentThread(), NULL );

    InterruptInit();

    if (InitialBreakpoint) {
        DbgBreakPoint();
    }

}

EXPORT
VOID
cpu_terminate(
    )
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
    InterruptTerminate();
}

EXPORT
VOID
cpu_simulate(
    )

/*++

Routine Description:

    This routine causes the simulation of intel instructions to start.

Arguments:

Return Value:

    None.

--*/

{
    NTSTATUS Status;
    PVDM_TIB VdmTib;
    ULONG oldIntState = VDM_VIRTUAL_INTERRUPTS;

    DBGTRACE(VDMTR_TYPE_MONITOR | MONITOR_CPU_SIMULATE, 0, 0);

    CurrentMonitorTeb = NtCurrentTeb();
    VdmTib = (PVDM_TIB)NtCurrentTeb()->Vdm;

    VdmTib->ContinueExecution = TRUE;


    VdmTib->VdmContext.ContextFlags = CONTEXT_FULL;

    while (VdmTib->ContinueExecution) {

        //ASSERT(CurrentMonitorTeb == NtCurrentTeb());
        ASSERT(InterlockedIncrement(&VdmTib->NumTasks) == 0);

        if (*pNtVDMState & VDM_INTERRUPT_PENDING) {
            DispatchInterrupts();
        }

        // translate MSW bits into EFLAGS
        if ( getMSW() & MSW_PE ) {
            if (!VDMForWOW && !getIF() && oldIntState == VDM_VIRTUAL_INTERRUPTS) {

                //
                // For PM apps, we need to set Cli time stamp if interrupts
                // are disabled and the time stamp was not set already.
                // This is because apps may use int31 to change interrupt
                // state instead of using cli.
                //

                VDM_PM_CLI_DATA cliData;

                cliData.Control = PM_CLI_CONTROL_SET;
                NtVdmControl(VdmPMCliControl, &cliData);
            }

            VdmTib->VdmContext.EFlags &= ~EFLAGS_V86_MASK;
            Status = FastEnterPm();
        } else {
            VdmTib->VdmContext.EFlags |= EFLAGS_V86_MASK;
            Status = NtVdmControl(VdmStartExecution,NULL);
        }

        if (!NT_SUCCESS(Status)) {
#if DBG
            DbgPrint("NTVDM: Could not start execution\n");
#endif
            return;
        }

        //
        // Refresh VdmTib for the fact that wow32 thread never enters cpu_simulate
        // but returns here to handle BOP
        // Note, I think this needs only in FREE build.
        //

        CurrentMonitorTeb = NtCurrentTeb();
        VdmTib = (PVDM_TIB)NtCurrentTeb()->Vdm;
        if (!VDMForWOW) {
            oldIntState = getIF() ? VDM_VIRTUAL_INTERRUPTS : 0;
        }

        ASSERT(InterlockedDecrement(&VdmTib->NumTasks) < 0);


        if (WOWEnterVxDMutex)
            (*WOWEnterVxDMutex)();

#if DBG
        if (fBreakInDebugger) {
            fBreakInDebugger = 0;
            DbgBreakPoint();
        }
#endif

        // Translate Eflags value
        ASSERT ((!((VdmTib->VdmContext.EFlags & EFLAGS_V86_MASK) &&
            (getMSW() & MSW_PE))));

        if ( VdmTib->VdmContext.EFlags & EFLAGS_V86_MASK ) {
            VdmTib->VdmContext.EFlags &= ~EFLAGS_V86_MASK;
        }

        // bugbug does cs:eip wrap cause some kind of fault?
        VdmTib->VdmContext.Eip += VdmTib->EventInfo.InstructionSize;

        if (VdmTib->EventInfo.Event >= VdmMaxEvent) {
#if DBG
            DbgPrint("NTVDM: Unknown event type\n");
            DbgBreakPoint();
#endif
            VdmTib->ContinueExecution = FALSE;
            continue;
        }

        (*EventDispatch[VdmTib->EventInfo.Event])();

        if (WOWLeaveVxDMutex)
            (*WOWLeaveVxDMutex)();
    }


    // set this back to true incase we are nested
    VdmTib->ContinueExecution = TRUE;

    //
    // Restore the old Vdm tib info.  This is necessary for the for the
    // case where the application thread is suspended, and a host simulate is
    // performed from another thread
    //

    DBGTRACE(VDMTR_TYPE_MONITOR | MONITOR_CPU_UNSIMULATE, 0, 0);
}


VOID
host_unsimulate(
    )

/*++

Routine Description:

    This routine causes execution of instructions in a VDM to stop.

Arguments:


Return Value:

    None.

--*/

{
    PVDM_TIB VdmTib;

    VdmTib = (PVDM_TIB)NtCurrentTeb()->Vdm;
    VdmTib->ContinueExecution = FALSE;

}


VOID
EventVdmIo(
    VOID
    )
/*++

Routine Description:

    This function calls the appropriate io simulation routine.

Arguments:


Return Value:

    None.

--*/
{
    PVDM_TIB VdmTib;

    VdmTib = (PVDM_TIB)NtCurrentTeb()->Vdm;
#if defined(NEC_98)
#if DBG
    int i;
    WORD port;
    port = (WORD)VdmTib->EventInfo.IoInfo.PortNumber;
#endif
#endif // NEC_98
    if (VdmTib->EventInfo.IoInfo.Size == 1) {
        if (VdmTib->EventInfo.IoInfo.Read) {
            inb(VdmTib->EventInfo.IoInfo.PortNumber,(half_word *)&(VdmTib->VdmContext.Eax));
#if defined(NEC_98)
#if DBG
            if(fShowIO) {
                for(i=0;i<16;i++)
                    if(port == fshownoport[i])
                        break;
                if(i>=16)
                    DbgPrint("IN  port = %04x, value = %04x\n",
                        port,
                        (half_word)(VdmTib->VdmContext.Eax));
            }
            if(fshowport[0] != 0xffff)
                for(i=0;i<16;i++) {
                    if(port == fshowport[i])
                        DbgPrint("IN  port = %04x, value = %04x\n",
                                port,
                                (half_word)(VdmTib->VdmContext.Eax));
                }
#endif
#endif // NEC_98
        } else {
#if defined(NEC_98)
#if DBG
            if(fShowIO) {
                for(i=0;i<16;i++)
                    if(port == fshownoport[i])
                        break;
                if(i>=16)
                    DbgPrint("OUT port = %04x, value = %04x\n",
                        port,
                        getAL());
            }
            if(fshowport[0] != 0xffff)
                for(i=0;i<16;i++) {
                    if(port == fshowport[i])
                       DbgPrint("OUT port = %04x, value = %04x\n",
                                 port,
                                (half_word)(VdmTib->VdmContext.Eax));
                }
#endif
#endif // NEC_98
            outb(VdmTib->EventInfo.IoInfo.PortNumber,getAL());
        }
    } else if (VdmTib->EventInfo.IoInfo.Size == 2) {
        if (VdmTib->EventInfo.IoInfo.Read) {
            inw(VdmTib->EventInfo.IoInfo.PortNumber,(word *)&(VdmTib->VdmContext.Eax));
#if defined(NEC_98)
#if DBG
            if(fShowIO) {
                for(i=0;i<16;i++)
                    if(port == fshownoport[i])
                        break;
                if(i>=16)
                     DbgPrint("IN  port = %04x, value = %04x\n",
                         port,
                        (word)(VdmTib->VdmContext.Eax));
            }
            if(fshowport[0] != 0xffff)
                for(i=0;i<16;i++) {
                    if(port == fshowport[i])
                        DbgPrint("IN  port = %04x, value = %04x\n",
                                 port,
                                (word)(VdmTib->VdmContext.Eax));
                }
#endif
#endif // NEC_98
        } else {
#if defined(NEC_98)
#if DBG
            if(fShowIO) {
                for(i=0;i<16;i++)
                    if(port == fshownoport[i])
                        break;
                if(i>=16)
                    DbgPrint("OUT port = %04x, value = %04x\n",
                        port,
                        getAX());
            }
            if(fshowport[0] != 0xffff)
                for(i=0;i<16;i++) {
                    if(port == fshowport[i])
                        DbgPrint("OUT port = %04x, value = %04x\n",
                                 port,
                                (word)(VdmTib->VdmContext.Eax));
                }
#endif
#endif // NEC_98
            outw(VdmTib->EventInfo.IoInfo.PortNumber,getAX());
        }
    }
#if DBG
    else {
    DbgPrint(
        "NtVdm: Unimplemented IO size %d\n",
        VdmTib->EventInfo.IoInfo.Size
        );
    DbgBreakPoint();
    }
#endif
}

VOID
EventVdmStringIo(
    VOID
    )
/*++

Routine Description:

    This function calls the appropriate io simulation routine.

Arguments:


Return Value:

    None.

--*/
{
   PVDMSTRINGIOINFO pvsio;
   PUSHORT pIndexRegister;
   USHORT Index;
   PVDM_TIB VdmTib;

   VdmTib = (PVDM_TIB)NtCurrentTeb()->Vdm;

   // WARNING no 32 bit address support

    pvsio = &VdmTib->EventInfo.StringIoInfo;

    if (pvsio->Size == 1) {
        if (pvsio->Read) {
            insb((io_addr)pvsio->PortNumber,
                 (half_word *)Sim32GetVDMPointer(pvsio->Address, 1, ISPESET),
                 (word)pvsio->Count
                 );
            pIndexRegister = (PUSHORT)&VdmTib->VdmContext.Edi;
        } else {
            outsb((io_addr)pvsio->PortNumber,
                 (half_word *)Sim32GetVDMPointer(pvsio->Address,1,ISPESET),
                 (word)pvsio->Count
                 );
            pIndexRegister = (PUSHORT)&VdmTib->VdmContext.Esi;
        }
    } else if (pvsio->Size == 2) {
        if (pvsio->Read) {
            insw((io_addr)pvsio->PortNumber,
                 (word *)Sim32GetVDMPointer(pvsio->Address,1,ISPESET),
                 (word)pvsio->Count
                 );
            pIndexRegister = (PUSHORT)&VdmTib->VdmContext.Edi;
        } else {
            outsw((io_addr)pvsio->PortNumber,
                 (word *)Sim32GetVDMPointer(pvsio->Address,1,ISPESET),
                 (word)pvsio->Count
                 );
            pIndexRegister = (PUSHORT)&VdmTib->VdmContext.Esi;
        }
    } else {
#if DBG
         DbgPrint(
             "NtVdm: Unimplemented IO size %d\n",
             VdmTib->EventInfo.IoInfo.Size
             );
         DbgBreakPoint();
#endif
        return;
    }

    if (getDF()) {
        Index = *pIndexRegister - (USHORT)(pvsio->Count * pvsio->Size);
        }
    else {
        Index = *pIndexRegister + (USHORT)(pvsio->Count * pvsio->Size);
        }

    *pIndexRegister = Index;

    if (pvsio->Rep) {
        (USHORT)VdmTib->VdmContext.Ecx = 0;
        }


}

VOID
EventVdmIntAck(
    VOID
    )
/*++

Routine Description:

    This routine is called each time we have returned to monitor context
    to dispatch interrupts. Its function is to check for AutoEoi and call
    the ica to do a nonspecific eoi, when the ica adapter is in AEOI mode.

Arguments:


Return Value:

    None.

--*/
{
    int line;
    int adapter;
    PVDM_TIB VdmTib;

    VdmTib = (PVDM_TIB)NtCurrentTeb()->Vdm;

    if (VdmTib->EventInfo.IntAckInfo) {
        if (VdmTib->EventInfo.IntAckInfo & VDMINTACK_SLAVE)
            adapter = 1;
        else
            adapter = 0;
        line = -1;

        host_ica_lock();
        ica_eoi(adapter,
                &line,
                (int)(VdmTib->EventInfo.IntAckInfo & VDMINTACK_RAEOIMASK)
                );
        host_ica_unlock();
        }
}


VOID
EventVdmBop(
    VOID
    )
/*++

Routine Description:

    This routine dispatches to the appropriate bop handler

Arguments:


Return Value:

    None.

--*/
{
    PVDM_TIB VdmTib;

    VdmTib = (PVDM_TIB)NtCurrentTeb()->Vdm;
    if (VdmTib->EventInfo.BopNumber > MAX_BOP) {
#if DBG
        DbgPrint(
            "NtVdm: Invalid BOP %lx\n",
            VdmTib->EventInfo.BopNumber
            );
#endif
         VdmTib->ContinueExecution = FALSE;
    } else {

       DBGTRACE(VDMTR_TYPE_MONITOR | MONITOR_EVENT_BOP,
                (USHORT)VdmTib->EventInfo.BopNumber,
                (ULONG)(*((UCHAR *)Sim32GetVDMPointer(
                                   (VdmTib->VdmContext.SegCs << 16) | VdmTib->VdmContext.Eip,
                                   1,
                                   ISPESET)))
                );

       (*BIOS[VdmTib->EventInfo.BopNumber])();
       CurrentMonitorTeb = NtCurrentTeb();
   }
}

VOID
EventVdmError(
    VOID
    )
/*++

Routine Description:

    This routine prints a message(debug only), and exits the vdm

Arguments:


Return Value:

    None.

--*/
{
    PVDM_TIB VdmTib;

    VdmTib = (PVDM_TIB)NtCurrentTeb()->Vdm;
#if DBG
    DbgPrint(
        "NtVdm: Error code %lx\n",
        VdmTib->EventInfo.ErrorStatus
        );
    DbgBreakPoint();
#endif
    TerminateVDM();
    VdmTib->ContinueExecution = FALSE;
}

VOID
EventVdmIrq13(
    VOID
    )
/*++

Routine Description:

    This routine simulates an IRQ 13 to the vdm

Arguments:


Return Value:

    None.

--*/
{
    if (!IRQ13BeingHandled) {
        IRQ13BeingHandled = TRUE;
#if defined(NEC_98)
       if ( getMSW() & MSW_PE )
            ica_hw_interrupt(
                ICA_SLAVE,
                0,
                1
                );
        else
            ica_hw_interrupt(
                ICA_SLAVE,
                6,
                1
                );
#else  // !NEC_98
        ica_hw_interrupt(
            ICA_SLAVE,
            5,
            1
            );
#endif // !NEC_98
    }
}


VOID
EventVdmMemAccess(
    VOID
    )
/*++

Routine Description:

    This routine will call the page fault handler routine which
    is common to both x86 and mips.

Arguments:


Return Value:

    None.

--*/
{

    PVDM_TIB VdmTib;

    VdmTib = (PVDM_TIB)NtCurrentTeb()->Vdm;

    // RWMode is 0 if read fault or 1 if write fault.

    DispatchPageFault(
        VdmTib->EventInfo.FaultInfo.FaultAddr,
        VdmTib->EventInfo.FaultInfo.RWMode
        );
    CurrentMonitorTeb = NtCurrentTeb();
}


// Get and Set routines for intel registers.

ULONG  getEAX (VOID) {
    PVDM_TIB VdmTib;

    VdmTib = (PVDM_TIB)NtCurrentTeb()->Vdm;
    return  (VdmTib->VdmContext.Eax);
}
USHORT getAX  (VOID) {
    PVDM_TIB VdmTib;

    VdmTib = (PVDM_TIB)NtCurrentTeb()->Vdm;
    return  ((USHORT)(VdmTib->VdmContext.Eax));
}
UCHAR  getAL  (VOID) {
    PVDM_TIB VdmTib;

    VdmTib = (PVDM_TIB)NtCurrentTeb()->Vdm;
    return  ((BYTE)(VdmTib->VdmContext.Eax));
}
UCHAR  getAH  (VOID) {
    PVDM_TIB VdmTib;

    VdmTib = (PVDM_TIB)NtCurrentTeb()->Vdm;
    return  ((BYTE)(VdmTib->VdmContext.Eax >> 8));
}
ULONG  getEBX (VOID) {
    PVDM_TIB VdmTib;

    VdmTib = (PVDM_TIB)NtCurrentTeb()->Vdm;
    return  (VdmTib->VdmContext.Ebx);
}
USHORT getBX  (VOID) {
    PVDM_TIB VdmTib;

    VdmTib = (PVDM_TIB)NtCurrentTeb()->Vdm;
    return  ((USHORT)(VdmTib->VdmContext.Ebx));
}
UCHAR  getBL  (VOID) {
    PVDM_TIB VdmTib;

    VdmTib = (PVDM_TIB)NtCurrentTeb()->Vdm;
    return  ((BYTE)(VdmTib->VdmContext.Ebx));
}
UCHAR  getBH  (VOID) {
    PVDM_TIB VdmTib;

    VdmTib = (PVDM_TIB)NtCurrentTeb()->Vdm;
    return  ((BYTE)(VdmTib->VdmContext.Ebx >> 8));
}
ULONG  getECX (VOID) {
    PVDM_TIB VdmTib;

    VdmTib = (PVDM_TIB)NtCurrentTeb()->Vdm;
    return  (VdmTib->VdmContext.Ecx);
}
USHORT getCX  (VOID) {
    PVDM_TIB VdmTib;

    VdmTib = (PVDM_TIB)NtCurrentTeb()->Vdm;
    return  ((USHORT)(VdmTib->VdmContext.Ecx));
}
UCHAR  getCL  (VOID) {
    PVDM_TIB VdmTib;

    VdmTib = (PVDM_TIB)NtCurrentTeb()->Vdm;
    return  ((BYTE)(VdmTib->VdmContext.Ecx));
}
UCHAR  getCH  (VOID) {
    PVDM_TIB VdmTib;

    VdmTib = (PVDM_TIB)NtCurrentTeb()->Vdm;
    return  ((BYTE)(VdmTib->VdmContext.Ecx >> 8));
}
ULONG  getEDX (VOID) {
    PVDM_TIB VdmTib;

    VdmTib = (PVDM_TIB)NtCurrentTeb()->Vdm;
    return  (VdmTib->VdmContext.Edx);
}
USHORT getDX  (VOID) {
    PVDM_TIB VdmTib;

    VdmTib = (PVDM_TIB)NtCurrentTeb()->Vdm;
    return  ((USHORT)(VdmTib->VdmContext.Edx));
}
UCHAR  getDL  (VOID) {
    PVDM_TIB VdmTib;

    VdmTib = (PVDM_TIB)NtCurrentTeb()->Vdm;
    return  ((BYTE)(VdmTib->VdmContext.Edx));
}
UCHAR  getDH  (VOID) {
    PVDM_TIB VdmTib;

    VdmTib = (PVDM_TIB)NtCurrentTeb()->Vdm;
    return  ((BYTE)(VdmTib->VdmContext.Edx >> 8));
}
ULONG  getESP (VOID) {
    PVDM_TIB VdmTib;

    VdmTib = (PVDM_TIB)NtCurrentTeb()->Vdm;
    return  (VdmTib->VdmContext.Esp);
}
USHORT getSP  (VOID) {
    PVDM_TIB VdmTib;

    VdmTib = (PVDM_TIB)NtCurrentTeb()->Vdm;
    return  ((USHORT)VdmTib->VdmContext.Esp);
}
ULONG  getEBP (VOID) {
    PVDM_TIB VdmTib;

    VdmTib = (PVDM_TIB)NtCurrentTeb()->Vdm;
    return  (VdmTib->VdmContext.Ebp);
}
USHORT getBP  (VOID) {
    PVDM_TIB VdmTib;

    VdmTib = (PVDM_TIB)NtCurrentTeb()->Vdm;
    return  ((USHORT)VdmTib->VdmContext.Ebp);
}
ULONG  getESI (VOID) {
    PVDM_TIB VdmTib;

    VdmTib = (PVDM_TIB)NtCurrentTeb()->Vdm;
    return  (VdmTib->VdmContext.Esi);
}
USHORT getSI  (VOID) {
    PVDM_TIB VdmTib;

    VdmTib = (PVDM_TIB)NtCurrentTeb()->Vdm;
    return  ((USHORT)VdmTib->VdmContext.Esi);
}
ULONG  getEDI (VOID) {
    PVDM_TIB VdmTib;

    VdmTib = (PVDM_TIB)NtCurrentTeb()->Vdm;
    return  (VdmTib->VdmContext.Edi);
}
USHORT getDI  (VOID) {
    PVDM_TIB VdmTib;

    VdmTib = (PVDM_TIB)NtCurrentTeb()->Vdm;
    return  ((USHORT)VdmTib->VdmContext.Edi);
}
ULONG  getEIP (VOID) {
    PVDM_TIB VdmTib;

    VdmTib = (PVDM_TIB)NtCurrentTeb()->Vdm;
    return  (VdmTib->VdmContext.Eip);
}
USHORT getIP (VOID)  {
    PVDM_TIB VdmTib;

    VdmTib = (PVDM_TIB)NtCurrentTeb()->Vdm;
    return  ((USHORT)VdmTib->VdmContext.Eip);
}
USHORT getCS (VOID)  {
    PVDM_TIB VdmTib;

    VdmTib = (PVDM_TIB)NtCurrentTeb()->Vdm;
    return  ((USHORT)VdmTib->VdmContext.SegCs);
}
USHORT getSS (VOID)  {
    PVDM_TIB VdmTib;

    VdmTib = (PVDM_TIB)NtCurrentTeb()->Vdm;
    return  ((USHORT)VdmTib->VdmContext.SegSs);
}
USHORT getDS (VOID)  {
    PVDM_TIB VdmTib;

    VdmTib = (PVDM_TIB)NtCurrentTeb()->Vdm;
    return  ((USHORT)VdmTib->VdmContext.SegDs);
}
USHORT getES (VOID)  {
    PVDM_TIB VdmTib;

    VdmTib = (PVDM_TIB)NtCurrentTeb()->Vdm;
    return  ((USHORT)VdmTib->VdmContext.SegEs);
}
USHORT getFS (VOID)  {
    PVDM_TIB VdmTib;

    VdmTib = (PVDM_TIB)NtCurrentTeb()->Vdm;
    return  ((USHORT)VdmTib->VdmContext.SegFs);
}
USHORT getGS (VOID)  {
    PVDM_TIB VdmTib;

    VdmTib = (PVDM_TIB)NtCurrentTeb()->Vdm;
    return  ((USHORT)VdmTib->VdmContext.SegGs);
}
ULONG  getCF (VOID)  {
    PVDM_TIB VdmTib;

    VdmTib = (PVDM_TIB)NtCurrentTeb()->Vdm;
    return  ((VdmTib->VdmContext.EFlags & FLG_CARRY) ? 1 : 0);
}
ULONG  getPF (VOID)  {
    PVDM_TIB VdmTib;

    VdmTib = (PVDM_TIB)NtCurrentTeb()->Vdm;
    return  ((VdmTib->VdmContext.EFlags & FLG_PARITY) ? 1 : 0);
}
ULONG  getAF (VOID)  {
    PVDM_TIB VdmTib;

    VdmTib = (PVDM_TIB)NtCurrentTeb()->Vdm;
    return  ((VdmTib->VdmContext.EFlags & FLG_AUXILIARY) ? 1 : 0);
}
ULONG  getZF (VOID)  {
    PVDM_TIB VdmTib;

    VdmTib = (PVDM_TIB)NtCurrentTeb()->Vdm;
    return  ((VdmTib->VdmContext.EFlags & FLG_ZERO) ? 1 : 0);
}
ULONG  getSF (VOID)  {
    PVDM_TIB VdmTib;

    VdmTib = (PVDM_TIB)NtCurrentTeb()->Vdm;
    return  ((VdmTib->VdmContext.EFlags & FLG_SIGN) ? 1 : 0);
}
ULONG  getTF (VOID)  {
    PVDM_TIB VdmTib;

    VdmTib = (PVDM_TIB)NtCurrentTeb()->Vdm;
    return  ((VdmTib->VdmContext.EFlags & FLG_TRAP) ? 1 : 0);
}
ULONG  getIF (VOID)  {
    PVDM_TIB VdmTib;

    VdmTib = (PVDM_TIB)NtCurrentTeb()->Vdm;
    return  ((VdmTib->VdmContext.EFlags & FLG_INTERRUPT) ? 1 : 0);
}
ULONG  getDF (VOID)  {
    PVDM_TIB VdmTib;

    VdmTib = (PVDM_TIB)NtCurrentTeb()->Vdm;
    return  ((VdmTib->VdmContext.EFlags & FLG_DIRECTION) ? 1 : 0);
}
ULONG  getOF (VOID)  {
    PVDM_TIB VdmTib;

    VdmTib = (PVDM_TIB)NtCurrentTeb()->Vdm;
    return  ((VdmTib->VdmContext.EFlags & FLG_OVERFLOW) ? 1 : 0);
}
USHORT getMSW (VOID) {
    PVDM_TIB VdmTib;

    VdmTib = (PVDM_TIB)NtCurrentTeb()->Vdm;
    return  ((USHORT)VdmTib->IntelMSW);
}
USHORT getSTATUS(VOID){
    PVDM_TIB VdmTib;

    VdmTib = (PVDM_TIB)NtCurrentTeb()->Vdm;
    return (USHORT)VdmTib->VdmContext.EFlags;
}
ULONG  getEFLAGS(VOID) {
    PVDM_TIB VdmTib;

    VdmTib = (PVDM_TIB)NtCurrentTeb()->Vdm;
    return VdmTib->VdmContext.EFlags;
}
USHORT getFLAGS(VOID) {
    PVDM_TIB VdmTib;

    VdmTib = (PVDM_TIB)NtCurrentTeb()->Vdm;
    return (USHORT)VdmTib->VdmContext.EFlags;
}

VOID setEAX (ULONG val) {
    PVDM_TIB VdmTib;

    VdmTib = (PVDM_TIB)NtCurrentTeb()->Vdm;
    VdmTib->VdmContext.Eax = val;
}

VOID setAX  (USHORT val) {
    PVDM_TIB VdmTib;

    VdmTib = (PVDM_TIB)NtCurrentTeb()->Vdm;
    VdmTib->VdmContext.Eax = (VdmTib->VdmContext.Eax & 0xFFFF0000) |
                            ((ULONG)val & 0x0000FFFF);
}

VOID setAH  (UCHAR val) {
    PVDM_TIB VdmTib;

    VdmTib = (PVDM_TIB)NtCurrentTeb()->Vdm;
    VdmTib->VdmContext.Eax = (VdmTib->VdmContext.Eax & 0xFFFF00FF) |
                            ((ULONG)(val << 8) & 0x0000FF00);
}

VOID setAL  (UCHAR val) {
    PVDM_TIB VdmTib;

    VdmTib = (PVDM_TIB)NtCurrentTeb()->Vdm;
    VdmTib->VdmContext.Eax = (VdmTib->VdmContext.Eax & 0xFFFFFF00) |
                            ((ULONG)val & 0x000000FF);
}

VOID setEBX (ULONG val) {
    PVDM_TIB VdmTib;

    VdmTib = (PVDM_TIB)NtCurrentTeb()->Vdm;
    VdmTib->VdmContext.Ebx = val ;
}

VOID setBX  (USHORT val) {
    PVDM_TIB VdmTib;

    VdmTib = (PVDM_TIB)NtCurrentTeb()->Vdm;
    VdmTib->VdmContext.Ebx = (VdmTib->VdmContext.Ebx & 0xFFFF0000) |
                            ((ULONG)val & 0x0000FFFF);
}

VOID setBH  (UCHAR val) {
    PVDM_TIB VdmTib;

    VdmTib = (PVDM_TIB)NtCurrentTeb()->Vdm;
    VdmTib->VdmContext.Ebx = (VdmTib->VdmContext.Ebx & 0xFFFF00FF) |
                            ((ULONG)(val << 8) & 0x0000FF00);
}

VOID setBL  (UCHAR  val) {
    PVDM_TIB VdmTib;

    VdmTib = (PVDM_TIB)NtCurrentTeb()->Vdm;
    VdmTib->VdmContext.Ebx = (VdmTib->VdmContext.Ebx & 0xFFFFFF00) |
                            ((ULONG)val & 0x000000FF);
}

VOID setECX (ULONG val) {
    PVDM_TIB VdmTib;

    VdmTib = (PVDM_TIB)NtCurrentTeb()->Vdm;
    VdmTib->VdmContext.Ecx = val ;
}

VOID setCX  (USHORT val) {
    PVDM_TIB VdmTib;

    VdmTib = (PVDM_TIB)NtCurrentTeb()->Vdm;
    VdmTib->VdmContext.Ecx = (VdmTib->VdmContext.Ecx & 0xFFFF0000) |
                            ((ULONG)val & 0x0000FFFF);
}

VOID setCH  (UCHAR val) {
    PVDM_TIB VdmTib;

    VdmTib = (PVDM_TIB)NtCurrentTeb()->Vdm;
    VdmTib->VdmContext.Ecx = (VdmTib->VdmContext.Ecx & 0xFFFF00FF) |
                            ((ULONG)(val << 8) & 0x0000FF00);
}

VOID setCL  (UCHAR val) {
    PVDM_TIB VdmTib;

    VdmTib = (PVDM_TIB)NtCurrentTeb()->Vdm;
    VdmTib->VdmContext.Ecx = (VdmTib->VdmContext.Ecx & 0xFFFFFF00) |
                            ((ULONG)val & 0x000000FF);
}

VOID setEDX (ULONG val) {
    PVDM_TIB VdmTib;

    VdmTib = (PVDM_TIB)NtCurrentTeb()->Vdm;
    VdmTib->VdmContext.Edx = val ;
}

VOID setDX  (USHORT val) {
    PVDM_TIB VdmTib;

    VdmTib = (PVDM_TIB)NtCurrentTeb()->Vdm;
    VdmTib->VdmContext.Edx = (VdmTib->VdmContext.Edx & 0xFFFF0000) |
                            ((ULONG)val & 0x0000FFFF);
}

VOID setDH  (UCHAR val) {
    PVDM_TIB VdmTib;

    VdmTib = (PVDM_TIB)NtCurrentTeb()->Vdm;
    VdmTib->VdmContext.Edx = (VdmTib->VdmContext.Edx & 0xFFFF00FF) |
                            ((ULONG)(val << 8) & 0x0000FF00);
}

VOID setDL  (UCHAR val) {
    PVDM_TIB VdmTib;

    VdmTib = (PVDM_TIB)NtCurrentTeb()->Vdm;
    VdmTib->VdmContext.Edx = (VdmTib->VdmContext.Edx & 0xFFFFFF00) |
                                ((ULONG)val & 0x000000FF);
}

VOID setESP (ULONG val) {
    PVDM_TIB VdmTib;

    VdmTib = (PVDM_TIB)NtCurrentTeb()->Vdm;
    VdmTib->VdmContext.Esp = val ;
}

VOID setSP  (USHORT val) {
    PVDM_TIB VdmTib;

    VdmTib = (PVDM_TIB)NtCurrentTeb()->Vdm;
    VdmTib->VdmContext.Esp = (VdmTib->VdmContext.Esp & 0xFFFF0000) |
                                ((ULONG)val & 0x0000FFFF);
}

VOID setEBP (ULONG val) {
    PVDM_TIB VdmTib;

    VdmTib = (PVDM_TIB)NtCurrentTeb()->Vdm;
    VdmTib->VdmContext.Ebp = val;
}

VOID setBP  (USHORT val) {
    PVDM_TIB VdmTib;

    VdmTib = (PVDM_TIB)NtCurrentTeb()->Vdm;
    VdmTib->VdmContext.Ebp = (VdmTib->VdmContext.Ebp & 0xFFFF0000) |
                                ((ULONG)val & 0x0000FFFF);
}

VOID setESI (ULONG val) {
    PVDM_TIB VdmTib;

    VdmTib = (PVDM_TIB)NtCurrentTeb()->Vdm;
    VdmTib->VdmContext.Esi = val ;
}

VOID setSI  (USHORT val) {
    PVDM_TIB VdmTib;

    VdmTib = (PVDM_TIB)NtCurrentTeb()->Vdm;
    VdmTib->VdmContext.Esi = (VdmTib->VdmContext.Esi & 0xFFFF0000) |
                                ((ULONG)val & 0x0000FFFF);
}
VOID setEDI (ULONG val) {
    PVDM_TIB VdmTib;

    VdmTib = (PVDM_TIB)NtCurrentTeb()->Vdm;
    VdmTib->VdmContext.Edi = val ;
}

VOID setDI  (USHORT val) {
    PVDM_TIB VdmTib;

    VdmTib = (PVDM_TIB)NtCurrentTeb()->Vdm;
    VdmTib->VdmContext.Edi = (VdmTib->VdmContext.Edi & 0xFFFF0000) |
                                ((ULONG)val & 0x0000FFFF);
}

VOID setEIP (ULONG val) {
    PVDM_TIB VdmTib;

    VdmTib = (PVDM_TIB)NtCurrentTeb()->Vdm;
    VdmTib->VdmContext.Eip = val ;
}

VOID setIP  (USHORT val) {
    PVDM_TIB VdmTib;

    VdmTib = (PVDM_TIB)NtCurrentTeb()->Vdm;
    VdmTib->VdmContext.Eip = (VdmTib->VdmContext.Eip & 0xFFFF0000) |
                                ((ULONG)val & 0x0000FFFF);
}

VOID setCS  (USHORT val) {
    PVDM_TIB VdmTib;

    VdmTib = (PVDM_TIB)NtCurrentTeb()->Vdm;
    VdmTib->VdmContext.SegCs = (ULONG) val & 0x0000FFFF ;
}

VOID setSS  (USHORT val) {
    PVDM_TIB VdmTib;

    VdmTib = (PVDM_TIB)NtCurrentTeb()->Vdm;
    VdmTib->VdmContext.SegSs = (ULONG) val & 0x0000FFFF ;
}

VOID setDS  (USHORT val) {
    PVDM_TIB VdmTib;

    VdmTib = (PVDM_TIB)NtCurrentTeb()->Vdm;
    VdmTib->VdmContext.SegDs = (ULONG) val & 0x0000FFFF ;
}

VOID setES  (USHORT val) {
    PVDM_TIB VdmTib;

    VdmTib = (PVDM_TIB)NtCurrentTeb()->Vdm;
    VdmTib->VdmContext.SegEs = (ULONG) val & 0x0000FFFF ;
}

VOID setFS  (USHORT val) {
    PVDM_TIB VdmTib;

    VdmTib = (PVDM_TIB)NtCurrentTeb()->Vdm;
    VdmTib->VdmContext.SegFs = (ULONG) val & 0x0000FFFF ;
}

VOID setGS  (USHORT val) {
    PVDM_TIB VdmTib;

    VdmTib = (PVDM_TIB)NtCurrentTeb()->Vdm;
    VdmTib->VdmContext.SegGs = (ULONG) val & 0x0000FFFF ;
}

VOID setCF  (ULONG val)  {
    PVDM_TIB VdmTib;

    VdmTib = (PVDM_TIB)NtCurrentTeb()->Vdm;
    VdmTib->VdmContext.EFlags = (VdmTib->VdmContext.EFlags & ~FLG_CARRY) |
                                (((ULONG)val << FLG_CARRY_BIT) & FLG_CARRY);
}

VOID setPF  (ULONG val) {
    PVDM_TIB VdmTib;

    VdmTib = (PVDM_TIB)NtCurrentTeb()->Vdm;
    VdmTib->VdmContext.EFlags = (VdmTib->VdmContext.EFlags & ~FLG_PARITY) |
                                (((ULONG)val << FLG_PARITY_BIT) & FLG_PARITY);
}

VOID setAF  (ULONG val) {
    PVDM_TIB VdmTib;

    VdmTib = (PVDM_TIB)NtCurrentTeb()->Vdm;
    VdmTib->VdmContext.EFlags = (VdmTib->VdmContext.EFlags & ~FLG_AUXILIARY) |
                                (((ULONG)val << FLG_AUXILIARY_BIT) & FLG_AUXILIARY);
}

VOID setZF  (ULONG val) {
    PVDM_TIB VdmTib;

    VdmTib = (PVDM_TIB)NtCurrentTeb()->Vdm;
    VdmTib->VdmContext.EFlags = (VdmTib->VdmContext.EFlags & ~FLG_ZERO) |
                                (((ULONG)val << FLG_ZERO_BIT) & FLG_ZERO);
}

VOID setSF  (ULONG val) {
    PVDM_TIB VdmTib;

    VdmTib = (PVDM_TIB)NtCurrentTeb()->Vdm;
    VdmTib->VdmContext.EFlags = (VdmTib->VdmContext.EFlags & ~FLG_SIGN) |
                                (((ULONG)val << FLG_SIGN_BIT) & FLG_SIGN);
}

VOID setIF  (ULONG val) {
    PVDM_TIB VdmTib;

    VdmTib = (PVDM_TIB)NtCurrentTeb()->Vdm;
    VdmTib->VdmContext.EFlags = (VdmTib->VdmContext.EFlags & ~FLG_INTERRUPT) |
                                (((ULONG)val << FLG_INTERRUPT_BIT) & FLG_INTERRUPT);
}

VOID setDF  (ULONG val) {
    PVDM_TIB VdmTib;

    VdmTib = (PVDM_TIB)NtCurrentTeb()->Vdm;
    VdmTib->VdmContext.EFlags = (VdmTib->VdmContext.EFlags & ~FLG_DIRECTION) |
                                (((ULONG)val << FLG_DIRECTION_BIT) & FLG_DIRECTION);
}

VOID setOF  (ULONG val) {
    PVDM_TIB VdmTib;

    VdmTib = (PVDM_TIB)NtCurrentTeb()->Vdm;
    VdmTib->VdmContext.EFlags = (VdmTib->VdmContext.EFlags & ~FLG_OVERFLOW) |
                                (((ULONG)val << FLG_OVERFLOW_BIT) & FLG_OVERFLOW);
}

VOID setMSW (USHORT val) {
    PVDM_TIB VdmTib;

    VdmTib = (PVDM_TIB)NtCurrentTeb()->Vdm;
    VdmTib->IntelMSW = val ;
}

VOID setSTATUS(USHORT val) {
    PVDM_TIB VdmTib;

    VdmTib = (PVDM_TIB)NtCurrentTeb()->Vdm;
    VdmTib->VdmContext.EFlags = (VdmTib->VdmContext.EFlags & 0xFFFF0000) | val;
}

VOID setEFLAGS(ULONG val) {
    PVDM_TIB VdmTib;

    VdmTib = (PVDM_TIB)NtCurrentTeb()->Vdm;
    VdmTib->VdmContext.EFlags = val;
}

VOID setFLAGS(USHORT val) {
    PVDM_TIB VdmTib;

    VdmTib = (PVDM_TIB)NtCurrentTeb()->Vdm;
    VdmTib->VdmContext.EFlags = (VdmTib->VdmContext.EFlags & 0xFFFF0000) | val;
}
//
// The following is a private register function
//

ULONG getPE(){
    PVDM_TIB VdmTib;

    VdmTib = (PVDM_TIB)NtCurrentTeb()->Vdm;
    return((VdmTib->IntelMSW & MSW_PE) ? 1 : 0);
}


PX86CONTEXT
getIntelRegistersPointer(
    VOID
    )
/*++

Routine Description:

    Return Address on Intel Registers for WOW Fast Access

Arguments:

    None

Return Value:

    Pointer to Intel Registers x86 Context Record


--*/
{
    PVDM_TIB VdmTib;

    VdmTib = (PVDM_TIB)NtCurrentTeb()->Vdm;
    return &(VdmTib->VdmContext);
}



#ifndef NEC_98
BOOLEAN MonitorInitializePrinterInfo(
     WORD   Ports,
     PWORD  PortTable,
     PUCHAR State,
     PUCHAR Control,
     PUCHAR Status,
     PUCHAR HostState)
{
    UCHAR   adapter;
    PVDM_TIB VdmTib;

    VdmTib = (PVDM_TIB)NtCurrentTeb()->Vdm;

    ASSERT (Ports == 3);
    ASSERT (Status != NULL);

    // only do this if the structure has not been initialized -- meaning
    // the pointers can be set once.
    if (NULL == VdmTib->PrinterInfo.prt_Status) {

        VdmTib->PrinterInfo.prt_PortAddr[0] = PortTable[0];
        VdmTib->PrinterInfo.prt_PortAddr[1] = PortTable[1];
        VdmTib->PrinterInfo.prt_PortAddr[2] = PortTable[2];

        VdmTib->PrinterInfo.prt_Handle[0] =
        VdmTib->PrinterInfo.prt_Handle[1] =
        VdmTib->PrinterInfo.prt_Handle[2] = NULL;

        // default mode is kernel simulating status port read
        // mode will be changed if
        // (1). A vdd is hooking printer ports.
        // (2). Dongle mode is detected
        VdmTib->PrinterInfo.prt_Mode[0] =
        VdmTib->PrinterInfo.prt_Mode[1] =
        VdmTib->PrinterInfo.prt_Mode[2] = PRT_MODE_SIMULATE_STATUS_PORT;

        // primarily for dongle
        VdmTib->PrinterInfo.prt_BytesInBuffer[0] =
        VdmTib->PrinterInfo.prt_BytesInBuffer[1] =
        VdmTib->PrinterInfo.prt_BytesInBuffer[2] = 0;

        // primarily for simulating printer status read in kernel
        VdmTib->PrinterInfo.prt_State = State;
        VdmTib->PrinterInfo.prt_Control = Control;
        VdmTib->PrinterInfo.prt_Status = Status;
        VdmTib->PrinterInfo.prt_HostState = HostState;

        //
        // Give the kernel printer emulation an opportunity to cache the
        // pointers
        //
        if (!NT_SUCCESS(NtVdmControl(VdmPrinterInitialize,NULL))) {
           return FALSE;
        }

        return TRUE;
    } else {
            return FALSE;
    }
}

BOOLEAN MonitorEnablePrinterDirectAccess(WORD adapter, HANDLE handle, BOOLEAN Enable)
{
    PVDM_TIB VdmTib;

    VdmTib = (PVDM_TIB)NtCurrentTeb()->Vdm;
    ASSERT(VDM_NUMBER_OF_LPT > adapter);
    if (Enable) {
        // if the adapter has been allocated by a third party VDD,
        // can't do direct io.
        if (PRT_MODE_VDD_CONNECTED != VdmTib->PrinterInfo.prt_Mode[adapter]) {
            VdmTib->PrinterInfo.prt_Mode[adapter] = PRT_MODE_DIRECT_IO;
            VdmTib->PrinterInfo.prt_Handle[adapter] = handle;
            // NtVdmControl(VdmPrinterDirectIoOpen, &adapter);
            return TRUE;
        }
        else
            return FALSE;
    }
    else {
        // disabling direct i/o. reset it back to status port simulation
        if (VdmTib->PrinterInfo.prt_Handle[adapter] == handle) {
            NtVdmControl(VdmPrinterDirectIoClose, &adapter);
            VdmTib->PrinterInfo.prt_Mode[adapter] = PRT_MODE_SIMULATE_STATUS_PORT;
            VdmTib->PrinterInfo.prt_Handle[adapter] = NULL;
            VdmTib->PrinterInfo.prt_BytesInBuffer[adapter] = 0;
            return TRUE;
        }
        else
            return FALSE;
    }
}

BOOLEAN MonitorVddConnectPrinter(WORD Adapter, HANDLE hVdd, BOOLEAN Connect)
{
    PVDM_TIB VdmTib;

    VdmTib = (PVDM_TIB)NtCurrentTeb()->Vdm;
    if (VDM_NUMBER_OF_LPT <= Adapter)
        return FALSE;
    if (Connect) {
        VdmTib->PrinterInfo.prt_Mode[Adapter] = PRT_MODE_VDD_CONNECTED;
        VdmTib->PrinterInfo.prt_Handle[Adapter] = hVdd;
        return TRUE;
    }
    else {
        if (hVdd == VdmTib->PrinterInfo.prt_Handle[Adapter]) {
            VdmTib->PrinterInfo.prt_Mode[Adapter] = PRT_MODE_SIMULATE_STATUS_PORT;
            VdmTib->PrinterInfo.prt_Handle[Adapter] = NULL;
            return TRUE;
        }
        else return FALSE;
    }
}

BOOLEAN MonitorPrinterWriteData(WORD Adapter, BYTE Value)
{
    USHORT BytesInBuffer;
    PVDM_TIB VdmTib;

    VdmTib = (PVDM_TIB)NtCurrentTeb()->Vdm;

    ASSERT(VDM_NUMBER_OF_LPT > Adapter);
    BytesInBuffer = VdmTib->PrinterInfo.prt_BytesInBuffer[Adapter];
    VdmTib->PrinterInfo.prt_Buffer[Adapter][BytesInBuffer] = Value;
    VdmTib->PrinterInfo.prt_BytesInBuffer[Adapter]++;

    return TRUE;
}
#endif // !NEC_98
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\v86\monitor\i386\spcstubs.c ===
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <vdm.h>
#include <stdio.h>
//Tim Nov 92 #include <xt.h>
#include <nt_mon.h> //Tim Nov 92, so it builds...


ULONG cpu_calc_q_ev_inst_for_time(ULONG time){
    return(time);
}

ULONG q_ev_count;

VOID cpu_q_ev_set_count(ULONG time){
    q_ev_count = time;
}
ULONG cpu_q_ev_get_count() {
    return(q_ev_count);
}

char szYodaWarn[]="NtVdm : Using Yoda on an x86 may be hazardous to your systems' health\n";

unsigned char *GDP;

int getCPL(){
    OutputDebugString(szYodaWarn);
    return(0);
}

int getEM(){
    OutputDebugString(szYodaWarn);
    return(0);
}
int getGDT_BASE(){
    OutputDebugString(szYodaWarn);
    return(0);
}
int getGDT_LIMIT(){
    OutputDebugString(szYodaWarn);
    return(0);
}
int getIDT_BASE(){
    OutputDebugString(szYodaWarn);
    return(0);
}
int getIDT_LIMIT(){
    OutputDebugString(szYodaWarn);
    return(0);
}
int getIOPL(){
    OutputDebugString(szYodaWarn);
    return(0);
}
int getLDT_BASE(){
    OutputDebugString(szYodaWarn);
    return(0);
}
int getLDT_LIMIT(){
    OutputDebugString(szYodaWarn);
    return(0);
}
int getLDT_SELECTOR(){
    OutputDebugString(szYodaWarn);
    return(0);
}
int getMP(){
    OutputDebugString(szYodaWarn);
    return(0);
}
int getNT(){
    OutputDebugString(szYodaWarn);
    return(0);
}
int getTR_BASE(){
    OutputDebugString(szYodaWarn);
    return(0);
}
int getTR_LIMIT(){
    OutputDebugString(szYodaWarn);
    return(0);
}
int getTR_SELECTOR(){
    OutputDebugString(szYodaWarn);
    return(0);
}
int getTS(){
    OutputDebugString(szYodaWarn);
    return(0);
}
void setPE(int dummy1){
    OutputDebugString(szYodaWarn);
}
boolean selector_outside_table(word foo, double_word *bar){
    UNREFERENCED_PARAMETER(foo);
    UNREFERENCED_PARAMETER(bar);
    OutputDebugString("NtVdm : Using Yoda on an x86 may be hazardous to your systems' health\n");
    return(0);
}

VOID
EnterIdle(){
}

VOID
LeaveIdle(){
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\v86\monitor\i386\thread.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    Thread.c

Abstract:

    This file contains functions for tracking and manipulating threads

Author:

    Dave Hastings (daveh) 18-Apr-1992

Revision History:

--*/

#include <monitorp.h>
#include <malloc.h>

extern VDM_INTERRUPTHANDLER DpmiInterruptHandlers[];
extern VDM_FAULTHANDLER DpmiFaultHandlers[];

//
// Local Types
//

typedef struct _MonitorThread {
    struct _MonitorThread *Previous;
    struct _MonitorThread *Next;
    PVOID Teb;
    HANDLE Thread;
    VDM_TIB VdmTib;
} MONITORTHREAD, *PMONITORTHREAD;

//
// Local Variables
//

PMONITORTHREAD ThreadList = NULL;          // List of all threads registered

VOID
InitVdmTib(
    PVDM_TIB VdmTib
    )
/*++

Routine Description:

    This routine is used to initialize the VdmTib.

Arguments:

    VdmTib - supplies a pointer to the vdm tib to be initialized

Return Value:

    None.

--*/
{
    VdmTib->IntelMSW = 0;
    VdmTib->VdmContext.SegGs = 0;
    VdmTib->VdmContext.SegFs = 0;
    VdmTib->VdmContext.SegEs = 0;
    VdmTib->VdmContext.SegDs = 0;
    VdmTib->VdmContext.SegCs = 0;
    VdmTib->VdmContext.Eip = 0xFFF0L;
    VdmTib->VdmContext.EFlags = 0x02L | EFLAGS_INTERRUPT_MASK;

    VdmTib->MonitorContext.SegDs = KGDT_R3_DATA | RPL_MASK;
    VdmTib->MonitorContext.SegEs = KGDT_R3_DATA | RPL_MASK;
    VdmTib->MonitorContext.SegGs = 0;
    VdmTib->MonitorContext.SegFs = KGDT_R3_TEB | RPL_MASK;

    VdmTib->PrinterInfo.prt_State       = NULL;
    VdmTib->PrinterInfo.prt_Control     = NULL;
    VdmTib->PrinterInfo.prt_Status      = NULL;
    VdmTib->PrinterInfo.prt_HostState   = NULL;
#ifndef NEC_98
    ASSERT(VDM_NUMBER_OF_LPT == 3);

    VdmTib->PrinterInfo.prt_Mode[0] =
    VdmTib->PrinterInfo.prt_Mode[1] =
    VdmTib->PrinterInfo.prt_Mode[2] = PRT_MODE_NO_SIMULATION;
#endif // !NEC_98

    VdmTib->VdmFaultTable = DpmiFaultHandlers;
    VdmTib->VdmInterruptTable = DpmiInterruptHandlers;

    VdmTib->ContinueExecution = FALSE;
    VdmTib->NumTasks = -1;
    VdmTib->Size = sizeof(VDM_TIB);
}

VOID
cpu_createthread(
    HANDLE Thread,
    PVDM_TIB VdmTib
    )
/*++

Routine Description:

    This routine adds a thread to the list of threads that could be executing
    in application mode.

Arguments:

    Thread -- Supplies a thread handle

    VdmContext -- Supplies a pointer to the VdmContext for the new thread

Return Value:

    None.

--*/
{
    PMONITORTHREAD NewThread, CurrentThread;
    THREAD_BASIC_INFORMATION ThreadInfo;
    HANDLE MonitorThreadHandle;
    NTSTATUS Status;

    //
    // Correctly initialize the floating point context for the thread
    //
    InitialContext.ContextFlags = CONTEXT_FLOATING_POINT;

    if (DebugContextActive)
        InitialContext.ContextFlags |= CONTEXT_DEBUG_REGISTERS;

    Status = NtSetContextThread(
        Thread,
        &InitialContext
        );

    if (!NT_SUCCESS(Status)) {
#if DBG
        DbgPrint("NtVdm terminating : Could not set float context for\n"
                 "                    thread handle 0x%x, status %lx\n", Thread, Status);
        DbgBreakPoint();
#endif
        TerminateVDM();
    }

    //
    // Set up a structure to keep track of the new thread
    //
    NewThread = malloc(sizeof(MONITORTHREAD));

    if (!NewThread) {
#if DBG
        DbgPrint("NTVDM: Could not allocate space for new thread\n");
        DbgBreakPoint();
#endif
        TerminateVDM();
    }
    RtlZeroMemory(NewThread, sizeof(MONITORTHREAD));
    if (VdmTib == NULL) {
        InitVdmTib(&NewThread->VdmTib);
    } else {
        RtlCopyMemory(&NewThread->VdmTib, VdmTib, sizeof(VDM_TIB));
        NewThread->VdmTib.ContinueExecution = FALSE;
        NewThread->VdmTib.NumTasks = -1;
        NewThread->VdmTib.VdmContext.EFlags = 0x02L | EFLAGS_INTERRUPT_MASK;
        NewThread->VdmTib.MonitorContext.EFlags = 0x02L | EFLAGS_INTERRUPT_MASK;
    }

    //
    // Create a handle for the monitor to use
    //

    Status = NtDuplicateObject(
        NtCurrentProcess(),
        Thread,
        NtCurrentProcess(),
        &MonitorThreadHandle,
        0,
        0,
        DUPLICATE_SAME_ACCESS
        );

    if (!NT_SUCCESS(Status)) {
#if DBG
        DbgPrint("NTVDM: Could not duplicate thread handle\n");
        DbgBreakPoint();
#endif
        TerminateVDM();
    }

    NewThread->Thread = MonitorThreadHandle;

    Status = NtQueryInformationThread(
        MonitorThreadHandle,
        ThreadBasicInformation,
        &ThreadInfo,
        sizeof(THREAD_BASIC_INFORMATION),
        NULL
        );

    if (!NT_SUCCESS(Status)) {
#if DBG
        DbgPrint("NTVDM: Could not get thread information\n");
        DbgBreakPoint();
#endif
        TerminateVDM();
    }

    NewThread->Teb = ThreadInfo.TebBaseAddress;
    ((PTEB)(NewThread->Teb))->Vdm = &NewThread->VdmTib;

    //
    // Insert the new thread in the list.  The list is sorted in ascending
    // order of Teb address
    //
    if (!ThreadList) {
        ThreadList = NewThread;
        NewThread->Next = NULL;
        NewThread->Previous = NULL;
        return;
    }

    CurrentThread = ThreadList;
    while ((CurrentThread->Next) && (CurrentThread->Teb < NewThread->Teb)) {
        CurrentThread = CurrentThread->Next;
    }

    if (NewThread->Teb > CurrentThread->Teb) {
        CurrentThread->Next = NewThread;
        NewThread->Previous = CurrentThread;
        NewThread->Next = NULL;
    } else {
        ASSERT((CurrentThread->Teb != NewThread->Teb));
        NewThread->Previous = CurrentThread->Previous;
        NewThread->Next = CurrentThread;
        CurrentThread->Previous = NewThread;
        if (NewThread->Previous) {
            NewThread->Previous->Next = NewThread;
        } else {
            ThreadList = NewThread;
        }
    }
}

VOID
cpu_exitthread(
    VOID
    )
/*++

Routine Description:

    This routine frees the thread tracking information, and closes the thread
    handle

Arguments:


Return Value:

    None.

--*/
{
    PVOID CurrentTeb;
    NTSTATUS Status;
    PMONITORTHREAD ThreadInfo;

    CurrentTeb = NtCurrentTeb();

    ThreadInfo = ThreadList;

    //
    // Find this thread in the list
    //
    while ((ThreadInfo) && (ThreadInfo->Teb != CurrentTeb)) {
        ThreadInfo = ThreadInfo->Next;
    }

    if (!ThreadInfo) {
#if DBG
        DbgPrint("NTVDM: Could not find thread in list\n");
        DbgBreakPoint();
#endif
        return;
    }

    //
    // Close our handle to this thread
    //
    Status = NtClose(ThreadInfo->Thread);
#if DBG
    if (!NT_SUCCESS(Status)) {
        DbgPrint("NTVDM: Could not close thread handle\n");
    }
#endif

    //
    // Remove this thread from the list
    //
    if (ThreadInfo->Previous) {
        ThreadInfo->Previous->Next = ThreadInfo->Next;
    } else {
        ThreadList = ThreadInfo->Next;
    }

    if (ThreadInfo->Next) {
        ThreadInfo->Next->Previous = ThreadInfo->Previous;
    }

    free(ThreadInfo);
}

HANDLE
ThreadLookUp(
    PVOID Teb
    )
/*++

Routine Description:

    This routine returns the handle for the specified thread.

Arguments:

    Teb -- Supplies the teb pointer of the thread

Return Value:

    Returns the handle of the thread, or NULL

--*/
{
    PMONITORTHREAD Thread;

    Thread = ThreadList;

    while ((Thread) && (Thread->Teb != Teb)) {
        Thread = Thread->Next;
    }

    if (Thread) {
        return Thread->Thread;
    } else {
        return NULL;
    }
}

BOOL
ThreadSetDebugContext(
    PULONG pDebugRegisters
    )
/*++

Routine Description:

    This routine sets the debug registers for all the threads that the
    monitor knows about.

Arguments:

    pDebugRegisters -- Pointer to 6 dwords containing the requested debug
                       register contents.

Return Value:

    none

--*/
{
    PMONITORTHREAD Thread;
    NTSTATUS Status;

    Thread = ThreadList;
    InitialContext.ContextFlags = CONTEXT_DEBUG_REGISTERS;

    InitialContext.Dr0 = *pDebugRegisters++;
    InitialContext.Dr1 = *pDebugRegisters++;
    InitialContext.Dr2 = *pDebugRegisters++;
    InitialContext.Dr3 = *pDebugRegisters++;
    InitialContext.Dr6 = *pDebugRegisters++;
    InitialContext.Dr7 = *pDebugRegisters++;

    while (Thread) {

        Status = NtSetContextThread(
            Thread->Thread,
            &InitialContext
            );

        if (!NT_SUCCESS(Status))
            break;

        Thread = Thread->Next;
    }

    if (!NT_SUCCESS(Status))
        return (FALSE);
    else {
        DebugContextActive = ((InitialContext.Dr7 & 0x0f) != 0);
        return (TRUE);
    }

}

BOOL
ThreadGetDebugContext(
    PULONG pDebugRegisters
    )
/*++

Routine Description:

    This routine gets the debug registers for the current thread.

Arguments:

    pDebugRegisters -- Pointer to 6 dwords to receive the debug
                       register contents.

Return Value:

    none

--*/
{
    CONTEXT CurrentContext;
    NTSTATUS Status;

    CurrentContext.ContextFlags = CONTEXT_DEBUG_REGISTERS;

    Status = NtGetContextThread(NtCurrentThread(), &CurrentContext);

    if (!NT_SUCCESS(Status)) {
        return FALSE;
    }

    *pDebugRegisters++ = CurrentContext.Dr0;
    *pDebugRegisters++ = CurrentContext.Dr1;
    *pDebugRegisters++ = CurrentContext.Dr2;
    *pDebugRegisters++ = CurrentContext.Dr3;
    *pDebugRegisters++ = CurrentContext.Dr6;
    *pDebugRegisters++ = CurrentContext.Dr7;
    return (TRUE);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\v86\scaffold\i386\fakebop.c ===
#include <windows.h>
#include <stdio.h>
#include <conio.h>
#include "demexp.h"
#include "cmdsvc.h"
#include "rdrexp.h"
#include "dbgexp.h"
#include "softpc.h"
#include "fun.h"
//
// This module contains the fake function definitions for bop functions
//

extern CONTEXT IntelRegisters;
extern VOID switch_to_real_mode();
extern VOID host_unsimulate();


HANDLE hWOWDll;

FARPROC WOWDispatchEntry;
FARPROC WOWInitEntry;

void DBGDispatch( void );

void reset(){}
void dummy_int(){}
void unexpected_int(){}
void illegal_bop(){}
void print_screen(){}
void time_int(){}
void keyboard_int(){}
void diskette_int(){}
void video_io(){}
void equipment(){}
void memory_size(){}
void disk_io(){}
void rs232_io(){}
void cassette_io(){}
void keyboard_io(){}
void printer_io(){}
void rom_basic(){}
void bootstrap(){}
void time_of_day(){}
void critical_region(){}
void cmd_install(){}
void cmd_load(){}
void redirector(){}
void ega_video_io(){}
void MsBop0(){

    DemDispatch((ULONG)(*Sim32GetVDMPointer(
        ((ULONG)getCS() << 16) + (getIP()), 1, FALSE)));
    setIP(getIP() + 1);

}
void MsBop1(){


    static WowModeInitialized = FALSE;

    if (!WowModeInitialized) {

        // Load the WOW DLL
        if ((hWOWDll = LoadLibrary ("WOW32")) == NULL){
            VDprint(
                VDP_LEVEL_ERROR,
                ("SoftPC: error initializing WOW\n")
                );
            TerminateVDM();
            return;
        }

       // Get the init entry point and dispatch entry point
       if ((WOWInitEntry = GetProcAddress (hWOWDll, "W32Init")) == NULL) {
            VDprint(
                VDP_LEVEL_ERROR,
                ("SoftPC: error initializing WOW\n")
               );
            FreeLibrary (hWOWDll);
            TerminateVDM();
            return;
       }

       if ((WOWDispatchEntry = GetProcAddress (hWOWDll, "W32Dispatch")) == NULL) {
            VDprint(
                VDP_LEVEL_ERROR,
                ("SoftPC: error initializing WOW\n")
                );
            FreeLibrary (hWOWDll);
            TerminateVDM();
            return;
       }

       // Call the Init Routine
       if ((*WOWInitEntry)() == FALSE) {
            VDprint(
                VDP_LEVEL_ERROR,
                ("SoftPC: error initializing WOW\n")
                );
            TerminateVDM();
            return;
       }

       WowModeInitialized = TRUE;
    }

    (*WOWDispatchEntry)();
}

void MsBop2(){

    XMSDispatch((ULONG)(*Sim32GetVDMPointer(
        ((ULONG)getCS() << 16) + (getIP()), 1, FALSE)));
    setIP(getIP() + 1);

}
void MsBop3(){
   DpmiDispatch();
}



void MsBop4(){
    CmdDispatch((ULONG)(*Sim32GetVDMPointer(
        ((ULONG)getCS() << 16) + (getIP()), 1, FALSE)));
    setIP(getIP() + 1);
}



//
// MsBop5 - used to dispatch to Vdm Redir (Vr) support functions
//

void MsBop5()
{
#ifdef NTVDM_NET_SUPPORT
    VrDispatch((ULONG)(*Sim32GetVDMPointer(
        ((ULONG)getCS() << 16) + (getIP()), 1, FALSE)));
    setIP(getIP() + 1);
#endif
}

//
// MsBop6 - used to dispatch to debugger support functions
//

void MsBop6()
{
    /*
    ** All of the parameters for the debugger support
    ** should be on the VDMs stack.
    */
    DBGDispatch();
}
void MsBop7(){}
void MsBop8(){}
void MsBop9(){}
void MsBopA(){}
void MsBopB(){

    switch (getAH()) {

        case 0 :
            setAH(0);
        while (!tkbhit());
        setAL((BYTE)tgetch());
            break;

        case 1 :
        tputch(getAL());
            break;
    }
}
void MsBopC(){

    BiosKbd();

}
void MsBopD(){

    BiosVid();

}
void MsBopE(){}


void MsBopF(){
    UCHAR *Instruction;
    USHORT i;

    // Unimplemented interrupt bop

    Instruction = RMSEGOFFTOLIN(getSS(), getSP());
    Instruction = RMSEGOFFTOLIN(*((PWORD)Instruction + 1),
     *(PWORD)(Instruction));
    i = (USHORT)(*(Instruction - 1));
    VDprint(
        VDP_LEVEL_WARNING,
        ("SoftPC Bop Support: Unimplemented Interrupt %x\n",
        i)
        );

}
void emm_init(){}
void emm_io(){}
void return_from_call(){}
void rtc_int(){}
void re_direct(){}
void D11_int(){}
void int_287(){}
void worm_init(){}
void worm_io(){}
void ps_private_1(){}
void ps_private_2(){}
void ps_private_3(){}
void ps_private_4(){}
void ps_private_5(){}
void ps_private_6(){}
void ps_private_7(){}
void ps_private_8(){}
void ps_private_9(){}
void ps_private_10(){}
void ps_private_11(){}
void ps_private_12(){}
void ps_private_13(){}
void ps_private_14(){}
void ps_private_15(){}
void bootstrap1(){}
void bootstrap2(){}
void bootstrap3(){}
void ms_windows(){}
void msw_mouse(){}
void mouse_install1(){}
void mouse_install2(){}
void mouse_int1(){}
void mouse_int2(){}
void mouse_io_language(){}
void mouse_io_interrupt(){}
void mouse_video_io(){}
void control_bop(){}
void diskette_io(){}
void illegal_op_int(){}

VOID (*BIOS[])(VOID) = { reset,
                                    dummy_int,
                                    unexpected_int,
                                    illegal_bop,
                                    illegal_bop,
                                    print_screen,
                                    illegal_op_int,
                                    illegal_bop,
                                    time_int,
                                    keyboard_int,
                                    illegal_bop,
                                    illegal_bop,
                                    illegal_bop,
                                    illegal_bop,
                                    diskette_int,
                                    illegal_bop,
                                    video_io,
                                    equipment,
                                    memory_size,
                                    disk_io,
                                    rs232_io,
                                    cassette_io,
                                    keyboard_io,
                                    printer_io,
                                    rom_basic,
                                    bootstrap,
                                    time_of_day,
                                    illegal_bop,
                                    illegal_bop,
                                    illegal_bop,
                                    illegal_bop,
                                    illegal_bop,
                                    illegal_bop,
                                    illegal_bop,
                                    illegal_bop,
                                    illegal_bop,
                                    illegal_bop,
                                    illegal_bop,
                                    illegal_bop,
                                    illegal_bop,
                                    illegal_bop,
                                    illegal_bop,
                                    critical_region,
                                    cmd_install,
                                    cmd_load,
                                    illegal_bop,
                                    illegal_bop,
                                    redirector,
                                    illegal_bop,
                                    illegal_bop,
                                    illegal_bop,
                                    illegal_bop,
                                    illegal_bop,
                                    illegal_bop,
                                    illegal_bop,
                                    illegal_bop,
                                    illegal_bop,
                                    illegal_bop,
                                    illegal_bop,
                                    illegal_bop,
                                    illegal_bop,
                                    illegal_bop,
                                    illegal_bop,
                                    illegal_bop,
                                    diskette_io,
                                    illegal_bop,
                                    ega_video_io,
                                    illegal_bop,
                                    illegal_bop,
                                    illegal_bop,
                                    illegal_bop,
                                    illegal_bop,
                                    illegal_bop,
                                    illegal_bop,
                                    illegal_bop,
                                    illegal_bop,
                                    illegal_bop,
                                    illegal_bop,
                                    illegal_bop,
                                    illegal_bop,
                                    MsBop0,
                                    MsBop1,
                                    MsBop2,
                                    MsBop3,
                                    MsBop4,
                                    MsBop5,
                                    MsBop6,
                                    MsBop7,
                                    MsBop8,
                                    MsBop9,
                                    MsBopA,
                                    MsBopB,
                                    MsBopC,
                                    MsBopD,
                                    MsBopE,
                                    MsBopF,
                                    illegal_bop,
                                    illegal_bop,
                                    illegal_bop,
                                    illegal_bop,
                                    illegal_bop,
                                    illegal_bop,
                                    emm_init,
                                    emm_io,
                                    return_from_call,
                                    illegal_bop,
                                    illegal_bop,
                                    illegal_bop,
                                    illegal_bop,
                                    illegal_bop,
                                    illegal_bop,
                                    illegal_bop,
                                    rtc_int,
                                    re_direct,
                                    D11_int,
                                    D11_int,
                                    D11_int,
                                    int_287,
                                    D11_int,
                                    D11_int,
                                    worm_init,
                                    worm_io,
                                    illegal_bop,
                                    illegal_bop,
                                    illegal_bop,
                                    illegal_bop,
                                    illegal_bop,
                                    illegal_bop,
                                    ps_private_1,
                                    ps_private_2,
                                    ps_private_3,
                                    ps_private_4,
                                    ps_private_5,
                                    ps_private_6,
                                    ps_private_7,
                                    ps_private_8,
                                    ps_private_9,
                                    ps_private_10,
                                    ps_private_11,
                                    ps_private_12,
                                    ps_private_13,
                                    ps_private_14,
                                    ps_private_15,
                                    illegal_bop,
                                    bootstrap1,
                                    bootstrap2,
                                    bootstrap3,
                                    illegal_bop,
                                    illegal_bop,
                                    illegal_bop,
                                    illegal_bop,
                                    illegal_bop,
                                    ms_windows,
                                    msw_mouse,
                                    illegal_bop,
                                    illegal_bop,
                                    illegal_bop,
                                    illegal_bop,
                                    illegal_bop,
                                    illegal_bop,
                                    illegal_bop,
                                    illegal_bop,
                                    illegal_bop,
                                    illegal_bop,
                                    illegal_bop,
                                    illegal_bop,
                                    illegal_bop,
                                    illegal_bop,
                                    illegal_bop,
                                    illegal_bop,
                                    illegal_bop,
                                    illegal_bop,
                                    illegal_bop,
                                    illegal_bop,
                                    illegal_bop,
                                    illegal_bop,
                                    illegal_bop,
                                    illegal_bop,
                                    illegal_bop,
                                    illegal_bop,
                                    illegal_bop,
                                    illegal_bop,
                                    illegal_bop,
                                    illegal_bop,
                                    mouse_install1,
                                    mouse_install2,
                                    mouse_int1,
                                    mouse_int2,
                                    mouse_io_language,
                                    mouse_io_interrupt,
                                    mouse_video_io,
                                    illegal_bop,
                                    illegal_bop,
                                    illegal_bop,
                                    illegal_bop,
                                    illegal_bop,
                                    illegal_bop,
                                    illegal_bop,
                                    illegal_bop,
                                    illegal_bop,
                                    illegal_bop,
                                    illegal_bop,
                                    illegal_bop,
                                    illegal_bop,
                                    illegal_bop,
                                    illegal_bop,
                                    illegal_bop,
                                    illegal_bop,
                                    illegal_bop,
                                    illegal_bop,
                                    illegal_bop,
                                    illegal_bop,
                                    illegal_bop,
                                    illegal_bop,
                                    illegal_bop,
                                    illegal_bop,
                                    illegal_bop,
                                    illegal_bop,
                                    illegal_bop,
                                    illegal_bop,
                                    illegal_bop,
                                    illegal_bop,
                                    illegal_bop,
                                    illegal_bop,
                                    illegal_bop,
                                    illegal_bop,
                                    illegal_bop,
                                    illegal_bop,
                                    illegal_bop,
                                    illegal_bop,
                                    illegal_bop,
                                    illegal_bop,
                                    illegal_bop,
                                    illegal_bop,
                                    illegal_bop,
                                    illegal_bop,
                                    illegal_bop,
                                    illegal_bop,
                                    illegal_bop,
                                    illegal_bop,
                                    illegal_bop,
                                    illegal_bop,
                                    illegal_bop,
                                    illegal_bop,
                                    illegal_bop,
                                    illegal_bop,
                                    illegal_bop,
                                    illegal_bop,
                                    illegal_bop,
                                    illegal_bop,
                                    illegal_bop,
                                    illegal_bop,
                                    illegal_bop,
                                    switch_to_real_mode,
                                    host_unsimulate,
                                    control_bop };
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\v86\scaffold\i386\fakeinit.c ===
//
// Fake Bios support initialization.
//
// This file provides interrim support for rom bios services initialization.
// It is only intended for use until Insignia produces proper rom support
// for NTVDM
//

#include <windows.h>
#include <stdio.h>
#include <conio.h>
#include <string.h>
#include "softpc.h"
#include "bop.h"
#include "xguest.h"
#include "xbios.h"
#include "xbiosdsk.h"
#include "fun.h"

#define SERVICE_LENGTH 4
static BYTE ServiceRoutine[] = { 0xC4 , 0xC4, BOP_UNIMPINT, 0xCF };

#define RESET_LENGTH 16
static BYTE ResetRoutine[] = { 0xEA, 0x00, 0x00, 0x00, 0xE0, // jmpf E000:0
                               BIOSDATE_MINE,
                               0, 0xFE, 0 };

static BYTE WarmBoot[] = {
    OPX_MOVAX,      BYTESOFFSET(0x30),
    OPX_MOV2SEG,    MODREGRM(MOD_REGISTER,REG_SS,REG_AX),
    OPX_MOVSP,      BYTESOFFSET(0x100),
    OPX_MOVAX,      0x00, 0x00,
    OPX_MOV2SEG,    MODREGRM(MOD_REGISTER,REG_DS,REG_AX),
    OPX_MOV2SEG,    MODREGRM(MOD_REGISTER,REG_ES,REG_AX),
    OPX_MOVDX,      DRIVE_FD0, 0x00,    // WARNING: sync with BIOSBOOT_DRIVE
    OPX_MOVCX,      0x01, 0x00,
    OPX_MOVBX,      BYTESOFFSET(BIOSDATA_BOOT),
    OPX_MOVAX,      0x01, DSKFUNC_READSECTORS,
    OPX_INT,        BIOSINT_DSK,
    OPX_JB,         -7,
    OPX_JMPF,       BYTESCOMPOSITE(0, BIOSDATA_BOOT)
};
#define WARMBOOT_LENGTH sizeof(WarmBoot)

static BYTE EquipmentRoutine[] = {   // INT 11h code
    OPX_PUSHDS,
    OPX_MOVAX,      0x00, 0x00,
    OPX_MOV2SEG,    MODREGRM(MOD_REGISTER,REG_DS,REG_AX),
    OPX_MOVAXOFF,   BYTESOFFSET(BIOSDATA_EQUIP_FLAG),
    OPX_POPDS,
    OPX_IRET
};
#define EQUIPMENT_LENGTH sizeof(EquipmentRoutine)

static BYTE MemoryRoutine[] = {      // INT 12h code
    OPX_PUSHDS,
    OPX_MOVAX,      0x00, 0x00,
    OPX_MOV2SEG,    MODREGRM(MOD_REGISTER,REG_DS,REG_AX),
    OPX_MOVAXOFF,   BYTESOFFSET(BIOSDATA_MEMORY_SIZE),
    OPX_POPDS,
    OPX_IRET
};
#define MEMORY_LENGTH sizeof(MemoryRoutine)


VOID BiosInit(int argc, char *argv[]) {

    PVOID Address, RomAddress;

    // set up IVT with unimplemented interrupt handler

    for (Address = NULL; Address < (PVOID)(0x1D * 4); (PCHAR)Address += 4) {
        *(PWORD)Address = 0x100;
        *(((PWORD)Address) + 1) = 0xF000;
    }

    RomAddress = (PVOID)(0xE000 << 4);

    // set up warm boot handler
    memcpy(RomAddress, WarmBoot, WARMBOOT_LENGTH);
    Address = RMSEGOFFTOLIN(0, BIOSINT_WBOOT * 4);
    *((PWORD)Address) = 0;
    *((PWORD)Address + 1) = 0xE000;
    (PCHAR)RomAddress += WARMBOOT_LENGTH;

    // set up equipment interrupt handler
    memcpy(RomAddress, EquipmentRoutine, EQUIPMENT_LENGTH);
    Address = RMSEGOFFTOLIN(0, BIOSINT_EQUIP * 4);
    *((PWORD)Address) = RMOFF(RomAddress);
    *((PWORD)Address + 1) = RMSEG(RomAddress);
    (PCHAR)RomAddress += EQUIPMENT_LENGTH;

    // set up memory size interrupt handler
    memcpy(RomAddress, MemoryRoutine, MEMORY_LENGTH);
    Address = RMSEGOFFTOLIN(0, BIOSINT_MEMORY * 4);
    *((PWORD)Address) = RMOFF(RomAddress);
    *((PWORD)Address + 1) = RMSEG(RomAddress);
 
    RomAddress = (PVOID)((0xF000 << 4) + 0x100);

    Address = (PBYTE)RomAddress + 0xFE53;
    *(PCHAR)Address = 0xCF;         // IRET at f000:ff53

    // set up unimplemented interrupt handler

    memcpy(RomAddress, ServiceRoutine, SERVICE_LENGTH);
    (PCHAR)RomAddress += SERVICE_LENGTH;

    // set up reset code
    memcpy(RMSEGOFFTOLIN(BIOSROM_SEG, BIOSROM_RESET), ResetRoutine, RESET_LENGTH);

    // set up equipment byte and memory size

    *(PWORD)RMSEGOFFTOLIN(BIOSDATA_SEG, BIOSDATA_EQUIP_FLAG) = 
        BIOSEQUIP_32KPLANAR;
    *(PWORD)RMSEGOFFTOLIN(BIOSDATA_SEG, BIOSDATA_MEMORY_SIZE) = 
        640;
    
    // Initialize individual rom modules

    BiosKbdInit(argc, argv, &RomAddress);
    BiosVidInit(argc, argv, &RomAddress);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\v86\scaffold\i386\fakevid.c ===
//
// Fake video rom support 
// 
// This file provides interrim support for video rom bios services.
// It is only intended for use until Insignia produces proper rom support
// for NTVDM
//
// Note: portions of this code were lifted from the following source.


/* x86 v1.0
 *
 * XBIOSVID.C
 * Guest ROM BIOS video emulation
 *
 * History
 * Created 20-Oct-90 by Jeff Parsons
 *
 * COPYRIGHT NOTICE
 * This source file may not be distributed, modified or incorporated into
 * another product without prior approval from the author, Jeff Parsons.
 * This file may be copied to designated servers and machines authorized to
 * access those servers, but that does not imply any form of approval.
 */

#include <windows.h>
#include <stdio.h>
#include <string.h>
#include <conio.h>
#include "softpc.h"
#include "bop.h"
#include "xbios.h"
#include "xbiosvid.h"
#include "xwincon.h"
#include "fun.h"
#include "cmdsvc.h"

static BYTE ServiceRoutine[] = { 0xC4, 0xC4, BOP_VIDEO, 0x50, 0x55, 0x8B,
    0xEC, 0x9C, 0x58, 0x89, 0x46, 0x08, 0x5d, 0x58, 0xCF };
#define SERVICE_LENGTH sizeof(ServiceRoutine)

extern	HANDLE OutputHandle;
extern	HANDLE InputHandle;

/* BiosVidInit - Initialize ROM BIOS video support
 *
 * ENTRY
 *  argc - # of command-line options
 *  argv - pointer to first option pointer
 *  ServicAddress - pointer to linear address to put interrupt service 
 *      routine at
 *
 * EXIT
 *  TRUE if successful, FALSE if not
 */

BOOL BiosVidInit(int argc, char *argv[], PVOID *ServiceAddress)
{
    USHORT usEquip;

    static BYTE abVidInit[] = {VIDMODE_MONO,	    // VIDDATA_CRT_MODE
                               0x80, 0,             // VIDDATA_CRT_COLS
                               00, 0x10,            // VIDDATA_CRT_LEN
                               0, 0,        	    // VIDDATA_CRT_START
                               0,0,0,0,0,0,0,0,     // VIDDATA_CURSOR_POSN
                               0,0,0,0,0,0,0,0,     //
                               7, 6,		        // VIDDATA_CURSOR_MODE
                               0,		            // VIDDATA_ACTIVE_PAGE
                               0xD4, 0x03,          // VIDDATA_ADDR_6845
                               0,		            // VIDDATA_CRT_MODE_SET
                               0,		            // VIDDATA_CRT_PALETTE
    };
    PVOID Address;
    
    argv, argc;
    memcpy(*ServiceAddress, ServiceRoutine, SERVICE_LENGTH);

    Address = (PVOID)(BIOSINT_VID * 4);
    *((PWORD)Address) = RMOFF(*ServiceAddress);
    *(((PWORD)Address) + 1) = RMSEG(*ServiceAddress);
    (PCHAR)*ServiceAddress += SERVICE_LENGTH;

    usEquip = *(PWORD)RMSEGOFFTOLIN(BIOSDATA_SEG, BIOSDATA_EQUIP_FLAG);
    usEquip |= BIOSEQUIP_MONOVIDEO;
    *(PWORD)RMSEGOFFTOLIN(BIOSDATA_SEG, BIOSDATA_EQUIP_FLAG) = usEquip;

    // Initialize ROM BIOS video data to defaults
    Address = RMSEGOFFTOLIN(BIOSDATA_SEG, VIDDATA_CRT_MODE);
    memcpy(Address, abVidInit, sizeof(abVidInit));

#if 0
#ifdef WIN
    clearconsole(hwndGuest);
#endif
#endif
    return TRUE;
}

 
/* BiosVid - Emulate ROM BIOS video functions
 *
 * ENTRY
 *  None (x86 registers contain parameters)
 *
 * EXIT
 *  None (x86 registers/memory updated appropriately)
 *
 * This function receives control on INT 10h, routes control to the
 * appropriate subfunction based on the function # in AH, and
 * then simulates an IRET and returns back to the instruction emulator.
 */

VOID BiosVid()
{
COORD coord;
CHAR  ch;

    if (fEnableInt10 == FALSE)
	return;

    switch(getAH()) {
	case VIDFUNC_SETCURSORPOS:
	    coord.X = getDL();
	    coord.Y = getDH();
	    if(SetConsoleCursorPosition(OutputHandle, coord) == FALSE)
		VDprint(
		   VDP_LEVEL_WARNING,
		   ("SetCursorPosition Failed X=%d Y=%d\n",
		   coord.X,coord.Y)
		   );
	    break;
        case VIDFUNC_QUERYCURSORPOS:
            VDprint(
                VDP_LEVEL_WARNING, 
		("Query Cursor Position Not Yet Implemented\n")
		);
	    break;
        case VIDFUNC_SCROLLUP:
            VDprint(
                VDP_LEVEL_WARNING, 
		("ScrollUp Not Yet Implemented\n")
		);
	    break;
        case VIDFUNC_WRITECHARATTR:
            VDprint(
                VDP_LEVEL_WARNING, 
		("WRITECHARATTR Not Yet Implemented\n")
		);
	    break;
	case VIDFUNC_WRITETTY:
	    ch = getAL();
	    putch(ch);
	    break;

        case VIDFUNC_QUERYMODE:
            setAX(*(PWORD)RMSEGOFFTOLIN(BIOSDATA_SEG, VIDDATA_CRT_MODE));
            setBX(*(PWORD)RMSEGOFFTOLIN(BIOSDATA_SEG, VIDDATA_ACTIVE_PAGE));
	    break;

        default:
            VDprint(
                VDP_LEVEL_WARNING, 
                ("SoftPC Video Support: Unimplemented function %x\n",
                getAX())
		);
    }
}


INT tputch(INT i)
{
    putch((CHAR)i);
    return i;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\v86\scaffold\i386\fun.h ===
//
// function definitions for scaffolding code
//

VOID BiosInit(int argc, char *argv[]);
BOOL WinInit();
VOID DbgPrint();
VOID DbgBreakPoint();
BOOL W32Init();
VOID main();
VOID exit();
BOOL BiosKbdInit(int argc, char *argv[], PVOID *ServiceAddress);
BOOL BiosDskInit(int argc, char *argv[], PVOID *ServiceAddress);
BOOL BiosVidInit(int argc, char *argv[], PVOID *ServiceAddress);
VOID W32Dispatch();
VOID XMSDispatch();
VOID BiosVid();
VOID BiosKbd();
VOID BiosDsk();
VOID BiosKbdReadLoop (VOID);
BOOL tkbhit(VOID);
CHAR tgetch(VOID);
INT tputch(INT);
VOID FixConfigFile (PSZ,BOOL);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\v86\scaffold\i386\fakekbd.c ===
//
// Fake Keyboard rom support 
// 
// This file provides interrim support for keyboard rom bios services.
// It is only intended for use until Insignia produces proper rom support
// for NTVDM
//
// Note: portions of this code were lifted from the following source.

/* x86 v1.0
 *
 * XBIOSKBD.C
 * Guest ROM BIOS keyboard emulation
 *
 * History
 * Created 20-Oct-90 by Jeff Parsons
 *
 * COPYRIGHT NOTICE
 * This source file may not be distributed, modified or incorporated into
 * another product without prior approval from the author, Jeff Parsons.
 * This file may be copied to designated servers and machines authorized to
 * access those servers, but that does not imply any form of approval.
 */

#include <windows.h>
#include <stdio.h>
#include <conio.h>
#include <string.h>
#include "softpc.h"
#include "bop.h"
#include "xbios.h"
#include "xbioskbd.h"
#include "xwincon.h"
#include "fun.h"
#include <conapi.h>

extern HANDLE InputHandle;

#define MAX_KBD_BUFFER 256
CHAR	KbdBuffer[MAX_KBD_BUFFER];
ULONG	Head=0,Tail=0;
HANDLE	KbdSyncEvent;
CRITICAL_SECTION csKbd;
CRITICAL_SECTION csConsole;
CRITICAL_SECTION csCtrlc;
BOOL	fEventThreadBlock = FALSE;
HANDLE	hConsoleWait;
ULONG  nCtrlc=0;

HANDLE StdIn;

static BYTE ServiceRoutine[] = { 0xC4, 0xC4, BOP_KBD, 0x50, 0x55, 0x8B,
    0xEC, 0x9C, 0x58, 0x89, 0x46, 0x08, 0x5d, 0x58, 0xCF };
#define SERVICE_LENGTH sizeof(ServiceRoutine)

/* BiosKbdInit - Initialize ROM BIOS keyboard support
 *
 * ENTRY
 *  argc - # of command-line options
 *  argv - pointer to first option pointer
 *  ServiceAddress - linear address to put service routine at
 *
 * EXIT
 *  TRUE if successful, FALSE if not
 */

BOOL BiosKbdInit(int argc, char *argv[], PVOID *ServiceAddress)
{
    PVOID Address;
    
    argc, argv;

    memcpy(*ServiceAddress, ServiceRoutine, SERVICE_LENGTH);

    Address = (PVOID)(BIOSINT_KBD * 4);
    *((PWORD)Address) = RMOFF(*ServiceAddress);
    *(((PWORD)Address) + 1) = RMSEG(*ServiceAddress);
    (PCHAR)*ServiceAddress += SERVICE_LENGTH;

    StdIn = GetStdHandle(STD_INPUT_HANDLE);

    KbdSyncEvent = CreateEvent( NULL, TRUE, FALSE,NULL );

    InitializeCriticalSection (&csKbd);
    InitializeCriticalSection(&csConsole);
    InitializeCriticalSection(&csCtrlc);

    hConsoleWait = CreateEvent (NULL,TRUE,FALSE,NULL);

    return TRUE;
}


/* BiosKbd - Emulate ROM BIOS keyboard functions
 *
 * ENTRY
 *  None (x86 registers contain parameters)
 *
 * EXIT
 *  None (x86 registers/memory updated appropriately)
 *
 * This function receives control on INT 16h, routes control to the
 * appropriate subfunction based on the function # in AH, and
 * then simulates an IRET and returns back to the instruction emulator.
 */

VOID BiosKbdReadLoop (VOID)
{
ULONG Temp;

    while (1) {

	Temp = Head + 1;
	if(Temp >= MAX_KBD_BUFFER)
	    Temp =0;
	if(Temp == Tail){
	    Sleep (20);
	    continue;
	}

	KbdBuffer[Head] = getche();

	EnterCriticalSection(&csConsole);
	if(fEventThreadBlock == TRUE){
	    LeaveCriticalSection(&csConsole);
	    WaitForSingleObject(hConsoleWait,-1);
	    ResetEvent(hConsoleWait);
	    continue;
	}
	else{
	    LeaveCriticalSection(&csConsole);
	}

	EnterCriticalSection(&csKbd);
	Head = Temp;
	LeaveCriticalSection(&csKbd);
	SetEvent(KbdSyncEvent);
    }
}

BOOL tkbhit(VOID)
{

    if (Tail != Head || nCtrlc)
            return TRUE;
    return FALSE;
}


CHAR tgetch(VOID)
{
CHAR ch;

    while(TRUE) {
	EnterCriticalSection(&csCtrlc);
	if (nCtrlc){
	    nCtrlc--;
	    LeaveCriticalSection(&csCtrlc);
	    return (CHAR)0x3;	    // return ctrlc
	}
	LeaveCriticalSection(&csCtrlc);

	if (Tail != Head) {
	    EnterCriticalSection(&csKbd);
	    ch = KbdBuffer[Tail++];
	    if (Tail >= MAX_KBD_BUFFER)
		Tail = 0;
	    LeaveCriticalSection(&csKbd);
	    return ch;
	}
	WaitForSingleObject(KbdSyncEvent, -1);
	ResetEvent(KbdSyncEvent);
    }
}




VOID BiosKbd()
{
    static ULONG ulch;
    DWORD nRead=0;

    switch(getAH()) {

    case KBDFUNC_READCHAR:
        if (ulch) {
            setAL(ulch & 0xff);
            setAH(ulch & 0xFF00);
            ulch = 0;
        }
        else {
            setAH(0); // zero scan code field for now
	    setAL((BYTE)tgetch());
            if (getAL() == 0 || getAL() == 0xE0) {
                setAL(0);
		setAH((BYTE)tgetch());
            }
        }
    break;

    case KBDFUNC_PEEKCHAR:
        setZF(1);
        if (ulch) {
            setAL(ulch & 0xFF);
            setAH(ulch & 0xFF00);
            setZF(0);
        }
	else if(tkbhit()) {
            setAH(0);		// zero scan code field for now
	    setAL((BYTE)tgetch());
            if (getAL() == 0 || getAL() == 0xE0) {
                setAL(0);
		setAH((BYTE)tgetch());
            }
            ulch = getAL() | getAH()<<8 | 0x10000;
            setZF(0);
        }
    break;
    }
}


void nt_block_event_thread(void)
{
    INPUT_RECORD InputRecord;
    DWORD	 nRecordsWritten;

    InputRecord.EventType = 1;
    InputRecord.Event.KeyEvent.bKeyDown = 1;
    InputRecord.Event.KeyEvent.wRepeatCount = 1;
    InputRecord.Event.KeyEvent.wVirtualKeyCode = 32;
    InputRecord.Event.KeyEvent.wVirtualScanCode = 41;
    InputRecord.Event.KeyEvent.uChar.AsciiChar = ' ';
    InputRecord.Event.KeyEvent.dwControlKeyState = 32;
    EnterCriticalSection(&csConsole);
    WriteConsoleInput(InputHandle,&InputRecord,1,&nRecordsWritten);
    InputRecord.EventType = 1;
    InputRecord.Event.KeyEvent.bKeyDown = 0;
    InputRecord.Event.KeyEvent.wRepeatCount = 1;
    InputRecord.Event.KeyEvent.wVirtualKeyCode = 32;
    InputRecord.Event.KeyEvent.wVirtualScanCode = 41;
    InputRecord.Event.KeyEvent.uChar.AsciiChar = ' ';
    InputRecord.Event.KeyEvent.dwControlKeyState = 32;
    WriteConsoleInput(InputHandle,&InputRecord,1,&nRecordsWritten);
    fEventThreadBlock = TRUE;
    LeaveCriticalSection(&csConsole);
    return;

}

void nt_resume_event_thread(void)
{
    fEventThreadBlock = FALSE;
    SetEvent (hConsoleWait);
    return;
}

// TEMP Till we have proper multitasking in WOW
extern BOOL VDMForWOW;
extern ULONG iWOWTaskId;


VOID VDMCtrlCHandler(ULONG ulCtrlType)
{
//    DebugBreak();
    if(ulCtrlType == SYSTEM_ROOT_CONSOLE_EVENT) {
	if(VDMForWOW)
	    // Kill everything for WOW VDM
	    ExitVDM(VDMForWOW,(ULONG)-1);
	else
	    ExitVDM(FALSE,0);
	ExitProcess(0);
	return;
    }
    EnterCriticalSection(&csCtrlc);
    nCtrlc++;
    LeaveCriticalSection(&csCtrlc);
    SetEvent(KbdSyncEvent);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\v86\scaffold\i386\softpc.c ===
#include <windows.h>
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <malloc.h>
#include <ctype.h>
#include "demexp.h"
#include "softpc.h"
#include <cmdsvc.h>
#include <xmssvc.h>
#include <dbgexp.h>
#include "xwincon.h"
#include "fun.h"
#include <conapi.h>

#define VDM_VIRTUAL_INTERRUPTS 0x00000200L
extern CONTEXT IntelRegisters;

VOID DumpIntelRegs();
VOID ParseSwitches( int, char**);
VOID usage();
BOOL ConInit (VOID);
extern VOID VDMCtrlCHandler(ULONG);

INT flOptions;

HANDLE OutputHandle;
HANDLE InputHandle;
HANDLE SCSCreateEvent;
char *EmDirectory;
BOOL scaffMin = FALSE;
BOOL scaffWow = FALSE;
BOOL VDMForWOW = FALSE;
CHAR BootLetter;


void main (argc, argv)
int argc;
char *argv[];
{

    PSZ psz,pszNULL;
    HANDLE hfile;
    DWORD BytesRead;
    int i;
    PCHAR FileAddress;
    BOOL	IsFirst;
    int   temp_argc = argc;
    char  **temp_argv = argv;

//    DebugBreak();

    if(SetConsoleCtrlHandler((PHANDLER_ROUTINE)VDMCtrlCHandler,TRUE)
	    == FALSE) {
        VDprint(
            VDP_LEVEL_INFO, 
	    ("CtrlC Handler Could'nt be installed\n")
	    );
    }

    // Tell the console that we want the last event (i.e when the
    // window is just to be destroyed.
    SetLastConsoleEventActive();

    // Check if the VDM Is for WOW
    while (--temp_argc > 0) {
	psz = *++temp_argv;
	if (*psz == '-' || *psz == '/') {
	    psz++;
	    if(tolower(*psz) == 'w'){
		VDMForWOW = TRUE;
		break;
	    }
	}
    }

    // This following API is required for recovery purposes. This
    // tells the basesrv that VDM has hooked ctrlc event. After
    // this it will always get the termination notification. If
    // the window is killed before we hook ctrl-c then basesrv
    // will know that data structures for this VDM has to be
    // freed. This should be the first call to base.dll.

    VDMOperationStarted (VDMForWOW);

    EmDirectory = NULL;

    // Hide the cmd window of WOWVDM
    if(VDMForWOW)
	VDMConsoleOperation((DWORD)VDM_HIDE_WINDOW);

    ParseSwitches( argc, argv );

    IsFirst = GetNextVDMCommand(NULL);

    for (i = 0; i < argc; i++) {
        VDprint(
            VDP_LEVEL_INFO, 
            ("%s\n", argv[i])
            );
    }

    VDbreak(VDB_LEVEL_INFO);

    if (EmDirectory == NULL) {
        usage();
	TerminateVDM();
    }

    // Sudeepb 26-Dec-1991 Temporary code to make
    // the life easy for WOW's internal users such that they dont have
    // to change the config.sys as per their setup.

    FixConfigFile (EmDirectory,IsFirst);

    pszNULL = strchr(EmDirectory,'\0');
    psz = EmDirectory;
    while(*psz == ' ' || *psz == '\t')
	psz++;

    BootLetter = *psz;

    host_cpu_init();
    sas_init(1024L * 1024L + 64L * 1024L);

    // Initialize ROM support

    BiosInit(argc, argv);

    // Initialize console support

    if (!ConInit()) {
        VDprint(
            VDP_LEVEL_ERROR,
	    ("SoftPC: error initializing console\n")
            );
	TerminateVDM();
    }

    // Initialize WOW


    CMDInit (argc,argv);

    // Initialize DOSEm

    if(!DemInit (argc,argv,EmDirectory)) {
        VDprint(
            VDP_LEVEL_ERROR,
	    ("SoftPC: error initializing DOSEm\n")
            );
	TerminateVDM();
    }

    // Initialize XMS
    
    if(!XMSInit (argc,argv)) {
        VDprint(
            VDP_LEVEL_ERROR,
	    ("SoftPC: error initializing XMS\n")
            );
	TerminateVDM();
    }

    // Initialize DBG
    
    if(!DBGInit (argc,argv)) {
        VDprint(
            VDP_LEVEL_ERROR,
	    ("SoftPC: error initializing DBG\n")
            );
	TerminateVDM();
    }

    // Prepare to load ntio.sys
    strcat (EmDirectory,"\\ntio.sys");
    hfile = CreateFile(EmDirectory,
                        GENERIC_READ, 
                        FILE_SHARE_READ,
                        NULL,
                        OPEN_EXISTING,
                        FILE_ATTRIBUTE_NORMAL,
                        NULL );

    if (hfile == (HANDLE)0xffffffff) {
        VDprint(
            VDP_LEVEL_ERROR,
            ("SoftPC: could not open file %s.  Error %d\n",
	    EmDirectory,
            GetLastError())
            );
	TerminateVDM();
    }

    FileAddress = (PCHAR)0x700;
    BytesRead = 1;
    while (BytesRead) {
        if (!ReadFile(hfile, FileAddress, 16384, &BytesRead, NULL)) {
            VDprint(
                VDP_LEVEL_ERROR,
                ("SoftPC: read failure on file %s.  Error %d\n",
		EmDirectory,
                GetLastError())
                );
	    TerminateVDM();
        }

        VDprint(VDP_LEVEL_INFO, 
            ("SoftPC: read a block of file %s\n", 
	    EmDirectory)
	    );
	FileAddress = (PCHAR)FileAddress + BytesRead;
    }

    VDprint(VDP_LEVEL_WARNING, 
        ("SoftPC: using Emulation file %s\n", 
	EmDirectory)
        );
    
    VDbreak(VDB_LEVEL_INFO);

    CloseHandle (hfile);

    // restore the emulation directory
    *pszNULL = 0;


    IntelRegisters.Eip = 0x0;
    IntelRegisters.SegCs = 0x70;
    IntelRegisters.EFlags = VDM_VIRTUAL_INTERRUPTS;

    host_simulate();

    if (IntelRegisters.EFlags & VDM_VIRTUAL_INTERRUPTS) {
        VDprint(VDP_LEVEL_INFO, ("Virtual ints enabled\n"));
    } else {
        VDprint(VDP_LEVEL_INFO, ("Virtual ints disabled\n"));
    }

    DumpIntelRegs();
}

#define MAX_CONFIG_SIZE  1024

VOID FixConfigFile (pszBin86Dir,IsFirstVDM)
PSZ  pszBin86Dir;
BOOL IsFirstVDM;
{

    // Temporary code. To be thrown out once we have full configuration
    // and installation.

CHAR   ConfigFile[]="?:\\config.vdm";
CHAR   Buffer [MAX_CONFIG_SIZE];
DWORD  len,i;
DWORD  BytesRead,BytesWritten;
HANDLE hfile;

    if (IsFirstVDM == FALSE)
	return;

    ConfigFile[0] = *pszBin86Dir;
    hfile = CreateFile( ConfigFile,
			GENERIC_WRITE | GENERIC_READ,
                        FILE_SHARE_READ,
                        NULL,
                        OPEN_EXISTING,
                        FILE_ATTRIBUTE_NORMAL,
			NULL );
    if (hfile == (HANDLE)0xffffffff) {
	DbgPrint ("config.vdm is'nt found on the root drive of yout NT trre\n");
	return;
    }


    if (!ReadFile(hfile, Buffer, MAX_CONFIG_SIZE, &BytesRead, NULL)){
	DbgPrint ("config.vdm could'nt be read\n, %x\n",GetLastError ());
	CloseHandle (hfile);
	return;
    }

    if (BytesRead == MAX_CONFIG_SIZE) {
	DbgPrint ("config.vdm is too big, could'nt perform macro substitution\n");
	CloseHandle (hfile);
	return;
    }

    SetFilePointer (hfile,
		    0,
		    NULL,
		    FILE_BEGIN);

    len = strlen (pszBin86Dir);

    for (i=0; i < BytesRead; i++) {
	if (Buffer [i] != '@'){
	    WriteFile (hfile,
		       &Buffer[i],
		       1,
		       &BytesWritten,
		       NULL);
	}
	else {
	    WriteFile (hfile,
		       pszBin86Dir,
		       len,
		       &BytesWritten,
		       NULL);
	}
    }

    CloseHandle (hfile);
    return;
}

VOID DumpIntelRegs()
{

    VDprint(VDP_LEVEL_ERROR,("EAX = %lx\n",IntelRegisters.Eax));
    VDprint(VDP_LEVEL_ERROR,("Ebx = %lx\n",IntelRegisters.Ebx));
    VDprint(VDP_LEVEL_ERROR,("Ecx = %lx\n",IntelRegisters.Ecx));
    VDprint(VDP_LEVEL_ERROR,("Edx = %lx\n",IntelRegisters.Edx));
    VDprint(VDP_LEVEL_ERROR,("Esi = %lx\n",IntelRegisters.Esi));
    VDprint(VDP_LEVEL_ERROR,("Edi = %lx\n",IntelRegisters.Edi));
    VDprint(VDP_LEVEL_ERROR,("Ebp = %lx\n",IntelRegisters.Ebp));
    VDprint(VDP_LEVEL_ERROR,("SegDs = %lx\n",IntelRegisters.SegDs));
    VDprint(VDP_LEVEL_ERROR,("SegEs = %lx\n",IntelRegisters.SegEs));
    VDprint(VDP_LEVEL_ERROR,("SegFs = %lx\n",IntelRegisters.SegFs));
    VDprint(VDP_LEVEL_ERROR,("SegGs = %lx\n",IntelRegisters.SegGs));
    VDprint(VDP_LEVEL_ERROR,("EFlags = %lx\n",IntelRegisters.EFlags));
    VDprint(VDP_LEVEL_ERROR,("SS:Esp = %lx:",IntelRegisters.SegSs));
    VDprint(VDP_LEVEL_ERROR,("%lx\n",IntelRegisters.Esp));
    VDprint(VDP_LEVEL_ERROR,("CS:Eip = %lx:",IntelRegisters.SegCs));
    VDprint(VDP_LEVEL_ERROR,("%lx\n",IntelRegisters.Eip));
}

VOID ParseSwitches(
    int argc,
    char **argv
    )
{
    int i;

    for (i = 1; i < argc; i++){
        if ((argv[i][0] == '-') || (argv[i][0] == '/')) {

            switch (argv[i][1]) {
                
                case 's' :
                case 'S' :
                    sscanf(&argv[i][2], "%x", &VdmDebugLevel);
                    VDprint(
                        VDP_LEVEL_WARNING, 
                        ("VdmDebugLevel = %x\n", 
                        VdmDebugLevel)
                        );
                    break;
                
                case 'f' :
		case 'F' :
		    // Note this memory is freed by DEM.
		    if((EmDirectory = (PCHAR)malloc (strlen (&argv[i][2]) +
					  1 +
					  sizeof("\\ntdos.sys") +
					  1
					 )) == NULL){
			DbgPrint("SoftPC: Not Enough Memory \n");
			TerminateVDM();
		    }
		    strcpy(EmDirectory,&argv[i][2]);
                    break;

                case 't' :
                case 'T' :
                    flOptions |= OPT_TERMINAL;
		    break;
		case 'm' :
		case 'M' :
		    scaffMin = TRUE;
		    break;
		case 'w' :
		case 'W' :
		    scaffWow = TRUE;
	    }
        } else {
            break;
        }
    }
}

VOID usage()
{
    DbgPrint("SoftPC Usage:  softpc -F<emulation file> [-D#] [<drive>:=<virtual disk>] [dos command line]\n");
}


VOID TerminateVDM(void)
{

    if(VDMForWOW)
    // Kill everything for WOW VDM
	ExitVDM(VDMForWOW,(ULONG)-1);
    else
	ExitVDM(FALSE,0);
    ExitProcess (0);
}


DWORD SCSConsoleThread(LPVOID lp)
{


    SetEvent(SCSCreateEvent);
    BiosKbdReadLoop();
    return TRUE;
}


BOOL ConInit (VOID)
{
    DWORD SCSThreadId;
    HANDLE InputThread;
    OutputHandle = GetStdHandle(STD_OUTPUT_HANDLE);
    InputHandle = GetStdHandle(STD_INPUT_HANDLE);

    SCSCreateEvent = CreateEvent( NULL, TRUE, FALSE,NULL );

    InputThread = CreateThread(
        (LPSECURITY_ATTRIBUTES)0,
        8192,
	(LPTHREAD_START_ROUTINE)SCSConsoleThread,
        (LPVOID)0,
        STANDARD_RIGHTS_REQUIRED,
	&SCSThreadId
    );

    WaitForSingleObject(SCSCreateEvent, -1);

    CloseHandle(SCSCreateEvent);

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\v86\scaffold\i386\stubs.c ===
void check_I(){
}

void copyROM(){
}

void generic_insb(){
}
void generic_insw(){
}
void generic_outsb(){
}
void generic_outsw(){
}

void host_timer_event(){
}
int ica_intack(){
    return 7;
}
void inb(){
}
void inw(){
}
void outb(){
}
void outw(){
}
unsigned long *read_pointers;

void rom_checksum(){
}

void rom_init(){
}


host_simulate(){
    cpu_simulate();
}

host_cpu_init(){
    cpu_init();
}

void (*ica_hw_interrupt_func)() = rom_init;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\v86\scaffold\i386\x86.h ===
//
// This is temporary code, and should be removed when Insignia supplies rom
// support
//

/* x86 v1.0
 *
 * X86.H
 * Constants, macros, and common types
 * for the x86 emulator and related components
 *
 * History
 * Created 19-Oct-90 by Jeff Parsons
 *         17-Apr-91 by Dave Hastings trimmed for use in softpc (temprorary)
 *
 * COPYRIGHT NOTICE
 * This source file may not be distributed, modified or incorporated into
 * another product without prior approval from the author, Jeff Parsons.
 * This file may be copied to designated servers and machines authorized to
 * access those servers, but that does not imply any form of approval.
 */

#ifdef DOS
#define SIGNALS
#endif

#ifdef OS2_16
#define OS2
#define SIGNALS
#endif

#ifdef OS2_32
#define OS2
#define FLAT_32
#endif

#include <stdarg.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <malloc.h>
#include <process.h>

#ifdef WIN_16
#define WIN
#define API16
#endif

#ifdef WIN_32
#ifndef WIN
#define WIN
#endif
#define FLAT_32
#define TRUE_IF_WIN32	1
#define FIXHWND(h)	((HWND)((INT)(h) & 0x00ffffff))
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#else
#define TRUE_IF_WIN32	0
#define FIXHWND(h)	(h)
#endif

#ifdef FLAT_32
#ifndef i386
#define ALIGN_32
#else
#define NOALIGN_32
#endif
#endif

#ifdef WIN
#define _WINDOWS
#include <windows.h>
#endif

#ifdef SIGNALS
#include <conio.h>
#include <signal.h>
#endif

#ifdef OS2_32
#include <excpt.h>
#define XCPT_SIGNAL	0xC0010003
#endif
#define SIGHIT(flChk)	((iSigCheck++ & 0x7FF)?(flSignals & (flChk)):(kbhit(),(flSignals & (flChk))))

#ifndef CONST
#define CONST const
#endif
#ifndef CDECL
#define CDECL _cdecl
#endif
#ifndef PASCAL
#define PASCAL
#endif

#ifdef FLAT_32
#ifndef WIN
#define FAR
#endif
#define HUGE
#define HALLOC(n,s)	malloc((n)*(s))
#define HLOCK(h)	h
#define HUNLOCK(h)	0
#define HFREE(h)	free(h)
#else
#ifndef WIN
#define FAR		_far
#define HUGE		_huge
#define HALLOC(n,s)	halloc(n,s)
#define HLOCK(h)	h
#define HUNLOCK(h)	0
#define HFREE(h)	hfree(h)
#else
#define HUGE		_huge
#define HALLOC(n,s)	GlobalAlloc(GMEM_MOVEABLE|GMEM_ZEROINIT,(n)*(s))
#define HLOCK(h)	(HPVOID)GlobalLock(h)
#define HUNLOCK(h)	GlobalUnlock(h)
#define HFREE(h)	GlobalFree(h)
#endif
#endif

#define BYTEOF(i,n)	(((PBYTE)&(i))[n])
#define LOB(i)		BYTEOF(i,0)
#define HIB(i)		BYTEOF(i,1)
#define WORDOF(i,n)	(((PWORD)&(i))[n])
#define LOW(l)		WORDOF(l,0)
#define HIW(l)		WORDOF(l,1)
#define INTOF(i,n)	(((PINT)&(i))[n])
#define UINTOF(i,n)	(((PUINT)&(i))[n])
#ifndef WIN
#define LOWORD(l)	((WORD)(l))
#define HIWORD(l)	((WORD)(((DWORD)(l) >> 16) & 0xFFFF))
#define LOBYTE(w)	((BYTE)(w))
#define HIBYTE(w)	((BYTE)(((WORD)(w) >> 8) & 0xFF))
#endif
#ifndef MAKEWORD
#define MAKEWORD(l,h)	((WORD)((BYTE)(l)|((BYTE)(h)<<8)))
#endif
#define MAKEDWORD(l0,h0,l1,h1)	((DWORD)MAKEWORD(l0,h0)|((DWORD)MAKEWORD(l1,h1)<<16))
#define GETBYTE(p)	*((PBYTE)p)++
#define GETBYTEPTR(p)	((PBYTE)p)++
#define GETWORDPTR(pb)	((PWORD)pb)++
#define GETDWORDPTR(pb) ((PDWORD)pb)++
#ifndef ALIGN_32
#define GETWORD(pb)	(*((PWORD)pb)++)
#define GETDWORD(pb)	(*((PDWORD)pb)++)
#define FETCHWORD(s)	((WORD)(s))
#define FETCHDWORD(s)	((DWORD)(s))
#define STOREWORD(d,s)	(WORD)d=(WORD)s
#define STOREDWORD(d,s) (DWORD)d=(DWORD)s
#else
#define GETWORD(pb)	(pb+=2,MAKEWORD(*(pb-2),*(pb-1)))
#define GETDWORD(pb)	(pb+=4,MAKEDWORD(*(pb-4),*(pb-3),*(pb-2),*(pb-1)))
#define FETCHWORD(s)	MAKEWORD(LOB(s),HIB(s))
#define FETCHDWORD(s)	MAKEDWORD(BYTEOF(s,0),BYTEOF(s,1),BYTEOF(s,2),BYTEOF(s,3))
#define STOREWORD(d,s)	{BYTEOF(d,0)=LOBYTE(s);BYTEOF(d,1)=HIBYTE(s);}
#define STOREDWORD(d,s) {BYTEOF(d,0)=LOBYTE(LOWORD(s));BYTEOF(d,1)=HIBYTE(LOWORD(s));BYTEOF(d,2)=LOBYTE(HIWORD(s));BYTEOF(d,3)=HIBYTE(HIWORD(s));}
#endif
#define SWAP(x,y)	{INT t; t=y; y=x; x=t;}
#define SWAPS(x,y)	{SHORT t; t=y; y=x; x=t;}
#define SWAPL(x,y)	{LONG t; t=y; y=x; x=t;}
#define SWAPBYTE(x,y)	{BYTE t; t=y; y=x; x=t;}
#define SWAPWORD(x,y)	{WORD t; t=FETCHWORD(y); STOREWORD(y,FETCHWORD(x)); STOREWORD(x,t);}
#define SWAPDWORD(x,y)	{DWORD t; t=FETCHDWORD(y); STOREDWORD(y,FETCHDWORD(x)); STOREDWORD(x,t);}
#define NUMEL(a)	((sizeof a)/(sizeof a[0]))

#define SXBYTE(i)	((LONG)(SBYTE)(i))
#define SXWORD(i)	((LONG)(SHORT)(i))
#define SXSHORT(i)	((LONG)(SHORT)(i))
#define ZXBYTE(i)	((ULONG)(BYTE)(i))
#define ZXWORD(i)	((ULONG)(USHORT)(i))
#define ZXSHORT(i)	((ULONG)(USHORT)(i))

#define _Z2(m)		((m)&1?0:(m)&2?1:2)
#define _Z4(m)		((m)&3?_Z2(m):_Z2((m)>>2)+2)
#define _Z8(m)		((m)&15?_Z4(m):_Z4((m)>>4)+4)
#define _Z16(m) 	((m)&255?_Z8(m):_Z8((m)>>8)+8)
#define _Z32(m) 	((m)&65535?_Z16(m):_Z16((m)>>16)+16)
#define SHIFTLEFT(i,m)	(((i)<<_Z32(m))&(m))
#define SHIFTRIGHT(i,m) (((i)&(m))>>_Z32(m))

#define OFFSETOF(t,f)	((INT)&(((t *)0)->f))


/* Universal constants
 */
#define K		1024L
#ifndef TRUE
#define TRUE		1
#define FALSE		0
#endif
#ifndef NULL
#define NULL		0
#endif
#define UNDEFINED      -1

#define CTRL_A		1	// used by gets to repeat last line
#define CTRL_C		3	// break in debug window
#define CTRL_Q		17	// flow control
#define CTRL_S		19	// flow control
#define BELL		7	//
#define BS		8	// backspace
#define TAB		9	//
#define LF		10	// linefeed
#define CR		13	// return
#define ESCAPE		27	//


/* Program options
 */
#define OPT_FONT	0x0004	// use small OEM font if available (/s)
#define OPT_DOUBLE	0x0020	// use 50-line debug window w/small font (/50)
#define OPT_CAPS	0x0002	// map ctrl keys to caps-lock (/c)
#define OPT_TERMINAL	0x0010	// redirect all window output to terminal (/t)
#define OPT_FLUSH	0x0100	// flush prefetch after every jump (/f)
#define OPT_NOXLATE	0x0200	// disable built-in translations (/n)
#define OPT_DEBUG	0x0008	// shadow all log output on debug terminal (/d)
#define OPT_GO		0x0001	// do an initial "go" (/g)


/* Signal flags
 */
#define SIGNAL_BREAK	0x0001	// set whenever break has occurred
#define SIGNAL_UNWIND	0x0002	// set whenever unwind has occurred
#define SIGNAL_REBOOT	0x0004	// set whenever reboot has occurred
#define SIGNAL_RUN	0x0008	// set whenever emulator is "running"
#define SIGNAL_TRACE	0x0010	// set whenever debugger tracing
#define SIGNAL_BRKPT	0x0020	// set whenever debugger breakpoints enabled
#define SIGNAL_SSTEP	0x0040	// set whenever emulator single-step on

#undef	SIG_IGN 		// fix broken definition in (old) signal.h
#define SIG_IGN (VOID (CDECL *)())1


/* Exec flags (for HostInput/GuestInput)
 */
#define EXEC_INPUT	0x0000	// wait for input
#define EXEC_GO 	0x0001	// execute immediately
#define EXEC_FREEZE	0x0002	// execution frozen (guest only)


/* Standard types
 */
#ifndef WIN
typedef void VOID;
typedef unsigned char BYTE;
typedef unsigned short WORD;	// confusing - use where 16-bit req. only
typedef unsigned long DWORD;	// confusing - use where 32-bit req. only
typedef long LONG;		// use where 32-bit req. only
typedef int BOOL;
#endif
typedef char CHAR;
typedef signed char SBYTE;
typedef short SHORT;		// use where 16-bit req. only
typedef unsigned short USHORT;	// use where 16-bit req. only
typedef int INT;		// ints preferred
typedef unsigned int UINT;	// ints preferred
typedef unsigned long ULONG;	// use where 32-bit req. only

#ifndef WIN
typedef BYTE *PBYTE;		// native pointers
typedef WORD *PWORD;
typedef DWORD *PDWORD;
typedef INT *PINT;
typedef LONG *PLONG;
typedef CHAR *PSTR;
#endif
typedef PBYTE *PPBYTE;
typedef PWORD *PPWORD;
typedef PDWORD *PPDWORD;
typedef CHAR SZ[];
typedef VOID *PVOID;
typedef CHAR *PCHAR;
typedef SHORT *PSHORT;
typedef USHORT *PUSHORT;
typedef PUSHORT *PPUSHORT;
typedef UINT *PUINT;
typedef ULONG *PULONG;
typedef PULONG *PPULONG;
typedef BOOL *PBOOL;
typedef CHAR *PSZ;
typedef PSZ *PPSZ;

typedef VOID FAR *FPVOID;	// "far" (or "long" in Windows) pointers
typedef CHAR FAR *FPCHAR;
typedef BYTE FAR *FPBYTE;
typedef SHORT FAR *FPSHORT;
typedef USHORT FAR *FPUSHORT;
typedef LONG FAR *FPLONG;
typedef ULONG FAR *FPULONG;
typedef CHAR FAR *FPSTR;
typedef CHAR FAR *FPSZ;

typedef VOID HUGE *HPVOID;	// "huge" pointers
typedef CHAR HUGE *HPCHAR;
typedef BYTE HUGE *HPBYTE;
typedef SHORT HUGE *HPSHORT;
typedef USHORT HUGE *HPUSHORT;
typedef LONG HUGE *HPLONG;
typedef ULONG HUGE *HPULONG;
typedef CHAR HUGE *HPSTR;
typedef CHAR HUGE *HPSZ;

#ifndef WIN
typedef HPVOID HANDLE;
#endif

#ifdef WIN
typedef INT  (FAR PASCAL *INTPROC)(HWND, UINT, UINT, LONG);
#endif
#ifdef WIN_16
typedef LONG (FAR PASCAL *WNDPROC)(HWND, WORD, UINT, LONG);
#endif


/* Global data
 */
extern FILE *hfLog;
extern INT  flOptions;	// command-line options (see OPT_*)
extern INT  flSignals;	// signal flags (see SIGNAL_*)
extern INT  iSigCheck;	// counter indicating when to make next check
extern INT  iSigLevel;	// counter indicating whether to take default action
extern INT  iLogLevel;	// logging level;  0 implies none
extern BOOL fReinit;	// set once first initialization has completed


/* String macros
 */
#define STRSKIP(psz,sz)     psz += strspn(psz, sz)
#define STRSKIPTO(psz,sz)   psz += strcspn(psz, sz)
#define STRSKIPNEXT(psz,sz) psz += strspn(psz+=strcspn(psz, sz), sz)

#define ATOI(psz)	(INT)szTOul(psz, 10, -1)


/* Logging macros
 */
#define IFLOG(l)	if (l==iLogLevel && (iLogLevel&1) || l<=iLogLevel && !(iLogLevel&1))

#define OPENLOG()	(hfLog?hfLog:(hfLog=fopen("log", "w")))
#define APPENDLOG()	(hfLog?hfLog:(hfLog=fopen("log", "a")))
#define CLOSELOG()	if (hfLog) {fclose(hfLog); hfLog=NULL;}

#ifdef	NOLOG
#define LOG(l,args)
#else
#define LOG(l,args)	IFLOG(l) logprintf args; else
#endif


/* Debugging macros
 */
#define MODNAME(module) static char szModule[] = __FILE__
#define X86ERROR()	terminate(ERR_ASSERT, szModule, __LINE__)

#ifdef	DEBUG

#define STATIC
#define INT3()		_asm int 3
#define IFDEBUG(f)	if (f)
#define ELSEDEBUG	else
#define LOGDEBUG(l,args) LOG(l,args)
#define X86ASSERT(exp)	if (!(exp)) X86ERROR()

#else

#define STATIC static
#define INT3()
#define IFDEBUG(f)
#define ELSEDEBUG
#define LOGDEBUG(l,args)
#define X86ASSERT(exp)

#endif	// DEBUG


/* Other common local include files
 */
#ifdef X86
#include "xerr.h"
#include "xlib.h"
#endif


/* Windows goop
 */
#define SZ_APP		"x86"
#define SZ_TITLE	"x86 emulator v0.17"
#define SZ_AUTHOR	"by Jeff Parsons, (C) 1991"
#define SZ_PCTITLE	"x86 pc"

#define IDM_DBBRK 100
#define IDM_ABOUT 101

/* Standard color definitions
 */
#define CLR_BLACK		0x00000000
#define CLR_RED 		0x007F0000
#define CLR_GREEN		0x00007F00
#define CLR_BROWN		0x007F7F00
#define CLR_BLUE		0x0000007F
#define CLR_MAGENTA		0x007F007F
#define CLR_CYAN		0x00007F7F
#define CLR_LT_GRAY		0x00BFBFBF

#define CLR_DK_GRAY		0x007F7F7F
#define CLR_BR_RED		0x00FF0000
#define CLR_BR_GREEN		0x0000FF00
#define CLR_YELLOW		0x00FFFF00
#define CLR_BR_BLUE		0x000000FF
#define CLR_BR_MAGENTA		0x00FF00FF
#define CLR_BR_CYAN		0x0000FFFF
#define CLR_WHITE		0x00FFFFFF


extern HANDLE hHostInstance;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\v86\scaffold\i386\xbios.h ===
//
// This code is temporary.  When Insignia supplies rom support, it should
// be removed.
//

/* x86 v1.0
 *
 * XBIOS.H
 * Guest ROM BIOS support
 *
 * History
 * Created 20-Oct-90 by Jeff Parsons
 *         17-Apr-91 Trimmed by Dave Hastings for use in temp. softpc
 *
 * COPYRIGHT NOTICE
 * This source file may not be distributed, modified or incorporated into
 * another product without prior approval from the author, Jeff Parsons.
 * This file may be copied to designated servers and machines authorized to
 * access those servers, but that does not imply any form of approval.
 */


/* BIOS interrupts
 */
#define BIOSINT_DIVZERO         0x00    //
#define BIOSINT_SSTEP           0x01    //
#define BIOSINT_NMI             0x02    // for parity errors, too
#define BIOSINT_BRKPT           0x03    //
#define BIOSINT_OVFL            0x04    //
#define BIOSINT_PRTSC           0x05    //
#define BIOSINT_TMRINT          0x08    //
#define BIOSINT_KBDINT          0x09    //
#define BIOSINT_COM2INT         0x0B    //
#define BIOSINT_COM1INT         0x0C    //
#define BIOSINT_LPT2INT         0x0D    //
#define BIOSINT_FLPYINT         0x0E    //
#define BIOSINT_LPT1INT         0x0F    //
#define BIOSINT_VID             0x10    //
#define BIOSINT_EQUIP           0x11    //
#define BIOSINT_MEMORY          0x12    //
#define BIOSINT_DSK             0x13    //
#define BIOSINT_COM             0x14    //
#define BIOSINT_OSHOOK          0x15    //
#define BIOSINT_KBD             0x16    //
#define BIOSINT_PRT             0x17    //
#define BIOSINT_BASIC           0x18    //
#define BIOSINT_WBOOT           0x19    //
#define BIOSINT_TIME            0x1A    //
#define BIOSINT_CTRLBRK         0x1B    //
#define BIOSINT_TICK            0x1C    //
#define BIOSINT_VIDPARMS        0x1D    //
#define BIOSINT_FDSKPARMS       0x1E    //
#define BIOSINT_VIDGRAPH        0x1F    //
#define BIOSINT_OLDDISKIO       0x40    //
#define BIOSINT_HDSK1PARMS      0x41    //
#define BIOSINT_OLDVID          0x42    //
#define BIOSINT_EXTVIDGRAPH     0x43    //
#define BIOSINT_HDSK2PARMS      0x46    //


/* BIOS Data Area locations
 *
 * So that all low-memory references are relative to the same segment
 * (ie, 0), we use 0:400 instead of 40:0 as the base address of this area.
 *
 * Note that as more individual BIOS modules are created (eg, xbiosvid,
 * xbiosdsk, etc), many of these BIOS data definitions should be moved to the
 * appropriate individual header file.
 */
#define BIOSDATA_SEG            0

#define BIOSDATA_BEGIN          0x400
#define BIOSDATA_RS232_BASE     0x400   // 4 COM adapter addresses
#define BIOSDATA_PRINTER_BASE   0x408   // 4 LPT adapter addresses
#define BIOSDATA_EQUIP_FLAG     0x410   // equipment flag           (1 word)

#define BIOSEQUIP_FLOPPY        0x0001  // machine has a floppy
#define BIOSEQUIP_X87           0x0002  // X87=1 if coprocessor installed
#define BIOSEQUIP_16KPLANAR     0x0000  //
#define BIOSEQUIP_32KPLANAR     0x0004  //
#define BIOSEQUIP_48KPLANAR     0x0008  //
#define BIOSEQUIP_64KPLANAR     0x000C  //
#define BIOSEQUIP_PLANARMASK    0x000C  //
#define BIOSEQUIP_VIDEOMASK     0x0030  // video configuration bits
#define BIOSEQUIP_COLOR40VIDEO  0x0010  //
#define BIOSEQUIP_COLOR80VIDEO  0x0020  //
#define BIOSEQUIP_MONOVIDEO     0x0030  //
#define BIOSEQUIP_FLOPPYMASK    0x00C0  // # floppies-1 (if FLOPPY=1)
#define BIOSEQUIP_COMMASK       0x0E00  // # COM ports
#define BIOSEQUIP_PRINTERMASK   0xC000  // # LPT ports

#define BIOSDATA_MFG_TST        0x412   // initialization flag      (1 byte)
#define BIOSDATA_MEMORY_SIZE    0x413   // memory size in K bytes   (1 word)
#define BIOSDATA_MFG_ERR_FLG    0x415   // mfg error codes          (2 bytes)

#define BIOSDATA_END            0x4FF

#define BIOSDATA_BOOT           0x7C00


/* BIOS ROM locations (assumed segment BIOSROM_SEG)
 */
#define BIOSROM_SEG             0xF000

#define BIOSROM_WBOOT           0xE6F2
#define BIOSROM_DSK             0xEC59
#define BIOSROM_MEMORY          0xF841
#define BIOSROM_EQUIP           0xF84D
#define BIOSROM_IRET            0xFF53  // 1 byte IRET
#define BIOSROM_RESET           0xFFF0  // 5 byte jmp
#define BIOSROM_DATE            0xFFF5  // 8 byte date (eg, 04/24/81)
#define BIOSROM_UNUSED1         0xFFFD
#define BIOSROM_SIG             0xFFFE  // PC ID byte
#define BIOSROM_GBP             0xFFFF  // location of GBP opcode (non-standard)

#define BIOSSIG_PC              0xFF
#define BIOSSIG_XT              0xFE
#define BIOSSIG_JR              0xFD
#define BIOSSIG_AT              0xFC    // and many more...

#define BIOSDATE_MINE           '0','4','/','1','7','/','9','1'
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\v86\scaffold\i386\xbiosdsk.h ===
//
// This code is temporary.  When Insignia supplies rom support, it should
// be removed.
//

/* x86 v1.0
 *
 * XBIOSDSK.H
 * Guest ROM BIOS disk emulation
 *
 * History
 * Created 20-Oct-90 by Jeff Parsons
 *         17-Apr-91 Trimmed by Dave Hastings for use in temp. softpc
 *
 * COPYRIGHT NOTICE
 * This source file may not be distributed, modified or incorporated into
 * another product without prior approval from the author, Jeff Parsons.
 * This file may be copied to designated servers and machines authorized to
 * access those servers, but that does not imply any form of approval.
 */


#define MAX_FD                  2       // # supported floppy drives
#define MAX_HD                  2       // # supported hard disk drives
#define MAX_DRIVES              (MAX_FD+MAX_HD)

#define DRIVE_FD0               0x00    // first floppy disk drive #
#define DRIVE_FD1               0x01    //
#define DRIVE_HD0               0x80    // first hard disk drive #
#define DRIVE_HD1               0x81    //


/* Drive types for QUERYDRVPARMS
 */
#define DRVTYPE_360KB           1
#define DRVTYPE_1200KB          2
#define DRVTYPE_720KB           3
#define DRVTYPE_1440KB          4


/* BIOS disk functions
 */
#define DSKFUNC_DISKRESET       0x00
#define DSKFUNC_DISKSTATUS      0x01
#define DSKFUNC_READSECTORS     0x02
#define DSKFUNC_WRITESECTORS    0x03
#define DSKFUNC_VERIFYSECTORS   0x04
#define DSKFUNC_FORMATTRACK     0x05
#define DSKFUNC_QUERYDRVPARMS   0x08
#define DSKFUNC_QUERYDASDTYPE   0x15
#define DSKFUNC_QUERYCHANGE     0x16
#define DSKFUNC_SETDISKTYPE     0x17
#define DSKFUNC_SETMEDIATYPE    0x18


/* BIOS disk status codes
 */
#define DSKSTAT_SUCCESS         0x00    // successful completion
#define DSKSTAT_BADCMD          0x01    // bad command
#define DSKSTAT_BADADDRMARK     0x02    // address mark not found
#define DSKSTAT_WRITEPROTECT    0x03    // write on write-protected disk
#define DSKSTAT_RECNOTFOUND     0x04    // sector not found
#define DSKSTAT_BADRESET        0x05    // reset failed (HD)
#define DSKSTAT_MEDIACHANGE     0x06    // media changed
#define DSKSTAT_INITFAIL        0x07    // parm. act. failed (HD)
#define DSKSTAT_BADDMA          0x08    // DMA overrun
#define DSKSTAT_DMABOUNDARY     0x09    // DMA across 64K boundary
#define DSKSTAT_BADSECTOR       0x0A    // bad sector detected (HD)
#define DSKSTAT_BADTRACK        0x0B    // bad track detected (HD)
#define DSKSTAT_BADMEDIATYPE    0x0C    // unsupported track (HD)
#define DSKSTAT_BADFMTSECNUM    0x0D    // bad # of sectors on format (HD)
#define DSKSTAT_ADDRMARKDET     0x0E    // ctrl data addr mark detected (HD
#define DSKSTAT_DMAARBERR       0x0F    // DMA arbitration error (HD)
#define DSKSTAT_BADCRCECC       0x10    // bad CRC/ECC
#define DSKSTAT_DATACORRECT     0x11    // data ECC corrected
#define DSKSTAT_BADCNTLR        0x20    // controller failure
#define DSKSTAT_BADSEEK         0x40    // seek failed
#define DSKSTAT_TIMEOUT         0x80    // time out
#define DSKSTAT_DRVNOTREADY     0xAA    // drive not ready (HD)
#define DSKSTAT_UNDEFERR        0xBB    // undefined error (HD)
#define DSKSTAT_WRITEFAULT      0xCC    // write fault (HD)
#define DSKSTAT_STATUSERROR     0xE0    // status register error (HD)
#define DSKSTAT_SENSEFAIL       0xFF    // sense operation failed (HD)


/* BIOS Data Area disk locations
 */
#define DSKDATA_SEEKSTATUS      0x43E   // drive recal. status      (1 byte)
#define DSKDATA_MOTORSTATUS     0x43F   // motor status             (1 byte)
#define DSKDATA_MOTORCOUNT      0x440   // time-out count for motor (1 byte)
#define DSKDATA_DISKETTESTATUS  0x441   // return code status       (1 byte)
#define DSKDATA_NECSTATUS       0x442   // controller status bytes  (7 bytes)

#define DSKDATA_DISKSTATUS1     0x474   // return code status       (1 byte)


/* Floppy Diskette Parameter Table
 * (pointed by vector BIOSINT_FDSKPARMS (1Eh))
 */
typedef struct fdp_s {
    BYTE bSpecify1;                     // step-rate, head-unload
    BYTE bSpecify2;                     // head-load, DMA mode
    BYTE bMotorOff;                     // motor-off delay
    BYTE bSectorSize;                   // bytes/sec (0=128,1=256,2=512,3=1024)
    BYTE nLastSector;                   // (or think of it as # sectors/track)
    BYTE lenGapRW;                      //
    BYTE lenData;                       //
    BYTE lenGapFormat;                  //
    BYTE bFormatData;                   // format initialization byte
    BYTE bSettle;                       // head settle time
    BYTE bMotorOn;                      // motor start-up time
} FDP;
typedef FDP *PFDP;                      // pointer to diskette parameter table


/* Hard Disk Parameter Table
 */
typedef struct hdp_s {
    USHORT usMaxCylinders;              // maximum number of cylinders
    BYTE   bMaxHeads;                   // maximum number of heads
    USHORT usReserve1;                  // reserved (not used)
    USHORT usWritePrecompCyl;           // starting write precompensation cyl.
    BYTE   bMaxECCDataBurstLen;         // maximum ECC data burst length
    BYTE   bControl;                    // control byte
    BYTE   abReserve2[3];               // reserved (not used)
    USHORT usLandingZone;               // landing zone for head parking
    BYTE   bSectorsPerTrack;            // number of sectors per track
    BYTE   bReserve3;                   // reserved for future use
} HDP;
typedef HDP *PHDP;                      // pointer to hard disk parameter table


/* Hard Disk Parameter Table control byte bit definitions
 */
#define HDPCTRL_DISABLERETRY    0xC0    // disable retries
#define HDPCTRL_EXCEED8HEADS    0x08    // more than 8 heads


/* Boot sector structures (more DOS-defined than BIOS-defined however -JTP)
 */
#define PARTITION_ACTIVE        0x80    // status values

#define PARTITION_12BITFAT      1       // type valus
#define PARTITION_16BITFAT      4
#define PARTITION_LARGEFAT      6

typedef struct mbr_s {                  // Master Boot Record
    BYTE    boot_code[0x1BE];
    BYTE    partition_status;
    BYTE    starting_head;
    USHORT  starting_sec_cyl;
    BYTE    partition_type;
    BYTE    ending_head;
    USHORT  ending_sec_cyl;
    ULONG   starting_abs_sector;
    ULONG   total_sectors;
} MBR;
typedef MBR *PMBR;

typedef struct bpb_s {                  // BIOS Parameter Block (from sysbloks.h)
    BYTE    boot_code[0x0B];
    USHORT  bytes_per_sector;           // sector size
    BYTE    sectors_per_cluster;        // sectors per allocation unit
    USHORT  reserved_sectors;           // number of reserved sectors
    BYTE    nbr_fats;                   // number of fats
    USHORT  root_entries;               // number of directory entries
    USHORT  total_sectors;              // number of sectors
    BYTE    media_type;                 // fatid byte
    USHORT  sectors_per_fat;            // sectors in a copy of the FAT
    USHORT  sectors_per_track;          // number of sectors per track
    USHORT  number_of_heads;            // number of heads
    ULONG   hidden_sectors;             // number of hidden sectors
    ULONG   large_total_sectors;        // large total sectors
    BYTE    reserved[6];                // 6 reserved bytes
} BPB;
typedef BPB *PBPB;


/* Virtual disk mapping info
 *
 * VIRTDISK is the header of a virtual disk file.  Following the header
 * is an optional track table, and TRACKINFO is the format of each entry
 * in that table.  The track table is only present if the last two
 * fields in the header (nsecTrack and nbSector) are zero, indicating a
 * non-homogeneous disk structure.
 *
 * Currently, a max of 4 DRIVEMAP structures are supported.  The first two
 * entries are for physical drives 0 and 1 (specified in the command-line
 * options as drives A: and B:), and subsequent entries are for physical
 * hard drives 0x80 and up (specified as drives C: and up).  Each DRIVEMAP
 * describes the remapping that should occur, if any, and for virtual disk
 * files, it also contains the virtual disk file header (which is read in
 * during initialization).
 *
 * When a request comes in for one of those drives, we check the flags in
 * corresponding DRIVEMAP structure.  If no flags are set, no remapping
 * or virtualization occurs (drive behaves normally).  This is the default.
 * If the drive is disabled (eg, "A:=*"), then all requests are returned
 * with an error.  If the drive is remapped to another physical drive (eg,
 * "A:=B:") then the request is routed to the mapped drive.  Finally, if
 * the drive is remapped to a virtual disk file, the appropriate file I/O
 * is performed.
 *
 * NOTE: Contrary to comments above, access to physical drives is not
 * currently supported, so mapping to a virtual drive is all you can do
 * right now.... (24-Nov-90 JTP)
 */

#define VDFLAGS_WRITEPROTECT    0x01    // virtual disk is "write-protected"

typedef struct virtdisk_s {
    BYTE    fbVirt;                     // flags
    BYTE    nHeads;                     // # heads
    USHORT  nCyls;                      // # cylinders
    USHORT  nsecTrack;                  // # sectors per track
    USHORT  nbSector;                   // # bytes per sector
} VIRTDISK;
typedef VIRTDISK *PVIRTDISK;

typedef struct trackinfo_s {
    USHORT  nsecTrack;                  // # sectors per track
    USHORT  nbSector;                   // # bytes per sector
    ULONG   offVirtDisk;                // offset within virtual disk file
} TRACKINFO;
typedef TRACKINFO *PTRACKINFO;

#define DMFLAGS_VIRTUAL         0x01    // physical remapped to virtual
#define DMFLAGS_DISABLED        0x02    // physical remapped to disabled
#define DMFLAGS_PHYSICAL        0x04    // physical remapped to physical
#define DMFLAGS_LOGICAL         0x08    // physical remapped to logical

typedef struct drivemap_s {
    BYTE    fbMap;                      // flags
    BYTE    iPhysical;                  // # of remapped drive, if any
    FILE    *hfVirtDisk;                // handle to virtual disk, if any
    VIRTDISK vdInfo;                    // virtual disk info, if any
   #ifdef LOGICAL_DRIVE_SUPPORT
    ULONG   nsecHidden;                 // from BPB, if any (logical disks only)
    BYTE    type;                       // disk type, if any (logical disks only)
   #endif
} DRIVEMAP;
typedef DRIVEMAP *PDRIVEMAP;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\v86\scaffold\i386\xbioskbd.h ===
//
// This code is temporary.  When Insignia supplies rom support, it should
// be removed.
//

/* x86 v1.0
 *
 * XBIOSKBD.H
 * Guest ROM BIOS keyboard emulation
 *
 * History
 * Created 20-Oct-90 by Jeff Parsons
 *         17-Apr-91 Trimmed by Dave Hastings for use in temp. softpc
 *
 * COPYRIGHT NOTICE
 * This source file may not be distributed, modified or incorporated into
 * another product without prior approval from the author, Jeff Parsons.
 * This file may be copied to designated servers and machines authorized to
 * access those servers, but that does not imply any form of approval.
 */


/* BIOS keyboard functions
 */
#define KBDFUNC_READCHAR        0x00
#define KBDFUNC_PEEKCHAR        0x01
#define KBDFUNC_QUERYSHIFT      0x02
#define KBDFUNC_SETDELAYS       0x03
#define KBDFUNC_WRITECHAR       0x05
#define KBDFUNC_READEXTCHAR     0x10
#define KBDFUNC_PEEKEXTCHAR     0x11
#define KBDFUNC_QUERYEXTSHIFT   0x12


/* BIOS Data Area keyboard locations
 */
#define KBDDATA_KBDSHIFT       0x417
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\v86\scaffold\i386\xguest.h ===
/* x86 v1.0
 *
 * XGUEST.H
 * Guest processor definitions/conventions
 *
 * History
 * Created 20-Oct-90 by Jeff Parsons
 *
 * COPYRIGHT NOTICE
 * This source file may not be distributed, modified or incorporated into
 * another product without prior approval from the author, Jeff Parsons.
 * This file may be copied to designated servers and machines authorized to
 * access those servers, but that does not imply any form of approval.
 */


#define GUESTMEM_SIZE	(640*K)

#define GUESTMEM_MIN	(32*K)		// smallest PC size ever
#define GUESTMEM_MAX	(960*K) 	// uses all but the last 64k ROM block

#define GUESTVID_SIZE	(4*K)		// for MONO emulation
#define GUESTVID_SEG	(USHORT)0xB000

#define GUESTROM_SIZE	(64*K)
#define GUESTROM_SEG	(USHORT)0xF000

#define FLATMEM_SIZE	((1024+64)*K)


/* Processor-defined stuff
 */
#define IVT_BEGIN	0x0000		// IVT table
#define IVT_END 	0x03FF

#define RESET_SEG	(USHORT)0xFFFF	// processor reset address
#define RESET_OFF	0x0000


/* Useful macros
 */
#define LINEAR(seg,off) 	(((((ULONG)(seg)<<4)+(off))) & ulWrapMask)
#define LINEAR2(seg,off)	(((ULONG)(seg)<<4)+(off))
#define COMPOSITE(seg,off)	(((ULONG)(seg)<<16)|(off))
#define OFFCOMPOSITE(ul)	WORDOF(ul,0)
#define SEGCOMPOSITE(ul)	WORDOF(ul,1)

#define BYTESOFFSET(off)	LOBYTE(off), HIBYTE(off)
#define BYTESCOMPOSITE(seg,off) LOBYTE(off), HIBYTE(off), LOBYTE(seg), HIBYTE(seg)

/* x86 opcodes (the really useful ones anyway)
 */
#define OPX_ADDAXI      0x05
#define OPX_PUSHDS	0x1E
#define OPX_POPDS	0x1F
#define OPX_ES		0x26
#define OPX_CS		0x2E
#define OPX_SS		0x36
#define OPX_DS		0x3E
#define OPX_PUSHAX      0x50
#define OPX_POPAX       0x58
#define OPX_JO		0x70
#define OPX_JNO 	0x71
#define OPX_JB		0x72
#define OPX_JNB 	0x73
#define OPX_JZ		0x74
#define OPX_JNZ 	0x75
#define OPX_JBE 	0x76
#define OPX_JNBE	0x77
#define OPX_JS		0x78
#define OPX_JNS 	0x79
#define OPX_JP		0x7A
#define OPX_JNP 	0x7B
#define OPX_JL		0x7C
#define OPX_JGE 	0x7D
#define OPX_JLE 	0x7E
#define OPX_JG		0x7F
#define OPX_MOVSEG2	0x8C
#define OPX_LEA 	0x8D
#define OPX_MOV2SEG	0x8E
#define OPX_CBW         0x98
#define OPX_CWD         0x99
#define OPX_MOVALOFF	0xA0
#define OPX_MOVAXOFF	0xA1
#define OPX_MOVSB	0xA4
#define OPX_MOVSW	0xA5
#define OPX_MOVAL	0xB0
#define OPX_MOVCL	0xB1
#define OPX_MOVDL	0xB2
#define OPX_MOVBL	0xB3
#define OPX_MOVAH	0xB4
#define OPX_MOVCH	0xB5
#define OPX_MOVDH	0xB6
#define OPX_MOVBH	0xB7
#define OPX_MOVAX	0xB8
#define OPX_MOVCX	0xB9
#define OPX_MOVDX	0xBA
#define OPX_MOVBX	0xBB
#define OPX_MOVSP	0xBC
#define OPX_MOVBP	0xBD
#define OPX_MOVSI	0xBE
#define OPX_MOVDI	0xBF
#define OPX_RETNV	0xC2
#define OPX_RETN	0xC3
#define OPX_LES         0xC4
#define OPX_LDS         0xC5
#define OPX_RETFV	0xCA
#define OPX_RETF	0xCB
#define OPX_INT3        0xCC
#define OPX_INT 	0xCD
#define OPX_INTO        0xCE
#define OPX_IRET	0xCF
#define OPX_GBP 	0xD6	// invalid opcode used for guest breakpoints
#define OPX_XLAT        0xD7
#define OPX_JCXZ        0xE3
#define OPX_JMPR16	0xE9
#define OPX_JMPF	0xEA
#define OPX_JMPR8	0xEB
#define OPX_LOCK	0xF0
#define OPX_REPNZ	0xF2
#define OPX_REPZ	0xF3
#define OPX_CLC         0xF8
#define OPX_STC         0xF9
#define OPX_CLI         0xFA
#define OPX_STI         0xFB
#define OPX_GRP5	0xFF

/* Mnemonic ordinals (indexes into apszMnemonic)
 */
#define M_NONE		0
#define M_AAA		1
#define M_AAD		2
#define M_AAM		3
#define M_AAS		4
#define M_ADC		5
#define M_ADD		6
#define M_AND		7
#define M_ARPL		8
#define M_ASIZE 	9
#define M_BOUND 	10
#define M_BSF		11
#define M_BSR		12
#define M_BT		13
#define M_BTC		14
#define M_BTR		15
#define M_BTS		16
#define M_CALL		17
#define M_CBW		18
#define M_CLC		19
#define M_CLD		20
#define M_CLI		21
#define M_CLTS		22
#define M_CMC		23
#define M_CMP		24
#define M_CMPSB 	25
#define M_CMPSW 	26
#define M_CS		27
#define M_CWD		28
#define M_DAA		29
#define M_DAS		30
#define M_DEC		31
#define M_DIV		32
#define M_DS		33
#define M_ENTER 	34
#define M_ES		35
#define M_ESC		36
#define M_FADD		37
#define M_FBLD		38
#define M_FBSTP 	39
#define M_FCOM		40
#define M_FCOMP 	41
#define M_FDIV		42
#define M_FDIVR 	43
#define M_FIADD 	44
#define M_FICOM 	45
#define M_FICOMP	46
#define M_FIDIV 	47
#define M_FIDIVR	48
#define M_FILD		49
#define M_FIMUL 	50
#define M_FIST		51
#define M_FISTP 	52
#define M_FISUB 	53
#define M_FISUBR	54
#define M_FLD		55
#define M_FLDCW 	56
#define M_FLDENV	57
#define M_FMUL		58
#define M_FNSAVE	59
#define M_FNSTCW	60
#define M_FNSTENV	61
#define M_FNSTSW	62
#define M_FRSTOR	63
#define M_FS		64
#define M_FST		65
#define M_FSTP		66
#define M_FSUB		67
#define M_FSUBR 	68
#define M_GBP		69
#define M_GS		70
#define M_HLT		71
#define M_IDIV		72
#define M_IMUL		73
#define M_IN		74
#define M_INC		75
#define M_INS		76
#define M_INT		77
#define M_INT3		78
#define M_INTO		79
#define M_IRET		80
#define M_JBE		81
#define M_JB		82
#define M_JCXZ		83
#define M_JG		84
#define M_JGE		85
#define M_JL		86
#define M_JLE		87
#define M_JMP		88
#define M_JNBE		89
#define M_JNB		90
#define M_JNO		91
#define M_JNP		92
#define M_JNS		93
#define M_JNZ		94
#define M_JO		95
#define M_JP		96
#define M_JS		97
#define M_JZ		98
#define M_LAHF		99
#define M_LAR		100
#define M_LDS		101
#define M_LEA		102
#define M_LEAVE 	103
#define M_LES		104
#define M_LFS		105
#define M_LGDT		106
#define M_LGS		107
#define M_LIDT		108
#define M_LLDT		109
#define M_LMSW		110
#define M_LOCK		111
#define M_LODSB 	112
#define M_LODSW 	113
#define M_LOOP		114
#define M_LOOPNZ	115
#define M_LOOPZ 	116
#define M_LSL		117
#define M_LSS		118
#define M_LTR		119
#define M_MOV		120
#define M_MOVSB 	121
#define M_MOVSW 	122
#define M_MOVSX 	123
#define M_MOVZX 	124
#define M_MUL		125
#define M_NEG		126
#define M_NOP		127
#define M_NOT		128
#define M_OR		129
#define M_OSIZE 	130
#define M_OUT		131
#define M_OUTS		132
#define M_POP		133
#define M_POPA		134
#define M_POPF		135
#define M_PUSH		136
#define M_PUSHA 	137
#define M_PUSHF 	138
#define M_RCL		139
#define M_RCR		140
#define M_REPNZ 	141
#define M_REPZ		142
#define M_RET		143
#define M_RETF		144
#define M_ROL		145
#define M_ROR		146
#define M_SAHF		147
#define M_SAR		148
#define M_SBB		149
#define M_SCASB 	150
#define M_SCASW 	151
#define M_SETBE 	152
#define M_SETC		153
#define M_SETG		154
#define M_SETGE 	155
#define M_SETL		156
#define M_SETLE 	157
#define M_SETNBE	158
#define M_SETNC 	159
#define M_SETNO 	160
#define M_SETNP 	161
#define M_SETNS 	162
#define M_SETNZ 	163
#define M_SETO		164
#define M_SETP		165
#define M_SETS		166
#define M_SETZ		167
#define M_SGDT		156
#define M_SHL		169
#define M_SHLD		170
#define M_SHR		171
#define M_SHRD		172
#define M_SIDT		173
#define M_SLDT		174
#define M_SMSW		175
#define M_SS		176
#define M_STC		177
#define M_STD		178
#define M_STI		179
#define M_STOSB 	180
#define M_STOSW 	181
#define M_STR		182
#define M_SUB		183
#define M_TEST		184
#define M_VERR		185
#define M_VERW		186
#define M_WAIT		187
#define M_XCHG		188
#define M_XLAT		189
#define M_XOR		190
#define MTOTAL		191


/* ModRegRM masks and definitions
 */
#define REG_AL		0x00	// bits 0-2 are standard Reg encodings
#define REG_CL		0x01	//
#define REG_DL		0x02	//
#define REG_BL		0x03	//
#define REG_AH		0x04	//
#define REG_CH		0x05	//
#define REG_DH		0x06	//
#define REG_BH		0x07	//
#define REG_AX		0x08	//
#define REG_CX		0x09	//
#define REG_DX		0x0A	//
#define REG_BX		0x0B	//
#define REG_SP		0x0C	//
#define REG_BP		0x0D	//
#define REG_SI		0x0E	//
#define REG_DI		0x0F	//

#define REG_ES		0x00	// bits 0-1 are standard SegReg encodings
#define REG_CS		0x01	//
#define REG_SS		0x02	//
#define REG_DS		0x03	//
#define REG_FS		0x04	//
#define REG_GS		0x05	//

#define MODMASK 	0xC0	// mod/reg/rm definitions
#define MODSHIFT	6	//
#define MOD(m)		(((m)&MODMASK)>>MODSHIFT)
#define REGMASK 	0x38	//
#define REGSHIFT	3	//
#define REG(r)		(((r)&REGMASK)>>REGSHIFT)
#define RMMASK		0x07	//
#define RMSHIFT 	0	//
#define RM(b)		(((b)&RMMASK)>>RMSHIFT)
#define MODREGRM(m,r,b) ((BYTE)((((m)<<MODSHIFT)&MODMASK) | \
				(((r)<<REGSHIFT)&REGMASK) | \
				(((b)<<RMSHIFT )&RMMASK )))

#define MOD_NODISP	0x00	// use RM below, no displacement
#define MOD_DISP8	0x01	// use RM below + 8-bit displacement
#define MOD_DISP16	0x02	// use RM below + 16-bit displacement
#define MOD_REGISTER	0x03	// use REG above

#define RM_BXSI 	0x00	//
#define RM_BXDI 	0x01	//
#define RM_BPSI 	0x02	//
#define RM_BPDI 	0x03	//
#define RM_SI		0x04	//
#define RM_DI		0x05	//
#define RM_BP		0x06	// note: if MOD_NODISP, this is IMMOFF
#define RM_BX		0x07	//


/* Operand type descriptor masks and definitions
 *
 * Note that the letters in () in the comments refer to Intel's
 * nomenclature used in Appendix A of the 80386 Prog. Reference Manual.
 */
#define TYPE_SIZE	0x000F	// size field
#define TYPE_TYPE	0x00F0	// type field
#define TYPE_IREG	0x0F00	// implied register field
#define TYPE_OTHER	0xF000	// "other" field

// TYPE_SIZE values.  Note that some of the values (eg, TYPE_WORDIB
// and TYPE_WORDIW) imply the presence of a third operand, for those
// wierd cases....

#define TYPE_NONE	0x0000	//     (all other TYPE fields ignored)
#define TYPE_BYTE	0x0001	// (b) byte, regardless of operand size
#define TYPE_SBYTE	0x0002	//     same as above, but sign-extended
#define TYPE_WORD	0x0003	// (w) word, regardless...
#define TYPE_WORDD	0x0004	// (v) word or double-word, depending...
#define TYPE_DWORD	0x0005	// (d) double-word, regardless...
#define TYPE_FARP	0x0006	// (p) 32-bit or 48-bit pointer, depending
#define TYPE_2WORDD	0x0007	// (a) two memory operands (BOUND only)
#define TYPE_DESC	0x0008	// (s) 6 byte pseudo-descriptor
#define TYPE_WORDIB	0x0009	//     two source operands (eg, IMUL)
#define TYPE_WORDIW	0x000A	//     two source operands (eg, IMUL)

// TYPE_TYPE values.  Note that all values implying
// the presence of a ModRegRM byte are >= TYPE_MODRM (clever, eh?)

#define TYPE_IMM	0x0000	// (I) immediate data
#define TYPE_ONE	0x0010	//     implicit 1 (eg, shifts/rotates)
#define TYPE_IMMOFF	0x0020	// (A) immediate offset
#define TYPE_IMMREL	0x0030	// (J) immediate relative
#define TYPE_DSSI	0x0040	// (X) memory addressed by DS:SI
#define TYPE_ESDI	0x0050	// (Y) memory addressed by ES:DI
#define TYPE_IMPREG	0x0060	//     implicit register in TYPE_IREG
#define TYPE_IMPSEG	0x0070	//     implicit seg. register in TYPE_IREG
#define TYPE_MODRM	0x0080	// (E) standard ModRM decoding
#define TYPE_MEM	0x0090	// (M) ModRM refers to memory only
#define TYPE_REG	0x00A0	// (G) standard Reg decoding
#define TYPE_SEGREG	0x00B0	// (S) Reg selects segment register
#define TYPE_MODREG	0x00C0	// (R) Mod refers to register only
#define TYPE_CTLREG	0x00D0	// (C) Reg selects control register
#define TYPE_DBGREG	0x00E0	// (D) Reg selects debug register
#define TYPE_TSTREG	0x00F0	// (T) Reg selects test register

// TYPE_IREG values, based on the REG_* constants.
// For convenience, they include TYPE_IMPREG or TYPE_IMPSEG as appropriate.

#define TYPE_AL        (REG_AL<<8|TYPE_IMPREG|TYPE_BYTE)
#define TYPE_CL        (REG_CL<<8|TYPE_IMPREG|TYPE_BYTE)
#define TYPE_DL        (REG_DL<<8|TYPE_IMPREG|TYPE_BYTE)
#define TYPE_BL        (REG_BL<<8|TYPE_IMPREG|TYPE_BYTE)
#define TYPE_AH        (REG_AH<<8|TYPE_IMPREG|TYPE_BYTE)
#define TYPE_CH        (REG_CH<<8|TYPE_IMPREG|TYPE_BYTE)
#define TYPE_DH        (REG_DH<<8|TYPE_IMPREG|TYPE_BYTE)
#define TYPE_BH        (REG_BH<<8|TYPE_IMPREG|TYPE_BYTE)
#define TYPE_AX        (REG_AX<<8|TYPE_IMPREG|TYPE_WORD)
#define TYPE_CX        (REG_CX<<8|TYPE_IMPREG|TYPE_WORD)
#define TYPE_DX        (REG_DX<<8|TYPE_IMPREG|TYPE_WORD)
#define TYPE_BX        (REG_BX<<8|TYPE_IMPREG|TYPE_WORD)
#define TYPE_SP        (REG_SP<<8|TYPE_IMPREG|TYPE_WORD)
#define TYPE_BP        (REG_BP<<8|TYPE_IMPREG|TYPE_WORD)
#define TYPE_SI        (REG_SI<<8|TYPE_IMPREG|TYPE_WORD)
#define TYPE_DI        (REG_DI<<8|TYPE_IMPREG|TYPE_WORD)
#define TYPE_ES        (REG_ES<<8|TYPE_IMPSEG|TYPE_WORD)
#define TYPE_CS        (REG_CS<<8|TYPE_IMPSEG|TYPE_WORD)
#define TYPE_SS        (REG_SS<<8|TYPE_IMPSEG|TYPE_WORD)
#define TYPE_DS        (REG_DS<<8|TYPE_IMPSEG|TYPE_WORD)
#define TYPE_FS        (REG_FS<<8|TYPE_IMPSEG|TYPE_WORD)
#define TYPE_GS        (REG_GS<<8|TYPE_IMPSEG|TYPE_WORD)

// TYPE_OTHER bit definitions

#define TYPE_IN 	0x1000	// operand is input
#define TYPE_OUT	0x2000	// operand is output
#define TYPE_BOTH      (TYPE_IN|TYPE_OUT)
#define TYPE_86        (CPU_86	<< 14)
#define TYPE_186       (CPU_186 << 14)
#define TYPE_286       (CPU_286 << 14)
#define TYPE_386       (CPU_386 << 14)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\vdd\hpscan\sources.inc ===
TARGETNAME=
TARGETTYPE=NOTARGET
TARGETPATH=
SOURCES=

NTTARGETFILE1=buildall

SOURCES_USED=..\sources.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\v86\util\quit.asm ===
title  "Terminate execution of an NT VDM"
;++
;
; Copyright (c) 1989  Microsoft Corporation
;
; Module Name:
;
;    quit.asm
;
; Abstract:
;
;   This module is a simple dos executable that will terminate a  
;   Vdm.
;
; Author:
;
;   Dave Hastings (daveh) 25-Apr-1991
;
; Environment:
;
;    V86 mode only!!
;
; Revision History:
;
;--
.386
 

.xlist
include bop.inc
.list

code segment
        ASSUME CS:code
quit    proc near
        BOP BOP_UNSIMULATE
quit    endp

code ends
        end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\vdd\hpscan\usa\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH)
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\v86\scaffold\i386\xwincon.h ===
//
// borrowed for temprorary softpc console support
//


/*++ BUILD Version: 0001
 *
 * x86 v1.0
 *
 * XWINCON.H
 * Windows support functions for console windows
 *
 * History
 * Created 27-Dec-90 by Jeff Parsons
 *
 * COPYRIGHT NOTICE
 * This source file may not be distributed, modified or incorporated into
 * another product without prior approval from the author, Jeff Parsons.
 * This file may be copied to designated servers and machines authorized to
 * access those servers, but that does not imply any form of approval.
 */


typedef unsigned int UINT;	// ints preferred
typedef int INT;		// ints preferred
typedef CHAR *NPSZ;
typedef INT  (FAR PASCAL *INTPROC)(HWND, UINT, UINT, LONG);

#define DEF_CCHIN	16	// default input buffer size
#define DEF_CCHXOUT	80	// default output buffer width
#define DEF_CCHYOUT	25	// default output buffer height

#define CON_SCROLL_LOCK 0x0010	// console has SCROLL-LOCK set
#define CON_NUM_LOCK	0x0020	// console has NUM-LOCK set
#define CON_CAPS_LOCK	0x0040	// console has CAPS-LOCK set
#define CON_LEDS_MASK	0x0070	//
#define CON_FOCUS	0x0100	// console has focus

#ifndef VK_OEM_SCROLL
#define VK_OEM_SCROLL	0x91	// left out of windows.h for some reason...
#endif

#define INVALIDATE_SCROLL   2

#define IDM_DBBRK 100
#define IDM_ABOUT 101

#define CLR_BLACK		0x00000000
#define CLR_RED 		0x007F0000
#define CLR_GREEN		0x00007F00
#define CLR_BROWN		0x007F7F00
#define CLR_BLUE		0x0000007F
#define CLR_MAGENTA		0x007F007F
#define CLR_CYAN		0x00007F7F
#define CLR_LT_GRAY		0x00BFBFBF

#define CLR_DK_GRAY		0x007F7F7F
#define CLR_BR_RED		0x00FF0000
#define CLR_BR_GREEN		0x0000FF00
#define CLR_YELLOW		0x00FFFF00
#define CLR_BR_BLUE		0x000000FF
#define CLR_BR_MAGENTA		0x00FF00FF
#define CLR_BR_CYAN		0x0000FFFF
#define CLR_WHITE		0x00FFFFFF

#define OPT_FONT	0x0004	// use small OEM font if available (/s)
#define OPT_DOUBLE	0x0020	// use 50-line debug window w/small font (/50)
#define OPT_CAPS	0x0002	// map ctrl keys to caps-lock (/c)
#define OPT_TERMINAL	0x0010	// redirect all window output to terminal (/t)
#define OPT_FLUSH	0x0100	// flush prefetch after every jump (/f)
#define OPT_NOXLATE	0x0200	// disable built-in translations (/n)
#define OPT_DEBUG	0x0008	// shadow all log output on debug terminal (/d)
#define OPT_GO		0x0001	// do an initial "go" (/g)

#define CTRL_A		1	// used by gets to repeat last line
#define CTRL_C		3	// break in debug window
#define CTRL_Q		17	// flow control
#define CTRL_S		19	// flow control
#define BELL		7	//
#define BS		8	// backspace
#define TAB		9	//
#define LF		10	// linefeed
#define CR		13	// return
#define ESCAPE		27	//

#define SIGNAL_EMULATE 1
#define ERR_NONE 0x0

#define TRUE_IF_WIN32	1

/* Per-window information
 */
#ifdef WIN_16
#define GETPCONSOLE(hwnd)	(PCONSOLE)GetWindowWord(hwnd,0)
#define SETPCONSOLE(hwnd,p)	(PCONSOLE)SetWindowWord(hwnd,0,(INT)p)
#endif
#ifdef WIN_32
#define GETPCONSOLE(hwnd)	(PCONSOLE)GetWindowLong(hwnd,0)
#define SETPCONSOLE(hwnd,p)	(PCONSOLE)SetWindowLong(hwnd,0,(LONG)p)
#endif
#ifdef PM
#define GETPCONSOLE(hwnd)	(PCONSOLE)WinQueryWindowUShort(hwnd,0)
#define SETPCONSOLE(hwnd,p)	(PCONSOLE)WinSetWindowUShort(hwnd,0,(USHORT)p)
#endif

#define GETICARET(pcon) 	(pcon->chyCaret*pcon->cchxOut+pcon->chxCaret)
#define GETPCARET(pcon) 	(pcon->pchOut+GETICARET(pcon))
#define GETXCARET(pcon) 	(pcon->chxCaret*pcon->cxChar)
#ifdef WIN
#define GETYCARET(pcon) 	(pcon->chyCaret*pcon->cyChar)
#else
#define GETYCARET(pcon) 	(pcon->cyOut - pcon->chyCaret*pcon->cyChar)
#endif

#define GETILINE(pcon,chy)	((chy)*pcon->cchxOut)
#define GETPLINE(pcon,chy)	(pcon->pchOut+GETILINE(pcon,chy))

#define GETICHAR(pcon,chx,chy)	((chy)*pcon->cchxOut+(chx))
#define GETPCHAR(pcon,chx,chy)	(pcon->pchOut+GETICHAR(pcon,chx,chy))
#define GETXCHAR(pcon,chx)	(pcon->cxChar*(chx))
#ifdef WIN
#define GETYCHAR(pcon,chy)	(pcon->cyChar*(chy))
#else
#define GETYCHAR(pcon,chy)	(pcon->cyOut - pcon->cyChar*(chy))
#endif

#define WORDOF(i,n)	(((PWORD)&(i))[n])
#define LOW(l)		WORDOF(l,0)
#define NPVOID(p)   ((VOID *)(p))

typedef struct key_s {
    INT   iKey;
    LONG  lKeyType;
} KEY, *PKEY;

typedef struct console_s {
    INT   flCon;		// console flags (see CON_*)
    PKEY  pkIn; 		// pointer to input buffer
    HANDLE hkEvent;		// handle to key event
    INT   ikHead;		// input head (where to store next key)
    INT   ikTail;		// input tail (where to retrieve next key)
    INT   ikMax;		// maximum input index
    HFONT hFont;		// font identifier
    INT   cxChar;		// character width, in pixels
    INT   cyChar;		// character height, in pixels
    INT   cxOut;		// buffer width, in pixels
    INT   cyOut;		// buffer height, in pixels
    INT   cchxOut;		// buffer width, in chars
    INT   cchyOut;		// buffer height, in chars
    UINT  cbOut;		// buffer size, in bytes
    PCHAR pchOut;		// pointer to output buffer
    INT   chxCaret;		// caret x location, in char coordinates
    INT   chyCaret;		// caret y location, in char coordinates
} CONSOLE, *PCONSOLE;


/* Function prototypes
 */
PCONSOLE initconsole(HWND hwnd, INT cchIn, INT cchxOut, INT cchyOut, INT iFont);
VOID	 freeconsole(HWND hwnd);
VOID	 clearconsole(HWND hwnd);
VOID	 invalidateconsole(HWND hwnd, PRECT prc, BOOL fUpdate);

INT	 wprint(HWND hwnd, NPSZ psz, INT n);
INT	 wgetch(HWND hwnd);
BOOL	 wkbhit(HWND hwnd);
VOID	 wyield(HANDLE);
INT	 wputch(HWND hwnd, INT i);

VOID	 setcaret(HWND hwnd, INT x, INT y);
VOID	 getcaret(HWND hwnd, PINT px, PINT py);
VOID	 writechar(HWND hwnd, CHAR ch, INT n);
VOID	 scrollrect(HWND hwndGuest, PRECT prc, INT n);

extern HWND hwndGuest;
extern HANDLE hHostInstance;
extern INT  flOptions;	// command-line options (see OPT_*)
extern INT  flSignals;	// signal flags (see SIGNAL_*)

LONG FAR PASCAL VDMWndProc(HWND hwnd, UINT wMsg, UINT uParam, LONG lParam);
BOOL FAR PASCAL VDMAbout(HWND hDlg, UINT wMsg, UINT uParam, LONG lParam);

VOID	processmessages(HWND hwnd);
INT	getkbdleds(VOID);
VOID	setkbdleds(INT flCon);
VOID	mapkbdkeys(PCONSOLE pcon, UINT iParam, BOOL fDown);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\vdd\mscdex\tsr\sources.inc ===
TARGETNAME=
TARGETTYPE=NOTARGET
TARGETPATH=
SOURCES=

NTTARGETFILE1=buildall

SOURCES_USED=..\sources.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\v86\scaffold\i386\xbiosvid.h ===
//
// This code is temporary.  When Insignia supplies rom support, it should
// be removed.
//

/* x86 v1.0
 *
 * XBIOSVID.H
 * Guest ROM BIOS video emulation
 *
 * History
 * Created 20-Oct-90 by Jeff Parsons
 *         17-Apr-91 Trimmed by Dave Hastings for use in temp. softpc
 *
 * COPYRIGHT NOTICE
 * This source file may not be distributed, modified or incorporated into
 * another product without prior approval from the author, Jeff Parsons.
 * This file may be copied to designated servers and machines authorized to
 * access those servers, but that does not imply any form of approval.
 */


/* BIOS video functions
 */
#define VIDFUNC_SETMODE         0x00
#define VIDFUNC_SETCURSORTYPE   0x01
#define VIDFUNC_SETCURSORPOS    0x02
#define VIDFUNC_QUERYCURSORPOS  0x03
#define VIDFUNC_QUERYLPEN       0x04
#define VIDFUNC_SETACTIVEPAGE   0x05
#define VIDFUNC_SCROLLUP        0x06
#define VIDFUNC_SCROLLDOWN      0x07
#define VIDFUNC_READCHARATTR    0x08
#define VIDFUNC_WRITECHARATTR   0x09
#define VIDFUNC_WRITECHAR       0x0A
#define VIDFUNC_SETPALETTE      0x0B
#define VIDFUNC_WRITEPIXEL      0x0C
#define VIDFUNC_READPIXEL       0x0D
#define VIDFUNC_WRITETTY        0x0E
#define VIDFUNC_QUERYMODE       0x0F
#define VIDFUNC_EGASETPALETTE   0x10
#define VIDFUNC_EGASELECTFONT   0x11
#define VIDFUNC_EGASELECTMISC   0x12
#define VIDFUNC_EGAWRITESTRING  0x13
#define VIDFUNC_VGADISPLAYCODES 0x1A
#define VIDFUNC_VGAQUERYSTATE   0x1B
#define VIDFUNC_VGASAVERESTORE  0x1C

#define VIDMODE_MONO            7


/* BIOS Data Area video locations
 */
#define VIDDATA_CRT_MODE        0x449
#define VIDDATA_CRT_COLS        0x44A
#define VIDDATA_CRT_LEN         0x44C
#define VIDDATA_CRT_START       0x44E
#define VIDDATA_CURSOR_POSN     0x450
#define VIDDATA_CURSOR_MODE     0x460
#define VIDDATA_ACTIVE_PAGE     0x462
#define VIDDATA_ADDR_6845       0x463
#define VIDDATA_CRT_MODE_SET    0x465
#define VIDDATA_CRT_PALETTE     0x466
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\vdd\mscdex\tsr\usa\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH)
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\vdd\hpscan\hpscan16.inc ===
;*************************************************
; Name:	       HPSCAN16.INC
; Description: Defines for HPSCAN16.ASM
;*************************************************

;**----------- Segment Declarations ------------**
CSEG	segment word public 'CODE'
CSEG	ends	;header segment

;**-------------- Status Values ----------------**
STAT_OK      equ  0000h     ;ok
STAT_DONE    equ  0100h     ;function complete
STAT_GF      equ  800Ch     ;general failure

RH  EQU  ES:[BX]  ;request header

;**------ Common Request Header Structure ------**
RHC     struc     ;common to all commands
        db  ?     ;length of request header
        db  ?     ;unit code of device
RHC_CMD db  ?     ;command code
RHC_STA dw  ?     ;completion status, 16-bits
        dq  ?     ;reserved for DOS
        db  ?     ;this field varies with command
RHC_OFF dw  ?     ;offset of data
RHC_SEG dw  ?     ;segment of data
RHC_CNT dw  ?     ;byte count (length) of data
RHC     ends      ;end of common portion

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\vdd\hpscan\hpscan16.asm ===
.MODEL small
;*************************************************
; Filename:	hpscan16.asm
; Purpose:  Stub DOS Device Driver. Pass device 
;   "HPSCAN" requests to the VDD, hpscan32.dll.
; Environment: MSDOS, Windows NT.
; (C) Hewlett-Packard Company 1993.
;*************************************************
INCLUDE hpscan16.inc     ;private
INCLUDE isvbop.inc       ;NT DDK

SUBTTL Segment and data definitions
      ASSUME   CS:CSEG,DS:NOTHING,ES:NOTHING
CSEG  SEGMENT

;-------------------------------------------------
; Resident data area - variables needed after init
;-------------------------------------------------

;**--- Device Header, must be at offset zero ---**
SCAN_HEADER:
        dd -1         ;becomes ptr to next req hdr
        dw 0C000H     ;character, supports IOCTL
        dw offset STRAT     ;Strategy routine
        dw offset IDVR      ;Interrupt routine
DH_NAME db 'HPSCAN  '       ;char device name

;**---- Request Header addr, saved by STRAT ----**
RH_PTRA LABEL  DWORD
RH_PTRO        dw  ?   ;offset
RH_PTRS        dw  ?   ;segment

;**------------- Define Stack Space ------------**
STK_SEG  dw  ?        ;Save original stack segment
STK_PTR  dw  ?        ;Save original stack pointer
STACK    dw  200 DUP (0)     ;Local stack
TOP_STK  dw  ?        ;Top of local stack

;**--------------- VDD information -------------**
VDD_DllName      db  "HPSCAN32.DLL", 0
VDD_InitFunc     db  "VDDInit", 0
VDD_DispFunc     db  "VDDDispatch", 0
VDD_hVDD         dw  ?

;**-------------- Copyright Info ---------------**
  db '(C) Copyright Hewlett-Packard Company 1993.'
  db 'All rights reserved.'

SUBTTL Device Strategy & Interrupt entry points

;**--------------- STRAT routine ---------------**
STRAT  proc  far           ;Strategy routine
    mov  cs:RH_PTRO,bx     ;save offset address
    mov  cs:RH_PTRS,es     ;save segment address
    ret                    ;end Strategy routine
STRAT  endp

;**--------------- IDVR routine ---------------**
IDVR  proc  far     ;Interrupt routine
    push  ds        ;save all modified registers
    push  es        ;DOS has stack for 20 pushes
    push  ax
    push  bx
    push  cx
    push  dx
    push  di
    push  si
    push  bp

    mov  cs:STK_PTR,sp   ;save original stack ptr
    mov  cs:STK_SEG,ss   ;save original stack seg
    cli                  ;disable for stack ops
    mov  ax,cs           ;setup new stack ptr
    mov  ss,ax           ;setup new stack seg
    mov  sp,offset TOP_STK
    sti                  ;restore flags back
    cld                  ;all moves are forward

    les  bx,cs:RH_PTRA  ;load req hdr adr in es:bx
    mov  al,RH.RHC_CMD
    cmp  al,0           ;check for init command
    je   BOOTUP         ;command 0 = init

    xor  dx,dx          ;some other command
    mov  dl,RH.RHC_CMD  ;dx = command code
    mov  cx,RH.RHC_CNT  ;cx = count
    mov  ax,RH.RHC_SEG  ;es:bx = addr of data
    mov  bx,RH.RHC_OFF
    mov  es,ax          ;finally, load VDD handle
    mov  ax,word ptr cs:[VDD_hVDD]
    DispatchCall        ;call Dispatch in VDD
                        ;returns with status in di
EXIT:
    les  bx,cs:RH_PTRA  ;restore ES:BX
    or   di,STAT_DONE   ;add "DONE" bit to status
    mov  RH.RHC_STA,di  ;save status in requ hdr
    cli                 ;disable ints for stack op
    mov  ss,cs:STK_SEG  ;restore stack seg
    mov  sp,cs:STK_PTR  ;restore stack ptr  
    sti                 ;re-enable interrupts

    pop  bp             ;restore registers
    pop  si
    pop  di
    pop  dx
    pop  cx
    pop  bx
    pop  ax
    pop  es
    pop  ds
    ret                 ;far return
IDVR endp

;**--------- jump here for Init Command --------**
BOOTUP:
    mov  ax,offset EndDriver
    mov  RH.RHC_OFF,ax  ;address of end of driver
    mov  RH.RHC_SEG,CS  ;reference from code seg

    mov  si,offset VDD_DllName  ;load regs for VDD
    mov  di,offset VDD_InitFunc
    mov  bx,offset VDD_DispFunc
    mov  ax,ds
    mov  es,ax
    RegisterModule      ;calls the VDD
    jnc  save_hVDD      ;if NC then success
    mov  di,STAT_GF     ;set failure status
    jmp  EXIT           ;return via common exit

save_hVDD:
    mov  [VDD_hVDD],ax  ;save handle in ax
    mov  di,STAT_OK     ;load OK status
    jmp  EXIT           ;return via common exit

EndDriver db ?
CSEG    ENDS
        END  SCAN_HEADER ;REQUIRED BY EXE2BIN

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\vdd\mscdex\tsr\mscdexnt.inc ===
;----------------------------- E Q U A T E S ----------------------------
DOS_SET_VECTOR  equ     25h
DOS_GET_VECTOR  equ     35h
DOS_TSR         equ     31h

MPX_INT         equ     2fh
MSCDEX_ID       equ     15h
MAX_MSCDEX_CMD  equ     10h

GET_NT_VERSION      equ     3306h
NT_MAJOR_VERSION    equ     05
NT_MINOR_VERSION    equ     50

CR                  equ     0dh
LF                  equ     0Ah

;----------------------------- M A C R O S ------------------------------
DrvHd   MACRO   name
        DD      -1
        DW      0c840h
        DW      0
        DW      0
        DB      name
        dw      0
        db      0
        db      1
        db      10 dup (0)
        ENDM


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\vdd\mscdex\tsr\mscdexnt.asm ===
name    mscdexnt
;
;       MSCDEXNT
;
;   Author: Neil Sandlin (neilsa)
;
;   Description:
;
;       This TSR implements the v86 mode portion of MSCDEX support under
;       NT. Basically, all this piece does is hook INT2F and watch for
;       MSCDEX calls. When the first one occurs, it tries to load VCDEX.DLL.
;       If that succeeds, it passes the call (and all subsequent calls)
;       to VCDEX for processing.
;
        include isvbop.inc
        include mscdexnt.inc

_TEXT   segment word public 'CODE'
        assume cs:_TEXT,ds:_TEXT,es:_TEXT

;*-----------------------  TSR Code --------------------------*

DrvStrat proc   far              ; Strategy Routine
        ret
DrvStrat endp

DrvIntr proc    far                     ; INterrupt routine
        ret
DrvIntr endp

;******************************************************************************
;
;       Int2FHook
;
;
;******************************************************************************
Int2FHook  proc    near

        cmp     ah, MSCDEX_ID               ;MSCDEX?
        jnz     int2fchain                  ;no
        cmp     al, MAX_MSCDEX_CMD          ;command too high?
        ja      int2fchain                  ;yes

        cmp     word ptr cs:[hVDD], 0       ;zero is an invalid module handle
        jnz     callvdd                     ;registered ok

        cmp     byte ptr cs:[fVDDChecked],1
        jz      vddfailed

        call    RegisterVDD
        jc      vddfailed                   ;didn't get it

callvdd:
        push    ax                          ;put ax on stack
        mov     ax, word ptr cs:[hVDD]
        DispatchCall
        add     sp, 2                       ;vdd has set ax accordingly
        iret                                ;svc handled, return to caller

vddfailed:
        or      al,al
        jnz     try_0b
        xor     bx,bx
        jmp     short int2f_done
try_0b:
        cmp     al,0bh
        jne     int2f_done
;; williamh - June 1 1993 - if unable to load VDD, we should tell
;;                          the caller that the drive is NOT a cd rom.
        xor     ax, ax
        mov     bx,0adadh
int2f_done:
        iret

int2fchain:
        jmp     dword ptr cs:[oldint]

Int2FHook  endp

;****************************************************************************
;
;       RegisterVDD
;
;****************************************************************************
RegisterVDD proc    near

        push    ax
        push    bx
        push    cx
        push    dx
        push    si
        push    di
        push    ds
        push    es


        mov     ax, cs
        mov     ds, ax
        mov     es, ax
        ; Load vcdex.dll
        mov     si, offset DllName      ; ds:si = dll name
        mov     di, offset InitFunc     ; es:di = init routine
        mov     bx, offset DispFunc     ; ds:bx = dispatch routine

        push    cs                      ; pass far pointer to headers
        pop     cx                      ; in cx:dx
        mov     dx, offset drive_header

        RegisterModule
        jc      errorexit               ; jif error
        mov     cs:[hVDD],ax            ; save handle

errorexit:
        mov     byte ptr cs:[fVDDChecked],1
        pop     es
        pop     ds
        pop     di
        pop     si
        pop     dx
        pop     cx
        pop     bx
        pop     ax
        ret

RegisterVDD endp

;*-----------------------  TSR Data Area ---------------------*
oldint  dd      0
hVDD    DW      0

fVDDChecked DB  0       ; 0 - VDD never called. 1 - VDD once called.

DllName DB      "VCDEX.DLL",0
InitFunc  DB    "VDDRegisterInit",0
DispFunc  DB    "VDDDispatch",0


        ALIGN   16
drive_header:
        DrvHd   'MSCDEX00'

        ALIGN   16
Init_Fence:
;*-------------------------- Initialization Code ----------------------*

mscdexnt proc    far

        ; at this point es,ds -> PSP
        ; SS:SP points to stack

        ; first check that we are running under NT

        mov     ax, GET_NT_VERSION
        int     21h
        cmp     bl, NT_MAJOR_VERSION
        je      cdx_chk_more
        jmp     cdx_exit

cdx_chk_more:
        cmp     bh, NT_MINOR_VERSION
        je      cdx_ver_ok
        jmp     cdx_exit

cdx_ver_ok:
        ; Now check that this TSR is'nt already installed
        mov     ah,MSCDEX_ID
        mov     al,0bh                  ; call function 0b
        int     MPX_INT                 ; int 2f

        cmp     bx,0adadh
        jne     cdx_chks_done
        jmp     cdx_exit

cdx_chks_done:

        ; free the env segment

        push    es
        push    ds
        mov     es, es:[2ch]
        mov     ah, 49h
        int     21h

        mov     ah, DOS_GET_VECTOR
        mov     al, MPX_INT             ; 2f
        int     21h                     ; get old vector
        mov     WORD PTR cs:oldint,bx   ; save old vector here
        mov     WORD PTR cs:oldint+2,es

        mov     dx, offset Int2FHook
        push    cs                      ; get current code segment
        pop     ds
        mov     ah, DOS_SET_VECTOR
        mov     al, MPX_INT             ; vector to hook
        int     21h                     ; hook that vector

;
; Compute size of TSR area
;
        pop     ds
        pop     es
        mov     dx, offset Init_Fence   ; end of fixed TSR code
        mov     cl, 4                   ; divide by 16
        shr     dx, cl
        add     dx, 16                  ; add in PSP
;
; Terminate and stay resident
;
        mov     ah, DOS_TSR             ; TSR
        mov     al, 0
        int     21h                     ; TSR

cdx_exit:
        mov     ax,4c00h                 ; Exit
        int     21h

mscdexnt endp

_TEXT   ends

InitStack       segment para stack 'STACK'

        dw      256 dup (?)

top_of_stack    equ     $

InitStack       ends

        end     mscdexnt

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\vdd\mscdex\tsr\messages\usa\messages.inc ===
Message1    db  CR,LF,'MSCDEXNT Will Run Only Under Windows NT.',CR,LF,'$'
Message2    db  CR,LF,'MSCDEXNT is already installed.',CR,LF,'$'
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\vdd\mscdex\vdd\vcdex.h ===
#define MAXDRIVES 26

typedef VOID (*PFNSVC)(VOID);

typedef struct _DRIVE_INFO {
    HANDLE Handle;
    USHORT DriveNum;
    USHORT LogicalBlocksPerSecond;
    BOOLEAN Playing;
    BOOLEAN Paused;
    BOOLEAN ValidVTOC;
    BOOLEAN StatusAvailable;
    DWORD LastError;
    BYTE    MediaStatus;
    SECTOR_ADDR PlayStart; //BUGBUG zero on reset, new disc, play complete
    DWORD   PlayCount;
    SUB_Q_CURRENT_POSITION current;
    CDROM_TOC VTOC;
} DRIVE_INFO, *PDRIVE_INFO;


VOID ApiReserved (VOID);
VOID ApiGetNumberOfCDROMDrives (VOID);
VOID ApiGetCDROMDriveList (VOID);
VOID ApiGetCopyrightFileName (VOID);
VOID ApiGetAbstractFileName (VOID);
VOID ApiGetBDFileName (VOID);
VOID ApiReadVTOC (VOID);
VOID ApiAbsoluteDiskRead (VOID);
VOID ApiAbsoluteDiskWrite (VOID);
VOID ApiCDROMDriveCheck (VOID);
VOID ApiMSCDEXVersion (VOID);
VOID ApiGetCDROMDriveLetters (VOID);
VOID ApiGetSetVolDescPreference (VOID);
VOID ApiGetDirectoryEntry (VOID);
VOID ApiSendDeviceRequest (VOID);
VOID IOCTLRead (VOID);
VOID IOCTLWrite (VOID);

PCDROM_TOC ReadTOC (PDRIVE_INFO DrvInfo);
BOOLEAN GetAudioStatus (PDRIVE_INFO DrvInfo);

DWORD
ProcessError(
    PDRIVE_INFO DrvInfo,
    USHORT Command,
    USHORT Subcmd
    );

HANDLE
OpenPhysicalDrive(
    int DriveNum
    );




#define DEBUG_MOD    0x01
#define DEBUG_API    0x02
#define DEBUG_IO     0x04
#define DEBUG_STATUS 0x08
#define DEBUG_ERROR  0x80

#ifdef DEBUG

USHORT DebugLevel = 0;

#define DebugPrint(LEVEL,STRING)                \
    {                                           \
        if (DebugLevel & LEVEL)                 \
            OutputDebugString (STRING);         \
    }

#define DebugFmt(LEVEL,STRING, PARM)            \
    {                                           \
    char szBuffer[80];                          \
        if (DebugLevel & LEVEL) {               \
            sprintf (szBuffer, STRING, PARM);   \
            OutputDebugString (szBuffer);       \
        }                                       \
    }

#else

#define DebugPrint(LEVEL,STRING) {}
#define DebugFmt(LEVEL,STRING,PARM) {}

#endif


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\vdd\samples\adlibvdd\vdd.c ===
/****************************************************************************
 *
 *   config.c
 *
 *   Copyright (c) 1991 Microsoft Corporation.  All Rights Reserved.
 *
 ***************************************************************************/

/*
 *  Definition of interface to kernel driver (synth.sys)
 *
 *     The kernel driver's Dos device name is assumed fixed and known
 *
 *          adlib.mid or adlib.mid0
 *
 *     The kernel driver is opened in read/write mode.
 *
 *     Writing to the driver sends a list of SYNTH_DATA structures
 *     to the driver.  The port number MUST be 0x388 or 0x389.
 *
 *
 *     Reading always reads just 1 byte - the status port.
 */

#include <windows.h>              // The VDD is just a win32 DLL
#include <vddsvc.h>               // Definition of VDD calls
#include "vdd.h"                // Common data with kernel driver
#include <stdio.h>

/*
 *  Debugging
 */

#if DBG

    int VddDebugLevel = 1;


   /***************************************************************************

    Generate debug output in printf type format

    ****************************************************************************/

    void VddDbgOut(LPSTR lpszFormat, ...)
    {
        char buf[256];
        va_list va;

        OutputDebugStringA("Ad Lib VDD: ");

        va_start(va, lpszFormat);
        vsprintf(buf, lpszFormat, va);
        va_end(va);

        OutputDebugStringA(buf);
        OutputDebugStringA("\r\n");
    }

    #define dprintf( _x_ )                          VddDbgOut _x_
    #define dprintf1( _x_ ) if (VddDebugLevel >= 1) VddDbgOut _x_
    #define dprintf2( _x_ ) if (VddDebugLevel >= 2) VddDbgOut _x_
    #define dprintf3( _x_ ) if (VddDebugLevel >= 3) VddDbgOut _x_
    #define dprintf4( _x_ ) if (VddDebugLevel >= 4) VddDbgOut _x_


#else

    #define dprintf(x)
    #define dprintf1(x)
    #define dprintf2(x)
    #define dprintf3(x)
    #define dprintf4(x)

#endif // DBG


/*
 *   Symbolic names for port addresses
 */

 #define ADLIB_DATA_PORT 0x389
 #define ADLIB_REGISTER_SELECT_PORT 0x388
 #define ADLIB_STATUS_PORT 0x388

/*
 *   Batch data to the device - for true Adlib use a size of 2
 */

 #define BATCH_SIZE 40
 int Position = 0;
 SYNTH_DATA PortData[BATCH_SIZE];


/*
 *  Internal Routines
 */

 void MyByteIn(WORD port, BYTE *data);
 void MyByteOut(WORD port, BYTE data);

/*
 *  IO handler table.
 *
 *  There's no point in providing string handlers because the chip
 *  can't respond very quickly (need gaps of at least 23 microseconds
 *  between writes).
 */

 VDD_IO_HANDLERS handlers = {
     MyByteIn,
     NULL,
     NULL,
     NULL,
     MyByteOut,
     NULL,
     NULL,
     NULL};

/*
 *  Note that we rely on the kernel driver to pretend the device is
 *  at address 388 even the driver supports it somewhere else.
 */

 VDD_IO_PORTRANGE ports[] = {
    {
       0x228,
       0x229
    },
    {
       0x388,
       0x389
    }
 };

/*
 *  Globals
 */


 //
 // Track timers.  The basic rule is that if no timer is started then
 // the only way the status register can change is via the reset bit
 // in which case we know what will happen.
 //
 // If a timer interrupts then it's 'stopped'
 //

 BOOL Timer1Started;
 BOOL Timer2Started;
 BYTE Status;

/*
 *  Current device handle
 *
 *  NULL if device is (potentially) free
 *  INVALID_HANDLE_VALUE if device was not obtainable
 */

 HANDLE DeviceHandle;

 HANDLE OpenDevice(PWSTR DeviceName)
 {
     WCHAR DosDeviceName[MAX_PATH];


    /*
     *  Make up a string suitable for opening a Dos device
     */

     wcscpy(DosDeviceName, TEXT("\\\\."));
     wcscat(DosDeviceName, DeviceName +
                           wcslen(TEXT("\\Device")));

    /*
     *  Open the device with GENERIC_READ and GENERIC_WRITE
     *  Also use FILE_SHARE_WRITE so other applications can
     *  set the device volume
     */

     return         CreateFile(DosDeviceName,
                               GENERIC_WRITE | GENERIC_READ,
                               FILE_SHARE_WRITE,
                               NULL,
                               OPEN_EXISTING,
                               0,
                               NULL);

 }

/*
 *  Open our device is it can be opened and we haven't tried before
 *
 *  Returns FALSE if device can't be acquired.
 */

 BOOL CheckDeviceAccess(void)
 {

    /*
     *  If we don't have a handle (valid or invalid) already try
     *  opening the device
     */

     if (DeviceHandle == NULL) {

         DeviceHandle = OpenDevice(STR_ADLIB_DEVICENAME);

         if (DeviceHandle == INVALID_HANDLE_VALUE) {
             DeviceHandle = OpenDevice(STR_ADLIB_DEVICENAME L"0");
         }
         Position = 0;
     }

     return DeviceHandle != INVALID_HANDLE_VALUE;
 }

/*
 *  Map a write to a port
 *
 *  How are we going to simulate timer stuff?
 *  Answer: Allow reading of the status port.
 *
 *  This is optimized to only write when we get a data port write
 */


 void MyByteOut(WORD port, BYTE data)
 {
     //
     // Remember what register is selected
     //

     static BYTE AdlibRegister;

     //
     // Just package the stuff up and call write file
     //

     DWORD BytesWritten;

     dprintf3(("Received write to Port %4X, Data %2X", port, data));

     port = (port & 1) | ADLIB_REGISTER_SELECT_PORT;


    /*
     *  Check for special values - don't let them switch to
     *  OPL3 mode.
     */

#if 0
     if (port == ADLIB_DATA_PORT && AdlibRegister == AD_NEW) {
         data &= 0xFE;
     }
#endif


     if (port == ADLIB_REGISTER_SELECT_PORT) {
        /*
         *  Just remember which register is supposed to be selected
         *  to cut down the number of times we go to the device driver
         */

         AdlibRegister = data;
     } else {

        /*
         *  Write this one to the device
         */

         PortData[Position].IoPort = ADLIB_REGISTER_SELECT_PORT;
         PortData[Position].PortData = AdlibRegister;
         PortData[Position + 1].IoPort = port;
         PortData[Position + 1].PortData = data;

         Position += 2;

         if (Position == BATCH_SIZE ||
             AdlibRegister >= 0xA0 && AdlibRegister <= 0xBF ||
             AdlibRegister == AD_MASK) {

            /*
             *  See if we have the device
             */

             if (CheckDeviceAccess()) {

                 if (!WriteFile(DeviceHandle,
                                &PortData,
                                Position * sizeof(PortData[0]),
                                &BytesWritten,
                                NULL)) {
                     dprintf1(("Failed to write to device!"));
                 } else {
                    /*
                     *  Work out what status change may have occurred
                     */

                     if (AdlibRegister == AD_MASK) {

                        /*
                         *  Look for RST and starting timers
                         */

                         if (data & 0x80) {
                             Status = 0;
                         }

                        /*
                         *  We ignore starting of timers if their interrupt
                         *  flag is set because the timer status will have to
                         *  be set again to make the status for this timer change
                         */

                         if ((data & 1) && !(Status & 0x40)) {
                             dprintf2(("Timer 1 started"));
#if 0
                             Timer1Started = TRUE;
#else
                             Status |= 0xC0;
#endif
                         } else {
                             Timer1Started = FALSE;
                         }

                         if ((data & 2) && !(Status & 0x20)) {
                             dprintf2(("Timer 2 started"));
#if 0
                             Timer2Started = TRUE;
#else
                             Status |= 0xA0;
#endif
                             Timer2Started = TRUE;
                         } else {
                             Timer2Started = FALSE;
                         }
                     }
                 }
             }

             Position = 0;
         }
     }
 }


/*
 *  Gets called when the application reads from one of our ports.
 *  We know the device only returns interesting things in the status port.
 */

 void MyByteIn(WORD port, BYTE *data)
 {
     DWORD BytesRead;

     dprintf4(("Received read from Port %4X", port));

     port = (port & 1) | ADLIB_STATUS_PORT;

    /*
     *  If we fail simulate nothing at the port
     */

     *data = 0xFF;

    /*
     *  Say there's nothing there if we didn't get the device driver or
     *  it's not the status port
     */

     if (port != ADLIB_STATUS_PORT || !CheckDeviceAccess()) {
         return;
     }

#if 0 // WSS interrupt messed this up
    /*
     *  Are we expecting a state change ?
     */

     if (Timer1Started || Timer2Started) {

        /*
         *  Read the status port from the driver - this is how the
         *  driver interprets read.
         *  Well, actually don't because the WSS driver doesn't work!
         */

         if (!ReadFile(DeviceHandle,
                       &Status,
                       1,
                       &BytesRead,
                       NULL)) {

             dprintf1(("Failed to read from device - code %d", GetLastError()));
         } else {

            /*
             *  Look for state change
             */

             if (Status & 0x40) {
                 Timer1Started = FALSE;
                 dprintf2(("Timer 1 finished"));
             }

             if (Status & 0x20) {
                 Timer2Started = FALSE;
                 dprintf2(("Timer 2 finished"));
             }
         }
     }
#endif

     dprintf3(("Data read was %2X", Status));
     *data = Status;
 }


/*
 *  Standard DLL entry point routine.
 */

 BOOL DllEntryPoint(HINSTANCE hInstance, DWORD Reason, LPVOID Reserved)
 {
     switch (Reason) {
     case DLL_PROCESS_ATTACH:
         if (!VDDInstallIOHook(hInstance, 2, ports, &handlers)) {
             dprintf2(("Ad Lib VDD failed to load - error in VDDInstallIoHook"));
             return FALSE;
         } else {
             dprintf2(("Ad Lib VDD loaded OK"));
             return TRUE;
         }

     case DLL_PROCESS_DETACH:
         VDDDeInstallIOHook(hInstance, 2, ports);

        /*
         *  Note that  this event corresponds to FreeLibrary on our DLL,
         *  NOT termination of the process - so we can't rely on process
         *  termination to close our device handle.
         *
         */

         if (DeviceHandle) {
             CloseHandle(DeviceHandle);
             DeviceHandle = NULL;      // Redundant but neater.
         }
         return TRUE;

     default:
         return TRUE;
     }
 }



=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\vdd\mscdex\vdd\vcdex.c ===
/*++

Copyright (c) 1991, Microsoft Corporation

Module Name:

    vcdex.c

Abstract:

    Virtual Device Driver for MSCDEX

Environment:

    NT-MVDM (User Mode VDD)

Author:

    Neil Sandlin (neilsa), 3/20/93

Notes:

    Implementation Restrictions-

    Currently, the starting and ending locations returned by the mscdex
    "audio status info" are not returned by NT drivers. This makes it
    difficult to maintain these values when the calling applications
    exit, or when multiple applications are controlling a single drive.

    Currently, this implementation does not validate the length argument of
    the IOCTL calls. This needs to be added for robustness, but will not
    affect well-behaved apps.


Revision History:



--*/

//
// Include files.
//

#include "windows.h"
#include "winerror.h"
#include <vddsvc.h>
#include <mscdex.h>
#include "devioctl.h"
#include "ntddcdrm.h"
#include "ntdddisk.h"
#include "vcdex.h"

//
// Global variables.
//

PFNSVC  apfnSVC [] = {
    ApiGetNumberOfCDROMDrives,
    ApiGetCDROMDriveList,
    ApiGetCopyrightFileName,
    ApiGetAbstractFileName,
    ApiGetBDFileName,
    ApiReadVTOC,
    ApiReserved,
    ApiReserved,
    ApiAbsoluteDiskRead,
    ApiAbsoluteDiskWrite,
    ApiReserved,
    ApiCDROMDriveCheck,
    ApiMSCDEXVersion,
    ApiGetCDROMDriveLetters,
    ApiGetSetVolDescPreference,
    ApiGetDirectoryEntry,
    ApiSendDeviceRequest
};

PDRIVE_INFO DrivePointers[MAXDRIVES];
PDRIVE_INFO DrvInfo;
LPREQUESTHEADER VdmReq;                     // for "send device request"
USHORT NumDrives = 0, FirstDrive = 0xff;
DWORD DeviceHeader;                         // for "get CDROM drive list"
BYTE LastRealStatus = AUDIO_STATUS_NO_STATUS;
UCHAR g_bProtMode;                        // FALSE for v86, TRUE for 16:16 PM

#define IS_DRIVE_CDROM(drive)	    \
                        (drive < MAXDRIVES && DrivePointers[drive] != NULL)


HANDLE hVdd;
HANDLE hProcessHeap;



VOID UserBlockHook(VOID);
VOID UserTerminateHook(USHORT);



BOOL
VDDInitialize(
    HANDLE hDll,
    DWORD dwReason,
    LPVOID lpReserved
    )

/*++

Routine Description:

    The entry point for the Vdd which handles intialization and termination.

Arguments:

    hVdd   - The handle to the VDD

    Reason - flag word thatindicates why Dll Entry Point was invoked

    lpReserved - Unused

Return Value:
    BOOL bRet - if (dwReason == DLL_PROCESS_ATTACH)
                   TRUE    - Dll Intialization successful
                   FALSE   - Dll Intialization failed
                else
                   always returns TRUE
--*/

{
    int i;

    switch ( dwReason ) {

        case DLL_PROCESS_ATTACH:
            hVdd = hDll;
            hProcessHeap = GetProcessHeap();

            DisableThreadLibraryCalls(hDll);

            DebugPrint (DEBUG_MOD, "VCDEX: Process Attach\n");
            break;

        case DLL_PROCESS_DETACH:

            for (i=0; i<MAXDRIVES; i++)

                if (DrivePointers[i] != NULL) {

                    if (DrivePointers[i]->Handle != INVALID_HANDLE_VALUE) {
                        CloseHandle(DrivePointers[i]->Handle);
                    }
                    HeapFree(hProcessHeap, 0, DrivePointers[i]);

                }

            DebugPrint (DEBUG_MOD, "VCDEX: Process Detach\n");
            break;

        default:

            break;

    }

    return TRUE;

}



VOID
VDDRegisterInit(
    VOID
    )
/*++

Routine Description:

    This routine is called when the MSCDEXNT TSR makes its RegisterModule
    call. Most of the initialization is done here instead of in the
    VDDInitialize routine to improve performance in the case where the
    VDD is loaded, but not used.

    The main point of this routine is to search for CDROM drives and set
    up an array of pointers to point to DRIVE_INFO structures. The array
    is a fixed size array, one for each possible DOS drive. The structures
    are allocated only if a CDROM drive exists at the corresponding drive
    letter in the array.

    By doing a CreateFile() to the drive letter of the drive, a handle to
    the SCSI CDROM class driver is returned. This handle is used for all
    communication with the drive.



Return Value:

    SUCCESS - Client carry is clear
              Client CX = # of CDROM drives

    FAILURE - Client carry is set

--*/


{
    CHAR chRoot [] = "?:\\";
    USHORT i;
    HANDLE hDriver;
    PDRIVE_INFO drvp;
    static BOOLEAN Initialized = FALSE;

    if (Initialized) {
        setCF(0);
        return;
    }


    // Make far pointer with offset zero (DX is para aligned)
    DeviceHeader = (DWORD) ((getCX() << 16) + (getDX() << 12));

    for (i=0; i<MAXDRIVES; i++) {

        chRoot[0] = i + 'A';

        if (GetDriveType((LPSTR) chRoot) == DRIVE_CDROM) {

            hDriver = OpenPhysicalDrive(i);

            if (hDriver != INVALID_HANDLE_VALUE) {

                drvp = (PDRIVE_INFO)HeapAlloc(hProcessHeap,
                                              0,
                                              sizeof(DRIVE_INFO)
                                             );

                if(drvp == NULL) {
                    DebugPrint (DEBUG_MOD, "VCDEX: Out of memory on initializetion\n");
                    Initialized = FALSE;
                    setCF(1);
                    return;
                }

                DrivePointers[i]   = drvp;
                drvp->Handle       = hDriver;
                drvp->DriveNum     = i;
                drvp->ValidVTOC    = FALSE;
                drvp->MediaStatus  = MEDCHNG_CHANGED;

                drvp->PlayStart.dw = 0;
                drvp->PlayCount    = 0;
                GetAudioStatus (drvp);

                NumDrives++;
                if (FirstDrive == 0xff)
                    FirstDrive = i;


                //
                // Keep the handle close until app really wants to use it
                //
                drvp->Handle  = INVALID_HANDLE_VALUE;
                CloseHandle(hDriver);


            } else {
                DrivePointers[i] = NULL;
            }

        }

    }

    if (NumDrives == 0) {

        setCF(1);

    } else {
        PDEVICE_HEADER pDev = (PDEVICE_HEADER) GetVDMPointer(
                                                    ((ULONG)getCX()<<16)+getDX(),
                                                    1, FALSE);

        // Put the first valid cdrom drive number in the device header
        pDev->drive = FirstDrive+1;

        VDDInstallUserHook(hVdd, NULL, UserTerminateHook, UserBlockHook, NULL);

        DebugPrint (DEBUG_MOD, "VCDEX: Initialized\n");
        Initialized = TRUE;

        setCF(0);

    }

    return;
}


VOID UserTerminateHook(USHORT Pdb)
{
    UserBlockHook();
}


VOID UserBlockHook(VOID)
{

    int DrvNum;

    DrvNum = MAXDRIVES;
    while (DrvNum--) {
       if (DrivePointers[DrvNum] &&
           DrivePointers[DrvNum]->Handle != INVALID_HANDLE_VALUE )
         {
           CloseHandle(DrivePointers[DrvNum]->Handle);
           DrivePointers[DrvNum]->Handle = INVALID_HANDLE_VALUE;
       }
    }
}






BOOL
VDDDispatch(
    VOID
    )
/*++

Routine Description:

    This is the main MSCDEX api function dispatcher.

    It's called in protected mode by DPMI's end-of-PM-chain Int 2f handler,
    as well as in v86 mode by the MSCDEX TSR.  This allows us to avoid
    the transition to v86 mode to handle PM calls, and more importantly
    skips the translation of buffers to below 1MB, because the VDD
    keeps track of the client processor mode and translates pointers
    appropriately.

    When this routine is entered from the TSR, an int2f has just been
    executed. Client registers are set to what they were at the time
    of the call with the exception of AX, which must contain a handle
    for the DispatchCall(). The value of AX was pushed on the stack.
    So, this routine restores it, and uses AL to index into the function
    call table apfnSVC[].  The TSR has already ensured AL will not
    index past apfnSVC, and chained such calls on to the previous handler.
    The return value of VDDDispatch is ignored.

    When this routine is enterd from DPMI, an int2f has just reached
    its prot-mode handler and the client AX is still intact.  However
    we are responsible for bounds-checking AL and returning FALSE for
    unhandled Int 2f AH=15 calls, so that DPMI can chain to the
    real-mode handlers.  For calls handled by MSCDEX, we return
    success or failure in the client carry bit.


Return Value:

    TRUE  - Handled by the TSR, client carry indicates success:
        SUCCESS - Client carry is clear
        FAILURE - Client carry is set

    FALSE - Only in protmode for unhandled Int 2f AH=15 calls,
            client registers untouched.
--*/

{

    BOOL    bHandled = TRUE;
    LPWORD  VdmWordPtr;
    WORD    VdmAX;
    ULONG   VdmAddress;

    g_bProtMode = ( getMSW() & MSW_PE );

    if (g_bProtMode) {

        //
        // Called by DPMI's PM Int 2f handler, AX is still in client regs.
        //

        VdmAX = getAX();

        //
        // The TSR chains on unsupported int 2f ah=15 calls to the
        // previous handler.  DPMI passes all int 2f ah=15 calls to
        // us and we have to return TRUE or FALSE to let it know if
        // we handled it (and therefore it shouldn't be chained on).
        // Unsupported ah=15 calls in protmode will come through the
        // VDD twice, first in protmode then in v86 mode.
        //

        if ( (VdmAX & 0xFF) >= (sizeof(apfnSVC) / sizeof(apfnSVC[0]))) {
            bHandled = FALSE;
            goto Return_bHandled;
        }

    } else {

        //
        // The TSR pushes AX on the stack. Pick up the value here.
        //

        VdmAddress = ( getSS() << 16 ) | getSP();

        VdmWordPtr = (LPWORD) GetVDMPointer ( VdmAddress, 2, FALSE );

        VdmAX = *VdmWordPtr;

        //
        // AL has the MSCDEX function code
        //
        setAX (VdmAX);                      //restore AX
    }

    (apfnSVC [VdmAX & 0xFF])();

  Return_bHandled:

    return bHandled;
}



/****************************************************************************

        MSCDEX API SUBROUTINES

    The following routines perform the individual functions specified by
    the MSCDEX extensions.


 ****************************************************************************/
VOID
ApiReserved(
    VOID
    )

{

    DebugFmt (DEBUG_API, "VCDEX: Reserved Function call, ax=%.4X\n", getAX());

}


VOID
ApiGetNumberOfCDROMDrives(
    VOID
    )

{

    DebugPrint (DEBUG_API, "VCDEX: Get # of CDROM drives\n");

    setBX (NumDrives);

    if (NumDrives)
        setCX (FirstDrive);

}


VOID
ApiGetCDROMDriveList(
    VOID
    )

{

    PDRIVE_DEVICE_LIST devlist, devlist0;
    ULONG   VdmAddress;
    USHORT  Drive;
    BYTE    Unit;

    DebugPrint (DEBUG_API, "VCDEX: Get CDROM drive list\n");

    VdmAddress = ( getES() << 16 ) | getBX();
    devlist = devlist0 = (PDRIVE_DEVICE_LIST) GetVDMPointer (VdmAddress,
                                          MAXDRIVES*sizeof(DRIVE_DEVICE_LIST),
                                          g_bProtMode);

    for (Drive=0, Unit=0; Drive<MAXDRIVES; Drive++)
        if (DrivePointers[Drive] != NULL) {
            devlist->Unit = Unit;
            devlist->DeviceHeader = DeviceHeader;
            devlist++;
            Unit++;
        }

    FreeVDMPointer (VdmAddress,
                    MAXDRIVES*sizeof(DRIVE_DEVICE_LIST),
                    devlist0,
                    g_bProtMode);


}

VOID
ApiGetCopyrightFileName(
    VOID
    )
{
    ULONG   VdmAddress;
    LPBYTE  fnBuffer;

    DebugPrint (DEBUG_API, "VCDEX: Get Copyright File Name\n");

    if (!IS_DRIVE_CDROM(getCX())) {	// Is drive CDROM?
        setAX (15);                         // no
        setCF (1);
    }

    VdmAddress = ( getES() << 16 ) | getBX();
    fnBuffer = (LPBYTE) GetVDMPointer (VdmAddress, 38, g_bProtMode);

    *fnBuffer = 0;                  // currently not implemented

    FreeVDMPointer (VdmAddress, 38, fnBuffer, g_bProtMode);

}

VOID
ApiGetAbstractFileName(
    VOID
    )
{

    ULONG   VdmAddress;
    LPBYTE  fnBuffer;

    DebugPrint (DEBUG_API, "VCDEX: Get Abstract File Name\n");

    if (!IS_DRIVE_CDROM(getCX())) {	// Is drive CDROM?
        setAX (15);                         // no
        setCF (1);
    }

    VdmAddress = ( getES() << 16 ) | getBX();
    fnBuffer = (LPBYTE) GetVDMPointer (VdmAddress, 38, g_bProtMode);

    *fnBuffer = 0;                  // currently not implemented

    FreeVDMPointer (VdmAddress, 38, fnBuffer, g_bProtMode);

}


VOID
ApiGetBDFileName(
    VOID
    )
{

    ULONG   VdmAddress;
    LPBYTE  fnBuffer;

    DebugPrint (DEBUG_API, "VCDEX: Get Bibliographic Doc File Name\n");

    if (!IS_DRIVE_CDROM(getCX())) {	// Is drive CDROM?
        setAX (15);                         // no
        setCF (1);
    }

    VdmAddress = ( getES() << 16 ) | getBX();
    fnBuffer = (LPBYTE) GetVDMPointer (VdmAddress, 38, g_bProtMode);

    *fnBuffer = 0;                  // currently not implemented

    FreeVDMPointer (VdmAddress, 38, fnBuffer, g_bProtMode);

}

VOID
ApiReadVTOC(
    VOID
    )
{

    DebugPrint (DEBUG_API, "VCDEX: Read VTOC\n");
    setCF(1);                       // currently not implemented

}



VOID
ApiAbsoluteDiskRead(
    VOID
    )
{

    DebugPrint (DEBUG_API, "VCDEX: Absolute Disk Read\n");
    setCF(1);                       // currently not implemented

}

VOID
ApiAbsoluteDiskWrite(
    VOID
    )
{
    DebugPrint (DEBUG_API, "VCDEX: Absolute Disk Write\n");
    setCF(1);                       // read only
}


VOID
ApiCDROMDriveCheck(
    VOID
    )

{

    DebugPrint (DEBUG_API, "VCDEX: CDROM drive check\n");

    setBX (0xADAD);                     // MSCDEX Signature

    if (IS_DRIVE_CDROM(getCX()))	// is CD ROM drive
        setAX (1);                      // yes
    else
        setAX (0);                      // no

}

VOID
ApiMSCDEXVersion(
    VOID
    )

{
    DebugPrint (DEBUG_API, "VCDEX: MSCDEX Version\n");
    setBX (MSCDEX_VERSION);                     // MSCDEX Version #

}

VOID
ApiGetCDROMDriveLetters(
    VOID
    )

{
    ULONG   VdmAddress;
    LPBYTE  VdmPtr, VdmPtr0;
    USHORT  Drive;

    DebugPrint (DEBUG_API, "VCDEX: Get CDROM Drive Letters\n");

    VdmAddress = (getES() << 16) | getBX();
    VdmPtr = VdmPtr0 = (LPBYTE) GetVDMPointer (VdmAddress, MAXDRIVES, g_bProtMode);

    for (Drive=0; Drive<MAXDRIVES; Drive++)
        if (DrivePointers[Drive] != NULL)
            *VdmPtr++ = (BYTE) Drive;

    FreeVDMPointer (VdmAddress, MAXDRIVES, VdmPtr0, g_bProtMode);

}


VOID
ApiGetSetVolDescPreference(
    VOID
    )
{

    DebugPrint (DEBUG_API, "VCDEX: Set Volume Descriptor Preference\n");
    setCF(1);                       // currently not implemented

}

VOID
ApiGetDirectoryEntry(
    VOID
    )
{

    DebugPrint (DEBUG_API, "VCDEX: Get Directory Entry\n");
    setCF(1);                       // currently not implemented

}



VOID
ApiSendDeviceRequest(
    VOID
    )
{

    ULONG   VdmAddress;
    BOOL    Success;
    DWORD   BytesReturned;
    DWORD absStart, absEnd;
    int     DrvNum;

    VdmAddress = ( getES() << 16 ) | getBX();
    VdmReq = (LPREQUESTHEADER) GetVDMPointer (VdmAddress,
                                              sizeof (REQUESTHEADER),
                                              g_bProtMode);


    DebugFmt (DEBUG_IO, ">RQ %d ", (DWORD) VdmReq->rhFunction);

    DrvNum = getCX();

    if (!IS_DRIVE_CDROM(DrvNum)) {
        VdmReq->rhStatus = CDSTAT_ERROR | CDSTAT_DONE | CDERR_UNKNOWN_UNIT;
        return;

    }

    DrvInfo = DrivePointers[DrvNum];

    if (DrvInfo->Handle == INVALID_HANDLE_VALUE) {
        DrvInfo->Handle = OpenPhysicalDrive(DrvInfo->DriveNum);
        if (DrvInfo->Handle == INVALID_HANDLE_VALUE) {
            VdmReq->rhStatus = CDSTAT_ERROR | CDSTAT_DONE | CDERR_UNKNOWN_UNIT;
            HeapFree(hProcessHeap, 0, DrvInfo);
            DrivePointers[DrvNum] = NULL;
            NumDrives--;
            if (FirstDrive == DrvNum) {
                FirstDrive = 0xff;
                while (++DrvNum < MAXDRIVES) {
                    if (DrivePointers[DrvNum]) {
                        FirstDrive = (USHORT)DrvNum;
                        break;
                    }
                }
            }

            return;
        }
    }


    GetAudioStatus (DrvInfo);

    if (DrvInfo->Playing)
        VdmReq->rhStatus |= CDSTAT_BUSY;

    switch (VdmReq->rhFunction) {

        case IOCTL_READ:

            IOCTLRead();

            break;

        case IOCTL_WRITE:

            IOCTLWrite();

            break;

        case INPUT_FLUSH:
        case OUTPUT_FLUSH:
        case DEVICE_OPEN:
        case DEVICE_CLOSE:
        case READ_LONG:
        case READ_LONG_PREFETCH:
        case SEEK:
            DebugPrint (DEBUG_API, "Unsupported MSCDEX Device Request\n");
            VdmReq->rhStatus = CDSTAT_ERROR | CDERR_UNKNOWN_CMD;
            CloseHandle(DrvInfo->Handle);
            DrvInfo->Handle = INVALID_HANDLE_VALUE;
            break;

        case PLAY_AUDIO: {

            CDROM_PLAY_AUDIO_MSF PlayAudioMSF;
            PPLAY_AUDIO_BLOCK playreq = (PPLAY_AUDIO_BLOCK) VdmReq;

            if (playreq->addrmode == MODE_HSG) {

                absStart = playreq->startsect.dw;
                PlayAudioMSF.StartingM = (BYTE) (absStart / (75 * 60));
                PlayAudioMSF.StartingS = (BYTE) ((absStart / 75) % 60);
                PlayAudioMSF.StartingF = (BYTE) (absStart % 75);

            } else if (playreq->addrmode == MODE_REDBOOK) {

                PlayAudioMSF.StartingM = playreq->startsect.b[2];
                PlayAudioMSF.StartingS = playreq->startsect.b[1];
                PlayAudioMSF.StartingF = playreq->startsect.b[0];

                absStart = (PlayAudioMSF.StartingM * 75 * 60) +
                           (PlayAudioMSF.StartingS * 75) +
                           (PlayAudioMSF.StartingF);
            } else {

                VdmReq->rhStatus = CDSTAT_ERROR | CDERR_PARAMETER;
                break;

            }

            absEnd = absStart + playreq->numsect - 1;

            PlayAudioMSF.EndingM = (BYTE) (absEnd / (75 * 60));
            PlayAudioMSF.EndingS = (BYTE) ((absEnd / 75) % 60);
            PlayAudioMSF.EndingF = (BYTE) (absEnd % 75);

            DebugPrint (DEBUG_IO, "Play ");

            Success = DeviceIoControl (DrvInfo->Handle,
                                      (DWORD) IOCTL_CDROM_PLAY_AUDIO_MSF,
                                      (LPVOID) &PlayAudioMSF,
                                      sizeof (CDROM_PLAY_AUDIO_MSF),
                                      (LPVOID) NULL, 0,
                                      &BytesReturned, (LPVOID) NULL);

            if (!Success)

                ProcessError (DrvInfo, PLAY_AUDIO,0);

            else {

                DrvInfo->Playing = TRUE;
                DrvInfo->Paused = FALSE;
                DrvInfo->PlayStart.dw = playreq->startsect.dw;
                DrvInfo->PlayCount = playreq->numsect;

            }

            break;
        }

        case STOP_AUDIO:

            if (DrvInfo->Playing) {

                DebugPrint (DEBUG_IO, "Pause ");
                Success = DeviceIoControl (DrvInfo->Handle,
                                          (DWORD) IOCTL_CDROM_PAUSE_AUDIO,
                                          (LPVOID) NULL, 0,
                                          (LPVOID) NULL, 0,
                                          &BytesReturned, (LPVOID) NULL);

                if (!Success)

                    ProcessError (DrvInfo, STOP_AUDIO,0);

                else {
                    DrvInfo->Playing = FALSE;
                    DrvInfo->Paused = TRUE;
                }

            } else {

                DebugPrint (DEBUG_IO, "Stop ");

                Success = DeviceIoControl (DrvInfo->Handle,
                                          (DWORD) IOCTL_CDROM_STOP_AUDIO,
                                          (LPVOID) NULL, 0,
                                          (LPVOID) NULL, 0,
                                          &BytesReturned, (LPVOID) NULL);

                // Fake out GetAudioStatus to simulate stop
                DrvInfo->Playing = FALSE;
                DrvInfo->Paused = FALSE;
                LastRealStatus = AUDIO_STATUS_PLAY_COMPLETE;

                if (!Success) {
                    DWORD dwErr;

                    dwErr = GetLastError();
                    if (dwErr == ERROR_MR_MID_NOT_FOUND ||
                        dwErr == ERROR_NO_MEDIA_IN_DRIVE )
                      {
                       CloseHandle(DrvInfo->Handle);
                       DrvInfo->Handle = INVALID_HANDLE_VALUE;
                    }
                }

            }

            break;

        case WRITE_LONG:
        case WRITE_LONG_VERIFY:

            VdmReq->rhStatus = CDSTAT_ERROR | CDERR_WRITE_PROTECT;
            CloseHandle(DrvInfo->Handle);
            DrvInfo->Handle = INVALID_HANDLE_VALUE;

            break;

        case RESUME_AUDIO:

            if (DrvInfo->Paused) {

                DebugPrint (DEBUG_IO, "Resume ");
                Success = DeviceIoControl (DrvInfo->Handle,
                                          (DWORD) IOCTL_CDROM_RESUME_AUDIO,
                                          (LPVOID) NULL, 0,
                                          (LPVOID) NULL, 0,
                                          &BytesReturned, (LPVOID) NULL);

                if (!Success)

                    ProcessError (DrvInfo, RESUME_AUDIO,0);

            } else {

                VdmReq->rhStatus = CDSTAT_ERROR | CDERR_GENERAL;
                CloseHandle(DrvInfo->Handle);
                DrvInfo->Handle = INVALID_HANDLE_VALUE;
            }

            break;

        default:
            DebugPrint (DEBUG_API, "Invalid MSCDEX Device Request\n");
            VdmReq->rhStatus = CDSTAT_ERROR | CDERR_UNKNOWN_CMD;
            CloseHandle(DrvInfo->Handle);
            DrvInfo->Handle = INVALID_HANDLE_VALUE;

    }

    VdmReq->rhStatus |= CDSTAT_DONE;

    DebugFmt (DEBUG_IO, ": %.4X   ", VdmReq->rhStatus);

}

VOID
IOCTLRead(
    VOID
    )

{

    LPBYTE Buffer;
    BOOL Success;
    DWORD   BytesReturned;

    Buffer = GetVDMPointer ((ULONG)VdmReq->irwrBuffer, 16, g_bProtMode);

    DebugFmt (DEBUG_IO, "iord %d ", (DWORD) *Buffer);

    switch (*Buffer) {

        case IOCTLR_AUDINFO: {

            PIOCTLR_AUDINFO_BLOCK audinfo = (PIOCTLR_AUDINFO_BLOCK) Buffer;
            VOLUME_CONTROL VolumeControl;

            Success = DeviceIoControl (DrvInfo->Handle,
                                      (DWORD) IOCTL_CDROM_GET_VOLUME,
                                      (LPVOID) NULL, 0,
                                      (LPVOID) &VolumeControl,
                                      sizeof (VOLUME_CONTROL),
                                      &BytesReturned, (LPVOID) NULL);

            if (Success) {

                // no support for input=>output channel manipulation
                audinfo->chan0 = 0;
                audinfo->chan1 = 1;
                audinfo->chan2 = 2;
                audinfo->chan3 = 3;

                audinfo->vol0 = VolumeControl.PortVolume[0];
                audinfo->vol1 = VolumeControl.PortVolume[1];
                audinfo->vol2 = VolumeControl.PortVolume[2];
                audinfo->vol3 = VolumeControl.PortVolume[3];

            } else {
                CloseHandle(DrvInfo->Handle);
                DrvInfo->Handle = INVALID_HANDLE_VALUE;
            }

            break;
        }

        case IOCTLR_DEVSTAT: {

            PIOCTLR_DEVSTAT_BLOCK devstat = (PIOCTLR_DEVSTAT_BLOCK) Buffer;

            devstat->devparms = DEVSTAT_DOOR_UNLOCKED |
                                DEVSTAT_SUPPORTS_RBOOK;


            if (!DrvInfo->StatusAvailable) {

                DrvInfo->MediaStatus = MEDCHNG_CHANGED;
                CloseHandle(DrvInfo->Handle);
                DrvInfo->Handle = INVALID_HANDLE_VALUE;

                switch (DrvInfo->LastError) {
                    case ERROR_NO_MEDIA_IN_DRIVE:
                        devstat->devparms |= DEVSTAT_NO_DISC |
                                             DEVSTAT_DOOR_OPEN;

                        DebugFmt (DEBUG_STATUS, ":%.4X ", devstat->devparms);

                        break;
                    //BUGBUG case for recently inserted (80000016) - see below
                }

                break;
            }

            if (!(DrvInfo->current.Control & AUDIO_DATA_TRACK))
                devstat->devparms |= DEVSTAT_PLAYS_AV;

            break;
        }

        case IOCTLR_VOLSIZE: {

            PIOCTLR_VOLSIZE_BLOCK volsize = (PIOCTLR_VOLSIZE_BLOCK) Buffer;
            PTRACK_DATA Track;
            PCDROM_TOC cdromtoc;

            if ((cdromtoc = ReadTOC (DrvInfo))!=NULL) {

                Track = &cdromtoc->TrackData[cdromtoc->LastTrack];

                volsize->size = (DWORD) ( (Track->Address[1]*60*75) +
                                          (Track->Address[2]*75) +
                                           Track->Address[3]      );

            }
            break;
        }

        case IOCTLR_MEDCHNG: {

            PIOCTLR_MEDCHNG_BLOCK medptr = (PIOCTLR_MEDCHNG_BLOCK) Buffer;
            BYTE status = DrvInfo->MediaStatus;

            if (status == MEDCHNG_NOT_CHANGED) {

                Success = DeviceIoControl (DrvInfo->Handle,
                                          (DWORD) IOCTL_CDROM_CHECK_VERIFY,
                                          (LPVOID) NULL, 0,
                                          (LPVOID) NULL, 0,
                                          &BytesReturned, (LPVOID) NULL);

                if (Success)

                    medptr->medbyte = MEDCHNG_NOT_CHANGED;

                else {

                    medptr->medbyte = MEDCHNG_CHANGED;
                    DrvInfo->MediaStatus = MEDCHNG_CHANGED;
                    CloseHandle(DrvInfo->Handle);
                    DrvInfo->Handle = INVALID_HANDLE_VALUE;
                }

            } else
                medptr->medbyte = DrvInfo->MediaStatus;

            break;
        }

        case IOCTLR_DISKINFO: {

            PIOCTLR_DISKINFO_BLOCK diskinfo = (PIOCTLR_DISKINFO_BLOCK) Buffer;
            PTRACK_DATA Track;
            PCDROM_TOC cdromtoc;

            if ((cdromtoc = ReadTOC (DrvInfo))!=NULL) {
                diskinfo->tracklow = cdromtoc->FirstTrack;
                diskinfo->trackhigh = cdromtoc->LastTrack;

                Track = &cdromtoc->TrackData[cdromtoc->LastTrack];

                diskinfo->startleadout.b[0] = Track->Address[3];
                diskinfo->startleadout.b[1] = Track->Address[2];
                diskinfo->startleadout.b[2] = Track->Address[1];
                diskinfo->startleadout.b[3] = Track->Address[0];

            } else {

                // zeroes apparently needed when not there physically
                diskinfo->tracklow = 0;
                diskinfo->trackhigh = 0;
                diskinfo->startleadout.dw = 0;

            }
            break;
        }

        case IOCTLR_TNOINFO: {

            PIOCTLR_TNOINFO_BLOCK tnoinfo = (PIOCTLR_TNOINFO_BLOCK) Buffer;
            PTRACK_DATA Track;
            PCDROM_TOC cdromtoc;

            if ((cdromtoc = ReadTOC (DrvInfo))!=NULL) {

                if (tnoinfo->trknum > cdromtoc->LastTrack) {
                    VdmReq->rhStatus = CDSTAT_ERROR | CDERR_SECT_NOTFOUND;
                    break;
                }

                Track = &cdromtoc->TrackData[tnoinfo->trknum-1];
                tnoinfo->start.b[0] = Track->Address[3];
                tnoinfo->start.b[1] = Track->Address[2];
                tnoinfo->start.b[2] = Track->Address[1];
                tnoinfo->start.b[3] = Track->Address[0];

                tnoinfo->trkctl = Track->Control;
            }

            break;
        }

        case IOCTLR_QINFO: {

            PIOCTLR_QINFO_BLOCK qinfo = (PIOCTLR_QINFO_BLOCK) Buffer;

            if (DrvInfo->StatusAvailable) {

                qinfo->ctladr = DrvInfo->current.Control | DrvInfo->current.ADR<<4;
                qinfo->trknum = DrvInfo->current.TrackNumber;
                qinfo->pointx = DrvInfo->current.IndexNumber;
                qinfo->min = DrvInfo->current.TrackRelativeAddress[1];
                qinfo->sec = DrvInfo->current.TrackRelativeAddress[2];
                qinfo->frame = DrvInfo->current.TrackRelativeAddress[3];

                qinfo->zero = DrvInfo->current.AbsoluteAddress[0];
                qinfo->apmin = DrvInfo->current.AbsoluteAddress[1];
                qinfo->apsec = DrvInfo->current.AbsoluteAddress[2];
                qinfo->apframe = DrvInfo->current.AbsoluteAddress[3];

            } else {
                CloseHandle(DrvInfo->Handle);
                DrvInfo->Handle = INVALID_HANDLE_VALUE;
            }

            break;
        }

        case IOCTLR_UPCCODE: {

            PIOCTLR_UPCCODE_BLOCK upccode = (PIOCTLR_UPCCODE_BLOCK) Buffer;
            SUB_Q_MEDIA_CATALOG_NUMBER MediaCatalog;
            static CDROM_SUB_Q_DATA_FORMAT subqfmt = {IOCTL_CDROM_MEDIA_CATALOG};
            int i;

            Success = DeviceIoControl (DrvInfo->Handle,
                                      (DWORD) IOCTL_CDROM_READ_Q_CHANNEL,
                                      (LPVOID) &subqfmt,
                                      sizeof (CDROM_SUB_Q_DATA_FORMAT),
                                      (LPVOID) &MediaCatalog,
                                      sizeof (SUB_Q_MEDIA_CATALOG_NUMBER),
                                      &BytesReturned, (LPVOID) NULL);

            if (!Success)

                ProcessError (DrvInfo, IOCTL_READ, IOCTLR_UPCCODE);

            else {

                if (MediaCatalog.Mcval) {

                    // The author is uncertain that this is the correct method,
                    // but it appears to work empirically.
                    for (i=0; i<7; i++)
                        upccode->upcean[i] = MediaCatalog.MediaCatalog[i];

                } else

                    VdmReq->rhStatus = CDSTAT_ERROR | CDERR_SECT_NOTFOUND;

            }

            break;
        }

        case IOCTLR_AUDSTAT: {
            PIOCTLR_AUDSTAT_BLOCK audstat = (PIOCTLR_AUDSTAT_BLOCK) Buffer;

            audstat->audstatbits = 0;

            if (DrvInfo->Paused)
                audstat->audstatbits |= AUDSTAT_PAUSED;

            audstat->startloc.dw = DrvInfo->PlayStart.dw;
            audstat->endloc.dw = DrvInfo->PlayCount;

            break;
        }


        case IOCTLR_RADDR:
        case IOCTLR_LOCHEAD:
        case IOCTLR_ERRSTAT:
        case IOCTLR_DRVBYTES:
        case IOCTLR_SECTSIZE:
        case IOCTLR_SUBCHANINFO:
            DebugPrint (DEBUG_API, "Unsupported MSCDEX IOCTL Read\n");
            VdmReq->rhStatus = CDSTAT_ERROR | CDERR_UNKNOWN_CMD;
            CloseHandle(DrvInfo->Handle);
            DrvInfo->Handle = INVALID_HANDLE_VALUE;
            break;

        default:
            DebugPrint (DEBUG_API, "Invalid MSCDEX IOCTL Read\n");
            VdmReq->rhStatus = CDSTAT_ERROR | CDERR_UNKNOWN_CMD;
            CloseHandle(DrvInfo->Handle);
            DrvInfo->Handle = INVALID_HANDLE_VALUE;

    }
}

VOID
IOCTLWrite(
    VOID
    )

{
    LPBYTE Buffer;
    BOOL Success;
    DWORD   BytesReturned;

    Buffer = GetVDMPointer ((ULONG)VdmReq->irwrBuffer, 16, g_bProtMode);

    DebugFmt (DEBUG_IO, "iowt %d ", (DWORD) *Buffer);

    switch (*Buffer) {

        case IOCTLW_EJECT:
            Success = DeviceIoControl (DrvInfo->Handle,
                                      (DWORD) IOCTL_CDROM_EJECT_MEDIA,
                                      (LPVOID) NULL, 0,
                                      (LPVOID) NULL, 0,
                                      &BytesReturned, (LPVOID) NULL);

            if (!Success)
                ProcessError (DrvInfo, IOCTL_WRITE, IOCTLW_EJECT);
            break;

        case IOCTLW_LOCKDOOR: {

            PREVENT_MEDIA_REMOVAL MediaRemoval;
            PIOCTLW_LOCKDOOR_BLOCK lockdoor = (PIOCTLW_LOCKDOOR_BLOCK) Buffer;

            MediaRemoval.PreventMediaRemoval = (BOOLEAN) lockdoor->lockfunc;

            Success = DeviceIoControl (DrvInfo->Handle,
                                      (DWORD) IOCTL_CDROM_MEDIA_REMOVAL,
                                      (LPVOID) &MediaRemoval,
                                      sizeof(PREVENT_MEDIA_REMOVAL),
                                      (LPVOID) NULL, 0,
                                      &BytesReturned, (LPVOID) NULL);

            if (!Success)
                ProcessError (DrvInfo, IOCTL_WRITE, IOCTLW_LOCKDOOR);
            break;
        }

        case IOCTLW_AUDINFO: {
            PIOCTLW_AUDINFO_BLOCK audinfo = (PIOCTLW_AUDINFO_BLOCK) Buffer;
            VOLUME_CONTROL VolumeControl;

            // note: no support for input=>output channel manipulation
            VolumeControl.PortVolume[0] = audinfo->vol0;
            VolumeControl.PortVolume[1] = audinfo->vol1;
            VolumeControl.PortVolume[2] = audinfo->vol2;
            VolumeControl.PortVolume[3] = audinfo->vol3;

            Success = DeviceIoControl (DrvInfo->Handle,
                                      (DWORD) IOCTL_CDROM_SET_VOLUME,
                                      (LPVOID) &VolumeControl,
                                      sizeof (VOLUME_CONTROL),
                                      (LPVOID) NULL, 0,
                                      &BytesReturned, (LPVOID) NULL);

            if (!Success)
                ProcessError (DrvInfo, IOCTL_WRITE, IOCTLW_AUDINFO);
            break;
        }



        case IOCTLW_RESETDRV:
        case IOCTLW_DRVBYTES:
        case IOCTLW_CLOSETRAY:
            DebugPrint (DEBUG_API, "Unsupported MSCDEX IOCTL Write\n");
            VdmReq->rhStatus = CDSTAT_ERROR | CDERR_UNKNOWN_CMD;
            CloseHandle(DrvInfo->Handle);
            DrvInfo->Handle = INVALID_HANDLE_VALUE;
            break;

        default:
            DebugPrint (DEBUG_API, "Invalid MSCDEX IOCTL Write\n");
            VdmReq->rhStatus = CDSTAT_ERROR | CDERR_UNKNOWN_CMD;
            CloseHandle(DrvInfo->Handle);
            DrvInfo->Handle = INVALID_HANDLE_VALUE;

    }


}


/**************************************************************************

        INTERNAL UTILITY ROUTINES

 **************************************************************************/

PCDROM_TOC
ReadTOC (
    PDRIVE_INFO DrvInfo
    )
/*++

Routine Description:

    Because several MSCDEX functions return information that is in the
    Volume Table Of Contents (VTOC), this routine is called to cache
    the TOC in the DRIVE_INFO structure. Subsequent operations that
    request information from the VTOC will not have to get it from
    the drive.

Return Value:

    DWORD value from GetLastError()

--*/

{
    BOOL    Success = TRUE;
    DWORD   BytesReturned;

    if ((DrvInfo->ValidVTOC) &&
        (DrvInfo->MediaStatus == MEDCHNG_NOT_CHANGED))
        return(&DrvInfo->VTOC);

    Success = DeviceIoControl (DrvInfo->Handle,
                              (DWORD) IOCTL_CDROM_READ_TOC,
                              (LPVOID) NULL, 0,
                              (LPVOID) &DrvInfo->VTOC, sizeof (CDROM_TOC),
                              &BytesReturned, (LPVOID) NULL);

    if (!Success) {
        DrvInfo->ValidVTOC = FALSE;
        ProcessError (DrvInfo, 0, 0);
        return (NULL);
        }

    DrvInfo->ValidVTOC = TRUE;
    DrvInfo->MediaStatus = MEDCHNG_NOT_CHANGED;
    return (&DrvInfo->VTOC);


}

BOOLEAN
GetAudioStatus(
    PDRIVE_INFO DrvInfo
    )

/*++

    Because the AudioStatus byte does not statically reflect the difference
    between paused and stopped, we have to try to watch for the transition
    from one state to another to keep track of it.

--*/
{

    static CDROM_SUB_Q_DATA_FORMAT subqfmt = {IOCTL_CDROM_CURRENT_POSITION};
    DWORD BytesReturned;
    BYTE AudStat;

    DrvInfo->Paused       = FALSE;
    DrvInfo->Playing      = FALSE;

    DrvInfo->StatusAvailable = (BOOLEAN)DeviceIoControl (DrvInfo->Handle,
                                             (DWORD) IOCTL_CDROM_READ_Q_CHANNEL,
                                             (LPVOID) &subqfmt,
                                             sizeof (CDROM_SUB_Q_DATA_FORMAT),
                                             (LPVOID) &DrvInfo->current,
                                             sizeof (SUB_Q_CURRENT_POSITION),
                                             &BytesReturned, (LPVOID) NULL);

    if (DrvInfo->StatusAvailable) {

        AudStat = DrvInfo->current.Header.AudioStatus;

        DebugFmt (DEBUG_STATUS, "+%.2X ", AudStat);

        switch (AudStat) {

            case AUDIO_STATUS_IN_PROGRESS:

                DrvInfo->Paused = FALSE;
                DrvInfo->Playing = TRUE;
                LastRealStatus = AudStat;
                break;

            case AUDIO_STATUS_PAUSED:

                if (LastRealStatus == AUDIO_STATUS_IN_PROGRESS) {

                    DrvInfo->Playing = FALSE;
                    DrvInfo->Paused = TRUE;

                }
                break;

            case AUDIO_STATUS_PLAY_ERROR:
            case AUDIO_STATUS_PLAY_COMPLETE:

                DrvInfo->Paused = FALSE;
                DrvInfo->Playing = FALSE;
                LastRealStatus = AudStat;
                break;

        }

    } else {
        DrvInfo->LastError = GetLastError();
    }

    return (DrvInfo->StatusAvailable);

}


DWORD
ProcessError(
    PDRIVE_INFO DrvInfo,
    USHORT Command,
    USHORT Subcmd
    )
/*++

Routine Description:

    This routine is called when a DeviceIoControl() fails. The extended
    error code is retrieved, and status bits are set according to the
    operation that was in progress.

    The DriveInfo Handle is closed


Return Value:

    DWORD value from GetLastError()

--*/


{
    DWORD err;

    err = GetLastError();

    DebugFmt (DEBUG_ERROR, "Err! %d, ", Command);
    DebugFmt (DEBUG_ERROR, "%d: ", Subcmd);
    DebugFmt (DEBUG_ERROR, "%.8X\n", err);

    switch (err) {

        case ERROR_MEDIA_CHANGED:
        case ERROR_NO_MEDIA_IN_DRIVE:

            VdmReq->rhStatus = CDSTAT_ERROR | CDERR_NOT_READY;
            DrvInfo->MediaStatus = MEDCHNG_CHANGED;
            break;

        default:
            VdmReq->rhStatus = CDSTAT_ERROR | CDERR_GENERAL;

    }

    CloseHandle(DrvInfo->Handle);
    DrvInfo->Handle = INVALID_HANDLE_VALUE;

    return (err);

}



HANDLE
OpenPhysicalDrive(
    int DriveNum
    )
/*++

Routine Description:

   int DriveNum; Zero based (0 = A, 1 = B, 2 = C ...)

Return Value:

    HANDLE Drive Handle as returned from CreateFile

--*/
{
    HANDLE hDrive;
    CHAR chDrive [] = "\\\\.\\?:";

    chDrive[4] = DriveNum + 'A';

    hDrive = CreateFile (chDrive,
                          GENERIC_READ,
                          FILE_SHARE_READ,
                          (LPSECURITY_ATTRIBUTES) NULL,
                          OPEN_EXISTING,
                          0,
                          (HANDLE) NULL);


    return hDrive;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\vdd\mscdex\vdd\mscdex.h ===
/*
    The following definitions were derived from the "CD-ROM Programmer's
    Guide for MS-DOS CD-ROM Extensions, Version 2.21" January 1992
                                                                      */
#define MSCDEX_VERSION  0x0215

#define CDSTAT_ERROR    0X8000
#define CDSTAT_BUSY     0X0200
#define CDSTAT_DONE     0X0100

#define CDERR_WRITE_PROTECT 0
#define CDERR_UNKNOWN_UNIT  1
#define CDERR_NOT_READY     2
#define CDERR_UNKNOWN_CMD   3
#define CDERR_CRC           4
#define CDERR_STRUCT_LENGTH 5
#define CDERR_SEEK          6
#define CDERR_UNKNOWN_MEDIA 7
#define CDERR_SECT_NOTFOUND 8
#define CDERR_WRITE_FAULT   10
#define CDERR_READ_FAULT    11
#define CDERR_GENERAL       12
#define CDERR_PARAMETER     13          // Per mscdex spec
#define CDERR_DISK_CHANGE   15

#define DEVICE_INIT         0
#define IOCTL_READ          3
#define INPUT_FLUSH         7
#define OUTPUT_FLUSH        11
#define IOCTL_WRITE         12
#define DEVICE_OPEN         13
#define DEVICE_CLOSE        14
#define READ_LONG           128
#define READ_LONG_PREFETCH  130
#define SEEK                131
#define PLAY_AUDIO          132
#define STOP_AUDIO          133
#define WRITE_LONG          134
#define WRITE_LONG_VERIFY   135
#define RESUME_AUDIO        136


#define IOCTLR_RADDR        0
#define IOCTLR_LOCHEAD      1
#define IOCTLR_ERRSTAT      3
#define IOCTLR_AUDINFO      4
#define IOCTLR_DRVBYTES     5
#define IOCTLR_DEVSTAT      6
#define IOCTLR_SECTSIZE     7
#define IOCTLR_VOLSIZE      8
#define IOCTLR_MEDCHNG      9
#define IOCTLR_DISKINFO     10
#define IOCTLR_TNOINFO      11
#define IOCTLR_QINFO        12
#define IOCTLR_SUBCHANINFO  13
#define IOCTLR_UPCCODE      14
#define IOCTLR_AUDSTAT      15

#define IOCTLW_EJECT        0
#define IOCTLW_LOCKDOOR     1
#define IOCTLW_RESETDRV     2
#define IOCTLW_AUDINFO      3
#define IOCTLW_DRVBYTES     4
#define IOCTLW_CLOSETRAY    5

#define MODE_HSG            0
#define MODE_REDBOOK        1

typedef union _SECTOR_ADDR {
    BYTE b[4];
    ULONG dw;
} SECTOR_ADDR;


#pragma pack(1)

typedef struct _REQUESTHEADER {
    BYTE rhLength;
    BYTE rhUnit;
    BYTE rhFunction;
    WORD rhStatus;
    BYTE rhReserved[8];

    BYTE irwrData;
    LPBYTE irwrBuffer;
    WORD irwrBytes;
} REQUESTHEADER, *LPREQUESTHEADER;

typedef struct _DEVICE_HEADER {
    DWORD link;
    WORD attributes;
    WORD strategy;
    WORD interrupt;
    BYTE name[8];
    WORD reserved;
    BYTE drive;
    BYTE numunits;
    BYTE reserved2[10];
} DEVICE_HEADER, *PDEVICE_HEADER;

typedef struct _DRIVE_DEVICE_LIST {
    BYTE Unit;
    DWORD DeviceHeader;
} DRIVE_DEVICE_LIST, *PDRIVE_DEVICE_LIST;


typedef struct _IOCTLR_RADDR_BLOCK {
    BYTE ctlcode;                   // 0
    DWORD devheader;
} IOCTLR_RADDR_BLOCK, *PIOCTLR_RADDR_BLOCK;


typedef struct _IOCTLR_LOCHEAD_BLOCK {
    BYTE ctlcode;                   // 1
    BYTE addrmode;
    SECTOR_ADDR headlocation;
} IOCTLR_LOCHEAD_BLOCK, *PIOCTLR_LOCHEAD_BLOCK;


typedef struct _IOCTLR_ERRSTAT_BLOCK {
    BYTE ctlcode;                   // 3
    BYTE statistics;                // array of undefined length
} IOCTLR_ERRSTAT_BLOCK, *PIOCTLR_ERRSTAT_BLOCK;


typedef struct _IOCTLR_AUDINFO_BLOCK {
    BYTE ctlcode;                   // 4
    BYTE chan0;
    BYTE vol0;
    BYTE chan1;
    BYTE vol1;
    BYTE chan2;
    BYTE vol2;
    BYTE chan3;
    BYTE vol3;
} IOCTLR_AUDINFO_BLOCK, *PIOCTLR_AUDINFO_BLOCK;


typedef struct _IOCTLR_DRVBYTES_BLOCK {
    BYTE ctlcode;                   // 5
    BYTE numbytes;
    BYTE buffer[128];
} IOCTLR_DRVBYTES_BLOCK, *PIOCTLR_DRVBYTES_BLOCK;


typedef struct _IOCTLR_DEVSTAT_BLOCK {
    BYTE ctlcode;                   // 6
    DWORD devparms;
} IOCTLR_DEVSTAT_BLOCK, *PIOCTLR_DEVSTAT_BLOCK;

#define DEVSTAT_DOOR_OPEN       0X00000001
#define DEVSTAT_DOOR_UNLOCKED   0X00000002
#define DEVSTAT_SUPPORTS_COOKED 0X00000004
#define DEVSTAT_READ_WRITE      0X00000008
#define DEVSTAT_PLAYS_AV        0X00000010
#define DEVSTAT_SUPPORTS_ILEAVE 0X00000020
#define DEVSTAT_SUPPORTS_PRFTCH 0X00000080
#define DEVSTAT_SUPPORTS_CHMAN  0X00000100
#define DEVSTAT_SUPPORTS_RBOOK  0X00000200
#define DEVSTAT_NO_DISC         0X00000800
#define DEVSTAT_SUPPORTS_RWSCH  0X00001000


typedef struct _IOCTLR_SECTSIZE_BLOCK {
    BYTE ctlcode;                   // 7
    BYTE readmode;
    WORD sectsize;
} IOCTLR_SECTSIZE_BLOCK, *PIOCTLR_SECTSIZE_BLOCK;


typedef struct _IOCTLR_VOLSIZE_BLOCK {
    BYTE ctlcode;                   // 8
    DWORD size;
} IOCTLR_VOLSIZE_BLOCK, *PIOCTLR_VOLSIZE_BLOCK;


typedef struct _IOCTLR_MEDCHNG_BLOCK {
    BYTE ctlcode;                   // 9
    BYTE medbyte;
} IOCTLR_MEDCHNG_BLOCK, *PIOCTLR_MEDCHNG_BLOCK;

#define MEDCHNG_NOT_CHANGED 1
#define MEDCHNG_DONT_KNOW   0
#define MEDCHNG_CHANGED     0XFF


typedef struct _IOCTLR_DISKINFO_BLOCK {
    BYTE ctlcode;                   // 10
    BYTE tracklow;
    BYTE trackhigh;
    SECTOR_ADDR startleadout;
} IOCTLR_DISKINFO_BLOCK, *PIOCTLR_DISKINFO_BLOCK;


typedef struct _IOCTLR_TNOINFO_BLOCK {
    BYTE ctlcode;                   // 11
    BYTE trknum;
    SECTOR_ADDR start;
    BYTE trkctl;
} IOCTLR_TNOINFO_BLOCK, *PIOCTLR_TNOINFO_BLOCK;


typedef struct _IOCTLR_QINFO_BLOCK {
    BYTE ctlcode;                   // 12
    BYTE ctladr;
    BYTE trknum;
    BYTE pointx;
    BYTE min;
    BYTE sec;
    BYTE frame;
    BYTE zero;
    BYTE apmin;
    BYTE apsec;
    BYTE apframe;
} IOCTLR_QINFO_BLOCK, *PIOCTLR_QINFO_BLOCK;


typedef struct _IOCTLR_SUBCHANINFO_BLOCK {
    BYTE ctlcode;                   // 13
    SECTOR_ADDR startsect;
    DWORD transaddr;
    DWORD numsect;
} IOCTLR_SUBCHANINFO_BLOCK, *PIOCTLR_SUBCHANINFO_BLOCK;


typedef struct _IOCTLR_UPCCODE_BLOCK {
    BYTE ctlcode;                   // 14
    BYTE ctladr;
    BYTE upcean[7];
    BYTE zero;
    BYTE aframe;
} IOCTLR_UPCCODE_BLOCK, *PIOCTLR_UPCCODE_BLOCK;


typedef struct _IOCTLR_AUDSTAT_BLOCK {
    BYTE ctlcode;                   // 15
    WORD audstatbits;
    SECTOR_ADDR startloc;
    SECTOR_ADDR endloc;
} IOCTLR_AUDSTAT_BLOCK, *PIOCTLR_AUDSTAT_BLOCK;

#define AUDSTAT_PAUSED 1


typedef struct _IOCTLW_LOCKDOOR_BLOCK {
    BYTE ctlcode;                   // 1
    BYTE lockfunc;
} IOCTLW_LOCKDOOR_BLOCK, *PIOCTLW_LOCKDOOR_BLOCK;


typedef struct _IOCTLW_AUDINFO_BLOCK {
    BYTE ctlcode;                   // 3
    BYTE chan0;
    BYTE vol0;
    BYTE chan1;
    BYTE vol1;
    BYTE chan2;
    BYTE vol2;
    BYTE chan3;
    BYTE vol3;
} IOCTLW_AUDINFO_BLOCK, *PIOCTLW_AUDINFO_BLOCK;


typedef struct _IOCTLW_DRVBYTES_BLOCK {
    BYTE ctlcode;                   // 4
    BYTE buffer;
} IOCTLW_DRVBYTES_BLOCK, *PIOCTLW_DRVBYTES_BLOCK;



typedef struct _READ_LONG_BLOCK {
    BYTE header[13];
    BYTE addrmode;
    DWORD transaddr;
    WORD numsect;
    SECTOR_ADDR startsect;
    BYTE readmode;
    BYTE ileavesize;
    BYTE ileaveskip;
} READ_LONG_BLOCK, *PREAD_LONG_BLOCK;


typedef struct _SEEK_BLOCK {
    BYTE header[13];
    BYTE addrmode;
    DWORD transaddr;
    WORD numsect;
    SECTOR_ADDR startsect;
} SEEK_BLOCK, *PSEEK_BLOCK;


typedef struct _PLAY_AUDIO_BLOCK {
    BYTE header[13];
    BYTE addrmode;
    SECTOR_ADDR startsect;
    DWORD numsect;
} PLAY_AUDIO_BLOCK, *PPLAY_AUDIO_BLOCK;


typedef struct _WRITE_LONG_BLOCK {
    BYTE header[13];
    BYTE addrmode;
    DWORD transaddr;
    WORD numsect;
    SECTOR_ADDR startsect;
    BYTE readmode;
    BYTE ileavesize;
    BYTE ileaveskip;
} WRITE_LONG_BLOCK, *PWRITE_LONG_BLOCK;


#pragma pack()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\vdd\samples\sample1\fax32\fax32.h ===
/* vdd.h - main include file for the VDD
 *
 */



#ifdef WIN_32
#define WIN
#define FLAT_32
#define TRUE_IF_WIN32	1
#else
#define TRUE_IF_WIN32	0
#endif

#ifdef WIN
#define _WINDOWS
#include "windows.h"
#endif



BOOL VDDInitialize(PVOID,ULONG,PCONTEXT);
VOID FAXVDDTerminateVDM(VOID);
VOID FAXVDDInit (VOID);
VOID FAXVDDDispatch (VOID);
VOID FAXVDDTerminate(USHORT usPDB);
VOID FAXVDDCreate(USHORT usPDB);
VOID FAXVDDBlock(VOID);
VOID FAXVDDResume(VOID);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\vdd\samples\adlibvdd\vdd.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects


Copyright (c) 1992, 1993  Microsoft Corporation

Module Name:

    vdd.h

Abstract:

    This header file is a grossly cut down version of that which exists
    in the SYNTH driver project. I have only extracted those pieces required
    for the AdLib VDD.

Author:

    Mike Tricker (MikeTri) 27-Jan-93 (after Robin Speed (RobinSp) 20-Oct-92)

Revision History:

--*/

#define STR_ADLIB_DEVICENAME L"\\Device\\adlib.mid"

/*
 *  Stucture for passing synth data
 */

typedef struct {
    unsigned short IoPort;
    unsigned short PortData;
} SYNTH_DATA, *PSYNTH_DATA;


#define AD_MASK                         (0x004)
#define AD_NEW                          (0x105)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\vdd\samples\sample1\fax16\fax16.asm ===
name    faxdrv
    title   'FAX16 - Stub driver for Application based intercept under NT'

;
; fax16.asm: This is a very simple DOS stub device driver for NTVDM.
;	     It shows how to use application based intercept services
;	     provided by NTVDM. FAX32.dll is its DLL which will be loaded
;	     in the NTVDM process by this stub device driver.
;
;	     This driver only has meaningful code for init,read and write.
;	     Rest all command codes always succeed. We are assuming here
;	     that the 16 bit fax application for this stub device driver
;	     opens this device and just make read and write calls. The
;	     meaning of read is to get a fax message and write means
;	     send a message

_TEXT	segment byte public 'CODE'

	assume cs:_TEXT,ds:_TEXT,es:NOTHING

	org	0

	include isvbop.inc

MaxCmd	  equ	24		    ; Maximum allowed command

; VDD Command codes

OpGet	  equ	1		    ; Read a FAX
OpSend	  equ	2		    ; Send a FAX

Header: 			    ; Fax Device Header
	DD  -1
	DW  0c840h
	DW  FaxStrat
	DW  FaxIntr
	DB  'FAXDRV00'

RHPtr	DD  ?			    ; Pointer to Request Header

Dispatch:			    ; Interrupt routine command code
	DW  Init
	DW  MediaChk
	DW  BuildBPB
	DW  IoctlRd
	DW  Read
	DW  NdRead
	DW  InpStat
	DW  InpFlush
	DW  Write
	DW  WriteVfy
	DW  OutStat
	DW  OutFlush
	DW  IoctlWt
	DW  DevOpen
	DW  DevClose
	DW  RemMedia
	DW  OutBusy
	DW  Error
	DW  Error
	DW  GenIOCTL
	DW  Error
	DW  Error
	DW  Error
	DW  GetLogDev
	DW  SetLogDev

DllName   DB "FAX32.DLL",0
InitFunc  DB "FAXVDDRegisterInit",0
DispFunc  DB "FAXVDDDispatch",0

F32Mes	  DB "We are called from 32 staff", 10, 13, "$"

hVDD	  DW	?

FaxStrat    proc    far 	    ; Strategy Routine

    mov     word ptr cs:[RhPtr],bx
    mov     word ptr cs:[RhPtr+2],es
    ret

FaxStrat    endp

FaxIntr     proc    far 	    ; INterrupt routine

    push    ax			    ; Save registers
    push    bx
    push    cx
    push    dx
    push    ds
    push    es
    push    di
    push    si
    push    bp

    push    cs
    pop     ds			    ; DS = CS

    les     di,[RHPtr]		    ; ES:DI = request header

    mov     bl,es:[di+2]
    xor     bh,bh		    ; BX = command code
    cmp     bx,MaxCmd
    jle     FIntr1

    call    Error		    ; Unknown command
    jmp     FIntr2

FIntr1:
    shl     bx,1
    call    word ptr [bx+Dispatch]  ; call command routine
    les     di,[RhPtr]		    ; ES:DI = request header

FIntr2:
    or	    ax,0100h		    ; Set Done bit in the status
    mov     es:[di+3],ax	    ; Store the status

    pop     bp			    ; restore registers
    pop     si
    pop     di
    pop     es
    pop     ds
    pop     dx
    pop     cx
    pop     bx
    pop     ax

    ret


MediaChk    proc    near
    xor     ax,ax
    ret
MediaChk    endp

BuildBPB    proc    near
    xor     ax,ax
    ret
BuildBPB    endp

IoctlRd	    proc    near
    xor     ax,ax
    ret
IoctlRd	    endp

Read	    proc    near
    push    es
    push    di					; Save Request Header add

    mov     bx,word ptr es:[di+14]		; buffer offset
    mov     ax,word ptr es:[di+16]		; buffer segment
    mov     cx,word ptr es:[di+18]		; buffer length

    mov     es,ax				; es:bx is the buffer where
						; fax has to be read from
						; the NT device driver

    mov     ax,word ptr cs:[hVDD]		; VDD handle returned by
						; register module
    mov     dx,OpGet				; Read the fax command

    DispatchCall

    pop     di
    pop     es

    jnc     rOK 				; NC -> Success and CX has
						; the count read.

    call    Error				; Operation Failed
    ret

rOK:
    mov     word ptr es:[di+12],cx		; return in header how much
						; was read
    xor     ax,ax
    ret
Read	    endp

NdRead	    proc    near
    xor     ax,ax
    ret
NdRead	    endp

InpStat	    proc    near
    xor     ax,ax
    ret
InpStat	    endp

InpFlush    proc    near
    xor     ax,ax
    ret
InpFlush    endp

Write	    proc    near
    push    es
    push    di					; Save Request Header add

    mov     bx,word ptr es:[di+14]		; buffer offset
    mov     ax,word ptr es:[di+16]		; buffer segment
    mov     cx,word ptr es:[di+18]		; buffer length

    mov     es,ax				; es:bx is the FAX message	where
						; to be send by NT device
						; driver

    mov     ax,word ptr cs:[hVDD]		; VDD handle returned by
						; register module
    mov     dx,OpSend				; Send the fax command

    DispatchCall

    pop     di
    pop     es

    jnc     wOK				; NC -> Success and CX has
						; the count read.

    call    Error				; Operation Failed
    ret

wOK:
    mov     word ptr es:[di+12],cx		; return in header how much
						; was actually written
    xor     ax,ax
    ret
Write	    endp

WriteVfy    proc    near
    xor     ax,ax
    ret
WriteVfy    endp

OutStat	    proc    near
    xor     ax,ax
    ret
OutStat     endp

OutFlush    proc    near
    xor     ax,ax
    ret
OutFlush    endp

IoctlWt	    proc    near
    xor     ax,ax
    ret
IoctlWt     endp

DevOpen	    proc    near
    xor     ax,ax
    ret
DevOpen     endp

DevClose    proc    near
    xor     ax,ax
    ret
DevClose    endp

RemMedia    proc    near
    xor     ax,ax
    ret
RemMedia    endp

OutBusy	    proc    near
    xor     ax,ax
    ret
OutBusy     endp

GenIOCTL    proc    near
    xor     ax,ax
    ret
GenIOCTL    endp

GetLogDev   proc    near
    xor     ax,ax
    ret
GetLogDev   endp

SetLogDev   proc    near
    xor     ax,ax
    ret
SetLogDev   endp

Error	    proc    near
    mov     ax,8003h				; Bad Command Code
    ret
Error	    endp
;
;
; This function is a sample sub that calling from 32-bits part of VDD
;
From32Sub   proc    near

    push    cs
    pop     ds
    mov     dx, offset F32mes
    mov     ah, 09h
    int     21h
    VDDUnSimulate16
    ret

From32Sub   endp

Init	    proc    near
    push    es
    push    di					; Save Request Header add

    push    ds
    pop     es

    ; Load fax32.dll
    mov     si, offset DllName			; ds:si = fax32.dll
    mov     di, offset InitFunc                 ; es:di = init routine
    mov     bx, offset DispFunc 		; ds:bx = dispatch routine
    mov     ax, offset From32Sub		; ds:ax = From32Sub


    RegisterModule
    jnc     saveHVDD				; NC -> Success

    call    Error				; Indicate failure

    pop     di
    pop     es
    mov     byte ptr es:[di+13],0		; unit supported 0
    mov     word ptr es:[di+14],offset Header	; Unload this device
    mov     word ptr es:[di+16],cs
    mov     si, offset Header
    and	    [si+4],8FFFh			; clear bit 15 for failure
    ret

saveHVDD:
    mov     [hVDD],ax

    pop     di
    pop     es
    mov     word ptr es:[di+14],offset Init	; Free Memory address
    mov     word ptr es:[di+16],cs

    xor     ax,ax				; return success
    ret
Init	    endp

FaxIntr	    endp

_TEXT	    ends

    end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\vdd\samples\sample2\vdd\vdd.h ===
/* vdd.h - main include file for the VDD
 *
 */


#include "windows.h"

// VDD services header
#include <vddsvc.h>

// private macro definitions


#define PAGE_SIZE		0x1000
/*disconnected I/O value */
#define FLOATING_IO		0xFF
#define FLOATING_MIO		0xFF

// I/O mapped I/O
#define IO_PORT_FIRST		0x790
#define IO_PORT_LAST		0x793
#define IO_PORT_FIRE_DMA_SLOW	IO_PORT_FIRST
#define IO_PORT_FIRE_DMA_FAST	IO_PORT_FIRST + 1
#define IO_PORT_DMA		IO_PORT_FIRST + 2
#define IO_PORT_RANGE		IO_PORT_LAST - IO_PORT_FIRST + 1

// memory mapped I/O
#define MIO_SEGMENT		0xC000
#define MIO_PORT_FIRST		0
#define MIO_PORT_LAST		7
#define MIO_PORT_FIRE_DMA	MIO_PORT_FIRST
#define MIO_PORT_DMA		MIO_PORT_FIRST + 1
#define MIO_PORT_RANGE		MIO_PORT_LAST - MIO_PORT_FIRST + 1
#define MIO_ADDRESS		((((ULONG)MIO_SEGMENT) << 16) | MIO_PORT_FIRST)

// DMA
#define DMA_CHANNEL		1
#define DMA_PORT_BASE		0
#define DMA_SHIFT_COUNT 	0
#define DMA_INTERRUPT_LINE	2
#define DMA_INTERRUPT_PIC	ICA_SLAVE
#define DMA_PORT_PAGE		0x83
#define DMA_PORT_ADDR		DMA_PORT_BASE + 2
#define DMA_PORT_COUNT		DMA_PORT_BASE + 3
#define DMA_PORT_CMD		DMA_PORT_BASE + 8
#define DMA_PORT_REQUEST	DMA_PORT_BASE + 9
#define DMA_PORT_SNGLE_MASK	DMA_PORT_BASE + 10
#define DMA_PORT_MODE		DMA_PORT_BASE + 11
#define DMA_PORT_FLIPFLOP	DMA_PORT_BASE + 12
#define DMA_PORT_TEMP		DMA_PORT_BASE + 13
#define DMA_PORT_CLEARMASK	DMA_PORT_BASE + 14
#define DMA_PORT_WRTEMASK	DMA_PORT_BASE + 15


/* function prototype definitions */

/* entry function of VDD */
BOOL VddDllEntry(HANDLE hVdd, DWORD dwReason, LPVOID lpReserved);

/* private functions */
VOID MyInB(WORD, PBYTE);
VOID MyOutB(WORD, BYTE);
VOID MyMIOHandler(ULONG, ULONG);
WORD FakeDD_DMARead(PBYTE, WORD);
WORD FakeDD_DMAWrite(PBYTE, WORD);
BOOLEAN SlowDMA();
BOOLEAN FastDMA();
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\vdd\samples\sample2\16bits\16bits.inc ===
;---------------------------------------------------;
; Include file for 16bits sample application
; Copyright (C) 1992, Microsoft Corporation
;---------------------------------------------------;

TRUE	    equ     0FFh
FALSE	    equ     NOT(TRUE)

;
;I/O mapped I/O port equates
;
IO_PORT_FIRST		equ	790h	    ;The first I/O port addr
IO_PORT_LAST		equ	793h	    ;The last I/O port addr
IO_PORT_FIRE_DMA_SLOW	equ	IO_PORT_FIRST	;Port addr to trigger DMA
IO_PORT_FIRE_DMA_FAST	equ	IO_PORT_FIRST + 1 ;port to trigger DMA
IO_PORT_DMA		equ	IO_PORT_FIRST+2 ;port connnected to DMA channel
;
;Memory mapped I/O port equates 	    ;segment address
;
MIO_SEGMENT equ     0C000h
MIO_PORT_FIRST	    equ	    0		    ;The first port addr(offset)
MIO_PORT_LAST	    equ     07		    ;the last port addr(offset)
MIO_PORT_RANGE	    equ     MIO_PORT_LAST - MIO_PORT_FIRST + 1
MIO_PORT_FIRE_DMA   equ     MIO_PORT_FIRST  ;Port to trigger DMA
MIO_PORT_DMA	    equ     MIO_PORT_FIRST+1;port connected to DMA channel
;
;DMA equates
;
DMA_INTERRUPT	    equ	    70h + 2	    ;slave PIC, line #2(0 based)
DMA_CHANNEL	    equ	    01h		    ;DMA #1, channel #1(0 based)

DMA_PORT_BASE	    equ	00
DMA_PORT_PAGE	    equ	083h
DMA_PORT_ADDR	    equ	DMA_PORT_BASE + 2
DMA_PORT_COUNT	    equ	DMA_PORT_BASE + 3
DMA_PORT_CMD	    equ	DMA_PORT_BASE + 8
DMA_PORT_REQUEST    equ DMA_PORT_BASE + 9
DMA_PORT_SNGLE_MASK equ DMA_PORT_BASE + 10
DMA_PORT_MODE	    equ DMA_PORT_BASE + 11
DMA_PORT_FLIPFLOP   equ DMA_PORT_BASE + 12
DMA_PORT_TEMP	    equ DMA_PORT_BASE + 13
DMA_PORT_CLEARMASK  equ DMA_PORT_BASE + 14
DMA_PORT_WRTEMASK   equ DMA_PORT_BASE + 15
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\vdd\samples\sample2\16bits\16bits.asm ===
TITLE Sample 16 Bits DOS application
;---------------------------------------------------------------;
;
    include 16bits.inc

    DOSSEG
    .MODEL SMALL

    .STACK 100h

    .DATA


DMAWriteBuffer	label	byte
	    db	    64 dup (?)
DMA_BUFFER_SIZE     equ $ - DMAWriteBuffer

DMAReadBuffer	 label	 byte
	    db	    DMA_BUFFER_SIZE dup (?)

MIOPattern  label   byte
	    db	    00, 0FFh, 0AAh, 055h
MIOPATTERN_SIZE equ	$ - MIOPattern

public	start

    .CODE
start:
    jmp     short RealStart
OldVector   label   dword
    dd	    ?
DMACompleted db     ?

RealStart:
    mov     ax,@DATA
    mov     ds,ax
    mov     es,ax
    assume  ds:@DATA, es:@DATA

;Hook interrupt(DMA terminate count notification)
    push    ds
    mov     al, DMA_INTERRUPT
    mov     ah, 35h
    int     21h
    mov     word ptr cs:OldVector, bx
    mov     word ptr cs:OldVector + 2, es
    mov     dx, offset ISRDMACompleted
    mov     ax, cs
    mov     ds, ax
    mov     al, DMA_INTERRUPT
    mov     ah, 25h
    int     21h
    pop     ds


;VDD operation.
;(1). Hook the I/O port.
;(2). Keep the port status up-to-date if a write operation is performed
;     by 16 bits application(this program).
;(3). Simulate DMA operation and generate a fake interrupt for 16bits
;     applicatiion if the DMA operation reaches its TC.
;
;
;16bits application
;(1). Output one byte to the port and then request DMA operation.
;(2). Wait for DMA operation completed.
;(3). goto step (1) if there are more data to be transferred.
;Note that the given I/O must be a R/W port.

;Here we do a DMA write operation upon I/O mapped I/O
    mov     cx, DMA_BUFFER_SIZE
    mov     si, offset DMAWriteBuffer
DMATransferLoop_Fast:
    mov     dx, IO_PORT_DMA
    mov     al, cl
    out     dx, al			;write I/O the current count
    cli
    mov     cs:DMACompleted, FALSE	;reset TC flag
    sti
;channel #1, write op, no auto init, addr inc, single transfer
    mov     al, 01000101B
    call    SetupDMAOperation
;Fire the DMA WRITE operation, this will cause VDD to gain control
;and start DMA operation.
    mov     dx, IO_PORT_FIRE_DMA_FAST
    out     dx, al
;In real world(there is a real hardware adapter), we won't do this
;idle loop, rather, we can do something useful(like, read the DMA current
;count and display the progress and so forth)provided that we can regain
;control while DMA operation is in progress(VDD spawns a new thread to
;handle DMA operation and returns to us immediately)
;
;Since we are simulating DMA operation without hardware, we always
;start the DMA operation with transfer count set to 1 byte. In reality
;this is should not be the case because it will slow down the data transfer.

WaitForDMA_Fast:
    cmp     cs:DMACompleted, TRUE
    jnz	    WaitForDMA_Fast
    inc     si
    loop    DMATransferLoop_Fast
;
;Now do a DMA read operation
    mov     cx, DMA_BUFFER_SIZE
    mov     si, offset DMAWriteBuffer
    mov     di, offset DMAReadBuffer
DMATransferLoop_Slow:
;channel #1, read op, no auto init, addr inc, single transfer
    mov     al, 01001001B
    cli
    mov     cs:DMACompleted, FALSE
    sti
    call    SetupDMAOperation
;Fire the DMA READ operation
    mov     dx, IO_PORT_FIRE_DMA_SLOW
    out     dx, al
WaitForDMA_Slow:
    cmp     cs:DMACompleted, TRUE
    jne     WaitForDMA_Slow
    mov     dx, IO_PORT_DMA
    in	    al, dx
    mov     [di], al
    inc     di				;advance our buffer
    inc     si				;and the DMA buffer
    loop    DMATransferLoop_Slow
;
;The DMAWriteBuffer and DMAReadBuffer should have the same contents.
;If they don't, it failed. ....


;Memory mapped I/O
    mov     ax, MIO_SEGMENT
    mov     es, ax
    mov     bx, MIOPATTERN_SIZE
    mov     si, offset MIOPattern

MIO_Loop:
    cld
    lodsb				;get next pattern
    mov     cx, MIO_PORT_RANGE
    mov     di, MIO_PORT_FIRST
rep stosb				;fill all I/O with the pattern
    mov     cx, MIO_PORT_RANGE
    dec     di
    std
repe	scasb				;
    je	    @F
;   call    ErrorMIO			;if any i/o failed,
@@:
    dec     bx				;next pattern
    jnz     MIO_Loop

;Before terminate, retsore everything we have touched
    push    ds
    lds     dx, cs:OldVector
    mov     al, DMA_INTERRUPT
    mov     ah, 25h
    int     21h
    pop     ds
    mov     ah, 04Ch
    int     21h

;-------------------------------------------------------;
;Setup DMA operation
;Input: ds:si = seg:offset of memeory address
;	al = DMA mode
;output: NONE
;Modified: AX, DX
;-------------------------------------------------------;
SetupDMAOperation proc
    push    cx
    mov     dx, DMA_PORT_FLIPFLOP
    out     dx, al
    mov     dx, DMA_PORT_MODE		    ;more register
    out     dx, al
    mov     ax, ds			    ;transfer address -> page:offset
    mov     cl, 4			    ;page: A16 ~ A19, offset A0 ~ A15
    rol     ax, cl
    mov     ch, al
    and     al, 0F0h
    add     ax, si
    jnc     @F
    inc     ch
@@:
    mov     dx, DMA_PORT_ADDR
    out     dx, al			    ;offset lower byte
    mov     al, ah
    out     dx, al			    ;and higher byte
    mov     dx, DMA_PORT_PAGE		    ;page register
    mov     al, ch
    and     al, 0Fh			    ;only 4 bits allowed
    out     dx, al
    mov     al, 1			    ;single transfer, one byte
    mov     dx, DMA_PORT_COUNT
    out     dx, al
    dec     al
    out     dx, al			    ;higher byte set to 0
    mov     dx, DMA_PORT_REQUEST	    ;request channel #1
    mov     al, 00000101B
    out     dx, al
    mov     dx, DMA_PORT_SNGLE_MASK	    ;start DMA transfer
    mov     al, 00000001B
    out     dx, al
    pop     cx
    ret
SetupDMAOperation endp


ISRDMACompleted proc	far
    mov     byte ptr DMACompleted, TRUE
    mov al, 20h
    out 20h, al
    out 0A0h, al
    iret
ISRDMACompleted	endp

END start
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\vdd\samples\sample1\fax32\fax32.c ===
/*++
 *
 *  VDD v1.0
 *
 *  Copyright (c) 1991, Microsoft Corporation
 *
 *  VDD.C - Sample VDD for NT-MVDM
 *
--*/
#include "fax32.h"
#include "vddsvc.h"


USHORT Sub16CS;
USHORT Sub16IP;

BOOL
VDDInitialize(
    IN PVOID DllHandle,
    IN ULONG Reason,
    IN PCONTEXT Context OPTIONAL
    )

/*++

Routine Description:


Arguments:

    DllHandle - Not Used

    Reason - Attach or Detach

    Context - Not Used

Return Value:

    SUCCESS - TRUE
    FAILURE - FALSE

--*/

{

    switch ( Reason ) {

    case DLL_PROCESS_ATTACH:
	// Allocate VDD's local heap if needed. Check that NT FAX driver
	// is available by opening that device.
	//....
	// Install user hook for callback service.

	if(!VDDInstallUserHook (DllHandle,&FAXVDDCreate, &FAXVDDTerminate,
		    &FAXVDDBlock, &FAXVDDResume))
	    OutputDebugString("FAX32: UserHook not installed\n");
	else
	    OutputDebugString("FAX32: UserHook installed!\n");

	// UserHook # 2
	if(!VDDInstallUserHook (DllHandle,&FAXVDDCreate, NULL,
		    NULL, &FAXVDDResume))
	    OutputDebugString("FAX32: UserHook #2 not installed\n");
	else
	    OutputDebugString("FAX32: UserHook #2 installed!\n");

	break;

    case DLL_PROCESS_DETACH:
	// Deallocate VDD's local heap if needed
	// communicate to appropriate Device driver about your departure
	//...
	// Deinstall user hook for callback service.
	if(!VDDDeInstallUserHook (DllHandle))
	    OutputDebugString("FAX32: UserHook not deinstalled\n");
	else
	    OutputDebugString("FAX32: UserHook deinstalled!\n");

        break;
    default:
        break;
    }

    return TRUE;
}

// Sample function
VOID FAXVDDTerminate(USHORT usPDB)
{
    USHORT uSaveCS, uSaveIP;

    OutputDebugString("FAX32: Terminate message\n");

    // VDDHostSimulate

    uSaveCS = getCS();
    uSaveIP = getIP();
    setCS(Sub16CS);
    setIP(Sub16IP);
    VDDSimulate16();
    setCS(uSaveCS);
    setIP(uSaveIP);

}

// Sample function
VOID FAXVDDCreate(USHORT usPDB)
{
    OutputDebugString("FAX32: Create Message\n");
}

// Sample function
VOID FAXVDDBlock(VOID)
{
    OutputDebugString("FAX32: Block Message\n");
}

// Sample function
VOID FAXVDDResume(VOID)
{
    OutputDebugString("FAX32: Resume Message\n");
}


VOID
FAXVDDTerminateVDM(
    VOID
    )
/*++

Arguments:

Return Value:

    SUCCESS - TRUE
    FAILURE - FALSE

--*/


{

    // Cleanup any resource taken for this vdm


    return;
}


VOID
FAXVDDRegisterInit(
    VOID
    )
/*++

Arguments:

Return Value:

    SUCCESS - TRUE
    FAILURE - FALSE

--*/


{
	// Save addresses for fax16
	Sub16CS = getDS();
	Sub16IP = getAX();

	OutputDebugString("FAX32: GET_ADD\n");

    // Called from the BOP manager. If VDDInitialize has done all the
    // checking and resources alloaction, just return success.

    setCF(0);
    return;
}


#define GET_A_FAX	1
#define SEND_A_FAX	2

VOID
FAXVDDDispatch(
    VOID
    )
/*++

Arguments:
    Client (DX)    = Command code
		    01 - get a message from NT device driver
		    02 - send a message through NT device driver
		    03 - address of 16 bit routine

    Client (ES:BX) = Message Buffer
    Client (CX)    = Buffer Size

Return Value:

    SUCCESS - Client Carry Clear and CX has the count transferred
    FAILURE - Client Carry Set

--*/


{
PCHAR	Buffer;
USHORT	cb;
USHORT	uCom;
BOOL	Success = TRUE; // In this sample operation always succeeds

    uCom = getDX();

    cb = getCX();
    Buffer = (PCHAR) GetVDMPointer ((ULONG)((getES() << 16)|getBX()),cb,FALSE);
    switch (uCom) {
	case GET_A_FAX:
	    // Make a DeviceIOControl or ReadFile on NT FAX driver with
	    // cb and Buffer.Then set CX if success.

	    if (Success) {
		setCX(cb);
		setCF(0);
	    }
	    else
		setCF(1);

	    break;


	case SEND_A_FAX:
	    // Make a DeviceIOControl or WriteFile on NT FAX driver with
	    // cb and Buffer.Then set CX if success.

	    if (Success) {
		setCX(cb);
		setCF(0);
	    }
	    else
		setCF(1);

	    break;
	default:
		setCF(1);
    }
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\vdd\samples\sample2\vdd\vdd.c ===
/*++
 *
 *  VDD v1.0
 *
 *  Copyright (c) 1991, Microsoft Corporation
 *
 *  VDD.C - Sample VDD for NT-MVDM
 *
--*/

#include "vdd.h"

/** Global variables **/

    HANDLE  hVDD;		/* VDD module handle */
    HANDLE  hVddHeap;		/* VDD local heap */
    PBYTE   IOBuffer;		/* buffer to simulate I/O Read and Write */
    ULONG   MIOAddress; 	/* memory mapped I/O linear address */
    PVOID   BaseAddress;	/* memory mapped I/O virtual address */
    BOOL    IOHook;		/* true if we installed a I/O hooked */
    BOOL    MIOHook;		/* true if we installed a memory hook */
    static VDD_IO_PORTRANGE PortRange;

BOOL
VDDInitialize(
    HANDLE   hVdd,
    DWORD    dwReason,
    LPVOID   lpReserved)

/*++

Routine Description:

    The DllEntryPoint for the Vdd which handles intialization and termination

Arguments:

    hVdd   - The handle to the VDD

    Reason - flag word thatindicates why Dll Entry Point was invoked

    lpReserved - Unused

Return Value:
    BOOL bRet - if (dwReason == DLL_PROCESS_ATTACH)
                   TRUE    - Dll Intialization successful
                   FALSE   - Dll Intialization failed
                else
                   always returns TRUE
--*/

{
    int     i;
    VDD_IO_HANDLERS  IOHandlers;



/**
    keep a copy of VDD handle in global variable so the other functions
    can see it
**/
    hVDD = hVdd;

    switch ( dwReason ) {

    case DLL_PROCESS_ATTACH:

        // Allocate VDD's local heap
        hVddHeap = HeapCreate(0, 0x1000, 0x10000);

	if (!hVddHeap) {
	    OutputDebugString("VDD: Can't create local heap");
            return FALSE;
	}

        IOBuffer = (PBYTE)HeapAlloc(hVddHeap,0,IO_PORT_RANGE);

	if (!IOBuffer)	{
	    OutputDebugString("VDD: Can't allocate IO buffer from heap");
            HeapDestroy(hVddHeap);
            return FALSE;
	}

        // communicate to appropriate Device driver about your arrival

	// Set emulated I/O to floating
        for (i = 0 ; i < IO_PORT_RANGE; i++)
	    IOBuffer[i] = FLOATING_IO;


	IOHandlers.inb_handler = MyInB;
	IOHandlers.inw_handler = NULL;
	IOHandlers.insb_handler = NULL;
	IOHandlers.insw_handler = NULL;
	IOHandlers.outb_handler = MyOutB;
	IOHandlers.outw_handler = NULL;
	IOHandlers.outsb_handler = NULL;
	IOHandlers.outsw_handler = NULL;
	PortRange.First = IO_PORT_FIRST;
	PortRange.Last = IO_PORT_LAST;

	// hook I/O mapped I/O
	IOHook = VDDInstallIOHook(hVDD, (WORD) 1, &PortRange, &IOHandlers);

	// get 32 bits linear address of memory mapped I/O
	MIOAddress = (ULONG) GetVDMPointer(MIO_ADDRESS, MIO_PORT_RANGE, 0);
	// hook memory mapped I/O
	MIOHook = VDDInstallMemoryHook(hVDD, (PVOID) MIOAddress, MIO_PORT_RANGE,
				       (PVDD_MEMORY_HANDLER)MyMIOHandler);

	BaseAddress = NULL;
	break;

    case DLL_PROCESS_DETACH:

        // communicate to appropriate Device driver about your departure
	if (IOHook)
	    VDDDeInstallIOHook(hVDD, 1, &PortRange);
	if (MIOHook) {
	    VDDDeInstallMemoryHook(hVDD, (PVOID) MIOAddress, MIO_PORT_RANGE);
	    if (BaseAddress) {
		VDDFreeMem(hVDD, BaseAddress, PAGE_SIZE);
	    }
	}

        // Deallocate VDD's local heap if needed
        HeapDestroy(hVddHeap);
        break;

    default:
        break;
    }

    return TRUE;
}


VOID
MyInB(
WORD	Port,
PBYTE	Buffer
)

{
// Simply provide the data from our buffer
    *Buffer = IOBuffer[Port - IO_PORT_FIRST];
}

VOID
MyOutB(
WORD Port,
BYTE Data
)

{
    // update our local buffer.
    // In real application, the VDD might want to call its associated
    // device driver to update the change.

    IOBuffer[Port - IO_PORT_FIRST] = (BYTE)Data;

    // If the IO port is the one to trigger DMA operation, do it
    // To demonstarte the two options in handling DMA operation, we
    // use two ports here to trigger different DMS operation schemes.

    if (Port == IO_PORT_FIRE_DMA_FAST) {
	FastDMA();
    }
    else {
	if(Port == IO_PORT_FIRE_DMA_SLOW) {
	    SlowDMA();
	 }
    }
}


VOID
MyMIOHandler(
ULONG	Address,			// faulting linear address
ULONG	RWFlags 			// 1 if write opertion, 0 if read
)
{

	// map the memory for the memory mapped I/O so that we won't
	// get page fault on our memory mapped I/O after this.
	// We may reserve the memory during  DLL_PROCESS_ATTACH (by using
	// MEM_RESERVE rather than MEM_COMMIT we did here).
	// The solution applied here is not the best solution(it is the
	// simplest solution though). A better way to handle memory mapped
	// I/O is to hook the page fault as we did here and decode the faulting
	// instruction, simulate its operation and advance 16 bits application
	// program counter(getIP and setIP).

    if (VDDAllocMem (hVDD, (LPVOID) MIOAddress, PAGE_SIZE)) {
	BaseAddress = (LPVOID)MIOAddress;
    } else {
	OutputDebugString("VDD: Can't allocate virtual memory");
    }
}


/** DMA operation support

Facts:
    - All DMA I/O ports are trapped and maintained by MVDM.
    - VDD provides necessary buffers and calls its associated device
      driver to carry out the real work(in this case, device driver
      will perform real DMA operation with the buffer provided by
      VDD as the source(DMA READ) or destination(DMA WRITE).
    -The device driver has full knowledge of which I/O port(s) are
      connectted to the DMA request channel.
Therefore, the responsibilities of VDD are:
    (1). Allocate necessary buffers
    (2). if it is a DMA write operation(data from I/O to memory)
	    - calls device driver to perform the DMA operation with
	      newly allocated memory as the target buffer for DMA operation.
	    - calls MVDM DMA support routine to transfer data from
	      local buffer to 16bits application buffer.
	    - Simulate an interrupt to the 16 bits applications to notify
	      the completion.
	 if it is a DMA read operation(data from memory to I/O)
	    - calls MVDM DMA service to copy data from 16bits application
	      to the newly allocated buffer.
	    - calls the device driver to carry out DMA operation with
	      the allocated buffer as the source of the operation.
	    - Simulate an interrupt to the 16bits application to notify
	      the completion.
The SlowDMA simulates a DMA READ operation by using VDDRequestDMA service.
The FastDMA simulates a DMA WRITE operation by using VDDQueryDMA and VDDSetDMA
services.

** NOTE **
We run the DMA in the same thread here so that before we return, there is no
way for 16 bits application to regain control. In real world, it would
be appropriate for VDDs to create a thread to do the actual DMA transfer
(interactes with device driver) so that it won't block the 16bits
application from running which will allow 16 bits application to provide
useful information to the users(the application can read DMA registers and
display the progress to the user and so forth)
**/


// This function perform DMA READ operation by using VDDRequestDMA service
BOOLEAN
SlowDMA()
{
 PBYTE DMABuffer, CurDMABuffer;
 DWORD BufferLen;
 DWORD PacketLen;

   //first find out how big the buffer we need and then allocate
   //the buffer from local heap.
   //give 0 for buffer length to ask buffer length
   //the length returned from VDDRequestDMA is the number of byte
   //the DMA operation has to carry out. If the DMA channel is a 16bits
   //the returned length will be 2 times the count value set to the
   // DMA count register.

 BufferLen = VDDRequestDMA(hVDD, DMA_CHANNEL, 0, 0);

 CurDMABuffer = DMABuffer = (PBYTE)HeapAlloc(hVddHeap, 0, BufferLen);
 if (!DMABuffer)  {
     OutputDebugString("VDD: Can't allocate heap memory for VDDRequestDMA");
     return(FALSE);
     }

   // Since this is a DMA read operation(memory -> I/O), 16bits application
   // should have provided necessary data in its local memory and the memory
   // address can be derived from DMA base address register and page register.
   // We don't want to deal with DMA register in this  DMS operation scheme,
   // therefore, we ask MVDM to copy the application data to our local buffer.
   // It may be the case that applications requested a very big data transfer,
   // 128K bytes for example, and we may not allocate enough buffer from our
   // local heap. To overcome the problem, we have to break the data transfer
   // to multiple subblocks and transfer each subblock by calling our device
   // driver. Here we assume we can get the enough buffer from local heap.
   //
   // The device driver should take care of 64k wrap problem of DMA operation.

 BufferLen = VDDRequestDMA(hVDD, DMA_CHANNEL, CurDMABuffer, BufferLen);

   // MVDM updates DMA registers on each VDDReauestDMA. Therefore, after we
   // made this call, the DMA registers maintained by MVDM have been set
   // to the states as the DMA operation has been done(and it is not yet).
   // It may be the case that the 16bits application regains control(as we
   // create a different thread to do the operation) and issues another
   // DMA operation before we(and the device driver) complete the current
   // DMA operation. Keep away from using global variables in this
   // case.

   // We have source data in our local buffer, time to ask device
   // driver to transfer the data to I/O. In case that the device driver
   // can not transfer the whole buffer in a single service call, we
   // call the device driver repeatly until we consume the entire buffer

 while( BufferLen > 0) {
    PacketLen = FakeDD_DMARead(CurDMABuffer, (WORD)BufferLen);
    CurDMABuffer += PacketLen;
    BufferLen -= PacketLen;
 }


    // DMA transfer completed; we simulate an interrupt to the 16bits
    // application. Note that the DMA I/O ports should have been set
    // accordingly by MVDM(through VDDReauestDMA).
    // A real VDD may not do thing this way(VDD has to wait for device
    // driver to finish the data transfer before returning to 16bits application
    // Instead, the VDD and its associated device driver can keep synchronized
    // by using semaphore or other events so that they can keep running in
    // parallel and when receiving a event signal(triggered by the device driver to
    // to notify completion of DMA operation) the VDD can then simulate the
    // interrupt to the 16bits application

 VDDSimulateInterrupt(DMA_INTERRUPT_PIC, DMA_INTERRUPT_LINE, 1);
 HeapFree(hVddHeap, 0, DMABuffer);
 return (TRUE);

}

   // This function simulate a DMA write(I/O to memory) operation
   // It uses VDDQueryDMA and VDDSetDMA services to gain speed

BOOLEAN
FastDMA()
{
    ULONG   DMAAddress;
    DWORD   Size;
    WORD    PacketLen;

    VDD_DMA_INFO    DMAInfo;

    // Get the current DMA registers setting
    VDDQueryDMA(hVDD, DMA_CHANNEL, &DMAInfo);

    // if the DMA channel is not 1 16bits channel, adjust the size
    Size = (DMAInfo.count << DMA_SHIFT_COUNT);

    // seg:off of the DMA transfer address
    DMAAddress = (((ULONG)DMAInfo.page) << (12 + 16))
                 + (DMAInfo.addr >> DMA_SHIFT_COUNT);

    // Get DMA transfer 32bits linear address
    DMAAddress = (ULONG) GetVDMPointer(DMAAddress, Size, 0);

    while(Size) {
	PacketLen = FakeDD_DMAWrite((PBYTE)DMAAddress, (WORD)Size);
	DMAAddress += PacketLen;
	Size -= PacketLen;
	DMAInfo.addr += PacketLen;
	DMAInfo.count -= (PacketLen >> DMA_SHIFT_COUNT);

	// We have to upate the DMA registers even though we are not done
	// the transfer yet. It is a good practice to update the DMA
	// register each time we have really transferred data so that
	// if the 16bits application regains control before DMA operation
	// totally completed, it can get the partial result states and
	// report to users.

	VDDSetDMA(hVDD, DMA_CHANNEL, VDD_DMA_ADDR | VDD_DMA_COUNT,
		  &DMAInfo);
    }

    // see note on SlowDMA
    VDDSimulateInterrupt(DMA_INTERRUPT_PIC, DMA_INTERRUPT_LINE, 1);
    return(TRUE);
}

   // This function is a fake service which should be provided by device
   // drivers in the real world. The thing we do here is to simulate
   // a DMA operation transferring data from the given buffer to
   // to the pre-defined memory mapped I/O port(DMA READ).

WORD  FakeDD_DMARead(PBYTE Buffer, WORD Size)
{
    IOBuffer[IO_PORT_DMA - IO_PORT_FIRST] = Buffer[0];
    return (1);
}

    //This function calls device driver services to start DMA operation
    //and requests the device driver to write the data to the given buffer.
    //Since we are simulating the operation, we simply fill the buffer by
    //reading the predefined I/O port

WORD FakeDD_DMAWrite(PBYTE Buffer, WORD Size)
{
    *Buffer = IOBuffer[IO_PORT_DMA - IO_PORT_FIRST];
    return(1);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\vdd\vjoy\vjoy.h ===
#define JOYSTICK_PORT 0x201


VOID
JoystickPortRead(
    WORD port,
    BYTE *pData
    );

VOID
JoystickPortWrite(
    WORD port,
    BYTE data
    );

BOOL
JoystickInit(
    VOID
    );

DWORD WINAPI
JoystickPollThread(
    LPVOID context
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\vdd\vjoy\vjoy.c ===
/***************************************************************************
*
*   vjoy.c
*
*   Virtual (analog) joystick driver for ntvdm
*
*   Copyright (c) 1991-1996 Microsoft Corporation.  All Rights Reserved.
*
***************************************************************************/


/*****************************************************************************
*
*    #includes
*
*****************************************************************************/

#include <windows.h>              // The VDD is a win32 DLL
#include <vddsvc.h>               // Definition of VDD calls
#include <ntddjoy.h>
#include <vjoy.h>


#define JOY_DRIVER_PATH L"\\\\.\\JOY1"
#define JOYSTICK_POLL_INTERVAL 100

JOY_DD_INPUT_DATA JoyData;
HANDLE hJoyDriver = INVALID_HANDLE_VALUE;
BOOL bInAnalogRead = FALSE;
BOOL bDataValid = FALSE;
ULONG ReadsSinceLastPortWrite = 0;
BOOL bEnabled = FALSE;
BOOL bAttemptedInit = FALSE;
UCHAR JoyFlags = 0xf;

USHORT TimeNdx;
ULONG Times[4];
UCHAR Values[4];
LONG InitialCount;

/*
*    DLL entry point routine.
*    Returns TRUE on success.
*/

BOOL WINAPI
DllEntryPoint(
    HINSTANCE hInstance,
    DWORD reason,
    LPVOID reserved
    )
{
    static VDD_IO_PORTRANGE PortRange;
    static VDD_IO_HANDLERS handlers = {
        JoystickPortRead,
        NULL,
        NULL,
        NULL,
        JoystickPortWrite,
        NULL,
        NULL,
        NULL};

    switch (reason) {

    case DLL_PROCESS_ATTACH:

        DisableThreadLibraryCalls(hInstance);

        PortRange.First = JOYSTICK_PORT;
        PortRange.Last = JOYSTICK_PORT;

        if (!VDDInstallIOHook((HANDLE)hInstance, 1, &PortRange, &handlers)) {
            return FALSE;
        }
        if (!JoystickInit()) {
            VDDDeInstallIOHook((HANDLE)hInstance, 1, &PortRange);
            return FALSE;
        }

        return TRUE;

    case DLL_PROCESS_DETACH:

        bEnabled = FALSE;       // tell thread to exit
        VDDDeInstallIOHook((HANDLE)hInstance, 1, &PortRange);
        return TRUE;

    default:
        return TRUE;
    }
}


BOOL
JoystickInit(
    VOID
    )
{
    HANDLE tHandle;
    ULONG ThreadId;
    ULONG numread;

    // BUGBUG: Should be using MM calls instead of this
    hJoyDriver = CreateFile(JOY_DRIVER_PATH,
                            GENERIC_READ,
                            0,
                            (LPSECURITY_ATTRIBUTES) NULL,
                            OPEN_EXISTING,
                            0,
                            (HANDLE) NULL);


    if (hJoyDriver != INVALID_HANDLE_VALUE) {


        if(!(tHandle = CreateThread(NULL, 0, JoystickPollThread,
                                    NULL, CREATE_SUSPENDED, &ThreadId))) {
            CloseHandle(hJoyDriver);
            return FALSE;
        }
        bEnabled = TRUE;

        //
        // Do an initial read
        //
        if (ReadFile(hJoyDriver, &JoyData, sizeof(JOY_DD_INPUT_DATA), &numread, NULL)) {
            bDataValid = TRUE;
        } else {
            bDataValid = FALSE;
        }

        ResumeThread(tHandle);
        CloseHandle(tHandle);
    }
    return TRUE;
}



VOID
JoystickPortRead(
    WORD port,
    BYTE *pData
    )
{
    BYTE data = 0xff;
    USHORT CurrentTime;
    LONG TargetTime;
    USHORT TargetCount;
    LONG USecsElapsed;
    ULONG TargetValue;
    static USHORT LastWriteTime;
    static LONG InitialCount;

    if (!bAttemptedInit) {
        bAttemptedInit = TRUE;
        JoystickInit();
    }

    if (!bEnabled) {
        *pData = data;
        return;
    }

    if (bDataValid && !JoyData.Unplugged) {

        //
        // Get the button state
        //
        data = (BYTE) ((~JoyData.Buttons << 4) & 0xf0);


        //
        // Get the analog resistive inputs
        //

        if (bInAnalogRead) {
            if (!ReadsSinceLastPortWrite) {
                VdmParametersInfo(VDM_GET_TIMER0_INITIAL_COUNT, &InitialCount, sizeof(LONG));
                VdmParametersInfo(VDM_GET_LAST_UPDATED_TIMER0_COUNT, &LastWriteTime, sizeof(USHORT));
                VDM_TRACE(0x6a1, (USHORT) 0, LastWriteTime);
            }

            if (++ReadsSinceLastPortWrite > 256) {
                // Too much time elapsed, we are done
                VDM_TRACE(0x6bf, 0, 0);
                if (JoyData.XTime) {
                    JoyFlags &= ~1;
                }
                if (JoyData.YTime) {
                    JoyFlags &= ~2;
                }
                if (JoyData.ZTime) {
                    JoyFlags &= ~4;
                }
                if (JoyData.TTime) {
                    JoyFlags &= ~8;
                }
                bInAnalogRead = FALSE;
            } else {

                TargetTime = (LONG)(LastWriteTime - (USHORT)(Times[TimeNdx]*3));
                if (TargetTime < 0) {
                    TargetTime += InitialCount;
                }

                TargetCount = (USHORT) TargetTime;
                VdmParametersInfo(VDM_SET_NEXT_TIMER0_COUNT, &TargetCount, sizeof(USHORT));
                VDM_TRACE(0x6b2, Values[TimeNdx], TargetTime);
                JoyFlags &= ~Values[TimeNdx];

                if (++TimeNdx >= 4) {
                    bInAnalogRead = FALSE;
                }
            }
        }

        data += JoyFlags;
    }

    *pData = data;

//    VDM_TRACE(0x6b0, data, 0);
}

VOID
JoystickPortWrite(
    WORD port,
    BYTE data
    )
{
    ULONG numread;
    ULONG TTim;
    CHAR TVal;
    int i, j;

    if (!bAttemptedInit) {
        bAttemptedInit = TRUE;
        JoystickInit();
    }

    ReadsSinceLastPortWrite = 0;
    JoyFlags = 0xf;

    Values[0] = 1;
    Values[1] = 2;
    Values[2] = 4;
    Values[3] = 8;
    Times[0] = JoyData.XTime;
    Times[1] = JoyData.YTime;
    Times[2] = JoyData.ZTime;
    Times[3] = JoyData.TTime;
    //
    // Sort them
    // Using just a bubble sort here with 4 items...
    //
    for (i=0; i<3; i++) {
        for (j=0; j<3-i; j++) {
            if (Times[j] > Times[j+1]) {
                TTim = Times[j];
                TVal = Values[j];
                Times[j] = Times[j+1];
                Values[j] = Values[j+1];
                Times[j+1] = TTim;
                Values[j+1] = TVal;
            }
        }
    }
    for (TimeNdx=0; TimeNdx<4; TimeNdx++) {
        if (Times[TimeNdx]) {
            break;
        }
    }

    if (TimeNdx < 4) {
        bInAnalogRead = TRUE;
    }

    for (i=0; i<4; i++) {
        VDM_TRACE(0x6a0, (USHORT) Values[i], Times[i]);
    }
}


DWORD WINAPI
JoystickPollThread(
    LPVOID context
    )
{
    ULONG numread;

    while(bEnabled) {

        Sleep(JOYSTICK_POLL_INTERVAL);

        if (ReadFile(hJoyDriver, &JoyData, sizeof(JOY_DD_INPUT_DATA), &numread, NULL)) {
            bDataValid = TRUE;
        } else {
            bDataValid = FALSE;
        }
    }
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\vdd\vsndblst\dsp.c ===
/***************************************************************************
*
*    dsp.c
*
*    Copyright (c) 1991-1996 Microsoft Corporation.  All Rights Reserved.
*
*    This code provides VDD support for SB 2.0 sound output, specifically:
*        DSP 2.01+ (excluding SB-MIDI port)
*
***************************************************************************/


/*****************************************************************************
*
*    #includes
*
*****************************************************************************/

#include <windows.h>              // The VDD is a win32 DLL
#include <mmsystem.h>             // Multi-media APIs
#include <vddsvc.h>               // Definition of VDD calls
#include <vsb.h>
#include <dsp.h>


/*****************************************************************************
*
*    Globals
*
*****************************************************************************/

//
// Definitions for MM api entry points. The functions will be linked
// dynamically to avoid bringing winmm.dll in before wow32.
//
extern SETVOLUMEPROC SetVolumeProc;
extern GETNUMDEVSPROC GetNumDevsProc;
extern GETDEVCAPSPROC GetDevCapsProc;
extern OPENPROC OpenProc;
extern RESETPROC ResetProc;
extern CLOSEPROC CloseProc;
extern GETPOSITIONPROC GetPositionProc;
extern WRITEPROC WriteProc;
extern PREPAREHEADERPROC PrepareHeaderProc;
extern UNPREPAREHEADERPROC UnprepareHeaderProc;

/*
 *    General globals
 */

extern HINSTANCE GlobalHInstance; // handle passed to dll entry point
BYTE IdentByte; // used with DSP_CARD_IDENTIFY
BOOL SpeakerOn = FALSE; // TRUE when speaker is on
BYTE ReservedRegister; // used with DSP_LOAD_RES_REG and DSP_READ_RES_REG
ULONG PageSize;         // size of pages for VirtualAlloc
ULONG iHdr;             // used to index wavehdr array

/*
 *    Event Globals
 */
HANDLE SingleWaveSem; // used by app to indicate data to write
HANDLE PauseEvent; // used to restart paused single
HANDLE ThreadStarted;  // signalled when thread starts running
HANDLE ThreadFinished; // signalled when thread exits

/*
 *    Wave globals
 */

UINT WaveOutDevice; // device identifier
HWAVEOUT HWaveOut = NULL; // the current open wave output device
PCMWAVEFORMAT WaveFormat = { { WAVE_FORMAT_PCM, 1, 0, 0, 1 }, 8};
DWORD TimeConstant = (256 - 1000000/11025); // one byte format
DWORD SBBlockSize = 0x800; // Block size set by apps, always size of transfer-1
DWORD LookAheadFactor = DEFAULT_LOOKAHEAD;

VDD_DMA_INFO dMAInfo;
DWORD dMAPhysicalStart; // the starting address for this transfer
DWORD dMACurrentPosition; // where we are currently reading from
DWORD dMAVirtualStart; // what the app thinks the addr is for this transfer
ULONG dMASize; // the size of the DMA memory-1

WAVEHDR * WaveHdrs; // pointer to allocated wave headers
BYTE * WaveData; // pointer to allocated wave buffer
ULONG TotalNumberOfBursts;
ULONG BurstsPerBlock;
ULONG DesiredBytesOutstanding;
ULONG BytesOutstanding = 0;
ULONG PhysicalBytesPlayed = 0;
ULONG LastBytesPlayedValue;

BOOL bDspActive = FALSE; // dsp thread currently active, changed with interlocked
BOOL bDspPause = FALSE;  // dsp paused, changed with interlocked
BOOL bDspReset = FALSE;  // dsp stopped, changed with interlocked


enum {
    Auto,
    Single
} DspMode;

/*****************************************************************************
*
*    State Machines
*
*****************************************************************************/

/*
*    DSP Reset State Machine
*/

enum {
    ResetNotStarted = 1,
    Reset1Written
}
ResetState = ResetNotStarted; // state of current reset

/*
*    DSP Write State Machine
*/

enum {
    WriteCommand = 1, // Initial state and after reset
    CardIdent,
    TableMunge,
    LoadResReg,
    SetTimeConstant,
    BlockSizeFirstByte,
    BlockSizeSecondByte,
    BlockSizeFirstByteWrite,
    BlockSizeSecondByteWrite,
    BlockSizeFirstByteRead,
    BlockSizeSecondByteRead
}
DSPWriteState = WriteCommand; // state of current command/data being written

/*
*    DSP Read State Machine
*/

enum {
    NothingToRead = 1, // initial state and after reset
    Reset,
    FirstVersionByte,
    SecondVersionByte,
    ReadIdent,
    ReadResReg
}
DSPReadState = NothingToRead; // state of current command/data being read


/*****************************************************************************
*
*    General Functions
*
*****************************************************************************/

BOOL
DspProcessAttach(
    VOID
    )
{
    HKEY hKey;
    ULONG dwType;
    ULONG cbData;
    SYSTEM_INFO SystemInfo;

    // create synchronization events
    PauseEvent=CreateEvent(NULL, FALSE, FALSE, NULL);
    SingleWaveSem=CreateSemaphore(NULL, 1, 100, NULL);
    ThreadStarted=CreateEvent(NULL, FALSE, FALSE, NULL);
    ThreadFinished=CreateEvent(NULL, FALSE, FALSE, NULL);

    if (!RegOpenKeyEx (HKEY_LOCAL_MACHINE,
                            VSBD_PATH,
                            0,
                            KEY_EXECUTE, // Requesting read access.
                            &hKey)) {


        cbData = sizeof(ULONG);
        RegQueryValueEx(hKey,
                        LOOKAHEAD_VALUE,
                        NULL,
                        &dwType,
                        (LPSTR)&LookAheadFactor,
                        &cbData);

        RegCloseKey(hKey);

    }

    // Allocate memory for wave buffer
    WaveData = (BYTE *) VirtualAlloc(NULL,
                                     64*1024,
                                     MEM_RESERVE,
                                     PAGE_READWRITE);

    if(WaveData == NULL ) {
        dprintf1(("Unable to allocate memory"));
        return(FALSE);
    }

    GetSystemInfo(&SystemInfo);
    PageSize = SystemInfo.dwPageSize;
    return TRUE;
}

VOID
DspProcessDetach(
    VOID
    )
{
    // stop any active threads
    StopAutoWave(FALSE);
    StopSingleWave(FALSE);
    // close synchronization events
    CloseHandle(PauseEvent);
    CloseHandle(SingleWaveSem);
    CloseHandle(ThreadStarted);
    CloseHandle(ThreadFinished);
    VirtualFree(WaveData, 0, MEM_RELEASE);
}


/***************************************************************************/

/*
*    Gets called when the application reads from port.
*    Returns results to application in data.
*/
VOID
DspReadStatus(
    BYTE * data
    )
{
    // See if we think there is something to read
    *data = DSPReadState != NothingToRead ? 0xFF : 0x7F;
}



VOID
DspReadData(
    BYTE * data
    )
{
    switch (DSPReadState) {
    case NothingToRead:
        *data = 0xFF;
        break;

    case Reset:
        *data = 0xAA;
        DSPReadState = NothingToRead;
        break;

    case FirstVersionByte:
        *data = (BYTE)(SB_VERSION / 256);
        DSPReadState = SecondVersionByte;
        break;

    case SecondVersionByte:
        *data = (BYTE)(SB_VERSION % 256);
        DSPReadState = NothingToRead;
        break;

    case ReadIdent:
        *data = ~IdentByte;
        DSPReadState = NothingToRead;
        break;

    case ReadResReg:
        *data = ReservedRegister;
        DSPReadState = NothingToRead;
        break;

    default:
        dprintf1(("Unrecognized read state"));
    }

}

/***************************************************************************/

/*
*    Gets called when an application writes data to port.
*/

VOID
DspResetWrite(
    BYTE data
    )
{
    if (data == 1) {
        ResetState = Reset1Written;
    }
    else {
        if (ResetState == Reset1Written && data == 0) {
            ResetState = ResetNotStarted;
            ResetAll(); // OK - reset everything
        }
    }
}

VOID
DspWrite(
    BYTE data
    )
{
    DWORD ddata;

    switch (DSPWriteState) {
    case WriteCommand:
        WriteCommandByte(data);
        break;

    case CardIdent:
        IdentByte = data;
        DSPReadState = ReadIdent;
        DSPWriteState = WriteCommand;
        break;

    case TableMunge:
        TableMunger(data);
        DSPWriteState = WriteCommand;
        break;

    case LoadResReg:
        ReservedRegister = data;
        DSPWriteState = WriteCommand;
        break;

    case SetTimeConstant:
        TimeConstant =  (DWORD)data;
        dprintf3(("Time constant is %X", TimeConstant));
        dprintf3(("Set sampling rate %d", GetSamplingRate()));
        DSPWriteState = WriteCommand;
        break;

    case BlockSizeFirstByte:
        SBBlockSize = (DWORD)data;
        DSPWriteState = BlockSizeSecondByte;
        break;

    case BlockSizeSecondByte:
        ddata = data;
        SBBlockSize = SBBlockSize + (ddata << 8);
        DSPWriteState = WriteCommand;
        dprintf2(("Block size set to 0x%x", SBBlockSize));
        break;

    case BlockSizeFirstByteWrite:
        SBBlockSize = (DWORD)data;
        DSPWriteState = BlockSizeSecondByteWrite;
        break;

    case BlockSizeSecondByteWrite:
        ddata = data;
        SBBlockSize = SBBlockSize + (ddata << 8);
        DSPWriteState = WriteCommand;
        dprintf3(("Block size set to 0x%x", SBBlockSize));
        // this is a hack to convince some apps a sb exists
        if(SBBlockSize==0) {
            VDM_TRACE(0x6a0,0,0);
            GenerateInterrupt();
        }
        StartSingleWave();
        break;

    case BlockSizeFirstByteRead:
        SBBlockSize = (DWORD)data;
        DSPWriteState = BlockSizeSecondByteRead;
        break;

    case BlockSizeSecondByteRead:
        ddata = data;
        SBBlockSize = SBBlockSize + (ddata << 8);
        DSPWriteState = WriteCommand;
        dprintf3(("Block size set to 0x%x", SBBlockSize));
        // this is a hack to convince some apps a sb exists
        if(SBBlockSize==0) {
            ULONG dMAPhysicalAddress;
            if((dMAPhysicalAddress=GetDMATransferAddress()) != -1L) {
                *(PUCHAR)dMAPhysicalAddress = 0x80;
            }
            VDM_TRACE(0x6a0,0,0);
            GenerateInterrupt();
        }
        break;
    }
}

/***************************************************************************/

/*
*  Handles commands sent to the DSP.
*/

VOID
WriteCommandByte(
    BYTE command
    )
{
    switch (command) {
    case DSP_GET_VERSION:
        dprintf2(("Command - Get Version"));
        DSPReadState = FirstVersionByte;
        break;

    case DSP_CARD_IDENTIFY:
        dprintf2(("Command - Identify"));
        DSPWriteState = CardIdent;
        break;

    case DSP_TABLE_MUNGE:
        dprintf2(("Command - DSP Table Munge"));
        DSPWriteState = TableMunge;
        break;

    case DSP_LOAD_RES_REG:
        dprintf2(("Command - Load Res Reg"));
        DSPWriteState = LoadResReg;
        break;

    case DSP_READ_RES_REG:
        dprintf2(("Command - Read Res Reg"));
        DSPReadState = ReadResReg;
        break;

    case DSP_GENERATE_INT:
        dprintf2(("Command - Generate interrupt DMA"));
        GenerateInterrupt();
        break;

    case DSP_SPEAKER_ON:
        dprintf2(("Command - Speaker ON"));
        SetSpeaker(TRUE);
        break;

    case DSP_SPEAKER_OFF:
        dprintf2(("Command - Speaker OFF"));
        SetSpeaker(FALSE);
        break;

    case DSP_SET_SAMPLE_RATE:
        dprintf3(("Command - Set Sample Rate"));
        DSPWriteState = SetTimeConstant;
        break;

    case DSP_SET_BLOCK_SIZE:
        dprintf2(("Command - Set Block Size"));
        DSPWriteState =  BlockSizeFirstByte;
        break;

    case DSP_PAUSE_DMA:
        dprintf2(("Command - Pause DMA"));
        PauseDMA();
        break;

    case DSP_CONTINUE_DMA:
        dprintf2(("Command - Continue DMA"));
        ContinueDMA();
        break;

    case DSP_STOP_AUTO:
        dprintf2(("Command - Stop DMA"));
        StopAutoWave(TRUE);
        break;

    case DSP_WRITE:
    case DSP_WRITE_HS:
        dprintf3(("Command - Write - non Auto"));
        DSPWriteState = BlockSizeFirstByteWrite;
        break;

    case DSP_WRITE_AUTO:
    case DSP_WRITE_HS_AUTO:
        dprintf2(("Command - Write - Auto"));
        StartAutoWave();
        break;

    case DSP_READ:
        dprintf3(("Command - Read - non Auto"));
        DSPWriteState = BlockSizeFirstByteRead;
        break;

    default:
        dprintf1(("Unrecognized DSP command %2X", command));
    }
}


/*****************************************************************************
*
*    Device manipulation and control routines
*
*****************************************************************************/

/*
*    Reset threads/globals/events/state-machines to initial state.
*/

VOID
ResetDSP(
    VOID
    )
{

    // Stop any active DMA threads
    StopAutoWave(TRUE);
    StopSingleWave(TRUE);

    // Set events and globals to initial state
    ResetEvent(PauseEvent);
    CloseHandle(SingleWaveSem);
    SingleWaveSem=CreateSemaphore(NULL, 1, 100, NULL);
    ResetEvent(ThreadStarted);
    ResetEvent(ThreadFinished);

    SetSpeaker(FALSE);
    SpeakerOn = FALSE;

    HWaveOut = NULL;
    TimeConstant = (256 - 1000000/11025);
    WaveFormat.wf.nSamplesPerSec = 0;
    WaveFormat.wf.nAvgBytesPerSec = 0;
    SBBlockSize = 0x800;

    bDspActive = FALSE;
    bDspReset = FALSE;
    bDspPause = FALSE;

    // Reset state machines
    DSPReadState = Reset;
    DSPWriteState = WriteCommand;
}

/***************************************************************************/

/*
*    Munges (changes) a jump table in apps code,
*    Algorithm from sbvirt.asm in MMSNDSYS.
*/

VOID
TableMunger(
    BYTE data
    )
{
    static BYTE TableMungeData;
    static BOOL TableMungeFirstByte = TRUE; // munging first or second byte
    BYTE comp, dataCopy;
    VDD_DMA_INFO dMAInfo;
    ULONG dMAPhysicalAddress;

    if(TableMungeFirstByte) {
        dprintf2(("Munging first byte"));
        dataCopy = data;
        dataCopy = dataCopy & 0x06;
        dataCopy = dataCopy << 1;
        if(data & 0x10) {
            comp = 0x40;
        }
        else {
            comp = 0x20;
        }
        comp = comp - dataCopy;
        data = data + comp;
        TableMungeData = data;

        // Update memory (code table) with munged data
        dprintf2(("Writing first byte"));
        if((dMAPhysicalAddress=GetDMATransferAddress()) == -1L) {
            dprintf1(("Unable to get dma address"));
            return;
        }
        CopyMemory((PVOID)dMAPhysicalAddress, &data, 1);

        // Update virtual DMA status
        VDDQueryDMA((HANDLE)GlobalHInstance, SB_DMA_CHANNEL, &dMAInfo);
        dprintf4(("DMA Info : addr  %4X, count %4X, page %4X, status %2X, mode %2X, mask %2X",
          dMAInfo.addr, dMAInfo.count, dMAInfo.page, dMAInfo.status,
          dMAInfo.mode, dMAInfo.mask));
        dMAInfo.count = dMAInfo.count - 1;
        dMAInfo.addr = dMAInfo.addr + 1;
        VDDSetDMA((HANDLE)GlobalHInstance, SB_DMA_CHANNEL,
          VDD_DMA_COUNT|VDD_DMA_ADDR, &dMAInfo);
        TableMungeFirstByte = FALSE;
    }
    else {
        dprintf2(("Munging second byte"));
        data = data ^ 0xA5;
        data = data + TableMungeData;
        TableMungeData = data;

        // Update memory (code table) with munged data
        dprintf2(("Writing second byte"));
        if((dMAPhysicalAddress=GetDMATransferAddress()) == -1L) {
            dprintf1(("Unable to get dma address"));
            return;
        }
        CopyMemory((PVOID)dMAPhysicalAddress, &data, 1);

        // Update virtual DMA status
        VDDQueryDMA((HANDLE)GlobalHInstance, SB_DMA_CHANNEL, &dMAInfo);
        dMAInfo.count = dMAInfo.count - 1;
        dMAInfo.addr = dMAInfo.addr + 1;
        VDDSetDMA((HANDLE)GlobalHInstance, SB_DMA_CHANNEL,
          VDD_DMA_COUNT|VDD_DMA_ADDR, &dMAInfo);
        if(dMAInfo.count==0xFFFF) {
            SetDMAStatus(FALSE, TRUE);
        }
        TableMungeFirstByte = TRUE;
    }
}

/***************************************************************************/

/*
*    Get sampling rate from time constant.
*    Returns sampling rate.
*/

DWORD
GetSamplingRate(
    VOID
    )
{
    // Sampling rate = 1000000 / (256 - Time constant)
    return(1000000 / (256 - TimeConstant));
}

/***************************************************************************/

/*
*    Generate device interrupt on dma channel SM_INTERRUPT on ICA_MASTER device.
*/

VOID
GenerateInterrupt(
    VOID
    )
{
    // Generate an interrupt on the master controller
    dprintf3(("Generating interrupt"));
    VDM_TRACE(0x6a1,0,0);
    VDDSimulateInterrupt(ICA_MASTER, SB_INTERRUPT, 1);
}

/***************************************************************************/

/*
*    Sets the speaker on or off.
*/

VOID
SetSpeaker(
    BOOL On
    )
{
    if (HWaveOut) {
        if(On) {
            SetVolumeProc(HWaveOut, (DWORD)0x77777777UL);
            SpeakerOn = TRUE;
    }
        else {
            SetVolumeProc(HWaveOut, (DWORD)0x00000000UL);
            SpeakerOn = FALSE;
        }
    }

    return;
}


/****************************************************************************
*
*    Wave device routines
*
****************************************************************************/

/*
*    Find a suitable wave output device.
*    Returns device or NO_DEVICE_FOUND if none found.
*/

UINT
FindWaveDevice(
    VOID
    )
{
    UINT numDev;
    UINT device;
    WAVEOUTCAPS wc;

    numDev = GetNumDevsProc();

    for (device = 0; device < numDev; device++) {
        if (MMSYSERR_NOERROR == GetDevCapsProc(device, &wc, sizeof(wc))) {
            // Need 11025 and 44100 for device
            if ((wc.dwFormats & (WAVE_FORMAT_1M08 | WAVE_FORMAT_4M08)) ==
              (WAVE_FORMAT_1M08 | WAVE_FORMAT_4M08)) {
                WaveOutDevice = device;
                return TRUE;
            }
        }
    }

    dprintf1(("Wave device not found"));
    return FALSE;
}

/***************************************************************************/

/*
*    Open wave device and start synchronization thread.
*    Returns TRUE on success.
*/

BOOL
OpenWaveDevice(
    VOID
    )
{
    UINT rc;
    HANDLE tHandle;

    rc = OpenProc(&HWaveOut, (UINT)WaveOutDevice, (LPWAVEFORMATEX)
                         &WaveFormat, 0, 0, CALLBACK_NULL);

    if (rc != MMSYSERR_NOERROR) {
        dprintf1(("Failed to open wave device - code %d", rc));
        return FALSE;
    }

    BytesOutstanding = 0;
    PhysicalBytesPlayed = 0;
    return TRUE;
}

/***************************************************************************/

/*
*    Reset wave device.
*/

VOID
ResetWaveDevice(
    VOID
    )
{
    // No synchronization required

    dprintf2(("Resetting wave device"));
    if (HWaveOut) {
        if(MMSYSERR_NOERROR != ResetProc(HWaveOut)) {
            dprintf1(("Unable to reset wave out device"));
        }
    }
}

/***************************************************************************/

/*
*    Shut down and close wave device.
*/

VOID
CloseWaveDevice(
    VOID
    )
{

    dprintf2(("Closing wave device"));

    ResetWaveDevice();

    if (HWaveOut) {
        if(MMSYSERR_NOERROR != CloseProc(HWaveOut)) {
            dprintf1(("Unable to close wave out device"));
        } else {
            HWaveOut = NULL;
            dprintf2(("Wave out device closed"));
        }
    }
}

/***************************************************************************/

/*
*    Returns TRUE if current wave device supports sample rate.
*/

BOOL
TestWaveFormat(
    DWORD sampleRate
    )
{
    PCMWAVEFORMAT format;

    format = WaveFormat;
    format.wf.nSamplesPerSec = sampleRate;
    format.wf.nAvgBytesPerSec = sampleRate;

    return(MMSYSERR_NOERROR == OpenProc(NULL, (UINT)WaveOutDevice,
                                        (LPWAVEFORMATEX) &format,
                                        0, 0, WAVE_FORMAT_QUERY));
}

/***************************************************************************/

/*
*    Make sure we've got a device that matches the current sampling rate.
*    Returns TRUE if device does NOT support current sampling rate and
*    wave format has changed, otherwise returns FALSE
*/

BOOL
SetWaveFormat(
    VOID
    )
{
    DWORD sampleRate;
    DWORD testValue;
    UINT i = 0;

    if (TimeConstant != 0xFFFF) {
        // time constant has been reset since last checked
        sampleRate = GetSamplingRate();
        dprintf3(("Requested sample rate is %d", sampleRate));

        if (sampleRate != WaveFormat.wf.nSamplesPerSec) {  // format has changed
            if (!TestWaveFormat(sampleRate)) {
                 dprintf3(("Finding closest wave format"));
                 // find some format that works and is close to requested
                 for(i=0; i<50000; i++) {
                     testValue = sampleRate-i;
                     if(TestWaveFormat(testValue)) {
                         sampleRate = testValue;
                         break;
                     }
                     testValue = sampleRate+i;
                     if(TestWaveFormat(testValue)) {
                         sampleRate = testValue;
                         break;
                     }
                 }
                 if(sampleRate!=testValue) {
                     dprintf1(("Unable to find suitable wave format"));
                     return FALSE;
                 }
            }

            // Set the new format if it's changed
            if (sampleRate != WaveFormat.wf.nSamplesPerSec) {
                   dprintf2(("Setting %d samples per second", sampleRate));
                   WaveFormat.wf.nSamplesPerSec = sampleRate;
                   WaveFormat.wf.nAvgBytesPerSec = sampleRate;
                   TimeConstant = 0xFFFF;
                   return TRUE;
            }
        }
    }

    TimeConstant = 0xFFFF;
    return FALSE;
}

/***************************************************************************/

/*
*    Stops auto init DMA, or pauses single cycle DMA.
*/

VOID
PauseDMA(
    VOID
    )
{
    DWORD position = 0;
    MMTIME mmTime;

    dprintf2(("Pausing DMA"));

    switch(DspMode) {
    case Auto:
        StopAutoWave(TRUE); // simply stop auto dma
        break;

    case Single:
        ResetEvent(PauseEvent);
        InterlockedExchange(&bDspPause, 1);
    }
}

/***************************************************************************/

/*
*    Start auto init DMA, or continues single cycle DMA.
*/

VOID
ContinueDMA(
    VOID
    )
{

    switch(DspMode) {
    case Auto:
        StartAutoWave();
        break;

    case Single:
        SetEvent(PauseEvent);
    }
}

/***************************************************************************/

/*
*    Get DMA transfer address.
*    Returns transfer address or -1 on failure.
*/

ULONG
GetDMATransferAddress(
    VOID
    )
{
    ULONG address;
    VDD_DMA_INFO dMAInfo;

    if (VDDQueryDMA((HANDLE)GlobalHInstance, SB_DMA_CHANNEL, &dMAInfo)) {
        dprintf4(("DMA Info : addr  %4X, count %4X, page %4X, status %2X, mode %2X, mask %2X",
          dMAInfo.addr, dMAInfo.count, dMAInfo.page, dMAInfo.status,
          dMAInfo.mode, dMAInfo.mask));

        // convert from 20 bit address to 32 bit address
        address = (((DWORD)dMAInfo.page) << (12 + 16)) + dMAInfo.addr;
        // get VDM pointer
        address = (ULONG)GetVDMPointer(address, ((DWORD)dMAInfo.count) + 1, 0);

        dprintf3(("Transfer address = %8X", (DWORD)address));

        return(address);
    }
    else {
        dprintf1(("Could not retrieve DMA Info"));
        return(ULONG)(-1L);
    }
}


/***************************************************************************/

/*
*    Update the virtual DMA terminal count and request status.
*    Terminal count (tc) is set when DMA count loops to 0xFFFF.
*    Request status is set when DMA has data to transfer
*    (ignored in auto-init DMA).
*/

VOID
SetDMAStatus(
    BOOL requesting,
    BOOL tc
    )
{
    VDD_DMA_INFO dMAInfo;

    if (VDDQueryDMA((HANDLE)GlobalHInstance, SB_DMA_CHANNEL, &dMAInfo)) {
        dprintf4(("DMA Info : addr  %4X, count %4X, page %4X, status %2X, mode %2X, mask %2X",
          dMAInfo.addr, dMAInfo.count, dMAInfo.page, dMAInfo.status,
          dMAInfo.mode, dMAInfo.mask));

        if (requesting) {
            dMAInfo.status |= (0x10 << SB_DMA_CHANNEL); // Requesting
            dprintf3(("DMA set as requesting"));
        } else {
            dMAInfo.status &= ~(0x10 << SB_DMA_CHANNEL); // Not Requesting
            dprintf3(("DMA set as not requesting"));
        }

        if (tc) {
            dMAInfo.status |= (1 << SB_DMA_CHANNEL); // tc reached
            dprintf3(("DMA set as terminal count reached"));
        } else {
            dMAInfo.status &= ~(1 << SB_DMA_CHANNEL); // tc not reached
            dprintf3(("DMA set as terminal count not reached"));
        }
        VDDSetDMA((HANDLE)GlobalHInstance, SB_DMA_CHANNEL, VDD_DMA_STATUS,
          &dMAInfo);
    }
    else {
        dprintf1(("Could not retrieve DMA Info"));
    }
}


/***************************************************************************/

/*
*    Start an auto wave.
*    Returns TRUE on success.
*/

BOOL
StartAutoWave(
    VOID
    )
{
    HANDLE tHandle;  // handle to auto thread
    VDD_DMA_INFO dMAInfo;
    ULONG i;
    DWORD id;

    dprintf2(("Starting auto wave"));
    StopSingleWave(TRUE);

    DspMode = Auto;

    // Open device
    SetWaveFormat();
    if (!OpenWaveDevice()) {
        dprintf1(("Can't open wave device", GetLastError()));
        return FALSE;
    }


    if(!(tHandle = CreateThread(NULL, 0, AutoThreadEntry, NULL,
      CREATE_SUSPENDED, &id))) {
        dprintf1(("Create auto thread failed code %d", GetLastError()));
        return FALSE;
    } else {
        if(!SetThreadPriority(tHandle, THREAD_PRIORITY_HIGHEST)) {
            dprintf1(("Unable to set auto thread priority"));
        }
    }

    ResumeThread(tHandle);
    CloseHandle(tHandle);
    WaitForSingleObject(ThreadStarted, INFINITE);

    return TRUE;
}


/***************************************************************************/

/*
*    Stop Auto thread,
*    Should always be called with TRUE,
*    except if process exiting as wait causes deadlock
*/

VOID
StopAutoWave(
    BOOL wait
    )
{
    if(bDspActive && (DspMode == Auto)) {
        dprintf2(("Stopping auto init"));
        InterlockedExchange(&bDspReset, TRUE);
        if(wait) {
            dprintf2(("Waiting for auto thread to exit"));
            WaitForSingleObject(ThreadFinished, INFINITE);
            dprintf2(("Auto thread has exited"));
        }
    }
}


/***************************************************************************/

/*
*    Start a single cycle wave.
*    Returns TRUE on success.
*/

BOOL
StartSingleWave(
    VOID
    )
{
    HANDLE tHandle; // handle to single thread
    DWORD id;
    ULONG i;

    StopAutoWave(TRUE);

    DspMode = Single;

    if(!bDspActive) {
        dprintf2(("Starting single cycle wave"));
        if(!(tHandle = CreateThread(NULL, 0, SingleThreadEntry, NULL,
                                    CREATE_SUSPENDED, &id))) {

            dprintf1(("Create single cycle thread failed code %d", GetLastError()));
            return FALSE;

        } else {
            // set synchronization events to a known state
            InterlockedExchange(&bDspActive, TRUE);
            InterlockedExchange(&bDspPause, FALSE);
            InterlockedExchange(&bDspReset, FALSE);

            CloseHandle(SingleWaveSem);
            SingleWaveSem=CreateSemaphore(NULL, 1, 100, NULL);

            if(!SetThreadPriority(tHandle, THREAD_PRIORITY_HIGHEST)) {
                dprintf1(("Unable to set thread priority"));
            }
            ResumeThread(tHandle);
            CloseHandle(tHandle);

            WaitForSingleObject(ThreadStarted, INFINITE);
            return TRUE;
        }
    } else {
        ContinueDMA(); // if app has paused dma
        ReleaseSemaphore(SingleWaveSem, 1, NULL); // new buffer to be written
        return TRUE;
    }
    Sleep(500);
}


/***************************************************************************/

/*
*    Stop single cycle thread,
*    Should always be called with TRUE,
*    except if process exiting as wait causes deadlock.
*/

VOID
StopSingleWave(
    BOOL wait
    )
{

    if(bDspActive && (DspMode == Single)) {
        dprintf2(("Stopping single wave"));
        InterlockedExchange(&bDspReset, TRUE);

        ContinueDMA(); // if app has paused DMA
        ReleaseSemaphore(SingleWaveSem, 1, NULL);

        if(wait) {
            dprintf2(("Waiting for single thread to exit"));
            WaitForSingleObject(ThreadFinished, INFINITE);
            dprintf2(("Single thread has exited"));
        }
    }
}


/***************************************************************************/

/*
 *    GetWaveOutPosition
*/

BOOL
GetWaveOutPosition(
    PULONG pPos
    )
{
    MMTIME mmTime;

    mmTime.wType = TIME_BYTES;

    if (MMSYSERR_NOERROR == GetPositionProc(HWaveOut, &mmTime, sizeof(MMTIME))) {
        VDM_TRACE(0x640, 0x640, mmTime.u.cb);
        *pPos = mmTime.u.cb;
        return TRUE;
    }
    return FALSE;
}

VOID
WaitOnWaveOutIdle(
    VOID
    )
{
    ULONG LastBytesPlayedValue = 0;
    ULONG PhysicalBytesPlayed;
    //
    // Allow the device to finish playing current sounds before nuking buffers
    //
    while(GetWaveOutPosition(&PhysicalBytesPlayed)) {
        if (LastBytesPlayedValue == PhysicalBytesPlayed) {
            break;  // no sounds are playing
        }
        LastBytesPlayedValue = PhysicalBytesPlayed;
        Sleep(1);
    }
}

/***************************************************************************/

/*
 *    WriteBurst
*/

BOOL
WriteBurst(
    WAVEHDR * WaveHdr
    )
{
    MMRESULT mmResult;

    // Copy data to current buffer
    dprintf3(("Copying data to buffer %8X from %4X", WaveHdr->lpData,
               dMACurrentPosition));

    RtlCopyMemory(WaveHdr->lpData,
                  (CONST VOID *)dMACurrentPosition,
                  WaveHdr->dwBufferLength);

    dMACurrentPosition += WaveHdr->dwBufferLength;

    // Update virtual DMA status
    dMAInfo.count = (WORD)(dMASize - (dMACurrentPosition-dMAPhysicalStart));
    dMAInfo.addr = (WORD)(dMAVirtualStart +
                   (dMACurrentPosition-dMAPhysicalStart));
    dprintf3(("Updated Dma Position = %4X, count = %4X", dMAInfo.addr,
             dMAInfo.count));

    VDDSetDMA((HANDLE)GlobalHInstance, SB_DMA_CHANNEL,
              VDD_DMA_COUNT|VDD_DMA_ADDR, &dMAInfo);

    if(dMACurrentPosition >= dMAPhysicalStart+dMASize) {
        // looped in DMA buffer
        dMACurrentPosition = dMAPhysicalStart;
    }

    // Actually write the data
    VDM_TRACE(0x603, (USHORT)WaveHdr->dwBufferLength, (ULONG)WaveHdr);

    mmResult = WriteProc(HWaveOut, WaveHdr, sizeof(WAVEHDR));

    return (mmResult == MMSYSERR_NOERROR);
}

/***************************************************************************/

/*
 *  GenerateHdrs
 *      Build an array of MM wavehdrs and corresponding buffers
*/

#define AUTO TRUE
#define SINGLE FALSE
BOOL
GenerateHdrs(
    BOOL bAuto
    )
{
    static ULONG committedMemorySize = 0;
    ULONG DesiredCommit;
    ULONG BurstBufferSize;
    ULONG BlocksPerGroup = 1;
    ULONG NumberOfGroups = 1;
    ULONG BurstSize; // minimum(AUTO_BLOCK_SIZE, SBBLockSize+1)
    ULONG lastBurst = 0; // the size of the last buffer
    BYTE *pDataInit;
    ULONG i;

    if(AUTO_BLOCK_SIZE > SBBlockSize+1) { // block size is no > than SBBlockSize+1
        BurstSize = SBBlockSize+1;
    } else {
        BurstSize = AUTO_BLOCK_SIZE;
    }

    DesiredBytesOutstanding = LookAheadFactor;

    BurstsPerBlock = (SBBlockSize+1)/BurstSize;
    BurstBufferSize = BurstsPerBlock*BurstSize;

    if((lastBurst = (SBBlockSize+1)%BurstSize) > 0 ) {
        BurstsPerBlock++;
        BurstBufferSize+=lastBurst;
    }

    BlocksPerGroup = (dMASize+1)/(SBBlockSize+1);
    if ((dMASize+1)%(SBBlockSize+1)) {
        dprintf2(("Error: SB block size not an integral factor of DMA size"));
        return FALSE;
    }

    NumberOfGroups = MAX_WAVE_BYTES / (dMASize+1);
    if (!NumberOfGroups) {
        NumberOfGroups = 1;
    }

    TotalNumberOfBursts = NumberOfGroups * BlocksPerGroup * BurstsPerBlock;

    //
    // Make sure the # of wavehdrs doesn't get out of hand
    //
    while((TotalNumberOfBursts > 256) && (NumberOfGroups > 1)) {

        NumberOfGroups /= 2;
        TotalNumberOfBursts = NumberOfGroups * BlocksPerGroup * BurstsPerBlock;

    }

    BurstBufferSize *= NumberOfGroups * BlocksPerGroup;

    dprintf2(("%d groups of %d blocks of %d bursts of size %X, remainder burst=%X", NumberOfGroups, BlocksPerGroup, BurstsPerBlock, BurstSize, lastBurst));

    DesiredCommit = ((BurstBufferSize+PageSize-1)/PageSize)*PageSize;
    dprintf2(("Total burst buffer size is %X bytes, rounding to %X", BurstBufferSize, DesiredCommit));

    if (DesiredCommit > committedMemorySize) {

        if (!VirtualAlloc(WaveData+committedMemorySize,
                          DesiredCommit-committedMemorySize,
                          MEM_COMMIT,
                          PAGE_READWRITE)) {
            dprintf1(("Unable to commit memory"));
            return(FALSE);
        }

        committedMemorySize = DesiredCommit;

    } else if (DesiredCommit < committedMemorySize) {

        if (VirtualFree(WaveData+DesiredCommit,
                          committedMemorySize-DesiredCommit,
                          MEM_DECOMMIT)) {
            committedMemorySize = DesiredCommit;
        } else {
            dprintf1(("Unable to decommit memory"));
        }

    }

    // malloc autoWaveHdrs
    WaveHdrs = (WAVEHDR *) VirtualAlloc(NULL,
                                        TotalNumberOfBursts*sizeof(WAVEHDR),
                                        MEM_RESERVE | MEM_COMMIT,
                                        PAGE_READWRITE);

    if(WaveHdrs == NULL) {
        dprintf1(("Unable to allocate memory"));
        return(FALSE);
    }

    //
    // Prepare autoWaveHdrs
    //
    pDataInit = WaveData;
    for (i=0; i<TotalNumberOfBursts; i++) {
        if ((!lastBurst) || ((i+1) % BurstsPerBlock)) {
            WaveHdrs[i].dwBufferLength = BurstSize;
        } else {
            WaveHdrs[i].dwBufferLength = lastBurst;
        }
        WaveHdrs[i].lpData = pDataInit;
        WaveHdrs[i].dwFlags = 0;
        PrepareHeaderProc(HWaveOut, &WaveHdrs[i], sizeof(WAVEHDR));
        pDataInit = (BYTE *) ((ULONG)pDataInit + WaveHdrs[i].dwBufferLength);
        BurstBufferSize += WaveHdrs[i].dwBufferLength;
    }

    //
    // Initialize iHdr for DspProcessBlock
    //
    iHdr = TotalNumberOfBursts-1;
    return TRUE;
}

/***************************************************************************/

/*
 *  ProcessBlock
 *      Process a single block of data as defined by the SB block transfer size
*/

VOID
DspProcessBlock(
    VOID
    )
{
    ULONG i;

    // Write the data, keeping DMA status current
    for (i=0; i<BurstsPerBlock; i++) {

        //
        // Make sure we aren't getting too far ahead
        //
        if (BytesOutstanding > (PhysicalBytesPlayed + DesiredBytesOutstanding)) {

            LastBytesPlayedValue = 0;
            while(1) {
                if (!GetWaveOutPosition(&PhysicalBytesPlayed)) {
                    break;  // ERROR
                }
                if (BytesOutstanding <= (PhysicalBytesPlayed + DesiredBytesOutstanding)) {
                    break;
                }
                if (LastBytesPlayedValue == PhysicalBytesPlayed) {
                    break;  // no sounds are playing
                }
                LastBytesPlayedValue = PhysicalBytesPlayed;
                Sleep(1);
            }
        }

        //
        // Queue next buffer
        //
        iHdr = (iHdr+1)%TotalNumberOfBursts;

        VDM_TRACE(0x601, (USHORT)iHdr, TotalNumberOfBursts);
        VDM_TRACE(0x602, (USHORT)iHdr, dMACurrentPosition);

        if (WriteBurst(&WaveHdrs[iHdr])) {
            BytesOutstanding += WaveHdrs[iHdr].dwBufferLength;
            VDM_TRACE(0x604, (USHORT)iHdr, BytesOutstanding);
        } else {
            VDM_TRACE(0x684, (USHORT)iHdr, BytesOutstanding);
        }

        // Check if we should pause
        if(bDspPause) {
            dprintf3(("Waiting for paused event"));
            WaitForSingleObject(PauseEvent, INFINITE);
            dprintf3(("Paused event received"));
            InterlockedExchange(&bDspPause, 0);
        }

        // Check if we should keep going
        if(bDspReset) {
            return;
        }
    }

    // Check if we should keep going
    if(bDspReset) {
        return;
    }

    // Generate interrupt
    if(dMAInfo.count==0xFFFF) { // end of DMA buffer
        SetDMAStatus(FALSE, TRUE);
    }

    VDM_TRACE(0x6a3,0,0);
    GenerateInterrupt();

    //
    // This sleep gives the app thread some time to catch up with the interrupt.
    // Granted this is an inexact method for doing this, but it empirically
    // seems to be good enough for most apps.
    //
    Sleep(1);
    if(dMAInfo.count==0xFFFF) { // end of DMA buffer
        SetDMAStatus(FALSE, FALSE);
    }
}

/***************************************************************************/

/*
*    Auto-init DMA thread.
*/

DWORD WINAPI
AutoThreadEntry(
    LPVOID context
    )
{
    ULONG i;

    dprintf2(("Auto thread starting"));
    VDM_TRACE(0x600, 0, 0);

    bDspActive = TRUE;
    SetEvent(ThreadStarted);

    //
    // Initialize DMA information
    //
    VDDQueryDMA((HANDLE)GlobalHInstance, SB_DMA_CHANNEL, &dMAInfo);
    dMAVirtualStart = dMAInfo.addr;
    dMASize = dMAInfo.count;
    if((dMAPhysicalStart=GetDMATransferAddress()) == -1L) {
        dprintf1(("Unable to get dma address"));
        return(FALSE);
    }

    dprintf2(("DMA Physical Start is %4X, DMA size is %4X", dMAPhysicalStart,
             dMASize));
    dMACurrentPosition = dMAPhysicalStart;
    SetDMAStatus(FALSE, FALSE);

    //
    // Calculate NumberOfBursts in the current run
    //
    if (!GenerateHdrs(AUTO)) {
        return FALSE;
    }

    //
    // Start looping on the buffer
    //

    while(!bDspReset) {
        DspProcessBlock();
    }

    WaitOnWaveOutIdle();
    //
    // Reset and close the device
    //
    CloseWaveDevice();

    // Clean up hdrs and events
    for(i=0; (ULONG)i<TotalNumberOfBursts; i++) {
        UnprepareHeaderProc(HWaveOut, &WaveHdrs[i], sizeof(WAVEHDR));
    }

    // Clean up memory
    VirtualFree(WaveHdrs, 0, MEM_RELEASE);

    bDspActive = FALSE;
    SetEvent(ThreadFinished);
    dprintf2(("Auto thread exiting"));
    return(0);
}


/***************************************************************************/

/*
*  Single cycle DMA thread.
*/

DWORD WINAPI
SingleThreadEntry(
    LPVOID context
    )
{
    ULONG LastSBBlockSize = 0;
    BOOL BlockSizeChanged; // set to TRUE if Size has changed
    BOOL WaveFormatChanged;
    BOOL HdrsInvalid = TRUE;
    ULONG i;

    dprintf2(("Single cycle thread starting"));
    bDspActive = TRUE;
    SetEvent(ThreadStarted);

    while (!bDspReset) {
        // Wait until app wants to transfer more data
        dprintf3(("Waiting for single wave semaphore"));
        WaitForSingleObject(SingleWaveSem, INFINITE);
        dprintf3(("Single wave semaphore received"));

        // Check if we should pause
        if(bDspPause) {
            dprintf3(("Waiting for paused event"));
            WaitForSingleObject(PauseEvent, INFINITE);
            dprintf3(("Paused event received"));
            InterlockedExchange(&bDspPause, 0);
        }

        // Check if we should keep going
        if(bDspReset) {
            break; // break out of loop
        }

        // Initialize for this run
        VDDQueryDMA((HANDLE)GlobalHInstance, SB_DMA_CHANNEL, &dMAInfo);
        dprintf4(("DMA Info : addr  %4X, count %4X, page %4X, status %2X, mode %2X, mask %2X",
                 dMAInfo.addr, dMAInfo.count, dMAInfo.page, dMAInfo.status,
                 dMAInfo.mode, dMAInfo.mask));
        dMAVirtualStart = dMAInfo.addr;
        dMASize = dMAInfo.count;

        if(dMAInfo.count == 0xFFFF || dMAInfo.count == 0) {
            continue; // next iteration of loop, app doesn't have data to transfer
        }

        if ((dMAPhysicalStart = GetDMATransferAddress()) == -1L) {
            dprintf1(("Unable to get transfer address"));
            continue; // next iteration of loop
        }

        dprintf3(("DMA Physical Start is %4X, DMA size is %4X",
                 dMAPhysicalStart, dMASize));
        dMACurrentPosition = dMAPhysicalStart;

        if(LastSBBlockSize != SBBlockSize) {
            LastSBBlockSize = SBBlockSize;
            BlockSizeChanged = TRUE;
        } else {
            BlockSizeChanged = FALSE;
        }

        WaveFormatChanged = SetWaveFormat();

        // If we're changing our device
        if ((WaveFormatChanged || BlockSizeChanged) && (HWaveOut != NULL)) {
            dprintf3(("Single-Cycle Parameters changed"));

            WaitOnWaveOutIdle();

            HdrsInvalid = TRUE;
            for(i=0; (ULONG)i<TotalNumberOfBursts; i++) {
                UnprepareHeaderProc(HWaveOut, &WaveHdrs[i], sizeof(WAVEHDR));
            }
            VirtualFree(WaveHdrs, 0, MEM_RELEASE);
            if (WaveFormatChanged) {
                CloseWaveDevice();
            }
        }

        if (HWaveOut == NULL) {
            OpenWaveDevice();
        }

        if (HdrsInvalid) {
            if (GenerateHdrs(SINGLE)) {
                HdrsInvalid = FALSE;
            } else {
                return FALSE;
            }
        }

        // show dma as requesting
        SetDMAStatus(TRUE, FALSE);

        DspProcessBlock();

    }

    WaitOnWaveOutIdle();

    //
    // Reset and close the device
    //
    CloseWaveDevice();

    // Clean up hdrs and events
    for(i=0; (ULONG)i<TotalNumberOfBursts; i++) {
        UnprepareHeaderProc(HWaveOut, &WaveHdrs[i], sizeof(WAVEHDR));
    }

    // Clean up memory
    VirtualFree(WaveHdrs, 0, MEM_RELEASE);

    bDspActive = FALSE;
    SetEvent(ThreadFinished);
    dprintf2(("Single cycle wave is exiting"));
    return(0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\vdd\vsndblst\fm.c ===
/***************************************************************************
*
*    fm.c
*
*    Copyright (c) 1991-1996 Microsoft Corporation.  All Rights Reserved.
*
*    This code provides VDD support for SB 2.0 sound output, specifically:
*        FM Chip OPL2 (a.k.a. Adlib)
*
***************************************************************************/


/*****************************************************************************
*
*    #includes
*
*****************************************************************************/

#include <windows.h>              // The VDD is a win32 DLL
#include <mmsystem.h>             // Multi-media APIs
#include <vddsvc.h>               // Definition of VDD calls
#include <vsb.h>
#include <fm.h>


/*****************************************************************************
*
*    Globals
*
*****************************************************************************/

HANDLE HFM = NULL; // current open FM device
BOOL FMActive = FALSE; // indicates whether we have an FM device
BYTE AdlibRegister = 0x00; // register currently selected
int Position = 0; // position in PortData array
SYNTH_DATA PortData[BATCH_SIZE]; // batched data to be written to OPL2 device
BOOL Timer1Started = FALSE; // if a timer interrupts then it's stopped
BOOL Timer2Started = FALSE; // if a timer interrupts then it's stopped
BYTE Status = 0x06; // or 0x00, see sb programming book page xi


/****************************************************************************
*
*    FM device routines
*
****************************************************************************/

VOID
ResetFM(
    VOID
    )
{
    AdlibRegister = 0x00; // register currently selected
    Position = 0;
    Timer1Started = FALSE;
    Timer2Started = FALSE;
    Status = 0x06;
}

VOID
FMStatusRead(
    BYTE *data
    )
{
#if 0 // This should work but doesn't (ReadFile fails)
        // Are we expecting a state change ?

        if (Timer1Started || Timer2Started) {
             // Read the status port from the driver - this is how the
             // driver interprets read.
             // Well, actually don't because the WSS driver doesn't work!

            if (!ReadFile(HFM, &Status, 1, &bytesRead, NULL)) {
#if DBG
                FormatMessageA( FORMAT_MESSAGE_ALLOCATE_BUFFER |
                  FORMAT_MESSAGE_FROM_SYSTEM,
                  NULL, GetLastError(), MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
                  (char *) &lpMsgBuf, 0, NULL);
                dprintf1(("FM read port failed: %d bytes of data read, error message: %s",
                            bytesRead, lpMsgBuf));
                LocalFree( lpMsgBuf ); // Free the buffer.
#endif DBG
                break;
            }
            else {
                 // Look for state change

                if (Status & 0x40) {
                     Timer1Started = FALSE;
                     dprintf2(("Timer 1 finished"));
            }

                if (Status & 0x20) {
                    Timer2Started = FALSE;
                    dprintf2(("Timer 2 finished"));
            }
            }
        }
#endif
        *data = Status;
}

VOID
FMRegisterSelect(
    BYTE data
    )
{
    AdlibRegister = data;
}

VOID
FMDataWrite(
    BYTE data
    )
{
    if(AdlibRegister==AD_NEW) {
        data &=0xFE; // don't enter opl3 mode
    }

    // put data in PortData array
    if(Position <= BATCH_SIZE-2) {
        PortData[Position].IoPort = ADLIB_REGISTER_SELECT_PORT;
        PortData[Position].PortData = AdlibRegister;
        PortData[Position + 1].IoPort = ADLIB_DATA_PORT;
        PortData[Position + 1].PortData = data;
        Position += 2;
    } else {
        dprintf1(("Attempting to write beyond end of PortData array"));
    }

    if (Position == BATCH_SIZE ||
        AdlibRegister>=0xB0 && AdlibRegister<=0xBD ||
        AdlibRegister == AD_MASK) {
        // PortData full or note-on/off command or changing status
        if (!FMPortWrite()) {
            dprintf1(("Failed to write to device!"));
        } else {
            // Work out what status change may have occurred
            if (AdlibRegister == AD_MASK) {
                // Look for RST and starting timers
                if (data & 0x80) {
                    Status = 0x00; // reset both timers
            }

                // We ignore starting of timers if their interrupt
                // flag is set because the timer status will have to
                // be set again to make the status for this timer change

                if ((data & 1) && !(Status & 0x40)) {
                    dprintf2(("Timer 1 started"));
#if 0
                    Timer1Started = TRUE;
#else
                    Status |= 0xC0; // simulate immediate expiry of timer1
#endif
                } else {
                    Timer1Started = FALSE;
                }

                if ((data & 2) && !(Status & 0x20)) {
                    dprintf2(("Timer 2 started"));
#if 0
                    Timer2Started = TRUE;
#else
                    Status |= 0xA0; // simulate immediate expiry of timer2
#endif
                    Timer2Started = TRUE;
                } else {
                    Timer2Started = FALSE;
                }
           }
        }
    }
}

/*
*    Opens opl2 device adlib.mid or adlib.mid0 as a file handle.
*    Returns TRUE on success.
*/

BOOL
OpenFMDevice(
    VOID
    )
{
    DWORD dwBytesReturned;
    LPVOID lpMsgBuf;

    // attempt to open device file adlib.mid or adlib.mid0
    HFM = CreateFile(L"\\\\.\\adlib.mid", GENERIC_READ | GENERIC_WRITE,
      FILE_SHARE_WRITE, NULL, OPEN_EXISTING, 0, NULL);
    if (HFM == INVALID_HANDLE_VALUE) {
        HFM = CreateFile(L"\\\\.\\adlib.mid0", GENERIC_READ | GENERIC_WRITE,
          FILE_SHARE_WRITE, NULL, OPEN_EXISTING, 0, NULL);
    }

    if (HFM == INVALID_HANDLE_VALUE) {
#if DBG
        FormatMessageA( FORMAT_MESSAGE_ALLOCATE_BUFFER |
          FORMAT_MESSAGE_FROM_SYSTEM, NULL, GetLastError(),
          MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), (char *) &lpMsgBuf, 0, NULL);
        dprintf1(("Create FM out failed, error message: %s", lpMsgBuf));
        LocalFree( lpMsgBuf ); // Free the buffer.
#endif // DBG
        return FALSE;
    }
    FMActive = TRUE;
    return TRUE;
}

/***************************************************************************/

/*
*    Closes our FM device.
*/

VOID
CloseFMDevice(
    VOID
    )
{
    dprintf2(("Closing FM device"));

    if (HFM) {
        CloseHandle(HFM);
        HFM = NULL;
        FMActive = FALSE;
    }
}

/***************************************************************************/

/*
*    Sends FM data to the card.
*    Returns TRUE on success.
*/

BOOL
FMPortWrite(
    VOID
    )
{
    DWORD bytesWritten = 0;
    LPVOID lpMsgBuf;

    if(FMActive) {
        dprintf4(("Writing %d bytes of data to port",
          Position * sizeof(PortData[0])));
        if(!WriteFile(HFM, &PortData, Position * sizeof(PortData[0]),
          &bytesWritten, NULL)) {
#if DBG
            FormatMessageA( FORMAT_MESSAGE_ALLOCATE_BUFFER |
              FORMAT_MESSAGE_FROM_SYSTEM, NULL, GetLastError(),
              MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), (char *) &lpMsgBuf,
                0, NULL);

            dprintf1(("FM write failed: %d bytes of data written, error message: %s",
              bytesWritten, lpMsgBuf));
            LocalFree( lpMsgBuf ); // Free the buffer.
#endif //DBG
             return FALSE;
        }
    }
    Position = 0;
    return TRUE;
}

/***************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\vdd\vsndblst\mixer.c ===
/***************************************************************************
*
*    mixer.c
*
*    Copyright (c) 1991-1996 Microsoft Corporation.  All Rights Reserved.
*
*    This code provides VDD support for SB 2.0 sound output, specifically:
*        Mixer Chip CT1335 (not strictly part of SB 2.0, but apps seem to like it)
*
***************************************************************************/


/*****************************************************************************
*
*    #includes
*
*****************************************************************************/

#include <windows.h>              // The VDD is a win32 DLL
#include <mmsystem.h>             // Multi-media APIs
#include <vddsvc.h>               // Definition of VDD calls
#include <vsb.h>
#include <mixer.h>

extern SETVOLUMEPROC SetVolumeProc;
extern HWAVEOUT HWaveOut;               // the current open wave output device

/*
 *    Mixer globals
 */

struct {
    BYTE MasterVolume; // current master volume
    BYTE FMVolume; // current volume of fm device
    BYTE CDVolume; // current volume of cd
    BYTE VoiceVolume; // current volume of wave device
}
MixerSettings;

/*
*    Mixer State Machine
*/

enum {
    MixerReset = 1, // initial state and after reset
    MixerMasterVolume,
    MixerFMVolume,
    MixerCDVolume,
    MixerVoiceVolume
  }
  MixerState = MixerReset; // state of current command/data being set


/****************************************************************************
*
*    Mixer device routines
*
****************************************************************************/

VOID
MixerDataRead(
    BYTE * data
    )
{
    switch(MixerState) {
    case MixerReset:
        ResetMixer();
        break;

    case MixerMasterVolume:
        *data = MixerSettings.MasterVolume;
        break;

    case MixerFMVolume:
        *data = MixerSettings.FMVolume;
        break;

    case MixerCDVolume:
        *data = MixerSettings.CDVolume;
        break;

    case MixerVoiceVolume:
        *data = MixerSettings.VoiceVolume;
        break;
    }
}

VOID
MixerAddrWrite(
    BYTE data
    )
{
    switch(data) {
    case MIXER_RESET:
        MixerState = MixerReset;
        break;

    case MIXER_MASTER_VOLUME:
        MixerState = MixerMasterVolume;
        break;

    case MIXER_FM_VOLUME:
        MixerState = MixerFMVolume;
        break;

    case MIXER_CD_VOLUME:
        MixerState = MixerCDVolume;
        break;

    case MIXER_VOICE_VOLUME:
        MixerState = MixerVoiceVolume;
        break;
    }
}

VOID
MixerDataWrite(
    BYTE data
    )
{
    // only voice and master volume implemented,
    // havent't found any apps using others
    switch(MixerState) {
    case MixerReset:
        ResetMixer();
        break;

    case MixerMasterVolume:
        MixerSettings.MasterVolume = data;
        MixerSetMasterVolume(data);
        break;

    case MixerFMVolume:
        MixerSettings.FMVolume = data;
        break;

    case MixerCDVolume:
        MixerSettings.CDVolume = data;
        break;

    case MixerVoiceVolume:
        MixerSettings.VoiceVolume = data;
        MixerSetVoiceVolume(data);
        break;
    }
}

/*
*    Reset the mixer to initial values.
*/

VOID
ResetMixer(
    VOID
    )
{
    MixerSettings.MasterVolume = 0x08; // set to level 4
    MixerSetMasterVolume(0x08);
    MixerSettings.FMVolume = 0x08; // set to level 4
    MixerSettings.CDVolume = 0x00; // set to level 0
    MixerSettings.VoiceVolume = 0x04; // set to level 2
    MixerSetVoiceVolume(0x04);

    MixerState = MixerReset;
}

/***************************************************************************/

/*
*    Set master volume.
*/

VOID
MixerSetMasterVolume(
    BYTE level
    )
{
    ULONG volume = 0;

    level = level >> 1;
    level = level & 0x07;

    volume = level*0x2492; // 0xFFFF/7 = 0x2492
    volume = volume + (volume<<16);
}

/***************************************************************************/

/*
*    Set volume of wave out device.
*/

VOID
MixerSetVoiceVolume(
    BYTE level
    )
{
    ULONG volume = 0;

    level = level >> 1;
    level = level & 0x03;

    volume = level*0x5555; // 0xFFFF/3 = 0x5555
    volume = volume + (volume<<16);
    SetVolumeProc(HWaveOut, volume);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\vdd\vsndblst\dsp.h ===
/***************************************************************************
*
*    dsp.h
*
*    Copyright (c) 1991-1996 Microsoft Corporation.  All Rights Reserved.
*
*    This code provides VDD support for SB 2.0 sound output, specifically:
*        DSP 2.01+ (excluding SB-MIDI port)
*
***************************************************************************/


/*****************************************************************************
*
*    #defines
*
*****************************************************************************/

/*
*    DSP Ports
*/

#define RESET_PORT          0x06        // used to reset SoundBlaster
#define READ_STATUS         0x0E        // 0xFF-data to read, 0x7F-no data to read
#define READ_DATA           0x0A        // App reads data from this port
#define WRITE_STATUS        0x0C        // 0x7f-port ready, 0xFF-port not ready
#define WRITE_PORT          0x0C        // Data or command

/*
*    Only implemented commands are defined
*/

/*
*    DSP commands - miscellaneous
*/

#define DSP_GET_VERSION     0xE1    // dsp version command
#define DSP_CARD_IDENTIFY   0xE0    // byte inverter
#define DSP_TABLE_MUNGE     0xE2    // jump table munging
#define DSP_LOAD_RES_REG    0xE4    // load byte into reserved register
#define DSP_READ_RES_REG    0xE8    // read byte from reserved register
#define DSP_GENERATE_INT    0xF2    // generate an interrupt

/*
*    DSP commands - speaker
*/

#define DSP_SPEAKER_ON      0xD1    // speaker on command
#define DSP_SPEAKER_OFF     0xD3    // speaker off command

/*
*    DSP commands - DMA mode
*/

#define DSP_SET_SAMPLE_RATE 0x40    // set the sample rate (one byte format)
#define DSP_SET_BLOCK_SIZE  0x48    // set dma block size
#define DSP_PAUSE_DMA       0xD0    // pause dma
#define DSP_CONTINUE_DMA    0xD4    // continue dma
#define DSP_STOP_AUTO       0xDA    // Stop auto init dma

#define DSP_WRITE           0x14    // Start single cycle output (8-bit PCM mono)
#define DSP_WRITE_HS        0x91    // Start single cycle high-speed output (8-bit PCM mono)
#define DSP_WRITE_AUTO      0x1C    // Start auto init output (8-bit PCM mono)
#define DSP_WRITE_HS_AUTO   0x90    // Start auto init high=speed output (8-bit PCM mono)
#define DSP_READ            0x24    // Start single cycle input (not implemented)

/*
*    Performance parameters for single and auto-init DMA fine tuning
*/
#define AUTO_BLOCK_SIZE     0x100   // size of each buffer in auto
#define DEFAULT_LOOKAHEAD   0x600   // target # of bytes to queue to kernel driver
#define MAX_WAVE_BYTES      0x2000  // maximum # of bytes to queue to kernel driver
#define SINGLE_PIECES       2       // number of pieces in each single write
#define SINGLE_SLEEP_ADJ    15      // number of overhead milliseconds in single


/*****************************************************************************
*
*    Function Prototypes
*
*****************************************************************************/

/*
*    General function prototypes
*/

BOOL DspProcessAttach(VOID);
VOID DspProcessDetach(VOID);

VOID DspReadData(BYTE * data);
VOID DspReadStatus(BYTE * data);
VOID DspResetWrite(BYTE data);
VOID DspWrite(BYTE data);

void WriteCommandByte(BYTE command);
VOID ResetDSP(VOID);
void TableMunger(BYTE data);
DWORD GetSamplingRate(void);
void GenerateInterrupt(void);
void SetSpeaker(BOOL);

/*
*    Wave function prototypes
*/

UINT FindWaveDevice(void);
BOOL OpenWaveDevice(VOID);
void ResetWaveDevice(void);
void CloseWaveDevice(void);
BOOL TestWaveFormat(DWORD sampleRate);
BOOL SetWaveFormat(void);

void PauseDMA(void);
void ContinueDMA(void);
ULONG GetDMATransferAddress(void);
void SetDMAStatus(BOOL requesting, BOOL tc);

BOOL StartAutoWave(void);
void StopAutoWave(BOOL wait);
BOOL StartSingleWave(void);
void StopSingleWave(BOOL wait);
DWORD WINAPI AutoThreadEntry(LPVOID context);
DWORD WINAPI SingleThreadEntry(LPVOID context);
DWORD WINAPI SingleSynchThreadEntry(LPVOID context);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\vdd\vsndblst\vsb.c ===
/***************************************************************************
*
*    vsb.c
*
*    Copyright (c) 1991-1996 Microsoft Corporation.  All Rights Reserved.
*
*    This code provides VDD support for SB 2.0 sound output, specifically:
*        DSP 2.01+ (excluding SB-MIDI port)
*        Mixer Chip CT1335 (not strictly part of SB 2.0, but apps seem to like it)
*        FM Chip OPL2 (a.k.a. Adlib)
*
***************************************************************************/


/*****************************************************************************
*
*    #includes
*
*****************************************************************************/

#include <windows.h>              // The VDD is a win32 DLL
#include <mmsystem.h>             // Multi-media APIs
#include <vddsvc.h>               // Definition of VDD calls
#include <vsb.h>
#include <dsp.h>
#include <mixer.h>
#include <fm.h>


/*****************************************************************************
*
*    Globals
*
*****************************************************************************/

//
// Definitions for MM api entry points. The functions will be linked
// dynamically to avoid bringing winmm.dll in before wow32.
//
SETVOLUMEPROC SetVolumeProc;
GETNUMDEVSPROC GetNumDevsProc;
GETDEVCAPSPROC GetDevCapsProc;
OPENPROC OpenProc;
RESETPROC ResetProc;
CLOSEPROC CloseProc;
GETPOSITIONPROC GetPositionProc;
WRITEPROC WriteProc;
PREPAREHEADERPROC PrepareHeaderProc;
UNPREPAREHEADERPROC UnprepareHeaderProc;

BOOL bWaveOutActive = FALSE;
BOOL bWinmmLoaded = FALSE;
BOOL LoadWinmm(VOID);
BOOL InitDevices(VOID);
HINSTANCE hWinmm;

/*
 *    General globals
 */

HINSTANCE GlobalHInstance; // handle passed to dll entry point
WORD BasePort; // Where the card is mapped

/*****************************************************************************
*
*    General Functions
*
*****************************************************************************/


/*
*    DLL entry point routine.
*    Returns TRUE on success.
*/

BOOL WINAPI
DllEntryPoint(
    HINSTANCE hInstance,
    DWORD reason,
    LPVOID reserved
    )
{

    switch (reason) {
    case DLL_PROCESS_ATTACH:

        DisableThreadLibraryCalls(hInstance);
        // save instance
        GlobalHInstance = hInstance;

        // Hook i/o ports
        if (!InstallIoHook(hInstance)) {
            dprintf1(("VDD failed to load"));
#if 0
            MessageBoxA(NULL, "Unable to load wave out device",
              "Sound Blaster VDD", MB_OK | MB_ICONEXCLAMATION);
#endif
            return FALSE;
        }

        if (!DspProcessAttach()) {
            DeInstallIoHook(hInstance);
            return FALSE;
        }

#if 0
        {
        char buf[256];
        wsprintfA(buf, "Sound blaster VDD loaded at port %3X, IRQ %d, DMA Channel %d, %s OPL2/Adlib support.",
                  BasePort, SB_INTERRUPT, SB_DMA_CHANNEL,
                  (FMActive ? "with" : "without"));
        MessageBoxA(NULL, buf, "Sound Blaster VDD", MB_OK | MB_ICONINFORMATION);
        }
#endif // DBG
        return TRUE;

    case DLL_PROCESS_DETACH:

        DspProcessDetach();
        DeInstallIoHook(hInstance);

        if (bWaveOutActive) {
            CloseFMDevice();
            SetSpeaker(TRUE);
        }

        if (bWinmmLoaded) {
            FreeLibrary(hWinmm);
        }

        return TRUE;

    default:
        return TRUE;
    }
}

/***************************************************************************/
//
// LoadWinmm()
//
// This function dynamically loads the "waveOutxxx" entry points. This
// is done because there is code in WINMM which does certain things in a
// WOW vdm. If we do static links, then winmm may get loaded way before
// WOW32, in which case it can't do the things it should.
//
BOOL
LoadWinmm(
    VOID
    )
{

    if (!(hWinmm = LoadLibrary(L"WINMM.DLL"))) {
        return FALSE;
    }

    //BUGBUG: Should check for error return from getprocaddress
    //
    SetVolumeProc = (SETVOLUMEPROC) GetProcAddress(hWinmm, "waveOutSetVolume");
    GetNumDevsProc = (GETNUMDEVSPROC) GetProcAddress(hWinmm, "waveOutGetNumDevs");
    GetDevCapsProc = (GETDEVCAPSPROC) GetProcAddress(hWinmm, "waveOutGetDevCapsW");
    OpenProc = (OPENPROC) GetProcAddress(hWinmm, "waveOutOpen");
    ResetProc = (RESETPROC) GetProcAddress(hWinmm, "waveOutReset");
    CloseProc = (CLOSEPROC) GetProcAddress(hWinmm, "waveOutClose");
    GetPositionProc = (GETPOSITIONPROC) GetProcAddress(hWinmm, "waveOutGetPosition");
    WriteProc = (WRITEPROC) GetProcAddress(hWinmm, "waveOutWrite");
    PrepareHeaderProc = (PREPAREHEADERPROC) GetProcAddress(hWinmm, "waveOutPrepareHeader");
    UnprepareHeaderProc = (UNPREPAREHEADERPROC) GetProcAddress(hWinmm, "waveOutUnprepareHeader");
    return TRUE;
}

/***************************************************************************/
//
// InitDevices()
//
// This function tries to get handles to the waveout and FM devices.
//
BOOL
InitDevices(
    VOID
    )
{
    static BOOL bTriedLoadAndFailed = FALSE;

    if (bWaveOutActive) {
        return TRUE;
    }

    if (bTriedLoadAndFailed) {
        return FALSE;
    }

    if (!bWinmmLoaded) {
        if (!LoadWinmm()) {
            bTriedLoadAndFailed = TRUE;
            return FALSE;
        }
        bWinmmLoaded = TRUE;
    }

    if (!FindWaveDevice()) {
        return FALSE;
    }
    bWaveOutActive = TRUE;
    OpenFMDevice();
    return TRUE;
}

/***************************************************************************/

/*
*    Hooks i/o ports with i/o handlers.
*    Sets BasePort and returns TRUE if successful.
*/

BOOL
InstallIoHook(
    HINSTANCE hInstance
    )
{
    int i;
    WORD ports[] = { 0x220, 0x210, 0x230, 0x240, 0x250, 0x260, 0x270 };
    VDD_IO_HANDLERS handlers = {
        VsbByteIn,
        NULL,
        NULL,
        NULL,
        VsbByteOut,
        NULL,
        NULL,
        NULL};

    // try each base port until success is achieved
    for (i = 0; i < sizeof(ports) / sizeof(ports[0]); i++ ) {
        VDD_IO_PORTRANGE PortRange[5];

        PortRange[0].First = ports[i] + 0x04;
        PortRange[0].Last = ports[i] + 0x06;

        PortRange[1].First = ports[i] + 0x08;
        PortRange[1].Last = ports[i] + 0x0A;

        PortRange[2].First = ports[i] + 0x0C;
        PortRange[2].Last = ports[i] + 0x0C;

        PortRange[3].First = ports[i] + 0x0E;
        PortRange[3].Last = ports[i] + 0x0E;

        PortRange[4].First = 0x388;
        PortRange[4].Last = 0x389;

        if (VDDInstallIOHook((HANDLE)hInstance, 5, PortRange, &handlers)) {
            dprintf2(("Device installed at %X", ports[i]));
            BasePort = ports[i];
            return TRUE;
        }
    }

    return FALSE;
}

/***************************************************************************/

/*
*    Remove our i/o hook.
*/

VOID
DeInstallIoHook(
    HINSTANCE hInstance
    )
{
    VDD_IO_PORTRANGE PortRange[5];

    PortRange[0].First = BasePort + 0x04;
    PortRange[0].Last = BasePort + 0x06;

    PortRange[1].First = BasePort + 0x08;
    PortRange[1].Last = BasePort + 0x0A;

    PortRange[2].First = BasePort + 0x0C;
    PortRange[2].Last = BasePort + 0x0C;

    PortRange[3].First = BasePort + 0x0E;
    PortRange[3].Last = BasePort + 0x0E;

    PortRange[4].First = 0x388;
    PortRange[4].Last = 0x389;

    VDDDeInstallIOHook((HANDLE)hInstance, 5, PortRange);
}


/***************************************************************************/

/*
*    Gets called when the application reads from port.
*    Returns results to application in data.
*/
VOID
VsbByteIn(
    WORD port,
    BYTE * data
    )
{
    // If we fail simulate nothing at the port
    *data = 0xFF;

    //
    // make sure we are linked in with winmm
    //
    if (!bWaveOutActive) {
        if (!InitDevices()) {
            // no wave device, forget it
            return;
        }
    }

    switch (port - BasePort) {
    case READ_STATUS:
        DspReadStatus(data);
        break;

    case READ_DATA:
        DspReadData(data);
        break;

    case WRITE_STATUS:
        // Can always write
        *data = 0x7F;
        break;

    case MIXER_ADDRESS:
        // apps sometimes read from this port??
        break;

    case MIXER_DATA:
        MixerDataRead(data);
        break;

    case 0x8:
        // remap to ADLIB_STATUS_PORT
        port = ADLIB_STATUS_PORT;
        break;
    }

    switch(port) {
    case ADLIB_STATUS_PORT:
        FMStatusRead(data);
        break;
    }

    dprintf4(("Read  %4X, <= %2X", port, *data));
}

/***************************************************************************/

/*
*    Gets called when an application writes data to port.
*/

VOID
VsbByteOut(
    WORD port,
    BYTE data
    )
{
    //
    // make sure we are linked in with winmm
    //
    if (!bWaveOutActive) {
        if (!InitDevices()) {
            // no wave device, forget it
            return;
        }
    }

    dprintf4(("Write %4X, => %2X", port, data));

    switch (port - BasePort) {
    case RESET_PORT:
        DspResetWrite(data);
        break;

    case WRITE_PORT:
        DspWrite(data);
        break;

    case MIXER_ADDRESS:
        MixerAddrWrite(data);
        break;

    case MIXER_DATA:
        MixerDataWrite(data);
        break;

    case 0x8:
        // remap to ADLIB_REGISTER_SELECT_PORT
        port = ADLIB_REGISTER_SELECT_PORT;
        break;

    case 0x9:
        // remap to ADLIB_DATA_PORT
        port = ADLIB_DATA_PORT;
        break;
    }

    switch(port) {
    case ADLIB_REGISTER_SELECT_PORT:
        FMRegisterSelect(data);
        break;

    case ADLIB_DATA_PORT:
        FMDataWrite(data);
        break;
    }
}

/***************************************************************************/

/*
*    Reset all devices
*/

VOID
ResetAll(
    VOID
    )
{
    dprintf2(("Resetting"));
    ResetDSP();
    ResetFM();
    ResetMixer();
}

/***************************************************************************/

/*
*    Debug
*/

#if DBG
int VddDebugLevel = 3;
int VddDebugCount = 0;

#define DEBUG_START 0

/*
 *    Generate debug output in printf type format.
 */

void VddDbgOut(LPSTR lpszFormat, ...)
{
    char buf[256];
    char buf2[300] = "VSBD: ";
    va_list va;

    if (++VddDebugCount < DEBUG_START) {
        return;
    }

    va_start(va, lpszFormat);
    wvsprintfA(buf, lpszFormat, va);
    va_end(va);

    strcat(buf2, buf);
    strcat(buf2, "\r\n");
    OutputDebugStringA(buf2);

}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\vdd\vsndblst\mixer.h ===
/***************************************************************************
*
*    mixer.h
*
*    Copyright (c) 1991-1996 Microsoft Corporation.  All Rights Reserved.
*
*    This code provides VDD support for SB 2.0 sound output, specifically:
*        Mixer Chip CT1335 (not strictly part of SB 2.0, but apps seem to like it)
*
***************************************************************************/


/*****************************************************************************
*
*    #defines
*
*****************************************************************************/

/*
*    Mixer Ports
*/

#define MIXER_ADDRESS       0x04        // Mixer address port
#define MIXER_DATA          0x05        // Mixer data port

/*
*    Mixer Commands
*/

#define MIXER_RESET         0x00    // reset mixer to initial state
#define MIXER_MASTER_VOLUME 0x02    // set master volume
#define MIXER_FM_VOLUME     0x06    // set opl2 volume
#define MIXER_CD_VOLUME     0x08    // set cd volume
#define MIXER_VOICE_VOLUME  0x0A    // set wave volume

/*****************************************************************************
*
*    Function Prototypes
*
*****************************************************************************/

void ResetMixer(void);
void MixerSetMasterVolume(BYTE level);
void MixerSetVoiceVolume(BYTE level);

VOID
MixerDataRead(
    BYTE *pData
    );

VOID
MixerDataWrite(
    BYTE data
    );

VOID
MixerAddrWrite(
    BYTE data
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\vdd\vsndblst\fm.h ===
/***************************************************************************
*
*    fm.h
*
*    Copyright (c) 1991-1996 Microsoft Corporation.  All Rights Reserved.
*
*    This code provides VDD support for SB 2.0 sound output, specifically:
*        FM Chip OPL2 (a.k.a. Adlib)
*
***************************************************************************/


/*****************************************************************************
*
*    #defines
*
*****************************************************************************/

/*
*    OPL2/Adlib Ports
*/

#define ADLIB_REGISTER_SELECT_PORT 0x388 // select the register to write data
#define ADLIB_STATUS_PORT          0x388 // read to determine opl2 status
#define ADLIB_DATA_PORT            0x389 // write data port

/*
*    FM information
*/

#define AD_MASK             0x04    // adlib register used to control opl2
#define AD_NEW              0x105   // used to determine if app entering opl3 mode
#define BATCH_SIZE          40      // how much data is batched to opl2

typedef struct {                    // structure written to fm device
    unsigned short IoPort;
    unsigned short PortData;
} SYNTH_DATA, *PSYNTH_DATA;

/*****************************************************************************
*
*    Function Prototypes
*
*****************************************************************************/

void ResetFM(void);
BOOL OpenFMDevice(void);
void CloseFMDevice(void);
BOOL FMPortWrite(void);

VOID
FMDataWrite(
    BYTE data
    );

VOID
FMRegisterSelect(
    BYTE data
    );

VOID
FMStatusRead(
    BYTE *data
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\vdmdbg\brkpt.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    brkpt.c

Abstract:

    This module contains the debugging support needed to debug
    16-bit VDM applications

Author:

    Neil Sandlin (neilsa) 1-Nov-1997 wrote it

Revision History:


--*/

#include <precomp.h>
#pragma hdrstop

#define X86_BP_OPCODE 0xcc

//----------------------------------------------------------------------------
// ProcessBPNotification()
//
//
//----------------------------------------------------------------------------
VOID
ProcessBPNotification(
    LPDEBUG_EVENT lpDebugEvent
    )
{
    BOOL            b;
    HANDLE hProcess;
    HANDLE hThread;
    VDMCONTEXT      vcContext;
    NTSTATUS Status;
    OBJECT_ATTRIBUTES Obja;
    CLIENT_ID ClientId;
    VDM_BREAKPOINT VdmBreakPoints[MAX_VDM_BREAKPOINTS] = {0};
    ULONG           vdmEip;
    DWORD lpNumberOfBytes;
    int             i;
    UCHAR  opcode;
    PVOID lpInst;

    hProcess = OpenProcess( PROCESS_VM_READ | PROCESS_VM_WRITE | PROCESS_VM_OPERATION,
                            FALSE, lpDebugEvent->dwProcessId );

    if ( hProcess == HANDLE_NULL ) {
        return;
    }
    
    ClientId.UniqueThread = (HANDLE)lpDebugEvent->dwThreadId;
    ClientId.UniqueProcess = (HANDLE)NULL;

    InitializeObjectAttributes(&Obja, NULL, 0, NULL, NULL);
    Status = NtOpenThread(&hThread,
                          (ACCESS_MASK)THREAD_GET_CONTEXT,
                          &Obja,
                          &ClientId);
    if (!NT_SUCCESS(Status)) {
        CloseHandle( hProcess );
        return;
    }
    
    vcContext.ContextFlags = VDMCONTEXT_CONTROL;
    
    if (!VDMGetContext(hProcess, hThread, &vcContext)) {
        CloseHandle( hProcess );
        CloseHandle( hThread);
        return;
    } 
    
    CloseHandle( hThread );
    
    b = ReadProcessMemory(hProcess, lpVdmBreakPoints, &VdmBreakPoints,
                          sizeof(VdmBreakPoints), &lpNumberOfBytes);

    if ( !b || lpNumberOfBytes != sizeof(VdmBreakPoints) ) {
        CloseHandle (hProcess);
        return;
    }
    
//    if ((getMSW() & MSW_PE) && SEGMENT_IS_BIG(vcContext.SegCs)) {
//        vdmEip = vcContext.Eip;
//    } else {
        vdmEip = (ULONG)LOWORD(vcContext.Eip);
//    }


    for (i=0; i<MAX_VDM_BREAKPOINTS; i++) {

        if ((VdmBreakPoints[i].Flags & VDMBP_ENABLED) &&
            (VdmBreakPoints[i].Flags & VDMBP_SET) &&
            (vcContext.SegCs == VdmBreakPoints[i].Seg) &&
            (vdmEip == VdmBreakPoints[i].Offset+1)  &&
            (!(vcContext.EFlags & V86FLAGS_V86) == !(VdmBreakPoints[i].Flags & VDMBP_V86)) ){

            // We must have hit this breakpoint. Back up the eip and
            // restore the original data
//            setEIP(getEIP()-1);
//            vcContext.Eip--;

            lpInst = (PVOID)InternalGetPointer(hProcess,
                                VdmBreakPoints[i].Seg, 
                                VdmBreakPoints[i].Offset,
                               ((VdmBreakPoints[i].Flags & VDMBP_V86)==0));
                               
            b = ReadProcessMemory(hProcess, lpInst, &opcode, 1,
                                  &lpNumberOfBytes);
                               

            if (b && (opcode == X86_BP_OPCODE)) {
                WriteProcessMemory(hProcess, lpInst, &VdmBreakPoints[i].Opcode, 1,
                                  &lpNumberOfBytes);
                
                VdmBreakPoints[i].Flags |= VDMBP_PENDING;
                VdmBreakPoints[i].Flags &= ~VDMBP_FLUSH;
                if (i == VDM_TEMPBP) {
                    // non-persistent breakpoint
                    VdmBreakPoints[i].Flags &= ~VDMBP_SET;
                }
                WriteProcessMemory(hProcess, lpVdmBreakPoints, &VdmBreakPoints,
                          sizeof(VdmBreakPoints), &lpNumberOfBytes);
            }

            break;

        }
    }

    CloseHandle( hProcess );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\vdd\vsndblst\vsb.h ===
/***************************************************************************
*
*    vsb.h
*
*    Copyright (c) 1991-1996 Microsoft Corporation.  All Rights Reserved.
*
*    This code provides VDD support for SB 2.0 sound output, specifically:
*        DSP 2.01+ (excluding SB-MIDI port)
*        Mixer Chip CT1335 (not strictly part of SB 2.0, but apps seem to like it)
*        FM Chip OPL2 (a.k.a. Adlib)
*
***************************************************************************/


/*****************************************************************************
*
*    #defines
*
*****************************************************************************/

#define VSBD_PATH TEXT("System\\CurrentControlSet\\Control\\VirtualDeviceDrivers\\SoundBlaster")
#define LOOKAHEAD_VALUE TEXT("LookAhead")

/*
*    Hardware and version information
*    In DOS terms: SET BLASTER=A220 I5 D1 T3
*/

#define SB_VERSION          0x201       // SB 2.0 (DSP 2.01+)
#define SB_INTERRUPT        0x05        // Interrupt 5
#define SB_DMA_CHANNEL      0x01        // DMA Channel 1
#define NO_DEVICE_FOUND     0xFFFF      // returned if no device found

/*****************************************************************************
*
*    Function Prototypes
*
*****************************************************************************/

/*
*    General function prototypes
*/

void VddDbgOut(LPSTR lpszFormat, ...);
BOOL WINAPI DllEntryPoint(HINSTANCE hInstance, DWORD reason, LPVOID reserved);
BOOL InstallIoHook(HINSTANCE hInstance);
void DeInstallIoHook(HINSTANCE hInstance);
VOID VsbByteIn(WORD port, BYTE * data);
VOID VsbByteOut(WORD port, BYTE data);
VOID ResetAll(VOID);

/*****************************************************************************
*
*    Globals
*
*****************************************************************************/

//
// Definitions for MM api entry points. The functions will be linked
// dynamically to avoid bringing winmm.dll in before wow32.
//

typedef MMRESULT (WINAPI* SETVOLUMEPROC)(HWAVEOUT, DWORD);
typedef UINT (WINAPI* GETNUMDEVSPROC)(VOID);
typedef MMRESULT (WINAPI* GETDEVCAPSPROC)(UINT, LPWAVEOUTCAPSW, UINT);
typedef MMRESULT (WINAPI* OPENPROC)(LPHWAVEOUT, UINT, LPCWAVEFORMATEX, DWORD, DWORD, DWORD);
typedef MMRESULT (WINAPI* RESETPROC)(HWAVEOUT);
typedef MMRESULT (WINAPI* CLOSEPROC)(HWAVEOUT);
typedef MMRESULT (WINAPI* GETPOSITIONPROC)(HWAVEOUT, LPMMTIME, UINT);
typedef MMRESULT (WINAPI* WRITEPROC)(HWAVEOUT, LPWAVEHDR, UINT);
typedef MMRESULT (WINAPI* PREPAREHEADERPROC)(HWAVEOUT, LPWAVEHDR, UINT);
typedef MMRESULT (WINAPI* UNPREPAREHEADERPROC)(HWAVEOUT, LPWAVEHDR, UINT);

/*****************************************************************************
*
*    Debugging
*    Levels:
*    1 - errors only
*    2 - significant events
*    3 - regular events
*    4 - heaps o' information
*
*****************************************************************************/

#if DBG

    extern int VddDebugLevel;
    #define dprintf( _x_ )                          VddDbgOut _x_
    #define dprintf1( _x_ ) if (VddDebugLevel >= 1) VddDbgOut _x_
    #define dprintf2( _x_ ) if (VddDebugLevel >= 2) VddDbgOut _x_
    #define dprintf3( _x_ ) if (VddDebugLevel >= 3) VddDbgOut _x_
    #define dprintf4( _x_ ) if (VddDebugLevel >= 4) VddDbgOut _x_

#else

    #define dprintf(x)
    #define dprintf1(x)
    #define dprintf2(x)
    #define dprintf3(x)
    #define dprintf4(x)

#endif // DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\vdmdbg\precomp.h ===
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <vdmdbg.h>
#include <dbginfo.h>
#include <stdio.h>
#include <string.h>
#include <common.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\vdmdbg\common.h ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    common.h

Abstract:

    Main header file for vdmdbg

Author:

    Bob Day      (bobday) 16-Sep-1992 Wrote it

Revision History:

    Neil Sandlin (neilsa) 1-Mar-1997 Enhanced it
--*/


#if DBG
#define DEBUG   1
#endif

#define TOOL_HMASTER    0       // Offset to hGlobalHeap (in kdata.asm)
#define TOOL_HMODFIRST  4       // Offset to hExeHead (in kdata.asm)
#define TOOL_HEADTDB    14      // Offset to headTDB (in kdata.asm)
#define TOOL_HMASTLEN   22      // Offset to SelTableLen (in kdata.asm)
#define TOOL_HMASTSTART 24      // Offset to SelTableStart (in kdata.asm)

#define HI_FIRST        6       // Offset to hi_first in heap header
#define HI_SIZE         24      // Size of HeapInfo structure

#define GI_LRUCHAIN     2       // Offset to gi_lruchain in heap header
#define GI_LRUCOUNT     4       // Offset to gi_lrucount in heap header
#define GI_FREECOUNT    16      // Offset to gi_free_count in heap header

#define GA_COUNT        0       // Offset to ga_count in arena header
#define GA_OWNER386     18      // Offset to "pga_owner member in globalarena

#define GA_OWNER        1       // Offset to "owner" member within Arena

#define GA_FLAGS        5       // Offset to ga_flags in arena header
#define GA_NEXT         9       // Offset to ga_next in arena header
#define GA_HANDLE       10      // Offset to ga_handle in arena header
#define GA_LRUNEXT      14      // Offset to ga_lrunext in arena header
#define GA_FREENEXT     GA_LRUNEXT  // Offset to ga_freenext in arena header

#define GA_SIZE         16      // Size of the GlobalArena structure

#define LI_SIG          HI_SIZE+10  // Offset to signature
#define LI_SIZE         HI_SIZE+12  // Size of LocalInfo structure
#define LOCALSIG        0x4C48  // 'HL' Signature

#define TDB_next        0       // Offset to next TDB in TDB
#define TDB_PDB         72      // Offset to PDB in TDB

#define GF_PDB_OWNER    0x100   // Low byte is kernel flags

#define NEMAGIC         0x454E  // 'NE' Signature

#define NE_MAGIC        0       // Offset to NE in module header
#define NE_USAGE        2       // Offset to usage
#define NE_CBENTTAB     6       // Offset to cbenttab (really next module ptr)
#define NE_PATHOFFSET   10      // Offset to file path stuff
#define NE_CSEG         28      // Offset to cseg, number of segs in module
#define NE_SEGTAB       34      // Offset to segment table ptr in modhdr
#define NE_RESTAB       38      // Offset to resident names table ptr in modhdr

#define NS_HANDLE       8       // Offset to handle in seg table
#define NEW_SEG1_SIZE   10      // Size of the NS_ stuff


typedef struct {
    DWORD   dwSize;
    DWORD   dwAddress;
    DWORD   dwBlockSize;
    WORD    hBlock;
    WORD    wcLock;
    WORD    wcPageLock;
    WORD    wFlags;
    WORD    wHeapPresent;
    WORD    hOwner;
    WORD    wType;
    WORD    wData;
    DWORD   dwNext;
    DWORD   dwNextAlt;
} GLOBALENTRY16, *LPGLOBALENTRY16;


#pragma pack(2)
typedef struct {
    DWORD   dwSize;
    char    szModule[MAX_MODULE_NAME];
    WORD    hModule;
    WORD    wcUsage;
    char    szExePath[MAX_PATH16];
    WORD    wNext;
} MODULEENTRY16, *LPMODULEENTRY16;
#pragma pack()

typedef struct _segentry {
    struct _segentry *Next;
    int     type;
    char    szExePath[MAX_PATH16];
    char    szModule[MAX_MODULE_NAME];
    WORD    selector;
    WORD    segment;
    DWORD   length;  
} SEGENTRY, *PSEGENTRY;

#define SEGTYPE_V86         1
#define SEGTYPE_PROT        2

#pragma  pack(1)

typedef struct _GNODE32 {     // GlobalArena
   DWORD pga_next      ;    // next arena entry (last points to self)
   DWORD pga_prev      ;    // previous arena entry (first points to self)
   DWORD pga_address   ;    // 32 bit linear address of memory
   DWORD pga_size      ;    // 32 bit size in bytes
   WORD  pga_handle    ;    // back link to handle table entry
   WORD  pga_owner     ;    // Owner field (current task)
   BYTE  pga_count     ;    // lock count for movable segments
   BYTE  pga_pglock    ;    // # times page locked
   BYTE  pga_flags     ;    // 1 word available for flags
   BYTE  pga_selcount  ;    // Number of selectors allocated
   DWORD pga_lruprev   ;    // Previous entry in lru chain
   DWORD pga_lrunext   ;    // Next entry in lru chain
} GNODE32;
typedef GNODE32 UNALIGNED *PGNODE32;

typedef struct _GHI32 {
    WORD  hi_check     ;    // arena check word (non-zero enables heap checking)
    WORD  hi_freeze    ;    // arena frozen word (non-zero prevents compaction)
    WORD  hi_count     ;    // #entries in arena
    WORD  hi_first     ;    // first arena entry (sentinel, always busy)
    WORD  hi_res1      ;    // reserved
    WORD  hi_last      ;    // last arena entry (sentinel, always busy)
    WORD  hi_res2      ;    // reserved
    BYTE  hi_ncompact  ;    // #compactions done so far (max of 3)
    BYTE  hi_dislevel  ;    // current discard level
    DWORD hi_distotal  ;    // total amount discarded so far
    WORD  hi_htable    ;    // head of handle table list
    WORD  hi_hfree     ;    // head of free handle table list
    WORD  hi_hdelta    ;    // #handles to allocate each time
    WORD  hi_hexpand   ;    // address of near procedure to expand handles for this arena
    WORD  hi_pstats    ;    // address of statistics table or zero
} GHI32;
typedef GHI32 UNALIGNED *PGHI32;

typedef struct _HEAPENTRY {
    GNODE32 gnode;
    DWORD CurrentEntry;
    DWORD NextEntry;
    WORD Selector;
    int  SegmentNumber;
    char OwnerName[9];
    char FileName[9];
    char ModuleArg[9];
} HEAPENTRY;

typedef struct _NEHEADER {
    WORD ne_magic       ;
    BYTE ne_ver         ;
    BYTE ne_rev         ;
    WORD ne_enttab      ;
    WORD ne_cbenttab    ;
    DWORD ne_crc        ;
    WORD ne_flags       ;
    WORD ne_autodata    ;
    WORD ne_heap        ;
    WORD ne_stack       ;
    DWORD ne_csip       ;
    DWORD ne_sssp       ;
    WORD ne_cseg        ;
    WORD ne_cmod        ;
    WORD ne_cbnrestab   ;
    WORD ne_segtab      ;
    WORD ne_rsrctab     ;
    WORD ne_restab      ;
    WORD ne_modtab      ;
    WORD ne_imptab      ;
    DWORD ne_nrestab    ;
    WORD ne_cmovent     ;
    WORD ne_align       ;
    WORD ne_cres        ;
    BYTE ne_exetyp      ;
    BYTE ne_flagsothers ;
    WORD ne_pretthunks  ;
    WORD ne_psegrefbytes;
    WORD ne_swaparea    ;
    WORD ne_expver      ;
} NEHEADER;
typedef NEHEADER UNALIGNED *PNEHEADER;

#pragma  pack()

#ifndef i386

//
// Structures in 486 emulator for obtaining registers (FROM NT_CPU.C)
//

typedef struct NT_CPU_REG {
    ULONG *nano_reg;         /* where the nano CPU keeps the register */
    ULONG *reg;              /* where the light compiler keeps the reg */
    ULONG *saved_reg;        /* where currently unused bits are kept */
    ULONG universe_8bit_mask;/* is register in 8-bit form? */
    ULONG universe_16bit_mask;/* is register in 16-bit form? */
} NT_CPU_REG;

typedef struct NT_CPU_INFO {
    /* Variables for deciding what mode we're in */
    BOOL *in_nano_cpu;      /* is the Nano CPU executing? */
    ULONG *universe;         /* the mode that the CPU is in */

    /* General purpose register pointers */
    NT_CPU_REG eax, ebx, ecx, edx, esi, edi, ebp;

    /* Variables for getting SP or ESP. */
    BOOL *stack_is_big;     /* is the stack 32-bit? */
    ULONG *nano_esp;         /* where the Nano CPU keeps ESP */
    UCHAR **host_sp;          /* ptr to variable holding stack pointer as a
                               host address */
    UCHAR **ss_base;          /* ptr to variables holding base of SS as a
                               host address */
    ULONG *esp_sanctuary;    /* top 16 bits of ESP if we're now using SP */

    ULONG *eip;

    /* Segment registers. */
    USHORT *cs, *ds, *es, *fs, *gs, *ss;

    ULONG *flags;

    /* CR0, mainly to let us figure out if we're in real or protect mode */
    ULONG *cr0;
} NT_CPU_INFO;


#endif // i386

#define HANDLE_NULL  ((HANDLE)NULL)

#define LONG_TIMEOUT    INFINITE

#define READ_FIXED_ITEM(seg,offset,item)  \
    if ( ReadItem(hProcess,seg,offset,&item,sizeof(item)) ) goto punt;

#define WRITE_FIXED_ITEM(seg,offset,item)  \
    if ( WriteItem(hProcess,seg,offset,&item,sizeof(item)) ) goto punt;

#define LOAD_FIXED_ITEM(seg,offset,item)  \
    ReadItem(hProcess,seg,offset,&item,sizeof(item))

#define READ_SIZED_ITEM(seg,offset,item,size)  \
    if ( ReadItem(hProcess,seg,offset,item,size) ) goto punt;

#define WRITE_SIZED_ITEM(seg,offset,item,size)  \
    if ( WriteItem(hProcess,seg,offset,item,size) ) goto punt;

#define MALLOC(cb) HeapAlloc(GetProcessHeap(), HEAP_GENERATE_EXCEPTIONS, cb)
#define FREE(addr) HeapFree(GetProcessHeap(), 0, addr)

extern WORD    wKernelSeg;
extern DWORD   dwOffsetTHHOOK;
extern LPVOID  lpRemoteAddress;
extern DWORD   lpRemoteBlock;
extern BOOL    fKernel386;
extern DWORD   dwLdtBase;
extern DWORD   dwIntelBase;
extern LPVOID  lpNtvdmState;
extern LPVOID  lpVdmDbgFlags;
extern LPVOID  lpNtCpuInfo;
extern LPVOID  lpVdmContext;
extern LPVOID  lpVdmBreakPoints;

BOOL
InternalGetThreadSelectorEntry(
    HANDLE hProcess,
    WORD   wSelector,
    LPVDMLDT_ENTRY lpSelectorEntry
    );

ULONG
InternalGetPointer(
    HANDLE  hProcess,
    WORD    wSelector,
    DWORD   dwOffset,
    BOOL    fProtMode
    );

BOOL
ReadItem(
    HANDLE  hProcess,
    WORD    wSeg,
    DWORD   dwOffset,
    LPVOID  lpitem,
    UINT    nSize
    );

BOOL
WriteItem(
    HANDLE  hProcess,
    WORD    wSeg,
    DWORD   dwOffset,
    LPVOID  lpitem,
    UINT    nSize
    );

BOOL
CallRemote16(
    HANDLE          hProcess,
    LPSTR           lpModuleName,
    LPSTR           lpEntryName,
    LPBYTE          lpArgs,
    WORD            wArgsPassed,
    WORD            wArgsSize,
    LPDWORD         lpdwReturnValue,
    DEBUGEVENTPROC  lpEventProc,
    LPVOID          lpData
    );

DWORD
GetRemoteBlock16(
    VOID
    );


VOID
ProcessBPNotification(
    LPDEBUG_EVENT lpDebugEvent
    );

VOID
ProcessInitNotification(
    LPDEBUG_EVENT lpDebugEvent
    );

VOID
ProcessSegmentNotification(
    LPDEBUG_EVENT lpDebugEvent
    );

VOID
ParseModuleName(
    LPSTR szName,
    LPSTR szPath
    );

BOOL
GetInfoBySegmentNumber(
    LPSTR szModule,
    WORD SegNumber,
    VDM_SEGINFO *si
    );

BOOL
EnumerateModulesForValue(
    BOOL (WINAPI *pfnEnumModuleProc)(LPSTR,LPSTR,PWORD,PDWORD,PWORD),
    LPSTR  szSymbol,
    PWORD  pSelector,
    PDWORD pOffset,
    PWORD  pType
    );

#ifndef _X86_
WORD
ReadWord(
    HANDLE hProcess,
    LPVOID lpAddress
    );

DWORD
ReadDword(
    HANDLE hProcess,
    LPVOID lpAddress
    );

ULONG
GetRegValue(
    HANDLE hProcess,
    NT_CPU_REG reg,
    BOOL bInNano,
    ULONG UMask
    );

ULONG
GetEspValue(
    HANDLE hProcess,
    NT_CPU_INFO nt_cpu_info,
    BOOL bInNano
    );
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\vdmdbg\dllentry.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    dllentry.c

Abstract:

    This module contains VdmDbgDllEntry, the entrypoint for
    vdmdbg.dll.  We don't use CRT to speak of, if that changes
    this should be renamed DllMain, which DLLMainCRTStartup calls.
    Also in that case DisableThreadLibraryCalls may be inappropriate.

Author:

    Dave Hart (davehart) 26-Oct-97 Added DllEntry to fix leak
                                   in repeated load/unloads.

Revision History:


--*/

#include <precomp.h>
#pragma hdrstop
#include <sharewow.h>


BOOL
VdmDbgDllEntry(
    IN PVOID DllHandle,
    IN ULONG Reason,
    IN PCONTEXT Context OPTIONAL
    )

/*++

Routine Description:

    This function is the "entry point" for the DLL, called with
    process and thread attach and detach messages.  We disable
    thread attach and detach notifications since we don't use them.
    The primary reason for this is to clean up open handles to
    the shared memory and associated mutex at process detach, so
    folks who load and unload vdmdbg.dll repeatedly won't leak.

Arguments:

    DllHandle

    Reason

    Context - Not Used

Return Value:

    STATUS_SUCCESS

--*/

{
switch ( Reason ) {

    case DLL_PROCESS_ATTACH:

        DisableThreadLibraryCalls(DllHandle);

        break;


    case DLL_PROCESS_DETACH:

        //
        // Close handles to shared memory and mutex, if we're
        // being unloaded from the process (Context/lpReserved
        // NULL) as opposed to process shutdown (Context 1)
        //

        if (! Context) {

            if (hSharedWOWMutex) {
                CloseHandle(hSharedWOWMutex);
                hSharedWOWMutex = NULL;
            }
            if (lpSharedWOWMem) {
                UnmapViewOfFile(lpSharedWOWMem);
                lpSharedWOWMem = NULL;
            }
            if (hSharedWOWMem) {
                CloseHandle(hSharedWOWMem);
                hSharedWOWMem = NULL;
            }
        }

        break;

    default:
        break;
}

    return TRUE;  // FALSE means don't load for DLL_PROCESS_ATTACH
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\vdmdbg\segment.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    segment.c

Abstract:

    This module contains the debugging support needed to track
    16-bit VDM segment notifications.

Author:

    Neil Sandlin (neilsa) 1-Mar-1997 Rewrote it

Revision History:

--*/

#include <precomp.h>
#pragma hdrstop
#include <stdio.h>

SEGENTRY SegListHead = {0};


//----------------------------------------------------------------------------
// VDMGetSegtablePointer
//
//  This is an undocumented entry point that allows VDMEXTS to dump the
//  segment list
//
//----------------------------------------------------------------------------
PSEGENTRY
WINAPI
VDMGetSegtablePointer(
    VOID
    )
{
    return SegListHead.Next;
}

//----------------------------------------------------------------------------
// VDMIsModuleLoaded
//
//  Given the path parameter, this routine determines if there are any 
//  segments in the segment list from the specified executable.
//
//----------------------------------------------------------------------------
BOOL
WINAPI
VDMIsModuleLoaded(
    LPSTR szPath
    )
{
    PSEGENTRY pSegEntry = SegListHead.Next;

    if (!*szPath) {
        return FALSE;
    }

    while (pSegEntry) {
        if ( _stricmp(pSegEntry->szExePath, szPath) == 0 ) {
            return TRUE;
        }
        pSegEntry = pSegEntry->Next;
    }

    return FALSE;
}

//----------------------------------------------------------------------------
// SegmentLoad
//
//  This routine adds an entry to the segment list based on the parameters
//  of a client SegmentLoad notification.
//
//----------------------------------------------------------------------------
BOOL
SegmentLoad(
    WORD selector,
    WORD segment,
    LPSTR szExePath
    )
{
    PSEGENTRY pSegEntry;

    if (strlen(szExePath) >= MAX_PATH16) {
        return FALSE;
    }
    pSegEntry = MALLOC(sizeof(SEGENTRY));
    if (pSegEntry == NULL) {
        return FALSE;
    }
    pSegEntry->Next = SegListHead.Next;
    SegListHead.Next = pSegEntry;

    pSegEntry->selector = selector;
    pSegEntry->segment = segment;
    pSegEntry->type = SEGTYPE_PROT;
    strcpy( pSegEntry->szExePath, szExePath );
    ParseModuleName(pSegEntry->szModule, szExePath);
    pSegEntry->length = 0;
    return TRUE;
}

//----------------------------------------------------------------------------
// SegmentFree
//
//  This routine removes the entry from the segment list that matches the
//  pass selector.
//
//----------------------------------------------------------------------------
BOOL
SegmentFree(
    WORD selector
    )
{
    PSEGENTRY pSegEntry = SegListHead.Next;
    PSEGENTRY pSegPrev = &SegListHead;
    PSEGENTRY pSegTmp;
    BOOL fResult = FALSE;

    while (pSegEntry) {
        if ((pSegEntry->type == SEGTYPE_PROT) &&
            (pSegEntry->selector == selector)) {
            
            pSegPrev->Next = pSegEntry->Next;
            pSegTmp = pSegEntry;
            pSegEntry = pSegTmp->Next;
            FREE(pSegTmp);
            fResult = TRUE;
            
        } else {
            pSegEntry = pSegEntry->Next;
        }
    }
    return fResult;
}

//----------------------------------------------------------------------------
// ModuleLoad
//
//  This routine adds an entry to the segment list based on the parameters
//  of a client ModuleLoad notification.
//
//----------------------------------------------------------------------------
BOOL
ModuleLoad(
    WORD selector,
    WORD segment,
    DWORD length,
    LPSTR szExePath
    )
{
    PSEGENTRY pSegEntry;

    if (strlen(szExePath) >= MAX_PATH16) {
        return FALSE;
    }
    pSegEntry = MALLOC(sizeof(SEGENTRY));
    if (pSegEntry == NULL) {
        return FALSE;
    }
    pSegEntry->Next = SegListHead.Next;
    SegListHead.Next = pSegEntry;

    pSegEntry->selector = selector;
    pSegEntry->segment = segment;
    pSegEntry->type = SEGTYPE_V86;
    strcpy( pSegEntry->szExePath, szExePath );
    ParseModuleName(pSegEntry->szModule, szExePath);
    pSegEntry->length = length;
    return TRUE;
}

//----------------------------------------------------------------------------
// ModuleFree
//
//  This routine removes all entries from the segment list that contain
//  the specified path name.
//
//----------------------------------------------------------------------------
BOOL
ModuleFree(
    LPSTR szExePath
    )
{
    PSEGENTRY pSegEntry = SegListHead.Next;
    PSEGENTRY pSegPrev = &SegListHead;
    PSEGENTRY pSegTmp;
    BOOL fResult = FALSE;

    while (pSegEntry) {
        if ( _stricmp(pSegEntry->szExePath, szExePath) == 0 ) {
        
            pSegPrev->Next = pSegEntry->Next;
            pSegTmp = pSegEntry;
            pSegEntry = pSegTmp->Next;
            FREE(pSegTmp);
            fResult = TRUE;
            
        } else {
            pSegEntry = pSegEntry->Next;
        }
    }
    return fResult;
}

BOOL
V86SegmentMove(
    WORD Selector,
    WORD segment,
    DWORD length,
    LPSTR szExePath
    )
{
    PSEGENTRY pSegEntry = SegListHead.Next;
    PSEGENTRY pSegPrev = &SegListHead;

    //
    // first see if one exists already
    //
    pSegEntry = SegListHead.Next;
    while (pSegEntry) {
        if ((pSegEntry->type == SEGTYPE_V86) &&
            (pSegEntry->segment == segment)) {
                // Normal segmove, just update selector
            pSegEntry->selector = Selector;
            return TRUE;
        }
        pSegEntry = pSegEntry->Next;
    }

    //
    // An entry for this segment doesn't exist, so create one
    //

    ModuleLoad(Selector, segment, length, szExePath);

    //
    // Now delete segment zero for this module. This prevents
    // confusion in the symbol routines
    //

    pSegEntry = SegListHead.Next;
    pSegPrev = &SegListHead;
    while (pSegEntry) {
        if ((pSegEntry->type == SEGTYPE_V86) &&
            ( _stricmp(pSegEntry->szExePath, szExePath) == 0 ) &&
            (pSegEntry->segment == 0)) {

            // Unlink and free it
            pSegPrev->Next = pSegEntry->Next;
            FREE(pSegEntry);

            break;
        }
        pSegEntry = pSegEntry->Next;
    }

    return TRUE;
}

BOOL
PMSegmentMove(
    WORD Selector1,
    WORD Selector2
    )
{
    PSEGENTRY pSegEntry;

    if (!Selector2) {
        return (SegmentFree(Selector1));
    }

    // Look for the segment entry
    pSegEntry = SegListHead.Next;
    while (pSegEntry) {
        if ((pSegEntry->type == SEGTYPE_PROT) &&
            (pSegEntry->selector == Selector1)) {
                // Normal segmove, just update selector
            pSegEntry->selector = Selector2;
            return TRUE;
        }
        pSegEntry = pSegEntry->Next;
    }
    return FALSE;
}

//----------------------------------------------------------------------------
// ProcessSegmentNotification
//
//  This routine is the main entry point for the following debugger
//  notifications:
//      DBG_SEGLOAD
//      DBG_SEGFREE
//      DBG_SEGMOVE
//      DBG_MODLOAD
//      DBG_MODFREE
//
//  It is called from VDMProcessException.
//
//----------------------------------------------------------------------------
VOID
ProcessSegmentNotification(
    LPDEBUG_EVENT lpDebugEvent
    )
{
    BOOL            b;
    DWORD           lpNumberOfBytesRead;
    LPDWORD         lpdw;
    SEGMENT_NOTE    se;
    HANDLE          hProcess;
    PSEGENTRY       pSegEntry, pSegPrev;

    lpdw = &(lpDebugEvent->u.Exception.ExceptionRecord.ExceptionInformation[0]);
    hProcess = OpenProcess( PROCESS_VM_READ, FALSE, lpDebugEvent->dwProcessId );

    if ( hProcess == HANDLE_NULL ) {
        return;
    }

    b = ReadProcessMemory(hProcess,
                          (LPVOID)lpdw[2],
                          &se,
                          sizeof(se),
                          &lpNumberOfBytesRead );

    if ( !b || lpNumberOfBytesRead != sizeof(se) ) {
        return;
    }

    switch(LOWORD(lpdw[0])) {

    case DBG_SEGLOAD:

        SegmentLoad(se.Selector1, se.Segment, se.FileName);
        break;

    case DBG_SEGMOVE:

        if (se.Type == SN_V86) {
            V86SegmentMove(se.Selector2, se.Segment, se.Length, se.FileName);
        } else {
            PMSegmentMove(se.Selector1, se.Selector2);
        }
        break;

    case DBG_SEGFREE:

        // Here, se.Type is a boolean to tell whether to restore
        // any breakpoints in the segment. That was done in the api
        // because wdeb386 didn't know how to move the breakpoint
        // definitions during a SEGMOVE. Currently, we ignore it, but
        // it would be nice to either support the flag, or better to 
        // have ntsd update the breakpoints based on it.

        SegmentFree(se.Selector1);
        break;

    case DBG_MODFREE:
        ModuleFree(se.FileName);
        break;

    case DBG_MODLOAD:
        ModuleLoad(se.Selector1, 0, se.Length, se.FileName);
        break;

    }

    CloseHandle( hProcess );
}


void
CopySegmentInfo(
    VDM_SEGINFO *si,
    PSEGENTRY pSegEntry
    )
{
    si->Selector = pSegEntry->selector;
    si->SegNumber = pSegEntry->segment;
    si->Length = pSegEntry->length;
    si->Type = (pSegEntry->type == SEGTYPE_V86) ? 0 : 1;
    strcpy(si->ModuleName, pSegEntry->szModule);
    strcpy(si->FileName, pSegEntry->szExePath);
}


//----------------------------------------------------------------------------
// VDMGetSegmentInfo
//
//  This routine fills in a VDM_SEGINFO structure for the segment that matches
//  the specified parameters.
//  notifications:
//      DBG_SEGLOAD
//      DBG_SEGFREE
//      DBG_SEGMOVE
//      DBG_MODLOAD
//      DBG_MODFREE
//
//  It is called from VDMProcessException.
//
//----------------------------------------------------------------------------
BOOL
WINAPI
VDMGetSegmentInfo(
    WORD Selector,
    ULONG Offset,
    BOOL bProtectMode,
    VDM_SEGINFO *si
    )
{
    PSEGENTRY pSegEntry = SegListHead.Next;
    PSEGENTRY pSegPrev = &SegListHead;
    int mode = bProtectMode ? SEGTYPE_PROT : SEGTYPE_V86;
    ULONG Base, BaseEnd, Target;

    while (pSegEntry) {
        if (pSegEntry->type == mode) {
            switch(mode) {

            case SEGTYPE_PROT:
                if (pSegEntry->selector == Selector) {
                    CopySegmentInfo(si, pSegEntry);
                    return TRUE;
                }
                break;

            case SEGTYPE_V86:
                Base = pSegEntry->selector << 4;
                BaseEnd = Base + pSegEntry->length;
                Target = (Selector << 4) + Offset;
                if ((Target >= Base) && (Target < BaseEnd)) {
                    CopySegmentInfo(si, pSegEntry);
                    return TRUE;
                }
                break;
            }
        }
        pSegEntry = pSegEntry->Next;
    }
    return FALSE;
}



BOOL
GetInfoBySegmentNumber(
    LPSTR szModule,
    WORD SegNumber,
    VDM_SEGINFO *si
    )
{
    PSEGENTRY pSegEntry = SegListHead.Next;
    PSEGENTRY pSegPrev = &SegListHead;
    ULONG Base, BaseEnd, Target;

    while (pSegEntry) {

        if (_stricmp(szModule, pSegEntry->szModule) == 0) {

            if (pSegEntry->segment == 0 || pSegEntry->segment == SegNumber) {
                CopySegmentInfo(si, pSegEntry);
                return TRUE;
            }
        }
        pSegEntry = pSegEntry->Next;
    }
    return FALSE;
}

BOOL
EnumerateModulesForValue(
    BOOL (WINAPI *pfnEnumModuleProc)(LPSTR,LPSTR,PWORD,PDWORD,PWORD),
    LPSTR  szSymbol,
    PWORD  pSelector,
    PDWORD pOffset,
    PWORD  pType
    )
{
    PSEGENTRY pSegEntry = SegListHead.Next;
    PSEGENTRY pSegPrev = &SegListHead;
    ULONG Base, BaseEnd, Target;

    while (pSegEntry) {

        if (pSegEntry->szModule) {
        //
        // BUGBUG should optimize this so that it only calls
        // the enum proc once per module, instead of once per
        // segment
        //

            if ((*pfnEnumModuleProc)(pSegEntry->szModule,
                                     szSymbol,
                                     pSelector,
                                     pOffset,
                                     pType)) {
                return TRUE;
            }
        }

        pSegEntry = pSegEntry->Next;
    }
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\vdmdbg\sym.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    sym.c

Abstract:

    This function contains the 16-bit symbol support for VDMDBG

Author:

    Bob Day      (bobday) 29-Feb-1992 Grabbed standard header

Revision History:

    Neil Sandlin (NeilSa) 15-Jan-1996 Merged with vdmexts
    Neil Sandlin (NeilSa) 01-Mar-1997 Moved it to VDMDBG,
                                      Rewrote it

--*/

#include <precomp.h>
#pragma hdrstop

#define PRINTF(x) TRUE

#define MYOF_FLAGS (OF_READ | OF_SHARE_DENY_NONE)

#define MAX_MODULE_LIST 200
char ModuleList[MAX_MODULE_LIST][9];
int ModuleListCount = 0;

typedef struct _SYM_MAP {
    WORD  map_ptr;
    WORD  map_lsa;
    WORD  pgm_ent;
    WORD  abs_cnt;
    WORD  abs_ptr;
    WORD  seg_cnt;
    WORD  seg_ptr;
    BYTE   sym_nam_max;
    BYTE   map_nam_len;
    char    map_name[20];
} SYM_MAP;

typedef struct _SYM_SEG {
    WORD  nxt_seg;
    WORD  sym_cnt;
    WORD  sym_ptr;
    WORD  seg_lsa;
    WORD  seg_in[4];
    WORD  seg_lin;
    BYTE   seg_ldd;
    char    seg_cin;
    BYTE   seg_nam_len;
    char    seg_name[20];
} SYM_SEG;

typedef struct _SYM_ITEM {
    WORD  sym_val;
    BYTE   sym_nam_len;
    char    sym_name[256];
} SYM_ITEM;



BOOL
FindExport(
    LPSTR           filename,
    WORD            segment,
    WORD            offset,
    LPSTR           sym_text,
    BOOL            next,
    LONG            *dist
    )
{
    int     iFile;
    OFSTRUCT    ofs;
    int     rc;
    IMAGE_DOS_HEADER doshdr;
    IMAGE_OS2_HEADER winhdr;
    BYTE    Table[65536];
    BYTE    bBundles;
    BYTE    bFlags;
    BYTE    *ptr;
    WORD    wIndex = 1;
    int     i;
    int     this_dist;
    int     wIndexBest = -1;
    char    myfilename[256];
#pragma pack(1)
    typedef struct
    {
    BYTE        bFlags;
    UNALIGNED WORD  wSegOffset;
    } FENTRY, *PFENTRY;

    typedef struct
    {
    BYTE        bFlags;
    UNALIGNED WORD  wINT3F;
    BYTE        bSegNumber;
    UNALIGNED WORD  wSegOffset;
    } MENTRY, *PMENTRY;
#pragma pack()

    strcpy(myfilename, filename);
    if (-1 == (iFile=OpenFile(myfilename, &ofs, MYOF_FLAGS))) {

        //PRINTF("VDMDBG: Error reading file %s\n", filename);
        strcpy(myfilename, filename);
        strcat(myfilename, ".exe");

        if (-1 == (iFile=OpenFile(myfilename, &ofs, MYOF_FLAGS))) {

            //PRINTF("VDMDBG: Error reading file %s\n", myfilename);
            strcpy(myfilename, filename);
            strcat(myfilename, ".dll");

            if (-1 == (iFile=OpenFile(myfilename, &ofs, MYOF_FLAGS))) {
                //PRINTF("VDMDBG: Error reading file %s\n", myfilename);
                PRINTF("VDMDBG: Error reading file\n");
                return FALSE;
            }
        }
    }

    rc = _lread(iFile, &doshdr, sizeof(doshdr));
    if (rc != sizeof(doshdr)) {
    PRINTF("VDMDBG: Error reading DOS header\n");
    goto Error;
    }
    if (doshdr.e_magic != IMAGE_DOS_SIGNATURE) {
    PRINTF("VDMDBG: Error - no DOS EXE signature");
    goto Error;
    }
    rc = _llseek(iFile, doshdr.e_lfanew, FILE_BEGIN);
    if (rc == -1) {
    PRINTF("VDMDBG: Error - could not seek - probably not Win3.1 exe\n");
    goto Error;
    }
    rc = _lread(iFile, &winhdr, sizeof(winhdr));
    if (rc != sizeof(winhdr)) {
    PRINTF("VDMDBG: Error - could not read WIN header - probably not Win3.1 exe\n");
    goto Error;
    }
    if (winhdr.ne_magic != IMAGE_OS2_SIGNATURE) {
    PRINTF("VDMDBG: Error - not WIN EXE signature\n");
    goto Error;
    }
    rc = _llseek(iFile, doshdr.e_lfanew+winhdr.ne_enttab, FILE_BEGIN);
    if (rc == -1) {
    PRINTF("VDMDBG: Error - could not seek to entry table\n");
    goto Error;
    }
    rc = _lread(iFile, Table, winhdr.ne_cbenttab);
    if (rc != winhdr.ne_cbenttab) {
    PRINTF("VDMDBG: Error - could not read entry table\n");
    goto Error;
    }
    ptr = Table;
    while (TRUE) {
        bBundles = *ptr++;
        if (bBundles == 0)
            break;

        bFlags = *ptr++;
        switch (bFlags) {
            case 0: // Placeholders
            wIndex += bBundles;
            break;

            case 0xff:  // movable segments
            for (i=0; i<(int)bBundles; ++i) {
                PMENTRY pe = (PMENTRY )ptr;
                if (pe->bSegNumber == segment) {
                this_dist = (!next) ? offset - pe->wSegOffset
                                    : pe->wSegOffset - offset;
                if ( this_dist >= 0 && (this_dist < *dist || *dist == -1) ) {
                    // mark this as the best match so far
                    *dist = this_dist;
                    wIndexBest = wIndex;
                }
                }
                ptr += sizeof(MENTRY);
                wIndex++;
            }
            break;

            default:    // fixed segments
            if ((int)bFlags != segment) {
                ptr += (int)bBundles * sizeof(FENTRY);
                wIndex += (int)bBundles;
            } else {
                for (i=0; i<(int)bBundles; ++i) {
                PFENTRY pe = (PFENTRY)ptr;
                this_dist = (!next) ? offset - pe->wSegOffset
                                    : pe->wSegOffset - offset;
                if ( this_dist >= 0 && (this_dist < *dist || *dist == -1) ) {
                    // mark this as the best match so far
                    *dist = this_dist;
                    wIndexBest = wIndex;
                }
                ptr += sizeof(FENTRY);
                wIndex++;
                }
            }
            break;
        }
    }
    if (wIndexBest == -1) {
    // no match found - error out
Error:
        _lclose(iFile);
        return FALSE;
    }

    // Success: match found
    // wIndexBest = ordinal of the function
    // segment:offset = address to look up
    // *dist = distance from segment:offset to the symbol
    // filename = name of .exe/.dll

    // Look for the ordinal in the resident name table
    rc = _llseek(iFile, doshdr.e_lfanew+winhdr.ne_restab, FILE_BEGIN);
    if (rc == -1) {
        PRINTF("VDMDBG: Error - unable to seek to residentname table\n");
        goto Error;
    }
    rc = _lread(iFile, Table, winhdr.ne_modtab-winhdr.ne_restab);
    if (rc != winhdr.ne_modtab-winhdr.ne_restab) {
        PRINTF("VDMDBG: Error - unable to read entire resident name table\n");
        goto Error;
    }
    ptr = Table;
    while (*ptr) {
        if ( *(UNALIGNED USHORT *)(ptr+1+*ptr) == (USHORT)wIndexBest) {
            // found the matching name
            *(ptr+1+*ptr) = '\0';   // null-terminate the function name
            strcpy(sym_text, ptr+1);
            goto Finished;
        }
        ptr += *ptr + 3;
    }

    // Look for the ordinal in the non-resident name table
    rc = _llseek(iFile, doshdr.e_lfanew+winhdr.ne_nrestab, FILE_BEGIN);
    if (rc == -1) {
        PRINTF("VDMDBG: Error - unable to seek to non-residentname table\n");
        goto Error;
    }
    rc = _lread(iFile, Table, winhdr.ne_cbnrestab);
    if (rc != winhdr.ne_cbnrestab) {
        PRINTF("VDMDBG: Error - unable to read entire non-resident name table\n");
        goto Error;
    }
    ptr = Table;
    while (*ptr) {
        if ( *(UNALIGNED USHORT *)(ptr+1+*ptr) == (USHORT)wIndexBest) {
            // found the matching name
            *(ptr+1+*ptr) = '\0';   // null-terminate the function name
            strcpy(sym_text, ptr+1);
            goto Finished;
        }
        ptr += *ptr + 3;
    }
    // fall into error path - no match found
    goto Error;

Finished:
    _lclose(iFile);
    return TRUE;
}


BOOL
ExtractSymbol(
    int iFile,
    DWORD ulSegPos,
    DWORD ulSymPos,
    WORD csym,
    WORD seglsa,
    WORD segment,
    DWORD offset,
    BOOL next,
    LPSTR sym_text,
    PLONG pdist
    )
{
    WORD uLastSymdefPos=0;
    /* ulWrap allows for wrapping around with more than 64K of symbols */
    DWORD ulWrap=0;
    LONG SymOffset;
    LONG this_dist;
    BOOL fResult = FALSE;
    char name_text[256];

    for (; csym--; ulSymPos+=sizeof(WORD))
    {
        WORD uSymdefPos;
        SYM_ITEM sym;

        if (_llseek(iFile, ulSymPos, FILE_BEGIN) == -1)
            return FALSE;
        if (_lread(iFile, (LPSTR)&uSymdefPos, sizeof(uSymdefPos)) != sizeof(uSymdefPos))
            return FALSE;
        if (uSymdefPos < uLastSymdefPos)
            ulWrap += 0x10000L;
        _llseek(iFile, ulSegPos + uSymdefPos + ulWrap, FILE_BEGIN);
        _lread(iFile, (LPSTR)&sym, sizeof(sym));

        if (segment == 0) {
            SymOffset = (LONG)seglsa*16 + sym.sym_val;
        } else {
            SymOffset = (LONG)sym.sym_val;
        }

        // Depending on whether the caller wants the closest symbol
        // from below or above, compute the distance from the current
        // symbol to the target offset.
        switch( next ) {
            case FALSE:
                this_dist = offset - SymOffset;
                break;
            case TRUE:
                this_dist = SymOffset - offset;
                break;
        }

        //
        // Since we don't really know if the current symbol is actually
        // the nearest symbol, just remember it if it qualifies. Keep
        // the best distance so far in 'dist'.
        //
        if ((this_dist >= 0) && ((this_dist < *pdist) || (*pdist == -1))) {
            *pdist = this_dist;
            strncpy(name_text, sym.sym_name, sym.sym_nam_len);
            name_text[sym.sym_nam_len] = 0;
            fResult = TRUE;
        }

        uLastSymdefPos = uSymdefPos;
    }

    if (fResult) {
        //
        // The scan of the symbols in this segment produced a winner.
        // Copy the name and displacement back up to the caller.
        //
        strcpy(sym_text, name_text);
    }
    return fResult;
}

BOOL
WalkSegmentsForSymbol(
    int iFile,
    SYM_MAP *pMap,
    ULONG ulMapPos,
    WORD segment,
    DWORD offset,
    BOOL next,
    LPSTR sym_text,
    PDWORD pDisplacement
    )
{

    DWORD ulSegPos;
    LONG dist = -1;
    BOOL fResult = FALSE;
    WORD this_seg;

#if 0
    /* first, walk absolute segment */
    if (fAbsolute && map.abs_cnt != 0) {

        /* the thing with seg_ptr below is to allow for an absolute
         * segment with more than 64K of symbols: if the segment
         * pointer of the next symbol is more than 64K away, then
         * add 64K to the beginning of the table of symbol pointers.
         */
        if (ExtractSymbol(iFile,
                          ulMapPos,
                          ulMapPos + pMap->abs_ptr + (pMap->seg_ptr&0xF000)*0x10L,
                          pMap->abs_cnt,
                          0,
                          segment,
                          offset,
                          next,
                          sym_text,
                          pDisplacement)) {
            return TRUE;
        }
    }
#endif

    /* now walk other segments */
    ulSegPos = (DWORD)pMap->seg_ptr * 16;
    for (this_seg = 0; this_seg < pMap->seg_cnt; this_seg++) {
        SYM_SEG seg;

        if (_llseek(iFile, ulSegPos, FILE_BEGIN) == -1)
            return FALSE;
        if (_lread(iFile, (LPSTR)&seg, sizeof(seg)) != sizeof(seg))
            return FALSE;

        if ((segment == 0) || (segment == this_seg+1)) {
            if (ExtractSymbol(iFile,
                              ulSegPos,
                              ulSegPos + seg.sym_ptr,
                              seg.sym_cnt,
                              seg.seg_lsa,
                              segment,
                              offset,
                              next,
                              sym_text,
                              &dist)) {
                fResult = TRUE;
                if (segment != 0) {
                    // only looking in one segment
                    break;
                }
            }
        }
        ulSegPos = (DWORD)seg.nxt_seg * 16;
    }

    if (fResult) {
        *pDisplacement = dist;
    }
    return fResult;
}


BOOL
WINAPI
VDMGetSymbol(
    LPSTR fn,
    WORD segment,
    DWORD offset,
    BOOL bProtectMode,
    BOOL next,
    LPSTR sym_text,
    PDWORD pDisplacement
    )
{
    int         iFile;
    char        filename[256];
    OFSTRUCT    ofs;
    SYM_MAP     map;
    SYM_SEG     seg;
    SYM_ITEM    item;
    ULONG       ulMapPos = 0;

    strcpy(filename, fn);
    strcat(filename,".sym");

    iFile = OpenFile( filename, &ofs, MYOF_FLAGS );

    if ( iFile == -1 ) {
        // Open the .EXE/.DLL file and see if the address corresponds
        // to an exported function.
        return(FindExport(fn,segment,(WORD)offset,sym_text,next,pDisplacement));
    }

    do {

        if (_llseek( iFile, ulMapPos, FILE_BEGIN) == -1) {
            PRINTF("VDMDBG: GetSymbol failed to seek to map\n");
            break;
        }

        if (_lread( iFile, (LPSTR)&map, sizeof(map)) != sizeof(map)) {
            PRINTF("VDMDBG: GetSymbol failed to read map\n");
            break;
        }

        if (WalkSegmentsForSymbol(iFile, &map, ulMapPos,
                                  segment, offset, next,
                                  sym_text, pDisplacement)) {
            _lclose( iFile );
            return TRUE;
        }

    } while(ulMapPos);

    _lclose( iFile );
    return FALSE;
}


BOOL
ExtractValue(
    int iFile,
    DWORD ulSegPos,
    DWORD ulSymPos,
    WORD csym,
    LPSTR szSymbol,
    PWORD pValue
    )
{
    WORD uLastSymdefPos=0;
    /* ulWrap allows for wrapping around with more than 64K of symbols */
    DWORD ulWrap=0;
    LONG SymOffset;
    char name_text[256];

    for (; csym--; ulSymPos+=sizeof(WORD))
    {
        WORD uSymdefPos;
        SYM_ITEM sym;

        if (_llseek(iFile, ulSymPos, FILE_BEGIN) == -1)
            return FALSE;
        if (_lread(iFile, (LPSTR)&uSymdefPos, sizeof(uSymdefPos)) != sizeof(uSymdefPos))
            return FALSE;
        if (uSymdefPos < uLastSymdefPos)
            ulWrap += 0x10000L;
        _llseek(iFile, ulSegPos + uSymdefPos + ulWrap, FILE_BEGIN);
        _lread(iFile, (LPSTR)&sym, sizeof(sym));

        strncpy(name_text, sym.sym_name, sym.sym_nam_len);
        name_text[sym.sym_nam_len] = 0;

        if (_stricmp(szSymbol, name_text) == 0) {
            *pValue = sym.sym_val;
            return TRUE;
        }

        uLastSymdefPos = uSymdefPos;
    }

    return FALSE;
}

BOOL
WalkSegmentsForValue(
    int iFile,
    SYM_MAP *pMap,
    ULONG ulMapPos,
    LPSTR szSymbol,
    PWORD pSegmentBase,
    PWORD pSegmentNumber,
    PWORD pValue
    )
{

    DWORD ulSegPos;
    WORD this_seg;

#if 0
    /* first, walk absolute segment */
    if (fAbsolute && pMap->abs_cnt != 0) {

        /* the thing with seg_ptr below is to allow for an absolute
         * segment with more than 64K of symbols: if the segment
         * pointer of the next symbol is more than 64K away, then
         * add 64K to the beginning of the table of symbol pointers.
         */
        if (ExtractValue(iFile,
                          ulMapPos,
                          ulMapPos + pMap->abs_ptr + (pMap->seg_ptr&0xF000)*0x10L,
                          pMap->abs_cnt,
                          szSymbol,
                          pValue)) {
            return TRUE;
        }
    }
#endif

    /* now walk other segments */
    ulSegPos = (DWORD)pMap->seg_ptr * 16;
    for (this_seg = 0; this_seg < pMap->seg_cnt; this_seg++) {
        SYM_SEG seg;

        if (_llseek(iFile, ulSegPos, FILE_BEGIN) == -1)
            return FALSE;
        if (_lread(iFile, (LPSTR)&seg, sizeof(seg)) != sizeof(seg))
            return FALSE;

        if (ExtractValue(iFile,
                          ulSegPos,
                          ulSegPos + seg.sym_ptr,
                          seg.sym_cnt,
                          szSymbol,
                          pValue)) {
            *pSegmentBase = seg.seg_lsa;
            *pSegmentNumber = this_seg+1;
            return TRUE;
        }
        ulSegPos = (DWORD)seg.nxt_seg * 16;
    }
    return FALSE;
}


BOOL
WalkMapForValue(
    LPSTR  fn,
    LPSTR  szSymbol,
    PWORD  pSelector,
    PDWORD pOffset,
    PWORD  pType
    )
{
    int         iFile;
    char        filename[256];
    OFSTRUCT    ofs;
    SYM_MAP     map;
    SYM_SEG     seg;
    SYM_ITEM    item;
    ULONG       ulMapPos = 0;
    WORD        SegmentNumber;
    WORD        SegmentBase;
    WORD        Value;

    strcpy(filename, fn);
    strcat(filename,".sym");

    iFile = OpenFile( filename, &ofs, MYOF_FLAGS );

    if ( iFile == -1 ) {
        return FALSE;
    }

    do {

        if (_llseek( iFile, ulMapPos, FILE_BEGIN) == -1) {
            PRINTF("VDMDBG: failed to seek to map\n");
            break;
        }

        if (_lread( iFile, (LPSTR)&map, sizeof(map)) != sizeof(map)) {
            PRINTF("VDMDBG: failed to read map\n");
            break;
        }

        if (WalkSegmentsForValue(iFile, &map, ulMapPos,
                                  szSymbol, &SegmentBase, &SegmentNumber, &Value)) {

            VDM_SEGINFO si;

            if (GetInfoBySegmentNumber(fn, SegmentNumber, &si)) {

                *pSelector = si.Selector;
                if (!si.Type) {
                    *pType = VDMADDR_V86;

                    if (!si.SegNumber) {
                        // This is a "combined" map of all the segments,
                        // so we need to calculate the offset
                        *pOffset = (DWORD)SegmentBase*16 + Value;
                    } else {
                        // This is a "split" v86 map
                        *pOffset = (DWORD) Value;
                    }
                } else {
                    *pType = VDMADDR_PM16;
                    *pOffset = (DWORD)Value;
                }

                _lclose( iFile );
                return TRUE;
            }
        }

    } while(ulMapPos);

    _lclose( iFile );
    return FALSE;
}

BOOL
WINAPI
VDMGetAddrExpression(
    LPSTR  szModule,
    LPSTR  szSymbol,
    PWORD  pSelector,
    PDWORD pOffset,
    PWORD  pType
    )
{
    int         iFile;
    char        filename[256];
    OFSTRUCT    ofs;
    SYM_MAP     map;
    SYM_SEG     seg;
    SYM_ITEM    item;
    ULONG       ulMapPos = 0;

    if (szModule) {
        return(WalkMapForValue(szModule, szSymbol, pSelector, pOffset, pType));
    }

    return (EnumerateModulesForValue(VDMGetAddrExpression,
                                     szSymbol,
                                     pSelector,
                                     pOffset,
                                     pType));

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\vdmdbg\util.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    util.c

Abstract:

    This module contains the debugging support needed to debug
    16-bit VDM applications

Author:

    Bob Day      (bobday) 16-Sep-1992 Wrote it

Revision History:

    Neil Sandlin (neilsa) 1-Mar-1997 Enhanced it

--*/

#include <precomp.h>
#pragma hdrstop

WORD    wKernelSeg = 0;
DWORD   dwOffsetTHHOOK = 0L;
LPVOID  lpRemoteAddress = NULL;
DWORD   lpRemoteBlock = 0;
BOOL    fKernel386 = FALSE;
DWORD   dwLdtBase = 0;
DWORD   dwIntelBase = 0;
LPVOID  lpNtvdmState = NULL;
LPVOID  lpVdmDbgFlags = NULL;
LPVOID  lpVdmContext = NULL;
LPVOID  lpNtCpuInfo = NULL;
LPVOID  lpVdmBreakPoints = NULL;

//----------------------------------------------------------------------------
// InternalGetThreadSelectorEntry()
//
//   Routine to return a LDT_ENTRY structure for the passed in selector number.
//   Its is assumed that we are talking about protect mode selectors.
//   For x86 systems, take the easy way and just call the system.  For non-x86
//   systems, we get some information from softpc and index into them as the
//   LDT and GDT tables.
//
//----------------------------------------------------------------------------
BOOL
InternalGetThreadSelectorEntry(
    HANDLE hProcess,
    WORD   wSelector,
    LPVDMLDT_ENTRY lpSelectorEntry
    )
{
    BOOL bResult = FALSE;
    DWORD lpNumberOfBytesRead;

    // For non-intel systems, query the information from the LDT
    // that we have a pointer to from the VDMINTERNALINFO that we
    // got passed.

    if (!dwLdtBase) {

        RtlFillMemory( lpSelectorEntry, sizeof(VDMLDT_ENTRY), (UCHAR)0 );

    } else {

        bResult = ReadProcessMemory(
                    hProcess,
                    (LPVOID)(dwLdtBase+((wSelector&~7))),
                    lpSelectorEntry,
                    sizeof(VDMLDT_ENTRY),
                    &lpNumberOfBytesRead
                    );

    }

    return( bResult );
}


//----------------------------------------------------------------------------
// InternalGetPointer()
//
//   Routine to convert a 16-bit address into a 32-bit address.  If fProtMode
//   is TRUE, then the selector table lookup is performed.  Otherwise, simple
//   real mode address calculations are performed.  On non-x86 systems, the
//   base of real memory is added into the
//
//----------------------------------------------------------------------------
ULONG
InternalGetPointer(
    HANDLE  hProcess,
    WORD    wSelector,
    DWORD   dwOffset,
    BOOL    fProtMode
    )
{
    VDMLDT_ENTRY    le;
    ULONG           ulResult;
    ULONG           base;
    ULONG           limit;
    BOOL            b;

    if ( fProtMode ) {
        b = InternalGetThreadSelectorEntry( hProcess,
                                            wSelector,
                                            &le );
        if ( !b ) {
            return( 0 );
        }

        base =   ((ULONG)le.HighWord.Bytes.BaseHi << 24)
               + ((ULONG)le.HighWord.Bytes.BaseMid << 16)
               + ((ULONG)le.BaseLow);
        limit = (ULONG)le.LimitLow
              + ((ULONG)le.HighWord.Bits.LimitHi << 16);
        if ( le.HighWord.Bits.Granularity ) {
            limit <<= 12;
            limit += 0xFFF;
        }
    } else {
        base = wSelector << 4;
        limit = 0xFFFF;
    }
    if ( dwOffset > limit ) {
        ulResult = 0;
    } else {
        ulResult = base + dwOffset;
#ifndef i386
        ulResult += dwIntelBase;
#endif
    }

    return( ulResult );
}


//----------------------------------------------------------------------------
// ReadItem
//
//    Internal routine used to read items out of the debugee's address space.
//    The routine returns TRUE for failure.  This allows easy failure testing.
//
//----------------------------------------------------------------------------
BOOL
ReadItem(
    HANDLE  hProcess,
    WORD    wSeg,
    DWORD   dwOffset,
    LPVOID  lpitem,
    UINT    nSize
    )
{
    LPVOID  lp;
    BOOL    b;
    DWORD   dwBytes;

    if ( nSize == 0 ) {
        return( FALSE );
    }

    lp = (LPVOID)InternalGetPointer(
                    hProcess,
                    (WORD)(wSeg | 1),
                    dwOffset,
                    TRUE );
    if ( lp == NULL ) return( TRUE );

    b = ReadProcessMemory(
                    hProcess,
                    lp,
                    lpitem,
                    nSize,
                    &dwBytes );
    if ( !b || dwBytes != nSize ) return( TRUE );

    return( FALSE );
}

//----------------------------------------------------------------------------
// WriteItem
//
//    Internal routine used to write items into the debugee's address space.
//    The routine returns TRUE for failure.  This allows easy failure testing.
//
//----------------------------------------------------------------------------
BOOL
WriteItem(
    HANDLE  hProcess,
    WORD    wSeg,
    DWORD   dwOffset,
    LPVOID  lpitem,
    UINT    nSize
    )
{
    LPVOID  lp;
    BOOL    b;
    DWORD   dwBytes;

    if ( nSize == 0 ) {
        return( FALSE );
    }

    lp = (LPVOID)InternalGetPointer(
                    hProcess,
                    (WORD)(wSeg | 1),
                    dwOffset,
                    TRUE );
    if ( lp == NULL ) return( TRUE );

    b = WriteProcessMemory(
                    hProcess,
                    lp,
                    lpitem,
                    nSize,
                    &dwBytes );
    if ( !b || dwBytes != nSize ) return( TRUE );

    return( FALSE );
}



BOOL
CallRemote16(
    HANDLE          hProcess,
    LPSTR           lpModuleName,
    LPSTR           lpEntryName,
    LPBYTE          lpArgs,
    WORD            wArgsPassed,
    WORD            wArgsSize,
    LPDWORD         lpdwReturnValue,
    DEBUGEVENTPROC  lpEventProc,
    LPVOID          lpData
    )
{
    HANDLE          hRemoteThread;
    DWORD           dwThreadId;
    DWORD           dwContinueCode;
    DEBUG_EVENT     de;
    BOOL            b;
    BOOL            fContinue;
    COM_HEADER      comhead;
    WORD            wRemoteSeg;
    WORD            wRemoteOff;
    WORD            wOff;
    UINT            uModuleLength;
    UINT            uEntryLength;

    if ( lpRemoteAddress == NULL || lpRemoteBlock == 0 ) {
#ifdef DEBUG
        OutputDebugString("Remote address or remote block not initialized\n");
#endif
        return( FALSE );
    }

    wRemoteSeg = HIWORD(lpRemoteBlock);
    wRemoteOff = LOWORD(lpRemoteBlock);
    wOff = wRemoteOff;

    // Fill in the communications buffer header

    READ_FIXED_ITEM( wRemoteSeg, wOff, comhead );

    comhead.wArgsPassed = wArgsPassed;
    comhead.wArgsSize   = wArgsSize;

    uModuleLength = strlen(lpModuleName) + 1;
    uEntryLength = strlen(lpEntryName) + 1;

    //
    // If this call won't fit into the buffer, then fail.
    //
    if ( (UINT)comhead.wBlockLength < sizeof(comhead) + wArgsSize + uModuleLength + uEntryLength ) {
#ifdef DEBUG
        OutputDebugString("Block won't fit\n");
#endif
        return( FALSE );
    }


    WRITE_FIXED_ITEM( wRemoteSeg, wOff, comhead );
    wOff += sizeof(comhead);

    // Fill in the communications buffer arguments
    WRITE_SIZED_ITEM( wRemoteSeg, wOff, lpArgs, wArgsSize );
    wOff += wArgsSize;

    // Fill in the communications buffer module name and entry name
    WRITE_SIZED_ITEM( wRemoteSeg, wOff, lpModuleName, uModuleLength );
    wOff += (WORD) uModuleLength;

    WRITE_SIZED_ITEM( wRemoteSeg, wOff, lpEntryName, uEntryLength );
    wOff += (WORD) uEntryLength;

    hRemoteThread = CreateRemoteThread(
                    hProcess,
                    NULL,
                    (DWORD)0,
                    lpRemoteAddress,
                    NULL,
                    0,
                    &dwThreadId );

    if ( hRemoteThread == (HANDLE)0 ) {     // Fail if we couldn't creaet thrd
#ifdef DEBUG
        OutputDebugString("CreateRemoteThread failed\n");
#endif
        return( FALSE );
    }

    //
    // Wait for the EXIT_THREAD_DEBUG_EVENT.
    //

    fContinue = TRUE;

    while ( fContinue ) {

        b = WaitForDebugEvent( &de, LONG_TIMEOUT );

        if (!b) {
            TerminateThread( hRemoteThread, 0 );
            CloseHandle( hRemoteThread );
            return( FALSE );
        }

        if ( de.dwThreadId == dwThreadId &&
               de.dwDebugEventCode == EXIT_THREAD_DEBUG_EVENT ) {
            fContinue = FALSE;
        }

        if ( lpEventProc ) {
            dwContinueCode = (* lpEventProc)( &de, lpData );
        } else {
            dwContinueCode = DBG_CONTINUE;
        }

        ContinueDebugEvent( de.dwProcessId, de.dwThreadId, dwContinueCode );

    }

    b = WaitForSingleObject( hRemoteThread, LONG_TIMEOUT );
    CloseHandle( hRemoteThread );

    if (b) {
#ifdef DEBUG
        OutputDebugString("Wait for remote thread failed\n");
#endif
        return( FALSE );
    }

    //
    // Get the return value and returned arguments
    //
    wOff = wRemoteOff;

    READ_FIXED_ITEM( wRemoteSeg, wOff, comhead );
    wOff += sizeof(comhead);

    *lpdwReturnValue = comhead.dwReturnValue;

    // Read back the communications buffer arguments
    READ_SIZED_ITEM( wRemoteSeg, wOff, lpArgs, wArgsSize );

    return( comhead.wSuccess );

punt:
    return( FALSE );
}

DWORD
GetRemoteBlock16(
    VOID
    )
{
    if ( lpRemoteBlock == 0 ) {
        return( 0 );
    }
    return( ((DWORD)lpRemoteBlock) + sizeof(COM_HEADER) );
}


VOID
ProcessInitNotification(
    LPDEBUG_EVENT lpDebugEvent
    )
{
    VDMINTERNALINFO viInfo;
    DWORD           lpNumberOfBytesRead;
    HANDLE          hProcess;
    BOOL            b;
    LPDWORD         lpdw;

    lpdw = &(lpDebugEvent->u.Exception.ExceptionRecord.ExceptionInformation[0]);
    hProcess = OpenProcess( PROCESS_VM_READ, FALSE, lpDebugEvent->dwProcessId );

    if ( hProcess == HANDLE_NULL ) {
        return;
    }

    b = ReadProcessMemory(hProcess,
                          (LPVOID)lpdw[3],
                          &viInfo,
                          sizeof(viInfo),
                          &lpNumberOfBytesRead
                          );
    if ( !b || lpNumberOfBytesRead != sizeof(viInfo) ) {
        return;

    }

    if ( wKernelSeg == 0 ) {
        wKernelSeg = viInfo.wKernelSeg;
        dwOffsetTHHOOK = viInfo.dwOffsetTHHOOK;
    }
    if ( lpRemoteAddress == NULL ) {
        lpRemoteAddress = viInfo.lpRemoteAddress;
    }
    if ( lpRemoteBlock == 0 ) {
        lpRemoteBlock = viInfo.lpRemoteBlock;
    }

    dwLdtBase = viInfo.dwLdtBase;
    dwIntelBase = viInfo.dwIntelBase;
    fKernel386 = viInfo.f386;
    lpNtvdmState = viInfo.lpNtvdmState;
    lpVdmDbgFlags = viInfo.lpVdmDbgFlags;
    lpVdmContext  = viInfo.vdmContext;
    lpNtCpuInfo  = viInfo.lpNtCpuInfo;
    lpVdmBreakPoints = viInfo.lpVdmBreakPoints;

    CloseHandle( hProcess );
}

VOID
ParseModuleName(
    LPSTR szName,
    LPSTR szPath
    )
/*++

    Routine Description:

        This routine strips off the 8 character file name from a path

    Arguments:

        szName - pointer to buffer of 8 characters (plus null)
        szPath - full path of file

    Return Value

        None.

--*/

{
    LPSTR lPtr = szPath;
    LPSTR lDest = szName;
    int BufferSize = 9;

    while(*lPtr) lPtr++;     // scan to end

    while( ((DWORD)lPtr > (DWORD)szPath) &&
           ((*lPtr != '\\') && (*lPtr != '/'))) lPtr--;

    if (*lPtr) lPtr++;

    while((*lPtr) && (*lPtr!='.')) {
        if (!--BufferSize) break;
        *lDest++ = *lPtr++;
    }

    *lDest = 0;
}

#ifndef i386

WORD
ReadWord(
    HANDLE hProcess,
    PVOID lpAddress
    )
{
    NTSTATUS bResult;
    WORD value;
    ULONG NumberOfBytesRead;

    bResult = ReadProcessMemory(
                hProcess,
                lpAddress,
                &value,
                sizeof(WORD),
                &NumberOfBytesRead
                );
    return value;
}

DWORD
ReadDword(
    HANDLE hProcess,
    PVOID lpAddress
    )
{
    NTSTATUS bResult;
    DWORD value;
    ULONG NumberOfBytesRead;

    bResult = ReadProcessMemory(
                hProcess,
                lpAddress,
                &value,
                sizeof(DWORD),
                &NumberOfBytesRead
                );
    return value;
}

//
// The following two routines implement the very funky way that we
// have to get register values on the 486 emulator.
//

ULONG
GetRegValue(
    HANDLE hProcess,
    NT_CPU_REG reg,
    BOOL bInNano,
    ULONG UMask
    )

{
    if (bInNano) {

        return(ReadDword(hProcess, reg.nano_reg));

    } else if (UMask & reg.universe_8bit_mask) {

        return (ReadDword(hProcess, reg.saved_reg) & 0xFFFFFF00 |
                ReadDword(hProcess, reg.reg) & 0xFF);

    } else if (UMask & reg.universe_16bit_mask) {

        return (ReadDword(hProcess, reg.saved_reg) & 0xFFFF0000 |
                ReadDword(hProcess, reg.reg) & 0xFFFF);

    } else {

        return (ReadDword(hProcess, reg.reg));

    }
}

ULONG
GetEspValue(
    HANDLE hProcess,
    NT_CPU_INFO nt_cpu_info,
    BOOL bInNano
    )

{
    if (bInNano) {

        return (ReadDword(hProcess, nt_cpu_info.nano_esp));

    } else {

        if (ReadDword(hProcess, nt_cpu_info.stack_is_big)) {

            return (ReadDword(hProcess, nt_cpu_info.host_sp) -
                    ReadDword(hProcess, nt_cpu_info.ss_base));

        } else {

            return (ReadDword(hProcess, nt_cpu_info.esp_sanctuary) & 0xFFFF0000 |
                    (ReadDword(hProcess, nt_cpu_info.host_sp) -
                     ReadDword(hProcess, nt_cpu_info.ss_base) & 0xFFFF));

        }

    }

}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\vdmdbg\toolhelp.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    vdmdbg.c

Abstract:

    This module contains the debugging support needed to debug
    16-bit VDM applications

Author:

    Bob Day      (bobday) 16-Sep-1992 Wrote it

Revision History:

    Neil Sandlin (neilsa) 1-Mar-1997 Enhanced it

--*/

#include <precomp.h>
#pragma hdrstop


VOID CopyToGlobalEntry16(
    LPGLOBALENTRY   lpGlobalEntry,
    LPGLOBALENTRY16 lpGlobalEntry16
) {
    if ( lpGlobalEntry == NULL || lpGlobalEntry16 == NULL ) {
        return;
    }
    lpGlobalEntry16->dwSize       = sizeof(GLOBALENTRY16);
    lpGlobalEntry16->dwAddress    = lpGlobalEntry->dwAddress;
    lpGlobalEntry16->dwBlockSize  = lpGlobalEntry->dwBlockSize;
    lpGlobalEntry16->hBlock       = (WORD)lpGlobalEntry->hBlock;
    lpGlobalEntry16->wcLock       = lpGlobalEntry->wcLock;
    lpGlobalEntry16->wcPageLock   = lpGlobalEntry->wcPageLock;
    lpGlobalEntry16->wFlags       = lpGlobalEntry->wFlags;
    lpGlobalEntry16->wHeapPresent = (BOOLEAN)lpGlobalEntry->wHeapPresent;
    lpGlobalEntry16->hOwner       = (WORD)lpGlobalEntry->hOwner;
    lpGlobalEntry16->wType        = lpGlobalEntry->wType;
    lpGlobalEntry16->wData        = lpGlobalEntry->wData;
    lpGlobalEntry16->dwNext       = lpGlobalEntry->dwNext;
    lpGlobalEntry16->dwNextAlt    = lpGlobalEntry->dwNextAlt;
}

VOID CopyFromGlobalEntry16(
    LPGLOBALENTRY   lpGlobalEntry,
    LPGLOBALENTRY16 lpGlobalEntry16
) {
    if ( lpGlobalEntry == NULL || lpGlobalEntry16 == NULL ) {
        return;
    }
    lpGlobalEntry->dwSize         = sizeof(GLOBALENTRY);
    lpGlobalEntry->dwAddress      = lpGlobalEntry16->dwAddress;
    lpGlobalEntry->dwBlockSize    = lpGlobalEntry16->dwBlockSize;
    lpGlobalEntry->hBlock         = (HANDLE)lpGlobalEntry16->hBlock;
    lpGlobalEntry->wcLock         = lpGlobalEntry16->wcLock;
    lpGlobalEntry->wcPageLock     = lpGlobalEntry16->wcPageLock;
    lpGlobalEntry->wFlags         = lpGlobalEntry16->wFlags;
    lpGlobalEntry->wHeapPresent   = lpGlobalEntry16->wHeapPresent;
    lpGlobalEntry->hOwner         = (HANDLE)lpGlobalEntry16->hOwner;
    lpGlobalEntry->wType          = lpGlobalEntry16->wType;
    lpGlobalEntry->wData          = lpGlobalEntry16->wData;
    lpGlobalEntry->dwNext         = lpGlobalEntry16->dwNext;
    lpGlobalEntry->dwNextAlt      = lpGlobalEntry16->dwNextAlt;
}


BOOL
WINAPI
VDMGlobalFirst(
    HANDLE          hProcess,
    HANDLE          hUnused,
    LPGLOBALENTRY   lpGlobalEntry,
    WORD            wFlags,
    DEBUGEVENTPROC  lpEventProc,
    LPVOID          lpData
) {
#define GF_SIZE 6           // 6 bytes are passed to GlobalFirst
    BYTE            Args[GF_SIZE+sizeof(GLOBALENTRY16)];
    LPBYTE          lpbyte;
    DWORD           vpBuff;
    DWORD           dwResult;
    BOOL            b;
    UNREFERENCED_PARAMETER(hUnused);

    if ( lpGlobalEntry->dwSize != sizeof(GLOBALENTRY) ) {
        return( FALSE );
    }

    vpBuff = GetRemoteBlock16();
    vpBuff += GF_SIZE;

    lpbyte = Args;

    // Push the flags
    (*(LPWORD)lpbyte) = wFlags;
    lpbyte += sizeof(WORD);

    // Push the pointer to the pointer to the GLOBALENTRY16 structure
    (*(LPWORD)lpbyte) = LOWORD(vpBuff);
    lpbyte += sizeof(WORD);

    (*(LPWORD)lpbyte) = HIWORD(vpBuff);
    lpbyte += sizeof(WORD);

    CopyToGlobalEntry16( lpGlobalEntry, (LPGLOBALENTRY16)lpbyte );

    b = CallRemote16(
            hProcess,
            "TOOLHELP.DLL",
            "GlobalFirst",
            Args,
            GF_SIZE,
            sizeof(Args),
            &dwResult,
            lpEventProc,
            lpData );

    if ( !b ) {
        return( FALSE );
    }
    CopyFromGlobalEntry16( lpGlobalEntry, (LPGLOBALENTRY16)lpbyte );


    return( (BOOL)((WORD)dwResult) );
}


BOOL
WINAPI
VDMGlobalNext(
    HANDLE          hProcess,
    HANDLE          hUnused,
    LPGLOBALENTRY   lpGlobalEntry,
    WORD            wFlags,
    DEBUGEVENTPROC  lpEventProc,
    LPVOID          lpData
) {
#define GN_SIZE 6           // 6 bytes are passed to GlobalNext
    BYTE            Args[GN_SIZE+sizeof(GLOBALENTRY16)];
    LPBYTE          lpbyte;
    DWORD           vpBuff;
    DWORD           dwResult;
    BOOL            b;
    UNREFERENCED_PARAMETER(hUnused);

    if ( lpGlobalEntry->dwSize != sizeof(GLOBALENTRY) ) {
        return( FALSE );
    }

    vpBuff = GetRemoteBlock16();
    vpBuff += GN_SIZE;

    lpbyte = Args;

    // Push the flags
    (*(LPWORD)lpbyte) = wFlags;
    lpbyte += sizeof(WORD);

    // Push the pointer to the pointer to the GLOBALENTRY16 structure
    (*(LPWORD)lpbyte) = LOWORD(vpBuff);
    lpbyte += sizeof(WORD);

    (*(LPWORD)lpbyte) = HIWORD(vpBuff);
    lpbyte += sizeof(WORD);

    CopyToGlobalEntry16( lpGlobalEntry, (LPGLOBALENTRY16)lpbyte );

    b = CallRemote16(
            hProcess,
            "TOOLHELP.DLL",
            "GlobalNext",
            Args,
            GN_SIZE,
            sizeof(Args),
            &dwResult,
            lpEventProc,
            lpData );

    if ( !b ) {
        return( FALSE );
    }
    CopyFromGlobalEntry16( lpGlobalEntry, (LPGLOBALENTRY16)lpbyte );

    return( (BOOL)((WORD)dwResult) );
}

VOID CopyToModuleEntry16(
    LPMODULEENTRY   lpModuleEntry,
    LPMODULEENTRY16 lpModuleEntry16
) {
    if ( lpModuleEntry == NULL || lpModuleEntry16 == NULL ) {
        return;
    }
    lpModuleEntry16->dwSize  = sizeof(MODULEENTRY16);
    lpModuleEntry16->hModule = (WORD)lpModuleEntry->hModule;
    lpModuleEntry16->wcUsage = lpModuleEntry->wcUsage;
    lpModuleEntry16->wNext   = lpModuleEntry->wNext;
    strncpy( lpModuleEntry16->szModule, lpModuleEntry->szModule, MAX_MODULE_NAME );
    strncpy( lpModuleEntry16->szExePath, lpModuleEntry->szExePath, MAX_PATH16 );
}

VOID CopyFromModuleEntry16(
    LPMODULEENTRY   lpModuleEntry,
    LPMODULEENTRY16 lpModuleEntry16
) {
    if ( lpModuleEntry == NULL || lpModuleEntry16 == NULL ) {
        return;
    }
    lpModuleEntry->dwSize   = sizeof(MODULEENTRY);
    lpModuleEntry->hModule  = (HANDLE)lpModuleEntry16->hModule;
    lpModuleEntry->wcUsage  = lpModuleEntry16->wcUsage;
    lpModuleEntry->wNext    = lpModuleEntry16->wNext;
    strncpy( lpModuleEntry->szModule, lpModuleEntry16->szModule, MAX_MODULE_NAME );
    strncpy( lpModuleEntry->szExePath, lpModuleEntry16->szExePath, MAX_PATH16 );
}

BOOL
WINAPI
VDMModuleFirst(
    HANDLE          hProcess,
    HANDLE          hUnused,
    LPMODULEENTRY   lpModuleEntry,
    DEBUGEVENTPROC  lpEventProc,
    LPVOID          lpData
) {
#define MF_SIZE 4           // 4 bytes are passed to ModuleFirst
    BYTE            Args[GF_SIZE+sizeof(MODULEENTRY16)];
    LPBYTE          lpbyte;
    DWORD           vpBuff;
    DWORD           dwResult;
    BOOL            b;
    UNREFERENCED_PARAMETER(hUnused);

    if ( lpModuleEntry->dwSize != sizeof(MODULEENTRY) ) {
        return( FALSE );
    }

    vpBuff = GetRemoteBlock16();
    vpBuff += MF_SIZE;

    lpbyte = Args;

    // Push the pointer to the pointer to the MODULEENTRY16 structure
    (*(LPWORD)lpbyte) = LOWORD(vpBuff);
    lpbyte += sizeof(WORD);

    (*(LPWORD)lpbyte) = HIWORD(vpBuff);
    lpbyte += sizeof(WORD);

    CopyToModuleEntry16( lpModuleEntry, (LPMODULEENTRY16)lpbyte );

    b = CallRemote16(
            hProcess,
            "TOOLHELP.DLL",
            "ModuleFirst",
            Args,
            MF_SIZE,
            sizeof(Args),
            &dwResult,
            lpEventProc,
            lpData );

    if ( !b ) {
        return( FALSE );
    }
    CopyFromModuleEntry16( lpModuleEntry, (LPMODULEENTRY16)lpbyte );

    return( (BOOL)((WORD)dwResult) );
}

BOOL
WINAPI
VDMModuleNext(
    HANDLE          hProcess,
    HANDLE          hUnused,
    LPMODULEENTRY   lpModuleEntry,
    DEBUGEVENTPROC  lpEventProc,
    LPVOID          lpData
) {
#define MN_SIZE 4           // 4 bytes are passed to ModuleNext
    BYTE            Args[GF_SIZE+sizeof(MODULEENTRY16)];
    LPBYTE          lpbyte;
    DWORD           vpBuff;
    DWORD           dwResult;
    BOOL            b;
    UNREFERENCED_PARAMETER(hUnused);

    if ( lpModuleEntry->dwSize != sizeof(MODULEENTRY) ) {
        return( FALSE );
    }

    vpBuff = GetRemoteBlock16();
    vpBuff += MN_SIZE;

    lpbyte = Args;

    // Push the pointer to the pointer to the MODULEENTRY16 structure
    (*(LPWORD)lpbyte) = LOWORD(vpBuff);
    lpbyte += sizeof(WORD);

    (*(LPWORD)lpbyte) = HIWORD(vpBuff);
    lpbyte += sizeof(WORD);

    CopyToModuleEntry16( lpModuleEntry, (LPMODULEENTRY16)lpbyte );

    b = CallRemote16(
            hProcess,
            "TOOLHELP.DLL",
            "ModuleNext",
            Args,
            MN_SIZE,
            sizeof(Args),
            &dwResult,
            lpEventProc,
            lpData );

    if ( !b ) {
        return( FALSE );
    }
    CopyFromModuleEntry16( lpModuleEntry, (LPMODULEENTRY16)lpbyte );

    return( (BOOL)((WORD)dwResult) );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\vdmdbg\vdmdbg.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    vdmdbg.c

Abstract:

    This module contains the debugging support needed to debug
    16-bit VDM applications

Author:

    Bob Day      (bobday) 16-Sep-1992 Wrote it

Revision History:

    Neil Sandlin (neilsa) 1-Mar-1997 Enhanced it

--*/

#include <precomp.h>
#pragma hdrstop

WORD LastEventFlags;

//----------------------------------------------------------------------------
// VDMGetThreadSelectorEntry()
//
//   Public interface to the InternalGetThreadSelectorEntry, needed because
//   that routine requires the process handle.
//
//----------------------------------------------------------------------------
BOOL
WINAPI
VDMGetThreadSelectorEntry(
    HANDLE  hProcess,
    HANDLE  hUnused,
    WORD    wSelector,
    LPVDMLDT_ENTRY lpSelectorEntry
) {
    BOOL    fResult;
    UNREFERENCED_PARAMETER(hUnused);

    fResult = InternalGetThreadSelectorEntry(
                    hProcess,
                    wSelector,
                    lpSelectorEntry );

    return( fResult );
}


//----------------------------------------------------------------------------
// VDMGetPointer()
//
//   Public interface to the InternalGetPointer, needed because that
//   routine requires the process handle.
//
//----------------------------------------------------------------------------
ULONG
WINAPI
VDMGetPointer(
    HANDLE  hProcess,
    HANDLE  hUnused,
    WORD    wSelector,
    DWORD   dwOffset,
    BOOL    fProtMode
) {
    ULONG   ulResult;
    UNREFERENCED_PARAMETER(hUnused);

    ulResult = InternalGetPointer(
                hProcess,
                wSelector,
                dwOffset,
                fProtMode );

    return( ulResult );
}

//
// Obselete functions
//
BOOL
WINAPI
VDMGetThreadContext(
    LPDEBUG_EVENT lpDebugEvent, 
    LPVDMCONTEXT    lpVDMContext)
{
    HANDLE          hProcess;
    BOOL bReturn;
    
    hProcess = OpenProcess( PROCESS_VM_READ, FALSE, lpDebugEvent->dwProcessId );

    bReturn = VDMGetContext(hProcess, NULL, lpVDMContext);
    
    CloseHandle( hProcess );
    return bReturn;
}

BOOL WINAPI VDMSetThreadContext(
    LPDEBUG_EVENT lpDebugEvent, 
    LPVDMCONTEXT    lpVDMContext)
{
    HANDLE          hProcess;
    BOOL bReturn;
    
    hProcess = OpenProcess( PROCESS_VM_READ, FALSE, lpDebugEvent->dwProcessId );

    bReturn = VDMSetContext(hProcess, NULL, lpVDMContext);
    
    CloseHandle( hProcess );
    return bReturn;
}

//----------------------------------------------------------------------------
// VDMGetContext()
//
//   Interface to get the simulated context.  The same functionality as
//   GetThreadContext except that it happens on the simulated 16-bit context,
//   rather than the 32-bit context.
//
//----------------------------------------------------------------------------
BOOL
WINAPI
VDMGetContext(
    HANDLE          hProcess,
    HANDLE          hThread,
    LPVDMCONTEXT    lpVDMContext
) {
    VDMCONTEXT      vcContext;
    BOOL            b;
    DWORD           lpNumberOfBytesRead;
    int             i;
    BOOL            bUseVDMContext = TRUE;

#ifdef _X86_
    if (hThread) {
        vcContext.ContextFlags = lpVDMContext->ContextFlags;
        if (!GetThreadContext(hThread, (CONTEXT*)&vcContext)) {
            return FALSE;
        }
        if ((vcContext.EFlags & V86FLAGS_V86) || (vcContext.SegCs != 0x1b)) {
            bUseVDMContext = FALSE;
        }
    }
#endif 

    if (bUseVDMContext) {
        b = ReadProcessMemory(hProcess,
                              lpVdmContext,
                              &vcContext,
                              sizeof(vcContext),
                              &lpNumberOfBytesRead
                              );
        if ( !b || lpNumberOfBytesRead != sizeof(vcContext) ) {
            return( FALSE );
        }
    }

#ifdef _X86_
    if ((lpVDMContext->ContextFlags & VDMCONTEXT_CONTROL) == VDMCONTEXT_CONTROL) {

        //
        // Set registers ebp, eip, cs, eflag, esp and ss.
        //

        lpVDMContext->Ebp    = vcContext.Ebp;
        lpVDMContext->Eip    = vcContext.Eip;
        lpVDMContext->SegCs  = vcContext.SegCs;
        lpVDMContext->EFlags = vcContext.EFlags;
        lpVDMContext->SegSs  = vcContext.SegSs;
        lpVDMContext->Esp    = vcContext.Esp;
    }

    //
    // Set segment register contents if specified.
    //

    if ((lpVDMContext->ContextFlags & VDMCONTEXT_SEGMENTS) == VDMCONTEXT_SEGMENTS) {

        //
        // Set segment registers gs, fs, es, ds.
        //
        // These values are junk most of the time, but useful
        // for debugging under certain conditions.  Therefore,
        // we report whatever was in the frame.
        //

        lpVDMContext->SegGs = vcContext.SegGs;
        lpVDMContext->SegFs = vcContext.SegFs;
        lpVDMContext->SegEs = vcContext.SegEs;
        lpVDMContext->SegDs = vcContext.SegDs;
    }

    //
    // Set integer register contents if specified.
    //

    if ((lpVDMContext->ContextFlags & VDMCONTEXT_INTEGER) == VDMCONTEXT_INTEGER) {

        //
        // Set integer registers edi, esi, ebx, edx, ecx, eax
        //

        lpVDMContext->Edi = vcContext.Edi;
        lpVDMContext->Esi = vcContext.Esi;
        lpVDMContext->Ebx = vcContext.Ebx;
        lpVDMContext->Ecx = vcContext.Ecx;
        lpVDMContext->Edx = vcContext.Edx;
        lpVDMContext->Eax = vcContext.Eax;
    }

    //
    // Fetch floating register contents if requested, and type of target
    // is user.  (system frames have no fp state, so ignore request)
    //

    if ( (lpVDMContext->ContextFlags & VDMCONTEXT_FLOATING_POINT) ==
          VDMCONTEXT_FLOATING_POINT ) {

        lpVDMContext->FloatSave.ControlWord   = vcContext.FloatSave.ControlWord;
        lpVDMContext->FloatSave.StatusWord    = vcContext.FloatSave.StatusWord;
        lpVDMContext->FloatSave.TagWord       = vcContext.FloatSave.TagWord;
        lpVDMContext->FloatSave.ErrorOffset   = vcContext.FloatSave.ErrorOffset;
        lpVDMContext->FloatSave.ErrorSelector = vcContext.FloatSave.ErrorSelector;
        lpVDMContext->FloatSave.DataOffset    = vcContext.FloatSave.DataOffset;
        lpVDMContext->FloatSave.DataSelector  = vcContext.FloatSave.DataSelector;
        lpVDMContext->FloatSave.Cr0NpxState   = vcContext.FloatSave.Cr0NpxState;
        for (i = 0; i < SIZE_OF_80387_REGISTERS; i++) {
            lpVDMContext->FloatSave.RegisterArea[i] = vcContext.FloatSave.RegisterArea[i];
        }
    }

    //
    // Fetch Dr register contents if requested.  Values may be trash.
    //

    if ((lpVDMContext->ContextFlags & VDMCONTEXT_DEBUG_REGISTERS) ==
        VDMCONTEXT_DEBUG_REGISTERS) {

        lpVDMContext->Dr0 = vcContext.Dr0;
        lpVDMContext->Dr1 = vcContext.Dr1;
        lpVDMContext->Dr2 = vcContext.Dr2;
        lpVDMContext->Dr3 = vcContext.Dr3;
        lpVDMContext->Dr6 = vcContext.Dr6;
        lpVDMContext->Dr7 = vcContext.Dr7;
    }

#else

    {
        NT_CPU_INFO nt_cpu_info;
        BOOL        bInNano;
        ULONG       UMask;

        b = ReadProcessMemory(hProcess,
                              lpNtCpuInfo,
                              &nt_cpu_info,
                              sizeof(NT_CPU_INFO),
                              &lpNumberOfBytesRead
                              );
        if ( !b || lpNumberOfBytesRead != sizeof(NT_CPU_INFO) ) {
            return( FALSE );
        }

        
        bInNano = ReadDword(hProcess, nt_cpu_info.in_nano_cpu);
        UMask   = ReadDword(hProcess, nt_cpu_info.universe);

        lpVDMContext->Eax = GetRegValue(hProcess, nt_cpu_info.eax, bInNano, UMask);
        lpVDMContext->Ecx = GetRegValue(hProcess, nt_cpu_info.ecx, bInNano, UMask);
        lpVDMContext->Edx = GetRegValue(hProcess, nt_cpu_info.edx, bInNano, UMask);
        lpVDMContext->Ebx = GetRegValue(hProcess, nt_cpu_info.ebx, bInNano, UMask);
        lpVDMContext->Ebp = GetRegValue(hProcess, nt_cpu_info.ebp, bInNano, UMask);
        lpVDMContext->Esi = GetRegValue(hProcess, nt_cpu_info.esi, bInNano, UMask);
        lpVDMContext->Edi = GetRegValue(hProcess, nt_cpu_info.edi, bInNano, UMask);

        lpVDMContext->Esp    = GetEspValue(hProcess, nt_cpu_info, bInNano);

        //
        // nt_cpu_info.flags isn't very much use, because several of the
        // flags values are not kept in memory, but computed each time.
        // The emulator doesn't supply us with the right value, so we
        // try to get it from the code in ntvdmd.dll
        //

        lpVDMContext->EFlags = vcContext.EFlags;

        //
        // On risc platforms, we don't run in V86 mode, we run in REAL mode.
        // So the widespread usage of testing the V86 mode bit in EFLAGS
        // would not correctly determine the address mode. Since there is
        // no more room in the VDM context structure, the simplest thing
        // to do is simply pretend to be in V86 mode when we are in REAL mode.
        //
        if (ReadDword(hProcess, nt_cpu_info.cr0) & 1) {
            lpVDMContext->EFlags |= V86FLAGS_V86;
        }

        lpVDMContext->Eip    = ReadDword(hProcess, nt_cpu_info.eip);

        lpVDMContext->SegEs = ReadWord(hProcess, nt_cpu_info.es);
        lpVDMContext->SegCs = ReadWord(hProcess, nt_cpu_info.cs);
        lpVDMContext->SegSs = ReadWord(hProcess, nt_cpu_info.ss);
        lpVDMContext->SegDs = ReadWord(hProcess, nt_cpu_info.ds);
        lpVDMContext->SegFs = ReadWord(hProcess, nt_cpu_info.fs);
        lpVDMContext->SegGs = ReadWord(hProcess, nt_cpu_info.gs);

    }
#endif

    return( TRUE );
}

//----------------------------------------------------------------------------
// VDMSetContext()
//
//   Interface to set the simulated context.  Similar in most respects to
//   the SetThreadContext API supported by Win NT.  Only differences are
//   in the bits which must be "sanitized".
//
//----------------------------------------------------------------------------
BOOL
WINAPI
VDMSetContext(
    HANDLE          hProcess,
    HANDLE          hThread,
    LPVDMCONTEXT    lpVDMContext
) {
    VDMINTERNALINFO viInfo;
    VDMCONTEXT      vcContext;
    BOOL            b;
    DWORD           lpNumberOfBytes;
    INT             i;
    BOOL            bUseVDMContext = TRUE;

#ifdef _X86_
    if (hThread) {
        if (!GetThreadContext(hThread, (CONTEXT*)&vcContext)) {
            return FALSE;
        }
        if ((vcContext.EFlags & V86FLAGS_V86) || (vcContext.SegCs != 0x1b)) {
            bUseVDMContext = FALSE;
        }
    }
#endif

    if (bUseVDMContext) {
        b = ReadProcessMemory(hProcess,
                              lpVdmContext,
                              &vcContext,
                              sizeof(vcContext),
                              &lpNumberOfBytes
                              );
        if ( !b || lpNumberOfBytes != sizeof(vcContext) ) {
            return( FALSE );
        }
    }

    if ((lpVDMContext->ContextFlags & VDMCONTEXT_CONTROL) == VDMCONTEXT_CONTROL) {

        //
        // Set registers ebp, eip, cs, eflag, esp and ss.
        //

        vcContext.Ebp    = lpVDMContext->Ebp;
        vcContext.Eip    = lpVDMContext->Eip;

        //
        // Don't allow them to modify the mode bit.
        //
        // Only allow these bits to get set:  01100000110111110111
        //    V86FLAGS_CARRY        0x00001
        //    V86FLAGS_?            0x00002
        //    V86FLAGS_PARITY       0x00004
        //    V86FLAGS_AUXCARRY     0x00010
        //    V86FLAGS_ZERO         0x00040
        //    V86FLAGS_SIGN         0x00080
        //    V86FLAGS_TRACE        0x00100
        //    V86FLAGS_INTERRUPT    0x00200
        //    V86FLAGS_DIRECTION    0x00400
        //    V86FLAGS_OVERFLOW     0x00800
        //    V86FLAGS_RESUME       0x10000
        //    V86FLAGS_VM86         0x20000
        //    V86FLAGS_ALIGNMENT    0x40000
        //
        // Commonly flags will be 0x10246
        //
        if ( vcContext.EFlags & V86FLAGS_V86 ) {
            vcContext.EFlags = V86FLAGS_V86 | (lpVDMContext->EFlags &
               ( V86FLAGS_CARRY
               | 0x0002
               | V86FLAGS_PARITY
               | V86FLAGS_AUXCARRY
               | V86FLAGS_ZERO
               | V86FLAGS_SIGN
               | V86FLAGS_TRACE
               | V86FLAGS_INTERRUPT
               | V86FLAGS_DIRECTION
               | V86FLAGS_OVERFLOW
               | V86FLAGS_RESUME
               | V86FLAGS_ALIGNMENT
               | V86FLAGS_IOPL
               ));
        } else {
            vcContext.EFlags = ~V86FLAGS_V86 & (lpVDMContext->EFlags &
               ( V86FLAGS_CARRY
               | 0x0002
               | V86FLAGS_PARITY
               | V86FLAGS_AUXCARRY
               | V86FLAGS_ZERO
               | V86FLAGS_SIGN
               | V86FLAGS_TRACE
               | V86FLAGS_INTERRUPT
               | V86FLAGS_DIRECTION
               | V86FLAGS_OVERFLOW
               | V86FLAGS_RESUME
               | V86FLAGS_ALIGNMENT
               | V86FLAGS_IOPL
               ));
        }

        //
        // CS might only be allowable as a ring 3 selector.
        //
        if ( vcContext.EFlags & V86FLAGS_V86 ) {
            vcContext.SegCs  = lpVDMContext->SegCs;
        } else {
#ifdef i386
            vcContext.SegCs  = lpVDMContext->SegCs | 0x0003;
#else
            vcContext.SegCs  = lpVDMContext->SegCs;
#endif
        }

        vcContext.SegSs  = lpVDMContext->SegSs;
        vcContext.Esp    = lpVDMContext->Esp;
    }

    //
    // Set segment register contents if specified.
    //

    if ((lpVDMContext->ContextFlags & VDMCONTEXT_SEGMENTS) == VDMCONTEXT_SEGMENTS) {

        //
        // Set segment registers gs, fs, es, ds.
        //
        vcContext.SegGs = lpVDMContext->SegGs;
        vcContext.SegFs = lpVDMContext->SegFs;
        vcContext.SegEs = lpVDMContext->SegEs;
        vcContext.SegDs = lpVDMContext->SegDs;
    }

    //
    // Set integer register contents if specified.
    //

    if ((lpVDMContext->ContextFlags & VDMCONTEXT_INTEGER) == VDMCONTEXT_INTEGER) {

        //
        // Set integer registers edi, esi, ebx, edx, ecx, eax
        //

        vcContext.Edi = lpVDMContext->Edi;
        vcContext.Esi = lpVDMContext->Esi;
        vcContext.Ebx = lpVDMContext->Ebx;
        vcContext.Ecx = lpVDMContext->Ecx;
        vcContext.Edx = lpVDMContext->Edx;
        vcContext.Eax = lpVDMContext->Eax;
    }

    //
    // Fetch floating register contents if requested, and type of target
    // is user.
    //

    if ( (lpVDMContext->ContextFlags & VDMCONTEXT_FLOATING_POINT) ==
          VDMCONTEXT_FLOATING_POINT ) {

        vcContext.FloatSave.ControlWord   = lpVDMContext->FloatSave.ControlWord;
        vcContext.FloatSave.StatusWord    = lpVDMContext->FloatSave.StatusWord;
        vcContext.FloatSave.TagWord       = lpVDMContext->FloatSave.TagWord;
        vcContext.FloatSave.ErrorOffset   = lpVDMContext->FloatSave.ErrorOffset;
        vcContext.FloatSave.ErrorSelector = lpVDMContext->FloatSave.ErrorSelector;
        vcContext.FloatSave.DataOffset    = lpVDMContext->FloatSave.DataOffset;
        vcContext.FloatSave.DataSelector  = lpVDMContext->FloatSave.DataSelector;
        vcContext.FloatSave.Cr0NpxState   = lpVDMContext->FloatSave.Cr0NpxState;
        for (i = 0; i < SIZE_OF_80387_REGISTERS; i++) {
            vcContext.FloatSave.RegisterArea[i] = lpVDMContext->FloatSave.RegisterArea[i];
        }
    }

    //
    // Fetch Dr register contents if requested.  Values may be trash.
    //

    if ((lpVDMContext->ContextFlags & VDMCONTEXT_DEBUG_REGISTERS) ==
        VDMCONTEXT_DEBUG_REGISTERS) {

        vcContext.Dr0 = lpVDMContext->Dr0;
        vcContext.Dr1 = lpVDMContext->Dr1;
        vcContext.Dr2 = lpVDMContext->Dr2;
        vcContext.Dr3 = lpVDMContext->Dr3;
        vcContext.Dr6 = lpVDMContext->Dr6;
        vcContext.Dr7 = lpVDMContext->Dr7;
    }

#ifdef _X86_
    if (!bUseVDMContext) {
        if (!SetThreadContext(hThread, (CONTEXT*)&vcContext)) {
            return FALSE;
        }
    }
#endif

    b = WriteProcessMemory(
            hProcess,
            lpVdmContext,
            &vcContext,
            sizeof(vcContext),
            &lpNumberOfBytes
            );

    if ( !b || lpNumberOfBytes != sizeof(vcContext) ) {
        return( FALSE );
    }

    return( TRUE );
}

//----------------------------------------------------------------------------
// VDMBreakThread()
//
//   Interface to interrupt a thread while it is running without any break-
//   points.  An ideal debugger would have this feature.  Since it is hard
//   to implement, we will be doing it later.
//
//----------------------------------------------------------------------------
BOOL
WINAPI
VDMBreakThread(
    HANDLE      hProcess,
    HANDLE      hThread
) {
    return( FALSE );
}

//----------------------------------------------------------------------------
// VDMProcessException()
//
//   This function acts as a filter of debug events.  Most debug events
//   should be ignored by the debugger (because they don't have the context
//   record pointer or the internal info structure setup.  Those events
//   cause this function to return FALSE, which tells the debugger to just
//   blindly continue the exception.  When the function does return TRUE,
//   the debugger should look at the exception code to determine what to
//   do (and all the the structures have been set up properly to deal with
//   calls to the other APIs).
//
//----------------------------------------------------------------------------
BOOL
WINAPI
VDMProcessException(
    LPDEBUG_EVENT lpDebugEvent
) {
    LPDWORD         lpdw;
    int             mode;
    BOOL            fResult = TRUE;

    lpdw = &(lpDebugEvent->u.Exception.ExceptionRecord.ExceptionInformation[0]);

    mode = LOWORD(lpdw[0]);
    LastEventFlags = HIWORD(lpdw[0]);

    switch( mode ) {
        case DBG_SEGLOAD:
        case DBG_SEGMOVE:
        case DBG_SEGFREE:
        case DBG_MODLOAD:
        case DBG_MODFREE:
            ProcessSegmentNotification(lpDebugEvent);
            fResult = FALSE;
            break;
            
        case DBG_BREAK:
            ProcessBPNotification(lpDebugEvent);
            break;            
    }

    ProcessInitNotification(lpDebugEvent);

    return( fResult );
}


//----------------------------------------------------------------------------
// VDMGetSelectorModule()
//
//   Interface to determine the module and segment associated with a given
//   selector.  This is useful during debugging to associate symbols with
//   code and data segments.  The symbol lookup should be done by the
//   debugger, given the module and segment number.
//
//   This code was adapted from the Win 3.1 ToolHelp DLL
//
//----------------------------------------------------------------------------
BOOL
WINAPI
VDMGetSelectorModule(
    HANDLE          hProcess,
    HANDLE          hUnused,
    WORD            wSelector,
    PUINT           lpSegmentNumber,
    LPSTR           lpModuleName,
    UINT            nNameSize,
    LPSTR           lpModulePath,
    UINT            nPathSize
) {
    BOOL            b;
    DWORD           lpNumberOfBytes;
    BOOL            fResult;
    DWORD           lphMaster;
    DWORD           lphMasterLen;
    DWORD           lphMasterStart;
    DWORD           lpOwner;
    DWORD           lpThisModuleResTab;
    DWORD           lpThisModuleName;
    DWORD           lpPath;
    DWORD           lpThisModulecSeg;
    DWORD           lpThisModuleSegTab;
    DWORD           lpThisSegHandle;
    WORD            wMaster;
    WORD            wMasterLen;
    DWORD           dwMasterStart;
    DWORD           dwArenaOffset;
    WORD            wArenaSlot;
    DWORD           lpArena;
    WORD            wModHandle;
    WORD            wResTab;
    UCHAR           cLength;
    WORD            wPathOffset;
    UCHAR           cPath;
    WORD            cSeg;
    WORD            iSeg;
    WORD            wSegTab;
    WORD            wHandle;
//    CHAR            chName[MAX_MODULE_NAME_LENGTH];
//    CHAR            chPath[MAX_MODULE_PATH_LENGTH];
    UNREFERENCED_PARAMETER(hUnused);

    if ( lpModuleName != NULL ) *lpModuleName = '\0';
    if ( lpModulePath != NULL ) *lpModulePath = '\0';
    if ( lpSegmentNumber != NULL ) *lpSegmentNumber = 0;

    fResult = FALSE;

#if 0
    if ( wKernelSeg == 0 ) {
        return( FALSE );
    }

    // Read out the master heap selector

    lphMaster = InternalGetPointer(
                    hProcess,
                    wKernelSeg,
                    dwOffsetTHHOOK + TOOL_HMASTER,  // To hGlobalHeap
                    TRUE );
    if ( lphMaster == (DWORD)NULL ) goto punt;

    b = ReadProcessMemory(
            hProcess,
            (LPVOID)lphMaster,
            &wMaster,
            sizeof(wMaster),
            &lpNumberOfBytes
            );
    if ( !b || lpNumberOfBytes != sizeof(wMaster) ) goto punt;

    wMaster |= 1;          // Convert to selector

    // Read out the master heap selector length

    lphMasterLen = InternalGetPointer(
                    hProcess,
                    wKernelSeg,
                    dwOffsetTHHOOK + TOOL_HMASTLEN, // To SelTableLen
                    TRUE );
    if ( lphMasterLen == (DWORD)NULL ) goto punt;

    b = ReadProcessMemory(
            hProcess,
            (LPVOID)lphMasterLen,
            &wMasterLen,
            sizeof(wMasterLen),
            &lpNumberOfBytes
            );
    if ( !b || lpNumberOfBytes != sizeof(wMasterLen) ) goto punt;

    // Read out the master heap selector start

    lphMasterStart = InternalGetPointer(
                    hProcess,
                    wKernelSeg,
                    dwOffsetTHHOOK + TOOL_HMASTSTART,   // To SelTableStart
                    TRUE );
    if ( lphMasterStart == (DWORD)NULL ) goto punt;

    b = ReadProcessMemory(
            hProcess,
            (LPVOID)lphMasterStart,
            &dwMasterStart,
            sizeof(dwMasterStart),
            &lpNumberOfBytes
            );
    if ( !b || lpNumberOfBytes != sizeof(dwMasterStart) ) goto punt;

    // Now make sure the selector provided is in the right range

    if ( fKernel386 ) {

        // 386 kernel?
        wArenaSlot = (WORD)(wSelector & 0xFFF8);   // Mask low 3 bits

        wArenaSlot = wArenaSlot >> 1;       // Sel/8*4

        if ( (WORD)wArenaSlot > wMasterLen ) goto punt;   // Out of range

        wArenaSlot += (WORD)dwMasterStart;

        // Ok, Now read out the area header offset

        dwArenaOffset = (DWORD)0;               // Default to 0

        lpArena = InternalGetPointer(
                        hProcess,
                        wMaster,
                        wArenaSlot,
                        TRUE );
        if ( lpArena == (DWORD)NULL ) goto punt;

        // 386 Kernel?
        b = ReadProcessMemory(
                hProcess,
                (LPVOID)lpArena,
                &dwArenaOffset,
                sizeof(dwArenaOffset),
                &lpNumberOfBytes
                );
        if ( !b || lpNumberOfBytes != sizeof(dwArenaOffset) ) goto punt;

        // Read out the owner member

        lpOwner = InternalGetPointer(
                        hProcess,
                        wMaster,
                        dwArenaOffset+GA_OWNER386,
                        TRUE );
        if ( lpOwner == (DWORD)NULL ) goto punt;

    } else {
        lpOwner = InternalGetPointer(
                        hProcess,
                        wSelector,
                        0,
                        TRUE );
        if ( lpOwner == (DWORD)NULL ) goto punt;

        lpOwner -= GA_SIZE;
        lpOwner += GA_OWNER;
    }

    b = ReadProcessMemory(
            hProcess,
            (LPVOID)lpOwner,
            &wModHandle,
            sizeof(wModHandle),
            &lpNumberOfBytes
            );
    if ( !b || lpNumberOfBytes != sizeof(wModHandle) ) goto punt;

    // Now read out the owners module name

    // Name is the first name in the resident names table

    lpThisModuleResTab = InternalGetPointer(
                        hProcess,
                        wModHandle,
                        NE_RESTAB,
                        TRUE );
    if ( lpThisModuleResTab == (DWORD)NULL ) goto punt;

    b = ReadProcessMemory(
            hProcess,
            (LPVOID)lpThisModuleResTab,
            &wResTab,
            sizeof(wResTab),
            &lpNumberOfBytes
            );
    if ( !b || lpNumberOfBytes != sizeof(wResTab) ) goto punt;

    // Get the 1st byte of the resident names table (1st byte of module name)

    lpThisModuleName = InternalGetPointer(
                        hProcess,
                        wModHandle,
                        wResTab,
                        TRUE );
    if ( lpThisModuleName == (DWORD)NULL ) goto punt;

    // PASCAL string (1st byte is length), read the byte.

    b = ReadProcessMemory(
            hProcess,
            (LPVOID)lpThisModuleName,
            &cLength,
            sizeof(cLength),
            &lpNumberOfBytes
            );
    if ( !b || lpNumberOfBytes != sizeof(cLength) ) goto punt;

    if ( cLength > MAX_MODULE_NAME_LENGTH ) goto punt;

    // Now go read the text of the name

    lpThisModuleName += 1;

    b = ReadProcessMemory(
            hProcess,
            (LPVOID)lpThisModuleName,
            &chName,
            cLength,
            &lpNumberOfBytes
            );
    if ( !b || lpNumberOfBytes != (DWORD)cLength ) goto punt;

    chName[cLength] = '\0';     // Nul terminate it

    // Grab out the path name too!

    lpPath = InternalGetPointer(
                    hProcess,
                    wModHandle,
                    NE_PATHOFFSET,
                    TRUE );
    if ( lpPath == (DWORD)NULL ) goto punt;

    b = ReadProcessMemory(
            hProcess,
            (LPVOID)lpPath,
            &wPathOffset,
            sizeof(wPathOffset),
            &lpNumberOfBytes
            );
    if ( !b || lpNumberOfBytes != sizeof(wPathOffset) ) goto punt;

    // Get the 1st byte of the path name

    lpThisModuleName = InternalGetPointer(
                        hProcess,
                        wModHandle,
                        wPathOffset,
                        TRUE );
    if ( lpThisModuleName == (DWORD)NULL ) goto punt;

    // PASCAL string (1st byte is length), read the byte.

    b = ReadProcessMemory(
            hProcess,
            (LPVOID)lpThisModuleName,
            &cPath,
            sizeof(cPath),
            &lpNumberOfBytes
            );
    if ( !b || lpNumberOfBytes != sizeof(cPath) ) goto punt;

    if ( cPath > MAX_MODULE_NAME_LENGTH ) goto punt;

    lpThisModuleName += 8;          // 1st 8 characters are ignored
    cPath -= 8;

    // Now go read the text of the name

    b = ReadProcessMemory(
            hProcess,
            (LPVOID)lpThisModuleName,
            &chPath,
            cPath,
            &lpNumberOfBytes
            );
    if ( !b || lpNumberOfBytes != (DWORD)cPath ) goto punt;

    chPath[cPath] = '\0';     // Nul terminate it

    // Ok, we found the module we need, now grab the right selector for the
    // segment number passed in.

    lpThisModulecSeg = InternalGetPointer(
                        hProcess,
                        wModHandle,
                        NE_CSEG,
                        TRUE );
    if ( lpThisModulecSeg == (DWORD)NULL ) goto punt;

    b = ReadProcessMemory(
            hProcess,
            (LPVOID)lpThisModulecSeg,
            &cSeg,
            sizeof(cSeg),
            &lpNumberOfBytes
            );
    if ( !b || lpNumberOfBytes != sizeof(cSeg) ) goto punt;

    // Read the segment table pointer for this module

    lpThisModuleSegTab = InternalGetPointer(
                        hProcess,
                        wModHandle,
                        NE_SEGTAB,
                        TRUE );
    if ( lpThisModuleSegTab == (DWORD)NULL ) goto punt;

    b = ReadProcessMemory(
            hProcess,
            (LPVOID)lpThisModuleSegTab,
            &wSegTab,
            sizeof(wSegTab),
            &lpNumberOfBytes
            );
    if ( !b || lpNumberOfBytes != sizeof(wSegTab) ) goto punt;

    // Loop through all of the segments for this module trying to find
    // one with the right handle.

    iSeg = 0;
    wSelector &= 0xFFF8;

    while ( iSeg < cSeg ) {

        lpThisSegHandle = InternalGetPointer(
                            hProcess,
                            wModHandle,
                            wSegTab+iSeg*NEW_SEG1_SIZE+NS_HANDLE,
                            TRUE );
        if ( lpThisSegHandle == (DWORD)NULL ) goto punt;

        b = ReadProcessMemory(
                hProcess,
                (LPVOID)lpThisSegHandle,
                &wHandle,
                sizeof(wHandle),
                &lpNumberOfBytes
                );
        if ( !b || lpNumberOfBytes != sizeof(wHandle) ) goto punt;

        wHandle &= 0xFFF8;

        if ( wHandle == (WORD)wSelector ) {
            break;
        }
        iSeg++;
    }

    if ( iSeg >= cSeg ) goto punt;      // Wasn't found at all!

    if ( lpModuleName && strlen(chName)+1 > nNameSize ) goto punt;
    if ( lpModulePath && strlen(chPath)+1 > nPathSize ) goto punt;

    if ( lpModuleName != NULL ) strcpy( lpModuleName, chName );
    if ( lpModulePath != NULL ) strcpy( lpModulePath, chPath );
    if ( lpSegmentNumber != NULL ) *lpSegmentNumber = iSeg;

    fResult = TRUE;

punt:
#endif
    return( fResult );
}

//----------------------------------------------------------------------------
// VDMGetModuleSelector()
//
//   Interface to determine the selector for a given module's segment.
//   This is useful during debugging to associate code and data segments
//   with symbols.  The symbol lookup should be done by the debugger, to
//   determine the module and segment number, which are then passed to us
//   and we determine the current selector for that module's segment.
//
//   Again, this code was adapted from the Win 3.1 ToolHelp DLL
//
//----------------------------------------------------------------------------
BOOL
WINAPI
VDMGetModuleSelector(
    HANDLE          hProcess,
    HANDLE          hUnused,
    UINT            uSegmentNumber,
    LPSTR           lpModuleName,
    LPWORD          lpSelector
) {
    BOOL            b;
    DWORD           lpNumberOfBytes;
    BOOL            fResult;
    WORD            wModHandle;
    DWORD           lpModuleHead;
    DWORD           lpThisModuleName;
    DWORD           lpThisModuleNext;
    DWORD           lpThisModuleResTab;
    DWORD           lpThisModulecSeg;
    DWORD           lpThisModuleSegTab;
    DWORD           lpThisSegHandle;
    WORD            wResTab;
    UCHAR           cLength;
    WORD            cSeg;
    WORD            wSegTab;
    WORD            wHandle;
//    CHAR            chName[MAX_MODULE_NAME_LENGTH];
    UNREFERENCED_PARAMETER(hUnused);

    *lpSelector = 0;

    fResult = FALSE;

#if 0
    if ( wKernelSeg == 0 ) {
        return( FALSE );
    }

    lpModuleHead = InternalGetPointer(
                        hProcess,
                        wKernelSeg,
                        dwOffsetTHHOOK + TOOL_HMODFIRST,
                        TRUE );
    if ( lpModuleHead == (DWORD)NULL ) goto punt;

    // lpModuleHead is a pointer into kernels data segment. It points to the
    // head of the module list (a chain of near pointers).

    b = ReadProcessMemory(
            hProcess,
            (LPVOID)lpModuleHead,
            &wModHandle,
            sizeof(wModHandle),
            &lpNumberOfBytes
            );
    if ( !b || lpNumberOfBytes != sizeof(wModHandle) ) goto punt;

    while( wModHandle != (WORD)0 ) {

        wModHandle |= 1;

        // Name is the first name in the resident names table

        lpThisModuleResTab = InternalGetPointer(
                            hProcess,
                            wModHandle,
                            NE_RESTAB,
                            TRUE );
        if ( lpThisModuleResTab == (DWORD)NULL ) goto punt;

        b = ReadProcessMemory(
                hProcess,
                (LPVOID)lpThisModuleResTab,
                &wResTab,
                sizeof(wResTab),
                &lpNumberOfBytes
                );
        if ( !b || lpNumberOfBytes != sizeof(wResTab) ) goto punt;

        // Get the 1st byte of the resident names table (1st byte of module name)

        lpThisModuleName = InternalGetPointer(
                            hProcess,
                            wModHandle,
                            wResTab,
                            TRUE );
        if ( lpThisModuleName == (DWORD)NULL ) goto punt;

        // PASCAL string (1st byte is length), read the byte.

        b = ReadProcessMemory(
                hProcess,
                (LPVOID)lpThisModuleName,
                &cLength,
                sizeof(cLength),
                &lpNumberOfBytes
                );
        if ( !b || lpNumberOfBytes != sizeof(cLength) ) goto punt;

        if ( cLength > MAX_MODULE_NAME_LENGTH ) goto punt;

        lpThisModuleName += 1;

        // Now go read the text of the name

        b = ReadProcessMemory(
                hProcess,
                (LPVOID)lpThisModuleName,
                &chName,
                cLength,
                &lpNumberOfBytes
                );
        if ( !b || lpNumberOfBytes != (DWORD)cLength ) goto punt;

        chName[cLength] = '\0';     // Nul terminate it

        if ( _stricmp(chName, lpModuleName) == 0 ) {
            // Found the name which matches!
            break;
        }

        // Move to the next module in the list.

        lpThisModuleNext = InternalGetPointer(
                            hProcess,
                            wModHandle,
                            NE_CBENTTAB,
                            TRUE );
        if ( lpThisModuleNext == (DWORD)NULL ) goto punt;

        b = ReadProcessMemory(
                hProcess,
                (LPVOID)lpThisModuleNext,
                &wModHandle,
                sizeof(wModHandle),
                &lpNumberOfBytes
                );
        if ( !b || lpNumberOfBytes != sizeof(wModHandle) ) goto punt;
    }

    if ( wModHandle == (WORD)0 ) {
        goto punt;
    }

    // Ok, we found the module we need, now grab the right selector for the
    // segment number passed in.

    lpThisModulecSeg = InternalGetPointer(
                        hProcess,
                        wModHandle,
                        NE_CSEG,
                        TRUE );
    if ( lpThisModulecSeg == (DWORD)NULL ) goto punt;

    b = ReadProcessMemory(
            hProcess,
            (LPVOID)lpThisModulecSeg,
            &cSeg,
            sizeof(cSeg),
            &lpNumberOfBytes
            );
    if ( !b || lpNumberOfBytes != sizeof(cSeg) ) goto punt;

    if ( uSegmentNumber > (DWORD)cSeg ) goto punt;

    // Read the segment table pointer for this module

    lpThisModuleSegTab = InternalGetPointer(
                        hProcess,
                        wModHandle,
                        NE_SEGTAB,
                        TRUE );
    if ( lpThisModuleSegTab == (DWORD)NULL ) goto punt;

    b = ReadProcessMemory(
            hProcess,
            (LPVOID)lpThisModuleSegTab,
            &wSegTab,
            sizeof(wSegTab),
            &lpNumberOfBytes
            );
    if ( !b || lpNumberOfBytes != sizeof(wSegTab) ) goto punt;

    lpThisSegHandle = InternalGetPointer(
                        hProcess,
                        wModHandle,
                        wSegTab+(WORD)uSegmentNumber*NEW_SEG1_SIZE+NS_HANDLE,
                        TRUE );
    if ( lpThisSegHandle == (DWORD)NULL ) goto punt;

    b = ReadProcessMemory(
            hProcess,
            (LPVOID)lpThisSegHandle,
            &wHandle,
            sizeof(wHandle),
            &lpNumberOfBytes
            );
    if ( !b || lpNumberOfBytes != sizeof(wHandle) ) goto punt;

    *lpSelector = (WORD)(wHandle | 1);

    fResult = TRUE;

punt:
#endif
    return( fResult );
}



DWORD
WINAPI
VDMGetDbgFlags(
    HANDLE hProcess
    )
{
    ULONG NtvdmState;
    ULONG VdmDbgFlags;
    BOOL b;
    DWORD lpNumberOfBytes;

    //
    // Merge in the two places where our flags are kept
    //
    b = ReadProcessMemory(hProcess, lpNtvdmState, &NtvdmState,
                          sizeof(NtvdmState), &lpNumberOfBytes);

    if ( !b || lpNumberOfBytes != sizeof(NtvdmState) ) {
        return 0;
    }

    b = ReadProcessMemory(hProcess, lpVdmDbgFlags, &VdmDbgFlags,
                          sizeof(VdmDbgFlags), &lpNumberOfBytes);

    if ( !b || lpNumberOfBytes != sizeof(VdmDbgFlags) ) {
        return 0;
    }

    return ((NtvdmState & (VDMDBG_BREAK_EXCEPTIONS | VDMDBG_BREAK_DEBUGGER)) |
            (VdmDbgFlags & ~(VDMDBG_BREAK_EXCEPTIONS | VDMDBG_BREAK_DEBUGGER)));
}

BOOL
WINAPI
VDMSetDbgFlags(
    HANDLE hProcess,
    DWORD VdmDbgFlags
    )
{
    ULONG NtvdmState;
    BOOL b;
    DWORD lpNumberOfBytes;

    //
    // The flags are spread out in two places, so split off the appropriate
    // bits and write them separately.
    //
    b = ReadProcessMemory(hProcess, lpNtvdmState, &NtvdmState,
                          sizeof(NtvdmState), &lpNumberOfBytes);

    if ( !b || lpNumberOfBytes != sizeof(NtvdmState) ) {
        return FALSE;
    }

    
    NtvdmState &= ~(VDMDBG_BREAK_EXCEPTIONS | VDMDBG_BREAK_DEBUGGER);
    NtvdmState |= VdmDbgFlags & (VDMDBG_BREAK_EXCEPTIONS | VDMDBG_BREAK_DEBUGGER);


    b = WriteProcessMemory(hProcess, lpNtvdmState, &NtvdmState,
                           sizeof(NtvdmState), &lpNumberOfBytes);

    if ( !b || lpNumberOfBytes != sizeof(NtvdmState) ) {
        return FALSE;
    }

    VdmDbgFlags &= ~(VDMDBG_BREAK_EXCEPTIONS | VDMDBG_BREAK_DEBUGGER);
    b = WriteProcessMemory(hProcess, lpVdmDbgFlags, &VdmDbgFlags,
                           sizeof(VdmDbgFlags), &lpNumberOfBytes);

    if ( !b || lpNumberOfBytes != sizeof(VdmDbgFlags) ) {
        return FALSE;
    }


    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\vdmexts\data.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    Data.c

Abstract:

    This module contains definitions for global data for the IEU and
    VDD debugging extensions

Author:

    Dave Hastings (daveh) 2-Apr-1992

Revision History:

--*/

#include <precomp.h>
#pragma hdrstop
//
// Pointers to NTSD api
//

PWINDBG_OUTPUT_ROUTINE Print;
PWINDBG_GET_EXPRESSION GetExpression;
PWINDBG_GET_SYMBOL GetSymbol;
PWINDBG_CHECK_CONTROL_C CheckCtrlC;

PWINDBG_READ_PROCESS_MEMORY_ROUTINE  ReadMem;
PWINDBG_WRITE_PROCESS_MEMORY_ROUTINE WriteMem;

PWINDBG_GET_THREAD_CONTEXT_ROUTINE     ExtGetThreadContext;
PWINDBG_SET_THREAD_CONTEXT_ROUTINE     ExtSetThreadContext;
PWINDBG_IOCTL_ROUTINE                  ExtIoctl;
PWINDBG_STACKTRACE_ROUTINE             ExtStackTrace;


HANDLE hCurrentProcess;
HANDLE hCurrentThread;
LPSTR lpArgumentString;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\vdmdbg\wow.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    wow.c

Abstract:

    This module contains the WOW vdmdbg functions


Revision History:

--*/
#include <precomp.h>
#pragma hdrstop

typedef WORD HAND16;

#define SHAREWOW_MAIN
#include <sharewow.h>


//----------------------------------------------------------------------------
// VDMKillWOW()
//
//   Interface to kill the wow sub-system.  This may not be needed and is
//   certainly not needed now.  We are going to look into fixing the
//   debugging interface so this is not necessary.
//
//----------------------------------------------------------------------------
BOOL
WINAPI
VDMKillWOW(
    VOID
) {
    return( FALSE );
}

//----------------------------------------------------------------------------
// VDMDetectWOW()
//
//   Interface to detect whether the wow sub-system has already been started.
//   This may not be needed and is certainly not needed now.  We are going
//   to look into fixing the debugging interface so this is not necessary.
//
//----------------------------------------------------------------------------
BOOL
WINAPI
VDMDetectWOW(
    VOID
) {
    return( FALSE );
}


INT
WINAPI
VDMEnumProcessWOW(
    PROCESSENUMPROC fp,
    LPARAM          lparam
) {
    LPSHAREDTASKMEM     lpstm;
    LPSHAREDPROCESS     lpsp;
    DWORD               dwOffset;
    INT                 count;
    BOOL                f;
    HANDLE              hProcess;

    /*
    ** Open the shared memory window
    */
    lpstm = LOCKSHAREWOW();
    if ( lpstm == NULL ) {
        // Wow must not be running
        return( 0 );
    }

    //
    // Now traverse through all of the processes in the
    // list, calling the callback function for each.
    //
    count = 0;
    dwOffset = lpstm->dwFirstProcess;

    while ( dwOffset != 0 ) {
        lpsp = (LPSHAREDPROCESS)((CHAR *)lpstm + dwOffset);

        if ( lpsp->dwType != SMO_PROCESS ) {
            // Some memory corruption problem
            OutputDebugString("VDMDBG: Shared memory object is not a process? (memory corruption)\n");
            return( 0 );
        }

        //
        // Make sure the process hasn't gone away because of a
        // crash or other rude shutdown that prevents cleanup.
        //

        hProcess = OpenProcess(
                       SYNCHRONIZE,
                       FALSE,
                       lpsp->dwProcessId
                       );

        if (hProcess) {

            CloseHandle(hProcess);

            count++;
            if ( fp ) {
                f = (*fp)( lpsp->dwProcessId, lpsp->dwAttributes, lparam );
                if ( f ) {
                    UNLOCKSHAREWOW();
                    return( count );
                }
            }

        } else {

            //
            // This is a ghost entry, change the process ID to zero
            // so that the next WOW started will be sure to remove
            // this entry even if the process ID is recycled.
            //

            lpsp->dwProcessId = 0;
        }

        dwOffset = lpsp->dwNextProcess;
    }

    UNLOCKSHAREWOW();
    return( count );
}


INT
WINAPI
VDMEnumTaskWOWWorker(
    DWORD           dwProcessId,
    void *          fp,
    LPARAM          lparam,
    BOOL            fEx
) {
    LPSHAREDTASKMEM     lpstm;
    LPSHAREDPROCESS     lpsp;
    LPSHAREDTASK        lpst;
    DWORD               dwOffset;
    INT                 count = 0;
    BOOL                f;

    //
    // Open the shared memory window
    //
    lpstm = LOCKSHAREWOW();
    if ( lpstm == NULL ) {
        // Wow must not be running
        return( 0 );
    }

    //
    // Now traverse through all of the processes in the
    // list, looking for the one with the proper id.
    //

    dwOffset = lpstm->dwFirstProcess;
    while ( dwOffset != 0 ) {
        lpsp = (LPSHAREDPROCESS)((CHAR *)lpstm + dwOffset);

        if ( lpsp->dwType != SMO_PROCESS ) {
            // Some memory corruption problem
            OutputDebugString("VDMDBG: shared memory object is not a process? (memory corruption)\n");
            UNLOCKSHAREWOW();
            return( 0 );
        }
        if ( lpsp->dwProcessId == dwProcessId ) {
            break;
        }
        dwOffset = lpsp->dwNextProcess;
    }

    if ( dwOffset == 0 ) {      // We must not have found this Id.
        UNLOCKSHAREWOW();
        return( 0 );
    }

    //
    // Now enumerate all of the tasks for this process
    //
    dwOffset = lpsp->dwFirstTask;
    while( dwOffset != 0 ) {
        lpst = (LPSHAREDTASK)((CHAR *)lpstm + dwOffset );

        if ( lpst->dwType != SMO_TASK ) {
            // Some memory corruption problem
            OutputDebugString("VDMDBG: shared memory object is not a task? (memory corruption)\n");
            UNLOCKSHAREWOW();
            return( 0 );
        }
        count++;
        if ( fp && lpst->hMod16 ) {
            if (fEx) {
                f = ((TASKENUMPROCEX)fp)( lpst->dwThreadId, lpst->hMod16, lpst->hTask16,
                                          lpst->szModName, lpst->szFilePath, lparam );
            } else {
                f = ((TASKENUMPROC)fp)( lpst->dwThreadId, lpst->hMod16, lpst->hTask16, lparam );
            }
            if ( f ) {
                UNLOCKSHAREWOW();
                return( count );
            }
        }
        dwOffset = lpst->dwNextTask;
    }

    UNLOCKSHAREWOW();
    return( count );
}


INT
WINAPI
VDMEnumTaskWOW(
    DWORD           dwProcessId,
    TASKENUMPROC    fp,
    LPARAM          lparam
) {
    return VDMEnumTaskWOWWorker(dwProcessId, (void *)fp, lparam, 0);
}


INT
WINAPI
VDMEnumTaskWOWEx(
    DWORD           dwProcessId,
    TASKENUMPROCEX  fp,
    LPARAM          lparam
) {
    return VDMEnumTaskWOWWorker(dwProcessId, (void *)fp, lparam, 1);
}


BOOL
WINAPI
VDMTerminateTaskWOW(
    DWORD           dwProcessId,
    WORD            htask
)
{
    BOOL                fRet = FALSE;
    LPSHAREDTASKMEM     lpstm;
    LPSHAREDPROCESS     lpsp;
    LPSHAREDTASK        lpst;
    DWORD               dwOffset;
    INT                 count;
    HANDLE              hProcess;
    HANDLE              hRemoteThread;
    DWORD               dwThreadId;

    //
    // Open the shared memory window
    //
    lpstm = LOCKSHAREWOW();
    if ( lpstm == NULL ) {
        // Wow must not be running
        return( 0 );
    }

    //
    // Now traverse through all of the processes in the
    // list, looking for the one with the proper id.
    //

    dwOffset = lpstm->dwFirstProcess;
    while ( dwOffset != 0 ) {
        lpsp = (LPSHAREDPROCESS)((CHAR *)lpstm + dwOffset);

        if ( lpsp->dwType != SMO_PROCESS ) {
            // Some memory corruption problem
            OutputDebugString("VDMDBG: shared memory object is not a process? (memory corruption)\n");
            goto UnlockReturn;
        }
        if ( lpsp->dwProcessId == dwProcessId ) {
            break;
        }
        dwOffset = lpsp->dwNextProcess;
    }

    if ( dwOffset == 0 ) {      // We must not have found this Id.
        goto UnlockReturn;
    }

    //
    // Get a handle to the process and start W32HungAppNotifyThread
    // running with htask as the parameter.
    //

    hProcess = OpenProcess(
                   PROCESS_ALL_ACCESS,
                   FALSE,
                   lpsp->dwProcessId
                   );

    if (hProcess) {

        hRemoteThread = CreateRemoteThread(
                            hProcess,
                            NULL,
                            0,
                            lpsp->pfnW32HungAppNotifyThread,
                            (LPVOID) htask,
                            0,
                            &dwThreadId
                            );

        if (hRemoteThread) {
            fRet = TRUE;
            CloseHandle(hRemoteThread);
        }

        CloseHandle(hProcess);
    }


UnlockReturn:
    UNLOCKSHAREWOW();

    return fRet;
}


BOOL
VDMStartTaskInWOW(
    DWORD           pidTarget,
    LPSTR           lpCommandLine,
    WORD            wShow
)
{
    HWND  hwnd = NULL;
    DWORD pid;
    BOOL  fRet;

    do {

        hwnd = FindWindowEx(NULL, hwnd, TEXT("WowExecClass"), NULL);

        if (hwnd) {

            pid = 0;
            GetWindowThreadProcessId(hwnd, &pid);
        }

    } while (hwnd && pid != pidTarget);


    if (hwnd && pid == pidTarget) {

#define WM_WOWEXEC_START_TASK (WM_USER+2)
        PostMessage(hwnd, WM_WOWEXEC_START_TASK, GlobalAddAtom(lpCommandLine), wShow);
        fRet = TRUE;

    } else {

        fRet = FALSE;
    }

    return fRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\vdmexts\debug.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    debug.c

Abstract:

    This file contains code to manage software breakpoints

Author:

    Neil Sandlin (neilsa) 1-Nov-1995

Revision History:

--*/

#include <precomp.h>
#pragma hdrstop
#include <dpmi.h>
#include <dbgsvc.h>
#include <dbginfo.h>
#include <stdio.h>

#define BREAKPOINT_CLEAR 1
#define BREAKPOINT_DISABLE 2
#define BREAKPOINT_ENABLE 3

#define VDMBP_ARRAY "ntvdmd!VdmBreakPoints"

VDM_BREAKPOINT VdmBPCache[MAX_VDM_BREAKPOINTS] = {0};
// BP zero is reserved for internal use
#define TEMP_BP 0

BOOL
LoadBreakPointCache(
    VOID
    )
{
    ULONG lpAddress;
    lpAddress = (*GetExpression)(VDMBP_ARRAY);

    if (!lpAddress) {
        PRINTF("Could not find symbol %s\n",VDMBP_ARRAY);
        return FALSE;
    }

    if (!READMEM((PVOID)lpAddress, &VdmBPCache, sizeof(VdmBPCache))) {
        PRINTF("Error reading BP memory\n");
        return FALSE;
    }
    return TRUE;
}

BOOL
FlushBreakPointCache(
    VOID
    )
{
    ULONG lpAddress;
    lpAddress = (*GetExpression)(VDMBP_ARRAY);

    if (!lpAddress) {
        PRINTF("Could not find symbol %s\n",VDMBP_ARRAY);
        return FALSE;
    }

    if (!WRITEMEM((PVOID)lpAddress, &VdmBPCache, sizeof(VdmBPCache))) {
        PRINTF("Error writing BP memory\n");
        return FALSE;
    }
    return TRUE;
}



BOOL
IsVdmBreakPoint(
    USHORT selector,
    ULONG offset,
    BOOL bProt,
    PULONG pBpNum,
    PUCHAR pBpData
    )
//
// Callers of this function must first call LoadBreakPointCache()
//
{
    ULONG BPNum;

    for (BPNum = 0; BPNum < MAX_VDM_BREAKPOINTS; BPNum++) {

        if ((VdmBPCache[BPNum].Flags & VDMBP_SET) &&
            (VdmBPCache[BPNum].Seg == selector)   &&
            (VdmBPCache[BPNum].Offset == offset)) {

            if ((bProt && ~(VdmBPCache[BPNum].Flags & VDMBP_V86)) ||
                (~bProt && (VdmBPCache[BPNum].Flags & VDMBP_V86))) {
                *pBpNum = BPNum;
                *pBpData = VdmBPCache[BPNum].Opcode;
                return TRUE;
            }
        }
    }
    return FALSE;
}


VOID
DisableBreakPoint(
    VDM_BREAKPOINT *pBP
    )
{
    int mode;
    ULONG lpAddress;
    BYTE byte;

    if (!(pBP->Flags & VDMBP_ENABLED)) {
        // already not enabled
        return;
    }

    pBP->Flags &= ~VDMBP_ENABLED;

    if (pBP->Flags & VDMBP_PENDING) {
        pBP->Flags &= ~VDMBP_PENDING;
        return;
    }


    if (pBP->Flags & VDMBP_V86) {
        mode = V86_MODE;
    } else {
        mode = PROT_MODE;
    }

    lpAddress = GetInfoFromSelector(pBP->Seg, mode, NULL) + GetIntelBase() + pBP->Offset;

    if (READMEM((PVOID)lpAddress, &byte, 1)) {
        if (byte == 0xcc) {
            WRITEMEM((PVOID)lpAddress, &pBP->Opcode, 1);
        }
    }

    pBP->Flags |= VDMBP_FLUSH;
    pBP->Flags &= ~VDMBP_PENDING;

#ifndef i386
    if (!InVdmPrompt()) {
        PRINTF("\n***Warning: command not issued from VDM> prompt.\nOpcode has not been flushed!\n\n");
    }
#endif
}

VOID
EnableBreakPoint(
    VDM_BREAKPOINT *pBP
    )
{
    int mode;
    ULONG lpAddress;
    BYTE byte;

    if (pBP->Flags & VDMBP_ENABLED) {
        return;
    }

    EnableDebuggerBreakpoints();

    if (pBP->Flags & VDMBP_V86) {
        mode = V86_MODE;
    } else {
        mode = PROT_MODE;
    }

    lpAddress = GetInfoFromSelector(pBP->Seg, mode, NULL) + GetIntelBase() + pBP->Offset;

    if (READMEM((PVOID)lpAddress, &byte, 1)) {
        if (byte != 0xcc) {
            static BYTE bpOp = 0xcc;

            WRITEMEM((PVOID)lpAddress, &bpOp, 1);
            pBP->Opcode = byte;
        }
    } else {

        PRINTF("Error enabling breakpoint at %04X:%08X\n", pBP->Seg, pBP->Offset);
        return;
    }

    pBP->Flags |= (VDMBP_ENABLED | VDMBP_FLUSH);
    pBP->Flags &= ~VDMBP_PENDING;

#ifndef i386
    if (!InVdmPrompt()) {
        PRINTF("\n***Warning: command not issued from VDM> prompt.\nBP has not been flushed!\n\n");
    }
#endif

}


VOID
UpdateBreakPoint(
    int Cmd
    )

{
    int BPNum;
    int count = 0;
    BOOL DoBreakPoints[MAX_VDM_BREAKPOINTS] = {FALSE};
    BOOL DoAll = FALSE;

    if (!LoadBreakPointCache()) {
        return;
    }

    while (GetNextToken()) {
        if (*lpArgumentString == '*') {
            DoAll = TRUE;
            count++;
            break;
        }

        sscanf(lpArgumentString, "%d", &BPNum);
        if (BPNum >= MAX_VDM_BREAKPOINTS) {
            PRINTF("Invalid breakpoint - %d\n", BPNum);
            return;
        }
        DoBreakPoints[BPNum] = TRUE;
        count++;
        SkipToNextWhiteSpace();
    }

    if (!count) {
        PRINTF("Please specify a breakpoint #\n");
        return;
    }


    for (BPNum=0; BPNum<MAX_VDM_BREAKPOINTS; BPNum++) {

        if (!DoBreakPoints[BPNum] && !DoAll) {
            continue;
        }

        if (!(VdmBPCache[BPNum].Flags & VDMBP_SET)) {
            continue;
        }
        switch(Cmd) {

        case BREAKPOINT_CLEAR:

            if (VdmBPCache[BPNum].Flags & VDMBP_ENABLED) {
                DisableBreakPoint(&VdmBPCache[BPNum]);
            }
            VdmBPCache[BPNum].Flags &= ~VDMBP_SET;
            break;

        case BREAKPOINT_DISABLE:

            if (VdmBPCache[BPNum].Flags & VDMBP_ENABLED) {
                DisableBreakPoint(&VdmBPCache[BPNum]);
            }
            break;

        case BREAKPOINT_ENABLE:

            if (!(VdmBPCache[BPNum].Flags & VDMBP_ENABLED)) {
                EnableBreakPoint(&VdmBPCache[BPNum]);
            }
            break;

        }
    }

    FlushBreakPointCache();
}

VOID
bc(
    CMD_ARGLIST
    )
{
    CMD_INIT();
    UpdateBreakPoint(BREAKPOINT_CLEAR);
}

VOID
bd(
    CMD_ARGLIST
    )
{
    CMD_INIT();
    UpdateBreakPoint(BREAKPOINT_DISABLE);
}

VOID
be(
    CMD_ARGLIST
    )
{
    CMD_INIT();
    UpdateBreakPoint(BREAKPOINT_ENABLE);
}


VOID
bl(
    CMD_ARGLIST
    )
{
    int BPNum;
    int mode;
    DWORD dist;
    CHAR  sym_text[255];

    CMD_INIT();

    if (!LoadBreakPointCache()) {
        return;
    }

    for (BPNum = 0; BPNum < MAX_VDM_BREAKPOINTS; BPNum++) {

        if (VdmBPCache[BPNum].Flags & VDMBP_SET) {

            PRINTF("%d %s%s%s ", BPNum,
                    (VdmBPCache[BPNum].Flags & VDMBP_ENABLED) ? "e" : "d",
                    (VdmBPCache[BPNum].Flags & VDMBP_FLUSH) ? "f" : " ",
                    (VdmBPCache[BPNum].Flags & VDMBP_PENDING) ? "p" : " ");

            if (VdmBPCache[BPNum].Flags & VDMBP_V86) {
                mode = V86_MODE;
                PRINTF("&");
            } else {
                mode = PROT_MODE;
                PRINTF("#");
            }

            PRINTF("%04X:", VdmBPCache[BPNum].Seg);

            if (VdmBPCache[BPNum].Offset > 0xffff) {
                PRINTF("%08X", VdmBPCache[BPNum].Offset);
            } else {
                PRINTF("%04X", VdmBPCache[BPNum].Offset);
            }

            PRINTF("   %04X:***", VdmBPCache[BPNum].Count);


            if (FindSymbol(VdmBPCache[BPNum].Seg, VdmBPCache[BPNum].Offset,
                           sym_text, &dist, BEFORE, mode )) {

                if ( dist == 0 ) {
                    PRINTF(" %s", sym_text );
                } else {
                    PRINTF(" %s+0x%lx", sym_text, dist );
                }
            }
            PRINTF("\n");
        }
    }
}


VOID
bp(
    CMD_ARGLIST
    )
{
#ifdef _X86_
    CMD_INIT();
    PRINTF("Error- Use native BP command on x86 platforms\n");
#else
    int BPNum;
    VDMCONTEXT      ThreadContext;
    WORD            selector;
    ULONG           offset;
    USHORT          count = 1;
    int mode;
    USHORT flags = 0;

    CMD_INIT();

    if (!LoadBreakPointCache()) {
        return;
    }

    mode = GetContext( &ThreadContext );

    if (!GetNextToken()) {
        PRINTF("Please enter an address\n");
        return;
    }

    if (!ParseIntelAddress(&mode, &selector, &offset)) {
        return;
    }

    if (mode == V86_MODE) {
        flags = VDMBP_V86;
    }

    //
    // first see if it's set already
    //
    for (BPNum = 0; BPNum < MAX_VDM_BREAKPOINTS; BPNum++) {

        if (VdmBPCache[BPNum].Flags & VDMBP_SET) {
            if ((VdmBPCache[BPNum].Seg == selector) &&
                (VdmBPCache[BPNum].Offset == offset) &&
                !(VdmBPCache[BPNum].Flags ^ flags))
                                                 {

                VdmBPCache[BPNum].Count = count;

                if (!(VdmBPCache[BPNum].Flags & VDMBP_ENABLED)) {
                    EnableBreakPoint(&VdmBPCache[BPNum]);
                }

                FlushBreakPointCache();
                PRINTF("breakpoint %d redefined\n", BPNum);
                return;

            }
        }
    }


    //
    // Not found, set a new one
    for (BPNum = 1; BPNum < MAX_VDM_BREAKPOINTS; BPNum++) {

        if (!(VdmBPCache[BPNum].Flags & (VDMBP_SET | VDMBP_FLUSH))) {
            VdmBPCache[BPNum].Seg = selector;
            VdmBPCache[BPNum].Offset = offset;
            VdmBPCache[BPNum].Count = count;
            VdmBPCache[BPNum].Flags = VDMBP_SET | flags;
            EnableBreakPoint(&VdmBPCache[BPNum]);

            FlushBreakPointCache();
            return;

        }
    }
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\vdmexts\dos.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    ntsdexts.c

Abstract:

    This function contains miscellaneous DOS VDMEXTS functions

Author:

    Neil Sandlin (NeilSa) 29-Jul-1996 Wrote it

Revision History:


--*/

#include <precomp.h>
#pragma hdrstop
#include <doswow.h>

VOID
ddh(
    CMD_ARGLIST
    )
/*
    Dump DOS Heap
*/
{
    DWORD selector;
    BYTE Sig;
    WORD Size;
    WORD Owner;
    int count = 0;
    char Module[9];

    CMD_INIT();

    if (!GetNextToken()) {
        WORD wSegment, wSelector;
        LONG lOffset;
        int Mode;

        if (!FindAddress("arena_head",
                         Module, &wSegment, &wSelector, &lOffset, &Mode, FALSE)) {

            PRINTF("Can't find symbol ntdos!arena_head\n");
            return;
        }

        if (!READMEM((LPVOID)(GetIntelBase()+(wSelector<<4)+lOffset), &wSelector, 2)) {
            PRINTF("Error reading ntdos!arena_head\n");
            return;
        }
        selector = wSelector;
    } else {
        selector = (DWORD) EXPRESSION(lpArgumentString);
    }

    PRINTF("DOS memory chain dump\n\n");
    PRINTF("   Addr   Sig Size   Owner\n");
    PRINTF("--------- --- ----  --------\n");

    while (1) {

        if (selector > 0x10000) {
            PRINTF("%08x: Segment value out of range (> 1MB)\n", selector);
            break;
        }

        if (!READMEM((LPVOID)(GetIntelBase()+(selector<<4)), &Sig, 1)) {
            PRINTF("%04x:0000: <Error Reading Memory>\n", selector);
            break;
        }

        if ((Sig != 'M') && (Sig != 'Z')) {
            PRINTF("%04x:0000: <Invalid DOS heap block>\n", selector);
            break;
        }

        if (!READMEM((LPVOID)(GetIntelBase()+(selector<<4)+1), &Owner, 2)) {
            PRINTF("%04x:0001: <Error Reading Memory>\n", selector);
            break;
        }

        if (!READMEM((LPVOID)(GetIntelBase()+(selector<<4)+3), &Size, 2)) {
            PRINTF("%04x:0003: <Error Reading Memory>\n", selector);
            break;
        }

        PRINTF("%04x:0000: %c  %.04X ", selector, Sig, Size);


        if (Owner == 0) {
            PRINTF(" Free\n");
        } else if (Owner<=8) {
            PRINTF(" System\n");
        } else {
            if (!READMEM((LPVOID)(GetIntelBase()+((Owner-1)<<4)+8), Module, 8)) {
                PRINTF("%04x:0008: <Error Reading Memory>\n", selector);
                break;
            }
            Module[8] = 0;
            PRINTF(" %s\n", Module);
        }

        if ((Sig == 'Z') && (selector>0x9ffe)) {
            break;
        }
        selector += Size;
        selector ++;
    }

}


BOOL
DumpSFT(
    USHORT index,
    BOOL Verbose
    )
{
    USHORT usSFN = index;
    ULONG pSfFlat;
    ULONG pSftFlat;
    DOSSF  DosSf;
    DOSSFT DosSft;
    USHORT usSFTCount;
    ULONG  ulSFLink;

    if (!ReadMemExpression("ntvdm!pSFTHead", &pSfFlat, sizeof(pSfFlat))) {
        return FALSE;
    }

    if (!READMEM((LPVOID)(pSfFlat), &DosSf, sizeof(DosSf))) {
        PRINTF("%08x: <Error Reading Memory>\n", pSfFlat);
        return FALSE;
    }

    // Find the right SFT group
    while (usSFN >= (usSFTCount = DosSf.SFCount)){
        usSFN = usSFN - usSFTCount;
        ulSFLink = DosSf.SFLink;
        if (LOWORD(ulSFLink) == 0xffff)
            return FALSE;

        pSfFlat = (((ULONG)(HIWORD(ulSFLink))<<4) + LOWORD(ulSFLink)) + GetIntelBase();

        if (!READMEM((LPVOID)(+pSfFlat), &DosSf, sizeof(DosSf))) {
            PRINTF("%08x: <Error Reading Memory>\n", pSfFlat);
            return FALSE;
        }
    }

    // Get the begining of SFT
    pSftFlat = (ULONG)&(((PDOSSF)pSfFlat)->SFTable);
    pSftFlat += usSFN*sizeof(DOSSFT);

    if (!READMEM((LPVOID)(pSftFlat), &DosSft, sizeof(DosSft))) {
        PRINTF("%08x: <Error Reading Memory>\n", pSftFlat);
        return FALSE;
    }

    PRINTF("%.2X(%.8X)  %.4X %.4X %.2X %.4X %.8X %.4X %.8X\n",
            (UCHAR)index,
            pSftFlat,
            DosSft.SFT_Ref_Count,
            DosSft.SFT_Mode,
            DosSft.SFT_Attr,
            DosSft.SFT_Flags,
            DosSft.SFT_Devptr,
            DosSft.SFT_PID,
            DosSft.SFT_NTHandle);

    if (Verbose) {
        PRINTF("                         %.4X %.4X %.8X %.8X %.8X\n",
            DosSft.SFT_Time,
            DosSft.SFT_Date,
            DosSft.SFT_Size,
            DosSft.SFT_Position,
            DosSft.SFT_Chain);
    }
    return TRUE;
}


VOID
dsft(
    CMD_ARGLIST
    )
/*
    Dump DOS system SFT
*/
{
    USHORT i;
    CMD_INIT();

    PRINTF("SFT           Ref  Mode At Flgs  Devptr  PID  NTHandle\n");

    if (GetNextToken()) {
        DumpSFT((USHORT) EXPRESSION(lpArgumentString), FALSE);
        return;
    }

    for (i=0; i<255; i++) {
        if (!DumpSFT(i, FALSE)) {
            break;
        }
    }
}


VOID
dfh(
    CMD_ARGLIST
    )
/*
    Dump File handle
*/
{
    DOSPDB DosPdb;
    BOOL bDumpAll = TRUE;
    BOOL bUseCurrentPDB = TRUE;
    USHORT pdb;
    ULONG ppdb;
    UCHAR Fh;
    ULONG pJfn;
    UCHAR SftIndex;

    CMD_INIT();

    if (GetNextToken()) {
        if (*lpArgumentString == '*') {
            SkipToNextWhiteSpace();
        } else {
           Fh = (UCHAR)EvaluateToken();
           bDumpAll = FALSE;
        }
        if (GetNextToken()) {
            pdb = (USHORT)EvaluateToken();
            bUseCurrentPDB = FALSE;
        }
    }

    if (bUseCurrentPDB) {
        if (!ReadMemExpression("ntvdm!puscurrentpdb", &ppdb, sizeof(ppdb))) {
            return;
        }
        if (!READMEM((LPVOID)(ppdb), &pdb, sizeof(pdb))) {
            PRINTF("<Error Reading puscurrentpdb at %.8x>\n", ppdb);
            return;
        }
    }

    if (!READMEM((LPVOID)(GetIntelBase()+((ULONG)(pdb)<<4)), &DosPdb, sizeof(DosPdb))) {
        PRINTF("<Error Reading PDB at &%.4x:0000> (%x)\n", pdb,(GetIntelBase()+((ULONG)(pdb)<<4)));
        return;
    }

    if (!bDumpAll && (Fh >= DosPdb.PDB_JFN_Length)) {
        PRINTF("<File handle %.2x out of range (0:%.02X)>\n", Fh, DosPdb.PDB_JFN_Length);
        return;
    }

    pJfn = GetIntelBase() + ((ULONG)(HIWORD(DosPdb.PDB_JFN_Pointer))<<4) +
                            LOWORD(DosPdb.PDB_JFN_Pointer);

#if 0
    PRINTF("%.8X %.8X %.8X\n", GetIntelBase(), (ULONG)(HIWORD(DosPdb.PDB_JFN_Pointer))<<4, (ULONG)LOWORD(DosPdb.PDB_JFN_Pointer));
    PRINTF("pdb=%.4X pjfn=%.8X ljfn=%.4X Flat=%.8X\n", pdb, DosPdb.PDB_JFN_Pointer, DosPdb.PDB_JFN_Length, pJfn);
#endif

    PRINTF("fh SFT           Ref  Mode At Flgs  Devptr  PID  NTHandle\n");

    if (bDumpAll) {
        for (Fh = 0; Fh < DosPdb.PDB_JFN_Length; Fh++) {
            if (!READMEM((LPVOID)(pJfn + Fh),
                         &SftIndex, sizeof(SftIndex))) {
                PRINTF("<Error Reading JFT at %.8x>\n", pJfn + Fh);
                return;
            }

            if (SftIndex != 0xff) {
                PRINTF("%.2X ", Fh);
                DumpSFT((USHORT)SftIndex, FALSE);
            }

        }

    } else {

        if (!READMEM((LPVOID)(pJfn + Fh),
                     &SftIndex, sizeof(SftIndex))) {
            PRINTF("<Error Reading JFT at %.8x>\n", pJfn + Fh);
            return;
        }

        if (SftIndex != 0xff) {
            PRINTF("%.2X ", Fh);
            DumpSFT((USHORT)SftIndex, FALSE);
        } else {
            PRINTF("Handle %.2X is not open\n", Fh);
        }
    }
}


BOOL DumpEnvironment(WORD segEnv, int mode)
{
    char rgchEnv[32768];
    char *pch;
    char *pchLimit;

    if (!READMEM((LPVOID)(GetIntelBase() + GetInfoFromSelector(segEnv, mode, NULL)),
                 rgchEnv, sizeof(rgchEnv))) {
        PRINTF("<Error Reading Environment at &%.4x:0 (%.8x)>\n", segEnv, GetIntelBase() + (segEnv << 4));
        return FALSE;
    }

    //
    // Dump each string in environment block until
    // double-null termination.
    //

    pch = rgchEnv;
    pchLimit = rgchEnv + sizeof(rgchEnv);

    while (pch < pchLimit && *pch) {

        if (!strchr(pch, '=')) {
            PRINTF("<malformed environment string, halting dump>\n");
            return FALSE;
        }
        PRINTF("    %s\n", pch);
        pch += strlen(pch) + 1;
    }

    if (pch >= pchLimit) {
        PRINTF("<Environment exceeded 32k, dump halted>\n", pch);
        return FALSE;
    }

    //
    // pch now points at the second null of the double-null termination,
    // advance past this null and dump the magic word that follows and
    // the EXE path after that.
    //

    pch++;
    if (pch >= pchLimit - 1) {
        PRINTF("<Environment exceeded 32k, dump halted>\n", pch);
        return FALSE;
    }

    if (1 != *(WORD UNALIGNED *)pch) {
        PRINTF("\nMagic word after double-null IS NOT ONE, dump halted: 0x%x\n", *(WORD UNALIGNED *)pch);
        return FALSE;
    }
    pch += sizeof(WORD);
    if ( (pch + strlen(pch) + 1) > pchLimit) {
        PRINTF("<Environment exceeded 32k, dump halted>\n", pch);
        return FALSE;
    }

    PRINTF("EXE path: <%s>\n", pch);

    return TRUE;
}


VOID
denv(
    CMD_ARGLIST
    )
/*
    Dump environment block for current DOS process or given environment selector

    !denv <bPMode> <segEnv>

    Examples:
    !denv             - Dumps environment for current DOS process
    !denv 0 145d      - Dumps DOS environment at &145d:0 (145d from PDB_environ of DOS process)
    !denv 1 16b7      - Dumps DOS environment at #16b7:0 (16b7 from !dt -v segEnvironment)
*/
{
    DOSPDB DosPdb;
    BOOL bUseCurrentPDB = TRUE;
    USHORT pdb;
    USHORT segEnv;
    ULONG ppdb;
    int mode = PROT_MODE;

    CMD_INIT();

    if (GetNextToken()) {
        mode = (int)EvaluateToken();
        if (GetNextToken()) {
            segEnv = (USHORT)EvaluateToken();
            bUseCurrentPDB = FALSE;
        }
    }

    if (bUseCurrentPDB) {
        if (!ReadMemExpression("ntvdm!puscurrentpdb", &ppdb, sizeof(ppdb))) {
            return;
        }
        if (!READMEM((LPVOID)(GetIntelBase()+ppdb), &pdb, sizeof(pdb))) {
            PRINTF("<Error Reading puscurrentpdb at %.8x>\n", ppdb);
            return;
        }
        PRINTF("Current PDB is 0x%x\n", pdb);
        if (!READMEM((LPVOID)(GetIntelBase()+((ULONG)(pdb)<<4)), &DosPdb, sizeof(DosPdb))) {
             PRINTF("<Error Reading PDB at &%.4x:0000>\n", pdb);
             return;
        }
        segEnv = DosPdb.PDB_environ;
        //
        // Guess mode for current PDB's PDB_environ (could be real or PM depending
        // on where we are in dosx).
        //
        if ( (segEnv & 0x7) == 0x7 ) {
            mode = PROT_MODE;
        } else {
            mode = V86_MODE;
        }
    }
    PRINTF("Environment %s is 0x%x\n", mode ? "selector" : "segment", segEnv);

    if (segEnv) {
        DumpEnvironment(segEnv, mode);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\vdmexts\dpmi.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    ntsdexts.c

Abstract:

    This function contains miscellaneous VDMEXTS functions

Author:

    Bob Day      (bobday) 29-Feb-1992 Grabbed standard header

Revision History:

    Neil Sandlin (NeilSa) 15-Jan-1996 Merged with vdmexts

--*/

#include <precomp.h>
#pragma hdrstop
#include <dpmi.h>


VOID
PrintOneFaultVector(
    int vector,
    ULONG pHandler
    )
{
    VDM_FAULTHANDLER handler;
    char            sym_text[255];
    ULONG dist;

    PRINTF("%02X: ", vector);

    if (!READMEM((LPVOID)pHandler, &handler, sizeof(VDM_FAULTHANDLER))) {
        PRINTF("<error reading memory>\n");
        return;
    }

    PRINTF("%04LX:%08lX ", handler.CsSelector, handler.Eip);

    if (FindSymbol(handler.CsSelector, handler.Eip, sym_text, &dist, BEFORE, PROT_MODE )) {
        if ( dist == 0 ) {
            PRINTF("%s", sym_text );
        } else {
            PRINTF("%s+0x%lx", sym_text, dist );
        }
    }
    PRINTF("\n");

}



VOID
df(
    CMD_ARGLIST
    )
{
    int vector = -1;
    LPVOID pHandlers;


    CMD_INIT();

    if (GetNextToken()) {
        vector = EvaluateToken();
        if ((vector < 0) || (vector > 0x1f)) {
            PRINTF("Invalid fault vector\n");
            return;
        }
    }

    pHandlers = (LPVOID) EXPRESSION("ntvdm!dpmifaulthandlers");
    if (!pHandlers) {
        PRINTF("Could get symbol ntvdm!dpmifaulthandlers\n");
        return;
    }


    if (vector >= 0) {

        PrintOneFaultVector(vector, (ULONG)pHandlers +
                                  vector*sizeof(VDM_FAULTHANDLER));

    } else for (vector = 0; vector < 0x20; vector++) {

        PrintOneFaultVector(vector, (ULONG)pHandlers +
                                  vector*sizeof(VDM_FAULTHANDLER));

    }

}


VOID
PrintOneInterruptVector(
    int vector,
    ULONG pHandler
    )
{
    VDM_INTERRUPTHANDLER handler;
    char            sym_text[255];
    ULONG dist;

    PRINTF("%02X: ", vector);

    if (!READMEM((LPVOID)pHandler, &handler, sizeof(VDM_INTERRUPTHANDLER))) {
        PRINTF("<error reading memory>\n");
        return;
    }

    PRINTF("%04LX:%08lX ", handler.CsSelector, handler.Eip);

    if (FindSymbol(handler.CsSelector, handler.Eip, sym_text, &dist, BEFORE, PROT_MODE )) {
        if ( dist == 0 ) {
            PRINTF("%s", sym_text );
        } else {
            PRINTF("%s+0x%lx", sym_text, dist );
        }
    }

    PRINTF("\n");

}



VOID
di(
    CMD_ARGLIST
    )
{
    int vector = -1;
    LPVOID pHandlers;

    CMD_INIT();

    if (GetNextToken()) {
        vector = EvaluateToken();
        if ((vector < 0) || (vector > 0xff)) {
            PRINTF("Invalid interrupt vector\n");
            return;
        }
    }

    pHandlers = (LPVOID) EXPRESSION("ntvdm!dpmiinterrupthandlers");
    if (!pHandlers) {
        PRINTF("Could get symbol ntvdm!dpmiinterrupthandlers\n");
        return;
    }

    if (vector >= 0) {

        PrintOneInterruptVector(vector, (ULONG)pHandlers +
                                  vector*sizeof(VDM_INTERRUPTHANDLER));

    } else for (vector = 0; vector < 0x100; vector++) {

        PrintOneInterruptVector(vector, (ULONG)pHandlers +
                                  vector*sizeof(VDM_INTERRUPTHANDLER));

    }

}

VOID
rmcb(
    CMD_ARGLIST
    )
{
    RMCB_INFO Rmcb[MAX_RMCBS];
    USHORT RMCallBackBopSeg;
    USHORT RMCallBackBopOffset;
    int i;
    int count = 0;

    CMD_INIT();

    if (!ReadMemExpression("ntvdm!DpmiRmcb", &Rmcb, MAX_RMCBS*sizeof(RMCB_INFO))) {
        return;
    }

    if (!ReadMemExpression("ntvdm!RMCallBackBopSeg", &RMCallBackBopSeg, 2)) {
        return;
    }

    if (!ReadMemExpression("ntvdm!RMCallBackBopOffset", &RMCallBackBopOffset, 2)) {
        return;
    }


    for (i=0; i<MAX_RMCBS; i++) {
        if (Rmcb[i].bInUse) {

            if (!count++) {
                PRINTF("\n");
                PRINTF(" CallBack      PM Proc         RM Struct       Stack Sel\n");
            }

            PRINTF("&%.4X:%.4X  -  ", RMCallBackBopSeg-i,
                                     RMCallBackBopOffset + (i*16));

            PRINTF("#%.4X:%.8X  #%.4X:%.8X  %.4X\n",
                                     Rmcb[i].ProcSeg,
                                     Rmcb[i].ProcOffset,
                                     Rmcb[i].StrucSeg,
                                     Rmcb[i].StrucOffset,
                                     Rmcb[i].StackSel);

        }
    }

    if (!count) {
        PRINTF("No dpmi real mode callbacks are defined\n");
    } else {
        PRINTF("\n");
    }

}


VOID
DumpDpmiMemChain(
    ULONG Head
    )
{
    MEM_DPMI MemBlock;
    ULONG pMem;
    ULONG Count = 0;

    if (!Head) {
        PRINTF("Error accessing ntvdm symbols\n");
        return;
    }

    if (!READMEM((LPVOID)(Head), &MemBlock, sizeof(MEM_DPMI))) {
        PRINTF("<Error Reading memory list head>\n");
        return;
    }

    pMem = (ULONG) MemBlock.Next;

    if (pMem == Head) {
        PRINTF("The list is empty.\n");
    } else {

        PRINTF("Address  Length   Owner Sel  Cnt   Next     Prev\n");
        while (pMem != Head) {

            if (!READMEM((LPVOID)(pMem), &MemBlock, sizeof(MEM_DPMI))) {
                PRINTF("<Error Reading memory list block at %.08X>\n", pMem);
                return;
            }

            PRINTF("%.08X %.08X %.04X  %.04X %.04X  %.08X %.08X\n",
                        MemBlock.Address, MemBlock.Length,
                        MemBlock.Owner, MemBlock.Sel, MemBlock.SelCount,
                        MemBlock.Next, MemBlock.Prev);

            pMem = (ULONG) MemBlock.Next;
            Count++;
            if (Count>100) {
                PRINTF("Possible Corruption\n");
                return;
            }
        }

    }

}

VOID
dpx(
    CMD_ARGLIST
    )
{
    CMD_INIT();
    PRINTF("\n*** Dpmi XMEM Allocation chain ***\n\n");
    DumpDpmiMemChain(EXPRESSION("ntvdm!XmemHead"));
}

VOID
dpd(
    CMD_ARGLIST
    )
{
    CMD_INIT();
    PRINTF("\n*** Dpmi DOSMEM Allocation chain ***\n\n");
    DumpDpmiMemChain(EXPRESSION("ntvdm!DosMemHead"));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\vdmexts\heap.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    heap.c

Abstract:

    This function contains the default ntsd debugger extensions

Author:

    Bob Day      (bobday) 29-Feb-1992 Grabbed standard header

Revision History:

    Neil Sandlin (NeilSa) 15-Jan-1996 Merged with vdmexts

--*/

#include <precomp.h>
#pragma hdrstop


BOOL    bWalkOnly = FALSE;

ULONG
GetHeapBase(
    VOID
    )
{
    WORD selector;
    SELECTORINFO si;

    if (!ReadMemExpression("ntvdmd!DbgWowhGlobalHeap", &selector, sizeof(selector))) {
        return 0;
    }

    GetInfoFromSelector(selector, PROT_MODE, &si);

    return(si.Base + GetIntelBase());

}



void
GetFileNameFromOwner(
    LPSTR filename,
    LPSTR OwnerName
    )
{
}


VOID
GetHeapOwnerInfo(
    HEAPENTRY *he
    )
{
    BOOL    b;
    NEHEADER owner;
    ULONG base;
    UCHAR len;
    int i;
    ULONG offset;
    WORD wTemp;

    he->SegmentNumber = -1;
    he->OwnerName[0] = 0;
    if (he->gnode.pga_owner == 0) {
        strcpy(he->OwnerName, "free");
        return;
    } else if (he->gnode.pga_owner>=0xFFF8) {
        strcpy(he->OwnerName, "sentinel");
        return;
    }


    base = GetInfoFromSelector(he->gnode.pga_owner, PROT_MODE, NULL)
            + GetIntelBase();

    b = READMEM((LPVOID)base, &owner, sizeof(owner));

    if (b) {
        if (owner.ne_magic == 0x454e) {

            len = ReadByteSafe(base+owner.ne_restab);
            if (len>8) {
                len=8;
            }
            READMEM((LPVOID)(base+owner.ne_restab+1), he->OwnerName, 8);

            he->OwnerName[len] = 0;
            if (!_stricmp(he->OwnerName, "kernel")) {
                strcpy(he->FileName, "krnl386");
            } else {
                strcpy(he->FileName, he->OwnerName);
            }

            offset = owner.ne_segtab;

            for (i=0; i<owner.ne_cseg; i++) {
                wTemp = ReadWordSafe(base+offset+8);    //get handle
                if (wTemp == he->gnode.pga_handle) {
                    he->SegmentNumber = i;
                    break;
                }
                offset += 10;
            }

        }
    }

}

BOOL
CheckGlobalHeap(
    BOOL bVerbose
    )
{
    PGHI32  pghi;
    DWORD   offset, prevoffset;
    DWORD   count, heapcount;
    DWORD   p;
    GNODE32 gnode;
    PBYTE   pFault = NULL;
    BOOL    bError = FALSE;

    pghi = (PGHI32)GetHeapBase();
    prevoffset = offset = (DWORD) ReadWord(&pghi->hi_first);
    heapcount = count = ReadWord(&pghi->hi_count);

    if (bVerbose) {
        PRINTF("Global Heap is at %08X\n", pghi);
    }


    while ((offset != 0) && (count)) {

        if (offset&0x1f) {
            PRINTF("Error! Kernel heap entry(%08X) contains invalid forward link (%08X)\n", prevoffset, offset);
            return FALSE;
        }

        p = (DWORD)pghi + offset;

        if (!ReadGNode32Safe(p, &gnode)) {

            PRINTF("Error! Kernel heap entry(%08X) contains invalid forward link (%08X)\n", prevoffset, offset);
            return FALSE;

        }

        if (count == heapcount) {
            // first entry
            if (offset != gnode.pga_prev) {
                PRINTF("Error! Kernel heap entry (%08X) contains invalid back link (%08X)\n", offset, gnode.pga_prev);
                PRINTF(" expecting (%08X)\n", offset);
                return FALSE;
            }
        } else {
            if (prevoffset != gnode.pga_prev) {
                PRINTF("Error! Kernel heap entry (%08X) contains invalid back link (%08X)\n", offset, gnode.pga_prev);
                PRINTF(" expecting (%08X)\n", prevoffset);
                return FALSE;
            }
        }

        prevoffset = offset;

        count--;
        if (offset == gnode.pga_next) {
            if (!count) {
                if (bVerbose) {
                    PRINTF("%d entries scanned\n", heapcount);
                }
                return TRUE;
            } else {
                PRINTF("Error! Kernel heap count (%d) larger then forward chain (%d)\n", heapcount, heapcount-count);
            }
        }
        offset = gnode.pga_next;
    }

    PRINTF("Error! Kernel heap count (%d) smaller then forward chain\n", heapcount);
    return FALSE;
}


BOOL
FindHeapEntry(
    HEAPENTRY *he,
    UINT FindMethod,
    BOOL bVerbose
    )
{
    PGHI32  pghi;
    DWORD   offset;
    DWORD   MaxEntries, count;
    DWORD   p;
    PBYTE   pFault = NULL;
    BOOL    bError = FALSE;

    pghi = (PGHI32)GetHeapBase();

    //
    // Verify that we are looking at a heap
    //
    offset = (DWORD) ReadWordSafe(&pghi->hi_first);
    p = (DWORD)pghi + offset;
    if (!ReadGNode32Safe(p, &he->gnode)) {
        if (bVerbose) {
            PRINTF("Heap not available\n");
        }
        return FALSE;
    } 
    if (offset != he->gnode.pga_prev) {
        if (bVerbose) {
            PRINTF("Heap not valid\n");
        }
        return FALSE;
    }


    //
    // The caller has requested that we return the next heap
    // entry since the last invocation, or the first entry.
    //

    if (he->CurrentEntry == 0) {

        // get first entry
        offset = (DWORD) ReadWord(&pghi->hi_first);

    } else {
        if (he->CurrentEntry == he->NextEntry) {
            return FALSE;
        }

        // get next entry
        offset = he->NextEntry;

    }

    he->CurrentEntry = offset;

    if ((he->Selector == 0) && (FindMethod != FHE_FIND_MOD_ONLY)) {

        p = (DWORD)pghi + offset;
        if (!ReadGNode32(p, &he->gnode)) {

            return FALSE;

        } 

        he->NextEntry = he->gnode.pga_next;
        GetHeapOwnerInfo(he);
        return TRUE;
    }

    // 
    // If we get here, the caller wants us to scan the heap
    //

    MaxEntries = ReadWord(&pghi->hi_count);
    count = 0;

    while ((offset != 0) && (count <= MaxEntries)) {

        p = (DWORD)pghi + offset;

        if (!ReadGNode32(p, &he->gnode)) {

            return FALSE;

        } else {

            if (FindMethod == FHE_FIND_ANY) {
                WORD sel = he->Selector;

                if (((sel|1)==((WORD)he->gnode.pga_handle|1)) ||
                    ((sel|1)==((WORD)he->gnode.pga_owner|1))  ||
                    (sel==offset))

                {
                    he->NextEntry = he->gnode.pga_next;
                    GetHeapOwnerInfo(he);
                    return TRUE;
                }

            } else if (FindMethod == FHE_FIND_MOD_ONLY) {

                GetHeapOwnerInfo(he);
                if (!_stricmp(he->OwnerName, he->ModuleArg)) {
                    he->NextEntry = he->gnode.pga_next;
                    return TRUE;
                }

            } else {
                if ((he->Selector|1)==((WORD)he->gnode.pga_handle|1)) {
                    he->NextEntry = he->gnode.pga_next;
                    GetHeapOwnerInfo(he);
                    return TRUE;
                }
            }
        }

        count++;
        if (offset == he->gnode.pga_next) {
            break;
        }
        offset = he->gnode.pga_next;
        he->CurrentEntry = offset;
    }

    return FALSE;
}


VOID
chkheap(
    CMD_ARGLIST
    )
{
    CMD_INIT();
    if (CheckGlobalHeap(TRUE)) {
        PRINTF("Heap checks OK\n");
    }

}


//*************************************************************
//  dumpgheap xxx
//   where xxx is the 16-bit protect mode selector of the
//   Kernel global heap info.
//
//*************************************************************


VOID
dgh(
    CMD_ARGLIST
    )
{
    HEAPENTRY    he = {0};
    SELECTORINFO si;
    ULONG TotalAllocated = 0;
    ULONG TotalFree = 0;
    ULONG CountPrinted = 0;

    CMD_INIT();

    if (GetNextToken()) {
        he.Selector = (WORD) EXPRESSION( lpArgumentString );
    }

    PRINTF("Arena   Base     Limit  Hnd  Own  Fl Lk   Module  Type  Resid");
    PRINTF("\n");

    PRINTF("===== ======== ======== ==== ==== == ==  ======== ====  =====");
    PRINTF("\n");

    while (FindHeapEntry(&he, FHE_FIND_ANY, FHE_FIND_VERBOSE)) {

        PRINTF("%.5x", he.CurrentEntry);
        PRINTF(" %.8x", he.gnode.pga_address);
        PRINTF(" %.8X", he.gnode.pga_size);
        PRINTF(" %.4X", he.gnode.pga_handle);
        PRINTF(" %.4X", he.gnode.pga_owner);
        PRINTF(" %.2X", he.gnode.pga_flags);
        PRINTF(" %.2X", he.gnode.pga_count);
        PRINTF("  %-8.8s", he.OwnerName);

        GetInfoFromSelector((WORD)(he.gnode.pga_handle | 1), PROT_MODE, &si);

        PRINTF(" %s", si.bCode ? "Code" : "Data");

        if (he.SegmentNumber != -1) {
            PRINTF("    %d", he.SegmentNumber+1);
        } 
        PRINTF("\n");

        if (!he.gnode.pga_owner) {
            TotalFree += he.gnode.pga_size;
        } else {
            TotalAllocated += he.gnode.pga_size;
        }
        CountPrinted++;
    }

    if (CountPrinted > 1) {
        PRINTF("\n Allocated = %dK, Free = %dK\n", TotalAllocated/1024, TotalFree/1024);
    }
}

VOID
UpdateLockCount(
    int count
    )
{
    HEAPENTRY    he = {0};
    BYTE LockCount;

    if (GetNextToken()) {
        he.Selector = (WORD) EXPRESSION( lpArgumentString );
    } else {
        PRINTF("Please enter a selector or handle\n");
        return;
    }

    if (FindHeapEntry(&he, FHE_FIND_SEL_ONLY, FHE_FIND_VERBOSE)) {

        if (READMEM((LPVOID)(GetHeapBase()+he.CurrentEntry+0x14), &LockCount, 1)) {

            LockCount = (BYTE)((int) LockCount + count);
            WRITEMEM((LPVOID)(GetHeapBase()+he.CurrentEntry+0x14), &LockCount, 1);
            PRINTF("Lock count for %.4X is now %d\n", he.Selector, LockCount);

        } else {

            PRINTF("<can't read memory at that location>\n");

        }

    } else {
        PRINTF("Can't find selector %4X in WOW heap\n", he.Selector);
    }
}


VOID
glock(
    CMD_ARGLIST
    )
{
    CMD_INIT();

    UpdateLockCount(1);
}


VOID
gunlock(
    CMD_ARGLIST
    )
{
    CMD_INIT();

    UpdateLockCount(-1);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\vdmexts\dib.c ===
/******************************Module*Header*******************************\
* Module Name: dib.c
*
* This file is for debugging tools and extensions.
*
* Created: 12-Jan-1996
* Author: VadimB
*
* History:
* Jan 12 96 VadimB Created to dump a list of dib.drv support structures
*
*
* Copyright (c) 1992 Microsoft Corporation
\**************************************************************************/

#include "precomp.h"
#pragma hdrstop
#include <wmdisp32.h>
#include <wcuricon.h>
#include <wucomm.h>
#include <doswow.h>
#include <wdib.h>
#include <wowgdip.h>

//
// Local function prototypes
//

extern INT  WDahtoi(LPSZ lpsz);
extern INT  WDParseArgStr(LPSZ lpszArgStr, CHAR **argv, INT iMax);

LPVOID DumpDibInfo(PDIBINFO pdi)
{
    DIBINFO di;
    
    READMEM_XRETV(di, pdi, NULL);
    pdi = &di;  

    PRINTF(">> Structure at %08X\n", (DWORD)(LPVOID)pdi);
    PRINTF("di_hdc: (32)%08X (16)%04X\n", pdi->di_hdc, ((DWORD)(pdi->di_hdc))<<2);
    PRINTF("di_newdib: %08X\n", (DWORD)pdi->di_newdib);
    PRINTF("di_newIntelDib: %08X\n", (DWORD)pdi->di_newIntelDib);
    PRINTF("di_hbm: (32)%08X\n", (DWORD)pdi->di_hbm);
    PRINTF("di_dibsize: %08X\n", (DWORD)pdi->di_dibsize);
    PRINTF("di_originaldibsel: %08X\n", (DWORD)pdi->di_originaldibsel);
    PRINTF("di_originaldibflags: %08X\n", (DWORD)pdi->di_originaldibflags);
    PRINTF("di_lockcount: %08X\n", (DWORD)pdi->di_lockcount);
    PRINTF("\n");

    return (LPVOID)pdi->di_next;
}


VOID DumpDibChain(LPSTR lpszExpressionHead)
{
    PDIBINFO pdi;

    GETEXPRADDR(pdi, lpszExpressionHead);
    READMEM_XRET(pdi, pdi);

    if (NULL == pdi) {
        PRINTF("List %s is empty!\n", lpszExpressionHead);
    }
    else {
        PRINTF("\nDump of the DIB.DRV support structure: %s\n", lpszExpressionHead);
        PRINTF("-------------------------------------------------------\n");
        
        while (NULL != pdi) {
            pdi = DumpDibInfo(pdi);
        }
    }
}


VOID 
dhdib(
    CMD_ARGLIST
    )
{
// dump dib support chain
// dumps: dhdib @<address> - dump at address
// dumps: dhdib   - everything...
    
    CHAR* argv[3];
    int nArgs;
    BOOL fDumpDib = TRUE;
    static CHAR* symDibHead = "wow32!pDibInfoHead";
    PDIBINFO pdi;

    CMD_INIT();
    ASSERT_WOW_PRESENT;

    nArgs = WDParseArgStr(lpArgumentString, argv, 2);
    if (nArgs > 0) {

        CHAR* parg = argv[0];
        switch(toupper(*parg)) {  // dump at...
            case '@':
                // recover address and dump!
                {
                    CHAR* pch = *++parg ? 
                                    parg : 
                                    (nArgs >= 2 ? argv[1] : NULL);
                    if (pch) {
                        pdi = (PDIBINFO)WDahtoi(pch);
                        fDumpDib = FALSE;
                    }
                    else {
                        PRINTF("Invalid Parameter\n"); 
                    }
                }
                break;

            default:
                break;
        }
    }


    if (fDumpDib) {
        DumpDibChain(symDibHead);
    }
    else {
        if (pdi) {
            DumpDibInfo(pdi);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\vdmexts\disasm.c ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    disasm.c

Abstract:

    This file contains the x86 disassmbler invoked by "!bde.u <16:16 address>"

Author:

    Barry Bond    (BarryBo)

Revision History:

    09-May-1995 Barry Bond  (BarryBo)   Created
    15-Jan-1996 Neil Sandlin (NeilSa)   Merged with vdmexts
                                        32 bit segments fixes

--*/

#include <precomp.h>
#pragma hdrstop

WORD  gSelector = 0;
ULONG gOffset = 0;
int gMode = 0;

VOID
u(
    CMD_ARGLIST
) {
    VDMCONTEXT      ThreadContext;
    WORD            selector;
    ULONG           offset;
    int             mode;
    char            rgchOutput[128];
    char            rgchExtra[128];
    BYTE            rgbInstruction[64];
    CHAR            sym_text[255];
    CHAR            sym_prev[255] = "";
    DWORD           dist;
    int             cb;
    int             i;
    int             j;
    int             count=10;
    ULONG           Base;
    SELECTORINFO    si;
    ULONG           BPNum;
    UCHAR           BPData;
    BOOL            bIsBP;

    CMD_INIT();

    mode = GetContext( &ThreadContext );

    if (!GetNextToken()) {
        if (!gSelector && !gOffset) {
            selector = (WORD) ThreadContext.SegCs;
            offset   = ThreadContext.Eip;
        } else {
            mode = gMode;
            selector = gSelector;
            offset = gOffset;
        }
    } else if (!ParseIntelAddress(&mode, &selector, &offset)) {
        return;
    }

    if (GetNextToken()) {
        count = (int) EXPRESSION(lpArgumentString);
        if (count > 1000) {
            PRINTF("Count too large - ignored\n");
            count=10;
        }
    }

    if ( mode != PROT_MODE && mode != V86_MODE) {
        PRINTF(" Disassembly of flat mode code not allowed.\n");
        return;
    }

    LoadBreakPointCache();
    Base = GetInfoFromSelector( selector, mode, &si ) + GetIntelBase();

    for (i=0; i<count; ++i) {

        if (FindSymbol(selector, offset, sym_text, &dist, BEFORE, mode )) {
            if (_stricmp(sym_text, sym_prev)) {
                if ( dist == 0 ) {
                    PRINTF("%s:\n", sym_text );
                } else {
                    PRINTF("%s+0x%lx:\n", sym_text, dist );
                }
                strcpy(sym_prev, sym_text);
            }
        }

        cb = sizeof(rgbInstruction);
        if ((DWORD)(offset+cb) >= si.Limit)
            cb -= offset+cb-si.Limit;
        if (!READMEM((LPVOID)(Base+offset), rgbInstruction, cb)) {
            PRINTF("%04x:%08x: <Error Reading Memory>\n", selector, offset);
            return;
        }

        if (bIsBP = IsVdmBreakPoint(selector,
                                    offset,
                                    mode==PROT_MODE,
                                    &BPNum,
                                    &BPData)) {
            rgbInstruction[0] = BPData;
        }

        cb = unassemble_one(rgbInstruction,
                si.bBig,
                selector, offset,
                rgchOutput,
                rgchExtra,
                &ThreadContext,
                mode);

        gOffset += cb;

        if (offset > 0xffff) {
            PRINTF("%04x:%08x ", selector, offset);
        } else {
            PRINTF("%04x:%04x ", selector, offset);
        }

        for (j=0; j<cb; ++j)
            PRINTF("%02x", rgbInstruction[j]);
        for (; j<8; ++j)
            PRINTF("  ");

        PRINTF("%s\t%s", rgchOutput, rgchExtra);

        if (bIsBP) {
            PRINTF("; BP%d",BPNum);
        }

        PRINTF("\n");
        offset+=cb;
    }
}


typedef struct _ADDR {
    ULONG     sOff;
    USHORT    sSeg;
} ADDR;


LPBYTE checkprefixes(LPBYTE);
void AppendPrefixes(void);
void DisplayAddress(int mod, int rm, int sOff, int size);
int DisplayBOP(void);

#define modrmB      1
#define modrmW      2
#define reg1B       3
#define reg1W       4
#define reg2B       5
#define reg2W       6
#define eeeControl  7
#define eeeDebug    8
#define eeeTest     9
#define regSeg      10
#define ALreg       11
#define AHreg       12
#define BLreg       13
#define BHreg       14
#define CLreg       15
#define CHreg       16
#define DLreg       17
#define DHreg       18
#define AXreg       19
#define BXreg       20
#define CXreg       21
#define DXreg       22
#define SIreg       23
#define DIreg       24
#define SPreg       25
#define BPreg       26
#define CSreg       27
#define SSreg       28
#define DSreg       29
#define ESreg       30
#define FSreg       31
#define GSreg       32
#define ImmB        33
#define ImmBEnter   34
#define ImmBS       35
#define ImmW        36
#define ImmW1       37
#define jmpB        38
#define jmpW        39
#define memB        40
#define memW        41
#define memD        42
#define indirmodrmW 43
#define indirFARmodrmW 44
#define memB1       45


int DmodrmB(LPBYTE);
int DmodrmW(LPBYTE);
int Dreg1B(LPBYTE);
int Dreg1W(LPBYTE);
int Dreg2B(LPBYTE);
int Dreg2W(LPBYTE);
int DeeeControl(LPBYTE);
int DeeeDebug(LPBYTE);
int DeeeTest(LPBYTE);
int DregSeg(LPBYTE);
int DALreg(LPBYTE);
int DAHreg(LPBYTE);
int DBLreg(LPBYTE);
int DBHreg(LPBYTE);
int DCLreg(LPBYTE);
int DCHreg(LPBYTE);
int DDLreg(LPBYTE);
int DDHreg(LPBYTE);
int DAXreg(LPBYTE);
int DBXreg(LPBYTE);
int DCXreg(LPBYTE);
int DDXreg(LPBYTE);
int DSIreg(LPBYTE);
int DDIreg(LPBYTE);
int DSPreg(LPBYTE);
int DBPreg(LPBYTE);
int DCSreg(LPBYTE);
int DSSreg(LPBYTE);
int DDSreg(LPBYTE);
int DESreg(LPBYTE);
int DFSreg(LPBYTE);
int DGSreg(LPBYTE);
int DImmB(LPBYTE);
int DImmBEnter(LPBYTE);
int DImmBS(LPBYTE);
int DImmW(LPBYTE);
int DImmW1(LPBYTE); // immediate-16 for 1-byte instructions
int DjmpB(LPBYTE);
int DjmpW(LPBYTE);
int DmemB(LPBYTE);
int DmemB1(LPBYTE);
int DmemW(LPBYTE);
int DmemD(LPBYTE);
int DindirmodrmW(LPBYTE);
int DindirFARmodrmW(LPBYTE);

struct {
    int (*pfn)(LPBYTE);
} rgpfn[] = {

 0,         // 0th entry is reserved
 DmodrmB,
 DmodrmW,
 Dreg1B,
 Dreg1W,
 Dreg2B,
 Dreg2W,
 DeeeControl,
 DeeeDebug,
 DeeeTest,
 DregSeg,
 DALreg,
 DAHreg,
 DBLreg,
 DBHreg,
 DCLreg,
 DCHreg,
 DDLreg,
 DDHreg,
 DAXreg,
 DBXreg,
 DCXreg,
 DDXreg,
 DSIreg,
 DDIreg,
 DSPreg,
 DBPreg,
 DCSreg,
 DSSreg,
 DDSreg,
 DESreg,
 DFSreg,
 DGSreg,
 DImmB,
 DImmBEnter,
 DImmBS,
 DImmW,
 DImmW1, // immediate-16 for 1-byte instructions
 DjmpB,
 DjmpW,
 DmemB,
 DmemW,
 DmemD,
 DindirmodrmW,
 DindirFARmodrmW,
 DmemB1
};

VDMCONTEXT  *g_pThreadContext;
int         g_mode;
char *g_pchOutput;  // the disassembled instruction
char *g_pchExtra;   // contents of memory (if any) modified by this instr.
int prefixes;

//NOTE: if first byte = 0x0f, then the instruction is two bytes long

char *szRegsB[] = {"al", "cl", "dl", "bl", "ah", "ch", "dh", "bh"};
char *szRegsW[] = {"ax", "cx", "dx", "bx", "sp", "bp", "si", "di"};
char *szRegsD[] = {"eax","ecx","edx","ebx","esp","ebp","esi","edi"};
char *szRegsSeg[] = {"es", "cs", "ss", "ds", "fs", "gs", "(bad)", "(bad)"};
char *szMod[]   = {"[bx+si", "[bx+di", "[bp+si", "[bp+di", "[si", "[di", "[bp", "[bx"};

#define PREFIX_REPZ 1
#define PREFIX_REPNZ 2
#define PREFIX_LOCK 4
#define PREFIX_CS 8
#define PREFIX_SS 0x10
#define PREFIX_DS 0x20
#define PREFIX_ES 0x40
#define PREFIX_FS 0x80
#define PREFIX_GS 0x100
#define PREFIX_DATA 0x200
#define PREFIX_ADR 0x400
#define PREFIX_FWAIT 0x800

#define GROUP_1B    -1
#define GROUP_1WS   -2
#define GROUP_1W    -3
#define GROUP_2B    -4
#define GROUP_2W    -5
#define GROUP_2B_1  -6
#define GROUP_2W_1  -7
#define GROUP_2B_CL -8
#define GROUP_2W_CL -9
#define GROUP_3B    -10
#define GROUP_3W    -11
#define GROUP_4     -12
#define GROUP_5     -13
#define GROUP_6     -14
#define GROUP_7     -15
#define GROUP_8     -16

#define FLOATCODE   -51
#define FLOAT       FLOATCODE

// WARNING: This list must remain in sync with the szInstructions[] array
#define szAdc   1
#define szAdd   2
#define szAnd   3
#define szBad   4
#define szCmp   5
#define szDec   6
#define szIn    7
#define szInc   8
#define szJmp   9
#define szMov   10
#define szOr    11
#define szOut   12
#define szRcl   13
#define szRcr   14
#define szRol   15
#define szRor   16
#define szSar   17
#define szSbb   18
#define szShl   19
#define szShr   20
#define szSub   21
#define szTest  22
#define szPop   23
#define szPush  24
#define szXchg  25
#define szXor   26
#define szDaa   27
#define szDas   28
#define szPusha 29
#define szPopa  30
#define szBound 31
#define szArpl  32
#define szAaa   33
#define szAas   34
#define szImul  35
#define szIdiv  36
#define szJo    37
#define szJno   38
#define szJb    39
#define szJae   40
#define szJe    41
#define szJne   42
#define szJbe   43
#define szJa    44
#define szJs    45
#define szJns   46
#define szJp    47
#define szJnp   48
#define szJl    49
#define szJnl   50
#define szJle   51
#define szJg    52
#define szNop   53
#define szLea   54
#define szCbw   55
#define szCwd   56
#define szCall  57
#define szPushf 58
#define szPopf  59
#define szSahf  60
#define szLahf  61
#define szMovsb 62
#define szMovsw 63
#define szCmpsb 64
#define szCmpsw 65
#define szStosb 66
#define szStosw 67
#define szLodsb 68
#define szLodsw 69
#define szScasb 70
#define szScasw 71
#define szRetn  72
#define szLes   73
#define szLds   74
#define szEnter 75
#define szLeave 76
#define szRetf  77
#define szInt3  78
#define szInt   79
#define szInto  80
#define szIret  81
#define szAam   82
#define szAad   83
#define szXlat  84
#define szLoopne 85
#define szLoope 86
#define szLoop  87
#define szJcxz  88
#define szHalt  89
#define szCmc   90
#define szClc   91
#define szStc   92
#define szCli   93
#define szSti   94
#define szCld   95
#define szStd   96
#define szLar   97
#define szLsl   98
#define szClts  99
#define szSeto  100
#define szSetno 101
#define szSetb  102
#define szSetae 103
#define szSete  104
#define szSetne 105
#define szSetbe 106
#define szSeta  107
#define szSets  108
#define szSetns 109
#define szSetp  110
#define szSetnp 111
#define szSetl  112
#define szSetge 113
#define szSetle 114
#define szSetg  115
#define szBt    116
#define szShld  117
#define szBts   118
#define szShrd  119
#define szShdr  120
#define szLss   121
#define szBtr   122
#define szLfs   123
#define szLgs   124
#define szMovzx 125
#define szBtc   126
#define szBsf   127
#define szBsr   128
#define szMovsx 129
#define szNot   130
#define szNeg   131
#define szMul   132
#define szDiv   133
#define szSldt  134
#define szStr   135
#define szLldt  136
#define szLtr   137
#define szVerr  138
#define szVerw  139
#define szSgdt  140
#define szSidt  141
#define szLgdt  142
#define szLidt  143
#define szSmsw  144
#define szLmsw  145

// WARNING: This must stay in sync with the #define list above
char *szInstructions[] = {
    "",     //used to indicate groups
    "adc",
    "add",
    "and",
    "(bad)",
    "cmp",
    "dec",
    "in",
    "inc",
    "jmp",
    // 10
    "mov",
    "or",
    "out",
    "rcl",
    "rcr",
    "rol",
    "ror",
    "sar",
    "sbb",
    "shl",
    // 20
    "shr",
    "sub",
    "test",
    "pop",
    "push",
    "xchg",
    "xor",
    "daa",
    "das",
    "pusha",
    // 30
    "popa",
    "bound",
    "arpl",
    "aaa",
    "aas",
    "imul",
    "idiv",
    "jo",
    "jno",
    "jb",
    // 40
    "jae",
    "je",
    "jne",
    "jbe",
    "ja",
    "js",
    "jns",
    "jp",
    "jnp",
    "jl",
    // 50
    "jnl",
    "jle",
    "jg",
    "nop",
    "lea",
    "cbw",
    "cwd",
    "call",
    "pushf",
    "popf",
    // 60
    "sahf",
    "lahf",
    "movsb",
    "movsw",
    "cmpsb",
    "cmpsw",
    "stosb",
    "stosw",
    "lodsb",
    "lodsw",
    // 70
    "scasb",
    "scasw",
    "retn",
    "les",
    "lds",
    "enter",
    "leave",
    "retf",
    "int3",
    "int",
    // 80
    "into",
    "iret",
    "aam",
    "aad",
    "xlat",
    "loopne",
    "loope",
    "loop",
    "jcxz",
    "halt",
    // 90
    "cmc",
    "clc",
    "stc",
    "cli",
    "sti",
    "cld",
    "std",
    "lar",
    "lsl",
    "clts",
    // 100
    "seto",
    "setno",
    "setb",
    "setae",
    "sete",
    "setne",
    "setbe",
    "seta",
    "sets",
    "setns",
    // 110
    "setp",
    "setnp",
    "setl",
    "setge",
    "setle",
    "setg",
    "bt",
    "shld",
    "bts",
    "shrd",
    // 120
    "shdr",
    "lss",
    "btr",
    "lfs",
    "lgs",
    "movzx",
    "btc",
    "bsf",
    "bsr",
    "movsx",
    // 130
    "not",
    "neg",
    "mul",
    "div",
    "sldt",
    "str",
    "lldt",
    "ltr",
    "verr",
    "verw",
    // 140
    "sgdt",
    "sidt",
    "lgdt",
    "lidt",
    "smsw",
    "lmsw"
};

struct dis {
    int     szName;
    char    iPart1;
    char    iPart2;
    char    iPart3;
};

struct dis dis386[] = {
    // 0
    { szAdd, modrmB, reg1B },
    { szAdd, modrmW, reg1W },
    { szAdd, reg1B, modrmB },
    { szAdd, reg1W, modrmW },
    { szAdd, ALreg, ImmB },
    { szAdd, AXreg, ImmW },
    { szPush, ESreg },
    { szPop, ESreg},
    // 8
    { szOr, modrmB, reg1B },
    { szOr, modrmW, reg1W },
    { szOr, reg1B, modrmB },
    { szOr, reg1W, modrmW },
    { szOr, ALreg, ImmB },
    { szOr, AXreg, ImmW },
    { szPush, CSreg },
    { szBad },                  // 0x0f is the 2-byte instr prefix
    // 10
    { szAdc, modrmB, reg1B },
    { szAdc, modrmW, reg1W },
    { szAdc, reg1B, modrmB },
    { szAdc, reg1W, modrmW },
    { szAdc, ALreg, ImmB },
    { szAdc, AXreg, ImmW },
    { szPush, SSreg },
    { szPop, SSreg },
    // 18
    { szSbb, modrmB, reg1B },
    { szSbb, modrmW, reg1W },
    { szSbb, reg1B, modrmB },
    { szSbb, reg1W, modrmW },
    { szSbb, ALreg, ImmB },
    { szSbb, AXreg, ImmW },
    { szPush, DSreg },
    { szPop, DSreg },
    // 20
    { szAnd, modrmB, reg1B },
    { szAnd, modrmW, reg1W },
    { szAnd, reg1B, modrmB },
    { szAnd, reg1W, modrmW },
    { szAnd, ALreg, ImmB },
    { szAnd, AXreg, ImmW },
    { szBad },                  // ES override prefix
    { szDaa },
    // 28
    { szSub, modrmB, reg1B },
    { szSub, modrmW, reg1W },
    { szSub, reg1B, modrmB },
    { szSub, reg1W, modrmW },
    { szSub, ALreg, ImmB },
    { szSub, AXreg, ImmW },
    { szBad },                  // CS override prefix
    { szDas },
    // 30
    { szXor, modrmB, reg1B },
    { szXor, modrmW, reg1W },
    { szXor, reg1B, modrmB },
    { szXor, reg1W, modrmW },
    { szXor, ALreg, ImmB },
    { szXor, AXreg, ImmW },
    { szBad},                   // SS override prefix
    { szAaa },
    // 38
    { szCmp, modrmB, reg1B },
    { szCmp, modrmW, reg1W },
    { szCmp, reg1B, modrmB },
    { szCmp, reg1W, modrmW },
    { szCmp, ALreg, ImmB },
    { szCmp, AXreg, ImmW },
    { szBad },
    { szAas },
    // 40
    { szInc, AXreg },
    { szInc, CXreg },
    { szInc, DXreg },
    { szInc, BXreg },
    { szInc, SPreg },
    { szInc, BPreg },
    { szInc, SIreg },
    { szInc, DIreg },
    // 48
    { szDec, AXreg },
    { szDec, CXreg },
    { szDec, DXreg },
    { szDec, BXreg },
    { szDec, SPreg },
    { szDec, BPreg },
    { szDec, SIreg },
    { szDec, DIreg },
    // 50
    { szPush, AXreg },
    { szPush, CXreg },
    { szPush, DXreg },
    { szPush, BXreg },
    { szPush, SPreg },
    { szPush, BPreg },
    { szPush, SIreg },
    { szPush, DIreg },
    // 58
    { szPop, AXreg },
    { szPop, CXreg },
    { szPop, DXreg },
    { szPop, BXreg },
    { szPop, SPreg },
    { szPop, BPreg },
    { szPop, SIreg },
    { szPop, DIreg },
    // 60
    { szPusha },
    { szPopa },
    { szBound, reg1W, modrmW },
    { szArpl, reg1W, reg2W },
    { szBad },                  // FS segment override
    { szBad },                  // GS segment override
    { szBad },                  // op size prefix
    { szBad },                  // addr size prefix
    // 68
    { szPush, ImmW},
    { szImul, reg1W, modrmW },
    { szPush, ImmBS},
    { szImul, reg1B, modrmB },
    { szIn, ImmB, DXreg },
    { szIn, ImmW, DXreg },
    { szOut, ImmB, DXreg },
    { szOut, ImmW, DXreg },
    // 70
    { szJo, jmpB },
    { szJno, jmpB },
    { szJb, jmpB },
    { szJae, jmpB },
    { szJe, jmpB },
    { szJne, jmpB },
    { szJbe, jmpB },
    { szJa, jmpB },
    // 78
    { szJs, jmpB },
    { szJns, jmpB },
    { szJp, jmpB },
    { szJnp, jmpB },
    { szJl, jmpB },
    { szJnl, jmpB },
    { szJle, jmpB },
    { szJg, jmpB },
    // 80
    { GROUP_1B },
    { GROUP_1W },
    { szBad },
    { GROUP_1WS },
    { szTest, reg1B, modrmB },
    { szTest, reg1W, modrmW },
    { szXchg, reg1B, modrmB },
    { szXchg, reg1W, modrmW },
    // 88
    { szMov, modrmB, reg1B },
    { szMov, modrmW, reg1W },
    { szMov, reg1B, modrmB  },
    { szMov, reg1W, modrmW },
    { szMov, modrmW, regSeg },
    { szLea, reg1W, modrmW },
    { szMov, regSeg, modrmW },
    { szPop, modrmW },
    // 90
    { szNop },
    { szXchg, AXreg, CXreg },
    { szXchg, AXreg, DXreg },
    { szXchg, AXreg, BXreg },
    { szXchg, AXreg, SPreg },
    { szXchg, AXreg, BPreg },
    { szXchg, AXreg, SIreg },
    { szXchg, AXreg, DIreg },
    // 98
    { szCbw },
    { szCwd },
    { szCall, memD },
    { szBad },
    { szPushf },
    { szPopf },
    { szSahf },
    { szLahf },
    // a0
    { szMov, ALreg, memB },
    { szMov, AXreg, memW },
    { szMov, memB, ALreg },
    { szMov, memW, AXreg },
    { szMovsb },
    { szMovsw },
    { szCmpsb },
    { szCmpsw },
    // a8
    { szTest, ALreg, ImmB },
    { szTest, AXreg, ImmW },
    { szStosb },
    { szStosw },
    { szLodsb },
    { szLodsw },
    { szScasb },
    { szScasw },
    // b0
    { szMov, ALreg, ImmB },
    { szMov, CLreg, ImmB },
    { szMov, DLreg, ImmB },
    { szMov, BLreg, ImmB },
    { szMov, AHreg, ImmB },
    { szMov, CHreg, ImmB },
    { szMov, DHreg, ImmB },
    { szMov, BHreg, ImmB },
    // b8
    { szMov, AXreg, ImmW },
    { szMov, CXreg, ImmW },
    { szMov, DXreg, ImmW },
    { szMov, BXreg, ImmW },
    { szMov, SPreg, ImmW },
    { szMov, BPreg, ImmW },
    { szMov, SIreg, ImmW },
    { szMov, DIreg, ImmW },
    // c0
    { GROUP_2B },
    { GROUP_2W },
    { szRetn, ImmW },
    { szRetn },
    { szLes, reg1W, modrmW },
    { szLds, reg1W, modrmW },
    { szMov, modrmB, ImmB },
    { szMov, modrmW, ImmW },
    // c8
    { szEnter, ImmW, ImmBEnter },
    { szLeave },
    { szRetf, ImmW1 },
    { szRetf },
    { szInt3 },
    { szInt, ImmB },
    { szInto },
    { szIret },
    // d0
    { GROUP_2B_1 },
    { GROUP_2W_1 },
    { GROUP_2B_CL },
    { GROUP_2W_CL },
    { szAam, ImmB },
    { szAad, ImmB },
    { szBad },
    { szXlat },
    // d8
    { FLOAT },
    { FLOAT },
    { FLOAT },
    { FLOAT },
    { FLOAT },
    { FLOAT },
    { FLOAT },
    { FLOAT },
    // e0
    { szLoopne, jmpB },
    { szLoope, jmpB },
    { szLoop, jmpB },
    { szJcxz, jmpB },
    { szIn, ALreg, memB1 },
    { szIn, AXreg, memB1 },
    { szOut, memB1, ALreg },
    { szOut, memB1, AXreg },
    // e8
    { szCall, jmpW },
    { szJmp, jmpW },
    { szJmp, memD },
    { szJmp, jmpB },
    { szIn, ALreg, DXreg },
    { szIn, AXreg, DXreg },
    { szOut, DXreg, ALreg },
    { szOut, DXreg, AXreg },
    // f0
    { szBad },      // lock prefix
    { szBad },
    { szBad },      // repne prefix
    { szBad },      // repz prefix
    { szHalt },
    { szCmc },
    { GROUP_3B },
    { GROUP_3W },
    // f8
    { szClc },
    { szStc },
    { szCli },
    { szSti },
    { szCld },
    { szStd },
    { GROUP_4 },
    { GROUP_5 },
};


struct dis dis386_2[] = {
    // 00
    { GROUP_6 },
    { GROUP_7 },
    { szLar, reg1W, modrmW },
    { szLsl, reg1W, modrmW },
    { szBad },
    { szBad },
    { szClts },
    { szBad },
    // 08
    { szBad },
    { szBad },
    { szBad },
    { szBad },
    { szBad },
    { szBad },
    { szBad },
    { szBad },
    // 10
    { szBad },
    { szBad },
    { szBad },
    { szBad },
    { szBad },
    { szBad },
    { szBad },
    { szBad },
    // 18
    { szBad },
    { szBad },
    { szBad },
    { szBad },
    { szBad },
    { szBad },
    { szBad },
    { szBad },
    // 20
    { szMov, reg2W, eeeControl },
    { szMov, reg2W, eeeDebug },
    { szMov, eeeControl, reg2W },
    { szMov, eeeDebug, reg2W },
    { szMov, reg2W, eeeTest },
    { szBad },
    { szMov, eeeTest, reg2W },
    { szBad },
    // 28
    { szBad },
    { szBad },
    { szBad },
    { szBad },
    { szBad },
    { szBad },
    { szBad },
    { szBad },
    // 30
    { szBad },
    { szBad },
    { szBad },
    { szBad },
    { szBad },
    { szBad },
    { szBad },
    { szBad },
    // 38
    { szBad },
    { szBad },
    { szBad },
    { szBad },
    { szBad },
    { szBad },
    { szBad },
    { szBad },
    // 40
    { szBad },
    { szBad },
    { szBad },
    { szBad },
    { szBad },
    { szBad },
    { szBad },
    { szBad },
    // 48
    { szBad },
    { szBad },
    { szBad },
    { szBad },
    { szBad },
    { szBad },
    { szBad },
    { szBad },
    // 50
    { szBad },
    { szBad },
    { szBad },
    { szBad },
    { szBad },
    { szBad },
    { szBad },
    { szBad },
    // 58
    { szBad },
    { szBad },
    { szBad },
    { szBad },
    { szBad },
    { szBad },
    { szBad },
    { szBad },
    // 60
    { szBad },
    { szBad },
    { szBad },
    { szBad },
    { szBad },
    { szBad },
    { szBad },
    { szBad },
    // 68
    { szBad },
    { szBad },
    { szBad },
    { szBad },
    { szBad },
    { szBad },
    { szBad },
    { szBad },
    // 70
    { szBad },
    { szBad },
    { szBad },
    { szBad },
    { szBad },
    { szBad },
    { szBad },
    { szBad },
    // 78
    { szBad },
    { szBad },
    { szBad },
    { szBad },
    { szBad },
    { szBad },
    { szBad },
    { szBad },
    // 80
    { szJo, jmpW },
    { szJno, jmpW },
    { szJb, jmpW },
    { szJae, jmpW },
    { szJe, jmpW },
    { szJne, jmpW },
    { szJbe, jmpW },
    { szJa, jmpW },
    // 88
    { szJs, jmpW },
    { szJns, jmpW },
    { szJp, jmpW },
    { szJnp, jmpW },
    { szJl, jmpW },
    { szJnl, jmpW },
    { szJle, jmpW },
    { szJg, jmpW },
    // 90
    { szSeto, modrmB },
    { szSetno, modrmB },
    { szSetb, modrmB },
    { szSetae, modrmB },
    { szSete, modrmB },
    { szSetne, modrmB },
    { szSetbe, modrmB },
    { szSeta, modrmB },
    // 98
    { szSets, modrmB },
    { szSetns, modrmB },
    { szSetp, modrmB },
    { szSetnp, modrmB },
    { szSetl, modrmB },
    { szSetge, modrmB },
    { szSetle, modrmB },
    { szSetg, modrmB },
    // a0
    { szPush, FSreg },
    { szPop, FSreg },
    { szBad },
    { szBt, modrmW, reg1W },
    { szShld, reg1W, modrmW, ImmB },
    { szShld, reg1W, modrmW, CLreg },
    { szBad },
    { szBad },
    // a8
    { szPush, GSreg },
    { szPop, GSreg },
    { szBad },
    { szBts, modrmW, reg1W },
    { szShrd, reg1W, modrmW, ImmB },
    { szShdr, reg1W, modrmW, CLreg },
    { szBad },
    { szImul, reg1W, modrmW },
    // b0
    { szBad },
    { szBad },
    { szLss, reg1W, modrmW },
    { szBtr, modrmW, reg1W },
    { szLfs, reg1W, modrmW },
    { szLgs, reg1W, modrmW },
    { szMovzx, reg1B, modrmB },
    { szMovzx, reg1W, modrmW },
    // b8
    { szBad },
    { szBad },
    { GROUP_8 },
    { szBtc, modrmW, reg1W },
    { szBsf, reg1W, modrmW },
    { szBsr, reg1W, modrmW },
    { szMovsx, reg1B, modrmB },
    { szMovsx, reg1W, modrmW },
    // c0
    { szBad },
    { szBad },
    { szBad },
    { szBad },
    { szBad },
    { szBad },
    { szBad },
    { szBad },
    // c8
    { szBad },
    { szBad },
    { szBad },
    { szBad },
    { szBad },
    { szBad },
    { szBad },
    { szBad },
    // d0
    { szBad },
    { szBad },
    { szBad },
    { szBad },
    { szBad },
    { szBad },
    { szBad },
    { szBad },
    // d8
    { szBad },
    { szBad },
    { szBad },
    { szBad },
    { szBad },
    { szBad },
    { szBad },
    { szBad },
    // e0
    { szBad },
    { szBad },
    { szBad },
    { szBad },
    { szBad },
    { szBad },
    { szBad },
    { szBad },
    // e8
    { szBad },
    { szBad },
    { szBad },
    { szBad },
    { szBad },
    { szBad },
    { szBad },
    { szBad },
    // f0
    { szBad },
    { szBad },
    { szBad },
    { szBad },
    { szBad },
    { szBad },
    { szBad },
    { szBad },
    // f8
    { szBad },
    { szBad },
    { szBad },
    { szBad },
    { szBad },
    { szBad },
    { szBad },
    { szBad },
};

struct dis dis386_groups[][8] = {
    // GROUP_1B
    {
        { szAdd, modrmB, ImmB },
        { szOr,  modrmB, ImmB },
        { szAdc, modrmB, ImmB },
        { szSbb, modrmB, ImmB },
        { szAnd, modrmB, ImmB },
        { szSub, modrmB, ImmB },
        { szXor, modrmB, ImmB },
        { szCmp, modrmB, ImmB }
    },
    // GROUP_1WS
    {
        { szAdd, modrmW, ImmBS },
        { szOr,  modrmW, ImmBS },
        { szAdc, modrmW, ImmBS },
        { szSbb, modrmW, ImmBS },
        { szAnd, modrmW, ImmBS },
        { szSub, modrmW, ImmBS },
        { szXor, modrmW, ImmBS },
        { szCmp, modrmW, ImmBS }
    },
    // GROUP_1W
    {
        { szAdd, modrmW, ImmW },
        { szOr,  modrmW, ImmW },
        { szAdc, modrmW, ImmW },
        { szSbb, modrmW, ImmW },
        { szAnd, modrmW, ImmW },
        { szSub, modrmW, ImmW },
        { szXor, modrmW, ImmW },
        { szCmp, modrmW, ImmW }
    },
    // GROUP_2B
    {
        { szRol, modrmB, ImmB },
        { szRor, modrmB, ImmB },
        { szRcl, modrmB, ImmB },
        { szRcr, modrmB, ImmB },
        { szShl, modrmB, ImmB },
        { szShr, modrmB, ImmB },
        { szBad },
        { szSar, modrmB, ImmB }
    },
    // GROUP_2W
    {
        { szRol, modrmW, ImmB },
        { szRor, modrmW, ImmB },
        { szRcl, modrmW, ImmB },
        { szRcr, modrmW, ImmB },
        { szShl, modrmW, ImmB },
        { szShr, modrmW, ImmB },
        { szBad },
        { szSar, modrmW, ImmB }
    },
    // GROUP_2B_1
    {
        { szRol, modrmB },
        { szRor, modrmB },
        { szRcl, modrmB },
        { szRcr, modrmB },
        { szShl, modrmB },
        { szShr, modrmB },
        { szBad },
        { szSar, modrmB }
    },
    // GROUP_2W_1
    {
        { szRol, modrmW },
        { szRor, modrmW },
        { szRcl, modrmW },
        { szRcr, modrmW },
        { szShl, modrmW },
        { szShr, modrmW },
        { szBad },
        { szSar, modrmW }
    },
    // GROUP_2B_CL
    {
        { szRol, modrmB, CLreg },
        { szRor, modrmB, CLreg },
        { szRcl, modrmB, CLreg },
        { szRcr, modrmB, CLreg },
        { szShl, modrmB, CLreg },
        { szShr, modrmB, CLreg },
        { szBad },
        { szSar, modrmB, CLreg }
    },
    // GROUP_2W_CL
    {
        { szRol, modrmW, CLreg },
        { szRor, modrmW, CLreg },
        { szRcl, modrmW, CLreg },
        { szRcr, modrmW, CLreg },
        { szShl, modrmW, CLreg },
        { szShr, modrmW, CLreg },
        { szBad },
        { szSar, modrmW, CLreg }
    },
    // GROUP_3B
    {
        { szTest, modrmB, ImmB },
        { szBad },
        { szNot, modrmB },
        { szNeg, modrmB },
        { szMul, ALreg, modrmB },
        { szImul, ALreg, modrmB },
        { szDiv, ALreg, modrmB },
        { szIdiv, ALreg, modrmB }
    },
    // GROUP_3W
    {
        { szTest, modrmW, ImmW },
        { szBad },
        { szNot, modrmW },
        { szNeg, modrmW },
        { szMul, AXreg, modrmW },
        { szImul, AXreg, modrmW },
        { szDiv, AXreg, modrmW },
        { szIdiv, AXreg, modrmW }
    },
    // GROUP_4
    {
        { szInc, modrmB },
        { szDec, modrmB },
        { szBad },
        { szBad },
        { szBad },
        { szBad },
        { szBad },
        { szBad }
    },
    // GROUP_5
    {
        { szInc, modrmW },
        { szDec, modrmW },
        { szCall, indirmodrmW },
        { szCall, indirFARmodrmW },
        { szJmp, indirmodrmW },
        { szJmp, indirFARmodrmW },
        { szPush, modrmW },
        { szBad }
    },
    // GROUP_6
    {
        { szSldt, modrmW },
        { szStr, modrmW },
        { szLldt, modrmW },
        { szLtr, modrmW },
        { szVerr, modrmW },
        { szVerw, modrmW },
        { szBad },
        { szBad }
    },
    // GROUP_7
    {
        { szSgdt, modrmW },
        { szSidt, modrmW },
        { szLgdt, modrmW },
        { szLidt, modrmW },
        { szSmsw, modrmW },
        { szBad },
        { szLmsw, modrmW },
        { szBad }
    },
    // GROUP_8
    {
        { szBad },
        { szBad },
        { szBad },
        { szBad },
        { szBt, modrmW, ImmB },
        { szBts, modrmW, ImmB },
        { szBtr, modrmW, ImmB },
        { szBtc, modrmW, ImmB }
    }
};

UCHAR OpcodeSize;
BYTE *pData;
ADDR g_InstrAddr;
BOOL bBig;

void AppendString(char *str)
{
    strcpy(g_pchOutput, (str));
    g_pchOutput+=strlen(g_pchOutput);
}

void ExtraString(char *str)
{
    strcpy(g_pchExtra, (str));
    g_pchExtra+=strlen(g_pchExtra);
}

#define AppendChar(c)      {*g_pchOutput++ = (c);}
#define AppendNumber(d) {_ultoa((ULONG)d,g_pchOutput, 16); g_pchOutput+=strlen(g_pchOutput);}

#define ExtraChar(c)       {*g_pchExtra++ = (c);}
#define ExtraNumber(d)     {_ultoa((ULONG)d,g_pchExtra, 16); g_pchExtra+=strlen(g_pchExtra);}
#define OPERAND_32 ((prefixes & PREFIX_DATA) ^ bBig)
#define ADDR_32 ((prefixes & PREFIX_ADR) ^ bBig)

int unassemble_one(
    BYTE        *pInstrStart,   // instruction to decode (can be local buffer)
    BOOL            bDefaultBig,
    WORD            wInstrSeg,      // selector of instruction
    DWORD       dwInstrOff,     // offset of instruction
    char        *pchOutput,     // [out] disassembled instruction
    char        *pchExtra,      // [out] extra info (ie. "es:[53]=1234")
                                //       (can be NULL)
    VDMCONTEXT  *pThreadContext,
    int         mode
) {
    int         i;
    int         cb;
    BYTE        *pInstr = pInstrStart;
    struct dis      *pszDecode;

    g_pThreadContext = pThreadContext;
    g_mode = mode;

    g_pchOutput = pchOutput;
    g_InstrAddr.sSeg = wInstrSeg;
    g_InstrAddr.sOff = dwInstrOff;
    bBig = bDefaultBig;

    gMode = mode;
    gSelector = wInstrSeg;
    gOffset = dwInstrOff;

    if (pchExtra)
        *pchExtra = '\0';

    g_pchExtra = pchExtra;

    if (*(UNALIGNED USHORT*)pInstr == 0xc4c4) {
        pData = pInstr;
        pData+=2;
        return DisplayBOP();
    }

    pInstr = checkprefixes(pInstr);

    OpcodeSize = 1;

    if (*pInstr == 0x0f) {
        OpcodeSize++;
        pInstr++;
        pszDecode = &dis386_2[*pInstr];
    } else {
        pszDecode = &dis386[*pInstr];
    }

    if (prefixes & PREFIX_REPZ)
        AppendString("repz ");
    if (prefixes & PREFIX_REPNZ)
        AppendString("repnz ");
    if (prefixes & PREFIX_LOCK)
        AppendString("lock ");
    if ((prefixes & PREFIX_FWAIT) && ((*pInstr < 0xd8) || (*pInstr > 0xdf))) {
        /* fwait not followed by floating point instruction */
        AppendString("fwait");
        return (1);
    }

    pInstr++;
    pData = pInstr;
    if (pszDecode->szName < 0) {    // found a GROUP_ or FLOAT entry...
        i = (-pszDecode->szName)-1;
        if (pszDecode->szName == FLOATCODE) {
            AppendString("*float* ");
            //Later: mputs("Floating point instructions NYI\n");
            return 1;
        } else {
            pszDecode = &dis386_groups[i][(*pInstr>>3)&7];
        }
    }

    AppendString(szInstructions[pszDecode->szName]);

    if (pszDecode->iPart1) {

        AppendChar('\t');

        i = (*(rgpfn[pszDecode->iPart1].pfn))(pInstr);

        if (pszDecode->iPart2) {

            AppendString(", ");
            i+=(*(rgpfn[pszDecode->iPart2].pfn))(pInstr);

            if (pszDecode->iPart3) {

                AppendString(", ");
                i+=(*(rgpfn[pszDecode->iPart3].pfn))(pInstr);

            }
        }

        pInstr+=i;
    }

    AppendChar('\0');
    cb = pInstr - pInstrStart;    // return length of instruction

    return cb;
}

BOOL safe_read_byte(
    ADDR        addr,
    BYTE        *pb
) {
    ULONG       Base;

    *pb = 0xbb;
    Base = GetInfoFromSelector( addr.sSeg, g_mode, NULL );
    if (Base == (ULONG)-1 || Base == 0) {
    return FALSE;
    }

    Base += GetIntelBase();

    return READMEM((LPVOID)(Base+(ULONG)addr.sOff), pb, 1);
}

BOOL safe_read_short(
    ADDR        addr,
    SHORT       *ps
) {
    ULONG       Base;

    Base = GetInfoFromSelector( addr.sSeg, g_mode, NULL );
    if (Base == (ULONG)-1 || Base == 0) {
    return FALSE;
    }

    Base += GetIntelBase();

    return READMEM((LPVOID)(Base+(ULONG)addr.sOff), ps, 2);
}

BOOL safe_read_long(
    ADDR        addr,
    LONG        *pl
) {
    ULONG       Base;

    Base = GetInfoFromSelector( addr.sSeg, g_mode, NULL );
    if (Base == (ULONG)-1 || Base == 0) {
    return FALSE;
    }

    Base += GetIntelBase();

    return READMEM((LPVOID)(Base+(ULONG)addr.sOff), pl, 4);
}


int Dreg1B(LPBYTE lpB)
{
    BYTE b = (*lpB >> 3) & 7;

    AppendString(szRegsB[b]);

    return 0;
}

int Dreg1W(LPBYTE lpB)
{
    BYTE b = (*lpB >> 3) & 7;

    if (OPERAND_32)
        AppendString(szRegsD[b]);
    else
        AppendString(szRegsW[b]);

    return 0;
}

int Dreg2B(LPBYTE lpB)
{
    BYTE b = *lpB & 7;

    AppendString(szRegsB[b]);

    return 0;
}

int Dreg2W(LPBYTE lpB)
{
    BYTE b = *lpB & 7;

    if (OPERAND_32)
        AppendString(szRegsD[b]);
    else
        AppendString(szRegsW[b]);

    return 0;
}

int DmodrmB(LPBYTE lpB)
{
    BYTE rm = *lpB & 0x07;
    BYTE mod = *lpB >> 6;
    unsigned short num;
    int iRet;

    pData++;                                // skip past mod r/m
    if (mod == 3) {
        AppendPrefixes();
        AppendString(szRegsB[rm]);
        return 1;
    }

    iRet = 0;
    AppendString("byte ptr ");
    AppendPrefixes();
    AppendString(szMod[rm]);
    AppendChar('+');

    switch (mod) {
        case 0:
            if (rm == 6) {
                g_pchOutput-=3; // back up over the 'BP+'
                num = *((UNALIGNED USHORT*)pData);
                AppendNumber(num);
                pData+=2;
                iRet = 3;
            } else {
                num = 0;
                g_pchOutput--;
                iRet = 1;
            }
            break;

        case 1:
            num = *pData;
            AppendNumber(num);
            pData++;
            iRet = 2;
            break;

        case 2:
            num = *((UNALIGNED USHORT*)pData);
            AppendNumber(num);
            pData += 2;
            iRet = 3;
            break;
    }

    AppendChar(']');

    DisplayAddress(mod, rm, num, 1);

    return iRet;
}

int DmodrmW(LPBYTE lpB)
{
    BYTE rm = *lpB & 0x07;
    BYTE mod = *lpB >> 6;
    ULONG num;
    int iRet;

    pData++;                                // skip past mod r/m
    AppendPrefixes();

    if (mod == 3) {
        if (OPERAND_32)
            AppendString(szRegsD[rm]);
        else
            AppendString(szRegsW[rm]);
        return 1;
    }

    if (ADDR_32) {
        AppendChar('[');
        AppendString(szRegsD[rm]);
    } else {
        AppendString(szMod[rm]);
    }
    AppendChar('+');

    switch (mod) {
        case 0:
            //
            // Handle special cases of ModRM
            //
            if ((rm == 6) && !ADDR_32) {
                g_pchOutput-=3; // back up over 'BP+'
                num = *((UNALIGNED USHORT*)pData);
                AppendNumber(num);
                pData+=2;
                iRet = 3;
            } else if ((rm == 5) && ADDR_32) {
                g_pchOutput-=4; // back up over 'EBP+'
                num = *((UNALIGNED ULONG*)pData);
                AppendNumber(num);
                pData+=4;
                iRet = 5;
            } else {
                g_pchOutput--;  // else back up over '+' alone
                num=0;
                iRet = 1;
            }
            break;

        case 1:
            num = *pData;
            AppendNumber(num);
            pData++;
            iRet = 2;
            break;

        case 2:
            num = *((UNALIGNED USHORT *)pData);
            AppendNumber(num);
            pData+=2;
            iRet = 3;
            break;
    }

    AppendChar(']');

    DisplayAddress(mod, rm, num, ADDR_32 ? 4 : 2);

    return iRet;
}


void DisplayAddress(int mod, int rm, int sOff, int size)
{
    ADDR addr;

    // if caller of unassemble_one() didn't want extra info, return now
    if (g_pchExtra == NULL)
    return;

    // no memory reference
    if (mod == 3)
    return;

    // display prefix

    if (prefixes & PREFIX_DS) {
    ExtraChar('D');
    addr.sSeg = (USHORT)g_pThreadContext->SegDs;
    } else if (prefixes & PREFIX_ES) {
    ExtraChar('E');
    addr.sSeg = (USHORT)g_pThreadContext->SegEs;
    } else if (prefixes & PREFIX_FS) {
    ExtraChar('F');
    addr.sSeg = (USHORT)g_pThreadContext->SegFs;
    } else if (prefixes & PREFIX_GS) {
    ExtraChar('G');
    addr.sSeg = (USHORT)g_pThreadContext->SegGs;
    } else if (prefixes & PREFIX_CS) {
    ExtraChar('C');
    addr.sSeg = (USHORT)g_pThreadContext->SegCs;
    } else if ( (prefixes & PREFIX_SS) || rm==2 || rm == 3) {
    ExtraChar('S');
    addr.sSeg = (USHORT)g_pThreadContext->SegSs;
    } else if (rm == 6 && mod != 0) {
    ExtraChar('S');
    addr.sSeg = (USHORT)g_pThreadContext->SegSs;
    } else {
    ExtraChar('D');
    addr.sSeg = (USHORT)g_pThreadContext->SegDs;
    }

    ExtraString("S:[");

    switch (rm) {
    case 0:
        addr.sOff = (USHORT)(g_pThreadContext->Ebx + g_pThreadContext->Esi);
        break;

    case 1:
        addr.sOff = (USHORT)(g_pThreadContext->Ebx + g_pThreadContext->Edi);
        break;

    case 2:
        addr.sOff = (USHORT)(g_pThreadContext->Ebp + g_pThreadContext->Esi);
        break;

    case 3:
        addr.sOff = (USHORT)(g_pThreadContext->Ebp + g_pThreadContext->Edi);
        break;

    case 4:
        addr.sOff = (USHORT)g_pThreadContext->Esi;
        break;

    case 5:
        addr.sOff = (USHORT)g_pThreadContext->Edi;
        break;

    case 6:
        if (mod == 0)
        addr.sOff = 0;
        else
        addr.sOff = (USHORT)g_pThreadContext->Ebp;
        break;

    default:
        addr.sOff = (USHORT)g_pThreadContext->Ebx;

    }

    addr.sOff += sOff;
    ExtraNumber(addr.sOff);
    ExtraString("]=");
    if (size == 2) {
    SHORT s;
    if (safe_read_short(addr, &s)) {
        ExtraNumber( s );
    } else {
        ExtraString("????");
    }
    } else if (size == 1) {
    BYTE b;
    if (safe_read_byte(addr, &b)) {
        ExtraNumber( b );
    } else {
        ExtraString("??");
    }
    } else if (size == 4) {
    LONG l;
    if (safe_read_long(addr, &l)) {
        ExtraNumber( l );
    } else {
        ExtraString("????????");
    }
    } else {
    ExtraString("Unknown size!");
    }
}

int DisplayBOP(void)
{
    UCHAR mjcode;
    int InstSize = 3;

    AppendString("BOP   ");

    mjcode = *((UCHAR *)pData);
    pData++;
    AppendNumber(mjcode);

    switch (mjcode) {
    case 0x50:
    case 0x52:
    case 0x53:
    case 0x54:
    case 0x58:
        //
        // This BOP has a minor function code
        //
        InstSize++;
        AppendString(", ");
        AppendNumber(*((UCHAR *)pData));
    }
    return InstSize;
}

int DALreg(LPBYTE lpB)
{
    AppendString("al");

    return 0;
}

int DAHreg(LPBYTE lpB)
{
    AppendString("ah");

    return 0;
}

int DBLreg(LPBYTE lpB)
{
    AppendString("bl");

    return 0;
}

int DBHreg(LPBYTE lpB)
{
    AppendString("bh");

    return 0;
}

int DCLreg(LPBYTE lpB)
{
    AppendString("cl");

    return 0;
}

int DCHreg(LPBYTE lpB)
{
    AppendString("ch");

    return 0;
}

int DDLreg(LPBYTE lpB)
{
    AppendString("dl");

    return 0;
}

int DDHreg(LPBYTE lpB)
{
    AppendString("dh");

    return 0;
}

int DAXreg(LPBYTE lpB)
{
    if (OPERAND_32)
        AppendChar('e');

    AppendString("ax");

    return 0;
}

int DBXreg(LPBYTE lpB)
{
    if (OPERAND_32)
        AppendChar('e');

    AppendString("bx");

    return 0;
}

int DCXreg(LPBYTE lpB)
{
    if (OPERAND_32)
        AppendChar('e');

    AppendString("cx");

    return 0;
}

int DDXreg(LPBYTE lpB)
{
    if (OPERAND_32)
        AppendChar('e');

    AppendString("dx");

    return 0;
}

int DBPreg(LPBYTE lpB)
{
    if (OPERAND_32)
        AppendChar('e');

    AppendString("bp");

    return 0;
}

int DSPreg(LPBYTE lpB)
{
    if (OPERAND_32)
        AppendChar('e');

    AppendString("sp");

    return 0;
}

int DSIreg(LPBYTE lpB)
{
    if (OPERAND_32)
        AppendChar('e');

    AppendString("si");

    return 0;
}

int DDIreg(LPBYTE lpB)
{
    if (OPERAND_32)
        AppendChar('e');

    AppendString("di");

    return 0;
}

int DCSreg(LPBYTE lpB)
{
    AppendString("cs");

    return 0;
}

int DDSreg(LPBYTE lpB)
{
    AppendString("ds");

    return 0;
}

int DSSreg(LPBYTE lpB)
{
    AppendString("es");

    return 0;
}

int DESreg(LPBYTE lpB)
{
    AppendString("es");

    return 0;
}

int DFSreg(LPBYTE lpB)
{
    AppendString("fs");

    return 0;
}

int DGSreg(LPBYTE lpB)
{
    AppendString("gs");

    return 0;
}

int DImmB(LPBYTE lpB)
{
    AppendNumber(*((UCHAR *)pData));
    pData++;

    return 1;
}

int DImmBEnter(LPBYTE lpB)
{
    AppendNumber(*((UCHAR *)pData));
    pData++;

    return 1;
}

int DImmBS(LPBYTE lpB)  // sign-extend 8-bit value to 16 bits
{
    int i = (signed char)*(pData);

    AppendNumber((USHORT)i);
    pData++;

    return 1;
}

int DImmW(LPBYTE lpB)
{
    if (OPERAND_32) {

            AppendNumber( *((UNALIGNED ULONG*)pData) );
            pData+=4;
            return 4;

        } else {

            AppendNumber( *((UNALIGNED USHORT*)pData) );
            pData+=2;
            return 2;

        }
}

int DImmW1(LPBYTE lpB)
{
    AppendNumber( *((UNALIGNED SHORT*)(pData)) );
    pData++;

    return 2;
}

int DjmpB(LPBYTE lpB)
{
    ULONG Dest = g_InstrAddr.sOff + (LONG)*((UNALIGNED CHAR *)lpB) + OpcodeSize + 1;

    if (OPERAND_32) {
        AppendNumber(Dest);
    } else {
        AppendNumber((USHORT)Dest);
    }

    return 1;
}

int DjmpW(LPBYTE lpB)
{

    if (OPERAND_32) {
        AppendNumber(g_InstrAddr.sOff + *((UNALIGNED ULONG *)lpB) + OpcodeSize + 4);
        return 4;
    } else {
        AppendNumber(LOWORD(g_InstrAddr.sOff + (ULONG)*((UNALIGNED USHORT *)lpB) + OpcodeSize + 2));
        return 2;
    }
}

int DregSeg(LPBYTE lpB)
{
    BYTE b = (*lpB >> 3) & 7;

    AppendString(szRegsSeg[b]);

    return 0;
}


int DmemB(LPBYTE lpB)
{
    ADDR addr;

    addr.sOff = *(lpB+1);

    AppendChar('[');
    AppendNumber( addr.sOff );
    AppendChar(']');

    if (g_pchExtra) {
        BYTE b;

        if (prefixes & PREFIX_DS) {
            ExtraChar('D');
            addr.sSeg = (USHORT)g_pThreadContext->SegDs;
        } else if (prefixes & PREFIX_ES) {
            ExtraChar('E');
            addr.sSeg = (USHORT)g_pThreadContext->SegEs;
        } else if (prefixes & PREFIX_FS) {
            ExtraChar('F');
            addr.sSeg = (USHORT)g_pThreadContext->SegFs;
        } else if (prefixes & PREFIX_GS) {
            ExtraChar('G');
            addr.sSeg = (USHORT)g_pThreadContext->SegGs;
        } else if (prefixes & PREFIX_CS) {
            ExtraChar('C');
            addr.sSeg = (USHORT)g_pThreadContext->SegCs;
        } else if (prefixes & PREFIX_SS) {
            ExtraChar('S');
            addr.sSeg = (USHORT)g_pThreadContext->SegSs;
        } else {
            ExtraChar('D');
            addr.sSeg = (USHORT)g_pThreadContext->SegDs;
        }

        ExtraString("S:[");
        ExtraNumber( addr.sOff );
        ExtraString("]=");
        if (safe_read_byte(addr, &b)) {
            ExtraNumber( b );
        } else {
            ExtraString("??");
        }

    }

    return 1;
}

int DmemB1(LPBYTE lpB)
{
    AppendNumber( *lpB );

    return 1;
}

int DmemW(LPBYTE lpB)
{
    int i;
    ADDR addr;

    addr.sOff = *(lpB+1);

    AppendChar('[');
    if (ADDR_32) {
        AppendNumber( *((UNALIGNED long*)lpB) );
        i=4;
    } else {
        addr.sOff = *((UNALIGNED short *)lpB);
        AppendNumber( addr.sOff );
        i=2;
    }
    AppendChar(']');

    if (g_pchExtra) {

        if (prefixes & PREFIX_DS) {
            ExtraChar('D');
            addr.sSeg = (USHORT)g_pThreadContext->SegDs;
        } else if (prefixes & PREFIX_ES) {
            ExtraChar('E');
            addr.sSeg = (USHORT)g_pThreadContext->SegEs;
        } else if (prefixes & PREFIX_FS) {
            ExtraChar('F');
            addr.sSeg = (USHORT)g_pThreadContext->SegFs;
        } else if (prefixes & PREFIX_GS) {
            ExtraChar('G');
            addr.sSeg = (USHORT)g_pThreadContext->SegGs;
        } else if (prefixes & PREFIX_CS) {
            ExtraChar('C');
            addr.sSeg = (USHORT)g_pThreadContext->SegCs;
        } else if (prefixes & PREFIX_SS) {
            ExtraChar('S');
            addr.sSeg = (USHORT)g_pThreadContext->SegSs;
        } else {
            ExtraChar('D');
            addr.sSeg = (USHORT)g_pThreadContext->SegDs;
        }

        ExtraString("S:[");
        ExtraNumber( addr.sOff );
        ExtraString("]=");
        if (i == 2) {
            SHORT s;
            if (safe_read_short(addr, &s)) {
                ExtraNumber( s );
            } else {
                ExtraString( "????" );
            }
        } else {
            LONG l;

            if (safe_read_long(addr, &l)) {
                ExtraNumber( l );
            } else {
                ExtraString( "????????" );
            }
        }
    }

    return i;
}


int DmemD(LPBYTE lpB)
{
    int i;

    if (OPERAND_32) {
        AppendNumber( *(((UNALIGNED SHORT*)lpB)+2) );
        AppendChar(':');
        AppendNumber( *((UNALIGNED long*)lpB) );
        i=6;
    } else {
        USHORT sel, off;

        sel = *(((UNALIGNED SHORT*)lpB)+1);
        off = *((UNALIGNED SHORT*)lpB);
        AppendNumber( sel );
        AppendChar(':');
        AppendNumber( off );
        i=4;

        if (g_pchExtra) {
            char sym_text[1000];
            LONG dist;

            // if the exact symbol name was found, print it
            if (FindSymbol(   sel,
                   off,
                   sym_text,
                   &dist,
                   BEFORE,
                   g_mode)) {
                ExtraString("= ");
                ExtraString(sym_text);
                if (dist) {
                    ExtraString(" + ");
                    ExtraNumber( dist );
                }
            }
        }

    }

    return i;
}

int DindirmodrmW(LPBYTE lpB)
{
    int i;

    AppendString("FAR PTR ");
    i = DmodrmW(lpB);
    AppendChar(']');

    return i;
}


int DindirFARmodrmW(LPBYTE lpB)
{
    int i;

    AppendString("FAR PTR ");
    i = DmodrmW(lpB);
    AppendChar(']');

    return i;
}


int DeeeControl(LPBYTE lpB)
{
    AppendChar('c');
    AppendChar('r');
    AppendChar('0'+ ((*lpB >> 3) & 7) );

    return 1;
}

int DeeeDebug(LPBYTE lpB)
{
    AppendChar('d');
    AppendChar('r');
    AppendChar('0'+ ((*lpB >> 3) & 7) );

    return 1;
}

int DeeeTest(LPBYTE lpB)
{
    AppendChar('t');
    AppendChar('r');
    AppendChar('0'+ ((*lpB >> 3) & 7) );

    return 1;
}


LPBYTE checkprefixes(LPBYTE lpB)
{
    prefixes = 0;

    for (;;) {

        switch (*lpB) {
            case 0xf3:
                prefixes |= PREFIX_REPZ;
                break;
            case 0xf2:
                prefixes |= PREFIX_REPNZ;
                break;
            case 0xf0:
                prefixes |= PREFIX_LOCK;
                break;
            case 0x2e:
                prefixes |= PREFIX_CS;
                break;
            case 0x36:
                prefixes |= PREFIX_SS;
                break;
            case 0x3e:
                prefixes |= PREFIX_DS;
                break;
            case 0x26:
                prefixes |= PREFIX_ES;
                break;
            case 0x64:
                prefixes |= PREFIX_FS;
                break;
            case 0x65:
                prefixes |= PREFIX_GS;
                break;
            case 0x66:
                prefixes |= PREFIX_DATA;
                break;
            case 0x67:
                prefixes |= PREFIX_ADR;
                break;
            case 0x9b:
                prefixes |= PREFIX_FWAIT;
                break;
            default:
                return lpB;
        }
    lpB++;
    }
}


void AppendPrefixes(void)
{
    if (prefixes & PREFIX_CS)
        AppendString("cs:");
    if (prefixes & PREFIX_DS)
        AppendString("ds:");
    if (prefixes & PREFIX_SS)
        AppendString("ss:");
    if (prefixes & PREFIX_ES)
        AppendString("es:");
    if (prefixes & PREFIX_FS)
        AppendString("fs:");
    if (prefixes & PREFIX_GS)
        AppendString("gs:");
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\vdmexts\help.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    help.c

Abstract:

    This module dumps out help info for VDMEXTS

Author:

    Neil Sandlin (NeilSa) 15-Jan-1996

Notes:


Revision History:

--*/

#include <precomp.h>
#pragma hdrstop

CHAR szAPIUSAGE[] = "Usage: !vdmexts.APIProfDmp [TblName] [APIspec]\n\n   where: TblName = kernel | user | gdi | keyboard | sound | shell | mmed\n                         (no TblName implies 'all tables')\n\n          APIspec = API # or API name";
CHAR szMSGUSAGE[] = "Usage: !vdmexts.MsgProfDmp [MessageName | MessageNum (decimal)]\n                         (no argument implies 'all messages')";

VOID
helpAPIProfDmp(
    VOID
    )
{
    PRINTF("\n\n%s\n", szAPIUSAGE);
}

VOID
helpMsgProfDmp(
    VOID
    )
{
    PRINTF("\n\n%s\n", szMSGUSAGE);
}


VOID
helpFilter(
    VOID
    )
{
    PRINTF("Usage: filter <option> <arg>\n\n");
    PRINTF(" where <option>=\n");
    PRINTF("<none>         - Dump current state\n");
    PRINTF("*              - Disables logging on all API classes\n");
    PRINTF("Reset          - Filter is reset to default state\n");
    PRINTF("CallId xxxx    - Adds api with given callid to list to be filtered\n");
    PRINTF("Task xxxx      - Filter on a Specific TaskID\n");
    PRINTF("Verbose        - Toggles Verbose Mode On/Off\n");
    PRINTF("Commdlg        - Toggles Filtering of Commdlg Calls On/Off\n");
    PRINTF("GDI            - Toggles Filtering of GDI Calls On/Off\n");
    PRINTF("Kernel         - Toggles Filtering of Kernel Calls On/Off\n");
    PRINTF("Kernel16       - Toggles Filtering of Kernel16 Calls On/Off\n");
    PRINTF("Keyboard       - Toggles Filtering of Keyboard Calls On/Off\n");
    PRINTF("MMedia         - Toggles Filtering of MMedia Calls On/Off\n");
    PRINTF("Sound          - Toggles Filtering of Sound Calls On/Off\n");
    PRINTF("User           - Toggles Filtering of User Calls On/Off\n");
    PRINTF("Winsock        - Toggles Filtering of Winsock Calls On/Off\n");
    PRINTF("\n");
}

VOID
help_denv(
    VOID
    )
{
    PRINTF("Dump environment block for current DOS process or given environment selector\n");
    PRINTF("\n");
    PRINTF("!denv <bPMode> <segEnv>\n");
    PRINTF("\n");
    PRINTF("Examples:\n");
    PRINTF("!denv             - Dumps environment for current DOS process\n");
    PRINTF("!denv 0 145d      - Dumps environment at &145d:0 (145d from PDB_environ of DOS process)\n");
    PRINTF("!denv 1 16b7      - Dumps environment at #16b7:0 (16b7 from !dt -v segEnvironment)\n");
    PRINTF("\n");
}

extern char *w32DotCommandExtHelp[];

VOID
help_k32(
    VOID
    )
{
    char **s;

    PRINTF("MEKRNL32 debug commands\n");
    PRINTF("\n");

    for (s = w32DotCommandExtHelp; *s; ++s) {
	 PRINTF(*s);
    }

}

VOID
help(
    CMD_ARGLIST
) {
    CMD_INIT();

    if (GetNextToken()) {
        if (_strnicmp(lpArgumentString, "filter", 6) == 0) {
            helpFilter();
        } else if (_strnicmp(lpArgumentString, "apiprofdmp", 10) == 0) {
            helpAPIProfDmp();
        } else if (_strnicmp(lpArgumentString, "msgprofdmp", 10) == 0) {
            helpMsgProfDmp();
        } else if (_strnicmp(lpArgumentString, "denv", 4) == 0) {
            help_denv();
	} else if (_strnicmp(lpArgumentString, "k32", 3) == 0) {
	    help_k32();
	} else {
            PRINTF("No specific help information available for '%s'\n", lpArgumentString);
        }
        return;
    }

    if (!EXPRESSION("ntvdm!Ldt")) {
        PRINTF("\nWARNING: Symbols for NTVDM are not available.\n\n");
    }
    if (!EXPRESSION("wow32!gptdTaskHead")) {
        PRINTF("\nWOW commands are not currently available.\n\n");
    } else if (!EXPRESSION("wow32!iLogLevel")) {
        PRINTF("\nWOW32 is the free version: Some commands will be unavailable.\n\n");
    }

    PRINTF("------------- VDMEXTS Debug Extension help:--------------\n\n");
    PRINTF("help [cmd]             - Displays this list or gives details on command\n");
    PRINTF("ApiProfClr             - Clears the api profiling table\n");
    PRINTF("ApiProfDmp [options]   - Dumps the api profiling table\n");
    PRINTF("at 0xXXXX              - shows name associated with hex atom #\n");
    PRINTF("bp <addr>              - Sets a vdm breakpoint\n");
    PRINTF("bd/be <n>              - Disables/enables vdm breakpoint 'n'\n");
    PRINTF("bl                     - Lists vdm breakpoints\n");
    PRINTF("chkheap                - Checks WOW kernel's global heap\n");
    PRINTF("cia                    - Dump cursor/icon alias list\n");
    PRINTF("d<b|w|d> <addr> [len]  - Dump vdm memory\n");
    PRINTF("ddemem                 - Dump dde memory thunks\n");
    PRINTF("ddte <addr>            - Dump dispatch table entry pointed to by <addr>\n");
    PRINTF("denv <bProt> <selEnv>  - Dump environment for current task or given selector/segment\n");
    PRINTF("df [vector]            - Dump protect mode fault handler address\n");
    PRINTF("dfh [fh [pdb]]         - Dump DOS file handles for current or given PDB\n");
    PRINTF("dg <sel>               - Dump info on a selector\n");
    PRINTF("ddh [seg]              - Dump DOS heap chain starting at <seg>:0000\n");
    PRINTF("dgh [sel|ownersel]     - Dump WOW kernel's global heap\n");
    PRINTF("dhdib [@<address>]     - Dump dib.drv support structures (DIBINFO)\n");
    PRINTF("di [vector]            - Dump protect mode interrupt handler address\n");
    PRINTF("dma                    - Dump virtual DMA state\n");
    PRINTF("dpd                    - Dump DPMI DOS memory allocations\n");
    PRINTF("dpx                    - Dump DPMI extended memory allocations\n");
    PRINTF("dsft [sft]             - Dump all or specified DOS system file tables\n");
    PRINTF("dt [-v] <addr>         - Dump WOW Task Info\n");
    PRINTF("dwp <addr>             - Dump WOWPORT structure pointed to by <addr>\n");
    PRINTF("e<b|w|d> <addr> <data> - Edit vdm memory\n");
    PRINTF("filter [options]       - Manipulate logging filter\n");
    PRINTF("fs <text to find>      - Find text in 16:16 memory (case insensitive)\n");
    PRINTF("glock <sel>            - Increments the lock count on a moveable segment\n");
    PRINTF("gmem                   - Dumps Global/heap memory alloc'd by wow32\n");
    PRINTF("gunlock <sel>          - Decrements the lock count on a moveable segment\n");
    PRINTF("hgdi <h16>             - Returns 32-bit GDI handle for <h16>\n");
    PRINTF("ica                    - Dump Interrupt Controller state\n");
    PRINTF("k                      - Stack trace\n");
    PRINTF("k32                    - MEKRNL32 special commands\n");
    PRINTF("kb                     - Stack trace with symbols\n");
    PRINTF("LastLog                - Dumps Last Logged WOW APIs from Circular Buffer\n");
    PRINTF("lg [#num] [count]      - Dumps NTVDM history log\n");
    PRINTF("lgr [#num] [count]     - Dumps NTVDM history log (with regs)\n");
    PRINTF("lgt [1|2|3]            - Sets NTVDM history log timer resolution\n");
    PRINTF("lm <sel|modname>       - List loaded modules\n");
    PRINTF("ln [addr]              - Determine near symbols\n");
    PRINTF("LogFile [path]         - Create/close toggle for iloglevel capture to file\n");
    PRINTF("                         (path defaults to c:\\ilog.log)\n");
    PRINTF("MsgProfClr             - Clears the msg profiling table\n");
    PRINTF("MsgProfDmp [options]   - Dumps the msg profiling table\n");
    PRINTF("ntsd                   - Gets an NTSD prompt from the VDM prompt\n");
    PRINTF("r                      - Dump registers\n");
    PRINTF("rmcb                   - Dumps dpmi real mode callbacks\n");
    PRINTF("SetLogLevel xx         - Sets the WOW Logging Level\n");
    PRINTF("StepTrace              - Toggles Single Step Tracing On/Off\n");
    PRINTF("sx                     - Displays debugging options\n");
    PRINTF("sx<d|e> <flag>         - Disables/enables debugging options\n");
    PRINTF("u [addr] [len]         - Unassemble vdm code with symbols\n");
    PRINTF("wc <hwnd16>            - Dumps the window class structure of <hwnd16>\n");
    PRINTF("ww <hwnd16>            - Dumps the window structure of <hwnd16>\n");
    PRINTF("x <symbol>             - Get symbol's value\n");
#ifdef i386
    PRINTF("\n-------------- i386 specific commands\n");
    PRINTF("fpu                    - Dump 487 state\n");
    PRINTF("pdump                  - Dumps profile info to file \\profile.out\n");
    PRINTF("pint                   - Sets the profile interval\n");
    PRINTF("pstart                 - Causes profiling to start\n");
    PRINTF("pstop                  - Causes profiling to stop\n");
    PRINTF("vdmtib [addr]          - Dumps the register context in the vdmtib\n");
#endif
    PRINTF("\n\n");
    PRINTF("    where [options] can be displayed with 'help <cmd>'\n\n");
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\vdmexts\misc.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    ntsdexts.c

Abstract:

    This function contains miscellaneous VDMEXTS functions

Author:

    Bob Day      (bobday) 29-Feb-1992 Grabbed standard header

Revision History:

    Neil Sandlin (NeilSa) 15-Jan-1996 Merged with vdmexts

--*/

#include <precomp.h>
#pragma hdrstop
#include <ctype.h>

extern DWORD gOffset;       // in disasm.c

VOID
DumpMemory(
    UINT UnitSize,
    BOOL bAscii
    )
{
    VDMCONTEXT ThreadContext;
    int mode;
    int j, lines = 8, linelength;
    WORD selector;
    ULONG offset, endoffset, units;
    ULONG base;
    char ch;

    if (!UnitSize) {
        return;
    }

    mode = GetContext( &ThreadContext );

    if (!GetNextToken()) {
        PRINTF("Please specify an address\n");
        return;
    }

    if (!ParseIntelAddress(&mode, &selector, &offset)) {
        return;
    }

    if (GetNextToken()) {
        if ((*lpArgumentString == 'l') || (*lpArgumentString == 'L')) {
            lpArgumentString++;
        }
        units = EvaluateToken();
        lines = (units*UnitSize+15)/16;
    } else {
        units = (lines*16)/UnitSize;
    }

    endoffset = offset+units*UnitSize;

    base = GetInfoFromSelector(selector, mode, NULL) + GetIntelBase();

    while (lines--) {
        if (offset & 0xFFFF0000) {
            PRINTF("%04x:%08lx ", selector, offset);
        } else {
            PRINTF("%04x:%04x ", selector, LOWORD(offset));
        }

        linelength = endoffset - offset;
        if (linelength > 16) {
            linelength = 16;
        }

        switch(UnitSize) {

        case 1:
            for (j=0; j<linelength; j++) {
                if (j==8) {
                    PRINTF("-");
                } else {
                    PRINTF(" ");
                }
                PRINTF("%02x", ReadByteSafe(base+offset+j));
            }

            break;
        case 2:
            for (j=0; j<linelength; j+=2) {
                PRINTF(" %04x", ReadWordSafe(base+offset+j));
            }
            break;
        case 4:
            for (j=0; j<linelength; j+=4) {
                PRINTF(" %08lx", ReadDwordSafe(base+offset+j));
            }
            break;
        }

        if (bAscii) {

            j = (16-linelength)*2 + (16-linelength)/UnitSize;
            while (j--) {
                PRINTF(" ");
            }

            PRINTF("  ");

            for (j=0; j<linelength; j++) {
                ch = ReadByteSafe(base+offset+j);
                if (isprint(ch)) {
                    PRINTF("%c", ch);
                } else {
                    PRINTF(".");
                }
            }
        }
        PRINTF("\n");
        offset += 16;

    }

}

VOID
db(
    CMD_ARGLIST
    )
{
    CMD_INIT();
    DumpMemory(1, TRUE);

}

VOID
dw(
    CMD_ARGLIST
    )
{
    CMD_INIT();
    DumpMemory(2, FALSE);

}

VOID
dd(
    CMD_ARGLIST
    )
{
    CMD_INIT();
    DumpMemory(4, FALSE);

}

VOID
EditMemory(
    UINT UnitSize
    )
{
    ULONG value, base, offset;
    WORD selector;
    int mode;

    if (!GetNextToken()) {
        PRINTF("Please specify an address\n");
        return;
    }

    if (!ParseIntelAddress(&mode, &selector, &offset)) {
        return;
    }

    base = GetInfoFromSelector(selector, mode, NULL) + GetIntelBase();

    while(GetNextToken()) {
        value = EvaluateToken();

        PRINTF("%04x base=%08x offset=%08x value=%08x\n", selector, base, offset, value);
        // this is endian dependant code
        WRITEMEM((LPVOID)(base+offset), &value, UnitSize);
        offset += UnitSize;

    }

}

VOID
eb(
    CMD_ARGLIST
    )
{
    CMD_INIT();
    EditMemory(1);
}

VOID
ew(
    CMD_ARGLIST
    )
{
    CMD_INIT();
    EditMemory(2);
}

VOID
ed(
    CMD_ARGLIST
    )
{
    CMD_INIT();
    EditMemory(4);
}





VOID
r(
    CMD_ARGLIST
) {
    VDMCONTEXT              ThreadContext;
    int                     mode;
    char            sym_text[255];
    char            rgchOutput[128];
    char            rgchExtra[128];
    BYTE            rgbInstruction[64];
    WORD            selector;
    ULONG           offset;
    ULONG           dist;
    int  cb, j;
    ULONG Base;
    SELECTORINFO si;

    CMD_INIT();

    mode = GetContext( &ThreadContext );

    PRINTF("eax=%08lx ebx=%08lx ecx=%08lx edx=%08lx esi=%08lx edi=%08lx\n",
            ThreadContext.Eax,
            ThreadContext.Ebx,
            ThreadContext.Ecx,
            ThreadContext.Edx,
            ThreadContext.Esi,
            ThreadContext.Edi );
    PRINTF("eip=%08lx esp=%08lx ebp=%08lx                ",
            ThreadContext.Eip,
            ThreadContext.Esp,
            ThreadContext.Ebp );

    if (ThreadContext.EFlags != 0xffffffff) {
        if ( ThreadContext.EFlags & FLAG_OVERFLOW ) {
            PRINTF("ov ");
        } else {
            PRINTF("nv ");
        }
        if ( ThreadContext.EFlags & FLAG_DIRECTION ) {
            PRINTF("dn ");
        } else {
            PRINTF("up ");
        }
        if ( ThreadContext.EFlags & FLAG_INTERRUPT ) {
            PRINTF("ei ");
        } else {
            PRINTF("di ");
        }
        if ( ThreadContext.EFlags & FLAG_SIGN ) {
            PRINTF("ng ");
        } else {
            PRINTF("pl ");
        }
        if ( ThreadContext.EFlags & FLAG_ZERO ) {
            PRINTF("zr ");
        } else {
            PRINTF("nz ");
        }
        if ( ThreadContext.EFlags & FLAG_AUXILLIARY ) {
            PRINTF("ac ");
        } else {
            PRINTF("na ");
        }
        if ( ThreadContext.EFlags & FLAG_PARITY ) {
            PRINTF("po ");
        } else {
            PRINTF("pe ");
        }
        if ( ThreadContext.EFlags & FLAG_CARRY ) {
            PRINTF("cy ");
        } else {
            PRINTF("nc ");
        }
    }

    PRINTF("\n");
    PRINTF("cs=%04x  ss=%04x  ds=%04x  es=%04x  fs=%04x  gs=%04x             ",
            ThreadContext.SegCs,
            ThreadContext.SegSs,
            ThreadContext.SegDs,
            ThreadContext.SegEs,
            ThreadContext.SegFs,
            ThreadContext.SegGs);

    if (ThreadContext.EFlags == 0xffffffff) {
        //
        // The contents of eflags are unreliable. This happens when you can't
        // do a "getEFLAGS()" to obtain the value.
        //
        PRINTF("efl=????????\n");

    } else {
        PRINTF("efl=%08lx\n",ThreadContext.EFlags );
    }

    //
    // Do disassembly of current instruction
    //

    selector = (WORD) ThreadContext.SegCs;
    offset = ThreadContext.Eip;

    Base = GetInfoFromSelector( selector, mode, &si ) + GetIntelBase();

    if (FindSymbol(selector, offset, sym_text, &dist, BEFORE, mode )) {
        if ( dist == 0 ) {
            PRINTF("%s:\n", sym_text );
        } else {
            PRINTF("%s+0x%lx:\n", sym_text, dist );
        }
    }

    cb = sizeof(rgbInstruction);
    if ((DWORD)(offset+cb) >= si.Limit)
         cb -= offset+cb-si.Limit;
    if (!READMEM((LPVOID)(Base+offset), rgbInstruction, cb)) {
        PRINTF("%04x:%08x: <Error Reading Memory>\n", selector, offset);
        return;
    }

    cb = unassemble_one(rgbInstruction,
                si.bBig,
                selector, offset,
                rgchOutput,
                rgchExtra,
                &ThreadContext,
                mode);

    if (offset > 0xffff) {
        PRINTF("%04x:%08x ", selector, offset);
    } else {
        PRINTF("%04x:%04x ", selector, offset);
    }

    for (j=0; j<cb; ++j)
        PRINTF("%02x", rgbInstruction[j]);
    for (; j<8; ++j)
        PRINTF("  ");
    PRINTF("%s\t%s\n", rgchOutput, rgchExtra);
}

VOID
SearchModuleList(
    VOID
    )
{
    VDMCONTEXT              ThreadContext;
    int                     mode;
    HEAPENTRY               he = {0};
    SELECTORINFO si;
    WORD         selector = 0;
    SEGENTRY  *se;
    char      filename[9];
    char    szModuleArg[255];
    BOOL bModuleNameGiven=FALSE;
    LPSTR pTemp;


    mode = GetContext( &ThreadContext );

    if (GetNextToken()) {

        if (IsTokenHex()) {
            selector = (WORD) EvaluateToken();
        } else {
            bModuleNameGiven = TRUE;
            pTemp = lpArgumentString;
            SkipToNextWhiteSpace();
            *lpArgumentString = 0;
            strcpy(szModuleArg, pTemp);
            if (strlen(szModuleArg) > 8) {
                szModuleArg[8] = 0;
            }
        }
    }


    PRINTF("Sel    Base     Limit  Type  Module  Seg\n");
    PRINTF("==== ======== ======== ==== ======== ===\n");

    se = GetSegtablePointer();
    while ( se ) {
        if ( selector == 0 ||
             se->selector == selector ||
             bModuleNameGiven) {

            switch (se->type) {

            case SEGTYPE_PROT:
                {
                    HEAPENTRY               he = {0};
                    he.Selector = se->selector;
                    if (FindHeapEntry(&he, FHE_FIND_SEL_ONLY, FHE_FIND_QUIET)) {
                        break;
                    }
                }
                GetInfoFromSelector(se->selector, PROT_MODE, &si);
                ParseModuleName(filename, se->szExePath);

                if (!bModuleNameGiven || !_stricmp(filename, szModuleArg)) {

                    PRINTF("%04X %08lX %08lX",
                        se->selector,
                        si.Base,
                        si.Limit);
                    PRINTF(" %s", si.bCode ? "code" : "data");
                    PRINTF(" %-8.8s %d\n",
                        filename,
                        se->segment+1 );

                }
                break;

            case SEGTYPE_V86:
                ParseModuleName(filename, se->szExePath);

                if (!bModuleNameGiven || !_stricmp(filename, szModuleArg)) {

                    PRINTF("%04X %08lX %08lX %s %-8.8s %d\n",
                        se->selector,
                        se->selector << 4,
                        se->length,
                        "v86 ",
                        filename,
                        se->segment+1);
                }
                break;
            }

        }
        se = se->Next;
    }

    he.CurrentEntry = 0;        // reset scan
    if (bModuleNameGiven) {
        strcpy(he.ModuleArg, szModuleArg);
    } else {
        he.Selector = selector;
    }

    while (FindHeapEntry(&he, bModuleNameGiven ? FHE_FIND_MOD_ONLY :
                                                 FHE_FIND_SEL_ONLY,
                                                    FHE_FIND_QUIET)) {

        if (he.SegmentNumber != -1) {
            GetInfoFromSelector((WORD)(he.gnode.pga_handle | 1), PROT_MODE, &si);
            PRINTF("%04X %08lX %08lX",
                he.gnode.pga_handle | 1,
                he.gnode.pga_address,
                he.gnode.pga_size - 1);

            PRINTF(" %s", si.bCode ? "Code" : "Data");

            PRINTF(" %-8.8s %d\n",
                he.OwnerName,
                he.SegmentNumber+1);
        }

    }

}


VOID
lm(
    CMD_ARGLIST
    )
{
    CMD_INIT();

    if (GetNextToken()) {

        SearchModuleList();

    } else {

        WORD sel;
        BOOL    b;
        NEHEADER owner;
        ULONG base;
        CHAR ModuleName[9];
        UCHAR len;

        if (!ReadMemExpression("ntvdmd!DbgWowhExeHead", &sel, sizeof(sel))) {
            return;
        }

        PRINTF("NEHeader  Module Name\n");
        while(sel) {

            base = GetInfoFromSelector(sel, PROT_MODE, NULL) + GetIntelBase();

            b = READMEM((LPVOID)base, &owner, sizeof(owner));

            if (!b || (owner.ne_magic != 0x454e)) {
                PRINTF("Invalid module list! (started with hExeHead)\n");
                return;
            }
          
            len = ReadByteSafe(base+owner.ne_restab);
            if (len>8) {
                len=8;
            }
            READMEM((LPVOID)(base+owner.ne_restab+1), ModuleName, 8);
          
            ModuleName[len] = 0;

            PRINTF("  %.04X     %s\n", sel, ModuleName);
            // This is mapped to ne_pnextexe in kernel
            sel = owner.ne_cbenttab;
        } 
    }
}

VOID
dg(
    CMD_ARGLIST
) {
    ULONG                   selector;
    ULONG                   Base;
    SELECTORINFO            si;
    int                     count = 16;

    CMD_INIT();

    if (!GetNextToken()) {
        PRINTF("Please enter a selector\n");
        return;
    }

    selector = EvaluateToken();

    if (GetNextToken()) {
        if (tolower(*lpArgumentString) == 'l') {
            lpArgumentString++;
        }
        count = (WORD) EvaluateToken();
    }

    while (count--) {

        Base = GetInfoFromSelector( (WORD) selector, PROT_MODE, &si );

        PRINTF("%04X => Base: %08lX", selector, Base);

#ifndef i386
        PRINTF(" (%08X)", Base+GetIntelBase());
#endif

        PRINTF("  Limit: %08lX  %s %s %s %s %s %s\n",
                si.Limit,
                si.bPresent ? " P" : "NP",
                si.bSystem ? "System" : si.bCode     ? "Code  " : "Data  ",
                si.bSystem ? ""       : si.bWrite    ? "W" : "R",
                si.bSystem ? ""       : si.bAccessed ? "A" : " ",
                si.bBig    ? "Big" : "",
                si.bExpandDown ? "ED" : ""
                );

        selector+=8;
        if (selector>0xffff) {
            break;
        }
    }

}

VOID
ntsd(
    CMD_ARGLIST
    )
{
#if 0
    PVOID Address;
    static BOOL bTrue = TRUE;
#endif    

    CMD_INIT();

    PRINTF("vdmexts: obselete command 'ntsd', use '.<cmd>' from VDM> prompt\n");
#if 0
    if (!InVdmPrompt()) {
        PRINTF("This command only works at the VDM> prompt\n");
    }

    Address = (PVOID)(*GetExpression)("ntvdmd!bWantsNtsdPrompt");

    if (Address) {
        WRITEMEM((PVOID)Address, &bTrue, sizeof(BOOL));
        PRINTF("Enter 'g' to return from the ntsd prompt\n");
    } else {
        PRINTF("Can't find symbol 'ntvdmd!bWantsNtsdPrompt'\n");
    }
#endif
}


VOID
q(
    CMD_ARGLIST
    )
{
    CMD_INIT();

    PRINTF("!vdmexts.q quitting debugger...");
    ExitProcess(0);
}


//
// fs find string
// case-insensitive
// searches LDT selectors one by one, first 64k only.
//

VOID
fs(
    CMD_ARGLIST
) {
    ULONG                   selector;
    ULONG                   Base;
    ULONG                   cbCopied;
    SELECTORINFO            si;
    BYTE                    Buffer[65*1024];
    LPSTR                   pszSearch;
    LPSTR                   pch;

    CMD_INIT();

    RtlZeroMemory(Buffer, sizeof(Buffer));

    if (!GetNextToken()) {
        PRINTF("Please enter a string to find in 16:16 memory\n");
        return;
    }

    pszSearch = lpArgumentString;

    PRINTF("Searching 16:16 memory for '%s'\n", pszSearch);

    for (selector = 7;
         selector < 0x10000;
         selector += 8) {

        Base = GetInfoFromSelector( (WORD) selector, PROT_MODE, &si );

        //
        // If the selector is valid and present read up to 64k
        // into Buffer.
        //

        if (Base != (ULONG)-1 && si.bPresent) {

            cbCopied = si.Limit + 1;

            if (cbCopied > 0x10000) {
                cbCopied = 0x10000;
            }

            if (!READMEM((LPVOID)(Base + GetIntelBase()), Buffer, cbCopied)) {
                PRINTF("Unable to read selector %04x contents at %x for %x bytes\n",
                       selector, Base + GetIntelBase(), cbCopied);
            } else {

                //
                // search the block for the string, buffer is 1k too big and
                // zero-inited so that strcmp is safe.
                //

                for (pch = Buffer;
                     pch < (Buffer + cbCopied);
                     pch++) {

                    if (!_memicmp(pch, pszSearch, strlen(pszSearch))) {

                        //
                        // Match!
                        //

                        PRINTF("%04x:%04x (%08x) '%s'\n",
                               selector,
                               pch - Buffer,
#ifndef i386
                               GetIntelBase() +
#endif
                               Base + (pch - Buffer),
                               pch);
                    }
                }
            }
        }
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\vdmexts\precomp.h ===
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#define NOEXTAPI
#include <wdbgexts.h>
#include <ntsdexts.h>
#include <string.h>
#include <stdlib.h>

#include <vdm.h>
#include <vdmdbg.h>
#include <vdmexts.h>

#include <ctype.h>
#define DEBUG_OR_WOWPROFILE 1
#include <wow32.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\vdmexts\platform.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    platform.c

Abstract:

    These are the entry points of the commands that don't exist
    on every platform.

Author:

    Neil Sandlin (NeilSa) 15-Jan-1996 

Notes:


Revision History:

--*/

#include <precomp.h>
#pragma hdrstop




VOID
es(
    CMD_ARGLIST
    )
{
    CMD_INIT();
    PRINTF("es has been replaced with the 'x' command\n");

}

VOID
eventinfo(
    CMD_ARGLIST
    )
{
    CMD_INIT();
#if defined(i386)
    EventInfop();
#else
    PRINTF("Eventinfo is not implemented on this platform\n");
#endif

}


VOID
pdump(
    CMD_ARGLIST
    )
{
    CMD_INIT();
#if defined(i386)
    ProfDumpp();
#else
    PRINTF("pdump is not implemented on this platform\n");
#endif

}

VOID
pint(
    CMD_ARGLIST
    )
{
    CMD_INIT();
#if defined(i386)
    ProfIntp();
#else
    PRINTF("pint is not implemented on this platform\n");
#endif

}

VOID
pstart(
    CMD_ARGLIST
    )
{
    CMD_INIT();
#if defined(i386)
    ProfStartp();
#else
    PRINTF("pstart is not implemented on this platform\n");
#endif

}

VOID
pstop(
    CMD_ARGLIST
    )
{
    CMD_INIT();
#if defined(i386)
    ProfStopp();
#else
    PRINTF("pstop is not implemented on this platform\n");
#endif

}

VOID
vdmtib(
    CMD_ARGLIST
    )
{
    CMD_INIT();
#if defined(i386)
    VdmTibp();
#else
    PRINTF("VdmTib is not implemented on this platform\n");
#endif

}

VOID
fpu(
    CMD_ARGLIST
    )
{
    CMD_INIT();
#if defined(i386)
    Fpup();
#else
    PRINTF("fpu is not implemented on this platform\n");
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\vdmexts\reflect.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    reflect.c

Abstract:

    This module contains extensions having to do with event and exception
    reflection.

Author:

    Dave Hastings (daveh) 20-Apr-1992

Revision History:

    Neil Sandlin (NeilSa) 15-Jan-1996 Merged with vdmexts
    Neil Sandlin (NeilSa) 15-Jul-1996 Added 'SX' commands

--*/

#include <precomp.h>
#pragma hdrstop
#include <dbgsvc.h>

VOID
ClearVdmDbgTraceFlags(
    VOID
    )
{
    ULONG lpAddress;
    ULONG ulTF;

    lpAddress = (*GetExpression)("ntvdmd!VdmDbgTraceFlags");

    if (!lpAddress) {
        lpAddress = (*GetExpression)("ntvdm!InitialVdmDbgFlags");
    }

    if (!READMEM((PVOID)lpAddress, &ulTF, sizeof(ULONG))) {
        PRINTF("Error reading memory\n");
        return;
    }

    ulTF = 0;

    WRITEMEM((PVOID)lpAddress, &ulTF, sizeof(ULONG));

}

VOID
dr(
    CMD_ARGLIST
    )
{
    CMD_INIT();

    PRINTF("\nThe DR command is obselete and has been removed. The debugger now\n");
    PRINTF("breaks on ntvdm debug exceptions by default. If you are debugging\n");
    PRINTF("an unusual scenario where you need the debugger to reflect (ignore)\n");
    PRINTF("these exceptions (like in debugging a 16-bit debugger), use the\n");
    PRINTF("vdmexts.sxd command.\n\n");
}

VOID
er(
    CMD_ARGLIST
    )
{
    CMD_INIT();

    PRINTF("\nThe ER command is obselete and has been removed. By default,\n");
    PRINTF("the debugger will break on 'second chance' GP faults, which is\n");
    PRINTF("typically the desired behavior. If you are debugging an unusual\n");
    PRINTF("scenario that requires you to examine FIRST CHANCE faults, use\n");
    PRINTF("the vdmexts.sxe command.\n\n");
    PRINTF("If you are not sure if you need to turn this notification on, then\n");
    PRINTF("you probably don't need it.\n\n");

}


VOID
DoVdmtibFlag(
    ULONG Flag,
    BOOL bSet,
    LPSTR pTitle
    )
/*++

Routine Description:

    This routine toggles the exception reflection bit in the vdmtib, and
    reports the current state

Arguments:

    None.

Return Value:

    None.

--*/
{
    BOOL Status;
    PVOID Address;
    ULONG Flags;


    Address = (PVOID) (FIXED_NTVDMSTATE_LINEAR + GetIntelBase());

    //
    // Read the current value of the flags
    //

    Status = READMEM(Address, &Flags, sizeof(ULONG));

    if (!Status)  {

        (ULONG)Address = (*GetExpression)("ntvdm!InitialVdmTibFlags");

        Status = READMEM((PVOID)Address, &Flags, sizeof(ULONG));

        if (!Status) {
            GetLastError();
            (*Print)("Could not get InitialTibflags\n");
            return;
        }
    }

    //
    // Toggle exception bit
    //
    if (bSet) {
        if (!(Flags & Flag)) {
            PRINTF("%s enabled\n", pTitle);
        }
        Flags |= Flag;
    } else {
        if (Flags & Flag) {
            PRINTF("%s disabled\n", pTitle);
        }
        Flags &= ~Flag;
    }

    Status = WRITEMEM(Address, &Flags, sizeof(ULONG));

    if (!Status) {
        GetLastError();
        (*Print)("Could not get set Flags\n");
        return;
    }
}


VOID
EnableDebuggerBreakpoints(
    VOID
    )
{

    DoVdmtibFlag(VDM_BREAK_DEBUGGER, TRUE, "Debug faults");
}

ULONG
TraceFlagFromName(
    LPSTR lpName
    )
{
    ULONG ulRet = 0;

    if (_strnicmp(lpName, "cw", 2) == 0) {
        ulRet = VDMDBG_BREAK_WOWTASK;
    } else if (_strnicmp(lpName, "cd", 2) == 0) {
        ulRet = VDMDBG_BREAK_DOSTASK;
    } else if (_strnicmp(lpName, "ld", 2) == 0) {
        ulRet = VDMDBG_BREAK_LOADDLL;
    }

    return ulRet;
}

VOID
sx(
    CMD_ARGLIST
    )
{
    ULONG lpAddress;
    ULONG Flags;
    BOOL Status;
    CMD_INIT();

    lpAddress = (*GetExpression)("ntvdmd!VdmDbgTraceFlags");

    if (!lpAddress) {
        lpAddress = (*GetExpression)("ntvdm!InitialVdmDbgFlags");
    }

    if (!READMEM((PVOID)lpAddress, &Flags, sizeof(ULONG))) {
        PRINTF("Error reading memory\n");
        return;
    }

    PRINTF("VDM DEBUG OPTIONS:\n\n");
    PRINTF("cd - break on create DOS task        - %s\n", (Flags & VDMDBG_BREAK_DOSTASK)? "enabled" : "disabled");
    PRINTF("cw - break on create WOW task        - %s\n", (Flags & VDMDBG_BREAK_WOWTASK)? "enabled" : "disabled");
    PRINTF("ld - break on load DLL               - %s\n", (Flags & VDMDBG_BREAK_LOADDLL)? "enabled" : "disabled");

    lpAddress = (ULONG) (FIXED_NTVDMSTATE_LINEAR + GetIntelBase());

    Status = READMEM((PVOID)lpAddress, &Flags, sizeof(ULONG));

    if (!Status)  {

        lpAddress = (*GetExpression)("ntvdm!InitialVdmTibFlags");

        Status = READMEM((PVOID)lpAddress, &Flags, sizeof(ULONG));

        if (!Status) {
            GetLastError();
            (*Print)("Could not get InitialTibflags\n");
            return;
        }
    }

    PRINTF("ex - break on FIRST CHANCE exceptions- %s\n", (Flags & VDM_BREAK_EXCEPTIONS)? "enabled" : "disabled");
    PRINTF("db - break on INT1, INT3             - %s\n", (Flags & VDM_BREAK_DEBUGGER)  ? "enabled" : "disabled");
    PRINTF("lg - NTVDM trace history log         - %s\n", (Flags & VDM_TRACE_HISTORY)   ? "enabled" : "disabled");

}

VOID
DoSxCmd(
    BOOL fEnable
    )

{
    ULONG lpAddress;
    ULONG ulTF;
    ULONG ulParm;

    if (!GetNextToken()) {
        PRINTF("Please enter an trace flag (enter 'sx' for list)\n");
        return;
    }

    if (!(ulParm = TraceFlagFromName(lpArgumentString))) {

        if (_strnicmp(lpArgumentString, "db", 2) == 0) {

            DoVdmtibFlag(VDM_BREAK_DEBUGGER, fEnable, "Debugger trapping of debug faults");

        } else if (_strnicmp(lpArgumentString, "ex", 2) == 0) {

            DoVdmtibFlag(VDM_BREAK_EXCEPTIONS, fEnable, "Debugger trapping of exceptions");

        } else if (_strnicmp(lpArgumentString, "lg", 2) == 0) {

            DoVdmtibFlag(VDM_TRACE_HISTORY, fEnable, "NTVDM trace log");

        } else {

            PRINTF("Invalid trace flag\n");
        }

        return;
    }

    lpAddress = (*GetExpression)("ntvdmd!VdmDbgTraceFlags");

    if (!lpAddress) {
        lpAddress = (*GetExpression)("ntvdm!InitialVdmDbgFlags");
    }

    if (!READMEM((PVOID)lpAddress, &ulTF, sizeof(ULONG))) {
        PRINTF("Error reading memory\n");
        return;
    }


    if (fEnable) {
        ulTF |= ulParm;
    } else {
        ulTF &= ~ulParm;
    }

    WRITEMEM((PVOID)lpAddress, &ulTF, sizeof(ULONG));

}

VOID
sxd(
    CMD_ARGLIST
    )
{
    CMD_INIT();

    DoSxCmd(FALSE);
}

VOID
sxe(
    CMD_ARGLIST
    )
{
    CMD_INIT();

    EnableDebuggerBreakpoints();
    DoSxCmd(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\vdmexts\stack.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    heap.c

Abstract:

    This function contains the default ntsd debugger extensions

Author:

    Bob Day      (bobday) 29-Feb-1992 Grabbed standard header

Revision History:

    Neil Sandlin (NeilSa) 15-Jan-1996 Merged with vdmexts

--*/

#include <precomp.h>
#pragma hdrstop

ULONG IntelBase;

void dump_params(
    ULONG                   params,
    char                    convention,
    int                     param_words
) {
    WORD                    word;
    int                     cnt;

    if ( param_words == 0 ) {
        param_words = 10;
    }
    PRINTF("(");
    cnt = 0;
    while ( cnt != param_words ) {
        if ( convention == 'c' ) {
            word = ReadWord(params+cnt);
        } else {
            word = ReadWord(params+(param_words-cnt));
        }
        if ( cnt == param_words - 1 ) {
            PRINTF("%04x",word);
        } else {
            PRINTF("%04x,",word);
        }
        cnt+=2;
    }
    PRINTF(")");
}

int look_for_near(
    ULONG           pbp,
    WORD            cs,
    WORD            ss,
    WORD            bp,
    int             framed,
    ULONG           csBase,
    int             mode,
    BOOL            fUseSymbols,
    BOOL            fParams
) {
    WORD            ip;
    ULONG           ra;
    char            call_type;
    char            frame_type;
    char            convention;
    int             param_words;
    signed short    dest;
    unsigned char   opcode;
    unsigned char   mod;
    unsigned char   type;
    unsigned char   rm;
    WORD            dest_ip;
    char            symbol[1000];
    BOOL            fOk;
    BOOL            fInst;
    BOOL            b;
    LONG            dist;
    BOOL            fDest;

    fOk = TRUE;
    fInst = FALSE;
    fDest = FALSE;

    param_words = 0;
    if ( framed ) {
        frame_type = 'B';
    } else {
        frame_type = 'C';
    }
    ip = ReadWord(pbp+2);
    ra = csBase + (ULONG)ip;

    do {
        opcode = ReadByteSafe(ra - 2);
        if ( opcode == CALL_NEAR_INDIRECT ) {
            if ( ReadByteSafe(ra - 3) == PUSH_CS ) {
                call_type = 'f';
            } else {
                call_type = 'N';
            }
            opcode = ReadByteSafe(ra - 1);
            mod  = opcode & MOD_BITS;
            type = opcode & TYPE_BITS;
            rm   = opcode & RM_BITS;
            if ( type == INDIRECT_NEAR_TYPE ) {
                if ( mod == MOD0 && rm != RM6 ) {
                    fInst = TRUE;
                    break;
                }
                if ( mod == MOD3 ) {
                    fInst = TRUE;
                    break;
                }
            }
        }
        opcode = ReadByteSafe(ra - 3);
        if ( opcode == CALL_NEAR_RELATIVE ) {
            if ( ReadByteSafe(ra - 4) == PUSH_CS ) {
                call_type = 'f';
            } else {
                call_type = 'N';
            }
            dest = ReadWordSafe( ra - 2 );
            dest_ip = ip+dest;
            fInst = TRUE;
            fDest = TRUE;
            break;
        }
        if ( opcode == CALL_NEAR_INDIRECT ) {
            if ( ReadByteSafe(ra - 4) == PUSH_CS ) {
                call_type = 'f';
            } else {
                call_type = 'N';
            }
            opcode = ReadByteSafe(ra - 2);
            mod  = opcode & MOD_BITS;
            type = opcode & TYPE_BITS;
            rm   = opcode & RM_BITS;
            if ( type == INDIRECT_NEAR_TYPE
                 && mod == MOD1 ) {
                fInst = TRUE;
                break;
            }
        }
        opcode = ReadByteSafe(ra - 4);
        if ( opcode == CALL_NEAR_INDIRECT ) {
            if ( ReadByteSafe(ra - 5) == PUSH_CS ) {
                call_type = 'f';
            } else {
                call_type = 'N';
            }
            opcode = ReadByteSafe(ra - 3);
            mod  = opcode & MOD_BITS;
            type = opcode & TYPE_BITS;
            rm   = opcode & RM_BITS;
            if ( type == INDIRECT_NEAR_TYPE ) {
                if ( mod == MOD0 && rm == RM6 ) {
                    fInst = TRUE;
                    break;
                }
                if ( mod == MOD2 ) {
                    fInst = TRUE;
                    break;
                }
            }
        }
        fOk = FALSE;
    } while ( FALSE );

    if ( fOk ) {
        if ( fUseSymbols ) {
            b = FindSymbol( cs, (LONG)ip, symbol, &dist, BEFORE, mode );
        } else {
            b = FALSE;
        }
        b = FALSE;

        if ( b ) {
            if ( dist == 0 ) {
                PRINTF("%04X:%04X %s %c%c", ss, bp, symbol, call_type, frame_type );
            } else {
                PRINTF("%04X:%04X %s+0x%lx %c%c", ss, bp, symbol, dist, call_type, frame_type );
            }
        } else {
            PRINTF("%04X:%04X %04X:%04X %c%c", ss, bp, cs, ip, call_type, frame_type );
        }
        if ( fInst ) {
            if ( ReadWordSafe(ra) == ADD_SP ) {
                convention = 'c';
                param_words = ReadByteSafe( ra+2 );
            } else {
                convention = 'p';
            }
            if ( fUseSymbols && fDest ) {
                b = FindSymbol( cs, (LONG)dest_ip, symbol, &dist, BEFORE, mode );
            } else {
                b = FALSE;
            }
            if ( b ) {
                if ( dist == 0 ) {
                    PRINTF(" %ccall near %s", convention, symbol );
                } else {
                    PRINTF(" %ccall near %s+0x%lx", convention, symbol, dist );
                }
            } else {
                if ( fDest ) {
                    PRINTF(" %ccall near %04X", convention, dest_ip );
                } else {
                    PRINTF(" %ccall near [Indirect]", convention );
                }
            }
            if ( fParams ) {
                dump_params( pbp+4, convention, param_words );
            }
        }
        PRINTF("\n");
        return( 1 );
    }

    return( 0 );
}

int look_for_far(
    ULONG           pbp,
    WORD            *cs,
    WORD            ss,
    WORD            bp,
    int             framed,
    ULONG           *csBase,
    int             mode,
    BOOL            fUseSymbols,
    BOOL            fParams
) {
    WORD            ip;
    WORD            new_cs;
    ULONG           new_csBase;
    ULONG           ra;
    char            frame_type;
    char            convention;
    int             param_words;
    WORD            dest_cs;
    WORD            dest_ip;
    unsigned char   opcode;
    unsigned char   mod;
    unsigned char   type;
    unsigned char   rm;
    char            symbol[1000];
    BOOL            fOk;
    BOOL            fInst;
    BOOL            b;
    LONG            dist;
    BOOL            fDest;
    int             iMeth;
    WORD            low_this;
    WORD            high_this;

    fOk = TRUE;
    fInst = FALSE;
    fDest = FALSE;
    iMeth = -1;

    param_words = 0;
    if ( framed ) {
        frame_type = 'B';
    } else {
        frame_type = 'C';
    }
    ip = ReadWord(pbp+2);
    new_cs = ReadWord(pbp+4);
    new_csBase = GetInfoFromSelector( new_cs, mode, NULL ) + IntelBase;
    if ( new_csBase == -1 ) {
        return( 0 );
    }
    ra = new_csBase + (ULONG)ip;

    do {
        opcode = ReadByteSafe(ra - 2);
        if ( opcode == CALL_FAR_INDIRECT ) {
            opcode = ReadByte(ra - 1);
            mod  = opcode & MOD_BITS;
            type = opcode & TYPE_BITS;
            rm   = opcode & RM_BITS;
            if ( type == INDIRECT_FAR_TYPE ) {
                if ( mod == MOD0 && rm != RM6 ) {
                    fInst = TRUE;
                    iMeth = 0;
                    break;
                }
                if ( mod == MOD3 ) {
                    fInst = TRUE;
                    break;
                }
            }
        }
        opcode = ReadByteSafe(ra - 3);
        if ( opcode == CALL_FAR_INDIRECT ) {
            opcode = ReadByteSafe(ra - 2);
            mod  = opcode & MOD_BITS;
            type = opcode & TYPE_BITS;
            rm   = opcode & RM_BITS;
            if ( type == INDIRECT_FAR_TYPE
                 && mod == MOD1 ) {
                fInst = TRUE;
                iMeth = ReadByteSafe(ra - 1);
                break;
            }
        }
        opcode = ReadByteSafe(ra - 4);
        if ( opcode == CALL_FAR_INDIRECT ) {
            opcode = ReadByteSafe(ra - 3);
            mod  = opcode & MOD_BITS;
            type = opcode & TYPE_BITS;
            rm   = opcode & RM_BITS;
            if ( type == INDIRECT_FAR_TYPE ) {
                if ( mod == MOD0 && rm == RM6 ) {
                    fInst = TRUE;
                    break;
                }
                if ( mod == MOD2 ) {
                    fInst = TRUE;
                    break;
                }
            }
        }
        opcode = ReadByteSafe(ra - 5);
        if ( opcode == CALL_FAR_ABSOLUTE ) {
            dest_ip = ReadWordSafe( ra - 4 );
            dest_cs = ReadWordSafe( ra - 2 );
            fInst = TRUE;
            fDest = TRUE;
            break;
        }
        fOk = FALSE;
    } while ( FALSE );

    if ( fOk ) {
        if ( fUseSymbols ) {
            b = FindSymbol( new_cs, (LONG)ip, symbol, &dist, BEFORE, mode );
        } else {
            b = FALSE;
        }
        b = FALSE;

        if ( b ) {
            if ( dist == 0 ) {
                PRINTF("%04X:%04X %s F%c", ss, bp, symbol, frame_type );
            } else {
                PRINTF("%04X:%04X %s+0x%lx F%c", ss, bp, symbol, dist, frame_type );
            }
        } else {
            PRINTF("%04X:%04X %04X:%04X F%c", ss, bp, new_cs, ip, frame_type );
        }
        if ( fInst ) {
            if ( ReadWordSafe(ra) == ADD_SP ) {
                convention = 'c';
                param_words = ReadByteSafe( ra+2 );
            } else {
                convention = 'p';
            }
            if ( fUseSymbols && fDest ) {
                b = FindSymbol( dest_cs, (LONG)dest_ip, symbol, &dist, BEFORE, mode );
            } else {
                b = FALSE;
            }
            if ( b ) {
                if ( dist == 0 ) {
                    PRINTF(" %ccall far %s", convention, symbol );
                } else {
                    PRINTF(" %ccall far %s + 0x%lx", convention, symbol, dist );
                }
            } else {
                if ( fDest ) {
                    PRINTF(" %ccall far %04X:%04X", convention, dest_cs, dest_ip );
                } else {
                    ULONG   thisBase;
                    ULONG   pvtbl;
                    ULONG   vtblBase;
                    ULONG   pfn;
                    WORD    low_vtbl;
                    WORD    high_vtbl;
                    WORD    low_fn;
                    WORD    high_fn;

                    if ( iMeth != -1 ) {
                        low_this = ReadWord(pbp+6);
                        high_this = ReadWord(pbp+8);

                        if ( low_this == 0 && high_this == 0 ) {
                            low_fn = 0;
                            high_fn = 0;
                            strcpy(symbol,"");
                        } else {
                            thisBase = GetInfoFromSelector( high_this, mode, NULL ) + IntelBase;
                            pvtbl = thisBase + (ULONG)low_this;

                            low_vtbl = ReadWord(pvtbl);
                            high_vtbl = ReadWord(pvtbl+2);

                            vtblBase = GetInfoFromSelector( high_vtbl, mode, NULL ) + IntelBase;
                            pfn = vtblBase + (ULONG)low_vtbl + iMeth;

                            low_fn = ReadWord(pfn);
                            high_fn = ReadWord(pfn+2);

                            b = FindSymbol( high_fn, (LONG)low_fn, symbol, &dist, BEFORE, mode );
                            if ( !b ) {
                                wsprintf(symbol,"%04X:%04X", high_fn, low_fn );
                            }
                        }
                    }
                    switch( iMeth ) {
                        default:
                        case -1:
                            if ( iMeth != -1 && (iMeth & 0x3) == 0 ) {
                                PRINTF(" %ccall far [Ind-%04X:%04x Method %d] %s", convention, high_this, low_this, iMeth/4, symbol );
                            } else {
                                PRINTF(" %ccall far [Indirect]", convention );
                            }
                            break;
                        case 0:
                            PRINTF(" %ccall far [Ind-%04X:%04X Method 0 - QI?] %s", convention, high_this, low_this, symbol);
                            break;
                        case 4:
                            PRINTF(" %ccall far [Ind-%04X:%04X Method 1 - AddRef?] %s", convention, high_this, low_this, symbol);
                            break;
                        case 8:
                            PRINTF(" %ccall far [Ind-%04X:%04X Method 2 - Release?] %s", convention, high_this, low_this, symbol);
                            break;
                    }
                }
            }
            if ( fParams ) {
                dump_params( pbp+6, convention, param_words );
            }
        }
        PRINTF("\n");
        *cs = new_cs;
        *csBase = new_csBase;
        return( 1 );
    }
    return( 0 );
}

int scan_for_frameless(
    WORD        ss,
    WORD        sp,
    WORD        next_bp,
    WORD        *cs,
    ULONG       ssBase,
    ULONG       *csBase,
    int         limit,
    int         mode,
    BOOL        fUseSymbols,
    BOOL        fParams
) {
    ULONG       pbp;
    int         result;
    int         cnt;

    cnt = 1000;
    sp -= 2;
    while ( limit ) {
        sp += 2;
        --cnt;
        if ( sp == next_bp || cnt == 0 ) {
            break;
        }

        pbp = ssBase + (ULONG)sp;

        result = look_for_near( pbp, *cs, ss, sp, 0, *csBase,
                                mode, fUseSymbols, fParams );
        if ( result ) {
            --limit;
            continue;
        }
        /*
        ** Check for far calls
        */
        result = look_for_far( pbp, cs, ss, sp, 0, csBase,
                               mode, fUseSymbols, fParams );
        if ( result ) {
            --limit;
            continue;
        }
    }

    return( 0 );
}

void stack_trace(
    WORD        ss,
    ULONG       ssBase,
    WORD        sp,
    WORD        bp,
    WORD        cs,
    ULONG       csBase,
    int         limit,
    int         mode,
    BOOL        fUseSymbols,
    BOOL        fGuessFrameless,
    BOOL        fParams
) {
    WORD        next_bp;
    ULONG       pbp;
    int         far_only;
    int         result;
    WORD        save_sp;
    WORD        save_bp;
    WORD        save_cs;
    ULONG       save_csBase;
    int         save_limit;

    save_sp = sp;
    save_bp = bp;
    save_cs = cs;
    save_csBase = csBase;
    save_limit = limit;

    PRINTF("[-Stack-] [-Retrn-] XY (X=Near/Far/far,Y=Call chain/BP Chain)\n");

    next_bp = bp;

    while ( limit ) {
        bp = next_bp;
        if ( bp == 0 ) {
            break;
        }
        if ( bp & 0x01 ) {
            far_only = 1;
            bp &= 0xFFFE;
        } else {
            far_only = 0;
        }
        pbp = ssBase + (ULONG)bp;
        next_bp = ReadWord(pbp);

        if ( fGuessFrameless ) {
            limit -= scan_for_frameless( ss, sp, bp, &cs,
                                         ssBase, &csBase, limit, mode, fUseSymbols,
                                         fParams );
        }

        if ( limit ) {
            /*
            ** Check for near calls
            */
            if ( far_only == 0 ) {
                result = look_for_near( pbp, cs, ss, bp, 1, csBase,
                                        mode, fUseSymbols, fParams );
                if ( result ) {
                    sp = bp + 4;
                    --limit;
                    continue;
                }
            }
            /*
            ** Check for far calls
            */
            result = look_for_far( pbp, &cs, ss, bp, 1, &csBase,
                                   mode, fUseSymbols, fParams );
            if ( result ) {
                sp = bp + 6;
                --limit;
                continue;
            }
            PRINTF("Could not find call\n");
            break;
        }
    }
    if ( fGuessFrameless ) {
        if ( limit ) {
            limit -= scan_for_frameless( 
                        ss, sp, 0, &cs, ssBase, &csBase, limit, mode,
                        fUseSymbols, fParams );
        }
    }
}

VOID
WalkStack(
) {
    VDMCONTEXT              ThreadContext;
    WORD                    bp;
    WORD                    sp;
    WORD                    ss;
    WORD                    cs;
    WORD                    ip;

    ULONG                   csBase;
    ULONG                   ssBase;
    int                     mode;
    int                     lines;

    mode = GetContext( &ThreadContext );
    IntelBase = GetIntelBase();

    sp = (WORD)ThreadContext.Esp;
    bp = (WORD)ThreadContext.Ebp;
    ss = (WORD)ThreadContext.SegSs;
    ip = (WORD)ThreadContext.Eip;
    cs = (WORD)ThreadContext.SegCs;

    csBase = GetInfoFromSelector( cs, mode, NULL ) + IntelBase;
    ssBase = GetInfoFromSelector( ss, mode, NULL ) + IntelBase;

    lines = 10;
    if (GetNextToken()) {
        lines = EXPRESSION( lpArgumentString );
    }

    stack_trace( ss,
                 ssBase,
                 sp,
                 bp,
                 cs,
                 csBase,
                 lines,
                 mode,
                 FALSE,
                 FALSE,
                 FALSE );
}

VOID
WalkStackVerbose(
) {
    VDMCONTEXT              ThreadContext;
    WORD                    bp;
    WORD                    sp;
    WORD                    ss;
    WORD                    cs;
    WORD                    ip;

    ULONG                   csBase;
    ULONG                   ssBase;
    int                     mode;
    int                     lines;

    mode = GetContext( &ThreadContext );
    IntelBase = GetIntelBase();

    sp = (WORD)ThreadContext.Esp;
    bp = (WORD)ThreadContext.Ebp;
    ss = (WORD)ThreadContext.SegSs;
    ip = (WORD)ThreadContext.Eip;
    cs = (WORD)ThreadContext.SegCs;

    csBase = GetInfoFromSelector( cs, mode, NULL ) + IntelBase;
    ssBase = GetInfoFromSelector( ss, mode, NULL ) + IntelBase;

    lines = 10;
    if (GetNextToken()) {
        lines = EXPRESSION( lpArgumentString );
    }

    stack_trace( ss,
                 ssBase,
                 sp,
                 bp,
                 cs,
                 csBase,
                 lines,
                 mode,
                 TRUE,
                 FALSE,
                 FALSE );
}

VOID
k(
    CMD_ARGLIST
    )
{
    CMD_INIT();
    WalkStack();

}


VOID
kb(
    CMD_ARGLIST
    )
{
    CMD_INIT();
    WalkStackVerbose();

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\vdmexts\system.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    system.c

Abstract:

    This file contains code to dump out the virtual machine state.

Author:

    Neil Sandlin (neilsa) 22-Nov-1995

Revision History:

--*/

#include <precomp.h>
#pragma hdrstop
#include "insignia.h"
#include "host_gen.h"
#define BIT_ORDER1 1
#include "dma.h"

VOID
dma(
    CMD_ARGLIST
    )
/*++

Routine Description:

    This routine dumps the virtual DMA state.

Return Value

    None.

--*/
{
    DMA_ADAPT adapter;
    DMA_CNTRL *dcp;
    int i,j;
    int chan = 0;

    CMD_INIT();

    if (!ReadMemExpression("ntvdm!adaptor", &adapter, sizeof(DMA_ADAPT))) {
        return;
    }

    PRINTF(" Virtual DMA State\n");
    PRINTF("       base base  cur  cur\n");
    PRINTF("chn pg addr cnt   addr cnt\n");
    PRINTF("--- -- ---- ----  ---- ----\n");

    for (i=0; i<DMA_ADAPTOR_CONTROLLERS; i++) {

        dcp = &adapter.controller[i];

        for (j=0; j<DMA_CONTROLLER_CHANNELS; j++) {

            PRINTF("%d   %.02X %.04X %.04X  %.04X %.04X", chan, adapter.pages.page[chan],
                        *(USHORT *)dcp->base_address[j], *(USHORT *)dcp->base_count[j],
                        *(USHORT *)dcp->current_address[j], *(USHORT *)dcp->current_count[j]);
            PRINTF("\n");

            chan++;
        }
    }

    PRINTF("\n");
}


VOID
ica(
    CMD_ARGLIST
    )
/*++

Routine Description:

    This routine dumps the virtual PIC state.

Return Value

    None.

--*/
{
    VDMVIRTUALICA VirtualIca[2];
    int i,j;

    CMD_INIT();

    if (!ReadMemExpression("ntvdm!VirtualIca", &VirtualIca, 2*sizeof(VDMVIRTUALICA))) {
        return;
    }

    PRINTF(" Virtual PIC State\n");
    PRINTF("              ");
    for (i=0; i<2; i++) {
        for(j=0; j<8; j++) {
            PRINTF("%01X", (VirtualIca[i].ica_base+j)/16);
        }
    }
    PRINTF("\n");

    PRINTF("              ");
    for (i=0; i<2; i++) {
        for(j=0; j<8; j++) {
            PRINTF("%01X", (VirtualIca[i].ica_base+j)&0xf);
        }
    }
    PRINTF("\n");
    PRINTF("              ----------------\n");

    PRINTF("Int Requests  ");
    for (i=0; i<2; i++) {
        for(j=0; j<8; j++) {
            PRINTF("%01X", (VirtualIca[i].ica_irr >> j)&0x1);
        }
    }
    PRINTF("\n");

    PRINTF("In Service    ");
    for (i=0; i<2; i++) {
        for(j=0; j<8; j++) {
            PRINTF("%01X", (VirtualIca[i].ica_isr >> j)&0x1);
        }
    }
    PRINTF("\n");

    PRINTF("Ints Masked   ");
    for (i=0; i<2; i++) {
        for(j=0; j<8; j++) {
            PRINTF("%01X", (VirtualIca[i].ica_imr >> j)&0x1);
        }
    }
    PRINTF("\n");
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\vdmexts\sym.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    heap.c

Abstract:

    This function contains the default ntsd debugger extensions

Author:

    Bob Day      (bobday) 29-Feb-1992 Grabbed standard header

Revision History:

    Neil Sandlin (NeilSa) 15-Jan-1996 Merged with vdmexts

--*/

#include <precomp.h>
#pragma hdrstop

#define MYOF_FLAGS (OF_READ | OF_SHARE_DENY_NONE)

#define MAX_MODULE_LIST 200
char ModuleList[MAX_MODULE_LIST][9];
int ModuleListCount = 0;

BOOL
GetVdmDbgEntry(
    LPSTR szEntryPoint,
    PVOID *pProc
    )
{
    HANDLE hModVDM;
    hModVDM = GetModuleHandle("VDMDBG.DLL");
    if (hModVDM == (HANDLE)NULL) {
        PRINTF("VDMEXTS: Can't find vdmdbg.dll\n");
        return FALSE;
    }

    *pProc = GetProcAddress(hModVDM, szEntryPoint);

    if (!*pProc) {
        PRINTF("VDMEXTS: Can't find VDMDBG.DLL entry point %s\n", szEntryPoint);
        return FALSE;
    }
    return TRUE;
}

PSEGENTRY
GetSegtablePointer(
    VOID
    )
{
    static PSEGENTRY (WINAPI *pfnVDMGetSegtablePointer)(VOID) = NULL;

    if (!pfnVDMGetSegtablePointer && !GetVdmDbgEntry("VDMGetSegtablePointer",
                                      (PVOID)&pfnVDMGetSegtablePointer)) {
        return NULL;
    }

    return((*pfnVDMGetSegtablePointer)());
}


VOID
ParseModuleName(
    LPSTR szName,
    LPSTR szPath
    )
/*++

    Routine Description:

        This routine strips off the 8 character file name from a path

    Arguments:

        szName - pointer to buffer of 8 characters (plus null)
        szPath - full path of file

    Return Value

        None.

--*/

{
    LPSTR lPtr = szPath;
    LPSTR lDest = szName;
    int BufferSize = 9;

    while(*lPtr) lPtr++;     // scan to end

    while( ((DWORD)lPtr > (DWORD)szPath) &&
           ((*lPtr != '\\') && (*lPtr != '/'))) lPtr--;

    if (*lPtr) lPtr++;

    while((*lPtr) && (*lPtr!='.')) {
        if (!--BufferSize) break;
        *lDest++ = *lPtr++;
    }

    *lDest = 0;
}

BOOL
FindModuleNameList(
    LPSTR filename
    )
{
    int i;

    for (i=0; i<ModuleListCount; i++) {

        if (!_stricmp(filename, ModuleList[i])) {
            return TRUE;
        }
    }
    return FALSE;
}

BOOL
AddModuleNameList(
    LPSTR filename
    )
{
    if (!strlen(filename)) {
        return FALSE;
    }

    if (!FindModuleNameList(filename)) {
        if (ModuleListCount>=(MAX_MODULE_LIST-1)) {
            return FALSE;
        }
        strcpy (ModuleList[ModuleListCount++], filename);
    }
    return TRUE;
}

VOID
FreeModuleNameList(
    VOID
    )
{
    ModuleListCount = 0;
    return;
}

VOID
BuildModuleNameList(
    VOID
    )
{
    HEAPENTRY he = {0};
    SEGENTRY  *se;
    char      filename[9];
    WORD sel;
    BOOL    b;
    NEHEADER owner;
    ULONG base;
    CHAR ModuleName[9];
    UCHAR len;

    //
    // Search WOW Module list
    //

    if (!ReadMemExpression("ntvdmd!DbgWowhExeHead", &sel, sizeof(sel))) {
        return;
    }

    while(sel) {

        base = GetInfoFromSelector(sel, PROT_MODE, NULL) + GetIntelBase();

        b = READMEM((LPVOID)base, &owner, sizeof(owner));

        if (!b || (owner.ne_magic != 0x454e)) {
            PRINTF("Invalid module list! (started with hExeHead)\n");
            return;
        }

        len = ReadByteSafe(base+owner.ne_restab);
        if (len>8) {
            len=8;
        }
        READMEM((LPVOID)(base+owner.ne_restab+1), ModuleName, 8);

        ModuleName[len] = 0;
        AddModuleNameList(ModuleName);

        // This is mapped to ne_pnextexe in kernel
        sel = owner.ne_cbenttab;
    }

    //
    // Search debugger segment array
    //

    se = GetSegtablePointer();
    while ( se ) {
        ParseModuleName(filename, se->szExePath);
        AddModuleNameList(filename);

        se = se->Next;
    }
}


BOOL
GetOwnerSegmentFromSelector(
    WORD        selector,
    int         mode,
    LPSTR       szModule,
    WORD       *psegment
    )
/*++

    Routine Description:

        This routine returns the "segment number" and owner name
        of the given selector or v86mode segment. The returned number
        represents the position of the segment in the binary, and is 1-based.

    Arguments:

        selector - either PMODE selector or V86 mode segment
        mode     - PROT_MODE or V86_MODE
        filename - pointer to buffer to receive module name
        psegment - pointer to WORD to receive segment number

    Return Value

        TRUE if found

--*/

{
    HEAPENTRY   he = {0};
    SEGENTRY  *se;

    he.Selector = selector;
    if (FindHeapEntry(&he, FHE_FIND_SEL_ONLY, FHE_FIND_QUIET)) {
        strcpy(szModule, he.FileName);
        *psegment = he.SegmentNumber+1;
        return TRUE;
    }

    se = GetSegtablePointer();
    while ( se ) {
        if (se->selector == selector) {
            ParseModuleName(szModule, se->szExePath);
            *psegment = se->segment;
            return TRUE;
        }
        se = se->Next;
    }

    return FALSE;
}

BOOL
GetSelectorFromOwnerSegment(
    LPSTR       szModule,
    WORD        segment,
    WORD       *pselector,
    int        *pmode
    )
{
    HEAPENTRY   he = {0};
    char tempModule[9];
    SEGENTRY  *se;

    while (FindHeapEntry(&he, FHE_FIND_SEL_ONLY, FHE_FIND_QUIET)) {

        if (!_stricmp(szModule, he.FileName) &&
             (segment == he.SegmentNumber+1)) {

            *pselector = he.gnode.pga_handle|1;
            *pmode = PROT_MODE;
            return TRUE;
        }
    }

    se = GetSegtablePointer();
    while ( se ) {

        ParseModuleName(tempModule, se->szExePath);

        if (!_stricmp(szModule, tempModule) &&
            (segment == se->segment+1)) {

            *pselector = se->selector;
            if (se->type == SEGTYPE_V86) {
                *pmode = V86_MODE;
            } else {
                *pmode = PROT_MODE;
            }
            return TRUE;

        }
        se = se->Next;
    }
    return FALSE;
}


BOOL
FindSymbol(
    WORD        selector,
    LONG        offset,
    LPSTR       sym_text,
    LONG        *dist,
    int         direction,
    int         mode
    )
{
    char filename[9];
    WORD segment;
    static VDMGETSYMBOLPROC pfnGetSymbol = NULL;

    if (!pfnGetSymbol && !GetVdmDbgEntry("VDMGetSymbol", (PVOID)&pfnGetSymbol)) {
        return FALSE;
    }


    if (GetOwnerSegmentFromSelector(selector, mode, filename, &segment)) {
        return(pfnGetSymbol(filename,
                             segment,
                             offset,
                             (mode == PROT_MODE),
                             (direction == AFTER),
                             sym_text,
                             dist));
    }
    return FALSE;
}


BOOL
FindAddress(
    LPSTR       sym_text,
    LPSTR       filename,
    WORD        *psegment,
    WORD        *pselector,
    LONG        *poffset,
    int         *pmode,
    BOOL        bDumpAll
    )
{
    int i;
    BOOL bResult;
    static VDMGETADDREXPRESSIONPROC pfnGetAddrExpression = NULL;
    WORD type;
    char module[9];

    if (!pfnGetAddrExpression && !GetVdmDbgEntry("VDMGetAddrExpression",
                                 (PVOID)&pfnGetAddrExpression)) {
        return FALSE;
    }

    BuildModuleNameList();
    for (i=0; i<ModuleListCount; i++) {
        bResult = pfnGetAddrExpression(ModuleList[i],
                                 sym_text,
                                 pselector,
                                 poffset,
                                 &type);
        if (bResult) {
            strcpy(filename, ModuleList[i]);

            if (type == VDMADDR_V86) {
                *pmode = V86_MODE;
            } else {
                *pmode = PROT_MODE;
            }

            if (!GetOwnerSegmentFromSelector(*pselector, *pmode,
                                             module, psegment)) {
                *pmode = NOT_LOADED;
            }
            return TRUE;
        }
    }
    return FALSE;
}

VOID
ln(
    CMD_ARGLIST
) {
    VDMCONTEXT              ThreadContext;
    WORD                    selector;
    LONG                    offset;
    CHAR                    sym_text[1000];
    DWORD                   dist;
    BOOL                    b;
    int                     mode;

    CMD_INIT();

    mode = GetContext( &ThreadContext );

    if (!GetNextToken()) {
        selector = (WORD) ThreadContext.SegCs;
        offset   = ThreadContext.Eip;
    } else if (!ParseIntelAddress(&mode, &selector, &offset)) {
        return;
    }


    if ( mode == PROT_MODE ) {
        PRINTF( "#%04X:%04lX", selector, offset );
    }
    if ( mode == V86_MODE ) {
        PRINTF( "&%04X:%04lX", selector, offset );
    }


    b = FindSymbol( selector, offset, sym_text, &dist, BEFORE, mode );
    if ( !b ) {
        PRINTF(" = Could not find symbol before");
    } else {
        if ( dist == 0 ) {
            PRINTF(" = %s", sym_text );
        } else {
            PRINTF(" = %s+0x%lx", sym_text, dist );
        }
    }
    b = FindSymbol( selector, offset, sym_text, &dist, AFTER, mode );
    if ( !b ) {
        PRINTF(" | Could not find symbol after");
    } else {
        if ( dist == 0 ) {
            PRINTF(" | %s", sym_text );
        } else {
            PRINTF(" | %s-0x%lx", sym_text, dist );
        }
    }
    PRINTF("\n");
}

VOID
x(
    CMD_ARGLIST
) {
    VDMCONTEXT              ThreadContext;
    BOOL                    result;
    WORD                    selector;
    WORD                    segment;
    LONG                    offset;
    int                     mode;
    char                    filename[9];

    CMD_INIT();

    try {

        mode = GetContext( &ThreadContext );

        result = FindAddress( lpArgumentString,
                              filename,
                              &segment,
                              &selector,
                              &offset,
                              &mode,
                              TRUE);

        if ( result ) {
            if ( mode == PROT_MODE ) {
                PRINTF("#");
            } else if ( mode == V86_MODE ) {
                PRINTF("&");
            } else if ( mode == NOT_LOADED ) {
                selector = 0;
                PRINTF("?");
            }

            PRINTF("%04X:%04X = %s(%04X)!%s\n",
                    selector, offset, filename, segment, lpArgumentString );
            return;
        }

        PRINTF("Could not find symbol '%s'\n", lpArgumentString );

    } except (1) {

        PRINTF("Exception 0x%08x in vdmexts!\n", GetExceptionCode());

    }
}

/****************************************************************************
 ****************************************************************************

   extension debugging routines

   The following functions were added to help debug the debugger extension.
   They are not intended to be used in normal operation.

 ****************************************************************************
 ****************************************************************************/

VOID
DumpModuleNameList(
    VOID
    )
{
    int i;

    for (i=0; i<ModuleListCount; i++) {
        PRINTF("%d %s\n", i, ModuleList[i]);
    }
}


VOID
moddump(
    CMD_ARGLIST
    )
{
    CMD_INIT();
    BuildModuleNameList();
    DumpModuleNameList();
}

VOID
segdef(
    CMD_ARGLIST
    )
{
    int       cnt;
    int       UpdateCnt;
    SEGENTRY  *se;
    WORD        selector;
    WORD        segment;
    DWORD     length;
    int         type;


    CMD_INIT();

    se = GetSegtablePointer();

    if (!GetNextToken()) {
        PRINTF("Missing index\n");
        return;
    }
    UpdateCnt = (int) EvaluateToken();


    if (!GetNextToken()) {
        PRINTF("Missing selector\n");
        return;
    }
    selector = (WORD) EvaluateToken();


    if (!GetNextToken()) {
        PRINTF("Missing segment\n");
        return;
    }
    segment = (WORD) EvaluateToken();


    if (!GetNextToken()) {
        PRINTF("Missing limit\n");
        return;
    }
    length = EvaluateToken();


    if (!GetNextToken()) {
        PRINTF("Missing type\n");
        return;
    }
    type = (int) EvaluateToken();


    if (!GetNextToken()) {
        PRINTF("Missing path\n");
        return;
    }

    cnt = 0;
    while ( se ) {
        if (cnt == UpdateCnt) {
            se->selector = selector;
            se->segment = segment;
            se->length = length;
            se->type = type;
            strcpy(se->szExePath, lpArgumentString);
            break;
        }
        cnt++;
        se = se->Next;
    }

}

VOID
segdump(
    CMD_ARGLIST
    )
{
    int       cnt;
    int       DumpCnt;
    SEGENTRY  *se;

    CMD_INIT();

    PRINTF("Index Sel  Seg   Length  Type  Module   Path\n");
    se = GetSegtablePointer();

    if (GetNextToken()) {
        DumpCnt = (int) EvaluateToken();

        cnt = 0;
        while ( se ) {
            if (DumpCnt == cnt) {
                PRINTF("%03x   %04x %04x %08x %s %s %s\n", cnt,
                    se->selector, se->segment, se->length,
                    ((se->type==SEGTYPE_V86) ? "v86 " : "prot"),
                    se->szModule, se->szExePath);
                break;
            }
            cnt++;
            se = se->Next;
        }
        return;
    }


    cnt = 0;
    while ( se ) {
        PRINTF("%03x   %04x %04x %08x %s %s %s\n", cnt,
                se->selector, se->segment, se->length,
                ((se->type==SEGTYPE_V86) ? "v86 " : "prot"),
                se->szModule, se->szExePath);
        cnt++;
        se = se->Next;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\vdmexts\trace.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    trace.c

Abstract:

    This file contains code to dump the ntvdm trace history log

Author:

    Neil Sandlin (neilsa) 1-Nov-1995

Revision History:

--*/

#include <precomp.h>
#pragma hdrstop
#include <dbgsvc.h>
#include <dpmi.h>

ULONG TimeIndex;
ULONG TimerMode = 0;
ULONG CpuSpeed = 0;
BOOL bTriedToGetCpuSpeed = FALSE;
#define CPUSPEED_PATH "Hardware\\Description\\System\\CentralProcessor\\0"
#define CPUSPEED_VALUE "~MHz"

VOID
DumpTypeGeneric(
    VDM_TRACEENTRY te
    )
{
    PRINTF("%.4x: %.4X %.8X", te.Type, te.wData, te.lData);
}


VOID
DumpTypeKernel(
    VDM_TRACEENTRY te
    )
{

    switch(te.Type&0xff) {
    case VDMTR_KERNEL_HW_INT:
        PRINTF("Hw Int       %.2x ", te.wData);
        break;

    case VDMTR_KERNEL_OP_PM:
    case VDMTR_KERNEL_OP_V86:
        PRINTF("OpEm   ");

        switch(te.wData&0xff) {

        case 0xec:
            PRINTF("INB");
            break;

        case 0xee:
            PRINTF("OUTB");
            break;

        case 0xfa:
            PRINTF("CLI");
            break;

        case 0xfb:
            PRINTF("STI");
            break;

        default:
            PRINTF("  %.2x ", te.wData);
        }
        break;


    default:
        PRINTF("Unknown : %d", te.Type&0xff);
        return;
    }
}


VOID
DumpTypeDpmi(
    VDM_TRACEENTRY te
    )
{
    //
    // Dpmi dispatch table entries
    //
    static char szDispatchEntries[MAX_DPMI_BOP_FUNC][40] = {
                                 "InitDosxRM",
                                 "InitDosx",
                                 "InitLDT",
                                 "GetFastBopAddress",
                                 "InitIDT",
                                 "InitExceptionHandlers",
                                 "InitApp",
                                 "TerminateApp",
                                 "InUse",
                                 "NoLongerInUse",
                                 "switch_to_protected_mode",
                                 "switch_to_real_mode",
                                 "SetAltRegs",
                                 "IntHandlerIret16",
                                 "IntHandlerIret32",
                                 "FaultHandlerIret16",
                                 "FaultHandlerIret32",
                                 "UnhandledExceptionHandler",
                                 "RMCallBackCall",
                                 "ReflectIntrToPM",
                                 "ReflectIntrToV86",
                                 "InitPmStackInfo",
                                 "VcdPmSvcCall32",
                                 "SetDescriptorEntry",
                                 "ResetLDTUserBase",
                                 "XlatInt21Call",
                                 "Int31"
                                 };


    switch(te.Type&0xff) {
    case DPMI_DISPATCH_INT:
        PRINTF("Dispatch Int %.2x ", te.wData);
        break;
    case DPMI_HW_INT:
        PRINTF("Hw Int       %.2x ", te.wData);
        break;
    case DPMI_SW_INT:
        PRINTF("Sw Int       %.2x ", te.wData);
        break;

    case DPMI_FAULT:
        PRINTF("Fault        %.2x ec=%.8x", te.wData, te.lData);
        break;
    case DPMI_DISPATCH_FAULT:
        PRINTF("Dispatch Flt %.2x ", te.wData);
        break;

    case DPMI_FAULT_IRET:
        PRINTF("Fault Iret");
        break;
    case DPMI_INT_IRET16:
        PRINTF("Int Iret16");
        break;
    case DPMI_INT_IRET32:
        PRINTF("Int Iret32");
        break;

    case DPMI_OP_EMULATION:
        PRINTF("Op Emulation");
        break;

    case DPMI_DISPATCH_ENTRY:
        PRINTF("Dispatch(%d): ", te.wData);
        if (te.lData >= MAX_DPMI_BOP_FUNC) {
            PRINTF("Unknown (%d)", te.lData);
        } else {
            PRINTF("%s", szDispatchEntries[te.lData]);
        }
        break;

    case DPMI_DISPATCH_EXIT:
        PRINTF("Exit(%d):     ", te.wData);
        if (te.lData >= MAX_DPMI_BOP_FUNC) {
            PRINTF("Unknown (%d)", te.lData);
        } else {
            PRINTF("%s", szDispatchEntries[te.lData]);
        }
        break;

    case DPMI_SWITCH_STACKS:
        PRINTF("switch stack -> %.4x:%.8x", te.wData, te.lData);
        break;

    case DPMI_GENERIC:
        PRINTF("Data: %.4x %.8x", te.wData, te.lData);
        break;

    case DPMI_IN_V86:
        PRINTF("in V86 mode");
        break;

    case DPMI_IN_PM:
        PRINTF("in protect mode");
        break;

    case DPMI_REFLECT_TO_PM:
        PRINTF("Reflect to PM");
        break;

    case DPMI_REFLECT_TO_V86:
        PRINTF("Reflect to V86");
        break;

    default:
        PRINTF("Unknown : %d", te.Type&0xff);
        return;
    }
}

VOID
DumpTypeMonitor(
    VDM_TRACEENTRY te
    )
{
    static char szMonitorEntries[][20] = {
                                 "Event IO",
                                 "Event String IO",
                                 "Event Mem Access",
                                 "Event Int Ack",
                                 "Event BOP",
                                 "Event Error",
                                 "Event Irq 13",
                                 "Cpu Simulate",
                                 "Cpu Unsimulate",
                                 };

    if ((te.Type&0xff) <= MONITOR_CPU_UNSIMULATE) {
        PRINTF("%s", szMonitorEntries[(te.Type&0xff)-1]);
        PRINTF(": %.4X %.8X", te.wData, te.lData);
    } else {
        DumpTypeGeneric(te);
    }
}

VOID
DumpTimeInfo(
    VDM_TRACEENTRY te
    )
{

    ULONG USecs = 0;

    switch(TimerMode) {

    case VDMTI_TIMER_TICK:
        PRINTF("%d.%.3d", TimeIndex/1000, TimeIndex%1000);
        PRINTF(" %.8X  ", te.Time);
        break;

    case VDMTI_TIMER_PENTIUM:

        if (CpuSpeed) {
            USecs = TimeIndex / CpuSpeed;
        }
        PRINTF("%5d.%.3d", USecs/1000, USecs%1000);
        PRINTF(" %.8X  ", te.Time);
        break;
    }


}


VOID
DumpTraceEntry(
    int index,
    VDM_TRACEENTRY te,
    ULONG Verbosity
    )

{

    PRINTF("%4x ",index);
    DumpTimeInfo(te);

    switch(te.Type & 0xff00) {
    case (VDMTR_TYPE_KERNEL):
        PRINTF("Krnl ");
        DumpTypeKernel(te);
        break;

    case (VDMTR_TYPE_DPMI):
        PRINTF("Dpmi ");
        DumpTypeDpmi(te);
        break;

    case (VDMTR_TYPE_DPMI_SF):
        PRINTF("Dpmi Set Fault Handler %.02X -> %.4X:%.8X", te.Type & 0xff, te.wData, te.lData);
        break;

    case (VDMTR_TYPE_DPMI_SI):
        PRINTF("Dpmi Set Int Handler %.02X -> %.4X:%.8X", te.Type & 0xff, te.wData, te.lData);
        break;

    case (VDMTR_TYPE_DEM):
        PRINTF("Dem  ");
        switch(te.Type & 0xff) {
        case 1:
            PRINTF("Dispatch: %.4X %.8X", te.wData, te.lData);
            break;
        case 2:
            PRINTF("Exit:     %.4X %.8X", te.wData, te.lData);
            break;
        default:
            DumpTypeGeneric(te);
        }
        break;

    case (VDMTR_TYPE_WOW):
        PRINTF("Wow  ");
        DumpTypeGeneric(te);
        break;

    case (VDMTR_TYPE_VSBD):
        PRINTF("Vsbd ");
        DumpTypeGeneric(te);
        break;

    case (VDMTR_TYPE_DBG):
        PRINTF("Dbg  ");
        DumpTypeGeneric(te);
        break;

    case (VDMTR_TYPE_MONITOR):
        PRINTF("Mon  ");
        DumpTypeMonitor(te);
        break;

    default:
        PRINTF("     ");
        DumpTypeGeneric(te);
    }

    if (Verbosity) {
        PRINTF("\n");

        PRINTF("eax=%08lx ebx=%08lx ecx=%08lx edx=%08lx esi=%08lx edi=%08lx\n",
            te.eax, te.ebx, te.ecx, te.edx, te.esi, te.edi );

        PRINTF("eip=%08lx esp=%08lx ebp=%08lx                ",
            te.eip, te.esp, te.ebp );

        if ( te.eflags & FLAG_OVERFLOW ) {
            PRINTF("ov ");
        } else {
            PRINTF("nv ");
        }
        if ( te.eflags & FLAG_DIRECTION ) {
            PRINTF("dn ");
        } else {
            PRINTF("up ");
        }
        if ( te.eflags & FLAG_INTERRUPT ) {
            PRINTF("ei ");
        } else {
            PRINTF("di ");
        }
        if ( te.eflags & FLAG_SIGN ) {
            PRINTF("ng ");
        } else {
            PRINTF("pl ");
        }
        if ( te.eflags & FLAG_ZERO ) {
            PRINTF("zr ");
        } else {
            PRINTF("nz ");
        }
        if ( te.eflags & FLAG_AUXILLIARY ) {
            PRINTF("ac ");
        } else {
            PRINTF("na ");
        }
        if ( te.eflags & FLAG_PARITY ) {
            PRINTF("po ");
        } else {
            PRINTF("pe ");
        }
        if ( te.eflags & FLAG_CARRY ) {
            PRINTF("cy ");
        } else {
            PRINTF("nc ");
        }
        PRINTF("\n");
        PRINTF("cs=%04x  ss=%04x  ds=%04x  es=%04x  fs=%04x  gs=%04x             efl=%08lx\n",
                te.cs, te.ss, te.ds, te.es, te.fs, te.gs, te.eflags );

    }

    TimeIndex += te.Time;
    PRINTF("\n");
}


VOID
DumpTrace(
    IN ULONG Verbosity
    )
/*++

Routine Description:

    This routine dumps the DPMI trace history buffer.

Arguments:

Return Value

    None.

--*/
{
    PVOID pMem;
    ULONG TraceBase, TraceEnd, TraceCurrent;
    ULONG Lines;
    VDM_TRACEINFO TraceInfo;
    VDM_TRACEENTRY TraceEntry;
    ULONG Count = 0;
    ULONG EntryID;
    ULONG NumEntries;

    if (!ReadMemExpression("ntvdm!pVdmTraceInfo", &pMem, 4)) {
        return;
    }

    if (!READMEM(pMem, &TraceInfo, sizeof(VDM_TRACEINFO))) {
        PRINTF("Error reading memory for TraceInfo\n");
        return;
    }

    if (!TraceInfo.pTraceTable) {
        PRINTF("NTVDM trace history not available\n");
        return;
    }

    if (!CpuSpeed && !bTriedToGetCpuSpeed) {
        HKEY hKey;
        DWORD retCode;
        DWORD dwType, cbData = sizeof(ULONG);
        ULONG dwData;
       
        retCode = RegOpenKeyEx (HKEY_LOCAL_MACHINE,
                                CPUSPEED_PATH,
                                0,
                                KEY_EXECUTE, // Requesting read access.
                                &hKey);
       
       
        if (!retCode) {
       
            retCode = RegQueryValueEx(hKey,
                                      CPUSPEED_VALUE,
                                      NULL,
                                      &dwType,
                                      (LPSTR)&dwData,
                                      &cbData);
           
            RegCloseKey(hKey);
           
            if (!retCode) {
                CpuSpeed = dwData;
            }
        }
        bTriedToGetCpuSpeed = TRUE;
        if (!CpuSpeed) {
            PRINTF("Error retrieving CPU speed\n");
        }
    }


    TimeIndex = 0;

    NumEntries   = TraceInfo.NumPages*4096/sizeof(VDM_TRACEENTRY);
    TraceBase    = (ULONG) TraceInfo.pTraceTable;
    TraceEnd     = (ULONG) &TraceInfo.pTraceTable[NumEntries];
    TraceCurrent = (ULONG) &TraceInfo.pTraceTable[TraceInfo.CurrentEntry];


    if ((TraceBase & 0xfff) || (TraceEnd & 0xfff) ||
        (TraceCurrent & 0x3f) ||
        (TraceBase > TraceEnd) ||
        (TraceCurrent > TraceEnd) || (TraceCurrent < TraceBase)) {
        PRINTF("TraceBuffer=%.8X, end=%.8X, current=%.8X\n",
                TraceBase, TraceEnd, TraceCurrent);
        PRINTF("Trace buffer info appears corrupt!\n");
        return;
    }

    if (Verbosity) {
        Lines = 8;
    } else {
        Lines = 32;
    }

    EntryID = 1;

    if (GetNextToken()) {
        if (*lpArgumentString == '#') {
            lpArgumentString++;
            EntryID = EvaluateToken();

            if (EntryID > NumEntries) {
                PRINTF("Requested trace entry out of range - %X\n", EntryID);
                return;
            }

        }

        if (GetNextToken()) {

            Lines = (int)EXPRESSION(lpArgumentString);
            if (Lines > NumEntries) {
                PRINTF("Requested count too large - %d\n", Lines);
                return;
            }
        }
    }


    TraceCurrent = (ULONG) &TraceInfo.pTraceTable[(TraceInfo.CurrentEntry-(EntryID-1))%NumEntries];
    TimerMode = (UCHAR) TraceInfo.Flags & VDMTI_TIMER_MODE;

    switch(TimerMode) {

    case VDMTI_TIMER_TICK:
        PRINTF("deltaT is in MSec, Time is in Seconds\n");
        PRINTF("\n#    Time  DeltaT    Event\n");
        break;
    case VDMTI_TIMER_PENTIUM:
        PRINTF("deltaT is at %d MHz, Time is in MSec\n", CpuSpeed);
        PRINTF("\nlog#     Time  DeltaT    Event\n");
        break;
    default:
        PRINTF("\n#    Event\n");
    }


    while (Lines--) {

        TraceCurrent -= sizeof(VDM_TRACEENTRY);
        if (TraceCurrent < TraceBase) {
            TraceCurrent = TraceEnd - sizeof(VDM_TRACEENTRY);
        }

        if (!READMEM((PVOID)TraceCurrent, &TraceEntry, sizeof(VDM_TRACEENTRY))) {
            PRINTF("Error reading memory at %.08X\n", pMem);
            return;
        }

        if (!TraceEntry.Type) {
            if (!Count) {
                if (EntryID == 1) {
                    PRINTF("<Log is empty>\n");
                } else {
                    PRINTF("<End of log>\n");
                }
            } else {
                PRINTF("<End of log>\n");
            }
            break;
        }

        //PRINTF("%.8x  ", TraceCurrent);

        DumpTraceEntry(EntryID++, TraceEntry, Verbosity);
        ++Count;

        if (EntryID >= NumEntries) {
            PRINTF("<End of log>\n");
            break;
        }

    }


}


VOID
lgr(
    CMD_ARGLIST
    )
{
    CMD_INIT();

    DumpTrace(1);
}

VOID
lg(
    CMD_ARGLIST
    )
{
    CMD_INIT();

    DumpTrace(0);
}



VOID
lgt(
    CMD_ARGLIST
    )
{
    PVOID pMem;
    VDM_TRACEINFO TraceInfo;
    UCHAR DbgTimerMode;
    BOOL DbgTimerInitialized;
    ULONG NewTimerMode;

    CMD_INIT();

    if (!ReadMemExpression("ntvdmd!DbgTimerMode", &DbgTimerMode, sizeof(UCHAR))) {
        return;
    }

    if (!ReadMemExpression("ntvdmd!DbgTimerInitialized", &DbgTimerInitialized, sizeof(BOOL))) {
        return;
    }

    if (GetNextToken()) {

        NewTimerMode = EvaluateToken();

        switch(NewTimerMode) {
        case 0:
            PRINTF("Event log timer is now OFF\n");
            break;

        case VDMTI_TIMER_TICK:
            PRINTF("Event log timer resolution set to ~10msec (GetTickCount)\n");
            break;

        case VDMTI_TIMER_PERFCTR:
            PRINTF("Event log timer resolution set to 100nsec (QueryPerformanceCounter)\n");
            break;

        case VDMTI_TIMER_PENTIUM:
            PRINTF("Event log timer resolution set to pentium time stamp counter\n");
            break;

        default:
            PRINTF("Invalid selection - enter 0-3\n");
            return;
        }

        pMem = (PVOID)(*GetExpression)("ntvdmd!DbgTimerMode");
        if (!pMem) {
            PRINTF("Could not find symbol ntvdmd!DbgTimerMode\n");
            return;
        }

        if (!WRITEMEM((PVOID)pMem, &NewTimerMode, sizeof(UCHAR))) {
            PRINTF("Error writing memory\n");
            return;
        }

        pMem = (PVOID)(*GetExpression)("ntvdmd!DbgTimerInitialized");

        if (!pMem) {
            PRINTF("Could not find symbol ntvdmd!DbgTimerInitialized\n");
            return;
        }

        DbgTimerInitialized = FALSE;
        if (!WRITEMEM((PVOID)pMem, &DbgTimerInitialized, sizeof(UCHAR))) {
            PRINTF("Error writing memory\n");
            return;
        }

    } else {


        if (!ReadMemExpression("ntvdm!pVdmTraceInfo", &pMem, sizeof(LPVOID))) {
            return;
        }

        if (!READMEM(pMem, &TraceInfo, sizeof(VDM_TRACEINFO))) {
            PRINTF("Error reading memory for TraceInfo\n");
            return;
        }

        PRINTF("Timer has%sbeen initialized\n", DbgTimerInitialized ? " " : " not ");
        PRINTF("Requested timer resolution == %d\n", DbgTimerMode);
        PRINTF("Current timer resolution == %d\n", TraceInfo.Flags & VDMTI_TIMER_MODE);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\vdmexts\util.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    heap.c

Abstract:

    This function contains the default ntsd debugger extensions

Author:

    Bob Day      (bobday) 29-Feb-1992 Grabbed standard header

Revision History:

    Neil Sandlin (NeilSa) 15-Jan-1996 Merged with vdmexts
                                      Added command line parsing

--*/

#include <precomp.h>
#pragma hdrstop

VDMCONTEXT ThreadContext;

PVOID LdtAddress = NULL;

BOOL
WINAPI
ReadProcessMem(
    LPVOID lpBaseAddress,
    LPVOID lpBuffer,
    DWORD nSize
    )
{
    return ReadProcessMemory( hCurrentProcess, lpBaseAddress, lpBuffer, nSize, NULL );
}

BOOL
WINAPI
WriteProcessMem(
    LPVOID lpBaseAddress,
    LPVOID lpBuffer,
    DWORD nSize
    )
{
    return WriteProcessMemory( hCurrentProcess, lpBaseAddress, lpBuffer, nSize, NULL );
}

#ifndef i386

//
// The following two routines implement the very funky way that we
// have to get register values on the 486 emulator.
//

ULONG
GetRegValue(
    NT_CPU_REG reg,
    BOOL bInNano,
    ULONG UMask
    )

{
    if (bInNano) {

        return(ReadDwordSafe(reg.nano_reg));

    } else if (UMask & reg.universe_8bit_mask) {

        return (ReadDwordSafe(reg.saved_reg) & 0xFFFFFF00 |
                ReadDwordSafe(reg.reg) & 0xFF);

    } else if (UMask & reg.universe_16bit_mask) {

        return (ReadDwordSafe(reg.saved_reg) & 0xFFFF0000 |
                ReadDwordSafe(reg.reg) & 0xFFFF);

    } else {

        return (ReadDwordSafe(reg.reg));

    }
}

ULONG
GetEspValue(
    NT_CPU_INFO nt_cpu_info,
    BOOL bInNano
    )

{
    if (bInNano) {

        return (ReadDwordSafe(nt_cpu_info.nano_esp));

    } else {

        if (ReadDwordSafe(nt_cpu_info.stack_is_big)) {

            return (ReadDwordSafe(nt_cpu_info.host_sp) -
                    ReadDwordSafe(nt_cpu_info.ss_base));

        } else {

            return (ReadDwordSafe(nt_cpu_info.esp_sanctuary) & 0xFFFF0000 |
                    (ReadDwordSafe(nt_cpu_info.host_sp) -
                     ReadDwordSafe(nt_cpu_info.ss_base) & 0xFFFF));

        }

    }

}

#endif

int
GetContext(
    VDMCONTEXT* lpContext
)
/*
    GetContext

    This function fills in the specified context record with
    the content of the 16-bit registers. The return value is
    the mode (v86 or PROT) of the client.

    Note that on x86, if the machine is currently in the monitor,
    we have to pick up the values from the VdmTib and IntelMSW.

*/
{
#ifndef i386    //
    int         mode;
    ULONG       pTmp;
    NT_CPU_INFO nt_cpu_info;
    BOOL        b;
    BOOL        bInNano;
    ULONG       UMask;
#if 0
    DWORD MyEflags;
#endif

    pTmp = (ULONG)EXPRESSION("ntvdm!nt_cpu_info");

    if ( pTmp ) {

        b = READMEM((LPVOID) pTmp, &nt_cpu_info, sizeof(NT_CPU_INFO));

        if ( !b ) {
            PRINTF("Could not read IntelRegisters context out of process\n");
            return( -1 );
        }

        bInNano = ReadDwordSafe((ULONG) nt_cpu_info.in_nano_cpu);
        UMask   = ReadDwordSafe((ULONG) nt_cpu_info.universe);

        lpContext->Eax = GetRegValue(nt_cpu_info.eax, bInNano, UMask);
        lpContext->Ecx = GetRegValue(nt_cpu_info.ecx, bInNano, UMask);
        lpContext->Edx = GetRegValue(nt_cpu_info.edx, bInNano, UMask);
        lpContext->Ebx = GetRegValue(nt_cpu_info.ebx, bInNano, UMask);
        lpContext->Ebp = GetRegValue(nt_cpu_info.ebp, bInNano, UMask);
        lpContext->Esi = GetRegValue(nt_cpu_info.esi, bInNano, UMask);
        lpContext->Edi = GetRegValue(nt_cpu_info.edi, bInNano, UMask);

        lpContext->Esp    = GetEspValue(nt_cpu_info, bInNano);

        //
        // nt_cpu_info.flags isn't very much use, because several of the
        // flags values are not kept in memory, but computed each time.
        // The emulator doesn't supply us with the right value, so we
        // try to get it from the code in VdmDebugger
        //

        lpContext->EFlags = ReadDwordSafe(nt_cpu_info.flags);
#if 0
        lpContext->EFlags = 0xffffffff;         // indicate value unknown

        if (InVdmPrompt() &&
            (pTmp = (ULONG)EXPRESSION("ntvdmd!VdmDbgEFLAGS"))        &&
            (READMEM((LPVOID) pTmp, &MyEflags, sizeof(DWORD))))  {

                lpContext->EFlags = MyEflags;

        }
#endif

        lpContext->Eip    = ReadDwordSafe(nt_cpu_info.eip);

        lpContext->SegEs = ReadWordSafe(nt_cpu_info.es);
        lpContext->SegCs = ReadWordSafe(nt_cpu_info.cs);
        lpContext->SegSs = ReadWordSafe(nt_cpu_info.ss);
        lpContext->SegDs = ReadWordSafe(nt_cpu_info.ds);
        lpContext->SegFs = ReadWordSafe(nt_cpu_info.fs);
        lpContext->SegGs = ReadWordSafe(nt_cpu_info.gs);


    } else {

        PRINTF("Could not find the symbol 'ntvdm!nt_cpu_info'\n");
        return( -1 );
    }

    if ( !(ReadDwordSafe(nt_cpu_info.cr0) & 1) ) {
        mode = V86_MODE;
    } else {
        mode = PROT_MODE;
    }
    return( mode );

#else           //

    NTSTATUS    rc;
    BOOL        b;
    int         mode;
    ULONG       lpVdmTib;
    ULONG       IntelMSW;

    lpContext->ContextFlags = CONTEXT_FULL;
    rc = NtGetContextThread( hCurrentThread,
                             lpContext );
    if ( NT_ERROR(rc) ) {
        PRINTF( "bde.k: Could not get current threads context - status = %08lX\n", rc );
        return( -1 );
    }
    /*
    ** Get the 16-bit registers from the context
    */

    if ( lpContext->EFlags & V86_BITS ) {
        /*
        ** V86 Mode
        */
        mode = V86_MODE;
    } else {
        if ( ((WORD)(lpContext->SegCs & RPL_MASK)) != KGDT_R3_CODE ) {
            mode = PROT_MODE;
        } else {
            /*
            ** We are in flat 32-bit address space!
            */
            lpVdmTib = GetCurrentVdmTib();
            if ( !lpVdmTib ) {
                PRINTF("Could not find the symbol 'VdmTib'\n");
                return( -1 );
            }

            b = READMEM((LPVOID)(lpVdmTib+FIELD_OFFSET(VDM_TIB,VdmContext)),
                        lpContext, sizeof(VDMCONTEXT));

            if ( !b ) {
                PRINTF("Could not read IntelRegisters context out of process\n");
                return( -1 );
            }

            b = READMEM((LPVOID)(lpVdmTib+FIELD_OFFSET(VDM_TIB,IntelMSW)),
                        &IntelMSW, sizeof(IntelMSW));

            if ( !b ) {
                PRINTF("Could not read IntelMSW out of process\n");
                return( -1 );
            }

            if ( IntelMSW & MSW_PE ) {
                mode = PROT_MODE;
            } else {
                mode = V86_MODE;
            }
        }
    }

    return( mode );
#endif
}

ULONG
GetIntelBase(
    VOID
    )
{
#ifndef i386
    ULONG IntelBase;
    BOOL        b;

    IntelBase = (ULONG)EXPRESSION("ntvdm!Start_of_M_area");
    if ( IntelBase ) {

        b = READMEM((LPVOID) IntelBase, &IntelBase, sizeof(ULONG));

        if ( !b ) {
            PRINTF("Could not read symbol 'ntvdm!Start_of_M_area\n");
            return(0);
        }

    } else {
        PRINTF("Could not find the symbol 'ntvdm!Start_of_M_area'\n");
    }

    return(IntelBase);
#else
    return(0);
#endif
}

DWORD read_dword(
    ULONG   lpAddress,
    BOOL    bSafe
) {
    BOOL    b;
    DWORD   dword;

    b = READMEM((LPVOID)lpAddress, &dword, sizeof(dword));

    if ( !b ) {
        if ( !bSafe ) {
            PRINTF("Failure reading dword at memory location %08lX\n", lpAddress );
        }
        return( 0 );
    }
    return( dword );
}

WORD read_word(
    ULONG   lpAddress,
    BOOL    bSafe
) {
    BOOL    b;
    WORD    word;

    b = READMEM((LPVOID)lpAddress, &word, sizeof(word));

    if ( !b ) {
        if ( !bSafe ) {
            PRINTF("Failure reading word at memory location %08lX\n", lpAddress );
        }
        return( 0 );
    }
    return( word );
}

BYTE read_byte(
    ULONG   lpAddress,
    BOOL    bSafe
) {
    BOOL    b;
    BYTE    byte;

    b = READMEM((LPVOID)lpAddress, &byte, sizeof(byte));

    if ( !b ) {
        if ( !bSafe ) {
            PRINTF("Failure reading byte at memory location %08lX\n", lpAddress );
        }
        return( 0 );
    }
    return( byte );
}

BOOL read_gnode32(
    ULONG   lpAddress,
    PGNODE32  p,
    BOOL    bSafe
) {
    BOOL    b;

    b = READMEM((LPVOID)lpAddress, p, sizeof(*p));

    if ( !b ) {
        if ( !bSafe ) {
            PRINTF("Failure reading word at memory location %08lX\n", lpAddress );
        }
        return( 0 );
    }
    return( TRUE );
}


BOOL GetDescriptorData(
    WORD selector,
    LPVDMLDT_ENTRY pdte
    )
{

//
// Using GetThreadSelectorEntry would be nice if it just wasn't so slow.
// So, we use our LDT, just like on risc, which should be good enough.
//#ifdef i386
#if 0
    LDT_ENTRY  dte;
    if (!GetThreadSelectorEntry( hCurrentThread,
                                    selector,
                                   &dte)) {
        return( FALSE );
    }
    pdte->HighWord = dte.HighWord;
    pdte->BaseLow = dte.BaseLow;
    pdte->LimitLow = dte.LimitLow;
    return (TRUE);
#endif

    NTSTATUS                Status;
    selector &= ~(SELECTOR_LDT | SELECTOR_RPL);

    //
    // Get address of Ldt
    //

    if (!LdtAddress) {
        //
        // GetExpression is VERY SLOW under ntsd now. Who knows what the
        // debugger guys are up to. So just try to cache the address value
        // since it only changes twice (both during boot).
        //
        LdtAddress = (PVOID)EXPRESSION("ntvdm!Ldt");

        Status = READMEM(LdtAddress, &LdtAddress, sizeof(ULONG));
        if (!Status) {
            LdtAddress = NULL;
            return FALSE;
        }
    }

    Status = READMEM((PVOID)((ULONG)LdtAddress + selector),
                      pdte, sizeof(VDMLDT_ENTRY));

    // Now do a special hack for the period of time during dpmi
    // init where the LDT moves. This would all be unecessary if
    // we just were to get the ldt base from VDMDBG, which knows
    // everything.
    if (((ULONG)LdtAddress)-GetIntelBase() < 0x100000) {
        LdtAddress = NULL;  // forget the value again
    }

    return Status;
}

BOOL
ReadMemExpression(
    LPSTR expr,
    LPVOID buffer,
    ULONG len
    )
{
    PVOID pMem;

    pMem = (PVOID)(*GetExpression)(expr);
    if (!pMem) {
        PRINTF("Can't find symbol %s\n", expr);
        return FALSE;
    }

    if (!READMEM(pMem, buffer, len)) {
        PRINTF("Error reading memory\n");
        return FALSE;
    }

    return TRUE;
}


ULONG GetInfoFromSelector(
    WORD                    selector,
    int                     mode,
    SELECTORINFO            *si
) {

    ULONG                   base;
    ULONG                   type;
    VDMLDT_ENTRY            dte;

    switch( mode ) {
    case V86_MODE:
        base = (ULONG)selector << 4;
        if ( si ) {
            si->Limit = 0xFFFFL;
            si->Base = (ULONG)selector << 4;
            si->bCode = FALSE;
            si->bBig = FALSE;
            si->bExpandDown = FALSE;
            si->bWrite = TRUE;
            si->bPresent = TRUE;
        }
        break;
    case PROT_MODE:

        if ( !GetDescriptorData(selector, &dte) ) {
            return( (ULONG)-1 );
        }

        base =   ((ULONG)dte.HighWord.Bytes.BaseHi << 24)
               + ((ULONG)dte.HighWord.Bytes.BaseMid << 16)
               + ((ULONG)dte.BaseLow);

        if ( si ) {
            si->Limit =  (ULONG)dte.LimitLow
                      + ((ULONG)dte.HighWord.Bits.LimitHi << 16);

            if ( dte.HighWord.Bits.Granularity ) {
                si->Limit <<= 12;
                si->Limit += 0xFFF;
            }
            si->Base = base;

            type = dte.HighWord.Bits.Type;

            si->bSystem = !(BOOL) (type & 0x10);

            if (!si->bSystem) {
                si->bCode = (BOOL) (type & 8);
            }
            si->bAccessed = (BOOL) (type & 1);
            si->bWrite =    (BOOL) (type & 2);
            if (si->bCode) {
                si->bWrite = !si->bWrite;

            }

            si->bExpandDown = FALSE;
            if (!si->bSystem && !si->bCode) {
                si->bExpandDown = (BOOL) (type & 4);
            }

            si->bPresent =  (BOOL) dte.HighWord.Bits.Pres;
            si->bBig =  (BOOL) dte.HighWord.Bits.Default_Big;

        }

        break;

    case FLAT_MODE:
        PRINTF("Unsupported determination of base address in flat mode\n");
        base = 0;
        break;
    }

    return( base );
}


BOOL
InVdmPrompt(
    VOID
    )

{
    ULONG pTmp;
    BOOL InVdmDebugger;
    BOOL bReturn = FALSE;


    if ((pTmp = (ULONG)EXPRESSION("ntvdmd!InVdmDebugger"))           &&
        (READMEM((LPVOID) pTmp, &InVdmDebugger, sizeof(BOOL))))  {
        bReturn = InVdmDebugger;
    }

    return bReturn;
}

//****************************************************************************
//
// Command line parsing routines
//
//****************************************************************************
BOOL
SkipToNextWhiteSpace(
    VOID
    )
{
    char ch;
    while ( (ch = *lpArgumentString) != '\0' ) {
        if ( ch == ' ' || ch == '\t' || ch == '\r' || ch == '\n' ) {
            return TRUE;
        }
        lpArgumentString++;
    }
    return FALSE;
}


BOOL
GetNextToken(
    VOID
    )
{
    char ch;

    while ( (ch = *lpArgumentString) != '\0' ) {
        if ( ch != ' ' && ch != '\t' && ch != '\r' && ch != '\n' ) {
            return TRUE;
        }
        lpArgumentString++;
    }
    return FALSE;
}

ULONG
EvaluateToken(
    VOID
    )
{
    char ch;
    LPSTR pTemp;
    ULONG value = 0;

    if (GetNextToken()) {
        pTemp = lpArgumentString;
        SkipToNextWhiteSpace();
        ch = *lpArgumentString;
        *lpArgumentString = 0;
        value = (ULONG) EXPRESSION( pTemp );
        *lpArgumentString = ch;
    }
    return (value);
}

BOOL
IsTokenHex(
    VOID
    )
{

    UCHAR ch;
    LPSTR pTemp;
    BOOL result = TRUE;

    if (GetNextToken()) {
        pTemp = lpArgumentString;
        SkipToNextWhiteSpace();
        lpArgumentString--;

        while(lpArgumentString >= pTemp) {

            ch = *lpArgumentString--;

            if (ch < '0') {
                result = FALSE;
                break;
            }

            if ((ch > '9') && (ch < 'A')) {
                result = FALSE;
                break;
            }

            if ((ch > 'F') && (ch < 'a')) {
                result = FALSE;
                break;
            }

            if (ch > 'f') {
                result = FALSE;
                break;
            }

        }

        lpArgumentString = pTemp;

    }
    return (result);

}


BOOL
RegisterToAsciiValue(
    LPSTR *pszValue,
    LPSTR *pszReg
    )
{
    LPSTR szReg = *pszReg;
    LPSTR szValue = *pszValue;

    if (!_strnicmp(szReg, "ax", 2) && !isalpha(szReg[2])) {
        _ultoa((ULONG)LOWORD(ThreadContext.Eax), szValue, 16);
        *pszReg += 2;
    } else if (!_strnicmp(szReg, "bx", 2) && !isalpha(szReg[2])) {
        _ultoa((ULONG)LOWORD(ThreadContext.Ebx), szValue, 16);
        *pszReg += 2;
    } else if (!_strnicmp(szReg, "cx", 2) && !isalpha(szReg[2])) {
        _ultoa((ULONG)LOWORD(ThreadContext.Ecx), szValue, 16);
        *pszReg += 2;
    } else if (!_strnicmp(szReg, "dx", 2) && !isalpha(szReg[2])) {
        _ultoa((ULONG)LOWORD(ThreadContext.Edx), szValue, 16);
        *pszReg += 2;
    } else if (!_strnicmp(szReg, "si", 2) && !isalpha(szReg[2])) {
        _ultoa((ULONG)LOWORD(ThreadContext.Esi), szValue, 16);
        *pszReg += 2;
    } else if (!_strnicmp(szReg, "di", 2) && !isalpha(szReg[2])) {
        _ultoa((ULONG)LOWORD(ThreadContext.Edi), szValue, 16);
        *pszReg += 2;
    } else if (!_strnicmp(szReg, "sp", 2) && !isalpha(szReg[2])) {
        _ultoa((ULONG)LOWORD(ThreadContext.Esp), szValue, 16);
        *pszReg += 2;
    } else if (!_strnicmp(szReg, "bp", 2) && !isalpha(szReg[2])) {
        _ultoa((ULONG)LOWORD(ThreadContext.Ebp), szValue, 16);
        *pszReg += 2;
    } else if (!_strnicmp(szReg, "ip", 2) && !isalpha(szReg[2])) {
        _ultoa((ULONG)LOWORD(ThreadContext.Eip), szValue, 16);
        *pszReg += 2;

    } else if (!_strnicmp(szReg, "eax", 3) && !isalpha(szReg[3])) {
        _ultoa(ThreadContext.Eax, szValue, 16);
        *pszReg += 3;
    } else if (!_strnicmp(szReg, "ebx", 3) && !isalpha(szReg[3])) {
        _ultoa(ThreadContext.Ebx, szValue, 16);
        *pszReg += 3;
    } else if (!_strnicmp(szReg, "ecx", 3) && !isalpha(szReg[3])) {
        _ultoa(ThreadContext.Ecx, szValue, 16);
        *pszReg += 3;
    } else if (!_strnicmp(szReg, "edx", 3) && !isalpha(szReg[3])) {
        _ultoa(ThreadContext.Edx, szValue, 16);
        *pszReg += 3;
    } else if (!_strnicmp(szReg, "esi", 3) && !isalpha(szReg[3])) {
        _ultoa(ThreadContext.Esi, szValue, 16);
        *pszReg += 3;
    } else if (!_strnicmp(szReg, "edi", 3) && !isalpha(szReg[3])) {
        _ultoa(ThreadContext.Edi, szValue, 16);
        *pszReg += 3;
    } else if (!_strnicmp(szReg, "esp", 3) && !isalpha(szReg[3])) {
        _ultoa(ThreadContext.Esp, szValue, 16);
        *pszReg += 3;
    } else if (!_strnicmp(szReg, "ebp", 3) && !isalpha(szReg[3])) {
        _ultoa(ThreadContext.Ebp, szValue, 16);
        *pszReg += 3;
    } else if (!_strnicmp(szReg, "eip", 3) && !isalpha(szReg[3])) {
        _ultoa(ThreadContext.Eip, szValue, 16);
        *pszReg += 3;

    } else if (!_strnicmp(szReg, "cs", 2) && !isalpha(szReg[2])) {
        _ultoa((ULONG)ThreadContext.SegCs, szValue, 16);
        *pszReg += 2;
    } else if (!_strnicmp(szReg, "ds", 2) && !isalpha(szReg[2])) {
        _ultoa((ULONG)ThreadContext.SegDs, szValue, 16);
        *pszReg += 2;
    } else if (!_strnicmp(szReg, "es", 2) && !isalpha(szReg[2])) {
        _ultoa((ULONG)ThreadContext.SegEs, szValue, 16);
        *pszReg += 2;
    } else if (!_strnicmp(szReg, "fs", 2) && !isalpha(szReg[2])) {
        _ultoa((ULONG)ThreadContext.SegFs, szValue, 16);
        *pszReg += 2;
    } else if (!_strnicmp(szReg, "gs", 2) && !isalpha(szReg[2])) {
        _ultoa((ULONG)ThreadContext.SegGs, szValue, 16);
        *pszReg += 2;
    } else if (!_strnicmp(szReg, "ss", 2) && !isalpha(szReg[2])) {
        _ultoa((ULONG)ThreadContext.SegSs, szValue, 16);
        *pszReg += 2;
    } else {
        return FALSE;
    }

//    PRINTF("value = %s\n", szValue);
    while (*szValue) {
        szValue++;
    }
    *pszValue = szValue;
    return TRUE;
}

VOID
ParseForIntelRegisters(
    LPSTR szTarg,
    LPSTR szSrc
    )
{

    while (*szSrc) {
        if (!isalpha(*szSrc)) {
            if (!isdigit(*szSrc)) {
                *szTarg++ = *szSrc++;
                continue;
            }

            while (isalpha(*szSrc) || isdigit(*szSrc)) {
                *szTarg++ = *szSrc++;
            }
            continue;
        }

        if (!RegisterToAsciiValue(&szTarg, &szSrc)) {
            while (isalpha(*szSrc) || isdigit(*szSrc)) {
                *szTarg++ = *szSrc++;
            }
        }

    }
    *szTarg = 0;
}

BOOL
ParseIntelAddress(
    int *pMode,
    WORD *pSelector,
    PULONG pOffset
    )

{
    char sel_text[128], off_text[128];
    char expr_text[256];
    char *colon;
    char *mode_prefix;
    WORD segment;
    char filename[9];

    colon = strchr( lpArgumentString, ':' );
    if ( colon == NULL ) {
        LPSTR pSymbol = lpArgumentString;
        BOOL bResult;
        char chTemp;

        SkipToNextWhiteSpace();
        chTemp = *lpArgumentString;
        *lpArgumentString = 0;

        bResult = FindAddress( pSymbol,
                              filename,
                              &segment,
                              pSelector,
                              pOffset,
                              pMode,
                              FALSE);

        *lpArgumentString = chTemp;

        if (bResult) {
            if (*pMode == NOT_LOADED) {
                PRINTF("Could not determine base of '%s'\n", pSymbol);
                return FALSE;
            } else {
                return TRUE;
            }

        } else {

            PRINTF("Could not find symbol: %s\n", pSymbol);
            return FALSE;
        }
    }

    *pMode = GetContext( &ThreadContext );

    mode_prefix = strchr( lpArgumentString, '&' );
    if ( mode_prefix == NULL ) {

        mode_prefix = strchr( lpArgumentString, '#' );
        if ( mode_prefix != NULL ) {

            if ( mode_prefix != lpArgumentString ) {
                PRINTF("Address must have '&' symbol as the first character\n");
                return FALSE;
            }

            *pMode = PROT_MODE;
            lpArgumentString = mode_prefix+1;
        }

    } else {

        if ( mode_prefix != lpArgumentString ) {
            PRINTF("Address must have '#' symbol as the first character\n");
            return FALSE;
        }
        *pMode = V86_MODE;
        lpArgumentString = mode_prefix+1;

    }

    *colon = '\0';
    strcpy( sel_text, lpArgumentString );
    *colon = ':';
    strcpy( off_text, colon+1 );

    ParseForIntelRegisters(expr_text, sel_text);
    *pSelector = (WORD) EXPRESSION( expr_text );
    ParseForIntelRegisters(expr_text, off_text);
    *pOffset   = (ULONG) EXPRESSION( expr_text );

    SkipToNextWhiteSpace();

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\vdmexts\vdmexts.h ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    vdmexts.h

Abstract:

    This file header defines most of the stuff used in VDMEXTS

Revision History:

    Neil Sandlin (NeilSa) 15-Jan-1996 Merged with vdmexts

--*/


//
// Pointers to WINDBG api
//

extern PWINDBG_OUTPUT_ROUTINE Print;
extern PWINDBG_GET_EXPRESSION GetExpression;
extern PWINDBG_GET_SYMBOL GetSymbol;
extern PWINDBG_DISASM Disassemble;
extern PWINDBG_CHECK_CONTROL_C CheckCtrlC;

extern PWINDBG_READ_PROCESS_MEMORY_ROUTINE  ReadMem;
extern PWINDBG_WRITE_PROCESS_MEMORY_ROUTINE WriteMem;

extern PWINDBG_GET_THREAD_CONTEXT_ROUTINE     ExtGetThreadContext;
extern PWINDBG_SET_THREAD_CONTEXT_ROUTINE     ExtSetThreadContext;
extern PWINDBG_IOCTL_ROUTINE                  ExtIoctl;
extern PWINDBG_STACKTRACE_ROUTINE             ExtStackTrace;

extern HANDLE hCurrentProcess;
extern HANDLE hCurrentThread;
extern LPSTR lpArgumentString;

#define PRINTF          (* Print)
#define EXPRESSION      (* GetExpression)

#define ReadDword(x)     read_dword((ULONG)x, FALSE)
#define ReadWord(x)      read_word ((ULONG)x, FALSE)
#define ReadByte(x)      read_byte ((ULONG)x, FALSE)
#define ReadDwordSafe(x) read_dword((ULONG)x, TRUE)
#define ReadWordSafe(x)  read_word ((ULONG)x, TRUE)
#define ReadByteSafe(x)  read_byte ((ULONG)x, TRUE)
#define ReadGNode32(x,p) read_gnode32((ULONG)x,p,FALSE)
#define ReadGNode32Safe(x,p) read_gnode32((ULONG)x,p,TRUE)

/****** macros common to all versions *******/
#define CMD_ARGLIST  HANDLE CurrentProcess,                 \
                     HANDLE CurrentThread,                  \
                     DWORD CurrentPc,                       \
                     PWINDBG_EXTENSION_APIS pXApis,         \
                     LPSTR ArgumentString

#define CMD_INIT() \
    UNREFERENCED_PARAMETER(CurrentPc);                      \
    hCurrentProcess = CurrentProcess;                       \
    hCurrentThread = CurrentThread;                         \
    lpArgumentString = ArgumentString;                      \
                                                            \
    Print         = pXApis->lpOutputRoutine;                \
    GetSymbol     = pXApis->lpGetSymbolRoutine;             \
    GetExpression = pXApis->lpGetExpressionRoutine;         \
    CheckCtrlC    = pXApis->lpCheckControlCRoutine;         \
                                                            \
    ReadMem       = pXApis->lpReadProcessMemoryRoutine;     \
    WriteMem      = pXApis->lpWriteProcessMemoryRoutine;    \
    ExtGetThreadContext       = pXApis->lpGetThreadContextRoutine;     \
    ExtSetThreadContext       = pXApis->lpSetThreadContextRoutine;     \
    ExtIoctl                  = pXApis->lpIoctlRoutine;                \
    ExtStackTrace             = pXApis->lpStackTraceRoutine;           \


#define READMEM( addr, buff, size ) ReadProcessMem(addr, buff, size)
#define WRITEMEM( addr, buff, size ) WriteProcessMem(addr, buff, size)

#define READMEM_XRET(buff, addr)\
try {\
    READMEM( (LPVOID)(addr), (LPVOID)&(buff), sizeof(buff));\
} except (EXCEPTION_EXECUTE_HANDLER) {\
    Print("ReadProcessMemory Failed !\n");\
    return;\
}


#define READMEM_XRETV(buff, addr, ret)\
try {\
    READMEM((LPVOID) (addr), (LPVOID)&(buff), sizeof(buff));\
} except (EXCEPTION_EXECUTE_HANDLER) {\
    Print("ReadProcessMemory Failed !\n");\
    return ret;\
}


#define WRITEMEM_XRET(addr, buff)\
try {\
    WRITEMEM((LPVOID)(addr), (LPVOID)&(buff), sizeof(buff));\
} except (EXCEPTION_EXECUTE_HANDLER) {\
    Print("WriteProcessMemory Failed !\n");\
    return;\
}

#define WRITEMEM_N_XRET(addr, buff, n)\
try {\
    WRITEMEM((LPVOID)(addr), (LPVOID)(buff), n);\
} except (EXCEPTION_EXECUTE_HANDLER) {\
    Print("WriteProcessMemory Failed !\n");\
    return;\
}


#define GETEXPRVALUE(dst, expr, typ) \
{\
   PVOID lpA = (PVOID)GetExpression(expr);\
   READMEM_XRET(dst, lpA);\
}

#define GETEXPRADDR(dst, expr) \
{\
   dst = (PVOID)GetExpression(expr);\
}


#define ASSERT_WOW_PRESENT {                                        \
    if (!EXPRESSION("wow32!gptdTaskHead")) {                        \
        PRINTF("Could not resolve needed symbols for WOW32\n");     \
        return;                                                     \
    }                                                               \
}

#define ASSERT_CHECKED_WOW_PRESENT {                                \
    if (!EXPRESSION("wow32!iCircBuffer")) {                         \
        PRINTF("Could not resolve needed symbols for checked WOW32\n");    \
        return;                                                     \
    }                                                               \
}

#define BEFORE      0
#define AFTER       1

#define RPL_MASK    0x78
#define V86_BITS    0x20000

#define SELECTOR_LDT            0x04
#define SELECTOR_RPL            0x03

#define V86_MODE    0
#define PROT_MODE   1
#define FLAT_MODE   2
#define NOT_LOADED  3

#define CALL_NEAR_RELATIVE   0xE8
#define CALL_NEAR_INDIRECT   0xFF
#define INDIRECT_NEAR_TYPE   0x02
#define CALL_FAR_ABSOLUTE    0x9A
#define CALL_FAR_INDIRECT    0xFF
#define INDIRECT_FAR_TYPE    0x03
#define PUSH_CS              0x0E
#define ADD_SP               0xC483

#define TYPE_BITS            0x38
#define TYPE0                0x00
#define TYPE1                0x08
#define TYPE2                0x10
#define TYPE3                0x18
#define TYPE4                0x20
#define TYPE5                0x28
#define TYPE6                0x30
#define TYPE7                0x38

#define MOD_BITS             0xC0
#define MOD0                 0x00
#define MOD1                 0x40
#define MOD2                 0x80
#define MOD3                 0xC0

#define RM_BITS              0x07
#define RM0                  0x00
#define RM1                  0x01
#define RM2                  0x02
#define RM3                  0x03
#define RM4                  0x04
#define RM5                  0x05
#define RM6                  0x06
#define RM7                  0x07

#define FLAG_OVERFLOW       0x0800
#define FLAG_DIRECTION      0x0400
#define FLAG_INTERRUPT      0x0200
#define FLAG_SIGN           0x0080
#define FLAG_ZERO           0x0040
#define FLAG_AUXILLIARY     0x0010
#define FLAG_PARITY         0x0004
#define FLAG_CARRY          0x0001


typedef struct _SELECTORINFO {
    DWORD Base;
    DWORD Limit;
    BOOL bCode;
    BOOL bSystem;
    BOOL bPresent;
    BOOL bWrite;
    BOOL bAccessed;
    BOOL bBig;
    BOOL bExpandDown;
} SELECTORINFO;

typedef struct _segentry {
    struct _segentry *Next;
    int     type;
    char    szExePath[MAX_PATH16];
    char    szModule[MAX_MODULE_NAME];
    WORD    selector;
    WORD    segment;
    DWORD   length;
} SEGENTRY, *PSEGENTRY;

#define SEGTYPE_V86         1
#define SEGTYPE_PROT        2

#pragma  pack(1)

typedef struct _GNODE32 {     // GlobalArena
   DWORD pga_next      ;    // next arena entry (last points to self)
   DWORD pga_prev      ;    // previous arena entry (first points to self)
   DWORD pga_address   ;    // 32 bit linear address of memory
   DWORD pga_size      ;    // 32 bit size in bytes
   WORD  pga_handle    ;    // back link to handle table entry
   WORD  pga_owner     ;    // Owner field (current task)
   BYTE  pga_count     ;    // lock count for movable segments
   BYTE  pga_pglock    ;    // # times page locked
   BYTE  pga_flags     ;    // 1 word available for flags
   BYTE  pga_selcount  ;    // Number of selectors allocated
   DWORD pga_lruprev   ;    // Previous entry in lru chain
   DWORD pga_lrunext   ;    // Next entry in lru chain
} GNODE32;
typedef GNODE32 UNALIGNED *PGNODE32;

typedef struct _GHI32 {
    WORD  hi_check     ;    // arena check word (non-zero enables heap checking)
    WORD  hi_freeze    ;    // arena frozen word (non-zero prevents compaction)
    WORD  hi_count     ;    // #entries in arena
    WORD  hi_first     ;    // first arena entry (sentinel, always busy)
    WORD  hi_res1      ;    // reserved
    WORD  hi_last      ;    // last arena entry (sentinel, always busy)
    WORD  hi_res2      ;    // reserved
    BYTE  hi_ncompact  ;    // #compactions done so far (max of 3)
    BYTE  hi_dislevel  ;    // current discard level
    DWORD hi_distotal  ;    // total amount discarded so far
    WORD  hi_htable    ;    // head of handle table list
    WORD  hi_hfree     ;    // head of free handle table list
    WORD  hi_hdelta    ;    // #handles to allocate each time
    WORD  hi_hexpand   ;    // address of near procedure to expand handles for this arena
    WORD  hi_pstats    ;    // address of statistics table or zero
} GHI32;
typedef GHI32 UNALIGNED *PGHI32;

typedef struct _HEAPENTRY {
    GNODE32 gnode;
    DWORD CurrentEntry;
    DWORD NextEntry;
    WORD Selector;
    int  SegmentNumber;
    char OwnerName[9];
    char FileName[9];
    char ModuleArg[9];
} HEAPENTRY;

typedef struct _NEHEADER {
    WORD ne_magic       ;
    BYTE ne_ver         ;
    BYTE ne_rev         ;
    WORD ne_enttab      ;
    WORD ne_cbenttab    ;
    DWORD ne_crc        ;
    WORD ne_flags       ;
    WORD ne_autodata    ;
    WORD ne_heap        ;
    WORD ne_stack       ;
    DWORD ne_csip       ;
    DWORD ne_sssp       ;
    WORD ne_cseg        ;
    WORD ne_cmod        ;
    WORD ne_cbnrestab   ;
    WORD ne_segtab      ;
    WORD ne_rsrctab     ;
    WORD ne_restab      ;
    WORD ne_modtab      ;
    WORD ne_imptab      ;
    DWORD ne_nrestab    ;
    WORD ne_cmovent     ;
    WORD ne_align       ;
    WORD ne_cres        ;
    BYTE ne_exetyp      ;
    BYTE ne_flagsothers ;
    WORD ne_pretthunks  ;
    WORD ne_psegrefbytes;
    WORD ne_swaparea    ;
    WORD ne_expver      ;
} NEHEADER;
typedef NEHEADER UNALIGNED *PNEHEADER;

#pragma  pack()


#ifndef i386

//
// Structures in 486 cpu for obtaining registers (FROM NT_CPU.C)
//

typedef struct NT_CPU_REG {
    ULONG *nano_reg;         /* where the nano CPU keeps the register */
    ULONG *reg;              /* where the light compiler keeps the reg */
    ULONG *saved_reg;        /* where currently unused bits are kept */
    ULONG universe_8bit_mask;/* is register in 8-bit form? */
    ULONG universe_16bit_mask;/* is register in 16-bit form? */
} NT_CPU_REG;

typedef struct NT_CPU_INFO {
    /* Variables for deciding what mode we're in */
    BOOL *in_nano_cpu;      /* is the Nano CPU executing? */
    ULONG *universe;         /* the mode that the CPU is in */

    /* General purpose register pointers */
    NT_CPU_REG eax, ebx, ecx, edx, esi, edi, ebp;

    /* Variables for getting SP or ESP. */
    BOOL *stack_is_big;     /* is the stack 32-bit? */
    ULONG *nano_esp;         /* where the Nano CPU keeps ESP */
    UCHAR **host_sp;          /* ptr to variable holding stack pointer as a
                               host address */
    UCHAR **ss_base;          /* ptr to variables holding base of SS as a
                               host address */
    ULONG *esp_sanctuary;    /* top 16 bits of ESP if we're now using SP */

    ULONG *eip;

    /* Segment registers. */
    USHORT *cs, *ds, *es, *fs, *gs, *ss;

    ULONG *flags;

    /* CR0, mainly to let us figure out if we're in real or protect mode */
    ULONG *cr0;
} NT_CPU_INFO;


#endif // i386



BOOL
WINAPI
ReadProcessMem(
    LPVOID lpBaseAddress,
    LPVOID lpBuffer,
    DWORD nSize
    );

BOOL
WINAPI
WriteProcessMem(
    LPVOID lpBaseAddress,
    LPVOID lpBuffer,
    DWORD nSize
    );

BOOL
ReadMemExpression(
    LPSTR expr,
    LPVOID buffer,
    ULONG len
    );

BOOL
CheckGlobalHeap(
    BOOL bVerbose
    );

int GetContext(
    VDMCONTEXT* lpContext
);

ULONG GetInfoFromSelector(
    WORD                    selector,
    int                     mode,
    SELECTORINFO            *si
);

BOOL
FindHeapEntry(
    HEAPENTRY *he,
    UINT FindMethod,
    BOOL bVerbose
    );

#define FHE_FIND_ANY 0
#define FHE_FIND_SEL_ONLY 1
#define FHE_FIND_MOD_ONLY 2

#define FHE_FIND_QUIET FALSE
#define FHE_FIND_VERBOSE TRUE

BOOL
FindAddress(
    LPSTR       sym_text,
    LPSTR       filename,
    WORD        *psegment,
    WORD        *pselector,
    LONG        *poffset,
    int         *pmode,
    BOOL        bDumpAll
    );

BOOL FindSymbol(
    WORD        selector,
    LONG        offset,
    LPSTR       sym_text,
    LONG        *dist,
    int         direction,
    int         mode
);

int
unassemble_one(
    BYTE *pInstrStart,
    BOOL bDefaultBig,
    WORD wInstrSeg,
    DWORD dwInstrOff,
    char *pchOutput,
    char *pchExtra,
    VDMCONTEXT *pThreadContext,
    int mode
    );


ULONG GetIntelBase(
    VOID
);

DWORD read_dword(
    ULONG   lpAddress,
    BOOL    bSafe
);

WORD read_word(
    ULONG   lpAddress,
    BOOL    bSafe
);

BYTE read_byte(
    ULONG   lpAddress,
    BOOL    bSafe
);

BOOL read_gnode32(
    ULONG   lpAddress,
    PGNODE32  p,
    BOOL    bSafe
);

BOOL GetNextToken(
    VOID
    );

ULONG EvaluateToken(
    VOID
    );

VOID helpAPIProfDmp(
    VOID
    );

VOID helpMsgProfDmp(
    VOID
    );

BOOL
InVdmPrompt(
    VOID
    );

BOOL ParseIntelAddress(
    int *pMode,
    WORD *pSelector,
    PULONG pOffset
    );

VOID
ParseModuleName(
    LPSTR szName,
    LPSTR szPath
    );

VOID
EnableDebuggerBreakpoints(
    VOID
    );

BOOL
IsVdmBreakPoint(
    USHORT selector,
    ULONG offset,
    BOOL bProt,
    PULONG pBpNum,
    PUCHAR pBpData
    );

BOOL
LoadBreakPointCache(
    VOID
    );

BOOL
SkipToNextWhiteSpace(
    VOID
    );

BOOL
IsTokenHex(
    VOID
    );

PSEGENTRY
GetSegtablePointer(
    VOID
    );

VOID Drp (VOID);
VOID Erp (VOID);
VOID EventInfop (VOID);
VOID ProfDumpp (VOID);
VOID ProfIntp (VOID);
VOID ProfStartp (VOID);
VOID ProfStopp (VOID);
VOID VdmTibp (VOID);
VOID Fpup (VOID);
BOOL DumpEnvironment(WORD segEnv, int mode);
ULONG GetCurrentVdmTib(VOID);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\vdmexts\wow.c ===
/******************************Module*Header*******************************\
* Module Name: wow.c
*
* This file is for debugging tools and extensions.
*
* Created: 24-Jan-1992
* Author: John Colleran
*
* History:
* Feb 17 92 Matt Felton (mattfe) lots of additional exentions for filtering
* Jul 13 92 (v-cjones) Added API & MSG profiling debugger extensions, fixed
*                      other extensions to handle segment motion correctly,
*                      & cleaned up the file in general
* Jan 3 96 Neil Sandlin (neilsa) integrated this routine into vdmexts
*
* Copyright (c) 1992 Microsoft Corporation
\**************************************************************************/

#include "precomp.h"
#pragma hdrstop
#include <tdb16.h>
#include <wmdisp32.h>
#include <wcuricon.h>
#include <wucomm.h>
#include <doswow.h>


//
// get the compatibility flag values & string names
//
typedef struct _tagWOWCFDATA {
    LPSZ  lpszCFName;
    DWORD dwVal;
} WOWCFDATA;



// allows us to grab the string tables only from mvdm\inc\wowcmpat.h
#define _VDMEXTS_CFLAGS 1

// exposes the compatibility flag strings & values in wowcmpat.h
#define _VDMEXTS_CF 1
WOWCFDATA CFData[] = {
#include "wowcmpat.h"
         {"", 0x00000000}
};
#undef _VDMEXTS_CF

// exposes the EXTENDED compatibility flag strings & values in wowcmpat.h
#define _VDMEXTS_CFEX 1
WOWCFDATA CFDataEx[] = {
#include "wowcmpat.h"
         {"", 0x00000000}
};
#undef _VDMEXTS_CFEX

// exposes the OLD Win3.x compatibility flag strings & values in wowcmpat.h
#define _VDMEXTS_CF31 1
WOWCFDATA CFData31[] = {
#include "wowcmpat.h"
         {"", 0x00000000}
};
#undef _VDMEXTS_CF31

// exposes the IME compatibility flag strings & values in wowcmpat.h
#if FE_SB
#define _VDMEXTS_CF_IME 1
WOWCFDATA CFDataIME[] = {
#include "wowcmpat.h"
         {"", 0x00000000}
};
#endif // FE_SB
#undef _VDMEXTS_CF_IME

#undef _VDMEXTS_CFLAGS





#define MALLOC(cb) HeapAlloc(GetProcessHeap(), HEAP_GENERATE_EXCEPTIONS, cb)
#define FREE(addr) HeapFree(GetProcessHeap(), 0, addr)


//
// Local function prototypes
//

INT  WDahtoi(LPSZ lpsz);


INT WDParseArgStr(LPSZ lpszArgStr, CHAR **argv, INT iMax) {
/*
 * Parse a string looking for SPACE, TAB, & COMMA as delimiters
 *  INPUT:
 *   lpszArgStr - ptr to input arg string
 *   iMax       - maximum number of substrings to parse
 *  OUTPUT:
 *   argv       - ptrs to strings
 *
 *  RETURN: # of vectors in argv
 *  NOTE: substrings are converted to uppercase
 */
    INT   nArgs;
    BOOL  bStrStart;

    nArgs = 0;
    bStrStart = 1;
    while( *lpszArgStr ) {
        if( (*lpszArgStr == ' ') || (*lpszArgStr == '\t') || (*lpszArgStr == ',') ) {
            *lpszArgStr = '\0';
            bStrStart = 1;
        }
        else {
            if( bStrStart ) {
                if( nArgs >= iMax ) {
                    break;
                }
                argv[nArgs++] = lpszArgStr;
                bStrStart = 0;
            }
            *lpszArgStr = (CHAR)toupper(*lpszArgStr);
        }
        lpszArgStr++;
    }
    return(nArgs);
}




VOID
dwp(
    CMD_ARGLIST
    )
{
    PWOWPORT pwp;
    WOWPORT wp;

    CMD_INIT();
    ASSERT_WOW_PRESENT;


    while (' ' == lpArgumentString[0]) {
        lpArgumentString++;
    }

    pwp = (PWOWPORT) WDahtoi(lpArgumentString);

    if (NULL == pwp) {
        PRINTF("Can't read WOWPORT structure!\n\n");
        return;
    }

    PRINTF("Dump of WOWPORT structure at 0x%x:\n\n", (unsigned)pwp);
    
    
    try {

        READMEM_XRET(wp, pwp);

    } except (EXCEPTION_ACCESS_VIOLATION == GetExceptionCode()
              ? EXCEPTION_EXECUTE_HANDLER : EXCEPTION_CONTINUE_SEARCH) {

        PRINTF("Access violation reading WOWPORT structure!\n\n");
        return;
    }

    PRINTF("idComDev       0x%x\n", (unsigned)wp.idComDev);
    PRINTF("h32            0x%x\n", (unsigned)wp.h32);
    PRINTF("hREvent        0x%x\n", (unsigned)wp.hREvent);
    PRINTF("csWrite        OwningThread 0x%x RecursionCount 0x%x\n",
           (unsigned)wp.csWrite.OwningThread, (unsigned)wp.csWrite.RecursionCount);
    PRINTF("pchWriteHead   0x%x\n", (unsigned)wp.pchWriteHead);
    PRINTF("pchWriteTail   0x%x\n", (unsigned)wp.pchWriteTail);
    PRINTF("cbWriteFree    0x%x\n", (unsigned)wp.cbWriteFree);
    PRINTF("cbWritePending 0x%x\n", (unsigned)wp.cbWriteFree);
    PRINTF("pchWriteBuf    0x%x\n", (unsigned)wp.pchWriteBuf);
    PRINTF("cbWriteBuf     0x%x\n", (unsigned)wp.cbWriteBuf);
    PRINTF("hWriteThread   0x%x\n", (unsigned)wp.hWriteThread);
    PRINTF("hWriteEvent    0x%x\n", (unsigned)wp.hWriteEvent);
    PRINTF("OverLap hEvent 0x%x\n", (unsigned)wp.olWrite.hEvent);
    PRINTF("fWriteDone     %s\n", wp.fWriteDone ? "TRUE" : "FALSE");
    PRINTF("cbWritten      0x%x\n", (unsigned)wp.fWriteDone);
    PRINTF("dwThreadID     0x%x\n", (unsigned)wp.dwThreadID);
    PRINTF("dwErrCode      0x%x\n", (unsigned)wp.dwErrCode);
    PRINTF("COMSTAT addr:  0x%x\n", (unsigned)(((char *)&wp.cs - (char *)&wp) + (char *)pwp));
    PRINTF("fChEvt         0x%x\n", (unsigned)wp.fChEvt);
    PRINTF("pdcb16         0x%x\n", (unsigned)wp.pdcb16);
    PRINTF("fUnGet         %s\n", wp.fUnGet ? "TRUE" : "FALSE");
    PRINTF("cUnGet         0x%x (%c)\n", (unsigned)wp.cUnGet, wp.cUnGet);
    PRINTF("hMiThread      0x%x\n", (unsigned)wp.hMiThread);
    PRINTF("fClose         %s\n", wp.fClose ? "TRUE" : "FALSE");
    PRINTF("dwComDEB16     0x%x\n", (unsigned)wp.dwComDEB16);
    PRINTF("lpComDEB16     0x%x\n", (unsigned)wp.lpComDEB16);
    PRINTF("cbInQ          0x%x\n", (unsigned)wp.cbInQ);
    PRINTF("RLSDTimeout    0x%x\n", (unsigned)wp.RLSDTimeout);
    PRINTF("CTSTimeout     0x%x\n", (unsigned)wp.CTSTimeout);
    PRINTF("DSRTimeout     0x%x\n", (unsigned)wp.DSRTimeout);

    PRINTF("\n");

    return;
}


//
//  Dump Taskinfo;
//
//  If no argument, dump all wow tasks.
//  If 0, dump current WOW task
//  Else dump the specifies task {which is thread-id as shown by
//  ~ command under ntsd like 37.6b so thread-id is 6b)
//

void DumpTaskInfo (ptd,mode)
PTD  ptd;
int    mode;
{

    ULONG                   Base;
    TDB                     tdb;
    BOOL                    b;
    char ModName[9];
    int i;
    BOOL                    fTDBValid = TRUE;

    Base = GetInfoFromSelector( ptd->htask16, PROT_MODE, NULL );
    b = READMEM( (LPVOID) (Base+GetIntelBase()), &tdb, sizeof(tdb));

    if ( !b ) {
        fTDBValid = FALSE;
    }

    for (b=FALSE, i=0; i<8; i++) {
        if (!fTDBValid || !tdb.TDB_ModName[i]) {
            b = TRUE;
        }
        if (b) {
            ModName[i] = ' ';
        } else {
            ModName[i] = tdb.TDB_ModName[i];
        }
    }
    ModName[i] = 0;

    PRINTF("%.4x",ptd->dwThreadID);
    PRINTF(" %.4x:%.4x",HIWORD(ptd->vpStack),LOWORD(ptd->vpStack));
    PRINTF(" %.4x", ptd->htask16);
    PRINTF(" %.4x", ptd->hInst16);
    PRINTF(" %.4x", ptd->hMod16);
    PRINTF(" %8s",ModName);
    PRINTF(" %.8x",ptd->dwWOWCompatFlags);
    PRINTF(" %.8x",ptd->hThread);
    if (fTDBValid) {
        PRINTF(" %.8x",tdb.TDB_flags);
        PRINTF(" %.3x",tdb.TDB_ExpWinVer);
        PRINTF(" %.4x:%.4x\n",HIWORD(tdb.TDB_DTA),LOWORD(tdb.TDB_DTA));
    } else {
        PRINTF(" Failure reading TDB at %X\n", Base );
    }
}


void
DumpTask(
    void
    )
{
    VDMCONTEXT              ThreadContext;
    DWORD                   ThreadId;
    PTD                     ptd,ptdHead;
    TD                      td;
    int                     mode;
    BOOL                    b,fFound=FALSE;


    mode = GetContext( &ThreadContext );

    ThreadId = (DWORD)-1;  // Assume Dump All Tasks
    if (GetNextToken()) {
        ThreadId = (DWORD) EXPRESSION( lpArgumentString );
    }

    ptdHead = (PTD)EXPRESSION("wow32!gptdTaskHead");

    // get the pointer to first TD
    b = READMEM((LPVOID) (ptdHead), &ptd, sizeof(DWORD));

    if ( !b ) {
        PRINTF("Failure reading gptdTaskHead at %08lX\n", ptdHead );
        return;
    }

    PRINTF("Thrd   Stack   task inst hmod  Module  Compat   hThread  Tdbflags Ver    Dta\n");


    // enumerate td list to find the match(es)
    while (ptd) {
        b = READMEM((LPVOID) (ptd), &td, sizeof(TD));
        if ( !b ) {
            PRINTF("Failure reading TD At %08lX\n", ptd );
            return;
        }

        if (ThreadId == -1) {
            DumpTaskInfo (&td,mode);
            fFound = TRUE;
        }
        else {
            if (ThreadId == td.dwThreadID) {
                DumpTaskInfo (&td,mode);
                fFound = TRUE;
                break;
            }
        }
        ptd = td.ptdNext;
    }

    if (!fFound) {
        if (ThreadId == -1) {
            PRINTF("No WOW Task Found.\n");
        }
        else
            PRINTF("WOW Task With Thread Id = %02x Not Found.\n",ThreadId);
    }
    return;
}



VOID DumpTaskVerbose( )  // dump WOW32 task database entry
{

    TD        td;
    PTD       ptd;
    INT       i;
    PWOAINST  pWOA, pWOALast;
    PTDB      ptdb;
    BOOL      fAll = FALSE;
    BYTE      SavedByte;

    ptd = (PTD) WDahtoi(lpArgumentString);


    if (!ptd) {

        fAll = TRUE;
        GETEXPRVALUE(ptd, "wow32!gptdTaskHead", PTD);
        if (!ptd) {
            Print("Could not get wow32!gptdTaskHead");
            return;
        }
        Print("Dump WOW task list\n\n");

    } else if ((ULONG)ptd < 65536) {
        ULONG dwId = (ULONG) ptd;

        // Here, I'm making the assumption that if the argument is a value
        // that is less than 64k, then it can't be a TD address.
        // So, try it out as a thread id

        GETEXPRVALUE(ptd, "wow32!gptdTaskHead", PTD);
        if (!ptd) {
            Print("Could not get wow32!gptdTaskHead");
            return;
        }

        while(ptd) {
            READMEM_XRET(td, ptd);
            if (td.dwThreadID == dwId) {
                break;
            }

            ptd = td.ptdNext;
        }
        if (!ptd) {
            Print("Could not find thread id %s\n", lpArgumentString);
            return;
        }
    }

    do {

        Print("Dump of TD at 0x%08x:\n\n", (unsigned)ptd);


        READMEM_XRET(td, ptd);

        Print("vpStack             %04x:%04x\n", HIWORD(td.vpStack), LOWORD(td.vpStack));
        Print("vpCBStack           %04x:%04x\n", HIWORD(td.vpCBStack), LOWORD(td.vpCBStack));
        Print("cStackAlloc16       0x%08x\n", td.cStackAlloc16);
        Print("CommDlgTd (ptr)     0x%08x\n", td.CommDlgTd);
        Print("ptdNext             0x%08x\n", td.ptdNext);
        Print("dwFlags             0x%08x\n", td.dwFlags);

        //
        // Dump symbolic names for TDF_ manifests
        //

        if (td.dwFlags & TDF_IGNOREINPUT) {
            Print("                        TDF_IGNOREINPUT\n");
        }
        if (td.dwFlags & TDF_FORCETASKEXIT) {
            Print("                        TDF_FORCETASKEXIT\n");
        }
        if (td.dwFlags & TDF_TASKCLEANUPDONE) {
            Print("                        TDF_TASKCLEANUPDONE\n");
        }
        Print("VDMInfoiTaskID      0x%08x\n", td.VDMInfoiTaskID);

        //
        // Dump CommDlgTd structure if present
        //

        if (td.CommDlgTd) {

            COMMDLGTD CommDlgTd;
            BOOL fCopySuccessful = TRUE;

            READMEM_XRET(CommDlgTd, td.CommDlgTd);

            if (fCopySuccessful) {

                Print("\n");
                Print("    Dump of CommDlgTd at 0x%08x:\n", td.CommDlgTd);
                Print("    hdlg                  0x%04x\n", CommDlgTd.hdlg);
                Print("    vpData                %04x:%04x\n", HIWORD(CommDlgTd.vpData), LOWORD(CommDlgTd.vpData));
                Print("    pData32               0x%08x\n", CommDlgTd.pData32);
                Print("    vpfnHook              %04x:%04x\n", HIWORD(CommDlgTd.vpfnHook), LOWORD(CommDlgTd.vpfnHook));
                Print("    vpfnSetupHook (union) %04x:%04x\n", HIWORD(CommDlgTd.vpfnSetupHook), LOWORD(CommDlgTd.vpfnSetupHook));
                Print("    pRes          (union) 0x%08x\n", CommDlgTd.pRes);
                Print("    SetupHwnd             0x%04x\n", CommDlgTd.SetupHwnd);
                Print("    Previous              0x%08x\n", CommDlgTd.Previous);
                Print("    Flags                 0x%08x\n", CommDlgTd.Flags);

                //
                // Dump symbolic names for WOWCD_ manifests
                //

                if (CommDlgTd.Flags & WOWCD_ISCHOOSEFONT) {
                    Print("                          WOWCD_ISCHOOSEFONT\n");
                }
                if (CommDlgTd.Flags & WOWCD_ISOPENFILE) {
                    Print("                          WOWCD_ISOPENFILE\n");
                }

                Print("\n");

            }
        }


        Print("dwWOWCompatFlags    0x%08x\n", td.dwWOWCompatFlags);

        //
        // Dump symbolic names for WOWCF_ manifests
        //
        if (td.dwWOWCompatFlags) {
            i = 0;
            while(CFData[i].dwVal) {

                if (td.dwWOWCompatFlags & CFData[i].dwVal) {
                    Print("                        %s\n", CFData[i].lpszCFName);
                }

                i++;
            }
        }


        Print("dwWOWCompatFlagsEx  0x%08x\n", td.dwWOWCompatFlagsEx);

        //
        // Dump symbolic names for WOWCFEX_ manifests
        //
        if (td.dwWOWCompatFlagsEx) {
            i = 0;
            while(CFDataEx[i].dwVal) {

                if (td.dwWOWCompatFlagsEx & CFDataEx[i].dwVal) {
                    Print("                        %s\n", CFDataEx[i].lpszCFName);
                }

                i++;
            }
        }

#if FE_SB
        Print("dwWOWCompatFlags2   0x%08x\n", td.dwWOWCompatFlags2);

        //
        // Dump symbolic names for WOWCFEX_ manifests
        //

        if (td.dwWOWCompatFlags2) {
            i = 0;
            while(CFDataIME[i].dwVal) {

                if (td.dwWOWCompatFlags2 & CFDataIME[i].dwVal) {
                    Print("                        %s\n", CFDataIME[i].lpszCFName);
                }

                i++;
            }
        }
#endif

        Print("dwThreadID          0x%08x\n", td.dwThreadID);
        Print("hThread             0x%08x\n", td.hThread);
        Print("hIdleHook           0x%08x\n", td.hIdleHook);
        Print("hrgnClip            0x%08x\n", td.hrgnClip);
        Print("ulLastDesktophDC    0x%08x\n", td.ulLastDesktophDC);
        Print("pWOAList            0x%08x\n", td.pWOAList);

        //
        // Dump WOATD structure if present
        //

        pWOALast = NULL;
        pWOA = td.pWOAList;

        while (pWOA && pWOA != pWOALast) {

            union {
               WOAINST WOA;
               char    buf[128+2+16];
            } u;

            READMEM_XRET(u.buf, pWOA);

            Print("\n");
            Print("    Dump of WOAINST at 0x%08x:\n", pWOA);
            Print("    pNext                 0x%08x\n", u.WOA.pNext);
            Print("    ptdWOA                0x%08x\n", u.WOA.ptdWOA);
            Print("    dwChildProcessID      0x%08x\n", u.WOA.dwChildProcessID);
            Print("    hChildProcess         0x%08x\n", u.WOA.hChildProcess);
            Print("    szModuleName          %s\n",     u.WOA.szModuleName);
            Print("\n");

            pWOALast = pWOA;
            pWOA = u.WOA.pNext;

        }

        Print("htask16             0x%04x\n", td.htask16, td.htask16);

        //
        // Dump the most interesting TDB fields
        //

        if (ptdb = (PTDB) (GetInfoFromSelector(td.htask16, PROT_MODE, NULL) + GetIntelBase())) {

            TDB tdb;

            READMEM_XRET(tdb, ptdb);

            Print("\n");
            Print("    Highlights of TDB at 0x%08x:\n", ptdb);

            if (tdb.TDB_sig != TDB_SIGNATURE) {
                Print("    TDB_sig signature is 0x%04x instead of 0x%04x, halting dump.\n",
                      tdb.TDB_sig, TDB_SIGNATURE);
            } else {

                PDOSPDB pPDB;
                DOSPDB  PDB;
                PBYTE   pJFT;
                BYTE    JFT[256];
                WORD    cbJFT;
                PDOSSF  pSFTHead, pSFTHeadCopy;
                DOSSF   SFTHead;
                PDOSSFT pSFT;
                WORD    fh;
                WORD    SFN;
                WORD    i;
                DWORD   cb;
                DWORD   dwCompatFlags;
                PDOSWOWDATA pDosWowData;
                DOSWOWDATA  DosWowData;

                SavedByte = tdb.TDB_ModName[8];
                tdb.TDB_ModName[8] = 0;
                Print("    Module name           \"%s\"\n", tdb.TDB_ModName);
                tdb.TDB_ModName[8] = SavedByte;

                Print("    ExpWinVer             0x%04x\n", tdb.TDB_ExpWinVer);

                dwCompatFlags = *(DWORD *)(&tdb.TDB_CompatFlags);
                Print("    CompatFlags           0x%08x\n", dwCompatFlags);

                if (dwCompatFlags) {
                    //
                    // Dump symbolic names for GACF_ manifests
                    //

                    i = 0;
                    while(CFData31[i].dwVal) {

                        if (dwCompatFlags & CFData31[i].dwVal) {
                            Print("                            %s\n", CFData31[i].lpszCFName);
                        }

                        i++;
                    }
                }

                Print("    Directory             \"%s\"\n", tdb.TDB_LFNDirectory);
                Print("    PDB (aka PSP)         0x%04x\n", tdb.TDB_PDB);

                pPDB  = (PDOSPDB) (GetInfoFromSelector(tdb.TDB_PDB, PROT_MODE, NULL) + GetIntelBase());
                READMEM_XRET(PDB, pPDB);

                Print("    segEnvironment        0x%04x\n", PDB.PDB_environ);

                //
                // Dump open file handle info
                //

                pJFT  = (PBYTE)   (GetIntelBase() +
                                   (HIWORD(PDB.PDB_JFN_Pointer)<<4) +
                                   LOWORD(PDB.PDB_JFN_Pointer));


                cbJFT = PDB.PDB_JFN_Length;

                Print("    JFT                   %04x:%04x (%08x), size 0x%x\n",
                                                 HIWORD(PDB.PDB_JFN_Pointer),
                                                 LOWORD(PDB.PDB_JFN_Pointer),
                                                 pJFT,
                                                 cbJFT);

                try {
                    READMEM(pJFT, JFT, cbJFT);
                } except (1) {
                    Print("Unable to read JFT from 0x%08x!\n", pJFT);
                    return;
                }

                for (fh = 0; fh < cbJFT; fh++) {

                    if (JFT[fh] != 0xFF) {

                        //
                        // Walk the SFT chain to find Nth entry
                        // where N == JFT[fh]
                        //

                        SFN = 0;
                        i = 0;

                        GETEXPRVALUE(pSFTHead, "ntvdm!pSFTHead", PDOSSF);

                        GETEXPRADDR(pDosWowData, "wow32!DosWowData");
                        READMEM_XRET(DosWowData, pDosWowData);

                        if ((DWORD)pSFTHead != DosWowData.lpSftAddr) {
                            Print("ntvdm!pSFTHead is 0x%08x, DosWowData.lpSftAddr ix 0x%08x.\n",
                                   pSFTHead, DosWowData.lpSftAddr);
                        }

                        try {
                            READMEM(pSFTHead, &SFTHead, sizeof(SFTHead));
                        } except (1) {
                            Print("Unable to read SFTHead from 0x%08x!\n", pSFTHead);
                            return;
                        }

                        cb = sizeof(DOSSF) + SFTHead.SFCount * sizeof(DOSSFT);
                        pSFTHeadCopy = MALLOC(cb);

                        // Print("First DOSSF at 0x%08x, SFCount 0x%x, SFLink 0x%08x.\n",
                        //      pSFTHead, SFTHead.SFCount, SFTHead.SFLink);

                        try {
                            READMEM(pSFTHead, pSFTHeadCopy, cb);
                        } except (1) {
                            Print("Unable to read SFTHead from 0x%08x!\n", pSFTHead);
                            return;
                        }

                        pSFT = (PDOSSFT) &(pSFTHeadCopy->SFTable);

                        while (SFN < JFT[fh]) {
                            SFN++;
                            i++;
                            pSFT++;
                            if (i >= pSFTHeadCopy->SFCount) {

                                if (LOWORD(pSFTHeadCopy->SFLink) == 0xFFFF) {
                                    SFN = JFT[fh] - 1;
                                    break;
                                }

                                pSFTHead = (PDOSSF) (GetIntelBase() +
                                                    (HIWORD(pSFTHeadCopy->SFLink)<<4) +
                                                     LOWORD(pSFTHeadCopy->SFLink));

                                i = 0;

                                try {
                                    READMEM(pSFTHead, &SFTHead, sizeof(SFTHead));
                                } except (1) {
                                    Print("Unable to read SFTHead from 0x%08x!\n", pSFTHead);
                                    return;
                                }

                                cb = sizeof(DOSSF) + SFTHead.SFCount * sizeof(DOSSFT);
                                FREE(pSFTHeadCopy);
                                pSFTHeadCopy = MALLOC(cb);

                                // Print("Next DOSSF at 0x%08x, SFCount 0x%x, SFLink 0x%08x.\n",
                                //      pSFTHead, SFTHead.SFCount, SFTHead.SFLink);

                                try {
                                    READMEM(pSFTHead, pSFTHeadCopy, cb);
                                } except (1) {
                                    Print("Unable to read SFTHead from 0x%08x!\n", pSFTHead);
                                    return;
                                }

                                pSFT = (PDOSSFT) &(pSFTHeadCopy->SFTable);
                            }
                        }

                        if (SFN != JFT[fh]) {
                            Print("    Unable to local SFT entry 0x%x for handle 0x%x.\n",
                                  pJFT[fh], fh);
                        } else {
                            Print("    Handle 0x%02x SFN 0x%02x Refs 0x%x Mode 0x%04x Flags 0x%04x ",
                                  fh, SFN, pSFT->SFT_Ref_Count, pSFT->SFT_Mode,
                                  pSFT->SFT_Flags);
                            if (!pSFT->SFT_Flags & 0x80) {
                                Print("NT Handle 0x%08x\n", pSFT->SFT_NTHandle);
                            } else {
                                Print("(NTDOS device)\n");
                            }
                        }

                        FREE(pSFTHeadCopy);
                    }
                }

                Print("\n");
            }

        }

        Print("hInst16             0x%04x\n", td.hInst16);
        Print("hMod16              0x%04x\n", td.hMod16);

        Print("\n");

        ptd = td.ptdNext;

    } while (fAll && ptd);

    return;
}


void
dt(
    CMD_ARGLIST
    )
{
    CMD_INIT();
    ASSERT_WOW_PRESENT;

    if (!GetNextToken()) {
        DumpTask();
    } else {
        if ((lpArgumentString[0] == '-') &&
            (tolower(lpArgumentString[1]) == 'v')) {
            SkipToNextWhiteSpace();
            GetNextToken();
            DumpTaskVerbose();
        } else {
            DumpTaskVerbose();
        }
    }

}



VOID
ddte(
    CMD_ARGLIST
    )
// dump dispatch table entry
{
    W32   dte;
    PW32  pdte;
    char  szW32[32];
    char  szSymbol[256];
    DWORD dwOffset;

    CMD_INIT();
    ASSERT_WOW_PRESENT;

    while (' ' == lpArgumentString[0]) {
        lpArgumentString++;
    }

    pdte = (PW32) WDahtoi(lpArgumentString);


    if (pdte) {

        PRINTF("Dump of dispatch table entry at 0x%08x:\n\n", (unsigned)pdte);

    } else {

        GETEXPRADDR(pdte, "wow32!aw32WOW");
        PRINTF("Dump of first dispatch table entry at 0x%08x:\n\n", (unsigned)pdte);

    }

    try {

        READMEM_XRET(dte, pdte);

        if (dte.lpszW32) {
            READMEM_XRET(szW32, dte.lpszW32);
            dte.lpszW32 = szW32;
            szW32[sizeof(szW32)-1] = '\0';
        }

    } except (1) {

        PRINTF("Exception 0x%08x reading dispatch table entry at 0x%08x!\n\n",
              GetExceptionCode(), pdte);
        return;
    }

    PRINTF("Dispatches to address 0x%08x, ", (unsigned)dte.lpfnW32);
    PRINTF("supposedly function '%s'.\n", dte.lpszW32);

    szSymbol[0] = '\0';
    GetSymbol((LPVOID)dte.lpfnW32, szSymbol, &dwOffset);

    PRINTF("Debugger finds symbol '%s' for that address.\n", szSymbol);
    PRINTF("\n");

    return;
}



PSTR aszWOWCLASS[] =
{
    "UNKNOWN",
    "WIN16",
    "BUTTON",
    "COMBOBOX",
    "EDIT",
    "LISTBOX",
    "MDICLIENT",
    "SCROLLBAR",
    "STATIC",
    "DESKTOP",
    "DIALOG",
    "MENU",
    "ACCEL",
    "CURSOR",
    "ICON",
    "DC",
    "FONT",
    "METAFILE",
    "RGN",
    "BITMAP",
    "BRUSH",
    "PALETTE",
    "PEN",
    "OBJECT"
};


INT  WDahtoi(LPSZ lpsz)
{
    char c;
    int  tot, pow, len, dig, i;


    len = strlen(lpsz) - 1;
    tot = 0;
    pow = 1;

    for(i = len; i >= 0; i--) {

        c = (char)toupper(lpsz[i]);

        if(c == '0') dig = 0;
        else if(c == '1') dig = 1;
        else if(c == '2') dig = 2;
        else if(c == '3') dig = 3;
        else if(c == '4') dig = 4;
        else if(c == '5') dig = 5;
        else if(c == '6') dig = 6;
        else if(c == '7') dig = 7;
        else if(c == '8') dig = 8;
        else if(c == '9') dig = 9;
        else if(c == 'A') dig = 10;
        else if(c == 'B') dig = 11;
        else if(c == 'C') dig = 12;
        else if(c == 'D') dig = 13;
        else if(c == 'E') dig = 14;
        else if(c == 'F') dig = 15;
        else return(-1);

        if(pow > 1) {
           tot += pow * dig;
        }
        else {
           tot = dig;
        }
        pow *= 16;
    }
    return(tot);
}




void
at(
    CMD_ARGLIST
    )
{
    UINT  i;
    ATOM  atom;
    CHAR  pszGAtomName[128];
    CHAR  pszLAtomName[128];
    CHAR  pszCAtomName[128];
    CHAR *argv[2], *psz;

    CMD_INIT();
    ASSERT_WOW_PRESENT;

    if(WDParseArgStr(lpArgumentString, argv, 1) == 1) {

        atom = (ATOM)LOWORD(WDahtoi(argv[0]));

        pszGAtomName[0] = 'G';  // put a random value in 1st byte so we can
        pszLAtomName[0] = 'L';  // tell if it got replaced with a '\0' for
        pszCAtomName[0] = 'C';  // an "undetermined" type

        psz = NULL;
        PRINTF("\n%s: ", argv[0]);
        if(GlobalGetAtomName(atom, pszGAtomName, 128) > 0) {
            PRINTF("<Global atom> \"%s\"  ", pszGAtomName);
            psz = pszGAtomName;
        }
        else if(GetAtomName(atom, pszLAtomName, 128) > 0) {
            PRINTF("<Local atom> \"%s\"  ", pszLAtomName);
            psz = pszLAtomName;
        }
        else if(GetClipboardFormatName((UINT)atom, pszCAtomName, 128) > 0) {
            PRINTF("<Clipboard format> \"%s\"  ", pszCAtomName);
            psz = pszCAtomName;
        }
        if(psz) {
            i = 0;
            while(psz[i] && i < 128) {
                PRINTF(" %2X", psz[i++] & 0x000000FF);
            }
        }
        else {
            PRINTF("<Undetermined type>\n");
            PRINTF("      GlobalGetAtomName string: \"%c\" ", pszGAtomName[0]);
            for(i = 0; i < 8; i++) {
                PRINTF(" %2X", pszGAtomName[i] & 0x000000FF);
            }
            PRINTF("\n            GetAtomName string: \"%c\" ", pszLAtomName[0]);
            for(i = 0; i < 8; i++) {
                PRINTF(" %2X", pszLAtomName[i] & 0x000000FF);
            }
            PRINTF("\n GetClipboardFormatName string: \"%c\" ", pszCAtomName[0]);
            for(i = 0; i < 8; i++) {
                PRINTF(" %2X", pszCAtomName[i] & 0x000000FF);
            }
        }
        PRINTF("\n\n");
    }
    else {
        PRINTF("Usage: at hex_atom_number\n");
    }
}




void
ww(
    CMD_ARGLIST
    )
{
    INT   h16;
    CHAR *argv[2];

    CMD_INIT();
    ASSERT_WOW_PRESENT;

    if(WDParseArgStr(lpArgumentString, argv, 1)) {

        if((h16 = WDahtoi(argv[0])) >= 0) {

        }
        else {
            PRINTF("Usage: ww hwnd16\n");
        }
    }
    else {
        PRINTF("Usage: ww hwnd16\n");
    }
}



void
wc(
    CMD_ARGLIST
    )
{
    PWC pwc;

    INT   h16;
    CHAR *argv[2];

    CMD_INIT();
    ASSERT_WOW_PRESENT;

    if(WDParseArgStr(lpArgumentString, argv, 1)) {

        if((h16 = WDahtoi(argv[0])) >= 0){

            try {

                pwc = (PWC)GetClassLong((HWND)HWND32((HAND16)h16),GCL_WOWWORDS);

                // this got moved out of WC
//              PRINTF("16:16 WndProc : %08lX\n", pwc->vpfnWndProc);

                PRINTF("VPSZ          : %08lX\n", pwc->vpszMenu);
                PRINTF("PWC           : %08lX\n\n", pwc);

            }
            except (EXCEPTION_ACCESS_VIOLATION == GetExceptionCode()) {

                PRINTF("!wow32.wc:  Invalid HWND16 %04x\n", h16);

            }
        }
        else {
            PRINTF("Usage: wc hwnd16\n");
        }
    }
    else {
        PRINTF("Usage: wc hwnd16\n");
    }
}






//
//  Dump Last Logged APIs
//
void
lastlog(
    CMD_ARGLIST
    )
{
    INT     ValueiCircBuffer = CIRC_BUFFERS;
    PVOID   pTmp = NULL;
    INT     iCircBuffer;
    CHAR    achTmp[TMP_LINE_LEN], *pachTmp;
    INT     i;

    CMD_INIT();
    ASSERT_CHECKED_WOW_PRESENT;

    GETEXPRVALUE(iCircBuffer, "wow32!iCircBuffer", INT);
    GETEXPRADDR(pTmp, "wow32!ValueiCircBuffer");
    if(pTmp) {
        try {
            READMEM(pTmp, &ValueiCircBuffer, sizeof(INT));
        } except (1) {
            ValueiCircBuffer = 0;
        }
    }
    if(ValueiCircBuffer == 0) {
        ValueiCircBuffer = CIRC_BUFFERS;
    }
    GETEXPRVALUE(pachTmp, "wow32!pachTmp", PCHAR);

    for (i = iCircBuffer; i >= 0; i--) {
        READMEM_XRET(achTmp, &pachTmp[i*TMP_LINE_LEN]);
        PRINTF("%s",achTmp);
    }

    for (i = ValueiCircBuffer-1; i > iCircBuffer; i--) {
        READMEM_XRET(achTmp, &pachTmp[i*TMP_LINE_LEN]);
        PRINTF("%s",achTmp);
    }

    return;
}


// creates/closes toggle for logfile for iloglevel logging in c:\ilog.log
void
logfile(
    CMD_ARGLIST
    )
{
    INT     nArgs;
    CHAR   *argv[2], szLogFile[128];
    DWORD   fLog;
    LPVOID  lpfLog, lpszLogFile;

    CMD_INIT();
    ASSERT_CHECKED_WOW_PRESENT;

    nArgs = WDParseArgStr(lpArgumentString, argv, 1);

    GETEXPRADDR(lpfLog, "wow32!fLog");
    READMEM_XRET(fLog, lpfLog);

    if(nArgs) {
        strcpy(szLogFile, argv[0]);
    }
    else {
        strcpy(szLogFile, "c:\\ilog.log");
    }

    if(fLog == 0) {
        fLog = 2;

        PRINTF("\nCreating ");
        PRINTF(szLogFile);
        PRINTF("\n\n");
    }
    else {
        fLog = 3;
        PRINTF("\nClosing logfile\n\n");
    }

    WRITEMEM_XRET(lpfLog, fLog);

    GETEXPRADDR(lpszLogFile, "wow32!szLogFile");
    WRITEMEM_N_XRET(lpszLogFile, szLogFile, strlen(szLogFile)+1);

    return;
}




//
//  Set iLogLevel from Debugger Extension
//
void
setloglevel(
    CMD_ARGLIST
    )
{
    INT    iLogLevel;
    LPVOID lpAddress;

    CMD_INIT();
    ASSERT_CHECKED_WOW_PRESENT;

    GETEXPRADDR(lpAddress, "wow32!iLogLevel");
    iLogLevel = (INT)GetExpression(lpArgumentString);
    WRITEMEM_XRET(lpAddress, iLogLevel);

    return;
}


//
//  Toggle Single Step Trace Mode
//
void
steptrace(
    CMD_ARGLIST
    )
{
    INT    localfDebugWait;
    LPVOID lpAddress;

    CMD_INIT();
    ASSERT_CHECKED_WOW_PRESENT;

    GETEXPRADDR(lpAddress, "wow32!fDebugWait");
    READMEM_XRET(localfDebugWait, lpAddress);
    localfDebugWait = ~localfDebugWait;
    WRITEMEM_XRET(lpAddress, localfDebugWait);

    return;
}

/******* Misc filtering functions ********/
//
//  Set Filter Filtering of Specific APIs ON
//
void FilterSpecific( )
{
    INT      i;
    INT      fLogFilter;
    WORD     wfLogFunctionFilter;
    LPVOID   lpAddress;
    PWORD    pawfLogFunctionFilter;
    WORD     wCallId;

    SkipToNextWhiteSpace();
    if (GetNextToken()) {
        wCallId = (WORD)GetExpression(lpArgumentString);
    } else {
        PRINTF("Please specify an api callid\n");
        return;
    }

    if (!wCallId) {
        PRINTF("Invalid callid\n");
        return;
    }


    GETEXPRVALUE(pawfLogFunctionFilter, "wow32!pawfLogFunctionFilter", PWORD);

    for (i = 0; i < FILTER_FUNCTION_MAX ; i++) {

         // Find Empty Position In Array
         READMEM_XRET(wfLogFunctionFilter, &pawfLogFunctionFilter[i]);
         if ((wfLogFunctionFilter == 0xffff) ||
             (wfLogFunctionFilter == 0x0000)) {

            // Add New Filter to Array
            wfLogFunctionFilter = wCallId;
            WRITEMEM_XRET(&pawfLogFunctionFilter[i], wfLogFunctionFilter);
            break;
         }
    }

    GETEXPRADDR(lpAddress, "wow32!fLogFilter");
    fLogFilter = 0xffffffff;
    WRITEMEM_XRET(lpAddress, fLogFilter);

}


//
//  Clear Filter Specific Array
//
void FilterResetSpecific( )
{
    INT     i;
    WORD    NEG1 = (WORD) -1;
    WORD    ZERO = 0;
    PWORD   pawfLogFunctionFilter;
    LPVOID  lpAddress;

    GETEXPRVALUE(pawfLogFunctionFilter, "wow32!pawfLogFunctionFilter", PWORD);

    WRITEMEM_XRET(&pawfLogFunctionFilter[0], NEG1);
    for (i=1; i < FILTER_FUNCTION_MAX ; i++) {
        WRITEMEM_XRET(&pawfLogFunctionFilter[i], ZERO);
    }

    GETEXPRADDR(lpAddress, "wow32!iLogFuncFiltIndex");
    WRITEMEM_XRET(lpAddress, ZERO);

}

//
//  Set TaskID Filtering
//
void FilterTask( )
{
    INT    fLogTaskFilter;
    LPVOID lpAddress;

    SkipToNextWhiteSpace();
    if (GetNextToken()) {
        GETEXPRADDR(lpAddress, "wow32!fLogTaskFilter");
        fLogTaskFilter = (INT)GetExpression(lpArgumentString);
        WRITEMEM_XRET(lpAddress, fLogTaskFilter);
    } else {
        PRINTF("Please specify a task\n");
    }

    return;
}



//
//  Turn All filtering ON
//
void FilterReset( )
{
    LPVOID lpAddress;
    INT    fLogFilter = 0xffffffff;
    WORD   fLogTaskFilter = 0xffff;

    GETEXPRADDR(lpAddress, "wow32!fLogFilter");
    WRITEMEM_XRET(lpAddress, fLogFilter);

    GETEXPRADDR(lpAddress, "wow32!fLogTaskFilter");
    WRITEMEM_XRET(lpAddress, fLogTaskFilter);

    FilterResetSpecific();
}


//
//  Disable logging on all classes
//
void FilterAll( )
{
    INT    fLogFilter;
    LPVOID lpAddress;

    GETEXPRADDR(lpAddress, "wow32!fLogFilter");
    fLogFilter = 0x00000000;
    WRITEMEM_XRET(lpAddress, fLogFilter);

}


VOID
DumpFilterSettings(
    VOID
    )
{
    INT      i;
    INT      fLogFilter;
    WORD     wfLogFunctionFilter;
    WORD     wfLogTaskFilter;
    LPVOID   lpAddress;
    PWORD    pawfLogFunctionFilter;

    GETEXPRVALUE(pawfLogFunctionFilter, "wow32!pawfLogFunctionFilter", PWORD);
    GETEXPRVALUE(wfLogTaskFilter, "wow32!fLogTaskFilter", WORD);
    GETEXPRADDR(lpAddress, "wow32!fLogFilter");
    READMEM_XRET(fLogFilter, lpAddress);


    if (!pawfLogFunctionFilter) {
        PRINTF("Symbol 'wow32!pawfLogFunctionFilter' not available\n");
        return;
    }

    PRINTF("\n*** WOW log filter state ***\n");
    if (fLogFilter & FILTER_VERBOSE) {
        PRINTF("Verbose logging is on\n");
    } else {
        PRINTF("Verbose logging is off\n");
    }

    if (wfLogTaskFilter != 0xffff) {
        PRINTF("Only API calls for task %04X will be logged\n", wfLogTaskFilter);
    } else {
        PRINTF("Task filtering is off\n");
    }

    READMEM_XRET(wfLogFunctionFilter, &pawfLogFunctionFilter[0]);
    if (wfLogFunctionFilter != 0xffff) {

        PRINTF("\nOnly API calls with the following CallId's will be logged:\n");

        for (i = 0; i < FILTER_FUNCTION_MAX ; i++) {

             // Find Empty Position In Array
             READMEM_XRET(wfLogFunctionFilter, &pawfLogFunctionFilter[i]);
             if ((wfLogFunctionFilter != 0xffff) &&
                 (wfLogFunctionFilter != 0x0000)) {
                PRINTF("    %04X\n", wfLogFunctionFilter);
             }
        }
        PRINTF("\n");
    } else {
        PRINTF("Specific API filtering is off\n");
    }

    if (!(~fLogFilter & ~FILTER_VERBOSE)) {
        PRINTF("API class filtering if off\n");
    } else {
        PRINTF("Logging is disabled for the following API classes:\n");
    }

    if (!(fLogFilter & FILTER_KERNEL)) {
        PRINTF("    KERNEL\n");
    }
    if (!(fLogFilter & FILTER_KERNEL16)) {
        PRINTF("    KERNEL16\n");
    }
    if (!(fLogFilter & FILTER_USER)) {
        PRINTF("    USER\n");
    }
    if (!(fLogFilter & FILTER_GDI)) {
        PRINTF("    GDI\n");
    }
    if (!(fLogFilter & FILTER_KEYBOARD)) {
        PRINTF("    KEYBOARD\n");
    }
    if (!(fLogFilter & FILTER_SOUND)) {
        PRINTF("    SOUND\n");
    }
    if (!(fLogFilter & FILTER_MMEDIA)) {
        PRINTF("    MMEDIA\n");
    }
    if (!(fLogFilter & FILTER_WINSOCK)) {
        PRINTF("    WINSOCK\n");
    }
    if (!(fLogFilter & FILTER_COMMDLG)) {
        PRINTF("    COMMDLG\n");
    }

    PRINTF("\n");

}

void
filter(
    CMD_ARGLIST
    )
{
    ULONG Mask = 0;
    LPVOID   lpAddress;

    CMD_INIT();
    ASSERT_CHECKED_WOW_PRESENT;

    while (' ' == *lpArgumentString) {
        lpArgumentString++;
    }

    if (_strnicmp(lpArgumentString, "kernel16", 8) == 0) {
        Mask = FILTER_KERNEL16;
    } else if (_strnicmp(lpArgumentString, "kernel", 6) == 0) {
        Mask = FILTER_KERNEL;
    } else if (_strnicmp(lpArgumentString, "user", 4) == 0) {
        Mask = FILTER_USER;
    } else if (_strnicmp(lpArgumentString, "gdi", 3) == 0) {
        Mask = FILTER_GDI;
    } else if (_strnicmp(lpArgumentString, "keyboard", 8) == 0) {
        Mask = FILTER_KEYBOARD;
    } else if (_strnicmp(lpArgumentString, "sound", 5) == 0) {
        Mask = FILTER_SOUND;
    } else if (_strnicmp(lpArgumentString, "mmedia", 6) == 0) {
        Mask = FILTER_MMEDIA;
    } else if (_strnicmp(lpArgumentString, "winsock", 7) == 0) {
        Mask = FILTER_WINSOCK;
    } else if (_strnicmp(lpArgumentString, "commdlg", 7) == 0) {
        Mask = FILTER_COMMDLG;
    } else if (_strnicmp(lpArgumentString, "callid", 6) == 0) {
        FilterSpecific();
    } else if (_strnicmp(lpArgumentString, "task", 4) == 0) {
        FilterTask();
    } else if (_strnicmp(lpArgumentString, "*", 1) == 0) {
        FilterAll();
    } else if (_strnicmp(lpArgumentString, "reset", 5) == 0) {
        FilterReset();
    } else if (_strnicmp(lpArgumentString, "verbose", 7) == 0) {
        Mask = FILTER_VERBOSE;
    } else {
        if (*lpArgumentString != 0) {
            PRINTF("Invalid argument to Filter command: '%s'\n", lpArgumentString);
            return;
        }
    }

    if (Mask) {
        INT   fLogFilter;
        GETEXPRADDR(lpAddress, "wow32!fLogFilter");
        if (!lpAddress) {
            PRINTF("Symbol 'wow32!fLogFilter' not available\n");
        } else {
            READMEM_XRET(fLogFilter, lpAddress);
            if ((fLogFilter & Mask) == 0) {
                fLogFilter |= Mask;
            } else {
                fLogFilter &= ~Mask;
            }
            WRITEMEM_XRET(lpAddress, fLogFilter);
        }
    }

    DumpFilterSettings();
}


void
cia(
    CMD_ARGLIST
    )
{
    CURSORICONALIAS cia;
    PVOID lpAddress;
    INT maxdump = 500;

    CMD_INIT();
    ASSERT_WOW_PRESENT;

    GETEXPRADDR(lpAddress, "wow32!lpCIAlias");
    READMEM_XRET(lpAddress, lpAddress);

    if (!lpAddress) {

        PRINTF("Cursor/Icon alias list is empty.\n");

    } else {

        PRINTF("Alias    tp H16  H32      inst mod  task res  szname\n");

        READMEM_XRET(cia, lpAddress);

        while ((lpAddress != NULL) && --maxdump) {

            if (cia.fInUse) {
                PRINTF("%08X", lpAddress);
                PRINTF(" %02X", cia.flType);
                PRINTF(" %04X", cia.h16);
                PRINTF(" %08X", cia.h32);
                PRINTF(" %04X", cia.hInst16);
                PRINTF(" %04X", cia.hMod16);
                PRINTF(" %04X", cia.hTask16);
                PRINTF(" %04X", cia.hRes16);
                PRINTF(" %08X\n", cia.lpszName);
            }

            lpAddress = cia.lpNext;
            READMEM_XRET(cia, lpAddress);

        }

        if (!maxdump) {
            PRINTF("Dump ended prematurely - possible infinite loop\n");
        }
    }

}


//WARNING: This structure must match ENTRY in ntgdi\inc\hmgshare.h

typedef struct _ENTRYWOW
{
    LONG   l1;
    LONG   l2;
    USHORT FullUnique;
    USHORT us1;
    LONG   l3;
} ENTRYWOW, *PENTRYWOW;

// converts an hGDI16 to the equivalent hGDI32
void
hgdi(
    CMD_ARGLIST
    )
{
    ULONG     h16, h32;
    PENTRYWOW pEntry;
    ENTRYWOW  Entry;
    LPVOID    lpAddress;

    CMD_INIT();
    ASSERT_WOW_PRESENT;

    lpAddress = (PENTRYWOW)EXPRESSION("wow32!gpGDIHandleInfo");
    READMEM_XRET(pEntry, lpAddress);

    h16 = (ULONG) WDahtoi(lpArgumentString);
    PRINTF("WOW 16-bit GDI Handle: %04X     ", h16);
    h16 = h16 >> 2;

    pEntry = &pEntry[h16];

    if(!READMEM((LPVOID) (pEntry), &Entry, sizeof(ENTRYWOW))) {
        PRINTF("Failure reading ENTRYWOW At %08lX\n", pEntry);
        return;
    }

    h32 = h16 | (Entry.FullUnique << 16);
    PRINTF("32-bit GDI Handle: %08X\n", h32);

    return;
}



#include "..\wow32\wdde.h"

//typedef struct _HDDE {
//    struct _HDDE *pDDENext;    // pointer to next hDDE alias
//    HAND16  To_hwnd;           // window that will receive this message
//    HAND16  From_hwnd;         // window that sent this message
//    HAND16  hMem16;            // handle of WOW app allocated 16 bit object
//    HANDLE  hMem32;            // handle of WOW allocated 32 bit object
//    WORD    DdeMsg;            // message id
//    WORD    DdeFormat;         // message format
//    WORD    DdeFlags;          // indicates if it is metafile handle
//    HAND16  h16;               // original h16 for bad apps doing EXECUTE
//} HDDE, *PHDDE;

// dumps the list of dde 16-32 memory pairs
void
ddemem(
    CMD_ARGLIST
    )
{
    PHDDE     phdde;
    HDDE      hdde;
    LPVOID    lpAddress;

    CMD_INIT();
    ASSERT_WOW_PRESENT;

    lpAddress = (PENTRYWOW)EXPRESSION("wow32!phDDEFirst");
    READMEM_XRET(phdde, lpAddress);

    while(phdde) {

        if(!READMEM((LPVOID) (phdde), &hdde, sizeof(HDDE))) {
            PRINTF("Failure reading HDDE At %08lX\n", phdde);
            return;
        }

        PRINTF("      PHDDE: %08X\n", phdde);
        PRINTF("  To_hwnd16: %04X\n", hdde.To_hwnd);
        PRINTF("From_hwnd16: %04X\n", hdde.From_hwnd);
        PRINTF("     hMem16: %04X\n", hdde.hMem16);
        PRINTF("     hMem32: %04X\n", hdde.hMem32);
        PRINTF("     DdeMsg: %04X\n", hdde.DdeMsg);
        PRINTF("  DdeFormat: %04X\n", hdde.DdeFormat);
        PRINTF("   DdeFlags: %04X\n", hdde.DdeFlags);
        PRINTF("   Orig h16: %04X\n\n", hdde.h16);

        phdde = hdde.pDDENext;
    }

    return;
}

// must match struct in  "..\wow32\wow32.h"
#ifndef DEBUG
#define ML_MALLOC_W      0x00000001
#define ML_MALLOC_W_ZERO 0x00000002
#define ML_REALLOC_W     0x00000004
#define ML_MALLOC_WTYPE  (ML_MALLOC_W | ML_MALLOC_W_ZERO | ML_REALLOC_W)
#define ML_GLOBALALLOC   0x00000010
#define ML_GLOBALREALLOC 0x00000020
#define ML_GLOBALTYPE    (ML_GLOBALREALLOC | ML_GLOBALALLOC)
typedef struct _tagMEMLEAK {
    struct _tagMEMLEAK *lpmlNext;
    PVOID               lp;
    DWORD               size;
    UINT                fHow;
    ULONG               Count;
    PVOID               CallersAddress;
} MEMLEAK, *LPMEMLEAK;
#endif


void
gmem(
    CMD_ARGLIST
    )
{
    LPMEMLEAK lpml;
    MEMLEAK   ml;
    LPVOID    lpAddress;

    CMD_INIT();
    ASSERT_WOW_PRESENT;

    // DbgBreakPoint();
    lpAddress = (PENTRYWOW)EXPRESSION("wow32!lpMemLeakStart");
    READMEM_XRET(lpml, lpAddress);

    while(lpml) {

        if(!READMEM((LPVOID) (lpml), &ml, sizeof(MEMLEAK))) {
            PRINTF("Failure reading lpml At %08lX\n", lpml);
            return;
        }

        PRINTF("         lp: %08X\n", ml.lp);
        PRINTF("       Size: %08X\n", ml.size);
        PRINTF(" Alloc'd by: %08X\n", ml.CallersAddress);
        PRINTF("Alloc Count: %08X\n", ml.Count);
        PRINTF("How Alloc'd: ");
        if(ml.fHow & ML_MALLOC_W) PRINTF("malloc_w ");
        if(ml.fHow & ML_MALLOC_W_ZERO) PRINTF("malloc_w_zero ");
        if(ml.fHow & ML_REALLOC_W) PRINTF("realloc_w ");
        if(ml.fHow & ML_GLOBALALLOC) PRINTF("GlobalAlloc ");
        if(ml.fHow & ML_GLOBALREALLOC) PRINTF("GlobalReAlloc ");
        PRINTF("\n\n");

        lpml = ml.lpmlNext;
    }

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\vdmexts\wdbgdot.c ===
//  WDBGDOT.C
//
// This file is effectively a copy of core32\kernel\dbgdot.c that builds it for inclusion
// as part of VDMEXTS.DLL
//
//      (C) Copyright Microsoft Corp., 1988-1994
//
//      WDEB386 Dot commands
//
//      This file and the file dbgdota.asm implement the .W dot commands on
//      behalf of wdeb386.  W32ParseDotCommand is called to parse and execute
//      the dot commands.
//
//      *All* memory that is accessed while processing a dot command *must*
//      be present.  If it is not, a page fault will occur which can, and
//      likely will, result in a very large amount of system code being
//      executed.  This will change the state of the system as it is being
//      debugged, and can lead to unexpected, incorrect or fatal behaviour.
//
//      The convention used by the .W commands to handle dumping structures
//      that reside in not-present memory is to display the not-present
//      address in brackets ("[]").  The user may then use the '.MM' command
//      to force the memory present if desired (note that this action has
//      all of the pitfalls described above), and then reissue the .W command.
//
//      All code and data directly associated with the .W commands reside in
//      the LOCKCODE and LOCKDATA segments.  The InitDotCommand function
//      (dbgdota.asm) locks these segments in memory.
//
//  Origin: Chicago
//
//  Change history:
//
//  Date       Who        Description
//  ---------  ---------  -------------------------------------------------
//  15-Feb-94  JonT       Code cleanup and precompiled headers
//
//
// defined to compile the debug support for inclusion in the VDMEXTS.DLL
// debugger extension for MEOW
//
#include <precomp.h>
#pragma hdrstop

#define WOW32_EXTENSIONS 1
#define KERNEL_DOT_COMMANDS 1
#define WOW 1
#undef DEBUG
#include <kernel32.h>

#define dbgprintf PRINTF

#define VerifyMemory(addr,sz) MapDbgAddr(&(addr),sz)

BOOL MapDbgAddr(VOID **ppaddr,ULONG objsz);

#ifdef KERNEL_DOT_COMMANDS

#ifdef WOW32_EXTENSIONS
extern INT  WDParseArgStr(LPSZ lpszArgStr, CHAR **argv, INT iMax);
extern INT  WDahtoi(LPSZ lpsz);
#endif

VOID KERNENTRY DumpFlags(DWORD flags);

#ifndef WOW32_EXTENSIONS

extern PTCB KERNENTRY GetCurThreadHandle();
extern VOID KERNENTRY PrintName16(DWORD, DWORD);
extern EXCEPTION_DISPOSITION __cdecl ExceptionHandler (
    IN struct _EXCEPTION_RECORD *,
    IN PVOID,
    IN OUT struct _CONTEXT *,
    IN OUT PVOID
    );

extern int KERNENTRY WDEBGetBuff(PVOID pSrc, PVOID pDst, DWORD dwLen);

#pragma code_seg("LOCKCODE")
#pragma data_seg("LOCKDATA")

// Validate ptdb or ppdb
#define ValidatePTDB(ptdb)      (VerifyMemory((ptdb), sizeof(TDB)) && \
                                ((ptdb)->objBase.typObj == typObjThread))

#define ValidatePPDB(ppdb)      (VerifyMemory((ppdb), sizeof(PDB)) && \
                                ((ppdb)->objBase.typObj == typObjProcess))

// Convert a ring 0 thread handle to a ptdbx
#define ptcb2ptdbx(ptcb) ((PTDBX)*((PULONG)((DWORD)ptcb + thcboffDeb)))

// VWIN32's thread slot offset from ring 0
DWORD thcboffDeb;
#endif  // ndef WOW32_EXTENSIONS

//
// Some frequently used strings.
//
char NotSignaled[] = "not signaled";
char Signaled[]    = "signaled";

//
// Extended .w help  (.w?)
//
// wdeb has maximum printf buffer size of 256 bytes.  Therefore, strings
// have to be broken up.
//
char *w32DotCommandExtHelp[] = {
"!k32 W"
" [<expression>]\n\
  where <expression> is the address of a win32 object of one of the following\n\
  object types:\n\
    Thread      Process              Semaphore        Event\n\
    Mutex       Critical Section     Timer            Change\n"
#ifndef WOW32_EXTENSIONS
    Console     Con Scrn Buff        "
#endif // ndef WOW32_EXTENSIONS
"\n\
  if <expression> is omitted, information on all threads is displayed.\n",

"!k32 WM"
" - Dump module table\n",

"!k32 WMP"
" [ppdb] - Dump module table for process (no ppdb - current process)\n",

"!k32 WP"
" - Dump process list\n",

#ifndef WOW32_EXTENSIONS

"!k32 WC"
" context - Dump context record\n",

"!k32 WE"
" exception - Dump exception record\n",

"!k32 WD"
" [dispatcherContext] - Dump dispatcher context\n"
"                         Currently active one if no argument\n",
#endif // ndef WOW32_EXTENSIONS

"!k32 WS"
" - Display the status of all ring 3 system critical sections\n",

"!k32 WT[K]"
" [ppdb] - Dump process handle table (no ppdb - current process, K kernel process)\n",

"!k32 WX"
" - Dump memory status\n\n", 0};

//
// All strings must be global in order to get the C compiler to put them
// in the LOCKDATA segment.  This means DON'T define any static data within
// a function.
//
// FLASH!  The latest version of the compiler (8.00.3148) is putting static,
// non-global data in LOCKDATA also, ie. we can get rid of these ugly global
// strings.
//
char DotError[] = "Invalid !k32 w command\n\n";
char NewLine[]  = "\n";
char NotPresentStr[] = "Not present in memory";

char fmt1[]  = "  waiting threads ptdbx: ";
char fmt2[]  = " %08x";
char fmt3[]  = " [%08x]";
char fmt3a[] = "\nControl-C cancel\n";
char fmt4[]  = "\n\t";
char fmt6[]  = "Sem       %08x %s";
char fmt8[]  = "Event     %08x %s";
char fmt9[]  = "Change    %08x hChangeInt=%08x";
char fmt10[] = "%s Owner=%08x(%x)";
char fmt11[] = "%s";
char fmt13[] = "CritSect  %08x Owner=%08x(%x) cCur=%08x cRecur=%08x";
char fmt14[] = "CritSect  %08x Unowned cCur=%08x cRecur=%08x";
char fmt16[] = "Thread [%.8x]\n";
char fmt23[] = " all of:";
char fmt24[] = " any of:";
char fmt27[] = "\n\t";
char fmt29[] = "Mutex     %08x ";
char fmt31[] = "Object %08x is invalid or not-present\n";
char fmt33[] = "[%08x]";
char fmt40[] = "%s %08x lev=%x ";
char fmt41[] = "Owner=%08x(%x) cCur %08x cRecur=%08x ";
char fmt42[] = "Unowned ";
char fmt42a[] = "Can't read ptdbxOwner ";
char fmt43[] = "%s [%08x]\n";
char fmt44[] = "%s [%08x]\n";
char fmt50[] = "Process [%08x]\n";

char fmt60h[] = "IMTE pmte     UCnt Ld BaseAddr FileName\n";
char fmt60i[] = "===================================================\n";
char fmt60[]  = " %2x  %08x  %2d  %s %08x %s\n";

char fmt61h[] = "              MTE  MdRf\n";
char fmt61i[] = "IMTE pmte     UCnt UCnt Ld BaseAddr FileName\n";
char fmt61j[] = "========================================================\n";
char fmt61[] = " %2x  %08x  %2d   %2d  %s %08x %s\n";

char fmt62[] = "IMTE ??? %s\n";
char fmt70[] = "PDB %08x %s\n";
char fmt71h[] = "    IMTE Usg Flags  Ld BaseAddr FileName\n";
char fmt71i[] = "    ====================================================\n";
char fmt71[] =  "     %2x   %2x  %04x  %s %08x %s\n";
char fmt72[] = "Current PDB %08x %s\n";
char fmt72a[] = "Cannot get Current PDB\n";
char fmt72b[] = "Cannot get imteMax\n";
char fmt72c[] = "Current PDB %08x does not have a pModExe\n";
char fmt73[] = "no name";
char fmt74[] = "Value specified %08x is not a valid or present process ID\n";
char fmt74a[] = "Value specified %08x is not a valid or present module structure\n";
char fmt75[] = "Handle table of process ID %08x %s\n"
               "  Handle Object   Flags    Type\n";
char fmt76[] = "    %4x %08x %08x %s (%2x)\n";
char fmt80[] = "Paranoid ring 3 heap walking is now ";
char fmt81[] = "ON\n";
char fmt82[] = "OFF\n";
char fmt83[] = "Stopping on ring 3 memory manager error returns is now ";
char fmt84[] = ".WH doesn't work in the retail build\n";

char* pszObjTypes[] =
{
    "Invalid or not present",
    "Semaphore",
    "Event",
    "Mutex",
    "Critical Section",
    "Timer",
    "Process",
    "Thread",
    "File",
    "Change",
    "Console",
    "IO",
    "Console Screen Buffer",
    "Mapped file",
    "Serial",
    "Device IOCtl",
    "Pipe",
    "Mailslot",
    "Toolhelp",
    "Socket",
    "R0 External Object",
};

#define MAXOBJTYPEINDEX 20


BOOL fDumpHeader = TRUE;
WORD    wHeadK16FreeList = 0;
WORD*   pwHeadSelman16 = NULL;


BOOL MapDbgAddr(VOID **ppaddr,ULONG objsz)
{

    return(FALSE);
}

#if !defined(offsetof)
#define offsetof(s,m)   (size_t)&(((s *)0)->m)
#endif


TDB *GetCurrentTdb(VOID)
{
    CONTEXT                 ThreadContext;
    LDT_ENTRY               dte;
    DWORD                   cb;
    TDB                     *ptdb;

    ThreadContext.ContextFlags = CONTEXT_SEGMENTS;

    if (!GetThreadContext(hCurrentThread, &ThreadContext)) {
        return( NULL );
    }

    cb = ThreadContext.SegFs;

    if (!GetThreadSelectorEntry( hCurrentThread,cb,&dte)) {
        return( NULL );
    }

    cb = (dte.HighWord.Bytes.BaseHi * 0x01000000) + (dte.HighWord.Bytes.BaseMid * 0x00010000) + dte.BaseLow;

    if((cb == 0xFFFFFFFF) || (cb == 0))
        return(NULL);

    cb += offsetof(TIB, pTDB);

    try {
        READMEM((LPVOID)cb, &ptdb, sizeof(TDB *));
    } except (1) {
        return(NULL);
    }

    return(ptdb);
}

BOOL Get16BitMemory(WORD wSelector, WORD wOffset, PVOID pData, ULONG ulSize)
{
    LDT_ENTRY   dte;
    DWORD       cb;
    HANDLE      hThread=hCurrentThread;

//    dbgprintf(  "Ask to read %08X bytes from %04X:%04X of thread %08x\n",
//                ulSize,
//                wSelector,
//                wOffset,
//                hThread);

    if (!GetThreadSelectorEntry( hCurrentThread, wSelector, &dte)) {

        dbgprintf(  "Could not get selector %04X of thread %08x\n",
                    wSelector,
                    hThread);
        return( FALSE );
    }

    cb = (dte.HighWord.Bytes.BaseHi * 0x01000000) + (dte.HighWord.Bytes.BaseMid * 0x00010000) + dte.BaseLow;

    if((cb == 0xFFFFFFFF) || (cb == 0)) {

        dbgprintf(  "Could not compute linear of %04X:%04X of thread %08x\n",
                    wSelector,
                    wOffset,
                    hThread);
        return(FALSE);
    }

    cb+=wOffset;
    try {
        READMEM((LPVOID)cb, pData, ulSize);
    } except (1) {
        dbgprintf(  "Faulted reading %04X:%04X=%08X of thread %08x\n",
                    cb,
                    wSelector,
                    wOffset,
                    hThread);
        return(FALSE);
    }

    return(TRUE);
}

TDBX *GetCurrentTdbx(VOID)
{
    TDB  tdb;
    TDB  *ptdb;

    ptdb = GetCurrentTdb();
    if(!ptdb) {
        return(NULL);
    }

    try {
        READMEM(ptdb, &tdb, sizeof(TDB));
    } except (1) {
        return(NULL);
    }

    return(tdb.ptdbx);
}

PDB *GetCurrentPdb(VOID)
{
    TDB  tdb;
    TDB  *ptdb;
    TIB  tib;

    ptdb = GetCurrentTdb();
    if(!ptdb) {
        return(NULL);
    }

    try {
        READMEM(ptdb, &tdb, sizeof(TDB));
    } except (1) {
        return(NULL);
    }

    try {
        READMEM(tdb.ptib, &tib, sizeof(TIB));
    } except (1) {
        return(NULL);
    }

    return(tib.ppdbProc);
}

MTE *GetModuleTableEntry(IMTE imte, MTE *pmtebuf)
{
    MTE **pmteModTab = 0;
    MTE **pmteModTabEnt;
    MTE  *pmte;
    PVOID pTmp = NULL;

    GETEXPRADDR(pTmp, "mekrnl32!pmteModTable");

    if(pTmp == NULL)
        return(NULL);

    try {
        READMEM(pTmp, &pmteModTab, sizeof(MTE **));\
    } except (1) {
        return(NULL);
    }

    pmteModTabEnt = &(pmteModTab[imte]);

    try {
        READMEM(pmteModTabEnt, &pmte, sizeof(MTE *));
    } except (1) {
        return(NULL);
    }

    try {
        READMEM(pmte, pmtebuf, sizeof(MTE));
    } except (1) {
        return(NULL);
    }

    return(pmte);
}

/***    PnodGetLstElem  - Get an element from a list
**
**  Synopsis
**      NOD * = PnodGetLstElem(plst, id)
**
**  Input:
**      plst        - pointer to the list to retrieve from
**      id          - indicator for which element to return
**
**  Output:
**      returns a pointer to the specified list element
**
**  Errors:
**      return 0L if result is undefined
**
**  Description:
**      This function will set the current position in the list
**      to the specified element and return a pointer to the element.
*/

NOD * KERNENTRY
PnodGetLstElem (LST * plst, NOD * pnodpre, int id)
{
    LST lst;
    NOD nod;

    if(!plst) {
        return(NULL);
    }

    switch (id) {
        case    idLstGetCur:
        case    idLstGetLast:
        case    idLstGetFirst:
            try {
                READMEM(plst, &lst, sizeof(LST));\
            } except (1) {
                dbgprintf("\nInvalid List\n");
                return(NULL);
            }
            if(id == idLstGetFirst)
                return (lst.pnodHead);
            else if(id == idLstGetLast)
                return (lst.pnodEnd);
            else
                return (lst.pnodCur);
            break;

        case    idLstGetNext:
        case    idLstGetPrev:
            if(!pnodpre) {
                return(NULL);
            }
            try {
                READMEM(pnodpre, &nod, sizeof(NOD));\
            } except (1) {
                dbgprintf("\nInvalid List element\n");
                return(NULL);
            }
            if(id == idLstGetNext)
                return(nod.pnodNext);
            else
                return(nod.pnodPrev);
            break;

        default:
            dbgprintf("\nInvalid List request\n");
            return(NULL);
            break;
    }
}


/*** GetObjType
 *
 *      Returns a string indicating the object type
 */

char* KERNENTRY
GetObjType(OBJ* pobj)
{
    int nObjType;

    nObjType = pobj->typObj;
    if (nObjType > MAXOBJTYPEINDEX)
        nObjType = 0;

    return pszObjTypes[nObjType];
}

#ifndef WOW32_EXTENSIONS

extern  DWORD* SelmanBuffer;
extern  DWORD*  pLDT;

/*** ValidatePTCB
 *
 * Validates the r0 thread handle.
 *
 * Entry: ptcb - pointer to thread handle
 *
 * Exit: TRUE if the thread handle is valid
 */

BOOL KERNENTRY
ValidatePTCB(PTCB ptcb)
{
    _asm mov edi, [ptcb]
    _asm or edi, edi
    _asm jz invalidtcb
    VMMCall(Validate_Thread_Handle);
    _asm jc invalidtcb
        return(TRUE);
invalidtcb:
    return(FALSE);
}

/*** ValidatePTDBX
 *
 * Validates the ptdbx
 *
 * Entry: ptdbx - pointer to ptdbx
 *
 * Exit: TRUE if the thread ptdbx is valid
 */

BOOL KERNENTRY
ValidatePTDBX(PTDBX ptdbx)
{
    BOOL f;
    if((f = VerifyMemory(ptdbx, sizeof(TDBX)))) {
        if(ptdbx->tdbxR0ThreadHandle == 0) {
            f = ValidatePTDB((PTDB)ptdbx->tdbxThreadHandle);
        }
        else {
            f = ValidatePTCB((PTCB)ptdbx->tdbxR0ThreadHandle);
        }
    }
    return(f);
}

#endif  // ndef WOW32_EXTENSIONS

/*** PrintThreads
 *
 * Worker routine that displays all threads blocked on a specified wait node.
 *
 * Entry: pwnod - pointer to wait node
 *
 * Exit: none
 */

VOID KERNENTRY
PrintThreads(WNOD *pwnod)
{
    WNOD  wnod;
    TDBX  tdbx;
    int   i = 0;

    dbgprintf(NewLine);

    try {
        READMEM(pwnod, &wnod, sizeof(WNOD));
    } except (1) {
        dbgprintf(fmt3, pwnod);
        dbgprintf(NewLine);
        return;
    }

    if(wnod.ptdbxWait) {
        try {
            READMEM(wnod.ptdbxWait, &tdbx, sizeof(TDBX));
        } except (1) {
            wnod.ptdbxWait = NULL;
        }
    }

    if(!wnod.ptdbxWait) {
        dbgprintf(fmt3, pwnod);
        dbgprintf(NewLine);
        return;
    }


    //
    // print "waiting threads ptdbx: "
    //
    dbgprintf(fmt1);

    //
    // print the first thread on the current line
    //
    dbgprintf("%08x(%x) ", wnod.ptdbxWait,
                           tdbx.tdbxR0ThreadHandle);

    pwnod = wnod.pwnCirc;

    //
    // If there's more threads, print them on the following lines
    //
    if (pwnod != NULL) {
        i = 1;
        do {
            //
            // print a newline every now and then
            //
            if (i % 6 == 0) {
                dbgprintf(fmt27);
            }


            try {
                READMEM(pwnod, &wnod, sizeof(WNOD));
            } except (1) {
                dbgprintf(fmt3, pwnod);
                break;
            }

            if(wnod.ptdbxWait) {
                try {
                    READMEM(wnod.ptdbxWait, &tdbx, sizeof(TDBX));
                } except (1) {
                    wnod.ptdbxWait = NULL;
                }
            }

            if(!wnod.ptdbxWait) {
                dbgprintf(fmt3, pwnod);
                break;
            }

            dbgprintf("%08x(%x) ", wnod.ptdbxWait,
                                   tdbx.tdbxR0ThreadHandle);

            ++i;
        } while ((pwnod = wnod.pwnCirc) != NULL);
    }
    //
    // print a closing newline
    //
    dbgprintf(NewLine);
}


/*** PrintThreadsCrst
 *
 * Prints the waiting threads on a critical section
 *
 * Entry: pcrst -  pointer to critical section object
 *
 * Exit: none
 */

VOID KERNENTRY
PrintThreadsCrst(CRST *pcrst)
{
    PTDBX ptdbx = pcrst->ptdbxWait;
    TDBX  tdbx;

    CheckCtrlC();       // flush queue
    dbgprintf(NewLine);
    if(ptdbx != NULL) {
        //
        // print "waiting threads ptdbx: "
        //
        dbgprintf(fmt1);

        do {
            try {
                READMEM(ptdbx, &tdbx, sizeof(TDBX));
            } except (1) {
                dbgprintf(fmt3, ptdbx);
                break;
            }
            dbgprintf("%08x ", ptdbx);

            if(CheckCtrlC()) {
                dbgprintf(fmt3a);
                break;
            }

            ptdbx = (PTDBX)tdbx.tdbxWaitNodeList.wnlst_pwnCirc;

        } while (ptdbx != NULL && ptdbx != pcrst->ptdbxWait);
    } else {
	dbgprintf("        no waiting threads");
    }
    //
    // print a closing newline
    //
    dbgprintf(NewLine);
}


/*** DumpSemaphore
 *
 * Information on a semaphore object is displayed.
 *
 * Entry: psem -  pointer to semaphore object
 *
 * Exit: none
 */

VOID KERNENTRY
DumpSemaphore(SEM *psem)
{
    SEM   sem;
    char *state;

    try {
        READMEM(psem, &sem, sizeof(SEM));
    } except (1) {
        dbgprintf("Could not read SEM structure for %08x\n", psem);
        return;
    }

    //
    // Determine the current signaled state of the semaphore.
    //
    if (sem.cntCur == 0) {
        state = NotSignaled;
    } else {
        state = Signaled;
    }

    dbgprintf(fmt6, psem, state);

    if (sem.pwnWait != NULL) {
        PrintThreads(sem.pwnWait);
    } else {
        dbgprintf(NewLine);
    }
}

/*** DumpEvent
 *
 * Information on a Event object is displayed.
 *
 * Entry: pevt -  pointer to Event object
 *
 * Exit: none
 */

VOID KERNENTRY
DumpEvent(EVT *pevt)
{
    EVT   evt;
    char *state;

    try {
        READMEM(pevt, &evt, sizeof(EVT));
    } except (1) {
        dbgprintf("Could not read EVT structure for %08x\n", pevt);
        return;
    }
    //
    // Determine the current state of the event.
    //
    if (evt.cntCur == 0) {
        state = NotSignaled;
    } else {
        state = Signaled;
    }

    dbgprintf(fmt8, pevt, state);

    if (evt.pwnWait != NULL) {
        PrintThreads(evt.pwnWait);
    } else {
        dbgprintf(NewLine);
    }
}

/*** DumpMutext
 *
 * Information on a mutext object is displayed.
 *
 * Entry: pmutx -  pointer to mutext object
 *
 * Exit: none
 */

VOID KERNENTRY
DumpMutex(MUTX *pmutx)
{
    MUTX    mutx;
    TDBX    tdbx;

    try {
        READMEM(pmutx, &mutx, sizeof(MUTX));
    } except (1) {
        dbgprintf("Could not read MUTX structure for %08x\n", pmutx);
        return;
    }

    dbgprintf(fmt29, pmutx);

    //
    // Display the mutex's state and owner if it has one.
    //
    if (mutx.cntCur <= 0) {
        if(mutx.ptdbxOwner) {
            try {
                READMEM(mutx.ptdbxOwner, &tdbx, sizeof(TDBX));
            } except (1) {
                tdbx.tdbxR0ThreadHandle = 0;
            }
        } else {
            tdbx.tdbxR0ThreadHandle = 0;
        }
        dbgprintf(fmt10, NotSignaled, mutx.ptdbxOwner,
                         tdbx.tdbxR0ThreadHandle);
    } else {
        dbgprintf(fmt11, Signaled);
    }

    if (mutx.pwnWait != NULL) {
        PrintThreads(mutx.pwnWait);
    } else {
        dbgprintf(NewLine);
    }
}

/*** DumpCritSect
 *
 * Information on a critical section object is displayed.
 *
 * Entry: pcrst -  pointer to critical section object
 *
 * Exit: none
 */

VOID KERNENTRY
DumpCritSect(CRST *pcrst)
{
    CRST  crst;
    TDBX  tdbx;
    CRST *pcrstWait;
    CRST  crstWait;

    try {
        READMEM(pcrst, &crst, sizeof(CRST));
    } except (1) {
        dbgprintf("Could not read CRST structure for %08x\n", pcrst);
        return;
    }

    // if there is no ptr in the ptdbxWait field, we can assume this is an
    // internal critical section
    if (crst.ptdbxWait) {

        pcrstWait = (CRST *)crst.ptdbxWait;

        try {
            READMEM(pcrstWait, &crstWait, sizeof(CRST));
        } except (1) {
            crstWait.typObj = 0;
        }

        if(crstWait.typObj == typObjCrst) {
            pcrst = pcrstWait;
            try {
                READMEM(pcrst, &crst, sizeof(CRST));
            } except (1) {
                dbgprintf("Could not read CRST structure for %08x\n", pcrst);
                return;
            }
        }
    }


    //
    // Display the critical section's owner if it has one.
    //
    if (crst.cntCur <= 0) {

        if(crst.ptdbxOwner) {
            try {
                READMEM(crst.ptdbxOwner, &tdbx, sizeof(TDBX));
            } except (1) {
                tdbx.tdbxR0ThreadHandle = 0;
            }
        } else {
            tdbx.tdbxR0ThreadHandle = 0;
        }

        dbgprintf(fmt13, pcrst, crst.ptdbxOwner,
                         tdbx.tdbxR0ThreadHandle,
                         crst.cntCur, crst.cntRecur);
    } else {
        dbgprintf(fmt14, pcrst, crst.cntCur, crst.cntRecur);
    }
    PrintThreadsCrst(&crst);
}

VOID KERNENTRY
DumpTDBX(PTDBX pTDBX)
{
    TDBX    tdbx;
    DWORD   flags;

    try {
        READMEM(pTDBX, &tdbx, sizeof(TDBX));
    } except (1) {
        dbgprintf("TDBX invalid");
        return;
    }

    dbgprintf("           ptdbx: %08x\n", pTDBX);
    dbgprintf("         CntUses: %8x\n", tdbx.tdbxCntUses);
    dbgprintf("  R0ThreadHandle: %8x\n", tdbx.tdbxR0ThreadHandle);
    dbgprintf("     VxdMutexTry: %8x\n", tdbx.tdbxVxDMutexTry);
    dbgprintf("   VxdMutexGrant: %8x\n", tdbx.tdbxVxDMutexGrant);
    dbgprintf("   ContextHandle: %8x\n", tdbx.tdbxContextHandle);
    dbgprintf("   TimeOutHandle: %8x\n", tdbx.tdbxTimeOutHandle);
    dbgprintf("       WakeParam: %8x\n", tdbx.tdbxWakeParam);
    dbgprintf("     BlockHandle: %8x\n", tdbx.tdbxBlockHandle);
    dbgprintf("      BlockState: %8x\n", tdbx.tdbxBlockState);
    dbgprintf("  Wait node list: %8x\n", tdbx.tdbxWaitNodeList);
    dbgprintf("    SuspendCount: %8x\n", tdbx.tdbxSuspendCount);
    dbgprintf("   SuspendHandle: %8x\n", tdbx.tdbxSuspendHandle);
    dbgprintf("   MustCpltCount: %8x\n", tdbx.tdbxMustCpltCount);
    flags = tdbx.tdbxWaitExFlags;
    dbgprintf("     WaitExFlags: %08x ", flags);
    if(flags & TDBX_WAITEXBIT_MASK) 
        dbgprintf("WAITEXBIT ");
    if(flags & TDBX_WAITACKBIT_MASK) 
        dbgprintf("WAITACKBIT ");
    if(flags & TDBX_SUSPEND_APC_PENDING_MASK)
        dbgprintf("SUSPEND_APC_PENDING ");
    if(flags & TDBX_SUSPEND_TERMINATED_MASK) 
        dbgprintf("SUSPEND_TERMINATED ");
    if(flags & TDBX_BLOCKED_FOR_TERMINATION_MASK) 
        dbgprintf("BLOCKED_FOR_TERMINATION ");
    if(flags & TDBX_EMULATE_NPX_MASK) 
        dbgprintf("EMULATE_NPX ");
    if(flags & TDBX_WIN32_NPX_MASK)
        dbgprintf("WIN32_NPX ");
    if(flags & TDBX_EXTENDED_HANDLES_MASK)
        dbgprintf("EXTENDED_HANDLES ");
    if(flags & TDBX_FROZEN_MASK)
        dbgprintf("FROZEN ");
    if(flags & TDBX_DONT_FREEZE_MASK)
        dbgprintf("DONT_FREEZE ");
    if(flags & TDBX_DONT_UNFREEZE_MASK)
        dbgprintf("DONT_UNFREEZE ");
    if(flags & TDBX_DONT_TRACE_MASK)
        dbgprintf("DONT_TRACE ");
    if(flags & TDBX_STOP_TRACING_MASK)
        dbgprintf("STOP_TRACING ");
    if(flags & TDBX_WAITING_FOR_CRST_SAFE_MASK)
        dbgprintf("WAITING_FOR_CRST_SAFE ");
    if(flags & TDBX_CRST_SAFE_MASK) 
        dbgprintf("CRST_SAFE ");
    if(flags & TDBX_THREAD_NOT_INIT_MASK)
        dbgprintf("THREAD_NOT_INIT ");
    if(flags & TDBX_BLOCK_TERMINATE_APC_MASK)
        dbgprintf("BLOCK_TERMINATE_APC ");
    dbgprintf("\n");
    dbgprintf("   SyncWaitCount: %8x\n", tdbx.tdbxSyncWaitCount);
    dbgprintf("  QueuedSyncAPCs: %8x\n", tdbx.tdbxQueuedSyncAPCs);
    dbgprintf("     UserAPCList: %8x\n", tdbx.tdbxUserAPCList);
    dbgprintf("     KernAPCList: %8x\n", tdbx.tdbxKernAPCList);
    dbgprintf("  pPMPSPSelector: %08x\n", tdbx.tdbxpPMPSPSelector);
    dbgprintf("     BlockedOnID: %8x\n", tdbx.tdbxBlockedOnID);
    dbgprintf("    TraceRefData: %8x\n", tdbx.tdbxTraceRefData);
    dbgprintf("   TraceCallBack: %8x\n", tdbx.tdbxTraceCallBack);
    dbgprintf("  TraceOutLastCS: %8.4x\n", tdbx.tdbxTraceOutLastCS);
    dbgprintf("TraceEventHandle: %8.4x\n", tdbx.tdbxTraceEventHandle);
    dbgprintf("       K16PDBSel: %8.4x\n", tdbx.tdbxK16PDB);
    dbgprintf("       DosPDBSeg: %8.4x\n", tdbx.tdbxDosPDBSeg);
    dbgprintf("  ExceptionCount: %8.2x\n", tdbx.tdbxExceptionCount);
    dbgprintf("       SavedIrql: %8.2x\n", tdbx.tdbxSavedIrql);
    dbgprintf("  SavedIrqlCount: %8.2x\n", tdbx.tdbxSavedIrqlCount);
    dbgprintf("          K16TDB: %8.4x\n", tdbx.tdbxK16Task);
    if(tdbx.tdbxK16Task) {
        TDB16   tdb16;

        if (Get16BitMemory(tdbx.tdbxK16Task, 0, &tdb16, sizeof(TDB16))) {

            dbgprintf("               Task16 SSSP: %04x:%04x\n",tdb16.TDB_taskSS,tdb16.TDB_taskSP);
            dbgprintf("      Task16 Event Counter: %4x\n",tdb16.TDB_nEvents);
            dbgprintf("          Task16 Priority : %4x\n",tdb16.TDB_priority);
            dbgprintf("              Task16 Flags:   %02x ",tdb16.TDB_flags);
            if(tdb16.TDB_flags & TDBF_CACHECHECK)
                dbgprintf("CACHECHK ");
            if(tdb16.TDB_flags & TDBF_NEWTASK)
                dbgprintf("NOT_SCHED_YET ");
            if(tdb16.TDB_flags & TDBF_KERNEL32)
                dbgprintf("K32 ");
            if(tdb16.TDB_flags & TDBF_HOOKINT21)
                dbgprintf("HOOK_I21 ");
            if(tdb16.TDB_flags & TDBF_HOOKINT2F)
                dbgprintf("HOOK_I2F ");
            dbgprintf("\n");
            dbgprintf("             Task16 WinVer: %4x\n",tdb16.TDB_ExpWinVer);
            dbgprintf("            Task16 hModule: %4x\n",tdb16.TDB_Module);
            dbgprintf("          Task16 TDBParent: %4x\n",tdb16.TDB_Parent);
            dbgprintf("      Task16 Win32 Thrdhnd: %8x\n",tdb16.TDB_ThreadHandle);
            dbgprintf("                     Drive: %4x\n",tdb16.TDB_Drive);
            dbgprintf("             Old Directory: %s\n" ,tdb16.TDB_Directory);
            dbgprintf("             LFN Directory: %s\n" ,tdb16.TDB_LFNDirectory);
        } else {
            dbgprintf("               Cannot fetch TDB16 memory\n");
        }
    }
}
/*** DumpThread
 *
 * Information on a specified thread is displayed.  Thread handle, thread id,
 * process id, exe name, blocked/ready status, and object(s) blocked on if
 * appropriate is displayed.
 *
 * Entry: ptdb - pointer to tdb (or NULL)
 *        fFullDump - if TRUE, dump all the thread's tdb, tdbx info
 *
 * Exit: none
 */

VOID KERNENTRY
DumpThread(PTDB ptdb, BOOL fFullDump)
{
    int    i;
    PTDB   ptdbSvc;
    PTDB   ptdbFault;
    PTDB   ptdbMEOWCreator;
    WNOD  *pwnod;
    WNOD  *pwnod2;
    WNOD   wnod;
    MTE   *pmte;
    MTE    mte;
    DWORD  flags;
    PPDB   ppdb = NULL;
    PDB    pdb;
    TDB    tdb;
    PTDBX  ptdbx = NULL;
    TDBX   tdbx;
    LPVOID pTmp;
    BOOL   fTDBXValid = TRUE;
    BOOL   fTDBValid = FALSE;
    BOOL   fPDBValid = TRUE;
    PBYTE  p, pTop;
    BYTE   b;
    WORD   wStackSize;
    TIB    tib;

    //
    // Validate everything
    //

    try {
        READMEM(ptdb, &tdb, sizeof(TDB));
    } except (1) {
        dbgprintf("Invalid Thread %08x\n",ptdb);
        return;
    }

    if(tdb.objBase.typObj != typObjThread) {
        dbgprintf("Invalid Thread %08x\n",ptdb);
        return;
    }

    fTDBValid = TRUE;

    ptdbx = tdb.ptdbx;

    try {
        READMEM(ptdbx, &tdbx, sizeof(TDBX));
    } except (1) {
        fTDBXValid = FALSE;
    }

    ppdb = (PPDB)tdbx.tdbxProcessHandle;

    try {
        READMEM(ppdb, &pdb, sizeof(PDB));
    } except (1) {
        fPDBValid = FALSE;
    }

    if(pdb.objBase.typObj != typObjProcess) {
        fPDBValid = FALSE;
    }

    //
    // Print header
    //
    if(fDumpHeader) {
        dbgprintf("  ptdb     ppdb     ptdbx    NTID Tr Gt Stck tdb  name         state\n");
        //         * xxxxxxxx xxxxxxxx xxxxxxxx xxxx xx xx xxxx xxxx ssssssss.sss block
        fDumpHeader = FALSE;
    }
    //
    // Print * for current thread
    //
    if (ptdb == GetCurrentTdb()) {
        dbgprintf("*");
    } else {
        dbgprintf(" ");
    }

    if (fTDBValid) {
        try {
            READMEM(tdb.ptib, &tib, sizeof(TIB));
        } except (1) {
            tib.pvStackUserLimit=NULL;
        }
        pTop=tib.pvStackUserLimit;
        if (pTop>(PBYTE)0x01000000) {
            wStackSize=0xBAD2;
            for (p=pTop-MEOW_BOP_STACK_SIZE;p<pTop;p++) {
                try {
                    READMEM(p, &b, 1);
                } except (1) {
                    wStackSize=0xBAD;
                    break;
                }
                if (b!=MEOW_BOP_STACK_FILL) {
                    wStackSize=(WORD)(pTop-p);
                    break;
                }
            }
        } else {
            wStackSize=0x0;
        }
    } else {
        wStackSize=0xBAD1;
    }

    //
    // Print the thread id, ptdb, ppdb ring 0 thread handle, 16 bit tdb
    //
    dbgprintf(" %08x %08x %08x %04x %02x %02x %04x %04x",
                ptdb,
                ppdb,
                ptdbx,
                fTDBValid ? tdb.R0ThreadHandle : 0xBAD1,
                fTDBXValid ? (BYTE)tdbx.tdbxVxDMutexTry : 0xBD,
                fTDBXValid ? (BYTE)tdbx.tdbxVxDMutexGrant : 0xBD,
                wStackSize,
                fTDBXValid ? tdbx.tdbxK16Task : 0xBAD5
                );

    //
    // Try to get the name of the exe file.
    //
    if(fPDBValid) {
        if(pdb.flFlags & fWin16Process) {
            //
            // This thread belongs to a 16-bit process.
            //
            if(fTDBXValid && tdbx.tdbxK16Task) {

                char    mname[9];

                if (Get16BitMemory(tdbx.tdbxK16Task, offsetof(TDB16, TDB_ModName), &mname, 8)) {
                    mname[8]='\0';
                    dbgprintf(" %-8.8s(16)",mname);
                } else {
                    dbgprintf(" %8x(16)",tdbx.tdbxK16Task);
                }
            } else {
                dbgprintf(" Unknown(16) ");
            }
        } else {
            //
            // This is a 32-bit process.
            //
            pTmp = NULL;
            GETEXPRADDR(pTmp, "mekrnl32!ptdbFault");
            if(pTmp == NULL) {
                ptdbFault = NULL;
            } else {
                try {
                    READMEM(pTmp, &ptdbFault, sizeof(PTDB));\
                } except (1) {
                    ptdbFault = NULL;
                }
            }

            pTmp = NULL;
            GETEXPRADDR(pTmp, "mekrnl32!ptdbSvc");
            if(pTmp == NULL) {
                ptdbSvc = NULL;
            } else {
                try {
                    READMEM(pTmp, &ptdbSvc, sizeof(PTDB));\
                } except (1) {
                    ptdbSvc = NULL;
                }
            }

            pTmp = NULL;
            GETEXPRADDR(pTmp, "mekrnl32!ptdbMEOWCreator");
            if(pTmp == NULL) {
                ptdbMEOWCreator = NULL;
            } else {
                try {
                    READMEM(pTmp, &ptdbMEOWCreator, sizeof(PTDB));\
                } except (1) {
                    ptdbMEOWCreator = NULL;
                }
            }

            if(fTDBValid && ptdbFault &&
              (ptdb == ptdbFault)) {
                dbgprintf(" Fault Thread");
            } else if (fTDBValid && ptdbSvc &&
              (ptdb == ptdbSvc)) {
                dbgprintf(" Krnl Service");
            } else if (fTDBValid && ptdbMEOWCreator &&
              (ptdb == ptdbMEOWCreator)) {
                dbgprintf(" MEOW Creator");
            } else {
                //
                // Verify the address of the mte table
                //
                char mname[13];

                pmte = GetModuleTableEntry(pdb.imte,&mte);

                if(pmte) {
                    pTmp = mte.szName;
                    try {
                        READMEM(pTmp, mname, 12);\
                    } except (1) {
                        mname[0] = ' ';
                        mname[1] = '?';
                        mname[2] = '?';
                        mname[3] = '?';
                        mname[4] = '\0';
                    }
                    for(i = 0; i<12;i++) {
                        if(mname[i] == '\0') {
                            mname[i] = ' ';
                            break;
                        }
                    }
                    for( ; i<12;i++) {
                        mname[i] = ' ';
                    }
                    mname[12] = '\0';

                    dbgprintf(" %s", mname);
                } else {
                    dbgprintf(" Unknown(32) ");
                }
            }
        }
    } else {
        pTmp = NULL;
        GETEXPRADDR(pTmp, "mekrnl32!ptdbFault");
        if(pTmp == NULL) {
            ptdbFault = NULL;
        } else {
            try {
                READMEM(pTmp, &ptdbFault, sizeof(PTDB));\
            } except (1) {
                ptdbFault = NULL;
            }
        }

        pTmp = NULL;
        GETEXPRADDR(pTmp, "mekrnl32!ptdbSvc");
        if(pTmp == NULL) {
            ptdbSvc = NULL;
        } else {
            try {
                READMEM(pTmp, &ptdbSvc, sizeof(PTDB));\
            } except (1) {
                ptdbSvc = NULL;
            }
        }

        pTmp = NULL;
        GETEXPRADDR(pTmp, "mekrnl32!ptdbMEOWCreator");
        if(pTmp == NULL) {
            ptdbMEOWCreator = NULL;
        } else {
            try {
                READMEM(pTmp, &ptdbMEOWCreator, sizeof(PTDB));\
            } except (1) {
                ptdbMEOWCreator = NULL;
            }
        }

        if(fTDBValid && ptdbFault &&
          (ptdb == ptdbFault)) {
            dbgprintf(" Fault Thread");
        } else if (fTDBValid && ptdbSvc &&
          (ptdb == ptdbSvc)) {
            dbgprintf(" Krnl Service");
        } else if (fTDBValid && ptdbMEOWCreator &&
          (ptdb == ptdbMEOWCreator)) {
            dbgprintf(" MEOW Creator");
        } else {
            dbgprintf("   No PDB    ");
        }
    }
    //
    // print the current blocked/ready status of the thread.
    //

    if(fTDBXValid) {

	BOOL fNodOk;

        if(tdbx.tdbxWaitNodeList.wnlst_pwnCirc == NULL) {
            BOOL fReady = TRUE;
            //
            // not blocked on any win32 object
            //
            if(tdbx.tdbxWaitExFlags & TDBX_FROZEN_MASK) {
                fReady = FALSE;
                dbgprintf(" frozen");
            } else if(tdbx.tdbxSuspendCount > 0) {
                fReady = FALSE;
		dbgprintf(" suspnd");
            }
            if((LONG)tdbx.tdbxBlockState < 0) {
                if(tdbx.tdbxWaitNodeList.wnlst_flFlags & fWaitCrst) {
		    dbgprintf(" blked:Crit");
                }
                else {
                    // blocked by something
		    dbgprintf(" blked BlkHnd:%08x",tdbx.tdbxBlockHandle);
                }
            } else {
                // not blocked
                if(tdbx.tdbxWaitExFlags & TDBX_BLOCKED_FOR_TERMINATION_MASK) {
		    dbgprintf(" blk trm");
                }
                else if(tdbx.tdbxBlockedOnID != 0) {
		    dbgprintf(" blkid: %08x", tdbx.tdbxBlockedOnID);
                }
                else if(tdbx.tdbxVxDBlockOnIDID != 0) {
		    dbgprintf(" VxDblkid: %08x", tdbx.tdbxVxDBlockOnIDID);
                }
                else if(fReady) {
		    if ((LONG)tdbx.tdbxBlockState > 0) {
        	        dbgprintf(" ready wp");
		    } else {
	                dbgprintf(" ready nwp");
		    }
                }
            }
            dbgprintf("\n");
        }
        else {
            //
            // blocked on at least one object
            //
	    dbgprintf(" blked: ");

            // If blocked on a critical section
            if(tdbx.tdbxWaitNodeList.wnlst_flFlags & fWaitCrst) {
		dbgprintf("Crit");
	    } else {
		fNodOk = TRUE;

		// Blocked on an semaphore, mutex or event
		pwnod = tdbx.tdbxWaitNodeList.wnlst_pwnCirc;

		try {
		    READMEM(pwnod, &wnod, sizeof(WNOD));
		} except (1) {
		    fNodOk = FALSE;
		}

		if(fNodOk) {
		    dbgprintf("\n\t %08x", wnod.pobjWait);
		    pwnod2 = wnod.pwnNext;

		    if((pwnod2 != pwnod) &&
		      (pwnod2 != tdbx.tdbxWaitNodeList.wnlst_pwnCirc)) {
			//
			// blocked on at least two objects.  Drop down a line and
			// print the remaining objects.
			//
			CheckCtrlC();  // Flush queue
			do {
			    pwnod = pwnod2;
			    //
			    // print a newline every now and then
			    //
			    dbgprintf("\n");
			    dbgprintf("\t");
			    try {
				READMEM(pwnod, &wnod, sizeof(WNOD));
			    } except (1) {
				dbgprintf(fmt3, pwnod);
				break;
			    }
			    dbgprintf(fmt2, wnod.pobjWait);
			    if(CheckCtrlC()) {
				break;
			    }
			    pwnod2 = wnod.pwnNext;
			} while( (pwnod2 != pwnod) &&
				 (pwnod2 != tdbx.tdbxWaitNodeList.wnlst_pwnCirc));
		    }
		} else {
		    //
		    // not-present object
		    //
		    dbgprintf(fmt33, pwnod);
		}
	    }
            dbgprintf("\n");
        }
    } else {
	dbgprintf(" Unknown\n");
    }

    // If we're not doing a full dump, bail out
    if(!fFullDump)
        return;

    if(fTDBValid) {
        DWORD   dwIdObsfucator;
        TIB    *ptib;
        TIB     tib;

        pTmp = NULL;
        GETEXPRADDR(pTmp, "mekrnl32!dwIdObsfucator");
        if(pTmp == NULL) {
            dwIdObsfucator = 0;
        } else {
            try {
                READMEM(pTmp, &dwIdObsfucator, sizeof(DWORD));\
            } except (1) {
                dwIdObsfucator = 0;
            }
        }
        ptib = tdb.ptib;

        try {
           READMEM(ptib, &tib, sizeof(TIB));
        } except (1) {
            ptib = NULL;
        }

        // Display useful TDB information
        if (dwIdObsfucator) {
            dbgprintf("              Id: %08x\n", ((DWORD)(ptdb)) ^ dwIdObsfucator);
        }
        dbgprintf("        Obj Type: %2x %s\n", tdb.objBase.typObj, GetObjType((OBJ*)&tdb));
        dbgprintf("   Obj Ref count: %4x\n", tdb.objBase.cntUses);
        if(ptib) {
            dbgprintf("        pvExcept: %8x\n", tib.pvExcept);
            dbgprintf("    Top of stack: %8x\n", tib.pvStackUserLimit);
            dbgprintf("   Base of stack: %8x\n", tib.pvStackUser);
            dbgprintf("         K16 TDB: %8.4x\n", tib.hTaskK16);
            dbgprintf("     Stack sel16: %8.4x\n", tib.ss16);
            dbgprintf("     Selman list: %8x\n", tib.pvFirstDscr);
            dbgprintf("    User pointer: %8x\n", tib.pvArbitraryUserPointer);
            dbgprintf("            pTIB: %08x\n", tib.ptibSelf);
            dbgprintf("       TIB flags: %8.4x ", tib.flags);
            if(tib.flags & TIBF_WIN32)
                dbgprintf("TIBF_WIN32 ");
            if(tib.flags & TIBF_TRAP)
                dbgprintf("TIBF_TRAP ");
            dbgprintf("\n");
            dbgprintf("Win16Mutex count: %8.4x\n", tib.Win16LockVCount);
            dbgprintf("   Debug context: %8x\n", tib.pcontextDeb);
            dbgprintf("  Ptr to cur pri: %08x", tib.pCurPri);

            pTmp = (LPVOID)tib.pCurPri;
            try {
                READMEM(pTmp, &dwIdObsfucator, sizeof(DWORD));\
            } except (1) {
                dwIdObsfucator = 0xFFFFFFFF;
            }
            if (dwIdObsfucator != 0xFFFFFFFF)
                dbgprintf(" pri: %x", dwIdObsfucator);
            dbgprintf("\n");
            dbgprintf("   Message queue: %8x\n", tib.dwMsgQueue);
            dbgprintf("      pTLS array: %8x\n", tib.ThreadLocalStoragePointer);
        }

        flags = tdb.flFlags;
        dbgprintf("           Flags: %08x ", flags);
        if(flags & fCreateThreadEvent)
            dbgprintf("fCreateThreadEvent ");
        if(flags & fCancelExceptionAbort)
            dbgprintf("fCancelExceptionAbort ");
        if(flags & fOnTempStack)
            dbgprintf("fOnTempStack ");
        if(flags & fGrowableStack)
            dbgprintf("fGrowableStack ");
        if(flags & fDelaySingleStep)
            dbgprintf("fDelaySingleStep ");
        if(flags & fOpenExeAsImmovableFile)
            dbgprintf("fOpenExeAsImmovableFile ");
        if(flags & fCreateSuspended)
            dbgprintf("fCreateSuspended ");
        if(flags & fStackOverflow)
            dbgprintf("fStackOverflow ");
        if(flags & fNestedCleanAPCs)
            dbgprintf("fNestedCleanAPCs ");
        if(flags & fWasOemNowAnsi)
            dbgprintf("fWasOemNowAnsi ");
        if(flags & fOKToSetThreadOem)
            dbgprintf("fOKToSetThreadOem ");
        DumpFlags(flags);
        dbgprintf("          Status: %8x\n", tdb.dwStatus);
        dbgprintf("         TIB sel: %8.4x\n", tdb.selTib);
        dbgprintf("    Emulator sel: %8.4x\n", tdb.selEmul);
        dbgprintf("    Handle count: %8.2x\n", tdb.cntHandles);
        dbgprintf(" APISuspendCount: %8x\n", tdb.dwAPISuspendCount);
        dbgprintf("      R0 hThread: %8x\n", tdb.R0ThreadHandle);
        dbgprintf("      Stack base: %8x\n", tdb.pStackBase);
        dbgprintf("   Emulator data: %8x\n", tdb.pvEmulData);
        dbgprintf("     Debugger CB: %8x\n", tdb.tdb_pderDebugger);
        dbgprintf("     Debugger TH: %8x\n", tdb.tdb_ihteDebugger);
        dbgprintf("         Context: %8x\n", tdb.tdb_pcontext);
        dbgprintf("   Except16 list: %8x\n", tdb.pvExcept16);
        dbgprintf("   Thunk connect: %8x\n", tdb.pvThunkConnectList);
        dbgprintf("  Neg stack base: %8x\n", tdb.dwCurNegBase);
        dbgprintf("      Current SS: %8x\n", tdb.dwCurSS);
        dbgprintf("        SS Table: %8x\n", tdb.pvMapSSTable);
        dbgprintf("      Thunk SS16: %8x\n", tdb.wMacroThunkSelStack16);
        dbgprintf("      hTerminate: %8x\n", tdb.hTerminate);
        dwIdObsfucator = (DWORD)ptdb;
        dwIdObsfucator += offsetof(TDB, TlsArray[0]);
        dbgprintf("       TLS Array: %8x\n", dwIdObsfucator);

        dbgprintf("  Delta priority: %8x\n", tdb.tpDeltaPri);
        dbgprintf("      Error Code: %8x\n", tdb.ercError);
        dbgprintf("   pCreateData16: %8x", tdb.pCreateData16);
        if(tdb.pCreateData16) {
            CREATEDATA16 crtd16;

            pTmp = (LPVOID)tdb.pCreateData16;

            try {
                READMEM(pTmp, &crtd16, sizeof(CREATEDATA16));\
            } except (1) {
                pTmp = NULL;
            }

            if(pTmp) {
                dbgprintf(" pProcessInfo: %8x",crtd16.pProcessInfo);
                dbgprintf(" pStartupInfo: %8x",crtd16.pStartupInfo);
            }
        }
        dbgprintf("\n");

        dbgprintf("          wSSBig: %8x\n", (DWORD)(tdb.wSSBig));
        dbgprintf("   lp16SwitchRec: %8x:%x\n", 
          ((DWORD)(tdb.lp16SwitchRec)) >> 16,
          ((DWORD)(tdb.lp16SwitchRec)) & 0xffff);
        if((!tdb.wSSBig) ||
          ((DWORD)(tdb.wSSBig | 7) ==
          (((tdb.lp16SwitchRec >> 16) & 0xffff ) | 7))) {
            dbgprintf("           Stack: Normal\n");
        } else {
            dbgprintf("           Stack: Big\n");
        }
//#ifdef DEBUG
//      dbgprintf("      Rip string: %8x\n", tdb.pSavedRip);
//#endif
        dbgprintf("\n");
    }
    if(fTDBXValid) {
        DumpTDBX(ptdbx);
    }
}


/*** DumpChange
 *
 * Information on a change notification object is displayed.
 *
 * Entry: pfcndb -  pointer to find change notification object
 *
 * Exit: none
 */

VOID KERNENTRY
DumpChange(FCNDB *pfcndb)
{
    FCNDB fcndb;

    try {
        READMEM(pfcndb, &fcndb, sizeof(FCNDB));
    } except (1) {
        dbgprintf("Could not read FCNDB structure for %08x\n", pfcndb);
        return;
    }
    //
    // Display the Change object's internal handle.
    //
    dbgprintf(fmt9, pfcndb, fcndb.hChangeInt);
    dbgprintf(NewLine);
}

/*** DumpLevel
 *
 * Information on a specified global ring 3 system hierarchical critical
 * section is displayed.
 *
 * Entry: Lock   - Pointer to pointer to leveled critical section
 *        Name   - Pointer to Lock name string
 *
 * Exit: none
 */

VOID KERNENTRY
DumpLevel(
          LCRST *Lock,
          SYSLVL Level,
          char *Name)
{
    LCRST lcrst;

    try {
        READMEM(Lock, &lcrst, sizeof(LCRST));
    } except (1) {
        dbgprintf(fmt43, Name, Lock);
        return;
    }
    dbgprintf(fmt40, Name, Lock, Level);

    //
    // Display the Lock owner if it has one
    //
    if ((long)(lcrst.cstSync.cntCur) <= 0) {

        TDBX  tdbx;

        try {
            READMEM(lcrst.cstSync.ptdbxOwner, &tdbx, sizeof(TDBX));
        } except (1) {
            dbgprintf(fmt42a);
            tdbx.tdbxR0ThreadHandle = 0;
        }
        dbgprintf(fmt41, lcrst.cstSync.ptdbxOwner,
                  lcrst.cstSync.ptdbxOwner ? 
                   (tdbx.tdbxR0ThreadHandle) : 0,
                    lcrst.cstSync.cntCur, lcrst.cstSync.cntRecur);
    } else {
        dbgprintf(fmt42);
    }
    //
    // Display the waiting threads
    //
    PrintThreadsCrst(&lcrst.cstSync);
}


/*** DumpSysLevels
 *
 * Called to process the '.ws' command.  Information on all global ring 3
 * system hierarchical critical sections is displayed.
 *
 * Entry: none
 *
 * Exit: none
 */

VOID KERNENTRY
DumpSysLevels(void)
{
    LCRST  *Win16Lock;     // Hierarchical critical section for Win16
    LCRST  *Krn32Lock;     // Hierarchical critical section for Kernel32
    LCRST  *crstGHeap16;
    LCRST  *crstLstMgr;
    LCRST  *crstExcpt16;
    LPVOID pTmp;
    LPVOID pTDBXVxD;

    pTmp = NULL;
    GETEXPRADDR(pTmp, "mekrnl32!Win16Lock");
    if(pTmp == NULL) {
        Win16Lock = NULL;
    } else {
        try {
            READMEM(pTmp, &Win16Lock, sizeof(LCRST *));\
        } except (1) {
            Win16Lock = NULL;
        }
    }

    pTmp = NULL;
    GETEXPRADDR(pTmp, "mekrnl32!Krn32Lock");
    if(pTmp == NULL) {
        Krn32Lock = NULL;
    } else {
        try {
            READMEM(pTmp, &Krn32Lock, sizeof(LCRST *));\
        } except (1) {
            Krn32Lock = NULL;
        }
    }

    pTmp = NULL;
    GETEXPRADDR(pTmp, "mekrnl32!crstGHeap16");
    if(pTmp == NULL) {
        crstGHeap16 = NULL;
    } else {
        try {
            READMEM(pTmp, &crstGHeap16, sizeof(LCRST *));\
        } except (1) {
            crstGHeap16 = NULL;
        }
    }

    crstLstMgr = crstExcpt16 = NULL;

    GETEXPRADDR(crstLstMgr, "mekrnl32!crstLstMgr");
    GETEXPRADDR(crstExcpt16, "mekrnl32!crstExcpt16");

    if (Win16Lock) {
        DumpLevel(Win16Lock, SL_WIN16, "Win16Mutex ");
    } else {
        dbgprintf("Could not get Win16Lock address from MEKRNL32\n");
    }

    if (Krn32Lock) {
        DumpLevel(Krn32Lock, SL_KRN32, "Krn32Mutex ");
    } else {
        dbgprintf("Could not get Krnl32Lock address from MEKRNL32\n");
    }

    if (crstGHeap16) {
        DumpLevel(crstGHeap16, SL_PRIVATE, "crstGHeap16");
    } else {
        dbgprintf("Could not get crstGHeap16 address from MEKRNL32\n");
    }

    if (crstLstMgr) {
        DumpLevel(crstLstMgr, SL_PRIVATE, "crstLstMgr ");
    } else {
        dbgprintf("Could not get crstLstMgr address from MEKRNL32\n");
    }

    if (crstExcpt16) {
        DumpLevel(crstExcpt16, SL_PRIVATE, "crstExcpt16");
    } else {
        dbgprintf("Could not get crstExcpt16 address from MEKRNL32\n");
    }

    pTmp = 0;
    GETEXPRADDR(pTmp, "wow32!pTDBXVxD");
    if(pTmp) {
	try {
	    READMEM(pTmp, &pTDBXVxD, sizeof(LPVOID));\
	} except (1) {
	    dbgprintf("Could not get pTDBXVxD content from WOW32\n");
            pTDBXVxD = (LPVOID)0xFFFFFFFF;
	}
	if(pTDBXVxD != (LPVOID)0xFFFFFFFF) {
	    if(pTDBXVxD) {
		dbgprintf("VxdMutex owned by ptdbx %08X\n",pTDBXVxD);
	    } else {
		dbgprintf("VxdMutex is Unowned\n");
	    }
	}
    } else {
	dbgprintf("Could not get pTDBXVxD address from WOW32\n");
    }
}

#ifndef WOW32_EXTENSIONS

/*** DisplayContext
 *
 * The information in a context record is displayed.
 *
 * Entry: ContextRecord - pointer to context record
 *
 * Exit: none
 */

VOID KERNENTRY
DisplayContextRecord(PCONTEXT ContextRecord)
{
    if (ContextRecord == 0 ||
        !VerifyMemory(ContextRecord, sizeof(*ContextRecord))) {
        dbgprintf("[%08x]\n", ContextRecord);
        return;
    }

    if (ContextRecord->ContextFlags & (CONTEXT_INTEGER & ~CONTEXT_i386)) {
        dbgprintf(
            "eax=%08x ebx=%08x ecx=%08x edx=%08x esi=%08x edi=%08x\n",
            ContextRecord->Eax,
            ContextRecord->Ebx,
            ContextRecord->Ecx,
            ContextRec