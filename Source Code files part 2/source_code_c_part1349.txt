escription: Provides the RTCP network I/O.
 *
 * INTEL Corporation Proprietary Information
 * This listing is supplied under the terms of a license agreement with
 * Intel Corporation and may not be copied nor disclosed except in
 * accordance with the terms of that agreement.
 * Copyright (c) 1995 Intel Corporation.
 *--------------------------------------------------------------------------*/


#include "rrcm.h"


/*---------------------------------------------------------------------------
/                                                       Global Variables
/--------------------------------------------------------------------------*/
#define DBG_CUM_FRACT_LOSS      0
#define FRACTION_ENTRIES        10
#define FRACTION_SHIFT_MAX      32
long    microSecondFrac [FRACTION_ENTRIES] = {500000,
                                                                                          250000,
                                                                                          125000,
                                                                                           62500,
                                                                                           31250,
                                                                                           15625,
                                                                                            7812,       // some precision lost
                                                                                                3906,   // some precision lost
                                                                                                1953,   // some precision lost
                                                                                                 976};  // ~ 1 milli second



/*---------------------------------------------------------------------------
/                                                       External Variables
/--------------------------------------------------------------------------*/
extern PRTCP_CONTEXT    pRTCPContext;
extern RRCM_WS                  RRCMws;

#ifdef ENABLE_ISDM2
extern ISDM2                    Isdm2;
#endif

#ifdef _DEBUG
extern char             debug_string[];
#endif

#if (defined(_DEBUG) || defined(PCS_COMPLIANCE))
//INTEROP
extern LPInteropLogger RTPLogger;
#endif



/*----------------------------------------------------------------------------
 * Function   : xmtRTCPreport
 * Description: RTCP report generator
 *
 * Input :      pSSRC   : -> to the SSRC entry
 *
 * Return:              None.
 ---------------------------------------------------------------------------*/
BOOL FormatRTCPReport (PRTCP_SESSION pRTCP,
                                                                 PSSRC_ENTRY pSSRC,
                                                                 DWORD curTime)
        {
        PLINK_LIST                      pTmp;
        RTCP_COMMON_T           *pRTCPhdr;
        RTCP_RR_T                       *pRTCPrr;
        RECEIVER_RPT            *pRTCPrecvr;
        SENDER_RPT                      *pRTCPsr;
        DWORD                           numRcvRpt;
        DWORD                           numSrc;
        SOCKET                          sd;
        DWORD                           dwTotalRtpBW = 0;
        PDWORD                          pLastWord;
        SDES_DATA                       sdesBfr[MAX_NUM_SDES];
        PCHAR                           pData;
        unsigned short          pcktLen;
        int                                     weSent = FALSE;

#ifdef _DEBUG
        DWORD                           timeDiff;
#endif

#ifdef ENABLE_ISDM2
        // update ISDM
        if (Isdm2.hISDMdll && pSSRC->hISDM)
                updateISDMstat (pSSRC, &Isdm2, XMITR, TRUE);
#endif

        ASSERT (!pSSRC->dwNumXmtIoPending);     // should only have one pending send
        if (pSSRC->dwNumXmtIoPending)
                return FALSE;
                
        memset (sdesBfr, 0x00, sizeof(SDES_DATA) * MAX_NUM_SDES);

        // lock out access to the SSRC entry
        EnterCriticalSection (&pSSRC->critSect);


        // socket descriptor
        sd = pSSRC->RTCPsd;

        // RTCP common header
        pRTCPhdr = (RTCP_COMMON_T *)pRTCP->XmtBfr.buf;

        // RTP protocol version
        pRTCPhdr->type = RTP_TYPE;

        // reset the flag
        weSent = 0;

        // SR or RR ? Check our Xmt list entry to know if we've sent data
        if (pSSRC->xmtInfo.dwCurXmtSeqNum != pSSRC->xmtInfo.dwPrvXmtSeqNum)
                {
                // set flag for Bw calculation
                weSent = TRUE;

                // update packet count
                pSSRC->xmtInfo.dwPrvXmtSeqNum = pSSRC->xmtInfo.dwCurXmtSeqNum;

                // build SR
                RTCPbuildSenderRpt (pSSRC, pRTCPhdr, &pRTCPsr, sd);

                // set the receiver report pointer
                pData = (PCHAR)(pRTCPsr + 1);

                // adjust for the additional structure defined in the SENDER_RPT
                pData -= sizeof (RTCP_RR_T);

                pRTCPrr = (RTCP_RR_T *)pData;

#ifdef DYNAMIC_RTCP_BW
                // calculate the RTP bandwidth used by this transmitter
                dwTotalRtpBW = updateRtpXmtBW (pSSRC);
#endif
                }
        else
                {
                // payload type, RR
                pRTCPhdr->pt = RTCP_RR;

                // set the receiver report pointer
                pRTCPrecvr = (RECEIVER_RPT *)(pRTCPhdr + 1);

                // set our SSRC as the originator of this report
                RRCMws.htonl (sd, pSSRC->SSRC, &pRTCPrecvr->ssrc);

                pRTCPrr = pRTCPrecvr->rr;
                }

        // build receiver report list
        numRcvRpt = 0;
        numSrc    = 0;

        // go through the received SSRCs list
        pTmp = pRTCP->RcvSSRCList.prev;
        while (pTmp)
                {
                // increment the number of sources for later time-out calculation
                numSrc++;

                // check to see if this entry is an active sender
                if (((PSSRC_ENTRY)pTmp)->rcvInfo.dwNumPcktRcvd ==
                        ((PSSRC_ENTRY)pTmp)->rcvInfo.dwPrvNumPcktRcvd)
                        {
                        // not an active source, don't include it in the RR
                        pTmp = pTmp->next;
                                        
                        // next entry in SSRC list
                        continue;
                        }

                // build RR
                RTCPbuildReceiverRpt ((PSSRC_ENTRY)pTmp, pRTCPrr, sd);

#ifdef DYNAMIC_RTCP_BW
                // calculate the RTP bandwidth used by this remote stream
                dwTotalRtpBW += updateRtpRcvBW ((PSSRC_ENTRY)pTmp);
#endif

                // next entry in receiver report
                pRTCPrr++;

                // next entry in SSRC list
                pTmp = pTmp->next;

                if (++numRcvRpt >= MAX_RR_ENTRIES)
// !!! TODO !!!
// When over 31 sources, generate a second packet or go round robin
                        break;
                }

        // check to see if any Receiver Report. If not, still send an empty RR,
        // that will be followed by an SDES CNAME, for case like initialization
        // time, or when no stream received yet
        if ((numRcvRpt == 0) && (weSent == TRUE))
                {
                // adjust to the right place
                pRTCPrr = (RTCP_RR_T *)pData;
                }

        // report count
        pRTCPhdr->count = (WORD)numRcvRpt;

        // packet length for the previous SR/RR
        pcktLen = (unsigned short)((char *)pRTCPrr - pRTCP->XmtBfr.buf);
        RRCMws.htons (sd, (WORD)((pcktLen >> 2) - 1), &pRTCPhdr->length);

        // check which SDES needs to be send
        RTCPcheckSDEStoXmit (pSSRC, sdesBfr);

        // build the SDES information
        pLastWord = RTCPbuildSDES ((RTCP_COMMON_T *)pRTCPrr, pSSRC, sd,
                                                           pRTCP->XmtBfr.buf, sdesBfr);

        // calculate total RTCP packet length to xmit
        pRTCP->XmtBfr.len = (u_long)((char *)pLastWord - pRTCP->XmtBfr.buf);

        if ( ! (pSSRC->dwSSRCStatus & RTCP_XMT_USER_CTRL))
                {
#ifdef DYNAMIC_RTCP_BW
                // get 5% of the total RTP bandwidth
                dwTotalRtpBW = (dwTotalRtpBW * 5) / 100;

                // calculate the next interval based upon RTCP parameters
                if (dwTotalRtpBW < pSSRC->xmtInfo.dwRtcpStreamMinBW)
                        {
                        dwTotalRtpBW = pSSRC->xmtInfo.dwRtcpStreamMinBW;
                        }

#ifdef _DEBUG
                wsprintf(debug_string, "RTCP: RTCP BW (Bytes/sec) = %ld", dwTotalRtpBW);
                RRCM_DBG_MSG (debug_string, 0, NULL, 0, DBG_TRACE);
#endif

#else
                dwTotalRtpBW = pSSRC->xmtInfo.dwRtcpStreamMinBW;
#endif

                pSSRC->dwNextReportSendTime = curTime + RTCPxmitInterval (numSrc + 1,
                                                                                numRcvRpt,
                                                                                dwTotalRtpBW,
                                                                                weSent,
                                                                                (int)(pRTCP->XmtBfr.len + NTWRK_HDR_SIZE),
                                                                                &pRTCP->avgRTCPpktSizeRcvd,
                                                                                0);
                }
        else
                {
                // user's control of the RTCP timeout interval
                if (pSSRC->dwUserXmtTimeoutCtrl != RTCP_XMT_OFF)
                        {
                        pSSRC->dwNextReportSendTime =
                                timeGetTime() + pSSRC->dwUserXmtTimeoutCtrl;
                        }
                else
                        {
                        pSSRC->dwNextReportSendTime = RTCP_XMT_OFF;
                        }
                }

#ifdef _DEBUG
        timeDiff = curTime - pSSRC->dwPrvTime;
        pSSRC->dwPrvTime = curTime;

        wsprintf(debug_string,
                         "RTCP: Sent report #%ld for SSRC x%lX after %5ld msec - (%s) w/ %d RR",
                         pSSRC->dwNumRptSent,
                         pSSRC->SSRC,
                         timeDiff,
                         (weSent==TRUE) ? "SR": "RR",
                         numRcvRpt);
        RRCM_DBG_MSG (debug_string, 0, NULL, 0, DBG_TRACE);
#endif
        // unlock pointer access
        LeaveCriticalSection (&pSSRC->critSect);        

        return TRUE;
        }



/*----------------------------------------------------------------------------
 * Function   : getSSRCpcktLoss
 * Description: Calculate the packet loss fraction and cumulative number.
 *
 * Input :      pSSRC:  -> to SSRC entry
 *                      update: Flag. Update the number received, or just calculate the
 *                                      number of packet lost w/o updating the counters.
 *
 *
 * Return: Fraction Lost: Number of packet lost (8:24)
 ---------------------------------------------------------------------------*/
 DWORD getSSRCpcktLoss (PSSRC_ENTRY pSSRC,
                                            DWORD update)
        {
        DWORD   expected;
        DWORD   expectedInterval;
        DWORD   rcvdInterval;
        int             lostInterval;
        DWORD   fraction;
        DWORD   cumLost;
        DWORD   dwTmp;

        IN_OUT_STR ("RTCP: Enter getSSRCpcktLoss()\n");

        // if nothing has been received, there is no loss
        if (pSSRC->rcvInfo.dwNumPcktRcvd == 0)
                {
                IN_OUT_STR ("RTCP: Exit getSSRCpcktLoss()\n");

                return 0;
                }

        // as per the RFC, but always one packet off when doing it ???
        expected = pSSRC->rcvInfo.XtendedSeqNum.seq_union.dwXtndedHighSeqNumRcvd -
                                pSSRC->rcvInfo.dwBaseRcvSeqNum + 1;

        cumLost = expected - pSSRC->rcvInfo.dwNumPcktRcvd;

        // 24 bits value
        cumLost &= 0x00FFFFFF;  

#if DBG_CUM_FRACT_LOSS
        wsprintf(debug_string, "RTCP : High Seq. #: %ld - Base: %ld",
                pSSRC->rcvInfo.XtendedSeqNum.seq_union.dwXtndedHighSeqNumRcvd,
                pSSRC->rcvInfo.dwBaseRcvSeqNum + 1);
        RRCM_DBG_MSG (debug_string, 0, NULL, 0, DBG_TRACE);

        wsprintf(debug_string, "RTCP : Expected: %ld - CumLost: %ld",
                                        expected,
                                        cumLost);
        RRCM_DBG_MSG (debug_string, 0, NULL, 0, DBG_TRACE);
#endif

        // Network byte order the lost number (will be or'ed with the fraction)
        RRCMws.htonl (pSSRC->RTPsd, cumLost, &dwTmp);
        cumLost = dwTmp;

        // fraction lost (per RFC)
        expectedInterval = expected - pSSRC->rcvInfo.dwExpectedPrior;
        rcvdInterval     =
                pSSRC->rcvInfo.dwNumPcktRcvd - pSSRC->rcvInfo.dwPrvNumPcktRcvd;

#if DBG_CUM_FRACT_LOSS
        wsprintf(debug_string, "RTCP : Exp. interval: %ld - Rcv interval: %ld",
                expectedInterval,
                rcvdInterval);
        RRCM_DBG_MSG (debug_string, 0, NULL, 0, DBG_TRACE);
#endif

        // check if need to update the data, or just calculate the loss
        if (update)
                {
                pSSRC->rcvInfo.dwExpectedPrior = expected;
                pSSRC->rcvInfo.dwPrvNumPcktRcvd = pSSRC->rcvInfo.dwNumPcktRcvd;
                }

        lostInterval = expectedInterval - rcvdInterval;

        if (expectedInterval == 0 || lostInterval <= 0)
                fraction = 0;
        else
                {
                fraction = (lostInterval << 8) / expectedInterval;

                // 8 bits value
                if (fraction > 0x000000FF)
                        // 100 % loss
                        fraction = 0x000000FF;

                fraction &= 0x000000FF;
                }

#if DBG_CUM_FRACT_LOSS
        wsprintf(debug_string, "RTCP : Lost interval: %ld - Fraction: %ld",
                                                lostInterval,
                                                fraction);
        RRCM_DBG_MSG (debug_string, 0, NULL, 0, DBG_TRACE);
#endif

        // get the 32 bits fraction/number
        cumLost |= fraction;

        IN_OUT_STR ("RTCP: Exit getSSRCpcktLoss()\n");

        return cumLost;
        }


/*----------------------------------------------------------------------------
 * Function   : RTCPcheckSDEStoXmit
 * Description: Check which SDES needs to be transmitted with this report.
 *                              SDES frequency varies for each type and is defined by the
 *                              application.
 *
 * Input :              pSSRC:          -> to the SSRC entry
 *                              pSdes:          -> to SDES buffer to initialize
 *
 * Return:              None
 ---------------------------------------------------------------------------*/
 void RTCPcheckSDEStoXmit (PSSRC_ENTRY pSSRC,
                                                   PSDES_DATA pSdes)
        {
        PSDES_DATA      pTmpSdes = pSdes;

        IN_OUT_STR ("RTCP: Enter RTCPcheckSDEStoXmit()\n");

        if (pSSRC->cnameInfo.dwSdesFrequency)
                {
                if ((pSSRC->dwNumRptSent % pSSRC->cnameInfo.dwSdesFrequency) == 0)
                        {
                        // CNAME
                        pTmpSdes->dwSdesType   = RTCP_SDES_CNAME;
                        pTmpSdes->dwSdesLength = pSSRC->cnameInfo.dwSdesLength;
                        memcpy (pTmpSdes->sdesBfr, pSSRC->cnameInfo.sdesBfr,
                                        pSSRC->cnameInfo.dwSdesLength);
                        }
                }

        pTmpSdes++;

        if (pSSRC->nameInfo.dwSdesFrequency)
                {
                if ((pSSRC->dwNumRptSent % pSSRC->nameInfo.dwSdesFrequency) == 0)
                        {
                        // NAME
                        pTmpSdes->dwSdesType   = RTCP_SDES_NAME;
                        pTmpSdes->dwSdesLength = pSSRC->nameInfo.dwSdesLength;
                        memcpy (pTmpSdes->sdesBfr, pSSRC->nameInfo.sdesBfr,
                                        pSSRC->nameInfo.dwSdesLength);
                        }
                }

        pTmpSdes++;

        if (pSSRC->emailInfo.dwSdesFrequency)
                {
                if ((pSSRC->dwNumRptSent % pSSRC->emailInfo.dwSdesFrequency) == 0)
                        {
                        // EMAIL
                        pTmpSdes->dwSdesType   = RTCP_SDES_EMAIL;
                        pTmpSdes->dwSdesLength = pSSRC->emailInfo.dwSdesLength;
                        memcpy (pTmpSdes->sdesBfr, pSSRC->emailInfo.sdesBfr,
                                        pSSRC->emailInfo.dwSdesLength);
                        }
                }

        pTmpSdes++;

        if (pSSRC->phoneInfo.dwSdesFrequency)
                {
                if ((pSSRC->dwNumRptSent % pSSRC->phoneInfo.dwSdesFrequency) == 0)
                        {
                        // PHONE
                        pTmpSdes->dwSdesType   = RTCP_SDES_PHONE;
                        pTmpSdes->dwSdesLength = pSSRC->phoneInfo.dwSdesLength;
                        memcpy (pTmpSdes->sdesBfr, pSSRC->phoneInfo.sdesBfr,
                                        pSSRC->phoneInfo.dwSdesLength);
                        }
                }

        pTmpSdes++;

        if (pSSRC->locInfo.dwSdesFrequency)
                {
                if ((pSSRC->dwNumRptSent % pSSRC->locInfo.dwSdesFrequency) == 0)
                        {
                        // LOCATION
                        pTmpSdes->dwSdesType   = RTCP_SDES_LOC;
                        pTmpSdes->dwSdesLength = pSSRC->locInfo.dwSdesLength;
                        memcpy (pTmpSdes->sdesBfr, pSSRC->locInfo.sdesBfr,
                                        pSSRC->locInfo.dwSdesLength);
                        }
                }

        pTmpSdes++;

        if (pSSRC->toolInfo.dwSdesFrequency)
                {
                if ((pSSRC->dwNumRptSent % pSSRC->toolInfo.dwSdesFrequency) == 0)
                        {
                        // TOOL
                        pTmpSdes->dwSdesType   = RTCP_SDES_TOOL;
                        pTmpSdes->dwSdesLength = pSSRC->toolInfo.dwSdesLength;
                        memcpy (pTmpSdes->sdesBfr, pSSRC->toolInfo.sdesBfr,
                                        pSSRC->toolInfo.dwSdesLength);
                        }
                }

        pTmpSdes++;

        if (pSSRC->txtInfo.dwSdesFrequency)
                {
                if ((pSSRC->dwNumRptSent % pSSRC->txtInfo.dwSdesFrequency) == 0)
                        {
                        // TEXT
                        pTmpSdes->dwSdesType   = RTCP_SDES_TXT;
                        pTmpSdes->dwSdesLength = pSSRC->txtInfo.dwSdesLength;
                        memcpy (pTmpSdes->sdesBfr, pSSRC->txtInfo.sdesBfr,
                                        pSSRC->txtInfo.dwSdesLength);
                        }
                }

        pTmpSdes++;

        if (pSSRC->privInfo.dwSdesFrequency)
                {
                if ((pSSRC->dwNumRptSent % pSSRC->privInfo.dwSdesFrequency) == 0)
                        {
                        // PRIVATE
                        pTmpSdes->dwSdesType   = RTCP_SDES_PRIV;
                        pTmpSdes->dwSdesLength = pSSRC->privInfo.dwSdesLength;
                        memcpy (pTmpSdes->sdesBfr, pSSRC->privInfo.sdesBfr,
                                        pSSRC->privInfo.dwSdesLength);
                        }
                }

        pTmpSdes++;
        pTmpSdes->dwSdesLength = 0;

        IN_OUT_STR ("RTCP: Exit RTCPcheckSDEStoXmit()\n");
        }


/*----------------------------------------------------------------------------
 * Function   : RTCPbuildSDES
 * Description: Build the SDES report
 *
 * Input :              pRTCPhdr:       -> to the RTCP packet header
 *                              pSSRC:          -> to the SSRC entry
 *                              sd:                     Socket descriptor
 *                              startAddr:      -> to the packet start address
 *                              pSdes:          -> to the SDES information to build
 *
 * Return:              pLastWord:      Address of the packet last Dword
 ---------------------------------------------------------------------------*/
 PDWORD RTCPbuildSDES (RTCP_COMMON_T *pRTCPhdr,
                                           PSSRC_ENTRY pSSRC,
                                           SOCKET sd,
                                           PCHAR startAddr,
                                           PSDES_DATA pSdes)
        {
        RTCP_SDES_T                     *pRTCPsdes;
        RTCP_SDES_ITEM_T        *pRTCPitem;
        int                                     pad = 0;
        PCHAR                           ptr;
        unsigned short          pcktLen;

        IN_OUT_STR ("RTCP: Enter RTCPbuildSDES()\n");

        // setup header
        pRTCPhdr->type  = RTP_TYPE;
        pRTCPhdr->pt    = RTCP_SDES;
        pRTCPhdr->p             = 0;
        pRTCPhdr->count = 1;

        // SDES specific header
        pRTCPsdes = (RTCP_SDES_T *)(pRTCPhdr + 1);

        // Get the SSRC
        RRCMws.htonl (sd, pSSRC->SSRC, &pRTCPsdes->src);

        // SDES item
        pRTCPitem = (RTCP_SDES_ITEM_T *)pRTCPsdes->item;

        while (pSdes->dwSdesLength)
                {
                // set SDES item characteristics
                pRTCPitem->dwSdesType   = (char)pSdes->dwSdesType;

                // make sure we don't go too far
                if (pSdes->dwSdesLength > MAX_SDES_LEN)
                        pSdes->dwSdesLength = MAX_SDES_LEN;

                pRTCPitem->dwSdesLength = (unsigned char)(pSdes->dwSdesLength);

                memcpy (pRTCPitem->sdesData, pSdes->sdesBfr, pSdes->dwSdesLength);

                // packet length
                pcktLen =
                        (unsigned short)((char *)(pRTCPitem->sdesData + pRTCPitem->dwSdesLength) - (char *)pRTCPsdes);

                pRTCPitem = (RTCP_SDES_ITEM_T *)((unsigned char *)pRTCPsdes + pcktLen);

                pSdes->dwSdesLength = 0; // setting this to zero will clear this entry

                // next SDES
                pSdes++;
                }

        // total SDES packet length
        pcktLen = (unsigned short)((char *)pRTCPitem - (char *)pRTCPhdr);

        // Zero the last word of the SDES item chunk, and padd to the
        // 32 bits boundary. If we landed exactly on the boundary then
        // have a whole null word to terminate the sdes, as is needed.
        pad = 4 - (pcktLen & 3);
        pcktLen += (unsigned short)pad;

        ptr = (PCHAR)pRTCPitem;
        while (pad--)
                *ptr++ = 0x00;

        // update packet length in header field
        RRCMws.htons (sd, (WORD)((pcktLen >> 2) - 1), &pRTCPhdr->length);

        IN_OUT_STR ("RTCP: Exit RTCPbuildSDES()\n");

        return ((PDWORD)ptr);
        }


/*----------------------------------------------------------------------------
 * Function   : RTCPbuildSenderRpt
 * Description: Build the RTCP Sender Report
 *
 * Input :              pSSRC:          -> to the SSRC entry
 *                              pRTCPhdr:       -> to the RTCP packet header
 *                              pRTCPsr:        -> to the Sender Report header
 *                              sd:                     Socket descriptor
 *
 * Return:              None
 ---------------------------------------------------------------------------*/
 void   RTCPbuildSenderRpt (PSSRC_ENTRY pSSRC,
                                                        RTCP_COMMON_T *pRTCPhdr,
                                                        SENDER_RPT      **pRTCPsr,
                                                        SOCKET  sd)
        {
        DWORD   dwTmp;
        DWORD   NTPtime;
        DWORD   RTPtime;
        DWORD   RTPtimeStamp = 0;

        IN_OUT_STR ("RTCP: Enter RTCPbuildSenderRpt()\n");

        // payload type, SR
        pRTCPhdr->pt = RTCP_SR;

        // padding
        pRTCPhdr->p      = 0;

        // sender report header
        *pRTCPsr = (SENDER_RPT *)(pRTCPhdr + 1);

        // fill in sender report packet
        RRCMws.htonl (sd, pSSRC->SSRC, &((*pRTCPsr)->ssrc));

        RRCMws.htonl (sd, pSSRC->xmtInfo.dwNumPcktSent, &((*pRTCPsr)->psent));

        RRCMws.htonl (sd, pSSRC->xmtInfo.dwNumBytesSent, &((*pRTCPsr)->osent));

        // NTP timestamp

        NTPtime = RTPtime = timeGetTime ();

        // get the number of seconds (integer calculation)
        dwTmp = NTPtime/1000;

        // NTP Msw
        RRCMws.htonl (sd, (NTPtime/1000), &((*pRTCPsr)->ntp_sec));

        // convert back dwTmp from second to millisecond
        dwTmp *= 1000;

        // get the remaining number of millisecond for the LSW
        NTPtime -= dwTmp;

        // NTP Lsw
        RRCMws.htonl (sd, usec2ntpFrac ((long)NTPtime*1000),
                                  &((*pRTCPsr)->ntp_frac));

        // calculate the RTP timestamp offset which correspond to this NTP
        // time and convert it to stream samples
        if (pSSRC->dwStreamClock)
                {
                RTPtimeStamp =
                        pSSRC->xmtInfo.dwLastSendRTPTimeStamp +
                         ((RTPtime - pSSRC->xmtInfo.dwLastSendRTPSystemTime) *
                          (pSSRC->dwStreamClock / 1000));
                }

        RRCMws.htonl (sd, RTPtimeStamp, &((*pRTCPsr)->rtp_ts));

        IN_OUT_STR ("RTCP: Exit RTCPbuildSenderRpt()\n");
        }


/*----------------------------------------------------------------------------
 * Function   : usec2ntp
 * Description: Convert microsecond to fraction of second for NTP
 *                              As per VIC.
 *                              Convert micro-second to fraction of second * 2^32. This
 *                              routine uses the factorization:
 *                              2^32/10^6 = 4096 + 256 - 1825/32
 *                              which results in a max conversion error of 3*10^-7 and an
 *                              average error of half that
 *
 * Input :              usec:   Micro second
 *
 * Return:              Fraction of second in NTP format
 ---------------------------------------------------------------------------*/
 DWORD usec2ntp (DWORD usec)
        {
        DWORD tmp = (usec * 1825) >>5;
        return ((usec << 12) + (usec << 8) - tmp);
        }


/*----------------------------------------------------------------------------
 * Function   : usec2ntpFrac
 * Description: Convert microsecond to fraction of second for NTP.
 *                              Just uses an array of microsecond and set the corresponding
 *                              bit.
 *
 * Input :              usec:   Micro second
 *
 * Return:              Fraction of second
 ---------------------------------------------------------------------------*/
 DWORD usec2ntpFrac (long usec)
        {
        DWORD   idx;
        DWORD   fraction = 0;
        DWORD   tmpFraction = 0;
        long    tmpVal;
        DWORD   shift;

        for (idx=0, shift=FRACTION_SHIFT_MAX-1;
                 idx < FRACTION_ENTRIES;
                 idx++, shift--)
                {
                tmpVal = usec;
                if ((tmpVal - microSecondFrac[idx]) > 0)
                        {
                        usec -= microSecondFrac[idx];
                        tmpFraction = (1 << shift);
                        fraction |= tmpFraction;
                        }
                else if ((tmpVal - microSecondFrac[idx]) == 0)
                        {
                        tmpFraction = (1 << shift);
                        fraction |= tmpFraction;
                        break;
                        }
                }

        return fraction;
        }


/*----------------------------------------------------------------------------
 * Function   : RTCPbuildReceiverRpt
 * Description: Build the RTCP Receiver Report
 *
 * Input :              pSSRC:          -> to the SSRC entry
 *                              pRTCPsr:        -> to the Receiver Report header
 *                              sd:                     Socket descriptor
 *
 * Return:              None
 ---------------------------------------------------------------------------*/
 void   RTCPbuildReceiverRpt (PSSRC_ENTRY pSSRC,
                                                          RTCP_RR_T     *pRTCPrr,
                                                          SOCKET        sd)
        {
        DWORD   dwDlsr;

        IN_OUT_STR ("RTCP: Enter RTCPbuildReceiverRpt()\n");

        // get the SSRC
        RRCMws.htonl (sd, pSSRC->SSRC, &pRTCPrr->ssrc);

        // get fraction and cumulative number of packet lost (per RFC)
        pRTCPrr->received = getSSRCpcktLoss (pSSRC, TRUE);

        // extended highest sequence number received
        RRCMws.htonl (sd,
                pSSRC->rcvInfo.XtendedSeqNum.seq_union.dwXtndedHighSeqNumRcvd,
                &pRTCPrr->expected);

        // interrarival jitter
#ifdef ENABLE_FLOATING_POINT
        RRCMws.htonl (sd, pSSRC->rcvInfo.interJitter, &pRTCPrr->jitter);
#else
        // Check RFC for details of the round off
        RRCMws.htonl (sd, (pSSRC->rcvInfo.interJitter >> 4), &pRTCPrr->jitter);
#endif

        // last SR
        RRCMws.htonl (sd, pSSRC->xmtInfo.dwLastSR, &pRTCPrr->lsr);

        // delay since last SR (only if an SR has been received from
        // this source, otherwise 0)
        if (pRTCPrr->lsr)
                {
                // get the DLSR
                dwDlsr = getDLSR (pSSRC);

                RRCMws.htonl (sd, dwDlsr, &pRTCPrr->dlsr);
                }
        else
                pRTCPrr->dlsr = 0;

        IN_OUT_STR ("RTCP: Exit RTCPbuildReceiverRpt()\n");
        }

/*----------------------------------------------------------------------------
 * Function   : getDLSR
 * Description: Get a DLSR packet
 *
 * Input :              pSSRC:          -> to the SSRC entry
 *
 * Return:              DLSR in seconds:fraction format
 ---------------------------------------------------------------------------*/
 DWORD getDLSR (PSSRC_ENTRY pSSRC)
        {
        DWORD   dwDlsr;
        DWORD   dwTime;
        DWORD   dwTmp;

        // DLSR in millisecond
        dwTime = timeGetTime() - pSSRC->xmtInfo.dwLastSRLocalTime;

        // get the number of seconds (integer calculation)
        dwTmp = dwTime/1000;

        // set the DLSR upper 16 bits (seconds)
        dwDlsr = dwTmp << 16;

        // convert back dwTmp from second to millisecond
        dwTmp *= 1000;

        // get the remaining number of millisecond for the LSW
        dwTime -= dwTmp;

        // convert microseconds to fraction of seconds
        dwTmp = usec2ntpFrac ((long)dwTime*1000);

        // get only the upper 16 bits
        dwTmp >>= 16;
        dwTmp &= 0x0000FFFF;

        // set the DLSR lower 16 bits (fraction of seconds)
        dwDlsr |= dwTmp;

        return dwDlsr;
        }


/*----------------------------------------------------------------------------
 * Function   : RTCPsendBYE
 * Description: Send an RTCP BYE packet
 *
 * Input :              pRTCP:          -> to the RTCP session
 *                              pSSRC:          -> to the SSRC entry
 *                              byeReason:      -> to the Bye reason, eg, "camera malfunction"...
 *
 * Return:              None
 ---------------------------------------------------------------------------*/
 void RTCPsendBYE (PSSRC_ENTRY pSSRC,
                                   PCHAR pByeReason)
        {
#define MAX_RTCP_BYE_SIZE 500           // ample
        PRTCP_SESSION           pRTCP;
        WSABUF                          wsaBuf;
        char                            buf[MAX_RTCP_BYE_SIZE];
        RTCP_COMMON_T           *pRTCPhdr;
        RTCP_RR_T                       *pRTCPrr;
        RECEIVER_RPT            *pRTCPrecvr;
        BYE_PCKT                        *pBye;
        DWORD                           *pLastWord;
        DWORD                           dwStatus;
        DWORD                           dwNumBytesXfr;
        DWORD                           offset;
        DWORD                           byeLen;
        unsigned short          pcktLen;
        PCHAR                           pBfr;

        IN_OUT_STR ("RTCP: Enter RTCPsendBYE()\n");

        // get the RTCP session
        pRTCP = pSSRC->pRTCPses;

        // check to see if under H.323 conference control. Don't send BYE in
        // this case
        if (pRTCP->dwSessionStatus & H323_CONFERENCE)
                return;

        // make sure the destination address is known
        if (!(pRTCP->dwSessionStatus & RTCP_DEST_LEARNED))
                {
                IN_OUT_STR ("RTCP: Exit RTCPsendBYE()\n");
                return;
                }




        // RTCP common header
        pRTCPhdr = (RTCP_COMMON_T *)buf;

        // RTP protocol version
        pRTCPhdr->type = RTP_TYPE;

        // empty RR
        pRTCPhdr->pt = RTCP_RR;

        // padding
        pRTCPhdr->p     = 0;

        // report count
        pRTCPhdr->count = 0;

        // set the receiver report pointer
        pRTCPrecvr = (RECEIVER_RPT *)(pRTCPhdr + 1);

        // get our SSRC
        RRCMws.htonl (pSSRC->RTCPsd, pSSRC->SSRC, &pRTCPrecvr->ssrc);

        // build receiver report list
        pRTCPrr = pRTCPrecvr->rr;

        // just adjust the size, sending 0 or garbagge doesn't matter, the
        // report count will tell the receiver what's valid
        pRTCPrr++;

        // packet length for the previous RR
        pcktLen = (unsigned short)((char *)pRTCPrr - buf);
        RRCMws.htons (pSSRC->RTCPsd, (WORD)((pcktLen >> 2) - 1), &pRTCPhdr->length);

        // BYE packet
        pRTCPhdr = (RTCP_COMMON_T *)pRTCPrr;
        pRTCPhdr->type  = RTP_TYPE;
        pRTCPhdr->pt    = RTCP_BYE;
        pRTCPhdr->count = 1;

        pBye = (BYE_PCKT *)pRTCPhdr + 1;
        RRCMws.htonl (pSSRC->RTCPsd, pSSRC->SSRC, pBye->src);

        pBye++;

        // send the reason
        pBfr = (PCHAR)pBye;
        if (pByeReason)
                byeLen = min (strlen(pByeReason), MAX_SDES_LEN);
        else
                byeLen = strlen ("Session Terminated");

        // Pre-zero the last word of the SDES item chunk, and padd to the
        // 32 bits boundary. Need to do this before the memcpy, If we
        // landed exactly on the boundary then this will give us a whole
        // null word to terminate the sdes, as is needed.
        offset    = (DWORD)((pBfr - buf) + byeLen);
        pLastWord = (unsigned long *)(buf + (offset & ~3));
        *pLastWord++ = 0;

        if (pByeReason)
                memcpy (pBfr+1, pByeReason, byeLen);
        else
                strcpy (pBfr+1, "Session Terminated");

        *pBfr = (unsigned char)byeLen;

        pcktLen = (unsigned short)((char *)pLastWord - (char *)pRTCPhdr);
        RRCMws.htons (pSSRC->RTCPsd, (WORD)((pcktLen >> 2) - 1), &pRTCPhdr->length);

        // calculate total RTCP packet length to xmit
        wsaBuf.len = (u_long)((char *)pLastWord - buf);

#if (defined(_DEBUG) || defined(PCS_COMPLIANCE))
        if (RTPLogger)
                {
                //INTEROP
                InteropOutput (RTPLogger,
                                           (BYTE FAR*)(buf),
                                           (int)wsaBuf.len,
                                           RTPLOG_SENT_PDU | RTCP_PDU);
                }
#endif

        // send the packet
        dwStatus = RRCMws.sendTo (pSSRC->RTCPsd,
                                                          &wsaBuf,
                                                          1,
                                                          &dwNumBytesXfr,
                                                          0,
                                                          (PSOCKADDR)pRTCP->toBfr,
                                                  pRTCP->toLen,
                                                          NULL,
                                                          NULL);



        IN_OUT_STR ("RTCP: Exit RTCPsendBYE()\n");
        }



/*----------------------------------------------------------------------------
 * Function   : updateRtpXmtBW
 * Description: Calculate a sending stream bandwidth during the last report
 *                              interval.
 *
 * Input :              pSSRC:          -> to the SSRC entry
 *
 * Return:              Bandwith used by transmitter in bytes/sec
 ---------------------------------------------------------------------------*/

#ifdef DYNAMIC_RTCP_BW

DWORD updateRtpXmtBW (PSSRC_ENTRY pSSRC)
        {
        DWORD   dwBW = 0;
        DWORD   dwTimeInterval;
        DWORD   dwByteInterval;
        DWORD   dwTimeNow = timeGetTime();

        IN_OUT_STR ("RTCP: Enter updateRtpXmtBW()\n");

        if (pSSRC->xmtInfo.dwLastTimeBwCalculated == 0)
                {
                pSSRC->xmtInfo.dwLastTimeBwCalculated = dwTimeNow;
                pSSRC->xmtInfo.dwLastTimeNumBytesSent = pSSRC->xmtInfo.dwNumBytesSent;
                pSSRC->xmtInfo.dwLastTimeNumPcktSent  = pSSRC->xmtInfo.dwNumPcktSent;
                }
        else
                {
                dwTimeInterval = dwTimeNow - pSSRC->xmtInfo.dwLastTimeBwCalculated;
                pSSRC->xmtInfo.dwLastTimeBwCalculated = dwTimeNow;

                // get the interval in second (we loose the fractional part)
                dwTimeInterval = dwTimeInterval / 1000;

                dwByteInterval =
                 pSSRC->xmtInfo.dwNumBytesSent - pSSRC->xmtInfo.dwLastTimeNumBytesSent;

                dwBW = dwByteInterval / dwTimeInterval;

                pSSRC->xmtInfo.dwLastTimeNumBytesSent = pSSRC->xmtInfo.dwNumBytesSent;
                pSSRC->xmtInfo.dwLastTimeNumPcktSent  = pSSRC->xmtInfo.dwNumPcktSent;
                }

        IN_OUT_STR ("RTCP: Exit updateRtpXmtBW()\n");

        return dwBW;
        }
#endif // #ifdef DYNAMIC_RTCP_BW


/*----------------------------------------------------------------------------
 * Function   : updateRtpRcvBW
 * Description: Calculate a remote stream RTP bandwidth during the last
 *                              report interval.
 *
 * Input :              pSSRC:          -> to the SSRC entry
 *
 * Return:              Bandwith used by the remote stream in bytes/sec
 ---------------------------------------------------------------------------*/

#ifdef DYNAMIC_RTCP_BW

DWORD updateRtpRcvBW (PSSRC_ENTRY pSSRC)
        {
        DWORD   dwBW = 0;
        DWORD   dwTimeInterval;
        DWORD   dwByteInterval;
        DWORD   dwTimeNow = timeGetTime();

        IN_OUT_STR ("RTCP: Enter updateRtpRcvBW()\n");

        if (pSSRC->rcvInfo.dwLastTimeBwCalculated == 0)
                {
                pSSRC->rcvInfo.dwLastTimeBwCalculated = dwTimeNow;
                pSSRC->rcvInfo.dwLastTimeNumBytesRcvd = pSSRC->rcvInfo.dwNumPcktRcvd;
                pSSRC->rcvInfo.dwLastTimeNumPcktRcvd  = pSSRC->rcvInfo.dwNumBytesRcvd;
                }
        else
                {
                dwTimeInterval = dwTimeNow - pSSRC->rcvInfo.dwLastTimeBwCalculated;
                pSSRC->rcvInfo.dwLastTimeBwCalculated = dwTimeNow;

                // get the interval in second (we loose the fractional part)
                dwTimeInterval = dwTimeInterval / 1000;

                dwByteInterval =
                 pSSRC->rcvInfo.dwNumBytesRcvd - pSSRC->rcvInfo.dwLastTimeNumBytesRcvd;

                dwBW = dwByteInterval / dwTimeInterval;

                pSSRC->rcvInfo.dwLastTimeNumBytesRcvd = pSSRC->rcvInfo.dwNumPcktRcvd;
                pSSRC->rcvInfo.dwLastTimeNumPcktRcvd  = pSSRC->rcvInfo.dwNumBytesRcvd;
                }

        IN_OUT_STR ("RTCP: Exit updateRtpXmtBW()\n");

        return dwBW;
        }
#endif // #ifdef DYNAMIC_RTCP_BW



// [EOF]
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\rrcm\rtcp\rtcpsess.cpp ===
/*----------------------------------------------------------------------------
 * File:        RTCPSESS.C
 * Product:     RTP/RTCP implementation
 * Description: Provides RTCP session management.
 *
 * INTEL Corporation Proprietary Information
 * This listing is supplied under the terms of a license agreement with
 * Intel Corporation and may not be copied nor disclosed except in
 * accordance with the terms of that agreement.
 * Copyright (c) 1995 Intel Corporation.
 *--------------------------------------------------------------------------*/

	
#include "rrcm.h"


/*---------------------------------------------------------------------------
/							Global Variables
/--------------------------------------------------------------------------*/




/*---------------------------------------------------------------------------
/							External Variables
/--------------------------------------------------------------------------*/
extern PRTCP_CONTEXT	pRTCPContext;
extern PRTP_CONTEXT		pRTPContext;
extern RRCM_WS			RRCMws;

#ifdef ENABLE_ISDM2
extern ISDM2			Isdm2;
#endif

#ifdef _DEBUG
extern char	debug_string[];
#endif

#if (defined(_DEBUG) || defined(PCS_COMPLIANCE))
//INTEROP
extern LPInteropLogger     RTPLogger;
#endif





/*----------------------------------------------------------------------------
 * Function   : CreateRTCPSession
 * Description: Creates an RTCP session.
 *
 * Input :      RTPsd			: RTP socket descriptor
 *				RTCPsd			: RTCP socket descriptor
 *				lpTo			: To address
 *				toLen			: To address length
 *				pSdesInfo		: -> to SDES information
 *				dwStreamClock	: Stream clocking frequency
 *				pEncryptInfo	: -> to encryption information
 *				ssrc			: If set, user selected SSRC
 *				pSSRCcallback	: Callback for user's selected SSRC
 *				dwCallbackInfo	: User callback information
 *				miscInfo		: Miscelleanous information:
 *										H.323Conf:		0x00000002
 *										Encrypt SR/RR:	0x00000004
 *										RTCPon:			0x00000008
 *				dwRtpSessionBw	: RTP session bandwidth used for RTCP BW
 *				*pRTCPStatus	: -> to status information
 *
 * Return: 		NULL 		: Couldn't create RTCP session
 *         		!0  		: RTCP session's address
 ---------------------------------------------------------------------------*/
 PRTCP_SESSION CreateRTCPSession (SOCKET RTPsd,
								  SOCKET RTCPsd,
 						  		  LPVOID lpTo,
								  DWORD toLen,
								  PSDES_DATA pSdesInfo,
								  DWORD dwStreamClock,
								  PENCRYPT_INFO pEncryptInfo,
								  DWORD ssrc,
								  PRRCM_EVENT_CALLBACK pRRCMcallback,
								  DWORD_PTR dwCallbackInfo,
								  DWORD	miscInfo,
								  DWORD dwRtpSessionBw,
								  DWORD *pRTCPstatus)
	{
	PRTCP_SESSION		pRTCPses   = NULL;
	PSSRC_ENTRY			pSSRCentry = NULL;
	DWORD				dwStatus   = RRCM_NoError;
	DWORD				startRtcp  = FALSE;
	char				hName[256];
	int					tmpSize;
	struct sockaddr_in	*pSockAddr;

	IN_OUT_STR ("RTCP: Enter CreateRTCPSession()\n");

	// set status
	*pRTCPstatus = RRCM_NoError;

	// allocate all required resources for the RTCP session
	dwStatus = allocateRTCPsessionResources (&pRTCPses,
											 &pSSRCentry);
	if (dwStatus != RRCM_NoError)
		{
		RRCM_DBG_MSG ("RTCP: ERROR - Resource allocation failed", 0,
					  __FILE__, __LINE__, DBG_CRITICAL);

		IN_OUT_STR ("RTCP: Exit CreateRTCPSession()\n");

		*pRTCPstatus = dwStatus;
		return (NULL);
		}

	// if this is the first session, create the RTCP thread, which
	// will be killed when no more sessions exist.
	if (pRTCPContext->RTCPSession.prev == NULL)
		{
		startRtcp = TRUE;
		}

	// save the parent RTCP session address in the SSRC entry
	pSSRCentry->pRTCPses = pRTCPses;

	// network destination address
	if (toLen)
		{
		pRTCPses->dwSessionStatus = RTCP_DEST_LEARNED;
		pRTCPses->toLen = toLen;
		memcpy (&pRTCPses->toBfr, lpTo, toLen);
		}
	
	// mark the session as new for the benefit of the RTCP thread
	pRTCPses->dwSessionStatus |= NEW_RTCP_SESSION;

#ifdef ENABLE_ISDM2
	// initialize the session key in case ISDM is used
	pRTCPses->hSessKey = NULL;
#endif

	// number of SSRC for this RTCP session
	pRTCPses->dwCurNumSSRCperSes = 1;
#ifdef MONITOR_STATS
	pRTCPses->dwHiNumSSRCperSes  = 1;
#endif

	// SSRC entry related information
    pSSRCentry->RTPsd  = RTPsd;
    pSSRCentry->RTCPsd = RTCPsd;

	// get our own transport address -
	// will be used for collision resolution when using multicast
	tmpSize = sizeof (SOCKADDR);
	dwStatus = RRCMws.getsockname (RTPsd, (PSOCKADDR)pSSRCentry->from, &tmpSize);

	// only process when no error is reported. If the socket is not bound
	// it won't cause any problem for unicast or multicast if the sender
	// has not join the mcast group. If the sender joins the mcast group
	// it's socket should be bound by now as specified in the EPS
	if (dwStatus == 0)
		{
		// if bound to INADDR_ANY, address will be 0
		pSockAddr = (PSOCKADDR_IN)&pSSRCentry->from;
		if (pSockAddr->sin_addr.s_addr == 0)
			{
			// get the host name (to get the local IP address)
			if ( ! RRCMws.gethostname (hName, sizeof(hName)))
				{
				LPHOSTENT	lpHEnt;

				// get the host by name infor
				if ((lpHEnt = RRCMws.gethostbyname (hName)) != NULL)
					{
					// get the local IP address
					pSockAddr->sin_addr.s_addr =
						*((u_long *)lpHEnt->h_addr_list[0]);
					}
				}
			}
		}

	// build session's SDES information
	buildSDESinfo (pSSRCentry, pSdesInfo);

	// link the SSRC to the RTCP session list of Xmt SSRCs entries
	addToHeadOfList (&(pRTCPses->XmtSSRCList),
					 (PLINK_LIST)pSSRCentry,
					 &pRTCPses->critSect);

	// initialize the number of stream for this session
    pRTCPses->dwNumStreamPerSes = 1;

	// get a unique SSRC for this session
	if (ssrc)
		pSSRCentry->SSRC = ssrc;
	else
		pSSRCentry->SSRC = getSSRC (pRTCPses->XmtSSRCList,
									pRTCPses->RcvSSRCList);

	// RRCM callback notification
	pRTCPses->pRRCMcallback		 = pRRCMcallback;
	pRTCPses->dwCallbackUserInfo = dwCallbackInfo;

	// set operation flag
	if (miscInfo & H323_CONFERENCE)
		pRTCPses->dwSessionStatus |= H323_CONFERENCE;
	if (miscInfo & ENCRYPT_SR_RR)
		pRTCPses->dwSessionStatus |= ENCRYPT_SR_RR;

	// estimate the initial session bandwidth
	if (dwRtpSessionBw == 0)
		{
		pSSRCentry->xmtInfo.dwRtcpStreamMinBW  = INITIAL_RTCP_BANDWIDTH;
		}
	else
		{
		// RTCP bandwidth is 5% of the RTP bandwidth
		pSSRCentry->xmtInfo.dwRtcpStreamMinBW  = (dwRtpSessionBw * 5) / 100;
		}

	// the stream clocking frequency
	pSSRCentry->dwStreamClock = dwStreamClock;

	// initialize 'dwLastReportRcvdTime' to now
	pSSRCentry->dwLastReportRcvdTime = timeGetTime();

#ifdef _DEBUG
	wsprintf(debug_string,
		"RTCP: Add new RTCP session: Addr:x%lX", pRTCPses);
	RRCM_DBG_MSG (debug_string, 0, NULL, 0, DBG_TRACE);

	wsprintf(debug_string,
		"RTCP: Add SSRC entry (Addr:x%lX, SSRC=x%lX) to session (Addr:x%lX)",
		pSSRCentry, pSSRCentry->SSRC, pRTCPses);
	RRCM_DBG_MSG (debug_string, 0, NULL, 0, DBG_TRACE);

	pSSRCentry->dwPrvTime = timeGetTime();
#endif

	// turn on RTCP or not
	if (miscInfo & RTCP_ON)
		{
		// this session sends and receives RTCP reports
		pRTCPses->dwSessionStatus |= RTCP_ON;
		}

	// link the RTCP session to the head of the list of RTCP sessions
	addToHeadOfList (&(pRTCPContext->RTCPSession),
					 (PLINK_LIST)pRTCPses,
					 &pRTCPContext->critSect);

#ifdef ENABLE_ISDM2
	// register to ISDM only if destination address is known
	if (Isdm2.hISDMdll && (pRTCPses->dwSessionStatus & RTCP_DEST_LEARNED))
		registerSessionToISDM (pSSRCentry, pRTCPses, &Isdm2);
#endif

	// create the RTCP thread if needed
	if (startRtcp == TRUE)
		{
		// No RTCP thread if this fail
		dwStatus = CreateRTCPthread ();
		if (dwStatus != RRCM_NoError)
			{
			RRCM_DBG_MSG ("RTCP: ERROR - Cannot create RTCP thread", 0,
						  __FILE__, __LINE__, DBG_CRITICAL);

			IN_OUT_STR ("RTCP: Exit CreateRTCPSession()\n");

			*pRTCPstatus = dwStatus;
			return (NULL);
			}
		}

	IN_OUT_STR ("RTCP: Exit CreateRTCPSession()\n");

	return (pRTCPses);
	}


/*----------------------------------------------------------------------------
 * Function   : allocateRTCPsessionResources
 * Description: Allocate all required resources for an RTCP session.
 *
 * Input :      *pRTCPses:		->(->) to the RTCP session's information
 *				*pSSRCentry:	->(->) to the SSRC's entry
 *
 * Return: 		OK: RRCM_NoError
 *         		!0: Error code (see RRCM.H)
 ---------------------------------------------------------------------------*/
 DWORD allocateRTCPsessionResources (PRTCP_SESSION *pRTCPses,
									 PSSRC_ENTRY *pSSRCentry)
	{
	DWORD dwStatus = RRCM_NoError;

	IN_OUT_STR ("RTCP: Enter allocateRTCPsessionResources()\n");

	// get an RTCP session
	*pRTCPses = (PRTCP_SESSION)HeapAlloc (pRTCPContext->hHeapRTCPSes,
										  HEAP_ZERO_MEMORY,
										  sizeof(RTCP_SESSION));
	if (*pRTCPses == NULL)
		dwStatus = RRCMError_RTCPResources;

	// 'defined' RTCP resources
	if (dwStatus == RRCM_NoError)
		{
		(*pRTCPses)->dwInitNumFreeRcvBfr = NUM_FREE_RCV_BFR;
		(*pRTCPses)->dwRcvBfrSize	  	 = pRTPContext->registry.RTCPrcvBfrSize;
		(*pRTCPses)->dwXmtBfrSize	  	 = RRCM_XMT_BFR_SIZE;

		// allocate the RTCP session's Rcv/Xmt heaps and Rcv/Xmt buffers
		dwStatus = allocateRTCPSessionHeaps (pRTCPses);
		}

	if (dwStatus == RRCM_NoError)
		{
		// initialize this session's critical section
		InitializeCriticalSection (&(*pRTCPses)->critSect);

		// allocate free list of RTCP receive buffers
		dwStatus = allocateRTCPBfrList (&(*pRTCPses)->RTCPrcvBfrList,
										(*pRTCPses)->hHeapRcvBfrList,
										(*pRTCPses)->hHeapRcvBfr,
										&(*pRTCPses)->dwInitNumFreeRcvBfr,
							 	 	    (*pRTCPses)->dwRcvBfrSize,
										&(*pRTCPses)->critSect);
		}

	if (dwStatus == RRCM_NoError)
		{
		(*pRTCPses)->XmtBfr.buf = (char *)LocalAlloc(0,(*pRTCPses)->dwXmtBfrSize);
		if ((*pRTCPses)->XmtBfr.buf == NULL)
			dwStatus = RRCMError_RTCPResources;
			
		}

	if (dwStatus == RRCM_NoError)
		{
		// get an SSRC entry
		*pSSRCentry = getOneSSRCentry (&pRTCPContext->RRCMFreeStat,
									   pRTCPContext->hHeapRRCMStat,
									   &pRTCPContext->dwInitNumFreeRRCMStat,
									   &pRTCPContext->critSect);
		if (*pSSRCentry == NULL)
			dwStatus = RRCMError_RTCPResources;
		}

	if (dwStatus == RRCM_NoError)
		{
		// manual-reset event that will be used to signal the end of the
		// RTCP session to all of the session's stream
		(*pRTCPses)->hShutdownDone = CreateEvent (NULL, TRUE, FALSE, NULL);

		if ((*pRTCPses)->hShutdownDone == NULL)
			{
			dwStatus = RRCMError_RTCPResources;

			RRCM_DBG_MSG ("RTCP: ERROR - CreateEvent()", GetLastError(),
						  __FILE__, __LINE__, DBG_ERROR);
			}
		}
	
	// any resource allocation problem ?
	if (dwStatus != RRCM_NoError)
		{
		if (*pSSRCentry)
			addToHeadOfList (&pRTCPContext->RRCMFreeStat,
							 (PLINK_LIST)*pSSRCentry,
							 &pRTCPContext->critSect);

		if ((*pSSRCentry)->hXmtThread)
			{
			if (TerminateThread ((*pSSRCentry)->hXmtThread,
								 (*pSSRCentry)->dwXmtThreadID) == FALSE)
				{
				RRCM_DBG_MSG ("RTCP: ERROR - TerminateThread()",
							  GetLastError(), __FILE__, __LINE__, DBG_ERROR);
				}
			}
	
		if (*pRTCPses)
			{
			if (HeapFree (pRTCPContext->hHeapRTCPSes, 0, *pRTCPses) == FALSE)
				{
				RRCM_DBG_MSG ("RTCP: ERROR - HeapFree()", GetLastError(),
							  __FILE__, __LINE__, DBG_ERROR);
				}
			}
		}

	IN_OUT_STR ("RTCP: Exit allocateRTCPsessionResources()\n");

	return dwStatus;
	}


/*----------------------------------------------------------------------------
 * Function   : buildSDESinfo
 * Description: Build the session's SDES information
 *
 * Input :      pRTCPses:	-> to session's
 *				pSdesInfo:	-> to SDES information
 *
 * Return: 		OK: RRCM_NoError
 *         		!0: Error code (see RRCM.H)
 ---------------------------------------------------------------------------*/
 DWORD buildSDESinfo (PSSRC_ENTRY pSSRCentry,
					  PSDES_DATA pSdesInfo)
	{
	PSDES_DATA	pTmpSdes;
	DWORD		CnameOK = FALSE;

	IN_OUT_STR ("RTCP: Enter buildSDESinfo()\n");

	pTmpSdes = pSdesInfo;

	while (pTmpSdes->dwSdesType)
		{
		switch (pTmpSdes->dwSdesType)
			{
			case RTCP_SDES_CNAME:
				pSSRCentry->cnameInfo.dwSdesLength = pTmpSdes->dwSdesLength;
				memcpy (pSSRCentry->cnameInfo.sdesBfr, pTmpSdes->sdesBfr,
						pTmpSdes->dwSdesLength);

				pSSRCentry->cnameInfo.dwSdesFrequency =
					frequencyToPckt (pTmpSdes->dwSdesFrequency);
				pSSRCentry->cnameInfo.dwSdesEncrypted = pTmpSdes->dwSdesEncrypted;

				CnameOK = TRUE;
				break;

			case RTCP_SDES_NAME:
				pSSRCentry->nameInfo.dwSdesLength  = pTmpSdes->dwSdesLength;
				memcpy (pSSRCentry->nameInfo.sdesBfr, pTmpSdes->sdesBfr,
						pTmpSdes->dwSdesLength);

				pSSRCentry->nameInfo.dwSdesFrequency =
					frequencyToPckt (pTmpSdes->dwSdesFrequency);
				pSSRCentry->nameInfo.dwSdesEncrypted = pTmpSdes->dwSdesEncrypted;
				break;

			case RTCP_SDES_EMAIL:
				pSSRCentry->emailInfo.dwSdesLength  = pTmpSdes->dwSdesLength;
				memcpy (pSSRCentry->emailInfo.sdesBfr, pTmpSdes->sdesBfr,
						pTmpSdes->dwSdesLength);

				pSSRCentry->emailInfo.dwSdesFrequency =
					frequencyToPckt (pTmpSdes->dwSdesFrequency);
				pSSRCentry->emailInfo.dwSdesEncrypted = pTmpSdes->dwSdesEncrypted;
				break;
			
			case RTCP_SDES_PHONE:
				pSSRCentry->phoneInfo.dwSdesLength  = pTmpSdes->dwSdesLength;
				memcpy (pSSRCentry->phoneInfo.sdesBfr, pTmpSdes->sdesBfr,
						pTmpSdes->dwSdesLength);

				pSSRCentry->phoneInfo.dwSdesFrequency =
					frequencyToPckt (pTmpSdes->dwSdesFrequency);
				pSSRCentry->phoneInfo.dwSdesEncrypted = pTmpSdes->dwSdesEncrypted;
				break;
			
			case RTCP_SDES_LOC:
				pSSRCentry->locInfo.dwSdesLength  = pTmpSdes->dwSdesLength;
				memcpy (pSSRCentry->locInfo.sdesBfr, pTmpSdes->sdesBfr,
						pTmpSdes->dwSdesLength);

				pSSRCentry->locInfo.dwSdesFrequency =
					frequencyToPckt (pTmpSdes->dwSdesFrequency);
				pSSRCentry->locInfo.dwSdesEncrypted = pTmpSdes->dwSdesEncrypted;
				break;
			
			case RTCP_SDES_TOOL:
				pSSRCentry->toolInfo.dwSdesLength  = pTmpSdes->dwSdesLength;
				memcpy (pSSRCentry->toolInfo.sdesBfr, pTmpSdes->sdesBfr,
						pTmpSdes->dwSdesLength);

				pSSRCentry->toolInfo.dwSdesFrequency =
					frequencyToPckt (pTmpSdes->dwSdesFrequency);
				pSSRCentry->toolInfo.dwSdesEncrypted = pTmpSdes->dwSdesEncrypted;
				break;
			
			case RTCP_SDES_TXT:
				pSSRCentry->txtInfo.dwSdesLength  = pTmpSdes->dwSdesLength;
				memcpy (pSSRCentry->txtInfo.sdesBfr, pTmpSdes->sdesBfr,
						pTmpSdes->dwSdesLength);

				pSSRCentry->txtInfo.dwSdesFrequency =
					frequencyToPckt (pTmpSdes->dwSdesFrequency);
				pSSRCentry->txtInfo.dwSdesEncrypted = pTmpSdes->dwSdesEncrypted;
				break;
			
			case RTCP_SDES_PRIV:
				pSSRCentry->privInfo.dwSdesLength  = pTmpSdes->dwSdesLength;
				memcpy (pSSRCentry->privInfo.sdesBfr, pTmpSdes->sdesBfr,
						pTmpSdes->dwSdesLength);

				pSSRCentry->privInfo.dwSdesFrequency =
					frequencyToPckt (pTmpSdes->dwSdesFrequency);
				pSSRCentry->privInfo.dwSdesEncrypted = pTmpSdes->dwSdesEncrypted;
				break;
			}

		pTmpSdes++;
		}

	// default CNAME if none provided
	if (CnameOK == FALSE)
		{
		pSSRCentry->cnameInfo.dwSdesLength = sizeof(szDfltCname);
		memcpy (pSSRCentry->cnameInfo.sdesBfr, szDfltCname,
				sizeof(szDfltCname));

		pSSRCentry->cnameInfo.dwSdesFrequency = 1;
		pSSRCentry->cnameInfo.dwSdesEncrypted = 0;
		}

	IN_OUT_STR ("RTCP: Exit buildSDESinfo()\n");
	return (RRCM_NoError);
	}


/*----------------------------------------------------------------------------
 * Function   : frequencyToPckt
 * Description: Transform the required frequency to a number of packet. (To
 *				be used by a modulo function)
 *
 * Input :      freq:	Desired frequency from 0 to 100
 *
 * Return: 		X: Packet to skip, ie, one out of X
 ---------------------------------------------------------------------------*/
 DWORD frequencyToPckt (DWORD freq)
	{
	if (freq <= 10)
		return 9;
	else if (freq <= 20)
		return 5;
	else if (freq <= 25)
		return 4;
	else if (freq <= 33)
		return 3;
	else if (freq <= 50)
		return 2;
	else
		return 1;
	}

	
/*----------------------------------------------------------------------------
 * Function   : deleteRTCPSession
 * Description: Closes an RTCP session.
 *
 * Input :      RTCPsd		: RTCP socket descriptor
 *				byeReason	: -> to the BYE reason
 *
 * Return: 		OK: RRCM_NoError
 *         		!0: Error code (see RRCM.H)
 ---------------------------------------------------------------------------*/
 DWORD deleteRTCPSession (SOCKET RTCPsd,
						  PCHAR byeReason)
	{
	PLINK_LIST		pTmp;
	PSSRC_ENTRY		pSSRC;
	PRTCP_SESSION	pRTCP;
	DWORD			dwStatus = RRCM_NoError;
	DWORD			sessionFound = FALSE;

	IN_OUT_STR ("RTCP: Enter deleteRTCPSEssion()\n");

	// walk through the list from the tail
	pTmp = pRTCPContext->RTCPSession.prev;

#ifdef _DEBUG
	wsprintf(debug_string,
		"RTCP: Deleting RTCP session: (Addr:x%lX) ...", pTmp);
	RRCM_DBG_MSG (debug_string, 0, NULL, 0, DBG_TRACE);
#endif

	while (pTmp)
		{
		// get the right session to close by walking the transmit list
		pSSRC = (PSSRC_ENTRY)((PRTCP_SESSION)pTmp)->XmtSSRCList.prev;
		if (pSSRC->RTCPsd == RTCPsd)
			{
			sessionFound = TRUE;

			// save a pointer to the RTCP session
			pRTCP = pSSRC->pRTCPses;

			// RTCP send BYE packet for this active stream
			RTCPsendBYE (pSSRC, NULL);

			// flush out any outstanding I/O
			RTCPflushIO (pSSRC);

			// if this is the only RTCP session left, terminate the RTCP
			// timeout thread, so it doesn't access the session when it expires
			if ((pRTCPContext->RTCPSession.prev)->next == NULL)
				terminateRtcpThread ();

			// lock out access to this RTCP session
			EnterCriticalSection (&pRTCP->critSect);

			// free all Rcv & Xmt SSRC entries used by this session
			deleteSSRClist (pRTCP,
							&pRTCPContext->RRCMFreeStat,
							pRTCPContext);

#ifdef ENABLE_ISDM2
			if (Isdm2.hISDMdll && pRTCP->hSessKey)
				Isdm2.ISDMEntry.ISD_DeleteKey(pRTCP->hSessKey);
#endif

			// release the RTCP session's heap
			if (pRTCP->hHeapRcvBfrList)
				{
				if (HeapDestroy (pRTCP->hHeapRcvBfrList) == FALSE)
					{
					RRCM_DBG_MSG ("RTCP: ERROR - HeapDestroy()",
								  GetLastError(), __FILE__, __LINE__,
								  DBG_ERROR);
					}
				}

	
			if (pRTCP->hHeapRcvBfr)
				{
				if (HeapDestroy (pRTCP->hHeapRcvBfr) == FALSE)
					{
					RRCM_DBG_MSG ("RTCP: ERROR - HeapDestroy()",
								  GetLastError(), __FILE__, __LINE__,
								  DBG_ERROR);
					}
				}


			if (pRTCP->XmtBfr.buf)
				LocalFree(pRTCP->XmtBfr.buf);
			// remove the entry from the list of RTCP session
			if (pTmp->next == NULL)
				removePcktFromHead (&pRTCPContext->RTCPSession,
									&pRTCPContext->critSect);
			else if (pTmp->prev == NULL)
				removePcktFromTail (&pRTCPContext->RTCPSession,
									&pRTCPContext->critSect);
			else
				{
				// in between, relink around
				(pTmp->prev)->next = pTmp->next;
				(pTmp->next)->prev = pTmp->prev;
				}

			// release the critical section
			LeaveCriticalSection (&pRTCP->critSect);
			DeleteCriticalSection (&pRTCP->critSect);

			// put the RTCP session back on its heap
			if (HeapFree (pRTCPContext->hHeapRTCPSes,
						  0,
						  pRTCP) == FALSE)
				{
				RRCM_DBG_MSG ("RTCP: ERROR - HeapFree()",
							  GetLastError(), __FILE__, __LINE__,
							  DBG_ERROR);
				}

			break;
			}

		pTmp = pTmp->next;
		}	
		
	if (sessionFound != TRUE)
		dwStatus = RRCMError_RTCPInvalidSession;

	IN_OUT_STR ("RTCP: Exit deleteRTCPSEssion()\n");

	return (dwStatus);
	}


/*----------------------------------------------------------------------------
 * Function   : CreateRTCPthread
 * Description: Create the RTCP thread / timeout thread depending on
 *				compilation flag.
 *
 * Input :      None.
 *
 * Return: 		None
 ---------------------------------------------------------------------------*/
 DWORD CreateRTCPthread (void)
	{
	DWORD dwStatus = RRCM_NoError;

	IN_OUT_STR ("RTCP: Enter CreateRTCPthread()\n");

	pRTCPContext->hTerminateRtcpEvent = CreateEvent (NULL, TRUE, FALSE, NULL);
	if (pRTCPContext->hTerminateRtcpEvent == NULL)
		{
		dwStatus = RRCMError_RTCPResources;

		RRCM_DBG_MSG ("RTCP: ERROR - CreateEvent()", GetLastError(),
					  __FILE__, __LINE__, DBG_ERROR);
		}

	pRTCPContext->hRtcpRptRequestEvent = CreateEvent (NULL, TRUE, FALSE, NULL);
	if (pRTCPContext->hRtcpRptRequestEvent == NULL)
		{
		dwStatus = RRCMError_RTCPResources;

		RRCM_DBG_MSG ("RTCP: ERROR - CreateEvent()", GetLastError(),
					  __FILE__, __LINE__, DBG_ERROR);
		}

	if (pRTCPContext->hTerminateRtcpEvent)
		{
		// create RTCP thread
		pRTCPContext->hRtcpThread = CreateThread (
											NULL,
											0,
											(LPTHREAD_START_ROUTINE)RTCPThread,
											pRTCPContext,
											0,
											&pRTCPContext->dwRtcpThreadID);

		if (pRTCPContext->hRtcpThread == FALSE)
			{
			dwStatus = RRCMError_RTCPThreadCreation;

			RRCM_DBG_MSG ("RTCP: ERROR - CreateThread()", GetLastError(),
						  __FILE__, __LINE__, DBG_ERROR);
			}
#ifdef _DEBUG
		else
			{
			wsprintf(debug_string,
				"RTCP: Create RTCP thread. Handle: x%lX - ID: x%lX",
				 pRTCPContext->hRtcpThread,
				 pRTCPContext->dwRtcpThreadID);
			RRCM_DBG_MSG (debug_string, 0, NULL, 0, DBG_TRACE);
			}
#endif
		}

	IN_OUT_STR ("RTCP: Exit CreateRTCPthread()\n");

	return dwStatus;
	}


/*----------------------------------------------------------------------------
 * Function   : terminateRtcpThread
 * Description: Terminate the RTCP thread.
 *
 * Input :      None.
 *
 * Return: 		None
 ---------------------------------------------------------------------------*/
 void terminateRtcpThread (void)
	{
	DWORD dwStatus;

	IN_OUT_STR ("RTCP: Enter terminateRtcpThread()\n");

	if (pRTCPContext->hRtcpThread)
		{
		// make sure the RTCP thread is running
		RTCPThreadCtrl (RTCP_ON);

		// signal the thread to terminate
		SetEvent (pRTCPContext->hTerminateRtcpEvent);

		// wait for the RTCP thread to be signaled
		dwStatus = WaitForSingleObject (pRTCPContext->hRtcpThread, 500);
		if (dwStatus == WAIT_OBJECT_0)
			;
		else if ((dwStatus == WAIT_TIMEOUT) || (dwStatus == WAIT_FAILED))
			{
			if (dwStatus == WAIT_TIMEOUT)
				{
				RRCM_DBG_MSG ("RTCP: Wait timed-out", GetLastError(),
							  __FILE__, __LINE__, DBG_ERROR);
				}
			else
				{
				RRCM_DBG_MSG ("RTCP: Wait failed", GetLastError(),
							  __FILE__, __LINE__, DBG_ERROR);
				}

			// Force ungraceful thread termination
			dwStatus = TerminateThread (pRTCPContext->hRtcpThread, 1);
			if (dwStatus == FALSE)
				{
				RRCM_DBG_MSG ("RTCP: ERROR - TerminateThread ()",
								GetLastError(), __FILE__, __LINE__,
								DBG_ERROR);
				}
			}

		// close the thread handle
		dwStatus = CloseHandle (pRTCPContext->hRtcpThread);
		if (dwStatus == TRUE)			
			pRTCPContext->hRtcpThread = 0;
		else
			{
			RRCM_DBG_MSG ("RTCP: ERROR - CloseHandle()", GetLastError(),
						  __FILE__, __LINE__, DBG_ERROR);
			}

		// close the event handle
		dwStatus = CloseHandle (pRTCPContext->hTerminateRtcpEvent);
		if (dwStatus == TRUE)
			pRTCPContext->hTerminateRtcpEvent = 0;
		else
			{
			RRCM_DBG_MSG ("RTCP: ERROR - CloseHandle()", GetLastError(),
						  __FILE__, __LINE__, DBG_ERROR);
			}

		// close the request handle
		dwStatus = CloseHandle (pRTCPContext->hRtcpRptRequestEvent);
		if (dwStatus == TRUE)
			pRTCPContext->hRtcpRptRequestEvent = 0;
		else
			{
			RRCM_DBG_MSG ("RTCP: ERROR - CloseHandle()", GetLastError(),
						  __FILE__, __LINE__, DBG_ERROR);
			}
		}

	IN_OUT_STR ("RTCP: Exit terminateRtcpThread()\n");
	}


/*----------------------------------------------------------------------------
 * Function   : RTCPflushIO
 * Description: Flush the receive queue.
 *
 * Input :      pSSRC:	-> to the SSRC entry
 *
 * Return: 		None
 ---------------------------------------------------------------------------*/
 DWORD RTCPflushIO (PSSRC_ENTRY pSSRC)
	{
	DWORD	dwStatus = RRCM_NoError;
	int		IoToFlush;
	int		waitForXmtTrials;

	IN_OUT_STR ("RTCP: Enter RTCPflushIO()\n");

	// set the flush flag
	EnterCriticalSection (&pSSRC->pRTCPses->critSect);
	pSSRC->pRTCPses->dwSessionStatus |= SHUTDOWN_IN_PROGRESS;
	LeaveCriticalSection (&pSSRC->pRTCPses->critSect);

	// check if need to flush or close the socket
	if (pSSRC->dwSSRCStatus & CLOSE_RTCP_SOCKET)
		{
		// get the number of outstanding buffers
		IoToFlush = pSSRC->pRTCPses->dwNumRcvIoPending;
#ifdef _DEBUG
			wsprintf(debug_string,
					 "RTCPflushIO: closing socket(%d) dwNumRcvIoPending (%d)",
					 pSSRC->RTCPsd, pSSRC->pRTCPses->dwNumRcvIoPending);
			RRCM_DBG_MSG (debug_string, 0, NULL, 0, DBG_TRACE);
#endif					

		// make sure it's not < 0
		if (IoToFlush < 0)
			IoToFlush = pRTPContext->registry.NumRTCPPostedBfr;

		dwStatus = RRCMws.closesocket (pSSRC->RTCPsd);
		if (dwStatus != 0)
			{
			RRCM_DBG_MSG ("RTCP: ERROR - closesocket ()", GetLastError(),
						  __FILE__, __LINE__, DBG_ERROR);
			}
		}
	else
		{
		IoToFlush = flushIO (pSSRC);
		}

	// wait for the receive side to flush it's pending I/Os
	if ((pSSRC->pRTCPses->dwSessionStatus & RTCP_ON) && IoToFlush)
		{
		// wait until the receiver signalled that the shutdown is done
		dwStatus = WaitForSingleObject (pSSRC->pRTCPses->hShutdownDone, 2000);
		if (dwStatus == WAIT_OBJECT_0)
			;
		else if (dwStatus == WAIT_TIMEOUT)
			{
			RRCM_DBG_MSG ("RTCP: Flush Wait timed-out", 0,
						  __FILE__, __LINE__, DBG_ERROR);
			}
		else if (dwStatus == WAIT_FAILED)
			{
			RRCM_DBG_MSG ("RTCP: Flush Wait failed", GetLastError(),
						  __FILE__, __LINE__, DBG_ERROR);
			}
		}

	// make sure there is no buffers in transit on the transmit side
	waitForXmtTrials = 3;
	while (waitForXmtTrials--)
		{
		if (pSSRC->dwNumXmtIoPending == 0)
			break;

		RRCM_DBG_MSG ("RTCP: Xmt I/O Pending - Waiting",
						0, NULL, 0, DBG_TRACE);

		// wait in an alertable wait-state
		SleepEx (200, TRUE);
		}
	
	// close the shutdown handle
	dwStatus = CloseHandle (pSSRC->pRTCPses->hShutdownDone);
	if (dwStatus == TRUE)			
		 pSSRC->pRTCPses->hShutdownDone = 0;
	else
		{
		RRCM_DBG_MSG ("RTCP: ERROR - CloseHandle()", GetLastError(),
					  __FILE__, __LINE__, DBG_ERROR);
		}

	IN_OUT_STR ("RTCP: Exit RTCPflushIO()\n");

	return (dwStatus);
	}


/*----------------------------------------------------------------------------
 * Function   : flushIO
 * Description: Flush the receive queue.
 *
 * Input :      pSSRC:	-> to the SSRC entry
 *
 * Return: 		None
 ---------------------------------------------------------------------------*/
 DWORD flushIO (PSSRC_ENTRY pSSRC)
	{
	SOCKET			tSocket;
	SOCKADDR_IN		tAddr;
	char			msg[16];
	WSABUF			msgBuf;
	DWORD			BytesSent;
	int				tmpSize;
	DWORD			dwStatus = RRCM_NoError;
	int				outstanding;
	int				IoToFlush;
	RTCP_COMMON_T	*pRTCPhdr;

	IN_OUT_STR ("RTCP: Enter flushIO()\n");

	// target socket
	tSocket = pSSRC->RTCPsd;

	// RTCP common header
	pRTCPhdr = (RTCP_COMMON_T *)msg;

	// RTP protocol version
	pRTCPhdr->type = RTP_TYPE;
	pRTCPhdr->pt   = FLUSH_RTP_PAYLOAD_TYPE;

	msgBuf.len = sizeof(msg);
	msgBuf.buf = msg;

	// get the address of the socket we are cleaning up
	tmpSize = sizeof(tAddr);
	if (RRCMws.getsockname (tSocket, (PSOCKADDR)&tAddr, &tmpSize))
		{
		dwStatus = GetLastError();
		RRCM_DBG_MSG ("RTCP: ERROR -  getsockname()",
					  dwStatus, __FILE__, __LINE__, DBG_ERROR);

		IN_OUT_STR ("RTP : Exit flushIO()\n");
		
        // (was: return dwStatus;)
        // Since this function is supposed to return number of pending I/O requests
        // to this socket, returning a non-zero error here is BOGUS!
        // Just return zero because if there is an error (socket has been freed)
        // then just say there's no i/o pending.
        return 0;
		}

	if (tAddr.sin_addr.s_addr == 0)
		{
		// send to the local address
		tAddr.sin_addr.S_un.S_un_b.s_b1 = 127;
		tAddr.sin_addr.S_un.S_un_b.s_b2 = 0;
		tAddr.sin_addr.S_un.S_un_b.s_b3 = 0;
		tAddr.sin_addr.S_un.S_un_b.s_b4 = 1;
		}

	// get the number of outstanding buffers
	outstanding = pSSRC->pRTCPses->dwNumRcvIoPending;

	// make sure it's not < 0
	if (outstanding < 0)
		outstanding = pRTPContext->registry.NumRTCPPostedBfr;

	// save number of pending I/Os
	IoToFlush = outstanding;

#if _DEBUG
	wsprintf(debug_string,
		 "RTCP: Flushing %d outstanding RCV buffers", outstanding);
	RRCM_DBG_MSG (debug_string, 0, NULL, 0, DBG_TRACE);
#endif

	// send datagrams to the RTCP socket
	while (outstanding--)
		{
#if (defined(_DEBUG) || defined(PCS_COMPLIANCE))
		if (RTPLogger)
			{
			//INTEROP
			InteropOutput (RTPLogger,
					       (BYTE FAR*)msgBuf.buf,
						   (int)msgBuf.len,
						   RTPLOG_SENT_PDU | RTCP_PDU);
			}
#endif

		dwStatus = RRCMws.sendTo (tSocket,
							      &msgBuf,
								  1,
								  &BytesSent,
								  0,
								  (SOCKADDR *)&tAddr,
								  sizeof(tAddr),
								  NULL,
#if 1
								  NULL);
#else
								  RTCPflushCallback);
#endif
		if (dwStatus == SOCKET_ERROR)
			{
			// If serious error, undo all our work
			dwStatus = GetLastError();

			if (dwStatus != WSA_IO_PENDING)
				{
				RRCM_DBG_MSG ("RTCP: ERROR - sendTo()", dwStatus,
							  __FILE__, __LINE__, DBG_ERROR);
				}
			}
		}

	IN_OUT_STR ("RTCP: Exit flushIO()\n");

	return IoToFlush;
	}



/*----------------------------------------------------------------------------
 * Function   : RTCPflushCallback
 * Description: Flush callback routine
 *
 * Input :	dwError:		I/O completion status
 *			cbTransferred:	Number of bytes received
 *			lpOverlapped:	-> to overlapped structure
 *			dwFlags:		Flags
 *
 *
 * Return: None
 ---------------------------------------------------------------------------*/
void CALLBACK RTCPflushCallback (DWORD dwError,
           			  		     DWORD cbTransferred,
           			  		     LPWSAOVERLAPPED lpOverlapped,
           			  		     DWORD dwFlags)
	{
	IN_OUT_STR ("RTCP: Enter RTCPflushCallback\n");

	// check Winsock callback error status
	if (dwError)
		{
		RRCM_DBG_MSG ("RTCP: ERROR - Rcv Callback", dwError,
					  __FILE__, __LINE__, DBG_ERROR);

		IN_OUT_STR ("RTCP: Exit RTCPflushCallback\n");
		return;
		}

	IN_OUT_STR ("RTCP: Exit RTCPflushCallback\n");
	}




// [EOF]


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\rrcm\rtp\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by rrcmver.rc
//
#define V_FILEFLAGS                     0

#define IDR_RTP                         101


// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\rrcm\rtp\queue.h ===
// generic queue class
// usage: 
// QueueOf<char *> charq;

#ifndef _QUEUE_H_
#define _QUEUE_H_

template <class T>
class QueueOf
{
public:
	QueueOf(): m_maxItems(8),m_iFirst(0),m_iLast(0)
	{
		// m_maxItems  is always a power of 2
		m_List = new T [m_maxItems];
	}

	// returns TRUE if the queue is empty and FALSE otherwise
	BOOL IsEmpty(void) { return (m_iLast == m_iFirst);}

	// add an element to the tail of the queue
	// makes a copy of the element
	BOOL Put(const T &itemT)
	{
		int inext;
		inext = (m_iLast+1)&(m_maxItems-1);
	
		if (inext == m_iFirst)
		{
			// too many items
			if (!Grow())
			{	

				return FALSE;
			}
			inext = (m_iLast+1)&(m_maxItems-1);
		}

		m_List[m_iLast] =  itemT;
		m_iLast = inext;

		return TRUE;
	}

	// get the first element in the queue
	BOOL Get(T *pT)
	{
		if (IsEmpty())
			return FALSE;	// nothing in queue
		else
		{
			if (pT)
				*pT = m_List[m_iFirst];
			m_iFirst = (m_iFirst+1)&(m_maxItems-1);
			return TRUE;
		}
	}
	// get the ith element in the queue without removing it
	BOOL Peek(T *pT, UINT pos=0)
	{
		if (pos >= GetCount())
			return FALSE;
		else
		{
			*pT = m_List[(m_iFirst+pos)&(m_maxItems-1)];
			return TRUE;
		}
	}

	// delete the ith element in the queue (this is not an efficient function!)
	BOOL Remove(UINT pos)
	{
		if (pos >= GetCount())
			return FALSE;
		else
		{
			int i1 = (m_iFirst+(int)pos)&(m_maxItems-1);
			int i2 = (i1+1)&(m_maxItems-1);
			// shift left to fill the gap
			for (; i2 != m_iLast; i1=i2,i2=(i2+1)&(m_maxItems-1))
			{
				m_List[i1] = m_List[i2];
			}
			m_iLast = i1;	// i1 = m_iLast-1
			return TRUE;
		}
			
	}
	
	// return the number of elements in the queue
	UINT GetCount(void)
	{
		return (m_iLast >= m_iFirst ? m_iLast-m_iFirst : m_iLast+m_maxItems-m_iFirst);
	}
	~QueueOf()
	{
		delete []m_List;
	}
private:
	BOOL Grow(void)
	{
		int i,j;
	// double the size of the queue array
		T* pNewList = new T [m_maxItems*2];
		if (!pNewList)
			return FALSE;
		for (i=0, j=m_iFirst; j != m_iLast; i++, j = ((++j)&(m_maxItems-1)))
		{
			pNewList[i] = m_List[j];
		}
		m_iFirst = 0;
		m_iLast = i;
		m_maxItems = m_maxItems*2;
		delete [] m_List;
		m_List = pNewList;
		return TRUE;
	}
	int m_maxItems;
	int m_iFirst;
	int m_iLast;
	T *m_List;
};
;
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\rrcm\rtp\rrcmmain.cpp ===
//---------------------------------------------------------------------------
//  File:  RRCMMAIN.C
//
//  This file contains the DLL's entry and exit points.
//
// INTEL Corporation Proprietary Information
// This listing is supplied under the terms of a license agreement with 
// Intel Corporation and may not be copied nor disclosed except in 
// accordance with the terms of that agreement.
// Copyright (c) 1995 Intel Corporation. 
//---------------------------------------------------------------------------

#ifndef STRICT
#define STRICT
#endif
#include "stdafx.h"
#include "windows.h"
#include <confdbg.h>
#include <memtrack.h>
// Note: Proxy/Stub Information
//		To build a separate proxy/stub DLL, 
//		run nmake -f mpps.mk in the project directory.

#include "resource.h"
#include "initguid.h"
#include "irtp.h"

#include "irtp_i.c"
//#include <cmmstrm.h>
#include "RTPSess.h"
#include "thread.h"



CComModule _Module;
CRITICAL_SECTION g_CritSect;

BEGIN_OBJECT_MAP(ObjectMap)
	OBJECT_ENTRY(CLSID_RTP, CRTP)
END_OBJECT_MAP()

#if (defined(_DEBUG) || defined(PCS_COMPLIANCE))
//INTEROP
#include "interop.h"
#include "rtpplog.h"
#endif

#ifdef ISRDBG
#include "isrg.h"
WORD    ghISRInst = 0;
#endif

#if (defined(_DEBUG) || defined(PCS_COMPLIANCE))
//INTEROP
LPInteropLogger            RTPLogger;
#endif


#if defined(__cplusplus)
extern "C"
{
#endif  // (__cplusplus)

extern DWORD deleteRTP (HINSTANCE);
extern DWORD initRTP (HINSTANCE);

#if defined(__cplusplus)
}
#endif  // (__cplusplus)

#ifdef _DEBUG
HDBGZONE  ghDbgZoneRRCM = NULL;
static PTCHAR _rgZones[] = {
	TEXT("RRCM"),
	TEXT("Trace"),
	TEXT("Error"),
};

#endif /* DEBUG */


//---------------------------------------------------------------------------
// Function: dllmain
//
// Description: DLL entry/exit points.
//
//	Inputs:
//    			hInstDll	: DLL instance.
//    			fdwReason	: Reason the main function is called.
//    			lpReserved	: Reserved.
//
//	Return: 	TRUE		: OK
//				FALSE		: Error, DLL won't load
//---------------------------------------------------------------------------
BOOL WINAPI DllMain (HINSTANCE hInstDll, DWORD fdwReason, LPVOID lpvReserved)
{
BOOL	status = TRUE;

switch (fdwReason)
	{
	case DLL_PROCESS_ATTACH:
		// The DLL is being loaded for the first time by a given process.
		// Perform per-process initialization here.  If the initialization
		// is successful, return TRUE; if unsuccessful, return FALSE.

#ifdef ISRDBG
		ISRREGISTERMODULE(&ghISRInst, "RRCM", "RTP/RTCP");
#endif

		DBGINIT(&ghDbgZoneRRCM, _rgZones);

        DBG_INIT_MEMORY_TRACKING(hInstDll);

#if (defined(_DEBUG) || defined(PCS_COMPLIANCE))
//INTEROP
		RTPLogger = InteropLoad(RTPLOG_PROTOCOL);
#endif

		_Module.Init(ObjectMap, hInstDll);
		DisableThreadLibraryCalls(hInstDll);
		//LogInit();
		InitializeCriticalSection(&g_CritSect);

		// initialize RTP/RTCP
		status = (initRTP (hInstDll) == FALSE) ? TRUE:FALSE;
		break;

	case DLL_PROCESS_DETACH:
		// The DLL is being unloaded by a given process.  Do any
		// per-process clean up here.The return value is ignored.
		// delete RTP resource
		deleteRTP (hInstDll);

		_Module.Term();
		//LogClose();
		DeleteCriticalSection(&g_CritSect);

#if (defined(_DEBUG) || defined(PCS_COMPLIANCE))
//INTEROP
		if (RTPLogger)
			InteropUnload(RTPLogger);
#endif
        DBG_CHECK_MEMORY_TRACKING(hInstDll);
		DBGDEINIT(&ghDbgZoneRRCM);
		break;

    case DLL_THREAD_ATTACH:
		// A thread is being created in a process that has already loaded
		// this DLL.  Perform any per-thread initialization here.
		break;

    case DLL_THREAD_DETACH:
		// A thread is exiting cleanly in a process that has already
		// loaded this DLL.  Perform any per-thread clean up here.
		break;
	}

return (status);  
}



/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
	return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
	return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
	// registers object, typelib and all interfaces in typelib
	return _Module.RegisterServer(FALSE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
	_Module.UnregisterServer();
	return S_OK;
}




// [EOF]
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\rrcm\rtcp\rtcpthrd.cpp ===
/*----------------------------------------------------------------------------
 * File:        RTCPIO.C
 * Product:     RTP/RTCP implementation
 * Description: Provides the RTCP network I/O.
 *
 * INTEL Corporation Proprietary Information
 * This listing is supplied under the terms of a license agreement with
 * Intel Corporation and may not be copied nor disclosed except in
 * accordance with the terms of that agreement.
 * Copyright (c) 1995 Intel Corporation.
 *--------------------------------------------------------------------------*/

#include "rrcm.h"



/*---------------------------------------------------------------------------
/							External Variables
/--------------------------------------------------------------------------*/
extern PRTCP_CONTEXT	pRTCPContext;
extern RRCM_WS			RRCMws;

#ifdef _DEBUG
extern char		debug_string[];
#endif

#if (defined(_DEBUG) || defined(PCS_COMPLIANCE))
//INTEROP
extern LPInteropLogger RTPLogger;
#endif



/*----------------------------------------------------------------------------
 * Function   : RTCPThread
 * Description: RTCP thread
 *
 * Input :      pRTCPctxt:	-> to RTCP context
 *
 * Return: 		None.
 ---------------------------------------------------------------------------*/
void RTCPThread (PRTCP_CONTEXT pRTCPctxt)
	{
	PSSRC_ENTRY			pSSRC;
	PSSRC_ENTRY			pRecvSSRC;
	PRTCP_SESSION		pRTCP;
	long				timerPeriod;
	long				minTimeInterval;
	long				prvTimeoutChkTime = 0;
	DWORD				initTime;
	long				deltaTime;
	int					dwStatus;
	DWORD				curTime;
	DWORD				dwNumBytesXfr;
	HANDLE				bfrHandle[2];
	DWORD				dwHandleCnt;

	RRCM_DBG_MSG ("RTCP: RTCP thread running ...", 0, NULL, 0, DBG_NOTIFY);

	// setup buffer Events
	bfrHandle[0] = pRTCPctxt->hTerminateRtcpEvent;
	bfrHandle[1] = pRTCPctxt->hRtcpRptRequestEvent;
	dwHandleCnt  = 2;

	// loop as long as there are sessions in the RTCP session list
	//
	while (1)
		{
		//LOOK: Claim global critical section?
		// walk through the RTCP session list from the tail and check which
		//  SSRC entry timed out if any
		curTime = timeGetTime();
		minTimeInterval = TIMEOUT_CHK_FREQ;		// 30 seconds

		for (pRTCP = (PRTCP_SESSION)pRTCPctxt->RTCPSession.prev;
			 pRTCP;
			 pRTCP = (PRTCP_SESSION)(pRTCP->RTCPList.next))
			{
			// if RTCP is disabled or shutdown is in progress, ignore
			// this session and move on.
			if (!(pRTCP->dwSessionStatus & RTCP_ON)
				|| (pRTCP->dwSessionStatus & SHUTDOWN_IN_PROGRESS))
				continue;
				
			// lock out access to this RTCP session
			EnterCriticalSection (&pRTCP->critSect);

			// NOTE: this assumes only one SSRC in the transmit list but
			// that assumption has been made elsewhere too
			pSSRC = (PSSRC_ENTRY)pRTCP->XmtSSRCList.prev;

			// if its a new session, post RECVs
			if (pRTCP->dwSessionStatus & NEW_RTCP_SESSION)
				{
				// post RTCP receive buffers
				dwStatus = RTCPrcvInit(pSSRC);
#ifdef _DEBUG
				if (dwStatus == FALSE)
					{
					RRCM_DBG_MSG ("RTCP: Couldn't initialize RTCP receive", 0,
								  __FILE__, __LINE__, DBG_TRACE);
					}
#endif
				// get initial transmit time
				timerPeriod = (long)RTCPxmitInterval (1, 0,
									  pSSRC->xmtInfo.dwRtcpStreamMinBW,
					 				  0, 100,
									  &pRTCP->avgRTCPpktSizeRcvd,
					 				  1);
					 				
				pSSRC->dwNextReportSendTime = curTime + timerPeriod;
				pRTCP->dwSessionStatus &= ~NEW_RTCP_SESSION;
				}

			// check if it has any expired SSRCs
			if ((curTime - prvTimeoutChkTime) > TIMEOUT_CHK_FREQ)
				{
				while (pRecvSSRC = SSRCTimeoutCheck (pRTCP, curTime))
					{
					// notify application if interested
					// NOTE: may be do this outside the loop?
					RRCMnotification (RRCM_TIMEOUT_EVENT, pRecvSSRC,
									  pRecvSSRC->SSRC, 0);

					// remove this entry from the list
					deleteSSRCEntry (pRecvSSRC->SSRC, pRTCP);
					}

				prvTimeoutChkTime = curTime;
				}
			
			if ( ! (pRTCP->dwSessionStatus & RTCP_DEST_LEARNED))
				{
				// cant send yet because we dont know who to
				// send to. Delay for 3 seconds
				pSSRC->dwNextReportSendTime = curTime + 3000;
				}

			//  if its time to send RTCP reports on this session
			//  then break out of the loop and send it  (cannot
			//  send with the global critsect held)
			//
			timerPeriod = (pSSRC->dwNextReportSendTime - curTime);
			if (timerPeriod <= RTCP_TIMEOUT_WITHIN_RANGE
				&& FormatRTCPReport(pRTCP, pSSRC, curTime))
				{
				// increment Xmt count in anticipation. This will prevent
				// the session from being deleted while the send is in progress.
				InterlockedIncrement ((long *)&pSSRC->dwNumXmtIoPending);
				InterlockedIncrement ((long *)&pSSRC->dwNumRptSent);
					
				LeaveCriticalSection(&pRTCP->critSect);
				break;
				}

			// if not then check how long before the next scheduled
			// transmission and save the minimum. We will sleep
			// for this much time and then start again.
			if (minTimeInterval > timerPeriod)
				minTimeInterval = timerPeriod;

			LeaveCriticalSection(&pRTCP->critSect);
			}
			
		if (pRTCP)
			{
			
			
#if (defined(_DEBUG) || defined(PCS_COMPLIANCE))
			if (RTPLogger)
				{
			   //INTEROP
				InteropOutput (RTPLogger,
							   (BYTE FAR*)(pRTCP->XmtBfr.buf),
							   (int)pRTCP->XmtBfr.len,
							   RTPLOG_SENT_PDU | RTCP_PDU);
				}
#endif

			// send the RTCP packet
			dwStatus = RRCMws.sendTo (pSSRC->RTCPsd,
				   					  &pRTCP->XmtBfr,
									  1,
					   				  &dwNumBytesXfr,
					   				  0,
				   					  (PSOCKADDR)pRTCP->toBfr,
				    				  pRTCP->toLen,
				   					  NULL,
					   				  NULL);

			// check SendTo status
			if (dwStatus == SOCKET_ERROR)
				{
				RRCM_DBG_MSG ("RTCP: ERROR - WSASendTo()", dwStatus,
							  __FILE__, __LINE__, DBG_ERROR);


                //If dwStatus is WSAENOTSOCK (or worse, a fault)
                //We're likely shutting down, and the RTCP session
                //is going away, don't touch it and let the normal
                //shutdown code take over
                if (dwStatus != WSAENOTSOCK && dwStatus != WSAEFAULT) {

                    // notify application if interested
                    RRCMnotification (RRCM_RTCP_WS_XMT_ERROR, pSSRC,
								  pSSRC->SSRC, dwStatus);

					InterlockedDecrement ((long *)&pSSRC->dwNumRptSent);
                }

				}
			InterlockedDecrement ((long *)&pSSRC->dwNumXmtIoPending);

			// run through the session list again
			continue;
			}

		// grab an initial timestamp so we can reset WaitForSingleObjectEx
		initTime = timeGetTime();

		// now we've gone through all the RTCP sessions and
		// verified that none have pending reports to be sent
		// We also know the earliest scheduled timeout so
		// lets sleep till then.
		while (1)
			{
				dwStatus = WaitForMultipleObjectsEx (dwHandleCnt,
													bfrHandle,
													FALSE,
												    (DWORD)minTimeInterval,
												    TRUE);
			if (dwStatus == WAIT_OBJECT_0)
				{
				// Exit event was signalled
#ifdef _DEBUG
				wsprintf(debug_string,
					"RTCP: Exit RTCP thread - Handle: x%lX - ID: x%lX",
					 pRTCPctxt->hRtcpThread, pRTCPctxt->dwRtcpThreadID);
				RRCM_DBG_MSG (debug_string, 0, NULL, 0, DBG_TRACE);
#endif

				ExitThread (0);
				}
			else if (dwStatus == WAIT_OBJECT_0+1)
				{
				// the application requested a non-periodic control
				//   of the RTCP report frequency
				break;
				}
			else if (dwStatus == WAIT_IO_COMPLETION)
				{
				// decrement the timerPeriod so the WaitForSingleObjectEx
				// can continue but if we're less than 250 milliseconds from
				// the original timeout go ahead and call it close enough.
				curTime = timeGetTime();
				deltaTime = curTime - initTime;
				if (deltaTime < 0)
					break;
				else
					{
					if (minTimeInterval >
						  (deltaTime + (RTCP_TIMEOUT_WITHIN_RANGE * 2)))
						{
						minTimeInterval -= deltaTime;
						}
					else
						break;
					}
				}
			else if (dwStatus == WAIT_TIMEOUT)
				{
				// the expected completion status
				break;
				}
			else if (dwStatus == WAIT_FAILED)
				{
				RRCM_DBG_MSG ("RTCP: Wait() Error", GetLastError(),
							  __FILE__, __LINE__, DBG_ERROR);

				break;
				}
			}
		}
	}


/*----------------------------------------------------------------------------
 * Function   : RTCPThreadCtrl
 * Description: RTCP thread ON / OFF
 *
 * Input :      dwState:	ON / OFF
 *
 * Return: 		0 (success) / 0xFFFFFFFF (failure)
 ---------------------------------------------------------------------------*/
DWORD WINAPI RTCPThreadCtrl (DWORD dwState)
	{
	IN_OUT_STR ("RTCP : Enter RTCPThreadCtrl()\n");

	DWORD	dwStatus = RRCM_NoError;
	DWORD	dwSuspendCnt;
	DWORD	idx;

	if (pRTCPContext->hRtcpThread == 0)
		{
		IN_OUT_STR ("RTCP : Exit RTCPThreadCtrl()\n");

		return dwStatus;
		}

	if (dwState == RTCP_ON)
		{
		idx = MAXIMUM_SUSPEND_COUNT;

		while (idx--)
			{
			dwSuspendCnt = ResumeThread (pRTCPContext->hRtcpThread);

			if (dwSuspendCnt <= 1)
				{
				break;
				}
			else if (dwSuspendCnt == 0xFFFFFFFF)
				{
				dwStatus = RRCM_NoError;
				break;
				}
			}
		}
	else if (dwState == RTCP_OFF)
		{
		if (SuspendThread (pRTCPContext->hRtcpThread) == 0xFFFFFFFF)
			{
			RRCM_DBG_MSG ("RTCP: SuspendThread() Error", GetLastError(),
						  __FILE__, __LINE__, DBG_ERROR);
			}
		}

	IN_OUT_STR ("RTCP : Exit RTCPThreadCtrl()\n");

	return dwStatus;
	}


/*----------------------------------------------------------------------------
 * Function   : RTCPSendSessionCtrl
 * Description: Gives RTCP control to the application if the application
 *				desire to do so. The application is now responsible to comply
 *				with the RTP specification.
 *
 * Input :      hRtpSession:	Handle of the RTP session
 *				dwTimeout:		RTCP send message timeout
 *										0x0			-> RRCM control
 *										0x7FFFFFFF	-> RTCP xmt disabled
 *										value		-> selected timeout
 *														(periodic or not)
 *
 * Return: 		0 (success) / 0xFFFFFFFF (failure)
 ---------------------------------------------------------------------------*/
HRESULT WINAPI RTCPSendSessionCtrl (DWORD_PTR RTPSession,
									 DWORD dwTimeOut)
	{
	IN_OUT_STR ("RTCP : Enter RTCPSendSessionCtrl()\n");

	PRTP_SESSION    pSession;
	PSSRC_ENTRY		pSSRC;
	DWORD			dwStatus = RRCM_NoError;

	// Cast Session ID to obtain the session pointer.
	pSession = (PRTP_SESSION)RTPSession;
	if (pSession == NULL)
		{
		RRCM_DBG_MSG ("RTCP : ERROR - Invalid RTP session", 0,
					  __FILE__, __LINE__, DBG_ERROR);

		IN_OUT_STR ("RTP : Exit RTCPSendSessionCtrl()\n");

		return (MAKE_RRCM_ERROR (RRCMError_RTPSessResources));
		}

	// Get this RTP session's transmit SSRC
	pSSRC = (PSSRC_ENTRY)pSession->pRTCPSession->XmtSSRCList.prev;
	if (pSSRC == NULL)
		{
		RRCM_DBG_MSG ("RTP : ERROR - No SSRC entry on the Xmt list", 0,
					  __FILE__, __LINE__, DBG_ERROR);

		IN_OUT_STR ("RTCP : Exit RTCPSendSessionCtrl()\n");

		return (MAKE_RRCM_ERROR (RRCMError_RTCPInvalidSSRCentry));
		}

	// set the new RTCP control timeout value
	if (dwTimeOut == RRCM_CTRL_RTCP)
		pSSRC->dwSSRCStatus &= ~RTCP_XMT_USER_CTRL;
	else if (dwTimeOut & RTCP_ONE_SEND_ONLY)
		{
		pSSRC->dwNextReportSendTime = RTCP_TIMEOUT_WITHIN_RANGE;

		// report are then turned off
		pSSRC->dwUserXmtTimeoutCtrl = RTCP_XMT_OFF;

		// signal the thread to terminate
		SetEvent (pRTCPContext->hRtcpRptRequestEvent);
		}
	else
		{
		if (dwTimeOut < RTCP_XMT_MINTIME)
			dwTimeOut = RTCP_XMT_MINTIME;

		pSSRC->dwUserXmtTimeoutCtrl = dwTimeOut;

		pSSRC->dwSSRCStatus |= RTCP_XMT_USER_CTRL;
		}

	IN_OUT_STR ("RTCP : Exit RTCPSendSessionCtrl()\n");

	return dwStatus;
	}


// [EOF]
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\rrcm\rtp\rtpinit.cpp ===
/*----------------------------------------------------------------------------
 * File:        RTPINIT.C
 * Product:     RTP/RTCP implementation
 * Description: Provides initialization functions.
 *
 * INTEL Corporation Proprietary Information
 * This listing is supplied under the terms of a license agreement with 
 * Intel Corporation and may not be copied nor disclosed except in 
 * accordance with the terms of that agreement.
 * Copyright (c) 1995 Intel Corporation. 
 *--------------------------------------------------------------------------*/

		
#include "rrcm.h"
/*---------------------------------------------------------------------------
/							External Variables
/--------------------------------------------------------------------------*/



extern SOCKET PASCAL WS2EmulSocket(
    int af, int type,int protocol, LPWSAPROTOCOL_INFO ,GROUP,DWORD);
extern int PASCAL WS2EmulCloseSocket(SOCKET s);
extern int PASCAL WS2EmulSetSockOpt(SOCKET s, int level,int optname,const char FAR * optval,int optlen);
extern int PASCAL WS2EmulBind( SOCKET s, const struct sockaddr FAR * name, int namelen);
extern int PASCAL WS2EmulRecvFrom(
    SOCKET s,LPWSABUF , DWORD, LPDWORD, LPDWORD,struct sockaddr FAR *,   LPINT,
    LPWSAOVERLAPPED,LPWSAOVERLAPPED_COMPLETION_ROUTINE );
extern int PASCAL WS2EmulSendTo(
	SOCKET s,LPWSABUF, DWORD ,LPDWORD , DWORD , const struct sockaddr FAR *, int,
    LPWSAOVERLAPPED , LPWSAOVERLAPPED_COMPLETION_ROUTINE );
extern int PASCAL WS2EmulGetSockName(	SOCKET s, struct sockaddr * name, int * namelen );
extern int PASCAL WS2EmulHtonl( SOCKET s,u_long hostlong,u_long FAR * lpnetlong);
extern int PASCAL WS2EmulNtohl( SOCKET s,u_long ,u_long FAR * );
extern int PASCAL WS2EmulHtons( SOCKET s,u_short ,u_short FAR *);
extern int PASCAL WS2EmulNtohs( SOCKET s,u_short ,u_short FAR *);
extern int PASCAL WS2EmulGetHostName(char *name, int namelen);
extern struct hostent FAR * PASCAL WS2EmulGetHostByName(const char * name);
extern SOCKET PASCAL WS2EmulJoinLeaf(SOCKET s, const struct sockaddr FAR * name,int , LPWSABUF , LPWSABUF , LPQOS, LPQOS, DWORD dwFlags);
extern int PASCAL WS2EmulIoctl(SOCKET s, DWORD, LPVOID,DWORD cbInBuffer, LPVOID ,
	DWORD, LPDWORD lpcbBytesReturned,LPWSAOVERLAPPED, LPWSAOVERLAPPED_COMPLETION_ROUTINE);

extern void WS2EmulInit();

extern void WS2EmulTerminate();

/*---------------------------------------------------------------------------
/							Global Variables
/--------------------------------------------------------------------------*/            
PRTP_CONTEXT	pRTPContext = NULL;
RRCM_WS			RRCMws = 
	{
		NULL,		// hWSdll
		WS2EmulSendTo,
		WS2EmulRecvFrom,
		WS2EmulNtohl,
		WS2EmulNtohs,
		WS2EmulHtonl,
		WS2EmulHtons,
		WS2EmulGetSockName,
		WS2EmulGetHostName,
		WS2EmulGetHostByName,
		WS2EmulCloseSocket,
		WS2EmulSocket,
		WS2EmulBind,
		NULL,		//WSAEnumProtocols
		WS2EmulJoinLeaf,		//WSAJoinLeaf
		WS2EmulIoctl,		//WSAIoctl
		WS2EmulSetSockOpt
	};				

DWORD g_fDisableWinsock2 = 0;

#ifdef ENABLE_ISDM2
KEY_HANDLE		hRRCMRootKey;
ISDM2			Isdm2;
#endif

#ifdef _DEBUG
char			debug_string[DBG_STRING_LEN];
#endif

#ifdef UNICODE
static const char szWSASocket[] = "WSASocketW";
static const char szWSAEnumProtocols[] = "WSAEnumProtocolsW";
#else
static const char szWSASocket[] = "WSASocketA";
static const char szWSAEnumProtocols[] = "WSAEnumProtocolsA";
#endif





/*----------------------------------------------------------------------------
 * Function   : initRTP
 * Description: Initializes the RTP task.
 * 
 * Input : hInst:	Handle to the DLL instance
 *
 * Return: RRCM_NoError		= OK.
 *         Otherwise(!=0)	= Initialization Error (see RRCM.H).
 ---------------------------------------------------------------------------*/
DWORD initRTP (HINSTANCE hInst)
	{
	DWORD	dwStatus;
	DWORD	hashTableEntries = NUM_RTP_HASH_SESS;

	IN_OUT_STR ("RTP : Enter initRTP()\n");

	// If RTP has already been initialized, stop, report the error and return
	if (pRTPContext != NULL) 
		{
		RRCM_DBG_MSG ("RTP : ERROR - Multiple RTP Instances", 0, 
				      __FILE__, __LINE__, DBG_CRITICAL);
		IN_OUT_STR ("RTP : Exit initRTP()\n");

		return (MAKE_RRCM_ERROR(RRCMError_RTPReInit));
		}

	// Obtain our context
	pRTPContext = (PRTP_CONTEXT)GlobalAlloc (GMEM_FIXED | GMEM_ZEROINIT,
											 sizeof(RTP_CONTEXT));

	// if no resources, exit with appropriate error
	if (pRTPContext == NULL) 
		{
		RRCM_DBG_MSG ("RTP : ERROR - Resource allocation failed", 0, 
					  __FILE__, __LINE__, DBG_CRITICAL);
		IN_OUT_STR ("RTP : Exit initRTP()\n");

		return (MAKE_RRCM_ERROR(RRCMError_RTPResources));
		}

	// Get information from the registry if any present
	RRCMreadRegistry (pRTPContext);

	// Perform dynamic linking of what we need
	if ((dwStatus = RRCMgetDynamicLink ()) != RRCM_NoError)
		{
		GlobalFree(pRTPContext);
		pRTPContext = NULL;

		RRCM_DBG_MSG ("RTP : ERROR - Winsock library not found", 0, 
					  __FILE__, __LINE__, DBG_CRITICAL);
		IN_OUT_STR ("RTP : Exit initRTP()\n");

		return MAKE_RRCM_ERROR(dwStatus);
		}

	// Initialize RTP context critical section
	InitializeCriticalSection(&pRTPContext->critSect);

	//Initialize WS2Emulation critical section
	WS2EmulInit();

	// Create RTCP and look at return value.  If error, don't proceed 
	// any further.  Pass this error to the calling function
	if ((dwStatus = initRTCP()) == RRCM_NoError) 
		{
		// RTCP is up.  We need to initialize our context
		pRTPContext->hInst = hInst;
		pRTPContext->pRTPSession.next = NULL;
		pRTPContext->pRTPSession.prev = NULL;

		}
			
	// if any part of initialation did not succeed, declare it all a failure
	//	and return all resourses allocated
	if (dwStatus != RRCM_NoError) 
		{
		if (pRTPContext) 
			{
	
			GlobalFree(pRTPContext);
			pRTPContext = NULL;
			}
		}

	IN_OUT_STR ("RTP : Exit initRTP()\n");

	if (dwStatus != RRCM_NoError)
		dwStatus = MAKE_RRCM_ERROR(dwStatus);

	return (dwStatus);
	}


/*----------------------------------------------------------------------------
 * Function   : deleteRTP
 * Description: Deletes RTP. Closes all RTP and RTCP sessions and releases all
 *				resources.
 * 
 * Input : hInst:	 Handle to the DLL instance.
 *
 * Return: RRCM_NoError		= OK.
 *         Otherwise(!=0)	= Initialization Error (see RRCM.H).
 ---------------------------------------------------------------------------*/
DWORD deleteRTP (HINSTANCE hInst)
	{
	DWORD			dwStatus;
	PRTP_SESSION	pDeleteSession;

#ifdef ENABLE_ISDM2
	HRESULT			hError;
#endif

	IN_OUT_STR ("RTP : Enter deleteRTP()\n");

	// If RTP context doesn't exist, report error and return.
	if (pRTPContext == NULL) 
		{
		RRCM_DBG_MSG ("RTP : ERROR - No RTP instance", 0, 
						__FILE__, __LINE__, DBG_ERROR);
		IN_OUT_STR ("RTP : Exit deleteRTP()\n");

		return (MAKE_RRCM_ERROR(RRCMError_RTPInvalidDelete));
		}

	if (pRTPContext->hInst != hInst) 
		{
		RRCM_DBG_MSG ("RTP : ERROR - Invalid DLL instance handle", 0, 
					  __FILE__, __LINE__, DBG_ERROR);
		IN_OUT_STR ("RTP : Exit deleteRTP()\n");

		return (MAKE_RRCM_ERROR(RRCMError_RTPNoContext));
		}

	// If we still have sessions open, clean them up
	while ((pDeleteSession = 
			(PRTP_SESSION)pRTPContext->pRTPSession.prev) != NULL) 
		{
		RRCM_DBG_MSG ("RTP : ERROR - Session x still open at DLL exit", 0, 
					  __FILE__, __LINE__, DBG_ERROR);
		ASSERT(0);
		//Close all open sessions
		CloseRTPSession (pDeleteSession, NULL, FALSE);
		}

	// Call RTCP to terminate and cleanup
	dwStatus = deleteRTCP();
		
#ifdef ENABLE_ISDM2
	// Query ISDM key
	if (Isdm2.hISDMdll)
		{
		DWORD dwKeys = 0;
		DWORD dwValues = 0;

		if (SUCCEEDED (Isdm2.ISDMEntry.ISD_QueryInfoKey (hRRCMRootKey, 
														 NULL, NULL, 
														 &dwKeys, &dwValues)))
			{
			if (!dwKeys && !dwValues)
				{
				hError = Isdm2.ISDMEntry.ISD_DeleteKey(hRRCMRootKey);
				if(FAILED(hError))
					RRCM_DBG_MSG ("RTP: ISD_DeleteKey failed", 0,
									NULL, 0, DBG_NOTIFY);
				}
			}

		DeleteCriticalSection (&Isdm2.critSect);

		if (FreeLibrary (Isdm2.hISDMdll) == FALSE)
			{
			RRCM_DBG_MSG ("RTP : ERROR - Freeing WS Lib", GetLastError(), 
						  __FILE__, __LINE__, DBG_ERROR);
			}
		}
#endif

	// unload the WS library
	if (RRCMws.hWSdll)
		{
		if (FreeLibrary (RRCMws.hWSdll) == FALSE)
			{
			RRCM_DBG_MSG ("RTP : ERROR - Freeing WS Lib", GetLastError(), 
						  __FILE__, __LINE__, DBG_ERROR);
			}
		}

	// delete RTP context critical section
	DeleteCriticalSection(&pRTPContext->critSect);

	// delete WS2 Emulation
	WS2EmulTerminate();
	
	// delete RTP context
	GlobalFree(pRTPContext);
	pRTPContext = NULL;

	IN_OUT_STR ("RTP : Exit deleteRTP()\n");

	if (dwStatus != RRCM_NoError)
		dwStatus = MAKE_RRCM_ERROR(dwStatus);

	return (dwStatus);
	}


/*----------------------------------------------------------------------------
 * Function   : RRCMreadRegistry
 * Description: Access the registry
 * 
 * Input : pCtxt:	-> to the RTP context
 *
 * Return: None
 ---------------------------------------------------------------------------*/
void RRCMreadRegistry (PRTP_CONTEXT	pCtxt)
	{
	HKEY	hKey;
	long	lRes;
	char	keyBfr[50];

	// open the key
	strcpy (keyBfr, szRegRRCMKey);

	// INTEL key vs MICROSOFT KEY
#ifndef INTEL
	strcat (keyBfr, szRegRRCMSubKey);
#else
	strcat (keyBfr, szRegRRCMSubKeyIntel);
#endif
	lRes = RegOpenKeyEx (HKEY_LOCAL_MACHINE,
						 keyBfr,	
						 0, 
						 KEY_READ,
						 &hKey);
	if (lRes || !hKey)
		{
		// key not found, setup default values
		pCtxt->registry.NumSessions      = NUM_RRCM_SESS;
		pCtxt->registry.NumFreeSSRC      = NUM_FREE_SSRC;
		pCtxt->registry.NumRTCPPostedBfr = NUM_RCV_BFR_POSTED;
		pCtxt->registry.RTCPrcvBfrSize   = RRCM_RCV_BFR_SIZE;
		return;
		}

	// get the number of RRCM sessions
	RRCMgetRegistryValue (hKey, szRegRRCMNumSessions, 
				          &pCtxt->registry.NumSessions, 
						  REG_DWORD, sizeof(DWORD));
	// check range
	if (pCtxt->registry.NumSessions < MIN_NUM_RRCM_SESS)
		pCtxt->registry.NumSessions = MIN_NUM_RRCM_SESS;
	else if (pCtxt->registry.NumSessions > MAX_NUM_RRCM_SESS)
		pCtxt->registry.NumSessions = MAX_NUM_RRCM_SESS;

	// get the number of initial free SSRC
	RRCMgetRegistryValue (hKey, szRegRRCMNumFreeSSRC,
					      &pCtxt->registry.NumFreeSSRC, 
						  REG_DWORD, sizeof(DWORD));

	// check range
	if (pCtxt->registry.NumFreeSSRC < MIN_NUM_FREE_SSRC)
		pCtxt->registry.NumFreeSSRC = MIN_NUM_FREE_SSRC;
	else if (pCtxt->registry.NumFreeSSRC > MAX_NUM_FREE_SSRC)
		pCtxt->registry.NumFreeSSRC = MAX_NUM_FREE_SSRC;

	// get the number of RTCP rcv buffers to be posted
	RRCMgetRegistryValue (hKey, szRegRRCMNumRTCPPostedBfr,
					      &pCtxt->registry.NumRTCPPostedBfr, 
						  REG_DWORD, sizeof(DWORD));

	// check range
	if (pCtxt->registry.NumRTCPPostedBfr < MIN_NUM_RCV_BFR_POSTED)
		pCtxt->registry.NumRTCPPostedBfr = MIN_NUM_RCV_BFR_POSTED;
	else if (pCtxt->registry.NumRTCPPostedBfr > MAX_NUM_RCV_BFR_POSTED)
		pCtxt->registry.NumRTCPPostedBfr = MAX_NUM_RCV_BFR_POSTED;

	// get the RTCP rcv buffer size
	RRCMgetRegistryValue (hKey, szRegRRCMRTCPrcvBfrSize,
					      &pCtxt->registry.RTCPrcvBfrSize, 
						  REG_DWORD, sizeof(DWORD));

	// check range
	if (pCtxt->registry.RTCPrcvBfrSize < MIN_RRCM_RCV_BFR_SIZE)
		pCtxt->registry.RTCPrcvBfrSize = MIN_RRCM_RCV_BFR_SIZE;
	else if (pCtxt->registry.RTCPrcvBfrSize > MAX_RRCM_RCV_BFR_SIZE)
		pCtxt->registry.RTCPrcvBfrSize = MAX_RRCM_RCV_BFR_SIZE;

	RRCMgetRegistryValue(hKey, "DisableWinsock2",
					      &g_fDisableWinsock2, 
						  REG_DWORD, sizeof(DWORD));

	// close the key
	RegCloseKey (hKey);
	}


/*----------------------------------------------------------------------------
 * Function   : RRCMgetRegistryValue
 * Description: Read a value from the registry
 * 
 * Input :		hKey	: Key handle
 *				pValStr	: -> to string value
 *				pKeyVal : -> to value
 *				type	: Type to read
 *				len		: Receiving buffer length
 *
 * Return:		None
 ---------------------------------------------------------------------------*/
void RRCMgetRegistryValue (HKEY hKey, LPTSTR pValStr, 
					       PDWORD pKeyVal, DWORD type, DWORD len)
	{
	DWORD	dwType = type;
	DWORD	retSize = len;

	// query the value
	RegQueryValueEx (hKey,
				     pValStr,
					 NULL,
					 &dwType,
					 (BYTE *)pKeyVal,
					 &retSize);
	}


/*----------------------------------------------------------------------------
 * Function   : RRCMgetDynamicLink
 * Description: Get all dynamic linked DLL entries
 * 
 * Input :		None
 *
 * Return:		None
 ---------------------------------------------------------------------------*/
DWORD RRCMgetDynamicLink (void)
	{
	HINSTANCE		hWSdll;

#ifdef ENABLE_ISDM2
	HRESULT			hError;

	Isdm2.hISDMdll = LoadLibrary(szISDMdll);

	// make sure the LoadLibrary call did not fail
	if (Isdm2.hISDMdll)
		{
		RRCM_DBG_MSG ("RTP: ISDM2 LoadLibrary worked", 0, NULL, 0, DBG_NOTIFY);
		// get the ISDM entry points used by RRCM
		Isdm2.ISDMEntry.ISD_CreateKey = 
			(ISD_CREATEKEY) GetProcAddress (Isdm2.hISDMdll, 
												   "ISD_CreateKey");

		Isdm2.ISDMEntry.ISD_CreateValue = 
			(ISD_CREATEVALUE) GetProcAddress (Isdm2.hISDMdll, "ISD_CreateValue");

		Isdm2.ISDMEntry.ISD_SetValue = 
			(ISD_SETVALUE) GetProcAddress (Isdm2.hISDMdll, "ISD_SetValue");

		Isdm2.ISDMEntry.ISD_DeleteValue = 
			(ISD_DELETEVALUE) GetProcAddress (Isdm2.hISDMdll, "ISD_DeleteValue");

		Isdm2.ISDMEntry.ISD_DeleteKey = 
			(ISD_DELETEKEY) GetProcAddress (Isdm2.hISDMdll, "ISD_DeleteKey");

		Isdm2.ISDMEntry.ISD_QueryInfoKey = 
			(ISD_QUERYINFOKEY) GetProcAddress (Isdm2.hISDMdll, "ISD_QueryInfoKey");

		// initialize critical section
		InitializeCriticalSection (&Isdm2.critSect);

		// make sure we have all of them
		if (Isdm2.ISDMEntry.ISD_CreateKey == NULL ||
			Isdm2.ISDMEntry.ISD_CreateValue == NULL ||
			Isdm2.ISDMEntry.ISD_SetValue == NULL ||
			Isdm2.ISDMEntry.ISD_DeleteValue == NULL ||
			Isdm2.ISDMEntry.ISD_DeleteKey == NULL ||
			Isdm2.ISDMEntry.ISD_QueryInfoKey == NULL )
			{
			Isdm2.hISDMdll = 0;
			RRCM_DBG_MSG ("RTP: Failed to load all ISDM2 functions",
							0, NULL, 0, DBG_NOTIFY);
			// delete critical section
			DeleteCriticalSection (&Isdm2.critSect);
			}
		else
			{
			hError = Isdm2.ISDMEntry.ISD_CreateKey(MAIN_ROOT_KEY, szRRCMISDM, &hRRCMRootKey);
			if(FAILED(hError))
				{
				RRCM_DBG_MSG ("RTP: ISD_CreateKey Failed",0, NULL, 0, DBG_NOTIFY);
				hRRCMRootKey = 0;
				}
			}
		}
#endif

	if (!g_fDisableWinsock2)
		{
		// load Winsock2 if present
		hWSdll = LoadLibrary(szRRCMdefaultLib);

		if (hWSdll)
			{
			RRCMws.hWSdll = hWSdll;

			RRCMws.sendTo = (LPFN_WSASENDTO)GetProcAddress (hWSdll, 
															  "WSASendTo");
			RRCMws.recvFrom = (LPFN_WSARECVFROM)GetProcAddress (hWSdll, 
															"WSARecvFrom");
			RRCMws.getsockname = (LPFN_GETSOCKNAME)GetProcAddress (hWSdll, 
															"getsockname");
			RRCMws.gethostname = (LPFN_GETHOSTNAME)GetProcAddress (hWSdll, 
															"gethostname");
			RRCMws.gethostbyname = (LPFN_GETHOSTBYNAME)GetProcAddress (hWSdll, 
															"gethostbyname");
			RRCMws.WSASocket = (LPFN_WSASOCKET)GetProcAddress (hWSdll, 
															szWSASocket);
			RRCMws.closesocket = (LPFN_CLOSESOCKET)GetProcAddress (hWSdll, 
																"closesocket");
			RRCMws.bind = (LPFN_BIND)GetProcAddress (hWSdll, 
																"bind");
		
			RRCMws.WSAEnumProtocols = (LPFN_WSAENUMPROTOCOLS) ::GetProcAddress(hWSdll, szWSAEnumProtocols);
			RRCMws.WSAIoctl = (LPFN_WSAIOCTL) ::GetProcAddress(hWSdll, "WSAIoctl");
			RRCMws.WSAJoinLeaf = (LPFN_WSAJOINLEAF) ::GetProcAddress(hWSdll, "WSAJoinLeaf");
			RRCMws.setsockopt = (LPFN_SETSOCKOPT) ::GetProcAddress(hWSdll, "setsockopt");
			RRCMws.ntohl = (LPFN_WSANTOHL)GetProcAddress (hWSdll, "WSANtohl");
			RRCMws.ntohs = (LPFN_WSANTOHS)GetProcAddress (hWSdll, "WSANtohs");
			RRCMws.htonl = (LPFN_WSAHTONL)GetProcAddress (hWSdll, "WSAHtonl");
			RRCMws.htons = (LPFN_WSAHTONS)GetProcAddress (hWSdll, "WSAHtons");
			
			if (RRCMws.WSAEnumProtocols)
			{
				int nProt = 0, i;
				int iProt[2];	// array of protocols we're interested in
				DWORD dwBufLength = sizeof(WSAPROTOCOL_INFO);
				LPWSAPROTOCOL_INFO pProtInfo = (LPWSAPROTOCOL_INFO) LocalAlloc(0,dwBufLength);

				iProt[0] = IPPROTO_UDP;
				iProt[1] = 0;
				// figure out the buffer size needed for WSAPROTOCOLINFO structs
				nProt = RRCMws.WSAEnumProtocols(iProt,pProtInfo,&dwBufLength);
				if (nProt < 0 && GetLastError() == WSAENOBUFS) {
					LocalFree(pProtInfo);
					pProtInfo = (LPWSAPROTOCOL_INFO) LocalAlloc(0,dwBufLength);
					if (pProtInfo)
						nProt = RRCMws.WSAEnumProtocols(iProt,pProtInfo,&dwBufLength);
				}

				if (nProt > 0) {
					for (i=0;i < nProt; i++) {
						if (pProtInfo[i].iProtocol == IPPROTO_UDP
							&& pProtInfo[i].iSocketType == SOCK_DGRAM
							&& ((pProtInfo[i].dwServiceFlags1 & XP1_QOS_SUPPORTED) || RRCMws.RTPProtInfo.iProtocol == 0)
							)
						{	// make a copy of the matching WSAPROTOCOL_INFO
							RRCMws.RTPProtInfo = pProtInfo[i];
							
							if (pProtInfo[i].dwServiceFlags1 & XP1_QOS_SUPPORTED)
							{
								RRCM_DBG_MSG ("QOS UDP provider found.\n", 0, 
		 		      			__FILE__, __LINE__, DBG_WARNING);
								break;
							}
							// else keep looking for a provider that supports QOS
						}
					}
				}
				if (pProtInfo)
					LocalFree(pProtInfo);

				if (RRCMws.RTPProtInfo.iProtocol == IPPROTO_UDP)
				{
					// we found the protocol(s) we wanted
					//RETAILMSG(("NAC: Using Winsock 2"));
				}
				else
				{
					FreeLibrary(RRCMws.hWSdll);
					RRCMws.hWSdll = NULL;
				}
			}
			}
		}
	// make sure we have the Xmt/Recv functionality
	if (RRCMws.sendTo == NULL || 
		RRCMws.recvFrom == NULL ||
		RRCMws.getsockname == NULL ||
		RRCMws.ntohl == NULL ||
		RRCMws.ntohs == NULL ||
		RRCMws.htonl == NULL ||
		RRCMws.htons == NULL ||
		RRCMws.gethostname == NULL ||
		RRCMws.gethostbyname == NULL ||
		RRCMws.WSASocket == NULL ||
		RRCMws.closesocket == NULL ||
		RRCMws.WSAIoctl == NULL ||
		RRCMws.WSAJoinLeaf == NULL 
		)
		{
		RRCM_DBG_MSG ("RTP : ERROR - Invalid Winsock DLL", 0, 
		 		      __FILE__, __LINE__, DBG_CRITICAL);

		return RRCMError_WinsockLibNotFound;
		}
	else
		return RRCM_NoError;
	}


// [EOF]
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\rrcm\rtcp\rtcptime.cpp ===
/*----------------------------------------------------------------------------
 * File:        RTCPTIME.C
 * Product:     RTP/RTCP implementation
 * Description: Provides timers related functions for RTCP.
 *
 * INTEL Corporation Proprietary Information
 * This listing is supplied under the terms of a license agreement with 
 * Intel Corporation and may not be copied nor disclosed except in 
 * accordance with the terms of that agreement.
 * Copyright (c) 1995 Intel Corporation. 
 *--------------------------------------------------------------------------*/


#include "rrcm.h"                                    


/*---------------------------------------------------------------------------
/							Global Variables
/--------------------------------------------------------------------------*/            


/*---------------------------------------------------------------------------
/							External Variables
/--------------------------------------------------------------------------*/  
extern PRTCP_CONTEXT	pRTCPContext;
#ifdef _DEBUG
extern char	debug_string[];
#endif




/*----------------------------------------------------------------------------
 * Function   : RTCPxmitInterval
 * Description: Calculate the RTCP transmission interval
 * 
 * Input :	members:	Estimated number of session members including 
 *						ourselves. On the initial call, should be 1.
 *
 *			senders:	Number of active senders since last report, known from
 *						construction of receiver reports for this packet. 
 *						Includes ourselves if we sent.
 *
 *			rtcpBw:		The target RTCP bandwidth, ie, the total Bw that will 
 *						be used by RTCP by all members of this session, in 
 *						bytes per seconds. Should be 5% of the session Bw.
 *
 *			weSent:		True if we've sent data during the last two RTCP 
 *						intervals. If TRUE, the compound RTCP packet just
 *						sent contained an SR packet.
 *
 *			packetSize:	Size of the RTCP packet just sent, in bytes, including
 *						network encapsulation, eg 28 bytes for UDP over IP.
 *
 *			*avgRtcpSize: Estimator to RTCP packet size, initialized and 
 *						 updated by this function for the packet just sent.
 *
 *			initial:	Initial transmission flag.
 *
 * Return: 		Interval time before the next transmission in msec.
 ---------------------------------------------------------------------------*/
DWORD RTCPxmitInterval (DWORD members, 
					    DWORD senders, 
						DWORD rtcpBw,
						DWORD weSent, 
						DWORD packetSize, 
						int *avgRtcpSize,
						DWORD initial)
	{
#ifdef ENABLE_FLOATING_POINT
//	// Minimum time between RTCP packets from this site in seconds. This time
//	// prevents the reports from clumping when sessions are small and the law
//	// of large numbers isn't helping to smooth out the traffic. It also keeps
//	// the report intervals from becoming ridiculously small during transient
//	// outages like a network partition.
//	double const RTCP_MinTime = 5.;
//
//	// Fraction of the RTCP bandwidth to be shared among active senders. This 
//	// fraction was chosen so that in a typical session with one or two active 
//	// senders, the computed report time would be roughly equal to the minimum
//	// report time so that we don't unnecessarily slow down receiver reports. 
//	// The receiver fraction must be 1 - the sender fraction.
//	double const RTCP_SenderBwFraction = 0.25;
//	double const RTCP_RcvrBwFraction   = (1 - RTCP_SenderBwFraction);
//
//	// Gain (smoothing constant) for the low-pass filter that estimates the 
//	// average RTCP packet size.
//	double const RTCP_sizeGain = RTCP_SIZE_GAIN;
//
//	// Interval 
//	double	t = 0;
//	double	rtcp_min_time = RTCP_MinTime;
//
//	// Number of member for computation 
//	unsigned int 	n;
//	int				tmpSize;
//
//	// Random number 
//	double	randNum;
//
//	// Very first call at application start-up uses half the min delay for 
//	// quicker notification while still allowing some time before reporting
//	// for randomization and to learn about other sources so the report
//	// interval will converge to the correct interval more quickly. The
//	// average RTCP size is initialized to 128 octects which is conservative.
//	// It assumes everyone else is generating SRs instead of RRs:
//	// 		20 IP + 8 UDP + 52 SR + 48 SDES CNAME
//	if (initial)
//		{
//		rtcp_min_time /= 2;
//		*avgRtcpSize = 128;
//		}
//
//	// If there were active senders, give them at least a minimum share of the 
//	// RTCP bandwidth. Otherwise all participants share the RTCP Bw equally.
//	n = members;
//	if (senders > 0 && (senders < (members * RTCP_SenderBwFraction)))
//		{
//		if (weSent)
//			{
//			rtcpBw *= RTCP_SenderBwFraction;
//			n = senders;
//			}
//		else
//			{
//			rtcpBw *= RTCP_RcvrBwFraction;
//			n -= senders;
//			}
//		}
//
//	// Update the average size estimate by the size of the report packet we 
//	// just sent out.
//	tmpSize = packetSize - *avgRtcpSize;
//	tmpSize = (int)(tmpSize * RTCP_sizeGain);
//	*avgRtcpSize += tmpSize;
//
//	// The effective number of sites times the average packet size is the 
//	// total number of octets sent when each site sends a report. Dividing 
//	// this by the effective bandwidth gives the time interval over which 
//	// those packets must be sent in order to meet the bandwidth target, 
//	// with a minimum enforced. In that time interval we send one report so
//	// this time is also our average time between reports.
//	t = (*avgRtcpSize) * n / rtcpBw;
//
//	if (t < rtcp_min_time)
//		t = rtcp_min_time;
//
//	// To avoid traffic burst from unintended synchronization with other sites
//	// we then pick our actual next report interval as a random number 
//	// uniformely distributed between 0.5*t and 1.5*t.
//
//	// Get a random number between 0 and 1
//	//  rand() gives a number between 0-32767. 
//	randNum = RRCMrand() % 32767;
//	randNum /= 32767.0;
//
//  // return timeout in msec
//	return (t * (randNum + 0.5) * 1000);
#else
	// Minimum time between RTCP packets from this site in Msec. This time
	// prevents the reports from clumping when sessions are small and the law
	// of large numbers isn't helping to smooth out the traffic. It also keeps
	// the report intervals from becoming ridiculously small during transient
	// outages like a network partition.
	int RTCP_MinTime = 5000;

	// Interval 
	int				t = 0;
	int				rtcp_min_time = RTCP_MinTime;

	// Number of member for computation 
	unsigned int 	n;
	int				tmpSize;

	// Random number 
	int				randNum;

	// Very first call at application start-up uses half the min delay for 
	// quicker notification while still allowing some time before reporting
	// for randomization and to learn about other sources so the report
	// interval will converge to the correct interval more quickly. The
	// average RTCP size is initialized to 128 octects which is conservative.
	// It assumes everyone else is generating SRs instead of RRs:
	// 		20 IP + 8 UDP + 52 SR + 48 SDES CNAME
	if (initial)
		{
		rtcp_min_time /= 2;
		*avgRtcpSize = 128;
		}

	// If there were active senders, give them at least a minimum share of the 
	// RTCP bandwidth. Otherwise all participants share the RTCP Bw equally.
	n = members;

	// Only a quart of the bandwidth (=> /4). Check above with floatting point
	if (senders > 0 && (senders < (members / 4)))
		{
		if (weSent)
			{
			// Only a quart of the bandwidth for the sender
			rtcpBw /= 4;
			n = senders;
			}
		else
			{
			// 3/4 of the bandwidth for the receiver
			rtcpBw = (3*rtcpBw)/4;
			n -= senders;
			}
		}

	// Update the average size estimate by the size of the report packet we 
	// just sent out.
	tmpSize = packetSize - *avgRtcpSize;
	tmpSize = (tmpSize+8) / 16;
	*avgRtcpSize += tmpSize;

	// The effective number of sites times the average packet size is the 
	// total number of octets sent when each site sends a report. Dividing 
	// this by the effective bandwidth gives the time interval over which 
	// those packets must be sent in order to meet the bandwidth target, 
	// with a minimum enforced. In that time interval we send one report so
	// this time is also our average time between reports.
	if (rtcpBw)
		t = (*avgRtcpSize) * n / rtcpBw;

	if (t < rtcp_min_time)
		t = rtcp_min_time;

	// To avoid traffic burst from unintended synchronization with other sites
	// we then pick our actual next report interval as a random number 
	// uniformely distributed between 0.5*t and 1.5*t.

	// Get a random number between 0 and 1
	// In order to avoid floating point operation, get a number between 
	// 0 and 1000, i.e. converted in Msec already. Add 500 Msec instead of 
	// 0.5 to the random number
	randNum = RRCMrand() % 1000;

	return ((t * (randNum + 500))/1000);
#endif
	}




// [EOF]
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\rrcm\rtcp\rtcpssrc.cpp ===
/*----------------------------------------------------------------------------
 * File:        RTCPSSRC.C
 * Product:     RTP/RTCP implementation
 * Description: Provides SSRC related function.
 *
 * INTEL Corporation Proprietary Information
 * This listing is supplied under the terms of a license agreement with 
 * Intel Corporation and may not be copied nor disclosed except in 
 * accordance with the terms of that agreement.
 * Copyright (c) 1995 Intel Corporation. 
 *--------------------------------------------------------------------------*/


#include "rrcm.h"
#include "md5.h"



/*---------------------------------------------------------------------------
/							Global Variables
/--------------------------------------------------------------------------*/            


/*---------------------------------------------------------------------------
/							External Variables
/--------------------------------------------------------------------------*/                                       
extern PRTCP_CONTEXT	pRTCPContext;

#ifdef ENABLE_ISDM2
extern KEY_HANDLE		hRRCMRootKey;
extern ISDM2			Isdm2;
#endif

#ifdef _DEBUG
extern char		debug_string[];
#endif
    


/*----------------------------------------------------------------------------
 * Function   : getOneSSRCentry
 * Description: Get an SSRC entry from the free list of entries.
 * 
 * Input :      pList		: -> to the list to get the entry from
 *				hHeap		: Handle to the heap where the data resides
 *				*pNum		: -> to the number of initial free entry in the list
 *				*pCritSect	: -> to the critical section
 *
 * Return: 		OK:		-> to SSRC entry
 *				Error:	NULL
 ---------------------------------------------------------------------------*/
PSSRC_ENTRY getOneSSRCentry (PLINK_LIST pList, 
							 HANDLE hHeap, 
							 DWORD *pNum,
							 CRITICAL_SECTION *pCritSect)
	{     
	PSSRC_ENTRY	pSSRC = NULL;

	IN_OUT_STR ("RTCP: Enter getOneSSRCentry()\n");

	// get an entry from the free list
	pSSRC = (PSSRC_ENTRY)removePcktFromHead (pList, pCritSect);
	if (pSSRC == NULL)
		{
		// try to reallocate some free cells
		if (allocateLinkedList (pList, hHeap, pNum, 
								sizeof(SSRC_ENTRY),
								pCritSect) == RRCM_NoError)
			{		 						
			// get a free cell if some have been reallocated
			pSSRC = (PSSRC_ENTRY)removePcktFromHead (pList, pCritSect);
			}
		}

	if (pSSRC)
		{
		clearSSRCEntry (pSSRC);

		// initialize the critical section
		InitializeCriticalSection(&pSSRC->critSect);
		}

	IN_OUT_STR ("RTCP: Exit getOneSSRCentry()\n");
		
	return (pSSRC);
	}		                                                                                                                                                            
	
                                                                                  
/*----------------------------------------------------------------------------
 * Function   : getSSRC
 * Description: Get a unique 32 bits SSRC
 * 
 * Input :      RcvSSRCList: Session's receive SSRC list address
 *				XmtSSRCList: Session's transmit SSRC list address
 *
 * Return:      Unique 32 bits SSRC
 ---------------------------------------------------------------------------*/
 DWORD getSSRC (LINK_LIST RcvSSRCList, 
				LINK_LIST XmtSSRCList)
	{               
	DWORD		SSRCnum = 0;
	DWORD		dwStatus;
	PSSRC_ENTRY	pSSRC;
	MD5_CTX		context;
	DWORD		i;
	union {
		unsigned char	c[16];
		DWORD			x[4];
		}digest;

	struct {
		DWORD		pid;
		DWORD		time;
		FILETIME	createTime;
		FILETIME	exitTime;
		FILETIME	kernelTime;
		FILETIME	userTime;
		} md5Input;

	IN_OUT_STR ("RTCP: Enter getSSRC()\n");

	// go through all SSRCs of this RTP/RTCP session
	while (SSRCnum == 0)
		{
		// get MD5 inputs
		md5Input.pid  = GetCurrentThreadId();
		md5Input.time = timeGetTime();

		dwStatus = GetProcessTimes (GetCurrentProcess(),
									&md5Input.createTime, 
									&md5Input.exitTime, 
									&md5Input.kernelTime, 
									&md5Input.userTime);
		if (dwStatus == FALSE)
			{
			RRCM_DBG_MSG ("RTCP: GetProcessTimes() failed", GetLastError(),
						  __FILE__, __LINE__, DBG_NOTIFY);
			}

		// Implementation suggested by draft 08, Appendix 6
		MD5Init (&context);
		MD5Update (&context, (unsigned char *)&md5Input, sizeof (md5Input));
		MD5Final ((unsigned char *)&digest, &context);
		SSRCnum = 0;
		for (i=0; i < 3; i++)
			SSRCnum ^= digest.x[i];

		// look through all transmitter for this session
		pSSRC = (PSSRC_ENTRY)XmtSSRCList.prev;
		if (isSSRCunique (pSSRC, &SSRCnum) == TRUE)
			{
			// look through all received SSRC for this session
			pSSRC = (PSSRC_ENTRY)RcvSSRCList.prev;
			isSSRCunique (pSSRC, &SSRCnum);
			}
		}

	IN_OUT_STR ("RTCP: Exit getSSRC()\n");

	return (SSRCnum);
	}


 /*----------------------------------------------------------------------------
 * Function   : getAnSSRC
 * Description: Build an SSRC according to the RFC, but does not check for 
 *				collision. Mainly used by H.323 to get a 32 bits number.
 * 
 * Input :      None
 *
 * Return:      32 bits SSRC
 ---------------------------------------------------------------------------*/
  DWORD WINAPI getAnSSRC (void)
	{               
	DWORD		SSRCnum = 0;
	DWORD		dwStatus;
	MD5_CTX		context;
	DWORD		i;
	union {
		unsigned char	c[16];
		DWORD			x[4];
		}digest;

	struct {
		DWORD		pid;
		DWORD		time;
		FILETIME	createTime;
		FILETIME	exitTime;
		FILETIME	kernelTime;
		FILETIME	userTime;
		} md5Input;

	IN_OUT_STR ("RTCP: Enter getAnSSRC()\n");

	// get MD5 inputs
	md5Input.pid  = GetCurrentThreadId();
	md5Input.time = timeGetTime();

	dwStatus = GetProcessTimes (GetCurrentProcess(),
								&md5Input.createTime, 
								&md5Input.exitTime, 
								&md5Input.kernelTime, 
								&md5Input.userTime);
	if (dwStatus == FALSE)
		{
		RRCM_DBG_MSG ("RTCP: GetProcessTimes() failed", GetLastError(),
					  __FILE__, __LINE__, DBG_NOTIFY);
		}

	// Implementation suggested by draft 08, Appendix 6
	MD5Init (&context);
	MD5Update (&context, (unsigned char *)&md5Input, sizeof (md5Input));
	MD5Final ((unsigned char *)&digest, &context);
	SSRCnum = 0;
	for (i=0; i < 3; i++)
		SSRCnum ^= digest.x[i];

	IN_OUT_STR ("RTCP: Exit getAnSSRC()\n");

	return (SSRCnum);
	}


/*----------------------------------------------------------------------------
 * Function   : isSSRCunique
 * Description: Check to see the SSRC already exist
 * 
 * Input :      pSSRC		:	-> to an SSRC list
 *				*SSRCnum	:	-> to the SSRC to check
 *
 * Return:      0: SSRC already exist
 *				1: SSRC is unique
 ---------------------------------------------------------------------------*/
 DWORD isSSRCunique (PSSRC_ENTRY pSSRC, 
					 DWORD *SSRCnum)
	{
	IN_OUT_STR ("RTCP: Enter isSSRCunique()\n");

	// make sure SSRC is unique for this session 
	while (pSSRC)
		{
		if (pSSRC->SSRC == *SSRCnum)
			{
			// SSRC already in use, get a new one 
			*SSRCnum = 0;
			return FALSE;
			}
					         
		// get next RTCP session 
		pSSRC = (PSSRC_ENTRY)pSSRC->SSRCList.next;
		}

	IN_OUT_STR ("RTCP: Exit isSSRCunique()\n");

	return TRUE;
	}                                                                                     
                                                                              
                                                                              
/*----------------------------------------------------------------------------
 * Function   : createSSRCEntry
 * Description: Create an SSRC entry, for a particular RTP/RTCP session
 * 
 * Input :      SSRCnum		: SSRC number
 *				pRTCP		: -> to the RTCP session
 *				fromAddr	: From address
 *				fromLen		: From length
 *				headOfList	: Put the new entry at the head of the list
 *
 * Return:      Address of the SSRC entry data structure.
 ---------------------------------------------------------------------------*/
 PSSRC_ENTRY createSSRCEntry (DWORD SSRCnum, 
							  PRTCP_SESSION pRTCP,
 							  PSOCKADDR fromAddr, 
							  DWORD fromLen, 
							  DWORD headOfList)
	{               
	PSSRC_ENTRY		pSSRCentry;
	PSSRC_ENTRY		pSSRCtmp;
	PLINK_LIST		pTmp;
	BOOL			entryAdded = FALSE;

	IN_OUT_STR ("RTCP: Enter createSSRCEntry()\n");

	// get an SSRC cell from the free list 
	pSSRCentry = getOneSSRCentry (&pRTCPContext->RRCMFreeStat, 
								  pRTCPContext->hHeapRRCMStat,
								  &pRTCPContext->dwInitNumFreeRRCMStat,
								  &pRTCPContext->critSect);
	if (pSSRCentry == NULL)
		return NULL;

	// save the remote source address
	if (saveNetworkAddress(pSSRCentry,
						   fromAddr,
						   fromLen) != RRCM_NoError)
		{
		addToHeadOfList (&pRTCPContext->RRCMFreeStat, 
						 (PLINK_LIST)pSSRCentry,
						 &pRTCPContext->critSect);
		return (NULL);
		}

	pSSRCentry->SSRC = SSRCnum;
	pSSRCentry->rcvInfo.dwProbation = MIN_SEQUENTIAL;

	// set this SSRC entry's RTCP session
	pSSRCentry->pRTCPses  = pRTCP;

	// initialize the socket descriptor
	pSSRCentry->RTPsd  = ((PSSRC_ENTRY)pRTCP->XmtSSRCList.prev)->RTPsd;
	pSSRCentry->RTCPsd = ((PSSRC_ENTRY)pRTCP->XmtSSRCList.prev)->RTCPsd;

	// initialize 'dwLastReportRcvdTime' to now
	pSSRCentry->dwLastReportRcvdTime = timeGetTime();

#ifdef _DEBUG
	wsprintf (debug_string, 
	  "RTCP: Create SSRC entry (Addr:x%lX, SSRC=x%lX) for session: (Addr:x%lX)",
	  pSSRCentry, pSSRCentry->SSRC, pRTCP);
	RRCM_DBG_MSG (debug_string, 0, NULL, 0, DBG_TRACE);
#endif

#ifdef ENABLE_ISDM2
	// register to ISDM
	if (Isdm2.hISDMdll && (pRTCP->dwSessionStatus & RTCP_DEST_LEARNED))
		registerSessionToISDM (pSSRCentry, pRTCP, &Isdm2);
#endif

	// check to see if it's our entry that needs to be put at the head of 
	//	the SSRC list. If it's not our entry, will find a place for it in the
	//	ordered list
	if (headOfList)
		{
		// Attach the SSRC to the RTCP session list entry head 
		addToHeadOfList (&pRTCP->XmtSSRCList, 
						 (PLINK_LIST)pSSRCentry,
						 &pRTCP->critSect);

		// number of SSRC entry for the RTCP session 
		InterlockedIncrement ((long *)&pRTCP->dwCurNumSSRCperSes);

#ifdef MONITOR_STATS
		// high number of SSRC entry for the RTCP session
		InterlockedIncrement ((long *)&pRTCP->dwHiNumSSRCperSes)
#endif

		return (pSSRCentry);
		}

	// put it on the receive list of SSRCs
	pTmp = (PLINK_LIST)pRTCP->RcvSSRCList.prev;

	// check if it's the first one
	if (pTmp == NULL)
		{
		// Attach the SSRC to the RTCP session list entry head 
		addToHeadOfList (&pRTCP->RcvSSRCList, 
						 (PLINK_LIST)pSSRCentry,
						 &pRTCP->critSect);

		// number of SSRC entry for the RTCP session 
		InterlockedIncrement ((long *)&pRTCP->dwCurNumSSRCperSes);

#ifdef MONITOR_STATS
		// high number of SSRC entry for the RTCP session 
		InterlockedIncrement ((long *)&pRTCP->dwHiNumSSRCperSes)
#endif

		return (pSSRCentry);
		}

	while (!entryAdded)
		{
		if (pTmp != NULL)
			{
			pSSRCtmp = (PSSRC_ENTRY)pTmp;
			if (pSSRCtmp->SSRC < SSRCnum)
				pTmp = pTmp->next;
			else
				{
				// lock at the RTCP session level, for head/tail ptrs access
				EnterCriticalSection (&pRTCP->critSect);

				if ((pTmp->next == NULL) && (pSSRCtmp->SSRC < SSRCnum))
					{
					// attach the SSRC to the RTCP session list entry head 
					// This SSRC is bigger than all other ones
					addToHeadOfList (&pRTCP->RcvSSRCList, 
									 (PLINK_LIST)pSSRCentry,
									 &pRTCP->critSect);
					}
				else if (pTmp->prev == NULL)
					{
					// attach the SSRC to the RTCP session list entry tail 
					// This SSRC is smaller than all other ones
					addToTailOfList (&pRTCP->RcvSSRCList, 
									 (PLINK_LIST)pSSRCentry,
									 &pRTCP->critSect);
					}
				else
					{				
					// this SSRC is in between other SSRCs
					EnterCriticalSection (&((PSSRC_ENTRY)pTmp->prev)->critSect);
					(pTmp->prev)->next = (PLINK_LIST)pSSRCentry;
					LeaveCriticalSection (&((PSSRC_ENTRY)pTmp->prev)->critSect);

					// don't need to lock out pSSRCentry pointers
					pSSRCentry->SSRCList.next = pTmp;
					pSSRCentry->SSRCList.prev = pTmp->prev;

					pTmp->prev = (PLINK_LIST)pSSRCentry;
					}

				// unlock RTCP session access 
				LeaveCriticalSection (&pRTCP->critSect);

				// set loop flag 
				entryAdded = TRUE;
				}
			}
		else
			{
			// attach the SSRC to the RTCP session list entry head 
			addToHeadOfList (&pRTCP->RcvSSRCList, 
							 (PLINK_LIST)pSSRCentry,
							 &pRTCP->critSect);

			// set loop flag 
			entryAdded = TRUE;
			}
		}

	// number of SSRC entry for the RTCP session 
	InterlockedIncrement ((long *)&pRTCP->dwCurNumSSRCperSes);

#ifdef MONITOR_STATS
	// high number of SSRC entry for the RTCP session 
	InterlockedIncrement ((long *)&pRTCP->dwHiNumSSRCperSes)
#endif

	IN_OUT_STR ("RTCP: Exit createSSRCEntry()\n");

	return (pSSRCentry);
	}
                                                                                                                                                            
                                                                              
                                                                              
/*----------------------------------------------------------------------------
 * Function   : deleteSSRCEntry
 * Description: Delete an SSRC entry (for a particular RTP/RTCP session).
 * 
 * Input :      SSRCnum		: SSRC number to delete from the list
 *				pRTCP		: -> to the RTCP session
 *
 * Return:      TRUE:	Deleted
 *				FALSE:	Entry not found
 ---------------------------------------------------------------------------*/
 DWORD deleteSSRCEntry (DWORD SSRCnum, 
						PRTCP_SESSION pRTCP)
	{               
	PSSRC_ENTRY	pSSRCtmp = NULL;
	PLINK_LIST	pTmp;
	DWORD		dwStatus = FALSE;

	IN_OUT_STR ("RTCP: Enter deleteSSRCEntry()\n");

	// walk through the list from the tail 
	pTmp = (PLINK_LIST)pRTCP->RcvSSRCList.prev;

	while (pTmp)
		{
		// lock access to this entry 
		EnterCriticalSection (&((PSSRC_ENTRY)pTmp)->critSect);

		if (((PSSRC_ENTRY)pTmp)->SSRC == SSRCnum)
			{
#ifdef _DEBUG
			wsprintf (debug_string, 
					  "RTCP: Delete SSRC=x%lX from session: (Addr:x%lX)",
					  SSRCnum, pRTCP);
			RRCM_DBG_MSG (debug_string, 0, NULL, 0, DBG_TRACE);
#endif

#ifdef ENABLE_ISDM2
			// unregister ISDM session
			if (Isdm2.hISDMdll && ((PSSRC_ENTRY)pTmp)->hISDM)
				Isdm2.ISDMEntry.ISD_DeleteValue(hRRCMRootKey, 
												((PSSRC_ENTRY)pTmp)->hISDM, NULL);
#endif

			// remove the entry from the list 
			if (pTmp->next == NULL)
				{
				removePcktFromHead (&pRTCP->RcvSSRCList,
									&pRTCP->critSect);
				}
			else if (pTmp->prev == NULL)
				{
				removePcktFromTail (&pRTCP->RcvSSRCList,
									&pRTCP->critSect);
				}
			else
				{
				// in between, relink around 
				EnterCriticalSection (&((PSSRC_ENTRY)pTmp->prev)->critSect);
				(pTmp->prev)->next = pTmp->next;
				LeaveCriticalSection (&((PSSRC_ENTRY)pTmp->prev)->critSect);

				EnterCriticalSection (&((PSSRC_ENTRY)pTmp->next)->critSect);
				(pTmp->next)->prev = pTmp->prev;
				LeaveCriticalSection (&((PSSRC_ENTRY)pTmp->next)->critSect);
				}

			// number of SSRC entry for the RTCP session 
			InterlockedDecrement ((long *)&pRTCP->dwCurNumSSRCperSes);

			// return entry to the free list 
			addToHeadOfList (&pRTCPContext->RRCMFreeStat, 
							 pTmp,
							 &pRTCPContext->critSect);

			// unlock access to this entry 
			LeaveCriticalSection (&((PSSRC_ENTRY)pTmp)->critSect);

			dwStatus = TRUE;
			break;
			}

		// unlock access to this entry 
		LeaveCriticalSection (&((PSSRC_ENTRY)pTmp)->critSect);

		pTmp = pTmp->next;
		}	

	IN_OUT_STR ("RTCP: Exit deleteSSRCEntry()\n");	

	return (dwStatus);
	}

 
/*----------------------------------------------------------------------------
 * Function   : deleteSSRClist
 * Description: Delete the SSRC list of an RTP/RTCP session.
 * 
 * Input :      pRTCP	  : -> to RTCP session
 *				pFreeList : -> to the free list of SSRCs
 *				pOwner	  : -> to the free list owner
 *
 * Return:      None
 ---------------------------------------------------------------------------*/
 void deleteSSRClist (PRTCP_SESSION pRTCP, 
					  PLINK_LIST pFreeList, 
					  PRTCP_CONTEXT pOwner)
	{               
	PLINK_LIST	pSSRC;

	IN_OUT_STR ("RTCP: Enter deleteSSRClist()\n");

	ASSERT (pFreeList);
	ASSERT (pRTCP);

	// lock access to the full RTCP session 
	EnterCriticalSection (&pRTCP->critSect);

	// go through the list of transmit SSRCs for this RTCP session 
	while (pRTCP->XmtSSRCList.next != NULL)
		{
		// get packet from the list tail 
		pSSRC = removePcktFromTail ((PLINK_LIST)&pRTCP->XmtSSRCList,
									&pRTCP->critSect);
		if (pSSRC != NULL)
			{
#ifdef _DEBUG
			wsprintf(debug_string, 
					 "RTCP: Delete SSRC entry (x%lX) from session (x%lX)",
					 ((PSSRC_ENTRY)pSSRC)->SSRC, pRTCP);
			RRCM_DBG_MSG (debug_string, 0, NULL, 0, DBG_TRACE);
#endif					

#ifdef ENABLE_ISDM2
			// unregister ISDM session
			if (Isdm2.hISDMdll && ((PSSRC_ENTRY)pSSRC)->hISDM)
				Isdm2.ISDMEntry.ISD_DeleteValue (hRRCMRootKey, 
										((PSSRC_ENTRY)pSSRC)->hISDM, NULL);
#endif

			// put it back to the free list 
			addToHeadOfList (pFreeList, pSSRC, &pOwner->critSect);

			// release the critical section
			DeleteCriticalSection (&((PSSRC_ENTRY)pSSRC)->critSect);
			}
		}

	// go through the list of SSRCs for this RTP/RTCP session 
	while (pRTCP->RcvSSRCList.next != NULL)
		{
		// get packet from the list tail 
		pSSRC = removePcktFromTail ((PLINK_LIST)&pRTCP->RcvSSRCList,
									&pRTCP->critSect);
		if (pSSRC != NULL)
			{
#ifdef _DEBUG
			wsprintf(debug_string, 
					 "RTCP: Delete SSRC entry (x%lX) from session (x%lX)",
					 ((PSSRC_ENTRY)pSSRC)->SSRC, pRTCP);
			RRCM_DBG_MSG (debug_string, 0, NULL, 0, DBG_TRACE);
#endif					

#ifdef ENABLE_ISDM2
			// unregister ISDM session
			if (Isdm2.hISDMdll && ((PSSRC_ENTRY)pSSRC)->hISDM)
				Isdm2.ISDMEntry.ISD_DeleteValue (hRRCMRootKey, 
								((PSSRC_ENTRY)pSSRC)->hISDM, NULL);
#endif

			// put it back to the free list 
			addToHeadOfList (pFreeList, pSSRC, &pOwner->critSect);

			// release the critical section
			DeleteCriticalSection (&((PSSRC_ENTRY)pSSRC)->critSect);
			}
		}

	// unlock access to the full RTCP session 
	LeaveCriticalSection (&pRTCP->critSect);

	IN_OUT_STR ("RTCP: Exit deleteSSRClist()\n");				
	}


/*----------------------------------------------------------------------------
 * Function   : SSRCTimeoutCheck
 * Description: Check if an rcv SSRC needs to be timed out
 *				Since there may be multiple RCV SSRCs, repeat calling
 *				this function until it returns NULL
 * 
 * Input :      pRTCC	: -> to the RTCP session
 *				curTime	: Current time
 *
 * Return: 		NULL  : No action needed
 *				PSSRC : -> to the SSRC entry that should be deleted
 ---------------------------------------------------------------------------*/
PSSRC_ENTRY SSRCTimeoutCheck (PRTCP_SESSION pRTCP, DWORD curTime) 
	{
	PSSRC_ENTRY pSSRC;
	DWORD		tmpTime;

	// check the colliding entries table and clear it if needed
	RRCMTimeOutCollisionTable (pRTCP);

	// get the right session to close 
	pSSRC = (PSSRC_ENTRY)pRTCP->RcvSSRCList.prev;
	while (pSSRC)
		{
		// check if this SSRC timed-out
		tmpTime = curTime - pSSRC->dwLastReportRcvdTime;

		// get the time in minutes
		tmpTime /= (1000*60);
		if (tmpTime > RTCP_TIME_OUT_MINUTES)
			{
				break;
			}

		pSSRC = (PSSRC_ENTRY)pSSRC->SSRCList.next;
		}
	return pSSRC;
	}


/*---------------------------------------------------------------------------
 * Function   : RRCMChkCollisionTable
 * Description: Check the collision table to try to find a match 
 * 
 * Input :	pFrom		:	-> recv from address
 *			fromlen		:	-> recv from address length
 *			pSSRC		:	-> to the SSRC entry
 *
 * Return:	TRUE:	Match found
 *			FALSE:	No match found
 --------------------------------------------------------------------------*/
 DWORD RRCMChkCollisionTable (PSOCKADDR pFrom,
 							  UINT fromlen,
							  PSSRC_ENTRY pSSRC)
	{
	DWORD			idx;
	DWORD			dwStatus = FALSE;
	PRTCP_SESSION	pRTCP = pSSRC->pRTCPses;

	IN_OUT_STR ("RRCM: Enter RRCMChkCollisionTable()\n");		 	

	// entry w/ time == 0 are empty
	for (idx = 0; idx < NUM_COLLISION_ENTRIES; idx++)
		{
		if (pRTCP->collInfo[idx].dwCollideTime != 0)
			{
			if (memcmp (&pRTCP->collInfo[idx].collideAddr,
						pFrom, 
						fromlen) == 0)
				{
				// update the time of last collision received
				pRTCP->collInfo[idx].dwCollideTime = timeGetTime();

				dwStatus = TRUE;
				break;
				}
			}
		}

	IN_OUT_STR ("RRCM: Exit RRCMChkCollisionTable()\n");		 	

	return dwStatus;
	}


/*---------------------------------------------------------------------------
 * Function   : RRCMAddEntryToCollisionTable
 * Description: Add an entry into the collision table.
 * 
 * Input :	pFrom		:	-> recv from address
 *			fromlen		:	-> recv from address length
 *			pSSRC		:	-> to the SSRC entry
 *
 * Return:	TRUE:	Entry added
 *			FALSE:	Table full
 --------------------------------------------------------------------------*/
 DWORD RRCMAddEntryToCollisionTable (PSOCKADDR pFrom,
 									 UINT fromlen,
									 PSSRC_ENTRY pSSRC)
	{
	DWORD			idx;
	DWORD			dwStatus = FALSE;
	PRTCP_SESSION	pRTCP = pSSRC->pRTCPses;

	IN_OUT_STR ("RRCM: Enter RRCMAddEntryToCollisionTable()\n");
	
	// entry w/ time == 0 are empty
	for (idx = 0; idx < NUM_COLLISION_ENTRIES; idx++)
		{
		if (pRTCP->collInfo[idx].dwCollideTime == 0)
			{
			memcpy (&pRTCP->collInfo[idx].collideAddr,
					pFrom, 
					fromlen);

			pRTCP->collInfo[idx].addrLen = fromlen;
			pRTCP->collInfo[idx].dwCollideTime = timeGetTime();
			pRTCP->collInfo[idx].dwCurRecvRTCPrptNumber = pSSRC->dwNumRptRcvd;

			pRTCP->collInfo[idx].SSRC = pSSRC->SSRC;

			dwStatus = TRUE;
			break;
			}
		}

	
	IN_OUT_STR ("RRCM: Exit RRCMAddEntryToCollisionTable()\n");		 

	return dwStatus;
	}



/*---------------------------------------------------------------------------
 * Function   : RRCMTimeOutInCollisionTable
 * Description: Check if an entry in the collision table must be timed-out
 * 
 * Input :	pRTCP	:	-> to the RTCP session
 *
 * Return:	None
 --------------------------------------------------------------------------*/
 void RRCMTimeOutCollisionTable (PRTCP_SESSION pRTCP)
	{
	DWORD	idx;
	DWORD	currTime = timeGetTime();
	DWORD	diffTime;

	IN_OUT_STR ("RTCP: Enter RRCMTimeOutCollisionTable()\n");
	
	// entry w/ time == 0 are empty
	for (idx = 0; idx < NUM_COLLISION_ENTRIES; idx++)
		{
		// valid entries have the time set
		if (pRTCP->collInfo[idx].dwCollideTime)
			{
			// remove the entry from this table if 10 RTCP report intervals
			// have occured without a collision

			// clear the entry if over 5'
// !!! TODO !!!
// !!! using the right interval !!!
			diffTime = currTime - pRTCP->collInfo[idx].dwCollideTime;
			diffTime /= 1000;
			if (diffTime > 300)
				{
				pRTCP->collInfo[idx].dwCollideTime = 0;

				// the SSRC entry in the receive list will be deleted by
				// the timeout thread
				}
			}
		}

	IN_OUT_STR ("RTCP: Exit RRCMTimeOutCollisionTable()\n");		 
	}


/*----------------------------------------------------------------------------
 * Function   : clearSSRCEntry
 * Description: Clears what needs to be cleared in an SSRC entry
 * 
 * Input :      pSSRC		: -> to the SSRC entry
 *
 * Return:      None
 ---------------------------------------------------------------------------*/
 void clearSSRCEntry (PSSRC_ENTRY pSSRC)
	{
	IN_OUT_STR ("RTCP: Enter clearSSRCEntry()\n");				

	memset (&pSSRC->xmtInfo, 0x00, sizeof(XMIT_INFO));
	memset (&pSSRC->rcvInfo, 0x00, sizeof(RECV_INFO));
	memset (&pSSRC->rrFeedback, 0x00, sizeof (RTCP_FEEDBACK));
	memset (&pSSRC->cnameInfo, 0x00, sizeof(SDES_DATA));
	memset (&pSSRC->nameInfo, 0x00, sizeof(SDES_DATA));
	memset (&pSSRC->from, 0x00, sizeof(SOCKADDR));

	pSSRC->SSRC					= 0;			
	pSSRC->dwSSRCStatus			= 0;
	pSSRC->dwStreamClock		= 0;
	pSSRC->fromLen				= 0;
	pSSRC->dwLastReportRcvdTime	= 0;
	pSSRC->dwUserXmtTimeoutCtrl = 0;
	pSSRC->RTPsd				= 0;
	pSSRC->RTCPsd				= 0;
	pSSRC->pRTCPses				= NULL;
	pSSRC->dwNumRptSent			= 0;
	pSSRC->dwNumRptRcvd			= 0;

#ifdef ENABLE_ISDM2
	pSSRC->hISDM				= 0;
#endif

#ifdef _DEBUG
	pSSRC->dwPrvTime			= 0;	
#endif

	IN_OUT_STR ("RTCP: Exit clearSSRCEntry()\n");				
	}

                                                                              
// [EOF]
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\rrcm\rtp\rtpio.cpp ===
/*----------------------------------------------------------------------------
 * File:        RTPIO.C
 * Product:     RTP/RTCP implementation
 * Description: Provides Session Creation/Deletion Functionality.
 *
 *
 * This listing is supplied under the terms
 * of a license agreement with Intel Corporation and
 * many not be copied nor disclosed except in accordance
 * with the terms of that agreement.
 * Copyright (c) 1995 Intel Corporation.
 *--------------------------------------------------------------------------*/

#include "rrcm.h"
		

/*---------------------------------------------------------------------------
/							Global Variables
/--------------------------------------------------------------------------*/


/*---------------------------------------------------------------------------
/							External Variables
/--------------------------------------------------------------------------*/
extern PRTP_CONTEXT	pRTPContext;

#ifdef _DEBUG
extern char   debug_string[];
#endif


/*----------------------------------------------------------------------------
 * Function   : CreateRTPSession
 * Description: Creates an RTP (and RTCP) session for a new stream.
 *
 * Input :		RTPsocket		: RTP socket descriptor
 *				RTCPsd			: RTCP socket descriptor
 *				pRTCPTo			: RTCP destination address
 *				toRTCPLen		: RTCP destination address length
 *				pSdesInfo		: -> to SDES information
 *				dwStreamClock	: Stream clocking frequency
 *				ssrc			: If set, user selected SSRC
 *				pRRCMcallback	: RRCM notification
 *				dwCallbackInfo	: User callback info
 *				miscInfo		: Miscelleanous information:
 *										H.323Conf:		0x00000002
 *										Encrypt SR/RR:	0x00000004
 *										RTCPon:			0x00000008
 *				dwRtpSessionBw	: RTP session bandwidth used for RTCP BW
 *				*pStatus		: -> to status information
 *
 * Return: handle to created session if successful
 *         Otherwise(0)	*pStatus = Initialization Error (see RRCM.H)
 ---------------------------------------------------------------------------*/
HANDLE WINAPI CreateRTPSession (SOCKET RTPsocket,
								  SOCKET RTCPsocket,
								  LPVOID pRTCPTo,
								  DWORD toRTCPLen,
								  PSDES_DATA pSdesInfo,
								  DWORD dwStreamClock,
								  PENCRYPT_INFO pEncryptInfo,
								  DWORD ssrc,
								  PRRCM_EVENT_CALLBACK pRRCMcallback,
								  DWORD_PTR dwCallbackInfo,
								  DWORD miscInfo,
								  DWORD dwRtpSessionBw,
								  DWORD *pStatus)
	{
	DWORD			numCells = NUM_FREE_CONTEXT_CELLS;
	DWORD			dwStatus;
	DWORD			dwRTCPstatus;
	PRTP_SESSION    pSession = NULL;
	PSSRC_ENTRY		pSSRC;

	IN_OUT_STR ("RTP : Enter CreateRTPSession()\n");

	// set status code
	*pStatus = dwStatus = RRCM_NoError;

	// If RTP context doesn't exist, report error and return.
	if (pRTPContext == NULL)
		{
		RRCM_DBG_MSG ("RTP : ERROR - No RTP Instance",
					  0, __FILE__, __LINE__, DBG_CRITICAL);
		IN_OUT_STR ("RTP : Exit CreateRTPSession()\n");

		*pStatus = MAKE_RRCM_ERROR(RRCMError_RTPNoContext);

		return 0;
		}

	#if 0
	// look for an existing session - Sender/Receiver for the same session
	// will be on two different graph under ActiveMovie
	if (pSession = findSessionID (RTPsocket))
		{
		RRCM_DBG_MSG ("RTP : Session already created", 0,
					  __FILE__, __LINE__, DBG_TRACE);

		IN_OUT_STR ("RTP : Exit CreateRTPSession()\n");

		// return the unique RTP session ID
		return ((HANDLE)pSession);
		}
	#endif

	// Allocate a new session pointer.
	pSession = (PRTP_SESSION)GlobalAlloc (GMEM_FIXED | GMEM_ZEROINIT,
									      sizeof(RTP_SESSION));
		
	// Report error if could not allocate context
	if (pSession == NULL)
		{
		RRCM_DBG_MSG ("RTP : ERROR - Resource allocation failed", 0,
					  __FILE__, __LINE__, DBG_CRITICAL);
		IN_OUT_STR ("RTP : Exit CreateRTPSession()\n");

		*pStatus = MAKE_RRCM_ERROR(RRCMError_RTPSessResources);

		return 0;
		}

	// Initialize the RTP session's critical section
	InitializeCriticalSection(&pSession->critSect);
	

	// All seems OK, initialize RTCP for this session
	pSession->pRTCPSession = CreateRTCPSession(RTPsocket,
											   RTCPsocket,
											   pRTCPTo,
											   toRTCPLen,
											   pSdesInfo,
											   dwStreamClock,
											   pEncryptInfo,
											   ssrc,
											   pRRCMcallback,
											   dwCallbackInfo,
											   miscInfo,
											   dwRtpSessionBw,
											   &dwRTCPstatus);

	if (pSession->pRTCPSession == NULL)
		{
		dwStatus = dwRTCPstatus;


		// Can't proceed, return session pointer
		if (pSession)
			{
			GlobalFree (pSession);
			pSession = NULL;
			}
		}
	else
		{
#if 0
		// Associate the socket with the Session address
		dwStatus = createHashEntry (pSession, RTPsocket);
#endif

		if (dwStatus == RRCM_NoError)
			{
			pSSRC =
				(PSSRC_ENTRY)pSession->pRTCPSession->XmtSSRCList.prev;

			if (pSSRC == NULL)
				{
				RRCM_DBG_MSG ("RTP : ERROR - No RTCP Xmt list", 0,
						  __FILE__, __LINE__, DBG_CRITICAL);

				dwStatus = RRCMError_RTCPNoXmtList;
				}
			else
				{
				// Let's add this to our context
				addToHeadOfList(&(pRTPContext->pRTPSession),
							(PLINK_LIST)pSession,
							&pRTPContext->critSect);
#ifdef _DEBUG
				wsprintf(debug_string, "RTP : Adding RTP Session. (Addr:0x%p)",
								pSession);
				RRCM_DBG_MSG (debug_string, 0, NULL, 0, DBG_TRACE);
#endif
				}
			}

		}

	// set status code
	if (dwStatus != RRCM_NoError)
		*pStatus = MAKE_RRCM_ERROR(dwStatus);

	IN_OUT_STR ("RTP : Exit CreateRTPSession()\n");

	// return the unique RTP session ID
	return ((HANDLE)pSession);
	}


/*----------------------------------------------------------------------------
 * Function   : CloseRTPSession
 * Description: Terminates a local stream session.
 *
 * Input : RTPSession		= RTP session ID
 *		   byeReason		= -> to BYE reason
 *		   closeRTCPSocket	= TRUE/FALSE. RTCP will close or not the socket
 *
 * Return: RRCM_NoError		= OK.
 *         Otherwise(!=0)	= Error (see RRCM.H)
 ---------------------------------------------------------------------------*/
HRESULT WINAPI CloseRTPSession (HANDLE RTPSession,
							     PCHAR byeReason,
							     DWORD closeRTCPSocket)
	{
	PRTP_SESSION    pSession;
	PSSRC_ENTRY		pSSRCList;
	PSSRC_ENTRY		pSSRC;
	DWORD			dwStatus;

	IN_OUT_STR ("RTP : Enter CloseRTPSession()\n");

	// If RTP context doesn't exist, report error and return.
	if (pRTPContext == NULL)
		{
		RRCM_DBG_MSG ("RTP : ERROR - No RTP Instance", 0,
						__FILE__, __LINE__, DBG_ERROR);
		IN_OUT_STR ("RTP : Exit CloseRTPSession()\n");

		return (MAKE_RRCM_ERROR(RRCMError_RTPNoContext));
		}

	// Cast Session ID to obtain the session pointer.
	pSession = (PRTP_SESSION)RTPSession;
	if (pSession == NULL)
		{
		RRCM_DBG_MSG ("RTP : ERROR - Invalid RTP session", 0,
					  __FILE__, __LINE__, DBG_ERROR);
		IN_OUT_STR ("RTP : Exit CloseRTPSession()\n");

		return (MAKE_RRCM_ERROR(RRCMError_RTPInvalidSession));
		}

	// Remove the session from the linked list of sessions
	dwStatus = deleteRTPSession (pRTPContext, pSession);
	if (dwStatus != RRCM_NoError)
		{
#ifdef _DEBUG
		wsprintf(debug_string,
				 "RTP : ERROR - RTP session (Addr:0x%lX) not found",
				 RTPSession);

		RRCM_DBG_MSG (debug_string, 0, NULL, 0, DBG_ERROR);
#endif
		return (MAKE_RRCM_ERROR(dwStatus));
		}

	// lock out the session - it's on a free list now
	EnterCriticalSection (&pSession->critSect);

#if 0
	// clean up the Hash table for any stream still left in the Session
	for (pSSRCList = (PSSRC_ENTRY)pSession->pRTCPSession->XmtSSRCList.prev;
		 pSSRCList != NULL;
		 pSSRCList = (PSSRC_ENTRY)pSSRCList->SSRCList.next)
		{
		deleteHashEntry (pSSRCList->RTPsd);
		}
#endif
			
	// All seems OK, close RTCP for each stream still open
	pSSRC = (PSSRC_ENTRY)pSession->pRTCPSession->XmtSSRCList.prev;
	if (pSSRC == NULL)
		{
		RRCM_DBG_MSG ("RTP : ERROR - No SSRC entry on the Xmt list", 0,
					  __FILE__, __LINE__, DBG_ERROR);
		IN_OUT_STR ("RTP : Exit CloseRTPSession()\n");

		return (MAKE_RRCM_ERROR(RRCMError_RTCPInvalidSSRCentry));
		}

	// reset the close socket flag
	if (closeRTCPSocket)
		pSSRC->dwSSRCStatus |= CLOSE_RTCP_SOCKET;

	dwStatus = deleteRTCPSession (pSSRC->RTCPsd, byeReason);
#ifdef _DEBUG
	if (dwStatus != RRCM_NoError)
		{
		wsprintf(debug_string,
				 "RTP : ERROR - RTCP delete Session (Addr: x%p) error:%d",
			     pSession, dwStatus);
		RRCM_DBG_MSG (debug_string, 0, NULL, 0, DBG_TRACE);
		}
#endif


#ifdef _DEBUG
	wsprintf(debug_string, "RTP : Deleting Session x%p", pSession);
	RRCM_DBG_MSG (debug_string, 0, NULL, 0, DBG_TRACE);
#endif

	// lock out the session - it's on a free list now
	LeaveCriticalSection (&pSession->critSect);
	DeleteCriticalSection (&pSession->critSect);

	GlobalFree (pSession);
	pSession = NULL;

	IN_OUT_STR ("RTP : Exit CloseRTPSession()\n");

	if (dwStatus != RRCM_NoError)
		dwStatus = MAKE_RRCM_ERROR(dwStatus);

	return (dwStatus);
	}


/*--------------------------------------------------------------------------
** Function   : deleteRTPSession
** Description: Remove from	RTP session queue and restore links for other
**				sessions.
**
** Input :		pRTPContext:	-> to the RTP context
**				pSession:		-> to the RTP session
**
** Return:		OK:	RRCM_NoError
**				!0: Error code (see RRCM.H)
--------------------------------------------------------------------------*/
DWORD deleteRTPSession(PRTP_CONTEXT pRTPContext,
					   PRTP_SESSION pSession)
	{
	PLINK_LIST	pTmp;

	IN_OUT_STR ("RTP : Enter deleteRTPSession()\n");

	// make sure the session exist
	pTmp = pRTPContext->pRTPSession.prev;
	while (pTmp)
		{
		if (pTmp == (PLINK_LIST)pSession)
			break;

		pTmp = pTmp->next;
		}

	if (pTmp == NULL)
		{
		RRCM_DBG_MSG ("RTP : ERROR - Invalid RTP session", 0,
					  __FILE__, __LINE__, DBG_ERROR);

		IN_OUT_STR ("RTP : Exit deleteRTPSession()\n");

		return (MAKE_RRCM_ERROR(RRCMError_RTPInvalidSession));
		}

	// lock out queue access
	EnterCriticalSection (&pRTPContext->critSect);
	EnterCriticalSection (&pSession->critSect);

	if (pSession->RTPList.prev == NULL)
		// this was the first entry in the queue
		pRTPContext->pRTPSession.prev = pSession->RTPList.next;
	else
		(pSession->RTPList.prev)->next = pSession->RTPList.next;

	if (pSession->RTPList.next == NULL)
		// this was the last entry in the queue
		pRTPContext->pRTPSession.next = pSession->RTPList.prev;
	else
		(pSession->RTPList.next)->prev = pSession->RTPList.prev;

	// unlock out queue access
	LeaveCriticalSection (&pSession->critSect);
	LeaveCriticalSection (&pRTPContext->critSect);

	IN_OUT_STR ("RTP : Exit deleteRTPSession()\n");

	return (RRCM_NoError);
	}


// [EOF]


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\rrcm\rtp\rrcmcrt.cpp ===
/*----------------------------------------------------------------------------
 * File:        RRCMCRT.C
 * Product:     RTP/RTCP implementation.
 * Description: Provides Microsoft 'C' run-time support
 *
 * INTEL Corporation Proprietary Information
 * This listing is supplied under the terms of a license agreement with 
 * Intel Corporation and may not be copied nor disclosed except in 
 * accordance with the terms of that agreement.
 * Copyright (c) 1995 Intel Corporation. 
 *--------------------------------------------------------------------------*/


#include "rrcm.h"

 
/*---------------------------------------------------------------------------
/							Global Variables
/--------------------------------------------------------------------------*/


/*---------------------------------------------------------------------------
/							External Variables
/--------------------------------------------------------------------------*/
#ifdef _DEBUG
extern char		debug_string[];
#endif


/*--------------------------------------------------------------------------
 * Function   : RRCMsrand
 * Description: Seeds the random number generator with the int given.  
 *				Adapted from the BASIC random number generator.
 *
 * WARNING:		There is no per thread seed. All threads of the process are
 *				using the same seed.
 *
 * Input :	seed:	Seed
 *			
 *
 * Return: None
 --------------------------------------------------------------------------*/

static long holdrand = 1L;

void RRCMsrand (unsigned int seed)
	{
	holdrand = (long)seed;
	}
 

/*--------------------------------------------------------------------------
 * Function   : RRCMrand
 * Description: Returns a pseudo-random number 0 through 32767.
 *
 * WARNING:		There is no per thread number. All threads of the process 
 *				share the random number
 *
 * Input :	None
 *			
 * Return:	Pseudo-random number 0 through 32767.
 --------------------------------------------------------------------------*/
int RRCMrand (void)
	{
	return(((holdrand = holdrand * 214013L + 2531011L) >> 16) & 0x7fff);
	}



/***
*char *_itoa, *_ltoa, *_ultoa(val, buf, radix) - convert binary int to ASCII
*       string
*
*Purpose:
*       Converts an int to a character string.
*
*Entry:
*       val - number to be converted (int, long or unsigned long)
*       int radix - base to convert into
*       char *buf - ptr to buffer to place result
*
*Exit:
*       fills in space pointed to by buf with string result
*       returns a pointer to this buffer
*
*Exceptions:
*
*******************************************************************************/

/* helper routine that does the main job. */

static void RRCMxtoa (unsigned long val,
					  char *buf,
					  unsigned radix,
					  int is_neg)
	{
	char		*p;                /* pointer to traverse string */
	char		*firstdig;         /* pointer to first digit */
	char		temp;              /* temp char */
	unsigned	digval;        /* value of digit */

	p = buf;

	if (is_neg) {
		/* negative, so output '-' and negate */
		*p++ = '-';
		val = (unsigned long)(-(long)val);
	}

	firstdig = p;           /* save pointer to first digit */

	do {
		digval = (unsigned) (val % radix);
		val /= radix;   /* get next digit */

		/* convert to ascii and store */
		if (digval > 9)
			*p++ = (char) (digval - 10 + 'a');      /* a letter */
		else
			*p++ = (char) (digval + '0');           /* a digit */
		} while (val > 0);

	/* We now have the digit of the number in the buffer, but in reverse
	   order. Thus we reverse them now. */

	*p-- = '\0';            /* terminate string; p points to last digit */

	do {
		temp = *p;
		*p = *firstdig;
		*firstdig = temp;       /* swap *p and *firstdig */
		--p;
		++firstdig;             /* advance to next two digits */
		} while (firstdig < p); /* repeat until halfway */
	}


/* Actual functions just call conversion helper with neg flag set correctly,
   and return pointer to buffer. */

char *RRCMitoa (int val, char *buf, int radix)
	{
	if (radix == 10 && val < 0)
		RRCMxtoa((unsigned long)val, buf, radix, 1);
	else
		RRCMxtoa((unsigned long)(unsigned int)val, buf, radix, 0);
	return buf;
	}


char *RRCMltoa (long val, char *buf, int radix)
	{
	RRCMxtoa((unsigned long)val, buf, radix, (radix == 10 && val < 0));
	return buf;
	}


char *RRCMultoa (unsigned long val, char *buf, int radix)
	{
	RRCMxtoa(val, buf, radix, 0);
	return buf;
	}



// [EOF]
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\rrcm\rtp\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\rrcm\rtp\rtpsess.cpp ===
// RTPSink.cpp : Implementation of CRTPSession
#include "stdafx.h"
#include <qossp.h>
#include "irtp.h"
#include "rtp.h"
#include "RTPSess.h"
//#include "rtpsink.h"
//#include "RTPMS.h"
//#include "RTPSamp.h"
#include "thread.h"
#include <rrcm.h>

#define DEFAULT_RTPBUF_SIZE 1500

#define IPPORT_FIRST_DYNAMIC	49152
#define IPPORT_FIRST_DYNAMIC_END	(IPPORT_FIRST_DYNAMIC + 200)
#define IPPORT_FIRST_DYNAMIC_BEGIN	(IPPORT_FIRST_DYNAMIC_END + 256)

// Port number allocation starts at IPPORT_FIRST_DYNAMIC_BEGIN.
// Everytime a port number is allocated we decrease g_alport, until
// we reach IPPORT_FIRST_DYNAMIC_END. We then reset it back to its
// original value (IPPORT_FIRST_DYNAMIC_BEGIN) and start this process
// all over again. This way we will avoid reusing the same port
// numbers between sessions.
u_short g_alport = IPPORT_FIRST_DYNAMIC_BEGIN;
void __cdecl RRCMNotification(int,DWORD_PTR,DWORD_PTR,DWORD_PTR);



#define IsMulticast(p) ((p->sin_addr.S_un.S_un_b.s_b1 & 0xF0) == 0xE0)


BOOL CRTP::m_WSInitialized = 0;



STDMETHODIMP CRTP::OpenSession(
			UINT sessionId,	// client specified unique identifier for the session
			DWORD flags,	// SESSIONF_SEND, SESSIONF_RECV, SESSIONF_MULTICAST etc.
			BYTE *localAddr,
			UINT cbAddr,
			IRTPSession **ppIRTP) // [output] pointer to RTPSession
{
	// the session is named by the sessionId

	CRTPSession *pRTPSess ;
	HRESULT hr= E_FAIL;
	UINT mediaId = flags & (SESSIONF_AUDIO | SESSIONF_VIDEO);

	EnterCriticalSection(&g_CritSect);
	for (pRTPSess=  CRTPSession::m_pSessFirst; pRTPSess; pRTPSess = pRTPSess->m_pSessNext ) {
// check for existing session of the same media type
// if the sessionId is not zero, also check for matching session id
		if (sessionId == pRTPSess->m_sessionId)
			if (mediaId == pRTPSess->m_mediaId)
			break;
// if the local address or remote address is not NULL, search for an exising RTP session bound to
// the same address
// TODO	
			
	}

	if (!pRTPSess)
	{
		if (!(flags & SESSIONF_EXISTING)) {
			// create the session
			ObjRTPSession *pObj;
			DEBUGMSG(ZONE_DP,("Creating new RTP session\n"));
			hr = ObjRTPSession::CreateInstance(&pObj);
			if (hr == S_OK) {
				pRTPSess = pObj;	// pointer conversion
				hr = pRTPSess->Initialize(sessionId, mediaId,localAddr,cbAddr);
				if (hr != S_OK)
					delete pObj;
			}
		}
		else
			hr = E_FAIL;	// matching session does not exist
		
	} else {
		DEBUGMSG(ZONE_DP,("Reusing RTP session\n"));
		hr = S_OK;
	}
	if (hr == S_OK) {
		hr = ((IRTPSession *)pRTPSess)->QueryInterface(IID_IRTPSession,(void **) ppIRTP);
		
	}
	LeaveCriticalSection(&g_CritSect);
	return hr;
}


CRTPSession *CRTPSession::m_pSessFirst = NULL;
/////////////////////////////////////////////////////////////////////////////
// CRTPSession

CRTPSession::CRTPSession()
:  m_hRTPSession(NULL), m_uMaxPacketSize(1500),m_nBufsPosted(0),m_pRTPCallback(NULL),
	m_fSendingSync(FALSE)
{
	ZeroMemory(&m_sOverlapped,sizeof(m_sOverlapped));
	ZeroMemory(&m_ss, sizeof(m_ss));
	ZeroMemory(&m_rs, sizeof(m_rs));
	m_sOverlapped.hEvent = (WSAEVENT)this;
}

/*
HRESULT CRTPSession::GetLocalAddress(
            unsigned char *sockaddr,
            UINT  *paddrlen)
{
	if (m_pRTPSess && *paddrlen >= sizeof(SOCKADDR_IN))
	{
		*paddrlen = sizeof(SOCKADDR_IN);
		CopyMemory(sockaddr, m_pRTPSess->GetLocalAddress(), *paddrlen);
	}
}
*/
HRESULT
CRTPSession::FinalRelease()
{

	CRTPPacket1 *pRTPPacket;
	// remove myself from the session list
	EnterCriticalSection(&g_CritSect);
	if (m_pSessFirst == this)
		m_pSessFirst = m_pSessNext;
	else {
		CRTPSession *pRTPSess = m_pSessFirst;
		while (pRTPSess && pRTPSess->m_pSessNext != this) {
			pRTPSess = pRTPSess->m_pSessNext;
		}
		if (pRTPSess)
			pRTPSess->m_pSessNext = m_pSessNext;
	}
	LeaveCriticalSection(&g_CritSect);

	if (m_rtpsock) {
		delete m_rtpsock;
		m_rtpsock = NULL;
	}
	// BUGBUG: in case the buffers have not been canceled yet (an error case),
	// they should complete now with WSA_OPERATION_ABORTED
	// or WSAEINTR. This happens in the context of the RecvThread
	if (m_nBufsPosted != 0)
		Sleep(500);		// time for APCs to be processed in RecvThread
		
	// close the RTP session. Also ask RRCM to close the rtcp socket if its WS2
	// because that is a more reliable way of cleaning up overlapped recvs than
	// sending loopback packets.
	CloseRTPSession (m_hRTPSession, NULL,  TRUE );
	
	if (m_rtcpsock) {
		delete m_rtcpsock;
		m_rtcpsock = NULL;
	}
	m_hRTPSession = 0;
	// free receive buffers
	while (m_FreePkts.Get(&pRTPPacket))
	{
		delete pRTPPacket;
	}

			
	return S_OK;
}



HRESULT CRTPSession::CreateRecvRTPStream(DWORD ssrc, IRTPRecv **ppIRTPRecv)
{
	HRESULT hr;
	Lock();
	if (ssrc != 0)
		return E_NOTIMPL;

#if 0
	ObjRTPRecvSource *pRecvS;
	hr = ObjRTPMediaStream::CreateInstance(&pMS);

	if (SUCCEEDED(hr))
	{
		pMS->AddRef();
		pMS->Init(this, m_mediaId);
		hr = pMS->QueryInterface(IID_IRTPMediaStream, (void**)ppIRTPMediaStream);
		pMS->Release();
	}
#else
	*ppIRTPRecv = this;
	(*ppIRTPRecv)->AddRef();
	hr = S_OK;
#endif
	Unlock();
	return hr;
}



ULONG GetRandom()
{
	return GetTickCount();
}

HRESULT CRTPSession::Initialize(UINT sessionId, UINT mediaId, BYTE *pLocalAddr, UINT cbAddr)
{
	DWORD		APIstatus;
	HRESULT		hr = E_OUTOFMEMORY;
	char		tmpBfr[MAX_COMPUTERNAME_LENGTH + 1];
	DWORD		tmpBfrLen = sizeof(tmpBfr);
	SDES_DATA	sdesInfo[3];
	ENCRYPT_INFO encryptInfo;
	SOCKADDR_IN *pSockAddr;


	m_sessionId = sessionId;
	m_mediaId = mediaId;
	m_rtpsock	= new UDPSOCKET();
	m_rtcpsock  = new UDPSOCKET();

	if (!m_rtpsock || !m_rtcpsock)
		goto ERROR_EXIT;

	
	if(!m_rtpsock->NewSock() || !m_rtcpsock->NewSock())
	{
		goto ERROR_EXIT;
	}
	
	// if the local address is specified do a bind on the sockets
	if (pLocalAddr) {
		//  setup both channels for the current local address
		hr = SetLocalAddress(pLocalAddr,cbAddr);

		if (hr != S_OK)
			goto ERROR_EXIT;
	}
/*
	// if the remote address is specified make a note of it
	SetRemoteAddresses(pChanDesc->pRemoteAddr, pChanDesc->pRemoteRTCPAddr);
*/
	// init send state
	memset (&m_ss.sendStats,0,sizeof(m_ss.sendStats));
	// init RTP send header
	// time stamp and marker bit have to specified per packet
	m_ss.hdr.p = 0;		// no padding needed
	m_ss.hdr.x = 0;		// no extensions
	m_ss.hdr.cc = 0;		// no contributing sources
	m_ss.hdr.seq = (WORD)GetRandom();
	

	m_clockRate = (m_mediaId == SESSIONF_VIDEO ? 90000 : 8000);	// typically 8KHz for audio
	m_ss.hdr.pt = 0;
	

	// Initialize list of overlapped structs
	
	// build a Cname
	memcpy(tmpBfr,"CName",6);
	GetComputerName(tmpBfr,&tmpBfrLen);

	// build the SDES information
	sdesInfo[0].dwSdesType = 1;
	memcpy (sdesInfo[0].sdesBfr, tmpBfr, strlen(tmpBfr)+1);
	sdesInfo[0].dwSdesLength = strlen(sdesInfo[0].sdesBfr);
	sdesInfo[0].dwSdesFrequency = 100;
	sdesInfo[0].dwSdesEncrypted = 0;

	// Build a Name
	tmpBfrLen = sizeof(tmpBfr);
	memcpy(tmpBfr,"UserName",9);
	GetUserName(tmpBfr,&tmpBfrLen);
	sdesInfo[1].dwSdesType = 2;
	memcpy (sdesInfo[1].sdesBfr, tmpBfr, strlen(tmpBfr)+1);
	sdesInfo[1].dwSdesLength = strlen(sdesInfo[1].sdesBfr);
	sdesInfo[1].dwSdesFrequency = 25;
	sdesInfo[1].dwSdesEncrypted = 0;

	// end of SDES list
	sdesInfo[2].dwSdesType = 0;

	pSockAddr = m_rtcpsock->GetRemoteAddress();
#ifdef DEBUG
	if (pSockAddr->sin_addr.s_addr == INADDR_ANY)
		DEBUGMSG(ZONE_DP,("Null dest RTCP addr\n"));
#endif

	// Create the RTP/RTCP session
	
	m_hRTPSession = CreateRTPSession(
									 (m_rtpsock->GetSock()),
									 (m_rtcpsock->GetSock()),
								     (LPVOID)pSockAddr,
								     (pSockAddr->sin_addr.s_addr == INADDR_ANY)? 0 : sizeof(SOCKADDR_IN),
								     sdesInfo,
								     (DWORD)m_clockRate,
								     &encryptInfo,
								     0,
								     (PRRCM_EVENT_CALLBACK)RRCMNotification,		// callback function
									 (DWORD_PTR) this,			// callback info
								     RTCP_ON|H323_CONFERENCE,
									 0, //rtp session bandwidth
								     &APIstatus);
	
	if (m_hRTPSession == NULL)
		{
			DEBUGMSG(ZONE_DP,("Couldnt create RRCM session\n"));
			hr = GetLastError();
			goto ERROR_EXIT;
		}

      	m_Qos.SendingFlowspec.ServiceType = SERVICETYPE_NOTRAFFIC;
  		m_Qos.SendingFlowspec.TokenRate = QOS_NOT_SPECIFIED;
       	m_Qos.SendingFlowspec.TokenBucketSize = QOS_NOT_SPECIFIED;
  		m_Qos.SendingFlowspec.PeakBandwidth = QOS_NOT_SPECIFIED;
    	m_Qos.SendingFlowspec.Latency = QOS_NOT_SPECIFIED;
    	m_Qos.SendingFlowspec.DelayVariation = QOS_NOT_SPECIFIED;
    	m_Qos.SendingFlowspec.MaxSduSize = QOS_NOT_SPECIFIED;
    	m_Qos.ReceivingFlowspec = m_Qos.SendingFlowspec;
    	m_Qos.ProviderSpecific.buf = NULL;
    	m_Qos.ProviderSpecific.len = 0;
    	

	// insert RTPSession in global list
	m_pSessNext = m_pSessFirst;
	m_pSessFirst = this;
	
	return S_OK;
	
ERROR_EXIT:
	if (m_rtpsock)
	{
		delete m_rtpsock;
		m_rtpsock = NULL;
	}
	if (m_rtcpsock)
	{
		delete m_rtcpsock;
		m_rtcpsock = NULL;
	}

	return hr;

}



BOOL CRTPSession::SelectPorts()
{

	// try port pairs in the dynamic range ( > 49152)
	if (g_alport <= IPPORT_FIRST_DYNAMIC_END)
		g_alport = IPPORT_FIRST_DYNAMIC_BEGIN;



	for (;g_alport >= IPPORT_FIRST_DYNAMIC;)
	{
	    m_rtpsock->SetLocalPort(g_alport);
	
	    if (m_rtpsock->BindMe() == 0)
	    {
	        /* it worked for the data, try the adjacent port for control*/
	        ++g_alport;

			m_rtcpsock->SetLocalPort(g_alport);
			if (m_rtcpsock->BindMe() == 0)
			{
				g_alport-=3;
				return TRUE;
			}
			else	// start over at the previous even numbered port
			{
				if( WSAGetLastError() != WSAEADDRINUSE)
				{
	    			DEBUGMSG(ZONE_DP,("ObjRTPSession::SelectPorts failed with error %d\n",WSAGetLastError()));
					goto ERROR_EXIT;
				}
				m_rtpsock->Cleanup();
				if(!m_rtpsock->NewSock())
				{
					ASSERT(0);
					return FALSE;
				}
	        	g_alport-=3;	
	        	continue;
	        }

	    }
	    if (WSAGetLastError() != WSAEADDRINUSE)
	    {
	    	DEBUGMSG(ZONE_DP,("ObjRTPSession::SelectPorts failed with error %d\n",WSAGetLastError()));
	       goto ERROR_EXIT;
	    }
	    g_alport-=2; // try the next lower even numbered port
	}
	
ERROR_EXIT:
	m_rtcpsock->SetLocalPort(0);
	m_rtpsock->SetLocalPort(0);
	return FALSE;
}

STDMETHODIMP CRTPSession::SetLocalAddress(BYTE *pbAddr, UINT cbAddr)
{
	HRESULT hr;
	SOCKADDR_IN *pAddr = (SOCKADDR_IN *)pbAddr;
	ASSERT(pbAddr);
	
	Lock();
	if ( IsMulticast(pAddr))
		hr = SetMulticastAddress(pAddr);
	else
	if (m_rtpsock->GetLocalAddress()->sin_port != 0)
		hr =  S_OK;	// already bound
	else
	{
		m_rtpsock->SetLocalAddress(pAddr);
		m_rtcpsock->SetLocalAddress(pAddr);
		if (pAddr->sin_port != 0)
		{
			// port already chosen
			m_rtcpsock->SetLocalPort(ntohs(pAddr->sin_port) + 1);
			if (m_rtpsock->BindMe() != 0 ||  m_rtcpsock->BindMe() != 0)
			{
				hr = HRESULT_FROM_WIN32(GetLastError());
				m_rtpsock->SetLocalPort(0);
				m_rtcpsock->SetLocalPort(0);
			}
			else
				hr = S_OK;
		}
		else
		{
			// client wants us to choose the port

			if (SelectPorts()) {
				hr = S_OK;
			}
			else
				hr = HRESULT_FROM_WIN32(GetLastError());
		}
	}
	Unlock();
	return hr;
}

HRESULT
CRTPSession::SetMulticastAddress(PSOCKADDR_IN pAddr)
{
	SOCKET s ;
	SOCKADDR_IN rtcpAddr = *pAddr;
	s = RRCMws.WSAJoinLeaf( m_rtpsock->GetSock(), (struct sockaddr *)pAddr, sizeof(SOCKADDR_IN), NULL, NULL, NULL, NULL, JL_BOTH);
	if (s == INVALID_SOCKET)
		return E_FAIL;
	else {
		rtcpAddr.sin_port = htons(ntohs(pAddr->sin_port)+1);
		s = RRCMws.WSAJoinLeaf( m_rtcpsock->GetSock(), (struct sockaddr *)&rtcpAddr, sizeof(SOCKADDR_IN), NULL, NULL, NULL, NULL, JL_BOTH);
			
		return S_OK;
	}
}


STDMETHODIMP
CRTPSession::SetRemoteRTPAddress(BYTE *sockaddr, UINT cbAddr)
{
	SOCKADDR_IN *pRTPAddr = (SOCKADDR_IN *)sockaddr;
	Lock();
	
	if (pRTPAddr) {
#ifdef DEBUG
		if (m_rtpsock->GetRemoteAddress()->sin_addr.s_addr != INADDR_ANY
			&& m_rtpsock->GetRemoteAddress()->sin_addr.s_addr != pRTPAddr->sin_addr.s_addr) {
			DEBUGMSG(ZONE_DP,("Changing RTP Session remote address (already set)!\n"));
		}
#endif
		m_rtpsock->SetRemoteAddr(pRTPAddr);
	}

	Unlock();
	return S_OK;
}


STDMETHODIMP
CRTPSession::SetRemoteRTCPAddress(BYTE *sockaddr, UINT cbAddr)
{
	SOCKADDR_IN *pRTCPAddr = (SOCKADDR_IN *)sockaddr;
	
	Lock();
	
	if (pRTCPAddr) {
#ifdef DEBUG
		if (m_rtcpsock->GetRemoteAddress()->sin_addr.s_addr != INADDR_ANY
			&& m_rtcpsock->GetRemoteAddress()->sin_addr.s_addr != pRTCPAddr->sin_addr.s_addr) {
			DEBUGMSG(ZONE_DP,("Changing RTCP Session remote address (already set)!\n"));
		}
#endif
		m_rtcpsock->SetRemoteAddr(pRTCPAddr);
		if (m_hRTPSession)
			updateRTCPDestinationAddress( m_hRTPSession,
			(SOCKADDR *)m_rtcpsock->GetRemoteAddress(), sizeof(SOCKADDR_IN));
	}
	Unlock();
	return S_OK;
}

STDMETHODIMP
CRTPSession::GetLocalAddress(const BYTE **sockaddr, UINT *pcbAddr)
{
	if (sockaddr && pcbAddr)
	{
		Lock();
		*sockaddr = (BYTE *)m_rtpsock->GetLocalAddress();
		*pcbAddr = sizeof(SOCKADDR_IN);
		Unlock();
		return S_OK;
	} else
	{
		return E_INVALIDARG;
	}
}

STDMETHODIMP
CRTPSession::GetRemoteRTPAddress(const BYTE **sockaddr, UINT *pcbAddr)
{
	if (sockaddr && pcbAddr )
	{
		Lock();
		*sockaddr = (BYTE *)m_rtpsock->GetRemoteAddress();
		*pcbAddr = sizeof(SOCKADDR_IN);
		Unlock();
		return S_OK;
	} else
	{
		return E_INVALIDARG;
	}
}

STDMETHODIMP
CRTPSession::GetRemoteRTCPAddress(const BYTE **sockaddr, UINT *pcbAddr)
{
	if (sockaddr && pcbAddr)
	{
		Lock();
		*sockaddr = (BYTE *)m_rtcpsock->GetRemoteAddress();
		*pcbAddr = sizeof(SOCKADDR_IN);
		Unlock();
		return S_OK;
	} else
	{
		return E_INVALIDARG;
	}
}

STDMETHODIMP
CRTPSession::SetSendFlowspec(FLOWSPEC *pFlowspec)
{
	QOS_DESTADDR qosDest;
	DWORD cbRet;
	int optval = pFlowspec->MaxSduSize;
	// Set the RTP socket to not buffer more than one packet
	// This will allow us to influence the packet scheduling.
	if(RRCMws.setsockopt(m_rtpsock->GetSock(),SOL_SOCKET, SO_SNDBUF,(char *)&optval,sizeof(optval)) != 0)
	{
	
		RRCM_DBG_MSG ("setsockopt failed ", GetLastError(),
					  __FILE__, __LINE__, DBG_ERROR);
	}

	if (WSQOSEnabled && m_rtpsock)
	{
    	
		m_Qos.SendingFlowspec = *pFlowspec;
		m_Qos.ProviderSpecific.buf = (char *)&qosDest;	// NULL
		m_Qos.ProviderSpecific.len = sizeof (qosDest);	// 0

		// check to see if the receive flowspec has already been
		// set.  If it has, specify NOCHANGE for the receive service
		// type.  If not, specify NOTRAFFIC.  This is done to circumvent
		// a bug in the Win98 QOS/RSVP layer.

		if (m_Qos.ReceivingFlowspec.TokenRate == QOS_NOT_SPECIFIED)
		{
			m_Qos.ReceivingFlowspec.ServiceType = SERVICETYPE_NOTRAFFIC;
		}
		else
		{
			m_Qos.ReceivingFlowspec.ServiceType = SERVICETYPE_NOCHANGE;
		}

		qosDest.ObjectHdr.ObjectType = QOS_OBJECT_DESTADDR;
		qosDest.ObjectHdr.ObjectLength = sizeof(qosDest);
		qosDest.SocketAddress = (PSOCKADDR)m_rtpsock->GetRemoteAddress();
		qosDest.SocketAddressLength = sizeof(SOCKADDR_IN);
		if (RRCMws.WSAIoctl(m_rtpsock->GetSock(),SIO_SET_QOS, &m_Qos, sizeof(m_Qos), NULL, 0, &cbRet, NULL,NULL) == 0)
			return S_OK;
		else
			return GetLastError();
	} else
		return E_NOTIMPL;
	
}

STDMETHODIMP
CRTPSession::SetRecvFlowspec(FLOWSPEC *pFlowspec)
{

	SOCKADDR_IN *pAddr = NULL;

	DWORD cbRet;
	if (WSQOSEnabled && m_rtpsock)
	{

		pAddr = m_rtpsock->GetRemoteAddress();

		m_Qos.ReceivingFlowspec = *pFlowspec;
		m_Qos.ProviderSpecific.buf = NULL;
		m_Qos.ProviderSpecific.len = 0;

		// check to see if the send flowspec has already been
		// set.  If it has, specify NOCHANGE for the receive service
		// type.  If not, specify NOTRAFFIC.  This is done to circumvent
		// a bug in the Win98 QOS/RSVP layer.

		if (m_Qos.SendingFlowspec.TokenRate == QOS_NOT_SPECIFIED)
		{
			m_Qos.SendingFlowspec.ServiceType = SERVICETYPE_NOTRAFFIC;
		}
		else
		{
			m_Qos.SendingFlowspec.ServiceType = SERVICETYPE_NOCHANGE;
		}
		
		if (RRCMws.WSAIoctl(m_rtpsock->GetSock(),SIO_SET_QOS, &m_Qos, sizeof(m_Qos), NULL, 0, &cbRet, NULL,NULL) == 0)
			return S_OK;
		else
			return GetLastError();
	} else
		return E_NOTIMPL;
}

// set the size used for receive packet buffers
STDMETHODIMP
CRTPSession::SetMaxPacketSize(UINT maxPacketSize)
{
	m_uMaxPacketSize = maxPacketSize;
	return S_OK;
}

HRESULT CRTPSession::SetRecvNotification(
	PRTPRECVCALLBACK pRTPRecvCB,	// pointer to callback function
	DWORD_PTR dwCB,		// callback arg
	UINT nBufs							// suggested number of receives to post
	)
{
	CRTPPacket1 *pRTPPacket;
	if (!m_hRTPSession)
		return E_FAIL;
		
	m_pRTPCallback = pRTPRecvCB;
	m_dwCallback = dwCB;
	
	if (m_nBufsPosted >= nBufs)
		return S_OK;	// packets already posted

	int nBufsToAllocate = nBufs - m_nBufsPosted - m_FreePkts.GetCount();
	// allocate packets if necessary
	while (nBufsToAllocate-- > 0)
	{
		if (pRTPPacket = new CRTPPacket1) {
			if (!SUCCEEDED(pRTPPacket->Init(m_uMaxPacketSize)))
			{
				delete pRTPPacket;
				break;
			}
			m_FreePkts.Put(pRTPPacket);
		}
		else
			break;
	}
	PostRecv();
	return m_nBufsPosted ? S_OK : E_OUTOFMEMORY;		
}

HRESULT
CRTPSession::CancelRecvNotification()
{
	m_pRTPCallback = NULL;
	if (m_rtpsock) {
		struct sockaddr myaddr;
		int myaddrlen = sizeof(myaddr);
		UINT i;
		char buf = 0;
		WSABUF wsabuf;
		DWORD bytesSent;
		UINT nBufsPosted;
		wsabuf.buf = &buf;
		wsabuf.len = 0;
		BOOL fCanceled = FALSE;
		if (RRCMws.getsockname(m_rtpsock->GetSock(),&myaddr,&myaddrlen)== 0) {
		// send  loopback packets (as many as there are recvs outstanding)
		// on this socket to get back our buffers.
		// NOTE: Winsock 2 on Win95 seems to have a bug where we get recv callbacks
		// within sendto() rather than in the subsequent SleepEx, so we
		// have to make a local copy of m_nBufsPosted
			for (i=0, nBufsPosted = m_nBufsPosted;i < nBufsPosted;i++) {
				if (RRCMws.sendTo(m_rtpsock->GetSock(),&wsabuf,1,&bytesSent,0,&myaddr, myaddrlen, NULL, NULL) < 0) {
					DEBUGMSG(ZONE_DP,("CancelRecv: loopback send failed\n"));
					break;
				}
			}
			fCanceled = (i > 0);
		} else {
			DEBUGMSG(ZONE_DP,("RTPState::CancelRecv: getsockname returned %d\n",GetLastError()));
		}
		if (fCanceled)
			while (m_nBufsPosted) {
				DWORD dwStatus;
				dwStatus = SleepEx(200,TRUE);
	    		ASSERT(dwStatus==WAIT_IO_COMPLETION);
				if (dwStatus !=WAIT_IO_COMPLETION)
					break;		// timed out => bail
			}


	}
	return S_OK;
}

HRESULT
CRTPSession::PostRecv()
{
	HRESULT hr;
	DWORD dwError = 0;
	DWORD	dwRcvFlag;
	WSAOVERLAPPED *pOverlapped;
	DWORD nBytesRcvd;
	CRTPPacket1 *pRTPPacket;

	if (!m_hRTPSession || !m_pRTPCallback)
		return E_FAIL;

	// post buffers in the free queue
	while (m_FreePkts.Get(&pRTPPacket))
	{
		pOverlapped = (WSAOVERLAPPED *)(pRTPPacket->GetOverlapped());
		pOverlapped->hEvent = (WSAEVENT) this;

		m_rcvSockAddrLen = sizeof(SOCKADDR);

		dwRcvFlag = 0;
		pRTPPacket->RestoreSize();
		dwError = RRCMws.recvFrom (m_rtpsock->GetSock(),
								pRTPPacket->GetWSABUF(),
	                            1,
								&nBytesRcvd,
								&dwRcvFlag,
								&m_rcvSockAddr,
								&m_rcvSockAddrLen,
								pOverlapped,
								(LPWSAOVERLAPPED_COMPLETION_ROUTINE)WS2RecvCB);
		if (dwError == SOCKET_ERROR) {
			dwError = WSAGetLastError();
			if (dwError != WSA_IO_PENDING) {
				DEBUGMSG(ZONE_DP,("RTP recv error %d\n",dwError));
			//	m_rs.rcvStats.packetErrors++;
				// return the buffer to the free list
				m_FreePkts.Put(pRTPPacket);
				break;
			}
			
		}
		++m_nBufsPosted;
	}
	return m_nBufsPosted ? S_OK : S_FALSE;		
}

HRESULT
CRTPSession::FreePacket(WSABUF *pBuf)
{
	m_FreePkts.Put(CRTPPacket1::GetRTPPacketFromWSABUF(pBuf));
	PostRecv();
	return S_OK;
}

/*----------------------------------------------------------------------------
 * Function: WS2SendCB
 * Description: Winsock callback provided by the application to Winsock
 *
 * Input:
 *
 * Return: None
 *--------------------------------------------------------------------------*/
void CALLBACK WS2SendCB (DWORD dwError,
						 DWORD cbTransferred,
                         LPWSAOVERLAPPED lpOverlapped,
                         DWORD dwFlags)
{
	CRTPSession *pSess;
    //get the RTPSession pointer so that we can mark the
    //IO complete on the object
    pSess= (CRTPSession *)lpOverlapped->hEvent;
	ASSERT (&pSess->m_sOverlapped == lpOverlapped);
	pSess->m_lastSendError = dwError;
    pSess->m_fSendingSync=FALSE;
}

	
void CALLBACK WS2RecvCB (DWORD dwError,
						 DWORD len,
                         LPWSAOVERLAPPED lpOverlapped,
                         DWORD dwFlags)
{

	CRTPSession *pRTP;
	CRTPPacket1 *pRTPPacket;

	DWORD ts, ssrc;
	
	// GEORGEJ: catch Winsock 2 bug (94903) where I get a bogus callback
	// after WSARecv returns WSAEMSGSIZE.
	if (!dwError && ((int) len < 0)) {
		RRCM_DBG_MSG ("RTP : RCV Callback : bad cbTransferred", len,
						  __FILE__, __LINE__, DBG_ERROR);
		return;
	}
	pRTP = (CRTPSession *)lpOverlapped->hEvent;	// cached by PostRecv
	ASSERT(pRTP);
	ASSERT(lpOverlapped);
	ASSERT(pRTP->m_nBufsPosted > 0);
	--pRTP->m_nBufsPosted;	// one recv just completed

	// Winsock 2 sometimes chooses to indicate a buffer-too-small
	// error via the dwFlags parameter.
	if (dwFlags & MSG_PARTIAL)
		dwError = WSAEMSGSIZE;
	
	pRTPPacket = CRTPPacket1::GetRTPPacketFromOverlapped(lpOverlapped);
	if (!dwError)
	{
		// validate RTP header and update receive stats
		dwError = RTPReceiveCheck(
					pRTP->m_hRTPSession,
					pRTP->m_rtpsock->GetSock(),
					pRTPPacket->GetWSABUF()->buf,
					len,
					&pRTP->m_rcvSockAddr,
					pRTP->m_rcvSockAddrLen
					);
	}
	if (!pRTP->m_pRTPCallback)
	{
		// we have stopped doing notifications
		// return the buffer to the free list
		pRTP->FreePacket(pRTPPacket->GetWSABUF());
	}
	else if (!dwError) {
		// call the callback
		//++pRTP->m_nBufsRecvd;
		// convert the RTP header fields to host order
		pRTPPacket->SetTimestamp(ntohl(pRTPPacket->GetTimestamp()));
		pRTPPacket->SetSeq(ntohs(( u_short)pRTPPacket->GetSeq()));
		pRTPPacket->SetActual(len);
		//LOG((LOGMSG_NET_RECVD,pRTPPacket->GetTimestamp(), pRTPPacket->GetSeq(), GetTickCount()));
		if (!pRTP->m_pRTPCallback(pRTP->m_dwCallback, pRTPPacket->GetWSABUF()))
			pRTP->FreePacket(pRTPPacket->GetWSABUF());
	} else {
		// packet error
		// repost the buffer
		pRTP->PostRecv();
	}
}

// the way its defined now, this Send() method is synchronous or asynchronous
// depending on whether pOverlapped is NULL or not
HRESULT CRTPSession::Send(
	WSABUF *pWsabufs,
	UINT nWsabufs,
	WSAOVERLAPPED *pOverlapped,
	LPWSAOVERLAPPED_COMPLETION_ROUTINE pWSAPC )
{
	DWORD   dwError;

	Lock();
	RTP_HDR_T *pHdr = (RTP_HDR_T *)pWsabufs[0].buf;
	// convert RTP header fields to network-order
	pHdr->ts = htonl (pHdr->ts);
	pHdr->seq = htons(pHdr->seq);
	//*pHdr = m_ss.hdr;
	pHdr->seq = htons(++m_ss.hdr.seq);
	// update send stats
	//m_ss.packetsSent++;
	//m_ss.bytesSent += cbBuf-sizeof(RTP_HDR_MIN_LEN);
	//bIOPending=TRUE;	// reset when send completes

	dwError = RTPSendTo (
				  m_hRTPSession,
				  (m_rtpsock->GetSock()),
				  pWsabufs,
				  nWsabufs,
  				  &m_numBytesSend,
  				  0,	
  				  (LPVOID)m_rtpsock->GetRemoteAddress(),
				  sizeof(SOCKADDR),
  				  pOverlapped,
  				  pWSAPC);
	
	if (dwError == SOCKET_ERROR) {
		dwError = WSAGetLastError();
		if (dwError != WSA_IO_PENDING) {
			DEBUGMSG(1, ("RTPSendTo error %d\n",dwError));
			m_lastSendError = dwError;
			m_ss.sendStats.packetErrors++;
			m_fSendingSync = FALSE;
			goto ErrorExit;
		}
		dwError = 0;	// return success for ERROR_IO_PENDING
	}
		
ErrorExit:
	Unlock();
	return dwError;
}
void CRTPSession::RTCPNotify(
	int rrcmEvent,
	DWORD_PTR dwSSRC,
	DWORD_PTR rtcpsock)
{

	switch (rrcmEvent) {
	case RRCM_RECV_RTCP_SNDR_REPORT_EVENT:
		GetRTCPReport();
		//DispRTCPReport(rtcpsock);
		break;
	case RRCM_RECV_RTCP_RECV_REPORT_EVENT:
		GetRTCPReport();
		break;
	case RRCM_NEW_SOURCE_EVENT:
		RRCM_DBG_MSG ("RTP : New SSRC", 0,
						  __FILE__, __LINE__, DBG_TRACE);
		break;
	default:
		RRCM_DBG_MSG ("RTP : RRCMNotification", rrcmEvent,
						  __FILE__, __LINE__, DBG_TRACE);
	break;
	}
}

void RRCMNotification(
//	RRCM_EVENT_T rrcmEvent,
	int rrcmEvent,
	DWORD_PTR dwSSRC,
	DWORD_PTR rtcpsock,
	DWORD_PTR dwUser)
{
	if (dwUser)
		((CRTPSession *)dwUser)->RTCPNotify(rrcmEvent,dwSSRC,rtcpsock);


}

// Get the useful fields from the RTCP report and store them
// Only works for unicast sessions now (one sender, one receiver)
BOOL CRTPSession::GetRTCPReport()
{
#define MAX_RTCP_REPORT 2
	RTCP_REPORT 	rtcpReport[MAX_RTCP_REPORT];
	DWORD		moreEntries = 0;
	DWORD		numEntry = 0;
	DWORD		i;

	ZeroMemory(rtcpReport,sizeof(rtcpReport));
	// Get latest RTCP report
	// for all SSRCs in this session
	if (RTCPReportRequest ( m_rtcpsock->GetSock(),
						   0, &numEntry,
						   &moreEntries, MAX_RTCP_REPORT,
						   rtcpReport,
						   0,NULL,0))
		return FALSE;

	for (i = 0; i < numEntry; i++)
	{
		if (rtcpReport[i].status & LOCAL_SSRC_RPT)
		{
			m_ss.sendStats.ssrc =			rtcpReport[i].ssrc;
			m_ss.sendStats.packetsSent =	rtcpReport[i].dwSrcNumPcktRealTime;
			m_ss.sendStats.bytesSent = 		rtcpReport[i].dwSrcNumByteRealTime;
		} else {
			m_rs.rcvStats.ssrc = rtcpReport[i].ssrc;
			m_rs.rcvStats.packetsSent = rtcpReport[i].dwSrcNumPckt;
			m_rs.rcvStats.bytesSent = rtcpReport[i].dwSrcNumByte;
			m_rs.rcvStats.packetsLost = rtcpReport[i].SrcNumLost;
			m_rs.rcvStats.jitter = rtcpReport[i].SrcJitter;
			// Get the SR timestamp information
			m_rs.ntpTime = ((NTP_TS)rtcpReport[i].dwSrcNtpMsw << 32) + rtcpReport[i].dwSrcNtpLsw;
			m_rs.rtpTime = rtcpReport[i].dwSrcRtpTs;

			// check if any feedback information
			if (rtcpReport[i].status & FEEDBACK_FOR_LOCAL_SSRC_PRESENT)
			{
				DWORD prevPacketsLost = m_ss.sendStats.packetsLost;
				
				m_ss.sendStats.packetsLost = rtcpReport[i].feedback.cumNumPcktLost;
/*
				if (prevPacketsLost != m_ss.sendStats.packetsLost) {
					DEBUGMSG(ZONE_DP,("RTCP: fraction Lost=%d/256 , totalLost =%d, StreamClock=%d\n",rtcpReport[i].feedback.fractionLost,m_ss.sendStats.packetsLost,m_clockRate));
				}
*/
				m_ss.sendStats.jitter = 	rtcpReport[i].feedback.dwInterJitter;
			}
		}

	}
	m_ss.sendStats.packetsDelivered =	m_ss.sendStats.packetsSent - m_ss.sendStats.packetsLost;

	return TRUE;

}

// CRTPPacket1 methods

HRESULT CRTPPacket1::Init(UINT uMaxPacketSize)
{
	m_wsabuf.buf = new char [uMaxPacketSize];
	if (!m_wsabuf.buf)
		return E_OUTOFMEMORY;
	m_wsabuf.len = uMaxPacketSize;
	m_cbSize = uMaxPacketSize;

	return S_OK;
}

CRTPPacket1::~CRTPPacket1()
{
	if (m_wsabuf.buf)
		delete [] m_wsabuf.buf;
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\rrcm\rtp\rtpsess.h ===
// RTPSession.h : Declaration of the CRTPSession

#ifndef __RTPSESSION_H_
#define __RTPSESSION_H_

#include "resource.h"       // main symbols
#include "queue.h"

#ifndef MAX_MISORDER
const int MAX_MISORDER =20;
#endif
const int MAX_DROPPED =30;

typedef short PORT;




typedef unsigned __int64 NTP_TS;


//typedef void (* PRTPRECVCALLBACK)(DWORD dwStatus, DWORD_PTR dwCallback, NETBUF *pNetBuf, DWORD ssrc, DWORD ts, UINT seq, BOOL fMark);

typedef struct {
	UINT sessionId;
	UINT mediaId;
	BOOL fSend;
	PSOCKADDR_IN pLocalAddr;
	PSOCKADDR_IN pLocalRTCPAddr;
	PSOCKADDR_IN pRemoteAddr;
	PSOCKADDR_IN pRemoteRTCPAddr;
} RTPCHANNELDESC;

typedef struct {
	RTP_HDR_T hdr;	// header template for quick formatting
	RTP_STATS sendStats;	// statistics
} RTP_SEND_STATE;

typedef struct {
	RTP_STATS rcvStats;	// statistics
	NTP_TS ntpTime;
	DWORD rtpTime;
	
} RTP_RECV_STATE;


// generic UDP socket wrapper
// defined in its entirety here
class UDPSOCKET {
	SOCKET Sock;
	SOCKADDR_IN local_sin;
	SOCKADDR_IN remote_sin;	
	int local_sin_len;
	int remote_sin_len;

public:
	UDPSOCKET()  {
		ZeroMemory(&local_sin,sizeof(local_sin));
		ZeroMemory(&remote_sin,sizeof(remote_sin));
		Sock = INVALID_SOCKET;}
	~UDPSOCKET()
	{
		Cleanup();
	}

	VOID SetRemoteAddr(PSOCKADDR_IN psin) {remote_sin = *psin;};
	VOID SetLocalAddress(PSOCKADDR_IN psin) {local_sin = *psin;};
	PSOCKADDR_IN GetLocalAddress() {return &local_sin;};
	PSOCKADDR_IN GetRemoteAddress() {return &remote_sin;};
	VOID SetRemotePort(PORT port) {remote_sin.sin_port = htons(port);};
	VOID SetLocalPort(PORT port) {local_sin.sin_port = htons(port);};
	PORT GetRemotePort() {return (ntohs(remote_sin.sin_port));};
	PORT GetLocalPort() {return(ntohs(local_sin.sin_port));};
	SOCKET GetSock() {return Sock;};
	BOOL NewSock()
	{
		if(Sock == INVALID_SOCKET)
		{
				
			Sock = (*RRCMws.WSASocket) (AF_INET,
							  SOCK_DGRAM,
							  WS2Enabled ? FROM_PROTOCOL_INFO : 0,
							  &RRCMws.RTPProtInfo,
							  0,
							  WSA_FLAG_OVERLAPPED);
		}
		return(Sock != INVALID_SOCKET);
	}

	VOID Cleanup()
	{
		if(Sock != INVALID_SOCKET)
		{
			(*RRCMws.closesocket)(Sock);
			Sock = INVALID_SOCKET;
		}

	}
	int BindMe()
	{
		return (*RRCMws.bind)(Sock, (LPSOCKADDR)&local_sin, sizeof (local_sin));
	}

};

/////////////////////////////////////////////////////////////////////////////
// CRTPPacket (internal object representing a received RTPPacket)
class  CRTPPacket1
{
public:
	CRTPPacket1()
	{
		m_wsabuf.buf = NULL;
		m_wsabuf.len = 0;
		m_cbSize = 0;

	}
	~CRTPPacket1();

public:

	HRESULT Init(UINT cbMaxSize);	// allocates buffer of size cbMaxSize
	
	WSAOVERLAPPED *GetOverlapped() {return &m_overlapped;}
	void SetActual(UINT len) {m_wsabuf.len = len;}
	void RestoreSize() {m_wsabuf.len = m_cbSize;}
	static CRTPPacket1 *GetRTPPacketFromOverlapped(WSAOVERLAPPED *pOverlapped)
	{
		return ( (CRTPPacket1 *)((char *)pOverlapped - (UINT_PTR)(&((CRTPPacket1 *)0)->m_overlapped)));
	}
	static CRTPPacket1 *GetRTPPacketFromWSABUF(WSABUF *pBuf)
	{
		return ( (CRTPPacket1 *)((char *)pBuf - (UINT_PTR)(&((CRTPPacket1 *)0)->m_wsabuf)));
	}
	WSABUF *GetWSABUF() {return &m_wsabuf;}
	DWORD GetTimestamp() {return (((RTP_HDR_T *)m_wsabuf.buf)->ts);}
	void SetTimestamp(DWORD timestamp) {((RTP_HDR_T *)m_wsabuf.buf)->ts = timestamp;}
	UINT GetSeq() {return (((RTP_HDR_T *)m_wsabuf.buf)->seq);}
	void SetSeq(UINT seq) {((RTP_HDR_T *)m_wsabuf.buf)->seq = (WORD)seq;}
	BOOL GetMarkBit() {return (((RTP_HDR_T *)m_wsabuf.buf)->m);}
private:
	WSAOVERLAPPED m_overlapped;
	WSABUF m_wsabuf;
	UINT m_cbSize;	// (max) size of packet
};


/////////////////////////////////////////////////////////////////////////////
// CRTPSession
class ATL_NO_VTABLE CRTPSession :
	public CComObjectRootEx<CComMultiThreadModel>,
//	public CComCoClass<CRTPSession, &CLSID_RTPSession>,
	public IRTPSend,
	public IRTPSession,
	public IRTPRecv
{
public:
	CRTPSession();
	HRESULT FinalRelease();

	

//DECLARE_REGISTRY_RESOURCEID(IDR_RTPSESSION)

BEGIN_COM_MAP(CRTPSession)
	COM_INTERFACE_ENTRY(IRTPSend)
	COM_INTERFACE_ENTRY(IRTPSession)
	COM_INTERFACE_ENTRY(IRTPRecv)
END_COM_MAP()

// IRTPSend
public:
	STDMETHOD(Send)(
		WSABUF *pWsabufs,
		UINT nWsabufs,
		WSAOVERLAPPED *pOverlapped,
		LPWSAOVERLAPPED_COMPLETION_ROUTINE pWSAPC );
	STDMETHOD(GetSendStats)(RTP_STATS *pSendStats) {
		*pSendStats = m_ss.sendStats;return S_OK;
	}

// IRTPRecv
	STDMETHOD(SetRecvNotification) (PRTPRECVCALLBACK , DWORD_PTR dwCallback, UINT nBufs);
	STDMETHOD(CancelRecvNotification) ();
	// called by CRTPMediaStream to free accumulated packets
	STDMETHOD (FreePacket)(WSABUF *pBuf) ;
	STDMETHOD(GetRecvStats)(RTP_STATS *pSendStats) {
		*pSendStats = m_rs.rcvStats;return S_OK;
	}


// IRTPSession
	STDMETHOD(SetLocalAddress)(BYTE *sockaddr, UINT cbAddr);
	STDMETHOD(SetRemoteRTPAddress)(BYTE *sockaddr, UINT cbAddr);
	STDMETHOD(SetRemoteRTCPAddress)(BYTE *sockaddr, UINT cbAddr);
	STDMETHOD(GetLocalAddress)(const BYTE **sockaddr, UINT *pcbAddr);
	STDMETHOD(GetRemoteRTPAddress)(const BYTE **sockaddr, UINT *pcbAddr);
	STDMETHOD(GetRemoteRTCPAddress)(const BYTE **sockaddr, UINT *pcbAddr);
	STDMETHOD(CreateRecvRTPStream)(DWORD ssrc, IRTPRecv **ppIRTPRecv);
	STDMETHOD(SetSendFlowspec)(FLOWSPEC *pSendFlowspec);
	STDMETHOD(SetRecvFlowspec)(FLOWSPEC *pRecvFlowspec);
	STDMETHOD (SetMaxPacketSize) (UINT cbPacketSize);

// other non-COM methods
	// called by CRTPMediaStream to request that receive buffers be posted
	HRESULT PostRecv();

private:
	
	UDPSOCKET *m_rtpsock;
	UDPSOCKET *m_rtcpsock;
	UINT m_sessionId;
	UINT m_mediaId;
	class CRTPSession *m_pSessNext;
	static class CRTPSession *m_pSessFirst;

	HANDLE			m_hRTPSession;
	QOS	m_Qos;
	
	UINT m_clockRate;

	// receive stuff
	UINT m_uMaxPacketSize;
	QueueOf<CRTPPacket1 *> m_FreePkts;
	UINT m_nBufsPosted;
	// this should be per remote SSRC
	PRTPRECVCALLBACK m_pRTPCallback;
	DWORD_PTR m_dwCallback;
	RTP_RECV_STATE m_rs;
	
	// used by RTPRecvFrom()
	int m_rcvSockAddrLen;
	SOCKADDR m_rcvSockAddr;

	// send stuff
	DWORD			m_numBytesSend;
	int m_lastSendError;
	WSAOVERLAPPED	m_sOverlapped;	// used only for synchronous Send()
	BOOL 	m_fSendingSync;			// TRUE if m_sOverlapped is in use
	RTP_SEND_STATE m_ss;
	
	HRESULT Initialize(UINT sessionId, UINT mediaId,BYTE *sockaddr, UINT cbAddr);
	BOOL SelectPorts();
	HRESULT SetMulticastAddress(PSOCKADDR_IN );

	friend void RRCMNotification(int ,DWORD_PTR,DWORD_PTR,DWORD_PTR);
	friend void CALLBACK WS2SendCB (DWORD ,	DWORD, LPWSAOVERLAPPED, DWORD );
	friend void CALLBACK WS2RecvCB (DWORD ,	DWORD, LPWSAOVERLAPPED, DWORD );
	friend class CRTP;


	void RTCPNotify(int,DWORD_PTR dwSSRC,DWORD_PTR rtcpsock);

	BOOL GetRTCPReport();

};

typedef CComObject<CRTPSession> ObjRTPSession;	// instantiable class


/////////////////////////////////////////////////////////////////////////////
// CRTP - top level RTP interface
//
class ATL_NO_VTABLE CRTP:
	public CComObjectRootEx<CComMultiThreadModel>,
	public CComCoClass<CRTP, &CLSID_RTP>,
	public IRTP
{
public:

DECLARE_REGISTRY_RESOURCEID(IDR_RTP)

BEGIN_COM_MAP(CRTP)
	COM_INTERFACE_ENTRY(IRTP)
END_COM_MAP()

// IRTP
public:
	STDMETHOD(OpenSession)(
			UINT sessionId,	// client specified unique identifier for the session
			DWORD flags,	// SESSION_SEND, SESSION_RECV, SESSION_MULTICAST
			BYTE *localAddr, // Local  socket interface addr to bind to
			UINT cbAddr,	// sizeof(SOCKADDR)
			IRTPSession **ppIRTP); // [output] pointer to RTPSession

//	STDMETHOD(CreateSink)( IRTPSink **ppIRTPSink);
private:
	static BOOL m_WSInitialized;
};

#endif //__RTPSINK_H_

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\rrcm\rtp\rtp_hash.cpp ===
/*----------------------------------------------------------------------------
 * File:        RTP_HASH.C
 * Product:     RTP/RTCP implementation
 * Description: Associate sockets/streams with their RTP Session in a hash table
 *
 *
 * INTEL Corporation Proprietary Information
 * This listing is supplied under the terms of a license agreement with 
 * Intel Corporation and may not be copied nor disclosed except in 
 * accordance with the terms of that agreement.
 * Copyright (c) 1995 Intel Corporation. 
 *--------------------------------------------------------------------------*/

	
#include "rrcm.h"


/*---------------------------------------------------------------------------
/							Global Variables
/--------------------------------------------------------------------------*/            
extern PRTP_CONTEXT	pRTPContext;


/*---------------------------------------------------------------------------
/							External Variables
/--------------------------------------------------------------------------*/





/*----------------------------------------------------------------------------
 * Function   : createHashEntry
 * Description: Adds stream unique socket ID to hash table.  
 * 
 * Input :  pSession	:  RTP Session containing the stream
 *			socket		: unique socket ID for stream
 *
 * Return: RRCM_NoError		= OK.
 *         Otherwise(!=0)	= Initialization Error.
 ---------------------------------------------------------------------------*/
DWORD createHashEntry (PRTP_SESSION pSession, 
					   SOCKET socket)
	{
	PRTP_HASH_LIST  pNewCell;
	WORD			hashEntry;
	DWORD			dwStatus = RRCM_NoError;
	DWORD			hashTableEntries = NUM_RTP_HASH_SESS;

	IN_OUT_STR ("RTP : Enter createHashEntry()\n");
	
	// Get a PRTP Buffer from the free list	and assign the values
	pNewCell = (PRTP_HASH_LIST)removePcktFromTail(
					(PLINK_LIST)&pRTPContext->pRTPHashList,
					&pRTPContext->critSect);

	if (pNewCell == NULL)
		{

		if ( allocateLinkedList (&pRTPContext->pRTPHashList, 
								 pRTPContext->hHashFreeList,
								 &hashTableEntries,
				 				 sizeof(RTP_HASH_LIST),
								 &pRTPContext->critSect) == RRCM_NoError)
	
		{		 						
			pNewCell = (PRTP_HASH_LIST)removePcktFromTail (
										(PLINK_LIST)&pRTPContext->pRTPHashList,
										&pRTPContext->critSect);
			}
		}

	if (pNewCell != NULL)
		{
		pNewCell->RTPsocket = socket;
		pNewCell->pSession  = pSession;

		// Get entry in table
		hashEntry = socket & HASH_MODULO;

		// Just insert the entry at the head of list
		addToHeadOfList (
			(PLINK_LIST)&pRTPContext->RTPHashTable[hashEntry].RTPHashLink,
			(PLINK_LIST)pNewCell,
			&pRTPContext->critSect);
		}
	else
		dwStatus = RRCMError_RTPResources;

	IN_OUT_STR ("RTP : Exit createHashEntry()\n");
	
	return (dwStatus);
	}


/*----------------------------------------------------------------------------
 * Function   : deleteHashEntry
 * Description: Searches hash table based on unique socket.  Deletes session from
 *					hash table and returns buffer to free list
 * 
 * Input : socket: unique socket ID for stream
 *
 *
 * Return: RRCM_NoError		= OK.
 *         Otherwise(!=0)	= Deletion Error.
 ---------------------------------------------------------------------------*/
DWORD deleteHashEntry (SOCKET socket)
	{
	PRTP_HASH_LIST  pNewCell;
	WORD			hashEntry;
	DWORD			dwStatus = RRCMError_RTPStreamNotFound;

	IN_OUT_STR ("RTP : Enter deleteHashEntry()\n");
	
	// Get entry in table
	hashEntry = socket & HASH_MODULO;

	// Search for entry in table.  if found, remove from RTPHashTable and insert
	//	back in free list
	for (pNewCell = (PRTP_HASH_LIST)pRTPContext->RTPHashTable[hashEntry].RTPHashLink.prev;
		 pNewCell != NULL;
		 pNewCell = (PRTP_HASH_LIST)pNewCell->RTPHashLink.next) 
		{
		if (pNewCell->RTPsocket == socket) 
			{
			EnterCriticalSection (&pRTPContext->critSect);

			if (pNewCell->RTPHashLink.prev == NULL) 
				{
				// first entry in the queue - update the tail pointer
				pRTPContext->RTPHashTable[hashEntry].RTPHashLink.prev = 
					pNewCell->RTPHashLink.next;

				// check if only one entry in the list 
				if (pNewCell->RTPHashLink.next == NULL)
					pRTPContext->RTPHashTable[hashEntry].RTPHashLink.next = NULL;
				else
					(pNewCell->RTPHashLink.next)->prev = NULL;
				}
			else if (pNewCell->RTPHashLink.next == NULL) 
				{
				// last entry in the queue - update the head pointer
				// this was the last entry in the queue
				pRTPContext->RTPHashTable[hashEntry].RTPHashLink.next = 
					pNewCell->RTPHashLink.prev;

				(pNewCell->RTPHashLink.prev)->next = NULL;
				}
			else
				{
				// in the middle of the list - link around it
				(pNewCell->RTPHashLink.prev)->next = pNewCell->RTPHashLink.next;
				(pNewCell->RTPHashLink.next)->prev = pNewCell->RTPHashLink.prev;
				}
	
			LeaveCriticalSection (&pRTPContext->critSect);			

			addToHeadOfList ((PLINK_LIST)&pRTPContext->pRTPHashList,
					 	  	 (PLINK_LIST)pNewCell,
							 &pRTPContext->critSect);
			
			dwStatus = RRCM_NoError;
			
			break;
			}
		}

	if (dwStatus != RRCM_NoError) 
		{
		RRCM_DBG_MSG ("RTP : ERROR - DeleteHashEntry()", 0, 
					  __FILE__, __LINE__, DBG_ERROR);
		}

	IN_OUT_STR ("RTP : Exit deleteHashEntry()\n");
	
	return (dwStatus);
	}


/*----------------------------------------------------------------------------
 * Function   : findSessionID
 * Description: Searches hash table based on unique socket to identify session ID
 * 
 * Input : socket: unique socket ID for stream
 *
 *
 * Return: Session ptr	= OK.
 *         NULL			= Search Error.
 ---------------------------------------------------------------------------*/
PRTP_SESSION findSessionID (SOCKET socket)
	{
	PRTP_HASH_LIST  pNewCell;
	WORD			hashEntry;
	PRTP_SESSION 	pSession = NULL;

	IN_OUT_STR ("RTP : Enter findSessionID()\n");
	
	// Get entry in table
	hashEntry = socket & HASH_MODULO;

	// Search for entry in table.  
	// If found, remove from RTPHashTable and insert back in free list
	for (pNewCell = (PRTP_HASH_LIST)pRTPContext->RTPHashTable[hashEntry].RTPHashLink.prev;
		 pNewCell != NULL;
		 pNewCell =  (PRTP_HASH_LIST)pNewCell->RTPHashLink.next) 
		{
		if (pNewCell->RTPsocket == socket) 
			{
			pSession = pNewCell->pSession;
			break;
			}
		}

	IN_OUT_STR ("RTP : Exit findSessionID()\n");
	
	return (pSession); 
	}


// [EOF]
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\rrcm\rtp\rtprecv.cpp ===
/*----------------------------------------------------------------------------
 * File:        RTPRECV.C
 * Product:     RTP/RTCP implementation
 * Description: Provides Receive Data Functionality.
 *
 * This listing is supplied under the terms 
 * of a license agreement with Intel Corporation and
 * many not be copied nor disclosed except in accordance
 * with the terms of that agreement.
 * Copyright (c) 1995 Intel Corporation. 
 *--------------------------------------------------------------------------*/


#include "rrcm.h"


/*---------------------------------------------------------------------------
/							Global Variables
/--------------------------------------------------------------------------*/            



/*---------------------------------------------------------------------------
/							External Variables
/--------------------------------------------------------------------------*/
extern PRTP_CONTEXT		pRTPContext;
extern RRCM_WS			RRCMws;

#if (defined(_DEBUG) || defined(PCS_COMPLIANCE))
//INTEROP
extern LPInteropLogger RTPLogger;
#endif

/*----------------------------------------------------------------------------
 * Function   : RTPReceiveCheck
 * Description: Called when a packet is received. Handles any statistical
 *				processing required for RTCP.  
 * 
 * Input :		hRTPSession: handle returned by CreateRTPSession
 				RTPsocket: socket on which the packet was received
 				char *pPacket: pointer to packet buffer
 *				cbTransferred:	Number of bytes in packet
 *				pFrom:			sender address
 *				fromlen:		sender address length
 *
 * !!! IMPORTANT NOTE !!!
 *   Currently assumes CSRC = 0
 * !!! IMPORTANT NOTE !!!
 *
 * Return: Status indicating if the packet is OK or has a problem
 ---------------------------------------------------------------------------*/
DWORD  RTPReceiveCheck (
						HANDLE hRTPSession,
						SOCKET RTPsocket,
						char *pPacket,
           				DWORD cbTransferred,
           				PSOCKADDR pFrom,
           				UINT fromlen
           				 )
	{
	PRTP_SESSION		pRTPSession = (PRTP_SESSION) hRTPSession;
	RTP_HDR_T 			*pRTPHeader = (RTP_HDR_T *)pPacket;
	PSSRC_ENTRY			pSSRC = NULL;
	DWORD				dwSSRC;
	DWORD				oldSSRC;
	PSSRC_ENTRY			pMySSRC;
	DWORD				dwStatus = 0;
	struct sockaddr_in	*pSSRCadr;

	IN_OUT_STR ("RTP : Enter RTPReceiveCheck()\n");


	ASSERT (pRTPSession);

	// If Winsock error or runt packet(used to cancel recvs), signal completion to application 
	// and do not repost.
	if (cbTransferred < RTP_HDR_MIN_LEN)
		{
		// don't report closeSocket() as an error when the application
		//  have some pending buffers remaining

		// notify the user if an error occured, so he can free up 
		// its receive resources. The byte count is set to 0

		return RTP_RUNT_PACKET;
		}

	// Perform validity checking
	ASSERT (pRTPHeader);

#if (defined(_DEBUG) || defined(PCS_COMPLIANCE))
	if (RTPLogger)
		{
		//INTEROP
		InteropOutput (RTPLogger,
					   (BYTE FAR*)(pRTPHeader),
					   (int)cbTransferred,
					   RTPLOG_RECEIVED_PDU | RTP_PDU);
		}
#endif

	// Check RTP Headers for validity.  If not valid, then repost buffers 
	// to the network layer for a new receive.
	if (validateRTPHeader (pRTPHeader) ) 
		{
		// Get pointer to SSRC entry table for this session
		// If SSRC in packet is > 1/2 MAX_RANGE of DWORD, start search from
		//	tail of SSRC list, otherwise, start from front
		RRCMws.ntohl (RTPsocket, pRTPHeader->ssrc, &dwSSRC);
					    
		if (dwSSRC > MAX_DWORD/2) 
			{
			pSSRC = searchforSSRCatTail (
				(PSSRC_ENTRY)pRTPSession->pRTCPSession->RcvSSRCList.prev,
				dwSSRC);
			}
		else 
			{
			pSSRC = searchforSSRCatHead (
				(PSSRC_ENTRY)pRTPSession->pRTCPSession->RcvSSRCList.next,
				dwSSRC);
			}

		// get my own SSRC used for this stream
		pMySSRC = searchForMySSRC (
			(PSSRC_ENTRY)pRTPSession->pRTCPSession->XmtSSRCList.prev,
			RTPsocket);
		ASSERT (pMySSRC);
		
		// is this SSRC already known on the receive list ?
		if (pSSRC == NULL) 
			{
			// don't create an entry for my own packet looping back on 
			// a mcast group where loopback has not been turned off
			if (pMySSRC->SSRC != dwSSRC)
				{
				// new party heard from. Create an entry for it
				pSSRC = createSSRCEntry (dwSSRC,
										 pRTPSession->pRTCPSession,
										 pFrom,
										 fromlen,
										 FALSE);

				// notify application if interested
				RRCMnotification (RRCM_NEW_SOURCE_EVENT, pSSRC, dwSSRC, 
								  pRTPHeader->pt);
				}
			else
				{
				// my own SSRC received back

				// A collision occurs if the SSRC in the rcvd packet is 
				// equal to mine, and the network transport address is
				// different from mine.
				// A loop occurs if after a collision has been resolved the
				// SSRC collides again from the same source transport address
				pSSRCadr = (PSOCKADDR_IN)&pMySSRC->from;
				if (((PSOCKADDR_IN)pFrom)->sin_addr.S_un.S_addr !=
					  pSSRCadr->sin_addr.S_un.S_addr)
					{
					// check if the source address is already in the 
					// conflicting table. This identifes that somebody out 
					// there is looping pckts back to me
					if (RRCMChkCollisionTable (pFrom, fromlen, pMySSRC))
						{
						RRCM_DBG_MSG ("RTP : Loop Detected ...", 0, NULL, 0,
										DBG_NOTIFY);

						// loop already known
						dwStatus |= SSRC_LOOP_DETECTED;
						}
					else
						{
						RRCM_DBG_MSG ("RTP : Collision Detected ...", 0, NULL, 0,
										DBG_NOTIFY);

						// create new entry in conflicting address table 
						RRCMAddEntryToCollisionTable (pFrom, fromlen, pMySSRC);

						// send RTCP BYE packet w/ old SSRC 
						RTCPsendBYE (pMySSRC, "Loop/collision detected");

						// select new SSRC
						oldSSRC = pMySSRC->SSRC;
						dwSSRC  = getSSRC (pMySSRC->pRTCPses->RcvSSRCList, 
										   pMySSRC->pRTCPses->XmtSSRCList);

					 	EnterCriticalSection (&pMySSRC->critSect);
						pMySSRC->SSRC = dwSSRC;
					 	LeaveCriticalSection (&pMySSRC->critSect);

						// create new entry w/ old SSRC plus actual source
						// transport address in our receive list side, so the 
						// packet actually en-route will be dealt with
						createSSRCEntry (oldSSRC,
										 pRTPSession->pRTCPSession,
										 pFrom,
										 fromlen,
										 FALSE);

						// notify application if interested
						RRCMnotification (RRCM_LOCAL_COLLISION_EVENT, 
										  pMySSRC, oldSSRC, 0);

						// loop already known
						dwStatus |= SSRC_COLLISION_DETECTED;
						}
					}
				else
					{
					// own packet looped back because the sender joined the
					// multicast group and loopback is not turned off
					dwStatus |= MCAST_LOOPBACK_NOT_OFF;
					}
				}
			}
		else if (pSSRC->dwSSRCStatus & THIRD_PARTY_COLLISION)
			{
			// this SSRC is marked as colliding. Reject the data
			dwStatus = THIRD_PARTY_COLLISION;
			}

		if (dwStatus == 0)
			{
			// do all the statistical updating stuff
			updateRTPStats (pRTPHeader, pSSRC, cbTransferred);

			// update the payload type for this SSRC
			pSSRC->PayLoadType = pRTPHeader->pt;

			}	// SSRCList != NULL
		}		// valid RTP Header
	else 
		{
		dwStatus |= INVALID_RTP_HEADER;
		}


	IN_OUT_STR ("RTP : Exit RTPReceiveCallback()\n");
	return dwStatus;
	}

/*----------------------------------------------------------------------------
 * Function   : validateRTPHeader
 * Description: Performs basic checking of RTP Header (e.g., version number 
 *				and	payload type range).
 * 
 * Input : pRTPHeader:	-> to an RTP header
 *
 * Return: TRUE, RTP Packet Header is valid
 *		   FALSE: Header is invalid
 ---------------------------------------------------------------------------*/
 BOOL validateRTPHeader(RTP_HDR_T *pRTPHeader)
	{   
	BOOL	bStatus = TRUE;

	IN_OUT_STR ("RTP : Enter validateRTPHeader()\n");

	if (! pRTPHeader)
		return FALSE;

	// Check version number is correct
	if (pRTPHeader->type != RTP_TYPE) 
		bStatus = FALSE;
	                                  
	// Next check that the Packet types look somewhat reasonable, 
	// at least out of the RTCP range
	if (pRTPHeader->pt >= RTCP_SR)
		bStatus = FALSE;

	IN_OUT_STR ("RTP : Exit validateRTPHeader()\n");
	
	return bStatus;
	}


#if 0
/*----------------------------------------------------------------------------
 * Function   : RTPRecvFrom
 * Description: Intercepts receive requests from app.  Handles any statistical
 *				processing required for RTCP.  Copies completion routine 
 *				from app and substitutes its own.  Apps completion routine
 *				will be called after RTP's completion routine gets called.
 * 
 * Input :	RTPsocket:			RTP socket descriptor
 *			pBuffers:			-> to WSAbuf structure
 *		  	dwBufferCount:		Buffer count in WSAbuf structure
 *			pNumBytesRecvd:		-> to number of bytes received
 *			pFlags:				-> to flags
 *			pFrom:				-> to the source address
 *			pFromLen:			-> to source address length
 *			pOverlapped:		-> to overlapped I/O structure
 *			pCompletionRoutine:	-> to completion routine
 *
 * Return: RRCM_NoError		= OK.
 *         Otherwise(!=0)	= Check RRCM.h file for references.
 ---------------------------------------------------------------------------*/
 DWORD WINAPI RTPRecvFrom (SOCKET RTPsocket,
					        LPWSABUF pBuffers,
						    DWORD  dwBufferCount,
						    LPDWORD pNumBytesRecvd, 
						    LPDWORD pFlags,
						    PSOCKADDR pFrom,
						    LPINT pFromlen,
						    LPWSAOVERLAPPED pOverlapped, 
						    LPWSAOVERLAPPED_COMPLETION_ROUTINE pCompletionRoutine)
	{
	int					dwStatus = RRCM_NoError;
	int					dwError;
	PRTP_SESSION		pRTPSession;
	PRTP_BFR_LIST		pRCVStruct;

	IN_OUT_STR ("RTP : Enter RTPRecvFrom()\n");

	// If RTP context doesn't exist, report error and return.
	if (pRTPContext == NULL) 
		{
		RRCM_DBG_MSG ("RTP : ERROR - No RTP Instance", 0, 
						__FILE__, __LINE__, DBG_CRITICAL);
		IN_OUT_STR ("RTP : Exit RTPRecvFrom()\n");

		return (MAKE_RRCM_ERROR(RRCMError_RTPInvalid));
		}

	// Search for the proper session based on incoming socket
	pRTPSession = findSessionID(RTPsocket);
	if (pRTPSession == NULL)
		{
		RRCM_DBG_MSG ("RTP : ERROR - Invalid RTP session", 0, 
					  __FILE__, __LINE__, DBG_CRITICAL);
		IN_OUT_STR ("RTP : Exit RTPRecvFrom()\n");

		return (MAKE_RRCM_ERROR(RRCMError_RTPInvalidSession));
		}

	// We need to associate a completionRoutine's lpOverlapped with a 
	// session. We look at each buffer and associate a socket so when 
	// the completion routine is called, we can pull out the socket.
	if (dwStatus = saveRCVWinsockContext(pOverlapped,
										  pBuffers,
					   					  pCompletionRoutine,
					   					  pRTPSession,
					   					  dwBufferCount,
			  		   					  pNumBytesRecvd, 
					   					  pFlags,
					   					  pFrom,
					   					  pFromlen,
					   					  RTPsocket) != RRCM_NoError)
		{
		RRCM_DBG_MSG ("RTP : ERROR - Out of resources...", 0, 
					  __FILE__, __LINE__, DBG_NOTIFY);
		IN_OUT_STR ("RTP : Exit RTPRecvFrom()\n");

		return (MAKE_RRCM_ERROR(dwStatus));
		}

	// Forward to winsock, substituting our completion routine for the
	//	one handed to us.
	dwStatus = RRCMws.recvFrom (RTPsocket,
			   		  			pBuffers,
			              		dwBufferCount,
		   				  		pNumBytesRecvd, 
		   				  		pFlags,
		   				  		pFrom,
		    		  			pFromlen,
			   			  		pOverlapped,
			   			  		RTPReceiveCallback); 

	// Check if Winsock Call succeeded
	if (dwStatus != 0) 
		{
		// If serious error, the receive request won't proceed so
		//	we must undo all our work
		dwError = GetLastError();
		if ((dwError != WSA_IO_PENDING) && (dwError != WSAEMSGSIZE)) 
			{
			// Reinstate the Apps WSAEVENT
			pRCVStruct = (PRTP_BFR_LIST)pOverlapped->hEvent;
			pOverlapped->hEvent =  pRCVStruct->hEvent;

			RRCM_DBG_MSG ("RTP : ERROR - WSARecvFrom()", dwError, 
						  __FILE__, __LINE__, DBG_NOTIFY);

			// Return the struct to the free queue
			addToHeadOfList (&pRTPSession->pRTPFreeList,
					 	  	 (PLINK_LIST)pRCVStruct,
							 &pRTPSession->critSect);
			}
		}
	
	IN_OUT_STR ("RTP : Exit RTPRecvFrom()\n");

	return (dwStatus);
	}
	
/*----------------------------------------------------------------------------
 * Function   : RTPReceiveCallback
 * Description: Callback routine from Winsock2  Handles any statistical
 *				processing required for RTCP.  Copies completion routine 
 *				from app and substitutes its own.  Apps completion routine
 *				will be called after RTP's completion routine gets called.
 * 
 * Input :		dwError:		I/O completion error code
 *				cbTransferred:	Number of bytes transferred
 *				pOverlapped:	-> to overlapped I/O structure
 *				dwFlags:		Flags
 *
 * !!! IMPORTANT NOTE !!!
 *   Currently assumes CSRC = 0
 * !!! IMPORTANT NOTE !!!
 *
 * Return: None
 ---------------------------------------------------------------------------*/
void CALLBACK RTPReceiveCallback (DWORD dwError,
           				  		  DWORD cbTransferred,
           				  		  LPWSAOVERLAPPED pOverlapped,
           				  		  DWORD dwFlags)
	{
	PRTP_SESSION		pRTPSession;
	RTP_HDR_T 			*pRTPHeader;
	PRTP_BFR_LIST		pRCVStruct;
	PSSRC_ENTRY			pSSRC = NULL;
	DWORD				dwSSRC;
	DWORD				oldSSRC;
	PSSRC_ENTRY			pMySSRC;
	DWORD				dwRequeue = 0;
	struct sockaddr_in	*pSSRCadr;

	IN_OUT_STR ("RTP : Enter RTPReceiveCallback()\n");

	// GEORGEJ: catch Winsock 2 bug (94903) where I get a bogus callback
	// after WSARecv returns WSAEMSGSIZE.
	if (!dwError && ((int) cbTransferred < 0)) {
		RRCM_DBG_MSG ("RTP : RCV Callback : bad cbTransferred", cbTransferred, 
						  __FILE__, __LINE__, DBG_ERROR);
		return;
	}
	// The returning hEvent in the LPWSAOVERLAPPED struct contains the 
	// information mapping the session and the buffer.
	pRCVStruct = (PRTP_BFR_LIST)pOverlapped->hEvent;

	// Search for the proper session based on incoming socket
	pRTPSession = (PRTP_SESSION)pRCVStruct->pSession;
	ASSERT (pRTPSession);

	// If Winsock error or runt packet(used to cancel recvs), signal completion to application 
	// and do not repost.
	if (dwError || cbTransferred < RTP_HDR_MIN_LEN)
		{
		// don't report closeSocket() as an error when the application
		//  have some pending buffers remaining
		if ((dwError != 65534) && (dwError == WSA_OPERATION_ABORTED))
			{
			RRCM_DBG_MSG ("RTP : RCV Callback", dwError, 
						  __FILE__, __LINE__, DBG_ERROR);
			}

		// notify the user if an error occured, so he can free up 
		// its receive resources. The byte count is set to 0

		// Reinstate the AppSs WSAEVENT
		pOverlapped->hEvent = pRCVStruct->hEvent;
			
		// And call the apps completion routine
		pRCVStruct->pfnCompletionNotification (dwError,
					       					   cbTransferred,
						       				   pOverlapped,
						       				   dwFlags);

		// Return the struct to the free queue
		addToHeadOfList (&pRTPSession->pRTPFreeList,
				 	  	 (PLINK_LIST)pRCVStruct,
						 &pRTPSession->critSect);

		IN_OUT_STR ("RTP : Exit RTPReceiveCallback()\n");
		return;
		}

	// Perform validity checking
    pRTPHeader = (RTP_HDR_T *)pRCVStruct->pBuffer->buf;
	ASSERT (pRTPHeader);

#if (defined(_DEBUG) || defined(PCS_COMPLIANCE))
	if (RTPLogger)
		{
		//INTEROP
		InteropOutput (RTPLogger,
					   (BYTE FAR*)(pRCVStruct->pBuffer->buf),
					   (int)cbTransferred,
					   RTPLOG_RECEIVED_PDU | RTP_PDU);
		}
#endif

	// Check RTP Headers for validity.  If not valid, then repost buffers 
	// to the network layer for a new receive.
	if (validateRTPHeader (pRTPHeader) && (dwError == 0)) 
		{
		// Get pointer to SSRC entry table for this session
		// If SSRC in packet is > 1/2 MAX_RANGE of DWORD, start search from
		//	tail of SSRC list, otherwise, start from front
		RRCMws.ntohl (pRCVStruct->RTPsocket, pRTPHeader->ssrc, &dwSSRC);
					    
		if (dwSSRC > MAX_DWORD/2) 
			{
			pSSRC = searchforSSRCatTail (
				(PSSRC_ENTRY)pRTPSession->pRTCPSession->RcvSSRCList.prev,
				dwSSRC);
			}
		else 
			{
			pSSRC = searchforSSRCatHead (
				(PSSRC_ENTRY)pRTPSession->pRTCPSession->RcvSSRCList.next,
				dwSSRC);
			}

		// get my own SSRC used for this stream
		pMySSRC = searchForMySSRC (
			(PSSRC_ENTRY)pRTPSession->pRTCPSession->XmtSSRCList.prev,
			pRCVStruct->RTPsocket);
		ASSERT (pMySSRC);
		
		// is this SSRC already known on the receive list ?
		if (pSSRC == NULL) 
			{
			// don't create an entry for my own packet looping back on 
			// a mcast group where loopback has not been turned off
			if (pMySSRC->SSRC != dwSSRC)
				{
				// new party heard from. Create an entry for it
				pSSRC = createSSRCEntry (dwSSRC,
										 pRTPSession->pRTCPSession,
										 (PSOCKADDR)pRCVStruct->pFrom,
										 (DWORD)*pRCVStruct->pFromlen,
										 FALSE);

				// notify application if interested
				RRCMnotification (RRCM_NEW_SOURCE_EVENT, pSSRC, dwSSRC, 
								  pRTPHeader->pt);
				}
			else
				{
				// my own SSRC received back

				// A collision occurs if the SSRC in the rcvd packet is 
				// equal to mine, and the network transport address is
				// different from mine.
				// A loop occurs if after a collision has been resolved the
				// SSRC collides again from the same source transport address
				pSSRCadr = (PSOCKADDR_IN)&pMySSRC->from;
				if (((PSOCKADDR_IN)pRCVStruct->pFrom)->sin_addr.S_un.S_addr !=
					  pSSRCadr->sin_addr.S_un.S_addr)
					{
					// check if the source address is already in the 
					// conflicting table. This identifes that somebody out 
					// there is looping pckts back to me
					if (RRCMChkCollisionTable ((PSOCKADDR)pRCVStruct->pFrom,*pRCVStruct->pFromlen, pMySSRC))
						{
						RRCM_DBG_MSG ("RTP : Loop Detected ...", 0, NULL, 0,
										DBG_NOTIFY);

						// loop already known
						dwRequeue |= SSRC_LOOP_DETECTED;
						}
					else
						{
						RRCM_DBG_MSG ("RTP : Collision Detected ...", 0, NULL, 0,
										DBG_NOTIFY);

						// create new entry in conflicting address table 
						RRCMAddEntryToCollisionTable ((PSOCKADDR)pRCVStruct->pFrom,*pRCVStruct->pFromlen, pMySSRC);

						// send RTCP BYE packet w/ old SSRC 
						RTCPsendBYE (pMySSRC, "Loop/collision detected");

						// select new SSRC
						oldSSRC = pMySSRC->SSRC;
						dwSSRC  = getSSRC (pMySSRC->pRTCPses->RcvSSRCList, 
										   pMySSRC->pRTCPses->XmtSSRCList);

					 	EnterCriticalSection (&pMySSRC->critSect);
						pMySSRC->SSRC = dwSSRC;
					 	LeaveCriticalSection (&pMySSRC->critSect);

						// create new entry w/ old SSRC plus actual source
						// transport address in our receive list side, so the 
						// packet actually en-route will be dealt with
						createSSRCEntry (oldSSRC,
										 pRTPSession->pRTCPSession,
										 (PSOCKADDR)pRCVStruct->pFrom,
										 (DWORD)*pRCVStruct->pFromlen,
										 FALSE);

						// notify application if interested
						RRCMnotification (RRCM_LOCAL_COLLISION_EVENT, 
										  pMySSRC, oldSSRC, 0);

						// loop already known
						dwRequeue |= SSRC_COLLISION_DETECTED;
						}
					}
				else
					{
					// own packet looped back because the sender joined the
					// multicast group and loopback is not turned off
					dwRequeue |= MCAST_LOOPBACK_NOT_OFF;
					}
				}
			}
		else if (pSSRC->dwSSRCStatus & THIRD_PARTY_COLLISION)
			{
			// this SSRC is marked as colliding. Reject the data
			dwRequeue = THIRD_PARTY_COLLISION;
			}

		if ((pSSRC != NULL)  && (dwRequeue == 0))
			{
			// do all the statistical updating stuff
			updateRTPStats (pRTPHeader, pSSRC, cbTransferred);

			// update the payload type for this SSRC
			pSSRC->PayLoadType = pRTPHeader->pt;

			// Reinstate the AppSs WSAEVENT
			pOverlapped->hEvent = pRCVStruct->hEvent;
			
			// And call the apps completion routine
			pRCVStruct->pfnCompletionNotification (dwError,
						       					   cbTransferred,
							       				   pOverlapped,
							       				   dwFlags);

			// Return the struct to the free queue
			addToHeadOfList (&pRTPSession->pRTPFreeList,
					 	  	 (PLINK_LIST)pRCVStruct,
							 &pRTPSession->critSect);
			}	// SSRCList != NULL
		}		// valid RTP Header
	else 
		{
		dwRequeue |= INVALID_RTP_HEADER;
		}

	if (dwRequeue) 
		{
		// The RTP packet was invalid for some reason
		RTPpostRecvBfr (dwError, cbTransferred, pOverlapped, dwFlags);
		} 

	IN_OUT_STR ("RTP : Exit RTPReceiveCallback()\n");
	}


/*----------------------------------------------------------------------------
 * Function   : saveRCVWinsockContext
 * Description: Saves context for this buffer so that when a completion 
 *				routine	returns with a handle, we know exactly what 
 *				buffer/stream this refers to.
 * 
 * Input :		pOverlapped		:	-> to overlapped structure
 *				pBuffers		:	-> to WSA buffers
 *				pFunc			:	-> to completion routine 
 *				pSession		:	-> to the RTP session
 *				dwBufferCount	:	Number of WSA buffers
 *				pNumBytesRecvd	:	-> to number of bytes received 
 *				pFlags			:	-> to flags
 *				pFrom			:	-> to the From address field
 *				pFromlen		:	-> to the from address field length
 *				RTPsocket		:	RTP socket descriptor
 *
 * Return: RRCM_NoError		= OK.
 *         Otherwise(!=0)	= Check RRCM.h file for references.
 ---------------------------------------------------------------------------*/
DWORD CALLBACK saveRCVWinsockContext(LPWSAOVERLAPPED pOverlapped,
				   					 LPWSABUF pBuffers,
				   					 LPWSAOVERLAPPED_COMPLETION_ROUTINE pFunc, 
				   					 PRTP_SESSION pSession,
								   	 DWORD dwBufferCount,
							   		 LPDWORD pNumBytesRecvd, 
									 LPDWORD pFlags,
							      	 LPVOID pFrom,
							      	 LPINT pFromlen,
							      	 SOCKET RTPsocket)
	{
	PRTP_BFR_LIST	pNewCell;
	DWORD			dwStatus = RRCM_NoError;
	DWORD			numCells = NUM_FREE_CONTEXT_CELLS;

	IN_OUT_STR ("RTP : Enter saveRCVWinsockContext()\n");
	
	// Get a PRTP Buffer from the free list
	pNewCell = (PRTP_BFR_LIST)removePcktFromTail (
								(PLINK_LIST)&pSession->pRTPFreeList,
								&pSession->critSect);

	if (pNewCell == NULL)
		{
		// try to reallocate some free cells
		if (pSession->dwNumTimesFreeListAllocated <= MAXNUM_CONTEXT_CELLS_REALLOC)
			{
			// increment the number of reallocated times even if the realloc
			//   fails next. Will avoid trying to realloc of a realloc problem
			pSession->dwNumTimesFreeListAllocated++;

			if (allocateLinkedList (&pSession->pRTPFreeList, 
								    pSession->hHeapFreeList,
		   							&numCells,
	   								sizeof(RTP_BFR_LIST),
									&pSession->critSect) == RRCM_NoError)
				{		 						
				pNewCell = (PRTP_BFR_LIST)removePcktFromTail (
											(PLINK_LIST)&pSession->pRTPFreeList,
											&pSession->critSect);
				}
			}
		}

	if (pNewCell != NULL) 
		{
		// Initialize the params
		pNewCell->hEvent		  = pOverlapped->hEvent;
		pNewCell->pBuffer		  = pBuffers;
		pNewCell->pSession		  = pSession;
		pNewCell->dwFlags		  = *pFlags;
		pNewCell->pFrom			  = pFrom;
		pNewCell->pFromlen		  = pFromlen;
		pNewCell->RTPsocket		  = RTPsocket;
		pNewCell->dwBufferCount   = dwBufferCount;
		pNewCell->pfnCompletionNotification = pFunc;		
		
		// Overwrite the hEvent handed down from app.  
		// Will return the real one when the completion routine is called
		pOverlapped->hEvent = (WSAEVENT)pNewCell;
		}
	else
		dwStatus = RRCMError_RTPResources;

	IN_OUT_STR ("RTP : Exit saveRCVWinsockContext()\n");
	
	return (dwStatus);
	}



/*----------------------------------------------------------------------------
 * Function   : RTPpostRecvBfr
 * Description: RTP post a receive buffer to Winsock
 * 
 * Input :      dwError			: Error code
 *    			cbTransferred	: Bytes transferred
 *				pOverlapped		: -> to overlapped structure
 *				dwFlags			: Flags
 *
 * Return: 		None
 ---------------------------------------------------------------------------*/
 void RTPpostRecvBfr (DWORD dwError,
           			  DWORD cbTransferred,
           			  LPWSAOVERLAPPED pOverlapped,
           			  DWORD dwFlags)
	{
	DWORD			dwStatus;
	PRTP_BFR_LIST  	pRCVStruct;
	PRTP_SESSION	pRTPSession;

	IN_OUT_STR ("RTP : Enter RTPpostRecvBfr\n");

	// Reuse the packet with another receive
	pRCVStruct = (PRTP_BFR_LIST)pOverlapped->hEvent;

	// Corresponding RTP session
	pRTPSession = (PRTP_SESSION)pRCVStruct->pSession;

	dwStatus = RRCMws.recvFrom (pRCVStruct->RTPsocket,
		   			  			pRCVStruct->pBuffer,
			              		pRCVStruct->dwBufferCount,
			   			  		&cbTransferred, 
			   			  		&pRCVStruct->dwFlags,
			   			  		(PSOCKADDR)pRCVStruct->pFrom,
			    		  		pRCVStruct->pFromlen,
			   			  		pOverlapped, 
			   			  		RTPReceiveCallback); 

	// Check if Winsock Call succeeded
	if (dwStatus == SOCKET_ERROR) 
		{
		// If serious error, the receive request won't proceed
		dwStatus = GetLastError();
		if ((dwStatus != WSA_IO_PENDING) && (dwStatus != WSAEMSGSIZE)) 
			{
			RRCM_DBG_MSG ("RTP : ERROR - WSARecvFrom()", dwError, 
						  __FILE__, __LINE__, DBG_ERROR);

			// notify the user if an error occured, so he can free up 
			// its receive resources. The byte count is set to 0

			// Reinstate the AppSs WSAEVENT
			pOverlapped->hEvent = pRCVStruct->hEvent;
			
			// And call the apps completion routine
			pRCVStruct->pfnCompletionNotification (dwStatus,
					       					       0,
								       			   pOverlapped,
								       			   dwFlags);

			// Return the receive structure to the free list
			addToHeadOfList (&pRTPSession->pRTPFreeList,
					 	  	 (PLINK_LIST)pRCVStruct,
							 &pRTPSession->critSect);
			}
		}

	IN_OUT_STR ("RTP : Exit RTPpostRecvBfr\n");
	}
#endif


// [EOF]
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\rrcm\rtp\rtpmisc.cpp ===
/*----------------------------------------------------------------------------
 * File:        RRCMMISC.C
 * Product:     RTP/RTCP implementation.
 * Description: Provides common RTP/RTCP support functionality.
 *
 *
 * INTEL Corporation Proprietary Information
 * This listing is supplied under the terms of a license agreement with
 * Intel Corporation and may not be copied nor disclosed except in
 * accordance with the terms of that agreement.
 * Copyright (c) 1995 Intel Corporation.
 *--------------------------------------------------------------------------*/


#include "rrcm.h"


/*---------------------------------------------------------------------------
/							Global Variables
/--------------------------------------------------------------------------*/


/*---------------------------------------------------------------------------
/							External Variables
/--------------------------------------------------------------------------*/
#ifdef ENABLE_ISDM2
extern KEY_HANDLE hRRCMRootKey;
extern ISDM2	  Isdm2;
#endif

extern RRCM_WS	RRCMws;				

#ifdef _DEBUG
extern char		debug_string[];
#endif

#ifdef ISRDBG
extern WORD		ghISRInst;
#endif


/*--------------------------------------------------------------------------
 * Function   : searchForMySSRC
 * Description: Find the SSRC for this stream.
 *
 * Input :	pSSRC		:	-> to the SSRC entry
 *			RTPSocket	:	RTP socket descriptor
 *
 * Return: NULL 			==> Session not found.
 *         Buffer Address 	==> OK, Session ptr returned
 --------------------------------------------------------------------------*/
 PSSRC_ENTRY searchForMySSRC(PSSRC_ENTRY pSSRC,
							 SOCKET RTPSocket)
	{
	PSSRC_ENTRY	pRRCMSession;

	IN_OUT_STR ("RTP : Enter searchForMySSRC()\n");

	for (pRRCMSession = NULL;
		 (pSSRC != NULL);
		 pSSRC = (PSSRC_ENTRY)pSSRC->SSRCList.prev)
		{
		if (pSSRC->RTPsd == RTPSocket)
			{
			pRRCMSession = pSSRC;
			break;
			}
		}

	IN_OUT_STR ("RTP : Exit searchForMySSRC()\n");		

	return (pRRCMSession);
	}


/*--------------------------------------------------------------------------
 * Function   : searchforSSRCatHead
 * Description: Search through linked list of RTCP entries starting at the
 *					head of the list.
 *
 * Input :	pSSRC	:	-> to the SSRC entry
 *			ssrc	:	ssrc to look for
 *
 * Return: NULL 			==> Session not found.
 *         Non-NULL		 	==> OK, SSRC entry found
 --------------------------------------------------------------------------*/
 PSSRC_ENTRY searchforSSRCatHead(PSSRC_ENTRY pSSRC,
								 DWORD ssrc)					
	{
	PSSRC_ENTRY	pRRCMSession;

	IN_OUT_STR ("RTP : Enter searchForMySSRCatHead()\n");		
	
	for (pRRCMSession = NULL;
		 (pSSRC != NULL) &&
		 (pRRCMSession == NULL) && (ssrc <= pSSRC->SSRC);
		 pSSRC = (PSSRC_ENTRY)pSSRC->SSRCList.prev)
		{
		if (pSSRC->SSRC == ssrc)
			{
			pRRCMSession = pSSRC;
			}
		}

	IN_OUT_STR ("RTP : Exit searchForMySSRCatHead()\n");		 		

	return (pRRCMSession);
	}


/*--------------------------------------------------------------------------
 * Function   : searchforSSRCatTail
 * Description: Search through linked list of RTCP entries starting at the
 *					tail of the list.
 *
 * Input :	pSSRC	:	-> to the SSRC entry
 *			ssrc	:	SSRC to look for
 *
 * Return: NULL 			==> Session not found.
 *         Non-NULL		 	==> OK, SSRC entry found
 --------------------------------------------------------------------------*/
 PSSRC_ENTRY searchforSSRCatTail(PSSRC_ENTRY pSSRC,
								 DWORD ssrc)					
	{
	PSSRC_ENTRY	pRRCMSession;

	IN_OUT_STR ("RTP : Enter searchForMySSRCatTail()\n");		
	
	for (pRRCMSession = NULL;
		 (pSSRC != NULL) &&
		 (pRRCMSession == NULL) && (ssrc >= pSSRC->SSRC);
		 pSSRC = (PSSRC_ENTRY)pSSRC->SSRCList.next)
		{
		if (pSSRC->SSRC == ssrc)
			{
			pRRCMSession = pSSRC;
			}
		}

	IN_OUT_STR ("RTP : Exit searchForMySSRCatTail()\n");		
	
	return (pRRCMSession);
	}


/*---------------------------------------------------------------------------
 * Function   : saveNetworkAddress
 * Description: Saves the received or local network Address in the local
 *					context.
 *
 * Input :	pSSRCEntry	:	-> to the SSRC entry
 *			pNetAddr	:	-> to the network address
 *			addrLen		:	Address length
 *
 * Return:	OK: RRCM_NoError
 --------------------------------------------------------------------------*/
 DWORD saveNetworkAddress (PSSRC_ENTRY pSSRC,
 						   PSOCKADDR pNetAddr,
 						   int addrLen)
	{
	IN_OUT_STR ("RTP : Enter saveNetworkAddress()\n");		

	pSSRC->dwSSRCStatus |= NETWK_ADDR_UPDATED;
	pSSRC->fromLen = addrLen;
	memcpy (&pSSRC->from, pNetAddr, addrLen);

	IN_OUT_STR ("RTP : Exit saveNetworkAddress()\n");

	return RRCM_NoError;			
	}


/*---------------------------------------------------------------------------
 * Function   : updateRTCPDestinationAddress
 * Description: The applicatino updates the RTCP destination address
 *				
 * Input :	hRTPSess		:	RTP session
 *			pAddr		:	-> to address structure	of RTCP information
 *			addrLen		:	Address length
 *
 * Return: RRCM_NoError		= OK.
 *         Otherwise(!=0)	= Check RRCM.h file for references.
 --------------------------------------------------------------------------*/
 DWORD WINAPI updateRTCPDestinationAddress (HANDLE hRTPSess,
	 										 PSOCKADDR pRtcpAddr,
											 int addrLen)	
	{
	PRTP_SESSION	pRTPSession = (PRTP_SESSION) hRTPSess;
	PRTCP_SESSION	pRTCPses;

#ifdef ENABLE_ISDM2
	PSSRC_ENTRY		pSSRC;
#endif
	
	IN_OUT_STR ("RTP : Enter updateRTCPDestinationAddress()\n");

	if (pRTPSession == NULL)
		{
		RRCM_DBG_MSG ("RTP : ERROR - Invalid RTP session", 0,
					  __FILE__, __LINE__, DBG_CRITICAL);
		IN_OUT_STR ("RTP : Exit updateRTCPDestinationAddress()\n");

		return (MAKE_RRCM_ERROR(RRCMError_RTPInvalidSession));
		}

	// get the RTCP session
	pRTCPses = pRTPSession->pRTCPSession;
	if (pRTCPses == NULL)
		{
		RRCM_DBG_MSG ("RTP : ERROR - Invalid RTCP session", 0,
					  __FILE__, __LINE__, DBG_CRITICAL);
		IN_OUT_STR ("RTP : Exit updateRTCPDestinationAddress()\n");

		return (MAKE_RRCM_ERROR(RRCMError_RTCPInvalidSession));
		}

	if (!(pRTCPses->dwSessionStatus & RTCP_DEST_LEARNED))
		{
		pRTCPses->dwSessionStatus |= RTCP_DEST_LEARNED;
		pRTCPses->toLen = addrLen;
		memcpy (&pRTCPses->toBfr, pRtcpAddr, addrLen);

		// register our Xmt SSRC - Rcvd one will be found later
#ifdef ENABLE_ISDM2
		if (Isdm2.hISDMdll)
			{
			pSSRC = (PSSRC_ENTRY)pRTCPses->XmtSSRCList.prev;
			if (pSSRC != NULL)
				registerSessionToISDM (pSSRC, pRTCPses, &Isdm2);
			}
#endif
		}

	IN_OUT_STR ("RTP : Exit updateRTCPDestinationAddress()\n");

	return RRCM_NoError;
	}


/*---------------------------------------------------------------------------
 * Function   : updateSSRCentry
 * Description: The application updates some of the SSRC information
 *				
 * Input :	RTPsd		:	RTP socket descriptor
 *			updateType	:	Type of update desired
 *			updateInfo	:	Update information
 *			misc		:	Miscelleanous information
 *
 * Return: RRCM_NoError		= OK.
 *         Otherwise(!=0)	= Check RRCM.h file for references.
 --------------------------------------------------------------------------*/
 HRESULT WINAPI updateSSRCentry ( HANDLE hRTPSess,
 								  SOCKET RTPsd,
								  DWORD updateType,
	 						      DWORD_PTR updateInfo,
								  DWORD_PTR misc)	
	{
	PRTP_SESSION	pRTPSession = (PRTP_SESSION) hRTPSess;
	PRTCP_SESSION	pRTCPses;
	PSSRC_ENTRY		pSSRC;
	PLINK_LIST		pTmp;
	PSDES_DATA		pSdes;
	
	IN_OUT_STR ("RTP : Enter updateRTCPSdes ()\n");

	if (pRTPSession == NULL)
		{
		RRCM_DBG_MSG ("RTP : ERROR - Invalid RTP session", 0,
					  __FILE__, __LINE__, DBG_CRITICAL);
		IN_OUT_STR ("RTP : Exit updateRTCPSdes ()\n");

		return (MAKE_RRCM_ERROR(RRCMError_RTPInvalidSession));
		}

	// get the RTCP session
	pRTCPses = pRTPSession->pRTCPSession;
	if (pRTCPses == NULL)
		{
		RRCM_DBG_MSG ("RTP : ERROR - Invalid RTCP session", 0,
					  __FILE__, __LINE__, DBG_CRITICAL);
		IN_OUT_STR ("RTP : Exit updateRTCPSdes ()\n");

		return (MAKE_RRCM_ERROR(RRCMError_RTCPInvalidSession));
		}

	// search for the socket descriptor (unique per session)
	// walk through the list from the tail
	pTmp = (PLINK_LIST)pRTCPses->XmtSSRCList.prev;

	while (pTmp)
		{
		if (((PSSRC_ENTRY)pTmp)->RTPsd == RTPsd)
			{
			// lock access to this entry
			EnterCriticalSection (&((PSSRC_ENTRY)pTmp)->critSect);

			pSSRC = (PSSRC_ENTRY)pTmp;

			switch (updateType)
				{
				case RRCM_UPDATE_SDES:
					// update the SDES
					pSdes = (PSDES_DATA)updateInfo;

					switch (pSdes->dwSdesType)
						{
						case RTCP_SDES_CNAME:
							pSSRC->cnameInfo.dwSdesLength = pSdes->dwSdesLength;
							memcpy (pSSRC->cnameInfo.sdesBfr, pSdes->sdesBfr,
									pSdes->dwSdesLength);

							pSSRC->cnameInfo.dwSdesFrequency =
								frequencyToPckt (pSdes->dwSdesFrequency);
							pSSRC->cnameInfo.dwSdesEncrypted = pSdes->dwSdesEncrypted;
							break;

						case RTCP_SDES_NAME:
							pSSRC->nameInfo.dwSdesLength  = pSdes->dwSdesLength;
							memcpy (pSSRC->nameInfo.sdesBfr, pSdes->sdesBfr,
									pSdes->dwSdesLength);

							pSSRC->nameInfo.dwSdesFrequency =
								frequencyToPckt (pSdes->dwSdesFrequency);
							pSSRC->nameInfo.dwSdesEncrypted = pSdes->dwSdesEncrypted;
							break;

						case RTCP_SDES_EMAIL:
							pSSRC->emailInfo.dwSdesLength  = pSdes->dwSdesLength;
							memcpy (pSSRC->emailInfo.sdesBfr, pSdes->sdesBfr,
									pSdes->dwSdesLength);

							pSSRC->emailInfo.dwSdesFrequency =
								frequencyToPckt (pSdes->dwSdesFrequency);
							pSSRC->emailInfo.dwSdesEncrypted = pSdes->dwSdesEncrypted;
							break;

						case RTCP_SDES_PHONE:
							pSSRC->phoneInfo.dwSdesLength  = pSdes->dwSdesLength;
							memcpy (pSSRC->phoneInfo.sdesBfr, pSdes->sdesBfr,
									pSdes->dwSdesLength);

							pSSRC->phoneInfo.dwSdesFrequency =
								frequencyToPckt (pSdes->dwSdesFrequency);
							pSSRC->phoneInfo.dwSdesEncrypted = pSdes->dwSdesEncrypted;
							break;

						case RTCP_SDES_LOC:
							pSSRC->locInfo.dwSdesLength  = pSdes->dwSdesLength;
							memcpy (pSSRC->locInfo.sdesBfr, pSdes->sdesBfr,
									pSdes->dwSdesLength);

							pSSRC->locInfo.dwSdesFrequency =
								frequencyToPckt (pSdes->dwSdesFrequency);
							pSSRC->locInfo.dwSdesEncrypted = pSdes->dwSdesEncrypted;
							break;

						case RTCP_SDES_TOOL:
							pSSRC->toolInfo.dwSdesLength  = pSdes->dwSdesLength;
							memcpy (pSSRC->toolInfo.sdesBfr, pSdes->sdesBfr,
									pSdes->dwSdesLength);

							pSSRC->toolInfo.dwSdesFrequency =
								frequencyToPckt (pSdes->dwSdesFrequency);
							pSSRC->toolInfo.dwSdesEncrypted = pSdes->dwSdesEncrypted;
							break;

						case RTCP_SDES_TXT:
							pSSRC->txtInfo.dwSdesLength  = pSdes->dwSdesLength;
							memcpy (pSSRC->txtInfo.sdesBfr, pSdes->sdesBfr,
									pSdes->dwSdesLength);

							pSSRC->txtInfo.dwSdesFrequency =
								frequencyToPckt (pSdes->dwSdesFrequency);
							pSSRC->txtInfo.dwSdesEncrypted = pSdes->dwSdesEncrypted;
							break;

						case RTCP_SDES_PRIV:
							pSSRC->privInfo.dwSdesLength  = pSdes->dwSdesLength;
							memcpy (pSSRC->privInfo.sdesBfr, pSdes->sdesBfr,
									pSdes->dwSdesLength);

							pSSRC->privInfo.dwSdesFrequency =
								frequencyToPckt (pSdes->dwSdesFrequency);
							pSSRC->privInfo.dwSdesEncrypted = pSdes->dwSdesEncrypted;
							break;
						}
					break;

				case RRCM_UPDATE_STREAM_FREQUENCY:
					// upate the stream clocking frequency
					pSSRC->dwStreamClock = (DWORD)updateInfo;
					break;

				case RRCM_UPDATE_RTCP_STREAM_MIN_BW:
					// upate the stream clocking frequency
					pSSRC->xmtInfo.dwRtcpStreamMinBW = (DWORD)updateInfo;
					break;

				case RRCM_UPDATE_CALLBACK:
					// update the callback information
					EnterCriticalSection (&pRTCPses->critSect);
					pRTCPses->pRRCMcallback      = (PRRCM_EVENT_CALLBACK)updateInfo;
					pRTCPses->dwCallbackUserInfo = misc;
					LeaveCriticalSection (&pRTCPses->critSect);
					break;
				}

			// unlock access to this entry
			LeaveCriticalSection (&((PSSRC_ENTRY)pTmp)->critSect);
			}

		pTmp = pTmp->next;
		}	


	IN_OUT_STR ("RTP : Exit updateRTCPSdes ()\n");

	return RRCM_NoError;
	}



/*---------------------------------------------------------------------------
 * Function   : RRCMnotification
 * Description: Notify the application that one of the RTP/RTCP events that
 *				we keep track of has occured.
 *
 * Input :	RRCMevent	:	RRCM event to report
 *			pSSRC		:	-> to the SSRC entry
 *			ssrc		:	SSRC which generated the event
 *			misc		:	Miscelleanous value
 *
 * Return:	OK: RRCM_NoError
 --------------------------------------------------------------------------*/
 void RRCMnotification (RRCM_EVENT_T RRCMevent,
						PSSRC_ENTRY pSSRC,
						DWORD dwSSRC,
						DWORD misc)
	{
	IN_OUT_STR ("RRCM: Enter RRCMnotification()\n");		

	// check to see if the application is interested by the RRCM event
	if (pSSRC->pRTCPses->pRRCMcallback == NULL)				
		return;

	switch (RRCMevent)
		{
		case RRCM_NEW_SOURCE_EVENT:
			pSSRC->pRTCPses->pRRCMcallback (RRCMevent, dwSSRC, misc,
											pSSRC->pRTCPses->dwCallbackUserInfo);
			break;

		case RRCM_LOCAL_COLLISION_EVENT:
			pSSRC->pRTCPses->pRRCMcallback (RRCMevent, pSSRC->SSRC, dwSSRC,
											pSSRC->pRTCPses->dwCallbackUserInfo);
			break;

		case RRCM_REMOTE_COLLISION_EVENT:
			pSSRC->pRTCPses->pRRCMcallback (RRCMevent, dwSSRC, 0,
											pSSRC->pRTCPses->dwCallbackUserInfo);
			break;

		case RRCM_RECV_RTCP_SNDR_REPORT_EVENT:
			pSSRC->pRTCPses->pRRCMcallback (RRCMevent, dwSSRC, pSSRC->RTCPsd,
											pSSRC->pRTCPses->dwCallbackUserInfo);
			break;

		case RRCM_RECV_RTCP_RECV_REPORT_EVENT:
			pSSRC->pRTCPses->pRRCMcallback (RRCMevent, dwSSRC, pSSRC->RTCPsd,
											pSSRC->pRTCPses->dwCallbackUserInfo);
			break;

		case RRCM_TIMEOUT_EVENT:
			pSSRC->pRTCPses->pRRCMcallback (RRCMevent, dwSSRC, 0,
											pSSRC->pRTCPses->dwCallbackUserInfo);
			break;

		case RRCM_BYE_EVENT:
			pSSRC->pRTCPses->pRRCMcallback (RRCMevent, dwSSRC, 0,
											pSSRC->pRTCPses->dwCallbackUserInfo);
			break;

		case RRCM_RTCP_WS_RCV_ERROR:
			pSSRC->pRTCPses->pRRCMcallback (RRCMevent, dwSSRC, misc,
											pSSRC->pRTCPses->dwCallbackUserInfo);
			break;

		case RRCM_RTCP_WS_XMT_ERROR:
			pSSRC->pRTCPses->pRRCMcallback (RRCMevent, dwSSRC, misc,
											pSSRC->pRTCPses->dwCallbackUserInfo);
			break;

		default:
			break;
		}

	IN_OUT_STR ("RRCM: Exit RRCMnotification()\n");
	}



/*----------------------------------------------------------------------------
 * Function   : registerSessionToISDM
 * Description: Register an RTP/RTCP session with ISDM
 *
 * Input :      pSSRC	:	-> to the SSRC's entry
 *				pRTCP	:	-> to the RTCP session's information
 *				pIsdm	:	-> to the ISDM information
 *
 * Return: 		None
 ---------------------------------------------------------------------------*/
#ifdef ENABLE_ISDM2

#define SESSION_BFR_SIZE	30
void registerSessionToISDM (PSSRC_ENTRY pSSRC,
							PRTCP_SESSION pRTCPses,
							PISDM2 pIsdm2)
	{
	struct sockaddr_in	*pSSRCadr;
	unsigned short		port;
	unsigned long		netAddr;
	CHAR				SsrcBfr[10];
	CHAR				sessionBfr[SESSION_BFR_SIZE];
	unsigned char		*ptr;
	int					num;
	HRESULT				hError;
	ISDM2_ENTRY			Isdm2Stat;

	// get the destination address as the session identifier
	pSSRCadr = (struct sockaddr_in *)&pRTCPses->toBfr;
	RRCMws.htons (pSSRC->RTPsd, pSSRCadr->sin_port, &port);
	netAddr  = pSSRCadr->sin_addr.S_un.S_addr;

	ptr = (unsigned char *)&netAddr;
	memset (sessionBfr, 0x00, SESSION_BFR_SIZE);

	num = (int)*ptr++;
	RRCMitoa (num, sessionBfr, 10);
	strcat (sessionBfr, ".");
	num = (int)*ptr++;
	RRCMitoa (num, (sessionBfr + strlen(sessionBfr)), 10);
	strcat (sessionBfr, ".");
	num = (int)*ptr++;
	RRCMitoa (num, (sessionBfr + strlen(sessionBfr)), 10);
	strcat (sessionBfr, ".");
	num = (int)*ptr;
	RRCMitoa (num, (sessionBfr + strlen(sessionBfr)), 10);
	strcat (sessionBfr, ".");
	RRCMitoa (port, (sessionBfr + strlen(sessionBfr)), 10);

	// get the SSRC
	RRCMultoa (pSSRC->SSRC, SsrcBfr, 16);

	// register the session
	if (pRTCPses->hSessKey == NULL)
		{
		hError = Isdm2.ISDMEntry.ISD_CreateKey (hRRCMRootKey,
												sessionBfr,
												&pRTCPses->hSessKey);
		if(FAILED(hError))
			RRCM_DBG_MSG ("RTP: ISD_CreateKey Failed",0, NULL, 0, DBG_NOTIFY);
			
		}

	memset(&Isdm2Stat, 0x00, sizeof(ISDM2_ENTRY));

	hError = Isdm2.ISDMEntry.ISD_CreateValue (pRTCPses->hSessKey,
											  SsrcBfr,
											  BINARY_VALUE,
											  (BYTE *)&Isdm2Stat,
											  sizeof(ISDM2_ENTRY),
											  &pSSRC->hISDM);
	if(FAILED(hError))
		RRCM_DBG_MSG ("RTP: ISD_CreateValue Failed",0, NULL, 0, DBG_NOTIFY);				
	}


/*----------------------------------------------------------------------------
 * Function   : udpateISDMsta
 * Description: Update an ISDM data structure
 *
 * Input :      pSSRC	:	-> to the SSRC's entry
 *				pIsdm	:	-> to the ISDM entry
 *				flag	:	Sender/Receive flag
 *				LocalFB :	do or dont't update the local feedback
 *
 * Return: 		None
 ---------------------------------------------------------------------------*/
void updateISDMstat (PSSRC_ENTRY pSSRC,
					 PISDM2 pIsdm2,
					 DWORD flag,
					 BOOL LocalFB)
	{
	DWORD			curTime = timeGetTime();
	DWORD			dwTmp;
	DWORD			dwValue;
	ISDM2_ENTRY		Isdm2Stat;
	HRESULT			hError;

	unsigned short	idx = 0;
	
	EnterCriticalSection (&pIsdm2->critSect);
	
	Isdm2Stat.SSRC = pSSRC->SSRC;
	Isdm2Stat.PayLoadType = pSSRC->PayLoadType;

	if (flag == RECVR)
		{
		Isdm2Stat.dwSSRCStatus = RECVR;
		Isdm2Stat.rcvInfo.dwNumPcktRcvd = pSSRC->rcvInfo.dwNumPcktRcvd;
		Isdm2Stat.rcvInfo.dwPrvNumPcktRcvd = pSSRC->rcvInfo.dwPrvNumPcktRcvd;
		Isdm2Stat.rcvInfo.dwExpectedPrior  = pSSRC->rcvInfo.dwExpectedPrior;
		Isdm2Stat.rcvInfo.dwNumBytesRcvd   = pSSRC->rcvInfo.dwNumBytesRcvd;
		Isdm2Stat.rcvInfo.dwBaseRcvSeqNum  = pSSRC->rcvInfo.dwBaseRcvSeqNum;
		Isdm2Stat.rcvInfo.dwBadSeqNum      = pSSRC->rcvInfo.dwBadSeqNum;
		Isdm2Stat.rcvInfo.dwProbation      = pSSRC->rcvInfo.dwProbation;
		Isdm2Stat.rcvInfo.dwPropagationTime= pSSRC->rcvInfo.dwPropagationTime;
		Isdm2Stat.rcvInfo.interJitter      = pSSRC->rcvInfo.interJitter;
		Isdm2Stat.rcvInfo.XtendedSeqNum.seq_union.dwXtndedHighSeqNumRcvd =
			pSSRC->rcvInfo.XtendedSeqNum.seq_union.dwXtndedHighSeqNumRcvd;
		}
	else // (flag == ISDM_UPDATE_XMTSTAT)
		{
		Isdm2Stat.dwSSRCStatus = XMITR;

		Isdm2Stat.xmitinfo.dwNumPcktSent  = pSSRC->xmtInfo.dwNumPcktSent;
		Isdm2Stat.xmitinfo.dwNumBytesSent = pSSRC->xmtInfo.dwNumBytesSent;
		Isdm2Stat.xmitinfo.dwNTPmsw		  = pSSRC->xmtInfo.dwNTPmsw;
		Isdm2Stat.xmitinfo.dwNTPlsw		  = pSSRC->xmtInfo.dwNTPlsw;
		Isdm2Stat.xmitinfo.dwRTPts		  = pSSRC->xmtInfo.dwRTPts;
		Isdm2Stat.xmitinfo.dwCurXmtSeqNum = pSSRC->xmtInfo.dwCurXmtSeqNum;
		Isdm2Stat.xmitinfo.dwPrvXmtSeqNum = pSSRC->xmtInfo.dwPrvXmtSeqNum;
		Isdm2Stat.xmitinfo.sessionBW	  = pSSRC->xmtInfo.dwRtcpStreamMinBW;
		Isdm2Stat.xmitinfo.dwLastSR       = pSSRC->xmtInfo.dwLastSR;
		Isdm2Stat.xmitinfo.dwLastSRLocalTime =
			pSSRC->xmtInfo.dwLastSRLocalTime;
		Isdm2Stat.xmitinfo.dwLastSendRTPSystemTime =
			pSSRC->xmtInfo.dwLastSendRTPSystemTime;
		Isdm2Stat.xmitinfo.dwLastSendRTPTimeStamp =
			pSSRC->xmtInfo.dwLastSendRTPTimeStamp;
		}

	if(LocalFB)
		{
		memcpy(&Isdm2Stat.rrFeedback, &pSSRC->rrFeedback, sizeof(RTCP_FEEDBACK));
		}
	else
		{
		Isdm2Stat.rrFeedback.SSRC = pSSRC->rrFeedback.SSRC;
#ifdef ENABLE_FLOATING_POINT
		Isdm2Stat.rrFeedback.dwInterJitter = pSSRC->rcvInfo.interJitter;
#else
		// Check RFC for details of the round off
		Isdm2Stat.rrFeedback.dwInterJitter = pSSRC->rcvInfo.interJitter >> 4;
#endif
		Isdm2Stat.rrFeedback.XtendedSeqNum.seq_union.dwXtndedHighSeqNumRcvd =
			pSSRC->rcvInfo.XtendedSeqNum.seq_union.dwXtndedHighSeqNumRcvd;

		// fraction/cumulative number lost are in network order
		dwTmp = getSSRCpcktLoss (pSSRC, FALSE);
		Isdm2Stat.rrFeedback.fractionLost = (dwTmp & 0xFF);
		RRCMws.ntohl (pSSRC->RTPsd, dwTmp, &dwValue);
		Isdm2Stat.rrFeedback.cumNumPcktLost = (dwValue & 0x00FFFFFF);
		
		Isdm2Stat.rrFeedback.dwLastRcvRpt = pSSRC->rrFeedback.dwLastRcvRpt;
		Isdm2Stat.rrFeedback.dwLastSR = pSSRC->xmtInfo.dwLastSR;
		Isdm2Stat.rrFeedback.dwDelaySinceLastSR = getDLSR (pSSRC);
		}

	Isdm2Stat.dwLastReportRcvdTime = pSSRC->dwLastReportRcvdTime;

	memcpy(&Isdm2Stat.cnameInfo, &pSSRC->cnameInfo, sizeof(SDES_DATA));
	memcpy(&Isdm2Stat.nameInfo, &pSSRC->nameInfo, sizeof(SDES_DATA));
	memcpy(&Isdm2Stat.from, &pSSRC->from, sizeof(SOCKADDR));

	Isdm2Stat.fromLen = pSSRC->fromLen;
	Isdm2Stat.dwNumRptSent = pSSRC->dwNumRptSent;
	Isdm2Stat.dwNumRptRcvd = pSSRC->dwNumRptRcvd;
	Isdm2Stat.dwNumXmtIoPending = pSSRC->dwNumXmtIoPending;
	Isdm2Stat.dwStreamClock = pSSRC->dwStreamClock;

	hError = Isdm2.ISDMEntry.ISD_SetValue (NULL,
										   pSSRC->hISDM,
										   NULL,
										   BINARY_VALUE,
										   (BYTE *)&Isdm2Stat,
										   sizeof(ISDM2_ENTRY));
	
	if(FAILED(hError))
		RRCM_DBG_MSG ("RTP: ISD_SetValue Failed",0, NULL, 0, DBG_NOTIFY);				

	LeaveCriticalSection (&pIsdm2->critSect);

	}
#endif // #ifdef ENABLE_ISDM2


/*---------------------------------------------------------------------------
 * Function   : RRCMdebugMsg
 * Description: Output RRCM debug messages
 *
 * Input :      pMsg:		-> to message
 *				err:		Error code
 *				pFile:		-> to file where the error occured
 *				line:		Line number where the error occured
 *
 * Return:		None
 --------------------------------------------------------------------------*/
 void RRCMdebugMsg (PCHAR pMsg,
				    DWORD err,
				    PCHAR pFile,
				    DWORD line,
					DWORD type)
	{
#ifdef ISRDBG
	wsprintf (debug_string, "%s", pMsg);
	if (err)
		wsprintf (debug_string+strlen(debug_string), " Error:%d", err);
	if (pFile != NULL)
		wsprintf (debug_string+strlen(debug_string), " - %s, line:%d",
					pFile, line);
	switch (type)
		{
		case DBG_NOTIFY:
			ISRNOTIFY(ghISRInst, debug_string, 0);
			break;
		case DBG_TRACE:
			ISRTRACE(ghISRInst, debug_string, 0);
			break;
		case DBG_ERROR:
			ISRERROR(ghISRInst, debug_string, 0);
			break;
		case DBG_WARNING:
			ISRWARNING(ghISRInst, debug_string, 0);
			break;
		case DBG_TEMP:
			ISRTEMP(ghISRInst, debug_string, 0);
			break;
		case DBG_CRITICAL:
			ISRCRITICAL(ghISRInst, debug_string, 0);
			break;
		default:
			break;
		}
#elif DEBUG
extern HDBGZONE  ghDbgZoneRRCM ;
	wsprintf (debug_string, "%s", pMsg);
	if (err)
		wsprintf (debug_string+strlen(debug_string), " Error:%d", err);
	if (pFile != NULL)
		wsprintf (debug_string+strlen(debug_string), " - %s, line:%d",
					pFile, line);
	
	switch (type)
		{
		case DBG_NOTIFY:
		case DBG_TRACE:
		case DBG_WARNING:
		case DBG_TEMP:
			DBGMSG(ghDbgZoneRRCM,0,(debug_string)); // Trace Zone
			break;
		case DBG_ERROR:
		case DBG_CRITICAL:
			DBGMSG(ghDbgZoneRRCM,1,(debug_string));	// Error Zone
			break;
		default:
			break;
		}

#endif
	}


// [EOF]


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\rrcm\rtp\rtpsend.cpp ===
/*----------------------------------------------------------------------------
 * File:        RTPSEND.C
 * Product:     RTP/RTCP implementation
 * Description: Provides WSA Send functions.
 *
 * This listing is supplied under the terms 
 * of a license agreement with Intel Corporation and
 * many not be copied nor disclosed except in accordance
 * with the terms of that agreement.
 * Copyright (c) 1995 Intel Corporation. 
 *--------------------------------------------------------------------------*/


#include "rrcm.h"


/*---------------------------------------------------------------------------
/							Global Variables
/--------------------------------------------------------------------------*/            



/*---------------------------------------------------------------------------
/							External Variables
/--------------------------------------------------------------------------*/
extern PRTP_CONTEXT		pRTPContext;
extern RRCM_WS			RRCMws;


#if (defined(_DEBUG) || defined(PCS_COMPLIANCE))
//INTEROP
extern LPInteropLogger RTPLogger;
#endif


/*----------------------------------------------------------------------------
 * Function   : RTPSendTo
 * Description: Intercepts sendto requests from the application.  
 *				Handles any statistical	processing required for RTCP.  
 *				Copies completion routine from app and substitutes its own.  
 *				Apps completion routine	will be called after RTP's completion 
 *				routine gets called by Winsock2.
 * 
 * Input :	RTPsocket:			RTP socket descriptor
 *			pBufs:				-> to WSAbuf structure
 *		  	dwBufCount:			Buffer count in WSAbuf structure
 *			pNumBytesSent:		-> to number of bytes sent
 *			socketFlags:		Flags
 *			pTo:				-> to the destination address
 *			toLen:				Destination address length
 *			pOverlapped:		-> to overlapped I/O structure
 *			pCompletionRoutine:	-> to completion routine
 *
 * Return: RRCM_NoError		= OK.
 *         Otherwise(!=0)	= Check RRCM.h file for references.
 ---------------------------------------------------------------------------*/
 DWORD WINAPI RTPSendTo (
 						  HANDLE hRTPSess,
 						  SOCKET RTPsocket,
					      LPWSABUF pBufs,
						  DWORD  dwBufCount,
						  LPDWORD pNumBytesSent, 
						  int socketFlags,
						  LPVOID pTo,
						  int toLen,
						  LPWSAOVERLAPPED pOverlapped, 
						  LPWSAOVERLAPPED_COMPLETION_ROUTINE pCompletionRoutine)
	{
	int				dwStatus;
	int				dwErrorStatus;
	PRTP_SESSION	pRTPSession = (PRTP_SESSION) hRTPSess;
	RTP_HDR_T 		*pRTPHeader;
	PSSRC_ENTRY		pSSRC;

	IN_OUT_STR ("RTP : Enter RTPSendTo()\n");

	// If RTP context doesn't exist, report error and return.
	if (pRTPContext == NULL) 
		{
		RRCM_DBG_MSG ("RTP : ERROR - No RTP Instance", 0, 
					  __FILE__, __LINE__, DBG_CRITICAL);
		IN_OUT_STR ("RTP : Exit RTPSendTo()\n");

		return (MAKE_RRCM_ERROR(RRCMError_RTPInvalid));
		}

	ASSERT(pRTPSession);
	
	// Complete filling in header.  First cast a pointer
	// of type RTP_HDR_T to ease accessing
	pRTPHeader = (RTP_HDR_T *)pBufs->buf;
	ASSERT (pRTPHeader);
			
	// Now setup some of the RTP header fields
	pRTPHeader->type = RTP_TYPE;	// RTP Version 2

	// Get pointer to our entry in SSRC table for this session
	pSSRC = searchForMySSRC (
		(PSSRC_ENTRY)pRTPSession->pRTCPSession->XmtSSRCList.prev,
		RTPsocket);
	ASSERT (pSSRC);

	// lock out access to this RTCP session variable 
	EnterCriticalSection (&pSSRC->critSect);

	// save the RTP timestamp
    RRCMws.ntohl (RTPsocket, pRTPHeader->ts, 
					&pSSRC->xmtInfo.dwLastSendRTPTimeStamp);

	// save the last transmit time
	pSSRC->xmtInfo.dwLastSendRTPSystemTime = timeGetTime ();

	// copy over sequence number sent
	RRCMws.ntohs (RTPsocket, pRTPHeader->seq, 
				  (WORD *)&pSSRC->xmtInfo.dwCurXmtSeqNum);

	// SSRC
    RRCMws.htonl (RTPsocket, pSSRC->SSRC, &pRTPHeader->ssrc);

	// Update initial XmtSeqNum so RTCP knows the baseline
	if ((pSSRC->dwSSRCStatus & SEQ_NUM_UPDATED) == 0) 
		{
		pSSRC->xmtInfo.dwPrvXmtSeqNum = pSSRC->xmtInfo.dwCurXmtSeqNum;
		pSSRC->dwSSRCStatus |= SEQ_NUM_UPDATED;
		}

	// update the payload type for this SSRC_ENTRY
	pSSRC->PayLoadType = pRTPHeader->pt;

 	// unlock pointer access 
	LeaveCriticalSection (&pSSRC->critSect);

#if (defined(_DEBUG) || defined(PCS_COMPLIANCE))
		if (RTPLogger)
			{
			//INTEROP
			InteropOutput (RTPLogger,
					       (BYTE FAR*)(pBufs->buf),
						   (int)pBufs->len,
						   RTPLOG_SENT_PDU | RTP_PDU);
			}
#endif

		dwStatus = RRCMws.sendTo (RTPsocket,
		   					      pBufs,
								  dwBufCount,
				   				  pNumBytesSent, 
				   				  socketFlags,
			   					  (PSOCKADDR)pTo,
			    				  toLen,
			   					  pOverlapped, 
			   					  pCompletionRoutine);


	if (dwStatus != SOCKET_ERROR || GetLastError() == WSA_IO_PENDING)
	{
		DWORD i, cbTransferred = 0;
		// assume the send will succeed
		/* lock out access to this RTCP session variable */
		EnterCriticalSection (&pSSRC->critSect);

		// calculate statistics (-DWORD) for the CRSC entry defined 
		// in the RTP header (but we should remove it from the data structure)
		for (i = 0;i < dwBufCount; i++)
			cbTransferred += pBufs[i].len;
			
	    pSSRC->xmtInfo.dwNumBytesSent += (cbTransferred -
	    							(sizeof(RTP_HDR_T) - sizeof(DWORD)));

	    pSSRC->xmtInfo.dwNumPcktSent++;
			    
	 	/* unlock access */
		LeaveCriticalSection (&pSSRC->critSect);
	}

	IN_OUT_STR ("RTP : Exit RTPSendTo()\n");

	return (dwStatus);
	}




// [EOF]
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\rrcm\rtp\rtp_stat.cpp ===
/*----------------------------------------------------------------------------
 * File:        RTP_STAT.C
 * Product:     RTP/RTCP implementation
 * Description: Provides statistical calculations for RTP packets
 *
 *
 * INTEL Corporation Proprietary Information
 * This listing is supplied under the terms of a license agreement with 
 * Intel Corporation and may not be copied nor disclosed except in 
 * accordance with the terms of that agreement.
 * Copyright (c) 1995 Intel Corporation. 
 *--------------------------------------------------------------------------*/

		
#include "rrcm.h"


#define DBG_JITTER_ENABLE	0


/*---------------------------------------------------------------------------
/							Global Variables
/--------------------------------------------------------------------------*/            


/*---------------------------------------------------------------------------
/							External Variables
/--------------------------------------------------------------------------*/
extern PRTP_CONTEXT	pRTPContext;
extern RRCM_WS		RRCMws;				

#ifdef _DEBUG
extern char	debug_string[];
#endif





/*----------------------------------------------------------------------------
 * Function   : calculateJitter
 * Description: Determines jitter between current and last received packet.
 * 
 * Input :		pRTPHeader	: -> to the RTP header
 *				pSSRC		: -> to the session's SSRC list
 *
 * Note: Implementataion adapted from IETF RFC1889
 *
 * Return: RRCM_NoError		= OK.
 *         Otherwise(!=0)	= Error.
 ---------------------------------------------------------------------------*/
DWORD calculateJitter (RTP_HDR_T *pRTPHeader, 
					   PSSRC_ENTRY pSSRC)
	{
	DWORD		dwStatus = RRCM_NoError;
	DWORD		streamClk;
	DWORD		dwTmp;
	int			dwPropagationTime;	// packet's transmit time
	int			dwIASourceTime;		// Packet's timestamp for IA
	int			delta;				// of 2 consec. packets

	IN_OUT_STR ("RTP : Enter calculateJitter()\n");

	// Convert the RTP timestamp to host order
	RRCMws.ntohl (pSSRC->RTPsd, pRTPHeader->ts, (PDWORD)&dwIASourceTime);

	// lock access
	EnterCriticalSection (&pSSRC->critSect);

	// Take the difference, after having adjusted the clock to the payload
	// type frequency
	streamClk = 
		((PSSRC_ENTRY)pSSRC->pRTCPses->XmtSSRCList.prev)->dwStreamClock;
	if (streamClk) 
		{
		dwTmp = streamClk / 1000;

		// update the time to be in unit of the source clock
		dwPropagationTime = (timeGetTime() * dwTmp) - dwIASourceTime;
		}
	else
		dwPropagationTime = timeGetTime() - dwIASourceTime;

	// initialize for the first valid packet, otherwise jitter will be off
	if (pSSRC->rcvInfo.dwPropagationTime == 0)
		{
		pSSRC->rcvInfo.dwPropagationTime = dwPropagationTime;

		LeaveCriticalSection (&pSSRC->critSect);

		IN_OUT_STR ("RTP : Exit calculateJitter()\n");	
		return (dwStatus);
		}

#if DBG_JITTER_ENABLE
	wsprintf(debug_string, "RTP : Time: %ld - Src Timestamp: %ld",
							timeGetTime(), 
							dwIASourceTime);
	RRCM_DBG_MSG (debug_string, 0, NULL, 0, DBG_TRACE);

	wsprintf(debug_string, "RTP : Propagation (Src unit): %ld",
							dwPropagationTime);
	RRCM_DBG_MSG (debug_string, 0, NULL, 0, DBG_TRACE);

	wsprintf(debug_string, "RTP : Previous Propagation (Src unit): %ld",
							pSSRC->rcvInfo.dwPropagationTime);
	RRCM_DBG_MSG (debug_string, 0, NULL, 0, DBG_TRACE);
#endif

	// Determine the difference in the transit times and save the latest
	delta = dwPropagationTime - pSSRC->rcvInfo.dwPropagationTime;
	if (delta < 0)
		delta = -delta;

	// check for a wrap-around, which is always possible, and avoid sending
	// the jitter through the roof - It will take a long time thereafter to 
	// go back down to a reasonable level 
	// Check against arbitrary large number
	if (delta > 20000)
		{
		pSSRC->rcvInfo.dwPropagationTime = dwPropagationTime;

		LeaveCriticalSection (&pSSRC->critSect);

		IN_OUT_STR ("RTP : Exit calculateJitter()\n");	
		return (dwStatus);
		}

#if DBG_JITTER_ENABLE
	wsprintf(debug_string, "RTP : Delta (Src unit): %ld", delta);
	RRCM_DBG_MSG (debug_string, 0, NULL, 0, DBG_TRACE);
#endif

	pSSRC->rcvInfo.dwPropagationTime = dwPropagationTime;

#ifdef ENABLE_FLOATING_POINT
	// This is the RFC way to do it
	pSSRC->rcvInfo.interJitter += 
		((1./16.) * ((double)delta - pSSRC->rcvInfo.interJitter));
#else
	// and this is when we need to remove floating point operation
	pSSRC->rcvInfo.interJitter += 
		(delta - (((long)pSSRC->rcvInfo.interJitter + 8) >> 4));
#endif

	LeaveCriticalSection (&pSSRC->critSect);

#if DBG_JITTER_ENABLE
	if (streamClk)
		{
		wsprintf(debug_string, "RTP : iJitter: %ld - iJitter (msec): %ld",
								pSSRC->rcvInfo.interJitter,
								(pSSRC->rcvInfo.interJitter / (streamClk / 1000)));
		}
	else
		{
		wsprintf(debug_string, "RTP : iJitter: %ld - Delta: %ld",
								pSSRC->rcvInfo.interJitter,
								delta);
		}
	RRCM_DBG_MSG (debug_string, 0, NULL, 0, DBG_TRACE);

	wsprintf(debug_string, "RTP : Next RTCP RR iJitter: %ld",
							(pSSRC->rcvInfo.interJitter >> 4));
	RRCM_DBG_MSG (debug_string, 0, NULL, 0, DBG_TRACE);
#endif
	
	IN_OUT_STR ("RTP : Exit calculateJitter()\n");	

	return (dwStatus);
	}


/*----------------------------------------------------------------------------
 * Function   : initRTPStats
 * Description: initializes statistics table for newly recieved SSRC
 * 
 * Input : RTPSequence	: Sequence number received in the packet.
 *						  NB: Must be in LittleEndian(IA) format
 *		   pSSRC		: -> to SSRC table entry for this terminal
 *
 * Note: Implementataion adapted from draftspec 08, Appendix A.1
 *
 * Return: None.
 ---------------------------------------------------------------------------*/
void initRTPStats (WORD	RTPSequence, 
				   PSSRC_ENTRY pSSRC)
	{
	IN_OUT_STR ("RTP : Enter initRTPStats()\n");

	pSSRC->rcvInfo.dwNumPcktRcvd    = 0;	
	pSSRC->rcvInfo.dwPrvNumPcktRcvd = 0;
	pSSRC->rcvInfo.dwExpectedPrior  = 0;
	pSSRC->rcvInfo.dwNumBytesRcvd   = 0;				
	pSSRC->rcvInfo.dwBadSeqNum      = RTP_SEQ_MOD + 1;		// Out of range
	pSSRC->rcvInfo.XtendedSeqNum.seq_union.RTPSequence.wSequenceNum = 
		RTPSequence;
	pSSRC->rcvInfo.XtendedSeqNum.seq_union.RTPSequence.wCycle = 0;

#if 0
	// as per the RFC, but always 1 packet off by doing this ???
	pSSRC->rcvInfo.dwBaseRcvSeqNum  = RTPSequence - 1;
#else
	pSSRC->rcvInfo.dwBaseRcvSeqNum  = RTPSequence;
#endif

	IN_OUT_STR ("RTP : Exit initRTPStats()\n");
	}


/*----------------------------------------------------------------------------
 * Function   : sequenceCheck
 * Description: Determines whether received packet sequence number is in a
 *				valid range to include for statistical tracking purposes.
 * 
 * Input : RTPSequence	:	Sequence number received in the packet.
 *							NB:	Must be in LittleEndian(IA) format
 *		   pSSRC		:	-> to SSRC table entry for this terminal
 *
 * Note: Implementataion adapted from draftspec 08, Appendix A.1
 *
 * Return: TRUE		= OK.
 *         FALSE	= Stale or invalid data.
 ---------------------------------------------------------------------------*/
#if 1
BOOL sequenceCheck (WORD RTPSequence, 
					PSSRC_ENTRY pSSRC)
	{
	WORD delta = RTPSequence - 
		pSSRC->rcvInfo.XtendedSeqNum.seq_union.RTPSequence.wSequenceNum;
		
	IN_OUT_STR ("RTP : Enter sequenceCheck()\n");

	// Have we received enough consecutive sequence numbered pckts in order 
	// to valide ?
	if (pSSRC->rcvInfo.dwProbation) 
		{
		// Is the sequence received the expected one ?
		if (RTPSequence == 
			(pSSRC->rcvInfo.XtendedSeqNum.seq_union.RTPSequence.wSequenceNum + 1)) 
			{
			// Decrement the number of consecutive packets we need before we
			//	consider statistics to be valid
			pSSRC->rcvInfo.dwProbation--;
			pSSRC->rcvInfo.XtendedSeqNum.seq_union.RTPSequence.wSequenceNum = 
				RTPSequence;

			if (pSSRC->rcvInfo.dwProbation == 0) 
				{
				initRTPStats(RTPSequence, pSSRC);

				IN_OUT_STR ("RTP : Exit sequenceCheck()\n");

				return TRUE;
				}
			}
		else 
			{
			pSSRC->rcvInfo.dwProbation = MIN_SEQUENTIAL - 1;
			pSSRC->rcvInfo.XtendedSeqNum.seq_union.RTPSequence.wSequenceNum = 
				RTPSequence;
			}

		IN_OUT_STR ("RTP : Exit sequenceCheck()\n");

		return FALSE;
		}
	else if (delta < MAX_DROPOUT)
		{
		// In order with permissible gap
		if (RTPSequence < pSSRC->rcvInfo.XtendedSeqNum.seq_union.RTPSequence.wSequenceNum)
			// sequence number wrapped - count another 64K cycle
			pSSRC->rcvInfo.XtendedSeqNum.seq_union.RTPSequence.wCycle += 1;

		pSSRC->rcvInfo.XtendedSeqNum.seq_union.RTPSequence.wSequenceNum = RTPSequence;
		}
	else if (delta <= RTP_SEQ_MOD - MAX_MISORDER)
		{
		// the sequence number made a very large jump
		if (RTPSequence == pSSRC->rcvInfo.dwBadSeqNum)
			// two sequential packet. Assume the other side restarted w/o telling
			// us, so just re-sync, i.e., pretend this was the first packet
			initRTPStats(RTPSequence, pSSRC);	
		else
			{
			pSSRC->rcvInfo.dwBadSeqNum = (RTPSequence + 1) & (RTP_SEQ_MOD - 1);

			IN_OUT_STR ("RTP : Exit sequenceCheck()\n");

			return FALSE;
			}
		}
	else
		{
		// duplicate or reordered packet
		}

	IN_OUT_STR ("RTP : Exit sequenceCheck()\n");

	return (TRUE);
	}

#else
//BOOL sequenceCheck (WORD RTPSequence, 
//					PSSRC_ENTRY lpSSRCList)
//{
//	BOOL			bStatus;
//	WORD			delta;
//		
//#ifdef IN_OUT_CHK
//	OutputDebugString ("\nEnter sequenceCheck()");
//#endif
//
//	// Have we received a couple of consecutive sequence numbered packets for
//	//	validation?
//	if (lpSSRCList->probation) {
//
//		// Default status is don't include since the source hasn't been validated yet
//		bStatus = FALSE;
//
//		// Is the sequence received the expected one?
//		if (RTPSequence == (lpSSRCList->XtendedSeqNum.seq_union.RTPSequence.wSequenceNum + 1)) {
//			// Decrement the number of consecutive packets we need before we
//			//	consider statistics to be valid
//			lpSSRCList->probation--;
//			lpSSRCList->XtendedSeqNum.seq_union.RTPSequence.wSequenceNum = RTPSequence;
//			if (lpSSRCList->probation == 0) {
//				initRTPStats(RTPSequence, lpSSRCList);
//				bStatus = TRUE;
//			}
//		}
//		else {
//			lpSSRCList->probation = MIN_SEQUENTIAL - 1;
//			lpSSRCList->XtendedSeqNum.seq_union.RTPSequence.wSequenceNum = RTPSequence;
//		}
//	}
//	else {
//		// Default status is include since the source has been validated
//		bStatus = TRUE;
//		
//		// First consider the case where delta is positive (or a duplicate packet)
//		if (RTPSequence >= lpSSRCList->XtendedSeqNum.seq_union.RTPSequence.wSequenceNum)	{
//
//			delta = RTPSequence - lpSSRCList->XtendedSeqNum.seq_union.RTPSequence.wSequenceNum;
//
//			if (delta < MAX_DROPOUT) {
//				// packets may be missing, but not too many so as to be deemed restarted
//				lpSSRCList->XtendedSeqNum.seq_union.RTPSequence.wSequenceNum = RTPSequence;
//			}
//			else if (delta  > (RTP_SEQ_MOD - MAX_MISORDER)) {
//				// There has been a recent wraparound, and this is just a recent old packet
//				//	Nothing to do but include for statistical processing
//			}
//			else {
//				// there was a very large jump in sequence numbers
//				if (RTPSequence == lpSSRCList->badSeqNum ) {
//					// Two sequential packets after what was thought was a bad packet or
//					//	(assume a very large jump and proceed as if the sender restarted
//					//	without telling us) or a new terminal is in the session.
//					initRTPStats(RTPSequence, lpSSRCList);
//				}
//				else {
//					lpSSRCList->badSeqNum = (RTPSequence + 1) & (RTP_SEQ_MOD - 1);
//					bStatus = FALSE;
//				}
//			}
//		}
//		else {
//			// sequence number is less than the last we received.  Could be either
//			//	a recent late packet, a very late packet, a wraparound or a restartup 
//			//	of a new session for an SSRC from which we hadn't received a BYE
//
// 			delta = lpSSRCList->XtendedSeqNum.seq_union.RTPSequence.wSequenceNum - RTPSequence;
//
//			if (delta < MAX_MISORDER) {
//				// Packet arrived a little bit late, it's still OK
//				// do nothing here, will be counted in stat routines
//			}
//			else if (delta > (RTP_SEQ_MOD - MAX_DROPOUT)) {
//				// wrap around, adjust cycle number and sequence number
//				lpSSRCList->XtendedSeqNum.seq_union.RTPSequence.cycle++;
//				lpSSRCList->XtendedSeqNum.seq_union.RTPSequence.wSequenceNum = RTPSequence;
//			}
//			else {
//				// there was a very large jump in sequence numbers
//				if (RTPSequence == lpSSRCList->badSeqNum) {
//					// Two sequential packets after what was thought was a bad packet.
//					//	Assume a very large jump and proceed as if the sender restarted
//					//	without telling us
//					initRTPStats(RTPSequence, lpSSRCList);
//				}
//				else {
//					lpSSRCList->badSeqNum = (RTPSequence + 1) & (RTP_SEQ_MOD - 1);
//					bStatus = FALSE;
//				}
//			}
//		}
//	}
//
//#ifdef IN_OUT_CHK
//	OutputDebugString ("\nExit sequenceCheck()");
//#endif
//
//	return (bStatus);
//}
#endif


/*----------------------------------------------------------------------------
 * Function   : updateRTPStats
 * Description: Updates statistics for RTP packets received from net
 * 
 * Input : 	pRTPHeader		: -> to packet's RTP header field
 *			pSSRC			: -> to remote source's statistics table
 *			cbTransferred	: Number of bytes transferred
 *
 *
 * Return: RRCM_NoError		= OK.
 *         Otherwise(!=0)	= Initialization Error.
 ---------------------------------------------------------------------------*/
DWORD updateRTPStats (RTP_HDR_T *pRTPHeader, 
					  PSSRC_ENTRY pSSRC,
					  DWORD cbTransferred)
	{
	WORD	RTPSequenceNum;

	IN_OUT_STR ("RTP : Enter updateRTPStats()\n");

	// Update statistics only if the data looks good.  Check the sequence number
	//	to ensure it is within an appropriate range.  First, we must convert the
	//	sequence number to IA (little Endian) format
	RRCMws.ntohs (pSSRC->RTPsd, pRTPHeader->seq, 
				  (unsigned short *)&RTPSequenceNum);

	if (sequenceCheck (RTPSequenceNum, pSSRC)) 
		{
		// lock access to data
		EnterCriticalSection (&pSSRC->critSect);

		// update number of packet received
		pSSRC->rcvInfo.dwNumPcktRcvd++;			

		// Number octets received (exclusive of header) depends on whether
		//	a mixer (CSRC != 0) was involved
		if (pRTPHeader->cc == 0) 
			{
			pSSRC->rcvInfo.dwNumBytesRcvd += 
				(cbTransferred - (sizeof(RTP_HDR_T) - sizeof(pRTPHeader->csrc[0])));
			}
		else 
			{
			pSSRC->rcvInfo.dwNumBytesRcvd += 
				(cbTransferred - sizeof(RTP_HDR_T) +
					((pRTPHeader->cc - 1) * sizeof(pRTPHeader->csrc[0])));
			}

		// Packet received sequentially in order (difference 
		// of 1, or -1 if wraparound) save new current 
		//	sequence number
		RRCMws.ntohs (pSSRC->RTPsd, pRTPHeader->seq, 
					  (unsigned short *)&pSSRC->xmtInfo.dwCurXmtSeqNum);

		//	Calculate JITTER
		calculateJitter (pRTPHeader, pSSRC);

		// unlock access to data
		LeaveCriticalSection (&pSSRC->critSect);
		}

	IN_OUT_STR ("RTP : Exit updateRTPStats()\n");

	return (RRCM_NoError);
	}


// [EOF]
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\rrcm\rtp\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__3C90D0D6_5F80_11D1_AA64_00C04FC9B202__INCLUDED_)
#define AFX_STDAFX_H__3C90D0D6_5F80_11D1_AA64_00C04FC9B202__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

//#define STRICT
//#define _ATL_STATIC_REGISTRY

#ifndef WIN32
#define WIN32
#endif

#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif
#define _ATL_APARTMENT_THREADED

#include "rrcm.h"

// We should really only put this in for w2k
#define _ATL_NO_DEBUG_CRT
#define _ASSERTE(expr) ASSERT(expr)


#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
extern CRITICAL_SECTION g_CritSect;
#include <atlcom.h>
//#include "log.h"
// temp. debug defns.
#define DEBUGMSG(x,y) ATLTRACE y
#define RETAILMSG(x) ATLTRACE x
#ifdef _DEBUG
#define FX_ENTRY(s)	static CHAR _fx_ [] = (s);
#else
#define FX_ENTRY(s)
#endif

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__3C90D0D6_5F80_11D1_AA64_00C04FC9B202__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\rrcm\rtp\thread.h ===
typedef BOOL (* THREADCALLBACK)(PVOID pParam, DWORD dwParam);

// general purpose worker thread
// The thread exists in an alertable Wait state and does most of its work
// in APCs.

struct ThreadCallback
{
	THREADCALLBACK CallProc;
	PVOID pParam;
	DWORD dwParam;
};

class CEventThread
{
public:
	CEventThread();
	~CEventThread();
	int Start();
	int Stop();
	BOOL CallNow(THREADCALLBACK CallProc, PVOID pParam, DWORD dwParam);
	//BOOL WaitOnEvent(THREADCALLBACK OnEventProc, PVOID pParam, DWORD dwParam);
private:
#define CTHREADF_STOP		0x00000001
	static DWORD  __stdcall EventThreadProc(PVOID pObj)
	{
		return ((class CEventThread *)pObj)->ThreadMethod();
	}
	static void APIENTRY HandleCallNowAPC(DWORD dwArg);
	DWORD ThreadMethod();

	HANDLE m_hThread;
	DWORD m_idThread;
	UINT m_uRef;
	HANDLE m_hSignalEvent;	// signal to worker thread to do something
	HANDLE m_hAckEvent;		// ack from worker thread
	DWORD m_dwFlags;
	CRITICAL_SECTION m_cs;	// serializes client calls. Not used by worker thread
	ThreadCallback m_Callback;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\rrcm\rtp\thread.cpp ===
#include "stdafx.h"
#include "thread.h"
// general purpose worker thread
// The thread exists in an alertable Wait state and does most of its work
// in APCs.
CEventThread::CEventThread()
{
	InitializeCriticalSection(&m_cs);
	m_uRef=0;
	m_dwFlags = 0;
	m_hThread = 0;
	m_hSignalEvent = CreateEvent(NULL,FALSE,FALSE,NULL);
	m_hAckEvent = CreateEvent(NULL,FALSE,FALSE,NULL);
}

CEventThread::~CEventThread()
{
	DeleteCriticalSection(&m_cs);
	if (m_hSignalEvent)
		CloseHandle(m_hSignalEvent);
	if (m_hAckEvent)
		CloseHandle(m_hAckEvent);
}

BOOL
CEventThread::Start()
{
	BOOL fRet;
	EnterCriticalSection(&m_cs);
	if (++m_uRef == 1)
	{
		m_hThread = CreateThread(
			NULL,0,
			EventThreadProc,
			this, 0, &m_idThread);
	}
	fRet = !!m_hThread;
	LeaveCriticalSection(&m_cs);
	return fRet;
}

BOOL
CEventThread::Stop()
{
	BOOL fRet;
	EnterCriticalSection(&m_cs);
	if (--m_uRef == 0)
	{
		m_dwFlags |= CTHREADF_STOP;
		SetEvent(m_hSignalEvent);
		WaitForSingleObject(m_hThread, INFINITE);
		CloseHandle(m_hThread);
		m_hThread = NULL;
		m_dwFlags &= ~CTHREADF_STOP;
	}
	LeaveCriticalSection(&m_cs);
	return TRUE;
}

DWORD
CEventThread::ThreadMethod()
{
	DWORD dwWait;
	while (1) {
		dwWait = WaitForSingleObjectEx(m_hSignalEvent, INFINITE, TRUE);
		if (dwWait == WAIT_OBJECT_0)
		{
			if (m_dwFlags & CTHREADF_STOP)
			{
				break;	// exit thread
			}
		}
		else if (dwWait == WAIT_IO_COMPLETION)
		{
			 
		}
		else
		if (dwWait == WAIT_FAILED)
		{
			break;	// exit thread
		}
	}

	return dwWait;
}

// Executes the CallProc in the worker thread in a synchronous fashion
// (similar to SendMessage). When this method returns the CallProc has been called
// and the return value is returned.
BOOL CEventThread::CallNow(THREADCALLBACK CallProc, PVOID pParam, DWORD dwParam)
{
	BOOL fRet = FALSE;
	EnterCriticalSection(&m_cs);
	m_Callback.CallProc = CallProc;
	m_Callback.pParam = pParam;
	m_Callback.dwParam = dwParam;
	ResetEvent(m_hAckEvent);
	if (QueueUserAPC(HandleCallNowAPC, m_hThread, (DWORD)this))
	{
		DWORD dwWait;
		dwWait = WaitForSingleObject(m_hAckEvent, INFINITE);
		if (dwWait == WAIT_OBJECT_0)
			fRet = (BOOL) m_Callback.dwParam;	//get the cached return value
	}
	LeaveCriticalSection(&m_cs);
	return fRet;
}

void APIENTRY CEventThread::HandleCallNowAPC(DWORD dwArg)
{
	CEventThread *pThis = (CEventThread *)dwArg;
	if (pThis->m_Callback.CallProc)
	{
		pThis->m_Callback.dwParam = pThis->m_Callback.CallProc(pThis->m_Callback.pParam, pThis->m_Callback.dwParam);
		SetEvent(pThis->m_hAckEvent);
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\core\avdefs.h ===
// File: avDefs.h

#ifndef _AVDEFS_H_

//To bring in the video stuff...from the NAC interface
#ifndef WSA_IO_PENDING

typedef struct _OVERLAPPED *    LPWSAOVERLAPPED;

typedef struct _WSABUF {
    u_long      len;     /* the length of the buffer */
    char FAR *  buf;     /* the pointer to the buffer */
} WSABUF, FAR * LPWSABUF;

typedef
void
(CALLBACK * LPWSAOVERLAPPED_COMPLETION_ROUTINE)(
    DWORD dwError,
    DWORD cbTransferred,
    LPWSAOVERLAPPED lpOverlapped,
    DWORD dwFlags
    );

#define WSA_IO_PENDING          (ERROR_IO_PENDING)

#endif // } WSA_IO_PENDING

#include <mmreg.h>
#include <msacm.h>
#include <vidinout.h>
#include <vcmstrm.h>
#include <iacapapi.h>

#endif /* _AVDEFS_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\core\audio.cpp ===
/****************************************************************************
*
*	 FILE:	   Audio.cpp
*
*	 CREATED:  Mike VanBuskirk (MikeV) 3-02-98
*
*	 CONTENTS: Audio control object
*
****************************************************************************/


#include "precomp.h"

#include "avdefs.h"
#include "audio.h"
#include "h323.h"
#include <nacguids.h>


#include "audio.h"

CAudioControl::CAudioControl(BOOL fLocal)
:	m_fPaused(FALSE),
	m_fLocal(fLocal),
	m_fChannelOpen(FALSE),
	m_fOpenPending(FALSE),
	m_fReopenPending(FALSE),
	m_fClosePending(FALSE),
	m_pCommChannel(NULL),
	m_pConnection(NULL),
	m_pMediaStream(NULL),
	m_NewFormat(INVALID_MEDIA_FORMAT)

{

}

CAudioControl::~CAudioControl()
{
	if (NULL != m_pCommChannel)
	{
		m_pCommChannel->Release();
	}
}

BOOL CAudioControl::ChanInitialize(ICommChannel* pCommChannel)
{
	ASSERT(m_pCommChannel == NULL);
	m_pCommChannel = pCommChannel;
	m_pCommChannel->AddRef();
	
	return TRUE;
}


VOID CAudioControl::Open(MEDIA_FORMAT_ID format_id)
{
	if(!m_pCommChannel)
	{
		return;
	}
	
	m_pCommChannel->PauseNetworkStream(FALSE);
	m_pCommChannel->EnableOpen(TRUE);

	if (m_fLocal)
	{

		HRESULT hr;
		// if the channel is not open and a call is in progress, now is the time
		if(m_pConnection && m_pCommChannel)
		{
			// a call is in progress
			if(!IsChannelOpen()  
				&& !m_fOpenPending)
			{
				// so, the channel is not open

				if(format_id != INVALID_MEDIA_FORMAT)
				{
					// try to open a channel using specified format 
					m_fOpenPending = TRUE;	// do this first (callbacks!)
					hr = m_pCommChannel->Open(format_id, m_pConnection);
					if(FAILED(hr))
						m_fOpenPending = FALSE;
				}
 
			}
			else if (m_fClosePending)
			{
				m_NewFormat = format_id;
				if(format_id != INVALID_MEDIA_FORMAT)
				{
					m_fClosePending = FALSE;
					m_fReopenPending = TRUE;
					hr = m_pCommChannel->Close();
				}
			}
		}
	}
	
}
VOID CAudioControl::Close()
{
	HRESULT hr;
	hr = m_pCommChannel->Close();
	// what to do about an error?
}

VOID CAudioControl::EnableXfer(BOOL fEnable)
{
	m_fXfer = fEnable;
	if(m_pCommChannel)
	{
		BOOL bPause = (fEnable)? FALSE :TRUE;
		m_pCommChannel->PauseNetworkStream(bPause);
		m_pCommChannel->EnableOpen(fEnable);
	}
	
}

BOOL CAudioControl::IsXferEnabled()
{
	return m_fXfer;
}
VOID CAudioControl::Pause(BOOL fPause)
{
	m_fPaused = fPause;
	if (m_fPaused)
	{
		EnableXfer(FALSE);
	}
	else
	{
		EnableXfer(TRUE);
	}
}


BOOL CAudioControl::Initialize(IH323CallControl *pNac, IMediaChannel *, 
    DWORD dwUser)
{
	HRESULT hr;

	m_fChannelOpen = FALSE;
	m_fOpenPending = m_fReopenPending = FALSE;
	m_fPaused = TRUE;
	EnableXfer(FALSE);	// need to store state locally, set it in OnChannelOpen

	return TRUE;
}


VOID CAudioControl::OnConnected(IH323Endpoint * lpConnection, ICommChannel *pIChannel)
{
	m_pConnection = lpConnection;
	m_fOpenPending = m_fReopenPending = m_fClosePending = FALSE;
	ChanInitialize(pIChannel);
}
VOID CAudioControl::OnChannelOpened(ICommChannel *pIChannel)
{
	m_fChannelOpen = TRUE;
	m_fOpenPending = m_fReopenPending = FALSE;
	if(!m_pMediaStream)
	{
		m_pMediaStream = m_pCommChannel->GetMediaChannel(); 
		ASSERT(m_pMediaStream);
	}
	if (m_fLocal || m_fXfer)	// start streams always if sending, or if transfer is enabled
	{
		EnableXfer(TRUE);
	}
	else
	{
		EnableXfer(FALSE);
	}


}
VOID CAudioControl::OnChannelError()
{
		m_fOpenPending = FALSE; 
}

VOID CAudioControl::OnChannelClosed()
{
	HRESULT hr;
	m_fChannelOpen = FALSE;
	if(m_fLocal && m_fReopenPending)
	{

		m_fReopenPending = FALSE;
		if(m_NewFormat != INVALID_MEDIA_FORMAT )
		{
			m_fOpenPending = TRUE;
			hr = m_pCommChannel->Open(m_NewFormat, m_pConnection);
			if(FAILED(hr))
				m_fOpenPending = FALSE;
		}
	}
	else
	{
		if(m_pCommChannel)
		{
			m_pCommChannel->Release();
			m_pCommChannel = NULL;	
		}
	}
	
}
VOID CAudioControl::OnDisconnected()
{
	m_pConnection = NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\core\clclsfct.h ===
// File: clclsfct.h

#ifndef _CLCLSFCT_H_
#define _CLCLSFCT_H_


//////////////////////////////////////////////////////////////////////////
// New Object
typedef PIUnknown (*NEWOBJECTPROC)(OBJECTDESTROYEDPROC);
DECLARE_STANDARD_TYPES(NEWOBJECTPROC);

typedef struct classconstructor
{
	PCCLSID pcclsid;

	NEWOBJECTPROC NewObject;
}
CLASSCONSTRUCTOR;
DECLARE_STANDARD_TYPES(CLASSCONSTRUCTOR);



//////////////////////////////////////////////////////////////////////////
// object class factory
class CCLClassFactory : public RefCount, public IClassFactory
{
private:
	NEWOBJECTPROC m_NewObject;

public:
	CCLClassFactory(NEWOBJECTPROC NewObject, OBJECTDESTROYEDPROC ObjectDestroyed);
	~CCLClassFactory(void);

	// IUnknown methods
	ULONG STDMETHODCALLTYPE AddRef(void);
	ULONG STDMETHODCALLTYPE Release(void);
	HRESULT STDMETHODCALLTYPE QueryInterface(REFIID riid, PVOID *ppvObj);

	// IClassFactory methods
	HRESULT STDMETHODCALLTYPE CreateInstance(PIUnknown piunkOuter, REFIID riid, PVOID *ppvObject);
	HRESULT STDMETHODCALLTYPE LockServer(BOOL bLock);

};
DECLARE_STANDARD_TYPES(CCLClassFactory);


HRESULT GetClassConstructor(REFCLSID rclsid, PNEWOBJECTPROC pNewObject);

VOID DllLock(void);
VOID DllRelease(void);

#endif /* _CLCLSFCT_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\core\audio.h ===
/****************************************************************************
*
*	 FILE:	   audio.h
*
*	 CREATED:  Mike VanBiskirk (mikev) 2-26-98
*
****************************************************************************/

#ifndef _AUDIOUI_H_
#define _AUDIOUI_H_


class CAudioControl
{
private:

	ICommChannel*	m_pCommChannel;
	IMediaChannel*   m_pMediaStream;
	IH323Endpoint *	m_pConnection;
	
	BOOL			m_fOpenPending;
	BOOL			m_fReopenPending;
	BOOL			m_fClosePending;

	BOOL			m_fPaused;
	BOOL			m_fLocal;
	BOOL			m_fChannelOpen;
    BOOL            m_fXfer;
   	MEDIA_FORMAT_ID m_NewFormat;
   	
public:
	// Methods:
				CAudioControl(BOOL fLocal);
				~CAudioControl();
	BOOL		ChanInitialize(ICommChannel* pCommChannel);

	BOOL		IsLocal() { return m_fLocal; }
	VOID		EnableXfer(BOOL fEnable);
	VOID        Open(MEDIA_FORMAT_ID format_id);
	VOID        Close();
	BOOL		IsXferEnabled();
	VOID		Pause(BOOL fPause);
	BOOL		IsPaused() { return m_fPaused; };

	BOOL		Initialize(IH323CallControl *pNac, IMediaChannel *pMC, 
	    DWORD dwUser);
	BOOL		IsChannelOpen() { return m_fChannelOpen; }

		// Handlers:
	VOID		OnConnected(IH323Endpoint * lpConnection, ICommChannel *pIChannel);
	VOID		OnChannelOpened(ICommChannel *pIChannel);
	VOID		OnChannelError();
	VOID		OnChannelClosed();
	VOID		OnDisconnected();
};

#endif // _AUDIOUI_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\core\clclsfct.cpp ===
// File: clclsfct.cpp
//
// IClassFactory and related routines
//
//		ULONG DLLAddRef(void);
//		ULONG DLLRelease(void);
//
//		STDAPI DllCanUnloadNow(void);
//		VOID   DllLock(void);
//		VOID   DllRelease(void);
//
//////////////////////////////////////////////////////////////////////////

#include "precomp.h"
#include "clclsfct.h"


// from imanager.cpp
PIUnknown NewNmManager(OBJECTDESTROYEDPROC ObjectDestroyed);



CCLASSCONSTRUCTOR s_cclscnstr[] =
{
	{&CLSID_NmManager2,  &NewNmManager},
};


// DLL reference count == number of class factories +
//                        number of URLs +
//                        LockServer() count

ULONG s_ulcDLLRef = 0;

///////////////////////////////////////////////////////////////////////////


/*  G E T  C L A S S  C O N S T R U C T O R  */
/*-------------------------------------------------------------------------
    %%Function: GetClassConstructor
    
-------------------------------------------------------------------------*/
HRESULT GetClassConstructor(REFCLSID rclsid, PNEWOBJECTPROC pNewObject)
{
   HRESULT hr = CLASS_E_CLASSNOTAVAILABLE;
   UINT u;

   ASSERT(IsValidREFCLSID(rclsid));
   ASSERT(IS_VALID_WRITE_PTR(pNewObject, NEWOBJECTPROC));

   *pNewObject = NULL;

   for (u = 0; u < ARRAY_ELEMENTS(s_cclscnstr); u++)
   {
      if (rclsid == *(s_cclscnstr[u].pcclsid))
      {
         *pNewObject = s_cclscnstr[u].NewObject;
         hr = S_OK;
      }
   }

   ASSERT((hr == S_OK &&
           IS_VALID_CODE_PTR(*pNewObject, NEWOBJECTPROC)) ||
          (hr == CLASS_E_CLASSNOTAVAILABLE &&
           ! *pNewObject));

   return hr;
}


VOID STDMETHODCALLTYPE DLLObjectDestroyed(void)
{
   TRACE_OUT(("DLLObjectDestroyed(): Object destroyed."));

   DllRelease();
}



/****************************** Public Functions *****************************/

ULONG DLLAddRef(void)
{
	ASSERT(s_ulcDLLRef < ULONG_MAX);

	ULONG ulcRef = ++s_ulcDLLRef;

	DbgMsgRefCount("DLLAddRef(): DLL reference count is now %lu.", ulcRef);

	return ulcRef;
}


ULONG DLLRelease(void)
{
	ULONG ulcRef;

	if (s_ulcDLLRef > 0)
	{
	  s_ulcDLLRef--;
	}

	ulcRef = s_ulcDLLRef;

	DbgMsgRefCount("DLLRelease(): DLL reference count is now %lu.", ulcRef);

	return ulcRef;
}


PULONG GetDLLRefCountPtr(void)
{
   return(&s_ulcDLLRef);
}


/********************************** Methods **********************************/


CCLClassFactory::CCLClassFactory(NEWOBJECTPROC NewObject,
                           OBJECTDESTROYEDPROC ObjectDestroyed) :
   RefCount(ObjectDestroyed)
{
	// Don't validate this until after construction.
	ASSERT(IS_VALID_CODE_PTR(NewObject, NEWOBJECTPROC));

	m_NewObject = NewObject;

	ASSERT(IS_VALID_STRUCT_PTR(this, CCCLClassFactory));
}


CCLClassFactory::~CCLClassFactory(void)
{
	ASSERT(IS_VALID_STRUCT_PTR(this, CCCLClassFactory));

	m_NewObject = NULL;
}


ULONG STDMETHODCALLTYPE CCLClassFactory::AddRef(void)
{
	ASSERT(IS_VALID_STRUCT_PTR(this, CCCLClassFactory));

	ULONG ulcRef = RefCount::AddRef();

	ASSERT(IS_VALID_STRUCT_PTR(this, CCCLClassFactory));
	return ulcRef;
}


ULONG STDMETHODCALLTYPE CCLClassFactory::Release(void)
{
	ASSERT(IS_VALID_STRUCT_PTR(this, CCCLClassFactory));

	ULONG ulcRef = RefCount::Release();
	return ulcRef;
}


HRESULT STDMETHODCALLTYPE CCLClassFactory::QueryInterface(REFIID riid, PVOID *ppvObject)
{
	HRESULT hr = S_OK;

	ASSERT(IS_VALID_STRUCT_PTR(this, CCCLClassFactory));
	ASSERT(IsValidREFIID(riid));
	ASSERT(IS_VALID_WRITE_PTR(ppvObject, PVOID));

	if (riid == IID_IClassFactory)
	{
		*ppvObject = (PIClassFactory)this;
		ASSERT(IS_VALID_INTERFACE_PTR((PIClassFactory)*ppvObject, IClassFactory));
		TRACE_OUT(("CCLClassFactory::QueryInterface(): Returning IClassFactory."));
	}
	else if (riid == IID_IUnknown)
	{
		*ppvObject = (PIUnknown)this;
		ASSERT(IS_VALID_INTERFACE_PTR((PIUnknown)*ppvObject, IUnknown));
		TRACE_OUT(("CCLClassFactory::QueryInterface(): Returning IUnknown."));
	}
	else
	{
		*ppvObject = NULL;
		hr = E_NOINTERFACE;
		TRACE_OUT(("CCLClassFactory::QueryInterface(): Called on unknown interface."));
	}

	if (hr == S_OK)
	{
		AddRef();
	}

	ASSERT(IS_VALID_STRUCT_PTR(this, CCCLClassFactory));
	return hr;
}


HRESULT STDMETHODCALLTYPE CCLClassFactory::CreateInstance(PIUnknown piunkOuter,
         REFIID riid, PVOID *ppvObject)
{
	ASSERT(IS_VALID_STRUCT_PTR(this, CCCLClassFactory));
	ASSERT(! piunkOuter || IS_VALID_INTERFACE_PTR(piunkOuter, IUnknown));
	ASSERT(IsValidREFIID(riid));
	ASSERT(IS_VALID_WRITE_PTR(ppvObject, PVOID));

	*ppvObject = NULL;

	if (NULL != piunkOuter)
	{
		WARNING_OUT(("CCLClassFactory::CreateInstance(): Aggregation not supported."));
		return CLASS_E_NOAGGREGATION;
	}

	PIUnknown piunk = (*m_NewObject)(  (void(__stdcall *)(void))   &DLLObjectDestroyed);
	if (NULL == piunk)
	{
		return E_OUTOFMEMORY;
	}
	
	DllLock();
	HRESULT hr = piunk->QueryInterface(riid, ppvObject);

	// N.b., the Release() method will destroy the object if the
	// QueryInterface() method failed.
	piunk->Release();

	ASSERT(IS_VALID_STRUCT_PTR(this, CCCLClassFactory));
	return hr;
}


HRESULT STDMETHODCALLTYPE CCLClassFactory::LockServer(BOOL fLock)
{
	ASSERT(IS_VALID_STRUCT_PTR(this, CCCLClassFactory));

	if (fLock)
	{
		DllLock();
	}
	else
	{
		DllRelease();
	}

	ASSERT(IS_VALID_STRUCT_PTR(this, CCCLClassFactory));
	return S_OK;
}


/***************************** Exported Functions ****************************/


/*  D L L  G E T  C L A S S  O B J E C T  */
/*-------------------------------------------------------------------------
    %%Function: DllGetClassObject
    
-------------------------------------------------------------------------*/
STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, PVOID *ppvObject)
{

	ASSERT(IsValidREFCLSID(rclsid));
	ASSERT(IsValidREFIID(riid));
	ASSERT(IS_VALID_WRITE_PTR(ppvObject, PVOID));

	*ppvObject = NULL;

	NEWOBJECTPROC NewObject;
	HRESULT hr = GetClassConstructor(rclsid, &NewObject);
	if (S_OK != hr)
	{
		WARNING_OUT(("DllGetClassObject(): Called on unknown class."));
		return hr;
	}

	if ((riid != IID_IUnknown) && (riid != IID_IClassFactory))
	{
		WARNING_OUT(("DllGetClassObject(): Called on unknown interface."));
		return E_NOINTERFACE;
	}

	PCCLClassFactory pcf = new CCLClassFactory(NewObject,
		(void(__stdcall *)(void)) &DLLObjectDestroyed);
	if (NULL == pcf)
	{
		return E_OUTOFMEMORY;
	}

	if (riid == IID_IClassFactory)
	{
		*ppvObject = (PIClassFactory)pcf;
		ASSERT(IS_VALID_INTERFACE_PTR((PIClassFactory)*ppvObject, IClassFactory));
		TRACE_OUT(("DllGetClassObject(): Returning IClassFactory."));
	}
	else
	{
		ASSERT(riid == IID_IUnknown);
		*ppvObject = (PIUnknown)pcf;
		ASSERT(IS_VALID_INTERFACE_PTR((PIUnknown)*ppvObject, IUnknown));
		TRACE_OUT(("DllGetClassObject(): Returning IUnknown."));
	}

	DllLock();

	TRACE_OUT(("DllGetClassObject(): Created a new class factory."));
	return S_OK;
}


/*  D L L  C A N  U N L O A D  N O W  */
/*-------------------------------------------------------------------------
    %%Function: DllCanUnloadNow
    
-------------------------------------------------------------------------*/
STDAPI DllCanUnloadNow(void)
{
	HRESULT hr = (s_ulcDLLRef > 0) ? S_FALSE : S_OK;
	TRACE_OUT(("DllCanUnloadNow(): DLL reference count is %lu.", s_ulcDLLRef));
	return hr;
}


/*  D L L  L O C K  */
/*-------------------------------------------------------------------------
    %%Function: DllLock
    
-------------------------------------------------------------------------*/
VOID DllLock(void)
{
    InterlockedIncrement((LPLONG) &s_ulcDLLRef);
    DbgMsgRefCount("Ref: DllLock count=%d", s_ulcDLLRef);
}


/*  D L L  R E L E A S E  */
/*-------------------------------------------------------------------------
    %%Function: DllRelease
    
-------------------------------------------------------------------------*/
VOID DllRelease(void)
{
	LONG cRef = InterlockedDecrement((LPLONG) &s_ulcDLLRef);

#ifdef DEBUG
	DbgMsgRefCount("Ref: DllLock count=%d", s_ulcDLLRef);
	if (0 == cRef)
	{
		WARNING_OUT(("NMCOM.DLL Can now be unloaded"));
	}
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\rrcm\rtp\ws2emul.cpp ===
#include <rrcm.h>
#include <queue.h>
// Forward declarations
DWORD WINAPI WS1MsgThread (LPVOID );
LRESULT CALLBACK WS1WindowProc(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam);
BOOL StartWS1MsgThread();
BOOL StopWS1MsgThread();
void __stdcall SendRecvCompleteAPC(ULONG_PTR dw);

class CWS2EmulSock;

#define WM_WSA_READWRITE	(WM_USER + 100)
// structure used to store WSASendTo/WSARecvFrom parameters
struct WSAIOREQUEST {
	WSAOVERLAPPED *pOverlapped;
	WSABUF wsabuf[2];
	DWORD dwBufCount;
	union {
		struct {
			struct sockaddr *pRecvFromAddr;
			LPINT pRecvFromLen;
		};
		struct sockaddr SendToAddr;
	};
};

// global Winsock emulation state
struct WS2Emul {
#define MAX_EMUL_SOCKETS 10
	CWS2EmulSock *m_pEmulSocks[MAX_EMUL_SOCKETS];
	int		numSockets;
	HWND	hWnd;
	HANDLE 	hMsgThread;
	HANDLE 	hAckEvent;
	// external crit sect serializes the WS2EmulXX apis
	// to make them multi-thread safe
	CRITICAL_SECTION extcs;	
	// internal crit sect serializes access between
	// MsgThread and WS2EmulXX apis
	// Never claim extcs while holding intcs.
	// (Is there a more elegant way to do this?)
	CRITICAL_SECTION intcs;
	
} g_WS2Emul;

/*
	CWS2EmulSock -
	WS2 socket emulation class
	Manages  queues of overlapped i/o requests
*/

class CWS2EmulSock
{
public:
	CWS2EmulSock(int myIndex) : m_myIndex(myIndex), m_RecvThreadId(0),m_SendThreadId(0),
		m_hRecvThread(NULL), m_hSendThread(NULL), m_sock(INVALID_SOCKET)
		{ ZeroMemory(&m_SendOverlapped, sizeof(m_SendOverlapped));}
			;
	BOOL NewSock(int af, int type, int protocol);
	int Close();
	int RecvFrom(
	    LPWSABUF lpBuffers,DWORD dwBufferCount, LPDWORD lpNumberOfBytesRecvd, LPDWORD lpFlags,
	    struct sockaddr FAR * lpFrom, LPINT lpFromlen,
	    LPWSAOVERLAPPED lpOverlapped, LPWSAOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine);
	int SendTo(
		LPWSABUF lpBuffers, DWORD dwBufferCount, LPDWORD lpNumberOfBytesSent,DWORD dwFlags,
	    const struct sockaddr FAR * lpTo, int iTolen,
	    LPWSAOVERLAPPED lpOverlapped,LPWSAOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine);

	LRESULT HandleMessage(WPARAM wParam, LPARAM lParam); //  WS1 window msg handler
	SOCKET GetSocket() { return m_sock;}
	WSAOVERLAPPED *GetSendOverlapped() {return &m_SendOverlapped;}
private:
	SOCKET m_sock;					// real socket handle
	int m_myIndex;					// fake socket handle
	QueueOf<WSAIOREQUEST> m_RecvQ;	// queue of overlapped recv requests
	QueueOf<WSAIOREQUEST> m_SendQ;	// queue of overlapped send requests
	WSAOVERLAPPED m_SendOverlapped; // used only for synchronous send calls
	// the following fields are used to issue Send/Recv APCs
	DWORD m_RecvThreadId;
	DWORD m_SendThreadId;
	HANDLE m_hRecvThread;		// thread issuing receive requests
	HANDLE m_hSendThread;		// thread issuing send requests
};

void WS2EmulInit()
{
	InitializeCriticalSection(&g_WS2Emul.extcs);
	InitializeCriticalSection(&g_WS2Emul.intcs);
}

void WS2EmulTerminate()
{
	DeleteCriticalSection(&g_WS2Emul.extcs);
	DeleteCriticalSection(&g_WS2Emul.intcs);
}

BOOL
CWS2EmulSock::NewSock(int af,int type, int protocol)
{
	m_sock = socket(af,type,protocol);
	if (m_sock != INVALID_SOCKET)
	{
		WSAAsyncSelect(m_sock, g_WS2Emul.hWnd, WM_WSA_READWRITE+m_myIndex, FD_READ|FD_WRITE);
	}
	return m_sock != INVALID_SOCKET;
}

int
CWS2EmulSock::RecvFrom(
    LPWSABUF lpBuffers,
    DWORD dwBufferCount,
    LPDWORD lpNumberOfBytesRecvd,
    LPDWORD lpFlags,
    struct sockaddr FAR * lpFrom,
    LPINT lpFromlen,
    LPWSAOVERLAPPED lpOverlapped,
    LPWSAOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine)
{
	WSAIOREQUEST ioreq;
	int error = 0;
	
	if (lpCompletionRoutine) {
		DWORD thid = GetCurrentThreadId();
		HANDLE hCurProcess;
		if (thid != m_RecvThreadId) {
			// need to create a thread handle for QueueUserAPC
			// typically this will only happen once
			if (!m_RecvQ.IsEmpty())
			{
				// dont allow simultaneous recv access by more than one thread
				error = WSAEINVAL;
			}
			else
			{
				if (m_hRecvThread)
					CloseHandle(m_hRecvThread);
				m_hRecvThread = NULL;

				hCurProcess = GetCurrentProcess();
				m_RecvThreadId = thid;
				if (!DuplicateHandle(

	    			hCurProcess,	// handle to process with handle to duplicate
	    			GetCurrentThread(),	// handle to duplicate
	    			hCurProcess,	// handle to process to duplicate to
	    			&m_hRecvThread,	// pointer to duplicate handle
	    			0,				// access for duplicate handle
	    			FALSE,			// handle inheritance flag
	    			DUPLICATE_SAME_ACCESS 	// optional actions
	   				))
	   			{
	   				error = WSAEINVAL;
	   				m_RecvThreadId = 0;
	   			}
			}
		}
	}
	if (error || dwBufferCount != 1 || !lpOverlapped)
	{
		WSASetLastError(WSAENOBUFS);
		return SOCKET_ERROR;
	}
	
	ioreq.pOverlapped = lpOverlapped;
	if (lpOverlapped)	// cache away ptr to completion routine
		lpOverlapped->Pointer = lpCompletionRoutine;
	ioreq.pRecvFromAddr = lpFrom;
	ioreq.pRecvFromLen = lpFromlen;
	ioreq.wsabuf[0] = lpBuffers[0];
	ioreq.dwBufCount = dwBufferCount;

	m_RecvQ.Put(ioreq);
	//LOG((LOGMSG_RECVFROM1,(UINT)lpOverlapped));
	// signal WS1 send/recv thread
	PostMessage(g_WS2Emul.hWnd, WM_WSA_READWRITE+m_myIndex, m_sock, FD_READ);
	
	WSASetLastError(ERROR_IO_PENDING);
	return SOCKET_ERROR;
}

int CWS2EmulSock::SendTo(
	LPWSABUF lpBuffers,
    DWORD dwBufferCount,
    LPDWORD lpNumberOfBytesSent,
    DWORD dwFlags,
    const struct sockaddr FAR * lpTo,
    int iTolen,
    LPWSAOVERLAPPED lpOverlapped,
    LPWSAOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine)
{
	WSAIOREQUEST ioreq;
	int error = 0;

	if (lpCompletionRoutine) {
		DWORD thid = GetCurrentThreadId();
		HANDLE hCurProcess;
		if (thid != m_SendThreadId) {
			// need to create a thread handle for QueueUserAPC
			if (!m_SendQ.IsEmpty())
			{
				// dont allow simultaneous send access by more than one thread
				error = WSAEINVAL;
			}
			else
			{
				if (m_hSendThread)
					CloseHandle(m_hSendThread);
				m_hSendThread = NULL;

				hCurProcess = GetCurrentProcess();
				m_SendThreadId = thid;
				if (!DuplicateHandle(

	    			hCurProcess,	// handle to process with handle to duplicate
	    			GetCurrentThread(),	// handle to duplicate
	    			hCurProcess,	// handle to process to duplicate to
	    			&m_hSendThread,	// pointer to duplicate handle
	    			0,				// access for duplicate handle
	    			FALSE,			// handle inheritance flag
	    			DUPLICATE_SAME_ACCESS 	// optional actions
	   				))
	   			{
	   				error = WSAEINVAL;
	   				m_SendThreadId = 0;
	   			}
			}
		}
	}
	if (error || dwBufferCount != 1 || iTolen != sizeof(struct sockaddr) || !lpOverlapped)
	{
		WSASetLastError(WSAEINVAL);
		return SOCKET_ERROR;
	}
		
	
	ioreq.pOverlapped = lpOverlapped;
	if (lpOverlapped)	// cache away ptr to completion routine
		lpOverlapped->Pointer = lpCompletionRoutine;
	ioreq.SendToAddr = *lpTo;
	ioreq.wsabuf[0] = lpBuffers[0];
	ioreq.dwBufCount = dwBufferCount;

	m_SendQ.Put(ioreq);
	// signal WS1 send/recv thread
	PostMessage(g_WS2Emul.hWnd, WM_WSA_READWRITE+m_myIndex, m_sock, FD_WRITE);
	
	WSASetLastError(ERROR_IO_PENDING);
	return SOCKET_ERROR;
}

/*
	Close - close the socket and cancel pending i/o
*/
int
CWS2EmulSock::Close()
{
	WSAIOREQUEST ioreq;
	int status;
	
	status = closesocket(m_sock);
	m_sock = NULL;
	while (m_SendQ.Get(&ioreq))
	{
		// complete the request
		ioreq.pOverlapped->Internal = WSA_OPERATION_ABORTED;
		// if there is a callback routine, its address is cached in pOverlapped->Offset
		if (ioreq.pOverlapped->Pointer)
		{
			QueueUserAPC(SendRecvCompleteAPC,m_hSendThread,(DWORD_PTR)ioreq.pOverlapped);
		}
		else
		{
			SetEvent((HANDLE)ioreq.pOverlapped->hEvent);
		}
	}
	while (m_RecvQ.Get(&ioreq))
	{
		// complete the request
		ioreq.pOverlapped->Internal = WSA_OPERATION_ABORTED;
		if (ioreq.pOverlapped->Pointer)
		{
			QueueUserAPC(SendRecvCompleteAPC,m_hRecvThread,(DWORD_PTR)ioreq.pOverlapped);
		}
		else
		{
			SetEvent((HANDLE)ioreq.pOverlapped->hEvent);
		}
	}
	if (m_hSendThread)
	{
		CloseHandle(m_hSendThread);
		m_hSendThread = NULL;
	}
	if (m_hRecvThread)
	{
		CloseHandle(m_hRecvThread);
		m_hRecvThread = NULL;
	}
	return 0;
}

LRESULT
CWS2EmulSock::HandleMessage(WPARAM sock, LPARAM lParam)
{
	WORD wEvent= (WSAGETSELECTEVENT(lParam));
	WORD wError= (WSAGETSELECTERROR(lParam));
	int iRet;
	int status;
	WSAIOREQUEST ioreq;
	HANDLE hThread;
	// make sure the message is intended for this socket
	if ((SOCKET) sock != m_sock)
		return 0;

	// get the first RecvFrom or SendTo request, but leave it on the queue
	// in case the request blocks
	//if (wEvent == FD_READ)
	//	LOG((LOGMSG_ONREAD1, (UINT)sock));
	
	if (wEvent == FD_READ && m_RecvQ.Peek(&ioreq))
	{
		//LOG((LOGMSG_ONREAD2, (UINT)ioreq.pOverlapped));
		iRet = recvfrom(m_sock, ioreq.wsabuf[0].buf, ioreq.wsabuf[0].len, 0, ioreq.pRecvFromAddr, ioreq.pRecvFromLen);
	}
	else if (wEvent == FD_WRITE && m_SendQ.Peek(&ioreq))
	{
		iRet = sendto(m_sock, ioreq.wsabuf[0].buf, ioreq.wsabuf[0].len, 0, &ioreq.SendToAddr, sizeof(ioreq.SendToAddr));
	}
	else	// some other event or no queued request
		return 1;

	// complete send and recv
	
	if(iRet >=0)
	{
		status = 0;
		ioreq.pOverlapped->InternalHigh = iRet;	// numBytesReceived
		
	} else {
		// error (or "would block") case falls out here
		ASSERT(iRet == SOCKET_ERROR);
		status  = WSAGetLastError();
		ioreq.pOverlapped->InternalHigh = 0;
	}
	// check the error - it could be blocking
	if (status != WSAEWOULDBLOCK)
	{
		ioreq.pOverlapped->Internal = status;
		// pull request off the queue
		if (wEvent == FD_READ)
		{
			m_RecvQ.Get(NULL);
			hThread = m_hRecvThread;
			//LOG((LOGMSG_ONREADDONE1, (UINT)ioreq.pOverlapped));
		}
		else // wEvent == FD_WRITE
		{
			m_SendQ.Get(NULL);
			hThread = m_hSendThread;
		}
		
		// complete the request
		if (ioreq.pOverlapped->Pointer)
		{
			// if there is a callback routine, its address is cached in pOverlapped->Offset
			QueueUserAPC(SendRecvCompleteAPC,hThread, (DWORD_PTR)ioreq.pOverlapped);
		}
		else
		{
			SetEvent((HANDLE)ioreq.pOverlapped->hEvent);
		}
			
	}
	return 1;
}	

void __stdcall
SendRecvCompleteAPC(ULONG_PTR dw)
{
	WSAOVERLAPPED *pOverlapped = (WSAOVERLAPPED *)dw;
	LPWSAOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine
		= (LPWSAOVERLAPPED_COMPLETION_ROUTINE) pOverlapped->Pointer;

	//LOG((LOGMSG_RECVFROM2,(UINT)pOverlapped));
	lpCompletionRoutine((DWORD)pOverlapped->Internal, (DWORD)pOverlapped->InternalHigh, pOverlapped, 0);
}
	
inline
CWS2EmulSock *
EmulSockFromSocket(SOCKET s)
{
	return ( ((UINT) s < MAX_EMUL_SOCKETS) ? g_WS2Emul.m_pEmulSocks[s] : NULL);
}

inline SOCKET MapSocket(SOCKET s)
{
	return (((UINT) s < MAX_EMUL_SOCKETS) && g_WS2Emul.m_pEmulSocks[s] ? g_WS2Emul.m_pEmulSocks[s]->GetSocket() : INVALID_SOCKET);
}

SOCKET
PASCAL
WS2EmulSocket(
    int af,
    int type,
    int protocol,
    LPWSAPROTOCOL_INFO lpProtocolInfo,
    GROUP,
    DWORD)
{
	SOCKET s = INVALID_SOCKET;
	int i;
	CWS2EmulSock *pESock;
	if (g_WS2Emul.numSockets == MAX_EMUL_SOCKETS)
		return s;

	EnterCriticalSection(&g_WS2Emul.extcs);
	if (af == FROM_PROTOCOL_INFO)
		af = lpProtocolInfo->iAddressFamily;
	if (type == FROM_PROTOCOL_INFO)
		type = lpProtocolInfo->iSocketType;
	if (protocol == FROM_PROTOCOL_INFO)
		protocol = lpProtocolInfo->iProtocol;

	for (i=0;i<MAX_EMUL_SOCKETS;i++)
	{
		if (g_WS2Emul.m_pEmulSocks[i] == NULL)
		{
			pESock = new CWS2EmulSock(i);
			if (pESock) {
				if (++g_WS2Emul.numSockets == 1)
				{
					StartWS1MsgThread();
				}
				if (pESock->NewSock(af,type,protocol))
				{
					g_WS2Emul.m_pEmulSocks[i] = pESock;
					s = (SOCKET)i;
				} else {
					delete pESock;
					if (--g_WS2Emul.numSockets == 0)
					{
						StopWS1MsgThread();
					}
				}
			}
			break;
		}
	}
	LeaveCriticalSection(&g_WS2Emul.extcs);
	return s;
			
}

int
PASCAL
WS2EmulRecvFrom(
    SOCKET s,
    LPWSABUF lpBuffers,
    DWORD dwBufferCount,
    LPDWORD lpNumberOfBytesRecvd,
    LPDWORD lpFlags,
    struct sockaddr FAR * lpFrom,
    LPINT lpFromlen,
    LPWSAOVERLAPPED lpOverlapped,
    LPWSAOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine
    )
{
	CWS2EmulSock *pESock;
	int iret;
	EnterCriticalSection(&g_WS2Emul.extcs);

	if (pESock = EmulSockFromSocket(s))
	{
		EnterCriticalSection(&g_WS2Emul.intcs);
		iret =  pESock->RecvFrom(lpBuffers, dwBufferCount, lpNumberOfBytesRecvd,
 						lpFlags,
    					lpFrom, lpFromlen,
    					lpOverlapped, lpCompletionRoutine);
    	LeaveCriticalSection(&g_WS2Emul.intcs);
    }
    else
    {
    	WSASetLastError(WSAENOTSOCK);
    	iret = SOCKET_ERROR;
    }
    LeaveCriticalSection(&g_WS2Emul.extcs);

	return iret;
}
/*----------------------------------------------------------------------------
 * Function: WS2EmulSendCB
 * Description: private Winsock callback
 * This is only called if WS2EmulSendTo is called in synchronous mode
 * (i.e.) lpOverlapped == NULL. In that case, the sync call is converted to async
 * using a private Overlapped struct, and the WS2EmulSendTo api blocks until
 * this routine sets the hEvent field to TRUE;
 * Input:
 *
 * Return: None
 *--------------------------------------------------------------------------*/
void CALLBACK WS2EmulSendCB (DWORD dwError,
						 DWORD cbTransferred,
                         LPWSAOVERLAPPED lpOverlapped,
                         DWORD dwFlags)
{
	lpOverlapped->Internal = dwError;
    lpOverlapped->InternalHigh = cbTransferred;
    lpOverlapped->hEvent = (WSAEVENT) TRUE;
}

int
PASCAL
WS2EmulSendTo(
	SOCKET s,
    LPWSABUF lpBuffers,
    DWORD dwBufferCount,
    LPDWORD lpNumberOfBytesSent,
    DWORD dwFlags,
    const struct sockaddr FAR * lpTo,
    int iTolen,
    LPWSAOVERLAPPED lpOverlapped,
    LPWSAOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine
    )
{
	CWS2EmulSock *pESock;
	int iret;
	BOOL fSync = FALSE;
	
	EnterCriticalSection(&g_WS2Emul.extcs);
	if (pESock = EmulSockFromSocket(s))
	{
		if (!lpOverlapped)
		{
			// synchronous call - we use our own overlapped struct to issue the
			// send request.
			lpOverlapped = pESock->GetSendOverlapped();
			lpOverlapped->hEvent = (WSAEVENT) FALSE;	// will be set to TRUE in Callback
			lpCompletionRoutine =  &WS2EmulSendCB;
			fSync = TRUE;
		}

		EnterCriticalSection(&g_WS2Emul.intcs);
		iret = pESock->SendTo(lpBuffers, dwBufferCount, lpNumberOfBytesSent,
 						dwFlags,
    					lpTo, iTolen,
    					lpOverlapped, lpCompletionRoutine);
		LeaveCriticalSection(&g_WS2Emul.intcs);

		if (fSync) {
			DWORD dwError;
			if (iret == SOCKET_ERROR)
			{
				dwError = WSAGetLastError();
				if (dwError != WSA_IO_PENDING) {
					// there was an error so there will not be a callback
					lpOverlapped->hEvent = (WSAEVENT) TRUE;
					lpOverlapped->Internal = dwError;
				}
			}
			// wait for the call to complete
			// WS2EmulSendCB sets the hEvent field to TRUE and sets the Internal field to
			// the completion status
			while (!lpOverlapped->hEvent)
			{
				dwError =SleepEx(5000,TRUE);	// WARNING: sleeping inside a Critical Section
				ASSERT(dwError == WAIT_IO_COMPLETION);
			}
			WSASetLastError((int)lpOverlapped->Internal);
			if (lpNumberOfBytesSent)
				*lpNumberOfBytesSent = (DWORD)lpOverlapped->InternalHigh;
			iret = lpOverlapped->Internal ? SOCKET_ERROR : 0;
		}

    }
    else
    {
    	WSASetLastError(WSAENOTSOCK);
    	iret = SOCKET_ERROR;
    }
	LeaveCriticalSection(&g_WS2Emul.extcs);
	return iret;
}

int
PASCAL
WS2EmulCloseSocket(SOCKET s)
{
	CWS2EmulSock *pESock;	
	int iret;
	EnterCriticalSection(&g_WS2Emul.extcs);

	if (pESock = EmulSockFromSocket(s))
	{
		// shut out access to this socket
		// by the MsgThread
		EnterCriticalSection(&g_WS2Emul.intcs);
		g_WS2Emul.m_pEmulSocks[s] = NULL;
		pESock->Close();
		delete pESock;
		LeaveCriticalSection(&g_WS2Emul.intcs);
		if (--g_WS2Emul.numSockets == 0)
		{
			// cant stop the thread with while holding intcs
			StopWS1MsgThread();
		}

		iret =  0;
    }
    else
    {
    	WSASetLastError(WSAENOTSOCK);
    	iret = SOCKET_ERROR;
    }
	LeaveCriticalSection(&g_WS2Emul.extcs);
	return iret;
}

int
PASCAL
WS2EmulSetSockOpt(
	SOCKET s, int level,int optname,const char FAR * optval,int optlen)
{
	return setsockopt(MapSocket(s), level, optname, optval, optlen);
}

int
PASCAL
WS2EmulBind( SOCKET s, const struct sockaddr FAR * name, int namelen)
{
	return bind(MapSocket(s), name, namelen);
}

int
PASCAL
WS2EmulGetSockName(	SOCKET s, 	
    struct sockaddr * name,	
    int * namelen )
{
	return getsockname(MapSocket(s), name, namelen);
}

int
PASCAL
WS2EmulHtonl(
    SOCKET s,
    u_long hostlong,
    u_long FAR * lpnetlong
    )
{
	*lpnetlong = htonl(hostlong);
	return 0;
}
int
PASCAL
WS2EmulHtons(
    SOCKET s,
    u_short hostshort,
    u_short FAR * lpnetshort
    )
{
	*lpnetshort = htons(hostshort);
	return 0;
}

int
PASCAL
WS2EmulNtohl(
    SOCKET s,
    u_long netlong,
    u_long FAR * lphostlong
    )
{
	*lphostlong = ntohl(netlong);
	return 0;
}

int
PASCAL
WS2EmulNtohs(
    SOCKET s,
    u_short netshort,
    u_short FAR * lphostshort
    )
{
	*lphostshort = ntohs(netshort);
	return 0;
}

int
PASCAL
WS2EmulGetHostName(char *name, int namelen)
{
	return gethostname(name, namelen);
}

struct hostent FAR *
PASCAL
WS2EmulGetHostByName(const char * name)
{
	return gethostbyname(name);
}

SOCKET
PASCAL
WS2EmulJoinLeaf(
    SOCKET s,
    const struct sockaddr FAR * name,
    int namelen,
    LPWSABUF lpCallerData,
    LPWSABUF lpCalleeData,
    LPQOS lpSQOS,
    LPQOS lpGQOS,
    DWORD dwFlags
    )
{
	ASSERT(0);
	return (-1);
}

int
PASCAL
WS2EmulIoctl(SOCKET s,    DWORD dwIoControlCode,    LPVOID lpvInBuffer,
    DWORD cbInBuffer,    LPVOID lpvOutBuffer,    DWORD cbOutBuffer,
    LPDWORD lpcbBytesReturned,    LPWSAOVERLAPPED,    LPWSAOVERLAPPED_COMPLETION_ROUTINE
    )

{
	ASSERT(0);
	return -1;
}

BOOL StartWS1MsgThread()
{
	DWORD threadId;
	DWORD dwStatus;
	ASSERT(g_WS2Emul.hMsgThread == 0);
	g_WS2Emul.hAckEvent = CreateEvent(NULL,FALSE,FALSE,NULL);
	g_WS2Emul.hMsgThread = CreateThread(NULL,0, WS1MsgThread, 0, 0, &threadId);
	dwStatus = WaitForSingleObject(g_WS2Emul.hAckEvent,INFINITE);
	return dwStatus == WAIT_OBJECT_0;
}

BOOL StopWS1MsgThread()
{
	if (g_WS2Emul.hMsgThread && g_WS2Emul.hWnd)
	{
		PostMessage(g_WS2Emul.hWnd, WM_CLOSE, 0, 0);
		WaitForSingleObject(g_WS2Emul.hMsgThread,INFINITE);
		CloseHandle(g_WS2Emul.hMsgThread);
		CloseHandle(g_WS2Emul.hAckEvent);
		g_WS2Emul.hMsgThread = NULL;
		g_WS2Emul.hAckEvent = NULL;
	}
	return TRUE;
}

LRESULT CALLBACK WS1WindowProc(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
	int i;
	CWS2EmulSock *pESock;
	EnterCriticalSection(&g_WS2Emul.intcs);
	
	if (pESock = EmulSockFromSocket(msg - WM_WSA_READWRITE))
	{
		
		LRESULT l = pESock->HandleMessage(wParam, lParam);
		LeaveCriticalSection(&g_WS2Emul.intcs);
		return l;
	}
	LeaveCriticalSection(&g_WS2Emul.intcs);
	if (msg == WM_DESTROY)
		PostQuitMessage(0);

	return (DefWindowProc(hWnd, msg, wParam, lParam));
}

DWORD WINAPI WS1MsgThread (LPVOID )
{

	HRESULT hr;
	BOOL fChange = FALSE;
	MSG msg;

	// Register hidden window class:
	WNDCLASS wcHidden =
	{
		0L,
		WS1WindowProc,
		0,
		0,
		GetModuleHandle(NULL),
		NULL,
		NULL,
		NULL,
		NULL,
		"WS1EmulWindowClass"
	};
	if (RegisterClass(&wcHidden)) {
	// Create hidden window
			// Create a hidden window for event processing:
		g_WS2Emul.hWnd = ::CreateWindow(	"WS1EmulWindowClass",
										"",
										WS_POPUP, // not visible!
										0, 0, 0, 0,
										NULL,
										NULL,
										GetModuleHandle(NULL),
										NULL);
		
	}

	if(!g_WS2Emul.hWnd)
	{	
		hr = GetLastError();
		goto CLEANUPEXIT;
	}
	//SetThreadPriority(m_hRecvThread, THREAD_PRIORITY_ABOVE_NORMAL);

    // This function is guaranteed to create a queue on this thread
    PeekMessage(&msg, NULL, 0, 0, PM_NOREMOVE);

	// notify thread creator that we're ready to recv messages
	SetEvent(g_WS2Emul.hAckEvent);


	// Wait for control messages  or Winsock messages directed to
	// our hidden window
	while (GetMessage(&msg, NULL, 0, 0)) {
        TranslateMessage(&msg);
        DispatchMessage(&msg);
    }
	g_WS2Emul.hWnd = NULL;
    hr = S_OK;

CLEANUPEXIT:
	UnregisterClass("WS1EmulWindowClass",GetModuleHandle(NULL));
    SetEvent(g_WS2Emul.hAckEvent);
    return hr;
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\core\clrefcnt.cpp ===
// File: clrefcnt.cpp
//
// RefCount class

#include "precomp.h"


/*  R E F  C O U N T  */
/*-------------------------------------------------------------------------
    %%Function: RefCount
    
-------------------------------------------------------------------------*/
RefCount::RefCount(OBJECTDESTROYEDPROC ObjectDestroyed)
{
	ASSERT((!ObjectDestroyed) ||
		IS_VALID_CODE_PTR(ObjectDestroyed, OBJECTDESTROYEDPROC));

	m_ulcRef = 1;
	m_ObjectDestroyed = ObjectDestroyed;
	DbgMsgRefCount("Ref: %08X c=%d (created)", this, m_ulcRef);

	ASSERT(IS_VALID_STRUCT_PTR(this, CRefCount));
}


RefCount::~RefCount(void)
{
	ASSERT(IS_VALID_STRUCT_PTR(this, CRefCount));

	// m_ulcRef may be any value.
	DbgMsgRefCount("Ref: %08X c=%d (destroyed)", this, m_ulcRef);

	if (m_ObjectDestroyed)
	{
		m_ObjectDestroyed();
		m_ObjectDestroyed = NULL;
	}

	ASSERT(IS_VALID_STRUCT_PTR(this, CRefCount));
}


ULONG STDMETHODCALLTYPE RefCount::AddRef(void)
{
	ASSERT(IS_VALID_STRUCT_PTR(this, CRefCount));

	ASSERT(m_ulcRef < ULONG_MAX);
	m_ulcRef++;
	DbgMsgRefCount("Ref: %08X c=%d (AddRef)", this, m_ulcRef);

	ASSERT(IS_VALID_STRUCT_PTR(this, CRefCount));

	return m_ulcRef;
}


ULONG STDMETHODCALLTYPE RefCount::Release(void)
{
	ASSERT(IS_VALID_STRUCT_PTR(this, CRefCount));

	if (m_ulcRef > 0)
	{
		m_ulcRef--;
	}

	ULONG ulcRef = m_ulcRef;
	DbgMsgRefCount("Ref: %08X c=%d (Release)", this, m_ulcRef);

	if (! ulcRef)
	{
		delete this;
	}

	return ulcRef;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\core\confqos.h ===
// File: confqos.h

#ifndef _CONFQOS_H_
#define _CONFQOS_H_


// Don't use more than 90% of the CPU among all the components
// registered with the QoS module
#define MSECS_PER_SEC    900

struct IQoS;

class CQoS
{
protected:
	IQoS  * m_pIQoS;

	HRESULT SetClients(void);
	HRESULT SetResources(int nBandWidth);

public:
	CQoS();
	~CQoS();
	HRESULT  Initialize();
	HRESULT  SetBandwidth(UINT uBandwidth);
	ULONG    GetCPULimit();
};

extern CQoS* g_pQoS;

#endif  // _CONFQOS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\core\connpnts.h ===
// File: connpnts.h

#ifndef _IMCONNPT_H_
#define _IMCONNPT_H_

#include "nmenum.h"


typedef HRESULT (*CONN_NOTIFYPROC)(IUnknown *pUnk, void *pv, REFIID riid);

//****************************************************************************
// CConnectionPoint definition
//****************************************************************************
//

class CConnectionPoint : public IConnectionPoint, public DllRefCount
{
private:
	IID 					m_riid;
	IConnectionPointContainer *m_pCPC;
	ULONG					m_cSinks;
    ULONG                   m_cAllocatedSinks;
	IUnknown				**m_rgSinks;

public:
	// Constructor and destructor
	CConnectionPoint (
		const IID *pIID,
		IConnectionPointContainer *pCPCInit);
	~CConnectionPoint (void);

	// Class public functions
	void					ContainerReleased() {m_pCPC = NULL;}
	STDMETHODIMP			Notify (void *pv, CONN_NOTIFYPROC pfn);

	// IUnknown
	STDMETHODIMP			QueryInterface (REFIID iid, void **ppv);
	STDMETHODIMP_(ULONG)	AddRef (void);
	STDMETHODIMP_(ULONG)	Release (void);

	// IConnectionPoint
	STDMETHODIMP			GetConnectionInterface(IID *pIID);
	STDMETHODIMP			GetConnectionPointContainer(IConnectionPointContainer **ppCPC);
	STDMETHODIMP			Advise(IUnknown *pUnk, DWORD *pdwCookie);
	STDMETHODIMP			Unadvise(DWORD dwCookie);
	STDMETHODIMP			EnumConnections(IEnumConnections **ppEnum);
};

//****************************************************************************
// CEnumConnections definition
//****************************************************************************
//
class CEnumConnections : public IEnumConnections, public DllRefCount
{
private:
	int				m_iIndex;
	int				m_cConnections;
	CONNECTDATA*	m_pCD;

public:
	// Constructor and Initialization
	CEnumConnections (IUnknown **pSinks, ULONG cSink, ULONG cAllocatedSinks);
	~CEnumConnections (void);

	// IUnknown
	STDMETHODIMP			QueryInterface (REFIID iid, void **ppv);
	STDMETHODIMP_(ULONG)	AddRef (void);
	STDMETHODIMP_(ULONG)	Release (void);

	// IEnumConnections
	STDMETHODIMP			Next(ULONG cConnections, CONNECTDATA *rgpcn,
								 ULONG *pcFetched);
	STDMETHODIMP			Skip(ULONG cConnections);
	STDMETHODIMP			Reset();
	STDMETHODIMP			Clone(IEnumConnections **ppEnum);
};

VOID RemoveCp(CConnectionPoint ** ppCp);

class CConnectionPointContainer : public IConnectionPointContainer
{
private:
	CConnectionPoint ** m_ppCp;
	int m_cCp;

public:
	CConnectionPointContainer(const IID **ppiid, int cCp);
	~CConnectionPointContainer();

	HRESULT STDMETHODCALLTYPE NotifySink(void *pv, CONN_NOTIFYPROC pfn);

	// IConnectionPointContainer methods
	STDMETHODIMP EnumConnectionPoints(IEnumConnectionPoints **ppEnum);
	STDMETHODIMP FindConnectionPoint(REFIID riid, IConnectionPoint **ppCp);
};

typedef CEnumNmX<IEnumConnectionPoints, &IID_IEnumConnectionPoints, IConnectionPoint, CConnectionPoint> CEnumConnectionPoints;

#endif // _IMCONNPT_H_

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\core\cuserdta.cpp ===
#include "precomp.h"

// CP: DCL's header redefines this:
#ifdef CLEAR_FLAG
#undef CLEAR_FLAG
#endif // CLEAR_FLAG

#include <cstring.hpp>
#include <cuserdta.hpp>
#include <oprahcom.h>

USER_DATA_LIST::USER_DATA_LIST()
{
    numEntries = 0;
    pUserDataArray = NULL;
}

USER_DATA_LIST::~USER_DATA_LIST()
{
	POSITION pHead;

	while ((pHead = GetHeadPosition()) != NULL)
	{
		RemoveAt(pHead);
	}

    delete[] pUserDataArray;
}

DWORD USER_DATA_LIST::AddUserData(GUID * pGUID, unsigned short nData, PVOID pData)
{
    ASSERT(pGUID);
    ASSERT(!nData || pData);

    POSITION            Position;
    unsigned char *     pWork;
    unsigned short      nDataPlusHeader = nData+sizeof(GUID);
    GCCUserData *       pUserData;
    LPOSTR              pOctetString;

    // If there is already an entry in the list
    // for the GUID, then delete it.

    DeleteEntry(pGUID);

    // Now go and add the new entry to the list.

    pUserData = new GCCUserData;
    pOctetString = new OSTR;
    if ((pUserData) && 
        (pOctetString) &&
        (nDataPlusHeader <= 0xffff)) {
        pWork = new unsigned char[nDataPlusHeader];
        if (pWork) {
            pUserData->octet_string = pOctetString;
            pOctetString->value = pWork;
            pOctetString->length = nDataPlusHeader;
            *(GUID *)pWork = *pGUID;
            pWork += sizeof(GUID);
            memcpy(pWork, pData, nData);
            Position = AddTail(pUserData);
            if (Position) {
                numEntries++;
                return NO_ERROR;
            }
            delete pWork;
        }
    }
    delete pOctetString;
    delete pUserData;
    return UI_RC_OUT_OF_MEMORY;
}

void USER_DATA_LIST::DeleteEntry(GUID * pGUID)
{
    POSITION    Position;

    Position = Lookup(pGUID);
    if (Position) {
        RemoveAt(Position);
    }
}

void * USER_DATA_LIST::RemoveAt(POSITION Position)
{
    ASSERT(Position);
    GCCUserData * pUserData = (GCCUserData *)GetFromPosition(Position);

    if (pUserData) {

        delete pUserData->octet_string->value;
        delete pUserData->octet_string;
        delete pUserData;
        COBLIST::RemoveAt(Position);
        numEntries--;
    }
    return pUserData;
}

DWORD USER_DATA_LIST::GetUserDataList(unsigned short * pnRecords,
                                      GCCUserData *** pppUserData)
{
    POSITION        Position;
    GCCUserData **  pUserDataArrayTemp;
    DWORD           Status = NO_ERROR;

    delete[] pUserDataArray;
    *pnRecords = 0;
    *pppUserData = NULL;
    if (numEntries) {

        // Allocate memory.

        pUserDataArray = new GCCUserData * [numEntries];
        if (!pUserDataArray) {
            Status = UI_RC_OUT_OF_MEMORY;
        }
        else {
            *pnRecords = numEntries;
            *pppUserData = pUserDataArray;

            // Fill in array.

            pUserDataArrayTemp = pUserDataArray;
	        Position = GetHeadPosition();
	        while (Position) {
		        *(pUserDataArrayTemp++) = (GCCUserData *)GetNext(Position);
	        }
        }
    }
    return NO_ERROR;
}

BOOL USER_DATA_LIST::Compare(void* pItemToCompare, void* pGUID)
{
    return(memcmp(((GCCUserData *)pItemToCompare)->octet_string->value, 
                  pGUID, 
                  sizeof(GUID)) == 0);
}

HRESULT USER_DATA_LIST::GetUserData(REFGUID rguid, BYTE ** ppb, ULONG *pcb)
{
	POSITION Position = Lookup((PVOID)&rguid);

	if (pcb == NULL)
		return E_POINTER;

	if (Position) {
		GCCUserData * pUserData = (GCCUserData *)Position->pItem;
		*pcb = pUserData->octet_string->length - sizeof(GUID);
		*ppb = (PBYTE)CoTaskMemAlloc(*pcb);
		CopyMemory(*ppb,pUserData->octet_string->value + sizeof(GUID),*pcb);
		return S_OK;
	}
	else {
		*ppb = NULL;
		*pcb = 0;
		return E_INVALIDARG;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\core\confqos.cpp ===
// File: confqos.cpp

#include "precomp.h"

#include <nacguids.h>
#include <initguid.h>
#include <datguids.h>
#include <common.h>
#include <nmqos.h>
#include "confqos.h"

/***************************************************************************

    Name      : CQoS

    Purpose   :

    Parameters:	NONE

    Returns   : HRESULT

    Comment   :

***************************************************************************/
CQoS::CQoS() :
    m_pIQoS(NULL)
{
}

/***************************************************************************

    Name      : ~CQoS

    Purpose   : Releases the Quality of Service objects and frees the DLL

    Parameters:	NONE

    Returns   : HRESULT

    Comment   :

***************************************************************************/
CQoS::~CQoS()
{
	// release the object
	if (m_pIQoS)
    {
		m_pIQoS->Release();
    }
}

/***************************************************************************

    Name      : Initialize

    Purpose   : Loads the QoS DLL and instantiates a QoS object

    Parameters:	hWnd    - handle to the window/dialog which called us

    Returns   : HRESULT

    Comment   :

***************************************************************************/
HRESULT CQoS::Initialize(void)
{
	HRESULT hr = S_OK;

	// create the QoS object and get the IQoS interface
	// CoInitialize is called in conf.cpp
	hr = CoCreateInstance(	CLSID_QoS,
							NULL,
							CLSCTX_INPROC_SERVER,
							IID_IQoS,
							(void **) &m_pIQoS);
	if (FAILED(hr))
	{
		WARNING_OUT(("CQoS: Could not obtain an IQoS interface, hr=0x%08lX", hr));		
	}
	else
	{
		SetClients();
		// Tell the QoS about available resources. Since the wizard will
        // provide the bandwidth info, we'll have to call SetResources
		// again later with the bandwidth, but we need to call it here
		// to make the CPU info available to the wizard
		SetResources(BW_288KBS_BITS);
	}

    return hr;
}

/***************************************************************************

    Name      : CQoS::SetResources

    Purpose   : Sets the initial available resources on the QoS module,
					i.e. configures the QoS module to how much is
					available from each resource.

    Parameters:	nBandWidth  - Maximum connection speed

    Returns   : HRESULT

    Comment   : The QoS module may select to override these settings

***************************************************************************/
HRESULT CQoS::SetResources(int nBandWidth)
{
	LPRESOURCELIST prl = NULL;
	HRESULT hr = S_OK;
    const int cResources = 3;

    ASSERT(m_pIQoS);

    DbgMsg(iZONE_API, "CQoS: SetResources(Bandwidth = %d)", nBandWidth);

    // allocate space for the resource list (which already includes
	// space for one resource), plus (cResources-1) more resources
	prl = (LPRESOURCELIST) MemAlloc(sizeof(RESOURCELIST) +
									(cResources-1)*sizeof(RESOURCE));
	if (NULL == prl)
	{
		ERROR_OUT(("CQoS: SetResources - MemAlloc failed"));
	}
	else
	{
        ZeroMemory(prl, sizeof(RESOURCELIST) + (cResources-1)*sizeof(RESOURCE));

		// fill in the resource list
		prl->cResources = cResources;
		prl->aResources[0].resourceID = RESOURCE_OUTGOING_BANDWIDTH;
		prl->aResources[0].nUnits = nBandWidth;
		prl->aResources[1].resourceID = RESOURCE_INCOMING_BANDWIDTH;
		prl->aResources[1].nUnits = nBandWidth;
		prl->aResources[2].resourceID = RESOURCE_CPU_CYCLES;
		prl->aResources[2].nUnits = MSECS_PER_SEC;

		// set the resources on the QoS object
		hr = m_pIQoS->SetResources(prl);
		if (FAILED(hr))
		{
			ERROR_OUT(("CQoS: SetResources: Fail, hr=0x%x", hr));
		}

		MemFree(prl);
	}

	return hr;
}

/***************************************************************************

    Name      : CQoS::SetBandwidth

    Purpose   : Sets the initial available resources on the QoS module,
					i.e. configures the QoS module to how much is
					available from each resource.

    Parameters:

    Returns   : HRESULT

    Comment   : The QoS module may select to override these settings

***************************************************************************/
HRESULT CQoS::SetBandwidth(UINT uBandwidth)
{
    return SetResources(uBandwidth);
}

/***************************************************************************

	Name	  : CQoS::GetCPULimit

	Purpose   : Gets the total allowed CPU percentage use from QoS

	Parameters: 

	Returns   : How much of the CPU can be used, in percents. 0 means failure

	Comment   :

***************************************************************************/
ULONG CQoS::GetCPULimit()
{
	LPRESOURCELIST pResourceList=NULL;
	ULONG ulCPUPercents=0;
	ULONG i;
	HRESULT hr = NOERROR;

    ASSERT(m_pIQoS);

	// get a list of all resources from QoS
	hr = m_pIQoS->GetResources(&pResourceList);
	if (FAILED(hr) || (NULL == pResourceList))
	{
		ERROR_OUT(("GetQoSCPULimit: GetResources failed"));
	}
	else
	{
		// find the CPU resource
		for (i=0; i < pResourceList->cResources; i++)
		{
			if (pResourceList->aResources[i].resourceID == RESOURCE_CPU_CYCLES)
			{
				// QoS keeps the CPU units as the number of ms in a sec that the
				// CPU can be used. Need to divide by 10 to get percents
				ulCPUPercents = pResourceList->aResources[i].nUnits / 10;
				break;
			}
		}
		m_pIQoS->FreeBuffer(pResourceList);
	}

	return ulCPUPercents;
}


/***************************************************************************

    Name      : CQoS::SetClients

    Purpose   : Set the priorities of requesting clients so that the QoS module
					will know who should get more resources

    Parameters:	None

    Returns   : HRESULT

    Comment   :

***************************************************************************/
HRESULT CQoS::SetClients(void)
{
	LPCLIENTLIST pcl = NULL;
	ULONG i;
	HRESULT hr = S_OK;
	ULONG cClients = 3;	// audio, video and data

    ASSERT(m_pIQoS);


	// allocate space for the client list (which already includes
	// space for one client), plus (cClients-1) more clients
	pcl = (LPCLIENTLIST) MemAlloc(sizeof(CLIENTLIST) +
									(cClients-1)*sizeof(CLIENT));
	if (NULL == pcl)
	{
		ERROR_OUT(("CQoS: SetClient - MemAlloc failed"));
	}
	else
	{
		ZeroMemory(pcl, sizeof(CLIENTLIST) +
										(cClients-1)*sizeof(CLIENT));

		// fill in the resource list
		pcl->cClients = cClients;

		i=0;
		// Audio
		pcl->aClients[i].guidClientGUID = MEDIA_TYPE_H323AUDIO;
		pcl->aClients[i].wszName[0] = L'A'; // A=Audio
		pcl->aClients[i++].priority = 1;

		// Data
		pcl->aClients[i].guidClientGUID = MEDIA_TYPE_T120DATA;
		pcl->aClients[i].wszName[0] = L'D'; // D=Data
		pcl->aClients[i++].priority = 2;

		// Audio
		pcl->aClients[i].guidClientGUID = MEDIA_TYPE_H323VIDEO;
		pcl->aClients[i].wszName[0] = L'V';  // V=Video
		pcl->aClients[i++].priority = 3;

		// the rest of the fields are not important and were set to 0 above

		// set the clients info on the QoS module
		hr = m_pIQoS->SetClients(pcl);
		if (FAILED(hr))
		{
			ERROR_OUT(("CQoS: SetClients: Fail, hr=0x%x", hr));
		}

		MemFree(pcl);
	}

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\core\debug.cpp ===
// File: debug.cpp

#include "precomp.h"

#ifdef DEBUG  // THE WHOLE FILE !

#ifndef HACK
HDBGZONE ghZoneOther = NULL; // Other, conf.exe specific zones
#define ghZones  ghZoneOther // Hack: The above should be called ghZones
#else
HDBGZONE ghZones = NULL; // Other, conf.exe specific zones
#endif

static PTCHAR _rgZones[] = {
	TEXT("Core"),
	TEXT("Api"),
	TEXT("RefCount"),
	TEXT("Manager"),
	TEXT("Calls"),
	TEXT("Conference"),
	TEXT("Members"),
	TEXT("A/V"),
	TEXT("FT"),
	TEXT("SysInfo"),
	TEXT("Objects "),
	TEXT("DC"),
};

VOID DbgMsg(int iZone, PSTR pszFormat,...)
{
	if (GETZONEMASK(ghZoneOther) & (1 << iZone))
	{
		va_list v1;
		va_start(v1, pszFormat);
		DbgZVPrintf(ghZoneOther, iZone, pszFormat, v1);
		va_end(v1);
	}
}

VOID DbgInitZones(VOID)
{
	ASSERT(::InitDebugModule(TEXT("NMCOM")));
	DBGINIT(&ghZones, _rgZones);
}

VOID DbgFreeZones(VOID)
{
	DBGDEINIT(&ghZones);
	ExitDebugModule();
}

VOID DbgMsgRefCount(PSTR pszFormat,...)
{
	if (GETZONEMASK(ghZones) & ZONE_REFCOUNT)
	{
		va_list v1;
		va_start(v1, pszFormat);
		DbgZVPrintf(ghZones, iZONE_REFCOUNT, pszFormat, v1);
		va_end(v1);
	}
}

VOID DbgMsgApi(PSTR pszFormat,...)
{
	if (GETZONEMASK(ghZones) & ZONE_API)
	{
		va_list v1;
		va_start(v1, pszFormat);
		DbgZVPrintf(ghZones, iZONE_API, pszFormat, v1);
		va_end(v1);
	}
}

VOID DbgMsgManager(PSTR pszFormat,...)
{
	if (GETZONEMASK(ghZones) & ZONE_MANAGER)
	{
		va_list v1;
		va_start(v1, pszFormat);
		DbgZVPrintf(ghZones, iZONE_MANAGER, pszFormat, v1);
		va_end(v1);
	}
}

VOID DbgMsgCall(PSTR pszFormat,...)
{
	if (GETZONEMASK(ghZones) & ZONE_CALL)
	{
		va_list v1;
		va_start(v1, pszFormat);
		DbgZVPrintf(ghZones, iZONE_CALL, pszFormat, v1);
		va_end(v1);
	}
}

VOID DbgMsgConference(PSTR pszFormat,...)
{
	if (GETZONEMASK(ghZones) & ZONE_CONFERENCE)
	{
		va_list v1;
		va_start(v1, pszFormat);
		DbgZVPrintf(ghZones, iZONE_CONFERENCE, pszFormat, v1);
		va_end(v1);
	}
}

VOID DbgMsgMember(PSTR pszFormat,...)
{
	if (GETZONEMASK(ghZones) & ZONE_MEMBER)
	{
		va_list v1;
		va_start(v1, pszFormat);
		DbgZVPrintf(ghZones, iZONE_MEMBER, pszFormat, v1);
		va_end(v1);
	}
}

VOID DbgMsgAV(PSTR pszFormat,...)
{
	if (GETZONEMASK(ghZones) & ZONE_AV)
	{
		va_list v1;
		va_start(v1, pszFormat);
		DbgZVPrintf(ghZones, iZONE_AV, pszFormat, v1);
		va_end(v1);
	}
}

VOID DbgMsgFT(PSTR pszFormat,...)
{
	if (GETZONEMASK(ghZones) & ZONE_FT)
	{
		va_list v1;
		va_start(v1, pszFormat);
		DbgZVPrintf(ghZones, iZONE_FT, pszFormat, v1);
		va_end(v1);
	}
}

VOID DbgMsgSysInfo(PSTR pszFormat,...)
{
	if (GETZONEMASK(ghZones) & ZONE_SYSINFO)
	{
		va_list v1;
		va_start(v1, pszFormat);
		DbgZVPrintf(ghZones, iZONE_SYSINFO, pszFormat, v1);
		va_end(v1);
	}
}

VOID DbgMsgDc(PSTR pszFormat,...)
{
	if (GETZONEMASK(ghZones) & ZONE_DC)
	{
		va_list v1;
		va_start(v1, pszFormat);
		DbgZVPrintf(ghZones, iZONE_DC, pszFormat, v1);
		va_end(v1);
	}
}

#endif /* DEBUG  - THE WHOLE FILE ! */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\core\cncodes.h ===
#ifndef _CNCODES_H_
#define _CNCODES_H_

const UINT_PTR CN_RC_NOERROR =							0;
const UINT_PTR CN_MASK =								0xee00;
const UINT_PTR CN_RC_CONFERENCE_CREATE_FAILED = 		(CN_MASK | 0x01);
const UINT_PTR CN_RC_CONNECT_FAILED =					(CN_MASK | 0x02);
const UINT_PTR CN_RC_ALREADY_IN_CONFERENCE =			(CN_MASK | 0x03);
const UINT_PTR CN_RC_CONFERENCE_JOIN_DENIED =			(CN_MASK | 0x04);
const UINT_PTR CN_RC_CONFERENCE_INVITE_DENIED = 		(CN_MASK | 0x05);
const UINT_PTR CN_RC_CONFERENCE_NAME_NEEDED =			(CN_MASK | 0x06);
const UINT_PTR CN_RC_CONFERENCE_LEAVE_FAILED =			(CN_MASK | 0x07);
const UINT_PTR CN_RC_INVALID_PASSWORD = 				(CN_MASK | 0x08);
const UINT_PTR CN_RC_NAME_RESOLUTION_FAILED =			(CN_MASK | 0x09);
const UINT_PTR CN_RC_NOT_INITIALIZED =					(CN_MASK | 0x0a);
const UINT_PTR CN_RC_UNSPECIFIED_ERROR =				(CN_MASK | 0x0b);
const UINT_PTR CN_RC_CONFERENCE_DOES_NOT_EXIST =		(CN_MASK | 0x0c);
const UINT_PTR CN_RC_AUDIO_CONNECT_FAILED = 			(CN_MASK | 0x0d);
const UINT_PTR CN_RC_AUDIO_FAILED_AFTER_DATA =			(CN_MASK | 0x0e);
const UINT_PTR CN_RC_CONFERENCE_ENDED_BEFORE_JOIN = 	(CN_MASK | 0x0f);
const UINT_PTR CN_RC_CANT_INVITE_MCU =					(CN_MASK | 0x10);
const UINT_PTR CN_RC_INVITE_DENIED_REMOTE_IN_CONF = 	(CN_MASK | 0x11);
const UINT_PTR CN_RC_AUDIO_IN_USE_REMOTE_AFTER_DATA =	(CN_MASK | 0x12);
const UINT_PTR CN_RC_AUDIO_IN_USE_REMOTE =				(CN_MASK | 0x13);
const UINT_PTR CN_RC_AUDIO_IN_USE_LOCAL_AFTER_DATA =	(CN_MASK | 0x14);
const UINT_PTR CN_RC_AUDIO_IN_USE_LOCAL =				(CN_MASK | 0x15);
const UINT_PTR CN_RC_ALREADY_IN_CONFERENCE_MCU =		(CN_MASK | 0x16);
const UINT_PTR CN_RC_AUDIO_NOT_AVAILABLE =				(CN_MASK | 0x17);
const UINT_PTR CN_RC_REMOTE_PLACING_CALL =				(CN_MASK | 0x18);
const UINT_PTR CN_RC_INCOMPATIBLE_REMOTE_VERSION =		(CN_MASK | 0x1a);
const UINT_PTR CN_RC_NO_TRANSPORTS =					(CN_MASK | 0x1b);
const UINT_PTR CN_RC_CANT_JOIN_ALREADY_IN_CALL =		(CN_MASK | 0x1e);
const UINT_PTR CN_RC_TRANSPORT_FAILURE =				(CN_MASK | 0x1f);
const UINT_PTR CN_RC_LOOPBACK = 						(CN_MASK | 0x20);
const UINT_PTR CN_RC_CONFERENCE_ENDED_BEFORE_ACCEPTED = (CN_MASK | 0x22);
const UINT_PTR CN_RC_GK_CALLEE_NOT_REGISTERED =			(CN_MASK | 0x23);
const UINT_PTR CN_RC_GK_TIMEOUT =						(CN_MASK | 0x24);
const UINT_PTR CN_RC_GK_REJECTED =						(CN_MASK | 0x25);
const UINT_PTR CN_RC_GK_NOT_REGISTERED =				(CN_MASK | 0x26);
const UINT_PTR CN_RC_CONNECT_REMOTE_NO_SECURITY =		(CN_MASK | 0x27);
const UINT_PTR CN_RC_CONNECT_REMOTE_DOWNLEVEL_SECURITY =	(CN_MASK | 0x28);
const UINT_PTR CN_RC_CONNECT_REMOTE_REQUIRE_SECURITY =	(CN_MASK | 0x29);
const UINT_PTR CN_RC_QUERY_FAILED =						(CN_MASK | 0x2a);
const UINT_PTR CN_RC_INVITE_FAILED =					(CN_MASK | 0x2a);
const UINT_PTR CN_RC_JOIN_FAILED =						(CN_MASK | 0x2b);
const UINT_PTR CN_RC_LOCAL_CANCELED =					(CN_MASK | 0x2c);
const UINT_PTR CN_RC_SECURITY_FAILED =					(CN_MASK | 0x2d);
const UINT_PTR CN_RC_CONNECT_AUTHENTICATION_FAILED =    (CN_MASK | 0x2e);

typedef UINT_PTR CNSTATUS;

#endif // _CNCODES_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\core\cuserdta.hpp ===
// cuserdta.hpp
// Data structure for managing user data.

#ifndef	USERDATA_INC
#define	USERDATA_INC

#include <nmutil.h>
#include <oblist.h>
#include <confdbg.h>
#include <confguid.h>

extern "C"
{
#include <t120.h>
}

// GetUserData extracts user data from a T120 event message.
// The caller passes in the T120 data structures and the GUID
// associated with the user data, and receives back a pointer to
// the buffer containing the user data. 
// This buffer will be invalidated by the user returning from
// the event. If the user data consisted just
// of the GUID, then *pnData == NULL and *ppData == NULL.

HRESULT NMINTERNAL GetUserData(unsigned short     nRecords,
                               GCCUserData **     ppUserData,
                               GUID *             pGUID,
                               unsigned short *   pnData, 
                               PVOID *            ppData);

/*************************************************************************

    NAME:		USER_DATA

    INTERFACE:	USER_DATA(object ID)
					Construct the container for the list.

				~USER_DATA_GUID()
					Destructor automatically releases data allocated.

				AddUserData()
					Add some user data to the list, keyed by a unique
                    GUID. If the GUID is already in the list, then its
                    data will be overwritten.

				GetUserData()
					Used in conjunction with GetNumUserData() to put the
                    user data into a T120 request.

                GetNumUserData()
					See GetUserData().

    PARENT:		None

    USES:		None

    CAVEATS:	1) The user data binary information must fit in an unsigned
                short field, less the bytes for the GUID header and byte count.

    NOTES:		None.

    HISTORY:
		06/04/96	lens	Created

**************************************************************************/

class USER_DATA_LIST : COBLIST
{
public:
	USER_DATA_LIST();
	~USER_DATA_LIST();
    DWORD AddUserData(GUID * pGUID, unsigned short nData, PVOID pData);
    DWORD GetUserDataList(unsigned short * pnRecords,
                          GCCUserData *** pppUserData);
    HRESULT GetUserData(REFGUID rguid, BYTE ** ppb, ULONG *pcb);
    inline unsigned short GetNumUserData(){return (numEntries);}

    void DeleteEntry(GUID * pGUID);

private:
    void * RemoveAt(POSITION Position);
    BOOL Compare(void* pItemToCompare, void* pComparator);
    unsigned short  numEntries;
    GCCUserData **  pUserDataArray;
};

#endif /* ndef USERDATA_INC */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\core\connpnts.cpp ===
// File: connpnts.cpp
//
// CConnectionPoint
// CConnectionPointContainer
// CEnumConnections
///////////////////////////////////////////////////////////////////////////

#include "precomp.h"
#include "connpnts.h"

#include <olectl.h>


/*  C  C O N N E C T I O N  P O I N T  */
/*-------------------------------------------------------------------------
    %%Function: CConnectionPoint

-------------------------------------------------------------------------*/
CConnectionPoint::CConnectionPoint(const IID *pIID, IConnectionPointContainer *pCPCInit) :
	m_riid(*pIID),
	m_pCPC(pCPCInit),
	m_cSinks(0),
    m_cAllocatedSinks(0),
    m_rgSinks(NULL)
{
	DbgMsgApi("CConnectionPoint - Constructed(%08X)", this);
}

CConnectionPoint::~CConnectionPoint (void)
{
    for (ULONG x = 0; x < m_cAllocatedSinks; x += 1)
    {
        if (m_rgSinks[x] != NULL)
        {
		    IUnknown *pUnk = (IUnknown *)m_rgSinks[x];
			pUnk->Release();
        }
    }

    if (m_cAllocatedSinks != 0)
    {
        HeapFree(GetProcessHeap(), 0, m_rgSinks);
    }

	DbgMsgApi("CConnectionPoint - Destructed(%p)", this);
}

STDMETHODIMP_(ULONG) CConnectionPoint::AddRef(void)
{
	return RefCount::AddRef();
}
	
STDMETHODIMP_(ULONG) CConnectionPoint::Release(void)
{
	return RefCount::Release();
}

STDMETHODIMP CConnectionPoint::QueryInterface(REFIID riid, void **ppv)
{
	HRESULT hr = S_OK;

	if ((riid == IID_IUnknown) || (riid == IID_IConnectionPoint))
	{
		*ppv = (IConnectionPoint *)this;
		DbgMsgApi("CConnectionPoint::QueryInterface(): Returning IConnectionPoint.");
	}
	else
	{
		hr = E_NOINTERFACE;
		*ppv = NULL;
		DbgMsgApi("CConnectionPoint::QueryInterface(): Called on unknown interface.");
	}

	if (S_OK == hr)
	{
		AddRef();
	}

	return hr;
}


/*  N O T I F Y  */
/*-------------------------------------------------------------------------
    %%Function: Notify

-------------------------------------------------------------------------*/
STDMETHODIMP CConnectionPoint::Notify(void *pv, CONN_NOTIFYPROC pfn)
{
    //
	// Enumerate each connection
	//

	AddRef();
    for (ULONG x = 0; x < m_cAllocatedSinks; x += 1)
    {
		if (m_rgSinks[x] != NULL)
		{
		    IUnknown *pUnk = (IUnknown *)m_rgSinks[x];
			pUnk->AddRef();
			(*pfn)(pUnk, pv, m_riid);
			pUnk->Release();
		}
    }

	Release();
	return S_OK;
}

/*  G E T  C O N N E C T I O N  I N T E R F A C E  */
/*-------------------------------------------------------------------------
    %%Function: GetConnectionInterface

-------------------------------------------------------------------------*/
STDMETHODIMP CConnectionPoint::GetConnectionInterface(IID *pIID)
{
	// Validate the parameter
	//
	if (pIID == NULL)
		return E_POINTER;

	// Support only one connection interface
	//
	*pIID = m_riid;
	return S_OK;
}

STDMETHODIMP CConnectionPoint::GetConnectionPointContainer(IConnectionPointContainer **ppCPC)
{
	// Validate the parameter
	//
	if (ppCPC == NULL)
		return E_POINTER;

	// Return the container and add its reference count
	//
	*ppCPC = m_pCPC;

	if (m_pCPC != NULL)
	{
		// The container is still alive
		//
		m_pCPC->AddRef();
		return S_OK;
	}
	else
	{
		// The container no longer exists
		//
		return E_FAIL;
	}
}

/*  A D V I S E  */
/*-------------------------------------------------------------------------
    %%Function: Advise

-------------------------------------------------------------------------*/
STDMETHODIMP CConnectionPoint::Advise(IUnknown *pUnk, DWORD *pdwCookie)
{
	IUnknown *pSinkInterface;

	// Validate the parameter
	//
	if (pdwCookie == NULL)
		return E_POINTER;

	*pdwCookie = 0;
	if (pUnk == NULL)
		return E_INVALIDARG;

	HRESULT hr = CONNECT_E_CANNOTCONNECT;

    //
	// Get the sink interface
	//

	if (SUCCEEDED(pUnk->QueryInterface(m_riid, (void **)&pSinkInterface)))
	{

        //
        // If the number of active sinks is less than the number of allocated
        // sinks, then there is a free slot in the sink table. Otherwise, the
        // table must be expanded.
        //

        ULONG x = m_cAllocatedSinks;
        if (m_cSinks < m_cAllocatedSinks)
        {
            for (x = 0; x < m_cAllocatedSinks; x += 1)
            {
                if (m_rgSinks[x] == NULL)
                {
                    break;
                }
            }
        }

        //
        // If a free slot was found in the table, then use the slot. Otherwise,
        // expand the sink table.
        //

        if (x == m_cAllocatedSinks)
        {
            IUnknown **rgSinks = (IUnknown **)HeapAlloc(GetProcessHeap(),
                                                        HEAP_ZERO_MEMORY,
                                                        (m_cAllocatedSinks + 8) * sizeof(IUnknown *));

            if (rgSinks == NULL)
            {
			    pSinkInterface->Release();
                return E_OUTOFMEMORY;
            }

            for (ULONG z = 0; z < m_cAllocatedSinks; z += 1)
            {
                rgSinks[z] = m_rgSinks[z];
            }

            m_cAllocatedSinks += 8;
            if (m_rgSinks != NULL) {
                HeapFree(GetProcessHeap(), 0, m_rgSinks);
            }

            m_rgSinks = rgSinks;
        }

        //
		// Add new sink to the table.
		//

        m_rgSinks[x] = pSinkInterface;
		m_cSinks += 1;
		*pdwCookie = x + 1;
		hr = S_OK;
	}

	return hr;
}

/*  U N A D V I S E  */
/*-------------------------------------------------------------------------
    %%Function: Unadvise

-------------------------------------------------------------------------*/
STDMETHODIMP CConnectionPoint::Unadvise(DWORD dwCookie)
{
	HRESULT hr = CONNECT_E_NOCONNECTION;

    //
	// Traverse the sink list to find the specified sink object
	//

    if ((dwCookie != 0) &&
        (dwCookie <= m_cAllocatedSinks) &&
        (m_rgSinks[dwCookie - 1] != NULL))
    {
		IUnknown *pUnk = (IUnknown *) m_rgSinks[dwCookie - 1];
	    pUnk->Release();
        m_rgSinks[dwCookie - 1] = NULL;
        m_cSinks -= 1;
		hr = S_OK;
    }

	return hr;
}

STDMETHODIMP CConnectionPoint::EnumConnections(IEnumConnections **ppEnum)
{
	HRESULT hr = E_POINTER;

	// Validate parameters
	//
	if (ppEnum == NULL)
	{
		// Create an enumerator
		//
		*ppEnum = new CEnumConnections(m_rgSinks, m_cSinks, m_cAllocatedSinks);
		hr = (NULL != *ppEnum) ? S_OK : E_OUTOFMEMORY;
	}

	return hr;
}


///////////////////////////////////////////////////////////////////////////

/*  C  E N U M  C O N N E C T I O N S  */
/*-------------------------------------------------------------------------
    %%Function: CEnumConnections

-------------------------------------------------------------------------*/
CEnumConnections::CEnumConnections(IUnknown **pSinks, ULONG cSinks, ULONG cAllocatedSinks) :
	m_iIndex(0),
	m_cConnections(0),
	m_pCD(NULL)
{
	// Snapshot the connection list
	//
	if (cSinks > 0)
	{
		m_pCD = new CONNECTDATA[cSinks];
		if (NULL != m_pCD)
		{
            for (ULONG x = 0; x < cAllocatedSinks; x += 1)
            {
                if (pSinks[x] != NULL) {
				    IUnknown *pUnk = (IUnknown *) pSinks[x];
                    pUnk->AddRef();
					m_pCD[m_cConnections++].pUnk = pUnk;
					m_pCD[m_cConnections++].dwCookie = x + 1;
                }
            }
		}
	}

	DbgMsgApi("CEnumConnections - Constructed(%p)", this);
}

CEnumConnections::~CEnumConnections(void)
{
	if (m_pCD != NULL)
	{
		for (int i = 0; i < m_cConnections; i++)
		{
			m_pCD[i].pUnk->Release();
		};
		delete [] m_pCD;
	};

	DbgMsgApi("CEnumConnections - Destructed(%08X)", this);
}

STDMETHODIMP_(ULONG) CEnumConnections::AddRef(void)
{
	return RefCount::AddRef();
}
	
STDMETHODIMP_(ULONG) CEnumConnections::Release(void)
{
	return RefCount::Release();
}

STDMETHODIMP CEnumConnections::QueryInterface(REFIID riid, void **ppv)
{
	HRESULT hr = S_OK;

	if ((riid == IID_IEnumConnections) || (riid == IID_IUnknown))
	{
		*ppv = (IEnumConnections *)this;
		DbgMsgApi("CEnumConnections::QueryInterface(): Returning IEnumConnections.");
	}
	else
	{
		hr = E_NOINTERFACE;
		*ppv = NULL;
		DbgMsgApi("CEnumConnections::QueryInterface(): Called on unknown interface.");
	}

	if (S_OK == hr)
	{
		AddRef();
	}

	return hr;
}

STDMETHODIMP CEnumConnections::Next(ULONG cConnections, CONNECTDATA *rgpcd, ULONG *pcFetched)
{
	ULONG cCopied = 0;

	if ((0 == cConnections) && (NULL == rgpcd) && (NULL != pcFetched))
	{
		// Return the number of remaining elements
		*pcFetched = m_cConnections - m_iIndex;
		return S_OK;
	}
	
	if ((NULL == rgpcd) || ((NULL == pcFetched) && (cConnections != 1)))
		return E_POINTER;

	if (NULL != m_pCD)
	{
		while ((cCopied < cConnections) && (m_iIndex < m_cConnections))
		{
			*rgpcd = m_pCD[m_iIndex];
			(*rgpcd).pUnk->AddRef();
			rgpcd++;
			cCopied++;
			m_iIndex++;
		}
	}

	if (pcFetched != NULL)
		*pcFetched = cCopied;

	return (cConnections == cCopied) ? S_OK : S_FALSE;
}

STDMETHODIMP CEnumConnections::Skip(ULONG cConnections)
{
    m_iIndex += cConnections;
	if (m_iIndex >= m_cConnections)
	{
		// Past the end of the list
		m_iIndex = m_cConnections;
		return S_FALSE;
	}

	return S_OK;
}


STDMETHODIMP CEnumConnections::Reset(void)
{
	m_iIndex = 0;
	return S_OK;
}

STDMETHODIMP CEnumConnections::Clone(IEnumConnections **ppEnum)
{
	// Validate parameters
	//
	if (ppEnum != NULL)
		return E_POINTER;

	HRESULT hr = S_OK;
	CEnumConnections * pEnum = new CEnumConnections(NULL, 0, 0);
	if (NULL == pEnum)
	{
		hr = E_OUTOFMEMORY;
	}
	else if (NULL != m_pCD)
	{
		pEnum->m_pCD = new CONNECTDATA[m_cConnections];
		if (NULL == pEnum->m_pCD)
		{
			delete pEnum;
			pEnum = NULL;
    		hr = E_OUTOFMEMORY;
		}
		else
		{
			pEnum->m_iIndex = m_iIndex;
			pEnum->m_cConnections = m_cConnections;

            for (int i = 0; i < m_cConnections; ++i)
            {
        		m_pCD[i].pUnk->AddRef();
                pEnum->m_pCD[i] = m_pCD[i];
            }
		}
	}

	*ppEnum = pEnum;
	return hr;
}


///////////////////////////////////////////////////////////////////////////

/*  C  C O N N E C T I O N  P O I N T  C O N T A I N E R  */
/*-------------------------------------------------------------------------
    %%Function: CConnectionPointContainer

-------------------------------------------------------------------------*/
CConnectionPointContainer::CConnectionPointContainer(const IID **ppiid, int cCp) :
	m_ppCp(NULL),
	m_cCp(0)
{
	m_ppCp = new CConnectionPoint* [cCp];
	if (NULL != m_ppCp)
	{
		for (int i = 0; i < cCp; ++i)
		{
			CConnectionPoint *pCp = new CConnectionPoint(ppiid[i], this);
			if (NULL != pCp)
			{
				m_ppCp[m_cCp++] = pCp;
			}
		}
	}
}

CConnectionPointContainer::~CConnectionPointContainer()
{
	if (NULL != m_ppCp)
	{
		for (int i = 0; i < m_cCp; ++i)
		{
			CConnectionPoint *pCp = m_ppCp[i];
			if (NULL != pCp)
			{
				pCp->ContainerReleased();
				pCp->Release();
			}
		}
		delete[] m_ppCp;
	}
}


HRESULT STDMETHODCALLTYPE
CConnectionPointContainer::NotifySink(void *pv, CONN_NOTIFYPROC pfn)
{
	if (NULL != m_ppCp)
	{
		for (int i = 0; i < m_cCp; ++i)
		{
			m_ppCp[i]->Notify(pv, pfn);
		}
	}

	return S_OK;
}

STDMETHODIMP
CConnectionPointContainer::EnumConnectionPoints(IEnumConnectionPoints **ppEnum)
{
	if (ppEnum == NULL)
		return E_POINTER;

	// Create an enumerator
	*ppEnum = new CEnumConnectionPoints(m_ppCp, m_cCp);

	return (NULL != *ppEnum) ? S_OK : E_OUTOFMEMORY;
}

STDMETHODIMP
CConnectionPointContainer::FindConnectionPoint(REFIID riid, IConnectionPoint **ppCp)
{
	HRESULT hr = E_POINTER;
	if (NULL != ppCp)
	{
		hr = CONNECT_E_NOCONNECTION;
		*ppCp = NULL;

		if (NULL != m_ppCp)
		{
			for (int i = 0; i < m_cCp; ++i)
			{
				IID iid;
				IConnectionPoint *pCp = m_ppCp[i];
				if (S_OK == pCp->GetConnectionInterface(&iid))
				{
					if (riid == iid)
					{
						pCp->AddRef();
						*ppCp = pCp;
						hr = S_OK;
						break;
					}
				}
			}
		}
	}

	return hr;
}



=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\core\global.h ===
// File: global.h

extern HINSTANCE g_hInst;
inline HINSTANCE GetInstanceHandle()	{ return g_hInst; }

extern BOOL g_fLoggedOn;
inline BOOL FIsLoggedOn() { return g_fLoggedOn; }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\core\debug.h ===
// File: debug.h

// Debug Zones (depends on order of strings in debug.cpp)

#ifndef _DEBUG_H_
#define _DEBUG_H_

#define ZONE_API        0x0001  // General API output
#define ZONE_REFCOUNT   0x0002  // Object reference counts
#define ZONE_MANAGER    0x0004  // INmManager
#define ZONE_CALL       0x0008  // INmCall
#define ZONE_CONFERENCE 0x0010  // INmConference
#define ZONE_MEMBER     0x0020  // INmMember
#define ZONE_AV         0x0040  // INmAudio/Video
#define ZONE_FT         0x0080  // INmFileTransfer
#define ZONE_SYSINFO    0x0100  // INmSysInfo
#define ZONE_OBJECTS    0x0200  // General object create/destruction
#define ZONE_DC         0x0400  // Data Channel

#define iZONE_API        0
#define iZONE_REFCOUNT   1
#define iZONE_MANAGER    2
#define iZONE_CALL       3
#define iZONE_CONFERENCE 4
#define iZONE_MEMBER     5
#define iZONE_AV         6
#define iZONE_FT         7
#define iZONE_SYSINFO    8
#define iZONE_OBJECTS    9
#define iZONE_DC        10


#ifdef DEBUG
VOID DbgInitZones(void);
VOID DbgFreeZones(void);

VOID DbgMsgApi(PSTR pszFormat,...);
VOID DbgMsgRefCount(PSTR pszFormat,...);
VOID DbgMsgManager(PSTR pszFormat,...);
VOID DbgMsgCall(PSTR pszFormat,...);
VOID DbgMsgMember(PSTR pszFormat,...);
VOID DbgMsgAV(PSTR pszFormat,...);
VOID DbgMsgFT(PSTR pszFormat,...);
VOID DbgMsgSysInfo(PSTR pszFormat,...);
VOID DbgMsgDc(PSTR pszFormat,...);

VOID DbgMsg(int iZone, PSTR pszFormat,...);

#else // no debug messages

inline void WINAPI DbgMsgNop(LPCTSTR, ...) { }

#define DbgMsgApi      1 ? (void)0 : ::DbgMsgNop
#define DbgMsgRefCount 1 ? (void)0 : ::DbgMsgNop
#define DbgMsgManager  1 ? (void)0 : ::DbgMsgNop
#define DbgMsgCall     1 ? (void)0 : ::DbgMsgNop
#define DbgMsgMember   1 ? (void)0 : ::DbgMsgNop
#define DbgMsgAV       1 ? (void)0 : ::DbgMsgNop
#define DbgMsgFT       1 ? (void)0 : ::DbgMsgNop
#define DbgMsgSysInfo  1 ? (void)0 : ::DbgMsgNop
#define DbgMsgDc       1 ? (void)0 : ::DbgMsgNop

inline void WINAPI DbgMsgZoneNop(UINT, LPCTSTR, ...) { }
#define DbgMsg  1 ? (void) 0 : ::DbgMsgZoneNop

#define DbgInitZones()
#define DbgFreeZones()

#endif

#define ApiDebugMsg(s)    DbgMsgApi s

#endif // _DEBUG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\core\h323.h ===
#ifndef _H323_H_
#define _H323_H_

#include <winerror.h>
#include <appavcap.h>
#include <ih323cc.h>
#include "video.h"
#include "audio.h"
#include <nacguids.h>
#include "capflags.h"

const DWORD H323UDF_ALREADY_IN_T120_CALL =	0x01000001;

const DWORD H323UDF_INVITE =				0x00000001;
const DWORD H323UDF_JOIN =					0x00000002;
const DWORD H323UDF_SECURE =				0x00000004;
const DWORD H323UDF_AUDIO =					0x00000008;
const DWORD H323UDF_VIDEO =					0x00000010;

class CH323ConnEvent
{
public:
	virtual CREQ_RESPONSETYPE OnH323IncomingCall(IH323Endpoint* pConnection, P_APP_CALL_SETUP_DATA lpvMNMData) = 0;
};

class CH323UI 
{
public:
					CH323UI();
					~CH323UI();

	// IH323ConfAdvise Methods:
	STDMETHODIMP QueryInterface(REFIID riid, LPVOID FAR * ppvObj);
	STDMETHOD_(ULONG, AddRef());
	STDMETHOD_(ULONG, Release());
    STDMETHODIMP GetMediaChannel (GUID *pmediaID, 
        BOOL bSendDirection, IMediaChannel **ppI);	

	// Other Methods:
	HRESULT		Init(HWND hWnd, HINSTANCE m_hInstance, UINT caps,
        CH323ConnEvent *pConnEvent, IH323ConfAdvise *pConfAdvise);
	IH323CallControl*		GetH323CallControl() { return m_pH323CallControl; };
	IMediaChannelBuilder*		GetStreamProvider();

	VOID		SetBandwidth(DWORD uBandwidth);
	VOID		SetUserName(BSTR bstrName);
	VOID		SetCaptureDevice(DWORD dwCaptureID);

protected:
	// Members:
	UINT                    m_uRef;
    UINT                    m_uCaps;
	IH323CallControl*       m_pH323CallControl;
	IMediaChannelBuilder*   m_pStreamProvider;

	static CH323UI*		m_spH323UI;

	CH323ConnEvent*		m_pConnEvent;
    IH323ConfAdvise*    m_pConfAdvise;
	
protected:
	// Callbacks:
	static CREQ_RESPONSETYPE CALLBACK ConnectionNotify(	IH323Endpoint* pConn,
														P_APP_CALL_SETUP_DATA lpvMNMData);
	CREQ_RESPONSETYPE CALLBACK _ConnectionNotify(	IH323Endpoint* pConn,
													P_APP_CALL_SETUP_DATA lpvMNMData);
};

// The global instance that is declared in conf.cpp:
extern CH323UI* g_pH323UI;

#endif // _H323_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\core\icall_in.h ===
#ifndef _ICALL_IN_H_
#define _ICALL_IN_H_

#include "rostinfo.h"

// BUGBUG:
// This is defined as 128 because the RNC_ROSTER structure has the
// same limitation.  Investigate what the appropriate number is.
const int MAX_CALLER_NAME = 128;

class COprahNCUI;

class CIncomingCall : public INmCall, public DllRefCount, public CConnectionPointContainer
{
private:
	COprahNCUI	  * m_pOprahNCUI;
	IH323Endpoint*	m_pConnection;
	BOOL			m_fInvite;
	CONF_HANDLE 	m_hConf;
	BSTR			m_bstrCaller;
	NM_CALL_STATE	m_State;
	UINT			m_dwFlags;
	USER_DATA_LIST	m_UserData;
	GUID			m_guidNode;
	BOOL			m_fMemberAdded;

	VOID			ProcessT120UserData(
						PUSERDATAINFO pUserDataInfoEntries,
						UINT cUserDataEntries);

public:
	CIncomingCall(  COprahNCUI *pOprahNCUI, 
    	                IH323Endpoint* pConnection, 
    	                P_APP_CALL_SETUP_DATA lpvMNMData,
						DWORD dwFlags);

	CIncomingCall(	COprahNCUI *pOprahNCUI,
						BOOL fInvite,
						CONF_HANDLE hConf,
						PCWSTR pcwszNodeName,
						PUSERDATAINFO pUserDataInfoEntries,
						UINT cUserDataEntries);

	~CIncomingCall();

	// this method will need to be changed to support proposed the cookie for NM3.0 callers
	// it will still need to handle 2.X callers
	BOOL			MatchAcceptedCaller(PCWSTR pcwszNodeName);
	BOOL			MatchAcceptedCaller(GUID* pguidNodeId);
	BOOL			MatchActiveCaller(GUID* pguidNodeId);

	IH323Endpoint *	GetH323Connection()	{ return m_pConnection; }
	HRESULT			OnH323Connected();
	HRESULT			OnH323Disconnected();
	UINT			GetFlags() { return m_dwFlags; }
	BOOL			IsDataOnly() { return (0 == ((CRPCF_AUDIO | CRPCF_VIDEO) & m_dwFlags));	}
	BOOL			DidUserAccept() { return (NM_CALL_ACCEPTED == m_State); }

	VOID			SetConfHandle(CONF_HANDLE hConf) { m_hConf = hConf; }
	CONF_HANDLE		GetConfHandle() { return m_hConf; }
	VOID			OnIncomingT120Call(
						BOOL fInvite,
						PUSERDATAINFO pUserDataInfoEntries,
						UINT cUserDataEntries);
	HRESULT			OnT120ConferenceEnded();
	HRESULT			Terminate(BOOL fReject);
	GUID *			GetNodeGuid() { return &m_guidNode; }

	void Ring();

	STDMETHODIMP_(ULONG) AddRef(void);
	STDMETHODIMP_(ULONG) Release(void);
	STDMETHODIMP QueryInterface(REFIID riid, PVOID *ppvObj);

	STDMETHODIMP IsIncoming(void);
	STDMETHODIMP GetState(NM_CALL_STATE *pState);
	STDMETHODIMP GetName(BSTR *pbstrName);
	STDMETHODIMP GetAddr(BSTR *pbstrAddr, NM_ADDR_TYPE *puType);
	STDMETHODIMP GetUserData(REFGUID rguid, BYTE **ppb, ULONG *pcb);
	STDMETHODIMP GetConference(INmConference **ppConference);
	STDMETHODIMP Accept(void);
	STDMETHODIMP Reject(void);
	STDMETHODIMP Cancel(void);
};

class CIncomingCallManager
{
private:
	COBLIST m_CallList;

public:
	CIncomingCallManager();
	~CIncomingCallManager();

	CREQ_RESPONSETYPE OnIncomingH323Call(
			COprahNCUI *pManager,
			IH323Endpoint* pConnection,
			P_APP_CALL_SETUP_DATA lpvMNMData);

	VOID OnH323Connected(IH323Endpoint * lpConnection);

	VOID OnH323Disconnected(IH323Endpoint * lpConnection);

	HRESULT OnIncomingT120Call(
			COprahNCUI *pManager,
			BOOL fInvite,
			CONF_HANDLE hConf,
			PCWSTR pcwszNodeName,
			PUSERDATAINFO pUserDataInfoEntries,
			UINT cUserDataEntries,
			BOOL fSecure);

	VOID	OnT120ConferenceEnded(CONF_HANDLE hConference);

	CIncomingCall* MatchAcceptedCaller(PCWSTR pcwszNodeName);
	CIncomingCall* MatchAcceptedCaller(GUID* pguidNodeId);
	CIncomingCall* MatchActiveCaller(GUID* pguidNodeId);

	GUID* GetGuidFromT120UserData(
				PUSERDATAINFO	pUserDataInfoEntries,
				UINT			cUserDataEntries);

	VOID CancelCalls();
};

#endif // _ICALL_IN_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\core\icall.h ===
/***************************************************************************/
/** 				 Microsoft Windows									  **/
/** 		   Copyright(c) Microsoft Corp., 1995-1996					  **/
/***************************************************************************/

//
//	The COutgoingCall class is defined, which is used while placing calls
//

#ifndef _ICALL_H_
#define _ICALL_H_

#include <nameres.h>		// need for RN_
#include "cncodes.h"		// needed for CNSTATUS and CN_

class CConfObject;

class COutgoingCall : public INmCall, public DllRefCount, 
    public CConnectionPointContainer
{
private:
	enum CNODESTATE
	{
		CNS_IDLE,

		CNS_SEARCHING,		// dummy state to keep compatible with NM2.X

		CNS_CONNECTING_H323,

		CNS_WAITING_T120_OPEN,

		CNS_QUERYING_REMOTE,

		CNS_CREATING_LOCAL,
		CNS_INVITING_REMOTE,
		CNS_TERMINATING_AFTER_INVITE,
		CNS_QUERYING_REMOTE_AFTER_INVITE,

		CNS_JOINING_REMOTE,

		CNS_COMPLETE
	};

	// Attributes:
	CNODESTATE      m_cnState;
	CConfObject*	m_pConfObject;
	REQUEST_HANDLE	m_hRequest;
	IH323Endpoint *	m_pH323Connection;
	BOOL            m_fCanceled;
	
	// User Info
	BSTR            m_bstrName;
	LPTSTR          m_pszAddr;
	BSTR            m_bstrAlias;
	BSTR            m_bstrConfToJoin;
	BSTR            m_bstrPassword;
	BSTR            m_bstrUserString;
	NM_ADDR_TYPE    m_addrType;
	DWORD           m_dwFlags;


	// Info that we obtain during processing
	CNSTATUS        m_cnResult;
	BOOL            m_fService;

	// Protected Methods:
	BOOL			ReportError(CNSTATUS cns);
	CNSTATUS		MapAudioSummaryToCNStatus(DWORD dwSummary);
	CNSTATUS 		StartT120Call();
	CNSTATUS		ConnectH323();
	VOID			SetCallState(CNODESTATE cnState);

	BOOL			IsDataOnly() { return (0 == ((CRPCF_AUDIO | CRPCF_VIDEO) & m_dwFlags));	}

	HRESULT			Connect(
						PSOCKADDR_IN psin,
						P_H323ALIASLIST pAliasList,
						LPCWSTR pcwszPSTNAddress,
						P_APP_CALL_SETUP_DATA lpvMNMData, 
						GUID PIDofProtocolType,
						IH323Endpoint * *ppConnection);

public:

	COutgoingCall(CConfObject* pco, DWORD dwFlags, NM_ADDR_TYPE addrType, BSTR bstrName,
		BSTR bstrDest, BSTR bstrAlias, BSTR bstrConference, BSTR bstrPassword, BSTR bstrUserString);

	~COutgoingCall();

						
	// Methods:
	VOID			PlaceCall(void);
	VOID			CallComplete(void);
	HRESULT 		_Cancel(BOOL fLeaving);

	// Properties:
	DWORD			GetFlags()					{ return m_dwFlags; }
	REQUEST_HANDLE	GetCurrentRequestHandle()	{ return m_hRequest; }
	IH323Endpoint *	GetH323Connection()			{ return m_pH323Connection; }
	BOOL			FCanceled() 				{ return m_fCanceled; }
	BOOL			FIsComplete()				{ return (CNS_COMPLETE == m_cnState); }

	BOOL			MatchActiveCallee(LPCTSTR pszDest, BSTR bstrAlias, BSTR bstrConference);


	
	// Event Handlers:
	
	// Received by only this COutgoingCall object
	BOOL			OnQueryRemoteResult(HRESULT ncsResult,
										BOOL fMCU,
										PWSTR pwszConfNames[],
										PT120PRODUCTVERSION pVersion,
										PWSTR pwszConfDescriptors[]);
	BOOL			OnInviteResult(HRESULT ncsResult, UINT uNodeID);
	
	// Received by all COutgoingCall objects sharing the same conference
	BOOL			OnConferenceEnded();
	
	// Received by all COutgoingCall objects
	BOOL			OnConferenceStarted(CONF_HANDLE hNewConf, 
										HRESULT ncsResult);
	BOOL			OnH323Connected(IH323Endpoint * pConnection);
	BOOL			OnH323Disconnected(IH323Endpoint * pConnection);
	BOOL            OnT120ChannelOpen(ICommChannel *pIChannel, DWORD dwStatus);

	STDMETHODIMP_(ULONG)	AddRef(void);
	STDMETHODIMP_(ULONG)	Release(void);
	STDMETHODIMP			QueryInterface(REFIID riid, PVOID *ppvObj);

	STDMETHODIMP 		IsIncoming(void);
	STDMETHODIMP 		GetState(NM_CALL_STATE *pState);
	STDMETHODIMP 		GetName(BSTR *pbstr);
	STDMETHODIMP 		GetAddr(BSTR *pbstr, NM_ADDR_TYPE *puType);
	STDMETHODIMP 		GetUserData(REFGUID rguid, BYTE **ppb, ULONG *pcb);
	STDMETHODIMP 		GetConference(INmConference **ppConference);
	STDMETHODIMP 		Accept(void);
	STDMETHODIMP 		Reject(void);
	STDMETHODIMP 		Cancel(void);

};

class COprahNCUI;

class COutgoingCallManager
{
private:
	COBLIST	m_CallList;

	UINT			GetNodeCount();

	COutgoingCall*	FindCall(IH323Endpoint * lpConnection);
	BOOL MatchActiveCallee(LPCTSTR pszDest, BSTR bstrAlias, BSTR bstrConference);

public:

	COutgoingCallManager();

	~COutgoingCallManager();

	UINT	GetCallCount();

	BOOL	RemoveFromList(COutgoingCall* pCall);

	HRESULT Call(	INmCall **ppCall,
					COprahNCUI* pManager,
					DWORD dwFlags,
					NM_ADDR_TYPE addrType,
					BSTR bstrName,
					BSTR bstrSetup,
					BSTR bstrDest,
					BSTR bstrAlias,
					BSTR bstrURL,
					BSTR bstrConference,
					BSTR bstrPassword,
					BSTR bstrUserString);

	BOOL OnH323Connected(IH323Endpoint * lpConnection);

	BOOL OnH323Disconnected(IH323Endpoint * lpConnection);
	
	VOID OnT120ChannelOpen(	ICommChannel *pIChannel,
							IH323Endpoint * lpConnection,
							DWORD dwStatus);

	VOID OnConferenceStarted(CONF_HANDLE hConference, HRESULT hResult);

	VOID OnQueryRemoteResult(	PVOID pvCallerContext,
								HRESULT hResult,
								BOOL fMCU,
								PWSTR* ppwszConferenceNames,
								PT120PRODUCTVERSION pVersion,
								PWSTR* ppwszConfDescriptors);

	VOID OnInviteResult(	CONF_HANDLE hConference,
							REQUEST_HANDLE hRequest,
							UINT uNodeID,
							HRESULT hResult,
							PT120PRODUCTVERSION pVersion);

	VOID OnConferenceEnded(CONF_HANDLE hConference);

	VOID CancelCalls();
};

#endif // _ICALL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\core\h323.cpp ===
#include "precomp.h"

//
//	H323UI.cpp
//
//	ChrisPi
//
//	Created:	03-04-96 (as audioui.cpp)
//	Renamed:	02-20-97
//

#include <mmreg.h>
#include <mmsystem.h>

#include "h323.h"

#include <ih323cc.h>
#include <mperror.h>

PORT g_ListenPort;	// port # that this app is listening on

static const char g_cszCreateStreamProviderEP[] = _TEXT("CreateStreamProvider");

// static member initialization:
CH323UI* CH323UI::m_spH323UI = NULL;

CH323UI::CH323UI() :
	m_pH323CallControl(NULL),
	m_pStreamProvider(NULL),
	m_pConnEvent(NULL),
	m_pConfAdvise(NULL),
    m_uCaps(0),
	m_uRef(1)

{
	DebugEntry(CH323UI::CH323UI);

	if (NULL == CH323UI::m_spH323UI)
	{
		m_spH323UI = this;
	}
	else
	{
		ERROR_OUT(("CH323UI class can only be constructed once for now!"));
	}

	DebugExitVOID(CH323UI::CH323UI);
}

CH323UI::~CH323UI()
{
	DebugEntry(CH323UI::~CH323UI);

	if (NULL != m_pH323CallControl)
	{
		m_pH323CallControl->Release();
		m_pH323CallControl = NULL;
	}

	if(NULL != m_pStreamProvider)
	{
		m_pStreamProvider->Release();
		m_pStreamProvider = NULL;
	}

	if (m_spH323UI == this)
	{
		m_spH323UI = NULL;
	}

	DebugExitVOID(CH323UI::~CH323UI);
}

ULONG CH323UI::AddRef()
{
	m_uRef++;
	return m_uRef;
}

ULONG CH323UI::Release()
{
	m_uRef--;
	if(m_uRef == 0)
	{
		delete this;
		return 0;
	}
	return m_uRef;
}

STDMETHODIMP CH323UI::QueryInterface( REFIID iid,	void ** ppvObject)
{

	HRESULT hr = E_NOINTERFACE;
	if(!ppvObject)
		return hr;
		
	*ppvObject = 0;
	if((iid == IID_IH323ConfAdvise)
	|| (iid == IID_IUnknown))
	{
        *ppvObject = (IH323ConfAdvise *)this;
   		hr = hrSuccess;
    	AddRef();
	}
	
	return (hr);
}

STDMETHODIMP CH323UI::GetMediaChannel (GUID *pmediaID,
        BOOL bSendDirection, IMediaChannel **ppI)
{
	ASSERT(m_pStreamProvider);
	
	// delegate to the appropriate stream provider.  For the time being
	// there is only one provider that does both audio & video

	// the assignment of media streams to channels should be under control of this
	// (CH323UI) module and the related (i.e. CVideoPump) objects. There is no
	// current way to for CH323UI to tell CVideoPump what the media stream interface
	// pointer is, but the underlying CommChannel (CVideoPump::m_pCommChannel) has to
	// remember this assignment for other reasons.  For the time being, let CVideoPump
	// get the assigned media stream from the CommChannel.
	
	return (::GetConfObject())->GetMediaChannel(pmediaID, 	
		bSendDirection, ppI);	
}

HRESULT CH323UI::Init(HWND hwnd, HINSTANCE hInstance, UINT uCaps,
    CH323ConnEvent *pConnEvent,	IH323ConfAdvise *pConfAdvise)
{
	DebugEntry(CH323UI::Init);

	HINSTANCE hLibH323CC = NULL;
	HINSTANCE hLibStream = NULL;
	CREATEH323CC pfnCreateH323CC = NULL;
	CREATE_SP pfnCreateStreamProvider =NULL;
	
	HRESULT hr = E_FAIL;

    ASSERT(uCaps & CAPFLAG_H323_CC);
    m_uCaps = uCaps;

	ASSERT(NULL == m_pH323CallControl);

    //
    // Initialize H323 call control
    //
	hLibH323CC = NmLoadLibrary(H323DLL);
	if (hLibH323CC == NULL)
	{
		WARNING_OUT(("LoadLibrary(H323DLL) failed"));
		hr = GetLastHR();
		goto MyExit;
	}

	pfnCreateH323CC = (CREATEH323CC) ::GetProcAddress(hLibH323CC, SZ_FNCREATEH323CC);
	if (pfnCreateH323CC == NULL)
	{
		ERROR_OUT(("GetProcAddress(CreateH323CC) failed"));
		hr = GetLastHR();
		goto MyExit;
	}

	hr = pfnCreateH323CC(&m_pH323CallControl, TRUE, uCaps);
	if (FAILED(hr))
	{
		ERROR_OUT(("CreateH323CC failed, hr=0x%lx", hr));
		goto MyExit;
	}

	hr = m_pH323CallControl->Initialize(&g_ListenPort);
	if (FAILED(hr))
	{
		// Made this a warning because it is common (occurs on all machines
		// without sound cards)
		WARNING_OUT(("H323CallControlInitialize failed, hr=0x%lx", hr));
		goto MyExit;
	}

    //
    // If H323 AV streaming is allowed, initialize that too.
    //
    if (uCaps & CAPFLAGS_AV_STREAMS)
    {
    	hLibStream = NmLoadLibrary(NACDLL);
	    if (hLibStream == NULL)
    	{
	    	WARNING_OUT(("LoadLibrary(NACDLL) failed"));
		    hr = GetLastHR();
    		goto MyExit;
	    }

    	pfnCreateStreamProvider = (CREATE_SP) ::GetProcAddress(hLibStream, g_cszCreateStreamProviderEP);
	    if (pfnCreateStreamProvider == NULL)
    	{
	    	ERROR_OUT(("GetProcAddress(CreateStreamProvider) failed"));
		    hr = GetLastHR();
    		goto MyExit;
	    }
	
    	hr = pfnCreateStreamProvider(&m_pStreamProvider);
	    if (FAILED(hr))
    	{
	    	ERROR_OUT(("CreateStreamProvider failed, hr=0x%lx", hr));
		    goto MyExit;
    	}

    	hr = m_pStreamProvider->Initialize(hwnd, hInstance);
	    if (FAILED(hr))
    	{
	    	// Made this a warning because it is common (occurs on all machines
		    // without sound cards)
    		WARNING_OUT(("m_pStreamProvider ->Initialize failed, hr=0x%lx", hr));
	    	goto MyExit;
        }
   	}
	
	hr = m_pH323CallControl->RegisterConnectionNotify(CH323UI::ConnectionNotify);
	if (FAILED(hr))
	{
		ERROR_OUT(("RegisterConnectionNotify failed, hr=0x%lx", hr));
		goto MyExit;
	}

	// store the callback interfaces
	m_pConnEvent = pConnEvent;
	m_pConfAdvise = pConfAdvise;
	
MyExit:
	if (FAILED(hr))
	{
		if(NULL != m_pStreamProvider)
		{
			m_pStreamProvider->Release();
			m_pStreamProvider = NULL;
		}

		if(NULL != m_pH323CallControl)
		{
			// If there was an error during init, ensure that the nac
			// object is released and the pointer is set to NULL
			m_pH323CallControl->Release();
			m_pH323CallControl = NULL;
		}
	}
	
	DebugExitULONG(CH323UI::Init, hr);
	return hr;
}


CREQ_RESPONSETYPE CH323UI::_ConnectionNotify(	IH323Endpoint* pConn,
												P_APP_CALL_SETUP_DATA lpvMNMData)
{
	CREQ_RESPONSETYPE resp = CRR_REJECT;
	HRESULT hr;
	ASSERT(m_pConfAdvise);
	hr = pConn->SetAdviseInterface (m_pConfAdvise);
	if (FAILED(hr))
	{
		ERROR_OUT(("ConnectionNotify: couldn't SetAdviseInterface, hr=0x%lx\r", hr));
	}

	if (NULL != m_pConnEvent)
	{
		resp = m_pConnEvent->OnH323IncomingCall(pConn, lpvMNMData);
	}
	
	// BUGBUG: the caller is assuming that the callee will be doing the release
	// this should be changed so that the caller does the release
	pConn->Release();

	return resp;
}

CREQ_RESPONSETYPE CALLBACK CH323UI::ConnectionNotify(	IH323Endpoint* pConn,
														P_APP_CALL_SETUP_DATA lpvMNMData)
{
	DebugEntry(CH323UI::ConnectionNotify);
	
	CREQ_RESPONSETYPE resp = CRR_REJECT;

	if (pConn == NULL)
	{
		ERROR_OUT(("ConnectionNotify called with NULL pConn!"));
	}
	else
	{
		ASSERT(m_spH323UI);
		resp = m_spH323UI->_ConnectionNotify(pConn, lpvMNMData);
	}

	DebugExitINT(CH323UI::ConnectionNotify, resp);
	return resp;
}

VOID CH323UI::SetCaptureDevice(DWORD dwCaptureID)
{
	// Select the proper capture device
	HRESULT hr;
	IVideoDevice *pVideoDevice = NULL;

    if (m_pStreamProvider)
    {
    	hr = m_pStreamProvider->QueryInterface(IID_IVideoDevice, (void **)&pVideoDevice);
	    if(FAILED(hr))
    	{
            ERROR_OUT(("CH323UI::SetCaptureDevice failed"));
		    return;
        }

    	if(pVideoDevice)
	    {
		    pVideoDevice->SetCurrCapDevID(dwCaptureID);
    		pVideoDevice->Release();
	    }
    }
}
	
VOID CH323UI::SetBandwidth(DWORD dwBandwidth)
{
	HRESULT hr = m_pH323CallControl->SetMaxPPBandwidth(dwBandwidth);
	ASSERT(SUCCEEDED(hr));
}

// This (SetUserName) is not really sufficient for H.323 calls and gatekeeper
// registration.  2 items are needed (display name, H.323 ID)
// And a third is optional.  (users phone number in E.164 form).
// This hack takes the single display name and sets BOTH the H323ID and user
// display name.

VOID CH323UI::SetUserName(BSTR bstrName)
{
	HRESULT hr;
	ASSERT(bstrName);
	H323ALIASLIST AliasList;
	H323ALIASNAME AliasName;
	AliasName.aType = AT_H323_ID;
	AliasList.wCount = 1;
	AliasList.pItems = &AliasName;
	AliasName.lpwData = bstrName;
	AliasName.wDataLength = (WORD)SysStringLen(bstrName);// # of unicode chars, w/o NULL terminator

	hr = m_pH323CallControl->SetUserAliasNames(&AliasList);
	ASSERT(SUCCEEDED(hr));
	hr = m_pH323CallControl->SetUserDisplayName(AliasName.lpwData);
	ASSERT(SUCCEEDED(hr));
}

IMediaChannelBuilder* CH323UI::GetStreamProvider()
{
	if (m_pStreamProvider)
	{
		m_pStreamProvider->AddRef();
	}

	return m_pStreamProvider;
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\core\icall_in.cpp ===
// File: icallin.cpp

#include "precomp.h"

#include <regentry.h>

#include "cncodes.h"		// needed for CN_
#include "icall_in.h"
#include "imanager.h"
#include "util.h"

extern HRESULT OnNotifyCallError(IUnknown *pCallNotify, PVOID pv, REFIID riid);
static HRESULT OnNotifyCallAccepted(IUnknown *pCallNotify, PVOID pv, REFIID riid);

// Internal code to indicate that there was no security data available in an incoming call.
const int CALL_NO_SECURITY_DATA = -1;


static const IID * g_apiidCP_Call[] =
{
    {&IID_INmCallNotify},
	{&IID_INmCallNotify2}
};

CIncomingCall::CIncomingCall(
	COprahNCUI	  * pOprahNCUI,
	BOOL			fInvite,
	CONF_HANDLE		hConf,
	PCWSTR			pcwszNodeName,
	PUSERDATAINFO	pUserDataInfoEntries,
	UINT			cUserDataEntries) :
	CConnectionPointContainer(g_apiidCP_Call, ARRAY_ELEMENTS(g_apiidCP_Call)),
	m_pOprahNCUI(pOprahNCUI),
	m_pConnection(NULL),
	m_fInvite(fInvite),
	m_hConf(hConf),
	m_bstrCaller(SysAllocString(pcwszNodeName)),
	m_State(NM_CALL_INIT),
	m_dwFlags(0)
	{
	DebugEntry(CIncomingCall::CIncomingCall[T120]);

	ProcessT120UserData(pUserDataInfoEntries, cUserDataEntries);


	DebugExitVOID(CIncomingCall::CIncomingCall);
}

CIncomingCall::CIncomingCall(COprahNCUI *pOprahNCUI, 
	IH323Endpoint* pConnection, P_APP_CALL_SETUP_DATA lpvMNMData,
	DWORD dwFlags) :
	CConnectionPointContainer(g_apiidCP_Call, ARRAY_ELEMENTS(g_apiidCP_Call)),
	m_pOprahNCUI(pOprahNCUI),
	m_pConnection(pConnection),
	m_fInvite(FALSE),
	m_hConf(NULL),
	m_bstrCaller(NULL),
	m_State(NM_CALL_INIT),
	m_guidNode(GUID_NULL),
	m_dwFlags(dwFlags),
	m_fMemberAdded(FALSE)
{
	DebugEntry(CIncomingCall::CIncomingCall[H323]);
	HRESULT hr;
	ASSERT(m_pConnection);

	m_pConnection->AddRef();

	WCHAR wszCaller[MAX_CALLER_NAME];
	if (SUCCEEDED(m_pConnection->GetRemoteUserName(wszCaller, MAX_CALLER_NAME)))
	{
		m_bstrCaller = SysAllocString(wszCaller);
	}

	if ((NULL != lpvMNMData) && (lpvMNMData->dwDataSize > sizeof(DWORD)))
	{
		BYTE *pbData = ((BYTE*)lpvMNMData->lpData) + sizeof(DWORD);
		DWORD cbRemaining = lpvMNMData->dwDataSize - sizeof(DWORD);

		while ((sizeof(GUID) + sizeof(DWORD)) < cbRemaining)
		{
			DWORD cbData = *(DWORD*)(pbData + sizeof(GUID));
			DWORD cbRecord = cbData + sizeof(GUID) + sizeof(DWORD);

			if (cbRemaining < cbRecord)
			{
				break;
			}

			if (*(GUID *)pbData == g_csguidNodeIdTag)
			{
				m_guidNode = *(GUID *)(pbData + sizeof(GUID) + sizeof(DWORD));
			}

			m_UserData.AddUserData((GUID *)pbData,
					(unsigned short)cbData,
					pbData + sizeof(GUID) + sizeof(DWORD));
			cbRemaining -= cbRecord;
			pbData += cbRecord;
		}
	}

	DebugExitVOID(CIncomingCall::CIncomingCall);
}

CIncomingCall::~CIncomingCall()
{
	DebugEntry(CIncomingCall::~CIncomingCall);

	if(m_pConnection)
	{
		m_pConnection->Release();
		m_pConnection = NULL;
	}

	SysFreeString(m_bstrCaller);

	DebugExitVOID(CIncomingCall::CIncomingCall);
}

VOID CIncomingCall::ProcessT120UserData(
	PUSERDATAINFO	pUserDataInfoEntries,
	UINT			cUserDataEntries)
{
	if (cUserDataEntries > 0)
	{
		ASSERT(pUserDataInfoEntries);
		for (UINT u = 0; u < cUserDataEntries; u++)
		{
			m_UserData.AddUserData(pUserDataInfoEntries[u].pGUID,
					(unsigned short)pUserDataInfoEntries[u].cbData,
					pUserDataInfoEntries[u].pData);

		}
	}
}

BOOL CIncomingCall::MatchAcceptedCaller(PCWSTR pcwszNodeName)
{
	// check to see if this caller matches someone whom we already accepted 
	if ((NULL != m_pConnection) &&
		(NM_CALL_ACCEPTED == m_State) &&
		(GUID_NULL == m_guidNode) &&
		(NULL != m_bstrCaller) &&
		(0 == UnicodeCompare(m_bstrCaller, pcwszNodeName)) )
	{
		return TRUE;
	}

	return FALSE;
}

BOOL CIncomingCall::MatchAcceptedCaller(GUID* pguidNodeId)
{
	// check to see if this caller matches someone whom we already accepted 
	if ((NULL != m_pConnection) &&
		((NM_CALL_INIT == m_State) ||
		(NM_CALL_ACCEPTED == m_State)) &&
		(GUID_NULL != m_guidNode) &&
		(*pguidNodeId == m_guidNode))
	{
		return TRUE;
	}

	return FALSE;
}

BOOL CIncomingCall::MatchActiveCaller(GUID* pguidNodeId)
{
	// check to see if this caller matches someone whom we already accepted
	// or is in the process of calling us
	if ((NULL != m_pConnection) &&
		((NM_CALL_INIT == m_State) ||
		(NM_CALL_RING == m_State) ||
		(NM_CALL_ACCEPTED == m_State)) &&
		(GUID_NULL != m_guidNode) &&
		(*pguidNodeId == m_guidNode))
	{
		return TRUE;
	}

	return FALSE;
}

void CIncomingCall::Ring()
{
	m_State = NM_CALL_RING;
	NotifySink((PVOID) m_State, OnNotifyCallStateChanged);
}

HRESULT CIncomingCall::OnH323Connected()
{
	CConfObject *pco = ::GetConfObject();
	if (NULL != pco)
	{
		BOOL fAddMember = DidUserAccept();
	
		pco->OnH323Connected(m_pConnection, m_dwFlags, fAddMember, m_guidNode);

		m_fMemberAdded = fAddMember;
	}

	return S_OK;
}

HRESULT CIncomingCall::OnH323Disconnected()
{
	if (NM_CALL_RING == m_State)
	{
		if (m_hConf)
		{
			CONF_HANDLE hConf = m_hConf;
			m_hConf = NULL;
			// if there is an invite or join pending, kill it
			if ( m_fInvite )
				hConf->InviteResponse(FALSE);
			else
				hConf->JoinResponse(FALSE);
		}
	}

	if(m_pConnection)
	{
		m_pConnection->Release();
		m_pConnection = NULL;
	}

	if ((NM_CALL_RING == m_State) ||
		(NM_CALL_INIT == m_State))
	{
		m_State = NM_CALL_CANCELED;
		NotifySink((PVOID) m_State, OnNotifyCallStateChanged);
	}

	return m_hConf ? S_FALSE : S_OK;
}

VOID CIncomingCall::OnIncomingT120Call(
			BOOL fInvite,
			PUSERDATAINFO pUserDataInfoEntries,
			UINT cUserDataEntries)
{
	m_fInvite = fInvite;

	ProcessT120UserData(pUserDataInfoEntries, cUserDataEntries);
}

HRESULT CIncomingCall::OnT120ConferenceEnded()
{
	m_hConf = NULL;

	if(!m_fMemberAdded && m_pConnection)
	{
		// we didn't hand off this connection to the member
		IH323Endpoint* pConnection = m_pConnection;
		m_pConnection = NULL;
		pConnection->Disconnect();
		pConnection->Release();
	}

	if (NM_CALL_RING == m_State)
	{
		m_State = NM_CALL_CANCELED;
		NotifySink((PVOID) m_State, OnNotifyCallStateChanged);
	}

	return m_pConnection ? S_FALSE : S_OK;
}

HRESULT CIncomingCall::Terminate(BOOL fReject)
{
	HRESULT hr = E_FAIL;

	// need to make sure that we are still ringing
	if ((NM_CALL_ACCEPTED != m_State) &&
		(NM_CALL_REJECTED != m_State) &&
		(NM_CALL_CANCELED != m_State))
	{
		m_State = fReject ? NM_CALL_REJECTED : NM_CALL_CANCELED;

		TRACE_OUT(("CIncomingCall: Call not accepted - responding"));

		if (NULL != m_hConf)
		{
			CONF_HANDLE hConf = m_hConf;
			m_hConf = NULL;
			if (m_fInvite)
			{
				hConf->InviteResponse(FALSE);
			}
			else
			{
				CConfObject *pco = ::GetConfObject();
				ASSERT(pco);

				if (pco->GetConfHandle() == hConf)
				{
					hConf->JoinResponse(FALSE);
				}
			}
		}

		if (NULL != m_pConnection)
		{
			ConnectStateType state;	
			HRESULT hr = m_pConnection->GetState(&state);
			hr = m_pConnection->GetState(&state);
			ASSERT(SUCCEEDED(hr));
			if(CLS_Alerting == state)
			{
				IH323Endpoint* pConn = m_pConnection;
				m_pConnection = NULL;
				pConn->AcceptRejectConnection(CRR_REJECT);
				pConn->Release();
				m_pOprahNCUI->ReleaseAV(pConn);
			}
		}

		NotifySink((PVOID) m_State, OnNotifyCallStateChanged);

		hr = S_OK;
	}

	return hr;
}


STDMETHODIMP_(ULONG) CIncomingCall::AddRef(void)
{
	return RefCount::AddRef();
}
	
STDMETHODIMP_(ULONG) CIncomingCall::Release(void)
{
	return RefCount::Release();
}

HRESULT STDMETHODCALLTYPE CIncomingCall::QueryInterface(REFIID riid, PVOID *ppv)
{
	HRESULT hr = S_OK;

	if ((riid == IID_INmCall) || (riid == IID_IUnknown))
	{
		*ppv = (INmCall *)this;
		ApiDebugMsg(("CIncomingCall::QueryInterface()"));
	}
	else if (riid == IID_IConnectionPointContainer)
	{
		*ppv = (IConnectionPointContainer *) this;
		ApiDebugMsg(("CIncomingCall::QueryInterface(): Returning IConnectionPointContainer."));
	}
	else
	{
		hr = E_NOINTERFACE;
		*ppv = NULL;
		ApiDebugMsg(("CIncomingCall::QueryInterface(): Called on unknown interface."));
	}

	if (S_OK == hr)
	{
		AddRef();
	}

	return hr;
}

HRESULT CIncomingCall::IsIncoming(void)
{
	return S_OK;
}

HRESULT CIncomingCall::GetState(NM_CALL_STATE *pState)
{
	HRESULT hr = E_POINTER;

	if (NULL != pState)
	{
		*pState = m_State;
		hr = S_OK;
	}
	return hr;
}

HRESULT CIncomingCall::GetName(BSTR * pbstrName)
{
	if (NULL == pbstrName)
		return E_POINTER;

	*pbstrName = SysAllocString(m_bstrCaller);
	return (*pbstrName ? S_OK : E_FAIL);
}

HRESULT CIncomingCall::GetAddr(BSTR * pbstrAddr, NM_ADDR_TYPE *puType)
{
	// for now we just do the same thing as NM2.11
	if ((NULL == pbstrAddr) || (NULL == puType))
		return E_POINTER;

	*puType = NM_ADDR_UNKNOWN;
	*pbstrAddr = SysAllocString(L"");
	return (*pbstrAddr ? S_OK : E_FAIL);
}

HRESULT CIncomingCall::GetUserData(REFGUID rguid, BYTE **ppb, ULONG *pcb)
{
	return m_UserData.GetUserData(rguid,ppb,pcb);
}

HRESULT CIncomingCall::GetConference(INmConference **ppConference)
{
#ifdef NOTYET
	*ppConference = NULL;

	CConfObject *pco = ::GetConfObject();
	if (NULL != pco)
	{
		if (pco->GetConfHandle() == m_hConf)
		{
			*ppConference = pco;
			return S_OK;
		}
		return E_UNEXPECTED;
	}
#endif
	return S_FALSE;

}

HRESULT CIncomingCall::Accept(void)
{
	HRESULT hr = E_FAIL;

	// need to make sure that we are still ringing
	if (NM_CALL_RING == m_State)
	{
		m_pOprahNCUI->OnIncomingCallAccepted();

		CConfObject *pco = ::GetConfObject();
		ASSERT(pco);

		if ((NULL != m_hConf) && (pco->GetConfHandle() == m_hConf))
		{
			if (m_fInvite)
			{
				hr = m_hConf->InviteResponse(TRUE);
			}
			else
			if (pco->GetConfHandle() == m_hConf)
			{
				hr = m_hConf->JoinResponse(TRUE);
			}
		}
		else if (NULL != m_pConnection)
		{
			ConnectStateType state;	
			HRESULT hrTemp = m_pConnection->GetState(&state);
			ASSERT(SUCCEEDED(hrTemp));
			if(CLS_Alerting == state)
			{
				m_pConnection->AcceptRejectConnection(CRR_ACCEPT);
				hr = S_OK;
			}
		}

		if (S_OK == hr)
		{
			// notify all call observers that the call was accepted
			m_State = NM_CALL_ACCEPTED;
			NotifySink((INmConference *) pco, OnNotifyCallAccepted);
		}
		else
		{
			// call went away before it was accepted
			m_State = NM_CALL_CANCELED;
			NotifySink((PVOID)CN_RC_CONFERENCE_ENDED_BEFORE_ACCEPTED, OnNotifyCallError);
		}

		// notify all call observers of the state change
		NotifySink((PVOID) m_State, OnNotifyCallStateChanged);
	}
	else
	{
		hr = ((NM_CALL_ACCEPTED == m_State) ? S_OK : E_FAIL);
	}

	return hr;
}

HRESULT CIncomingCall::Reject(void)
{
	return Terminate(TRUE);
}

HRESULT CIncomingCall::Cancel(void)
{
	return Terminate(FALSE);
}

/*  O N  N O T I F Y  C A L L  A C C E P T E D  */
/*-------------------------------------------------------------------------
    %%Function: OnNotifyCallAccepted
    
-------------------------------------------------------------------------*/
HRESULT OnNotifyCallAccepted(IUnknown *pCallNotify, PVOID pv, REFIID riid)
{
	ASSERT(NULL != pCallNotify);
	((INmCallNotify*)pCallNotify)->Accepted((INmConference *) pv);
	return S_OK;
}



CIncomingCallManager::CIncomingCallManager()
{
}

CIncomingCallManager::~CIncomingCallManager()
{
	// Empty the call list:
	while (!m_CallList.IsEmpty())
	{
		CIncomingCall* pCall = (CIncomingCall*) m_CallList.RemoveHead();
		// Shouldn't have any NULL entries:
		ASSERT(pCall);
		pCall->Release();
	}
}

CREQ_RESPONSETYPE CIncomingCallManager::OnIncomingH323Call(
	    COprahNCUI *pManager,
		IH323Endpoint* pConnection,
		P_APP_CALL_SETUP_DATA lpvMNMData)
{
	CREQ_RESPONSETYPE resp;

///////////////////////////////////////////////////
//	first we determine the capabilities the caller	
///////////////////////////////////////////////////	
	
	BOOL fRequestAutoAccept = FALSE;
	// don't assume anything about security
	BOOL fT120SecureCall = FALSE;
	BOOL fT120NonSecureCall = FALSE;
	// assume that the caller can do an invite or a join
	BOOL fT120Invite = TRUE;
	BOOL fT120Join = TRUE;
	// assume that the caller wants a/v
	BOOL fRequestAV = TRUE;
	// assume that the caller is not NM2.X
	BOOL fCallerNM2x = FALSE;

	PCC_VENDORINFO pLocalVendorInfo;
	PCC_VENDORINFO pRemoteVendorInfo;
	if (S_OK == pConnection->GetVersionInfo(&pLocalVendorInfo, &pRemoteVendorInfo))
	{
		H323VERSION version = GetH323Version(pRemoteVendorInfo);

		switch (version)
		{
			case H323_NetMeeting20:
			case H323_NetMeeting21:
			case H323_NetMeeting211:
				fCallerNM2x = TRUE;
				break;
			default:
				break;
		}
	}

	if ((NULL != lpvMNMData) &&
		(lpvMNMData->dwDataSize >= sizeof(DWORD)))
	{
		DWORD dwUserData = *((LPDWORD)lpvMNMData->lpData);
		if (fCallerNM2x)
		{
			fRequestAutoAccept = (H323UDF_ALREADY_IN_T120_CALL == dwUserData);
			fT120SecureCall = FALSE;
			fT120NonSecureCall = TRUE;
			fT120Invite = TRUE;
			fT120Join = TRUE;
			fRequestAV = TRUE;
		}
		else if (0 != dwUserData)
		{
			fT120SecureCall = (H323UDF_SECURE & dwUserData);
			fT120NonSecureCall = !fT120SecureCall;
			fT120Invite = (H323UDF_INVITE & dwUserData);
			fT120Join = (H323UDF_JOIN & dwUserData);
			fRequestAV = ((H323UDF_AUDIO | H323UDF_VIDEO) & dwUserData);
		}
	}

////////////////////////////////////////////////
// next we determine the state of us the callee
////////////////////////////////////////////////
	
	DWORD dwFlags = CRPCF_DATA;
	BOOL fAcceptSecure  = TRUE;
    BOOL fAcceptNonSecure = TRUE;

	CConfObject *pco = ::GetConfObject();
	ASSERT(pco);

	BOOL fInActiveConference = pco->IsConferenceActive();
	
	if (fInActiveConference)
	{
        //
        // If we've reached our limit of attendees, reject it.  Also reject
        // it if incoming calls are prevented by settings.
        //
        if (pco->GetNumMembers() >= pco->GetConfMaxParticipants())
        {
            ASSERT(pco->GetNumMembers() == pco->GetConfMaxParticipants());

            WARNING_OUT(("Rejecting incoming H.323 call, reached limit setting of %d",
                pco->GetConfMaxParticipants()));
            resp = CRR_REJECT;
            goto REJECT_CALL;
        }

        if ((pco->IsHosting() != S_OK) &&
            !(pco->GetConfAttendeePermissions() & NM_PERMIT_INCOMINGCALLS))
        {
            WARNING_OUT(("Rejecting incoming H.323 call, not permitted by meeting setting"));
            resp = CRR_REJECT;
            goto REJECT_CALL;
        }

        //
        // We're in a conference, the security settings are whatever those
        // of the conference are.  The user prefs are just for establishing
        // the first call.
        //
		if (pco->IsConfObjSecure())
		{
			fAcceptNonSecure = FALSE;
		}
		else
		{
            fAcceptSecure = FALSE;
		}
	}
    else
    {
		// we are not in a conference so use the prefered settings

        RegEntry reConf(POLICIES_KEY, HKEY_CURRENT_USER);
        switch (reConf.GetNumber(REGVAL_POL_SECURITY, DEFAULT_POL_SECURITY))
        {
            case DISABLED_POL_SECURITY:
                fAcceptSecure = FALSE;
                break;

            case REQUIRED_POL_SECURITY:
                fAcceptNonSecure = FALSE;
                break;

            default:
            {
                RegEntry rePref(CONFERENCING_KEY, HKEY_CURRENT_USER);

                // Is incoming required to be secure by preference?
		    	if (rePref.GetNumber(REGVAL_SECURITY_INCOMING_REQUIRED,
								 DEFAULT_SECURITY_INCOMING_REQUIRED))
			    {
				    fAcceptNonSecure = FALSE;
    			}
                break;
            }
        }
    }


//////////////////////////////////////////
// now we weed out non acceptable callers	
//////////////////////////////////////////	
	
	if (fCallerNM2x && !fAcceptNonSecure)
	{
		// NetMeeting 2.X cannot speak security
		return CRR_REJECT;
	}

	if (fT120SecureCall || !fAcceptNonSecure)
	{
        //
        // If we insist on security, or the call is secure and we can 
        // handle it, the result is secure.
        //
		dwFlags |= CRPCF_SECURE;
	}
	else if (fRequestAV && pManager->AcquireAV(pConnection))
	{
		dwFlags |= CRPCF_VIDEO | CRPCF_AUDIO;
	}

	if (fCallerNM2x && (0 == ((CRPCF_VIDEO | CRPCF_AUDIO) & dwFlags)))
	{
		// a/v is not available
		// if leading with H323, caller will try again with T120
		// else their done
		resp = CRR_BUSY;
	}
	else if (fRequestAutoAccept)
	{
		// Auto accept this call if it came from NetMeeting 2.X and the caller is telling
		// us that we are already in a T.120 call with them.  This allows audio after data
		// calls to be accepted and also means that you aren't prompted when someone
		// switches a/v using the UI's "Send audio and video to..."

		if (fInActiveConference)
		{
			// we most likely have a matching call already but may not be able to find it
			CIncomingCall *pCall = new CIncomingCall(pManager, pConnection, lpvMNMData, dwFlags);
			// This transfers the implicit reference of pConnection to the
			// new CIncomingCall.  It will Release().
			if (NULL != pCall)
			{
				// add call to the list of incoming calls
				m_CallList.AddTail(pCall);

				resp = CRR_ACCEPT;
			}
			else
			{
				resp = CRR_REJECT;
			}
		}
		else
		{
			// we're not really in a T120 call like the caller said. reject this call!
			resp = CRR_REJECT;
		}
	}
	else if (!fT120Join && fInActiveConference)
	{
		// need to change this to CRR_IN_CONFERENCE
		resp = CRR_BUSY;
		TRACE_OUT(("Can only accept joins; in a conference"));
	}
	else if (fT120Join && !fT120Invite && !fInActiveConference)
	{
		resp = CRR_REJECT;
		TRACE_OUT(("Cannot accept H323 Join Request; not in a conference"));
	}
	else if (!fRequestAV && !fT120Join && !fT120Invite && !fInActiveConference)
	{
		resp = CRR_REJECT;
		TRACE_OUT(("No av/ or data; reject"));
	}
	else if (fT120SecureCall && !fAcceptSecure)
	{
		resp = CRR_SECURITY_DENIED;
		TRACE_OUT(("Can not accept secure H323 Call"));
	}
	else if (fT120NonSecureCall && !fAcceptNonSecure)
	{
		resp = CRR_SECURITY_DENIED;
		TRACE_OUT(("Can not accept non secure H323 Call"));
	}
	else
	{
		CIncomingCall *pCall = new CIncomingCall(pManager, pConnection, lpvMNMData, dwFlags);
		// This transfers the implicit reference of pConnection to the
		// new CIncomingCall.  It will Release().
		if (NULL != pCall)
		{
			if (g_guidLocalNodeId != *pCall->GetNodeGuid())
			{
				// Check for multiple calls from the same caller
				if (!MatchActiveCaller(pCall->GetNodeGuid()))
				{
					// add call to the list of incoming calls
					m_CallList.AddTail(pCall);

					pManager->OnIncomingCallCreated(pCall);

					// Don't ring on data only calls.
					// Wait for T120 call to come in.
					if (pCall->IsDataOnly())
					{
						resp = CRR_ACCEPT;
      				}
					else
					{	
						pCall->Ring();

						resp = CRR_ASYNC;
					}
				}
				else
				{
					// we're already in call with this person
					delete pCall;

					resp = CRR_REJECT;
				}
			}
			else
			{
				// we somehow called ourself
				delete pCall;

				resp = CRR_REJECT;
			}
		}
		else
		{
			resp = CRR_REJECT;
		}
	}

REJECT_CALL:
	if ((resp != CRR_ACCEPT) && (resp != CRR_ASYNC))
	{
		// make sure we are not holding on to AV
		pManager->ReleaseAV(pConnection);
	}

	return resp;
}

VOID CIncomingCallManager::OnH323Connected(IH323Endpoint* lpConnection)
{
	POSITION pos = m_CallList.GetHeadPosition();
	POSITION posItem;
	while (posItem = pos)
	{
		CIncomingCall* pCall = (CIncomingCall*) m_CallList.GetNext(pos);

		if ((NULL != pCall) &&
			(lpConnection == pCall->GetH323Connection()))
		{
			pCall->OnH323Connected();
			break;
		}
	}
}

VOID CIncomingCallManager::OnH323Disconnected(IH323Endpoint * lpConnection)
{
	POSITION pos = m_CallList.GetHeadPosition();
	POSITION posItem;
	while (posItem = pos)
	{
		CIncomingCall* pCall = (CIncomingCall*) m_CallList.GetNext(pos);

		if ((NULL != pCall) &&
			(lpConnection == pCall->GetH323Connection()))
		{
			if (S_OK == pCall->OnH323Disconnected())
			{
				m_CallList.RemoveAt(posItem);
				pCall->Release();
			}
			break;
		}
	}
}

VOID CIncomingCallManager::OnT120ConferenceEnded(CONF_HANDLE hConference)
{
	POSITION pos = m_CallList.GetHeadPosition();
	POSITION posItem;
	while (posItem = pos)
	{
		CIncomingCall* pCall = (CIncomingCall*) m_CallList.GetNext(pos);

		if ((NULL != pCall) &&
			(hConference == pCall->GetConfHandle()))
		{
			if (S_OK == pCall->OnT120ConferenceEnded())
			{
				m_CallList.RemoveAt(posItem);
				pCall->Release();
			}
		}
	}
}

HRESULT CIncomingCallManager::OnIncomingT120Call(
		COprahNCUI *pManager,
		BOOL fInvite,
		CONF_HANDLE hConf,
		PCWSTR pcwszNodeName,
		PUSERDATAINFO pUserDataInfoEntries,
		UINT cUserDataEntries,
		BOOL fSecure)
{
	HRESULT hr = S_OK;

	// need to scan through all accepted calls passing the T120 params
	// if someone returns S_OK, we accept the call

	CIncomingCall *pMatchedCall = NULL;

	GUID* pguidNodeID = GetGuidFromT120UserData(pUserDataInfoEntries, cUserDataEntries);
	if (pguidNodeID)
	{
		pMatchedCall = MatchAcceptedCaller(pguidNodeID);
	}
	else
	{
		pMatchedCall = MatchAcceptedCaller(pcwszNodeName);
	}

	if (pMatchedCall)
	{
		pMatchedCall->SetConfHandle(hConf);

		// we should always ring the client when the call is secure
		// or when we haven't rang already
		if (!pMatchedCall->DidUserAccept())
		{
			pMatchedCall->OnIncomingT120Call(fInvite,
											 pUserDataInfoEntries,
											 cUserDataEntries);

			pMatchedCall->Ring();
		}
		else
		{
			if (fInvite)
			{
				hr = hConf->InviteResponse(TRUE);
			}
			else
			{
				hr = hConf->JoinResponse(TRUE);
			}
		}
		pMatchedCall->Release();
	}
	else
	{
		CIncomingCall *pCall = new CIncomingCall(pManager,
												 fInvite,
												 hConf,
												 pcwszNodeName,
												 pUserDataInfoEntries,
												 cUserDataEntries);
		if (NULL != pCall)
		{
			// currently we don't add T120 calls to the call list

			pManager->OnIncomingCallCreated(pCall);

			pCall->Ring();

			// we're not holding on to the call so release it
			pCall->Release();
		}
		else
		{
			// unable to accept call
			if (fInvite)
			{
				hr = hConf->InviteResponse(FALSE);
			}
			else
			{
				hConf->JoinResponse(FALSE);
			}

			hr = E_OUTOFMEMORY;
		}
	}

	return hr;
}


CIncomingCall* CIncomingCallManager::MatchAcceptedCaller(PCWSTR pcwszNodeName)
{
	// we won't auto accept anyone who is already in the roster
	CNmMember* pMember = PDataMemberFromName(pcwszNodeName);
	if (NULL != pMember)
	{
		return FALSE;
	}

	POSITION pos = m_CallList.GetHeadPosition();
	while (pos)
	{
		CIncomingCall* pCall = (CIncomingCall*) m_CallList.GetNext(pos);

		if ((NULL != pCall) &&
			pCall->MatchAcceptedCaller(pcwszNodeName))
		{
			TRACE_OUT(("Matched accepted caller"));
			pCall->AddRef();
			return pCall;
		}
	}

	return NULL;
}

CIncomingCall* CIncomingCallManager::MatchAcceptedCaller(GUID* pguidNodeId)
{
	if (GUID_NULL == *pguidNodeId)
	{
		return FALSE;
	}

	// we wont auto accept anyone who is already in the roster
	CNmMember* pMember = PMemberFromNodeGuid(*pguidNodeId);
	if ((NULL != pMember) && pMember->FHasData())
	{
		return FALSE;
	}

	POSITION pos = m_CallList.GetHeadPosition();
	while (pos)
	{
		CIncomingCall* pCall = (CIncomingCall*) m_CallList.GetNext(pos);

		if ((NULL != pCall) &&
			pCall->MatchAcceptedCaller(pguidNodeId))
		{
			TRACE_OUT(("Matched accepted caller"));
			pCall->AddRef();
			return pCall;
		}
	}

	return NULL;
}

CIncomingCall* CIncomingCallManager::MatchActiveCaller(GUID* pguidNodeId)
{
	if (GUID_NULL == *pguidNodeId)
	{
		return FALSE;
	}

	POSITION pos = m_CallList.GetHeadPosition();
	while (pos)
	{
		CIncomingCall* pCall = (CIncomingCall*) m_CallList.GetNext(pos);

		if ((NULL != pCall) &&
			pCall->MatchActiveCaller(pguidNodeId))
		{
			TRACE_OUT(("Matched active caller"));
			pCall->AddRef();
			return pCall;
		}
	}

	return NULL;
}

GUID* CIncomingCallManager::GetGuidFromT120UserData(
			PUSERDATAINFO	pUserDataInfoEntries,
			UINT			cUserDataEntries)
{
	if (cUserDataEntries > 0)
	{
		ASSERT(pUserDataInfoEntries);
		for (UINT u = 0; u < cUserDataEntries; u++)
		{
			if ((*pUserDataInfoEntries[u].pGUID == g_csguidNodeIdTag) &&
				(pUserDataInfoEntries[u].cbData == sizeof(GUID)))
			{
				return (GUID*)pUserDataInfoEntries[u].pData;
			}
		}
	}
	return NULL;
}

VOID CIncomingCallManager::CancelCalls()
{
	DebugEntry(CIncomingCallManager::CancelCalls);

	POSITION pos = m_CallList.GetHeadPosition();
	POSITION posItem;
	while (posItem = pos)
	{
		CIncomingCall* pCall = (CIncomingCall*) m_CallList.GetNext(pos);

		if (NULL != pCall)
		{
			if (SUCCEEDED(pCall->Terminate(FALSE)))
			{
				m_CallList.RemoveAt(posItem);
				pCall->Release();
			}
		}
	}

	DebugExitVOID(CIncomingCallManager::CancelCalls);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\core\icall.cpp ===
// File: icall.cpp

#include "precomp.h"

#include "icall.h"
#include "rostinfo.h"
#include "imanager.h"
#include "mperror.h"
#include "nmremote.h"
#include "util.h"

typedef struct
{
	BOOL    fMCU;
	PWSTR * pwszConfNames;
	BSTR  * pbstrConfToJoin;
} REMOTE_CONFERENCE;

typedef struct
{
	BSTR bstrConference;
	BSTR *pbstrPassword;
	PBYTE pbRemoteCred;
	DWORD cbRemoteCred;
	BOOL fIsService;
} REMOTE_PASSWORD;


HRESULT OnNotifyCallError(IUnknown *pCallNotify, PVOID pv, REFIID riid);

static HRESULT OnNotifyRemoteConference(IUnknown *pCallNotify, PVOID pv, REFIID riid);
static HRESULT OnNotifyRemotePassword(IUnknown *pCallNotify, PVOID pv, REFIID riid);

static const IID * g_apiidCP[] =
{
	{&IID_INmCallNotify},
	{&IID_INmCallNotify2}
};

// String Functions
inline VOID FreeBstr(BSTR *pbstr)
{
	if (NULL != pbstr)
	{
		SysFreeString(*pbstr);
		*pbstr = NULL;
	}
}

/*  P S Z  A L L O C  */
/*-------------------------------------------------------------------------
    %%Function: PszAlloc

-------------------------------------------------------------------------*/
LPTSTR PszAlloc(LPCTSTR pszSrc)
{
	if (NULL == pszSrc)
		return NULL;

	LPTSTR pszDest = new TCHAR[lstrlen(pszSrc) + 1];
	if (NULL != pszDest)
	{
		lstrcpy(pszDest, pszSrc);
	}
	return pszDest;
}

COutgoingCall::COutgoingCall(CConfObject* pco,
		DWORD dwFlags, NM_ADDR_TYPE addrType,
		BSTR bstrName, BSTR bstrDest, BSTR bstrAlias,
		BSTR bstrConference, BSTR bstrPassword,	BSTR bstrUserString) :
	CConnectionPointContainer(g_apiidCP, ARRAY_ELEMENTS(g_apiidCP)),
	m_pConfObject			(pco),
	m_addrType				(addrType),
	m_dwFlags				(dwFlags),
	m_bstrName				(SysAllocString(bstrName)),
	m_bstrAlias				(SysAllocString(bstrAlias)),
	m_bstrConfToJoin		(SysAllocString(bstrConference)),
	m_bstrPassword			(SysAllocString(bstrPassword)),
	m_bstrUserString		(SysAllocString(bstrUserString)),
	m_hRequest				(NULL),
	m_pH323Connection		(NULL),
	m_fCanceled 			(FALSE),
	m_cnResult				(CN_RC_NOERROR),
	m_cnState				(CNS_IDLE),
	m_fService				(FALSE)
{
	m_pszAddr =	PszAlloc(CUSTRING(bstrDest));
	DbgMsg(iZONE_OBJECTS, "Obj: %08X created COutgoingCall", this);
}

COutgoingCall::~COutgoingCall()
{
	delete m_pszAddr;

	FreeBstr(&m_bstrName);
	FreeBstr(&m_bstrAlias);
	FreeBstr(&m_bstrConfToJoin);
	FreeBstr(&m_bstrPassword);
	FreeBstr(&m_bstrUserString);

	ASSERT(NULL == m_pH323Connection);

	DbgMsg(iZONE_OBJECTS, "Obj: %08X destroyed COutgoingCall", this);
}


BOOL COutgoingCall::MatchActiveCallee(LPCTSTR pszAddr, BSTR bstrAlias, BSTR bstrConference)
{
	return ((0 == lstrcmp(pszAddr, m_pszAddr)) &&
			(0 == UnicodeCompare(bstrAlias, m_bstrAlias)));

}

/*  P L A C E  C A L L  */
/*-------------------------------------------------------------------------
    %%Function: PlaceCall

-------------------------------------------------------------------------*/
VOID COutgoingCall::PlaceCall(void)
{
	DebugEntry(COutgoingCall::PlaceCall);

	COprahNCUI *pOprahNCUI = COprahNCUI::GetInstance();
	ASSERT(NULL != pOprahNCUI);

	SetCallState(CNS_SEARCHING);

	if ((CRPCF_H323CC & m_dwFlags) && (NULL != g_pH323UI))
	{
		SetCallState(CNS_CONNECTING_H323);

		// Start placing the H.323 call:
		CNSTATUS cnResult = ConnectH323();
		if (CN_RC_NOERROR != cnResult)
		{
			m_cnResult = cnResult;
			SetCallState(CNS_COMPLETE);
		}
	}
	else if ((CRPCF_DATA & m_dwFlags) && (NULL != g_pNodeController))
	{
		// Start placing the T.120 call
		CNSTATUS cnResult = StartT120Call();
		if (CN_RC_NOERROR != cnResult)
		{
			m_cnResult = cnResult;
			SetCallState(CNS_COMPLETE);
		}
	}
	else
	{
		m_cnResult = CN_RC_TRANSPORT_FAILURE;
		SetCallState(CNS_COMPLETE);
	}

	DebugExitVOID(COutgoingCall::PlaceCall);
}

CNSTATUS COutgoingCall::ConnectH323()
{
	DBGENTRY(COutgoingCall::ConnectH323);
	H323ALIASLIST AliasList;
	H323ALIASNAME AliasName;
	P_H323ALIASLIST pAliasList = &AliasList;
	SOCKADDR_IN sin;
	LPCWSTR pcwszPhone = NULL;
	CNSTATUS cnResult = CN_RC_NOERROR;

	if (NULL == g_pH323UI)
		return cnResult;
	
	AliasName.aType = AT_H323_ID;
	AliasName.lpwData = m_bstrAlias;
	AliasName.wDataLength = (WORD)SysStringLen(m_bstrAlias);// # of unicode chars, w/o NULL terminator
	AliasList.wCount = 1;
	AliasList.pItems = &AliasName;

	sin.sin_family = AF_INET;
	sin.sin_addr.s_addr = inet_addr(m_pszAddr);

	switch (m_addrType)
	{
	case NM_ADDR_PSTN:
	case NM_ADDR_H323_GATEWAY:
	case NM_ADDR_ALIAS_E164:
		// overide alias type and phone number
		AliasName.aType = AT_H323_E164;
		pcwszPhone = m_bstrAlias;
		break;

	case NM_ADDR_IP:
	case NM_ADDR_MACHINENAME:
		// overide alias list
		pAliasList = NULL;
		break;

	case NM_ADDR_ALIAS_ID:
	case NM_ADDR_ULS:
	default:
		break;
	}

	if (INADDR_NONE != sin.sin_addr.s_addr)
	{
		HRESULT hr;
		ASSERT(g_pH323UI);

		DWORD dwUserData = 0;
		APP_CALL_SETUP_DATA acsd;
		P_APP_CALL_SETUP_DATA pacsd = NULL;
		BYTE *pbUserData = NULL;
	
		COprahNCUI *pOprahNCUI = COprahNCUI::GetInstance();
		ASSERT(NULL !=pOprahNCUI);
		
		if (CRPCF_DATA & m_dwFlags)
		{
			if (CRPCF_SECURE & m_dwFlags)
			{
				dwUserData |= H323UDF_SECURE;
			}

			if (m_pConfObject->IsConferenceActive())
			{
				dwUserData |= H323UDF_INVITE;
			}
			else if (m_bstrConfToJoin != NULL)
			{
				dwUserData |= H323UDF_JOIN;
			}
			else
			{
				dwUserData |= H323UDF_INVITE | H323UDF_JOIN;
			}
		}

		if (CRPCF_AUDIO & m_dwFlags)
		{
			dwUserData |= H323UDF_AUDIO;
		}
		if (CRPCF_VIDEO & m_dwFlags)
		{
			dwUserData |= H323UDF_VIDEO;
		}

		CRosterInfo ri;
		PVOID pvRosterData;
		UINT cbRosterData = 0;

		if (pOprahNCUI->GetULSName(&ri))
		{
			if (FAILED(ri.Save(&pvRosterData, &cbRosterData)))
			{
				cbRosterData = 0;
			}
		}

		UINT cbUserString = 0;
		if (m_bstrUserString)
		{
			cbUserString = SysStringByteLen(m_bstrUserString);
		}
		
		DWORD dwTotalSize =	sizeof(DWORD);
		if (cbRosterData)
		{
			dwTotalSize += sizeof(GUID) + sizeof(DWORD) + cbRosterData;
		}
		if (cbUserString)
		{
			dwTotalSize += sizeof(GUID) + sizeof(DWORD) + cbUserString;
		}
		dwTotalSize += sizeof(GUID) + sizeof(DWORD) + sizeof(GUID);

		pbUserData = new BYTE [dwTotalSize];
		if (NULL != pbUserData)
		{
			BYTE *pb = pbUserData;

			// H323UDF_ first
			*((DWORD*)pb) = dwUserData;
			pb += sizeof(DWORD);

			if(cbRosterData)
			{
				// RosterInfo GUID next
				*((GUID*)pb) = g_csguidRostInfo,
				pb += sizeof(GUID);

				// then RosterInfo size (a DWORD)
				*((DWORD*)pb) = cbRosterData;
				pb += sizeof(DWORD);

				// then RosterInfo data
				CopyMemory(pb, pvRosterData, cbRosterData);
				pb += cbRosterData;
			}

			if(cbUserString)
			{
				// string GUID next
				*((GUID*)pb) = g_csguidUserString,
				pb += sizeof(GUID);

				// then string size (a DWORD)
				*((DWORD*)pb) = cbUserString;
				pb += sizeof(DWORD);

				// then string data
				CopyMemory(pb, m_bstrUserString, cbUserString);
				pb += cbUserString;
			}

			{
				// string GUID next
				*((GUID*)pb) = g_csguidNodeIdTag,
				pb += sizeof(GUID);

				// then string size (a DWORD)
				*((DWORD*)pb) = sizeof(GUID);
				pb += sizeof(DWORD);

				// then GUID data
				*(GUID*)pb = g_guidLocalNodeId;
				pb += sizeof(GUID);
			}

			acsd.dwDataSize = dwTotalSize;
			acsd.lpData = pbUserData;
			pacsd = &acsd;
		}

		sin.sin_port = htons(H323_PORT);
		hr = Connect(&sin, pAliasList, pcwszPhone, pacsd, PID_H323, &m_pH323Connection);
		delete pbUserData;

		if (SUCCEEDED(hr))
		{
			TRACE_OUT(("COutgoingCall - Connect() succeeded!"));
			cnResult = CN_RC_NOERROR;
		}
		else
		{
			WARNING_OUT(("COutgoingCall - Connect() failed!"));
			if (CONN_E_GK_NOT_REGISTERED == hr)
			{
				cnResult = CN_RC_GK_NOT_REGISTERED;
			}
			else
			{
				cnResult = CN_RC_AUDIO_CONNECT_FAILED;
			}
		}
	}
	else
	{
		WARNING_OUT(("COutgoingCall - inet_addr failed!"));
		cnResult = CN_RC_NAME_RESOLUTION_FAILED;
	}
	return cnResult;
}


HRESULT COutgoingCall::Connect(	PSOCKADDR_IN psin,
						    P_H323ALIASLIST pAliasList,
							LPCWSTR pcwszPSTNAddress,
							P_APP_CALL_SETUP_DATA lpvMNMData,
							GUID PIDofProtocolType,
							IH323Endpoint * *ppConnection)
{
	DebugEntry(CH323UI::Connect);

	HRESULT hr = E_ACCESSDENIED;

	*ppConnection = NULL;

	COprahNCUI *pOprahNCUI = COprahNCUI::GetInstance();
	ASSERT(NULL != pOprahNCUI);

	IH323CallControl * pH323CallControl = g_pH323UI->GetH323CallControl();
		
	// create the connection
	IH323Endpoint* pConn = NULL;
	ASSERT(pH323CallControl);
	
	hr = pH323CallControl->CreateConnection(&pConn, PIDofProtocolType);
	if (FAILED(hr) || (NULL == pConn))
	{
		ERROR_OUT(("Could not create a connection, hr=0x%lx", hr));
	}
	else
	{
		// if the following operations fail, we still can delete this conn obj
		*ppConnection = pConn;

		if (!pOprahNCUI->AcquireAV(pConn))
		{
			// we did not get AV, clear out the flags
			m_dwFlags &= ~(CRPCF_AUDIO | CRPCF_VIDEO);
		}
	
		hr = pConn->SetAdviseInterface (pOprahNCUI);
		ASSERT(SUCCEEDED(hr));

		// if we are using an alias, tell the Gatekeeper to resolve it
		BOOL fUseGKResolution = (NULL != pAliasList);

		// start the connection
		hr = pConn->PlaceCall (fUseGKResolution, psin, pAliasList, NULL, pcwszPSTNAddress, lpvMNMData);
		if (FAILED(hr))
		{
			// ERROR_OUT(("COutgoingCall::Connect: couldn't StartConnection, hr=0x%lx", hr));
			if(hr == CONN_E_GK_NOT_REGISTERED)
			{
				WARNING_OUT(("COutgoingCall::Connect: not registered. Do you want to re-register..., hr=0x%lx", hr));
			}
			*ppConnection = NULL;

			pConn->Release();

			pOprahNCUI->ReleaseAV(pConn);
		}
	}

	DebugExitULONG(CH323UI::Connect, hr);

	return hr;
}

BOOL COutgoingCall::OnConferenceEnded()
{
	DebugEntry(COutgoingCall::OnConferenceEnded);

	BOOL bRet = FALSE;

	switch (m_cnState)
	{
		case CNS_INVITING_REMOTE:
		{
			TRACE_OUT(("COutgoingCall (calling) rec. UNEXPECTED ConfEnded event"));

			SetCallState(CNS_COMPLETE);

			bRet = TRUE;
			break;
		}

		case CNS_JOINING_REMOTE:
		{
			// JoinConference failed!
			TRACE_OUT(("COutgoingCall (joining) received ConferenceEnded event"));

			m_cnResult = CN_RC_CONFERENCE_JOIN_DENIED;
			SetCallState(CNS_COMPLETE);

			bRet = TRUE;
			break;
		}

		case CNS_TERMINATING_AFTER_INVITE:
		{
			TRACE_OUT(("COutgoingCall (terminating after invite) received ConferenceEnded event"));

			SetCallState(CNS_QUERYING_REMOTE_AFTER_INVITE);

			ASSERT(g_pNodeController);

			HRESULT hr = g_pNodeController->QueryRemote(this, m_pszAddr,
				m_pConfObject->IsConfObjSecure(),
				m_pConfObject->IsConferenceActive());
			if (S_OK != hr)
			{
				m_cnResult = CN_RC_QUERY_FAILED;
				SetCallState(CNS_COMPLETE);
			}

			bRet = TRUE;
			break;
		}

		default:
		{
			WARNING_OUT(("COutgoingCall received unexpected ConfEnded event"));
		}
	}

	DebugExitBOOL(COutgoingCall::OnConferenceEnded, bRet);
	return bRet;
}

BOOL COutgoingCall::OnInviteResult(HRESULT ncsResult, UINT uNodeID)
{
	DebugEntry(COutgoingCall::OnInviteResult);

	BOOL bRet = TRUE;

	ASSERT(CNS_INVITING_REMOTE == m_cnState);

	TRACE_OUT(("COutgoingCall (calling) received InviteResult event"));

	// Clear the current request handle
	m_hRequest = NULL;
	
	if (0 == ncsResult)
	{
		SetCallState(CNS_COMPLETE);
		if (m_pH323Connection)
		{
			m_pConfObject->OnT120Connected(m_pH323Connection, uNodeID);
		}
	}
	else
	{
		if (UI_RC_USER_REJECTED == ncsResult)
		{
			SetCallState(CNS_TERMINATING_AFTER_INVITE);

			// Issue "soft" leave attempt (to allow auto-terminate)
			ASSERT(m_pConfObject);
			if (S_OK != m_pConfObject->LeaveConference(FALSE))
			{
				m_cnResult = CN_RC_CONFERENCE_INVITE_DENIED;
				SetCallState(CNS_COMPLETE);
			}
		}
		else
		{
			// make sure that we are not recieving this notification due to
			// the conference going away
			ASSERT(m_pConfObject);
			if (CS_GOING_DOWN != m_pConfObject->GetT120State())
			{
				TRACE_OUT(("COutgoingCall - invite failed / couldn't connect -> leaving"));
			
				m_cnResult = CN_RC_INVITE_FAILED;
				SetCallState(CNS_COMPLETE);

				// Issue "soft" leave attempt (to allow auto-terminate)
				ASSERT(m_pConfObject);
				m_pConfObject->LeaveConference(FALSE);
			}
		}
	}

	DebugExitBOOL(COutgoingCall::OnInviteResult, bRet);
	return bRet;
}

BOOL COutgoingCall::OnQueryRemoteResult(HRESULT ncsResult,
									BOOL fMCU,
									PWSTR pwszConfNames[],
									PT120PRODUCTVERSION pVersion,
									PWSTR pwszConfDescriptors[])
{
	DebugEntry(COutgoingCall::OnQueryRemoteResult);

	ASSERT ((CNS_QUERYING_REMOTE == m_cnState) ||
			(CNS_QUERYING_REMOTE_AFTER_INVITE == m_cnState));
	ASSERT (NULL == m_bstrConfToJoin);

	if (SUCCEEDED(ncsResult))
	{
		BOOL fRemoteInConf = FALSE;
		if ((NULL != pwszConfNames) && (NULL != pwszConfNames[0]))
		{
			fRemoteInConf = TRUE;
		}

		m_fService = FALSE;
		if (fRemoteInConf && (NULL != pwszConfDescriptors) && (NULL != pwszConfDescriptors[0]))
		{
			if (0 == UnicodeCompare(pwszConfDescriptors[0],RDS_CONFERENCE_DESCRIPTOR))
			{
				m_fService = TRUE;
			}
		}

		if (m_pConfObject->IsConferenceActive())
		{
			if (fMCU)
			{
				TRACE_OUT(("COutgoingCall - QR ok, but is MCU -> complete"));
				m_cnResult = CN_RC_CANT_INVITE_MCU;
			}
			else if (fRemoteInConf)
			{
				TRACE_OUT(("COutgoingCall - QR ok, but callee is in a conference"));
				m_cnResult = CN_RC_INVITE_DENIED_REMOTE_IN_CONF;
			}
			else
			{
				if (CNS_QUERYING_REMOTE_AFTER_INVITE == m_cnState)
				{
					m_cnResult = CN_RC_CONFERENCE_INVITE_DENIED;
					SetCallState(CNS_COMPLETE);
				}
				else
				{
					SetCallState(CNS_INVITING_REMOTE);

					HRESULT hr = m_pConfObject->InviteConference(m_pszAddr, m_bstrUserString, &m_hRequest);
					if (S_OK != hr)
					{
						// Failure while inviting:
						m_cnResult = CN_RC_INVITE_FAILED;
					}
				}
			}

			if (CN_RC_NOERROR != m_cnResult)
			{
				SetCallState(CNS_COMPLETE);
			}
		}
		else if (fRemoteInConf || fMCU)
		{
			TRACE_OUT(("COutgoingCall - QR succeeded (>0 conf) -> joining"));
			TRACE_OUT(("\tfMCU is %d", fMCU));
		
			// There are remote conferences
			HRESULT hr = E_FAIL; // Assume a failure

			SetCallState(CNS_JOINING_REMOTE);

			if (!fMCU && (NULL == pwszConfNames[1]))
			{
				// we're not calling an MCU and we have just one conference, so join it
				m_bstrConfToJoin = SysAllocString(pwszConfNames[0]);
				hr = m_pConfObject->JoinConference(	m_bstrConfToJoin,
													m_bstrPassword,
													m_pszAddr,
													m_bstrUserString);
			}
			else
			{
				ASSERT(NULL == m_bstrConfToJoin);
				REMOTE_CONFERENCE remoteConf;
				remoteConf.fMCU = fMCU;
				remoteConf.pwszConfNames = pwszConfNames;
				remoteConf.pbstrConfToJoin = &m_bstrConfToJoin;

				// Ask the app which conference to join
				NotifySink(&remoteConf, OnNotifyRemoteConference);

				if (NULL != m_bstrConfToJoin)
				{
					hr = m_pConfObject->JoinConference(	m_bstrConfToJoin,
														m_bstrPassword,
														m_pszAddr,
														m_bstrUserString);
				}
			}

			if (S_OK != hr)
			{
				// JoinConference failed!
				m_cnResult = CN_RC_JOIN_FAILED;
				SetCallState(CNS_COMPLETE);
			}
		}
		else
		{
			if (CNS_QUERYING_REMOTE_AFTER_INVITE == m_cnState)
			{
				m_cnResult = CN_RC_CONFERENCE_INVITE_DENIED;
				SetCallState(CNS_COMPLETE);
			}
			else
			{
				// No conferences on remote machine, so create local:
				TRACE_OUT(("COutgoingCall - QR succeeded (no conf)-> creating local"));

				// Create local conf
				ASSERT(m_pConfObject);
				SetCallState(CNS_CREATING_LOCAL);
				HRESULT hr = m_pConfObject->CreateConference();

				if (S_OK != hr)
				{
					// CreateConference failed!
					m_cnResult = CN_RC_CONFERENCE_CREATE_FAILED;
					SetCallState(CNS_COMPLETE);
				}
			}
		}
	}
	else
	{
		// The QueryRemote failed
		switch( ncsResult )
		{
			case UI_RC_USER_REJECTED:
				// The initial QueryRemote failed because GCC symmetry determined
				// that the other node is calling someone, and it might be us
				// See Bug 1886
				TRACE_OUT(("COutgoingCall - QueryRemote rejected -> complete"));
				m_cnResult = CN_RC_REMOTE_PLACING_CALL;
				break;
			case UI_RC_T120_REMOTE_REQUIRE_SECURITY:
				m_cnResult = CN_RC_CONNECT_REMOTE_REQUIRE_SECURITY;
				break;
			case UI_RC_T120_SECURITY_FAILED:
				m_cnResult = CN_RC_SECURITY_FAILED;
				break;
			case UI_RC_T120_REMOTE_NO_SECURITY:
				m_cnResult = CN_RC_CONNECT_REMOTE_NO_SECURITY;
				break;
			case UI_RC_T120_REMOTE_DOWNLEVEL_SECURITY:
				m_cnResult = CN_RC_CONNECT_REMOTE_DOWNLEVEL_SECURITY;
				break;
			case UI_RC_T120_AUTHENTICATION_FAILED:
				m_cnResult = CN_RC_CONNECT_AUTHENTICATION_FAILED;
				break;
			default:
				m_cnResult = CN_RC_CONNECT_FAILED;
				break;
		}
		SetCallState(CNS_COMPLETE);
	}

	DebugExitBOOL(COutgoingCall::OnQueryRemoteResult, TRUE);
	return TRUE;
}

BOOL COutgoingCall::OnConferenceStarted(CONF_HANDLE hNewConf, HRESULT ncsResult)
{
	DebugEntry(COutgoingCall::OnConferenceStarted);

	switch (m_cnState)
	{
		case CNS_CREATING_LOCAL:
		{
			TRACE_OUT(("COutgoingCall (inviting) received ConferenceStarted event"));
			
			if (0 == ncsResult)
			{
				ASSERT(m_pConfObject);
				ASSERT(NULL == m_hRequest);

				SetCallState(CNS_INVITING_REMOTE);

				HRESULT hr = m_pConfObject->InviteConference(m_pszAddr, m_bstrUserString, &m_hRequest);
				if (S_OK != hr)
				{
					m_hRequest = NULL;
					m_cnResult = CN_RC_INVITE_FAILED;
					SetCallState(CNS_COMPLETE);
					
					// Issue "soft" leave attempt (to allow auto-terminate)
					ASSERT(m_pConfObject);
					HRESULT hr = m_pConfObject->LeaveConference(FALSE);
					if (FAILED(hr))
					{
						WARNING_OUT(("Couldn't leave after failed invite"));
					}
				}
			}
			else
			{
				WARNING_OUT(("CreateConference (local) failed - need UI here!"));
				m_cnResult = CN_RC_CONFERENCE_CREATE_FAILED;
				SetCallState(CNS_COMPLETE);
			}
			
			break;
		}

		case CNS_JOINING_REMOTE:
		{
			TRACE_OUT(("COutgoingCall (joining) received ConferenceStarted event"));

			if (0 == ncsResult)
			{
				SetCallState(CNS_COMPLETE);
				if (m_pH323Connection)
				{
					UINT uNodeID = hNewConf->GetParentNodeID();

					m_pConfObject->OnT120Connected(m_pH323Connection, uNodeID);
				}
			}
			else if (UI_RC_INVALID_PASSWORD == ncsResult)
			{
				TRACE_OUT(("COutgoingCall - invalid password, prompt for password"));

				BSTR bstrPassword = NULL;
				REMOTE_PASSWORD remotePw;
				remotePw.bstrConference = m_bstrConfToJoin;
				remotePw.pbstrPassword = &bstrPassword;
				if (NO_ERROR != hNewConf->GetCred(&remotePw.pbRemoteCred, &remotePw.cbRemoteCred))
				{
					remotePw.pbRemoteCred = NULL;
					remotePw.cbRemoteCred = 0;
				}
				remotePw.fIsService = m_fService;
				NotifySink(&remotePw, OnNotifyRemotePassword);

				if (NULL != bstrPassword)
				{
					SysFreeString(m_bstrPassword);
					m_bstrPassword = bstrPassword;

					// reissue join with new password
					ASSERT(m_pConfObject);
					HRESULT ncs =
						m_pConfObject->JoinConference(	m_bstrConfToJoin,
														m_bstrPassword,
														m_pszAddr,
														m_bstrUserString,
														TRUE); // retry

					if (0 != ncs)
					{
						// JoinConference failed!
						m_cnResult = CN_RC_JOIN_FAILED;
						SetCallState(CNS_COMPLETE);
					}
				}
				else
				{
					// cancel from pw dlg
					m_cnResult = CN_RC_INVALID_PASSWORD;
					SetCallState(CNS_COMPLETE);
					
					ASSERT(m_pConfObject);
					HRESULT hr = m_pConfObject->LeaveConference(TRUE);
					if (FAILED(hr))
					{
						ERROR_OUT(("Couldn't leave after cancelling pw join!"));
					}
				}
			}
			else if (UI_RC_UNKNOWN_CONFERENCE == ncsResult)
			{
				TRACE_OUT(("Join failed (conf does not exist) "
							"- notifying user"));
						
				// error while joining
				m_cnResult = CN_RC_CONFERENCE_DOES_NOT_EXIST;
				SetCallState(CNS_COMPLETE);
			}
			else
			{
				TRACE_OUT(("Join failed - notifying user"));
						
				// error while joining
				m_cnResult = CN_RC_CONFERENCE_JOIN_DENIED;
				SetCallState(CNS_COMPLETE);
			}

			break;
		}

		default:
		{
			if (m_pConfObject->GetConfHandle() == hNewConf)
			{
				WARNING_OUT(("COutgoingCall received unexpected ConferenceStarted event"));
			}
			else
			{
				TRACE_OUT(("COutgoingCall ignoring ConferenceStarted event - not our conf"));
			}
		}
	}

	DebugExitBOOL(COutgoingCall::OnConferenceStarted, TRUE);
	return TRUE;
}

BOOL COutgoingCall::OnH323Connected(IH323Endpoint * pConnection)
{
	DebugEntry(COutgoingCall::OnH323Connected);

	BOOL bRet = TRUE;

	ASSERT(m_pH323Connection == pConnection);

	if (m_dwFlags & CRPCF_DATA)
	{
		PCC_VENDORINFO pLocalVendorInfo;
		PCC_VENDORINFO pRemoteVendorInfo;

		pConnection->GetVersionInfo(&pLocalVendorInfo, &pRemoteVendorInfo);
		H323VERSION version = GetH323Version(pRemoteVendorInfo);

		if (H323_NetMeeting20 == version)
		{
			if ((m_addrType != NM_ADDR_H323_GATEWAY) &&
				(m_addrType != NM_ADDR_PSTN) &&
				(m_addrType != NM_ADDR_ALIAS_ID) &&
				(m_addrType != NM_ADDR_ALIAS_E164))
			{
				CNSTATUS cnResult = StartT120Call();
				if (CN_RC_NOERROR != cnResult)
				{
					m_cnResult = cnResult;
					SetCallState(CNS_COMPLETE);
				}
			}
			else
			{
				SetCallState(CNS_COMPLETE);
			}
		}
		else
		{
			// wait for results of T.120 open logical channel
			TRACE_OUT(("COutgoingCall - H323Connected received -> waiting for T120 channel open"));
			SetCallState(CNS_WAITING_T120_OPEN);
		}
	}
	else
	{
		// no T120 for this call
		TRACE_OUT(("COutgoingCall - our H323 call started -> complete"));
		SetCallState(CNS_COMPLETE);
	}
	
	CConfObject *pco = ::GetConfObject();
	if (NULL != pco)
	{
		// add member if we are calling with A/V
		BOOL fAddMember = m_dwFlags & (CRPCF_AUDIO | CRPCF_VIDEO);

		pco->OnH323Connected(pConnection, m_dwFlags, fAddMember, GUID_NULL);
	}

	DebugExitBOOL(COutgoingCall::OnH323Connected, bRet);
	return bRet;
}

BOOL COutgoingCall::OnH323Disconnected(IH323Endpoint * pConnection)
{
	DebugEntry(COutgoingCall::OnH323Disconnected);

	BOOL bRet = TRUE;
	
	ASSERT(m_pH323Connection == pConnection);

	HRESULT hSummary = m_pH323Connection->GetSummaryCode();
	// Check summary code for gatekeeper-caused disconnect
	// Note: this applies only to MY gatekeeper, not the callee's gatekeeper
	if(CUSTOM_FACILITY(hSummary) == FACILITY_GKIADMISSION)
	{
		DWORD dwRejectReason;
		dwRejectReason = CUSTOM_FACILITY_CODE(hSummary);
		
		// should the T.120 call be placed anyway?
		switch (dwRejectReason)
		{
			case ARJ_CALLEE_NOT_REGISTERED:
				m_cnResult = CN_RC_GK_CALLEE_NOT_REGISTERED;
				break;
			case ARJ_TIMEOUT:
				m_cnResult = CN_RC_GK_TIMEOUT;
				break;
			case ARJ_INVALID_PERMISSION:
			case ARJ_REQUEST_DENIED:
			case ARJ_UNDEFINED:
			case ARJ_CALLER_NOT_REGISTERED:
			case ARJ_ROUTE_TO_GK:
			case ARJ_INVALID_ENDPOINT_ID:
			case ARJ_RESOURCE_UNAVAILABLE:
			case ARJ_SECURTY_DENIAL:
			case ARJ_QOS_CONTROL_NOT_SUPPORTED:
			case ARJ_INCOMPLETE_ADDRESS:
			default:
				m_cnResult = CN_RC_GK_REJECTED;
				break;
		}

		SetCallState(CNS_COMPLETE);
	}
	else if (CNS_CONNECTING_H323 == m_cnState)
	{
		// attempted an H.323 call without success.

		TRACE_OUT(("COutgoingCall - our leading H323 call ended -> complete"));

		// check for cases of remote refusing the call
		switch (hSummary)
		{
			case CCR_REMOTE_DISCONNECT:
			case CCR_REMOTE_REJECTED:
				m_cnResult = CN_RC_CONFERENCE_INVITE_DENIED;
				SetCallState(CNS_COMPLETE);
				break;
			case CCR_LOCAL_DISCONNECT:
				// cancelled by user, do not report error
				m_cnResult = CN_RC_LOCAL_CANCELED;
				m_fCanceled = TRUE;
				SetCallState(CNS_COMPLETE);
				break;
			case CCR_GK_NO_RESOURCES:
				// callee's gatekeeper would not let callee answer
				// do the same as CCR_REMOTE_REJECTED
				// as a temporary measure !!!!
				m_cnResult = CN_RC_CONFERENCE_INVITE_DENIED;
				SetCallState(CNS_COMPLETE);
				break;
			case CCR_REMOTE_SECURITY_DENIED:
				if (m_pConfObject->IsConfObjSecure())
				{
					m_cnResult = CN_RC_CONNECT_REMOTE_NO_SECURITY;
				}
				else
				{
					m_cnResult = CN_RC_CONNECT_REMOTE_REQUIRE_SECURITY;
				}
				SetCallState(CNS_COMPLETE);
				break;
			case CCR_REMOTE_BUSY:
				if (m_pConfObject->IsConferenceActive())
				{
					m_cnResult = CN_RC_INVITE_DENIED_REMOTE_IN_CONF;
					SetCallState(CNS_COMPLETE);
					break;
				}
				// else fall through

			default:
				if ((m_dwFlags & CRPCF_DATA) &&
					(m_addrType != NM_ADDR_H323_GATEWAY) &&
					(m_addrType != NM_ADDR_PSTN) &&
					(m_addrType != NM_ADDR_ALIAS_ID) &&
					(m_addrType != NM_ADDR_ALIAS_E164))
				{
					// The endpoint is not there, not listening for H.323 calls, or is busy,
					// and the address is a resolvable type (not an H.323 alias or E.164 number)
					// go back into the T.120 call state path
					CNSTATUS cnResult = StartT120Call();
					if (CN_RC_NOERROR != cnResult)
					{
						m_cnResult = cnResult;
						SetCallState(CNS_COMPLETE);
						bRet = FALSE;
					}
				}
				else
				{
					switch (hSummary)
					{
						case CCR_REMOTE_BUSY:
							m_cnResult = CN_RC_INVITE_DENIED_REMOTE_IN_CONF;
							break;
						case CCR_REMOTE_MEDIA_ERROR:
							m_cnResult = CN_RC_AUDIO_IN_USE_REMOTE;
							break;
						case CCR_LOCAL_MEDIA_ERROR:
							m_cnResult = CN_RC_AUDIO_IN_USE_LOCAL;
							break;
						case CCR_GK_NO_RESOURCES:
							m_cnResult = CN_RC_GK_REJECTED;
							break;
						default:
							m_cnResult = CN_RC_AUDIO_CONNECT_FAILED;
							break;
					}
					SetCallState(CNS_COMPLETE);
				}
				break;
		}
	}
	else if (CNS_WAITING_T120_OPEN == m_cnState)
	{
		TRACE_OUT(("COutgoingCall - OnH323Disconnected received -> call is canceled"));
		m_cnResult = CN_RC_CONFERENCE_INVITE_DENIED;
		SetCallState(CNS_COMPLETE);
	}
	else
	{
		TRACE_OUT(("COutgoingCall - OnH323Disconnected received -> canceling call"));
		ASSERT(m_pConfObject);

		if (NULL != m_hRequest)
		{
			REQUEST_HANDLE hRequest = m_hRequest;
			m_hRequest = NULL;
			m_pConfObject->CancelInvite(hRequest);
		}

		if (m_pConfObject->IsConferenceActive())
		{
			// Issue "soft" leave attempt (to allow auto-terminate)
			m_pConfObject->LeaveConference(FALSE);
		}
	}

	// the connection may have been released due to the LeaveConference above
	// bug 3996
	if (m_pH323Connection)
	{
		m_pH323Connection->Release();
		m_pH323Connection = NULL;
	}

	DebugExitBOOL(COutgoingCall::OnH323Disconnected, bRet);
	return bRet;
}

BOOL COutgoingCall::OnT120ChannelOpen(ICommChannel *pIChannel, DWORD dwStatus)
{
	DebugEntry(COutgoingCall::OnT120ChannelOpen);

	BOOL bRet = TRUE;

	// sometimes we get an extra T120 channel open
	// this is most likely due the master/slave anomolies that
	// venkatg discovered.
	if (CNS_WAITING_T120_OPEN == m_cnState)
	{
		switch(dwStatus)
		{
			case CHANNEL_OPEN:
				{
					// start the T.120 part of the call
					// get the negotiated address
					SOCKADDR_IN sin_T120;
					HRESULT hr = pIChannel->GetRemoteAddress(&sin_T120);
					delete m_pszAddr;  // we won't be needing this anymore

					TCHAR szAddress[256];  // allow plenty of room for conversion from numberic to string
					wsprintf(szAddress, "%s:%d", inet_ntoa(sin_T120.sin_addr), ntohs(sin_T120.sin_port));
					m_pszAddr =  PszAlloc(szAddress);

					CNSTATUS cnResult = StartT120Call();
					if (CN_RC_NOERROR != cnResult)
					{
						m_cnResult = cnResult;
						SetCallState(CNS_COMPLETE);
					}
				}
				break;
			case CHANNEL_CLOSED:	
				// if the T.120 channel is being closed
				// the H.323 call is going down, so don't continue waiting for
				// T.120 to connect!
				m_cnResult = CN_RC_CONNECT_FAILED;
				SetCallState(CNS_COMPLETE);

				if (NULL != m_hRequest)
				{
					REQUEST_HANDLE hRequest = m_hRequest;
					m_hRequest = NULL;
					ASSERT(m_pConfObject);
					m_pConfObject->CancelInvite(hRequest);
				}
				break;
				
			case CHANNEL_NO_CAPABILITY:
			case CHANNEL_REJECTED:
			case CHANNEL_OPEN_ERROR:
			default:
				m_cnResult = CN_RC_CONNECT_FAILED;
				SetCallState(CNS_COMPLETE);
				break;
		}
	}

	DebugExitBOOL(COutgoingCall::OnT120ChannelOpen, bRet);
	return bRet;
}


void COutgoingCall::CallComplete()
{
	DebugEntry(COutgoingCall::CallComplete);

	// If this fails, we are being destructed unexpectedly
	
	ASSERT( (m_cnState == CNS_IDLE) ||
			(m_cnState == CNS_COMPLETE));

	// The request handle should have been reset
	ASSERT(NULL == m_hRequest);

	// make sure that the H323 connection is released
	if (m_pH323Connection)
	{
		if (!IsDataOnly() &&
			((CN_RC_TRANSPORT_FAILURE == m_cnResult) ||
			(CN_RC_QUERY_FAILED == m_cnResult) ||
			(CN_RC_CONNECT_FAILED == m_cnResult)))
		{
			m_cnResult = CN_RC_NOERROR;
		}

		if (CN_RC_NOERROR != m_cnResult)
		{
			m_pH323Connection->Disconnect();
		}
		m_pH323Connection->Release();
		m_pH323Connection = NULL;
	}

	if (!FCanceled() && (CN_RC_NOERROR != m_cnResult))
	{
		ReportError(m_cnResult);
	}

	NM_CALL_STATE state;
	GetState(&state);
	NotifySink((PVOID) state, OnNotifyCallStateChanged);

	TRACE_OUT(("ConfNode destroying addr %s", m_pszAddr));
	DebugExitVOID(COutgoingCall::CallComplete);
}

BOOL COutgoingCall::ReportError(CNSTATUS cns)
{
	DebugEntry(COutgoingCall::ReportError);
	TRACE_OUT(("CNSTATUS 0x%08x", cns));
	
	NotifySink((PVOID)cns, OnNotifyCallError);

	DebugExitBOOL(COutgoingCall::ReportError, TRUE);
	return TRUE;
}

CNSTATUS COutgoingCall::StartT120Call()
{
	DebugEntry(COutgoingCall::StartT120Call);
	
	CNSTATUS cnResult = CN_RC_NOERROR;

	if (NULL == m_bstrConfToJoin)
	{
		// conference name not specified
		// need to start out with a QueryRemote
		SetCallState(CNS_QUERYING_REMOTE);

		ASSERT(g_pNodeController);

		HRESULT hr = g_pNodeController->QueryRemote(this, m_pszAddr,
			m_pConfObject->IsConfObjSecure(),
			m_pConfObject->IsConferenceActive());
		if (S_OK != hr)
		{
			cnResult = CN_RC_QUERY_FAILED;
		}
	}
	else
	{
		ASSERT(m_pConfObject);
		// conference name has been specified
		// time to do a JoinConference
		SetCallState(CNS_JOINING_REMOTE);

		HRESULT hr = m_pConfObject->JoinConference(	m_bstrConfToJoin,
													m_bstrPassword,
													m_pszAddr,
													m_bstrUserString);
		if (S_OK != hr)
		{
			cnResult = CN_RC_JOIN_FAILED;
		}
	}
	
	DebugExitINT(COutgoingCall::StartT120Call, cnResult);
	return cnResult;
}


VOID COutgoingCall::SetCallState(CNODESTATE cnState)
{
	NM_CALL_STATE stateOld;
	NM_CALL_STATE stateNew;
	GetState(&stateOld);

	m_cnState = cnState;

	// completion state will be fired off later
	if (CNS_COMPLETE != cnState)
	{
		GetState(&stateNew);
		if (stateOld != stateNew)
		{
			NotifySink((PVOID) stateNew, OnNotifyCallStateChanged);
		}
	}
}

HRESULT COutgoingCall::_Cancel(BOOL fLeaving)
{
	DebugEntry(COutgoingCall::Cancel);

	BOOL fAbortT120 = (m_cnState != CNS_COMPLETE);

	if (fAbortT120)
	{
		m_fCanceled = TRUE;

		// Abort T.120 Call:


		// Attempt to make this transition regardless of our
		// current state:
		SetCallState(CNS_COMPLETE);

		ASSERT(m_pConfObject);

		if (NULL != m_hRequest)
		{
			REQUEST_HANDLE hRequest = m_hRequest;
			m_hRequest = NULL;
			m_pConfObject->CancelInvite(hRequest);
		}

		if (!fLeaving && m_pConfObject->IsConferenceActive())
		{
			HRESULT hr = m_pConfObject->LeaveConference(FALSE);
			if (FAILED(hr))
			{
				WARNING_OUT(("Couldn't leave after disconnecting"));
			}
		}
	}

	if (NULL != m_pH323Connection)
	{
		m_fCanceled = TRUE;

		// Abort H.323 Call:
		m_pH323Connection->Disconnect();
	}

	DebugExitULONG(COutgoingCall::Abort, m_cnResult);

	return CN_RC_NOERROR ? S_OK : E_FAIL;
}

STDMETHODIMP_(ULONG) COutgoingCall::AddRef(void)
{
	return RefCount::AddRef();
}
	
STDMETHODIMP_(ULONG) COutgoingCall::Release(void)
{
	return RefCount::Release();
}

HRESULT STDMETHODCALLTYPE COutgoingCall::QueryInterface(REFIID riid, PVOID *ppv)
{
	HRESULT hr = S_OK;

	if ((riid == IID_INmCall) || (riid == IID_IUnknown))
	{
		*ppv = (INmCall *)this;
		ApiDebugMsg(("COutgoingCall::QueryInterface()"));
	}
	else if (riid == IID_IConnectionPointContainer)
	{
		*ppv = (IConnectionPointContainer *) this;
		ApiDebugMsg(("CNmCall::QueryInterface(): Returning IConnectionPointContainer."));
	}
	else
	{
		hr = E_NOINTERFACE;
		*ppv = NULL;
		ApiDebugMsg(("COutgoingCall::QueryInterface(): Called on unknown interface."));
	}

	if (S_OK == hr)
	{
		AddRef();
	}

	return hr;
}

HRESULT COutgoingCall::IsIncoming(void)
{
	return S_FALSE;
}

HRESULT COutgoingCall::GetState(NM_CALL_STATE *pState)
{
	HRESULT hr = E_POINTER;

	if (NULL != pState)
	{
		if (FCanceled())
		{
			*pState = NM_CALL_CANCELED;
		}
		else
		{
			switch (m_cnState)
			{
				case CNS_IDLE:
					*pState = NM_CALL_INIT;
					break;

				case CNS_SEARCHING:
					*pState = NM_CALL_SEARCH;
					break;

				case CNS_CONNECTING_H323:
				case CNS_WAITING_T120_OPEN:
				case CNS_QUERYING_REMOTE:
				case CNS_CREATING_LOCAL:
				case CNS_INVITING_REMOTE:
				case CNS_JOINING_REMOTE:
					*pState = NM_CALL_WAIT;
					break;

				case CNS_COMPLETE:
					switch (m_cnResult)
					{
					case CN_RC_NOERROR:
						*pState = NM_CALL_ACCEPTED;
						break;
					case CN_RC_CONFERENCE_JOIN_DENIED:
					case CN_RC_CONFERENCE_INVITE_DENIED:
					case CN_RC_CONFERENCE_DOES_NOT_EXIST:
					case CN_RC_AUDIO_CONNECT_FAILED:
					case CN_RC_GK_CALLEE_NOT_REGISTERED:
					case CN_RC_GK_TIMEOUT:
					case CN_RC_GK_REJECTED:
					case CN_RC_GK_NOT_REGISTERED:
					case CN_RC_CONNECT_REMOTE_NO_SECURITY:
					case CN_RC_CONNECT_REMOTE_DOWNLEVEL_SECURITY:
					case CN_RC_CONNECT_REMOTE_REQUIRE_SECURITY:
					case CN_RC_TRANSPORT_FAILURE:
					case CN_RC_QUERY_FAILED:
					case CN_RC_CONNECT_FAILED:
						*pState = NM_CALL_REJECTED;
						break;

					case CN_RC_ALREADY_IN_CONFERENCE:
					case CN_RC_CANT_INVITE_MCU:
					case CN_RC_CANT_JOIN_ALREADY_IN_CALL:
					case CN_RC_INVITE_DENIED_REMOTE_IN_CONF:
					case CN_RC_REMOTE_PLACING_CALL:
					case CN_RC_ALREADY_IN_CONFERENCE_MCU:
					case CN_RC_INVALID_PASSWORD:
					default:
						*pState = NM_CALL_CANCELED;
						break;
					}
					break;

				default:
					*pState = NM_CALL_INVALID;
					break;
			}
		}

		hr = S_OK;
	}
	return hr;
}

HRESULT COutgoingCall::GetName(BSTR * pbstrName)
{
	if (NULL == pbstrName)
		return E_POINTER;

	*pbstrName = SysAllocString(m_bstrName);
	return (*pbstrName ? S_OK : E_FAIL);
}


HRESULT COutgoingCall::GetAddr(BSTR *pbstrAddr, NM_ADDR_TYPE *puType)
{
	if ((NULL == pbstrAddr) || (NULL == puType))
		return E_POINTER;

	*pbstrAddr = SysAllocString(CUSTRING(m_pszAddr));
	*puType = m_addrType;

	return *pbstrAddr ? S_OK : E_FAIL;
}

HRESULT COutgoingCall::GetUserData(REFGUID rguid, BYTE **ppb, ULONG *pcb)
{
	return E_NOTIMPL;
}

HRESULT COutgoingCall::GetConference(INmConference **ppConference)
{
	HRESULT hr = E_POINTER;

	if (NULL != ppConference)
	{
		*ppConference = m_pConfObject;
		return S_OK;
	}

	return hr;
}

HRESULT COutgoingCall::Accept(void)
{
	return E_UNEXPECTED;
}

HRESULT COutgoingCall::Reject(void)
{
	return E_UNEXPECTED;
}

HRESULT COutgoingCall::Cancel(void)
{
	DebugEntry(COutgoingCall::Cancel);

	AddRef();		// protect against Release() while processing
					// disconnect related indications & callbacks

	HRESULT hr = _Cancel(FALSE);
	
	if (FIsComplete())
	{
		COprahNCUI *pOprahNCUI = COprahNCUI::GetInstance();
		ASSERT(NULL !=pOprahNCUI);
		pOprahNCUI->OnOutgoingCallCanceled(this);
	}

	DebugExitULONG(COutgoingCall::Abort, m_cnResult);

	Release();

	return hr;
}

/*	O N  N O T I F Y  C A L L  E R R O R  */
/*-------------------------------------------------------------------------
	%%Function: OnNotifyCallError
	
-------------------------------------------------------------------------*/
HRESULT OnNotifyCallError(IUnknown *pCallNotify, PVOID pv, REFIID riid)
{
	ASSERT(NULL != pCallNotify);
	CNSTATUS cnStatus = (CNSTATUS)((DWORD_PTR)pv);
	switch (cnStatus)
	{
		case CN_RC_ALREADY_IN_CONFERENCE:
		case CN_RC_CANT_INVITE_MCU:
		case CN_RC_CANT_JOIN_ALREADY_IN_CALL:
		case CN_RC_INVITE_DENIED_REMOTE_IN_CONF:
		case CN_RC_REMOTE_PLACING_CALL:
		case CN_RC_ALREADY_IN_CONFERENCE_MCU:
			((INmCallNotify*)pCallNotify)->NmUI(CONFN_CALL_IN_CONFERENCE);
			break;
		case CN_RC_CONFERENCE_JOIN_DENIED:
		case CN_RC_CONFERENCE_INVITE_DENIED:
		case CN_RC_CONFERENCE_DOES_NOT_EXIST:
		case CN_RC_GK_CALLEE_NOT_REGISTERED:
		case CN_RC_GK_TIMEOUT:
		case CN_RC_GK_REJECTED:
		case CN_RC_GK_NOT_REGISTERED:
		case CN_RC_CONNECT_REMOTE_NO_SECURITY:
		case CN_RC_CONNECT_REMOTE_DOWNLEVEL_SECURITY:
		case CN_RC_CONNECT_REMOTE_REQUIRE_SECURITY:
			((INmCallNotify*)pCallNotify)->NmUI(CONFN_CALL_IGNORED);
			break;
		case CN_RC_CONNECT_FAILED:
		case CN_RC_AUDIO_CONNECT_FAILED:
			((INmCallNotify*)pCallNotify)->NmUI(CONFN_CALL_FAILED);
			break;
		default:
			break;
	}

	if (IID_INmCallNotify2 == riid)
	{
		((INmCallNotify2*)pCallNotify)->CallError(cnStatus);
	}
	return S_OK;
}

/*	O N  N O T I F Y  R E M O T E  C O N F E R E N C E	*/
/*-------------------------------------------------------------------------
	%%Function: OnNotifyRemoteConference
	
-------------------------------------------------------------------------*/
HRESULT OnNotifyRemoteConference(IUnknown *pCallNotify, PVOID pv, REFIID riid)
{
	REMOTE_CONFERENCE *prc = (REMOTE_CONFERENCE *)pv;

	// WARNING: pwszConfName is an PWSTR array, not a BSTR

	ASSERT(NULL != pCallNotify);
	((INmCallNotify2*)pCallNotify)->RemoteConference(prc->fMCU,
		(BSTR *) prc->pwszConfNames, prc->pbstrConfToJoin);
	return S_OK;
}

/*	O N  N O T I F Y  R E M O T E  P A S S W O R D	*/
/*-------------------------------------------------------------------------
	%%Function: OnNotifyRemotePassword
	
-------------------------------------------------------------------------*/
HRESULT OnNotifyRemotePassword(IUnknown *pCallNotify, PVOID pv, REFIID riid)
{
	REMOTE_PASSWORD *prp = (REMOTE_PASSWORD *)pv;

	ASSERT(NULL != pCallNotify);
	((INmCallNotify2*)pCallNotify)->RemotePassword(prp->bstrConference, prp->pbstrPassword, prp->pbRemoteCred, prp->cbRemoteCred, prp->fIsService);
	return S_OK;
}

COutgoingCallManager::COutgoingCallManager()
{
}

COutgoingCallManager::~COutgoingCallManager()
{
	// Empty the call list:
	while (!m_CallList.IsEmpty())
	{
		COutgoingCall* pCall = (COutgoingCall*) m_CallList.RemoveHead();
		// Shouldn't have any NULL entries:
		ASSERT(pCall);
		pCall->Release();
	}
}

UINT COutgoingCallManager::GetCallCount()
{
	UINT nNodes = 0;
	POSITION pos = m_CallList.GetHeadPosition();
	while (pos)
	{
		nNodes++;
		m_CallList.GetNext(pos);
	}
	return nNodes;
}

COutgoingCall* COutgoingCallManager::FindCall(IH323Endpoint * lpConnection)
{
	POSITION pos = m_CallList.GetHeadPosition();
	while (pos)
	{
		COutgoingCall* pCall = (COutgoingCall*) m_CallList.GetNext(pos);

		if ((NULL != pCall) &&
			(pCall->GetH323Connection() == lpConnection))
		{
			return pCall;
		}
	}
	return NULL;
}

BOOL COutgoingCallManager::MatchActiveCallee(LPCTSTR pszDest, BSTR bstrAlias, BSTR bstrConference)
{
	// Try to find a matching callee
	POSITION pos = m_CallList.GetHeadPosition();
	while (pos)
	{
		COutgoingCall* pCall = (COutgoingCall*) m_CallList.GetNext(pos);

		if (NULL != pCall)
		{
			if (pCall->MatchActiveCallee(pszDest, bstrAlias, bstrConference))
			{
				return TRUE;
			}
		}
	}
	return FALSE;
}

HRESULT COutgoingCallManager::Call(
    INmCall **ppCall,
	COprahNCUI* pManager,
    DWORD dwFlags,
    NM_ADDR_TYPE addrType,
    BSTR bstrName,
    BSTR bstrSetup,
    BSTR bstrDest,
    BSTR bstrAlias,
    BSTR bstrURL,
    BSTR bstrConference,
    BSTR bstrPassword,
	BSTR bstrUserString)
{
	DebugEntry(COutgoingCallManager::CallConference);
	HRESULT hr = E_FAIL;
	COutgoingCall* pCall = NULL;
	CConfObject* pConfObject = pManager->GetConfObject();
	
	if (NULL != ppCall)
	{
		*ppCall = NULL;
	}

	if (MatchActiveCallee(CUSTRING(bstrDest), bstrAlias, bstrConference))
	{
		hr = NM_CALLERR_ALREADY_CALLING;
	}
	else if (pConfObject->IsConferenceActive() && (NULL != bstrConference))
	{
		hr= NM_CALLERR_IN_CONFERENCE;	
	}
	else
	{
		if (!pConfObject->IsConferenceActive())
		{
			pConfObject->SetConfSecurity(0 != (CRPCF_SECURE & dwFlags));
		}

        //
        // Check outgoing call settings
        //
        if (pConfObject->GetNumMembers() >= pConfObject->GetConfMaxParticipants())
        {
            ASSERT(pConfObject->GetNumMembers() == pConfObject->GetConfMaxParticipants());
            WARNING_OUT(("Outgoing call denied, reached limit of participants"));
            goto END_CALL;
        }

        if ((pConfObject->IsHosting() != S_OK) &&
            !(pConfObject->GetConfAttendeePermissions() & NM_PERMIT_OUTGOINGCALLS))
        {
            WARNING_OUT(("Outgoing call denied, not permitted by meeting settings"));
            goto END_CALL;
        }

		pCall = new COutgoingCall(	pConfObject,
									dwFlags,
									addrType,
									bstrName,
									bstrDest,
									bstrAlias,
									bstrConference,
									bstrPassword,
									bstrUserString);
		if (NULL != pCall)
		{
			m_CallList.AddTail(pCall);

			if (NULL != ppCall)
			{
				pCall->AddRef();

				// This MUST be set before OnNotifyCallCreated
				*ppCall = pCall;
			}

			pCall->AddRef();

			pManager->OnOutgoingCallCreated(pCall);

			pCall->PlaceCall();

			if (pCall->FIsComplete())
			{
				RemoveFromList(pCall);
			}

			pCall->Release();

			// let the caller know that we successfully created the call
			// any error will be reported asynchronously
			hr = S_OK;
		}
	}

END_CALL:
	DebugExitHRESULT(COutgoingCallManager::CallConference, hr);
	return hr;
}

BOOL COutgoingCallManager::RemoveFromList(COutgoingCall* pCall)
{
	DebugEntry(COutgoingCallManager::RemoveFromList);
	ASSERT(pCall);
	BOOL bRet = FALSE;

	POSITION pos = m_CallList.GetPosition(pCall);
	if (NULL != pos)
	{
		m_CallList.RemoveAt(pos);

		pCall->CallComplete();
		pCall->Release();

		bRet = TRUE;
	}
	else
	{
		WARNING_OUT(("COutgoingCallManager::RemoveFromList() could not match call"));
	}

	DebugExitBOOL(COutgoingCallManager::RemoveFromList, bRet);
	return bRet;
}

BOOL COutgoingCallManager::OnH323Connected(IH323Endpoint* lpConnection)
{
	DebugEntry(COutgoingCallManager::OnH323Connected);

	BOOL fFound = FALSE;

	COutgoingCall* pCall = FindCall(lpConnection);
	if (pCall)
	{
		fFound = TRUE;

		pCall->AddRef();
		pCall->OnH323Connected(lpConnection);
		if (pCall->FIsComplete())
		{
			RemoveFromList(pCall);
		}
		pCall->Release();
	}
	
	DebugExitBOOL(COutgoingCallManager::OnH323Connected, fFound);

	return fFound;
}


BOOL COutgoingCallManager::OnH323Disconnected(IH323Endpoint * lpConnection)
{
	DebugEntry(COutgoingCallManager::OnH323Disconnected);

	BOOL fFound = FALSE;

	COutgoingCall* pCall = FindCall(lpConnection);
	if (pCall)
	{
		fFound = TRUE;

		pCall->AddRef();
		pCall->OnH323Disconnected(lpConnection);
		if (pCall->FIsComplete())
		{
			RemoveFromList(pCall);
		}
		pCall->Release();
	}

	DebugExitBOOL(COutgoingCallManager::OnH323Disconnected, fFound);

	return fFound;
}

VOID COutgoingCallManager::OnT120ChannelOpen(ICommChannel *pIChannel, IH323Endpoint * lpConnection, DWORD dwStatus)
{
	DebugEntry(COutgoingCallManager::OnT120ChannelOpen);

	COutgoingCall* pCall = FindCall(lpConnection);
	if (pCall)
	{
		pCall->AddRef();
		pCall->OnT120ChannelOpen(pIChannel, dwStatus);
		if (pCall->FIsComplete())
		{
			RemoveFromList(pCall);
		}
		pCall->Release();
	}

	DebugExitVOID(COutgoingCallManager::OnT120ChannelOpen);
}

VOID COutgoingCallManager::OnConferenceStarted(CONF_HANDLE hConference, HRESULT hResult)
{
	DebugEntry(COutgoingCallManager::OnConferenceStarted);

	// Tell all ConfNode's that a conference has started
	POSITION pos = m_CallList.GetHeadPosition();
	while (pos)
	{
		COutgoingCall* pCall = (COutgoingCall*) m_CallList.GetNext(pos);

		if (NULL != pCall)
		{
			pCall->AddRef();
			pCall->OnConferenceStarted(hConference, hResult);
			if (pCall->FIsComplete())
			{
				RemoveFromList(pCall);
			}
			pCall->Release();
		}
	}

	DebugExitVOID(COutgoingCallManager::OnConferenceStarted);
}

VOID COutgoingCallManager::OnQueryRemoteResult(PVOID pvCallerContext,
										HRESULT hResult,
										BOOL fMCU,
										PWSTR* ppwszConferenceNames,
										PT120PRODUCTVERSION pVersion,
										PWSTR* ppwszConfDescriptors)
{
	DebugEntry(COutgoingCallManager::OnQueryRemoteResult);

	POSITION pos = m_CallList.GetHeadPosition();
	while (pos)
	{
		COutgoingCall* pCall = (COutgoingCall*) m_CallList.GetNext(pos);

		// Notify the node that issued the query:
		
		if ((COutgoingCall*) pvCallerContext == pCall)
		{
			pCall->AddRef();
			pCall->OnQueryRemoteResult(	hResult,
										fMCU,
										ppwszConferenceNames,
										pVersion,
										ppwszConfDescriptors);
			if (pCall->FIsComplete())
			{
				RemoveFromList(pCall);
			}
			pCall->Release();
			break;
		}
	}
	
	DebugExitVOID(COutgoingCallManager::OnQueryRemoteResult);
}

VOID COutgoingCallManager::OnInviteResult(	CONF_HANDLE hConference,
											REQUEST_HANDLE hRequest,
											UINT uNodeID,
											HRESULT hResult,
											PT120PRODUCTVERSION pVersion)
{
	DebugEntry(COutgoingCallManager::OnInviteResult);

	POSITION pos = m_CallList.GetHeadPosition();
	while (pos)
	{
		COutgoingCall* pCall = (COutgoingCall*) m_CallList.GetNext(pos);

		if ((NULL != pCall) &&
			(pCall->GetCurrentRequestHandle() == hRequest))
		{
			pCall->AddRef();
			pCall->OnInviteResult(hResult, uNodeID);
			if (pCall->FIsComplete())
			{
				RemoveFromList(pCall);
			}
			pCall->Release();
			break;
		}
	}

	DebugExitVOID(COutgoingCallManager::OnInviteResult);
}

VOID COutgoingCallManager::OnConferenceEnded(CONF_HANDLE hConference)
{
	DebugEntry(COutgoingCallManager::OnConferenceEnded);

	// Tell all ConfNode's that a conference has started
	POSITION pos = m_CallList.GetHeadPosition();
	while (pos)
	{
		COutgoingCall* pCall = (COutgoingCall*) m_CallList.GetNext(pos);

		if (NULL != pCall)
		{
			pCall->AddRef();
			pCall->OnConferenceEnded();
			if (pCall->FIsComplete())
			{
				RemoveFromList(pCall);
			}
			pCall->Release();
		}
	}

	DebugExitVOID(COutgoingCallManager::OnConferenceEnded);
}

VOID COutgoingCallManager::CancelCalls()
{
	DebugEntry(COutgoingCallManager::CancelCalls);

	// Tell all ConfNode's that a conference has started
	POSITION pos = m_CallList.GetHeadPosition();
	while (pos)
	{
		COutgoingCall* pCall = (COutgoingCall*) m_CallList.GetNext(pos);

		if (NULL != pCall)
		{
			pCall->AddRef();
			pCall->_Cancel(TRUE);
			if (pCall->FIsComplete())
			{
				RemoveFromList(pCall);
			}
			pCall->Release();
		}
	}

	DebugExitVOID(COutgoingCallManager::CancelCalls);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\core\icawrap.h ===
#ifndef _ICAWRAP_H_
#define _ICAWRAP_H_

#include <icaapi.h>

class CICA : public RefCount
{
protected:
	static CICA* m_pThis;
	PFnICA_Start m_pfnICA_Start;
	PFnICA_Stop m_pfnICA_Stop;
	PFnICA_DisplayPanel m_pfnICA_DisplayPanel;
	PFnICA_RemovePanel m_pfnICA_RemovePanel;
	PFnICA_SetOptions m_pfnICA_SetOptions;

	HANDLE m_hICA_General;
	HANDLE m_hICA_Audio;
	HANDLE m_hICA_Video;
	HANDLE m_hICA_SetOptions;
	
	HWND m_hWndICADlg;

	CICA();
	~CICA();
	
	BOOL Initialize();

public:
	static CICA* Instance();
	
	STDMETHODIMP_(ULONG) AddRef(void);
	STDMETHODIMP_(ULONG) Release(void);

	BOOL Start();
	VOID Stop();

	BOOL IsRunning() { return NULL != m_hWndICADlg; }
	HWND GetHwnd()   { return m_hWndICADlg; }

	VOID SetInTray(BOOL fInTray);
};

#endif	// _ICAWRAP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\core\icawrap.cpp ===
// File: icawrap.cpp

#include "precomp.h"

#include "icawrap.h"

CICA* CICA::m_pThis = NULL;


CICA::CICA() :
	RefCount(NULL),
	m_pfnICA_Start(NULL),
	m_pfnICA_Stop(NULL),
	m_pfnICA_DisplayPanel(NULL),
	m_pfnICA_RemovePanel(NULL),
	m_pfnICA_SetOptions(NULL),
	m_hICA_General(NULL),
	m_hICA_Audio(NULL),
	m_hICA_Video(NULL),
	m_hICA_SetOptions(NULL),
	m_hWndICADlg(NULL)
{
}

CICA::~CICA()
{
	m_pThis = NULL;
}

CICA* CICA::Instance()
{
	if (NULL == m_pThis)
	{
		m_pThis = new CICA;
		if (!m_pThis->Initialize())
		{
			WARNING_OUT(("ICA Failed to initialize"));
			delete m_pThis;
			m_pThis = NULL;
		}
	}
	else
	{
		m_pThis->AddRef();
	}
	
	return m_pThis;
}

BOOL CICA::Initialize()
{
	HINSTANCE hInst = NmLoadLibrary(SZ_ICADLL);
	if (NULL == hInst)
	{
		return FALSE;
	}

	m_pfnICA_Start = (PFnICA_Start)GetProcAddress(hInst, TEXT("ICA_Start"));
	if (NULL == m_pfnICA_Start)
	{
		goto ErrorLeave;
	}

	m_pfnICA_Stop = (PFnICA_Stop)GetProcAddress(hInst, TEXT("ICA_Stop"));
	if( NULL == m_pfnICA_Stop)
	{
		goto ErrorLeave;
	}

	m_pfnICA_DisplayPanel =
		(PFnICA_DisplayPanel)GetProcAddress(hInst, TEXT("ICA_DisplayPanel"));
	if(NULL == m_pfnICA_DisplayPanel)
	{
		goto ErrorLeave;
	}
	
	m_pfnICA_RemovePanel =
		(PFnICA_RemovePanel)GetProcAddress(hInst, TEXT("ICA_RemovePanel"));
	if(NULL == m_pfnICA_RemovePanel)
	{
		goto ErrorLeave;
	}

	m_pfnICA_SetOptions =
		(PFnICA_SetOptions)GetProcAddress(hInst, TEXT("ICA_SetOptions"));
	if(NULL == m_pfnICA_SetOptions)
	{
		goto ErrorLeave;
	}
	return TRUE;

ErrorLeave:
	FreeLibrary(hInst);
	return FALSE;
}
	

BOOL CICA::Start()
{
	if (IsRunning())
	{
		return TRUE;
	}

	LPSTR pszHelpFile = SZ_ICAHELP;

	ASSERT(m_pfnICA_Start);
	if (S_OK != m_pfnICA_Start(TEXT(""), TEXT("RRCM.DLL"), &m_hWndICADlg))
	{
		return FALSE;
	}

	ASSERT(m_pfnICA_DisplayPanel);
	if (S_OK != m_pfnICA_DisplayPanel(
		NULL,					// pszModuleName
		"ICA_GENERAL_PANEL",	// pzName
		pszHelpFile,			// pszHelpFile
		NULL,
		&m_hICA_General))
	{
		m_hICA_General = NULL;
		goto ErrorLeave;
	}

	if (S_OK != m_pfnICA_DisplayPanel(
		NULL,					// pszModuleName
		"NM2.0_H323_AUDIO",		// pzName
		pszHelpFile,			// pszHelpFile
		NULL,
		&m_hICA_Audio))
	{
		m_hICA_Audio = NULL;
		goto ErrorLeave;
	}

	if (S_OK != m_pfnICA_DisplayPanel(
		NULL,					// pszModuleName
		"NM2.0_H323_VIDEO",		// pzName
		pszHelpFile,			// pszHelpFile
		NULL,
		&m_hICA_Video))
	{
		m_hICA_Video = NULL;
		goto ErrorLeave;
	}

#if 0
	RegEntry re( AUDIO_KEY, HKEY_CURRENT_USER );
	UINT uSoundCardCaps = re.GetNumber(REGVAL_SOUNDCARDCAPS,SOUNDCARD_NONE);

	BOOL fFullDuplex = FALSE;
	ASSERT(ISSOUNDCARDPRESENT(uSoundCardCaps));
	if (ISSOUNDCARDFULLDUPLEX(uSoundCardCaps))
	{					
		fFullDuplex = (BOOL)
			( re.GetNumber(REGVAL_FULLDUPLEX,0) == FULLDUPLEX_ENABLED );
	}					

	ASSERT(g_pfnICA_SetOptions);
	if (S_OK != m_pfnICA_SetOptions( (fFullDuplex ? ICA_SET_FULL_DUPLEX : ICA_SET_HALF_DUPLEX)))
	{
		m_hICA_SetOptions = NULL;
		goto ErrorLeave;
	}
#endif // 0
	
	// normal return path
	return TRUE;

ErrorLeave:
	Stop();
	return FALSE;
}

VOID CICA::Stop()
{
	ASSERT(m_hWndICADlg);

	ASSERT(m_pfnICA_RemovePanel);
	if (NULL != m_hICA_General)
	{
		m_pfnICA_RemovePanel(m_hICA_General);
		m_hICA_General = NULL;
	}
	
	if (NULL != m_hICA_Audio)
	{
		m_pfnICA_RemovePanel(m_hICA_Audio);
		m_hICA_Audio = NULL;
	}
	
	if (NULL != m_hICA_Video)
	{
		m_pfnICA_RemovePanel(m_hICA_Video);
		m_hICA_Video = NULL;
	}

	ASSERT(m_pfnICA_Stop);
	m_pfnICA_Stop();

	m_hWndICADlg = NULL;
}


VOID CICA::SetInTray(BOOL fInTray)
{
	if (NULL != m_pfnICA_SetOptions)
	{
		UINT uOptions = ICA_DONT_SHOW_TRAY_ICON;

		if (fInTray)
		{
			uOptions = ICA_SHOW_TRAY_ICON;
		}

		m_pfnICA_SetOptions(uOptions);
	}
}

STDMETHODIMP_(ULONG) CICA::AddRef(void)
{
	return RefCount::AddRef();
}
	
STDMETHODIMP_(ULONG) CICA::Release(void)
{
	return RefCount::Release();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\core\ichannel.cpp ===
// File: ichannel.cpp

#include "precomp.h"


/*  O N  N O T I F Y  C H A N N E L  M E M B E R  A D D E D  */
/*-------------------------------------------------------------------------
    %%Function: OnNotifyChannelMemberAdded
    
-------------------------------------------------------------------------*/
HRESULT OnNotifyChannelMemberAdded(IUnknown *pChannelNotify, PVOID pv, REFIID riid)
{
	ASSERT(NULL != pChannelNotify);
	((INmChannelNotify*)pChannelNotify)->MemberChanged(NM_MEMBER_ADDED, (INmMember *) pv);
	return S_OK;
}

/*  O N  N O T I F Y  C H A N N E L  M E M B E R  U P D A T E D  */
/*-------------------------------------------------------------------------
    %%Function: OnNotifyChannelMemberUpdated
    
-------------------------------------------------------------------------*/
HRESULT OnNotifyChannelMemberUpdated(IUnknown *pChannelNotify, PVOID pv, REFIID riid)
{
	ASSERT(NULL != pChannelNotify);
	((INmChannelNotify*)pChannelNotify)->MemberChanged(NM_MEMBER_UPDATED, (INmMember *) pv);
	return S_OK;
}

/*  O N  N O T I F Y  C H A N N E L  M E M B E R  R E M O V E D  */
/*-------------------------------------------------------------------------
    %%Function: OnNotifyChannelMemberRemoved
    
-------------------------------------------------------------------------*/
HRESULT OnNotifyChannelMemberRemoved(IUnknown *pChannelNotify, PVOID pv, REFIID riid)
{
	ASSERT(NULL != pChannelNotify);
	((INmChannelNotify*)pChannelNotify)->MemberChanged(NM_MEMBER_REMOVED, (INmMember *) pv);
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\core\ichannel.h ===
// File: ichannel.h

#ifndef _ICHANNEL_H_
#define _ICHANNEL_H_

HRESULT OnNotifyChannelMemberAdded(IUnknown *pChannelNotify, PVOID pv, REFIID riid);
HRESULT OnNotifyChannelMemberUpdated(IUnknown *pChannelNotify, PVOID pv, REFIID riid);
HRESULT OnNotifyChannelMemberRemoved(IUnknown *pChannelNotify, PVOID pv, REFIID riid);

#endif // _CHANNEL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\core\ichnldat.cpp ===
// File: ichnldat.cpp
//
// INmChannelData
//

#include "precomp.h"

#include <wbguid.h>
#include <confguid.h>
#include "pfnt120.h"
#include "ichnldat.h"

static const IID * g_apiidCP[] =
{
    {&IID_INmChannelDataNotify2},
    {&IID_INmChannelDataNotify},
    {&IID_INmChannelNotify}
};

#define CopyStruct(pDest, pSrc)  CopyMemory(pDest, pSrc, sizeof(*(pDest)))
#define MAX_NM_PEER  256 // Maximum number of NetMeeting Peer applications/users


#ifdef DEBUG  /* T.120 Debug utilities */
LPCTSTR GetGccErrorString(GCCError uErr);
LPCTSTR GetMcsErrorString(MCSError uErr);
LPCTSTR GetGccResultString(UINT uErr);
LPCTSTR GetMcsResultString(UINT uErr);
#else
#define GetGccErrorString(uErr) ""
#define GetMcsErrorString(uErr) ""
#define GetGccResultString(uErr) ""
#define GetMcsResultString(uErr) ""
#endif /* DEBUG */



// code from nm\ui\conf\cuserdta.cpp:
static unsigned char H221IDGUID[5] = {H221GUIDKEY0,
                                      H221GUIDKEY1,
                                      H221GUIDKEY2,
                                      H221GUIDKEY3,
                                      H221GUIDKEY4};
// Create an H.221 application key with a guid
VOID NMINTERNAL CreateH221AppKeyFromGuid(LPBYTE lpb, GUID * pguid)
{
	CopyMemory(lpb, H221IDGUID, sizeof(H221IDGUID));
	CopyMemory(lpb + sizeof(H221IDGUID), pguid, sizeof(GUID));
}


/*  S E T  A P P  K E Y */
/*----------------------------------------------------------------------------
    %%Function: SetAppKey

	Set the two pieces of an OctetString (the length and the data.)
	Note that the length always includes the terminating null character.
----------------------------------------------------------------------------*/
VOID SetAppKey(LPOSTR pOct, LPBYTE lpb)
{
	pOct->length = cbKeyApp;
	pOct->value = lpb;
}

/*  C R E A T E  A P P  K E Y */
/*----------------------------------------------------------------------------
    %%Function: CreateAppKey

	Given a guid and a userid, create the appropriate application key.

	The key is formated as:
	0xB5 0x00 0x53 0x4C  - Microsoft Object Identifier
	0x01                 - guid identifier
	<binary guid>        - guid data
	<dword node id>      - user node id
----------------------------------------------------------------------------*/
VOID CreateAppKey(LPBYTE lpb, GUID * pguid, DWORD dwUserId)
{
	CreateH221AppKeyFromGuid(lpb, pguid);
	CopyMemory(lpb + cbKeyApp - sizeof(DWORD), &dwUserId, sizeof(DWORD));

#ifdef DEBUG
	TCHAR szGuid[LENGTH_SZGUID_FORMATTED];
	GuidToSz(pguid, szGuid);
	DbgMsgDc("CreateAppKey: %s %08X", szGuid, dwUserId);
#endif
}


/*  P  M E M B E R  F R O M  D W  U S E R  I D  */
/*-------------------------------------------------------------------------
    %%Function: PMemberFromDwUserId

-------------------------------------------------------------------------*/
CNmMember * PMemberFromDwUserId(DWORD dwUserId, COBLIST *pList)
{
	if (NULL != pList)
	{
		POSITION posCurr;
		POSITION pos = pList->GetHeadPosition();
		while (NULL != pos)
		{
			posCurr = pos;
			CNmMember * pMember = (CNmMember *) pList->GetNext(pos);
			if (dwUserId == pMember->GetGCCID())
			{
				pMember->AddRef();
				return pMember;
			}
		}
	}
	return NULL;
}


/*  A D D  N O D E  */
/*-------------------------------------------------------------------------
    %%Function: AddNode

    Add a node to a list.
    Initializes the ObList, if necessary.
    Returns the position in the list or NULL if there was a problem.
-------------------------------------------------------------------------*/
POSITION AddNode(PVOID pv, COBLIST ** ppList)
{
	ASSERT(NULL != ppList);
	if (NULL == *ppList)
	{
		*ppList = new COBLIST();
		if (NULL == *ppList)
			return NULL;
	}

	return (*ppList)->AddTail(pv);
}

/*  R E M O V E  N O D E  */
/*-------------------------------------------------------------------------
    %%Function: RemoveNode

    Remove a node from a list.
    Sets pPos to NULL
-------------------------------------------------------------------------*/
PVOID RemoveNodePos(POSITION * pPos, COBLIST *pList)
{
	if ((NULL == pList) || (NULL == pPos))
		return NULL;

	PVOID pv = pList->RemoveAt(*pPos);
	*pPos = NULL;
	return pv;
}


/*  R E M O V E  N O D E  */
/*-------------------------------------------------------------------------
    %%Function: RemoveNode

-------------------------------------------------------------------------*/
VOID RemoveNode(PVOID pv, COBLIST * pList)
{
	ASSERT(NULL != pv);

	if (NULL != pList)
	{
		POSITION pos = pList->GetPosition(pv);
		RemoveNodePos(&pos, pList);
	}
}

VOID CNmChannelData::InitCT120Channel(DWORD dwUserId)
{
	m_dwUserId = dwUserId;
	m_gcc_conference_id = 0;
	m_gcc_pIAppSap = NULL;
	m_mcs_channel_id = 0;
	m_pmcs_sap = NULL;
	m_gcc_node_id = 0;
	m_scs = SCS_UNINITIALIZED;

	m_pGuid = PGuid();
	ASSERT((NULL != m_pGuid) && (GUID_NULL != *m_pGuid));

	CreateAppKey(m_keyApp, m_pGuid, 0);
	CreateAppKey(m_keyChannel, m_pGuid, dwUserId);

	// initialize other gcc & mcs stuff
	GCCObjectKey FAR * pObjKey;
	ClearStruct(&m_gcc_session_key);
	pObjKey = &(m_gcc_session_key.application_protocol_key);
	pObjKey->key_type = GCC_H221_NONSTANDARD_KEY;
	SetAppKey(&(pObjKey->h221_non_standard_id), m_keyApp);
	ASSERT(0 == m_gcc_session_key.session_id);

	ClearStruct(&m_gcc_registry_item);
	ClearStruct(&m_gcc_registry_key);
	CopyStruct(&m_gcc_registry_key.session_key, &m_gcc_session_key);
	SetAppKey(&m_gcc_registry_key.resource_id, m_keyApp);

	ClearStruct(&m_registry_item_Private);
	ClearStruct(&m_registry_key_Private);
	CopyStruct(&m_registry_key_Private.session_key, &m_gcc_session_key);
	SetAppKey(&m_registry_key_Private.resource_id, m_keyChannel);

	UpdateScState(SCS_UNINITIALIZED, 0);
}


/*  C L O S E  C H A N N E L */
/*----------------------------------------------------------------------------
    %%Function: CloseChannel

	Close the channel.

	Note there are no confirm messages expected for any of the GCC/MCS calls.
----------------------------------------------------------------------------*/
VOID CNmChannelData::CloseChannel(void)
{
	GCCError gccError = GCC_NO_ERROR;
	MCSError mcsError = MCS_NO_ERROR;

	if (SCS_UNINITIALIZED == m_scs)
    {
        WARNING_OUT(("in CT120Channel::CloseChannel, m_scs is SCS_UNINITIALIZED, is this OK?"));
        return;
    }

	DbgMsgDc("CT120Channel::CloseChannel %08X (userHandle=%p)", m_mcs_channel_id, m_pmcs_sap);

	m_scs = SCS_TERMINATING;

	if (0 != m_mcs_channel_id)
	{
		ASSERT (m_pmcs_sap);
		mcsError = m_pmcs_sap->ChannelLeave(m_mcs_channel_id);
		DbgMsgDc("CT120Channel::CloseChannel: ChannelLeave %s", GetMcsErrorString(mcsError));
		m_mcs_channel_id = 0;
	}

	if (NULL != m_pmcs_sap)
	{
		mcsError = m_pmcs_sap->ReleaseInterface();
		DbgMsgDc("CT120Channel::CloseChannel: MCS ReleaseInterface %s", GetMcsErrorString(mcsError));
		m_pmcs_sap = NULL;
	}

	if (NULL != m_gcc_pIAppSap)
	{
		m_gcc_pIAppSap->RegistryDeleteEntry(m_gcc_conference_id, &m_registry_key_Private);
		// ignore the above result

        m_gcc_pIAppSap->ReleaseInterface();
		DbgMsgDc("CT120Channel::CloseChannel: GCCDeleteSap %s", GetGccErrorString(gccError));
		m_gcc_pIAppSap = NULL;
	}

	m_scs = SCS_UNINITIALIZED;
	m_gcc_conference_id = 0;

	// make sure no one is around
	UpdateRoster(NULL, 0, FALSE, TRUE /* fRemove */);;
}


/*  U P D A T E  S C  S T A T E */
/*----------------------------------------------------------------------------
    %%Function: UpdateScState

	The system progresses from one state to another
	by making an GCC (or MCS) call that is guarenteed to
	produce a notification that calls this function.
	The calling process is released by UnBlockThread.
----------------------------------------------------------------------------*/
VOID CNmChannelData::UpdateScState(SCSTATE scs, DWORD dwErr)
{
    DBGENTRY(CNmChannelData::UpdateScState)
	if (m_scs != scs)
	{
		WARNING_OUT(("UpdateScState - invalid state transition (%d - %d)", m_scs, scs));
		dwErr = INVALID_T120_ERROR; // We should never get here
	}

	if (0 == dwErr)
	{
	switch (m_scs)
		{
	case SCS_UNINITIALIZED:
		dwErr = DoCreateSap();
		break;
	case SCS_CREATESAP:
		dwErr = DoAttach();
		break;
	case SCS_ATTACH:
		dwErr = DoEnroll();
		break;
	case SCS_ENROLL:
		dwErr = DoJoinPrivate();
		break;
	case SCS_JOIN_PRIVATE:
		dwErr = DoRegRetrieve();
		break;
	case SCS_REGRETRIEVE_NEW:
		dwErr = DoJoinNew();
		break;
	case SCS_REGRETRIEVE_EXISTS:
		dwErr = DoJoinOld();
		break;
	case SCS_JOIN_NEW:
		dwErr = DoRegChannel();
		break;
	case SCS_REGCHANNEL:
	case SCS_JOIN_OLD:
		dwErr = DoRegPrivate();
		break;
	case SCS_REGPRIVATE:
		DbgMsgDc(">>>>>>>>>>>UpdateScState: Complete");
		m_scs = SCS_CONNECTED;
		NotifyChannelConnected();
		break;
	case SCS_CONNECTED:
	case SCS_REGRETRIEVE:
		// we should never be called when we're in these states
		// so, treat it as an error and fall thru to the default case
	default:
		dwErr = INVALID_T120_ERROR; // We should never get here
		break;
		}
	}

	DbgMsgDc("UpdateScState: New state (%d) channelId=%04X", m_scs, GetMcsChannelId());

	if (0 != dwErr)
	{
		WARNING_OUT(("UpdateScState: Err=%d", dwErr));
		CloseConnection();
	}

    DBGEXIT(CNmChannelData::UpdateScState)
}

DWORD CNmChannelData::DoCreateSap(void)
{
	ASSERT(SCS_UNINITIALIZED == m_scs);
	m_scs = SCS_CREATESAP;

    GCCError gccError = PFNT120::CreateAppSap(&m_gcc_pIAppSap, this, NmGccMsgHandler);
	DbgMsgDc("GCCCreateSap err=%s", GetGccErrorString(gccError));
	return (DWORD) gccError;
}

DWORD CNmChannelData::DoAttach(void)
{
	ASSERT(SCS_CREATESAP == m_scs);
	m_scs = SCS_ATTACH;

	MCSError mcsError = PFNT120::AttachRequest(&m_pmcs_sap,
		(DomainSelector) &m_gcc_conference_id,
		sizeof(m_gcc_conference_id),
		NmMcsMsgHandler,
		this,
		ATTACHMENT_DISCONNECT_IN_DATA_LOSS | ATTACHMENT_MCS_FREES_DATA_IND_BUFFER);
	// This generates an async MCS_ATTACH_USER_CONFIRM

	DbgMsgDc("MCS_AttachRequest err=%s", GetMcsErrorString(mcsError));
	return (DWORD) mcsError;
}

DWORD CNmChannelData::DoEnroll(void)
{
	ASSERT(SCS_ATTACH == m_scs || SCS_JOIN_STATIC_CHANNEL);
	m_scs = SCS_ENROLL;

	GCCEnrollRequest er;
    GCCRequestTag nReqTag;

	if(m_pGCCER)
	{
		m_pGCCER->pSessionKey = &m_gcc_session_key;
		m_pGCCER->nUserID = m_mcs_sender_id;

	}
	else
	{
    	// fill in enroll request structure
	    ::ZeroMemory(&er, sizeof(er));
	    er.pSessionKey = &m_gcc_session_key;
	    er.fEnrollActively = TRUE;
	    er.nUserID = m_mcs_sender_id;
	    // er.fConductingCapabable = FALSE;
	    er.nStartupChannelType = MCS_DYNAMIC_MULTICAST_CHANNEL;
	    // er.cNonCollapsedCaps = 0;
	    // er.apNonCollapsedCaps = NULL;
	    // er.cCollapsedCaps = 0;
    	// er.apCollapsedCaps = NULL;
	    er.fEnroll = TRUE;
	}

	GCCError gccError = m_gcc_pIAppSap->AppEnroll(m_gcc_conference_id, m_pGCCER != NULL ? m_pGCCER : &er, &nReqTag);

	DbgMsgDc("GCCApplicationEnrollRequest err=%s", GetGccErrorString(gccError));

	if (GCC_NO_ERROR != gccError)
	{
		ERROR_OUT(("DoEnroll failed - WHY?"));
	}

	return (DWORD) gccError;
}

// Join the PRIVATE data channel (m_mcs_sender_id)
DWORD CNmChannelData::DoJoinPrivate(void)
{
	ASSERT(SCS_ENROLL == m_scs || SCS_ATTACH == m_scs);
	m_scs = SCS_JOIN_PRIVATE;

	MCSError mcsError = m_pmcs_sap->ChannelJoin(m_mcs_sender_id);
	// This generates an async MCS_CHANNEL_JOIN_CONFIRM

	DbgMsgDc("MCSChannelJoinRequest (private) %04X, err=%s",
		m_mcs_sender_id, GetMcsErrorString(mcsError));
	return (DWORD) mcsError;
}


DWORD CNmChannelData::DoRegRetrieve(void)
{
	ASSERT(SCS_JOIN_PRIVATE == m_scs);
	m_scs = SCS_REGRETRIEVE;

	GCCError gccError = m_gcc_pIAppSap->RegistryRetrieveEntry(
		m_gcc_conference_id, &m_gcc_registry_key);
	// This generates an async GCC_RETRIEVE_ENTRY_CONFIRM

	DbgMsgDc("GCCRegistryRetrieveEntryRequest err=%s", GetGccErrorString(gccError));
	return (DWORD) gccError;
}

// Register the PUBLIC channel
DWORD CNmChannelData::DoRegChannel(void)
{
	ASSERT(SCS_JOIN_NEW == m_scs);
	m_scs = SCS_REGCHANNEL;

	GCCError gccError = m_gcc_pIAppSap->RegisterChannel(
		m_gcc_conference_id, &m_gcc_registry_key, m_mcs_channel_id);
	// This generates an async GCC_REGISTER_CHANNEL_CONFIRM

	DbgMsgDc("GCCRegisterChannelRequest err=%s", GetGccErrorString(gccError));
	return (DWORD) gccError;
}

DWORD CNmChannelData::DoJoinStatic(ChannelID staticChannel)
{
	m_scs = SCS_JOIN_STATIC_CHANNEL;
	MCSError mcsError = m_pmcs_sap->ChannelJoin(staticChannel);
	// This generates an async MCS_CHANNEL_JOIN_CONFIRM

	DbgMsgDc("MCSChannelJoinRequest %04X, err=%s",
		staticChannel, GetMcsErrorString(mcsError));
	return (DWORD) mcsError;
}

DWORD CNmChannelData::DoJoin(SCSTATE scs)
{
	m_scs = scs;

	MCSError mcsError = m_pmcs_sap->ChannelJoin(m_mcs_channel_id);
	// This generates an async MCS_CHANNEL_JOIN_CONFIRM

	DbgMsgDc("MCSChannelJoinRequest %04X, err=%s",
		m_mcs_channel_id, GetMcsErrorString(mcsError));
	return (DWORD) mcsError;
}

DWORD CNmChannelData::DoJoinNew(void)
{
	ASSERT(0 == m_mcs_channel_id);
	ASSERT(SCS_REGRETRIEVE_NEW == m_scs);
	return DoJoin(SCS_JOIN_NEW);
}

DWORD CNmChannelData::DoJoinOld(void)
{
	ASSERT(0 != m_mcs_channel_id);
	ASSERT(SCS_REGRETRIEVE_EXISTS == m_scs);
	return DoJoin(SCS_JOIN_OLD);
}


// Register the PRIVATE data channel. (m_mcs_sender_id)
DWORD CNmChannelData::DoRegPrivate(void)
{
	ASSERT(0 != m_mcs_sender_id);
	ASSERT((SCS_REGCHANNEL == m_scs) || (SCS_JOIN_OLD == m_scs));
	m_scs = SCS_REGPRIVATE;

	DbgMsgDc("DoRegPrivate: channelId %04X as private for %08X", m_mcs_sender_id, m_dwUserId);

	GCCError gccError = m_gcc_pIAppSap->RegisterChannel(
			m_gcc_conference_id, &m_registry_key_Private, m_mcs_sender_id);
	// This generates an async GCC_REGISTER_CHANNEL_CONFIRM

	DbgMsgDc("GCCRegisterChannelRequest err=%s", GetGccErrorString(gccError));
	return (DWORD) gccError;
}


// deal with a GCC_RETRIEVE_ENTRY_CONFIRM notification
VOID CNmChannelData::ProcessEntryConfirm(GCCAppSapMsg * pMsg)
{
	if (pMsg->RegistryConfirm.pRegKey->resource_id.length >=
	    m_gcc_registry_key.resource_id.length
	    &&
        0 != memcmp(m_gcc_registry_key.resource_id.value,
		pMsg->RegistryConfirm.pRegKey->resource_id.value,
		m_gcc_registry_key.resource_id.length))
	{
		OnEntryConfirmRemote(pMsg);
	}
	else
	{
		OnEntryConfirmLocal(pMsg);
	}
}



// deal with a GCC_REGISTRY_HANDLE_CONFIRM notification
VOID CNmChannelData::ProcessHandleConfirm(GCCAppSapMsg * pMsg)
{
	ASSERT(NULL != pMsg);
	NotifySink(&pMsg->RegAllocHandleConfirm, OnAllocateHandleConfirm);
}


VOID CNmChannelData::OnEntryConfirmRemote(GCCAppSapMsg * pMsg)
{
	DWORD dwUserId;
	ASSERT(cbKeyApp ==
		pMsg->RegistryConfirm.pRegKey->resource_id.length);
	CopyMemory(&dwUserId,
		pMsg->RegistryConfirm.pRegKey->resource_id.value +
		cbKeyApp - sizeof(DWORD), sizeof(DWORD));

	DbgMsgDc("GCC_RETRIEVE_ENTRY_CONFIRM: user private channelId = %04X for userId=%04X result=%s",
		pMsg->RegistryConfirm.pRegItem->channel_id, dwUserId,
		GetGccResultString(pMsg->RegistryConfirm.nResult));

	if (GCC_RESULT_SUCCESSFUL == pMsg->RegistryConfirm.nResult)
	{
		UpdateMemberChannelId(dwUserId,
			pMsg->RegistryConfirm.pRegItem->channel_id);
	}
	else
	{
		CNmMemberId * pMemberId = GetMemberId(dwUserId);
		if (NULL != pMemberId)
		{
			UINT cCount = pMemberId->GetCheckIdCount();
			if (0 == cCount)
			{
				DbgMsgDc("CT120Channel: No more ChannelId requests %08X", dwUserId);
			}
			else
			{
				cCount--;
				DbgMsgDc("CT120Channel: Request Count for %08X = %0d", dwUserId, cCount);
				pMemberId->SetCheckIdCount(cCount);

				// BUGBUG: T.120 should notify us when this information is available
				RequestChannelId(dwUserId);
			}
		}
	}
}

VOID CNmChannelData::OnEntryConfirmLocal(GCCAppSapMsg * pMsg)
{
	DbgMsgDc("GCC_RETRIEVE_ENTRY_CONFIRM: public channelId = %04X result=%s",
		pMsg->RegistryConfirm.pRegItem->channel_id,
		GetGccResultString(pMsg->RegistryConfirm.nResult));

	// Processing initial request for guid channel information
	ASSERT(sizeof(m_gcc_registry_item) == sizeof(*(pMsg->RegistryConfirm.pRegItem)));
	CopyMemory(&m_gcc_registry_item, pMsg->RegistryConfirm.pRegItem,
		sizeof(m_gcc_registry_item));
	if (GCC_RESULT_SUCCESSFUL == pMsg->RegistryConfirm.nResult)
	{

		m_mcs_channel_id = m_gcc_registry_item.channel_id;
		ASSERT(SCS_REGRETRIEVE == m_scs);
		m_scs = SCS_REGRETRIEVE_EXISTS;
		UpdateScState(SCS_REGRETRIEVE_EXISTS, 0);
	}
	else if (GCC_RESULT_ENTRY_DOES_NOT_EXIST == pMsg->RegistryConfirm.nResult)
	{
		DbgMsgDc(" channel does not exist - proceeding to new state");
		ASSERT(0 == m_mcs_channel_id);
		ASSERT(SCS_REGRETRIEVE == m_scs);
		m_scs = SCS_REGRETRIEVE_NEW;
		UpdateScState(SCS_REGRETRIEVE_NEW, 0);
	}
}
	

// deal with a GCC_APP_ROSTER_REPORT_INDICATION
BOOL CNmChannelData::UpdateRoster(GCCAppSapMsg * pMsg)
{
	UINT iRoster;
	GCCApplicationRoster * lpAppRoster;
	int iRecord;
	GCCApplicationRecord * lpAppRecord;
	DWORD dwUserId;
	UCID  rgPeerTemp[MAX_NM_PEER];
	int   cPeer;
	int   i;
	BOOL  fAdd = FALSE;
	BOOL  fRemove = FALSE;
	BOOL  fLocal = FALSE;

	DbgMsgDc("CT120Channel::UpdateRoster: conf=%d, roster count=%d",
		pMsg->AppRosterReportInd.nConfID,
		pMsg->AppRosterReportInd.cRosters);

	ZeroMemory(rgPeerTemp, sizeof(rgPeerTemp));

	/* Create rgPeerTemp[], cPeer */
	cPeer = 0;
	for (iRoster = 0;
		iRoster < pMsg->AppRosterReportInd.cRosters;
		iRoster++)
	{
		lpAppRoster = pMsg->AppRosterReportInd.apAppRosters[iRoster];
		if (lpAppRoster->session_key.session_id != m_gcc_session_key.session_id)
			continue;
		
		// Must pay attention to these flags to avoid GCC weirdness
		if (lpAppRoster->nodes_were_added)
			fAdd = TRUE;
		if (lpAppRoster->nodes_were_removed)
			fRemove = TRUE;

		for (iRecord = 0;
			iRecord < lpAppRoster->number_of_records;
			iRecord++)
		{
			lpAppRecord = lpAppRoster->application_record_list[iRecord];
			TRACE_OUT(("Node=%X, Entity=%X, AppId=%X", lpAppRecord->node_id,
				lpAppRecord->entity_id, lpAppRecord->application_user_id));

			// Search for the node in the list
			dwUserId = lpAppRecord->node_id;
			
			//
			// Check for local node
			//
			fLocal |= (dwUserId == m_dwUserIdLocal);
			
			for (i = 0; i < cPeer; i++)
			{
				if (dwUserId == rgPeerTemp[i].dwUserId)
					break;
			}
			if (i >= cPeer)
			{
				if (cPeer >= MAX_NM_PEER)
					continue; // over our limit!

				// Add the node to our new list
				rgPeerTemp[cPeer++].dwUserId = dwUserId;
			}


			// Make sure we know the sender_id's
			if (MCS_DYNAMIC_PRIVATE_CHANNEL == lpAppRecord->startup_channel_type)
			{
				rgPeerTemp[i].sender_id_private = lpAppRecord->application_user_id;
			}
			else
			{
				rgPeerTemp[i].sender_id_public = lpAppRecord->application_user_id;
			}
		}

		break; // out of for (iRoster) loop
	}

	UpdateRoster(rgPeerTemp, cPeer, fAdd, fRemove);

	return (fAdd && fLocal);
}


/*  H R  S E N D  D A T A */
/*----------------------------------------------------------------------------
    %%Function: HrSendData

	Send data on a specific channel
----------------------------------------------------------------------------*/
HRESULT CNmChannelData::HrSendData(ChannelID channel_id, DWORD dwUserId, LPVOID lpv, DWORD cb, DWORD dwFlags)
{
	DbgMsgDc("CT120Channel::HrSendData: %d bytes", cb);



	PDUPriority priority = MEDIUM_PRIORITY;
	SendDataFlags allocation = APP_ALLOCATION;
	DataRequestType requestType =	NORMAL_SEND_DATA;

	if(dwFlags)
	{
	 	if(dwFlags & TOP_PRIORITY_MASK)
	 	{
		 	priority = TOP_PRIORITY;
	 	}
	 	else if (dwFlags & HIGH_PRIORITY_MASK)
	 	{
		 	priority = HIGH_PRIORITY;
	 	}
	 	else if (dwFlags & LOW_PRIORITY_MASK)
	 	{
		 	priority = LOW_PRIORITY;
	 	}

		if (dwFlags & UNIFORM_SEND_DATA_MASK)
		{
			requestType = UNIFORM_SEND_DATA;
		}
	
		if (dwFlags & MCS_ALLOCATION_MASK)
		{
			allocation = MCS_ALLOCATION;
		}
	}

	if ((0 == m_mcs_channel_id) || (NULL == m_pmcs_sap) || (0 == channel_id))
	{
		WARNING_OUT(("*** Attempted to send data on invalid channel"));
		return E_INVALIDARG;
	}

	MCSError mcsError = m_pmcs_sap->SendData(requestType, channel_id, priority,
									(unsigned char *)lpv, cb, allocation);

	if (0 != mcsError)
	{
		TRACE_OUT(("SendData err=%s", GetMcsErrorString(mcsError)));
		// Usually MCS_TRANSMIT_BUFFER_FULL
		return E_OUTOFMEMORY;
	}

	{	// Inform the app the data has been sent
		NMN_DATA_XFER nmnData;
		nmnData.pMember = NULL;
		nmnData.pb = (LPBYTE) lpv;
		nmnData.cb = cb;
		nmnData.dwFlags = 0;

		if (0 == dwUserId)
		{
			// send out notification with NULL member (BROADCAST)
			NotifySink(&nmnData, OnNmDataSent);
		}
		else
		{
			nmnData.pMember = (INmMember *) PMemberFromDwUserId(dwUserId, GetMemberList());
			if (nmnData.pMember)
			{
				NotifySink(&nmnData, OnNmDataSent);
				nmnData.pMember->Release();
			}
		}
	}

	TRACE_OUT(("SendData completed successfully"));
	return S_OK;
}


// Ask GCC for the private channel id.
VOID CNmChannelData::RequestChannelId(DWORD dwUserId)
{
	BYTE   keyChannel[cbKeyApp];
	GCCRegistryKey  registry_key;

	DbgMsgDc("Requesting channel id for %08X", dwUserId);

	CopyStruct(&registry_key.session_key, &m_gcc_session_key);
	CreateAppKey(keyChannel, m_pGuid, dwUserId);
	SetAppKey(&registry_key.resource_id, keyChannel);

	GCCError gccError = m_gcc_pIAppSap->RegistryRetrieveEntry(
		m_gcc_conference_id, &registry_key);
	// This generates an async GCC_RETRIEVE_ENTRY_CONFIRM

	if (0 != gccError)
	{
		WARNING_OUT(("RequestChannelId - problem with GCCRegistryRectreiveEntryRequest"));
	}
}


VOID CNmChannelData::NotifyChannelConnected(void)
{
    DBGENTRY(CNmChannelData::NotifyChannelConnected);
	if (S_OK != IsActive())
	{
		CConfObject * pConference = PConference();
		if (NULL != pConference)
		{
		   	m_fActive = TRUE;

            TRACE_OUT(("The channel is now officially active"));
			// The channel is now officially active
			pConference->OnChannelUpdated(this);
		}
        else
        {
            WARNING_OUT(("PConference is NULL!"));

        }
    }
    DBGEXIT(CNmChannelData::NotifyChannelConnected);
}


/*  N M  G C C  M S G  H A N D L E R  */
/*-------------------------------------------------------------------------
    %%Function: NmGccMsgHandler

-------------------------------------------------------------------------*/
void CALLBACK NmGccMsgHandler(GCCAppSapMsg * pMsg)
{
	TRACE_OUT(("NmGccMsgHandler: [%d]", pMsg->eMsgType));

	CNmChannelData * psc = (CNmChannelData *) (pMsg->pAppData);
	ASSERT(NULL != psc);
	psc->AddRef();

	switch (pMsg->eMsgType)
		{
	case GCC_PERMIT_TO_ENROLL_INDICATION:
		TRACE_OUT((" m_conference_id = %X", pMsg->AppPermissionToEnrollInd.nConfID));
		TRACE_OUT((" permission = %X", pMsg->AppPermissionToEnrollInd.fPermissionGranted));
		if ((SCS_CONNECTED == psc->m_scs) &&
			(0 == pMsg->AppPermissionToEnrollInd.fPermissionGranted))
		{
			psc->CloseConnection();
			break;
		}

		if (SCS_CREATESAP != psc->m_scs)
		{
			TRACE_OUT((" ignoring Enroll Indication"));
			break;
		}
		psc->m_gcc_conference_id = pMsg->AppPermissionToEnrollInd.nConfID;
		psc->UpdateScState(SCS_CREATESAP, !pMsg->AppPermissionToEnrollInd.fPermissionGranted);
		break;

	case GCC_ENROLL_CONFIRM:
		TRACE_OUT((" result = %s", GetGccResultString(pMsg->AppEnrollConfirm.nResult)));

		if (GCC_RESULT_SUCCESSFUL == pMsg->AppEnrollConfirm.nResult)
		{
			TRACE_OUT((" m_conference_id = %X", pMsg->AppEnrollConfirm.nConfID));
			TRACE_OUT((" entity_id = %X", pMsg->AppEnrollConfirm.eidMyself));
			TRACE_OUT((" node_id = %X", pMsg->AppEnrollConfirm.nidMyself));
			psc->m_gcc_node_id = pMsg->AppEnrollConfirm.nidMyself;
		}
		break;

	case GCC_APP_ROSTER_REPORT_INDICATION:
		if(psc->UpdateRoster(pMsg) && psc->m_scs == SCS_ENROLL)
		{
			psc->UpdateScState(SCS_ENROLL, GCC_RESULT_SUCCESSFUL);
		}
		break;

	case GCC_REGISTER_CHANNEL_CONFIRM:
		DbgMsgDc("GCC_REGISTER_CHANNEL_CONFIRM: channel id = %04X  result = %s",
			pMsg->RegistryConfirm.pRegItem->channel_id,
			GetGccResultString(pMsg->RegistryConfirm.nResult));
		if (GCC_RESULT_SUCCESSFUL == pMsg->RegistryConfirm.nResult)
		{
			if (psc->GetMcsChannelId() ==
				pMsg->RegistryConfirm.pRegItem->channel_id)
			{
				ASSERT((0 == psc->m_gcc_registry_item.item_type) ||
					(GCC_REGISTRY_NONE == psc->m_gcc_registry_item.item_type));

    		    ASSERT(sizeof(psc->m_gcc_registry_item) == sizeof(*(pMsg->RegistryConfirm.pRegItem)));
				CopyMemory(&psc->m_gcc_registry_item, pMsg->RegistryConfirm.pRegItem,
					sizeof(psc->m_gcc_registry_item));
			}
			else
			{
				ASSERT(psc->SenderChannelId() ==
						pMsg->RegistryConfirm.pRegItem->channel_id);
				ASSERT(0 == psc->m_registry_item_Private.item_type);

    		    ASSERT(sizeof(psc->m_registry_item_Private) == sizeof(*(pMsg->RegistryConfirm.pRegItem)));
				CopyMemory(&psc->m_registry_item_Private, pMsg->RegistryConfirm.pRegItem,
					sizeof(psc->m_registry_item_Private));
			}
		}
		ASSERT((SCS_REGCHANNEL == psc->m_scs) || (SCS_REGPRIVATE == psc->m_scs));
		psc->UpdateScState(psc->m_scs, pMsg->RegistryConfirm.nResult);
		break;

	case GCC_RETRIEVE_ENTRY_CONFIRM:
		psc->ProcessEntryConfirm(pMsg);
		break;

	case GCC_ALLOCATE_HANDLE_CONFIRM:
		psc->ProcessHandleConfirm(pMsg);
		break;

	default:
		break;
		}

	psc->Release();
}



/*  N M  M C S  M S G  H A N D L E R  */
/*-------------------------------------------------------------------------
    %%Function: NmMcsMsgHandler

-------------------------------------------------------------------------*/
void CALLBACK NmMcsMsgHandler(unsigned int uMsg, LPARAM lParam, PVOID pv)
{
	CNmChannelData * psc = (CNmChannelData *) pv;
	ASSERT(NULL != psc);
//	TRACE_OUT(("[%s]", GetMcsMsgString(uMsg)));
	psc->AddRef();

	switch (uMsg)
		{
	case MCS_ATTACH_USER_CONFIRM:
	{
		DbgMsgDc("MCS_ATTACH_USER_CONFIRM channelId=%04X result=%s",
			LOWORD(lParam), GetMcsResultString(HIWORD(lParam) ));
		if (RESULT_SUCCESSFUL == HIWORD(lParam))
		{
			DbgMsgDc(" Local m_mcs_sender_id = %04X", LOWORD(lParam));
			psc->m_mcs_sender_id = LOWORD(lParam);
		}
		psc->UpdateScState(SCS_ATTACH, (DWORD) HIWORD(lParam));
		break;
	}

	case MCS_CHANNEL_JOIN_CONFIRM:
	{
		DbgMsgDc("MCS_CHANNEL_JOIN_CONFIRM channelId=%04X result=%s",
			LOWORD(lParam), GetMcsResultString(HIWORD(lParam) ));
		if (RESULT_SUCCESSFUL == HIWORD(lParam))
		{
			if (psc->m_mcs_sender_id == LOWORD(lParam))
			{
				ASSERT(SCS_JOIN_PRIVATE == psc->m_scs);
			}
			else
			{
				ASSERT((0 == psc->m_mcs_channel_id) ||
					(psc->m_mcs_channel_id == LOWORD(lParam)));

				psc->m_mcs_channel_id = LOWORD(lParam);
			}			
		}
		ASSERT((SCS_JOIN_NEW == psc->m_scs) ||
		       (SCS_JOIN_OLD == psc->m_scs) ||
		       (SCS_JOIN_PRIVATE == psc->m_scs) ||
			   (SCS_CONNECTED == psc->m_scs)||
			   (SCS_JOIN_STATIC_CHANNEL == psc->m_scs));

		psc->UpdateScState(psc->m_scs, (DWORD) HIWORD(lParam));
		break;
	}

	case MCS_UNIFORM_SEND_DATA_INDICATION:
	case MCS_SEND_DATA_INDICATION:  // lParam == SendData *
	{
		SendData * pSendData = (SendData *) lParam;
		ASSERT(NULL != pSendData);
		CNmMember * pMember = psc->PMemberFromSenderId(pSendData->initiator);

		if (NULL != pMember)
		{
            if (uMsg == MCS_UNIFORM_SEND_DATA_INDICATION)
            {
                //
                // Skip UNIFORM notifications that came from us
                //

                ULONG memberID;
                pMember->GetID(&memberID);

                if (memberID == psc->m_gcc_node_id)
                {
                    // We sent this, skip it.
                    goto RelMember;
                }
            }

			ASSERT (pSendData->segmentation == (SEGMENTATION_BEGIN | SEGMENTATION_END));
					
			NMN_DATA_XFER nmnData;
			nmnData.pMember =(INmMember *) pMember;
			nmnData.pb = pSendData->user_data.value;
			nmnData.cb = pSendData->user_data.length;
			nmnData.dwFlags = (ULONG)
				(NM_DF_SEGMENT_BEGIN | NM_DF_SEGMENT_END) |
				((psc->GetMcsChannelId() == pSendData->channel_id) ?
				NM_DF_BROADCAST : NM_DF_PRIVATE);

			psc->NotifySink((PVOID) &nmnData, OnNmDataReceived);

RelMember:
			pMember->Release();
		}
		break;
	}
	
	default:
		break;
		}

	psc->Release();
}



//
//	CNmMemberId
//

CNmMemberId::CNmMemberId(CNmMember *pMember, UCID * pucid) :
	m_channelId(pucid->channelId),
	m_sender_id_public(pucid->sender_id_public),
	m_sender_id_private(pucid->sender_id_private),
	m_cCheckId(0),
	m_pMember(pMember)
{
}

VOID CNmMemberId::UpdateRosterInfo(UCID * pucid)
{
	if (0 == m_channelId)
		m_channelId = pucid->channelId;
	if (0 == m_sender_id_private)
		m_sender_id_private = pucid->sender_id_private;
	if (0 == m_sender_id_public)
		m_sender_id_public = pucid->sender_id_public;
}

//
// CNmChannelData
//

CNmChannelData::CNmChannelData(CConfObject * pConference, REFGUID rguid, PGCCEnrollRequest pER) :
	CConnectionPointContainer(g_apiidCP, ARRAY_ELEMENTS(g_apiidCP)),
	m_pConference(pConference),
	m_fClosed(TRUE),
	m_fActive(FALSE),
	m_cMember(0),
	m_pListMemberId(NULL),
	m_pListMember(NULL),
	m_pGCCER(pER)
{
	m_guid = rguid;
	ASSERT(GUID_NULL != rguid);

	m_dwUserIdLocal = pConference->GetDwUserIdLocal();
	ASSERT(INVALID_GCCID != m_dwUserIdLocal);

	DbgMsg(iZONE_OBJECTS, "Obj: %08X created CNmChannelData", this);
}


CNmChannelData::~CNmChannelData(void)
{
    DBGENTRY(CNmChannelData::~CNmChannelData);

		// This will keep us from being deleted again...
	++m_ulcRef;

	CloseConnection();

	FreeMemberIdList(&m_pListMemberId);
	delete m_pListMember;

	if(m_pConference)
	{
		m_pConference->RemoveDataChannelGUID(m_guid);
	}

	DbgMsg(iZONE_OBJECTS, "Obj: %08X destroyed CNmChannelData", this);

    DBGEXIT(CNmChannelData::~CNmChannelData);
}


/*  A D D  M E M B E R  */
/*-------------------------------------------------------------------------
    %%Function: AddMember

-------------------------------------------------------------------------*/
VOID CNmChannelData::AddMember(CNmMember * pMember)
{
	DbgMsgDc("CNmChannelData::AddMember [%ls] id=%08X",
		pMember->GetName(), pMember->GetGCCID());

	m_cMember++;
	pMember->AddRef();
	AddNode(pMember, &m_pListMember);

	INmMember * pNmMember = (INmMember *) pMember;
	NotifySink(pNmMember, OnNotifyChannelMemberAdded);
}


/*  R E M O V E  M E M B E R  */
/*-------------------------------------------------------------------------
    %%Function: RemoveMember

-------------------------------------------------------------------------*/
VOID CNmChannelData::RemoveMember(CNmMember * pMember)
{
	DbgMsgDc("CNmChannelData::RemoveMember [%ls] id=%08X",
		pMember->GetName(), pMember->GetGCCID());

	m_cMember--;
	ASSERT((int)m_cMember >= 0);
	RemoveNode(pMember, m_pListMember);

	INmMember * pNmMember = (INmMember *) pMember;
	NotifySink(pNmMember, OnNotifyChannelMemberRemoved);

 	pMember->Release(); // Release AFTER notifying everyone
}


/*  O P E N  C O N N E C T I O N  */
/*-------------------------------------------------------------------------
    %%Function: OpenConnection

    Open a T.120 data connection (init both public and private channels)
-------------------------------------------------------------------------*/
HRESULT	CNmChannelData::OpenConnection(void)
{
	TRACE_OUT(("CNmChannelData::OpenConection()"));

	if (!m_fClosed)
		return E_FAIL; // already open
	m_fClosed = FALSE; // need to call CloseConnection after this

	if (FAILED(PFNT120::Init()))
		return E_FAIL;

	InitCT120Channel(m_dwUserIdLocal);
	return S_OK;
}


/*  C L O S E  C O N N E C T I O N  */
/*-------------------------------------------------------------------------
    %%Function: CloseConnection

	Close the data channel - this matches what is done in OpenConnection
-------------------------------------------------------------------------*/
HRESULT CNmChannelData::CloseConnection(void)
{
	DBGENTRY(CNmChannelData::CloseConnection);

    HRESULT hr = S_OK;

	if (!m_fClosed)
    {
	    m_fClosed = TRUE;

	    // Close any open T.120 channels
		CloseChannel();

	    if (0 != m_cMember)
	    {
		    // force roster update with no peers
		    DbgMsgDc("CloseConnection: %d members left", m_cMember);
		    UpdateRoster(NULL, 0, FALSE, TRUE /* fRemove */);
		    ASSERT(IsEmpty());
	    }

	    CConfObject * pConference = PConference();
	    if (NULL != pConference)
	    {
	    	m_fActive = FALSE;
		    // The channel is now officially inactive
		    pConference->OnChannelUpdated(this);
	    }
    }

    DBGEXIT_HR(CNmChannelData::CloseConnection, hr);
	return hr;
}


/*  U P D A T E  P E E R  */
/*-------------------------------------------------------------------------
    %%Function: UpdatePeer

-------------------------------------------------------------------------*/
VOID CNmChannelData::UpdatePeer(CNmMember * pMember, UCID *pucid, BOOL fAdd)
{
#ifdef DEBUG
	DbgMsgDc("UpdatePeer (%08X) fAdd=%d fLocal=%d", pMember, fAdd, pMember->FLocal());
	if (NULL != pucid)
	{
		DbgMsgDc(" channelId=(%04X) dwUserId=%08X", pucid->channelId, pucid->dwUserId);
	}
#endif /* DEBUG */

	if (fAdd)
	{
		CNmMemberId *pMemberId = new CNmMemberId(pMember, pucid);
		if (NULL != pMemberId)
		{
			AddNode(pMemberId, &m_pListMemberId);
			AddMember(pMember);
		}
	}
	else
	{
		CNmMemberId *pMemberId = GetMemberId(pMember);
		if (NULL != pMemberId)
		{
			RemoveNode(pMemberId, m_pListMemberId);
			delete pMemberId;
			RemoveMember(pMember);
		}
	}
}

/*  U P D A T E  R O S T E R  */
/*-------------------------------------------------------------------------
    %%Function: UpdateRoster

    Update the local peer list based on the new roster data
-------------------------------------------------------------------------*/
VOID CNmChannelData::UpdateRoster(UCID * rgPeer, int cPeer, BOOL fAdd, BOOL fRemove)
{
	int   iPeer;
	DWORD dwUserId;
	CNmMember * pMember;
	COBLIST * pList;

	DbgMsgDc("CNmChannelData::UpdateRoster: %d peers, fAdd=%d, fRemove=%d",
		cPeer, fAdd, fRemove);

	if (NULL != m_pListMemberId)
	{
		for (POSITION pos = m_pListMemberId->GetHeadPosition(); NULL != pos; )
		{
			BOOL fFound = FALSE;
			CNmMemberId *pMemberId = (CNmMemberId *) m_pListMemberId->GetNext(pos);
			ASSERT(NULL != pMemberId);
			pMember = pMemberId->GetMember();
			ASSERT(NULL != pMember);
			dwUserId = pMember->GetGCCID();

			if (0 != dwUserId)
			{
				for (iPeer = 0; iPeer < cPeer; iPeer++)
				{
					if (dwUserId == rgPeer[iPeer].dwUserId)
					{
						fFound = TRUE;
						// remove from the new list
						// so that the peer will not be added below
						rgPeer[iPeer].dwUserId = 0;

						// no change, but make sure we know sender_ids
						pMemberId->UpdateRosterInfo(&rgPeer[iPeer]);

						// try to find channel id, if necessary
						if ((0 == pMemberId->GetChannelId()) &&
							(0 == pMemberId->GetCheckIdCount())
							&& !pMember->FLocal())
						{
							pMemberId->SetCheckIdCount(MAX_CHECKID_COUNT);
							RequestChannelId(dwUserId);
						}
						break;
					}
				}
			}

			if (!fFound && fRemove)
			{
				pMember->AddRef();

				// Unable to find old peer in new list - delete it
				UpdatePeer(pMember, NULL, FALSE /* fAdd */ );

				pMember->Release();
			}
		}
	}

	if (!fAdd)
		return;


	// Use the conference list to find member data
	pList = PConference()->GetMemberList();
	/* Add new peers */
	for (iPeer = 0; iPeer < cPeer; iPeer++)
	{
		dwUserId = rgPeer[iPeer].dwUserId;
		if (0 == dwUserId)
			continue;

		// PMemberFromDwUserId returns AddRef'd member
		pMember = PMemberFromDwUserId(dwUserId, pList);

		if (NULL == pMember)
		{
			WARNING_OUT(("UpdateRoster: Member not found! dwUserId=%08X", dwUserId));
		}
		else
		{
			UpdatePeer(pMember, &rgPeer[iPeer], TRUE /* fAdd */);
			pMember->Release();
		}
	}
}


/*  U P D A T E  M E M B E R  C H A N N E L  I D  */
/*-------------------------------------------------------------------------
    %%Function: UpdateMemberChannelId

-------------------------------------------------------------------------*/
VOID CNmChannelData::UpdateMemberChannelId(DWORD dwUserId, ChannelID channelId)
{
		// PMemberFromDwUserId returns AddRef'd member
	CNmMember * pMember = PMemberFromDwUserId(dwUserId, PConference()->GetMemberList());
	TRACE_OUT(("Member (%08X) private channelId=(%04X)", pMember, channelId));
	if (NULL != pMember)
	{
		UCID ucid;
		ClearStruct(&ucid);
		ucid.channelId = channelId;
		UpdateRosterInfo(pMember, &ucid);
		pMember->Release();
	}
}


/*  G E T  M E M B E R  I D  */
/*-------------------------------------------------------------------------
    %%Function: GetMemberId

-------------------------------------------------------------------------*/
CNmMemberId * CNmChannelData::GetMemberId(CNmMember *pMember)
{
	if (NULL != m_pListMemberId)
	{
		POSITION pos = m_pListMemberId->GetHeadPosition();
		while (NULL != pos)
		{
			CNmMemberId *pMemberId = (CNmMemberId *) m_pListMemberId->GetNext(pos);
			ASSERT(NULL != pMemberId);
			if (pMemberId->GetMember() == pMember)
			{
				return pMemberId;
			}
		}
	}
	return NULL;
}

/*  G E T  M E M B E R  I D  */
/*-------------------------------------------------------------------------
    %%Function: GetMemberId

-------------------------------------------------------------------------*/
CNmMemberId * CNmChannelData::GetMemberId(DWORD dwUserId)
{
	if (NULL != m_pListMemberId)
	{
		POSITION pos = m_pListMemberId->GetHeadPosition();
		while (NULL != pos)
		{
			CNmMemberId *pMemberId = (CNmMemberId *) m_pListMemberId->GetNext(pos);
			ASSERT(NULL != pMemberId);
			CNmMember *pMember = pMemberId->GetMember();
			ASSERT(NULL != pMember);
			if (pMember->GetGCCID() == dwUserId)
			{
				return pMemberId;
			}
		}
	}
	return NULL;
}


/*  U P D A T E  R O S T E R  I N F O  */
/*-------------------------------------------------------------------------
    %%Function: UpdateRosterInfo

-------------------------------------------------------------------------*/
VOID CNmChannelData::UpdateRosterInfo(CNmMember *pMember, UCID * pucid)
{
	CNmMemberId *pMemberId = GetMemberId(pMember);
	if (NULL != pMemberId)
	{
		pMemberId->UpdateRosterInfo(pucid);
	}
}

/*  G E T  C H A N N E L  I D  */
/*-------------------------------------------------------------------------
    %%Function: GetChannelId

-------------------------------------------------------------------------*/
ChannelID CNmChannelData::GetChannelId(CNmMember *pMember)
{
	CNmMemberId *pMemberId = GetMemberId(pMember);
	if (NULL != pMemberId)
	{
		return pMemberId->GetChannelId();
	}
	return 0;
}

/*  P  M E M B E R  F R O M  S E N D E R  I D  */
/*-------------------------------------------------------------------------
    %%Function: PMemberFromSenderId

-------------------------------------------------------------------------*/
CNmMember * CNmChannelData::PMemberFromSenderId(UserID id)
{
	if (NULL != m_pListMemberId)
	{
		POSITION pos = m_pListMemberId->GetHeadPosition();
		while (NULL != pos)
		{
			CNmMemberId * pMemberId = (CNmMemberId *) m_pListMemberId->GetNext(pos);
			ASSERT(NULL != pMemberId);
			if (pMemberId->FSenderId(id))
			{
				CNmMember* pMember = pMemberId->GetMember();
				ASSERT(NULL != pMember);
				pMember->AddRef();
				return pMember;
			}
		}
	}
	return NULL;
}

///////////////////////////
//  CNmChannelData:IUknown

ULONG STDMETHODCALLTYPE CNmChannelData::AddRef(void)
{
    TRACE_OUT(("CNmChannelData::AddRef this = 0x%X", this));
	return RefCount::AddRef();
}


ULONG STDMETHODCALLTYPE CNmChannelData::Release(void)
{
    TRACE_OUT(("CNmChannelData::Release this = 0x%X", this));
	return RefCount::Release();
}


HRESULT STDMETHODCALLTYPE CNmChannelData::QueryInterface(REFIID riid, PVOID *ppv)
{
	HRESULT hr = S_OK;

	if ((riid == IID_IUnknown) ||  (riid == IID_INmChannelData2) || (riid == IID_INmChannelData) || (riid == IID_INmChannel))
	{
		*ppv = (INmChannelData2 *)this;
		TRACE_OUT(("CNmChannel::QueryInterface(): Returning INmChannelData."));
	}
	else if (riid == IID_IConnectionPointContainer)
	{
		*ppv = (IConnectionPointContainer *) this;
		TRACE_OUT(("CNmChannel::QueryInterface(): Returning IConnectionPointContainer."));
	}

	else
	{
		hr = E_NOINTERFACE;
		*ppv = NULL;
		TRACE_OUT(("CNmChannel::QueryInterface(): Called on unknown interface."));
	}

	if (S_OK == hr)
	{
		AddRef();
	}

	return hr;
}


///////////////////////
// INmChannelData

HRESULT STDMETHODCALLTYPE CNmChannelData::GetGuid(GUID *pGuid)
{
	if (NULL == pGuid)
		return E_POINTER;

	*pGuid = m_guid;
	return S_OK;
}

HRESULT STDMETHODCALLTYPE CNmChannelData::SendData(INmMember *pMember, ULONG cb, LPBYTE pv, ULONG uOptions)
{
	HRESULT hr;

	if (!m_fActive)
	{
		// No active Channels, yet
		return E_FAIL;
	}

	if ((NULL == pv) || (0 == cb))
	{
		return S_FALSE;
	}
	if (IsBadReadPtr(pv, cb))
	{
		return E_POINTER;
	}

	CNmMember * pDest = (CNmMember *) pMember;
	COBLIST * pList = GetMemberList();
	if (NULL == pMember)
	{
		hr = HrSendData(GetMcsChannelId(), 0, pv, cb, uOptions);
	}
	else if ((NULL == pList) || (NULL == pList->Lookup(pDest)) )
	{
		// Destination is not in list
		hr = E_INVALIDARG;
	}
	else
	{
		ChannelID channel_id = GetChannelId(pDest);
		if (0 == channel_id)
		{
			WARNING_OUT(("Unable to find user destination channel?"));

			CNmMemberId *pMemberId = GetMemberId(pDest);
			if (NULL == pMemberId)
			{
				hr = E_UNEXPECTED;
			}
			else
			{
				channel_id = pMemberId->SenderId();
				hr = (0 == channel_id) ? E_FAIL : S_OK;
			}
		}
		
		if (SUCCEEDED(hr))
		{
			hr = HrSendData(channel_id, pDest->GetGCCID(), pv, cb, uOptions);
		}
	}

	return hr;
}

HRESULT STDMETHODCALLTYPE CNmChannelData::RegistryAllocateHandle(ULONG numberOfHandlesRequested)
{
	if (!m_fActive)
	{
		// No active Channels, yet
		return E_FAIL;
	}

	if(numberOfHandlesRequested == 0)
	{
		return E_INVALIDARG;
	}

	//
	// Request handles from gcc
	//
	GCCError gccError = m_gcc_pIAppSap->RegistryAllocateHandle(m_gcc_conference_id, numberOfHandlesRequested);
	
	if(gccError == GCC_NO_ERROR)
	{
		return S_OK;
	}
	else
	{
		return E_FAIL;
	}
}

///////////////
// INmChannel

HRESULT STDMETHODCALLTYPE CNmChannelData::IsSameAs(INmChannel *pChannel)
{
	HRESULT hr;
	PVOID pv;

	if (pChannel == NULL)
	{
		hr = E_INVALIDARG;
	}
	else
	{
		hr = pChannel->QueryInterface(IID_INmChannelData, &pv);
		if (SUCCEEDED(hr))
		{
			hr = (this == (PVOID) ((CNmChannelData *)(INmChannelData *)pv)) ? S_OK : S_FALSE;
			((IUnknown *) pv)->Release();
		}
	}
	
	return hr;
}

HRESULT STDMETHODCALLTYPE CNmChannelData::IsActive(void)
{
	return m_fActive ? S_OK : S_FALSE;
}

HRESULT STDMETHODCALLTYPE CNmChannelData::SetActive(BOOL fActive)
{
	TRACE_OUT(("CNmChannelData::SetActive(%d)", fActive));

	NM_CONFERENCE_STATE state;
	// Must be in a non-idle conference
	CConfObject * pConference = PConference();
	pConference->GetState(&state);
	if ((NULL == pConference) || state == NM_CONFERENCE_IDLE)
		return E_FAIL;

	if (fActive)
	{
		if (S_OK == IsActive())
			return S_OK;
		return OpenConnection();
	}
	else
	{
		if (S_FALSE == IsActive())
			return S_OK;
		return CloseConnection();
	}
}


HRESULT STDMETHODCALLTYPE CNmChannelData::GetConference(INmConference **ppConference)
{
	return ::GetConference(ppConference);
}

HRESULT STDMETHODCALLTYPE CNmChannelData::GetInterface(IID *piid)
{
	HRESULT hr = E_POINTER;
	if (NULL != piid)
	{
		*piid = IID_INmChannelData;
		hr = S_OK;
	}
	return hr;
}
	

HRESULT STDMETHODCALLTYPE CNmChannelData::GetNmch(ULONG *puch)
{
	HRESULT hr = E_POINTER;

	if (NULL != puch)
	{
		*puch = NMCH_DATA;
		hr = S_OK;
	}
	return hr;
}

HRESULT STDMETHODCALLTYPE CNmChannelData::EnumMember(IEnumNmMember **ppEnum)
{
	HRESULT hr = E_POINTER;
	if (NULL != ppEnum)
	{
		*ppEnum = new CEnumNmMember( GetMemberList(), m_cMember);

		hr = (NULL != *ppEnum)? S_OK : E_OUTOFMEMORY;
	}
	return hr;
}

HRESULT STDMETHODCALLTYPE CNmChannelData::GetMemberCount(ULONG *puCount)
{
	HRESULT hr = E_POINTER;

	if (NULL != puCount)
	{
		*puCount = m_cMember;
		hr = S_OK;
	}
	return hr;
}


///////////////////////////////////////////////////////////////////////////
// Utility Functions

HRESULT OnNmDataSent(IUnknown *pChannelDataNotify, void *pv, REFIID riid)
{
	NMN_DATA_XFER * pData = (NMN_DATA_XFER *) pv;

    if (IID_INmChannelDataNotify.Data1 == riid.Data1 || IID_INmChannelDataNotify2.Data1 == riid.Data1)
    {
	    ((INmChannelDataNotify2*)pChannelDataNotify)->DataSent(
		    pData->pMember, pData->cb, pData->pb);
    }
	return S_OK;
}

HRESULT OnNmDataReceived(IUnknown *pChannelDataNotify, void *pv, REFIID riid)
{
	NMN_DATA_XFER * pData = (NMN_DATA_XFER *) pv;

    if (IID_INmChannelDataNotify.Data1 == riid.Data1 || IID_INmChannelDataNotify2.Data1 == riid.Data1)
    {
	    ((INmChannelDataNotify2*)pChannelDataNotify)->DataReceived(
		    pData->pMember, pData->cb, pData->pb, pData->dwFlags);
    }
	return S_OK;
}

HRESULT OnAllocateHandleConfirm(IUnknown *pChannelDataNotify, void *pv, REFIID riid)
{


	if(IID_INmChannelDataNotify2.Data1 == riid.Data1)
	{
		GCCRegAllocateHandleConfirm *pConfirm =  (GCCRegAllocateHandleConfirm *)pv;

		((INmChannelDataNotify2*)pChannelDataNotify)->AllocateHandleConfirm(pConfirm->nFirstHandle,
															    pConfirm->cHandles);
	}											
	return S_OK;
}


///////////////////////////////////////////////////////////////////////////
// Utility Functions

/*  F R E E  M E M B E R  ID  L I S T  */
/*-------------------------------------------------------------------------
    %%Function: FreeMemberIdList

-------------------------------------------------------------------------*/
VOID FreeMemberIdList(COBLIST ** ppList)
{
	DBGENTRY(FreeMemberIdList);

	ASSERT(NULL != ppList);
	if (NULL != *ppList)
	{
		while (!(*ppList)->IsEmpty())
		{
			CNmMemberId * pMemberId = (CNmMemberId *)  (*ppList)->RemoveHead();
			delete pMemberId;
		}
		delete *ppList;
		*ppList = NULL;
	}
}


///////////////////////////////////////////////////////////////////////////
//
// GCC / MCS Errors

#ifdef DEBUG
LPCTSTR _FormatSzErr(LPTSTR psz, UINT uErr)
{
	static char szErr[MAX_PATH];
	wsprintf(szErr, "%s 0x%08X (%d)", psz, uErr, uErr);
	return szErr;
}

#define STRING_CASE(val)               case val: pcsz = #val; break

LPCTSTR GetGccErrorString(GCCError uErr)
{
	LPCTSTR pcsz;

	switch (uErr)
		{
	STRING_CASE(GCC_NO_ERROR);
	STRING_CASE(GCC_RESULT_ENTRY_DOES_NOT_EXIST);
	STRING_CASE(GCC_NOT_INITIALIZED);
	STRING_CASE(GCC_ALREADY_INITIALIZED);
	STRING_CASE(GCC_ALLOCATION_FAILURE);
	STRING_CASE(GCC_NO_SUCH_APPLICATION);
	STRING_CASE(GCC_INVALID_CONFERENCE);

	default:
		pcsz = _FormatSzErr("GccError", uErr);
		break;
		}

	return pcsz;
}

LPCTSTR GetMcsErrorString(MCSError uErr)
{
	LPCTSTR pcsz;

	switch (uErr)
		{
	STRING_CASE(MCS_NO_ERROR);
	STRING_CASE(MCS_USER_NOT_ATTACHED);
	STRING_CASE(MCS_NO_SUCH_USER);
	STRING_CASE(MCS_TRANSMIT_BUFFER_FULL);
	STRING_CASE(MCS_NO_SUCH_CONNECTION);

	default:
		pcsz = _FormatSzErr("McsError", uErr);
		break;
		}

	return pcsz;
}

LPCTSTR GetGccResultString(UINT uErr)
{
	LPCTSTR pcsz;

	switch (uErr)
		{
	STRING_CASE(GCC_RESULT_ENTRY_DOES_NOT_EXIST);
	default:
		pcsz = _FormatSzErr("GccResult", uErr);
		break;
		}

	return pcsz;
}

LPCTSTR GetMcsResultString(UINT uErr)
{
	return _FormatSzErr("McsResult", uErr);
}
#endif /* DEBUG (T.120 Error routines) */



=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\core\ichnlvid.cpp ===
// File: ichnlvid.cpp

#include "precomp.h"
#include "ichnlvid.h"

typedef struct
{
	DWORD *pdwCapDevIDs;
	LPTSTR pszCapDevNames;
	DWORD dwNumCapDev;
} ENUM_CAP_DEV;

static HRESULT OnNotifyStateChanged(IUnknown *pChannelNotify, PVOID pv, REFIID riid);
static HRESULT OnNotifyPropertyChanged(IUnknown *pChannelNotify, PVOID pv, REFIID riid);

static const IID * g_apiidCP[] =
{
	{&IID_INmChannelNotify},
	{&IID_INmChannelVideoNotify}
};

CNmChannelVideo * CNmChannelVideo::m_pPreviewChannel = NULL;


CNmChannelVideo::CNmChannelVideo(BOOL fIncoming) :
	CConnectionPointContainer(g_apiidCP, ARRAY_ELEMENTS(g_apiidCP)),
	m_VideoPump(!fIncoming /* fLocal */),
	m_cMembers	(0),
	m_fIncoming(fIncoming),
	m_pMediaChannel(NULL),
	m_pCommChannel(NULL),
	m_MediaFormat(INVALID_MEDIA_FORMAT)
{
	if (NULL != g_pH323UI)
	{
		IH323CallControl * pH323CallControl = g_pH323UI->GetH323CallControl();
		IMediaChannelBuilder * pMCProvider = g_pH323UI->GetStreamProvider();
		IVideoDevice *pVideoDevice=NULL;
		ASSERT((NULL !=  pH323CallControl) && (NULL != pMCProvider));
		pMCProvider->CreateMediaChannel(MCF_VIDEO | (fIncoming ? MCF_RECV : MCF_SEND), &m_pMediaChannel);
		if (m_pMediaChannel)
		{
			pMCProvider->QueryInterface(IID_IVideoDevice, (void**)&pVideoDevice);
			m_VideoPump.Initialize(pH323CallControl, m_pMediaChannel, pVideoDevice, (DWORD_PTR)this, FrameReadyCallback);
			pVideoDevice->Release();
		}
		pMCProvider->Release();
	}

	DbgMsg(iZONE_OBJECTS, "Obj: %08X created CNmChannelVideo", this);
}

CNmChannelVideo::~CNmChannelVideo()
{
	if (!m_fIncoming)
	{
		// make sure we're no longer capturing
		m_VideoPump.EnableXfer(FALSE);
	}

	if (this == m_pPreviewChannel)
	{
		m_pPreviewChannel = NULL;
	}

	if (NULL != m_pCommChannel)
	{
		m_pCommChannel->Release();
	}
	if (NULL != m_pMediaChannel)
	{
		m_pMediaChannel->Release();
	}
	

	DbgMsg(iZONE_OBJECTS, "Obj: %08X destroyed CNmChannelVideo", this);
}

VOID CNmChannelVideo::CommChannelOpened(ICommChannel *pCommChannel)
{
	ASSERT(NULL == m_pCommChannel);
	m_pCommChannel = pCommChannel;
	m_pCommChannel->AddRef();
}

VOID CNmChannelVideo::CommChannelActive(ICommChannel *pCommChannel)
{
	ASSERT(m_pCommChannel == pCommChannel);
	m_VideoPump.OnChannelOpened(pCommChannel);
	OnStateChange();
}

VOID CNmChannelVideo::CommChannelClosed()
{
	if (NULL != m_pCommChannel)
	{
		m_pCommChannel->Release();
		m_pCommChannel = NULL;

		m_VideoPump.OnChannelClosed();
		OnStateChange();
	}
}

CNmChannelVideo * CNmChannelVideo::CreateChannel(BOOL fIncoming)
{
	if (fIncoming)
	{
		return new CNmChannelVideo(TRUE /* fIncoming */);
	}
	else
	{
		if (NULL != m_pPreviewChannel)
		{
			m_pPreviewChannel->AddRef();
		}
		return m_pPreviewChannel;
	}
}

CNmChannelVideo * CNmChannelVideo::CreatePreviewChannel()
{
	ASSERT(NULL == m_pPreviewChannel);
	m_pPreviewChannel = new CNmChannelVideo(FALSE /* fIncoming */);
	if (NULL != m_pPreviewChannel)
	{
		if (!m_pPreviewChannel->IsCaptureAvailable())
		{
			delete m_pPreviewChannel;
			m_pPreviewChannel = NULL;
		}
	}
	return m_pPreviewChannel;
}

VOID CNmChannelVideo::OnMemberAdded(CNmMember *pMember)
{
	// Don't add to the channel if we already belong.
	if (0 != (pMember->GetNmchCaps() & NMCH_VIDEO))
	{
		return;
	}
	
	++m_cMembers;

	pMember->AddNmchCaps(NMCH_VIDEO);

	CConfObject *pco = ::GetConfObject();
	pco->OnMemberUpdated(pMember);

	NotifySink((INmMember *) pMember, OnNotifyChannelMemberAdded);
}

VOID CNmChannelVideo::OnMemberRemoved(CNmMember *pMember)
{
		// If member does not belong to this channel, don't remove it.
	if (0 == (pMember->GetNmchCaps() & NMCH_VIDEO))
	{
		return;
	}
	
	--m_cMembers;

	pMember->RemoveNmchCaps(NMCH_VIDEO);

	CConfObject *pco = ::GetConfObject();
	pco->OnMemberUpdated(pMember);

	NotifySink((INmMember *) pMember, OnNotifyChannelMemberRemoved);
}

VOID CNmChannelVideo::OnMemberUpdated(CNmMember *pMember)
{
	NotifySink((INmMember *) pMember, OnNotifyChannelMemberUpdated);
}

VOID CNmChannelVideo::OnStateChange()
{
	NM_VIDEO_STATE state;
	GetState(&state);
	NotifySink((PVOID) state, OnNotifyStateChanged);
}

VOID CNmChannelVideo::OnFrameAvailable()
{
	NotifySink((PVOID) NM_VIDPROP_FRAME, OnNotifyPropertyChanged);
}

VOID CNmChannelVideo::Open()
{
	ASSERT(m_MediaFormat !=  INVALID_MEDIA_FORMAT);
	m_VideoPump.Open(m_MediaFormat);
}

VOID CNmChannelVideo::Close()
{
	m_VideoPump.Close();
}


STDMETHODIMP_(ULONG) CNmChannelVideo::AddRef(void)
{
	return RefCount::AddRef();
}
	
STDMETHODIMP_(ULONG) CNmChannelVideo::Release(void)
{
	return RefCount::Release();
}

STDMETHODIMP CNmChannelVideo::QueryInterface(REFIID riid, PVOID *ppv)
{
	HRESULT hr = S_OK;

	if ((riid == IID_INmChannelVideo) || (riid == IID_INmChannel) || (riid == IID_IUnknown))
	{
		*ppv = (INmChannel *)this;
		DbgMsgApi("CNmChannelVideo::QueryInterface()");
	}
	else if (riid == IID_IConnectionPointContainer)
	{
		*ppv = (IConnectionPointContainer *) this;
		DbgMsgApi("CNmChannelVideo::QueryInterface(): Returning IConnectionPointContainer.");
	}
	else
	{
		hr = E_NOINTERFACE;
		*ppv = NULL;
		DbgMsgApi("CNmChannelVideo::QueryInterface(): Called on unknown interface.");
	}

	if (S_OK == hr)
	{
		AddRef();
	}

	return hr;
}

STDMETHODIMP CNmChannelVideo::IsSameAs(INmChannel *pChannel)
{
	return (((INmChannel *) this) == pChannel) ? S_OK : S_FALSE;
}

STDMETHODIMP CNmChannelVideo::IsActive()
{
	return (NULL != m_pCommChannel) ? S_OK : S_FALSE;
}

STDMETHODIMP CNmChannelVideo::SetActive(BOOL fActive)
{
	return E_FAIL;
}

STDMETHODIMP CNmChannelVideo::GetConference(INmConference **ppConference)
{
	return ::GetConference(ppConference);
}

STDMETHODIMP CNmChannelVideo::GetInterface(IID *piid)
{
	HRESULT hr = E_POINTER;

	if (NULL != piid)
	{
		*piid = IID_INmChannelVideo;
		hr = S_OK;
	}
	return hr;
}

STDMETHODIMP CNmChannelVideo::GetNmch(ULONG *puCh)
{
	HRESULT hr = E_POINTER;

	if (NULL != puCh)
	{
		*puCh = NMCH_VIDEO;
		hr = S_OK;
	}
	return hr;
}
	
STDMETHODIMP CNmChannelVideo::EnumMember(IEnumNmMember **ppEnum)
{
	HRESULT hr = E_POINTER;
	if (NULL != ppEnum)
	{
		int cMembers = 0;
		COBLIST MemberList;
		COBLIST* pPartList = ::GetMemberList();
		if (NULL != pPartList)
		{
			POSITION pos = pPartList->GetHeadPosition();
			while (pos)
			{
				CNmMember * pMember = (CNmMember *) pPartList->GetNext(pos);
				ASSERT(NULL != pMember);

				if (NMCH_AUDIO & pMember->GetNmchCaps())
				{
					MemberList.AddTail(pMember);
					pMember->AddRef();
					cMembers++;
				}
			}
		}

		*ppEnum = new CEnumNmMember(&MemberList, cMembers);

		while (!MemberList.IsEmpty())
		{
			INmMember *pMember = (INmMember *) (CNmMember *) MemberList.RemoveHead();
			pMember->Release();
		}
		hr = (NULL != *ppEnum)? S_OK : E_OUTOFMEMORY;
	}
	return hr;
}

STDMETHODIMP CNmChannelVideo::GetMemberCount(ULONG * puCount)
{
	HRESULT hr = E_POINTER;
	if (NULL != puCount)
	{
		*puCount = m_cMembers;
		hr = S_OK;
	}
	return hr;
}

STDMETHODIMP CNmChannelVideo::IsIncoming(void)
{
	return m_fIncoming ? S_OK : S_FALSE;
}

STDMETHODIMP CNmChannelVideo::GetState(NM_VIDEO_STATE *puState)
{
	HRESULT hr = E_POINTER;
	if (NULL != puState)
	{
		*puState = m_VideoPump.GetState();
		hr = S_OK;
	}
	return hr;
}

STDMETHODIMP CNmChannelVideo::GetProperty(NM_VIDPROP uID, ULONG_PTR *puValue)
{
	HRESULT hr = S_OK;

	switch (uID)
	{
	case NM_VIDPROP_PAUSE:
		*puValue = m_VideoPump.IsPaused();
		break;
	case NM_VIDPROP_IMAGE_PREFERRED_SIZE:
		*puValue = m_VideoPump.GetFrameSize();
		break;
	case NM_VIDPROP_IMAGE_QUALITY:
		if (m_fIncoming)
		{
			*puValue = m_VideoPump.GetReceiveQuality();
		}
		break;
	case NM_VIDPROP_CAMERA_DIALOG:
		*puValue = 0;
		if (m_VideoPump.HasSourceDialog())
		{
			*puValue |= NM_VIDEO_SOURCE_DIALOG;
		}
		if (m_VideoPump.HasFormatDialog())
		{
			*puValue |= NM_VIDEO_FORMAT_DIALOG;
		}
		break;
	case NM_VIDPROP_IMAGE_SIZES:
		// get all the sizes, not just a size for one video format
		*puValue = m_VideoPump.GetFrameSizes(INVALID_MEDIA_FORMAT);
		break;
	case NM_VIDPROP_FRAME:
	{
		FRAMECONTEXT *pfc = (FRAMECONTEXT*) puValue;
		hr = m_VideoPump.GetFrame(pfc);
		break;
	}
	case NM_VIDPROP_NUM_CAPTURE_DEVS:
		*puValue = m_VideoPump.GetNumCapDev();
		break;
	case NM_VIDPROP_CAPTURE_DEV_ID:
		*puValue = m_VideoPump.GetCurrCapDevID();
		break;
	case NM_VIDPROP_MAX_CAPTURE_NAME:
		*puValue = m_VideoPump.GetMaxCapDevNameLen();
		break;
	case NM_VIDPROP_CAPTURE_LIST:
		{
			ENUM_CAP_DEV *pEnumCapDev = (ENUM_CAP_DEV *)puValue;

			return m_VideoPump.EnumCapDev(pEnumCapDev->pdwCapDevIDs,
					pEnumCapDev->pszCapDevNames,
					pEnumCapDev->dwNumCapDev);
			break;
		}
	default:
		hr = E_INVALIDARG;
		break;
	}

	return hr;
}

STDMETHODIMP CNmChannelVideo::SetProperty(NM_VIDPROP uID, ULONG_PTR uValue)
{
	HRESULT hr = S_OK;

	switch (uID)
	{
	case NM_VIDPROP_PAUSE:
		m_VideoPump.Pause(uValue);
		OnStateChange();
		break;
	case NM_VIDPROP_IMAGE_PREFERRED_SIZE:
		switch(uValue)
		{
		case NM_VIDEO_SMALL:
		case NM_VIDEO_MEDIUM:
		case NM_VIDEO_LARGE:
			m_VideoPump.SetFrameSize(uValue);
			break;
		default:
			hr = E_INVALIDARG;
			break;
		}
		break;
	case NM_VIDPROP_IMAGE_QUALITY:
		if /* ((uValue >= NM_VIDEO_MIN_QUALITY) || Always True */ ((uValue <= NM_VIDEO_MAX_QUALITY))
		{
			if (m_fIncoming)
			{
				m_VideoPump.SetReceiveQuality(uValue);
			}
		}
		else
		{
			hr = E_INVALIDARG;
		}
		break;
	case NM_VIDPROP_CAMERA_DIALOG:
		switch(uValue)
		{
		case NM_VIDEO_SOURCE_DIALOG:
			m_VideoPump.ShowSourceDialog();
			break;
		case NM_VIDEO_FORMAT_DIALOG:
			m_VideoPump.ShowFormatDialog();
			break;
		default:
			hr = E_INVALIDARG;
			break;
		}
		break;
	case NM_VIDPROP_SUSPEND_CAPTURE:
		m_VideoPump.SuspendCapture(uValue);
		break;
	case NM_VIDPROP_FRAME:
		hr = m_VideoPump.ReleaseFrame((FRAMECONTEXT *)uValue);
		break;
	case NM_VIDPROP_CAPTURE_DEV_ID:
		m_VideoPump.SetCurrCapDevID(uValue);
		break;

	default:
		hr = E_INVALIDARG;
		break;
	}
	return hr;
}

VOID __stdcall CNmChannelVideo::FrameReadyCallback(DWORD_PTR dwMyThis)
{
	CNmChannelVideo *pChannel = (CNmChannelVideo *)dwMyThis;
	if (NULL != pChannel)
	{
		pChannel->OnFrameAvailable();
	}
}


/*	O N  N O T I F Y  S T A T E  C H A N G E D	*/
/*-------------------------------------------------------------------------
	%%Function: OnNotifyStateChanged
	
-------------------------------------------------------------------------*/
HRESULT OnNotifyStateChanged(IUnknown *pChannelNotify, PVOID pv, REFIID riid)
{
	ASSERT(NULL != pChannelNotify);
	if (IID_INmChannelVideoNotify == riid)
	{
		((INmChannelVideoNotify*)pChannelNotify)->StateChanged((NM_VIDEO_STATE) (DWORD)((DWORD_PTR)pv));
	}
	return S_OK;
}

/*	O N  N O T I F Y  P R O P E R T Y  C H A N G E D  */
/*-------------------------------------------------------------------------
	%%Function: OnNotifyPropertyChanged
	
-------------------------------------------------------------------------*/
HRESULT OnNotifyPropertyChanged(IUnknown *pChannelNotify, PVOID pv, REFIID riid)
{
	ASSERT(NULL != pChannelNotify);
	if (IID_INmChannelVideoNotify == riid)
	{
		((INmChannelVideoNotify*)pChannelNotify)->PropertyChanged((DWORD)((DWORD_PTR)pv));
	}
	return S_OK;
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\core\ichnlaud.h ===
// File: ichnlaud.h

#ifndef _ICHNLAUD_H_
#define _ICHNLAUD_H_

// we have no notification on the channel "callback" that the state changed
// to determine if a/v is active we need to get both the video and the audio channel

class CNmChannelAudio : public INmChannelAudio,
	public DllRefCount, public CConnectionPointContainer
{
private:
	int				m_cMembers;
	BOOL			m_fIncoming;
	DWORD			m_dwFlags;
	IAudioChannel*	m_pAudioChannel;
	IAudioDevice *	m_pAudioDevice;
	ICommChannel*	m_pCommChannel;
	MEDIA_FORMAT_ID m_MediaFormat;
    CAudioControl   m_AudioControl;

public:
	CNmChannelAudio(BOOL fIncoming);
	~CNmChannelAudio();

	VOID CommChannelOpened(ICommChannel *pCommChannel);
	VOID CommChannelActive(ICommChannel *pCommChannel);
	VOID CommChannelClosed();
	ICommChannel * GetCommChannel() { return m_pCommChannel; }
	VOID SetFormat(MEDIA_FORMAT_ID id) { m_MediaFormat = id;}
	
	VOID OnConnected(IH323Endpoint * pConnection, ICommChannel *pIChannel)
        { m_AudioControl.OnConnected(pConnection, pIChannel); }
	VOID OnDisconnected() {	m_AudioControl.OnDisconnected(); }
	
	VOID OnMemberAdded(CNmMember *pMember);
	VOID OnMemberRemoved(CNmMember *pMember);
	VOID OnMemberUpdated(CNmMember *pMember);

	IMediaChannel *GetMediaChannelInterface(void);


	DWORD GetLevel();
	BOOL IsPaused();
	BOOL IsAutoMixing();

    VOID Open();
    VOID Close();

	// IUnknown
	STDMETHODIMP_(ULONG) AddRef(void);
	STDMETHODIMP_(ULONG) Release(void);
	STDMETHODIMP QueryInterface(REFIID riid, PVOID *ppvObj);

	// INmChannel
    STDMETHODIMP IsSameAs(INmChannel *pChannel);
    STDMETHODIMP IsActive();
    STDMETHODIMP SetActive(BOOL fActive);
    STDMETHODIMP GetConference(INmConference **ppConference);
    STDMETHODIMP GetInterface(IID *piid);
    STDMETHODIMP GetNmch(ULONG *puCh);
    STDMETHODIMP EnumMember(IEnumNmMember **ppEnum);
    STDMETHODIMP GetMemberCount(ULONG * puCount);

	// INmChannelAudio
    STDMETHODIMP IsIncoming(void);
    STDMETHODIMP GetState(NM_AUDIO_STATE *puState);
    STDMETHODIMP GetProperty(NM_AUDPROP uID, ULONG_PTR *puValue);
    STDMETHODIMP SetProperty(NM_AUDPROP uID, ULONG_PTR uValue);
};

HRESULT OnNotifyPropertyChanged(IUnknown *pAudioChannelNotify, PVOID pv, REFIID riid);
HRESULT OnNotifyStateChanged(IUnknown *pAudioChannelNotify, PVOID pv, REFIID riid);

#endif // _ICHNLAUD_H_

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\core\ichnldat.h ===
// File: ichnldat.h
//

#ifndef _ICHNLDAT_H_
#define _ICHNLDAT_H_

#include "pfnt120.h"

typedef enum _scState {               /* State of data channel */
	SCS_UNINITIALIZED = 0,           // Nothing is valid
	SCS_CREATESAP,                   // Creating m_gcc_pIAppSap
	SCS_ATTACH,                      // Attaching
	SCS_ENROLL,                      // Enrolling in a conference
	SCS_JOIN_PRIVATE,                // Join the private channel
	SCS_REGRETRIEVE,                 // Checking the registry
	SCS_REGRETRIEVE_NEW,             // new channel must be created
	SCS_REGRETRIEVE_EXISTS,          // channel already exists
	SCS_JOIN_NEW,                    // Creating a new MCS channel
	SCS_REGCHANNEL,                  // Registering the MCS channel
	SCS_JOIN_OLD,                    // Joining an existing channel
	SCS_REGPRIVATE,                  // Register the private channel
	SCS_CONNECTED,                   // m_mcs_channel_id is valid
	SCS_TERMINATING,                 // shutting down
	SCS_JOIN_STATIC_CHANNEL          // Join a static channel
} SCSTATE;


// An application key consists of an MS Object ID + guid identifier + guid + node id
#define cbKeyApp (4 + 1 + sizeof(GUID) + sizeof(DWORD))
#define MAX_CHECKID_COUNT 80  // Maximum number of times to ask for channel Id

typedef struct _tagUcid {
	DWORD     dwUserId;           // Node ID
	ChannelID channelId;          // Private channel ID
	UserID    sender_id_public;
	UserID    sender_id_private;
} UCID;

// CNmMemberId
class CNmMemberId
{
private:
	UINT      m_cCheckId;          // non-zero means checking the ID

	ChannelID m_channelId;         // Private channel ID
	UserID    m_sender_id_public;
	UserID    m_sender_id_private;

	CNmMember *m_pMember;

public:
	CNmMemberId(CNmMember *pMember, UCID *pucid);

	ChannelID GetChannelId(void)  {return m_channelId;}
	ChannelID SenderId(void)      {return m_sender_id_public;}

	VOID  UpdateRosterInfo(UCID * pucid);
	BOOL  FSenderId(UserID id)    {return ((id == m_sender_id_public) || (id == m_sender_id_private));}

	UINT  GetCheckIdCount(void)   {return m_cCheckId;}
	VOID  SetCheckIdCount(UINT c) {m_cCheckId = c;}

	CNmMember *GetMember(void)    {return m_pMember;}
};




// INmChannelData
//
class CNmChannelData : public INmChannelData2,
	public DllRefCount, public CConnectionPointContainer
{
private:
	GUID	m_guid;                  // SetGuid/GetGuid
	BOOL    m_fClosed;               // TRUE when CloseConnection is called
	BOOL    m_fActive;               // TRUE when data channel is active
	DWORD   m_dwUserIdLocal;         // Data channel needs to know local user id
	CConfObject * m_pConference;	 //	Helpful to get member list

	ULONG       m_cMember;           // Number of members in this channel
	COBLIST   * m_pListMemberId;	 // Member id list
	COBLIST	  * m_pListMember;       // Member list
	PGCCEnrollRequest	m_pGCCER;     // Enroll request from enrolling app

public:
	CNmChannelData(CConfObject * pConference, REFGUID rguid, PGCCEnrollRequest pER = NULL);
	~CNmChannelData();


	// Internal functions
	GUID * PGuid(void)      {return &m_guid;}
	VOID UpdatePeer(CNmMember * pMember, UCID *pucid, BOOL fAdd);
	VOID UpdateRoster(UCID * rgPeer, int cPeer, BOOL fAdd, BOOL fRemove);
	VOID UpdateMemberChannelId(DWORD dwUserId, ChannelID channelId);
	HRESULT OpenConnection(void);
	HRESULT CloseConnection(void);

	ULONG IsEmpty()               {return 0 == m_cMember;}
	COBLIST * GetMemberList()     {return m_pListMember;}
	VOID AddMember(CNmMember * pMember);
	VOID RemoveMember(CNmMember * pMember);

	CNmMemberId *GetMemberId(CNmMember *pMember);
	CNmMemberId *GetMemberId(DWORD dwUserId);
	VOID  UpdateRosterInfo(CNmMember *pMember, UCID * pucid);
	ChannelID GetChannelId(CNmMember *pMember);
	CNmMember *PMemberFromSenderId(UserID id);
	CConfObject * PConference() {return m_pConference;}
	DWORD GetLocalId()          {return m_dwUserIdLocal;}

	// INmChannelData methods
	HRESULT STDMETHODCALLTYPE GetGuid(GUID *pguid);
	HRESULT STDMETHODCALLTYPE SendData(INmMember *pMember, ULONG uSize, LPBYTE pb, ULONG uOptions);
	HRESULT STDMETHODCALLTYPE RegistryAllocateHandle(ULONG numberOfHandlesRequested);
	
	// INmChannel methods
	HRESULT STDMETHODCALLTYPE IsSameAs(INmChannel *pChannel);
	HRESULT STDMETHODCALLTYPE IsActive(void);
	HRESULT STDMETHODCALLTYPE SetActive(BOOL fActive);
	HRESULT STDMETHODCALLTYPE GetConference(INmConference **ppConference);
	HRESULT STDMETHODCALLTYPE GetInterface(IID *piid);
	HRESULT STDMETHODCALLTYPE GetNmch(ULONG *puCh);
	HRESULT STDMETHODCALLTYPE EnumMember(IEnumNmMember **ppEnum);
	HRESULT STDMETHODCALLTYPE GetMemberCount(ULONG * puCount);

	// IUnknown methods
	ULONG STDMETHODCALLTYPE AddRef(void);
	ULONG STDMETHODCALLTYPE Release(void);
	HRESULT STDMETHODCALLTYPE QueryInterface(REFIID riid, PVOID *ppvObj);

/////////////////////////////////////////////////////////////


// class CT120Channel

private:
	DWORD DoJoin(SCSTATE scs);

	DWORD DoJoinStatic(ChannelID staticChannel);
	DWORD DoCreateSap(void);
	DWORD DoEnroll(void);
	DWORD DoJoinPrivate(void);
	DWORD DoAttach(void);
	DWORD DoRegRetrieve(void);
	DWORD DoRegChannel(void);
	DWORD DoJoinNew(void);
	DWORD DoJoinOld(void);
	DWORD DoRegPrivate(void);

	VOID  OnEntryConfirmRemote(GCCAppSapMsg * pMsg);
	VOID  OnEntryConfirmLocal(GCCAppSapMsg * pMsg);

public:
	// Methods:
	VOID InitCT120Channel(DWORD dwUserId);

	GUID * m_pGuid;
	CNmChannelData * m_pChannel;

	DWORD   m_dwUserId;
	BYTE    m_keyApp[cbKeyApp];
	BYTE    m_keyChannel[cbKeyApp];

	SCSTATE m_scs;         // Current state

	GCCConferenceID m_gcc_conference_id;
	IGCCAppSap      *m_gcc_pIAppSap;
	GCCSessionKey   m_gcc_session_key;
	GCCRegistryKey  m_gcc_registry_key;
	GCCRegistryItem m_gcc_registry_item;

	GCCRegistryKey  m_registry_key_Private;
	GCCRegistryItem m_registry_item_Private;
	
	ChannelID       m_mcs_channel_id;  // public channel ID
	PIMCSSap	    m_pmcs_sap;

	UserID          m_gcc_node_id;

	// m_mcs_sender_id is the result of MCS_ATTACH_USER_CONFIRM.
	// It is also the "sender_id" in MCS_SEND_DATA_INDICATION
	UserID          m_mcs_sender_id;

	// Properties:
	BOOL    FConnected(void)       {return (SCS_CONNECTED == m_scs);}
	ChannelID GetMcsChannelId()    {return m_mcs_channel_id;}
	ChannelID SenderChannelId()    {return m_mcs_sender_id;}

	VOID    CloseChannel(VOID);
	HRESULT HrSendData(ChannelID channelId, DWORD dwUserId, LPVOID lpv, DWORD cb, DWORD opt);
	VOID    UpdateScState(SCSTATE scs, DWORD dwErr);
	VOID    ProcessEntryConfirm(GCCAppSapMsg * pMsg);
	BOOL    UpdateRoster(GCCAppSapMsg * pMsg);
	VOID    RemovePeer(UINT iPeer);
	VOID    RequestChannelId(DWORD dwUserId);
	VOID    NotifyChannelConnected(void);
	VOID    ProcessHandleConfirm(GCCAppSapMsg * pMsg);

};
DECLARE_STANDARD_TYPES(CNmChannelData);

void CALLBACK NmGccMsgHandler(GCCAppSapMsg * pMsg);
void CALLBACK NmMcsMsgHandler(unsigned int uMsg, LPARAM lParam, PVOID pv);

// list management
POSITION AddNode(PVOID pv, COBLIST **ppList);
PVOID RemoveNodePos(POSITION * pPos, COBLIST *pList);
VOID  RemoveNode(PVOID pv, COBLIST * pList);

// Data Notification Structure
typedef struct {
	INmMember * pMember;
	LPBYTE   pb;
	ULONG    cb;
	ULONG    dwFlags;
} NMN_DATA_XFER;


// Global Routines
VOID FreeMemberIdList(COBLIST ** ppList);
HRESULT	OnNmDataSent(IUnknown *pConferenceNotify, void *pv, REFIID riid);
HRESULT OnNmDataReceived(IUnknown *pConferenceNotify, void *pv, REFIID riid);
HRESULT	OnAllocateHandleConfirm(IUnknown *pConferenceNotify, void *pv, REFIID riid);



#endif // _ICHNLDAT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\core\ichnlaud.cpp ===
// File: ichnlaud.cpp

#include "precomp.h"
#include "ichnlaud.h"

static const IID * g_apiidCP[] =
{
    {&IID_INmChannelNotify},
    {&IID_INmChannelAudioNotify}
};

CNmChannelAudio::CNmChannelAudio(BOOL fIncoming) :
	CConnectionPointContainer(g_apiidCP, ARRAY_ELEMENTS(g_apiidCP)),
	m_cMembers	(0),
	m_dwFlags(0),
	m_pAudioChannel(NULL),
	m_pAudioDevice(NULL),
	m_pCommChannel(NULL),
	m_fIncoming(fIncoming),
	m_AudioControl(!fIncoming /* fLocal */),
	m_MediaFormat(INVALID_MEDIA_FORMAT)
{
	IMediaChannel *pMC = NULL;
	HRESULT hr;

	if (NULL != g_pH323UI)
	{
		IMediaChannelBuilder * pMCProvider = g_pH323UI->GetStreamProvider();
		ASSERT(NULL != pMCProvider);

		// create the channel, and get the device interface
		pMCProvider->CreateMediaChannel(MCF_AUDIO | (fIncoming ? MCF_RECV : MCF_SEND), &pMC);
		if (NULL != pMC)
		{
			pMCProvider->QueryInterface(IID_IAudioDevice, (void**)&m_pAudioDevice);
			pMC->QueryInterface(IID_IAudioChannel, (void**)&m_pAudioChannel);

			ASSERT(m_pAudioChannel);
			ASSERT(m_pAudioDevice);

			pMC->Release();
		}
		else
		{
			WARNING_OUT(("CreateMediaChannel failed"));
		}
		pMCProvider->Release();
	}
	
	DbgMsg(iZONE_OBJECTS, "Obj: %08X created CNmChannelAudio", this);
}

CNmChannelAudio::~CNmChannelAudio()
{
	if (NULL != m_pCommChannel)
	{
		m_pCommChannel->Release();
	}

	if (NULL != m_pAudioChannel)
	{
		m_pAudioChannel->Release();
	}

	if (NULL != m_pAudioDevice)
	{
		m_pAudioDevice->Release();
	}

	DbgMsg(iZONE_OBJECTS, "Obj: %08X destroyed CNmChannelAudio", this);
}

VOID CNmChannelAudio::CommChannelOpened(ICommChannel *pCommChannel)
{
	ASSERT(NULL == m_pCommChannel);
	m_pCommChannel = pCommChannel;
	pCommChannel->AddRef();
}
VOID CNmChannelAudio::CommChannelActive(ICommChannel *pCommChannel)
{
	ASSERT(m_pCommChannel == pCommChannel);
}

VOID CNmChannelAudio::CommChannelClosed()
{
	if (NULL != m_pCommChannel)
	{
		m_pCommChannel->Release();
		m_pCommChannel = NULL;
	}
}

VOID CNmChannelAudio::OnMemberAdded(CNmMember *pMember)
{
	// Don't add to the channel if we already belong.
	if (0 != (pMember->GetNmchCaps() & NMCH_AUDIO))
	{
		return;
	}
	
	++m_cMembers;

	pMember->AddNmchCaps(NMCH_AUDIO);

	CConfObject *pco = ::GetConfObject();
	pco->OnMemberUpdated(pMember);

	NotifySink((INmMember *) pMember, OnNotifyChannelMemberAdded);
}

VOID CNmChannelAudio::OnMemberRemoved(CNmMember *pMember)
{

	// If member does not belong to this channel, don't remove it.
	if (0 == (pMember->GetNmchCaps() & NMCH_AUDIO))
	{
		return;
	}
	
	--m_cMembers;

	pMember->RemoveNmchCaps(NMCH_AUDIO);

	CConfObject *pco = ::GetConfObject();
	pco->OnMemberUpdated(pMember);

	NotifySink((INmMember *) pMember, OnNotifyChannelMemberRemoved);
}

VOID CNmChannelAudio::OnMemberUpdated(CNmMember *pMember)
{
	NotifySink((INmMember *) pMember, OnNotifyChannelMemberUpdated);
}

DWORD CNmChannelAudio::GetLevel()
{
	UINT uLevel = 0;

	if (NULL != m_pAudioChannel)
	{
		m_pAudioChannel->GetSignalLevel(&uLevel);
	}

	return uLevel;
}


BOOL CNmChannelAudio::IsAutoMixing()
{
	BOOL bOn=FALSE;


	if ((NULL != m_pAudioChannel) && (!m_fIncoming))
	{
		bOn = m_pAudioDevice->GetAutoMix(&bOn);
	}

	return bOn;
}


BOOL CNmChannelAudio::IsPaused()
{
	BOOL fPaused = TRUE;
	if (NULL != m_pCommChannel)
	{
		DWORD dwOn = FALSE;
		UINT uSize = sizeof(dwOn);
		DWORD dwPropID = m_fIncoming ? PROP_PLAY_ON : PROP_RECORD_ON;
		m_pCommChannel->GetProperty(dwPropID, &dwOn, &uSize);
		fPaused = (0 == dwOn);
	}
	return fPaused;
}

VOID CNmChannelAudio::Open()
{
	ASSERT(m_MediaFormat !=  INVALID_MEDIA_FORMAT);
	m_AudioControl.Open(m_MediaFormat);

}

VOID CNmChannelAudio::Close()
{
	m_AudioControl.Close();
}

STDMETHODIMP_(ULONG) CNmChannelAudio::AddRef(void)
{
	return RefCount::AddRef();
}
	
STDMETHODIMP_(ULONG) CNmChannelAudio::Release(void)
{
	return RefCount::Release();
}

STDMETHODIMP CNmChannelAudio::QueryInterface(REFIID riid, PVOID *ppv)
{
	HRESULT hr = S_OK;

	if ((riid == IID_INmChannelAudio) || (riid == IID_INmChannel) || (riid == IID_IUnknown))
	{
		*ppv = (INmChannel *)this;
		DbgMsgApi("CNmChannelAudio::QueryInterface()");
	}
	else if (riid == IID_IConnectionPointContainer)
	{
		*ppv = (IConnectionPointContainer *) this;
		DbgMsgApi("CNmChannelAudio::QueryInterface(): Returning IConnectionPointContainer.");
	}
	else
	{
		hr = E_NOINTERFACE;
		*ppv = NULL;
		DbgMsgApi("CNmChannelAudio::QueryInterface(): Called on unknown interface.");
	}

	if (S_OK == hr)
	{
		AddRef();
	}

	return hr;
}

STDMETHODIMP CNmChannelAudio::IsSameAs(INmChannel *pChannel)
{
	return (((INmChannel *) this) == pChannel) ? S_OK : S_FALSE;
}

STDMETHODIMP CNmChannelAudio::IsActive()
{
	return (NULL != m_pCommChannel) ? S_OK : S_FALSE;
}

STDMETHODIMP CNmChannelAudio::SetActive(BOOL fActive)
{
	return E_FAIL;
}

STDMETHODIMP CNmChannelAudio::GetConference(INmConference **ppConference)
{
	return ::GetConference(ppConference);
}

STDMETHODIMP CNmChannelAudio::GetInterface(IID *piid)
{
	HRESULT hr = E_POINTER;

	if (NULL != piid)
	{
		*piid = IID_INmChannelAudio;
		hr = S_OK;
	}
	return hr;
}

STDMETHODIMP CNmChannelAudio::GetNmch(ULONG *puCh)
{
	HRESULT hr = E_POINTER;

	if (NULL != puCh)
	{
		*puCh = NMCH_AUDIO;
		hr = S_OK;
	}
	return hr;
}
	
STDMETHODIMP CNmChannelAudio::EnumMember(IEnumNmMember **ppEnum)
{
	HRESULT hr = E_POINTER;
	if (NULL != ppEnum)
	{
		int cMembers = 0;
		COBLIST MemberList;
		COBLIST* pPartList = ::GetMemberList();
		if (NULL != pPartList)
		{
			POSITION pos = pPartList->GetHeadPosition();
			while (pos)
			{
				CNmMember * pMember = (CNmMember *) pPartList->GetNext(pos);
				ASSERT(NULL != pMember);

				if (NMCH_AUDIO & pMember->GetNmchCaps())
				{
					MemberList.AddTail(pMember);
					pMember->AddRef();
					cMembers++;
				}
			}
		}

		*ppEnum = new CEnumNmMember(&MemberList, cMembers);

		while (!MemberList.IsEmpty())
		{
			INmMember *pMember = (INmMember *) (CNmMember *) MemberList.RemoveHead();
			pMember->Release();
		}
		hr = (NULL != *ppEnum)? S_OK : E_OUTOFMEMORY;
	}
	return hr;
}

STDMETHODIMP CNmChannelAudio::GetMemberCount(ULONG * puCount)
{
	HRESULT hr = E_POINTER;
	if (NULL != puCount)
	{
		*puCount = m_cMembers;
		hr = S_OK;
	}
	return hr;
}

STDMETHODIMP CNmChannelAudio::IsIncoming(void)
{
	return m_fIncoming ? S_OK : S_FALSE;
}

STDMETHODIMP CNmChannelAudio::GetState(NM_AUDIO_STATE *puState)
{
	HRESULT hr = E_POINTER;

	if (NULL != puState)
	{
		if (NULL != m_pCommChannel)
		{
			if (IsPaused())
			{
				*puState = NM_AUDIO_LOCAL_PAUSED;
			}
			else
			{
				*puState = NM_AUDIO_TRANSFERRING;
			}
		}
		else
		{
			*puState = NM_AUDIO_IDLE;
		}
		hr = S_OK;
	}
	return hr;
}


IMediaChannel* CNmChannelAudio::GetMediaChannelInterface(void)
{
	IMediaChannel *pMC=NULL;

	if (m_pAudioChannel)
	{
		m_pAudioChannel->QueryInterface(IID_IMediaChannel, (void**)&pMC);
	}
	return pMC;
}





STDMETHODIMP CNmChannelAudio::GetProperty(NM_AUDPROP uID, ULONG_PTR *puValue)
{
	HRESULT hr = E_POINTER;

	if (NULL != puValue)
	{
		switch (uID)
		{
		case NM_AUDPROP_LEVEL:
			*puValue = GetLevel();
			hr = S_OK;
			break;

		case NM_AUDPROP_PAUSE:
			*puValue = IsPaused();
			hr = S_OK;
			break;

		case NM_AUDPROP_AUTOMIX:
			*puValue = IsAutoMixing();
			hr = S_OK;
			break;

		default:
			hr = E_FAIL;
			break;
		}
	}
	return hr;
}

HRESULT OnNotifyPropertyChanged(IUnknown *pAudioChannelNotify, PVOID pv, REFIID riid)
{
	ASSERT(NULL != pAudioChannelNotify);
	((INmChannelAudioNotify*)pAudioChannelNotify)->PropertyChanged((DWORD)((DWORD_PTR)pv));
	return S_OK;
}

HRESULT OnNotifyStateChanged(IUnknown *pAudioChannelNotify, PVOID pv, REFIID riid)
{
	ASSERT(NULL != pAudioChannelNotify);
	((INmChannelAudioNotify*)pAudioChannelNotify)->StateChanged(static_cast<NM_AUDIO_STATE>((DWORD)((DWORD_PTR)pv)));
	return S_OK;
}


STDMETHODIMP CNmChannelAudio::SetProperty(NM_AUDPROP uID, ULONG_PTR uValue)
{
	HRESULT hr = E_FAIL;

	if ((NULL != m_pAudioDevice) && (NULL != m_pAudioChannel))
	{
		switch (uID)
		{
		case NM_AUDPROP_PAUSE:
		{
			DWORD dwOn = (0 == uValue);
			DWORD dwPropID = m_fIncoming ? PROP_PLAY_ON : PROP_RECORD_ON;
			if (m_pCommChannel)
			{
				hr = m_pCommChannel->SetProperty(dwPropID, &dwOn, sizeof(dwOn));

				if(S_OK == hr)
				{		
						// The Mute state has changed
					NotifySink((void*)NM_AUDPROP_PAUSE, OnNotifyPropertyChanged);

						// The Channel state has changed
					NM_AUDIO_STATE uState;
					if(SUCCEEDED(GetState(&uState)))
					{
						NotifySink((void*)uState, OnNotifyStateChanged);
					}
				}
			}
			break;
		}
		case NM_AUDPROP_LEVEL:
		{
			hr = m_pAudioDevice->SetSilenceLevel(uValue);
			break;
		}
		case NM_AUDPROP_FULL_DUPLEX:
		{
			DWORD dwDuplex = uValue;
			hr = m_pAudioDevice->SetDuplex((BOOL)uValue);
			break;
		}
		case NM_AUDPROP_WAVE_DEVICE:
		{
			if (m_fIncoming)
			{
				hr = m_pAudioDevice->SetPlaybackID(uValue);
			}
			else
			{
				hr = m_pAudioDevice->SetRecordID(uValue);
			}
			break;
		}

		case NM_AUDPROP_AUTOMIX:
		{
			hr = m_pAudioDevice->SetAutoMix((BOOL)uValue);
			break;
		}

		case NM_AUDPROP_DTMF_DIGIT:
		{
			IDTMFSend *pDTMF=NULL;

			if (!m_fIncoming)
			{
				hr = m_pAudioChannel->QueryInterface(IID_IDTMFSend, (void**)&pDTMF);
				if (SUCCEEDED(hr))
				{
					hr = pDTMF->AddDigit((int)uValue);
					pDTMF->Release();
				}
			}
		}

		default:
			break;
		}
	}
	return hr;
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\core\imanager.cpp ===
// File: imanager.cpp

#include "precomp.h"

extern "C"
{
	#include "t120.h"
}
#include <version.h>
#include <confcli.h>
#include "icall.h"
#include "icall_in.h"
#include "imanager.h"
#include "ichnlvid.h"
#include "isysinfo.h"
#include <tsecctrl.h>
#include <imbft.h>
#include <objbase.h>
#include <regentry.h>

#include <initguid.h>
// GUID to receive userdata from "callto:" via INmCall::GetUserData
//
// {068B0780-718C-11d0-8B1A-00A0C91BC90E}
DEFINE_GUID(GUID_CallToUserData,
0x068b0780, 0x718c, 0x11d0, 0x8b, 0x1a, 0x0, 0xa0, 0xc9, 0x1b, 0xc9, 0x0e);


class CH323ChannelEvent
{
private:
	ICommChannel *m_pIChannel;
	IH323Endpoint *m_lpConnection;
	DWORD m_dwStatus;

public:
	static DWORD ms_msgChannelEvent;

	CH323ChannelEvent(ICommChannel *pIChannel,
			IH323Endpoint *lpConnection,
			DWORD dwStatus):
		m_pIChannel(pIChannel),
		m_lpConnection(lpConnection),
		m_dwStatus(dwStatus)
	{
		if(!ms_msgChannelEvent)
		{
			ms_msgChannelEvent = RegisterWindowMessage(_TEXT("NetMeeting::H323ChannelEvent"));
		}
		
		m_pIChannel->AddRef();
		m_lpConnection->AddRef();
	}

	~CH323ChannelEvent()
	{
		m_pIChannel->Release();
		m_lpConnection->Release();
	}


	ICommChannel*	GetChannel() { return m_pIChannel; }
	IH323Endpoint*	GetEndpoint() { return m_lpConnection; }
	DWORD			GetStatus() { return m_dwStatus; }

};

//static
DWORD CH323ChannelEvent::ms_msgChannelEvent = 0;

static HRESULT OnNotifyConferenceCreated(IUnknown *pManagerNotify, PVOID pv, REFIID riid);
static HRESULT OnNotifyCallCreated(IUnknown *pManagerNotify, PVOID pv, REFIID riid);

GUID g_csguidRosterCaps = GUID_CAPS;
GUID g_csguidSecurity = GUID_SECURITY;
GUID g_csguidMeetingSettings = GUID_MTGSETTINGS;
GUID g_csguidUserString = GUID_CallToUserData;
GUID g_csguidNodeIdTag = GUID_NODEID;

// this guid is dynamically created each time we start
GUID g_guidLocalNodeId;



CH323UI* g_pH323UI = NULL;
INodeController* g_pNodeController = NULL;
SOCKADDR_IN g_sinGateKeeper;

const TCHAR cszDllHiddenWndClassName[] = _TEXT("OPNCUI_HiddenWindow");


COprahNCUI *COprahNCUI::m_pOprahNCUI = NULL;

static const IID * g_apiidCP_Manager[] =
{
    {&IID_INmManagerNotify}
};

COprahNCUI::COprahNCUI(OBJECTDESTROYEDPROC ObjectDestroyed) :
	RefCount(ObjectDestroyed),
	CConnectionPointContainer(g_apiidCP_Manager, ARRAY_ELEMENTS(g_apiidCP_Manager)),
	m_uCaps(0),
	m_pQoS(NULL),
	m_pPreviewChannel(NULL),
	m_fAllowAV(TRUE),
	m_pAVConnection(NULL),
	m_hwnd(NULL),
	m_pSysInfo(NULL),
    m_pOutgoingCallManager(NULL),
    m_pIncomingCallManager(NULL),
    m_pConfObject(NULL)
{
	DbgMsg(iZONE_OBJECTS, "Obj: %08X created CNmManager", this);
	
//	DllLock() is called by CClClassFactory::CreateInstance
	m_pOprahNCUI = this;

	ClearStruct(&g_sinGateKeeper);
	g_sinGateKeeper.sin_addr.s_addr = INADDR_NONE;

	m_pSysInfo = new CNmSysInfo();
}


COprahNCUI::~COprahNCUI()
{
	// need to unregister the H323 callback
	// need to unregister the T120 callback

	delete m_pIncomingCallManager;
	m_pIncomingCallManager = NULL;

	delete m_pOutgoingCallManager;
	m_pOutgoingCallManager = NULL;

	if( m_pSysInfo )
	{
		m_pSysInfo->Release();
		m_pSysInfo = NULL;
	}

	if (m_pConfObject)
	{
		// turn off stream notifications
		if (g_pH323UI)
		{
			IMediaChannelBuilder *pStreamProvider = NULL;
			pStreamProvider = g_pH323UI->GetStreamProvider();
			if (pStreamProvider)
			{
				pStreamProvider->SetStreamEventObj(NULL);
				pStreamProvider->Release();
			}
		}

		m_pConfObject->Release();
		m_pConfObject = NULL;
	}

	if (NULL != m_pPreviewChannel)
	{
		m_pPreviewChannel->Release();
		m_pPreviewChannel = NULL;
	}

	// Shutdown H323
	delete g_pH323UI;
	g_pH323UI = NULL;

	if (NULL != m_hwnd)
	{
		HWND hwnd = m_hwnd;
		m_hwnd = NULL;

#if 0	// if we start leaking th CH323ChannelEvents we may need to reenable this
		MSG msg;
		while (::PeekMessage(&msg, hwnd,
					CH323ChannelEvent::ms_msgChannelEvent,
					CH323ChannelEvent::ms_msgChannelEvent,
					PM_REMOVE))
		{
			CH323ChannelEvent *pEvent = reinterpret_cast<CH323ChannelEvent*>(msg.lParam);
			delete pEvent;
		}
#endif
	
		::DestroyWindow(hwnd);
	}

        if (0==UnregisterClass(cszDllHiddenWndClassName, GetInstanceHandle()))
        {
            ERROR_OUT(("COprahNCUI::~COprahNCUI - failed to unregister window class"));
        }
	// cleanup the node controller:
	if (NULL != g_pNodeController)
	{
		g_pNodeController->ReleaseInterface();
		g_pNodeController = NULL;
	}
	// Shutdown QoS
	delete m_pQoS;
    m_pQoS = NULL;

	m_pOprahNCUI = NULL;

	DbgMsg(iZONE_OBJECTS, "Obj: %08X destroyed CNmManager", this);
}

BSTR COprahNCUI::GetUserName()
{
	return m_pSysInfo ? m_pSysInfo->GetUserName() : NULL;
}

UINT COprahNCUI::GetOutgoingCallCount()
{
	return m_pOutgoingCallManager->GetCallCount();
}

VOID COprahNCUI::OnOutgoingCallCreated(INmCall* pCall)
{
	// notify the UI about this outgoing call
	NotifySink(pCall, OnNotifyCallCreated);

	if (!m_pConfObject->IsConferenceCreated())
	{
		m_pConfObject->OnConferenceCreated();
		NotifySink((INmConference*) m_pConfObject, OnNotifyConferenceCreated);
	}
}

VOID COprahNCUI::OnOutgoingCallCanceled(COutgoingCall* pCall)
{
	m_pOutgoingCallManager->RemoveFromList(pCall);
}

VOID COprahNCUI::OnIncomingCallAccepted()
{
	if (!m_pConfObject->IsConferenceCreated())
	{
		m_pConfObject->OnConferenceCreated();
		NotifySink((INmConference*) m_pConfObject, OnNotifyConferenceCreated);
	}
}

VOID COprahNCUI::OnIncomingCallCreated(INmCall* pCall)
{
	NotifySink(pCall, OnNotifyCallCreated);
}

VOID COprahNCUI::CancelCalls()
{
	m_pOutgoingCallManager->CancelCalls();
	m_pIncomingCallManager->CancelCalls();
}
			
BOOL COprahNCUI::AcquireAV(IH323Endpoint* pConnection)
{
	if (NULL == m_pAVConnection)
	{
		m_pAVConnection = pConnection;
		TRACE_OUT(("AV acquired"));
		return TRUE;
	}
	TRACE_OUT(("AV not acquired"));
	return FALSE;
}

BOOL COprahNCUI::ReleaseAV(IH323Endpoint* pConnection)
{
	if (m_pAVConnection == pConnection)
	{
		m_pAVConnection = NULL;
		TRACE_OUT(("AV released"));
		return TRUE;
	}
	return FALSE;
}




HRESULT COprahNCUI::AllowH323(BOOL fAllowAV)
{
	m_fAllowAV = fAllowAV;
	if (m_pConfObject->IsConferenceActive())
	{
		// Force a roster update
		CONF_HANDLE hConf = m_pConfObject->GetConfHandle();
		if (NULL != hConf)
		{
			ASSERT(g_pNodeController);
			hConf->UpdateUserData();
		}
	}
	return S_OK;
}

CREQ_RESPONSETYPE COprahNCUI::OnH323IncomingCall(IH323Endpoint* pConnection,
	P_APP_CALL_SETUP_DATA lpvMNMData)
{
	CREQ_RESPONSETYPE resp = m_pIncomingCallManager->OnIncomingH323Call(this, pConnection, lpvMNMData);

	if ((CRR_REJECT == resp) ||
		(CRR_BUSY == resp) ||
		(CRR_SECURITY_DENIED == resp))
	{
		ReleaseAV(pConnection);
	}

	return resp;
}


VOID COprahNCUI::OnH323Connected(IH323Endpoint * lpConnection)
{
	DebugEntry(COprahNCUI::OnH323Connected);

	if (!m_pOutgoingCallManager->OnH323Connected(lpConnection))
	{
		m_pIncomingCallManager->OnH323Connected(lpConnection);
	}
	
	DebugExitVOID(COprahNCUI::OnH323Connected);
}

VOID COprahNCUI::OnH323Disconnected(IH323Endpoint * lpConnection)
{
	DebugEntry(COprahNCUI::OnH323Disconnected);

	if (!m_pOutgoingCallManager->OnH323Disconnected(lpConnection))
	{
		m_pIncomingCallManager->OnH323Disconnected(lpConnection);
	}

	m_pConfObject->OnH323Disconnected(lpConnection, IsOwnerOfAV(lpConnection));

	ReleaseAV(lpConnection);

	DebugExitVOID(COprahNCUI::OnH323Disconnected);
}

VOID COprahNCUI::OnT120ChannelOpen(ICommChannel *pIChannel, IH323Endpoint * lpConnection, DWORD dwStatus)
{
	DebugEntry(COprahNCUI::OnT120ChannelOpen);

	m_pOutgoingCallManager->OnT120ChannelOpen(pIChannel, lpConnection, dwStatus);

	DebugExitVOID(COprahNCUI::OnT120ChannelOpen);
}


VOID COprahNCUI::OnVideoChannelStatus(ICommChannel *pIChannel, IH323Endpoint * lpConnection, DWORD dwStatus)
{
	DebugEntry(COprahNCUI::OnVideoChannelStatus);

	m_pConfObject->OnVideoChannelStatus(pIChannel, lpConnection, dwStatus);

	DebugExitVOID(COprahNCUI::OnVideoChannelStatus);
}

VOID COprahNCUI::OnAudioChannelStatus(ICommChannel *pIChannel, IH323Endpoint * lpConnection, DWORD dwStatus)
{
	DebugEntry(COprahNCUI::OnAudioChannelStatus);

	m_pConfObject->OnAudioChannelStatus(pIChannel, lpConnection, dwStatus);

	DebugExitVOID(COprahNCUI::OnAudioChannelStatus);
}

BOOL COprahNCUI::GetULSName(CRosterInfo *pri)
{
	if (FIsLoggedOn())
	{
		RegEntry reULS(	ISAPI_KEY _TEXT("\\") REGKEY_USERDETAILS,
						HKEY_CURRENT_USER);
		CUSTRING custrULSName(reULS.GetString(REGVAL_ULS_RES_NAME));
		if ((NULL != (PWSTR)custrULSName) &&
			(L'\0' != ((PWSTR)custrULSName)[0]))
		{
			pri->AddItem(g_cwszULSTag, (PWSTR)custrULSName);
			return TRUE;
		}
	}
	return FALSE;
}

VOID COprahNCUI::GetRosterInfo(CRosterInfo *pri)
{
	RegEntry reULS(	ISAPI_KEY _TEXT("\\") REGKEY_USERDETAILS,
					HKEY_CURRENT_USER);

	// This code is here in addition to the code above to fix bug 3367.
	// Add the single IP address to the list that is obtained by calling
	// gethostname() and then gethostbyname().
	// This shouldn't be detrimental, even though we may end up adding the
	// same IP address that has already been added by the code above.
	// This is because the code that looks for matching IP addresses searches
	// through all of them until it finds a match.
	CHAR szHostName[MAX_PATH];
	if (SOCKET_ERROR != gethostname(szHostName, CCHMAX(szHostName)))
	{
		HOSTENT* phe = gethostbyname(szHostName);
		if (NULL != phe)
		{
			ASSERT(phe->h_addrtype == AF_INET);
			ASSERT(phe->h_length == sizeof(DWORD));

			struct in_addr in;
			in.s_addr = *((DWORD *)phe->h_addr);
			CHAR szIPAddress[MAX_PATH];
			lstrcpyn(szIPAddress, inet_ntoa(in), CCHMAX(szIPAddress));
			pri->AddItem(	g_cwszIPTag, CUSTRING(szIPAddress));
		}
	}

	// Add the build/version string
	pri->AddItem(g_cwszVerTag, (PWSTR)VER_PRODUCTVERSION_DWSTR);
	if (FIsLoggedOn())
	{
		CUSTRING custrULSName(reULS.GetString(REGVAL_ULS_RES_NAME));
		if ((NULL != (PWSTR)custrULSName) &&
			(L'\0' != ((PWSTR)custrULSName)[0]))
		{
			pri->AddItem(g_cwszULSTag, (PWSTR)custrULSName);
		}
	}

	CUSTRING custrULSEmail(reULS.GetString(REGVAL_ULS_EMAIL_NAME));
	if ((NULL != (PWSTR)custrULSEmail) &&
		(L'\0' != ((PWSTR)custrULSEmail)[0]))
	{
		pri->AddItem(g_cwszULS_EmailTag, (PWSTR)custrULSEmail);
	}

	CUSTRING custrULSLocation(reULS.GetString(REGVAL_ULS_LOCATION_NAME));
	if ((NULL != (PWSTR)custrULSLocation) &&
		(L'\0' != ((PWSTR)custrULSLocation)[0]))
	{
		pri->AddItem(g_cwszULS_LocationTag, (PWSTR)custrULSLocation);
	}

	CUSTRING custrULSPhoneNum(reULS.GetString(REGVAL_ULS_PHONENUM_NAME));
	if ((NULL != (PWSTR)custrULSPhoneNum) &&
		(L'\0' != ((PWSTR)custrULSPhoneNum)[0]))
	{
		pri->AddItem(g_cwszULS_PhoneNumTag, (PWSTR)custrULSPhoneNum);
	}
}


ULONG COprahNCUI::GetRosterCaps()
{
	ULONG uCaps = m_uCaps;

	CNmMember * pMember = m_pConfObject->GetLocalMember();
	if (NULL != pMember)
	{
		DWORD dwFlags = pMember->GetDwFlags();
		if (dwFlags & PF_MEDIA_VIDEO)
		{
			uCaps |= CAPFLAG_VIDEO_IN_USE;
		}
		if (dwFlags & PF_MEDIA_AUDIO)
		{
			uCaps |= CAPFLAG_AUDIO_IN_USE;
		}
		if (dwFlags & PF_MEDIA_DATA)
		{
			uCaps |= CAPFLAG_DATA_IN_USE;
		}
		if (dwFlags & PF_H323)
		{
			uCaps |= CAPFLAG_H323_IN_USE;
		}
	}

	if (!m_fAllowAV)
	{
		uCaps &= ~(CAPFLAGS_AV_ALL);
	}

	return uCaps;
}


ULONG COprahNCUI::GetAuthenticatedName(PBYTE * ppb)
{
	// Buffer created here should be freed by caller.

	ULONG cb;

	if (::T120_GetSecurityInfoFromGCCID(0,NULL,&cb)) {
		(*ppb) = new BYTE[cb];
		if ((*ppb) != NULL) {
			::T120_GetSecurityInfoFromGCCID(0,*ppb,&cb);
			return cb;
		}
	}
	(* ppb) = NULL;	
	return 0;

}

HRESULT COprahNCUI::OnUpdateUserData(CONF_HANDLE hConference)
{
	CRosterInfo ri;

	// This string will contain addresses in the form:
	// L"TCP:157.55.143.3\0TCP:157.55.143.4\0\0" - 512 character max for now
	WCHAR wszAddresses[512];
	ASSERT(g_pNodeController);
	ASSERT(hConference);
	if (NOERROR == hConference->GetLocalAddressList(wszAddresses,
													CCHMAX(wszAddresses)))
	{
		ri.Load(wszAddresses);
	}

	// First, handle roster information
	GetRosterInfo(&ri);

	PVOID pvData;
	UINT cbDataLen;
	if (SUCCEEDED(ri.Save(&pvData, &cbDataLen)))
	{
	    ASSERT(g_pNodeController);
	    ASSERT(hConference);
		hConference->SetUserData(&g_csguidRostInfo,
								cbDataLen,
								pvData);
	}

	// Next, handle caps information
	ULONG uCaps = GetRosterCaps();
	ASSERT(g_pNodeController);
	ASSERT(hConference);
	hConference->SetUserData(&g_csguidRosterCaps, sizeof(uCaps), &uCaps);

	// Next, handle credentials

	if ( hConference->IsSecure() )
	{
		BYTE * pb = NULL;
		ULONG cb = GetAuthenticatedName(&pb);
		if (cb > 0) {
			ASSERT(g_pNodeController);
			ASSERT(hConference);
			TRACE_OUT(("COprahNCUI::OnUpdateUserData: adding %d bytes SECURITY data", cb));
			hConference->SetUserData(&g_csguidSecurity, cb, pb);
		}
		else
		{
			WARNING_OUT(("OnUpdateUserData: 0 bytes security data?"));
		}
		delete [] pb;			
	}

    // Next, set meeting settings if we hosted the meeting
    ASSERT(m_pConfObject);
    if (m_pConfObject->IsHosting() == S_OK)
    {
        NM30_MTG_PERMISSIONS attendeePermissions = m_pConfObject->GetConfAttendeePermissions();

        WARNING_OUT(("Hosted Meeting Settings 0x%08lx", attendeePermissions));

        hConference->SetUserData(&g_csguidMeetingSettings,
            sizeof(attendeePermissions), &attendeePermissions);
    }

	ULONG nRecords;
	GCCUserData ** ppUserData = NULL;
	if (m_pSysInfo)
	{
		m_pSysInfo->GetUserDataList(&nRecords,&ppUserData);
		for (unsigned int i = 0; i < nRecords; i++) {
			// Do not add user data that was already set above.
			if (memcmp(ppUserData[i]->octet_string->value,(PVOID)&g_csguidRostInfo,sizeof(GUID)) == 0)
				continue;
			if (memcmp(ppUserData[i]->octet_string->value,(PVOID)&g_csguidRosterCaps,sizeof(GUID)) == 0)
				continue;
			if (memcmp(ppUserData[i]->octet_string->value,(PVOID)&g_csguidSecurity,sizeof(GUID)) == 0)
				continue;
			if (memcmp(ppUserData[i]->octet_string->value,(PVOID)&g_csguidMeetingSettings,sizeof(GUID)) == 0)
                continue;

			ASSERT(g_pNodeController);
			ASSERT(hConference);
			hConference->SetUserData((GUID *)(ppUserData[i]->octet_string->value),
				ppUserData[i]->octet_string->length - sizeof(GUID), ppUserData[i]->octet_string->value + sizeof(GUID));
		}
	}

	// only add the LocalNodeId to the roster if H323 is enabled
	if (IsH323Enabled())
	{
		hConference->SetUserData((GUID *)(&g_csguidNodeIdTag), sizeof(GUID), (PVOID)&g_guidLocalNodeId);
	}
	return S_OK;
}
	
HRESULT COprahNCUI::OnIncomingInviteRequest(CONF_HANDLE hConference,
											PCWSTR pcwszNodeName,
											PT120PRODUCTVERSION pRequestorVersion,
											PUSERDATAINFO		pUserDataInfoEntries,
											UINT				cUserDataEntries,
											BOOL				fSecure)
{
	DebugEntry(COprahNCUI::OnIncomingInviteRequest);

    //  Fix an AV problem ONLY for RTC client
    if (m_pConfObject == NULL)
    {
        return S_OK;
    }
	
	if (!m_pConfObject->OnT120Invite(hConference, fSecure))
	{
		// Respond negatively - already in a call
		TRACE_OUT(("Rejecting invite - already in a call"));
		ASSERT(g_pNodeController);
		ASSERT(hConference);
		hConference->InviteResponse(FALSE);
	}
	else
	{
		m_pIncomingCallManager->OnIncomingT120Call(	this,
												TRUE,
												hConference,
												pcwszNodeName,
												pUserDataInfoEntries,
												cUserDataEntries,
												fSecure);

        //
        // This will simply notify the UI about the call state.
        //
		m_pConfObject->SetConfSecurity(fSecure);
	}

	DebugExitHRESULT(COprahNCUI::OnIncomingInviteRequest, S_OK);
	return S_OK;
}


HRESULT COprahNCUI::OnIncomingJoinRequest(	CONF_HANDLE hConference,
											PCWSTR pcwszNodeName,
											PT120PRODUCTVERSION pRequestorVersion,
											PUSERDATAINFO		pUserDataInfoEntries,
											UINT				cUserDataEntries)
{
	DebugEntry(COprahNCUI::OnIncomingJoinRequest);

	// shouldn't we be checking for an active conference before accepting a join
	// or will T120 not present this

	m_pIncomingCallManager->OnIncomingT120Call(	this,
											FALSE,
											hConference,
											pcwszNodeName,
											pUserDataInfoEntries,
											cUserDataEntries,
											m_pConfObject->IsConfObjSecure());

	DebugExitHRESULT(COprahNCUI::OnIncomingJoinRequest, S_OK);
	return S_OK;
}


HRESULT COprahNCUI::OnConferenceStarted(CONF_HANDLE hConference, HRESULT hResult)
{
	DebugEntry(COprahNCUI::OnConferenceStarted);

	if (m_pConfObject->GetConfHandle() == hConference)
	{
		m_pConfObject->OnConferenceStarted(hConference, hResult);

		m_pOutgoingCallManager->OnConferenceStarted(hConference, hResult);
	}

	DebugExitHRESULT(COprahNCUI::OnConferenceStarted, S_OK);
	return S_OK;
}

HRESULT COprahNCUI::OnQueryRemoteResult(PVOID pvCallerContext,
										HRESULT hResult,
										BOOL fMCU,
										PWSTR* ppwszConferenceNames,
										PT120PRODUCTVERSION pVersion,
										PWSTR* ppwszConfDescriptors)
{
	DebugEntry(COprahNCUI::OnQueryRemoteResult);

	if (NO_ERROR == hResult)
	{
		TRACE_OUT(("COprahNCUI: OnQueryRemoteResult Success!"));
	}
	else
	{
		TRACE_OUT(("COprahNCUI: OnQueryRemoteResult Failure!"));
	}

	m_pOutgoingCallManager->OnQueryRemoteResult(pvCallerContext,
												hResult,
												fMCU,
												ppwszConferenceNames,
												pVersion,
												ppwszConfDescriptors);
	
	DebugExitHRESULT(COprahNCUI::OnQueryRemoteResult, S_OK);
	return S_OK;
}

HRESULT COprahNCUI::OnInviteResult(	CONF_HANDLE hConference,
									REQUEST_HANDLE hRequest,
									UINT uNodeID,
									HRESULT hResult,
									PT120PRODUCTVERSION pVersion)
{
	DebugEntry(COprahNCUI::OnInviteResult);

	if (hConference == m_pConfObject->GetConfHandle())
	{
		m_pOutgoingCallManager->OnInviteResult(	hConference,
												hRequest,
												uNodeID,
												hResult,
												pVersion);
	}

	DebugExitHRESULT(COprahNCUI::OnInviteResult, S_OK);
	return S_OK;
}

HRESULT COprahNCUI::OnConferenceEnded(CONF_HANDLE hConference)
{
	DebugEntry(COprahNCUI::OnConferenceEnded);

	if (m_pConfObject && (hConference == m_pConfObject->GetConfHandle()))
	{
		m_pConfObject->OnConferenceEnded();

		m_pOutgoingCallManager->OnConferenceEnded(hConference);

		m_pIncomingCallManager->OnT120ConferenceEnded(hConference);
	}

	DebugExitHRESULT(COprahNCUI::OnConferenceEnded, S_OK);
	return S_OK;
}

HRESULT COprahNCUI::OnRosterChanged(CONF_HANDLE hConf, PNC_ROSTER pRoster)
{
	TRACE_OUT(("COprahNCUI::OnRosterChanged"));

	if (hConf == m_pConfObject->GetConfHandle())
	{
		m_pConfObject->OnRosterChanged(pRoster);
	}
	return S_OK;
}



ULONG STDMETHODCALLTYPE COprahNCUI::AddRef(void)
{
	return RefCount::AddRef();
}
	
ULONG STDMETHODCALLTYPE COprahNCUI::Release(void)
{
	return RefCount::Release();
}

HRESULT STDMETHODCALLTYPE COprahNCUI::QueryInterface(REFIID riid, PVOID *ppv)
{
	HRESULT hr = S_OK;

	if ((riid == IID_INmManager2) || (riid == IID_INmManager) || (riid == IID_IUnknown))
	{
		*ppv = (INmManager2 *)this;
		ApiDebugMsg(("COprahNCUI::QueryInterface()"));
	}
	else if (riid == IID_IConnectionPointContainer)
	{
		*ppv = (IConnectionPointContainer *) this;
		ApiDebugMsg(("COprahNCUI::QueryInterface(): Returning IConnectionPointContainer."));
	}
	else
	{
		hr = E_NOINTERFACE;
		*ppv = NULL;
		ApiDebugMsg(("COprahNCUI::QueryInterface(): Called on unknown interface."));
	}

	if (S_OK == hr)
	{
		AddRef();
	}

	return hr;
}

/*  I N I T I A L I Z E  */
/*-------------------------------------------------------------------------
    %%Function: Initialize

    REVIEW: What should the return value be if any of these parts fail
    to initialize or load?
-------------------------------------------------------------------------*/
HRESULT COprahNCUI::Initialize(ULONG *puOptions, ULONG *puchCaps)
{
	HRESULT hr = S_OK;

    // puOptions is UNUSED

    ASSERT(puchCaps);

	m_pOutgoingCallManager = new COutgoingCallManager;
    if (!m_pOutgoingCallManager)
    {
        ERROR_OUT(("COprahNCUI::Initialize -- failed to create outgoing call mgr"));
        return(E_OUTOFMEMORY);
    }

	m_pIncomingCallManager = new CIncomingCallManager;
    if (!m_pIncomingCallManager)
    {
        ERROR_OUT(("COprahNCUI::Initialize -- failed to create incoming call mgr"));
        return(E_OUTOFMEMORY);
    }

	// The lifetime of this object is up to the reference counting crap
	m_pConfObject = new CConfObject;
    if (!m_pConfObject)
    {
        ERROR_OUT(("COprahNCUI::Initialize -- failed to create conf object"));
        return(E_OUTOFMEMORY);
    }

	m_pConfObject->Init(this);

	WNDCLASS wcHidden =
	{
		0L,
		COprahNCUI::WndProc,
		0,
		0,
		GetInstanceHandle(),
		NULL,
		NULL,
		NULL,
		NULL,
		cszDllHiddenWndClassName
	};

	if (!RegisterClass(&wcHidden))
    {
        ERROR_OUT(("COprahNCUI::Initialize -- failed to register HiddenWnd class"));
        return(E_OUTOFMEMORY);
    }

	// Create a hidden window for event processing:
	m_hwnd = ::CreateWindow(cszDllHiddenWndClassName,
									_TEXT(""),
									WS_POPUP, // not visible!
									0, 0, 0, 0,
									NULL,
									NULL,
									GetInstanceHandle(),
									NULL);

	if (NULL == m_hwnd)
	{
		return E_FAIL;
	}

    //
    // INIT QOS only if AV is in the picture (otherwise, there's nothing
    // to arbitrate).
    //
    if (CAPFLAGS_AV_STREAMS & *puchCaps)
    {
    	m_pQoS = new CQoS();
	    if (NULL != m_pQoS)
    	{
		    hr = m_pQoS->Initialize();
	    	if (FAILED(hr))
    		{
		    	WARNING_OUT(("CQoS::Init() failed!"));

                // let NetMeeting hobble along without QoS.
                delete m_pQoS;
                m_pQoS = NULL;
                hr = S_FALSE; // we can live without QOS
	    	}
    	}
	    else
    	{
		    WARNING_OUT(("Could not allocate CQoS object"));
	    }
    }

    //
    // IF DATA CONFERENCING IS ALLOWED
    //
    if (CAPFLAG_DATA & *puchCaps)
    {
        //
        // Create the node controller
        //
	    hr = ::T120_CreateNodeController(&g_pNodeController, this);
    	if (FAILED(hr))
	    {
		    ERROR_OUT(("T120_CreateNodeController() failed!"));
    		return hr;
	    }
    }

	// Initialize audio/video
	if (CAPFLAGS_AV_ALL & *puchCaps)
	{
		g_pH323UI = new CH323UI();
		if (NULL != g_pH323UI)
		{
			hr = g_pH323UI->Init(m_hwnd, ::GetInstanceHandle(), *puchCaps, this, this);
			if (FAILED(hr))
			{
				WARNING_OUT(("CH323UI::Init() failed!"));
				delete g_pH323UI;
				g_pH323UI = NULL;
				*puchCaps &= ~(CAPFLAGS_AV_ALL);
				hr = S_FALSE;  // We can run without AV
			}
			else
			{
                if (CAPFLAGS_VIDEO & *puchCaps)
                {
    				// if we can get a Preview channel, we can send video
	    			m_pPreviewChannel = CNmChannelVideo::CreatePreviewChannel();
		    		if (NULL == m_pPreviewChannel)
			    	{
				    	*puchCaps &= ~CAPFLAG_SEND_VIDEO;
    				}
                }

				if (m_pConfObject && (CAPFLAGS_AV_STREAMS & *puchCaps))
				{
					IMediaChannelBuilder *pStreamProvider;

					pStreamProvider = g_pH323UI->GetStreamProvider();
					if (pStreamProvider)
					{
						pStreamProvider->SetStreamEventObj(m_pConfObject);
						pStreamProvider->Release();
					}
				}

			}
		}
		else
		{
			ERROR_OUT(("Could not allocate CH323UI object"));
		}
	}

	m_uCaps = *puchCaps;

	return CoCreateGuid(&g_guidLocalNodeId);
}



HRESULT COprahNCUI::GetSysInfo(INmSysInfo **ppSysInfo)
{
	HRESULT hr = S_OK;

	if( ppSysInfo )
	{
		if(m_pSysInfo )
		{
			m_pSysInfo->AddRef();
			*ppSysInfo = m_pSysInfo;
		}
		else
		{
			hr = E_OUTOFMEMORY;
		}
	}
	else
	{
		hr = E_POINTER;
	}

	return hr;
}

HRESULT COprahNCUI::EnumConference(IEnumNmConference **ppEnum)
{
	return E_NOTIMPL;
}

HRESULT COprahNCUI::CreateConference(	INmConference **ppConference,
										BSTR bstrName,
										BSTR bstrPassword,
										ULONG uchCaps)
{
    return(CreateConferenceEx(ppConference, bstrName, bstrPassword,
        uchCaps, NM_PERMIT_ALL, (UINT)-1));
}


HRESULT COprahNCUI::EnumCall(IEnumNmCall **ppEnum)
{
	return E_NOTIMPL;
}

HRESULT COprahNCUI::CreateCall(
    INmCall **ppCall,
    NM_CALL_TYPE callType,
    NM_ADDR_TYPE addrType,
    BSTR bstrAddress,
    INmConference * pConference)
{
	return E_NOTIMPL;
}

HRESULT COprahNCUI::CallConference(
    INmCall **ppCall,
    NM_CALL_TYPE callType,
    NM_ADDR_TYPE addrType,
    BSTR bstrAddress,
    BSTR bstrConfToJoin,
    BSTR bstrPassword)
{
	return E_NOTIMPL;
}

STDMETHODIMP COprahNCUI::GetPreviewChannel(INmChannelVideo **ppChannelVideo)
{
	HRESULT hr = E_POINTER;
	if (NULL != ppChannelVideo)
	{
		*ppChannelVideo = m_pPreviewChannel;
		if (NULL != m_pPreviewChannel)
		{
			m_pPreviewChannel->AddRef();
			hr = S_OK;
		}
		else
		{
			hr = E_FAIL;
		}
	}
	return hr;
}


STDMETHODIMP COprahNCUI::CreateASObject
(
    IUnknown *  pNotify,
    ULONG       flags,
    IUnknown ** ppAS
)
{
    return(::CreateASObject((IAppSharingNotify *)pNotify, flags,
        (IAppSharing **)ppAS));
}


HRESULT COprahNCUI::CallEx(
    INmCall **ppCall,
    DWORD dwFlags,
    NM_ADDR_TYPE addrType,
	BSTR bstrName,
    BSTR bstrSetup,
    BSTR bstrDest,
    BSTR bstrAlias,
    BSTR bstrURL,
    BSTR bstrConference,
    BSTR bstrPassword,
    BSTR bstrUserData)
{
	DebugEntry(COprahNCUI::CallEx);

	HRESULT hr = m_pOutgoingCallManager->Call(	ppCall,
												this,
												dwFlags,
												addrType,
												bstrName,
												bstrSetup,
												bstrDest,
												bstrAlias,
												bstrURL,
												bstrConference,
												bstrPassword,
												bstrUserData);

	DebugExitHRESULT(COprahNCUI::CallEx, hr);
	return hr;
}


HRESULT COprahNCUI::CreateConferenceEx
(
    INmConference **ppConference,
    BSTR            bstrName,
    BSTR            bstrPassword,
    DWORD           uchCaps,
    DWORD           attendeePermissions,
    DWORD           maxParticipants
)
{
	if (NULL == ppConference)
    {
        ERROR_OUT(("CreateConferenceEx:  null ppConference passed in"));
		return E_POINTER;
    }

    if (maxParticipants < 2)
    {
        ERROR_OUT(("CreateConferenceEx:  bad maxParticipants %d", maxParticipants));
        return E_INVALIDARG;
    }

	if (m_pConfObject->IsConferenceActive())
	{
		WARNING_OUT(("CreateConference is failing because IsConferenceActive return TRUE"));
		return NM_CALLERR_IN_CONFERENCE;
	}

	m_pConfObject->SetConfName(bstrName);
	if (uchCaps & NMCH_SRVC)
		m_pConfObject->SetConfHashedPassword(bstrPassword);
	else
		m_pConfObject->SetConfPassword(bstrPassword);


	if (uchCaps & NMCH_SECURE)
		m_pConfObject->SetConfSecurity(TRUE);
	else
		m_pConfObject->SetConfSecurity(FALSE);


    m_pConfObject->SetConfAttendeePermissions(attendeePermissions);
    m_pConfObject->SetConfMaxParticipants(maxParticipants);

	if (!m_pConfObject->IsConferenceCreated())
	{
		m_pConfObject->OnConferenceCreated();
	}

	NotifySink((INmConference*) m_pConfObject, OnNotifyConferenceCreated);


	*ppConference = m_pConfObject;
	if(*ppConference)
	{
		(*ppConference)->AddRef();
	}
	return S_OK;
}


/*  O N  N O T I F Y  C O N F E R E N C E  C R E A T E D  */
/*-------------------------------------------------------------------------
    %%Function: OnNotifyConferenceCreated

-------------------------------------------------------------------------*/
HRESULT OnNotifyConferenceCreated(IUnknown *pManagerNotify, PVOID pv, REFIID riid)
{
	ASSERT(NULL != pManagerNotify);
	((INmManagerNotify*)pManagerNotify)->ConferenceCreated((INmConference *) pv);
	return S_OK;
}

/*  O N  N O T I F Y  C A L L  C R E A T E D  */
/*-------------------------------------------------------------------------
    %%Function: OnNotifyCallCreated

-------------------------------------------------------------------------*/
HRESULT OnNotifyCallCreated(IUnknown *pManagerNotify, PVOID pv, REFIID riid)
{
	ASSERT(NULL != pManagerNotify);
	((INmManagerNotify*)pManagerNotify)->CallCreated((INmCall *) pv);
	return S_OK;
}


/*  O N  N O T I F Y  C A L L  S T A T E  C H A N G E D  */
/*-------------------------------------------------------------------------
    %%Function: OnNotifyCallStateChanged

-------------------------------------------------------------------------*/
HRESULT OnNotifyCallStateChanged(IUnknown *pCallNotify, PVOID pv, REFIID riid)
{
	ASSERT(NULL != pCallNotify);
	((INmCallNotify*)pCallNotify)->StateChanged((NM_CALL_STATE)(DWORD_PTR)pv);
	return S_OK;
}

VOID SetBandwidth(UINT uBandwidth)
{
	COprahNCUI *pOprahNCUI = COprahNCUI::GetInstance();
	if (NULL != pOprahNCUI)
	{
        pOprahNCUI->SetBandwidth(uBandwidth);
	}
	if (NULL != g_pH323UI)
	{
		//Inform the NAC of the connection speed
		g_pH323UI->SetBandwidth(uBandwidth);
	}
}


//
// BOGUS LAURABU!
// Do we need this HWND anymore?  The hidden window is used now only to
// pass to H323, which passes it to the MediaStream interfaces in the NAC,
// which passes it to DirectX.
//

LRESULT CALLBACK COprahNCUI::WndProc(HWND hwnd, UINT uMsg,
										WPARAM wParam, LPARAM lParam)
{
	
		// if ms_msgChannelEvent is 0, that means that we are not initialized
		// RegisterWindowMessage returns MSGIds in the range 0xC000 through 0xFFFF
	if(CH323ChannelEvent::ms_msgChannelEvent && CH323ChannelEvent::ms_msgChannelEvent == uMsg)
	{
		COprahNCUI *pOprahNCUI = COprahNCUI::GetInstance();
		if (pOprahNCUI)
		{
			CH323ChannelEvent *pEvent = reinterpret_cast<CH323ChannelEvent*>(lParam);
			if(pEvent)
			{
				// if we're shutting down m_hwnd will be NULL
				if (pOprahNCUI->m_hwnd)
				{
					pOprahNCUI->_ChannelEvent(
							pEvent->GetChannel(),
							pEvent->GetEndpoint(),
							pEvent->GetStatus());
				}
				delete pEvent;
			}
			else
			{
				WARNING_OUT(("Why are we getting a NULL pEvent?"));
			}
		}
		return 1;
	}

	return DefWindowProc(hwnd, uMsg, wParam, lParam);
}

PIUnknown NewNmManager(OBJECTDESTROYEDPROC ObjectDestroyed)
{
	COprahNCUI *pManager = new COprahNCUI(ObjectDestroyed);
	if (NULL != pManager)
	{
		return (INmManager2 *) pManager;
	}
	return NULL;
}


VOID COprahNCUI::_ChannelEvent (ICommChannel *pIChannel,
                IH323Endpoint * lpConnection,	DWORD dwStatus )
{
	ASSERT(pIChannel);
	GUID guidMedia;
	if (SUCCEEDED(pIChannel->GetMediaType(&guidMedia)))
	{
		if (MEDIA_TYPE_H323AUDIO == guidMedia)
		{
			OnAudioChannelStatus(pIChannel, lpConnection, dwStatus);
		}
		else if (MEDIA_TYPE_H323VIDEO == guidMedia)
		{
			OnVideoChannelStatus(pIChannel, lpConnection, dwStatus);
		}
		else if (MEDIA_TYPE_H323_T120 == guidMedia)
		{
			switch (dwStatus)
			{
				case CHANNEL_OPEN_ERROR:
				case CHANNEL_OPEN:
				case CHANNEL_CLOSED:
				case CHANNEL_REJECTED:
				case CHANNEL_NO_CAPABILITY:
					OnT120ChannelOpen(pIChannel, lpConnection, dwStatus);
					break;
				
				default:
					WARNING_OUT(("COprahNCUI::ChannelEvent - unrecognized T120 status"));
					break;				
					
			}
		}
		else
		{
			WARNING_OUT(("COprahNCUI::ChannelEvent - unknown media type"));
		}
	}
	else
	{
		WARNING_OUT(("COprahNCUI::ChannelEvent - pIChannel->GetMediaType() failed"));
	}
}

STDMETHODIMP COprahNCUI::ChannelEvent (ICommChannel *pIChannel,
                IH323Endpoint * lpConnection,	DWORD dwStatus )
{
	ASSERT(pIChannel);
	GUID guidMedia;
	if (SUCCEEDED(pIChannel->GetMediaType(&guidMedia)))
	{
		if (MEDIA_TYPE_H323_T120 == guidMedia)
		{
			if (NULL != m_hwnd)
			{
				CH323ChannelEvent* pEvent = new CH323ChannelEvent(
													pIChannel,
													lpConnection,
													dwStatus);
				if (pEvent)
				{
					PostMessage(m_hwnd,
								CH323ChannelEvent::ms_msgChannelEvent,
								0,
								reinterpret_cast<LPARAM>(pEvent));
					return S_OK;
				}
			}
		}
		else
		{
			_ChannelEvent(pIChannel, lpConnection, dwStatus);
			return S_OK;
		}
	}

	return E_FAIL;
}

#ifdef DEBUG
VOID TraceStatus(DWORD dwStatus)
{
	switch(dwStatus)
	{
		case CONNECTION_DISCONNECTED:
			TRACE_OUT(("COprahNCUI::CallEvent: CONNECTION_DISCONNECTED"));
			break;

		case CONNECTION_CONNECTED:
			TRACE_OUT(("COprahNCUI::CallEvent: CONNECTION_CONNECTED"));
			break;

		case CONNECTION_RECEIVED_DISCONNECT:
			TRACE_OUT(( "COprahNCUI::CallEvent: RECEIVED_DISCONNECT"));
			break;

		case CONNECTION_PROCEEDING:
			TRACE_OUT(("COprahNCUI::CallEvent: CONNECTION_PROCEEDING"));
			break;

		case CONNECTION_REJECTED:
			TRACE_OUT(("COprahNCUI::CallEvent: CONNECTION_REJECTED"));
			break;

		default:
			TRACE_OUT(("COprahNCUI::CallEvent: dwStatus = %d", dwStatus));
			break;
	}
}
#endif

STDMETHODIMP COprahNCUI::CallEvent(IH323Endpoint * lpConnection, DWORD dwStatus)
{

	DebugEntry(COprahNCUI::CallEvent);
	IH323CallControl * pH323CallControl = g_pH323UI->GetH323CallControl();
#ifdef DEBUG
	TraceStatus(dwStatus);
#endif

	switch (dwStatus)
	{
		case CONNECTION_DISCONNECTED:
			OnH323Disconnected(lpConnection);
			break;

		case CONNECTION_CONNECTED:
		// This is currently interpreted as CONNECTION_CAPABILITIES_READY.
		// Lower layers are continuing to post CONNECTION_CONNECTED only after
		// capabilities are exchanged. note that channels may be opened while
		// inside OnH323Connected();
			OnH323Connected(lpConnection);
			break;
	}

	DebugExitVOID(COprahNCUI::CallEvent);
	return S_OK;
}

STDMETHODIMP COprahNCUI::GetMediaChannel (GUID *pmediaID,
        BOOL bSendDirection, IMediaChannel **ppI)
{
	// delegate to the appropriate stream provider.  For the time being
	// there is only one provider that does both audio & video
		return g_pH323UI->GetMediaChannel (pmediaID, bSendDirection, ppI);
}



=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\core\iconf.cpp ===
// File: iconf.cpp

#include "precomp.h"
#include "version.h"
#include "ichnlaud.h"
#include "ichnlvid.h"
#include "ichnldat.h"
#include "rostinfo.h"
#include "imanager.h"
#include "isysinfo.h"
#include "imstream.h"
#include "medialst.h"
#include <tsecctrl.h>

typedef CEnumNmX<IEnumNmChannel, &IID_IEnumNmChannel, INmChannel, INmChannel> CEnumNmChannel;

// BUGBUG:
// This is defined as 128 because the RNC_ROSTER structure has the
// same limitation.  Investigate what the appropriate number is.
const int MAX_CALLER_NAME = 128;

static const WCHAR _szConferenceNameDefault[] = L"Personal Conference";


static HRESULT OnNotifyStateChanged(IUnknown *pConfNotify, PVOID pv, REFIID riid);
static HRESULT OnNotifyMemberAdded(IUnknown *pConfNotify, PVOID pv, REFIID riid);
static HRESULT OnNotifyMemberUpdated(IUnknown *pConfNotify, PVOID pv, REFIID riid);
static HRESULT OnNotifyMemberRemoved(IUnknown *pConfNotify, PVOID pv, REFIID riid);
static HRESULT OnNotifyChannelAdded(IUnknown *pConfNotify, PVOID pv, REFIID riid);
static HRESULT OnNotifyChannelUpdated(IUnknown *pConfNotify, PVOID pv, REFIID riid);
static HRESULT OnNotifyChannelRemoved(IUnknown *pConfNotify, PVOID pv, REFIID riid);
static HRESULT OnNotifyNmUI(IUnknown *pConfNotify, PVOID pv, REFIID riid);
static HRESULT OnNotifyStreamEvent(IUnknown *pConfNotify, PVOID pv, REFIID riid);


static DWORD PF_VER_FromDw(DWORD dw);
static DWORD PF_VER_FromUserData(ROSTER_DATA_HANDLE hUserData);

static const IID * g_apiidCP[] =
{
    {&IID_INmConferenceNotify},
    {&IID_INmConferenceNotify2}
};

struct StreamEventInfo
{
	INmChannel *pChannel;
	NM_STREAMEVENT uEventCode;
	UINT uSubCode;
};

class CUserDataOut
{
private:
	int m_nEntries;
	PUSERDATAINFO m_pudi;
	CRosterInfo m_ri;
	PBYTE m_pbSecurity;

public:
		CUserDataOut(BOOL fSecure, BSTR bstrUserString);
		~CUserDataOut()
		{
			delete [] m_pbSecurity;
			delete [] m_pudi;
		}

		PUSERDATAINFO Data() { return m_pudi; }
		int Entries() { return m_nEntries; }
};

CUserDataOut::CUserDataOut(BOOL fSecure, BSTR bstrUserString) :
	m_nEntries(0),
	m_pudi(NULL),
	m_pbSecurity(NULL)
{
	COprahNCUI *pOprahNCUI = COprahNCUI::GetInstance();
	if (NULL != pOprahNCUI)
	{
		BOOL fULSNameValid = FALSE;

		ULONG cbSecurity = 0;
		ULONG cbUserString = 0;

		if (fULSNameValid = pOprahNCUI->GetULSName(&m_ri))
			m_nEntries++;

		DWORD dwResult;
		if ( fSecure )
		{
			if (cbSecurity = 
					pOprahNCUI->GetAuthenticatedName(&m_pbSecurity)) {
				m_nEntries++;
			}
		}
		
		if (bstrUserString)
		{
			if (cbUserString = SysStringByteLen(bstrUserString))
			{
				m_nEntries++;
			}
		}

		// only add the LocalNodeId to the call user data if H323 is enabled
		if (pOprahNCUI->IsH323Enabled())
		{
			m_nEntries++;
		}

		m_pudi = new USERDATAINFO[m_nEntries];

		if (m_pudi != NULL)
		{
			
			m_nEntries = 0;

			if (fULSNameValid)
			{
				m_pudi[m_nEntries].pData = NULL;
				m_pudi[m_nEntries].pGUID = (PGUID) &g_csguidRostInfo;
				m_ri.Save(&(m_pudi[m_nEntries].pData), &(m_pudi[m_nEntries].cbData));
				m_nEntries++;

			}

			if (cbSecurity > 0) {
				m_pudi[m_nEntries].pData = m_pbSecurity;
				m_pudi[m_nEntries].cbData = cbSecurity;
				m_pudi[m_nEntries].pGUID = (PGUID) &g_csguidSecurity;
				m_nEntries++;
			}

			if (cbUserString > 0) {
				m_pudi[m_nEntries].pData = bstrUserString;
				m_pudi[m_nEntries].cbData = cbUserString;
				m_pudi[m_nEntries].pGUID = (PGUID) &g_csguidUserString;
				m_nEntries++;
			}

			// only add the LocalNodeId to the call user data if H323 is enabled
			if (pOprahNCUI->IsH323Enabled())
			{
				m_pudi[m_nEntries].pData = &g_guidLocalNodeId;
				m_pudi[m_nEntries].cbData = sizeof(g_guidLocalNodeId);
				m_pudi[m_nEntries].pGUID = (PGUID) &g_csguidNodeIdTag;
				m_nEntries++;
			}
		}
	}
}

CConfObject::CConfObject() :
	CConnectionPointContainer(g_apiidCP, ARRAY_ELEMENTS(g_apiidCP)),
	m_hConf				(NULL),
	m_csState			(CS_UNINITIALIZED),
	m_fConferenceCreated(FALSE),
	m_bstrConfName      (NULL),
	m_bstrConfPassword  (NULL),
	m_pbConfHashedPassword    (NULL),
	m_cbConfHashedPassword	(0),
	m_fServerMode		(FALSE),
	m_uDataMembers		(0),
	m_uMembers			(0),
	m_uH323Endpoints	(0),
	m_ourNodeID			(0),
	m_pMemberLocal      (NULL),
	m_uGCCConferenceID	(0),
	m_pChannelAudioLocal(NULL),
	m_pChannelVideoLocal(NULL),
	m_pChannelAudioRemote(NULL),
	m_pChannelVideoRemote(NULL),
	m_fSecure			(FALSE),
    m_attendeePermissions (NM_PERMIT_ALL),
    m_maxParticipants   (-1),
	m_cRef				(1)
{
	DebugEntry(CConfObject::CConfObject);

	DebugExitVOID(CConfObject::CConfObject);
}

CConfObject::~CConfObject()
{
	DebugEntry(CConfObject::~CConfObject);

	// Empty the participant list:
	while (!m_MemberList.IsEmpty())
	{
		CNmMember * pMember = (CNmMember *) m_MemberList.RemoveHead();
		// Shouldn't have any NULL entries:
		ASSERT(pMember);
		pMember->Release();
	}

	_EraseDataChannelGUIDS();

	SysFreeString(m_bstrConfName);
	SysFreeString(m_bstrConfPassword);
	delete []m_pbConfHashedPassword;

	DebugExitVOID(CConfObject::~CConfObject);
}

VOID CConfObject::SetConfName(BSTR bstr)
{
	SysFreeString(m_bstrConfName);
	m_bstrConfName = SysAllocString(bstr);
}

VOID CConfObject::SetConfPassword(BSTR bstr)
{
	ASSERT (NULL == m_pbConfHashedPassword);
	SysFreeString(m_bstrConfPassword);
	m_bstrConfPassword = SysAllocString(bstr);
}

VOID CConfObject::SetConfHashedPassword(BSTR bstr)
{
	int cch = 0;

	ASSERT (NULL == m_bstrConfPassword);
	delete []m_pbConfHashedPassword;
        m_pbConfHashedPassword = NULL;
	if (NULL == bstr) return;
	cch = SysStringByteLen(bstr);
        m_pbConfHashedPassword = (PBYTE) new BYTE[cch];
        if (NULL == m_pbConfHashedPassword) {
		ERROR_OUT(("CConfObject::SetConfHashedPassword() - Out of merory."));
		return;
	}
	memcpy(m_pbConfHashedPassword, bstr, cch);
	m_cbConfHashedPassword = cch;
}

VOID CConfObject::SetConfSecurity(BOOL fSecure)
{
	NM_CONFERENCE_STATE NmState;

	m_fSecure = fSecure;

	// Force update of the status icon to reflect security
	GetState(&NmState);
	NotifySink((PVOID) NmState, OnNotifyStateChanged);
}


VOID CConfObject::SetConfAttendeePermissions(NM30_MTG_PERMISSIONS attendeePermissions)
{
    m_attendeePermissions = attendeePermissions;
}


VOID CConfObject::SetConfMaxParticipants(UINT maxParticipants)
{
    m_maxParticipants = maxParticipants;
}



HRESULT CConfObject::CreateConference(void)
{
	DebugEntry(CConfObject::CreateConference);
	HRESULT nsRet = E_FAIL;

	switch (m_csState)
	{
		case CS_UNINITIALIZED:
		case CS_TERMINATED:
		{
			if ((NULL == m_bstrConfName) || (0 == *m_bstrConfName))
			{
				m_bstrConfName = SysAllocString(_szConferenceNameDefault);
			}
			TRACE_OUT(("CConfObject:CreateConference [%ls]", m_bstrConfName));
			
			ASSERT(g_pNodeController);
			ASSERT(NULL == m_hConf);
			nsRet = g_pNodeController->CreateConference(
											m_bstrConfName,
											m_bstrConfPassword,
											m_pbConfHashedPassword,
											m_cbConfHashedPassword,
											m_fSecure,
											&m_hConf);
			
			if (0 == nsRet)
			{
				SetT120State(CS_CREATING);
			}
			else
			{
				m_hConf = NULL;
			}
			break;
		}

		default:
		{
			WARNING_OUT(("CConfObject: Can't create - bad state"));
			nsRet = E_FAIL;
		}
	}
	
	DebugExitINT(CConfObject::CreateConference, nsRet);
	return nsRet;
}

HRESULT CConfObject::JoinConference(    LPCWSTR pcwszConferenceName,
										LPCWSTR	pcwszPassword,
									 	LPCSTR	pcszAddress,
										BSTR bstrUserString,
										BOOL fRetry)
{
	DebugEntry(CConfObject::JoinConference);
	HRESULT nsRet = E_FAIL;



	switch (m_csState)
	{
		case CS_COMING_UP:
		{
			if (!fRetry)
			{
				break;
			}
			// fall through if this is another attempt to join
		}
		case CS_UNINITIALIZED:
		case CS_TERMINATED:
		{
			TRACE_OUT(("CConfObject: Joining conference..."));
			
			CUserDataOut userData(m_fSecure, bstrUserString);

			ASSERT(g_pNodeController);
			nsRet = g_pNodeController->JoinConference(pcwszConferenceName,
														pcwszPassword,
														pcszAddress,
														m_fSecure,
														userData.Data(),
														userData.Entries(),
														&m_hConf);
			
			if (0 == nsRet)
			{
				SetT120State(CS_COMING_UP);
			}
			else
			{
				m_hConf = NULL;
			}
			break;
		}

		case CS_GOING_DOWN:
		default:
		{
			WARNING_OUT(("CConfObject: Can't join - bad state"));
			// BUGBUG: define return values
			nsRet = 1;
		}
	}
	
	DebugExitINT(CConfObject::JoinConference, nsRet);

	return nsRet;
}



HRESULT CConfObject::InviteConference(	LPCSTR	Address,
										BSTR bstrUserString,
										REQUEST_HANDLE *phRequest )
{
	DebugEntry(CConfObject::InviteConference);
	HRESULT nsRet = E_FAIL;
	ASSERT(phRequest);

	switch (m_csState)
	{
		case CS_RUNNING:
		{
			TRACE_OUT(("CConfObject: Inviting conference..."));
			
			CUserDataOut userData(m_fSecure, bstrUserString);

			ASSERT(g_pNodeController);
			ASSERT(m_hConf);
			m_hConf->SetSecurity(m_fSecure);
			nsRet = m_hConf->Invite(Address,
									userData.Data(),
									userData.Entries(),
									phRequest);
			
			break;
		}

		default:
		{
			WARNING_OUT(("CConfObject: Can't invite - bad state"));
			nsRet = E_FAIL;
		}
	}
	
	DebugExitINT(CConfObject::InviteConference, nsRet);
	return nsRet;
}
	
HRESULT CConfObject::LeaveConference(BOOL fForceLeave)
{
	DebugEntry(CConfObject::LeaveConference);
	HRESULT nsRet = E_FAIL;
	REQUEST_HANDLE hReq = NULL;

	switch (m_csState)
	{
		case CS_GOING_DOWN:
		{
			// we're already going down
			nsRet = S_OK;
			break;
		}
	
		case CS_COMING_UP:
		case CS_RUNNING:
		{
			if (FALSE == fForceLeave)
			{
				COprahNCUI *pOprahNCUI = COprahNCUI::GetInstance();
				if (NULL != pOprahNCUI)
				{
					int nNodes = pOprahNCUI->GetOutgoingCallCount();

					if (m_fServerMode || (nNodes > 1) || (m_uDataMembers > 1))
					{
						// We are either in the process of calling another node
						// or we have other people in our conference roster
						TRACE_OUT(("CConfObject: Not leaving (there are other nodes)"));
						break;
					}
				}
			}
			
			TRACE_OUT(("CConfObject: Leaving conference..."));
			
			ASSERT(g_pNodeController);
			ASSERT(m_hConf);
			
			SetT120State(CS_GOING_DOWN);
			nsRet = m_hConf->Leave();
			break;
		}

		default:
		{
			WARNING_OUT(("CConfObject: Can't leave - bad state"));
			break;
		}
	}
	
	DebugExitINT(CConfObject::LeaveConference, nsRet);
	return nsRet;
}
	

BOOL CConfObject::OnT120Invite(CONF_HANDLE hConference, BOOL fSecure)
{
	DebugEntry(CConfObject::OnT120Invite);

	BOOL bRet = FALSE;

	switch (m_csState)
	{
		case CS_UNINITIALIZED:
		case CS_TERMINATED:
		{
			TRACE_OUT(("CConfObject: Accepting a conference invitation..."));
			
			ASSERT(g_pNodeController);
			ASSERT(NULL == m_hConf);
			m_hConf = hConference;

            m_fSecure = fSecure;
			hConference->SetSecurity(m_fSecure);

			// WORKITEM need to issue INmManagerNotify::ConferenceCreated()
			SetT120State(CS_COMING_UP);

			bRet = TRUE;
			break;
		}

		default:
		{
			WARNING_OUT(("CConfObject: Can't accept invite - bad state"));
		}
	}
	
	DebugExitBOOL(CConfObject::OnT120Invite, bRet);
	return bRet;
}

BOOL CConfObject::OnRosterChanged(PNC_ROSTER pRoster)
{
	DebugEntry(CConfObject::OnRosterChanged);

	BOOL bRet = TRUE;
	int i;

	// REVIEW: Could these be done more efficiently?
	
	if (NULL != pRoster)
	{
#ifdef DEBUG
		TRACE_OUT(("Data Roster Dump: for conference ID = %d", pRoster->uConferenceID));
		for (i = 0; i < (int) pRoster->uNumNodes; i++)
		{
			TRACE_OUT((	"\tID:%d\tName:%ls", 
						pRoster->nodes[i].uNodeID,
						pRoster->nodes[i].pwszNodeName));

		    ASSERT(g_pNodeController);
			UINT cbData;
			PVOID pData;
			if (NOERROR == g_pNodeController->GetUserData(
									pRoster->nodes[i].hUserData, 
									(GUID*) &g_csguidRostInfo, 
									&cbData, 
									&pData))
			{
				CRosterInfo ri;
				ri.Load(pData);
				ri.Dump();
			}
		}
#endif // DEBUG

		UINT nExistingParts = 0;
		// Allocate an array of markers:
		UINT uRosterNodes = pRoster->uNumNodes;
		LPBOOL pMarkArray = new BOOL[uRosterNodes];

		m_ourNodeID = pRoster->uLocalNodeID;
		m_uGCCConferenceID = pRoster->uConferenceID;

		if (NULL != pRoster->pwszConferenceName)
		{
			SysFreeString(m_bstrConfName);
			m_bstrConfName = SysAllocString(pRoster->pwszConferenceName);
		}
		
		if (NULL != pMarkArray)
		{
			// Zero out the array:
            for (UINT i = 0; i < uRosterNodes; i++)
            {
                pMarkArray[i] = FALSE;
            }
			
			// For all participants still in the roster,
			//   clear out the reserved flags and
			//   copy in new UserInfo
			POSITION pos = m_MemberList.GetHeadPosition();
            // lous: Preserve previous pos so we can check list integrity
            POSITION prevpos = pos;
			while (NULL != pos)
			{
				CNmMember * pMember = (CNmMember *) m_MemberList.GetNext(pos);
				ASSERT(pMember);
				pMember->RemovePf(PF_RESERVED);
				UINT uNodeID = INVALID_GCCID;
				if (PF_T120 & pMember->GetDwFlags())
				{
					uNodeID = pMember->GetGCCID();
				}
				
				for (UINT uNode = 0; uNode < uRosterNodes; uNode++)
				{
					if (uNodeID == pRoster->nodes[uNode].uNodeID)
					{
						nExistingParts++;
						pMarkArray[uNode] = TRUE;	// mark this node as "existing member"
						ResetDataMember(pMember, pRoster->nodes[uNode].hUserData);
                        // lou: Check pos to make sure we didn't just wipe out the end of
                        // the list in ResetDataMember.
                        if (NULL == prevpos->pNext)
                        {
                            pos = NULL;
                        }
						break;
					}
				}
                // lou: Store previous pos so we can check list integrity.
                prevpos = pos;
			}
			
			RemoveOldDataMembers(m_uDataMembers - nExistingParts);

			if (pRoster->uNumNodes > nExistingParts)
			{
#ifdef _DEBUG
				UINT nAdded = 0;
#endif // _DEBUG
				// At least one participant joined:
				// find the new participant(s)
				for (UINT uNode = 0; uNode < uRosterNodes; uNode++)
				{
					if (FALSE == pMarkArray[uNode]) 	// a new participant?
					{
						BOOL fLocal = FALSE;
						CNmMember * pMember = NULL;
						PVOID pvUserInfo;
						UINT cbUserInfo;
						ASSERT(g_pNodeController);
						if (NOERROR != g_pNodeController->GetUserData(
												pRoster->nodes[uNode].hUserData, 
												(GUID*) &g_csguidRostInfo, 
												&cbUserInfo, 
												&pvUserInfo))
						{
							pvUserInfo = NULL;
							cbUserInfo = 0;
						}
						
						
						UINT uCaps;
						UINT cbCaps;
						PVOID pvCaps;
						if (NOERROR != g_pNodeController->GetUserData(
												pRoster->nodes[uNode].hUserData, 
												(GUID*) &g_csguidRosterCaps, 
												&cbCaps, 
												&pvCaps))
						{
							uCaps = 0;
						}
						else
						{
							ASSERT(pvCaps && (sizeof(uCaps) == cbCaps));
							uCaps = *((PUINT)pvCaps);
						}

						PGUID pguidNodeId;
						UINT cbNodeId;
						if (NOERROR != g_pNodeController->GetUserData(
												pRoster->nodes[uNode].hUserData, 
												(GUID*) &g_csguidNodeIdTag, 
												&cbNodeId,
												(PVOID*) &pguidNodeId))
						{
							pguidNodeId = NULL;
						}
						else
						{
							if (sizeof(GUID) != cbNodeId)
							{
								pguidNodeId = NULL;
							}
						}

						if (m_ourNodeID == pRoster->nodes[uNode].uNodeID)
						{
							fLocal = TRUE;
						}
			
						REFGUID rguidNodeId = pguidNodeId ? *pguidNodeId : GUID_NULL;

						if (fLocal)
						{
							pMember = GetLocalMember();
						}
						else
						{
							pMember = MatchDataToH323Member(rguidNodeId, pRoster->nodes[uNode].uNodeID, pvUserInfo);
						}

						if(pMember)
						{
								AddDataToH323Member(pMember,
													pvUserInfo,
													cbUserInfo,
													uCaps,
													&pRoster->nodes[uNode]);
#ifdef _DEBUG
								nAdded++; // a data participant was effectively added
#endif // _DEBUG
						}
						else
						{
							pMember = CreateDataMember(
												fLocal,
												rguidNodeId,
												pvUserInfo,
												cbUserInfo,
												uCaps,
												&pRoster->nodes[uNode]);
#ifdef _DEBUG
							if (NULL != pMember)
							{
								nAdded++;
							}
#endif // _DEBUG
							AddMember(pMember, NULL);
						}
					}
				}
				// Validate that we did the right thing:
				ASSERT(nAdded == (uRosterNodes - nExistingParts));
			}
			delete pMarkArray;
			pMarkArray = NULL;
		}
		else
		{
			ERROR_OUT(("Couldn't allocate pMarkArray - no roster diff done"));
		}

		UINT uPrevDataMembers = m_uDataMembers;
		
		m_uDataMembers = pRoster->uNumNodes;

		// Check to decide if we should auto-terminate here..
		if ((1 == pRoster->uNumNodes) &&
			(uPrevDataMembers > 1) &&
			(1 == m_uDataMembers))
		{
			if (!m_fServerMode)
			{
				LeaveConference(FALSE); // don't force (we could be inviting)
			}
		}	
	}
	else
	{
		WARNING_OUT(("NULL pRoster passed to CConfObject::OnRosterChanged!"));
	}

	DebugExitBOOL(CConfObject::OnRosterChanged, bRet);
	return bRet;
}

VOID CConfObject::AddMember(CNmMember * pMember, IH323Endpoint * pConnection)
{
	DebugEntry(CConfObject::AddMember);

	if (NULL == pMember)
	{
		ERROR_OUT(("AddMember - null member!"));
		return;
	}

	NM_CONFERENCE_STATE oldNmState, newNmState;
	GetState(&oldNmState);

	m_MemberList.AddTail(pMember);
	if(pConnection)
	{
		pMember->AddH323Endpoint(pConnection);
		++m_uH323Endpoints;

		CheckState(oldNmState);
		GetState(&oldNmState);
	}
	m_uMembers++;

	CheckState(oldNmState);

	NotifySink((INmMember *) pMember, OnNotifyMemberAdded);

	DebugExitVOID(CConfObject::AddMember);
}

VOID CConfObject::RemoveMember(POSITION pos)
{
	DebugEntry(CConfObject::RemoveMember);

	NM_CONFERENCE_STATE oldNmState, newNmState;

	GetState(&oldNmState);

	CNmMember * pMember = (CNmMember *) m_MemberList.RemoveAt(pos);
	--m_uMembers;

	if (pMember->FLocal())
	{
		// this is the local node:
		m_pMemberLocal = NULL;
	}

	IH323Endpoint *pConnection = pMember->GetH323Endpoint();
	if(pConnection)
	{
		pMember->DeleteH323Endpoint(pConnection);
		--m_uH323Endpoints;
	}

	NotifySink((INmMember *) pMember, OnNotifyMemberRemoved);
	pMember->Release();

	CheckState(oldNmState);

	DebugExitVOID(CConfObject::RemoveMember);
}

BOOL CConfObject::OnConferenceEnded()
{
	DebugEntry(CConfObject::OnConferenceEnded);
	BOOL bRet = TRUE;

	switch (m_csState)
	{
		case CS_GOING_DOWN:
		{
			TRACE_OUT(("ConfEnded received (from CS_GOING_DOWN)"));
			break;
		}

		case CS_RUNNING:
		{
			TRACE_OUT(("ConfEnded received (from CS_RUNNING)"));
			break;
		}

		case CS_COMING_UP:
		{
			TRACE_OUT(("ConfEnded received (from CS_COMING_UP)"));
			break;
		}

		default:
		{
			WARNING_OUT(("ConfEnded received (UNEXPECTED)"));
		}
	}

	if (NULL != m_hConf)
	{
		m_hConf->ReleaseInterface();
		m_hConf = NULL;
	}
	SetT120State(CS_TERMINATED);

	TRACE_OUT(("OnConferenceEnded(), num participants is %d", m_uMembers));

	// Empty the participant list:
	NC_ROSTER FakeRoster;
	ClearStruct(&FakeRoster);
	FakeRoster.uConferenceID = m_uGCCConferenceID;
	OnRosterChanged(&FakeRoster);

	ASSERT(0 == m_ourNodeID);
	ASSERT(0 == m_uDataMembers);

	// Reset member variables that pertain to a conference
	m_uGCCConferenceID = 0;
	m_fServerMode = FALSE;
    m_attendeePermissions = NM_PERMIT_ALL;
    m_maxParticipants = (UINT)-1;

	SysFreeString(m_bstrConfName);
	m_bstrConfName = NULL;
	SysFreeString(m_bstrConfPassword);
	m_bstrConfPassword = NULL;

	LeaveH323(TRUE /* fKeepAV */);
	
	DebugExitBOOL(CConfObject::OnConferenceEnded, bRet);
	return bRet;
}

BOOL CConfObject::OnConferenceStarted(CONF_HANDLE hConf, HRESULT hResult)
{
	DebugEntry(CConfObject::OnConferenceStarted);
	BOOL bRet = TRUE;

	ASSERT(hConf == m_hConf);

	switch (m_csState)
	{
		case CS_CREATING:
		case CS_COMING_UP:
		{
			switch(hResult)
			{
				case S_OK:
					TRACE_OUT(("ConfStarted received -> now running"));
					SetT120State(CS_RUNNING);
					break;
				case UI_RC_INVALID_PASSWORD:
					// nop, don't mess with state
					// the conference is still coming up
					// the incoming call handler will deal with this
					break;
				default:
					SetT120State(CS_GOING_DOWN);
					TRACE_OUT(("ConfStarted failed"));
					break;
			}
			break;
		}

		default:
		{
			WARNING_OUT(("OnConferenceStarted received (UNEXPECTED)"));
			break;
		}
	}

	DebugExitBOOL(CConfObject::OnConferenceStarted, bRet);
	return bRet;
}

VOID CConfObject::OnH323ChannelChange(DWORD dwFlags, BOOL fIncoming, BOOL fOpen, ICommChannel *pIChannel)
{
	CConfObject *pco = ::GetConfObject();
	IEnumNmMember *pEnumMember = NULL;
	ULONG cFetched;
	INmChannel *pINmChannel;
	DWORD dwMediaFlag;
	HRESULT hr;
	// find the INmChannel instance that would be associated with the
	// comm channel (pIChannel).  

	// note the current issues with making this work for any number/type of
	// channels
	//
	//	- CConfObject has 4 hardcoded instances of send/receive audio/video
	//	- Those instances aren't yet associated with the ICommChannel instance
	//		other than by media type and direction.  For receive, new instances
	//		could even be created dynamically as rx channel requests are 
	//		processed.  For send, need to change CNmChannelAudio
	//		and CNmChannelVideo to keep a reference to ICommChannel before 
	//		the channel open attempt occurs
	//	- There is no base interface common to CNmChannelAudio
	//		and CNmChannelVideo
	//	- There is no internal interface on CNmMember
	//	
	
	CNmMember *pMember = NULL;
	INmMember *pIMember = NULL;

	if (PF_MEDIA_AUDIO & dwFlags)
	{
		dwMediaFlag = PF_MEDIA_AUDIO;
		CNmChannelAudio *pChannelAudio;
		if (fIncoming)
		{
			pChannelAudio = m_pChannelAudioRemote;
		}
		else
		{
			pChannelAudio = m_pChannelAudioLocal;
		}
		if (NULL != pChannelAudio)
		{
			pINmChannel = (INmChannel *) pChannelAudio;
			if (fOpen)
			{
				pChannelAudio->CommChannelOpened(pIChannel);
			}
			else
			{
				pChannelAudio->CommChannelClosed();
			}
			
			// for every member associated with this channel, do the
			// member update thing
			
			hr = pChannelAudio->EnumMember(&pEnumMember);
			if(pEnumMember)
			{
				ASSERT(hr == S_OK);

				while(hr == S_OK)
				{
					pIMember = NULL;
	           		hr = pEnumMember->Next(1, &pIMember, &cFetched);
     				if(!pIMember)
     				{
     					break;
     				}
     				else
					{
						ASSERT(hr == S_OK);
						// this cast is ugly, but necessary because there is no
						// real internal interface of CNmMember to query for.
						// When in Rome........
						pMember = (CNmMember *)pIMember;

						if (fOpen)
						{
							pMember->AddPf(dwMediaFlag);
						}
						else
						{
							pMember->RemovePf(dwMediaFlag);
						}
						// ugly - OnMemberUpdated() should be a base interface
						// method so that this code didn't have to be copied
						// for the video case
						pChannelAudio->OnMemberUpdated(pMember);
						pco->OnMemberUpdated(pMember);

						if (pMember->FLocal() && (NULL != m_hConf) && (CS_RUNNING == m_csState))
						{
//							m_hConf->UpdateUserData();
						}
						pMember->Release();
					}
				}
				pEnumMember->Release();
			}
			NotifySink(pINmChannel, OnNotifyChannelUpdated);
		}
	}
	else if (PF_MEDIA_VIDEO & dwFlags)
	{
		dwMediaFlag = PF_MEDIA_VIDEO;
		CNmChannelVideo *pChannelVideo;
		if (fIncoming)
		{
			pChannelVideo = m_pChannelVideoRemote;
		}
		else
		{
			pChannelVideo = m_pChannelVideoLocal;
		}
		if (NULL != pChannelVideo)
		{
			pINmChannel = (INmChannel *) pChannelVideo;
			if (fOpen)
			{
				pChannelVideo->CommChannelOpened(pIChannel);
			}
			else
			{
				pChannelVideo->CommChannelClosed();
			}

			// for every member associated with this channel, do the
			// member update thing
		
			hr = pChannelVideo->EnumMember(&pEnumMember);
			if(pEnumMember)
			{
				ASSERT(hr == S_OK);
				while(hr == S_OK)
				{
					pIMember = NULL;
	           		hr = pEnumMember->Next(1, &pIMember, &cFetched);
     				if(!pIMember)
     				{
     					break;
     				}
     				else
					{
						ASSERT(hr == S_OK);
						// this cast is ugly, but necessary because there is no
						// real internal interface of CNmMember to query for.
						// When in Rome........
						pMember = (CNmMember *)pIMember;

						if (fOpen)
						{
							pMember->AddPf(dwMediaFlag);
						}
						else
						{
							pMember->RemovePf(dwMediaFlag);
						}
						// ugly - OnMemberUpdated() should be a base interface
						// method so that this code didn't have to be copied
						// from the audio case
						pChannelVideo->OnMemberUpdated(pMember);
						pco->OnMemberUpdated(pMember);

						if (pMember->FLocal() && (NULL != m_hConf) && (CS_RUNNING == m_csState))
						{
//							m_hConf->UpdateUserData();
						}
						pMember->Release();
					}
				}
				pEnumMember->Release();
			}
			NotifySink(pINmChannel, OnNotifyChannelUpdated);
		
		}
	}
	else
		ASSERT(0);
}


VOID CConfObject::OnAudioChannelStatus(ICommChannel *pIChannel, IH323Endpoint * lpConnection, DWORD dwStatus)
{
	BOOL bIncoming = (pIChannel->IsSendChannel())? FALSE:TRUE; 
	CNmChannelAudio *pChannelAudio;
	switch (dwStatus)
	{
	case CHANNEL_ACTIVE:
		if (bIncoming)
		{
			pChannelAudio = m_pChannelAudioRemote;
		}
		else
		{
			pChannelAudio = m_pChannelAudioLocal;
		}
		if (NULL != pChannelAudio)
		{
			pChannelAudio->CommChannelActive(pIChannel);
		}
		break;
	case CHANNEL_OPEN:
		OnH323ChannelChange(PF_MEDIA_AUDIO, bIncoming, TRUE, pIChannel);
		break;
	case CHANNEL_CLOSED:
		OnH323ChannelChange(PF_MEDIA_AUDIO, bIncoming, FALSE, pIChannel);
		break;
	default:
		return;
	}
}

VOID CConfObject::OnVideoChannelStatus(ICommChannel *pIChannel, IH323Endpoint * lpConnection, DWORD dwStatus)
{
	BOOL bIncoming = (pIChannel->IsSendChannel())? FALSE:TRUE; 
	CNmChannelVideo *pChannelVideo;
	switch (dwStatus)
	{
	case CHANNEL_ACTIVE:
		if (bIncoming)
		{
			pChannelVideo = m_pChannelVideoRemote;
		}
		else
		{
			pChannelVideo = m_pChannelVideoLocal;
		}
		if (NULL != pChannelVideo)
		{
			pChannelVideo->CommChannelActive(pIChannel);
		}
		break;

	case CHANNEL_OPEN:
		OnH323ChannelChange(PF_MEDIA_VIDEO, bIncoming, TRUE, pIChannel);
		break;
	case CHANNEL_CLOSED:
		OnH323ChannelChange(PF_MEDIA_VIDEO, bIncoming, FALSE, pIChannel);
		break;
	case CHANNEL_REJECTED:
	case CHANNEL_OPEN_ERROR:
	case CHANNEL_NO_CAPABILITY:
		if(bIncoming)
		{
			if (NULL != m_pChannelVideoRemote)
			{
				m_pChannelVideoRemote->CommChannelError(dwStatus);
			}
		}
		else
		{
			if (NULL != m_pChannelVideoLocal)
			{
				m_pChannelVideoLocal->CommChannelError(dwStatus);
			}
		}
		break;

	case CHANNEL_REMOTE_PAUSE_ON:
	case CHANNEL_REMOTE_PAUSE_OFF:
		if(bIncoming)
		{
			if (NULL != m_pChannelVideoRemote)
			{
				BOOL fPause = CHANNEL_REMOTE_PAUSE_ON == dwStatus;
				m_pChannelVideoRemote->CommChannelRemotePaused(fPause);
			}
		}
		else
		{
			if (NULL != m_pChannelVideoLocal)
			{
				BOOL fPause = CHANNEL_REMOTE_PAUSE_ON == dwStatus;
				m_pChannelVideoLocal->CommChannelRemotePaused(fPause);
			}
		}
		break;
	default:
		break;
	}
}

VOID CConfObject::CreateMember(IH323Endpoint * pConnection, REFGUID rguidNode, UINT uNodeID)
{
	ASSERT(g_pH323UI);
	WCHAR wszRemoteName[MAX_CALLER_NAME];
	if (FAILED(pConnection->GetRemoteUserName(wszRemoteName, MAX_CALLER_NAME)))
	{
		ERROR_OUT(("GetRemoteUserName() failed!"));
		return;
	}
	
	// Add the local member
	CNmMember * pMemberLocal = GetLocalMember();
	if (NULL != pMemberLocal)
	{
		AddH323ToDataMember(pMemberLocal, NULL);
	}
	else
	{
		// We aren't already in the list, so add ourselves here:
		BSTR bstrName = NULL;

		COprahNCUI *pOprahNCUI = COprahNCUI::GetInstance();
		if (NULL != pOprahNCUI)
		{
			bstrName = pOprahNCUI->GetUserName();
		}
		pMemberLocal = new CNmMember(bstrName, H323_GCCID_LOCAL,
			PF_H323 | PF_LOCAL_NODE | PF_VER_CURRENT, 0, g_guidLocalNodeId, NULL, 0);
		if (NULL != pMemberLocal)
		{
			AddMember(pMemberLocal, NULL);

			ASSERT(NULL == m_pMemberLocal);
			m_pMemberLocal = pMemberLocal;
		}
	}

	// Add the remote member
	CNmMember * pMemberRemote = MatchH323ToDataMembers(rguidNode, pConnection);
	if (NULL != pMemberRemote)
	{
		AddH323ToDataMember(pMemberRemote, pConnection);
	}
	else
	{
		// BUGBUG: A version number should be added here, if possible
		pMemberRemote = new CNmMember(	wszRemoteName,
										uNodeID,
										PF_H323,
										0,
										rguidNode,
										NULL,
										0);
		if (NULL != pMemberRemote)
		{
			AddMember(pMemberRemote, pConnection);
		}
	}

	if (NULL != m_hConf && (CS_RUNNING == m_csState))
	{
//			m_hConf->UpdateUserData();
	}
}


VOID CConfObject::OnH323Connected(IH323Endpoint * pConnection, DWORD dwFlags, BOOL fAddMember,  REFGUID rguidNode)
{
	HRESULT hr;
	UINT ui;
	ASSERT(NULL != pConnection);
	// alloc and initialize media guids.

	CMediaList MediaList;

	GUID MediaType;
	BOOL fEnableMedia;

	COprahNCUI *pOprahNCUI = COprahNCUI::GetInstance();
	if (NULL != pOprahNCUI)
	{
		MediaType = MEDIA_TYPE_H323VIDEO;
		fEnableMedia = pOprahNCUI->IsSendVideoAllowed() && (dwFlags & CRPCF_VIDEO);
		MediaList.EnableMedia(&MediaType, TRUE /*send */, fEnableMedia);
		fEnableMedia = pOprahNCUI->IsReceiveVideoAllowed() && (dwFlags & CRPCF_VIDEO);
		MediaList.EnableMedia(&MediaType, FALSE /* recv, NOT send */, fEnableMedia);
		
		MediaType = MEDIA_TYPE_H323AUDIO;
		fEnableMedia = pOprahNCUI->IsAudioAllowed() && (dwFlags & CRPCF_AUDIO);
		MediaList.EnableMedia(&MediaType, TRUE /* send */, fEnableMedia);
		MediaList.EnableMedia(&MediaType, FALSE /* recv, NOT send */, fEnableMedia);

		MediaType = MEDIA_TYPE_H323_T120;
		fEnableMedia = (dwFlags & CRPCF_DATA);
		MediaList.EnableMedia(&MediaType, TRUE /* send */, fEnableMedia);
		MediaList.EnableMedia(&MediaType, FALSE /* recv, NOT send */, fEnableMedia);
	}

	hr = MediaList.ResolveSendFormats(pConnection);
	
	if(!(SUCCEEDED(hr)))
	{
		// Well, there is no way we can ever open any send channel.  But It is a
		// product requirement to keep the connection up just in case the other
		// endpoint(s) ever wants to open a send video channel to this endpoint.
	}

	ICommChannel* pChannelT120 = CreateT120Channel(pConnection, &MediaList);
	CreateAVChannels(pConnection, &MediaList);
	if (pChannelT120)
	{
		OpenT120Channel(pConnection, &MediaList, pChannelT120);
		// no need to hold onto the T120 channel
		pChannelT120->Release();
	}
	OpenAVChannels(pConnection, &MediaList);


	if (fAddMember)
	{
		CreateMember(pConnection, rguidNode, H323_GCCID_REMOTE);

		if (dwFlags & (CRPCF_AUDIO | CRPCF_VIDEO))
		{
			CNmMember* pMemberLocal = GetLocalMember();
			if (pMemberLocal)
			{
				AddMemberToAVChannels(pMemberLocal);
			}

			CNmMember* pMemberRemote = PMemberFromH323Endpoint(pConnection);
			if (pMemberRemote)
			{
				AddMemberToAVChannels(pMemberRemote);
			}
		}

	}
}

VOID CConfObject::OnH323Disconnected(IH323Endpoint * pConnection, BOOL fHasAV)
{
	DebugEntry(CConfObject::OnH323Disconnected);

	POSITION pos = m_MemberList.GetHeadPosition();
	while (NULL != pos)
	{
		POSITION oldpos = pos;
		CNmMember * pMember = (CNmMember *) m_MemberList.GetNext(pos);
		ASSERT(pMember);
		if (pMember->GetH323Endpoint() == pConnection)
		{
			if (fHasAV)
			{
				RemoveMemberFromAVChannels(pMember);
			}

			if (0 == (PF_T120 & pMember->GetDwFlags()))
			{
				// This is an H323 only participant, so remove now:
				RemoveMember(oldpos);
			}
			else
			{
				RemoveH323FromDataMember(pMember, pConnection);
			}
		}
	}

	CNmMember *pLocalMember = GetLocalMember();
	if (pLocalMember)
	{
		if (fHasAV)
		{
			RemoveMemberFromAVChannels(pLocalMember);
		}

		if (0 == m_uH323Endpoints)
		{
			if (0 == (PF_T120 & pLocalMember->GetDwFlags()))
			{
				// This is an H323 only participant, so remove now:
				RemoveMember(pLocalMember);
			}
			else
			{
				RemoveH323FromDataMember(pLocalMember, NULL);
			}
		}
	}

	if (fHasAV)
	{
		DestroyAVChannels();
	}

#ifdef REPORT_ALL_ERRORS
	DWORD dwSummary;
	dwSummary = pConnection->GetSummaryCode()
	if(CCR_REMOTE_MEDIA_ERROR == dwSummary)
	{
		::PostConfMsgBox(IDS_REMOTE_MEDIA_ERROR);
	}
#endif

	if ((NULL != m_hConf) && (CS_RUNNING == m_csState))
	{
//		m_hConf->UpdateUserData();
	}

	DebugExitVOID(CConfObject::OnH323Disconnected);
}


VOID CConfObject::OnT120Connected(IH323Endpoint * pConnection, UINT uNodeID)
{
	CNmMember *pMember = PMemberFromH323Endpoint(pConnection);
	if (pMember)
	{
		// save away the GCC id so that we can match this up when the member is added
		pMember->SetGCCID(uNodeID);
	}
	else
	{
		CreateMember(pConnection, GUID_NULL, uNodeID);
	}
}

//	StoreAndVerifyMemberUserData
//
//	Processes a member's user data and stores them for the GetUserData API call.
//	If security data is among the user data, verification against the transport-level
//  credentials is performed.

//  Returns FALSE if security verification fails, TRUE otherwise.

BOOL StoreAndVerifyMemberUserData(CNmMember * pMember, ROSTER_DATA_HANDLE hData)
{
	BOOL rc = TRUE;
	BOOL fUserDataSet;

 	GCCNodeRecord * pRosterEntry = (GCCNodeRecord *)hData;
	GCCUserData ** ppUserData = pRosterEntry->user_data_list;
	for (int i = 0; i < pRosterEntry->number_of_user_data_members; i++)
	{

		fUserDataSet = FALSE;

/* Always False		if ((int)ppUserData[i]->octet_string->length - sizeof(GUID) < 0)
		{
			WARNING_OUT(("StoreAndVerifyMemberUserData: bad user data"));
			rc = FALSE;
			break;
		}*/
		if (!pMember->FLocal() && 0 == CompareGuid((GUID *)ppUserData[i]->octet_string->value,(GUID *)&g_csguidSecurity))
		{
			PBYTE pb = NULL;
			ULONG cb = 0;
			if (pMember->GetSecurityData(&pb,&cb))
			{

				//
				// Check to make sure that the current user data matches
				// the transport security data.
				//

				if (memcmp(pb,ppUserData[i]->octet_string->value + sizeof(GUID),
					ppUserData[i]->octet_string->length - sizeof(GUID) - 1))
				{

					//
					// This should NOT happen. Either there is a bug
					// in the security code (credentials failed up update
					// in the transport or the like), or someone is trying
					// to deceive us.
					ERROR_OUT(("SECURITYDATA MISMATCH"));
					fUserDataSet = TRUE; // so we don't do it below.
					rc = FALSE;
				}
			}
			else {
				WARNING_OUT(("StoreAndVerifyMemberUserData: failed to get security data"));
				rc = FALSE;
			}
			CoTaskMemFree(pb);
		}
		if ( FALSE == fUserDataSet )
		{
			pMember->SetUserData(*(GUID *)ppUserData[i]->octet_string->value,
				(BYTE *)ppUserData[i]->octet_string->value + sizeof(GUID),
				ppUserData[i]->octet_string->length - sizeof(GUID));
		}
	}
	return rc;
}

VOID CConfObject::ResetDataMember(	CNmMember * pMember,
										ROSTER_DATA_HANDLE hData)
{
	DebugEntry(CConfObject::ResetDataMember);

	pMember->AddPf(PF_RESERVED);
	pMember->SetUserInfo(NULL, 0);

	UINT cbData;
	PVOID pData;
	ASSERT(g_pNodeController);
	if (NOERROR == g_pNodeController->GetUserData(
							hData, 
							(GUID*) &g_csguidRostInfo, 
							&cbData, 
							&pData))
	{
		pMember->SetUserInfo(pData, cbData);
	}

	UINT cbCaps;
	PVOID pvCaps;
	if (NOERROR != g_pNodeController->GetUserData(
							hData, 
							(GUID*) &g_csguidRosterCaps, 
							&cbCaps, 
							&pvCaps))
	{
		WARNING_OUT(("roster update is missing caps information"));
	}
	else
	{
		ASSERT(NULL != pvCaps);
		ASSERT(sizeof(ULONG) == cbCaps);
		pMember->SetCaps( *((PULONG)pvCaps) );
	}

	if (StoreAndVerifyMemberUserData(pMember, hData) == FALSE) {
		// Need to disconnect the conference in this case.
		WARNING_OUT(("ResetDataMember Security Warning: Authentication data could not be verified."));
	}

	NotifySink((INmMember *) pMember, OnNotifyMemberUpdated);

	DebugExitVOID(CConfObject::ResetDataMember);
}


VOID CConfObject::RemoveOldDataMembers(int nExpected)
{
	DebugEntry(CConfObject::RemoveOldDataMembers);

#ifdef _DEBUG
	int nRemoved = 0;
#endif // _DEBUG
	ASSERT(nExpected >= 0);

	if (nExpected > 0)
	{
		// At least one participant left:
		POSITION pos = m_MemberList.GetHeadPosition();
		while (NULL != pos)
		{
			POSITION oldpos = pos;
			CNmMember * pMember = (CNmMember *) m_MemberList.GetNext(pos);
			ASSERT(pMember);
			DWORD dwFlags = pMember->GetDwFlags();
			if (!(PF_RESERVED & dwFlags))
			{
				// This one is not in the data call:
				TRACE_OUT(("CConfObject Roster: %ls (%d) has left.", 
							pMember->GetName(), pMember->GetGCCID()));

#ifdef _DEBUG
				if (dwFlags & PF_T120)
				{
					nRemoved++;
				}
#endif // _DEBUG

				if (0 == (dwFlags & PF_H323))
				{
					// If they were data only, then remove:
					RemoveMember(oldpos);
				}
				else
				{
					pMember->RemovePf(PF_DATA_ALL);
					pMember->SetGCCID(pMember->FLocal() ? H323_GCCID_LOCAL : H323_GCCID_REMOTE);
					pMember->SetGccIdParent(INVALID_GCCID);
					pMember->SetCaps(0);
					pMember->SetUserInfo(NULL, 0);

					NotifySink((INmMember *) pMember, OnNotifyMemberUpdated);
				}
			}
		}

		// Validate that we did the right thing:
		ASSERT(nRemoved == nExpected);
	}

	DebugExitVOID(CConfObject::RemoveOldDataMembers);
}


CNmMember *CConfObject::MatchDataToH323Member(	REFGUID rguidNode,
											    UINT uNodeId,
												PVOID pvUserInfo)
{
	DebugEntry(CConfObject::MatchDataToH323Member);
	CNmMember *pMemberRet = NULL;
	BOOL bRet = FALSE;
	
	if (GUID_NULL != rguidNode)
	{
		// try matching up guids
		pMemberRet = PMemberFromNodeGuid(rguidNode);
	}

	if (NULL == pMemberRet)
	{
		// try matching up node ids
		pMemberRet = PMemberFromGCCID(uNodeId);
	}

	if ((NULL == pMemberRet) && pvUserInfo)
	{
		// All else failed try mathcing IP addresses
		CRosterInfo ri;
		if(SUCCEEDED(ri.Load(pvUserInfo)))
		{
			POSITION pos = m_MemberList.GetHeadPosition();
			while (NULL != pos)
			{
				SOCKADDR_IN sin;
				CNmMember * pMember = (CNmMember *) m_MemberList.GetNext(pos);
				IH323Endpoint * pConnection = pMember->GetH323Endpoint();
				if (pConnection && (S_OK == pConnection->GetRemoteUserAddr(&sin)))
				{

					TCHAR szAudioIP[MAX_PATH];
					TCHAR szDataIP[MAX_PATH];
					HROSTINFO hRI = NULL;
			
					// BUGBUG: UNICODE issues?
					lstrcpyn(szAudioIP, inet_ntoa(sin.sin_addr), CCHMAX(szAudioIP));
					while (SUCCEEDED(ri.ExtractItem(&hRI,
													g_cwszIPTag,
													szDataIP,
													CCHMAX(szDataIP))))
					{
						TRACE_OUT(("Comparing data IP \"%s\" with "
									"audio IP \"%s\"", szDataIP, szAudioIP));
						if (0 == lstrcmp(szDataIP, szAudioIP))
						{
							pMemberRet = pMember;
							break;	// out of outer while loop
						}
					}
				}
			}
		}
	}

	DebugExitPVOID(CConfObject::MatchDataToH323Member, pMemberRet);
	return pMemberRet;
}

VOID CConfObject::AddDataToH323Member(	CNmMember * pMember,
											PVOID pvUserInfo,
											UINT cbUserInfo,
											UINT uCaps,
											NC_ROSTER_NODE_ENTRY* pRosterNode)
{
	DebugEntry(CConfObject::AddDataToH323Member);

	ASSERT(pMember);
	ASSERT(NULL != pRosterNode);

	DWORD dwFlags = pMember->GetDwFlags();
	ASSERT(0 == ((PF_MEDIA_DATA | PF_T120) & dwFlags));
	dwFlags |= (PF_T120 | PF_MEDIA_DATA | PF_CA_DETACHED);

	// Add version information
	dwFlags = (dwFlags & ~PF_VER_MASK) |
		PF_VER_FromUserData(pRosterNode->hUserData);

	pMember->SetDwFlags(dwFlags);
	pMember->SetGCCID(pRosterNode->uNodeID);
	pMember->SetGccIdParent(pRosterNode->uSuperiorNodeID);

	ASSERT(0 == pMember->GetCaps());
	pMember->SetCaps(uCaps);

	pMember->SetUserInfo(pvUserInfo, cbUserInfo);

	NotifySink((INmMember *) pMember, OnNotifyMemberUpdated);

	ROSTER_DATA_HANDLE hData = pRosterNode->hUserData;

	if (StoreAndVerifyMemberUserData(pMember, hData) == FALSE) {
		// Need to disconnect the conference in this case.
		WARNING_OUT(("AddDataToH323Member Security Warning: Authentication data could not be verified."));
	}

	DebugExitVOID(CConfObject::AddDataToH323Member);
}

CNmMember * CConfObject::CreateDataMember(BOOL fLocal,
				  								REFGUID rguidNode,
												PVOID pvUserInfo,
												UINT cbUserInfo,
												UINT uCaps,
											    NC_ROSTER_NODE_ENTRY* pRosterNode)
{
	DebugEntry(CConfObject::CreateDataMember);

	ASSERT(NULL != pRosterNode);

	DWORD dwFlags = PF_T120 | PF_MEDIA_DATA | PF_CA_DETACHED;
	if (fLocal)
	{
		dwFlags |= (PF_LOCAL_NODE | PF_VER_CURRENT);
	}
	if (pRosterNode->fMCU)
	{
		dwFlags |= PF_T120_MCU;
	}

	if (0 != cbUserInfo)
	{
		dwFlags = (dwFlags & ~PF_VER_MASK)
				| PF_VER_FromUserData(pRosterNode->hUserData);
	}

	CNmMember * pMember = new CNmMember(pRosterNode->pwszNodeName,
										pRosterNode->uNodeID,
										dwFlags,
										uCaps,
										rguidNode,
										pvUserInfo,
										cbUserInfo);

	if (NULL != pMember)
	{
		pMember->SetGccIdParent(pRosterNode->uSuperiorNodeID);
		
		if (fLocal)
		{
			ASSERT(NULL == m_pMemberLocal);
			m_pMemberLocal = pMember;
		}
	}

	ROSTER_DATA_HANDLE hData = pRosterNode->hUserData;

	if (StoreAndVerifyMemberUserData(pMember, hData) == FALSE) {
		// Need to disconnect the conference in this case.
		WARNING_OUT(("CreateDataMember Security Warning: Authentication data could not be verified."));
	}

	TRACE_OUT(("CConfObject Roster: %ls (%d) has joined.", pRosterNode->pwszNodeName, pRosterNode->uNodeID));

	DebugExitPVOID(CConfObject::CreateDataMember, pMember);
	return pMember;
}

CNmMember * CConfObject::MatchH323ToDataMembers(REFGUID rguidNodeId,
												IH323Endpoint * pConnection)
{
	DebugEntry(CConfObject::MatchH323ToDataMembers);
	CNmMember * pMemberRet = NULL;

	// This is currently called only by OnH323Connected().  Terminal label isn't assigned yet.
	// so there is no need yet to INSERT SEARCH FOR MATCHING TERMINAL LABEL HERE

	if (GUID_NULL != rguidNodeId)
	{
		pMemberRet = PMemberFromNodeGuid(rguidNodeId);
	}
	else
	{
		SOCKADDR_IN sin;

		if (S_OK == pConnection->GetRemoteUserAddr(&sin))
		{
			TCHAR szAudioIP[MAX_PATH];
			lstrcpyn(szAudioIP, inet_ntoa(sin.sin_addr), CCHMAX(szAudioIP));

			POSITION pos = m_MemberList.GetHeadPosition();
			while (NULL != pos)
			{
				CNmMember * pMember = (CNmMember *) m_MemberList.GetNext(pos);

				// need to try to match IP addresses
				// this is how things were done in NM2.11 and earlier
				TCHAR szDataIP[MAX_PATH];
				HROSTINFO hRI = NULL;
				CRosterInfo ri;
				if (SUCCEEDED(ri.Load(pMember->GetUserInfo())) )
				{
					while (SUCCEEDED(ri.ExtractItem(&hRI,
													g_cwszIPTag,
													szDataIP,
													CCHMAX(szDataIP))))
					{
						TRACE_OUT(("Comparing data IP \"%s\" with "
									"h323 IP \"%s\"", szDataIP, szAudioIP));
						if (0 == lstrcmp(szDataIP, szAudioIP))
						{
							// close enough
							return pMember;
						}
					}
				}
			}
		}
	}

	DebugExitPVOID(CConfObject::MatchH323ToDataMembers, pMemberRet);
	return pMemberRet;
}

VOID CConfObject::AddMemberToAVChannels(CNmMember *pMember)
{
	CNmChannelAudio *pChannelAudio;
	CNmChannelVideo *pChannelVideo;

	if (pMember->FLocal())
	{
		pChannelAudio = m_pChannelAudioLocal;

		pChannelVideo = m_pChannelVideoLocal;
	}
	else
	{
		pChannelAudio = m_pChannelAudioRemote;

		pChannelVideo = m_pChannelVideoRemote;
	}

	if (pChannelAudio)
	{
		pChannelAudio->OnMemberAdded(pMember);
		// set media flags if channel is open
		if(S_OK == pChannelAudio->IsActive())
		{
			pMember->AddPf(PF_MEDIA_AUDIO);
			pChannelAudio->OnMemberUpdated(pMember);
			OnMemberUpdated(pMember);
		}
	}
	if (pChannelVideo)
	{
		pChannelVideo->OnMemberAdded(pMember);
		// set media flags if channel is open
		if(S_OK == pChannelVideo->IsActive())
		{
			pMember->AddPf(PF_MEDIA_VIDEO);
			pChannelVideo->OnMemberUpdated(pMember);
			OnMemberUpdated(pMember);
		}
	}

}

VOID CConfObject::RemoveMemberFromAVChannels(CNmMember *pMember)
{
	CNmChannelAudio *pChannelAudio;
	CNmChannelVideo *pChannelVideo;

	if (pMember->FLocal())
	{
		pChannelAudio = m_pChannelAudioLocal;

		pChannelVideo = m_pChannelVideoLocal;
	}
	else
	{
		pChannelAudio = m_pChannelAudioRemote;

		pChannelVideo = m_pChannelVideoRemote;
	}

	if ((NULL != pChannelVideo) && (PF_MEDIA_VIDEO & pMember->GetDwFlags()))
	{
		pMember->RemovePf(PF_MEDIA_VIDEO);
		pChannelVideo->OnMemberRemoved(pMember);
		OnMemberUpdated(pMember);
	}

	if ((NULL != pChannelAudio) && (PF_MEDIA_AUDIO & pMember->GetDwFlags()))
	{
		pMember->RemovePf(PF_MEDIA_AUDIO);
		pChannelAudio->OnMemberRemoved(pMember);
		OnMemberUpdated(pMember);
	}
}


/*  C R E A T E  A V  C H A N N E L S  */
/*-------------------------------------------------------------------------
    %%Function: CreateAVChannels
    
    Create AV channels.
-------------------------------------------------------------------------*/
VOID CConfObject::CreateAVChannels(IH323Endpoint * pConnection, CMediaList* pMediaList)
{
	HRESULT hr;
	GUID MediaGuid;
	ICommChannel *pCommChannel = NULL;
	
	MediaGuid = MEDIA_TYPE_H323AUDIO;
	if (pMediaList->IsInSendList(&MediaGuid))
	{
		m_pChannelAudioLocal = new CNmChannelAudio(FALSE /* fIncoming */);
		if (NULL != m_pChannelAudioLocal)
		{
			hr = pConnection->CreateCommChannel(&MediaGuid, &pCommChannel, TRUE /* fSend*/);
			ASSERT(SUCCEEDED(hr) && (NULL != pCommChannel));
			//if(SUCCEEDED(hr) && (NULL != pCommChannel))
			{
				NotifySink((INmChannel *) m_pChannelAudioLocal, OnNotifyChannelAdded);
				m_pChannelAudioLocal->OnConnected(pConnection, pCommChannel);
				hr = pCommChannel->EnableOpen(TRUE);
				ASSERT(SUCCEEDED(hr));
			}
			pCommChannel->Release();
			pCommChannel = NULL; // bug detection that can be removed later
		}
	}

	if (pMediaList->IsInRecvList(&MediaGuid))
	{
		m_pChannelAudioRemote = new CNmChannelAudio(TRUE /* fIncoming */);
		if (NULL != m_pChannelAudioRemote)
		{
			hr = pConnection->CreateCommChannel(&MediaGuid, &pCommChannel, FALSE /* fSend*/);
			ASSERT(SUCCEEDED(hr) && (NULL != pCommChannel));
			//if(SUCCEEDED(hr) && (NULL != pCommChannel))
			{
				NotifySink((INmChannel *) m_pChannelAudioRemote, OnNotifyChannelAdded);
				m_pChannelAudioRemote->OnConnected(pConnection, pCommChannel);
				hr = pCommChannel->EnableOpen(TRUE);
				ASSERT(SUCCEEDED(hr));
			}
			pCommChannel->Release();
			pCommChannel = NULL; // bug detection that can be removed later
		}
	}
	
	MediaGuid = MEDIA_TYPE_H323VIDEO;	// now doing video channels
	if (pMediaList->IsInSendList(&MediaGuid))
	{
		m_pChannelVideoLocal = CNmChannelVideo::CreateChannel(FALSE /* fIncoming */);
		if (NULL != m_pChannelVideoLocal)
		{
			BOOL fCreated = FALSE;
			// check for previous existence of preview stream/preview channel
			if(NULL == (pCommChannel= m_pChannelVideoLocal->GetPreviewCommChannel()))
			{
				hr = pConnection->CreateCommChannel(&MediaGuid, &pCommChannel, TRUE /* fSend*/);
				ASSERT(SUCCEEDED(hr) && (NULL != pCommChannel));
				fCreated = TRUE;
			}
			else
			{
				pCommChannel->SetAdviseInterface(m_pIH323ConfAdvise);
			}

			//if(SUCCEEDED(hr) && (NULL != pCommChannel))
			{
				NotifySink((INmChannel *) m_pChannelVideoLocal, OnNotifyChannelAdded);
				m_pChannelVideoLocal->OnConnected(pConnection, pCommChannel);
				hr = pCommChannel->EnableOpen(TRUE);
				ASSERT(SUCCEEDED(hr));			
			}
			if (fCreated)
				pCommChannel->Release();
			pCommChannel = NULL; // bug detection that can be removed later
		}

	}

	if (pMediaList->IsInRecvList(&MediaGuid))
	{
		m_pChannelVideoRemote = CNmChannelVideo::CreateChannel(TRUE /* fIncoming */);
		if (NULL != m_pChannelVideoRemote)
		{
			BOOL fCreated = FALSE;
			// check for previous existence of preview stream/preview channel
			if(NULL == (pCommChannel= m_pChannelVideoRemote->GetCommChannel()))
			{
				hr = pConnection->CreateCommChannel(&MediaGuid, &pCommChannel, FALSE /* fSend*/);
				fCreated = TRUE;
			}
			else
			{
				pCommChannel->SetAdviseInterface(m_pIH323ConfAdvise);
			}
			ASSERT(SUCCEEDED(hr) && (NULL != pCommChannel));
			//if(SUCCEEDED(hr) && (NULL != pCommChannel))
			{
				NotifySink((INmChannel *) m_pChannelVideoRemote, OnNotifyChannelAdded);
				m_pChannelVideoRemote->OnConnected(pConnection, pCommChannel);
				hr = pCommChannel->EnableOpen(TRUE);
				ASSERT(SUCCEEDED(hr));
			}
			if (fCreated)
				pCommChannel->Release();
		}
	}
}


/*  O P E N  A V  C H A N N E L S  */
/*-------------------------------------------------------------------------
    %%Function: OpenAVChannels
    
    Open AV channels.
-------------------------------------------------------------------------*/
VOID CConfObject::OpenAVChannels(IH323Endpoint * pConnection, CMediaList* pMediaList)
{
	MEDIA_FORMAT_ID idLocal;

	if(m_pChannelAudioLocal)
	{
		if (pMediaList->GetSendFormatLocalID(MEDIA_TYPE_H323AUDIO, &idLocal))
		{
			m_pChannelAudioLocal->SetFormat(idLocal);
			// open only if a valid negotiated format exists.
			// it won't hurt to always call the Open() method, but there is 
			// no need to.  This will and should probably change. Calling
			// this with INVALID_MEDIA_FORMAT results in a call to the event 
			// handler for the channel, notifying the upper layer(s) that the
			// channel could not be opened due to no compatible caps.  User 
			// feedback could be much improved if it took advantage of this.  
			if(idLocal != INVALID_MEDIA_FORMAT)
			{
				m_pChannelAudioLocal->Open();
			}
		}
	}

	if(m_pChannelVideoLocal)
	{
		if (pMediaList->GetSendFormatLocalID(MEDIA_TYPE_H323VIDEO, &idLocal))
		{
			m_pChannelVideoLocal->SetFormat(idLocal);
			if(m_pChannelVideoLocal->IsPreviewEnabled())
			{
				// open only if a valid negotiated format exists. see comments 
				// in the MEDIA_TYPE_H323AUDIO case above 
				if(idLocal != INVALID_MEDIA_FORMAT)
				{
					m_pChannelVideoLocal->Open();
				}
			}
		}
	}
}


ICommChannel* CConfObject::CreateT120Channel(IH323Endpoint * pConnection, CMediaList* pMediaList)
{
	ICommChannel *pChannelT120 = NULL;
	
	// create a T.120 channel stub 
	GUID MediaGuid = MEDIA_TYPE_H323_T120;
	if (pMediaList->IsInSendList(&MediaGuid))
	{
		HRESULT hr = pConnection->CreateCommChannel(&MediaGuid, &pChannelT120, TRUE /* fSend*/);
		if(SUCCEEDED(hr))
		{
			ASSERT(NULL != pChannelT120);
			hr = pChannelT120->EnableOpen(TRUE);
			ASSERT(SUCCEEDED(hr));
		}
	}

	return pChannelT120;
}

VOID CConfObject::OpenT120Channel(IH323Endpoint * pConnection, CMediaList* pMediaList, ICommChannel* pChannelT120)
{
	if(pChannelT120)
	{
		MEDIA_FORMAT_ID idLocal;

		if (pMediaList->GetSendFormatLocalID(MEDIA_TYPE_H323_T120, &idLocal))
		{
			// T.120 channels are different.  Always call the Open() method
			// If there are no common T.120 capabilities.  This lets the 
			// channel event handler know of the absence of remote T.120
			// caps. 
			// The T.120 call side of things is tied into the T.120 channel
			// event handler.
			pChannelT120->Open(idLocal, pConnection);
		}
	}
}

/*  D E S T R O Y  A V  C H A N N E L S  */
/*-------------------------------------------------------------------------
    %%Function: DestroyAVChannels
    
    Destroy AV channels.
-------------------------------------------------------------------------*/
VOID CConfObject::DestroyAVChannels()
{
	if (NULL != m_pChannelAudioLocal)
	{
		NotifySink((INmChannel *) m_pChannelAudioLocal, OnNotifyChannelRemoved);
		m_pChannelAudioLocal->Release();
		m_pChannelAudioLocal = NULL;
	}
	if (NULL != m_pChannelAudioRemote)
	{
		NotifySink((INmChannel *) m_pChannelAudioRemote, OnNotifyChannelRemoved);
		m_pChannelAudioRemote->Release();
		m_pChannelAudioRemote = NULL;
	}
	if (NULL != m_pChannelVideoLocal)
	{
		m_pChannelVideoLocal->OnDisconnected();
		NotifySink((INmChannel *) m_pChannelVideoLocal, OnNotifyChannelRemoved);
		m_pChannelVideoLocal->Release();
		m_pChannelVideoLocal = NULL;
	}
	if (NULL != m_pChannelVideoRemote)
	{
		m_pChannelVideoRemote->OnDisconnected();
		NotifySink((INmChannel *) m_pChannelVideoRemote, OnNotifyChannelRemoved);
		m_pChannelVideoRemote->Release();
		m_pChannelVideoRemote = NULL;
	}
}


HRESULT CConfObject::GetMediaChannel (GUID *pmediaID,BOOL bSendDirection, IMediaChannel **ppI)
{
	*ppI = NULL;
	if (*pmediaID == MEDIA_TYPE_H323AUDIO)
	{
		CNmChannelAudio *pAudChan = (bSendDirection ? m_pChannelAudioLocal : m_pChannelAudioRemote);
		*ppI = (pAudChan ? pAudChan->GetMediaChannelInterface() : NULL);
	}
	else if (*pmediaID == MEDIA_TYPE_H323VIDEO)
	{
		CNmChannelVideo *pVidChan = (bSendDirection ? m_pChannelVideoLocal : m_pChannelVideoRemote);
		*ppI = (pVidChan ? pVidChan->GetMediaChannelInterface() : NULL);
	}
	return (*ppI == NULL ? E_NOINTERFACE : S_OK);
}	

VOID CConfObject::AddH323ToDataMember(CNmMember * pMember, IH323Endpoint * pConnection)
{
	DebugEntry(CConfObject::AddH323ToDataMember);

	// Add the H323 flag bit to the member:
	pMember->AddPf(PF_H323);

	if (pConnection)
	{
		ASSERT(NULL == pMember->GetH323Endpoint());

		pMember->AddH323Endpoint(pConnection);
		++m_uH323Endpoints;
	}

	DebugExitVOID(CConfObject::AddH323ToDataMember);
}

VOID CConfObject::RemoveH323FromDataMember(CNmMember * pMember, IH323Endpoint * pConnection)
{
	DebugEntry(CConfObject::RemoveH323FromDataMember);

	// Remove the H323 flag from the member:
	pMember->RemovePf(PF_H323);

	if (pConnection)
	{
		pMember->DeleteH323Endpoint(pConnection);
		--m_uH323Endpoints;
	}

	DebugExitVOID(CConfObject::RemoveH323FromDataMember);
}

VOID CConfObject::OnMemberUpdated(INmMember *pMember)
{
	NotifySink(pMember, OnNotifyMemberUpdated);
}

VOID CConfObject::OnChannelUpdated(INmChannel *pChannel)
{
	NotifySink(pChannel, OnNotifyChannelUpdated);
}

VOID CConfObject::SetT120State(CONFSTATE state)
{
	NM_CONFERENCE_STATE oldNmState;

	GetState(&oldNmState);
	m_csState = state;
	if ( state == CS_TERMINATED )
		m_fSecure = FALSE; // Reset secure flag
	CheckState(oldNmState);
}

VOID CConfObject::CheckState(NM_CONFERENCE_STATE oldNmState)
{
	NM_CONFERENCE_STATE newNmState;
	GetState(&newNmState);
	if (oldNmState != newNmState)
	{
		NotifySink((PVOID) newNmState, OnNotifyStateChanged);
		if (NM_CONFERENCE_IDLE == newNmState)
		{
			_EraseDataChannelGUIDS();
			m_fConferenceCreated = FALSE;
		}
	}
}

void CConfObject::RemoveDataChannelGUID(REFGUID rguid)
{
	POSITION pCur = m_DataChannelGUIDS.GetHeadPosition();
	POSITION pNext = pCur;
	while(pCur)
	{
		GUID* pG = reinterpret_cast<GUID*>(m_DataChannelGUIDS.GetNext(pNext));
		if(*pG == rguid)
		{
			m_DataChannelGUIDS.RemoveAt(pCur);
		}
		pCur = pNext;
	}
}

void CConfObject::_EraseDataChannelGUIDS(void)
{
	POSITION pCur = m_DataChannelGUIDS.GetHeadPosition();
	while(pCur)
	{
		GUID* pG = reinterpret_cast<GUID*>(m_DataChannelGUIDS.GetNext(pCur));
		delete pG;
	}

	m_DataChannelGUIDS.EmptyList();
}

ULONG CConfObject::AddRef(void)
{
	return ++m_cRef;
}
	
ULONG CConfObject::Release(void)
{
	ASSERT(m_cRef > 0);

	if (m_cRef > 0)
	{
		m_cRef--;
	}

	ULONG cRef = m_cRef;

	if (0 == cRef)
	{
		delete this;
	}

	return cRef;
}

HRESULT STDMETHODCALLTYPE CConfObject::QueryInterface(REFIID riid, PVOID *ppv)
{
	HRESULT hr = S_OK;

	if((riid == IID_INmConference2) || (riid == IID_INmConference) || (riid == IID_IUnknown))
	{
		*ppv = (INmConference2 *)this;
		ApiDebugMsg(("CConfObject::QueryInterface()"));
	}
	else if (riid == IID_IConnectionPointContainer)
	{
		*ppv = (IConnectionPointContainer *) this;
		ApiDebugMsg(("CConfObject::QueryInterface(): Returning IConnectionPointContainer."));
	}
	else
	{
		hr = E_NOINTERFACE;
		*ppv = NULL;
		ApiDebugMsg(("CConfObject::QueryInterface(): Called on unknown interface."));
	}

	if (S_OK == hr)
	{
		AddRef();
	}

	return hr;
}

HRESULT CConfObject::GetName(BSTR *pbstrName)
{
	HRESULT hr = E_POINTER;

	if (NULL != pbstrName)
	{
		*pbstrName = SysAllocString(m_bstrConfName);
		hr = *pbstrName ? S_OK : E_FAIL;
	}
	return hr;
}

HRESULT CConfObject::GetID(ULONG *puID)
{
	HRESULT hr = E_POINTER;

	if (NULL != puID)
	{
		*puID = m_uGCCConferenceID;
		hr = S_OK;
	}
	return hr;
}

HRESULT CConfObject::GetState(NM_CONFERENCE_STATE *pState)
{
	HRESULT hr = E_POINTER;

	if (NULL != pState)
	{
		hr = S_OK;

		switch (m_csState)
		{
			// Note: All states are valid (at least, for now)
			case CS_CREATING:
			case CS_UNINITIALIZED:
			case CS_TERMINATED:
				if (0 == m_uH323Endpoints)
				{
					*pState = NM_CONFERENCE_IDLE;
					break;
				}
				//////////////////////////////////////////////////////////////////////////					
				//////////////////////////////////////////////////////////////////////////					
				//////////////////////////////////////////////////////////////////////////					
				//////////////////////////////////////////////////////////////////////////					
				//////////////////////////////////////////////////////////////////////////					
				//////////////////////////////////////////////////////////////////////////					
				//////////////////////////////////////////////////////////////////////////					
				//////////////////////////////////////////////////////////////////////////					
				// else fall through !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
				//////////////////////////////////////////////////////////////////////////
			case CS_COMING_UP:
			case CS_GOING_DOWN:
			case CS_RUNNING:
				if (m_uMembers < 2)
				{
					if (m_fServerMode)
					{
						*pState = NM_CONFERENCE_WAITING;
					}
					else
					{
						*pState = NM_CONFERENCE_INITIALIZING;
					}
				}
				else
				{
					*pState = NM_CONFERENCE_ACTIVE;
				}
				break;
			default:
				hr = E_FAIL;
				break;
		}
	}
	return hr;
}

HRESULT CConfObject::GetNmchCaps(ULONG *puchCaps)
{
	HRESULT hr = E_POINTER;

	// BUGBUG: this returns secure cap only, used to be NOTIMPL

	if (NULL != puchCaps)
	{
		*puchCaps = m_fSecure ? NMCH_SECURE : 0;
		hr = S_OK;
	}
	return hr;
}

HRESULT CConfObject::GetTopProvider(INmMember **ppMember)
{
	CNmMember *pMemberRet = NULL;
	HRESULT hr = E_POINTER;

	if (NULL != ppMember)
	{
		POSITION pos = m_MemberList.GetHeadPosition();
		while (NULL != pos)
		{
			CNmMember *pMember = (CNmMember *) m_MemberList.GetNext(pos);
			ASSERT(pMember);

			if (pMember->FTopProvider())
			{
				// We have found the top provider
				pMemberRet = pMember;
				break;
			}
		}

		*ppMember = pMemberRet;
		hr = (NULL != pMemberRet) ? S_OK : S_FALSE;
	}
	return hr;
}


HRESULT CConfObject::EnumMember(IEnumNmMember **ppEnum)
{
	HRESULT hr = E_POINTER;

	if (NULL != ppEnum)
	{
		*ppEnum = new CEnumNmMember(&m_MemberList, m_uMembers);
		hr = (NULL != *ppEnum) ? S_OK : E_OUTOFMEMORY;
	}
	return hr;
}

HRESULT CConfObject::GetMemberCount(ULONG *puCount)
{
	HRESULT hr = E_POINTER;

	if (NULL != puCount)
	{
		*puCount = m_uMembers;
		hr = S_OK;
	}
	return hr;
}

HRESULT CConfObject::EnumChannel(IEnumNmChannel **ppEnum)
{
 	HRESULT hr = E_POINTER;
 
 	if (NULL != ppEnum)
 	{
 		COBLIST ChannelList;
 		ULONG cChannels = 0;
 
 		if (NULL != m_pChannelAudioLocal)
 		{
 			ChannelList.AddTail(m_pChannelAudioLocal);
 			++cChannels;
 		}
 		if (NULL != m_pChannelAudioRemote)
 		{
 			ChannelList.AddTail(m_pChannelAudioRemote);
 			++cChannels;
 		}
 		if (NULL != m_pChannelVideoLocal)
 		{
 			ChannelList.AddTail(m_pChannelVideoLocal);
 			++cChannels;
 		}
 		if (NULL != m_pChannelVideoRemote)
 		{
 			ChannelList.AddTail(m_pChannelVideoRemote);
 			++cChannels;
 		}
 
 		*ppEnum = new CEnumNmChannel(&ChannelList, cChannels);
 		hr = (NULL != ppEnum) ? S_OK : E_OUTOFMEMORY;
 
 		ChannelList.EmptyList();
 	}
 
 	return hr;
}

HRESULT CConfObject::GetChannelCount(ULONG *puCount)
{
	HRESULT hr = E_POINTER;

	if (NULL != puCount)
	{
		ULONG cChannels = 0;

		if (NULL != m_pChannelAudioLocal)
		{
			++cChannels;
		}
		if (NULL != m_pChannelAudioRemote)
		{
			++cChannels;
		}
		if (NULL != m_pChannelVideoLocal)
		{
			++cChannels;
		}
		if (NULL != m_pChannelVideoRemote)
		{
			++cChannels;
		}

		*puCount = cChannels;
		hr = S_OK;
	}
	return hr;
}

/*  P  M E M B E R  L O C A L  */
/*-------------------------------------------------------------------------
    %%Function: PMemberLocal
    
-------------------------------------------------------------------------*/
CNmMember * PMemberLocal(COBLIST *pList)
{
	if (NULL != pList)
	{
		POSITION posCurr;
		POSITION pos = pList->GetHeadPosition();
		while (NULL != pos)
		{
			posCurr = pos;
			CNmMember * pMember = (CNmMember *) pList->GetNext(pos);
			ASSERT(NULL != pMember);
			if (pMember->FLocal())
				return pMember;
		}
	}
	return NULL;
}


HRESULT STDMETHODCALLTYPE CConfObject::CreateDataChannelEx(INmChannelData **ppChannel, REFGUID rguid, BYTE * pER)
{
	if (NULL != ppChannel)
	{
		if (IsBadWritePtr(ppChannel, sizeof(LPVOID)))
			return E_POINTER;
		*ppChannel = NULL;
	}

	if (GUID_NULL == rguid)
	{
		WARNING_OUT(("CreateDataChannel: Null guid"));
		return E_INVALIDARG;
	}


	{	// Make sure we're in a data conference
		CNmMember * pMember = PMemberLocal(&m_MemberList);
		if (NULL == pMember)
			return E_FAIL;

		// Data must be available
		if (!FValidGccId(pMember->GetGCCID()))
			return NM_E_NO_T120_CONFERENCE;
	}

	// Make sure the data channel has not already been created
	GUID g = rguid;

	POSITION pCur = m_DataChannelGUIDS.GetHeadPosition();
	while(pCur)
	{
		GUID* pG = reinterpret_cast<GUID*>(m_DataChannelGUIDS.GetNext(pCur));
		if(*pG == rguid)
		{
			return NM_E_CHANNEL_ALREADY_EXISTS;			
		}
	}

	CNmChannelData * pChannel = new CNmChannelData(this, rguid, (PGCCEnrollRequest) pER);
	if (NULL == pChannel)
	{
		WARNING_OUT(("CreateChannelData: Unable to create data channel"));
		return E_OUTOFMEMORY;
	}

	HRESULT hr = pChannel->OpenConnection();
	if (FAILED(hr))
	{
		ERROR_OUT(("CreateDataChannel: Unable to set guid / create T.120 channels"));
		// Failed to create T.120 data channels
		delete pChannel;
		*ppChannel = NULL;
		return hr;
	}

	GUID* pG = new GUID;
	*pG = g;

	m_DataChannelGUIDS.AddTail(pG);

	NotifySink((INmChannel *) pChannel, OnNotifyChannelAdded);
	TRACE_OUT(("CreateChannelData: Created data channel %08X", pChannel));

		// Now we are active
	NotifySink((INmChannel*) pChannel, OnNotifyChannelUpdated);

	if (NULL != ppChannel)
	{
		*ppChannel = (INmChannelData *)pChannel;
//		pChannel->AddRef(); // Caller needs to release the initial lock
	}
	else
	{
		pChannel->Release(); // No one is watching this channel? - free it now
	}

	return S_OK;
}




HRESULT STDMETHODCALLTYPE CConfObject::CreateDataChannel(INmChannelData **ppChannel, REFGUID rguid)
{
	return CreateDataChannelEx(ppChannel, rguid, NULL);
}

HRESULT CConfObject::IsHosting(void)
{
	return m_fServerMode ? S_OK : S_FALSE;
}


HRESULT CConfObject::Host(void)
{
	HRESULT hr = E_FAIL;

	if (m_fServerMode || IsConferenceActive())
	{
		WARNING_OUT(("Conference already exists!"));
//		ncsRet = UI_RC_CONFERENCE_ALREADY_EXISTS;
	}
	else
	{
		HRESULT ncsRet = CreateConference();
		if (S_OK == ncsRet)
		{
			// The only success case:
			TRACE_OUT(("Create local issued successfully"));
			m_fServerMode = TRUE;
			hr = S_OK;
		}
		else
		{
			// UI?
			WARNING_OUT(("Create local failed!"));
		}
	}
	return hr;
}

HRESULT CConfObject::Leave(void)
{
	DebugEntry(CConfObject::Leave);

	COprahNCUI *pOprahNCUI = COprahNCUI::GetInstance();
	if (NULL != pOprahNCUI)
	{
		pOprahNCUI->CancelCalls();
	}

	HRESULT hr = S_OK;
	switch (m_csState)
	{
		case CS_GOING_DOWN:
			// we are already exiting
			break;

		case CS_COMING_UP:
		case CS_RUNNING:
		{
			SetT120State(CS_GOING_DOWN);
			ASSERT(m_hConf);
			TRACE_OUT(("Calling IDataConference::Leave"));
			hr = m_hConf->Leave();
			if (FAILED(hr))
			{
				WARNING_OUT(("IDataConference::Leave failed"));
			}
			break;
		}

		default:
			hr = E_FAIL;
			break;
	}

	if(FAILED(LeaveH323(FALSE /* fKeepAV */ )))
	{
		// overwrite return value.... I guess this error is as good as any error
		hr = E_FAIL;
	}

	DebugExitHRESULT(CConfObject::Leave, hr);
	return hr;
}

HRESULT CConfObject::LeaveH323(BOOL fKeepAV)
{
	HRESULT hrRet = S_OK;
	POSITION pos = m_MemberList.GetHeadPosition();
	while (NULL != pos && !m_MemberList.IsEmpty())
	{
		CNmMember * pMember = (CNmMember *) m_MemberList.GetNext(pos);
		ASSERT(pMember);
		HRESULT hr;
		DWORD dwFlags = pMember->GetDwFlags();
		IH323Endpoint * pConnection = pMember->GetH323Endpoint();
		if(pConnection)
		{
			if (!fKeepAV || !((PF_MEDIA_AUDIO | PF_MEDIA_VIDEO) & dwFlags))
			{
				ConnectStateType state = CLS_Idle;
				hr = pConnection->GetState(&state);
				if (SUCCEEDED(hr))
				{
					if(state != CLS_Idle)
					{
						ASSERT(dwFlags & PF_H323);
						hr = pConnection->Disconnect();
						if (SUCCEEDED(hr))
						{
							TRACE_OUT(("pConnection->Disconnect() succeeded!"));
						}
						else
						{
							hrRet = E_FAIL;
							WARNING_OUT(("pConnection->Disconnect() failed!"));
						}
					}
				}
				else
				{
					hrRet = E_FAIL;
				}
			}
		}
	}
	return hrRet;
}

HRESULT CConfObject::LaunchRemote(REFGUID rguid, INmMember *pMember)
{
	DWORD dwUserId = 0;
	if(m_hConf)
	{
		if (NULL != pMember)
		{
			dwUserId = ((CNmMember*)pMember)->GetGCCID();
		}

		ASSERT(g_pNodeController);
		ASSERT(m_hConf);
		HRESULT nsRet = m_hConf->LaunchGuid(&rguid,
			(PUINT) &dwUserId, (0 == dwUserId) ? 0 : 1);

		return (S_OK == nsRet) ? S_OK : E_FAIL;
	}

	return NM_E_NO_T120_CONFERENCE;
}


STDMETHODIMP CConfObject::DisconnectAV(INmMember *pMember)
{
	return E_FAIL;
}

/****************************************************************************
*
*	 CLASS:    CConfObject
*
*	 FUNCTION: ConnectAV(LPCTSTR, LPCTSTR)
*
*	 PURPOSE:  Switches Audio and Video to a new person (given an IP address)
*
****************************************************************************/

STDMETHODIMP CConfObject::ConnectAV(INmMember *pMember)
{
	DebugEntry(CConfRoom::SwitchAV);

	HRESULT hr = E_FAIL;

	DebugExitHRESULT(CConfRoom::SwitchAV, hr);
	return hr;
}

/****************************************************************************
*
*	 CLASS:    CConfObject
*
*	 FUNCTION: GetConferenceHandle(DWORD *)
*
*	 PURPOSE:  Gets the T120 conference handle
*
****************************************************************************/

STDMETHODIMP CConfObject::GetConferenceHandle(DWORD_PTR *pdwHandle)
{
	HRESULT hr = E_FAIL;

	if (NULL != pdwHandle)
	{
		CONF_HANDLE hConf = GetConfHandle();
		*pdwHandle = (DWORD_PTR)hConf;
		hr = S_OK;
	}
	return hr;

}

/*  O N  N O T I F Y  S T A T E  C H A N G E D  */
/*-------------------------------------------------------------------------
    %%Function: OnNotifyStateChanged
    
-------------------------------------------------------------------------*/
HRESULT OnNotifyStateChanged(IUnknown *pConfNotify, PVOID pv, REFIID riid)
{
	ASSERT(NULL != pConfNotify);

	((INmConferenceNotify*)pConfNotify)->StateChanged((NM_CONFERENCE_STATE)((DWORD_PTR)pv));
	return S_OK;
}

/*  O N  N O T I F Y  M E M B E R  A D D E D  */
/*-------------------------------------------------------------------------
    %%Function: OnNotifyMemberAdded
    
-------------------------------------------------------------------------*/
HRESULT OnNotifyMemberAdded(IUnknown *pConfNotify, PVOID pv, REFIID riid)
{
	ASSERT(NULL != pConfNotify);

	((INmConferenceNotify*)pConfNotify)->MemberChanged(NM_MEMBER_ADDED, (INmMember *) pv);
	return S_OK;
}

/*  O N  N O T I F Y  M E M B E R  U P D A T E D  */
/*-------------------------------------------------------------------------
    %%Function: OnNotifyMemberUpdated
    
-------------------------------------------------------------------------*/
HRESULT OnNotifyMemberUpdated(IUnknown *pConfNotify, PVOID pv, REFIID riid)
{
	ASSERT(NULL != pConfNotify);

	((INmConferenceNotify*)pConfNotify)->MemberChanged(NM_MEMBER_UPDATED, (INmMember *) pv);
	return S_OK;
}

/*  O N  N O T I F Y  M E M B E R  R E M O V E D  */
/*-------------------------------------------------------------------------
    %%Function: OnNotifyMemberRemoved
    
-------------------------------------------------------------------------*/
HRESULT OnNotifyMemberRemoved(IUnknown *pConfNotify, PVOID pv, REFIID riid)
{
	ASSERT(NULL != pConfNotify);

	((INmConferenceNotify*)pConfNotify)->MemberChanged(NM_MEMBER_REMOVED, (INmMember *) pv);
	return S_OK;
}

/*  O N  N O T I F Y  C H A N N E L  A D D E D  */
/*-------------------------------------------------------------------------
    %%Function: OnNotifyChannelAdded
    
-------------------------------------------------------------------------*/
HRESULT OnNotifyChannelAdded(IUnknown *pConfNotify, PVOID pv, REFIID riid)
{
	ASSERT(NULL != pConfNotify);

	((INmConferenceNotify*)pConfNotify)->ChannelChanged(NM_CHANNEL_ADDED, (INmChannel *) pv);
	return S_OK;
}

/*  O N  N O T I F Y  C H A N N E L  U P D A T E D  */
/*-------------------------------------------------------------------------
    %%Function: OnNotifyChannelUpdated
    
-------------------------------------------------------------------------*/
HRESULT OnNotifyChannelUpdated(IUnknown *pConfNotify, PVOID pv, REFIID riid)
{
	ASSERT(NULL != pConfNotify);

	((INmConferenceNotify*)pConfNotify)->ChannelChanged(NM_CHANNEL_UPDATED, (INmChannel *) pv);
	return S_OK;
}

/*  O N  N O T I F Y  C H A N N E L  R E M O V E D  */
/*-------------------------------------------------------------------------
    %%Function: OnNotifyChannelRemoved
    
-------------------------------------------------------------------------*/
HRESULT OnNotifyChannelRemoved(IUnknown *pConfNotify, PVOID pv, REFIID riid)
{
	ASSERT(NULL != pConfNotify);

	((INmConferenceNotify*)pConfNotify)->ChannelChanged(NM_CHANNEL_REMOVED, (INmChannel *) pv);
	return S_OK;
}

HRESULT OnNotifyStreamEvent(IUnknown *pConfNotify, PVOID pv, REFIID riid)
{
	StreamEventInfo *pInfo = (StreamEventInfo*)pv;
	ASSERT(NULL != pConfNotify);
	HRESULT hr;

	if (riid != IID_INmConferenceNotify2)
		return E_NOINTERFACE;

	((INmConferenceNotify2*)pConfNotify)->StreamEvent(pInfo->uEventCode, pInfo->uSubCode, pInfo->pChannel);
	return S_OK;
}


/*  O N  N O T I F Y  N M  U I  */
/*-------------------------------------------------------------------------
    %%Function: OnNotifyNmUI
    
-------------------------------------------------------------------------*/
HRESULT OnNotifyNmUI(IUnknown *pConfNotify, PVOID pv, REFIID riid)
{
	ASSERT(NULL != pConfNotify);

	((INmConferenceNotify*)pConfNotify)->NmUI((CONFN)((DWORD_PTR)pv));
	return S_OK;
}

/*  G E T  C O N F  O B J E C T  */
/*-------------------------------------------------------------------------
    %%Function: GetConfObject

    Global function to get the conference object
-------------------------------------------------------------------------*/
CConfObject * GetConfObject(void)
{
	COprahNCUI *pOprahNCUI = COprahNCUI::GetInstance();
	if (NULL != pOprahNCUI)
	{
		return pOprahNCUI->GetConfObject();
	}
	return NULL;
}

/*  G E T  C O N F E R E N C E  */
/*-------------------------------------------------------------------------
    %%Function: GetConference

    Global function to get the INmConference interface to the conf object
-------------------------------------------------------------------------*/
HRESULT GetConference(INmConference **ppConference)
{
	HRESULT hr = E_POINTER;
	if (NULL != ppConference)
	{
		hr = E_FAIL;
		INmConference *pConference = GetConfObject();
		if (NULL != pConference)
		{
			pConference->AddRef();
			hr = S_OK;
		}
		*ppConference = pConference;
	}
	return hr;
}

/*  G E T  M E M B E R  L I S T  */
/*-------------------------------------------------------------------------
    %%Function: GetMemberList

    Global function to get the member list
-------------------------------------------------------------------------*/
COBLIST * GetMemberList(void)
{
	CConfObject* pco = ::GetConfObject();
	if (NULL == pco)
		return NULL;
	return pco->GetMemberList();
}

/*  P  F _  V  E  R _  F R O M  D W  */
/*-------------------------------------------------------------------------
    %%Function: PF_VER_FromDw

-------------------------------------------------------------------------*/
DWORD PF_VER_FromDw(DWORD dw)
{
	if (DWVERSION_NM_1 == dw)
		return PF_VER_NM_1;

	if ((DWVERSION_NM_2b2 <= dw) && (DWVERSION_NM_2 >= dw))
		return PF_VER_NM_2;

	if ((DWVERSION_NM_3a1 <= dw) && (DWVERSION_NM_3max >= dw))
		return PF_VER_NM_3;

	if ((DWVERSION_NM_4a1 <= dw) && (DWVERSION_NM_CURRENT >= dw))
		return PF_VER_NM_4;

	if (dw > DWVERSION_NM_CURRENT)
		return PF_VER_FUTURE;

	return PF_VER_UNKNOWN;
}


/*  P  F _  V  E  R _  F R O M  U S E R  D A T A  */
/*-------------------------------------------------------------------------
    %%Function: PV_VER_FromUserData
    
-------------------------------------------------------------------------*/
DWORD PF_VER_FromUserData(ROSTER_DATA_HANDLE hUserData)
{
	UINT cb;
	PT120PRODUCTVERSION pVersion;
	PVOID pv;

	static const GUID g_csguidVerInfo = GUID_VERSION;

	ASSERT(NULL != g_pNodeController);

	if (NULL == hUserData)
		return PF_VER_UNKNOWN; // not NetMeeting

	// Try to find the T.120 Product Version guid
	if ((NOERROR == g_pNodeController->GetUserData(hUserData,
			&g_csguidVerInfo, &cb, (PVOID *) &pVersion))
		&& (cb < sizeof(T120PRODUCTVERSION)) )
	{
		return PF_VER_FromDw(pVersion->dwVersion);
	}

	// Try to extract the build number from the hex string for VER_PRODUCTVERSION_DW
	if ((NOERROR == g_pNodeController->GetUserData(hUserData,
			(GUID *) &g_csguidRostInfo, &cb, &pv)))
	{
		CRosterInfo ri;
		ri.Load(pv);

		TCHAR szVersion[MAX_PATH];
		if (SUCCEEDED(ri.ExtractItem(NULL,
			g_cwszVerTag, szVersion, CCHMAX(szVersion))))
		{
			return PF_VER_FromDw(DwFromHex(szVersion));
		}
	}

	return PF_VER_NM_1; // Must be at least NetMeeting 1.0
}

DWORD CConfObject::GetDwUserIdLocal(void)
{
	CNmMember * pMemberLocal = GetLocalMember();

	if (NULL != pMemberLocal)
	{
		return pMemberLocal->GetGCCID();
	}

	return 0;
}


CNmMember * CConfObject::PMemberFromGCCID(UINT uNodeID)
{
	COBLIST* pMemberList = ::GetMemberList();
	if (NULL != pMemberList)
	{
		POSITION pos = pMemberList->GetHeadPosition();
		while (pos)
		{
			CNmMember * pMember = (CNmMember *) pMemberList->GetNext(pos);
			ASSERT(NULL != pMember);
			if (uNodeID == pMember->GetGCCID())
			{
				return pMember;
			}
		}
	}
	return NULL;
}

CNmMember * CConfObject::PMemberFromNodeGuid(REFGUID rguidNode)
{
	POSITION pos = m_MemberList.GetHeadPosition();
	while (NULL != pos)
	{
		CNmMember * pMember = (CNmMember *) m_MemberList.GetNext(pos);

		if (pMember->GetNodeGuid() == rguidNode)
		{
			return  pMember;
		}
	}
	return NULL;
}

CNmMember * CConfObject::PMemberFromH323Endpoint(IH323Endpoint * pConnection)
{
	COBLIST* pMemberList = ::GetMemberList();
	if (NULL != pMemberList)
	{
		POSITION pos = pMemberList->GetHeadPosition();
		while (pos)
		{
			CNmMember * pMember = (CNmMember *) pMemberList->GetNext(pos);
			ASSERT(NULL != pMember);
			if (pConnection == pMember->GetH323Endpoint())
			{
				return pMember;
			}
		}
	}
	return NULL;
}
	

CNmMember * CConfObject::PDataMemberFromName(PCWSTR pwszName)
{
	POSITION pos = m_MemberList.GetHeadPosition();
	while (NULL != pos)
	{
		CNmMember * pMember = (CNmMember *) m_MemberList.GetNext(pos);

		if(pMember->FHasData())
		{
			if (0 == UnicodeCompare(pwszName, pMember->GetName()))
			{
				return  pMember;
			}
		}
	}
	return NULL;
}


// IStreamEventNotify method
// get called whenever a major event on the stream occurs
HRESULT __stdcall CConfObject::EventNotification(UINT uDirection, UINT uMediaType, UINT uEventCode, UINT uSubCode)
{
	CNmChannelAudio *pChannel = NULL;
	ULONG uStatus = 0;
	StreamEventInfo seInfo;

	if (uMediaType == MCF_AUDIO)
	{

		if (uDirection == MCF_SEND)
		{
			pChannel = m_pChannelAudioLocal;
		}
		else if (uDirection == MCF_RECV)
		{
			pChannel = m_pChannelAudioRemote;
		}
	}

	if (pChannel)
	{
		// If we get a device failure notification,
		// do a quick check to see if the device is indeed
		// jammed.  The device may have opened by the time we
		// got this notification

		seInfo.pChannel = pChannel;
		seInfo.uSubCode = uSubCode;

		switch (uEventCode)
		{
			case STREAM_EVENT_DEVICE_FAILURE:
			{
				seInfo.uEventCode = (NM_STREAMEVENT)NM_STREAMEVENT_DEVICE_FAILURE;
				NotifySink((void*)&seInfo, OnNotifyStreamEvent);
				break;
			}
			case STREAM_EVENT_DEVICE_OPEN:
			{
				seInfo.uEventCode = (NM_STREAMEVENT)NM_STREAMEVENT_DEVICE_OPENED;
				NotifySink((void*)&seInfo, OnNotifyStreamEvent);
				break;
			}
			default:
			{
				break;
			}
		}
	}

	else
	{
		return E_FAIL;
	}

	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\core\ichnlvid.h ===
// File: ichnlvid.h

#ifndef _ICHNLVID_H_
#define _ICHNLVID_H_

// we have no notification on the channel "callback" that the state changed
// to determine if a/v is active we need to get both the video and the audio channel

class CNmChannelVideo : public INmChannelVideo,
	public DllRefCount, public CConnectionPointContainer
{
private:
	int			m_cMembers;
	BOOL		m_fIncoming;
	static CNmChannelVideo * m_pPreviewChannel;
	FRAMECONTEXT m_FrameContext;
	IMediaChannel *m_pMediaChannel;
	ICommChannel* m_pCommChannel;
	CVideoPump	m_VideoPump;
	MEDIA_FORMAT_ID m_MediaFormat;
	
	BOOL IsCaptureAvailable() { return m_VideoPump.IsCaptureAvailable(); }
public:
	CNmChannelVideo(BOOL fIncoming);
	~CNmChannelVideo();

	static CNmChannelVideo * CreatePreviewChannel();
	static CNmChannelVideo * CreateChannel(BOOL fIncoming);

	VOID OnConnected(IH323Endpoint * pConnection, ICommChannel *pIChannel)
        { m_VideoPump.OnConnected(pConnection, pIChannel); }
	VOID OnDisconnected() {	m_VideoPump.OnDisconnected(); }

	VOID CommChannelOpened(ICommChannel *pCommChannel);
	VOID CommChannelActive(ICommChannel *pCommChannel);
	VOID CommChannelError(DWORD dwStatus) { m_VideoPump.OnChannelError(); }
	VOID CommChannelRemotePaused(BOOL fPause) { OnStateChange(); }
	VOID CommChannelClosed();
	ICommChannel * GetCommChannel() { return m_pCommChannel; }
	ICommChannel * GetPreviewCommChannel() { return m_VideoPump.GetCommChannel();}
	VOID SetFormat(MEDIA_FORMAT_ID id) { m_MediaFormat = id;}
    BOOL IsSendEnabled() { return m_VideoPump.IsSendEnabled(); }
    BOOL IsPreviewEnabled() { return m_VideoPump.IsPreviewEnabled(); }

	VOID OnMemberAdded(CNmMember *pMember);
	VOID OnMemberRemoved(CNmMember *pMember);
	VOID OnMemberUpdated(CNmMember *pMember);

	IMediaChannel *GetMediaChannelInterface(void)
		{ if (m_pMediaChannel) m_pMediaChannel->AddRef(); return m_pMediaChannel;}

	VOID OnStateChange();
	VOID OnFrameAvailable();

    VOID Open();
    VOID Close();

	// IUnknown
	STDMETHODIMP_(ULONG) AddRef(void);
	STDMETHODIMP_(ULONG) Release(void);
	STDMETHODIMP QueryInterface(REFIID riid, PVOID *ppvObj);

	// INmChannel
    STDMETHODIMP IsSameAs(INmChannel *pChannel);
    STDMETHODIMP IsActive();
    STDMETHODIMP SetActive(BOOL fActive);
    STDMETHODIMP GetConference(INmConference **ppConference);
    STDMETHODIMP GetInterface(IID *piid);
    STDMETHODIMP GetNmch(ULONG *puCh);
    STDMETHODIMP EnumMember(IEnumNmMember **ppEnum);
    STDMETHODIMP GetMemberCount(ULONG * puCount);

	// INmChannelVideo
    STDMETHODIMP IsIncoming(void);
    STDMETHODIMP GetState(NM_VIDEO_STATE *puState);
    STDMETHODIMP GetProperty(NM_VIDPROP uID, ULONG_PTR *puValue);
    STDMETHODIMP SetProperty(NM_VIDPROP uID, ULONG_PTR uValue);

	static VOID __stdcall FrameReadyCallback(DWORD_PTR dwMyThis);
};

#endif // _ICHNLVID_H_

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\core\iconf.h ===
/***************************************************************************/
/** 				 Microsoft Windows									  **/
/** 		   Copyright(c) Microsoft Corp., 1995-1996					  **/
/***************************************************************************/

//
//	File:		iconf.h
//	Created:	ChrisPi 	12/6/95
//	Modified:
//
//	The CConfObject class is defined
//

#ifndef _ICONF_H_
#define _ICONF_H_

#include <inodecnt.h>
#include "h323.h"
#include "connpnts.h"
#include "medialst.h"
#include <atlbase.h>
#include <lst.h>

enum CONFSTATE
{
	CS_UNINITIALIZED,
	CS_CREATING,
	CS_COMING_UP,
	CS_RUNNING,
	CS_GOING_DOWN,
	CS_TERMINATED
};

enum AC_TYPE
{
	CLT_T120,
	CLT_H323
};

class CNmMember;
class CNmChannelAudio;
class CNmChannelVideo;
class CNmChannelData;

class CConfObject : public INmConference2, public CConnectionPointContainer,
    public IStreamEventNotify
{
protected:
	COBLIST m_MemberList;
	COBLIST m_DataChannelGUIDS;

	CNmChannelAudio * m_pChannelAudioLocal;
	CNmChannelVideo * m_pChannelVideoLocal;
	CNmChannelAudio * m_pChannelAudioRemote;
	CNmChannelVideo * m_pChannelVideoRemote;
    IH323ConfAdvise * m_pIH323ConfAdvise;
	// Attributes:
	
	CONFSTATE		m_csState;
	CONF_HANDLE 	m_hConf;
	BOOL			m_fConferenceCreated;
	BOOL			m_fServerMode;

	BSTR            m_bstrConfName;
	BSTR            m_bstrConfPassword;
	PBYTE		    m_pbConfHashedPassword;
	DWORD		    m_cbConfHashedPassword;

    NM30_MTG_PERMISSIONS m_attendeePermissions;
    UINT            m_maxParticipants;

	CNmMember * 	m_pMemberLocal;
	UINT			m_uDataMembers;
	UINT			m_uH323Endpoints;
	UINT			m_uMembers;
	UINT			m_ourNodeID;
	UINT			m_uGCCConferenceID;
	ULONG			m_cRef;
	BOOL			m_fSecure;

	VOID			AddMember(CNmMember * pMember, IH323Endpoint * pConnection);
	VOID			RemoveMember(POSITION pos);
	VOID			RemoveMember(CNmMember * pMember)
					{
						POSITION pos = m_MemberList.GetPosition(pMember);
						if (NULL != pos)
						{
							RemoveMember(pos);
						}
					}
	VOID			ResetDataMember(CNmMember * pMember,
											ROSTER_DATA_HANDLE hData);
    VOID            RemoveOldDataMembers(int nExpected);
	CNmMember *     MatchDataToH323Member(REFGUID pguidNodeId,
								UINT uNodeId,
								PVOID pvUserInfo);
	VOID			AddDataToH323Member(CNmMember * pMember,
								PVOID pvUserInfo,
								UINT cbUserInfo,
								UINT uCaps,
								NC_ROSTER_NODE_ENTRY* pRosterNode);
	CNmMember * 	CreateDataMember(BOOL fLocal, 
								REFGUID pguidNodeId,
								PVOID pvUserInfo,
								UINT cbUserInfo,
								UINT uCaps,
								NC_ROSTER_NODE_ENTRY* pRosterNode);
	CNmMember * 	MatchH323ToDataMembers(REFGUID pguidNodeId,
								IH323Endpoint * pConnection);
    
	VOID			CreateMember(IH323Endpoint * pConnection, REFGUID rguidNode, UINT uNodeID);
	VOID			AddH323ToDataMember(CNmMember * pMember, IH323Endpoint * pConnection);
	VOID			RemoveH323FromDataMember(CNmMember * pMember, IH323Endpoint * pConnection);
	VOID			SetT120State(CONFSTATE state);
	VOID			OnH323ChannelChange(DWORD dwFlags, BOOL fIncoming, BOOL fOpen, ICommChannel *pIChannel);
	VOID			AddMemberToAVChannels(CNmMember *pMember);
	VOID			RemoveMemberFromAVChannels(CNmMember *pMember);
	VOID			CreateAVChannels(IH323Endpoint * pConnection, CMediaList* pMediaList);
    VOID            OpenAVChannels(IH323Endpoint * pConnection, CMediaList* pMediaList);
	VOID			DestroyAVChannels();
	ICommChannel *	CreateT120Channel(IH323Endpoint * pConnection, CMediaList* pMediaList);
    VOID            OpenT120Channel(IH323Endpoint * pConnection, CMediaList* pMediaList, ICommChannel *pChannelT120);
	VOID		    CheckState(NM_CONFERENCE_STATE pState);

	HRESULT __stdcall EventNotification(UINT uDirection, UINT uMediaType, UINT uEventCode, UINT uSubCode);


public:
	
	// Methods:

				CConfObject();
				~CConfObject();
    VOID        Init(IH323ConfAdvise * pci) {m_pIH323ConfAdvise = pci; };
	VOID		OnConferenceCreated() {m_fConferenceCreated = TRUE; }
	VOID		OnMemberUpdated(INmMember *pMember);
	VOID		OnChannelUpdated(INmChannel *pChannel);
	
	HRESULT 	CreateConference(void);
	HRESULT 	JoinConference(LPCWSTR	pcwszConferenceName,
							   LPCWSTR	pcwszPassword,
							   LPCSTR	pcszAddress,
							   BSTR		bstrUserString,
							   BOOL		fRetry = FALSE);
	HRESULT 	InviteConference(LPCSTR pszAddr,
								 BSTR bstrUserString,
	                             REQUEST_HANDLE *phRequest);
	HRESULT 	LeaveConference(BOOL fForceLeave=TRUE);
	HRESULT		CancelInvite(REQUEST_HANDLE hRequest)
				{
					if (NULL == m_hConf)
					{
						return E_FAIL;
					}
					return m_hConf->CancelInvite(hRequest);
				}

    HRESULT     LeaveH323(BOOL fKeepAV);

	// Properties:

	BSTR	 	GetConfName()			{ return m_bstrConfName;         };
	UINT		GetOurNodeID()			{ return m_ourNodeID;				};
	UINT		GetGCCConferenceID()	{ return m_uGCCConferenceID;		};
	UINT		GetNumMembers()			{ return m_uMembers;			};
	BOOL		InCall()				{ return (m_uMembers > 0); 	};
	COBLIST*	GetMemberList()			{ return &m_MemberList;		};
	CONF_HANDLE GetConfHandle() 		{ return m_hConf;					};
	CONFSTATE	GetT120State()			{ return m_csState; 				};
	BOOL		IsConferenceActive()	{ return m_hConf!= NULL;			};
	BOOL		IsConferenceCreated()	{ return m_fConferenceCreated;		};
	BOOL		IsConfObjSecure()		{ return m_fSecure; };
	CNmMember * GetLocalMember()		{ return m_pMemberLocal;			};
    NM30_MTG_PERMISSIONS GetConfAttendeePermissions() { return m_attendeePermissions; }
    UINT        GetConfMaxParticipants() { return m_maxParticipants; }

	DWORD       GetDwUserIdLocal(void);
    HRESULT     GetMediaChannel (GUID *pmediaID,BOOL bSendDirection, IMediaChannel **ppI);

	VOID        SetConfName(BSTR bstr);
	VOID        SetConfPassword(BSTR bstr);
	VOID        SetConfHashedPassword(BSTR bstr);
	VOID        SetConfSecurity(BOOL fSecure);
    VOID        SetConfAttendeePermissions(NM30_MTG_PERMISSIONS attendeePermissions);
    VOID        SetConfMaxParticipants(UINT maxParticipants);
	
	CNmMember *	PMemberFromNodeGuid(REFGUID pguidNode);
	CNmMember *	PMemberFromGCCID(UINT uNodeID);
	CNmMember * PMemberFromH323Endpoint(IH323Endpoint * pConnection);
	CNmMember *	PDataMemberFromName(PCWSTR pwszName);

	// Event Handlers:
	
	VOID OnT120Connected(IH323Endpoint * pConnection, UINT uNodeID);

	// Data Conferencing (R1.1, T.120) events from NCUI:
	BOOL		OnRosterChanged(PNC_ROSTER pRoster);
	BOOL		OnT120Invite(CONF_HANDLE hConference, BOOL fSecure);
	BOOL		OnConferenceEnded();
	BOOL		OnConferenceStarted(CONF_HANDLE hNewConf,
									HRESULT Result);
									
	// H323 Connection events from opncui.cpp:
	VOID		OnH323Connected(IH323Endpoint * pConnection, DWORD dwFlags, BOOL fAddMember, REFGUID rguidNode);
	VOID		OnH323Disconnected(IH323Endpoint * pConnection, BOOL fHasAV);
	VOID		OnAudioChannelStatus(ICommChannel *pIChannel, IH323Endpoint * lpConnection, DWORD dwStatus);
	VOID		OnVideoChannelStatus(ICommChannel *pIChannel, IH323Endpoint * lpConnection, DWORD dwStatus);

	// INmConference
	STDMETHODIMP_(ULONG) AddRef(void);
	STDMETHODIMP_(ULONG) Release(void);
	STDMETHODIMP QueryInterface(REFIID riid, PVOID *ppvObj);

	STDMETHODIMP GetName(BSTR *pbstrName);
	STDMETHODIMP GetID(ULONG *puID);
	STDMETHODIMP GetState(NM_CONFERENCE_STATE *pState);
	STDMETHODIMP GetNmchCaps(ULONG *puchCaps);
	STDMETHODIMP GetTopProvider(INmMember **ppMember);
	STDMETHODIMP EnumMember(IEnumNmMember **ppEnum);
	STDMETHODIMP GetMemberCount(ULONG *puCount);
	STDMETHODIMP EnumChannel(IEnumNmChannel **ppEnum);
	STDMETHODIMP GetChannelCount(ULONG *puCount);
	STDMETHODIMP CreateDataChannel(INmChannelData **ppChannel, REFGUID rguid);
	STDMETHODIMP IsHosting(void);
	STDMETHODIMP Host(void);
	STDMETHODIMP Leave(void);
	STDMETHODIMP LaunchRemote(REFGUID rguid, INmMember *pMember);

	// INmConference3
	STDMETHODIMP DisconnectAV(INmMember *pMember);
	STDMETHODIMP ConnectAV(INmMember *pMember);
	STDMETHODIMP GetConferenceHandle(DWORD_PTR *pdwHandle);
	STDMETHODIMP CreateDataChannelEx(INmChannelData **ppChannel, REFGUID rguid, BYTE* pER);

	void _EraseDataChannelGUIDS(void);
	void RemoveDataChannelGUID(REFGUID rguid);
};

CConfObject * GetConfObject(void);
HRESULT GetConference(INmConference **ppConference);
COBLIST * GetMemberList(void);

#endif /* _ICONF_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\core\imember.cpp ===
// File: iMember.cpp
//
// INmMember interface  (participant routines)

#include "precomp.h"
#include "imember.h"
#include "rostinfo.h"
#include "imanager.h" // for g_pNodeController

/*  C  N M  M E M B E R  */
/*-------------------------------------------------------------------------
    %%Function: CNmMember Constructor
    
-------------------------------------------------------------------------*/
CNmMember::CNmMember(PWSTR pwszName, DWORD dwGCCID, DWORD dwFlags, ULONG uCaps,
						REFGUID rguidNode, PVOID pwszUserInfo, UINT cbUserInfo) :
	m_bstrName     (SysAllocString(pwszName)),
	m_dwGCCID      (dwGCCID),
	m_dwFlags      (dwFlags),
	m_uCaps        (uCaps),
	m_guidNode     (rguidNode),
	m_cbUserInfo   (cbUserInfo),
	m_uNmchCaps    (0),
	m_dwGccIdParent(INVALID_GCCID),
	m_pwszUserInfo (NULL),
	m_pConnection(NULL)
{
	// Local state never changes
	m_fLocal = 0 != (PF_LOCAL_NODE & m_dwFlags);

	// check to see if we have the right GUID for local member
	// guid will be NULL if we have H323 disabled.
	ASSERT (!m_fLocal || (GUID_NULL == rguidNode) || (g_guidLocalNodeId == rguidNode));

	SetUserInfo(pwszUserInfo, cbUserInfo);

	DbgMsg(iZONE_OBJECTS, "Obj: %08X created CNmMember", this);
}


CNmMember::~CNmMember(void)
{
	SysFreeString(m_bstrName);

	delete m_pwszUserInfo;
	if(m_pConnection)
		m_pConnection->Release();
		
	DbgMsg(iZONE_OBJECTS, "Obj: %08X destroyed CNmMember", this);
}

VOID CNmMember::SetGccIdParent(DWORD dwGccId)
{
	m_dwGccIdParent = dwGccId;
	if (0 == dwGccId)
	{
		// No Parent means this is the Top Provider
		m_dwFlags |= PF_T120_TOP_PROV;
	}
	else
	{
		m_dwFlags &= ~PF_T120_TOP_PROV;
	}
}

VOID CNmMember::SetUserInfo(PVOID pwszUserInfo, UINT cbUserInfo)
{
	// clear out any previous data
	delete m_pwszUserInfo;
	m_cbUserInfo = 0;

	if (0 == cbUserInfo)
	{
		m_pwszUserInfo = NULL;
	}
	else
	{
		m_pwszUserInfo = (PWSTR) new BYTE[cbUserInfo];
		if (NULL == m_pwszUserInfo)
		{
			WARNING_OUT(("CNmMember: unable to alloc space for user data"));
		}
		else
		{
			m_cbUserInfo = cbUserInfo;
			CopyMemory(m_pwszUserInfo, pwszUserInfo, m_cbUserInfo);
		}
	}
}

BOOL CNmMember::GetSecurityData(PBYTE * ppb, ULONG * pcb)
{
	DWORD dwGCCID = FLocal() ? 0 : GetGCCID();

	(* pcb) = 0;
	(* ppb) = NULL;
	
	// If this node is directly connected to the member, we use the transport data...
	if (::T120_GetSecurityInfoFromGCCID(dwGCCID,NULL,pcb)) {
		if (0 != (* pcb)) {
			// We are directly connected and security data is valid.
			(*ppb) = (PBYTE)CoTaskMemAlloc(*pcb);
			if ((*ppb) != NULL)
			{
				::T120_GetSecurityInfoFromGCCID(dwGCCID,*ppb,pcb);
				return TRUE;
			}
			else
			{
				ERROR_OUT(("CoTaskMemAlloc failed in GetSecurityData"));
			}
		}
		else if (GetUserData(g_csguidSecurity,ppb,pcb) == S_OK)
		{
			// We are not directly connected, so get security data from roster.
			return TRUE;
		}
	}	
	return FALSE;
}

HRESULT CNmMember::ExtractUserData(LPTSTR psz, UINT cchMax, PWSTR pwszKey)
{
	CRosterInfo ri;
	HRESULT hr = ri.Load(GetUserInfo());
	if (FAILED(hr))
		return hr;

	hr = ri.ExtractItem(NULL, pwszKey, psz, cchMax);
	return hr;
}

HRESULT CNmMember::GetIpAddr(LPTSTR psz, UINT cchMax)
{
	return ExtractUserData(psz, cchMax, (PWSTR) g_cwszIPTag);
}

///////////////////////////
//  CNmMember:IUknown

ULONG STDMETHODCALLTYPE CNmMember::AddRef(void)
{

    DBGENTRY(CNmMember::AddRef);

    TRACE_OUT(("CNmMember [%ls]:  AddRef this = 0x%X", m_bstrName ? m_bstrName : L"", this));

    ULONG ul = RefCount::AddRef();

    DBGEXIT(CNmMember::AddRef);

	return ul;
}
	
ULONG STDMETHODCALLTYPE CNmMember::Release(void)
{

    DBGENTRY(CNmMember::Release);

    TRACE_OUT(("CNmMember [%ls]: Release this = 0x%X", m_bstrName ? m_bstrName : L"", this));

    ULONG ul = RefCount::Release();

    DBGEXIT(CNmMember::Release);

	return ul;
}


HRESULT STDMETHODCALLTYPE CNmMember::QueryInterface(REFIID riid, PVOID *ppv)
{
	HRESULT hr = S_OK;

	if ((riid == IID_INmMember) || (riid == IID_IUnknown))
	{
		*ppv = (INmMember *)this;
		ApiDebugMsg(("CNmMember::QueryInterface()"));
	}
	else
	{
		hr = E_NOINTERFACE;
		*ppv = NULL;
		ApiDebugMsg(("CNmMember::QueryInterface(): Called on unknown interface."));
	}

	if (S_OK == hr)
	{
		AddRef();
	}

	return hr;
}



///////////////
// INmMember


HRESULT STDMETHODCALLTYPE CNmMember::GetName(BSTR *pbstrName)
{
	if (NULL == pbstrName)
		return E_POINTER;

	*pbstrName = SysAllocString(m_bstrName);

	return *pbstrName ? S_OK : E_FAIL;
}

HRESULT STDMETHODCALLTYPE CNmMember::GetID(ULONG *puID)
{
	if (NULL == puID)
		return E_POINTER;

	*puID = m_dwGCCID;
	return (0 != m_dwGCCID) ? S_OK : NM_E_NO_T120_CONFERENCE;
}

HRESULT STDMETHODCALLTYPE CNmMember::GetNmVersion(ULONG *puVersion)
{
	if (NULL == puVersion)
		return E_POINTER;

	*puVersion = (ULONG) HIWORD(m_dwFlags & PF_VER_MASK);
	return S_OK;
}

HRESULT STDMETHODCALLTYPE CNmMember::GetAddr(BSTR *pbstrAddr, NM_ADDR_TYPE *puType)
{
	if ((NULL == pbstrAddr) || (NULL == puType))
		return E_POINTER;

	TCHAR szIp[MAX_PATH];

	if (S_OK != GetIpAddr(szIp, CCHMAX(szIp)))
	{
		return E_FAIL;
	}

	*puType = NM_ADDR_IP;
	*pbstrAddr = SysAllocString(CUSTRING(szIp));

	return *pbstrAddr ? S_OK : E_FAIL;
}

HRESULT STDMETHODCALLTYPE CNmMember::SetUserData(REFGUID rguid, BYTE *pb, ULONG cb)
{
	return m_UserData.AddUserData((GUID *)&rguid,(unsigned short)cb,pb);
}

HRESULT STDMETHODCALLTYPE CNmMember::GetUserData(REFGUID rguid, BYTE **ppb, ULONG *pcb)
{
	return m_UserData.GetUserData(rguid,ppb,pcb);
}

STDMETHODIMP CNmMember::GetConference(INmConference **ppConference)
{
	return ::GetConference(ppConference);
}

HRESULT STDMETHODCALLTYPE CNmMember::GetNmchCaps(ULONG *puCaps)
{
	if (NULL == puCaps)
		return E_POINTER;

	if (m_dwFlags & PF_T120)
	{
		// this can be removed when NMCH_SHARE and NMCH_DATA is reliable
        *puCaps = m_uNmchCaps | NMCH_SHARE | NMCH_DATA;
	}
	else
	{
		*puCaps = m_uNmchCaps;
	}
	return S_OK;
}

HRESULT STDMETHODCALLTYPE CNmMember::GetShareState(NM_SHARE_STATE *puState)
{
    return(E_FAIL);
}

HRESULT STDMETHODCALLTYPE CNmMember::IsSelf(void)
{
	return m_fLocal ? S_OK : S_FALSE;
}

HRESULT STDMETHODCALLTYPE CNmMember::IsMCU(void)
{
	return (m_dwFlags & PF_T120_MCU) ? S_OK : S_FALSE;
}

HRESULT STDMETHODCALLTYPE CNmMember::Eject(void)
{
	if (m_fLocal)
		return E_FAIL; // can't eject ourselves.

	if (PF_T120 & m_dwFlags)
	{
		CNmMember * pMemberLocal = GetLocalMember();
		if ((NULL == pMemberLocal) || !pMemberLocal->FTopProvider())
			return E_FAIL; // only top providers should be allowed to do this

		CConfObject * pco = ::GetConfObject();
		if (NULL != pco)
		{
			ASSERT(g_pNodeController);
			ASSERT(pco->GetConfHandle());
			pco->GetConfHandle()->EjectUser(m_dwGCCID);
		}
	}

	if (NULL != m_pConnection)
	{
		HRESULT hr = m_pConnection->Disconnect();
		if (FAILED(hr))
		{
			WARNING_OUT(("m_pConnection->Disconnect() failed - hr = %s",
						::GetHRESULTString(hr)));
		}
	}
	return S_OK;
}


///////////////////////////////////////////////////////////////////////
// Utility Functions


/*  G E T  L O C A L  M E M B E R  */
/*-------------------------------------------------------------------------
    %%Function: GetLocalMember
    
-------------------------------------------------------------------------*/
CNmMember * GetLocalMember(void)
{
	CConfObject * pco = ::GetConfObject();
	if (NULL == pco)
		return NULL;

	return pco->GetLocalMember();
}


/*  P  M E M B E R  F R O M  G  C  C  I  D  */
/*-------------------------------------------------------------------------
    %%Function: PMemberFromGCCID
    
-------------------------------------------------------------------------*/
CNmMember * PMemberFromGCCID(UINT uNodeID)
{
	CConfObject* pco = ::GetConfObject();
	if (NULL == pco)
		return NULL;

	return pco->PMemberFromGCCID(uNodeID);
}


/*  P  M E M B E R  F R O M  N O D E  G U I D  */
/*-------------------------------------------------------------------------
    %%Function: PMemberFromNodeGuid
    
-------------------------------------------------------------------------*/
CNmMember * PMemberFromNodeGuid(REFGUID rguidNode)
{
	CConfObject* pco = ::GetConfObject();
	if (NULL == pco)
		return NULL;

	return pco->PMemberFromNodeGuid(rguidNode);
}

CNmMember *	PDataMemberFromName(PCWSTR pwszName)
{
	CConfObject* pco = ::GetConfObject();
	if (NULL == pco)
		return NULL;

	return pco->PDataMemberFromName(pwszName);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\core\isysinfo.cpp ===
// File: isysinfo.cpp
//
// INmSysInfo interface  (system information)

#include "precomp.h"
#include "imanager.h"
#include "cuserdta.hpp"
#include "isysinfo.h"
#include <iappldr.h>
#include <tsecctrl.h>

extern VOID SetBandwidth(UINT uBandwidth);

CNmSysInfo* CNmSysInfo::m_pSysInfo = NULL;

BOOL g_fLoggedOn = FALSE; // Set by NM_SYSOPT_LOGGED_ON

static HRESULT OnGateKeeperNotify(IUnknown *pNmSysNotify, LPVOID code, REFIID riid);


static const IID * g_apiidCP_Manager[] =
{
    {&IID_INmSysInfoNotify}
};

/*  C  N M  S Y S  I N F O  */
/*-------------------------------------------------------------------------
    %%Function: CNmSysInfo

-------------------------------------------------------------------------*/
CNmSysInfo::CNmSysInfo() :
	CConnectionPointContainer(g_apiidCP_Manager, ARRAY_ELEMENTS(g_apiidCP_Manager)),
	m_bstrUserName(NULL)
{
	DbgMsg(iZONE_OBJECTS, "Obj: %08X created CNmSysInfo", this);

	ASSERT(NULL == m_pSysInfo);

	m_pSysInfo = this;
}


CNmSysInfo::~CNmSysInfo(void)
{
	DbgMsg(iZONE_OBJECTS, "Obj: %08X destroyed CNmSysInfo", this);

	SysFreeString(m_bstrUserName);

	m_pSysInfo = NULL;
}


//////////////////////////////////////////////////////////////////////////
//  CNmSysInfo:IUknown

ULONG STDMETHODCALLTYPE CNmSysInfo::AddRef(void)
{
	return RefCount::AddRef();
}
	
ULONG STDMETHODCALLTYPE CNmSysInfo::Release(void)
{
	return RefCount::Release();
}


HRESULT STDMETHODCALLTYPE CNmSysInfo::QueryInterface(REFIID riid, PVOID *ppv)
{
	HRESULT hr = S_OK;

	if ((riid == IID_INmSysInfo2) || (riid == IID_INmSysInfo) || (riid == IID_IUnknown))
	{
		*ppv = (INmSysInfo *)this;
		ApiDebugMsg(("CNmSysInfo::QueryInterface()"));
	}
	else if (riid == IID_IConnectionPointContainer)
	{
		*ppv = (IConnectionPointContainer *) this;
		DbgMsgApi("CNmSysInfo::QueryInterface(): Returning IConnectionPointContainer.");
	}
	else
	{
		hr = E_NOINTERFACE;
		*ppv = NULL;
		ApiDebugMsg(("CNmSysInfo::QueryInterface(): Called on unknown interface."));
	}

	if (S_OK == hr)
	{
		AddRef();
	}

	return hr;
}



//////////////////////////////////////////////////////////////////////////
// INmSysInfo

HRESULT STDMETHODCALLTYPE CNmSysInfo::IsInstalled(void)
{
	// TODO: GetLaunchInfo isn't useful for in-proc
	return S_OK;
}

HRESULT STDMETHODCALLTYPE CNmSysInfo::GetProperty(NM_SYSPROP uProp, BSTR *pbstrProp)
{
	return E_NOTIMPL;
}	


HRESULT STDMETHODCALLTYPE CNmSysInfo::SetProperty(NM_SYSPROP uProp, BSTR bstrData)
{
	switch (uProp)
	{
		case NM_SYSPROP_USER_NAME:
			SysFreeString(m_bstrUserName);
			m_bstrUserName = SysAllocString(bstrData);

			if (NULL != g_pH323UI)
			{
				g_pH323UI->SetUserName(bstrData);
			}
			return S_OK;

		default:
			break;
	}

	return E_INVALIDARG;
}


HRESULT STDMETHODCALLTYPE CNmSysInfo::GetUserData(REFGUID rguid, BYTE **ppb, ULONG *pcb)
{
	return m_UserData.GetUserData(rguid,ppb,pcb);
}

HRESULT STDMETHODCALLTYPE CNmSysInfo::SetUserData(REFGUID rguid, BYTE *pb, ULONG cb)
{
	return m_UserData.AddUserData((GUID *)&rguid,(unsigned short)cb,pb);
}


HRESULT STDMETHODCALLTYPE CNmSysInfo::GetNmApp(REFGUID rguid,
		BSTR *pbstrApplication, BSTR *pbstrCommandLine, BSTR *pbstrDirectory)
{
	return E_NOTIMPL;
}

HRESULT STDMETHODCALLTYPE CNmSysInfo::SetNmApp(REFGUID rguid,
		BSTR bstrApplication, BSTR bstrCommandLine, BSTR bstrDirectory)
{
	return E_NOTIMPL;
}


HRESULT STDMETHODCALLTYPE CNmSysInfo::GetNmchCaps(ULONG *pchCaps)
{
	return E_NOTIMPL;
}


HRESULT STDMETHODCALLTYPE CNmSysInfo::GetLaunchInfo(INmConference **ppConference, INmMember **ppMember)
{
	return E_NOTIMPL;
}


//////////////////////////////////////////////////////////////////////////
// INmSysInfo3

HRESULT STDMETHODCALLTYPE CNmSysInfo::GetOption(NM_SYSOPT uOption, ULONG * plValue)
{
	return E_NOTIMPL;
}

HRESULT STDMETHODCALLTYPE CNmSysInfo::SetOption(NM_SYSOPT uOption, ULONG lValue)
{
	IAudioDevice *pAudioDevice = NULL;
	IMediaChannelBuilder *pMCB = NULL;

	switch (uOption)
		{
	case NM_SYSOPT_BANDWIDTH:
	{
		::SetBandwidth(lValue);
		return S_OK;
	}
	
	case NM_SYSOPT_CAPTURE_DEVICE:
	{
		if (NULL == g_pH323UI)
			return E_FAIL;

		g_pH323UI->SetCaptureDevice(lValue);
		return S_OK;
	}
	
	case NM_SYSOPT_LOGGED_ON:
	{
		g_fLoggedOn = lValue;
		return S_OK;
	}

	case NM_SYSOPT_DIRECTSOUND:
	{
		if (NULL == g_pH323UI)
			return E_FAIL;

		pMCB = g_pH323UI->GetStreamProvider();

		if (pMCB)
		{
			pMCB->QueryInterface(IID_IAudioDevice, (void**)&pAudioDevice);
			pAudioDevice->SetDirectSound((BOOL)lValue);
			pAudioDevice->Release();
			pMCB->Release();
			return S_OK;
		}
	}

	case NM_SYSOPT_FULLDUPLEX:
	{
		if (NULL == g_pH323UI)
			return E_FAIL;

		pMCB = g_pH323UI->GetStreamProvider();
		if (pMCB)
		{
			pMCB->QueryInterface(IID_IAudioDevice, (void**)&pAudioDevice);
			pAudioDevice->SetDuplex((BOOL)lValue);  // true==full, false==half
			pAudioDevice->Release();
			pMCB->Release();
			return S_OK;
		}
	}

	default:
		break;
	}

	return E_INVALIDARG;
}

HRESULT STDMETHODCALLTYPE CNmSysInfo::ProcessSecurityData(DWORD dwTaskCode, DWORD_PTR dwParam1, DWORD_PTR dwParam2,
    	DWORD * pdwResult)
{
    switch (dwTaskCode)
    {
        case LOADFTAPPLET:
        {
            ::T120_LoadApplet(APPLET_ID_FT, TRUE, 0, FALSE, NULL);
            return S_OK;
        }
        case UNLOADFTAPPLET:
        {
            ::T120_CloseApplet(APPLET_ID_FT, TRUE, TRUE, 600);
            return S_OK;
        }
        default:
        {
            if (NULL != pdwResult) {
				(* pdwResult) = ::T120_TprtSecCtrl(dwTaskCode, dwParam1, dwParam2);
				return S_OK;
            }
            else {
				return E_FAIL;
            }
        }
    }
}


//////////////////////////////////////////////////////////////////////////
// Gatekeeper / Alias routines

HRESULT STDMETHODCALLTYPE CNmSysInfo::GkLogon(BSTR bstrServer, BSTR bstrAliasID, BSTR bstrAliasE164)
{
	TRACE_OUT(("Gatekeeper Logon: Server=[%ls] AliasID=[%ls] AliasE164=[%ls]",
		bstrServer,
		bstrAliasID ? bstrAliasID : L"<NULL>",
		bstrAliasE164 ? bstrAliasE164 : L"<NULL>"));

	HRESULT hr = E_FAIL;
	
	if (NULL != g_pH323UI)
	{
		IH323CallControl * pH323CallControl = g_pH323UI->GetH323CallControl();
		if (NULL != pH323CallControl)
		{
			SOCKADDR_IN sin;
			sin.sin_family = AF_INET;
			sin.sin_addr.s_addr = inet_addr(CUSTRING(bstrServer));

			// If inet_addr failed, this may be a host address, so try to
			// resolve it

			if (INADDR_NONE == sin.sin_addr.s_addr)
			{
				HOSTENT *host_info;
				
				if ( NULL != (host_info = gethostbyname(CUSTRING(bstrServer))))
				{
					// Only expecting IP addresses..
					ASSERT(( host_info->h_addrtype == AF_INET ));
					ASSERT(( host_info->h_length == sizeof(DWORD)));

					sin.sin_addr.s_addr = *((DWORD *)host_info->h_addr);
				}
			}

			if ((INADDR_NONE != sin.sin_addr.s_addr)
			 && (INADDR_ANY != sin.sin_addr.s_addr))
			{
				H323ALIASLIST AliasList;
				H323ALIASNAME AliasNames[2];
				UINT nAliases = 0;
				UINT nLen;
				
				nLen = SysStringLen(bstrAliasID);
				if (nLen > 0)
				{
					AliasNames[nAliases].aType = AT_H323_ID;
					AliasNames[nAliases].lpwData = bstrAliasID;
					AliasNames[nAliases].wDataLength = (WORD)nLen;// # of unicode chars, w/o NULL terminator
					++nAliases;
				}
				nLen = SysStringLen(bstrAliasE164);
				if (nLen > 0)
				{
					AliasNames[nAliases].aType = AT_H323_E164;
					AliasNames[nAliases].lpwData = bstrAliasE164;
					AliasNames[nAliases].wDataLength = (WORD)nLen;// # of unicode chars, w/o NULL terminator
					++nAliases;
				}
				AliasList.wCount = (WORD)nAliases;
				AliasList.pItems = AliasNames;

				hr = pH323CallControl->EnableGatekeeper(TRUE, &sin, &AliasList, CNmSysInfo::RasNotify);
				if (SUCCEEDED(hr))
				{
					// keep a global copy of the Getkeeper SOCKADDR_IN
					g_sinGateKeeper = sin;
				}
			}
		}
	}
	
	return hr;
}

HRESULT STDMETHODCALLTYPE CNmSysInfo::GkLogoff(void)
{
	TRACE_OUT(("Gatekeeper Logoff"));

	HRESULT hr;

	if (NULL != g_pH323UI)
	{
		IH323CallControl * pH323CallControl = g_pH323UI->GetH323CallControl();
		if (NULL != pH323CallControl)
		{
			hr = pH323CallControl->EnableGatekeeper(FALSE,  NULL, NULL, CNmSysInfo::RasNotify);
			if (SUCCEEDED(hr))
			{
				// invalidate the global Getkeeper SOCKADDR_IN
				g_sinGateKeeper.sin_addr.s_addr = INADDR_NONE;
			}
		}
	}


	return hr;
}

HRESULT STDMETHODCALLTYPE CNmSysInfo::GkState(NM_GK_STATE * pgkState)
{
	if (NULL == pgkState)
		return E_POINTER;

	*pgkState = NM_GK_INVALID;
	return E_NOTIMPL;
}


VOID CALLBACK CNmSysInfo::RasNotify(DWORD dwRasEvent, HRESULT hReason)
{
	
	NM_GK_NOTIFY_CODE code = NM_GKNC_INVALID;

	switch(dwRasEvent)
	{
		case RAS_REG_TIMEOUT:	// GK did not respond.  (no hReason)
			code = NM_GKNC_LOGON_TIMEOUT;
			break;

		case RAS_REG_CONFIRM:	// received RCF (registration confirmed)  (no hReason)
			code = NM_GKNC_REG_CONFIRM;
			break;

		case RAS_UNREG_CONFIRM: // received UCF (unregistration confirmed)  (no hReason)
			code = NM_GKNC_UNREG_CONFIRM;
			break;

		case RAS_REJECTED:		// received RRJ (registration rejected)
			
			code = NM_GKNC_REJECTED;

			ASSERT(CUSTOM_FACILITY(hReason) == FACILITY_GKIREGISTRATION);
			switch(CUSTOM_FACILITY_CODE(hReason))
			{
				case RRJ_DISCOVERY_REQ:					TRACE_OUT(("NmSysInfo::RasNotify: GateKeeper logon failed with code RRJ_DISCOVERY_REQ"));
					break;

				case RRJ_INVALID_REVISION:				TRACE_OUT(("GateKeeper logon failed with code RRJ_INVALID_REVISION"));
					break;

				case RRJ_INVALID_CALL_ADDR:				TRACE_OUT(("GateKeeper logon failed with code RRJ_INVALID_CALL_ADDR"));
					break;

				case RRJ_INVALID_RAS_ADDR:				TRACE_OUT(("GateKeeper logon failed with code RRJ_INVALID_RAS_ADDR"));
					break;	

				case RRJ_DUPLICATE_ALIAS:				TRACE_OUT(("GateKeeper logon failed with code RRJ_DUPLICATE_ALIAS"));
					break;

				case RRJ_INVALID_TERMINAL_TYPE:			TRACE_OUT(("GateKeeper logon failed with code RRJ_INVALID_TERMINAL_TYPE"));
					break;

				case RRJ_UNDEFINED:						TRACE_OUT(("GateKeeper logon failed with code RRJ_UNDEFINED"));
					break;

				case RRJ_TRANSPORT_NOT_SUPPORTED:		TRACE_OUT(("GateKeeper logon failed with code RRJ_TRANSPORT_NOT_SUPPORTED"));
					break;

				case RRJ_TRANSPORT_QOS_NOT_SUPPORTED:	TRACE_OUT(("GateKeeper logon failed with code RRJ_TRANSPORT_QOS_NOT_SUPPORTED"));
					break;

				case RRJ_RESOURCE_UNAVAILABLE:			TRACE_OUT(("GateKeeper logon failed with code RRJ_RESOURCE_UNAVAILABLE"));
					break;

				case RRJ_INVALID_ALIAS:					TRACE_OUT(("GateKeeper logon failed with code RRJ_INVALID_ALIAS"));
					break;

				case RRJ_SECURITY_DENIAL:				TRACE_OUT(("GateKeeper logon failed with code RRJ_SECURITY_DENIAL"));
					break;

				default:
				break;
			}
			
		break;
		case RAS_UNREG_REQ:		// received URQ
			code = NM_GKNC_UNREG_REQ;
		// (unregistration request - means that gatekeeper booted the endpoint off)
			ASSERT(CUSTOM_FACILITY(hReason) == FACILITY_GKIUNREGREQ);
			switch(CUSTOM_FACILITY_CODE(hReason))
			{
				case URQ_REREG_REQUIRED:	// GK wants another registration
				case URQ_TTL_EXPIRED:		// TimeToLive expired
				case URQ_SECURITY_DENIAL:	
				case URQ_UNDEFINED:
				default:
				break;
			}
		break;
		default:
		break;
	}

	if( NM_GKNC_INVALID != code )
	{
		if (m_pSysInfo)
		{
			m_pSysInfo->NotifySink(reinterpret_cast<LPVOID>(code), OnGateKeeperNotify);
		}
	}
}

HRESULT OnGateKeeperNotify(IUnknown *pNmSysNotify, LPVOID code, REFIID riid)
{
	HRESULT hr = S_OK;

	if( riid == IID_INmSysInfoNotify )
	{
		NM_GK_NOTIFY_CODE gknc = (NM_GK_NOTIFY_CODE)((DWORD_PTR)(code));
		static_cast<INmSysInfoNotify*>(pNmSysNotify)->GateKeeperNotify( gknc );
	}

	return hr;
}

//////////////////////////////////////////////////////////////////////////
// Internal Methods

HRESULT STDMETHODCALLTYPE CNmSysInfo::GetUserDataList(ULONG * pnRecords, GCCUserData *** pppUserData)
{
	unsigned short nsRecords;
	HRESULT hr = m_UserData.GetUserDataList(&nsRecords,pppUserData);
	*pnRecords = nsRecords;
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\core\imanager.h ===
#ifndef _IMANAGER_H_
#define _IMANAGER_H_

#include "confqos.h"
#include <ias.h>
#include "SDKInternal.h"

extern GUID g_csguidSecurity;
extern GUID g_csguidUserString;
extern GUID g_csguidNodeIdTag;
extern GUID g_guidLocalNodeId;

class COutgoingCall;
class COutgoingCallManager;
class CIncomingCallManager;
class CConfObject;
class CRosterInfo;
class CQoS;
class CNmSysInfo;

class COprahNCUI : public RefCount, public INodeControllerEvents, public CH323ConnEvent,
				   public INmManager2, public CConnectionPointContainer,
				   public IH323ConfAdvise
{
friend CNmSysInfo;

protected:
	static COprahNCUI *m_pOprahNCUI;
	COutgoingCallManager* m_pOutgoingCallManager;
	CIncomingCallManager* m_pIncomingCallManager;

	CNmSysInfo*  m_pSysInfo;
	CConfObject* m_pConfObject;
	HWND		m_hwnd;
	UINT		m_uCaps;
	CQoS      * m_pQoS;		// The quality of service object

	INmChannelVideo * m_pPreviewChannel;

	static VOID CALLBACK AudioConnectResponse(	LPVOID pContext1,
												LPVOID pContext2,
												DWORD dwFlags);
	static LRESULT CALLBACK WndProc(HWND hwnd, UINT uMsg,
									WPARAM wParam, LPARAM lParam);

	BOOL            m_fAllowAV;
	IH323Endpoint*	m_pAVConnection;

public:
	COprahNCUI(OBJECTDESTROYEDPROC ObjectDestroyed);
	~COprahNCUI();

	BSTR	GetUserName();
	UINT	GetOutgoingCallCount();
	BOOL	GetULSName(CRosterInfo *pri);
	VOID	GetRosterInfo(CRosterInfo *pri);
	ULONG	GetRosterCaps();
	ULONG	GetAuthenticatedName(PBYTE * ppb);
	VOID	OnOutgoingCallCreated(INmCall* pCall);
	VOID	OnOutgoingCallCanceled(COutgoingCall* pCall);
	VOID	OnIncomingCallAccepted();
	VOID	OnIncomingCallCreated(INmCall* pCall);

	BOOL	AcquireAV(IH323Endpoint* pConnection);
	BOOL	ReleaseAV(IH323Endpoint* pConnection);
	BOOL	IsOwnerOfAV(IH323Endpoint* pConnection) { return m_pAVConnection == pConnection; }

	VOID	CancelCalls();

	BOOL	IsAudioAllowed()		{ return m_fAllowAV && (m_uCaps & (CAPFLAG_SEND_AUDIO | CAPFLAG_RECV_AUDIO)); }
	BOOL	IsReceiveVideoAllowed() { return m_fAllowAV && (m_uCaps & CAPFLAG_RECV_VIDEO); }
	BOOL	IsSendVideoAllowed()	{ return m_fAllowAV && (m_uCaps & CAPFLAG_SEND_VIDEO); }
	BOOL	IsH323Enabled()			{ return m_uCaps & CAPFLAG_H323_CC; }

	CREQ_RESPONSETYPE OnH323IncomingCall(IH323Endpoint* pConn, P_APP_CALL_SETUP_DATA lpvMNMData);
    //
    // IH323ConfAdvise methods
    //
    STDMETHODIMP CallEvent (IH323Endpoint * lpConnection, DWORD dwStatus);
    STDMETHODIMP ChannelEvent (ICommChannel *pIChannel, 
        IH323Endpoint * lpConnection,	DWORD dwStatus );
    STDMETHODIMP GetMediaChannel (GUID *pmediaID, 
        BOOL bSendDirection, IMediaChannel **ppI);	
        
	VOID	_ChannelEvent ( ICommChannel *pIChannel, 
							IH323Endpoint * lpConnection,
							DWORD dwStatus);
	// H323 Connection events from H323UI:
	VOID		OnH323Connected(IH323Endpoint * lpConnection);
	VOID		OnH323Disconnected(IH323Endpoint * lpConnection);
	// Audio Conferencing events from H323UI:
	VOID		OnAudioChannelStatus(ICommChannel *pIChannel, 
							IH323Endpoint * lpConnection, DWORD dwStatus);
	// Video Conferencing events from H323UI:
	VOID		OnVideoChannelStatus(ICommChannel *pIChannel, 
							IH323Endpoint * lpConnection, DWORD dwStatus);
	// T.120 events from H323UI
    VOID		OnT120ChannelOpen(ICommChannel *pIChannel, IH323Endpoint * lpConnection, DWORD dwStatus);
    
	static COprahNCUI *GetInstance() { return m_pOprahNCUI; }
	CConfObject *GetConfObject() { return m_pConfObject; }
	VOID		SetBandwidth(UINT uBandwidth) { if (NULL != m_pQoS) m_pQoS->SetBandwidth(uBandwidth); }
	HRESULT		AbortResolve(UINT uAsyncRequest);

	//
	// INodeControllerEvents methods:
	//
	STDMETHODIMP OnConferenceStarted(	CONF_HANDLE 		hConference,
										HRESULT 			hResult);
	STDMETHODIMP OnConferenceEnded( 	CONF_HANDLE 		hConference);
	STDMETHODIMP OnRosterChanged(		CONF_HANDLE 		hConference,
										PNC_ROSTER			pRoster);
	STDMETHODIMP OnIncomingInviteRequest( CONF_HANDLE 		hConference,
										PCWSTR				pcwszNodeName,
										PT120PRODUCTVERSION pRequestorVersion,
										PUSERDATAINFO		pUserDataInfoEntries,
										UINT				cUserDataEntries,
										BOOL				fSecure);
	STDMETHODIMP OnIncomingJoinRequest( CONF_HANDLE 		hConference,
										PCWSTR				pcwszNodeName,
										PT120PRODUCTVERSION pRequestorVersion,
										PUSERDATAINFO		pUserDataInfoEntries,
										UINT				cUserDataEntries);
	STDMETHODIMP OnQueryRemoteResult(	PVOID				pvCallerContext,
										HRESULT 			hResult,
										BOOL				fMCU,
										PWSTR*				ppwszConferenceNames,
										PT120PRODUCTVERSION pVersion,
										PWSTR*                          ppwszConfDescriptors);
	STDMETHODIMP OnInviteResult(		CONF_HANDLE 		hConference,
										REQUEST_HANDLE		hRequest,
										UINT				uNodeID,
										HRESULT 			hResult,
										PT120PRODUCTVERSION pVersion);
	STDMETHODIMP OnUpdateUserData(		CONF_HANDLE 		hConference);


	//
	// INmManager methods
	//
	STDMETHODIMP_(ULONG) AddRef(void);
	STDMETHODIMP_(ULONG) Release(void);
	STDMETHODIMP QueryInterface(REFIID riid, PVOID *ppvObj);
	STDMETHODIMP Initialize(ULONG *puOptions, ULONG *puchCaps);
	STDMETHODIMP GetSysInfo(INmSysInfo **ppSysInfo);
	STDMETHODIMP EnumConference(IEnumNmConference **ppEnum);
	STDMETHODIMP CreateConference(INmConference **ppConference,
								BSTR bstrName,
								BSTR bstrPassword,
								ULONG uchCaps);
	STDMETHODIMP EnumCall(IEnumNmCall **ppEnum);
	STDMETHODIMP CreateCall(INmCall **ppCall,
						NM_CALL_TYPE callType,
						NM_ADDR_TYPE addrType,
						BSTR bstrAddr,
						INmConference *pConference);
	STDMETHODIMP CallConference(INmCall **ppCall,
							NM_CALL_TYPE callType,
							NM_ADDR_TYPE addrType,
							BSTR bstrAddr,
							BSTR bstrName,
							BSTR bstrPassword);
	//
	// INmManager2 methods
	//
	STDMETHODIMP GetPreviewChannel(INmChannelVideo **ppChannelVideo);
    STDMETHODIMP CreateASObject(IUnknown * pNotify, ULONG flags, IUnknown ** ppAS);
	STDMETHODIMP AllowH323(BOOL fAllow);
    STDMETHODIMP CallEx(INmCall **ppCall,
						DWORD	dwFlags,
						NM_ADDR_TYPE addrType,
						BSTR bstrName,
						BSTR bstrSetup,
						BSTR bstrDest,
						BSTR bstrAlias,
						BSTR bstrURL,
						BSTR userData,
						BSTR bstrConference,
						BSTR bstrPassword);

    STDMETHODIMP CreateConferenceEx(INmConference **ppConference,
                        BSTR  bstrName,
                        BSTR  bstrPassword,
                        DWORD dwTypeFlags,
                        DWORD attendeePermissions,
                        DWORD maxParticipants);

};

// The global instance that is declared in conf.cpp:
extern INodeController* g_pNodeController;
// The GUID is declared in opncui.cpp:
extern GUID g_csguidRosterCaps;

extern SOCKADDR_IN g_sinGateKeeper;

HRESULT OnNotifyCallStateChanged(IUnknown *pCallNotify, PVOID pv, REFIID riid);

typedef BOOL (WINAPI * PFNGETUSERSECURITYINFO) (DWORD dwGCCID, PBYTE pInfo, PDWORD pcbInfo);
typedef DWORD (WINAPI * PFNPROCESSSECURITYDATA) ( DWORD dwCode, DWORD dwParam1, DWORD dwParam2 );

#endif // _IMANAGER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\core\imember.h ===
// File: iMember.h

#ifndef _IMEMBER_H_
#define _IMEMBER_H_

#include "nmenum.h"
#include "cuserdta.hpp"
#include <ih323cc.h>

#define INVALID_GCCID      ((DWORD) -1)
#define H323_GCCID_LOCAL   ((DWORD) -2)
#define H323_GCCID_REMOTE  ((DWORD) -3)

class USER_DATA_LIST;

// A valid T.120 GCC ID must be in this range:
#define FValidGccId(dw)    ((dw >= 1) && (dw <= 65535))


// *** DO NOT CHANGE these flags without checking the
// corresponding CONF_UF_* items in msconf.h

// PARTICIPANT flags:

// Media Types: 
const DWORD PF_MEDIA_DATA     = 0x00000001;
const DWORD PF_MEDIA_AUDIO    = 0x00000002;
const DWORD PF_MEDIA_VIDEO    = 0x00000004;
 
const DWORD PF_T120           = 0x00000010;
const DWORD PF_H323           = 0x00000020;
const DWORD PF_T127_LAUNCHED  = 0x00000040; // Requested T.127 (FT) be started
 
const DWORD PF_LOCAL_NODE     = 0x00000100; // Local User
const DWORD PF_T120_MCU       = 0x00000200; // MCU
const DWORD PF_T120_TOP_PROV  = 0x00000400; // Top Provider
 
// Control Arbitration specific 
const DWORD PF_CA_VIEWING     = 0x00001000;
const DWORD PF_CA_DETACHED    = 0x00002000; // Working alone
const DWORD PF_CA_CONTROL     = 0x00004000; // In Control
const DWORD PF_CA_MASK        = 0x0000F000;
const DWORD PF_CA_MODEMASK = (PF_CA_VIEWING | PF_CA_DETACHED);
 
// NetMeeting Version
const DWORD PF_VER_UNKNOWN    = 0x00000000; // Not Microsoft NetMeeting
const DWORD PF_VER_NM_1       = 0x00010000; // NetMeeting 1.0 (Build 1133)
const DWORD PF_VER_NM_2       = 0x00020000; // NetMeeting 2.0 (Build 1368)
const DWORD PF_VER_NM_3       = 0x00030000; // NetMeeting 2.1x (Build 2135)
const DWORD PF_VER_NM_4       = 0x00040000; // NetMeeting 3.0
const DWORD PF_VER_FUTURE     = 0x000F0000; // Future NetMeeting version
const DWORD PF_VER_MASK       = 0x000F0000;
 
const DWORD PF_RESERVED       = 0x80000000;

const DWORD PF_VER_CURRENT = PF_VER_NM_4;   // Current version

const DWORD PF_DATA_ALL =	(	PF_MEDIA_DATA |
								PF_CA_MASK |
								PF_T120 |
								PF_T120_MCU |
								PF_T120_TOP_PROV);

class CNmMember : public DllRefCount, public INmMember
{
private:
	BSTR   m_bstrName;            // Display Name
	DWORD  m_dwGCCID;            // GCC UserId
	BOOL   m_fLocal;             // True if local user
	ULONG  m_uCaps;              // Current Roster Caps (CAPFLAG_*)
	ULONG  m_uNmchCaps;           // Current Channel Capabilities (NMCH_*)
	DWORD  m_dwFlags;            // PF_*
	DWORD  m_dwGccIdParent;      // GCCID of parent node
	GUID   m_guidNode;           // unique Id of this node
	UINT   m_cbUserInfo;         // size of user info (in bytes)
	PWSTR  m_pwszUserInfo;       // user info
	USER_DATA_LIST m_UserData;	 // user data
	IH323Endpoint* m_pConnection;

public:
	CNmMember(PWSTR pwszName, DWORD dwGCCID, DWORD dwFlags, ULONG uCaps,
	          REFGUID pguidNode, PVOID pwszUserInfo, UINT cbUserInfo);
	~CNmMember();

	// Internal methods
	IH323Endpoint *  GetH323Endpoint() { return m_pConnection;};
	VOID AddH323Endpoint(IH323Endpoint *pConnection) 
	{
        if(pConnection)
        {
            ASSERT(m_pConnection == NULL);
            m_pConnection = pConnection;
            m_pConnection->AddRef();
        }
	}
	VOID DeleteH323Endpoint(IH323Endpoint *pConnection) 
	{
        ASSERT(m_pConnection && (m_pConnection == pConnection ));
        m_pConnection->Release();
        m_pConnection = NULL;
    }
	DWORD GetDwFlags()            {return m_dwFlags;}
	VOID  SetDwFlags(DWORD dw)    {m_dwFlags = dw;}
	
	VOID AddPf(DWORD dw)          {m_dwFlags |= dw;}
	VOID RemovePf(DWORD dw)       {m_dwFlags &= ~dw;}

	ULONG GetNmchCaps()                  {return m_uNmchCaps;}
	VOID SetNmchCaps(ULONG uNmchCaps)    {m_uNmchCaps = uNmchCaps;}

	VOID AddNmchCaps(ULONG uNmchCaps)    {m_uNmchCaps |= uNmchCaps;}
	VOID RemoveNmchCaps(ULONG uNmchCaps) {m_uNmchCaps &= ~uNmchCaps;}

	DWORD GetGCCID()              {return m_dwGCCID;}
	VOID  SetGCCID(DWORD dw)      {m_dwGCCID = dw;}

	DWORD GetGccIdParent()        {return m_dwGccIdParent;}
	VOID  SetGccIdParent(DWORD dw);

	ULONG GetCaps()               {return m_uCaps;}
	VOID  SetCaps(ULONG uCaps)    {m_uCaps = uCaps;}

	PVOID GetUserInfo()           {return m_pwszUserInfo;}
	VOID  SetUserInfo(PVOID pwszUserInfo, UINT cbUserInfo);

	BOOL  GetSecurityData(PBYTE * ppb, ULONG * pcb);
	
	BOOL  FLocal()                {return m_fLocal;}
	BOOL  FTopProvider()          {return (0 != (m_dwFlags & PF_T120_TOP_PROV));}
	BOOL  FMcu()                  {return (0 != (m_dwFlags & PF_T120_MCU));}
	BOOL  FHasData()              {return (0 != (m_dwFlags & PF_T120));}

	BSTR GetName()                    {return m_bstrName;}
	REFGUID GetNodeGuid()		      {return m_guidNode;}

	HRESULT ExtractUserData(LPTSTR psz, UINT cchMax, PWSTR pwszKey);
	HRESULT GetIpAddr(LPTSTR psz, UINT cchMax);

	HRESULT STDMETHODCALLTYPE SetUserData(REFGUID rguid, BYTE *pb, ULONG cb);

	// INmMember methods
	HRESULT STDMETHODCALLTYPE GetName(BSTR *pbstrName);
	HRESULT STDMETHODCALLTYPE GetID(ULONG * puID);
	HRESULT STDMETHODCALLTYPE GetNmVersion(ULONG *puVersion);
	HRESULT STDMETHODCALLTYPE GetAddr(BSTR *pbstrAddr, NM_ADDR_TYPE *puType);
	HRESULT STDMETHODCALLTYPE GetUserData(REFGUID rguid, BYTE **ppb, ULONG *pcb);
	HRESULT STDMETHODCALLTYPE GetConference(INmConference **ppConference);
	HRESULT STDMETHODCALLTYPE GetNmchCaps(ULONG *puchCaps);
	HRESULT STDMETHODCALLTYPE GetShareState(NM_SHARE_STATE *puState);
	HRESULT STDMETHODCALLTYPE IsSelf(void);
	HRESULT STDMETHODCALLTYPE IsMCU(void);
	HRESULT STDMETHODCALLTYPE Eject(void);

	// IUnknown methods
	ULONG STDMETHODCALLTYPE AddRef(void);
	ULONG STDMETHODCALLTYPE Release(void);
	HRESULT STDMETHODCALLTYPE QueryInterface(REFIID riid, PVOID *ppvObj);
};

// Utility Functions
CNmMember * GetLocalMember(void);
CNmMember * PMemberFromGCCID(UINT uNodeID);
CNmMember *	PMemberFromNodeGuid(REFGUID rguidNode);
CNmMember *	PDataMemberFromName(PCWSTR pwszName);

typedef CEnumNmX<IEnumNmMember, &IID_IEnumNmMember, INmMember, CNmMember> CEnumNmMember;

#endif // _IMEMBER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\core\medialst.h ===
#ifndef _MEDIALST_H_
#define _MEDIALST_H_

#include "common.h"

class CMediaList
{
private:
	typedef struct _guidlist
	{
		GUID guid;
		struct _guidlist *pnext;
	}GUIDLIST, *PGUIDLIST;

	RES_PAIR    *m_pResolvedFormatIDs;
	PGUIDLIST   m_pSendMediaList, m_pRecvMediaList;
	UINT        m_uNumSendMedia, m_uNumRecvMedia;
	GUID        *m_pSendMediaGuids;
	UINT        m_uNumResolvedMedia;
	
    VOID AddSendMedia(LPGUID pMediaTypeGuid);
    VOID RemoveSendMedia(LPGUID pMediaTypeGuid);
    VOID AddRecvMedia(LPGUID pMediaTypeGuid);
    VOID RemoveRecvMedia(LPGUID pMediaTypeGuid);
    BOOL IsInList(LPGUID pMediaTypeGuid, PGUIDLIST pList);

public:
	CMediaList();
	~CMediaList();

	HRESULT ResolveSendFormats(IH323Endpoint* pConnection);
	BOOL	GetSendFormatLocalID(REFGUID guidMedia, MEDIA_FORMAT_ID* pId);
	VOID	EnableMedia(LPGUID pMediaTypeGuid, BOOL fSendDirection, BOOL fEnabled);
	BOOL	IsInSendList(LPGUID pMediaTypeGuid) { return IsInList(pMediaTypeGuid, m_pSendMediaList); }
	BOOL	IsInRecvList(LPGUID pMediaTypeGuid) { return IsInList(pMediaTypeGuid, m_pRecvMediaList); }
	VOID	Clear();
};

#endif // _MEDIALST_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\core\medialst.cpp ===
#include "precomp.h"
#include "medialst.h"


CMediaList::CMediaList() :
	m_pResolvedFormatIDs (NULL),
	m_pSendMediaGuids	(NULL),
    m_pSendMediaList	(NULL), 
    m_pRecvMediaList	(NULL),
    m_uNumSendMedia 	(0),
    m_uNumRecvMedia		(0),
	m_uNumResolvedMedia	(0)
{
}

CMediaList::~CMediaList()
{
	if(m_pResolvedFormatIDs)
		LocalFree(m_pResolvedFormatIDs);
	if(m_pSendMediaGuids)
		LocalFree(m_pSendMediaGuids);
	if(m_pSendMediaList)
	{
		PGUIDLIST pNext, pThis;
		pThis = m_pSendMediaList;
		while(pThis)
		{
			pNext = pThis->pnext;
			delete pThis;
			pThis = pNext;
		}
	}
	if(m_pRecvMediaList)
	{
		PGUIDLIST pNext, pThis;
		pThis = m_pRecvMediaList;
		while(pThis)
		{
			pNext = pThis->pnext;
			delete pThis;
			pThis = pNext;
		}
	}
}

VOID CMediaList::AddSendMedia(LPGUID pMediaTypeGuid)
{
	PGUIDLIST pGLThis;
	pGLThis = new GUIDLIST;
	ASSERT(pGLThis);
	
	pGLThis->pnext = m_pSendMediaList;
	m_pSendMediaList = pGLThis;
	pGLThis->guid = *pMediaTypeGuid;
	m_uNumSendMedia++;
}

VOID CMediaList::RemoveSendMedia(LPGUID pMediaTypeGuid)
{
	PGUIDLIST pGLThis, pGLToast = m_pSendMediaList;
	while(pGLToast)
	{
		if(pGLToast->guid == *pMediaTypeGuid)
		{
			// check head case
			if(pGLToast == m_pSendMediaList)
			{
				m_pSendMediaList = pGLToast->pnext;
			}
			else
			{
				pGLThis->pnext = pGLToast->pnext;
			}
			delete pGLToast;
			m_uNumSendMedia--;
			break;
		}
		pGLThis = pGLToast;
		pGLToast = pGLToast->pnext;
	}
}
VOID CMediaList::AddRecvMedia(LPGUID pMediaTypeGuid)
{
	PGUIDLIST pGLThis;
	pGLThis = new GUIDLIST;
	ASSERT(pGLThis);
	
	pGLThis->pnext = m_pRecvMediaList;
	m_pRecvMediaList = pGLThis;
	pGLThis->guid = *pMediaTypeGuid;
	m_uNumRecvMedia++;
}
VOID CMediaList::RemoveRecvMedia(LPGUID pMediaTypeGuid)
{
	PGUIDLIST pGLThis, pGLToast = m_pRecvMediaList;
	while(pGLToast)
	{
		if(pGLToast->guid == *pMediaTypeGuid)
		{
			// check head case
			if(pGLToast == m_pRecvMediaList)
			{
				m_pSendMediaList = pGLToast->pnext;
			}
			else
			{
				pGLThis->pnext = pGLToast->pnext;
			}
			delete pGLToast;
			m_uNumRecvMedia--;
			break;
		}
		pGLThis = pGLToast;
		pGLToast = pGLToast->pnext;
	}
}

VOID CMediaList::EnableMedia(LPGUID pMediaTypeGuid, BOOL fSendDirection, BOOL fEnabled)
{
	// two bits of info: Send = 1, enable = 2
	// 0 - disable receive
	// 1 - disable send
	// 2 - enable receive
	// 3 - enable send
	int the_case;
	
	the_case = (fSendDirection)?1:0;
	the_case |= (fEnabled)? 2:0;

	switch(the_case)
	{
		case 0:
			RemoveRecvMedia(pMediaTypeGuid);
		break;
		case 1:
			RemoveSendMedia(pMediaTypeGuid);
		break;
		case 2:
			AddRecvMedia(pMediaTypeGuid);
		break;
		case 3:
			AddSendMedia(pMediaTypeGuid);
		break;		
	}
}

BOOL CMediaList::IsInList(LPGUID pMediaTypeGuid, PGUIDLIST pList)
{
	PGUIDLIST pGLThis = pList;
	while(pGLThis)
	{
		if(pGLThis->guid == *pMediaTypeGuid)
		{
			return TRUE;
		}
		//else
		pGLThis = pGLThis->pnext;
	}
	return FALSE;
}

HRESULT CMediaList::ResolveSendFormats(IH323Endpoint* pConnection)
{
	UINT ui;
	PGUIDLIST pGLThis;

	ASSERT(NULL == m_pSendMediaGuids);
	ASSERT((0 != m_uNumSendMedia) && (NULL != m_pSendMediaList));
	
	m_pSendMediaGuids = (GUID *)LocalAlloc(LMEM_FIXED, m_uNumSendMedia*sizeof(GUID));
	ASSERT(NULL != m_pSendMediaGuids);

	for(ui=0, pGLThis = m_pSendMediaList; ui<m_uNumSendMedia; ui++)
	{
		ASSERT(NULL != pGLThis);
		*(m_pSendMediaGuids+ui) = pGLThis->guid;
		pGLThis = pGLThis->pnext;
	}
	
	// alloc space for resolved format IDs.
	ASSERT(NULL == m_pResolvedFormatIDs);
	m_pResolvedFormatIDs = 
		(RES_PAIR *)LocalAlloc(LMEM_FIXED, m_uNumSendMedia*sizeof(RES_PAIR));
	
	ASSERT(NULL != m_pResolvedFormatIDs);
	
	// and set m_uNumResolvedMedia
	m_uNumResolvedMedia = m_uNumSendMedia;

	// resolve capabilities
	return pConnection->ResolveFormats(m_pSendMediaGuids, m_uNumResolvedMedia, 
		m_pResolvedFormatIDs);
}

BOOL CMediaList::GetSendFormatLocalID(REFGUID guidMedia, MEDIA_FORMAT_ID* pId)
{
	UINT ui;
	PGUIDLIST pGLThis;

	// find the index of the appropriate media type.  Need to do this because
	// the order of media types in the list is unknown and there isn't a
	// table that relates the types with the resolved ID's.  Need to 
	// add such a table when decentralized media is supported.
	for(ui=0, pGLThis = m_pSendMediaList; ui<m_uNumSendMedia; ui++)
	{
		ASSERT(NULL != pGLThis);
		if (pGLThis->guid == guidMedia)
		{
			*pId = m_pResolvedFormatIDs[ui].idLocal;
			return TRUE;
		}
		pGLThis = pGLThis->pnext;
	}

	return FALSE;
}

VOID CMediaList::Clear()
{
	if(m_pResolvedFormatIDs)
	{
		LocalFree(m_pResolvedFormatIDs);
		m_pResolvedFormatIDs = NULL;
	}
	if(m_pSendMediaGuids)
	{
		LocalFree(m_pSendMediaGuids);
		m_pSendMediaGuids = NULL;
	}
	if(m_pSendMediaList)
	{
		PGUIDLIST pNext, pThis;
		pThis = m_pSendMediaList;
		while(pThis)
		{
			pNext = pThis->pnext;
			delete pThis;
			pThis = pNext;
		}
		m_pSendMediaList = NULL;
	}
	if(m_pRecvMediaList)
	{
		PGUIDLIST pNext, pThis;
		pThis = m_pRecvMediaList;
		while(pThis)
		{
			pNext = pThis->pnext;
			delete pThis;
			pThis = pNext;
		}
		m_pRecvMediaList = NULL;
	}
	m_uNumSendMedia = 0;
	m_uNumRecvMedia = 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\core\isysinfo.h ===
// File: iSysInfo.h

#ifndef _ISYSINFO_H_
#define _ISYSINFO_H_

class USER_DATA_LIST;

class CNmSysInfo : public DllRefCount, public INmSysInfo2, public CConnectionPointContainer
{
private:
	static CNmSysInfo* m_pSysInfo;
	USER_DATA_LIST m_UserData;
	BSTR m_bstrUserName;

public:
	CNmSysInfo();
	~CNmSysInfo();

	BSTR GetUserName() { return m_bstrUserName; }

	// IUnknown methods
	ULONG STDMETHODCALLTYPE AddRef(void);
	ULONG STDMETHODCALLTYPE Release(void);
	HRESULT STDMETHODCALLTYPE QueryInterface(REFIID riid, PVOID *ppvObj);
	
	// INmSysInfo methods
	HRESULT STDMETHODCALLTYPE IsInstalled(void);
	HRESULT STDMETHODCALLTYPE GetProperty(NM_SYSPROP uProp, BSTR *pbstrProp);
	HRESULT STDMETHODCALLTYPE SetProperty(NM_SYSPROP uProp, BSTR bstrName);
	HRESULT STDMETHODCALLTYPE GetUserData(REFGUID rguid, BYTE **ppb, ULONG *pcb);
	HRESULT STDMETHODCALLTYPE SetUserData(REFGUID rguid, BYTE *pb, ULONG cb);
	HRESULT STDMETHODCALLTYPE GetNmApp(REFGUID rguid,
		BSTR *pbstrApplication, BSTR *pbstrCommandLine, BSTR *pbstrDirectory);
	HRESULT STDMETHODCALLTYPE SetNmApp(REFGUID rguid,
		BSTR bstrApplication, BSTR bstrCommandLine, BSTR bstrDirectory);
	HRESULT STDMETHODCALLTYPE GetNmchCaps(ULONG *pchCaps);
	HRESULT STDMETHODCALLTYPE GetLaunchInfo(INmConference **ppConference, INmMember **pMember);

	// INmSysInfo2 methods
	HRESULT STDMETHODCALLTYPE GetOption(NM_SYSOPT uOption, ULONG * plOption);
	HRESULT STDMETHODCALLTYPE SetOption(NM_SYSOPT uOption, ULONG lOption);
	HRESULT STDMETHODCALLTYPE ProcessSecurityData(DWORD dwTaskCode, DWORD_PTR dwParam1, DWORD_PTR dwParam2,
    	DWORD * pdwResult);
	HRESULT STDMETHODCALLTYPE GkLogon(BSTR bstrAddr, BSTR bstrAliasID, BSTR bstrAliasE164);
	HRESULT STDMETHODCALLTYPE GkLogoff(void);
	HRESULT STDMETHODCALLTYPE GkState(NM_GK_STATE * pgkState);
    	
	// Internal Methods
	HRESULT STDMETHODCALLTYPE GetUserDataList(ULONG * pnRecords, GCCUserData *** pppUserData);
	static VOID CALLBACK RasNotify(DWORD dwRasEvent, HRESULT hReason);

};


#endif /* _ISysInfo_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\core\pfnt120.cpp ===
// File: pfnt120.cpp

#include "precomp.h"
#include "pfnt120.h"

PFN_T120_AttachRequest PFNT120::AttachRequest = NULL;
PFN_T120_CreateAppSap  PFNT120::CreateAppSap = NULL;

HINSTANCE PFNT120::m_hInstance = NULL;

APIFCN s_apiFcnT120[] = {
	{(PVOID *) &PFNT120::AttachRequest, "MCS_AttachRequest"},
	{(PVOID *) &PFNT120::CreateAppSap,  "GCC_CreateAppSap"},
};

HRESULT PFNT120::Init(void)
{
	if (NULL != m_hInstance)
		return S_OK;

	return HrInitLpfn(s_apiFcnT120, ARRAY_ELEMENTS(s_apiFcnT120), &m_hInstance, TEXT("MST120.DLL"));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\core\pfnt120.h ===
// File: pfnt120.h

#ifndef _PFNT120_H_
#define _PFNT120_H_

extern "C" {
#include <t120.h>
}
#include <gcc.h>
#include <igccapp.h>
#include <imcsapp.h>

extern "C" {
typedef MCSError (WINAPI * PFN_T120_AttachRequest)(IMCSSap **, DomainSelector, UINT, MCSCallBack, PVOID, UINT);
typedef GCCError (WINAPI * PFN_T120_CreateAppSap)(IGCCAppSap **, PVOID, LPFN_APP_SAP_CB);
}

class PFNT120
{
private:
	static HINSTANCE m_hInstance;

protected:
	PFNT120() {};
	~PFNT120() {};
	
public:
	static HRESULT Init(void);
	
	static PFN_T120_AttachRequest AttachRequest;
	static PFN_T120_CreateAppSap  CreateAppSap;
};

#endif /* _PFNT120_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\core\nmenum.h ===
#ifndef _NMENUM_H_
#define _NMENUM_H_

#include "oblist.h"
// IEnumNmX
//
template <class IEnumNmX, const IID* piidEnumNmX, class INmX, class CNmX>
class CEnumNmX : public IEnumNmX
{
private:
	INmX	**m_pList;		   // The list
	int 	  m_iCurr;		   // Current index number
	int 	  m_iMax;		   // Maximum index
	ULONG	  m_cRef;

public:
	CEnumNmX(COBLIST * pList, int cItems) :
		m_iCurr(0),
		m_iMax(0),
		m_pList(NULL),
		m_cRef(1)
	{
		if ((NULL != pList) && (0 != cItems))
		{
			m_pList = new INmX* [cItems];
			if (NULL != m_pList)
			{
				POSITION pos = pList->GetHeadPosition();
				while ((NULL != pos) && (m_iMax < cItems))
				{
					INmX *pINmX = (INmX *) (CNmX *) pList->GetNext(pos);
					ASSERT(NULL != pINmX);
					pINmX->AddRef();
					m_pList[m_iMax] = pINmX;
					m_iMax++;
				}
			}
		}
//		ApiDebugMsg(("CEnumNmX - Constructed(%08X)", this));
	}

	CEnumNmX(COBLIST * pList)
	{
		int cItems = 0;
		if (NULL != pList)
		{
			POSITION pos = pList->GetHeadPosition();
			while (NULL != pos)
			{
				pList->GetNext(pos);
				cItems++;
			}
		}
		CEnumNmX(pList, cItems);
	}


	CEnumNmX(CNmX **rgpNmX, ULONG cItems) :
		m_iCurr(0),
		m_iMax(0),
		m_pList(NULL),
		m_cRef(1)
	{
		if (NULL != rgpNmX)
		{
			m_pList = new INmX* [cItems];
			if (NULL != m_pList)
			{
				m_iMax = cItems;

				for (int i = 0; i < m_iMax; ++i)
				{
					ASSERT(NULL != rgpNmX[i]);
					rgpNmX[i]->AddRef();
					m_pList[i] = rgpNmX[i];
				}
			}
		}
//		ApiDebugMsg(("CEnumNmX - Constructed(%08X)", this));
	}

	~CEnumNmX(void)
	{
		for (int i = 0; i < m_iMax; ++i)
		{
			ASSERT(NULL != m_pList[i]);
			m_pList[i]->Release();
		}
		delete m_pList;

//		ApiDebugMsg(("CEnumNmX - Destructed (%08X)", this));
	}

	STDMETHODIMP_(ULONG) AddRef(void)
	{
		return ++m_cRef;
	}
		
	STDMETHODIMP_(ULONG) Release(void)
	{
		ASSERT(m_cRef > 0);

		if (m_cRef > 0)
		{
			m_cRef--;
		}

		ULONG cRef = m_cRef;

		if (0 == cRef)
		{
			delete this;
		}

		return cRef;
	}

	STDMETHODIMP QueryInterface(REFIID riid, PVOID *ppv)
	{
		HRESULT hr = S_OK;

		if ((riid == *piidEnumNmX) || (riid == IID_IUnknown))
		{
			*ppv = (IEnumNmX *)this;
//			ApiDebugMsg(("CEnumNmX::QueryInterface(): Returning IEnumNmX."));
		}
		else
		{
			hr = E_NOINTERFACE;
			*ppv = NULL;
//			ApiDebugMsg(("CEnumNmX::QueryInterface(): Called on unknown interface."));
		}

		if (S_OK == hr)
		{
			AddRef();
		}

		return hr;
	}

	STDMETHODIMP Next(ULONG cItem, INmX **rgpNmX, ULONG *pcFetched)
	{
		ULONG cCopied = 0;

		if ((0 == cItem) && (NULL == rgpNmX) && (NULL != pcFetched))
		{
			// Return the number of remaining elements
			*pcFetched = m_iMax - m_iCurr;
			return S_OK;
		}
		
		if ((NULL == rgpNmX) || ((NULL == pcFetched) && (cItem != 1)))
			return E_POINTER;

		if (NULL != m_pList)
		{
			while ((cCopied < cItem) && (m_iCurr < m_iMax))
			{
				*rgpNmX = m_pList[m_iCurr];
				ASSERT(NULL != *rgpNmX);
				(*rgpNmX)->AddRef();
				rgpNmX++;
				cCopied++;
				m_iCurr++;
			}
		}

		if (pcFetched != NULL)
			*pcFetched = cCopied;

		return ((cItem == cCopied) ? S_OK : S_FALSE);
	}

	STDMETHODIMP Skip(ULONG cItem)
	{
		m_iCurr += cItem;
		if (m_iCurr >= m_iMax)
		{
			// Past the end of the list
			m_iCurr = m_iMax;
			return S_FALSE;
		}

		return S_OK;
	}

	STDMETHODIMP Reset()
	{
		m_iCurr = 0;
		return S_OK;
	}

	STDMETHODIMP Clone(IEnumNmX **ppEnum)
	{
		if (NULL == ppEnum)
			return E_POINTER;

		HRESULT hr = S_OK;
		CEnumNmX * pEnum = new CEnumNmX(NULL, 0);
		if (NULL == pEnum)
		{
			hr = E_OUTOFMEMORY;
		}
		else if (NULL != m_pList)
		{
			pEnum->m_pList = new INmX*[m_iMax];
			if (NULL == pEnum->m_pList)
			{
				delete pEnum;
				pEnum = NULL;
				hr = E_OUTOFMEMORY;
			}
			else
			{
				pEnum->m_iCurr = m_iCurr;
				pEnum->m_iMax = m_iMax;

				for (int i = 0; i < m_iMax; ++i)
				{
					ASSERT(NULL != m_pList[i]);
					m_pList[i]->AddRef();
					pEnum->m_pList[i] = m_pList[i];
				}
			}
		}

		*ppEnum = pEnum;
		return hr;
	}
};

#endif	// _NMENUM_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\core\nmdll.cpp ===
// File: nmdll.cpp

#include "precomp.h"

///////////////////////////////////////////////////////////////////////////
// Globals

HINSTANCE g_hInst = NULL;

///////////////////////////////////////////////////////////////////////////


/*  D L L  M A I N  */
/*-------------------------------------------------------------------------
    %%Function: DllMain
    
-------------------------------------------------------------------------*/
BOOL WINAPI DllMain(HINSTANCE hDllInst, DWORD fdwReason, LPVOID lpv)
{
	switch (fdwReason)
	{
	case DLL_PROCESS_ATTACH:
	{
		g_hInst = hDllInst;
		DisableThreadLibraryCalls(hDllInst);
		DbgInitZones();
        DBG_INIT_MEMORY_TRACKING(hDllInst);
		TRACE_OUT(("*** NMCOM.DLL: Attached process thread %X", GetCurrentThreadId()));
		break;
	}

	case DLL_PROCESS_DETACH:
		TRACE_OUT(("*** NMCOM.DLL: Detaching process thread %X", GetCurrentThreadId()));
        DBG_CHECK_MEMORY_TRACKING(hDllInst);
		DbgFreeZones();
		break;

	default:
		break;
	}

	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\core\refcount.cpp ===
// File: refcount.cpp
//
// RefCount class

#include "precomp.h"


/*  R E F  C O U N T  */
/*-------------------------------------------------------------------------
    %%Function: RefCount
    
-------------------------------------------------------------------------*/
RefCount::RefCount(OBJECTDESTROYEDPROC ObjectDestroyed)
{
	ASSERT((!ObjectDestroyed) ||
		IS_VALID_CODE_PTR(ObjectDestroyed, OBJECTDESTROYEDPROC));

	m_ulcRef = 1;
	m_ObjectDestroyed = ObjectDestroyed;
	DbgMsgRefCount("Ref: %08X c=%d (created)", this, m_ulcRef);

	ASSERT(IS_VALID_STRUCT_PTR(this, CRefCount));
#ifdef DEBUG
	m_fTrack = FALSE;
#endif
}


RefCount::~RefCount(void)
{
	ASSERT(IS_VALID_STRUCT_PTR(this, CRefCount));

	// m_ulcRef may be any value.
	DbgMsgRefCount("Ref: %08X c=%d (destroyed)", this, m_ulcRef);

	if (m_ObjectDestroyed)
	{
		m_ObjectDestroyed();
		m_ObjectDestroyed = NULL;
	}

	ASSERT(IS_VALID_STRUCT_PTR(this, CRefCount));
}


ULONG STDMETHODCALLTYPE RefCount::AddRef(void)
{
	ASSERT(IS_VALID_STRUCT_PTR(this, CRefCount));

	ASSERT(m_ulcRef < ULONG_MAX);
	m_ulcRef++;
	DbgMsgRefCount("Ref: %08X c=%d (AddRef)", this, m_ulcRef);

	ASSERT(IS_VALID_STRUCT_PTR(this, CRefCount));

#ifdef DEBUG
	if (m_fTrack)
	{
		DbgMsg(iZONE_OBJECTS, "Obj: %08X c=%d (AddRef)  *** Tracking", this, m_ulcRef);
	}
#endif
	return m_ulcRef;
}


ULONG STDMETHODCALLTYPE RefCount::Release(void)
{
	ASSERT(IS_VALID_STRUCT_PTR(this, CRefCount));

	if (m_ulcRef > 0)
	{
		m_ulcRef--;
	}

#ifdef DEBUG
	if (m_fTrack)
	{
		DbgMsg(iZONE_OBJECTS, "Obj: %08X c=%d (Release) *** Tracking", this, m_ulcRef);
	}
#endif

	ULONG ulcRef = m_ulcRef;
	DbgMsgRefCount("Ref: %08X c=%d (Release)", this, m_ulcRef);

	if (! ulcRef)
	{
		delete this;
	}

	return ulcRef;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\core\precomp.h ===
// File: precomp.h

#define OEMRESOURCE
#define INC_OLE2

// Standard Windows includes
#include <windows.h>
#include <tchar.h>
#include <ocidl.h>
#include <mmsystem.h>
#include <winsock.h>
#include <time.h>

// Standard NetMeeting includes
#include <ConfDbg.h>
#include <debspew.h>
#include <oblist.h>
#include <CSTRING.hpp>
#include <ConfReg.h>
#include <oprahcom.h>
#include <confevt.h>
#include <dllutil.h>
#include <mtgset.h>

#include "SDKInternal.h"

#include "debug.h"
#include "global.h"

#include "refcount.h"
#include "connpnts.h"
#include "imember.h"
#include "ichannel.h"
#include "iconf.h"





=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\core\resource.h ===
// File: resource.h

#define IDS_COPY_OF             2001
#define IDS_COPY_N_OF           2002
#define IDS_INVALID_NAME        2003
#define IDS_FT_RECDIR_DEFAULT   566
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\core\util.h ===
// File: util.h

#ifndef _UTIL_H_
#define _UTIL_H_

enum H323VERSION
{
	H323_Unknown,
	H323_NetMeeting20,
	H323_NetMeeting21,
	H323_NetMeeting211,
	H323_NetMeeting30,
	H323_NetMeetingFuture,
	H323_TAPI30,
	H323_TAPIFuture,
	H323_MicrosoftFuture,
};

H323VERSION GetH323Version(PCC_VENDORINFO pRemoteVendorInfo);

#endif _UTIL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\core\refcount.h ===
// File: refcount.h

#ifndef _REFCOUNT_H_
#define _REFCOUNT_H_

// RefCount destructor callback function
typedef void (*OBJECTDESTROYEDPROC)(void);
VOID STDMETHODCALLTYPE DLLObjectDestroyed(void);
VOID DllLock(void);


//////////////////////////////////////////////////////////////////////////


class RefCount
{
protected:
	ULONG m_ulcRef;
	OBJECTDESTROYEDPROC m_ObjectDestroyed;

#ifdef DEBUG
	BOOL m_fTrack;
#endif

public:
	RefCount(OBJECTDESTROYEDPROC ObjectDestroyed);
	// Virtual destructor defers to destructor of derived class.
	virtual ~RefCount(void);

	// IUnknown
	ULONG STDMETHODCALLTYPE AddRef(void);
	ULONG STDMETHODCALLTYPE Release(void);

#ifdef DEBUG
	VOID SetTrack(BOOL fTrack)  {m_fTrack = fTrack;}
#endif
};
DECLARE_STANDARD_TYPES(RefCount);


// Special version of the above that calls our standard Dll locking functions
class DllRefCount : public RefCount
{
public:
	DllRefCount() : RefCount(&DLLObjectDestroyed) {DllLock();}
	~DllRefCount(void) {};
};

#endif /* _REFCOUNT_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\core\util.cpp ===
// File: util.cpp
//
// General Utilities

#include "precomp.h"
#include "avcommon.h"
#include "util.h"

static BOOL VersionCheck(PCC_VENDORINFO pVendorInfo, LPCSTR pszVersion)
{
	return (0 == _StrCmpN((char*)(pVendorInfo->pVersionNumber->pOctetString),
					pszVersion,
					pVendorInfo->pVersionNumber->wOctetStringLength));
}


static BOOL ProductCheck(PCC_VENDORINFO pVendorInfo, LPCSTR pszName)
{
	BOOL fFound = FALSE;
	// Octet string may not be terminated allow for terminator
	int len = pVendorInfo->pProductNumber->wOctetStringLength + 1;
	char* pszPN = new char[len];

	if (NULL != pszPN)
	{

		lstrcpyn(pszPN, (char*)pVendorInfo->pProductNumber->pOctetString, len);

		fFound = (NULL != _StrStr(pszPN, pszName));

		delete[] pszPN;
	}

	return fFound;
}


H323VERSION GetH323Version(PCC_VENDORINFO pRemoteVendorInfo)
{
	if (NULL == pRemoteVendorInfo)
	{
		return H323_Unknown;
	}


	// make sure we are dealing with a Microsoft product
	if ((pRemoteVendorInfo->bCountryCode != USA_H221_COUNTRY_CODE) ||
	    (pRemoteVendorInfo->wManufacturerCode != MICROSOFT_H_221_MFG_CODE) ||
	    (pRemoteVendorInfo->pProductNumber == NULL) ||
		(pRemoteVendorInfo->pVersionNumber == NULL)
	   )
	{
		return H323_Unknown;
	}


	// redundant check to make sure we are a Microsoft H.323 product
	if (!ProductCheck(pRemoteVendorInfo, H323_COMPANYNAME_STR))
	{
		return H323_Unknown;
	}


	// check for NetMeeting in the string
	if (ProductCheck(pRemoteVendorInfo, H323_PRODUCTNAME_SHORT_STR))
	{
		if (VersionCheck(pRemoteVendorInfo, H323_20_PRODUCTRELEASE_STR))
		{
			return H323_NetMeeting20;
		}

		if (VersionCheck(pRemoteVendorInfo, H323_21_PRODUCTRELEASE_STR))
		{
			return H323_NetMeeting21;
		}

		if (VersionCheck(pRemoteVendorInfo, H323_21_SP1_PRODUCTRELEASE_STR))
		{
			return H323_NetMeeting21;
		}

		if (VersionCheck(pRemoteVendorInfo, H323_211_PRODUCTRELEASE_STR))
		{
			return H323_NetMeeting211;
		}

		if (VersionCheck(pRemoteVendorInfo, H323_30_PRODUCTRELEASE_STR))
		{
			return H323_NetMeeting30;
		}

		// must be future version of NetMeeting 3.1
		return H323_NetMeetingFuture;
	}

	// filter out TAPI v3.0
	// their version string is "Version 3.0"
	if (VersionCheck(pRemoteVendorInfo, H323_TAPI30_PRODUCTRELEASE_STR))
	{
		return H323_TAPI30;
	}

	// must be TAPI 3.1, or some other Microsoft product
	return H323_MicrosoftFuture;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\core\video.h ===
/****************************************************************************
*
*	 FILE:	   VideoUI.h
*
*	 CREATED:  Mark MacLin (MMacLin) 10-17-96
*
****************************************************************************/

#ifndef _VIDEOUI_H_
#define _VIDEOUI_H_

#include "appavcap.h"
#include "ih323cc.h"
#include <vfw.h>

#define MIN_VIDEO_QUALITY		0
#define MAX_VIDEO_QUALITY		31

class CVideoProp
{
protected:

	ICommChannel*	m_pCommChannel;
	ICommChannel*	m_pPreviewChannel;
	IMediaChannel*   m_pMediaStream;
	IH323Endpoint *	m_pConnection;

	IVideoDevice*		m_pIVideoDevice;

	BOOL			m_fSend;
	BOOL			m_fReceive;
	DWORD			m_dwImageQuality;

	VOID			SetFrameRate(DWORD dwValue);
	DWORD			GetFrameRate();
	MEDIA_FORMAT_ID GetBestFormat();

	DWORD			m_dwFrameSize;
	DWORD           m_dwPreferredFrameSize;
private:
	BOOL			m_fPreview;
	DWORD			m_dwFrameRate;

public:

	// Methods:
				CVideoProp();
	VOID		EnableSend(BOOL fEnable);
	BOOL		IsSendEnabled();
	VOID		EnableReceive(BOOL fEnable);
	BOOL		IsReceiveEnabled();
	VOID		EnablePreview(BOOL fEnable);
	BOOL		IsPreviewEnabled();
	BOOL		IsRemotePaused();
	VOID		SetFrameSize(DWORD dwValue);
	DWORD		GetFrameSize();
	DWORD		GetFrameSizes(MEDIA_FORMAT_ID idSpecificFormat);
	BOOL		HasSourceDialog();
	BOOL		HasFormatDialog();
	VOID		ShowSourceDialog();
	VOID		ShowFormatDialog();
	VOID		SetReceiveQuality(DWORD dwValue);
	DWORD		GetReceiveQuality();
	BOOL		IsCaptureAvailable();
	BOOL		IsCaptureSuspended();
	VOID		SuspendCapture(BOOL fSuspend);
	int			GetNumCapDev();
	int			GetMaxCapDevNameLen();
	BOOL		EnumCapDev(DWORD *pdwCapDevIDs, TCHAR *pszCapDevNames, DWORD dwNumCapDev);
	int			GetCurrCapDevID();
	BOOL		SetCurrCapDevID(int nCapDevID);
	ICommChannel * GetCommChannel() { return m_pCommChannel; }
};


class CVideoPump : public CVideoProp
{
private:
	BOOL			m_fPaused;
	DWORD			m_dwLastFrameRate;
	BOOL			m_fLocal;
	BOOL			m_fChannelOpen;
	LPBYTE			m_pImage;
	IVideoRender*	m_pVideoRender;
	FRAMECONTEXT	m_FrameContext;
	RECT			m_ClipRect;
	MEDIA_FORMAT_ID m_BestFormat;
	MEDIA_FORMAT_ID m_NewFormat;
	BOOL			m_fOpenPending;
	BOOL			m_fReopenPending;
	BOOL			m_fClosePending;
	DWORD_PTR		m_dwUser;
	LPFNFRAMEREADY	m_pfnCallback;

public:
	// Methods:
				CVideoPump(BOOL fLocal);
				~CVideoPump();
	BOOL		ChanInitialize(ICommChannel* pCommChannel);
	VOID        Open(MEDIA_FORMAT_ID format_id);
	VOID        Close();
	BOOL		IsLocal() { return m_fLocal; }
	VOID		EnableXfer(BOOL fEnable);
	BOOL		IsXferEnabled();
	VOID		Pause(BOOL fPause);
	BOOL		IsPaused() { return m_fPaused; };
	NM_VIDEO_STATE	GetState();

	VOID		SnapImage();
	VOID		ReleaseImage();
	HRESULT 	GetFrame(FRAMECONTEXT *pFrameContext);
	HRESULT 	ReleaseFrame(FRAMECONTEXT *pFrameContext);
	VOID		SetFrameSize(DWORD dwValue);
	BOOL		SetCurrCapDevID(int nCapDevID);
	BOOL		ForceCaptureChange();
	BOOL		Initialize(IH323CallControl *pNac, IMediaChannel *pMC, IVideoDevice *pVideoDevice,
	    DWORD_PTR dwUser, LPFNFRAMEREADY pfCallback);
	BOOL		IsChannelOpen() { return m_fChannelOpen; }

	// Handlers:
	VOID		OnConnected(IH323Endpoint * lpConnection, ICommChannel *pIChannel);
	VOID		OnChannelOpened(ICommChannel *pIChannel);
	VOID		OnChannelError();
	VOID		OnChannelClosed();
	VOID		OnDisconnected();
};

#endif // _VIDEOUI_H_

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\core\rostinfo.cpp ===
/***************************************************************************/
/**                  Microsoft Windows                                    **/
/**            Copyright(c) Microsoft Corp., 1995-1996                    **/
/***************************************************************************/

//
//	File:		RostInfo.cpp
//	Created:	ChrisPi		6/17/96
//	Modified:
//
//	The CRosterInfo class is implemented, which is used for adding user
//  information to the T.120 roster
//

#include "precomp.h"
#include <RostInfo.h>

GUID g_csguidRostInfo = GUID_ROSTINFO;

static const HROSTINFO g_cshriEOList = (HROSTINFO)((LONG_PTR)-1);

CRosterInfo::~CRosterInfo()
{
	DebugEntry(CRosterInfo::~CRosterInfo);

	while (FALSE == m_ItemList.IsEmpty())
	{
		PWSTR pwszItem = (PWSTR) m_ItemList.RemoveHead();
		ASSERT(pwszItem);
		delete pwszItem;
	}
	delete m_pvSaveData;

	DebugExitVOID(CRosterInfo::~CRosterInfo);
}

HRESULT CRosterInfo::AddItem(PCWSTR pcwszTag, PCWSTR pcwszData)
{
	DebugEntry(CRosterInfo::AddItem);
	ASSERT(pcwszTag);
	ASSERT(pcwszData);
	HRESULT hr = E_OUTOFMEMORY;

	int nTagLength = lstrlenW(pcwszTag);
	int nDataLength = lstrlenW(pcwszData);

	// +1 for tag sep, +1 for rost info sep
	PWSTR pwszNewItem = new WCHAR[nTagLength + 1 + nDataLength + 1];
	if (NULL != pwszNewItem)
	{
		::CopyMemory(	(PVOID) pwszNewItem,
						pcwszTag,
						sizeof(WCHAR) * nTagLength);
		pwszNewItem[nTagLength] = g_cwchRostInfoTagSeparator;
		::CopyMemory(	(PVOID) &(pwszNewItem[nTagLength + 1]),
						pcwszData,
						sizeof(WCHAR) * nDataLength);
		pwszNewItem[nTagLength + 1 + nDataLength] = g_cwchRostInfoSeparator;
		m_ItemList.AddTail(pwszNewItem);
		hr = S_OK;
	}

	DebugExitHRESULT(CRosterInfo::AddItem, hr);
	return hr;
}

HRESULT CRosterInfo::ExtractItem(	PHROSTINFO phRostInfo,
									PCWSTR pcwszTag,
									LPTSTR pszBuffer,
									UINT cbLength)
{
	DebugEntry(CRosterInfo::ExtractItem);
	ASSERT(pcwszTag);
	HRESULT hr = E_FAIL;
	
	POSITION pos;
	if ((NULL == phRostInfo) ||
		(NULL == *phRostInfo))
	{
		pos = m_ItemList.GetHeadPosition();
	}
	else
	{
		pos = *phRostInfo;
	}

	if (g_cshriEOList != pos)
	{
		while (NULL != pos)
		{
			PWSTR pwszItem = (PWSTR) m_ItemList.GetNext(pos);
			if (NULL != phRostInfo)
			{
				*phRostInfo = (NULL != pos) ? pos : g_cshriEOList;
			}
			ASSERT(pwszItem);
			int nItemLength = lstrlenW(pwszItem);
			int nTagLength = lstrlenW(pcwszTag);
			
			// NOTE: CRT is used for memcmp
			if ((nItemLength > nTagLength) &&
				(0 == memcmp(	pcwszTag,
								pwszItem,
								sizeof(WCHAR) * nTagLength)) &&
				(g_cwchRostInfoTagSeparator == pwszItem[nTagLength]))
			{
				// This is a match
				PWSTR pwszItemData = &(pwszItem[nTagLength + 1]);
				CUSTRING custrItemData(pwszItemData);
				LPTSTR pszItemData = custrItemData;
				if (NULL != pszBuffer)
				{
					lstrcpyn(pszBuffer, pszItemData, cbLength);
				}

				hr = S_OK;
				break;
			}
		}
	}

	DebugExitHRESULT(CRosterInfo::ExtractItem, hr);
	return hr;
}

HRESULT CRosterInfo::Load(PVOID pData)
{
	DebugEntry(CRosterInfo::Load);
	HRESULT hr = E_FAIL;

	PWSTR pwszUserInfo = (PWSTR) pData;
	if (NULL != pwszUserInfo)
	{
		hr = S_OK;
		while (L'\0' != pwszUserInfo[0])
		{
			// this includes the null terminator
			int nItemLenNT = lstrlenW(pwszUserInfo) + 1;
			PWSTR pwszNewItem = new WCHAR[nItemLenNT];
			if (NULL != pwszNewItem)
			{
				::CopyMemory(	pwszNewItem,
								pwszUserInfo,
								sizeof(WCHAR) * nItemLenNT);
				m_ItemList.AddTail(pwszNewItem);
				// Skip past this item and the n.t.
				pwszUserInfo += nItemLenNT;
			}
			else
			{
				hr = E_OUTOFMEMORY;
				break;
			}
		}
	}
	else
	{
		TRACE_OUT(("CRosterInfo::Load() called with NULL pData"));
	}

	DebugExitHRESULT(CRosterInfo::Load, hr);
	return hr;
}

UINT CRosterInfo::GetSize()
{
	UINT uSize = sizeof(WCHAR); // for last separator

	POSITION pos = m_ItemList.GetHeadPosition();
	while (NULL != pos)
	{
		PWSTR pwszItem = (PWSTR) m_ItemList.GetNext(pos);
		ASSERT(pwszItem);
		uSize += sizeof(WCHAR) * (lstrlenW(pwszItem) + 1);
	}

	return uSize;
}

HRESULT CRosterInfo::Save(PVOID* ppvData, PUINT pcbLength)
{
	DebugEntry(CRosterInfo::Save);
	ASSERT(ppvData);
	ASSERT(pcbLength);
	HRESULT hr = E_FAIL;

	*pcbLength = GetSize();
	delete m_pvSaveData;
	m_pvSaveData = new BYTE[*pcbLength];
	if (NULL != m_pvSaveData)
	{
		PWSTR pwszDest = (PWSTR) m_pvSaveData;
		POSITION pos = m_ItemList.GetHeadPosition();
		while (NULL != pos)
		{
			PWSTR pwszItem = (PWSTR) m_ItemList.GetNext(pos);
			ASSERT(pwszItem);
			::CopyMemory(	pwszDest,
							pwszItem,
							sizeof(WCHAR) * (lstrlenW(pwszItem) + 1));
			pwszDest += (lstrlenW(pwszItem) + 1);
		}
		int nLastSepPos = (*pcbLength / sizeof(WCHAR)) - 1;
		((PWSTR)m_pvSaveData)[nLastSepPos] = g_cwchRostInfoSeparator;
		*ppvData = m_pvSaveData;
		hr = S_OK;
	}

	DebugExitHRESULT(CRosterInfo::Save, hr);
	return hr;
}

#ifdef DEBUG
VOID CRosterInfo::Dump()
{
	POSITION pos = m_ItemList.GetHeadPosition();
	while (NULL != pos)
	{
		PWSTR pwszItem = (PWSTR) m_ItemList.GetNext(pos);
		ASSERT(pwszItem);
		TRACE_OUT(("\t%ls", pwszItem));
	}
}
#endif // DEBUG

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\dev\common.inc ===
#
#  GHOST: h\shlguid.h and all of dev except this file.
#

##########################################################################
#
#   Microsoft Confidential
#   Copyright (C) Microsoft Corporation 1991-96
#   All Rights Reserved.
#
##########################################################################

#
# Common include file 'sources' files in the NetMeeting project.
#
# History:
#    Common NetMeeting makefile created 13-Aug-96 Chris Pirich (chrispi)
#    Common ccshell makefile and cleanup 15-Apr-96 Scott Hysom (scotth)
#    Created 27-Sep-94 by Bob Day (bobday)
#    from template created 12-Apr-1990 by Steve Wood (stevewo)
#
#
#
#
# Required definitions:
#     FREEBUILD
#        Set by makefile.def file.  One of the following:
#          0      - build debug
#          1      - build retail
#
#

!if "$(BUILD_PRODUCT)" != "NT"
OAK_INC_PATH=$(NMROOT)\h		# A hack so version.rc can always be found.
SDK_LIB_PATH    = $(DEVROOT)\lib\*
SDK_INC_PATH    = $(DEVROOT)\inc
CRT_LIB_PATH    = $(DEVROOT)\lib\*
CRT_INC_PATH    = $(DEVROOT)\inc
#
# Set private paths
#

INCLUDES        = ..;$(NMROOT)\dev\inc;$(NMROOT)\h;$(NMROOT)\h\t120;$(INCLUDES)
!else
INCLUDES        = ..;$(NMROOT)\h;$(NMROOT)\h\t120;$(INCLUDES);
!endif

COFFBASE_TXT_FILE = $(NMROOT)\h\coffbase.txt
MASTER_VERSION_FILE=$(NMROOT)\h\version.h

#
# Set common options
#

# Defining this allows windows.h to include other headers
#NOT_LEAN_AND_MEAN = 1

# Don't link to NT libs - defining this brings in int64.lib
# USE_NOLIBS      = 1

# Use multi-thread CRT by default
USE_LIBCMT        = 1

# Use C-runtime DLL by default
USE_MSVCRT        = 1

# don't use stdcall by default
386_STDCALL       = 0

UMTYPE            = windows

#
# Lego options
#
!if defined(NTBBT)

#NTPROFILEINPUT  = 1
!endif

# ****** "FINAL" should be defined only for golden builds ******
C_DEFINES       = $(C_DEFINES) -DFINAL

!if defined(USE_UNICODE)
C_DEFINES       = $(C_DEFINES) -DUNICODE -D_UNICODE
NMUTIL_LIB      = nmutilw
!else
NMUTIL_LIB      = nmutila
# Insure that we will work on Win 95
CHICAGO_PROJECT   = 1
CHICAGO_PRODUCT   = 1
NO_NTDLL          = 1
!endif

#
# Additional compiler flags
#
!if "$(BUILD_PRODUCT)" == "NT"
WIN32_WINNT_VERSION=0x500
#WIN32_WIN95_VERSION=0x040a
WIN32_IE_VERSION   =0x0500
WIN32_DEFINE= -D_WIN32_WINDOWS=0x500 -D_WIN32_WINNT=0x0500
#C_DEFINES          =$(C_DEFINES) -DSTRICT -DOS_WINDOWS -DWIN_95_32_BIT -DNASHVILLE
C_DEFINES          =$(C_DEFINES) -DSTRICT -DWIN32 -D_WIN32
!if !$(FREEBUILD)
C_DEFINES          = $(C_DEFINES) -D_DEBUG -DDEBUG
!endif
ATL_VER            = 30
USE_STATIC_ATL     = 1
#-D_ATL_NO_DEBUG_CRT
!else

#WIN32_DEFINE=-DWIN32=200 -D_CHICAGO_=200 -D_WIN32_WINDOWS=0x040a -D_WIN32_WINNT=0x0400
#C_DEFINES       = $(C_DEFINES) -DSTRICT -DWIN32 -D_WIN32 -DOS_WINDOWS -DWIN_95_32_BIT

!if !$(FREEBUILD)
C_DEFINES          = $(C_DEFINES) -D_DEBUG -DDEBUG
DEBUG_CRTS         = 1
NTDEBUG            = ntsd
NTDEBUGTYPE        = windbg
!endif

USE_PDB            = 1
USE_PDB_TO_COMPILE = 1
#
# Additional linker flags
#

LINKER_FLAGS    = $(LINKER_FLAGS) -map

#
# Get all maps and syms
#

USE_MAPSYM = 1
!endif		# BUILD_PRODUCT != NT

# Make warnings equivalent to errors

!if !defined(MSC_WARNING_LEVEL)
MSC_WARNING_LEVEL= /W3
!endif
MSC_WARNING_LEVEL= $(MSC_WARNING_LEVEL) /WX
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\dev\warning.h ===
#pragma warning(3:4092)   // sizeof returns 'unsigned long'
#pragma warning(4:4121)   // structure is sensitive to alignment
#pragma warning(3:4125)   // decimal digit in octal sequence
#pragma warning(3:4130)   // logical operation on address of string constant
#pragma warning(3:4132)   // const object should be initialized
#pragma warning(4:4206)   // Source File is empty
#pragma warning(4:4101)   // Unreferenced local variable
#pragma warning(4:4208)   // delete[exp] - exp evaluated but ignored
#pragma warning(3:4212)   // function declaration used ellipsis
#pragma warning(3:4242)   // convertion possible loss of data
#pragma warning(4:4267)   // convertion from size_t to smaller type
#pragma warning(4:4312)   // conversion to type of greater size
#pragma warning(error:4700)    // Local used w/o being initialized
//#pragma warning(3:4700)    // Local used w/o being initialized
#pragma warning(error:4259)    // pure virtual function was not defined
#pragma warning(error:4071)    // no function prototype given
#pragma warning(error:4072)    // no function prototype given (fastcall)
#pragma warning(error:4171)    // no function prototype given (old style)
#pragma warning(error:4013)    // 'function' undefined - assuming extern returning int
#pragma warning(error:4551)    // Function call missing argument list
#pragma warning(error:4806)    // unsafe operation involving type 'bool'
#pragma warning(4:4509)   // use of SEH with destructor
#pragma warning(4:4177)   // pragma data_seg s/b at global scope
#pragma warning(disable:4274)  // #ident ignored
#pragma warning(disable:4786)  // identifier was truncated to 255 chararcers in debug information.
#pragma warning(disable:4503)  // decorated name length exceeded, name was truncated.
#pragma warning(disable:4263)  // Derived override doesn't match base - who cares...
#pragma warning(disable:4264)  // base function is hidden - again who cares.
#pragma warning(disable:4710)  // Function marked as inline - wasn't
#pragma warning(disable:4917)  // A GUID can only be associated with a class, interface or namespace
#pragma warning(error:4552)    // <<, >> ops used to no effect (probably missing an = sign)
#pragma warning(error:4553)    // == op used w/o effect (probably s/b an = sign)

#if 0
#pragma warning(3:4100)   // Unreferenced formal parameter
#pragma warning(3:4701)   // local may be used w/o init
#pragma warning(3:4702)   // Unreachable code
#pragma warning(3:4705)   // Statement has no effect
#pragma warning(3:4706)   // assignment w/i conditional expression
#pragma warning(3:4709)   // command operator w/o index expression
#endif

#ifndef __cplusplus
#undef try
#undef except
#undef finally
#undef leave
#define try                         __try
#define except                      __except
#define finally                     __finally
#define leave                       __leave
#endif


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\core\setupdd.cpp ===
// File: setupdd.cpp

// The code to install the NM display driver for Windows NT.

// TODO: NM-specific HRESULT codes 

#include "precomp.h"
#include "resource.h"

#ifdef NMDLL_HACK
inline HINSTANCE GetInstanceHandle()	{ return g_hInst; }
#endif

const TCHAR g_pcszDisplayCPLName[]       = TEXT("DESK.CPL");
const CHAR  g_pcszInstallDriverAPIName[] = "InstallGraphicsDriver";
const WCHAR g_pcwszDefaultModelName[]    = L"Microsoft NetMeeting graphics driver";
const WCHAR g_pcwszDefaultINFName[]      = L"MNMDD.INF";


// Maxmimum size of the model name string
const int NAME_BUFFER_SIZE = 128;

// Prototype for the function installed by the Display CPL
typedef DWORD (*PFNINSTALLGRAPHICSDRIVER)(
    HWND    hwnd,
    LPCWSTR pszSourceDirectory,
    LPCWSTR pszModel,
    LPCWSTR pszInf
    );



/*  C A N  I N S T A L L  N  T  D I S P L A Y  D R I V E R  */
/*-------------------------------------------------------------------------
    %%Function: CanInstallNTDisplayDriver
    
	This function determines whether the entry point for installing the
	NT display driver is availalble (i.e. NT 4.0 SP3 or later).
    
-------------------------------------------------------------------------*/
HRESULT CanInstallNTDisplayDriver(void)
{
	if (!IsWindowsNT())
	{
		return E_FAIL;
	}

	// We verify that the major version number is exactly 4 and either
	// the minor version number is greater than 0 or the service pack
	// number (which is stored in the high byte of the low word of the
	// CSD version) is 3 or greater.
	OSVERSIONINFO osvi;
	osvi.dwOSVersionInfoSize = sizeof(osvi);
	if (FALSE == ::GetVersionEx(&osvi))
	{
		ERROR_OUT(("CanInstallNTDisplayDriver: GetVersionEx failed"));
		return E_FAIL;
	}

	HRESULT hr = E_FAIL;
	if (4 == osvi.dwMajorVersion)
	{
		if (0 == osvi.dwMinorVersion)
		{
			RegEntry re(NT_WINDOWS_SYSTEM_INFO_KEY, HKEY_LOCAL_MACHINE, FALSE);
			DWORD dwCSDVersion = re.GetNumber(REGVAL_NT_CSD_VERSION, 0);
			if (3 <= HIBYTE(LOWORD(dwCSDVersion)))
			{
				// This is NT 4.0, SP 3 or later
				hr = S_OK;
			}
		}
		else
		{
			// We assume that any future version of Windows NT 4.x (x > 0)
			// will support this.
			hr = S_OK;
		}
	}

	return hr;
}


/*  I N S T A L L  A P P  S H A R I N G  D  D  */
/*-------------------------------------------------------------------------
    %%Function: InstallAppSharingDD

	This function attempts to install the NT display driver.
	If it succeeds the machine MUST BE RESTARTED before it can be used.
-------------------------------------------------------------------------*/
HRESULT InstallAppSharingDD(HWND hwnd)
{
	HRESULT  hr;
	CUSTRING custrPath;
	TCHAR    szDir[MAX_PATH];
	LPWSTR   pwszSourcePath = NULL;
	LPWSTR   pwszSourcePathEnd;
	WCHAR    pwszModelNameBuffer[NAME_BUFFER_SIZE];
	LPCWSTR  pcwszModelName;
	WCHAR    pwszINFNameBuffer[MAX_PATH];
	LPCWSTR  pcwszINFName;
	PFNINSTALLGRAPHICSDRIVER pfnInstallGraphicsDriver;


	// REVIEW: Need NM-specific HRESULTS for all of these
	if (!IsWindowsNT())
	{
		return E_FAIL;
	}

	if (!CanInstallNTDisplayDriver())
	{
		return E_FAIL;
	}

	// The driver files are located in the NM directory.
	if (!GetInstallDirectory(szDir))
	{
		ERROR_OUT(("GetInstallDirectory() fails"));
		return E_FAIL;
	}

	// Convert the install directory to Unicode, if necessary
	custrPath.AssignString(szDir);
	pwszSourcePath = custrPath;
	if (NULL == pwszSourcePath)
	{
		ERROR_OUT(("AnsiToUnicode() fails"));
		return E_FAIL;
	}

	// Strip the trailing backslash that GetInstallDirectory appends
	pwszSourcePathEnd = pwszSourcePath + lstrlenW(pwszSourcePath);
	// Handle X:\, just to be safe
	if (pwszSourcePathEnd - pwszSourcePath > 3)
	{
		ASSERT(L'\\' == *(pwszSourcePathEnd - 1));
		*--pwszSourcePathEnd = L'\0';
	}

	// Read the model name string from the resource file
	if (0 != ::LoadStringW(::GetInstanceHandle(), IDS_NMDD_DISPLAYNAME, 
				pwszModelNameBuffer, CCHMAX(pwszModelNameBuffer)))
	{
		pcwszModelName = pwszModelNameBuffer;
	}
	else
	{
		ERROR_OUT(("LoadStringW() fails, err=%lu", GetLastError()));
		pcwszModelName = g_pcwszDefaultModelName;
	}

	// Read the INF name string from the resource file
	if (0 < ::LoadStringW(::GetInstanceHandle(), 
			IDS_NMDD_INFNAME,  pwszINFNameBuffer, CCHMAX(pwszINFNameBuffer)))
	{
		pcwszINFName = pwszINFNameBuffer;
	}
	else
	{
		ERROR_OUT(("LoadStringW() fails, err=%lu", GetLastError()));
		pcwszINFName = g_pcwszDefaultINFName;
	}


	// Get the entry point for display driver installation
	HMODULE hDll = LoadLibrary(g_pcszDisplayCPLName);
	if (NULL == hDll)
	{
		ERROR_OUT(("LoadLibrary failed on %s", g_pcszDisplayCPLName));
		return E_FAIL;
	}

	pfnInstallGraphicsDriver = (PFNINSTALLGRAPHICSDRIVER) 
				GetProcAddress(hDll, g_pcszInstallDriverAPIName);
	if (NULL == pfnInstallGraphicsDriver)
	{
		ERROR_OUT(("GetInstallDisplayDriverEntryPoint() fails"));
		hr = E_FAIL;
	}
	else
	{	// Now we're set to call the actual installation function
		DWORD dwErr = (*pfnInstallGraphicsDriver)(hwnd,
					pwszSourcePath, pcwszModelName, pcwszINFName);
		if (0 != dwErr)
		{
			ERROR_OUT(("InstallGraphicsDriver() fails, err=%lu", dwErr));
			hr = E_FAIL;
		}
		else
		{
			WARNING_OUT(("InstallGraphicsDriver() succeeded"));
			hr = S_OK;
		}
	}

	// Cleanup
	ASSERT(NULL != hDll);
	FreeLibrary(hDll);

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\core\video.cpp ===
/****************************************************************************
*
*	 FILE:	   Videoui.cpp
*
*	 CREATED:  Mark MacLin (MMacLin) 10-17-96
*
*	 CONTENTS: CVideo object
*
****************************************************************************/
// File: VideoUI.cpp

#include "precomp.h"

#include "avdefs.h"
#include "video.h"
#include "h323.h"
#include <mperror.h>
#include <initguid.h>
#include <nacguids.h>


#define INITIAL_FRAMERATE		  700

#define DibHdrSize(lpbi)		((lpbi)->biSize + (int)(lpbi)->biClrUsed * sizeof(RGBQUAD))
#define DibDataSize(lpbi)		((lpbi)->biSizeImage)
#define DibSize(lpbi)			(DibHdrSize(lpbi) + DibDataSize(lpbi))




//
//  SortOrder() and SetVideoSize() are helper functions for reordering the video
//  based on the notion of a "small", "medium", or "large" user preference that is
//  exposed by a property setting in INmChannelVideo::Setproperty. This
//  notion is flawed because there may be more or less than three sizes.
//  We should expose the possible sizes and let the application choose
//  a format.  Unil then, this hack has to be here.  The code for these two functions
//  was originally in vidstrm.cpp (in NAC.DLL)
//

//
// types & globals used by SortOrder() and SetVideoSize()
//

// Used to translate between frame sizes and the FRAME_* bit flags
#define NON_STANDARD    0x80000000
#define SIZE_TO_FLAG(s) (s == Small  ? FRAME_SQCIF : s == Medium ? FRAME_QCIF: s == Large ? FRAME_CIF : NON_STANDARD)

// FORMATORDER: structure used in ::SetVideoSize to
// use predefined frame size orders for different set size requests
typedef struct _FORMATORDER
{
    WORD indexCIF;
    WORD indexQCIF;
    WORD indexSQCIF;
} FORMATORDER;

// Table of sizes in order
const FORMATORDER g_fmtOrderTable[3] =
{
    { 0, 1, 2 }, // requestor asked for CIF
    { 2, 0, 1 }, // requestor asked for QCIF
    { 2, 1, 0 }  // requestor asked for SQCIF
};

//  SortOrder
//      Helper function to search for the specific format type and set its sort
//      order to the desired number
//  THIS WAS MOVED HERE FROM vidstrm.cpp
//
BOOL
SortOrder(
	IAppVidCap *pavc,
    BASIC_VIDCAP_INFO* pvidcaps,
    DWORD dwcFormats,
    DWORD dwFlags,
    WORD wDesiredSortOrder,
	int nNumFormats
    )
{
    int i, j;
	int nNumSizes = 0;
	int *aFrameSizes = (int *)NULL;
	int *aMinFrameSizes = (int *)NULL;
	int iMaxPos;
	WORD wTempPos, wMaxSortIndex;

	// Scale sort value
	wDesiredSortOrder *= (WORD)nNumFormats;

	// Local buffer of sizes that match dwFlags
    if (!(aFrameSizes = (int *)LocalAlloc(LPTR,nNumFormats * sizeof (int))))
        goto out;

    // Look through all the formats until we find the ones we want
	// Save the position of these entries
    for (i=0; i<(int)dwcFormats; i++)
        if (SIZE_TO_FLAG(pvidcaps[i].enumVideoSize) == dwFlags)
			aFrameSizes[nNumSizes++] = i;

	// Now order those entries from highest to lowest sort index
	for (i=0; i<nNumSizes; i++)
	{
		for (iMaxPos = -1L, wMaxSortIndex=0UL, j=i; j<nNumSizes; j++)
		{
			if (pvidcaps[aFrameSizes[j]].wSortIndex > wMaxSortIndex)
			{
				wMaxSortIndex = pvidcaps[aFrameSizes[j]].wSortIndex;
				iMaxPos = j;
			}
		}
		if (iMaxPos != -1L)
		{
			wTempPos = (WORD)aFrameSizes[i];
			aFrameSizes[i] = aFrameSizes[iMaxPos];
			aFrameSizes[iMaxPos] = wTempPos;
		}
	}

	// Change the sort index of the sorted entries
	for (; nNumSizes--;)
		pvidcaps[aFrameSizes[nNumSizes]].wSortIndex = wDesiredSortOrder++;

	// Release memory
	LocalFree(aFrameSizes);

	return TRUE;

out:
	return FALSE;
}



//  ::SetVideoSize
//
//  THIS WAS MOVED HERE FROM vidstrm.cpp

HRESULT
SetVideoSize(
	IH323CallControl *pH323CallControl,
    DWORD dwSizeFlags
    )
{
    IAppVidCap* pavc;
    DWORD dwcFormats;
    DWORD dwcFormatsReturned;
    BASIC_VIDCAP_INFO* pvidcaps = NULL;
    BASIC_VIDCAP_INFO* pmin;
	DWORD *pvfx = NULL;
    DWORD i, j;
	int k;
    HRESULT hr = S_OK;
	int nNumFormatTags;

    // Validate parameters
    if (dwSizeFlags != FRAME_CIF && dwSizeFlags != FRAME_QCIF && dwSizeFlags != FRAME_SQCIF)
        return S_FALSE;;

    // Prepare for error
    hr = S_FALSE;

    // Get a vid cap interface
    if (pH323CallControl->QueryInterface(IID_IAppVidCap, (void **)&pavc) != S_OK)
        goto out;

    // Get the number of BASIC_VIDCAP_INFO structures available
    if (pavc->GetNumFormats((UINT*)&dwcFormats) != S_OK)
        goto out;

    // Allocate some memory to hold the list in
    if (!(pvidcaps = (BASIC_VIDCAP_INFO*)LocalAlloc(LPTR,dwcFormats * sizeof (BASIC_VIDCAP_INFO))))
        goto out;

    // Get the list
    if (pavc->EnumFormats(pvidcaps, dwcFormats * sizeof (BASIC_VIDCAP_INFO),
        (UINT*)&dwcFormatsReturned) != S_OK)
        goto out;

    // Use the preformatted list of choice here
    switch (dwSizeFlags)
    {
    default:
    case FRAME_CIF:     i = 0; break;
    case FRAME_QCIF:    i = 1; break;
    case FRAME_SQCIF:   i = 2; break;
    }

	// Get the number of different format tags
    if (!(pvfx = (DWORD*)LocalAlloc(LPTR,dwcFormatsReturned * sizeof (DWORD))))
        goto out;
	ZeroMemory(pvfx,dwcFormatsReturned * sizeof (DWORD));

	if (dwcFormatsReturned)
	{
		for (nNumFormatTags = 1, pvfx[0] = pvidcaps[0].dwFormatTag, j=1; j<dwcFormatsReturned; j++)
		{
			for (k=0; k<nNumFormatTags; k++)
				if (pvidcaps[j].dwFormatTag == pvfx[k])
					break;

			if (k==nNumFormatTags)
				pvfx[nNumFormatTags++] = pvidcaps[j].dwFormatTag;
			
		}
	}

    // Set the sort order for the desired item
    if (!SortOrder(pavc, pvidcaps, dwcFormatsReturned, FRAME_CIF, g_fmtOrderTable[i].indexCIF, nNumFormatTags) ||
        !SortOrder(pavc, pvidcaps, dwcFormatsReturned, FRAME_QCIF, g_fmtOrderTable[i].indexQCIF, nNumFormatTags) ||
        !SortOrder(pavc, pvidcaps, dwcFormatsReturned, FRAME_SQCIF, g_fmtOrderTable[i].indexSQCIF, nNumFormatTags))
	{
        goto out;
	}

	// Always pack indices
	for (i=0; i<dwcFormatsReturned; i++)
	{
		// First find an entry with a sort index larger or equal to i
		for (j=0; j<dwcFormatsReturned; j++)
		{
			// if ((pvidcaps[j].wSortIndex >= i) || (!i && (pvidcaps[j].wSortIndex == 0)))
			if (pvidcaps[j].wSortIndex >= i)
			{
				pmin = &pvidcaps[j];
				break;
			}
		}
		// First the smallest entry larger or equal to i
		for (; j<dwcFormatsReturned; j++)
		{
			if ((pvidcaps[j].wSortIndex < pmin->wSortIndex) && (pvidcaps[j].wSortIndex >= i))
				pmin = &pvidcaps[j];
		}
		// Update sort index
		pmin->wSortIndex = (WORD)i;
	}

    // Ok, now submit this list
    if (pavc->ApplyAppFormatPrefs(pvidcaps, dwcFormats) != S_OK)
	{
        goto out;
	}


	hr = S_OK;

out:
    // Free the memory, we're done
    if (pvidcaps)
        LocalFree(pvidcaps);
    if (pvfx)
        LocalFree(pvfx);

	// let the interface go
	if (pavc)
		pavc->Release();

	return hr;
}


CVideoPump::CVideoPump(BOOL fLocal) :
	m_fPaused(FALSE),
	m_dwUser(0),
	m_pfnCallback(NULL),
	m_dwLastFrameRate(0),
	m_fLocal(fLocal),
	m_fChannelOpen(FALSE),
	m_pImage(NULL),
	m_pVideoRender(NULL),
	m_BestFormat(INVALID_MEDIA_FORMAT),
	m_NewFormat(INVALID_MEDIA_FORMAT),
	m_fOpenPending(FALSE),
	m_fReopenPending(FALSE),
	m_fClosePending(FALSE)
{
}

CVideoPump::~CVideoPump()
{
	if (NULL != m_pVideoRender)
	{
		m_pVideoRender->Done();
		m_pVideoRender->Release();
	}
	ReleaseImage();
	if (NULL != m_pIVideoDevice)
	{
		m_pIVideoDevice->Release();
	}
	if (NULL != m_pMediaStream)
	{
		m_pMediaStream->Release();
	}

	if (NULL != m_pPreviewChannel)
	{
		m_pPreviewChannel->Release();
	}
	if (NULL != m_pCommChannel)
	{
		m_pCommChannel->Release();
	}
}

BOOL CVideoPump::ChanInitialize(ICommChannel* pCommChannel)
{
	HRESULT hr;
	BOOL bRet = TRUE;
	if(m_pPreviewChannel && m_pPreviewChannel == pCommChannel)
	{
		ASSERT(m_pVideoRender && m_pCommChannel == pCommChannel);
		//m_pCommChannel = pCommChannel;
	}
	else
	{
		m_pCommChannel = pCommChannel;
		m_pCommChannel->AddRef();
	}
	
	return bRet;
}

BOOL CVideoPump::Initialize(IH323CallControl *pH323CallControl, IMediaChannel *pMC,
                            IVideoDevice *pVideoDevice,	DWORD_PTR dwUser, LPFNFRAMEREADY pfnCallback)
{
	HRESULT hr;

	m_dwUser = dwUser;
	m_pfnCallback = pfnCallback;

	m_pMediaStream = pMC;
	m_pMediaStream->AddRef();
	
	if(m_fLocal)
	{
		GUID mediaID = MEDIA_TYPE_H323VIDEO;

		hr = pH323CallControl->CreateLocalCommChannel(&m_pPreviewChannel, &mediaID, m_pMediaStream);
		if(FAILED(hr))
		{
			ASSERT(0);
			return FALSE;
		}

		m_pCommChannel = m_pPreviewChannel;
		m_pCommChannel->AddRef();

	}

	hr = m_pMediaStream->QueryInterface(IID_IVideoRender, (void **)&m_pVideoRender);
	if(FAILED(hr))
	{
		ASSERT(0);
		return FALSE;
	}
	
	hr = m_pVideoRender->Init(m_dwUser, m_pfnCallback);
	if(FAILED(hr))
	{
		ASSERT(0);
		m_pVideoRender->Release();
		m_pVideoRender = NULL;
		return FALSE;
	}	


	ASSERT(pVideoDevice);
	m_pIVideoDevice = pVideoDevice;
	m_pIVideoDevice->AddRef();

	
	m_fChannelOpen = FALSE;
	m_dwLastFrameRate = INITIAL_FRAMERATE;
	
	m_fPaused = TRUE;
	EnableXfer(FALSE);	// need to store state locally, set it in OnChannelOpen

	return TRUE;
}

HRESULT CVideoPump::GetFrame(FRAMECONTEXT *pFrameContext)
{
	HRESULT hr;
	
	// if we are paused m_pImage will be a pointer to the saved DIB
	if (NULL != m_pImage)
	{
		*pFrameContext = m_FrameContext;
		hr = S_OK;
	}
	else
	{
		if(m_pVideoRender)
		{
			hr = m_pVideoRender->GetFrame(pFrameContext);
		}
		else
		{
			hr = S_FALSE;
		}

		if (S_OK == hr)
		{
			// data pump may be sending a bogus lpClipRect, so ...
			
			// if lpClipRect is NULL, calculate rect from bmiHeader
			if (NULL == pFrameContext->lpClipRect) {
				// calculate clip rect from BITMAPINFOHEADER
				m_ClipRect.left = m_ClipRect.top = 0;
				m_ClipRect.right = pFrameContext->lpbmi->bmiHeader.biWidth;
				m_ClipRect.bottom = pFrameContext->lpbmi->bmiHeader.biHeight;
				pFrameContext->lpClipRect = &m_ClipRect;
			}
		}
	}
	return hr;
}

HRESULT CVideoPump::ReleaseFrame(FRAMECONTEXT *pFrameContext)
{
	// release the frame if it is not the saved DIB
	if ((m_pImage != (LPBYTE)pFrameContext->lpbmi) && m_pVideoRender)
	{
		// if lpClipRect was NULL (see GetFrame), restore it
		if (&m_ClipRect == pFrameContext->lpClipRect)
		{
			pFrameContext->lpClipRect = NULL;
		}
		return m_pVideoRender->ReleaseFrame(pFrameContext);
	}
	return S_OK;
}

VOID CVideoPump::SnapImage ()
{
	FRAMECONTEXT FrameContext;
	
	if ((NULL == m_pImage) && m_pVideoRender)
	{
		if (S_OK == m_pVideoRender->GetFrame(&FrameContext))
		{
			BITMAPINFOHEADER *pbmih;
			
			pbmih = &FrameContext.lpbmi->bmiHeader;
			m_pImage = (LPBYTE)LocalAlloc(LPTR, DibSize(pbmih));
			if (NULL != m_pImage)
			{
				int nHdrSize = DibHdrSize(pbmih);

				CopyMemory(m_pImage, pbmih, nHdrSize);
				CopyMemory(m_pImage + nHdrSize, FrameContext.lpData, DibDataSize(pbmih));

				m_FrameContext.lpbmi = (LPBITMAPINFO)m_pImage;
				m_FrameContext.lpData = (LPBYTE)m_pImage + nHdrSize;
				if (NULL != FrameContext.lpClipRect)
				{
					m_ClipRect = *FrameContext.lpClipRect;
				}
				else
				{
					m_ClipRect.left = m_ClipRect.top = 0;
					m_ClipRect.right = m_FrameContext.lpbmi->bmiHeader.biWidth;
					m_ClipRect.bottom = m_FrameContext.lpbmi->bmiHeader.biHeight;
				}
				m_FrameContext.lpClipRect = &m_ClipRect;
			}
			m_pVideoRender->ReleaseFrame(&FrameContext);
		}
	}
}

VOID CVideoPump::ReleaseImage ()
{
	if (NULL != m_pImage)
	{
		LocalFree(m_pImage);
		m_pImage = NULL;
	}
}

VOID CVideoPump::Pause(BOOL fPause)
{
	m_fPaused = fPause;
	
	// ideally we would like the data pump to hold onto the last frame
	// so that we don't have to do this
	if (m_fPaused)
	{
		if (m_fChannelOpen)
		{
			SnapImage();
		}
		EnableXfer(FALSE);
	}
	else
	{
		EnableXfer(TRUE);
		ReleaseImage();
	}
}

BOOL CVideoPump::IsXferEnabled()
{
	if (m_fLocal)
	{
		return IsSendEnabled();
	}
	return IsReceiveEnabled();
}

VOID CVideoPump::Open(MEDIA_FORMAT_ID format_id)
{
	if(!m_pCommChannel)
	{
		return;
	}
	
	m_pCommChannel->PauseNetworkStream(FALSE);
	m_pCommChannel->EnableOpen(TRUE);

	if (m_fLocal)
	{
		HRESULT hr;
		// if the channel is not open and a call is in progress, now is the time
		if(m_pConnection && m_pCommChannel)
		{
			// a call is in progress
			if(!IsChannelOpen()
				&& !m_fOpenPending)
			{
				// so, the channel is not open

				if(format_id != INVALID_MEDIA_FORMAT)
				{
					// try to open a channel using specified format
					m_fOpenPending = TRUE;	// do this first (callbacks!)
					hr = m_pCommChannel->Open(format_id, m_pConnection);
					if(FAILED(hr))
						m_fOpenPending = FALSE;
				}

			}
			else if (m_fClosePending)
			{
				m_NewFormat = format_id;
				if(format_id != INVALID_MEDIA_FORMAT)
				{
					m_fClosePending = FALSE;
					m_fReopenPending = TRUE;
					hr = m_pCommChannel->Close();
				}
			}
		}
	}
}
VOID CVideoPump::Close()
{
	HRESULT hr;
	hr = m_pCommChannel->Close();
	// what to do about an error?
}

VOID CVideoPump::EnableXfer(BOOL fEnable)
{
	if (m_fLocal)
	{
		if (fEnable)
		{
			HRESULT hr;
			SetFrameRate(m_dwLastFrameRate);

			EnablePreview(TRUE);
			EnableSend(TRUE);

			// if the channel is not open and a call is in progress, now is the time
			if(m_pConnection && m_pCommChannel)
			{
				// a call is in progress
				if(!IsChannelOpen()
					&& !m_fOpenPending)
				{
					// so, the channel is not open
					m_BestFormat = m_NewFormat = CVideoProp::GetBestFormat();
					if(m_BestFormat != INVALID_MEDIA_FORMAT)
					{
						// try to open a channel using format m_BestFormat
						m_fOpenPending = TRUE;	// do this first (callbacks!)
						hr = m_pCommChannel->Open(m_BestFormat, m_pConnection);
						if(FAILED(hr))
							m_fOpenPending = FALSE;
					}
					// else no common video formats exist and a channel cannot
					// be opened.
				}
				else if (m_fClosePending)
				{
					m_BestFormat = m_NewFormat = CVideoProp::GetBestFormat();
					if(m_BestFormat != INVALID_MEDIA_FORMAT)
					{
						m_fClosePending = FALSE;
						m_fReopenPending = TRUE;
						hr = m_pCommChannel->Close();
					}
				}
			}

		}
		else
		{
			if (IsSendEnabled())
			{
				m_dwLastFrameRate = GetFrameRate();
			}

			EnablePreview(FALSE);
			EnableSend(FALSE);
		}
	}
	else
	{
		EnableReceive(fEnable);
	}
	
}

VOID CVideoPump::SetFrameSize(DWORD dwValue)
{
	CVideoProp::SetFrameSize(dwValue);
	
	ForceCaptureChange();
}

VOID CVideoPump::OnConnected(IH323Endpoint * lpConnection, ICommChannel *pIChannel)
{
	m_pConnection = lpConnection;
	m_fOpenPending = m_fReopenPending = m_fClosePending = FALSE;
}

VOID CVideoPump::OnChannelOpened(ICommChannel *pIChannel)
{
	HRESULT hr;
	m_fChannelOpen = TRUE;
	m_fOpenPending = FALSE;
	ChanInitialize(pIChannel);
	ASSERT(m_pMediaStream);
		
	if (m_fLocal)
	{
		m_fSend = TRUE;
		EnableXfer(TRUE);

		// if video size changed while waiting for the channel to be opened,
		// then need to close again, then reopen again using the new format
		if(m_BestFormat != m_NewFormat)
		{
			ForceCaptureChange();
		}
		else // make sure to track the video size
		{
			GetFrameSize();
		}
	}
	else
	{
		EnableXfer(m_fReceive);
		SetReceiveQuality(m_dwImageQuality);
	}
	ReleaseImage();
}

VOID CVideoPump::OnChannelError()
{
	m_fOpenPending = FALSE;
}

NM_VIDEO_STATE CVideoPump::GetState()
{
	NM_VIDEO_STATE state = NM_VIDEO_IDLE;

	if (IsChannelOpen())
	{
		if (IsXferEnabled())
		{
			if (IsRemotePaused())
			{
				state  = NM_VIDEO_REMOTE_PAUSED;
			}
			else
			{
				state  = NM_VIDEO_TRANSFERRING;
			}
		}
		else
		{
			if (IsRemotePaused())
			{
				state  = NM_VIDEO_BOTH_PAUSED;
			}
			else
			{
				state  = NM_VIDEO_LOCAL_PAUSED;
			}
		}
	}
	else
	{
		if (IsXferEnabled())
		{
			state = NM_VIDEO_PREVIEWING;
		}
	}
	return state;
}

VOID CVideoPump::OnChannelClosed()
{
	m_fChannelOpen = FALSE;
	HRESULT hr;
	if(m_pPreviewChannel)
	{
		if(m_fReopenPending)
		{
			m_fReopenPending = FALSE;
			if(m_BestFormat != INVALID_MEDIA_FORMAT )
			{
				m_fOpenPending = TRUE;
				hr = m_pCommChannel->Open(m_BestFormat, m_pConnection);
				if(FAILED(hr))
					m_fOpenPending = FALSE;
			}
		}
		else if(CVideoProp::IsPreviewEnabled())
		{
			EnablePreview(TRUE);
		}
	}
	else
	{
		if(m_pCommChannel)
		{
			m_pCommChannel->Release();
			m_pCommChannel = NULL;	
		}
	}
}

VOID CVideoPump::OnDisconnected()
{
	m_pConnection = NULL;

	if(m_dwFrameSize != m_dwPreferredFrameSize)
	{
		SetFrameSize(m_dwPreferredFrameSize);
	}
			
	if (!IsLocal())
	{
		EnableXfer(FALSE);
	}

	ReleaseImage();
}


CVideoProp::CVideoProp() :
	m_pCommChannel(NULL),
	m_pPreviewChannel(NULL),
	m_pConnection(NULL),
	m_pMediaStream(NULL),
	m_pIVideoDevice(NULL)
{
}

VOID CVideoProp::EnableSend(BOOL fEnable)
{
	m_fSend = fEnable;
	BOOL bPause = (fEnable)? FALSE :TRUE;
	ASSERT(m_pCommChannel);
	m_pCommChannel->PauseNetworkStream(bPause);
	m_pCommChannel->EnableOpen(fEnable);

}

BOOL CVideoProp::IsSendEnabled()
{
	return m_fSend;
}

VOID CVideoProp::EnableReceive(BOOL fEnable)
{
	m_fReceive = fEnable;
	BOOL fPause = !fEnable;

	if(m_pCommChannel)
	{
		m_pCommChannel->PauseNetworkStream(fPause);
	}
}

BOOL CVideoProp::IsReceiveEnabled()
{
	return m_fReceive;
}

VOID CVideoProp::EnablePreview(BOOL fEnable)
{
	m_fPreview = fEnable;
	MEDIA_FORMAT_ID FormatID;
	if(m_pCommChannel)
	{
		if(m_fPreview)
		{
			// get format to preview, then do it
			FormatID = GetBestFormat();
			if(FormatID != INVALID_MEDIA_FORMAT)
			{
				m_pCommChannel->Preview(FormatID, m_pMediaStream);
			}
		}
		else
		{
				m_pCommChannel->Preview(INVALID_MEDIA_FORMAT, NULL);
		}
	}
}

BOOL CVideoProp::IsPreviewEnabled()
{
	return m_fPreview;
}

BOOL CVideoProp::IsRemotePaused()
{

	if(m_pCommChannel)
		return m_pCommChannel->IsRemotePaused();
	else
		return FALSE;
}

VOID CVideoProp::SetFrameRate(DWORD dwValue)
{
	m_dwFrameRate = dwValue;

	ASSERT(m_pMediaStream);
	m_pMediaStream->SetProperty(
		PROP_VIDEO_FRAME_RATE,
		&dwValue,
		sizeof(dwValue));
}

DWORD CVideoProp::GetFrameRate()
{
	DWORD dwValue;
	UINT uSize = sizeof(dwValue);

	ASSERT(m_pMediaStream);
	m_pMediaStream->GetProperty(
		PROP_VIDEO_FRAME_RATE,
		&dwValue,
		&uSize);

	TRACE_OUT(("GetFrameRate returns %d", dwValue));
	return dwValue;
}


MEDIA_FORMAT_ID CVideoProp::GetBestFormat()
{
	IAppVidCap* pavc;
	UINT cFormats;
	BASIC_VIDCAP_INFO* pvidcaps = NULL;

	MEDIA_FORMAT_ID FormatID = INVALID_MEDIA_FORMAT;
  	// Get a vid cap interface.  If in a call, use the best common format
	//
	if(!m_pConnection)
	{
		// not in a call - use the best local format period
		if(!m_pCommChannel)
			goto out;
		if (m_pCommChannel->QueryInterface(IID_IAppVidCap, (void **)&pavc) != S_OK)
			goto out;
		// Get the number of BASIC_VIDCAP_INFO structures available
		if (pavc->GetNumFormats(&cFormats) != S_OK)
			goto out;

		if(cFormats < 1)
			goto out;
			
		// Allocate some memory to hold the list in
		if (!(pvidcaps = (BASIC_VIDCAP_INFO*)LocalAlloc(LPTR, cFormats * sizeof (BASIC_VIDCAP_INFO))))
			goto out;

		// Get the list of local capabilities
		// (by the way, this is never called for receive video)
		if (pavc->EnumFormats(pvidcaps, cFormats * sizeof (BASIC_VIDCAP_INFO),
			&cFormats) != S_OK)
			goto out;

		// the output of EnumCommonFormats is in preferred order
		FormatID = pvidcaps[0].Id;
	}
	else
	{
		if (m_pConnection->QueryInterface(IID_IAppVidCap, (void **)&pavc) != S_OK)
			goto out;

		// Get the number of BASIC_VIDCAP_INFO structures available
		if (pavc->GetNumFormats(&cFormats) != S_OK)
			goto out;

		if(cFormats < 1)
			goto out;
			
		// Allocate some memory to hold the list in
		if (!(pvidcaps = (BASIC_VIDCAP_INFO*)LocalAlloc(LPTR, cFormats * sizeof (BASIC_VIDCAP_INFO))))
			goto out;

		// Get the list of viable transmit capabilities
		// (by the way, this is never called for receive video)
		if (pavc->EnumCommonFormats(pvidcaps, cFormats * sizeof (BASIC_VIDCAP_INFO),
			&cFormats, TRUE) != S_OK)
			goto out;

		// the output of EnumCommonFormats is in preferred order
		FormatID = pvidcaps[0].Id;

	}
	
out:
	// Free the memory, we're done
	if (pvidcaps)
		LocalFree(pvidcaps);

	// let the interface go
	if (pavc)
		pavc->Release();

	return FormatID;
}



VOID CVideoProp::SetFrameSize(DWORD dwValue)
{
	IH323CallControl * pH323CallControl = g_pH323UI->GetH323CallControl();
	m_dwFrameSize = m_dwPreferredFrameSize = dwValue;
	::SetVideoSize(pH323CallControl, m_dwFrameSize);
}

DWORD CVideoProp::GetFrameSize()
{
	MEDIA_FORMAT_ID idCurrent;
	if(m_pCommChannel)
	{
		idCurrent = m_pCommChannel->GetConfiguredFormatID();
		m_dwFrameSize = GetFrameSizes(idCurrent);
	}
	return m_dwFrameSize;
}

DWORD CVideoProp::GetFrameSizes(MEDIA_FORMAT_ID idSpecificFormat)
{
	DWORD dwValue =  0; //FRAME_SQCIF | FRAME_QCIF | FRAME_CIF;
	HRESULT hr;
	BOOL bOpen = FALSE;
	ASSERT(m_pCommChannel);
	// Used to translate between frame sizes and the FRAME_* bit flags
	#define NON_STANDARD    0x80000000
	#define SIZE_TO_FLAG(s) (s == Small  ? FRAME_SQCIF : s == Medium ? FRAME_QCIF: s == Large ? FRAME_CIF : NON_STANDARD)

    IAppVidCap* pavc = NULL;
    DWORD dwcFormats;
    DWORD dwcFormatsReturned;
    BASIC_VIDCAP_INFO* pvidcaps = NULL;
    DWORD i;
    DWORD dwSizes = 0;
    DWORD dwThisSize;

   // Get a vid cap interface
    hr = m_pCommChannel->QueryInterface(IID_IAppVidCap, (void **)&pavc);
    if (hr != S_OK)
    	goto out;

	   // Get the number of BASIC_VIDCAP_INFO structures available
    hr = pavc->GetNumFormats((UINT*)&dwcFormats);
    if (hr != S_OK)
    	goto out;

    // Allocate some memory to hold the list in
    if (!(pvidcaps = (BASIC_VIDCAP_INFO*)LocalAlloc(LPTR, dwcFormats * sizeof (BASIC_VIDCAP_INFO))))
    {
    	// report that no sizes are available?
    	// dwValue =  0FRAME_SQCIF | FRAME_QCIF | FRAME_CIF;
        goto out;
	}
	// if an active session, use common caps from that session
	hr = m_pCommChannel->IsChannelOpen(&bOpen);
	// if hr is an error, so what. it will take the channel not open path
	if(bOpen)
	{
	    // Get the list of common formats
	    hr = pavc->EnumCommonFormats(pvidcaps, dwcFormats * sizeof (BASIC_VIDCAP_INFO),
	        (UINT*)&dwcFormatsReturned, m_fSend);
		if(hr != S_OK)
		{
	    	// if the error is simply because there are no remote video caps, get the local formats
			if(hr == CAPS_E_NOCAPS)
			{
	    		hr = pavc->EnumFormats(pvidcaps, dwcFormats * sizeof (BASIC_VIDCAP_INFO),
	        		(UINT*)&dwcFormatsReturned);
				if (hr != S_OK)
        			goto out;
			}
			else
				goto out;
	    }
	}
	else
	{
		hr = pavc->EnumFormats(pvidcaps, dwcFormats * sizeof (BASIC_VIDCAP_INFO),
       		(UINT*)&dwcFormatsReturned);
		if (hr != S_OK)
   			goto out;
	}
	if(bOpen && (idSpecificFormat != INVALID_MEDIA_FORMAT ))
	{
	 // Now walk through the list to see what sizes are supported
	    for (i = 0 ; i < dwcFormatsReturned ; i++)
	    {
	    	if(pvidcaps[i].Id == idSpecificFormat)
	    	{
				dwThisSize = SIZE_TO_FLAG(pvidcaps[i].enumVideoSize);
			    // As long as the macro found the size, return it to the property requester
	        	if (dwThisSize != NON_STANDARD)
	        	{
	        	   	dwSizes |= dwThisSize;
	        	}
			    break;
	    	}
	    }
	}
	else
	{
	    // Now walk through the list to see what sizes are supported
	    for (i = 0 ; i < dwcFormatsReturned ; i++)
	    {
	    	if(m_fSend)
	    	{
				if(!pvidcaps[i].bSendEnabled)
					continue;
	    	}
	    	else
	    	{
				if(!pvidcaps[i].bRecvEnabled)
					continue;
	    	}
	        // Convert to bit field sizes or NON_STANDARD
	        dwThisSize = SIZE_TO_FLAG(pvidcaps[i].enumVideoSize);

	        // As long as the macro found the size, return it to the property requester
	        if (dwThisSize != NON_STANDARD)
	            dwSizes |= dwThisSize;
	    }
	}
    // Now that we've accumulated all the sizes, return them
    dwValue = dwSizes;

out:
    // Free the memory, we're done
    if (pvidcaps)
        LocalFree(pvidcaps);
	// let the interface go
	if (pavc)
		pavc->Release();
	return dwValue;
}

BOOL CVideoProp::HasSourceDialog()
{
	HRESULT hr;
	IVideoChannel *pVideoChannel=NULL;
	DWORD dwFlags;

	ASSERT(m_pMediaStream);
	hr = m_pMediaStream->QueryInterface(IID_IVideoChannel, (void**)&pVideoChannel);
	ASSERT(pVideoChannel);

	if (FAILED(hr))
	{
		return FALSE;
	}

	pVideoChannel->GetDeviceDialog(&dwFlags);
	pVideoChannel->Release();

	return dwFlags & CAPTURE_DIALOG_SOURCE;
}

BOOL CVideoProp::HasFormatDialog()
{
	HRESULT hr;
	IVideoChannel *pVideoChannel=NULL;
	DWORD dwFlags;

	ASSERT(m_pMediaStream);
	hr = m_pMediaStream->QueryInterface(IID_IVideoChannel, (void**)&pVideoChannel);
	ASSERT(pVideoChannel);

	if (FAILED(hr))
	{
		return FALSE;
	}

	pVideoChannel->GetDeviceDialog(&dwFlags);
	pVideoChannel->Release();

	return dwFlags & CAPTURE_DIALOG_FORMAT;
}

VOID CVideoProp::ShowSourceDialog()
{
	DWORD dwFlags = CAPTURE_DIALOG_SOURCE;
	HRESULT hr;
	IVideoChannel *pVideoChannel=NULL;

	ASSERT(m_pMediaStream);

	hr = m_pMediaStream->QueryInterface(IID_IVideoChannel, (void**)&pVideoChannel);
	ASSERT(pVideoChannel);

	if (SUCCEEDED(hr))
	{

		pVideoChannel->ShowDeviceDialog(dwFlags);
		pVideoChannel->Release();
	}
}

VOID CVideoProp::ShowFormatDialog()
{
	DWORD dwFlags = CAPTURE_DIALOG_FORMAT;
	HRESULT hr;
	IVideoChannel *pVideoChannel=NULL;

	ASSERT(m_pMediaStream);

	hr = m_pMediaStream->QueryInterface(IID_IVideoChannel, (void**)&pVideoChannel);
	ASSERT(pVideoChannel);

	if (SUCCEEDED(hr))
	{

		pVideoChannel->ShowDeviceDialog(dwFlags);
		pVideoChannel->Release();
	}
}

VOID CVideoProp::SetReceiveQuality(DWORD dwValue)
{
	m_dwImageQuality = dwValue;
	if(m_pCommChannel)
	{
		dwValue = MAX_VIDEO_QUALITY - dwValue;
		m_pCommChannel->SetProperty(
			PROP_TS_TRADEOFF,
			&dwValue,
			sizeof(dwValue));
	}
}

DWORD CVideoProp::GetReceiveQuality()
{
	return m_dwImageQuality;
}

BOOL CVideoProp::IsCaptureAvailable()
{
	ULONG uNumCapDevs;

	ASSERT(m_pIVideoDevice);

	uNumCapDevs = m_pIVideoDevice->GetNumCapDev();
	
	return (uNumCapDevs > 0);
}

BOOL CVideoProp::IsCaptureSuspended()
{
	BOOL fStandby;
	UINT uSize = sizeof(fStandby);

	ASSERT(m_pCommChannel);
	m_pCommChannel->GetProperty(
		PROP_VIDEO_PREVIEW_STANDBY,
		&fStandby,
		&uSize);
	
	return fStandby;
}


VOID CVideoProp::SuspendCapture(BOOL fSuspend)
{
	ASSERT(m_pCommChannel);
	if (fSuspend)
	{
		// Enable standby
		m_pCommChannel->SetProperty(
			PROP_VIDEO_PREVIEW_STANDBY,
			&fSuspend,
			sizeof(fSuspend));
			
		m_pCommChannel->Preview(INVALID_MEDIA_FORMAT, NULL);
	}
	else
	{
		if(m_fPreview)
		{
			// get format to preview, then do it
			MEDIA_FORMAT_ID FormatID = GetBestFormat();
			if(FormatID != INVALID_MEDIA_FORMAT)
			{
				m_pCommChannel->Preview(FormatID, m_pMediaStream);
			}
			// Disable standby
			m_pCommChannel->SetProperty(
				PROP_VIDEO_PREVIEW_STANDBY,
				&fSuspend,
				sizeof(fSuspend));
		}
		else
		{
			m_pCommChannel->Preview(INVALID_MEDIA_FORMAT, NULL);
		}
	}
}


// Gets the number of enabled capture devices
// Returns -1L on error
int CVideoProp::GetNumCapDev()
{
	ASSERT(m_pIVideoDevice);
	return (m_pIVideoDevice->GetNumCapDev());
}

// Gets the max size of the captuire device name
// Returns -1L on error
int CVideoProp::GetMaxCapDevNameLen()
{
	ASSERT(m_pIVideoDevice);
	return (m_pIVideoDevice->GetMaxCapDevNameLen());
}

// Enum list of enabled capture devices
// Fills up 1st buffer with device IDs, 2nd buffer with device names
// Third parameter is the number of devices to enum
// Returns FALSE on error
BOOL CVideoProp::EnumCapDev(DWORD *pdwCapDevIDs, TCHAR *pszCapDevNames, DWORD dwNumCapDev)
{
	ASSERT(m_pIVideoDevice);
	return (m_pIVideoDevice->EnumCapDev(pdwCapDevIDs, pszCapDevNames, dwNumCapDev));
}

// Returns the ID of the currently selected device
// Returns -1L on error
int CVideoProp::GetCurrCapDevID()
{
	ASSERT(m_pIVideoDevice);
	return (m_pIVideoDevice->GetCurrCapDevID());
}

// Selects the current capture device
// Returns -1L on error
BOOL CVideoProp::SetCurrCapDevID(int nCapDevID)
{
	ASSERT(m_pIVideoDevice);
	return (m_pIVideoDevice->SetCurrCapDevID(nCapDevID));
}

// Selects the current capture device
// Returns -1L on error
BOOL CVideoPump::SetCurrCapDevID(int nCapDevID)
{
    if (nCapDevID == -1)
    {
        WARNING_OUT(("CVideoPump::SetCurrCapDevID called with %d", nCapDevID));

        // This will release the capture device  for Exchange RTC video stuff
        if (m_pMediaStream)
        {
            m_pMediaStream->Configure(NULL, 0, NULL, 0, NULL);
        }

        return TRUE;
    }
    else
    {
    	HRESULT hr;
	    IDualPubCap *pCapability = NULL;
    	LPAPPVIDCAPPIF pVidCap = NULL;
	    IH323CallControl * pH323CallControl = g_pH323UI->GetH323CallControl();

    	// change the capture device
	    CVideoProp::SetCurrCapDevID(nCapDevID);

    	// reinitialize local capability data
        hr = pH323CallControl->QueryInterface(IID_IDualPubCap, (void **)&pCapability);
    	if(FAILED(hr))
	    	goto out;
		
    	ASSERT(pCapability);
        hr = pCapability->QueryInterface(IID_IAppVidCap, (void **)&pVidCap);
    	if(FAILED(hr))
	    	goto out;
    	ASSERT(pVidCap);
	    hr = pVidCap->SetDeviceID(nCapDevID);
    	if(FAILED(hr))
	    	goto out;
    	hr = pCapability->ReInitialize();

out:
	    if (pVidCap)
    		pVidCap->Release();
	    if (pCapability)
		    pCapability->Release();

      	return ForceCaptureChange();
    }
}	


BOOL CVideoPump::ForceCaptureChange()
{
	HRESULT hr = S_OK;

	if (m_fLocal)
	{
		if (m_pConnection)
		{
			if (IsXferEnabled())
			{
				if (!m_fReopenPending && !m_fOpenPending)
				{
					// if the send channel, and a call exists and the channel is open, and not
					// already closing or opening .....
					if(IsChannelOpen())
					{
						ASSERT(m_pCommChannel);
						// need to close and re-open
						// don't lose a good channel if there is no longer
						// a compatible format, otherwise, close and reopen
						m_BestFormat = m_NewFormat = CVideoProp::GetBestFormat();
						if(m_BestFormat != INVALID_MEDIA_FORMAT)
						{
							m_fReopenPending = TRUE;
							hr = m_pCommChannel->Close();
						}
					}
					else
					{
						if(m_BestFormat != INVALID_MEDIA_FORMAT )
						{
							m_fOpenPending = TRUE;
							hr = m_pCommChannel->Open(m_BestFormat, m_pConnection);
							if(FAILED(hr))
								m_fOpenPending = FALSE;
						}
					}
				}
				else	// already waiting for channel to be opened using some format
				{
					m_NewFormat = CVideoProp::GetBestFormat();
				}
			}
			else
			{
				if(IsChannelOpen())
				{
					m_fClosePending = TRUE;
				}
			}
		}
		else
		{
			if (!IsChannelOpen() && IsPreviewEnabled())
			{
				// togle preview to commit size change
				EnablePreview(FALSE);
				EnablePreview(TRUE);
			}
		}
	}

	if (FAILED(hr))
		return FALSE;
	else
		return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\h\avcommon.h ===
#ifndef _AVCOMMON_H_
#define _AVCOMMON_H_

// READ BELOW - DO NOT MODIFY THIS FILE FOR UI PURPOSES



/*
	This file contains text string definitions that are not to be modified
	between release versions.

	These strings and definitions are identifiers for PDUs and other packets
	that get put on the wire.  It's important that these version numbers
	remain constant, even between release versions of NetMeeting.
	Otherwise, interopability and/or compatibility with past/future releases
	may get broken.

	If you are browsing this header file in at attempt to change an 
	"about box", DLL version string, or other UI resource, go away.
	
*/


#define H323_COMPANYNAME_STR      "Microsoft"


// current version
#define H323_PRODUCTNAME_STR	"Microsoft\256 NetMeeting\256"


// older builds and releases of NetMeeting may use this definition
#define H323_OLD_PRODUCTNAME_STR	"Microsoft\256 NetMeeting(TM)"


// current version number, change as approprate
#define H323_PRODUCTRELEASE_STR      "3.0"


// past version numbers - so many variations!
#define H323_20_PRODUCTRELEASE_STR    "Version 2.0"
#define H323_21_PRODUCTRELEASE_STR    "Version 2.1"
#define H323_211_PRODUCTRELEASE_STR    "2.11"

// uggh, there was a version of NetMeeting 2.1 (NM 2.1 SP1) that claimed to be 2.11
#define H323_21_SP1_PRODUCTRELEASE_STR    "Version 2.11"

#define H323_30_PRODUCTRELEASE_STR    "3.0"

// TAPI 3.0 version number
#define H323_TAPI30_PRODUCTRELEASE_STR    "Version 3.0"


// used in sub-string searches to identify NetMeeting clients
#define H323_PRODUCTNAME_SHORT_STR	"NetMeeting"


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\h\avutil.h ===
/* File: avUtil.h (was debug.h + runtime.h)

         Used by NAC.dll and H323CC.dll, and QOS.LIB
 */

#ifndef _AVUTIL_H
#define _AVUTIL_H

#include <nmutil.h>
#include <pshpack8.h> /* Assume 8 byte packing throughout */




/***********************************************************************
 *
 *	Registry access easy-wrapper functions prototypes
 *
 ***********************************************************************/
UINT NMINTERNAL RegistryGetInt(HKEY hPDKey, LPCTSTR lpszSection, LPCTSTR lpszKey, INT dwDefault,
  LPCTSTR lpszFile);
DWORD NMINTERNAL RegistryGetString(HKEY hPDKey, LPCTSTR lpszSection, LPCTSTR lpszKey,
  LPCTSTR lpszDefault, LPTSTR lpszReturnBuffer, DWORD cchReturnBuffer,
  LPCTSTR lpszFile);
BOOL NMINTERNAL RegistrySetString(HKEY hPDKey, LPCTSTR lpszSection, LPCTSTR lpszKey,
  LPCTSTR lpszString, LPCTSTR lpszFile);
BOOL NMINTERNAL RegistrySetInt(HKEY hPDKey, LPCTSTR lpszSection, LPCTSTR lpszKey,
  DWORD i, LPCTSTR lpszFile);
DWORD NMINTERNAL RegistryGetBinData(HKEY hPDKey, LPCTSTR lpszSection, LPCTSTR lpszKey,
  LPVOID lpvDefault, DWORD cchDefault, LPVOID lpvReturnBuffer, DWORD cchReturnBuffer,
  LPCTSTR lpszFile);
BOOL NMINTERNAL RegistrySetBinData(HKEY hPDKey, LPCTSTR lpszSection, LPCTSTR lpszKey,
  LPVOID lpvBinData, DWORD cchBinData, LPCTSTR lpszFile);



/**********************************************************************
 *
 *	Debug Macros
 **********************************************************************/

/*
 *	Debug message types
 */
#define AVERROR				0
#define AVTRACE				1
#define AVTRACEMEM			2
#define AVTESTTRACE			3



//****** Retail
//	MACRO: RETAILMSG(message-to-print)
//	PURPOSE: Prints a message to the debug output
//	NOTE: available in all builds, depends on the registry flag
#define RETAILMSG(x)	 RetailPrintfTrace x
VOID WINAPI RetailPrintfTrace(LPCSTR lpszFormat, ...);

//****** Test and Debug
// in test and debug build, doesnt depent on the registry flag
#if defined(TEST) || defined(DEBUG)
#define TESTMSG(x)		 TestPrintfTrace x
void __cdecl TestPrintfTrace(LPCSTR lpszFormat, ...);
#define ERRORMSG(x)		ERROR_OUT(x)
#else
#define ERRORMSG(x)
#define TESTMSG(x)	
#endif

//****** Debug only
#if defined(DEBUG)

//	MACRO: DebugTrap(void)
//	PURPOSE: Executes a debug break (like 'int 3' on x86)
#define DebugTrap	DebugTrapFn()
#define DEBUGCHK(e)  if(!(e)) DebugTrap

/*
 *  MACRO: DebugPrintError(LPCSTR)
 *
 *  PURPOSE: Prints an error string to the debug output terminal
 *
 *  PARAMETERS:
 *    lpszFormat - a printf-style format
 *
 *  RETURN VALUE:
 *    none
 *
 *  COMMENTS:
 *    This macro calls the generic debug print macro, specifying
 *    that this is an error message
 *
 */

#define DebugPrintError(x)	ERROR_OUT(x)


/*
 *  MACRO: DebugPrintErrorFileLine(DWORD, LPSTR)
 *
 *  PURPOSE: Pretty print an error to the debugging output.
 *
 *  PARAMETERS:
 *    dwError - Actual error code
 *    pszPrefix  - String to prepend to the printed message.
 *
 *  RETURN VALUE:
 *    none
 *
 *  COMMENTS:
 *    It will take the error, turn it into a human
 *    readable string, prepend pszPrefix (so you
 *    can tag your errors), append __FILE__ and __LINE__
 *    and print it to the debugging output.
 *
 *    This macro is just a wrapper around OutputDebugLineErrorFileLine
 *    that is necessary to get proper values for __FILE__ and __LINE__.
 *
 */

#define DebugPrintErrorFileLine(dwError, pszPrefix) \
	DebugPrintFileLine(dwError, pszPrefix,\
		__FILE__, __LINE__)

/*
 *  MACRO: DebugPrintTraceFileLine(DWORD, LPSTR)
 *
 *  PURPOSE: Pretty print a trace message to the debugging output.
 *
 *  PARAMETERS:
 *    dwParam- A paramter to trace
 *    pszPrefix  - String to prepend to the printed message.
 *
 *  RETURN VALUE:
 *    none
 *
 *  COMMENTS:
 *    Takes a parameter, prepend pszPrefix (so you
 *    can tag your traces), append __FILE__ and __LINE__
 *    and print it to the debugging output.
 *
 *    This macro is just a wrapper around OutputDebugLineErrorFileLine
 *    that is necessary to get proper values for __FILE__ and __LINE__.
 *
 */

#define DebugPrintTraceFileLine(dwParam, pszPrefix) \
	DebugPrintFileLine(dwParam, pszPrefix,\
		__FILE__, __LINE__)

void DebugPrintFileLine(
    DWORD dwError, LPSTR szPrefix, 
    LPSTR szFileName, DWORD nLineNumber);


VOID NMINTERNAL DebugTrapFn(void);

#else	// not DEBUG 

#define DEBUGMSG(z,s)
#define DebugTrap
#define DebugPrintError(x)
#define DebugPrintTrace(x)
#define DebugPrintTraceFileLine(dwParam, pszPrefix)
#define DEBUGCHK(e)

#endif

#define GETMASK(hDbgZone) \
		((hDbgZone) ? (((PZONEINFO)(hDbgZone))->ulZoneMask) : (0))
	
#include <poppack.h> /* End byte packing */

#endif	//#ifndef _AVUTIL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\h\appavcap.h ===
/*
 *  	File: appavcap.h
 *
 *      Network audio/video application capability interface. Provides
 * 		data structures for adding, removing, enumerating, prioritizing,\
 *		and enabling/disabling codecs independently for send/receive.
 *
 */


#ifndef _APPAVCAP_H
#define _APPAVCAP_H

#include <mmreg.h>
#include <msacm.h>

#include <pshpack8.h> /* Assume 8 byte packing throughout */

// For use as dimension for variable size arrays
#define VARIABLE_DIM 1

// CPU utilization numbers for NetMeeting-provided codecs
#define LNH_48_CPU 97
#define LNH_8_CPU  47
#define LNH_12_CPU 48
#define LNH_16_CPU 49
#define MS_G723_CPU 70
#define CCITT_A_CPU 24
#define	CCITT_U_CPU 25
#define MSRT24_CPU 55


// AUDIO_FORMAT_ID is an index into an array of AUDCAPS structures
typedef DWORD AUDIO_FORMAT_ID;
#define INVALID_AUDIO_FORMAT 0xffffffff
typedef DWORD MEDIA_FORMAT_ID;
#define INVALID_MEDIA_FORMAT 0xffffffff
// VIDEO_FORMAT_ID is an index into an array of VIDCAPS structures
typedef DWORD VIDEO_FORMAT_ID;
#define INVALID_VIDEO_FORMAT 0xffffffff

/*
 *  @doc  EXTERNAL DATASTRUC
 *
 *	AUDIO capabilities info structure
 *
 *	@struct AUDCAP_INFO | AUDIO capabilities info structure.
 *	Use for both input and output when calling capabilties APIs.
 *	The fields are input-only, output-only or input/output depending on the API used.
 *	Behavior is undefined if these are altered.
 */

// basic audcap structure
typedef struct BasicAudCapInfo
{
	WORD wFormatTag;			// @field The ACM format tag
	AUDIO_FORMAT_ID	Id;			// @field (OUTPUT only) The local id (a.k.a. *Handle*) of this capability entry
	char szFormat[ACMFORMATDETAILS_FORMAT_CHARS];	// @field (OUTPUT only) Descriptive string of
													// the format, e.g. "Microsoft GSM 6.10"
	UINT uMaxBitrate;			// @field (OUTPUT only) Worst case bitrate
	UINT uAvgBitrate;			// @field The average bitrate for this codec
	WORD wCPUUtilizationEncode;	// @field % of Pentium 90Mhz needed for compress
	WORD wCPUUtilizationDecode;	// @field % of Pentium 90Mhz needed for decompress
	
	BOOL bSendEnabled;			// @field OK to use this format for sending
	BOOL bRecvEnabled;			// @field OK to use this format for receiving
	WORD wSortIndex;			// @field The ordered position of this entry
								// in the capability table. Can be used as input only 
								// in ReorderFormats
}BASIC_AUDCAP_INFO, *PBASIC_AUDCAP_INFO, AUDCAP_INFO, *PAUDCAP_INFO;

/*
 *	@struct AUDCAP_INFO_LIST | List of AUDCAP_INFO structures
 */
typedef struct _audcapinfolist
{
	ULONG	cFormats;			// @field Number of AUDCAP_INFO structures in this list
	AUDCAP_INFO	aFormats[VARIABLE_DIM];	// @field cFormats AUDCAP_INFO structures
} AUDCAP_INFO_LIST, *PAUDCAP_INFO_LIST;

/*
 *	@enum VIDEO_SIZES | Enumeration values for the three video sizes supported by NetMeeting
 */
typedef enum
{
	Small = 0,	// @emem Small size video
	Medium,		// @emem Medium size video
	Large		// @emem Large size video
} VIDEO_SIZES;

/*
 *	VIDEO capabilities info structure
 *
 *	@struct VIDCAP_INFO | VIDEO capabilities info structure.
 *	Use for both input and output when calling capabilties APIs.
 *	The fields are input-only, output-only or input/output depending on the API used.
 *	Behavior is undefined if these are altered.
 */

// VIDCAP_INFO structure
typedef struct BasicVidCapInfo
{
	// format identification
	DWORD dwFormatTag;			// @field The format tag of this format
	VIDEO_FORMAT_ID	Id;			// @field (OUTPUT only) The local id (a.k.a. *Handle*) of this capability entry
	char szFormat[ACMFORMATDETAILS_FORMAT_CHARS];	// @field (OUTPUT only) Descriptive string of,
													// the formate.g. "Microsoft H.263"
	// NetMeeting specific info
	WORD wCPUUtilizationEncode;	// @field % of Pentium 90Mhz needed for compress
	WORD wCPUUtilizationDecode;	// @field % of Pentium 90Mhz needed for decompress
	BOOL bSendEnabled;			// @field OK to use this format for sending
	BOOL bRecvEnabled;			// @field OK to use this format for receiving
	WORD wSortIndex;			// @field (OUTPUT only) The ordered position of this entry
								// in the capability table.

	// video format details
	VIDEO_SIZES enumVideoSize;	// @field The video size for this format. Different video sizes for 
								// the same formats must be added as separate formats 
    BITMAPINFOHEADER bih;		// @field The BITMAPINFOHEADER sturcture for the video 
								// size in enumVideosize
	UINT uFrameRate;			// @field Number of frames per second
	DWORD dwBitsPerSample;		// @field number of bits per sample for this format. Must
								// match the value in bih.biBitCount
	UINT uAvgBitrate;			// @field The average bitrate for this codec
	UINT uMaxBitrate;			// @field (OUTPUT only) Worst case bitrate
}BASIC_VIDCAP_INFO, *PBASIC_VIDCAP_INFO, VIDCAP_INFO, *PVIDCAP_INFO;


/*
 *	@struct VIDCAP_INFO_LIST | List of VIDCAP_INFO structures
 */
typedef struct _vidcapinfolist
{
	ULONG	cFormats;// @field Number of VIDCAP_INFO structures in this list
	VIDCAP_INFO	aFormats[VARIABLE_DIM];	// @field cFormats VIDCAP_INFO structures
} VIDCAP_INFO_LIST, *PVIDCAP_INFO_LIST;

#include <poppack.h> /* End byte packing */


#endif	//#ifndef _APPAVCAP_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\h\apierror.h ===
/****************************************************************************
 *
 *	$Archive:   S:/STURGEON/SRC/INCLUDE/VCS/apierror.h_v  $
 *
 *  INTEL Corporation Prorietary Information
 *
 *  This listing is supplied under the tERROR of a license agreement
 *  with INTEL Corporation and may not be copied nor disclosed except
 *  in accordance with the terms of that agreement.
 *
 *	Copyright (c) 1993-1994 Intel Corporation.
 *
 *	$Revision:   1.28  $
 *	$Date:   Jan 22 1997 11:38:04  $
 *	$Author:   plantz  $
 *
 *	Deliverable:
 *
 *	Abstract:
 *		Media Service Manager "public" header file. This file contains
 *		#defines, typedefs, struct definitions and prototypes used by
 *		and in conjunction with MSM. Any EXE or DLL which interacts with
 *		MSM will include this header file.
 *
 *	Notes:
 *
 ***************************************************************************/

#ifndef APIERROR_H
#define APIERROR_H

#include <objbase.h>

#ifdef __cplusplus
extern "C" {				// Assume C declarations for C++.
#endif // __cplusplus


#ifndef DllExport
#define DllExport	__declspec( dllexport )
#endif	// DllExport


// Prototype for function that converts HRESULT into a string.  The function
// and string resources are contained in NETMMERR.DLL.
//
typedef WORD	(*NETMMERR_ERRORTOSTRING)	(HRESULT, LPSTR, int);


extern DllExport BOOL GetResultUserString(HRESULT hResult, LPSTR lpBuffer, int iBufferSize);
extern DllExport BOOL GetResultSubStrings(HRESULT hResult, LPSTR lpBuffer, int iBufferSize);


// This description was extracted from winerror.h.  It appears here only for
// the purpose of convenience.

//
// OLE error definitions and values
//
// The return value of OLE APIs and methods is an HRESULT.
// This is not a handle to anything, but is merely a 32-bit value
// with several fields encoded in the value.  The parts of an
// HRESULT are shown below.
//
// Many of the macros and functions below were orginally defined to
// operate on SCODEs.  SCODEs are no longer used.  The macros are
// still present for compatibility and easy porting of Win16 code.
// Newly written code should use the HRESULT macros and functions.
//

//
//  HRESULTs are 32 bit values layed out as follows:
//
//   3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
//   1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
//  +-+-+-+-+-+---------------------+-------------------------------+
//  |S|R|C|N|r|    Facility         |               Code            |
//  +-+-+-+-+-+---------------------+-------------------------------+
//
//  where
//
//      S - Severity - indicates success/fail
//
//          0 - Success
//          1 - Fail (COERROR)
//
//      R - reserved portion of the facility code, corresponds to NT's
//              second severity bit.
//
//      C - reserved portion of the facility code, corresponds to NT's
//              C field.
//
//      N - reserved portion of the facility code. Used to indicate a
//              mapped NT status value.
//
//      r - reserved portion of the facility code. Reserved for internal
//              use. Used to indicate HRESULT values that are not status
//              values, but are instead message ids for display strings.
//
//      Facility - is the facility code
//
//      Code - is the facility's status code
//


// Macro to create a custom HRESULT
//
#define MAKE_CUSTOM_HRESULT(sev,cus,fac,code) \
((HRESULT) (((unsigned long)(sev)<<31) | ((unsigned long)(cus)<<29) | ((unsigned long)(fac)<<16) | ((unsigned long)(code))) )


// Macro to test for custom HRESULT
//
#define HRESULT_CUSTOM(hr)  (((hr) >> 29) & 0x1)

// Macro to get custom facility and code
//
#define CUSTOM_FACILITY_MASK 0x07FF0000
#define CUSTOM_FACILITY(hr) ((hr & CUSTOM_FACILITY_MASK) >> 16)
#define CUSTOM_FACILITY_CODE(hr) (hr & 0x00000FFF)

// Custom facility codes
//
#define FACILITY_BASE                          0x080
#define FACILITY_MSM                           (FACILITY_BASE +  1)
#define FACILITY_AUDIOMSP                      (FACILITY_BASE +  2)
#define FACILITY_VIDEOMSP                      (FACILITY_BASE +  3)
#define FACILITY_FILEIOMSP                     (FACILITY_BASE +  4)
#define FACILITY_CALLCONTROL                   (FACILITY_BASE +  5)
#define FACILITY_SESSIONMANAGER                (FACILITY_BASE +  6)
#define FACILITY_RTPCHANMAN                    (FACILITY_BASE +  7)
#define FACILITY_RTPMSP                        (FACILITY_BASE +  8)
#define FACILITY_RTPRTCPCONTROL                (FACILITY_BASE +  9)
#define FACILITY_WINSOCK                       (FACILITY_BASE + 10)
#define FACILITY_TESTMSP                       (FACILITY_BASE + 11)
#define FACILITY_MSM_SESSION_CLASSES           (FACILITY_BASE + 12)
#define FACILITY_SCRIPTING                     (FACILITY_BASE + 13)
#define FACILITY_Q931                          (FACILITY_BASE + 14)
#define FACILITY_WSCB                          (FACILITY_BASE + 15)
#define FACILITY_DRWS                          (FACILITY_BASE + 16)
#define FACILITY_ISDM                          (FACILITY_BASE + 17)
#define FACILITY_AUTOREG                       (FACILITY_BASE + 18)
#define FACILITY_CAPREG                        (FACILITY_BASE + 19)
#define FACILITY_H245WS                        (FACILITY_BASE + 20)
#define FACILITY_H245                          (FACILITY_BASE + 21)
#define FACILITY_ARSCLIENT                     (FACILITY_BASE + 22)
#define FACILITY_PPM                           (FACILITY_BASE + 23)
#define FACILITY_STRMSP                        (FACILITY_BASE + 24)
#define FACILITY_STRMAN                        (FACILITY_BASE + 25) 
#define FACILITY_MIXERMSP                      (FACILITY_BASE + 26) 
#define FACILITY_GKI                           (FACILITY_BASE + 27)
#define FACILITY_GKIREGISTRATION               (FACILITY_BASE + 28)
#define FACILITY_GKIADMISSION                  (FACILITY_BASE + 29)
#define FACILITY_CALLINCOMPLETE                (FACILITY_BASE + 30)
#define FACILITY_CALLSUMMARY                   (FACILITY_BASE + 31)
#define FACILITY_GKIUNREGREQ                   (FACILITY_BASE + 32)

#define FACILITY_WINSOCK2                      FACILITY_WINSOCK

// Macros to support custom error reporting
//
#define MAKE_MSM_ERROR(error)                  MAKE_CUSTOM_HRESULT(SEVERITY_ERROR, TRUE, FACILITY_MSM, (error))
#define MAKE_AUDIOMSP_ERROR(error)             MAKE_CUSTOM_HRESULT(SEVERITY_ERROR, TRUE, FACILITY_AUDIOMSP, (error))
#define MAKE_AUDIOMSP_ERROR(error)             MAKE_CUSTOM_HRESULT(SEVERITY_ERROR, TRUE, FACILITY_AUDIOMSP, (error))
#define MAKE_VIDEOMSP_ERROR(error)             MAKE_CUSTOM_HRESULT(SEVERITY_ERROR, TRUE, FACILITY_VIDEOMSP, (error))
#define MAKE_FILEIOMSP_ERROR(error)            MAKE_CUSTOM_HRESULT(SEVERITY_ERROR, TRUE, FACILITY_FILEIOMSP,(error))
#define MAKE_RTPCHANMAN_ERROR(error)           MAKE_CUSTOM_HRESULT(SEVERITY_ERROR, TRUE, FACILITY_RTPCHANNELMANAGER, (error))
#define MAKE_RTPMSP_ERROR(error)               MAKE_CUSTOM_HRESULT(SEVERITY_ERROR, TRUE, FACILITY_RTPMSP, (error))
#define MAKE_WINSOCK_ERROR(error)              MAKE_CUSTOM_HRESULT(SEVERITY_ERROR, TRUE, FACILITY_WINSOCK, (error))
#define MAKE_TESTMSP_ERROR(error)              MAKE_CUSTOM_HRESULT(SEVERITY_ERROR, TRUE, FACILITY_TESTMSP, (error))
#define MAKE_MSM_SESSION_CLASSES_ERROR(error)  MAKE_CUSTOM_HRESULT(SEVERITY_ERROR, TRUE, FACILITY_MSM_SESSION_CLASSES, (error))
#define MAKE_SCRIPTING_ERROR(error)            MAKE_CUSTOM_HRESULT(SEVERITY_ERROR, TRUE, FACILITY_SCRIPTING,(error))
#define MAKE_Q931_ERROR(error)                 MAKE_CUSTOM_HRESULT(SEVERITY_ERROR, TRUE, FACILITY_Q931, (error))
#define MAKE_WSCB_ERROR(error)                 MAKE_CUSTOM_HRESULT(SEVERITY_ERROR, TRUE, FACILITY_WSCB, (error))
#define MAKE_DRWS_ERROR(error)                 MAKE_CUSTOM_HRESULT(SEVERITY_ERROR, TRUE, FACILITY_DRWS, (error))
#define MAKE_ISDM_ERROR(error)                 MAKE_CUSTOM_HRESULT(SEVERITY_ERROR, TRUE, FACILITY_ISDM, (error))
#define MAKE_AUTOREG_ERROR(error)              MAKE_CUSTOM_HRESULT(SEVERITY_ERROR, TRUE, FACILITY_AUTOREG, (error))
#define MAKE_CAPREG_ERROR(error)               MAKE_CUSTOM_HRESULT(SEVERITY_ERROR, TRUE, FACILITY_CAPREG, (error))
#define MAKE_H245WS_ERROR(error)               MAKE_CUSTOM_HRESULT(SEVERITY_ERROR, TRUE, FACILITY_H245WS, (error))
#define MAKE_H245_ERROR(error)                 MAKE_CUSTOM_HRESULT(SEVERITY_ERROR, TRUE, FACILITY_H245, (error))
#define MAKE_ARSCLIENT_ERROR(error)            MAKE_CUSTOM_HRESULT(SEVERITY_ERROR, TRUE, FACILITY_ARSCLIENT, (error))
#define MAKE_PPM_ERROR(error)                  MAKE_CUSTOM_HRESULT(SEVERITY_ERROR, TRUE, FACILITY_PPM, (error))
#define MAKE_STRMSP_ERROR(error)               MAKE_CUSTOM_HRESULT(SEVERITY_ERROR, TRUE, FACILITY_STRMSP, (error))
#define MAKE_STRMAN_ERROR(error)               MAKE_CUSTOM_HRESULT(SEVERITY_ERROR, TRUE, FACILITY_STRMAN, (error))
#define MAKE_MIXERMSP_ERROR(error)             MAKE_CUSTOM_HRESULT(SEVERITY_ERROR, TRUE, FACILITY_MIXERMSP, (error))


// Error defines for MSM
//
//
#define ERROR_BASE_ID                          0x8000
#define ERROR_LOCAL_BASE_ID                    0xA000

//
// MessageId: ERROR_UNKNOWN
//
// MessageText:
//
//  An unkown error has occured in the system
//
#define ERROR_UNKNOWN					(ERROR_BASE_ID +  0)


//
// MessageId: ERROR_INVALID_BUFFER
//
// MessageText:
//
//  An invalid buffer handle was encountered.
//
#define ERROR_INVALID_BUFFER			(ERROR_BASE_ID +  1)


//
// MessageId: ERROR_INVALID_BUFFER_SIZE
//
// MessageText:
//
//  An invalid buffer size was encountered.
//
#define ERROR_INVALID_BUFFER_SIZE		(ERROR_BASE_ID +  2)


//
// MessageId: ERROR_INVALID_CALL_ORDER
//
// MessageText:
//
//  A bad call sequence was encountered.
//
#define ERROR_INVALID_CALL_ORDER		(ERROR_BASE_ID +  3)


//
// MessageId: ERROR_INVALID_CONFIG_SETTING
//
// MessageText:
//
//  A specified configuration parameter was invalid
//
#define ERROR_INVALID_CONFIG_SETTING	(ERROR_BASE_ID +  4)


//
// MessageId: ERROR_INVALID_LINK
//
// MessageText:
//
//  An invalid link handle was encountered.
//
#define ERROR_INVALID_LINK				(ERROR_BASE_ID +  5)


//
// MessageId: ERROR_INVALID_PORT
//
// MessageText:
//
//  An invalid port handle was encountered.
//
#define ERROR_INVALID_PORT				(ERROR_BASE_ID +  6)


//
// MessageId: ERROR_INVALID_SERVICE
//
// MessageText:
//
//  An invalid service handle was encountered.
//
#define ERROR_INVALID_SERVICE			(ERROR_BASE_ID +  7)


//
// MessageId: ERROR_INVALID_SERVICE_DLL
//
// MessageText:
//
//  The specified service DLL does not support required interface
//
#define ERROR_INVALID_SERVICE_DLL		(ERROR_BASE_ID +  8)


//
// MessageId: ERROR_INVALID_SERIVCE_ID
//
// MessageText:
//
//  The specified service was not located in the registry
//
#define ERROR_INVALID_SERVICE_ID		(ERROR_BASE_ID +  9)


//
// MessageId: ERROR_INVALID_SESSION
//
// MessageText:
//
//  An invalid session handle was encountered.
//
#define ERROR_INVALID_SESSION			(ERROR_BASE_ID + 10)


//
// MessageId: ERROR_INVALID_SYNC
//
// MessageText:
//
//  An invalid sync handle was encountered.
//
#define ERROR_INVALID_SYNC				(ERROR_BASE_ID + 11)

//
// MessageId: ERROR_INVALID_VERSION
//
// MessageText:
//
//  An invalid version of an object or structure was detected.
//
#define ERROR_INVALID_VERSION			(ERROR_BASE_ID + 12)

//
// MessageId: ERROR_BUFFER_LIMIT
//
// MessageText:
//
//  No buffers are available for performing this operation.
//
#define ERROR_BUFFER_LIMIT				(ERROR_BASE_ID + 13)

//
// MessageId: ERROR_INVALID_SKEY
//
// MessageText:
//
//  An invalid status key was encountered.
//
#define ERROR_INVALID_SKEY				(ERROR_BASE_ID + 14)

//
// MessageId: ERROR_INVALID_SVALUE
//
// MessageText:
//
//  An invalid status value was encountered.
//
#define ERROR_INVALID_SVALUE			(ERROR_BASE_ID + 15)



#ifdef __cplusplus
}						// End of extern "C" {
#endif // __cplusplus

#endif // APIMSM_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\h\auformats.h ===
#ifndef _AUFORMATS_H
#define _AUFORMATS_H

#include <pshpack8.h> /* Assume 8 byte packing throughout */

#define WAVE_FORMAT_INTELG723 0x0400
#define WAVE_FORMAT_MSG723 0x0042	  /*  Microsoft Corporation  */
#define WAVE_FORMAT_LH_CELP 0x0070
#define WAVE_FORMAT_LH_SB8	   0x0071
#define WAVE_FORMAT_LH_SB12 0x0072
#define WAVE_FORMAT_LH_SB16 0x0073
#define WAVE_FORMAT_MSRT24 0x0082     /*  Microsoft RT24  */
#define WAVE_FORMAT_VOXWARE		0x0062


#define ACMDM_LH_DATA_PACKAGING		(ACMDM_USER + 1)


// lParam1 when sending ACMDM_LH_DATA_PACKAGING
enum
{
	LH_PACKET_DATA_NULL,	// uninitialized
	LH_PACKET_DATA_FRAMED,	// always aligned on frame boundary
	LH_PACKET_DATA_ANYTHING // do not assume alignment
};

#include <poppack.h> /* End byte packing */


#pragma pack(1)  // byte packing
typedef struct msg723waveformat_tag {
    WAVEFORMATEX wfx;
    WORD         wConfigWord;
    DWORD        dwCodeword1;
    DWORD        dwCodeword2;
} MSG723WAVEFORMAT;

typedef struct intelg723waveformat_tag {
    WAVEFORMATEX wfx;
    WORD         wConfigWord;
    DWORD        dwCodeword1;
    DWORD        dwCodeword2;
} INTELG723WAVEFORMAT;

typedef struct tagVOXACM_WAVEFORMATEX 
{
	WAVEFORMATEX	wfx;
	DWORD           dwCodecId;
	DWORD			dwMode;
	char			szKey[72];
} VOXACM_WAVEFORMATEX, *PVOXACM_WAVEFORMATEX, FAR *LPVOXACM_WAVEFORMATEX;


#pragma pack()


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\h\bestintf.h ===
#ifndef _BESTINTF
#define _BESTINTF

#include <iphlpapi.h>
#include <winsock2.h>

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

DWORD NMINTERNAL NMGetBestInterface ( SOCKADDR_IN* srem, SOCKADDR_IN* sloc );

#ifdef __cplusplus
}
#endif // __cplusplus

#endif // _BESTINTF
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\h\bstring.h ===
/*
 * BSTRING.H
 *
 * Defines a BSTRING C++ class that allows us to wrap the OLE BSTR (Basic
 * String) type, primarily to simplify the creation and freeing of these
 * objects.  This is intended to be a lightweight wrapper with minimal
 * overhead.
 *
 * If no input string is specified to the constructor or if the allocation
 * of the BSTR fails, then the <m_bstr> member is set to NULL.
 *
 * Note: The BSTRING class is not intended to allow managing multiple BSTR 
 * strings with a single object.
 *
 * Usage scenarios:
 *
 * 1) Create a BSTR from an existing string, have it automatically freed
 *    when done.
 *
 *		// Allocate BSTR using SysAllocString()
 *		BSTRING bstrComputerName(lpstrComputerName);
 *
 *		...
 *
 *		// Automatic, lightweight cast to BSTR
 *		SomeFunctionThatTakesABSTR(bstrComputerName);
 *
 *		...
 *
 *		// SysFreeString() gets called automatically when the scope of
 *		// bstrComputerName ends.
 *
 * 2) Create a null BSTRING object, pass it to a function that returns an
 *	  allocated BSTR, then have it automatically freed when done.
 *
 *		// Create null BSTRING
 *		BSTRING bstrReturnedComputerName;
 *
 *		...
 *
 *		// Call a function that returns an allocated BSTR.
 *		SomeFunctionThatReturnsABSTR(bstrReturnedComputerName.GetLPBSTR());
 *
 *		...
 *
 *		// SysFreeString() gets called automatically when the scope of
 *		// bstrReturnedComputerName ends.
 *		
 * Author:
 *		dannygl, 29 Oct 96
 */

#if !defined(_BSTRING_H_)
#define _BSTRING_H_

#include <oleauto.h>
#include <confdbg.h>

class BSTRING
{
private:
	BSTR m_bstr;

public:
	// Constructors
	BSTRING() {m_bstr = NULL;}

	inline BSTRING(LPCWSTR lpcwString);

#if !defined(UNICODE)
	// We don't support construction from an ANSI string in the Unicode build.
	BSTRING(LPCSTR lpcString);
#endif // !defined(UNICODE)

	// Destructor
	inline ~BSTRING();

	// Cast to BSTR
	operator BSTR() {return m_bstr;}

	// Get a BSTR pointer.
	//
	// This member function is intended for passing this object to
	// functions that allocate a BSTR, return a pointer to this BSTR,
	// and expect the caller to free the BSTR when done.  The BSTR is
	// freed when the BSTRING destructor gets called.
	inline LPBSTR GetLPBSTR(void);
};


BSTRING::BSTRING(LPCWSTR lpcwString)
{
	if (NULL != lpcwString)
	{
		// SysAllocString returns NULL on failure
		m_bstr = SysAllocString(lpcwString);

		ASSERT(NULL != m_bstr);
	}
	else
	{
		m_bstr = NULL;
	}
}

BSTRING::~BSTRING()
{
	if (NULL != m_bstr)
	{
		SysFreeString(m_bstr);
	}
}

inline LPBSTR BSTRING::GetLPBSTR(void)
{
	// This function is intended to be used to set the BSTR value for
	// objects that are initialized to NULL.  It should not be called
	// on objects which already have a non-NULL BSTR.
	ASSERT(NULL == m_bstr);

	return &m_bstr;
}

#endif // !defined(_BSTRING_H_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\h\cnotifid.h ===
/*
 * CLSID for CConfNotify object and IID for IConfNotify interface
 *
 * ChrisPi 10-3-95
 *
 */

#ifndef _CNOTIFID_H_
#define _CNOTIFID_H_

// {49C6C2C0-FD8A-11ce-8865-00805F742EF6}
DEFINE_GUID(CLSID_ConfNotify, 
0x49c6c2c0, 0xfd8a, 0x11ce, 0x88, 0x65, 0x0, 0x80, 0x5f, 0x74, 0x2e, 0xf6);

DEFINE_GUID(IID_IConfNotify, 
0x49c6c2d0, 0xfd8a, 0x11ce, 0x88, 0x65, 0x0, 0x80, 0x5f, 0x74, 0x2e, 0xf6);

#endif /* _CNOTIFID_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\h\capflags.h ===
#ifndef __capflags_h__
#define __capflags_h__

const UINT CAPFLAG_DATA =					0x00000001;
const UINT CAPFLAG_SEND_AUDIO  =			0x00000002;
const UINT CAPFLAG_RECV_AUDIO =				0x00000004;
const UINT CAPFLAG_SEND_VIDEO =				0x00000008;
const UINT CAPFLAG_RECV_VIDEO =				0x00000010;
const UINT CAPFLAG_H323_CC =                0x00000020;

const UINT CAPFLAG_DATA_IN_USE =			0x00010000;
const UINT CAPFLAG_AUDIO_IN_USE =			0x00020000;
const UINT CAPFLAG_VIDEO_IN_USE =			0x00040000;
const UINT CAPFLAG_H323_IN_USE =			0x00080000;

#define CAPFLAGS_AUDIO          (CAPFLAG_SEND_AUDIO | CAPFLAG_RECV_AUDIO)

#define CAPFLAGS_VIDEO          (CAPFLAG_SEND_VIDEO | CAPFLAG_RECV_VIDEO)

#define CAPFLAGS_AV_STREAMS     (CAPFLAGS_AUDIO | CAPFLAGS_VIDEO)

#define CAPFLAGS_AV_ALL         (CAPFLAG_H323_CC | CAPFLAGS_AV_STREAMS)

#define CAPFLAGS_ALL            (CAPFLAG_DATA | CAPFLAGS_AV_ALL)


#endif // __capflags_h__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\h\cnotify.h ===
/*
 * IConfNotify interface definition
 *
 * ChrisPi 9-29-95
 *
 */

#ifndef _CNOTIFY_H_
#define _CNOTIFY_H_

#undef  INTERFACE
#define INTERFACE IConfNotify

DECLARE_INTERFACE_(IConfNotify, IUnknown)
{
	/* IUnknown methods */

	STDMETHOD(QueryInterface)(	THIS_
								REFIID riid,
								PVOID *ppvObject) PURE;

	STDMETHOD_(ULONG, AddRef)(THIS) PURE;

	STDMETHOD_(ULONG, Release)(THIS) PURE;

	/* IConfNotify methods */

	STDMETHOD(OnConf_Ended)(THIS_
							DWORD dwCode) PURE;


	STDMETHOD(OnEnum_Rejected)(	THIS_
								DWORD dwCode) PURE;

	STDMETHOD(OnEnum_Failed)(	THIS_
								DWORD dwCode) PURE;


	STDMETHOD(OnJoin_InvalidPassword)(	THIS_
										DWORD dwCode) PURE;

	STDMETHOD(OnJoin_InvalidConference)(THIS_
										DWORD dwCode) PURE;

	STDMETHOD(OnJoin_Rejected)(	THIS_
								DWORD dwCode) PURE;

	STDMETHOD(OnJoin_Failed)(	THIS_
								DWORD dwCode) PURE;


	STDMETHOD(OnUser_Added)(	THIS_
								DWORD dwUserID) PURE;

	STDMETHOD(OnUser_Removed)(	THIS_
								DWORD dwUserID) PURE;

	STDMETHOD(OnTAPI_Status)(	THIS_
								LPCTSTR pcszStatus) PURE;

};

typedef IConfNotify *PIConfNotify;
typedef const IConfNotify CIConfNotify;
typedef const IConfNotify *PCIConfNotify;

#endif /* _CNOTIFY_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\h\cnotify.hpp ===
/*
 * CNotify.hpp - CConfNotify class definition
 *
 * Created: ChrisPi 10-3-95
 *
 */

#ifndef _CNOTIFY_HPP_
#define _CNOTIFY_HPP_

class CConfNotify :
		public RefCount,
		public IConfNotify
{
private:

	// private members

public:
	CConfNotify(OBJECTDESTROYEDPROC);
	~CConfNotify(void);

	// IConfNotify methods

	HRESULT STDMETHODCALLTYPE OnConf_Ended(DWORD dwCode);
	HRESULT STDMETHODCALLTYPE OnEnum_Rejected(DWORD dwCode);
	HRESULT STDMETHODCALLTYPE OnEnum_Failed(DWORD dwCode);
	HRESULT STDMETHODCALLTYPE OnJoin_InvalidPassword(DWORD dwCode);
	HRESULT STDMETHODCALLTYPE OnJoin_InvalidConference(DWORD dwCode);
	HRESULT STDMETHODCALLTYPE OnJoin_Rejected(DWORD dwCode);
	HRESULT STDMETHODCALLTYPE OnJoin_Failed(DWORD dwCode);
	HRESULT STDMETHODCALLTYPE OnUser_Added(DWORD dwUserID);
	HRESULT STDMETHODCALLTYPE OnUser_Removed(DWORD dwUserID);
	HRESULT STDMETHODCALLTYPE OnTAPI_Status(LPCTSTR pcszStatus);

	// IUnknown methods

	HRESULT STDMETHODCALLTYPE QueryInterface(REFIID riid, PVOID *ppvObj);
	ULONG   STDMETHODCALLTYPE AddRef(void);
	ULONG   STDMETHODCALLTYPE Release(void);

	// other methods

	// friends

#ifdef DEBUG

	friend BOOL IsValidPCCConfNotify(const CConfNotify *pcConfNotify);

#endif
};

DECLARE_STANDARD_TYPES(CConfNotify);

#endif // _CNOTIFY_HPP_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\h\clink.h ===
/*
 * IConferenceLink interface definition
 *
 * ChrisPi 9-12-95
 *
 * ChrisPi: Added RemoteConfName and CallFlags members 5-15-96
 *
 * Based on IUniformResourceLocator interface by DavidDi
 *
 */

#ifndef _CLINK_H_
#define _CLINK_H_

typedef enum icl_invokecommand_flags
{
	ICL_INVOKECOMMAND_FL_ALLOW_UI			= 0x0001,
	ICL_INVOKECOMMAND_FL_USE_DEFAULT_VERB	= 0x0002,

	ALL_ICL_INVOKECOMMAND_FLAGS	= (	ICL_INVOKECOMMAND_FL_ALLOW_UI |
									ICL_INVOKECOMMAND_FL_USE_DEFAULT_VERB)
}
ICL_INVOKECOMMAND_FLAGS;

typedef struct clinvokecommandinfo
{
   DWORD dwcbSize;
   DWORD dwFlags;
   HWND hwndParent;
   PCSTR pcszVerb;
}
CLINVOKECOMMANDINFO;
typedef CLINVOKECOMMANDINFO *PCLINVOKECOMMANDINFO;
typedef const CLINVOKECOMMANDINFO CCLINVOKECOMMANDINFO;
typedef const CLINVOKECOMMANDINFO *PCCLINVOKECOMMANDINFO;

#undef  INTERFACE
#define INTERFACE IConferenceLink

DECLARE_INTERFACE_(IConferenceLink, IUnknown)
{
	/* IUnknown methods */

	STDMETHOD(QueryInterface)(	THIS_
								REFIID riid,
								PVOID *ppvObject) PURE;

	STDMETHOD_(ULONG, AddRef)(THIS) PURE;

	STDMETHOD_(ULONG, Release)(THIS) PURE;

	/* IConferenceLink methods */

	STDMETHOD(SetName)(	THIS_
						PCSTR pcszName) PURE;

	STDMETHOD(GetName)(	THIS_
						PSTR *ppszName) PURE;

	STDMETHOD(SetAddress)(	THIS_
							PCSTR pcszAddress) PURE;

	STDMETHOD(GetAddress)(	THIS_
							PSTR *ppszAddress) PURE;

	STDMETHOD(SetRemoteConfName)(	THIS_
									PCSTR pcszRemoteConfName) PURE;

	STDMETHOD(GetRemoteConfName)(	THIS_
									PSTR *ppszRemoteConfName) PURE;

	STDMETHOD(SetTransport)(THIS_
							DWORD dwTransport) PURE;

	STDMETHOD(GetTransport)(THIS_
							DWORD *pdwTransport) PURE;

	STDMETHOD(SetCallFlags)(THIS_
							DWORD dwCallFlags) PURE;

	STDMETHOD(GetCallFlags)(THIS_
							DWORD *pdwCallFlags) PURE;

	STDMETHOD(InvokeCommand)(	THIS_
								PCLINVOKECOMMANDINFO pclici) PURE;
};

typedef IConferenceLink *PIConferenceLink;
typedef const IConferenceLink CIConferenceLink;
typedef const IConferenceLink *PCIConferenceLink;

#endif /* _CLINK_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\h\clinkid.h ===
/*
 * CLSID for CConfLink object and IID for IConferenceLink interface
 *
 * ChrisPi 9-12-95
 *
 */

#ifndef _CLINKID_H_
#define _CLINKID_H_

/* {30E7F2A0-EC4C-11ce-8865-00805F742EF6} */
DEFINE_GUID(CLSID_ConfLink, 
0x30e7f2a0, 0xec4c, 0x11ce, 0x88, 0x65, 0x0, 0x80, 0x5f, 0x74, 0x2e, 0xf6);

DEFINE_GUID(IID_IConferenceLink, 
0x30e7f2b0, 0xec4c, 0x11ce, 0x88, 0x65, 0x0, 0x80, 0x5f, 0x74, 0x2e, 0xf6);

#endif /* _CLINKID_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\h\codecs.h ===
/*
 -  CODECS.H
 -
 *	Microsoft NetMeeting
 *	Installable codecs
 *	Header file
 *
 *  @doc  EXTERNAL
 *
 *	@topic NetMeeting Installable Codecs Programmer's Reference | NetMeeting supports
 *		adding arbitrary audio and video codec formats for use with NetMeeting, 
 *		as well as enumerating, prioritizing or removing these formats.
 *
 */

#include <pshpack8.h> /* Assume 8 byte packing throughout */
#include "appavcap.h"

/*
 *	Constants
 */

// hresult codes, facility IC = 0x301
#define IC_E_CAPS_INSTANTIATION_FAILURE		0x83010001	// could not instantiate a required caps object
#define IC_E_CAPS_INITIALIZATION_FAILURE	0x83010002	// could not initialize a required bject
#define IC_E_NO_FORMATS						0x83010003	// no formats available
#define IC_E_NO_SUCH_FORMAT					0x83010005	// no matching AC</VCM format was found
#define IC_E_INTERNAL_ERROR					0x83010006	// the Network Audio/Video Controller
														// reported a system error

/*
 *	Macros
 */

/*
 *	Data Structures
 */

/*
 *	Functions
 */

/*
 *	Interfaces
 */

#ifndef DECLARE_INTERFACE_PTR
#ifdef __cplusplus
#define DECLARE_INTERFACE_PTR(iface, piface)                       \
	interface iface; typedef iface FAR * piface
#else
#define DECLARE_INTERFACE_PTR(iface, piface)                       \
	typedef interface iface iface, FAR * piface
#endif
#endif /* DECLARE_INTERFACE_PTR */


#define IUNKNOWN_METHODS(IPURE)										\
    STDMETHOD (QueryInterface)                                      \
        (THIS_ REFIID riid, LPVOID FAR * ppvObj) IPURE;				\
    STDMETHOD_(ULONG,AddRef)  (THIS) IPURE;							\
    STDMETHOD_(ULONG,Release) (THIS) IPURE;							\

#define IINSTALLAUDIOCODECS_METHODS(IPURE)							\
	STDMETHOD(AddACMFormat)											\
		(THIS_ LPWAVEFORMATEX lpwfx, PAUDCAP_INFO pAudCapInfo) IPURE;	\
	STDMETHOD (RemoveACMFormat)										\
		(THIS_ LPWAVEFORMATEX lpwfx) IPURE;	\
	STDMETHOD (ReorderFormats)										\
		(THIS_ PAUDCAP_INFO_LIST pAudCapInfoList) IPURE;			\
	STDMETHOD (EnumFormats)											\
		(THIS_ PAUDCAP_INFO_LIST *ppAudCapInfoList) IPURE;	\
	STDMETHOD (FreeBuffer) (THIS_ LPVOID lpBuffer) IPURE;			\

#define IINSTALLVIDEOCODECS_METHODS(IPURE)							\
	STDMETHOD(AddVCMFormat)											\
		(THIS_ PVIDCAP_INFO pVidCapInfo) IPURE;	\
	STDMETHOD (RemoveVCMFormat)										\
		(THIS_ PVIDCAP_INFO pVidCapInfo) IPURE;	\
	STDMETHOD (ReorderFormats)										\
		(THIS_ PVIDCAP_INFO_LIST pVidCapInfoList) IPURE;			\
	STDMETHOD (EnumFormats)											\
		(THIS_ PVIDCAP_INFO_LIST *ppVidCapInfoList) IPURE;	\
	STDMETHOD (FreeBuffer) (THIS_ LPVOID lpBuffer) IPURE;			\

// IInstallAudioCodecs
#undef       INTERFACE
#define      INTERFACE  IInstallAudioCodecs
DECLARE_INTERFACE_(IInstallAudioCodecs, IUnknown)
{
    IUNKNOWN_METHODS(PURE)
	IINSTALLAUDIOCODECS_METHODS(PURE)
};
DECLARE_INTERFACE_PTR(IInstallAudioCodecs, LPINSTALLAUDIOCODECS);

// IInstallVideooCodecs
#undef       INTERFACE
#define      INTERFACE  IInstallVideoCodecs
DECLARE_INTERFACE_(IInstallVideoCodecs, IUnknown)
{
    IUNKNOWN_METHODS(PURE)
	IINSTALLVIDEOCODECS_METHODS(PURE)
};
DECLARE_INTERFACE_PTR(IInstallVideoCodecs, LPINSTALLVIDEOCODECS);

// IInstallAudioCodecs
#undef       INTERFACE
#define      INTERFACE  IInstallCodecs
DECLARE_INTERFACE_(IInstallCodecs, IUnknown)
{
    IUNKNOWN_METHODS(PURE)
};
DECLARE_INTERFACE_PTR(IInstallCodecs, LPINSTALLCODECS);

EXTERN_C HRESULT WINAPI CreateInstallCodecs (
								IUnknown *punkOuter,
								REFIID riid,
								void **ppv);

typedef HRESULT (WINAPI *PFNCREATEINSTALLCODECS)
				(IUnknown *punkOuter, REFIID riid, void **ppv);


// {8ED14CC0-7A1F-11d0-92F6-00A0C922E6B2}
DEFINE_GUID(CLSID_InstallCodecs, 0x8ed14cc0, 0x7a1f, 0x11d0, 0x92, 0xf6, 0x0, 0xa0, 0xc9, 0x22, 0xe6, 0xb2);
// {8ED14CC1-7A1F-11d0-92F6-00A0C922E6B2}
DEFINE_GUID(IID_IInstallCodecs, 0x8ed14cc1, 0x7a1f, 0x11d0, 0x92, 0xf6, 0x0, 0xa0, 0xc9, 0x22, 0xe6, 0xb2);
// {8ED14CC2-7A1F-11d0-92F6-00A0C922E6B2}
DEFINE_GUID(IID_IInstallAudioCodecs, 0x8ed14cc2, 0x7a1f, 0x11d0, 0x92, 0xf6, 0x0, 0xa0, 0xc9, 0x22, 0xe6, 0xb2);
// {8ED14CC3-7A1F-11d0-92F6-00A0C922E6B2}
DEFINE_GUID(IID_IInstallVideoCodecs, 0x8ed14cc3, 0x7a1f, 0x11d0, 0x92, 0xf6, 0x0, 0xa0, 0xc9, 0x22, 0xe6, 0xb2);

#include <poppack.h> /* End byte packing */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\h\confguid.h ===
//****************************************************************************
//
//  File:       confguid.h
//  Content:    This file contains the class GUID for Microsoft Conferencing.
//
//  Copyright (c) Microsoft Corporation 1995-1996
//
//****************************************************************************

// {19FF8A00-9447-11cf-8796-444553540000}

DEFINE_GUID(CLSID_ConferenceManager, 
0x19ff8a00, 0x9447, 0x11cf, 0x87, 0x96, 0x44, 0x45, 0x53, 0x54, 0x0, 0x0);

#define H221USACode1    0xb5
#define H221USACode2    0x00
#define H221MFGCode1    0x53
#define H221MFGCode2    0x4c
#define H221GUIDID      0x01

#define H221GUIDKEY0    H221USACode1
#define H221GUIDKEY1    H221USACode2
#define H221GUIDKEY2    H221MFGCode1
#define H221GUIDKEY3    H221MFGCode2
#define H221GUIDKEY4    H221GUIDID

#define CB_H221_GUIDKEY    (5 + sizeof(GUID))
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\h\common.h ===
/*
 -  common.h
 -
 *      Microsoft Internet Phone
 *              Definitions that are common across the product
 *
 *              Revision History:
 *
 *              When            Who                                     What
 *              --------        ------------------  ---------------------------------------
 *              11.20.95        Yoram Yaacovi           Created
 */

#ifndef _COMMON_H
#define _COMMON_H
#include <windows.h>

#include <pshpack8.h> /* Assume 8 byte packing throughout */

#ifdef __cplusplus
extern "C" {
#endif

/*
 *      DLL names
 */
#define NACDLL                  TEXT("nac.dll")
#define H323DLL			TEXT("h323cc.dll")

/*
 *      Registry section
 *		
 *		Under HKEY_CURRENT_USER
 */
#define szRegInternetPhone			TEXT("Software\\Microsoft\\Internet Audio")
#define szRegInternetPhoneUI		TEXT("UI")
#define szRegInternetPhoneUIProperties	TEXT("UI\\Properties")
#define szRegInternetPhoneDebug		TEXT("Debug")
#define szRegInternetPhoneCodec		TEXT("Codec")
#define szRegInternetPhoneVideoCodec	TEXT("VideoCodec")
#define szRegInternetPhoneDataPump	TEXT("DataPump")
#define szRegInternetPhoneACMEncodings	TEXT("ACMEncodings")
#define szRegInternetPhoneVCMEncodings	TEXT("VCMEncodings")
#define szRegInternetPhoneCustomEncodings TEXT("CustomACMEncodings")
#define szRegInternetPhoneCustomVideoEncodings TEXT("CustomVCMEncodings")
#define szRegInternetPhoneNac		TEXT("NacObject")
#define szRegInternetPhoneHelp		TEXT("Help")
#define szRegInternetPhoneOutputFile	TEXT("RecordToFile")
#define szRegInternetPhoneInputFile	TEXT("PlayFromFile")

/*
 *      Network section
 */
typedef short PORT;
// Following is our assigned port number for the lightweight call control
// protocol, infamously known as MSICCPP, or Microsoft Internet Call Control
// Protocol.
//----------
//From: 	iana@ISI.EDU[SMTP:iana@ISI.EDU]
//Sent: 	Friday, July 12, 1996 11:35 AM
//To: 	Max Morris
//Cc: 	iana@ISI.EDU
//Subject:  Re: request for port number: MSICCPP
//Max,
//
//We have assigned port number 1731 to MSICCPP, with you as the point of
//contact.
//
//Joyce
#define MSICCPP_PORT 1731

//#define HARDCODED_PORT 11010
#define HARDCODED_PORT MSICCPP_PORT
#define H323_PORT 1720 	// well known H.323 listen port

//
//  H.221 identification codes used by call control and nonstandard capability exchange
//
#define USA_H221_COUNTRY_CODE 0xB5
#define USA_H221_COUNTRY_EXTENSION 0x00
#define MICROSOFT_H_221_MFG_CODE 0x534C  //("first" byte 0x53, "second" byte 0x4C)


// some standard RTP payload types
#define RTP_PAYLOAD_H261	31
#define RTP_PAYLOAD_H263	34
#define RTP_PAYLOAD_G723	 4
#define RTP_PAYLOAD_GSM610	3
#define RTP_PAYLOAD_G721	2
#define RTP_PAYLOAD_G711_MULAW	0
#define RTP_PAYLOAD_G711_ALAW	8
#define RTP_PAYLOAD_PCM8	10
#define RTP_PAYLOAD_PCM16	11


//Common Bandwidth declarations
// !!! The QoS will decrease these numbers by the LeaveUnused value.
// This value is currently hardcoded to be 30% 
#define BW_144KBS_BITS				14400	// QoS 30% markdown leads to a max bw usage of  10080 bits/second
#define BW_288KBS_BITS				28800	// QoS 30% markdown leads to a max bw usage of  20160 bits/second
#define BW_ISDN_BITS 				85000	// QoS 30% markdown leads to a max bw usage of  59500 bits/second

// LAN BANDWIDTH for slow pentiums
#define BW_SLOWLAN_BITS				621700	// QoS 30% markdown leads to a max bw usage of 435190 bits/second

// Pentiums faster than 400mhz can have this LAN setting
#define BW_FASTLAN_BITS				825000	// QoS 30% markdown leads to a max bw usage of 577500 bits/second



// For use as dimension for variable size arrays
#define VARIABLE_DIM				1


/*
 *      Interface pointers
 */

#ifndef DECLARE_INTERFACE_PTR
#ifdef __cplusplus
#define DECLARE_INTERFACE_PTR(iface, piface)                       \
	struct iface; typedef iface FAR * piface
#else
#define DECLARE_INTERFACE_PTR(iface, piface)                       \
	typedef struct iface iface, FAR * piface
#endif
#endif /* DECLARE_INTERFACE_PTR */

/*
 *      Custom Interface types
 */
DECLARE_INTERFACE_PTR(IH323Endpoint,       PH323_ENDPOINT);
DECLARE_INTERFACE_PTR(IH323CallControl,       LPH323CALLCONTROL);
DECLARE_INTERFACE_PTR(ICommChannel,       LPCOMMCHANNEL);

// connection request callback returns CREQ_RESPONSETYPE
typedef enum
{
	CRR_ACCEPT,
	CRR_BUSY,
	CRR_REJECT,
	CRR_SECURITY_DENIED,
	CRR_ASYNC,
	CRR_ERROR
}CREQ_RESPONSETYPE;

typedef struct _application_call_setup_data
{
    DWORD dwDataSize;
    LPVOID lpData;
}APP_CALL_SETUP_DATA, *P_APP_CALL_SETUP_DATA;

typedef  CREQ_RESPONSETYPE (__stdcall *CNOTIFYPROC)(IH323Endpoint *pIEndpoint,
   P_APP_CALL_SETUP_DATA pAppData);

#ifdef __cplusplus
}
#endif

#include <poppack.h> /* End byte packing */

#endif  //#ifndef _COMMON_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\h\confevt.h ===
#ifndef _CONFEVT_H_
#define _CONFEVT_H_

// CRPlaceCall Flags:
// Media types:
#define CRPCF_DATA			0x00000001
#define CRPCF_AUDIO			0x00000002
#define CRPCF_VIDEO			0x00000004
#define CRPCF_H323CC        0x00000008


// Data conferencing flags:
#define CRPCF_T120			0x00010000
#define CRPCF_JOIN			0x00020000
#define CRPCF_NO_UI         0x00100000 // Do not display messages (called by API)
#define CRPCF_HOST          0x00200000 // Enter "Host Mode"
#define CRPCF_SECURE        0x00400000 // Make a secure call

#define CRPCF_DEFAULT		CRPCF_DATA |\
							CRPCF_AUDIO|\
							CRPCF_VIDEO|\
                            CRPCF_H323CC |\
							CRPCF_T120

#endif // ! _CONFEVT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\h\confdbg.h ===
// confdbg.h -  Conferencing Debug Functions and Macros

/*
	The main macros are:

	ASSERT - display error if parameter evalulates to FALSE.
		e.g. ASSERT(x == y);

	ERROR_OUT - always print this error.  Messagebox is optional.
		e.g. ERROR_OUT(("Unable to FooBar!  Err=%d", dwErr));

	WARNING_OUT - warning message, not an error (App must call InitDebugModule)
		e.g. WARNING_OUT(("FooBar is not available. Using %s", szAlt));

	TRACE_OUT - debug message (App must call InitDebugModule)
		e.g. TRACE_OUT(("dwFoo=%d, dwBar=%d", dwFoo, dwBar));

	DBGMSG - debug message for a specific zone
		e.g. DBGMSG(ghZoneFoo, ZONE_BAR, ("Setting dwFoo=%d", dwFoo));


Important Functions:
	VOID DbgInit(HDBGZONE * phDbgZone, PTCHAR * psz, UINT cZone);
	VOID DbgDeInit(HDBGZONE * phDbgZone);
	VOID WINAPI DbgPrintf(PCSTR pszPrefix, PCSTR pszFormat, va_list ap);
	PSTR WINAPI DbgZPrintf(HDBGZONE hZone, UINT iZone, PSTR pszFormat,...);

	Note: The strings in these functions, in particular the module and
	zone names, are always ANSI strings, even in Unicode components.  The
	input strings to DBGINIT should not be wrapped in TEXT macros.
*/

#ifndef _CONFDBG_H_
#define _CONFDBG_H_

#include <nmutil.h>
#include <stock.h>

#ifdef __cplusplus
extern "C" {
#endif
#include <pshpack8.h> /* Assume 8 byte packing throughout */

// deal with including "debug.h" before and after
#ifdef DEBUGMSG
#undef DEBUGMSG
#endif
#define _DEBUG_H

// MFC also defines this - use our version
#ifdef ASSERT
#undef ASSERT
#endif

#ifdef DEBUG
#ifndef NM_DEBUG
#define NM_DEBUG
#endif
#endif /* DEBUG */



// Special NetMeeting Debug definitions
#ifdef NM_DEBUG


//////////////////////////////////////
//Debug Zones

#define MAXNUM_OF_MODULES			64
#define MAXSIZE_OF_MODULENAME		32
#define MAXNUM_OF_ZONES				16
#define MAXSIZE_OF_ZONENAME			32

#define ZONEINFO_SIGN				0x12490000


// Zone information for a module
typedef struct _ZoneInfo
{
	ULONG	ulSignature;
	ULONG	ulRefCnt;
	ULONG	ulZoneMask; //the zone mask
	BOOL	bInUse;
	CHAR	pszModule[MAXSIZE_OF_MODULENAME];	//name against which the zones are registered
	CHAR	szZoneNames[MAXNUM_OF_ZONES][MAXSIZE_OF_ZONENAME]; //names of the zones
	CHAR	szFile[MAX_PATH];	                // output file, specific to this module
}ZONEINFO,*PZONEINFO;

// DBGZONEPARAM replaced by ZONEINFO
#define DBGZONEINFO ZONEINFO
#define PDBGZONEINFO PZONEINFO
	
typedef PVOID HDBGZONE;

// size of the memory mapped file
#define CBMMFDBG (sizeof(ZONEINFO) * MAXNUM_OF_MODULES + sizeof(NMDBG))

// General information at end of memory-mapped file (after all zone data)
typedef struct _NmDbg {
	BOOL  fOutputDebugString;  // OutputDebugString is enabled
	BOOL  fWinOutput;          // Window Output is enabled
	HWND  hwndCtrl;            // Window that handles output
	UINT  msgDisplay;          // Message to post to hwndCtrl
	BOOL  fFileOutput;         // File Output is enabled
	CHAR  szFile[MAX_PATH];    // File name for output
	UINT  uShowTime;           // Format date/time (see DBG_FMTTIME_*)
	BOOL  fShowThreadId;       // Dump ThreadId with each message
	BOOL  fShowModule;         // Dump Module:Zone with each message
} NMDBG;
typedef NMDBG * PNMDBG;

#define DBG_FMTTIME_NONE 0     // Do not format the time
#define DBG_FMTTIME_TICK 1     // Old format (tick count)
#define DBG_FMTTIME_FULL 2     // Full Year/Month/Day Hour:Min:Sec.ms
#define DBG_FMTTIME_DAY  3     // Hour:Minute:Second.ms

extern BOOL      WINAPI     NmDbgRegisterCtl(HWND hwnd, UINT uDisplayMsg);
extern BOOL      WINAPI     NmDbgDeregisterCtl(HWND hwnd);
extern BOOL      WINAPI     NmDbgSetLoggingOptions(HWND hwnd, UINT uOptions);
extern void      WINAPI     NmDbgFlushFileLog();
extern BOOL      WINAPI     NmDbgGetAllZoneParams(PDBGZONEINFO *plpZoneParam, UINT * puCnt);
extern BOOL      WINAPI     NmDbgFreeZoneParams(PDBGZONEINFO pZoneParam);

extern HDBGZONE  WINAPI     NmDbgCreateZone(LPSTR pszName);
extern VOID      WINAPI     NmDbgDeleteZone(LPSTR pszName, HDBGZONE hDbgZone);
extern BOOL      WINAPI     NmDbgSetZone(HDBGZONE hDbgZone,PDBGZONEINFO pZoneParam);
extern PNMDBG    WINAPI     GetPNmDbg(void);
extern VOID      WINAPI     NmDbgSetZoneFileName(HDBGZONE hDbgZone, LPCSTR pszFile);

extern PZONEINFO NMINTERNAL FindZoneForModule(LPCSTR pszModule);
extern PZONEINFO NMINTERNAL AllocZoneForModule(LPCSTR pszModule);
extern PZONEINFO NMINTERNAL MapDebugZoneArea(void);
extern VOID      NMINTERNAL UnMapDebugZoneArea(void);

extern VOID      NMINTERNAL InitDbgZone(void);
extern VOID      NMINTERNAL DeInitDbgZone(void);
extern VOID      NMINTERNAL SetDbgFlags(void);



// Special reserved strings
#define SZ_DBG_MAPPED_ZONE TEXT("_NmDebugZoneMap")
#define SZ_DBG_FILE_MUTEX  TEXT("_NmDbgFileMutex")
#define SZ_DBG_ZONE_MUTEX  TEXT("_NmDbgZoneMutex")


#define GETZONEMASK(z)  ((z) ? (((PZONEINFO)(z))->ulZoneMask) : 0 )
#define IS_ZONE_ENABLED(z, f) ((((PZONEINFO)(z))->ulZoneMask) & (f))

// Macro to check if zone is enabled:  h = ghZone,  i = zone index
#define F_ZONE_ENABLED(h, i)  ((NULL != h) && IS_ZONE_ENABLED(h, (1 << i)))


// Standard Zones
#define ZONE_WARNING           0
#define ZONE_TRACE             1
#define ZONE_FUNCTION          2

#define ZONE_WARNING_FLAG   0x01
#define ZONE_TRACE_FLAG     0x02
#define ZONE_FUNCTION_FLAG  0x04


////////////////////////////////////////////
// Functions
VOID WINAPI     DbgPrintf(PCSTR pszPrefix, PCSTR pszFormat, va_list ap);
PSTR WINAPI     DbgZPrintf(HDBGZONE hZone, UINT iZone, PSTR pszFormat,...);
PSTR WINAPI     DbgZVPrintf(HDBGZONE hZone, UINT iZone, PSTR pszFormat, va_list ap);

VOID NMINTERNAL DbgInitEx(HDBGZONE * phDbgZone, PCHAR * psz, UINT cZone, long ulZoneDefault);
VOID NMINTERNAL DbgDeInit(HDBGZONE * phDbgZone);

INLINE VOID DbgInit(HDBGZONE * phDbgZone, PCHAR * psz, UINT cZones)
{
	DbgInitEx(phDbgZone, psz, cZones, 0);
}

PSTR PszPrintf(PCSTR pszFormat,...);

#endif /* NM_DEBUG */


////////////////////////////////////////////
// Main Macros
#ifdef DEBUG
#define DBGINIT(phZone, psz)  DbgInit(phZone, psz, (sizeof(psz)/sizeof(PCHAR))-1)
#define DBGDEINIT(phZone)     DbgDeInit(phZone)

#define ASSERT(exp)     (!(exp) ? ERROR_OUT(("ASSERT failed on %s line %u:\n\r"#exp, __FILE__, __LINE__)) : 0)


VOID WINAPI DbgZPrintError(PSTR pszFormat,...);
VOID WINAPI DbgZPrintWarning(PSTR pszFormat,...);
VOID WINAPI DbgZPrintTrace(PSTR pszFormat,...);
VOID WINAPI DbgZPrintFunction(PSTR pszFormat,...);

#define ERROR_OUT(s)   DbgZPrintError s
#define WARNING_OUT(s) DbgZPrintWarning s
#define TRACE_OUT(s)   DbgZPrintTrace s

#define DBGENTRY(s)        DbgZPrintFunction("Enter " #s);
#define DBGEXIT(s)         DbgZPrintFunction("Exit  " #s);
#define DBGEXIT_HR(s,hr)   DbgZPrintFunction("Exit  " #s "  (result=%s)", GetHRESULTString(hr));
#define DBGEXIT_BOOL(s,f)  DbgZPrintFunction("Exit  " #s "  (result=%s)", GetBOOLString(f));
#define DBGEXIT_INT(s,i)   DbgZPrintFunction("Exit  " #s "  (result=%s)", GetINTString(i));
#define DBGEXIT_ULONG(s,u) DbgZPrintFunction("Exit  " #s "  (result=%s)", GetULONGString((ULONG)u));


#define DBGMSG(z, i, s)                                             \
   {                                                                \
      if ((NULL != z) && (((PZONEINFO)(z))->ulZoneMask & (1<<i)) )  \
      {                                                             \
         LocalFree(DbgZPrintf(z, i, PszPrintf s));                  \
      }                                                             \
   }
// e.g. DBGMSG(ghZone, ZONE_FOO, ("bar=%d", dwBar))

#else
#define DBGINIT(phZone, psz)
#define DBGDEINIT(phZone)
#define ASSERT(exp)

#define ERROR_OUT(s)
#define WARNING_OUT(s)
#define TRACE_OUT(s)

#define DBGENTRY(s)
#define DBGEXIT(s)
#define DBGEXIT_HR(s,hr)
#define DBGEXIT_BOOL(s,f)
#define DBGEXIT_INT(s,i)
#define DBGEXIT_ULONG(s,u)

#ifndef DBGMSG
#define DBGMSG(z, f, s)
#endif

#endif /* DEBUG */


#include <poppack.h> /* End byte packing */

#ifdef __cplusplus
}
#endif

#endif /* _CONFDBG_H_ */


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\h\confdir.h ===
/***********************************************************************
//    ConfDir.h
//
//	  Conferencing directory functions
//
//	  Chris Pirich (chrispi) : Created 9-7-95
*/

#ifndef _CONFDIR_H_
#define _CONFDIR_H_

#ifdef __cplusplus
extern "C"
{
#endif /* __cplusplus */

UINT GetConferencingDir(LPTSTR szDir, int cBufSize);
UINT GetFavoritesDir(LPTSTR szDir, int cBufSize);

#ifdef __cplusplus
}
#endif /* __cplusplus */

#endif /* _CONFDIR_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\h\confcli.h ===
// This is the header file that defines the interface to ConfCli.dll
//
//	Created:	ChrisPi	8-29-95
//

#ifndef _CONFCLI_H_
#define _CONFCLI_H_


#include <tchar.h> // for _TEXT()

// Functions:
BOOL WINAPI ConfInitialize();
typedef BOOL (WINAPI *CONFINITIALIZEPROC) ();
#define CONFINITIALIZENAME	("ConfInitialize")

int WINAPI ConfSendMessage(UINT uMsg, LPBYTE lpData, DWORD cbData);
typedef int (WINAPI *CONFSENDMESSAGEPROC) (UINT uMsg, LPBYTE lpData, DWORD cbData);
#define CONFSENDMESSAGENAME	("ConfSendMessage")

#define CONFCLIDLLNAME	(_TEXT("msconf.dll"))

#ifdef __cplusplus
extern "C" 
{
#endif
void WINAPI NewMediaPhone(HWND hwndParent, HINSTANCE hinst,
							PSTR pszCmdLine, int nShowCmd);
typedef VOID (WINAPI *NEWMEDIAPHONEPROC)(HWND, HINSTANCE, PSTR, int);
#define NEWMEDIAPHONENAME	("NewMediaPhone")
#ifdef __cplusplus
}
#endif /* __cplusplus */

// Structs:
#define MAX_DIALINFO_STRING 128

struct DIALINFO
{
	DWORD	dwDialFlags;
	CHAR	szWABKey[MAX_DIALINFO_STRING];
	CHAR	szName[MAX_DIALINFO_STRING];
	CHAR	szAddress[MAX_DIALINFO_STRING];
	CHAR    szConference[MAX_DIALINFO_STRING];
	DWORD	dwTransport;
};

#endif /* _CONFCLI_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\h\compddk.h ===
/**************************************************************************
 *
 *  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
 *  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 *  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
 *  PURPOSE.
 *
 *
 *
 *  Compddk.h - include file for implementing installable compressors
 *
 *  Copyright (c) 1990-1995, Microsoft Corp.  All rights reserved.
 *
 **********************************************************************
 *
 * To register FOURCC's for codec types please obtain a
 * copy of the Multimedia Developer Registration Kit from:
 *
 *  Microsoft Corporation
 *  Multimedia Systems Group
 *  Product Marketing
 *  One Microsoft Way
 *  Redmond, WA 98052-6399
 *
 *
*/

#ifndef _INC_COMPDDK
#define _INC_COMPDDK	50	/* version number */

#ifndef RC_INVOKED
#ifndef _WIN32
#pragma pack(1)         /* Assume byte packing throughout */
#endif
#endif  /* RC_INVOKED */

#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif	/* __cplusplus */

// begin_vfw32

#define ICVERSION       0x0104

DECLARE_HANDLE(HIC);     /* Handle to a Installable Compressor */

//
// this code in biCompression means the DIB must be accesed via
// 48 bit pointers! using *ONLY* the selector given.
//
#define BI_1632  0x32333631     // '1632'

#ifndef mmioFOURCC
#define mmioFOURCC( ch0, ch1, ch2, ch3 )				\
		( (DWORD)(BYTE)(ch0) | ( (DWORD)(BYTE)(ch1) << 8 ) |	\
		( (DWORD)(BYTE)(ch2) << 16 ) | ( (DWORD)(BYTE)(ch3) << 24 ) )
#endif

#ifndef aviTWOCC
#define aviTWOCC(ch0, ch1) ((WORD)(BYTE)(ch0) | ((WORD)(BYTE)(ch1) << 8))
#endif

#ifndef ICTYPE_VIDEO
#define ICTYPE_VIDEO    mmioFOURCC('v', 'i', 'd', 'c')
#define ICTYPE_AUDIO    mmioFOURCC('a', 'u', 'd', 'c')
#endif

#ifndef ICERR_OK
#define ICERR_OK                0L
#define ICERR_DONTDRAW          1L
#define ICERR_NEWPALETTE        2L
#define ICERR_GOTOKEYFRAME	3L
#define ICERR_STOPDRAWING 	4L

#define ICERR_UNSUPPORTED      -1L
#define ICERR_BADFORMAT        -2L
#define ICERR_MEMORY           -3L
#define ICERR_INTERNAL         -4L
#define ICERR_BADFLAGS         -5L
#define ICERR_BADPARAM         -6L
#define ICERR_BADSIZE          -7L
#define ICERR_BADHANDLE        -8L
#define ICERR_CANTUPDATE       -9L
#define ICERR_ABORT	       -10L
#define ICERR_ERROR            -100L
#define ICERR_BADBITDEPTH      -200L
#define ICERR_BADIMAGESIZE     -201L

#define ICERR_CUSTOM           -400L    // errors less than ICERR_CUSTOM...
#endif

/* Values for dwFlags of ICOpen() */
#ifndef ICMODE_COMPRESS
#define ICMODE_COMPRESS		1
#define ICMODE_DECOMPRESS	2
#define ICMODE_FASTDECOMPRESS   3
#define ICMODE_QUERY            4
#define ICMODE_FASTCOMPRESS     5
#define ICMODE_DRAW             8
#endif
#ifndef _WIN32					// ;Internal
#define ICMODE_INTERNALF_FUNCTION32	0x8000	// ;Internal
#define ICMODE_INTERNALF_MASK		0x8000	// ;Internal
#endif						// ;Internal

/* Flags for AVI file index */
#define AVIIF_LIST	0x00000001L
#define AVIIF_TWOCC	0x00000002L
#define AVIIF_KEYFRAME	0x00000010L

/* quality flags */
#define ICQUALITY_LOW       0
#define ICQUALITY_HIGH      10000
#define ICQUALITY_DEFAULT   -1

/************************************************************************
************************************************************************/

#define ICM_USER          (DRV_USER+0x0000)

#define ICM_RESERVED      ICM_RESERVED_LOW
#define ICM_RESERVED_LOW  (DRV_USER+0x1000)
#define ICM_RESERVED_HIGH (DRV_USER+0x2000)

/************************************************************************

    messages.

************************************************************************/

#define ICM_GETSTATE                (ICM_RESERVED+0)    // Get compressor state
#define ICM_SETSTATE                (ICM_RESERVED+1)    // Set compressor state
#define ICM_GETINFO                 (ICM_RESERVED+2)    // Query info about the compressor

#define ICM_CONFIGURE               (ICM_RESERVED+10)   // show the configure dialog
#define ICM_ABOUT                   (ICM_RESERVED+11)   // show the about box

#define ICM_GETERRORTEXT            (ICM_RESERVED+12)   // get error text TBD ;Internal
#define ICM_GETFORMATNAME	    (ICM_RESERVED+20)	// get a name for a format ;Internal
#define ICM_ENUMFORMATS		    (ICM_RESERVED+21)	// cycle through formats ;Internal

#define ICM_GETDEFAULTQUALITY       (ICM_RESERVED+30)   // get the default value for quality
#define ICM_GETQUALITY              (ICM_RESERVED+31)   // get the current value for quality
#define ICM_SETQUALITY              (ICM_RESERVED+32)   // set the default value for quality

#define ICM_SET			    (ICM_RESERVED+40)	// Tell the driver something
#define ICM_GET			    (ICM_RESERVED+41)	// Ask the driver something

// Constants for ICM_SET:
#define ICM_FRAMERATE       mmioFOURCC('F','r','m','R')
#define ICM_KEYFRAMERATE    mmioFOURCC('K','e','y','R')

/************************************************************************

    ICM specific messages.

************************************************************************/

#define ICM_COMPRESS_GET_FORMAT     (ICM_USER+4)    // get compress format or size
#define ICM_COMPRESS_GET_SIZE       (ICM_USER+5)    // get output size
#define ICM_COMPRESS_QUERY          (ICM_USER+6)    // query support for compress
#define ICM_COMPRESS_BEGIN          (ICM_USER+7)    // begin a series of compress calls.
#define ICM_COMPRESS                (ICM_USER+8)    // compress a frame
#define ICM_COMPRESS_END            (ICM_USER+9)    // end of a series of compress calls.

#define ICM_DECOMPRESS_GET_FORMAT   (ICM_USER+10)   // get decompress format or size
#define ICM_DECOMPRESS_QUERY        (ICM_USER+11)   // query support for dempress
#define ICM_DECOMPRESS_BEGIN        (ICM_USER+12)   // start a series of decompress calls
#define ICM_DECOMPRESS              (ICM_USER+13)   // decompress a frame
#define ICM_DECOMPRESS_END          (ICM_USER+14)   // end a series of decompress calls
#define ICM_DECOMPRESS_SET_PALETTE  (ICM_USER+29)   // fill in the DIB color table
#define ICM_DECOMPRESS_GET_PALETTE  (ICM_USER+30)   // fill in the DIB color table

#define ICM_DRAW_QUERY              (ICM_USER+31)   // query support for dempress
#define ICM_DRAW_BEGIN              (ICM_USER+15)   // start a series of draw calls
#define ICM_DRAW_GET_PALETTE        (ICM_USER+16)   // get the palette needed for drawing
#define ICM_DRAW_UPDATE             (ICM_USER+17)   // update screen with current frame ;Internal
#define ICM_DRAW_START              (ICM_USER+18)   // start decompress clock
#define ICM_DRAW_STOP               (ICM_USER+19)   // stop decompress clock
#define ICM_DRAW_BITS               (ICM_USER+20)   // decompress a frame to screen ;Internal
#define ICM_DRAW_END                (ICM_USER+21)   // end a series of draw calls
#define ICM_DRAW_GETTIME            (ICM_USER+32)   // get value of decompress clock
#define ICM_DRAW                    (ICM_USER+33)   // generalized "render" message
#define ICM_DRAW_WINDOW             (ICM_USER+34)   // drawing window has moved or hidden
#define ICM_DRAW_SETTIME            (ICM_USER+35)   // set correct value for decompress clock
#define ICM_DRAW_REALIZE            (ICM_USER+36)   // realize palette for drawing
#define ICM_DRAW_FLUSH	            (ICM_USER+37)   // clear out buffered frames
#define ICM_DRAW_RENDERBUFFER       (ICM_USER+38)   // draw undrawn things in queue

#define ICM_DRAW_START_PLAY         (ICM_USER+39)   // start of a play
#define ICM_DRAW_STOP_PLAY          (ICM_USER+40)   // end of a play

#define ICM_DRAW_SUGGESTFORMAT      (ICM_USER+50)   // Like ICGetDisplayFormat
#define ICM_DRAW_CHANGEPALETTE      (ICM_USER+51)   // for animating palette

#define ICM_DRAW_IDLE               (ICM_USER+52)   // send each frame time ;Internal

#define ICM_GETBUFFERSWANTED        (ICM_USER+41)   // ask about prebuffering

#define ICM_GETDEFAULTKEYFRAMERATE  (ICM_USER+42)   // get the default value for key frames


#define ICM_DECOMPRESSEX_BEGIN      (ICM_USER+60)   // start a series of decompress calls
#define ICM_DECOMPRESSEX_QUERY      (ICM_USER+61)   // start a series of decompress calls
#define ICM_DECOMPRESSEX            (ICM_USER+62)   // decompress a frame
#define ICM_DECOMPRESSEX_END        (ICM_USER+63)   // end a series of decompress calls

#define ICM_COMPRESS_FRAMES_INFO    (ICM_USER+70)   // tell about compress to come
#define ICM_COMPRESS_FRAMES         (ICM_USER+71)   // compress a bunch of frames ;Internal
#define ICM_SET_STATUS_PROC	        (ICM_USER+72)   // set status callback

/************************************************************************
************************************************************************/

typedef struct {
    DWORD               dwSize;         // sizeof(ICOPEN)
    DWORD               fccType;        // 'vidc'
    DWORD               fccHandler;     //
    DWORD               dwVersion;      // version of compman opening you
    DWORD               dwFlags;        // LOWORD is type specific
    LRESULT             dwError;        // error return.
    LPVOID              pV1Reserved;    // Reserved
    LPVOID              pV2Reserved;    // Reserved
    DWORD               dnDevNode;      // Devnode for PnP devices
} ICOPEN;

/************************************************************************
************************************************************************/

typedef struct {
    DWORD   dwSize;                 // sizeof(ICINFO)
    DWORD   fccType;                // compressor type     'vidc' 'audc'
    DWORD   fccHandler;             // compressor sub-type 'rle ' 'jpeg' 'pcm '
    DWORD   dwFlags;                // flags LOWORD is type specific
    DWORD   dwVersion;              // version of the driver
    DWORD   dwVersionICM;           // version of the ICM used
// end_vfw32
#ifdef _WIN32
// begin_vfw32
    //
    // under Win32, the driver always returns UNICODE strings.
    //
    WCHAR   szName[16];             // short name
    WCHAR   szDescription[128];     // long name
    WCHAR   szDriver[128];          // driver that contains compressor
// end_vfw32
#else
    char    szName[16];             // short name
    char    szDescription[128];     // long name
    char    szDriver[128];          // driver that contains compressor
#endif
// begin_vfw32
}   ICINFO;

/* Flags for the <dwFlags> field of the <ICINFO> structure. */
#define VIDCF_QUALITY        0x0001  // supports quality
#define VIDCF_CRUNCH         0x0002  // supports crunching to a frame size
#define VIDCF_TEMPORAL       0x0004  // supports inter-frame compress
#define VIDCF_COMPRESSFRAMES 0x0008  // wants the compress all frames message
#define VIDCF_DRAW           0x0010  // supports drawing
#define VIDCF_FASTTEMPORALC  0x0020  // does not need prev frame on compress
#define VIDCF_FASTTEMPORALD  0x0080  // does not need prev frame on decompress
//#define VIDCF_QUALITYTIME    0x0040  // supports temporal quality

//#define VIDCF_FASTTEMPORAL   (VIDCF_FASTTEMPORALC|VIDCF_FASTTEMPORALD)

/************************************************************************
************************************************************************/

#define ICCOMPRESS_KEYFRAME	0x00000001L

typedef struct {
    DWORD               dwFlags;        // flags

    LPBITMAPINFOHEADER  lpbiOutput;     // output format
    LPVOID              lpOutput;       // output data

    LPBITMAPINFOHEADER  lpbiInput;      // format of frame to compress
    LPVOID              lpInput;        // frame data to compress

    LPDWORD             lpckid;         // ckid for data in AVI file
    LPDWORD             lpdwFlags;      // flags in the AVI index.
    LONG                lFrameNum;      // frame number of seq.
    DWORD               dwFrameSize;    // reqested size in bytes. (if non zero)

    DWORD               dwQuality;      // quality

    // these are new fields
    LPBITMAPINFOHEADER  lpbiPrev;       // format of previous frame
    LPVOID              lpPrev;         // previous frame

} ICCOMPRESS;

/************************************************************************
************************************************************************/

#define ICCOMPRESSFRAMES_PADDING	0x00000001

typedef struct {
    DWORD               dwFlags;        // flags

    LPBITMAPINFOHEADER  lpbiOutput;     // output format
    LPARAM              lOutput;        // output identifier

    LPBITMAPINFOHEADER  lpbiInput;      // format of frame to compress
    LPARAM              lInput;         // input identifier

    LONG                lStartFrame;    // start frame
    LONG                lFrameCount;    // # of frames

    LONG                lQuality;       // quality
    LONG                lDataRate;      // data rate
    LONG                lKeyRate;       // key frame rate

    DWORD		dwRate;		// frame rate, as always
    DWORD		dwScale;

    DWORD		dwOverheadPerFrame;
    DWORD		dwReserved2;

    LONG (CALLBACK *GetData)(LPARAM lInput, LONG lFrame, LPVOID lpBits, LONG len);
    LONG (CALLBACK *PutData)(LPARAM lOutput, LONG lFrame, LPVOID lpBits, LONG len);
} ICCOMPRESSFRAMES;

typedef struct {
    DWORD		dwFlags;
    LPARAM		lParam;

    // messages for Status callback
    #define ICSTATUS_START	    0
    #define ICSTATUS_STATUS	    1	    // l == % done
    #define ICSTATUS_END	    2
    #define ICSTATUS_ERROR	    3	    // l == error string (LPSTR)
    #define ICSTATUS_YIELD	    4
    // return nonzero means abort operation in progress

    LONG (CALLBACK *Status) (LPARAM lParam, UINT message, LONG l);
} ICSETSTATUSPROC;

/************************************************************************
************************************************************************/

#define ICDECOMPRESS_HURRYUP      0x80000000L   // don't draw just buffer (hurry up!)
#define ICDECOMPRESS_UPDATE       0x40000000L   // don't draw just update screen
#define ICDECOMPRESS_PREROLL      0x20000000L   // this frame is before real start
#define ICDECOMPRESS_NULLFRAME    0x10000000L   // repeat last frame
#define ICDECOMPRESS_NOTKEYFRAME  0x08000000L   // this frame is not a key frame

typedef struct {
    DWORD               dwFlags;    // flags (from AVI index...)

    LPBITMAPINFOHEADER  lpbiInput;  // BITMAPINFO of compressed data
                                    // biSizeImage has the chunk size
    LPVOID              lpInput;    // compressed data

    LPBITMAPINFOHEADER  lpbiOutput; // DIB to decompress to
    LPVOID              lpOutput;
    DWORD		ckid;	    // ckid from AVI file
} ICDECOMPRESS;

typedef struct {
    //
    // same as ICM_DECOMPRESS
    //
    DWORD               dwFlags;

    LPBITMAPINFOHEADER  lpbiSrc;    // BITMAPINFO of compressed data
    LPVOID              lpSrc;      // compressed data

    LPBITMAPINFOHEADER  lpbiDst;    // DIB to decompress to
    LPVOID              lpDst;      // output data

    //
    // new for ICM_DECOMPRESSEX
    //
    int                 xDst;       // destination rectangle
    int                 yDst;
    int                 dxDst;
    int                 dyDst;

    int                 xSrc;       // source rectangle
    int                 ySrc;
    int                 dxSrc;
    int                 dySrc;

} ICDECOMPRESSEX;

/************************************************************************
************************************************************************/

#define ICDRAW_QUERY        0x00000001L   // test for support
#define ICDRAW_FULLSCREEN   0x00000002L   // draw to full screen
#define ICDRAW_HDC          0x00000004L   // draw to a HDC/HWND
#define ICDRAW_ANIMATE	    0x00000008L	  // expect palette animation
#define ICDRAW_CONTINUE	    0x00000010L	  // draw is a continuation of previous draw
#define ICDRAW_MEMORYDC	    0x00000020L	  // DC is offscreen, by the way
#define ICDRAW_UPDATING	    0x00000040L	  // We're updating, as opposed to playing
#define ICDRAW_RENDER       0x00000080L   // used to render data not draw it
#define ICDRAW_BUFFER       0x00000100L   // please buffer this data offscreen, we will need to update it

typedef struct {
    DWORD               dwFlags;        // flags

    HPALETTE            hpal;           // palette to draw with
    HWND                hwnd;           // window to draw to
    HDC                 hdc;            // HDC to draw to

    int                 xDst;           // destination rectangle
    int                 yDst;
    int                 dxDst;
    int                 dyDst;

    LPBITMAPINFOHEADER  lpbi;           // format of frame to draw

    int                 xSrc;           // source rectangle
    int                 ySrc;
    int                 dxSrc;
    int                 dySrc;

    DWORD               dwRate;         // frames/second = (dwRate/dwScale)
    DWORD               dwScale;

} ICDRAWBEGIN;

/************************************************************************
************************************************************************/

#define ICDRAW_HURRYUP      0x80000000L   // don't draw just buffer (hurry up!)
#define ICDRAW_UPDATE       0x40000000L   // don't draw just update screen
#define ICDRAW_PREROLL	    0x20000000L	  // this frame is before real start
#define ICDRAW_NULLFRAME    0x10000000L	  // repeat last frame
#define ICDRAW_NOTKEYFRAME  0x08000000L   // this frame is not a key frame

typedef struct {
    DWORD               dwFlags;        // flags
    LPVOID		lpFormat;       // format of frame to decompress
    LPVOID              lpData;         // frame data to decompress
    DWORD               cbData;
    LONG                lTime;          // time in drawbegin units (see dwRate and dwScale)
} ICDRAW;

typedef struct {
    LPBITMAPINFOHEADER	lpbiIn;		// format to be drawn
    LPBITMAPINFOHEADER	lpbiSuggest;	// location for suggested format (or NULL to get size)
    int			dxSrc;		// source extent or 0
    int			dySrc;
    int			dxDst;		// dest extent or 0
    int			dyDst;
    HIC			hicDecompressor;// decompressor you can talk to
} ICDRAWSUGGEST;

/************************************************************************
************************************************************************/

typedef struct {
    DWORD               dwFlags;    // flags (from AVI index...)
    int                 iStart;     // first palette to change
    int                 iLen;       // count of entries to change.
    LPPALETTEENTRY      lppe;       // palette
} ICPALETTE;

// end_vfw32

#ifndef RC_INVOKED
#ifndef _WIN32
#pragma pack()          /* Revert to default packing */
#endif
#endif  /* RC_INVOKED */

#ifdef __cplusplus
}                       /* End of extern "C" { */
#endif	/* __cplusplus */

#endif  /* _INC_COMPDDK */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\h\confwiz.h ===
// This is the header file for conference wizards in conf.exe
//
//	Created:	ClausGi	8-30-95
//


// Data structure for NewConnectorWizard call

typedef struct _NewConnectorWizardStruct {

	// The following path describes the folder that the wizard
	// is invoked in. This is used to determine where the speed-dial
	// object is created.

	char szPathOfInvocation[MAX_PATH];

} NCW, FAR * LPNCW;


// Functions:
BOOL WINAPI NewConferenceWizard ( HINSTANCE hInst, HWND hWnd );
BOOL WINAPI NewConnectorWizard ( HINSTANCE hInst, HWND hWnd, LPNCW lpncw );

/* Constants - BUGBUG move this to wizglob.h */

#define	NUM_PAGES	4
#define	_MAX_TEXT	512

// BUGBUG review all of these
#define	MAX_CONF_PASSWORD	12
#define	MAX_CONF_NAME		256
#define	MAX_SERVER_NAME		256
#define	MAX_WAB_TAG			256

#define	CONF_TYPE_PRIVATE	0
#define	CONF_TYPE_JOINABLE	1


/* Data Structures private to the wizard code */

typedef struct _ConfInfo {
	char szConfName[MAX_CONF_NAME+1];
	char szPwd[MAX_CONF_PASSWORD+1];
	WORD wConfType;
	WORD cMembers;
	HWND hwndMemberList;
	DWORD dwDuration;
	// Addl info TBD;
} CI, FAR * LPCI;

typedef struct _ConnectInfo {
	char szTargetName[MAX_WAB_TAG];
	char szAddress[MAX_PATH]; // BUGBUG proper limit needed
	DWORD dwAddrType;
	int idPreferredTransport;
	BOOL fSingleAddress;
	// Addl info TBD;
} CN, FAR * LPCN;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\h\cpnmctl1.h ===
//////////////////////////////////////////////////////////////////////////////
// CProxyINmAppletNotify
template <class T>
class CProxyINmAppletNotify : public IConnectionPointImpl<T, &IID_INmAppletNotify, CComDynamicUnkArray>
{
public:

//INmAppletNotify
public:
	HRESULT Fire_OnStateChanged(
		int State)
	{
		T* pT = (T*)this;
		pT->Lock();
		HRESULT ret;
		IUnknown** pp = m_vec.begin();
		while (pp < m_vec.end())
		{
			if (*pp != NULL)
			{
				INmAppletNotify* pINmAppletNotify = reinterpret_cast<INmAppletNotify*>(*pp);
				ret = pINmAppletNotify->OnStateChanged(State);
			}
			pp++;
		}
		pT->Unlock();
		return ret;
	}
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\h\dcap.h ===
//  DCAP.H
//
//  Created 31-Jul-96 [JonT]

#ifndef _DCAP_H
#define _DCAP_H

#pragma pack(1)         /* Assume byte packing throughout */

#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif	/* __cplusplus */

// API defines. These allow optimized DLL import code generation
#ifdef __DCAP_BUILD__
#define DCAPI WINAPI
#else
#define DCAPI __declspec(dllimport) __stdcall
#endif

// Equates
#define MAX_CAPDEV_NAME                 MAX_PATH
#define MAX_CAPDEV_DESCRIPTION          MAX_PATH
#define MAX_CAPDEV_VERSION              80
#define MIN_STREAMING_CAPTURE_BUFFERS   2

// Equates for "InitializeStreaming" flags
#define STREAMING_PREFER_STREAMING      0x0
#define STREAMING_PREFER_FRAME_GRAB     0x1

// CaptureDeviceDialog flags
#define CAPDEV_DIALOG_QUERY     1       // Queries if the dialog exists
#define CAPDEV_DIALOG_IMAGE     0       // (default and mutually exclusive with
#define CAPDEV_DIALOG_SOURCE    2       //  CAPDEV_DIALOG_SOURCE)

// Errors
#define DCAP_ERRORBIT           0x20000000
#define ERROR_DCAP_DEVICE_IN_USE        (DCAP_ERRORBIT | 0x0001)
#define ERROR_DCAP_BAD_INSTALL          (DCAP_ERRORBIT | 0x0002)
#define ERROR_DCAP_NONSPECIFIC          (DCAP_ERRORBIT | 0x0003)
#define ERROR_DCAP_NO_DRIVER_SUPPORT    (DCAP_ERRORBIT | 0x0004)
#define ERROR_DCAP_NOT_WHILE_STREAMING  (DCAP_ERRORBIT | 0x0005)
#define ERROR_DCAP_FORMAT_NOT_SUPPORTED (DCAP_ERRORBIT | 0x0006)
#define ERROR_DCAP_BAD_FRAMERATE        (DCAP_ERRORBIT | 0x0007)
#define ERROR_DCAP_BAD_PARAM            (DCAP_ERRORBIT | 0x0008)
#define ERROR_DCAP_DIALOG_FORMAT        (DCAP_ERRORBIT | 0x0009)   // can't reset format changes caused by dialog
#define ERROR_DCAP_DIALOG_STREAM        (DCAP_ERRORBIT | 0x000A)   // can't re-establish stream after dialog

// Structures

#ifndef __DCAP_BUILD__
typedef HANDLE HCAPDEV;
typedef HANDLE HFRAMEBUF;
#endif

typedef struct _FINDCAPTUREDEVICE
{
    DWORD dwSize;
    int nDeviceIndex;
    char szDeviceName[MAX_CAPDEV_NAME];
    char szDeviceDescription[MAX_CAPDEV_DESCRIPTION];
    char szDeviceVersion[MAX_CAPDEV_VERSION];
} FINDCAPTUREDEVICE;

typedef struct _CAPSTREAM
{
    DWORD dwSize;
    int nFPSx100;
    int ncCapBuffers;
    HANDLE hevWait;
} CAPSTREAM;

typedef struct _CAPTUREPALETTE
{
    WORD wVersion;
    WORD wcEntries;
    PALETTEENTRY pe[256];
} CAPTUREPALETTE, FAR* LPCAPTUREPALETTE;

typedef struct _CAPFRAMEINFO
{
    LPSTR lpData;
    DWORD dwcbData;
    DWORD dwTimestamp;
    DWORD dwFlags;
} CAPFRAMEINFO;

// Prototypes

int DCAPI       GetNumCaptureDevices();
BOOL DCAPI      FindFirstCaptureDevice(IN OUT FINDCAPTUREDEVICE* lpfcd, char* szDeviceDescription);
BOOL DCAPI      FindFirstCaptureDeviceByIndex(IN OUT FINDCAPTUREDEVICE* lpfcd, int nDeviceIndex);
BOOL DCAPI      FindNextCaptureDevice(IN OUT FINDCAPTUREDEVICE* lpfcd);
HCAPDEV DCAPI   OpenCaptureDevice(int nDeviceIndex);
BOOL DCAPI      CloseCaptureDevice(HCAPDEV hcd);
DWORD DCAPI     GetCaptureDeviceFormatHeaderSize(HCAPDEV hcd);
BOOL DCAPI      GetCaptureDeviceFormat(HCAPDEV hcd, OUT LPBITMAPINFOHEADER lpbmih);
BOOL DCAPI      SetCaptureDeviceFormat(HCAPDEV hcd, IN LPBITMAPINFOHEADER lpbmih,
                                       IN LONG srcwidth, IN LONG srcheight);
BOOL DCAPI      GetCaptureDevicePalette(HCAPDEV hcd, OUT CAPTUREPALETTE* lpcp);
BOOL DCAPI      InitializeStreaming(HCAPDEV hcd, IN OUT CAPSTREAM* lpcs, IN DWORD flags);
BOOL DCAPI      SetStreamFrameRate(HCAPDEV hcd, IN int nFPSx100);
BOOL DCAPI      UninitializeStreaming(HCAPDEV hcd);
BOOL DCAPI      StartStreaming(HCAPDEV hcd);
BOOL DCAPI      StopStreaming(HCAPDEV hcd);
LPSTR DCAPI     GetNextReadyBuffer(HCAPDEV hcd, OUT CAPFRAMEINFO* lpcfi);
BOOL DCAPI      PutBufferIntoStream(HCAPDEV hcd, IN BYTE* lpBits);
BOOL DCAPI      CaptureDeviceDialog(HCAPDEV hcd, HWND hwndParent, DWORD dwFlags,
                                    IN LPBITMAPINFOHEADER lpbmih);
LPBYTE DCAPI    CaptureFrame(HCAPDEV hcd, IN HFRAMEBUF hbuf);
HFRAMEBUF DCAPI AllocFrameBuffer(HCAPDEV hcd);
VOID DCAPI      FreeFrameBuffer(HCAPDEV hcd, IN HFRAMEBUF hbuf);

LPBYTE DCAPI    GetFrameBufferPtr(HCAPDEV hcd, IN HFRAMEBUF hbuf);

DWORD DCAPI     DCAPGetThreadExecutionTimeService(HANDLE R0ThreadID );
HANDLE DCAPI     DCAPGetR0ThreadHandle(void);


#ifdef __cplusplus
}                       /* End of extern "C" { */
#endif	/* __cplusplus */

#pragma pack()          /* Revert to default packing */

#endif // #ifndef _DCAP_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\h\cpappletnotify.h ===
#ifndef __CPAppletNotify_h__
#define __CPAppletNotify_h__

#include "CPnmctl1.h"


#endif // __CPAppletNotify_h__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\h\confreg.h ===
#ifndef _CONFREG_H_
#define _CONFREG_H_

#include <nmutil.h>

// General Reg Keys
#define REGVAL_WINDOW_XPOS		TEXT("WindowX")
#define REGVAL_WINDOW_YPOS		TEXT("WindowY")
#define REGVAL_WINDOW_WIDTH		TEXT("WindowWidth")
#define REGVAL_WINDOW_HEIGHT	TEXT("WindowHeight")



	// This is all that is left of Restricted ULS... we always
	// log in as BUSINESS uls type from now on....
#define RESTRICTED_ULS_BUSINESS 2

// Registry path of conference settings under HKEY_LOCAL_MACHINE or
// HKEY_CURRENT_USER.

#define	CONFERENCING_KEY TEXT("SOFTWARE\\Microsoft\\Conferencing")

// Value for disabling pluggable UI
#define REGVAL_DISABLE_PLUGGABLE_UI     TEXT("NoMUI")

// Value for forcing the wizard to run
#define REGVAL_WIZARD_VERSION_UI	TEXT("WizardUI")
#define REGVAL_WIZARD_VERSION_NOUI	TEXT("WizardNoUI")

#define REGVAL_GK_SERVER        TEXT("Gatekeeper")
#define REGVAL_GK_ALIAS         TEXT("GatekeeperAlias")

// Gatekeeper uses phonenum or e-mail to place calls?
#define REGVAL_GK_METHOD			TEXT("GateKeeperAddressing")
#define GK_LOGON_USING_PHONENUM				1
#define GK_LOGON_USING_ACCOUNT				2
#define GK_LOGON_USING_BOTH					3

// Direct is all non-gatekeeper modes ( ils, uls, gateway, machine name, etc. )	
#define REGVAL_CALLING_MODE		TEXT("CallingMethod")
#define CALLING_MODE_DIRECT				0
#define CALLING_MODE_GATEKEEPER			1

// Key and value for finding IE's default search page
#define IE_MAIN_KEY				TEXT("SOFTWARE\\Microsoft\\Internet Explorer\\Main")
#define REGVAL_IE_SEARCH_PAGE	TEXT("Search Page")
#define REGVAL_IE_START_PAGE    TEXT("Start Page")

#define REGVAL_IE_CLIENTS_MAIL  TEXT("SOFTWARE\\Clients\\mail")
#define REGVAL_IE_CLIENTS_NEWS  TEXT("SOFTWARE\\Clients\\news")

// The shell folders key is useful for finding the Favorites
// folder.  It is stored under HKEY_CURRENT_USER.
#define SHELL_FOLDERS_KEY TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Shell Folders")

// The TCPIP Params key possibly contains the local hostname.
// It is stored under HKEY_LOCAL_MACHINE (Win95 only).
#define TCPIP_PARAMS_W95_KEY TEXT("System\\CurrentControlSet\\Services\\VxD\\MSTCP")
#define TCPIP_PARAMS_NT_KEY TEXT("System\\CurrentControlSet\\Services\\Tcpip\\Parameters")

// Hostname contains the TCP/IP hostname - if it is not present,
// then use GetComputerName()
#define	REGVAL_TCPIP_HOSTNAME	TEXT("Hostname")

// The shell open key for http (present if we can ShellExecute() http URL's).
// It is stored under HKEY_LOCAL_MACHINE.
#define CLASSES_HTTP_KEY TEXT("SOFTWARE\\Classes\\http\\shell\\open\\command")

// The shell open key for mailto (present if we can ShellExecute() mailto URL's).
// It is stored under HKEY_LOCAL_MACHINE.
#define CLASSES_MAILTO_KEY TEXT("SOFTWARE\\Classes\\mailto\\shell\\open\\command")

// The Windows CurrentVersion key is used for obtaining the name that was
// was specified while installing Windows.  It is stored under HKEY_LOCAL_MACHINE:
#define WINDOWS_CUR_VER_KEY TEXT("SOFTWARE\\Microsoft\\Windows\\CurrentVersion")

// This is the string value that contains the registered owner name.
// It is stored in the WINDOW_CUR_VER_KEY
#define REGVAL_REGISTERED_OWNER				TEXT("RegisteredOwner")

// 1: join conference without prompt 0: don't
#define	REGVAL_AUTO_ACCEPT					TEXT("AutoAccept")
#define	AUTO_ACCEPT_DEFAULT					0

// n: set comm port wait seconds
#define	REGVAL_N_WAITSECS					TEXT("nWaitSeconds")
#define	N_WAITSECS_DEFAULT					60

// DCB default structure
#define REGVAL_DCB							TEXT("DCB")

// Taskbar icon settings, one of								(HKCU)
#define	REGVAL_TASKBAR_ICON		TEXT("Taskbar Icon")
#define	TASKBARICON_NEVER	    0
#define	TASKBARICON_ALWAYS	    1
#define	TASKBARICON_DEFAULT	    TASKBARICON_ALWAYS

// Controls if node controller is always running 1:yes 0:no		(HKCU)
#define	REGVAL_CONF_ALWAYS_RUNNING			TEXT("Run Always")
#define	ALWAYS_RUNNING_DEFAULT				0

// The Run key is used for forcing windows to run our program in the background
// at startup.  It is stored under HKEY_CURRENT_USER
#define WINDOWS_RUN_KEY TEXT("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Run")

// This is the name of the string value that we place under the Run key
#define REGVAL_RUN_TASKNAME					TEXT("Microsoft NetMeeting")


/////////// File Transfer registry keys and values (HKCU) /////////////

#define	FILEXFER_KEY TEXT("SOFTWARE\\Microsoft\\Conferencing\\File Transfer")

// Path for transferred files
#define	REGVAL_FILEXFER_PATH				TEXT("Receive Directory")

// File Transfer Mode (flags)
#define	REGVAL_FILEXFER_MODE				TEXT("FileXferMode")
#define	FT_MODE_ALLOW_T127                  0x01  /* Allow T.127                 */
#define	FT_MODE_T127                        0x04  /* T.127 is loaded (runtime)   */
#define	FT_MODE_SEND                        0x10  /* Allow sending files         */
#define	FT_MODE_RECEIVE                     0x20  /* Allow receiving             */
#define	FT_MODE_DLL                       0x0100  /* FT loads as DLL (set at runtime) */
#define	FT_MODE_FORCE_DLL                 0x0200  /* Force FT_MODE_DLL setting (debug-only) */
#define	FT_MODE_DEFAULT                     (FT_MODE_ALLOW_T127 | FT_MODE_SEND | FT_MODE_RECEIVE)

// After a file is transferred, display a message, etc.
#define	REGVAL_FILEXFER_OPTIONS             TEXT("FileXferOptions")
#define	FT_SHOW_FOLDER                       0x01 /* Show receive folder */
#define	FT_SHOW_MSG_REC                      0x02 /* Show message after receiving */
#define	FT_SHOW_MSG_SENT                     0x04 /* Show message after sending   */
#define	FT_AUTOSTART                         0x10 /* Always start the File Transfer app */
#define	FT_OPTIONS_DEFAULT                   (FT_SHOW_MSG_SENT | FT_SHOW_MSG_REC)

// MBFT (T.127) Timing values
#define REGVAL_FILEXFER_DISBAND             TEXT("Disband")   // 5000
#define REGVAL_FILEXFER_CH_RESPONSE         TEXT("Response")  // 60000
#define REGVAL_FILEXFER_ENDACK              TEXT("EndAck")    // 60000


/////////// 


// 0: logon a ULS server, 1: don't (stored under CONFERENCING_KEY, HKCU)
#define	REGVAL_DONT_LOGON_ULS				TEXT("DontUseULS")
#define	DONT_LOGON_ULS_DEFAULT				0

// installation directory
#define	REGVAL_INSTALL_DIR					TEXT("InstallationDirectory")

// node controller executable name
#define	REGVAL_NC_NAME						TEXT("NodeControllerName")

// speed dial directory
#define	REGVAL_SPEED_DIAL_FOLDER			TEXT("SpeedDialFolder")

// If call security is whatever and available, then these are changeable
#define REGVAL_SECURITY_INCOMING_REQUIRED   TEXT("RequireSecureIncomingCalls")
#define DEFAULT_SECURITY_INCOMING_REQUIRED  0
#define REGVAL_SECURITY_OUTGOING_PREFERRED  TEXT("PreferSecureOutgoingCalls")
#define DEFAULT_SECURITY_OUTGOING_PREFERRED 0


// 0: Use the NetMeeting default cert, 1: don't
#define REGVAL_SECURITY_AUTHENTICATION      TEXT("SecureAuthentication")
#define DEFAULT_SECURITY_AUTHENTICATION     0   

#define REGVAL_CERT_ID						TEXT("NmCertID")

////////// Home Page related values (HKLM) ////////////////////////////

// NOTE: Default stored as IDS_DEFAULT_WEB_PAGE in confroom.rc
#define	REGVAL_HOME_PAGE				TEXT("NetMeeting Home Page")

/////////// User Location Service related keys and values ////////////
////
//// BUGBUG: merge with defs in audio src tree
////
//// All values here are stored under HKEY_CURRENT_USER
////

#define	ISAPI_KEY                   TEXT("Software\\Microsoft\\User Location Service")
#define	REGKEY_USERDETAILS          TEXT("Client")
#define	ISAPI_CLIENT_KEY            TEXT("Software\\Microsoft\\User Location Service\\Client")

#define	REGVAL_SERVERNAME			TEXT("Server Name")
#define REGVAL_ULS_NAME				TEXT("User Name")
#define REGVAL_ULS_FIRST_NAME		TEXT("First Name")
#define REGVAL_ULS_LAST_NAME		TEXT("Last Name")
#define REGVAL_ULS_RES_NAME			TEXT("Resolve Name")
#define REGVAL_ULS_EMAIL_NAME		TEXT("Email Name")
#define REGVAL_ULS_LOCATION_NAME	TEXT("Location")
#define REGVAL_ULS_PHONENUM_NAME	TEXT("Phonenum")
#define REGVAL_ULS_GK_ACCOUNT		TEXT("Account")
#define REGVAL_ULS_COMMENTS_NAME	TEXT("Comments")
#define REGVAL_ULS_DONT_PUBLISH		TEXT("Don't Publish")
#define REGVAL_ULS_DONT_PUBLISH_DEFAULT	0

#define MAX_DCL_NAME_LEN             48 /* REGVAL_ULS_NAME can't be larger than this */

// The following values and keys are per user,
// i.e. under HKEY_CURRENT_USER

/////////// Audio related keys and values ///////////////////////////

#define	AUDIO_KEY	TEXT("SOFTWARE\\Microsoft\\Conferencing\\Audio Control")

#define REGVAL_CODECCHOICE	TEXT("Codec Choice")
//DWORD one of:
#define CODECCHOICE_AUTO			1
#define CODECCHOICE_MANUAL		2

// DWORD One of:
#define	CODECPOWER_MOST			1
#define	CODECPOWER_MODERATE		2
#define	CODECPOWER_SOME			3
#define	CODECPOWER_LEAST		4

#define	REGVAL_FULLDUPLEX	TEXT("Full Duplex")
// DWORD One of:
#define	FULLDUPLEX_ENABLED		1
#define	FULLDUPLEX_DISABLED		0

#define	REGVAL_AUTOGAIN			TEXT("Auto Gain Control")
// DWORD One of:
#define	AUTOGAIN_ENABLED				1
#define	AUTOGAIN_DISABLED			0


#define REGVAL_AUTOMIX		TEXT("Auto Mix")
// DWORD One of:
#define	AUTOMIX_ENABLED	1
#define	AUTOMIX_DISABLED	0

#define REGVAL_DIRECTSOUND	TEXT("Direct Sound")

#define DSOUND_USER_ENABLED  0x0001
#define DSOUND_USER_DISABLED 0x0000


#define	REGVAL_SOUNDCARDCAPS	TEXT("Sound Card Capabilities")
// DWORD a mask of values specified in oprah\h\audiowiz.h

#define REGVAL_WAVEINDEVICEID	TEXT("WaveIn Device ID")
#define REGVAL_WAVEOUTDEVICEID	TEXT("WaveOut Device ID")

#define REGVAL_WAVEINDEVICENAME		TEXT("WaveIn Device Name")
#define REGVAL_WAVEOUTDEVICENAME	TEXT("WaveOut Device Name")

#define REGVAL_SPKMUTE	TEXT("SpeakerMute")
#define REGVAL_RECMUTE	TEXT("RecordMute")


#define REGVAL_TYPICALBANDWIDTH		TEXT("Typical BandWidth")
#define BW_144KBS				1
#define BW_288KBS				2
#define BW_ISDN 				3
#define BW_MOREKBS				4
#define BW_DEFAULT				BW_288KBS




//this is actually the last volume used by conf
#define REGVAL_CALIBRATEDVOL		TEXT("Calibrated Volume")
//at calibration both the lastcalibratedvol and calibrated volume are set to the same
//value
#define REGVAL_LASTCALIBRATEDVOL	TEXT("Last Calibrated Volume")

#define REGVAL_AUTODET_SILENCE	TEXT("Automatic Silence Detection")

#define REGVAL_SPEAKERVOL	TEXT("Speaker Volume")

#define	REGVAL_MICROPHONE_SENSITIVITY	TEXT("Microphone Sensitivity")
#define	MIN_MICROPHONE_SENSITIVITY	0
#define	MAX_MICROPHONE_SENSITIVITY	20
#define	DEFAULT_MICROPHONE_SENSITIVITY	14

#define	REGVAL_MICROPHONE_AUTO			TEXT("Automatic Mic Sensitivity")
#define	MICROPHONE_AUTO_YES				1
#define	MICROPHONE_AUTO_NO				0
#define DEFAULT_MICROPHONE_AUTO			MICROPHONE_AUTO_YES

#define DEFAULT_USE_PROXY				0
#define REGVAL_USE_PROXY				TEXT("Enable Proxy")
#define REGVAL_PROXY					TEXT("Proxy")

#define DEFAULT_USE_H323_GATEWAY		0
#define REGVAL_USE_H323_GATEWAY			TEXT("Enable H.323 Gateway")
#define REGVAL_H323_GATEWAY				TEXT("H.323 Gateway")

#define DEFAULT_POL_NO_WEBDIR			0
#define REGVAL_POL_NO_WEBDIR			TEXT("NoWebDirectory")
#define REGVAL_WEBDIR_URL				TEXT("webDirectory URL")
#define REGVAL_WEBDIR_ILS				TEXT("webDirectory ILS")
#define REGVAL_WEBDIR_DISPLAY_NAME		TEXT("webDirectory Name")

#define REGVAL_POL_NOCHANGECALLMODE     TEXT("NoChangingCallMode")
#define DEFAULT_POL_NOCHANGECALLMODE    0

// from common.h (HKCU)
#define INTERNET_AUDIO_KEY              TEXT("Software\\Microsoft\\Internet Audio")
#define REGVAL_ACMH323ENCODINGS         TEXT("ACMH323Encodings")

// from common.h (HKLM)
#define NACOBJECT_KEY                       TEXT("Software\\Microsoft\\Internet Audio\\NacObject")
#define REGVAL_DISABLE_WINSOCK2             TEXT("DisableWinsock2")


/////////// Video related keys and values ///////////////////////////

#define	VIDEO_KEY	        TEXT("SOFTWARE\\Microsoft\\Conferencing\\Video Control")
#define	VIDEO_LOCAL_KEY	    TEXT("SOFTWARE\\Microsoft\\Conferencing\\Video Control\\Local")
#define	VIDEO_REMOTE_KEY	TEXT("SOFTWARE\\Microsoft\\Conferencing\\Video Control\\Remote")

#define REGVAL_CAPTUREDEVICEID	TEXT("Capture Device ID")
#define REGVAL_CAPTUREDEVICENAME		TEXT("Capture Device Name")
#define	REGVAL_CAPTURECARDCAPS	TEXT("Capture Card Capabilities")

#define REGVAL_VIDEO_ALLOW_SEND             TEXT("AllowSend")
#define REGVAL_VIDEO_ALLOW_RECEIVE          TEXT("AllowReceive")
#define VIDEO_ALLOW_SEND_DEFAULT            1
#define VIDEO_ALLOW_RECEIVE_DEFAULT         1

#define REGVAL_VIDEO_DOCK_EDGE              TEXT("DockEdge")

#define	REGVAL_VIDEO_WINDOW_INIT            TEXT("WindowOnInit")
#define	REGVAL_VIDEO_WINDOW_CONNECT         TEXT("WindowOnConnect")
#define	REGVAL_VIDEO_WINDOW_DISCONNECT      TEXT("WindowOnDisconnect")
//DWORD one of:
#define VIDEO_WINDOW_NOP            0   // Leave window in current state
#define VIDEO_WINDOW_HIDE           1   // Hide window
#define VIDEO_WINDOW_SHOW           2   // Show window
#define VIDEO_WINDOW_PROMPT         3   // Prompt to show/hide window
#define VIDEO_WINDOW_PREV           4   // Restore previous window state

#define VIDEO_LOCAL_INIT_DEFAULT            VIDEO_WINDOW_NOP
#define VIDEO_REMOTE_INIT_DEFAULT           VIDEO_WINDOW_NOP

#define VIDEO_LOCAL_CONNECT_DEFAULT         VIDEO_WINDOW_NOP
#define VIDEO_REMOTE_CONNECT_DEFAULT        VIDEO_WINDOW_NOP

#define VIDEO_LOCAL_DISCONNECT_DEFAULT      VIDEO_WINDOW_NOP
#define VIDEO_REMOTE_DISCONNECT_DEFAULT     VIDEO_WINDOW_NOP

#define	REGVAL_VIDEO_XFER_INIT              TEXT("XferOnInit")
#define	REGVAL_VIDEO_XFER_CONNECT           TEXT("XferOnConnect")
#define	REGVAL_VIDEO_XFER_DISCONNECT        TEXT("XferOnDisconnect")
#define	REGVAL_VIDEO_XFER_SHOW              TEXT("XferOnShow")
#define	REGVAL_VIDEO_XFER_HIDE              TEXT("XferOnHide")
//DWORD one of:
#define VIDEO_XFER_NOP              0   // Leave transfer in current state
#define VIDEO_XFER_STOP             1   // Stop transfer
#define VIDEO_XFER_START            2   // Start transfer
#define VIDEO_XFER_PROMPT           3   // Prompt to start/stop transfer
#define VIDEO_XFER_PREV             4   // Previous state

#define	VIDEO_SEND_INIT_DEFAULT             VIDEO_XFER_STOP
#define	VIDEO_RECEIVE_INIT_DEFAULT          VIDEO_XFER_STOP

#define	VIDEO_SEND_CONNECT_DEFAULT          VIDEO_XFER_NOP
#define	VIDEO_RECEIVE_CONNECT_DEFAULT       VIDEO_XFER_START

#define	VIDEO_SEND_DISCONNECT_DEFAULT       VIDEO_XFER_NOP
#define	VIDEO_RECEIVE_DISCONNECT_DEFAULT    VIDEO_XFER_STOP

#define	VIDEO_SEND_SHOW_DEFAULT             VIDEO_XFER_PROMPT
#define	VIDEO_RECEIVE_SHOW_DEFAULT          VIDEO_XFER_PREV

#define	VIDEO_SEND_HIDE_DEFAULT             VIDEO_XFER_PROMPT
#define	VIDEO_RECEIVE_HIDE_DEFAULT          VIDEO_XFER_STOP

#define REGVAL_VIDEO_XPOS           REGVAL_WINDOW_XPOS
#define REGVAL_VIDEO_YPOS           REGVAL_WINDOW_YPOS

//------------------------------------------------------- 
// SIC
// Notice that the height and width reg keys are reversed
// ( that is the WindowHeight registry value actuall holds the
// video window's width )....
// It has always been like this but because it would screw
// up upgrade installations if we "fixed" it, we are going
// to keep it like this.... 
#define REGVAL_VIDEO_WIDTH          REGVAL_WINDOW_HEIGHT
#define REGVAL_VIDEO_HEIGHT         REGVAL_WINDOW_WIDTH

#define REGVAL_VIDEO_DOCKED_XPOS    TEXT("DockedX")
#define REGVAL_VIDEO_DOCKED_YPOS    TEXT("DockedY")

#define REGVAL_VIDEO_TOPMOST        TEXT("TopMost")
#define VIDEO_TOPMOST_DEFAULT       1

#define REGVAL_VIDEO_ZOOM           TEXT("Zoom")
#define VIDEO_ZOOM_DEFAULT          100

#define REGVAL_VIDEO_MIRROR         TEXT("Mirror")
#define VIDEO_MIRROR_DEFAULT        TRUE

#define REGVAL_VIDEO_VISIBLE            TEXT("Visible")
#define VIDEO_LOCAL_VISIBLE_DEFAULT     0
#define VIDEO_REMOTE_VISIBLE_DEFAULT    0

#define REGVAL_VIDEO_FRAME_SIZE         TEXT("FrameSize")

#define REGVAL_VIDEO_AUDIO_SYNC         TEXT("AVSync")
#define VIDEO_AUDIO_SYNC_DEFAULT        1

/////////// QoS-related keys and values (HKLM, CONFERENCING_KEY) /////////
#define QOS_KEY					CONFERENCING_KEY TEXT("\\QoS")
#define	REGKEY_QOS_RESOURCES	QOS_KEY TEXT("\\Resources") 

/////////// Tools menu related registry keys and values /////////////

#define	TOOLS_MENU_KEY TEXT("SOFTWARE\\Microsoft\\Conferencing\\Tools") // (HKLM)

/////////// MRU related registry keys and values /////////////

#define	MRU_KEY TEXT("SOFTWARE\\Microsoft\\Conferencing\\UI\\Calls")
#define	DIR_MRU_KEY TEXT("SOFTWARE\\Microsoft\\Conferencing\\UI\\Directory")

// Most recently used list count
#define REGVAL_MRU_COUNT					TEXT("Count")

// MRU list prefixes (name and transport)
#define REGVAL_NAME_MRU_PREFIX				TEXT("Name")
#define REGVAL_TRANSPORT_MRU_PREFIX			TEXT("Transport")
#define REGVAL_CALL_FLAGS_MRU_PREFIX		TEXT("Flags")

// MRU list for the "Place A Call" dialog
#define DLGCALL_MRU_KEY TEXT("SOFTWARE\\Microsoft\\Conferencing\\UI\\CallMRU")
#define REGVAL_DLGCALL_DEFDIR               TEXT("DefDir")
#define REGVAL_DLGCALL_POSITION             TEXT("Pos")
#define REGVAL_DLGCALL_NAME_MRU_PREFIX      TEXT("Name")
#define REGVAL_DLGCALL_ADDR_MRU_PREFIX      TEXT("Addr")
#define REGVAL_DLGCALL_TYPE_MRU_PREFIX      TEXT("Type")

/////////// UI related registry keys and values /////////////

#define	UI_KEY TEXT("SOFTWARE\\Microsoft\\Conferencing\\UI")

// Window size/position
#define REGVAL_MP_WINDOW_X					REGVAL_WINDOW_XPOS
#define DEFAULT_MP_WINDOW_X					10
#define REGVAL_MP_WINDOW_Y					REGVAL_WINDOW_YPOS
#define DEFAULT_MP_WINDOW_Y					3
#define REGVAL_MP_WINDOW_WIDTH				REGVAL_WINDOW_WIDTH
#define DEFAULT_MP_WINDOW_WIDTH				638 // IDS_WINDOW_WIDTH fallback
#define REGVAL_MP_WINDOW_HEIGHT				REGVAL_WINDOW_HEIGHT // actually window bottom
#define DEFAULT_MP_WINDOW_HEIGHT			500 // max of SVGA: 800x600 (was 640x480)
#define DEFAULT_MP_WINDOW_HEIGHT_LAN        574 // allows for larger video windows
#define REGVAL_MP_WINDOW_MAXIMIZED			TEXT("WindowMax")    // actually window right
#define DEFAULT_MP_WINDOW_MAXIMIZED			0
#define REGVAL_MP_WINDOW_STATE				TEXT("WindowState")    // Normal, Compact, Data-Only
#define DEFAULT_MP_WINDOW_STATE				0

#define REGVAL_COLUMN_WIDTHS				TEXT("ColumnWidths")
#define REGVAL_COLUMN_ORDER					TEXT("ColumnOrder")
#define REGVAL_DIR_FILTER					TEXT("DirFilter")
#define REGVAL_DIR_COLUMN_WIDTHS			TEXT("DirColumnWidths")
#define REGVAL_DIR_COLUMN_ORDER				TEXT("DirColumnOrder")
#define REGVAL_DIR_SORT_ASCENDING			TEXT("DirSortAscending")
#define REGVAL_DIR_SORT_COLUMN				TEXT("DirSortColumn")

#define REGVAL_ENABLE_DIRECTORY_INITIALREFRESH	TEXT("DirInitialRefresh")
#define DEFAULT_ENABLE_DIRECTORY_INITIALREFRESH	1
#define REGVAL_ENABLE_DIRECTORY_AUTOREFRESH	    TEXT("DirAutoRefresh")
#define DEFAULT_ENABLE_DIRECTORY_AUTOREFRESH	0
#define REGVAL_DIRECTORY_REFRESH_INTERVAL		TEXT("DirRefreshInterval")
#define DEFAULT_DIRECTORY_REFRESH_INTERVAL	    5 // minutes

#define REGVAL_CACHE_DIRECTORY              TEXT("DirCache")
#define DEFAULT_CACHE_DIRECTORY             1
#define REGVAL_CACHE_DIRECTORY_EXPIRATION   TEXT("DirExpire")
#define DEFAULT_CACHE_DIRECTORY_EXPIRATION  30 // minutes

#define REGVAL_RING_TIMEOUT                 TEXT("CallTimeout")
#define DEFAULT_RING_TIMEOUT                20 // seconds

// Window element visibility
#define REGVAL_SHOW_TOOLBAR                 TEXT("Toolbar")
#define DEFAULT_SHOW_TOOLBAR                1
#define REGVAL_SHOW_STATUSBAR               TEXT("StatusBar")
#define DEFAULT_SHOW_STATUSBAR              1

#define REGVAL_SHOW_SECUREDETAILS			TEXT("SecurityDetails")
#define DEFAULT_SHOW_SECUREDETAILS			0




// Don't show me dialog settings (all default to FALSE)
#define REGVAL_DS_DO_NOT_DISTURB_WARNING			TEXT("DS Do Not Disturb Warning")
#define REGVAL_DS_MACHINE_NAME_WARNING				TEXT("DS Machine Name Warning")

/////////// GUID related registry keys and values /////////////

#define	GUID_KEY TEXT("SOFTWARE\\Microsoft\\Conferencing\\Applications")
#define T120_APPLET_KEY TEXT("SOFTWARE\\Microsoft\\Conferencing\\T.120 Applets")
#define T120_NONSTD_KEY TEXT("NonStd Key")
#define T120_STD_KEY    TEXT("Object Key")

// startup values
#define REGVAL_GUID_APPNAME                 TEXT("Path")
#define REGVAL_GUID_CMDLINE                 TEXT("CmdLine")
#define REGVAL_GUID_CURRDIR                 TEXT("Directory")

// environment variables (not registry items)
#define ENV_NODEID                          TEXT("_node_id")
#define ENV_CONFID                          TEXT("_conf_id")


// GUID for Roster information
// {6CAA8570-CAE5-11cf-8FA5-00805F742EF6}
#define GUID_ROSTINFO {0x6caa8570,0xcae5,0x11cf,{0x8f,0xa5,0x00,0x80,0x5f,0x74,0x2e,0xf6}}

// GUID for Version information, passed across T120 as User Data.
// {E0A07F00-C9D7-11cf-A4ED-00AA003B1816}
#define GUID_VERSION  {0xe0a07f00,0xc9d7,0x11cf,{0xa4,0xed,0x00,0xaa,0x00,0x3b,0x18,0x16}}

// GUID for capabilities, passed across T120 as User Data.
// {5E8BA590-8C59-11d0-8DD6-0000F803A446}
#define GUID_CAPS     {0x5e8ba590,0x8c59,0x11d0,{0x8d,0xd6,0x00,0x00,0xf8,0x03,0xa4,0x46}}

// GUID for Security information
// {DF7284F0-B933-11d1-8754-0000F8757125}
#define GUID_SECURITY { 0xdf7284f0, 0xb933, 0x11d1, { 0x87, 0x54, 0x0, 0x0, 0xf8, 0x75, 0x71, 0x25 } }

// GUID for H.323 terminal label 
// {16D7DA06-FF2C-11d1-B32D-00C04FD919C9}
#define GUID_TERMLABEL { 0x16d7da06, 0xff2c, 0x11d1, {0xb3, 0x2d, 0x0, 0xc0, 0x4f, 0xd9, 0x19, 0xc9 } }

// GUID for meeting settings
// {44B67307-D4EC-11d2-8BE4-00C04FD8EE32}
#define GUID_MTGSETTINGS { 0x44b67307, 0xd4ec, 0x11d2, { 0x8b, 0xe4, 0x0, 0xc0, 0x4f, 0xd8, 0xee, 0x32 } }

// GUID for Unigue Node Id
// {74423881-CC84-11d2-B4E3-00A0C90D0660}
#define GUID_NODEID { 0x74423881, 0xcc84, 0x11d2, { 0xb4, 0xe3, 0x0, 0xa0, 0xc9, 0xd, 0x6, 0x60 } }

// NetMeeting versions
#define DWVERSION_NM_1    (0x04000000 | 1133)  // 1.0 Final
#define DWVERSION_NM_2b2  (0x04000000 | 1266)  // 2.0 Beta 2
#define DWVERSION_NM_2b4  (0x04000000 | 1333)  // 2.0 Beta 4
#define DWVERSION_NM_2b5  (0x04000000 | 1349)  // 2.0 RC 1
#define DWVERSION_NM_2rc2 (0x04000000 | 1366)  // 2.0 RC 2
#define DWVERSION_NM_2    (0x04000000 | 1368)  // 2.0 Final
#define DWVERSION_NM_2q1  (0x04000000 | 1372)  // 2.0 QFE
#define DWVERSION_NM_3a1  (0x04030000 | 2000)  // 2.1 Alpha 1
#define DWVERSION_NM_3b1  (0x04030000 | 2064)  // 2.1 Beta 1
#define DWVERSION_NM_3b2  (0x04030000 | 2099)  // 2.1 Beta 2
#define DWVERSION_NM_3rc  (0x04030000 | 2135)  // 2.1 Final
#define DWVERSION_NM_3sp1 (0x04030000 | 2203)  // 2.1 Service Pack 1
#define DWVERSION_NM_3o9b1 (0x04030000 | 2408) // 2.11 Office Beta 1 and IE5 Beta 1
#define DWVERSION_NM_3ntb2 (0x04030000 | 2412) // 2.11 NT Beta 2
#define DWVERSION_NM_3max  (0x0403ffff)		   // 2.X max version

#define DWVERSION_NM_4a1  (0x04040000 | 2200)  // 3.0 Alpha 1
#define DWVERSION_NM_4    VER_PRODUCTVERSION_DW
#define DWVERSION_NM_CURRENT    DWVERSION_NM_4

#define DWVERSION_MASK     0x00FF0000  // mask for product version number


/////////// Policy related registry keys and values /////////////

#define	POLICIES_KEY TEXT("SOFTWARE\\Policies\\Microsoft\\Conferencing")

// The following are the policy values that can be set by the policy editor
// If any of these are set to 1, the feature is disabled.  If they are not
// present or they are set to 0, the feature is enabled.

#define REGVAL_AUTOCONF_USE				    TEXT("Use AutoConfig")
#define DEFAULT_AUTOCONF_USE				0
#define REGVAL_AUTOCONF_CONFIGFILE			TEXT("ConfigFile")
#define REGVAL_AUTOCONF_TIMEOUT				TEXT("Timeout")
#define DEFAULT_AUTOCONF_TIMEOUT			10000


#define	REGVAL_POL_NO_FILETRANSFER_SEND		TEXT("NoSendingFiles")
#define	DEFAULT_POL_NO_FILETRANSFER_SEND	0
#define	REGVAL_POL_NO_FILETRANSFER_RECEIVE	TEXT("NoReceivingFiles")
#define	DEFAULT_POL_NO_FILETRANSFER_RECEIVE	0
#define REGVAL_POL_MAX_SENDFILESIZE			TEXT("MaxFileSendSize")
#define	DEFAULT_POL_MAX_FILE_SIZE			0

#define REGVAL_POL_NO_CHAT			        TEXT("NoChat")
#define	DEFAULT_POL_NO_CHAT		            0
#define REGVAL_POL_NO_OLDWHITEBOARD         TEXT("NoOldWhiteBoard")
#define	DEFAULT_POL_NO_OLDWHITEBOARD        0
#define REGVAL_POL_NO_NEWWHITEBOARD         TEXT("NoNewWhiteBoard")
#define DEFAULT_POL_NO_NEWWHITEBOARD        0

#define	REGVAL_POL_NO_APP_SHARING			TEXT("NoAppSharing")
#define	DEFAULT_POL_NO_APP_SHARING			0
#define REGVAL_POL_NO_SHARING               TEXT("NoSharing")
#define DEFAULT_POL_NO_SHARING              0
#define REGVAL_POL_NO_DESKTOP_SHARING       TEXT("NoSharingDesktop")
#define DEFAULT_POL_NO_DESKTOP_SHARING      0
#define	REGVAL_POL_NO_MSDOS_SHARING			TEXT("NoSharingDosWindows")
#define	DEFAULT_POL_NO_MSDOS_SHARING		0
#define	REGVAL_POL_NO_EXPLORER_SHARING		TEXT("NoSharingExplorer")
#define	DEFAULT_POL_NO_EXPLORER_SHARING		0
#define REGVAL_POL_NO_TRUECOLOR_SHARING     TEXT("NoTrueColorSharing")
#define DEFAULT_POL_NO_TRUECOLOR_SHARING    0
#define	REGVAL_POL_NO_ALLOW_CONTROL		    TEXT("NoAllowControl")
#define	DEFAULT_POL_NO_ALLOW_CONTROL		0

#define	REGVAL_POL_NO_AUDIO					TEXT("NoAudio")
#define	DEFAULT_POL_NO_AUDIO				0
#define REGVAL_POL_NO_ADVAUDIO				TEXT("NoAdvancedAudio")
#define	DEFAULT_POL_NO_ADVAUDIO				0
#define REGVAL_POL_NO_FULLDUPLEX			TEXT("NoFullDuplex")
#define	DEFAULT_POL_NO_FULLDUPLEX			0
#define REGVAL_POL_NOCHANGE_DIRECTSOUND     TEXT("NoChangeDirectSound")
#define DEFAULT_POL_NOCHANGE_DIRECTSOUND    0
#define REGVAL_POL_NO_VIDEO_SEND			TEXT("NoSendingVideo")
#define	DEFAULT_POL_NO_VIDEO_SEND			0
#define REGVAL_POL_NO_VIDEO_RECEIVE			TEXT("NoReceivingVideo")
#define	DEFAULT_POL_NO_VIDEO_RECEIVE		0
#define REGVAL_POL_MAX_BANDWIDTH			TEXT("MaximumBandwidth")
#define DEFAULT_POL_MAX_BANDWIDTH			0

#define	REGVAL_POL_NO_GENERALPAGE			TEXT("NoGeneralPage")
#define	DEFAULT_POL_NO_GENERALPAGE			0
#define REGVAL_POL_NO_SECURITYPAGE			TEXT("NoSecurityPage")
#define DEFAULT_POL_NO_SECURITYPAGE			0
#define	REGVAL_POL_NO_AUDIOPAGE				TEXT("NoAudioPage")
#define	DEFAULT_POL_NO_AUDIOPAGE			0
#define REGVAL_POL_NO_VIDEOPAGE             TEXT("NoVideoPage")
#define	DEFAULT_POL_NO_VIDEOPAGE			0
#define REGVAL_POL_NO_ADVANCEDCALLING       TEXT("NoAdvancedCalling")
#define DEFAULT_POL_NO_ADVANCEDCALLING      0

#define REGVAL_POL_NO_DIRECTORY_SERVICES	TEXT("NoDirectoryServices")
#define	DEFAULT_POL_NO_DIRECTORY_SERVICES	0
#define REGVAL_POL_NO_AUTOACCEPTCALLS       TEXT("NoAutoAcceptCalls")
#define	DEFAULT_POL_NO_AUTOACCEPTCALLS      0
#define REGVAL_POL_PERSIST_AUTOACCEPTCALLS  TEXT("PersistAutoAcceptCalls")
#define	DEFAULT_POL_PERSIST_AUTOACCEPTCALLS 0
#define REGVAL_POL_INTRANET_SUPPORT_URL     TEXT("IntranetSupportURL")
#define REGVAL_POL_INTRANET_WEBDIR_URL      TEXT("IntranetWebDirURL")
#define REGVAL_POL_INTRANET_WEBDIR_NAME     TEXT("IntranetWebDirName")
#define REGVAL_POL_INTRANET_WEBDIR_SERVER   TEXT("IntranetWebDirServer")
#define REGVAL_POL_SHOW_FIRST_TIME_URL		TEXT("ShowFirstTimeURL")
#define DEFAULT_POL_SHOW_FIRST_TIME_URL		0
#define REGVAL_POL_NO_ADDING_NEW_ULS        TEXT("NoAddingDirectoryServers")
#define DEFAULT_POL_NO_ADDING_NEW_ULS       0

// Before a file is transferred, we need to check its size in case it exceeds the limit.
// This is the default size limit (0 is "no limit").
#define REGVAL_POL_NO_RDS					TEXT("NoRDS")
#define DEFAULT_POL_NO_RDS					0
#define REGVAL_POL_NO_RDS_WIN9X             TEXT("NoRDSWin9x")
#define DEFAULT_POL_NO_RDS_WIN9X            0



// MCU cleartext password keys.
#define REGVAL_VALIDATE_USER				TEXT("PasswordValidation")
#define REGKEY_CONFERENCES					TEXT("Conferences")
#define REGVAL_PASSWORD						TEXT("Password")

// CALL SECURITY
#define REGVAL_POL_SECURITY             TEXT("CallSecurity")
#define STANDARD_POL_SECURITY           0
#define REQUIRED_POL_SECURITY           1
#define DISABLED_POL_SECURITY           2
#define DEFAULT_POL_SECURITY            STANDARD_POL_SECURITY

#define REGVAL_POL_NO_INCOMPLETE_CERTS		TEXT("NoIncompleteCerts")
#define DEFAULT_POL_NO_INCOMPLETE_CERTS		0
#define REGVAL_POL_ISSUER					TEXT("CertificateIssuer")

/////////// Logging related registry keys and values /////////////

#define	LOG_INCOMING_KEY TEXT("SOFTWARE\\Microsoft\\Conferencing\\Log\\Incoming")
#define	LOG_OUTGOING_KEY TEXT("SOFTWARE\\Microsoft\\Conferencing\\Log\\Outgoing")

// Name of file in which to store log data
#define	REGVAL_LOG_FILE                     TEXT("File")

// Number of days before deleting log entry
#define	REGVAL_LOG_EXPIRE                   TEXT("Expire")
#define	DEFAULT_LOG_EXPIRE                  0

// Maximum number of log entries to maintain
#define REGVAL_LOG_MAX_ENTRIES				TEXT("Max Entries")
#define DEFAULT_LOG_MAX_ENTRIES				100


///////////// Debug only registry settings //////////////

// Flag to determine whether to display debug output window
#define REGVAL_SHOW_DEBUG_OUTPUT			TEXT("ShowDebugOutput")


// Debug-only key
#define DEBUG_KEY TEXT("SOFTWARE\\Microsoft\\Conferencing\\Debug")

#define REGVAL_DBG_OUTPUT                    TEXT("OutputDebugString")
#define DEFAULT_DBG_OUTPUT                    1
#define REGVAL_DBG_WIN_OUTPUT                TEXT("Window Output")
#define DEFAULT_DBG_NO_WIN                    0
#define REGVAL_DBG_FILE_OUTPUT               TEXT("File Output")
#define DEFAULT_DBG_NO_FILE                   0
#define REGVAL_DBG_FILE                      TEXT("File")
#define DEFAULT_DBG_FILENAME                 TEXT("nmDbg.txt")

#define REGVAL_RETAIL_LOG                    TEXT("RetailLog")
#define RETAIL_LOG_FILENAME                  TEXT("nmLog.txt")

#define REGVAL_DBG_SPEWFLAGS                 TEXT("SpewFlags")
#define DEFAULT_DBG_SPEWFLAGS                 0

#define REGVAL_DBG_SHOW_TIME                 TEXT("Show Time")
#define REGVAL_DBG_SHOW_THREADID             TEXT("Show ThreadId")
#define REGVAL_DBG_SHOW_MODULE               TEXT("Show Module")

#define REGVAL_DBG_RTL                       TEXT("RTL")
#define DEFAULT_DBG_RTL                      0

#define REGVAL_DBG_DISPLAY_FPS               TEXT("DisplayFps")
#define REGVAL_DBG_DISPLAY_VIEWSTATUS        TEXT("ViewStatus")

#define REGVAL_DBG_FAKE_CALLTO               TEXT("CallTo")
#define DEFAULT_DBG_FAKE_CALLTO              0

#define REGVAL_DBG_CALLTOP                   TEXT("CallTop")
#define DEFAULT_DBG_CALLTOP                  1


#define ZONES_KEY TEXT("SOFTWARE\\Microsoft\\Conferencing\\Debug\\Zones")


/////////// Whiteboard related registry keys and values /////////////

#define	WHITEBOARD_KEY TEXT("SOFTWARE\\Microsoft\\Conferencing\\Whiteboard")
#define	NEW_WHITEBOARD_KEY TEXT("SOFTWARE\\Microsoft\\Conferencing\\Whiteboard 3.0")

//Whiteboard values are defined in oprah\dcg32\wb32\wwbopts.hpp

////////////// Chat related registry keys and values ////////////////

#define	CHAT_KEY TEXT("SOFTWARE\\Microsoft\\Conferencing\\Chat")

////////////// Remote control service related keys and values ////////////////

#define WIN95_SERVICE_KEY					TEXT("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\RunServices")
#define REMOTECONTROL_KEY					TEXT("SOFTWARE\\Microsoft\\Conferencing\\Mcpt")
#define WINNT_WINLOGON_KEY                                      TEXT("SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon")
#define WIN95_WINLOGON_KEY                                      TEXT("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Winlogon")
#define DESKTOP_KEY                                             TEXT("Control Panel\\Desktop")
#define REMOTE_REG_RUNSERVICE				TEXT("Fpx")
#define DEFAULT_REMOTE_RUNSERVICE			0
#define REMOTE_REG_ACTIVATESERVICE			TEXT("Plc")
#define DEFAULT_REMOTE_ACTIVATESERVICE		0
#define REMOTE_REG_NOEXIT                   TEXT("Nx")
#define DEFAULT_REMOTE_NOEXIT              0

#define REMOTE_REG_PASSWORD					TEXT("FieldPos")

#define REGVAL_SCREENSAVER_GRACEPERIOD                          TEXT("ScreenSaverGracePeriod")
#define REGVAL_WINNT_SCPW                                       TEXT("ScreenSaverIsSecure")
#define REGVAL_WIN95_SCPW                                       TEXT("ScreenSaveUsePassword")

/////////// NT display driver registry keys and values (HKLM) /////////////

#define NM_NT_DISPLAY_DRIVER_KEY	TEXT("System\\CurrentControlSet\\Services\\mnmdd")
#define REGVAL_NM_NT_DISPLAY_DRIVER_ENABLED	TEXT("Start")
// Note: The below values are from KB article Q103000
#define NT_DRIVER_START_BOOT		0x0
#define NT_DRIVER_START_SYSTEM		0x1
#define NT_DRIVER_START_AUTOLOAD	0x2
#define NT_DRIVER_START_ONDEMAND	0x3
#define NT_DRIVER_START_DISABLED	0x4

/////////// NT service pack version registry keys and values (HKLM) /////////////
#define NT_WINDOWS_SYSTEM_INFO_KEY	TEXT("System\\CurrentControlSet\\Control\\Windows")
#define REGVAL_NT_CSD_VERSION		TEXT("CSDVersion")


/////////// System Information registry keys and values (HKLM) /////////////
#define WINDOWS_KEY            TEXT("SOFTWARE\\Microsoft\\Windows\\CurrentVersion")
#define WINDOWS_NT_KEY         TEXT("SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion")
#define REGVAL_REGISTERED_USER TEXT("RegisteredOwner")
#define	REGVAL_REGISTERED_ORG  TEXT("RegisteredOrganization")

#endif  // ! _CONFREG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\h\custring.h ===
#ifndef _CUSTRING_H_
#define _CUSTRING_H_

#include <nmutil.h>

// Simple universal string class, where string can be converted 
// back and forth between Ansi and Unicode string and buffers
// allocated are destroyed in string class destructor.

class CUSTRING
{
public:
	CUSTRING(PCWSTR wszText = NULL);
	CUSTRING(PCSTR szText);
	~CUSTRING();
	operator PWSTR();
	operator PSTR();
	inline void GiveString(PCWSTR wszText);
	inline void GiveString(PCSTR szText);
	inline void AssignString(PCWSTR wszText);
	inline void AssignString(PCSTR szText);
protected:
	PWSTR	wszData;
	PSTR	szData;
	BOOL	bUnicodeNew;
	BOOL	bAnsiNew;
};


inline void CUSTRING::GiveString(PCWSTR wszText)
{
	ASSERT(!wszData);
	wszData = (PWSTR)wszText;
	bUnicodeNew = TRUE;
}

inline void CUSTRING::GiveString(PCSTR szText)
{
	ASSERT(!szData);
	szData = (PSTR)szText;
	bAnsiNew = TRUE;
}

inline void CUSTRING::AssignString(PCWSTR wszText)
{
	ASSERT(!wszData);
	wszData = (PWSTR)wszText;
}

inline void CUSTRING::AssignString(PCSTR szText)
{
	ASSERT(!szData);
	szData = (PSTR)szText;
}

#endif // ndef CUSTRING_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\h\datguids.h ===
/*
 *  	File: datguids.h
 *
 *      Defines media type for T120 data for QOS purposes
 *
 *		Revision History:
 *
 *		11/22/96	clausgi created
 */

// {9442E580-4457-11d0-A787-00A0C91BBEE1}
DEFINE_GUID(MEDIA_TYPE_T120DATA,
0x9442e580, 0x4457, 0x11d0, 0xa7, 0x87, 0x0, 0xa0, 0xc9, 0x1b, 0xbe, 0xe1);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\h\cstring.hpp ===
#ifndef _CSTRING_HPP_
#define _CSTRING_HPP_

#include <nmutil.h>

// These two header files contain definitions that used to be in this file.
// To allow source files which include this file to continue to work 
// unmodified, we include them here.
#include <strutil.h>
#include <custring.h>

#define REMAFXAPI
#define REMAFX_DATADEF
#define REMAFX_DATA
#define REMAFX_CDECL
#define REM_AFX_INLINE inline

// BUGBUG - How are these used?
#ifndef PUBLIC_CODE
#define PUBLIC_CODE
#define PUBLIC_DATA
#define PRIVATE_CODE             PUBLIC_CODE
#define PRIVATE_DATA             PUBLIC_DATA
#endif


struct CSTRINGData
{
	long nRefs;     // reference count
	int nDataLength;
	int nAllocLength;
	// TCHAR data[nAllocLength]

	TCHAR* data()
		{ return (TCHAR*)(this+1); }
};

class CSTRING
{
public:
// Constructors
	CSTRING();
	CSTRING(const CSTRING& stringSrc);
	CSTRING(TCHAR ch, int nRepeat = 1);
	CSTRING(LPCSTR lpsz);
	CSTRING(LPCWSTR lpsz);
	CSTRING(LPCTSTR lpch, int nLength);
	CSTRING(const unsigned char* psz);

// Attributes & Operations
	// as an array of characters
	int GetLength() const;
	BOOL IsEmpty() const;
	void Empty();                       // free up the data

	TCHAR GetAt(int nIndex) const;      // 0 based
	TCHAR operator[](int nIndex) const; // same as GetAt
	void SetAt(int nIndex, TCHAR ch);
	operator LPCTSTR() const;           // as a C string

	// overloaded assignment
	const CSTRING& operator=(const CSTRING& stringSrc);
	const CSTRING& operator=(TCHAR ch);
#ifdef _UNICODE
	const CSTRING& operator=(char ch);
	const CSTRING& operator=(LPCSTR lpsz);
#else
	const CSTRING& operator=(LPCWSTR lpsz);
#endif
	const CSTRING& operator=(const unsigned char* psz);
	const CSTRING& operator=(LPCTSTR lpsz);

	// string concatenation
	const CSTRING& operator+=(const CSTRING& string);
	const CSTRING& operator+=(TCHAR ch);
#ifdef _UNICODE
	const CSTRING& operator+=(char ch);
#endif
	const CSTRING& operator+=(LPCTSTR lpsz);

	friend CSTRING REMAFXAPI operator+(const CSTRING& string1,
			const CSTRING& string2);
	friend CSTRING REMAFXAPI operator+(const CSTRING& string, TCHAR ch);
	friend CSTRING REMAFXAPI operator+(TCHAR ch, const CSTRING& string);
#ifdef _UNICODE
	friend CSTRING REMAFXAPI operator+(const CSTRING& string, char ch);
	friend CSTRING REMAFXAPI operator+(char ch, const CSTRING& string);
#endif
	friend CSTRING REMAFXAPI operator+(const CSTRING& string, LPCTSTR lpsz);
	friend CSTRING REMAFXAPI operator+(LPCTSTR lpsz, const CSTRING& string);

	void Append (LPCTSTR lpszSrcData, int nSrcLen);

	// string comparison
	int Compare(LPCTSTR lpsz) const;		// straight character
	int CompareNoCase(LPCTSTR lpsz) const;	// ignore case
	BOOL FEqual (const CSTRING& s2) const;	// length-sensitive comparison
	int Collate(LPCTSTR lpsz) const;		// NLS aware

	// simple sub-string extraction
	CSTRING Mid(int nFirst, int nCount) const;
	CSTRING Mid(int nFirst) const;
	CSTRING Left(int nCount) const;
	CSTRING Right(int nCount) const;

	CSTRING SpanIncluding(LPCTSTR lpszCharSet) const;
	CSTRING SpanExcluding(LPCTSTR lpszCharSet) const;

	// upper/lower/reverse conversion
	void MakeUpper();
	void MakeLower();

	// trimming whitespace (either side)
	void TrimRight();
	void TrimLeft();

	// searching (return starting index, or -1 if not found)
	// look for a single character match
	int Find(TCHAR ch) const;               // like "C" strchr

	// simple formatting
	void REMAFX_CDECL Format(LPCTSTR lpszFormat, ...);
	void REMAFX_CDECL Format(UINT nFormatID, ...);

	// formatting for localization (uses FormatMessage API)
	void REMAFX_CDECL FormatMessage(LPCTSTR lpszFormat, ...);
	void REMAFX_CDECL FormatMessage(UINT nFormatID, ...);

	// Windows support
	BOOL LoadString(HINSTANCE hInstance, UINT nID);	// load from string resource
													// 255 chars max
#ifndef _UNICODE
	// ANSI <-> OEM support (convert string in place)
	void AnsiToUnicode();
	void AnsiToOem();
	void OemToAnsi();
#endif

#ifndef _AFX_NO_BSTR_SUPPORT
	// OLE BSTR support (use for OLE automation)
	BSTR AllocSysString() const;
	BSTR SetSysString(BSTR* pbstr) const;
#endif

	// Access to string implementation buffer as "C" character array
	LPTSTR GetBuffer(int nMinBufLength);
	void ReleaseBuffer(int nNewLength = -1);
	LPTSTR GetBufferSetLength(int nNewLength);
	void FreeExtra();

	// Use LockBuffer/UnlockBuffer to turn refcounting off
	LPTSTR LockBuffer();
	void UnlockBuffer();

// Implementation
public:
	~CSTRING();
	int GetAllocLength() const;

protected:
	LPTSTR m_pchData;   // pointer to ref counted string data

	// implementation helpers
	CSTRINGData* GetData() const;
	void Init();
	void AllocCopy(CSTRING& dest, int nCopyLen, int nCopyIndex, int nExtraLen) const;
	void AllocBuffer(int nLen);
	void AssignCopy(int nSrcLen, LPCTSTR lpszSrcData);
	void ConcatCopy(int nSrc1Len, LPCTSTR lpszSrc1Data, int nSrc2Len, LPCTSTR lpszSrc2Data);
	void ConcatInPlace(int nSrcLen, LPCTSTR lpszSrcData);
	void FormatV(LPCTSTR lpszFormat, va_list argList);
	void CopyBeforeWrite();
	void AllocBeforeWrite(int nLen);
	void Release();
	static void PASCAL Release(CSTRINGData* pData);
	static int PASCAL SafeStrlen(LPCTSTR lpsz);
};

// conversion helpers
int REMAFX_CDECL _wcstombsz(char* mbstr, const wchar_t* wcstr, size_t count);
int REMAFX_CDECL _mbstowcsz(wchar_t* wcstr, const char* mbstr, size_t count);

// Globals
extern REMAFX_DATA TCHAR AFXChNil;
const CSTRING& REMAFXAPI AFXGetEmptyString();
#define AFXEmptyString AFXGetEmptyString()

// inlines
REM_AFX_INLINE CSTRINGData* CSTRING::GetData() const
	{ ASSERT(m_pchData != NULL); return ((CSTRINGData*)m_pchData)-1; }
REM_AFX_INLINE void CSTRING::Init()
	{ m_pchData = AFXEmptyString.m_pchData; }
REM_AFX_INLINE CSTRING::CSTRING(const unsigned char* lpsz)
	{ Init(); *this = (LPCSTR)lpsz; }
REM_AFX_INLINE const CSTRING& CSTRING::operator=(const unsigned char* lpsz)
	{ *this = (LPCSTR)lpsz; return *this; }
#ifdef _UNICODE
REM_AFX_INLINE const CSTRING& CSTRING::operator+=(char ch)
	{ *this += (TCHAR)ch; return *this; }
REM_AFX_INLINE const CSTRING& CSTRING::operator=(char ch)
	{ *this = (TCHAR)ch; return *this; }
REM_AFX_INLINE CSTRING REMAFXAPI operator+(const CSTRING& string, char ch)
	{ return string + (TCHAR)ch; }
REM_AFX_INLINE CSTRING REMAFXAPI operator+(char ch, const CSTRING& string)
	{ return (TCHAR)ch + string; }
#endif

REM_AFX_INLINE int CSTRING::GetLength() const
	{ return GetData()->nDataLength; }
REM_AFX_INLINE int CSTRING::GetAllocLength() const
	{ return GetData()->nAllocLength; }
REM_AFX_INLINE BOOL CSTRING::IsEmpty() const
	{ return GetData()->nDataLength == 0; }
REM_AFX_INLINE CSTRING::operator LPCTSTR() const
	{ return m_pchData; }
REM_AFX_INLINE int PASCAL CSTRING::SafeStrlen(LPCTSTR lpsz)
	{ return (lpsz == NULL) ? 0 : lstrlen(lpsz); }
REM_AFX_INLINE void CSTRING::Append (LPCTSTR lpszSrcData, int nSrcLen)
	{ ConcatInPlace(nSrcLen, lpszSrcData); }

REM_AFX_INLINE BOOL REMAFXAPI operator==(const CSTRING& s1, const CSTRING& s2)
	{ return s1.FEqual(s2); }
REM_AFX_INLINE BOOL REMAFXAPI operator==(const CSTRING& s1, LPCTSTR s2)
	{ return s1.Compare(s2) == 0; }
REM_AFX_INLINE BOOL REMAFXAPI operator==(LPCTSTR s1, const CSTRING& s2)
	{ return s2.Compare(s1) == 0; }
REM_AFX_INLINE BOOL REMAFXAPI operator!=(const CSTRING& s1, const CSTRING& s2)
	{ return s1.FEqual(s2) == FALSE; }
REM_AFX_INLINE BOOL REMAFXAPI operator!=(const CSTRING& s1, LPCTSTR s2)
	{ return s1.Compare(s2) != 0; }
REM_AFX_INLINE BOOL REMAFXAPI operator!=(LPCTSTR s1, const CSTRING& s2)
	{ return s2.Compare(s1) != 0; }

// Commented out for Unicode because Win95 doesn't support lstrcmpW
#ifndef UNICODE
REM_AFX_INLINE int CSTRING::Compare(LPCTSTR lpsz) const
	{ return lstrcmp(m_pchData, lpsz); }    // MBCS/Unicode aware
#endif // UNICODE

#endif // ndef CSTRING_HPP
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\h\evtlog.h ===
#ifndef __EVENTLOG_H__
#define __EVENTLOG_H__

#ifdef __cplusplus 
extern "C" {
#endif

void AddToMessageLog(WORD wType, WORD wCategory, DWORD dwEvtId, LPTSTR lpszMsg);

#ifdef __cplusplus
}
#endif

#endif __EVENTLOG_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\h\dllutil.h ===
// File: dllutil.h

#ifndef _DLLUTIL_H_
#define _DLLUTIL_H_

#include <shlwapi.h>  // for DLLVERSIONINFO

typedef struct tagApiFcn   // function pointer to API mapping
{
	PVOID * ppfn;
	LPSTR   szApiName;
} APIFCN;
typedef APIFCN * PAPIFCN;


BOOL FCheckDllVersionVersion(LPCTSTR pszDll, DWORD dwMajor, DWORD dwMinor);
HRESULT HrGetDllVersion(LPCTSTR lpszDllName, DLLVERSIONINFO * pDvi);
HRESULT HrInitLpfn(APIFCN *pProcList, int cProcs, HINSTANCE* phLib, LPCTSTR pszDllName);
HINSTANCE NmLoadLibrary(LPCTSTR pszModule);

#endif /* _DLLUTIL_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\h\gencontrols.h ===
// File: EditText.h

#ifndef _EDITTEXT_H_
#define _EDITTEXT_H_

#include "GenWindow.h"

#include "GenContainers.h"

class CEditText;

interface IEditTextChange : IUnknown
{
	virtual void OnTextChange(CEditText *pEdit) = 0;
	virtual void OnFocusChange(CEditText *pEdit, BOOL bSet) = 0;
} ;

// An edit control class that supports using different foreground and
// background colors
class DECLSPEC_UUID("{FD827E00-ACA3-11d2-9C97-00C04FB17782}")
CEditText : public CFillWindow
{
public:
	// Default constructor; inits a few intrinsics
	CEditText();

	// Creates the edit control
	BOOL Create(
		HWND hWndParent,				// Parent of the edit control
		DWORD dwStyle=0,				// Edit control style
		DWORD dwExStyle=0,				// Extended window style
		LPCTSTR szTitle=TEXT(""),		// Initial text for the edit control
		IEditTextChange *pNotify=NULL	// Object to notify of changes
		);

	HRESULT STDMETHODCALLTYPE QueryInterface(REFGUID riid, LPVOID *ppv)
	{
		if (__uuidof(CEditText) == riid)
		{
			*ppv = this;
			AddRef();
			return(S_OK);
		}
		return(CFillWindow::QueryInterface(riid, ppv));
	}

	void GetDesiredSize(SIZE *ppt);

	// Sets the foreground and background colors and brush to use for painting
	// Set the brush to NULL to indicate using default colors
	void SetColors(HBRUSH hbrBack, COLORREF back, COLORREF fore);

	// Sets the font to use in the edit control
	void SetFont(HFONT hf);

	// Sets the text for the control
	void SetText(
		LPCTSTR szText	// The text to set
		);

	// Gets the text for the control; returns the total text length
	int GetText(
		LPTSTR szText,	// Where to put the text
		int nLen		// The length of the buffer
		);

protected:
	virtual ~CEditText();

	virtual LRESULT ProcessMessage(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam);

private:
	// The actual edit control
	HWND m_edit;
	// The background brush
	HBRUSH m_hbrBack;
	// The background color
	COLORREF m_crBack;
	// The foreground color
	COLORREF m_crFore;
	// The font to use
	HFONT m_hfText;
	// The object ot notify of changes
	IEditTextChange *m_pNotify;

	// I may turn this into a GetWindow call later
	inline HWND GetEdit()
	{
		return(m_edit);
	}

	// Needed to change the edit control colors
	HBRUSH OnCtlColor(HWND hwnd, HDC hdc, HWND hwndChild, int type);

	// Notification of events on the edit control
	void OnCommand(HWND hwnd, int id, HWND hwndCtl, UINT codeNotify);

	// To clean stuff up
	void OnNCDestroy(HWND hwnd);
} ;

class CButton;

interface IButtonChange : IUnknown
{
	virtual void OnClick(CButton *pButton) = 0;
} ;

class DECLSPEC_UUID("{C3AEA4CA-CAB3-11d2-9CA7-00C04FB17782}")
CButton : public CFillWindow
{
public:
	CButton();
	~CButton();

	BOOL Create(
		HWND hWndParent,	// The parent window
		INT_PTR nId,			// The ID of the button for WM_COMMAND messages
		LPCTSTR szTitle,	// The string to display
		DWORD dwStyle=BS_PUSHBUTTON,	// The Win32 button style
		IButtonChange *pNotify=NULL		// Click notifications
		);

	HRESULT STDMETHODCALLTYPE QueryInterface(REFGUID riid, LPVOID *ppv)
	{
		if (__uuidof(CButton) == riid)
		{
			*ppv = this;
			AddRef();
			return(S_OK);
		}
		return(CFillWindow::QueryInterface(riid, ppv));
	}

	// Get/set the icon displayed with this button
	void SetIcon(
		HICON hIcon	// The icon to use for this button
		);
	HICON GetIcon();
	// Get/set the bitmap displayed with this button
	void SetBitmap(
		HBITMAP hBitmap	// The bitmap to use for this button
		);
	HBITMAP GetBitmap();

	// Get/set the checked state of the button
	void SetChecked(
		BOOL bCheck	// TRUE if the button should be checked
		);
	BOOL IsChecked();

	virtual void GetDesiredSize(SIZE *psize);

protected:
	virtual LRESULT ProcessMessage(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam);

private:
	// Notify handler for clicks
	IButtonChange *m_pNotify;
	// Store away the icon size to avoid creating many bitmaps
	SIZE m_sizeIcon;

	// Change the HWND and forward to the parent
	void OnCommand(HWND hwnd, int id, HWND hwndCtl, UINT codeNotify);
} ;

// A button class that uses bitmaps for its different states. Currently only
// pressed and normal are supported
class DECLSPEC_UUID("{E1813EDA-ACA3-11d2-9C97-00C04FB17782}")
CBitmapButton : public CButton
{
public:
	// The order of the bitmaps for the states of the button
	enum StateBitmaps
	{
		Normal = 0,
		Pressed,
		Hot,
		Disabled,
		NumStates
	} ;

	// Default constructor; inits a few intrinsics
	CBitmapButton();

	// Creates the button, using the bitmaps specified
	BOOL Create(
		HWND hWndParent,	// The parent of the button
		int nId,			// The ID for WM_COMMAND messages
		HBITMAP hbStates,	// The 2D array of bitmaps for the states of the button,
							// vertically in the order specified in the StateBitmaps enum
							// and horizontally in the custom states order
		UINT nInputStates=NumStates,	// The number of input states (Normal, Pressed, Hot, Disabled)
		UINT nCustomStates=1,			// The number of custom states
		IButtonChange *pNotify=NULL	// The click handler
		);

	// Creates the button, using the bitmaps specified
	BOOL Create(
		HWND hWndParent,	// The parent of the button
		int nId,			// The ID for WM_COMMAND messages
		HINSTANCE hInst,	// The instance to load the bitmap from
		int nIdBitmap,		// The ID of the bitmap to use
		BOOL bTranslateColors=TRUE,		// Use system background colors
		UINT nInputStates=NumStates,	// The number of input states (Normal, Pressed, Hot, Disabled)
		UINT nCustomStates=1,			// The number of custom states
		IButtonChange *pNotify=NULL	// The click handler
		);

	HRESULT STDMETHODCALLTYPE QueryInterface(REFGUID riid, LPVOID *ppv)
	{
		if (__uuidof(CBitmapButton) == riid)
		{
			*ppv = this;
			AddRef();
			return(S_OK);
		}
		return(CButton::QueryInterface(riid, ppv));
	}

	void GetDesiredSize(SIZE *ppt);

	// Change the current custom state
	void SetCustomState(UINT nCustomState);

	// Return the current custom state
	UINT GetCustomState() const { return(m_nCustomState); }

	// Change to flashing mode
	void SetFlashing(int nSeconds);

	// Is in flashing mode
	UINT IsFlashing() const { return(NoFlash != m_nFlashState); }

	static void GetBitmapSizes(HBITMAP parts[], SIZE sizes[], int nParts);

	static void LoadBitmaps(
		HINSTANCE hInst,	// The instance to load the bitmap from
		const int ids[],	// Array of bitmap ID's
		HBITMAP bms[],		// Array of HBITMAP's for storing the result
		int nBmps,			// Number of entries in the arrays
		BOOL bTranslateColors=TRUE // Use system background colors
		);

protected:
	virtual ~CBitmapButton();

	virtual LRESULT ProcessMessage(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam);

	virtual void SetHot(BOOL bHot);

	virtual BOOL IsHot() { return(m_bHot != FALSE); }

	void SchedulePaint()
	{
		InvalidateRect(GetChild(), NULL, FALSE);
	}

private:
	enum FlashState
	{
		NoFlash = 0,
		ForceHot,
		ForceNormal,
	} ;

	// The number of custom states
	UINT m_nCustomStates;
	// The current custom state
	UINT m_nCustomState;
	// The bitmaps for the states of the button, in the order specified in the
	// StateBitmaps enum.
	HBITMAP m_hbStates;
	// The time to stop flashing
	DWORD m_endFlashing;
	// The number of input states; one of StateBitmaps enum
	// HACKHACK georgep: Need to change the number of bits if more states
	UINT m_nInputStates : 4;
	// The Hot flag
	BOOL m_bHot : 1;
	// The current flash state; one of FlashState enum
	// HACKHACK georgep: Need an extra bit since C++ thinks this is signed
	FlashState m_nFlashState : 3;

	// Specialized drawing
	void OnDrawItem(HWND hwnd, const DRAWITEMSTRUCT * lpDrawItem);
	// Change the HWND and forward to the parent
	void OnCommand(HWND hwnd, int id, HWND hwndCtl, UINT codeNotify);
	// Set the Hot control
	BOOL OnSetCursor(HWND hwnd, HWND hwndCursor, UINT codeHitTest, UINT msg);
	// Handles the flashing button
	void OnTimer(HWND hwnd, UINT id);
} ;

class CComboBox;

interface IComboBoxChange : IUnknown
{
	virtual void OnTextChange(CComboBox *pCombo) = 0;
	virtual void OnFocusChange(CComboBox *pCombo, BOOL bSet) = 0;
	virtual void OnSelectionChange(CComboBox *pCombo) = 0;
} ;

// An edit control class that supports using different foreground and
// background colors
class DECLSPEC_UUID("{B4B10DBA-B22F-11d2-9C98-00C04FB17782}")
CComboBox : public CFillWindow
{
public:
	// Default constructor; inits a few intrinsics
	CComboBox();

	operator HWND (void){ return( m_combo ); }

	// Creates the edit control
	BOOL Create(
		HWND hWndParent,				// Parent of the edit control
		UINT height,					// The height of the combo (with drop-down)
		DWORD dwStyle=0,				// Edit control style
		LPCTSTR szTitle=TEXT(""),		// Initial text for the edit control
		IComboBoxChange *pNotify=NULL	// Object to notify of changes
		);

	HRESULT STDMETHODCALLTYPE QueryInterface(REFGUID riid, LPVOID *ppv)
	{
		if (__uuidof(CComboBox) == riid)
		{
			*ppv = this;
			AddRef();
			return(S_OK);
		}
		return(CFillWindow::QueryInterface(riid, ppv));
	}

	void GetDesiredSize(SIZE *ppt);

	// Sets the foreground and background colors and brush to use for painting
	// Set the brush to NULL to indicate using default colors
	void SetColors(HBRUSH hbrBack, COLORREF back, COLORREF fore);

	// Sets the font to use in the edit control
	void SetFont(HFONT hf);

	// Sets the text for the control
	void SetText(
		LPCTSTR szText	// The text to set
		);

	// Gets the text for the control; returns the total text length
	int GetText(
		LPTSTR szText,	// Where to put the text
		int nLen		// The length of the buffer
		);

	// Returns the number of items in the list
	int GetNumItems();

	// Returns the index of the currently selected item
	int GetSelectedIndex();

	// Sets the index of the currently selected item
	void SetSelectedIndex(int index);

	// Adds text to the list; returns the index of the added string
	int AddText(
		LPCTSTR pszText,	// The string to add
		LPARAM lUserData=0	// User data to associate with the string
		);

	// Gets the text for the list item; returns the total text length
	// The string is emptied if there is not enough room for the text
	int GetText(
		UINT index,		// The index of the string to get
		LPTSTR pszText,	// The string buffer to fill
		int nLen		// User data to associate with the string
		);

	// Gets the user data for the list item
	LPARAM GetUserData(
		int index	// The index of the user data to get
		);

	// Removes an item from the list
	void RemoveItem(
		UINT index	// The index of the item to remove
		);

	virtual void Layout();

protected:
	virtual ~CComboBox();

	virtual LRESULT ProcessMessage(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam);

	// Get the info necessary for displaying a tooltip
	virtual void GetSharedTooltipInfo(TOOLINFO *pti);

private:
	// The actual ComboBox control
	HWND m_combo;
	// The background brush
	HBRUSH m_hbrBack;
	// The background color
	COLORREF m_crBack;
	// The foreground color
	COLORREF m_crFore;
	// The font to use
	HFONT m_hfText;
	// The object ot notify of changes
	IComboBoxChange *m_pNotify;

	// I may turn this into a GetWindow call later
	inline HWND GetComboBox()
	{
		return(m_combo);
	}

	// I may turn this into a GetWindow call later
	inline HWND GetEdit()
	{
		// return(reinterpret_cast<HWND>(SendMessage(GetCombo(), CBEM_GETEDITCONTROL, 0, 0));
		return(GetComboBox());
	}

	// Needed to change the edit control colors
	HBRUSH OnCtlColor(HWND hwnd, HDC hdc, HWND hwndChild, int type);

	// Notification of events on the edit control
	void OnCommand(HWND hwnd, int id, HWND hwndCtl, UINT codeNotify);

	// To clean stuff up
	void OnNCDestroy(HWND hwnd);
} ;

class CSeparator : public CGenWindow
{
public:	
	
	// The Separator style
	enum Styles
	{
		Normal = 0,
		Blank,
		NumStates
	} ;

	CSeparator();

	BOOL Create(
		HWND hwndParent, UINT  iStyle = Normal
		);

	virtual void GetDesiredSize(SIZE *ppt);

	void SetDesiredSize(SIZE *psize);

	// Put the single child in the middle
	virtual void Layout();

private:
	// The desired size for the control; defaults to (2,2)
	SIZE m_desSize;
	UINT m_iStyle : 4;

	inline void OnPaint(HWND hwnd);

protected:
	virtual LRESULT ProcessMessage(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam);
} ;

#endif // _EDITTEXT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\h\gencontainers.h ===
// File: GenContainers.h

#ifndef _GENCONTAINERS_H_
#define _GENCONTAINERS_H_

#include "GenWindow.h"

// A bordered window class. A BorderWindow will layout its children on the 8
// points of the compas plus the center. The creator should set the m_uParts
// member to a bitmask of flags saying which parts are actually used. Then the
// children will be layed out in those parts, in the order of the Parts enum
class // DECLSPEC_UUID("")
CBorderWindow : public CGenWindow
{
public:
	// Which parts of the border window are filled with children. The order of
	// the children in the window is the same as the order of these contants
	enum Parts
	{
		TopLeft     = 0x0001,
		Top         = 0x0002,
		TopRight    = 0x0004,
		Left        = 0x0008,
		Center      = 0x0010,
		Right       = 0x0020,
		BottomLeft  = 0x0040,
		Bottom      = 0x0080,
		BottomRight = 0x0100,
	} ;
	enum { NumParts = 9 } ;

	// BUGBUG georgep: We should probably use setters and getters for all of
	// these, so we can force a relayout

	// The horizontal gap between components
	int m_hGap;
	// The vertical gap between components
	int m_vGap;

	// One of the Alignment enum
	UINT m_uParts : 9;

	// Default constructor; inits a few intrinsics
	CBorderWindow();

	// Create the window
	BOOL Create(
		HWND hWndParent	// The parent of the toolbar window
		);

#if FALSE
	HRESULT STDMETHODCALLTYPE QueryInterface(REFGUID riid, LPVOID *ppv)
	{
		if (__uuidof(CBorderWindow) == riid)
		{
			*ppv = this;
			AddRef();
			return(S_OK);
		}
		return(CGenWindow::QueryInterface(riid, ppv));
	}
#endif // FALSE

	virtual void GetDesiredSize(SIZE *ppt);

	virtual void Layout();

protected:
	virtual ~CBorderWindow() {}

	// Forward WM_COMMAND messages to the parent window
	virtual LRESULT ProcessMessage(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam);

	virtual void OnCommand(HWND hwnd, int id, HWND hwndCtl, UINT codeNotify);

private:
	UINT CBorderWindow::GetDesiredSize(
		HWND hwnds[CBorderWindow::NumParts],
		SIZE sizes[CBorderWindow::NumParts],
		int rows[3],
		int cols[3],
		SIZE *psize);
} ;

// A toolbar window class. A toolbar window will layout its children generally
// from left-to-right or top-to-bottom, with margins around and gaps between
// children, filling the window if specified. See the definitions for the
// public fields.
class DECLSPEC_UUID("{0BFB8454-ACA4-11d2-9C97-00C04FB17782}")
CToolbar : public CGenWindow
{
public:
	// Where to align the children in the direction perpendicular to the flow:
	// in a horizontal toolbar, TopLeft will mean Top,and BottomRight will
	// mean Bottom
	enum Alignment
	{
		TopLeft = 0,
		Center,
		BottomRight,
		Fill,
	} ;

	// BUGBUG georgep: We should probably use setters and getters for all of
	// these, so we can force a relayout

	// The maximum gap between components
	int m_gap;
	// The left and right margin
	int m_hMargin;
	// The top and bottom margin
	int m_vMargin;
	// Start index of right-aligned children; they will still get layed out
	// left to right
	UINT m_uRightIndex;

	// One of the Alignment enum
	// HACKHACK georgep: I need to use an extra bit, or C++ gets confused by
	// the top bit (thinks it's signed)
	Alignment m_nAlignment : 3;
	// Vertical layout if TRUE
	BOOL m_bVertical : 1;
	// If TRUE, the child before m_uRightIndex will fill the center are of the
	// toolbar
	BOOL m_bHasCenterChild : 1;
	// HACKHACK georgep: Layout in reverse order if TRUE; this lets me fix
	// weird tabbing order problems
	BOOL m_bReverseOrder : 1;
	// Set this if you don't want the gaps calculated in the desired size
	BOOL m_bMinDesiredSize : 1;

	// Default constructor; inits a few intrinsics
	CToolbar();

	// Create the toolbar window
	BOOL Create(
		HWND hWndParent,	// The parent of the toolbar window
		DWORD dwExStyle=0	// The extended style of the toolbar window
		);

	HRESULT STDMETHODCALLTYPE QueryInterface(REFGUID riid, LPVOID *ppv)
	{
		if (__uuidof(CToolbar) == riid)
		{
			*ppv = this;
			AddRef();
			return(S_OK);
		}
		return(CGenWindow::QueryInterface(riid, ppv));
	}

	IGenWindow* FindControl(int nID);

	virtual void GetDesiredSize(SIZE *ppt);

	virtual void Layout();

protected:
	virtual ~CToolbar() {}

	// Forward WM_COMMAND messages to the parent window
	virtual LRESULT ProcessMessage(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam);

	virtual void OnCommand(HWND hwnd, int id, HWND hwndCtl, UINT codeNotify);

private:
	void AdjustPos(POINT *pPos, SIZE *pSize, UINT width);

	// Get the first child to layout
	HWND GetFirstKid();
	// Get the next child to layout
	HWND GetNextKid(
		HWND hwndCurrent	// The current child
		);
} ;

// Just makes the first child fill the client area
class CFillWindow : public CGenWindow
{
public:
	// Just makes the first child fill the client area
	virtual void Layout();

	virtual void GetDesiredSize(SIZE *psize);

	// Get the info necessary for displaying a tooltip
	virtual void GetSharedTooltipInfo(TOOLINFO *pti);

protected:
	HWND GetChild() { return(GetTopWindow(GetWindow())); }
} ;


// Maybe someday I will add a label for this, and multiple border types
class CEdgedWindow : public CGenWindow
{
private:
	enum { s_nBorder = 2 };
	int GetBorderWidth() { return(s_nBorder); }

public:
	// BUGBUG georgep: We should probably use setters and getters for all of
	// these, so we can force a relayout

	// The left and right margin
	int m_hMargin;
	// The top and bottom margin
	int m_vMargin;

	CEdgedWindow();
	~CEdgedWindow();

	BOOL Create(HWND hwndParent);

	// Just makes the first child fill the client area - the border
	virtual void Layout();

	virtual void GetDesiredSize(SIZE *psize);

	void SetHeader(CGenWindow *pHeader);
	CGenWindow *GetHeader() { return(m_pHeader); }

private:
	CGenWindow *m_pHeader;

	// Get the content window
	HWND GetContentWindow();

	void OnPaint(HWND hwnd);

protected:
	LRESULT ProcessMessage(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam);
} ;

class CLayeredView : public CGenWindow
{
public:
	enum LayoutStyle
	{
		Center = 0,
		Fill,
		NumStyles
	} ;

	// I should make accessor methods for this
	// The layout style for the window
	LayoutStyle m_lStyle;

	CLayeredView() : m_lStyle(Center) {}

	BOOL Create(
		HWND hwndParent,	// The parent of this window
		DWORD dwExStyle=WS_EX_CONTROLPARENT	// The extended style
		);

	virtual void GetDesiredSize(SIZE *psize);

	virtual void Layout();
} ;

class DECLSPEC_UUID("{5D573806-CD09-11d2-9CA9-00C04FB17782}")
CFrame : public CFillWindow
{
public:
	BOOL Create(
		HWND hWndOwner,			// Window owner
		LPCTSTR szWindowName,	// Window name
		DWORD dwStyle,			// Window style
		DWORD dwEXStyle,		// Extended window style
		int x,					// Window pos: x
		int y,					// Window pos: y
		int nWidth,				// Window size: width
		int nHeight,			// Window size: height
		HINSTANCE hInst,		// The hInstance to create the window on
		HICON hIcon=NULL,		// The icon for the window
		HMENU hmMain=NULL,		// Window menu
		LPCTSTR szClassName=NULL	// The class name to use
		);

	HRESULT STDMETHODCALLTYPE QueryInterface(REFGUID riid, LPVOID *ppv)
	{
		if (__uuidof(CFrame) == riid)
		{
			*ppv = this;
			AddRef();
			return(S_OK);
		}
		return(CFillWindow::QueryInterface(riid, ppv));
	}

	virtual void OnDesiredSizeChanged();

	BOOL SetForeground();

	// Update the size immediately
	void Resize();

	void MoveEnsureVisible(int x, int y);

protected:
	virtual LRESULT ProcessMessage(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);

private:
	// Handle messages
	void OnPaletteChanged(HWND hwnd, HWND hwndPaletteChange);
	BOOL OnQueryNewPalette(HWND hwnd);

	// Delayed resizing when the desired size changes
	static void Resize(CGenWindow *pThis, WPARAM wParam);

	// Select and realize the proper palette
	BOOL SelAndRealizePalette(BOOL bBackground);
} ;

#endif // _GENCONTAINERS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\h\fnobjs.h ===
#ifndef __FnObjs_h__
#define __FnObjs_h__


class IsEqLPTSTR
{
private:

	LPCTSTR m_pcsz;

public:
	IsEqLPTSTR( LPCTSTR pcsz ) : m_pcsz( pcsz ) { ; }
    bool operator() ( LPCTSTR pcsz ) 
	{
		return ( 0 == lstrcmp( pcsz, m_pcsz ) );
    }

};


template< class T > 
class IsEq
{

	const T& m_rT;
public:
	IsEq( const T& rT ) : m_rT( rT ) { ; }

    bool operator() ( const T& rT ) 
	{
		return rT == m_rT;
    }
};


#endif // __FnObjs_h__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\h\fsmenu.h ===
#ifndef _FSMENU_H
#define _FSMENU_H
//---------------------------------------------------------------------------
//
//---------------------------------------------------------------------------

typedef enum
{
	FMF_NONE	 	= 0x0000,
	FMF_NOEMPTYITEM		= 0x0001,
        FMF_INCLUDEFOLDERS      = 0x0002,
        FMF_NOPROGRAMS      	= 0x0004,
        FMF_FILESMASK      	= 0x0007,
        FMF_LARGEICONS      	= 0x0008,
        FMF_NOBREAK      	= 0x0010,
        FMF_NOABORT      	= 0x0020,
} FMFLAGS;

#define FMAI_SEPARATOR		0x00000001

typedef void (CALLBACK *PFNFMCALLBACK)(LPITEMIDLIST, LPITEMIDLIST);

WINSHELLAPI UINT 	WINAPI FileMenu_ReplaceUsingPidl(HMENU hmenu, UINT idNewItems,  LPITEMIDLIST pidl, UINT fMenuFilter, PFNFMCALLBACK pfncb);
WINSHELLAPI BOOL 	WINAPI FileMenu_InitMenuPopup(HMENU hmenu);
WINSHELLAPI LRESULT WINAPI FileMenu_DrawItem(HWND hwnd, DRAWITEMSTRUCT FAR *lpdi);
WINSHELLAPI LRESULT WINAPI FileMenu_MeasureItem(HWND hwnd, MEASUREITEMSTRUCT FAR *lpmi);
WINSHELLAPI UINT 	WINAPI FileMenu_DeleteAllItems(HMENU hmenu);
WINSHELLAPI LRESULT WINAPI FileMenu_HandleMenuChar(HMENU hmenu, char ch);
WINSHELLAPI BOOL 	WINAPI FileMenu_GetLastSelectedItemPidls(HMENU hmenu, LPITEMIDLIST *ppidlFolder, LPITEMIDLIST *ppidlItem);
WINSHELLAPI HMENU 	WINAPI FileMenu_FindSubMenuByPidl(HMENU hmenu, LPITEMIDLIST pidl);
WINSHELLAPI UINT 	WINAPI FileMenu_InsertUsingPidl(HMENU hmenu, UINT idNewItems,  LPITEMIDLIST pidl, FMFLAGS fmf, UINT fMenuFilter, PFNFMCALLBACK pfncb);
WINSHELLAPI void 	WINAPI FileMenu_Invalidate(HMENU hmenu);
WINSHELLAPI HMENU   WINAPI FileMenu_Create(COLORREF clr, int cxBmpGap, HBITMAP hbmp, int cySel, FMFLAGS fmf);
WINSHELLAPI BOOL    WINAPI FileMenu_AppendItem(HMENU hmenu, LPSTR psz, UINT id, int iImage, HMENU hmenuSub, UINT cyItem);
WINSHELLAPI BOOL    WINAPI FileMenu_TrackPopupMenuEx(HMENU hmenu, UINT Flags, int x, int y, HWND hwndOwner, LPTPMPARAMS lpTpm);
WINSHELLAPI BOOL 	WINAPI FileMenu_DeleteItemByCmd(HMENU hmenu, UINT id);
WINSHELLAPI void 	WINAPI FileMenu_Destroy(HMENU hmenu);
WINSHELLAPI BOOL 	WINAPI FileMenu_EnableItemByCmd(HMENU hmenu, UINT id, BOOL fEnable);
WINSHELLAPI BOOL 	WINAPI FileMenu_DeleteSeparator(HMENU hmenu);
WINSHELLAPI BOOL 	WINAPI FileMenu_DeleteMenuItemByFirstID(HMENU hmenu, UINT id);
WINSHELLAPI DWORD 	WINAPI FileMenu_GetItemExtent(HMENU hmenu, UINT iItem);
WINSHELLAPI BOOL 	WINAPI FileMenu_DeleteItemByIndex(HMENU hmenu, UINT iItem);
WINSHELLAPI void 	WINAPI FileMenu_AbortInitMenu(void);

#endif //_FSMENU_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\h\endsesn.h ===
#ifndef _ENDSESN_H_
#define _ENDSESN_H_

#include <tchar.h>

static const TCHAR NM_ENDSESSION_MSG_NAME[] = _TEXT("NetMeeting_EndSession");
static const UINT g_cuEndSessionMsgTimeout = 0x7FFFFFFF; // milliseconds
static const UINT g_cuEndSessionAbort = 0xF0F0;

// used in conf.exe, defined in conf.cpp
extern UINT g_uEndSessionMsg;

#endif // _ENDSESN_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\h\debspew.h ===
/*
 * debspew.h - Debug macros and their retail translations.
 *
 * Taken from URL code by ChrisPi 9-11-95
 *
 */

#ifndef _DEBSPEW_H_
#define _DEBSPEW_H_
#include <nmutil.h>

#ifdef __cplusplus
extern "C" {
#endif /* __cplusplus */

#include <tchar.h>
#include <limits.h>
#include <shlobj.h>

#include "stock.h"
#include "olestock.h"

#ifdef DEBUG
#include "inifile.h"
#include "resstr.h"
#endif /* DEBUG */

#include "valid.h"
#include "olevalid.h"


#define DATA_SEG_READ_ONLY       ".text"
#define DATA_SEG_PER_INSTANCE    ".data"
#define DATA_SEG_SHARED          ".shared"


/* parameter validation macros */

/*
 * call as:
 *
 * bPTwinOK = IS_VALID_READ_PTR(ptwin, CTWIN);
 *
 * bHTwinOK = IS_VALID_HANDLE(htwin, TWIN);
 */

#ifdef DEBUG

#define IS_VALID_READ_PTR(ptr, type) \
   (IsBadReadPtr((ptr), sizeof(type)) ? \
    (ERROR_OUT(("invalid %s read pointer - %#08lx", (PCSTR)"P"#type, (ptr))), FALSE) : \
    TRUE)

#define IS_VALID_WRITE_PTR(ptr, type) \
   (IsBadWritePtr((PVOID)(ptr), sizeof(type)) ? \
    (ERROR_OUT(("invalid %s write pointer - %#08lx", (PCSTR)"P"#type, (ptr))), FALSE) : \
    TRUE)

#define IS_VALID_STRING_PTR_A(ptr, type) \
   (IsBadStringPtrA((ptr), (UINT)-1) ? \
    (ERROR_OUT(("invalid %s pointer - %#08lx", (PCSTR)"P"#type, (ptr))), FALSE) : \
    TRUE)

#define IS_VALID_STRING_PTR_W(ptr, type) \
   (IsBadStringPtrW((ptr), (UINT)-1) ? \
    (ERROR_OUT(("invalid %s pointer - %#08lx", (PCSTR)"P"#type, (ptr))), FALSE) : \
    TRUE)

#if defined(UNICODE)
#define IS_VALID_STRING_PTR IS_VALID_STRING_PTR_W
#else // defined(UNICODE)
#define IS_VALID_STRING_PTR IS_VALID_STRING_PTR_A
#endif // defined(UNICODE)


#define IS_VALID_CODE_PTR(ptr, type) \
   (IsBadCodePtr((FARPROC)(ptr)) ? \
    (ERROR_OUT(("invalid %s code pointer - %#08lx", (PCSTR)#type, (ptr))), FALSE) : \
    TRUE)

#define IS_VALID_READ_BUFFER_PTR(ptr, type, len) \
   (IsBadReadPtr((ptr), len) ? \
    (ERROR_OUT(("invalid %s read pointer - %#08lx", (PCSTR)"P"#type, (ptr))), FALSE) : \
    TRUE)

#define IS_VALID_WRITE_BUFFER_PTR(ptr, type, len) \
   (IsBadWritePtr((ptr), len) ? \
    (ERROR_OUT(("invalid %s write pointer - %#08lx", (PCSTR)"P"#type, (ptr))), FALSE) : \
    TRUE)

#define FLAGS_ARE_VALID(dwFlags, dwAllFlags) \
   (((dwFlags) & (~(dwAllFlags))) ? \
    (ERROR_OUT(("invalid flags set - %#08lx", ((dwFlags) & (~(dwAllFlags))))), FALSE) : \
    TRUE)

#else

#define IS_VALID_READ_PTR(ptr, type) \
   (! IsBadReadPtr((ptr), sizeof(type)))

#define IS_VALID_WRITE_PTR(ptr, type) \
   (! IsBadWritePtr((PVOID)(ptr), sizeof(type)))

#define IS_VALID_STRING_PTR(ptr, type) \
   (! IsBadStringPtr((ptr), (UINT)-1))

#define IS_VALID_CODE_PTR(ptr, type) \
   (! IsBadCodePtr((FARPROC)(ptr)))

#define IS_VALID_READ_BUFFER_PTR(ptr, type, len) \
   (! IsBadReadPtr((ptr), len))

#define IS_VALID_WRITE_BUFFER_PTR(ptr, type, len) \
   (! IsBadWritePtr((ptr), len))

#define FLAGS_ARE_VALID(dwFlags, dwAllFlags) \
   (((dwFlags) & (~(dwAllFlags))) ? FALSE : TRUE)

#endif

/* handle validation macros */

#ifdef DEBUG

#define IS_VALID_HANDLE(hnd, type) \
   (IsValidH##type(hnd) ? \
    TRUE : \
    (ERROR_OUT(("invalid H" #type " - %#08lx", (hnd))), FALSE))

#else

#define IS_VALID_HANDLE(hnd, type) \
   (IsValidH##type(hnd))

#endif

/* structure validation macros */

#ifdef VSTF

#ifdef DEBUG

#define IS_VALID_STRUCT_PTR(ptr, type) \
   (IsValidP##type(ptr) ? \
    TRUE : \
    (ERROR_OUT(("invalid %s pointer - %#08lx", (PCSTR)"P"#type, (ptr))), FALSE))

#else

#define IS_VALID_STRUCT_PTR(ptr, type) \
   (IsValidP##type(ptr))

#endif

#else

#define IS_VALID_STRUCT_PTR(ptr, type) \
   (! IsBadReadPtr((ptr), sizeof(type)))

#endif

/* OLE interface validation macro */

#define IS_VALID_INTERFACE_PTR(ptr, iface) \
   IS_VALID_STRUCT_PTR(ptr, C##iface)



#ifdef DEBUG

#define CALLTRACE_OUT(s) DbgZPrintFunction s

#define DebugEntry(szFunctionName) \
   (CALLTRACE_OUT((#szFunctionName "() entered.")), \
    StackEnter())

#define DebugExit(szFunctionName, szResult) \
   (StackLeave(), \
    CALLTRACE_OUT(("%s() exiting, returning %s.", #szFunctionName, szResult)))

#define DebugExitBOOL(szFunctionName, bool) \
   DebugExit(szFunctionName, GetBOOLString(bool))

#define DebugExitCOMPARISONRESULT(szFunctionName, cr) \
   DebugExit(szFunctionName, GetCOMPARISONRESULTString(cr))

#define DebugExitDWORD(szFunctionName, dw) \
   DebugExitULONG(szFunctionName, dw)

#define DebugExitHRESULT(szFunctionName, hr) \
   DebugExit(szFunctionName, GetHRESULTString(hr))

#define DebugExitINT(szFunctionName, n) \
   DebugExit(szFunctionName, GetINTString(n))

#define DebugExitINT_PTR(szFunctionName, n) \
   DebugExit(szFunctionName, GetINT_PTRString(n))

#define DebugExitULONG(szFunctionName, ul) \
   DebugExit(szFunctionName, GetULONGString(ul))

#define DebugExitVOID(szFunctionName) \
   (StackLeave(), \
    CALLTRACE_OUT(("%s() exiting.", #szFunctionName)))

#define DebugExitPVOID(szFunctionName, ptr) \
   DebugExit(szFunctionName, GetPVOIDString(ptr))

#else

#define DebugEntry(szFunctionName)
#define DebugExit(szFunctionName, szResult)
#define DebugExitBOOL(szFunctionName, bool)
#define DebugExitCOMPARISONRESULT(szFunctionName, cr)
#define DebugExitDWORD(szFunctionName, dw)
#define DebugExitHRESULT(szFunctionName, hr)
#define DebugExitINT(szFunctionName, n)
#define DebugExitINT_PTR(szFunctionName, n)
#define DebugExitULONG(szFunctionName, ul)
#define DebugExitVOID(szFunctionName)
#define DebugExitPVOID(szFunctionName, ptr)

#endif


/* Types
 ********/

/* g_dwSpewFlags flags */

typedef enum _spewflags
{
   SPEW_FL_SPEW_PREFIX        = 0x0001,

   SPEW_FL_SPEW_LOCATION      = 0x0002,

   ALL_SPEW_FLAGS             = (SPEW_FL_SPEW_PREFIX |
                                 SPEW_FL_SPEW_LOCATION)
}
SPEWFLAGS;

/* g_uSpewSev values */

typedef enum _spewsev
{
   SPEW_TRACE,

   SPEW_CALLTRACE,

   SPEW_WARNING,

   SPEW_ERROR,

   SPEW_FATAL
}
SPEWSEV;


/* Prototypes
 *************/

/* debspew.c */

#ifdef DEBUG

extern BOOL             SetDebugModuleIniSwitches(void);
extern BOOL  NMINTERNAL InitDebugModule(PCSTR);
extern void  NMINTERNAL ExitDebugModule(void);
extern void  NMINTERNAL StackEnter(void);
extern void  NMINTERNAL StackLeave(void);
extern ULONG_PTR NMINTERNAL GetStackDepth(void);
extern void             SpewOut(PCSTR pcszFormat, ...);
extern DWORD NMINTERNAL GetDebugOutputFlags(VOID);
extern VOID  NMINTERNAL SetDebugOutputFlags(DWORD dw);

#else // DEBUG

#define SetDebugModuleIniSwitches()
#define InitDebugModule(str)
#define ExitDebugModule()
#define StackEnter()
#define StackLeave()
#define GetStackDepth()
//#define SpewOut(fmt, ...)
#define GetDebugOutputFlags()
#define SetDebugOutputFlags(dw)

#endif // DEBUG


/* Global Variables
 *******************/

#ifdef DEBUG

/* dbg.cpp */
extern HDBGZONE ghDbgZone;

/* debspew.c */

extern DWORD g_dwSpewFlags;
extern UINT g_uSpewSev;
extern UINT g_uSpewLine;
extern PCSTR g_pcszSpewFile;
extern WINDOWPLACEMENT g_wpSpew;

/* defined by client */

extern PCSTR g_pcszSpewModule;

#endif



/*
 * EVAL() may only be used as a logical expression.
 *
 * E.g.,
 *
 * if (EVAL(exp))
 *    bResult = TRUE;
 */

#ifdef DEBUG

#define EVAL(exp) \
   ((exp) || \
    (ERROR_OUT(("evaluation failed '%s'", (PCSTR)#exp)), 0))

#else

#define EVAL(exp) \
   ((exp) != 0)

#endif   /* DEBUG */


#ifdef __cplusplus
}
#endif /* __cplusplus */



#endif /* _DEBSPEW_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\h\iacapapi.h ===
/*
 *  	File: iacapapi.h
 *
 *      Network audio application capability interface. Provides
 * 		APIs for enumerating, prioritizing, and enabling/disabling
 *		codecs independently for send/receive.
 *
 *		Revision History:
 *
 *		06/06/96	mikev	created
 *		02/05/97	yoramy	moved most of what was here to appavcap.h
 */


#ifndef _IACAPAPI_H
#define _IACAPAPI_H

#include "appavcap.h"

#include <pshpack8.h> /* Assume 8 byte packing throughout */

#ifndef DECLARE_INTERFACE_PTR
#ifdef __cplusplus
#define DECLARE_INTERFACE_PTR(iface, piface)                       \
	interface iface; typedef iface FAR * piface
#else
#define DECLARE_INTERFACE_PTR(iface, piface)                       \
	typedef interface iface iface, FAR * piface
#endif
#endif /* DECLARE_INTERFACE_PTR */


//Interface declarations:
//
// IAppAudioCap, IAppVidCap and IDualPubCap
//
//


//This is the interface to the Audio Class

#undef INTERFACE
#define INTERFACE IAppAudioCap
DECLARE_INTERFACE( IAppAudioCap )
{
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;
    STDMETHOD (GetNumFormats) (THIS_ UINT *puNumFmtOut) PURE;
    STDMETHOD (ApplyAppFormatPrefs) (THIS_ PBASIC_AUDCAP_INFO pFormatPrefsBuf,
		UINT uNumFormatPrefs) PURE;
    STDMETHOD (EnumFormats) (THIS_ PBASIC_AUDCAP_INFO pFmtBuf, UINT uBufsize,
		UINT *uNumFmtOut) PURE;
    STDMETHOD (EnumCommonFormats) (THIS_ PBASIC_AUDCAP_INFO pFmtBuf, UINT uBufsize,
		UINT *uNumFmtOut, BOOL bTXCaps) PURE;
	STDMETHOD (GetBasicAudcapInfo) (THIS_ AUDIO_FORMAT_ID Id,
		PBASIC_AUDCAP_INFO pFormatPrefsBuf) PURE;		
	STDMETHOD (AddACMFormat) (THIS_ LPWAVEFORMATEX lpwfx, PAUDCAP_INFO pAudCapInfo) PURE;
	STDMETHOD (RemoveACMFormat) (THIS_ LPWAVEFORMATEX lpwfx) PURE;
	STDMETHOD_ (LPVOID, GetFormatDetails) (THIS_ AUDIO_FORMAT_ID Id) PURE;

};

DECLARE_INTERFACE_PTR(IAppAudioCap,  LPAPPCAPPIF);
HRESULT WINAPI CreateAppCapInterface(LPAPPCAPPIF *ppAppCap);

#define CREATEIAPPCAPNAME	(_TEXT("CreateAppCapInterface"))
typedef HRESULT (WINAPI *CREATEIAPPCAPPROC) (LPAPPCAPPIF *ppAppCap);

//This is the interface to the Video Class
#undef INTERFACE
#define INTERFACE IAppVidCap
DECLARE_INTERFACE( IAppVidCap )
{
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;
    STDMETHOD (GetNumFormats) (THIS_ UINT *puNumFmtOut) PURE;
    STDMETHOD (ApplyAppFormatPrefs) (THIS_ PBASIC_VIDCAP_INFO pFormatPrefsBuf,
		UINT uNumFormatPrefs) PURE;
    STDMETHOD (EnumFormats) (THIS_ PBASIC_VIDCAP_INFO pFmtBuf, UINT uBufsize,
		UINT *uNumFmtOut) PURE;
    STDMETHOD (EnumCommonFormats) (THIS_ PBASIC_VIDCAP_INFO pFmtBuf, UINT uBufsize,
		UINT *uNumFmtOut, BOOL bTXCaps) PURE;		
	STDMETHOD (GetBasicVidcapInfo) (THIS_ VIDEO_FORMAT_ID Id,
		PBASIC_VIDCAP_INFO pFormatPrefsBuf) PURE;		
	STDMETHOD (AddVCMFormat) (THIS_ PVIDEOFORMATEX lpvfx, PVIDCAP_INFO pVidCapInfo) PURE;
	STDMETHOD (RemoveVCMFormat) (THIS_ PVIDEOFORMATEX lpvfx) PURE;
	STDMETHOD_ (PVIDEOFORMATEX, GetVidcapDetails) (THIS_ VIDEO_FORMAT_ID Id) PURE;
	STDMETHOD (GetPreferredFormatId) (THIS_ VIDEO_FORMAT_ID *pId) PURE;		
	STDMETHOD (SetDeviceID)(THIS_ DWORD dwDeviceID) PURE;			
	
};

DECLARE_INTERFACE_PTR(IAppVidCap,  LPAPPVIDCAPPIF);
HRESULT WINAPI CreateAppVidCapInterface(LPAPPVIDCAPPIF *ppAppVidCap);

#define CREATEIAPPVIDCAPNAME	(_TEXT("CreateAppVidCapInterface"))
typedef HRESULT (WINAPI *CREATEIAPPVIDCAPPROC) (LPAPPVIDCAPPIF *ppAppVidCap);



//This is the app's interface to the CapsCtl Class

#undef INTERFACE
#define INTERFACE IDualPubCap
DECLARE_INTERFACE( IDualPubCap )
{
	STDMETHOD_(ULONG,  AddRef()) =0;
	STDMETHOD_(ULONG, Release())=0;
	STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR * ppvObj) PURE;
	STDMETHOD_(BOOL, Init())=0;
	STDMETHOD(ReInitialize())=0;
};


DECLARE_INTERFACE_PTR(IDualPubCap, LPCAPSIF);
HRESULT WINAPI CreateCapsInterface(LPCAPSIF *ppAppCap);

#define CREATEICAPSNAME	(_TEXT("CreateCapsInterface"))
typedef HRESULT (WINAPI *CREATEICAPSPROC) (LPCAPSIF *ppCapsIF);



#include <poppack.h> /* End byte packing */


#endif	//#ifndef _IACAPAPI_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\h\icomchan.h ===
/*
 *  	File: icomchan.h
 *
 *      Network media channel interface definitions 
 *
 *		Revision History:
 *
 *		10/09/96	mikev	created
 */
 

#ifndef _ICOMCHAN_H
#define _ICOMCHAN_H

#include "incommon.h"
#include "iprop.h"

//
// 	status code definitions for channel events passed upward 
//  to IH323ConfAdvise::ChannelEvent();
//
#define CHANNEL_OPEN		0x00000001	
#define CHANNEL_ACTIVE		0x00000002	// started streaming

#define CHANNEL_REJECTED	 	0x00000003	
#define CHANNEL_NO_CAPABILITY	0x00000004	// remote end is not capable of supporting
											// the media type of this channel
#define CHANNEL_CLOSED		    0x00000005
#define CHANNEL_OPEN_ERROR		0x00000007

#define CHANNEL_VIDEO_TS_TRADEOFF 	0x00000008
#define CHANNEL_REMOTE_PAUSE_ON     0x00000009
#define CHANNEL_REMOTE_PAUSE_OFF    0x0000000A

//
//	ICommChannel
//

#undef INTERFACE
#define INTERFACE ICommChannel
DECLARE_INTERFACE(ICommChannel)
{
	STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR * ppvObj) PURE;	
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;
	STDMETHOD(GetProperty)(THIS_ DWORD prop, PVOID pBuf, LPUINT pcbBuf) PURE;
	STDMETHOD(SetProperty)(THIS_ DWORD prop, PVOID pBuf, UINT cbBuf) PURE;
	STDMETHOD(IsChannelOpen)(THIS_ BOOL *pbOpen) PURE;
	STDMETHOD(Open)(THIS_ DWORD dwLocalFormatID, IH323Endpoint *pConnection) PURE;
 	STDMETHOD(Close)(THIS) PURE;
    STDMETHOD(SetAdviseInterface)(THIS_ interface IH323ConfAdvise *pH323ConfAdvise) PURE;
	STDMETHOD(EnableOpen)(THIS_ BOOL bEnable)PURE;
	STDMETHOD(GetMediaType)(THIS_ LPGUID pGuid)PURE; 
    STDMETHOD_(BOOL, IsSendChannel) (THIS) PURE;
    STDMETHOD_(IMediaChannel *, GetMediaChannel) (THIS) PURE;
   	STDMETHOD(Preview)(THIS_ MEDIA_FORMAT_ID idLocalFormat, 
   	    IMediaChannel * pMediaChannel)PURE;
   	STDMETHOD(PauseNetworkStream)(THIS_ BOOL fPause)PURE;
    STDMETHOD_(BOOL, IsNetworkStreamPaused)(THIS) PURE;
    STDMETHOD_(BOOL, IsRemotePaused)(THIS) PURE;
    STDMETHOD_(MEDIA_FORMAT_ID, GetConfiguredFormatID) (THIS) PURE;    
   	STDMETHOD(GetRemoteAddress)(THIS_ PSOCKADDR_IN pAddrOutput) PURE;
};

#undef INTERFACE
#define INTERFACE IStreamSignal
DECLARE_INTERFACE(IStreamSignal)
{
	STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR * ppvObj) PURE;	
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;
    STDMETHOD(PictureUpdateRequest)(THIS)PURE;
    STDMETHOD(GetVersionInfo)(THIS_  
        PCC_VENDORINFO* ppLocalVendorInfo, PCC_VENDORINFO *ppRemoteVendorInfo) PURE;
};

// 
// IVideoDevice
// 

#undef INTERFACE
#define INTERFACE IVideoDevice
DECLARE_INTERFACE(IVideoDevice)
{
	STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR * ppvObj) PURE;	
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

	// Capture Device related methods
	STDMETHOD(GetNumCapDev)(THIS) PURE;
	STDMETHOD(GetMaxCapDevNameLen)(THIS) PURE;
	STDMETHOD(EnumCapDev)(THIS_ DWORD *pdwCapDevIDs, TCHAR *pszCapDevNames, DWORD dwNumCapDev) PURE;
	STDMETHOD(GetCurrCapDevID)(THIS) PURE;
	STDMETHOD(SetCurrCapDevID)(THIS_ int nCapDevID) PURE;
	
};


#endif	//#ifndef _ICOMCHAN_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\h\genwindow.h ===
// File: GenWindow.h

#ifndef _GenWINDOW_H_
#define _GenWINDOW_H_

#include "Referenc.h"

// Minimal interface for windows to talk to each other
interface DECLSPEC_UUID("{9B677AA6-ACA3-11d2-9C97-00C04FB17782}")
IGenWindow : public IUnknown
{
public:
	// Retrieve the desired size of a window so parents can layout their
	// children in an abstract manner
	virtual void GetDesiredSize(
		SIZE *psize	// The returned desired size
		) = 0;

	// Method to call when the desired size for a GenWindow changes
	virtual void OnDesiredSizeChanged() = 0;

	// Get the background brush to use
	virtual HBRUSH GetBackgroundBrush() = 0;

	// Get the palette the app is using
	virtual HPALETTE GetPalette() = 0;

	// Get the LPARAM of user data
	virtual LPARAM GetUserData() = 0;

	// Sends the registered c_msgFromHandle message to the hwnd. The hwnd
	// should return an IGenWindow* from that message
	static IGenWindow *FromHandle(
		HWND hwnd	// The hwnd to get the IGenWindow* from
		);

protected:
	// Registered message for retrieving the IGenWindow*
	static const DWORD c_msgFromHandle;
} ;

// Generic window class. Override the ProcessMessage method to add your own
// functionality
class DECLSPEC_UUID("{CEEA6922-ACA3-11d2-9C97-00C04FB17782}")
CGenWindow : REFCOUNT, public IGenWindow
{
public:
	typedef void (*InvokeProc)(CGenWindow *pWin, WPARAM wParam);

	// Default constructor; inits a few intrinsics
	CGenWindow();

	// Create the window, analagous to Win32's CreateWindowEx. Only the
	// class name is missing, since CGenWindow works only for its own window
	// class
	BOOL Create(
		HWND hWndParent,		// Window parent
		LPCTSTR szWindowName,	// Window name
		DWORD dwStyle,			// Window style
		DWORD dwEXStyle,		// Extended window style
		int x,					// Window pos: x
		int y,					// Window pos: y
		int nWidth,				// Window size: width
		int nHeight,			// Window size: height
		HINSTANCE hInst,		// The hInstance to create the window on
		HMENU hmMain=NULL,		// Window menu
		LPCTSTR szClassName=NULL	// The class name to use
		);

	// Create a child window, analagous to Win32's CreateWindowEx. The class
	// name is missing, since CGenWindow works only for its own window class.
	// Size and pos are also missing since most children will get layed out by
	// their parent.
	BOOL Create(
		HWND hWndParent,		// Window parent
		INT_PTR nId=0,				// ID of the child window
		LPCTSTR szWindowName=TEXT(""),	// Window name
		DWORD dwStyle=0,			// Window style; WS_CHILD|WS_VISIBLE will be added to this
		DWORD dwEXStyle=WS_EX_CONTROLPARENT	// Extended window style
		);

	// Return the HWND
	inline HWND GetWindow()
	{
		return(m_hwnd);
	}

	// Override if you want to layout your window in a specific way when it
	// resizes.
	// Making this public so it can be forced on a window.
	virtual void Layout()
	{
	}

	// begin IGenWindow interface
	virtual HRESULT STDMETHODCALLTYPE QueryInterface(REFGUID iid, LPVOID *pObj);
	virtual ULONG STDMETHODCALLTYPE AddRef(void) { return(REFCOUNT::AddRef()); }
	virtual ULONG STDMETHODCALLTYPE Release(void) { return(REFCOUNT::Release()); }

	virtual void GetDesiredSize(SIZE *ppt);

	// Forward the notification to the parent
	virtual void OnDesiredSizeChanged();

	// Get the background brush to use; use parent's by default
	virtual HBRUSH GetBackgroundBrush();

	// Get the palette the app is using
	virtual HPALETTE GetPalette();

	// Get the LPARAM of user data
	virtual LPARAM GetUserData();

	// end IGenWindow interface

	void SetUserData(LPARAM lUserData) { m_lUserData = lUserData; }

	// Set the global Hot control
	static void SetHotControl(CGenWindow *pHot);

	// Do a layout on this window at some time soon
	void ScheduleLayout();

	// Invoke on a posted message
	BOOL AsyncInvoke(InvokeProc proc, WPARAM wParam);

	// Set the tooltip for this window
	void SetTooltip(LPCTSTR pszTip);
	// Remove the tooltip for this window
	void RemoveTooltip();

	// Get the standard palette for drawing
	static HPALETTE GetStandardPalette();
	// Delete the standard palette for drawing
	static void DeleteStandardPalette();

	// Get the standard palette for drawing
	static HBRUSH GetStandardBrush();
	// Delete the standard palette for drawing
	static void DeleteStandardBrush();

protected:
	// Virtual destructor so clients can provide specific destruction code
	// This is protected to indicate that only Release should call it, not
	// creators of this object. I'd rather make it private, but then extenders
	// would not work.
	virtual ~CGenWindow();

	// The virtual window procedure. Override this to add specific behavior.
	virtual LRESULT ProcessMessage(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam);

	// Set this control to be hot
	virtual void SetHot(BOOL bHot);
	// Is this control currently hot
	virtual BOOL IsHot();

	// Get the info necessary for displaying a tooltip
	virtual void GetSharedTooltipInfo(TOOLINFO *pti);

private:
	// The current hot control
	static CGenWindow *g_pCurHot;
	// The standard palette
	static HPALETTE g_hPal;
	// Whether we actually need a palette or not
	static BOOL g_bNeedPalette;
	// The standard background brush
	static HBRUSH g_hBrush;
	// The single list of tooltip windows
	static class CTopWindowArray *g_pTopArray;

	// Stuff nobody should ever do
	CGenWindow(const CGenWindow& rhs);
	CGenWindow& operator=(const CGenWindow& rhs);

	// The window class name
	static const LPCTSTR c_szGenWindowClass;

	// Initalizes the window class
	static BOOL InitWindowClass(LPCTSTR szClassName, HINSTANCE hThis);
	// The real window procedure that sets up the "this" pointer and calls
	// ProcessMessage
	static LRESULT CALLBACK RealWindowProc(
		HWND hWnd, 
		UINT message, 
		WPARAM wParam, 
		LPARAM lParam
		);
	// WM_NCCREATE handler. Stores away the "this" pointer.
	static BOOL OnNCCreate(HWND hwnd, LPCREATESTRUCT lpCreateStruct);

	// The hwnd associated with this object
	HWND m_hwnd;

	// A single LPARAM so no need to extend just to add a little data
	LPARAM m_lUserData;

	// WM_SIZE handler. Calls the Layout function.
	void OnSize(HWND hwnd, UINT state, int cx, int cy);
	// WM_ERASEBKGND handler. Clears the window.
	BOOL OnEraseBkgnd(HWND hwnd, HDC hdc);
	// WM_MOUSEMOVE handler; sets the Hot control
	void OnMouseMove(HWND hwnd, int x, int y, UINT keyFlags);
	// clears the Hot tracking
	void OnMouseLeave();
	// Tells the parent to layout
	void OnShowWindow(HWND hwnd, BOOL fShow, int fnStatus);

	// Returns TRUE if the TT exists
	BOOL InitToolInfo(TOOLINFO *pti, LPTSTR pszText=NULL);
} ;

#endif // _GENWINDOW_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\h\html.h ===
/*
 *  html.h
 *
 *      Constants and Macros for html file generation and parsing
 *
 *		Revision History:
 *
 *		When		Who					What
 *		--------	------------------  ---------------------------------------
 *					Sunita				Created/defined macros to write and parse html
 */

#ifndef _HTML_H
#define _HTML_H

//include for common token defns 
#include "nameres.h"

#include <pshpack8.h> /* Assume 8 byte packing throughout */

#ifdef __cplusplus
extern "C" {
#endif

//html file manipulation macros
#define HTMLTOKENBEGINCHAR		TOKENBEGINCHAR
#define HTMLTOKENENDCHAR		TOKENENDCHAR
#define HTMLHEADERSTARTSTR		HEADSTARTSTR
#define HTMLHEADERENDSTR		HEADENDSTR
#define HTMLSIGNSTARTSTR		"HTML"
#define HTMLSIGNENDSTR			"/HTML"
#define HTMLBODYSTARTSTR		"BODY"
#define HTMLBODYENDSTR			"/BODY"
#define HTMLAHREFSTARTSTR		"A HREF = "
#define HTMLAHREFENDSTR			"/A"
#define HTMLTITLESTARTSTR		"TITLE"
#define HTMLTITLEENDSTR			"/TITLE"
#define HTMLCONTENTTYPESTR		"Content-Type: text/html\r\n\n\n"

//token types in the ipa file format
#define HTMLTOKEN_INVALID		0
#define HTMLTOKEN_UNKNOWN		1
#define	HTMLTOKEN_SIGNSTART		2
#define HTMLTOKEN_SIGNEND		3
#define HTMLTOKEN_HEADSTART		4
#define HTMLTOKEN_HEADEND		5
#define HTMLTOKEN_BODYSTART		6
#define HTMLTOKEN_BODYEND		7
#define HTMLTOKEN_AHREFSTART	8
#define HTMLTOKEN_AHREFEND		9
#define HTMLTOKEN_TITLESTART	10
#define HTMLTOKEN_TITLEEND		11

//write macros
//note all macros taken LPSTR - it is the responsibility of the calling
//code to do any appropriate string conversions.
#define WRITEHTMLSIGNATURESTART(lpBuf)									\
	wsprintf((LPSTR)(lpBuf), "%c%s%c\r\n", HTMLTOKENBEGINCHAR,			\
		(LPSTR)HTMLSIGNSTARTSTR,HTMLTOKENENDCHAR)

#define WRITEHTMLSIGNATUREEND(lpBuf)									\
	wsprintf((LPSTR)(lpBuf), "%c%s%c\r\n", HTMLTOKENBEGINCHAR,			\
		(LPSTR)HTMLSIGNENDSTR,HTMLTOKENENDCHAR)

#define WRITEHTMLHEADERSTART(lpBuf)										\
	wsprintf((LPSTR)(lpBuf), "%c%s%c\r\n", HTMLTOKENBEGINCHAR,			\
		(LPSTR)HTMLHEADERSTARTSTR,HTMLTOKENENDCHAR)

#define WRITEHTMLHEADEREND(lpBuf)										\
	wsprintf((LPSTR)(lpBuf), "%c%s%c\r\n", HTMLTOKENBEGINCHAR,			\
		(LPSTR)HTMLHEADERENDSTR,HTMLTOKENENDCHAR)

#define WRITEHTMLTITLESTART(lpBuf)										\
	wsprintf((LPSTR)(lpBuf), "%c%s%c\r\n", HTMLTOKENBEGINCHAR,			\
		(LPSTR)HTMLTITLESTARTSTR,HTMLTOKENENDCHAR)

#define WRITEHTMLTITLE(lpBuf,lpszTitle)									\
	wsprintf((LPSTR)(lpBuf), "%s\r\n", lpszTitle)

#define WRITEHTMLTITLEEND(lpBuf)										\
	wsprintf((LPSTR)(lpBuf), "%c%s%c\r\n", HTMLTOKENBEGINCHAR,			\
		(LPSTR)HTMLTITLEENDSTR,HTMLTOKENENDCHAR)

#define WRITEHTMLBODYSTART(lpBuf)										\
	wsprintf((LPSTR)(lpBuf), "%c%s%c\r\n", HTMLTOKENBEGINCHAR,			\
		(LPSTR)HTMLBODYSTARTSTR,HTMLTOKENENDCHAR)

#define WRITEHTMLBODYEND(lpBuf)											\
	wsprintf((LPSTR)(lpBuf), "%c%s%c\r\n", HTMLTOKENBEGINCHAR,			\
		(LPSTR)HTMLBODYENDSTR,HTMLTOKENENDCHAR)

#define WRITEHTMLSIGNATURE(lpBuf)										\
	wsprintf((LPSTR)(lpBuf), "%c%s%c\r\n", HTMLTOKENBEGINCHAR,			\
		(LPSTR)HTMLSIGNATURESTR,HTMLTOKENENDCHAR)

#define WRITEHTMLREF(lpBuf,lpszUrl,lpszDisplayName)						\
	wsprintf((LPSTR)(lpBuf), "%c%s\"%s\"%c%s%c%s%c\r\n", 				\
		HTMLTOKENBEGINCHAR,(LPSTR)HTMLAHREFSTARTSTR,					\
		(LPSTR)lpszUrl,HTMLTOKENENDCHAR,								\
		(LPSTR)lpszDisplayName,HTMLTOKENBEGINCHAR,						\
		(LPSTR)HTMLAHREFENDSTR,HTMLTOKENENDCHAR)

#define WRITEHTMLREFCRLF(lpBuf,lpszUrl,lpszDisplayName)					\
	wsprintf((LPSTR)(lpBuf), "%c%s\"%s\"%c%s%c%s%c<BR>\r\n", 			\
		HTMLTOKENBEGINCHAR,(LPSTR)HTMLAHREFSTARTSTR,					\
		(LPSTR)lpszUrl,HTMLTOKENENDCHAR,								\
		(LPSTR)lpszDisplayName,HTMLTOKENBEGINCHAR,						\
		(LPSTR)HTMLAHREFENDSTR,HTMLTOKENENDCHAR)

//token identification macros
#define ISBUFOURHTMLTOKEN(lpBuf,dwBufSize,lpszToken)					\
	((strlen((LPSTR)lpszToken) == dwBufSize) ?							\
		!(memcmp((LPBYTE)lpBuf,(LPBYTE)lpszToken,dwBufSize)) : 0 )

#ifdef __cplusplus
}
#endif

#include <poppack.h> /* End byte packing */

#endif	//#ifndef _HTML_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\h\help_ids.h ===
/*
	Microsoft Corp. (C) Copyright 1995-1996
	Developed under contract by Numbers & Co.
----------------------------------------------------------------------------

		name:	Oprah Context Help Ids
	
		file:	help_ids.h

	comments:	This header contains all of the current Oprah context 
				help ids in #define form. These are intended to be used in 
				a DWORD array to associate them with Oprah internal 
				controls. Each Oprah component can make an array using just 
				the subset of these ids that it needs. The id values are 
				arbitrary except that I tried to allow a range of 20 for each 
				logical area (also arbitrary).

				For dialog boxes, the array is handed to WinHelp as shown in 
				the example below.
				------------------------

The following example shows how to implement context-sensitive help in a dialog box.
  
LRESULT CALLBACK EditDlgProc(HWND hwndDlg, UINT uMsg, WPARAM	wParam, 
	LPARAM lParam) 
{ 
 
// Create an array of control identifiers and context identifiers. 
 
static DWORD aIds[] = { 
	ID_SAVE,   IDH_SAVE, 
	ID_DELETE, IDH_DELETE, 
	ID_COPY,   IDH_COPY, 
	ID_PASTE,  IDH_PASTE, 
	0,0 
}; 
 
switch (uMsg) { 
	case WM_HELP: 
		WinHelp(((LPHELPINFO) lParam)->hItemHandle, "helpfile.hlp", 
			HELP_WM_HELP, (DWORD) (LPSTR) aIds); 
		break; 
 
	case WM_CONTEXTMENU: 
		WinHelp((HWND) wParam, "helpfile.hlp", HELP_CONTEXTMENU, 
			(DWORD) (LPVOID) aIds); 
		break; 
	. 
	. // process other messages here 
	. 
	} 
 
return FALSE; 
 
} 


WM_HELP is generated by pressing F1. WM_CONTEXTMENU is generated by right clicking.


(This example is an except from:
	Win32 Programmer's Reference
		Overviews
			Window Management
				Help
					Using Help
						Providing Help in a Dialog Box
 )

----------------------------------------------------------------------------
	Microsoft Corp. (C) Copyright 1995-1996
	Developed under contract by Numbers & Co.
 */




/* For the options dialog (confcp.dll) */

// For the General tab
#define IDH_GENERAL_GENERAL 					26100
#define IDH_GENERAL_SHOW_ON_TASKBAR 			26000
#define IDH_GENERAL_FRIENDS_TAB 				26101
#define IDH_GENERAL_CHECK_DEFAULT				26102
#define IDH_GENERAL_SHOW_ICA_ON_TASKBAR 		26200

#define IDH_GENERAL_AUTO_ACCEPT 				26004

#define IDH_GENERAL_FT_GROUP					26103
#define IDH_GENERAL_FT_DIRECTORY				26009
#define IDH_GENERAL_FT_BROWSE					26010
#define IDH_GENERAL_FT_VIEWFILES				26104

// For the protocols tab
#define IDH_PROTOCOLS_LIST						26020
#define IDH_PROTOCOLS_PROPERTIES				26021
#define IDH_PROTOCOLS_DESCRIPTION				26022

// For the video tab
#define IDH_VIDEO_CAMERA						26105
#define IDH_VIDEO_CAPTURE                       26082
#define IDH_VIDEO_SOURCE						26074
#define IDH_VIDEO_FORMAT						26075
#define IDH_VIDEO_MIRROR						26083

#define IDH_VIDEO_SQCIF 						26076
#define IDH_VIDEO_QCIF							26077
#define IDH_VIDEO_CIF							26078

#define IDH_VIDEO_QUALITY						26079

#define IDH_VIDEO_SEND_RECEIVE					26106
#define IDH_VIDEO_AUTO_SEND 					26080
#define IDH_VIDEO_AUTO_RECEIVE					26081

// For the audio tab
#define IDH_AUDIO_GENERAL						26107
#define IDH_AUDIO_FULL_DUPLEX					26030
#define IDH_AUDIO_AUTO_GAIN 					26031
#define IDH_AUDIO_TUNING_WIZARD 				26032

#define IDH_AUDIO_SET_COMPRESSION				26033
#define IDH_AUDIO_CONNECTION_SPEED				26034
#define IDH_AUDIO_MANUAL_CODEC_SETTINGS 		26035
#define IDH_AUDIO_ADVANCED_CODEC_SETTINGS		26036

#define IDH_AUDIO_MIC_SENSITIVITY				26108
#define IDH_AUDIO_AUTO_SENSITIVITY				26037
#define IDH_AUDIO_MANUAL_SENSITIVITY			26038

#define IDH_AUDIO_GATEWAY						26109
#define IDH_AUDIO_USEGATEWAY					26039
#define IDH_AUDIO_H323_GATEWAY					26043
#define IDH_SERVERS_DIRECT_CALL					26048
#define IDH_SERVERS_USE_GATEKEEPER				26045
#define IDH_SERVERS_GATEKEEPER_NAME				26046
#define IDH_SERVERS_GATEKEEPER_PHONENO			26047
#define IDH_SERVERS_GATEKEEPER_EMAIL			26049


// For the My Information tab
#define IDH_MYINFO_MYINFO                       26110
#define IDH_MYINFO_FIRSTNAME					26111
#define IDH_MYINFO_LASTNAME 					26112
#define IDH_MYINFO_EMAIL						26113
#define IDH_MYINFO_LOCATION						26114
#define IDH_MYINFO_PHONENUM						26115
#define IDH_MYINFO_COMMENTS 					26116

#define IDH_MYINFO_CATEGORIZE_GROUP				26300
#define IDH_MYINFO_PERSONAL_RADIO				26301
#define IDH_MYINFO_BUSINESS_RADIO				26302
#define IDH_MYINFO_ADULT_RADIO					26304

#define IDH_MYINFO_PUBLISH						26041
#define IDH_MYINFO_ULS_SERVER					26042
#define IDH_MYINFO_DIRECTORY_AT_START			26044
#define IDH_DIRECTORY_DIRECTORY 				26117
#define IDH_ADVCALL_USE_ACCOUNT					26122
#define IDH_ADVCALL_ACCOUNT_NO					26003
#define IDH_MYINFO_PHONE						26115
#define IDH_CALLING_ADVANCED					26123
#define IDH_CALLING_BANDWIDTH					26130
#define IDH_ADVCALL_USE_PROXY					26200
#define IDH_ADVCALL_PROXY_NAME					26121
#define IDH_ADVCALL_ADD_DIRECTORY				26101
#define IDH_ADVCALL_DISPLAY_NAME				26102
#define IDH_ADVCALL_SERVER						26103
#define IDH_ADVCALL_URL							26403

#define IDH_FRIENDS_ADDFRIENDS					26120
#define IDH_FRIENDS_ADD_NEVER					26121
#define IDH_FRIENDS_ADD_ASKME					26122
#define IDH_FRIENDS_ADD_AUTO					26123
#define IDH_FRIENDS_GENERAL 					26124
#define IDH_FRIENDS_REFRESH_AT_START			26125
#define IDH_FRIENDS_REFRESH 					26126
#define IDH_FRIENDS_REFRESH_INTERVAL			26127
#define IDH_FRIENDS_REFRESH_WARNING 			26128
#define IDH_FRIENDS_REFRESH_COUNT				26129

////////////////////////////////////////////////////
// For the Modem properties dialog

#define IDH_MODEMPROP_AUTOANSWER				26050
#define IDH_MODEMPROP_NRINGS					26051
#define IDH_MODEMPROP_LOCATION					26052
#define IDH_MODEMPROP_DIALPROP					26053
#define IDH_MODEMPROP_USEMODEM					26054
#define IDH_MODEMPROP_MODEMPROP 				26055

////////////////////////////////////////////////////
// For the Advanced compression settings dialog

#define IDH_ADVCOMP_CODECS                      26060
#define IDH_ADVCOMP_UP                          26061
#define IDH_ADVCOMP_DOWN                        26062
#define IDH_ADVCOMP_DEFAULTS                    26063

#define IDH_AUDIO_AUTOMIXER                     26138
#define IDH_AUDIO_DIRECTSOUND                   26139


// Security Tab
#define IDH_SECURITY_SECURITY                   26400
#define IDH_SECURITY_INCOMING                   26401
#define IDH_SECURITY_OUTGOING                   26402

#define IDH_SECURITY_CERTIFICATE                26404
#define IDH_SECURITY_CHANGE_CERTIFICATE         26405
#define IDH_SECURITY_CERTIFICATE_PRIVACY        26406
#define IDH_SECURITY_CERTIFICATE_PRIV_AUTH      26409

#define IDH_SECURITY_CERTIFICATE_LIST           26410   // BUGBUG LAURABU - From MargeM

#define IDH_SECURITY_CHANGE_PASSWORD            26407
#define IDH_SECURITY_RUN_REMOTE                 26408


/* Whiteboard - Page Sorter */			
#define IDH_CONF_PAGESORT_MAIN                  27000
#define IDH_CLOSE                               27001
#define IDH_CONF_PAGESORT_GOTO                  27002
#define IDH_CONF_PAGESORT_DEL                   27003
#define IDH_CONF_PAGESORT_BEFORE                27004
#define IDH_CONF_PAGESORT_AFTER                 27005

/* Chat - Message Format */ 			
#define IDH_CHAT_FORMAT_MESSAGE                 28000
#define IDH_CHAT_FORMAT_HEADER                  28001
#define IDH_CHAT_RECEIVE_MSG					28002
#define IDH_CHAT_RECEIVE_PRIV					28003
#define IDH_CHAT_SENT_MSG						28004
#define IDH_CHAT_SENT_PRIV						28005
#define IDH_CHAT_FONT							28006
#define IDH_CHAT_FONTS_LABEL                    28007	
#define IDH_CHAT_NAME                           28008
#define IDH_CHAT_DATE                           28009
#define IDH_CHAT_TIME                           28010



/* IDH_OK */							
/* IDH_CANCEL */						

/* conf.exe help id's */
/* (most are in confroom\messages\usa\resource.hm) */
#define IDH_SHADOW_REMOTE_DETACHED              29000
#define IDH_SHADOW_LOCAL_DETACHED               29001


/* New Call (9/5/97)*/
#define IDH_ADV_PASSWORD                        29002

/* Com Port Properties (9/5/97) */
#define IDH_PROTO_TIME                          29003
#define IDH_PROTO_PORT                          29004
#define IDH_PROTO_PROP                          29005

/* Host a Meeting */
#define IDH_HOST_GENERAL                        27000
#define IDH_HOST_SETTINGS                       29008
#define IDH_HOST_NAME                           29006
#define IDH_HOST_PASSWORD                       29007
#define IDH_HOST_SECURE                         29201
#define IDH_HOST_ACCEPT_PEOPLE                  26202
#define IDH_HOST_TOOLS                          26208
#define IDH_HOST_AUDIO                          26203
#define IDH_HOST_CHAT                           26204
#define IDH_HOST_INVITE_PEOPLE                  26205
#define IDH_HOST_SHARE                          26207
#define IDH_HOST_VIDEO                          26209
#define IDH_HOST_WHITEBD                        26210
#define IDH_HOST_XFER                           26211

/* Place a Call (3/6/98)  */
#define IDH_PLACECALL_SECURITY_CHKBX			29009
#define IDH_PLACECALL_NAME                      29010
#define IDH_PLACECALL_INFOSTORE                 29011
#define IDH_PLACECALL_LIST                      29012
#define IDH_PLACECALL_DIRECT                    29013
#define IDH_PLACECALL_CALL                      29014

#define IDH_PLACECALL_TO						29016
#define IDH_PLACECALL_TO_TEXT					29017
#define IDH_PLACECALL_USING						29018
#define IDH_ADV_NORMAL_HINT						29019

/* NM/Office Info (3/20/98)  */
#define IDH_INFO_CATEGORY                       29015

/* WDM Device Source Dialog (9/03/98)  */
#define IDH_DEVICE_SETTINGS                     29020
#define IDH_CAMERA_CONTROLS                     29021

/* Choose Conference Dialog (3/11/99)  */
#define IDH_MCU_CONF_MAIN                       27000
#define IDH_MCU_CONF_NAME                       29022
#define IDH_MCU_CONF_LIST                       29023

#define IDH_PLACECALL_SEARCH_DIR				29025
#define IDH_FINDSOMEONE_REFRESH					29024
#define IDH_FINDSOMEONE_BROWSER					29026
#define IDH_FINDSOMEONE_HELP					29027
#define IDH_FINDSOMEONE_DELETE_ILS				29028


/* Create SpeedDial Dialog (3/15/99)  */
#define IDH_STATIC_SPEED_DIAL_INSTRUCTIONS      26011
#define IDH_CSD_ADDRESS_EDIT                    0x80a30424
#define IDH_CSD_CALL_USING_COMBO                0x80a30423
#define IDH_CSD_CREATE_GROUPBOX                 0x80a3047f
#define IDH_CSD_SAVE_DESKTOP_RADIO              0x80a3040b
#define IDH_CSD_SD_INFO_GROUP                   0x80a30480
#define IDH_CSD_SPEEDDIAL_LIST_RADIO            0x80a3040d
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\h\icaapi.h ===
/*============================================================================*\

                 INTEL Corporation Proprietary Information

      This listing is supplied under the terms of a license agreement
      with INTEL Corporation and may not be copied nor disclosed except
      in accordance with the terms of that agreement.

                 Copyright (c) 1996 Intel Corporation.
                           All rights reserved.

\*============================================================================*/

/*****************************************************************************\

    SUMMARY: Intel Connection Advisor DLL export API

    HISTORY:
		Original E. Rogers, January 1997

$Header:   L:\proj\sturgeon\src\ica\vcs\icaapi.h_v   1.11   07 Feb 1997 14:29:28   RKAR  $

\*****************************************************************************/

#ifndef _ICA_API_H_
#define _ICA_API_H_

#ifdef __cplusplus
extern "C" {				// Assume C declarations for C++.
#endif // __cplusplus

#define SZ_ICADLL TEXT("MSICA.DLL")
#define SZ_ICAHELP TEXT("MSICA.HLP")
															  
#ifndef DllExport
//! #define DllExport	__declspec( dllexport )
#define DllExport
#endif	// DllExport

// Registry definitions (needed by conf.exe)
#define REGKEY_ICA           TEXT("Software\\Microsoft\\Conferencing\\ICA")
#define REGVAL_ICA_IN_TRAY   TEXT("UseTrayIcon")
#define REGVAL_ICA_POPUP     TEXT("PopupOnError")
#define REGVAL_ICA_TOPMOST   TEXT("StayOnTop")

// Panel identifiers
#define GENERAL_PANEL		"ICA_GENERAL_PANEL"			// Localization OK
#define MS_AUDIO_PANEL		"NM2.0_H323_AUDIO"			// Localization OK
#define MS_VIDEO_PANEL		"NM2.0_H323_VIDEO"			// Localization OK
#define VP20_H323_AUDIO_PANEL	"VPHONE2.0_H323_AUDIO"	// Localization OK
#define VP20_H323_VIDEO_PANEL	"VPHONE2.0_H323_VIDEO"	// Localization OK
#define VP20_H323_DETAILS_PANEL	"VPHONE2.0_H323_DETAILS"// Localization OK
#define VP20_H324_AUDIO_PANEL	"VPHONE2.0_H324_AUDIO"	// Localization OK
#define VP20_H324_VIDEO_PANEL	"VPHONE2.0_H324_VIDEO"	// Localization OK
#define VP20_H324_DETAILS_PANEL	"VPHONE2.0_H324_DETAILS"// Localization OK

// ICA data types - used by ICA_OpenStatistic in the dwType param
#define DWORD_TYPE		0


// Statistic info structure
typedef struct
{
	UINT	cbSize;
	DWORD	dwMaxValue;
	DWORD	dwMinValue;
	DWORD	dwWarnLevel;
	DWORD	dwUpdateFrequency;
} ICA_STATISTIC_INFO, *PICA_STATISTIC_INFO;


// Function typedefs
typedef HRESULT (WINAPI *PFnICA_Start)( char*, char*, HWND* );
typedef HRESULT (WINAPI *PFnICA_Stop)( VOID );
typedef HRESULT (WINAPI *PFnICA_DisplayPanel)( char*, char*, char*, VOID*, HANDLE* );
typedef HRESULT (WINAPI *PFnICA_RemovePanel)( HANDLE );
typedef HRESULT (WINAPI *PFnICA_OpenStatistic)( char*, DWORD, HANDLE* );
typedef HRESULT (WINAPI *PFnICA_SetStatistic)( HANDLE, BYTE*, DWORD );
typedef HRESULT (WINAPI *PFnICA_SetStatisticInfo)( HANDLE, ICA_STATISTIC_INFO* );
typedef HRESULT (WINAPI *PFnICA_SetWarningEvent)( HANDLE, HANDLE );
typedef HRESULT (WINAPI *PFnICA_GetStatistic)( HANDLE, BYTE*, DWORD*, DWORD* );
typedef HRESULT (WINAPI *PFnICA_GetWarningState)( HANDLE, BOOL* );
typedef HRESULT (WINAPI *PFnICA_EnumStatistic)( DWORD, char*, DWORD, HANDLE* );
typedef HRESULT (WINAPI *PFnICA_ResetStatistic)( HANDLE );
typedef HRESULT (WINAPI *PFnICA_CloseStatistic)( HANDLE );
typedef HRESULT (WINAPI *PFnICA_SetOptions) ( UINT );
typedef HRESULT (WINAPI *PFnICA_GetOptions) ( DWORD*);


///////////////////////// ICA API functions ///////////////////////////////////

// General functions
HRESULT WINAPI ICA_Start( char* pszDisplayName, char* pszRRCMLibrary, HWND* phWnd );
HRESULT WINAPI ICA_Stop( VOID );

// Panel functions
HRESULT WINAPI ICA_DisplayPanel( char* pszModuleName, char* pszName,
								 char* pszHelpFile, VOID* pReserved, HANDLE* phPanel );
HRESULT WINAPI ICA_RemovePanel( HANDLE hPanel );

// Data functions
HRESULT WINAPI ICA_OpenStatistic( char* pszName, DWORD dwType, HANDLE* phStat );
HRESULT WINAPI ICA_SetStatistic( HANDLE hStat, BYTE* pData, DWORD dwDataSize );
HRESULT WINAPI ICA_SetStatisticInfo( HANDLE hStat, ICA_STATISTIC_INFO* pStatInfo );
HRESULT WINAPI ICA_SetWarningEvent( HANDLE hStat, HANDLE hEvent );
HRESULT WINAPI ICA_GetStatistic( HANDLE hStat, BYTE* pBuffer, DWORD* pdwBufSize,
								    DWORD* pdwTimeStamp );
HRESULT WINAPI ICA_GetWarningState( HANDLE hStat, BOOL* bInWarningState );
HRESULT WINAPI ICA_EnumStatistic( DWORD dwIndex, char* pszName, DWORD dwNameSize,
									 HANDLE* phStat );
HRESULT WINAPI ICA_ResetStatistic( HANDLE hStat );
HRESULT WINAPI ICA_CloseStatistic( HANDLE hStat );

#define ICA_OPTION_DUPLEX_MASK     0x00000001
#define ICA_OPTION_TRAY_MASK       0x00000002
HRESULT WINAPI ICA_GetOptions( DWORD* dwOptionValue );

// ICA Flags to ICA_SetOptions
#define ICA_SHOW_TRAY_ICON         0x00000001
#define ICA_DONT_SHOW_TRAY_ICON	   0x00000002
#define ICA_SET_HALF_DUPLEX        0x00000004
#define ICA_SET_FULL_DUPLEX        0x00000008
HRESULT WINAPI ICA_SetOptions( UINT fOptionFlag );

#ifdef __cplusplus
}						// End of extern "C" {
#endif // __cplusplus

#endif // _ICA_API_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\h\ias.h ===
#ifndef _IAS_H_
#define _IAS_H_



// GetShareableApps()
typedef struct
{
    HWND        hwnd;
    BOOL        fShared;
}
IAS_HWND;


typedef struct
{
    ULONG       cShared;
    ULONG       cEntries;
    IAS_HWND    aEntries[1];
}
IAS_HWND_ARRAY;


typedef UINT IAS_GCC_ID;



// GetPersonStatus()

#define IAS_SHARING_NOTHING             0x0000
#define IAS_SHARING_APPLICATIONS        0x0001
#define IAS_SHARING_DESKTOP             0x0002

typedef enum
{
    IAS_VERSION_20 = 1,
    IAS_VERSION_30
}
IAS_VERSION;

typedef struct
{
    UINT                cbSize;

    BOOL                InShare;            // Participating in share
    IAS_VERSION         Version;            // AS protocol version
    UINT                AreSharing;         // What person is sharing (IAS_SHARING_)
    BOOL                Controllable;       // Is person controllable
    BOOL                IsPaused;           // If controlled, is control paused currently
    IAS_GCC_ID          InControlOfPending; // Whom we are waiting to control
    IAS_GCC_ID          InControlOf;        // Whom is controlled by person
    IAS_GCC_ID          ControlledByPending;// Whom we are waiting to be controlled by
    IAS_GCC_ID          ControlledBy;       // Who is controlling person
}
IAS_PERSON_STATUS;




// GetWindowStatus

typedef enum
{
    IAS_SHARE_DEFAULT = 0,
    IAS_SHARE_BYPROCESS,
    IAS_SHARE_BYTHREAD,
    IAS_SHARE_BYWINDOW
}
IAS_SHARE_TYPE;



// lonchanc
// In general, S_OK means success, E_*** means failure
// For boolean values, S_OK means TRUE, S_FALSE means FALSE, and E_*** means failure.

#undef  INTERFACE
#define INTERFACE IAppSharing

// lonchanc: the idea of this IAppSharing is per call interface
DECLARE_INTERFACE_(IAppSharing, IUnknown)
{
    STDMETHOD(QueryInterface)(THIS_  REFIID, void **) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    //
    // INFORMATION
    //
    STDMETHOD_(BOOL, IsSharingAvailable)(THIS) PURE;
    STDMETHOD_(BOOL, CanShareNow)(THIS) PURE;
    STDMETHOD_(BOOL, IsInShare)(THIS) PURE;
    STDMETHOD_(BOOL, IsSharing)(THIS) PURE;
    STDMETHOD_(BOOL, IsWindowShareable)(THIS_ HWND hwnd) PURE;
    STDMETHOD_(BOOL, IsWindowShared)(THIS_ HWND hwnd) PURE;
    STDMETHOD_(BOOL, CanAllowControl)(THIS) PURE;
    STDMETHOD_(BOOL, IsControllable)(THIS) PURE;
    STDMETHOD(GetPersonStatus)(THIS_ IAS_GCC_ID Person, IAS_PERSON_STATUS *pStatus) PURE;

    //
    // SHARING
    //
    STDMETHOD(LaunchHostUI)(THIS) PURE;
	STDMETHOD(GetShareableApps)(THIS_ IAS_HWND_ARRAY **ppHwnds) PURE;
    STDMETHOD(FreeShareableApps)(THIS_  IAS_HWND_ARRAY * pHwnds) PURE;
	STDMETHOD(Share)(THIS_  HWND hwnd, IAS_SHARE_TYPE how) PURE;
	STDMETHOD(Unshare)(THIS_  HWND hwnd) PURE;

    //
    // CONTROL
    //

    // On host
    STDMETHOD(AllowControl)(THIS_ BOOL fAllowed) PURE;

    // From person controlling to person controlled
    STDMETHOD(TakeControl)(THIS_ IAS_GCC_ID PersonOf) PURE;
    STDMETHOD(CancelTakeControl)(THIS_ IAS_GCC_ID PersonOf) PURE;
    STDMETHOD(ReleaseControl)(THIS_ IAS_GCC_ID PersonOf) PURE;
    STDMETHOD(PassControl)(THIS_ IAS_GCC_ID PersonOf, IAS_GCC_ID PersonTo) PURE;

    // From person controlled
    STDMETHOD(GiveControl)(THIS_ IAS_GCC_ID PersonTo) PURE;
    STDMETHOD(CancelGiveControl)(THIS_ IAS_GCC_ID PersonTo) PURE;
    STDMETHOD(RevokeControl)(THIS_ IAS_GCC_ID PersonFrom) PURE;

    STDMETHOD(PauseControl)(IAS_GCC_ID PersonInControl) PURE;
    STDMETHOD(UnpauseControl)(IAS_GCC_ID PersonInControl) PURE;
};



// IAppSharingNotify interface
DECLARE_INTERFACE_(IAppSharingNotify, IUnknown)
{
    STDMETHOD(QueryInterface)(THIS_ REFIID, void**) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    STDMETHOD(OnReadyToShare)(THIS_ BOOL fReady) PURE;
    STDMETHOD(OnShareStarted)(THIS) PURE;
    STDMETHOD(OnSharingStarted)(THIS) PURE;
    STDMETHOD(OnShareEnded)(THIS) PURE;
    STDMETHOD(OnPersonJoined)(THIS_ IAS_GCC_ID gccID) PURE;
    STDMETHOD(OnPersonLeft)(THIS_ IAS_GCC_ID gccID) PURE;

    STDMETHOD(OnStartInControl)(THIS_ IAS_GCC_ID gccOf) PURE;
    STDMETHOD(OnStopInControl)(THIS_ IAS_GCC_ID gccOf) PURE;
    STDMETHOD(OnPausedInControl)(THIS_ IAS_GCC_ID gccInControlOf) PURE;
    STDMETHOD(OnUnpausedInControl)(THIS_ IAS_GCC_ID gccInControlOf) PURE;

    STDMETHOD(OnControllable)(THIS_ BOOL fControllable) PURE;
    STDMETHOD(OnStartControlled)(THIS_ IAS_GCC_ID gccBy) PURE;
    STDMETHOD(OnStopControlled)(THIS_ IAS_GCC_ID gccBy) PURE;
    STDMETHOD(OnPausedControlled)(THIS_ IAS_GCC_ID gccControlledBy) PURE;
    STDMETHOD(OnUnpausedControlled)(THIS_ IAS_GCC_ID gccControlledBy) PURE;
};


//
// AS flags:
//
#define     AS_SERVICE          0x0001          // Is this service context?
#define     AS_UNATTENDED       0x0002          // Is this unattended (no end user)?

HRESULT WINAPI CreateASObject(IAppSharingNotify * pNotify, UINT flags, IAppSharing** ppAS);

#endif // _IAS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\h\iconnect.h ===
/*
 *  	File: iconnect.h
 *
 *      Network audio connection interface header file. 
 *
 *		Revision History:
 *
 *		04/15/96	mikev	created
 */
 

#ifndef _ICONNECT_H
#define _ICONNECT_H

#include "icomchan.h"
#include "apierror.h"

// RES_PAIR contains an instance of a matching set of local and remote
// capability IDs.  
typedef struct res_pair
{
	MEDIA_FORMAT_ID idLocal;		// locally unique ID 
	MEDIA_FORMAT_ID idRemote;		// remote's ID 
	MEDIA_FORMAT_ID idPublicLocal;	// the public ID that corresponds to the (private) idLocal
}RES_PAIR, *PRES_PAIR;

typedef enum {
    AT_H323_ID =1,  // unicode string (typically user name or full email address)
    AT_H323_E164,   // unicode E164
    AT_INVALID      // this always goes last. it marks the end of valid values
}ALIAS_ADDR_TYPE;

typedef struct
{
    ALIAS_ADDR_TYPE         aType;
    WORD                    wDataLength;   // UNICODE character count
    LPWSTR                  lpwData;       // UNICODE data.
} H323ALIASNAME, *P_H323ALIASNAME;

typedef struct
{
    WORD                    wCount;     // # of entries in array of H323ALIASNAME
    P_H323ALIASNAME         pItems;     // points to array of H323ALIASNAME
} H323ALIASLIST, *P_H323ALIASLIST;


typedef enum {
	CLS_Idle,
	CLS_Connecting,
	CLS_Inuse,
	CLS_Listening,
	CLS_Disconnecting,
	CLS_Alerting
}ConnectStateType;

//
// 	call progress codes 
//

#define CONNECTION_CONNECTED 			0x00000001	// connected at network level
#define CONNECTION_RECEIVED_DISCONNECT 	0x00000002	// other end disconnected
#define CONNECTION_CAPABILITIES_READY 	0x00000003	// capabilities have been exchanged

#define CONNECTION_PROCEEDING			0x00000005  // "ringing" 

#define CONNECTION_READY				0x00000006  // start talking!
#define CONNECTION_REJECTED				0x00000007	// received a rejection
#define CONNECTION_DISCONNECTED			0x00000008	// this end is now disconnected

#define CONNECTION_BUSY					0x00000012 // busy signal
#define CONNECTION_ERROR				0x00000013



//
// 	Call completion summary codes ("Reason") for disconnecting or being rejected. 
//  This is a "first error" code.  It is assigned its value at the first detectable 
// 	event which is known to terminate a call.  
//
// The IConfAdvise implementation bears the responsibility for preserving the
// summary codes.  Control channel implementations (IControlChannel) supply the 
// best known summary code for each event, regardless of prior events.  
//

#define CCR_INVALID_REASON		0	// 	this indicates that no reason has been assigned

#define CCR_UNKNOWN				MAKE_CUSTOM_HRESULT(SEVERITY_SUCCESS, TRUE, FACILITY_CALLSUMMARY, 1)
#define CCR_LOCAL_DISCONNECT	MAKE_CUSTOM_HRESULT(SEVERITY_SUCCESS, TRUE, FACILITY_CALLSUMMARY, 2)
#define CCR_REMOTE_DISCONNECT	MAKE_CUSTOM_HRESULT(SEVERITY_SUCCESS, TRUE, FACILITY_CALLSUMMARY, 3)
#define CCR_REMOTE_REJECTED		MAKE_CUSTOM_HRESULT(SEVERITY_SUCCESS, TRUE, FACILITY_CALLSUMMARY, 4)
#define CCR_REMOTE_BUSY			MAKE_CUSTOM_HRESULT(SEVERITY_SUCCESS, TRUE, FACILITY_CALLSUMMARY, 5)
#define CCR_LOCAL_PROTOCOL_ERROR	MAKE_CUSTOM_HRESULT(SEVERITY_SUCCESS, TRUE, FACILITY_CALLSUMMARY, 6)
#define CCR_REMOTE_PROTOCOL_ERROR	MAKE_CUSTOM_HRESULT(SEVERITY_SUCCESS, TRUE, FACILITY_CALLSUMMARY, 7)
#define CCR_INCOMPATIBLE_VERSION	MAKE_CUSTOM_HRESULT(SEVERITY_SUCCESS, TRUE, FACILITY_CALLSUMMARY, 8)
#define CCR_LOCAL_SYSTEM_ERROR		MAKE_CUSTOM_HRESULT(SEVERITY_SUCCESS, TRUE, FACILITY_CALLSUMMARY, 9)
#define CCR_REMOTE_SYSTEM_ERROR		MAKE_CUSTOM_HRESULT(SEVERITY_SUCCESS, TRUE, FACILITY_CALLSUMMARY, 10)
#define CCR_LOCAL_MEDIA_ERROR		MAKE_CUSTOM_HRESULT(SEVERITY_SUCCESS, TRUE, FACILITY_CALLSUMMARY, 11)
#define CCR_REMOTE_MEDIA_ERROR		MAKE_CUSTOM_HRESULT(SEVERITY_SUCCESS, TRUE, FACILITY_CALLSUMMARY, 12)
#define CCR_LOCAL_REJECT			MAKE_CUSTOM_HRESULT(SEVERITY_SUCCESS, TRUE, FACILITY_CALLSUMMARY, 13)
#define CCR_LOCAL_BUSY				MAKE_CUSTOM_HRESULT(SEVERITY_SUCCESS, TRUE, FACILITY_CALLSUMMARY, 14)
#define CCR_INCOMPATIBLE_CAPS		MAKE_CUSTOM_HRESULT(SEVERITY_SUCCESS, TRUE, FACILITY_CALLSUMMARY, 15)	// no capabilities in common
#define CCR_NO_ANSWER_TIMEOUT		MAKE_CUSTOM_HRESULT(SEVERITY_SUCCESS, TRUE, FACILITY_CALLSUMMARY, 16)
#define CCR_GK_NO_RESOURCES			MAKE_CUSTOM_HRESULT(SEVERITY_SUCCESS, TRUE, FACILITY_CALLSUMMARY, 17)
#define CCR_LOCAL_SECURITY_DENIED	MAKE_CUSTOM_HRESULT(SEVERITY_SUCCESS, TRUE, FACILITY_CALLSUMMARY, 18)
#define CCR_REMOTE_SECURITY_DENIED	MAKE_CUSTOM_HRESULT(SEVERITY_SUCCESS, TRUE, FACILITY_CALLSUMMARY, 19)



//
//	IH323Endpoint
//

#undef INTERFACE
#define INTERFACE IH323Endpoint
DECLARE_INTERFACE( IH323Endpoint )
{
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR * ppvObj) PURE;	
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    STDMETHOD(SetAdviseInterface)(THIS_ IH323ConfAdvise *pH323ConfAdvise) PURE;
    STDMETHOD(ClearAdviseInterface)(THIS) PURE;
    STDMETHOD(PlaceCall)(THIS_ BOOL bUseGKResolution, PSOCKADDR_IN pCallAddr,		
        P_H323ALIASLIST pDestinationAliases, P_H323ALIASLIST pExtraAliases,  	
	    LPCWSTR pCalledPartyNumber, P_APP_CALL_SETUP_DATA pAppData) PURE;	
    STDMETHOD(Disconnect)(THIS) PURE;
    STDMETHOD(GetState)(THIS_ ConnectStateType *pState) PURE;
    STDMETHOD(GetRemoteUserName)(THIS_ LPWSTR lpwszName, UINT uSize) PURE;
    STDMETHOD(GetRemoteUserAddr)(THIS_ PSOCKADDR_IN psinUser) PURE;
    STDMETHOD(AcceptRejectConnection)(THIS_ CREQ_RESPONSETYPE Response) PURE;
    STDMETHOD_(HRESULT, GetSummaryCode)(THIS) PURE;
 	STDMETHOD(CreateCommChannel)(THIS_ LPGUID pMediaGuid, ICommChannel **ppICommChannel,
    	BOOL fSend) PURE; 
    	
	STDMETHOD (ResolveFormats)(THIS_ LPGUID pMediaGuidArray, UINT uNumMedia, 
	    PRES_PAIR pResOutput) PURE;
    	
    STDMETHOD(GetVersionInfo)(THIS_
		PCC_VENDORINFO *ppLocalVendorInfo,
		PCC_VENDORINFO *ppRemoteVendorInfo) PURE;
};


#endif	//#ifndef _ICONNECT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\h\imbft.h ===
// File: iMbft.h
//
// Interface to Multipoint Binary File Transfer


#ifndef _IMBFT_H_
#define _IMBFT_H_

#include <t120type.h>

const unsigned int _iMBFT_MAX_APP_KEY        = 64;     //Max characters in lpszAppKey parameter passed to MBFTInitialize
const unsigned int _iMBFT_MAX_FILE_NAME      = MAX_PATH;     //Max characters in filename


typedef UINT MBFTFILEHANDLE;
typedef UINT MBFTEVENTHANDLE;

typedef enum
{
    iMBFT_OK = 0,
    iMBFT_FIRST_ERROR = 0x100,
    iMBFT_NOT_INITIALIZED,
    iMBFT_ALREADY_INITIALIZED,
    iMBFT_INVALID_SESSION_ID,
    iMBFT_INVALID_ATTACHMENT_HANDLE,
    iMBFT_NO_MORE_RECIPIENTS,
    iMBFT_NO_MORE_FILES,
    iMBFT_INVALID_EVENT_HANDLE,
    iMBFT_INVALID_FILE_HANDLE,
    iMBFT_INSUFFICIENT_DISK_SPACE,
    iMBFT_FILE_NOT_FOUND,
    iMBFT_FILE_IO_ERROR,
    iMBFT_MEMORY_ALLOCATION_ERROR,
    iMBFT_ASN1_ENCODING_ERROR,
    iMBFT_RECIPIENT_NOT_FOUND,
    iMBFT_SENDER_ABORTED,
    iMBFT_RECEIVER_ABORTED,
    iMBFT_MULT_RECEIVER_ABORTED,
    iMBFT_RECEIVER_REJECTED,
    iMBFT_INVALID_PARAMETERS,
    iMBFT_COMPRESSION_ERROR,
    iMBFT_DECOMPRESSION_ERROR,
    iMBFT_INVALID_PATH,
    iMBFT_FILE_ACCESS_DENIED,
    iMBFT_FILE_HARD_IO_ERROR,
    iMBFT_FILE_SHARING_VIOLATION,
    iMBFT_DIRECTORY_FULL_ERROR,
    iMBFT_TOO_MANY_OPEN_FILES,
    iMBFT_OPERATION_IN_PROGRESS,
    iMBFT_INSUFFICIENT_PRIVILEGE,
    iMBFT_CONDUCTOR_ABORTED,
    iMBFT_PACKET_SIZE_ERROR,
    iMBFT_UNKNOWN_ERROR,
    iMBFT_TIMEOUT_ERROR
} MBFT_ERROR_CODE;

// Return codes  (Should be in imsconf2.idl)

#define FT_ERR_FAC 0xF000
#define FT_E(e)    (0x81000000UL | FT_ERR_FAC | (ULONG) (e))

enum
{
	NM_E_FT_NO_RECIPIENTS =                FT_E(0x01FF),
	NM_E_FT_CANCELED =                     FT_E(0x01FE),
	NM_E_FT_MULT_CANCELED =                FT_E(0x01FD),
	NM_E_FT_RECDIR =                       FT_E(0x01FC),
	NM_E_FT_REJECTED =                     FT_E(0x01FB)
};

#define HRESULT_FROM_IMBFT(iMbftError)     FT_E(iMbftError)



// This matches "ErrorType" in T.MBFT spec
typedef enum
{
    MBFT_INFORMATIVE_ERROR = 0,         // Information only
    MBFT_TRANSIENT_ERROR,               // Current transfer failed, retry might work
    MBFT_PERMANENT_ERROR                // Error occurs consistently
} MBFT_ERROR_TYPES;


typedef struct _T_MBFT_PEER_INFO
{
    T120NodeID      NodeID;                 // MCS userID of GCC on peer's node
    T120UserID      MBFTPeerID;             // MCS userID of peer app
    T120SessionID   MBFTSessionID;          // Session ID
    BOOL            bIsProShareApp;         // ProShare MBFT peer
    char            szAppKey[_iMBFT_MAX_APP_KEY];   // see MBFTInitialize
} MBFT_PEER_INFO;

typedef struct _T_MBFT_SEND_FILE_INFO
{
    char            * lpszFilePath;          //Canonical path to file to be sent, upto [_iMBFT_MAX_PATH] bytes
    MBFTFILEHANDLE  hFile;                  // unique identifier for file (filled in on return)
    ULONG           lFileSize;              // File size in bytes
    time_t          FileDateTime;
} MBFT_SEND_FILE_INFO;

typedef struct _T_MBFT_RECEIVE_FILE_INFO
{
    char            szFileName[_iMBFT_MAX_FILE_NAME];  // Just the File name
    MBFTFILEHANDLE  hFile;                  // unique identifier for file
    ULONG           lFileSize;              // File size in bytes
    time_t          FileDateTime;
} MBFT_RECEIVE_FILE_INFO;

typedef struct  _T_MBFT_FILE_OFFER
{
    MBFTEVENTHANDLE hEvent;
    T120UserID      SenderID;           // MCS ID of sender-to-be
	T120NodeID      NodeID;
    ULONG           uNumFiles;          // Number of files offered
    BOOL            bIsBroadcastEvent;
    MBFT_RECEIVE_FILE_INFO  FAR * lpFileInfoList;   // Array of structs with file info
} MBFT_FILE_OFFER;

typedef struct  _T_MBFT_FILE_PROGRESS
{
    MBFTEVENTHANDLE hEvent;
    MBFTFILEHANDLE  hFile;
    ULONG           lFileSize;
    ULONG           lBytesTransmitted;
    BOOL            bIsBroadcastEvent;
} MBFT_FILE_PROGRESS;

typedef struct  _T_MBFT_EVENT_ERROR
{
    MBFTEVENTHANDLE hEvent;
    BOOL            bIsLocalError;      // If error in local MBFT provider
    T120UserID      UserID;             // MCS ID of peer who reported error
    MBFTFILEHANDLE  hFile;              // File associated with error
    BOOL            bIsBroadcastEvent;
    MBFT_ERROR_TYPES eErrorType;        // Severity of error
    MBFT_ERROR_CODE eErrorCode;
} MBFT_EVENT_ERROR;


#undef  INTERFACE
#define INTERFACE IMbftEvents
DECLARE_INTERFACE(IMbftEvents)
{
	STDMETHOD(OnInitializeComplete)(    THIS) PURE;

	STDMETHOD(OnPeerAdded)(             THIS_
										MBFT_PEER_INFO *pInfo) PURE;
	STDMETHOD(OnPeerRemoved)(           THIS_
										MBFT_PEER_INFO *pInfo) PURE;
	STDMETHOD(OnFileOffer)(             THIS_
										MBFT_FILE_OFFER *pOffer) PURE;
	STDMETHOD(OnFileProgress)(          THIS_
										MBFT_FILE_PROGRESS *pProgress) PURE;
	STDMETHOD(OnFileEnd)(               THIS_
										MBFTFILEHANDLE hFile) PURE;
	STDMETHOD(OnFileError)(             THIS_
										MBFT_EVENT_ERROR *pEvent) PURE;
	STDMETHOD(OnFileEventEnd)(          THIS_
										MBFTEVENTHANDLE hEvent) PURE;
	STDMETHOD(OnSessionEnd)(            THIS) PURE;
};

#undef  INTERFACE
#define INTERFACE IMbftControl
DECLARE_INTERFACE(IMbftControl)
{
	STDMETHOD_(void, ReleaseInterface)( THIS) PURE;
	STDMETHOD_(void, Update)(           THIS) PURE;
	STDMETHOD_(void, CancelFt)(         THIS_
										MBFTEVENTHANDLE hEvent,
										MBFTFILEHANDLE  hFile) PURE;
	STDMETHOD(AcceptFileOffer)(         THIS_
										MBFT_FILE_OFFER *pOffer,
										LPCSTR pszRecDir,
										LPCSTR pszFileName) PURE;
	STDMETHOD_(void, RejectFileOffer)(  THIS_
	                                    MBFT_FILE_OFFER *pOffer) PURE;
	STDMETHOD(SendFile)(                THIS_
	                                    LPCSTR pszFileName,
	                                    T120NodeID nidReceiver,
	                                    MBFTEVENTHANDLE *phEvent,
	                                    MBFTFILEHANDLE *phFile) PURE;
};

typedef HRESULT (WINAPI * PFNCREATEMBFTOBJECT) (IMbftControl**, IMbftEvents *);

HRESULT WINAPI FT_CreateInterface(IMbftControl **ppMbft, IMbftEvents *pEvents);


#endif /* _IMBFT_H */


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\h\ilsguid.h ===
//****************************************************************************
//
//  File:       ilsguid.h
//  Content:    This file contains the class GUID for Internet Location Services.
//
//  Copyright (c) Microsoft Corporation 1996-1997
//
//****************************************************************************

// {A4AD47C0-20EA-11d0-8796-444553540000}
//
DEFINE_GUID(CLSID_InternetLocationServices, 
0xa4ad47c0, 0x20ea, 0x11d0, 0x87, 0x96, 0x44, 0x45, 0x53, 0x54, 0x0, 0x0);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\h\icounter.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


/* File created by MIDL compiler version 3.01.75 */
/* at Sun Apr 19 17:22:14 1998
 */
/* Compiler settings for icounter.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win32, ms_ext, c_ext
    error checks: none
*/
//@@MIDL_FILE_HEADING(  )
#include "rpc.h"
#include "rpcndr.h"
#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __icounter_h__
#define __icounter_h__

#ifdef __cplusplus
extern "C"{
#endif 

/* Forward Declarations */ 

#ifndef __ICounter_FWD_DEFINED__
#define __ICounter_FWD_DEFINED__
typedef interface ICounter ICounter;
#endif 	/* __ICounter_FWD_DEFINED__ */


#ifndef __IReport_FWD_DEFINED__
#define __IReport_FWD_DEFINED__
typedef interface IReport IReport;
#endif 	/* __IReport_FWD_DEFINED__ */


#ifndef __ICounterMgr_FWD_DEFINED__
#define __ICounterMgr_FWD_DEFINED__
typedef interface ICounterMgr ICounterMgr;
#endif 	/* __ICounterMgr_FWD_DEFINED__ */


#ifndef __Counter_FWD_DEFINED__
#define __Counter_FWD_DEFINED__

#ifdef __cplusplus
typedef class Counter Counter;
#else
typedef struct Counter Counter;
#endif /* __cplusplus */

#endif 	/* __Counter_FWD_DEFINED__ */


#ifndef __Report_FWD_DEFINED__
#define __Report_FWD_DEFINED__

#ifdef __cplusplus
typedef class Report Report;
#else
typedef struct Report Report;
#endif /* __cplusplus */

#endif 	/* __Report_FWD_DEFINED__ */


#ifndef __CounterMgr_FWD_DEFINED__
#define __CounterMgr_FWD_DEFINED__

#ifdef __cplusplus
typedef class CounterMgr CounterMgr;
#else
typedef struct CounterMgr CounterMgr;
#endif /* __cplusplus */

#endif 	/* __CounterMgr_FWD_DEFINED__ */


/* header files for imported files */
#include "wtypes.h"
#include "nmstat.h"
#include "oaidl.h"

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 

#ifndef __ICounter_INTERFACE_DEFINED__
#define __ICounter_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: ICounter
 * at Sun Apr 19 17:22:14 1998
 * using MIDL 3.01.75
 ****************************************/
/* [unique][helpstring][uuid][object] */ 



EXTERN_C const IID IID_ICounter;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("7BC77801-3830-11d0-B143-00C04FC2A118")
    ICounter : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Initialize( 
            /* [in] */ char __RPC_FAR *szName,
            /* [in] */ DWORD dwFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Update( 
            /* [in] */ int nValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE InitMax( 
            /* [in] */ int nMaxValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetValue( 
            /* [in] */ DWORD dwFlags,
            /* [out] */ int __RPC_FAR *pnValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE StartStatistics( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE StopStatistics( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ReadStatistics( 
            /* [out] */ COUNTERSTAT __RPC_FAR *lpcs) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ClearStatistics( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICounterVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ICounter __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ICounter __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ICounter __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Initialize )( 
            ICounter __RPC_FAR * This,
            /* [in] */ char __RPC_FAR *szName,
            /* [in] */ DWORD dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Update )( 
            ICounter __RPC_FAR * This,
            /* [in] */ int nValue);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *InitMax )( 
            ICounter __RPC_FAR * This,
            /* [in] */ int nMaxValue);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetValue )( 
            ICounter __RPC_FAR * This,
            /* [in] */ DWORD dwFlags,
            /* [out] */ int __RPC_FAR *pnValue);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *StartStatistics )( 
            ICounter __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *StopStatistics )( 
            ICounter __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ReadStatistics )( 
            ICounter __RPC_FAR * This,
            /* [out] */ COUNTERSTAT __RPC_FAR *lpcs);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ClearStatistics )( 
            ICounter __RPC_FAR * This);
        
        END_INTERFACE
    } ICounterVtbl;

    interface ICounter
    {
        CONST_VTBL struct ICounterVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICounter_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICounter_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICounter_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICounter_Initialize(This,szName,dwFlags)	\
    (This)->lpVtbl -> Initialize(This,szName,dwFlags)

#define ICounter_Update(This,nValue)	\
    (This)->lpVtbl -> Update(This,nValue)

#define ICounter_InitMax(This,nMaxValue)	\
    (This)->lpVtbl -> InitMax(This,nMaxValue)

#define ICounter_GetValue(This,dwFlags,pnValue)	\
    (This)->lpVtbl -> GetValue(This,dwFlags,pnValue)

#define ICounter_StartStatistics(This)	\
    (This)->lpVtbl -> StartStatistics(This)

#define ICounter_StopStatistics(This)	\
    (This)->lpVtbl -> StopStatistics(This)

#define ICounter_ReadStatistics(This,lpcs)	\
    (This)->lpVtbl -> ReadStatistics(This,lpcs)

#define ICounter_ClearStatistics(This)	\
    (This)->lpVtbl -> ClearStatistics(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ICounter_Initialize_Proxy( 
    ICounter __RPC_FAR * This,
    /* [in] */ char __RPC_FAR *szName,
    /* [in] */ DWORD dwFlags);


void __RPC_STUB ICounter_Initialize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICounter_Update_Proxy( 
    ICounter __RPC_FAR * This,
    /* [in] */ int nValue);


void __RPC_STUB ICounter_Update_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICounter_InitMax_Proxy( 
    ICounter __RPC_FAR * This,
    /* [in] */ int nMaxValue);


void __RPC_STUB ICounter_InitMax_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICounter_GetValue_Proxy( 
    ICounter __RPC_FAR * This,
    /* [in] */ DWORD dwFlags,
    /* [out] */ int __RPC_FAR *pnValue);


void __RPC_STUB ICounter_GetValue_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICounter_StartStatistics_Proxy( 
    ICounter __RPC_FAR * This);


void __RPC_STUB ICounter_StartStatistics_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICounter_StopStatistics_Proxy( 
    ICounter __RPC_FAR * This);


void __RPC_STUB ICounter_StopStatistics_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICounter_ReadStatistics_Proxy( 
    ICounter __RPC_FAR * This,
    /* [out] */ COUNTERSTAT __RPC_FAR *lpcs);


void __RPC_STUB ICounter_ReadStatistics_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICounter_ClearStatistics_Proxy( 
    ICounter __RPC_FAR * This);


void __RPC_STUB ICounter_ClearStatistics_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICounter_INTERFACE_DEFINED__ */


#ifndef __IReport_INTERFACE_DEFINED__
#define __IReport_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IReport
 * at Sun Apr 19 17:22:14 1998
 * using MIDL 3.01.75
 ****************************************/
/* [unique][helpstring][uuid][object] */ 



EXTERN_C const IID IID_IReport;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("7BC77802-3830-11d0-B143-00C04FC2A118")
    IReport : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Initialize( 
            /* [in] */ char __RPC_FAR *szName,
            /* [in] */ DWORD dwFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Update( 
            /* [in] */ int nValue,
            /* [in] */ DWORD dwIndex) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateEntry( 
            /* [in] */ char __RPC_FAR *szName,
            /* [in] */ DWORD dwIndex) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetValue( 
            /* [in] */ DWORD dwFlags,
            /* [out] */ int __RPC_FAR *pnValue) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IReportVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IReport __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IReport __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IReport __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Initialize )( 
            IReport __RPC_FAR * This,
            /* [in] */ char __RPC_FAR *szName,
            /* [in] */ DWORD dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Update )( 
            IReport __RPC_FAR * This,
            /* [in] */ int nValue,
            /* [in] */ DWORD dwIndex);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CreateEntry )( 
            IReport __RPC_FAR * This,
            /* [in] */ char __RPC_FAR *szName,
            /* [in] */ DWORD dwIndex);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetValue )( 
            IReport __RPC_FAR * This,
            /* [in] */ DWORD dwFlags,
            /* [out] */ int __RPC_FAR *pnValue);
        
        END_INTERFACE
    } IReportVtbl;

    interface IReport
    {
        CONST_VTBL struct IReportVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IReport_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IReport_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IReport_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IReport_Initialize(This,szName,dwFlags)	\
    (This)->lpVtbl -> Initialize(This,szName,dwFlags)

#define IReport_Update(This,nValue,dwIndex)	\
    (This)->lpVtbl -> Update(This,nValue,dwIndex)

#define IReport_CreateEntry(This,szName,dwIndex)	\
    (This)->lpVtbl -> CreateEntry(This,szName,dwIndex)

#define IReport_GetValue(This,dwFlags,pnValue)	\
    (This)->lpVtbl -> GetValue(This,dwFlags,pnValue)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IReport_Initialize_Proxy( 
    IReport __RPC_FAR * This,
    /* [in] */ char __RPC_FAR *szName,
    /* [in] */ DWORD dwFlags);


void __RPC_STUB IReport_Initialize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IReport_Update_Proxy( 
    IReport __RPC_FAR * This,
    /* [in] */ int nValue,
    /* [in] */ DWORD dwIndex);


void __RPC_STUB IReport_Update_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IReport_CreateEntry_Proxy( 
    IReport __RPC_FAR * This,
    /* [in] */ char __RPC_FAR *szName,
    /* [in] */ DWORD dwIndex);


void __RPC_STUB IReport_CreateEntry_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IReport_GetValue_Proxy( 
    IReport __RPC_FAR * This,
    /* [in] */ DWORD dwFlags,
    /* [out] */ int __RPC_FAR *pnValue);


void __RPC_STUB IReport_GetValue_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IReport_INTERFACE_DEFINED__ */


#ifndef __ICounterMgr_INTERFACE_DEFINED__
#define __ICounterMgr_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: ICounterMgr
 * at Sun Apr 19 17:22:14 1998
 * using MIDL 3.01.75
 ****************************************/
/* [unique][helpstring][uuid][object] */ 



EXTERN_C const IID IID_ICounterMgr;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("9CB7FE5B-3444-11D0-B143-00C04FC2A118")
    ICounterMgr : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE CreateCounter( 
            /* [out] */ ICounter __RPC_FAR *__RPC_FAR *lplpCounter) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE FindFirstC( 
            /* [in] */ char __RPC_FAR *szName,
            /* [out] */ FINDCOUNTER __RPC_FAR *lpfc) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE FindNextC( 
            /* [out] */ FINDCOUNTER __RPC_FAR *lpfc) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateReport( 
            /* [out] */ IReport __RPC_FAR *__RPC_FAR *lplpReport) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE FindFirstR( 
            /* [in] */ char __RPC_FAR *szName,
            /* [out] */ FINDREPORT __RPC_FAR *lpfr) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE FindNextR( 
            /* [out] */ FINDREPORT __RPC_FAR *lpfr) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICounterMgrVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ICounterMgr __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ICounterMgr __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ICounterMgr __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CreateCounter )( 
            ICounterMgr __RPC_FAR * This,
            /* [out] */ ICounter __RPC_FAR *__RPC_FAR *lplpCounter);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *FindFirstC )( 
            ICounterMgr __RPC_FAR * This,
            /* [in] */ char __RPC_FAR *szName,
            /* [out] */ FINDCOUNTER __RPC_FAR *lpfc);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *FindNextC )( 
            ICounterMgr __RPC_FAR * This,
            /* [out] */ FINDCOUNTER __RPC_FAR *lpfc);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CreateReport )( 
            ICounterMgr __RPC_FAR * This,
            /* [out] */ IReport __RPC_FAR *__RPC_FAR *lplpReport);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *FindFirstR )( 
            ICounterMgr __RPC_FAR * This,
            /* [in] */ char __RPC_FAR *szName,
            /* [out] */ FINDREPORT __RPC_FAR *lpfr);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *FindNextR )( 
            ICounterMgr __RPC_FAR * This,
            /* [out] */ FINDREPORT __RPC_FAR *lpfr);
        
        END_INTERFACE
    } ICounterMgrVtbl;

    interface ICounterMgr
    {
        CONST_VTBL struct ICounterMgrVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICounterMgr_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICounterMgr_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICounterMgr_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICounterMgr_CreateCounter(This,lplpCounter)	\
    (This)->lpVtbl -> CreateCounter(This,lplpCounter)

#define ICounterMgr_FindFirstC(This,szName,lpfc)	\
    (This)->lpVtbl -> FindFirstC(This,szName,lpfc)

#define ICounterMgr_FindNextC(This,lpfc)	\
    (This)->lpVtbl -> FindNextC(This,lpfc)

#define ICounterMgr_CreateReport(This,lplpReport)	\
    (This)->lpVtbl -> CreateReport(This,lplpReport)

#define ICounterMgr_FindFirstR(This,szName,lpfr)	\
    (This)->lpVtbl -> FindFirstR(This,szName,lpfr)

#define ICounterMgr_FindNextR(This,lpfr)	\
    (This)->lpVtbl -> FindNextR(This,lpfr)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ICounterMgr_CreateCounter_Proxy( 
    ICounterMgr __RPC_FAR * This,
    /* [out] */ ICounter __RPC_FAR *__RPC_FAR *lplpCounter);


void __RPC_STUB ICounterMgr_CreateCounter_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICounterMgr_FindFirstC_Proxy( 
    ICounterMgr __RPC_FAR * This,
    /* [in] */ char __RPC_FAR *szName,
    /* [out] */ FINDCOUNTER __RPC_FAR *lpfc);


void __RPC_STUB ICounterMgr_FindFirstC_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICounterMgr_FindNextC_Proxy( 
    ICounterMgr __RPC_FAR * This,
    /* [out] */ FINDCOUNTER __RPC_FAR *lpfc);


void __RPC_STUB ICounterMgr_FindNextC_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICounterMgr_CreateReport_Proxy( 
    ICounterMgr __RPC_FAR * This,
    /* [out] */ IReport __RPC_FAR *__RPC_FAR *lplpReport);


void __RPC_STUB ICounterMgr_CreateReport_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICounterMgr_FindFirstR_Proxy( 
    ICounterMgr __RPC_FAR * This,
    /* [in] */ char __RPC_FAR *szName,
    /* [out] */ FINDREPORT __RPC_FAR *lpfr);


void __RPC_STUB ICounterMgr_FindFirstR_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICounterMgr_FindNextR_Proxy( 
    ICounterMgr __RPC_FAR * This,
    /* [out] */ FINDREPORT __RPC_FAR *lpfr);


void __RPC_STUB ICounterMgr_FindNextR_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICounterMgr_INTERFACE_DEFINED__ */



#ifndef __Counter_LIBRARY_DEFINED__
#define __Counter_LIBRARY_DEFINED__

/****************************************
 * Generated header for library: Counter
 * at Sun Apr 19 17:22:14 1998
 * using MIDL 3.01.75
 ****************************************/
/* [helpstring][version][uuid] */ 



EXTERN_C const IID LIBID_Counter;

#ifdef __cplusplus
EXTERN_C const CLSID CLSID_Counter;

class DECLSPEC_UUID("9CB7FE5F-3444-11D0-B143-00C04FC2A118")
Counter;
#endif

#ifdef __cplusplus
EXTERN_C const CLSID CLSID_Report;

class DECLSPEC_UUID("9CB7FE5E-3444-11D0-B143-00C04FC2A118")
Report;
#endif

#ifdef __cplusplus
EXTERN_C const CLSID CLSID_CounterMgr;

class DECLSPEC_UUID("65DDC229-38FE-11d0-B143-00C04FC2A118")
CounterMgr;
#endif
#endif /* __Counter_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\h\ih323cc.h ===
/*
 *  	File: ih323cc.h
 *
 *      Microsoft H323 call control interface header file
 *
 *		Revision History:
 *
 *		04/15/96	mikev	created (as inac.h)
 *      
 */

#ifndef _IH323CC_H
#define _IH323CC_H

#include "appavcap.h"
#include "imstream.h"
#include "ividrdr.h"
#include "common.h"
#include "iconnect.h"
#include "iras.h"

#include <pshpack8.h> /* Assume 8 byte packing throughout */
 
typedef WORD H323_TERMINAL_LABEL;   // instead of struct, ensure that this data 
                                    // type is as packed as possible w/zero ambiguity
#define McuNumberFromTl(tl) HIBYTE(tl)  // macros to access terminal label fields
#define TerminalNumberFromTl(tl) LOBYTE(tl)
#define TlFromMcuNumberAndTerminalNumber(mn, tn) MAKEWORD(mn,tn)

//
//	IH323CallControl  
//

#undef INTERFACE
#define INTERFACE IH323CallControl
DECLARE_INTERFACE_( IH323CallControl, IUnknown)
{
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR * ppvObj) PURE;	
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    STDMETHOD(Initialize) (THIS_ PORT *lpPort) PURE;
   	STDMETHOD(SetMaxPPBandwidth)(UINT Bandwidth) PURE;
    STDMETHOD(RegisterConnectionNotify) (THIS_ CNOTIFYPROC pConnectRequestHandler) PURE;
    STDMETHOD(DeregisterConnectionNotify) (THIS_ CNOTIFYPROC pConnectRequestHandler) PURE;
    STDMETHOD(GetNumConnections) (THIS_ ULONG *lp) PURE;
    STDMETHOD(GetConnectionArray)(THIS_ IH323Endpoint **lppArray, UINT uSize) PURE;
    STDMETHOD(CreateConnection) (THIS_ IH323Endpoint **lppConnection, GUID PIDofProtocolType) PURE;
   	STDMETHOD(SetUserDisplayName)(THIS_ LPWSTR lpwName) PURE;

	STDMETHOD(CreateLocalCommChannel)(THIS_ ICommChannel** ppCommChan, LPGUID lpMID,
		IMediaChannel* pMediaChannel) PURE;
	STDMETHOD(SetUserAliasNames)(THIS_ P_H323ALIASLIST pAliases) PURE;
	STDMETHOD(EnableGatekeeper)(THIS_ BOOL bEnable, 
	    PSOCKADDR_IN pGKAddr, 
	    P_H323ALIASLIST pAliases,
	    RASNOTIFYPROC pRasNotifyProc) PURE;
};


#undef INTERFACE
#define INTERFACE IH323ConfAdvise
DECLARE_INTERFACE_( IH323ConfAdvise, IUnknown)
{
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR * ppvObj) PURE;	
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;
    STDMETHOD (CallEvent) (THIS_ IH323Endpoint * lpConnection, DWORD dwStatus) PURE;
    STDMETHOD (ChannelEvent) (THIS_ ICommChannel *pIChannel, 
        IH323Endpoint * lpConnection,	DWORD dwStatus ) PURE;
    STDMETHOD(GetMediaChannel)(THIS_ GUID *pmediaID, BOOL bSendDirection, IMediaChannel **ppI) PURE;	
};


// call this to create the top-level call control object
#define SZ_FNCREATEH323CC     "CreateH323CC"

typedef HRESULT (WINAPI *CREATEH323CC)(IH323CallControl **, BOOL fCallControl, UINT caps);

#include <poppack.h> /* End byte packing */
#endif	//#ifndef _IH323CC_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\h\imstream.h ===
/*++

Copyright (c) 1995-1996  Microsoft Corporation

Module Name:

    medistrm.h

Abstract:
	Contains constants and class declarations for the abstract MediaStream object. A MediaStream
	represents a single unidirectional stream, such as a received Video channel.
	
--*/
#ifndef _IMSTREAM_H_
#define _IMSTREAM_H_

#include <pshpack8.h> /* Assume 8 byte packing throughout */

class IStreamEventNotify
{
public:
	virtual HRESULT __stdcall EventNotification(UINT uDirection, UINT uMediaType, UINT uEventCode, UINT uSubCode)=0;
};


DECLARE_INTERFACE_(IMediaChannel, IUnknown)
{
	// *** IUnknown methods ***
	STDMETHOD(QueryInterface) (THIS_ REFIID riid,LPVOID FAR* ppvObj) PURE;
	STDMETHOD_(ULONG,AddRef) (THIS) PURE;
	STDMETHOD_(ULONG,Release) (THIS) PURE;

	STDMETHOD(GetProperty)(THIS_ DWORD dwProp, PVOID pBuf, LPUINT pcbBuf) PURE;
	STDMETHOD(SetProperty)(THIS_ DWORD dwProp, PVOID pBuf, UINT cbBuf) PURE;
	STDMETHOD(Configure)(THIS_ BYTE *pFormat, UINT cbFormat,
				   BYTE *pChannelParams, UINT cbParams,
				   IUnknown *pUnknown) PURE;
	STDMETHOD(SetNetworkInterface)(THIS_ IUnknown *pUnknown) PURE;
	STDMETHOD(Start)(THIS ) PURE;
	STDMETHOD(Stop)(THIS) PURE;
	STDMETHOD_(DWORD, GetState)(THIS) PURE;
	STDMETHOD(SetMaxBitrate) (THIS_ UINT uMaxBitrate) PURE;
};

class IAudioChannel : public IMediaChannel
{
public:
	virtual HRESULT __stdcall GetSignalLevel(UINT *pLevel)=0;
};


class IVideoChannel : public IMediaChannel
{
public:
	virtual HRESULT __stdcall SetTemporalSpatialTradeOff(DWORD dwVal)=0;
	virtual HRESULT __stdcall GetTemporalSpatialTradeOff(DWORD *pdwVal)=0;
	virtual HRESULT __stdcall SendKeyFrame(void) = 0;
	virtual HRESULT __stdcall ShowDeviceDialog(DWORD dwFlags)=0;
	virtual HRESULT __stdcall GetDeviceDialog(DWORD *pdwFlags)=0;
};


// return values for GetState
#define MSSTATE_UNCONFIGURED    0
#define MSSTATE_CONFIGURED              1
#define MSSTATE_STARTED                 2

// flag values for CreateMediaChannel()
typedef enum 
{
	MCF_SEND = 1,
	MCF_RECV = 2,
	MCF_AUDIO = 4,
	MCF_VIDEO = 8,
	MCF_DEFAULT_DEVICE = 16
} MC_FLAGS;

#undef INTERFACE
#define INTERFACE IMediaChannelBuilder
DECLARE_INTERFACE_( IMediaChannelBuilder, IUnknown)
{
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR * ppvObj) PURE;     
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;
    STDMETHOD(Initialize) (THIS_ HWND hWnd, HINSTANCE hInst) PURE;
    STDMETHOD(CreateMediaChannel) (THIS_ UINT flags, IMediaChannel **ppI) PURE;  
	STDMETHOD(SetStreamEventObj) (THIS_ IStreamEventNotify *pNotify) PURE;
};


class IMixer : public IUnknown
{
public:
	virtual BOOL __stdcall SetVolume(DWORD dwVolume)=0;
	virtual BOOL __stdcall CanSetVolume()=0;
	virtual BOOL __stdcall SetMainVolume(DWORD dwVolume)=0;
	virtual BOOL __stdcall SetSubVolume(DWORD dwVolume)=0;
	virtual BOOL __stdcall SetAGC(BOOL fOn)=0;
	virtual BOOL __stdcall GetMainVolume(LPDWORD pdwVolume)=0;
	virtual BOOL __stdcall GetSubVolume(LPDWORD pdwVolume)=0;
	virtual BOOL __stdcall GetAGC(BOOL *pfOn)=0;
	virtual BOOL __stdcall EnableMicrophone()=0;
	virtual BOOL __stdcall UnMuteVolume()=0;
};

class IAudioDevice : public IUnknown
{
public: 
	virtual HRESULT __stdcall GetRecordID(UINT *puWaveDevID)=0;
	virtual HRESULT __stdcall SetRecordID(UINT uWaveDevID)=0;
	virtual HRESULT __stdcall GetPlaybackID(UINT *puWaveDevID)=0;
	virtual HRESULT __stdcall SetPlaybackID(UINT uWaveDevID)=0;
	virtual HRESULT __stdcall GetDuplex(BOOL *pbFullDuplex)=0;
	virtual HRESULT __stdcall SetDuplex(BOOL bFullDuplex)=0;
	virtual HRESULT __stdcall GetSilenceLevel(UINT *puLevel)=0;
	virtual HRESULT __stdcall SetSilenceLevel(UINT uLevel)=0;
	virtual HRESULT __stdcall GetAutoMix(BOOL *pbAutoMix)=0;
	virtual HRESULT __stdcall SetAutoMix(BOOL bAutoMix)=0;
	virtual HRESULT __stdcall GetDirectSound(BOOL *pbDS)=0;
	virtual HRESULT __stdcall SetDirectSound(BOOL bDS)=0;
	virtual HRESULT __stdcall GetMixer(HWND hwnd, BOOL bPlayback, IMixer **ppMixer)=0;
};


enum STREAM_EVENTS
{
	STREAM_EVENT_DEVICE_FAILURE=1001,
	STREAM_EVENT_DEVICE_OPEN,
	STREAM_EVENT_DEVICE_CLOSE
};


// hiword of GetSignalLevel contains may these status bits
#define SIGNAL_STATUS_TRANSMIT  0x01  // data is being received/sent
#define SIGNAL_STATUS_JAMMED    0x02  // wave dev failed to open


typedef HRESULT (WINAPI *CREATE_SP)(IMediaChannelBuilder **);



#define DTMF_STAR	10
#define DTMF_POUND	11
#define DTMF_A	12
#define DTMF_B	13
#define DTMF_C	14
#define DTMF_D	15

class IDTMFSend : public IUnknown
{
public:
	virtual HRESULT __stdcall AddDigit(int nDigit) = 0;
	virtual HRESULT __stdcall ResetDTMF() = 0;
};


#include <poppack.h> /* End byte packing */


#endif // _MEDISTRM_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\h\incommon.h ===
/****************************************************************************
 *
 *      $Archive:   S:/STURGEON/SRC/INCLUDE/VCS/incommon.h_v  $
 *
 *  INTEL Corporation Prorietary Information
 *
 *  This listing is supplied under the terms of a license agreement
 *  with INTEL Corporation and may not be copied nor disclosed except
 *  in accordance with the terms of that agreement.
 *
 *      Copyright (c) 1996 Intel Corporation.
 *
 *      $Revision:   1.41  $
 *      $Date:   12 Feb 1997 09:34:42  $
 *      $Author:   MANDREWS  $
 *
 *      Deliverable:    INCOMMON.H
 *
 *      Abstract:        commonly used structures
 *
 *
 *      Notes:
 *
 ***************************************************************************/
#ifndef INCOMMON_H
#define INCOMMON_H

#pragma pack(push,8)

#define CC_INVALID_HANDLE                    0

// CCRC_CALL_REJECTED reason codes (includes cause values)
#define CC_REJECT_NO_BANDWIDTH              1
#define CC_REJECT_GATEKEEPER_RESOURCES      2
#define CC_REJECT_UNREACHABLE_DESTINATION   3
#define CC_REJECT_DESTINATION_REJECTION     4
#define CC_REJECT_INVALID_REVISION          5
#define CC_REJECT_NO_PERMISSION             6
#define CC_REJECT_UNREACHABLE_GATEKEEPER    7
#define CC_REJECT_GATEWAY_RESOURCES         8
#define CC_REJECT_BAD_FORMAT_ADDRESS        9
#define CC_REJECT_ADAPTIVE_BUSY             10
#define CC_REJECT_IN_CONF                   11
#define CC_REJECT_ROUTE_TO_GATEKEEPER       12
#define CC_REJECT_CALL_FORWARDED            13
#define CC_REJECT_ROUTE_TO_MC               14
#define CC_REJECT_UNDEFINED_REASON          15
#define CC_REJECT_INTERNAL_ERROR            16    // Internal error occured in peer CS stack.
#define CC_REJECT_NORMAL_CALL_CLEARING      17    // Normal call hangup
#define CC_REJECT_USER_BUSY                 18    // User is busy with another call
#define CC_REJECT_NO_ANSWER                 19    // Callee does not answer
#define CC_REJECT_NOT_IMPLEMENTED           20    // Service has not been implemented
#define CC_REJECT_MANDATORY_IE_MISSING      21    // Pdu missing mandatory ie
#define CC_REJECT_INVALID_IE_CONTENTS       22    // Pdu ie was incorrect
#define CC_REJECT_TIMER_EXPIRED             23    // Own timer expired
#define CC_REJECT_CALL_DEFLECTION           24    // You deflected the call, so lets quit.
#define CC_REJECT_GATEKEEPER_TERMINATED     25    // Gatekeeper terminated call
#define CC_REJECT_SECURITY_DENIED           26    // Security is not compatible

// Q931 call types
#define CC_CALLTYPE_UNKNOWN                 0
#define CC_CALLTYPE_PT_PT                   1
#define CC_CALLTYPE_1_N                     2
#define CC_CALLTYPE_N_1                     3
#define CC_CALLTYPE_N_N                     4

// alias contants
#define CC_ALIAS_MAX_H323_ID                256
#define CC_ALIAS_MAX_H323_PHONE             128

// unicode character mask contants
#define CC_ALIAS_H323_PHONE_CHARS           L"0123456789#*,"
#define CC_ODOTTO_CHARS                     L".0123456789"


// alias type codes
#define CC_ALIAS_H323_ID                    1    // Return call information.
#define CC_ALIAS_H323_PHONE                 2    // H323 Phone Number.

// default port id's
#define CC_H323_GATE_DISC    1718 // Gatekeeper IP Discovery Port
#define CC_H323_GATE_STAT    1719 // Gatekeeper UDP Reg. and Status Port
#define CC_H323_HOST_CALL    1720 // Endpoint TCP Call Signalling Por

// Call creation goals
#define CC_GOAL_UNKNOWN                     0
#define CC_GOAL_CREATE                      1
#define CC_GOAL_JOIN                        2
#define CC_GOAL_INVITE                      3

// H245 non-standard message types
#define CC_H245_MESSAGE_REQUEST             0
#define CC_H245_MESSAGE_RESPONSE            1
#define CC_H245_MESSAGE_COMMAND             2
#define CC_H245_MESSAGE_INDICATION          3

// Call Control handle typedefs
typedef DWORD_PTR    CC_HLISTEN, *PCC_HLISTEN;
typedef DWORD_PTR    CC_HCONFERENCE, *PCC_HCONFERENCE;
typedef DWORD_PTR    CC_HCALL, *PCC_HCALL;
typedef DWORD_PTR    CC_HCHANNEL, *PCC_HCHANNEL;

// IP address in domain name format
typedef struct
{
    WORD         wPort;          // UDP or TCP port (host byte order)
    WCHAR        cAddr[255];     // UNICODE zstring
} CC_IP_DomainName_t;

// IP address in conventional dot notation
typedef struct
{
    WORD         wPort;          // UDP or TCP port (host byte order)
    WCHAR        cAddr[16];      // UNICODE zstring
} CC_IP_Dot_t;

// IP address in binary format
typedef struct
{
    WORD         wPort;          // UDP or TCP port (host byte order)
    DWORD        dwAddr;         // binary address (host byte order)
} CC_IP_Binary_t;

typedef enum
{
    CC_IP_DOMAIN_NAME,
    CC_IP_DOT,
    CC_IP_BINARY
} CC_ADDRTYPE;

typedef struct _ADDR
{
    CC_ADDRTYPE nAddrType;
    BOOL        bMulticast;
    union
    {
        CC_IP_DomainName_t   IP_DomainName;
        CC_IP_Dot_t          IP_Dot;
        CC_IP_Binary_t       IP_Binary;
    } Addr;
} CC_ADDR, *PCC_ADDR;

typedef struct
{
    BYTE *pOctetString;
    WORD wOctetStringLength;
} CC_OCTETSTRING, *PCC_OCTETSTRING;

typedef struct
{
    CC_OCTETSTRING          sData;            // pointer to Octet data.
    BYTE                    bCountryCode;
    BYTE                    bExtension;
    WORD                    wManufacturerCode;
} CC_NONSTANDARDDATA, *PCC_NONSTANDARDDATA;

#define CC_MAX_PRODUCT_LENGTH 256
#define CC_MAX_VERSION_LENGTH 256
#define CC_MAX_DISPLAY_LENGTH 82

typedef struct
{
    BYTE                    bCountryCode;
    BYTE                    bExtension;
    WORD                    wManufacturerCode;
    PCC_OCTETSTRING         pProductNumber;
    PCC_OCTETSTRING         pVersionNumber;
} CC_VENDORINFO, *PCC_VENDORINFO;

typedef struct
{
    PCC_VENDORINFO          pVendorInfo;
    BOOL                    bIsTerminal;
    BOOL                    bIsGateway;    // for now, the H323 capability will be hard-coded.
} CC_ENDPOINTTYPE, *PCC_ENDPOINTTYPE;

typedef struct
{
    WORD                    wType;
    WORD                    wPrefixLength;
    LPWSTR                  pPrefix;
    WORD                    wDataLength;   // UNICODE character count
    LPWSTR                  pData;         // UNICODE data.
} CC_ALIASITEM, *PCC_ALIASITEM;

typedef struct
{
    WORD                    wCount;
    PCC_ALIASITEM           pItems;
} CC_ALIASNAMES, *PCC_ALIASNAMES;

typedef struct _CONFERENCE_ID
{
    BYTE                    buffer[16];  // This is OCTET data, not ASCII.
} CC_CONFERENCEID, *PCC_CONFERENCEID;

#pragma pack(pop)

#endif    INCOMMON_H

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\h\indeopal.h ===
// Indeo Palette

typedef struct Palette_tag
{
	WORD Version;
	WORD NumberOfEntries;
	PALETTEENTRY aEntries[256];
} LOGPALETTE_NM;

static const LOGPALETTE_NM gcLogPaletteIndeo =
{
  0x300,
	256,
	  0,       0,       0,              0,
	  0,       0,       0,              0,
	  0,       0,       0,              0,
	  0,       0,       0,              0,
	  0,       0,       0,              0,
	  0,       0,       0,              0,
	  0,       0,       0,              0,
	  0,       0,       0,              0,
	  0,       0,       0,              0,
	  0,       0,       0,              0,
      0,  39+ 15,       0,  PC_NOCOLLAPSE,
      0,  39+ 24,       0,  PC_NOCOLLAPSE,
      0,  39+ 33,       0,  PC_NOCOLLAPSE,
      0,  39+ 42,       0,  PC_NOCOLLAPSE,
-44+ 51,  39+ 51,       0,  PC_NOCOLLAPSE,
-44+ 60,  39+ 60, -55+ 60,  PC_NOCOLLAPSE,
-44+ 69,  39+ 69, -55+ 69,  PC_NOCOLLAPSE,
-44+ 78,  39+ 78, -55+ 78,  PC_NOCOLLAPSE,
-44+ 87,  39+ 87, -55+ 87,  PC_NOCOLLAPSE,
-44+ 96,  39+ 96, -55+ 96,  PC_NOCOLLAPSE,
-44+105,  39+105, -55+105,  PC_NOCOLLAPSE,
-44+114,  39+114, -55+114,  PC_NOCOLLAPSE,
-44+123,  39+123, -55+123,  PC_NOCOLLAPSE,
-44+132,  39+132, -55+132,  PC_NOCOLLAPSE,
-44+141,  39+141, -55+141,  PC_NOCOLLAPSE,
-44+150,  39+150, -55+150,  PC_NOCOLLAPSE,
-44+159,  39+159, -55+159,  PC_NOCOLLAPSE,
-44+168,  39+168, -55+168,  PC_NOCOLLAPSE,
-44+177,  39+177, -55+177,  PC_NOCOLLAPSE,
-44+186,  39+186, -55+186,  PC_NOCOLLAPSE,
-44+195,  39+195, -55+195,  PC_NOCOLLAPSE,
-44+204,  39+204, -55+204,  PC_NOCOLLAPSE,
-44+213,  39+213, -55+213,  PC_NOCOLLAPSE,
-44+222,     255, -55+222,  PC_NOCOLLAPSE,
-44+231,     255, -55+231,  PC_NOCOLLAPSE,
-44+240,     255, -55+240,  PC_NOCOLLAPSE,

      0,  26+ 15,   0+ 15,  PC_NOCOLLAPSE,
      0,  26+ 24,   0+ 24,  PC_NOCOLLAPSE,
      0,  26+ 33,   0+ 33,  PC_NOCOLLAPSE,
      0,  26+ 42,   0+ 42,  PC_NOCOLLAPSE,
-44+ 51,  26+ 51,   0+ 51,  PC_NOCOLLAPSE,
-44+ 60,  26+ 60,   0+ 60,  PC_NOCOLLAPSE,
-44+ 69,  26+ 69,   0+ 69,  PC_NOCOLLAPSE,
-44+ 78,  26+ 78,   0+ 78,  PC_NOCOLLAPSE,
-44+ 87,  26+ 87,   0+ 87,  PC_NOCOLLAPSE,
-44+ 96,  26+ 96,   0+ 96,  PC_NOCOLLAPSE,
-44+105,  26+105,   0+105,  PC_NOCOLLAPSE,
-44+114,  26+114,   0+114,  PC_NOCOLLAPSE,
-44+123,  26+123,   0+123,  PC_NOCOLLAPSE,
-44+132,  26+132,   0+132,  PC_NOCOLLAPSE,
-44+141,  26+141,   0+141,  PC_NOCOLLAPSE,
-44+150,  26+150,   0+150,  PC_NOCOLLAPSE,
-44+159,  26+159,   0+159,  PC_NOCOLLAPSE,
-44+168,  26+168,   0+168,  PC_NOCOLLAPSE,
-44+177,  26+177,   0+177,  PC_NOCOLLAPSE,
-44+186,  26+186,   0+186,  PC_NOCOLLAPSE,
-44+195,  26+195,   0+195,  PC_NOCOLLAPSE,
-44+204,  26+204,   0+204,  PC_NOCOLLAPSE,
-44+213,  26+213,   0+213,  PC_NOCOLLAPSE,
-44+222,  26+222,   0+222,  PC_NOCOLLAPSE,
-44+231,     255,   0+231,  PC_NOCOLLAPSE,
-44+240,     255,   0+240,  PC_NOCOLLAPSE,

      0,  14+ 15,  55+ 15,  PC_NOCOLLAPSE,
      0,  14+ 24,  55+ 24,  PC_NOCOLLAPSE,
      0,  14+ 33,  55+ 33,  PC_NOCOLLAPSE,
      0,  14+ 42,  55+ 42,  PC_NOCOLLAPSE,
-44+ 51,  14+ 51,  55+ 51,  PC_NOCOLLAPSE,
-44+ 60,  14+ 60,  55+ 60,  PC_NOCOLLAPSE,
-44+ 69,  14+ 69,  55+ 69,  PC_NOCOLLAPSE,
-44+ 78,  14+ 78,  55+ 78,  PC_NOCOLLAPSE,
-44+ 87,  14+ 87,  55+ 87,  PC_NOCOLLAPSE,
-44+ 96,  14+ 96,  55+ 96,  PC_NOCOLLAPSE,
-44+105,  14+105,  55+105,  PC_NOCOLLAPSE,
-44+114,  14+114,  55+114,  PC_NOCOLLAPSE,
-44+123,  14+123,  55+123,  PC_NOCOLLAPSE,
-44+132,  14+132,  55+132,  PC_NOCOLLAPSE,

// Replace this entry with a more ie-logo-friendly color 
// -44+141,  14+141,  55+141,  PC_NOCOLLAPSE,
     51,     153,     255,  PC_NOCOLLAPSE,

-44+150,  14+150,  55+150,  PC_NOCOLLAPSE,
-44+159,  14+159,  55+159,  PC_NOCOLLAPSE,
-44+168,  14+168,  55+168,  PC_NOCOLLAPSE,
-44+177,  14+177,  55+177,  PC_NOCOLLAPSE,
-44+186,  14+186,  55+186,  PC_NOCOLLAPSE,
-44+195,  14+195,  55+195,  PC_NOCOLLAPSE,
-44+204,  14+204,     255,  PC_NOCOLLAPSE,
-44+213,  14+213,     255,  PC_NOCOLLAPSE,
-44+222,     255,     255,  PC_NOCOLLAPSE,
-44+231,     255,     255,  PC_NOCOLLAPSE,
-44+240,     255,     255,  PC_NOCOLLAPSE,

  0+ 15,  13+ 15,       0,  PC_NOCOLLAPSE,
  0+ 24,  13+ 24,       0,  PC_NOCOLLAPSE,
  0+ 33,  13+ 33,       0,  PC_NOCOLLAPSE,
  0+ 42,  13+ 42,       0,  PC_NOCOLLAPSE,
  0+ 51,  13+ 51,       0,  PC_NOCOLLAPSE,
  0+ 60,  13+ 60, -55+ 60,  PC_NOCOLLAPSE,
  0+ 69,  13+ 69, -55+ 69,  PC_NOCOLLAPSE,
  0+ 78,  13+ 78, -55+ 78,  PC_NOCOLLAPSE,
  0+ 87,  13+ 87, -55+ 87,  PC_NOCOLLAPSE,
  0+ 96,  13+ 96, -55+ 96,  PC_NOCOLLAPSE,
  0+105,  13+105, -55+105,  PC_NOCOLLAPSE,
  0+114,  13+114, -55+114,  PC_NOCOLLAPSE,
  0+123,  13+123, -55+123,  PC_NOCOLLAPSE,
  0+132,  13+132, -55+132,  PC_NOCOLLAPSE,
  0+141,  13+141, -55+141,  PC_NOCOLLAPSE,
  0+150,  13+150, -55+150,  PC_NOCOLLAPSE,
  0+159,  13+159, -55+159,  PC_NOCOLLAPSE,
  0+168,  13+168, -55+168,  PC_NOCOLLAPSE,
  0+177,  13+177, -55+177,  PC_NOCOLLAPSE,
  0+186,  13+186, -55+186,  PC_NOCOLLAPSE,
  0+195,  13+195, -55+195,  PC_NOCOLLAPSE,
  0+204,  13+204, -55+204,  PC_NOCOLLAPSE,
  0+213,  13+213, -55+213,  PC_NOCOLLAPSE,
  0+222,  13+222, -55+222,  PC_NOCOLLAPSE,
  0+231,  13+231, -55+231,  PC_NOCOLLAPSE,
  0+240,  13+242, -55+240,  PC_NOCOLLAPSE,

  0+ 15,   0+ 15,   0+ 15,  PC_NOCOLLAPSE,
  0+ 24,   0+ 24,   0+ 24,  PC_NOCOLLAPSE,
  0+ 33,   0+ 33,   0+ 33,  PC_NOCOLLAPSE,
  0+ 42,   0+ 42,   0+ 42,  PC_NOCOLLAPSE,
  0+ 51,   0+ 51,   0+ 51,  PC_NOCOLLAPSE,
  0+ 60,   0+ 60,   0+ 60,  PC_NOCOLLAPSE,
  0+ 69,   0+ 69,   0+ 69,  PC_NOCOLLAPSE,
  0+ 78,   0+ 78,   0+ 78,  PC_NOCOLLAPSE,
  0+ 87,   0+ 87,   0+ 87,  PC_NOCOLLAPSE,
  0+ 96,   0+ 96,   0+ 96,  PC_NOCOLLAPSE,
  0+105,   0+105,   0+105,  PC_NOCOLLAPSE,
  0+114,   0+114,   0+114,  PC_NOCOLLAPSE,
  0+123,   0+123,   0+123,  PC_NOCOLLAPSE,
  0+132,   0+132,   0+132,  PC_NOCOLLAPSE,
  0+141,   0+141,   0+141,  PC_NOCOLLAPSE,
  0+150,   0+150,   0+150,  PC_NOCOLLAPSE,
  0+159,   0+159,   0+159,  PC_NOCOLLAPSE,
  0+168,   0+168,   0+168,  PC_NOCOLLAPSE,
  0+177,   0+177,   0+177,  PC_NOCOLLAPSE,
  0+186,   0+186,   0+186,  PC_NOCOLLAPSE,
  0+195,   0+195,   0+195,  PC_NOCOLLAPSE,
  0+204,   0+204,   0+204,  PC_NOCOLLAPSE,
  0+213,   0+213,   0+213,  PC_NOCOLLAPSE,
  0+222,   0+222,   0+222,  PC_NOCOLLAPSE,
  0+231,   0+231,   0+231,  PC_NOCOLLAPSE,
  0+240,   0+240,   0+240,  PC_NOCOLLAPSE,

  0+ 15, -13+ 15,  55+ 15,  PC_NOCOLLAPSE,
  0+ 24, -13+ 24,  55+ 24,  PC_NOCOLLAPSE,
  0+ 33, -13+ 33,  55+ 33,  PC_NOCOLLAPSE,
  0+ 42, -13+ 42,  55+ 42,  PC_NOCOLLAPSE,
  0+ 51, -13+ 51,  55+ 51,  PC_NOCOLLAPSE,
  0+ 60, -13+ 60,  55+ 60,  PC_NOCOLLAPSE,
  0+ 69, -13+ 69,  55+ 69,  PC_NOCOLLAPSE,
  0+ 78, -13+ 78,  55+ 78,  PC_NOCOLLAPSE,
  0+ 87, -13+ 87,  55+ 87,  PC_NOCOLLAPSE,
  0+ 96, -13+ 96,  55+ 96,  PC_NOCOLLAPSE,
  0+105, -13+105,  55+105,  PC_NOCOLLAPSE,
  0+114, -13+114,  55+114,  PC_NOCOLLAPSE,
  0+123, -13+123,  55+123,  PC_NOCOLLAPSE,
  0+132, -13+132,  55+132,  PC_NOCOLLAPSE,
  0+141, -13+141,  55+141,  PC_NOCOLLAPSE,
  0+150, -13+150,  55+150,  PC_NOCOLLAPSE,
  0+159, -13+159,  55+159,  PC_NOCOLLAPSE,
  0+168, -13+168,  55+168,  PC_NOCOLLAPSE,
  0+177, -13+177,  55+177,  PC_NOCOLLAPSE,
  0+186, -13+186,  55+186,  PC_NOCOLLAPSE,
  0+195, -13+195,  55+195,  PC_NOCOLLAPSE,
  0+204, -13+204,     255,  PC_NOCOLLAPSE,
  0+213, -13+213,     255,  PC_NOCOLLAPSE,
  0+222, -13+222,     255,  PC_NOCOLLAPSE,
  0+231, -13+231,     255,  PC_NOCOLLAPSE,
  0+240, -13+240,     255,  PC_NOCOLLAPSE,

 44+ 15, -14+ 15,       0,  PC_NOCOLLAPSE,
 44+ 24, -14+ 24,       0,  PC_NOCOLLAPSE,
 44+ 33, -14+ 33,       0,  PC_NOCOLLAPSE,
 44+ 42, -14+ 42,       0,  PC_NOCOLLAPSE,
 44+ 51, -14+ 51,       0,  PC_NOCOLLAPSE,
 44+ 60, -14+ 60, -55+ 60,  PC_NOCOLLAPSE,
 44+ 69, -14+ 69, -55+ 69,  PC_NOCOLLAPSE,
 44+ 78, -14+ 78, -55+ 78,  PC_NOCOLLAPSE,
 44+ 87, -14+ 87, -55+ 87,  PC_NOCOLLAPSE,
 44+ 96, -14+ 96, -55+ 96,  PC_NOCOLLAPSE,
 44+105, -14+105, -55+105,  PC_NOCOLLAPSE,
 44+114, -14+114, -55+114,  PC_NOCOLLAPSE,
 44+123, -14+123, -55+123,  PC_NOCOLLAPSE,
 44+132, -14+132, -55+132,  PC_NOCOLLAPSE,
 44+141, -14+141, -55+141,  PC_NOCOLLAPSE,
 44+150, -14+150, -55+150,  PC_NOCOLLAPSE,
 44+159, -14+159, -55+159,  PC_NOCOLLAPSE,
 44+168, -14+168, -55+168,  PC_NOCOLLAPSE,
 44+177, -14+177, -55+177,  PC_NOCOLLAPSE,
 44+186, -14+186, -55+186,  PC_NOCOLLAPSE,
 44+195, -14+195, -55+195,  PC_NOCOLLAPSE,
 44+204, -14+204, -55+204,  PC_NOCOLLAPSE,
    255, -14+213, -55+213,  PC_NOCOLLAPSE,
    255, -14+222, -55+222,  PC_NOCOLLAPSE,
    255, -14+231, -55+231,  PC_NOCOLLAPSE,
    255, -14+242, -55+240,  PC_NOCOLLAPSE,

 44+ 15,       0,   0+ 15,  PC_NOCOLLAPSE,
 44+ 24,       0,   0+ 24,  PC_NOCOLLAPSE,
 44+ 33, -26+ 33,   0+ 33,  PC_NOCOLLAPSE,
 44+ 42, -26+ 42,   0+ 42,  PC_NOCOLLAPSE,
 44+ 51, -26+ 51,   0+ 51,  PC_NOCOLLAPSE,
 44+ 60, -26+ 60,   0+ 60,  PC_NOCOLLAPSE,
 44+ 69, -26+ 69,   0+ 69,  PC_NOCOLLAPSE,
 44+ 78, -26+ 78,   0+ 78,  PC_NOCOLLAPSE,
 44+ 87, -26+ 87,   0+ 87,  PC_NOCOLLAPSE,
 44+ 96, -26+ 96,   0+ 96,  PC_NOCOLLAPSE,
 44+105, -26+105,   0+105,  PC_NOCOLLAPSE,
 44+114, -26+114,   0+114,  PC_NOCOLLAPSE,
 44+123, -26+123,   0+123,  PC_NOCOLLAPSE,
 44+132, -26+132,   0+132,  PC_NOCOLLAPSE,
 44+141, -26+141,   0+141,  PC_NOCOLLAPSE,
 44+150, -26+150,   0+150,  PC_NOCOLLAPSE,
 44+159, -26+159,   0+159,  PC_NOCOLLAPSE,
 44+168, -26+168,   0+168,  PC_NOCOLLAPSE,
 44+177, -26+177,   0+177,  PC_NOCOLLAPSE,
 44+186, -26+186,   0+186,  PC_NOCOLLAPSE,
 44+195, -26+195,   0+195,  PC_NOCOLLAPSE,
 44+204, -26+204,   0+204,  PC_NOCOLLAPSE,
    255, -26+213,   0+213,  PC_NOCOLLAPSE,
    255, -26+222,   0+222,  PC_NOCOLLAPSE,
    255, -26+231,   0+231,  PC_NOCOLLAPSE,
    255, -26+240,   0+240,  PC_NOCOLLAPSE,

 44+ 15,       0,  55+ 15,  PC_NOCOLLAPSE,
 44+ 24,       0,  55+ 24,  PC_NOCOLLAPSE,
 44+ 33,       0,  55+ 33,  PC_NOCOLLAPSE,
 44+ 42, -39+ 42,  55+ 42,  PC_NOCOLLAPSE,
 44+ 51, -39+ 51,  55+ 51,  PC_NOCOLLAPSE,
 44+ 60, -39+ 60,  55+ 60,  PC_NOCOLLAPSE,
 44+ 69, -39+ 69,  55+ 69,  PC_NOCOLLAPSE,
 44+ 78, -39+ 78,  55+ 78,  PC_NOCOLLAPSE,
 44+ 87, -39+ 87,  55+ 87,  PC_NOCOLLAPSE,
 44+ 96, -39+ 96,  55+ 96,  PC_NOCOLLAPSE,
 44+105, -39+105,  55+105,  PC_NOCOLLAPSE,
 44+114, -39+114,  55+114,  PC_NOCOLLAPSE,
 44+123, -39+123,  55+123,  PC_NOCOLLAPSE,
 44+132, -39+132,  55+132,  PC_NOCOLLAPSE,
 44+141, -39+141,  55+141,  PC_NOCOLLAPSE,
 44+150, -39+150,  55+150,  PC_NOCOLLAPSE,
 44+159, -39+159,  55+159,  PC_NOCOLLAPSE,
 44+168, -39+168,  55+168,  PC_NOCOLLAPSE,
 44+177, -39+177,  55+177,  PC_NOCOLLAPSE,
 44+186, -39+186,  55+186,  PC_NOCOLLAPSE,
 44+195, -39+195,  55+195,  PC_NOCOLLAPSE,
 44+204, -39+204,     255,  PC_NOCOLLAPSE,
    255, -39+213,     255,  PC_NOCOLLAPSE,
    255, -39+222,     255,  PC_NOCOLLAPSE,
    255, -39+231,     255,  PC_NOCOLLAPSE,
    255, -39+240,     255,  PC_NOCOLLAPSE,

   0x81, 0x81, 0x83, PC_NOCOLLAPSE, 
   0x81, 0x81, 0x84, PC_NOCOLLAPSE,

	  0,       0,       0,              0,
	  0,       0,       0,              0,
	  0,       0,       0,              0,
	  0,       0,       0,              0,
	  0,       0,       0,              0,
	  0,       0,       0,              0,
	  0,       0,       0,              0,
	  0,       0,       0,              0,
	  0,       0,       0,              0,
	255,     255,     255,              0
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\h\intlutil.h ===
// File: intl.h

#ifndef _INTL_H_
#define _INTL_H_

#ifdef __cplusplus
extern "C" {
#endif
// This needs to be loaded by the only code that is not C++ (app sharing)
HINSTANCE NMINTERNAL LoadNmRes(LPCTSTR pszFileFormat);
#ifdef __cplusplus
}
#endif

#endif /* _INTL_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\h\iras.h ===
/*
 *  	File: iras.h
 *
 *      Gatekeeper status interface header file
 *
 *		Revision History:
 *
 *		08/28/98	mikev	created 
 *      
 */

#ifndef _IRAS_H
#define _IRAS_H

#include <pshpack8.h> /* Assume 8 byte packing throughout */

// RAS event codes
#define RAS_REG_TIMEOUT     0  // GK did not respond
#define RAS_REG_CONFIRM     1  // received RCF (registration confirmed)
#define RAS_UNREG_CONFIRM   2  // received UCF (unregistration confirmed) 
#define RAS_REJECTED        3  // received RRJ (registration rejected)
#define RAS_UNREG_REQ       4  // received URQ 
                                        // (unregistration request - means that  
                                        // gatekeeper booted the endpoint off)

// Note that if RRJ or URQ is received, no calls can be placed until 
// successfully registering.

// reason codes for RRJ.  Note that these map to the ASN.1 defined reason
// values in H.225. But the ASN.1 headers aren't exposed to the world.
// It would cause build nightmares to do so. The headers are generated by the 
// ASN.1 compiler from ASN.1 source that is sometimes updated. Sometimes
// duplicate names in the source result in name decoration in the generated headers
// and that causes compilation errors in anything that references what changed.

// fortunately, the code deep in the stack that actually propagates these upward 
// IS exposed to both headers, and has compile-time tests for equality.  If 
// these don't match the real codes, that code will not compile

#define RRJ_DISCOVERY_REQ       1  // discovery required 
#define RRJ_INVALID_REVISION    2
#define RRJ_INVALID_CALL_ADDR   3
#define RRJ_INVALID_RAS_ADDR    4
#define RRJ_DUPLICATE_ALIAS     5
#define RRJ_INVALID_TERMINAL_TYPE   6
#define RRJ_UNDEFINED           7
#define RRJ_TRANSPORT_NOT_SUPPORTED 8
#define RRJ_TRANSPORT_QOS_NOT_SUPPORTED 9
#define RRJ_RESOURCE_UNAVAILABLE    10
#define RRJ_INVALID_ALIAS       11
#define RRJ_SECURITY_DENIAL     12

// reason codes for GK initiated Unregistration Request

#define URQ_REREG_REQUIRED  1  // GK wants another registration
#define URQ_TTL_EXPIRED     2  // TimeToLive expired
#define URQ_SECURITY_DENIAL 3
#define URQ_UNDEFINED       4 

// reason codes for Admission Reject (ARJ)

#define ARJ_CALLEE_NOT_REGISTERED    1
#define ARJ_INVALID_PERMISSION       2
#define ARJ_REQUEST_DENIED           3
#define ARJ_UNDEFINED                4
#define ARJ_CALLER_NOT_REGISTERED    5
#define ARJ_ROUTE_TO_GK              6
#define ARJ_INVALID_ENDPOINT_ID      7
#define ARJ_RESOURCE_UNAVAILABLE     8
#define ARJ_SECURTY_DENIAL           9
#define ARJ_QOS_CONTROL_NOT_SUPPORTED 10
#define ARJ_INCOMPLETE_ADDRESS       11
#define MAX_ARJ_H225_REASON          ARJ_INCOMPLETE_ADDRESS
// The following is not a real H.225 reason code for ARJ.   
// It is generated internally when there is an ARJ timeout
#define ARJ_TIMEOUT MAX_ARJ_H225_REASON+1

typedef  VOID (__stdcall *RASNOTIFYPROC)(DWORD dwRasEvent, HRESULT hReason);
   

#include <poppack.h> /* End byte packing */
#endif	//#ifndef _IRAS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\h\inifile.h ===
/*
 * inifile.h - Initialization file processing module description.
 *
 * Taken from URL code by ChrisPi 9-11-95
 *
 */

#ifndef _INIFILE_H_
#define _INIFILE_H_

/* Types
 ********/

#ifdef DEBUG

/* .ini switch types */

typedef enum _iniswitchtype
{
   IST_BOOL,
   IST_DEC_INT,
   IST_UNS_DEC_INT,
   IST_BIN
}
INISWITCHTYPE;
DECLARE_STANDARD_TYPES(INISWITCHTYPE);

/* boolean .ini switch */

typedef struct _booliniswitch
{
   INISWITCHTYPE istype;      /* must be IST_BOOL */

   PCSTR pcszKeyName;

   PDWORD pdwParentFlags;

   DWORD dwFlag;
}
BOOLINISWITCH;
DECLARE_STANDARD_TYPES(BOOLINISWITCH);

/* decimal integer .ini switch */

typedef struct _decintiniswitch
{
   INISWITCHTYPE istype;      /* must be IST_DEC_INT */

   PCSTR pcszKeyName;

   PINT pnValue;
}
DECINTINISWITCH;
DECLARE_STANDARD_TYPES(DECINTINISWITCH);

/* unsigned decimal integer .ini switch */

typedef struct _unsdecintiniswitch
{
   INISWITCHTYPE istype;      /* must be IST_UNS_DEC_INT */

   PCSTR pcszKeyName;

   PUINT puValue;
}
UNSDECINTINISWITCH;
DECLARE_STANDARD_TYPES(UNSDECINTINISWITCH);

/* binary (hex data) .ini switch */

typedef struct _bininiswitch
{
   INISWITCHTYPE istype;      /* must be IST_BIN */

   PCSTR pcszKeyName;

   DWORD dwSize;

   PVOID pb;
}
BININISWITCH;
DECLARE_STANDARD_TYPES(BININISWITCH);

#endif


/* Global Variables
 *******************/

#ifdef DEBUG

/* defined by client */

extern PCSTR g_pcszIniFile;
extern PCSTR g_pcszIniSection;

#endif


/* Prototypes
 *************/

#ifdef DEBUG

/* inifile.c */

extern BOOL SetIniSwitches(const PCVOID *, UINT);
extern BOOL WriteIniData(const PCVOID *);
extern BOOL WriteIniSwitches(const PCVOID *, UINT);

#endif

#endif /* _INIFILE_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\h\iprop.h ===
//  IPROP.H
//
//      IProperty interface.
//
//      A simple property mechanism to query and set properties on media objects.
//
//  Created 12-Oct-96 [JonT]

#ifndef _IPROPERTY_H
#define _IPROPERTY_H

#include <pshpack8.h> /* Assume 8 byte packing throughout */

DECLARE_INTERFACE_(IProperty, IUnknown)
//DECLARE_INTERFACE(IProperty)
{
	// *** IUnknown methods ***
	STDMETHOD(QueryInterface) (THIS_ REFIID riid,LPVOID FAR* ppvObj) PURE;
	STDMETHOD_(ULONG,AddRef) (THIS) PURE;
	STDMETHOD_(ULONG,Release) (THIS) PURE;

	STDMETHOD(GetProperty)(THIS_ DWORD dwProp, PVOID pBuf, LPUINT pcbBuf) PURE;
	STDMETHOD(SetProperty)(THIS_ DWORD dwProp, PVOID pBuf, UINT cbBuf) PURE;
};

typedef IProperty *LPIProperty;

// Currently defined properties
#define PROP_NET_SEND_STATS         4	// RTP_STATS
#define PROP_NET_RECV_STATS         5	// RTP_STATS
#define PROP_RTP_PAYLOAD	        6	// (dword) RTP payload type
#define PROP_VOLUME	                7	
#define PROP_SILENCE_LEVEL	        8	// (dword)
#define PROP_DURATION	            9	// (dword) avg. pkt duration in ms
#define PROP_SILENCE_DURATION	    10	// (dword) silence duration before recording stops, in ms
#define PROP_WAVE_DEVICE_TYPE	    11	// (dword) play,rec, full duplex capability
#define PROP_DUPLEX_TYPE	        12	// (dword) current mode
#define PROP_AUDIO_SPP	            13	// (dword)
#define PROP_AUDIO_SPS	            14	// (dword)
#define PROP_VOICE_SWITCH	        15	// (dword) auto or manual voice switching
#define PROP_AUDIO_STRENGTH	        16	// (dword) send audio strength
#define PROP_RECV_AUDIO_STRENGTH	17	// (dword) recv audio strength
#define PROP_RECORD_ON	            18	// (dword) enable or disable record
#define PROP_PLAY_ON	            19	// (dword) enable or disable playback
#define PROP_RECORD_DEVICE	        20	// (dword) device id of waveIn
#define PROP_PLAYBACK_DEVICE	    21	// (dword) device id of waveOut
#define PROP_VIDEO_CAPTURE_AVAILABLE 22	// (bool)
#define PROP_VIDEO_CAPTURE_DIALOGS_AVAILABLE 23 // (dword) CAPTURE_DIALOG_SOURCE and/or CAPTURE_DIALOG_FORMAT
#define PROP_VIDEO_CAPTURE_DIALOG   24	// (dword) CAPTURE_DIALOG_SOURCE or CAPTURE_DIALOG_FORMAT
#define PROP_VIDEO_FRAME_RATE       25	// (dword) FRAMERATE_LOW or FRAMERATE_HIGH
#define PROP_VIDEO_SIZE_AVAIL       26	// (dword) FRAME_CIF, FRAME_QCIF, FRAME_SQCIF
#define PROP_VIDEO_SIZE             27	// (dword) FRAME_CIF, FRAME_QCIF, FRAME_SQCIF
#define PROP_VIDEO_PREVIEW_ON		28	// (bool) enable/disable video preview
#define PROP_VIDEO_POSTPROCESSING_SUPPORTED		29	// (bool) used to query the datapump: TRUE is returned if codec supports post-processing
#define PROP_VIDEO_BRIGHTNESS		30	// (dword) sets the brightness of the video data displayed in the Remote window
#define PROP_VIDEO_CONTRAST			31	// (dword) sets the contrast of the video data displayed in the Remote window
#define PROP_VIDEO_SATURATION		32	// (dword) sets the saturation of the video data displayed in the Remote window
#define PROP_VIDEO_IMAGE_QUALITY	33	// (dword) a number between 100 (low quality) and 10000 (high quality)
#define PROP_VIDEO_RESET_BRIGHTNESS	34	// (dword) restores the default brightness of the video data displayed in the Remote window
#define PROP_VIDEO_RESET_CONTRAST	35	// (dword) restores the default contrast of the video data displayed in the Remote window
#define PROP_VIDEO_RESET_SATURATION	36	// (dword) restores the default saturation of the video data displayed in the Remote window
#define PROP_VIDEO_RESET_IMAGE_QUALITY	37	// (dword) a number between 100 (low quality) and 10000 (high quality)
#define PROP_VIDEO_AUDIO_SYNC		38	// (bool) enable A/V sync
#define PROP_MAX_PP_BITRATE			39	// (dword) max point-to-point bitrate of current connection

#define PROP_CHANNEL_ENABLED		41	// (bool) independently enable send/receive on a channel
#define PROP_LOCAL_FORMAT_ID		42	// (dword) unique ID of local compression format
#define PROP_REMOTE_FORMAT_ID		43  // (dword) unique ID of remote compression format
#define PROP_TS_TRADEOFF			44  // (dword) value of temporal/spatial tradeoff (video quality)
#define PROP_REMOTE_TS_CAPABLE		45	// (bool) temporal/spatial tradeoff is remotely controllable
#define PROP_TS_TRADEOFF_IND		46	// (dword) internally set by control channel only

#define PROP_PAUSE_SEND				50	// (bool) disables packet transmission, when read, indicates the current state of the network stream
#define PROP_PAUSE_RECV				51	// (bool) disables packet reception, when read, indicates the current state of the network stream

#define PROP_REMOTE_PAUSED			52	// (bool, read-only) channel is paused at remote end
#define PROP_VIDEO_PREVIEW_STANDBY	54	// (bool) stop preview but leave capture device open
#define PROP_LOCAL_PAUSE_SEND   	55	// (bool) disables packet transmission, sticky local state
#define PROP_LOCAL_PAUSE_RECV   	56	// (bool) disables packet reception, sticky local state

#define PROP_CAPTURE_DEVICE	        57	// (dword) device id of capture device
#define PROP_AUDIO_JAMMED	58 // (bool) TRUE if the audio device is
                              // failing to open or if another application
                              // owns the audio device
#define PROP_AUDIO_AUTOMIX	59  // (bool) enable self-adjusting mixer

// Equates used by properties

#define CAPTURE_DIALOG_SOURCE       1
#define CAPTURE_DIALOG_FORMAT       2
#define FRAMERATE_LOW               1
#define FRAMERATE_HIGH              2
#define FRAME_SQCIF                 1
#define FRAME_QCIF                  2
#define FRAME_CIF                   4
#define VOICE_SWITCH_AUTO			1
#define VOICE_SWITCH_MIC_ON			2
#define VOICE_SWITCH_MIC_OFF		4
#define DUPLEX_TYPE_FULL			1
#define DUPLEX_TYPE_HALF			0



#include <poppack.h> /* End byte packing */

#endif //_IPROPERTY_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\h\isdmapi.h ===
#ifndef _ISDMAPI_H_
#define _ISDMAPI_H_

/****************************************************************************
 *
 *	$Archive:   S:/STURGEON/SRC/INCLUDE/VCS/isdmapi.h_v  $
 *
 *  INTEL Corporation Prorietary Information
 *
 *  This listing is supplied under the terms of a license agreement
 *  with INTEL Corporation and may not be copied nor disclosed except
 *  in accordance with the terms of that agreement.
 *
 *	Copyright (c) 1993-1994 Intel Corporation.
 *
 *	$Revision:   1.12  $
 *	$Date:   Aug 15 1996 14:23:36  $
 *	$Author:   dmgorlic  $
 *
 *	Deliverable:
 *
 *	Abstract:
 *
 *	Notes:
 *
 ***************************************************************************/

#include "apierror.h"

#ifdef __cplusplus
extern "C" {				// Assume C declarations for C++.
#endif // __cplusplus

#ifndef DllExport
#define DllExport	__declspec( dllexport )
#endif	// DllExport

typedef DWORD	HSTATSESSION,	*LPHSTATSESSION;

#define MAX_SESSNAME_LENGTH		25 
#define MAX_MODNAME_LENGTH		20
#define MAX_SESSIDENT_LENGTH	256 //consistant with max cName length
#define MAX_STATNAME_LENGTH		256
//stat item string name
typedef char STATNAME[MAX_STATNAME_LENGTH], *LPSTATNAME;
//session string name
typedef char SESSIONNAME[MAX_SESSNAME_LENGTH], *LPSESSIONNAME;
//module name
typedef char MODULENAME[MAX_MODNAME_LENGTH], *LPMODULENAME;
//identifier length
typedef char SESSIONIDENT[MAX_SESSIDENT_LENGTH], *LPSESSIONIDENT;


typedef struct STATSTRUCT
{
	DWORD		dwStructSize;				// size of the structure
	STATNAME	szStatName;					// string name of the stat item
	DWORD		dwToken;					// session unique id of the stat item
	DWORD		dwValue;					// value(data) of the stat item
	DWORD		dwLow;						// low value for range of value
	DWORD		dwHigh;						// hi value for range of value
	DWORD		dwLastUpdate;				// time stamp of last update
} STAT, *LPSTAT;

// Typedefs for ISDM application entry points to ensure stricter checking
// when functions are called via pointers
//
typedef HRESULT		(*ISD_REGISTER_SESSION)		(LPMODULENAME, LPSESSIONNAME, LPSESSIONIDENT, LPHSTATSESSION);
typedef HRESULT		(*ISD_CREATESTAT)			(HSTATSESSION, LPSTAT, WORD);
typedef HRESULT		(*ISD_UNREGISTERSESSION)	(HSTATSESSION);
typedef HRESULT		(*ISD_DELETESTAT)			(HSTATSESSION, LPSTAT, WORD);
typedef HRESULT		(*ISD_UPDATESTAT)			(HSTATSESSION, LPSTAT, WORD);
typedef HRESULT		(*ISD_GETFIRSTSESSION)		(LPMODULENAME, LPSESSIONNAME, LPSESSIONIDENT, LPHSTATSESSION);
typedef HRESULT		(*ISD_GETNEXTSESSION)		(HSTATSESSION, LPMODULENAME, LPSESSIONNAME, LPSESSIONIDENT, LPHSTATSESSION);
typedef HRESULT		(*ISD_GETNUMSESSIONS)		(WORD *);
typedef HRESULT		(*ISD_GETFIRSTSTAT)			(HSTATSESSION, LPSTAT);
typedef HRESULT		(*ISD_GETNEXTSTAT)			(HSTATSESSION, LPSTAT, LPSTAT);
typedef HRESULT		(*ISD_GETNUMSTATS)			(HSTATSESSION, WORD *);
typedef HRESULT		(*ISD_GETSESSIONSTATS)		(HSTATSESSION, LPSTAT, WORD);

typedef struct _ISDMAPI
{
	ISD_REGISTER_SESSION	ISD_RegisterSession;
	ISD_CREATESTAT			ISD_CreateStat;
	ISD_UNREGISTERSESSION	ISD_UnregisterSession;
	ISD_DELETESTAT			ISD_DeleteStat;
	ISD_UPDATESTAT			ISD_UpdateStat;
	ISD_GETFIRSTSESSION		ISD_GetFirstSession;
	ISD_GETNEXTSESSION		ISD_GetNextSession;
	ISD_GETNUMSESSIONS		ISD_GetNumSessions;
	ISD_GETFIRSTSTAT		ISD_GetFirstStat;
	ISD_GETNEXTSTAT			ISD_GetNextStat;
	ISD_GETNUMSTATS			ISD_GetNumStats;
	ISD_GETSESSIONSTATS		ISD_GetSessionStats;
}
ISDMAPI, *LPISDMAPI;

//HRESULT error defines
#define ISDM_ERROR_BASE             ERROR_LOCAL_BASE_ID

#define ERROR_HIT_MAX_SESSIONS      ISDM_ERROR_BASE + 1
#define ERROR_HIT_MAX_STATS         ISDM_ERROR_BASE + 2
#define ERROR_ACCESSING_SESSION     ISDM_ERROR_BASE + 3
#define ERROR_SESSION_EXISTS        ISDM_ERROR_BASE + 4
#define ERROR_INVALID_SESS_HANDLE   ISDM_ERROR_BASE + 5
#define ERROR_INVALID_STAT_HANDLE   ISDM_ERROR_BASE + 6
#define ERROR_NO_SESSIONS           ISDM_ERROR_BASE + 7
#define ERROR_NO_STATS              ISDM_ERROR_BASE + 8
#define ERROR_SESSION_NOT_FOUND     ISDM_ERROR_BASE + 9
#define ERROR_MUTEX_WAIT_FAIL       ISDM_ERROR_BASE + 10
#define ERROR_TOKEN_NOT_UNIQUE      ISDM_ERROR_BASE + 11
#define ERROR_NO_FREE_SESSIONS      ISDM_ERROR_BASE + 12
#define ERROR_SESSION_GET_FAIL      ISDM_ERROR_BASE + 13
#define ERROR_BAD_STAT_ARRAY        ISDM_ERROR_BASE + 14
#define ERROR_BAD_STAT_TOKEN        ISDM_ERROR_BASE + 15
#define ERROR_BAD_SESSION_NAME      ISDM_ERROR_BASE + 16
#define ERROR_NO_FREE_STATS         ISDM_ERROR_BASE + 17
#define ERROR_BAD_MODULE_NAME       ISDM_ERROR_BASE + 18

//token defines
//RRCM
#define RRCM_LOCAL_STREAM				1
#define RRCM_REMOTE_STREAM				2

#define ISDM_TOKEN_BASE 0x0000

#define ISDM_CC_CODEC					ISDM_TOKEN_BASE + 1
#define ISDM_CC_REMOTE					ISDM_TOKEN_BASE + 2
#define ISDM_CC_LOCAL					ISDM_TOKEN_BASE + 3

#define ISDM_RRCM_BASE 0x1000

#define ISDM_SSRC						ISDM_RRCM_BASE + 1
#define ISDM_NUM_PCKT_SENT				ISDM_RRCM_BASE + 2
#define ISDM_NUM_BYTES_SENT				ISDM_RRCM_BASE + 3
#define ISDM_FRACTION_LOST				ISDM_RRCM_BASE + 4
#define ISDM_CUM_NUM_PCKT_LOST			ISDM_RRCM_BASE + 5
#define ISDM_XTEND_HIGHEST_SEQ_NUM		ISDM_RRCM_BASE + 6
#define ISDM_INTERARRIVAL_JITTER		ISDM_RRCM_BASE + 7
#define ISDM_LAST_SR					ISDM_RRCM_BASE + 8
#define ISDM_DLSR						ISDM_RRCM_BASE + 9
#define ISDM_NUM_BYTES_RCVD				ISDM_RRCM_BASE + 10
#define ISDM_NUM_PCKT_RCVD				ISDM_RRCM_BASE + 11
#define ISDM_NTP_FRAC					ISDM_RRCM_BASE + 12
#define ISDM_NTP_SEC					ISDM_RRCM_BASE + 13
#define ISDM_WHO_AM_I					ISDM_RRCM_BASE + 14
#define ISDM_FDBK_FRACTION_LOST			ISDM_RRCM_BASE + 15
#define ISDM_FDBK_CUM_NUM_PCKT_LOST		ISDM_RRCM_BASE + 16
#define ISDM_FDBK_LAST_SR				ISDM_RRCM_BASE + 17
#define ISDM_FDBK_DLSR					ISDM_RRCM_BASE + 18
#define ISDM_FDBK_INTERARRIVAL_JITTER	ISDM_RRCM_BASE + 19


//
//Supplier calls 
//

//registration call
//This call is made whenever a new session is desired. The session name passed in must be unique
//across all sessions.
extern DllExport HRESULT ISD_RegisterSession
(
	LPMODULENAME		pszModuleName,		// module who owns session
	LPSESSIONNAME		pszSessionName,		// string name of new session to register
	LPSESSIONIDENT		pszSessionIdent,	// further level identifier for session
	LPHSTATSESSION		phSession			// return; handle to new session
);

//stat creation call
//add 1+ stat item(s) to a session. 
extern DllExport HRESULT ISD_CreateStat
(
	HSTATSESSION		hSession,			// handle to session
	LPSTAT				pStatArray,		// array of structs holding new stats to create
	WORD				wNumItems			// size of array(number of new stats)
);

//unregistration call
//deletes a session and all associated stat structs
extern DllExport HRESULT ISD_UnregisterSession
(
	HSTATSESSION		hSession			// handle of session to remove
);

//stat deletion call
//delete 1+ stat item(s) from a session
extern DllExport HRESULT ISD_DeleteStat
(
	HSTATSESSION		hSession,			// handle to session
	LPSTAT				pStatArray,			// array of structs
	WORD				wNumItems			// size of array(number of stats to remove)
);

//set stat data call
extern DllExport HRESULT ISD_UpdateStat
(
	HSTATSESSION		hSession,			// handle of session with stat item(s)
	LPSTAT				pStatArray,			// array of structs holding items to update
	WORD				wNumItems			// size of array(number of stats to update)
);

//
//Consumer calls 
//

//query calls
//session query
extern DllExport HRESULT ISD_GetFirstSession
(
	LPMODULENAME		pszModuleName,		// module who owns session
	LPSESSIONNAME		pszSessionName,		// string name of new session to register
	LPSESSIONIDENT		pszSessionIdent,	// further level identifier for session
	LPHSTATSESSION		phSession			// return; the session handle or null if empty list
);

//GetNext uses hCurSession to determine the next item..returned in phNextSession
extern DllExport HRESULT ISD_GetNextSession
(
	HSTATSESSION		hCurSession,		// the current session handle
	LPMODULENAME		pszModuleName,		// module who owns session
	LPSESSIONNAME		pszSessionName,		// string name of new session to register
	LPSESSIONIDENT		pszSessionIdent,	// further level identifier for session
	LPHSTATSESSION		phNextSession		// return; the session handle or null if at the end
);

extern DllExport HRESULT ISD_GetNumSessions
(
	WORD				*wNumSessions		// return; number of sessions
);

//stat query..retreive structs for the first time(get unique ids..initial values..etc)
extern DllExport HRESULT ISD_GetFirstStat
(
	HSTATSESSION		hSession,			// handle to session containing stat
	LPSTAT				pStat				// return; filled struct for first stat item
);

//pCurrentStat and pNextStat can be identical for saving memory.
extern DllExport HRESULT ISD_GetNextStat
(
	HSTATSESSION		hSession,			// handle to session containing stat
	LPSTAT				pCurrentStat,		// pointer to current stat item(for determining next)
	LPSTAT				pNextStat			// return; filled struct for next stat item
);

extern DllExport HRESULT ISD_GetNumStats
(
	HSTATSESSION		hSession,			// what session we are interested in
	WORD				*wNumStats			// return; number of stats in session
);

//stat retreival 
extern DllExport HRESULT ISD_GetSessionStats
(
	HSTATSESSION		hSession,		// what session we are interested in
	LPSTAT				pStatArray,	// return; array of structs holding items 
	WORD				wNumStats		// return; number of items in session
);

//void			StorePartofStat(LPSTAT pStat,LPCSTR szName,LPBYTE pValue,DWORD dwType);

#ifdef __cplusplus
}						// End of extern "C" {
#endif // __cplusplus

#endif // ISDTAT.H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\h\inodecnt.h ===
#ifndef _INODECNT_H_
#define _INODECNT_H_

typedef void * REQUEST_HANDLE;
typedef REQUEST_HANDLE * PREQUEST_HANDLE;
typedef void * ROSTER_DATA_HANDLE;

typedef struct T120PRODUCTVERSION
{
    DWORD           dwVersion;
    DWORD           dwExpirationDate; // (year<<16)+(month<<8)+day
    DWORD           dwInformation;
    DWORD           dwEarliestPossibleVersion;
    DWORD           dwMaxDifference;
    DWORD           dwReserved;
} T120PRODUCTVERSION, * PT120PRODUCTVERSION;

typedef struct USERDATAINFO
{
    UINT  cbData;
    PVOID pData;
    GUID* pGUID;
} USERDATAINFO, * PUSERDATAINFO;

typedef struct NC_ROSTER_NODE_ENTRY
{
    PWSTR               pwszNodeName;
    UINT                uNodeID;
    UINT                uSuperiorNodeID;
    BOOL                fMCU;
    ROSTER_DATA_HANDLE  hUserData;
} NC_ROSTER_NODE_ENTRY, * PNC_ROSTER_NODE_ENTRY;

typedef struct NC_ROSTER
{
    UINT                    uNumNodes;
    PWSTR                   pwszConferenceName;
    UINT_PTR                uConferenceID;
    UINT                    uLocalNodeID;
    NC_ROSTER_NODE_ENTRY    nodes[1];
} NC_ROSTER, * PNC_ROSTER;



#undef  INTERFACE
#define INTERFACE IDataConference

DECLARE_INTERFACE(IDataConference)
{
    STDMETHOD_(void, ReleaseInterface)( THIS ) PURE;

    STDMETHOD_(UINT_PTR, GetConferenceID) ( THIS ) PURE;

    STDMETHOD(Leave)                  ( THIS ) PURE;

    STDMETHOD(EjectUser)              ( THIS_
                                        UINT                uNodeID) PURE;

    STDMETHOD(Invite)                 ( THIS_
                                        LPCSTR              pcszAddress,
                                        USERDATAINFO        aUserDataInfoEntries[],
                                        UINT                cUserDataEntries,
                                        PREQUEST_HANDLE     phRequest) PURE;

    STDMETHOD(InviteResponse)         ( THIS_
                                        BOOL                fResponse) PURE;

    STDMETHOD(JoinResponse)           ( THIS_
                                        BOOL                fResponse) PURE;

    STDMETHOD(LaunchGuid)             ( THIS_
                                        const GUID*         pcGUID,
                                        UINT                auNodeIDs[],
                                        UINT                cNodes) PURE;

    STDMETHOD(SetUserData)(             THIS_
                                        const GUID*         pcGUID,
                                        UINT                cbData,
                                        LPVOID              pvData) PURE;
    STDMETHOD_(BOOL, IsSecure) ( THIS_) PURE;

    STDMETHOD(UpdateUserData)         ( THIS ) PURE;

    STDMETHOD(GetLocalAddressList)    ( THIS_
                                        LPWSTR              pwszBuffer,
                                        UINT                cchBuffer) PURE;
    STDMETHOD(CancelInvite)           ( THIS_
                                        REQUEST_HANDLE      hRequest) PURE;
    STDMETHOD(SetSecurity)              ( THIS_
                                          BOOL                fSecure) PURE;

    STDMETHOD(GetCred)                ( THIS_
                                        PBYTE*              ppbCred,
                                        DWORD*              pcbCred) PURE;

    STDMETHOD_(UINT, GetParentNodeID) ( THIS ) PURE;
};

typedef IDataConference * CONF_HANDLE;
typedef CONF_HANDLE     * PCONF_HANDLE;



#undef  INTERFACE
#define INTERFACE INodeControllerEvents

DECLARE_INTERFACE(INodeControllerEvents)
{
    STDMETHOD(OnConferenceStarted)(     THIS_
                                        CONF_HANDLE         hConference,
                                        HRESULT             hResult) PURE;
    STDMETHOD(OnConferenceEnded)(       THIS_
                                        CONF_HANDLE         hConference) PURE;
    STDMETHOD(OnRosterChanged)(         THIS_
                                        CONF_HANDLE         hConference,
                                        PNC_ROSTER          pRoster) PURE;
    STDMETHOD(OnIncomingInviteRequest)( THIS_
                                        CONF_HANDLE         hConference,
                                        PCWSTR              pcwszNodeName,
                                        PT120PRODUCTVERSION pRequestorVersion,
                                        PUSERDATAINFO       pUserDataInfoEntries,
                                        UINT                cUserDataEntries,
                                        BOOL                fSecure) PURE;
    STDMETHOD(OnIncomingJoinRequest)(   THIS_
                                        CONF_HANDLE         hConference,
                                        PCWSTR              pcwszNodeName,
                                        PT120PRODUCTVERSION pRequestorVersion,
                                        PUSERDATAINFO       pUserDataInfoEntries,
                                        UINT                cUserDataEntries) PURE;
    STDMETHOD(OnQueryRemoteResult)(     THIS_
                                        PVOID               pvCallerContext,
                                        HRESULT             hResult,
                                        BOOL                fMCU,
                                        PWSTR*              ppwszConferenceNames,
                                        PT120PRODUCTVERSION pVersion,
                                        PWSTR*              ppwszConfDescriptors) PURE;
    STDMETHOD(OnInviteResult)(          THIS_
                                        CONF_HANDLE         hConference,
                                        REQUEST_HANDLE      hRequest,
                                        UINT                uNodeID,
                                        HRESULT             hResult,
                                        PT120PRODUCTVERSION pVersion) PURE;
    STDMETHOD(OnUpdateUserData)(        THIS_
                                        CONF_HANDLE         hConference) PURE;
};



#undef  INTERFACE
#define INTERFACE INodeController

DECLARE_INTERFACE(INodeController)
{
    STDMETHOD_(void, ReleaseInterface)( THIS_) PURE;

    STDMETHOD(CheckVersion)(            THIS_
                                        PT120PRODUCTVERSION pRemoteVersion) PURE;

    STDMETHOD(QueryRemote)(             THIS_
                                        LPVOID              pCallerContext,
                                        LPCSTR              pcszAddress,
                                        BOOL                fSecure,
                                        BOOL                fIsConferenceActive) PURE;

    STDMETHOD(CancelQueryRemote)(       THIS_
                                        LPVOID              pCallerContext) PURE;

    STDMETHOD(CreateConference)(        THIS_
                                        LPCWSTR             pcwszConferenceName,
                                        LPCWSTR             pcwszPassword,
                                        PBYTE               pbHashedPassword,
                                        DWORD               cbHashedPassword,
                                        BOOL                fSecure,
                                        PCONF_HANDLE        phConference) PURE;

    STDMETHOD(JoinConference)(          THIS_
                                        LPCWSTR             pcwszConferenceName,
                                        LPCWSTR             pcwszPassword,
                                        LPCSTR              pcszAddress,
                                        BOOL                fSecure,
                                        PUSERDATAINFO       pUserDataInfoEntries,
                                        UINT                cUserDataEntries,
                                        PCONF_HANDLE        phConference) PURE;

    STDMETHOD(GetUserData)(             THIS_
                                        ROSTER_DATA_HANDLE  hUserData,
                                        const GUID*         pcGUID,
                                        PUINT               pcbData,
                                        LPVOID*             ppvData) PURE;
    STDMETHOD_(UINT, GetPluggableConnID) (THIS_
                                         LPCSTR pcszNodeAddress) PURE;
};


HRESULT WINAPI T120_CreateNodeController(INodeController **, INodeControllerEvents *);
BOOL WINAPI T120_GetSecurityInfoFromGCCID(DWORD dwGCCID, PBYTE pInfo, PDWORD pcbInfo);
DWORD WINAPI T120_TprtSecCtrl(DWORD dwCode, DWORD_PTR dwParam1, DWORD_PTR dwParam2);

//
// Return codes
//

#define NC_ERR_FAC 0xfe00
#define NC_E(e)    (0x81000000UL | NC_ERR_FAC | (ULONG) (e))

enum UI_RC_ERRORS
{
    UI_RC_ALREADY_IN_CONFERENCE =                NC_E(0x01),
    UI_RC_CONFERENCE_ALREADY_EXISTS,
    UI_RC_INVALID_PASSWORD,
    UI_RC_NO_CONFERENCE_NAME,
    UI_RC_T120_FAILURE,
    UI_RC_UNKNOWN_CONFERENCE,
    UI_RC_BAD_TRANSPORT_NAME,
    UI_RC_USER_REJECTED,

    LAST_RC_GCC_MAPPED_ERROR = UI_RC_USER_REJECTED,

    UI_RC_T120_ALREADY_INITIALIZED,
    UI_RC_BAD_ADDRESS,
    UI_RC_NO_ADDRESS,
    UI_RC_NO_SUCH_CONFERENCE,
    UI_RC_CONFERENCE_CREATE_FAILED,
    UI_RC_BAD_PARAMETER,
    UI_RC_OUT_OF_MEMORY,
    UI_RC_CALL_GOING_DOWN,
    UI_RC_CALL_FAILED,
    UI_NO_SUCH_CONFERENCE,
    UI_RC_CONFERENCE_GOING_DOWN,
    UI_RC_INVALID_REQUEST,
    UI_RC_USER_DISCONNECTED,
    UI_RC_EXITING_CORE_UI,
    UI_RC_NO_NODE_NAME,
    UI_RC_INVALID_TRANSPORT_SETTINGS,
    UI_RC_REGISTER_CPI_FAILURE,
    UI_RC_CMP_FAILURE,
    UI_RC_TRANSPORT_DISABLED,
    UI_RC_TRANSPORT_FAILED,
    UI_RC_NOT_SUPPORTED,
    UI_RC_NOT_SUPPORTED_IN_BACKLEVEL,
    UI_RC_CONFERENCE_NOT_READY,
    UI_RC_NO_SUCH_USER_DATA,
    UI_RC_INTERNAL_ERROR,
    UI_RC_VERSION_REMOTE_INCOMPATIBLE,
    UI_RC_VERSION_LOCAL_INCOMPATIBLE,
    UI_RC_VERSION_REMOTE_EXPIRED,
    UI_RC_VERSION_LOCAL_UPGRADE_RECOMMENDED,
    UI_RC_VERSION_REMOTE_UPGRADE_RECOMMENDED,
    UI_RC_VERSION_REMOTE_OLDER,
    UI_RC_VERSION_REMOTE_NEWER,
    UI_RC_BACKLEVEL_LOADED,
    UI_RC_NULL_MODEM_CONNECTION,
    UI_RC_CANCELED,
    UI_RC_T120_REMOTE_NO_SECURITY,
    UI_RC_T120_REMOTE_DOWNLEVEL_SECURITY,
    UI_RC_T120_REMOTE_REQUIRE_SECURITY,
    UI_RC_T120_SECURITY_FAILED,
	UI_RC_T120_AUTHENTICATION_FAILED,
    UI_RC_NO_WINSOCK,

    //
    // Internal return codes
    //
    UI_RC_START_PRIMARY =                  NC_E(0x81),
    UI_RC_START_ALTERNATE =                NC_E(0x82)
};

#endif // _INODECNT_H_


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\h\ividrdr.h ===
//  IVIDRDR.H
//
//      IVideoRender interface.
//
//      Used by videoconferencing UI to drive frame viewing.
//
//  Created 12-Oct-96 [JonT]

#ifndef _IVIDEORENDER_H
#define _IVIDEORENDER_H

#include <pshpack8.h> /* Assume 8 byte packing throughout */

#define FRAME_RECEIVE   1
#define FRAME_SEND      2       // Preview frame

typedef struct _FRAMECONTEXT
{
    LPBITMAPINFO lpbmi;
    void* lpData;
    DWORD_PTR dwReserved;
	LPRECT lpClipRect;
} FRAMECONTEXT, *LPFRAMECONTEXT;


typedef void (CALLBACK *LPFNFRAMEREADY) (DWORD_PTR);

DECLARE_INTERFACE_(IVideoRender, IUnknown)
{
	// *** IUnknown methods ***
	STDMETHOD(QueryInterface) (THIS_ REFIID riid,LPVOID FAR* ppvObj) PURE;
	STDMETHOD_(ULONG,AddRef) (THIS) PURE;
	STDMETHOD_(ULONG,Release) (THIS) PURE;
	
	// IVideoRender methods
	STDMETHOD (Init)(THIS_ DWORD_PTR dwUser, LPFNFRAMEREADY pfCallback) PURE;
	STDMETHOD (Done)(THIS) PURE;
	STDMETHOD (GetFrame)(THIS_ FRAMECONTEXT* pfc) PURE;
	STDMETHOD (ReleaseFrame)(THIS_ FRAMECONTEXT *pfc) PURE;

};
#if(0)
// This is  no longer used anywhere
// outside of NAC.DLL, and is almost obsolete
//DECLARE_INTERFACE_(IMediaProp, IUnknown)
DECLARE_INTERFACE_(IVideoRenderOld, IUnknown)
{

	// *** IUnknown methods ***
	STDMETHOD(QueryInterface) (THIS_ REFIID riid,LPVOID FAR* ppvObj) PURE;
	STDMETHOD_(ULONG,AddRef) (THIS) PURE;
	STDMETHOD_(ULONG,Release) (THIS) PURE;

    STDMETHOD(Init)(THIS_ DWORD dwFlags, HANDLE hEvent) PURE;
    STDMETHOD(Done)(THIS_ DWORD dwFlags) PURE;
    STDMETHOD(GetFrame)(THIS_ DWORD dwFlags, FRAMECONTEXT* pFrameContext) PURE;
    STDMETHOD(ReleaseFrame)(THIS_ DWORD dwFlags, FRAMECONTEXT* pFrameContext) PURE;
};

typedef IVideoRenderOld *LPIVideoRender;
#endif

#include <poppack.h> /* End byte packing */

#endif //_IVIDEORENDER_H

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\h\isdmapi2.h ===
#ifndef __ISDMAPI2_H__
#define __ISDMAPI2_H__

/****************************************************************************
 *
 *	$Archive:   S:/STURGEON/SRC/INCLUDE/VCS/isdmapi2.h_v  $
 *
 *  INTEL Corporation Prorietary Information
 *
 *  This listing is supplied under the terms of a license agreement
 *  with INTEL Corporation and may not be copied nor disclosed except
 *  in accordance with the terms of that agreement.
 *
 *	Copyright (c) 1993-1994 Intel Corporation.
 *
 *	$Revision:   1.10  $
 *	$Date:   08 Oct 1996 17:29:42  $
 *	$Author:   MANDREWS  $
 *
 *	Deliverable:
 *
 *	Abstract:
 *
 *	Notes:
 *
 ***************************************************************************/

#ifdef __cplusplus
extern "C" {				// Assume C declarations for C++.
#endif // __cplusplus

#ifndef DllExport
#define DllExport	__declspec( dllexport )
#endif	// DllExport


//reserved key define for backwards compatability with old API
//all ISDM1 data falls under this key
#define BACKCOMP_KEY	"BackCompatability"
//value type defines
#define DWORD_VALUE			2
#define STRING_VALUE		3
#define BINARY_VALUE		4

//handle prefix bit codes(these get appended to the actual memmap offset to generate a handle)
#define	KEYBITCODE		0x6900
#define VALUEBITCODE	0xAB00
#define ROOTBITCODE		0x1234

//in case we want multiple roots, this can expand
#define ROOT_MAIN	0x0000

//this is the main root keys handle define
#define MAIN_ROOT_KEY MAKELONG(ROOT_MAIN,ROOTBITCODE)

//typedefs for each kind of handle
typedef DWORD KEY_HANDLE,*LPKEY_HANDLE;
typedef DWORD VALUE_HANDLE,*LPVALUE_HANDLE;
typedef DWORD EVENT_HANDLE,*LPEVENT_HANDLE;

//this structure is an internal status structure
//my test app accesses this for debug. You should never need this.
typedef struct INFODATASTRUCT
{
	UINT			uBindCount;
	UINT			uNumKeys;
	UINT			uMaxKeys;
	UINT			uNumValues;
	UINT			uMaxValues;
	UINT			uNumTableEntries;
	UINT			uMaxTableEntries;
	UINT			uNumEvents;
	UINT			uMaxEvents;
	DWORD			dwBytesFree;
	DWORD			dwMaxChars;
} INFO_DATA, *LPINFO_DATA;

//function typedefs
//supplier
typedef HRESULT (*ISD_CREATEKEY)		(KEY_HANDLE, LPCSTR, LPKEY_HANDLE);
typedef HRESULT (*ISD_CREATEVALUE)		(KEY_HANDLE, LPCSTR, DWORD,CONST BYTE *,DWORD,LPVALUE_HANDLE);
typedef HRESULT (*ISD_SETVALUE)			(KEY_HANDLE, VALUE_HANDLE, LPCSTR, DWORD, CONST BYTE *, DWORD);
//consumer
typedef HRESULT (*ISD_OPENKEY)			(KEY_HANDLE, LPCSTR, LPKEY_HANDLE);
typedef HRESULT (*ISD_OPENVALUE)		(KEY_HANDLE, LPCSTR, LPVALUE_HANDLE);
typedef HRESULT (*ISD_ENUMKEY)			(KEY_HANDLE, DWORD, LPSTR, LPDWORD, LPKEY_HANDLE);
typedef HRESULT (*ISD_ENUMVALUE)		(KEY_HANDLE, DWORD, LPDWORD, LPDWORD, LPBYTE, LPDWORD, LPDWORD, LPVALUE_HANDLE);
typedef HRESULT (*ISD_QUERYINFOKEY)		(KEY_HANDLE, LPSTR, LPDWORD, LPDWORD, LPDWORD);
typedef HRESULT (*ISD_QUERYINFOVALUE)	(VALUE_HANDLE, LPSTR, LPDWORD, LPDWORD, LPBYTE, LPDWORD, LPDWORD, LPKEY_HANDLE);
typedef HRESULT (*ISD_NOTIFYCHANGEVALUE)	(VALUE_HANDLE, HANDLE);
//used by either
typedef HRESULT (*ISD_DELETEKEY)		(KEY_HANDLE);
typedef HRESULT	(*ISD_DELETEVALUE)		(KEY_HANDLE, VALUE_HANDLE, LPCSTR);
typedef BOOL	(*ISD_GETSTRUCTDATA)	(LPINFO_DATA);
typedef BOOL	(*ISD_ISVALIDKEYHANDLE)	(KEY_HANDLE);
typedef BOOL	(*ISD_ISVALIDVALUEHANDLE)	(VALUE_HANDLE);
typedef HRESULT (*ISD_COMPACTMEMORY)	();

//structure for ISDM entry points
typedef struct _ISDM2API
{
	ISD_CREATEKEY			ISD_CreateKey;
	ISD_CREATEVALUE			ISD_CreateValue;
	ISD_SETVALUE			ISD_SetValue;
	ISD_OPENKEY				ISD_OpenKey;
	ISD_OPENVALUE			ISD_OpenValue;
	ISD_ENUMKEY				ISD_EnumKey;
	ISD_ENUMVALUE			ISD_EnumValue;
	ISD_QUERYINFOKEY		ISD_QueryInfoKey;
	ISD_QUERYINFOVALUE		ISD_QueryInfoValue;
	ISD_NOTIFYCHANGEVALUE	ISD_NotifyChangeValue;
	ISD_DELETEKEY			ISD_DeleteKey;
	ISD_DELETEVALUE			ISD_DeleteValue;
	ISD_GETSTRUCTDATA		ISD_GetStructData;
	ISD_ISVALIDKEYHANDLE	ISD_IsValidKeyHandle;
	ISD_ISVALIDVALUEHANDLE	ISD_IsValidValueHandle;
	ISD_COMPACTMEMORY		ISD_CompactMemory;
}
ISDM2API, *LPISDM2API;

//HRESULT error defines
#define ISDM_ERROR_BASEB 0x8000

#define ERROR_INVALID_KEY_HANDLE		ISDM_ERROR_BASEB + 1
#define ERROR_MORE_DATA_AVAILABLE		ISDM_ERROR_BASEB + 2
#define ERROR_INVALID_STRING_POINTER	ISDM_ERROR_BASEB + 3
#define ERROR_KEY_NOT_FOUND				ISDM_ERROR_BASEB + 4
#define ERROR_VALUE_NOT_FOUND			ISDM_ERROR_BASEB + 5
#define ERROR_NO_MORE_SESSIONS			ISDM_ERROR_BASEB + 6
#define ERROR_INVALID_VALUE_HANDLE		ISDM_ERROR_BASEB + 7
#define ERROR_FAILED_TO_GET_MEM_KEY		ISDM_ERROR_BASEB + 8
#define ERROR_NO_PARENT					ISDM_ERROR_BASEB + 9
#define ERROR_NO_PREV_SIBLING			ISDM_ERROR_BASEB + 10
#define ERROR_NO_NEXT_SIBLING			ISDM_ERROR_BASEB + 11
#define ERROR_NO_CHILD					ISDM_ERROR_BASEB + 12
#define ERROR_INVALID_VALUE_TYPE		ISDM_ERROR_BASEB + 13
#define ERROR_MALLOC_FAILURE			ISDM_ERROR_BASEB + 14
#define ERROR_CREATE_KEY_FAILURE		ISDM_ERROR_BASEB + 15
#define ERROR_NULL_PARAM				ISDM_ERROR_BASEB + 16
#define ERROR_VALUE_EXISTS				ISDM_ERROR_BASEB + 17
#define ERROR_FAILED_TO_GET_MEM_VALUE	ISDM_ERROR_BASEB + 18
#define ERROR_NO_MORE_STR_SPACE			ISDM_ERROR_BASEB + 19
#define ERROR_KEY_EXISTS				ISDM_ERROR_BASEB + 20
#define ERROR_NO_MORE_KEY_SPACE			ISDM_ERROR_BASEB + 21
#define ERROR_NO_MORE_VALUE_SPACE		ISDM_ERROR_BASEB + 22
#define ERROR_INVALID_PARAM				ISDM_ERROR_BASEB + 23
#define ERROR_ROOT_DELETE				ISDM_ERROR_BASEB + 24
#define ERROR_NULL_STRING_TABLE_ENTRY	ISDM_ERROR_BASEB + 25
#define ERROR_NO_MORE_TABLE_ENTRIES		ISDM_ERROR_BASEB + 26
#define ERROR_ISDM_UNKNOWN				ISDM_ERROR_BASEB + 27
#define ERROR_NOT_IMPLEMENTED			ISDM_ERROR_BASEB + 28
#define ERROR_MALLOC_FAILED				ISDM_ERROR_BASEB + 29
#define ERROR_FAILED_TO_GET_MEM_TABLE	ISDM_ERROR_BASEB + 30
#define ERROR_SEMAPHORE_WAIT_FAIL		ISDM_ERROR_BASEB + 31
#define ERROR_NO_MORE_EVENTS			ISDM_ERROR_BASEB + 32
#define ERROR_INVALID_EVENT				ISDM_ERROR_BASEB + 33
#define ERROR_INVALID_EVENT_HANDLE		ISDM_ERROR_BASEB + 34
#define ERROR_EVENT_NONEXISTANT			ISDM_ERROR_BASEB + 35
#define ERROR_VALUE_DOES_NOT_EXIST		ISDM_ERROR_BASEB + 36
#define ERROR_BUFFER_TOO_SMALL			ISDM_ERROR_BASEB + 37

//token defines..these may just disappear
//RRCM
#define RRCM_LOCAL_STREAM				1
#define RRCM_REMOTE_STREAM				2
#define ISDM_RRCM_BASE 0x1000

#define ISDM_SSRC						ISDM_RRCM_BASE + 1
#define ISDM_NUM_PCKT_SENT				ISDM_RRCM_BASE + 2
#define ISDM_NUM_BYTES_SENT				ISDM_RRCM_BASE + 3
#define ISDM_FRACTION_LOST				ISDM_RRCM_BASE + 4
#define ISDM_CUM_NUM_PCKT_LOST			ISDM_RRCM_BASE + 5
#define ISDM_XTEND_HIGHEST_SEQ_NUM		ISDM_RRCM_BASE + 6
#define ISDM_INTERARRIVAL_JITTER		ISDM_RRCM_BASE + 7
#define ISDM_LAST_SR					ISDM_RRCM_BASE + 8
#define ISDM_DLSR						ISDM_RRCM_BASE + 9
#define ISDM_NUM_BYTES_RCVD				ISDM_RRCM_BASE + 10
#define ISDM_NUM_PCKT_RCVD				ISDM_RRCM_BASE + 11
#define ISDM_NTP_FRAC					ISDM_RRCM_BASE + 12
#define ISDM_NTP_SEC					ISDM_RRCM_BASE + 13
#define ISDM_WHO_AM_I					ISDM_RRCM_BASE + 14

//
//Supplier API
//

//NOTE: always refer to the Win32 Registry equivalent call for more information on the functionality of the call
 
//The create key call is similar to the RegCreateKeyEx call from Win32 in functionality
//NOTE: This call will create the new key or simply return the handle of the key if it already
//exists
extern DllExport HRESULT ISD_CreateKey
(
	KEY_HANDLE hParentKey,	//The key from which to create the new key(can be MAIN_ROOT_KEY)
	LPCSTR lpSubKey,		//the subkey to create.(see RegCreateKeyEx for details)
	LPKEY_HANDLE lphReturnKey//the handle of the newly created key
);

//The create value call is not part of the Win32 reg calls. It is here for symmetry in my API
//I prefer to use CreateValue then SetValue for my values, you can simply use SetValue and ignore
//CreateValue if you wish. The reason the registry has no such call is because they don't have
//a notion of a handle to a value. I felt it was very useful to have direct handles to the values for
//subsequent supplier or consumer calls.
//NOTE: If the type is STRING, you need to include the null terminator for the string in the size(cbData).
extern DllExport HRESULT ISD_CreateValue
(
	KEY_HANDLE hKey,				//handle to the key that will own the new value
	LPCSTR lpName,					//string ID of the value to be create
	DWORD dwType,					//type of value to create(DWORD,STRING,BINARY)
	CONST BYTE *lpData,				//pointer to value data	
	DWORD cbData,					//size of the value data buffer
	LPVALUE_HANDLE lphReturnValue	//return handle to the newly created value
);

//SetValue is similar to the Win32 RegSetValueEx call
//Note: If you have the value handle, you don't need to pass the key handle or lpName
//NOTE: If the type is STRING, you need to include the null terminator for the string in the size(cbData).
DllExport HRESULT ISD_SetValue
(
	KEY_HANDLE hKey,		//handle of valid key(can be NULL if hValue is known)
	VALUE_HANDLE hValue,	//handle of value to set(can be NULL)
	LPCSTR lpName,			//address of value name of value to set(can be NULL if hkey is null)
	DWORD dwType,			//flag for value type 
	CONST BYTE *lpData,		//address of value data 
	DWORD cbData 			//size of value data 
);

//
//Consumer API
//

//The OpenKey call is similar to the Win32 RegOpenKeyEx call
DllExport HRESULT ISD_OpenKey
(
	KEY_HANDLE hKey,				//handle of a valid key(can be MAIN_ROOT_KEY)
	LPCSTR lpSubKey,				//name of subkey to open
	LPKEY_HANDLE lphReturnKey		//handle of the opened key
);

//The OpenValue call is new to ISDM because the registry doesn't have a concept of value handles
DllExport HRESULT ISD_OpenValue
(
	KEY_HANDLE hKey,				//handle of a valid key(can NOT be MAIN_ROOT_KEY)
	LPCSTR lpValueName,				//Name of value to open
	LPVALUE_HANDLE lphReturnValue	//handle of the opened value
);


//The EnumKey call is similar to the Win32 RegEnumKey call
//NOTES:
//	If lpName is null the size of the name is returned into lpcbName and NOERROR is returned
DllExport HRESULT ISD_EnumKey
(
	KEY_HANDLE hKey,				//key to enumerate
	DWORD dwIndex,					//index of subkey to enumerate
	LPSTR lpName,					//address of buffer for subkey name(can be NULL)
	LPDWORD lpcbName,				//address for size of subkey buffer (acts like the RegEnumKeyEx version of this param)
	LPKEY_HANDLE lphReturnKey		//handle of subkey(can be NULL) 
);

//The EnumValue call is similar to the Win32 RegEnumValue call
DllExport HRESULT ISD_EnumValue
(
	KEY_HANDLE hKey,				//handle of key where value resides
	DWORD dwIndex,					//index of value to enum
	LPSTR lpName,					//address of buffer for value name(can be NULL)
	LPDWORD lpcbName,				//address for size of value name buffer(can be NULL only if lpName is NULL)
	LPDWORD lpType,					//address for type of value(can be NULL if you don't care about type)
	LPBYTE lpData,					//address of buffer to receive the value data(can be NULL)
	LPDWORD lpcbData,				//address of size of buffer to receive the value data(can be NULL only if lpData is NULL)
	LPDWORD lpTimeStamp,			//address for timestamp on value(when last updated)(can be NULL)
	LPVALUE_HANDLE lphReturnValue	//address for handle of value(can be NULL)
);

//The QueryKeyInfo call is similar to the RegQueryInfoKey
DllExport HRESULT ISD_QueryInfoKey
(
	KEY_HANDLE hKey,				//handle of a valid key(can be MAIN_ROOT_KEY)
	LPSTR lpKeyName,			    //buffer to receive the name of the key(can be NULL)
	LPDWORD lpcbKeyName,			//address of size of name buffer(can be null only if lpKeyName is NULL)
	LPDWORD lpcNumKeys,				//address for number of direct children of the key(can be NULL)
	LPDWORD lpcNumValues			//address for number of values under the key(can be NULL)
);

//The QueryValueInfo call is NOT similar to the Win32 RegQueryValueEx call
//you must supply a value handle, the Win32 call doesn't have a notion of such a thing
//You can get the handle with subsequent calls to EnumKey
//This is my consumer call to retrieve statistical data
//NOTES:
//		If lpData is NULL and lpcbData is not, the function will return NOERROR with
//		lpcbData containing the buffer size needed for the value
//		If lpName is NULL and lpcbName is not, the function will return NOERROR with
//		lpcbName containing the buffer size needed for the value
DllExport HRESULT ISD_QueryInfoValue
(
	VALUE_HANDLE hValue,		//handle of value to query 
	LPSTR lpName,				//buffer to receive the name of the value(can be NULL)
	LPDWORD lpcbName,			//size of the name buffer(can only be NULL if lpName is NULL)
	LPDWORD lpValueType,		//address to receive the value type
	LPBYTE lpData,				//buffer to receive the value data(can be NULL)
	LPDWORD lpcbData,			//size of the value data buffer(can only be NULL if lpData is NULL)
	LPDWORD lpTime,				//address for timestamp on value(when last updated)(can be NULL)
	LPKEY_HANDLE lphParentKey	//return handle of the key that owns the value(can be NULL) 
);

//NotifyChangeValue is somewhat similar to the Win32 RegNotifyChangeValue call
//I limit you to async notification and also to value notification(no key level notify..yet)
DllExport HRESULT ISD_NotifyChangeValue
(
	VALUE_HANDLE hValue,	//handle of the value to trigger an event from
	HANDLE hEvent			//handle to the event you want triggered when value changes
);

//
//shared API
//

//The DeleteKey call is similar to RegDeleteKey
DllExport HRESULT ISD_DeleteKey
(
	KEY_HANDLE hKey					//handle of key to delete
);

//The DeleteValue call is similar to the RegDeleteValue call
//NOTE: You must supply either hValue or lpValueName. If you have the hValue, use it 
//and pass NULL for the value name.
DllExport HRESULT ISD_DeleteValue
(
	KEY_HANDLE hKey,				//handle of key that owns the value..if you have the value handle..pass NULL
	VALUE_HANDLE hValue,			//handle of value to delete(if known)..if known..pass NULL for key handle and name value
	LPCSTR lpValueName				//buffer holding name of value to delete(if known) pass NULL when hValue is known
);

//The GetStructData call is for retrieving structural info on ISDM itself. This is exposed so
//my test app can check the data structs. You should not need to call this.
DllExport BOOL ISD_GetStructData
(
	LPINFO_DATA pInfo				//structure holding ISDM structural info
);

//
//Handle validation calls
//
//use these anytime you want to check the validity of a handle to an ISDM object
DllExport BOOL ISD_IsValidKeyHandle
(
	KEY_HANDLE		hKey	//handle to key
);

DllExport BOOL ISD_IsValidValueHandle
(
	VALUE_HANDLE	hValue	//handle to value
);

//CompactMemory is my garbage collection function for ISDM. It is exported for
//test purposes with my browser app. You don't ever need to call this.
DllExport HRESULT ISD_CompactMemory
(
);

#ifdef __cplusplus
}						// End of extern "C" {
#endif // __cplusplus

#endif // __ISDMAPI2_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\h\isrg.h ===
/****************************************************************************

	INTEL CORPORATION PROPRIETARY INFORMATION
	Copyright (c) 1992 Intel Corporation
	All Rights Reserved

	This software is supplied under the terms of a license
	agreement or non-disclosure agreement with Intel Corporation
	and may not be copied or disclosed except in accordance
	with the terms of that agreement

    $Source: q:/prism/include/rcs/isrg.h $
  $Revision:   1.4  $
      $Date:   01 Oct 1996 11:14:54  $
    $Author:   EHOWARDX  $
    $Locker:  $

	Description
	-----------
	Interrupt Service Routine debug header file
	This module allows for a way of doing OutputDebugString()
	at interrupt time.

****************************************************************************/

#ifndef ISRG_H
#define ISRG_H

#ifdef __cplusplus
extern "C" {				// Assume C declarations for C++.
#endif // __cplusplus

// Use for Win16
//#define DllExport
//#define DllImport
//#define DLL_EXPORT	_export

// Use for Win32
#define DllExport		__declspec( dllexport )
#define DllImport		__declspec( dllimport )
#define DLL_EXPORT

#if defined(ISRDBG32_C)
#define ISR_DLL      DllExport
#else
#define ISR_DLL      DllImport
#endif

//
//	directions
//		Pick a number (mod 100) and create a base for the next
//		100 entries.  Do it this way so that your numbers can
//		be easily moved.  The string assigned to the base you select
//		will be displayed as the filter string in a list box when
//		viewing.  After defining your constants go to isrdsp.rc
//		and assign strings to them.  You will need to build the
//		isrdsp.exe but not the isrdbg.dll.  You only need to
//		inlude this h file and import the functions from this
//		file into your def file.  Happy debugging.


//------------------------------------------------------------------------------
#define kModSNameSize		16
#define kModLNameSize		32

//------------------------------------------------------------------------------
// defines for tISRModule.Flags
#define kCaptureOn			0x01

//------------------------------------------------------------------------------
typedef struct _tISRModule
{
	WORD	Flags;
	BYTE	CaptureFilter;
	BYTE	DisplayFilter;
	char	zSName[kModSNameSize];	// Short name of user registered debug module
	char	zLName[kModLNameSize];	// Long name of user registered debug module
} tISRModule, FAR *ptISRModule;

//------------------------------------------------------------------------------
#define kModuleBufSize		((DWORD) (16*1024L))
#define kMaxModules			((UINT) (kModuleBufSize/sizeof(tISRModule)))


//------------------------------------------------------------------------------
typedef struct _tISRItem
{
	WORD	hISRInst;		// Our handle to registered modules
	BYTE	DbgLevel;		// Caller determined debug level
	BYTE	Flags;
	UINT	IP;				// Callers Instruction Ptr address
	DWORD_PTR Param1;
	DWORD	Param2;
} tISRItem, FAR *ptISRItem;

//------------------------------------------------------------------------------
#define kISRBufSize			((DWORD) (128*1024L))
#define kMaxISRItems		((UINT) (kISRBufSize/sizeof(tISRItem)))
#define kMaxStrTab			((UINT) (256*1024L))


//------------------------------------------------------------------------------
// defines for tISRItem.Flags
#define kParam1IsStr		0x01
#define kParam1IsRes		0x02
#define kParam1IsNum		0x04		// Use only if passed two numbers.


//------------------------------------------------------------------------------
// Supported DbgMsg state values.
//------------------------------------------------------------------------------
#define ISR_DBG 				0
#define ISR_ERR 				1

#define kISRCritical		0x01	// Progammer errors that should never happen
#define kISRError			0x02	// Errors that need to be fixed
#define kISRWarning			0x04	// The user could have problems if not corrected
#define kISRNotify			0x08	// Status, events, settings...
#define kISRTrace			0x10	// Trace info that will not overrun the system
#define kISRTemp			0x20	// Trace info that may be reproduced in heavy loops
#define kISRReserved1		0x40	// Future use
#define kISRReserved2		0x80	// Future use
#define kISRDefault			kISRReserved2	// Historical use only

#define TT_CRITICAL			kISRCritical
#define TT_ERROR			kISRError
#define TT_WARNING			kISRWarning
#define TT_NOTIFY			kISRNotify
#define TT_TRACE			kISRTrace
#define TT_TEMP				kISRTemp


//------------------------------------------------------------------------------
// exports from isrdbg.dll
// Include these in your def file if you want to output at interrupt time.
// The ISR_Hook*() functions are the same as their counterparts.  The only
// difference is that these functions need the Instruction Pointer passed
// in.  If you are using an intermediate library to encapsulate the debug
// functions then you must be responsible for pulling the IP off the stack.

// Register the module and get a handle for making debug calls.  If a debug
// call is made with an invalid handle then the results are not defined.
// It is possible to drop the debug event or to place the event into the
// compatibility module.  If no more module handles are available then
// the handle returned will be the compatibility handle.
ISR_DLL void WINAPI DLL_EXPORT
ISR_RegisterModule (LPWORD phISRInst, LPSTR zShortName, LPSTR zLongName);


// Allow two strings to be concatenated togeter.
ISR_DLL void WINAPI DLL_EXPORT
ISR_HookDbgStrStr (UINT IP, WORD hISRInst, BYTE DbgLevel, LPSTR pzStr1, LPSTR pzStr2);

// Use a resource to format a number.
ISR_DLL void WINAPI DLL_EXPORT
ISR_HookDbgRes (UINT IP, WORD hISRInst, BYTE DbgLevel, UINT uResId, DWORD Param1);

// Use a str to format a number.
ISR_DLL void WINAPI DLL_EXPORT
ISR_HookDbgStr (UINT IP, WORD hISRInst, BYTE DbgLevel, LPSTR pzStr1, DWORD Param1);

// Allow two strings to be concatenated togeter.
ISR_DLL void WINAPI DLL_EXPORT
ISR_DbgStrStr (WORD hISRInst, BYTE DbgLevel, LPSTR pzStr1, LPSTR pzStr2);

// Use a resource to format a number.
ISR_DLL void WINAPI DLL_EXPORT
ISR_DbgRes (WORD hISRInst, BYTE DbgLevel, UINT uResId, DWORD Param1);

// Use a str to format a number.
ISR_DLL void WINAPI DLL_EXPORT
ISR_DbgStr (WORD hISRInst, BYTE DbgLevel, LPSTR pzStr1, DWORD Param1);


// WARNING: Call at task time only.  Not reentrant.
ISR_DLL void FAR cdecl DLL_EXPORT
TTDbgMsg
(
	WORD		hISRInst,	// Module's ISRDBG handle.
	BYTE		DbgLevel,	// Appropriate ISRDBG level.
	LPCSTR		zMsgFmt,	// Output format string (like printf).
	... 					// Optional parameter list.
);


// Old functions for compatibility only.
ISR_DLL void WINAPI DLL_EXPORT
ISR_OutputDbgStr (LPSTR pzStr);

ISR_DLL void WINAPI DLL_EXPORT
ISR_OutputStr (UINT uResId);

ISR_DLL void WINAPI DLL_EXPORT
ISR_OutputNum (UINT uResId, DWORD Num);

// WARNING: Call at task time only.  Not reentrant.
ISR_DLL void FAR cdecl DLL_EXPORT
DbgMsg
	(
	LPCSTR		module,
	int			state,
	LPCSTR		format_str,
	...
	);


//------------------------------------------------------------------------------
// exports from isrdbg.dll
// Include these in your def file if you need to know the state of isrdbg.dll.
// isrdsp.exe needs to do this to display the data at task time.

ISR_DLL void WINAPI DLL_EXPORT
ISR_ClearItems (void);

ISR_DLL UINT WINAPI DLL_EXPORT
ISR_GetNumItems (void);

ISR_DLL UINT WINAPI DLL_EXPORT
ISR_GetNumModules (void);

ISR_DLL ptISRItem WINAPI DLL_EXPORT
ISR_GetItem (UINT uItem,ptISRItem pItem);

ISR_DLL ptISRModule WINAPI DLL_EXPORT
ISR_GetModule (UINT hISRInst);

ISR_DLL int WINAPI DLL_EXPORT
ISR_SetCaptureFilter (WORD hISRInst, BYTE CaptureFilter,  BYTE DisplayFilter);


//------------------------------------------------------------------------------
//	The caller of ISR debug functions can call these Macros and then the
//	retail release will just drop all of the debug statement code.
//------------------------------------------------------------------------------
#if (DEBUG >= 1) || (_DEBUG >= 1)
#define ISRDEBUGINFO	1
extern WORD	ghISRInst;
#define ISRREGISTERMODULE(pghISRInst, ShortName, LongName)	ISR_RegisterModule(pghISRInst, ShortName, LongName)
#define ISRNOTIFY(ghISRInst, Str, Num)		ISR_DbgStr(ghISRInst, kISRNotify, Str, Num)
#define ISRCRITICAL(ghISRInst, Str, Num)	ISR_DbgStr(ghISRInst, kISRCritical, Str, Num)
#define ISRERROR(ghISRInst, Str, Num)		ISR_DbgStr(ghISRInst, kISRError, Str, Num)
#define ISRWARNING(ghISRInst, Str, Num)		ISR_DbgStr(ghISRInst, kISRWarning, Str, Num)
#define ISRTRACE(ghISRInst, Str, Num)		ISR_DbgStr(ghISRInst, kISRTrace, Str, Num)
#define ISRTEMP(ghISRInst, Str, Num)		ISR_DbgStr(ghISRInst, kISRTemp, Str, Num)
#define ISRRESERVED1(ghISRInst, Str, Num)	ISR_DbgStr(ghISRInst, kISRReserved1, Str, Num)
#define ISRRESERVED2(ghISRInst, Str, Num)	ISR_DbgStr(ghISRInst, kISRReserved2, Str, Num)

#define ISRSNOTIFY(ghISRInst, Str, Str2)	ISR_DbgStrStr(ghISRInst, kISRNotify, Str, Str2)
#define ISRSCRITICAL(ghISRInst, Str, Str2)	ISR_DbgStrStr(ghISRInst, kISRCritical, Str, Str2)
#define ISRSERROR(ghISRInst, Str, Str2)		ISR_DbgStrStr(ghISRInst, kISRError, Str, Str2)
#define ISRSWARNING(ghISRInst, Str, Str2)	ISR_DbgStrStr(ghISRInst, kISRWarning, Str, Str2)
#define ISRSTRACE(ghISRInst, Str, Str2)		ISR_DbgStrStr(ghISRInst, kISRTrace, Str, Str2)
#define ISRSTEMP(ghISRInst, Str, Str2)		ISR_DbgStrStr(ghISRInst, kISRTemp, Str, Str2)
#define ISRSRESERVED1(ghISRInst, Str, Str2)	ISR_DbgStrStr(ghISRInst, kISRReserved1, Str, Str2)
#define ISRSRESERVED2(ghISRInst, Str, Str2)	ISR_DbgStrStr(ghISRInst, kISRReserved2, Str, Str2)

#define TTDBG			TTDbgMsg

#else

#define ISRNOTIFY(ghISRInst, Str, Num)
#define ISRREGISTERMODULE(pghISRInst, ShortName, LongName)
#define ISRCRITICAL(ghISRInst, Str, Num)
#define ISRERROR(ghISRInst, Str, Num)
#define ISRWARNING(ghISRInst, Str, Num)
#define ISRTRACE(ghISRInst, Str, Num)
#define ISRTEMP(ghISRInst, Str, Num)
#define ISRRESERVED1(ghISRInst, Str, Num)
#define ISRRESERVED2(ghISRInst, Str, Num)

#define ISRSNOTIFY(ghISRInst, Str, Str2)
#define ISRSCRITICAL(ghISRInst, Str, Str2)
#define ISRSERROR(ghISRInst, Str, Str2)
#define ISRSWARNING(ghISRInst, Str, Str2)
#define ISRSTRACE(ghISRInst, Str, Str2)
#define ISRSTEMP(ghISRInst, Str, Str2)
#define ISRSRESERVED1(ghISRInst, Str, Str2)
#define ISRSRESERVED2(ghISRInst, Str, Str2)

#define ghISRInst		0
#define TTDBG			1 ? (void)0 : TTDbgMsg

#endif


//------------------------------------------------------------------------------
// Local Functions

// Local function but thunk needs to get to it
ISR_DLL void WINAPI
OutputRec
	(
	WORD	hISRInst,		// Our handle to registered modules
	BYTE	DbgLevel,		// Caller determined debug level
	BYTE	Flags,
	UINT	IP,				// Callers Instruction Ptr address
	DWORD	Param1,
	DWORD	Param2
	);

// Local function but thunk needs to get to it
ISR_DLL void WINAPI
OutputRecStr
	(
	WORD	hISRInst,		// Our handle to registered modules
	BYTE	DbgLevel,		// Caller determined debug level
	BYTE	Flags,
	UINT	IP,				// Callers Instruction Ptr address
	LPSTR	pzStr1,
	LPSTR	pzStr2,
	DWORD	Param1
	);


//------------------------------------------------------------------------------
// do not use a base of 0.  Reserved for system use.
#define ID_SysBase			0
#define ID_SysStr			(ID_SysBase + 1)
#define ID_SysSInt			(ID_SysBase + 2)
#define ID_SysUInt			(ID_SysBase + 3)
#define ID_SysDWord			(ID_SysBase + 4)
#define ID_SysLong			(ID_SysBase + 5)
#define ID_SysHex			(ID_SysBase + 6)


//------------------------------------------------------------------------------
// IsrDbg.dll
#define ID_IsrDbgBase		100
#define ID_IsrDbgLibMain	(ID_IsrDbgBase + 1)
#define ID_IsrDbgWep		(ID_IsrDbgBase + 2)
#define ID_IsrDbgReentrant	(ID_IsrDbgBase + 3)


//------------------------------------------------------------------------------
// IsrDsp.exe
#define ID_IsrDspBase		200
#define ID_IsrDspInit		(ID_IsrDspBase + 1)
#define ID_IsrDspExit		(ID_IsrDspBase + 2)


//------------------------------------------------------------------------------
// stMem.dll
#define ID_stMemBase		300
#define ID_stMemLibMain		(ID_stMemBase + 1)
#define ID_stMemWep			(ID_stMemBase + 2)
#define ID_stMemPreAlloc	(ID_stMemBase + 3)
#define ID_stMemPageLock	(ID_stMemBase + 4)
#define ID_stMemNoPageLock	(ID_stMemBase + 5)
#define ID_stMemAlloc		(ID_stMemBase + 6)
#define ID_stMemTotMem		(ID_stMemBase + 7)
#define ID_stMemstFree		(ID_stMemBase + 8)


//-------------------------------------------------------------------------------
// DLM.dll

// Errors
#define ID_DLMErrorBase		400
#define ID_DLMEnqError      (ID_DLMErrorBase + 1)
#define ID_DLMDeqError      (ID_DLMErrorBase + 2)
#define ID_DLMFreeError     (ID_DLMErrorBase + 3)
#define ID_DLMChanError     (ID_DLMErrorBase + 4)
#define ID_DLMChanNIUErr    (ID_DLMErrorBase + 5)
#define ID_DLMChanNumErr    (ID_DLMErrorBase + 6)
#define ID_DLMInConnErr     (ID_DLMErrorBase + 7)
#define ID_DLMInSessErr     (ID_DLMErrorBase + 8)
#define ID_DLMSessNIU       (ID_DLMErrorBase + 9)
#define ID_DLMSessNO        (ID_DLMErrorBase + 10)
#define ID_DLMConnNIU       (ID_DLMErrorBase + 11)
#define ID_DLMConnNO        (ID_DLMErrorBase + 12)
#define ID_DLMIDErr         (ID_DLMErrorBase + 13)
#define ID_DLMConnErr       (ID_DLMErrorBase + 14)
#define ID_DLMSessErr       (ID_DLMErrorBase + 15)
#define ID_DLMSessNF        (ID_DLMErrorBase + 16)
#define ID_DLMNoFreeConn    (ID_DLMErrorBase + 17)
#define ID_DLMConnCloseErr  (ID_DLMErrorBase + 18)
#define ID_DLMConnNF        (ID_DLMErrorBase + 19)
#define ID_DLMConnNC        (ID_DLMErrorBase + 20)
#define ID_DLMMDMError      (ID_DLMErrorBase + 21)
#define ID_DLMNoSess        (ID_DLMErrorBase + 22)
#define ID_DLMInvalidSess   (ID_DLMErrorBase + 23)
#define ID_DLMEventErr      (ID_DLMErrorBase + 24)
#define ID_DLMNoConn        (ID_DLMErrorBase + 25)
#define ID_DLMChanCloseErr  (ID_DLMErrorBase + 26)
#define ID_DLMInvalidConn   (ID_DLMErrorBase + 27)
#define ID_DLMCorruptQueue  (ID_DLMErrorBase + 28)
#define ID_DLMInvChanID     (ID_DLMErrorBase + 29)
#define ID_DLMChanInUse     (ID_DLMErrorBase + 30)
#define ID_DLMInvalidChan   (ID_DLMErrorBase + 31)
#define ID_DLMNoBufHdr      (ID_DLMErrorBase + 32)
#define ID_DLMEnqueueErr    (ID_DLMErrorBase + 33)
#define ID_DLMNMBufInProg   (ID_DLMErrorBase + 34)
#define ID_DLMNoBuffer      (ID_DLMErrorBase + 35)
#define ID_DLMEnterDumping  (ID_DLMErrorBase + 36)
#define ID_DLMSizeError     (ID_DLMErrorBase + 37)
#define ID_DLMNoBuf         (ID_DLMErrorBase + 38)
#define ID_DLMInitAlready   (ID_DLMErrorBase + 39)
#define ID_DLMGDLError      (ID_DLMErrorBase + 40)
#define ID_DLMNoEntryPoint  (ID_DLMErrorBase + 41)
#define ID_DLMNoEvent       (ID_DLMErrorBase + 42)
#define ID_DLMNoPackets     (ID_DLMErrorBase + 43)

// Debug level 1 messages
#define ID_DLMDebug1Base         500
#define ID_DLMCloseAllEntered    (ID_DLMDebug1Base + 1)
#define ID_DLMEstabHEntered      (ID_DLMDebug1Base + 2)
#define ID_DLMEstabHExit         (ID_DLMDebug1Base + 3)
#define ID_DLMReqHEntered        (ID_DLMDebug1Base + 4)
#define ID_DLMReqHAlloc          (ID_DLMDebug1Base + 5)
#define ID_DLMReqHExit           (ID_DLMDebug1Base + 6)
#define ID_DLMRejHEntered        (ID_DLMDebug1Base + 7)
#define ID_DLMRejHExit           (ID_DLMDebug1Base + 8)
#define ID_DLMCNoteHEntered      (ID_DLMDebug1Base + 9)
#define ID_DLMCNoteHExit         (ID_DLMDebug1Base + 10)
#define ID_DLMCComHEntered       (ID_DLMDebug1Base + 11)
#define ID_DLMCComHExit          (ID_DLMDebug1Base + 12)
#define ID_DLMSessCloseHEntered  (ID_DLMDebug1Base + 13)
#define ID_DLMSessCloseHExit     (ID_DLMDebug1Base + 14)
#define ID_DLMSessHEntered       (ID_DLMDebug1Base + 15)
#define ID_DLMSessHExit          (ID_DLMDebug1Base + 16)
#define ID_DLMBegSessEntered     (ID_DLMDebug1Base + 17)
#define ID_DLMBegSessExit        (ID_DLMDebug1Base + 18)
#define ID_DLMEndSessEntered     (ID_DLMDebug1Base + 19)
#define ID_DLMEndSessExit        (ID_DLMDebug1Base + 20)
#define ID_DLMListenEntered      (ID_DLMDebug1Base + 21)
#define ID_DLMListenExit         (ID_DLMDebug1Base + 22)
#define ID_DLMDoCloseEntered     (ID_DLMDebug1Base + 23)
#define ID_DLMDoCloseExit        (ID_DLMDebug1Base + 24)
#define ID_DLMMakeConnEntered    (ID_DLMDebug1Base + 25)
#define ID_DLMMakeConnExit       (ID_DLMDebug1Base + 26)
#define ID_DLMRejEntered         (ID_DLMDebug1Base + 27)
#define ID_DLMRejExit            (ID_DLMDebug1Base + 28)
#define ID_DLMAccEntered         (ID_DLMDebug1Base + 29)
#define ID_DLMAccExit            (ID_DLMDebug1Base + 30)
#define ID_DLMCloseConnEntered   (ID_DLMDebug1Base + 31)
#define ID_DLMCloseConnExit      (ID_DLMDebug1Base + 32)
#define ID_DLMTryEntered         (ID_DLMDebug1Base + 33)
#define ID_DLMTryExit            (ID_DLMDebug1Base + 34)
#define ID_DLMOpenEntered        (ID_DLMDebug1Base + 35)
#define ID_DLMOpenExit           (ID_DLMDebug1Base + 36)
#define ID_DLMSendEntered        (ID_DLMDebug1Base + 37)
#define ID_DLMSendExit           (ID_DLMDebug1Base + 38)
#define ID_DLMSendComEntered     (ID_DLMDebug1Base + 39)
#define ID_DLMSendComExit        (ID_DLMDebug1Base + 40)
#define ID_DLMPostEntered        (ID_DLMDebug1Base + 41)
#define ID_DLMPostExit           (ID_DLMDebug1Base + 42)
#define ID_DLMNewMsgEntered      (ID_DLMDebug1Base + 43)
#define ID_DLMNewMsgExit         (ID_DLMDebug1Base + 44)
#define ID_DLMContMsgEntered     (ID_DLMDebug1Base + 45)
#define ID_DLMContMsgExit        (ID_DLMDebug1Base + 46)
#define ID_DLMRecEntered         (ID_DLMDebug1Base + 47)
#define ID_DLMRecExit            (ID_DLMDebug1Base + 48)
#define ID_DLMCloseEntered       (ID_DLMDebug1Base + 49)
#define ID_DLMCloseExit          (ID_DLMDebug1Base + 50)
#define ID_DLMGetCharEntered     (ID_DLMDebug1Base + 51)
#define ID_DLMGetCharExit        (ID_DLMDebug1Base + 52)
#define ID_DLMInitEntered        (ID_DLMDebug1Base + 53)
#define ID_DLMInitExit           (ID_DLMDebug1Base + 54)
#define ID_DLMDeInitEntered      (ID_DLMDebug1Base + 55)
#define ID_DLMDeInitExit         (ID_DLMDebug1Base + 56)
#define ID_DLMCloseAllExit       (ID_DLMDebug1Base + 57)
#define ID_DLMEnqEntered         (ID_DLMDebug1Base + 58)
#define ID_DLMEnqExit            (ID_DLMDebug1Base + 59)
#define ID_DLMDeqEntered         (ID_DLMDebug1Base + 60)
#define ID_DLMDeqExit            (ID_DLMDebug1Base + 61)
#define ID_DLMEnqPEntered        (ID_DLMDebug1Base + 62)
#define ID_DLMEnqPExit           (ID_DLMDebug1Base + 63)


// Debug level 2 messages
#define ID_DLMDebug2Base         600
#define ID_DLMCallback           (ID_DLMDebug2Base + 1)
#define ID_DLMConnection         (ID_DLMDebug2Base + 2)
#define ID_DLMBuffer             (ID_DLMDebug2Base + 3)
#define ID_DLMSize               (ID_DLMDebug2Base + 4)
#define ID_DLMRemaining          (ID_DLMDebug2Base + 5)
#define ID_DLMReceived           (ID_DLMDebug2Base + 6)
#define ID_DLMToken              (ID_DLMDebug2Base + 7)
#define ID_DLMOChannel           (ID_DLMDebug2Base + 8)
#define ID_DLMRChannel           (ID_DLMDebug2Base + 9)
#define ID_DLMStatus             (ID_DLMDebug2Base + 10)
#define ID_DLMEndSessClosing     (ID_DLMDebug2Base + 11)
#define ID_DLMBufferSize         (ID_DLMDebug2Base + 12)
#define ID_DLMLinkPacket         (ID_DLMDebug2Base + 13)
#define ID_DLMChannel            (ID_DLMDebug2Base + 14)
#define ID_DLMInDumping          (ID_DLMDebug2Base + 15)
#define ID_DLMByteCount          (ID_DLMDebug2Base + 16)
#define ID_DLMDeqNoBuf           (ID_DLMDebug2Base + 17)
#define ID_DLMEnqPSkip           (ID_DLMDebug2Base + 18)


//------------------------------------------------------------------------------
// MDM -> mdmnbios.dll

#define ID_mdmBase				700
#define ID_mdmLibMain			(ID_mdmBase + 1)
#define ID_mdmWep				(ID_mdmBase + 2)
#define ID_mdmBadhSesUser		(ID_mdmBase + 3)
#define ID_mdmBadhConUser		(ID_mdmBase + 4)
#define ID_mdmBadhSesFree		(ID_mdmBase + 5)
#define ID_mdmBadhConFree		(ID_mdmBase + 6)
#define ID_mdmBadhSesInt		(ID_mdmBase + 7)
#define ID_mdmBadhConInt		(ID_mdmBase + 8)
#define ID_mdmNoMorehSes		(ID_mdmBase + 9)
#define ID_mdmNoMorehCon		(ID_mdmBase + 10)
#define ID_mdmWepConFree		(ID_mdmBase + 11)
#define ID_mdmActiveCon			(ID_mdmBase + 12)
#define ID_mdmBBegSes			(ID_mdmBase + 13)
#define ID_mdmEBegSes			(ID_mdmBase + 14)
#define ID_mdmBEndSes			(ID_mdmBase + 15)
#define ID_mdmEEndSes			(ID_mdmBase + 16)
#define ID_mdmBListen			(ID_mdmBase + 17)
#define ID_mdmEListen			(ID_mdmBase + 18)
#define ID_mdmBMakeCon			(ID_mdmBase + 19)
#define ID_mdmEMakeCon			(ID_mdmBase + 20)
#define ID_mdmBAcceptCon		(ID_mdmBase + 21)
#define ID_mdmEAcceptCon		(ID_mdmBase + 22)
#define ID_mdmBRejectCon		(ID_mdmBase + 23)
#define ID_mdmERejectCon		(ID_mdmBase + 24)
#define ID_mdmBCloseCon			(ID_mdmBase + 25)
#define ID_mdmECloseCon			(ID_mdmBase + 26)
#define ID_mdmErrNetBios		(ID_mdmBase + 27)
#define ID_mdmNoSendNcb			(ID_mdmBase + 28)
#define ID_mdmNoFreeSndNcbSlot	(ID_mdmBase + 29)
#define ID_mdmInvalidConState	(ID_mdmBase + 30)
#define ID_mdmInvalidParams		(ID_mdmBase + 31)
#define ID_mdmToManyListens		(ID_mdmBase + 32)
#define ID_mdmKillTheListen		(ID_mdmBase + 33)
#define ID_mdmBListenCB			(ID_mdmBase + 34)
#define ID_mdmEListenCB			(ID_mdmBase + 35)
#define ID_mdmBConnectCB		(ID_mdmBase + 36)
#define ID_mdmEConnectCB		(ID_mdmBase + 37)
#define ID_mdmBCloseCB			(ID_mdmBase + 38)
#define ID_mdmECloseCB			(ID_mdmBase + 39)
#define ID_mdmBSndCB			(ID_mdmBase + 40)
#define ID_mdmESndCB			(ID_mdmBase + 41)
#define ID_mdmBRcvCB			(ID_mdmBase + 42)
#define ID_mdmERcvCB			(ID_mdmBase + 43)


//---------------------------------------------------------------------------------
// MDM -> MDM Teleos

// Errors
#define ID_MDMTEBASE               1000
#define ID_MDMTEDeqUnackNoHead     (ID_MDMTEBASE + 1)
#define ID_MDMTEDeqUnackNoNext     (ID_MDMTEBASE + 2)
#define ID_MDMTEDeqUnackNoPrev     (ID_MDMTEBASE + 3)
#define ID_MDMTEDeqArrNoTail       (ID_MDMTEBASE + 4)
#define ID_MDMTENullTCB            (ID_MDMTEBASE + 5)
#define ID_MDMTETCBRet             (ID_MDMTEBASE + 6)
#define ID_MDMTEWinSize            (ID_MDMTEBASE + 7)
#define ID_MDMTENoLinkPacket       (ID_MDMTEBASE + 8)
#define ID_MDMTETooLarge           (ID_MDMTEBASE + 9)
#define ID_MDMTELPNotFound         (ID_MDMTEBASE + 10)
#define ID_MDMTENoTCB              (ID_MDMTEBASE + 11)
#define ID_MDMTEInitAlready        (ID_MDMTEBASE + 12)
#define ID_MDMTETCBInitFail        (ID_MDMTEBASE + 13)
#define ID_MDMTELSNErr             (ID_MDMTEBASE + 14)
#define ID_MDMTESizeError          (ID_MDMTEBASE + 15)
#define ID_MDMTEReceived           (ID_MDMTEBASE + 16)
#define ID_MDMTEExpected           (ID_MDMTEBASE + 17)
#define ID_MDMTECorruptQ           (ID_MDMTEBASE + 18)
#define ID_MDMTENoInit             (ID_MDMTEBASE + 19)
#define ID_MDMTEAbanPack           (ID_MDMTEBASE + 20)
#define ID_MDMTESeqNum             (ID_MDMTEBASE + 21)
#define ID_MDMTESipPend            (ID_MDMTEBASE + 22)
#define ID_MDMTENoConn             (ID_MDMTEBASE + 23)
#define ID_MDMTEInvalidID          (ID_MDMTEBASE + 24)
#define ID_MDMTENoSess             (ID_MDMTEBASE + 25)
#define ID_MDMTENoLPM              (ID_MDMTEBASE + 26)
#define ID_MDMTESessID             (ID_MDMTEBASE + 27)
#define ID_MDMTESessNIU            (ID_MDMTEBASE + 28)
#define ID_MDMTESize               (ID_MDMTEBASE + 29)
#define ID_MDMTEState              (ID_MDMTEBASE + 30)
#define ID_MDMTEConnID             (ID_MDMTEBASE + 31)
#define ID_MDMTEConnNIU            (ID_MDMTEBASE + 32)
#define ID_MDMTETinyPacket         (ID_MDMTEBASE + 33)
#define ID_MDMTEPacketOOS          (ID_MDMTEBASE + 34)
#define ID_MDMTEECBNotFound        (ID_MDMTEBASE + 35)

// Trace Information
#define ID_MDMTTBASE               1100
#define ID_MDMTTB1CEnter         (ID_MDMTTBASE + 1)
#define ID_MDMTTB1CExit          (ID_MDMTTBASE + 2)
#define ID_MDMTTSB1Enter         (ID_MDMTTBASE + 3)
#define ID_MDMTTSB1Exit          (ID_MDMTTBASE + 4)
#define ID_MDMTTB2CEnter         (ID_MDMTTBASE + 5)
#define ID_MDMTTB2CExit          (ID_MDMTTBASE + 6)
#define ID_MDMTTSB2Enter         (ID_MDMTTBASE + 7)
#define ID_MDMTTSB2Exit          (ID_MDMTTBASE + 8)
#define ID_MDMTTSendEnter        (ID_MDMTTBASE + 9)
#define ID_MDMTTSendExit         (ID_MDMTTBASE + 10)
#define ID_MDMTTInitEnter        (ID_MDMTTBASE + 11)
#define ID_MDMTTInitExit         (ID_MDMTTBASE + 12)
#define ID_MDMTTDeInitEnter      (ID_MDMTTBASE + 13)
#define ID_MDMTTDeInitExit       (ID_MDMTTBASE + 14)
#define ID_MDMTTLB1Enter         (ID_MDMTTBASE + 15)
#define ID_MDMTTLB1Exit          (ID_MDMTTBASE + 16)
#define ID_MDMTTLB2Enter         (ID_MDMTTBASE + 17)
#define ID_MDMTTLB2Exit          (ID_MDMTTBASE + 18)
#define ID_MDMTTNBSEnter         (ID_MDMTTBASE + 19)
#define ID_MDMTTNBSExit          (ID_MDMTTBASE + 20)
#define ID_MDMTTRecEnter         (ID_MDMTTBASE + 21)
#define ID_MDMTTRecExit          (ID_MDMTTBASE + 22)
#define ID_MDMTTCTSEnter         (ID_MDMTTBASE + 23)
#define ID_MDMTTCTSExit          (ID_MDMTTBASE + 24)
#define ID_MDMTTGCEnter          (ID_MDMTTBASE + 25)
#define ID_MDMTTGCExit           (ID_MDMTTBASE + 26)
#define ID_MDMTTBegSessEnter     (ID_MDMTTBASE + 27)
#define ID_MDMTTBegSessExit      (ID_MDMTTBASE + 28)
#define ID_MDMTTEndSessEnter     (ID_MDMTTBASE + 29)
#define ID_MDMTTEndSessExit      (ID_MDMTTBASE + 30)
#define ID_MDMTTMakeConEnter     (ID_MDMTTBASE + 31)
#define ID_MDMTTMakeConExit      (ID_MDMTTBASE + 32)
#define ID_MDMTTCloseConEnter    (ID_MDMTTBASE + 33)
#define ID_MDMTTCloseConExit     (ID_MDMTTBASE + 34)
#define ID_MDMTTListEnter        (ID_MDMTTBASE + 35)
#define ID_MDMTTListExit         (ID_MDMTTBASE + 36)
#define ID_MDMTTAccEnter         (ID_MDMTTBASE + 37)
#define ID_MDMTTAccExit          (ID_MDMTTBASE + 38)
#define ID_MDMTTRejEnter         (ID_MDMTTBASE + 39)
#define ID_MDMTTRejExit          (ID_MDMTTBASE + 40)
#define ID_MDMTTRecLookEnter     (ID_MDMTTBASE + 41)
#define ID_MDMTTRecLookExit      (ID_MDMTTBASE + 42)

// Comment Information
#define ID_MDMTCBASE               1200
#define ID_MDMTCSeqNum             (ID_MDMTCBASE + 1)
#define ID_MDMTCFound              (ID_MDMTCBASE + 2)
#define ID_MDMTCWaiting            (ID_MDMTCBASE + 3)
#define ID_MDMTCCTSFail            (ID_MDMTCBASE + 4)
#define ID_MDMTCCTSPass            (ID_MDMTCBASE + 5)
#define ID_MDMTCCTSize             (ID_MDMTCBASE + 6)
#define ID_MDMTCCTSOut             (ID_MDMTCBASE + 7)
#define ID_MDMTCTCB                (ID_MDMTCBASE + 8)
#define ID_MDMTCECBPMAddr          (ID_MDMTCBASE + 9)
#define ID_MDMTCECBRMAddr          (ID_MDMTCBASE + 10)

#ifdef __cplusplus
}						// End of extern "C" {
#endif // __cplusplus

#endif	// h file included already

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\h\memtrack.h ===
//
// MEMTRACK.H
// Standard NetMeeting memory leak tracking.
//
// In retail:
//      new/MemAlloc    become      LocalAlloc()
//      MemReAlloc      becomes     LocalReAlloc()
//      delete/MemFree  become      LocalFree()
//
// In debug:
//      allocations are tracked, with module/file/line number
//      leaked blocks are spewed when the module unloads
//
// 
// USAGE:
// (1) Include this header and link to NMUTIL
// (2) If your component requires zero-initialized memory, define 
//      _MEM_ZEROINIT (for both debug and retail) in your SOURCES file
// (3) In your DllMain, on DLL_PROCESS_ATTACH call DBG_INIT_MEMORY_TRACKING,
//     and on DLL_PROCESS_DETACH call DBG_CHECK_MEMORY_TRACKING
// (4) In DEBUG, you can make a call to DbgMemTrackDumpCurrent() to dump
//      the currently allocated memory list from code.
//


#ifndef _MEMTRACK_H
#define _MEMTRACK_H

#ifdef __cplusplus
extern "C" {
#endif

//
// MEMORY ALLOCATIONS/TRACKING
//
//
// GUI message boxes kill us when we hit an assert or error, because they
// have a message pump that causes messages to get dispatched, making it
// very difficult for us to debug problems when they occur.  Therefore
// we redefine ERROR_OUT and ASSERT
//
#ifdef DEBUG


#undef assert
#define assert(x)           ASSERT(x)


void    WINAPI DbgMemTrackDumpCurrent(void);
void    WINAPI DbgMemTrackFinalCheck(void);

LPVOID  WINAPI DbgMemAlloc(UINT cbSize, LPVOID caller, LPSTR pszFileName, UINT nLineNumber);
void    WINAPI DbgMemFree(LPVOID ptr);
LPVOID  WINAPI DbgMemReAlloc(LPVOID ptr, UINT cbSize, UINT uFlags, LPSTR pszFileName, UINT nLineNumber);


#define DBG_CHECK_MEMORY_TRACKING(hInst)     DbgMemTrackFinalCheck()  
 
#define MemAlloc(cbSize)            DbgMemAlloc(cbSize, NULL, __FILE__, __LINE__)

#ifdef _MEM_ZEROINIT
#define MemReAlloc(pObj, cbSize)    DbgMemReAlloc((pObj), (cbSize), LMEM_MOVEABLE | LMEM_ZEROINIT, __FILE__, __LINE__)
#else
#define MemReAlloc(pObj, cbSize)    DbgMemReAlloc((pObj), (cbSize), LMEM_MOVEABLE, __FILE__, __LINE__)
#endif //_MEM_ZEROINIT

#define MemFree(pObj)               DbgMemFree(pObj)

void    WINAPI DbgSaveFileLine(LPSTR pszFileName, UINT nLineNumber);
#define DBG_SAVE_FILE_LINE          DbgSaveFileLine(__FILE__, __LINE__);


// RETAIL
#else

#define DBG_CHECK_MEMORY_TRACKING(hInst)   

#ifdef _MEM_ZEROINIT
#define MemAlloc(cbSize)            LocalAlloc(LPTR, (cbSize))
#define MemReAlloc(pObj, cbSize)    LocalReAlloc((pObj), (cbSize), LMEM_MOVEABLE | LMEM_ZEROINIT)
#else
#define MemAlloc(cbSize)            LocalAlloc(LMEM_FIXED, (cbSize))
#define MemReAlloc(pObj, cbSize)    LocalReAlloc((pObj), (cbSize), LMEM_MOVEABLE)
#endif // _MEM_ZEROINIT

#define MemFree(pObj)               LocalFree(pObj)

#define DBG_SAVE_FILE_LINE

#endif // DEBUG


void WINAPI DbgInitMemTrack(HINSTANCE hDllInst, BOOL fZeroOut);
#ifdef _MEM_ZEROINIT
#define DBG_INIT_MEMORY_TRACKING(hInst)     DbgInitMemTrack(hInst, TRUE)
#else
#define DBG_INIT_MEMORY_TRACKING(hInst)     DbgInitMemTrack(hInst, FALSE)
#endif //_MEM_ZEROINIT



#define MEMALLOC(cb)                MemAlloc(cb)
#define MEMREALLOC(p, cb)           MemReAlloc(p, cb)
#define MEMFREE(p)                  MemFree(p)


#ifdef __cplusplus
}
#endif




#endif // #ifndef _MEMTRACK_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\h\mlzdbg.h ===
#ifndef _Multi_Level_Zone_Debug_H_
#define _Multi_Level_Zone_Debug_H_

#include <confdbg.h>
#include <debspew.h>

#define ZONE_FLAG(z)    (1 << (z))

#if defined(_DEBUG) && defined(MULTI_LEVEL_ZONES)

#define DEFAULT_ZONES       "Warning",    "Trace",     "Function",
#define BASE_ZONE_INDEX     (ZONE_FUNCTION + 1)


#undef TRACE_OUT
#define TRACE_OUT(s)        MLZ_TraceZoneEnabled(MLZ_FILE_ZONE) ? (MLZ_TraceOut s) : 0

#undef WARNING_OUT
#define WARNING_OUT(s)      MLZ_WarningOut s

#undef DebugEntry
#define DebugEntry(fn)          MLZ_EntryOut(MLZ_FILE_ZONE, #fn)

#undef DebugExitVOID
#define DebugExitVOID(fn)       MLZ_ExitOut(MLZ_FILE_ZONE, #fn, RCTYPE_VOID,    (DWORD) 0)

#undef DebugExitBOOL
#define DebugExitBOOL(fn,f)     MLZ_ExitOut(MLZ_FILE_ZONE, #fn, RCTYPE_BOOL,    (DWORD) f)

#undef DebugExitDWORD
#define DebugExitDWORD(fn,dw)   MLZ_ExitOut(MLZ_FILE_ZONE, #fn, RCTYPE_DWORD,   (DWORD) dw)

#undef DebugExitHRESULT
#define DebugExitHRESULT(fn,hr) MLZ_ExitOut(MLZ_FILE_ZONE, #fn, RCTYPE_HRESULT, (DWORD) hr)

#undef DebugExitINT
#define DebugExitINT(fn,n)      MLZ_ExitOut(MLZ_FILE_ZONE, #fn, RCTYPE_INT,     (DWORD) n)

#undef DebugExitULONG
#define DebugExitULONG(fn,ul)   MLZ_ExitOut(MLZ_FILE_ZONE, #fn, RCTYPE_ULONG,   (DWORD) ul)

#undef DebugExitPTR
#define DebugExitPTR(fn,lp)     MLZ_ExitOut(MLZ_FILE_ZONE, #fn, RCTYPE_PTR,   (DWORD_PTR) lp)


#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

typedef enum
{
    RCTYPE_VOID     = 0,
    RCTYPE_BOOL     = 1,
    RCTYPE_DWORD    = 2,
    RCTYPE_HRESULT  = 3,
    RCTYPE_INT      = 4,
    RCTYPE_ULONG    = 5,
    RCTYPE_PTR      = 6
}
    RCTYPE;

void WINAPI  MLZ_DbgInit(PSTR *apszZones, UINT cZones);
void WINAPI  MLZ_DbgDeInit(void);
void WINAPIV MLZ_WarningOut(PSTR pszFormat, ...);
BOOL WINAPI  MLZ_TraceZoneEnabled(int iZone);
void WINAPIV MLZ_TraceOut(PSTR pszFormat, ...);
void WINAPI  MLZ_EntryOut(int iZone, PSTR pszFunName);
void WINAPI  MLZ_ExitOut(int iZone, PSTR pszFunName, RCTYPE eRetCodeType, DWORD_PTR dwRetCode);

#ifdef __cplusplus
}
#endif // __cplusplus

#else
#define DebugExitPTR(fn,lp)

#endif // _DEBUG && MULTI_ZONE_OUT

#endif // _Multi_Level_Zone_Debug_H_


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\h\mperror.h ===
/*
 -  mperror.h
 -
 *      Microsoft Internet Phone
 *		Common error codes
 *
 *		Revision History:
 *
 *		When		Who					What
 *		--------	------------------  ---------------------------------------
 *		11.20.95	Yoram Yaacovi		Created
 *		11.30.95	Lon-Chan Chu		Added MAKE_AVC_ERROR and MAKE_AVC_WARNING.
 *		12.02.95	Lon-Chan Chu		Added datapump error codes.
 */

#ifndef _AVC_ERROR_H_
#define _AVC_ERROR_H_

#include <winerror.h>

#include <pshpack8.h> /* Assume 8 byte packing throughout */

/*
 *	Macros
 */
#define HR_SUCCEEDED(_hr)		SUCCEEDED((SCODE)(_hr))
#define HR_FAILED(_hr)			FAILED((SCODE)(_hr))
#define MakeResult(_s)			ResultFromScode(_s)

/*
 *	Error codes
 *
 *	error codes for hResults are in winerror.h
 */
#define hrSuccess               0


//
//	Common macros
//

#define AVC_FACILITY			0x100		// facility code for audio/video communications
#define MAKE_AVC_ERROR(z,e)		MAKE_HRESULT(1,AVC_FACILITY,(((z)&0xF000)|(e)))
#define MAKE_AVC_WARNING(z,w)	MAKE_HRESULT(0,AVC_FACILITY,(((z)&0xF000)|(w)))

#define AVC_APP_ZONE			0x0000		// ui and application
#define AVC_DP_ZONE				0x1000		// datapump
#define AVC_NAC_ZONE			0x2000		// nac
#define AVC_CONN_ZONE			0x3000		// conn
#define AVC_NRES_ZONE			0x4000		// name resolution
#define AVC_UI_ZONE			0x5000		// ui
#define AVC_CAP_ZONE			0x6000
#define AVC_CCO_ZONE			0x7000
#define AVC_CADV_ZONE			0x8000
#define AVC_PC_ZONE				0x9000
#define AVC_CHAN_ZONE				0xA000

#define AVC_WIN32_ZONE			0xF000		// Win32 error code

#define Win32ErrToHR(e)			MAKE_AVC_ERROR (AVC_WIN32_ZONE, e)
#define GetLastHR()				Win32ErrToHR (GetLastError ())

//
//	NAC return codes
//
#define H323CC_E_INVALID_PARAM 		MAKE_AVC_ERROR(AVC_NAC_ZONE, 0x0000)
#define H323CC_E_INSUFFICIENT_MEMORY 	MAKE_AVC_ERROR(AVC_NAC_ZONE, 0x0001)
#define H323CC_E_MORE_CONNECTIONS		MAKE_AVC_ERROR(AVC_NAC_ZONE, 0x0004)
#define H323CC_E_NOACTIVELINE			MAKE_AVC_ERROR(AVC_NAC_ZONE, 0x0005)
#define H323CC_E_INIT_FAILURE			MAKE_AVC_ERROR(AVC_NAC_ZONE, 0x0006)
#define H323CC_E_CREATE_FAILURE		MAKE_AVC_ERROR(AVC_NAC_ZONE, 0x0007)
#define H323CC_E_DATAPUMP_ERROR		MAKE_AVC_ERROR(AVC_NAC_ZONE, 0x0008)
#define H323CC_E_REGISTRY_ERROR		MAKE_AVC_ERROR(AVC_NAC_ZONE, 0x0009)
#define H323CC_E_NO_AUDIOHW			MAKE_AVC_ERROR(AVC_NAC_ZONE, 0x000A)
#define H323CC_E_NETWORK_ERROR			MAKE_AVC_ERROR(AVC_NAC_ZONE, 0x000B)
#define H323CC_E_NOT_INITIALIZED		MAKE_AVC_ERROR(AVC_NAC_ZONE, 0x000C)
#define H323CC_E_CONNECTION_NOT_FOUND	MAKE_AVC_ERROR(AVC_NAC_ZONE, 0x000D)

//
// IConfAdvise interface error codes
//
#define CADV_E_INVALID_PARAM 	MAKE_AVC_ERROR(AVC_CADV_ZONE, 0x0000)
#define CADV_E_NOT_INITIALIZED 	MAKE_AVC_ERROR(AVC_CADV_ZONE, 0x0001)
#define CADV_E_NOT_SUPPORTED 	MAKE_AVC_ERROR(AVC_CADV_ZONE, 0x0002)

//
// connection object error codes
//

#define CONN_E_INVALID_PARAM  	MAKE_AVC_ERROR(AVC_CONN_ZONE, 0x0000)
#define CONN_E_NOT_IDLE  		MAKE_AVC_ERROR(AVC_CONN_ZONE, 0x0001)
#define CONN_E_BAD_ADDRESS		MAKE_AVC_ERROR(AVC_CONN_ZONE, 0x0002)
#define CONN_E_CONNECT_FAILED	MAKE_AVC_ERROR(AVC_CONN_ZONE, 0x0003)
#define CONN_E_INIT_FAILED		MAKE_AVC_ERROR(AVC_CONN_ZONE, 0x0004)
#define CONN_E_OUT_OF_MEMORY	MAKE_AVC_ERROR(AVC_CONN_ZONE, 0x0005)
#define CONN_E_MANDATORY_CHAN_OPEN_FAILED 	MAKE_AVC_ERROR(AVC_CONN_ZONE, 0x0006)
#define CONN_E_SYSTEM_ERROR		MAKE_AVC_ERROR(AVC_CONN_ZONE, 0x0007)
#define CONN_E_NOT_INITIALIZED		MAKE_AVC_ERROR(AVC_CONN_ZONE, 0x0008)
#define CONN_E_ALREADY_INITIALIZED	MAKE_AVC_ERROR(AVC_CONN_ZONE, 0x0009)
#define CONN_E_GK_NOT_REGISTERED	MAKE_AVC_ERROR(AVC_CONN_ZONE, 0x000A)

//
// control channel object error codes
//

#define CCO_E_INVALID_PARAM  	MAKE_AVC_ERROR(AVC_CCO_ZONE, 0x0000)
#define CCO_E_NOT_IDLE  		MAKE_AVC_ERROR(AVC_CCO_ZONE, 0x0001)
#define CCO_E_BAD_ADDRESS		MAKE_AVC_ERROR(AVC_CCO_ZONE, 0x0002)
#define CCO_E_CONNECT_FAILED	MAKE_AVC_ERROR(AVC_CCO_ZONE, 0x0003)
#define CCO_E_INIT_FAILED		MAKE_AVC_ERROR(AVC_CCO_ZONE, 0x0004)
#define CCO_E_OUT_OF_MEMORY		MAKE_AVC_ERROR(AVC_CCO_ZONE, 0x0005)
#define CCO_E_MANDATORY_CHAN_OPEN_FAILED 	MAKE_AVC_ERROR(AVC_CCO_ZONE, 0x0006)
#define CCO_E_NODEFAULT_CHANNEL 	MAKE_AVC_ERROR(AVC_CCO_ZONE, 0x0007)
#define CCO_E_INVALID_CAPABILITY  	MAKE_AVC_ERROR(AVC_CCO_ZONE, 0x0008)
#define CCO_E_UNSUPPORTED_MEDIA_TYPE  	MAKE_AVC_ERROR(AVC_CCO_ZONE, 0x0009)
#define CCO_E_SYSTEM_ERROR	 	MAKE_AVC_ERROR(AVC_CCO_ZONE, 0x000a)
#define CCO_E_NOT_LISTENING		MAKE_AVC_ERROR(AVC_CCO_ZONE, 0x000b)
#define CCO_E_NOT_SUPPORTED		MAKE_AVC_ERROR(AVC_CCO_ZONE, 0x000c)
//
//	channel (ICommChannel) error codes
//

#define CHAN_E_INVALID_PARAM  	MAKE_AVC_ERROR(AVC_CHAN_ZONE, 0x0000)
#define CHAN_E_NOT_OPEN  	    MAKE_AVC_ERROR(AVC_CHAN_ZONE, 0x0001)

//
// capability object error codes
//
#define AUDCAPS_W_MORE_FORMATS	MAKE_AVC_WARNING(AVC_CAP_ZONE,0x0001)
#define CAPS_W_NO_MORE_FORMATS  MAKE_AVC_WARNING(AVC_CAP_ZONE,0x0002)

#define CAPS_E_NOCAPS		        MAKE_AVC_ERROR(AVC_CAP_ZONE,0x0001)
#define CAPS_E_NOMATCH		        MAKE_AVC_ERROR(AVC_CAP_ZONE,0x0002)
#define CAPS_E_NOMEM			    MAKE_AVC_ERROR(AVC_CAP_ZONE,0x0003)
#define CAPS_E_NOT_SUPPORTED        MAKE_AVC_ERROR(AVC_CAP_ZONE,0x0005)
#define CAPS_E_BUFFER_TOO_SMALL	    MAKE_AVC_ERROR(AVC_CAP_ZONE,0x0006)
#define	CAPS_E_SYSTEM_ERROR		    MAKE_AVC_ERROR(AVC_CAP_ZONE,0x0007)
#define CAPS_E_INVALID_PARAM		MAKE_AVC_ERROR(AVC_CAP_ZONE,0x000F)

//
// datapump error codes
//

#define DPR_SUCCESS					0
#define DPR_INVALID_PARAMETER		MAKE_AVC_ERROR (AVC_DP_ZONE, 0x1)
#define DPR_INVALID_PROP_ID			MAKE_AVC_ERROR (AVC_DP_ZONE, 0x2)
#define DPR_INVALID_PROP_VAL		MAKE_AVC_ERROR (AVC_DP_ZONE, 0x3)
#define DPR_INVALID_PLATFORM		MAKE_AVC_ERROR (AVC_DP_ZONE, 0x4)
#define DPR_CANT_PREPARE_HEADER		MAKE_AVC_ERROR (AVC_DP_ZONE, 0x5)
#define DPR_CANT_UNPREPARE_HEADER	MAKE_AVC_ERROR (AVC_DP_ZONE, 0x6)
#define DPR_CANT_GET_BUF_SIZE		MAKE_AVC_ERROR (AVC_DP_ZONE, 0x7)
#define DPR_IMPOSSIBLE_SET_PROP		MAKE_AVC_ERROR (AVC_DP_ZONE, 0x8)
#define DPR_CANT_ADD_BUFFER			MAKE_AVC_ERROR (AVC_DP_ZONE, 0x9)
#define DPR_CANT_WRITE_WAVE_DEV		MAKE_AVC_ERROR (AVC_DP_ZONE, 0xA)
#define DPR_CANT_OPEN_CODEC			MAKE_AVC_ERROR (AVC_DP_ZONE, 0xB)
#define DPR_CANT_OPEN_WAVE_DEV		MAKE_AVC_ERROR (AVC_DP_ZONE, 0xC)
#define DPR_CANT_SET_VOLUME			MAKE_AVC_ERROR (AVC_DP_ZONE, 0xD)
#define DPR_CANT_INITIALIZE_AGAIN	MAKE_AVC_ERROR (AVC_DP_ZONE, 0xE)
#define DPR_OUT_OF_MEMORY			MAKE_AVC_ERROR (AVC_DP_ZONE, 0xF)
#define DPR_OUT_OF_SEQUENCE			MAKE_AVC_ERROR (AVC_DP_ZONE, 0x10)
#define DPR_CONVERSION_FAILED		MAKE_AVC_ERROR (AVC_DP_ZONE, 0x11)
#define DPR_CANT_CREATE_EVENT		MAKE_AVC_ERROR (AVC_DP_ZONE, 0x12)
#define DPR_NET_SEND_ERROR			MAKE_AVC_ERROR (AVC_DP_ZONE, 0x13)
#define DPR_NET_RECV_ERROR			MAKE_AVC_ERROR (AVC_DP_ZONE, 0x14)
#define DPR_LATE_PACKET				MAKE_AVC_ERROR (AVC_DP_ZONE, 0x15)
#define DPR_DUPLICATE_PACKET		MAKE_AVC_ERROR (AVC_DP_ZONE, 0x16)
#define DPR_CANT_START_WAVE_DEV		MAKE_AVC_ERROR (AVC_DP_ZONE, 0x17)
#define DPR_CANT_STOP_WAVE_DEV		MAKE_AVC_ERROR (AVC_DP_ZONE, 0x18)
#define DPR_INVALID_MEDIA_TYPE		MAKE_AVC_ERROR (AVC_DP_ZONE, 0x1A)
#define DPR_NOT_INITIALIZED			MAKE_AVC_ERROR (AVC_DP_ZONE, 0x1B)
#define DPR_NOT_CONFIGURED			MAKE_AVC_ERROR (AVC_DP_ZONE, 0x1C)
#define DPR_INVALID_FORMAT			MAKE_AVC_ERROR (AVC_DP_ZONE, 0x1D)
#define DPR_NO_PLAY_CAP				MAKE_AVC_ERROR (AVC_DP_ZONE, 0x1E)
#define DPR_NO_RECORD_CAP			MAKE_AVC_ERROR (AVC_DP_ZONE, 0x1F)
#define DPR_CANT_RESET_WAVE_DEV		MAKE_AVC_ERROR (AVC_DP_ZONE, 0x2B)
#define DPR_INVALID_HANDLE			MAKE_AVC_ERROR (AVC_DP_ZONE, 0x2C)
#define DPR_CANT_CLOSE_WAVE_DEV		MAKE_AVC_ERROR (AVC_DP_ZONE, 0x2D)
#define DPR_CANT_INIT_RX_STREAM		MAKE_AVC_ERROR (AVC_DP_ZONE, 0x2E)
#define DPR_CANT_INIT_TX_STREAM		MAKE_AVC_ERROR (AVC_DP_ZONE, 0x2F)
#define DPR_NOT_YET_IMPLEMENTED		MAKE_AVC_ERROR (AVC_DP_ZONE, 0x30)
#define DPR_PROPERTY_NOT_AVAILABLE	MAKE_AVC_ERROR (AVC_DP_ZONE, 0x31)
#define DPR_CANT_INTERPOLATE		MAKE_AVC_ERROR (AVC_DP_ZONE, 0x32)
#define DPR_CANT_WRITE_VIDEO_DEV	MAKE_AVC_ERROR (AVC_DP_ZONE, 0x33)
#define DPR_CANT_OPEN_DEV			MAKE_AVC_ERROR (AVC_DP_ZONE, 0x34)
#define DPR_CANT_CLOSE_DEV			MAKE_AVC_ERROR (AVC_DP_ZONE, 0x35)
#define DPR_CANT_START_DEV			MAKE_AVC_ERROR (AVC_DP_ZONE, 0x36)
#define DPR_CANT_STOP_DEV			MAKE_AVC_ERROR (AVC_DP_ZONE, 0x37)
#define DPR_CANT_RESET_DEV			MAKE_AVC_ERROR (AVC_DP_ZONE, 0x38)
#define DPR_CANT_PAUSE_DEV			MAKE_AVC_ERROR (AVC_DP_ZONE, 0x39)
#define DPR_CANT_RESTART_DEV		MAKE_AVC_ERROR (AVC_DP_ZONE, 0x3A)
#define DPR_CANT_INIT_RXV_STREAM	MAKE_AVC_ERROR (AVC_DP_ZONE, 0x3B)
#define DPR_CANT_INIT_TXV_STREAM	MAKE_AVC_ERROR (AVC_DP_ZONE, 0x3C)
#define DPR_CANT_REGISTER_WND_CLASS	MAKE_AVC_ERROR (AVC_DP_ZONE, 0x3D)
#define DPR_CANT_CREATE_WINDOW		MAKE_AVC_ERROR (AVC_DP_ZONE, 0x3E)

// Datapump warning
#define DPR_NO_PACKET_READY         MAKE_AVC_WARNING (AVC_DP_ZONE, 0x1)
#define DPR_IO_PENDING              MAKE_AVC_WARNING (AVC_DP_ZONE, 0x2)

//name resolution errors
#define NMRES_E_INVALIDARG			MAKE_AVC_ERROR(AVC_NRES_ZONE, 0x0001)
#define NMRES_E_OUTOFMEMORY			MAKE_AVC_ERROR(AVC_NRES_ZONE, 0x0002)
#define NMRES_E_INETAPIFAILED		MAKE_AVC_ERROR(AVC_NRES_ZONE, 0x0003)
#define NMRES_E_SERVERUNKNOWN		MAKE_AVC_ERROR(AVC_NRES_ZONE, 0x0004)
#define NMRES_E_SERVNOTINITIALIZED  MAKE_AVC_ERROR(AVC_NRES_ZONE, 0x0005)
#define NMRES_E_SOCKCALLFAILED		MAKE_AVC_ERROR(AVC_NRES_ZONE, 0x0006)
#define NMRES_E_IPAFILEPARSEFAILED  MAKE_AVC_ERROR(AVC_NRES_ZONE, 0x0007)
#define NMRES_E_UNEXPECTEDIPAREPLY	MAKE_AVC_ERROR(AVC_NRES_ZONE, 0x0008)
#define NMRES_E_IPALINEPARSEFAILED  MAKE_AVC_ERROR(AVC_NRES_ZONE, 0x0009)
#define NMRES_E_IPAQUERYFAILED		MAKE_AVC_ERROR(AVC_NRES_ZONE, 0x000A)
#define NMRES_E_HTMLFILEPARSEFAILED	MAKE_AVC_ERROR(AVC_NRES_ZONE, 0x000B)
#define NMRES_E_IPARESULTCONVFAILED MAKE_AVC_ERROR(AVC_NRES_ZONE, 0x000C)
#define NMRES_E_DLGERROR			MAKE_AVC_ERROR(AVC_NRES_ZONE, 0x000D)
#define NMRES_E_NOUSERDETAILS		MAKE_AVC_ERROR(AVC_NRES_ZONE, 0x000E)
#define NMRES_E_INETOPENURLFAILED	MAKE_AVC_ERROR(AVC_NRES_ZONE, 0x000F)


//name resolution warnings
#define NMRES_W_HTMLFILEIMPERFECT	MAKE_AVC_WARNING(AVC_NRES_ZONE,0x0001)

//
// Codec Performance error codes
//
#define PERFCODEC_SUCCESS					0
#define PERFCODEC_INVALID_PARAMETER			MAKE_AVC_ERROR(AVC_PC_ZONE,0x0001)
#define PERFCODEC_OUT_OF_MEMORY				MAKE_AVC_ERROR(AVC_PC_ZONE,0x0002)
#define PERFCODEC_CANT_OPEN_CODEC			MAKE_AVC_ERROR(AVC_PC_ZONE,0x0003)
#define PERFCODEC_CANT_GET_BUF_SIZE			MAKE_AVC_ERROR(AVC_PC_ZONE,0x0004)
#define PERFCODEC_CANT_PREPARE_HEADER		MAKE_AVC_ERROR(AVC_PC_ZONE,0x0005)
#define PERFCODEC_CANT_CONVERT				MAKE_AVC_ERROR(AVC_PC_ZONE,0x0006)
#define PERFCODEC_CANT_UNPREPARE_HEADER		MAKE_AVC_ERROR(AVC_PC_ZONE,0x0007)
#define PERFCODEC_CANT_CLOSE_CODEC			MAKE_AVC_ERROR(AVC_PC_ZONE,0x0008)
#define PERFCODEC_CREATE_FAILED				MAKE_AVC_ERROR(AVC_PC_ZONE,0x0009)
#define PERFCODEC_DELETE_FAILED				MAKE_AVC_ERROR(AVC_PC_ZONE,0x000A)

#include <poppack.h> /* End byte packing */

#endif // _AVC_ERROR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\h\mediacap.h ===
#ifndef _MEDIACAP_H
#define _MEDIACAP_H

#ifdef __cplusplus

#define RTP_DYNAMIC_MIN 96	// use value in the range of "dynamic" payload type
#define RTP_DYNAMIC_MAX 127
#define IsDynamicPayload(p) ((p >= RTP_DYNAMIC_MIN) && (p <= RTP_DYNAMIC_MAX))


#define CAP_CHUNK_SIZE 8	// allocate AUDCAP_DETAILS and VIDCAP_DETAILS in chunks of this size
#define MAX_CAPS_PRESORT 64

typedef struct
{
	WORD  wDataRate;	// (channel param) Data rate - must be one of the data rates
						// received in the exchanged capabilities. or within the
						//specified range. Note that this is redundant
						// in the case of exchanging a WAVEFORMATEX
	WORD wFrameSizeMax; 	// (capability)
	WORD wFrameSizeMin;		// (capability)
	WORD wFrameSize;		// (channel open param) Record - playback frame size
	WORD wFramesPerPkt;		// (channel open param) Number of frames in an audio packet
	WORD wFramesPerPktMax;	// (capability)
	WORD wFramesPerPktMin;	// (capability)
	BYTE UseSilenceDet; // If silence detection is to be used/is available (both)
	BYTE UsePostFilter;	// If post-filtering is to be used	(channel open param. (both?))

}NSC_CHANNEL_PARAMETERS, *PNSC_CHANNEL_PARAMETERS;

typedef struct
{
	NSC_CHANNEL_PARAMETERS ns_params;
	BYTE	RTP_Payload;
}AUDIO_CHANNEL_PARAMETERS, *PAUDIO_CHANNEL_PARAMETERS;


typedef enum
{
	NSC_ACMABBREV = 1,
	NSC_ACM_WAVEFORMATEX,
	// NSC_MS_ACTIVE_MOVIE
} NSC_CAP_TYPE;

typedef struct
{
	DWORD dwFormatTag;		// ACM format tag  + padding
	DWORD dwSamplesPerSec;	// samples per second
	DWORD dwBitsPerSample;	// bits per sample plus padding
}NSC_AUDIO_ACM_ABBREVIATED; //ACM_TAG_CAPS, *LP_ACM_TAG_CAPS;

// DON't ever allocate an array of these because of WAVEFORMATEX Extra Bytes
typedef struct {
	NSC_CAP_TYPE cap_type;
	NSC_CHANNEL_PARAMETERS cap_params;
	union {
		WAVEFORMATEX wfx;
		NSC_AUDIO_ACM_ABBREVIATED acm_brief;
	}cap_data;
}NSC_AUDIO_CAPABILITY, *PNSC_AUDIO_CAPABILITY;

typedef struct
{
	UINT maxBitRate;
	USHORT maxBPP;
	USHORT MPI;
}NSC_CHANNEL_VIDEO_PARAMETERS, *PNSC_CHANNEL_VIDEO_PARAMETERS;

typedef struct
{
	NSC_CHANNEL_VIDEO_PARAMETERS ns_params;
	BYTE	RTP_Payload;
	BOOL	TS_Tradeoff;
}VIDEO_CHANNEL_PARAMETERS, *PVIDEO_CHANNEL_PARAMETERS;


typedef enum
{
	NSC_VCMABBREV = 1,
	NSC_VCM_VIDEOFORMATEX,
	// NSC_MS_ACTIVE_MOVIE
} NSC_CVP_TYPE;

typedef struct
{
	DWORD dwFormatTag;		// VCM format tag  + padding
	DWORD dwSamplesPerSec;	// samples per second
	DWORD dwBitsPerSample;	// bits per sample plus padding
}NSC_VIDEO_VCM_ABBREVIATED; //VCM_TAG_CAPS, *LP_VCM_TAG_CAPS;



// DON't ever allocate an array of these because of VIDEOFORMATEX Extra Bytes
typedef struct {
	NSC_CVP_TYPE cvp_type;
	NSC_CHANNEL_VIDEO_PARAMETERS cvp_params;
	union {
		VIDEOFORMATEX vfx;
		NSC_VIDEO_VCM_ABBREVIATED vcm_brief;
	}cvp_data;
}NSC_VIDEO_CAPABILITY, *PNSC_VIDEO_CAPABILITY;



// IH323MediaCap  is exposed by the media-specific capability object
// This interface is used primarily by the simultaneous capability object.
// (i.e. the thing that combines all capabilities)
class IH323MediaCap
{
	public:
	STDMETHOD(QueryInterface(REFIID riid, LPVOID FAR * ppvObj))=0;
	STDMETHOD_(ULONG,  AddRef()) =0;
	STDMETHOD_(ULONG, Release())=0;

	STDMETHOD_(BOOL, Init())=0;
	STDMETHOD_(BOOL, ReInit())=0;
	STDMETHOD_(VOID, FlushRemoteCaps())=0;
	STDMETHOD(AddRemoteDecodeCaps(PCC_TERMCAPLIST pTermCapList))=0;
	// H.245 parameter grabbing functions
	// Get public version of channel parameters for a specific decode capability
	STDMETHOD(GetPublicDecodeParams(LPVOID pBufOut, UINT uBufSize, MEDIA_FORMAT_ID id))=0;
	// Get local and remote channel parameters for a specific encode capability
	STDMETHOD( GetEncodeParams(LPVOID pBufOut, UINT uBufSize, LPVOID pLocalParams,
			UINT uLocalSize,MEDIA_FORMAT_ID idRemote,MEDIA_FORMAT_ID idLocal))=0;
 	// get local version of channel parameters for a specific decode capability
	STDMETHOD(GetDecodeParams(PCC_RX_CHANNEL_REQUEST_CALLBACK_PARAMS  pChannelParams,
		MEDIA_FORMAT_ID * pFormatID, LPVOID lpvBuf, UINT uBufSize))=0;
	STDMETHOD( CreateCapList(LPVOID *ppCapBuf))=0;
	STDMETHOD( DeleteCapList(LPVOID pCapBuf))=0;

	STDMETHOD( ResolveEncodeFormat(MEDIA_FORMAT_ID *pIDEncodeOut,MEDIA_FORMAT_ID * pIDRemoteDecode))=0;


	STDMETHOD_(UINT, GetNumCaps())=0;				
	STDMETHOD_(UINT, GetNumCaps(BOOL bRXCaps))=0;
	STDMETHOD_(BOOL, IsHostForCapID(MEDIA_FORMAT_ID CapID))=0;
	STDMETHOD_(BOOL, IsCapabilityRecognized(PCC_TERMCAP pCCThisCap))=0;
	STDMETHOD_(MEDIA_FORMAT_ID, AddRemoteDecodeFormat(PCC_TERMCAP pCCThisCap))=0;

	STDMETHOD(SetCapIDBase(UINT uNewBase))=0;
	STDMETHOD_(UINT, GetCapIDBase())=0;
		STDMETHOD_(UINT, GetLocalSendParamSize(MEDIA_FORMAT_ID dwID))=0;
	STDMETHOD_(UINT, GetLocalRecvParamSize(PCC_TERMCAP pCapability))=0;

	// The following is an interim solution, definitely must revisit this for the next release.
 	// The data pump requires access to local parameters that results from capability
 	// negotiation. In the absence of a separate interface that the data pump can use,
 	// the following are stuck onto this interface.
	STDMETHOD(GetDecodeFormatDetails(MEDIA_FORMAT_ID FormatID, VOID **ppFormat, UINT *puSize))=0;
	STDMETHOD(GetEncodeFormatDetails(MEDIA_FORMAT_ID FormatID, VOID **ppFormat, UINT *puSize))=0;

	STDMETHOD (IsFormatEnabled (MEDIA_FORMAT_ID FormatID, PBOOL bRecv, PBOOL bSend))=0;
	STDMETHOD_(BOOL, IsFormatPublic(MEDIA_FORMAT_ID FormatID))=0;
	STDMETHOD_(MEDIA_FORMAT_ID, GetPublicID(MEDIA_FORMAT_ID FormatID))=0;
	STDMETHOD_ (VOID, EnableTXCaps(BOOL bSetting))=0;
	STDMETHOD_ (VOID, EnableRemoteTSTradeoff(BOOL bSetting))=0;
	STDMETHOD (SetAudioPacketDuration( UINT durationInMs))=0;
	STDMETHOD (ResolveToLocalFormat(MEDIA_FORMAT_ID FormatIDLocal,
		MEDIA_FORMAT_ID * pFormatIDRemote))=0;
};
typedef IH323MediaCap *LPIH323MediaCap;

#endif //__cplusplus


#endif // _MEDIACAP_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\h\lst.h ===
#ifndef __lst_h__
#define __lst_h__

#ifndef ASSERT
    #define ASSERT( x ) 
#endif // #ifndef ASSERT

#include <functional>


// lst bidirectional linked-list template class
// Here are some examples of the usage:
//
//    lst< int > MyList;
//
//    for( int i = 0; i < 10; i++ ) {        
//        MyList . push_front( i );
//    }
//
//   
//    lst< int > TestList;
//    TestList . insert( TestList . begin(), MyList . begin(), MyList . end() ); 
//
//    const lst< int > cList = MyList;
//
//    lst< int >::const_iterator I = cList . begin();
//    while( I != cList . end() ) {
//        int Num = *I;
//        I++;
//    }
//
//
//  the const_iterator is used to iterate through a const List
// 
//  

template< class T, class Operator_Eq = std::equal_to<T> >
class lst {

private: // Data types and typedefs

    typedef T value_type;
    typedef value_type* pointer;
    typedef value_type& reference;
    typedef const value_type& const_reference;
    typedef lst< value_type > self;
	Operator_Eq _FnEq;

    class node {
    public:
      node( node* pP, node* pN, const_reference t ) : pNext( pN ), pPrev( pP ), data( t ) { ; }
      node( void ) : pNext( NULL ), pPrev( NULL ) { ; }
      node* pNext;
      node* pPrev;
      value_type data;
    };            

public:
        // iterator class for iterating through the list
    class iterator {
    friend lst;        
    private:
        typedef iterator self;
        node* pNode;

        iterator( node* pN ) : pNode( pN ) { ; }

    public:
        iterator( void ) : pNode( NULL ) { ; }
        ~iterator( void ) { ; }

        iterator( self& r ) { *this = r; }
        
        iterator& operator=( iterator& r ) { pNode = r . pNode; return *this; }
        bool operator==( const self& r ) const { return pNode == r . pNode; }
        operator!=( const self& r ) const { return pNode != r . pNode; }
        reference operator*() { return pNode -> data; }
        self& operator++() { 
            pNode = pNode -> pNext;
            return *this;
        }
        
        self operator++( int ) { 
            self tmp = *this;
            ++*this;
            return tmp;
        }
        
        self& operator--() { 
            pNode = pNode -> pPrev;
            return *this;
        }
        
        self operator--(int) { 
            self tmp = *this;
            --*this;
            return tmp;
        }

    };

        // const_iterator class for iterating through a const list
    class const_iterator {
    friend lst;        

    private:

        typedef const_iterator self;
        const node* pNode;
        const_iterator( const node* pN ) : pNode( pN ) { ; }

    public:
        const_iterator( void ) : pNode( NULL ) { ; }
        ~const_iterator( void ) { ; }

        const_iterator( const self& r ) { *this = r; }
        
        const_iterator& operator=( const const_iterator& r ) { pNode = r . pNode; return *this;}
        bool operator==( const self& r ) const { return pNode == r . pNode; }
        operator!=( const self& r ) const { return pNode != r . pNode; }
        const_reference operator*() const { return pNode -> data; }

        self& operator++() { 
            pNode = pNode -> pNext;
            return *this;
        }
        
        self operator++( int ) { 
            self tmp = *this;
            ++*this;
            return tmp;
        }
        
        self& operator--() { 
            pNode = pNode -> pPrev;
            return *this;
        }
        
        self operator--(int) { 
            self tmp = *this;
            --*this;
            return tmp;
        }

    };


    // Data
    node*   m_pNode;
    size_t  m_nItems;

public: 
        // construction / destruction
    lst( void ) {
      empty_initialize();
    };

    lst( const self& rList ) { empty_initialize(); *this = rList; }
    ~lst( void ) { clear(); delete m_pNode; m_pNode = NULL; }

    bool operator==( const self& rList ) const {
        if( size() != rList . size() ) { return false; }

        self::const_iterator IThis = begin();
        self::const_iterator IThat = rList . begin();

        while( IThis != end() ) {
            if( !_FnEq( *IThis, *IThat ) ) {
                return false;
            }
            ++IThat;
            ++IThis;
         }

         return true;
    }        
    
        // Member Fns
    self& operator=( const self& rList ) {
        clear();
        insert( begin(), rList . begin(), rList . end() );
        return *this;
    }

    void empty_initialize( void ) {
      m_pNode = new node;
      m_pNode -> pNext = m_pNode;
      m_pNode -> pPrev = m_pNode;
      m_nItems = 0;
    }

    void clear( void ) {
      node* pCur = m_pNode -> pNext;
      while( pCur != m_pNode ) {
        node* pTmp = pCur;
        pCur = pCur -> pNext;
        --m_nItems;
        delete pTmp;
        pTmp = NULL;
      }
      m_pNode -> pNext = m_pNode;
      m_pNode -> pPrev = m_pNode;

    }

        // Return the size of the list
    size_t size( void ) const             { return m_nItems; }
    bool empty( void ) const              { return 0 == size(); }

        // Return an iterator to the position after the last element in the list
        // N.B. ---- Don't dereference end()!!!!!!
        // N.B. ---- end()++ is undefined!!!!!!
    iterator end( void )                  { return iterator( m_pNode ); }
    const_iterator end( void ) const      { return const_iterator( m_pNode ); }

        // Return an iterator to the position of the first element of the list
        // You may dereference begin()
    iterator begin( void )                { return iterator( m_pNode -> pNext ); }
    const_iterator begin( void ) const    { return const_iterator( m_pNode -> pNext ); }

        // Returns a reference to the first element in the list
    reference front( void )               { return *begin(); }
    const_reference front( void ) const   { return *begin(); }

        // Returns a reference to the last element in the list
    reference back( void )                { return *(--end()); }
    const_reference back( void ) const    { return *(--end()); }
    
        // add an object to the front of the list
    void push_front( const_reference x )  { insert(begin(), x); }

        // add an object to the end of the list
    void push_back( const_reference x )   { insert(end(), x); }

        // Insert an item before the item that position points to
    void insert( iterator position, const_reference r ) {
      node* pTmp = new node( position . pNode -> pPrev, position . pNode, r );
      ( position . pNode -> pPrev ) -> pNext = pTmp;
      position . pNode -> pPrev = pTmp;
      ++m_nItems;
    }

        // Insert items first through last to the list at position position
    void insert( iterator position, iterator first, iterator last ) {
        for ( ; first != last; ++first) {
            insert(position, *first);
        }
    }

        // Insert items first through last to the list at position position
    void insert( iterator position, const_iterator first, const_iterator last ) {
        for ( ; first != last; ++first) {
            insert(position, *first);
        }
    }

        // Pop the first element from the list
    void pop_front( void )              { erase(begin()); }
    

        // Pop the last element from the list
    void pop_back( void ) {
        iterator tmp = end();
        erase(--tmp);
    }

    
        // erase the item at position pos in the list
    void erase( iterator pos ) {
        ASSERT( pos != end() );
        ( pos . pNode -> pPrev ) -> pNext = pos . pNode -> pNext;
        ( pos . pNode -> pNext ) -> pPrev = pos . pNode -> pPrev;
        --m_nItems;
        delete pos . pNode;
        pos . pNode = NULL;
        
    }

       // erase the items in the range first through last
    void erase( iterator first, iterator last ) {
        while (first != last) erase(first++);
    }

  
    const_iterator find( const_reference x ) const {
        return find( begin(), end(), x );
    }

    iterator find( const_reference x ) {
        return find( begin(), end(), x );
    }

    iterator find( iterator first, iterator last, const_reference x ) {
        while( first != last ) {
            if( _FnEq(*first, x) ) {
                return first;
            }
            first++;
        }
        return end();
    }

    const_iterator find( const_iterator first, const_iterator last, const_reference x ) const {
        while( first != last ) {
            if( _FnEq(*first, x) ) {
                return first;
            }
            first++;
        }
        return end();
    }

};

template< class T, class F >
lst< T >::iterator find( lst< T >& rLst, F& f ) {
    lst< T >::iterator I = rLst . begin();
    while( rLst . end() != I ) {
        if( f( *I ) ) {
            return I;
        }
        ++I;
    }
    return I;
}

template< class T, class F >
void for_each( lst< T >& rLst, F& f ) {
    lst< T >::iterator I = rLst . begin();
    while( rLst . end() != I ) {
        f( *I );
        ++I;
    }
}

#endif //__lst_h__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\h\mtgset.h ===
//
// MTGSET.H
// Meeting Setting definitions and structures
//
// Copyright (c) Microsoft Copr., 1999-
//

#ifndef _MTGSET_H
#define _MTGSET_H


extern GUID g_csguidMeetingSettings;


//
// Remote permission flags NM 3.0
//
#define NM_PERMIT_OUTGOINGCALLS     0x00000001
#define NM_PERMIT_INCOMINGCALLS     0x00000002
#define NM_PERMIT_SENDAUDIO         0x00000004
#define NM_PERMIT_SENDVIDEO         0x00000008
#define NM_PERMIT_SENDFILES         0x00000010
#define NM_PERMIT_STARTCHAT         0x00000020
#define NM_PERMIT_STARTOLDWB        0x00000040  // WILL BE OBSOLETE IN A WHILE
#define NM_PERMIT_USEOLDWBATALL     0x00000080  // "", for RDS
#define NM_PERMIT_STARTWB           0x00000100
#define NM_PERMIT_SHARE             0x00000200
#define NM_PERMIT_STARTOTHERTOOLS   0x00000400

#define NM_PERMIT_ALL               0x000007FF

// This is the structure of the GUID_MTGSETTINGS data
typedef DWORD   NM30_MTG_PERMISSIONS;
                                  
#endif // ndef _MTGSET_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\h\nameres.h ===
//
// This is the header file for simple conference name resolution
//
//	Created:	ClausGi	11-02-95
//

#ifndef _NAME_RES_H
#define _NAME_RES_H

// These are provisional

#define NAMETYPE_UNKNOWN	0
#define	NAMETYPE_IP			1
#define	NAMETYPE_PSTN		2
#define	NAMETYPE_IPX		3
#define NAMETYPE_NDS		4
#define	NAMETYPE_ULS		5
#define NAMETYPE_NETBIOS	6
#define NAMETYPE_COMM		7
#define NAMETYPE_H323GTWY	8
#define NAMETYPE_RAS		9
#define NAMETYPE_ALIAS_ID   10
#define NAMETYPE_ALIAS_E164 11
#define	NAMETYPE_CALLTO		12

#define	NAMETYPE_DEFAULT	NAMETYPE_IP

#define	NUM_NAMETYPES		8

#define	MAX_UNRESOLVED_NAME	255
#define	MAX_RESOLVED_NAME	255
#define	MAX_DISPLAY_NAME	255

// These must correspond to above BUGBUG localize?
// These should not be used - check "Display Name" in the registry
//
// These are obsolete and not being used
#define	NAMESTRING_UNKNOWN	"Unknown"
#define	NAMESTRING_IP		"Network (IP)"
#define	NAMESTRING_PSTN		"Telephone Number"
#define	NAMESTRING_IPX		"Network (IPX)"
#define	NAMESTRING_NDS		"Network (NDS)"
#define	NAMESTRING_ISP		"Internet Name"
#define NAMESTRING_NETBIOS	"Network (NETBIOS)"

// Name resolution return codes:

#define	RN_SUCCESS				0	// valid return
#define	RN_FAIL					1	// general error return
#define	RN_NAMERES_NOT_INIT		2	// name service not initialized
#define	RN_XPORT_DISABLED		3	// requested transport disabled
#define	RN_XPORT_NOTFUNC		4	// requested transport not functioning
#define	RN_TOO_AMBIGUOUS		5	// the unknown name type was too ambiguous
#define	RN_POOR_MATCH			6	// best syntax match not good enough
#define	RN_NO_SYNTAX_MATCH		7	// didn't match syntax for any active xport
#define	RN_ERROR				8	// internal ("unexpected") error
#define	RN_LOOPBACK				9	// address is identified as own
#define	RN_PENDING				10	// return of async request
#define	RN_INVALID_PARAMETER	11	// error in function parameters
#define RN_NAMERES_BUSY			12	// Timed out on a mutex
#define RN_ASYNC				13	// Name resolution is async
#define RN_SERVER_SERVICE				14	// Specially designated for ULS (ILS_E_SERVER_SERVICE)

// Name resolution callstruct dwFlags fields

#define	RNF_ASYNC			0x00000001	// Specifies async resolution
#define	RNF_CANCEL			0x00000002	// Cancels all async resolution ops
#define	RNF_FIRSTMATCH		0x00000004

typedef DWORD (WINAPI * PRN_CALLBACK)(LPBYTE pRN_CS); //BUGBUG type

typedef struct tag_ResolveNameCallstruct {
			DWORD	IN	dwFlags;
			DWORD	IN OUT	dwAsyncId;
			DWORD	OUT dwAsyncError;
			PRN_CALLBACK pCallback;
			DWORD	IN OUT	dwNameType;
			TCHAR	IN	szName[MAX_UNRESOLVED_NAME+1];
			TCHAR	OUT	szResolvedName[MAX_RESOLVED_NAME+1];
			TCHAR	OUT	szDisplayName[MAX_DISPLAY_NAME+1];
} RN_CS, * PRN_CS;

// Functions:

extern DWORD WINAPI ResolveName2 (
			IN OUT PRN_CS	pRN_CS );

extern DWORD WINAPI ResolveName ( 
			IN LPCSTR szName,
			IN OUT LPDWORD lpdwNameType,
			OUT LPBYTE lpResult,
			IN OUT LPDWORD lpdwResult,
			OUT LPSTR lpszDisplayName,
			IN OUT LPDWORD lpdwDisplayName,
			OUT LPUINT puAsyncRequest);

extern BOOL InitializeNameServices(VOID);

extern VOID DeInitializeNameServices(VOID);

extern BOOL IsNameServiceInitialized(DWORD dwNameType);

#endif	//#ifndef _NAME_RES_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\h\mscnfapi.h ===
/*****************************************************************/ 
/**						 Microsoft Windows						**/
/**				Copyright (C) Microsoft Corp., 1995				**/
/*****************************************************************/ 

/*
 * mscnfapi.h
 *
 * This header file contains definitions for the Windows Conferencing API.
 */

#ifndef _MSCNFAPI_
#define _MSCNFAPI_

#ifdef __cplusplus
extern "C" {
#endif

/*
 * Registry key and value names.
 *
 * Under HKEY_LOCAL_MACHINE\<REGSTR_PATH_CONFERENCING>, the value
 * <REGSTR_VAL_APIPROVIDER> is a string value naming the DLL which
 * provides the Windows Conferencing API.  If this value is present,
 * the conferencing software is installed, and the application should
 * use LoadLibrary to load the specified DLL.  If the key or value is
 * not present, conferencing software is not installed and the
 * application should hide or disable any conferencing-related features.
 */

#define REGSTR_PATH_CONFERENCING	"Software\\Microsoft\\Conferencing"
#define REGSTR_VAL_APIPROVIDER		"API Provider"

/*
 * Error code definitions.
 */

typedef unsigned int CONFERR;

#define CONF_SUCCESS			ERROR_SUCCESS
#define CONF_MOREDATA			ERROR_MORE_DATA
#define CONF_INVALIDPARAM		ERROR_INVALID_PARAMETER
#define CONF_OOM				ERROR_NOT_ENOUGH_MEMORY
#define CONF_USERCANCELED		ERROR_CANCELLED
#define CONF_NOTSUPPORTED		ERROR_NOT_SUPPORTED
#define CONF_PERMISSIONDENIED	ERROR_ACCESS_DENIED

#define CONF_CUSTOM_ERROR_BASE	3000
#define CONF_APPCANCELLED		(CONF_CUSTOM_ERROR_BASE + 0)
#define CONF_ALREADYSHARED		(CONF_CUSTOM_ERROR_BASE + 1)
#define CONF_ALREADYUNSHARED	(CONF_CUSTOM_ERROR_BASE + 2)

/*
 * All conference management and application sharing APIs should be loaded
 * from the API provider DLL via GetProcAddress, by name.  The following
 * type definitions are provided to declare function pointers that will be
 * returned by GetProcAddress.
 */

/*
 * Conference Management APIs
 */

typedef HANDLE HCONFERENCE;

typedef CONFERR (WINAPI *pfnConferenceStart)(HWND hwndParent, HCONFERENCE *phConference, LPVOID pCallAddress);
typedef CONFERR (WINAPI *pfnConferenceEnumerate)(HCONFERENCE *pHandleArray, UINT *pcHandles);
typedef CONFERR (WINAPI *pfnConferenceGet)(HWND hwndParent, HCONFERENCE *pHandle);
typedef CONFERR (WINAPI *pfnConferenceGetGCCID)(HCONFERENCE hConference, WORD *pID);
typedef CONFERR (WINAPI *pfnConferenceGetName)(HCONFERENCE hConference, LPSTR pName, UINT *pcbName);
typedef CONFERR (WINAPI *pfnConferenceStop)(HWND hwndParent, HCONFERENCE hConference);

#define WM_CONFERENCESTATUS		0x0060

/*
 * Application Sharing APIs
 */

typedef BOOL (WINAPI *pfnIsWindowShared)(HWND hWnd, LPVOID pReserved);
typedef CONFERR (WINAPI *pfnShareWindow)(HWND hWnd, BOOL fShare, LPVOID pReserved);

#define WM_SHARINGSTATUS		0x0061

#define CONFN_SHAREQUERY			0
#define CONFN_SHARED				1
#define CONFN_SHARESTOPPED			2
#define CONFN_SHARESTOPQUERY		3
#define CONFN_CONFERENCESTART		4
#define CONFN_CONFERENCESTOPQUERY	5
#define CONFN_CONFERENCESTOPPED		6
#define CONFN_CONFERENCESTOPABORTED	7

#ifdef __cplusplus
};	/* extern "C" */
#endif

#endif	/* _MSCNFAPI_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\h\nmappletdispid.h ===
#ifndef __NmAppletDispID_h__
#define __NmAppletDispID_h__

#define DISPID_ONSTATECHANGED 1



#endif // __NmAppletDispID_h__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\h\nacguids.h ===
/*
 *  	File: nacguids.h
 *
 *      Defines protocol IDs, media types, capability object IDs used by 
 * 		NAC.DLL
 *
 *		Revision History:
 *
 *		09/18/96	mikev	created
 */

// {D2E97230-0C18-11d0-AD53-00AA004A80A3}
DEFINE_GUID(OID_CAP_ACM_TO_H323, 		// h323 capability resolver
0xd2e97230, 0xc18, 0x11d0, 0xad, 0x53, 0x0, 0xaa, 0x0, 0x4a, 0x80, 0xa3);

// {D2E97231-0C18-11d0-AD53-00AA004A80A3}
DEFINE_GUID(OID_CAP_ACM_TO_MSIA, 		// MSICCP capability resolver
0xd2e97231, 0xc18, 0x11d0, 0xad, 0x53, 0x0, 0xaa, 0x0, 0x4a, 0x80, 0xa3);

// {A4209190-14B4-11d0-AD55-00AA004A80A3}
DEFINE_GUID(PID_H323, 					// H.323 protocol ID
0xa4209190, 0x14b4, 0x11d0, 0xad, 0x55, 0x0, 0xaa, 0x0, 0x4a, 0x80, 0xa3);

// {8C85D5E0-22E2-11d0-AD58-00AA004A80A3}
DEFINE_GUID(MEDIA_TYPE_H323VIDEO, 		// media type Video
0x8c85d5e0, 0x22e2, 0x11d0, 0xad, 0x58, 0x0, 0xaa, 0x0, 0x4a, 0x80, 0xa3);

// {8C85D5E1-22E2-11d0-AD58-00AA004A80A3}
DEFINE_GUID(MEDIA_TYPE_H323AUDIO, 		// media type Audio
0x8c85d5e1, 0x22e2, 0x11d0, 0xad, 0x58, 0x0, 0xaa, 0x0, 0x4a, 0x80, 0xa3);

// {97ADE24E-E0EA-11d0-B2DD-00C04FD919C9}
DEFINE_GUID(MEDIA_TYPE_H323_T120, 		// T120 channel in H.323 session
0x97ade24e, 0xe0ea, 0x11d0, 0xb2, 0xdd, 0x0, 0xc0, 0x4f, 0xd9, 0x19, 0xc9);


//
// 	Interface ID's. 
//

// {FCD77356-EF58-11d1-B32B-00C04FD919C9}
DEFINE_GUID(IID_IH323CC, 
0xfcd77356, 0xef58, 0x11d1, 0xb3, 0x2b, 0x0, 0xc0, 0x4f, 0xd9, 0x19, 0xc9);

// {8AD05D94-6A49-11d0-B2A4-00C04FD919C9}
DEFINE_GUID(IID_INac, 
0x8ad05d94, 0x6a49, 0x11d0, 0xb2, 0xa4, 0x0, 0xc0, 0x4f, 0xd9, 0x19, 0xc9);

// {8AD05D95-6A49-11d0-B2A4-00C04FD919C9}
DEFINE_GUID(IID_IPhoneConnection, 
0x8ad05d95, 0x6a49, 0x11d0, 0xb2, 0xa4, 0x0, 0xc0, 0x4f, 0xd9, 0x19, 0xc9);

// {8AD05D96-6A49-11d0-B2A4-00C04FD919C9}
DEFINE_GUID(IID_ICommChannel, 
0x8ad05d96, 0x6a49, 0x11d0, 0xb2, 0xa4, 0x0, 0xc0, 0x4f, 0xd9, 0x19, 0xc9);

// {8AD05D97-6A49-11d0-B2A4-00C04FD919C9}
DEFINE_GUID(IID_IAppAudioCap, 
0x8ad05d97, 0x6a49, 0x11d0, 0xb2, 0xa4, 0x0, 0xc0, 0x4f, 0xd9, 0x19, 0xc9);

// {8AD05D98-6A49-11d0-B2A4-00C04FD919C9}
DEFINE_GUID(IID_IAppVidCap, 
0x8ad05d98, 0x6a49, 0x11d0, 0xb2, 0xa4, 0x0, 0xc0, 0x4f, 0xd9, 0x19, 0xc9);

// {8AD05D99-6A49-11d0-B2A4-00C04FD919C9}
DEFINE_GUID(IID_IDualPubCap, 
0x8ad05d99, 0x6a49, 0x11d0, 0xb2, 0xa4, 0x0, 0xc0, 0x4f, 0xd9, 0x19, 0xc9);

// {8AD05D9A-6A49-11d0-B2A4-00C04FD919C9}
DEFINE_GUID(IID_IVideoRender, 
0x8ad05d9a, 0x6a49, 0x11d0, 0xb2, 0xa4, 0x0, 0xc0, 0x4f, 0xd9, 0x19, 0xc9);

// {4F354BB4-8443-11d0-B2B0-00C04FD919C9}
DEFINE_GUID(IID_ICtrlCommChannel, 
0x4f354bb4, 0x8443, 0x11d0, 0xb2, 0xb0, 0x0, 0xc0, 0x4f, 0xd9, 0x19, 0xc9);

// {0230C3D4-8E75-11d0-B2B2-00C04FD919C9}
DEFINE_GUID(IID_IConfAdvise, 
0x230c3d4, 0x8e75, 0x11d0, 0xb2, 0xb2, 0x0, 0xc0, 0x4f, 0xd9, 0x19, 0xc9);

// {50E94A04-6C42-11d1-B311-00C04FD919C9}
DEFINE_GUID(IID_IH323ConfAdvise, 
0x50e94a04, 0x6c42, 0x11d1, 0xb3, 0x11, 0x0, 0xc0, 0x4f, 0xd9, 0x19, 0xc9);

// {50E94A05-6C42-11d1-B311-00C04FD919C9}
DEFINE_GUID(IID_IMediaChannelBuilder, 
0x50e94a05, 0x6c42, 0x11d1, 0xb3, 0x11, 0x0, 0xc0, 0x4f, 0xd9, 0x19, 0xc9);

DEFINE_GUID(IID_IMediaChannel,
0x06f87f70, 0x793e, 0x11d0, 0x8e, 0xf0, 0x0, 0xa0, 0xc9, 0x05, 0x41, 0xf4);

DEFINE_GUID(IID_IAudioChannel,
0xd92d5d30, 0xe78e, 0x11d1, 0xa9, 0x76, 0x0, 0xc0, 0x4f, 0xd9, 0x1a, 0x6f);

DEFINE_GUID(IID_IVideoChannel,
0x138889f0, 0xee9d, 0x11d1, 0xa9, 0x7d, 0x0, 0xc0, 0x4f, 0xd9, 0x1a, 0x6f);


// {11A5FA28-C8C6-11d1-B320-00C04FD919C9}
DEFINE_GUID(IID_IH323MediaCap, 
0x11a5fa28, 0xc8c6, 0x11d1, 0xb3, 0x20, 0x0, 0xc0, 0x4f, 0xd9, 0x19, 0xc9);

// {C3DD8828-1A97-11d2-B331-00C04FD919C9}
DEFINE_GUID(IID_IStreamSignal, 
0xc3dd8828, 0x1a97, 0x11d2, 0xb3, 0x31, 0x0, 0xc0, 0x4f, 0xd9, 0x19, 0xc9);


// The naming convention is not followed for the following because the interface
// name (IProperty) will probably collide with something else.  This interface is
// a specific pseudo property interface that has very specific media control 
// properties. 
// {8AD05D9B-6A49-11d0-B2A4-00C04FD919C9}
DEFINE_GUID(IID_IAudioPseudoProperty, 
0x8ad05d9b, 0x6a49, 0x11d0, 0xb2, 0xa4, 0x0, 0xc0, 0x4f, 0xd9, 0x19, 0xc9);

DEFINE_GUID(IID_IVideoDevice,
0xe040ad20, 0xf5a2, 0x11d1, 0xa9, 0x7f, 0x0, 0xc0, 0x4f, 0xd9, 0x1a, 0x6f);

// e9604a60-f691-11d1-a97f-00c04fd91a6f 
DEFINE_GUID(IID_IAudioDevice,
0xe9604a60, 0xf691, 0x11d1, 0xa9, 0x7f, 0x0, 0xc0, 0x4f, 0xd9, 0x1a, 0x6f);


DEFINE_GUID(IID_IMixer,
0x142e1ff0, 0xf692, 0x11d1, 0xa9, 0x7f, 0x0, 0xc0, 0x4f, 0xd9, 0x1a, 0x6f);


DEFINE_GUID(IID_IDTMFSend,
0x2e29f4c0, 0x93f4, 0x11d2, 0xa9, 0xbe, 0x0, 0xc0, 0x4f, 0xd9, 0x1a, 0x6f);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\h\nameserv.h ===
/*
 -  nameres.h
 -
 *      Microsoft Internet Phone user interface
 *		Name Resolution exported header
 *
 *		Revision History:
 *
 *		When		Who					What
 *		--------	------------------  ---------------------------------------
 *		11.25.95	Yoram Yaacovi		Created
 *					Sunita				Added name service functions and ipa macros
 */

#ifndef _NAMERES_H
#define _NAMERES_H

#ifdef __cplusplus
extern "C" {
#endif

//definitions
//external
#define BY_HOST_NAME				1
#define	BY_USER_NAME				2

#define MPNS_PROMPT					0x0001
#define MPNS_SHOWDIR				0x0002
#define MPNS_RETURNHTML				0x0004
#define MPNS_GETADDR				0x0008
#define MPNS_SAVE					0x0010
#define MPNS_GETDETAILS				0x0020
#define MPNS_ALLOWSAVE				0x0040

//internal
#define MAXSERVERNAMELEN			256
#define MAXIPAFILESIZE				4096
#define MAXSERVERDLLNAMELEN			256
#define MAXIPALINELEN				512
#define MAXREGISTEREDNAMELEN		256
#define MAXIPAACTIONLEN				16
#define MAXIPAPAIRSPERLINE			3
#define MAXIPARESULTLEN				64
#define MAXSEARCHEXPLEN				256
#define MAXDIRECTORYLEN				1000
#define MAX_IP_ADDRESS_STRING_SIZE	16
#define LITTLE_STRING_BUFFER_SIZE	8
#define	MAXUSERINFOSIZE				MAXREGISTEREDNAMELEN

// version defines.

#define CURRENT_CLIENT_VERSION		"0001"

// keep-alive periods.

#define CLIENT_KEEP_ALIVE_PERIOD	20000	// 20 seconds.
#define SERVER_KEEP_ALIVE_PERIOD	30000	// 30 seconds.
#define LOWER_TIME_LIMIT			1000	// 1 second.
#define UPPER_TIME_LIMIT			900000	// 15 minutes.
	
//for now we just call in char
#ifdef UNICODE
typedef TCHAR	REGISTEREDNAME[MAXREGISTEREDNAMELEN];
#else
typedef char	REGISTEREDNAME[MAXREGISTEREDNAMELEN*2];
#endif //!UNICODE

#ifdef UNICODE
typedef struct USERDETAILS{
	REGISTEREDNAME	szRegName;
	TCHAR			szFullName[MAXUSERINFOSIZE];
	TCHAR			szLocation[MAXUSERINFOSIZE];
	TCHAR			szHostName[MAXUSERINFOSIZE];
	TCHAR			szEmailName[MAXUSERINFOSIZE];
	TCHAR			szHomePage[MAXUSERINFOSIZE];
	TCHAR			szComments[MAXUSERINFOSIZE];
}USERDETAILS, *PUSERDETAILS;
#else
typedef struct USERDETAILS{
	REGISTEREDNAME	szRegName;
	char			szFullName[MAXUSERINFOSIZE*2];
	char			szLocation[MAXUSERINFOSIZE*2];
	char			szHostName[MAXUSERINFOSIZE*2];
	char			szEmailName[MAXUSERINFOSIZE*2];
	char			szHomePage[MAXUSERINFOSIZE*2];
	char			szComments[MAXUSERINFOSIZE*2];
}USERDETAILS, *PUSERDETAILS;
#endif

typedef struct _CALLEE_ID
{
	REGISTEREDNAME	strCalleeName;
	TCHAR			strIPAddress[MAX_IP_ADDRESS_STRING_SIZE + 1];
	TCHAR			strPort[LITTLE_STRING_BUFFER_SIZE + 1];
	TCHAR			strAppName[MAX_PATH + 1];
	TCHAR			strGUID[LITTLE_STRING_BUFFER_SIZE + 1];
}CALLEE_ID;
typedef CALLEE_ID *PCALLEE_ID;

//typedef REGISTEREDNAME *PREGISTEREDNAME,*LPREGISTEREDNAME;

typedef struct _SEARCHCRITERIA{
	WORD	cbStruct;		//size of the struct

}SEARCHCRITERIA;

typedef SEARCHCRITERIA *pSEARCHCRITERIA,*LPSEARCHCRITERIA;


#pragma warning (disable : 4200)
typedef struct _NAMEDIR{
	DWORD				cbStruct;		//size of the struct
	DWORD				dwNumEntries;	//number of entries in the directory
	REGISTEREDNAME		RegNames[];		//pointer to an array of registerednames
}NAMEDIR,*PNAMEDIR,*LPNAMEDIR;
#pragma warning (default : 4200)


typedef DWORD	HNSSESSION;

#define TOKENBEGINCHAR		'<'
#define TOKENENDCHAR		'>'
#define HEADSTARTSTR		"HEAD"
#define HEADENDSTR			"/HEAD"
#define URL_SPACE_CHARACTER	'.'

//exported functions

typedef HNSSESSION (WINAPI *NAMESERVICEINITIALIZE)(HWND,LPTSTR);
typedef BOOL (WINAPI *NAMESERVICEDEINITIALIZE)(HNSSESSION);
typedef BOOL (WINAPI *NAMESERVICEREGISTER)(HNSSESSION, HWND,LPTSTR);
typedef BOOL (WINAPI *NAMESERVICEUNREGISTER)(HNSSESSION,LPTSTR);
typedef BOOL (WINAPI *NAMESERVICERESOLVE)(HNSSESSION, LPTSTR, DWORD, CALLEE_ID *);
typedef BOOL (WINAPI *NAMESERVICEGETDIRECTORY)(HNSSESSION, HWND, LPSEARCHCRITERIA,
											   DWORD, LPNAMEDIR *,LPTSTR, PCALLEE_ID);
typedef BOOL (WINAPI *NAMESERVICELOGON)(HNSSESSION, LPTSTR, LPTSTR, LPTSTR,
										LPTSTR, LPTSTR, LPTSTR, LPTSTR, 
										LPTSTR, LPTSTR);
typedef BOOL (WINAPI *NAMESERVICELOGOFF)(HNSSESSION, LPTSTR);
typedef BOOL (WINAPI *CALLEEIDFROMIPABUF)(LPBYTE, DWORD, PCALLEE_ID);
typedef void (WINAPI *NAMESERVICEFREEMEM)(LPVOID);
typedef BOOL (WINAPI *NAMESERVICEUSERDETAILS)(HWND, DWORD, PUSERDETAILS);

//exported function prototypes

extern BOOL WINAPI DllMain(HINSTANCE, DWORD, LPVOID);
extern HNSSESSION WINAPI NameServiceInitialize(HWND, LPTSTR);
extern BOOL WINAPI NameServiceDeinitialize(HNSSESSION);
extern BOOL WINAPI NameServiceRegister(HNSSESSION, HWND, LPTSTR);
extern BOOL WINAPI NameServiceUnregister(HNSSESSION, LPTSTR);
extern BOOL WINAPI NameServiceLogon(HNSSESSION, LPTSTR, LPTSTR, LPTSTR, LPTSTR,
									LPTSTR, LPTSTR, LPTSTR, LPTSTR, LPTSTR);
extern BOOL WINAPI NameServiceLogoff(HNSSESSION, LPTSTR);
extern BOOL WINAPI NameServiceResolve(HNSSESSION, LPTSTR, DWORD, CALLEE_ID *);
extern BOOL WINAPI NameServiceGetDirectory(HNSSESSION, HWND, LPSEARCHCRITERIA, 
									DWORD, LPNAMEDIR *, LPTSTR, PCALLEE_ID);
extern BOOL WINAPI NameServiceUserDetails(HWND, DWORD, PUSERDETAILS);
extern BOOL WINAPI CalleeIdFromIpaBuf(LPBYTE, DWORD, PCALLEE_ID);
extern void WINAPI NameServiceFreeMem(LPVOID);

#ifdef __cplusplus
}
#endif


#endif	//#ifndef _NAMERES_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\h\netmeetingcp.h ===
#ifndef _NETMEETINGCP_H_
#define _NETMEETINGCP_H_
#include <NmDispid.h>
template <class T>
class CProxy_INetMeetingEvents : public IConnectionPointImpl<T, &DIID__INetMeetingEvents, CComDynamicUnkArray>
{
	//Warning this class may be recreated by the wizard.
public:
	VOID Fire_ConferenceStarted()
	{
		T* pT = static_cast<T*>(this);
		int nConnectionIndex;
		int nConnections = m_vec.GetSize();
		
		for (nConnectionIndex = 0; nConnectionIndex < nConnections; nConnectionIndex++)
		{
			pT->Lock();
			CComPtr<IUnknown> sp = m_vec.GetAt(nConnectionIndex);
			pT->Unlock();
			IDispatch* pDispatch = reinterpret_cast<IDispatch*>(sp.p);
			if (pDispatch != NULL)
			{
				DISPPARAMS disp = { NULL, NULL, 0, 0 };
				pDispatch->Invoke(DISPID_ConferenceStarted, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, NULL, NULL, NULL);
			}
		}
	
	}
	VOID Fire_ConferenceEnded()
	{
		T* pT = static_cast<T*>(this);
		int nConnectionIndex;
		int nConnections = m_vec.GetSize();
		
		for (nConnectionIndex = 0; nConnectionIndex < nConnections; nConnectionIndex++)
		{
			pT->Lock();
			CComPtr<IUnknown> sp = m_vec.GetAt(nConnectionIndex);
			pT->Unlock();
			IDispatch* pDispatch = reinterpret_cast<IDispatch*>(sp.p);
			if (pDispatch != NULL)
			{
				DISPPARAMS disp = { NULL, NULL, 0, 0 };
				pDispatch->Invoke(DISPID_ConferenceEnded, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, NULL, NULL, NULL);
			}
		}
	}
};
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\h\nmasn1.h ===
/* Copyright (C) Boris Nikolaus, Germany, 1996-1997. All rights reserved. */
/* Copyright (C) Microsoft Corporation 1997-1998, All rights reserved. */

#ifndef __NM_ASN1_H__
#define __NM_ASN1_H__

#include <msper.h>

#endif // __NM_ASN1_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\h\nmapptyp.h ===
#if ! defined(_NM_APPLET_TYPE_H_) && ! defined(__iapplet_h__)
#define _NM_APPLET_TYPE_H_

//
// GCC/MCS Base Types
//

typedef USHORT          AppletSessionID;
typedef USHORT          AppletChannelID;
typedef AppletChannelID AppletUserID;
typedef AppletUserID    AppletNodeID;
typedef USHORT          AppletTokenID;
typedef USHORT          AppletEntityID;

typedef ULONG_PTR        AppletConfID;

typedef UINT            AppletRequestTag;


//
// GCC Registry
//

typedef enum tagAppletRegistryCommand
{
    APPLET_REGISTER_CHANNEL  = 0,
    APPLET_ASSIGN_TOKEN      = 1,
    APPLET_SET_PARAMETER     = 2,
    APPLET_RETRIEVE_ENTRY    = 3,
    APPLET_DELETE_ENTRY      = 4,
    APPLET_ALLOCATE_HANDLE   = 5,
    APPLET_MONITOR           = 6, // nyi in SDK
}
    AppletRegistryCommand;


typedef enum tagAppletRegistryItemType
{
    APPLET_REGISTRY_CHANNEL_ID  = 1,
    APPLET_REGISTRY_TOKEN_ID    = 2,
    APPLET_REGISTRY_PARAMETER   = 3,
    APPLET_REGISTRY_NONE        = 4,
}
    AppletRegistryItemType;


typedef enum tagAppletModificationRights
{
    APPLET_OWNER_RIGHTS                     = 0,
    APPLET_SESSION_RIGHTS                   = 1,
    APPLET_PUBLIC_RIGHTS                    = 2,
    APPLET_NO_MODIFICATION_RIGHTS_SPECIFIED = 3,
}
    AppletModificationRights;


//
// MCS Channel
//

typedef enum tagAppletChannelCommand
{
    APPLET_JOIN_CHANNEL         = 0,
    APPLET_LEAVE_CHANNEL        = 1,
    APPLET_CONVENE_CHANNEL      = 2,
    APPLET_DISBAND_CHANNEL      = 3,
    APPLET_ADMIT_CHANNEL        = 4,
    APPLET_EXPEL_CHANNEL        = 5,	// indication only
}
    AppletChannelCommand;


typedef enum tagAppletChannelType
{
    APPLET_STATIC_CHANNEL               = 0,
    APPLET_DYNAMIC_MULTICAST_CHANNEL    = 1,
    APPLET_DYNAMIC_PRIVATE_CHANNEL      = 2,
    APPLET_DYNAMIC_USER_ID_CHANNEL      = 3,
    APPLET_NO_CHANNEL_TYPE_SPECIFIED    = 4
}
    AppletChannelType;


//
// MCS Token
//

typedef enum tagAppletTokenCommand
{
    APPLET_GRAB_TOKEN          = 0,
    APPLET_INHIBIT_TOKEN       = 1,
    APPLET_GIVE_TOKEN          = 2,
    APPLET_PLEASE_TOKEN        = 3,
    APPLET_RELEASE_TOKEN       = 4,
    APPLET_TEST_TOKEN          = 5,
    APPLET_GIVE_TOKEN_RESPONSE = 6,
}
    AppletTokenCommand;


typedef enum tagAppletTokenStatus
{
    APPLET_TOKEN_NOT_IN_USE         = 0,
    APPLET_TOKEN_SELF_GRABBED       = 1,
    APPLET_TOKEN_OTHER_GRABBED      = 2,
    APPLET_TOKEN_SELF_INHIBITED     = 3,
    APPLET_TOKEN_OTHER_INHIBITED    = 4,
    APPLET_TOKEN_SELF_RECIPIENT     = 5,
    APPLET_TOKEN_SELF_GIVING        = 6,
    APPLET_TOKEN_OTHER_GIVING       = 7,
}
    AppletTokenStatus;


//
// GCC Capability
//

typedef enum tagAppletCapabilityType
{
    APPLET_UNKNOWN_CAP_TYPE             = 0, // for non-collapsing caps
    APPLET_LOGICAL_CAPABILITY           = 1,
    APPLET_UNSIGNED_MINIMUM_CAPABILITY  = 2,
    APPLET_UNSIGNED_MAXIMUM_CAPABILITY  = 3,
}
    AppletCapabilityType;


typedef struct tagAppletCapabilityClass
{
    AppletCapabilityType    eType;
    ULONG                   nMinOrMax;
}
    AppletCapabilityClass;


typedef enum tagAppletCapIDType
{
	APPLET_STANDARD_CAPABILITY  = 0,
	APPLET_NONSTD_CAPABILITY	= 1,
}
    AppletCapIDType;


//
// GCC/MCS Resource Allocation Command
//

typedef enum tagAppletResourceAllocCommand
{
    APPLET_JOIN_DYNAMIC_CHANNEL     = 0, // compete among all members
    APPLET_GRAB_TOKEN_REQUEST		= 1, // nyi in SDK
}
    AppletResourceAllocCommand;

//
// Send Data
//

typedef enum tagAppletPriority
{
    APPLET_TOP_PRIORITY     = 0,
    APPLET_HIGH_PRIORITY    = 1,
    APPLET_MEDIUM_PRIORITY  = 2,
    APPLET_LOW_PRIORITY     = 3,
}
    AppletPriority;


//
// Key Type
//

typedef enum tagAppletKeyType
{
	APPLET_OBJECT_KEY		= 1,
	APPLET_H221_NONSTD_KEY	= 2,
}
	AppletKeyType;


//
// Error Code
//

enum tagAppletErrorCode
{
    APPLET_E_NO_SERVICE       		= 0x82000001,
    APPLET_E_SERVICE_FAIL      		= 0x82000002,
    APPLET_E_ALREADY_REGISTERED  	= 0x82000003,
    APPLET_E_NOT_REGISTERED      	= 0x82000004,
    APPLET_E_INVALID_CONFERENCE  	= 0x82000005,
    APPLET_E_INVALID_COOKIE      	= 0x82000006,
    APPLET_E_ALREADY_JOIN        	= 0x82000007,
    APPLET_E_NOT_JOINED          	= 0x82000008,
    APPLET_E_INVALID_JOIN_REQUEST	= 0x82000009,
    APPLET_E_ENTRY_ALREADY_EXISTS   = 0x8200000a,
    APPLET_E_ENTRY_DOES_NOT_EXIST   = 0x8200000b,
    APPLET_E_NOT_OWNER              = 0x8200000c,
    APPLET_E_NOT_ADVISED            = 0x8200000d,
    APPLET_E_ALREADY_ADVISED        = 0x8200000e,
};


//
// Reason Code
//

typedef enum tagAppletReason
{
    APPLET_R_UNSPECIFIED            = 0,
    APPLET_R_CONFERENCE_GONE        = 1,
    APPLET_R_USER_REJECTED          = 2,
    APPLET_R_RESOURCE_PURGED        = 3,
}
    AppletReason;


#endif // _NM_APPLET_BASE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\h\nmctl1dispid.h ===
#ifndef __NmCtl1DispId_h__
#define __NmCtl1DispId_h__

#define DISPID_BASE                                 100
#define DISPID_PROPERTY_TYPE                        (1 + DISPID_BASE)
#define DISPID_PROPERTY_NAME                        (2 + DISPID_BASE)
#define DISPID_PROPERTY_URL                         (3 + DISPID_BASE)
#define DISPID_PROPERTY_DESCRIPTION                 (4 + DISPID_BASE)
#define DISPID_PROPERTY_RESOLUTION                  (5 + DISPID_BASE)
#define DISPID_PROPERTY_ISRESOLVED                  (6 + DISPID_BASE)
#define DISPID_PROPERTY_PRESENTOR                   (7 + DISPID_BASE)
#define DISPID_PROPERTY_CALLTO_PARTICIPANT_NAME     (8 + DISPID_BASE)
#define DISPID_PROPERTY_WBFILE_NAME                 (9 + DISPID_BASE)
#define DISPID_PROPERTY_SENDFILE_NAME               (10 + DISPID_BASE)
#define DISPID_PROPERTY_CHATMSG_DESTINATION         (11 + DISPID_BASE)
#define DISPID_PROPERTY_CHATMSG_TEXT                (12 + DISPID_BASE)
#define DISPID_PROPERTY_ACTIONTYPE                  (14 + DISPID_BASE)    
#define DISPID_PROPERTY_ASSIGNEDTO                  (15 + DISPID_BASE)    
#define DISPID_PROPERTY_FILENAME                    (16 + DISPID_BASE)    
#define DISPID_PROPERTY_CHILDREN                    (17 + DISPID_BASE)


#endif // __NmCtl1DispId_h__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\h\nmappletimpl.h ===
#ifndef __NmAppletImpl_h__
#define __NmAppletImpl_h__


#define DECLARE_NMAPPLET_CAPS(dwCaps)\
    static DWORD _GetNmAppletCaps()\
    {\
        return dwCaps;\
    }

#define DECLARE_NMAPPLET_FILE_OPEN_FILTER(idStringResourceFilter, idStringResourceExt) \
    static HRESULT _GetNmAppletFileOpenFilter( LPTSTR szFilter, int cchMaxFilter, LPTSTR szExtension, int cchMaxExtension )\
    {	HRESULT hr = S_OK;\
		DBGENTRY(_GetNmAppletFileOpenFilter);\
		if( SUCCEEDED( hr = NmCtlLoadString( idStringResourceFilter, szFilter, cchMaxFilter ) ) )\
		{\
			hr = NmCtlLoadString( idStringResourceExt, szExtension, cchMaxExtension );\
		}\
		DBGEXIT_HR(_GetNmAppletFileOpenFilter,hr);\
        return hr;\
    }

template <class T>
class ATL_NO_VTABLE INmAppletImpl
{
// YOU MUST ONLY PUT DATA MEMBERS OR HELPER FNS AT THE END OF THE CLASS
// THE VTABLE FOR INmAgendaItemView MUST BE AT THE BEGINNING OF THE CLASS!!!!

public:
    INmAppletImpl( void )
    : m_bInsertFileMenuIntoEditGroup( false )
     { 
        DBGENTRY(INmAppletImpl::INmAppletImpl);
        DBGEXIT(INmAppletImpl::INmAppletImpl);
     }
    ~INmAppletImpl( void ) 
    { 
        DBGENTRY(INmAppletImpl::~INmAppletImpl);
        DBGEXIT(INmAppletImpl::~INmAppletImpl);
    }

public:

	// IUnknown
	//
	STDMETHOD(QueryInterface)(REFIID riid, void ** ppvObject) = 0;
	_ATL_DEBUG_ADDREF_RELEASE_IMPL(INmAppletImpl)


        // The INmApplet Interface...
    STDMETHOD(get_NmAppletCaps)( OUT DWORD* pdwCaps )
    {
        DBGENTRY(INmAppletImpl::get_NmAppletCaps)
        HRESULT hr = S_OK;

        ASSERT( pdwCaps != NULL );

        *pdwCaps = T::_GetNmAppletCaps();

        DBGEXIT_HR(INmAppletImpl::get_NmAppletCaps ,hr)
        return hr;
    }

    STDMETHOD(SaveDialog)( /*[in, out, retval]*/ LPTSTR lpszFile, /*[in]*/ DWORD dwFlags, /*[out]*/ LPWORD pnFileOffset )
    {
        DBGENTRY(INmAppletImpl::SaveDialog)
        HRESULT hr = S_OK;

        T* pT = static_cast<T*>(this);
   
        TCHAR szFilter[MAX_PATH];
		TCHAR szDefExt[MAX_PATH];
        
        if( SUCCEEDED ( hr = T::_GetNmAppletFileOpenFilter( szFilter, CCHMAX( szFilter ), szDefExt, CCHMAX( szDefExt ) ) ) )
        {
            ConvertSzCh(szFilter);

            OPENFILENAME ofn;
            ClearStruct( &ofn );
            ofn.lStructSize = sizeof( OPENFILENAME );
            ofn.hwndOwner = pT->m_hWnd;
            ofn.lpstrFilter = szFilter;
			ofn.lpstrFile = lpszFile;
            ofn.nMaxFile = MAX_PATH;
			ofn.lpstrDefExt = szDefExt;
            ofn.Flags = dwFlags;
            if( !GetSaveFileName( &ofn ) )
			{
				hr = E_FAIL;
			}
			else
			{
				*pnFileOffset = ofn.nFileOffset;
			}
        }

        DBGEXIT_HR(INmAppletImpl::SaveDialog,hr)
        return hr;
    }


    STDMETHOD(OpenDialog)()
    {
        DBGENTRY(INmAppletImpl::OpenDialog)

        HRESULT hr = E_NOTIMPL;

        DBGEXIT_HR(INmAppletImpl::OpenDialog,hr)
        return hr;
    }


    STDMETHOD(GetIconBitmaps)( IN int cxBitmap, IN int cyBitmap,
                               OUT int*	   pcStates,
							   OUT HBITMAP** pphBitmapIcon,
							   OUT HBITMAP** pphBitmapIconHot,
							   OUT HBITMAP** pphBitmapIconDisabled
							  )

    {
        DBGENTRY(INmAppletImpl::GetIconBitmaps)

        HRESULT hr = E_NOTIMPL;

        DBGEXIT_HR(INmAppletImpl::GetIconBitmaps,hr)
        return hr;
    }

    STDMETHOD(GetIconLabel)( OUT BSTR* pLabel )
    {

        DBGENTRY(INmAppletImpl::GetIconLabel)

        HRESULT hr = E_NOTIMPL;

        DBGEXIT_HR(INmAppletImpl::GetIconLabel,hr)
        return hr;
    }

    STDMETHOD(OnContainerActivating)( IN BOOL bAppActivating )
    {
        DBGENTRY(INmAppletImpl::OnContainerActivating)

        HRESULT hr = S_OK;

        DBGEXIT_HR(INmAppletImpl::OnContainerActivating,hr)
        return hr;
    }

    STDMETHOD(SetFocus)()
    {
        DBGENTRY(INmAppletImpl::SetFocus)

        HRESULT hr = S_OK;

        DBGEXIT_HR(INmAppletImpl::SetFocus,hr)
        return hr;
    }

    STDMETHOD(SetClientSite)( IN INmAppletClientSite* pClientSite )
    {
        DBGENTRY(INmAppletImpl::SetClientSite);
        HRESULT hr = S_OK;

        m_spContianerAppletSite = pClientSite;

        DBGEXIT_HR(INmAppletImpl::SetClientSite,hr);
        return hr;
    }

	STDMETHOD(ShiftFocus)( IN HWND hWndCur, BOOL bForward )
	{
        DBGENTRY(INmAppletImpl::ShiftFocus);
        HRESULT hr = S_OK;

        DBGEXIT_HR(INmAppletImpl::ShiftFocus,hr);
        return hr;
	}

	STDMETHOD(IsChild)( IN HWND hWnd )
	{
        DBGENTRY(INmAppletImpl::IsChild);

        HRESULT hr = S_FALSE;

        DBGEXIT_HR(INmAppletImpl::IsChild,hr);
        return hr;
	}

	STDMETHOD(QueryEndSession)( OUT BOOL* pbCancelTermination )
	{
		DBGENTRY(INmAppletImpl::QueryEndSession);
		HRESULT hr = S_OK;
		if( pbCancelTermination )
		{
			*pbCancelTermination = FALSE;
		}
		else
		{
			hr = E_POINTER;
		}

		DBGEXIT_HR(INmAppletImpl::QueryEndSession,hr);
		return hr;
	}

	STDMETHOD(OnMenuSelect)( IN DWORD wParam, IN DWORD lParam )
	{
		DBGENTRY(INmAppletImpl::OnMenuSelect);
		HRESULT hr = S_OK;

		DBGEXIT_HR(INmAppletImpl::OnMenuSelect,hr);
		return hr;
	}

	STDMETHOD(OnCommand)( IN DWORD wParam, IN DWORD lParam )
	{
		DBGENTRY(INmAppletImpl::OnCommand);
		HRESULT hr = S_OK;

		DBGEXIT_HR(INmAppletImpl::OnCommand,hr);
		return hr;
	}

	STDMETHOD(OnGetMinMax)( IN DWORD lParam )
	{
		DBGENTRY(INmAppletImpl::OnGetMinMax);
		HRESULT hr = S_OK;

		DBGEXIT_HR(INmAppletImpl::OnGetMinMax,hr);
		return hr;
	}


    static DWORD _GetNmAppletCaps() { return 0; }

protected:
    // PUT data members here
    bool m_bInsertFileMenuIntoEditGroup;
    CComPtr<INmAppletClientSite> m_spContianerAppletSite;
};


static HRESULT _MoveMenuToSharedMenu( HMENU hMenu, HMENU hMenuShared, int MenuBarIndex, int InsertionIndex )
{
    DBGENTRY(MoveMenuToSharedMenu);
    HRESULT hr = S_OK;

    if( IsMenu( hMenu ) && IsMenu( hMenuShared ) )
    {
        TCHAR szMenuItem[ MAX_PATH ] = TEXT("");
        int cbMenuItem = 0;
    
        MENUITEMINFO mii;
        ClearStruct( &mii );
        mii.cbSize = sizeof(MENUITEMINFO);
        mii.fMask = MIIM_DATA | MIIM_SUBMENU | MIIM_TYPE;
        mii.fType = MFT_STRING;

        cbMenuItem = GetMenuString( hMenu, MenuBarIndex, szMenuItem, MAX_PATH, MF_BYPOSITION );
        if( 0 != cbMenuItem )
        {
            mii.cch = 1 + cbMenuItem;
            mii.dwTypeData = szMenuItem;
            mii.hSubMenu = GetSubMenu( hMenu, MenuBarIndex );
            
            RemoveMenu( hMenu, MenuBarIndex, MF_BYPOSITION );

            if( 0 == InsertMenuItem( hMenuShared, InsertionIndex, TRUE, &mii ) )
            {
                ERROR_OUT(("InsertMenuItem failed"));
                hr = HRESULT_FROM_WIN32(GetLastError());
            }
        }
        else
        {
            ERROR_OUT(("GetMenuString failed"));
            hr = E_FAIL;
        }
    }
    else
    {
        ERROR_OUT(("Passed a bad menu handle"));
        hr = E_HANDLE;
    }

    DBGEXIT_HR( MoveMenuToSharedMenu, hr );
    return hr;
}

inline STDMETHODIMP NmApplet_UIActivate(LONG iVerb, 
                                        const RECT* prcPosRect,
                                        CComControlBase* pThis,
                                        HMENU* phMenuShared, 
                                        DWORD dwMenuResourceID,
                                        int nEditGroupMenuBarItems,
                                        int nObjectGroupMenuBarItems,
                                        int nHelpGroupMenuBarItems
                                )
{
    
    DBGENTRY(Applet_UIActivate);
    HRESULT hr = S_OK;

    bool bPreviouslyActiveUI = pThis->m_bUIActive;
        // CComControlBase::InPlaceActivawe may change the state of m_bUIActive
        // which would indicate that we are UI activating for the first time...
    hr = pThis->InPlaceActivate( iVerb, NULL );

    if( SUCCEEDED( hr ) && (!bPreviouslyActiveUI) && pThis->m_bUIActive )
    {
        OLEINPLACEFRAMEINFO frameInfo;
	    RECT rcPos, rcClip;
	    CComPtr<IOleInPlaceFrame> spInPlaceFrame;
	    CComPtr<IOleInPlaceUIWindow> spInPlaceUIWindow;
        ClearStruct(&frameInfo);
	    frameInfo.cb = sizeof(OLEINPLACEFRAMEINFO);
	    
	    CComPtr<IOleInPlaceObject> pIPO;
	    pThis->ControlQueryInterface(IID_IOleInPlaceObject, (void**)&pIPO);
	    _ASSERTE(pIPO != NULL);
	    if (prcPosRect != NULL)
        {
		    pIPO->SetObjectRects(prcPosRect, prcPosRect);
        }


        if( pThis->m_spInPlaceSite )
        {
    	    hr = pThis->m_spInPlaceSite->GetWindowContext(&spInPlaceFrame, &spInPlaceUIWindow, &rcPos, &rcClip, &frameInfo);
            if( spInPlaceFrame )
            {

                // Create the shared menu...
                *phMenuShared = ::CreateMenu();        
                if( NULL != *phMenuShared )
                {

                    OLEMENUGROUPWIDTHS mgw;
                    ClearStruct( &mgw );
        
                    if( SUCCEEDED( hr = spInPlaceFrame->InsertMenus(*phMenuShared, &mgw) ) )
                    {
                        HMENU hMenu = LoadMenu( _Module.GetModuleInstance(), MAKEINTRESOURCE( dwMenuResourceID ) );
                        if( hMenu )
                        {
                            int InsertionIndex, i;

                             // Edit Group                                
                            InsertionIndex = mgw.width[0];
                            for( i = 0; i < nEditGroupMenuBarItems; i++ )
                            {
                                _MoveMenuToSharedMenu( hMenu, *phMenuShared, 0, InsertionIndex + i );
                            }
                            mgw.width[1] = nEditGroupMenuBarItems;

                            // Object Group   
							
                            InsertionIndex = mgw.width[0] + mgw.width[1] + mgw.width[2];
                            for( i = 0; i < nObjectGroupMenuBarItems; i++ )
                            {
                                _MoveMenuToSharedMenu( hMenu, *phMenuShared, 0, InsertionIndex + i );
                            }
                            mgw.width[3] = nObjectGroupMenuBarItems; // Object Group
							

                            // Help Group
							
                            InsertionIndex = mgw.width[0] + mgw.width[1] + mgw.width[2] + mgw.width[3] + mgw.width[4];
                            for( i = 0; i < nHelpGroupMenuBarItems; i++ )
                            {
                                _MoveMenuToSharedMenu( hMenu, *phMenuShared, 0, InsertionIndex + i );
                            }
                            mgw.width[5] = nHelpGroupMenuBarItems; // Help Group
							

                            HOLEMENU hOLEMENU = OleCreateMenuDescriptor( *phMenuShared, &mgw );
                            if( hOLEMENU )
                            {
                                hr = spInPlaceFrame->SetMenu( *phMenuShared, hOLEMENU, pThis->m_hWndCD );
                            }
                            else
                            {
                                hr = E_OUTOFMEMORY;
                            }

                            DestroyMenu(hMenu);

                        }
                        else
                        {
                            hr = HRESULT_FROM_WIN32(GetLastError());
                        }
                    }
                    else
                    {
                        DestroyMenu( *phMenuShared );
                        *phMenuShared = NULL;
                    }
                }
                else
                {
                    hr = HRESULT_FROM_WIN32(GetLastError());
                    ERROR_OUT(("Could not create menu..."));
                }
            }
        }
        else
        {
            hr = E_UNEXPECTED;
        }
    }
    
    DBGEXIT_HR(Applet_UIActivate,hr);

    return hr;

}




#endif // __NmAppletImpl_h__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\h\nmevtmsg.h ===
/* Copyright (C) 1993-1998  Microsoft Corporation.  All Rights Reserved.

    MODULE: nmevtmsg.mc

    AUTHOR: xin liu

    This file contains the message definition for the Remote Desktop Sharing 
    service program.
 */
//
//  Values are 32 bit values layed out as follows:
//
//   3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
//   1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
//  +---+-+-+-----------------------+-------------------------------+
//  |Sev|C|R|     Facility          |               Code            |
//  +---+-+-+-----------------------+-------------------------------+
//
//  where
//
//      Sev - is the severity code
//
//          00 - Success
//          01 - Informational
//          10 - Warning
//          11 - Error
//
//      C - is the Customer code flag
//
//      R - is a reserved bit
//
//      Facility - is the facility code
//
//      Code - is the facility's status code
//
//
// Define the facility codes
//


//
// Define the severity codes
//


//
// MessageId: MSG_ERR_SERVICE
//
// MessageText:
//
//  Service Error in %1
//
#define MSG_ERR_SERVICE                  0xC0000001L

//
// MessageId: MSG_INF_START
//
// MessageText:
//
//  NetMeeting RDS Service Start
//
#define MSG_INF_START                    0x40000010L

//
// MessageId: MSG_INF_STOP
//
// MessageText:
//
//  NetMeeting RDS Service Stop
//
#define MSG_INF_STOP                     0x40000011L

//
// MessageId: MSG_INF_ACCESS
//
// MessageText:
//
//  NetMeeting RDS Service is called from %1
//
#define MSG_INF_ACCESS                   0x40000012L
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\h\nmdispid.h ===
#ifndef _NMDISPID_H_
#define _NMDISPID_H_

#include <olectl.h>

#define UUID_ICall					5948A4B0-8EFD-11d2-933E-0000F875AE17
#define UUID_INetMeeting			5572984E-7A76-11d2-9334-0000F875AE17
#define UUID_NetMeetingLib			5CE55CD7-5179-11D2-931D-0000F875AE17
#define UUID_NetMeeting				3E9BAF2D-7A79-11d2-9334-0000F875AE17

///////////////////////////////////////////////////////////////////////////////////////////////
// INetMeeting DISPIDs
#define NETMEETING_DISPID_START				(100)
#define DISPID_Version						(NETMEETING_DISPID_START + 0)
#define DISPID_UnDock						(NETMEETING_DISPID_START + 1)
#define DISPID_IsInConference				(NETMEETING_DISPID_START + 2)
#define DISPID_CallTo						(NETMEETING_DISPID_START + 3)
#define DISPID_LeaveConference				(NETMEETING_DISPID_START + 4)
#define NETMEETING_DISPID_END				(NETMEETING_DISPID_START + 100)

#define NETMEETING_EVENTS_DISPID_START		(NETMEETING_DISPID_END + 1)
#define DISPID_ConferenceStarted			(NETMEETING_EVENTS_DISPID_START + 1)
#define DISPID_ConferenceEnded				(NETMEETING_EVENTS_DISPID_START + 2)


#endif /* _NMDISPID_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\h\nmdsprv.h ===
/*==========================================================================;
 *
 *  Copyright (C) 1995-1998 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       nmdsprv.h
 *  Content:    utility function to map WAVE IDs to DirectSound GUID IDs
 *              (Win98 and NT 5 only)
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  8/19/98     dereks  Created.
 *  8/24/98     jselbie	Streamlined up for lightweight use in NetMeeting
 *@@END_MSINTERNAL
 *
 **************************************************************************/

#ifndef __NMDSPRV_INCLUDED__
#define __NMDSPRV_INCLUDED__

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus




// NetMeeting utility function

extern HRESULT __stdcall DsprvGetWaveDeviceMapping
(
    LPCSTR                                              pszWaveDevice,
    BOOL                                                fCapture,
    LPGUID                                              pguidDeviceId
);



#ifdef __cplusplus
}
#endif // __cplusplus

#endif  // __DSPRV_INCLUDED__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\h\nmhelp.h ===
// File: nmhelp.h

#ifndef _NMHELP_H_
#define _NMHELP_H_

#include <htmlhelp.h>

HRESULT InitHtmlHelpMarshaler(HINSTANCE hInst);

VOID ShowNmHelp(LPCTSTR lpcszHtmlHelpFile);

VOID DoNmHelp(HWND hwnd, UINT uCommand, DWORD_PTR dwData);
VOID DoHelp(LPARAM lParam);
VOID DoHelp(LPARAM lParam, const DWORD * rgId);
VOID DoHelpWhatsThis(WPARAM wParam, const DWORD * rgId);

VOID ShutDownHelp(void);

#endif /* _NMHELP_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\h\nmmkcert.h ===
#ifndef _NMMKCERT_
#define _NMMKCERT_

// Flags
#define	NMMKCERT_F_DELETEOLDCERT	0x00000001
#define NMMKCERT_F_LOCAL_MACHINE	0x00000002
#define NMMKCERT_F_CLEANUP_ONLY		0x00000004

// NetMeeting certificate store
#define SZNMSTORE	"_NMSTR"
#define WSZNMSTORE	L"_NMSTR"

// Magic constant in user properties
#define NMMKCERT_MAGIC    0x2389ABD0

// RDN name of issuing root cert...
#define SZ_NMROOTNAME TEXT("NetMeeting Root")

// When issuer obtained using these flags
#ifndef CERT_NAME_STR_REVERSE_FLAG
#define CERT_NAME_STR_REVERSE_FLAG      0x02000000
#endif // CERT_NAME_STR_REVERSE_FLAG

#define CERT_FORMAT_FLAGS (CERT_SIMPLE_NAME_STR|CERT_NAME_STR_NO_PLUS_FLAG|\
    CERT_NAME_STR_REVERSE_FLAG)

// Library Name
#define SZ_NMMKCERTLIB TEXT("NMMKCERT.DLL")

// Prototype typedef
typedef DWORD (WINAPI *PFN_NMMAKECERT)(LPCSTR, LPCSTR, LPCSTR, LPCSTR, LPCSTR, DWORD);

// Loadlibrary constant
#define SZ_NMMAKECERTFUNC "NmMakeCert"

// Static prototype
extern DWORD WINAPI NmMakeCert (LPCSTR szFirstName,
								LPCSTR szLastName,
								LPCSTR szEmailName,
								LPCSTR szCity,
								LPCSTR szCountry,
								DWORD dwFlags );

#endif // _NMMKCERT_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\h\nmqos.h ===
/*
 -  QOS.H
 -
 *	Microsoft NetMeeting
 *	Quality of Service DLL
 *	Header file
 *
 *		Revision History:
 *
 *		When		Who					What
 *		--------	------------------  ---------------------------------------
 *		10.23.96	Yoram Yaacovi		Created
 *
 */

#ifndef _NMQOS_H_
#define _NMQOS_H_

#include <pshpack8.h> /* Assume 8 byte packing throughout */

/*
 *	Constants
 */

// Properties stuff
// Property types
#define PT_NULL         ((ULONG)  1)    /* NULL property value */
#define PT_I2           ((ULONG)  2)    /* Signed 16-bit value */
#define PT_LONG         ((ULONG)  3)    /* Signed 32-bit value */
#define PT_BOOLEAN      ((ULONG) 11)    /* 16-bit boolean (non-zero true) */
#define PT_STRING8      ((ULONG) 30)    /* Null terminated 8-bit character string */
#define PT_UNICODE      ((ULONG) 31)    /* Null terminated Unicode string */
#define PT_CLSID        ((ULONG) 72)    /* OLE GUID */
#define PT_BINARY       ((ULONG) 258)   /* Uninterpreted (counted byte array) */

// Property IDs
#define QOS_PROPERTY_BASE		0x3000
#define PR_QOS_WINDOW_HANDLE	PROPERTY_TAG( PT_LONG, QOS_PROPERTY_BASE+1)

// hresult codes, facility QOS = 0x300
#define QOS_E_RES_NOT_ENOUGH_UNITS	0x83000001
#define QOS_E_RES_NOT_AVAILABLE		0x83000002
#define QOS_E_NO_SUCH_REQUEST		0x83000003
#define QOS_E_NO_SUCH_RESOURCE		0x83000004
#define QOS_E_NO_SUCH_CLIENT		0x83000005
#define QOS_E_REQ_ERRORS			0x83000006		
#define QOS_W_MAX_UNITS_EXCEEDED	0x03000007		
#define QOS_E_INTERNAL_ERROR		0x83000008		
#define QOS_E_NO_SUCH_PROPERTY		0x83000100

// Resource IDs
#define RESOURCE_NULL				0
#define RESOURCE_OUTGOING_BANDWIDTH	1		/* units: bps */
#define RESOURCE_INCOMING_BANDWIDTH	2		/* units: bps */
#define RESOURCE_OUTGOING_LATENCY	3		/* units: */
#define RESOURCE_INCOMING_LATENCY	4		/* units: */
#define RESOURCE_CPU_CYCLES			10		/* units: */

#define QOS_CLIENT_NAME_ZISE		20

// For use as dimension for variable size arrays
#define VARIABLE_DIM				1


/*
 *	Macros
 */
#define PROPERTY_TYPE_MASK          ((ULONG)0x0000FFFF) /* Mask for Property type */
#define PROPERTY_TYPE(ulPropTag)    (((ULONG)(ulPropTag))&PROPERTY_TYPE_MASK)
#define PROPERTY_ID(ulPropTag)      (((ULONG)(ulPropTag))>>16)
#define PROPERTY_TAG(ulPropType,ulPropID)   ((((ULONG)(ulPropID))<<16)|((ULONG)(ulPropType)))

#ifndef GUARANTEE
// this used to be defined in the original winsock2.h
typedef enum
{
    BestEffortService,
    ControlledLoadService,
    PredictiveService,
    GuaranteedDelayService,
    GuaranteedService
} GUARANTEE;
#endif
/*
 *	Data Structures
 */

// Properties part
typedef struct _binaryvalue
{
    ULONG       cb;
    LPBYTE      lpb;
} BINARYVALUE, *PBINARYVALUE;

typedef union _propvalue
{
    short int           i;          /* case PT_I2 */
    LONG                l;          /* case PT_LONG */
    ULONG_PTR           ul;         /* alias for PT_LONG */
    unsigned short int  b;          /* case PT_BOOLEAN */
    LPSTR               lpszA;      /* case PT_STRING8 */
    BINARYVALUE         bin;        /* case PT_BINARY */
    LPWSTR              lpszW;      /* case PT_UNICODE */
    LPGUID              lpguid;     /* case PT_CLSID */
} PROPVALUE;

typedef struct _property
{
    ULONG				ulPropTag;
    ULONG				hResult;
    union _propvalue	Value;
} PROPERTY, *PPROPERTY;


typedef struct _proptagarray
{
    ULONG   cValues;
    ULONG   aulPropTag[VARIABLE_DIM];
} PROPTAGARRAY, *PPROPTAGARRAY;


// QoS part
typedef struct _resource
{
	DWORD		resourceID;
	DWORD		ulResourceFlags;	/* 0 in NetMeeting 2.0 */
	int			nUnits;				/* Total units of the resource */
	DWORD		reserved;			/* Must be 0 */
} RESOURCE, *LPRESOURCE;

typedef struct _resourcerequest
{
	DWORD		resourceID;
	DWORD		ulRequestFlags;		/* 0 in NetMeeting 2.0 */
	GUARANTEE	levelOfGuarantee;	/* Guaranteed, Predictive */
	int			nUnitsMin;			/* # of units to reserve */
	int			nUnitsMax;			/* 0 in NetMeeting 2.0 */
	SOCKET		socket;				/* Socket where the */
									/*  reservation will be used */
	HRESULT		hResult;			/* result code for this resource */
	DWORD		reserved;			/* Must be 0 */
} RESOURCEREQUEST, *LPRESOURCEREQUEST;

typedef struct _resourcelist
{
	ULONG		cResources;
	RESOURCE	aResources[VARIABLE_DIM];
} RESOURCELIST, *LPRESOURCELIST;

typedef struct _resourcerequestlist
{
	ULONG			cRequests;
	RESOURCEREQUEST	aRequests[VARIABLE_DIM];
} RESOURCEREQUESTLIST, *LPRESOURCEREQUESTLIST;

typedef struct _client
{
	GUID	guidClientGUID;
	int		priority;				/* 1 highest, 9 lowest, 0 invalid */
	WCHAR	wszName[QOS_CLIENT_NAME_ZISE];	/* name of the client */
	DWORD	reserved;				/* Must be 0 */
} CLIENT, *LPCLIENT;

typedef struct _clientlist
{
	ULONG	cClients;
	CLIENT	aClients[VARIABLE_DIM];
} CLIENTLIST, *LPCLIENTLIST;

/*
 *	Functions
 */
typedef HRESULT (CALLBACK *LPFNQOSNOTIFY)
				(LPRESOURCEREQUESTLIST lpResourceRequestList,
				DWORD_PTR dwParam);

/*
 *	Interfaces
 */

#ifndef DECLARE_INTERFACE_PTR
#ifdef __cplusplus
#define DECLARE_INTERFACE_PTR(iface, piface)                       \
	interface iface; typedef iface FAR * piface
#else
#define DECLARE_INTERFACE_PTR(iface, piface)                       \
	typedef interface iface iface, FAR * piface
#endif
#endif /* DECLARE_INTERFACE_PTR */


#define IUNKNOWN_METHODS(IPURE)										\
    STDMETHOD (QueryInterface)                                      \
        (THIS_ REFIID riid, LPVOID FAR * ppvObj) IPURE;				\
    STDMETHOD_(ULONG,AddRef)  (THIS) IPURE;							\
    STDMETHOD_(ULONG,Release) (THIS) IPURE;							\

#define IQOS_METHODS(IPURE)											\
	STDMETHOD(RequestResources)										\
		(THIS_	LPGUID lpStreamGUID,								\
				LPRESOURCEREQUESTLIST lpResourceRequestList,		\
				LPFNQOSNOTIFY lpfnQoSNotify,		\
				DWORD_PTR dwParam) IPURE;					\
	STDMETHOD (ReleaseResources)									\
		(THIS_	LPGUID lpStreamGUID,								\
				LPRESOURCEREQUESTLIST lpResourceRequestList) IPURE;	\
	STDMETHOD (SetResources) (THIS_ LPRESOURCELIST lpResourceList) IPURE;	\
	STDMETHOD (GetResources) (THIS_ LPRESOURCELIST *lppResourceList) IPURE;	\
	STDMETHOD (SetClients) (THIS_ LPCLIENTLIST lpClientList) IPURE;	\
	STDMETHOD (NotifyNow) (THIS) IPURE;								\
	STDMETHOD (FreeBuffer) (THIS_ LPVOID lpBuffer) IPURE;			\

#define IPROP_METHODS(IPURE)										\
	STDMETHOD (SetProps)											\
		(THIS_  ULONG cValues,										\
				PPROPERTY pPropArray) IPURE;						\
    STDMETHOD (GetProps)											\
        (THIS_  PPROPTAGARRAY pPropTagArray,						\
                ULONG ulFlags,										\
                ULONG *pcValues,								\
                PPROPERTY *ppPropArray) IPURE;					\

#undef       INTERFACE
#define      INTERFACE  IQoS
DECLARE_INTERFACE_(IQoS, IUnknown)
{
    IUNKNOWN_METHODS(PURE)
	IQOS_METHODS(PURE)
	IPROP_METHODS(PURE)
};

DECLARE_INTERFACE_PTR(IQoS, LPIQOS);

EXTERN_C HRESULT WINAPI CreateQoS (	IUnknown *punkOuter,
								REFIID riid,
								void **ppv);

typedef HRESULT (WINAPI *PFNCREATEQOS)
				(IUnknown *punkOuter, REFIID riid, void **ppv);


// QoS Class GUID
// {085C06A0-3CAA-11d0-A00E-00A024A85A2C}
DEFINE_GUID(CLSID_QoS, 0x085c06a0, 0x3caa, 0x11d0, 0xa0, 0x0e, 0x0, 0xa0, 0x24, 0xa8, 0x5a, 0x2c);
// QoS Interface GUID
// {DFC1F900-2DCE-11d0-92DD-00A0C922E6B2}
DEFINE_GUID(IID_IQoS, 0xdfc1f900, 0x2dce, 0x11d0, 0x92, 0xdd, 0x0, 0xa0, 0xc9, 0x22, 0xe6, 0xb2);

#include <poppack.h> /* End byte packing */

#endif  // _NMQOS_H_

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\h\nmremote.h ===
// nmremote.h
// Contains data structures and declarations shared by NetMeeting and
// the remote control service

// String for identifying remote control service.
#define	REMOTE_CONTROL_NAME  TEXT("mnmsrvc")

#ifdef DATA_CHANNEL
// GUID for the remote control data channel
// {B983C6DA-459A-11d1-8735-0000F8757125}
const GUID g_guidRemoteControl = 
{ 0xb983c6da, 0x459a, 0x11d1, { 0x87, 0x35, 0x0, 0x0, 0xf8, 0x75, 0x71, 0x25 } };

const UINT RC_CAP_DESKTOP       = 0x00000001;

typedef UINT RC_CAP_DATA;
#endif // DATA_CHANNEL

#ifdef DATA_CHANNEL
// Declarations for the remote control data channel protocol
typedef enum {
	RC_SENDCTRLALTDEL = 0,
#ifdef RDS_AV
	RC_STARTAUDIO = 1,
	RC_STOPAUDIO = 2,
	RC_STARTVIDEO = 3,
	RC_STOPVIDEO = 4
#endif // RDS_AV
} RC_COMMAND;

typedef struct tagRCDATA {
	DWORD	magic;			// magic number
	DWORD	command;		// which command
	DWORD	size;			// size of data afterwards
} RCDATA;

// Constants for use in parsing incoming data
const int RC_DATAMINSIZE = sizeof(RCDATA);	// minimum size for a data packet = size of the header
const DWORD RC_DATAMAGIC = 0x03271943;		// magic number to identify packets

const int RC_DATAMAGICOFFSET = 0;
const int RC_DATACMDOFFSET = sizeof(DWORD);
const int RC_DATABUFFEROFFSET = RC_DATACMDOFFSET + sizeof(DWORD);
#endif // DATA_CHANNEL;

// Application name for Win95 service
#define WIN95_SERVICE_APP_NAME	TEXT("mnmsrvc.exe")

#define REMOTE_CONTROL_DISPLAY_NAME 	TEXT("NetMeeting Remote Desktop Sharing")

#define SZRDSGROUP "NetMeeting RDS Users"

// Remote Control Conference Descriptor
#define RDS_CONFERENCE_DESCRIPTOR  L"0xb983c6da459a11d1873500f8757125"

// Strings for events used for communication between NetMeeting and the service
#define SERVICE_STOP_EVENT	TEXT("RDS:Stop")
#define SERVICE_PAUSE_EVENT     TEXT("RDS:Pause")
#define SERVICE_CONTINUE_EVENT  TEXT("RDS:Continue")
#define SERVICE_ACTIVE_EVENT    TEXT("RDS:Active")
#define SERVICE_CALL_EVENT  TEXT("RDS:Call")

// BUGBUG 03-02-98
// These string constants are copied from ui\conf\ipcpriv.h
const char g_szConfInit[] =				_TEXT("CONF:Init");
const char g_szConfShuttingDown[] =		_TEXT("CONF:ShuttingDown");
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\h\nmstd.h ===
#ifndef __NmStd_h__
#define __NmStd_h__

// Useful macros
inline LONG RectWidth(const RECT* pr) { return pr->right - pr->left; }
inline LONG RectHeight(const RECT* pr) { return pr->bottom - pr->top; }
inline LONG RectWidth(const RECT& rpr) { return rpr.right - rpr.left; }
inline LONG RectHeight(const RECT& rpr) { return rpr.bottom - rpr.top; }

inline HRESULT GetLocalIPAddress( DWORD *pdwIPAddress )
{
	HRESULT hr = S_OK;

	if( pdwIPAddress )
	{
		// get local host name
		CHAR szLocalHostName[MAX_PATH];
		szLocalHostName[0] = '\0';
		gethostname(&szLocalHostName[0], MAX_PATH);

		// get the host entry by name
		PHOSTENT phe = gethostbyname(&szLocalHostName[0]);
		if (phe != NULL)
		{
			// get info from the host entry
			*pdwIPAddress = *(DWORD *) phe->h_addr;
		}	
		else
		{
			hr = MAKE_HRESULT(SEVERITY_ERROR,FACILITY_INTERNET,WSAGetLastError());
		}
	}
	else
	{
		hr = E_INVALIDARG;
	}

	return hr;
}

#endif  // ! _NMUTIL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\h\nmstat.h ===
//  NMSTAT.H
//
//      Headers for STATS.DLL: a library to accumulate high performance
//      statistics and allow them to be tabulated in a different
//      process.
//
//  Created 24-Oct-96 [JonT]

#ifndef _NMSTATS_H
#define _NMSTATS_H

#ifdef __cplusplus
extern "C" {
#endif

//#if defined(_BUILD_STATS_) || defined(__midl)
#ifdef _BUILD_STATS_
#define STATSAPI
#else
#define STATSAPI __declspec(dllimport)
#endif

// Equates
#define MAX_COUNTER_NAME    64
#define STATS_COUNTER_ADDDEL_EVENT  "StatsNewCounter"
#define STATS_REPORT_ADDDEL_EVENT  "StatsNewReport"
#define COUNTER_FLAG_NO_STATISTICS  1   // Flag to CreateCounter. No statistics accumulated
                                        // for this counter even if StartStatistics called.
                                        // (StartStatistics fails)
#define COUNTER_FLAG_ACCUMULATE     2   // UpdateCounter adds to the counter value rather
                                        // than replacing it.
#define COUNTER_CLEAR               1   // Flag to GetCounter. Specifies the counter should
                                        // be cleared after being read
#define MAX_REPORT_NAME    64
#define UNDEFINED -1L

// Call parameters report defines
#define	REP_SEND_AUDIO_FORMAT	0
#define	REP_SEND_AUDIO_SAMPLING	1
#define	REP_SEND_AUDIO_BITRATE	2
#define	REP_SEND_AUDIO_PACKET	3
#define	REP_RECV_AUDIO_FORMAT	4
#define	REP_RECV_AUDIO_SAMPLING	5
#define	REP_RECV_AUDIO_BITRATE	6
#define	REP_RECV_AUDIO_PACKET	7
#define	REP_SEND_VIDEO_FORMAT	8
#define	REP_SEND_VIDEO_MAXFPS	9
#define	REP_SEND_VIDEO_BITRATE	10
#define	REP_RECV_VIDEO_FORMAT	11
#define	REP_RECV_VIDEO_MAXFPS	12
#define	REP_RECV_VIDEO_BITRATE	13

// System settings report defines
#define	REP_SYS_BANDWIDTH			0
#define	REP_SYS_AUDIO_DSOUND		1
#define	REP_SYS_AUDIO_RECORD		2
#define	REP_SYS_AUDIO_PLAYBACK		3
#define	REP_SYS_AUDIO_DUPLEX		4
#define	REP_SYS_VIDEO_DEVICE		5
#define	REP_DEVICE_IMAGE_SIZE		6

// Types
#ifdef __midl
typedef DWORD HCOUNTER;
#else
typedef HANDLE HCOUNTER;
#endif
typedef HCOUNTER HREPORT;

typedef struct _FINDCOUNTER
{
    DWORD dwSize;
    char szName[MAX_COUNTER_NAME];      // Human-readable counter name
    HCOUNTER hcounter;                  // Handle to use with all stats functions
    int nValue;                         // Current value of counter
    WORD wFlags;                        // COUNTER_FLAG_* values
    WORD wRefCount;                     // Number of times StartStatistics has been called.
    DWORD dwReserved;                   // Must be preserved: used for FindNextCounter
} FINDCOUNTER;

typedef struct _FINDREPORT
{
    DWORD dwSize;
    char szName[MAX_REPORT_NAME];       // Human-readable report name
    HREPORT hreport;                    // Handle to use with all functions
    WORD wFlags;                        // COUNTER_FLAG_* values
    WORD wRefCount;                     // Number of times StartStatistics has been called.
    DWORD dwReserved;                   // Must be preserved: used for FindNextCounter
} FINDREPORT;

typedef struct _COUNTERSTAT
{
    DWORD dwSize;                       // Size of structure. Allows for future growth...
    int nValue;
    int nLow;                           // Lowest value seen since clear
    int nHigh;                          // Highest value seen since clear
    int nAverage;                       // Average value seen since clear
    DWORD dwNumSamples;                 // Number of samples accumulated
    DWORD dwmsAtClear;                  // GetTickCount at last Clear/StartStatistics call
} COUNTERSTAT;

// Nothing further needed by MIDL
#ifndef __midl

// Counter Functions

// Called by updater of counter to make new counter
// Sets the event named in the equate STATS_NEW_COUNTER_EVENT
STATSAPI HCOUNTER WINAPI    CreateCounter(char* szName, WORD wFlags);

// Called by updater of counter when counter is going away
STATSAPI BOOL WINAPI DeleteCounter(HCOUNTER hc);

// Used by reader app to locate specific named counters or walk entire list.
// Pass NULL in for name to walk entire list. Pass NULL to FINDCOUNTER if
// just an HCOUNTER is desired. FindNext returns FALSE when there are no more.
STATSAPI HCOUNTER WINAPI    FindFirstCounter(char* szName, FINDCOUNTER* pfc);
STATSAPI BOOL WINAPI        FindNextCounter(FINDCOUNTER* pfc);

// Called by updater of counter. Makes the value current in the counter.
STATSAPI void WINAPI        UpdateCounter(HCOUNTER hcounter, int value);

// Called by updater of counter. Initializes the max value for the counter.
STATSAPI void WINAPI        InitCounterMax(HCOUNTER hcounter, int nMaxValue);

// Called by user of counter and just returns value with no statistics
STATSAPI int WINAPI         GetCounter(HCOUNTER hcounter, DWORD dwFlags);

// Called by user of counter and just returns max value with no statistics
STATSAPI int WINAPI         GetCounterMax(HCOUNTER hcounter, DWORD dwFlags);

// Begins collecting statistics on a counter
STATSAPI BOOL WINAPI        StartStatistics(HCOUNTER hcounter);

// Done collecting statistics on a counter
STATSAPI void WINAPI        StopStatistics(HCOUNTER hcounter);

// Get statistics on a counter
STATSAPI BOOL WINAPI        ReadStatistics(HCOUNTER hcounter, COUNTERSTAT* pcs);

// Clear statistics on a counter
STATSAPI void WINAPI        ClearStatistics(HCOUNTER hcounter);

// Report Functions

// Called by updater of report to make new report
// Sets the event named in the equate STATS_NEW_COUNTER_EVENT
STATSAPI HREPORT WINAPI CreateReport(char* szName, WORD wFlags);

// Called by updater of report when report is going away
STATSAPI BOOL WINAPI DeleteReport(HREPORT hreport);

// Used by reader app to locate specific named reports or walk entire list.
// Pass NULL in for name to walk entire list. Pass NULL to FINDREPORT if
// just an HREPORT is desired. FindNext returns FALSE when there are no more.
STATSAPI HREPORT WINAPI FindFirstReport(char* szName, FINDREPORT* pfr);
STATSAPI BOOL WINAPI FindNextReport(FINDREPORT* pfr);

// Called by updater of report. Makes the value current in the report.
STATSAPI void WINAPI UpdateReportEntry(HREPORT hreport, int nValue, DWORD dwIndex);

// Called by creater of report.
STATSAPI void WINAPI CreateReportEntry(HREPORT hreport, char* szName, DWORD dwIndex);

// Called by user of report
STATSAPI int WINAPI GetReportEntry(HREPORT hreport, DWORD dwIndex);

// Called by user of report
STATSAPI void WINAPI GetReportEntryName(HREPORT hreport, char *szName, DWORD dwIndex);

// Called by user of report
STATSAPI int WINAPI GetNumReportEntries(HREPORT hreport);

#endif // #ifndef __midl

#ifdef __cplusplus
}
#endif

#endif // #ifndef _STATS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\h\nmutil.h ===
#ifndef _NMUTIL_H_
#define _NMUTIL_H_

#define NMINTERNAL __stdcall

#endif  // ! _NMUTIL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\h\olevalid.h ===
/*
 * olevalid.h - OLE validation functions description.
 *
 * Taken from URL code by ChrisPi 9-11-95
 *
 */

#ifndef _OLEVALID_H_
#define _OLEVALID_H_

#ifdef __cplusplus
extern "C" {                        /* Assume C declarations for C++. */
#endif   /* __cplusplus */


/* Macros
 *********/

/* method validation macro */

#define IS_VALID_METHOD(piface, mthd) \
   IS_VALID_CODE_PTR((piface)->lpVtbl->mthd, mthd)


/* Prototypes
 *************/

/* olevalid.c */

#ifdef DEBUG

extern BOOL IsValidPCGUID(PCGUID);
extern BOOL IsValidPCCLSID(PCCLSID);
extern BOOL IsValidPCIID(PCIID);
extern BOOL IsValidPCDVTARGETDEVICE(PCDVTARGETDEVICE);
extern BOOL IsValidPCFORMATETC(PCFORMATETC);
extern BOOL IsValidStgMediumType(DWORD);
extern BOOL IsValidPCSTGMEDIUM(PCSTGMEDIUM);
extern BOOL IsValidREFIID(REFIID);
extern BOOL IsValidREFCLSID(REFCLSID);
extern BOOL IsValidPCINTERFACE(PCVOID);
extern BOOL IsValidPCIAdviseSink(PCIAdviseSink);
extern BOOL IsValidPCIClassFactory(PCIClassFactory);
extern BOOL IsValidPCIDataObject(PCIDataObject);
extern BOOL IsValidPCIDropSource(PCIDropSource);
extern BOOL IsValidPCIDropTarget(PCIDropTarget);
extern BOOL IsValidPCIEnumFORMATETC(PCIEnumFORMATETC);
extern BOOL IsValidPCIEnumSTATDATA(PCIEnumSTATDATA);
extern BOOL IsValidPCIMalloc(PCIMalloc);
extern BOOL IsValidPCIMoniker(PCIMoniker);
extern BOOL IsValidPCIPersist(PCIPersist);
extern BOOL IsValidPCIPersistFile(PCIPersistFile);
extern BOOL IsValidPCIPersistStorage(PCIPersistStorage);
extern BOOL IsValidPCIPersistStream(PCIPersistStream);
extern BOOL IsValidPCIStorage(PCIStorage);
extern BOOL IsValidPCIStream(PCIStream);
extern BOOL IsValidPCIUnknown(PCIUnknown);

#ifdef __INTSHCUT_H__

extern BOOL IsValidPCIUniformResourceLocator(PCIUniformResourceLocator);

#endif   /* __INTSHCUT_H__ */

#endif   /* DEBUG */


#ifdef __cplusplus
}                                   /* End of extern "C" {. */
#endif   /* __cplusplus */

#endif /* _OLEVALID_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\h\oblist.h ===
#ifndef _OBLIST_H_
#define _OBLIST_H_

// class COBNODE;
#define POSITION COBNODE*

struct COBNODE
{
	POSITION	pNext;
	void*		pItem;
};

class COBLIST
{
protected:
	POSITION m_pHead;
	POSITION m_pTail;
    virtual BOOL Compare(void* pItemToCompare, void* pComparator) 
        {return(pItemToCompare == pComparator);};
public:
	COBLIST() : m_pHead(NULL), m_pTail(NULL) { };
	
	POSITION	    GetHeadPosition() { return(m_pHead); };
	POSITION	    GetTailPosition() { return(m_pTail); };
	virtual void *  RemoveAt(POSITION rPos);
	virtual void *	ReplaceAt(POSITION rPos, void* pNewItem)
	{
		void *pvoid = rPos->pItem;
		rPos->pItem = pNewItem;
		return(pvoid);
	}

	POSITION	    AddTail(void* pItem);
	BOOL		    IsEmpty() { return(!m_pHead); };
	void *		    GetTail();
	void *		    GetNext(POSITION& rPos);
    void *          SafeGetFromPosition(POSITION rPos);
    POSITION        GetPosition(void* pItem);
    POSITION        Lookup(void* pComparator);
    void            EmptyList();
    virtual         ~COBLIST();
#ifdef DEBUG
	void *		    GetHead();
	void *		    RemoveHead();
	// void *		RemoveTail(); // inefficient
	void *		    GetFromPosition(POSITION rPos);
#else
	void *		    GetHead(){return GetFromPosition(GetHeadPosition());};
	void *		    RemoveHead() { return RemoveAt(m_pHead); };
	// void *		RemoveTail() { return RemoveAt(m_pTail); }; // inefficient
	void *		    GetFromPosition(POSITION rPos){return(rPos->pItem);};
#endif
};

#endif // ndef _OBLIST_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\h\olestock.h ===
/*
 * olestock.h - Stock OLE header file.
 *
 * Taken from URL code by ChrisPi 9-11-95
 *
 */

#ifndef _OLESTOCK_H_
#define _OLESTOCK_H_

#ifdef __cplusplus
extern "C" {                        /* Assume C declarations for C++. */
#endif   /* __cplusplus */


/* Types
 ********/

/* IDs */

DECLARE_STANDARD_TYPES(GUID);
DECLARE_STANDARD_TYPES(CLSID);
DECLARE_STANDARD_TYPES(IID);

typedef FARPROC *Interface;
DECLARE_STANDARD_TYPES(Interface);

/* interfaces */

DECLARE_STANDARD_TYPES(IAdviseSink);
DECLARE_STANDARD_TYPES(IBindCtx);
DECLARE_STANDARD_TYPES(IClassFactory);
DECLARE_STANDARD_TYPES(IDataObject);
DECLARE_STANDARD_TYPES(IDropSource);
DECLARE_STANDARD_TYPES(IDropTarget);
DECLARE_STANDARD_TYPES(IEnumFORMATETC);
DECLARE_STANDARD_TYPES(IEnumSTATDATA);
DECLARE_STANDARD_TYPES(IMalloc);
DECLARE_STANDARD_TYPES(IMoniker);
DECLARE_STANDARD_TYPES(IPersist);
DECLARE_STANDARD_TYPES(IPersistFile);
DECLARE_STANDARD_TYPES(IPersistStorage);
DECLARE_STANDARD_TYPES(IPersistStream);
DECLARE_STANDARD_TYPES(IStorage);
DECLARE_STANDARD_TYPES(IStream);
DECLARE_STANDARD_TYPES(IUnknown);

/* structures */

DECLARE_STANDARD_TYPES(DVTARGETDEVICE);
DECLARE_STANDARD_TYPES(FORMATETC);
DECLARE_STANDARD_TYPES(STGMEDIUM);

/* advise flags */

typedef enum advise_flags
{
   ALL_ADVISE_FLAGS   = (ADVF_NODATA |
                         ADVF_PRIMEFIRST |
                         ADVF_ONLYONCE |
                         ADVF_DATAONSTOP |
                         ADVFCACHE_NOHANDLER |
                         ADVFCACHE_FORCEBUILTIN |
                         ADVFCACHE_ONSAVE)
}
ADVISE_FLAGS;

/* data transfer direction flags */

typedef enum datadir_flags
{
   ALL_DATADIR_FLAGS   = (DATADIR_GET |
                          DATADIR_SET)
}
DATADIR_FLAGS;

/* drop effects */

typedef enum drop_effects
{
   ALL_DROPEFFECT_FLAGS   = (DROPEFFECT_NONE |
                             DROPEFFECT_COPY |
                             DROPEFFECT_MOVE |
                             DROPEFFECT_LINK |
                             DROPEFFECT_SCROLL)
}
DROP_EFFECTS;

/* mouse message key states */

typedef enum mk_flags
{
   ALL_KEYSTATE_FLAGS      = (MK_LBUTTON |
                              MK_RBUTTON |
                              MK_SHIFT |
                              MK_CONTROL |
                              MK_MBUTTON)
}
MK_FLAGS;

/* medium types */

typedef enum tymeds
{
   ALL_TYMED_FLAGS         = (TYMED_HGLOBAL |
                              TYMED_FILE |
                              TYMED_ISTREAM |
                              TYMED_ISTORAGE |
                              TYMED_GDI |
                              TYMED_MFPICT |
                              TYMED_ENHMF)
}
TYMEDS;


#ifdef __cplusplus
}                                   /* End of extern "C" {. */
#endif   /* __cplusplus */

#endif /* _OLESTOCK_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\h\os2.h ===
// Dummy file to prevent dependancy errors.
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\h\ping.h ===
#ifndef _PING_H_
#define _PING_H_

#include <ipexport.h>
#include <icmpapi.h>


// Function prototypes equivalent to those in icmpapi.h
// these are required in order to use GetProcAddress()
typedef HANDLE (WINAPI * PFNIcmpCreateFile) (VOID);
typedef BOOL   (WINAPI * PFNIcmpCloseHandle) (HANDLE  IcmpHandle);
typedef DWORD  (WINAPI * PFNIcmpSendEcho) (
    HANDLE                   IcmpHandle,
    IPAddr                   DestinationAddress,
    LPVOID                   RequestData,
    WORD                     RequestSize,
    PIP_OPTION_INFORMATION   RequestOptions,
    LPVOID                   ReplyBuffer,
    DWORD                    ReplySize,
    DWORD                    Timeout);

enum { AUTODIAL_UNKNOWN = -1, PLATFORM_UNKNOWN = -2 };

class CPing
{
protected:
	HINSTANCE			m_hICMPDLL;
	PFNIcmpCreateFile	m_pfnCreateFile;
	PFNIcmpCloseHandle	m_pfnCloseHandle;
	PFNIcmpSendEcho		m_pfnSendEcho;

	BOOL				m_fWinNTAutodialEnabled;
	DWORD				m_dwPlatformId;

public:
			CPing() :
				m_hICMPDLL			(NULL),
				m_pfnCreateFile		(NULL),
				m_pfnCloseHandle	(NULL),
				m_pfnSendEcho		(NULL),
				m_fWinNTAutodialEnabled (AUTODIAL_UNKNOWN),
				m_dwPlatformId			(PLATFORM_UNKNOWN)
			{ };
			~CPing() { if (m_hICMPDLL) ::FreeLibrary(m_hICMPDLL); };
	HRESULT	Ping(DWORD dwAddr, DWORD dwTimeout, DWORD dwRetries);

	BOOL IsWin95AutodialEnabled ( VOID );
	BOOL IsWinNTAutodialEnabled ( VOID );
	BOOL IsAutodialEnabled ( VOID ); // call either one above
};




#endif  // _PING_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\h\oprahcom.h ===
#ifndef _OPRAHCOM_H_
#define _OPRAHCOM_H_

#include <nmutil.h>
#include <tchar.h>
#include <stock.h>
#include <confdbg.h>
#include <memtrack.h>

// Some string functions that used to be defined here have been moved to
// STRUTIL.  We include that header file so that source files that include
// this file continue to work.
#include <strutil.h>

BOOL    NMINTERNAL CanShellExecHttp();
BOOL    NMINTERNAL CanShellExecMailto();
BOOL    NMINTERNAL GetInstallDirectory(LPTSTR psz);

INLINE DWORD 
CompareGuid(GUID * p1, GUID * p2)
{
	ASSERT(NULL != p1);
	ASSERT(NULL != p2);
	return memcmp(p1, p2, sizeof(GUID));
}

INLINE VOID 
ClosePh(HANDLE * ph)
{
	if ((NULL == ph) || (NULL == *ph))
		return;

	CloseHandle(*ph);
	*ph = NULL;
}

BOOL    NMINTERNAL FFileExists(LPCTSTR szFile);
BOOL    NMINTERNAL FDirExists(LPCSTR szDir);
BOOL    NMINTERNAL FEnsureDirExists(LPCTSTR szDir);
BOOL    NMINTERNAL FEnsureDirName(LPTSTR pszPath);
DWORD   NMINTERNAL CreateNewFile(LPTSTR pszFile);
BOOL    NMINTERNAL FCreateNewFile(LPCTSTR pcszPath, LPCTSTR pcszName,
								  LPCTSTR pcszExt, LPTSTR pszResult, int cchMax);

LPCTSTR NMINTERNAL ExtractFileName(LPCTSTR pcszPathName);
#if defined(UNICODE)
LPCSTR NMINTERNAL ExtractFileNameA(LPCSTR pcszPathName);
#else // defined(UNICODE)
#define ExtractFileNameA ExtractFileName
#endif // defined(UNICODE)
BOOL    NMINTERNAL SanitizeFileName(LPTSTR psz);

VOID    NMINTERNAL CenterWindow(HWND hwndChild, HWND hwndParent);


/****************************************************************************

Processor ID and Speed routines

*****************************************************************************/
#ifdef _M_IX86
HRESULT NMINTERNAL GetNormalizedCPUSpeed (int *pdwNormalizedSpeed, int *iFamily);
int     NMINTERNAL GetProcessorSpeed(int *pdwFamily);
#endif

BOOL NMINTERNAL IsFloatingPointEmulated(void);

#endif // _OPRAHCOM_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\h\referenc.h ===
#ifndef	_REFERENC_H_
#define	_REFERENC_H_

class REFCOUNT
{
public:
	REFCOUNT();
	virtual ~REFCOUNT();
	DWORD AddRef();
	DWORD Release();
	DWORD Delete();
	void OnStack() {bOnStack = TRUE;};
private:
	DWORD		 NumRefs;

	// Give 2 bits since BOOL is signed
	BOOL		 bMarkedForDelete : 2;
	BOOL		 bOnStack : 2;
};

class REFERENCE
{
public:
	REFERENCE(REFCOUNT * _pRefCount) : pRefCount(_pRefCount) {pRefCount->AddRef();};
	~REFERENCE() {pRefCount->Release();};

private:
	REFCOUNT * pRefCount;
};

#endif // ! _REFERENC_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\h\refcount.hpp ===
/*
 * refcount.hpp - RefCount class description.
 *
 * Taken from URL code by ChrisPi 9-11-95
 *
 */

#ifndef _REFCOUNT_HPP_
#define _REFCOUNT_HPP_

/* Types
 ********/

// RefCount destructor callback function

typedef void (*OBJECTDESTROYEDPROC)(void);


/* Classes
 **********/

class RefCount
{
private:
   ULONG m_ulcRef;
   OBJECTDESTROYEDPROC m_ObjectDestroyed;

public:
   RefCount(OBJECTDESTROYEDPROC ObjectDestroyed);
   // Virtual destructor defers to destructor of derived class.
   virtual ~RefCount(void);

   // IUnknown methods

   ULONG STDMETHODCALLTYPE AddRef(void);
   ULONG STDMETHODCALLTYPE Release(void);

   // friends

#ifdef DEBUG

   friend BOOL IsValidPCRefCount(const RefCount *pcrefcnt);

#endif

};
DECLARE_STANDARD_TYPES(RefCount);

#endif // _REFCOUNT_HPP_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\h\pmwinp.h ===
// Dummy file to prevent dependancy errors.
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\h\resstr.h ===
/*
 * resstr.h - Common return code to string translation routines description.
 *
 * Taken from URL code by ChrisPi 9-11-95
 *
 */

#ifndef _RESSTR_H_
#define _RESSTR_H_

#include <nmutil.h>

/* Prototypes
 *************/

/* resstr.c */

#ifdef DEBUG

extern PCSTR NMINTERNAL GetINTString(int);
extern PCSTR NMINTERNAL GetINT_PTRString(INT_PTR);
extern PCSTR NMINTERNAL GetULONGString(ULONG);
extern PCSTR NMINTERNAL GetBOOLString(BOOL);
extern PCSTR NMINTERNAL GetPVOIDString(PVOID);
extern PCSTR NMINTERNAL GetClipboardFormatNameString(UINT);
extern PCSTR NMINTERNAL GetCOMPARISONRESULTString(COMPARISONRESULT);
extern PCSTR NMINTERNAL GetHRESULTString(HRESULT);

#endif   /* DEBUG */

#endif /* _RESSTR_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\h\regentry.h ===
/***************************************************************************/
/**                  Microsoft Windows                                    **/
/**            Copyright(c) Microsoft Corp., 1995-1996                    **/
/***************************************************************************/


/****************************************************************************

regentry.h

Oct. 95		LenS

Wrapper for registry access

Construct a RegEntry object by specifying the subkey (under
HKEY_CURRENT_USER by default, but can be overridden.)

All member functions (except the destructor) set an internal
error state which can be retrieved with GetError().
Zero indicates no error.

RegEntry works only with strings and DWORDS which are both set
using the overloaded function SetValue()

	SetValue("valuename", "string");
	SetValue("valuename", 42);
	
Values are retrieved with GetString() and GetNumber().  
GetNumber() allows you to specificy a default if the valuename doesn't
exist.
GetString() returns a pointer to a string internal to RegEntry that is 
invalidated when another fuction is called on the same RegEntry object
(e.g. its destructor) so, if you want to use the string beyond this
time, then you must copy it out of the RegEntry object first.

DeleteValue() removes the valuename and value pair.

Registry flushes are automatic when RegEntry is destroys or moves to
another key.

****************************************************************************/

#ifndef	REGENTRY_INC
#define	REGENTRY_INC

class RegEntry
{
	public:
		RegEntry(	LPCTSTR pszSubKey,
					HKEY hkey = HKEY_CURRENT_USER,
					BOOL fCreate = TRUE,
					REGSAM samDesired = 0
					);
		~RegEntry();
		
		long	GetError()	{ return m_error;}
		VOID	ClearError() {m_error = ERROR_SUCCESS;}
		long	SetValue(LPCTSTR pszValueName, LPCTSTR string);
		long	SetValue(LPCTSTR pszValueName, unsigned long dwNumber);
		long	SetValue(LPCTSTR pszValue, void* pData, DWORD cbLength);
		LPTSTR	GetString(LPCTSTR pszValueName);
		DWORD	GetBinary(LPCTSTR pszValueName, void** ppvData);
		long	GetNumber(LPCTSTR pszValueName, long dwDefault = 0);
		ULONG	GetNumberIniStyle(LPCTSTR pszValueName, ULONG dwDefault = 0);
		long	DeleteValue(LPCTSTR pszValueName);
		long	FlushKey();
        VOID    MoveToSubKey(LPCTSTR pszSubKeyName);
        HKEY    GetKey()    { return m_hkey; }

	private:
		VOID	ChangeKey(HKEY hNewKey);
		VOID	UpdateWrittenStatus();
		VOID	ResizeValueBuffer(DWORD length);

		HKEY	m_hkey;
		long	m_error;
        BOOL    m_fhkeyValid;
		LPBYTE  m_pbValueBuffer;
        DWORD   m_cbValueBuffer;
		BOOL	m_fValuesWritten;
		TCHAR	m_szNULL;
};

inline long 
RegEntry::FlushKey()
{
    if (m_fhkeyValid) {
		m_error = ::RegFlushKey(m_hkey);
    }
	return m_error;
}


class RegEnumValues
{
	public:
		RegEnumValues(RegEntry *pRegEntry);
		~RegEnumValues();
		long	Next();
		LPTSTR 	GetName()       {return m_pchName;}
        DWORD   GetType()       {return m_dwType;}
        LPBYTE  GetData()       {return m_pbValue;}
        DWORD   GetDataLength() {return m_dwDataLength;}
		DWORD	GetCount()      {return m_cEntries;}

	private:
        RegEntry * m_pRegEntry;
		DWORD   m_iEnum;
        DWORD   m_cEntries;
		LPTSTR  m_pchName;
		LPBYTE  m_pbValue;
        DWORD   m_dwType;
        DWORD   m_dwDataLength;
        DWORD   m_cMaxValueName;
        DWORD   m_cMaxData;
        LONG    m_error;
};

class RegEnumSubKeys
{
	public:
		RegEnumSubKeys(RegEntry *pRegEntry);
		~RegEnumSubKeys();
		long    Next();
		LPTSTR 	GetName()       {return m_pchName;}
		DWORD	GetCount()      {return m_cEntries;}

	protected:
        RegEntry * m_pRegEntry;
		DWORD   m_iEnum;
        DWORD   m_cEntries;
		LPTSTR  m_pchName;
        DWORD   m_cMaxKeyName;
        LONG    m_error;
};

#endif // REGENTRY_INC
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\h\rrcm_dll.h ===
/*
 * Filename: RRCM_DLL.H
 *
 * Description: Declares imported/exported RRCM functions.
 *
 * $Workfile:   rrcm_dll.h  $
 * $Author:   CMACIOCC  $
 * $Date:   14 Feb 1997 11:59:52  $
 * $Revision:   1.20  $
 * $Archive:   R:\rtp\src\include\rrcm_dll.h_v  $
 *
 * INTEL Corporation Proprietary Information
 * This listing is supplied under the terms of a license agreement with
 * Intel Corporation and may not be copied nor disclosed except in
 * accordance with the terms of that agreement.
 * Copyright (c) 1995 Intel Corporation.
 *
 */

#ifndef _RRCMDLL_H_
#define _RRCMDLL_H_

// force 8 byte structure packing
#include <pshpack8.h>

#if !defined (RRCMDLL)
//#define RRCMAPI __declspec (dllimport)
//#else
//#define RRCMAPI __declspec (dllexport)
#endif

#ifdef __cplusplus
extern "C" {
#endif


#define MAX_SDES_LEN			256
#define	MAX_ENCRYPT_KEY_SIZE	8
#define	NUM_COLLISION_ENTRIES	10
#define	MAX_ADDR_LEN			80


// RTCP SDES type
typedef enum {
	RTCP_SDES_END,
	RTCP_SDES_CNAME,
	RTCP_SDES_NAME,
	RTCP_SDES_EMAIL,
	RTCP_SDES_PHONE,
	RTCP_SDES_LOC,
	RTCP_SDES_TOOL,
	RTCP_SDES_TXT,
	RTCP_SDES_PRIV
	} RTCP_SDES_TYPE_T;


// RRCM events
typedef enum
	{
	RRCM_NO_EVENT,
	RRCM_NEW_SOURCE_EVENT,				// New SSRC detected
	RRCM_RECV_RTCP_RECV_REPORT_EVENT,	// RTCP RR received
	RRCM_RECV_RTCP_SNDR_REPORT_EVENT,	// RTCP SR received
	RRCM_LOCAL_COLLISION_EVENT,			// Collision detected
	RRCM_REMOTE_COLLISION_EVENT,		// Remote collision detected
	RRCM_TIMEOUT_EVENT,					// SSRC timed-out
	RRCM_BYE_EVENT,						// RTCP Bye received
	RRCM_RTCP_WS_RCV_ERROR,				// Winsock error on RTCP rcv
	RRCM_RTCP_WS_XMT_ERROR				// Winsock error on RTCP xmt
	} RRCM_EVENT_T;


// RRCM events callback
typedef void (*PRRCM_EVENT_CALLBACK) (RRCM_EVENT_T, DWORD_PTR, DWORD_PTR, DWORD_PTR);


// RRCM SSRC entry update
typedef enum
	{
	RRCM_UPDATE_SDES,
	RRCM_UPDATE_CALLBACK,
	RRCM_UPDATE_STREAM_FREQUENCY,
	RRCM_UPDATE_RTCP_STREAM_MIN_BW
	} RRCM_UPDATE_SSRC_ENTRY;


// RTP/RTCP session bits mask
#define	RTCP_DEST_LEARNED		0x00000001	// RTCP destination address known ?
#define	H323_CONFERENCE			0x00000002	// H.323 conference control
#define ENCRYPT_SR_RR			0x00000004	// Encrypt SR/RR
#define	RTCP_ON					0x00000008
#define NEW_RTCP_SESSION		0x00000010
#define RTCP_OFF				0x00000020
#define SHUTDOWN_IN_PROGRESS	0x80000000	// Shutdown in progress

// RTCP control
#define RRCM_CTRL_RTCP			0x00000000
#define RTCP_XMT_OFF			0x7FFFFFFF
#define RTCP_ONE_SEND_ONLY		0x80000000

//	RTCP SDES data
typedef struct _SDES_DATA
	{
	DWORD				dwSdesType;			// SDES type: CNAME/NAME/...
	char				sdesBfr[MAX_SDES_LEN];
	DWORD				dwSdesLength;		// SDES length
	DWORD				dwSdesFrequency;	// SDES frequency
	DWORD				dwSdesEncrypted;	// SDES encrypted Y/N ?
	} SDES_DATA, *PSDES_DATA;
	

// Encryption data
typedef struct _encryption_info
	{
	DWORD				dwEncryptType;			// DES/Triple DES/...
	DWORD				dwKeyLen;					// Encryption key length
	char				keyVal[MAX_ENCRYPT_KEY_SIZE];
	} ENCRYPT_INFO, *PENCRYPT_INFO;


//	Received sequence numbers/cycles.  Union allows access as combined
//	cycle/sequence number or as either field alone for optimizations
typedef struct _RTP_SEQUENCE
	{
	WORD	wSequenceNum;
	WORD	wCycle;
	} RTP_SEQUENCE, *PRTP_SEQUENCE;


typedef struct _RTP_SEQ_NUM
	{
	union {
		DWORD		dwXtndedHighSeqNumRcvd;	// Combined cycle/sequence number
		RTP_SEQUENCE RTPSequence;			// Cycle/sequence number separate
		} seq_union;
	} RTP_SEQ_NUM, *PRTP_SEQ_NUM;


//	Link list elements
typedef struct _LINK_LIST
	{
	struct _LINK_LIST 	*next;				// Next in list / Head of list
	struct _LINK_LIST	*prev;				// Previous in list	/ Tail of list
	} LINK_LIST, *PLINK_LIST, HEAD_TAIL, *PHEAD_TAIL;


//	Application provided buffer for RTCP to copy the raw RTCP report into
typedef struct _APP_RTCP_BFR
	{
	LINK_LIST			bfrList;			// Next/prev buffer in list		
	char				*bfr;
	DWORD				dwBfrLen;
	DWORD				dwBfrStatus;		// RTCP Operation on this Bfr
#define	RTCP_SR_ONLY	0x00000001			// Only copy RTCP packet
	DWORD				dwBytesRcvd;
	HANDLE				hBfrEvent;
	} APP_RTCP_BFR, *PAPP_RTCP_BFR;


// RTCP sender's feedback data structure
typedef struct _RTCP_FEEDBACK
	{
	DWORD		SSRC;
	DWORD		fractionLost:8;				// Fraction lost 				
	int  		cumNumPcktLost:24;			// Cumulative num of pckts lost
	RTP_SEQ_NUM	XtendedSeqNum;				// Xtnded highest seq. num rcvd	
	DWORD		dwInterJitter;				// Interarrival jitter 			
	DWORD		dwLastSR;					// Last sender report 			
	DWORD		dwDelaySinceLastSR;			// Delay since last SR 			
	DWORD		dwLastRcvRpt;				// Time of last Receive Report
	} RTCP_FEEDBACK, *PRTCP_FEEDBACK;


//	RTCPReportRequestEx bitmasks used to specify filter values
typedef enum
	{
	FLTR_SSRC	= 1,		// Filters report on SSRC value
	FLTR_CNAME,				// Filters report on CName
	FLTR_TIME_WITHIN		// Filters report receive within a time period
	} RRCM_RPT_FILTER_OPTION;


//	RTCP report data structure
typedef struct _RTCP_REPORT
	{
	// SSRC for this entry's information. Local SSRC if it's one of
	// are local stream, or a remote SSRC otherwise.
	DWORD				ssrc;				

	DWORD				status;
#define	LOCAL_SSRC_RPT						0x1
#define REMOTE_SSRC_RPT						0x2
#define	FEEDBACK_FOR_LOCAL_SSRC_PRESENT		0x4
	// LOCAL_SSRC_RPT identifies to the application that this entry is
	// one of our local stream.
	// Only 'dwSrcNumPcktRealTime & dwSrcNumByteRealTime' which
	// reflect the number of Pckt/byte transmitted are meaningful.

	// FEEDBACK_FOR_LOCAL_SSRC_PRESENT is set if the entry is for a
	// remote stream and if this remote stream has ever send us any
	// feedback about ourselve. Feedback send by the remote stream to
	// other SSRC are filtered out. Only feedback about ourselve is kept.

	// Number of Pckt/Byte send if this entry is for a local stream, or
	// number of Pckt/Byte received if this entry is for a remote stream
	// This counters are updated in real-time.
	DWORD				dwSrcNumPcktRealTime;
	DWORD				dwSrcNumByteRealTime;

	// This is the information we would be sending in a receiver report
	// for the stream identified by 'ssrc' if this 'ssrc' has been active
	// during the last report interval. This information is provided when the
	// API is queried, and will most likely be different than the one send
	// out by the receiver report. (RR will be send at some different time)
	DWORD				SrcFraction:8;
	int					SrcNumLost:24;
	DWORD				dwSrcXtndNum;
	DWORD				SrcJitter;
	DWORD				dwSrcLsr;
	DWORD				dwSrcDlsr;

	// This information has been received from 'ssrc' has part of an
	// RTCP sender report if 'ssrc' has been active, otherwise all 0s
	DWORD				dwSrcNumPckt;
	DWORD				dwSrcNumByte;
	DWORD				dwSrcNtpMsw;
	DWORD				dwSrcNtpLsw;
	DWORD				dwSrcRtpTs;

	// This is the feedback information about us from the SSRC identified
	// in the 'feedback' data structure. Currently we only store feedback
	// information about ourselve and we filter out feedback information
	// about additional streams. We'll have feedback information only if
	// our stream has been active. If our stream goes from active to inactive
	// the feedback information will be set, but not updated.
	RTCP_FEEDBACK		feedback;			

	// Generic information for the SSRC entry
	// Payload type for this SSRC. If a sender, it is assume that the
	// application knows what it is sending, and the type will be set
	// to 0. If a receiver, this is the last value seen on an RTP data packet
	DWORD				PayLoadType;		
	DWORD				dwStreamClock;			// Sampling frequency
    DWORD				dwLastReportRcvdTime;	// Time of last report rcvd
	char				fromAddr[MAX_ADDR_LEN];	
	DWORD				dwFromLen;			
	CHAR				cname[MAX_SDES_LEN];
	DWORD				dwCnameLen;
	CHAR				name[MAX_SDES_LEN];
	DWORD				dwNameLen;
	} RTCP_REPORT, *PRTCP_REPORT;



//----------------------------------------------------------------------------
//	ISDM Information
//----------------------------------------------------------------------------

#ifdef ENABLE_ISDM2

// RTCP Xmt information
typedef struct _XMIT_INFO_ISDM
	{
	DWORD		dwNumPcktSent;				// Number of packet sent 		
	DWORD		dwNumBytesSent;				// Number of bytes sent     	
	DWORD		dwNTPmsw;					// NTP most significant word	
	DWORD		dwNTPlsw;					// NTP least significant word	
	DWORD		dwRTPts;					// RTP timestamp				
	DWORD		dwCurXmtSeqNum;				// Current Xmt sequence number	
	DWORD		dwPrvXmtSeqNum;				// Previous Xmt sequence number
	DWORD		sessionBW;					// Session's bandwidth			
	DWORD		dwLastSR;					// Last sender report 			
	DWORD		dwLastSRLocalTime;			// Last sender report local time
	DWORD		dwLastSendRTPSystemTime;	// Last RTP packet send time
	DWORD		dwLastSendRTPTimeStamp;		// RTP timestamp of the last packet
	} XMIT_INFO_ISDM, *PXMIT_INFO_ISDM;



// RTCP receive information
typedef struct _RECV_INFO_ISDM
	{
	DWORD		dwNumPcktRcvd;				// Number of packet received	
	DWORD		dwPrvNumPcktRcvd;			// Previous number of pckt rcvd	
	DWORD		dwExpectedPrior;			// Number previously expected	
	DWORD		dwNumBytesRcvd;				// Number of bytes rcvd     	
	DWORD		dwBaseRcvSeqNum;			// Initial sequence number rcvd
	DWORD		dwBadSeqNum;				// Potential new valid seq num
	DWORD		dwProbation;				// # consec pkts for validation
	RTP_SEQ_NUM	XtendedSeqNum;				// Xtnded highest seq. num rcvd	
	DWORD		dwPropagationTime;			// Last packet's transmit time
	DWORD		interJitter;				// Interarrival jitter 			
	} RECV_INFO_ISDM, *PRECV_INFO_ISDM;


//----------------------------------------------------------------------------
// RTP/RTCP: Registry information under:
//----------------------------------------------------------------------------
#define szRRCMISDM			TEXT("RRCM_2")


// Structure used by new ISDM features

typedef struct _ISDM2_ENTRY
	{
	DWORD		SSRC;				// Source SSRC 			
	DWORD		dwSSRCStatus;		// Entry status
    #define XMITR   0x00000001
    #define RECVR   0x00000002

	DWORD		PayLoadType;		// Payload type for this SSRC
									// taken from the RTP header.

	// SSRC Transmit information
	// If on our transmit list, this is our SSRC information, and if on our
	// receive list, this is a SR feedback information.
    XMIT_INFO_ISDM	xmitinfo;

	// SSRC Receive information
	// If on our transmit list, this is undefined information, and if on our
	// receive list, this is the SSRC's receive information, ie, this SSRC
	// is an active sender somewhere on the network. This information is
	// maintained by RTP, and used by RTCP to generate RR.
	RECV_INFO_ISDM	rcvInfo;

	// Feedback information received about ourselve if we're an active source
	RTCP_FEEDBACK	rrFeedback;				// Feedback	information

    DWORD		dwLastReportRcvdTime;	// Time of last report received

	// SSRC SDES information
	SDES_DATA	cnameInfo;		// CNAME information
	SDES_DATA	nameInfo;		// NAME information

    // SSRC network address information
	int		fromLen;	        // From address length
	char	from[MAX_ADDR_LEN];	// From address
		
	DWORD		dwNumRptSent;		// Number of RTCP report sent	
	DWORD		dwNumRptRcvd;		// Number of RTCP report rcvd	
	DWORD		dwNumXmtIoPending;  // Number of transmit I/O pending
	DWORD		dwStreamClock;		// Sampling frequency

	} ISDM2_ENTRY, *PISDM2_ENTRY;

#endif // #ifdef ENABLE_ISDM2

//----------------------------------------------------------------------------
//	RTP/RTCP Error Codes
//----------------------------------------------------------------------------
#define	RRCM_NoError					NO_ERROR
#define	RTP_ERROR_BASE					0x8100
#define	RTCP_ERROR_BASE					0x8200

// Macro to create a custom HRESULT
// S: Severity Code
// C: Customer subsystem (TRUE)
// F: Facility code
// E: Error code
#define MAKE_RRCM_HRESULT(S,C,F,E)	\
((((DWORD)(S)<<31)|((DWORD)(C)<<29)|((DWORD)(F)<<16)|((DWORD)(E))))

// Custom facility codes
#define FACILITY_BASE              0x080
#define FACILITY_RRCM              (FACILITY_BASE+9)

// Sample macro to support custom error reporting //
#define MAKE_RRCM_ERROR(error)	\
MAKE_RRCM_HRESULT(SEVERITY_ERROR,TRUE,FACILITY_RRCM,error)

// RTP Error Codes
#define RRCMError_RTPReInit					RTP_ERROR_BASE
#define RRCMError_RTPResources				(RTP_ERROR_BASE+1)
#define RRCMError_RTPInvalidDelete			(RTP_ERROR_BASE+2)
#define RRCMError_RTPNoContext				(RTP_ERROR_BASE+3)
#define RRCMError_RTPSessResources			(RTP_ERROR_BASE+4)
#define RRCMError_RTPInvalid				(RTP_ERROR_BASE+5)
#define RRCMError_RTPInvSocket				(RTP_ERROR_BASE+6)
#define RRCMError_RTPSSRCNotFound			(RTP_ERROR_BASE+7)
#define RRCMError_RTCPCreateError			(RTP_ERROR_BASE+8)
#define RRCMError_RTPInvalidSession			(RTP_ERROR_BASE+9)
#define RRCMError_RTPStreamNotFound			(RTP_ERROR_BASE+10)
#define RRCMError_WinsockLibNotFound		(RTP_ERROR_BASE+11)
#define RRCMError_RTPNoSession				(RTCP_ERROR_BASE+12)


// RTCP Error Codes
#define	RRCMError_RTCPReInit				RTCP_ERROR_BASE
#define	RRCMError_RTCPResources				(RTCP_ERROR_BASE+1)
#define RRCMError_RTCPInvalidDelete			(RTCP_ERROR_BASE+2)
#define RRCMError_RTCPNoContext				(RTCP_ERROR_BASE+3)
#define RRCMError_RTCPInvalidRequest		(RTCP_ERROR_BASE+4)
#define RRCMError_RTCPheapError				(RTCP_ERROR_BASE+5)
#define RRCMError_RTCPThreadCreation		(RTCP_ERROR_BASE+6)
#define RRCMError_RTCPInvalidSession		(RTCP_ERROR_BASE+7)
#define RRCMError_RTCPNotimer				(RTCP_ERROR_BASE+8)
#define	RRCMError_RTCPMaxStreamPerSession	(RTCP_ERROR_BASE+9)
#define	RRCMError_RTCPInvalidSSRCentry		(RTCP_ERROR_BASE+10)
#define RRCMError_RTCPNoXmtList				(RTCP_ERROR_BASE+11)
#define RRCMError_RTCPNoCname				(RTCP_ERROR_BASE+12)
#define RRCMError_RTCPNotImpl				(RTCP_ERROR_BASE+13)

		

// RRCM Exported API
HANDLE WINAPI CreateRTPSession (SOCKET,
								  SOCKET,
								  LPVOID,
								  DWORD,
								  PSDES_DATA,
								  DWORD,
								  PENCRYPT_INFO,
								  DWORD,
								  PRRCM_EVENT_CALLBACK,
								  DWORD_PTR,
								  DWORD,
								  DWORD,
								  PDWORD);

HRESULT WINAPI CloseRTPSession (HANDLE,
							     PCHAR,
							     DWORD);

DWORD WINAPI RTPSendTo ( HANDLE,
						 SOCKET,
					     LPWSABUF,
					     DWORD,
					     LPDWORD,
					     int,
					     LPVOID,
					     int,
					     LPWSAOVERLAPPED,
					     LPWSAOVERLAPPED_COMPLETION_ROUTINE);

DWORD WINAPI RTPRecvFrom (SOCKET,
						   LPWSABUF,
						   DWORD,
						   LPDWORD,
						   LPDWORD,
						   PSOCKADDR,
						   LPINT,
						   LPWSAOVERLAPPED,
						   LPWSAOVERLAPPED_COMPLETION_ROUTINE);

HRESULT WINAPI RTCPReportRequest (SOCKET,
							       DWORD,
								   PDWORD,
								   PDWORD,
								   DWORD,
								   PRTCP_REPORT,
								   DWORD,
								   LPVOID,
								   DWORD);

HRESULT WINAPI getRtcpSessionList (PDWORD_PTR,
								    DWORD,
								    PDWORD);

DWORD WINAPI updateRTCPDestinationAddress (HANDLE,
	 										PSOCKADDR,
											int);

DWORD WINAPI getAnSSRC (void);

DWORD WINAPI RTCPThreadCtrl (DWORD);

HRESULT WINAPI RTCPSendSessionCtrl (DWORD_PTR,
									 DWORD);

HRESULT WINAPI updateSSRCentry ( HANDLE,
								 SOCKET,
							     DWORD,
							     DWORD,
							     DWORD);

HRESULT WINAPI addApplicationRtcpBfr (DWORD_PTR,
									   PAPP_RTCP_BFR);

PAPP_RTCP_BFR WINAPI removeApplicationRtcpBfr (DWORD_PTR);

#ifdef __cplusplus
}
#endif

// restore structure packing
#include <poppack.h>

#endif /* #ifndef _RRCMDLL_H_ */


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\h\sehcall.h ===
#ifndef NM_SEH_H
#define NM_SEH_H


// CallWithSEH is a utility function to call a function with structured exception handling

typedef DWORD (CALLBACK *INEXCEPTION)(LPEXCEPTION_RECORD per, PCONTEXT pctx);
typedef DWORD (CALLBACK *EXCEPTPROC)(void* pv);


#ifdef __cplusplus
extern "C" {
#endif

DWORD WINAPI CallWithSEH(EXCEPTPROC pfn, void* pv, INEXCEPTION InException);


#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\h\rostinfo.h ===
/***************************************************************************/
/**                  Microsoft Windows                                    **/
/**            Copyright(c) Microsoft Corp., 1995-1996                    **/
/***************************************************************************/

//
//	File:		RostInfo.h
//	Created:	ChrisPi		6/17/96
//	Modified:
//
//	The CRosterInfo class is defined, which is used for adding user
//  information to the T.120 roster
//

#ifndef _ROSTINFO_H_
#define _ROSTINFO_H_

#include <oblist.h>
typedef POSITION HROSTINFO;
typedef HROSTINFO* PHROSTINFO;

extern GUID g_csguidRostInfo;

static const WCHAR g_cwchRostInfoSeparator =	L'\0';
static const WCHAR g_cwchRostInfoTagSeparator =	L':';
static const WCHAR g_cwszIPTag[] =				L"TCP";
static const WCHAR g_cwszULSTag[] =				L"ULS";
static const WCHAR g_cwszULS_EmailTag[] =		L"EMAIL";
static const WCHAR g_cwszULS_LocationTag[] =	L"LOCATION";
static const WCHAR g_cwszULS_PhoneNumTag[] =	L"PHONENUM";
static const WCHAR g_cwszULS_CommentsTag[] =	L"COMMENTS";
static const WCHAR g_cwszVerTag[] =				L"VER";

class CRosterInfo
{
protected:
	// Attributes:
	COBLIST		m_ItemList;
	PVOID		m_pvSaveData;

	// Methods:
	UINT		GetSize();

public:
	// Methods:
				CRosterInfo() : m_pvSaveData(NULL) { };
				~CRosterInfo();
	HRESULT		AddItem(PCWSTR pcwszTag,
						PCWSTR pcwszData);
	HRESULT		ExtractItem(PHROSTINFO phRostInfo,
							PCWSTR pcwszTag,
							LPTSTR pszBuffer,
							UINT cbLength);
	HRESULT		Load(PVOID pvData);
	HRESULT		Save(PVOID* ppvData, PUINT pcbLength);

	BOOL        IsEmpty() {return m_ItemList.IsEmpty(); }

#ifdef DEBUG
	VOID		Dump();
#endif // DEBUG
};

#endif // _ROSTINFO_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\h\security.h ===
// This is the header file for conference security functions in common.lib
//
//	Created:	ClausGi	10-24-95
//

// Functions:
BOOL WINAPI HashPassword ( LPSTR szPasswd, LPBYTE lpBuffer, LPDWORD lpcbBuffer );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\h\shellp.h ===
#ifndef _SHELLP_H_
#define _SHELLP_H_

//
// Define API decoration for direct importing of DLL references.
//
#ifndef WINSHELLAPI
#if !defined(_SHELL32_)
#define WINSHELLAPI DECLSPEC_IMPORT
#else
#define WINSHELLAPI
#endif
#endif // WINSHELLAPI

//
// shell private header
//

#ifndef RC_INVOKED
#pragma pack(1)         /* Assume byte packing throughout */
#endif /* !RC_INVOKED */

#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif  /* __cplusplus */

//===========================================================================
#ifndef _SHSEMIP_H_
// Handle to property sheet extension array
DECLARE_HANDLE( HPSXA );
#endif // _SHSEMIP_H_

//===========================================================================
// Shell restrictions. (Parameter for SHRestriction)
typedef enum
{
	REST_NONE			= 0x00000000,
	REST_NORUN 			= 0x00000001,
	REST_NOCLOSE			= 0x00000002,
	REST_NOSAVESET			= 0x00000004,
	REST_NOFILEMENU 		= 0x00000008,
	REST_NOSETFOLDERS		= 0x00000010,
	REST_NOSETTASKBAR		= 0x00000020,
	REST_NODESKTOP			= 0x00000040,
	REST_NOFIND			= 0x00000080,
	REST_NODRIVES			= 0x00000100,
	REST_NODRIVEAUTORUN		= 0x00000200,
	REST_NODRIVETYPEAUTORUN		= 0x00000400,
	REST_NONETHOOD			= 0x00000800,
	REST_STARTBANNER		= 0x00001000,
	REST_RESTRICTRUN		= 0x00002000,
	REST_NOPRINTERTABS		= 0x00004000,
	REST_NOPRINTERDELETE		= 0x00008000,
	REST_NOPRINTERADD		= 0x00010000,
	REST_NOSTARTMENUSUBFOLDERS	= 0x00020000,
        REST_MYDOCSONNET                = 0x00040000,
        REST_NOEXITTODOS                = 0x00080000,
} RESTRICTIONS;

WINSHELLAPI HRESULT WINAPI CIDLData_CreateFromIDArray(LPCITEMIDLIST pidlFolder, UINT cidl, LPCITEMIDLIST apidl[], LPDATAOBJECT * ppdtobj);
WINSHELLAPI BOOL WINAPI SHIsBadInterfacePtr(LPCVOID pv, UINT cbVtbl);
//
// Stream API
//
WINSHELLAPI LPSTREAM WINAPI OpenRegStream(HKEY hkey, LPCSTR pszSubkey, LPCSTR pszValue, DWORD grfMode);
WINSHELLAPI LPSTREAM WINAPI OpenFileStream(LPCSTR szFile, DWORD grfMode);
//
// OLE ripoffs of Drag and Drop related API
//
WINSHELLAPI HRESULT WINAPI SHRegisterDragDrop(HWND hwnd, LPDROPTARGET pdtgt);
WINSHELLAPI HRESULT WINAPI SHRevokeDragDrop(HWND hwnd);
WINSHELLAPI HRESULT WINAPI SHDoDragDrop(HWND hwndOwner, LPDATAOBJECT pdata, LPDROPSOURCE pdsrc, DWORD dwEffect, LPDWORD pdwEffect);
//
// Special folder
//
WINSHELLAPI LPITEMIDLIST WINAPI SHCloneSpecialIDList(HWND hwndOwner, int nFolder, BOOL fCreate);
WINSHELLAPI BOOL WINAPI SHGetSpecialFolderPath(HWND hwndOwner, LPSTR lpszPath, int nFolder, BOOL fCreate);
// DiskFull
WINSHELLAPI void WINAPI SHHandleDiskFull(HWND hwnd, int idDrive);

//
// File Search APIS
//
WINSHELLAPI BOOL WINAPI SHFindFiles(LPCITEMIDLIST pidlFolder, LPCITEMIDLIST pidlSaveFile);
WINSHELLAPI BOOL WINAPI SHFindComputer(LPCITEMIDLIST pidlFolder, LPCITEMIDLIST pidlSaveFile);
//
//
WINSHELLAPI void WINAPI PathGetShortPath(LPSTR pszLongPath);
WINSHELLAPI BOOL WINAPI PathFindOnPath(LPSTR szFile, LPCSTR FAR * ppszOtherDirs);
WINSHELLAPI BOOL WINAPI PathYetAnotherMakeUniqueName(LPSTR  pszUniqueName, LPCSTR pszPath, LPCSTR pszShort, LPCSTR pszFileSpec);
//
WINSHELLAPI BOOL WINAPI Win32CreateDirectory(LPCSTR lpszPath, LPSECURITY_ATTRIBUTES lpsa);
WINSHELLAPI BOOL WINAPI Win32RemoveDirectory(LPCSTR lpszPath);
WINSHELLAPI BOOL WINAPI Win32DeleteFile(LPCSTR lpszPath);

// Convert an IDList into a logical IDList so that desktop folders	
// appear at the right spot in the tree					
WINSHELLAPI LPITEMIDLIST WINAPI SHLogILFromFSIL(LPCITEMIDLIST pidlFS);		

// Convert an ole string.
WINSHELLAPI BOOL WINAPI StrRetToStrN(LPSTR szOut, UINT uszOut, LPSTRRET pStrRet, LPCITEMIDLIST pidl);

WINSHELLAPI DWORD WINAPI SHWaitForFileToOpen(LPCITEMIDLIST pidl,
                               UINT uOptions, DWORD dwtimeout);
WINSHELLAPI HRESULT WINAPI SHGetRealIDL(LPSHELLFOLDER psf, LPCITEMIDLIST pidlSimple, LPITEMIDLIST FAR* ppidlReal);

WINSHELLAPI void WINAPI SetAppStartingCursor(HWND hwnd, BOOL fSet);

#define DECLAREWAITCURSOR  HCURSOR hcursor_wait_cursor_save
#define SetWaitCursor()   hcursor_wait_cursor_save = SetCursor(LoadCursor(NULL, IDC_WAIT))
#define ResetWaitCursor() SetCursor(hcursor_wait_cursor_save)

WINSHELLAPI DWORD WINAPI SHRestricted(RESTRICTIONS rest);
WINSHELLAPI LPVOID WINAPI SHGetHandlerEntry(LPCSTR szHandler, LPCSTR szProcName, HINSTANCE *lpModule);

WINSHELLAPI STDAPI SHCoCreateInstance(LPCSTR pszCLSID, const CLSID FAR * lpclsid,
	LPUNKNOWN pUnkOuter, REFIID riid, LPVOID FAR* ppv);
WINSHELLAPI BOOL  WINAPI SignalFileOpen(LPCITEMIDLIST pidl);
WINSHELLAPI LPITEMIDLIST WINAPI SHSimpleIDListFromPath(LPCSTR pszPath);
WINSHELLAPI int WINAPI SHCreateDirectory(HWND hwnd, LPCSTR pszPath);

WINSHELLAPI HPSXA SHCreatePropSheetExtArray( HKEY hKey, PCSTR pszSubKey, UINT max_iface );
WINSHELLAPI void SHDestroyPropSheetExtArray( HPSXA hpsxa );
WINSHELLAPI UINT SHAddFromPropSheetExtArray( HPSXA hpsxa, LPFNADDPROPSHEETPAGE lpfnAddPage, LPARAM lParam );
WINSHELLAPI UINT SHReplaceFromPropSheetExtArray( HPSXA hpsxa, UINT uPageID, LPFNADDPROPSHEETPAGE lpfnReplaceWith, LPARAM lParam );
WINSHELLAPI DWORD SHNetConnectionDialog(HWND hwnd, LPSTR pszRemoteName, DWORD dwType) ;
WINSHELLAPI STDAPI SHLoadOLE(LPARAM lParam);
WINSHELLAPI void WINAPI Desktop_UpdateBriefcaseOnEvent(HWND hwnd, UINT uEvent);

WINSHELLAPI HRESULT WINAPI SHCreateStdEnumFmtEtc(UINT cfmt, const FORMATETC afmt[], LPENUMFORMATETC * ppenumFormatEtc);

// Shell create link API
#define SHCL_USETEMPLATE	0x0001
#define SHCL_USEDESKTOP		0x0002
#define SHCL_CONFIRM		0x0004

WINSHELLAPI HRESULT WINAPI SHCreateLinks(HWND hwnd, LPCSTR pszDir, IDataObject *pDataObj, UINT fFlags, LPITEMIDLIST* ppidl);

//
// Interface pointer validation
//
#define IsBadInterfacePtr(pitf, ITF)  SHIsBadInterfacePtr(pitf, sizeof(ITF##Vtbl))

//===========================================================================
// Image dragging API (definitely private)
//===========================================================================

// stuff for doing auto scrolling
#define NUM_POINTS	3
typedef struct {	// asd
    int iNextSample;
    DWORD dwLastScroll;
    BOOL bFull;
    POINT pts[NUM_POINTS];
    DWORD dwTimes[NUM_POINTS];
} AUTO_SCROLL_DATA;

#define DAD_InitScrollData(pad) (pad)->bFull = FALSE, (pad)->iNextSample = 0, (pad)->dwLastScroll = 0

WINSHELLAPI BOOL WINAPI DAD_SetDragImage(HIMAGELIST him, POINT FAR* pptOffset);
WINSHELLAPI BOOL WINAPI DAD_DragEnter(HWND hwndTarget);
WINSHELLAPI BOOL WINAPI DAD_DragEnterEx(HWND hwndTarget, const POINT ptStart);
WINSHELLAPI BOOL WINAPI DAD_ShowDragImage(BOOL fShow);
WINSHELLAPI BOOL WINAPI DAD_DragMove(POINT pt);
WINSHELLAPI BOOL WINAPI DAD_DragLeave(void);
WINSHELLAPI BOOL WINAPI DAD_AutoScroll(HWND hwnd, AUTO_SCROLL_DATA *pad, const POINT *pptNow);
WINSHELLAPI BOOL WINAPI DAD_SetDragImageFromListView(HWND hwndLV, POINT ptOffset);

//===========================================================================
// Another block of private API
//===========================================================================

// indexes into the shell image lists (Shell_GetImageList) for default images
#define II_DOCNOASSOC   0         // document (blank page) (not associated)
#define II_DOCUMENT     1         // document (with stuff on the page)
#define II_APPLICATION  2         // application (exe, com, bat)
#define II_FOLDER       3         // folder (plain)
#define II_FOLDEROPEN   4         // folder (open)
// Startmenu images.							
#define II_STPROGS    	19						
#define II_STDOCS	20						
#define II_STSETNGS    	21						
#define II_STFIND    	22						
#define II_STHELP    	23						
#define II_STRUN  	24						
#define II_STSUSPD  	25						
#define II_STEJECT  	26						
#define II_STSHUTD    	27						
// More startmenu image.
#define II_STCPANEL	35
#define II_STSPROGS	36
#define II_STPRNTRS	37
#define II_STFONTS	38
#define II_STTASKBR	39
									
WINSHELLAPI BOOL  WINAPI Shell_GetImageLists(HIMAGELIST FAR *phiml, HIMAGELIST FAR *phimlSmall);
WINSHELLAPI void  WINAPI Shell_SysColorChange(void);
WINSHELLAPI int   WINAPI Shell_GetCachedImageIndex(LPCSTR pszIconPath, int iIconIndex, UINT uIconFlags);

WINSHELLAPI LRESULT WINAPI SHShellFolderView_Message(HWND hwndMain, UINT uMsg, LPARAM lParam);

// A usefull function in Defview for mapping idlist into index into system
// image list.  Optionally it can also look up the index of the selected
// icon.
WINSHELLAPI int WINAPI SHMapPIDLToSystemImageListIndex(LPSHELLFOLDER pshf, LPCITEMIDLIST pidl, int *piIndexSel);
//
// OLE string
//
WINSHELLAPI int WINAPI OleStrToStrN(LPSTR, int, LPCOLESTR, int);
WINSHELLAPI int WINAPI StrToOleStrN(LPOLESTR, int, LPCSTR, int);
WINSHELLAPI int WINAPI OleStrToStr(LPSTR, LPCOLESTR);
WINSHELLAPI int WINAPI StrToOleStr(LPOLESTR, LPCSTR);

//===========================================================================
// Useful macros
//===========================================================================
#define ResultFromShort(i)  ResultFromScode(MAKE_SCODE(SEVERITY_SUCCESS, 0, (USHORT)(i)))
#define ShortFromResult(r)  (short)SCODE_CODE(GetScode(r))


// Tray CopyData Messages
#define TCDM_APPBAR     0x00000000
#define TCDM_NOTIFY     0x00000001
#define TCDM_LOADINPROC 0x00000002


//===========================================================================
// IShellFolder::UIObject helper
//===========================================================================

STDAPI SHCreateDefExtIconKey(HKEY hkey, LPCSTR pszModule, int iIcon, int iIconOpen, UINT uFlags, LPEXTRACTICON FAR* pxiconOut);
STDAPI SHCreateDefExtIcon(LPCSTR pszModule, int iIcon, int iIconOpen, UINT uFlags, LPEXTRACTICON FAR* pxiconOut);

//
// BUGBUG: lParam for DFM_INVOKECOMMAND needs to be changed
// now it contains "args" but it should just contain the LPCMINVOKECOMMANDINFO
//                                  uMsg       wParam       lParam
#define DFM_MERGECONTEXTMENU         1      // uFlags       LPQCMINFO
#define DFM_INVOKECOMMAND            2      // idCmd        pszArgs
#define DFM_ADDREF                   3      // 0            0
#define DFM_RELEASE                  4      // 0            0
#define DFM_GETHELPTEXT              5      // idCmd,cchMax pszText
#define DFM_WM_MEASUREITEM           6      // ---from the message---
#define DFM_WM_DRAWITEM              7      // ---from the message---
#define DFM_WM_INITMENUPOPUP         8      // ---from the message---
#define DFM_VALIDATECMD              9      // idCmd        0
#define DFM_MERGECONTEXTMENU_TOP     10     // uFlags       LPQCMINFO

// Commands from DFM_INVOKECOMMAND when strings are passed in
#define DFM_CMD_DELETE		((WPARAM)-1)
#define DFM_CMD_MOVE		((WPARAM)-2)
#define DFM_CMD_COPY		((WPARAM)-3)
#define DFM_CMD_LINK		((WPARAM)-4)
#define DFM_CMD_PROPERTIES	((WPARAM)-5)
#define DFM_CMD_NEWFOLDER	((WPARAM)-6)
#define DFM_CMD_PASTE		((WPARAM)-7)
#define DFM_CMD_VIEWLIST	((WPARAM)-8)
#define DFM_CMD_VIEWDETAILS	((WPARAM)-9)
#define DFM_CMD_PASTELINK       ((WPARAM)-10)
#define DFM_CMD_PASTESPECIAL	((WPARAM)-11)
#define DFM_CMD_MODALPROP       ((WPARAM)-12)

typedef struct _QCMINFO	// qcm
{
    HMENU	hmenu;		// in
    UINT	indexMenu;	// in
    UINT	idCmdFirst;	// in/out
    UINT	idCmdLast;	// in
} QCMINFO, FAR* LPQCMINFO;

typedef HRESULT (CALLBACK FAR* LPFNDFMCALLBACK)(LPSHELLFOLDER psf,
						HWND hwndOwner,
						LPDATAOBJECT pdtobj,
						UINT uMsg,
						WPARAM wParam,
						LPARAM lParam);

STDAPI CDefFolderMenu_Create(LPCITEMIDLIST pidlFolder,
			     HWND hwndOwner,
			     UINT cidl, LPCITEMIDLIST FAR* apidl,
			     LPSHELLFOLDER psf,
			     LPFNDFMCALLBACK lpfn,
			     HKEY hkeyProgID, HKEY hkeyBaseProgID,
			     LPCONTEXTMENU FAR* ppcm);

void PASCAL CDefFolderMenu_MergeMenu(HINSTANCE hinst, UINT idMainMerge, UINT idPopupMerge,
	LPQCMINFO pqcm);
void PASCAL Def_InitFileCommands(ULONG dwAttr, HMENU hmInit, UINT idCmdFirst,
	BOOL bContext);
void PASCAL Def_InitEditCommands(ULONG dwAttr, HMENU hmInit, UINT idCmdFirst,
	LPDROPTARGET pdtgt, UINT fContext);
void NEAR PASCAL _SHPrettyMenu(HMENU hm);

//===========================================================================
// Default IShellView for IShellFolder
//===========================================================================

WINSHELLAPI HRESULT WINAPI SHCreateShellFolderView(LPSHELLFOLDER pshf, LPCITEMIDLIST pidl, LONG lEvent, LPSHELLVIEW FAR* ppsv);

// Menu ID's
#ifdef BUG_23171_FIXED
#define SFVIDM_FIRST			(FCIDM_SHVIEWLAST-0x0fff)
#else
// MENUEX currently cannot handle subtraction in the ID's, so we need
// to subtract for it.
#if (FCIDM_SHVIEWLAST != 0x7fff)
#error FCIDM_SHVIEWLAST has changed, so shellp.h needs to also
#endif
#define SFVIDM_FIRST			(0x7000)
#endif
#define SFVIDM_LAST			(FCIDM_SHVIEWLAST)

// Popup menu ID's used in merging menus
#define SFVIDM_MENU_ARRANGE	(SFVIDM_FIRST + 0x0001)
#define SFVIDM_MENU_VIEW	(SFVIDM_FIRST + 0x0002)
#define SFVIDM_MENU_SELECT	(SFVIDM_FIRST + 0x0003)

// TBINFO flags
#define TBIF_APPEND     0
#define TBIF_PREPEND    1
#define TBIF_REPLACE    2

typedef struct _TBINFO
{
    UINT        cbuttons;       // out
    UINT        uFlags;         // out (one of TBIF_ flags)
} TBINFO, FAR * LPTBINFO;

typedef struct _COPYHOOKINFO
{
    HWND hwnd;
    DWORD wFunc;
    DWORD wFlags;
    LPCSTR pszSrcFile;
    DWORD dwSrcAttribs;
    LPCSTR pszDestFile;
    DWORD dwDestAttribs;
} COPYHOOKINFO, *LPCOPYHOOKINFO;

typedef struct _DETAILSINFO
{
    LPCITEMIDLIST pidl;     // pidl to get details of
    // Note: do not change the order of these fields until IShellDetails
    //       has gone away!
    int fmt;                // LVCFMT_* value (header only)
    int cxChar;             // Number of "average" characters (header only)
    STRRET str;             // String information
} DETAILSINFO, *PDETAILSINFO;

//                               uMsg    wParam         lParam
#define DVM_MERGEMENU            1    // uFlags             LPQCMINFO
#define DVM_INVOKECOMMAND        2    // idCmd              0
#define DVM_GETHELPTEXT          3    // idCmd,cchMax       pszText
#define DVM_GETTOOLTIPTEXT       4    // idCmd,cchMax       pszText
#define DVM_GETBUTTONINFO        5    // 0                  LPTBINFO
#define DVM_GETBUTTONS           6    // idCmdFirst,cbtnMax LPTBBUTTON
#define DVM_INITMENUPOPUP        7    // idCmdFirst,nIndex  hmenu
#define DVM_SELCHANGE            8    // idCmdFirst,nItem   PDVSELCHANGEINFO
#define DVM_DRAWITEM             9    // idCmdFirst         pdis
#define DVM_MEASUREITEM         10    // idCmdFirst         pmis
#define DVM_EXITMENULOOP        11    // -                  -
#define DVM_RELEASE             12    // -                  lSelChangeInfo (ShellFolder private)
#define DVM_GETCCHMAX           13    // pidlItem           pcchMax
#define DVM_FSNOTIFY            14    // LPITEMIDLIST*      lEvent
#define DVM_WINDOWCREATED       15    // hwnd               PDVSELCHANGEINFO
#define DVM_WINDOWDESTROY       16    // hwnd               PDVSELCHANGEINFO
#define DVM_REFRESH             17    // -                  lSelChangeInfo
#define DVM_SETFOCUS            18    // -                  lSelChangeInfo
#define DVM_KILLFOCUS           19    // -                  -
#define DVM_QUERYCOPYHOOK	20    // -                  -
#define DVM_NOTIFYCOPYHOOK      21    // -                  LPCOPYHOOKINFO
#define DVM_NOTIFY		22    // idFrom		    LPNOTIFY
#define DVM_GETDETAILSOF        23    // iColumn            PDETAILSINFO
#define DVM_COLUMNCLICK         24    // iColumn            -
#define DVM_QUERYFSNOTIFY       25    // -                  FSNotifyEntry *
#define DVM_DEFITEMCOUNT        26    // -                  PINT
#define DVM_DEFVIEWMODE         27    // -                  PFOLDERVIEWMODE
#define DVM_UNMERGEMENU         28    // uFlags
#define DVM_INSERTITEM          29    // pidl               PDVSELCHANGEINFO
#define DVM_DELETEITEM          30    // pidl               PDVSELCHANGEINFO
#define DVM_UPDATESTATUSBAR     31    // -                  lSelChangeInfo
#define DVM_BACKGROUNDENUM      32
#define DVM_GETWORKINGDIR       33
#define DVM_GETCOLSAVESTREAM    34    // flags              IStream **
#define DVM_SELECTALL           35    //                    lSelChangeInfo
#define DVM_DIDDRAGDROP         36    // dwEffect           IDataObject *

typedef struct _DVSELCHANGEINFO {
    UINT uOldState;
    UINT uNewState;
    LPARAM lParamItem;
    LPARAM* plParam;
} DVSELCHANGEINFO, *PDVSELCHANGEINFO;

typedef HRESULT (CALLBACK FAR* LPFNVIEWCALLBACK)(LPSHELLVIEW psvOuter,
						LPSHELLFOLDER psf,
                                                HWND hwndMain,
                                                UINT uMsg,
                                                WPARAM wParam,
                                                LPARAM lParam);

// SHCreateShellFolderViewEx struct
typedef struct _CSFV
{
    UINT            cbSize;
    LPSHELLFOLDER   pshf;
    LPSHELLVIEW     psvOuter;
    LPCITEMIDLIST   pidl;
    LONG            lEvents;
    LPFNVIEWCALLBACK pfnCallback;       // No callback if NULL
    FOLDERVIEWMODE  fvm;
} CSFV, FAR * LPCSFV;

// Tell the FolderView to rearrange.  The lParam will be passed to
// IShellFolder::CompareIDs
#define SFVM_REARRANGE		0x00000001
#define ShellFolderView_ReArrange(_hwnd, _lparam) \
	(BOOL)SHShellFolderView_Message(_hwnd, SFVM_REARRANGE, _lparam)

// Get the last sorting parameter given to FolderView
#define SFVM_GETARRANGEPARAM	0x00000002
#define ShellFolderView_GetArrangeParam(_hwnd) \
	(LPARAM)SHShellFolderView_Message(_hwnd, SFVM_GETARRANGEPARAM, 0L)

// Add an OBJECT into the view (May need to add insert also)
#define SFVM_ADDOBJECT         0x00000003
#define ShellFolderView_AddObject(_hwnd, _pidl) \
	(LPARAM)SHShellFolderView_Message(_hwnd, SFVM_ADDOBJECT, (LPARAM)_pidl)

// Gets the count of objects in the view
#define SFVM_GETOBJECTCOUNT         0x00000004
#define ShellFolderView_GetObjectCount(_hwnd) \
	(LPARAM)SHShellFolderView_Message(_hwnd, SFVM_GETOBJECTCOUNT, (LPARAM)0)

// Returns a pointer to the Idlist associated with the specified index
// Returns NULL if at end of list.
#define SFVM_GETOBJECT         0x00000005
#define ShellFolderView_GetObject(_hwnd, _iObject) \
	(LPARAM)SHShellFolderView_Message(_hwnd, SFVM_GETOBJECT, _iObject)

// Remove an OBJECT into the view (This works by pidl, may need index also);
#define SFVM_REMOVEOBJECT         0x00000006
#define ShellFolderView_RemoveObject(_hwnd, _pidl) \
	(LPARAM)SHShellFolderView_Message(_hwnd, SFVM_REMOVEOBJECT, (LPARAM)_pidl)

// updates an object by passing in pointer to two PIDLS, the first
// is the old pidl, the second one is the one with update information.
#define SFVM_UPDATEOBJECT         0x00000007
#define ShellFolderView_UpdateObject(_hwnd, _ppidl) \
	(LPARAM)SHShellFolderView_Message(_hwnd, SFVM_UPDATEOBJECT, (LPARAM)_ppidl)

// Sets the redraw mode for the window that is displaying the information
#define SFVM_SETREDRAW           0x00000008
#define ShellFolderView_SetRedraw(_hwnd, fRedraw) \
	(LPARAM)SHShellFolderView_Message(_hwnd, SFVM_SETREDRAW, (LPARAM)fRedraw)

// Returns an array of the selected IDS to the caller.
//     lparam is a pointer to receive the idlists into
//     return value is the count of items in the array.
#define SFVM_GETSELECTEDOBJECTS 0x00000009
#define ShellFolderView_GetSelectedObjects(_hwnd, ppidl) \
	(LPARAM)SHShellFolderView_Message(_hwnd, SFVM_GETSELECTEDOBJECTS, (LPARAM)ppidl)

// Checks if the current drop is on the view window
//     lparam is unused
//     return value is TRUE if the current drop is upon the background of the
//         view window, FALSE otherwise
#define SFVM_ISDROPONSOURCE	0x0000000a
#define ShellFolderView_IsDropOnSource(_hwnd, _pdtgt) \
	(BOOL)SHShellFolderView_Message(_hwnd, SFVM_ISDROPONSOURCE, (LPARAM)_pdtgt)

// Moves the selected icons in the listview
//     lparam is a pointer to a drop target
//     return value is unused
#define SFVM_MOVEICONS		0x0000000b
#define ShellFolderView_MoveIcons(_hwnd, _pdt) \
	(void)SHShellFolderView_Message(_hwnd, SFVM_MOVEICONS, (LPARAM)(LPDROPTARGET)_pdt)

// Gets the start point of a drag-drop
//     lparam is a pointer to a point
//     return value is unused
#define SFVM_GETDRAGPOINT	0x0000000c
#define ShellFolderView_GetDragPoint(_hwnd, _ppt) \
	(BOOL)SHShellFolderView_Message(_hwnd, SFVM_GETDRAGPOINT, (LPARAM)(LPPOINT)_ppt)

// Gets the end point of a drag-drop
//     lparam is a pointer to a point
//     return value is unused
#define SFVM_GETDROPPOINT	0x0000000d
#define ShellFolderView_GetDropPoint(_hwnd, _ppt) \
	SHShellFolderView_Message(_hwnd, SFVM_GETDROPPOINT, (LPARAM)(LPPOINT)_ppt)

#define ShellFolderView_GetAnchorPoint(_hwnd, _fStart, _ppt) \
	(BOOL)((_fStart) ? ShellFolderView_GetDragPoint(_hwnd, _ppt) : ShellFolderView_GetDropPoint(_hwnd, _ppt))

typedef struct _SFV_SETITEMPOS
{
	LPCITEMIDLIST pidl;
	POINT pt;
} SFV_SETITEMPOS, FAR *LPSFV_SETITEMPOS;

// Sets the position of an item in the viewer
//     lparam is a pointer to a SVF_SETITEMPOS
//     return value is unused
#define SFVM_SETITEMPOS		0x0000000e
#define ShellFolderView_SetItemPos(_hwnd, _pidl, _x, _y) \
{	SFV_SETITEMPOS _sip = {_pidl, {_x, _y}}; \
	SHShellFolderView_Message(_hwnd, SFVM_SETITEMPOS, (LPARAM)(LPSFV_SETITEMPOS)&_sip);}

// Determines if a given drop target interface is the one being used for
// the background of the ShellFolderView (as opposed to an object in the
// view)
//     lparam is a pointer to a drop target interface
//     return value is TRUE if it is the background drop target, FALSE otherwise
#define SFVM_ISBKDROPTARGET	0x0000000f
#define ShellFolderView_IsBkDropTarget(_hwnd, _pdptgt) \
        (BOOL)SHShellFolderView_Message(_hwnd, SFVM_ISBKDROPTARGET, (LPARAM)(LPDROPTARGET)_pdptgt)

//  Notifies a ShellView when one of its objects get put on the clipboard
//  as a result of a menu command.
//
//  called by defcm.c when it does a copy/cut
//
//     lparam is the dwEffect (DROPEFFECT_MOVE, DROPEFFECT_COPY)
//     return value is void.
#define SFVM_SETCLIPBOARD       0x00000010
#define ShellFolderView_SetClipboard(_hwnd, _dwEffect) \
        (void)SHShellFolderView_Message(_hwnd, SFVM_SETCLIPBOARD, (LPARAM)(DWORD)(_dwEffect))


// sets auto arrange
#define SFVM_AUTOARRANGE        0x00000011
#define ShellFolderView_AutoArrange(_hwnd) \
        (void)SHShellFolderView_Message(_hwnd, SFVM_AUTOARRANGE, 0)

// sets snap to grid
#define SFVM_ARRANGEGRID        0x00000012
#define ShellFolderView_ArrangeGrid(_hwnd) \
        (void)SHShellFolderView_Message(_hwnd, SFVM_ARRANGEGRID, 0)

#define SFVM_GETAUTOARRANGE     0x00000013
#define ShellFolderView_GetAutoArrange(_hwnd) \
        (BOOL)SHShellFolderView_Message(_hwnd, SFVM_GETAUTOARRANGE, 0)

#define SFVM_GETSELECTEDCOUNT     0x00000014
#define ShellFolderView_GetSelectedCount(_hwnd) \
        (BOOL)SHShellFolderView_Message(_hwnd, SFVM_GETSELECTEDCOUNT, 0)

typedef struct {
    int cxSmall;
    int cySmall;
    int cxLarge;
    int cyLarge;
} ITEMSPACING, *LPITEMSPACING;

#define SFVM_GETITEMSPACING     0x00000015
#define ShellFolderView_GetItemSpacing(_hwnd, lpis) \
        (BOOL)SHShellFolderView_Message(_hwnd, SFVM_GETITEMSPACING, (LPARAM)lpis)

// Causes an object to be repainted
#define SFVM_REFRESHOBJECT      0x00000016
#define ShellFolderView_RefreshObject(_hwnd, _ppidl) \
        (LPARAM)SHShellFolderView_Message(_hwnd, SFVM_REFRESHOBJECT, (LPARAM)_ppidl)


#define SFVM_SETPOINTS           0x00000017
#define ShellFolderView_SetPoints(_hwnd, _pdtobj) \
        (void)SHShellFolderView_Message(_hwnd, SFVM_SETPOINTS, (LPARAM)_pdtobj)

// SVM_SELECTANDPOSITIONITEM lParam
typedef struct
{
	LPCITEMIDLIST pidl;	// relative pidl to the view
	UINT  uSelectFlags;	// select flags
        BOOL fMove; // if true, we should also move it to point pt
        POINT pt;
} SFM_SAP;

// shell view messages
#define SVM_SELECTITEM       		(WM_USER + 1)
#define SVM_MOVESELECTEDITEMS           (WM_USER + 2)
#define SVM_GETANCHORPOINT              (WM_USER + 3)
#define SVM_GETITEMPOSITION             (WM_USER + 4)
#define SVM_SELECTANDPOSITIONITEM       (WM_USER + 5)

// Heap tracking stuff.
#ifdef MEMMON
#ifndef INC_MEMMON
#define INC_MEMMON
#define LocalAlloc	SHLocalAlloc
#define LocalFree	SHLocalFree
#define LocalReAlloc	SHLocalReAlloc

WINSHELLAPI HLOCAL WINAPI SHLocalAlloc(UINT uFlags, UINT cb);
WINSHELLAPI HLOCAL WINAPI SHLocalReAlloc(HLOCAL hOld, UINT cbNew, UINT uFlags);
WINSHELLAPI HLOCAL WINAPI SHLocalFree(HLOCAL h);
#endif
#endif

//===========================================================================
// CDefShellFolder members (for easy subclassing)
//===========================================================================

// Single instance members
STDMETHODIMP_(ULONG) CSIShellFolder_AddRef(LPSHELLFOLDER psf) ;
STDMETHODIMP_(ULONG) CSIShellFolder_Release(LPSHELLFOLDER psf);

// Default implementation (no dependencies to the instance data)
STDMETHODIMP CDefShellFolder_QueryInterface(LPSHELLFOLDER psf, REFIID riid, LPVOID FAR* ppvObj);
STDMETHODIMP CDefShellFolder_BindToStorage(LPSHELLFOLDER psf, LPCITEMIDLIST pidl, LPBC pbc,
    			 REFIID riid, LPVOID FAR* ppvOut);
STDMETHODIMP CDefShellFolder_BindToObject(LPSHELLFOLDER psf, LPCITEMIDLIST pidl, LPBC pbc, REFIID riid, LPVOID FAR* ppvOut);
STDMETHODIMP CDefShellFolder_GetAttributesOf(LPSHELLFOLDER psf, UINT cidl, LPCITEMIDLIST FAR* apidl, ULONG FAR* rgfOut);
STDMETHODIMP CDefShellFolder_SetNameOf(LPSHELLFOLDER psf, HWND hwndOwner,
	LPCITEMIDLIST pidl, LPCOLESTR lpszName, DWORD dwReserved, LPITEMIDLIST FAR* ppidlOut);

// File Search APIS
WINSHELLAPI LPCONTEXTMENU WINAPI SHFind_InitMenuPopup(HMENU hmenu, HWND hwndOwner, UINT idCmdFirst, UINT idCmdLast);

WINSHELLAPI void WINAPI Control_RunDLL(HWND hwndStub, HINSTANCE hAppInstance, LPSTR lpszCmdLine, int nCmdShow);
// to add 16 bit pages to 32bit things.  hGlobal can be NULL
WINSHELLAPI UINT WINAPI SHAddPages16(HGLOBAL hGlobal, LPCSTR pszDllEntry, LPFNADDPROPSHEETPAGE pfnAddPage, LPARAM lParam);

WINSHELLAPI HRESULT WINAPI SHCreateShellFolderViewEx(LPCSFV pcsfv, LPSHELLVIEW FAR* ppsv);

//===========================================================================
// Defview related API and interface
//
//  Notes: At this point, we have no plan to publish this mechanism.
//===========================================================================

typedef struct _SHELLDETAILS
{
	int	fmt;		// LVCFMT_* value (header only)
	int	cxChar;		// Number of "average" characters (header only)
	STRRET	str;		// String information
} SHELLDETAILS, FAR *LPSHELLDETAILS;

#undef  INTERFACE
#define INTERFACE   IShellDetails

DECLARE_INTERFACE_(IShellDetails, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IShellDetails methods ***
    STDMETHOD(GetDetailsOf)(THIS_ LPCITEMIDLIST pidl, UINT iColumn, LPSHELLDETAILS pDetails) PURE;
    STDMETHOD(ColumnClick)(THIS_ UINT iColumn) PURE;
};

//
// Private QueryContextMenuFlag passed from DefView
//
#define CMF_DVFILE	 0x00010000	// "File" pulldown

//
// Functions to help the cabinets sync to each other
//  uOptions parameter to SHWaitForFileOpen
//
#define WFFO_WAITTIME 10000L

#define WFFO_ADD        0x0001
#define WFFO_REMOVE     0x0002
#define WFFO_WAIT       0x0004


// Common strings
#define STR_DESKTOPCLASS	"Progman"

//===========================================================================
// Helper functions for pidl allocation using the task allocator.
//
WINSHELLAPI HRESULT WINAPI SHILClone(LPCITEMIDLIST pidl, LPITEMIDLIST * ppidlOut);
WINSHELLAPI HRESULT WINAPI SHILCombine(LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2, LPITEMIDLIST * ppidlOut);
#define SHILFree(pidl)	SHFree(pidl)

WINSHELLAPI HRESULT WINAPI SHDllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID FAR* ppv);


#include <fsmenu.h>

//===========================================================================

//----------------------------------------------------------------------------
#define IsLFNDriveORD		119
WINSHELLAPI BOOL WINAPI IsLFNDrive(LPCSTR pszPath);
WINSHELLAPI int WINAPI SHOutOfMemoryMessageBox(HWND hwndOwner, LPSTR pszTitle, UINT fuStyle);
WINSHELLAPI BOOL WINAPI SHWinHelp(HWND hwndMain, LPCSTR lpszHelp, UINT usCommand, DWORD ulData);

WINSHELLAPI BOOL WINAPI RLBuildListOfPaths(void);

#define SHValidateUNCORD        173

#define VALIDATEUNC_NOUI        0x0002      // dont bring up stinking UI!
#define VALIDATEUNC_CONNECT     0x0001      // connect a drive letter
#define VALIDATEUNC_PRINT       0x0004      // validate as print share instead of disk share
#define VALIDATEUNC_VALID       0x0007      // valid flags


WINSHELLAPI BOOL WINAPI SHValidateUNC(HWND hwndOwner, LPSTR pszFile, UINT fConnect);

//----------------------------------------------------------------------------
#define OleStrToStrNORD			        78
#define SHCloneSpecialIDListORD		      	89
#define SHDllGetClassObjectORD		       128
#define SHLogILFromFSILORD			95
#define SHMapPIDLToSystemImageListIndexORD	77
#define SHShellFolderView_MessageORD		73
#define Shell_GetImageListsORD			71
#define SHGetSpecialFolderPathORD	       175
#define StrToOleStrNORD				79

#define ILCloneORD				18
#define ILCloneFirstORD				19
#define ILCombineORD				25
#define ILCreateFromPathORD			157
#define ILFindChildORD				24
#define ILFreeORD				155
#define ILGetNextORD				153
#define ILGetSizeORD				152
#define ILIsEqualORD				21
#define ILRemoveLastIDORD			17
#define PathAddBackslashORD			32
#define PathCombineORD				37
#define PathIsExeORD				43
#define PathMatchSpecORD			46
#define SHGetSetSettingsORD			68
#define SHILCreateFromPathORD			28

#define SHFreeORD				195
#define MemMon_FreeORD				123

//
// Storage name of a scrap/bookmark item
//
#define WSTR_SCRAPITEM L"\003ITEM000"

//
//  PifMgr Thunked APIs (in SHELL.DLL)
//
extern int  WINAPI PifMgr_OpenProperties(LPCSTR lpszApp, LPCSTR lpszPIF, int hInf, int flOpt);
extern int  WINAPI PifMgr_GetProperties(int hProps, LPCSTR lpszGroup, LPVOID lpProps, int cbProps, int flOpt);
extern int  WINAPI PifMgr_SetProperties(int hProps, LPCSTR lpszGroup, const VOID FAR *lpProps, int cbProps, int flOpt);
extern int  WINAPI PifMgr_CloseProperties(int hProps, int flOpt);

//
// exported from SHSCRAP.DLL
//
#define SCRAP_CREATEFROMDATAOBJECT "Scrap_CreateFromDataObject"
typedef HRESULT (WINAPI FAR * LPFNSCRAPCREATEFROMDATAOBJECT)(LPCSTR pszPath, LPDATAOBJECT pDataObj, BOOL fLink, LPSTR pszNewFile);
extern HRESULT WINAPI Scrap_CreateFromDataObject(LPCSTR pszPath, LPDATAOBJECT pDataObj, BOOL fLink, LPSTR pszNewFile);

WINSHELLAPI void WINAPI SHSetInstanceExplorer(IUnknown *punk);

// Always use TerminateThreadEx.
BOOL APIENTRY TerminateThreadEx(HANDLE hThread, DWORD dwExitCode, BOOL bCleanupFlag);
#define TerminateThread(hThread, dwExitCode) TerminateThreadEx(hThread, dwExitCode, TRUE)

//===========================================================================
#ifdef __cplusplus
}
#endif  /* __cplusplus */

#ifndef RC_INVOKED
#pragma pack()
#endif  /* !RC_INVOKED */

#endif // _SHELLP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\h\shguidp.h ===
//
// CLSIDs of shell object classes. They don't have to be in a public header
// unless we decided to let ISVs to create shell objects directly by calling
// OleCreateInstance with one of class IDs.
//
// NOTE: those that are commented out are ready to be used again...
//

DEFINE_GUID(CLSID_ShellNetwork,        	0x208D2C60, 0x3AEA, 0x1069, 0xA2,0xD7,0x08,0x00,0x2B,0x30,0x30,0x9D);//208D2C60-3AEA-1069-A2D7-08002B30309D
DEFINE_GUID(CLSID_ShellDrives,         	0x20D04FE0, 0x3AEA, 0x1069, 0xA2,0xD8,0x08,0x00,0x2B,0x30,0x30,0x9D);//20D04FE0-3AEA-1069-A2D8-08002B30309D

// do this so that we don't break anyone's build by pulling it out
#ifndef NO_CLSID_ShellFolder
DEFINE_GUID(CLSID_ShellFolder,         	0x210A4BA0, 0x3AEA, 0x1069, 0xA2,0xD9,0x08,0x00,0x2B,0x30,0x30,0x9D);//210A4BA0-3AEA-1069-A2D9-08002B30309D
#endif

// DEFINE_GUID(CLSID_,                 	0x21444760, 0x3AEA, 0x1069, 0xA2,0xDA,0x08,0x00,0x2B,0x30,0x30,0x9D);//21444760-3AEA-1069-A2DA-08002B30309D
DEFINE_GUID(CLSID_ShellCopyHook,       	0x217FC9C0, 0x3AEA, 0x1069, 0xA2,0xDB,0x08,0x00,0x2B,0x30,0x30,0x9D);//217FC9C0-3AEA-1069-A2DB-08002B30309D
DEFINE_GUID(CLSID_ShellFileDefExt,     	0x21B22460, 0x3AEA, 0x1069, 0xA2,0xDC,0x08,0x00,0x2B,0x30,0x30,0x9D);//21B22460-3AEA-1069-A2DC-08002B30309D
DEFINE_GUID(CLSID_ShellDrvDefExt,      	0x5F5295E0, 0x429F, 0x1069, 0xA2,0xE2,0x08,0x00,0x2B,0x30,0x30,0x9D);//5F5295E0-429F-1069-A2E2-08002B30309D
DEFINE_GUID(CLSID_ShellNetDefExt,       0x86422020, 0x42A0, 0x1069, 0xA2,0xE5,0x08,0x00,0x2B,0x30,0x30,0x9D);//86422020-42A0-1069-A2E5-08002B30309D
DEFINE_GUID(CLSID_CCommonShellExtInit, 	0xA2AD3100, 0x3B84, 0x1069, 0xA2,0xDF,0x08,0x00,0x2B,0x30,0x30,0x9D);//A2AD3100-3B84-1069-A2DF-08002B30309D
DEFINE_GUID(CLSID_Briefcase,           	0x85BBD920, 0x42A0, 0x1069, 0xA2,0xE4,0x08,0x00,0x2B,0x30,0x30,0x9D);//85BBD920-42A0-1069-A2E4-08002B30309D
//DEFINE_GUID(CLSID_ShellMoniker,        	0x86747AC0, 0x42A0, 0x1069, 0xA2,0xE6,0x08,0x00,0x2B,0x30,0x30,0x9D);//86747AC0-42A0-1069-A2E6-08002B30309D
DEFINE_GUID(CLSID_Clouds,               0x869DADA0, 0x42A0, 0x1069, 0xA2,0xE7,0x08,0x00,0x2B,0x30,0x30,0x9D);//869DADA0-42A0-1069-A2E7-08002B30309D   // secret credits object
//DEFINE_GUID(CLSID_ShellIDMoniker,      	0x86C86720, 0x42A0, 0x1069, 0xA2,0xE8,0x08,0x00,0x2B,0x30,0x30,0x9D);//86C86720-42A0-1069-A2E8-08002B30309D   // shellidmoniker
DEFINE_GUID(CLSID_PifProperties,        0x86F19A00, 0x42A0, 0x1069, 0xA2,0xE9,0x08,0x00,0x2B,0x30,0x30,0x9D);//86F19A00-42A0-1069-A2E9-08002B30309D   // pifprops
DEFINE_GUID(CLSID_ShellFSFolder, 	0xF3364BA0, 0x65B9, 0x11CE, 0xA9,0xBA,0x00,0xAA,0x00,0x4A,0xE8,0x37);// F3364BA0-65B9-11CE-A9BA-00AA004AE837
// DEFINE_GUID(CLSID_, 	               	0x871C5380, 0x42A0, 0x1069, 0xA2,0xEA,0x08,0x00,0x2B,0x30,0x30,0x9D);//871C5380-42A0-1069-A2EA-08002B30309D   // shelllink
DEFINE_GUID(CLSID_ShellViewerExt,      	0x84F26EA0, 0x42A0, 0x1069, 0xA2,0xE3,0x08,0x00,0x2B,0x30,0x30,0x9D);//871C5380-42A0-1069-A2EA-08002B30309D   // shelllink
DEFINE_GUID(CLSID_ShellBitBucket,	0x645FF040, 0x5081, 0x101B, 0x9F,0x08,0x00,0xAA,0x00,0x2F,0x95,0x4E);//645FF040-5081-101B-9F08-00AA002F954E
DEFINE_GUID(CLSID_CControls,		0x21EC2020, 0x3AEA, 0x1069, 0xA2,0xDD,0x08,0x00,0x2B,0x30,0x30,0x9D);
DEFINE_GUID(CLSID_CPrinters,		0x2227A280, 0x3AEA, 0x1069, 0xA2,0xDE,0x08,0x00,0x2B,0x30,0x30,0x9D);
DEFINE_GUID(CLSID_Remote,               0x992CFFA0, 0xF557, 0x101A, 0x88,0xEC,0x00,0xDD,0x01,0x0C,0xCC,0x48);
DEFINE_GUID(CLSID_ShellFindExt,         0x61E218E0, 0x65D3, 0x101B, 0x9F,0x08,0x06,0x1C,0xEA,0xC3,0xD5,0x0D);//61E218E0-65D3-101B-9F08-061CEAC3D50D
DEFINE_GUID(CLSID_CFonts,		0xBD84B380, 0x8CA2, 0x1069, 0xAB,0x1D,0x08,0x00,0x09,0x48,0xF5,0x34);//bd84b380-8ca2-1069-ab1d-08000948f534
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\h\shlobjp.h ===
HRESULT CALLBACK CShellFileDefExt_CreateInstance(LPUNKNOWN, REFIID, LPVOID *);
HRESULT CALLBACK CShellDrvDefExt_CreateInstance(LPUNKNOWN, REFIID, LPVOID *);
HRESULT CALLBACK CShellNetDefExt_CreateInstance(LPUNKNOWN, REFIID, LPVOID *);
HRESULT CALLBACK CDrives_CreateInstance(LPUNKNOWN, REFIID, LPVOID *);
HRESULT CALLBACK CTray_CreateInstance(LPUNKNOWN, REFIID, LPVOID *);
HRESULT CALLBACK CDesktop_CreateInstance(LPUNKNOWN, REFIID, LPVOID *);
HRESULT CALLBACK CBriefcase_CreateInstance(LPUNKNOWN, REFIID, LPVOID *);
HRESULT CALLBACK CRecycleBin_CreateInstance(LPUNKNOWN, REFIID, LPVOID *);
HRESULT CALLBACK CNetwork_CreateInstance(LPUNKNOWN, REFIID, LPVOID *);
HRESULT CALLBACK CShellCopyHook_CreateInstance(LPUNKNOWN, REFIID , LPVOID *);
HRESULT CALLBACK CShellLink_CreateInstance(LPUNKNOWN, REFIID, LPVOID *);
HRESULT CALLBACK CControls_CreateInstance(LPUNKNOWN, REFIID , LPVOID * );
HRESULT CALLBACK CPrinters_CreateInstance(LPUNKNOWN, REFIID , LPVOID * );
HRESULT CALLBACK CShellViewerExt_CreateInstance(LPUNKNOWN, REFIID , LPVOID * );
HRESULT CALLBACK CShellBitBucket_CreateInstance(LPUNKNOWN, REFIID , LPVOID * );
HRESULT CALLBACK CShellFindExt_CreateInstance(LPUNKNOWN, REFIID , LPVOID * );
HRESULT CALLBACK CProxyPage_CreateInstance(LPUNKNOWN, REFIID, LPVOID *);
HRESULT CALLBACK CScrapData_CreateInstance(LPUNKNOWN, REFIID, LPVOID *);
HRESULT CALLBACK CFSFolder_CreateInstance(LPUNKNOWN, REFIID, LPVOID *);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\h\shell2.h ===
#include <shlobj.h>         // ;Internal
#include <shellapi.h>       // ;Internal
						/* ;Internal */
#ifndef _SHSEMIP_H_
#define _SHSEMIP_H_

//
// Define API decoration for direct importing of DLL references.
//
#ifndef WINSHELLAPI
#if !defined(_SHELL32_)
#define WINSHELLAPI DECLSPEC_IMPORT
#else
#define WINSHELLAPI
#endif
#endif // WINSHELLAPI

#ifndef RC_INVOKED
#pragma pack(1)         /* Assume byte packing throughout */
#endif /* !RC_INVOKED */

#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif  /* __cplusplus */


#ifndef DONT_WANT_SHELLDEBUG
    
#ifndef DebugMsg                                                                /* ;Internal */
#define DM_TRACE    0x0001      // Trace messages                               /* ;Internal */
#define DM_WARNING  0x0002      // Warning                                      /* ;Internal */
#define DM_ERROR    0x0004      // Error                                        /* ;Internal */
#define DM_ASSERT   0x0008      // Assertions                                   /* ;Internal */
#define Assert(f)                                                               /* ;Internal */
#define AssertE(f)      (f)                                                     /* ;Internal */
#define AssertMsg   1 ? (void)0 : (void)                                        /* ;Internal */
#define DebugMsg    1 ? (void)0 : (void)                                        /* ;Internal */
#endif                                                                          /* ;Internal */
                                                                                /* ;Internal */
#endif
    
//====== Ranges for WM_NOTIFY codes ==================================
// If a new set of codes is defined, make sure the range goes   /* ;Internal */
// here so that we can keep them distinct                       /* ;Internal */
// Note that these are defined to be unsigned to avoid compiler warnings  
// since NMHDR.code is declared as UINT.
//
// NM_FIRST - NM_LAST defined in commctrl.h (0U-0U) - (OU-99U)
//
// LVN_FIRST - LVN_LAST defined in commctrl.h (0U-100U) - (OU-199U)
//
// PSN_FIRST - PSN_LAST defined in prsht.h (0U-200U) - (0U-299U)
//
// HDN_FIRST - HDN_LAST defined in commctrl.h (0U-300U) - (OU-399U)
//
// TVN_FIRST - TVN_LAST defined in commctrl.h (0U-400U) - (OU-499U)

// TTN_FIRST - TTN_LAST defined in commctrl.h (0U-520U) - (OU-549U)

#define RFN_FIRST       (0U-510U) // run file dialog notify
#define RFN_LAST        (0U-519U)

#define SEN_FIRST       (0U-550U)       // ;Internal
#define SEN_LAST        (0U-559U)       // ;Internal


#define MAXPATHLEN      MAX_PATH        // ;Internal
    
    
//===========================================================================
// ITEMIDLIST
//===========================================================================

WINSHELLAPI LPITEMIDLIST  WINAPI ILGetNext(LPCITEMIDLIST pidl);
WINSHELLAPI UINT          WINAPI ILGetSize(LPCITEMIDLIST pidl);
WINSHELLAPI LPITEMIDLIST  WINAPI ILCreate(void);
WINSHELLAPI LPITEMIDLIST  WINAPI ILAppendID(LPITEMIDLIST pidl, LPCSHITEMID pmkid, BOOL fAppend);
WINSHELLAPI void          WINAPI ILFree(LPITEMIDLIST pidl);
WINSHELLAPI void          WINAPI ILGlobalFree(LPITEMIDLIST pidl);
WINSHELLAPI LPITEMIDLIST  WINAPI ILCreateFromPath(LPCSTR szPath);
WINSHELLAPI BOOL          WINAPI ILGetDisplayName(LPCITEMIDLIST pidl, LPSTR pszName);
WINSHELLAPI LPITEMIDLIST  WINAPI ILFindLastID(LPCITEMIDLIST pidl);
WINSHELLAPI BOOL          WINAPI ILRemoveLastID(LPITEMIDLIST pidl);
WINSHELLAPI LPITEMIDLIST  WINAPI ILClone(LPCITEMIDLIST pidl);
WINSHELLAPI LPITEMIDLIST  WINAPI ILCloneFirst(LPCITEMIDLIST pidl);
WINSHELLAPI LPITEMIDLIST  WINAPI ILGlobalClone(LPCITEMIDLIST pidl);
WINSHELLAPI BOOL          WINAPI ILIsEqual(LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2);
WINSHELLAPI BOOL          WINAPI ILIsEqualItemID(LPCSHITEMID pmkid1, LPCSHITEMID pmkid2);
WINSHELLAPI BOOL          WINAPI ILIsParent(LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2, BOOL fImmediate);
WINSHELLAPI LPITEMIDLIST  WINAPI ILFindChild(LPCITEMIDLIST pidlParent, LPCITEMIDLIST pidlChild);
WINSHELLAPI LPITEMIDLIST  WINAPI ILCombine(LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2);
WINSHELLAPI HRESULT       WINAPI ILLoadFromStream(LPSTREAM pstm, LPITEMIDLIST *pidl);
WINSHELLAPI HRESULT       WINAPI ILSaveToStream(LPSTREAM pstm, LPCITEMIDLIST pidl);
WINSHELLAPI HRESULT       WINAPI ILLoadFromFile(HFILE hfile, LPITEMIDLIST *pidl);
WINSHELLAPI HRESULT       WINAPI ILSaveToFile(HFILE hfile, LPCITEMIDLIST pidl);
WINSHELLAPI LPITEMIDLIST  WINAPI _ILCreate(UINT cbSize);	

WINSHELLAPI HRESULT       WINAPI SHILCreateFromPath(LPCSTR szPath, LPITEMIDLIST *ppidl, DWORD *rgfInOut);

// helper macros
#define ILIsEmpty(pidl)	((pidl)->mkid.cb==0)
#define IsEqualItemID(pmkid1, pmkid2)	(memcmp(pmkid1, pmkid2, (pmkid1)->cb)==0)
#define ILCreateFromID(pmkid)   ILAppendID(NULL, pmkid, TRUE)

// unsafe macros
#define _ILSkip(pidl, cb)	((LPITEMIDLIST)(((BYTE*)(pidl))+cb))
#define _ILNext(pidl)		_ILSkip(pidl, (pidl)->mkid.cb)

/*
 * The SHObjectProperties API provides an easy way to invoke
 *   the Properties context menu command on shell objects.
 *
 *   PARAMETERS
 *
 *     hwndOwner    The window handle of the window which will own the dialog
 *     dwType       A SHOP_ value as defined below
 *     lpObject     Name of the object, see SHOP_ values below
 *     lpPage       The name of the property sheet page to open to or NULL.
 *
 *   RETURN
 *
 *     TRUE if the Properties command was invoked
 */
WINSHELLAPI BOOL WINAPI SHObjectProperties(HWND hwndOwner, DWORD dwType, LPCSTR lpObject, LPCSTR lpPage);

#define SHOP_PRINTERNAME 1  // lpObject points to a printer friendly name
#define SHOP_FILEPATH    2  // lpObject points to a fully qualified path+file name
#define SHOP_TYPEMASK   0x00000003
#define SHOP_MODAL	0x80000000




//====== ShellMessageBox ================================================
                                                                         
// If lpcTitle is NULL, the title is taken from hWnd                     
// If lpcText is NULL, this is assumed to be an Out Of Memory message    
// If the selector of lpcTitle or lpcText is NULL, the offset should be a
//     string resource ID                                                
// The variable arguments must all be 32-bit values (even if fewer bits  
//     are actually used)                                                
// lpcText (or whatever string resource it causes to be loaded) should   
//     be a formatting string similar to wsprintf except that only the   
//     following formats are available:                                  
//         %%              formats to a single '%'                        
//         %nn%s           the nn-th arg is a string which is inserted    
//         %nn%ld          the nn-th arg is a DWORD, and formatted decimal
//         %nn%lx          the nn-th arg is a DWORD, and formatted hex    
//     note that lengths are allowed on the %s, %ld, and %lx, just        
//                         like wsprintf /* ;Internal */                  
//                                                                        
int _cdecl ShellMessageBox(HINSTANCE hAppInst, HWND hWnd, LPCSTR      
        lpcText, LPCSTR lpcTitle, UINT fuStyle, ...);                                               
                                                                          
//===================================================================    
// Smart tiling API's                                                   
WINSHELLAPI WORD WINAPI ArrangeWindows(HWND hwndParent, WORD flags, LPCRECT lpRect, WORD chwnd, const HWND *ahwnd);                             


//
// Flags for SHGetSetSettings
//
typedef struct {
    BOOL fShowAllObjects : 1;
    BOOL fShowExtensions : 1;
    BOOL fNoConfirmRecycle : 1;
    UINT fRestFlags : 13;

    LPSTR pszHiddenFileExts;
    UINT cbHiddenFileExts;
} SHELLSTATE, *LPSHELLSTATE;

#define SSF_SHOWALLOBJECTS 0x0001
#define SSF_SHOWEXTENSIONS 0x0002
#define SSF_HIDDENFILEEXTS 0x0004
#define SSF_NOCONFIRMRECYCLE 0x8000

//
// for SHGetNetResource
//
typedef HANDLE HNRES;

//
// For SHCreateDefClassObject
//
typedef HRESULT (CALLBACK *LPFNCREATEINSTANCE)(LPUNKNOWN pUnkOuter, REFIID riid, LPVOID *ppvObject);

                                                                          
typedef void (WINAPI FAR* RUNDLLPROC)(HWND hwndStub,                      
        HINSTANCE hAppInstance,                                           
        LPSTR lpszCmdLine, int nCmdShow);                                 



//======================================================================= 
// String constants for                                                   
//  1. Registration database keywords       (prefix STRREG_)              
//  2. Exported functions from handler dlls (prefix STREXP_)              
//  3. .INI file keywords                   (prefix STRINI_)              
//  4. Others                               (prefix STR_)                 
//======================================================================= 
#define STRREG_SHELLUI          "ShellUIHandler"                          
#define STRREG_SHELL            "Shell"                                   
#define STRREG_DEFICON          "DefaultIcon"                             
#define STRREG_SHEX             "shellex"                                
#define STRREG_SHEX_PROPSHEET   STRREG_SHEX "\\PropertySheetHandlers"     
#define STRREG_SHEX_DDHANDLER   STRREG_SHEX "\\DragDropHandlers"              
#define STRREG_SHEX_MENUHANDLER STRREG_SHEX "\\ContextMenuHandlers"           
#define STRREG_SHEX_COPYHOOK    "Directory\\" STRREG_SHEX "\\CopyHookHandlers"
#define STRREG_SHEX_PRNCOPYHOOK "Printers\\" STRREG_SHEX "\\CopyHookHandlers" 
                                                                         
#define STREXP_CANUNLOAD        "DllCanUnloadNow"       // From OLE 2.0  
                                                                         
#define STRINI_CLASSINFO        ".ShellClassInfo"       // secton name   
#define STRINI_SHELLUI          "ShellUIHandler"                         
#define STRINI_OPENDIRICON      "OpenDirIcon"                            
#define STRINI_DIRICON          "DirIcon"                                
                                                                         
#define STR_DESKTOPINI          "desktop.ini"                            
                                                                         
// Maximum length of a path string
#define CCHPATHMAX      MAX_PATH
#define MAXSPECLEN      MAX_PATH
#define DRIVEID(path)   ((path[0] - 'A') & 31)
#define ARRAYSIZE(a)    (sizeof(a)/sizeof(a[0]))


#define PATH_CCH_EXT    64
// PathResolve flags							
#define PRF_VERIFYEXISTS	    0x0001				
#define PRF_TRYPROGRAMEXTENSIONS    (0x0002 | PRF_VERIFYEXISTS)		
#define PRF_FIRSTDIRDEF		    0x0004
#define PRF_DONTFINDLNK		    0x0008	// if PRF_TRYPROGRAMEXTENSIONS is specified




//
// For CallCPLEntry16
//
DECLARE_HANDLE(FARPROC16);

// Needed for RunFileDlg
#define RFD_NOBROWSE		0x00000001
#define RFD_NODEFFILE		0x00000002
#define RFD_USEFULLPATHDIR	0x00000004
#define RFD_NOSHOWOPEN          0x00000008

#ifdef RFN_FIRST
#define RFN_EXECUTE             (RFN_FIRST - 0)
typedef struct {
    NMHDR hdr;
    LPCSTR lpszCmd;
    LPCSTR lpszWorkingDir;
    int nShowCmd;
} NMRUNFILE, *LPNMRUNFILE;
#endif

// RUN FILE RETURN values from notify message
#define RFR_NOTHANDLED 0
#define RFR_SUCCESS 1
#define RFR_FAILURE 2


#define PathRemoveBlanksORD	33
#define PathFindFileNameORD	34
#define PathGetExtensionORD	158
#define PathFindExtensionORD	31

WINSHELLAPI LPSTR WINAPI PathAddBackslash(LPSTR lpszPath);
WINSHELLAPI LPSTR WINAPI PathRemoveBackslash(LPSTR lpszPath);
WINSHELLAPI void  WINAPI PathRemoveBlanks(LPSTR lpszString);
WINSHELLAPI BOOL  WINAPI PathRemoveFileSpec(LPSTR lpszPath);
WINSHELLAPI LPSTR WINAPI PathFindFileName(LPCSTR pPath);
WINSHELLAPI BOOL  WINAPI PathIsRoot(LPCSTR lpszPath);
WINSHELLAPI BOOL  WINAPI PathIsRelative(LPCSTR lpszPath);
WINSHELLAPI BOOL  WINAPI PathIsUNC(LPCSTR lpsz);
WINSHELLAPI BOOL  WINAPI PathIsDirectory(LPCSTR lpszPath);
WINSHELLAPI BOOL  WINAPI PathIsExe(LPCSTR lpszPath);
WINSHELLAPI int   WINAPI PathGetDriveNumber(LPCSTR lpszPath);
WINSHELLAPI LPSTR WINAPI PathCombine(LPSTR szDest, LPCSTR lpszDir, LPCSTR lpszFile);
WINSHELLAPI BOOL  WINAPI PathAppend(LPSTR pPath, LPCSTR pMore);
WINSHELLAPI LPSTR WINAPI PathBuildRoot(LPSTR szRoot, int iDrive);
WINSHELLAPI int   WINAPI PathCommonPrefix(LPCSTR pszFile1, LPCSTR pszFile2, LPSTR achPath);
WINSHELLAPI LPSTR WINAPI PathGetExtension(LPCSTR lpszPath, LPSTR lpszExtension, int cchExt);
WINSHELLAPI LPSTR WINAPI PathFindExtension(LPCSTR pszPath);
WINSHELLAPI BOOL  WINAPI PathCompactPath(HDC hDC, LPSTR lpszPath, UINT dx);
WINSHELLAPI BOOL  WINAPI PathFileExists(LPCSTR lpszPath);
WINSHELLAPI BOOL  WINAPI PathMatchSpec(LPCSTR pszFile, LPCSTR pszSpec);
WINSHELLAPI BOOL  WINAPI PathMakeUniqueName(LPSTR pszUniqueName, UINT cchMax, LPCSTR pszTemplate, LPCSTR pszLongPlate, LPCSTR pszDir);
WINSHELLAPI LPSTR WINAPI PathGetArgs(LPCSTR pszPath);
WINSHELLAPI BOOL  WINAPI PathGetShortName(LPCSTR lpszLongName, LPSTR lpszShortName, UINT cbShortName);
WINSHELLAPI BOOL  WINAPI PathGetLongName(LPCSTR lpszShortName, LPSTR lpszLongName, UINT cbLongName);
WINSHELLAPI void  WINAPI PathQuoteSpaces(LPSTR lpsz);
WINSHELLAPI void  WINAPI PathUnquoteSpaces(LPSTR lpsz);
WINSHELLAPI BOOL  WINAPI PathDirectoryExists(LPCSTR lpszDir);
WINSHELLAPI void  WINAPI PathQualify(LPSTR lpsz);
WINSHELLAPI int   WINAPI PathResolve(LPSTR lpszPath, LPCSTR dirs[], UINT fFlags);	
WINSHELLAPI LPSTR WINAPI PathGetNextComponent(LPCSTR lpszPath, LPSTR lpszComponent);
WINSHELLAPI LPSTR WINAPI PathFindNextComponent(LPCSTR lpszPath);
WINSHELLAPI BOOL  WINAPI PathIsSameRoot(LPCSTR pszPath1, LPCSTR pszPath2);
WINSHELLAPI void  WINAPI PathSetDlgItemPath(HWND hDlg, int id, LPCSTR pszPath);
WINSHELLAPI BOOL  WINAPI ParseField(LPCSTR szData, int n, LPSTR szBuf, int iBufLen);

int   WINAPI PathCleanupSpec(LPCSTR pszDir, LPSTR pszSpec);
//
//  Return codes from PathCleanupSpec.	Negative return values are
//  unrecoverable errors
//
#define PCS_FATAL	    0x80000000
#define PCS_REPLACEDCHAR    0x00000001
#define PCS_REMOVEDCHAR     0x00000002
#define PCS_TRUNCATED	    0x00000004
#define PCS_PATHTOOLONG     0x00000008	// Always combined with FATAL


WINSHELLAPI int   WINAPI RestartDialog(HWND hwnd, LPCSTR lpPrompt, DWORD dwReturn);
WINSHELLAPI void  WINAPI ExitWindowsDialog(HWND hwnd);
WINSHELLAPI int WINAPI RunFileDlg(HWND hwndParent, HICON hIcon, LPCSTR lpszWorkingDir, LPCSTR lpszTitle,
	LPCSTR lpszPrompt, DWORD dwFlags);
WINSHELLAPI int   WINAPI PickIconDlg(HWND hwnd, LPSTR pszIconPath, UINT cbIconPath, int *piIconIndex);
WINSHELLAPI BOOL  WINAPI GetFileNameFromBrowse(HWND hwnd, LPSTR szFilePath, UINT cbFilePath, LPCSTR szWorkingDir, LPCSTR szDefExt, LPCSTR szFilters, LPCSTR szTitle);

WINSHELLAPI int  WINAPI DriveType(int iDrive);
WINSHELLAPI void WINAPI InvalidateDriveType(int iDrive);
WINSHELLAPI int  WINAPI IsNetDrive(int iDrive);

WINSHELLAPI UINT WINAPI Shell_MergeMenus(HMENU hmDst, HMENU hmSrc, UINT uInsert, UINT uIDAdjust, UINT uIDAdjustMax, ULONG uFlags);

WINSHELLAPI void WINAPI SHGetSetSettings(LPSHELLSTATE lpss, DWORD dwMask, BOOL bSet);
WINSHELLAPI LRESULT WINAPI SHRenameFile(HWND hwndParent, LPCSTR pszDir, LPCSTR pszOldName, LPCSTR pszNewName, BOOL bRetainExtension);

WINSHELLAPI UINT WINAPI SHGetNetResource(HNRES hnres, UINT iItem, LPNETRESOURCE pnres, UINT cbMax);

WINSHELLAPI STDAPI SHCreateDefClassObject(REFIID riid, LPVOID * ppv, LPFNCREATEINSTANCE lpfn, UINT *pcRefDll, REFIID riidInstance);

WINSHELLAPI LRESULT WINAPI CallCPLEntry16(HINSTANCE hinst, FARPROC16 lpfnEntry, HWND hwndCPL, UINT msg, DWORD lParam1, DWORD lParam2);
WINSHELLAPI BOOL    WINAPI SHRunControlPanel(LPCSTR lpcszCmdLine, HWND hwndMsgParent);

WINSHELLAPI STDAPI SHCLSIDFromString(LPCSTR lpsz, LPCLSID lpclsid);

#define SHObjectPropertiesORD	178
WINSHELLAPI BOOL WINAPI SHObjectProperties(HWND hwndOwner, DWORD dwType, LPCSTR lpObject, LPCSTR lpPage);

WINSHELLAPI int WINAPI DriveType(int iDrive);
WINSHELLAPI int WINAPI RestartDialog(HWND hwnd, LPCSTR lpPrompt, DWORD dwReturn);
WINSHELLAPI int WINAPI PickIconDlg(HWND hwnd, LPSTR pszIconPath, UINT cbIconPath, int *piIconIndex);


//===================================================================
// Shell_MergeMenu parameter
//
#define MM_ADDSEPARATOR		0x00000001L
#define MM_SUBMENUSHAVEIDS	0x00000002L

//-------- drive type identification --------------
// iDrive      drive index (0=A, 1=B, ...)
//
#define DRIVE_CDROM     5           // extended DriveType() types
#define DRIVE_RAMDRIVE  6
#define DRIVE_TYPE      0x000F      // type masek
#define DRIVE_SLOW      0x0010      // drive is on a slow link
#define DRIVE_LFN       0x0020      // drive supports LFNs
#define DRIVE_AUTORUN   0x0040      // drive has AutoRun.inf in root.
#define DRIVE_AUDIOCD   0x0080      // drive is a AudioCD
#define DRIVE_AUTOOPEN  0x0100      // should *always* auto open on insert
#define DRIVE_NETUNAVAIL 0x0200     // Network drive that is not available
#define DRIVE_SHELLOPEN  0x0400     // should auto open on insert, if shell has focus

#define DriveTypeFlags(iDrive)      DriveType('A' + (iDrive))
#define DriveIsSlow(iDrive)         (DriveTypeFlags(iDrive) & DRIVE_SLOW)
#define DriveIsLFN(iDrive)          (DriveTypeFlags(iDrive) & DRIVE_LFN)
#define DriveIsAutoRun(iDrive)      (DriveTypeFlags(iDrive) & DRIVE_AUTORUN)
#define DriveIsAutoOpen(iDrive)     (DriveTypeFlags(iDrive) & DRIVE_AUTOOPEN)
#define DriveIsShellOpen(iDrive)    (DriveTypeFlags(iDrive) & DRIVE_SHELLOPEN)
#define DriveIsAudioCD(iDrive)      (DriveTypeFlags(iDrive) & DRIVE_AUDIOCD)
#define DriveIsNetUnAvail(iDrive)   (DriveTypeFlags(iDrive) & DRIVE_NETUNAVAIL)

#define IsCDRomDrive(iDrive)        (DriveType(iDrive) == DRIVE_CDROM)
#define IsRamDrive(iDrive)          (DriveType(iDrive) == DRIVE_RAMDRIVE)
#define IsRemovableDrive(iDrive)    (DriveType(iDrive) == DRIVE_REMOVABLE)
#define IsRemoteDrive(iDrive)       (DriveType(iDrive) == DRIVE_REMOTE)

// should be moved to shell32s private include files

WINSHELLAPI int  WINAPI GetDefaultDrive();
WINSHELLAPI int  WINAPI SetDefaultDrive(int iDrive);
WINSHELLAPI int  WINAPI SetDefaultDirectory(LPCSTR lpPath);
WINSHELLAPI void WINAPI GetDefaultDirectory(int iDrive, LPSTR lpPath);

#define POSINVALID  32767       // values for invalid position

#define IDCMD_SYSTEMFIRST       0x8000
#define IDCMD_SYSTEMLAST        0xbfff
#define IDCMD_CANCELED          0xbfff
#define IDCMD_PROCESSED         0xbffe
#define IDCMD_DEFAULT           0xbffe

//====== SEMI-PRIVATE API ===============================
DECLARE_HANDLE( HPSXA );
WINSHELLAPI HPSXA SHCreatePropSheetExtArray( HKEY hKey, PCSTR pszSubKey, UINT max_iface );
WINSHELLAPI void SHDestroyPropSheetExtArray( HPSXA hpsxa );
WINSHELLAPI UINT SHAddFromPropSheetExtArray( HPSXA hpsxa, LPFNADDPROPSHEETPAGE lpfnAddPage, LPARAM lParam );
WINSHELLAPI UINT SHReplaceFromPropSheetExtArray( HPSXA hpsxa, UINT uPageID, LPFNADDPROPSHEETPAGE lpfnReplaceWith, LPARAM lParam );

//====== SEMI-PRIVATE API ORDINALS ===============================
// This is the list of semi-private ordinals we semi-publish.
#define SHAddFromPropSheetExtArrayORD		167
#define SHCreatePropSheetExtArrayORD		168
#define SHDestroyPropSheetExtArrayORD		169
#define SHReplaceFromPropSheetExtArrayORD	170
#define SHCreateDefClassObjectORD		 70
#define SHGetNetResourceORD			 69

#define SHEXP_SHADDFROMPROPSHEETEXTARRAY	MAKEINTRESOURCE(SHAddFromPropSheetExtArrayORD)
#define SHEXP_SHCREATEPROPSHEETEXTARRAY	        MAKEINTRESOURCE(SHCreatePropSheetExtArrayORD)
#define SHEXP_SHDESTROYPROPSHEETEXTARRAY        MAKEINTRESOURCE(SHDestroyPropSheetExtArrayORD)
#define SHEXP_SHREPLACEFROMPROPSHEETEXTARRAY    MAKEINTRESOURCE(SHReplaceFromPropSheetExtArrayORD)
#define SHEXP_SHCREATEDEFCLASSOBJECT            MAKEINTRESOURCE(SHCreateDefClassObjectORD)
#define SHEXP_SHGETNETRESOURCE                  MAKEINTRESOURCE(SHGetNetResourceORD)

/*
 * The SHFormatDrive API provides access to the Shell
 *   format dialog. This allows apps which want to format disks
 *   to bring up the same dialog that the Shell does to do it.
 *
 *   This dialog is not sub-classable. You cannot put custom
 *   controls in it. If you want this ability, you will have
 *   to write your own front end for the DMaint_FormatDrive
 *   engine.
 *
 *   NOTE that the user can format as many diskettes in the specified
 *   drive, or as many times, as he/she wishes to. There is no way to
 *   force any specififc number of disks to format. If you want this
 *   ability, you will have to write your own front end for the
 *   DMaint_FormatDrive engine.
 *
 *   NOTE also that the format will not start till the user pushes the
 *   start button in the dialog. There is no way to do auto start. If
 *   you want this ability, you will have to write your own front end
 *   for the DMaint_FormatDrive engine.
 *
 *   PARAMETERS
 *
 *     hwnd    = The window handle of the window which will own the dialog
 *		 NOTE that unlike SHCheckDrive, hwnd == NULL does not cause
 *		 this dialog to come up as a "top level application" window.
 *		 This parameter should always be non-null, this dialog is
 *		 only designed to be the child of another window, not a
 *		 stand-alone application.
 *     drive   = The 0 based (A: == 0) drive number of the drive to format
 *     fmtID   = The ID of the physical format to format the disk with
 *		 NOTE: The special value SHFMT_ID_DEFAULT means "use the
 *		       default format specified by the DMaint_FormatDrive
 *		       engine". If you want to FORCE a particular format
 *		       ID "up front" you will have to call
 *		       DMaint_GetFormatOptions yourself before calling
 *		       this to obtain the valid list of phys format IDs
 *		       (contents of the PhysFmtIDList array in the
 *		       FMTINFOSTRUCT).
 *     options = There is currently only two option bits defined
 *
 *		  SHFMT_OPT_FULL
 *                SHFMT_OPT_SYSONLY
 *
 *		 The normal defualt in the Shell format dialog is
 *		 "Quick Format", setting this option bit indicates that
 *		 the caller wants to start with FULL format selected
 *		 (this is useful for folks detecting "unformatted" disks
 *		 and wanting to bring up the format dialog).
 *
 *               The SHFMT_OPT_SYSONLY initializes the dialog to
 *               default to just sys the disk.
 *
 *		 All other bits are reserved for future expansion and
 *		 must be 0.
 *
 *		 Please note that this is a bit field and not a value
 *		 and treat it accordingly.
 *
 *   RETURN
 *	The return is either one of the SHFMT_* values, or if the
 *	returned DWORD value is not == to one of these values, then
 *	the return is the physical format ID of the last succesful
 *	format. The LOWORD of this value can be passed on subsequent
 *	calls as the fmtID parameter to "format the same type you did
 *	last time".
 *
 */
DWORD WINAPI SHFormatDrive(HWND hwnd, UINT drive, UINT fmtID, UINT options);

//
// Special value of fmtID which means "use the default format"
//
#define SHFMT_ID_DEFAULT    0xFFFF

//
// Option bits for options parameter
//
#define SHFMT_OPT_FULL     0x0001
#define SHFMT_OPT_SYSONLY  0x0002

//
// Special return values. PLEASE NOTE that these are DWORD values.
//
#define SHFMT_ERROR	0xFFFFFFFFL	// Error on last format, drive may be formatable
#define SHFMT_CANCEL	0xFFFFFFFEL	// Last format was canceled
#define SHFMT_NOFORMAT  0xFFFFFFFDL	// Drive is not formatable


#ifdef __cplusplus
}
#endif  /* __cplusplus */

#ifndef RC_INVOKED
#pragma pack()
#endif  /* !RC_INVOKED */

#endif // _SHSEMIP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\h\standrd.h ===
#ifndef __standrd_h__
#define __standrd_h__


// Useful macros

#ifndef TRACENOTIMPL
    #define TRACENOTIMPL(funcname)   TRACE_OUT((_T("%s not implemented.\n"), funcname)); hr = E_NOTIMPL
#endif 

#define CONSTANT( x ) enum{ x }

#define CASERET(x) case x: return _T(#x)

#define ClearStruct(lpv)     ZeroMemory((LPVOID) (lpv), sizeof(*(lpv)))

#ifndef STRING_RESOURCE_MODULE
    # define STRING_RESOURCE_MODULE _Module.GetModuleInstance()
#endif

typedef struct _tagCol {
	UINT  dwWidth;
	LPTSTR lpsz;
} COL;
typedef COL * LPCOL;


inline LPTSTR CopyLPCTSTR( LPCTSTR sz )
{
    LPTSTR newString = new TCHAR[ lstrlen( sz ) + 1 ];
    if( !lstrcpy( newString, sz ) )
    {
        // Somethnig fialide
        delete [] newString;
        newString = NULL;
    }

    return newString;
}

#ifndef CchMax
    #define CchMax(pcsz)        (sizeof(pcsz) / sizeof((pcsz)[0]))
#endif // CchMax

#define MAX_RESOURCE_STRING_LEN 256


/*  C O N V E R T  S Z  C H  */
/*-------------------------------------------------------------------------
    %%Function: ConvertSzCh

    Replace every instance of chSrc to chDest in the string
-------------------------------------------------------------------------*/
inline VOID ConvertSzCh(LPTSTR psz, TCHAR chSrc, TCHAR chDest)
{
	while (_T('\0') != *psz)
	{
		if (chSrc == *psz)
		{
			*psz = chDest;
			psz++;
		}
		else
		{
			psz = CharNext(psz);
		}
	}
}


inline VOID ConvertSzCh(LPTSTR psz, TCHAR chSrc = _T('|'), TCHAR chDest = _T('\0'));


inline HRESULT NmCtlLoadString(UINT id, LPTSTR lpsz, UINT cch)
{
    HRESULT hr = S_OK;

    if( NULL != STRING_RESOURCE_MODULE )
    {
        if( NULL != lpsz )
        {
	        if (0 == ::LoadString(STRING_RESOURCE_MODULE, id, lpsz, cch))
	        {
		        ERROR_OUT(("*** Resource %d does not exist", id));
		        *lpsz = _T('\0');
		        hr = HRESULT_FROM_WIN32( ::GetLastError() );
	        }


        }
        else
        {
            ERROR_OUT(("LoadString passed an empty buffer"));
            hr = E_INVALIDARG;
        }
    }
    else
    {
        ERROR_OUT(("LoadString could not find the module"));
        hr = E_UNEXPECTED;
    }

	return hr;
}


///////////////////////////////////////////////////////////////////////////////////////////////////////////
// this works if you have a member variable CComBSTR m_bstrProp ( substitute Prop for the Prop param )
// Example:
//
// CComBSTR m_bstrName;
//
//
// DECLARE_CCOMBSTR_PROPPUT( Name, DISPID_PROP_NAME );
// DECLARE_CCOMBSTR_PROPGET( Name );
//
#define DECLARE_CCOMBSTR_PROPPUT( Prop, PROP_DISPID ) \
    STDMETHOD(put_##Prop)( BSTR newVal )  \
    {\
        HRESULT hr = S_OK;\
        if( S_OK == __ATL_PROP_NOTIFY_EVENT_CLASS::FireOnRequestEdit(GetUnknown(), PROP_DISPID) )\
        {\
            m_bstr##Prop = newVal;\
            hr = __ATL_PROP_NOTIFY_EVENT_CLASS::FireOnChanged(GetUnknown(), PROP_DISPID);\
        }\
        return hr;                \
    }


#define DECLARE_CCOMBSTR_PROPGET( Prop ) \
    STDMETHOD(get_##Prop)( BSTR *pVal )  \
    {\
        if( pVal )\
        {\
            *pVal = m_bstr##Prop.Copy();\
        }\
        else\
        {\
            return E_POINTER;\
        }\
        return S_OK;\
    }



///////////////////////////////////////////////////////////////////////////////////////////////////////////
// this works if you have a member variable <class with iterator> m_aryProp ( substitute Prop for the Prop param )
// Example:
//
// lst<IUnknown*> m_AryName;
//
//
// DECLARE_SAFEARRAY_UNK_PROPPUT( Name, DISPID_PROP_NAME );
// DECLARE_SAFEARRAY_UNK_PROPGET( Name );
//

#define DECLARE_SAFEARRAY_UNK_PROPPUT( Prop, PROP_DISPID ) \
    STDMETHOD(put_##Prop)( SAFEARRAY newVal )  \
    {\
        HRESULT hr = S_OK;\
        if( S_OK == __ATL_PROP_NOTIFY_EVENT_CLASS::FireOnRequestEdit(GetUnknown(), PROP_DISPID) )\
        {\
            lst<IUnknown*>::iterator I = m_ary##Prop.begin();\
            while( I != m_ary##Prop.end() )\
            {\
                (*I)->Release();\
                ++I;\
            }\
            m_ary##Prop.erase(m_ary##Prop.begin(), m_ary##Prop.end());\
            IUnknown** ppUnkArray;\
            SafeArrayAccessData( &newVal, reinterpret_cast<void**>(&ppUnkArray) );\
            for (UINT x = 0; x < newVal.rgsabound->cElements; x++)\
	        {\
                IUnknown* pUnk = ppUnkArray[x];\
                pUnk->AddRef();\
                m_ary##Prop.push_back( pUnk );\
	        }\
            SafeArrayUnaccessData(&newVal);\
            hr = __ATL_PROP_NOTIFY_EVENT_CLASS::FireOnChanged(GetUnknown(), PROP_DISPID);\
        }\
        return hr;                \
    }


#define DECLARE_SAFEARRAY_UNK_PROPGET( Prop ) \
    STDMETHOD(get_##Prop)( SAFEARRAY *pVal )  \
    {\
        if( pVal )\
        {\
            int nItems = m_ary##Prop.size();\
            SAFEARRAYBOUND bounds = { nItems, 0 };\
            pVal = SafeArrayCreate( VT_UNKNOWN, 1, &bounds );\
            IUnknown** ppUnkArray;\
            SafeArrayAccessData( pVal, reinterpret_cast<void**>(&ppUnkArray) );\
            lst<IUnknown*>::iterator I = m_ary##Prop.begin();\
            for( int i = 0; I != m_ary##Prop.end(); ++I, ++i )\
            {\
                ppUnkArray[i] = (*I);\
            }\
            SafeArrayUnaccessData(pVal);\
        }\
        else\
        {\
            return E_POINTER;\
        }\
        return S_OK;\
    }
///////////////////////////////////////////////////////////////////////////////////////////////////////
// The following DECLARE_PROPXXX macros define functions if you have a member variable that supports
// an issignment operator ( cleaning up memory if need be....
#define DECLARE_PROPPUT( Type, lVal, Prop, PROP_DISPID ) \
    STDMETHOD(put_##Prop)( Type newVal )  \
    {\
        HRESULT hr = S_OK;\
        if( S_OK == __ATL_PROP_NOTIFY_EVENT_CLASS::FireOnRequestEdit(GetUnknown(), PROP_DISPID) )\
        {\
            lVal = newVal;\
            hr = __ATL_PROP_NOTIFY_EVENT_CLASS::FireOnChanged(GetUnknown(), PROP_DISPID);\
        }\
        return hr;                \
    }


#define DECLARE_PROPGET( Type, rVal, Prop ) \
    STDMETHOD(get_##Prop)( Type* pVal )\
    {\
        if( pVal )\
        {\
            *pVal = rVal;\
        }\
        else\
        {\
            return E_POINTER;\
        }\
        return S_OK;\
    }

inline HRESULT GetTextBoxHeight( HWND hwnd, int* pcy )
{

    HRESULT hr = S_OK;
    HDC hdc = NULL;
    HFONT hSysFont = NULL;
    HFONT hOldFont = NULL;
    TEXTMETRIC tm;

    int HeightOfCurrentFont = 0;
    int HeightOfSystemFont = 0;

    if( pcy )
    {
        if( IsWindow( hwnd ) )
        {
           //get the DC for the  control
           hdc = GetDC(hwnd);

           //get the metrics for the system font
           hSysFont = reinterpret_cast<HFONT>(GetStockObject(SYSTEM_FONT));
           hOldFont = reinterpret_cast<HFONT>(SelectObject(hdc, hSysFont));
           GetTextMetrics(hdc, &tm);
           HeightOfSystemFont = tm.tmHeight;

           //select the original font back into the DC and release the DC
           SelectObject(hdc, hOldFont);
           DeleteObject(hSysFont);
           
           GetTextMetrics(hdc, &tm);
           
		   ReleaseDC(hwnd, hdc);
		   
		   HeightOfCurrentFont = tm.tmHeight;

           *pcy = HeightOfCurrentFont + 
                  ( min( HeightOfSystemFont, HeightOfCurrentFont ) >> 1 ) + 
                  (GetSystemMetrics(SM_CYEDGE) * 2);
        }
        else
        {
            hr = E_INVALIDARG;
        }
    }
    else
    {
        hr = E_POINTER;
    }

    return hr;
}

#define RES_CH_MAX 256

inline TCHAR* Res2THelper( UINT uID, TCHAR* psz, int cch )
{
    if( LoadString( STRING_RESOURCE_MODULE, uID, psz, cch ) )
    {
        return psz;
    }

    return _T("");
}

#ifndef RES2T
#define RES2T(uID) ( Res2THelper( uID, static_cast<TCHAR*>(_alloca( RES_CH_MAX )), RES_CH_MAX ) )
#endif

inline LPCTSTR CommDlgLastErrorToa( DWORD dwErr )
{
    switch( dwErr )
    {
        CASERET ( CDERR_DIALOGFAILURE   ); 
        CASERET ( CDERR_GENERALCODES     );
        CASERET ( CDERR_STRUCTSIZE       );
        CASERET ( CDERR_INITIALIZATION   );
        CASERET ( CDERR_NOTEMPLATE       );
        CASERET ( CDERR_NOHINSTANCE      );
        CASERET ( CDERR_LOADSTRFAILURE   );
        CASERET ( CDERR_FINDRESFAILURE   );
        CASERET ( CDERR_LOADRESFAILURE   );
        CASERET ( CDERR_LOCKRESFAILURE   );
        CASERET ( CDERR_MEMALLOCFAILURE  );
        CASERET ( CDERR_MEMLOCKFAILURE   );
        CASERET ( CDERR_NOHOOK           );
        CASERET ( CDERR_REGISTERMSGFAIL  );

        CASERET ( PDERR_PRINTERCODES     );
        CASERET ( PDERR_SETUPFAILURE     );
        CASERET ( PDERR_PARSEFAILURE     );
        CASERET ( PDERR_RETDEFFAILURE    );
        CASERET ( PDERR_LOADDRVFAILURE   );
        CASERET ( PDERR_GETDEVMODEFAIL   );
        CASERET ( PDERR_INITFAILURE      );
        CASERET ( PDERR_NODEVICES        );
        CASERET ( PDERR_NODEFAULTPRN     );
        CASERET ( PDERR_DNDMMISMATCH     );
        CASERET ( PDERR_CREATEICFAILURE  );
        CASERET ( PDERR_PRINTERNOTFOUND  );
        CASERET ( PDERR_DEFAULTDIFFERENT );

        CASERET ( CFERR_CHOOSEFONTCODES  );
        CASERET ( CFERR_NOFONTS          );
        CASERET ( CFERR_MAXLESSTHANMIN   );

        CASERET ( FNERR_FILENAMECODES    );
        CASERET ( FNERR_SUBCLASSFAILURE  );
        CASERET ( FNERR_INVALIDFILENAME  );
        CASERET ( FNERR_BUFFERTOOSMALL   );

        CASERET ( FRERR_FINDREPLACECODES );
        CASERET ( FRERR_BUFFERLENGTHZERO );

        CASERET ( CCERR_CHOOSECOLORCODES );
    }

    return _T("NOERROR");
}

inline void DumpCommDlgLastError()
{
    ATLTRACE(_T("CommDlgExtendedError == %s"), CommDlgLastErrorToa( CommDlgExtendedError() ));
}

inline int _Points_From_LogFontHeight( int height, HWND hwnd )
{
	HDC hdc = ::GetDC( hwnd );
	if( NULL != hdc )
	{
		int iRet = MulDiv( -height, 72, GetDeviceCaps( hdc, LOGPIXELSY ) );
		::ReleaseDC( hwnd, hdc );
		return iRet;
	}

	return 0;
}


#endif // __standrd_h__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\h\stock.h ===
/*
 * stock.h - Stock header file.
 *
 * Taken from URL code by ChrisPi 9-11-95
 *
 */

#ifndef _STOCK_H_
#define _STOCK_H_

/* Constants
 ************/

#define ASTERISK                 '*'
#define BACKSLASH                '/'
#define COLON                    ':'
#define COMMA                    ','
#define EQUAL                    '='
#define PERIOD                   '.'
#define POUND                    '#'
#define QMARK                    '?'
#define QUOTE                    '\''
#define QUOTES                   '"'
#define SLASH                    '\\'
#define SPACE                    ' '
#define TAB                      '\t'

/* linkage */

#ifdef __cplusplus
#define INLINE                   inline
#else
#define INLINE                   __inline
#endif


/* Win32 HRESULTs */

#define E_FILE_NOT_FOUND         MAKE_SCODE(SEVERITY_ERROR, FACILITY_WIN32, ERROR_FILE_NOT_FOUND)
#define E_PATH_NOT_FOUND         MAKE_SCODE(SEVERITY_ERROR, FACILITY_WIN32, ERROR_PATH_NOT_FOUND)

/* file-related flag combinations */

#define ALL_FILE_ACCESS_FLAGS          (GENERIC_READ |\
                                        GENERIC_WRITE)

#define ALL_FILE_SHARING_FLAGS         (FILE_SHARE_READ |\
                                        FILE_SHARE_WRITE)

#define ALL_FILE_ATTRIBUTES            (FILE_ATTRIBUTE_READONLY |\
                                        FILE_ATTRIBUTE_HIDDEN |\
                                        FILE_ATTRIBUTE_SYSTEM |\
                                        FILE_ATTRIBUTE_DIRECTORY |\
                                        FILE_ATTRIBUTE_ARCHIVE |\
                                        FILE_ATTRIBUTE_NORMAL |\
                                        FILE_ATTRIBUTE_TEMPORARY |\
                                        FILE_ATTRIBUTE_ATOMIC_WRITE |\
                                        FILE_ATTRIBUTE_XACTION_WRITE)

#define ALL_FILE_FLAGS                 (FILE_FLAG_WRITE_THROUGH |\
                                        FILE_FLAG_OVERLAPPED |\
                                        FILE_FLAG_NO_BUFFERING |\
                                        FILE_FLAG_RANDOM_ACCESS |\
                                        FILE_FLAG_SEQUENTIAL_SCAN |\
                                        FILE_FLAG_DELETE_ON_CLOSE |\
                                        FILE_FLAG_BACKUP_SEMANTICS |\
                                        FILE_FLAG_POSIX_SEMANTICS)

#define ALL_FILE_ATTRIBUTES_AND_FLAGS  (ALL_FILE_ATTRIBUTES |\
                                        ALL_FILE_FLAGS)


/* Macros
 *********/

#ifndef DECLARE_STANDARD_TYPES

/*
 * For a type "FOO", define the standard derived types PFOO, CFOO, and PCFOO.
 */

#define DECLARE_STANDARD_TYPES(type)      typedef type *P##type; \
                                          typedef const type C##type; \
                                          typedef const type *PC##type;

#endif

/* character manipulation */

#define IS_SLASH(ch)                      ((ch) == SLASH || (ch) == BACKSLASH)

/* bit flag manipulation */

#define SET_FLAG(dwAllFlags, dwFlag)      ((dwAllFlags) |= (dwFlag))

/* ChrisPi: DCL also defines this - override their definition */
#ifdef CLEAR_FLAG
#undef CLEAR_FLAG
#endif /* CLEAR_FLAG */

#define CLEAR_FLAG(dwAllFlags, dwFlag)    ((dwAllFlags) &= (~dwFlag))

#define IS_FLAG_SET(dwAllFlags, dwFlag)   ((BOOL)((dwAllFlags) & (dwFlag)))
#define IS_FLAG_CLEAR(dwAllFlags, dwFlag) (! (IS_FLAG_SET(dwAllFlags, dwFlag)))

/* array element count */

#define ARRAY_ELEMENTS(rg)                (sizeof(rg) / sizeof((rg)[0]))
#define CCHMAX(rg)                        ARRAY_ELEMENTS(rg)

/* clearing bytes */
#define ClearStruct(lpv)     ZeroMemory((LPVOID) (lpv), sizeof(*(lpv)))
#define InitStruct(lpv)      {ClearStruct(lpv); (* (LPDWORD)(lpv)) = sizeof(*(lpv));}


/* string safety */

#define CHECK_STRING(psz)                 ((psz) ? (psz) : "(null)")

/* file attribute manipulation */

#define IS_ATTR_DIR(attr)                 (IS_FLAG_SET((attr), FILE_ATTRIBUTE_DIRECTORY))
#define IS_ATTR_VOLUME(attr)              (IS_FLAG_SET((attr), FILE_ATTRIBUTE_VOLUME))

/* stuff a point value packed in an LPARAM into a POINT */

#define LPARAM_TO_POINT(lparam, pt)       ((pt).x = (short)LOWORD(lparam), \
                                           (pt).y = (short)HIWORD(lparam))


/* Types
 ********/

typedef const void *PCVOID;
typedef const INT CINT;
typedef const INT *PCINT;
typedef const UINT CUINT;
typedef const UINT *PCUINT;
typedef const LONG CULONG;
typedef const LONG *PCULONG;
typedef const BYTE CBYTE;
typedef const BYTE *PCBYTE;
typedef const WORD CWORD;
typedef const WORD *PCWORD;
typedef const DWORD CDWORD;
typedef const DWORD *PCDWORD;
typedef const CRITICAL_SECTION CCRITICAL_SECTION;
typedef const CRITICAL_SECTION *PCCRITICAL_SECTION;
typedef const FILETIME CFILETIME;
typedef const FILETIME *PCFILETIME;
typedef const BITMAPINFO CBITMAPINFO;
typedef const BITMAPINFO *PCBITMAPINFO;
typedef const POINT CPOINT;
typedef const POINT *PCPOINT;
typedef const POINTL CPOINTL;
typedef const POINTL *PCPOINTL;
typedef const SECURITY_ATTRIBUTES CSECURITY_ATTRIBUTES;
typedef const SECURITY_ATTRIBUTES *PCSECURITY_ATTRIBUTES;
typedef const WIN32_FIND_DATA CWIN32_FIND_DATA;
typedef const WIN32_FIND_DATA *PCWIN32_FIND_DATA;

DECLARE_STANDARD_TYPES(HGLOBAL);
DECLARE_STANDARD_TYPES(HICON);
DECLARE_STANDARD_TYPES(HMENU);
DECLARE_STANDARD_TYPES(HWND);
DECLARE_STANDARD_TYPES(NMHDR);


#ifndef _COMPARISONRESULT_DEFINED_

/* comparison result */

typedef enum _comparisonresult
{
   CR_FIRST_SMALLER = -1,
   CR_EQUAL = 0,
   CR_FIRST_LARGER = +1
}
COMPARISONRESULT;
DECLARE_STANDARD_TYPES(COMPARISONRESULT);

#define _COMPARISONRESULT_DEFINED_

#endif

#endif /* _STOCK_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\h\shlstock.h ===
/*
 * shlstock.h - Shell Stock header file.
 *
 * Taken from URL code by ChrisPi 9-20-95
 *
 * Note: some types are only available with internal shell headers
 *       (these are ifdef'ed with INTERNALSHELL)
 *
 */

#ifndef _SHLSTOCK_H_
#define _SHLSTOCK_H_



#ifdef __cplusplus
extern "C" {                        /* Assume C declarations for C++. */
#endif   /* __cplusplus */


/* Types
 ********/

/* interfaces */

DECLARE_STANDARD_TYPES(IExtractIcon);
DECLARE_STANDARD_TYPES(INewShortcutHook);
#ifdef INTERNALSHELL
DECLARE_STANDARD_TYPES(IShellExecuteHook);
#endif
DECLARE_STANDARD_TYPES(IShellLink);
DECLARE_STANDARD_TYPES(IShellExtInit);
DECLARE_STANDARD_TYPES(IShellPropSheetExt);

/* structures */

DECLARE_STANDARD_TYPES(DROPFILES);
DECLARE_STANDARD_TYPES(FILEDESCRIPTOR);
DECLARE_STANDARD_TYPES(FILEGROUPDESCRIPTOR);
DECLARE_STANDARD_TYPES(ITEMIDLIST);
DECLARE_STANDARD_TYPES(PROPSHEETPAGE);
DECLARE_STANDARD_TYPES(SHELLEXECUTEINFO);

/* flags */

typedef enum _shellexecute_mask_flags
{
   ALL_SHELLEXECUTE_MASK_FLAGS = (SEE_MASK_CLASSNAME |
                                  SEE_MASK_CLASSKEY |
                                  SEE_MASK_IDLIST |
                                  SEE_MASK_INVOKEIDLIST |
                                  SEE_MASK_ICON |
                                  SEE_MASK_HOTKEY |
                                  SEE_MASK_NOCLOSEPROCESS |
                                  SEE_MASK_CONNECTNETDRV |
                                  SEE_MASK_FLAG_DDEWAIT |
                                  SEE_MASK_DOENVSUBST |
                                  SEE_MASK_FLAG_NO_UI 
#ifdef INTERNALSHELL
                                | SEE_MASK_FLAG_SHELLEXEC |
                                  SEE_MASK_FORCENOIDLIST
#endif
                                  )
}
SHELLEXECUTE_MASK_FLAGS;


#ifdef __cplusplus
}                                   /* End of extern "C" {. */
#endif   /* __cplusplus */

#endif /* _SHLSTOCK_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\h\strutil.h ===
#ifndef _STRUTIL_H_
#define _STRUTIL_H_

#include <nmutil.h>
#include <stock.h>
#include <wincrypt.h>


INLINE BOOL
IsEmptyStringA(LPCSTR pcsz)
{
	return (NULL == pcsz) || ('\0' == *pcsz);
}

INLINE BOOL
IsEmptyStringW(LPCWSTR pcwsz)
{
	return (NULL == pcwsz) || (L'\0' == *pcwsz);
}

#if defined(UNICODE)
#define IsEmptyString IsEmptyStringW
#else // defined(UNICODE)
#define IsEmptyString IsEmptyStringA
#endif // defined(UNICODE)


#define IS_EMPTY_STRING(s)	  (IsEmptyString(s))
#define FEmptySz(psz)         (IsEmptyString(psz))

#define SetEmptySz(psz)       (*(psz) = _T('\0'))

	
// global helper functions for Unicode support in a DBCS environment

int     NMINTERNAL UnicodeCompare(PCWSTR s, PCWSTR t);
PWSTR   NMINTERNAL NewUnicodeString(PCWSTR wszText);
BOOL    NMINTERNAL UnicodeIsNumber(PCWSTR wszText);
PWSTR   NMINTERNAL DBCSToUnicode(UINT uCodePage, PCSTR szText);
PSTR    NMINTERNAL UnicodeToDBCS(UINT uCodePage, PCWSTR wszText);

INLINE PWSTR AnsiToUnicode(PCSTR szText)
{
	return DBCSToUnicode(CP_ACP, szText);
}

INLINE PWSTR OEMToUnicode(PCSTR szText)
{
	return DBCSToUnicode(CP_OEMCP, szText);
}

INLINE PSTR UnicodeToAnsi(PCWSTR wszText)
{
	return UnicodeToDBCS(CP_ACP, wszText);
}

INLINE PSTR UnicodeToOEM(PCWSTR wszText)
{
	return UnicodeToDBCS(CP_OEMCP, wszText);
}


// Functions to convert between Quad Words (expressed as ULARGE_INTEGERs)
// and ANSI strings.
BOOL NMINTERNAL HexStringToQWordA(LPCSTR pcszString, ULARGE_INTEGER* pqw);
int NMINTERNAL QWordToHexStringA(ULARGE_INTEGER qw, LPSTR pszString);

// Function to convert from a hex string to a DWORD.
DWORD   NMINTERNAL DwFromHex(LPCTSTR pchHex);

// CCHMAX_HEX_ULARGE_INTEGER - defines the minimum string buffer size needed
// for the second parameter of QWordToHexStringA().
#define CCHMAX_HEX_ULARGE_INTEGER 17 // 16 characters + n.t.

#define CCH_HEX_DWORD		8
#define CCH_HEX_QWORD		16
#define BITS_PER_HEX_CHAR	4


// Other Random string functions
VOID    NMINTERNAL GuidToSz(GUID * pguid, LPTSTR lpchDest);
/* sizeof(GUID)*2 + 7 (includes NULL terminator) characters (see GuidToSz) */
#define LENGTH_SZGUID_FORMATTED 39


int WINAPI RtStrToInt(LPCTSTR lpSrc);       // atoi()
#define ATOI					RtStrToInt

#ifdef __cplusplus
extern "C"{
#endif
UINT    NMINTERNAL DecimalStringToUINT(LPCTSTR pcszString);
#ifdef __cplusplus
}
#endif

#ifdef __cplusplus
extern "C"{
#endif
LPCTSTR NMINTERNAL _StrChr(LPCTSTR psz, TCHAR c);
int     NMINTERNAL _StrCmpN(LPCTSTR psz1, LPCTSTR psz2, UINT maxChars);
#ifdef __cplusplus
}
#endif
LPCTSTR NMINTERNAL _StrStr(LPCTSTR pcsz1, LPCTSTR pcsz2);
LPCWSTR NMINTERNAL _StrStrW(LPCWSTR pcsz1, LPCWSTR pcsz2);

LPSTR	NMINTERNAL _StrPbrkA(LPCSTR pcszString, LPCSTR pcszSearch);
LPWSTR	NMINTERNAL _StrPbrkW(LPCWSTR pcszString, LPCWSTR pcszSearch);

#if defined(UNICODE)
#define _StrPbrk _StrPbrkW
#else // defined(UNICODE)
#define _StrPbrk _StrPbrkA
#endif // defined(UNICODE)

LPTSTR  NMINTERNAL SzFindLastCh(LPTSTR lpsz, TCHAR ch);
UINT    NMINTERNAL TrimSz(PTCHAR psz);

// Local LStrLenW function is unnecessary, since Windows 95 supports
// lstrlenW natively
#define LStrLenW lstrlenW

// Map LStrCpyW to its Win32 equivalent for Unicode builds
#if defined UNICODE
#define LStrCpyW lstrcpyW
#define LStrCpyNW lstrcpyn
#else // defined UNICODE
LPWSTR  NMINTERNAL LStrCpyW(LPWSTR pszDest, LPWSTR pszSrc);
LPWSTR  NMINTERNAL LStrCpyNW(LPWSTR pszDest, LPCWSTR pszSrc, INT iMaxLength);
#endif // defined UNICODE

LPWSTR NMINTERNAL _StrLwrW(LPWSTR pwszSrc);

#ifdef __cplusplus
class CHash
{
public:
	CHash();
	~CHash();
	DWORD GetHashedData(PBYTE pbData, DWORD cbData, void ** ppvHashedData);

private:
	HCRYPTPROV      m_hProv;
	HCRYPTHASH      m_hHash;
	PBYTE			m_pbHashedData;
	DWORD			m_cbHashedData;
	BOOL			m_fReady;
};
#endif
	
DWORD NMINTERNAL HashPasswd(PBYTE pbPasswd, DWORD cbPasswd, void **ppvData);

#endif // ndef STRUTIL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\h\temp.h ===
#ifndef _TEMP_H
#define _TEMP_H

#include <pshpack8.h> /* Assume 8 byte packing throughout */

#define WAVE_FORMAT_LH_CELP	0x0070
#define WAVE_FORMAT_LH_SB8	   0x0071
#define WAVE_FORMAT_LH_SB12	0x0072
#define WAVE_FORMAT_LH_SB16	0x0073

#define ACMDM_LH_DATA_PACKAGING		(ACMDM_USER + 1)


// lParam1 when sending ACMDM_LH_DATA_PACKAGING
enum
{
	LH_PACKET_DATA_NULL,	// uninitialized
	LH_PACKET_DATA_FRAMED,	// always aligned on frame boundary
	LH_PACKET_DATA_ANYTHING // do not assume alignment
};

#include <poppack.h> /* End byte packing */

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\h\tsecctrl.h ===
#ifndef _TSECCTRL_
#define _TSECCTRL_

// Command codes
#define LOADFTAPPLET                        100
#define UNLOADFTAPPLET                      101

// Sets credentials directly in the transport
#define TPRTCTRL_SETX509CREDENTIALS            111
#define TPRTCTRL_GETX509CREDENTIALS            112

// Prototype typedef
typedef DWORD (WINAPI *PFN_TPRTSECCTRL)(DWORD, DWORD, DWORD);

// Loadlibrary constant
#define SZ_TPRTSECCTRL TEXT("TprtSecCtrl")

// Static prototype
extern DWORD WINAPI TprtSecCtrl (DWORD dwCode, DWORD dwParam1, DWORD dwParam2);

#endif // _TSECCTRL_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\h\ullaunch.h ===
#ifndef _ULLAUNCH_H_
#define _ULLAUNCH_H_

#include <windows.h>
#include "ulserror.h"

#include <pshpack8.h> /* Assume 8 byte packing throughout */

#ifdef __cplusplus
extern "C" {
#endif


typedef struct tagUlsApp
{
    GUID    guid;           // application guid
    long    port;           // port number

    PTSTR   pszPathName;    // full path of the app
    PTSTR   pszCmdTemplate; // command-line template, could be NULL
    PTSTR   pszCmdLine;     // expanded command line, could be NULL
    PTSTR   pszWorkingDir;  // working directory, could be NULL
    long    idxDefIcon;     // default icon index
    PTSTR   pszDescription; // description of this app
    HICON   hIconAppDef;    // default icon
    BOOL    fPostMsg;       // launch existing app by posting a msg
}
    ULSAPP;


typedef struct tagUlsResult
{
    DWORD   dwIPAddr;
    long    idxApp;         // which app is selected thru ui
    long    nApps;
// TO BE TURNED ON    ULSAPP  App[1];
    ULSAPP  App[4];
}
    ULSRES;


typedef struct tagUlsToken
{
    TCHAR   cPrior;
    TCHAR   cPost;
    PTSTR   pszToken;
    WORD    cbTotal;
}
    ULSTOKEN;

enum
{
    TOKEN_IULS_BEGIN,
    TOKEN_IULS_END,
    TOKEN_RES,
    NumOf_Tokens
};


HRESULT WINAPI UlxParseUlsFile ( PTSTR pszUlsFile, ULSRES **ppUlsResult );
typedef HRESULT (WINAPI *PFN_UlxParseUlsFile) ( PTSTR, ULSRES ** );
#define ULXPARSEULSFILE     TEXT ("UlxParseUlsFile")

HRESULT WINAPI UlxParseUlsBuffer ( PTSTR pszBuf, DWORD cbBufSize, ULSRES **ppUlsResult );
typedef HRESULT (WINAPI *PFN_UlxParseUlsBuffer) ( PTSTR, DWORD, ULSRES ** );
#define ULXPARSEULSBUFFER   TEXT ("UlxParseUlsBuffer")

void WINAPI UlxFreeUlsResult ( ULSRES *pUlsResult );
typedef HRESULT (WINAPI *PFN_UlxFreeUlsResult) ( ULSRES * );
#define ULXFREEULSRESULT    TEXT ("UlxFreeUlsResult")

HRESULT WINAPI UlxFindAppInfo ( ULSRES *pUlsResult );
typedef HRESULT (WINAPI *PFN_UlxFindAppInfo) ( ULSRES * );
#define ULXFINDAPPINFO      TEXT ("UlxFindAppInfo")

HRESULT WINAPI UlxLaunchApp ( HWND hWnd, ULSRES *pUlsResult );
typedef HRESULT (WINAPI *PFN_UlxLaunchApp) ( HWND, ULSRES * );
#define ULXLAUNCHAPP        TEXT ("UlxLaunchApp")


#ifdef __cplusplus
}
#endif

#include <poppack.h> /* End byte packing */

#endif // _LAUNCH_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\h\ulsreg.h ===
//--------------------------------------------------------------------------
//
// Module Name:  ULSREG.H
//
// Brief Description:  This module contains definitions for all registry
//                     folders and keys.
//
// Author:  Lon-Chan Chu (LonChanC)
// Created: 09-Apr-1996
//
// Copyright (c) 1996 Microsoft Corporation
//
//--------------------------------------------------------------------------


#ifndef _ULSREG_H_
#define _ULSREG_H_

#include <pshpack1.h> /* Assume 1 byte packing throughout */

#ifdef __cplusplus
extern "C" {
#endif

// registry used in UL Client and Launcher

#define ULS_REGISTRY            TEXT ("Software\\Microsoft\\User Location Service")

    #define ULS_REGFLD_APP_GUID     TEXT ("Application GUID")
        #define ULS_REGKEY_APP_PATH     TEXT ("Path Name")
        #define ULS_REGKEY_CMD_LINE     TEXT ("Command Line Template")
        #define ULS_REGKEY_WORK_DIR     TEXT ("Working Directory")
        #define ULS_REGKEY_DEF_ICON     TEXT ("Default Icon")
        #define ULS_REGKEY_POST_MSG     TEXT ("Post Message")
        #define ULS_REGKEY_APP_TEXT     TEXT ("Description")

    #define ULS_REGFLD_CLIENT       TEXT ("Client")
        #define ULS_REGKEY_FIRST_NAME    TEXT ("First Name")
        #define ULS_REGKEY_LAST_NAME    TEXT ("Last Name")
        #define ULS_REGKEY_EMAIL_NAME   TEXT ("Email Name")
        #define ULS_REGKEY_LOCATION		TEXT ("Location")
        #define ULS_REGKEY_PHONENUM	    TEXT ("Phonenum")
        #define ULS_REGKEY_COMMENTS	    TEXT ("Comments")
        #define ULS_REGKEY_SERVER_NAME  TEXT ("Server Name")
        #define ULS_REGKEY_DONT_PUBLISH TEXT ("Don't Publish")
        #define ULS_REGKEY_USER_NAME	TEXT ("User Name")
		#define ULS_REGKEY_RESOLVE_NAME TEXT ("Resolve Name")
		#define ULS_REGKEY_CLIENT_ID	TEXT ("Client ID")


#define MAIL_REGISTRY            TEXT ("Software\\Microsoft\\Internet Mail and News")

    #define MAIL_REGFLD_MAIL      TEXT ("Mail")
    
        #define MAIL_REGKEY_SENDER_EMAIL    TEXT ("Sender EMail")
        #define MAIL_REGKEY_SENDER_NAME	  	TEXT ("Sender Name")


#define WINDOWS_REGISTRY		TEXT("SOFTWARE\\Microsoft\\Windows")
	#define WIN_REGFLD_CURVERSION	TEXT("CurrentVersion")			
		#define WIN_REGKEY_REGOWNER			TEXT("RegisteredOwner")
	
#ifdef __cplusplus
}
#endif

#include <poppack.h> /* End byte packing */

#endif // _ULSREG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\h\utf8str.h ===
#ifndef _UTF8STR_H_
#define _UTF8STR_H_

class CUTF8String
{
public:
	CUTF8String(LPCWSTR pcwszUnicode) :
		m_pwszUnicode	((LPWSTR) pcwszUnicode),
		m_pszUTF8		(NULL),
		m_eAlloc		(ALLOC_NONE),
		m_hr			(S_OK) { };
	CUTF8String(LPCSTR pcszUTF8) :
		m_pszUTF8		((LPSTR) pcszUTF8),
		m_pwszUnicode	(NULL),
		m_eAlloc		(ALLOC_NONE),
		m_hr			(S_OK) { };
	~CUTF8String();

	VOID AssignString(LPCSTR pcszUTF8) {
									delete m_pwszUnicode;
									m_pwszUnicode = NULL;
									m_eAlloc = ALLOC_NONE;
									m_hr = S_OK;
									m_pszUTF8 = (LPSTR) pcszUTF8; };

	VOID AssignString(LPCWSTR pcwszUnicode) {
									delete m_pszUTF8;
									m_pszUTF8 = NULL;
									m_eAlloc = ALLOC_NONE;
									m_hr = S_OK;
									m_pwszUnicode = (LPWSTR) pcwszUnicode; };

	operator LPWSTR();
	operator LPSTR();

	HRESULT GetError() { return m_hr; };
protected:
	VOID EncodeUTF8();
	VOID DecodeUTF8();

	HRESULT	m_hr;
	LPWSTR	m_pwszUnicode;
	LPSTR	m_pszUTF8;
	enum
	{
		ALLOC_NONE,
		ALLOC_UNICODE,
		ALLOC_UTF8,
	} m_eAlloc;
};

#endif // ! _UTF8STR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\h\valid.h ===
/*
 * valid.h - Validation functions description.
 *
 * Taken from URL code by ChrisPi 9-11-95
 *
 */

#ifndef _VALID_H_
#define _VALID_H_

/* Prototypes
 *************/

/* valid.c */

extern BOOL IsValidHWND(HWND);

#ifdef DEBUG

extern BOOL IsValidFileCreationMode(DWORD);
extern BOOL IsValidHANDLE(HANDLE);
extern BOOL IsValidHEVENT(HANDLE);
extern BOOL IsValidHFILE(HANDLE);
extern BOOL IsValidHGLOBAL(HGLOBAL);
extern BOOL IsValidHMENU(HMENU);
extern BOOL IsValidHICON(HICON);
extern BOOL IsValidHINSTANCE(HINSTANCE);
extern BOOL IsValidHKEY(HKEY);
extern BOOL IsValidHMODULE(HMODULE);
extern BOOL IsValidHPROCESS(HANDLE);
extern BOOL IsValidHTEMPLATEFILE(HANDLE);
extern BOOL IsValidIconIndex(HRESULT, LPCTSTR, UINT, int);
extern BOOL IsValidPCFILETIME(PCFILETIME);
extern BOOL IsValidPCPOINT(PCPOINT);
extern BOOL IsValidPCPOINTL(PCPOINTL);
extern BOOL IsValidPCSECURITY_ATTRIBUTES(PCSECURITY_ATTRIBUTES);
extern BOOL IsValidPCWIN32_FIND_DATA(PCWIN32_FIND_DATA);
extern BOOL IsValidPathResult(HRESULT, LPCTSTR, UINT);
extern BOOL IsValidExtension(LPCTSTR);
extern BOOL IsValidRegistryValueType(DWORD);
extern BOOL IsValidShowCmd(int);
extern BOOL IsValidHotkey(WORD);

extern BOOL IsValidPath(LPCTSTR);
#if defined(UNICODE)
extern BOOL IsValidPathA(PCSTR);
#else // defined(UNICODE)
#define IsValidPathA IsValidPath
#endif // defined(UNICODE)

#ifdef _COMPARISONRESULT_DEFINED_

extern BOOL IsValidCOMPARISONRESULT(COMPARISONRESULT);

#endif   /* _COMPARISONRESULT_DEFINED_ */

#endif   /* DEBUG */

#endif /* _VALID_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\h\version.h ===
/****************************************************************************
 *                                                                          *
 *      VERSION.H        -- Version information for internal builds         *
 *                                                                          *
 *      This file is only modified by the official builder to update the         *
 *      VERSION, VER_PRODUCTVERSION and VER_PRODUCTVERSION_STR values            *
 *                                                                          *
 ****************************************************************************/

#if defined(WIN32) && !defined(SKIP_WINVER)
#include <winver.h>
#endif // defined(WIN32) && !defined(SKIP_WINVER)

/*--------------------------------------------------------------*/
/* the following entry should be phased out in favor of         */
/* VER_PRODUCTVERSION_STR, but is used in the shell today.      */
/*--------------------------------------------------------------*/

/*--------------------------------------------------------------*/
/* the following values should be modified by the official      */
/* builder for each build                                       */
/*--------------------------------------------------------------*/
#ifndef WIN32
#define VERSION                     "4.4.3400"
#endif
#define VER_PRODUCTVERSION_STR      "4.4.3400\0"
#define VER_PRODUCTVERSION           4,4,0,3400
#define VER_PRODUCTVERSION_REGSTR   "4,4,0,3400"
#define VERSIONBUILD_STR                  "3400"
#define VERSIONBUILD                       3400
#define VER_PRODUCTVERSION_DW       (0x04040000 | 3400)
#define VER_PRODUCTVERSION_W        (0x0400)
#define VER_PRODUCTVERSION_DW_REG   04,00,04,00,00,00,48,0D
#define VER_PRODUCTVERSION_DWSTR    L"04040D48"


/*--------------------------------------------------------------*/
/* the following section defines values used in the version     */
/* data structure for all files, and which do not change.       */
/*--------------------------------------------------------------*/


/* default is nodebug */
#ifndef DEBUG
#define VER_DEBUG                   0
#else
#define VER_DEBUG                   VS_FF_DEBUG
#endif

/* default is privatebuild */
#ifndef OFFICIAL
#define VER_PRIVATEBUILD            VS_FF_PRIVATEBUILD
#else
#define VER_PRIVATEBUILD            0
#endif

/* default is prerelease */
#ifndef FINAL
#define VER_PRERELEASE              VS_FF_PRERELEASE
#else
#define VER_PRERELEASE              0
#endif

#define VER_FILEFLAGSMASK           VS_FFI_FILEFLAGSMASK
#define VER_FILEFLAGS               (VER_PRIVATEBUILD|VER_PRERELEASE|VER_DEBUG)


/* Allow these to be re-defined */

#ifndef VER_FILEOS
#ifdef WIN32
#define VER_FILEOS                  VOS__WINDOWS32
#else // WIN32
#define VER_FILEOS                  VOS_DOS_WINDOWS16
#endif // WIN32
#endif // ! VER_FILEOS

#ifndef VER_COMPANYNAME_STR
#define VER_COMPANYNAME_STR         "Microsoft Corporation"
#endif

#ifndef VER_PRODUCTNAME_STR
#define VER_PRODUCTNAME_STR         "Windows\256 NetMeeting\256"
#endif

#ifndef VER_PRODUCTRELEASE_STR
#define VER_PRODUCTRELEASE_STR      "3.01"
#endif

#ifndef VER_LEGALTRADEMARKS_STR
#define VER_LEGALTRADEMARKS_STR     \
"Microsoft\256 , Windows\256 and NetMeeting\256 are registered trademarks of Microsoft Corporation in the U.S. and/or other countries."
#endif

#ifndef VER_COPYRIGHT_STR
#define VER_COPYRIGHT_STR       \
"Copyright \251 Microsoft Corporation 1996-2001"
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\h\vcmstrm.h ===
#ifndef _INC_VCM
#define _INC_VCM        /* #defined if vcmStrm.h has been included */

#if defined(UNICODE) && !defined(_UNICODE)
#define _UNICODE
#endif

#pragma pack(1)         /* Assume 1 byte packing throughout */

#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif  /* __cplusplus */

/****************************************************************************
			       Table Of Contents
****************************************************************************/
/****************************************************************************
@doc EXTERNAL

@contents1 Contents | To display a list of topics by category, click any
of the contents entries below. To display an alphabetical list of
topics, choose the Index button.

@head3 Introduction |

The vcmStreamXXX APIs are defined to simplify integration of video
compression and decompression in NetMeeting's datapump. Currently, the datapump
behavior relies a lot on the acmStreamXXX APIs. In order to limit the amount of modifications that need to be applied
to the datapump, we define video compression APIs with a behavior similar to
the audio compression APIs. Integration in the datapump will be achieved by defining
a FilterVideoManager class identical to the FilterManager class, where calls to
acmStreamXXX functions are simply replaced by calls to vcmStreamXXX functions.

@head3 vcmStreamXXX Compression/Decompression API |

@subindex Functions
@subindex Structures and Enums
@subindex Messages

@head3 vcmDevCapsXXX Capture Device Capabilities API |

@subindex Functions
@subindex Structures and Enums
@subindex Messages

@head3 Other |

@subindex Modules
@subindex Constants

***********************************************************************
@contents2 Compression/Decompression Functions |
@index func | COMPFUNC

***********************************************************************
@contents2 Compression/Decompression Structures and Enums |
@index struct,enum | COMPSTRUCTENUM

***********************************************************************
@contents2 Compression/Decompression Messages |
@index msg | COMPMSG

***********************************************************************
@contents2 Capture Device Capabilities Functions |
@index func | DEVCAPSFUNC

***********************************************************************
@contents2 Capture Device Capabilities Structures and Enums |
@index struct,enum | DEVCAPSSTRUCTENUM

***********************************************************************
@contents2 Modules |
@index module |

***********************************************************************
@contents2 Constants |
@index const |
****************************************************************************/

/*****************************************************************************
 * @doc EXTERNAL COMPSTRUCTENUM
 *
 * @struct VIDEOFORMATEX | The <t VIDEOFORMATEX> structure defines the format used to
 *   capture video data and settings for the capture device.
 *
 * @field DWORD | dwFormatTag | Specifies the video format type (FOURCC code).
 *
 * @field DWORD | nSamplesPerSec | Specifies the sample rate, in frames per second.
 *
 * @field DWORD | nAvgBytesPerSec | Specifies the average data-transfer rate, in bytes per second.
 *
 * @field DWORD | nMinBytesPerSec | Specifies the minimum data-transfer rate, in bytes per second.
 *
 * @field DWORD | nMaxBytesPerSec | Specifies the maximum data-transfer rate, in bytes per second.
 *
 * @field DWORD | nBlockAlign | Specifies the block alignment, in bytes.
 *
 * @field DWORD | wBitsPerSample | Specifies the bits per sample for the wFormatTag format type.
 *
 * @field DWORD | dwRequestMicroSecPerFrame | Specifies the requested frame rate, in microseconds.
 *
 * @field DWORD | dwPercentDropForError | Specifies the maximum allowable percentage of dropped frames during capture.
 *
 * @field DWORD | dwNumVideoRequested | This specifies the maximum number of video buffers to allocate.
 *
 * @field DWORD | dwSupportTSTradeOff | Specifies the usage of temporal/spatial trade off.
 *
 * @field BOOL | bLive | Specifies if the preview is to be allowed.
 *
 * @field HWND | hWndParent | Specifies handle of the parent window.
 *
 * @field DWORD | dwFormatSize | Specifies the size of the actual video format.
 *
 * @field DWORD | biSize | Specifies the number of bytes required by the spatial information.
 *
 * @field LONG | biWidth | Specifies the width of the bitmap, in pixels.
 *
 * @field LONG | biHeight | Specifies the height of the bitmap, in pixels.
 *
 * @field WORD | biPlanes | Specifies the number of planes for the target device.
 *
 * @field WORD | biBitCount | Specifies the number of bits per pixel.
 *
 * @field DWORD | biCompression | Specifies the type of compression.
 *
 * @field DWORD | biSizeImage | Specifies the size, in bytes, of the image.
 *
 * @field LONG | biXPelsPerMeter | Specifies the horizontal resolution, in pixels per meter, of the target device for the bitmap.
 *
 * @field LONG | biYPelsPerMeter | Specifies the vertical resolution, in pixels per meter, of the target device for the bitmap.
 *
 * @field DWORD | biClrUsed | Specifies the number of color indices in the color table that are actually used by the bitmap.
 *
 * @field DWORD | biClrImportant | Specifies the number of color indices that are considered important for displaying the bitmap.
 *
 * @field DWORD | bmiColors[256] | Specifies an array of 256 RGBQUADs.
 *
 * @type PVIDEOFORMATEX | Pointer to a <t VIDEOFORMATEX> structure.
 *
 ****************************************************************************/

#define VCMAPI                                          WINAPI

/****************************************************************************
			vcmStrm Constants
****************************************************************************/
/*****************************************************************************
 * @doc EXTERNAL CONSTANTS
 *
 * @const WAVE_FORMAT_UNKNOWN | VIDEO_FORMAT_UNKNOWN | Constant for unknown video format.
 *
 * @const BI_RGB | VIDEO_FORMAT_BI_RGB | RGB video format.
 *
 * @const BI_RLE8 | VIDEO_FORMAT_BI_RLE8 | RLE 8 video format.
 *
 * @const BI_RLE4 | VIDEO_FORMAT_BI_RLE4 | RLE 4 video format.
 *
 * @const BI_BITFIELDS | VIDEO_FORMAT_BI_BITFIELDS | RGB Bit Fields video format.
 *
 * @const MAKEFOURCC('c','v','i','d') | VIDEO_FORMAT_CVID | Cinepack video format.
 *
 * @const MAKEFOURCC('I','V','3','2') | VIDEO_FORMAT_IV32 | Intel Indeo IV32 video format.
 *
 * @const MAKEFOURCC('Y','V','U','9') | VIDEO_FORMAT_YVU9 | Intel Indeo YVU9 video format.
 *
 * @const MAKEFOURCC('M','S','V','C') | VIDEO_FORMAT_MSVC | Microsoft CRAM video format.
 *
 * @const MAKEFOURCC('M','R','L','E') | VIDEO_FORMAT_MRLE | Microsoft RLE video format.
 *
 * @const MAKEFOURCC('h','2','6','3') | VIDEO_FORMAT_INTELH263 | Intel H.263 video format.
 *
 * @const MAKEFOURCC('h','2','6','1') | VIDEO_FORMAT_INTELH261 | Intel H.261 video format.
 *
 * @const MAKEFOURCC('M','2','6','3') | VIDEO_FORMAT_MSH263 | Microsoft H.263 video format.
 *
 * @const MAKEFOURCC('M','2','6','1') | VIDEO_FORMAT_MSH261 | Microsoft H.261 video format.
 *
 * @const MAKEFOURCC('V','D','E','C') | VIDEO_FORMAT_VDEC | Color QuickCam video format.
 *
 ****************************************************************************/
#define VIDEO_FORMAT_UNKNOWN		WAVE_FORMAT_UNKNOWN

#define VIDEO_FORMAT_BI_RGB			BI_RGB
#define VIDEO_FORMAT_BI_RLE8		BI_RLE8
#define VIDEO_FORMAT_BI_RLE4		BI_RLE4
#define VIDEO_FORMAT_BI_BITFIELDS	BI_BITFIELDS
#define VIDEO_FORMAT_CVID			MAKEFOURCC('C','V','I','D')	// hex: 0x44495643
#define VIDEO_FORMAT_IV31			MAKEFOURCC('I','V','3','1')	// hex: 0x31335649
#define VIDEO_FORMAT_IV32			MAKEFOURCC('I','V','3','2')	// hex: 0x32335649
#define VIDEO_FORMAT_YVU9			MAKEFOURCC('Y','V','U','9')	// hex: 0x39555659
#define VIDEO_FORMAT_I420			MAKEFOURCC('I','4','2','0')
#define VIDEO_FORMAT_IYUV			MAKEFOURCC('I','Y','U','V')
#define VIDEO_FORMAT_MSVC			MAKEFOURCC('M','S','V','C')	// hex: 0x4356534d
#define VIDEO_FORMAT_MRLE			MAKEFOURCC('M','R','L','E')	// hex: 0x454c524d
#define VIDEO_FORMAT_INTELH263		MAKEFOURCC('H','2','6','3')	// hex: 0x33363248
#define VIDEO_FORMAT_INTELH261		MAKEFOURCC('H','2','6','1')	// hex: 0x31363248
#define VIDEO_FORMAT_INTELI420		MAKEFOURCC('I','4','2','0')	// hex: 0x30323449
#define VIDEO_FORMAT_INTELRT21		MAKEFOURCC('R','T','2','1')	// hex: 0x31325452
#define VIDEO_FORMAT_MSH263			MAKEFOURCC('M','2','6','3')	// hex: 0x3336324d
#define VIDEO_FORMAT_MSH261			MAKEFOURCC('M','2','6','1')	// hex: 0x3136324d
#if !defined(_ALPHA_) && defined(USE_BILINEAR_MSH26X)
#define VIDEO_FORMAT_MSH26X			MAKEFOURCC('M','2','6','X')	// hex: 0x5836324d
#endif
#define VIDEO_FORMAT_Y411			MAKEFOURCC('Y','4','1','1')	// hex:
#define VIDEO_FORMAT_YUY2			MAKEFOURCC('Y','U','Y','2')	// hex:
#define VIDEO_FORMAT_YVYU			MAKEFOURCC('Y','V','Y','U')	// hex:
#define VIDEO_FORMAT_UYVY			MAKEFOURCC('U','Y','V','Y')	// hex:
#define VIDEO_FORMAT_Y211			MAKEFOURCC('Y','2','1','1')	// hex:
// VDOnet VDOWave codec
#define VIDEO_FORMAT_VDOWAVE		MAKEFOURCC('V','D','O','W')	// hex:
// Color QuickCam video codec
#define VIDEO_FORMAT_VDEC			MAKEFOURCC('V','D','E','C')	// hex: 0x43454456
// Dec Alpha
#define VIDEO_FORMAT_DECH263		MAKEFOURCC('D','2','6','3')	// hex: 0x33363248
#define VIDEO_FORMAT_DECH261		MAKEFOURCC('D','2','6','1')	// hex: 0x31363248
// MPEG4 Scrunch codec
#ifdef USE_MPEG4_SCRUNCH
#define VIDEO_FORMAT_MPEG4_SCRUNCH	MAKEFOURCC('M','P','G','4')	// hex:
#endif


//--------------------------------------------------------------------------;
//
//  VCM General API's and Defines
//
//
//
//
//--------------------------------------------------------------------------;

//
//  there are four types of 'handles' used by the VCM. the first three
//  are unique types that define specific objects:
//
//  HVCMDRIVERID: used to _identify_ an VCM driver. this identifier can be
//  used to _open_ the driver for querying details, etc about the driver.
//
//  HVCMDRIVER: used to manage a driver (codec, filter, etc). this handle
//  is much like a handle to other media drivers--you use it to send
//  messages to the converter, query for capabilities, etc.
//
//  HVCMSTREAM: used to manage a 'stream' (conversion channel) with the
//  VCM. you use a stream handle to convert data from one format/type
//  to another--much like dealing with a file handle.
//
//
//  the fourth handle type is a generic type used on VCM functions that
//  can accept two or more of the above handle types (for example the
//  vcmMetrics and vcmDriverID functions).
//
//  HVCMOBJ: used to identify VCM objects. this handle is used on functions
//  that can accept two or more VCM handle types.
//
DECLARE_HANDLE(HVCMDRIVERID);
typedef HVCMDRIVERID       *PHVCMDRIVERID;

DECLARE_HANDLE(HVCMDRIVER);
typedef HVCMDRIVER         *PHVCMDRIVER;

DECLARE_HANDLE(HVCMSTREAM);
typedef HVCMSTREAM         *PHVCMSTREAM;

DECLARE_HANDLE(HVCMOBJ);
typedef HVCMOBJ            *PHVCMOBJ;

/****************************************************************************
    callback function type
****************************************************************************/
typedef void (CALLBACK* VCMSTREAMPROC) (HVCMSTREAM hvs, UINT uMsg, DWORD_PTR dwInstance, DWORD_PTR dwParam1, DWORD_PTR dwParam2);

//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
//
//  VCM Error Codes
//
//  Note that these error codes are specific errors that apply to the VCM
//  directly--general errors are defined as MMSYSERR_*.
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

#ifndef _MMRESULT_
#define _MMRESULT_
typedef UINT                MMRESULT;
#endif

/*****************************************************************************
 * @doc EXTERNAL CONSTANTS
 *
 * @const ACMERR_BASE | VCMERR_BASE | Base for video errors.
 *
 * @const (VCMERR_BASE + 0) | VCMERR_NOTPOSSIBLE | Unsupported video compression format.
 *
 * @const (VCMERR_BASE + 1) | VCMERR_BUSY | Compression header is already or still queued.
 *
 * @const (VCMERR_BASE + 2) | VCMERR_UNPREPARED | Compression header is not prepared.
 *
 * @const (VCMERR_BASE + 3) | VCMERR_CANCELED | User canceled operation.
 *
 * @const (VCMERR_BASE + 4) | VCMERR_FAILED | Compression operation failed.
 *
 * @const (VCMERR_BASE + 5) | VCMERR_NOREGENTRY | Failed to read/write registry entry.
 *
 * @const (VCMERR_BASE + 6) | VCMERR_NONSPECIFIC | Some error occured.
 *
 * @const (VCMERR_BASE + 7) | VCERR_NOMOREPACKETS | No more packets to receive a payload header.
 *
 ****************************************************************************/
#define VCMERR_BASE				ACMERR_BASE
#define VCMERR_NOTPOSSIBLE		(VCMERR_BASE + 0)
#define VCMERR_BUSY				(VCMERR_BASE + 1)
#define VCMERR_UNPREPARED		(VCMERR_BASE + 2)
#define VCMERR_CANCELED			(VCMERR_BASE + 3)
#define VCMERR_FAILED			(VCMERR_BASE + 4)
#define VCMERR_NOREGENTRY		(VCMERR_BASE + 5)
#define VCMERR_NONSPECIFIC		(VCMERR_BASE + 6)
#define VCMERR_NOMOREPACKETS	(VCMERR_BASE + 7)
#define VCMERR_PSCMISSING		(VCMERR_BASE + 8)

//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
//
//  VCM Window Messages
//
//  These window messages are sent by the VCM or VCM drivers to notify
//  applications of events.
//
//  Note that these window message numbers will also be defined in
//  mmsystem.
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

/*****************************************************************************
 * @doc EXTERNAL COMPMSG
 *
 * @msg VCM_OPEN | This message is sent to a video compression callback function when
 *   a video compression stream is opened.
 *
 * @parm DWORD | dwParam1 | Currently unused.
 *
 * @parm DWORD | dwParam2 | Currently unused.
 *
 * @rdesc None
 *
 * @xref <m MM_VCM_OPEN>
 ****************************************************************************/

/*****************************************************************************
 * @doc EXTERNAL COMPMSG
 *
 * @msg MM_VCM_OPEN | This message is sent to a window when a video compression
 *   stream is opened.
 *
 * @parm WORD | wParam | Specifies a handle to the video compression stream
 *   that was opened.
 *
 * @parm LONG | lParam | Currently unused.
 *
 * @rdesc None
 *
 * @xref <m VCM_OPEN>
 ****************************************************************************/

/*****************************************************************************
 * @doc EXTERNAL COMPMSG
 *
 * @msg VCM_CLOSE | This message is sent to a video compression stream function when
 *   a video ccompression stream is closed. The stream handle is no longer
 *   valid once this message has been sent.
 *
 * @parm DWORD | dwParam1 | Currently unused.
 *
 * @parm DWORD | dwParam2 | Currently unused.
 *
 * @rdesc None
 *
 * @xref <m MM_VCM_CLOSE>
 ****************************************************************************/

/*****************************************************************************
 * @doc EXTERNAL COMPMSG
 *
 * @msg MM_VCM_CLOSE | This message is sent to a window when a video compression
 *   stream is closed. The stream handle is no longer valid once this message
 *   has been sent.
 *
 * @parm WORD | wParam | Specifies a handle to the video compression stream
 *   that was closed.
 *
 * @parm LONG | lParam | Currently unused.
 *
 * @rdesc None
 *
 * @xref <m VCM_CLOSE>
 ****************************************************************************/

/*****************************************************************************
 * @doc EXTERNAL COMPMSG
 *
 * @msg VCM_DONE | This message is sent to a video compression stream callback function when
 *   video data is present in the compression buffer and the buffer is being
 *   returned to the application. The message can be sent either when the
 *   buffer is full, or after the <f acmStreamReset> function is called.
 *
 * @parm DWORD | dwParam1 | Specifies a far pointer to a <t VCMSTREAMHDR> structure
 *   identifying the buffer containing the compressed video data.
 *
 * @parm DWORD | dwParam2 | Currently unused.
 *
 * @rdesc None
 *
 * @comm The returned buffer may not be full. Use the <e VCMSTREAMHDR.dwDstBytesUsed>
 *   field of the <t VCMSTREAMHDR> structure specified by <p dwParam1> to
 *   determine the number of valid bytes into the returned buffer.
 *
 * @xref <m MM_VCM_DONE>
 ****************************************************************************/

/*****************************************************************************
 * @doc EXTERNAL COMPMSG
 *
 * @msg MM_VCM_DONE | This message is sent to a window when video data is
 *   present in the compression buffer and the buffer is being returned to the
 *   application. The message can be sent either when the buffer is full, or
 *   after the <f acmStreamReset> function is called.
 *
 * @parm WORD | wParam | Specifies a handle to the video compression stream
 *   that received the compressed video data.
 *
 * @parm LONG | lParam | Specifies a far pointer to a <t VCMSTREAMHDR> structure
 *   identifying the buffer containing the compressed video data.
 *
 * @rdesc None
 *
 * @comm The returned buffer may not be full. Use the <e VCMSTREAMHDR.dwDstBytesUsed>
 *   field of the <t VCMSTREAMHDR> structure specified by <p lParam> to
 *   determine the number of valid bytes into the returned buffer.
 *
 * @xref <m VCM_DONE>
 ****************************************************************************/

#define MM_VCM_OPEN         (MM_STREAM_OPEN)  // conversion callback messages
#define MM_VCM_CLOSE        (MM_STREAM_CLOSE)
#define MM_VCM_DONE         (MM_STREAM_DONE)
#define VCM_OPEN                        (MM_STREAM_OPEN)  // conversion states
#define VCM_CLOSE                       (MM_STREAM_CLOSE)
#define VCM_DONE                        (MM_STREAM_DONE)


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
//
//  vcmMetrics()
//
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

MMRESULT VCMAPI vcmMetrics
(
    HVCMOBJ                 hvo,
    UINT                    uMetric,
    LPVOID                  pMetric
);

#define VCM_METRIC_COUNT_DRIVERS            1
#define VCM_METRIC_COUNT_CODECS             2
#define VCM_METRIC_COUNT_CONVERTERS         3
#define VCM_METRIC_COUNT_FILTERS            4
#define VCM_METRIC_COUNT_DISABLED           5
#define VCM_METRIC_COUNT_HARDWARE           6
#define VCM_METRIC_COUNT_COMPRESSORS        7
#define VCM_METRIC_COUNT_DECOMPRESSORS      8
#define VCM_METRIC_COUNT_LOCAL_DRIVERS      20
#define VCM_METRIC_COUNT_LOCAL_CODECS       21
#define VCM_METRIC_COUNT_LOCAL_CONVERTERS   22
#define VCM_METRIC_COUNT_LOCAL_FILTERS      23
#define VCM_METRIC_COUNT_LOCAL_DISABLED     24
#define VCM_METRIC_HARDWARE_VIDEO_INPUT      30
#define VCM_METRIC_HARDWARE_VIDEO_OUTPUT     31
#define VCM_METRIC_MAX_SIZE_FORMAT          50
#define VCM_METRIC_MAX_SIZE_FILTER          51
#define VCM_METRIC_MAX_SIZE_BITMAPINFOHEADER 52
#define VCM_METRIC_DRIVER_SUPPORT           100
#define VCM_METRIC_DRIVER_PRIORITY          101

//--------------------------------------------------------------------------;
//
//  VCM Drivers
//
//
//
//
//--------------------------------------------------------------------------;

#define VCMDM_USER                  (DRV_USER + 0x0000)
#define VCMDM_RESERVED_LOW          (DRV_USER + 0x2000)
#define VCMDM_RESERVED_HIGH         (DRV_USER + 0x2FFF)

#define VCMDM_BASE                  VCMDM_RESERVED_LOW

#define VCMDM_DRIVER_ABOUT          (VCMDM_BASE + 11)


//
//  VCMDRIVERDETAILS
//
//  the VCMDRIVERDETAILS structure is used to get various capabilities from
//  an VCM driver (codec, converter, filter).
//
#define VCMDRIVERDETAILS_SHORTNAME_CHARS        16
#define VCMDRIVERDETAILS_LONGNAME_CHARS         128
#define VCMDRIVERDETAILS_MODULE_CHARS           128

/*****************************************************************************
 *  @doc EXTERNAL COMPSTRUCTENUM
 *
 *  @struct VCMDRIVERDETAILS | The <t VCMDRIVERDETAILS> structure describes
 *      various details of a Video Compression Manager (VCM) driver.
 *
 *  @field DWORD | dwSize | Specifies the size, in bytes,  of the valid
 *      information contained in the <t VCMDRIVERDETAILS> structure.
 *      An application should initialize this member to the size, in bytes, of
 *      the desired information. The size specified in this member must be
 *      large enough to contain the <e VCMDRIVERDETAILS.dwSize> member of
 *      the <t VCMDRIVERDETAILS> structure. When the <f vcmDriverDetails>
 *      function returns, this member contains the actual size of the
 *      information returned. The returned information will never exceed
 *      the requested size.
 *
 *  @field FOURCC | fccType | Specifies the type of the driver. For VCM drivers, set
 *      this member to <p vidc>, which represents VCMDRIVERDETAILS_FCCTYPE_VIDEOCODEC.
 *
 *  @field FOURCC | fccHandler | Specifies a four-character code identifying a specific compressor.
 *
 *  @field DWORD | dwFlags | Specifies applicable flags.
 *
 *  @field DWORD | dwVersion | Specifies version number of the driver.
 *
 *  @field DWORD | dwVersionICM | Specifies theersion of VCM supported by the driver.
 *      This member should be set to ICVERSION.
 *
 *  @field WCHAR | szName[VCMDRIVERDETAILS_SHORTNAME_CHARS] | Specifies
 *      a NULL-terminated string that describes the short version of the compressor name.
 *
 *  @field WCHAR | szDescription[VCMDRIVERDETAILS_LONGNAME_CHARS] | Specifies a
 *      NULL-terminated string that describes the long version of the compressor name.
 *
 *  @field WCHAR | szDriver[VCMDRIVERDETAILS_MODULE_CHARS] | Specifies
 *      a NULL-terminated string that provides the name of the module containing the VCM compression driver.
 *
 *  @xref <f vcmDriverDetails>
 ****************************************************************************/
// This structure is equivalent to ICINFO
typedef struct tVCMDRIVERDETAILS
{
	DWORD   dwSize;                                                                                 // Size, in bytes, of this structure
	DWORD   fccType;                                                                                // Four-character code indicating the type of stream being compressed or decompressed. Specify "VIDC" for video streams.
	DWORD   fccHandler;                                                                             // A four-character code identifying a specific compressor
	DWORD   dwFlags;                                                                                // Applicable flags
	DWORD   dwVersion;                                                                              // Version number of the driver
	DWORD   dwVersionICM;                                                                   // Version of VCM supported by the driver. This member should be set to ICVERSION
	WCHAR   szName[VCMDRIVERDETAILS_SHORTNAME_CHARS];               // Short version of the compressor name
	WCHAR   szDescription[VCMDRIVERDETAILS_LONGNAME_CHARS]; // Long version of the compressor name
	WCHAR   szDriver[VCMDRIVERDETAILS_MODULE_CHARS];                // Name of the module containing VCM compression driver. Normally, a driver does not need to fill this out.
} VCMDRIVERDETAILS, *PVCMDRIVERDETAILS;

#define VCMDRIVERDETAILS_FCCTYPE_VIDEOCODEC mmioFOURCC('v', 'i', 'd', 'c')
#define VCMDRIVERDETAILS_FCCCOMP_UNDEFINED  mmioFOURCC('\0', '\0', '\0', '\0')

MMRESULT VCMAPI vcmDriverDetails
(
    PVCMDRIVERDETAILS   pvdd
);

//--------------------------------------------------------------------------;
//
//  VCM Format Tags
//
//
//
//
//--------------------------------------------------------------------------;

//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
//
//  vcmFormatTagDetails()
//
//
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

#define VCMFORMATTAGDETAILS_FORMATTAG_CHARS 48

typedef struct tVCMFORMATTAGDETAILSA
{
    DWORD           cbStruct;
    DWORD           dwFormatTagIndex;
    DWORD           dwFormatTag;
    DWORD           cbFormatSize;
    DWORD           fdwSupport;
    DWORD           cStandardFormats;
    char            szFormatTag[VCMFORMATTAGDETAILS_FORMATTAG_CHARS];

} VCMFORMATTAGDETAILSA, *PVCMFORMATTAGDETAILSA;

typedef struct tVCMFORMATTAGDETAILSW
{
    DWORD           cbStruct;
    DWORD           dwFormatTagIndex;
    DWORD           dwFormatTag;
    DWORD           cbFormatSize;
    DWORD           fdwSupport;
    DWORD           cStandardFormats;
    WCHAR           szFormatTag[VCMFORMATTAGDETAILS_FORMATTAG_CHARS];

} VCMFORMATTAGDETAILSW, *PVCMFORMATTAGDETAILSW;

#ifdef _UNICODE
#define VCMFORMATTAGDETAILS     VCMFORMATTAGDETAILSW
#define PVCMFORMATTAGDETAILS    PVCMFORMATTAGDETAILSW
#else
#define VCMFORMATTAGDETAILS     VCMFORMATTAGDETAILSA
#define PVCMFORMATTAGDETAILS    PVCMFORMATTAGDETAILSA
#endif

#define VCM_FORMATTAGDETAILSF_INDEX         0x00000000L
#define VCM_FORMATTAGDETAILSF_FORMATTAG     0x00000001L
#define VCM_FORMATTAGDETAILSF_LARGESTSIZE   0x00000002L
#define VCM_FORMATTAGDETAILSF_QUERYMASK     0x0000000FL

//--------------------------------------------------------------------------;
//
//  VCM Formats
//
//
//
//
//--------------------------------------------------------------------------;

#define VCMFORMATDETAILS_FORMAT_CHARS   128

/*****************************************************************************
 *  @doc EXTERNAL COMPSTRUCTENUM
 *
 *  @struct VCMFORMATDETAILS | The <t VCMFORMATDETAILS> structure details a
 *      video format.
 *
 *  @field DWORD | cbStruct | Specifies the size, in bytes, of the
 *      <t VCMFORMATDETAILS> structure. This member must be initialized
 *      before calling the <f vcmFormatDetails> or <f vcmFormatEnum>
 *      functions. The size specified in this member must be large enough to
 *      contain the base <t VCMFORMATDETAILS> structure. When the
 *      <f vcmFormatDetails> function returns, this member contains the
 *      actual size of the information returned. The returned information
 *      will never exceed the requested size.
 *
 *  @field DWORD | dwFormatTag | Specifies the video format tag that the
 *      <t VCMFORMATDETAILS> structure describes. This member is always
 *      returned if the <f vcmFormatDetails> is successful. This member
 *      should be set to VIDEO_FORMAT_UNKNOWN before calling <f vcmFormatDetails>.
 *
 *  @field DWORD | dwFlags | Specifies if the format the <p pvfx> field points
 *      to is a format that can be generated by the capture driver + codec, decompressed
 *      by the codec, or both.
 *
 *      @flag VCM_FORMATENUMF_INPUT | Specifies that the format enumerated can be transmitted.
 *
 *      @flag VCM_FORMATENUMF_OUTPUT | Specifies that the format enumerated can be received.
 *
 *      @flag VCM_FORMATENUMF_BOTH | Specifies that the format enumerated can be transmitted and received.
 *
 *  @field PVIDEOFORMATEX | pvfx | Specifies a pointer to a <t VIDEOFORMATEX>
 *      data structure that will receive the format details. This structure requires no initialization
 *      by the application.
 *
 *  @field DWORD | cbvfx | Specifies the size, in bytes, available for
 *      the <e VCMFORMATDETAILS.pvfx> to receive the format details. The
 *      <f vcmMetrics> function can be used to
 *      determine the maximum size required for any format available for
 *      all installed VCM drivers.
 *
 *  @field char | szFormat[VCMFORMATDETAILS_FORMAT_CHARS] |
 *      Specifies a string that describes the format for the
 *      <e VCMFORMATDETAILS.dwFormatTag> type. This string is always returned
 *      if the <f vcmFormatDetails> function is successful.
 *
 *  @xref <f vcmFormatDetails> <f vcmFormatEnum>
 ****************************************************************************/
typedef struct tVCMFORMATDETAILS
{
    DWORD           cbStruct;
    DWORD           dwFormatTag;
    DWORD           dwFlags;
    PVIDEOFORMATEX  pvfx;
    DWORD           cbvfx;
    WCHAR           szFormat[VCMFORMATDETAILS_FORMAT_CHARS];
} VCMFORMATDETAILS, *PVCMFORMATDETAILS;

MMRESULT VCMAPI vcmFormatDetails
(
    PVCMFORMATDETAILS   pvfd
);

//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
//
//  vcmFormatEnum()
//
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

/****************************************************************************
 *  @doc  EXTERNAL COMPFUNC
 *
 *  @func BOOL VCMFORMATENUMCB | vcmFormatEnumCallback |
 *      The <f ccmFormatEnumCallback> function refers to the callback function used for
 *      Video Compression Manager (VCM) video format detail enumeration. The
 *      <f vcmFormatEnumCallback> is a placeholder for the application-supplied
 *      function name.
 *
 *  @parm HVCMDRIVERID | hvdid | Specifies a VCM driver identifier.
 *
 *  @parm  PVCMDRIVERDETAILS | pvfd | Specifies a pointer to a
 *      <t VCMDRIVERDETAILS> structure that contains the enumerated
 *      driver details.
 *
 *  @parm  PVCMFORMATDETAILS | pvfd | Specifies a pointer to a
 *      <t VCMFORMATDETAILS> structure that contains the enumerated
 *      format details.
 *
 *  @parm DWORD | dwInstance | Specifies the application-defined value
 *      specified in the <f vcmFormatEnum> function.
 *
 *  @rdesc The callback function must return TRUE to continue enumeration;
 *      to stop enumeration, it must return FALSE.
 *
 *  @comm The <f vcmFormatEnum> function will return MMSYSERR_NOERROR
 *      (zero) if no formats are to be enumerated. Moreover, the callback
 *      function will not be called.
 *
 *  @xref <f vcmFormatEnum> <f vcmFormatDetails>
 ***************************************************************************/
typedef BOOL (CALLBACK *VCMFORMATENUMCB)
(
    HVCMDRIVERID            hvdid,
    PVCMDRIVERDETAILS      pvdd,
    PVCMFORMATDETAILS      pvfd,
    DWORD_PTR              dwInstance
);

MMRESULT VCMAPI vcmFormatEnum
(
	UINT					uDevice,
	VCMFORMATENUMCB         fnCallback,
	PVCMDRIVERDETAILS       pvdd,
	PVCMFORMATDETAILS       pvfd,
	DWORD_PTR               dwInstance,
	DWORD                           fdwEnum
);

//#define VCM_FORMATENUMF_WFORMATTAG       0x00010000L
//#define VCM_FORMATENUMF_NCHANNELS        0x00020000L
//#define VCM_FORMATENUMF_NSAMPLESPERSEC   0x00040000L
//#define VCM_FORMATENUMF_WBITSPERSAMPLE   0x00080000L
//#define VCM_FORMATENUMF_CONVERT          0x00100000L
//#define VCM_FORMATENUMF_SUGGEST          0x00200000L
#define VCM_FORMATENUMF_INPUT           0x00400000L
#define VCM_FORMATENUMF_OUTPUT          0x00800000L
#define VCM_FORMATENUMF_BOTH            0x01000000L

#define VCM_FORMATENUMF_TYPEMASK        0x01C00000L

#define VCM_FORMATENUMF_APP			0x00000000L
#define VCM_FORMATENUMF_ALL			0x02000000L
#define VCM_FORMATENUMF_ALLMASK		VCM_FORMATENUMF_ALL

typedef struct
{
    WORD biWidth;
    WORD biHeight;
} MYFRAMESIZE;

typedef struct
{
	DWORD fccType;
	DWORD fccHandler;
	MYFRAMESIZE framesize[3];
} VCM_APP_ICINFO, *PVCM_APP_ICINFO;

typedef struct
{
    DWORD dwRes;
    MYFRAMESIZE framesize;
} NCAP_APP_INFO, *PNCAP_APP_INFO;

//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
//
//  vcmFormatSuggest()
//
//
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

MMRESULT VCMAPI vcmFormatSuggest
(
	UINT				uDevice,
    HVCMDRIVER          hvd,
    PVIDEOFORMATEX      pvfxSrc,
    PVIDEOFORMATEX      pvfxDst,
    DWORD               cbvfxDst,
    DWORD               fdwSuggest
);

#define VCM_FORMATSUGGESTF_DST_WFORMATTAG       0x00010000L
#define VCM_FORMATSUGGESTF_DST_NSAMPLESPERSEC   0x00020000L
#define VCM_FORMATSUGGESTF_DST_WBITSPERSAMPLE   0x00040000L

#define VCM_FORMATSUGGESTF_SRC_WFORMATTAG       0x00100000L
#define VCM_FORMATSUGGESTF_SRC_NSAMPLESPERSEC   0x00200000L
#define VCM_FORMATSUGGESTF_SRC_WBITSPERSAMPLE   0x00400000L

#define VCM_FORMATSUGGESTF_TYPEMASK         0x00FF0000L


//--------------------------------------------------------------------------;
//
//  VCM Stream API's
//
//
//
//--------------------------------------------------------------------------;

//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
//
//  vcmStreamOpen()
//
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

/*****************************************************************************
 *  @doc EXTERNAL COMPSTRUCTENUM
 *
 *  @struct VCMSTREAMHEADER | The <t VCMSTREAMHEADER> structure defines the
 *      header used to identify an Video Compression Manager (VCM) conversion
 *      source and destination buffer pair for a conversion stream.
 *
 *  @field DWORD | cbStruct | Specifies the size, in bytes, of the
 *      <t VCMSTREAMHEADER> structure. This member must be initialized
 *      before calling any VCM stream functions using this structure.
 *      The size specified in this member must be large enough to contain
 *      the base <t VCMSTREAMHEADER> structure.
 *
 *  @field DWORD | fdwStatus | Specifies flags giving information about
 *      the conversion buffers. This member must be initialized to zero
 *      before calling <f vcmStreamPrepareHeader> and should not be modified
 *      by the application while the stream header remains prepared.
 *
 *      @flag VCMSTREAMHEADER_STATUSF_DONE | Set by the VCM or driver to
 *      indicate that it is finished with the conversion and is returning it
 *      to the application.
 *
 *      @flag VCMSTREAMHEADER_STATUSF_PREPARED | Set by the VCM to indicate
 *      that the data buffers have been prepared with <f acmStreamPrepareHeader>.
 *
 *      @flag VCMSTREAMHEADER_STATUSF_INQUEUE | Set by the VCM or driver to
 *      indicate that the data buffers are queued for conversion.
 *
 *  @field DWORD | dwUser | Specifies 32 bits of user data. This can be any
 *      instance data specified by the application.
 *
 *  @field PBYTE | pbSrc | Specifies a pointer to the source data buffer.
 *      This pointer must always refer to the same location while the stream
 *      header remains prepared. If an application needs to change the
 *      source location, it must unprepare the header and re-prepare it
 *      with the alternate location.
 *
 *  @field DWORD | cbSrcLength | Specifies the length, in bytes, of the source
 *      data buffer pointed to by <e VCMSTREAMHEADER.pbSrc>. When the
 *      header is prepared, this member must specify the maximum size
 *      that will be used in the source buffer. Conversions can be performed
 *      on source lengths less than or equal to the original prepared size.
 *      However, this member must be reset to the original size when
 *      unpreparing the header.
 *
 *  @field DWORD | cbSrcLengthUsed | Specifies the amount of data, in bytes,
 *      used for the conversion. This member is not valid until the
 *      conversion is complete. Note that this value can be less than or
 *      equal to <e VCMSTREAMHEADER.cbSrcLength>. An application must use
 *      the <e VCMSTREAMHEADER.cbSrcLengthUsed> member when advancing to
 *      the next piece of source data for the conversion stream.
 *
 *  @field DWORD | dwSrcUser | Specifies 32 bits of user data. This can be
 *      any instance data specified by the application.
 *
 *  @field PBYTE | pbDst | Specifies a pointer to the destination data
 *      buffer. This pointer must always refer to the same location while
 *      the stream header remains prepared. If an application needs to change
 *      the destination location, it must unprepare the header and re-prepare
 *      it with the alternate location.
 *
 *  @field DWORD | cbDstLength | Specifies the length, in bytes, of the
 *      destination data buffer pointed to by <e VCMSTREAMHEADER.pbDst>.
 *      When the header is prepared, this member must specify the maximum
 *      size that will be used in the destination buffer. Conversions can be
 *      performed to destination lengths less than or equal to the original
 *      prepared size. However, this member must be reset to the original
 *      size when unpreparing the header.
 *
 *  @field DWORD | cbDstLengthUsed | Specifies the amount of data, in bytes,
 *      returned by a conversion. This member is not valid until the
 *      conversion is complete. Note that this value may be less than or
 *      equal to <e ACMSTREAMHEADER.cbDstLength>. An application must use
 *      the <e ACMSTREAMHEADER.cbDstLengthUsed> member when advancing to
 *      the next destination location for the conversion stream.
 *
 *  @field DWORD | dwDstUser | Specifies 32 bits of user data. This can be
 *      any instance data specified by the application.
 *
 *  @field PBYTE | pbPrev | Specifies a pointer to the previous destination data
 *      buffer. This pointer must always refer to the same location while
 *      the stream header remains prepared. If an application needs to change
 *      the destination location, it must unprepare the header and re-prepare
 *      it with the alternate location.
 *
 *  @field DWORD | cbPrevLength | Specifies the length, in bytes, of the previous
 *      destination data buffer pointed to by <e VCMSTREAMHEADER.pbPrev>.
 *      When the header is prepared, this member must specify the maximum
 *      size that will be used in the destination buffer. Conversions can be
 *      performed to destination lengths less than or equal to the original
 *      prepared size. However, this member must be reset to the original
 *      size when unpreparing the header.
 *
 *  @field DWORD | cbPrevLengthUsed | Specifies the amount of data, in bytes,
 *      returned by a conversion. This member is not valid until the
 *      conversion is complete. Note that this value may be less than or
 *      equal to <e VCMSTREAMHEADER.cbPrevLength>. An application must use
 *      the <e VCMSTREAMHEADER.cbPrevLengthUsed> member when advancing to
 *      the next destination location for the conversion stream.
 *
 *  @field DWORD | dwDstUser | Specifies 32 bits of user data. This can be
 *      any instance data specified by the application.
 *
 *  @field struct tVCMSTREAMHEADER * | lpNext | Reserved for driver use and should not be
 *      used. Typically, this maintains a linked list of buffers in the queue.
 *
 *  @field DWORD | reserved | Reserved for driver use and should not be used.
 *
 *  @type PVCMSTREAMHEADER | Pointer to a <t VCMSTREAMHEADER> structure.
 *
 *  @comm Before an <t VCMSTREAMHEADER> structure can be used for a conversion, it must
 *      be prepared with <f vcmStreamPrepareHeader>. When an application
 *      is finished with an <t VCMSTREAMHEADER> structure, the <f vcmStreamUnprepareHeader>
 *      function must be called before freeing the source and destination buffers.
 *
 *  @xref <f vcmStreamPrepareHeader> <f vcmStreamUnprepareHeader>
 *      <f vcmStreamConvert>
 ****************************************************************************/
typedef struct tVCMSTREAMHEADER
{
    DWORD           cbStruct;               // sizeof(VCMSTREAMHEADER)
    DWORD           fdwStatus;                          // status flags
    DWORD           dwUser;                 // user instance data for hdr
    PBYTE           pbSrc;
    DWORD           cbSrcLength;
    DWORD           cbSrcLengthUsed;
    DWORD           dwSrcUser;              // user instance data for src
    PBYTE           pbDst;
    DWORD           cbDstLength;
    DWORD           cbDstLengthUsed;
    DWORD           dwDstUser;              // user instance data for dst
    PBYTE           pbPrev;
    DWORD           cbPrevLength;
    DWORD           cbPrevLengthUsed;
    DWORD           dwPrevUser;             // user instance data for prev
    struct tVCMSTREAMHEADER *pNext;             // reserved for driver
    DWORD                       reserved;               // reserved for driver
} VCMSTREAMHEADER, *PVCMSTREAMHEADER;

typedef struct tVCMSTREAM
{
	HVCMDRIVER				hIC;				// Handle to driver (HIC)
	DWORD					dwICInfoFlags;		// Some properties of the compressor
	HWND					hWndParent;			// Handle to the parent window
	DWORD_PTR				dwCallback;			// Callback function, event, thread or window
	DWORD_PTR				dwCallbackInstance;	// User instance data
	DWORD					fdwOpen;			// Defines type of callback
	struct tVCMSTREAMHEADER	*pvhLast;			// Last of the list
	struct tVCMSTREAMHEADER	*pvhFirst;			// First of the list
	PVIDEOFORMATEX			pvfxSrc;			// Format of input buffers
	PVIDEOFORMATEX			pvfxDst;			// Format of output buffers
	BITMAPINFOHEADER		*pbmiPrev;			// Format of previous buffers
	UINT					cSrcPrepared;		// Number of input headers prepared
	UINT					cDstPrepared;		// Number of output headers prepared
	DWORD					dwFrame;			// Current frame number
	DWORD					dwQuality;			// Compression quality value
	DWORD					dwMaxPacketSize;	// Targeted max packet size for encode
	DWORD					fdwStream;			// Stream state flags, etc.
	CRITICAL_SECTION		crsFrameNumber;		// Used to allow the UI to request an I-Frame
	DWORD					dwLastTimestamp;	// Last known good timestamp
	DWORD					dwTargetByterate;	// Target bitrate
	DWORD					dwTargetFrameRate;	// Target frame rate
	BOOL					fPeriodicIFrames;	// Set to TRUE if we need to generate I-Frames periodically
	DWORD					dwLastIFrameTime;	// Holds the last time an I-Frame was generated
} VCMSTREAM, *PVCMSTREAM;

//
//  VCMSTREAMHEADER.fdwStatus
//
//  VCMSTREAMHEADER_STATUSF_DONE: done bit for async conversions.
//
#define VCMSTREAMHEADER_STATUSF_DONE        0x00010000L
#define VCMSTREAMHEADER_STATUSF_PREPARED    0x00020000L
#define VCMSTREAMHEADER_STATUSF_INQUEUE     0x00100000L

MMRESULT VCMAPI vcmStreamOpen
(
    PHVCMSTREAM             phas,			// pointer to stream handle
    HVCMDRIVER              had,			// optional driver handle
    PVIDEOFORMATEX          pvfxSrc,		// source format to convert
    PVIDEOFORMATEX          pvfxDst,		// required destination format
    DWORD                   dwImageQuality, // image compression factor
    DWORD					dwPacketSize,	// target fragment size
    DWORD_PTR               dwCallback,		// callback
    DWORD_PTR               dwInstance,		// callback instance data
    DWORD                   fdwOpen			// VCM_STREAMOPENF_* and CALLBACK_*
);

#define VCM_STREAMOPENF_QUERY           0x00000001
#define VCM_STREAMOPENF_ASYNC           0x00000002
#define VCM_STREAMOPENF_NONREALTIME     0x00000004

//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
//
//  vcmStreamClose()
//
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

MMRESULT VCMAPI vcmStreamClose
(
    HVCMSTREAM              hvs
);

//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
//
//  vcmStreamSize()
//
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

MMRESULT VCMAPI vcmStreamSize
(
    HVCMSTREAM              has,
    DWORD                   cbInput,
    PDWORD                  pdwOutputBytes,
    DWORD                   fdwSize
);

#define VCM_STREAMSIZEF_SOURCE          0x00000000L
#define VCM_STREAMSIZEF_DESTINATION     0x00000001L
#define VCM_STREAMSIZEF_QUERYMASK       0x0000000FL

//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
//
//  vcmStreamReset()
//
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

MMRESULT VCMAPI vcmStreamReset
(
    HVCMSTREAM              has
);

//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
//
//  vcmStreamMessage()
//
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

MMRESULT VCMAPI vcmStreamMessage
(
    HVCMSTREAM              has,
    UINT                    uMsg,
    LPARAM                  lParam1,
    LPARAM                  lParam2
);

//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
//
//  vcmStreamConvert()
//
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

MMRESULT VCMAPI vcmStreamConvert
(
    HVCMSTREAM              has,
    PVCMSTREAMHEADER       pash,
    DWORD                   fdwConvert
);

#define VCM_STREAMCONVERTF_BLOCKALIGN           0x00000004
#define VCM_STREAMCONVERTF_START                        0x00000010
#define VCM_STREAMCONVERTF_END                          0x00000020
#define VCM_STREAMCONVERTF_FORCE_KEYFRAME   0x00000040

//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
//
//  vcmStreamPrepareHeader()
//
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

MMRESULT VCMAPI vcmStreamPrepareHeader
(
    HVCMSTREAM          has,
    PVCMSTREAMHEADER   pash,
    DWORD               fdwPrepare
);

//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
//
//  vcmStreamUnprepareHeader()
//
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

MMRESULT VCMAPI vcmStreamUnprepareHeader
(
    HVCMSTREAM          has,
    PVCMSTREAMHEADER   pash,
    DWORD               fdwUnprepare
);

//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
//
//  Device Capabilities Functions
//
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

MMRESULT VCMAPI vcmGetDevCaps(UINT uDevice, PVIDEOINCAPS pvc, UINT cbvc);
MMRESULT VCMAPI vcmDevCapsReadFromReg(LPSTR szDeviceName, LPSTR szDeviceVersion, PVIDEOINCAPS pvc, UINT cbvc);
MMRESULT VCMAPI vcmDevCapsProfile(UINT uDevice, PVIDEOINCAPS pvc, UINT cbvc);
MMRESULT VCMAPI vcmDevCapsWriteToReg(LPSTR szDeviceName, LPSTR szDeviceVersion, PVIDEOINCAPS pvc, UINT cbvc);
MMRESULT VCMAPI vcmGetDevCapsFrameSize(PVIDEOFORMATEX pvfx, PINT piWidth, PINT piHeight);
MMRESULT VCMAPI vcmGetDevCapsPreferredFormatTag(UINT uDevice, PDWORD pdwFormatTag);
MMRESULT VCMAPI vcmGetDevCapsStreamingMode(UINT uDevice, PDWORD pdwStreamingMode);
MMRESULT VCMAPI vcmGetDevCapsDialogs(UINT uDevice, PDWORD pdwDialogs);
MMRESULT VCMAPI vcmReleaseResources();

//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
//
//  Post-processing Functions
//
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

BOOL VCMAPI vcmStreamIsPostProcessingSupported(HVCMSTREAM hvs);
MMRESULT VCMAPI vcmStreamSetBrightness(HVCMSTREAM hvs, DWORD dwBrightness);
MMRESULT VCMAPI vcmStreamSetContrast(HVCMSTREAM hvs, DWORD dwContrast);
MMRESULT VCMAPI vcmStreamSetSaturation(HVCMSTREAM hvs, DWORD dwSaturation);
MMRESULT VCMAPI vcmStreamSetImageQuality(HVCMSTREAM hvs, DWORD dwImageQuality);

#define PLAYBACK_CUSTOM_START				(ICM_RESERVED_HIGH     + 1)
#define PLAYBACK_CUSTOM_CHANGE_BRIGHTNESS	(PLAYBACK_CUSTOM_START + 0)
#define PLAYBACK_CUSTOM_CHANGE_CONTRAST		(PLAYBACK_CUSTOM_START + 1)
#define PLAYBACK_CUSTOM_CHANGE_SATURATION	(PLAYBACK_CUSTOM_START + 2)

#define	G723MAGICWORD1							0xf7329ace
#define	G723MAGICWORD2							0xacdeaea2
#define CUSTOM_ENABLE_CODEC						(ICM_RESERVED_HIGH+201)

#define VCM_MAX_BRIGHTNESS		255UL
#define VCM_MIN_BRIGHTNESS		1UL
#define VCM_RESET_BRIGHTNESS	256UL
#define VCM_DEFAULT_BRIGHTNESS	128UL
#define VCM_MAX_CONTRAST		255UL
#define VCM_MIN_CONTRAST		1UL
#define VCM_RESET_CONTRAST		256UL
#define VCM_DEFAULT_CONTRAST	128UL
#define VCM_MAX_SATURATION		255UL
#define VCM_MIN_SATURATION		1UL
#define VCM_RESET_SATURATION	256UL
#define VCM_DEFAULT_SATURATION	128UL

//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
//
//  Custom Encoder Control Functions
//
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

MMRESULT VCMAPI vcmStreamSetMaxPacketSize(HVCMSTREAM hvs, DWORD dwMaxPacketSize);

#define CUSTOM_START					(ICM_RESERVED_HIGH + 1)
#define CODEC_CUSTOM_ENCODER_CONTROL	(CUSTOM_START      + 9)

// CUSTOM_ENCODER_CONTROL: HIWORD(lParam1)
#define EC_SET_CURRENT               0
#define EC_GET_FACTORY_DEFAULT       1
#define EC_GET_FACTORY_LIMITS        2
#define EC_GET_CURRENT               3
#define EC_RESET_TO_FACTORY_DEFAULTS 4

// CUSTOM_ENCODER_CONTROL: LOWORD(lParam1)
#define EC_RTP_HEADER                0
#define EC_RESILIENCY                1
#define EC_PACKET_SIZE               2
#define EC_PACKET_LOSS               3
#define EC_BITRATE_CONTROL			 4
#define EC_BITRATE					 5

#define VCM_MAX_PACKET_SIZE		9600UL
#define VCM_MIN_PACKET_SIZE		64UL
#define VCM_RESET_PACKET_SIZE	512UL
#define VCM_DEFAULT_PACKET_SIZE	512UL

//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
//
//  Compression Ratio and Compression Options Functions
//
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

MMRESULT VCMAPI vcmStreamSetImageQuality(HVCMSTREAM hvs, DWORD dwImageQuality);
MMRESULT VCMAPI vcmStreamRequestIFrame(HVCMSTREAM hvs);
MMRESULT VCMAPI vcmStreamPeriodicIFrames(HVCMSTREAM hvs, BOOL fPeriodicIFrames);
MMRESULT VCMAPI vcmStreamSetTargetRates(HVCMSTREAM hvs, DWORD dwTargetFrameRate, DWORD dwTargetByterate);

#define MIN_IFRAME_REQUEST_INTERVAL 15000

#define VCM_MAX_IMAGE_QUALITY		0UL
#define VCM_MIN_IMAGE_QUALITY		31UL

#define VCM_RESET_IMAGE_QUALITY		VCM_MAX_IMAGE_QUALITY
#define VCM_DEFAULT_IMAGE_QUALITY	VCM_MAX_IMAGE_QUALITY

#define VCM_MAX_FRAME_RATE			2997UL
#define VCM_MIN_FRAME_RATE			20UL
#define VCM_RESET_FRAME_RATE		700UL
#define VCM_DEFAULT_FRAME_RATE		700UL
#define VCM_MAX_BYTE_RATE			187500UL
#define VCM_MIN_BYTE_RATE			1UL
#define VCM_RESET_BYTE_RATE			1664UL
#define VCM_DEFAULT_BYTE_RATE		1664UL
#define VCM_MAX_FRAME_SIZE			32768UL
#define VCM_MIN_FRAME_SIZE			1UL
#define VCM_RESET_FRAME_SIZE		235UL
#define VCM_DEFAULT_FRAME_SIZE		235UL
#define VCM_MAX_TRADE_OFF			31UL
#define VCM_MIN_TRADE_OFF			1UL
#define VCM_RESET_TRADE_OFF			31UL
#define VCM_DEFAULT_TRADE_OFF		31UL


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
//
//  RTP Payload Functions
//
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

MMRESULT VCMAPI vcmStreamFormatPayload(HVCMSTREAM hvs, PBYTE pDataSrc, DWORD dwDataSize, PBYTE *ppDataPkt, PDWORD pdwPktSize,
				       PDWORD pdwPktCount, UINT *pfMark, PBYTE *pHdrInfo,PDWORD pdwHdrSize);
MMRESULT VCMAPI vcmStreamRestorePayload(HVCMSTREAM hvs, WSABUF *ppDataPkt, DWORD dwPktCount, PBYTE pbyFrame, PDWORD pdwFrameSize, BOOL *pfReceivedKeyframe);
MMRESULT VCMAPI vcmStreamGetPayloadHeaderSize(HVCMSTREAM hvs, PDWORD pdwPayloadHeaderSize);

#ifdef __cplusplus
}                       /* End of extern "C" { */
#endif  /* __cplusplus */

#pragma pack()          /* Revert to default packing */

#endif  /* _INC_VCM */

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\h\ulstags.h ===
//--------------------------------------------------------------------------
//
// Module Name:  ULSTAGS.H
//
// Brief Description:  This module contains declarations of property
//					   tags for the User Location Service.
//
// Author:  Kent Settle (kentse)
// Created: 16-May-1996
//
// Copyright (c) 1996 Microsoft Corporation
//
//--------------------------------------------------------------------------


#ifndef ULSTAGS_H
#define ULSTAGS_H

#include <pshpack8.h> /* Assume 8 byte packing throughout */

#ifndef WABTAGS_H
#include "wabtags.h"
#endif

#ifdef __cplusplus
extern "C" {
#endif

/////////////////////////////////////
// WAB related

#define PR_FIRST_NAME           PR_GIVEN_NAME
#define PR_FIRST_NAME_W         PR_GIVEN_NAME_W
#define PR_FIRST_NAME_A         PR_GIVEN_NAME_A

#define PR_LAST_NAME            PR_SURNAME
#define PR_LAST_NAME_W          PR_SURNAME_W
#define PR_LAST_NAME_A          PR_SURNAME_A

#define PR_EMAIL_NAME	        PR_EMAIL_ADDRESS
#define PR_EMAIL_NAME_A         PR_EMAIL_ADDRESS_A
#define PR_EMAIL_NAME_W         PR_EMAIL_ADDRESS_W

#define PR_CITY                 PR_LOCATION
#define PR_CITY_W               PR_LOCATION_W
#define PR_CITY_A               PR_LOCATION_A

// defined in wabtags.h
// #define PR_COUNTRY           PROP_TAG( PT_TSTRING,   0x3A26)
// #define PR_COUNTRY_W         PROP_TAG( PT_UNICODE,   0x3A26)
// #define PR_COUNTRY_A         PROP_TAG( PT_STRING8,   0x3A26)

#define PR_COMMENT_INTEREST     PR_COMMENT
#define PR_COMMENT_INTEREST_W   PR_COMMENT_W
#define PR_COMMENT_INTEREST_A   PR_COMMENT_A

/////////////////////////////////////
// ULS specifics

#define PR_IP_ADDRESS		    PROP_TAG(PT_LONG,		0x3A65)
#define PR_ULS_SERVERS		    PROP_TAG(PT_MV_TSTRING, 0x3A66)
#define PR_WP_SERVERS		    PROP_TAG(PT_MV_TSTRING, 0x3A67)
#define PR_AGE				    PROP_TAG(PT_LONG,		0x3A68)
#define PR_PORT_NUMBER		    PROP_TAG(PT_LONG,		0x3A69)
#define PR_APPLICATION_GUID		PROP_TAG(PT_CLSID,		0x3A6A)
#define PR_APPLICATION_NAME	    PROP_TAG(PT_TSTRING,	0x3A6B)
#define PR_APPLICATION_NAME_A   PROP_TAG(PT_STRING,	    0x3A6B)
#define PR_APPLICATION_NAME_W   PROP_TAG(PT_UNICODE,	0x3A6B)
#define PR_ULS_MODE		        PROP_TAG(PT_LONG,	    0x3A6C)
// #define PR_MIME_TYPE            PROP_TAG(PT_CLSID,	    0x3A6D)
#define PR_MIME_TYPE            PROP_TAG(PT_TSTRING,	0x3A6D)
#define PR_MIME_TYPE_A          PROP_TAG(PT_STRING,	    0x3A6D)
#define PR_MIME_TYPE_W          PROP_TAG(PT_UNICODE,	0x3A6D)
#define PR_PROTOCOL_GUID		PROP_TAG(PT_CLSID,		0x3A6E)


#ifdef __cplusplus
}
#endif

#include <poppack.h> /* End byte packing */

#endif // ULSTAGS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\h\vidinout.h ===
/*****************************************************************************/
/* Let's bring the videoStream functions back from the dead, and rename them */
/* in a way consistent with the waveIn and waveOut APIs.                     */
/* This will allow us to create a VideoPacket class VERY similar to the      */
/* AudioPacket class. And we will be talking directly to the capture driver  */
/* which is much more straightforward than the stuff that is available today.*/
/*****************************************************************************/

#ifndef _INC_VIDEOINOUT
#define _INC_VIDEOINOUT

#pragma pack(1)         /* Assume byte packing throughout */

#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif	/* __cplusplus */

/****************************************************************************
                        videoIn and videoOut Constants
****************************************************************************/
/*****************************************************************************
 * @doc EXTERNAL CONSTANTS
 *
 * @const 10 | MAXVIDEODRIVERS | Maximum number of video input capture drivers.
 *
 * @const WAVE_MAPPER | VIDEO_MAPPER | Arbitrary video driver.
 *
 * @const WAVE_FORMAT_PCM | VIDEO_FORMAT_DEFAULT | Default video format.
 *
 * @const 16 | NUM_4BIT_ENTRIES | Number of entries in a 4bit palette.
 *
 * @const 256 | NUM_8BIT_ENTRIES | Number of entries in an 8bit palette.
 *
 ****************************************************************************/
#define MAXVIDEODRIVERS 10
#define VIDEO_MAPPER WAVE_MAPPER
#define VIDEO_FORMAT_DEFAULT WAVE_FORMAT_PCM
#define NUM_4BIT_ENTRIES 16
#define NUM_8BIT_ENTRIES 256

/****************************************************************************
                        videoIn and videoOut Macros
****************************************************************************/
// WIDTHBYTES takes number of bits in a scan line and rounds up to nearest word.
#define WIDTHBYTES(bits) (((bits) + 31) / 32 * 4)

/****************************************************************************
                       videoIn and videoOut Data Types
****************************************************************************/
DECLARE_HANDLE(HVIDEOIN);                 // generic handle
typedef HVIDEOIN *PHVIDEOIN;
DECLARE_HANDLE(HVIDEOOUT);                 // generic handle
typedef HVIDEOOUT *PHVIDEOOUT;

/****************************************************************************
                         Callback Capture Messages
****************************************************************************/

/*****************************************************************************
 * @doc EXTERNAL CAPMSG
 *
 * @msg VIM_OPEN | This message is sent to a video capture input callback function when
 *   a video capture input device is opened.
 *
 * @parm DWORD | dwParam1 | Currently unused.
 *
 * @parm DWORD | dwParam2 | Currently unused.
 *
 * @rdesc None
 *
 * @xref <m MM_VIM_OPEN>
 ****************************************************************************/

/*****************************************************************************
 * @doc EXTERNAL CAPMSG
 *
 * @msg MM_VIM_OPEN | This message is sent to a window when a video capture input
 *   device is opened.
 *
 * @parm WORD | wParam | Specifies a handle to the video capture input device
 *   that was opened.
 *
 * @parm LONG | lParam | Currently unused.
 *
 * @rdesc None
 *
 * @xref <m VIM_OPEN>
 ****************************************************************************/

/*****************************************************************************
 * @doc EXTERNAL CAPMSG
 *
 * @msg VIM_CLOSE | This message is sent to a video capture input callback function when
 *   a video capture input device is closed. The device handle is no longer
 *   valid once this message has been sent.
 *
 * @parm DWORD | dwParam1 | Currently unused.
 *
 * @parm DWORD | dwParam2 | Currently unused.
 *
 * @rdesc None
 *
 * @xref <m MM_VIM_CLOSE>
 ****************************************************************************/

/*****************************************************************************
 * @doc EXTERNAL CAPMSG
 *
 * @msg MM_VIM_CLOSE | This message is sent to a window when a video capture input
 *   device is closed. The device handle is no longer valid once this message
 *   has been sent.
 *
 * @parm WORD | wParam | Specifies a handle to the video capture input device
 *   that was closed.
 *
 * @parm LONG | lParam | Currently unused.
 *
 * @rdesc None
 *
 * @xref <m VIM_CLOSE>
 ****************************************************************************/

/*****************************************************************************
 * @doc EXTERNAL CAPMSG
 *
 * @msg VIM_DATA | This message is sent to a video capture input callback function when
 *   video data is present in the input buffer and the buffer is being
 *   returned to the application. The message can be sent either when the
 *   buffer is full, or after the <f videoInReset> function is called.
 *
 * @parm DWORD | dwParam1 | Specifies a far pointer to a <t VIDEOINOUTHDR> structure
 *   identifying the buffer containing the video data.
 *
 * @parm DWORD | dwParam2 | Currently unused.
 *
 * @rdesc None
 *
 * @comm The returned buffer may not be full. Use the
 *   <e VIDEOINOUTHDR.dwBytesUsed>
 *   field of the <t VIDEOINOUTHDR> structure specified by <p dwParam1> to
 *   determine the number of valid bytes into the returned buffer.
 *
 * @xref <m MM_VIM_DATA>
 ****************************************************************************/

/*****************************************************************************
 * @doc EXTERNAL CAPMSG
 *
 * @msg MM_VIM_DATA | This message is sent to a window when video data is
 *   present in the input buffer and the buffer is being returned to the
 *   application. The message can be sent either when the buffer is full, or
 *   after the <f videoInReset> function is called.
 *
 * @parm WORD | wParam | Specifies a handle to the video capture input device
 *   that received the video data.
 *
 * @parm LONG | lParam | Specifies a far pointer to a <t VIDEOINOUTHDR> structure
 *   identifying the buffer containing the video data.
 *
 * @rdesc None
 *
 * @comm The returned buffer may not be full. Use the
 *   <e VIDEOINOUTHDR.dwBytesUsed>
 *   field of the <t VIDEOINOUTHDR> structure specified by <p lParam> to
 *   determine the number of valid bytes into the returned buffer.
 *
 * @xref <m VIM_DATA>
 ****************************************************************************/

#define MM_VIM_OPEN		MM_WIM_OPEN
#define MM_VIM_CLOSE	MM_WIM_CLOSE
#define MM_VIM_DATA		MM_WIM_DATA
#define VIM_OPEN		MM_VIM_OPEN
#define VIM_CLOSE		MM_VIM_CLOSE
#define VIM_DATA		MM_VIM_DATA

/****************************************************************************
                         Callback Playback Messages
****************************************************************************/

/*****************************************************************************
 * @doc EXTERNAL PLAYMSG
 *
 * @msg VOM_OPEN | This message is sent to a video output callback function when
 *   a video output device is opened.
 *
 * @parm DWORD | dwParam1 | Currently unused.
 *
 * @parm DWORD | dwParam2 | Currently unused.
 *
 * @rdesc None
 *
 * @xref <m MM_VOM_OPEN>
 ****************************************************************************/

/*****************************************************************************
 * @doc EXTERNAL PLAYMSG
 *
 * @msg MM_VOM_OPEN | This message is sent to a window when a video output
 *   device is opened.
 *
 * @parm WORD | wParam | Specifies a handle to the video output device
 *   that was opened.
 *
 * @parm LONG | lParam | Currently unused.
 *
 * @rdesc None
 *
 * @xref <m VOM_OPEN>
 ****************************************************************************/

/*****************************************************************************
 * @doc EXTERNAL PLAYMSG
 *
 * @msg VOM_CLOSE | This message is sent to a video output callback function when
 *   a video output device is closed. The device handle is no longer
 *   valid once this message has been sent.
 *
 * @parm DWORD | dwParam1 | Currently unused.
 *
 * @parm DWORD | dwParam2 | Currently unused.
 *
 * @rdesc None
 *
 * @xref <m MM_VOM_CLOSE>
 ****************************************************************************/

/*****************************************************************************
 * @doc EXTERNAL PLAYMSG
 *
 * @msg MM_VOM_CLOSE | This message is sent to a window when a video output
 *   device is closed. The device handle is no longer valid once this message
 *   has been sent.
 *
 * @parm WORD | wParam | Specifies a handle to the video output device
 *   that was closed.
 *
 * @parm LONG | lParam | Currently unused.
 *
 * @rdesc None
 *
 * @xref <m VOM_CLOSE>
 ****************************************************************************/

/*****************************************************************************
 * @doc EXTERNAL PLAYMSG
 *
 * @msg VOM_DONE | This message is sent to a video output callback function when
 *   the specified output buffer is being returned to
 *   the application. Buffers are returned to the application when
 *   they have been played back, or as the result of a call to <f videoOutReset>.
 *
 * @parm DWORD | dwParam1 | Specifies a far pointer to a <t VIDEOINOUTHDR> structure
 *   identifying the buffer.
 *
 * @parm DWORD | dwParam2 | Currently unused.
 *
 * @rdesc None
 *
 * @xref <m MM_VOM_DONE>
 ****************************************************************************/

/*****************************************************************************
 * @doc EXTERNAL PLAYMSG
 *
 * @msg MM_VOM_DONE | This message is sent to a window when
 *   the specified output buffer is being returned to
 *   the application. Buffers are returned to the application when
 *   they have been played, or as the result of a call to <f videoOutReset>.
 *
 * @parm WORD | wParam | Specifies a handle to the video output device
 *   that played the buffer.
 *
 * @parm LONG | lParam | Specifies a far pointer to a <t VIDEOINOUTHDR> structure
 *   identifying the buffer.
 *
 * @rdesc None
 *
 * @xref <m VOM_DONE>
 ****************************************************************************/

#define MM_VOM_OPEN		MM_WOM_OPEN
#define MM_VOM_CLOSE	MM_WOM_CLOSE
#define MM_VOM_DONE		MM_WOM_DONE
#define VOM_OPEN		MM_VOM_OPEN
#define VOM_CLOSE		MM_VOM_CLOSE
#define VOM_DONE		MM_VOM_DONE

/****************************************************************************
                       videoIn and videoOut Structures
****************************************************************************/

/*****************************************************************************
 * @doc EXTERNAL CAPSTRUCTENUM
 *
 * @struct VIDEOFORMATEX | The <t VIDEOFORMATEX> structure defines the format used to
 *   capture video data and settings for the capture device.
 *
 * @field DWORD | dwFormatTag | Specifies the video format type (FOURCC code).
 *
 * @field DWORD | nSamplesPerSec | Specifies the sample rate, in frames per second.
 *
 * @field DWORD | nAvgBytesPerSec | Specifies the average data-transfer rate, in bytes per second.
 *
 * @field DWORD | nMinBytesPerSec | Specifies the minimum data-transfer rate, in bytes per second.
 *
 * @field DWORD | nMaxBytesPerSec | Specifies the maximum data-transfer rate, in bytes per second.
 *
 * @field DWORD | nBlockAlign | Specifies the block alignment, in bytes.
 *
 * @field DWORD | wBitsPerSample | Specifies the bits per sample for the wFormatTag format type.
 *
 * @field DWORD | dwRequestMicroSecPerFrame | Specifies the requested frame rate, in microseconds.
 *
 * @field DWORD | dwPercentDropForError | Specifies the maximum allowable percentage of dropped frames during capture.
 *
 * @field DWORD | dwNumVideoRequested | This specifies the maximum number of video buffers to allocate.
 *
 * @field DWORD | dwSupportTSTradeOff | Specifies the usage of temporal/spatial trade off.
 *
 * @field BOOL | bLive | Specifies if the preview is to be allowed.
 *
 * @field HWND | hWndParent | Specifies handle of the parent window.
 *
 * @field DWORD | dwFormatSize | Specifies the size of the actual video format.
 *
 * @field DWORD | bih.biSize | Specifies the number of bytes required by the spatial information.
 *
 * @field LONG | bih.biWidth | Specifies the width of the bitmap, in pixels.
 *
 * @field LONG | bih.biHeight | Specifies the height of the bitmap, in pixels.
 *
 * @field WORD | bih.biPlanes | Specifies the number of planes for the target device.
 *
 * @field WORD | bih.biBitCount | Specifies the number of bits per pixel.
 *
 * @field DWORD | bih.biCompression | Specifies the type of compression.
 *
 * @field DWORD | bih.biSizeImage | Specifies the size, in bytes, of the image.
 *
 * @field LONG | bih.biXPelsPerMeter | Specifies the horizontal resolution, in pixels per meter, of the target device for the bitmap.
 *
 * @field LONG | bih.biYPelsPerMeter | Specifies the vertical resolution, in pixels per meter, of the target device for the bitmap.
 *
 * @field DWORD | bih.biClrUsed | Specifies the number of color indices in the color table that are actually used by the bitmap.
 *
 * @field DWORD | bih.biClrImportant | Specifies the number of color indices that are considered important for displaying the bitmap.
 *
 * @field DWORD | bmiColors[256] | Specifies an array of 256 RGBQUADs.
 *
 * @type PVIDEOFORMATEX | Pointer to a <t VIDEOFORMATEX> structure.
 *
 ****************************************************************************/

#define BMIH_SLOP 256+32
#define BMIH_SLOP_BYTES (256+32)*4

typedef struct videoformatex_tag {
	// Wave format compatibility fields
	DWORD		dwFormatTag;
	DWORD		nSamplesPerSec;
	DWORD		nAvgBytesPerSec;
	DWORD		nMinBytesPerSec;
	DWORD		nMaxBytesPerSec;
	DWORD		nBlockAlign;
	DWORD		wBitsPerSample;
	// Temporal fields
    DWORD		dwRequestMicroSecPerFrame;
    DWORD		dwPercentDropForError;
    DWORD		dwNumVideoRequested;
    DWORD		dwSupportTSTradeOff;
    BOOL		bLive;
	// Spatial fields
    DWORD       dwFormatSize;
    BITMAPINFOHEADER bih;
    DWORD 	bihSLOP[BMIH_SLOP];	// bmiColors = &bih + bih.biSize
//    RGBQUAD     bmiColors[256];
} VIDEOFORMATEX, *PVIDEOFORMATEX;

/*****************************************************************************
 * @doc EXTERNAL CAPSTRUCTENUM
 *
 * @struct VIDEOINCAPS | The <t VIDEOINCAPS> structure describes the
 *   capabilities of a video capture input device.
 *
 * @field TCHAR | szDeviceName[80] | Specifies the device name.
 *
 * @field TCHAR | szDeviceVersion[80] | Specifies the device version.
 *
 * @field DWORD | dwImageSize | Specifies which standard image sizes are supported.
 *   The supported sizes are specified with a logical OR of the following
 *   flags:
 *   @flag VIDEO_FORMAT_IMAGE_SIZE_40_30	| 40x30 pixels
 *   @flag VIDEO_FORMAT_IMAGE_SIZE_80_60	| 80x30 pixels
 *   @flag VIDEO_FORMAT_IMAGE_SIZE_120_90	| 120x90 pixels
 *   @flag VIDEO_FORMAT_IMAGE_SIZE_160_120	| 160x120 pixels
 *   @flag VIDEO_FORMAT_IMAGE_SIZE_200_150	| 200x150 pixels
 *   @flag VIDEO_FORMAT_IMAGE_SIZE_240_180	| 240x180 pixels
 *   @flag VIDEO_FORMAT_IMAGE_SIZE_280_210	| 280x210 pixels
 *   @flag VIDEO_FORMAT_IMAGE_SIZE_320_240	| 320x240 pixels
 *
 * @field DWORD | dwNumColors | Specifies what number of colors are supported.
 *   The supported number of colors are specified with a logical OR of the following
 *   flags:
 *   @flag VIDEO_FORMAT_NUM_COLORS_16 | 16 colors
 *   @flag VIDEO_FORMAT_NUM_COLORS_256 | 256 colors
 *   @flag VIDEO_FORMAT_NUM_COLORS_65536 | 65536 colors
 *   @flag VIDEO_FORMAT_NUM_COLORS_16777216 | 16777216 colors
 *
 * @field DWORD | dwStreamingMode | Specifies the preferred streaming mode.
 *   The supported mode is either one of the following
 *   flags:
 *   @flag STREAMING_PREFER_STREAMING | Real streaming
 *   @flag STREAMING_PREFER_FRAME_GRAB | Single frame grabbing
 *
 * @field DWORD | dwDialogs | Specifies the dialogs that we shoud enable\disable.
 *   The supported dialogs are specified with a logical OR of the following
 *   flags:
 *   @flag FORMAT_DLG_ON | Enable video format dialog
 *   @flag FORMAT_DLG_OFF | Disable video format dialog
 *   @flag SOURCE_DLG_ON | Enable source dialog
 *   @flag SOURCE_DLG_OFF | Disable source dialog
 *
 * @field RGBQUAD | bmi4bitColors[16] | Specifies a 16 color palette.
 *
 * @field RGBQUAD | bmi8bitColors[256] | Specifies a 256 color palette.
 *
 * @type PVIDEOINCAPS | Pointer to a <t VIDEOINCAPS> structure.
 *
 * @devnote We could allocate the memory space required by the palettes dynamically.
 *   But since the VIDEOINCAPS structure are only created on the stack of a couple of
 *   VCM functions, why bother.
 *
 * @xref <f videoInGetDevCaps>
 ****************************************************************************/
typedef struct videoincaps_tag {
    TCHAR		szDeviceName[80];
    TCHAR		szDeviceVersion[80];
    DWORD		dwImageSize;
    DWORD		dwNumColors;
    DWORD		dwStreamingMode;
    DWORD		dwDialogs;
    DWORD       dwFlags;
	RGBQUAD		bmi4bitColors[NUM_4BIT_ENTRIES];
	RGBQUAD		bmi8bitColors[NUM_8BIT_ENTRIES];
} VIDEOINCAPS, *PVIDEOINCAPS;

#define VICF_4BIT_TABLE     1   // set in dwFlags, if bmi4bitColors is valid
#define VICF_8BIT_TABLE     2   // set in dwFlags, if bmi8bitColors is valid

/*****************************************************************************
 * @doc EXTERNAL PLAYSTRUCTENUM
 *
 * @struct VIDEOOUTCAPS | The <t VIDEOOUTCAPS> structure describes the
 *   capabilities of a video output device.
 *
 * @field DWORD | dwFormats | Specifies which standard formats are supported.
 *   The supported formats are specified with a logical OR of the following
 *   flags:
 *   @flag VIDEO_FORMAT_04 | 4-bit palettized
 *   @flag VIDEO_FORMAT_08 | 8-bit palettized
 *   @flag VIDEO_FORMAT_16 | 16-bit
 *   @flag VIDEO_FORMAT_24 | 24-bit
 *   @flag VIDEO_FORMAT_SP | Driver supplies palettes
 *
 * @type PVIDEOOUTCAPS | Pointer to a <t VIDEOOUTCAPS> structure.
 *
 * @xref <f videoOutGetDevCaps>
 ****************************************************************************/
typedef struct videooutcaps_tag {
    DWORD		dwFormats;
} VIDEOOUTCAPS, *PVIDEOOUTCAPS;

// dwFlags field of VIDEOINOUTHDR
/*****************************************************************************
 * @doc EXTERNAL CONSTANTS
 *
 * @const 0x00000001 | VHDR_DONE | Data is done.
 *
 * @const 0x00000002 | VHDR_PREPARED | Data is prepared.
 *
 * @const 0x00000004 | VHDR_INQUEUE | Data is in queue.
 *
 ****************************************************************************/
#define VHDR_DONE       0x00000001  /* Done bit */
#define VHDR_PREPARED   0x00000002  /* Set if this header has been prepared */
#define VHDR_INQUEUE    0x00000004  /* Reserved for driver */
#define VHDR_KEYFRAME   0x00000008  /* Key Frame */
#define VHDR_VALID      0x0000000F  /* valid flags */     /* ;Internal */

// dwImageSize of VIDEOINCAPS
/*****************************************************************************
 * @doc EXTERNAL CONSTANTS
 *
 * @const 27 | VIDEO_FORMAT_NUM_IMAGE_SIZE | Number of video input sizes used by the device.
 *
 * @const 0x00000001 | VIDEO_FORMAT_IMAGE_SIZE_40_30 | Video input device uses 40x30 pixel frames.
 *
 * @const 0x00000002 | VIDEO_FORMAT_IMAGE_SIZE_64_48 | Video input device uses 64x48 pixel frames.
 *
 * @const 0x00000004 | VIDEO_FORMAT_IMAGE_SIZE_80_60 | Video input device uses 80x60 pixel frames.
 *
 * @const 0x00000008 | VIDEO_FORMAT_IMAGE_SIZE_96_64 | Video input device uses 96x64 pixel frames.
 *
 * @const 0x00000010 | VIDEO_FORMAT_IMAGE_SIZE_112_80 | Video input device uses 112x80 pixel frames.
 *
 * @const 0x00000020 | VIDEO_FORMAT_IMAGE_SIZE_120_90 | Video input device uses 120x90 pixel frames.
 *
 * @const 0x00000040 | VIDEO_FORMAT_IMAGE_SIZE_128_96 | Video input device uses 128x96 (SQCIF) pixel frames.
 *
 * @const 0x00000080 | VIDEO_FORMAT_IMAGE_SIZE_144_112 | Video input device uses 144x112 pixel frames.
 *
 * @const 0x00000100 | VIDEO_FORMAT_IMAGE_SIZE_160_120 | Video input device uses 160x120 pixel frames.
 *
 * @const 0x00000200 | VIDEO_FORMAT_IMAGE_SIZE_160_128 | Video input device uses 160x128 pixel frames.
 *
 * @const 0x00000400 | VIDEO_FORMAT_IMAGE_SIZE_176_144 | Video input device uses 176x144 (QCIF) pixel frames.
 *
 * @const 0x00000800 | VIDEO_FORMAT_IMAGE_SIZE_192_160 | Video input device uses 192x160 pixel frames.
 *
 * @const 0x00001000 | VIDEO_FORMAT_IMAGE_SIZE_200_150 | Video input device uses 200x150 pixel frames.
 *
 * @const 0x00002000 | VIDEO_FORMAT_IMAGE_SIZE_208_176 | Video input device uses 208x176 pixel frames.
 *
 * @const 0x00004000 | VIDEO_FORMAT_IMAGE_SIZE_224_192 | Video input device uses 224x192 pixel frames.
 *
 * @const 0x00008000 | VIDEO_FORMAT_IMAGE_SIZE_240_180 | Video input device uses 240x180 pixel frames.
 *
 * @const 0x00010000 | VIDEO_FORMAT_IMAGE_SIZE_240_208 | Video input device uses 240x208 pixel frames.
 *
 * @const 0x00020000 | VIDEO_FORMAT_IMAGE_SIZE_256_224 | Video input device uses 256x224 pixel frames.
 *
 * @const 0x00040000 | VIDEO_FORMAT_IMAGE_SIZE_272_240 | Video input device uses 272x240 pixel frames.
 *
 * @const 0x00080000 | VIDEO_FORMAT_IMAGE_SIZE_280_210 | Video input device uses 280x210 pixel frames.
 *
 * @const 0x00100000 | VIDEO_FORMAT_IMAGE_SIZE_288_256 | Video input device uses 288x256 pixel frames.
 *
 * @const 0x00200000 | VIDEO_FORMAT_IMAGE_SIZE_304_272 | Video input device uses 304x272 pixel frames.
 *
 * @const 0x00400000 | VIDEO_FORMAT_IMAGE_SIZE_320_240 | Video input device uses 320x240 pixel frames.
 *
 * @const 0x00800000 | VIDEO_FORMAT_IMAGE_SIZE_320_288 | Video input device uses 320x288 pixel frames.
 *
 * @const 0x01000000 | VIDEO_FORMAT_IMAGE_SIZE_336_288 | Video input device uses 336x288 pixel frames.
 *
 * @const 0x02000000 | VIDEO_FORMAT_IMAGE_SIZE_352_288 | Video input device uses 352x288 (CIF) pixel frames.
 *
 * @const 0x04000000 | VIDEO_FORMAT_IMAGE_SIZE_640_480 | Video input device uses 640x480 pixel frames.
 *
 ****************************************************************************/
#define VIDEO_FORMAT_NUM_IMAGE_SIZE	27

#define VIDEO_FORMAT_IMAGE_SIZE_40_30	0x00000001
#define VIDEO_FORMAT_IMAGE_SIZE_64_48	0x00000002
#define VIDEO_FORMAT_IMAGE_SIZE_80_60	0x00000004
#if !defined(_ALPHA_) && defined(USE_BILINEAR_MSH26X)
#define VIDEO_FORMAT_IMAGE_SIZE_80_64	0x00000008
#else
#define VIDEO_FORMAT_IMAGE_SIZE_96_64	0x00000008
#endif
#define VIDEO_FORMAT_IMAGE_SIZE_112_80	0x00000010
#define VIDEO_FORMAT_IMAGE_SIZE_120_90	0x00000020
#define VIDEO_FORMAT_IMAGE_SIZE_128_96	0x00000040
#define VIDEO_FORMAT_IMAGE_SIZE_144_112	0x00000080
#define VIDEO_FORMAT_IMAGE_SIZE_160_120	0x00000100
#define VIDEO_FORMAT_IMAGE_SIZE_160_128	0x00000200
#define VIDEO_FORMAT_IMAGE_SIZE_176_144	0x00000400
#define VIDEO_FORMAT_IMAGE_SIZE_192_160	0x00000800
#define VIDEO_FORMAT_IMAGE_SIZE_200_150	0x00001000
#define VIDEO_FORMAT_IMAGE_SIZE_208_176	0x00002000
#define VIDEO_FORMAT_IMAGE_SIZE_224_192	0x00004000
#define VIDEO_FORMAT_IMAGE_SIZE_240_180	0x00008000
#define VIDEO_FORMAT_IMAGE_SIZE_240_208	0x00010000
#define VIDEO_FORMAT_IMAGE_SIZE_256_224	0x00020000
#define VIDEO_FORMAT_IMAGE_SIZE_272_240	0x00040000
#define VIDEO_FORMAT_IMAGE_SIZE_280_210	0x00080000
#define VIDEO_FORMAT_IMAGE_SIZE_288_256	0x00100000
#define VIDEO_FORMAT_IMAGE_SIZE_304_272	0x00200000
#define VIDEO_FORMAT_IMAGE_SIZE_320_240	0x00400000
#define VIDEO_FORMAT_IMAGE_SIZE_320_288	0x00800000
#define VIDEO_FORMAT_IMAGE_SIZE_336_288	0x01000000
#define VIDEO_FORMAT_IMAGE_SIZE_352_288	0x02000000
#define VIDEO_FORMAT_IMAGE_SIZE_640_480	0x04000000

#define VIDEO_FORMAT_IMAGE_SIZE_USE_DEFAULT 0x80000000

// dwNumColors of VIDEOINCAPS
/*****************************************************************************
 * @doc EXTERNAL CONSTANTS
 *
 * @const 0x00000001 | VIDEO_FORMAT_NUM_COLORS_16 | Video input device uses 16 colors.
 *
 * @const 0x00000002 | VIDEO_FORMAT_NUM_COLORS_256 | Video input device uses 256 colors.
 *
 * @const 0x00000004 | VIDEO_FORMAT_NUM_COLORS_65536 | Video input device uses 65536 colors.
 *
 * @const 0x00000008 | VIDEO_FORMAT_NUM_COLORS_16777216 | Video input device uses 16777216 colors.
 *
 * @const 0x00000010 | VIDEO_FORMAT_NUM_COLORS_YVU9 | Video input device uses the YVU9 compressed format.
 *
 * @const 0x00000020 | VIDEO_FORMAT_NUM_COLORS_I420 | Video input device uses the I420 compressed format.
 *
 * @const 0x00000040 | VIDEO_FORMAT_NUM_COLORS_IYUV | Video input device uses the IYUV compressed format.
 *
 ****************************************************************************/
#define VIDEO_FORMAT_NUM_COLORS_16			0x00000001
#define VIDEO_FORMAT_NUM_COLORS_256			0x00000002
#define VIDEO_FORMAT_NUM_COLORS_65536		0x00000004
#define VIDEO_FORMAT_NUM_COLORS_16777216	0x00000008
#define VIDEO_FORMAT_NUM_COLORS_YVU9		0x00000010
#define VIDEO_FORMAT_NUM_COLORS_I420		0x00000020
#define VIDEO_FORMAT_NUM_COLORS_IYUV		0x00000040
#define VIDEO_FORMAT_NUM_COLORS_YUY2		0x00000080
#define VIDEO_FORMAT_NUM_COLORS_UYVY		0x00000100

// dwDialogs of VIDEOINCAPS
/*****************************************************************************
 * @doc EXTERNAL CONSTANTS
 *
 * @const 0x00000000 | FORMAT_DLG_OFF | Disable video format dialog.
 *
 * @const 0x00000000 | SOURCE_DLG_OFF | Disable source dialog.
 *
 * @const 0x00000001 | FORMAT_DLG_ON | Enable video format dialog.
 *
 * @const 0x00000002 | SOURCE_DLG_ON | Enable source dialog.
 *
 ****************************************************************************/
#define FORMAT_DLG_OFF	0x00000000
#define SOURCE_DLG_OFF	0x00000000
#define FORMAT_DLG_ON	0x00000001
#define SOURCE_DLG_ON	0x00000002

// dwFormats of VIDEOOUTCAPS
/*****************************************************************************
 * @doc EXTERNAL CONSTANTS
 *
 * @const 0x00000001 | VIDEO_FORMAT_04 | Video output device supports 4bit DIBs
 *
 * @const 0x00000002 | VIDEO_FORMAT_08 | Video output device supports 8bit DIBs
 *
 * @const 0x00000004 | VIDEO_FORMAT_16 | Video output device supports 16bit DIBs
 *
 * @const 0x00000008 | VIDEO_FORMAT_24 | Video output device supports 24bit DIBs
 *
 * @const 0x00000008 | VIDEO_FORMAT_32 | Video output device supports 32bit DIBs
 *
 ****************************************************************************/
#define VIDEO_FORMAT_04	0x00000001
#define VIDEO_FORMAT_08	0x00000002
#define VIDEO_FORMAT_16	0x00000004
#define VIDEO_FORMAT_24	0x00000008
#define VIDEO_FORMAT_32	0x00000010

/****************************************************************************
                            Error Return Values
****************************************************************************/

/*****************************************************************************
 * @doc EXTERNAL CONSTANTS
 *
 * @const WAVERR_BASE | VIDEOERR_BASE | Base for video errors.
 *
 * @const (VIDEOERR_BASE + 0) | VIDEOERR_BADFORMAT | Unsupported video format.
 *
 * @const (VIDEOERR_BASE + 1) | VIDEOERR_INQUEUE | Header is already or still queued.
 *
 * @const (VIDEOERR_BASE + 2) | VIDEOERR_UNPREPARED | Header is not prepared.
 *
 * @const (VIDEOERR_BASE + 3) | VIDEOERR_NONSPECIFIC | Non specific error.
 *
 * @const (VIDEOERR_BASE + 3) | VIDEOERR_LASTERROR | Last video error in range.
 *
 ****************************************************************************/
#define VIDEOERR_BASE			WAVERR_BASE				/* base for video errors */
#define VIDEOERR_BADFORMAT		(VIDEOERR_BASE + 0)		/* unsupported video format */
#define VIDEOERR_INQUEUE		(VIDEOERR_BASE + 1)		/* header is already queued */
#define VIDEOERR_UNPREPARED		(VIDEOERR_BASE + 2)		/* header not prepared */
#define VIDEOERR_NONSPECIFIC	(VIDEOERR_BASE + 3)		/* non specific */
#define VIDEOERR_LASTERROR		(VIDEOERR_BASE + 3)		/* last error in range */

#ifdef __cplusplus
}                       /* End of extern "C" { */
#endif	/* __cplusplus */

#pragma pack()          /* Revert to default packing */

#endif  /* _INC_VIDEOINOUT */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\h\wbguid.h ===
//****************************************************************************
//
//  File:       wbguid.h
//  Content:    This file contains the class GUID for Microsoft T126 WB.
//
//  Copyright (c) Microsoft Corporation 1995-1996
//
//****************************************************************************

// {340f4a60-7067-11d0-a041-444553540000}
//
const GUID CLSID_NM2Wb = { 0x340f4a60, 0x7067, 0x11d0, { 0xa0, 0x41, 0x44, 0x45, 0x53, 0x54, 0x0, 0x0 } };
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\h\t120\iappldr.h ===
#ifndef _I_APPLOADER_H
#define _I_APPLOADER_H

#include <basetyps.h>
#include "gcc.h"


typedef enum
{
	APPLET_ID_WB = 0,
    APPLET_ID_FT = 1,
    APPLET_ID_CHAT = 2,
    APPLET_LAST = 3,
}
    APPLET_ID;


typedef enum
{
    APPLDR_NO_ERROR = 0,
    APPLDR_FAIL,
    APPLDR_CANCEL_EXIT,
}
    APPLDR_RESULT;


typedef enum
{
    APPLET_QUERY_SHUTDOWN = 0,
    APPLET_QUERY_NM2xNODE,
}
    APPLET_QUERY_ID;


#undef INTERFACE
#define INTERFACE IAppletLoader
DECLARE_INTERFACE(IAppletLoader)
{
	STDMETHOD_(void,           ReleaseInterface)(THIS) PURE;
	STDMETHOD_(APPLDR_RESULT,  AppletStartup)(THIS_
	                                IN  BOOL    fNoUI) PURE;
	STDMETHOD_(APPLDR_RESULT,  AppletCleanup)(THIS_
									IN	DWORD	dwTimeout) PURE;
	STDMETHOD_(APPLDR_RESULT,  AppletInvoke)(THIS_
									IN	BOOL fLocal,
									IN	GCCConfID,
	                                IN  LPSTR   pszCmdLine) PURE;
    STDMETHOD_(APPLDR_RESULT,  AppletQuery)(THIS_
                                    IN  APPLET_QUERY_ID eQueryId) PURE; 
    STDMETHOD_(APPLDR_RESULT,  OnNM2xNodeJoin)(THIS) PURE;
};



typedef enum
{
    APPLET_LIBRARY_FREED = 0,
    APPLET_LIBRARY_LOADED,
    APPLET_WORK_THREAD_STARTED,
    APPLET_CLOSING,
    APPLET_WORK_THREAD_EXITED,
}
    APPLET_STATUS;



#define CREATE_APPLET_LOADER_INTERFACE  "CreateAppletLoaderInterface"
typedef T120Error (WINAPI *LPFN_CREATE_APPLET_LOADER_INTERFACE) (IAppletLoader **);



#ifdef __cplusplus
extern "C" {
#endif

// caller: NM/UI, T.120
T120Error WINAPI T120_LoadApplet(APPLET_ID, BOOL fLocal, T120ConfID, BOOL fNoUI, LPSTR pszCmdLine);

// caller: NM/UI shutdown
T120Error WINAPI T120_CloseApplet(APPLET_ID, BOOL fNowRegardlessRefCount, BOOL fSync, DWORD dwTimeout);

// caller: applet itself
T120Error WINAPI T120_AppletStatus(APPLET_ID, APPLET_STATUS);

// caller: NM/UI
T120Error WINAPI T120_QueryApplet(APPLET_ID, APPLET_QUERY_ID);

// node ID --> user name
//
// Return value is zero (in case of failure)
// or the length of node name (in case of valid <conf ID, node ID>).
//
// The caller should check if the buffer size given is large enough to
// hold the entire node name. If not, the caller should provide a new buffer
// and call this function again in order to get the entire node name.
//
ULONG WINAPI T120_GetNodeName(T120ConfID, T120NodeID, LPSTR pszName, ULONG cchName);

// node ID + GUID --> user data
//
// Return value is zero (in case of failure)
// or the size of user data (in case of valid <conf ID, node ID, GUID>).
//
// The caller should check if the buffer size given is large enough to
// hold the entire user data. If not, the caller should provide a new buffer
// and call this function again in order to get the entire user data.
//
ULONG WINAPI T120_GetUserData(T120ConfID, T120NodeID, GUID *, LPBYTE pbBuffer, ULONG cbBufSize);

// node ID --> node version
//
// Node version (like NM 3.0) is maintained iinside CConf's NodeVersion list
// Given confId and node id, returns node's version number
//
DWORD_PTR WINAPI T120_GetNodeVersion(T120ConfID, T120NodeID);

#ifdef __cplusplus
}
#endif


#endif // _I_APPLOADER_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\h\t120\imcsapp.h ===
#ifndef _IMCSAPP_H_
#define _IMCSAPP_H_

#include <basetyps.h>
#include "mcatmcs.h"


#define MCSAPI_(_type_) virtual _type_   __stdcall
#define MCSAPI          MCSAPI_(MCSError)

#define	ATTACHMENT_DISCONNECT_IN_DATA_LOSS		0x1
#define ATTACHMENT_MCS_FREES_DATA_IND_BUFFER	0x2


#undef  INTERFACE
#define INTERFACE IMCSSap
DECLARE_INTERFACE(IMCSSap)
{
    STDMETHOD_(MCSError, ReleaseInterface) (THIS) PURE;

    /* memory calls */

    STDMETHOD_(MCSError, GetBuffer) (THIS_
                IN      UINT,
                OUT     PVoid *)
                PURE;

    STDMETHOD_(Void, FreeBuffer) (THIS_
                IN      PVoid)
                PURE;

    // channel request calls
    STDMETHOD_(MCSError, ChannelJoin) (THIS_
                IN      ChannelID)
                PURE;

    STDMETHOD_(MCSError, ChannelLeave) (THIS_
                IN      ChannelID)
                PURE;

    STDMETHOD_(MCSError, ChannelConvene) (THIS)
                PURE;

    STDMETHOD_(MCSError, ChannelDisband) (THIS_
                IN      ChannelID)
                PURE;

    STDMETHOD_(MCSError, ChannelAdmit) (THIS_
                IN      ChannelID,
                IN		PUserID,
				IN		UINT)
                PURE;

    /* send data services */

    STDMETHOD_(MCSError, SendData) (THIS_
                IN      DataRequestType,
                IN      ChannelID,
                IN      Priority,
                IN		unsigned char *,
                IN		ULong,
                IN		SendDataFlags)
                PURE;

	/*	token services */
    STDMETHOD_(MCSError, TokenGrab) (THIS_
                IN      TokenID)
                PURE;

    STDMETHOD_(MCSError, TokenInhibit) (THIS_
                IN      TokenID)
                PURE;

    STDMETHOD_(MCSError, TokenGive) (THIS_
                IN      TokenID,
                IN		UserID)
                PURE;

    STDMETHOD_(MCSError, TokenGiveResponse) (THIS_
                IN      TokenID,
                IN		Result)
                PURE;

    STDMETHOD_(MCSError, TokenPlease) (THIS_
                IN      TokenID)
                PURE;
                
    STDMETHOD_(MCSError, TokenRelease) (THIS_
                IN      TokenID)
                PURE;

    STDMETHOD_(MCSError, TokenTest) (THIS_
                IN      TokenID)
                PURE;
};

typedef IMCSSap * 		PIMCSSap;


//
// GCC Application Service Access Point exports
//

#ifdef __cplusplus
extern "C" {
#endif

MCSError WINAPI MCS_AttachRequest(
                        OUT     IMCSSap **,
                        IN		DomainSelector,
                        IN		UINT,
                        IN      MCSCallBack,
                        IN		PVoid,
                        IN		UINT);
#ifdef __cplusplus
}
#endif


#endif // _IMCSAPP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\h\t120\databeam.h ===
/*
 * databeam.h
 *
 *	Copyright (c) 1993 - 1996 by DataBeam Corporation, Lexington, KY
 *
 * Abstract:
 *      This file defines common extensions to the C++ language for
 *		use at DataBeam Corporation.
 *
 * Author:
 *		James P. Galvin, Jr.
 *		Brian L. Pulito
 *		Carolyn J. Holmes
 *		John B. O'Nan
 *
 *	Revision History
 *		08AUG94		blp		Added UniChar
 *		15JUL94		blp		Added lstrcmp
 */

#ifndef _DATABEAM_
#define _DATABEAM_

#	include <windows.h>

/*
 * The following two macros can be used to get the minimum or the maximum
 * of two numbers.
 */
#ifndef min
#	define	min(a,b)	(((a) < (b)) ? (a) : (b))
#endif

#ifndef max
#	define	max(a,b)	(((a) > (b)) ? (a) : (b))
#endif


/*
 *	This typedef defines Boolean as an BOOL, rather than an enum.  The
 *	thinking is that this is more likely to be compatible with other
 *	uses of Boolean (if any), as well as with the use of "#define" to
 *	define TRUE and FALSE.
 */
#ifndef	DBBoolean
typedef	BOOL						DBBoolean;
typedef	BOOL *						PDBBoolean;
#endif

/*
 *	These defines set up values that would typically be used in conjunction
 *	with the type Boolean as defined above.
 */
#ifndef	OFF
#	define	OFF		0
#endif
#ifndef	ON
#	define	ON		1
#endif


/*
 * EOS can be used for the NUL byte at the end of a string.  Do not 
 * confuse this with the pointer constant "NULL".
 */
#define EOS     '\0'


/*
 *	The following is a list of the standard typedefs that will be used
 *	in all programs written at DataBeam.  Use of this list gives us full
 *	control over types for portability.  It also gives us a standard
 *	naming convention for all types.
 */
typedef	char						Char;
typedef	unsigned char				UChar;
typedef	char *						PChar;
typedef	const char *				PCChar;
typedef	unsigned char *				PUChar;
typedef	const unsigned char *		PCUChar;
typedef	char *						FPChar;
typedef	const char *				FPCChar;
typedef	unsigned char *				FPUChar;
typedef	const unsigned char *		FPCUChar;
typedef	char  *						HPChar;
typedef	const char *				HPCChar;
typedef	unsigned char *				HPUChar;
typedef	const unsigned char *		HPCUChar;

typedef	short						Short;
typedef	unsigned short				UShort;
typedef	short *						PShort;
typedef	const short *				PCShort;
typedef	unsigned short *			PUShort;
typedef	const unsigned short *		PCUShort;
typedef	short *						FPShort;
typedef	const short *				FPCShort;
typedef	unsigned short *			FPUShort;
typedef	const unsigned short *		FPCUShort;
typedef	short *						HPShort;
typedef	const short *				HPCShort;
typedef	unsigned short *			HPUShort;
typedef	const unsigned short *		HPCUShort;

typedef	int							Int;
typedef	unsigned int				UInt;
typedef	int *						PInt;
typedef	const int *					PCInt;
typedef	unsigned int *				PUInt;
typedef	const unsigned int *		PCUInt;
typedef	int *						FPInt;
typedef	const int *					FPCInt;
typedef	unsigned int *				FPUInt;
typedef	const unsigned int *		FPCUInt;
typedef	int *						HPInt;
typedef	const int *					HPCInt;
typedef	unsigned int *				HPUInt;
typedef	const unsigned int *		HPCUInt;

typedef	long						Long;
typedef	unsigned long				ULong;
typedef	long *						PLong;
typedef	const long *				PCLong;
typedef	unsigned long *				PULong;
typedef	const unsigned long *		PCULong;
typedef	long *						FPLong;
typedef	const long *				FPCLong;
typedef	unsigned long *				FPULong;
typedef	const unsigned long *		FPCULong;
typedef	long *						HPLong;
typedef	const long *				HPCLong;
typedef	unsigned long *				HPULong;
typedef	const unsigned long *		HPCULong;

#ifdef USE_FLOATING_POINT
typedef	float						Float;
typedef	float *						PFloat;
typedef	const float *				PCFloat;
typedef	float *						FPFloat;
typedef	const float *				FPCFloat;
typedef	float *						HPFloat;
typedef	const float *				HPCFloat;

typedef	double						Double;
typedef	double *					PDouble;
typedef	const double *				PCDouble;
typedef	double *					FPDouble;
typedef	const double *				FPCDouble;
typedef	double *					HPDouble;
typedef	const double *				HPCDouble;

typedef	long double					LDouble;
typedef	long double *				PLDouble;
typedef	const long double *			PCLDouble;
typedef	long double *				FPLDouble;
typedef	const long double *			FPCLDouble;
typedef	long double *				HPLDouble;
typedef	const long double *			HPCLDouble;
#endif

typedef	void						Void;
typedef	void *						PVoid;
typedef	const void *				PCVoid;
typedef	void *						FPVoid;
typedef	const void *				FPCVoid;
typedef	void *						HPVoid;
typedef	const void *				HPCVoid;

/*
 *	Temporary fix for compatibility with the Symantec compiler, which doesn't
 *	recognize wchar_t as a valid type.
 */
typedef	unsigned short				UniChar;
typedef	UniChar		*				PUniChar;
typedef	UniChar		*				FPUniChar;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\h\t120\gcc.h ===
/*
 *	gcc.h
 *
 *	Copyright (c) 1994, 1995 by DataBeam Corporation, Lexington, KY
 *
 *	Abstract:
 *		This is the interface file for the GCC DLL.  This file defines all
 *		macros, types, and functions needed to use the GCC DLL, allowing GCC
 *		services to be accessed from user applications. 
 *
 *		An application requests services from GCC by making direct
 *		calls into the DLL (this includes T.124 requests and responses).  GCC
 *		sends information back to the application through a callback (this
 *		includes T.124 indications and confirms).  The callback for the node
 *		controller is specified in the call GCCInitialize, and the callback
 *		for a particular application service access point is specified in the 
 *		call GCCRegisterSAP.
 *
 *		During initialization, GCC allocates a timer in order to give itself
 *		a heartbeat. If zero is passed in here the owner application (the node 
 *		controller) must take the responsibility to call GCCHeartbeat.  Almost 
 *		all work is done by GCC during these clocks ticks. It is during these 
 *		clock ticks that GCC checks with MCS to see if there is any work to be 
 *		done.  It is also during these clock ticks that callbacks are made to 
 *		the user applications.  GCC will NEVER invoke a user callback during a 
 *		user request (allowing the user applications to not worry about 
 *		re-entrancy).  Since timer events are processed during the message 
 *		loop, the developer should be aware that long periods of time away 
 *		from the message loop will result in GCC "freezing" up.
 *
 *		Note that this is a "C" language interface in order to prevent any "C++"
 *		naming conflicts between different compiler manufacturers.  Therefore,
 *		if this file is included in a module that is being compiled with a "C++"
 *		compiler, it is necessary to use the following syntax:
 *
 *		extern "C"
 *		{
 *			#include "gcc.h"
 *		}
 *
 *		This disables C++ name mangling on the API entry points defined within
 *		this file.
 *
 *	Author:
 *		blp
 *
 *	Caveats:
 *		none
 */
#ifndef	__GCC_H__
#define	__GCC_H__

#include "t120type.h"

/************************************************************************
*																		*
*					Generally Used Typedefs								*
*																		*
*************************************************************************/

#define NM_T120_VERSION_3		(MAKELONG(0, 3))	// NM 3.0

typedef struct tagOSTR
{
    ULONG       length;
    LPBYTE      value;
}
    OSTR, *LPOSTR;

/*
**	Typedef for a GCC hex string.  This typedef is used throughout GCC for
**	storing	variable length wide character strings with embedded NULLs.
*/
typedef struct
{
	UINT                hex_string_length;
	USHORT           *  hex_string;
}
    T120HexString, GCCHexString, *PGCCHexString;

/*
**	Typedef for a GCC long string.  This typedef is used in GCC for
**	storing	variable length strings of longs with embedded NULLs.
*/
typedef struct tagT120LongString
{
	ULONG               long_string_length;
	ULONG         *     long_string;
}
    T120LongString, GCCLongString, *PGCCLongString;


/*
 *	TransportAddress is passed in with the ConnectRequest() call.
 *	This address is always a pointer to an ascii string.
 *	The TransportAddress represents a remote location.  It is the TCP
 *	address of the remote machine.
 *
 */
typedef	LPSTR       TransportAddress, *PTransportAddress;


/*
**	Typedef for a GCC Character string.  This typedef is used throughout GCC for
**	storing	variable length, NULL terminated, single byte character strings.
*/
// lonchanc: we should simply use char.
typedef BYTE        GCCCharacter, *GCCCharacterString, **PGCCCharacterString;

/*
**	Typedef for a GCC Numeric string.  This typedef is used throughout GCC for
**	storing	variable length, NULL terminated, single byte character strings.
**	A single character in this string is constrained to numeric values 
**	ranging from "0" to "9".
*/
typedef LPSTR       GCCNumericString, *PGCCNumericString;

/*
**	Typdef for GCC version which is used when registering the node controller
**	or an application.
*/
typedef	struct
{
	USHORT	major_version;
	USHORT	minor_version;
}
    GCCVersion, *PGCCVersion;



/* 
** Macros for values of Booleans passed through the GCC API.
*/
#define		CONFERENCE_IS_LOCKED					TRUE
#define		CONFERENCE_IS_NOT_LOCKED				FALSE
#define		CONFERENCE_IS_LISTED					TRUE
#define		CONFERENCE_IS_NOT_LISTED				FALSE
#define		CONFERENCE_IS_CONDUCTIBLE				TRUE
#define		CONFERENCE_IS_NOT_CONDUCTIBLE			FALSE
#define		PERMISSION_IS_GRANTED					TRUE
#define		PERMISSION_IS_NOT_GRANTED				FALSE
#define		TIME_IS_CONFERENCE_WIDE					TRUE
#define		TIME_IS_NOT_CONFERENCE_WIDE				FALSE
#define		APPLICATION_IS_ENROLLED_ACTIVELY		TRUE
#define		APPLICATION_IS_NOT_ENROLLED_ACTIVELY	FALSE
#define		APPLICATION_IS_CONDUCTING				TRUE
#define		APPLICATION_IS_NOT_CONDUCTING_CAPABLE	FALSE
#define		APPLICATION_IS_ENROLLED					TRUE
#define		APPLICATION_IS_NOT_ENROLLED				FALSE
#define		DELIVERY_IS_ENABLED						TRUE
#define		DELIVERY_IS_NOT_ENABLED					FALSE

/*
**	The following enum structure typedefs are used to define the GCC Object Key.
**	The GCC Object Key is used throughout GCC for things like the Application
**	keys and Capability IDs.
*/

typedef AppletKeyType               GCCObjectKeyType, *PGCCObjectKeyType;;
#define GCC_OBJECT_KEY              APPLET_OBJECT_KEY
#define GCC_H221_NONSTANDARD_KEY    APPLET_H221_NONSTD_KEY


typedef struct tagT120ObjectKey
{
    GCCObjectKeyType	key_type;
    GCCLongString		object_id;
    OSTR        		h221_non_standard_id;
}
    T120ObjectKey, GCCObjectKey, *PGCCObjectKey;

/*
**	GCCNonStandardParameter
**		This structure is used within the NetworkAddress typedef and
**		the NetworkService typedef defined below.
*/
typedef struct 
{
	GCCObjectKey		object_key;
	OSTR        		parameter_data;
}
    GCCNonStandardParameter, *PGCCNonStandardParameter;


/*
**	GCCConferenceName
**		This structure defines the conference name.  In a create request, the
**		conference name can include an optional unicode string but it must 
**		always include the simple numeric string.  In a join request, either
**		one can be specified.
*/
typedef struct
{
	GCCNumericString		numeric_string;
	LPWSTR					text_string;			/* optional */
}
    GCCConferenceName, GCCConfName, *PGCCConferenceName, *PGCCConfName;

/*
**	MCSChannelType
**		Should this be defined in MCATMCS?  It is used in a couple of places
**		below and is explicitly defined in the T.124 specification.
*/
typedef AppletChannelType               MCSChannelType, *PMCSChannelType;
#define MCS_STATIC_CHANNEL              APPLET_STATIC_CHANNEL
#define MCS_DYNAMIC_MULTICAST_CHANNEL   APPLET_DYNAMIC_MULTICAST_CHANNEL
#define MCS_DYNAMIC_PRIVATE_CHANNEL     APPLET_DYNAMIC_PRIVATE_CHANNEL
#define MCS_DYNAMIC_USER_ID_CHANNEL     APPLET_DYNAMIC_USER_ID_CHANNEL
#define MCS_NO_CHANNEL_TYPE_SPECIFIED   APPLET_NO_CHANNEL_TYPE_SPECIFIED

/*
**	GCCUserData
**		This structure defines a user data element which is used throughout GCC.
*/
typedef struct
{
	GCCObjectKey		key;
	LPOSTR          	octet_string;	/* optional */
}
    GCCUserData, *PGCCUserData;


/************************************************************************
*																		*
*					Node Controller Related Typedefs					*
*																		*
*************************************************************************/

/*
**	GCCTerminationMethod
**		The termination method is used by GCC to determine
**		what action to take when all participants of a conference have
**		disconnected.  The conference can either be manually terminated
**		by the node controller or it can terminate itself automatically when 
**		all the participants have left the conference.
*/
typedef enum
{
	GCC_AUTOMATIC_TERMINATION_METHOD 		= 0, 
	GCC_MANUAL_TERMINATION_METHOD 	 		= 1
}
    GCCTerminationMethod, *PGCCTerminationMethod;

/*
**	GCCNodeType
**		GCC specified node types.  These node types dictate node controller	  
**		behavior under certain conditions.  See T.124 specification for
**		proper assignment based on the needs of the Node Controller.
*/
typedef enum
{
	GCC_TERMINAL							= 0,
	GCC_MULTIPORT_TERMINAL					= 1,
	GCC_MCU									= 2
}
    GCCNodeType, *PGCCNodeType;

/*
**	GCCNodeProperties
**		GCC specified node properties.  See T.124 specification for proper
**		assignment by the Node Controller.
*/
typedef enum
{
	GCC_PERIPHERAL_DEVICE					= 0,
	GCC_MANAGEMENT_DEVICE					= 1,
	GCC_PERIPHERAL_AND_MANAGEMENT_DEVICE	= 2,
	GCC_NEITHER_PERIPHERAL_NOR_MANAGEMENT	= 3
}
    GCCNodeProperties, *PGCCNodeProperties;

/*
**	GCCPassword
**		This is the unique password specified by the convenor of the
**		conference that is used by the node controller to insure conference
**		security. This is also a unicode string.
*/
typedef	struct
{
	GCCNumericString	numeric_string;
	LPWSTR				text_string;	/* optional */
}
    GCCPassword, *PGCCPassword;

/*
**	GCCChallengeResponseItem
**		This structure defines what a challenge response should look like.
**		Note that either a password string or response data should be passed
**		but not both.
*/
typedef struct
{
    GCCPassword		*		password_string;
	USHORT      			number_of_response_data_members;
	GCCUserData		**		response_data_list;
}
    GCCChallengeResponseItem, *PGCCChallengeResponseItem;

typedef	enum
{
	GCC_IN_THE_CLEAR_ALGORITHM	= 0,
	GCC_NON_STANDARD_ALGORITHM	= 1
}
    GCCPasswordAlgorithmType, *PGCCPasswordAlgorithmType;

typedef struct 
{
    GCCPasswordAlgorithmType		password_algorithm_type;
	GCCNonStandardParameter	*		non_standard_algorithm;	/* optional */
}
    GCCChallengeResponseAlgorithm, *PGCCChallengeResponseAlgorithm;

typedef struct 
{
    GCCChallengeResponseAlgorithm	response_algorithm;
	USHORT      					number_of_challenge_data_members;
	GCCUserData				**		challenge_data_list;
}
    GCCChallengeItem, *PGCCChallengeItem;

typedef struct 
{
    GCCResponseTag			challenge_tag;
	USHORT      			number_of_challenge_items;
	GCCChallengeItem	**	challenge_item_list;
}
    GCCChallengeRequest, *PGCCChallengeRequest;

typedef struct 
{
    GCCResponseTag						challenge_tag;
    GCCChallengeResponseAlgorithm		response_algorithm;
    GCCChallengeResponseItem			response_item;
}
    GCCChallengeResponse, *PGCCChallengeResponse;


typedef	enum
{
	GCC_PASSWORD_IN_THE_CLEAR	= 0,
	GCC_PASSWORD_CHALLENGE 		= 1
}
    GCCPasswordChallengeType, *PGCCPasswordChallengeType;

typedef struct 
{
	GCCPasswordChallengeType	password_challenge_type;
	
	union 
    {
        GCCPassword			password_in_the_clear;
        
        struct 
        {
            GCCChallengeRequest		*	challenge_request;	/* optional */
            GCCChallengeResponse	*	challenge_response;	/* optional */
        } challenge_request_response;
    } u;
}
    GCCChallengeRequestResponse, *PGCCChallengeRequestResponse;

/*
**	GCCAsymmetryType
**		Used in queries to determine if the calling and called node are known
**		by both Node Controllers involved with the connection.
*/
typedef enum
{
	GCC_ASYMMETRY_CALLER				= 1,
	GCC_ASYMMETRY_CALLED				= 2,
	GCC_ASYMMETRY_UNKNOWN				= 3
}
    GCCAsymmetryType, *PGCCAsymmetryType;

/*
**	GCCAsymmetryIndicator
**		Defines how the Node Controller sees itself when making a Query
**		request or response.  The random number portion of this structure is
**		only used if the asymmetry_type is specified to be 
**		GCC_ASYMMETRY_UNKNOWN.
*/
typedef struct
{
	GCCAsymmetryType	asymmetry_type;
	unsigned long		random_number;		/* optional */
}
    GCCAsymmetryIndicator, *PGCCAsymmetryIndicator;

/*
**	GCCNetworkAddress
**		The following block of structures defines the Network Address as defined 
**		by T.124.  Most of these structures were taken almost verbatim from the
**		ASN.1 interface file.  Since I'm not really sure what most of this stuff
**		is for I really didn't know how to simplify it.
*/
typedef	struct 
{
    BOOL         speech;
    BOOL         voice_band;
    BOOL         digital_56k;
    BOOL         digital_64k;
    BOOL         digital_128k;
    BOOL         digital_192k;
    BOOL         digital_256k;
    BOOL         digital_320k;
    BOOL         digital_384k;
    BOOL         digital_512k;
    BOOL         digital_768k;
    BOOL         digital_1152k;
    BOOL         digital_1472k;
    BOOL         digital_1536k;
    BOOL         digital_1920k;
    BOOL         packet_mode;
    BOOL         frame_mode;
    BOOL         atm;
}
    GCCTransferModes, *PGCCTransferModes;

#define		MAXIMUM_DIAL_STRING_LENGTH		17
typedef char	GCCDialingString[MAXIMUM_DIAL_STRING_LENGTH];

typedef struct 
{
    USHORT                  length;
    USHORT          *       value;
}
    GCCExtraDialingString, *PGCCExtraDialingString;

typedef	struct 
{
    BOOL         telephony3kHz;
    BOOL         telephony7kHz;
    BOOL         videotelephony;
    BOOL         videoconference;
    BOOL         audiographic;
    BOOL         audiovisual;
    BOOL         multimedia;
}
    GCCHighLayerCompatibility, *PGCCHighLayerCompatibility;

typedef	struct 
{
    GCCTransferModes				transfer_modes;
    GCCDialingString   				international_number;
    GCCCharacterString				sub_address_string;  		/* optional */
    GCCExtraDialingString		*	extra_dialing_string;  		/* optional */
  	GCCHighLayerCompatibility 	*	high_layer_compatibility;	/* optional */
}
    GCCAggregatedChannelAddress, *PGCCAggregatedChannelAddress;

#define		MAXIMUM_NSAP_ADDRESS_SIZE		20
typedef struct 
{
    struct 
    {
        UINT    length;
        BYTE    value[MAXIMUM_NSAP_ADDRESS_SIZE];
    } nsap_address;
   
	LPOSTR              transport_selector;				/* optional */
}
    GCCTransportConnectionAddress, *PGCCTransportConnectionAddress;

typedef enum
{
	GCC_AGGREGATED_CHANNEL_ADDRESS		= 1,
	GCC_TRANSPORT_CONNECTION_ADDRESS	= 2,
	GCC_NONSTANDARD_NETWORK_ADDRESS		= 3
}
    GCCNetworkAddressType, *PGCCNetworkAddressType;

typedef struct
{
    GCCNetworkAddressType  network_address_type;
    
    union 
    {
		GCCAggregatedChannelAddress		aggregated_channel_address;
		GCCTransportConnectionAddress	transport_connection_address;
        GCCNonStandardParameter			non_standard_network_address;
    } u;
}
    GCCNetworkAddress, *PGCCNetworkAddress;

/*
**	GCCNodeRecord
**		This structure defines a single conference roster record.  See the
**		T.124 specification for parameter definitions.
*/
typedef struct
{
	UserID					node_id;
	UserID					superior_node_id;
	GCCNodeType				node_type;
	GCCNodeProperties		node_properties;
	LPWSTR					node_name; 					/* optional */
	USHORT      			number_of_participants;
	LPWSTR			 	*	participant_name_list; 		/* optional */	
	LPWSTR					site_information; 			/* optional */
	UINT        			number_of_network_addresses;
	GCCNetworkAddress 	**	network_address_list;		/* optional */
	LPOSTR                  alternative_node_id;		/* optional */
	USHORT      			number_of_user_data_members;
	GCCUserData			**	user_data_list;				/* optional */
}
    GCCNodeRecord, *PGCCNodeRecord;

/*
**	GCCConferenceRoster
**		This structure hold a complete conference roster.  See the
**		T.124 specification for parameter definitions.
*/

typedef struct
{  
	USHORT  		instance_number;
	BOOL 			nodes_were_added;
	BOOL 			nodes_were_removed;
	USHORT			number_of_records;
	GCCNodeRecord		 **	node_record_list;
}
    GCCConferenceRoster, *PGCCConferenceRoster, GCCConfRoster, *PGCCConfRoster;

/*
**	GCCConferenceDescriptor
**		Definition for the conference descriptor returned in a 
**		conference query confirm.  This holds information about the
**		conferences that exists at the queried node.
*/
typedef struct
{
	GCCConferenceName		conference_name;
	GCCNumericString		conference_name_modifier;	/* optional */
	LPWSTR					conference_descriptor;		/* optional */
	BOOL				conference_is_locked;
	BOOL				password_in_the_clear_required;
	UINT    			number_of_network_addresses;
	GCCNetworkAddress **	network_address_list;		/* optional */
}
    GCCConferenceDescriptor, *PGCCConferenceDescriptor, GCCConfDescriptor, *PGCCConfDescriptor;

/*
**	ConferencePrivileges
**		This structure defines the list of privileges that can be assigned to
**		a particular conference. 
*/
typedef struct
{
	BOOL		terminate_is_allowed;
	BOOL		eject_user_is_allowed;
	BOOL		add_is_allowed;
	BOOL		lock_unlock_is_allowed;
	BOOL		transfer_is_allowed;
}
    GCCConferencePrivileges, *PGCCConferencePrivileges, GCCConfPrivileges, *PGCCConfPrivileges;

/************************************************************************
*																		*
*					User Application Related Typedefs					*
*																		*
*************************************************************************/

/*
**	GCCSessionKey
**		This is a unique identifier for an application that is
**		using GCC.  See the T.124 for the specifics on what an application
**		key should look like.  A session id of zero indicates that it is
**		not being used.
*/
typedef struct tagT120SessionKey
{
	GCCObjectKey		application_protocol_key;
	GCCSessionID		session_id;
}
    T120SessionKey, GCCSessionKey, *PGCCSessionKey;


/*
**	CapabilityType
**		T.124 supports three different rules when collapsing the capabilities
**		list.  "Logical" keeps a count of the Application Protocol Entities 
**		(APEs) that have that capability, "Unsigned Minimum" collapses to the 
**		minimum value and "Unsigned	Maximum" collapses to the maximum value.		
*/
typedef AppletCapabilityType            GCCCapabilityType, GCCCapType, *PGCCCapabilityType, *PGCCCapType;
#define GCC_UNKNOWN_CAP_TYPE            APPLET_UNKNOWN_CAP_TYPE
#define GCC_LOGICAL_CAPABILITY          APPLET_LOGICAL_CAPABILITY
#define GCC_UNSIGNED_MINIMUM_CAPABILITY APPLET_UNSIGNED_MINIMUM_CAPABILITY
#define GCC_UNSIGNED_MAXIMUM_CAPABILITY APPLET_UNSIGNED_MAXIMUM_CAPABILITY

typedef AppletCapIDType             T120CapabilityIDType, T120CapIDType, GCCCapabilityIDType, GCCCapIDType, *PGCCCapabilityIDType, *PGCCCapIDType;
#define GCC_STANDARD_CAPABILITY     APPLET_STANDARD_CAPABILITY
#define GCC_NON_STANDARD_CAPABILITY APPLET_NONSTD_CAPABILITY


/*
**	CapabilityID
**		T.124 supports both standard and non-standard capabilities.  This
**		structure is used to differentiate between the two.		
*/
typedef struct tagT120CapID
{
    GCCCapabilityIDType	capability_id_type;
    GCCObjectKey		non_standard_capability;
    ULONG               standard_capability;
}
    T120CapID, GCCCapabilityID, GCCCapID, *PGCCCapabilityID, *PGCCCapID;

/* 
**	CapabilityClass
**		This structure defines the class of capability and holds the associated
**		value. Note that Logical is not necessary.  Information associated with 
**		logical is stored in number_of_entities in the GCCApplicationCapability 
**		structure.
*/

typedef AppletCapabilityClass       T120CapClass, GCCCapabilityClass, GCCCapClass, *PGCCCapabilityClass, *PGCCCapClass;


/* 
**	GCCApplicationCapability
**		This structure holds all the data associated with a single T.124 
**		defined application capability.
*/
typedef struct tagT120AppCap
{
	GCCCapabilityID			capability_id;
	GCCCapabilityClass		capability_class;
    ULONG                   number_of_entities;
}
    T120AppCap, GCCApplicationCapability, GCCAppCap, *PGCCApplicationCapability, *PGCCAppCap;

/* 
**	GCCNonCollapsingCapability
*/
typedef struct tagT120NonCollCap
{
	GCCCapabilityID			capability_id;
	LPOSTR                  application_data;	/* optional */
}
    T120NonCollCap, GCCNonCollapsingCapability, GCCNonCollCap, *PGCCNonCollapsingCapability, *PGCCNonCollCap;

/* 
**	GCCApplicationRecord
**		This structure holds all the data associated with a single T.124 
**		application record.  See the T.124 specification for what parameters
**		are optional.
*/
typedef struct tagT120AppRecord
{
	GCCNodeID					node_id;
	GCCEntityID 				entity_id;
	BOOL    					is_enrolled_actively;
	BOOL    					is_conducting_capable;
	MCSChannelType				startup_channel_type; 
	UserID  					application_user_id;  			/* optional */
	ULONG       				number_of_non_collapsed_caps;
	GCCNonCollapsingCapability 
					**	non_collapsed_caps_list;		/* optional */
}
    T120AppRecord, GCCApplicationRecord, GCCAppRecord, *PGCCApplicationRecord, *PGCCAppRecord;

/* 
**	GCCApplicationRoster
**		This structure holds all the data associated with a single T.124 
**		application roster.  This includes the collapsed capabilites and
**		the complete list of application records associated with an Application
**		Protocol Entity (APE).
*/
typedef struct tagT120AppRoster
{
	GCCSessionKey		session_key;
	BOOL 				application_roster_was_changed;
	ULONG         		instance_number;
	BOOL 				nodes_were_added;
	BOOL 				nodes_were_removed;
	BOOL 				capabilities_were_changed;
	ULONG         		number_of_records;
	GCCApplicationRecord 	**	application_record_list;
	ULONG				number_of_capabilities;
	GCCApplicationCapability **	capabilities_list;	/* optional */		
}
    T120AppRoster, GCCApplicationRoster, GCCAppRoster, *PGCCApplicationRoster, *PGCCAppRoster;

/*
**	GCCRegistryKey
**		This key is used to identify a specific resource used
**		by an application. This may be a particular channel or token needed
**		for control purposes.
*/
typedef struct tagT120RegistryKey
{
	GCCSessionKey		session_key;
	OSTR        		resource_id;	/* Max length is 64 */
}
    T120RegistryKey, GCCRegistryKey, *PGCCRegistryKey;

/*
**	RegistryItemType
**		This enum is used to specify what type of registry item is contained
**		at the specified slot in the registry.
*/
typedef AppletRegistryItemType  GCCRegistryItemType, *PGCCRegistryItemType;
#define GCC_REGISTRY_CHANNEL_ID APPLET_REGISTRY_CHANNEL_ID
#define GCC_REGISTRY_TOKEN_ID   APPLET_REGISTRY_TOKEN_ID
#define GCC_REGISTRY_PARAMETER  APPLET_REGISTRY_PARAMETER
#define GCC_REGISTRY_NONE       APPLET_REGISTRY_NONE

/*
**	GCCRegistryItem
**		This structure is used to hold a single registry item.  Note that the
**		union supports all three registry types supported by GCC.
*/
typedef struct
{
	GCCRegistryItemType	item_type;
	// the following three fields were in a union
    ChannelID			channel_id;
	TokenID				token_id;
	OSTR         		parameter;		/* Max length is 64 */
}
    T120RegistryItem, GCCRegistryItem, *PGCCRegistryItem;

/*
**	GCCRegistryEntryOwner
**
*/
typedef struct
{
	BOOL		    entry_is_owned;
	GCCNodeID		owner_node_id;
	GCCEntityID 	owner_entity_id;
}
    T120RegistryEntryOwner, GCCRegistryEntryOwner, *PGCCRegistryEntryOwner;

/*
**	GCCModificationRights
**		This enum is used when specifing what kind of rights a node has to
**		alter the contents of a registry "parameter".
*/
typedef	AppletModificationRights    GCCModificationRights, *PGCCModificationRights;
#define GCC_OWNER_RIGHTS                        APPLET_OWNER_RIGHTS
#define GCC_SESSION_RIGHTS                      APPLET_SESSION_RIGHTS
#define GCC_PUBLIC_RIGHTS                       APPLET_PUBLIC_RIGHTS
#define GCC_NO_MODIFICATION_RIGHTS_SPECIFIED    APPLET_NO_MODIFICATION_RIGHTS_SPECIFIED

/*
**	GCCAppProtocolEntity
**		This structure is used to identify a protocol entity at a remote node
**		when invoke is used.
*/
typedef	struct tagT120APE
{
	GCCSessionKey				session_key;
	MCSChannelType				startup_channel_type;
	BOOL					    must_be_invoked;
	ULONG         				number_of_expected_capabilities;
	GCCApplicationCapability **	expected_capabilities_list;
}
    T120APE, GCCAppProtocolEntity, GCCApe, *PGCCAppProtocolEntity, *PGCCApe;


/*
**	GCCMessageType
**		This section defines the messages that can be sent to the application
**		through the callback facility.  These messages correspond to the 
**		indications and confirms that are defined within T.124.
*/
typedef T120MessageType     GCCMessageType, *PGCCMessageType;

#endif // __GCC_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\h\t120\it120app.h ===
#ifndef _IT120APPSAP_H_
#define _IT120APPSAP_H_

#include <basetyps.h>
#include "gcc.h"
#include "igccapp.h"
#include "imcsapp.h"


typedef void (CALLBACK *LPFN_APPLET_SESSION_CB) (struct T120AppletSessionMsg *);
typedef void (CALLBACK *LPFN_APPLET_CB) (struct T120AppletMsg *);


/* ------ registry request ------ */

typedef struct tagT120RegistryParameter
{
    LPOSTR                      postrValue;
    AppletModificationRights    eModifyRights;
}
    T120RegistryParameter;

typedef struct tagT120RegistryRequest
{
    AppletRegistryCommand   eCommand;
    GCCRegistryKey         *pRegistryKey;
    union
    {
        // register channel
        T120ChannelID           nChannelID;
        // set parameter
        T120RegistryParameter   Param;
        // monitor
        BOOL                    fEnableDelivery;
        // allocate handle
        ULONG                   cHandles;
    };
}
    T120RegistryRequest;


/* ------ channel request ------ */

typedef struct tagT120ChannelRequest
{
    AppletChannelCommand    eCommand;
    T120ChannelID           nChannelID;
    ULONG                   cUsers;
    T120UserID             *aUsers;
}
    T120ChannelRequest;


/* ------ token request ------ */

typedef struct tagT120TokenRequest
{
    AppletTokenCommand      eCommand;
    T120TokenID             nTokenID;
    T120UserID              uidGiveTo;
    T120Result              eGiveResponse;
}
    T120TokenRequest;


/* ------ join conference ------ */

typedef struct tagT120ResourceRequest
{
    AppletResourceAllocCommand  eCommand;
    BOOL                        fImmediateNotification;
    T120ChannelID               nChannelID;
    T120TokenID                 nTokenID;
    GCCRegistryKey              RegKey;
}
    T120ResourceRequest;

typedef struct tagT120JoinSessionRequest
{
    // attach user flags
    DWORD                   dwAttachmentFlags;
    // session specific
    GCCSessionKey           SessionKey;
    // applet enroll
    BOOL                    fConductingCapable;
    AppletChannelType       nStartupChannelType;
    ULONG                   cNonCollapsedCaps;
    GCCNonCollCap         **apNonCollapsedCaps;
    ULONG                   cCollapsedCaps;
    GCCAppCap             **apCollapsedCaps;
    // static and dynamic channels
    ULONG                   cStaticChannels;
    T120ChannelID          *aStaticChannels;
    ULONG                   cResourceReqs;
    T120ResourceRequest    *aResourceReqs;
}
    T120JoinSessionRequest;



#undef  INTERFACE
#define INTERFACE IT120AppletSession
DECLARE_INTERFACE(IT120AppletSession)
{
    STDMETHOD_(void, ReleaseInterface) (THIS) PURE;

    STDMETHOD_(void, Advise) (THIS_
                IN      LPFN_APPLET_SESSION_CB pfnCallback,
                IN      LPVOID  pAppletContext,
                IN      LPVOID  pSessionContext) PURE;

    STDMETHOD_(void, Unadvise) (THIS) PURE;

    /* ------ basic info ------ */

    STDMETHOD_(T120ConfID, GetConfID) (THIS) PURE;

    STDMETHOD_(BOOL, IsThisNodeTopProvider) (THIS) PURE;

    STDMETHOD_(T120NodeID, GetTopProvider) (THIS) PURE;

    /* ------ join/leave ------ */

    STDMETHOD_(T120Error, Join) (THIS_
                IN      T120JoinSessionRequest *) PURE;

    STDMETHOD_(void, Leave) (THIS) PURE;

    /* ------ send data ------ */

    STDMETHOD_(T120Error, AllocateSendDataBuffer) (THIS_
                IN      ULONG,
                OUT     void **) PURE;

    STDMETHOD_(void, FreeSendDataBuffer) (THIS_
                IN      void *) PURE;

    STDMETHOD_(T120Error, SendData) (THIS_
                IN      DataRequestType,
                IN      T120ChannelID,
                IN      T120Priority,
                IN		LPBYTE,
                IN		ULONG,
                IN		SendDataFlags) PURE;

    /* ------ inquiry ------ */

    STDMETHOD_(T120Error, InvokeApplet) (THIS_
                IN      GCCAppProtEntityList *,
                IN      GCCSimpleNodeList *,
                OUT     T120RequestTag *) PURE;

    STDMETHOD_(T120Error, InquireRoster) (THIS_
                IN      GCCSessionKey *) PURE;

    /* ------ registry services ------ */

    STDMETHOD_(T120Error, RegistryRequest) (THIS_
                IN      T120RegistryRequest *) PURE;

    /* ------ channel services ------ */

    STDMETHOD_(T120Error, ChannelRequest) (THIS_
                IN      T120ChannelRequest *) PURE;

    /* ------ token services ------ */

    STDMETHOD_(T120Error, TokenRequest) (THIS_
                IN      T120TokenRequest *) PURE;
};


//
// T120 Applet Session Callback
//

typedef struct tagT120JoinSessionConfirm
{
    T120Result              eResult;
    T120Error               eError;
    IT120AppletSession     *pIAppletSession;
    T120UserID              uidMyself;
    T120SessionID           sidMyself;
    T120EntityID            eidMyself;
    T120NodeID              nidMyself;
    // the following two are the same as those in the request structure
    ULONG                   cResourceReqs;
    T120ResourceRequest    *aResourceReqs;
}
    T120JoinSessionConfirm;


typedef struct tagT120ChannelConfirm
{
    T120ChannelID           nChannelID;
    T120Result              eResult;
}
    T120ChannelConfirm;


typedef struct tagT120ChannelInd
{
    T120ChannelID           nChannelID;
    union
    {
        T120Reason          eReason;
        T120UserID          nManagerID;
    };
}
    T120ChannelInd;


typedef struct tagT120TokenConfirm
{
    T120TokenID             nTokenID;
    union
    {
        T120TokenStatus     eTokenStatus;
        T120Result          eResult;
    };
}
    T120TokenConfirm;


typedef struct tagT120TokenInd
{
    T120TokenID             nTokenID;
    union
    {
        T120Reason          eReason;
        T120UserID          nUserID;
    };
}
    T120TokenInd;


typedef struct tagT120DetachUserInd
{
    T120UserID              nUserID;
    T120Reason              eReason;
}
    T120DetachUserInd;


// internal use
typedef struct tagT120AttachUserConfirm
{
    T120UserID              nUserID;
    T120Result              eResult;
}
    T120AttachUserConfirm;


/*
 *  GCCAppSapMsg
 *      This structure defines the callback message that is passed from GCC to
 *      a user application when an indication or confirm occurs.
 */

typedef struct T120AppletSessionMsg
{
    T120MessageType     eMsgType;
    LPVOID              pAppletContext;
    LPVOID              pSessionContext;
    T120ConfID          nConfID;

    union
    {
        T120JoinSessionConfirm              JoinSessionConfirm;
        T120DetachUserInd                   DetachUserInd;

        GCCAppRosterInquireConfirm          AppRosterInquireConfirm;
        GCCAppRosterReportInd               AppRosterReportInd;

        GCCConfRosterInquireConfirm         ConfRosterInquireConfirm;

        GCCAppInvokeConfirm                 AppInvokeConfirm;
        GCCAppInvokeInd                     AppInvokeInd;

        GCCRegistryConfirm                  RegistryConfirm;
        GCCRegAllocateHandleConfirm         RegAllocHandleConfirm;

        SendDataIndicationPDU               SendDataInd;

        T120ChannelConfirm                  ChannelConfirm;
        T120ChannelInd                      ChannelInd;
        T120TokenConfirm                    TokenConfirm;
        T120TokenInd                        TokenInd;

        // will be removed in the future after converting all applets
        GCCAppEnrollConfirm                 AppEnrollConfirm;
        T120AttachUserConfirm               AttachUserConfirm;
    };
}
    T120AppletSessionMsg;



typedef struct T120AppletMsg
{
    T120MessageType     eMsgType;
    LPVOID              pAppletContext;
    LPVOID              Reserved1;
    T120ConfID          nConfID;

    union
    {
        GCCAppPermissionToEnrollInd         PermitToEnrollInd;
        T120JoinSessionConfirm              AutoJoinSessionInd;
    };
}
    T120AppletMsg;


#undef  INTERFACE
#define INTERFACE IT120AppletNotify
DECLARE_INTERFACE(IT120AppletNotify)
{
    STDMETHOD_(void, PermitToJoinSessionIndication) (THIS_
                    IN      T120ConfID,
                    IN      BOOL fPermissionGranted) PURE;

    STDMETHOD_(void, AutoJoinSessionIndication) (THIS_
                    IN      T120JoinSessionConfirm *) PURE;
};


#undef  INTERFACE
#define INTERFACE IT120Applet
DECLARE_INTERFACE(IT120Applet)
{
    STDMETHOD_(void, ReleaseInterface) (THIS) PURE;

    STDMETHOD_(void, Advise) (THIS_
                    IN      LPFN_APPLET_CB pfnCallback,
                    IN      LPVOID         pAppletContext) PURE;

    STDMETHOD_(void, Unadvise) (THIS) PURE;

    /* ------ Auto Join ------ */

    STDMETHOD_(T120Error, RegisterAutoJoin) (THIS_
                    IN      T120JoinSessionRequest *) PURE;

    STDMETHOD_(void, UnregisterAutoJoin) (THIS) PURE;

    /* ------ Session ------ */

    STDMETHOD_(T120Error, CreateSession) (THIS_
                    OUT     IT120AppletSession **,
                    IN      T120ConfID) PURE;
};


//
// T120 Applet SAP Exports
//

#ifdef __cplusplus
extern "C" {
#endif

T120Error WINAPI T120_CreateAppletSAP(IT120Applet **);

#ifdef __cplusplus
}
#endif


#endif // _IT120APPSAP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\h\t120\igccapp.h ===
#ifndef _IGCCAPP_H_
#define _IGCCAPP_H_

#include <basetyps.h>
#include "gcc.h"

#define GCCAPI_(_type_) virtual _type_   __stdcall
#define GCCAPI          GCCAPI_(GCCError)


typedef struct
{
    GCCSessionKey           *pSessionKey;
    BOOL                    fEnrollActively;
    UserID                  nUserID;
    BOOL                    fConductingCapable;
    MCSChannelType          nStartupChannelType;
    ULONG                   cNonCollapsedCaps;
    GCCNonCollCap           **apNonCollapsedCaps;
    ULONG                   cCollapsedCaps;
    GCCAppCap               **apCollapsedCaps;
    BOOL                    fEnroll;
}
    GCCEnrollRequest, *PGCCEnrollRequest;


typedef struct
{
    ULONG                   cNodes;
    GCCNodeID               *aNodeIDs;
}
    GCCSimpleNodeList, *PGCCSimpleNodeList;


typedef struct
{
    ULONG                   cApes;
    GCCAppProtocolEntity    **apApes;
}
    GCCAppProtEntityList, *PGCCAppProtEntityList;


typedef struct
{
    GCCConfID               nConfID;
    ULONG                   cRosters;
    GCCAppRoster            **apAppRosters;
    GCCResult               nResult;
    LPVOID                  pReserved;          // do not touch
}
    GCCAppRosterInquireConfirm, *PGCCAppRosterInquireConfirm;


typedef struct
{
    GCCConfID               nConfID;
    GCCConfName             ConfName;
    LPSTR                   pszConfModifier;
    LPWSTR                  pwszConfDescriptor;
    GCCConfRoster           *pConfRoster;
    GCCResult               nResult;
}
    GCCConfRosterInquireConfirm, *PGCCConfRosterInquireConfirm;


typedef struct
{
    GCCConfID               nConfID;
    BOOL                    fPermissionGranted;
}
    GCCAppPermissionToEnrollInd, *PGCCAppPermissionToEnrollInd;


typedef struct
{
    GCCConfID               nConfID;
    // GCCSessionKey           *pSessionKey;
    GCCSessionID            sidMyself;
    GCCEntityID             eidMyself;
    GCCNodeID               nidMyself;
    GCCResult               nResult;
    GCCRequestTag           nReqTag;
}
    GCCAppEnrollConfirm, *PGCCAppEnrollConfirm;

typedef struct
{
    GCCConfID               nConfID;
    // GCCAppProtEntityList    *pApeList;
    GCCResult               nResult;
    GCCRequestTag           nReqTag;
}
    GCCAppInvokeConfirm, *PGCCAppInvokeConfirm;

typedef struct
{
    GCCConfID               nConfID;
    GCCAppProtEntityList    ApeList;
    GCCNodeID               nidInvoker;
}
    GCCAppInvokeInd, *PGCCAppInvokeInd;


typedef struct
{
    GCCConfID               nConfID;
    ULONG                   cRosters;
    GCCAppRoster            **apAppRosters;
    LPVOID                  pReserved;          // do not touch
}
    GCCAppRosterReportInd, *PGCCAppRosterReportInd;


typedef struct
{
    GCCConfID               nConfID;
    GCCRegistryKey          *pRegKey;
    GCCRegistryItem         *pRegItem;
    GCCRegistryEntryOwner   EntryOwner;
    GCCModificationRights   eRights;
    GCCResult               nResult;
    BOOL                    fDeliveryEnabled;   // for monitor confirm only
}
    GCCRegistryConfirm, *PGCCRegistryConfirm;


typedef struct
{
    GCCConfID               nConfID;
    ULONG                   nFirstHandle;
    ULONG                   cHandles;
    GCCResult               nResult;
}
    GCCRegAllocateHandleConfirm, *PGCCRegAllocateHandleConfirm;


typedef struct
{
    GCCConfID               nConfID;
    BOOL                    fConducted;
    GCCNodeID               nidConductor;
    BOOL                    fGranted;
    GCCResult               nResult;
}
    GCCConductorInquireConfirm, *PGCCConductorInquireConfirm;


typedef struct
{
    GCCConfID               nConfID;
    BOOL                    fThisNodeIsGranted;
    GCCSimpleNodeList       Granted;
    GCCSimpleNodeList       Waiting;
    LPVOID                  pReserved;      // do not touch
}
    GCCConductorPermitGrantInd, *PGCCConductorPermitGrantInd;


typedef struct
{
    GCCConfID               nConfID;
    GCCNodeID               nidConductor;
}
    GCCConductorAssignInd, *PGCCConductorAssignInd;


typedef struct
{
    GCCConfID               nConfID;
}
    GCCConductorReleaseInd, *PConductorReleaseInd;


/*
 *  GCCAppSapMsg
 *      This structure defines the callback message that is passed from GCC to
 *      a user application when an indication or confirm occurs.
 */

typedef struct
{
    GCCMessageType      eMsgType;
    LPVOID              pAppData;
    LPVOID              reserved1; // reserved
    GCCConfID           nConfID; // reserved

    union
    {
        GCCAppPermissionToEnrollInd         AppPermissionToEnrollInd;
        GCCAppEnrollConfirm                 AppEnrollConfirm;

        GCCAppRosterInquireConfirm          AppRosterInquireConfirm;
        GCCAppRosterReportInd               AppRosterReportInd;

        GCCConfRosterInquireConfirm         ConfRosterInquireConfirm;

        GCCAppInvokeConfirm                 AppInvokeConfirm;
        GCCAppInvokeInd                     AppInvokeInd;

        GCCRegistryConfirm                  RegistryConfirm;
        GCCRegAllocateHandleConfirm         RegAllocHandleConfirm;

        GCCConductorInquireConfirm          ConductorInquireConfirm;
        GCCConductorPermitGrantInd          ConductorPermitGrantInd;
        GCCConductorAssignInd               ConductorAssignInd;
        GCCConductorReleaseInd              ConductorReleaseInd;
    };
}
    GCCAppSapMsg, *PGCCAppSapMsg;


typedef void (CALLBACK *LPFN_APP_SAP_CB) (GCCAppSapMsg *);



#undef  INTERFACE
#define INTERFACE IGCCAppSap
DECLARE_INTERFACE(IGCCAppSap)
{
    STDMETHOD_(void, ReleaseInterface) (THIS) PURE;

    /* application roster services */

    STDMETHOD_(GCCError, AppEnroll) (THIS_
                IN      GCCConfID,
                IN      GCCEnrollRequest *,
                OUT     PGCCRequestTag)
                PURE;

    STDMETHOD_(GCCError, AppInvoke) (THIS_
                IN      GCCConfID,
                IN      GCCAppProtEntityList *,
                IN      GCCSimpleNodeList *,
                OUT     PGCCRequestTag)
                PURE;

    // to acquire one or all full-refresh app roster.
    // can be called by both app sap and control sap.
    STDMETHOD_(GCCError, AppRosterInquire) (THIS_
                IN      GCCConfID,
                IN      GCCSessionKey *,
                OUT     GCCAppSapMsg **)
                PURE;

    STDMETHOD_(void, FreeAppSapMsg) (THIS_
                IN      GCCAppSapMsg *)
                PURE;

    /* conference roster service */

    STDMETHOD_(BOOL, IsThisNodeTopProvider) (THIS_
                IN      GCCConfID)
                PURE;

    STDMETHOD_(GCCNodeID, GetTopProvider) (THIS_
                IN      GCCConfID)
                PURE;

    // to acquire a full-refresh conf roster.
    STDMETHOD_(GCCError, ConfRosterInquire) (THIS_
                IN      GCCConfID,
                OUT     GCCAppSapMsg **)
                PURE;

    /* registry services */

    STDMETHOD_(GCCError, RegisterChannel) (THIS_
                IN      GCCConfID,
                IN      GCCRegistryKey *,
                IN      ChannelID)
                PURE;

    STDMETHOD_(GCCError, RegistryAssignToken) (THIS_
                IN      GCCConfID,
                IN      GCCRegistryKey *)
                PURE;

    STDMETHOD_(GCCError, RegistrySetParameter) (THIS_
                IN      GCCConfID,
                IN      GCCRegistryKey *,
                IN      LPOSTR,
                IN      GCCModificationRights)
                PURE;

    STDMETHOD_(GCCError, RegistryRetrieveEntry) (THIS_
                IN      GCCConfID,
                IN      GCCRegistryKey *)
                PURE;

    STDMETHOD_(GCCError, RegistryDeleteEntry) (THIS_
                IN      GCCConfID,
                IN      GCCRegistryKey *)
                PURE;

    STDMETHOD_(GCCError, RegistryMonitor) (THIS_
                IN      GCCConfID,
                IN      BOOL fEnableDelivery,
                IN      GCCRegistryKey *)
                PURE;

    STDMETHOD_(GCCError, RegistryAllocateHandle) (THIS_
                IN      GCCConfID,
                IN      ULONG cHandles)
                PURE;

    /* conductorship services */

    STDMETHOD_(GCCError, ConductorInquire) (THIS_
                IN      GCCConfID)
                PURE;
};



//
// GCC Application Service Access Point exports
//

#ifdef __cplusplus
extern "C" {
#endif

GCCError WINAPI GCC_CreateAppSap(
                        OUT     IGCCAppSap **,
                        IN      LPVOID, // user defined data
                        IN      LPFN_APP_SAP_CB);
#ifdef __cplusplus
}
#endif


#endif // _IGCCAPP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\h\t120\it120nc.h ===
#ifndef _IGCCControlSAP_H_
#define _IGCCControlSAP_H_

#include <basetyps.h>
#include "gcc.h"
#include "igccapp.h"

/*
 *    These structures are used to hold the information included for the
 *    various callback messages.  In the case where these structures are used for 
 *    callbacks, the address of the structure is passed as the only parameter.
 */

typedef struct
{
    PGCCConferenceName          conference_name;
    GCCNumericString            conference_modifier;
    BOOL                        use_password_in_the_clear;
    BOOL                        conference_is_locked;
    BOOL                        conference_is_listed;
    BOOL                        conference_is_conductible;
    GCCTerminationMethod        termination_method;
    PGCCConferencePrivileges    conduct_privilege_list;
    PGCCConferencePrivileges    conduct_mode_privilege_list;
    PGCCConferencePrivileges    non_conduct_privilege_list;
    LPWSTR                      pwszConfDescriptor;
    LPWSTR                      pwszCallerID;
    TransportAddress            calling_address;
    TransportAddress            called_address;
    PDomainParameters           domain_parameters;
    UINT                        number_of_network_addresses;
    PGCCNetworkAddress         *network_address_list;
    PConnectionHandle           connection_handle;
}
    GCCConfCreateReqCore;

typedef struct
{
    GCCConfCreateReqCore        Core;
    PGCCPassword                convener_password;
    PGCCPassword                password;
    BOOL                        fSecure;
    UINT                        number_of_user_data_members;
    PGCCUserData               *user_data_list;
}
    GCCConfCreateRequest;


/*********************************************************************
 *                                                                   *
 *            NODE CONTROLLER CALLBACK INFO STRUCTURES               *
 *                                                                   *
 *********************************************************************/

typedef struct
{
    GCCConfID                   conference_id;
    GCCResult                   result;
}
    SimpleConfirmMsg;

/*
 *    GCC_CREATE_INDICATION
 *
 *    Union Choice:
 *        CreateIndicationMessage
 *            This is a pointer to a structure that contains all necessary
 *            information about the new conference that is about to be created.
 */
typedef struct
{
    GCCConferenceName           conference_name;
    GCCConferenceID             conference_id;
    GCCPassword                *convener_password;              /* optional */
    GCCPassword                *password;                       /* optional */
    BOOL                        conference_is_locked;
    BOOL                        conference_is_listed;
    BOOL                        conference_is_conductible;
    GCCTerminationMethod        termination_method;
    GCCConferencePrivileges    *conductor_privilege_list;       /* optional */
    GCCConferencePrivileges    *conducted_mode_privilege_list;  /* optional */
    GCCConferencePrivileges    *non_conducted_privilege_list;   /* optional */
    LPWSTR                      conference_descriptor;          /* optional */
    LPWSTR                      caller_identifier;              /* optional */
    TransportAddress            calling_address;                /* optional */
    TransportAddress            called_address;                 /* optional */
    DomainParameters           *domain_parameters;              /* optional */
    UINT                        number_of_user_data_members;
    GCCUserData               **user_data_list;                 /* optional */
    ConnectionHandle            connection_handle;
}
    CreateIndicationMessage, *PCreateIndicationMessage;

/*
 *    GCC_CREATE_CONFIRM
 *
 *    Union Choice:
 *        CreateConfirmMessage
 *            This is a pointer to a structure that contains all necessary
 *            information about the result of a conference create request.
 *            The connection handle and physical handle will be zero on a
 *            local create.
 */
typedef struct
{
    GCCConferenceName           conference_name;
    GCCNumericString            conference_modifier;            /* optional */
    GCCConferenceID             conference_id;
    DomainParameters           *domain_parameters;              /* optional */
    UINT                        number_of_user_data_members;
    GCCUserData               **user_data_list;                 /* optional */
    GCCResult                   result;
    ConnectionHandle            connection_handle;              /* optional */
}
    CreateConfirmMessage, *PCreateConfirmMessage;

/*
 *    GCC_QUERY_INDICATION
 *
 *    Union Choice:
 *        QueryIndicationMessage
 *            This is a pointer to a structure that contains all necessary
 *            information about the conference query.
 */
typedef struct
{
    GCCResponseTag              query_response_tag;
    GCCNodeType                 node_type;
    GCCAsymmetryIndicator      *asymmetry_indicator;
    TransportAddress            calling_address;                /* optional */
    TransportAddress            called_address;                 /* optional */
    UINT                        number_of_user_data_members;
    GCCUserData               **user_data_list;                 /* optional */
    ConnectionHandle            connection_handle;
}
    QueryIndicationMessage, *PQueryIndicationMessage;

/*
 *    GCC_QUERY_CONFIRM
 *
 *    Union Choice:
 *        QueryConfirmMessage
 *            This is a pointer to a structure that contains all necessary
 *            information about the result of a conference query request.
 */
typedef struct
{
    GCCNodeType                 node_type;
    GCCAsymmetryIndicator      *asymmetry_indicator;            /* optional */
    UINT                        number_of_descriptors;
    GCCConferenceDescriptor   **conference_descriptor_list;     /* optional*/
    UINT                        number_of_user_data_members;
    GCCUserData               **user_data_list;                 /* optional */
    GCCResult                   result;
    ConnectionHandle            connection_handle;
}
    QueryConfirmMessage, *PQueryConfirmMessage;
    

/*
 *    GCC_JOIN_INDICATION
 *
 *    Union Choice:
 *        JoinIndicationMessage
 *            This is a pointer to a structure that contains all necessary
 *            information about the join request.
 */
typedef struct
{
    GCCResponseTag              join_response_tag;
    GCCConferenceID             conference_id;
    GCCPassword                *convener_password;              /* optional */
    GCCChallengeRequestResponse*password_challenge;             /* optional */
    LPWSTR                      caller_identifier;              /* optional */
    TransportAddress            calling_address;                /* optional */
    TransportAddress            called_address;                 /* optional */
    UINT                        number_of_user_data_members;
    GCCUserData               **user_data_list;                 /* optional */
    BOOL                        node_is_intermediate;
    ConnectionHandle            connection_handle;
}
    JoinIndicationMessage, *PJoinIndicationMessage;

/*
 *    GCC_JOIN_CONFIRM
 *
 *    Union Choice:
 *        JoinConfirmMessage
 *            This is a pointer to a structure that contains all necessary
 *            information about the join confirm.
 */
typedef struct
{
    GCCConferenceName           conference_name;
    GCCNumericString            called_node_modifier;           /* optional */
    GCCNumericString            calling_node_modifier;          /* optional */
    GCCConferenceID             conference_id;
    GCCChallengeRequestResponse*password_challenge;             /* optional */
    DomainParameters           *domain_parameters;
    BOOL                        clear_password_required;
    BOOL                        conference_is_locked;
    BOOL                        conference_is_listed;
    BOOL                        conference_is_conductible;
    GCCTerminationMethod        termination_method;
    GCCConferencePrivileges    *conductor_privilege_list;       /* optional */
    GCCConferencePrivileges    *conducted_mode_privilege_list;  /* optional */
    GCCConferencePrivileges    *non_conducted_privilege_list;   /* optional */
    LPWSTR                      conference_descriptor;          /* optional */
    UINT                        number_of_user_data_members;
    GCCUserData               **user_data_list;                 /* optional */
    GCCResult                   result;
    ConnectionHandle            connection_handle;
    PBYTE                       pb_remote_cred;
    DWORD                       cb_remote_cred;
}
    JoinConfirmMessage, *PJoinConfirmMessage;

/*
 *    GCC_INVITE_INDICATION
 *
 *    Union Choice:
 *        InviteIndicationMessage
 *            This is a pointer to a structure that contains all necessary
 *            information about the invite indication.
 */
typedef struct
{
    GCCConferenceID             conference_id;
    GCCConferenceName           conference_name;
    LPWSTR                      caller_identifier;              /* optional */
    TransportAddress            calling_address;                /* optional */
    TransportAddress            called_address;                 /* optional */
    BOOL                        fSecure;
    DomainParameters           *domain_parameters;              /* optional */
    BOOL                        clear_password_required;
    BOOL                        conference_is_locked;
    BOOL                        conference_is_listed;
    BOOL                        conference_is_conductible;
    GCCTerminationMethod        termination_method;
    GCCConferencePrivileges    *conductor_privilege_list;       /* optional */
    GCCConferencePrivileges    *conducted_mode_privilege_list;  /* optional */
    GCCConferencePrivileges    *non_conducted_privilege_list;   /* optional */
    LPWSTR                      conference_descriptor;          /* optional */
    UINT                        number_of_user_data_members;
    GCCUserData               **user_data_list;                 /* optional */
    ConnectionHandle            connection_handle;
}
    InviteIndicationMessage, *PInviteIndicationMessage;

/*
 *    GCC_INVITE_CONFIRM
 *
 *    Union Choice:
 *        InviteConfirmMessage
 *            This is a pointer to a structure that contains all necessary
 *            information about the invite confirm.
 */
typedef struct
{
    GCCConferenceID             conference_id;
    UINT                        number_of_user_data_members;
    GCCUserData               **user_data_list;                 /* optional */
    GCCResult                   result;
    ConnectionHandle            connection_handle;
}
    InviteConfirmMessage, *PInviteConfirmMessage;

/*
 *    GCC_ADD_INDICATION
 *
 *    Union Choice:
 *        AddIndicationMessage
 */
typedef struct
{
    GCCResponseTag              add_response_tag;
    GCCConferenceID             conference_id;
    UINT                        number_of_network_addresses;
    GCCNetworkAddress         **network_address_list;
    UserID                      requesting_node_id;
    UINT                        number_of_user_data_members;
    GCCUserData               **user_data_list;                 /* optional */
}
    AddIndicationMessage, *PAddIndicationMessage;

/*
 *    GCC_ADD_CONFIRM
 *
 *    Union Choice:
 *        AddConfirmMessage
 */
typedef struct
{
    GCCConferenceID             conference_id;
    UINT                        number_of_network_addresses;
    GCCNetworkAddress         **network_address_list;
    UINT                        number_of_user_data_members;
    GCCUserData               **user_data_list;                 /* optional */
    GCCResult                   result;
}
    AddConfirmMessage, *PAddConfirmMessage;

/*
 *    GCC_LOCK_INDICATION
 *
 *    Union Choice:
 *        LockIndicationMessage
 */
typedef struct
{
    GCCConferenceID             conference_id;
    UserID                      requesting_node_id;
}
    LockIndicationMessage, *PLockIndicationMessage;

/*
 *    GCC_UNLOCK_INDICATION
 *
 *    Union Choice:
 *        UnlockIndicationMessage
 */
typedef struct
{
    GCCConferenceID             conference_id;
    UserID                      requesting_node_id;
}
    UnlockIndicationMessage, *PUnlockIndicationMessage;

/*
 *    GCC_DISCONNECT_INDICATION
 *
 *    Union Choice:
 *        DisconnectIndicationMessage
 */
typedef struct
{
    GCCConferenceID             conference_id;
    GCCReason                   reason;
    UserID                      disconnected_node_id;
}
    DisconnectIndicationMessage, *PDisconnectIndicationMessage;

/*
 *    GCC_DISCONNECT_CONFIRM
 *
 *    Union Choice:
 *        PDisconnectConfirmMessage
 */
typedef SimpleConfirmMsg    DisconnectConfirmMessage, *PDisconnectConfirmMessage;

/*
 *    GCC_TERMINATE_INDICATION
 *
 *    Union Choice:
 *        TerminateIndicationMessage
 */
typedef struct
{
    GCCConferenceID             conference_id;
    UserID                      requesting_node_id;
    GCCReason                   reason;
}
    TerminateIndicationMessage, *PTerminateIndicationMessage;

/*
 *    GCC_TERMINATE_CONFIRM
 *
 *    Union Choice:
 *        TerminateConfirmMessage
 */
typedef SimpleConfirmMsg    TerminateConfirmMessage, *PTerminateConfirmMessage;

/*
 *    GCC_CONNECTION_BROKEN_INDICATION
 *
 *    Union Choice:
 *        ConnectionBrokenIndicationMessage
 *
 *    Caveat: 
 *        This is a non-standard indication.
 */
typedef struct
{
    ConnectionHandle            connection_handle;
}
    ConnectionBrokenIndicationMessage, *PConnectionBrokenIndicationMessage;


/*
 *    GCC_EJECT_USER_INDICATION
 *
 *    Union Choice:
 *        EjectUserIndicationMessage
 */
typedef struct
{
    GCCConferenceID             conference_id;
    UserID                      ejected_node_id;
    GCCReason                   reason;
}
    EjectUserIndicationMessage, *PEjectUserIndicationMessage;

/*
 *    GCC_PERMIT_TO_ANNOUNCE_PRESENCE
 *
 *    Union Choice:
 *        PermitToAnnouncePresenceMessage
 */
typedef struct
{
    GCCConferenceID             conference_id;
    UserID                      node_id;
}
    PermitToAnnouncePresenceMessage, *PPermitToAnnouncePresenceMessage;

/*
 *    GCC_ANNOUNCE_PRESENCE_CONFIRM
 *
 *    Union Choice:
 *        AnnouncePresenceConfirmMessage
 */
typedef SimpleConfirmMsg    AnnouncePresenceConfirmMessage, *PAnnouncePresenceConfirmMessage;

/*
 *    GCC_ROSTER_REPORT_INDICATION
 *
 *    Union Choice:
 *        ConfRosterReportIndicationMessage
 */
typedef struct
{
    GCCConferenceID             conference_id;
    GCCConferenceRoster        *conference_roster;
}
    ConfRosterReportIndicationMessage, *PConfRosterReportIndicationMessage;

/*
 *    GCC_CONDUCT_GIVE_INDICATION
 *
 *    Union Choice:
 *        ConductorGiveIndicationMessage
 */
typedef struct
{        
    GCCConferenceID             conference_id;
}
    ConductGiveIndicationMessage, *PConductGiveIndicationMessage;

/*
 *    GCC_TIME_INQUIRE_INDICATION
 *
 *    Union Choice:
 *        TimeInquireIndicationMessage
 */
typedef struct
{
    GCCConferenceID             conference_id;
    BOOL                        time_is_conference_wide;
    UserID                      requesting_node_id;
}
    TimeInquireIndicationMessage, *PTimeInquireIndicationMessage;

/*
 *    GCC_STATUS_INDICATION
 *
 *    Union Choice:
 *        GCCStatusMessage
 *            This callback is used to relay GCC status to the node controller
 */
typedef    enum
{
    GCC_STATUS_PACKET_RESOURCE_FAILURE      = 0,
    GCC_STATUS_PACKET_LENGTH_EXCEEDED       = 1,
    GCC_STATUS_CTL_SAP_RESOURCE_ERROR       = 2,
    GCC_STATUS_APP_SAP_RESOURCE_ERROR       = 3, /*    parameter = Sap Handle */
    GCC_STATUS_CONF_RESOURCE_ERROR          = 4, /*    parameter = Conference ID */
    GCC_STATUS_INCOMPATIBLE_PROTOCOL        = 5, /*    parameter = Physical Handle */
    GCC_STATUS_JOIN_FAILED_BAD_CONF_NAME    = 6, /* parameter = Physical Handle */
    GCC_STATUS_JOIN_FAILED_BAD_CONVENER     = 7, /* parameter = Physical Handle */
    GCC_STATUS_JOIN_FAILED_LOCKED           = 8  /* parameter = Physical Handle */
}
    GCCStatusMessageType;

typedef struct
{
    GCCStatusMessageType        status_message_type;
    UINT                        parameter;
}
    GCCStatusIndicationMessage, *PGCCStatusIndicationMessage;

/*
 *    GCC_SUB_INITIALIZED_INDICATION
 *
 *    Union Chice:
 *        SubInitializedIndicationMessage
 */
typedef struct
{
    ConnectionHandle            connection_handle;
    UserID                      subordinate_node_id;
}
    SubInitializedIndicationMessage, *PSubInitializedIndicationMessage;



#ifdef JASPER // ------------------------------------------------
/*
 *    GCC_LOCK_CONFIRM
 *
 *    Union Choice:
 *        LockConfirmMessage
 */
typedef SimpleConfirmMsg    LockConfirmMessage, *PLockConfirmMessage;

/*
 *    GCC_UNLOCK_CONFIRM
 *
 *    Union Choice:
 *        UnlockConfirmMessage
 */
typedef SimpleConfirmMsg    UnlockConfirmMessage, *PUnlockConfirmMessage;

/*
 *    GCC_LOCK_REPORT_INDICATION
 *
 *    Union Choice:
 *        LockReportIndicationMessage
 */
typedef struct
{
    GCCConferenceID             conference_id;
    BOOL                        conference_is_locked;
}
    LockReportIndicationMessage, *PLockReportIndicationMessage;

/*
 *    GCC_EJECT_USER_CONFIRM
 *
 *    Union Choice:
 *        EjectUserConfirmMessage
 */
typedef struct
{
    GCCConferenceID              conference_id;
    GCCResult                    result;
    UserID                       ejected_node_id;
}
    EjectUserConfirmMessage, *PEjectUserConfirmMessage;

/*
 *    GCC_TRANSFER_INDICATION
 *
 *    Union Choice:
 *        TransferIndicationMessage
 */
typedef struct
{
    GCCConferenceID             conference_id;
    GCCConferenceName           destination_conference_name;
    GCCNumericString            destination_conference_modifier;/* optional */
    UINT                        number_of_destination_addresses;
    GCCNetworkAddress         **destination_address_list;
    GCCPassword                *password;                       /* optional */
}
    TransferIndicationMessage, *PTransferIndicationMessage;

/*
 *    GCC_TRANSFER_CONFIRM
 *
 *    Union Choice:
 *        TransferConfirmMessage
 */
typedef struct
{
    GCCConferenceID             conference_id;
    GCCConferenceName           destination_conference_name;
    GCCNumericString            destination_conference_modifier;/* optional */
    UINT                        number_of_destination_nodes;
    UserID                     *destination_node_list;
    GCCResult                   result;
}
    TransferConfirmMessage, *PTransferConfirmMessage;

/*
 *    GCC_CONDUCT_ASSIGN_CONFIRM
 *
 *    Union Choice:
 *        ConductAssignConfirmMessage
 */
typedef SimpleConfirmMsg    ConductAssignConfirmMessage, *PConductAssignConfirmMessage;

/*
 *    GCC_CONDUCT_RELEASE_CONFIRM
 *
 *    Union Choice:
 *        ConductorReleaseConfirmMessage
 */
typedef SimpleConfirmMsg    ConductReleaseConfirmMessage, *PConductReleaseConfirmMessage; 

/*
 *    GCC_CONDUCT_PLEASE_INDICATION
 *
 *    Union Choice:
 *        ConductorPleaseIndicationMessage
 */
typedef struct
{
    GCCConferenceID             conference_id;
    UserID                      requester_node_id;
}
    ConductPleaseIndicationMessage, *PConductPleaseIndicationMessage; 

/*
 *    GCC_CONDUCT_PLEASE_CONFIRM
 *
 *    Union Choice:
 *        ConductPleaseConfirmMessage
 */
typedef SimpleConfirmMsg    ConductPleaseConfirmMessage, *PConductPleaseConfirmMessage;

/*
 *    GCC_CONDUCT_GIVE_CONFIRM
 *
 *    Union Choice:
 *        ConductorGiveConfirmMessage
 */
typedef struct
{
    GCCConferenceID             conference_id;
    GCCResult                   result;
    UserID                      recipient_node_id;
}
    ConductGiveConfirmMessage, *PConductGiveConfirmMessage;

/*
 *    GCC_CONDUCT_ASK_INDICATION
 *
 *    Union Choice:
 *        ConductPermitAskIndicationMessage
 */
typedef struct
{
    GCCConferenceID             conference_id;
    BOOL                        permission_is_granted;
    UserID                      requester_node_id;
}
    ConductPermitAskIndicationMessage, *PConductPermitAskIndicationMessage; 

/*
 *    GCC_CONDUCT_ASK_CONFIRM
 *
 *    Union Choice:
 *        ConductPermitAskConfirmMessage
 */
typedef struct
{
    GCCConferenceID             conference_id;
    GCCResult                   result;
    BOOL                        permission_is_granted;
}
    ConductPermitAskConfirmMessage, *PConductPermitAskConfirmMessage;

/*
 *    GCC_CONDUCT_GRANT_CONFIRM
 *
 *    Union Choice:
 *        ConductPermissionGrantConfirmMessage
 */
typedef SimpleConfirmMsg    ConductPermitGrantConfirmMessage, *PConductPermitGrantConfirmMessage;

/*
 *    GCC_TIME_REMAINING_INDICATION
 *
 *    Union Choice:
 *        TimeRemainingIndicationMessage
 */
typedef struct
{
    GCCConferenceID             conference_id;
    UINT                        time_remaining;
    UserID                      node_id;
    UserID                      source_node_id;
}
    TimeRemainingIndicationMessage, *PTimeRemainingIndicationMessage;

/*
 *    GCC_TIME_REMAINING_CONFIRM
 *
 *    Union Choice:
 *        TimeRemainingConfirmMessage
 */
typedef SimpleConfirmMsg    TimeRemainingConfirmMessage, *PTimeRemainingConfirmMessage;

/*
 *    GCC_TIME_INQUIRE_CONFIRM
 *
 *    Union Choice:
 *        TimeInquireConfirmMessage
 */
typedef SimpleConfirmMsg    TimeInquireConfirmMessage, *PTimeInquireConfirmMessage;

/*
 *    GCC_CONFERENCE_EXTEND_INDICATION
 *
 *    Union Choice:
 *        ConferenceExtendIndicationMessage
 */
typedef struct
{
    GCCConferenceID             conference_id;
    UINT                        extension_time;
    BOOL                        time_is_conference_wide;
    UserID                      requesting_node_id;
}
    ConferenceExtendIndicationMessage, *PConferenceExtendIndicationMessage;

/*
 *    GCC_CONFERENCE_EXTEND_CONFIRM
 *
 *    Union Choice:
 *        ConferenceExtendConfirmMessage
 */
typedef struct
{
    GCCConferenceID             conference_id;
    UINT                        extension_time;
    GCCResult                   result;
}
    ConferenceExtendConfirmMessage, *PConferenceExtendConfirmMessage;

/*
 *    GCC_ASSISTANCE_INDICATION
 *
 *    Union Choice:
 *        ConferenceAssistIndicationMessage
 */
typedef struct
{
    GCCConferenceID             conference_id;
    UINT                        number_of_user_data_members;
    GCCUserData               **user_data_list;
    UserID                      source_node_id;
}
    ConferenceAssistIndicationMessage, *PConferenceAssistIndicationMessage;

/*
 *    GCC_ASSISTANCE_CONFIRM
 *
 *    Union Choice:
 *        ConferenceAssistConfirmMessage
 */
typedef SimpleConfirmMsg    ConferenceAssistConfirmMessage, *PConferenceAssistConfirmMessage;

/*
 *    GCC_TEXT_MESSAGE_INDICATION
 *
 *    Union Choice:
 *        TextMessageIndicationMessage
 */
typedef struct
{
    GCCConferenceID             conference_id;
    LPWSTR                      text_message;
    UserID                      source_node_id;
}
    TextMessageIndicationMessage, *PTextMessageIndicationMessage;

/*
 *    GCC_TEXT_MESSAGE_CONFIRM
 *
 *    Union Choice:
 *        TextMessageConfirmMessage
 */
typedef SimpleConfirmMsg    TextMessageConfirmMessage, *PTextMessageConfirmMessage;
#endif // JASPER // ------------------------------------------------


/*********************************************************************
 *                                                                   *
 *            USER APPLICATION CALLBACK INFO STRUCTURES              *
 *                                                                   *
 *********************************************************************/

/*
 *    GCC_APP_ROSTER_REPORT_INDICATION
 *
 *    Union Choice:
 *        AppRosterReportIndicationMessage
 */
typedef struct
{
    GCCConferenceID             conference_id;
    ULONG                       number_of_rosters;
    GCCApplicationRoster      **application_roster_list;
}
    AppRosterReportIndicationMessage, *PAppRosterReportIndicationMessage;

/*********************************************************************
 *                                                                     *
 *                SHARED CALLBACK INFO STRUCTURES                         *
 *        (Note that this doesn't include all the shared callbacks)    *
 *                                                                     *
 *********************************************************************/

/*
 *    GCC_ROSTER_INQUIRE_CONFIRM
 *
 *    Union Choice:
 *        ConfRosterInquireConfirmMessage
 */
typedef struct
{
    GCCConferenceID             conference_id;
    GCCConferenceName           conference_name;
    GCCNumericString            conference_modifier;
    LPWSTR                      conference_descriptor;
    GCCConferenceRoster        *conference_roster;
    GCCResult                   result;
}
    ConfRosterInquireConfirmMessage, *PConfRosterInquireConfirmMessage;

/*
 *    GCC_APPLICATION_INVOKE_INDICATION
 *
 *    Union Choice:
 *        ApplicationInvokeIndicationMessage
 */
typedef struct
{
    GCCConferenceID             conference_id;
    ULONG                       number_of_app_protocol_entities;
    GCCAppProtocolEntity      **app_protocol_entity_list;
    UserID                      invoking_node_id;
}
    ApplicationInvokeIndicationMessage, *PApplicationInvokeIndicationMessage;

/*
 *    GCC_APPLICATION_INVOKE_CONFIRM
 *
 *    Union Choice:
 *        ApplicationInvokeConfirmMessage
 */
typedef struct
{
    GCCConferenceID             conference_id;
    ULONG                       number_of_app_protocol_entities;
    GCCAppProtocolEntity      **app_protocol_entity_list;
    GCCResult                   result;
}
    ApplicationInvokeConfirmMessage, *PApplicationInvokeConfirmMessage;
 


#ifdef JASPER // ------------------------------------------------
/*
 *    GCC_APP_ROSTER_INQUIRE_CONFIRM
 *
 *    Union Choice:
 *        AppRosterInquireConfirmMessage
 */
typedef struct
{
    GCCConferenceID             conference_id;
    ULONG                       number_of_rosters;
    GCCApplicationRoster      **application_roster_list;
    GCCResult                   result;
}
    AppRosterInquireConfirmMessage, *PAppRosterInquireConfirmMessage;

/*
 *    GCC_CONDUCT_INQUIRE_CONFIRM
 *
 *    Union Choice:
 *        ConductorInquireConfirmMessage
 */
typedef struct
{
    GCCConferenceID             conference_id;
    BOOL                        mode_is_conducted;
    UserID                      conductor_node_id;
    BOOL                        permission_is_granted;
    GCCResult                   result;
}
    ConductInquireConfirmMessage, *PConductInquireConfirmMessage;

/*
 *    GCC_CONDUCT_ASSIGN_INDICATION
 *
 *    Union Choice:
 *        ConductAssignIndicationMessage
 */
typedef struct
{
    GCCConferenceID             conference_id;
    UserID                      node_id;
}
    ConductAssignIndicationMessage, *PConductAssignIndicationMessage; 

/*
 *    GCC_CONDUCT_RELEASE_INDICATION
 *
 *    Union Choice:
 *        ConductReleaseIndicationMessage
 */
typedef struct
{
    GCCConferenceID             conference_id;
}
    ConductReleaseIndicationMessage, *PConductReleaseIndicationMessage;

/*
 *    GCC_CONDUCT_GRANT_INDICATION
 *
 *    Union Choice:
 *        ConductPermitGrantIndicationMessage
 */
typedef struct
{
    GCCConferenceID             conference_id;
    UINT                        number_granted;
    UserID                     *granted_node_list;
    UINT                        number_waiting;
    UserID                     *waiting_node_list;
    BOOL                        permission_is_granted;
}
    ConductPermitGrantIndicationMessage, *PConductPermitGrantIndicationMessage; 
#endif // JASPER  // ------------------------------------------------


/*
 *    GCCMessage
 *        This structure defines the message that is passed from GCC to either
 *        the node controller or a user application when an indication or
 *        confirm occurs.
 */

typedef    struct
{
    GCCMessageType              message_type;
    LPVOID                      user_defined;

    // GCCNC relies on easy access to conference ID.
    GCCConfID                   nConfID;

    union
    {
        CreateIndicationMessage                 create_indication;
        CreateConfirmMessage                    create_confirm;
        QueryIndicationMessage                  query_indication;
        QueryConfirmMessage                     query_confirm;
        JoinIndicationMessage                   join_indication;
        JoinConfirmMessage                      join_confirm;
        InviteIndicationMessage                 invite_indication;
        InviteConfirmMessage                    invite_confirm;
        AddIndicationMessage                    add_indication;
        AddConfirmMessage                       add_confirm;
        LockIndicationMessage                   lock_indication;
        UnlockIndicationMessage                 unlock_indication;
        DisconnectIndicationMessage             disconnect_indication;
        DisconnectConfirmMessage                disconnect_confirm;
        TerminateIndicationMessage              terminate_indication;
        TerminateConfirmMessage                 terminate_confirm;
        ConnectionBrokenIndicationMessage       connection_broken_indication;
        EjectUserIndicationMessage              eject_user_indication;    
        ApplicationInvokeIndicationMessage      application_invoke_indication;
        ApplicationInvokeConfirmMessage         application_invoke_confirm;
        SubInitializedIndicationMessage         conf_sub_initialized_indication;
        PermitToAnnouncePresenceMessage         permit_to_announce_presence;
        AnnouncePresenceConfirmMessage          announce_presence_confirm;
        ConfRosterReportIndicationMessage       conf_roster_report_indication;
        ConductGiveIndicationMessage            conduct_give_indication;
        TimeInquireIndicationMessage            time_inquire_indication;
        GCCStatusIndicationMessage              status_indication;
        AppRosterReportIndicationMessage        app_roster_report_indication;
        ConfRosterInquireConfirmMessage         conf_roster_inquire_confirm;
#ifdef TSTATUS_INDICATION
        TransportStatus                         transport_status;
#endif // TSTATUS_INDICATION

#ifdef JASPER // ------------------------------------------------
        TextMessageIndicationMessage            text_message_indication;
        TimeRemainingIndicationMessage          time_remaining_indication;
        AppRosterInquireConfirmMessage          app_roster_inquire_confirm;
        ConferenceAssistConfirmMessage          conference_assist_confirm;
        ConferenceAssistIndicationMessage       conference_assist_indication;
        ConductPermitAskConfirmMessage          conduct_permit_ask_confirm;
        ConductPermitAskIndicationMessage       conduct_permit_ask_indication; 
        ConductAssignConfirmMessage             conduct_assign_confirm;
        ConductAssignIndicationMessage          conduct_assign_indication; 
        ConductGiveConfirmMessage               conduct_give_confirm;
        ConductPermitGrantConfirmMessage        conduct_permit_grant_confirm;
        ConductPermitGrantIndicationMessage     conduct_permit_grant_indication; 
        ConductInquireConfirmMessage            conduct_inquire_confirm;
        ConductPleaseConfirmMessage             conduct_please_confirm;
        ConductPleaseIndicationMessage          conduct_please_indication;
        ConductReleaseConfirmMessage            conduct_release_confirm; 
        ConductReleaseIndicationMessage         conduct_release_indication; 
        ConferenceExtendConfirmMessage          conference_extend_confirm;
        ConferenceExtendIndicationMessage       conference_extend_indication;
        EjectUserConfirmMessage                 eject_user_confirm;
        LockConfirmMessage                      lock_confirm;
        LockReportIndicationMessage             lock_report_indication;
        TextMessageConfirmMessage               text_message_confirm;
        TimeInquireConfirmMessage               time_inquire_confirm;
        TimeRemainingConfirmMessage             time_remaining_confirm;
        TransferConfirmMessage                  transfer_confirm;
        TransferIndicationMessage               transfer_indication;
        UnlockConfirmMessage                    unlock_confirm;
#endif // JASPER // ------------------------------------------------

        // easy acess to conf id and gcc result
        SimpleConfirmMsg        simple_confirm;
    } u;
}
    GCCMessage, *PGCCMessage, T120Message, *PT120Message;


// node controller callback entry
typedef void (CALLBACK *LPFN_T120_CONTROL_SAP_CB) (T120Message *);


#undef  INTERFACE
#define INTERFACE IT120ControlSAP
DECLARE_INTERFACE(IT120ControlSAP)
{
    STDMETHOD_(void, ReleaseInterface) (THIS) PURE;

    /*
     *  GCCError    ConfCreateRequest()
     *        This routine is a request to create a new conference. Both 
     *        the local node and the node to which the create conference 
     *        request is directed to, join the conference automatically.  
     */
    STDMETHOD_(GCCError, ConfCreateRequest) (THIS_
                    GCCConfCreateRequest *,
                    GCCConfID *) PURE;

    /*    
     *  GCCError    ConfCreateResponse()
     *        This procedure is a remote node controller's response to a con-
     *        ference creation request by the convener. 
     */

    STDMETHOD_(GCCError, ConfCreateResponse) (THIS_
                    GCCNumericString            conference_modifier,
                    GCCConfID,
                    BOOL                        use_password_in_the_clear,
                    DomainParameters           *domain_parameters,
                    UINT                        number_of_network_addresses,
                    GCCNetworkAddress         **local_network_address_list,
                    UINT                        number_of_user_data_members,
                    GCCUserData               **user_data_list,
                    GCCResult) PURE;

    /*
     *  GCCError    ConfQueryRequest()
     *        This routine is a request to query a node for information about the
     *        conferences that exist at that node.
     */
    STDMETHOD_(GCCError, ConfQueryRequest) (THIS_
                    GCCNodeType                 node_type,
                    GCCAsymmetryIndicator      *asymmetry_indicator,
                    TransportAddress            calling_address,
                    TransportAddress            called_address,
                    BOOL                        fSecure,
                    UINT                        number_of_user_data_members,
                    GCCUserData               **user_data_list,
                    ConnectionHandle           *connection_handle) PURE;

    STDMETHOD_(void, CancelConfQueryRequest) (THIS_
                    ConnectionHandle) PURE;

    /*
     *  GCCError    ConfQueryResponse()
     *        This routine is called in response to a conference query request.
     */
    STDMETHOD_(GCCError, ConfQueryResponse) (THIS_
                    GCCResponseTag              query_response_tag,
                    GCCNodeType                 node_type,
                    GCCAsymmetryIndicator      *asymmetry_indicator,
                    UINT                        number_of_user_data_members,
                    GCCUserData               **user_data_list,
                    GCCResult) PURE;

    /*
     *  GCCError    AnnouncePresenceRequest()
     *        This routine is invoked by node controller when a node joins a 
     *        conference, to announce the presence of the new node to all
     *        other nodes of the conference. This should be followed by a
     *        GCCConferenceReport indication by the GCC to all nodes.
     */
    STDMETHOD_(GCCError, AnnouncePresenceRequest) (THIS_
                    GCCConfID,
                    GCCNodeType                 node_type,
                    GCCNodeProperties           node_properties,
                    LPWSTR                      pwszNodeName,
                    UINT                        number_of_participants,
                    LPWSTR                     *ppwszParticipantNameList,
                    LPWSTR                      pwszSiteInfo,
                    UINT                        number_of_network_addresses,
                    GCCNetworkAddress         **network_address_list,
                    LPOSTR                      alternative_node_id,
                    UINT                        number_of_user_data_members,
                    GCCUserData               **user_data_list) PURE;

    /*
     *  GCCError    ConfJoinRequest()
     *        This routine is invoked by node controller to cause the local
     *        node to join an existing conference.    
     */
    STDMETHOD_(GCCError, ConfJoinRequest) (THIS_
                    GCCConferenceName          *conference_name,
                    GCCNumericString            called_node_modifier,
                    GCCNumericString            calling_node_modifier,
                    GCCPassword                *convener_password,
                    GCCChallengeRequestResponse*password_challenge,
                    LPWSTR                      pwszCallerID,
                    TransportAddress            calling_address,
                    TransportAddress            called_address,
                    BOOL                        fSecure,
                    DomainParameters           *domain_parameters,
                    UINT                        number_of_network_addresses,
                    GCCNetworkAddress         **local_network_address_list,
                    UINT                        number_of_user_data_members,
                    GCCUserData               **user_data_list,
                    ConnectionHandle           *connection_handle,
                    GCCConfID                  *pnConfID) PURE;

    /*
     *  GCCError    ConfJoinResponse()
     *        This routine is remote node controller's response to conference join 
     *        request by the local node controller.
     */
    STDMETHOD_(GCCError, ConfJoinResponse) (THIS_
                    GCCResponseTag              join_response_tag,
                    GCCChallengeRequestResponse*password_challenge,
                    UINT                        number_of_user_data_members,
                    GCCUserData               **user_data_list,
                    GCCResult) PURE;

    /*
     *  GCCError    ConfInviteRequest()
     *        This routine is invoked by node controller to invite a node  
     *        to join a conference.
     */
    STDMETHOD_(GCCError, ConfInviteRequest) (THIS_
                    GCCConfID,
                    LPWSTR                      pwszCallerID,
                    TransportAddress            calling_address,
                    TransportAddress            called_address,
                    BOOL                        fSecure,
                    UINT                        number_of_user_data_members,
                    GCCUserData               **user_data_list,
                    ConnectionHandle           *connection_handle) PURE;

    STDMETHOD_(void, CancelInviteRequest) (THIS_
                    GCCConfID,
                    ConnectionHandle) PURE;

    /*
     *  GCCError    ConfInviteResponse()
     *        This routine is invoked by node controller to respond to an
     *        invite indication.
     */
    STDMETHOD_(GCCError, ConfInviteResponse) (THIS_
                    GCCConfID,
                    GCCNumericString            conference_modifier,
                    BOOL                        fSecure,
                    DomainParameters           *domain_parameters,
                    UINT                        number_of_network_addresses,
                    GCCNetworkAddress         **local_network_address_list,
                    UINT                        number_of_user_data_members,
                    GCCUserData               **user_data_list,
                    GCCResult) PURE;

    /*
     *  GCCError    ConfAddResponse()
     */
    STDMETHOD_(GCCError, ConfAddResponse) (THIS_
                    GCCResponseTag              app_response_tag,
                    GCCConfID,
                    UserID                      requesting_node,
                    UINT                        number_of_user_data_members,
                    GCCUserData               **user_data_list,
                    GCCResult) PURE;

    /*
     *  GCCError    ConfLockResponse()
     *        This routine is invoked by node controller to respond to a
     *        lock indication.
     */
    STDMETHOD_(GCCError, ConfLockResponse) (THIS_
                    GCCConfID,
                    UserID                      requesting_node,
                    GCCResult) PURE;

    /*
     *  GCCError    ConfDisconnectRequest()
     *        This routine is used by a node controller to disconnect itself
     *        from a specified conference. GccConferenceDisconnectIndication
     *        sent to all other nodes of the conference. This is for client 
     *        initiated case.
     */
    STDMETHOD_(GCCError, ConfDisconnectRequest) (THIS_
                    GCCConfID) PURE;

    /*
     *  GCCError    ConfEjectUserRequest()
     */
    STDMETHOD_(GCCError, ConfEjectUserRequest) (THIS_
                    GCCConfID,
                    UserID                      ejected_node_id,
                    GCCReason) PURE;

    /*
     *  GCCError    AppletInvokeRequest()
     */
    STDMETHOD_(GCCError, AppletInvokeRequest) (THIS_
                    GCCConfID,
                    UINT                        number_of_app_protcol_entities,
                    GCCAppProtocolEntity      **app_protocol_entity_list,
                    UINT                        number_of_destination_nodes,
                    UserID                     *list_of_destination_nodes) PURE;

    /*
     *  GCCError    ConfRosterInqRequest()
     *        This routine is invoked to request a conference roster.  It can be
     *        called by either the Node Controller or the client application.
     */
    STDMETHOD_(GCCError, ConfRosterInqRequest) (THIS_
                    GCCConfID) PURE;

    /*
     *  GCCError    ConductorGiveResponse()
     */
    STDMETHOD_(GCCError, ConductorGiveResponse) (THIS_
                    GCCConfID,
                    GCCResult) PURE;

    /*
     *  GCCError    ConfTimeRemainingRequest()
     */
    STDMETHOD_(GCCError, ConfTimeRemainingRequest) (THIS_
                    GCCConfID,
                    UINT                        time_remaining,
                    UserID                      node_id) PURE;


    STDMETHOD_(GCCError, GetParentNodeID) (THIS_
                    GCCConfID,
                    GCCNodeID *) PURE;

#ifdef JASPER // ------------------------------------------------
    /*
     *  GCCError    ConfAddRequest()
     */
    STDMETHOD_(GCCError, ConfAddRequest) (THIS_
                    GCCConfID,
                    UINT                        number_of_network_addresses,
                    GCCNetworkAddress         **network_address_list,
                    UserID                      adding_node,
                    UINT                         number_of_user_data_members,
                    GCCUserData               **user_data_list) PURE;

    /*
     *  GCCError    ConfLockRequest()
     *        This routine is invoked by node controller to lock a conference.
     */
    STDMETHOD_(GCCError, ConfLockRequest) (THIS_
                    GCCConfID) PURE;

    /*
     *  GCCError    ConfUnlockRequest()
     *        This routine is invoked by node controller to unlock a conference.
     */
    STDMETHOD_(GCCError, ConfUnlockRequest) (THIS_
                    GCCConfID) PURE;

    /*
     *  GCCError    ConfUnlockResponse()
     *        This routine is invoked by node controller to respond to an
     *        unlock indication.
     */
    STDMETHOD_(GCCError, ConfUnlockResponse) (
                    GCCConfID,
                    UserID                      requesting_node,
                    GCCResult) PURE;

    /*
     *  GCCError    ConfTerminateRequest()
     */
    STDMETHOD_(GCCError, ConfTerminateRequest) (THIS_
                    GCCConfID,
                    GCCReason) PURE;

    /*
     *  GCCError    ConfTransferRequest()
     */
    STDMETHOD_(GCCError, ConfTransferRequest) (THIS_
                    GCCConfID,
                    GCCConferenceName          *destination_conference_name,
                    GCCNumericString            destination_conference_modifier,
                    UINT                        number_of_destination_addresses,
                    GCCNetworkAddress         **destination_address_list,
                    UINT                        number_of_destination_nodes,
                    UserID                     *destination_node_list,
                    GCCPassword                *password) PURE;

    /*
     *  GCCError    ConductorAssignRequest()
     */
    STDMETHOD_(GCCError, ConductorAssignRequest) (THIS_
                    GCCConfID) PURE;

    /*
     *  GCCError    ConductorReleaseRequest()
     */
    STDMETHOD_(GCCError, ConductorReleaseRequest) (THIS_
                    GCCConfID) PURE;

    /*
     *  GCCError    ConductorPleaseRequest()
     */
    STDMETHOD_(GCCError, ConductorPleaseRequest) (THIS_
                    GCCConfID) PURE;

    /*
     *  GCCError    ConductorGiveRequest()
     */
    STDMETHOD_(GCCError, ConductorGiveRequest) (THIS_
                    GCCConfID,
                    UserID                      recipient_user_id) PURE;

    /*
     *  GCCError    ConductorPermitAskRequest()
     */
    STDMETHOD_(GCCError, ConductorPermitAskRequest) (THIS_
                            GCCConfID,
                            BOOL                grant_permission) PURE;

    /*
     *  GCCError    ConductorPermitGrantRequest()
     */
    STDMETHOD_(GCCError, ConductorPermitGrantRequest) (THIS_
                    GCCConfID,
                    UINT                        number_granted,
                    UserID                     *granted_node_list,
                    UINT                        number_waiting,
                    UserID                     *waiting_node_list) PURE;

    /*
     *  GCCError    ConductorInquireRequest()
     */
    STDMETHOD_(GCCError, ConductorInquireRequest) (THIS_
                    GCCConfID) PURE;

    /*
     *  GCCError    ConfTimeInquireRequest()
     */
    STDMETHOD_(GCCError, ConfTimeInquireRequest) (THIS_
                    GCCConfID,
                    BOOL                        time_is_conference_wide) PURE;

    /*
     *  GCCError    ConfExtendRequest()
     */
    STDMETHOD_(GCCError, ConfExtendRequest) (THIS_
                    GCCConfID,
                    UINT                        extension_time,
                    BOOL                        time_is_conference_wide) PURE;

    /*
     *  GCCError    ConfAssistanceRequest()
     */
    STDMETHOD_(GCCError, ConfAssistanceRequest) (THIS_
                    GCCConfID,
                    UINT                        number_of_user_data_members,
                    GCCUserData               **user_data_list) PURE;

    /*
     *  GCCError    TextMessageRequest()
     */
    STDMETHOD_(GCCError, TextMessageRequest) (THIS_
                    GCCConfID,
                    LPWSTR                      pwszTextMsg,
                    UserID                      destination_node) PURE;
#endif // JASPER // ------------------------------------------------

};



//
// GCC Application Service Access Point exports
//

#ifdef __cplusplus
extern "C" {
#endif

GCCError WINAPI T120_CreateControlSAP(
                        OUT     IT120ControlSAP **,
                        IN      LPVOID, // user defined data
                        IN      LPFN_T120_CONTROL_SAP_CB);

#ifdef __cplusplus
}
#endif

#endif // _IGCCControlSAP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\h\t120\it120xprt.h ===
#ifndef _IT120_TRANSPORT_H_
#define _IT120_TRANSPORT_H_


#include <basetyps.h>
#include <t120type.h>


#define T120_CONNECTION_ID_LENGTH       64


typedef enum tagPLUGXPRT_PROTOCOL
{
    PLUGXPRT_PROTOCOL_X224          = 0,
}
    PLUGXPRT_PROTOCOL;


typedef enum tagPLUGXPRT_RESULT
{
    PLUGXPRT_RESULT_SUCCESSFUL      = 0,
    PLUGXPRT_RESULT_READ_FAILED     = 1,
    PLUGXPRT_RESULT_WRITE_FAILED    = 2,
    PLUGXPRT_RESULT_FAILED          = 3,
    PLUGXPRT_RESULT_ABANDONED       = 4,
}
    PLUGXPRT_RESULT;


typedef enum tagPLUGXPRT_STATE
{
    PLUGXPRT_UNKNOWN_STATE      = 0,
    PLUGXPRT_CONNECTING         = 1,
    PLUGXPRT_CONNECTED          = 2,
    PLUGXPRT_DISCONNECTING      = 3,
    PLUGXPRT_DISCONNECTED       = 4,
}
    PLUGXPRT_STATE;


typedef struct tagPLUGXPRT_MESSAGE
{
    PLUGXPRT_STATE          eState;
    LPVOID                  pContext;
    LPSTR                   pszConnID;
    PLUGXPRT_PROTOCOL       eProtocol;
    PLUGXPRT_RESULT         eResult;
}
    PLUGXPRT_MESSAGE;


typedef void (CALLBACK *LPFN_PLUGXPRT_CB) (PLUGXPRT_MESSAGE *);


#undef  INTERFACE
#define INTERFACE IT120PluggableTransport
DECLARE_INTERFACE(IT120PluggableTransport)
{
    STDMETHOD_(void, ReleaseInterface) (THIS) PURE;

    STDMETHOD_(T120Error, CreateConnection) (THIS_
                    char                szConnID[], /* out */
                    PLUGXPRT_CALL_TYPE  eCaller, // caller vs callee
                    HANDLE              hCommLink,
                    HANDLE              hevtDataAvailable,
                    HANDLE              hevtWriteReady,
                    HANDLE              hevtConnectionClosed,
                    PLUGXPRT_FRAMING    eFraming,
                    PLUGXPRT_PARAMETERS *pParams) PURE;

    STDMETHOD_(T120Error, UpdateConnection) (THIS_
                    LPSTR               pszConnID,
                    HANDLE              hCommLink) PURE;

    STDMETHOD_(T120Error, CloseConnection) (THIS_ LPSTR pszConnID) PURE; 

    STDMETHOD_(T120Error, EnableWinsock) (THIS) PURE; 

    STDMETHOD_(T120Error, DisableWinsock) (THIS) PURE; 

    STDMETHOD_(void, Advise) (THIS_ LPFN_PLUGXPRT_CB, LPVOID pContext) PURE;

    STDMETHOD_(void, UnAdvise) (THIS) PURE;

    STDMETHOD_(void, ResetConnCounter) (THIS) PURE;
};


#ifdef __cplusplus
extern "C" {
#endif

T120Error WINAPI T120_CreatePluggableTransport(IT120PluggableTransport **);

#ifdef __cplusplus
}
#endif


#endif // _IT120_TRANSPORT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\nmmkcert\global.h ===
#ifndef _MAKECERT_GLOBAL_H
#define _MAKECERT_GLOBAL_H

#include <windows.h>
#include <windowsx.h>
#include <objbase.h>
#include <wincrypt.h>

#include <nmutil.h>
#include <confdbg.h>
#include <strutil.h>
#include <regentry.h>
#include <confreg.h>
#include <nmmkcert.h>

#include "nmpvkhlp.h"
#include "resource.h"

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\h\t120\mcspdu.h ===
#ifndef _MCSPDU_Module_H_
#define _MCSPDU_Module_H_

#include "msper.h"

#ifdef __cplusplus
extern "C" {
#endif

typedef struct SetOfUserIDs * PSetOfUserIDs;

typedef struct SetOfPDUChannelAttributes * PSetOfPDUChannelAttributes;

typedef struct SetOfChannelIDs * PSetOfChannelIDs;

typedef struct SetOfPDUTokenAttributes * PSetOfPDUTokenAttributes;

typedef struct SetOfTokenIDs * PSetOfTokenIDs;

typedef ASN1uint16_t ChannelID;

typedef ChannelID StaticChannelID;

typedef ChannelID DynamicChannelID;

typedef DynamicChannelID UserID;

typedef DynamicChannelID PrivateChannelID;

typedef DynamicChannelID AssignedChannelID;

typedef ASN1uint16_t TokenID;

typedef enum PDUTokenStatus {
    not_in_use = 0,
    self_grabbed = 1,
    other_grabbed = 2,
    self_inhibited = 3,
    other_inhibited = 4,
    self_recipient = 5,
    self_giving = 6,
    other_giving = 7,
} PDUTokenStatus;

typedef enum PDUPriority {
    TOP_PRIORITY = 0,
    HIGH_PRIORITY = 1,
    MEDIUM_PRIORITY = 2,
    LOW_PRIORITY = 3,
} PDUPriority;

typedef ASN1uint8_t PDUSegmentation;
// #define begin 0x80
// #define end 0x40

typedef enum PDUReason {
    rn_domain_disconnected = 0,
    rn_provider_initiated = 1,
    rn_token_purged = 2,
    rn_user_requested = 3,
    rn_channel_purged = 4,
} PDUReason;

typedef enum PDUResult {
    rt_successful = 0,
    rt_domain_merging = 1,
    rt_domain_not_hierarchical = 2,
    rt_no_such_channel = 3,
    rt_no_such_domain = 4,
    rt_no_such_user = 5,
    rt_not_admitted = 6,
    rt_other_user_id = 7,
    rt_parameters_unacceptable = 8,
    rt_token_not_available = 9,
    rt_token_not_possessed = 10,
    rt_too_many_channels = 11,
    rt_too_many_tokens = 12,
    rt_too_many_users = 13,
    rt_unspecified_failure = 14,
    rt_user_rejected = 15,
} PDUResult;

typedef enum Diagnostic {
    dc_inconsistent_merge = 0,
    dc_forbidden_pdu_downward = 1,
    dc_forbidden_pdu_upward = 2,
    dc_invalid_ber_encoding = 3,
    dc_invalid_per_encoding = 4,
    dc_misrouted_user = 5,
    dc_unrequested_confirm = 6,
    dc_wrong_transport_priority = 7,
    dc_channel_id_conflict = 8,
    dc_token_id_conflict = 9,
    dc_not_user_id_channel = 10,
    dc_too_many_channels = 11,
    dc_too_many_tokens = 12,
    dc_too_many_users = 13,
} Diagnostic;

typedef struct Given {
    TokenID token_id;
    UserID recipient;
} Given;

typedef struct Ungivable {
    TokenID token_id;
    UserID grabber;
} Ungivable;

typedef struct Giving {
    TokenID token_id;
    UserID grabber;
    UserID recipient;
} Giving;

typedef struct Inhibited {
    TokenID token_id;
    PSetOfUserIDs inhibitors;
} Inhibited;

typedef struct Grabbed {
    TokenID token_id;
    UserID grabber;
} Grabbed;

typedef struct ChannelAttributesAssigned {
    AssignedChannelID channel_id;
} ChannelAttributesAssigned;

typedef struct ChannelAttributesPrivate {
    ASN1bool_t joined;
    PrivateChannelID channel_id;
    UserID manager;
    PSetOfUserIDs admitted;
} ChannelAttributesPrivate;

typedef struct ChannelAttributesUserID {
    ASN1bool_t joined;
    UserID user_id;
} ChannelAttributesUserID;

typedef struct ChannelAttributesStatic {
    StaticChannelID channel_id;
} ChannelAttributesStatic;

typedef struct PDUDomainParameters {
    ASN1uint32_t max_channel_ids;
    ASN1uint32_t max_user_ids;
    ASN1uint32_t max_token_ids;
    ASN1uint32_t number_priorities;
    ASN1uint32_t min_throughput;
    ASN1uint32_t max_height;
    ASN1uint32_t max_mcspdu_size;
    ASN1uint32_t protocol_version;
} PDUDomainParameters;

typedef struct ConnectInitialPDU {
    ASN1octetstring_t calling_domain_selector;
    ASN1octetstring_t called_domain_selector;
    ASN1bool_t upward_flag;
    PDUDomainParameters target_parameters;
    PDUDomainParameters minimum_parameters;
    PDUDomainParameters maximum_parameters;
    ASN1octetstring_t user_data;
} ConnectInitialPDU;

typedef struct ConnectResponsePDU {
    PDUResult result;
    ASN1uint32_t called_connect_id;
    PDUDomainParameters domain_parameters;
    ASN1octetstring_t user_data;
} ConnectResponsePDU;

typedef struct ConnectAdditionalPDU {
    ASN1uint32_t called_connect_id;
    PDUPriority data_priority;
} ConnectAdditionalPDU;

typedef struct ConnectResultPDU {
    PDUResult result;
} ConnectResultPDU;

typedef struct PlumbDomainIndicationPDU {
    ASN1uint32_t height_limit;
} PlumbDomainIndicationPDU;

typedef struct ErectDomainRequestPDU {
    UINT_PTR sub_height;
    ASN1uint32_t sub_interval;
} ErectDomainRequestPDU;

typedef struct PDUChannelAttributes {
    ASN1choice_t choice;
    union {
#	define channel_attributes_static_chosen 1
	ChannelAttributesStatic channel_attributes_static;
#	define channel_attributes_user_id_chosen 2
	ChannelAttributesUserID channel_attributes_user_id;
#	define channel_attributes_private_chosen 3
	ChannelAttributesPrivate channel_attributes_private;
#	define channel_attributes_assigned_chosen 4
	ChannelAttributesAssigned channel_attributes_assigned;
    } u;
} PDUChannelAttributes;

typedef struct MergeChannelsPDU {
    PSetOfPDUChannelAttributes merge_channels;
    PSetOfChannelIDs purge_channel_ids;
} MergeChannelsPDU;

typedef	MergeChannelsPDU			MergeChannelsRequestPDU;
typedef	MergeChannelsPDU			MergeChannelsConfirmPDU;

typedef struct PurgeChannelIndicationPDU {
    PSetOfUserIDs detach_user_ids;
    PSetOfChannelIDs purge_channel_ids;
} PurgeChannelIndicationPDU;

typedef struct PDUTokenAttributes {
    ASN1choice_t choice;
    union {
#	define grabbed_chosen 1
	Grabbed grabbed;
#	define inhibited_chosen 2
	Inhibited inhibited;
#	define giving_chosen 3
	Giving giving;
#	define ungivable_chosen 4
	Ungivable ungivable;
#	define given_chosen 5
	Given given;
    } u;
} PDUTokenAttributes;

typedef struct SetOfUserIDs {
    PSetOfUserIDs next;
    UserID value;
} SetOfUserIDs_Element;

typedef struct SetOfPDUChannelAttributes {
    PSetOfPDUChannelAttributes next;
    PDUChannelAttributes value;
} SetOfPDUChannelAttributes_Element;

typedef struct SetOfChannelIDs {
    PSetOfChannelIDs next;
    ChannelID value;
} SetOfChannelIDs_Element;

typedef struct SetOfPDUTokenAttributes {
    PSetOfPDUTokenAttributes next;
    PDUTokenAttributes value;
} SetOfPDUTokenAttributes_Element;

typedef struct SetOfTokenIDs {
    PSetOfTokenIDs next;
    TokenID value;
} SetOfTokenIDs_Element;

typedef struct MergeTokensPDU {
    PSetOfPDUTokenAttributes merge_tokens;
    PSetOfTokenIDs purge_token_ids;
} MergeTokensPDU;

typedef MergeTokensPDU			MergeTokensRequestPDU;
typedef MergeTokensPDU			MergeTokensConfirmPDU;

typedef struct PurgeTokenIndicationPDU {
    PSetOfTokenIDs purge_token_ids;
} PurgeTokenIndicationPDU;

typedef struct DisconnectProviderUltimatumPDU {
    PDUReason reason;
} DisconnectProviderUltimatumPDU;

typedef struct RejectUltimatumPDU {
    Diagnostic diagnostic;
    ASN1octetstring_t initial_octets;
} RejectUltimatumPDU;

typedef struct AttachUserRequestPDU {
    char placeholder;
} AttachUserRequestPDU;

typedef struct AttachUserConfirmPDU {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    PDUResult result;
#   define initiator_present 0x80
    UserID initiator;
} AttachUserConfirmPDU;

typedef struct DetachUserRequestPDU {
    PDUReason reason;
    PSetOfUserIDs user_ids;
} DetachUserPDU;

typedef DetachUserPDU		DetachUserRequestPDU;
typedef DetachUserPDU		DetachUserIndicationPDU;

typedef struct ChannelJoinRequestPDU {
    UserID initiator;
    ChannelID channel_id;
} ChannelJoinRequestPDU;

typedef struct ChannelJoinConfirmPDU {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    PDUResult result;
    UserID initiator;
    ChannelID requested;
#   define join_channel_id_present 0x80
    ChannelID join_channel_id;
} ChannelJoinConfirmPDU;

typedef struct ChannelLeaveRequestPDU {
    PSetOfChannelIDs channel_ids;
} ChannelLeaveRequestPDU;

typedef struct ChannelConveneRequestPDU {
    UserID initiator;
} ChannelConveneRequestPDU;

typedef struct ChannelConveneConfirmPDU {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    PDUResult result;
    UserID initiator;
#   define convene_channel_id_present 0x80
    PrivateChannelID convene_channel_id;
} ChannelConveneConfirmPDU;

typedef struct ChannelDisbandRequestPDU {
    UserID initiator;
    PrivateChannelID channel_id;
} ChannelDisbandRequestPDU;

typedef struct ChannelDisbandIndicationPDU {
    PrivateChannelID channel_id;
} ChannelDisbandIndicationPDU;

typedef struct ChannelAdmitRequestPDU {
    UserID initiator;
    PrivateChannelID channel_id;
    PSetOfUserIDs user_ids;
} ChannelAdmitExpelPDU;

typedef ChannelAdmitExpelPDU		ChannelAdmitRequestPDU;
typedef ChannelAdmitExpelPDU		ChannelAdmitIndicationPDU;
typedef ChannelAdmitExpelPDU		ChannelExpelRequestPDU;

typedef struct ChannelExpelIndicationPDU {
    PrivateChannelID channel_id;
    PSetOfUserIDs user_ids;
} ChannelExpelIndicationPDU;

typedef struct SendDataRequestPDU {
    UserID initiator;
    ChannelID channel_id;
    PDUPriority data_priority;
    PDUSegmentation segmentation;
    ASN1octetstring_t user_data;
} SendDataRequestPDU;

typedef struct SendDataIndicationPDU {
    UserID initiator;
    ChannelID channel_id;
    PDUPriority data_priority;
    PDUSegmentation segmentation;
    ASN1octetstring_t user_data;
} SendDataIndicationPDU;

typedef struct UniformSendDataRequestPDU {
    UserID initiator;
    ChannelID channel_id;
    PDUPriority data_priority;
    PDUSegmentation segmentation;
    ASN1octetstring_t user_data;
} UniformSendDataRequestPDU;

typedef struct UniformSendDataIndicationPDU {
    UserID initiator;
    ChannelID channel_id;
    PDUPriority data_priority;
    PDUSegmentation segmentation;
    ASN1octetstring_t user_data;
} UniformSendDataIndicationPDU;

typedef struct TokenGrabRequestPDU {
    UserID initiator;
    TokenID token_id;
} TokenGrabRequestPDU;

typedef struct TokenGrabConfirmPDU {
    PDUResult result;
    UserID initiator;
    TokenID token_id;
    PDUTokenStatus token_status;
} TokenGrabConfirmPDU;

typedef struct TokenInhibitRequestPDU {
    UserID initiator;
    TokenID token_id;
} TokenInhibitRequestPDU;

typedef struct TokenInhibitConfirmPDU {
    PDUResult result;
    UserID initiator;
    TokenID token_id;
    PDUTokenStatus token_status;
} TokenInhibitConfirmPDU;

typedef struct TokenGiveRequestPDU {
    UserID initiator;
    TokenID token_id;
    UserID recipient;
} TokenGiveRequestPDU;

typedef struct TokenGiveIndicationPDU {
    UserID initiator;
    TokenID token_id;
    UserID recipient;
} TokenGiveIndicationPDU;

typedef struct TokenGiveResponsePDU {
    PDUResult result;
    UserID recipient;
    TokenID token_id;
} TokenGiveResponsePDU;

typedef struct TokenGiveConfirmPDU {
    PDUResult result;
    UserID initiator;
    TokenID token_id;
    PDUTokenStatus token_status;
} TokenGiveConfirmPDU;

typedef struct TokenPleaseRequestPDU {
    UserID initiator;
    TokenID token_id;
} TokenPleaseRequestPDU;

typedef struct TokenPleaseIndicationPDU {
    UserID initiator;
    TokenID token_id;
} TokenPleaseIndicationPDU;

typedef struct TokenReleaseRequestPDU {
    UserID initiator;
    TokenID token_id;
} TokenReleaseRequestPDU;

typedef struct TokenReleaseConfirmPDU {
    PDUResult result;
    UserID initiator;
    TokenID token_id;
    PDUTokenStatus token_status;
} TokenReleaseConfirmPDU;

typedef struct TokenTestRequestPDU {
    UserID initiator;
    TokenID token_id;
} TokenTestRequestPDU;

typedef struct TokenTestConfirmPDU {
    UserID initiator;
    TokenID token_id;
    PDUTokenStatus token_status;
} TokenTestConfirmPDU;

typedef struct ConnectMCSPDU {
    ASN1choice_t choice;
    union {
#	define connect_initial_chosen 1
	ConnectInitialPDU connect_initial;
#	define connect_response_chosen 2
	ConnectResponsePDU connect_response;
#	define connect_additional_chosen 3
	ConnectAdditionalPDU connect_additional;
#	define connect_result_chosen 4
	ConnectResultPDU connect_result;
    } u;
} ConnectMCSPDU;
#define ConnectMCSPDU_PDU 0
#define SIZE_MCSPDU_Module_PDU_0 sizeof(ConnectMCSPDU)

typedef struct DomainMCSPDU {
    ASN1choice_t choice;
    union {
#	define plumb_domain_indication_chosen 1
	PlumbDomainIndicationPDU plumb_domain_indication;
#	define erect_domain_request_chosen 2
	ErectDomainRequestPDU erect_domain_request;
#	define merge_channels_request_chosen 3
	MergeChannelsRequestPDU merge_channels_request;
#	define merge_channels_confirm_chosen 4
	MergeChannelsConfirmPDU merge_channels_confirm;
#	define purge_channel_indication_chosen 5
	PurgeChannelIndicationPDU purge_channel_indication;
#	define merge_tokens_request_chosen 6
	MergeTokensRequestPDU merge_tokens_request;
#	define merge_tokens_confirm_chosen 7
	MergeTokensConfirmPDU merge_tokens_confirm;
#	define purge_token_indication_chosen 8
	PurgeTokenIndicationPDU purge_token_indication;
#	define disconnect_provider_ultimatum_chosen 9
	DisconnectProviderUltimatumPDU disconnect_provider_ultimatum;
#	define reject_user_ultimatum_chosen 10
	RejectUltimatumPDU reject_user_ultimatum;
#	define attach_user_request_chosen 11
	AttachUserRequestPDU attach_user_request;
#	define attach_user_confirm_chosen 12
	AttachUserConfirmPDU attach_user_confirm;
#	define detach_user_request_chosen 13
	DetachUserRequestPDU detach_user_request;
#	define detach_user_indication_chosen 14
	DetachUserIndicationPDU detach_user_indication;
#	define channel_join_request_chosen 15
	ChannelJoinRequestPDU channel_join_request;
#	define channel_join_confirm_chosen 16
	ChannelJoinConfirmPDU channel_join_confirm;
#	define channel_leave_request_chosen 17
	ChannelLeaveRequestPDU channel_leave_request;
#	define channel_convene_request_chosen 18
	ChannelConveneRequestPDU channel_convene_request;
#	define channel_convene_confirm_chosen 19
	ChannelConveneConfirmPDU channel_convene_confirm;
#	define channel_disband_request_chosen 20
	ChannelDisbandRequestPDU channel_disband_request;
#	define channel_disband_indication_chosen 21
	ChannelDisbandIndicationPDU channel_disband_indication;
#	define channel_admit_request_chosen 22
	ChannelAdmitRequestPDU channel_admit_request;
#	define channel_admit_indication_chosen 23
	ChannelAdmitIndicationPDU channel_admit_indication;
#	define channel_expel_request_chosen 24
	ChannelExpelRequestPDU channel_expel_request;
#	define channel_expel_indication_chosen 25
	ChannelExpelIndicationPDU channel_expel_indication;
#	define send_data_request_chosen 26
	SendDataRequestPDU send_data_request;
#	define send_data_indication_chosen 27
	SendDataIndicationPDU send_data_indication;
#	define uniform_send_data_request_chosen 28
	UniformSendDataRequestPDU uniform_send_data_request;
#	define uniform_send_data_indication_chosen 29
	UniformSendDataIndicationPDU uniform_send_data_indication;
#	define token_grab_request_chosen 30
	TokenGrabRequestPDU token_grab_request;
#	define token_grab_confirm_chosen 31
	TokenGrabConfirmPDU token_grab_confirm;
#	define token_inhibit_request_chosen 32
	TokenInhibitRequestPDU token_inhibit_request;
#	define token_inhibit_confirm_chosen 33
	TokenInhibitConfirmPDU token_inhibit_confirm;
#	define token_give_request_chosen 34
	TokenGiveRequestPDU token_give_request;
#	define token_give_indication_chosen 35
	TokenGiveIndicationPDU token_give_indication;
#	define token_give_response_chosen 36
	TokenGiveResponsePDU token_give_response;
#	define token_give_confirm_chosen 37
	TokenGiveConfirmPDU token_give_confirm;
#	define token_please_request_chosen 38
	TokenPleaseRequestPDU token_please_request;
#	define token_please_indication_chosen 39
	TokenPleaseIndicationPDU token_please_indication;
#	define token_release_request_chosen 40
	TokenReleaseRequestPDU token_release_request;
#	define token_release_confirm_chosen 41
	TokenReleaseConfirmPDU token_release_confirm;
#	define token_test_request_chosen 42
	TokenTestRequestPDU token_test_request;
#	define token_test_confirm_chosen 43
	TokenTestConfirmPDU token_test_confirm;
    } u;
} DomainMCSPDU;
#define DomainMCSPDU_PDU 1
#define SIZE_MCSPDU_Module_PDU_1 sizeof(DomainMCSPDU)

extern ASN1module_t MCSPDU_Module;
extern void ASN1CALL MCSPDU_Module_Startup(void);
extern void ASN1CALL MCSPDU_Module_Cleanup(void);

/* Prototypes of element functions for SEQUENCE OF and SET OF constructs */
    extern int ASN1CALL ASN1Enc_SetOfUserIDs_ElmFn(ASN1encoding_t enc, PSetOfUserIDs val);
    extern int ASN1CALL ASN1Dec_SetOfUserIDs_ElmFn(ASN1decoding_t dec, PSetOfUserIDs val);
    extern void ASN1CALL ASN1Free_SetOfUserIDs_ElmFn(PSetOfUserIDs val);
    extern int ASN1CALL ASN1Enc_SetOfPDUChannelAttributes_ElmFn(ASN1encoding_t enc, PSetOfPDUChannelAttributes val);
    extern int ASN1CALL ASN1Dec_SetOfPDUChannelAttributes_ElmFn(ASN1decoding_t dec, PSetOfPDUChannelAttributes val);
    extern void ASN1CALL ASN1Free_SetOfPDUChannelAttributes_ElmFn(PSetOfPDUChannelAttributes val);
    extern int ASN1CALL ASN1Enc_SetOfChannelIDs_ElmFn(ASN1encoding_t enc, PSetOfChannelIDs val);
    extern int ASN1CALL ASN1Dec_SetOfChannelIDs_ElmFn(ASN1decoding_t dec, PSetOfChannelIDs val);
    extern void ASN1CALL ASN1Free_SetOfChannelIDs_ElmFn(PSetOfChannelIDs val);
    extern int ASN1CALL ASN1Enc_SetOfPDUTokenAttributes_ElmFn(ASN1encoding_t enc, PSetOfPDUTokenAttributes val);
    extern int ASN1CALL ASN1Dec_SetOfPDUTokenAttributes_ElmFn(ASN1decoding_t dec, PSetOfPDUTokenAttributes val);
    extern void ASN1CALL ASN1Free_SetOfPDUTokenAttributes_ElmFn(PSetOfPDUTokenAttributes val);
    extern int ASN1CALL ASN1Enc_SetOfTokenIDs_ElmFn(ASN1encoding_t enc, PSetOfTokenIDs val);
    extern int ASN1CALL ASN1Dec_SetOfTokenIDs_ElmFn(ASN1decoding_t dec, PSetOfTokenIDs val);
    extern void ASN1CALL ASN1Free_SetOfTokenIDs_ElmFn(PSetOfTokenIDs val);

#ifdef __cplusplus
} /* extern "C" */
#endif

#endif /* _MCSPDU_Module_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\h\t120\mcatmcs.h ===
/*
 *	mcatmcs.h
 *
 *	Copyright (c) 1993 - 1995 by DataBeam Corporation, Lexington, KY
 *
 *	Abstract:
 *		This is the interface file for the MCS DLL.  This file defines all
 *		macros, types, and functions needed to use the MCS DLL, allowing MCS
 *		services to be accessed from user applications.
 *
 *		Basically, an application requests services from MCS by making direct
 *		calls into the DLL (this includes T.122 requests and responses).  MCS
 *		sends information back to the application through a callback (this
 *		includes T.122 indications and confirms).  The callback 
 *		for a particular user attachment is specified in the call
 *		MCS_AttachRequest.
 *
 *		Note that this is a "C" language interface in order to prevent any "C++"
 *		naming conflicts between different compiler manufacturers.  Therefore,
 *		if this file is included in a module that is being compiled with a "C++"
 *		compiler, it is necessary to use the following syntax:
 *
 *		extern "C"
 *		{
 *		#include "mcatmcs.h"
 *		}
 *
 *		This disables C++ name mangling on the API entry points defined within
 *		this file.
 *
 *	Author:
 *		James P. Galvin, Jr.
 */
#ifndef	__MCATMCS_H__
#define	__MCATMCS_H__

#include "databeam.h"
#include "mcspdu.h"
#include <t120type.h>

/*
 *	The following definitions are used to identify various parameters within
 *	MCS, and are part of the MCS protocol definition.
 *
 *	Priority
 *		MCS specifies the use of up to four levels of priority.  An application
 *		should NOT use TOP_PRIORITY (this level is reserved for MCS traffic).
 *	Segmentation
 *		This type is used when specifying whether a given data indication is the
 *		first or last one in a user data block (or both or neither).
 *	TokenStatus
 *		This type is returned when testing the current state of a token.
 *	Reason
 *		When MCS issues an indication to a user application, it often includes a
 *		reason parameter informing the user of why the activity is occurring.
 *	Result
 *		When a user makes a request of MCS, MCS often responds with a result,
 *		letting the user know whether or not the request succeeded.
 */

typedef PDUPriority				Priority;
typedef	PDUSegmentation			Segmentation;

typedef	Priority  *				PPriority;
typedef	Segmentation  *			PSegmentation;

#define	SEGMENTATION_BEGIN			0x80
#define	SEGMENTATION_END			0x40


/*
 *	The following type is used to indicate what merge state the local provider
 *	is in.  Note that this is a local implementation feature that is not part
 *	of the standard MCS definition.
 *
 *	Whenever the former Top Provider of a domain enters the domain merge state,
 *	it indicates this to all applications locally attached to that domain by
 *	sending an MCS_MERGE_DOMAIN_INDICATION.  This type (MergeStatus) is the
 *	parameter to that call.  It will be called twice, the first time indicating
 *	that the domain is entering the merge state.  The second time indicates that
 *	the domain merger is complete.
 *
 *	All T.122 primitives (requests and responses) will be rejected during the
 *	time that the domain merger is in progress.  It is the repsonsibility of
 *	the user application to re-try the primitive once the merge is complete.
 */
typedef	unsigned short			MergeStatus;
typedef	MergeStatus  *			PMergeStatus;

#define	MERGE_DOMAIN_IN_PROGRESS	0
#define	MERGE_DOMAIN_COMPLETE		1

/*
 *	This type is the signature of an MCS call back function.  MCS uses this
 *	function to let the application know when an event occurs.
 *
 *	Note that an MCS callback routine needs to return a value to MCS.  This
 *	value should either be MCS_NO_ERROR if the callback was successfully
 *	processed, or MCS_CALLBACK_NOT_PROCESSED if the callback was not processed.
 *	In the latter case, MCS will hold on to the information contained in the
 *	callback message, so that it can try issuing the same callback during the
 *	next time slice.  It will keep retrying until the user application accepts
 *	the callback message (by returning MCS_NO_ERROR).  This is how flow control
 *	works for information flowing upward from MCS to the application.
 */
typedef	void (CALLBACK *MCSCallBack) (UINT, LPARAM, LPVOID);

/*
typedef	struct
{
	ChannelID			channel_id;
	Priority			priority;
	UserID				sender_id;
	Segmentation		segmentation;
	unsigned char  *	user_data;
	unsigned long		user_data_length;
} SendData;
*/
typedef SendDataRequestPDU				SendData;
typedef	SendData  *						PSendData;

// This constant defines the maximum MCS PDU size for applications
#define MAX_MCS_DATA_SIZE	4096

/*
 *	This section defines the messages that can be sent to the application
 *	through the callback facility.  These messages correspond to the indications
 *	and confirms that are defined within T.122.
 */
typedef T120MessageType  MCSMessageType;


/*
 *	The following declaration defines the flags that can be set when 
 *	calling MCSSendDataRequest.
 */
typedef enum {
	APP_ALLOCATION,
	MCS_ALLOCATION
} SendDataFlags, *PSendDataFlags;


/*
 *	The following type defines whether the SendDataRequest
 *	is a normal send or a uniform send.
 */
typedef enum {
	NORMAL_SEND_DATA,
	UNIFORM_SEND_DATA
} DataRequestType, *PDataRequestType;

typedef enum
{
	TOP_PRIORITY_MASK		=0x0001,
	HIGH_PRIORITY_MASK		=0x0002,
	LOW_MEDIUM_MASK			=0x0004,
	LOW_PRIORITY_MASK		=0x0008,
	UNIFORM_SEND_DATA_MASK	=0x0010,
	NORMAL_SEND_DATA_MASK	=0x0020,
	MCS_ALLOCATION_MASK		=0x0040,
	APP_ALLOCATION_MASK		=0x0080
} MCSSenDataMasks;



#endif // __MCATMCS_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\h\t120\t120type.h ===
#ifndef _T120_TYPE_H_
#define  _T120_TYPE_H_

#include <nmapptyp.h>

/*
 *	This is a list of types that are used extensively throughout MCS.  For
 *	each type there is also a pointer to that type defined, which has a "P"
 *	prefix.  These types are described as follows:
 *
 *	DomainSelector - This is a string of bytes that acts as the name of a given
 *		domain.  It is used when creating a new domain, as well as in accessing
 *		that domain after creation.  The length of the string is specified with
 *		a separate parameter, and the string CAN contain embedded zeroes.
 *	ConnectionHandle - When a user application connects two domains using
 *		MCSConnectProviderRequest, a ConnectionHandle is assigned to that MCS
 *		connection.  This allows more direct access to it for further services.
 *	ConnectID - This type is used only during MCS connection establishment.
 *		It identifies a particular transport connection for the purpose of
 *		adding multiple data priorities on the same MCS connection.
 *	ChannelID - This type identifies an MCS channel.  There are four different
 *		types of channels that are part of this type: user ID; static; private;
 *		and assigned.
 *	UserID - This is a special channel that identifies a particular user in an
 *		MCS domain.  Only that user can join the channel, so this is referred
 *		to as a single-cast channel.  All other channels are multi-cast, meaning
 *		that any number of users can join them at once.
 *	TokenID - This is an MCS object that is used to resolve resource conflicts.
 *		If an application has a particular resource or service that can only
 *		be used by one user at a time, that user can request exclusive ownership
 *		of a token.
 */
// ushort
typedef AppletSessionID     T120SessionID, GCCSessionID, *PGCCSessionID;
typedef	AppletChannelID     T120ChannelID, ChannelID, *PChannelID;
typedef	AppletUserID        T120UserID, UserID, *PUserID, GCCUserID, *PGCCUserID;
typedef	AppletTokenID       T120TokenID, TokenID, *PTokenID;
typedef AppletNodeID        T120NodeID, GCCNodeID, *PGCCNodeID;
typedef AppletEntityID      T120EntityID, GCCEntityID, *PGCCEntityID;
// ulong
typedef AppletConfID        T120ConfID, GCCConferenceID, GCCConfID, *PGCCConferenceID, *PGCCConfID;
// uint
typedef AppletRequestTag    T120RequestTag, GCCRequestTag, *PGCCRequestTag;
typedef AppletRequestTag    T120ResponseTag, GCCResponseTag, *PGCCResponseTag;
// enum
typedef AppletPriority      T120Priority;


typedef	LPBYTE          DomainSelector, *PDomainSelector;
typedef	USHORT          ConnectionHandle, *PConnectionHandle;
typedef	USHORT          ConnectID, *PConnectID;


#define GCC_INVALID_EID     0   // invalid entity id
#define GCC_INVALID_UID     0   // invalid user id
#define GCC_INVALID_NID     0   // invalid node id
#define GCC_INVALID_CID     0   // invalid conference id
#define GCC_INVALID_TID     0   // invalid token id
#define GCC_INVALID_TAG     0   // invalid request id




/*
 *	This section defines the valid return values from GCC function calls.  Do
 *	not confuse this return value with the Result and Reason values defined
 *	by T.124 (which are discussed later).  These values are returned directly
 *	from the call to the API entry point, letting you know whether or not the
 *	request for service was successfully invoked.  The Result and Reason
 *	codes are issued as part of an indication or confirm which occurs
 *	asynchronously to the call that causes it.
 *
 *	All GCC function calls return type GCCError.  Its valid values are as
 *	follows:
 *
 *	GCC_NO_ERROR
 *		This means that the request was successfully invoked.  It does NOT
 *		mean that the service has been successfully completed.  Remember that
 *		all GCC calls are non-blocking.  This means that each request call
 *		begins the process, and if necessary, a subsequent indication or
 *		confirm will result.  By convention, if ANY GCC call returns a value
 *		other than this, something went wrong.  Note that this value should
 *		also be returned to GCC during a callback if the application processes
 *		the callback successfully.
 *
 *	GCC_NOT_INITIALIZED
 *		The application has attempted to use GCC services before GCC has been
 *		initialized.  It is necessary for the node controller (or whatever
 *		application is serving as the node controller), to initialize GCC before
 *		it is called upon to perform any services.
 *
 *	GCC_ALREADY_INITIALIZED
 *		The application has attempted to initialize GCC when it is already
 *		initialized.
 *
 *	GCC_ALLOCATION_FAILURE
 *		This indicates a fatal resource error inside GCC.  It usually results
 *		in the automatic termination of the affected conference.
 *
 *	GCC_NO_SUCH_APPLICATION	
 *		This indicates that the Application SAP handle passed in was invalid.
 *
 *	GCC_INVALID_CONFERENCE
 *		This indicates that an illegal conference ID was passed in.
 *
 *	GCC_CONFERENCE_ALREADY_EXISTS
 *		The Conference specified in the request or response is already in
 *		existence.
 *
 *	GCC_NO_TRANSPORT_STACKS
 *		This indicates that MCS failed to load the TCP transport stack during
 *		initialization.  This is now an error.  MCS exits when this happens and
 *		can not be used any more, since NetMeeting is now a TCP-only
 *		product.
 *
 *	GCC_INVALID_ADDRESS_PREFIX
 *		The called address parameter in a request such as 
 *		GCCConferenceCreateRequest does not	contain a recognized prefix.  MCS 
 *		relies on the prefix to know which transport stack to invoke.
 *
 *	GCC_INVALID_TRANSPORT
 *		The dynamic load of a transport stack failed either because the DLL
 *		could not be found, or because it did not export at least one entry
 *		point that MCS requires.
 *
 *	GCC_FAILURE_CREATING_PACKET
 *		This is a FATAL error which means that for some reason the 
 *		communications packet generated due to a request could not be created.
 *		This typically flags a problem with the ASN.1 toolkit.
 *
 *	GCC_QUERY_REQUEST_OUTSTANDING
 *		This error indicates that all the domains that set aside for querying
 *		are used up by other outstanding query request.
 *
 *	GCC_INVALID_QUERY_TAG
 *		The query response tag specified in the query response is not valid.
 *
 *	GCC_FAILURE_CREATING_DOMAIN
 *		Many requests such as GCCConferenceCreateRequest require that an MCS
 *		domain be created.  If the request to MCS fails this will be returned.
 *
 *	GCC_CONFERENCE_NOT_ESTABLISHED
 *		If a request is made to a conference before it is established, this
 *		error value will be returned.
 *
 *	GCC_INVALID_PASSWORD
 *		The password passed in the request is not valid.  This usually means
 *		that a numeric string needs to be specified.
 *		
 *	GCC_INVALID_MCS_USER_ID
 *		All MCS User IDs must have a value greater than 1000.
 *
 *	GCC_INVALID_JOIN_RESPONSE_TAG
 *		The join response tag specified in the join response is not valid.
 *	
 *	GCC_TRANSPORT_NOT_READY
 *		Request was made to a transport before it was ready to process it.
 *
 *	GCC_DOMAIN_PARAMETERS_UNACCEPTABLE
 *		The specified domain parameters do not fit within the range allowable
 *		by GCC and MCS.
 *
 *	GCC_APP_NOT_ENROLLED
 *		Occurs if a request is made by an Application Protocol Entity to a
 *		conference before the "APE" is enrolled.
 *
 *	GCC_NO_GIVE_RESPONSE_PENDING
 *		This will occur if a conductor Give Request is issued before a 
 *		previously pending conductor Give Response has been processed.
 *
 *	GCC_BAD_NETWORK_ADDRESS_TYPE
 *		An illegal network address type was passed in.  Valid types are	
 *		GCC_AGGREGATED_CHANNEL_ADDRESS, GCC_TRANSPORT_CONNECTION_ADDRESS and
 *		GCC_NONSTANDARD_NETWORK_ADDRESS.
 *
 *	GCC_BAD_OBJECT_KEY
 *		The object key passed in is invalid.
 *
 *	GCC_INVALID_CONFERENCE_NAME
 *		The conference name passed in is not a valid conference name.
 *
 *	GCC_INVALID_CONFERENCE_MODIFIER
 *		The conference modifier passed in is not a valid conference name.
 *
 *	GCC_BAD_SESSION_KEY
 *		The session key passed in was not valid.
 *				  
 *	GCC_BAD_CAPABILITY_ID
 *		The capability ID passed into the request is not valid.
 *
 *	GCC_BAD_REGISTRY_KEY
 *		The registry key passed into the request is not valid.
 *
 *	GCC_BAD_NUMBER_OF_APES
 *		Zero was passed in for the number of APEs in the invoke request. Zero
 *		is illegal here.
 *
 *	GCC_BAD_NUMBER_OF_HANDLES
 *		A number < 1 or	> 1024 was passed into the allocate handle request.
 *		  
 *	GCC_ALREADY_REGISTERED
 *		The user application attempting to register itself has already 
 *		registered.
 *			  
 *	GCC_APPLICATION_NOT_REGISTERED	  
 *		The user application attempting to make a request to GCC has not 
 *		registered itself with GCC.
 *
 *	GCC_BAD_CONNECTION_HANDLE_POINTER
 *		A NULL connection handle pointer was passed in.
 * 
 *	GCC_INVALID_NODE_TYPE
 *		A node type value other than GCC_TERMINAL, GCC_MULTIPORT_TERMINAL or
 *		GCC_MCU was passed in.
 *
 *	GCC_INVALID_ASYMMETRY_INDICATOR
 *		An asymetry type other than GCC_ASYMMETRY_CALLER, GCC_ASYMMETRY_CALLED
 *		or GCC_ASYMMETRY_UNKNOWN was passed into the request.
 *	
 *	GCC_INVALID_NODE_PROPERTIES
 *		A node property other than GCC_PERIPHERAL_DEVICE, GCC_MANAGEMENT_DEVICE,
 *		GCC_PERIPHERAL_AND_MANAGEMENT_DEVICE or	
 *		GCC_NEITHER_PERIPHERAL_NOR_MANAGEMENT was passed into the request.
 *		
 *	GCC_BAD_USER_DATA
 *		The user data list passed into the request was not valid.
 *				  
 *	GCC_BAD_NETWORK_ADDRESS
 *		There was something wrong with the actual network address portion of
 *		the passed in network address.
 *
 *	GCC_INVALID_ADD_RESPONSE_TAG
 *		The add response tag passed in the response does not match any add
 *		response tag passed back in the add indication.
 *			  
 *	GCC_BAD_ADDING_NODE
 *		You can not request that the adding node be the node where the add
 *		request is being issued.
 *				  
 *	GCC_FAILURE_ATTACHING_TO_MCS
 *		Request failed because GCC could not create a user attachment to MCS.
 *	  
 *	GCC_INVALID_TRANSPORT_ADDRESS	  
 *		The transport address specified in the request (usually the called
 *		address) is not valid.  This will occur when the transport stack
 *		detects an illegal transport address.
 *
 *	GCC_INVALID_PARAMETER
 *		This indicates an illegal parameter is passed into the GCC function
 *		call.
 *
 *	GCC_COMMAND_NOT_SUPPORTED
 *		This indicates that the user application has attempted to invoke an
 *		GCC service that is not yet supported.
 *
 *	GCC_UNSUPPORTED_ERROR
 *		An error was returned from a request to MCS that is not recognized 
 *		by GCC.
 *
 *	GCC_TRANSMIT_BUFFER_FULL
 *		Request can not be processed because the transmit buffer is full.
 *		This usually indicates a problem with the shared memory portal in the
 *		Win32 client.
 *		
 *	GCC_INVALID_CHANNEL
 *		The channel ID passed into the request is not a valid MCS channel ID
 *		(zero is not valid).
 *
 *	GCC_INVALID_MODIFICATION_RIGHTS
 *		The modification rights passed in in not one of the enumerated types
 *		supported.
 *
 *	GCC_INVALID_REGISTRY_ITEM
 *		The registry item passed in is not one of the valid enumerated types.
 *
 *	GCC_INVALID_NODE_NAME
 *		The node name passed in is not valid.  Typically this means that it
 *		is to long.
 *
 *	GCC_INVALID_PARTICIPANT_NAME
 *		The participant name passed in is not valid.  Typically this means that 
 *		it is to long.
 *		
 *	GCC_INVALID_SITE_INFORMATION
 *		The site information passed in is not valid.  Typically this means that 
 *		it is to long.
 *
 *	GCC_INVALID_NON_COLLAPSED_CAP
 *		The non-collapsed capability passed in is not valid.  Typically this 
 *		means that it is to long.
 *
 *	GCC_INVALID_ALTERNATIVE_NODE_ID
 *		Alternative node IDs can only be two characters long.
 */


/*
 *	This section defines the valid return values from MCS function calls.  Do
 *	not confuse this return value with the Result and Reason values defined
 *	by T.125 (which are discussed later).  These values are returned directly
 *	from the call to the API entry point, letting you know whether or not the
 *	request for service was successfully invoked.  The Result and Reason
 *	codes are issued as part of an indication or confirm which occurs
 *	asynchronously to the call that causes it.
 *
 *	All MCS function calls return type MCSError.  Its valid values are as
 *	follows:
 *
 *	MCS_NO_ERROR
 *		This means that the request was successfully invoked.  It does NOT
 *		mean that the service has been successfully completed.  Remember that
 *		all MCS calls are non-blocking.  This means that each request call
 *		begins the process, and if necessary, a subsequent indication or
 *		confirm will result.  By convention, if ANY MCS call returns a value
 *		other than this, something went wrong.  Note that this value should
 *		also be returned to MCS during a callback if the application processes
 *		the callback successfully.
 *	MCS_COMMAND_NOT_SUPPORTED
 *		This indicates that the user application has attempted to invoke an
 *		MCS service that is not yet supported.  Note that this return value
 *		will NEVER be returned from the release version of MCS, and is left
 *		defined only for backward compatibility.  It WILL be removed in a future
 *		version of MCS.
 *	MCS_NOT_INITIALIZED
 *		The application has attempted to use MCS services before MCS has been
 *		initialized.  It is necessary for the node controller (or whatever
 *		application is serving as the node controller), to initialize MCS before
 *		it is called upon to perform any services.
 *	MCS_ALREADY_INITIALIZED
 *		The application has attempted to initialize MCS when it is already
 *		initialized.
 *	MCS_NO_TRANSPORT_STACKS
 *		This indicates that MCS did not load the TCP transport stack during
 *		initialization.  This is now considered an error.  MCS can not
 *		be used in a local only manner.  We no longer load other ransport stacks can also be loaded
 *		after initialization using the call MCSLoadTransport.  Note that when
 *		getting this return code during initialization, it IS necessary for the
 *		node controller to cleanly shut down MCS.
 *	MCS_DOMAIN_ALREADY_EXISTS
 *		The application has attempted to create a domain that already exists.
 *	MCS_NO_SUCH_DOMAIN
 *		The application has attempted to use a domain that has not yet been
 *		created.
 *	MCS_USER_NOT_ATTACHED
 *		This indicates that the application has issued an MCS_AttachRequest,
 *		and then tried to use the returned handle before receiving an
 *		MCS_ATTACH_USER_CONFIRM (which essentially validates the handle).
 *	MCS_NO_SUCH_USER
 *		An MCS primitive has been invoked with an unknown user handle.
 *	MCS_TRANSMIT_BUFFER_FULL
 *		This indicates that the call failed due to an MCS resource shortage.
 *		This will typically occur when there is a LOT of traffic through the
 *		MCS layer.  It simply means that MCS could not process the request at
 *		this time.  It is the responsibility of the application to retry at a
 *		later time.
 *	MCS_NO_SUCH_CONNECTION
 *		An MCS primitive has been invoked with an unknown connection handle.
 *	MCS_DOMAIN_NOT_HIERARCHICAL
 *		An attempt has been made to create an upward connection from a local
 *		domain that already has an upward connection.
 *	MCS_INVALID_ADDRESS_PREFIX
 *		The called address parameter of MCSConnectProviderRequest does not
 *		contain a recognized prefix.  MCS relies on the prefix to know which
 *		transport stack to invoke.
 *	MCS_ALLOCATION_FAILURE
 *		The request could not be successfully invoked due to a memory allocation
 *		failure.
 *	MCS_INVALID_PARAMETER
 *		One of the parameters to the request is invalid.
 *	MCS_CALLBACK_NOT_PROCESSED
 *		This value should be returned to MCS during a callback if the
 *		application cannot process the callback at that time.  This provides
 *		a form of flow control between the application and MCS.  When MCS
 *		receives this return value during a callback, it will retry the same
 *		callback again during the next time slice.  Note that the user
 *		application can refuse a callback as many times as it wishes, but the
 *		programmer should be aware that this will cause MCS to "back up".
 *		Eventually this back pressure will cause MCS to refuse data from the
 *		transport layer (and so on).  Information should always be processed
 *		in a timely manner in order to insure smooth operation.
 *	MCS_DOMAIN_MERGING
 *		This value indicates that the call failed because of a domain merger
 *		that is in progress.  This will happen at the former Top Provider of
 *		the lower domain while it is still merging into the upper domain.
 *	MCS_TRANSPORT_NOT_READY
 *		This is returned from MCSConnectProviderRequest when the transport
 *		stack could not create the connection because it was not ready for the
 *		request.  This will usually happen if the request follows too closely
 *		behind the initialization of the transport stack (while it is still
 *		actively initializing).
 *	MCS_DOMAIN_PARAMETERS_UNACCEPTABLE
 *		This is returned from MCSConnectProviderResponse when the inbound
 *		connection could not be accepted because of no overlap in acceptable
 *		domain parameters.  Each MCS provider has a set of minimum and maximum
 *		domain parameters for each domain.  When a connection is to be created,
 *		the negotiated values will fall within the overlap of the two sets.
 *		If there is no overlap, then the connection cannot be accepted.  Note
 *		that this error does NOT refer to the acceptability of the domain
 *		parameters passed into the MCSConnectProviderResponse call.
 */

typedef	enum tagT120Error
{
	// the first values have to remain unmodified, because they match
	// MCS error values.
	T120_NO_ERROR			            = 0,

	T120_COMMAND_NOT_SUPPORTED,
	T120_NOT_INITIALIZED,
	T120_ALREADY_INITIALIZED,
	T120_NO_TRANSPORT_STACKS,
	T120_INVALID_ADDRESS_PREFIX,
	T120_ALLOCATION_FAILURE,
	T120_INVALID_PARAMETER,
	T120_TRANSPORT_NOT_READY,
	T120_DOMAIN_PARAMETERS_UNACCEPTABLE,
	T120_SECURITY_FAILED,
	
	// the following values can be modified in their orders
	GCC_NO_SUCH_APPLICATION             = 100,
	GCC_INVALID_CONFERENCE,
	GCC_CONFERENCE_ALREADY_EXISTS,
	GCC_INVALID_TRANSPORT,
	GCC_FAILURE_CREATING_PACKET,
	GCC_QUERY_REQUEST_OUTSTANDING,
	GCC_INVALID_QUERY_TAG,
	GCC_FAILURE_CREATING_DOMAIN,
	GCC_CONFERENCE_NOT_ESTABLISHED,
	GCC_INVALID_PASSWORD,
	GCC_INVALID_MCS_USER_ID,
	GCC_INVALID_JOIN_RESPONSE_TAG,
	GCC_APP_NOT_ENROLLED,
	GCC_NO_GIVE_RESPONSE_PENDING,
	GCC_BAD_NETWORK_ADDRESS_TYPE,
	GCC_BAD_OBJECT_KEY,	    
	GCC_INVALID_CONFERENCE_NAME,
	GCC_INVALID_CONFERENCE_MODIFIER,
	GCC_BAD_SESSION_KEY,
	GCC_BAD_CAPABILITY_ID,
	GCC_BAD_REGISTRY_KEY,
	GCC_BAD_NUMBER_OF_APES,
	GCC_BAD_NUMBER_OF_HANDLES,
	GCC_ALREADY_REGISTERED,
	GCC_APPLICATION_NOT_REGISTERED,
	GCC_BAD_CONNECTION_HANDLE_POINTER,
	GCC_INVALID_NODE_TYPE,
	GCC_INVALID_ASYMMETRY_INDICATOR,
	GCC_INVALID_NODE_PROPERTIES,
	GCC_BAD_USER_DATA,
	GCC_BAD_NETWORK_ADDRESS,
	GCC_INVALID_ADD_RESPONSE_TAG,
	GCC_BAD_ADDING_NODE,
	GCC_FAILURE_ATTACHING_TO_MCS,
	GCC_INVALID_TRANSPORT_ADDRESS,
	GCC_UNSUPPORTED_ERROR,
	GCC_TRANSMIT_BUFFER_FULL,
	GCC_INVALID_CHANNEL,
	GCC_INVALID_MODIFICATION_RIGHTS,
	GCC_INVALID_REGISTRY_ITEM,
	GCC_INVALID_NODE_NAME,
	GCC_INVALID_PARTICIPANT_NAME,
	GCC_INVALID_SITE_INFORMATION,
	GCC_INVALID_NON_COLLAPSED_CAP,
	GCC_INVALID_ALTERNATIVE_NODE_ID,
	GCC_INSUFFICIENT_PRIVILEGE,
	GCC_APPLET_EXITING,
	GCC_APPLET_CANCEL_EXIT,
	GCC_NYI,
	T120_POLICY_PROHIBIT,

	// the following values can be modified in their orders
	MCS_DOMAIN_ALREADY_EXISTS           = 200,
	MCS_NO_SUCH_DOMAIN,
	MCS_USER_NOT_ATTACHED,
	MCS_NO_SUCH_USER,
	MCS_TRANSMIT_BUFFER_FULL,
	MCS_NO_SUCH_CONNECTION,
	MCS_DOMAIN_NOT_HIERARCHICAL,
	MCS_CALLBACK_NOT_PROCESSED,
	MCS_DOMAIN_MERGING,
	MCS_DOMAIN_NOT_REGISTERED,
	MCS_SIZE_TOO_BIG,
	MCS_BUFFER_NOT_ALLOCATED,
	MCS_MORE_CALLBACKS,

    T12_ERROR_CHECK_T120_RESULT         = 299,
	INVALID_T120_ERROR                  = 300,
}
    T120Error, GCCError, *PGCCError, MCSError, *PMCSError;

#define GCC_NO_ERROR    T120_NO_ERROR
#define MCS_NO_ERROR    T120_NO_ERROR

#define GCC_COMMAND_NOT_SUPPORTED           T120_COMMAND_NOT_SUPPORTED
#define GCC_NOT_INITIALIZED                 T120_NOT_INITIALIZED
#define GCC_ALREADY_INITIALIZED             T120_ALREADY_INITIALIZED
#define GCC_NO_TRANSPORT_STACKS             T120_NO_TRANSPORT_STACKS
#define GCC_INVALID_ADDRESS_PREFIX          T120_INVALID_ADDRESS_PREFIX
#define GCC_ALLOCATION_FAILURE              T120_ALLOCATION_FAILURE
#define GCC_INVALID_PARAMETER               T120_INVALID_PARAMETER
#define GCC_TRANSPORT_NOT_READY             T120_TRANSPORT_NOT_READY
#define GCC_DOMAIN_PARAMETERS_UNACCEPTABLE  T120_DOMAIN_PARAMETERS_UNACCEPTABLE
#define GCC_SECURITY_FAILED                 T120_SECURITY_FAILED

#define MCS_COMMAND_NOT_SUPPORTED           T120_COMMAND_NOT_SUPPORTED
#define MCS_NOT_INITIALIZED                 T120_NOT_INITIALIZED
#define MCS_ALREADY_INITIALIZED             T120_ALREADY_INITIALIZED
#define MCS_NO_TRANSPORT_STACKS             T120_NO_TRANSPORT_STACKS
#define MCS_INVALID_ADDRESS_PREFIX          T120_INVALID_ADDRESS_PREFIX
#define MCS_ALLOCATION_FAILURE              T120_ALLOCATION_FAILURE
#define MCS_INVALID_PARAMETER               T120_INVALID_PARAMETER
#define MCS_TRANSPORT_NOT_READY             T120_TRANSPORT_NOT_READY
#define MCS_DOMAIN_PARAMETERS_UNACCEPTABLE  T120_DOMAIN_PARAMETERS_UNACCEPTABLE
#define MCS_SECURITY_FAILED                 T120_SECURITY_FAILED


//
// Token Status
//

typedef AppletTokenStatus       T120TokenStatus, TokenStatus;
#define TOKEN_NOT_IN_USE        APPLET_TOKEN_NOT_IN_USE
#define TOKEN_SELF_GRABBED      APPLET_TOKEN_SELF_GRABBED
#define TOKEN_OTHER_GRABBED     APPLET_TOKEN_OTHER_GRABBED
#define TOKEN_SELF_INHIBITED    APPLET_TOKEN_SELF_INHIBITED
#define TOKEN_OTHER_INHIBITED   APPLET_TOKEN_OTHER_INHIBITED
#define TOKEN_SELF_RECIPIENT    APPLET_TOKEN_SELF_RECIPIENT
#define TOKEN_SELF_GIVING       APPLET_TOKEN_SELF_GIVING
#define TOKEN_OTHER_GIVING      APPLET_TOKEN_OTHER_GIVING


/*
**	MCSReason
**      The order is important because they are in the same order of those
**      defined in mcspdu.h.
**  GCCReason
**		When GCC issues an indication to a user application, it often includes a
**		reason parameter informing the user of why the activity is occurring.
*/
typedef	enum
{
    REASON_DOMAIN_DISCONNECTED 		            = 0,
    REASON_PROVIDER_INITIATED 		            = 1,
    REASON_TOKEN_PURGED 			            = 2,
    REASON_USER_REQUESTED 			            = 3,
    REASON_CHANNEL_PURGED 			            = 4,
    REASON_REMOTE_NO_SECURITY			        = 5,
    REASON_REMOTE_DOWNLEVEL_SECURITY		    = 6,
    REASON_REMOTE_REQUIRE_SECURITY		        = 7,
	REASON_AUTHENTICATION_FAILED				= 8,

	GCC_REASON_USER_INITIATED					= 100,
	GCC_REASON_UNKNOWN							= 101,
	GCC_REASON_NORMAL_TERMINATION				= 102,
	GCC_REASON_TIMED_TERMINATION				= 103,
	GCC_REASON_NO_MORE_PARTICIPANTS				= 104,
	GCC_REASON_ERROR_TERMINATION				= 105,
	GCC_REASON_ERROR_LOW_RESOURCES				= 106,
	GCC_REASON_MCS_RESOURCE_FAILURE				= 107,
	GCC_REASON_PARENT_DISCONNECTED				= 108,
	GCC_REASON_CONDUCTOR_RELEASE				= 109,
	GCC_REASON_SYSTEM_RELEASE					= 110,
	GCC_REASON_NODE_EJECTED						= 111,
	GCC_REASON_HIGHER_NODE_DISCONNECTED 		= 112,
	GCC_REASON_HIGHER_NODE_EJECTED				= 113,
	GCC_REASON_DOMAIN_PARAMETERS_UNACCEPTABLE	= 114,
	INVALID_GCC_REASON,
}
    T120Reason, Reason, *PReason, GCCReason, *PGCCReason;

/*
**	MCSResult
**      The order is important because they are in the same order of those
**      defined in mcspdu.h.
**	GCCResult
**		When a user makes a request of GCC, GCC often responds with a result,
**		letting the user know whether or not the request succeeded.
*/
typedef	enum
{
    T120_RESULT_SUCCESSFUL              = 0,

    RESULT_DOMAIN_MERGING               = 1,
    RESULT_DOMAIN_NOT_HIERARCHICAL      = 2,
    RESULT_NO_SUCH_CHANNEL              = 3,
    RESULT_NO_SUCH_DOMAIN               = 4,
    RESULT_NO_SUCH_USER                 = 5,
    RESULT_NOT_ADMITTED                 = 6,
    RESULT_OTHER_USER_ID                = 7,
    RESULT_PARAMETERS_UNACCEPTABLE      = 8,
    RESULT_TOKEN_NOT_AVAILABLE          = 9,
    RESULT_TOKEN_NOT_POSSESSED          = 10,
    RESULT_TOO_MANY_CHANNELS            = 11,
    RESULT_TOO_MANY_TOKENS              = 12,
    RESULT_TOO_MANY_USERS               = 13,
    RESULT_UNSPECIFIED_FAILURE          = 14,
    RESULT_USER_REJECTED                = 15,
    RESULT_REMOTE_NO_SECURITY           = 16,
    RESULT_REMOTE_DOWNLEVEL_SECURITY    = 17,
    RESULT_REMOTE_REQUIRE_SECURITY      = 18,
	RESULT_AUTHENTICATION_FAILED		= 19,

	GCC_RESULT_RESOURCES_UNAVAILABLE   			= 101,
	GCC_RESULT_INVALID_CONFERENCE	   			= 102,
	GCC_RESULT_INVALID_PASSWORD		   			= 103,
	GCC_RESULT_INVALID_CONVENER_PASSWORD		= 104,
	GCC_RESULT_SYMMETRY_BROKEN		   			= 105,
	GCC_RESULT_UNSPECIFIED_FAILURE	   			= 106,
	GCC_RESULT_NOT_CONVENER_NODE	   			= 107,
	GCC_RESULT_REGISTRY_FULL		   			= 108,
	GCC_RESULT_INDEX_ALREADY_OWNED 	   			= 109,
	GCC_RESULT_INCONSISTENT_TYPE 	   			= 110,
	GCC_RESULT_NO_HANDLES_AVAILABLE	   			= 111,
	GCC_RESULT_CONNECT_PROVIDER_FAILED 			= 112,
	GCC_RESULT_CONFERENCE_NOT_READY    			= 113,
	GCC_RESULT_USER_REJECTED		   			= 114,
	GCC_RESULT_ENTRY_DOES_NOT_EXIST    			= 115,
	GCC_RESULT_NOT_CONDUCTIBLE	   	   			= 116,
	GCC_RESULT_NOT_THE_CONDUCTOR	   			= 117,
	GCC_RESULT_NOT_IN_CONDUCTED_MODE   			= 118,
	GCC_RESULT_IN_CONDUCTED_MODE	   			= 119,
	GCC_RESULT_ALREADY_CONDUCTOR	   			= 120,
	GCC_RESULT_CHALLENGE_RESPONSE_REQUIRED		= 121,
	GCC_RESULT_INVALID_CHALLENGE_RESPONSE		= 122,
	GCC_RESULT_INVALID_REQUESTER				= 123,
	GCC_RESULT_ENTRY_ALREADY_EXISTS				= 124,	
	GCC_RESULT_INVALID_NODE						= 125,
	GCC_RESULT_INVALID_SESSION_KEY				= 126,
	GCC_RESULT_INVALID_CAPABILITY_ID			= 127,
	GCC_RESULT_INVALID_NUMBER_OF_HANDLES		= 128,	
	GCC_RESULT_CONDUCTOR_GIVE_IS_PENDING		= 129,
	GCC_RESULT_INCOMPATIBLE_PROTOCOL			= 130,
	GCC_RESULT_CONFERENCE_ALREADY_LOCKED		= 131,
	GCC_RESULT_CONFERENCE_ALREADY_UNLOCKED		= 132,
	GCC_RESULT_INVALID_NETWORK_TYPE				= 133,
	GCC_RESULT_INVALID_NETWORK_ADDRESS			= 134,
	GCC_RESULT_ADDED_NODE_BUSY					= 135,
	GCC_RESULT_NETWORK_BUSY						= 136,
	GCC_RESULT_NO_PORTS_AVAILABLE				= 137,
	GCC_RESULT_CONNECTION_UNSUCCESSFUL			= 138,
	GCC_RESULT_LOCKED_NOT_SUPPORTED    			= 139,
	GCC_RESULT_UNLOCK_NOT_SUPPORTED				= 140,
	GCC_RESULT_ADD_NOT_SUPPORTED				= 141,
	GCC_RESULT_DOMAIN_PARAMETERS_UNACCEPTABLE	= 142,
	GCC_RESULT_CANCELED                         = 143,
	GCC_RESULT_CONNECT_PROVIDER_REMOTE_NO_SECURITY          = 144,
	GCC_RESULT_CONNECT_PROVIDER_REMOTE_DOWNLEVEL_SECURITY   = 145,
	GCC_RESULT_CONNECT_PROVIDER_REMOTE_REQUIRE_SECURITY     = 146,
	GCC_RESULT_CONNECT_PROVIDER_AUTHENTICATION_FAILED		= 147,

	T120_RESULT_CHECK_T120_ERROR                = 148,
	INVALID_GCC_RESULT,
}
    T120Result, Result, *PResult, GCCResult, *PGCCResult;

#define RESULT_SUCCESSFUL           T120_RESULT_SUCCESSFUL
#define GCC_RESULT_SUCCESSFUL       T120_RESULT_SUCCESSFUL



//
//  T120 Messages (Control SAP and Applet SAP)
//

typedef enum
{
    /******************* NODE CONTROLLER CALLBACKS ***********************/
    
    /* Conference Create, Terminate related calls */
    GCC_CREATE_INDICATION                   = 0,
    GCC_CREATE_CONFIRM                      = 1,
    GCC_QUERY_INDICATION                    = 2,
    GCC_QUERY_CONFIRM                       = 3,
    GCC_JOIN_INDICATION                     = 4,
    GCC_JOIN_CONFIRM                        = 5,
    GCC_INVITE_INDICATION                   = 6,
    GCC_INVITE_CONFIRM                      = 7,
    GCC_ADD_INDICATION                      = 8,
    GCC_ADD_CONFIRM                         = 9,
    GCC_LOCK_INDICATION                     = 10,
    GCC_LOCK_CONFIRM                        = 11,
    GCC_UNLOCK_INDICATION                   = 12,
    GCC_UNLOCK_CONFIRM                      = 13,
    GCC_LOCK_REPORT_INDICATION              = 14,
    GCC_DISCONNECT_INDICATION               = 15,
    GCC_DISCONNECT_CONFIRM                  = 16,
    GCC_TERMINATE_INDICATION                = 17,
    GCC_TERMINATE_CONFIRM                   = 18,
    GCC_EJECT_USER_INDICATION               = 19,
    GCC_EJECT_USER_CONFIRM                  = 20,
    GCC_TRANSFER_INDICATION                 = 21,
    GCC_TRANSFER_CONFIRM                    = 22,
    GCC_APPLICATION_INVOKE_INDICATION       = 23,        /* SHARED CALLBACK */
    GCC_APPLICATION_INVOKE_CONFIRM          = 24,        /* SHARED CALLBACK */
    GCC_SUB_INITIALIZED_INDICATION          = 25,

    /* Conference Roster related callbacks */
    GCC_ANNOUNCE_PRESENCE_CONFIRM           = 26,
    GCC_ROSTER_REPORT_INDICATION            = 27,        /* SHARED CALLBACK */
    GCC_ROSTER_INQUIRE_CONFIRM              = 28,        /* SHARED CALLBACK */

    /* Conductorship related callbacks */
    GCC_CONDUCT_ASSIGN_INDICATION           = 29,        /* SHARED CALLBACK */
    GCC_CONDUCT_ASSIGN_CONFIRM              = 30,
    GCC_CONDUCT_RELEASE_INDICATION          = 31,        /* SHARED CALLBACK */
    GCC_CONDUCT_RELEASE_CONFIRM             = 32,
    GCC_CONDUCT_PLEASE_INDICATION           = 33,
    GCC_CONDUCT_PLEASE_CONFIRM              = 34,
    GCC_CONDUCT_GIVE_INDICATION             = 35,
    GCC_CONDUCT_GIVE_CONFIRM                = 36,
    GCC_CONDUCT_INQUIRE_CONFIRM             = 37,        /* SHARED CALLBACK */
    GCC_CONDUCT_ASK_INDICATION              = 38,
    GCC_CONDUCT_ASK_CONFIRM                 = 39,
    GCC_CONDUCT_GRANT_INDICATION            = 40,        /* SHARED CALLBACK */
    GCC_CONDUCT_GRANT_CONFIRM               = 41,

    /* Miscellaneous Node Controller callbacks */
    GCC_TIME_REMAINING_INDICATION           = 42,
    GCC_TIME_REMAINING_CONFIRM              = 43,
    GCC_TIME_INQUIRE_INDICATION             = 44,
    GCC_TIME_INQUIRE_CONFIRM                = 45,
    GCC_CONFERENCE_EXTEND_INDICATION        = 46,
    GCC_CONFERENCE_EXTEND_CONFIRM           = 47,
    GCC_ASSISTANCE_INDICATION               = 48,
    GCC_ASSISTANCE_CONFIRM                  = 49,
    GCC_TEXT_MESSAGE_INDICATION             = 50,
    GCC_TEXT_MESSAGE_CONFIRM                = 51,

    /***************** USER APPLICATION CALLBACKS *******************/

    /* Application Roster related callbacks */
    GCC_PERMIT_TO_ENROLL_INDICATION         = 52,
    GCC_ENROLL_CONFIRM                      = 53,
    GCC_APP_ROSTER_REPORT_INDICATION        = 54,        /* SHARED CALLBACK */
    GCC_APP_ROSTER_INQUIRE_CONFIRM          = 55,        /* SHARED CALLBACK */

    /* Application Registry related callbacks */
    GCC_REGISTER_CHANNEL_CONFIRM            = 56,
    GCC_ASSIGN_TOKEN_CONFIRM                = 57,
    GCC_RETRIEVE_ENTRY_CONFIRM              = 58,
    GCC_DELETE_ENTRY_CONFIRM                = 59,
    GCC_SET_PARAMETER_CONFIRM               = 60,
    GCC_MONITOR_INDICATION                  = 61,
    GCC_MONITOR_CONFIRM                     = 62,
    GCC_ALLOCATE_HANDLE_CONFIRM             = 63,

    /****************** NON-Standard Primitives **********************/

    GCC_PERMIT_TO_ANNOUNCE_PRESENCE         = 100,    /*    Node Controller Callback */    
    GCC_CONNECTION_BROKEN_INDICATION        = 101,    /*    Node Controller Callback */
    GCC_FATAL_ERROR_SAP_REMOVED             = 102,    /*    Application Callback     */
    GCC_STATUS_INDICATION                   = 103,    /*    Node Controller Callback */
    GCC_TRANSPORT_STATUS_INDICATION         = 104,    /*    Node Controller Callback */

    T120_JOIN_SESSION_CONFIRM               = 120,

    /******************* MCS CALLBACKS ***********************/

    MCS_CONNECT_PROVIDER_INDICATION         = 200,
    MCS_CONNECT_PROVIDER_CONFIRM            = 201,
    MCS_DISCONNECT_PROVIDER_INDICATION      = 202,
    MCS_ATTACH_USER_CONFIRM                 = 203,
    MCS_DETACH_USER_INDICATION              = 204,
    MCS_CHANNEL_JOIN_CONFIRM                = 205,
    MCS_CHANNEL_LEAVE_INDICATION            = 206,
    MCS_CHANNEL_CONVENE_CONFIRM             = 207,
    MCS_CHANNEL_DISBAND_INDICATION          = 208,
    MCS_CHANNEL_ADMIT_INDICATION            = 209,
    MCS_CHANNEL_EXPEL_INDICATION            = 210,
    MCS_SEND_DATA_INDICATION                = 211,
    MCS_UNIFORM_SEND_DATA_INDICATION        = 212,
    MCS_TOKEN_GRAB_CONFIRM                  = 213,
    MCS_TOKEN_INHIBIT_CONFIRM               = 214,
    MCS_TOKEN_GIVE_INDICATION               = 215,
    MCS_TOKEN_GIVE_CONFIRM                  = 216,
    MCS_TOKEN_PLEASE_INDICATION             = 217,
    MCS_TOKEN_RELEASE_CONFIRM               = 218,
    MCS_TOKEN_TEST_CONFIRM                  = 219,
    MCS_TOKEN_RELEASE_INDICATION            = 220,
    MCS_TRANSMIT_BUFFER_AVAILABLE_INDICATION= 221,
    MCS_LAST_USER_MESSAGE                   = 222,

    /******************* Non-standard MCS CALLBACKS ***********************/
    
    MCS_TRANSPORT_STATUS_INDICATION         = 301,
}
    T120MessageType;



/*
 *	MCS_CONNECT_PROVIDER_INDICATION
 *
 *	Parameter:
 *		PConnectProviderIndication
 *			This is a pointer to a structure that contains all necessary
 *			information about an incoming connection.
 *
 *	Functional Description:
 *		This indication is sent to the node controller when an incoming
 *		connection is detected.  The node controller should respond by calling
 *		MCSConnectProviderResponse indicating whether or not the connection
 *		is to be accepted.
 */

/*
 *	MCS_CONNECT_PROVIDER_CONFIRM
 *
 *	Parameter:
 *		PConnectProviderConfirm
 *			This is a pointer to a structure that contains all necessary
 *			information about an outgoing connection.
 *
 *	Functional Description:
 *		This confirm is sent to the node controller in response to a previous
 *		call to MCSConnectProviderRequest.  It informs the node controller
 *		of when the new connection is available for use, or that the
 *		connection could not be established (or that it was rejected by the
 *		remote site).
 */

/*
 *	MCS_DISCONNECT_PROVIDER_INDICATION
 *
 *	Parameter:
 *		PDisconnectProviderIndication
 *			This is a pointer to a structure that contains all necessary
 *			information about a connection that has been lost.
 *
 *	Functional Description:
 *		This indication is sent to the node controller whenever a connection
 *		is lost.  This essentially tells the node controller that the contained
 *		connection handle is no longer valid.
 */

/*
 *	MCS_ATTACH_USER_CONFIRM
 *
 *	Parameter:
 *		(LOWUSHORT) UserID
 *			If the result is success, then this is the newly assigned user ID.
 *			If the result is failure, then this field is undefined.
 *		(HIGHUSHORT) Result
 *			This is the result of the attach user request.
 *
 *	Functional Description:
 *		This confirm is sent to a user application in response to a previous
 *		call to MCS_AttachRequest.  It contains the result of that service
 *		request.  If successful, it also contains the user ID that has been
 *		assigned to that attachment.
 */

/*
 *	MCS_DETACH_USER_INDICATION
 *
 *	Parameter:
 *		(LOWUSHORT) UserID
 *			This is the user ID of the user that is detaching.
 *		(HIGHUSHORT) Reason
 *			This is the reason for the detachment.
 *
 *	Functional Description:
 *		This indication is sent to the user application whenever a user detaches
 *		from the domain.  This is sent to ALL remaining users in the domain
 *		automatically.  Note that if the user ID contained in this indication
 *		is the same as that of the application receiving it, the application is
 *		essentially being told that it has been kicked out of the conference.
 *		The user handle and user ID are no longer valid in this case.  It is the
 *		responsibility of the application to recognize when this occurs.
 */

/*
 *	MCS_CHANNEL_JOIN_CONFIRM
 *
 *	Parameter:
 *		(LOWUSHORT) ChannelID
 *			This is the channel that has been joined.
 *		(HIGHUSHORT) Result
 *			This is the result of the join request.
 *
 *	Functional Description:
 *		This confirm is sent to a user application in response to a previous
 *		call to MCSChannelJoinRequest.  It lets the application know if the
 *		join was successful for a particular channel.  Furthermore, if the
 *		join request was for channel 0 (zero), then the ID of the assigned
 *		channel is contained in this confirm.
 */

/*
 *	MCS_CHANNEL_LEAVE_INDICATION
 *
 *	Parameter:
 *		(LOWUSHORT) ChannelID
 *			This is the channel that has been left or is being told to leave.
 *		(HIGHUSHORT) Reason
 *			This is the reason for the leave.
 *
 *	Functional Description:
 *		This indication is sent to a user application when a domain merger has
 *		caused a channel to be purged from the lower domain.  This informs the
 *		the user that it is no longer joined to the channel.
 */

/*
 *	MCS_CHANNEL_CONVENE_CONFIRM
 *
 *	Parameter:
 *		(LOWUSHORT) ChannelID
 *			This is the private channel that is being convened.
 *		(HIGHUSHORT) Result
 *			This is the result of the convene request.
 *
 *	Functional Description:
 *		This confirm is sent to a user application in response to a previous
 *		call to MCSChannelConveneRequest.  It lets the application know whether
 *		or not the convene request was successful, and if so, what the channel
 *		number is.
 */

/*
 *	MCS_CHANNEL_DISBAND_INDICATION
 *
 *	Parameter:
 *		(LOWUSHORT) ChannelID
 *			This is the private channel that is being disbanded.
 *		(HIGHUSHORT) Reason
 *			This is the reason for the disband.
 *
 *	Functional Description:
 *		This indication is sent to a user application when a private channel
 *		that it convened is disbanded by MCS.  This is sent to only the channel
 *		manager (all other members of the private channel will receive an
 *		MCS_CHANNEL_EXPEL_INDICATION).
 */

/*
 *	MCS_CHANNEL_ADMIT_INDICATION
 *
 *	Parameter:
 *		(LOWUSHORT) ChannelID
 *			This is the private channel that the user is being admitted to.
 *		(HIGHUSHORT) UserID
 *			This is the User ID of the manager of this private channel.
 *
 *	Functional Description:
 *		This indication is sent to a user application when it is admitted to
 *		a private channel (its User ID is added to the authorized user list).
 *		This lets the user know that it is now allowed to use the private
 *		channel.
 */

/*
 *	MCS_CHANNEL_EXPEL_INDICATION
 *
 *	Parameter:
 *		(LOWUSHORT) ChannelID
 *			This is the private channel that the user is being expelled from.
 *		(HIGHUSHORT) Reason
 *			This is the reason for the expel.
 *
 *	Functional Description:
 *		This indication is sent to a user application when it is expelled from
 *		a private channel (its User ID is removed from the authorized user
 *		list).  This lets the user know that it is no longer allowed to use
 *		the private channel.
 */

/*
 *	MCS_SEND_DATA_INDICATION
 *
 *	Parameter:
 *		PSendData
 *			This is a pointer to a SendData structure that contains all
 *			information about the data received.
 *
 *	Functional Description:
 *		This indication is sent to a user application when data is received
 *		by the local MCS provider on a channel to which the user is joined.
 */

/*
 *	MCS_UNIFORM_SEND_DATA_INDICATION
 *
 *	Parameter:
 *		PSendData
 *			This is a pointer to a SendData structure that contains all
 *			information about the data received.
 *
 *	Functional Description:
 *		This indication is sent to a user application when data is received
 *		by the local MCS provider on a channel to which the user is joined.
 */

/*
 *	MCS_TOKEN_GRAB_CONFIRM
 *
 *	Parameter:
 *		(LOWUSHORT) TokenID
 *			This is the ID of the token that the user application has attempted
 *			to grab.
 *		(HIGHUSHORT) Result
 *			This is the result of the token grab operation.  This will be
 *			RESULT_SUCCESSFUL if the token was grabbed.
 *
 *	Functional Description:
 *		This confirm is sent to a user application in response to a previous
 *		call to MCSTokenGrabRequest.  It lets the application know if the grab
 *		request was successful or not.
 */

/*
 *	MCS_TOKEN_INHIBIT_CONFIRM
 *
 *	Parameter:
 *		(LOWUSHORT) TokenID
 *			This is the ID of the token that the user application has attempted
 *			to inhibit.
 *		(HIGHUSHORT) Result
 *			This is the result of the token inhibit operation.  This will be
 *			RESULT_SUCCESSFUL if the token was inhibited.
 *
 *	Functional Description:
 *		This confirm is sent to a user application in response to a previous
 *		call to MCSTokenInhibitRequest.  It lets the application know if the
 *		inhibit request was successful or not.
 */

/*
 *	MCS_TOKEN_GIVE_INDICATION
 *
 *	Parameter:
 *		(LOWUSHORT) TokenID
 *			This is the ID of the token being offered to another user.
 *		(HIGHUSHORT) UserID
 *			This is the User ID of the user that is attempting to give the
 *			token away.
 *
 *	Functional Description:
 *		This indication is sent to a user application when another user in the
 *		domain attempts to give a token to it.  The user application should
 *		respond by calling MCSTokenGiveResponse indicating whether or not the
 *		token was accepted.
 */

/*
 *	MCS_TOKEN_GIVE_CONFIRM
 *
 *	Parameter:
 *		(LOWUSHORT) TokenID
 *			This is the ID of the token being offered to another user.
 *		(HIGHUSHORT) Result
 *			This is the result of the token give operation.  This will be
 *			RESULT_SUCCESSFUL if the token was accepted.
 *
 *	Functional Description:
 *		This confirm is sent to a user application in response to a previous
 *		call to MCSTokenGiveRequest (which in turn will cause another user to
 *		call MCSTokenGiveResponse).  The result code will inform the user
 *		as to whether or not the token was accepted.
 */

/*
 *	MCS_TOKEN_PLEASE_INDICATION
 *
 *	Parameter:
 *		(LOWUSHORT) TokenID
 *			This is the ID of the token that the user application would like to
 *			gain possesion of.
 *		(HIGHUSHORT) UserID
 *			This is the User ID of the user that is asking to receive ownership
 *			of a token.
 *
 *	Functional Description:
 *		This indication is sent to all owners (grabbers or inhibitors) of a
 *		token when a user issues an MCSTokenPleaseRequest.  This allows a user
 *		to "ask" for possession of a token without having to know exactly
 *		who currently owns it (MCS will route this indication appropriately).
 */

/*
 *	MCS_TOKEN_RELEASE_CONFIRM
 *
 *	Parameter:
 *		(LOWUSHORT) TokenID
 *			This is the ID of the token that the user application has attempted
 *			to release.
 *		(HIGHUSHORT) Result
 *			This is the result of the token release operation.  This will be
 *			RESULT_SUCCESSFUL if the token was released.
 *
 *	Functional Description:
 *		This confirm is sent to a user application in response to a previous
 *		call to MCSTokenReleaseRequest.  It lets the application know if the
 *		release request was successful or not.
 */

/*
 *	MCS_TOKEN_TEST_CONFIRM
 *
 *	Parameter:
 *		(LOWUSHORT) TokenID
 *			This is the ID of the token that the user application is testing.
 *		(HIGHUSHORT) TokenStatus
 *			This is the status of that token.
 *
 *	Functional Description:
 *		This confirm is sent to a user application in response to a previous
 *		call to MCSTokenTestRequest.  It lets the application know the current
 *		state of the specified token.
 */

/*
 *	MCS_TOKEN_RELEASE_INDICATION
 *
 *	Parameter:
 *		(LOWUSHORT) TokenID
 *			This is the ID of the token that is being taken away from its
 *			current owner.
 *		(HIGHUSHORT) Reason
 *			This is the reason that the token is being taken away from its
 *			owner.
 *
 *	Functional Description:
 *		This indication is sent to a user application when a domain merger has
 *		caused a token to be purged from the lower domain.  This tells the
 *		user that a token that it used to own has been taken away.
 */

/*
 *	MCS_MERGE_DOMAIN_INDICATION
 *
 *	Parameter:
 *		(LOWUSHORT) MergeStatus
 *			The is the status of the merge.  This informs the applications of
 *			whether the merge is just starting, or whether it is complete.
 *
 *	Functional Description:
 *		This indication is sent to the application when a provider begins
 *		merging its information base upward.  It informs the application that
 *		all domain activity is temporarily suspended.  It is sent again when the
 *		merge operation is complete, letting the application know that domain
 *		activity is once again valid.
 */

/*
 *  MCS_TRANSPORT_STATUS_INDICATION
 *
 *	This primitive is non-standard, and is issed through MCS by a transport
 *	stack when a state change occurs.  MCS merely passes the information
 *	through to the node controller.  This primitive will NOT be received by
 *	any user attachment.
 */


#endif // _T120_TYPE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\h\t120\t120.h ===
/*
 *    t120.h
 *
 *    Copyright (c) 1994, 1995 by DataBeam Corporation, Lexington, KY
 *
 *    Abstract:
 *        This is the interface file for the communications infrastructure of
 *        T120.
 *
 *        Note that this is a "C" language interface in order to prevent any "C++"
 *        naming conflicts between different compiler manufacturers.  Therefore,
 *        if this file is included in a module that is being compiled with a "C++"
 *        compiler, it is necessary to use the following syntax:
 *
 *        extern "C"
 *        {
 *            #include "t120.h"
 *        }
 *
 *        This disables C++ name mangling on the API entry points defined within
 *        this file.
 *
 *    Author:
 *        blp
 *
 *    Caveats:
 *        none
 */
#ifndef __T120_H__
#define __T120_H__


/*
 *    These macros are used to pack 2 16-bit values into a 32-bit variable, and
 *    get them out again.
 */
#ifndef LOWUSHORT
    #define LOWUSHORT(ul)    (LOWORD(ul))
#endif

#ifndef HIGHUSHORT
    #define HIGHUSHORT(ul)    (HIWORD(ul))
#endif


#include "t120type.h"
#include "mcatmcs.h"
#include "gcc.h"

#endif // __T120_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\nmmkcert\nmmkcert.cpp ===
//+-------------------------------------------------------------------------
//
// NmMkCert - NetMeeting internal certificate generator
//
//            Generates NetMeeting default user certificates. The NetMeeting
//            root key and certificate are stored as a program resource.
//
// ClausGi    7/29/98 created based on MAKECERT
//
//--------------------------------------------------------------------------

#include "global.h"
#include <oprahcom.h>

#ifdef DEBUG
HDBGZONE    ghDbgZone = NULL;
static PTCHAR _rgZonesNmMkCert[] = { TEXT("nmmkcert"), };
#endif /* DEBUG */

//+-------------------------------------------------------------------------
//  contants
//--------------------------------------------------------------------------

//allow max 10 extensions per certificate
#define MAX_EXT_CNT 10

//+-------------------------------------------------------------------------
//  globals
//--------------------------------------------------------------------------

WCHAR*   g_wszSubjectKey            = L"_NmMkCert";
WCHAR*     g_wszSubjectStore          = WSZNMSTORE;
DWORD     g_dwSubjectStoreFlag          = CERT_SYSTEM_STORE_CURRENT_USER;

DWORD     g_dwIssuerKeySpec          = AT_SIGNATURE;
DWORD    g_dwSubjectKeySpec         = AT_KEYEXCHANGE;

WCHAR   *g_wszSubjectDisplayName = NULL; // BUGBUG set this?

LPWSTR  g_wszIssuerProviderName   = NULL;
LPWSTR    g_wszSubjectProviderName    = NULL;

WCHAR*   g_wszSubjectX500Name;

DWORD g_dwProvType = PROV_RSA_FULL;

HMODULE    hModule=NULL;

BOOL MakeCert(DWORD dwFlags);

BOOL WINAPI DllMain(HINSTANCE hDllInst, DWORD fdwReason, LPVOID)
{
    switch (fdwReason)
    {
        case DLL_PROCESS_ATTACH:
        {
            hModule = hDllInst;
            ASSERT (hModule != NULL);
            DBGINIT(&ghDbgZone, _rgZonesNmMkCert);
            DisableThreadLibraryCalls (hDllInst);
            DBG_INIT_MEMORY_TRACKING(hDllInst);
            break;
        }

        case DLL_PROCESS_DETACH:
        {
            DBG_CHECK_MEMORY_TRACKING(hDllInst);
            hModule = NULL;
            break;
        }

        default:
            break;
    }
    return (TRUE);
}

//
// X.509 cert strings must be from X.208 printable character set... this
// function enforces that.
//

static const char szPrintable[] = " '()+,-./:=?\"";   // along with A-Za-z0-9

VOID MkPrintableString ( LPSTR szString )
{
    CHAR * p = szString;

    while ( *p )
    {
        if (!(('a' <= *p && *p <='z') ||
              ('A' <= *p && *p <='Z') ||
              ('0' <= *p && *p <='9') ||
              _StrChr(szPrintable,*p)))
        {
            *p = '-';
        }
        p++;
    }
}

DWORD WINAPI NmMakeCert(     LPCSTR szFirstName,
                            LPCSTR szLastName,
                            LPCSTR szEmailName,
                            LPCSTR szCity,
                            LPCSTR szCountry,
                            DWORD flags)
{
    DWORD dwRet = -1;

    WARNING_OUT(("NmMakeCert called"));

    // Form the unencoded X500 subject string. It would be nice to
    // use official constants for the below... CertRDNValueToString?

    UINT cbX500Name = ( szFirstName ? lstrlen(szFirstName) : 0 ) +
                      ( szLastName ? lstrlen(szLastName) : 0 ) +
                      ( szEmailName ? lstrlen(szEmailName) : 0 ) +
                      ( szCity ? lstrlen(szCity) : 0 ) +
                      ( szCountry ? lstrlen(szCountry) : 0 ) +
                      128; // Extra is for RDN OID strings: CN= etc.

    char * pX500Name = new char[cbX500Name];

    if ( NULL == pX500Name )
    {
        ERROR_OUT(("couldn't allocate %d bytes for x500 name", cbX500Name));
        goto cleanup;
    }

    ASSERT( ( szFirstName && *szFirstName ) || ( szLastName && *szLastName ) );

    wsprintf( pX500Name, "CN=\"%s %s\"", szFirstName ? szFirstName : "", szLastName ? szLastName : "" );

    if ( szEmailName && *szEmailName )
        wsprintf( pX500Name + lstrlen(pX500Name), ", E=\"%s\"", szEmailName );

    if ( szCity && *szCity )
        wsprintf( pX500Name + lstrlen(pX500Name), ", S=\"%s\"", szCity );

    if ( szCountry && *szCountry )
        wsprintf( pX500Name + lstrlen(pX500Name), ", C=\"%s\"", szCountry );

    MkPrintableString ( pX500Name );

    g_wszSubjectX500Name = AnsiToUnicode ( pX500Name );

    ASSERT(g_wszSubjectX500Name);

    if ( flags & NMMKCERT_F_LOCAL_MACHINE )
    {
        // We are being asked to generate a local machine cert...
        // change the subject store flag and the key container name
        g_dwSubjectStoreFlag          = CERT_SYSTEM_STORE_LOCAL_MACHINE;
        g_wszSubjectKey = L"_NmMkMchCert";
    }

    // If we're on NT5 we have to generate the cert using the
    // PROV_RSA_SCHANNEL provider, on other platforms this provider type
    // doesn't exist.

    OSVERSIONINFO       osVersion;

    ZeroMemory(&osVersion, sizeof(osVersion));
    osVersion.dwOSVersionInfoSize = sizeof(osVersion);
    GetVersionEx(&osVersion);

    if (osVersion.dwPlatformId == VER_PLATFORM_WIN32_NT &&
        osVersion.dwMajorVersion >= 5)
    {
        g_dwProvType = PROV_RSA_SCHANNEL;
    }
        
    // Get to work and make the certificate
    if (!MakeCert(flags))
    {
        WARNING_OUT(("NmMakeCert failed."));
    }
    else
    {
        dwRet = 1;
    }

cleanup:

    if ( NULL != g_wszSubjectX500Name )
    {
        delete g_wszSubjectX500Name;
    }

    if ( NULL != pX500Name )
    {
        delete pX500Name;
    }

    return dwRet;
}


// RUNDLL entry point for certificate uninstall... the prototype is given
// by RUNDLL32.EXE requirements!
void CALLBACK NmMakeCertCleanup ( HWND hwnd, HINSTANCE hinst, LPSTR lpszCmdLine, int nCmdShow )
{
    // Clean up exisint certs and private keys
    MakeCert(NMMKCERT_F_CLEANUP_ONLY);
    g_dwSubjectStoreFlag          = CERT_SYSTEM_STORE_LOCAL_MACHINE;
    g_wszSubjectKey = L"_NmMkMchCert";
    MakeCert(NMMKCERT_F_LOCAL_MACHINE|NMMKCERT_F_CLEANUP_ONLY);
}


//+=========================================================================
//  Local Support Functions
//==========================================================================

//+=========================================================================
//  MakeCert support functions
//==========================================================================

BOOL VerifyIssuerKey( IN HCRYPTPROV hProv,
        IN PCERT_PUBLIC_KEY_INFO pIssuerKeyInfo);
HCRYPTPROV GetSubjectProv(OUT LPWSTR *ppwszTmpContainer);

BOOL GetPublicKey(
    HCRYPTPROV hProv,
    PCERT_PUBLIC_KEY_INFO *ppPubKeyInfo
    );
BOOL EncodeSubject(
    OUT BYTE **ppbEncoded,
    IN OUT DWORD *pcbEncoded
    );
BOOL CreateSpcCommonName(
    OUT BYTE **ppbEncoded,
    IN OUT DWORD *pcbEncoded
    );
BOOL CreateEnhancedKeyUsage(
    OUT BYTE **ppbEncoded,
    IN OUT DWORD *pcbEncoded
    );

BOOL    SaveCertToStore(HCRYPTPROV    hProv,        
                        HCERTSTORE        hStore,        
                        DWORD        dwFlag,
                        BYTE        *pbEncodedCert,    
                        DWORD        cbEncodedCert,
                        LPWSTR        wszPvk,            
                        DWORD        dwKeySpecification,
                        LPWSTR        wszCapiProv,        
                        DWORD        dwCapiProvType);


//+-------------------------------------------------------------------------
//  Get the root's certificate from the program's resources
//--------------------------------------------------------------------------
PCCERT_CONTEXT GetRootCertContext()
{
    PCCERT_CONTEXT    pCert = NULL;
    HRSRC            hRes;

    //
    // The root certificate is stored as a resource of ours.
    // Load it...
    //
    if (0 != (hRes = FindResource(hModule, MAKEINTRESOURCE(IDR_ROOTCERTIFICATE),
                        "CER"))) {
        HGLOBAL hglobRes;
        if (NULL != (hglobRes = LoadResource(hModule, hRes))) {
            BYTE *pbRes;
            DWORD cbRes;

            cbRes = SizeofResource(hModule, hRes);
            pbRes = (BYTE *) LockResource(hglobRes);

            if (cbRes && pbRes)
                pCert = CertCreateCertificateContext(X509_ASN_ENCODING,
                                                    pbRes, cbRes);
            if ( NULL == pCert )
            {
                DWORD dwError = GetLastError();
            }

            UnlockResource(hglobRes);
            FreeResource(hglobRes);
        }
    }

    if (pCert == NULL)
    {
        ERROR_OUT(("Error creating root cert: %x", GetLastError()));
    }
    return pCert;
}

//+-------------------------------------------------------------------------
//  Get the root's private key from the program's resources and create
//  a temporary key provider container
//--------------------------------------------------------------------------
HCRYPTPROV GetRootProv(OUT LPWSTR *ppwszTmpContainer)
{
    HCRYPTPROV        hProv = 0;
    HRSRC            hRes;
    WCHAR            wszRootSig[] = L"Root Signature";

    *ppwszTmpContainer = NULL;

    if (0 != (hRes = FindResource(hModule,MAKEINTRESOURCE(IDR_PVKROOT),"PVK")))
    {
        HGLOBAL hglobRes;
        if (NULL != (hglobRes = LoadResource(hModule, hRes))) {
            BYTE *pbRes;
            DWORD cbRes;

            cbRes = SizeofResource(hModule, hRes);
            pbRes = (BYTE *) LockResource(hglobRes);
            if (cbRes && pbRes) {
                PvkPrivateKeyAcquireContextFromMemory(
                    g_wszIssuerProviderName,
                    PROV_RSA_FULL,
                    pbRes,
                    cbRes,
                    NULL,               // hwndOwner
                    wszRootSig,
                    &g_dwIssuerKeySpec,
                    &hProv
                    );
            }
            UnlockResource(hglobRes);
            FreeResource(hglobRes);
        }
    }

    if (hProv == 0)
    {
        ERROR_OUT(("couldn't create root key provider: %x", GetLastError()));
    }
    return hProv;
}

//+-------------------------------------------------------------------------
//  Make the subject certificate. If the subject doesn't have a private
//  key, then, create.
//--------------------------------------------------------------------------
BOOL MakeCert(DWORD dwFlags)
{
    BOOL fResult;

    HCRYPTPROV        hIssuerProv = 0;
    LPWSTR            pwszTmpIssuerContainer = NULL;
    PCCERT_CONTEXT    pIssuerCertContext = NULL;
    PCERT_INFO        pIssuerCert =NULL; // not allocated

    HCRYPTPROV        hSubjectProv = 0;
    LPWSTR            pwszTmpSubjectContainer = NULL;

    PCERT_PUBLIC_KEY_INFO pSubjectPubKeyInfo = NULL;         // not allocated
    PCERT_PUBLIC_KEY_INFO pAllocSubjectPubKeyInfo = NULL;
    BYTE *pbSubjectEncoded = NULL;
    DWORD cbSubjectEncoded =0;
    BYTE *pbSpcCommonNameEncoded = NULL;
    DWORD cbSpcCommonNameEncoded =0;
    BYTE *pbCertEncoded = NULL;
    DWORD cbCertEncoded =0;
    BYTE *pbEKUEncoded = NULL;
    DWORD cbEKUEncoded = 0;

    CERT_INFO Cert;
    GUID SerialNumber;
    HCERTSTORE                hStore=NULL;

    CERT_EXTENSION rgExt[MAX_EXT_CNT];
    DWORD cExt = 0;

    CRYPT_ALGORITHM_IDENTIFIER SignatureAlgorithm = {
        szOID_RSA_MD5RSA, 0, 0
    };

    if (0 == (hSubjectProv = GetSubjectProv(&pwszTmpSubjectContainer)))
        goto ErrorReturn;


#define TEMP_CLEAN_CODE
#ifdef TEMP_CLEAN_CODE
    // open the system store where we used to generate certs
    hStore=CertOpenStore(CERT_STORE_PROV_SYSTEM_W,
        X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
        hSubjectProv,
        CERT_STORE_NO_CRYPT_RELEASE_FLAG | g_dwSubjectStoreFlag,
        L"MY" );

	if ( hStore )
	{
		//
		// Delete all old certs
		//
		PCCERT_CONTEXT pCertContext = NULL;

		// Clear out any certificate(s) we may have added before
		while ( pCertContext = CertEnumCertificatesInStore(
										hStore, (PCERT_CONTEXT)pCertContext ))
		{
			DWORD dwMagic;
			DWORD cbMagic;

			cbMagic = sizeof(dwMagic);

			if (CertGetCertificateContextProperty(pCertContext,
				CERT_FIRST_USER_PROP_ID, &dwMagic, &cbMagic) &&
				cbMagic == sizeof(dwMagic) && dwMagic == NMMKCERT_MAGIC )
			{
				CertDeleteCertificateFromStore(pCertContext);
				// Restart the enumeration
				pCertContext = NULL;
				continue;
			}
		}
		CertCloseStore(hStore,0);
	}
#endif // TEMP_CLEAN_CODE

    // open a new cert store
    hStore=CertOpenStore(CERT_STORE_PROV_SYSTEM_W,
        X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
        hSubjectProv,
        CERT_STORE_NO_CRYPT_RELEASE_FLAG | g_dwSubjectStoreFlag,
        g_wszSubjectStore);

    if(hStore==NULL)
        goto ErrorReturn;
        
    // Empty the store
    PCCERT_CONTEXT pCertContext;
    while ( pCertContext = CertEnumCertificatesInStore ( hStore, NULL ))
    {
        if ( !CertDeleteCertificateFromStore ( pCertContext ))
        {
            WARNING_OUT(("Failed to delete certificate: %x", GetLastError()));
            break;
        }
    }

    // If NMMKCERT_F_CLEANUP_ONLY is set, we are done
    if ( dwFlags & NMMKCERT_F_CLEANUP_ONLY )
    {
        // We've just deleted the existing certs, now delete the
        // private key container and exit.
        CryptAcquireContextU(
                &hSubjectProv,
                g_wszSubjectKey,
                g_wszSubjectProviderName,
                g_dwProvType,
                CRYPT_DELETEKEYSET |  
                    ( g_dwSubjectStoreFlag == CERT_SYSTEM_STORE_LOCAL_MACHINE ?
                        CRYPT_MACHINE_KEYSET : 0 ));
        fResult = TRUE;
        goto CommonReturn;
    }

    //
    // Get access to the subject's (public) key, creating it if necessary
    //
    if (!GetPublicKey(hSubjectProv, &pAllocSubjectPubKeyInfo))
        goto ErrorReturn;
    pSubjectPubKeyInfo = pAllocSubjectPubKeyInfo;


    //
    // Encode the subject name
    //
    if (!EncodeSubject(&pbSubjectEncoded, &cbSubjectEncoded))
        goto ErrorReturn;

    //
    // Get access to the issuer's (private) key
    //
    hIssuerProv= GetRootProv(&pwszTmpIssuerContainer);

    if (NULL == (pIssuerCertContext = GetRootCertContext()))
        goto ErrorReturn;

    pIssuerCert = pIssuerCertContext->pCertInfo;

    if (!VerifyIssuerKey(hIssuerProv, &pIssuerCert->SubjectPublicKeyInfo))
        goto ErrorReturn;

    //
    // Update the CERT_INFO
    //
    ClearStruct(&Cert);
    Cert.dwVersion = CERT_V3;

    CoCreateGuid(&SerialNumber);
    Cert.SerialNumber.pbData = (BYTE *) &SerialNumber;
    Cert.SerialNumber.cbData = sizeof(SerialNumber);

    Cert.SignatureAlgorithm = SignatureAlgorithm;
    Cert.Issuer.pbData = pIssuerCert->Subject.pbData;
    Cert.Issuer.cbData = pIssuerCert->Subject.cbData;

    {
        SYSTEMTIME st;

        // Valid starting now...
        GetSystemTimeAsFileTime(&Cert.NotBefore);

        // Ending in 2039 (arbitrarily)
        ClearStruct(&st);
        st.wYear  = 2039;
        st.wMonth = 12;
        st.wDay   = 31;
        st.wHour  = 23;
        st.wMinute= 59;
        st.wSecond= 59;
        SystemTimeToFileTime(&st, &Cert.NotAfter);
    }

    Cert.Subject.pbData = pbSubjectEncoded;
    Cert.Subject.cbData = cbSubjectEncoded;
    Cert.SubjectPublicKeyInfo = *pSubjectPubKeyInfo;

    // Cert Extensions

    if (!CreateEnhancedKeyUsage(
            &pbEKUEncoded,
            &cbEKUEncoded))
        goto ErrorReturn;

    rgExt[cExt].pszObjId = szOID_ENHANCED_KEY_USAGE;
    rgExt[cExt].fCritical = FALSE;
    rgExt[cExt].Value.pbData = pbEKUEncoded;
    rgExt[cExt].Value.cbData = cbEKUEncoded;
    cExt++;

    if (g_wszSubjectDisplayName) {
        if (!CreateSpcCommonName(
                &pbSpcCommonNameEncoded,
                &cbSpcCommonNameEncoded))
            goto ErrorReturn;
        rgExt[cExt].pszObjId = szOID_COMMON_NAME;
        rgExt[cExt].fCritical = FALSE;
        rgExt[cExt].Value.pbData = pbSpcCommonNameEncoded;
        rgExt[cExt].Value.cbData = cbSpcCommonNameEncoded;
        cExt++;
    }

    Cert.rgExtension = rgExt;
    Cert.cExtension = cExt;

    //
    // Sign and encode the certificate
    //
    cbCertEncoded = 0;
    CryptSignAndEncodeCertificate(
        hIssuerProv,
        g_dwIssuerKeySpec,
        X509_ASN_ENCODING,
        X509_CERT_TO_BE_SIGNED,
        &Cert,
        &Cert.SignatureAlgorithm,
        NULL,                       // pvHashAuxInfo
        NULL,                       // pbEncoded
        &cbCertEncoded
        );
    if (cbCertEncoded == 0) {
        ERROR_OUT(("CryptSignAndEncodeCertificate failed: %x", GetLastError()));
        goto ErrorReturn;
    }
    pbCertEncoded = new BYTE[cbCertEncoded];
    if (pbCertEncoded == NULL) goto ErrorReturn;
    if (!CryptSignAndEncodeCertificate(
            hIssuerProv,
            g_dwIssuerKeySpec,
            X509_ASN_ENCODING,
            X509_CERT_TO_BE_SIGNED,
            &Cert,
            &Cert.SignatureAlgorithm,
            NULL,                       // pvHashAuxInfo
            pbCertEncoded,
            &cbCertEncoded
            )) {
        ERROR_OUT(("CryptSignAndEncodeCertificate(2) failed: %x", GetLastError()));
        goto ErrorReturn;
    }

    // Output the encoded certificate to an cerificate store

    ASSERT(g_wszSubjectStore);
    ASSERT(AT_KEYEXCHANGE == g_dwSubjectKeySpec);

    if((!SaveCertToStore(hSubjectProv,
            hStore,
            g_dwSubjectStoreFlag,
            pbCertEncoded,
            cbCertEncoded,
            g_wszSubjectKey,
            g_dwSubjectKeySpec,
            g_wszSubjectProviderName,
            g_dwProvType)))
    {
        ERROR_OUT(("SaveCertToStore failed: %x", GetLastError()));
        goto ErrorReturn;

    }

    fResult = TRUE;
    goto CommonReturn;

ErrorReturn:
    fResult = FALSE;
CommonReturn:

    PvkFreeCryptProv(hSubjectProv, g_wszSubjectProviderName,
                    g_dwProvType,pwszTmpSubjectContainer);

    //free the cert store
    if(hStore)
         CertCloseStore(hStore, 0);
    if (pIssuerCertContext)
        CertFreeCertificateContext(pIssuerCertContext);
    if (pAllocSubjectPubKeyInfo)
        delete (pAllocSubjectPubKeyInfo);
    if (pbSubjectEncoded)
        delete (pbSubjectEncoded);
    if (pbEKUEncoded)
        delete (pbEKUEncoded);
    if (pbSpcCommonNameEncoded)
        delete (pbSpcCommonNameEncoded);
    if (pbCertEncoded)
        delete (pbCertEncoded);
    if (hIssuerProv)
        CryptReleaseContext(hIssuerProv,0);

    return fResult;
}

//+-------------------------------------------------------------------------
//  save the certificate to a certificate store.  Attach private key information
//  to the certificate
//--------------------------------------------------------------------------
BOOL    SaveCertToStore(
                HCRYPTPROV hProv,
                HCERTSTORE hStore,        DWORD dwFlag,
                BYTE *pbEncodedCert,    DWORD cbEncodedCert,
                LPWSTR wszPvk,
                DWORD dwKeySpecification,
                LPWSTR wszCapiProv,        DWORD dwCapiProvType)
{
        BOOL                    fResult=FALSE;
        PCCERT_CONTEXT            pCertContext=NULL;
        CRYPT_KEY_PROV_INFO        KeyProvInfo;

        HCRYPTPROV              hDefaultProvName=NULL;
        DWORD                   cbData=0;
        LPSTR                   pszName=NULL;
        LPWSTR                  pwszName=NULL;

        //init
        ClearStruct(&KeyProvInfo);

        //add the encoded certificate to store
        if(!CertAddEncodedCertificateToStore(
                    hStore,
                    X509_ASN_ENCODING,
                    pbEncodedCert,
                    cbEncodedCert,
                    CERT_STORE_ADD_REPLACE_EXISTING,
                    &pCertContext))
            goto CLEANUP;

        //add properties to the certificate
        KeyProvInfo.pwszContainerName=wszPvk;
        KeyProvInfo.pwszProvName=wszCapiProv,
        KeyProvInfo.dwProvType=dwCapiProvType,
        KeyProvInfo.dwKeySpec=dwKeySpecification;

        if ( g_dwSubjectStoreFlag == CERT_SYSTEM_STORE_LOCAL_MACHINE )
        {
            // If this is a local machine cert, set the keyset flags
            // indicating that the private key will be under HKLM
            KeyProvInfo.dwFlags = CRYPT_MACHINE_KEYSET;
        }

        ASSERT(AT_KEYEXCHANGE == dwKeySpecification);

        //if wszCapiProv is NULL, we get the default provider name
        if(NULL==wszCapiProv)
        {
            //get the default provider
            if(CryptAcquireContext(&hDefaultProvName,
                                    NULL,
                                    NULL,
                                    KeyProvInfo.dwProvType,
                                    CRYPT_VERIFYCONTEXT))
            {

                //get the provider name
                if(CryptGetProvParam(hDefaultProvName,
                                    PP_NAME,
                                    NULL,
                                    &cbData,
                                    0) && (0!=cbData))
                {

                    if(pszName= new CHAR[cbData])
                    {
                        if(CryptGetProvParam(hDefaultProvName,
                                            PP_NAME,
                                            (BYTE *)pszName,
                                            &cbData,
                                            0))
                        {
                            pwszName= AnsiToUnicode(pszName);

                            KeyProvInfo.pwszProvName=pwszName;
                        }
                    }
                }
            }
        }

        //free the provider as we want
        if(hDefaultProvName)
            CryptReleaseContext(hDefaultProvName, 0);

        hDefaultProvName=NULL;

        //add property related to the key container
        if(!CertSetCertificateContextProperty(
                pCertContext,
                CERT_KEY_PROV_INFO_PROP_ID,
                0,
                &KeyProvInfo))
            goto CLEANUP;

        //
        // Load the display name from resource and create a blob to
        // set the cert friendly name.
        //
        CHAR szFriendlyName[128];

        if (!LoadString(hModule, IDS_DEFNAME, szFriendlyName,
                                    sizeof(szFriendlyName)))
        {
            ERROR_OUT(("LoadString failed: %d", GetLastError()));
            goto CLEANUP;
        }

        WCHAR *pwszFriendlyName;

        pwszFriendlyName = AnsiToUnicode ( szFriendlyName );

        if ( NULL == pwszFriendlyName )
        {
            ERROR_OUT(("AnsiToUnicode failed"));
            goto CLEANUP;
        }

        CRYPT_DATA_BLOB FriendlyName;

        FriendlyName.pbData = (PBYTE)pwszFriendlyName;
        FriendlyName.cbData = ( lstrlenW(pwszFriendlyName) + 1 ) *
                                sizeof(WCHAR);

        if(!CertSetCertificateContextProperty(
                pCertContext,
                CERT_FRIENDLY_NAME_PROP_ID,
                0,
                &FriendlyName))
            goto CLEANUP;

        //
        // Add magic ID
        //
        CRYPT_DATA_BLOB MagicBlob;
        DWORD dwMagic;

        dwMagic = NMMKCERT_MAGIC;
        MagicBlob.pbData = (PBYTE)&dwMagic;
        MagicBlob.cbData = sizeof(dwMagic);

        if(!CertSetCertificateContextProperty(
                pCertContext,
                CERT_FIRST_USER_PROP_ID,
                0,
                &MagicBlob))
            goto CLEANUP;

        fResult=TRUE;

CLEANUP:

        if (pwszFriendlyName)
            delete pwszFriendlyName;

        //free the cert context
        if(pCertContext)
            CertFreeCertificateContext(pCertContext);

        if(pszName)
            delete (pszName);

        if(pwszName)
           delete pwszName;

        if(hDefaultProvName)
            CryptReleaseContext(hDefaultProvName, 0);

        return fResult;

}

//+-------------------------------------------------------------------------
//  Verify the issuer's certificate. The public key in the certificate
//  must match the public key associated with the private key in the
//  issuer's provider
//--------------------------------------------------------------------------
BOOL VerifyIssuerKey(
    IN HCRYPTPROV hProv,
    IN PCERT_PUBLIC_KEY_INFO pIssuerKeyInfo
    )
{
    BOOL fResult;
    PCERT_PUBLIC_KEY_INFO pPubKeyInfo = NULL;
    DWORD cbPubKeyInfo;

    // Get issuer's public key
    cbPubKeyInfo = 0;
    CryptExportPublicKeyInfo(
        hProv,                        
        g_dwIssuerKeySpec,
        X509_ASN_ENCODING,
        NULL,               // pPubKeyInfo
        &cbPubKeyInfo
        );
    if (cbPubKeyInfo == 0)
    {
        ERROR_OUT(("CryptExportPublicKeyInfo failed: %x", GetLastError()));
        goto ErrorReturn;
    }
    if (NULL == (pPubKeyInfo = (PCERT_PUBLIC_KEY_INFO) new BYTE[cbPubKeyInfo]))
        goto ErrorReturn;
    if (!CryptExportPublicKeyInfo(
            hProv,
            g_dwIssuerKeySpec,
            X509_ASN_ENCODING,
            pPubKeyInfo,
            &cbPubKeyInfo
            )) {
        ERROR_OUT(("CrypteExportPublicKeyInfo(2) failed: %x", GetLastError()));
        goto ErrorReturn;
    }

    if (!CertComparePublicKeyInfo(
            X509_ASN_ENCODING,
            pIssuerKeyInfo,
            pPubKeyInfo)) {
        // BUGBUG:: This might be the test root with an incorrectly
        // encoded public key. Convert to the capi representation and
        // compare.
        BYTE rgProvKey[256]; //BUGBUG needs appropriate constant or calc
        BYTE rgCertKey[256]; //BUGBUG needs appropriate constant or calc
        DWORD cbProvKey = sizeof(rgProvKey);
        DWORD cbCertKey = sizeof(rgCertKey);

        if (!CryptDecodeObject(X509_ASN_ENCODING, RSA_CSP_PUBLICKEYBLOB,
                    pIssuerKeyInfo->PublicKey.pbData,
                    pIssuerKeyInfo->PublicKey.cbData,
                    0,                  // dwFlags
                    rgProvKey,
                    &cbProvKey)                             ||
            !CryptDecodeObject(X509_ASN_ENCODING, RSA_CSP_PUBLICKEYBLOB,
                    pPubKeyInfo->PublicKey.pbData,
                    pPubKeyInfo->PublicKey.cbData,
                    0,                  // dwFlags
                    rgCertKey,
                    &cbCertKey)                             ||
                cbProvKey == 0 || cbProvKey != cbCertKey    ||
                memcmp(rgProvKey, rgCertKey, cbProvKey) != 0) {
            ERROR_OUT(("mismatch: %x", GetLastError()));
            goto ErrorReturn;
        }
    }

    fResult = TRUE;
    goto CommonReturn;

ErrorReturn:
    fResult = FALSE;
CommonReturn:
    if (pPubKeyInfo)
        delete (pPubKeyInfo);
    return fResult;
}

//+-------------------------------------------------------------------------
//  Get the subject's private key provider
//--------------------------------------------------------------------------
HCRYPTPROV GetSubjectProv(OUT LPWSTR *ppwszTmpContainer)
{
    HCRYPTPROV    hProv=0;
    WCHAR        wszKeyName[40] = L"Subject Key";
    int            ids;
    WCHAR       *wszRegKeyName=NULL;
    BOOL        fResult;
    HCRYPTKEY    hKey=NULL;
    GUID        TmpContainerUuid;

    //try to get the hProv from the private key container
    if(S_OK != PvkGetCryptProv(NULL,
                                wszKeyName,
                                g_wszSubjectProviderName,
                                g_dwProvType,
                                NULL,
                                g_wszSubjectKey,
                                &g_dwSubjectKeySpec,
                                ppwszTmpContainer,
                                &hProv))
        hProv=0;

    //generate the private keys
    if (0 == hProv)
    {
        //now that we have to generate private keys, generate
        //AT_KEYEXCHANGE key

        // If there is an existing container with the name of the
        // one we are about to create, attempt to delete it first so
        // that creating it won't fail. This should only happen if the
        // container exists but we were unable to acquire a context to
        // it previously.
        CryptAcquireContextU(
                &hProv,
                g_wszSubjectKey,
                g_wszSubjectProviderName,
                g_dwProvType,
                CRYPT_DELETEKEYSET |  
                    ( g_dwSubjectStoreFlag == CERT_SYSTEM_STORE_LOCAL_MACHINE ?
                        CRYPT_MACHINE_KEYSET : 0 ));

        // Open a new key container
        if (!CryptAcquireContextU(
                &hProv,
                g_wszSubjectKey,
                g_wszSubjectProviderName,
                g_dwProvType,
                CRYPT_NEWKEYSET |
                    ( g_dwSubjectStoreFlag == CERT_SYSTEM_STORE_LOCAL_MACHINE ?
                        CRYPT_MACHINE_KEYSET : 0 )))
        {
            ERROR_OUT(("CryptAcquireContext failed: %x", GetLastError()));
            goto CreateKeyError;
        }
        
        //generate new keys in the key container - make sure its EXPORTABLE
        //for SCHANNEL! (Note: remove that when SCHANNEL no longer needs it).
        if (!CryptGenKey( hProv, g_dwSubjectKeySpec, CRYPT_EXPORTABLE, &hKey))
        {
            ERROR_OUT(("CryptGenKey failed: %x", GetLastError()));
            goto CreateKeyError;
        }
        else
            CryptDestroyKey(hKey);

        //try to get the user key
        if (CryptGetUserKey( hProv, g_dwSubjectKeySpec, &hKey))
        {
            CryptDestroyKey(hKey);
        }
        else
        {
            // Doesn't have the specified public key
            CryptReleaseContext(hProv, 0);
            hProv=0;
        }

        if (0 == hProv )
        {
            ERROR_OUT(("sub key error: %x", GetLastError()));
            goto ErrorReturn;
        }
    } //hProv==0

    goto CommonReturn;

CreateKeyError:
ErrorReturn:
    if (hProv)
    {
        CryptReleaseContext(hProv, 0);
        hProv = 0;
    }
CommonReturn:
    if(wszRegKeyName)
        delete (wszRegKeyName);

    return hProv;
}



//+-------------------------------------------------------------------------
//  Allocate and get the public key info for the provider
//--------------------------------------------------------------------------
BOOL GetPublicKey(
    HCRYPTPROV hProv,
    PCERT_PUBLIC_KEY_INFO *ppPubKeyInfo
    )
{
    BOOL fResult;

    PCERT_PUBLIC_KEY_INFO pPubKeyInfo = NULL;
    DWORD cbPubKeyInfo;

    cbPubKeyInfo = 0;
    CryptExportPublicKeyInfo(
        hProv,
        g_dwSubjectKeySpec,
        X509_ASN_ENCODING,
        NULL,               // pPubKeyInfo
        &cbPubKeyInfo
        );
    if (cbPubKeyInfo == 0) {
        ERROR_OUT(("CryptExportPublicKeyInfo failed: %x", GetLastError()));
        goto ErrorReturn;
    }
    if (NULL == (pPubKeyInfo = (PCERT_PUBLIC_KEY_INFO) new BYTE[cbPubKeyInfo]))
        goto ErrorReturn;
    if (!CryptExportPublicKeyInfo(
            hProv,
            g_dwSubjectKeySpec,
            X509_ASN_ENCODING,
            pPubKeyInfo,
            &cbPubKeyInfo
            )) {
        ERROR_OUT(("CryptExportPublicKeyInfo(2) failed: %x", GetLastError()));
        goto ErrorReturn;
    }

    fResult = TRUE;
    goto CommonReturn;

ErrorReturn:
    fResult = FALSE;
    if (pPubKeyInfo) {
        delete (pPubKeyInfo);
        pPubKeyInfo = NULL;
    }
CommonReturn:
    *ppPubKeyInfo = pPubKeyInfo;
    return fResult;
}

//+-------------------------------------------------------------------------
//  Convert and encode the subject's X500 formatted name
//--------------------------------------------------------------------------
BOOL EncodeSubject(
        OUT BYTE **ppbEncoded,
        IN OUT DWORD *pcbEncoded
        )
{
    BOOL            fResult;
    DWORD            cbEncodedSubject=0;
    BYTE            *pbEncodedSubject=NULL;
    BYTE            *pbEncoded = NULL;
    DWORD            cbEncoded;

    //encode the wszSubjectX500Name into an encoded X509_NAME

    if(!CertStrToNameW(
        X509_ASN_ENCODING,
        g_wszSubjectX500Name,
        0,
        NULL,
        NULL,
        &cbEncodedSubject,
        NULL))
    {
        ERROR_OUT(("CertStrToNameW failed: %x", GetLastError()));
        goto ErrorReturn;
    }

    pbEncodedSubject = new BYTE[cbEncodedSubject];
    if (pbEncodedSubject == NULL) goto ErrorReturn;    

    if(!CertStrToNameW(
        X509_ASN_ENCODING,
        g_wszSubjectX500Name,
        0,
        NULL,
        pbEncodedSubject,
        &cbEncodedSubject,
        NULL))
    {
        ERROR_OUT(("CertStrToNameW(2) failed: %x", GetLastError()));
        goto ErrorReturn;
    }

    cbEncoded=cbEncodedSubject;
    pbEncoded=pbEncodedSubject;

    fResult = TRUE;
    goto CommonReturn;

ErrorReturn:
    if (pbEncoded) {
        delete (pbEncoded);
        pbEncoded = NULL;
    }
    cbEncoded = 0;
    fResult = FALSE;
CommonReturn:
    *ppbEncoded = pbEncoded;
    *pcbEncoded = cbEncoded;
    return fResult;
}


// The test root's public key isn't encoded properly in the certificate.
// It's missing a leading zero to make it a unsigned integer.
static BYTE rgbTestRoot[] = {
    #include "root.h"
};
static CERT_PUBLIC_KEY_INFO TestRootPublicKeyInfo = {
    szOID_RSA_RSA, 0, NULL, sizeof(rgbTestRoot), rgbTestRoot, 0
};

static BYTE rgbTestRootInfoAsn[] = {
    #include "rootasn.h"
};

//+-------------------------------------------------------------------------
//  X509 Extensions: Allocate and Encode functions
//--------------------------------------------------------------------------

BOOL CreateEnhancedKeyUsage(
    OUT BYTE **ppbEncoded,
    IN OUT DWORD *pcbEncoded
    )
{
    BOOL               fResult = TRUE;
    LPBYTE             pbEncoded =NULL;
    DWORD              cbEncoded;
    PCERT_ENHKEY_USAGE pUsage =NULL;

    //
    // Allocate a cert enhanced key usage structure and fill it in
    //

    pUsage = (PCERT_ENHKEY_USAGE) new BYTE[sizeof(CERT_ENHKEY_USAGE) +
                                                2 * sizeof(LPSTR)];
    if ( pUsage != NULL )
    {
        pUsage->cUsageIdentifier = 2;
        pUsage->rgpszUsageIdentifier = (LPSTR *)((LPBYTE)pUsage+sizeof(CERT_ENHKEY_USAGE));

        pUsage->rgpszUsageIdentifier[0] = szOID_PKIX_KP_CLIENT_AUTH;
        pUsage->rgpszUsageIdentifier[1] = szOID_PKIX_KP_SERVER_AUTH;
    }
    else
    {
        fResult = FALSE;
    }

    //
    // Encode the usage
    //

    if ( fResult == TRUE )
    {
        fResult = CryptEncodeObject(
                       X509_ASN_ENCODING,
                       szOID_ENHANCED_KEY_USAGE,
                       pUsage,
                       NULL,
                       &cbEncoded
                       );

        if ( fResult == TRUE )
        {
            pbEncoded = new BYTE[cbEncoded];
            if ( pbEncoded != NULL )
            {
                fResult = CryptEncodeObject(
                               X509_ASN_ENCODING,
                               szOID_ENHANCED_KEY_USAGE,
                               pUsage,
                               pbEncoded,
                               &cbEncoded
                               );
            }
            else
            {
                fResult = FALSE;
            }
        }
    }

    //
    // Cleanup
    //

    delete (pUsage);

    if ( fResult == TRUE )
    {
        *ppbEncoded = pbEncoded;
        *pcbEncoded = cbEncoded;
    }
    else
    {
        delete (pbEncoded);
    }

    return( fResult );
}

BOOL CreateSpcCommonName(
        OUT BYTE **ppbEncoded,
        IN OUT DWORD *pcbEncoded
        )
{
    BOOL fResult;
    BYTE *pbEncoded = NULL;
    DWORD cbEncoded;

    CERT_NAME_VALUE NameValue;

    NameValue.dwValueType = CERT_RDN_UNICODE_STRING;
    NameValue.Value.pbData =  (BYTE *) g_wszSubjectDisplayName;
    NameValue.Value.cbData =0;

    cbEncoded = 0;
    CryptEncodeObject(X509_ASN_ENCODING, X509_UNICODE_NAME_VALUE,
            &NameValue,
            NULL,           // pbEncoded
            &cbEncoded
            );
    if (cbEncoded == 0) {
        ERROR_OUT(("CryptEncodeObject failed: %x", GetLastError()));
        goto ErrorReturn;
    }
    pbEncoded = new BYTE[cbEncoded];
    if (pbEncoded == NULL) goto ErrorReturn;
    if (!CryptEncodeObject(X509_ASN_ENCODING, X509_UNICODE_NAME_VALUE,
            &NameValue,
            pbEncoded,
            &cbEncoded
            )) {
        ERROR_OUT(("CryptEncodeObject failed: %x", GetLastError()));
        goto ErrorReturn;
    }

    fResult = TRUE;
    goto CommonReturn;

ErrorReturn:
    if (pbEncoded) {
        delete (pbEncoded);
        pbEncoded = NULL;
    }
    cbEncoded = 0;
    fResult = FALSE;
CommonReturn:
    *ppbEncoded = pbEncoded;
    *pcbEncoded = cbEncoded;
    return fResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\nmmkcert\root.h ===
0x30,0x47,0x02,0x40,0x81,0x55,0x22,0xB9,0x8A,0xA4,0x6F,0xED,0xD6,0xE7,0xD9,0x66,
0x0F,0x55,0xBC,0xD7,0xCD,0xD5,0xBC,0x4E,0x40,0x02,0x21,0xA2,0xB1,0xF7,0x87,0x30,
0x85,0x5E,0xD2,0xF2,0x44,0xB9,0xDC,0x9B,0x75,0xB6,0xFB,0x46,0x5F,0x42,0xB6,0x9D,
0x23,0x36,0x0B,0xDE,0x54,0x0F,0xCD,0xBD,0x1F,0x99,0x2A,0x10,0x58,0x11,0xCB,0x40,
0xCB,0xB5,0xA7,0x41,0x02,0x03,0x01,0x00,0x01
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\nmmkcert\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by makecert.rc
//
#define IDR_PVKROOT                 101
#define IDR_ROOTCERTIFICATE         102
#define IDS_DEFNAME                 103

// Next default values for new objects
//
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NO_MFC                     1
#define _APS_NEXT_RESOURCE_VALUE        104
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\nmrk\confirm.h ===
#ifndef __Confirm_h__
#define __Confirm_h__

#include "FilePane.h"

class CConfirmationSheet {

friend class CNmAkWiz;
    
private:
    static BOOL APIENTRY DlgProc( HWND hDlg, UINT message, WPARAM uParam, LPARAM lParam );
    static CConfirmationSheet* ms_pConfirmationSheet;


private: // DATA
    CPropertySheetPage m_PropertySheetPage;
	ULONG			   m_uIndex;
	CFilePanePropWnd2 *		   m_pFilePane;

private: 
    CConfirmationSheet( void );
    ~CConfirmationSheet( void );

    LPCPROPSHEETPAGE GetPropertySheet( void ) const { return &m_PropertySheetPage;}

    void _FillListBox( void );
	void _CreateFilePane(HWND hDlg);

public:
	CFilePanePropWnd2 * GetFilePane() { return m_pFilePane; }
	HWND GetListHwnd() { return GetDlgItem( m_pFilePane->GetHwnd(), IDC_LIST_SETTINGS ); }

};


#endif // __Confirm_h__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\nmrk\confirm.cpp ===
#include "precomp.h"
#include "resource.h"
#include "global.h"
#include "PropPg.h"
#include "SetSht.h"
#include "dslist.h"
#include "Confirm.h"
#include "nmakreg.h"
#include "nmakwiz.h"



////////////////////////////////////////////////////////////////////////////////////////////////////
// Static member vars
CConfirmationSheet* CConfirmationSheet::ms_pConfirmationSheet = NULL;

////////////////////////////////////////////////////////////////////////////////////////////////////
// Static member fns

BOOL APIENTRY CConfirmationSheet::DlgProc( HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam ) {

    switch( message )
    {
		case WM_INITDIALOG:
        {
			PropSheet_SetWizButtons( GetParent( hDlg ), PSWIZB_NEXT | PSWIZB_BACK ); 
			ms_pConfirmationSheet->_CreateFilePane(hDlg);
			return TRUE;
            break;
        }

		case WM_NOTIFY:
        {
			switch( reinterpret_cast< NMHDR FAR* >( lParam )->code )
            {
				case PSN_QUERYCANCEL: 
					SetWindowLong( hDlg, DWL_MSGRESULT, !VerifyExitMessageBox());
					return TRUE;

                case PSN_SETACTIVE:
                    g_hwndActive = hDlg;
                    ms_pConfirmationSheet->_FillListBox( );
                    PropSheet_SetWizButtons( GetParent( hDlg ), PSWIZB_NEXT | PSWIZB_BACK ); 
					ms_pConfirmationSheet->m_pFilePane->Validate(FALSE);
			        return TRUE;

				case PSN_WIZBACK:
					if( !ms_pConfirmationSheet->m_pFilePane->Validate( TRUE ) )
					{
						SetWindowLong( hDlg, DWL_MSGRESULT, -1 );
						return TRUE;
					}
					break;

				case PSN_WIZNEXT:
					if( !ms_pConfirmationSheet->m_pFilePane->Validate( TRUE ) )
					{
						SetWindowLong( hDlg, DWL_MSGRESULT, -1 );
						return TRUE;
					}
					break;
			}
            break;
        }

		default:
			break;
	}

	return FALSE;
}


////////////////////////////////////////////////////////////////////////////////////////////////////
// Member fns


CConfirmationSheet::CConfirmationSheet() :
    m_PropertySheetPage( MAKEINTRESOURCE( IDD_PROPPAGE_DEFAULT ), 
						( DLGPROC ) CConfirmationSheet::DlgProc /*,
						PSP_HASHELP   */ 
                       ),
	m_uIndex( 0 ),
	m_pFilePane( NULL )
{
    ms_pConfirmationSheet = this;
}


CConfirmationSheet::~CConfirmationSheet( void ) 
{
	delete m_pFilePane;
    m_pFilePane = NULL;
    ms_pConfirmationSheet = NULL;
}

void CConfirmationSheet::_FillListBox(void)
{

	HWND hwndList = GetDlgItem( m_pFilePane->GetHwnd(), IDC_LIST_SETTINGS );

	ListBox_ResetContent( hwndList );

    int iLine = 0;

	iLine = g_pWiz->m_SettingsSheet.SpewToListBox( hwndList, iLine );
    iLine = g_pWiz->m_CallModeSheet.SpewToListBox( hwndList, iLine );

	// Note - 500 is just a large and arbitrary value
	ListBox_SetHorizontalExtent( hwndList, 500 );
}



void CConfirmationSheet::_CreateFilePane(HWND hDlg)
{
	RECT rect;

	GetClientRect(hDlg, &rect );
	int iHeight = rect.bottom - rect.top;
	int iWidth = rect.right - CPropertyDataWindow2::mcs_iLeft;
	
	m_pFilePane = new CFilePanePropWnd2(hDlg,
										IDD_FILEPANE_SUMMARY,
										TEXT("IDD_FILEPANE_SUMMARY"),
										0,
										CPropertyDataWindow2::mcs_iLeft,
										CPropertyDataWindow2::mcs_iTop,
										iWidth,
										iHeight );
	assert( m_pFilePane );
	HWND hwndCond = GetDlgItem( m_pFilePane->GetHwnd(), IDC_CREATE_CONFIGURATION_SUMMARY_FILE );
	m_pFilePane->ConnectControlsToCheck( IDC_CREATE_CONFIGURATION_SUMMARY_FILE, 2,
										new CControlID( hwndCond,
														IDC_CREATE_CONFIGURATION_SUMMARY_FILE,
														IDC_CONFIGURATION_SUMMARY_PATH,
														CControlID::EDIT ),
										new CControlID( hwndCond,
														IDC_CREATE_CONFIGURATION_SUMMARY_FILE,
														IDC_BROWSE_CONFIGURATION_SUMMARY,
														// Note this is not a check but I don't think I care
														CControlID::CHECK ) );

	m_pFilePane->SetFilePane( FALSE, IDC_CONFIGURATION_SUMMARY_PATH,
							IDC_CREATE_CONFIGURATION_SUMMARY_FILE,
							IDC_BROWSE_CONFIGURATION_SUMMARY,
							TEXT( "Text File (*.txt)" ),
							TEXT( ".txt" ),
							TEXT( "Summary.txt" ));

	m_pFilePane->ShowWindow( TRUE );
    m_pFilePane->SetCheck(IDC_CREATE_CONFIGURATION_SUMMARY_FILE, TRUE);

	if (g_pWiz->m_IntroSheet.GetFilePane()->OptionEnabled())
	{
		m_pFilePane->ReadSettings();
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\nmmkcert\nmpvkhlp.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1995 - 1996
//
//  File:       nmpvkhlp.h
//
//  History:    10-May-96   philh   created
//--------------------------------------------------------------------------

#ifndef __NMPVKHLP_H__
#define __NMPVKHLP_H__

#include "wincrypt.h"

#ifdef __cplusplus
extern "C" {
#endif

#ifndef PRIVATEKEYBLOB
#define PRIVATEKEYBLOB  0x7
#endif


    //+-------------------------------------------------------------------------
    //  Creates a temporary container in the provider and loads the private key
    //  from memory.
    //  For success, returns a handle to a cryptographic provider for the private
    //  key and the name of the temporary container. PrivateKeyReleaseContext must
    //  be called to release the hCryptProv and delete the temporary container.
    //
    //  PrivateKeyLoadFromMemory is called to load the private key into the
    //  temporary container.
    //--------------------------------------------------------------------------
    BOOL WINAPI
        PvkPrivateKeyAcquireContextFromMemory(IN LPCWSTR pwszProvName,
                                           IN DWORD dwProvType,
                                           IN BYTE *pbData,
                                           IN DWORD cbData,
                                           IN HWND hwndOwner,
                                           IN LPCWSTR pwszKeyName,
                                           IN OUT OPTIONAL DWORD *pdwKeySpec,
                                           OUT HCRYPTPROV *phCryptProv);

    //+-------------------------------------------------------------------------
    //  Releases the cryptographic provider and deletes the temporary container
    //  created by PrivateKeyAcquireContext or PrivateKeyAcquireContextFromMemory.
    //--------------------------------------------------------------------------
    BOOL WINAPI
        PvkPrivateKeyReleaseContext(IN HCRYPTPROV hCryptProv,
                                 IN LPCWSTR pwszProvName,
                                 IN DWORD dwProvType,
                                 IN LPWSTR pwszTmpContainer);

//+-------------------------------------------------------------------------
//  Acquiring hprovs, Trys the file first and then the KeyContainer. Use
//  PvkFreeCryptProv to release HCRYPTPROV and resources.
//--------------------------------------------------------------------------
    HCRYPTPROV WINAPI 
        PvkGetCryptProvU(IN HWND hwnd,
                         IN LPCWSTR pwszCaption,
                         IN LPCWSTR pwszCapiProvider,
                         IN DWORD   dwProviderType,
                         IN LPCWSTR pwszPrivKey,
                         OUT LPWSTR *ppwszTmpContainer);
    
    void WINAPI
        PvkFreeCryptProvU(IN HCRYPTPROV hProv,
                          IN LPCWSTR  pwszCapiProvider,
                          IN DWORD    dwProviderType,
                          IN LPWSTR   pwszTmpContainer);

//+-----------------------------------------------------------------------
//  
//  
//  Parameters:
//  Return Values:
//  Error Codes:
//     
//------------------------------------------------------------------------

void WINAPI PvkFreeCryptProv(IN HCRYPTPROV hProv,
                      IN LPCWSTR pwszCapiProvider,
                      IN DWORD dwProviderType,
                      IN LPWSTR pwszTmpContainer);

//+-----------------------------------------------------------------------
//  
//  
//  Parameters:
//  Return Values:
//  Error Codes:
//     
//------------------------------------------------------------------------
HRESULT WINAPI PvkGetCryptProv(	IN HWND hwnd,
							IN LPCWSTR pwszCaption,
							IN LPCWSTR pwszCapiProvider,
							IN DWORD   dwProviderType,
							IN LPCWSTR pwszPvkFile,
							IN LPCWSTR pwszKeyContainerName,
							IN DWORD   *pdwKeySpec,
							OUT LPWSTR *ppwszTmpContainer,
							OUT HCRYPTPROV *phCryptProv);

#ifdef _M_IX86
BOOL WINAPI CryptAcquireContextU(
    HCRYPTPROV *phProv,
    LPCWSTR lpContainer,
    LPCWSTR lpProvider,
    DWORD dwProvType,
    DWORD dwFlags
    );
#else
#define CryptAcquireContextU    CryptAcquireContextW
#endif

//+-------------------------------------------------------------------------
//  Private Key helper  error codes
//--------------------------------------------------------------------------
#define PVK_HELPER_BAD_PARAMETER        0x80097001
#define PVK_HELPER_BAD_PVK_FILE         0x80097002
#define PVK_HELPER_WRONG_KEY_TYPE       0x80097003
#define PVK_HELPER_PASSWORD_CANCEL      0x80097004

#ifdef __cplusplus
}       // Balance extern "C" above
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\nmmkcert\rootasn.h ===
0x30,0x5B,0x30,0x0D,0x06,0x09,0x2A,0x86,0x48,0x86,0xF7,0x0D,0x01,0x01,0x01,0x05,
0x00,0x03,0x4A,0x00,0x30,0x47,0x02,0x40,0x81,0x55,0x22,0xB9,0x8A,0xA4,0x6F,0xED,
0xD6,0xE7,0xD9,0x66,0x0F,0x55,0xBC,0xD7,0xCD,0xD5,0xBC,0x4E,0x40,0x02,0x21,0xA2,
0xB1,0xF7,0x87,0x30,0x85,0x5E,0xD2,0xF2,0x44,0xB9,0xDC,0x9B,0x75,0xB6,0xFB,0x46,
0x5F,0x42,0xB6,0x9D,0x23,0x36,0x0B,0xDE,0x54,0x0F,0xCD,0xBD,0x1F,0x99,0x2A,0x10,
0x58,0x11,0xCB,0x40,0xCB,0xB5,0xA7,0x41,0x02,0x03,0x01,0x00,0x01
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\nmmkcert\pvkutil.cpp ===
#include "global.h"


//+-------------------------------------------------------------------------
//  Private Key file definitions
//
//  The file consists of the FILE_HDR followed by cbEncryptData optional
//  bytes used to encrypt the private key and then the private key.
//  The private key is encrypted according to dwEncryptType.
//
//  The public key is included with the private key.
//--------------------------------------------------------------------------

typedef struct _FILE_HDR {
    DWORD               dwMagic;
    DWORD               dwVersion;
    DWORD               dwKeySpec;
    DWORD               dwEncryptType;
    DWORD               cbEncryptData;
    DWORD               cbPvk;
} FILE_HDR, *PFILE_HDR;

// BUGBUG: enum from pvk.h?
#ifndef ENTER_PASSWORD
#define ENTER_PASSWORD    0
#endif // ENTER_PASSWORD

#define PVK_FILE_VERSION_0          0
#define PVK_MAGIC                   0xb0b5f11e

// Private key encrypt types
#define PVK_NO_ENCRYPT                  0

#define MAX_PVK_FILE_LEN            4096

typedef BOOL (* PFNREAD)(HANDLE h, void * p, DWORD cb);

extern DWORD     g_dwSubjectStoreFlag;

//+-------------------------------------------------------------------------
//  Read & Write to memory fucntion
//--------------------------------------------------------------------------
typedef struct _MEMINFO {
    BYTE *  pb;
    DWORD   cb;
    DWORD   cbSeek;
} MEMINFO, * PMEMINFO;

static BOOL ReadFromMemory(
    IN HANDLE h,
    IN void * p,
    IN DWORD cb
    )
{
    PMEMINFO pMemInfo = (PMEMINFO) h;

    if (pMemInfo->cbSeek + cb <= pMemInfo->cb) {
        // copy the bytes
        memcpy(p, &pMemInfo->pb[pMemInfo->cbSeek], cb);
        pMemInfo->cbSeek += cb;
        return TRUE;
    } else {
        SetLastError(ERROR_END_OF_MEDIA);
        return FALSE;
    }
}

//+-------------------------------------------------------------------------
//  Converts the bytes into WCHAR hex
//
//  Needs (cb * 2 + 1) * sizeof(WCHAR) bytes of space in wsz
//--------------------------------------------------------------------------
static void BytesToWStr(ULONG cb, void* pv, LPWSTR wsz)
{
    BYTE* pb = (BYTE*) pv;
    for (ULONG i = 0; i<cb; i++) {
        int b;
        b = (*pb & 0xF0) >> 4;
        *wsz++ = (b <= 9) ? b + L'0' : (b - 10) + L'A';
        b = *pb & 0x0F;
        *wsz++ = (b <= 9) ? b + L'0' : (b - 10) + L'A';
        pb++;
    }
    *wsz++ = 0;
}

#define UUID_WSTR_BYTES ((sizeof(GUID) * 2 + 1) * sizeof(WCHAR))

//-------------------------------------------------------------------------
//
//    Call GetLastError and convert the return code to HRESULT
//--------------------------------------------------------------------------
HRESULT WINAPI SignError ()
{
    DWORD   dw = GetLastError ();
    HRESULT hr;
    if ( dw <= (DWORD) 0xFFFF )
        hr = HRESULT_FROM_WIN32 ( dw );
    else
        hr = dw;
    if ( ! FAILED ( hr ) )
    {
        // somebody failed a call without properly setting an error condition

        hr = E_UNEXPECTED;
    }
    return hr;
}

static BOOL LoadKeyW(
    IN HCRYPTPROV hCryptProv,
    IN HANDLE hRead,
    IN PFNREAD pfnRead,
    IN DWORD cbKeyData,
    IN HWND hwndOwner,
    IN LPCWSTR pwszKeyName,
    IN DWORD dwFlags,
    IN OUT OPTIONAL DWORD *pdwKeySpec
    )
{
    BOOL fResult;
    FILE_HDR Hdr;
    HCRYPTKEY hKey = 0;
    BYTE *pbPvk = NULL;
    DWORD cbPvk;

    // Read the file header and verify
    if (!pfnRead(hRead, &Hdr, sizeof(Hdr)))
    {
        ERROR_OUT(("can't read in-memory pvk file hdr"));
        goto BadPvkFile;
    }
    
    ASSERT( Hdr.dwMagic == PVK_MAGIC );

    // Treat as a "normal" private key file
    cbPvk = Hdr.cbPvk;
    if (Hdr.dwVersion != PVK_FILE_VERSION_0 ||
        Hdr.cbEncryptData > MAX_PVK_FILE_LEN ||
        cbPvk == 0 || cbPvk > MAX_PVK_FILE_LEN)
    goto BadPvkFile;

    if (pdwKeySpec) {
        DWORD dwKeySpec = *pdwKeySpec;
        *pdwKeySpec = Hdr.dwKeySpec;
        if (dwKeySpec && dwKeySpec != Hdr.dwKeySpec) {
            SetLastError(PVK_HELPER_WRONG_KEY_TYPE);
            goto ErrorReturn;
        }
    }

    // Allocate and read the private key
    if (NULL == (pbPvk = new BYTE[cbPvk]))
        goto ErrorReturn;
    if (!pfnRead(hRead, pbPvk, cbPvk))
        goto BadPvkFile;

    ASSERT(Hdr.dwEncryptType == PVK_NO_ENCRYPT);

    // Decrypt and import the private key
    if (!CryptImportKey(hCryptProv, pbPvk, cbPvk, 0, dwFlags,
            &hKey))
        goto ErrorReturn;

    fResult = TRUE;
    goto CommonReturn;

BadPvkFile:
    SetLastError(PVK_HELPER_BAD_PVK_FILE);
    if (pdwKeySpec)
        *pdwKeySpec = 0;
ErrorReturn:
    fResult = FALSE;
CommonReturn:
    if (pbPvk)
        delete (pbPvk);
    if (hKey)
        CryptDestroyKey(hKey);
    return fResult;
}

static BOOL AcquireKeyContextW(
    IN LPCWSTR pwszProvName,
    IN DWORD dwProvType,
    IN HANDLE hRead,
    IN PFNREAD pfnRead,
    IN DWORD cbKeyData,
    IN HWND hwndOwner,
    IN LPCWSTR pwszKeyName,
    IN OUT OPTIONAL DWORD *pdwKeySpec,
    OUT HCRYPTPROV *phCryptProv
    )
{
    BOOL fResult;
    HCRYPTPROV hProv = 0;
    GUID TmpContainerUuid;
    LPWSTR pwszTmpContainer = NULL;

    // Create a temporary keyset to load the private key into
    // UuidCreate(&TmpContainerUuid);
    if (CoCreateGuid((GUID *)&TmpContainerUuid) != S_OK)
    {
        goto ErrorReturn;
    }

    if (NULL == (pwszTmpContainer = (LPWSTR) new BYTE[
            6 * sizeof(WCHAR) + UUID_WSTR_BYTES]))
        goto ErrorReturn;
    LStrCpyW(pwszTmpContainer, L"TmpKey");
    BytesToWStr(sizeof(UUID), &TmpContainerUuid, pwszTmpContainer + 6);

    if (!CryptAcquireContextU(
            &hProv,
            pwszTmpContainer,
            pwszProvName,
            dwProvType,
            CRYPT_NEWKEYSET |
                ( g_dwSubjectStoreFlag == CERT_SYSTEM_STORE_LOCAL_MACHINE ?
                    CRYPT_MACHINE_KEYSET : 0 )))
        goto ErrorReturn;

    if (!LoadKeyW(
            hProv,
            hRead,
            pfnRead,
            cbKeyData,
            hwndOwner,
            pwszKeyName,
            0,              // dwFlags
            pdwKeySpec
            ))
        goto DeleteKeySetReturn;

    fResult = TRUE;
    goto CommonReturn;

DeleteKeySetReturn:
    CryptReleaseContext(hProv, 0);
    CryptAcquireContextU(
        &hProv,
        pwszTmpContainer,
        pwszProvName,
        dwProvType,
        CRYPT_DELETEKEYSET
        );
    hProv = 0;
ErrorReturn:
    if (hProv) {
        CryptReleaseContext(hProv, 0);
        hProv = 0;
    }
    fResult = FALSE;

CommonReturn:
    if (pwszTmpContainer) {
        delete (pwszTmpContainer);
    }
    *phCryptProv = hProv;
    return fResult;
}

//+-------------------------------------------------------------------------
//  Creates a temporary container in the provider and loads the private key
//  from memory.
//  For success, returns a handle to a cryptographic provider for the private
//  key and the name of the temporary container. PrivateKeyReleaseContext must
//  be called to release the hCryptProv and delete the temporary container.
//
//  PrivateKeyLoadFromMemory is called to load the private key into the
//  temporary container.
//--------------------------------------------------------------------------
BOOL
WINAPI
PvkPrivateKeyAcquireContextFromMemory(
    IN LPCWSTR pwszProvName,
    IN DWORD dwProvType,
    IN BYTE *pbData,
    IN DWORD cbData,
    IN HWND hwndOwner,
    IN LPCWSTR pwszKeyName,
    IN OUT OPTIONAL DWORD *pdwKeySpec,
    OUT HCRYPTPROV *phCryptProv
    )
{

    HRESULT hr = S_OK;
    if(FAILED(hr))
        return FALSE;

    MEMINFO MemInfo;

    MemInfo.pb = pbData;
    MemInfo.cb = cbData;
    MemInfo.cbSeek = 0;
    BOOL fhr = AcquireKeyContextW(
        pwszProvName,
        dwProvType,
        (HANDLE) &MemInfo,
        ReadFromMemory,
        cbData,
        hwndOwner,
        pwszKeyName,
        pdwKeySpec,
        phCryptProv
        );
    return fhr;
}

//+-------------------------------------------------------------------------
//  Releases the cryptographic provider and deletes the temporary container
//  created by PrivateKeyAcquireContext or PrivateKeyAcquireContextFromMemory.
//--------------------------------------------------------------------------
BOOL
WINAPI
PvkPrivateKeyReleaseContext(
    IN HCRYPTPROV hCryptProv,
    IN LPCWSTR pwszProvName,
    IN DWORD dwProvType,
    IN LPWSTR pwszTmpContainer
    )
{

    HRESULT hr = S_OK;

    if (hCryptProv)
        CryptReleaseContext(hCryptProv, 0);

    if (pwszTmpContainer) {
        // Delete the temporary container for the private key from
        // the provider
        //
        // Note: for CRYPT_DELETEKEYSET, the returned hCryptProv is undefined
        // and must not be released.
        CryptAcquireContextU(
                &hCryptProv,
                pwszTmpContainer,
                pwszProvName,
                dwProvType,
                CRYPT_DELETEKEYSET
                );
        delete (pwszTmpContainer);
    }

    return TRUE;
}

//+-------------------------------------------------------------------------
//  Get crypto provider to based on either the pvkfile or key container name
//--------------------------------------------------------------------------
HRESULT WINAPI PvkGetCryptProv(    IN HWND hwnd,
                            IN LPCWSTR pwszCaption,
                            IN LPCWSTR pwszCapiProvider,
                            IN DWORD   dwProviderType,
                            IN LPCWSTR pwszPvkFile,
                            IN LPCWSTR pwszKeyContainerName,
                            IN DWORD   *pdwKeySpec,
                            OUT LPWSTR *ppwszTmpContainer,
                            OUT HCRYPTPROV *phCryptProv)
{
    HANDLE    hFile=NULL;
    HRESULT    hr=E_FAIL;
    DWORD    dwRequiredKeySpec=0;

    //Init
    *ppwszTmpContainer=NULL;
    *phCryptProv=NULL;

    //get the provider handle based on the key container name
    if(!CryptAcquireContextU(phCryptProv,
                pwszKeyContainerName,
                pwszCapiProvider,
                dwProviderType,
                ( g_dwSubjectStoreFlag == CERT_SYSTEM_STORE_LOCAL_MACHINE ?
                    CRYPT_MACHINE_KEYSET : 0 )))
        return SignError();

    dwRequiredKeySpec=*pdwKeySpec;

    //make sure *pdwKeySpec is the correct key spec
    HCRYPTKEY hPubKey;
    if (CryptGetUserKey(
        *phCryptProv,
        dwRequiredKeySpec,
        &hPubKey
        )) 
    {
        CryptDestroyKey(hPubKey);
        *pdwKeySpec=dwRequiredKeySpec;
        return S_OK;
    } 
    else 
    {
        // Doesn't have the specified public key
        hr=SignError();
        CryptReleaseContext(*phCryptProv, 0);
        *phCryptProv=NULL;
        return hr;
    }        
}



void WINAPI PvkFreeCryptProv(IN HCRYPTPROV hProv,
                      IN LPCWSTR pwszCapiProvider,
                      IN DWORD dwProviderType,
                      IN LPWSTR pwszTmpContainer)
{
    
    if (pwszTmpContainer) {
        // Delete the temporary container for the private key from
        // the provider
        PvkPrivateKeyReleaseContext(hProv,
                                    pwszCapiProvider,
                                    dwProviderType,
                                    pwszTmpContainer);
    } else {
        if (hProv)
            CryptReleaseContext(hProv, 0);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\nmrk\controlid.h ===
#ifndef _ControlID_h_
#define _ControlID_h_

#include <list>
using namespace std;

#define MAX_DIGITS 16

class CControlID
{
	public:
		typedef enum eTypes
		{
			EDIT,
			CHECK,
			SLIDER,
			COMBO,
			EDIT_NUM,
			STATIC
		} IDTYPE;

	private:
		UINT m_ID;
		HWND m_hwndCond;
		UINT m_condID;
		UINT m_staticID;
		IDTYPE m_type;

	public:
		CControlID( HWND hwndCond, UINT condID, UINT ID, IDTYPE type )
			: m_ID( ID ), m_condID( condID ), m_hwndCond( hwndCond ), m_staticID( 0 ), m_type( type )
		{
		}

		CControlID( UINT ID, IDTYPE type )
			: m_ID( ID ), m_condID( 0 ), m_hwndCond( NULL ), m_staticID( 0 ), m_type( type )
		{
		}

		CControlID( IDTYPE type )
			: m_ID( 0 ), m_condID( 0 ), m_hwndCond( NULL ), m_staticID( 0 ), m_type( type )
		{
		}

		inline HWND GetCondHwnd() const
		{
			return m_hwndCond;
		}

		inline UINT GetCondID() const
		{
			return m_condID;
		}

		inline UINT GetID() const
		{
			return m_ID;
		}

		inline IDTYPE GetType() const
		{
			return m_type;
		}

		inline UINT GetStaticID() const
		{
			return m_staticID;
		}

		inline void SetStaticID( UINT ID )
		{
			m_staticID = ID;
		}

		void Reset( HWND hDlg )
		{
			switch( m_type )
			{
				case STATIC:
					break;

				case EDIT:
				case EDIT_NUM:
				{
					SetDlgItemText( hDlg, m_ID, TEXT("") );
					break;
				}
				case CHECK:
				{
					Button_SetCheck( GetDlgItem( hDlg, m_ID ), FALSE );
					break;
				}
				case SLIDER:
				{
					HWND hwndSlide = GetDlgItem( hDlg, m_ID );
					LONG lVal = TrackBar_GetRangeMin( hwndSlide );
					TrackBar_SetPos( hwndSlide, true, lVal );
					TCHAR szBuff[ MAX_DIGITS ];
					wsprintf( szBuff, "%d", lVal );
					SetDlgItemText( hDlg, m_staticID, szBuff );
					break;
				}
				case COMBO:
				{
					ComboBox_SetCurSel( GetDlgItem( hDlg, m_ID ), 0 );
					break;
				}
				default:
					assert( 0 );
					break;
			}
		}
		
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\nmrk\dslist.cpp ===
#include "precomp.h"
#include "resource.h"
#include <algorithm>
#include "global.h"
#include "PropPg.h"
#include "DSList.h"
#include "NmAkWiz.h"


////////////////////////////////////////////////////////////////////////////////////////////////////
// Static member vars
CCallModeSheet* CCallModeSheet::ms_pCallModeSheet = NULL;

////////////////////////////////////////////////////////////////////////////////////////////////////
// Static member fns

BOOL APIENTRY CCallModeSheet::DlgProc( HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam ) {
    
    TCHAR sz[ MAX_PATH ];

    switch( message )
    {
		case WM_INITDIALOG:
			ms_pCallModeSheet->_InitDialog(hDlg);
			ms_pCallModeSheet->_CreatePropWnd(hDlg);
			return TRUE;
            
        case WM_COMMAND:
        {
            if (ms_pCallModeSheet)
            {
                if (ms_pCallModeSheet->m_fGkActive)
                {
                    if (ms_pCallModeSheet->m_pGkPropWnd)
                        return(ms_pCallModeSheet->m_pGkPropWnd->DoCommand(wParam, lParam));
                }
                else
                {
                    if (ms_pCallModeSheet->m_pDsPropWnd)
                        return(ms_pCallModeSheet->m_pDsPropWnd->DoCommand(wParam, lParam));
                }
            }
            break;
        }
 
		case WM_NOTIFY:
			switch( reinterpret_cast< NMHDR FAR* >( lParam )->code ) {
				case PSN_QUERYCANCEL: 
					SetWindowLong( hDlg, DWL_MSGRESULT, !VerifyExitMessageBox());
					return TRUE;

                case PSN_SETACTIVE:
                    g_hwndActive = hDlg;
                    ms_pCallModeSheet->m_fGkActive = g_pWiz->m_SettingsSheet.IsGateKeeperModeSelected();

                    if (ms_pCallModeSheet->m_fGkActive)
                    {
                        if (ms_pCallModeSheet->m_pDsPropWnd)
                            ms_pCallModeSheet->m_pDsPropWnd->ShowWindow( FALSE );

                        if (ms_pCallModeSheet->m_pGkPropWnd)
                            ms_pCallModeSheet->m_pGkPropWnd->ShowWindow( TRUE );
                    }
                    else
                    {
                        if (ms_pCallModeSheet->m_pGkPropWnd)
                            ms_pCallModeSheet->m_pGkPropWnd->ShowWindow( FALSE );

                        if (ms_pCallModeSheet->m_pDsPropWnd)
                        	ms_pCallModeSheet->m_pDsPropWnd->ShowWindow( TRUE );
                    }
                	PropSheet_SetWizButtons( GetParent( hDlg ), PSWIZB_NEXT | PSWIZB_BACK ); 
			        return TRUE;

				case PSN_WIZNEXT:
					if (ms_pCallModeSheet->m_fGkActive)
                    {
                        if (ms_pCallModeSheet->m_pGkPropWnd)
                            ms_pCallModeSheet->m_pGkPropWnd->QueryWizNext();
                    }
                    else
                    {
                        if (ms_pCallModeSheet->m_pDsPropWnd)
                            ms_pCallModeSheet->m_pDsPropWnd->QueryWizNext();
                    }
					return TRUE;
			}

		default:
			break;

	}

	return FALSE;

}

////////////////////////////////////////////////////////////////////////////////////////////////////
// Member fns


CCallModeSheet::CCallModeSheet( void )
	: m_PropertySheetPage( MAKEINTRESOURCE( IDD_PROPPAGE_DEFAULT ), 
						( DLGPROC ) CCallModeSheet::DlgProc /*, 
						PSP_HASHELP   */
                       ),
	m_pDsPropWnd( NULL ),
    m_pGkPropWnd( NULL ),
    m_fGkActive( FALSE )
{
    assert(ms_pCallModeSheet == NULL);
    ms_pCallModeSheet = this; 
}


void CCallModeSheet::_CreatePropWnd(HWND hDlg)
{
	RECT rect;

	GetClientRect(hDlg, &rect );
	int iHeight = rect.bottom;
	int iWidth = rect.right - CPropertyDataWindow2::mcs_iLeft;

	m_pDsPropWnd = new CDsPropWnd2(hDlg, CPropertyDataWindow2::mcs_iLeft,
			CPropertyDataWindow2::mcs_iTop, iWidth, iHeight );

    m_pGkPropWnd = new CGkPropWnd2(hDlg, CPropertyDataWindow2::mcs_iLeft,
            CPropertyDataWindow2::mcs_iTop, iWidth, iHeight );
}

CCallModeSheet::~CCallModeSheet( void ) 
{
    delete m_pDsPropWnd;
    m_pDsPropWnd = NULL;

    delete m_pGkPropWnd;
    m_pGkPropWnd = NULL;

    ms_pCallModeSheet = NULL;
}


void CCallModeSheet::_InitDialog(HWND hDlg)
{
     // Set the buttons
	PropSheet_SetWizButtons( GetParent(hDlg ), PSWIZB_NEXT | PSWIZB_BACK ); 
}


int CCallModeSheet::SpewToListBox(HWND hwndList, int iStartLine )
{
    if (m_fGkActive)
    {
        if (m_pGkPropWnd)
            iStartLine = m_pGkPropWnd->SpewToListBox(hwndList, iStartLine);
    }
    else
    {
        if (m_pDsPropWnd)
            iStartLine = m_pDsPropWnd->SpewToListBox(hwndList, iStartLine);
    }

    return(iStartLine);
}



void CCallModeSheet::PrepSettings(void)
{
    if (m_pDsPropWnd)
        m_pDsPropWnd->PrepSettings(m_fGkActive);

    if (m_pGkPropWnd)
        m_pGkPropWnd->PrepSettings(m_fGkActive);
}


void CCallModeSheet::WriteSettings(void)
{
    if (m_pDsPropWnd)
        m_pDsPropWnd->WriteSettings(m_fGkActive);

    if (m_pGkPropWnd)
        m_pGkPropWnd->WriteSettings(m_fGkActive);
}


BOOL CCallModeSheet::WriteToINF(HANDLE hFile)
{
    if (m_pDsPropWnd)
        m_pDsPropWnd->WriteToINF(m_fGkActive, hFile);

    if (m_pGkPropWnd)
        m_pGkPropWnd->WriteToINF(m_fGkActive, hFile);

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\nmrk\dspropwnd2.h ===
#ifndef _DsPropWnd2_h_
#define _DsPropWnd2_h_

#include "PropWnd2.h"
#include <deque>
using namespace std;

class CWebViewInfo
{
public:
	CWebViewInfo()
	{
		m_szWebViewName  [0] = '\0';
		m_szWebViewURL   [0] = '\0';
		m_szWebViewServer[0] = '\0';
	}

	TCHAR m_szWebViewName[MAX_PATH];
	TCHAR m_szWebViewURL[MAX_PATH];
	TCHAR m_szWebViewServer[MAX_PATH];

	void SetWebView(LPCTSTR szServer, LPCTSTR szName=NULL, LPCTSTR szURL=NULL);
} ;

CWebViewInfo* GetWebViewInfo();

class CDsPropWnd2 : public CPropertyDataWindow2
{
	friend class CCallModeSheet;

private:
	static const int MAXSERVERS;

private:
	deque< LPTSTR >		m_serverDQ;
//	list< LPTSTR >		m_oldServerList;
	int					m_defaultServer;
	HWND				m_hwndList;

public:
	CDsPropWnd2( HWND hwndParent, int iX, int iY, int iWidth, int iHeight );
	~CDsPropWnd2();

	void ReadSettings( void );
	void WriteSettings( BOOL fGkMode );
	void SetButtons();
	BOOL WriteToINF( BOOL fGkMode, HANDLE hFile );
	int SpewToListBox( HWND hwndList, int iStartLine );
	void PrepSettings(BOOL fGkMode);
    BOOL DoCommand(WPARAM wParam, LPARAM lParam);
    void QueryWizNext(void);

	inline BOOL DirectoryEnabled()
	{
		HWND hwndBut = GetDlgItem( m_hwnd, IDC_ALLOW_USER_TO_USE_DIRECTORY_SERVICES );
		return hwndBut && Button_GetCheck( hwndBut );
	}

    inline BOOL GatewayEnabled()
    {
        HWND hwndBut = GetDlgItem( m_hwnd, IDC_CHECK_GATEWAY);
        return hwndBut && Button_GetCheck( hwndBut );
    }

	inline BOOL AllowUserToAdd()
	{
		HWND hwndBut = GetDlgItem( m_hwnd, IDC_PREVENT_THE_USER_FROM_ADDING_NEW_SERVERS );
		return hwndBut && !Button_GetCheck( hwndBut );
	}

	inline int CountServers()
	{
		return m_serverDQ.size();
	}

private:

	BOOL IsWebView(LPCTSTR szServer) { return(0 == lstrcmp(szServer, GetWebViewInfo()->m_szWebViewServer)); }
	BOOL IsWebView(int index) { return(IsWebView(m_serverDQ.at(index))); }
	void SetWebView(LPCTSTR szServer, LPCTSTR szName=NULL, LPCTSTR szURL=NULL);

	BOOL IsWebViewAllowed() { return(!IsDlgButtonChecked(m_hwnd, IDC_DISABLE_WEBDIR)); }

	BOOL IsDefault(int index) { return(index == m_defaultServer); }

	void _UpdateServerList();
	BOOL _SetAsDefault( int iIndex );
	void _EditCurSel( void );
	void _EditCurSelWebView();
	BOOL _DeleteCurSel( void );
	void _MoveCurSel( int iPlaces );
	void _AddServer( LPTSTR szServer );

	LRESULT CALLBACK _WndProc( HWND hwnd, UINT uiMsg, WPARAM wParam, LPARAM lParam );
	
private:
	static LRESULT CALLBACK DsPropWndProc( HWND hwnd, UINT uiMsg, WPARAM wParam, LPARAM lParam );
};




class CGkPropWnd2 : public CPropertyDataWindow2
{
	friend class CCallModeSheet;

public:
	CGkPropWnd2( HWND hwndParent, int iX, int iY, int iWidth, int iHeight );
	~CGkPropWnd2();

	void ReadSettings( void );
	void WriteSettings( BOOL fGkMode );
	void SetButtons();
	BOOL WriteToINF( BOOL fGkMode, HANDLE hFile );
	int  SpewToListBox( HWND hwndList, int iStartLine );
	void PrepSettings(BOOL fGkMode);
    BOOL DoCommand(WPARAM wParam, LPARAM lParam);
    void QueryWizNext();

private:
	void SetWebView(LPCTSTR szServer, LPCTSTR szName=NULL, LPCTSTR szURL=NULL);

	BOOL IsWebViewAllowed() { return(!IsDlgButtonChecked(m_hwnd, IDC_DISABLE_WEBDIR_GK)); }

	void _EditCurSelWebView();

	LRESULT CALLBACK _WndProc( HWND hwnd, UINT uiMsg, WPARAM wParam, LPARAM lParam );

private:
	static LRESULT CALLBACK GkPropWndProc( HWND hwnd, UINT uiMsg, WPARAM wParam, LPARAM lParam );
};




#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\nmrk\dslist.h ===
#pragma warning( disable : 4786 )
#include <list>
#include <string>

#ifndef __DSList_h__
#define __DSList_h__

#include "DsPropWnd2.h"

class CCallModeSheet
{

friend class CNmAkWiz;
friend class CConfirmationSheet;
    
private:
    static BOOL APIENTRY DlgProc( HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam );
    static CCallModeSheet* ms_pCallModeSheet;

public:
    int     SpewToListBox(HWND hwndList, int iStartLine);
    void    PrepSettings();
    void    WriteSettings();
    BOOL    WriteToINF(HANDLE hFile);

private: // DATA
    CPropertySheetPage  m_PropertySheetPage;
	CDsPropWnd2 *	    m_pDsPropWnd;
    CGkPropWnd2 *       m_pGkPropWnd;
    BOOL                m_fGkActive;    

private: 
    CCallModeSheet( void );
    ~CCallModeSheet( void );
    LPCPROPSHEETPAGE GetPropertySheet( void ) const { return &m_PropertySheetPage;}

private: // Helper Fns
	
    void _InitDialog(HWND hDlg);
	void _CreatePropWnd(HWND hDlg);

};





#endif // __DSList_h__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\nmrk\editserver.cpp ===
#include "precomp.h"
#include "resource.h"
#include "EditServer.h"
#include "nmakwiz.h"

CEditServer* CEditServer::ms_pThis = NULL;

CEditServer::CEditServer( HWND hwndParent, LPTSTR szServer, size_t cbLen )
	: m_hwnd( NULL ), m_hwndParent( hwndParent ), m_cbLen( cbLen )
{
	ms_pThis = this;
	m_szServerBuffer = new TCHAR[ m_cbLen ];
	lstrcpy( m_szServerBuffer, szServer );
}


CEditServer::~CEditServer()
{
	ms_pThis = NULL;
	delete [] m_szServerBuffer;
}

int CEditServer::ShowDialog()
{
	return DialogBox(  g_hInstance,  // handle to application instance
						  MAKEINTRESOURCE( IDD_DIALOG_EDIT_SERVERNAME ),  // identifies dialog box template
						  m_hwndParent,      // handle to owner window
						  (DLGPROC) _Proc, // pointer to dialog box procedure
						  );
}

BOOL CALLBACK CEditServer::_Proc(  HWND hwndDlg,  // handle to dialog box
					  UINT uMsg,     // message  
					  WPARAM wParam, // first message parameter
					  LPARAM lParam  // second message parameter
					  )
{
	switch( uMsg )
	{
		case WM_INITDIALOG:
		{
			HWND hwndEdit = GetDlgItem( hwndDlg, IDC_EDIT_SERVER_NAME );
			Edit_SetText( hwndEdit, ms_pThis->m_szServerBuffer );
			Edit_LimitText( hwndEdit, ms_pThis->m_cbLen - 1 );
			return TRUE;
			break;
		}
		case WM_COMMAND:
		{
            switch (GET_WM_COMMAND_ID(wParam, lParam))
			{
                case IDOK:
                {
                    switch (GET_WM_COMMAND_CMD(wParam, lParam))
                    {
                        case BN_CLICKED:
                        {
							HWND hwndEdit = GetDlgItem( hwndDlg, IDC_EDIT_SERVER_NAME );
							if( Edit_GetTextLength( hwndEdit ) )
							{
								if( !Edit_GetText( hwndEdit, ms_pThis->m_szServerBuffer, ms_pThis->m_cbLen ) )
								{
									ErrorMessage( TEXT("Edit_GetText"), GetLastError() );
								}
								EndDialog( hwndDlg, IDOK );
							}
							else
							{
								NmrkMessageBox(
                                    MAKEINTRESOURCE(IDS_REMOVE_SERVER),
                                    MAKEINTRESOURCE(IDS_EMPTY_SERVER),
									MB_ICONEXCLAMATION | MB_OK,
									hwndDlg);
							}
							return TRUE;
                            break;
                        }
                    }
                    break;
                }

                case IDCANCEL:
                {
                    switch (GET_WM_COMMAND_CMD(wParam, lParam))
                    {
                        case BN_CLICKED:
                        {
							EndDialog( hwndDlg, IDCANCEL );
							return TRUE;
                            break;
                        }
                    }
                    break;
                }
            }

            break;
        }
	}

	return 0;
}


CEditWebView* CEditWebView::ms_pThis = NULL;

CEditWebView::CEditWebView( HWND hwndParent, LPCTSTR szServer, LPCTSTR szName, LPCTSTR szURL, size_t cbLen )
	: m_hwndParent( hwndParent ), m_cbLen( cbLen ), m_bEditServer(TRUE)
{
	ms_pThis = this;

	m_szServerBuffer = new TCHAR[ m_cbLen ];
	lstrcpy( m_szServerBuffer, szServer );
	m_szNameBuffer = new TCHAR[ m_cbLen ];
	lstrcpy( m_szNameBuffer, szName );
	m_szURLBuffer = new TCHAR[ m_cbLen ];
	lstrcpy( m_szURLBuffer, szURL );
}


CEditWebView::~CEditWebView()
{
	ms_pThis = NULL;
	delete [] m_szServerBuffer;
	delete [] m_szNameBuffer;
	delete [] m_szURLBuffer;
}

int CEditWebView::ShowDialog()
{
	return DialogBox(  g_hInstance,  // handle to application instance
						  MAKEINTRESOURCE( IDD_DIALOG_EDIT_WEBVIEW ),  // identifies dialog box template
						  m_hwndParent,      // handle to owner window
						  _Proc, // pointer to dialog box procedure
						  );
}

BOOL CALLBACK CEditWebView::_Proc(  HWND hwndDlg,  // handle to dialog box
					  UINT uMsg,     // message  
					  WPARAM wParam, // first message parameter
					  LPARAM lParam  // second message parameter
					  )
{
	switch( uMsg )
	{
		case WM_INITDIALOG:
		{
			HWND hwndEdit;

			hwndEdit = GetDlgItem( hwndDlg, IDC_EDIT_SERVER_NAME );
			Edit_SetText( hwndEdit, ms_pThis->m_szServerBuffer );
			Edit_LimitText( hwndEdit, ms_pThis->m_cbLen - 1 );

			FORWARD_WM_NEXTDLGCTL(hwndDlg, hwndEdit, TRUE, SendMessage);
			if (!ms_pThis->GetEditServer())
			{
				Edit_SetReadOnly(hwndEdit, TRUE);
				FORWARD_WM_NEXTDLGCTL(hwndDlg, FALSE, FALSE, SendMessage);
			}

			hwndEdit = GetDlgItem( hwndDlg, IDC_EDIT_URL_NAME );
			Edit_SetText( hwndEdit, ms_pThis->m_szURLBuffer );
			Edit_LimitText( hwndEdit, ms_pThis->m_cbLen - 1 );

			hwndEdit = GetDlgItem( hwndDlg, IDC_EDIT_DISPLAY_NAME );
			Edit_SetText( hwndEdit, ms_pThis->m_szNameBuffer );
			Edit_LimitText( hwndEdit, ms_pThis->m_cbLen - 1 );

			// I already set the focus
			return FALSE;
			break;
		}
		case WM_COMMAND:
		{
            switch (GET_WM_COMMAND_ID(wParam, lParam))
			{
                case IDOK:
                {
                    switch (GET_WM_COMMAND_CMD(wParam, lParam))
                    {
                        case BN_CLICKED:
                        {
							if( GetDlgItemText( hwndDlg, IDC_EDIT_SERVER_NAME, ms_pThis->m_szServerBuffer, ms_pThis->m_cbLen )
								&& GetDlgItemText( hwndDlg, IDC_EDIT_URL_NAME, ms_pThis->m_szURLBuffer, ms_pThis->m_cbLen )
								&& GetDlgItemText( hwndDlg, IDC_EDIT_DISPLAY_NAME, ms_pThis->m_szNameBuffer, ms_pThis->m_cbLen ))
							{
								EndDialog( hwndDlg, IDOK );
							}
							else
							{
								NmrkMessageBox(
                                    MAKEINTRESOURCE(IDS_ERROR_NEEDALLFIELDS),
                                    MAKEINTRESOURCE(IDS_EDIT_WEBVIEW),
									MB_ICONEXCLAMATION | MB_OK,
									hwndDlg);
							}
							return TRUE;
                            break;
                        }
                    }
                    break;
                }

                case IDCANCEL:
                {
                    switch (GET_WM_COMMAND_CMD(wParam, lParam))
                    {
                        case BN_CLICKED:
                        {
							EndDialog( hwndDlg, IDCANCEL );
							return TRUE;
                            break;
                        }
                    }
                    break;
                }
            }

            break;
        }
	}

	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\nmrk\dspropwnd2.cpp ===
#include "precomp.h"
#include "resource.h"
#include "PropWnd2.h"
#include "DsPropWnd2.h"
#include "NmAkWiz.h"
#include "EditServer.h"
#include "WndProcs.h"
//#include "poldata.h"
#include "nmakreg.h"

#include <algorithm>

const int CDsPropWnd2::MAXSERVERS = 15;
const TCHAR c_szMSServer[] = TEXT("logon.netmeeting.microsoft.com");

CWebViewInfo* GetWebViewInfo()
{
	static CWebViewInfo g_wvi;
	return(&g_wvi);
}

BOOL IsMSServer(LPCTSTR szServer) { return(0 == lstrcmp(szServer, c_szMSServer)); }

// Read the WebView information, but only once
void ReadWebViewSettings(CPropertyDataWindow2 *pData)
{
	static BOOL g_bRead = FALSE;

	if (g_bRead)
	{
		return;
	}

	CWebViewInfo *pWebView = GetWebViewInfo();

	pData->ReadStringValue(KEYNAME_WEBVIEWNAME  , pWebView->m_szWebViewName  , CCHMAX(pWebView->m_szWebViewName  ));
	pData->ReadStringValue(KEYNAME_WEBVIEWURL   , pWebView->m_szWebViewURL   , CCHMAX(pWebView->m_szWebViewURL   ));
	pData->ReadStringValue(KEYNAME_WEBVIEWSERVER, pWebView->m_szWebViewServer, CCHMAX(pWebView->m_szWebViewServer));

	g_bRead = TRUE;
}

void WriteWebViewSettings(CPropertyDataWindow2 *pData)
{
	CWebViewInfo *pWebView = GetWebViewInfo();

	// If the WebView is the default, write blanks to the file
	LPCTSTR szWVName   = pWebView->m_szWebViewName  ;
	LPCTSTR szWVURL    = pWebView->m_szWebViewURL   ;
	LPCTSTR szWVServer = pWebView->m_szWebViewServer;
	if (IsMSServer(szWVServer))
	{
		szWVName = szWVURL = szWVServer = TEXT("");
	}

	pData->WriteStringValue(KEYNAME_WEBVIEWNAME  , szWVName  );
	pData->WriteStringValue(KEYNAME_WEBVIEWURL   , szWVURL   );
	pData->WriteStringValue(KEYNAME_WEBVIEWSERVER, szWVServer);
}

void WriteWebViewToINF(HANDLE hFile, BOOL bWebViewAllowed)
{
	CWebViewInfo *pWebView = GetWebViewInfo();

	// If the WebView is the default, write blanks to the file
	if (!bWebViewAllowed || IsMSServer(pWebView->m_szWebViewServer))
	{
		CPolicyData( CPolicyData::eKeyType_HKEY_CURRENT_USER, 
                     POLICIES_KEY, 
                     REGVAL_POL_INTRANET_WEBDIR_NAME,
					 CPolicyData::OpDelete()
                   ).SaveToINFFile( hFile );
		CPolicyData( CPolicyData::eKeyType_HKEY_CURRENT_USER, 
                     POLICIES_KEY, 
                     REGVAL_POL_INTRANET_WEBDIR_URL,
					 CPolicyData::OpDelete()
                   ).SaveToINFFile( hFile );
		CPolicyData( CPolicyData::eKeyType_HKEY_CURRENT_USER, 
                     POLICIES_KEY, 
                     REGVAL_POL_INTRANET_WEBDIR_SERVER,
					 CPolicyData::OpDelete()
                   ).SaveToINFFile( hFile );
	}
	else
	{
		CPolicyData( CPolicyData::eKeyType_HKEY_CURRENT_USER, 
                     POLICIES_KEY, 
                     REGVAL_POL_INTRANET_WEBDIR_NAME,
					 pWebView->m_szWebViewName
                   ).SaveToINFFile( hFile );
		CPolicyData( CPolicyData::eKeyType_HKEY_CURRENT_USER, 
                     POLICIES_KEY, 
                     REGVAL_POL_INTRANET_WEBDIR_URL,
					 pWebView->m_szWebViewURL
                   ).SaveToINFFile( hFile );
		CPolicyData( CPolicyData::eKeyType_HKEY_CURRENT_USER, 
                     POLICIES_KEY, 
                     REGVAL_POL_INTRANET_WEBDIR_SERVER,
					 pWebView->m_szWebViewServer
                   ).SaveToINFFile( hFile );
	}
}

void CWebViewInfo::SetWebView(LPCTSTR szServer, LPCTSTR szName, LPCTSTR szURL)
{
	lstrcpy(m_szWebViewServer, szServer);
	if (NULL != szName)
	{
		lstrcpy(m_szWebViewName, szName);
	}
	if (NULL != szURL)
	{
		lstrcpy(m_szWebViewURL, szURL);
	}
}

CDsPropWnd2::CDsPropWnd2( HWND hwndParent, int iX, int iY, int iWidth, int iHeight )
	: CPropertyDataWindow2( hwndParent, IDD_CHILDPAGE_ILSGATEWAY, TEXT("IDD_CHILDPAGE_ILSGATEWAY"), (WNDPROC) DsPropWndProc, 0, iX, iY, iWidth, iHeight, FALSE )
{
	SetWindowLong( m_hwnd, GWL_USERDATA, (long)this );
	Edit_LimitText( GetDlgItem( m_hwnd, IDC_EDIT_NEW_SERVER ), MAX_PATH );
    Edit_LimitText( GetDlgItem( m_hwnd, IDC_EDIT_GATEWAY ), MAX_PATH );

	m_hwndList = GetDlgItem( m_hwnd, IDC_LIST_SERVERS );

    ConnectControlsToCheck( IDC_CHECK_GATEWAY, 1,
        new CControlID(GetDlgItem(m_hwnd, IDC_CHECK_GATEWAY),
            IDC_CHECK_GATEWAY,
            IDC_EDIT_GATEWAY,
            CControlID::EDIT ) );

    PrepSettings(FALSE);
	SetButtons();
}

CDsPropWnd2::~CDsPropWnd2()
{
	deque< LPTSTR >::iterator it;
	for( it = m_serverDQ.begin(); it != m_serverDQ.end(); ++it )
	{
		delete [] *it;
	}
}


void CDsPropWnd2::QueryWizNext(void)
{
	bool bWarned = false;

    if (DirectoryEnabled())
	{
		CWebViewInfo *pWebView = GetWebViewInfo();
		if (('\0' == pWebView->m_szWebViewServer[0] ||
			IsMSServer(pWebView->m_szWebViewServer))
			&& IsWebViewAllowed())
		{
			// Just using default Web View information; see if the default
			// server is there
			for (int i=m_serverDQ.size()-1; ; --i)
			{
				if (i < 0)
				{
					// Got through the list without finding the default server
					NmrkMessageBox(MAKEINTRESOURCE(IDS_WEBDIR_AUTOADD), NULL, MB_OK | MB_ICONINFORMATION);
					bWarned = true;
					break;
				}

				if (IsMSServer(m_serverDQ.at(i)))
				{
					// Found the default server; no need to proceed
					break;
				}
			}
		}

		// Note that the MID may be automatically added even if users are not
		// allowed to add servers
		if (!bWarned && 0 == CountServers())
		{
			if (AllowUserToAdd())
			{
				NmrkMessageBox(MAKEINTRESOURCE(IDS_DSLIST_EMPTY), NULL, MB_OK | MB_ICONINFORMATION);
			}
			else
			{
				NmrkMessageBox(MAKEINTRESOURCE(IDS_DS_WILL_BE_EMPTY), NULL, MB_OK | MB_ICONINFORMATION);
			}
		}
	}
}

LRESULT CALLBACK CDsPropWnd2::DsPropWndProc( HWND hwnd, UINT uiMsg, WPARAM wParam, LPARAM lParam )
{
	switch( uiMsg )
	{
		case WM_VSCROLL:
		case WM_VKEYTOITEM:
		case WM_COMMAND:
		{
			CDsPropWnd2 * pPropWnd = (CDsPropWnd2 *)GetWindowLong( hwnd, GWL_USERDATA );
			return pPropWnd->_WndProc( hwnd, uiMsg, wParam, lParam );
			break;
		}
		default:
		{
			return DefWindowProc( hwnd, uiMsg, wParam, lParam );
			break;
		}
	}
}


BOOL CDsPropWnd2::DoCommand(WPARAM wParam, LPARAM lParam)
{
    return(_WndProc(m_hwnd, WM_COMMAND, wParam, lParam));
}


LRESULT CALLBACK CDsPropWnd2::_WndProc( HWND hwnd, UINT uiMsg, WPARAM wParam, LPARAM lParam )
{
	
	switch( uiMsg ) 
	{
		case WM_VSCROLL: 
		{
			OnMsg_VScroll( hwnd, wParam );
			return 0;
			break;
		} 
		case WM_VKEYTOITEM:
		{
			if( m_serverDQ.size() )
			{
				switch( LOWORD( wParam ) )
				{    
					case VK_DELETE:                     
					{
						_DeleteCurSel();
						return 0;
						break;
					}
				}
			}
			break;
		}
		case WM_COMMAND:
		{
            switch (GET_WM_COMMAND_ID(wParam, lParam))
            {
                case IDC_LIST_SERVERS:
                {
                    switch (GET_WM_COMMAND_CMD(wParam, lParam))
                    {
        				case LBN_SELCHANGE:
		        		{
				        	SetButtons();
        					return 0;
		        			break;
				        }

        				case LBN_DBLCLK:
		        		{
				        	_EditCurSel();
        					return 0;
		        			break;
				        }
                    }
                    break;
                }

                case IDC_BUTTON_SET_AS_DEFAULT:
                {
                    switch (GET_WM_COMMAND_CMD(wParam, lParam))
    				{
                        case BN_CLICKED:
                        {
							_SetAsDefault( ListBox_GetCurSel( m_hwndList ) );
							return 0;
							break;
						}
                    }
                    break;
                }

                case IDC_BUTTON_EDIT:
                {
                    switch (GET_WM_COMMAND_CMD(wParam, lParam))
					{
                        case BN_CLICKED:
                        {
							_EditCurSel();
							return 0;
							break;
						}
                    }
                    break;
                }

                case IDC_BUTTON_SET_WEBVIEW:
                {
                    switch (GET_WM_COMMAND_CMD(wParam, lParam))
					{
                        case BN_CLICKED:
                        {
							_EditCurSelWebView();
							return 0;
							break;
						}
                    }
                    break;
                }

				case IDC_BUTTON_REMOVE:
				{
                    switch (GET_WM_COMMAND_CMD(wParam, lParam))
                    {
                        case BN_CLICKED:
                        {
							_DeleteCurSel();
							return 0;
							break;
						}
                    }
                    break;
                }

				case IDC_BUTTON_UP:
				{
                    switch (GET_WM_COMMAND_CMD(wParam, lParam))
                    {
                        case BN_CLICKED:
                        {
							_MoveCurSel( -1 );
							return 0;
							break;
						}
                    }
                    break;
                }

				case IDC_BUTTON_DOWN:
				{
                    switch (GET_WM_COMMAND_CMD(wParam, lParam))
                    {
                        case BN_CLICKED:
                        {
							_MoveCurSel( 1 );
							return 0;
							break;
						}
                    }
                    break;
                }

				case IDC_BUTTON_ADDDIRECTORYSERVER:
				{
                    switch (GET_WM_COMMAND_CMD(wParam, lParam))
                    {
                        case BN_CLICKED:
                        {
							HWND hwndEdit = GetDlgItem( m_hwnd, IDC_EDIT_NEW_SERVER );
							if( Edit_GetTextLength( hwndEdit ) )
							{
								LPTSTR szServer = new TCHAR[ MAX_PATH ];
								Edit_GetText( hwndEdit, szServer, MAX_PATH );
								_AddServer( szServer );
								Edit_SetText( hwndEdit, TEXT("") );
							}
							else
							{
								NmrkMessageBox( MAKEINTRESOURCE(IDS_DSNAME_INVALID), NULL,
											MB_OK | MB_ICONEXCLAMATION );
							}

							return 0;
							break;
						}
                    }
                    break;
                }

				case IDC_ALLOW_USER_TO_USE_DIRECTORY_SERVICES:
				{
                    switch (GET_WM_COMMAND_CMD(wParam, lParam))
                    {
                        case BN_CLICKED:
                        {
							SetButtons();
							return 0;
							break;
						}
					}
					break;
				}

				case IDC_DISABLE_WEBDIR:
				{
                    switch (GET_WM_COMMAND_CMD(wParam, lParam))
                    {
                        case BN_CLICKED:
                        {
							_UpdateServerList();
							SetButtons();
							return 0;
							break;
						}
					}
					break;
				}
			}
			break;
		}	
	}
	
	return DefWindowProc( hwnd, uiMsg, wParam, lParam );
}

void CDsPropWnd2::SetButtons()
{
	BOOL bEnable = DirectoryEnabled();
	HWND hwndFocus = GetFocus();
	BOOL bFocusEnabled = IsWindowEnabled(hwndFocus);

	if( m_serverDQ.size() )
	{
		int iCurSel = ListBox_GetCurSel( m_hwndList );
		
		::EnableWindow( GetDlgItem( m_hwnd, IDC_BUTTON_UP ),
			bEnable && 1 < iCurSel && m_defaultServer != iCurSel );
		::EnableWindow( GetDlgItem( m_hwnd, IDC_BUTTON_DOWN ),
			bEnable && (m_serverDQ.size() - 1) != iCurSel && m_defaultServer != iCurSel );
		::EnableWindow( GetDlgItem( m_hwnd, IDC_BUTTON_SET_AS_DEFAULT ),
			bEnable && iCurSel != m_defaultServer );
		::EnableWindow( GetDlgItem( m_hwnd, IDC_BUTTON_SET_WEBVIEW ),
			bEnable
			&& IsWebViewAllowed()
			&& !(IsWebView(iCurSel) && IsMSServer(GetWebViewInfo()->m_szWebViewServer)) );
		::EnableWindow( GetDlgItem( m_hwnd, IDC_BUTTON_EDIT ),
			bEnable );
		::EnableWindow( GetDlgItem( m_hwnd, IDC_BUTTON_REMOVE ),
			bEnable );
	}
	else
	{
		::EnableWindow( GetDlgItem( m_hwnd, IDC_BUTTON_SET_AS_DEFAULT ),
			FALSE );
		::EnableWindow( GetDlgItem( m_hwnd, IDC_BUTTON_SET_WEBVIEW ),
			FALSE );
		::EnableWindow( GetDlgItem( m_hwnd, IDC_BUTTON_EDIT ),
			FALSE );
		::EnableWindow( GetDlgItem( m_hwnd, IDC_BUTTON_REMOVE ),
			FALSE );
		::EnableWindow( GetDlgItem( m_hwnd, IDC_BUTTON_UP ),
			FALSE );
		::EnableWindow( GetDlgItem( m_hwnd, IDC_BUTTON_DOWN ),
			FALSE );
	}

	::EnableWindow( GetDlgItem( m_hwnd, IDC_BUTTON_ADDDIRECTORYSERVER ),
		bEnable && m_serverDQ.size() != MAXSERVERS );
	::EnableWindow( GetDlgItem( m_hwnd, IDC_EDIT_NEW_SERVER ),
		bEnable && m_serverDQ.size() != MAXSERVERS );
	::EnableWindow( GetDlgItem( m_hwnd, IDC_PREVENT_THE_USER_FROM_ADDING_NEW_SERVERS ),
		bEnable );
    ::EnableWindow( GetDlgItem( m_hwnd, IDC_DISABLE_WEBDIR), bEnable);
	::EnableWindow( m_hwndList, bEnable );

	if (bFocusEnabled && !IsWindowEnabled(hwndFocus))
	{
		// We seem to have disabled the focus window. Let's try to set the
		// focus to an enabled window
		if (IsWindowEnabled(m_hwndList))
		{
			FORWARD_WM_NEXTDLGCTL(m_hwndParent, m_hwndList, TRUE, SendMessage);
		}
		else
		{
			FORWARD_WM_NEXTDLGCTL(m_hwndParent, FALSE, FALSE, SendMessage);
		}
	}
}

void CDsPropWnd2::_AddServer( LPTSTR szServer )
{
	int iSize = m_serverDQ.size();
	if( iSize > 0 && iSize < MAXSERVERS )
	{
		int iCurSel = ListBox_GetCurSel( m_hwndList );
		if( iCurSel == m_defaultServer )
		{
			++iCurSel;
		}

		deque< LPTSTR >::iterator it = m_serverDQ.begin();
		for( int i = 0; i < iCurSel; ++i )
		{
			++it;
		}

		m_serverDQ.insert( it, szServer );
		ListBox_InsertString( m_hwndList, iCurSel, szServer );

		ListBox_SetCurSel( m_hwndList, iCurSel );
	}
	else
	{
		m_serverDQ.push_front( szServer );
		ListBox_InsertString( m_hwndList, 0, szServer );
		_SetAsDefault( 0 );
	}
	SetButtons();
}

	

void CDsPropWnd2::_MoveCurSel( int iPlaces )
{
	int iCurSel = ListBox_GetCurSel( m_hwndList );
	int iNewPos = iCurSel + iPlaces;

	if( iNewPos == m_defaultServer )
	{
		_SetAsDefault( iCurSel );
	}
	else if( iCurSel == m_defaultServer )
	{
		_SetAsDefault( iNewPos );
	}
	else
	{
		LPTSTR szCur = m_serverDQ.at( iCurSel );
		LPTSTR szNew = m_serverDQ.at( iNewPos );

		m_serverDQ.at( iCurSel ) = szNew;
		m_serverDQ.at( iNewPos ) = szCur;

		if( iPlaces > 0 )
		{
			ListBox_DeleteString( m_hwndList, iCurSel );
			ListBox_InsertString( m_hwndList, iCurSel, m_serverDQ.at( iCurSel ) );

			ListBox_DeleteString( m_hwndList, iNewPos );
			ListBox_InsertString( m_hwndList, iNewPos, m_serverDQ.at( iNewPos ) );
		}
		else
		{
			ListBox_DeleteString( m_hwndList, iNewPos );
			ListBox_InsertString( m_hwndList, iNewPos, m_serverDQ.at( iNewPos ) );

			ListBox_DeleteString( m_hwndList, iCurSel );
			ListBox_InsertString( m_hwndList, iCurSel, m_serverDQ.at( iCurSel ) );
		}
	}
	ListBox_SetCurSel( m_hwndList, iNewPos );

	_UpdateServerList();

	SetButtons();
}

void CDsPropWnd2::PrepSettings( BOOL fGkMode )
{
	if (g_pWiz->m_IntroSheet.GetFilePane()->OptionEnabled())
	{
		ReadSettings();
	}
	else
	{
		deque <LPTSTR>::iterator it;
		for( it = m_serverDQ.begin(); it != m_serverDQ.end(); ++it )
		{
			delete [] *it;
		}

		m_serverDQ.erase( m_serverDQ.begin(), m_serverDQ.end() );


		LPTSTR szServerName = NULL;

		szServerName = new TCHAR[ MAX_PATH ];
		lstrcpy( szServerName, c_szMSServer );
		m_serverDQ.push_back( szServerName );

		m_defaultServer = 0;

		Button_SetCheck( GetDlgItem( m_hwnd, IDC_ALLOW_USER_TO_USE_DIRECTORY_SERVICES ), TRUE );
		Button_SetCheck( GetDlgItem( m_hwnd, IDC_PREVENT_THE_USER_FROM_ADDING_NEW_SERVERS ), FALSE );
        Button_SetCheck( GetDlgItem( m_hwnd, IDC_DISABLE_WEBDIR), FALSE);

        Button_SetCheck( GetDlgItem( m_hwnd, IDC_CHECK_GATEWAY), FALSE);
	}

	ListBox_ResetContent( m_hwndList );

	// Add Items to listbox
	deque< LPTSTR >::const_iterator it;
	int i = 0;
	for( it = m_serverDQ.begin(); it != m_serverDQ.end(); ++it, ++i )
	{
		ListBox_InsertString( m_hwndList, i, *it );
	}

	if( m_serverDQ.size() )
	{
		// This will do an _UpdateServerList for us
		_SetAsDefault( m_defaultServer );
	}
}

void CDsPropWnd2::_UpdateServerList()
{
	int iSel = ListBox_GetCurSel(m_hwndList);

	// We only want to find one WebView
	BOOL bFoundWebView = FALSE;

	for (int index=ListBox_GetCount(m_hwndList)-1; index>=0; --index)
	{
		TCHAR szNewText[MAX_PATH];
		lstrcpy(szNewText, m_serverDQ.at(index));

		BOOL bWebView = FALSE;
		if (!bFoundWebView)
		{
			bWebView = IsWebView(szNewText);
		}

		if (IsDefault(index))
		{
			lstrcat(szNewText, TEXT(" (Default)"));
		}
		if (bWebView)
		{
			bFoundWebView = TRUE;

			if (IsWebViewAllowed())
			{
				lstrcat(szNewText, TEXT(" (WebView)"));
			}
		}

		TCHAR szOldText[MAX_PATH];
		ListBox_GetText(m_hwndList, index, szOldText);
		if (lstrcmp(szOldText, szNewText) != 0)
		{
			ListBox_DeleteString(m_hwndList, index);
			ListBox_InsertString(m_hwndList, index, szNewText);
			if (iSel == index)
			{
				ListBox_SetCurSel(m_hwndList, iSel);
			}
		}
	}

	if (!bFoundWebView && !IsMSServer(GetWebViewInfo()->m_szWebViewServer))
	{
		SetWebView(c_szMSServer);
		_UpdateServerList();
	}
}

void CDsPropWnd2::_EditCurSel()
{
	int iCurSel = ListBox_GetCurSel( m_hwndList );
	LPTSTR szOldServer = m_serverDQ.at( iCurSel );
	CEditServer* pEditServer = new CEditServer( m_hwnd, szOldServer, MAX_PATH );
	
	if( pEditServer->ShowDialog() == IDOK )
	{
		LPTSTR szServer = new TCHAR[ MAX_PATH ];
		lstrcpy( szServer, pEditServer->GetServer() );
		m_serverDQ.at( iCurSel ) = szServer;

		if (IsWebView(szOldServer))
		{
			SetWebView(szServer);
		}

		_UpdateServerList();

		delete [] szOldServer;
	}

	ListBox_SetCurSel( m_hwndList, iCurSel );
}

void CDsPropWnd2::SetWebView(LPCTSTR szServer, LPCTSTR szName, LPCTSTR szURL)
{
	GetWebViewInfo()->SetWebView(szServer, szName, szURL);
	_UpdateServerList();
}

void CDsPropWnd2::_EditCurSelWebView()
{
	int iCurSel = ListBox_GetCurSel( m_hwndList );
	LPTSTR szServer = m_serverDQ.at( iCurSel );

	if (IsMSServer(szServer))
	{
		if (IDYES == NmrkMessageBox(MAKEINTRESOURCE(IDS_DEFAULT_WEBVIEW),
			MAKEINTRESOURCE(IDS_EDIT_WEBVIEW), MB_ICONEXCLAMATION | MB_YESNO))
		{
			SetWebView(szServer, TEXT(""), TEXT(""));
			SetButtons();
		}
		return;
	}

	CWebViewInfo *pWebView = GetWebViewInfo();

	LPCTSTR szWVName = TEXT("");
	LPCTSTR szWVURL = TEXT("");
	if (IsWebView(szServer))
	{
		szWVName = pWebView->m_szWebViewName;
		szWVURL = pWebView->m_szWebViewURL;
	}

	CEditWebView* pEditWebView = new CEditWebView(
		m_hwnd, szServer, szWVName, szWVURL, MAX_PATH );
	pEditWebView->SetEditServer(FALSE);
	
	if( pEditWebView->ShowDialog() == IDOK )
	{
		SetWebView(szServer, pEditWebView->GetName(), pEditWebView->GetURL());
		SetButtons();
	}

	delete pEditWebView;
}

BOOL CDsPropWnd2::_SetAsDefault( int iIndex )
{
	if( iIndex < 0 || iIndex > m_serverDQ.size() )
	{
		return FALSE;
	}

	// Move default server to top of deque
	LPTSTR szNewZero = m_serverDQ.at( iIndex );

	m_serverDQ.erase( m_serverDQ.begin() + iIndex );
	ListBox_DeleteString( m_hwndList, iIndex );

	ListBox_InsertString( m_hwndList, 0, szNewZero );
	m_serverDQ.push_front( szNewZero );
	m_defaultServer = 0;

	ListBox_SetCurSel( m_hwndList, 0 );

	_UpdateServerList();

	SetButtons();

	return TRUE;
}

BOOL CDsPropWnd2::_DeleteCurSel()
{
	int iCurSel = ListBox_GetCurSel( m_hwndList );

	LPTSTR szKill = m_serverDQ.at( iCurSel );

	TCHAR szBuffer[ MAX_PATH ];
	LoadString( IDS_ARE_YOU_SURE_YOU_WISH_TO_REMOVE, szBuffer, CCHMAX( szBuffer ) );

	TCHAR lpszMessage[ MAX_PATH ];
	wsprintf( lpszMessage, szBuffer, szKill );

	if( IDNO == NmrkMessageBox(lpszMessage, MAKEINTRESOURCE(IDS_VERIFY), MB_YESNO | MB_ICONQUESTION ) )
	{
		return FALSE;
	}

	m_serverDQ.erase( m_serverDQ.begin() + iCurSel );

	delete [] szKill;
	ListBox_DeleteString( m_hwndList, iCurSel );


	if( m_defaultServer == iCurSel )
	{
		if( m_serverDQ.size() > iCurSel )
		{
			_SetAsDefault( iCurSel );
		}
		else
		{
			_SetAsDefault( iCurSel - 1 );
		}
	}
	else
	{
		if( m_serverDQ.size() > iCurSel )
		{
			ListBox_SetCurSel( m_hwndList, iCurSel );
		}
		else if( iCurSel > 0 )
		{
			ListBox_SetCurSel( m_hwndList, iCurSel - 1);
		}
	}

	// Make sure all the WebView information is up-to-date
	_UpdateServerList();

	// Bug fix - I do not get a LBN_SELCHANGE message all the time when I want one
	// even though the string selected changes.  So just for that I gotta do this
	SetButtons();

	return TRUE;
}

void CDsPropWnd2::ReadSettings( void )
{
	TCHAR szValue[ MAX_PATH ];
	TCHAR szServerName[ MAX_PATH ];

	for( int i = 0; i < MAXSERVERS; i++ )
	{
		wsprintf( szValue, KEYNAME_ILSSERVER, i );
        ReadStringValue(szValue, szServerName, CCHMAX(szServerName));
        if (!szServerName[0])
            break;

		LPTSTR szServer = new TCHAR[ lstrlen( szServerName ) + 1 ];
		lstrcpy( szServer, szServerName );
		m_serverDQ.push_back( szServer );
	}

	ReadWebViewSettings(this);

    ReadNumberValue(KEYNAME_ILSDEFAULT, &m_defaultServer);

	_ReadCheckSetting( IDC_ALLOW_USER_TO_USE_DIRECTORY_SERVICES );
	_ReadCheckSetting( IDC_PREVENT_THE_USER_FROM_ADDING_NEW_SERVERS );
    _ReadCheckSetting( IDC_DISABLE_WEBDIR);

    _ReadCheckSetting( IDC_CHECK_GATEWAY );
    _ReadEditSetting ( IDC_EDIT_GATEWAY );
}


void CDsPropWnd2::WriteSettings( BOOL fGkMode )
{
	TCHAR szValue[ MAX_PATH ];
	deque< LPTSTR >::const_iterator it;
	
	int i = 0;
	for( it = m_serverDQ.begin(); it != m_serverDQ.end(); ++it )
	{
		wsprintf( szValue, KEYNAME_ILSSERVER, i );
        WriteStringValue(szValue, (LPTSTR)*it);
		i++;
	}

	while( i < MAXSERVERS )
	{
		wsprintf( szValue, KEYNAME_ILSSERVER, i );
        WriteStringValue(szValue, TEXT(""));
		i++;
	}

	WriteWebViewSettings(this);

    WriteNumberValue(KEYNAME_ILSDEFAULT, m_defaultServer);

	_WriteCheckSetting( IDC_ALLOW_USER_TO_USE_DIRECTORY_SERVICES );
	_WriteCheckSetting( IDC_PREVENT_THE_USER_FROM_ADDING_NEW_SERVERS );
    _WriteCheckSetting( IDC_DISABLE_WEBDIR );

    _WriteCheckSetting( IDC_CHECK_GATEWAY );
    _WriteEditSetting( IDC_EDIT_GATEWAY );
}


BOOL CDsPropWnd2::WriteToINF(BOOL fGkMode, HANDLE hFile )
{
	TCHAR szValue[ MAX_PATH ];
	deque< LPTSTR >::const_iterator it;
	
	int i = 0;
	for( it = m_serverDQ.begin(); it != m_serverDQ.end(); ++it, ++i )
	{
		wsprintf( szValue, TEXT("Name%d"), i );
		CPolicyData( CPolicyData::eKeyType_HKEY_CURRENT_USER, 
                     DIR_MRU_KEY, 
                     szValue, 
                     *it
                   ).SaveToINFFile( hFile );
	}

	CPolicyData( CPolicyData::eKeyType_HKEY_CURRENT_USER, 
                     DIR_MRU_KEY, 
                     TEXT("Count"), 
                     (DWORD)m_serverDQ.size() 
                   ).SaveToINFFile( hFile );

	while( i < MAXSERVERS )
	{
		wsprintf( szValue, TEXT("Name%d"), i );
		CPolicyData( CPolicyData::eKeyType_HKEY_CURRENT_USER, 
                     DIR_MRU_KEY, 
                     szValue, 
					 CPolicyData::OpDelete()
                   ).SaveToINFFile( hFile );
		i++;
	}

	if( m_serverDQ.size() )
	{
		CPolicyData( CPolicyData::eKeyType_HKEY_CURRENT_USER, 
             ISAPI_CLIENT_KEY, 
             REGVAL_SERVERNAME, 
             m_serverDQ.at( m_defaultServer )
           ).SaveToINFFile( hFile );
	}

    //
    // Directory stuff
    //
	BOOL bCheckValues = !fGkMode && DirectoryEnabled();
	
	if (!fGkMode)
	{
		WriteWebViewToINF(hFile, IsWebViewAllowed());
	    _WriteCheckToINF( hFile, IDC_DISABLE_WEBDIR, bCheckValues);
	}

	CPolicyData( ms_ClassMap[ IDC_ALLOW_USER_TO_USE_DIRECTORY_SERVICES ], 
             ms_KeyMap[ IDC_ALLOW_USER_TO_USE_DIRECTORY_SERVICES ], 
             ms_ValueMap[ IDC_ALLOW_USER_TO_USE_DIRECTORY_SERVICES ], 
             !bCheckValues
           ).SaveToINFFile( hFile );

	CPolicyData( CPolicyData::eKeyType_HKEY_CURRENT_USER, 
				 POLICIES_KEY,
				 REGVAL_POL_NO_DIRECTORY_SERVICES,
				 !bCheckValues
			   ).SaveToINFFile( hFile );

	_WriteCheckToINF( hFile, IDC_PREVENT_THE_USER_FROM_ADDING_NEW_SERVERS, bCheckValues );

    //
    // Gateway stuff
    //
    bCheckValues = !fGkMode & GatewayEnabled();

    _WriteCheckToINF( hFile, IDC_CHECK_GATEWAY, bCheckValues);
    _WriteEditToINF(hFile, IDC_EDIT_GATEWAY, bCheckValues);

	return TRUE;
}

int CDsPropWnd2::SpewToListBox( HWND hwndList, int iStartLine )
{
	if( DirectoryEnabled() )
	{	
		if( m_serverDQ.size() )
		{
			ListBox_InsertString( hwndList, iStartLine, TEXT("Adding Directory Servers:") );
			iStartLine++;

			deque< LPTSTR >::const_iterator it;
			for( it = m_serverDQ.begin(); it != m_serverDQ.end(); ++it )
			{
				LPTSTR sz = new TCHAR[ lstrlen( *it ) + 2 ];
				sz[ 0 ] = '\t'; sz[1] = '\0';
				lstrcat( sz, *it );

				ListBox_InsertString( hwndList, iStartLine, sz );
				iStartLine++;

				delete [] sz;
			}

			ListBox_InsertString( hwndList, iStartLine, TEXT("Default Server:") );
			iStartLine++;

			{
				LPTSTR sz = new TCHAR[ lstrlen( m_serverDQ.at( m_defaultServer ) ) + 2 ];
				sz[ 0 ] = '\t'; sz[1] = '\0';
				lstrcat( sz, m_serverDQ.at( m_defaultServer ) );

				ListBox_InsertString( hwndList, iStartLine, sz );
				iStartLine++;

				delete [] sz;
			}
		}

		if( !AllowUserToAdd() )
		{
			ListBox_InsertString( hwndList, iStartLine, TEXT("Prevent users from adding new servers to the list you provide") );
			iStartLine++;
		}

        if (!IsWebViewAllowed())
        {
            ListBox_InsertString( hwndList, iStartLine, TEXT("Prevent users from viewing web directory"));
            iStartLine++;
        }
	}
	else
	{
		ListBox_InsertString( hwndList, iStartLine, TEXT("Disable Directory Services") );
		iStartLine++;
	}

    if (GatewayEnabled())
    {
        TCHAR   szGateway[MAX_PATH];

        ListBox_InsertString( hwndList, iStartLine, TEXT("Adding Gateway server:") );
        iStartLine++;

        szGateway[0] = '\t';
        GetDlgItemText(m_hwnd, IDC_EDIT_GATEWAY, szGateway+1,
                CCHMAX(szGateway)-1);
        ListBox_InsertString( hwndList, iStartLine, szGateway);
        iStartLine++;
    }

	return iStartLine;
}


//
// GATEKEEPER STUFF
//


CGkPropWnd2::CGkPropWnd2( HWND hwndParent, int iX, int iY, int iWidth, int iHeight )
	: CPropertyDataWindow2( hwndParent, IDD_CHILDPAGE_GATEKEEPER, TEXT("IDD_CHILDPAGE_GATEKEEPER"), (WNDPROC) GkPropWndProc, 0, iX, iY, iWidth, iHeight, FALSE )
{
	SetWindowLong( m_hwnd, GWL_USERDATA, (long)this );

    HWND    hwndChild;

	// Calling method radio buttons
    hwndChild = GetDlgItem(m_hwnd, IDC_RADIO_GKMODE_ACCOUNT);
    SetWindowLong( hwndChild, GWL_USERDATA, GK_LOGON_USING_ACCOUNT );

    hwndChild = GetDlgItem(m_hwnd, IDC_RADIO_GKMODE_PHONE);
    SetWindowLong(hwndChild, GWL_USERDATA, GK_LOGON_USING_PHONENUM);

    hwndChild = GetDlgItem(m_hwnd, IDC_RADIO_GKMODE_BOTH);
    SetWindowLong(hwndChild, GWL_USERDATA, GK_LOGON_USING_BOTH);

	Edit_LimitText( GetDlgItem( m_hwnd, IDC_EDIT_GATEKEEPER ), MAX_PATH );
    ConnectControlsToCheck( IDC_CHECK_GATEKEEPER, 1,
        new CControlID(GetDlgItem(m_hwnd, IDC_CHECK_GATEKEEPER),
        IDC_CHECK_GATEKEEPER,
        IDC_EDIT_GATEKEEPER,
        CControlID::EDIT ) );

    PrepSettings(FALSE);

	SetButtons();
}

CGkPropWnd2::~CGkPropWnd2()
{
}

void CGkPropWnd2::_EditCurSelWebView()
{
	CWebViewInfo *pWebView = GetWebViewInfo();

	CEditWebView* pEditWebView = new CEditWebView(
		m_hwnd, pWebView->m_szWebViewServer, pWebView->m_szWebViewName, pWebView->m_szWebViewURL, MAX_PATH );
	
	if( pEditWebView->ShowDialog() == IDOK )
	{
		SetWebView(pEditWebView->GetServer(), pEditWebView->GetName(), pEditWebView->GetURL());
		SetButtons();
	}

	delete pEditWebView;
}

LRESULT CALLBACK CGkPropWnd2::GkPropWndProc( HWND hwnd, UINT uiMsg, WPARAM wParam, LPARAM lParam )
{
	switch( uiMsg )
	{
		case WM_VSCROLL:
		case WM_VKEYTOITEM:
		case WM_COMMAND:
		{
			CGkPropWnd2 * pPropWnd = (CGkPropWnd2 *)GetWindowLong( hwnd, GWL_USERDATA );
			return pPropWnd->_WndProc( hwnd, uiMsg, wParam, lParam );
			break;
		}
		default:
		{
			return DefWindowProc( hwnd, uiMsg, wParam, lParam );
			break;
		}
	}
}


BOOL CGkPropWnd2::DoCommand(WPARAM wParam, LPARAM lParam)
{
    return(_WndProc(m_hwnd, WM_COMMAND, wParam, lParam));
}


LRESULT CALLBACK CGkPropWnd2::_WndProc( HWND hwnd, UINT uiMsg, WPARAM wParam, LPARAM lParam )
{
	
	switch( uiMsg ) 
	{
		case WM_VSCROLL: 
		{
			OnMsg_VScroll( hwnd, wParam );
			return 0;
			break;
		}

		case WM_COMMAND:
			if (GET_WM_COMMAND_CMD(wParam, lParam) == BN_CLICKED)
			{
				switch (GET_WM_COMMAND_ID(wParam, lParam))
				{
				case IDC_BUTTON_SET_WEBVIEW:
					_EditCurSelWebView();
					break;

				case IDC_DISABLE_WEBDIR_GK:
					SetButtons();
					break;
				}
			}
			break;
	}
	
	return DefWindowProc( hwnd, uiMsg, wParam, lParam );
}

void CGkPropWnd2::SetButtons()
{
	::EnableWindow(GetDlgItem(m_hwnd, IDC_BUTTON_SET_WEBVIEW),
		!IsDlgButtonChecked(m_hwnd, IDC_DISABLE_WEBDIR_GK));
}




void CGkPropWnd2::PrepSettings( BOOL fGkMode )
{
	if (g_pWiz->m_IntroSheet.GetFilePane()->OptionEnabled())
	{
		ReadSettings();
	}
	else
	{
        TCHAR   szText[1];

        szText[0] = 0;
        SetDlgItemText(m_hwnd, IDC_EDIT_GATEKEEPER, szText);

        Button_SetCheck(GetDlgItem(m_hwnd, IDC_CHECK_GATEKEEPER), FALSE);
        Button_SetCheck(GetDlgItem(m_hwnd, IDC_RADIO_GKMODE_BOTH), BST_CHECKED);
	}
}



void CGkPropWnd2::ReadSettings( void )
{
    int iRadio;

    _ReadEditSetting ( IDC_EDIT_GATEKEEPER );
    Button_SetCheck(GetDlgItem(m_hwnd, IDC_CHECK_GATEKEEPER),
        (GetWindowTextLength(GetDlgItem(m_hwnd, IDC_EDIT_GATEKEEPER)) != 0));

    for (iRadio = IDC_RADIO_GKMODE_FIRST; iRadio < IDC_RADIO_GKMODE_MAX; iRadio++)
    {
        _ReadCheckSetting(iRadio);
    }

	ReadWebViewSettings(this);

    _ReadCheckSetting( IDC_DISABLE_WEBDIR_GK);
}


void CGkPropWnd2::WriteSettings( BOOL fGkMode )
{
    int iRadio;

    _WriteEditSetting( IDC_EDIT_GATEKEEPER );

    for (iRadio = IDC_RADIO_GKMODE_FIRST; iRadio < IDC_RADIO_GKMODE_MAX; iRadio++)
    {
        _WriteCheckSetting(iRadio);
    }

	WriteWebViewSettings(this);

    _WriteCheckSetting( IDC_DISABLE_WEBDIR_GK );
}


BOOL CGkPropWnd2::WriteToINF( BOOL fGkMode, HANDLE hFile )
{
    int iRadio;

    _WriteEditToINF( hFile, IDC_EDIT_GATEKEEPER,
        fGkMode && IsDlgButtonChecked(m_hwnd, IDC_CHECK_GATEKEEPER));

    for (iRadio = IDC_RADIO_GKMODE_FIRST; iRadio < IDC_RADIO_GKMODE_MAX; iRadio++)
    {
        _WriteCheckToINF(hFile, iRadio, fGkMode);
    }

	if (fGkMode)
	{
		WriteWebViewToINF(hFile, IsWebViewAllowed());
	    _WriteCheckToINF( hFile, IDC_DISABLE_WEBDIR_GK, fGkMode );
	}

	return TRUE;
}

int CGkPropWnd2::SpewToListBox( HWND hwndList, int iStartLine )
{
    TCHAR   szTemp[MAX_PATH];
    int     iRadio;

    if (IsDlgButtonChecked(m_hwnd, IDC_CHECK_GATEKEEPER))
    {
        ListBox_InsertString(hwndList, iStartLine, TEXT("Adding Gatekeeper server:") );
        iStartLine++;

        szTemp[0] = '\t';
        GetDlgItemText(m_hwnd, IDC_EDIT_GATEKEEPER, szTemp+1,
            CCHMAX(szTemp)-1);
        ListBox_InsertString(hwndList, iStartLine, szTemp);
        iStartLine++;
    }

    ListBox_InsertString(hwndList, iStartLine, TEXT("Gatekeeper addressing mode:") );
    iStartLine++;

    for (iRadio = IDC_RADIO_GKMODE_FIRST; iRadio < IDC_RADIO_GKMODE_MAX; iRadio++)
    {
        if (IsDlgButtonChecked(m_hwnd, iRadio))
        {
            szTemp[0] = '\t';
            GetDlgItemText(m_hwnd, iRadio, szTemp+1, CCHMAX(szTemp)-1);
            ListBox_InsertString(hwndList, iStartLine, szTemp);
            iStartLine++;

            break;
        }
    }

    return(iStartLine);
}


void CGkPropWnd2::QueryWizNext(void)
{

}

void CGkPropWnd2::SetWebView(LPCTSTR szServer, LPCTSTR szName, LPCTSTR szURL)
{
	GetWebViewInfo()->SetWebView(szServer, szName, szURL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\nmrk\editserver.h ===
#ifndef _EditServer_h_
#define _EditServer_h_

class CEditServer
{
	private:
		static CEditServer *ms_pThis;

	private:
		HWND m_hwnd;
		LPTSTR m_szServerBuffer;
		HWND m_hwndParent;
		size_t m_cbLen;

	public:
		CEditServer( HWND hwndParent, LPTSTR szServer, size_t cbLen );
		~CEditServer();
		int ShowDialog();

		inline LPTSTR GetServer() { return m_szServerBuffer; }

	private:
		static BOOL CALLBACK _Proc(  HWND hwndDlg,  // handle to dialog box
							  UINT uMsg,     // message  
							  WPARAM wParam, // first message parameter
							  LPARAM lParam  // second message parameter
							  );


};

class CEditWebView
{
	private:
		static CEditWebView *ms_pThis;

	private:
		LPTSTR m_szServerBuffer;
		LPTSTR m_szNameBuffer;
		LPTSTR m_szURLBuffer;
		HWND m_hwndParent;
		size_t m_cbLen;

		BOOL m_bEditServer : 2;

	public:
		CEditWebView( HWND hwndParent, LPCTSTR szServer, LPCTSTR szName, LPCTSTR szURL, size_t cbLen );
		~CEditWebView();
		int ShowDialog();

		LPCTSTR GetServer() { return m_szServerBuffer; }
		LPCTSTR GetName()   { return m_szNameBuffer; }
		LPCTSTR GetURL()    { return m_szURLBuffer; }

		void SetEditServer(BOOL bEditServer) { m_bEditServer = (bEditServer != FALSE); }
		BOOL GetEditServer() { return(m_bEditServer); }

	private:
		static BOOL CALLBACK _Proc(  HWND hwndDlg,  // handle to dialog box
							  UINT uMsg,     // message  
							  WPARAM wParam, // first message parameter
							  LPARAM lParam  // second message parameter
							  );


};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\nmrk\filepane.h ===
#ifndef _FilePane_h_
#define _FilePane_h_

#include "propwnd2.h"

//UINT CALLBACK _ButtonProc( HWND hwnd, UINT iMsg, WPARAM wParam, LPARAM lParam );
//UINT CALLBACK _CheckProc( HWND hwnd, UINT iMsg, WPARAM wParam, LPARAM lParam );

class CFilePanePropWnd2 : public CPropertyDataWindow2
{
//	friend UINT CALLBACK _ButtonProc( HWND hwnd, UINT iMsg, WPARAM wParam, LPARAM lParam );
//	friend UINT CALLBACK _CheckProc( HWND hwnd, UINT iMsg, WPARAM wParam, LPARAM lParam );

private:
	static UINT CALLBACK OFNHookProc( HWND hwnd, UINT iMsg, WPARAM wParam, LPARAM lParam );
	static LRESULT CALLBACK WndProc( HWND hwnd, UINT uiMsg, WPARAM wParam, LPARAM lParam );
	UINT CALLBACK _OFNHookProc( HWND hwnd, UINT iMsg, WPARAM wParam, LPARAM lParam );
private:
	HWND m_hwndEdit;
	HWND m_hwndCheck;
	HWND m_hwndBrowse;

	UINT m_editID;
	UINT m_checkID;
	UINT m_browseID;

	TCHAR m_szOFNData[MAX_PATH];

	LPTSTR m_lptstrFilter;
	LPTSTR m_lptstrDefExtension;

	LPTSTR m_lptstrDefFileName;

	OPENFILENAME m_ofn;

    BOOL   m_fOpenDialog;

public:
	CFilePanePropWnd2( HWND hwndParent, UINT uIDD, LPTSTR szClassName, UINT PopUpHelpMenuTextId, int iX, int iY, int iWidth, int iHeight, BOOL bScroll = FALSE );
	void SetFilePane( BOOL fOpenDialog, UINT editID, UINT checkID, UINT browseID, LPTSTR lptstDesc, LPTSTR lptstrDefExtension, LPTSTR lptstrDefFileName);

	~CFilePanePropWnd2();

public:
	void CreateOutputDir( void );
	void QueryFilePath( void );
	LPTSTR GetPathAndFile( LPTSTR lpstrPath );
	LPTSTR GetPath( LPTSTR lpstrPath );
	LPTSTR GetFile( LPTSTR lpstrFile );
    void SetFileName(LPTSTR lpstrFullFileName);
	BOOL OptionEnabled();
	void Enable( BOOL bEnable );
	BOOL Validate( BOOL bMsg );
	HANDLE CreateFile( DWORD dwDesiredAccess,
							 DWORD dwShareMode,
							 LPSECURITY_ATTRIBUTES lpSecurityAttributes,
							 DWORD dwCreationDisposition,
							 DWORD dwFlagsAndAttributes );


private:
	void _Enable( BOOL bEnable );
	void _InitOFN( void );
	void _CopyString( LPTSTR * szTarget, LPTSTR szSource );
	void _CopyFilter( LPTSTR * szTarget, LPTSTR szDesc, LPTSTR szExt );
	void _SetDefaultPath( void );
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\nmrk\filepane.cpp ===
#include "Precomp.h"
#include "resource.h"
#include "global.h"
#include "propwnd2.h"
#include "FilePane.h"
#include "NmAkWiz.h"
#include "wndprocs.h"



CFilePanePropWnd2::CFilePanePropWnd2(HWND hwndParent, UINT uIDD, LPTSTR szClassName, UINT PopUpHelpMenuTextId, int iX, int iY, int iWidth, int iHeight, BOOL bScroll ) :
    CPropertyDataWindow2( hwndParent, uIDD, szClassName, CFilePanePropWnd2::WndProc, PopUpHelpMenuTextId, iX, iY, iWidth, iHeight, bScroll ),
    m_fOpenDialog(FALSE)
{
	// All the new stuff done in setfilepane...
	// this constructor is already too big
}

void CFilePanePropWnd2::SetFilePane(BOOL fOpenDialog, UINT editID, UINT checkID, UINT browseID, LPTSTR lptstrDesc, LPTSTR lptstrDefExtension, LPTSTR lptstrDefFileName )
{
	SetWindowLong( m_hwnd, GWL_USERDATA, (long)this );

    m_fOpenDialog = fOpenDialog;
	m_editID = editID;
	m_checkID = checkID;
	m_browseID = browseID;
	m_lptstrFilter = NULL;
	m_lptstrDefExtension = NULL;
	m_lptstrDefFileName = NULL;

	_CopyFilter( &m_lptstrFilter, lptstrDesc, lptstrDefExtension );
	_CopyString( &m_lptstrDefExtension, lptstrDefExtension );
	_CopyString( &m_lptstrDefFileName, lptstrDefFileName );

	m_hwndEdit = GetDlgItem( m_hwnd, editID );
	m_hwndCheck = GetDlgItem( m_hwnd, checkID );
	Edit_LimitText( m_hwndEdit, MAX_PATH );
	m_hwndBrowse = GetDlgItem( m_hwnd, browseID );

	_SetDefaultPath();

	_InitOFN();
}

CFilePanePropWnd2::~CFilePanePropWnd2( void )
{
	delete [] m_lptstrFilter;
	delete [] m_lptstrDefExtension;
	delete [] m_lptstrDefFileName;
}


LRESULT CALLBACK CFilePanePropWnd2::WndProc( HWND hwnd, UINT iMsg, WPARAM wParam, LPARAM lParam )
{
	switch( iMsg )
	{
		case WM_VSCROLL: 
		{
			OnMsg_VScroll( hwnd, wParam );
			return 0;
			break;
		} 
		case WM_COMMAND:
		if (BN_CLICKED == GET_WM_COMMAND_CMD(wParam, lParam))
		{
    		CFilePanePropWnd2 *p = (CFilePanePropWnd2 *)GetWindowLong( hwnd, GWL_USERDATA);

            if (p && GET_WM_COMMAND_ID(wParam, lParam) == p->m_browseID)
            {
                p->QueryFilePath();
            }

            return(0);
            break;
        }
	}
	return( DefWindowProc( hwnd, iMsg, wParam, lParam ) );
}



HANDLE CFilePanePropWnd2::CreateFile( DWORD dwDesiredAccess,
							 DWORD dwShareMode,
							 LPSECURITY_ATTRIBUTES lpSecurityAttributes,
							 DWORD dwCreationDisposition,
							 DWORD dwFlagsAndAttributes )
{
	CreateOutputDir();

	TCHAR szFile[ MAX_PATH ];
	TCHAR szPath[ MAX_PATH ];
	GetPath( szPath );
	GetFile( szFile );
	if( '\\' != szPath[ lstrlen( szPath ) - 1 ] )
	{
		lstrcat( szPath, TEXT("\\") );
	}
	lstrcat( szPath, szFile );

	return ::CreateFile( szPath,
						dwDesiredAccess,
						dwShareMode,
						lpSecurityAttributes,
						dwCreationDisposition,
						dwFlagsAndAttributes,
						NULL );
}

void CFilePanePropWnd2::_CopyFilter( LPTSTR* szTarget, LPTSTR szDec, LPTSTR szExt )
{
	int index = 0;
	// Note - add 4 because this filter needs three null terminators and a '*'
	int iLen = (lstrlen( szDec ) + 1) + (1 + lstrlen( szExt ) + 1) + 1;
	*szTarget = new TCHAR[ iLen ];
	lstrcpy( *szTarget, szDec );

	index = lstrlen( *szTarget ) + 1;

	(*szTarget)[index] = '*';
	lstrcpy( &((*szTarget)[index+1]), szExt );

	(*szTarget)[ iLen - 1] = '\0';

}

void CFilePanePropWnd2::_CopyString( LPTSTR* szTarget, LPTSTR szSource )
{
	int iLen = lstrlen( szSource ) + 1;
	*szTarget = new TCHAR[ iLen ];
	lstrcpy( *szTarget, szSource );
}

UINT CALLBACK CFilePanePropWnd2::OFNHookProc(  HWND hdlg,      // handle to child dialog window
							UINT uiMsg,     // message identifier  
							WPARAM wParam,  // message parameter
							LPARAM lParam   // message parameter
						 )
{
	switch (uiMsg)
	{
    	case WM_INITDIALOG:
	    {
		    SetWindowLong(hdlg, GWL_USERDATA, ((OPENFILENAME *)lParam)->lCustData);
    		break;
	    }

    	case WM_NOTIFY:
	    {
		    CFilePanePropWnd2 *p = (CFilePanePropWnd2 *)GetWindowLong( hdlg, GWL_USERDATA );
    		if (NULL == p)
	    		break;
		    return p->_OFNHookProc(hdlg, uiMsg, wParam, lParam);
    	}

	    default:
		    break;
	}

	return 0;
}

UINT CALLBACK CFilePanePropWnd2::_OFNHookProc(  HWND hdlg,      // handle to child dialog window
							UINT uiMsg,     // message identifier  
							WPARAM wParam,  // message parameter
							LPARAM lParam   // message parameter
						 )
{
	switch( uiMsg )
	{
		case WM_NOTIFY:
		{
			OFNOTIFY * pOfnotify = (OFNOTIFY *) lParam;
			switch( pOfnotify -> hdr . code )
			{
				case CDN_FOLDERCHANGE:
				{

					TCHAR szFile[ MAX_PATH ];
					if( !CommDlg_OpenSave_GetSpec( GetParent( hdlg ), szFile, MAX_PATH ) ||
						0 == lstrlen( szFile ) ||
						_tcschr( szFile, '\\' ) )
					{
						CommDlg_OpenSave_SetControlText( GetParent( hdlg ), edt1,
							m_szOFNData );
					}
					else
					{
						lstrcpy( m_szOFNData, szFile );
						OutputDebugString( szFile );
					}
					break;
				}
				case CDN_INITDONE:
				{
					GetFile( m_szOFNData );
					break;
				}
			}
		}
	}

	return( 0 );
}

void CFilePanePropWnd2::_InitOFN( void )
{
	ZeroMemory( &m_ofn, sizeof( m_ofn ) );
	m_ofn.lStructSize = sizeof( m_ofn );
	m_ofn.hwndOwner = m_hwnd;
    m_ofn.hInstance = g_hInstance;
	m_ofn.lpstrFilter = m_lptstrFilter;
	m_ofn.nMaxFile  = MAX_PATH;
	m_ofn.lpstrDefExt = m_lptstrDefExtension;
	m_ofn.Flags = OFN_HIDEREADONLY | OFN_EXPLORER | OFN_ENABLEHOOK ;// | OFN_OVERWRITEPROMPT;
    if (m_fOpenDialog)
        m_ofn.Flags |= OFN_FILEMUSTEXIST;
	m_ofn.lCustData     = (long)this;
	m_ofn.lpfnHook      = OFNHookProc;
	m_ofn.lpstrTitle    = TEXT("Browse");
}

void CFilePanePropWnd2::QueryFilePath( void )
{
	TCHAR szDir[MAX_PATH];
    TCHAR szFile[MAX_PATH];

	GetPath(szDir);
	GetFile(szFile);

	m_ofn.lpstrInitialDir   = szDir;
	m_ofn.lpstrFile         = szFile;

    BOOL bRet;
    if (m_fOpenDialog)
        bRet = GetOpenFileName(&m_ofn);
    else
        bRet = GetSaveFileName(&m_ofn);

	if( bRet )
	{
		Edit_SetText( m_hwndEdit, m_ofn.lpstrFile );
	}
}

void CFilePanePropWnd2::_SetDefaultPath( void ) 
{

    TCHAR szDefaultDistributionFilePath[ MAX_PATH ];
    const TCHAR* szInstallationPath;
    szInstallationPath = GetInstallationPath();
    if( szInstallationPath )
    {
        lstrcpy( szDefaultDistributionFilePath, szInstallationPath );
        _tcscat( szDefaultDistributionFilePath, TEXT("\\output\\") );
		_tcscat( szDefaultDistributionFilePath, m_lptstrDefFileName );
    }
    else
    {
        _tcscat( szDefaultDistributionFilePath, m_lptstrDefFileName );
    }
    Edit_SetText( m_hwndEdit, szDefaultDistributionFilePath );

}

void CFilePanePropWnd2::CreateOutputDir( void ) 
{
    TCHAR sz[ MAX_PATH ];
	GetPath( sz );
	CreateDirectory( sz, NULL );
}


LPTSTR CFilePanePropWnd2::GetPathAndFile( LPTSTR lpstrPath )
{
	Edit_GetText( m_hwndEdit, lpstrPath, MAX_PATH );

	return lpstrPath;
}

LPTSTR CFilePanePropWnd2::GetPath( LPTSTR sz )
{
	TCHAR path[ MAX_PATH], drive[_MAX_DRIVE], dir[_MAX_DIR];
	Edit_GetText( m_hwndEdit, path, MAX_PATH );

	_splitpath( path, drive, dir, NULL, NULL );
	wsprintf( sz, TEXT("%s%s"), drive, dir );

	return sz;
}

LPTSTR CFilePanePropWnd2::GetFile( LPTSTR sz )
{
	TCHAR path[ MAX_PATH], file[_MAX_FNAME], ext[ _MAX_EXT];
	Edit_GetText( m_hwndEdit, path, MAX_PATH );

	_splitpath( path, NULL, NULL, file, ext );

	if (file[0] && (NULL == _tcschr(file, '\\')))
	{
		if (!lstrcmp( m_lptstrDefExtension, ext))
		{
			wsprintf(sz, TEXT("%s%s"), file, m_lptstrDefExtension);
		}
		else
		{
			wsprintf(sz, TEXT("%s%s%s"), file, ext, m_lptstrDefExtension);
		}
	}
	else
	{
        lstrcpy(sz, m_lptstrDefFileName);
	}

	return sz;
}

BOOL CFilePanePropWnd2::OptionEnabled()
{
	return Button_GetCheck( m_hwndCheck ) ? TRUE : FALSE;
}

BOOL CFilePanePropWnd2::Validate( BOOL bMsg )
{
	if( !OptionEnabled() )
	{
		return TRUE;
	}

	TCHAR szPath[ MAX_PATH ];
	TCHAR drive[ _MAX_DRIVE], dir[_MAX_DIR], ext[ _MAX_EXT];
	Edit_GetText( m_hwndEdit, szPath, MAX_PATH );

	if( 0 == lstrlen( szPath ) ) 
	{
		_SetDefaultPath();
		return FALSE;
	}

	_splitpath( szPath, drive, dir, NULL, ext );

	if( 0 != lstrcmp( m_lptstrDefExtension, ext ) )
	{
		lstrcat( szPath, m_lptstrDefExtension );
	}

	wsprintf( szPath, TEXT("%s%s"), drive, dir );

    // Verify that we can write to the location 

    if( szPath[ lstrlen( szPath ) - 1 ] != '\\' ) {
        _tcscat( szPath, TEXT("\\") );
    }

    strcat( szPath, TEXT("eraseme.now") );

    HANDLE hFile = ::CreateFile( szPath, 
                               GENERIC_WRITE, 
                               0,
                               NULL,
                               CREATE_ALWAYS,
                               FILE_ATTRIBUTE_NORMAL | FILE_FLAG_DELETE_ON_CLOSE,
                               NULL
                             );
    
    if( INVALID_HANDLE_VALUE == hFile ) 
	{
        switch( GetLastError() ) 
		{
            case ERROR_PATH_NOT_FOUND:
			{
                // Try to create the directory...

				GetPath( szPath );
                if( CreateDirectory( szPath, NULL ) ) 
				{
                    // Everything is OK, we created the directory at the path
                    RemoveDirectory( szPath );
				
					// Ask if we should create the directory
					if( bMsg ) 
					{
						if( IDNO == NmrkMessageBox(MAKEINTRESOURCE(IDS_CREATE_DIRECTORY), NULL, MB_YESNO | MB_ICONQUESTION ) )
						{
							return FALSE;
						}
						else
						{
							return TRUE;
						}
					}
					else
					{
						_SetDefaultPath();
						return FALSE;
					}
                }                
                //ErrorMessage();
                if( bMsg ) 
				{
                    NmrkMessageBox(MAKEINTRESOURCE(IDS_SELECTED_PATH_IS_INVALID_PLEASE_CHANGE_THE_PATH_NAME_OR_BROWSE_FOR_A_NEW_PATH),
                                   MAKEINTRESOURCE( IDS_NMAKWIZ_ERROR_CAPTION),
                                MB_OK | MB_ICONEXCLAMATION
                              );
                }
				else
				{
					_SetDefaultPath();
				}
                return FALSE;
				break;
			}
            case ERROR_ACCESS_DENIED:
			{
                if( bMsg ) 
				{
                    NmrkMessageBox(
								MAKEINTRESOURCE(IDS_YOU_DO_NOT_HAVE_WRITE_ACCESS_TO_THE_SELECTED_PATH_PLEASE_SELECT_A_PATH_IN_WHICH_YOU_HAVE_WRITE_PERMISSION),
                                MAKEINTRESOURCE(IDS_NMAKWIZ_ERROR_CAPTION),
								MB_OK | MB_ICONEXCLAMATION
                              );
                }
				else
				{
					_SetDefaultPath();
				}
                return FALSE;
				break;
			}
            default:
                return FALSE;
				break;
        }

    }
    else {
        CloseHandle( hFile );
        DeleteFile( szPath );
    }

	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\nmrk\finishdg.h ===
#ifndef __FinishDg_h__
#define __FinishDg_h__

#include "filepane.h"

class CFinishSheet
{

friend class CNmAkWiz;

private: // DATA
    CPropertySheetPage      m_PropertySheetPage;
    CFilePanePropWnd2 *     m_pFilePane;
    static CFinishSheet *   ms_pFinishSheet;

public:
    CFilePanePropWnd2 * GetFilePane(void) const {return m_pFilePane;}

private:
    static BOOL APIENTRY DlgProc( HWND hDlg, UINT message, WPARAM uParam, LPARAM lParam );

    CFinishSheet( void );
    ~CFinishSheet( void );

    void _CreateFilePane(HWND hDlg);

    LPCPROPSHEETPAGE GetPropertySheet( void ) const { return &m_PropertySheetPage;}
};

#endif // __FinishDg_h__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\nmrk\fileparm.h ===
#ifndef __FileParm_h__
#define __FileParm_h__

#include "FilePane.h"

class CDistributionSheet {

friend class CNmAkWiz;
    
private:
    static BOOL APIENTRY DlgProc( HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam );
	static UINT CALLBACK DistroOFNHookProc(  HWND hdlg, UINT uiMsg, WPARAM wParam, LPARAM lParam );
	static UINT CALLBACK AutoConfOFNHookProc(  HWND hdlg, UINT uiMsg, WPARAM wParam, LPARAM lParam );
    static CDistributionSheet* ms_pDistributionFileSheet;
    static int ms_MaxDistributionFilePathLen;
	static  TCHAR ms_szOFNData[ MAX_PATH];


private: // DATA
    CPropertySheetPage m_PropertySheetPage; 
	OPENFILENAME	   m_ofn;

	CFilePanePropWnd2 *		   m_pDistroFilePane;
	CFilePanePropWnd2 *        m_pAutoFilePane;

	BOOL			m_bHadAutoConf;
	BOOL			m_bLastRoundUp;
	LPTSTR			m_szLastLocation;
  
public:
	inline CFilePanePropWnd2 * GetDistroFilePane() { return m_pDistroFilePane; }
	inline CFilePanePropWnd2 * GetAutoFilePane() { return m_pAutoFilePane; }
	inline BOOL TurnedOffAutoConf() { return m_bLastRoundUp; }

private: 
    CDistributionSheet( void );
    ~CDistributionSheet( void );

    LPCPROPSHEETPAGE GetPropertySheet( void ) const { return &m_PropertySheetPage;}
	void CreateFilePanes(HWND hDlg);
//    int GetEditLen( UINT id );
//    void GetEditText( UINT id, TCHAR* sz, int cb );
};

#endif // __FileParm_h__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\nmrk\global.h ===
////////////////////////////////////////////////////////////////////////////////////////////////////
// This is a collection of useful functions. 
// 


#ifndef __Global_h__
#define __Global_h__


    // Display a message box to query the user if she is sure she wants to exit the wizard
BOOL VerifyExitMessageBox(void);
    
    // Return a SIZE structure for the size that text will be in a window        
    // A return value of SIZE( -1, -1 ) indicates an error
SIZE GetTextSize( HWND hWnd, LPCTSTR sz );

    // Return a the height for the text will be in a window        
    // A return value of -1 indicates an error
int GetTextHeight( HWND hWnd, LPCTSTR sz );

    // Return a the width for the text will be in a window        
    // A return value of -1 indicates an error
int GetTextWidth( HWND hWnd, LPCTSTR sz );

TCHAR *MakeCopyOfString( const TCHAR* sz );

#endif // __Global_h__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\nmrk\finishdg.cpp ===
#include "Precomp.h"
#include "resource.h"
#include "global.h"
#include "PropPg.h"
#include "FinishDg.h"
#include "nmakwiz.h"



// Static
CFinishSheet* CFinishSheet::ms_pFinishSheet = NULL;


////////////////////////////////////////////////////////////////////////////////////////////////////
// Member fns


CFinishSheet::CFinishSheet( void ) :
    m_PropertySheetPage( MAKEINTRESOURCE( IDD_PROPPAGE_DEFAULT ), 
						( DLGPROC ) CFinishSheet::DlgProc),
    m_pFilePane( NULL )
{
    ms_pFinishSheet = this;
}


CFinishSheet::~CFinishSheet(void) 
{
    delete m_pFilePane;
    m_pFilePane = NULL;
    ms_pFinishSheet = NULL;
}




////////////////////////////////////////////////////////////////////////////////////////////////////
// Static member fns

BOOL APIENTRY CFinishSheet::DlgProc( HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam ) {

    switch( message )
    {
		case WM_INITDIALOG:
        {
			PropSheet_SetWizButtons( GetParent( hDlg ), PSWIZB_FINISH | PSWIZB_BACK );
            ms_pFinishSheet->_CreateFilePane(hDlg);
			return TRUE;
        }

		case WM_NOTIFY:
        {
			switch( reinterpret_cast< NMHDR FAR* >( lParam ) -> code )
            {
				case PSN_QUERYCANCEL: 
					SetWindowLong( hDlg, DWL_MSGRESULT, !VerifyExitMessageBox());
					return TRUE;

                case PSN_SETACTIVE:
                    g_hwndActive = hDlg;
                    PropSheet_SetWizButtons( GetParent( hDlg ), PSWIZB_FINISH | PSWIZB_BACK );
                    ms_pFinishSheet->m_pFilePane->Validate(FALSE);
			        return TRUE;

                case PSN_WIZBACK:
                    if (!ms_pFinishSheet->m_pFilePane->Validate(TRUE))
                    {
                        SetWindowLong(hDlg, DWL_MSGRESULT, -1);
                        return TRUE;
                    }
                    break;

                case PSN_WIZFINISH:
                    if (!ms_pFinishSheet->m_pFilePane->Validate(TRUE))
                    {
                        SetWindowLong(hDlg, DWL_MSGRESULT, -1);
                        return TRUE;
                    }

                    g_pWiz->CallbackForWhenUserHitsFinishButton();
                    return TRUE;
			}
            break;
        }

		default:
			break;

	}

	return FALSE;

}



//
// _CreateFilePane()
//
void CFinishSheet::_CreateFilePane(HWND hDlg)
{
    RECT    rect;

    GetClientRect(hDlg, &rect);
    int iHeight = rect.bottom - rect.top;
    int iWidth = rect.right - CPropertyDataWindow2::mcs_iLeft;

    m_pFilePane = new CFilePanePropWnd2(hDlg, IDD_FILEPANE_SETTINGS,
        TEXT("IDD_FILEPANE_SETTINGS"), 0, CPropertyDataWindow2::mcs_iLeft,
        CPropertyDataWindow2::mcs_iTop, iWidth, iHeight);

    HWND hwndCond = GetDlgItem(m_pFilePane->GetHwnd(), IDC_SETTINGS_FILE);
    m_pFilePane->ConnectControlsToCheck(IDC_SETTINGS_FILE, 2,
            new CControlID(hwndCond, IDC_SETTINGS_FILE, IDE_SETTINGS_FILE,
                    CControlID::EDIT),
            new CControlID(hwndCond, IDC_SETTINGS_FILE, IDC_BROWSE_SETTINGS_FILE,
                    CControlID::CHECK));

    m_pFilePane->SetFilePane(FALSE, IDE_SETTINGS_FILE, IDC_SETTINGS_FILE,
        IDC_BROWSE_SETTINGS_FILE, TEXT("Configuration File (*.ini)"),
        TEXT(".ini"), TEXT("nm3c.ini"));

	if (g_pWiz->m_IntroSheet.GetFilePane()->OptionEnabled())
    {
        TCHAR   szFile[MAX_PATH];

        g_pWiz->m_IntroSheet.GetFilePane()->GetPathAndFile(szFile);
        Edit_SetText(GetDlgItem(m_pFilePane->GetHwnd(), IDE_SETTINGS_FILE),
            szFile);
    }

    m_pFilePane->ShowWindow(TRUE);
    m_pFilePane->SetCheck(IDC_SETTINGS_FILE, TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\nmrk\global.cpp ===
#include "precomp.h"
#include "resource.h"
#include "global.h"
#include "nmakwiz.h"

////////////////////////////////////////////////////////////////////////////////////////////////////


//#include <crtdbg.h>
//#ifdef _DEBUG
//#undef THIS_FILE
//static char THIS_FILE[] = __FILE__;
//#define new new( _NORMAL_BLOCK, THIS_FILE, __LINE__)
//#endif

////////////////////////////////////////////////////////////////////////////////////////////////////
// Display a message box to query the user if she is sure she wants to exit the wizard
// Returns TRUE if the user wants to quit, else returns FALSE

BOOL VerifyExitMessageBox(void)
{
	int ret = NmrkMessageBox(MAKEINTRESOURCE(IDS_DO_YOU_REALLY_WANT_TO_QUIT_THE_WIZARD_NOW),
        NULL, MB_YESNO | MB_DEFBUTTON2);

	return ( ret == IDYES ) ? TRUE : FALSE;

}

////////////////////////////////////////////////////////////////////////////////////////////////////
// Copy a string using the "new" allocator.... string must be deleted with delete [];
//
TCHAR *MakeCopyOfString( const TCHAR* sz ) {

    if( NULL == sz ) { return NULL; }
    TCHAR* local = new char[ strlen( sz ) + 1 ];
    if( NULL == local ) { return NULL; }
    lstrcpy( local, sz );
    return local;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\nmrk\fileparm.cpp ===
#include "Precomp.h"
#include "resource.h"
#include "global.h"
#include "PropPg.h"
//#include "SelTargt.h"
#include "FileParm.h"
#include "nmakwiz.h"



////////////////////////////////////////////////////////////////////////////////////////////////////
// Static member vars
/* static */ CDistributionSheet* CDistributionSheet::ms_pDistributionFileSheet = NULL;
/* static */ int CDistributionSheet::ms_MaxDistributionFilePathLen;
/* static */ TCHAR CDistributionSheet::ms_szOFNData[ MAX_PATH];

////////////////////////////////////////////////////////////////////////////////////////////////////
// Static member fns

BOOL APIENTRY CDistributionSheet::DlgProc( HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam ) {
    

    switch( message ) 
	{
		case WM_INITDIALOG:
		{
			PropSheet_SetWizButtons( GetParent( hDlg ), PSWIZB_NEXT | PSWIZB_BACK ); 
			ms_pDistributionFileSheet->CreateFilePanes(hDlg);
	
			return TRUE;
		}

        case WM_COMMAND:
		{
            switch (GET_WM_COMMAND_ID(wParam, lParam))
            {
                case IDC_BUTTON_BROWSE_DISTRIBUTION_FILE_PATH:
                {
                    switch (GET_WM_COMMAND_CMD(wParam, lParam))
                    {
                        case BN_CLICKED:
                        {
							ms_pDistributionFileSheet->m_pDistroFilePane->QueryFilePath( );
							return TRUE;
                            break;
                        }
                    }
                    break;
                }

                case IDC_BUTTON_BROWSE_AUTO_CONFIG_PATH:
                {
                    switch (GET_WM_COMMAND_CMD(wParam, lParam))
                    {
                        case BN_CLICKED:
                        {
							ms_pDistributionFileSheet->m_pAutoFilePane->QueryFilePath( );
							return TRUE;
                            break;
                        }
                    }
                    break;
                }
            }
            break;
        }


		case WM_NOTIFY:
		{
			switch( reinterpret_cast< NMHDR FAR* >( lParam )->code ) 
			{
				case PSN_QUERYCANCEL: 
					SetWindowLong( hDlg, DWL_MSGRESULT, !VerifyExitMessageBox());
					return TRUE;

                case PSN_SETACTIVE:
                    g_hwndActive = hDlg;
                    PropSheet_SetWizButtons( GetParent( hDlg ), PSWIZB_NEXT | PSWIZB_BACK ); 

                    ms_pDistributionFileSheet->m_pDistroFilePane->Validate(FALSE);

					ms_pDistributionFileSheet->m_pAutoFilePane->Validate(FALSE);

			        return TRUE;

                case PSN_WIZNEXT:   
					// Distro
                    if( !ms_pDistributionFileSheet->m_pDistroFilePane->Validate(TRUE) )
					{
						SetWindowLong( hDlg, DWL_MSGRESULT, -1 );
						return TRUE;
					}

					// AutoConf
					if( !ms_pDistributionFileSheet->m_pAutoFilePane->Validate(TRUE) )
					{
						SetWindowLong( hDlg, DWL_MSGRESULT, -1 );
						return TRUE;
					}
					
					if( ms_pDistributionFileSheet->m_pAutoFilePane->OptionEnabled() )
					{
						if( !Edit_GetTextLength( 
							GetDlgItem( ms_pDistributionFileSheet->m_pAutoFilePane->GetHwnd(),
										IDC_AUTOCONF_URL ) ) )
						{
							NmrkMessageBox(MAKEINTRESOURCE(IDS_NEED_CONF_SERVER), NULL, MB_OK | MB_ICONWARNING );
							SetWindowLong( hDlg, DWL_MSGRESULT, -1 );
							return TRUE;
						}
					}
					else if( ms_pDistributionFileSheet->m_bHadAutoConf )
					{
						if( IDNO == NmrkMessageBox(MAKEINTRESOURCE(IDS_TURNING_OFF_AUTOCONF), NULL, MB_YESNO | MB_ICONWARNING ) )
						{
							ms_pDistributionFileSheet->m_pAutoFilePane->SetCheck( IDC_CHECK_AUTOCONFIG_CLIENTS, TRUE );
							SetWindowLong( hDlg, DWL_MSGRESULT, -1 );
							return TRUE;
						}
						else
						{
							ms_pDistributionFileSheet->m_pAutoFilePane->SetEditData( IDC_EDIT_AUTO_CONFIG_FILE_PATH, ms_pDistributionFileSheet->m_szLastLocation );
							ms_pDistributionFileSheet->m_bLastRoundUp = TRUE;
						}
					}

					return TRUE;
			}
		}

		default:
			break;

	}

	return FALSE;

}


////////////////////////////////////////////////////////////////////////////////////////////////////
// Member fns


CDistributionSheet::CDistributionSheet( void )
 : m_PropertySheetPage( MAKEINTRESOURCE( IDD_PROPPAGE_DEFAULT ), 
						( DLGPROC ) CDistributionSheet::DlgProc /*, 
						PSP_HASHELP   */
                       ),
    m_pDistroFilePane( NULL ), m_pAutoFilePane( NULL ), m_bHadAutoConf( FALSE ), m_bLastRoundUp( FALSE ), m_szLastLocation( NULL )
{   
	 ZeroMemory( &m_ofn, sizeof( OPENFILENAME ) );
     ms_MaxDistributionFilePathLen = MAX_PATH;
     ms_pDistributionFileSheet = this; 
}

CDistributionSheet::~CDistributionSheet( void ) 
{ 
	delete m_pDistroFilePane;
    m_pDistroFilePane = NULL;

	delete m_pAutoFilePane;
    m_pAutoFilePane = NULL;

	delete [] m_szLastLocation;
    m_szLastLocation = NULL;

    ms_pDistributionFileSheet = NULL;
}

void CDistributionSheet::CreateFilePanes(HWND hWndDlg) 
{
	RECT rect;

	GetClientRect( hWndDlg, &rect );
	int iWidth = rect.right - CPropertyDataWindow2::mcs_iLeft;
	int iTop = CPropertyDataWindow2::mcs_iTop + CPropertyDataWindow2::mcs_iBorder;

	// The top panel is being given 1/3 of the vertical space
	int iHeight = MulDiv( rect.bottom, 1, 3 );
	m_pDistroFilePane = new CFilePanePropWnd2(hWndDlg,
											IDD_FILEPANE_DISTRO,
											TEXT("IDD_FILEPANE_DISTRO"),
											0,
											CPropertyDataWindow2::mcs_iLeft,
											iTop,
											iWidth,
											iHeight );

	HWND hwndCond = GetDlgItem( m_pDistroFilePane->GetHwnd(), IDC_CHECK_CREATE_DISTRIBUTION );
	m_pDistroFilePane->ConnectControlsToCheck( IDC_CHECK_CREATE_DISTRIBUTION, 2,
										new CControlID( hwndCond,
														IDC_CHECK_CREATE_DISTRIBUTION,
														IDC_EDIT_DISTRIBUTION_FILE_PATH,
														CControlID::EDIT ),
										new CControlID( hwndCond,
														IDC_CHECK_CREATE_DISTRIBUTION,
														IDC_BUTTON_BROWSE_DISTRIBUTION_FILE_PATH,
														// Note this is not a check but I don't think I care
														CControlID::CHECK ) );

	m_pDistroFilePane->SetFilePane( FALSE, IDC_EDIT_DISTRIBUTION_FILE_PATH,
								IDC_CHECK_CREATE_DISTRIBUTION,
								IDC_BUTTON_BROWSE_DISTRIBUTION_FILE_PATH,
					   			TEXT( "Application (*.exe)" ),
								TEXT( ".exe" ),
								TEXT( "Nm3c.exe" ) );

	m_pDistroFilePane->SetCheck( IDC_CHECK_CREATE_DISTRIBUTION, TRUE );


	//iHeight = rect.bottom - iHeight;
	m_pAutoFilePane = new CFilePanePropWnd2(hWndDlg,
										IDD_FILEPANE_AUTOCONF,
										TEXT("IDD_FILEPANE_AUTOCONF"),
										0,
										CPropertyDataWindow2::mcs_iLeft,
										iHeight,
										iWidth,
										rect.bottom - iHeight );

	hwndCond = GetDlgItem( m_pAutoFilePane->GetHwnd(), IDC_CHECK_AUTOCONFIG_CLIENTS );
	m_pAutoFilePane->ConnectControlsToCheck( IDC_CHECK_AUTOCONFIG_CLIENTS, 3,
										new CControlID( hwndCond,
														IDC_CHECK_AUTOCONFIG_CLIENTS,
														IDC_EDIT_AUTO_CONFIG_FILE_PATH,
														CControlID::EDIT ),
										new CControlID( hwndCond,
														IDC_CHECK_AUTOCONFIG_CLIENTS,
														IDC_AUTOCONF_URL,
														CControlID::EDIT ),
										new CControlID( hwndCond,
														IDC_CHECK_AUTOCONFIG_CLIENTS,
														IDC_BUTTON_BROWSE_AUTO_CONFIG_PATH,
														// Note this is not a check but I don't think I care
														CControlID::CHECK ) );


	m_pAutoFilePane->SetFilePane( FALSE, IDC_EDIT_AUTO_CONFIG_FILE_PATH,
								IDC_CHECK_AUTOCONFIG_CLIENTS,
								IDC_BUTTON_BROWSE_AUTO_CONFIG_PATH,
								TEXT( "Application Settings(*.inf)" ),
								TEXT( ".inf" ),
								TEXT( "nm3conf.inf" ) );
	m_pAutoFilePane->SetCheck( IDC_CHECK_AUTOCONFIG_CLIENTS, FALSE );

	if (g_pWiz->m_IntroSheet.GetFilePane()->OptionEnabled())
	{
		m_pDistroFilePane->ReadSettings();
		m_pAutoFilePane->ReadSettings();
	}

	if (m_bHadAutoConf = m_pAutoFilePane->OptionEnabled())
	{
		m_szLastLocation = new TCHAR[ MAX_PATH ];
		assert( m_szLastLocation );
		m_pAutoFilePane->GetPathAndFile( m_szLastLocation );
	}

	m_pAutoFilePane->ShowWindow( TRUE );
	m_pDistroFilePane->ShowWindow( TRUE );

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\nmrk\nmak.cpp ===
#include "precomp.h"
#include "resource.h"
#include "NmAkWiz.h"



int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hInstPrev, LPSTR lpCmdLine, int nCmdShow) 
{

	CNmAkWiz::DoWizard( hInstance );
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\nmrk\nmakreg.h ===
#ifndef __NMAKReg_h__
#define __NMAKReg_h__


////////////////////////////////////////////////////////////////////////////////////////////////////
#ifndef TEXT
    #define TEXT( a ) ( a )
#endif // TEXT

////////////////////////////////////////////////////////////////////////////////////////////////////


//
// GLOBAL SETTINGS FILE, THIS IS USED BY THE SOFTWARE COMPONENTS ALSO.
// That way, we have one place where registry keys, settings go, and 
// modifications affect the NMRK as well as the code.
// 
#include <confreg.h>

#define REGKEY_NMRK                         TEXT("SOFTWARE\\Microsoft\\NMRK")
#define REGVAL_INSTALLATIONDIRECTORY        TEXT("InstallationDirectory")
#define REGVAL_LASTCONFIG                   TEXT("LastConfig")

#define DEFAULT_CONFIGFILE                  "nm3c.ini"
#define SECTION_SETTINGS                    TEXT("NMRK30Settings")

#define KEYNAME_AUTOCONF                    TEXT("AutoConf")
#define KEYNAME_ILSSERVER                   TEXT("IlsServer%d")
#define KEYNAME_ILSDEFAULT                  TEXT("IlsDefault")

#define KEYNAME_WEBVIEWNAME					TEXT("WebViewName")
#define KEYNAME_WEBVIEWURL					TEXT("WebViewURL")
#define KEYNAME_WEBVIEWSERVER				TEXT("WebViewServer")

#endif // __NMAKReg_h__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\nmrk\precomp.h ===
#ifndef __Precomp_h_
#define __Precomp_h_

#define OEMRESOURCE
#pragma warning( disable : 4786 )

#include <windows.h>
#include <windowsx.h>
#include <commctrl.h>
#include <commdlg.h>
#include <dlgs.h>
#include <shellapi.h>
#include <prsht.h>
#include <assert.h>
#include <limits.h>
#include <tchar.h>
#include <shlobj.h>
#include "Util.h"

//#include "resource.h"
extern HINSTANCE    g_hInstance;
extern HWND         g_hwndActive;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\nmrk\nmakwiz.h ===
////////////////////////////////////////////////////////////////////////////////////////////////////
//----------------------------------------------------
//| NetMeeting Administration Kit Wizard  ( NmAkWiz )|
//----------------------------------------------------
//
// This is the controling class for the NetMeeting Administration Kit Wizard. Most of
// this could have been done globally, but it is so much prettier when it is enclosed in a class...
// CNmAkViz objects are not actually created by the user.  The only access is provided through the
// static member function DoWizard.  All the user has to do is call this single function, like this:
//
//
/////////////
//
// #include "NmAkWiz.h"
//
//
// int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hInstPrev, LPSTR lpCmdLine, int nCmdShow) {
//
//      CNmAkWiz::DoWizard( hInstance );
//      ExitProcess(0);
//    return 0;
// }
//
//
////////////////////////////////////////////////////////////////////////////////////////////////////


#ifndef __NmAkWiz_h__
#define __NmAkWiz_h__

////////////////////////////////////////////////////////////////////////////////////////////////////
// Include files

#include "PShtHdr.h"
#include "WelcmSht.h"
#include "SetInSht.h"
#include "SetSht.h"
#include "FileParm.h"
#include "FinishDg.h"
#include "PolData.h"
#include "DSList.h"
#include "Confirm.h"



////////////////////////////////////////////////////////////////////////////////////////////////////

#pragma warning( disable : 4786 )
#include <map>
using namespace std;



////////////////////////////////////////////////////////////////////////////////////////////////////
// This is the NetMeeting Resource Deployment Wizard

class CNmAkWiz {

public: 
	friend class CIntroSheet;
	friend class CSettingsSheet;
    friend class CCallModeSheet;
    friend class CConfirmationSheet;
    friend class CDistributionSheet;
    friend class CFinishSheet;
    friend class CPropertyDataWindow2;
	
	// STATIC Fns
	static  HRESULT  DoWizard( HINSTANCE hInstance );
    void    CallbackForWhenUserHitsFinishButton( void );

private: // private static Data
    static TCHAR                                ms_InfFilePath[ MAX_PATH ];
    static TCHAR                                ms_InfFileName[ MAX_PATH ];
    static TCHAR                                ms_FileExtractPath[ MAX_PATH ];
    static TCHAR                                ms_ToolsFolder[ MAX_PATH ];
    static TCHAR                                ms_NetmeetingSourceDirectory[ MAX_PATH ];
    static TCHAR                                ms_NetmeetingOutputDirectory[ MAX_PATH ];
    static TCHAR                                ms_NetmeetingOriginalDistributionFilePath[ MAX_PATH ];
    static TCHAR                                ms_NetmeetingOriginalDistributionFileName[ MAX_PATH ];
    static TCHAR                                ms_NMRK_TMP_FolderName[ MAX_PATH ];

public: // DATATYPES
	enum eSheetIDs
    {
        ID_WelcomeSheet = 0, 
        ID_IntroSheet,
        ID_SettingsSheet,
        ID_CallModeSheet,
        ID_ConfirmationSheet,
        ID_DistributionSheet,
        ID_FinishSheet,
        ID_NumSheets
    };



private:    // Construction / destruction ( private, so only access is through DoWizard( ... )
	CNmAkWiz( void );
	~CNmAkWiz( void );

public:    // Data
	CPropertySheetHeader        m_PropSheetHeader;
	CWelcomeSheet               m_WelcomeSheet;
    CIntroSheet                 m_IntroSheet;
    CSettingsSheet              m_SettingsSheet;
    CCallModeSheet              m_CallModeSheet;
    CConfirmationSheet          m_ConfirmationSheet;
    CDistributionSheet          m_DistributionSheet;
    CFinishSheet                m_FinishSheet;

private:
    HANDLE                      m_hInfFile;

private: // HELPER Fns

	void _CreateTextSpew( void );
	void _CreateDistro( void );
	void _CreateAutoConf( void );
	void _CreateFinalAutoConf( void );
    void _CreateSettingsFile( void );

    BOOL _InitInfFile( void );
    BOOL _StoreDialogData( HANDLE hFile );
    BOOL _CloseInfFile( void );
    BOOL _CreateDistributableFile( CFilePanePropWnd2 *pFilePane );
    BOOL _CreateFileDistribution( CFilePanePropWnd2 *pFilePane );
    BOOL _DeleteFiles( void );
    BOOL _GetNetMeetingOriginalDistributionData( void );
    BOOL _NetMeetingOriginalDistributionIsAtSpecifiedLocation( void );

    BOOL _ExtractOldNmCabFile( void );
    BOOL _CreateNewInfFile( void );
    BOOL _SetPathNames( void );
};

extern CNmAkWiz *   g_pWiz;
const TCHAR* GetInstallationPath( void );


int NmrkMessageBox(LPCSTR lpText, LPCSTR lpCaption, UINT uType, HWND hwndParent=NULL);


#endif // __NmAkWiz_h__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\nmrk\proppg.cpp ===
////////////////////////////////////////////////////////////////////////////////////////////////////
// NOTE: THIS HAS NOT BEEN THROUGHLY TESTED. IT IS A SIMPLE CLASS, AND BUGS SHOULD 
//      PRESENT THEMSELVES THROUGH USAGE. THE BUGS SHOULD BE SIMPLE TO FIX. 

////////////////////////////////////////////////////////////////////////////////////////////////////
// Include Files
////////////////////////////////////////////////////////////////////////////////////////////////////

#include "precomp.h"
#include "PropPg.h"


////////////////////////////////////////////////////////////////////////////////////////////////////
// Construction, Destruction, and Initialization funcs
////////////////////////////////////////////////////////////////////////////////////////////////////


//--------------------------------------------------------------------------------------------------
// CPropertySheetPage::CPropertySheetPage

CPropertySheetPage::CPropertySheetPage( void ) {
	_InitData();
}



//--------------------------------------------------------------------------------------------------
// CPropertySheetPage::CPropertySheetPage
CPropertySheetPage::CPropertySheetPage( const CPropertySheetPage& r ) {
	_InitData();
	*this = r;
}



//--------------------------------------------------------------------------------------------------
// CPropertySheetPage::CPropertySheetPage
// pszTemplate can specify either the resource identifier of the template 
// or the address of a string that specifies the name of the template
CPropertySheetPage::CPropertySheetPage( LPCTSTR pszTemplate, DLGPROC pfnDlgProc, 
										DWORD dwFlags /* = 0 */,  LPARAM lParam /* = 0L */  ) {

	_InitData();

	this -> dwFlags = dwFlags;
	if( ! _Set_hInstance( g_hInstance ) )				{ return; }
	if( ! _Set_pszTemplate( pszTemplate ) )		{ return; }
	if( ! _Set_pfnDlgProc( pfnDlgProc ) )		{ return; }
	if( ! _Set_lParam( lParam ) )				{ return; }
	if( ! _Validate() )							{ return; }
}


//--------------------------------------------------------------------------------------------------
// CPropertySheetPage::CPropertySheetPage
CPropertySheetPage::CPropertySheetPage( LPCDLGTEMPLATE pResource, DLGPROC pfnDlgProc,
										DWORD dwFlags /* = 0 */,  LPARAM lParam /* = 0L */  ) {

	_InitData();
	this -> dwFlags = dwFlags;
	if( ! _Set_hInstance( g_hInstance ) )				{ return; }
	if( ! _Set_pResource( pResource ) )			{ return; }
	if( ! _Set_pfnDlgProc( pfnDlgProc ) )		{ return; }
	if( ! _Set_lParam( lParam ) )				{ return; }
	if( ! _Validate() )							{ return; }

}


//--------------------------------------------------------------------------------------------------
// CPropertySheetPage::CPropertySheetPage
// pszTemplate can specify either the resource identifier of the template 
// or the address of a string that specifies the name of the template
CPropertySheetPage::CPropertySheetPage( LPCTSTR pszTemplate, DLGPROC pfnDlgProc, 
										HICON hIcon, /* = NULL */ LPCTSTR pszTitle /* = NULL */,  DWORD dwFlags, /* = 0 */
										LPARAM lParam /* =NULL */, LPFNPSPCALLBACK pfnCallBack, /* =NULL */
										UINT FAR * pcRefParent /* =NULL */
										) {
	_InitData();
	this -> dwFlags = dwFlags;

	if( ! _Set_hInstance( g_hInstance ) )				{ return; }
	if( ! _Set_pszTemplate( pszTemplate ) )		{ return; }
	if( ! _Set_hIcon( hIcon ) )					{ return; }
	if( ! _Set_pszTitle( pszTitle ) )			{ return; }
	if( ! _Set_pfnDlgProc( pfnDlgProc ) )		{ return; }
	if( ! _Set_lParam( lParam ) )				{ return; }
	if( ! _Set_pfnCallback( pfnCallBack ) )		{ return; }
	if( ! _Set_pcRefParent( pcRefParent ) )		{ return; }
	if( ! _Validate() )							{ return; }

}


//--------------------------------------------------------------------------------------------------
// CPropertySheetPage::CPropertySheetPage
CPropertySheetPage::CPropertySheetPage( LPCDLGTEMPLATE pResource, DLGPROC pfnDlgProc, 
										HICON hIcon, /* = NULL */ LPCTSTR pszTitle /* = NULL */, DWORD dwFlags, /* = 0 */
										LPARAM lParam /* =NULL */, LPFNPSPCALLBACK pfnCallBack,/* =NULL */
										UINT FAR * pcRefParent /* =NULL */
										) {

	_InitData();
	this -> dwFlags = dwFlags;

	if( ! _Set_hInstance( g_hInstance ) )				{ return; }
	if( ! _Set_pResource( pResource ) )			{ return; }
	if( ! _Set_hIcon( hIcon ) )					{ return; }
	if( ! _Set_pszTitle( pszTitle ) )			{ return; }
	if( ! _Set_pfnDlgProc( pfnDlgProc ) )		{ return; }
	if( ! _Set_lParam( lParam ) )				{ return; }
	if( ! _Set_pfnCallback( pfnCallBack ) )		{ return; }
	if( ! _Set_pcRefParent( pcRefParent ) )		{ return; }
	if( ! _Validate() )							{ return; }


}

//--------------------------------------------------------------------------------------------------
// CPropertySheetPage::CPropertySheetPage
CPropertySheetPage::CPropertySheetPage( LPCTSTR pszTemplate, DLGPROC pfnDlgProc, 
										LPCTSTR pszIcon /* =0 */, LPCTSTR pszTitle /* = NULL */, DWORD dwFlags, /* = 0 */
										LPARAM lParam /* =NULL */, LPFNPSPCALLBACK pfnCallBack, /* =NULL */
										UINT FAR * pcRefParent /* =NULL */
										) {
	_InitData();
	this -> dwFlags = dwFlags;

	if( ! _Set_hInstance( g_hInstance ) )				{ return; }
	if( ! _Set_pszTemplate( pszTemplate ) )		{ return; }
	if( ! _Set_pszIcon( pszIcon ) )				{ return; }
	if( ! _Set_pszTitle( pszTitle ) )			{ return; }
	if( ! _Set_pfnDlgProc( pfnDlgProc ) )		{ return; }
	if( ! _Set_lParam( lParam ) )				{ return; }
	if( ! _Set_pfnCallback( pfnCallBack ) )		{ return; }
	if( ! _Set_pcRefParent( pcRefParent ) )		{ return; }
	if( ! _Validate() )							{ return; }


}

//--------------------------------------------------------------------------------------------------
// CPropertySheetPage::CPropertySheetPage
CPropertySheetPage::CPropertySheetPage( LPCDLGTEMPLATE pResource, DLGPROC pfnDlgProc, 
										LPCTSTR pszIcon /* =0 */, LPCTSTR pszTitle /* = NULL */, DWORD dwFlags, /* = 0 */
										LPARAM lParam /* =NULL */, LPFNPSPCALLBACK pfnCallBack, /* =NULL */ 
										UINT FAR * pcRefParent /* =NULL */
										) {

	_InitData();
	this -> dwFlags = dwFlags;

	if( ! _Set_hInstance( g_hInstance ) )				{ return; }
	if( ! _Set_pResource( pResource ) )			{ return; }
	if( ! _Set_pszIcon( pszIcon ) )				{ return; }
	if( ! _Set_pszTitle( pszTitle ) )			{ return; }
	if( ! _Set_pfnDlgProc( pfnDlgProc ) )		{ return; }
	if( ! _Set_lParam( lParam ) )				{ return; }
	if( ! _Set_pfnCallback( pfnCallBack ) )		{ return; }
	if( ! _Set_pcRefParent( pcRefParent ) )		{ return; }
	if( ! _Validate() )							{ return; }
}


//--------------------------------------------------------------------------------------------------
// CPropertySheetPage::CPropertySheetPage
CPropertySheetPage::CPropertySheetPage( LPCPROPSHEETPAGE pPageVector ) {

    memcpy( this, pPageVector, sizeof( PROPSHEETPAGE ) );
	_Validate();
}


//--------------------------------------------------------------------------------------------------
// CPropertySheetPage::~CPropertySheetPage
CPropertySheetPage::~CPropertySheetPage( void ) {

}


////////////////////////////////////////////////////////////////////////////////////////////////////
// Public Member Fns
////////////////////////////////////////////////////////////////////////////////////////////////////



//--------------------------------------------------------------------------------------------------
// operator= assigns *this to another CPropertySheetPage
// Because there are no pointers or references in the PROPSHEETPAGE structure, the contents may 
// simply be memory copied

CPropertySheetPage& CPropertySheetPage::operator=( const CPropertySheetPage& r ) {
	
	LPCPROPSHEETPAGE pcSrc = static_cast< LPCPROPSHEETPAGE >( &r );
	LPPROPSHEETPAGE pDst = static_cast< LPPROPSHEETPAGE >( this );

	memcpy( pDst, pcSrc, sizeof( PROPSHEETPAGE ) );

	return *this;
}





////////////////////////////////////////////////////////////////////////////////////////////////////
// Private Helper Fns
////////////////////////////////////////////////////////////////////////////////////////////////////


void CPropertySheetPage::_InitData( void ) {
	ZeroMemory( this, sizeof( PROPSHEETPAGE ) );
	this -> dwSize = sizeof( PROPSHEETPAGE );
	this -> dwFlags |= PSP_DEFAULT;
}
			
//--------------------------------------------------------------------------------------------------
// _IsRightToLeftLocale is called to determine the value of one of the flags in the PROPSHEETPAGE
// datastructure.  If this is to be a robust and complete wrapper class, this should be implemented

BOOL CPropertySheetPage::_IsRightToLeftLocale( void ) const {
	// BUGBUG
	// this is not implemented, and it may not act properly when implemented, 
	// Look at the the usage as well
	return FALSE;
}


////////////////////////////////////////////////////////////////////////////////////////////////////
// Data Setting and validation funcs
////////////////////////////////////////////////////////////////////////////////////////////////////


//--------------------------------------------------------------------------------------------------
// _Set_hInstance

BOOL CPropertySheetPage::_Set_hInstance( HINSTANCE hInst ) {

#ifdef CPropertySheetPage_ValidateParameters

	if( NULL == hInst ) { assert( 0 ); return FALSE; }

#endif // CPropertySheetPage_ValidateParameters

	this -> hInstance = hInst;

	return TRUE;
}

//--------------------------------------------------------------------------------------------------
// _Set_pszTemplate

BOOL CPropertySheetPage::_Set_pszTemplate( LPCTSTR pszTemplate ) {

#ifdef CPropertySheetPage_ValidateParameters

	if( NULL == pszTemplate ) { assert( 0 ); return FALSE; }
	if( this -> dwFlags & PSP_DLGINDIRECT ) { // If the PSP_DLGINDIRECT is set, pszTemplate is ignored
		assert( 0 );
		return FALSE;
	}

#endif // CPropertySheetPage_ValidateParameters

	this -> pszTemplate = pszTemplate;
	return TRUE;
}

//--------------------------------------------------------------------------------------------------
// _Set_pResource

BOOL CPropertySheetPage::_Set_pResource( LPCDLGTEMPLATE pResource ) {

#ifdef CPropertySheetPage_ValidateParameters
	
	if( NULL == pResource ) { assert( 0 ); return FALSE; }

#endif // CPropertySheetPage_ValidateParameters

	this -> pResource = pResource;
	this -> dwFlags |= PSP_DLGINDIRECT;
	return TRUE;
}

//--------------------------------------------------------------------------------------------------
// _Set_hIcon

BOOL CPropertySheetPage::_Set_hIcon( HICON hIcon ) {

#ifdef CPropertySheetPage_ValidateParameters

	if( ( NULL == hIcon ) && ( dwFlags & PSP_USEHICON ) ) { assert( 0 ); return FALSE; }
	if ( dwFlags & PSP_USEICONID ) { assert( 0 ); return FALSE; }

#endif // CPropertySheetPage_ValidateParameters

	if( NULL != hIcon ) {
		this -> dwFlags |= PSP_USEHICON;
		this -> hIcon = hIcon;
	}
	
	return TRUE;
}

//--------------------------------------------------------------------------------------------------
// _Set_pszIcon

BOOL CPropertySheetPage::_Set_pszIcon( LPCTSTR pszIcon ) {

#ifdef CPropertySheetPage_ValidateParameters

	if( ( NULL == pszIcon ) && ( dwFlags & PSP_USEICONID  ) ) { // This is a bad parameter
		assert( 0 );
		return FALSE;
	}

	if ( dwFlags & PSP_USEHICON ) {	// Wrong function signature, use the one that takes LPCTSTR pszIcon /* =0 */
		assert( 0 );
		return FALSE;
	}

#endif // CPropertySheetPage_ValidateParameters

	if( NULL != pszIcon ) {
		this -> pszIcon = pszIcon;
		this -> dwFlags |= PSP_USEICONID;
	}

	return TRUE;
}

//--------------------------------------------------------------------------------------------------
// _Set_pszTitle

BOOL CPropertySheetPage::_Set_pszTitle( LPCTSTR pszTitle ) {

#ifdef CPropertySheetPage_ValidateParameters

	if( ( NULL == pszTitle ) && ( dwFlags & PSP_USETITLE ) ) { // This is a bad parameter
		assert( 0 );
		return FALSE;
	}

#endif // CPropertySheetPage_ValidateParameters

	if( NULL != pszTitle ) {
		this -> pszTitle = pszTitle;
		this -> dwFlags |= PSP_USETITLE;
	}

	return TRUE;
}

//--------------------------------------------------------------------------------------------------
// _Set_pfnDlgProc


BOOL CPropertySheetPage::_Set_pfnDlgProc( DLGPROC pfnDlgProc ) {

#ifdef CPropertySheetPage_ValidateParameters

	if( NULL == pfnDlgProc ) { assert( 0 ); return FALSE; }
#endif // CPropertySheetPage_ValidateParameters

	this -> pfnDlgProc = pfnDlgProc;
	return TRUE;
}

//--------------------------------------------------------------------------------------------------
// _Set_pfnCallback


BOOL CPropertySheetPage::_Set_pfnCallback( LPFNPSPCALLBACK pfnCallBack ) {

#ifdef CPropertySheetPage_ValidateParameters

	if( ( NULL == pfnCallBack ) && ( dwFlags & PSP_USECALLBACK ) ) {	// This is a bad parameter
		assert( 0 );
		return FALSE;
	}

#endif // CPropertySheetPage_ValidateParameters

	if( NULL != pfnCallback ) {
		this -> pfnCallback = pfnCallback;
		this -> dwFlags |= PSP_USECALLBACK;
	}

	return TRUE;
}

//--------------------------------------------------------------------------------------------------
// _Set_pcRefParent


BOOL CPropertySheetPage::_Set_pcRefParent( UINT FAR * pcRefParent ) {


#ifdef CPropertySheetPage_ValidateParameters

	if( ( NULL == pcRefParent ) && ( dwFlags & PSP_USEREFPARENT ) ) {	// This is a bad parameter
		assert( 0 );
		return FALSE;
	}

#endif // CPropertySheetPage_ValidateParameters

	if( NULL != pcRefParent ) {
		this -> pcRefParent = pcRefParent;
		this -> dwFlags |= PSP_USEREFPARENT;
	}

	return TRUE;

}

//--------------------------------------------------------------------------------------------------
// _Set_lParam


BOOL CPropertySheetPage::_Set_lParam( LPARAM lParam ) {

#ifdef CPropertySheetPage_ValidateParameters

#endif // CPropertySheetPage_ValidateParameters

	this -> lParam = lParam;

	return TRUE;
}

//--------------------------------------------------------------------------------------------------
// _Validate


BOOL CPropertySheetPage::_Validate( void ) const {

#ifdef CPropertySheetPage_ValidateParameters

	// Make sure there are no mutually exclusize flags set

	if( ( this -> dwFlags & PSP_USEICONID ) && ( this -> dwFlags & PSP_USEHICON ) ) {
		assert( 0 );
		return FALSE;
	}

	// Make sure that the data is valid ( for set flags )
	if( this -> dwFlags & PSP_DLGINDIRECT ) { // We must validate pResource
		if( NULL == pResource ) {
			assert( 0 );
			return FALSE;
		}
	}
	else { // We must validate pszTemplate 
		if( NULL == this -> pszTemplate ) {
			assert( 0 );
			return FALSE;
		}
	}

	if( this -> dwFlags & PSP_USECALLBACK ) {
		if( NULL == this -> pfnCallback ) {
			assert( 0 );
			return FALSE;
		}
	}

	if( this -> dwFlags & PSP_USEREFPARENT ) {
		if( NULL == this -> pcRefParent ) {
			assert( 0 );
			return FALSE;
		}
	}
	if( this -> dwFlags & PSP_USETITLE ) {
		if( NULL == this -> pszTitle ) {
			assert( 0 );
			return FALSE;
		}
	}
 
#endif // CPropertySheetPage_ValidateParameters

	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\nmrk\nmakwiz.cpp ===
////////////////////////////////////////////////////////////////////////////////////////////////////
// Look at the header file for usage information...


#include "precomp.h"
#include "resource.h"
#include <direct.h>
#include "PropPg.h"
#include "PShtHdr.h"
#include "NmAkWiz.h"
#include "PolData.h"
#include "NMAKReg.h"

/////////////////
// Global
/////////////////
CNmAkWiz *  g_pWiz = NULL;
HWND        g_hwndActive = NULL;
HINSTANCE   g_hInstance = NULL;

////////////////////////////////////////////////////////////////////////////////////////////////////
// Static Data
////////////////////////////////////////////////////////////////////////////////////////////////////

/* static */ TCHAR CNmAkWiz::ms_InfFilePath[ MAX_PATH ] = TEXT("output");
/* static */ TCHAR CNmAkWiz::ms_InfFileName[ MAX_PATH ] = TEXT("msnetmtg.inf");
/* static */ TCHAR CNmAkWiz::ms_FileExtractPath[ MAX_PATH ] = TEXT("output");
/* static */ TCHAR CNmAkWiz::ms_ToolsFolder[ MAX_PATH ] = TEXT("tools");
/* static */ TCHAR CNmAkWiz::ms_NetmeetingOriginalDistributionFilePath[ MAX_PATH ] = TEXT("");
/* static */ TCHAR CNmAkWiz::ms_NetmeetingSourceDirectory[ MAX_PATH ] = TEXT("source");
/* static */ TCHAR CNmAkWiz::ms_NetmeetingOutputDirectory[ MAX_PATH ] = TEXT("output");
/* static */ TCHAR CNmAkWiz::ms_NetmeetingOriginalDistributionFileName[ MAX_PATH ] = TEXT("nm30.exe");
/* static */ TCHAR CNmAkWiz::ms_NMRK_TMP_FolderName[ MAX_PATH ] = TEXT("nmrktmp");


////////////////////////////////////////////////////////////////////////////////////////////////////
// Static Fns
////////////////////////////////////////////////////////////////////////////////////////////////////

//--------------------------------------------------------------------------------------------------
// DoWizard is a static function of CNmAkWiz.  This was done for two reasons:
// 1.) There is always only a single CNmAkViz object
// 2.) I wanted to make it clear that duriving something from CNmAkWiz is nonsense, so only access
//         to the CNmAkViz constructor and destructor is through this static helper function
// 
// Do Wizard "blocks" while the modal NetMeeting AK Wizard does it's thing.
HRESULT CNmAkWiz::DoWizard( HINSTANCE hInstance )
{
    g_hInstance = hInstance;
    
    if( NULL == GetInstallationPath() )
    {   
        // This means that NMRK is not properly installed
        NmrkMessageBox(MAKEINTRESOURCE(IDS_NMAKWIZ_ERROR_NMRK_MUST_BE_PROPERLY_INSTALLED),
            MAKEINTRESOURCE(IDS_NMAKWIZ_ERROR_CAPTION), MB_OK | MB_ICONSTOP);

        NmrkMessageBox(MAKEINTRESOURCE(IDS_NMAKWIZ_ERROR_PLEASE_REINSTALL_NET_MEETING_RESOURCE_KIT),
            MAKEINTRESOURCE(IDS_NMAKWIZ_ERROR_CAPTION), MB_OK | MB_ICONSTOP);

        return E_FAIL;


    }

    // Init common controls
	InitCommonControls();

    g_pWiz = new CNmAkWiz();
    if (!g_pWiz)
        return E_FAIL;

	HRESULT hr;

	// Initialize the Welcome property page
    g_pWiz->m_PropSheetHeader[ ID_WelcomeSheet ]         = g_pWiz->m_WelcomeSheet.GetPropertySheet();
    g_pWiz->m_PropSheetHeader[ ID_IntroSheet ]           = g_pWiz->m_IntroSheet.GetPropertySheet();
    g_pWiz->m_PropSheetHeader[ ID_SettingsSheet ]        = g_pWiz->m_SettingsSheet.GetPropertySheet();
    g_pWiz->m_PropSheetHeader[ ID_CallModeSheet ]        = g_pWiz->m_CallModeSheet.GetPropertySheet();
    g_pWiz->m_PropSheetHeader[ ID_ConfirmationSheet ]    = g_pWiz->m_ConfirmationSheet.GetPropertySheet();
    g_pWiz->m_PropSheetHeader[ ID_DistributionSheet ]    = g_pWiz->m_DistributionSheet.GetPropertySheet();
    g_pWiz->m_PropSheetHeader[ ID_FinishSheet ]          = g_pWiz->m_FinishSheet.GetPropertySheet();

    if (-1 == PropertySheet(g_pWiz->m_PropSheetHeader))
    {
        hr = E_FAIL;
    }
    else
    {
        hr = S_OK;
    }
    
    delete g_pWiz;
    g_pWiz = NULL;

    return hr;
}

void CNmAkWiz::_CreateTextSpew( void )
{
	CFilePanePropWnd2 * pFilePane = m_ConfirmationSheet.GetFilePane();
	if( pFilePane->OptionEnabled() )
	{
		HANDLE hFile = pFilePane->CreateFile( 
						GENERIC_WRITE | GENERIC_READ,
						FILE_SHARE_READ,
						NULL,
						CREATE_ALWAYS,
						FILE_ATTRIBUTE_NORMAL );
		if( INVALID_HANDLE_VALUE == hFile )
		{
			return;
		}
		else 
		{
			HWND hList = m_ConfirmationSheet.GetListHwnd();
			int iLines = ListBox_GetCount( hList );
			DWORD dwWritten = 0;

			for( int i = 0; i < iLines; i++ )
			{
				int iLen = ListBox_GetTextLen( hList, i ) + 1;
				LPTSTR szLine = new TCHAR[ iLen ];
				ListBox_GetText( hList, i, szLine );

				if( !WriteFile( hFile, (void *)szLine, iLen, &dwWritten, NULL ) ||
					!WriteFile( hFile, (void *)TEXT("\r\n"), lstrlen( TEXT("\r\n") ), &dwWritten, NULL ) )
				{
					delete [] szLine;
					return;
				}
				delete [] szLine;
			}

			CloseHandle( hFile );
		}
	}
}

void CNmAkWiz::_CreateDistro( void )
{
	CFilePanePropWnd2 * pFilePane = m_DistributionSheet.GetDistroFilePane();

	if( pFilePane->OptionEnabled() )
	{
        if( ! _SetPathNames() ) { assert( 0 ); return; }

        // First Extract the nm21.exe file to the OUTPUT Directory
        if( !_ExtractOldNmCabFile() ) { assert( 0 ); return; }    

        // Create the new MsNetMtg.inf file in the OUTPUT Directory
        if( !_CreateNewInfFile() ) { assert( 0 ); return; }    

        if( !_CreateFileDistribution( pFilePane ) ) { return; }

		// Clean up after ourselves
        if( !_DeleteFiles() ) { assert( 0 ); return; }
	}
}

void CNmAkWiz::_CreateFinalAutoConf( void )
{
	CFilePanePropWnd2 * pFilePane = m_DistributionSheet.GetAutoFilePane();

//	if( pFilePane->OptionEnabled() )
//	{
		//
		// Try to drop most of the output in a temp file...
		//
		TCHAR szBuf[ 256 ];
		ULONG cbWritten;

		HANDLE hAutoINF = pFilePane->CreateFile( GENERIC_WRITE | GENERIC_READ,
											 FILE_SHARE_READ,
											 NULL,
											 CREATE_ALWAYS,
											 FILE_ATTRIBUTE_NORMAL
										   );
		if( INVALID_HANDLE_VALUE == hAutoINF )
		{
			ErrorMessage();
			return;
		}

		lstrcpy( szBuf, TEXT("[version]\r\nsignature=\"$CHICAGO$\"\r\n\r\n\r\nAdvancedINF=2.5\r\n") );
		if( 0 == WriteFile( hAutoINF, szBuf, lstrlen( szBuf ), &cbWritten, NULL ) ) {
			return;
		}

		// Write string [NetMtg.Install.NMRK]\n
		lstrcpy( szBuf, TEXT("[NetMtg.Install.NMRK]\r\n") );
		if( 0 == WriteFile( hAutoINF, szBuf, lstrlen( szBuf ), &cbWritten, NULL ) ) {
			return;
		}

		lstrcpy( szBuf, TEXT("AddReg=NetMtg.Install.Reg.NMRK\r\n") );
		if( 0 == WriteFile( hAutoINF, szBuf, lstrlen( szBuf ), &cbWritten, NULL ) ) {
			return;
		}

		lstrcpy( szBuf, TEXT("DelReg=NetMtg.Install.DeleteReg.NMRK\r\n") );
		if( 0 == WriteFile( hAutoINF, szBuf, lstrlen( szBuf ), &cbWritten, NULL ) ) {
			return;
		}


		// Write string [NetMtg.Install.Reg.NMRK]\n
		lstrcpy( szBuf, TEXT("\r\n\r\n[NetMtg.Install.Reg.NMRK]\r\n\r\n") );
		if( 0 == WriteFile( hAutoINF, szBuf, lstrlen( szBuf ), &cbWritten, NULL ) ) {
			return;
		}

		lstrcpy( szBuf, TEXT("HKCU,\"SOFTWARE\\Microsoft\\Conferencing\\AutoConf\",\"Use AutoConfig\",65537,0, 0, 0, 0\r\n") );
		if( 0 == WriteFile( hAutoINF, szBuf, lstrlen( szBuf ), &cbWritten, NULL ) ) {
			return;
		}

		// Write the REG Keys
		//_StoreDialogData( hAutoINF );

		// Write string [NetMtg.Install.DeleteReg.NMRK]\n
		lstrcpy( szBuf, TEXT("\r\n\r\n[NetMtg.Install.DeleteReg.NMRK]\r\n\r\n") );
		if( 0 == WriteFile( hAutoINF, szBuf, lstrlen( szBuf ), &cbWritten, NULL ) ) {
			return;
		}

		// Write the REG Delete Keys
		//CPolicyData::FlushCachedInfData( hAutoINF );

		// this is needed...
		lstrcpy( szBuf, TEXT("\r\n\r\n") );
		if( 0 == WriteFile( hAutoINF, szBuf, lstrlen( szBuf ), &cbWritten, NULL ) ) {
			return;
		}

		CloseHandle( hAutoINF );
//	}
}


void CNmAkWiz::_CreateAutoConf( void )
{
	CFilePanePropWnd2 * pFilePane = m_DistributionSheet.GetAutoFilePane();

	if( pFilePane->OptionEnabled() )
	{
		//
		// Try to drop most of the output in a temp file...
		//
		TCHAR szBuf[ 256 ];
		ULONG cbWritten;

		HANDLE hAutoINF = pFilePane->CreateFile( GENERIC_WRITE | GENERIC_READ,
											 FILE_SHARE_READ,
											 NULL,
											 CREATE_ALWAYS,
											 FILE_ATTRIBUTE_NORMAL
										   );
		if( INVALID_HANDLE_VALUE == hAutoINF )
		{
			ErrorMessage();
			return;
		}

		lstrcpy( szBuf, TEXT("[version]\r\nsignature=\"$CHICAGO$\"\r\n\r\n\r\nAdvancedINF=2.5\r\n") );
		if( 0 == WriteFile( hAutoINF, szBuf, lstrlen( szBuf ), &cbWritten, NULL ) ) {
			return;
		}

		// Write string [NetMtg.Install.NMRK]\n
		lstrcpy( szBuf, TEXT("[NetMtg.Install.NMRK]\r\n") );
		if( 0 == WriteFile( hAutoINF, szBuf, lstrlen( szBuf ), &cbWritten, NULL ) ) {
			return;
		}

		lstrcpy( szBuf, TEXT("AddReg=NetMtg.Install.Reg.NMRK\r\n") );
		if( 0 == WriteFile( hAutoINF, szBuf, lstrlen( szBuf ), &cbWritten, NULL ) ) {
			return;
		}

		lstrcpy( szBuf, TEXT("DelReg=NetMtg.Install.DeleteReg.NMRK\r\n") );
		if( 0 == WriteFile( hAutoINF, szBuf, lstrlen( szBuf ), &cbWritten, NULL ) ) {
			return;
		}


		// Write string [NetMtg.Install.Reg.NMRK]\n
		lstrcpy( szBuf, TEXT("\r\n\r\n[NetMtg.Install.Reg.NMRK]\r\n\r\n") );
		if( 0 == WriteFile( hAutoINF, szBuf, lstrlen( szBuf ), &cbWritten, NULL ) ) {
			return;
		}

		// Write the REG Keys
		_StoreDialogData( hAutoINF );

		// Write string [NetMtg.Install.DeleteReg.NMRK]\n
		lstrcpy( szBuf, TEXT("\r\n\r\n[NetMtg.Install.DeleteReg.NMRK]\r\n\r\n") );
		if( 0 == WriteFile( hAutoINF, szBuf, lstrlen( szBuf ), &cbWritten, NULL ) ) {
			return;
		}

		// Write the REG Delete Keys
		CPolicyData::FlushCachedInfData( hAutoINF );

		// this is needed...
		lstrcpy( szBuf, TEXT("\r\n\r\n") );
		if( 0 == WriteFile( hAutoINF, szBuf, lstrlen( szBuf ), &cbWritten, NULL ) ) {
			return;
		}

		CloseHandle( hAutoINF );
	}
}



//
// CreateSettingsFile()
//
// This saves the options (policies, servers, auto-conf location, distro loc)
// to a .INI file
//
void CNmAkWiz::_CreateSettingsFile(void)
{
    CFilePanePropWnd2 * pFilePane = m_FinishSheet.GetFilePane();

    if (pFilePane->OptionEnabled())
    {
        HKEY    hKey;

    	m_SettingsSheet.WriteSettings();
        m_CallModeSheet.WriteSettings();
    	m_ConfirmationSheet.GetFilePane()->WriteSettings();
	    m_DistributionSheet.GetDistroFilePane()->WriteSettings();
    	m_DistributionSheet.GetAutoFilePane()->WriteSettings();

        // Save last config path in registry.
        if (RegOpenKey(HKEY_LOCAL_MACHINE, REGKEY_NMRK, &hKey) == ERROR_SUCCESS)
        {
            TCHAR   szFile[MAX_PATH];

            pFilePane->GetPathAndFile(szFile);

            RegSetValueEx(hKey, REGVAL_LASTCONFIG, 0, REG_SZ, (LPBYTE)szFile,
                lstrlen(szFile)+1);

            RegCloseKey(hKey);
        }
    }
}


//-------------------------------------------------------------------------------------------------
// This is called when the user hits the the FINISH button after entering data with the wizard...
//  We simply get the information from the various dialogs ( property sheets as they are ), and 
//  set the appropriate data in the .INF file
void CNmAkWiz::CallbackForWhenUserHitsFinishButton( void )
{
	if (m_DistributionSheet.TurnedOffAutoConf() )
	{
		_CreateFinalAutoConf();
	}
	else
	{
		_CreateAutoConf();
	}

	_CreateTextSpew();
    _CreateSettingsFile();
	_CreateDistro();
}

////////////////////////////////////////////////////////////////////////////////////////////////////
// Constructors, Destructors, and Initialization Fns
////////////////////////////////////////////////////////////////////////////////////////////////////


//--------------------------------------------------------------------------------------------------
// CNmAkWiz::CNmAkWiz
CNmAkWiz::CNmAkWiz(void)
:   m_WelcomeSheet(),
    m_IntroSheet(),
    m_SettingsSheet(),
    m_CallModeSheet(),
    m_ConfirmationSheet(),
    m_DistributionSheet(),
    m_FinishSheet(),
    m_PropSheetHeader( ID_NumSheets, 
                       PSH_PROPSHEETPAGE | PSH_WIZARD | PSH_NOAPPLYNOW /* | PSH_HASHELP */
                     )
{ 
}


//--------------------------------------------------------------------------------------------------
// CNmAkWiz::~CNmAkWiz
CNmAkWiz::~CNmAkWiz( void ) 
{ 
}



//--------------------------------------------------------------------------------------------------
// CNmAkWiz::_InitInfFile opens the reg file specified by  ms_InfFilePath\ms_InfFileName.
// If the file cannot be created there, the user is prompted for a good location for the file.
BOOL CNmAkWiz::_InitInfFile( void ) {

        // First we have to open the .INF file
    TCHAR szFileName[ MAX_PATH ];
    int Err;        

    const TCHAR* szInstallationPath = GetInstallationPath();
    if( NULL != szInstallationPath ) {
        
        lstrcpy( szFileName, szInstallationPath );
        lstrcat( szFileName, TEXT("\\") );
        lstrcat( szFileName, ms_InfFilePath );
        lstrcat( szFileName, TEXT("\\") );
        lstrcat( szFileName, ms_InfFileName );
    }
    else {
        assert( 0 );          
        lstrcat( szFileName, ms_InfFileName );
    }

    /**/m_hInfFile = CreateFile( szFileName, 
                                        GENERIC_WRITE, 
                                        0,
                                        NULL,
                                        CREATE_ALWAYS, // This is going to overwrite existing files
                                        FILE_ATTRIBUTE_NORMAL,
                                        NULL
                                      );
    

    
    if( INVALID_HANDLE_VALUE == m_hInfFile ) {
        switch( Err = GetLastError() ) {

            case ERROR_ACCESS_DENIED:
                assert( 0 ); return FALSE;

            case ERROR_PATH_NOT_FOUND:
                
                assert( 0 ); return FALSE;


            case ERROR_WRITE_PROTECT:
                
                assert( 0 ); return FALSE;

            default:
                ErrorMessage( "", Err );
                assert( 0 );
                return FALSE;
        }

    }

    DWORD cbWritten;        

    TCHAR szPreamble [] = TEXT("[version]\nsignature=\"$CHICAGO$\"\nAdvancedINF=2.5\n\n[DefaultInstall]\nAddReg\t= AddRegSection\nDelReg\t= DelRegSection\n\n\n[AddRegSection]\n");

    RETFAIL( WriteFile( m_hInfFile, szPreamble, lstrlen( szPreamble ), &cbWritten, NULL ) );
    return TRUE;
}


//--------------------------------------------------------------------------------------------------
// CNmAkWiz::_StoreDialogData 
//  The user specifies a bunch of data in the g_pWiz-> NetMeeting ( conf.exe ) reads customization
//  data stored from the registry. We have to store this customization data in a .INF file for 
//  the setup program to use.  This function will get the data from the wizard and save it to
//  a .INF file according to the key maps which map a Wizard property to a Infistry entry...
BOOL CNmAkWiz::_StoreDialogData( HANDLE hFile ) {

	m_SettingsSheet.WriteToINF( hFile );
    m_CallModeSheet.WriteToINF( hFile );

	m_DistributionSheet.GetAutoFilePane()->WriteToINF( hFile, TRUE );

	return TRUE;
}

//--------------------------------------------------------------------------------------------------
// CNmAkWiz::_CloseInfFile closes the registry file that we are using to store the data entered
//  by the user in the Wizard. 
BOOL CNmAkWiz::_CloseInfFile( void ) {

    TCHAR szDelRegSectionPrefix[] = "\n\n[DelRegSection]\n";

    DWORD cbWritten;

    RETFAIL( WriteFile( m_hInfFile, szDelRegSectionPrefix, lstrlen( szDelRegSectionPrefix ), &cbWritten, NULL ) );

    CPolicyData::FlushCachedInfData( m_hInfFile );

    CloseHandle( m_hInfFile );
    return TRUE;
}

//--------------------------------------------------------------------------------------------------
// CNmAkWiz::_CreateDistributableFile creates a custom NetMeeting distributable incorporating
//  the registry changes that are stored in ms_InfFilePath\ms_InfFileName
//  The szPathName is a path where we are going to create a file called:
//    CNmAkWiz::ms_NetmeetingCustomDistributionFileName;
BOOL CNmAkWiz::_CreateDistributableFile( CFilePanePropWnd2 *pFilePane ) {

        // Get the location of the original distribution
    if( !_GetNetMeetingOriginalDistributionData() ) { return FALSE; }

    TCHAR szNMOriginalDistributableFile[ MAX_PATH ];
    TCHAR szNMCustomDistributableFile[ MAX_PATH ];
    TCHAR szUpdateCommandLine[ MAX_PATH ];

    pFilePane->CreateOutputDir();
	pFilePane->GetPathAndFile( szNMCustomDistributableFile );

    const TCHAR* sz = GetInstallationPath();
    if( NULL != sz ) {
        lstrcpy( szNMOriginalDistributableFile, sz );
        lstrcat( szNMOriginalDistributableFile, TEXT("\\" ) );
        lstrcat( szNMOriginalDistributableFile, ms_NetmeetingSourceDirectory );
        lstrcat( szNMOriginalDistributableFile, TEXT("\\" ) );
        lstrcat( szNMOriginalDistributableFile, ms_NetmeetingOriginalDistributionFileName );
    }

    // Copy source distribution to  custom exe
    SHFILEOPSTRUCT FileOp;
    ZeroMemory( &FileOp, sizeof( FileOp ) );
    FileOp.hwnd     = g_hwndActive;
    FileOp.wFunc    = FO_COPY;
    FileOp.fFlags   = FOF_SIMPLEPROGRESS | FOF_NOCONFIRMATION;

        // Must double-null terminate file names for the struct...
    szNMOriginalDistributableFile[ lstrlen( szNMOriginalDistributableFile ) + 1 ] = '\0';
    szNMCustomDistributableFile[ lstrlen( szNMCustomDistributableFile ) + 1 ] = '\0';

    FileOp.pFrom = szNMOriginalDistributableFile;
    FileOp.pTo = szNMCustomDistributableFile;
    
    TCHAR szProgressTitle[ 256 ];

    LoadString( g_hInstance, 
                IDS_CREATING_CUSTOM_DISTRIBUTION,
                szProgressTitle,
                CCHMAX( szProgressTitle )
              );


    FileOp.lpszProgressTitle = szProgressTitle;
    
    int iRet = SHFileOperation( &FileOp );
    if( 0 != iRet ) { return FALSE; }


    // CreateProcess: updfile nm30.exe MsNetMtg.inf    
    const TCHAR* szInstallationPath = GetInstallationPath();

    wsprintf(szUpdateCommandLine, "\"%s\\%s\\updfile.exe\" \"%s\" \"%s\\%s\"",
        szInstallationPath, ms_ToolsFolder, szNMCustomDistributableFile,
        ms_FileExtractPath, ms_InfFileName);
    OutputDebugString(szUpdateCommandLine);
    OutputDebugString("\n\r");


    PROCESS_INFORMATION ProcInfo;
    STARTUPINFO StartupInfo;

    ZeroMemory( &StartupInfo, sizeof( StartupInfo ) );
    StartupInfo.cb          = sizeof( StartupInfo );
    
    
    BOOL bRet = CreateProcess( NULL,
                               szUpdateCommandLine,
                               NULL,
                               NULL,
                               TRUE,
                               DETACHED_PROCESS,
                               NULL,
                               NULL,
                               &StartupInfo,
                               &ProcInfo
                             );

    if( 0 == bRet ) {
        DWORD dwErr;
        if( ERROR_FILE_NOT_FOUND == ( dwErr = GetLastError() ) ) {
            TCHAR szMsg[ 256 ];

            LoadString( g_hInstance, 
                        IDS_COULD_NOT_FIND_THE_TOOL,
                        szMsg,
                        CCHMAX( szMsg )
                      );

            lstrcat( szMsg, TEXT(" \"") );
            lstrcat( szMsg, szInstallationPath );
            lstrcat( szMsg, TEXT("\\") );
            lstrcat( szMsg, ms_ToolsFolder );
            lstrcat( szMsg, TEXT("\\") );
            lstrcat( szMsg, TEXT("updfile.exe\"") );

            NmrkMessageBox(
                        szMsg,
                        MAKEINTRESOURCE(IDS_NMAKWIZ_ERROR_CAPTION),
                        MB_OK | MB_ICONSTOP
                      );

            NmrkMessageBox(MAKEINTRESOURCE(IDS_REINSTALL_THE_NETMEETING_RESOURCE_KIT_AND_TRY_AGAIN),
                MAKEINTRESOURCE(IDS_NMAKWIZ_ERROR_CAPTION),
                MB_OK | MB_ICONSTOP);
        }

        return FALSE;
    }

    SetLastError( 0 );

    DWORD   dwRet;
    MSG     msg;

    while (TRUE)
    {
        dwRet = MsgWaitForMultipleObjects(1, &ProcInfo.hThread, FALSE, INFINITE, QS_ALLINPUT);

        // Process is done
        if (dwRet == WAIT_OBJECT_0)
            break;

        // Something went wrong
        if (dwRet != WAIT_OBJECT_0 + 1)
        {
            ErrorMessage();
            assert(0);
            return FALSE;
        }
        
        // GUI stuff
        while (PeekMessage(&msg, NULL, NULL, NULL, PM_REMOVE))
        {
            TranslateMessage(&msg);
            DispatchMessage(&msg);

            if (WaitForSingleObject(ProcInfo.hThread, 0) == WAIT_OBJECT_0)
            {
                // Process is done
                break;
            }
        }
    }


    DWORD dwExitCode;        
    bRet = GetExitCodeProcess( ProcInfo.hProcess, &dwExitCode );
    if (dwExitCode != 0)
    {
		NmrkMessageBox(MAKEINTRESOURCE(IDS_NOT_ENOUGH_SPACE_IN_FINAL),
            MAKEINTRESOURCE(IDS_NMAKWIZ_ERROR_CAPTION),
					MB_OK | MB_ICONEXCLAMATION
				  );
        return FALSE;
    }

    TCHAR szMsg[ 256 ];

    lstrcpy( szMsg, szNMCustomDistributableFile );

    int len = lstrlen( szMsg );

    LoadString( g_hInstance, 
                IDS_SUCCESSFULLY_CREATED,
                szMsg + len,
                CCHMAX(szMsg) - len
              );

    NmrkMessageBox(szMsg, NULL, MB_OK);
                

    return TRUE;
}

//--------------------------------------------------------------------------------------------------
// CNmAkWiz::_CreateFileDistribution
//  We are going to create a file called CNmAkWiz::ms_NetmeetingCustomDistributionFileName in the
//  location specified by the user in the m_DistributionSheet dialog
BOOL CNmAkWiz::_CreateFileDistribution( CFilePanePropWnd2 *pFilePane ) {

    if ( !_CreateDistributableFile( pFilePane ))
    { 
        NmrkMessageBox(MAKEINTRESOURCE(IDS_THERE_WAS_AN_UNEXPECTED_ERROR),
            MAKEINTRESOURCE(IDS_NMAKWIZ_ERROR_CAPTION),
            MB_OK | MB_ICONSTOP);

        return FALSE;
    }

    return TRUE;
}

//--------------------------------------------------------------------------------------------------
// CNmAkWiz::_NetMeetingOriginalDistributionIsAtSpecifiedLocationsearches 
//

BOOL CNmAkWiz::_NetMeetingOriginalDistributionIsAtSpecifiedLocation( void ) {

    TCHAR szFileName[ MAX_PATH ];
    const TCHAR* sz = GetInstallationPath();
    if( NULL != sz ) {
        lstrcpy( ms_NetmeetingOriginalDistributionFilePath, sz );
        lstrcat( ms_NetmeetingOriginalDistributionFilePath, TEXT("\\") );
        lstrcat( ms_NetmeetingOriginalDistributionFilePath, ms_NetmeetingSourceDirectory );
        lstrcat( ms_NetmeetingOriginalDistributionFilePath, TEXT("\\") );
    }
    if( MAX_PATH < ( lstrlen( ms_NetmeetingOriginalDistributionFilePath ) + 
                     lstrlen( ms_NetmeetingOriginalDistributionFileName ) + 1 ) 
       ) {
        assert( 0 );
        return FALSE;   // This should not happen becaues the file should have been 
                            // Created in this same program
    }

    lstrcpy( szFileName, ms_NetmeetingOriginalDistributionFilePath );
    lstrcat( szFileName, ms_NetmeetingOriginalDistributionFileName );

    HANDLE hFile = CreateFile( szFileName,
                               GENERIC_READ,
                               FILE_SHARE_READ,
                               NULL,
                               OPEN_EXISTING,
                               FILE_ATTRIBUTE_NORMAL,
                               NULL
                             );
    if( INVALID_HANDLE_VALUE != hFile ) {
        // The NetMeeting Distribution file was at the specified location...
        CloseHandle( hFile );
        return TRUE;
    }

    return FALSE;

}


//--------------------------------------------------------------------------------------------------
// CNmAkWiz::_GetNetMeetingOriginalDistributionData searches for the NetMeeting original 
//  distribution and if it can't find it, it will ask the user to help
//  return TRUE if the user selected one, and FALSE if the user wants to quit

BOOL CNmAkWiz::_GetNetMeetingOriginalDistributionData( void )
{
        // We have to get the file path from the user
    OPENFILENAME OpenFileName;
    while( !_NetMeetingOriginalDistributionIsAtSpecifiedLocation() )
    {
        NmrkMessageBox(MAKEINTRESOURCE(IDS_CANT_FIND_NETMEETING_ORIGINAL_DISTRIBUTION),
            MAKEINTRESOURCE(IDS_NMAKWIZ_ERROR_CAPTION),
                MB_OK | MB_ICONEXCLAMATION);

        ZeroMemory( &OpenFileName, sizeof( OpenFileName ) );
        OpenFileName.lStructSize = sizeof( OpenFileName );
        OpenFileName.hwndOwner = g_hwndActive;
        OpenFileName.lpstrFile = ms_NetmeetingOriginalDistributionFileName;
        OpenFileName.nMaxFile = MAX_PATH;
        OpenFileName.Flags = OFN_PATHMUSTEXIST;

        if( GetOpenFileName( &OpenFileName ) ) {
            lstrcpy( ms_NetmeetingOriginalDistributionFilePath, "" );
        }
        else {
            // This means that the user wants to cancel
            if( IDCANCEL == NmrkMessageBox(
                MAKEINTRESOURCE(IDS_CANT_FIND_NETMEETING_ORIGINAL_DISTRIBUTION_QUERY_ABORT),
                MAKEINTRESOURCE(IDS_NMAKWIZ_ERROR_CAPTION),
                                        MB_OKCANCEL | MB_ICONEXCLAMATION
                                      ) ) {
                exit( 0 );
            }

        }
    }
    return TRUE; 
}

//--------------------------------------------------------------------------------------------------
// CNmAkWiz::_DeleteFiles deletes the Temp files that we have been using...
BOOL CNmAkWiz::_DeleteFiles( void ) {

    TCHAR szProgressTitle[ 256 ];

    LoadString( g_hInstance, 
                IDS_DELETING_TEMPORARY_FILES_PROGRESS_TITLE,
                szProgressTitle,
                CCHMAX( szProgressTitle )
              );


    TCHAR szOutputDirectoryPath[ MAX_PATH ];

    lstrcpy( szOutputDirectoryPath, ms_FileExtractPath );
    lstrcat( szOutputDirectoryPath, TEXT("\\*.*") );
        // Must double NULL terminate this!
    szOutputDirectoryPath[ lstrlen( szOutputDirectoryPath ) + 1 ] = '\0';

    int iRet = rmdir( ms_FileExtractPath );
    if( ( -1 == iRet ) && ( ENOENT != errno ) ) {
        
        SHFILEOPSTRUCT FileOp;
        ZeroMemory( &FileOp, sizeof( FileOp ) );
        FileOp.hwnd     = g_hwndActive;
        FileOp.wFunc    = FO_DELETE;
        FileOp.fFlags   = FOF_SIMPLEPROGRESS | FOF_NOCONFIRMATION;
        FileOp.pFrom    = szOutputDirectoryPath;
        FileOp.lpszProgressTitle = szProgressTitle;
    
        iRet = SHFileOperation( &FileOp );
        iRet = rmdir( ms_FileExtractPath );
    }
   

    return TRUE;

}

BOOL CNmAkWiz::_SetPathNames( void ) {

    GetTempPath( MAX_PATH, ms_FileExtractPath );
    lstrcat( ms_FileExtractPath, ms_NMRK_TMP_FolderName );
    OutputDebugString( "ms_FileExtractPath = " );
    OutputDebugString( ms_FileExtractPath );
    OutputDebugString( "\r\n" );
    return TRUE;
}


const TCHAR* GetInstallationPath( void ) {

    static TCHAR szPath[ MAX_PATH ];
    
    HKEY hKey;
    long lRet = RegOpenKey( HKEY_LOCAL_MACHINE, REGKEY_NMRK, &hKey );
    if( ERROR_SUCCESS != lRet ) { return NULL; }
    
    DWORD cb = MAX_PATH;
    DWORD dwType = REG_SZ;
    if( ERROR_SUCCESS != RegQueryValueEx( hKey, 
                                          REGVAL_INSTALLATIONDIRECTORY, 
                                          NULL,
                                          &dwType,
                                          reinterpret_cast< LPBYTE >( szPath ), 
                                          &cb ) ) {
        ErrorMessage();
        if( ERROR_SUCCESS != RegCloseKey( hKey ) ) {
            ErrorMessage();
        }
        return NULL;
    }

    if( ERROR_SUCCESS != RegCloseKey( hKey ) ) {
        ErrorMessage();
    }
    return szPath;

}



BOOL CNmAkWiz::_CreateNewInfFile( void ) {

    // Load MsNetMtg.inf into memory
    TCHAR szInfFilePath[ MAX_PATH ];
    TCHAR szBuf[ MAX_PATH ];
    TCHAR* pOriginalInfFileData;
    TCHAR* pOriginalInfFileDataCursor;
    TCHAR* pCursor;
    DWORD dwSize;
    DWORD cbWritten;

    lstrcpy( szInfFilePath, ms_FileExtractPath );
    lstrcat( szInfFilePath, TEXT("\\") );
    lstrcat( szInfFilePath, ms_InfFileName );

    m_hInfFile = CreateFile( szInfFilePath,
                             GENERIC_READ,
                             FILE_SHARE_READ,
                             NULL,
                             OPEN_EXISTING,
                             FILE_ATTRIBUTE_NORMAL,
                             NULL
                           );

    if( INVALID_HANDLE_VALUE == m_hInfFile ) { goto ExitError; }

    DWORD dwFileSizeHigh;
    dwSize = GetFileSize( m_hInfFile, &dwFileSizeHigh );

    pOriginalInfFileData = new TCHAR[ dwSize ];
    pOriginalInfFileDataCursor = pOriginalInfFileData;

    DWORD cbRead;
    if( 0 == ReadFile( m_hInfFile, pOriginalInfFileData, dwSize, &cbRead, NULL ) ) {
        goto ExitError;
    }
    if( cbRead != dwSize ) { goto ExitError; }

    // Close MsNetMtg.inf file
    CloseHandle( m_hInfFile );

    
        // Open MsNetMtg.inf for writing ( overwrite existing )
    m_hInfFile = CreateFile( szInfFilePath,
                             GENERIC_WRITE,
                             0,
                             NULL,
                             CREATE_ALWAYS,
                             FILE_ATTRIBUTE_NORMAL,
                             NULL
                           );

    if( INVALID_HANDLE_VALUE == m_hInfFile ) { goto ExitError; }

        // Set cursor to [DefaultInstall] string
    pCursor = strstr( pOriginalInfFileDataCursor, TEXT("[DefaultInstall]") );
    if( NULL == pCursor ) { goto ExitError; }

        // Set cursor to next "AddReg"
    pCursor = strstr( pCursor, TEXT("AddReg") );
    if( NULL == pCursor ) { goto ExitError; }

        // Set cursor to the end of the line
    pCursor = strstr( pCursor, TEXT("\r") );
    if( NULL == pCursor ) { goto ExitError; }

        // Write Original Data up to the cursor to INF
    if( 0 == WriteFile( m_hInfFile, pOriginalInfFileDataCursor, pCursor - pOriginalInfFileDataCursor, &cbWritten, NULL ) ) {
        goto ExitError;
    }
    pOriginalInfFileDataCursor = pCursor;

    if( 0 == WriteFile( m_hInfFile, pOriginalInfFileDataCursor, pCursor - pOriginalInfFileDataCursor, &cbWritten, NULL ) ) {
        goto ExitError;
    }

        // Write ",NetMtg.Install.Reg.NMRK" to INF
    lstrcpy( szBuf, ",NetMtg.Install.Reg.NMRK" );
    if( 0 == WriteFile( m_hInfFile, szBuf, lstrlen( szBuf ), &cbWritten, NULL ) ) {
        goto ExitError;
    }

        // Set cursor to next "DelReg"
    pCursor = strstr( pCursor, "DelReg" );
    if( NULL == pCursor ) { goto ExitError; }

        // Set cursor to the end of the line
    pCursor = strstr( pCursor, "\r" );
    if( NULL == pCursor ) { goto ExitError; }

        // Write Original Data up to the cursor to INF
    if( 0 == WriteFile( m_hInfFile, pOriginalInfFileDataCursor, pCursor - pOriginalInfFileDataCursor, &cbWritten, NULL ) ) {
        goto ExitError;
    }
    pOriginalInfFileDataCursor = pCursor;

        // Write ",NetMtg.Install.DeleteReg.NMRK" to INF
    lstrcpy( szBuf, ",NetMtg.Install.DeleteReg.NMRK" );
    if( 0 == WriteFile( m_hInfFile, szBuf, lstrlen( szBuf ), &cbWritten, NULL ) ) {
        goto ExitError;
    }


        // Set cursor to [DefaultInstall.NT] string
    pCursor = strstr( pOriginalInfFileDataCursor, "[DefaultInstall.NT]" );
    if( NULL == pCursor ) { goto ExitError; }

        // Set cursor to next "AddReg"
    pCursor = strstr( pCursor, "AddReg" );
    if( NULL == pCursor ) { goto ExitError; }

        // Set cursor to the end of the line
    pCursor = strstr( pCursor, "\r" );
    if( NULL == pCursor ) { goto ExitError; }

        // Write Original Data up to the cursor to INF
    if( 0 == WriteFile( m_hInfFile, pOriginalInfFileDataCursor, pCursor - pOriginalInfFileDataCursor, &cbWritten, NULL ) ) {
        goto ExitError;
    }
    pOriginalInfFileDataCursor = pCursor;

    if( 0 == WriteFile( m_hInfFile, pOriginalInfFileDataCursor, pCursor - pOriginalInfFileDataCursor, &cbWritten, NULL ) ) {
        goto ExitError;
    }

        // Write ",NetMtg.Install.Reg.NMRK" to INF
    lstrcpy( szBuf, ",NetMtg.Install.Reg.NMRK" );
    if( 0 == WriteFile( m_hInfFile, szBuf, lstrlen( szBuf ), &cbWritten, NULL ) ) {
        goto ExitError;
    }

        // Set cursor to next "DelReg"
    pCursor = strstr( pCursor, "DelReg" );
    if( NULL == pCursor ) { goto ExitError; }

        // Set cursor to the end of the line
    pCursor = strstr( pCursor, "\r" );
    if( NULL == pCursor ) { goto ExitError; }

        // Write Original Data up to the cursor to INF
    if( 0 == WriteFile( m_hInfFile, pOriginalInfFileDataCursor, pCursor - pOriginalInfFileDataCursor, &cbWritten, NULL ) ) {
        goto ExitError;
    }
    pOriginalInfFileDataCursor = pCursor;

        // Write ",NetMtg.Install.DeleteReg.NMRK" to INF
    lstrcpy( szBuf, ",NetMtg.Install.DeleteReg.NMRK" );
    if( 0 == WriteFile( m_hInfFile, szBuf, lstrlen( szBuf ), &cbWritten, NULL ) ) {
        goto ExitError;
    }

    //
    // Now we have to yank the old Ils stuff...
    //


    // Set cursor to [NetMtg.Install.Reg.PerUser] string
    pCursor = strstr( pCursor, "[NetMtg.Install.Reg.PerUser]" );
    if( NULL == pCursor ) { goto ExitError; }

    // Skip to the start of the next line
    pCursor = strstr( pCursor, "\n" ); // This is the last TCHARacter on the line
    pCursor++; // This will be the first TCHARacter on the line

    // Write Original Data up to the cursor to INF
    if( 0 == WriteFile( m_hInfFile, pOriginalInfFileDataCursor, pCursor - pOriginalInfFileDataCursor, &cbWritten, NULL ) ) {
        goto ExitError;
    }
    pOriginalInfFileDataCursor = pCursor;
    
    // skip white space
    while( isspace( *pCursor ) ) { pCursor++; }

    // While the cursor is not '['
    while( *pCursor != '[' ) {
        // if current line starts with 
        if( ( pCursor == strstr( pCursor, "HKCU,\"%KEY_CONFERENCING%\\UI\\Directory\",\"Name" ) ) ||
            ( pCursor == strstr( pCursor, "HKCU,\"%KEY_CONFERENCING%\\UI\\Directory\",\"Count" ) ) ) {
            // Delete the line by incrementing the base cursor to the beginning of the next line
            pCursor = strstr( pCursor, "\n" );
            pCursor++;
        }
        else {
            break;
        }
    }

    // Set pOriginalInfFileDataCursor to cursor ( thus skipping the old Ils stuff )
    pOriginalInfFileDataCursor = pCursor;

        // Set Cursor to [Strings] string
    pCursor = strstr( pCursor, "[Strings]" );
    if( NULL == pCursor ) { goto ExitError; }

    // Write original data to the cursor
    if( 0 == WriteFile( m_hInfFile, pOriginalInfFileDataCursor, pCursor - pOriginalInfFileDataCursor, &cbWritten, NULL ) ) {
        goto ExitError;
    }
    pOriginalInfFileDataCursor = pCursor;

    // Write string [NetMtg.Install.Reg.NMRK]\n
    lstrcpy( szBuf, "\r\n\r\n[NetMtg.Install.Reg.NMRK]\r\n\r\n" );
    if( 0 == WriteFile( m_hInfFile, szBuf, lstrlen( szBuf ), &cbWritten, NULL ) ) {
        goto ExitError;
    }

    // Write the REG Keys
    _StoreDialogData( m_hInfFile );

    // Write string [NetMtg.Install.DeleteReg.NMRK]\n
    lstrcpy( szBuf, "\r\n\r\n[NetMtg.Install.DeleteReg.NMRK]\r\n\r\n" );
    if( 0 == WriteFile( m_hInfFile, szBuf, lstrlen( szBuf ), &cbWritten, NULL ) ) {
        goto ExitError;
    }

    // Write the REG Delete Keys
    CPolicyData::FlushCachedInfData( m_hInfFile );

    // this is needed...
    lstrcpy( szBuf, "\r\n\r\n" );
    if( 0 == WriteFile( m_hInfFile, szBuf, lstrlen( szBuf ), &cbWritten, NULL ) ) {
        goto ExitError;
    }



    // Write the rest of the Original File to the INF
    pCursor = pOriginalInfFileData + dwSize;
    if( 0 == WriteFile( m_hInfFile, pOriginalInfFileDataCursor, pCursor - pOriginalInfFileDataCursor, &cbWritten, NULL ) ) {
        goto ExitError;
    }

    CloseHandle( m_hInfFile );
    m_hInfFile = INVALID_HANDLE_VALUE;
    delete [] pOriginalInfFileData;

    return TRUE;

    ExitError:
        assert( 0 );
        if( INVALID_HANDLE_VALUE != INVALID_HANDLE_VALUE ) {         
            CloseHandle( m_hInfFile );
        }

        delete [] pOriginalInfFileData;

        return FALSE;
}



BOOL CNmAkWiz::_ExtractOldNmCabFile( void ) {

    TCHAR szCabPath[ MAX_PATH ];
    TCHAR szOutputDirectoryPath[ MAX_PATH ];
    TCHAR szCommandLine[ MAX_PATH ];

        // Clean up in case we abnormally terminated before...
    _DeleteFiles();

        // Create the temp folder
    mkdir( ms_FileExtractPath );


    const TCHAR* szInstallationPath = GetInstallationPath();

    if( NULL != szInstallationPath ) {
        lstrcpy( szCabPath, "\"" );
        lstrcat( szCabPath, szInstallationPath );
        lstrcat( szCabPath, "\\" );
        lstrcat( szCabPath, ms_NetmeetingSourceDirectory );
        lstrcat( szCabPath, "\\" );
        lstrcat( szCabPath, ms_NetmeetingOriginalDistributionFileName );
        lstrcat( szCabPath, "\" " );
    }
    else {
        assert( 0 );          
        lstrcat( szCabPath, ms_InfFileName );
    }

    

    lstrcpy( szOutputDirectoryPath, ms_FileExtractPath );

    lstrcpy( szCommandLine, "/C /T:\"" );
    lstrcat( szCommandLine, szOutputDirectoryPath );
    lstrcat( szCommandLine, "\" /Q" );

    PROCESS_INFORMATION ProcInfo;
    STARTUPINFO StartupInfo;
    ZeroMemory( &StartupInfo, sizeof( StartupInfo ) );
    StartupInfo.cb = sizeof( StartupInfo );

    lstrcat( szCabPath, szCommandLine );
    OutputDebugString( szCabPath );
    OutputDebugString( "\n" );
    BOOL iRet = CreateProcess( NULL,
                               szCabPath,
                               NULL,
                               NULL,
                               FALSE,
                               0,
                               NULL,
                               NULL,
                               &StartupInfo,
                               &ProcInfo
                             );
    
    if( FALSE == iRet ) {
        ErrorMessage();
        assert( 0 );                
        return FALSE;
    }

    SetLastError( 0 );

    DWORD   dwRet;
    MSG     msg;

    while (TRUE)
    {
        dwRet = MsgWaitForMultipleObjects(1, &ProcInfo.hThread, FALSE, INFINITE, QS_ALLINPUT);

        // Process is done
        if (dwRet == WAIT_OBJECT_0)
            break;

        // Something went wrong
        if (dwRet != WAIT_OBJECT_0 + 1)
        {
            ErrorMessage();
            assert(0);
            return FALSE;
        }
        
        // GUI stuff
        while (PeekMessage(&msg, NULL, NULL, NULL, PM_REMOVE))
        {
            TranslateMessage(&msg);
            DispatchMessage(&msg);

            if (WaitForSingleObject(ProcInfo.hThread, 0) == WAIT_OBJECT_0)
            {
                // Process is done
                break;
            }
        }
    }

    DWORD dwExitCode;        
    BOOL bRet = GetExitCodeProcess( ProcInfo.hProcess, &dwExitCode );

    // dwExitCode 0 is success
    
    if (dwExitCode != 0)
    {
		NmrkMessageBox(MAKEINTRESOURCE(IDS_NOT_ENOUGH_SPACE_IN_TEMP_DIR),
            MAKEINTRESOURCE(IDS_NMAKWIZ_ERROR_CAPTION),
					MB_OK | MB_ICONEXCLAMATION
				  );
        return FALSE;
    }

    return TRUE;
}




//
// NmrkMessageBox()
//
// Puts up a message box owned by the wizard
//
int NmrkMessageBox
(
    LPCSTR  lpszText,
    LPCSTR  lpszCaption,
    UINT    uType,
	HWND	hwndParent
)
{
    MSGBOXPARAMS    mbp;

    ZeroMemory(&mbp, sizeof(mbp));
    mbp.cbSize      = sizeof(mbp);

    mbp.hwndOwner   = NULL == hwndParent ? g_hwndActive : hwndParent;
    mbp.hInstance   = g_hInstance;
    mbp.lpszText    = lpszText;
    if (!lpszCaption)
        mbp.lpszCaption = MAKEINTRESOURCE(IDS_MSG_CAPTION);
    else
        mbp.lpszCaption = lpszCaption;
    mbp.dwStyle     = uType | MB_SETFOREGROUND;

    return(MessageBoxIndirect(&mbp));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\nmrk\poldata.cpp ===
#include "precomp.h"
#include "global.h"
#include "PolData.h"

/* static */ void CPolicyData::FlushCachedInfData( HANDLE hFile ) {
    std::list< std::string >::iterator I = ms_CachedInfData . begin();
    DWORD cbWritten;
    while( I != ms_CachedInfData . end() ) {
        if( !WriteFile( hFile, ( *I ) . c_str(), lstrlen( ( *I ) . c_str() ), &cbWritten, NULL ) ) {
            assert( 0 );
            ErrorMessage();
            return;
        }
        I++;
    }

    ms_CachedInfData . erase( ms_CachedInfData . begin(), ms_CachedInfData . end() );

}
/* static */ std::list< std::string > CPolicyData::ms_CachedInfData;


CPolicyData::CPolicyData( eKeyType KeyType, const char* szKeyName, const char* szValueName, DWORD dwVal ) {
    
    m_KeyType = KeyType;
    m_ValueType = ValueType_DWORD;
    m_dwVal     = dwVal;
    
    m_szKeyName = MakeCopyOfString( szKeyName );
    m_szValueName = MakeCopyOfString( szValueName );

}


CPolicyData::CPolicyData( eKeyType KeyType, const char* szKeyName, const char* szValueName, const char* szVal ) {

    m_KeyType = KeyType;
    m_ValueType = ValueType_String;
    m_szVal     = MakeCopyOfString( szVal );
    
    m_szKeyName = MakeCopyOfString( szKeyName );
    m_szValueName = MakeCopyOfString( szValueName );

}

CPolicyData::CPolicyData( eValueType ValType, eKeyType KeyType, const char* szKeyName, const char* szValueName, const char* szVal ) {

    m_KeyType   = KeyType;
    m_ValueType = ValType;
    m_szVal     = MakeCopyOfString( szVal );
    
    m_szKeyName = MakeCopyOfString( szKeyName );
    m_szValueName = MakeCopyOfString( szValueName );

}


CPolicyData::CPolicyData( eKeyType KeyType, const char* szKeyName, const char* szValueName, const OpDelete& r ) {

    m_KeyType = KeyType;
    m_ValueType = ValueType_Delete;
    
    m_szKeyName = MakeCopyOfString( szKeyName );
    m_szValueName = MakeCopyOfString( szValueName );

}

CPolicyData::CPolicyData( const CPolicyData& r ) 
: m_ValueType ( ValueType_NotInitialized )
{ *this = r; }

CPolicyData::~CPolicyData( void ) {
    _KillHeapData();
}


CPolicyData& CPolicyData::operator=( const CPolicyData& r )
{
    _KillHeapData();
    
    m_KeyType = r . m_KeyType;

    switch( m_ValueType = r . m_ValueType )
    {
        case ValueType_BinaryAsString:
        case ValueType_String:
            m_szVal = MakeCopyOfString( r . m_szVal );
            break;

        case ValueType_DWORD:
            m_dwVal = r.m_dwVal;
            break;

    }

    m_szKeyName = MakeCopyOfString( r . m_szKeyName );        
    m_szValueName = MakeCopyOfString( r . m_szValueName );        

    return *this;
}

#define KEYSIZE 1000

BOOL CPolicyData::SaveToINFFile( HANDLE hFile ) {

    DWORD cbWritten;
    static char szLastKey[ KEYSIZE ] = "";    
    

    // We have to save the key name first
    char szKey[ KEYSIZE ];
    switch( m_KeyType ) {
        case eKeyType_HKEY_CURRENT_USER:
            strcpy( szKey, "HKCU," );
            break;

        case eKeyType_HKEY_LOCAL_MACHINE:
            strcpy( szKey, "HKLM," );
            break;

        default:
            assert( 0 );
            break;

    }
    strcat( szKey, "\"" );
    strcat( szKey, m_szKeyName );
    strcat( szKey, "\",\""  );
    strcat( szKey, m_szValueName );
    strcat( szKey, "\""  );
    
    switch( m_ValueType ) {

        case ValueType_String:
            // 0 is FLG_ADDREG_TYPE_SZ
            strcat( szKey, ",0,\"" );
            if( NULL == m_szVal ) {
                strcat( szKey, "" );
            }
            else {
                strcat( szKey, m_szVal );
            }
            strcat( szKey, "\"" );
            break;

        case ValueType_DWORD:
            // 1 is FLG_ADDREG_TYPE_BINARY
            // NOTE that DWORDs are 4 byte BINARY values.  This works on
            // all platforms.  The later FLG_ADDREG_TYPE_DWORD isn't
            // supported on Win95.
            strcat( szKey, ",1," );
            sprintf( szKey + lstrlen( szKey ), "%x, %x, %x, %x", 
                            LOBYTE( LOWORD( m_dwVal ) ), 
                            HIBYTE( LOWORD( m_dwVal ) ),
                            LOBYTE( HIWORD( m_dwVal ) ), 
                            HIBYTE( HIWORD( m_dwVal ) ));
            break;

        case ValueType_BinaryAsString:
            // 1 is FLG_ADDREG_TYPE_BINARY
            strcat( szKey, ",1," );
            strcat( szKey, m_szVal );
            break;

        case ValueType_Delete:
            strcat( szKey, "\r\n" );
            ms_CachedInfData . push_back( szKey );
            return TRUE;

        default:
            assert( 0 );
            break;

    }
        
    strcat( szKey, "\r\n" );

    RETFAIL( WriteFile( hFile, szKey, lstrlen( szKey ), &cbWritten, NULL ) );

    return TRUE;


}


// This will break if the following occurs:
   // Same key name as the last call in this process
   // but a new file....
BOOL CPolicyData::SaveToREGFile( HANDLE hFile ) {

    DWORD cbWritten;
    static char szLastKey[ KEYSIZE ] = "";    
    

    // We have to save the key name first
    char szKey[ KEYSIZE ];
    strcpy( szKey, "[" );
    switch( m_KeyType ) {
        case eKeyType_HKEY_CURRENT_USER:
            strcat( szKey, "HKEY_CURRENT_USER\\" );
            break;

        case eKeyType_HKEY_LOCAL_MACHINE:
            strcat( szKey, "HKEY_LOCAL_MACHINE\\" );
            break;

        default:
            assert( 0 );
            break;

    }

    strcat( szKey, m_szKeyName );
    strcat( szKey, "]\n" );

    if( strcmp( szLastKey, szKey ) ) {
        // We hawe to save the key first if it is different
        // From the last one 
        RETFAIL( WriteFile( hFile, szKey, lstrlen( szKey ), &cbWritten, NULL ) );
        strcpy( szLastKey, szKey );    
    }

    
    char szVal[ KEYSIZE ];
    strcpy( szVal, "\"" );
    strcat( szVal, m_szValueName );
    strcat( szVal, "\"=" );
    
    switch( m_ValueType ) {
        case ValueType_String:
            if( NULL == m_szVal ) {
                strcat( szVal, "\"\"\n" );
            }
            else {
                strcat( szVal, "\"" );
                strcat( szVal, m_szVal );
                strcat( szVal, "\"\n" );

            }
            break;

        case ValueType_DWORD:
            strcat( szVal, "dword:" );
            sprintf( szVal + lstrlen( szVal ), "%x", m_dwVal );
            strcat( szVal, "\n" );
            break;

        case ValueType_BinaryAsString:
            strcat( szVal, "hex:" );
            strcat( szVal, m_szVal );
            strcat( szVal, "\n" );
            break;

        case ValueType_Delete:
            strcat( szVal, "-\n" );
            break;

        default:
            assert( 0 );
            break;

    }
        
    RETFAIL( WriteFile( hFile, szVal, lstrlen( szVal ), &cbWritten, NULL ) );  

    return TRUE;
}

void CPolicyData::_KillHeapData( void ) {
    
    if( ( ValueType_String == m_ValueType ) || ( ValueType_BinaryAsString == m_ValueType ) ) {
        delete [] m_szVal;
        m_szVal = NULL;
        m_ValueType = ValueType_NotInitialized;
    }

    delete [] m_szKeyName;
    m_szKeyName = NULL;
    delete m_szValueName;
    m_szValueName = NULL;
        


}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\nmrk\poldata.h ===
#ifndef __PolData_h__
#define __PolData_h__

////////////////////////////////////////////////////////////////////////////////////////////////////
#pragma warning( disable : 4786 )
#include <string>
#include <list>
////////////////////////////////////////////////////////////////////////////////////////////////////


class CPolicyData {

public: // Static Fns
    static void FlushCachedInfData( HANDLE hFile );

private:// Static Fns
    static std::list< std::string > ms_CachedInfData;

public: // Datatypes
    enum eValueType {
                      ValueType_BinaryAsString,
                      ValueType_String,
                      ValueType_DWORD,  
                      ValueType_Delete,  // This will delete the value name entry in the registry
                      ValueType_NotInitialized
                    };

public:
    enum eKeyType { eKeyType_HKEY_CURRENT_USER,
                    eKeyType_HKEY_LOCAL_MACHINE,
                    eKeyType_INVALID
                  };
                

    class OpDelete { ; }; // Symbol class to signify deleting a registry value entry
    
private: // Data
    eKeyType    m_KeyType;
    char        *m_szKeyName;
    char        *m_szValueName;

    eValueType  m_ValueType;

    union {
        char*   m_szVal;
        DWORD   m_dwVal;
    };
        
public: // Construction / destruction
    CPolicyData( eKeyType KeyType, const char* szKeyName, const char* szValueName, DWORD dwVal );
    CPolicyData( eKeyType KeyType, const char* szKeyName, const char* szValueName, const char* szVal );
    CPolicyData( eValueType ValType, eKeyType KeyType, const char* szKeyName, const char* szValueName, const char* szVal );
    CPolicyData( eKeyType KeyType, const char* szKeyName, const char* szValueName, const OpDelete& r );
    CPolicyData( const CPolicyData& r );
    ~CPolicyData( void );

public: // Member Fns

    CPolicyData& operator=( const CPolicyData& r );

    BOOL SaveToREGFile( HANDLE hFile );
    BOOL SaveToINFFile( HANDLE hFile );

private: // Helper Fns
    void _KillHeapData( void );

private: // Unused, declared to make sure compiler does not make a default and mess us up...
    CPolicyData( void );


};


#endif // __PolData_h__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\nmrk\propwnd2.cpp ===
#include "precomp.h"
#include "resource.h"
#include "PropWnd2.h"
#include "WndProcs.h"
#include "nmakwiz.h"
#include "nmakreg.h"
#include <algorithm>

const int CPropertyDataWindow2::mcs_iTop = 0;
const int CPropertyDataWindow2::mcs_iLeft = 150;
const int CPropertyDataWindow2::mcs_iBorder = 15;

/* static */ map< UINT, CPolicyData::eKeyType > CPropertyDataWindow2::ms_ClassMap;
/* static */ map< UINT, TCHAR* > CPropertyDataWindow2::ms_KeyMap;
/* static */ map< UINT, TCHAR* > CPropertyDataWindow2::ms_ValueMap;


LRESULT CALLBACK DefaultProc( HWND hwnd, UINT iMsg, WPARAM wParam, LPARAM lParam )
{
    switch( iMsg )
    {
        case WM_VSCROLL: 
        {
            OnMsg_VScroll( hwnd, wParam );
            return 0;
            break;
        } 
        case WM_COMMAND:
        {
            return 0;
        }
    }
    return( DefWindowProc( hwnd, iMsg, wParam, lParam ) );
}

CPropertyDataWindow2::CPropertyDataWindow2( HWND hwndParent, UINT uIDD, LPTSTR szClassName, UINT PopUpHelpMenuTextId, int iX, int iY, int iWidth, int iHeight, BOOL bScroll ) :
        m_hwnd( NULL ),
        m_IDD( uIDD ),
        m_wndProc( (WNDPROC) DefaultProc),
        m_bInit( FALSE ),
        m_hwndParent( hwndParent )
{ 
    m_szClassName = new TCHAR[ lstrlen( szClassName ) + 1 ];
    lstrcpy( m_szClassName, szClassName );
    _InitWindow();
    _SizeWindow( iX, iY, iWidth, iHeight );
    if( bScroll )
    {
        _PrepScrollBars();
    }
    ShowWindow( FALSE );
}

CPropertyDataWindow2::CPropertyDataWindow2( HWND hwndParent, UINT uIDD, LPTSTR szClassName, WNDPROC wndProc, UINT PopUpHelpMenuTextId, int iX, int iY, int iWidth, int iHeight, BOOL bScroll ) :
        m_IDD( uIDD ),
        m_hwnd( NULL ),
        m_wndProc( wndProc ),
        m_bInit( FALSE ),
        m_hwndParent( hwndParent )
{ 
    m_szClassName = new TCHAR[ lstrlen( szClassName ) + 1 ];
    lstrcpy( m_szClassName, szClassName );
    _InitWindow();
    _SizeWindow( iX, iY, iWidth, iHeight );
    if( bScroll )
    {
        _PrepScrollBars();
    }
    ShowWindow( FALSE );
}

CPropertyDataWindow2::~CPropertyDataWindow2( void ) 
{
    delete [] m_szClassName;
    list< CControlID * >::iterator it;
    for( it = m_condList.begin(); it != m_condList.end(); it++ )
    {
        delete *it;
    }
    for( it = m_specialControlList.begin(); it != m_specialControlList.end(); it++ )
    {
        delete *it;
    }

}

void CPropertyDataWindow2::Reset()
{
    list< HWND >::iterator i;

    for( i = m_enableList.begin(); i != m_enableList.end(); i++ )
    {
        switch (GetWindowLong(*i, GWL_STYLE) & 0x0F)
        {
            case BS_AUTORADIOBUTTON:
            case BS_RADIOBUTTON:
                // Do nothing -- we always want default item checked
                break;

            default:
                Button_SetCheck(*i, FALSE);
                break;
        }
    }

    list< CControlID * >::iterator it;
    for( it = m_condList.begin(); it != m_condList.end(); it++ )
    {
        (*it)->Reset( m_hwnd );
    }
    for( it = m_specialControlList.begin(); it != m_specialControlList.end(); it++ )
    {
        (*it)->Reset( m_hwnd );
    }
}

void CPropertyDataWindow2::SetEnableListID( UINT uCount, ... )
{
    UINT uID;
    HWND hwnd;
    
    va_list ap;
    va_start( ap, uCount );

    while( uCount )
    {
        uID = va_arg( ap, UINT );
        uCount--;
        if( NULL == ( hwnd = GetDlgItem( m_hwnd, uID ) ) )
        {
            OutputDebugString( TEXT("Enabling Invalid ID\n") );
        }
        else
        {
            m_checkIDList.push_front( uID );
            m_enableList.push_front( hwnd );
        }
    }
    
    va_end( ap );
}

BOOL CPropertyDataWindow2::SetFocus( UINT id ) 
{     
    return ::SetFocus( GetDlgItem( m_hwnd, id ) ) ? TRUE : FALSE;
}

void CPropertyDataWindow2::SetEditData( UINT id, TCHAR* sz ) 
{
    Edit_SetText( GetDlgItem( m_hwnd, id ), sz );
}

void CPropertyDataWindow2::GetEditData( UINT id, LPTSTR sz, ULONG cb ) const 
{
    Edit_GetText( GetDlgItem( m_hwnd, id ), sz, cb );
}

ULONG CPropertyDataWindow2::GetEditDataLen( UINT id ) const
{
    return Edit_GetTextLength( GetDlgItem( m_hwnd, id ) );
}

BOOL CPropertyDataWindow2::GetCheck( UINT id ) const
{
    return(Button_GetCheck( GetDlgItem( m_hwnd, id ) ) ? TRUE : FALSE);
}

void CPropertyDataWindow2::SetCheck( UINT id, BOOL bCheck )
{
    Button_SetCheck( GetDlgItem( m_hwnd, id ), bCheck );
}

void CPropertyDataWindow2::ShowWindow( BOOL bShowWindow /* = TRUE */ )
{
    ::ShowWindow( m_hwnd, bShowWindow ? SW_SHOW : SW_HIDE );
}

void CPropertyDataWindow2::EnableWindow( BOOL bEnable /* = TRUE */ )
{
    list< HWND >::const_iterator it;
    
    for (it = m_enableList.begin(); it != m_enableList.end(); ++it)
    {
        ::EnableWindow( (HWND)(*it), bEnable );
    }

    if( m_specialControlList.size() )
    {
        list< CControlID * >::const_iterator iter;
        for( iter = m_specialControlList.begin();
            iter != m_specialControlList.end();
            iter++ )
        {
                switch( (*iter)->GetType() )
                {
                    case CControlID::CHECK:
                    case CControlID::SLIDER:
                    case CControlID::EDIT:
                    case CControlID::EDIT_NUM:
                    case CControlID::STATIC:
                    case CControlID::COMBO:
                    {
                        HWND hwnd = GetDlgItem( m_hwnd, (*iter)->GetID() );
                        ::EnableWindow( hwnd, bEnable );
                        break;
                    }
                    default:
                        OutputDebugString( TEXT("CPropertyDataWindow2::EnableWindow: unknown CControlID::type\n") );
                        assert( 0 );
                        break;
                }
        }
    }

    if( m_condList.size() )
    {
        list< CControlID * >::const_iterator iter;
        for( iter = m_condList.begin();
            iter != m_condList.end();
            iter++ )
        {
            ::EnableWindow( (*iter)->GetCondHwnd(), bEnable );
        }
    }
}

BOOL CPropertyDataWindow2::_InitWindow( void ) 
{

    if( FALSE == m_bInit )
    {
        WNDCLASSEX wc;
    
        ZeroMemory( &wc, sizeof( WNDCLASSEX ) );
        wc . cbSize = sizeof( WNDCLASSEX );
        wc . style = 0;
        wc . cbWndExtra = DLGWINDOWEXTRA;     
        wc . hInstance = g_hInstance;
        wc . lpfnWndProc = m_wndProc;
        wc . lpszClassName = m_szClassName;
        
        if( 0 == RegisterClassEx( &wc ) ) 
        { 
            return FALSE; 
        }
    
        if( NULL == (m_hwnd = CreateDialogParam( g_hInstance, MAKEINTRESOURCE( m_IDD ), m_hwndParent, NULL/*(DLGPROC)m_wndProc*/, 0 ) ) )
        {
            ErrorMessage( TEXT("CPropertyDataWindow2::_InitWindow"), GetLastError() );
        }
    
        m_bInit = TRUE;
    }
    return TRUE;
}

BOOL CPropertyDataWindow2::_SizeWindow( int X, int Y, int Width, int Height )
{
    GetClientRect( m_hwnd, &m_rect );
    return SetWindowPos(  m_hwnd,    // handle to window
                        HWND_TOP,  // placement-order handle
                        X,   // horizontal position
                        Y,   // vertical position
                        Width,    // width
                        Height,   // height
                        0          // window-positioning flags
                        );
}

void CPropertyDataWindow2::_PrepScrollBars()
{
    RECT clientRect;
    GetClientRect( m_hwnd, &clientRect );

    int iTotalHeight = (m_rect.bottom - m_rect.top);
    int iVisible = clientRect.bottom - clientRect.top;

    if( iTotalHeight <= iVisible )
    {
        return;
    }

    SCROLLINFO ScrollInfo;
    ScrollInfo . cbSize = sizeof( SCROLLINFO );
    ScrollInfo . fMask = SIF_ALL;
    ScrollInfo . nMin = 0;
    ScrollInfo . nMax = iTotalHeight;
    // Make the scroll bar scroll 4/5th of a screen per page
    ScrollInfo . nPage = MulDiv( iVisible, 4, 5 );
    ScrollInfo . nPos = 0;
    SetScrollInfo( m_hwnd, SB_VERT, &ScrollInfo, 0 );
}

void CPropertyDataWindow2::AddControl( CControlID *pControlID )
{
    m_specialControlList.push_front( pControlID );
}

void CPropertyDataWindow2::ConnectControlsToCheck( UINT idCheck, UINT uCount, ... )
{
    HWND hwndCheck = GetDlgItem( m_hwnd, idCheck );
    PSUBDATA pSubData = new SUBDATA;
    pSubData -> proc = SubclassWindow( hwndCheck, wndProcForCheckTiedToEdit );

    va_list ap;
    va_start( ap, uCount );

    while( uCount )
    {
        uCount--;
        CControlID *pControlID = va_arg( ap, CControlID * );
        m_condList.push_front( pControlID );

        switch( pControlID->GetType() )
        {
            case CControlID::STATIC:
            case CControlID::CHECK:
            case CControlID::SLIDER:
            case CControlID::EDIT:
            case CControlID::EDIT_NUM:
            case CControlID::COMBO:
            {
                HWND hwnd = GetDlgItem( m_hwnd, pControlID->GetID() );
                pSubData->list.push_front( hwnd );
                break;
            }
            default:
                OutputDebugString( TEXT("CPropertyDataWindow2::ConnectControlsToCheck: unknown CControlID::type\n") );
                break;

        }
    }

    SetWindowLong( hwndCheck, GWL_USERDATA, (long)pSubData );
}





BOOL CPropertyDataWindow2::WriteStringValue
(
    LPCTSTR  szKeyName,
    LPCTSTR  szValue
)
{
    TCHAR   szFile[MAX_PATH];

    //
    // We SAVE settings to the file on the finish page.
    //
    g_pWiz->m_FinishSheet.GetFilePane()->GetPathAndFile(szFile);

    return(WritePrivateProfileString(SECTION_SETTINGS, szKeyName,
        szValue, szFile));
}



BOOL CPropertyDataWindow2::WriteNumberValue
(
    LPCTSTR  szKeyName,
    int     nValue
)
{
    TCHAR   szValue[MAX_DIGITS];
    TCHAR   szFile[MAX_PATH];

    //
    // We SAVE settings to the file on the finish page.
    //
    g_pWiz->m_FinishSheet.GetFilePane()->GetPathAndFile(szFile);

    wsprintf(szValue, "%d", nValue);
    return(WritePrivateProfileString(SECTION_SETTINGS, szKeyName,
        szValue, szFile));
}



void CPropertyDataWindow2::ReadStringValue
(
    LPCTSTR  szKeyName,
    LPTSTR  szValue,
    UINT    cchMax
)
{
    TCHAR   szFile[MAX_PATH];

    //
    // We READ settings from the file on the intro page.
    //
    g_pWiz->m_IntroSheet.GetFilePane()->GetPathAndFile(szFile);

    GetPrivateProfileString(SECTION_SETTINGS, szKeyName,
            TEXT(""), szValue, cchMax, szFile);
}



void CPropertyDataWindow2::ReadNumberValue
(
    LPCTSTR  szKeyName,
    int *   pnValue
)
{
    TCHAR   szFile[MAX_PATH];

    //
    // We READ settings from the file on the intro page.
    //
    g_pWiz->m_IntroSheet.GetFilePane()->GetPathAndFile(szFile);

    *pnValue = GetPrivateProfileInt(SECTION_SETTINGS, szKeyName,
        0, szFile);
}



void CPropertyDataWindow2::ReadSettings()
{
    list< CControlID *>::const_iterator it;

    _ReadCheckSettings();

    for( it = m_condList.begin(); it != m_condList.end(); it++ )
    {
        _ReadCheckSetting( (*it)->GetCondID() );
        switch( (*it)->GetType() )
        {
            case CControlID::STATIC:
                break;

            case CControlID::EDIT:
            case CControlID::EDIT_NUM:
                _ReadEditSetting( (*it)->GetID() );
                break;
            case CControlID::CHECK:
                _ReadCheckSetting( (*it)->GetID() );
                break;
            case CControlID::COMBO:
                _ReadComboSetting( (*it)->GetID() );
                break;
            case CControlID::SLIDER:
                _ReadSliderSetting( (*it) );
                break;
            default:
                OutputDebugString( TEXT("CPropertyDataWindow2::ReadSettings: unknown CControlID::type\n") );
                assert( 0 );
                break;
        }
    }

    for( it = m_specialControlList.begin(); it != m_specialControlList.end(); it++ )
    {
        switch( (*it)->GetType() )
        {
            case CControlID::STATIC:
                break;

            case CControlID::EDIT:
            case CControlID::EDIT_NUM:
                _ReadEditSetting( (*it)->GetID() );
                break;
            case CControlID::CHECK:
                _ReadCheckSetting( (*it)->GetID() );
                break;
            case CControlID::COMBO:
                _ReadComboSetting( (*it)->GetID() );
                break;
            case CControlID::SLIDER:
                _ReadSliderSetting( (*it) );
                break;
            default:
                OutputDebugString( TEXT("CPropertyDataWindow2::ReadSettings: unknown CControlID::type\n") );
                assert( 0 );
                break;
        }
    }
}


BOOL CPropertyDataWindow2::WriteSettings()
{
    list< CControlID *>::const_iterator it;

    _WriteCheckSettings();

    for( it = m_condList.begin(); it != m_condList.end(); it++ )
    {
        _WriteCheckSetting( (*it)->GetCondID() );
        switch( (*it)->GetType() )
        {
            case CControlID::EDIT:
            case CControlID::EDIT_NUM:
                _WriteEditSetting( (*it)->GetID() );
                break;
            case CControlID::CHECK:
                _WriteCheckSetting( (*it)->GetID() );
                break;
            case CControlID::COMBO:
                _WriteComboSetting( (*it)->GetID() );
                break;
            case CControlID::SLIDER:
                _WriteSliderSetting( (*it)->GetID() );
                break;
            case CControlID::STATIC:
                break;

            default:
                OutputDebugString( TEXT("CPropertyDataWindow2::WriteSettings: unknown CControlID::type\n") );
                assert( 0 );
                break;
        }
    }

    for( it = m_specialControlList.begin(); it != m_specialControlList.end(); it++ )
    {
        switch( (*it)->GetType() )
        {
            case CControlID::EDIT:
            case CControlID::EDIT_NUM:
                _WriteEditSetting( (*it)->GetID() );
                break;
            case CControlID::CHECK:
                _WriteCheckSetting( (*it)->GetID() );
                break;
            case CControlID::COMBO:
                _WriteComboSetting( (*it)->GetID() );
                break;
            case CControlID::SLIDER:
                _WriteSliderSetting( (*it)->GetID() );
                break;
            case CControlID::STATIC:
                break;
            default:
                OutputDebugString( TEXT("CPropertyDataWindow2::WriteSettings: unknown CControlID::type\n") );
                assert( 0 );
                break;
        }
    }

    return TRUE;
}

void CPropertyDataWindow2::_ReadEditSetting( UINT EditID )
{
    TCHAR   szKeyName[8];
    TCHAR   szSetting[512];

    wsprintf( szKeyName, TEXT("%d"), EditID );

    ReadStringValue(szKeyName, szSetting, CCHMAX(szSetting));
    SetEditData(EditID, szSetting);
}


BOOL CPropertyDataWindow2::_WriteEditSetting( UINT EditID )
{
    BOOL    fSuccess;
    int iLen = GetEditDataLen( EditID ) + 1;
    LPTSTR szData = new TCHAR[ iLen ];
    GetEditData( EditID, szData, iLen );

    TCHAR szKeyName[ 8 ];
    wsprintf(szKeyName, TEXT("%d"), EditID);

    fSuccess = WriteStringValue(szKeyName, szData);

    delete [] szData;

    return(fSuccess);
}


void CPropertyDataWindow2::_ReadIntSetting( UINT ID, int *pData )
{
    TCHAR szKeyName[ 8 ];
    
    wsprintf( szKeyName, TEXT("%d"), ID );

    ReadNumberValue(szKeyName, pData);
}


BOOL CPropertyDataWindow2::_WriteIntSetting( UINT ID, int data )
{
    TCHAR szKeyName[ 8 ];

    wsprintf( szKeyName, TEXT("%d"), ID );
    
    return(WriteNumberValue(szKeyName, data));
}


void CPropertyDataWindow2::_ReadSliderSetting( CControlID *pControlID )
{
    int iPos;
    UINT ID = pControlID->GetID();

    _ReadIntSetting( ID, &iPos);

    //
    // HACK FOR AV BANDWIDTH -- TrackBars are limited to WORD-sized values
    // for range.  So the registry has the real value (bits/sec) but we 
    // represent it in NMRK UI as (kbits/sec).
    //
    iPos /= 1000;

    TrackBar_SetPos( GetDlgItem( m_hwnd, ID  ), TRUE, iPos);

    TCHAR szPos[ MAX_DIGITS ];
    wsprintf( szPos, TEXT("%u"), iPos );
    Static_SetText( GetDlgItem( m_hwnd, pControlID->GetStaticID()), szPos );
}


BOOL CPropertyDataWindow2::_WriteSliderSetting(  UINT ID )
{
    int iPos;

    //
    // HACK FOR AV BANDWIDTH -- TrackBars are limited to WORD-sized values
    // for range.  So the registry has the real value (bits/sec) but we 
    // represent it in NMRK UI as (kbits/sec).
    //

    iPos = TrackBar_GetPos(GetDlgItem(m_hwnd, ID));
    iPos *= 1000;

    return _WriteIntSetting( ID, iPos);
}



void CPropertyDataWindow2::_ReadComboSetting( UINT ID )
{
    int iSelected;

    _ReadIntSetting( ID, &iSelected );

    HWND hwndCombo = GetDlgItem( m_hwnd, ID );
    ComboBox_SetCurSel( hwndCombo, iSelected );
}


BOOL CPropertyDataWindow2::_WriteComboSetting( UINT ID )
{
    return _WriteIntSetting( ID, ComboBox_GetCurSel( GetDlgItem( m_hwnd, ID ) ) );
}


void CPropertyDataWindow2::_ReadCheckSetting( UINT ID )
{
    TCHAR szKeyName[ 8 ];
    int   nValue;

    wsprintf( szKeyName, TEXT("%d"), ID );
    ReadNumberValue(szKeyName, &nValue);

    CheckDlgButton(m_hwnd, ID, nValue);
}


BOOL CPropertyDataWindow2::_WriteCheckSetting( UINT ID )
{
    TCHAR szKeyName[ MAX_DIGITS ];

    wsprintf( szKeyName, TEXT("%d"), ID );

    return(WriteNumberValue(szKeyName, IsDlgButtonChecked(m_hwnd, ID)));
}


void CPropertyDataWindow2::_ReadCheckSettings()
{
    for( list< UINT >::const_iterator it = m_checkIDList.begin(); it != m_checkIDList.end(); it++ )
    {
        _ReadCheckSetting(*it);
    }
}


BOOL CPropertyDataWindow2::_WriteCheckSettings()
{
    for( list< UINT >::const_iterator it = m_checkIDList.begin(); it != m_checkIDList.end(); it++ )
    {
        if (!_WriteCheckSetting(*it))
        {
            return FALSE;
        }
    }
    return TRUE;
}





void CPropertyDataWindow2::MapControlsToRegKeys( void ) 
{
    
    if( 0 != ms_ValueMap.size() )
    {
        return;
    }

    UINT CurrentID;
    // File Transfer
    CurrentID = IDC_PREVENT_THE_USER_FROM_SENDING_FILES;
    ms_ClassMap[ CurrentID ] = CPolicyData::eKeyType_HKEY_CURRENT_USER;
    ms_KeyMap[ CurrentID  ] = POLICIES_KEY;;
    ms_ValueMap[ CurrentID ] = REGVAL_POL_NO_FILETRANSFER_SEND;

    CurrentID = IDC_PREVENT_THE_USER_FROM_RECEIVING_FILES;
    ms_ClassMap[ CurrentID ] = CPolicyData::eKeyType_HKEY_CURRENT_USER;
    ms_KeyMap[ CurrentID ] = POLICIES_KEY;
    ms_ValueMap[ CurrentID ] = REGVAL_POL_NO_FILETRANSFER_RECEIVE;

    CurrentID = IDC_EDIT_MAXIMUM_SIZE_OF_SENT_FILES;
    ms_ClassMap[ CurrentID ] = CPolicyData::eKeyType_HKEY_CURRENT_USER;
    ms_KeyMap[ CurrentID ] = POLICIES_KEY;
    ms_ValueMap[ CurrentID ] = REGVAL_POL_MAX_SENDFILESIZE;

    // App Sharing
    CurrentID = IDC_DISABLE_ALL_SHARING_FEATURES;
    ms_ClassMap[ CurrentID ] = CPolicyData::eKeyType_HKEY_CURRENT_USER;
    ms_KeyMap[ CurrentID ] = POLICIES_KEY;
    ms_ValueMap[ CurrentID ] = REGVAL_POL_NO_APP_SHARING;

    CurrentID = IDC_DISABLE_WEBDIR;
    ms_ClassMap[ CurrentID ] = CPolicyData::eKeyType_HKEY_CURRENT_USER;
    ms_KeyMap[ CurrentID ] = POLICIES_KEY;
    ms_ValueMap[ CurrentID ] = REGVAL_POL_NO_WEBDIR;

    CurrentID = IDC_DISABLE_WEBDIR_GK;
    ms_ClassMap[ CurrentID ] = CPolicyData::eKeyType_HKEY_CURRENT_USER;
    ms_KeyMap[ CurrentID ] = POLICIES_KEY;
    ms_ValueMap[ CurrentID ] = REGVAL_POL_NO_WEBDIR;

    CurrentID = IDC_PREVENT_SHARING;
    ms_ClassMap[ CurrentID ] = CPolicyData::eKeyType_HKEY_CURRENT_USER;
    ms_KeyMap[ CurrentID ] = POLICIES_KEY;
    ms_ValueMap[ CurrentID ] = REGVAL_POL_NO_SHARING;

    CurrentID = IDC_PREVENT_SHARING_DESKTOP;
    ms_ClassMap[ CurrentID ] = CPolicyData::eKeyType_HKEY_CURRENT_USER;
    ms_KeyMap[ CurrentID ] = POLICIES_KEY;
    ms_ValueMap[ CurrentID ] = REGVAL_POL_NO_DESKTOP_SHARING;

    CurrentID = IDC_PREVENT_SHARING_TRUECOLOR;
    ms_ClassMap[ CurrentID ] = CPolicyData::eKeyType_HKEY_CURRENT_USER;
    ms_KeyMap[ CurrentID ] = POLICIES_KEY;
    ms_ValueMap[ CurrentID ] = REGVAL_POL_NO_TRUECOLOR_SHARING;

    CurrentID = IDC_PREVENT_SHARING_EXPLORER;
    ms_ClassMap[ CurrentID ] = CPolicyData::eKeyType_HKEY_CURRENT_USER;
    ms_KeyMap[ CurrentID ] = POLICIES_KEY;
    ms_ValueMap[ CurrentID ] = REGVAL_POL_NO_EXPLORER_SHARING;

    CurrentID = IDC_PREVENT_SHARING_DOS;
    ms_ClassMap[ CurrentID ] = CPolicyData::eKeyType_HKEY_CURRENT_USER;
    ms_KeyMap[ CurrentID ] = POLICIES_KEY;
    ms_ValueMap[ CurrentID ] = REGVAL_POL_NO_MSDOS_SHARING;

    CurrentID = IDC_PREVENT_SHARING_CONTROL;
    ms_ClassMap[ CurrentID ] = CPolicyData::eKeyType_HKEY_CURRENT_USER;
    ms_KeyMap[ CurrentID ] = POLICIES_KEY;
    ms_ValueMap[ CurrentID ] = REGVAL_POL_NO_ALLOW_CONTROL;

    CurrentID = IDC_DISABLE_RDS_ON_ALL;
    ms_ClassMap[ CurrentID ] = CPolicyData::eKeyType_HKEY_LOCAL_MACHINE;
    ms_KeyMap[ CurrentID ] = POLICIES_KEY;
    ms_ValueMap[ CurrentID ] = REGVAL_POL_NO_RDS;

    CurrentID = IDC_DISABLE_RDS_ON_WIN9X;
    ms_ClassMap[ CurrentID ] = CPolicyData::eKeyType_HKEY_LOCAL_MACHINE;
    ms_KeyMap[ CurrentID ] = POLICIES_KEY;
    ms_ValueMap[ CurrentID ] = REGVAL_POL_NO_RDS_WIN9X;


    // Audio
    CurrentID = IDC_CREATE_AN_AUDIO_LOG_FILE; // HKLM
    ms_ClassMap[ CurrentID ] = CPolicyData::eKeyType_HKEY_LOCAL_MACHINE;
    ms_KeyMap[ CurrentID ] = DEBUG_KEY;
    ms_ValueMap[ CurrentID ] = REGVAL_RETAIL_LOG;

    CurrentID = IDC_CHECK_MUTE_SPEAKER_BY_DEFAULT;
    ms_ClassMap[ CurrentID ] = CPolicyData::eKeyType_HKEY_CURRENT_USER;
    ms_KeyMap[ CurrentID ] = AUDIO_KEY;
    ms_ValueMap[ CurrentID ] = REGVAL_SPKMUTE;

    CurrentID = IDC_CHECK_MUTE_MICROPHONE_BY_DEFAULT;
    ms_ClassMap[ CurrentID ] = CPolicyData::eKeyType_HKEY_CURRENT_USER;
    ms_KeyMap[ CurrentID ] = AUDIO_KEY;
    ms_ValueMap[ CurrentID ] = REGVAL_RECMUTE;

    CurrentID = IDC_ENABLE_DIRECT_SOUND;
    ms_ClassMap[ CurrentID ] = CPolicyData::eKeyType_HKEY_CURRENT_USER;
    ms_KeyMap[ CurrentID ] = AUDIO_KEY;
    ms_ValueMap[ CurrentID ] = REGVAL_DIRECTSOUND;

    CurrentID = IDC_NOCHANGE_DIRECT_SOUND;
    ms_ClassMap[CurrentID] = CPolicyData::eKeyType_HKEY_CURRENT_USER;
    ms_KeyMap[CurrentID] = POLICIES_KEY;
    ms_ValueMap[CurrentID] = REGVAL_POL_NOCHANGE_DIRECTSOUND;

    CurrentID = IDC_PREVENT_THE_USER_FROM_USING_AUDIO;
    ms_ClassMap[ CurrentID ] = CPolicyData::eKeyType_HKEY_CURRENT_USER;
    ms_KeyMap[ CurrentID ] = POLICIES_KEY;
    ms_ValueMap[ CurrentID ] = REGVAL_POL_NO_AUDIO;

    CurrentID = IDC_DISABLE_FULL_DUPLEX_AUDIO;
    ms_ClassMap[ CurrentID ] = CPolicyData::eKeyType_HKEY_CURRENT_USER;
    ms_KeyMap[ CurrentID ] = POLICIES_KEY;
    ms_ValueMap[ CurrentID ] = REGVAL_POL_NO_FULLDUPLEX;                

    // Video
    CurrentID = IDC_DISABLE_SENDING_VIDEO;
    ms_ClassMap[ CurrentID ] = CPolicyData::eKeyType_HKEY_CURRENT_USER;
    ms_KeyMap[ CurrentID ] = POLICIES_KEY;
    ms_ValueMap[ CurrentID ] = REGVAL_POL_NO_VIDEO_SEND;

    CurrentID = IDC_DISABLE_RECIEVING_VIDEO;
    ms_ClassMap[ CurrentID ] = CPolicyData::eKeyType_HKEY_CURRENT_USER;
    ms_KeyMap[ CurrentID ] = POLICIES_KEY;
    ms_ValueMap[ CurrentID ] = REGVAL_POL_NO_VIDEO_RECEIVE;

    // Notifications

    //
    // REMOTE OLDER WARNING is GONE
    //
    CurrentID = IDC_REQUIRE_COMPLETE_AUTHENTICATION;
    ms_ClassMap[ CurrentID ] = CPolicyData::eKeyType_HKEY_LOCAL_MACHINE;
    ms_KeyMap[ CurrentID ] = POLICIES_KEY;
    ms_ValueMap[ CurrentID ] = REGVAL_POL_NO_INCOMPLETE_CERTS;

    CurrentID = IDC_EDIT_SET_RDN_FOR_REQUIRED_CA;
    ms_ClassMap[ CurrentID ] = CPolicyData::eKeyType_HKEY_LOCAL_MACHINE;
    ms_KeyMap[ CurrentID ] = POLICIES_KEY;
    ms_ValueMap[ CurrentID ] = REGVAL_POL_ISSUER;

    // Directory Services
    CurrentID = IDC_ALLOW_USER_TO_USE_DIRECTORY_SERVICES;
    ms_ClassMap[ CurrentID ] = CPolicyData::eKeyType_HKEY_CURRENT_USER;
    ms_KeyMap[ CurrentID ] = CONFERENCING_KEY;
    ms_ValueMap[ CurrentID ] = REGVAL_DONT_LOGON_ULS;

    CurrentID = IDC_PREVENT_THE_USER_FROM_ADDING_NEW_SERVERS;
    ms_ClassMap[ CurrentID ] = CPolicyData::eKeyType_HKEY_CURRENT_USER;
    ms_KeyMap[ CurrentID ] = POLICIES_KEY;
    ms_ValueMap[ CurrentID ] = REGVAL_POL_NO_ADDING_NEW_ULS;

    // Chat
    CurrentID = IDC_DISABLE_CHAT;
    ms_ClassMap[ CurrentID ] = CPolicyData::eKeyType_HKEY_CURRENT_USER;
    ms_KeyMap[ CurrentID ] = POLICIES_KEY;
    ms_ValueMap[ CurrentID ] = REGVAL_POL_NO_CHAT;


    // Whiteboard
    // 
    // BOGUS BUGBUG LAURABU
    // We have OLD and NEW whiteboard
    //
    CurrentID = IDC_DISABLE_2XWHITEBOARD;
    ms_ClassMap[ CurrentID ] = CPolicyData::eKeyType_HKEY_CURRENT_USER;
    ms_KeyMap[ CurrentID ] = POLICIES_KEY;
    ms_ValueMap[ CurrentID ] = REGVAL_POL_NO_OLDWHITEBOARD;

    CurrentID = IDC_DISABLE_WHITEBOARD;
    ms_ClassMap[ CurrentID ] = CPolicyData::eKeyType_HKEY_CURRENT_USER;
    ms_KeyMap[ CurrentID ] = POLICIES_KEY;
    ms_ValueMap[ CurrentID ] = REGVAL_POL_NO_NEWWHITEBOARD;

    // Online Support
    CurrentID = IDC_EDIT_SET_URL_FOR_INTERNAL_SUPPORT_PAGE;
    ms_ClassMap[ CurrentID ] = CPolicyData::eKeyType_HKEY_CURRENT_USER;
    ms_KeyMap[ CurrentID ] = POLICIES_KEY;
    ms_ValueMap[ CurrentID ] = REGVAL_POL_INTRANET_SUPPORT_URL;

    CurrentID = IDC_SHOW_THE_ONLINE_SUPPORT_PAGE_THE_FIRST_TIME_NETMEETING_STARTS;
    ms_ClassMap[ CurrentID ] = CPolicyData::eKeyType_HKEY_CURRENT_USER;
    ms_KeyMap[ CurrentID ] = POLICIES_KEY;
    ms_ValueMap[ CurrentID ] = REGVAL_POL_SHOW_FIRST_TIME_URL;

    // Options Dialog 
    CurrentID = IDC_DISABLE_THE_GENERAL_OPTIONS_PAGE;
    ms_ClassMap[ CurrentID ] = CPolicyData::eKeyType_HKEY_CURRENT_USER;
    ms_KeyMap[ CurrentID ] = POLICIES_KEY;
    ms_ValueMap[ CurrentID ] = REGVAL_POL_NO_GENERALPAGE;

    CurrentID = IDC_DISABLE_THE_ADVANCED_CALLING_BUTTON;
    ms_ClassMap[ CurrentID ] = CPolicyData::eKeyType_HKEY_CURRENT_USER;
    ms_KeyMap[ CurrentID ] = POLICIES_KEY;
    ms_ValueMap[ CurrentID ] = REGVAL_POL_NO_ADVANCEDCALLING;

    CurrentID = IDC_DISABLE_THE_SECURITY_OPTIONS_PAGE;
    ms_ClassMap[ CurrentID ] = CPolicyData::eKeyType_HKEY_CURRENT_USER;
    ms_KeyMap[ CurrentID ] = POLICIES_KEY;
    ms_ValueMap[ CurrentID ] = REGVAL_POL_NO_SECURITYPAGE;

    CurrentID = IDC_DISABLE_THE_AUDIO_OPTIONS_PAGE;
    ms_ClassMap[ CurrentID ] = CPolicyData::eKeyType_HKEY_CURRENT_USER;
    ms_KeyMap[ CurrentID ] = POLICIES_KEY;
    ms_ValueMap[ CurrentID ] = REGVAL_POL_NO_AUDIOPAGE;

    CurrentID = IDC_DISABLE_THE_VIDEO_OPTIONS_PAGE;
    ms_ClassMap[ CurrentID ] = CPolicyData::eKeyType_HKEY_CURRENT_USER;
    ms_KeyMap[ CurrentID ] = POLICIES_KEY;
    ms_ValueMap[ CurrentID ] = REGVAL_POL_NO_VIDEOPAGE;

    CurrentID = IDC_DISABLE_AUTOACCEPT;
    ms_ClassMap[ CurrentID ] = CPolicyData::eKeyType_HKEY_CURRENT_USER;
    ms_KeyMap[ CurrentID ]   = POLICIES_KEY;
    ms_ValueMap[ CurrentID ] = REGVAL_POL_NO_AUTOACCEPTCALLS;

    CurrentID = IDC_PERSIST_AUTOACCEPT;
    ms_ClassMap[ CurrentID ] = CPolicyData::eKeyType_HKEY_CURRENT_USER;
    ms_KeyMap[ CurrentID ]   = POLICIES_KEY;
    ms_ValueMap[ CurrentID ] = REGVAL_POL_PERSIST_AUTOACCEPTCALLS;

    // Security RADIO Options
    CurrentID = IDC_RADIO_SECURITY_DEFAULT;
    ms_ClassMap[ CurrentID ] = CPolicyData::eKeyType_HKEY_CURRENT_USER;
    ms_KeyMap[ CurrentID ]   = POLICIES_KEY;
    ms_ValueMap[ CurrentID ] = REGVAL_POL_SECURITY;

    CurrentID = IDC_RADIO_SECURITY_REQUIRED;
    ms_ClassMap[ CurrentID ] = CPolicyData::eKeyType_HKEY_CURRENT_USER;
    ms_KeyMap[ CurrentID ]   = POLICIES_KEY;
    ms_ValueMap[ CurrentID ] = REGVAL_POL_SECURITY;

    CurrentID = IDC_RADIO_SECURITY_DISABLED;
    ms_ClassMap[ CurrentID ] = CPolicyData::eKeyType_HKEY_CURRENT_USER;
    ms_KeyMap[ CurrentID ]   = POLICIES_KEY;
    ms_ValueMap[ CurrentID ] = REGVAL_POL_SECURITY;

    // Call mode RADIO options
    CurrentID = IDC_RADIO_CALLMODE_DIRECT;
    ms_ClassMap[ CurrentID ] = CPolicyData::eKeyType_HKEY_CURRENT_USER;
    ms_KeyMap[ CurrentID ]   = CONFERENCING_KEY;
    ms_ValueMap[ CurrentID ] = REGVAL_CALLING_MODE;

    CurrentID = IDC_RADIO_CALLMODE_GATEKEEPER;
    ms_ClassMap[ CurrentID ] = CPolicyData::eKeyType_HKEY_CURRENT_USER;
    ms_KeyMap[ CurrentID ]   = CONFERENCING_KEY;
    ms_ValueMap[ CurrentID ] = REGVAL_CALLING_MODE;


    // Gateway
    CurrentID = IDC_CHECK_GATEWAY;
    ms_ClassMap[ CurrentID ] = CPolicyData::eKeyType_HKEY_CURRENT_USER;
    ms_KeyMap[ CurrentID ] = CONFERENCING_KEY;
    ms_ValueMap[ CurrentID ] = REGVAL_USE_H323_GATEWAY;

    CurrentID = IDC_EDIT_GATEWAY;
    ms_ClassMap[ CurrentID ] = CPolicyData::eKeyType_HKEY_CURRENT_USER;
    ms_KeyMap[ CurrentID ] = CONFERENCING_KEY;
    ms_ValueMap[ CurrentID ] = REGVAL_H323_GATEWAY;

    // Gatekeeper addressing RADIO options
    CurrentID = IDC_RADIO_GKMODE_ACCOUNT;
    ms_ClassMap[ CurrentID ] = CPolicyData::eKeyType_HKEY_CURRENT_USER;
    ms_KeyMap[ CurrentID ] = CONFERENCING_KEY;
    ms_ValueMap[ CurrentID ] = REGVAL_GK_METHOD;

    CurrentID = IDC_RADIO_GKMODE_PHONE;
    ms_ClassMap[ CurrentID ] = CPolicyData::eKeyType_HKEY_CURRENT_USER;
    ms_KeyMap[ CurrentID ] = CONFERENCING_KEY;
    ms_ValueMap[ CurrentID ] = REGVAL_GK_METHOD;

    CurrentID = IDC_RADIO_GKMODE_BOTH;
    ms_ClassMap[ CurrentID ] = CPolicyData::eKeyType_HKEY_CURRENT_USER;
    ms_KeyMap[ CurrentID ] = CONFERENCING_KEY;
    ms_ValueMap[ CurrentID ] = REGVAL_GK_METHOD;



    CurrentID = IDC_EDIT_GATEKEEPER;
    ms_ClassMap[ CurrentID ] = CPolicyData::eKeyType_HKEY_CURRENT_USER;
    ms_KeyMap[ CurrentID ] = CONFERENCING_KEY;
    ms_ValueMap[ CurrentID ] = REGVAL_GK_SERVER;

    CurrentID = IDC_CHECK_NOCHANGECALLMODE;
    ms_ClassMap[ CurrentID ] = CPolicyData::eKeyType_HKEY_CURRENT_USER;
    ms_KeyMap[ CurrentID ] = POLICIES_KEY;
    ms_ValueMap[ CurrentID ] = REGVAL_POL_NOCHANGECALLMODE;

    // AV Throughput
    CurrentID = IDC_SLIDE_AV_THROUGHPUT;
    ms_ClassMap[ CurrentID ] = CPolicyData::eKeyType_HKEY_CURRENT_USER;
    ms_KeyMap[ CurrentID ]   = POLICIES_KEY;
    ms_ValueMap[ CurrentID ] = REGVAL_POL_MAX_BANDWIDTH;

    // AutoConf
    CurrentID = IDC_CHECK_AUTOCONFIG_CLIENTS;
    ms_ClassMap[ CurrentID ] = CPolicyData::eKeyType_HKEY_CURRENT_USER;
    ms_KeyMap[ CurrentID ] = POLICIES_KEY;
    ms_ValueMap[ CurrentID ] = REGVAL_AUTOCONF_USE;

    CurrentID = IDC_AUTOCONF_URL;
    ms_ClassMap[ CurrentID ] = CPolicyData::eKeyType_HKEY_CURRENT_USER;
    ms_KeyMap[ CurrentID ] = POLICIES_KEY;
    ms_ValueMap[ CurrentID ] = REGVAL_AUTOCONF_CONFIGFILE;
 
    // Network Speed RADIO options
    CurrentID = IDC_RADIO_NETSPEED_144;
    ms_ClassMap[ CurrentID ] = CPolicyData::eKeyType_HKEY_CURRENT_USER;
    ms_KeyMap[ CurrentID ] = AUDIO_KEY;
    ms_ValueMap[ CurrentID ] = REGVAL_TYPICALBANDWIDTH;

    CurrentID = IDC_RADIO_NETSPEED_288;
    ms_ClassMap[ CurrentID ] = CPolicyData::eKeyType_HKEY_CURRENT_USER;
    ms_KeyMap[ CurrentID ] = AUDIO_KEY;
    ms_ValueMap[ CurrentID ] = REGVAL_TYPICALBANDWIDTH;

    CurrentID = IDC_RADIO_NETSPEED_ISDN;
    ms_ClassMap[ CurrentID ] = CPolicyData::eKeyType_HKEY_CURRENT_USER;
    ms_KeyMap[ CurrentID ] = AUDIO_KEY;
    ms_ValueMap[ CurrentID ] = REGVAL_TYPICALBANDWIDTH;

    CurrentID = IDC_RADIO_NETSPEED_LAN;
    ms_ClassMap[ CurrentID ] = CPolicyData::eKeyType_HKEY_CURRENT_USER;
    ms_KeyMap[ CurrentID ] = AUDIO_KEY;
    ms_ValueMap[ CurrentID ] = REGVAL_TYPICALBANDWIDTH;

}

BOOL CPropertyDataWindow2::WriteToINF( HANDLE hFile, BOOL bCheckValues ) 
{
    list< UINT > condList;
    list< CControlID *>::const_iterator it;

    _WriteChecksToINF( hFile, bCheckValues );

    for( it = m_condList.begin(); it != m_condList.end(); it++ )
    {
        if( ms_ValueMap.find( (*it)->GetCondID() ) != ms_ValueMap.end() )
        {
            list< UINT >::const_iterator i;
            if( (i = find( condList.begin(), condList.end(), (*it)->GetCondID() ) ) == condList.end()  )
            {
                condList.push_front( (*it)->GetCondID() );
                _WriteCheckToINF( hFile, (*it)->GetCondID(), bCheckValues );
            }
        }

        if( bCheckValues)
        {
            bCheckValues = Button_GetCheck( (*it)->GetCondHwnd() );
        }
        switch( (*it)->GetType() )
        {
            case CControlID::STATIC:
                break;

            case CControlID::EDIT_NUM:
                if( ms_ValueMap.find( (*it)->GetID() ) != ms_ValueMap.end() )
                {
                    _WriteEditNumToINF( hFile, (*it)->GetID(), bCheckValues );
                }
                break;
            case CControlID::EDIT:
                if( ms_ValueMap.find( (*it)->GetID() ) != ms_ValueMap.end() )
                {
                    _WriteEditToINF( hFile, (*it)->GetID(), bCheckValues );
                }
                break;
            case CControlID::CHECK:
                if( ms_ValueMap.find( (*it)->GetID() ) != ms_ValueMap.end() )
                {
                    _WriteCheckToINF( hFile, (*it)->GetID(), bCheckValues );
                }
                break;
            case CControlID::COMBO:
                if( ms_ValueMap.find( (*it)->GetID() ) != ms_ValueMap.end() )
                {
                    _WriteComboToINF( hFile, (*it)->GetID(), bCheckValues );
                }
                break;
            case CControlID::SLIDER:
                if( ms_ValueMap.find( (*it)->GetID() ) != ms_ValueMap.end() )
                {
                    _WriteSliderToINF( hFile, (*it)->GetID(), bCheckValues );
                }
                break;
            default:
                OutputDebugString( TEXT("CPropertyDataWindow2::WriteToINF: unknown CControlID::type\n") );
                assert( 0 );
                break;
        }
    }

    for( it = m_specialControlList.begin(); it != m_specialControlList.end(); it++ )
    {
        switch( (*it)->GetType() )
        {
            case CControlID::STATIC:
                break;

            case CControlID::EDIT_NUM:
                if( ms_ValueMap.find( (*it)->GetID() ) != ms_ValueMap.end() )
                {
                    _WriteEditNumToINF( hFile, (*it)->GetID(), bCheckValues );
                }
                break;
            case CControlID::EDIT:
                if( ms_ValueMap.find( (*it)->GetID() ) != ms_ValueMap.end() )
                {
                    _WriteEditToINF( hFile, (*it)->GetID(), bCheckValues );
                }
                break;
            case CControlID::CHECK:
                if( ms_ValueMap.find( (*it)->GetID() ) != ms_ValueMap.end() )
                {
                    _WriteCheckToINF( hFile, (*it)->GetID(), bCheckValues );
                }
                break;
            case CControlID::COMBO:
                if( ms_ValueMap.find( (*it)->GetID() ) != ms_ValueMap.end() )
                {
                    _WriteComboToINF( hFile, (*it)->GetID(), bCheckValues );
                }
                break;
            case CControlID::SLIDER:
                if( ms_ValueMap.find( (*it)->GetID() ) != ms_ValueMap.end() )
                {
                    _WriteSliderToINF( hFile, (*it)->GetID(), bCheckValues );
                }
                break;
            default:
                OutputDebugString( TEXT("CPropertyDataWindow2::WriteToINF: unknown CControlID::type\n") );
                assert( 0 );
                break;
        }
    }

    return TRUE;
}

void CPropertyDataWindow2::_WriteCheckToINF( HANDLE hFile, UINT ID, BOOL bCheckValues ) 
{
    HWND    hwndButton;
    BOOL    fIsRadioButton;
    DWORD   dwWrite;

    hwndButton = GetDlgItem(m_hwnd, ID);
    switch (GetWindowLong(hwndButton, GWL_STYLE) & 0x0F)
    {
        case BS_RADIOBUTTON:
        case BS_AUTORADIOBUTTON:
            fIsRadioButton = TRUE;
            break;

        default:
            fIsRadioButton = FALSE;
            break;
    }

    if (bCheckValues && Button_GetCheck(hwndButton))
    {
        if (fIsRadioButton)
        {
            //
            // For radio buttons, real value is in user data
            //
            dwWrite = GetWindowLong(hwndButton, GWL_USERDATA);
        }
        else
        {
            dwWrite = TRUE;
        }

        CPolicyData(ms_ClassMap[ID], ms_KeyMap[ID], ms_ValueMap[ID], dwWrite).
            SaveToINFFile(hFile);
    }
    else 
    {
        //
        // If this is a radio button, do not write the unchecked ones out.
        //
        if (!fIsRadioButton)
        {
            dwWrite = FALSE;

            CPolicyData(ms_ClassMap[ ID ],
                        ms_KeyMap[ ID ],
                        ms_ValueMap[ ID ],
                        dwWrite).SaveToINFFile( hFile );
        }
    }
}


void CPropertyDataWindow2::_WriteChecksToINF( HANDLE hFile, BOOL bCheckValues ) 
{
    list< UINT >::const_iterator it;

    for (it = m_checkIDList.begin(); it != m_checkIDList.end(); it++)
    {
        if (ms_ValueMap.find(*it) != ms_ValueMap.end())
        {
            _WriteCheckToINF(hFile, *it, bCheckValues);
        }
    }
}


void CPropertyDataWindow2::_WriteEditNumToINF( HANDLE hFile, UINT EditID, BOOL bCheckValues )
{
    if( bCheckValues )
    {
        CPolicyData( ms_ClassMap[ EditID ],
                     ms_KeyMap[ EditID ],
                     ms_ValueMap[ EditID ],
                     (DWORD) GetDlgItemInt(  m_hwnd, EditID, NULL, FALSE ) ).SaveToINFFile( hFile );
    }
    else
    {
        _DeleteKey( hFile, EditID );
    }
}

void CPropertyDataWindow2::_WriteEditToINF( HANDLE hFile, UINT EditID, BOOL bCheckValues )
{
    if( bCheckValues )
    {
        int iLen = GetEditDataLen( EditID ) + 1;
        LPTSTR szData = new TCHAR[ iLen ];
        GetEditData( EditID, szData, iLen );

        CPolicyData( ms_ClassMap[ EditID ],
                     ms_KeyMap[ EditID ],
                     ms_ValueMap[ EditID ],
                     szData ).SaveToINFFile( hFile );
        delete [] szData;
    }
    else
    {
        _DeleteKey( hFile, EditID );
    }
}



void CPropertyDataWindow2::_WriteSliderToINF( HANDLE hFile, UINT SliderID, BOOL bCheckValues )
{
    if( bCheckValues )
    {
        int iPos;

        iPos = TrackBar_GetPos(GetDlgItem(m_hwnd, SliderID));
        iPos *= 1000;
        CPolicyData( ms_ClassMap[ SliderID ], 
                     ms_KeyMap[ SliderID ], 
                     ms_ValueMap[ SliderID ], 
                     (DWORD)iPos
                   ).SaveToINFFile( hFile );
    }
    else
    {
        _DeleteKey( hFile, SliderID );
    }
}

void CPropertyDataWindow2::_WriteComboToINF( HANDLE hFile, UINT ComboID, BOOL bCheckValues )
{
    if( bCheckValues )
    {
        HWND hwndCombo = GetDlgItem( m_hwnd, ComboID );

        CPolicyData( ms_ClassMap[ ComboID ], 
                 ms_KeyMap[ ComboID ], 
                 ms_ValueMap[ ComboID ], 
                 (DWORD) ComboBox_GetItemData( hwndCombo, ComboBox_GetCurSel( hwndCombo ) ) 
               ).SaveToINFFile( hFile );
    }
    else
    {
        _DeleteKey( hFile, ComboID );
    }
}

void CPropertyDataWindow2::_DeleteKey( HANDLE hFile, UINT ID ) 
{
    CPolicyData( ms_ClassMap[ ID ], 
                 ms_KeyMap[ ID ], 
                 ms_ValueMap[ ID ], 
                 CPolicyData::OpDelete()
               ).SaveToINFFile( hFile );

}

int CPropertyDataWindow2::Spew( HWND hwndList, int iStartLine )
{
    list< UINT >::const_iterator it;
    for( it = m_checkIDList.begin(); it != m_checkIDList.end(); it++ ) 
    {
        if( Button_GetCheck( GetDlgItem( m_hwnd, *it ) ) )
        {
            HWND hwndButton = GetDlgItem( m_hwnd, *it );
            // 2 is 1 for '\0' and 1 for '\t'
            int iButtonTextLen = Button_GetTextLength( hwndButton ) + 2;
            LPTSTR szButtonText = new TCHAR[ iButtonTextLen ];
            szButtonText[0] = '\t';
            Button_GetText( hwndButton, &(szButtonText[1]), iButtonTextLen - 1 );
            ListBox_InsertString( hwndList, iStartLine, szButtonText );
            iStartLine++;
        }
    }

    list< CControlID *>::const_iterator i;
    if( m_condList.size() )
    {
        for( i = m_condList.begin(); i != m_condList.end(); i++ )
        {
            if( Button_GetCheck( (*i)->GetCondHwnd() ) )
            {
                iStartLine = _Spew( hwndList, iStartLine, *i );
            }
        }
    }

    if( m_specialControlList.size() )
    {
        for( i = m_specialControlList.begin(); i != m_specialControlList.end(); i++ )
        {
            iStartLine = _Spew( hwndList, iStartLine, *i );
        }
    }

    return iStartLine;
}

int CPropertyDataWindow2::_Spew( HWND hwndList, int iStartLine, CControlID *pControlID )
{
    switch( pControlID->GetType() )
    {
        case CControlID::EDIT_NUM:
        case CControlID::EDIT:
        {
            int iEditLen = GetEditDataLen( pControlID->GetID() ) + 1;
            if( iEditLen )
            {
                int iLen = Button_GetTextLength( pControlID->GetCondHwnd() ) + 1;

                LPTSTR sz = new TCHAR[ iLen];
                Button_GetText( pControlID->GetCondHwnd(), sz, iLen );    

                LPTSTR szData = new TCHAR[ iEditLen];
                GetEditData( pControlID->GetID(), szData, iEditLen );

                // 2 is: 1 for ' ' and 1 for '\t'
                LPTSTR szBuff = new TCHAR[ iLen + iEditLen + 2];
                wsprintf( szBuff, TEXT("\t%s %s"), sz, szData );
                ListBox_InsertString( hwndList, iStartLine, szBuff );
                iStartLine++;
                delete [] szData;
                delete [] szBuff;
                delete [] sz;
            }
            break;
        }

        case CControlID::CHECK:
        {
            HWND hwnd = GetDlgItem( m_hwnd, pControlID->GetID() );
            if( Button_GetCheck( hwnd ) )
            {
                int iLen = Button_GetTextLength( hwnd ) + 2;

                LPTSTR sz = new TCHAR[ iLen];
                sz[0] = '\t';
                Button_GetText( hwnd, &sz[1], iLen );

                ListBox_InsertString( hwndList, iStartLine, sz );
                iStartLine++;

                delete [] sz;
            }
            break;
        }

        case CControlID::COMBO:
        {
            HWND hwnd = GetDlgItem( m_hwnd, pControlID->GetID() );
            int iCurSel = ComboBox_GetCurSel( hwnd );
            int iLen = ComboBox_GetLBTextLen( hwnd, iCurSel ) + 2;
            LPTSTR sz = new TCHAR[ iLen ];
            sz[0] = '\t';
            ComboBox_GetLBText( hwnd, iCurSel, &(sz[1]) );
    
            ListBox_InsertString( hwndList, iStartLine, sz );
            iStartLine++;

            delete [] sz;
            break;
        }

        case CControlID::SLIDER:
        {
            HWND hwnd = GetDlgItem( m_hwnd, pControlID->GetID() );
            TCHAR sz[ MAX_DIGITS ]; 
            wsprintf( sz, TEXT("\t%d kbits/s"), TrackBar_GetPos( hwnd ) );
    
            ListBox_InsertString( hwndList, iStartLine, sz );
            iStartLine++;

            break;
        }

        case CControlID::STATIC:
            break;

        default:
            OutputDebugString( TEXT("CPropertyDataWindow2::_Spew: unknown CControlID::type\n") );
            assert( 0 );
            break;
    }

    return iStartLine;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\nmrk\proppg.h ===
////////////////////////////////////////////////////////////////////////////////////////////////////
// CPropertySheetPage is a small wrapper around the PROPSHEETPAGE structure.  
// The class mostly does parameter validation.  
//
// This is an example of how it can be used...
//
//
// CPropertySheetPage MyPropertySheetPage( 
//                                         MAKEINTRESOURCE( IDD_PROPPAGE_DEFAULT ), 
//                                         ( DLGPROC ) MyDlgProc, 
//                                         PSP_HASHELP   
//                                       );
//      
//
// The casting operators are defined to cast a CPropertySheetPage to a LPPROPSHEETPAGE, which is
//      useful for assigning to the elements in a PROPSHEETHEADER
//
//
//  PROPSHEETHEADER Psh;
//  LPPROPSHEETPAGE pPageAry;
//  extern PROPSHEETPAGE OtherPage;        
//
//  pPageAry = new PROPSHEETPAGE[ 2 ]
//  
//
//      pPageAry[ 0 ] = MyPropertySheetPage;
//      pPageAry[ 0 ] = OtherPage;
//
//      Psh . ppsp = pPageAry;
//
//
//
//
// NOTE: this is the signature for the callback function, if specified:
//
// UINT (CALLBACK FAR * LPFNPSPCALLBACKA)(HWND hwnd, UINT uMsg, struct _PROPSHEETPAGEA FAR *ppsp);
//
//
////////////////////////////////////////////////////////////////////////////////////////////////////


#ifndef __PropPg_h__
#define __PropPg_h__


////////////////////////////////////////////////////////////////////////////////////////////////////
//  comment this out if you don't want data validation ( class essentially does nothing )
//
#define CPropertySheetPage_ValidateParameters
////////////////////////////////////////////////////////////////////////////////////////////////////

class CPropertySheetPage : public PROPSHEETPAGE {

public: // Construction / destruction
	CPropertySheetPage( void );	 // So We can make an Array of these things

	CPropertySheetPage( const CPropertySheetPage& r );

        // pssTemplate can specify either the resource identifier of the template 
        // or the address of a string that specifies the name of the template
	CPropertySheetPage( LPCTSTR pszTemplate, DLGPROC pfnDlgProc, 
						DWORD dwFlags = 0, LPARAM lParam = 0L 
					  );

	CPropertySheetPage( LPCDLGTEMPLATE pResource, DLGPROC pfnDlgProc,
						DWORD dwFlags = 0, LPARAM lParam = 0L  
					  );

        // psTemplate can specify either the resource identifier of the template 
        // or the address of a string that specifies the name of the template
	CPropertySheetPage( LPCTSTR pszTemplate, DLGPROC pfnDlgProc, 
						HICON hIcon, LPCTSTR pszTitle = NULL,  DWORD dwFlags = 0,
						LPARAM lParam = NULL, LPFNPSPCALLBACK pfnCallBack = NULL, 
						UINT FAR * pcRefParent = NULL
					  );

	CPropertySheetPage( LPCDLGTEMPLATE pResource, DLGPROC pfnDlgProc, 
						HICON hIcon, LPCTSTR pszTitle = NULL, DWORD dwFlags = 0,
						LPARAM lParam = NULL, LPFNPSPCALLBACK pfnCallBack = NULL, 
						UINT FAR * pcRefParent = NULL
					  );

        // pszTemplate can specify either the resource identifier of the template 
        // or the address of a string that specifies the name of the template
	CPropertySheetPage( LPCTSTR pszTemplate, DLGPROC pfnDlgProc,
						LPCTSTR pszIcon, LPCTSTR pszTitle = NULL, DWORD dwFlags = 0,
						LPARAM lParam = NULL, LPFNPSPCALLBACK pfnCallBack = NULL, 
						UINT FAR * pcRefParent = NULL
					  );

	CPropertySheetPage( LPCDLGTEMPLATE pResource, DLGPROC pfnDlgProc,
						LPCTSTR pszIcon, LPCTSTR pszTitle = NULL, DWORD dwFlags = 0,
						LPARAM lParam = NULL, LPFNPSPCALLBACK pfnCallBack = NULL, 
						UINT FAR * pcRefParent = NULL
					  );

    CPropertySheetPage( LPCPROPSHEETPAGE pPageVector );

	CPropertySheetPage& operator=( const CPropertySheetPage& r );
	~CPropertySheetPage( void );

    
        // conversion operator
    operator LPPROPSHEETPAGE() { return this; }
    operator LPCPROPSHEETPAGE() { return this; }

private:    // Helper Fns

	void _InitData( void );
	BOOL _IsRightToLeftLocale( void ) const;

		// Set with optional validation, defined in the cpp file
	BOOL _Set_hInstance( HINSTANCE hInst );
	BOOL _Set_pszTemplate( LPCTSTR pszTemplate );
	BOOL _Set_pResource( LPCDLGTEMPLATE pResource );
	BOOL _Set_hIcon( HICON hIcon );
	BOOL _Set_pszIcon( LPCTSTR pszIcon );
	BOOL _Set_pszTitle( LPCTSTR pszTitle );
	BOOL _Set_pfnDlgProc( DLGPROC pfnDlgProc );
	BOOL _Set_pfnCallback( LPFNPSPCALLBACK pfnCallBack );
	BOOL _Set_lParam( LPARAM lParam );
	BOOL _Set_pcRefParent( UINT FAR * pcRefParent );
	BOOL _Validate( void ) const;
};
		


#endif // __PropPg_h__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\nmrk\propwnd2.h ===
#ifndef __PropWnd2_h__
#define __PropWnd2_h__

////////////////////////////////////////////////////////////////////////////////////////////////////

#pragma warning( disable : 4786 )
#include <list>
#include <map>
#include "poldata.h"
#include "controlID.h"
using namespace std;
////////////////////////////////////////////////////////////////////////////////////////////////////


LRESULT CALLBACK DefaultProc( HWND hwnd, UINT iMsg, WPARAM wParam, LPARAM lParam );

class CPropertyDataWindow2 
{
friend class CNmAkWiz;

public: // Static functions
	static void MapControlsToRegKeys( void );

private: // Static functions
	

public: // Static Data
	static const int mcs_iTop;
	static const int mcs_iLeft;
	static const int mcs_iBorder;

protected: // Static Data
	static  map< UINT, CPolicyData::eKeyType > ms_ClassMap;
	static  map< UINT, TCHAR* > ms_KeyMap;
	static  map< UINT, TCHAR* > ms_ValueMap;
	
protected:    // DATA

    // Frame Window for data boxes
	TCHAR					*m_szClassName;
    HWND                    m_hwnd;
	HWND					m_hwndParent;
	UINT					m_IDD;
	WNDPROC					m_wndProc;
	RECT					m_rect;

	list< UINT >			m_checkIDList;
	list< HWND >			m_enableList;
	list< CControlID * >	m_condList;
	list< CControlID * >    m_specialControlList;
	BOOL					m_bInit;

public: // construction / destruction
	CPropertyDataWindow2( HWND hwndParent, UINT uIDD, LPTSTR szClassName, WNDPROC wndProc, UINT PopUpHelpMenuTextId, int iX, int iY, int iWidth, int iHeight, BOOL bScroll = TRUE );
	CPropertyDataWindow2( HWND hwndParent, UINT uIDD, LPTSTR szClassName, UINT PopUpHelpMenuTextId, int iX, int iY, int iWidth, int iHeight, BOOL bScroll = TRUE );
    ~CPropertyDataWindow2( void );
        
public: // Member fns
	inline HWND GetHwnd() { return m_hwnd; };
	inline int LoadString( UINT IDS, LPTSTR lpszBuffer, int cb ) { return ::LoadString( g_hInstance, IDS, lpszBuffer, cb ); }

	void ConnectControlsToCheck( UINT idCheck, UINT uCount, ... );
	void AddControl( CControlID *pControl );
	void SetEnableListID( UINT uCount, ... );

    void GetEditData( UINT id, TCHAR* sz, ULONG cb ) const;
    void SetEditData( UINT id, TCHAR* sz );
	ULONG GetEditDataLen( UINT id ) const;
    
	BOOL SetFocus( UINT id );

    BOOL GetCheck( UINT id ) const;
	void SetCheck( UINT id, BOOL bCheck );

	void ShowWindow( BOOL bShowWindow = TRUE );
	void EnableWindow( BOOL bEnable = TRUE );

	void ReadSettings( void );
	BOOL WriteSettings( void );
	void Reset();

	BOOL WriteToINF( HANDLE hFile, BOOL bCheckValues );

	int Spew( HWND hwndList, int iStartLine );

protected: // Helper Fns
    BOOL _InitWindow( void );
	BOOL _SizeWindow( int X, int Y, int Width, int Height );
	void _PrepScrollBars( void );

	void _ReadIntSetting( UINT ID, int *pData );
	void _ReadEditSetting( UINT EditID );
	void _ReadCheckSetting( UINT ID);
	void _ReadComboSetting( UINT ComboID );
	void _ReadSliderSetting( CControlID * );
	void _ReadCheckSettings( void );

	BOOL _WriteIntSetting(UINT ID, int iData);
	BOOL _WriteEditSetting( UINT EditID );
	BOOL _WriteCheckSetting( UINT ID);
	BOOL _WriteComboSetting( UINT ComboID );
	BOOL _WriteSliderSetting( UINT ID );
	BOOL _WriteCheckSettings( void );

	// We need these friends so that the WebView data can be shared
	friend void ReadWebViewSettings(CPropertyDataWindow2 *pData);
	friend void WriteWebViewSettings(CPropertyDataWindow2 *pData);

    BOOL    WriteStringValue(LPCTSTR szKeyName, LPCTSTR szValue);
    BOOL    WriteNumberValue(LPCTSTR szKeyName, int nValue);
    void    ReadStringValue(LPCTSTR szKeyName, LPTSTR szValue, UINT cchValueMax);
    void    ReadNumberValue(LPCTSTR szKeyName, int * pnValue);


	void _WriteCheckToINF( HANDLE hFile, UINT ID, BOOL bCheckValues );
	void _WriteChecksToINF( HANDLE hFile, BOOL bCheckValues );
	void _WriteEditToINF( HANDLE hFile, UINT EditID, BOOL bCheckValues );
	void _WriteEditNumToINF( HANDLE hFile, UINT EditID, BOOL bCheckValues );
	void _WriteSliderToINF( HANDLE hFile, UINT SliderID, BOOL bCheckValues );
	void _WriteComboToINF( HANDLE hFile, UINT ComboID, BOOL bCheckValues );
	void _DeleteKey( HANDLE hFile, UINT ID );

	int _Spew( HWND hwndList, int iStartLine, CControlID *pControlID );

};

#endif // __PropWnd_h__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\nmrk\pshthdr.cpp ===
////////////////////////////////////////////////////////////////////////////////////////////////////
// Include Files

#include "precomp.h"
#include "PropPg.h"
#include "PShtHdr.h"


////////////////////////////////////////////////////////////////////////////////////////////////////
// Construction, destruction, and Initialization
////////////////////////////////////////////////////////////////////////////////////////////////////

//--------------------------------------------------------------------------------------------------
// CPropertySheetHeader::CPropertySheetHeader
CPropertySheetHeader::CPropertySheetHeader( void ) {
    _InitData();
}


//--------------------------------------------------------------------------------------------------
// CPropertySheetHeader::CPropertySheetHeader

CPropertySheetHeader::CPropertySheetHeader( int nPages, UsePropertySheetArray dummy, PFNPROPSHEETCALLBACK pfnCallback /* = NULL */ ) {

    _InitData();

    this -> ppsp = new PROPSHEETPAGE[ nPages ];
    this -> dwFlags |= PSH_PROPSHEETPAGE;
	this -> nPages = nPages;

    _Set_pfnCallback( pfnCallback );

#ifdef CPropertySheetHeader_ValidateParameters
        
#endif // CPropertySheetHeader_ValidateParameters

    _Validate();
}


//--------------------------------------------------------------------------------------------------
// CPropertySheetHeader::CPropertySheetHeader

CPropertySheetHeader::CPropertySheetHeader( int nPages, UsePropertySheetHandleArray dummy, PFNPROPSHEETCALLBACK pfnCallback /* = NULL */  ) {

    _InitData();

    this -> phpage = new HPROPSHEETPAGE[ nPages ];
    this -> dwFlags &= ~PSH_PROPSHEETPAGE;
	this -> nPages = nPages;

    _Set_pfnCallback( pfnCallback );

#ifdef CPropertySheetHeader_ValidateParameters
        
#endif // CPropertySheetHeader_ValidateParameters

    _Validate();

}


//--------------------------------------------------------------------------------------------------
// CPropertySheetHeader::CPropertySheetHeader

CPropertySheetHeader::CPropertySheetHeader( LPCPROPSHEETPAGE pPageVector, int nPages, PFNPROPSHEETCALLBACK pfnCallback /* = NULL */ ) 
{ 

    _InitData();

    if( _Set_ppsp( pPageVector, nPages ) )       { assert( 0 ); return; }
    
    _Set_pfnCallback( pfnCallback );

#ifdef CPropertySheetHeader_ValidateParameters
        
#endif // CPropertySheetHeader_ValidateParameters

    _Validate();
}


//--------------------------------------------------------------------------------------------------
// CPropertySheetHeader::CPropertySheetHeader
// Note that we are assuming that you are telling us wether to use the ppsp or the phpage member
// of PROPSHEETHEADER, as specified by the flag PSH_PROPSHEETPAGE
CPropertySheetHeader::CPropertySheetHeader( int nPages, DWORD dwFlags, PFNPROPSHEETCALLBACK pfnCallback /* = NULL */  ) {
    _InitData();

	this -> dwFlags = dwFlags;
	if( this -> dwFlags & PSH_PROPSHEETPAGE ) {
		this -> ppsp = new PROPSHEETPAGE[ nPages ];
		this -> nPages = nPages;
		ZeroMemory( const_cast<LPPROPSHEETPAGE>( this -> ppsp ), sizeof( PROPSHEETPAGE ) * nPages );
	}
	else {
		this -> phpage = new HPROPSHEETPAGE[ nPages ];
		this -> nPages = nPages;
		ZeroMemory( this -> phpage, sizeof( HPROPSHEETPAGE )  * nPages );
	}
    
    _Set_pfnCallback( pfnCallback );
    
    _Validate();
}


//--------------------------------------------------------------------------------------------------
// CPropertySheetHeader::~CPropertySheetHeader

CPropertySheetHeader::~CPropertySheetHeader( void ) {
    _DeletePageData();
}




//--------------------------------------------------------------------------------------------------
// CPropertySheetHeader::_InitData

BOOL CPropertySheetHeader::_InitData( void ) {
    ZeroMemory( this, sizeof( PROPSHEETHEADER ) );
    this -> dwSize = sizeof( PROPSHEETHEADER );
    return TRUE;
}

////////////////////////////////////////////////////////////////////////////////////////////////////
// Methods and operators
////////////////////////////////////////////////////////////////////////////////////////////////////

    

//--------------------------------------------------------------------------------------------------
// CPropertySheetHeader::operator[]
// This is a funny little beastie.  Basically, it returns an iterator so the results can be used as 
// both an lval and an rval.
//
//  MyPropertySheetPage = MyPropSheetHeader[ 0 ];
//  MyPropSheetHeader[ 1 ] = OtherPage;

CPropertySheetHeader::CPropertySheetPageDataIterator CPropertySheetHeader::operator[]( int index ) {

#ifdef CPropertySheetHeader_ValidateParameters
    assert( index >= 0 );
    if( static_cast< UINT >( index ) >= this -> nPages ) { // This is out of range ( they start at 0 )
        assert( 0 );
        return CPropertySheetPageDataIterator( 0, this );
    }
#endif // CPropertySheetHeader_ValidateParameters

    return CPropertySheetPageDataIterator( index, this );
}
    


//--------------------------------------------------------------------------------------------------
// CPropertySheetHeader::_Validate

BOOL CPropertySheetHeader::_Validate( void ) {

#ifdef CPropertySheetHeader_ValidateParameters

    if( ( this -> dwFlags & PSH_PROPTITLE ) || ( this -> dwFlags & PSH_USEICONID ) ) {
        if( NULL == this -> hInstance ) {
            assert( 0 );
            return FALSE;
        }
    }

#endif // CPropertySheetHeader_ValidateParameters

    return TRUE;
}



//--------------------------------------------------------------------------------------------------
// CPropertySheetHeader::_Set_hwndParent

BOOL CPropertySheetHeader::_Set_hwndParent( HWND hwndParent ) {

#ifdef CPropertySheetHeader_ValidateParameters
    
#endif // CPropertySheetHeader_ValidateParameters

    this -> hwndParent = hwndParent;
    return TRUE;
}

BOOL CPropertySheetHeader::_Set_hInstance( HINSTANCE hInstance ) {
#ifdef CPropertySheetHeader_ValidateParameters


#endif // CPropertySheetHeader_ValidateParameters

    this -> hInstance = hInstance;
    return TRUE;

}


//--------------------------------------------------------------------------------------------------
// CPropertySheetHeader::_Set_hIcon
BOOL CPropertySheetHeader::_Set_hIcon( HICON hIcon ) {

    if( NULL == hIcon ) { return FALSE; }
#ifdef CPropertySheetHeader_ValidateParameters

#endif // CPropertySheetHeader_ValidateParameters


    this -> dwFlags &= ~PSH_USEICONID;
    this -> dwFlags |= PSH_USEHICON;
    this -> hIcon = hIcon;
    
    return TRUE;
}


//--------------------------------------------------------------------------------------------------
// CPropertySheetHeader::_Set_pszIcon
BOOL CPropertySheetHeader::_Set_pszIcon( LPCTSTR pszIcon )  {

    if( NULL == pszIcon ) { return FALSE; }
#ifdef CPropertySheetHeader_ValidateParameters
    if( NULL == this -> hInstance ) { // This must be set first
        assert( 0 );
        return FALSE;
    }

#endif // CPropertySheetHeader_ValidateParameters

    this -> dwFlags &= ~PSH_USEHICON;
    this -> dwFlags |= PSH_USEICONID;
    this -> pszIcon = pszIcon;

    return TRUE;
}


//--------------------------------------------------------------------------------------------------
// CPropertySheetHeader::_Set_pszCaption
BOOL CPropertySheetHeader::_Set_pszCaption( LPCTSTR pszCaption ) {

    if( NULL == pszCaption ) { return FALSE; }
#ifdef CPropertySheetHeader_ValidateParameters
    if( NULL == this -> hInstance ) { // This must be set first
        assert( 0 );
        return FALSE;
    }

#endif // CPropertySheetHeader_ValidateParameters

    this -> dwFlags |= PSH_PROPTITLE;
    this -> pszCaption = pszCaption;

    return TRUE;
}


//--------------------------------------------------------------------------------------------------
// CPropertySheetHeader::_Set_nStartPage

BOOL CPropertySheetHeader::_Set_nStartPage( UINT nStartPage ) {

#ifdef CPropertySheetHeader_ValidateParameters
    if( ( nStartPage > 0 ) || ( nStartPage >= this -> nPages ) ) {
        assert( 0 );
        return FALSE;
    }

#endif // CPropertySheetHeader_ValidateParameters

    this -> dwFlags &= ~PSH_USEPSTARTPAGE;
    this -> nStartPage = nStartPage;
    return TRUE;
}



//--------------------------------------------------------------------------------------------------
// CPropertySheetHeader::_Set_pStartPage
BOOL CPropertySheetHeader::_Set_pStartPage( LPCTSTR pStartPage ) {

    if( NULL == pStartPage ) { return FALSE; }

#ifdef CPropertySheetHeader_ValidateParameters

#endif // CPropertySheetHeader_ValidateParameters

    this -> dwFlags |= PSH_USEPSTARTPAGE;
    this -> pStartPage = pStartPage;
    return TRUE;
}

//--------------------------------------------------------------------------------------------------
// CPropertySheetHeader::_Set_ppsp

BOOL CPropertySheetHeader::_Set_ppsp( LPCPROPSHEETPAGE ppsp, UINT nPages ) {


    _DeletePageData();

    this -> ppsp = new PROPSHEETPAGE[ nPages ];
    this -> dwFlags |= PSH_PROPSHEETPAGE;

#ifdef CPropertySheetHeader_ValidateParameters
    for( UINT i = 0; i < this -> nPages; i++ ) {
        const_cast<LPPROPSHEETPAGE>( this -> ppsp )[ i ] = CPropertySheetPage( ppsp + i );
    }
#else
    memcpy( this -> ppsp, ppsp, sizeof( PROPSHEETPAGE ) * nPages );
#endif // CPropertySheetHeader_ValidateParameters

    this -> nPages = nPages;

    return TRUE;
}


//--------------------------------------------------------------------------------------------------
// CPropertySheetHeader::_Set_phpage
BOOL CPropertySheetHeader::_Set_phpage( HPROPSHEETPAGE FAR phpage, UINT nPages ) {

#ifdef CPropertySheetHeader_ValidateParameters

#endif // CPropertySheetHeader_ValidateParameters

    _DeletePageData();

    this -> phpage = new HPROPSHEETPAGE[ nPages ];
    this -> dwFlags &= ~PSH_PROPSHEETPAGE;
    memcpy( this -> phpage, phpage, sizeof( HPROPSHEETPAGE ) * nPages );
    this -> nPages = nPages;
    return TRUE;
}


//--------------------------------------------------------------------------------------------------
// CPropertySheetHeader::_Set_pfnCallback
BOOL CPropertySheetHeader::_Set_pfnCallback( PFNPROPSHEETCALLBACK pfnCallback ) {

#ifdef CPropertySheetHeader_ValidateParameters

#endif // CPropertySheetHeader_ValidateParameters

    if( NULL != pfnCallback ) {
        this -> pfnCallback = pfnCallback;
        this -> dwFlags |= PSH_USECALLBACK;
    }
    return TRUE;
}

//--------------------------------------------------------------------------------------------------
// CPropertySheetHeader::_DeletePageData

BOOL CPropertySheetHeader::_DeletePageData( void ) {

    if( this -> dwFlags & PSH_PROPSHEETPAGE ) {
        LPPROPSHEETPAGE ppsp = const_cast<LPPROPSHEETPAGE>( this -> ppsp );
        delete [] ppsp;
        this -> ppsp = NULL;
    }
    else {
        delete [] const_cast<HPROPSHEETPAGE FAR *>( this -> phpage );
        this -> phpage = NULL;
    }

    this -> nPages = 0;
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\nmrk\pshthdr.h ===
////////////////////////////////////////////////////////////////////////////////////////////////////
// CPropertySHeetHeader is a wrapper class around the PROPSHEETHEADER structure
//  this class mostly does data validation. The operator[] and Iterator member class allows for
//  pretty syntax.  Hopefully the prettyness outweighs the confusion... 
//
//
// 	CPropertySheetHeader		MyPropSheetHeader( 2,                             // NumPropShtPages
//                                                 PSH_PROPSHEETPAGE | PSH_WIZARD // Flags
//                                                );            
//                                                 
//
//
//  CPropertySheetPage MyPropertySheetPage( 
//                                          IDD_PROPPAGE_TEMPLATE, 
//                                          ( DLGPROC ) MyDlgProc, 
//                                          PSP_HASHELP   
//                                        );
//  extern PROPSHEETPAGE OtherPage;        
//
//  MyPropSheetHeader[ 0 ] = MyPropertySheetPage;
//  MyPropSheetHeader[ 1 ] = OtherPage;
//
//
////////////////////////////////////////////////////////////////////////////////////////////////////

#ifndef __PhtHdr_h__
#define __PhtHdr_h__


////////////////////////////////////////////////////////////////////////////////////////////////////
// Include files

#include "PropPg.h"



////////////////////////////////////////////////////////////////////////////////////////////////////
// Comment this if you do not want parameter validation ( class would do essentially nothing )
//
#define CPropertySheetHeader_ValidateParameters
////////////////////////////////////////////////////////////////////////////////////////////////////


////////////////////////////////////////////////////////////////////////////////////////////////////
// Property Sheet Header


class CPropertySheetHeader : public PROPSHEETHEADER {

        // Forward declarations and friend declarations
    class CPropertySheetPageDataIterator;
    friend CPropertySheetPageDataIterator;

private: // DATATYPES

        ///////////////////////////////////////////////////////////////////////////////////////////
        // CPropertySheetPageDataIterator is for getting at a PROPSHEETPAGE in the ppsp member
        //      array of a PROPSHEETHEADER
    class CPropertySheetPageDataIterator {
            // Forward Decls and Friend decls
        friend CPropertySheetHeader;

    private:    // DATA
        UINT                m_Index;
        PROPSHEETHEADER    *m_pPsh;

    private:    // Construction / destruction
            // This may only be created by CPropertySheetHeader
        CPropertySheetPageDataIterator( UINT index, PROPSHEETHEADER* pPsh ) 
            : m_Index( index ), m_pPsh( pPsh ) { ; }

    public:     
        ~CPropertySheetPageDataIterator( void ) { ; }

    public: // Public Member Fns
        void operator=( LPCPROPSHEETPAGE p ) { 
            assert( m_pPsh -> dwFlags & PSH_PROPSHEETPAGE );    // We only handle this case now
            const_cast< LPPROPSHEETPAGE >( m_pPsh -> ppsp )[ m_Index ] = *p; 
        }
        void operator=( HPROPSHEETPAGE FAR * p ) {
            assert( !( m_pPsh -> dwFlags & PSH_PROPSHEETPAGE ) ); // We only handle this case now
            m_pPsh -> phpage[ m_Index ] = *p; 
        }
    private:    // UNUSED
        CPropertySheetPageDataIterator( void );
        CPropertySheetPageDataIterator( const CPropertySheetPageDataIterator& r );
    };


public:  // symbol classes for signature disambiguation...
    class UsePropertySheetArray{ ; };
    class UsePropertySheetHandleArray{ ; };

public: // Construction / destruction
	CPropertySheetHeader( void ); 	
	CPropertySheetHeader( LPCPROPSHEETPAGE pPageVector, int nPages, PFNPROPSHEETCALLBACK pfnCallback = NULL );
	CPropertySheetHeader( int nPages, UsePropertySheetArray dummy, PFNPROPSHEETCALLBACK pfnCallback = NULL );
	CPropertySheetHeader( int nPages, DWORD dwFlags, PFNPROPSHEETCALLBACK pfnCallback = NULL );
    CPropertySheetHeader( int nPages, UsePropertySheetHandleArray dummy, PFNPROPSHEETCALLBACK pfnCallback = NULL );
	~CPropertySheetHeader( void );

        // Methods and operators
    CPropertySheetPageDataIterator operator[]( int index );
	void SetParent( HWND hWndParent ) { _Set_hwndParent( hWndParent ); }
	
		// Conversion operator
    operator LPPROPSHEETHEADER() { return this; }

private: // Helper Fns
    BOOL _InitData( void );
    BOOL _Validate( void );
    BOOL _Set_hwndParent( HWND hwndParent );
    BOOL _Set_hInstance( HINSTANCE hInstance );
    BOOL _Set_hIcon( HICON hIcon );
    BOOL _Set_pszIcon( LPCTSTR pszIcon );  
    BOOL _Set_pszCaption( LPCTSTR pszCaption );
    BOOL _Set_nStartPage( UINT nStartPage );
    BOOL _Set_pStartPage( LPCTSTR pStartPage );
    BOOL _Set_ppsp( LPCPROPSHEETPAGE ppsp, UINT nPages );
    BOOL _Set_phpage( HPROPSHEETPAGE FAR phpage, UINT nPages );
    BOOL _Set_pfnCallback( PFNPROPSHEETCALLBACK pfnCallback );
    BOOL _DeletePageData( void );

private: // UNUSED
	CPropertySheetHeader( const CPropertySheetHeader& r );
 	CPropertySheetHeader& operator=( const CPropertySheetHeader& r );
};

#endif // __PhtHdr_h__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\nmrk\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by nmrk.rc
//
#define IDS_NOT_ENOUGH_SPACE_IN_FINAL   51
#define IDS_REMOVE_SERVER               52
#define IDS_EMPTY_SERVER                53
#define IDS_NMAKWIZ_ERROR_CAPTION       54
#define IDS_CANT_FIND_NETMEETING_ORIGINAL_DISTRIBUTION 55
#define IDS_CANT_FIND_NETMEETING_ORIGINAL_DISTRIBUTION_QUERY_ABORT 56
#define IDS_ERROR_MUST_SELECT_DISTRIBUTION_FOLDER 57
#define IDS_DLG_TITLE_SELECT_ROOT_FOLDER_FOR_DISTRIBUTION 58
#define IDC_SETTINGS_FILE               59
#define IDS_EDIT_WEBVIEW                59
#define IDE_SETTINGS_FILE               60
#define IDS_ERROR_NEEDALLFIELDS         60
#define IDC_BROWSE_SETTINGS_FILE        61
#define IDS_DEFAULT_WEBVIEW             61
#define IDS_NMAKWIZ_ERROR_NMRK_MUST_BE_PROPERLY_INSTALLED 62
#define IDS_NMAKWIZ_ERROR_PLEASE_REINSTALL_NET_MEETING_RESOURCE_KIT 63
#define IDS_SELECTED_PATH_DISTRO_IS_INVALID_PLEASE_CHANGE_THE_PATH_NAME_OR_BROWSE_FOR_A_NEW_PATH 64
#define IDS_YOU_DO_NOT_HAVE_WRITE_ACCESS_TO_THE_SELECTED_DISTRO_PATH_PLEASE_SELECT_A_PATH_IN_WHICH_YOU_HAVE_WRITE_PERMISSION 65
#define IDS_DO_YOU_REALLY_WANT_TO_QUIT_THE_WIZARD_NOW 66
#define IDS_MSG_CAPTION 67
#define IDS_REINSTALL_THE_NETMEETING_RESOURCE_KIT_AND_TRY_AGAIN 68
#define IDS_COULD_NOT_FIND_THE_TOOL     69
#define IDS_SUCCESSFULLY_CREATED        70
#define IDS_THERE_WAS_AN_UNEXPECTED_ERROR 71
#define IDS_DELETING_TEMPORARY_FILES_PROGRESS_TITLE 72
#define IDS_CREATING_CUSTOM_DISTRIBUTION 73
#define IDS_YOU_MUST_SELECT_AT_LEAST_ONE_DISTRIBUTION_TYPE 74
#define IDS_YOU_MUST_ENTER_AT_LEAST_ONE_DIRECTORY_SERVER 75
#define IDS_AUDIO_VIDEO_THROUGHPUT_VALUE_IS_INVALID 76
#define IDS_INVALID_DATA_ERROR          77
#define IDS_KBPS                        82
#define IDS_NMAKWIZ_VERIFY_CAPTION      83
#define IDS_SELECTED_PATH_HAS_TOO_MANY_CHARACTERS 86
#define IDS_NETMEETING_HOMEPAGE_IS_INVALID 87
#define IDS_GATEKEEPER_SERVER_IS_INVALID 88

#define IDD_PROPPAGE_DEFAULT            100
#define IDD_PROPPAGE_WELCOME            101
#define IDD_CHILDPAGE_ILSGATEWAY        102
#define IDD_CHILDPAGE_GATEKEEPER        103
#define IDD_FILEPANE_INTRO              104
#define IDD_FILEPANE_SUMMARY            105
#define IDD_FILEPANE_DISTRO             106
#define IDD_FILEPANE_AUTOCONF           107
#define IDD_FILEPANE_SETTINGS           108

#define IDS_FT_THROUGHPUT_VALUE_IS_INVALID 119
#define IDS_SHOW_ONLINE_SUPPORT_PAGE    120
#define IDS_MUST_ENTER_DISTRONAME       121
#define IDS_CREATE_AUTOCONF_DIRECTORY   122
#define IDS_NOT_ENOUGH_SPACE_IN_TEMP_DIR 123
#define IDS_CREATE_DIRECTORY            124
#define IDS_SELECTED_PATH_IS_INVALID_PLEASE_CHANGE_THE_PATH_NAME_OR_BROWSE_FOR_A_NEW_PATH 125
#define IDS_YOU_DO_NOT_HAVE_WRITE_ACCESS_TO_THE_SELECTED_PATH_PLEASE_SELECT_A_PATH_IN_WHICH_YOU_HAVE_WRITE_PERMISSION 126
#define IDS_MUST_ENTER_AUTOCONF_NAME    127
#define IDS_AUTHSERVER_URL              129
#define IDS_CAPTION_AUTHSERVER_URL      130
#define IDS_AUTHENTICATION_URL_IS_INVALID 131
#define IDS_NEED_CONF_SERVER            132
#define IDS_TURNING_OFF_AUTOCONF        133
#define IDS_ERASE_ALL_SETTINGS          134
#define IDS_WEBDIR_AUTOADD              135
#define IDS_DSLIST_EMPTY                136
#define IDS_DS_WILL_BE_EMPTY            137
#define IDS_DSNAME_INVALID              138
#define IDS_ARE_YOU_SURE_YOU_WISH_TO_REMOVE 139
#define IDS_VERIFY                      140
#define IDD_DIALOG_EDIT_SERVERNAME      150
#define IDI_ICON2                       153
#define IDD_FILETRANSFER                168
#define IDD_CATEGORY_LIST               169
#define IDD_AUDIO                       171
#define IDD_VIDEO                       172
#define IDD_SECURITY                    173
#define IDD_RDS                         174
#define IDD_CHAT                        175
#define IDD_WHITEBOARD                  176
#define IDD_ONLINE_SUPPORT              180
#define IDD_OPTIONS_DIALOG              181
#define IDC_DISABLE_AUTOACCEPT          182
#define IDC_DISABLE_WEBDIR              183
#define IDC_DISABLE_WEBDIR_GK           184
#define IDD_LIMIT_AV_THROUGHPUT         185
#define IDC_PERSIST_AUTOACCEPT          186
#define IDD_SHARING                     197
#define IDB_BITMAP1                     215
#define IDD_SET_CALLING_OPTIONS         219
#define IDD_DIALOG_EDIT_WEBVIEW         220
#define IDC_CHECK_CREATE_DISTRIBUTION   1005
#define IDC_PREVENT_THE_USER_FROM_SENDING_FILES 1006
#define IDC_RESTRICT_THE_USE_OF_FILE_TRANSFER 1007
#define IDC_PREVENT_THE_USER_FROM_USING_AUDIO 1008
#define IDC_DISABLE_SENDING_VIDEO       1009
#define IDC_CHECK_AUTOCONFIG_CLIENTS    1011
#define IDC_PREVENT_THE_USER_FROM_RECEIVING_FILES 1012
#define IDC_RESTRICT_THE_USE_OF_SHARING 1013
#define IDC_RESTRICT_THE_USE_OF_RDS     1014
#define IDC_DISABLE_RECIEVING_VIDEO     1015
#define IDC_DISABLE_RDS_ON_ALL          1016
#define IDC_DISABLE_RDS_ON_WIN9X        1017
#define IDC_MAXIMUM_SIZE_OF_SENT_FILES  1018
#define IDC_RESTRICT_THE_USE_OF_AUDIO   1019
#define IDC_ENABLE_DIRECT_SOUND         1020
#define IDC_DISABLE_FULL_DUPLEX_AUDIO   1021
#define IDC_CREATE_AN_AUDIO_LOG_FILE    1022
#define IDC_DISABLE_ALL_SHARING_FEATURES    1023
#define IDC_PREVENT_SHARING             1024
#define IDC_PREVENT_SHARING_DESKTOP     1025
#define IDC_PREVENT_SHARING_EXPLORER    1026
#define IDC_PREVENT_SHARING_DOS         1027
#define IDC_PREVENT_SHARING_CONTROL     1028
#define IDC_PREVENT_SHARING_TRUECOLOR   1029
#define IDC_RESTRICT_THE_USE_OF_WHITEBOARD  1030
#define IDC_DISABLE_2XWHITEBOARD        1031
#define IDC_DISABLE_WHITEBOARD          1032
#define IDC_NOCHANGE_DIRECT_SOUND       1033
#define IDC_EDIT_DISTRIBUTION_FILE_PATH 1044
#define IDC_EDIT_AUTO_CONFIG_FILE_PATH  1046
#define IDC_STATIC_DISTRIBUTION_FILE_PATH_EDIT_CAPTION 1047
#define IDC_AUTO_CONFIG_FILE_PATH_EDIT_CAPTION 1049
#define IDC_AUTO_CONFIG_FILE_PATH_EDIT_CAPTION2 1050
#define IDC_BUTTON_BROWSE_DISTRIBUTION_FILE_PATH 1053
#define IDC_BUTTON_BROWSE_AUTO_CONFIG_PATH 1055
#define IDC_BUTTON_UP                   1057
#define IDC_BUTTON_ADDDIRECTORYSERVER   1059
#define IDC_BUTTON_EDIT                 1061
#define IDC_EDIT_SERVER_NAME            1062
#define IDC_BUTTON_REMOVE               1063
#define IDC_EDIT_DISPLAY_NAME           1063
#define IDC_EDIT_URL_NAME               1064
#define IDC_BUTTON_DOWN                 1065
#define IDC_BUTTON_SET_AS_DEFAULT       1067
#define IDC_RADIO_LOAD_SAVED_CONFIG     1068
#define IDC_RADIO_START_FROM_SCRATCH    1069
#define IDE_SAVED_CONFIG_FILE           1070
#define IDC_BROWSE_CONFIG_FILE          1071
#define IDC_STATIC2                     1072
#define IDC_STATIC3                     1073
#define IDC_EDIT_MAXIMUM_SIZE_OF_SENT_FILES 1074
#define IDC_STATIC1                     1075
#define IDC_RESTRICT_THE_USE_OF_VIDEO   1076
#define IDC_SET_SECURITY_OPTIONS        1077

#define IDC_RADIO_SECURITY_FIRST        1078
#define IDC_RADIO_SECURITY_DEFAULT      (IDC_RADIO_SECURITY_FIRST)
#define IDC_RADIO_SECURITY_REQUIRED     (IDC_RADIO_SECURITY_FIRST+1)
#define IDC_RADIO_SECURITY_DISABLED     (IDC_RADIO_SECURITY_FIRST+2)
#define IDC_RADIO_SECURITY_MAX          (IDC_RADIO_SECURITY_FIRST+3)

#define IDC_STATIC4                     1089
#define IDC_PREVENT_THE_USER_FROM_ADDING_NEW_SERVERS 1090
#define IDC_RESTRICT_THE_USE_OF_DIRECTORY_SERVICES 1091
#define IDC_DISABLE_CHAT                1092
#define IDC_SET_URL_FOR_INTERNAL_SUPPORT_PAGE 1094
#define IDC_EDIT_SET_URL_FOR_INTERNAL_SUPPORT_PAGE 1095
#define IDC_SHOW_THE_ONLINE_SUPPORT_PAGE_THE_FIRST_TIME_NETMEETING_STARTS 1096
#define IDC_ONLINE_SUPPORT              1097
#define IDC_DISABLE_THE_GENERAL_OPTIONS_PAGE 1098
#define IDC_DISABLE_THE_SECURITY_OPTIONS_PAGE 1099
#define IDC_DISABLE_THE_AUDIO_OPTIONS_PAGE 1100
#define IDC_DISABLE_THE_VIDEO_OPTIONS_PAGE 1101
#define IDC_DISABLE_THE_ADVANCED_CALLING_BUTTON    1102
#define IDC_RESTRICT_USE_OF_THE_OPTIONS_DIALOG 1104
#define IDC_SET_CALLING_OPTIONS         1109
#define IDC_SLIDE_AV_THROUGHPUT         1114
#define IDC_STATIC_MAX_AV_THROUGHPUT    1115
#define IDC_LIMIT_AV_THROUGHPUT         1116
#define IDC_LIST_SETTINGS               1117
#define IDC_CREATE_CONFIGURATION_SUMMARY_FILE 1118
#define IDC_CONFIGURATION_SUMMARY_PATH  1119
#define IDC_BROWSE_CONFIGURATION_SUMMARY 1120
#define IDC_EDIT_NEW_SERVER             1122
#define IDC_LIST_SERVERS                1123
#define IDC_AUTOCONF_URL                1124

// These are RADIO items, keep contiguous
#define IDC_RADIO_NETSPEED_FIRST        1125
#define IDC_RADIO_NETSPEED_144          (IDC_RADIO_NETSPEED_FIRST)
#define IDC_RADIO_NETSPEED_288          (IDC_RADIO_NETSPEED_FIRST+1)
#define IDC_RADIO_NETSPEED_ISDN         (IDC_RADIO_NETSPEED_FIRST+2)
#define IDC_RADIO_NETSPEED_LAN          (IDC_RADIO_NETSPEED_FIRST+3)
#define IDC_RADIO_NETSPEED_MAX          (IDC_RADIO_NETSPEED_FIRST+4)

#define IDC_NETWORK_SPEED               1132

// These are RADIO items, keep contiguous
#define IDC_RADIO_GKMODE_FIRST          1140
#define IDC_RADIO_GKMODE_PHONE          (IDC_RADIO_GKMODE_FIRST)
#define IDC_RADIO_GKMODE_ACCOUNT        (IDC_RADIO_GKMODE_FIRST+1)
#define IDC_RADIO_GKMODE_BOTH           (IDC_RADIO_GKMODE_FIRST+2)
#define IDC_RADIO_GKMODE_MAX            (IDC_RADIO_GKMODE_FIRST+3)

#define IDC_DROP_NAME                   1149
#define IDC_DROP_EMAIL                  1150
#define IDC_DROP_PHONENUM               1151
#define IDC_DROP_LOCATION               1152
#define IDC_DROP_COMMENTS               1153
#define IDC_DROP_SURNAME                1154
#define IDC_ALLOW_USER_TO_USE_DIRECTORY_SERVICES 1160
#define IDC_STATIC_NAME                 1163
#define IDC_STATIC_SUR_NAME             1164
#define IDC_STATIC_EMAIL                1165
#define IDC_STATIC_LOCATION             1166
#define IDC_STATIC_PHONENUM             1167
#define IDC_STATIC_COMMENTS             1168
#define IDC_DROP_VALUES                 1171

// These are RADIO items, keep continugous
#define IDC_RADIO_CALLMODE_FIRST              1172
#define IDC_RADIO_CALLMODE_DIRECT             (IDC_RADIO_CALLMODE_FIRST)
#define IDC_RADIO_CALLMODE_GATEKEEPER         (IDC_RADIO_CALLMODE_FIRST+1)
#define IDC_RADIO_CALLMODE_MAX                (IDC_RADIO_CALLMODE_FIRST+2)

#define IDC_CHECK_GATEKEEPER            1180
#define IDC_EDIT_GATEKEEPER             1181
#define IDC_CHECK_GATEWAY               1182
#define IDC_EDIT_GATEWAY                1183

#define IDC_CHECK_NOCHANGECALLMODE            1187
#define IDC_CHECK_MUTE_SPEAKER_BY_DEFAULT 1190
#define IDC_CHECK_MUTE_MICROPHONE_BY_DEFAULT 1191
#define IDC_REQUIRE_COMPLETE_AUTHENTICATION 1192
#define IDC_SET_RDN_FOR_REQUIRED_CA 1193
#define IDC_EDIT_SET_RDN_FOR_REQUIRED_CA 1194
#define IDC_BUTTON_SET_WEBVIEW          1195

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NO_MFC                     1
#define _APS_NEXT_RESOURCE_VALUE        220
#define _APS_NEXT_COMMAND_VALUE         40002
#define _APS_NEXT_CONTROL_VALUE         1195
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\nmrk\setinsht.h ===
#ifndef __SetInSht_h__
#define __SetInSht_h__

#include "filepane.h"

class CIntroSheet
{
friend class CNmAkWiz;
    
private:
    static BOOL APIENTRY DlgProc( HWND hDlg, UINT message, WPARAM uParam, LPARAM lParam );
    static CIntroSheet* ms_pIntroSheet;

    CFilePanePropWnd2 *         m_pFilePane;
    CPropertySheetPage          m_PropertySheetPage;
	BOOL				        m_bBeenToNext;

public: 
    CIntroSheet(void);
    ~CIntroSheet(void);
    void                _CreateFilePane(HWND hDlg);
    CFilePanePropWnd2 * GetFilePane() { return m_pFilePane; }

private:
    LPCPROPSHEETPAGE    GetPropertySheet( void ) const { return &m_PropertySheetPage;}
};

#endif // __SetInSht_h__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\nmrk\setinsht.cpp ===
#include "precomp.h"
#include "resource.h"
#include "global.h"
#include "PropPg.h"
#include "SetInSht.h"
#include "nmakwiz.h"
#include "nmakreg.h"


////////////////////////////////////////////////////////////////////////////////////////////////////
// Static member vars
CIntroSheet* CIntroSheet::ms_pIntroSheet = NULL;


CIntroSheet::CIntroSheet( void ) :
    m_PropertySheetPage( MAKEINTRESOURCE( IDD_PROPPAGE_DEFAULT ), 
						(DLGPROC) CIntroSheet::DlgProc
                       ),
    m_bBeenToNext( FALSE ),
    m_pFilePane(NULL)
{    
    ms_pIntroSheet = this;
}


CIntroSheet::~CIntroSheet(void) 
{
    delete m_pFilePane;
    m_pFilePane = NULL;

    ms_pIntroSheet = NULL;
}



////////////////////////////////////////////////////////////////////////////////////////////////////
// Static member fns

BOOL APIENTRY CIntroSheet::DlgProc( HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam ) {

    switch( message )
    {
		case WM_INITDIALOG:
        {
			PropSheet_SetWizButtons( GetParent( hDlg ), PSWIZB_NEXT | PSWIZB_BACK );
            ms_pIntroSheet->_CreateFilePane(hDlg);
			return TRUE;

        }

		case WM_NOTIFY:
        {
			switch( reinterpret_cast< NMHDR FAR* >( lParam )->code )
            {
				case PSN_QUERYCANCEL: 
					SetWindowLong( hDlg, DWL_MSGRESULT, !VerifyExitMessageBox());
                    return TRUE;

                case PSN_SETACTIVE:
                    g_hwndActive = hDlg;
                	PropSheet_SetWizButtons( GetParent( hDlg ), PSWIZB_NEXT | PSWIZB_BACK );
                    ms_pIntroSheet->m_pFilePane->Validate(FALSE);
			        return TRUE;

				case PSN_WIZNEXT:
                    if (!ms_pIntroSheet->m_pFilePane->Validate(TRUE))
                    {
                        SetWindowLong(hDlg, DWL_MSGRESULT, -1);
                        return TRUE;
                    }

					if (ms_pIntroSheet->m_bBeenToNext)
					{
						g_pWiz->m_SettingsSheet.PrepSettings();
                        g_pWiz->m_CallModeSheet.PrepSettings();
					}

					ms_pIntroSheet->m_bBeenToNext = TRUE;
                    break;
			}
            break;
        }

        default:
            break;
	}

	return FALSE;
}



//
// _CreateFilePane()
//
void CIntroSheet::_CreateFilePane(HWND hDlg)
{
    RECT    rect;

    GetClientRect(hDlg, &rect);
    int iHeight = rect.bottom - rect.top;
    int iWidth = rect.right - CPropertyDataWindow2::mcs_iLeft;

    m_pFilePane = new CFilePanePropWnd2(hDlg, IDD_FILEPANE_INTRO,
        TEXT("IDD_FILEPANE_INTRO"), 0, CPropertyDataWindow2::mcs_iLeft,
        CPropertyDataWindow2::mcs_iTop, iWidth, iHeight);

    HWND hwndCond = GetDlgItem(m_pFilePane->GetHwnd(), IDC_RADIO_LOAD_SAVED_CONFIG);
    m_pFilePane->ConnectControlsToCheck(IDC_RADIO_LOAD_SAVED_CONFIG, 2,
            new CControlID(hwndCond, IDC_RADIO_LOAD_SAVED_CONFIG,
                    IDE_SAVED_CONFIG_FILE,
                    CControlID::EDIT),
            new CControlID(hwndCond, IDC_RADIO_LOAD_SAVED_CONFIG,
                    IDC_BROWSE_CONFIG_FILE,
                    CControlID::CHECK));

    m_pFilePane->SetFilePane(TRUE, IDE_SAVED_CONFIG_FILE,
        IDC_RADIO_LOAD_SAVED_CONFIG, IDC_BROWSE_CONFIG_FILE,
        TEXT("Configuration File (*.ini)"),
        TEXT(".ini"), TEXT("Nm3c.ini"));

    //
    // Get last edited/saved config from registry
    //
    HKEY    hKey;
    TCHAR   szFile[MAX_PATH];

    szFile[0] = 0;

    if (RegOpenKey(HKEY_LOCAL_MACHINE, REGKEY_NMRK, &hKey) == ERROR_SUCCESS)
    {
        DWORD   dwType;
        DWORD   cb;

        dwType  = REG_SZ;
        cb      = sizeof(szFile);

        RegQueryValueEx(hKey, REGVAL_LASTCONFIG, NULL, &dwType, (LPBYTE)szFile,
            &cb);
    }

    Edit_SetText(GetDlgItem(m_pFilePane->GetHwnd(), IDE_SAVED_CONFIG_FILE), szFile);
    m_pFilePane->ShowWindow(TRUE);
    m_pFilePane->SetCheck(IDC_RADIO_START_FROM_SCRATCH, TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\nmrk\util.cpp ===
#include "precomp.h"
#include "util.h"


void ErrorMessage( void ) {
    ErrorMessage( "", GetLastError() );
}

void ErrorMessage( LPCTSTR str, HRESULT hr ) {

#ifdef _DEBUG

	void* pMsgBuf;

	::FormatMessage( 
		FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM,
		NULL,
		hr,
		MAKELANGID( LANG_NEUTRAL, SUBLANG_DEFAULT ),
		(LPTSTR ) &pMsgBuf,
		0,
		NULL
	);

	OutputDebugString( str );
	if( NULL != pMsgBuf ) {
		OutputDebugString( (LPTSTR ) pMsgBuf );
	}

	LocalFree( pMsgBuf );
#endif _DEBUG
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\nmrk\setsht.h ===
#ifndef __SetSht_h__
#define __SetSht_h__

////////////////////////////////////////////////////////////////////////////////////////////////////

//#pragma warning( disable : 4786 )
#include <map>
using namespace std;
#include "PropWnd2.h"


////////////////////////////////////////////////////////////////////////////////////////////////////

class CSettingsSheet {
 
private:
		// Static Data
    static CSettingsSheet* ms_pSettingsSheet;

    static map< UINT, CPropertyDataWindow2* > ms_PropertyWindows;
	static map< UINT, HWND >				  ms_FocusList;
	static list< UINT > ms_CategoryIDList;
		
		// Static fns
    static BOOL APIENTRY DlgProc( HWND hDlg, UINT message, WPARAM uParam, LPARAM lParam );


private: // DATA
    CPropertySheetPage		m_PropertySheetPage;
	CPropertyDataWindow2*	m_pCategoryList;
    HWND                    m_hWndDlg;
	UINT					m_uPropWndShowing;

public: 
    CSettingsSheet( void );
    ~CSettingsSheet( void );

    LPCPROPSHEETPAGE GetPropertySheet( void ) const { return &m_PropertySheetPage;}

	inline CPropertyDataWindow2* GetPropWnd( UINT idCategory ) { return ms_PropertyWindows[ idCategory ]; }
	inline HWND GetHwnd( UINT idCategory ) const { return ms_PropertyWindows[ idCategory ] -> GetHwnd(); }
	LPTSTR GetStringData( UINT idCategory, UINT idEdit, LPTSTR* sz );

	inline CPropertyDataWindow2* GetCatWnd() { return m_pCategoryList; }
	inline BOOL GetCategoryCheck( UINT idCategory ) { return m_pCategoryList -> GetCheck( idCategory ); }
	inline void SetCategoryCheck( UINT idCategory, BOOL bSet ) { m_pCategoryList -> SetCheck( idCategory, bSet ); }

	BOOL GetCheckData( UINT idCategory, UINT idCheck );
	BOOL SetCheckData( UINT idCategory, UINT idCheck, BOOL bSet );

	void EnableWindow( UINT idCategory, BOOL bShow );
	BOOL IsShowing( UINT idCategory );
	void ShowWindow( UINT idCategory, BOOL bShow );
	void ShowWindow( HWND hWnd, BOOL bShow );

	void PrepSettings(void);
	void WriteSettings( void );

	void WriteToINF( HANDLE hFile );

	int SpewToListBox( HWND hwndList, int iStartLine ) ;
	void SetFocus( UINT catID );
	
	static bool IsGateKeeperModeSelected(void);

private:
	void _KillPropertyDataWindows( void );
	BOOL _InitWindows( void );
	BOOL _AddPropertyDataWindows( int iX, int iY, int iWidth, int iHeight );
	BOOL _IsDataValid( void );
	void _SetButtons( void );
	void _ReadSettings( void );
	BOOL _INFComment( HANDLE hFile, LPCTSTR sz );
};
#endif // __SetSht_h__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\nmrk\setsht.cpp ===
#include "precomp.h"
#include "resource.h"
#include <algorithm>
#include "global.h"
#include "PropPg.h"
#include "SetSht.h"
#include "WndProcs.h"
#include "nmakwiz.h"
#include "nmakreg.h"
#include <common.h>

////////////////////////////////////////////////////////////////////////////////////////////////////
// Static member vars
CSettingsSheet* CSettingsSheet::ms_pSettingsSheet = NULL;

// This is a map to keep track of the PropertyDataWindows
/* static */ map<UINT, HWND> CSettingsSheet::ms_FocusList;
/* static */ map< UINT, CPropertyDataWindow2* > CSettingsSheet::ms_PropertyWindows;
/* static */ list< UINT > CSettingsSheet::ms_CategoryIDList;

////////////////////////////////////////////////////////////////////////////////////////////////////
// Static member fns


/* static */ BOOL APIENTRY CSettingsSheet::DlgProc( HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam ) {

    BOOL bRetval;
    NMHDR FAR* pnmhdr;
    
    switch( message ) {
        case WM_INITDIALOG:
            ms_pSettingsSheet->m_hWndDlg = hDlg;
            ms_pSettingsSheet->_InitWindows();
            ms_pSettingsSheet->PrepSettings();
            ms_pSettingsSheet->_SetButtons();
            return TRUE;

        case WM_CHAR:
        case WM_KEYDOWN:
            return FALSE;

        case WM_NOTIFY:
            pnmhdr = reinterpret_cast< NMHDR FAR* >( lParam ); 
            switch( pnmhdr -> code ) {

                case PSN_QUERYCANCEL: 
                    SetWindowLong( hDlg, DWL_MSGRESULT, !VerifyExitMessageBox());
                    return TRUE;
                    break;
                    
                case PSN_SETACTIVE:
                    g_hwndActive = hDlg;
                    ms_pSettingsSheet->_SetButtons();
                    return TRUE;
                    break;

                case PSN_WIZNEXT:
                    if( !ms_pSettingsSheet -> _IsDataValid() )
                    { 
                        SetWindowLong( hDlg, DWL_MSGRESULT, -1); 
                    }

                    return TRUE;
                    break;

                case PSN_WIZBACK:
                {
                    int iRet = NmrkMessageBox(MAKEINTRESOURCE(IDS_ERASE_ALL_SETTINGS),
                        NULL, MB_YESNO | MB_ICONQUESTION );
                    if( IDNO == iRet )
                    {
                        SetWindowLong( hDlg, DWL_MSGRESULT, -1 );
                    }
                    return TRUE;
                    break;
                }
             }
            break;

         default:
            break;

    }

    return FALSE;

}


/* static */ bool CSettingsSheet::IsGateKeeperModeSelected(void)
{
    bool bRet = false;
    
    if( ms_pSettingsSheet )
    {
        if( ms_pSettingsSheet->GetCategoryCheck( IDC_SET_CALLING_OPTIONS ) )
        {
            if( ms_pSettingsSheet->GetCheckData( IDC_SET_CALLING_OPTIONS, IDC_RADIO_CALLMODE_GATEKEEPER ) )
            {
                bRet = TRUE;
            }
        }
    }
        
    return bRet;

}

////////////////////////////////////////////////////////////////////////////////////////////////////
// Member fns


CSettingsSheet::CSettingsSheet( void )
    : m_PropertySheetPage( MAKEINTRESOURCE( IDD_PROPPAGE_DEFAULT ), 
                            ( DLGPROC ) CSettingsSheet::DlgProc ),
    m_uPropWndShowing( 0 )
{    
    if( NULL == ms_pSettingsSheet ) { ms_pSettingsSheet = this; }
}

CSettingsSheet::~CSettingsSheet( void ) 
{ 
    _KillPropertyDataWindows();
}

void CSettingsSheet::SetFocus( UINT catID )
{
    map< UINT, HWND >::iterator I = ms_FocusList.find( catID );
    if( I != ms_FocusList.end() )
    {
        ::SetFocus( (*I).second );
    }
}

// Allocates the memory needed!!!
// User must dealloc
LPTSTR CSettingsSheet::GetStringData( UINT idCategory, UINT idEdit, LPTSTR *sz ) 
{
    *sz = NULL;
    map< UINT, CPropertyDataWindow2* >::iterator I = ms_PropertyWindows . find( idCategory );
    if( ms_PropertyWindows . end() != I ) 
    {
        ULONG uLen = ( *I ) . second -> GetEditDataLen( idEdit );
        if( !uLen )
        {
            return NULL;
        }
        *sz = new TCHAR[ uLen + 1];
        ( *I ) . second -> GetEditData( idEdit, *sz, uLen + 1 );
        return *sz;
    }
    
    return NULL;
}

BOOL CSettingsSheet::SetCheckData( UINT idCategory, UINT idCheck, BOOL bSet )
{

    map< UINT, CPropertyDataWindow2* >::iterator I = ms_PropertyWindows . find( idCategory );
    if( ms_PropertyWindows . end() != I ) {
        ( *I ) . second -> SetCheck( idCheck, bSet );
        return TRUE;
    }

    return FALSE;
}

BOOL CSettingsSheet::GetCheckData( UINT idCategory, UINT idCheck ) 
{

    if( FALSE == m_pCategoryList -> GetCheck( idCategory ) ) {
        return FALSE;
    }
    map< UINT, CPropertyDataWindow2* >::iterator I = ms_PropertyWindows . find( idCategory );
    if( ms_PropertyWindows . end() != I ) {
        return ( *I ) . second -> GetCheck( idCheck );
    }

    return FALSE;
}

void CSettingsSheet::EnableWindow( UINT idCategory, BOOL bShow )
{
    map< UINT, CPropertyDataWindow2* >::iterator I = ms_PropertyWindows . find( idCategory );
    if( ms_PropertyWindows . end() != I ) {
        ( *I ) . second -> EnableWindow( bShow );
    }
    else
    {
        OutputDebugString( TEXT("Error in CSettingsSheet::EnableWindow") );
    }
}

BOOL CSettingsSheet::IsShowing( UINT idCategory )
{
    return( idCategory == m_uPropWndShowing );
}

void CSettingsSheet::ShowWindow( UINT idCategory, BOOL bShow )
{
    map< UINT, CPropertyDataWindow2* >::iterator I = ms_PropertyWindows . find( idCategory );
    if( ms_PropertyWindows . end() != I ) {
        if( 0 != m_uPropWndShowing )
        {
            map< UINT, CPropertyDataWindow2* >::iterator it = ms_PropertyWindows . find( m_uPropWndShowing );
            (*it).second-> ShowWindow( FALSE );
            SetWindowLong( GetDlgItem( m_pCategoryList->GetHwnd(), m_uPropWndShowing), GWL_USERDATA, 0 );
        }
        ( *I ) . second -> ShowWindow( bShow );
        m_uPropWndShowing = idCategory;
    }
}

void CSettingsSheet::ShowWindow( HWND hWnd, BOOL bShow )
{
    ShowWindow( GetWindowLong( hWnd, GWL_ID ), bShow );
}

void CSettingsSheet::_KillPropertyDataWindows( void ) 
{
    map< UINT, CPropertyDataWindow2* >::iterator I = ms_PropertyWindows . begin();
    while( I != ms_PropertyWindows . end() ) {
        delete ( *I ) . second;
        I++;
    }

    ms_PropertyWindows . erase( ms_PropertyWindows . begin(), ms_PropertyWindows . end() );

    // TODO - This is being deleted else where... I should find where
//    delete m_pCategoryList;
}

BOOL CSettingsSheet::_InitWindows(void) 
{
    int iTotal = 9;
    int iFractionTop = 4;
    RECT rect;
    GetClientRect( m_hWndDlg, &rect );
    int iWidth = rect.right - CPropertyDataWindow2::mcs_iLeft - 
        CPropertyDataWindow2::mcs_iBorder;
    int iHeight = MulDiv( (rect.bottom - CPropertyDataWindow2::mcs_iBorder ), iFractionTop, iTotal );
    m_pCategoryList = new CPropertyDataWindow2( m_hWndDlg,
                                                IDD_CATEGORY_LIST,
                                                TEXT("IDD_CATEGORY_LIST"),
                                                CatListWndProc,
                                                0,
                                                CPropertyDataWindow2::mcs_iLeft,
                                                CPropertyDataWindow2::mcs_iTop, 
                                                iWidth,
                                                iHeight
                                               );
    m_pCategoryList -> ShowWindow( TRUE );
    if( !_AddPropertyDataWindows( CPropertyDataWindow2::mcs_iLeft,
                                    CPropertyDataWindow2::mcs_iTop + iHeight + CPropertyDataWindow2::mcs_iBorder,
                                    iWidth,
                                    MulDiv( (rect.bottom - CPropertyDataWindow2::mcs_iBorder ), iTotal - iFractionTop, iTotal ) ) ) 
    { 
        return FALSE; 
    }
  
    return TRUE;
}

void CSettingsSheet::PrepSettings()
{
	if (g_pWiz->m_IntroSheet.GetFilePane()->OptionEnabled())
    {
        _ReadSettings();
    }
    else
    {
        m_pCategoryList->Reset();
        for( map< UINT, CPropertyDataWindow2* >::const_iterator it = ms_PropertyWindows.begin();
        it != ms_PropertyWindows.end();
        it++ )
        {
            (*it).second->Reset();
        }
    }
}

void CSettingsSheet::_ReadSettings()
{
    for( map< UINT, CPropertyDataWindow2* >::const_iterator it = ms_PropertyWindows.begin();
        it != ms_PropertyWindows.end();
        it++ )
    {
        (*it).second->ReadSettings();
    }
    
    m_pCategoryList->ReadSettings();

    for( list< UINT >::const_iterator i = ms_CategoryIDList.begin();
        i != ms_CategoryIDList.end();
        i++ )
    {
        if( GetCategoryCheck( *i ) )
        {
            ms_PropertyWindows[ *i ]->EnableWindow( TRUE );
        }
    }
}


void CSettingsSheet::WriteSettings()
{
    for( map< UINT, CPropertyDataWindow2* >::const_iterator it = ms_PropertyWindows.begin();
        it != ms_PropertyWindows.end();
        it++ )
    {
        (*it).second->WriteSettings();
    }
    
    m_pCategoryList->WriteSettings();
}

void CSettingsSheet::WriteToINF( HANDLE hFile )
{
    CPropertyDataWindow2::MapControlsToRegKeys();

    _INFComment( hFile, TEXT("Categories") );
    m_pCategoryList->WriteToINF( hFile, TRUE );

    for( map< UINT, CPropertyDataWindow2* >::const_iterator it = ms_PropertyWindows.begin();
        it != ms_PropertyWindows.end();
        it++ )
    {
        {
            HWND hwnd = GetDlgItem( m_pCategoryList->GetHwnd(), (*it).first );
            int iLen = Button_GetTextLength( hwnd ) + 1;
            LPTSTR szButtonText = new TCHAR[ iLen ];
            Button_GetText( hwnd, szButtonText, iLen );

            _INFComment( hFile, szButtonText );

            delete [] szButtonText;
        }

        (*it).second->WriteToINF( hFile, GetCategoryCheck( (*it).first ) );
    }
}

BOOL CSettingsSheet::_INFComment( HANDLE hFile, LPCTSTR sz )
{
#if _NMAKUSEINFCOMMENTS
    DWORD dwWritten;
    WriteFile( hFile, (void *)TEXT(";;"), lstrlen( TEXT(";;") ), &dwWritten, NULL );
    WriteFile( hFile, (void *)sz, lstrlen( sz ), &dwWritten, NULL );
    return WriteFile( hFile, (void *)TEXT("\r\n"), lstrlen( TEXT("\r\n") ), &dwWritten, NULL );
#else
    return 0;
#endif
}

BOOL CSettingsSheet::_AddPropertyDataWindows( int iX, int iY, int iWidth, int iHeight ) 
{

    UINT ItemID;
    CPropertyDataWindow2* pPropDataWnd;

    _KillPropertyDataWindows();

    //
    // CALLING
    //
////////
    ItemID = IDC_SET_CALLING_OPTIONS;
    m_pCategoryList->SetEnableListID( 1, ItemID );
    ms_CategoryIDList.push_front( ItemID );
    pPropDataWnd = new CPropertyDataWindow2( m_hWndDlg,
                                IDD_SET_CALLING_OPTIONS, TEXT("IDD_SET_CALLING_OPTIONS"),
                                0, iX, iY, iWidth, iHeight );
    {
        // Calling method radio buttons
        HWND hwnd;

        // DIRECT radio item is default CALLING_MODE
        hwnd = GetDlgItem( pPropDataWnd->GetHwnd(), IDC_RADIO_CALLMODE_DIRECT );
        SetWindowLong( hwnd, GWL_USERDATA, CALLING_MODE_DIRECT );
        Button_SetCheck(hwnd, BST_CHECKED);

        hwnd = GetDlgItem( pPropDataWnd->GetHwnd(), IDC_RADIO_CALLMODE_GATEKEEPER );
        SetWindowLong( hwnd, GWL_USERDATA, CALLING_MODE_GATEKEEPER );

        // Netspeed radio buttons
        hwnd = GetDlgItem( pPropDataWnd->GetHwnd(), IDC_RADIO_NETSPEED_144 );
        SetWindowLong( hwnd, GWL_USERDATA, BW_144KBS );

        hwnd = GetDlgItem( pPropDataWnd->GetHwnd(), IDC_RADIO_NETSPEED_288 );
        SetWindowLong( hwnd, GWL_USERDATA, BW_288KBS );

        hwnd = GetDlgItem( pPropDataWnd->GetHwnd(), IDC_RADIO_NETSPEED_ISDN );
        SetWindowLong( hwnd, GWL_USERDATA, BW_ISDN );

        // LAN radio item is default NETSPEED
        hwnd = GetDlgItem( pPropDataWnd->GetHwnd(), IDC_RADIO_NETSPEED_LAN );
        SetWindowLong( hwnd, GWL_USERDATA, BW_MOREKBS );
        Button_SetCheck(hwnd, BST_CHECKED);

        pPropDataWnd->SetEnableListID( 9,
                                       IDC_RADIO_CALLMODE_DIRECT,
                                       IDC_RADIO_CALLMODE_GATEKEEPER,
                                       IDC_CHECK_NOCHANGECALLMODE,
                                       IDC_DISABLE_AUTOACCEPT,
                                       IDC_PERSIST_AUTOACCEPT,
                                       IDC_RADIO_NETSPEED_144,
                                       IDC_RADIO_NETSPEED_288,
                                       IDC_RADIO_NETSPEED_ISDN,
                                       IDC_RADIO_NETSPEED_LAN);
    }

    ms_PropertyWindows[ ItemID ] = pPropDataWnd;
    ms_FocusList[ ItemID ] = GetDlgItem( pPropDataWnd->GetHwnd(), IDC_RADIO_CALLMODE_DIRECT );
    pPropDataWnd -> EnableWindow( FALSE );


////////
    ItemID = IDC_SET_SECURITY_OPTIONS;
    m_pCategoryList->SetEnableListID( 1, ItemID );
    ms_CategoryIDList.push_front( ItemID );
    pPropDataWnd = new CPropertyDataWindow2( m_hWndDlg,
                                IDD_SECURITY, TEXT("IDD_SECURITY"),
                                0, iX, iY, iWidth, iHeight );
    {
        HWND hwnd;

        // DEFAULT radio item is default SECURITY
        hwnd = GetDlgItem( pPropDataWnd->GetHwnd(), IDC_RADIO_SECURITY_DEFAULT );
        SetWindowLong( hwnd, GWL_USERDATA, DEFAULT_POL_SECURITY);
        Button_SetCheck(hwnd, BST_CHECKED);
        
        hwnd = GetDlgItem( pPropDataWnd->GetHwnd(), IDC_RADIO_SECURITY_REQUIRED );
        SetWindowLong( hwnd, GWL_USERDATA, REQUIRED_POL_SECURITY);

        hwnd = GetDlgItem( pPropDataWnd->GetHwnd(), IDC_RADIO_SECURITY_DISABLED );
        SetWindowLong( hwnd, GWL_USERDATA, DISABLED_POL_SECURITY);

        pPropDataWnd -> SetEnableListID( 5,
                                         IDC_RADIO_SECURITY_DEFAULT,
                                         IDC_RADIO_SECURITY_REQUIRED,
                                         IDC_RADIO_SECURITY_DISABLED,
                                         IDC_REQUIRE_COMPLETE_AUTHENTICATION,
                                         IDC_SET_RDN_FOR_REQUIRED_CA
                                         );

        //
        // Link Set URL checkbox with edit field
        //
        {
            HWND hwndCond = GetDlgItem(pPropDataWnd->GetHwnd(), IDC_SET_RDN_FOR_REQUIRED_CA);
            pPropDataWnd->ConnectControlsToCheck( IDC_SET_RDN_FOR_REQUIRED_CA,
                    1,
                    new CControlID(hwndCond, IDC_SET_RDN_FOR_REQUIRED_CA,
                        IDC_EDIT_SET_RDN_FOR_REQUIRED_CA,
                        CControlID::EDIT ) );
        }
    }
    ms_PropertyWindows[ ItemID ] = pPropDataWnd;
    ms_FocusList[ ItemID ] = GetDlgItem( pPropDataWnd->GetHwnd(), IDC_RADIO_SECURITY_DEFAULT );
    pPropDataWnd -> EnableWindow( FALSE );


    //
    // A/V OPTIONS
    //

//////////
    ItemID = IDC_RESTRICT_THE_USE_OF_AUDIO;
    m_pCategoryList->SetEnableListID( 1, ItemID );
    ms_CategoryIDList.push_front( ItemID );
    pPropDataWnd = new CPropertyDataWindow2( m_hWndDlg,
                            IDD_AUDIO, TEXT("IDD_AUDIO"),
                            0, iX, iY, iWidth, iHeight );
    pPropDataWnd -> SetEnableListID( 7,
                                    IDC_PREVENT_THE_USER_FROM_USING_AUDIO,
                                    IDC_ENABLE_DIRECT_SOUND,
                                    IDC_NOCHANGE_DIRECT_SOUND,
                                    IDC_DISABLE_FULL_DUPLEX_AUDIO,
                                    IDC_CREATE_AN_AUDIO_LOG_FILE,
                                    IDC_CHECK_MUTE_SPEAKER_BY_DEFAULT,
                                    IDC_CHECK_MUTE_MICROPHONE_BY_DEFAULT
                                   );
    ms_PropertyWindows[ ItemID ] = pPropDataWnd;
    ms_FocusList[ ItemID ] = GetDlgItem( pPropDataWnd->GetHwnd(),
        IDC_PREVENT_THE_USER_FROM_USING_AUDIO );
    pPropDataWnd -> EnableWindow( FALSE );

//////////
    ItemID = IDC_RESTRICT_THE_USE_OF_VIDEO;
    m_pCategoryList->SetEnableListID( 1, ItemID );
    ms_CategoryIDList.push_front( ItemID );
    pPropDataWnd = new CPropertyDataWindow2( m_hWndDlg,
                            IDD_VIDEO, TEXT("IDD_VIDEO"),
                            0, iX, iY, iWidth, iHeight );
    pPropDataWnd -> SetEnableListID( 2,
                                    IDC_DISABLE_SENDING_VIDEO,
                                    IDC_DISABLE_RECIEVING_VIDEO );
    ms_PropertyWindows[ ItemID ] = pPropDataWnd;
    ms_FocusList[ ItemID ] = GetDlgItem( pPropDataWnd->GetHwnd(),
        IDC_DISABLE_SENDING_VIDEO );
    pPropDataWnd -> EnableWindow( FALSE );

////////
    ItemID = IDC_LIMIT_AV_THROUGHPUT;
    m_pCategoryList->SetEnableListID( 1, ItemID );
    ms_CategoryIDList.push_front( ItemID );
    pPropDataWnd = new CPropertyDataWindow2( m_hWndDlg,
                                IDD_LIMIT_AV_THROUGHPUT, TEXT("IDD_LIMIT_AV_THROUGHPUT"),
                                RestrictAvThroughputWndProc,
                                0, iX, iY, iWidth, iHeight );
    {
        CControlID *pControl = new CControlID( IDC_SLIDE_AV_THROUGHPUT,
                                        CControlID::SLIDER );
        pControl->SetStaticID( IDC_STATIC_MAX_AV_THROUGHPUT );
        pPropDataWnd->AddControl( pControl );
    }

    HWND hwndTrack = GetDlgItem( pPropDataWnd -> GetHwnd(), IDC_SLIDE_AV_THROUGHPUT );

    TrackBar_ClearTics(hwndTrack, FALSE);
    TrackBar_SetRange(hwndTrack, FALSE, BW_ISDN_BITS / 1000, BW_SLOWLAN_BITS / 1000);
    TrackBar_SetTicFreq(hwndTrack, 10, 0);
    TrackBar_SetPageSize( hwndTrack,  5);
    TrackBar_SetThumbLength( hwndTrack, 5);

    ms_PropertyWindows[ ItemID ] = pPropDataWnd;
    ms_FocusList[ ItemID ] = hwndTrack;
    pPropDataWnd -> EnableWindow( FALSE );

    //
    // TOOLS
    //
/////////
    ItemID = IDC_DISABLE_CHAT;
    m_pCategoryList->SetEnableListID( 1, ItemID );
    ms_CategoryIDList.push_front( ItemID );
    pPropDataWnd = new CPropertyDataWindow2( m_hWndDlg,
                                IDD_CHAT, TEXT("IDD_CHAT"),
                                0, iX, iY, iWidth, iHeight );
    ms_PropertyWindows[ ItemID ] = pPropDataWnd;
    pPropDataWnd -> EnableWindow( FALSE );


//////////
    ItemID = IDC_RESTRICT_THE_USE_OF_FILE_TRANSFER;
    m_pCategoryList->SetEnableListID( 1, ItemID );
    ms_CategoryIDList.push_front( ItemID );
    pPropDataWnd = new CPropertyDataWindow2( m_hWndDlg,
                            IDD_FILETRANSFER, TEXT("IDD_FILETRANSFER"),
                            0, iX, iY, iWidth, iHeight );

    pPropDataWnd -> SetEnableListID(     2,
                                    IDC_PREVENT_THE_USER_FROM_SENDING_FILES,
                                    IDC_PREVENT_THE_USER_FROM_RECEIVING_FILES
                                 );

    //
    // Link max send size check box to inverse of prevent sending checkbox
    //

    {
        HWND hwndCond = GetDlgItem( pPropDataWnd->GetHwnd(), IDC_MAXIMUM_SIZE_OF_SENT_FILES );
        pPropDataWnd -> ConnectControlsToCheck( IDC_MAXIMUM_SIZE_OF_SENT_FILES, 1,
                                            new CControlID( hwndCond,
                                                            IDC_MAXIMUM_SIZE_OF_SENT_FILES,
                                                            IDC_EDIT_MAXIMUM_SIZE_OF_SENT_FILES,
                                                            CControlID::EDIT_NUM ) );
    }
    
    ms_PropertyWindows[ ItemID ] = pPropDataWnd;
    ms_FocusList[ ItemID ] = GetDlgItem( pPropDataWnd->GetHwnd(),
        IDC_PREVENT_THE_USER_FROM_SENDING_FILES );
    pPropDataWnd -> EnableWindow( FALSE );


//////////
    ItemID = IDC_RESTRICT_THE_USE_OF_SHARING;
    m_pCategoryList->SetEnableListID( 1, ItemID );
    ms_CategoryIDList.push_front( ItemID );
    pPropDataWnd = new CPropertyDataWindow2( m_hWndDlg,
                            IDD_SHARING, TEXT("IDD_SHARING"),
                            0, iX, iY, iWidth, iHeight );
    pPropDataWnd -> SetEnableListID( 7,
                                    IDC_DISABLE_ALL_SHARING_FEATURES,
                                    IDC_PREVENT_SHARING,
                                    IDC_PREVENT_SHARING_DESKTOP,
                                    IDC_PREVENT_SHARING_TRUECOLOR,
                                    IDC_PREVENT_SHARING_EXPLORER,
                                    IDC_PREVENT_SHARING_DOS,
                                    IDC_PREVENT_SHARING_CONTROL);
    ms_PropertyWindows[ ItemID ] = pPropDataWnd;
    ms_FocusList[ ItemID ] = GetDlgItem( pPropDataWnd->GetHwnd(), IDC_DISABLE_ALL_SHARING_FEATURES );

    pPropDataWnd -> EnableWindow( FALSE );

////////
    ItemID = IDC_RESTRICT_THE_USE_OF_WHITEBOARD;
    m_pCategoryList->SetEnableListID( 1, ItemID );
    ms_CategoryIDList.push_front( ItemID );
    pPropDataWnd = new CPropertyDataWindow2( m_hWndDlg,
                                IDD_WHITEBOARD, TEXT("IDD_WHITEBOARD"),
                                0, iX, iY, iWidth, iHeight );

    pPropDataWnd -> SetEnableListID( 2,
                                    IDC_DISABLE_2XWHITEBOARD,
                                    IDC_DISABLE_WHITEBOARD);
    ms_PropertyWindows[ ItemID ] = pPropDataWnd;
    ms_FocusList[ ItemID ] = GetDlgItem( pPropDataWnd->GetHwnd(), IDC_DISABLE_2XWHITEBOARD );
    pPropDataWnd -> EnableWindow( FALSE );

//////////
    ItemID = IDC_RESTRICT_THE_USE_OF_RDS;
    m_pCategoryList->SetEnableListID(1, ItemID);
    ms_CategoryIDList.push_front( ItemID );
    pPropDataWnd = new CPropertyDataWindow2( m_hWndDlg,
                                IDD_RDS, TEXT("IDD_RDS"),
                                0, iX, iY, iWidth, iHeight );

    pPropDataWnd->SetEnableListID(2,
                                  IDC_DISABLE_RDS_ON_ALL,
                                  IDC_DISABLE_RDS_ON_WIN9X);
    ms_PropertyWindows[ ItemID ] = pPropDataWnd;
    ms_FocusList[ ItemID ] = GetDlgItem( pPropDataWnd->GetHwnd(), IDC_DISABLE_RDS_ON_ALL );
    pPropDataWnd->EnableWindow(FALSE);


    //
    // MISCELLANEOUS
    //
////////
    ItemID = IDC_RESTRICT_USE_OF_THE_OPTIONS_DIALOG;
    m_pCategoryList->SetEnableListID( 1, ItemID );
    ms_CategoryIDList.push_front( ItemID );
    pPropDataWnd = new CPropertyDataWindow2( m_hWndDlg,
                                IDD_OPTIONS_DIALOG, TEXT("IDD_OPTIONS_DIALOG"),
                                0, iX, iY, iWidth, iHeight );
    pPropDataWnd -> SetEnableListID( 5,
                                IDC_DISABLE_THE_GENERAL_OPTIONS_PAGE,
                                IDC_DISABLE_THE_ADVANCED_CALLING_BUTTON,
                                IDC_DISABLE_THE_SECURITY_OPTIONS_PAGE,
                                IDC_DISABLE_THE_AUDIO_OPTIONS_PAGE,
                                IDC_DISABLE_THE_VIDEO_OPTIONS_PAGE
                                );
    ms_PropertyWindows[ ItemID ] = pPropDataWnd;
    ms_FocusList[ ItemID ] = GetDlgItem( pPropDataWnd->GetHwnd(),
        IDC_DISABLE_THE_GENERAL_OPTIONS_PAGE );
    pPropDataWnd -> EnableWindow( FALSE );


////////
    ItemID = IDC_ONLINE_SUPPORT;
    m_pCategoryList->SetEnableListID( 1, ItemID );
    ms_CategoryIDList.push_front( ItemID );
    pPropDataWnd = new CPropertyDataWindow2( m_hWndDlg,
                                IDD_ONLINE_SUPPORT, TEXT("IDD_ONLINE_SUPPORT"),
                                0, iX, iY, iWidth, iHeight );
    {
        HWND hwndCond = GetDlgItem( pPropDataWnd->GetHwnd(), IDC_SET_URL_FOR_INTERNAL_SUPPORT_PAGE );
        pPropDataWnd -> ConnectControlsToCheck(IDC_SET_URL_FOR_INTERNAL_SUPPORT_PAGE,
                                                2,
                                                new CControlID(
                                                    hwndCond,
                                                    IDC_SET_URL_FOR_INTERNAL_SUPPORT_PAGE,
                                                    IDC_EDIT_SET_URL_FOR_INTERNAL_SUPPORT_PAGE,
                                                    CControlID::EDIT ),
                                                new CControlID(
                                                    hwndCond,
                                                    IDC_SET_URL_FOR_INTERNAL_SUPPORT_PAGE,
                                                    IDC_SHOW_THE_ONLINE_SUPPORT_PAGE_THE_FIRST_TIME_NETMEETING_STARTS,
                                                    CControlID::CHECK )
                                                );
    }
    ms_PropertyWindows[ ItemID ] = pPropDataWnd;
    ms_FocusList[ ItemID ] = GetDlgItem( pPropDataWnd->GetHwnd(),
        IDC_SET_URL_FOR_INTERNAL_SUPPORT_PAGE );
    pPropDataWnd -> EnableWindow( FALSE );

    return TRUE;
}

BOOL CSettingsSheet::_IsDataValid( void ) 
{
    // Validate FT Throughput
    if( GetCategoryCheck( IDC_RESTRICT_THE_USE_OF_FILE_TRANSFER ) &&
        GetCheckData( IDC_RESTRICT_THE_USE_OF_FILE_TRANSFER, IDC_MAXIMUM_SIZE_OF_SENT_FILES ) ) 
    {
        if( 0 >= GetDlgItemInt( ms_PropertyWindows[ IDC_RESTRICT_THE_USE_OF_FILE_TRANSFER ]->GetHwnd(),
                                IDC_EDIT_MAXIMUM_SIZE_OF_SENT_FILES,
                                NULL,
                                FALSE ) ) 
        {
            NmrkMessageBox(MAKEINTRESOURCE(IDS_FT_THROUGHPUT_VALUE_IS_INVALID),
                MAKEINTRESOURCE(IDS_INVALID_DATA_ERROR),
                MB_OK | MB_ICONEXCLAMATION);

            ShowWindow( IDC_RESTRICT_THE_USE_OF_FILE_TRANSFER, TRUE );
            ms_PropertyWindows[ IDC_RESTRICT_THE_USE_OF_FILE_TRANSFER ]->SetFocus( IDC_EDIT_MAXIMUM_SIZE_OF_SENT_FILES );
            return FALSE;
        }
    }

    // Validate online support URL
    if( GetCategoryCheck( IDC_ONLINE_SUPPORT ) &&
        GetCheckData( IDC_ONLINE_SUPPORT, IDC_SET_URL_FOR_INTERNAL_SUPPORT_PAGE ) ) 
    {
        LPTSTR sz;
        GetStringData( IDC_ONLINE_SUPPORT,
                    IDC_EDIT_SET_URL_FOR_INTERNAL_SUPPORT_PAGE,
                    &sz ); 

        if( NULL == sz ) 
        {
            delete [] sz;
            NmrkMessageBox(MAKEINTRESOURCE(IDS_NETMEETING_HOMEPAGE_IS_INVALID),
                MAKEINTRESOURCE(IDS_INVALID_DATA_ERROR), MB_OK | MB_ICONEXCLAMATION);
            
            ShowWindow( IDC_ONLINE_SUPPORT, TRUE );
            ms_PropertyWindows[ IDC_ONLINE_SUPPORT ]->SetFocus( IDC_SET_URL_FOR_INTERNAL_SUPPORT_PAGE );
            ms_PropertyWindows[ IDC_ONLINE_SUPPORT ]->SetFocus( IDC_EDIT_SET_URL_FOR_INTERNAL_SUPPORT_PAGE );
            return FALSE;
        }
        delete [] sz;
    }

    return TRUE;
}

int CSettingsSheet::SpewToListBox( HWND hwndList, int iStartLine ) 
{
    HWND hwndCat = m_pCategoryList->GetHwnd();
    map< UINT, CPropertyDataWindow2 * >::const_iterator it;
    for( it = ms_PropertyWindows.begin(); it != ms_PropertyWindows.end(); it++ )
    {
        if( GetCategoryCheck( (*it).first ) )
        {
            HWND hwndButton = GetDlgItem( hwndCat, (*it).first );
            int iButtonTextLen = Button_GetTextLength( hwndButton ) + 2;
            LPTSTR szButtonText = new TCHAR[ iButtonTextLen ];

            Button_GetText( hwndButton, szButtonText, iButtonTextLen -1 );
            lstrcat( szButtonText, TEXT(":") );

            ListBox_InsertString( hwndList, iStartLine, szButtonText );
            iStartLine++;

            iStartLine = (*it).second->Spew( hwndList, iStartLine );
        }
    }
    return iStartLine;
}

void CSettingsSheet::_SetButtons( void ) 
{

    DWORD dwFlags = PSWIZB_BACK;
    dwFlags |= PSWIZB_NEXT;
    PropSheet_SetWizButtons( GetParent( m_hWndDlg ), dwFlags ); 
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\nmrk\welcmsht.h ===
#ifndef __WelcmSht_h__
#define __WelcmSht_h__


class CWelcomeSheet {

friend class CNmAkWiz;
    
private:
    static BOOL APIENTRY DlgProc( HWND hDlg, UINT message, WPARAM uParam, LPARAM lParam );
    static CWelcomeSheet* ms_pWelcomeSheet;


private: // DATA
    CPropertySheetPage m_PropertySheetPage;

private: 
    CWelcomeSheet( void );
    ~CWelcomeSheet( void );

    LPCPROPSHEETPAGE GetPropertySheet( void ) const { return &m_PropertySheetPage;}
};


#endif // __WelcmSht_h__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\nmrk\util.h ===
#ifndef __util_h__
#define __util_h__

#define ARRAY_SIZE( A ) ( sizeof(A) / sizeof(A[0]) )
#define CCHMAX	ARRAY_SIZE

void ErrorMessage( void );
void ErrorMessage( LPCTSTR str, HRESULT hr );

HRESULT LPTSTR_to_BSTR(BSTR *pbstr, LPCTSTR psz);
HRESULT BSTR_to_LPTSTR(LPTSTR *ppsz, BSTR bstr);

#define RETFAIL( x ) if( false == ( x ) ) { ErrorMessage( "", GetLastError() ); assert( 0 ); return false; }

#define RETNULL( x ) if( NULL == ( x ) ) { ErrorMessage( "", GetLastError() ); assert( 0 ); return NULL; }

//-------------------------------------------------------------------
// Track Bar Helper Macros
//-------------------------------------------------------------------
// Pilfered from Petzold, "Programming Windows 95", Chapter 12, comctlhlp.h
#define TrackBar_ClearSel(hwnd, fRedraw) \
    (void)SendMessage((hwnd), TBM_CLEARSEL, (WPARAM) (BOOL) fRedraw, 0L)

#define TrackBar_ClearTics(hwnd, fRedraw) \
    (void)SendMessage((hwnd), TBM_CLEARTICS, (WPARAM) (BOOL) fRedraw, 0L)

#define TrackBar_GetChannelRect(hwnd, lprc) \
    (void)SendMessage((hwnd), TBM_GETCHANNELRECT, 0, (LPARAM) (LPRECT) lprc)

#define TrackBar_GetLineSize(hwnd) \
    (LONG)SendMessage((hwnd), TBM_GETLINESIZE, 0, 0L)

#define TrackBar_GetNumTics(hwnd) \
    (LONG)SendMessage((hwnd), TBM_GETNUMTICS, 0, 0L)

#define TrackBar_GetPageSize(hwnd) \
    (LONG)SendMessage((hwnd), TBM_GETPAGESIZE, 0, 0L)

#define TrackBar_GetPos(hwnd) \
    (LONG)SendMessage((hwnd), TBM_GETPOS, 0, 0L)

#define TrackBar_GetPTics(hwnd) \
    (LPLONG)SendMessage((hwnd), TBM_GETPTICS, 0, 0L)

#define TrackBar_GetRangeMax(hwnd) \
    (LONG)SendMessage((hwnd), TBM_GETRANGEMAX, 0, 0L)

#define TrackBar_GetRangeMin(hwnd) \
    (LONG)SendMessage((hwnd), TBM_GETRANGEMIN, 0, 0L)

#define TrackBar_GetSelEnd(hwnd) \
    (LONG)SendMessage((hwnd), TBM_GETSELEND, 0, 0L)

#define TrackBar_GetSelStart(hwnd) \
    (LONG)SendMessage((hwnd), TBM_GETSELSTART, 0, 0L)

#define TrackBar_GetThumbLength(hwnd) \
    (UINT)SendMessage((hwnd), TBM_GETTHUMBLENGTH, 0, 0L)

#define TrackBar_GetThumbRect(hwnd, lprc) \
    (void)SendMessage((hwnd), TBM_GETTHUMBRECT, 0, (LPARAM) (LPRECT) lprc)

#define TrackBar_GetTic(hwnd, iTic) \
    (LONG)SendMessage((hwnd), TBM_GETTIC, (WPARAM) (WORD) iTic, 0L)

#define TrackBar_GetTicPos(hwnd, iTic) \
    (LONG)SendMessage((hwnd), TBM_GETTICPOS, (WPARAM) (WORD) iTic, 0L)

#define TrackBar_SetLineSize(hwnd, lLineSize) \
    (LONG)SendMessage((hwnd), TBM_SETLINESIZE, 0, (LONG) lLineSize)

#define TrackBar_SetPageSize(hwnd, lPageSize) \
    (LONG)SendMessage((hwnd), TBM_SETPAGESIZE, 0, (LONG) lPageSize)

#define TrackBar_SetPos(hwnd, bPosition, lPosition) \
    (void)SendMessage((hwnd), TBM_SETPOS, (WPARAM) (BOOL) bPosition, (LPARAM) (LONG) lPosition)

#define TrackBar_SetRange(hwnd, bRedraw, lMinimum, lMaximum) \
    (void)SendMessage((hwnd), TBM_SETRANGE, (WPARAM) (BOOL) bRedraw, (LPARAM) MAKELONG(lMinimum, lMaximum))

#define TrackBar_SetRangeMax(hwnd, bRedraw, lMaximum) \
    (void)SendMessage((hwnd), TBM_SETRANGEMAX, (WPARAM) bRedraw, (LPARAM) lMaximum)

#define TrackBar_SetRangeMin(hwnd, bRedraw, lMinimum) \
    (void)SendMessage((hwnd), TBM_SETRANGEMIN, (WPARAM) bRedraw, (LPARAM) lMinimum)

#define TrackBar_SetSel(hwnd, bRedraw, lMinimum, lMaximum) \
    (void)SendMessage((hwnd), TBM_SETSEL, (WPARAM) (BOOL) bRedraw, (LPARAM) MAKELONG(lMinimum, lMaximum))

#define TrackBar_SetSelEnd(hwnd, bRedraw, lEnd) \
    (void)SendMessage((hwnd), TBM_SETSELEND, (WPARAM) (BOOL) bRedraw, (LPARAM) (LONG) lEnd)

#define TrackBar_SetSelStart(hwnd, bRedraw, lStart) \
    (void)SendMessage((hwnd), TBM_SETSELSTART, (WPARAM) (BOOL) bRedraw, (LPARAM) (LONG) lStart)

#define TrackBar_SetThumbLength(hwnd, iLength) \
    (void)SendMessage((hwnd), TBM_SETTHUMBLENGTH, (WPARAM) (UINT) iLength, 0L)

#define TrackBar_SetTic(hwnd, lPosition) \
    (BOOL)SendMessage((hwnd), TBM_SETTIC, 0, (LPARAM) (LONG) lPosition)

#define TrackBar_SetTicFreq(hwnd, wFreq, lPosition) \
    (void)SendMessage((hwnd), TBM_SETTICFREQ, (WPARAM) wFreq, (LPARAM) (LONG) lPosition)


#endif // __util_h__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\nmrk\welcmsht.cpp ===
#include "precomp.h"
#include "resource.h"
#include "global.h"
#include "PropPg.h"
#include "WelcmSht.h"
#include "nmakwiz.h"


////////////////////////////////////////////////////////////////////////////////////////////////////
// Static member vars
CWelcomeSheet* CWelcomeSheet::ms_pWelcomeSheet = NULL;

////////////////////////////////////////////////////////////////////////////////////////////////////
// Static member fns

BOOL APIENTRY CWelcomeSheet::DlgProc( HWND hDlg, UINT message, WPARAM uParam, LPARAM lParam ) {

    switch( message ) {
		case WM_INITDIALOG:
			PropSheet_SetWizButtons( GetParent( hDlg ), PSWIZB_NEXT ); 
			return TRUE;

		case WM_NOTIFY:
			switch( reinterpret_cast< NMHDR FAR* >( lParam ) -> code ) {
				case PSN_QUERYCANCEL: 
					SetWindowLong( hDlg, DWL_MSGRESULT, !VerifyExitMessageBox());
					return TRUE;

                case PSN_SETACTIVE:
                    g_hwndActive = hDlg;
                	PropSheet_SetWizButtons( GetParent( hDlg ), PSWIZB_NEXT ); 
			        return TRUE;

			}

		default:
			break;

	}

	return FALSE;

}


////////////////////////////////////////////////////////////////////////////////////////////////////
// Member fns


CWelcomeSheet::CWelcomeSheet( void )
 : m_PropertySheetPage( MAKEINTRESOURCE( IDD_PROPPAGE_WELCOME ), 
						( DLGPROC ) CWelcomeSheet::DlgProc 
                       )
{   
     if( NULL == ms_pWelcomeSheet ) { ms_pWelcomeSheet = this; }
}

CWelcomeSheet::~CWelcomeSheet( void ) 
{ ; }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\nmrk\wndprocs.h ===
#ifndef _WNDPROCS_H_
#define _WNDPROCS_H_

#define CAT_CHECK_STATE_UNSEL  0
#define CAT_CHECK_STATE_SEL	   1
#define CAT_CHECK_STATE_CHECK  2

typedef struct tagSubData
{
	WNDPROC		  proc;
	list<HWND>    list;
} SUBDATA, *PSUBDATA;

void OnMsg_VScroll( HWND hwnd, WPARAM wParam );
LRESULT CALLBACK RestrictAvThroughputWndProc( HWND hwnd, UINT iMsg, WPARAM wParam, LPARAM lParam );
LRESULT CALLBACK CatListWndProc( HWND hwnd, UINT iMsg, WPARAM wParam, LPARAM lParam );
LRESULT CALLBACK wndProcForCheckTiedToEdit( HWND hwnd, UINT iMsg, WPARAM wParam, LPARAM lParam );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\nmutil\borderwindow.cpp ===
// File: Toolbar.cpp

#include "precomp.h"

#include "GenContainers.h"

#include <windowsx.h>

CBorderWindow::CBorderWindow() :
	m_uParts(0),
	m_hGap(0),
	m_vGap(0)
{
}

BOOL CBorderWindow::Create(
	HWND hWndParent	// The parent of this window
	)
{
	return(CGenWindow::Create(
		hWndParent,		// Window parent
		0,				// ID of the child window
		TEXT("NMBorderWindow"),	// Window name
		WS_CLIPCHILDREN,			// Window style; WS_CHILD|WS_VISIBLE will be added to this
		WS_EX_CONTROLPARENT		// Extended window style
		));
}

extern void GetWindowDesiredSize(HWND hwnd, SIZE *ppt);

extern BOOL IsChildVisible(HWND hwndChild);

enum Parts
{
	TL = 0,
	T,
	TR,
	L,
	C,
	R,
	BL,
	B,
	BR,
} ;

// Returns the number of child windows
UINT FillWindowSizes(
	HWND hwndParent,
	HWND hwnds[CBorderWindow::NumParts],
	SIZE sizes[CBorderWindow::NumParts],
	UINT uParts
	)
{
	UINT nChildren = 0;

	HWND hwndChild = ::GetWindow(hwndParent, GW_CHILD);

	for (int i=0; i<CBorderWindow::NumParts; ++i)
	{
		sizes[i].cx = sizes[i].cy = 0;

		if ((uParts&(1<<i)) == 0)
		{
			hwnds[i] = NULL;
		}
		else
		{
			hwnds[i] = hwndChild;

			if (NULL != hwndChild && IsChildVisible(hwndChild))
			{
				IGenWindow *pWin = IGenWindow::FromHandle(hwndChild);
				if (NULL != pWin)
				{
					++nChildren;
					pWin->GetDesiredSize(&sizes[i]);
				}

				hwndChild = ::GetWindow(hwndChild, GW_HWNDNEXT);
			}
		}
	}

	return(nChildren);
}

// Returns the total children desired size in the arrays
// Return value is the number of child windows
UINT CBorderWindow::GetDesiredSize(
	HWND hwnds[NumParts],
	SIZE sizes[NumParts],
	int rows[3],
	int cols[3],
	SIZE *psize)
{
	UINT nChildren = FillWindowSizes(GetWindow(), hwnds, sizes, m_uParts);

	cols[0] = max(max(sizes[TL].cx, sizes[L].cx), sizes[BL].cx);
	cols[1] = max(max(sizes[T ].cx, sizes[C].cx), sizes[B ].cx);
	cols[2] = max(max(sizes[TR].cx, sizes[R].cx), sizes[BR].cx);

	rows[0] = max(max(sizes[TL].cy, sizes[T].cy), sizes[TR].cy);
	rows[1] = max(max(sizes[L ].cy, sizes[C].cy), sizes[R ].cy);
	rows[2] = max(max(sizes[BL].cy, sizes[B].cy), sizes[BR].cy);

	psize->cx = cols[0] + cols[1] + cols[2];
	psize->cy = rows[0] + rows[1] + rows[2];

	// Add the gaps
	if (0 != cols[0])
	{
		if (0 != cols[1] || 0 != cols[2])
		{
			psize->cx += m_hGap;
		}
	}
	if (0 != cols[1] && 0 != cols[2])
	{
		psize->cx += m_hGap;
	}

	if (0 != rows[0])
	{
		if (0 != rows[1] || 0 != rows[2])
		{
			psize->cy += m_vGap;
		}
	}
	if (0 != rows[1] && 0 != rows[2])
	{
		psize->cy += m_vGap;
	}

	return(nChildren);
}

void CBorderWindow::GetDesiredSize(SIZE *psize)
{
	HWND hwnds[NumParts];
	SIZE sizes[NumParts];
	int rows[3];
	int cols[3];

	GetDesiredSize(hwnds, sizes, rows, cols, psize);

	// Add on any non-client size
	SIZE sizeTemp;
	CGenWindow::GetDesiredSize(&sizeTemp);
	psize->cx += sizeTemp.cx;
	psize->cy += sizeTemp.cy;
}

HDWP SetWindowPosI(HDWP hdwp, HWND hwndChild, int left, int top, int width, int height)
{
	if (NULL == hwndChild)
	{
		return(hdwp);
	}

#if TRUE
	return(DeferWindowPos(hdwp, hwndChild, NULL, left, top, width, height, SWP_NOZORDER));
#else
	// Helpful for debugging
	SetWindowPos(hwndChild, NULL, left, top, width, height, SWP_NOZORDER);
	return(hdwp);
#endif
}

// Move the children into their various locations
void CBorderWindow::Layout()
{
	HWND hwnds[NumParts];
	SIZE sizes[NumParts];
	int rows[3];
	int cols[3];

	SIZE desiredSize;

	UINT nChildren = GetDesiredSize(hwnds, sizes, rows, cols, &desiredSize);
	bool bCenterOnly = (1 == nChildren) && (0 != (m_uParts & Center));

	HWND hwndThis = GetWindow();

	RECT rcClient;
	GetClientRect(hwndThis, &rcClient);

	// Add extra space to the center
	if (desiredSize.cx < rcClient.right || bCenterOnly)
	{
		cols[1] += rcClient.right  - desiredSize.cx;
	}
	if (desiredSize.cy < rcClient.bottom || bCenterOnly)
	{
		rows[1] += rcClient.bottom - desiredSize.cy;
	}

	// Speed up layout by deferring it
	HDWP hdwp = BeginDeferWindowPos(NumParts);

	// Add the gaps

	// Make the dimension 3 so we can safely iterate through the loop below
	int hGaps[3] = { 0, 0 };
	if (0 != cols[0])
	{
		if (0 != cols[1] || 0 != cols[2])
		{
			hGaps[0] = m_hGap;
		}
	}
	if (0 != cols[1] && 0 != cols[2])
	{
		hGaps[1] = m_hGap;
	}

	// Make the dimension 3 so we can safely iterate through the loop below
	int vGaps[3] = { 0, 0 };
	if (0 != rows[0])
	{
		if (0 != rows[1] || 0 != rows[2])
		{
			vGaps[0] = m_vGap;
		}
	}
	if (0 != rows[1] && 0 != rows[2])
	{
		vGaps[1] = m_vGap;
	}

	// Layout by rows
	int top = 0;
	for (int i=0; i<3; ++i)
	{
		int left = 0;

		for (int j=0; j<3; ++j)
		{
			hdwp = SetWindowPosI(hdwp, hwnds[3*i+j], left, top, cols[j], rows[i]);
			left += cols[j] + hGaps[j];
		}

		top += rows[i] + vGaps[i];
	}

	// Actually move all the windows now
	EndDeferWindowPos(hdwp);
}

LRESULT CBorderWindow::ProcessMessage(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)
{
	switch (message)
	{
		HANDLE_MSG(hwnd, WM_COMMAND, OnCommand);
	}

	return(CGenWindow::ProcessMessage(hwnd, message, wParam, lParam));
}

void CBorderWindow::OnCommand(HWND hwnd, int id, HWND hwndCtl, UINT codeNotify)
{
	FORWARD_WM_COMMAND(GetParent(hwnd), id, hwndCtl, codeNotify, SendMessage);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\nmrk\wndprocs.cpp ===
#include "precomp.h"
#include "resource.h"
#include "nmakwiz.h"
#include "wndprocs.h"

LRESULT CALLBACK RestrictAvThroughputWndProc( HWND hwnd, UINT iMsg, WPARAM wParam, LPARAM lParam )
{
	switch( iMsg )
	{
		case WM_VSCROLL: 
		{
			OnMsg_VScroll( hwnd, wParam );
			return 0;
			break;
		} 
		case WM_HSCROLL:
		{
			TCHAR szPos[ MAX_DIGITS ];
			DWORD dwPos = SendMessage( GetDlgItem( hwnd, IDC_SLIDE_AV_THROUGHPUT), TBM_GETPOS, 0, 0); 
			wsprintf( szPos, "%d", dwPos );
			Static_SetText( GetDlgItem( hwnd, IDC_STATIC_MAX_AV_THROUGHPUT), szPos );
			return 0;
			break;
		}

		case WM_COMMAND:
		{
			return 0;
            break;
		}
	}
	return( DefWindowProc( hwnd, iMsg, wParam, lParam ) );
}

LRESULT CALLBACK wndProcForCheckTiedToEdit( HWND hwnd, UINT iMsg, WPARAM wParam, LPARAM lParam )
{
	PSUBDATA pSubData = (PSUBDATA)GetWindowLong( hwnd, GWL_USERDATA );
	WNDPROC proc = pSubData->proc;

	switch( iMsg )
	{
		case WM_ENABLE:
		{
			if( Button_GetCheck( hwnd ) )
			{
				list< HWND >::const_iterator it;
				
				for( it = pSubData -> list . begin(); it != pSubData -> list . end(); ++it )
				{
					::EnableWindow( (HWND)(*it), (BOOL)wParam );
				}
			}
			break;
		}
		case BM_SETCHECK:
		{
			if( IsWindowEnabled( hwnd ) )
			{
				list< HWND >::const_iterator it;
				
				for( it = pSubData -> list . begin(); it != pSubData -> list . end(); ++it )
				{
					::EnableWindow( (HWND)(*it), (BOOL)wParam );
				}
			}
			break;
		}
		case WM_NCDESTROY:
		{
			delete pSubData;
			break;
		}
	}

	return( CallWindowProc( proc, hwnd, iMsg, wParam, lParam ) );
}

int _ControlIsObscured( HWND parentControl, HWND hwndControl );

int _ControlIsObscured( HWND parentControl, HWND hwndControl )
{
	RECT rectControl;
	GetWindowRect( hwndControl, &rectControl );

	RECT rectParent;
	GetWindowRect( parentControl, &rectParent );

	if( rectControl . top < rectParent . top )
	{
		// Scroll 
		return -1;
	}
	else if( rectControl . bottom > rectParent . bottom )
	{
		// Scroll
		return 1;
	}
	else 
	{
		return 0;
	}
}


enum tagCategoryButtonStates
{
	STATE_UNSELECTED,
	STATE_SELECTED,
	STATE_SELECTED_VIS,
	STATE_CHECKED,
	STATE_CHECKED_VIS
};

LRESULT CALLBACK CatListWndProc( HWND hwnd, UINT iMsg, WPARAM wParam, LPARAM lParam )
{
	switch( iMsg )
	{
		case WM_CREATE:
		{
			// Note - this should be set to the top check box
			PostMessage( hwnd, WM_COMMAND, MAKEWPARAM( IDC_SET_CALLING_OPTIONS, BN_CLICKED ), 0L );
			break;
		}
		
		case WM_COMMAND:
		{
			UINT uHiword = GET_WM_COMMAND_CMD(wParam, lParam);
            UINT uLoword = GET_WM_COMMAND_ID(wParam, lParam);
			switch( uHiword )
			{
				case BN_DOUBLECLICKED:
				case BN_CLICKED:
				{
					HWND hwndButton = GetDlgItem(hwnd, uLoword);
					ULONG uState = GetWindowLong( hwndButton, GWL_USERDATA );
					switch( uState )
					{
						case STATE_UNSELECTED:
						{
							if (Button_GetCheck(hwndButton))
							{
								SetWindowLong(hwndButton, GWL_USERDATA, STATE_CHECKED_VIS  );
							}
							else
							{
								SetWindowLong(hwndButton, GWL_USERDATA, STATE_SELECTED_VIS );
							}
							g_pWiz->m_SettingsSheet.ShowWindow(uLoword, TRUE);
							break;
						}
						case STATE_SELECTED:
						case STATE_SELECTED_VIS:
						{
							if ((uHiword == BN_DOUBLECLICKED) && (STATE_SELECTED_VIS != uState))
							{
								break;
							}
							Button_SetCheck( hwndButton, TRUE );
							g_pWiz -> m_SettingsSheet . EnableWindow( uLoword, TRUE );
							g_pWiz->m_SettingsSheet.SetFocus( uLoword );
							SetWindowLong( hwndButton, GWL_USERDATA, STATE_CHECKED );
							break;
						}
						case STATE_CHECKED:
						case STATE_CHECKED_VIS:
						{
							if ((uHiword == BN_DOUBLECLICKED) && (STATE_CHECKED_VIS != uState))
							{
								break;
							}

							Button_SetCheck( hwndButton, FALSE );
							g_pWiz -> m_SettingsSheet . EnableWindow( uLoword, FALSE );
							SetWindowLong( hwndButton, GWL_USERDATA, STATE_SELECTED );
							break;
						}
					}			
					return 0;
					break;	
				}

				case EN_SETFOCUS:
				case BN_SETFOCUS:
				{
					return 0;
				}
			}
		}
		
		case WM_VSCROLL:
		{
			OnMsg_VScroll( hwnd, wParam );
			return 0;
		}
		
	}

	return( DefWindowProc( hwnd, iMsg, wParam, lParam ) );
}

enum { SCROLL_JUMP = 20 };

void OnMsg_VScroll( HWND hwnd, WPARAM wParam )
{
	int         nPosition; 
	int         nHorzScroll = 0; 
	int         nVertScroll = 0; 
	SCROLLINFO  ScrollInfo; 
	WORD		wScrollCode = (WORD)LOWORD(wParam);

	// Get current scroll information. 
	ScrollInfo.cbSize = sizeof(SCROLLINFO); 
	ScrollInfo.fMask = SIF_ALL; 
	GetScrollInfo(hwnd, SB_VERT, &ScrollInfo); 
	nPosition = ScrollInfo.nPos; 

	// Modify scroll information based on requested 
	// scroll action. 

	RECT rectWindow;
	GetClientRect( hwnd, &rectWindow );

	int iDelta;
	switch (wScrollCode) 
	{ 
		case SB_LINEDOWN:
			iDelta = -SCROLL_JUMP;
			ScrollInfo.nPos += SCROLL_JUMP; 
			break; 

		case SB_LINEUP:
			iDelta = SCROLL_JUMP;
			ScrollInfo.nPos -= SCROLL_JUMP; 
			break; 

		case SB_PAGEDOWN: 
			iDelta = -ScrollInfo.nPage;
			ScrollInfo.nPos += ScrollInfo.nPage; 
			break; 

		case SB_PAGEUP: 
			iDelta = ScrollInfo.nPage;
			ScrollInfo.nPos -= ScrollInfo.nPage; 
			break; 

		case SB_TOP: 
			iDelta = rectWindow . top - rectWindow . bottom;/*170;*/
			ScrollInfo.nPos = ScrollInfo.nMin; 
			break; 

		case SB_BOTTOM: 
			iDelta = rectWindow . top - rectWindow . bottom;/*170;*/
			ScrollInfo.nPos = ScrollInfo.nMax; 
			break; 

			// Don't do anything. 
		case SB_THUMBPOSITION: 
		case SB_THUMBTRACK: 
			iDelta = -(ScrollInfo.nTrackPos - ScrollInfo.nPos);
			ScrollInfo.nPos = ScrollInfo.nTrackPos; 
			break; 

		case SB_ENDSCROLL: 
			default: 
			return; 
	} 

	// Make sure that scroll position is in range. 
	if (0 > ScrollInfo.nPos)
	{
		ScrollInfo.nPos = 0; 
	}
	else if (ScrollInfo.nMax - (int) ScrollInfo.nPage + 1 < ScrollInfo.nPos) 
	{
		ScrollInfo.nPos = ScrollInfo.nMax  - ScrollInfo.nPage + 1; 
	}

	// Set new scroll position. 
	ScrollInfo.fMask = SIF_POS; 
	SetScrollInfo(hwnd, SB_VERT, &ScrollInfo, TRUE); 

	// Scroll window. 
	nVertScroll = nPosition - ScrollInfo.nPos; 


	ScrollWindowEx(hwnd, nHorzScroll, nVertScroll, NULL, NULL, 
				   NULL, NULL, SW_ERASE | SW_INVALIDATE | SW_SCROLLCHILDREN); 

	//InvalidateRect( hwnd, NULL, TRUE );
	if( 0 < iDelta )
	{
		iDelta += 1;
		SetRect( &rectWindow, rectWindow . left, rectWindow . top , rectWindow . right, rectWindow . top + iDelta /*164, 200, 164 + 375, 200 + iDelta */ );
	}
	else if( 0 > iDelta )
	{
		iDelta -= 1;
		SetRect( &rectWindow, rectWindow . left, rectWindow . bottom + iDelta , rectWindow . right, rectWindow . bottom /*164, 200 + 170 + iDelta, 164 + 375, 200 + 170*/ );
	}
	else
	{
		return;
	}

	MapWindowPoints(  hwnd, GetParent( hwnd ), (LPPOINT) &rectWindow, 2 );
	RedrawWindow( GetParent( hwnd ), &rectWindow, NULL, RDW_INVALIDATE | RDW_ERASE | RDW_ERASENOW | RDW_UPDATENOW | RDW_ALLCHILDREN );

	return; 
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\nmutil\centwnd.cpp ===
#include "precomp.h"
#include <oprahcom.h>


/*  C E N T E R  W I N D O W */
/*-------------------------------------------------------------------------
	%%Function: CenterWindow

	Center a window over another window.
-------------------------------------------------------------------------*/
VOID NMINTERNAL CenterWindow(HWND hwndChild, HWND hwndParent)
{
	int   xNew, yNew;
	int   cxChild, cyChild;
	int   cxParent, cyParent;
	int   cxScreen, cyScreen;
	RECT  rcChild, rcParent, rcScrn;

	// Get the Height and Width of the child window
	GetWindowRect(hwndChild, &rcChild);
	cxChild = rcChild.right - rcChild.left;
	cyChild = rcChild.bottom - rcChild.top;

	// Get the display limits
	GetWindowRect(GetDesktopWindow(), &rcScrn);
	cxScreen = rcScrn.right - rcScrn.left;
	cyScreen = rcScrn.bottom - rcScrn.top;

	if(hwndParent != NULL )
	{
	    // Get the Height and Width of the parent window
	    GetWindowRect(hwndParent, &rcParent);
	    cxParent = rcParent.right - rcParent.left;
	    cyParent = rcParent.bottom - rcParent.top;
	}
    else
    {
		// No parent - center on desktop
		cxParent = cxScreen;
		cyParent = cyScreen;
		SetRect(&rcParent, 0, 0, cxScreen, cyScreen);
    }

	// Calculate new X position, then adjust for screen
	xNew = rcParent.left + ((cxParent - cxChild) / 2);
	if (xNew < 0)
		xNew = 0;
	else if ((xNew + cxChild) > cxScreen)
		xNew = cxScreen - cxChild;

	// Calculate new Y position, then adjust for screen
	yNew = rcParent.top  + ((cyParent - cyChild) / 2);
	if (yNew < 0)
		yNew = 0;
	else if ((yNew + cyChild) > cyScreen)
		yNew = cyScreen - cyChild;

	SetWindowPos(hwndChild, NULL, xNew, yNew, 0, 0,
		SWP_NOSIZE | SWP_NOZORDER | SWP_NOACTIVATE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\nmutil\bstring.cpp ===
/*
 * BSTRING.CPP
 *
 * Implementation of the member functions of the BSTRING C++ class.  See
 * BSTRING.H for the class declaration and the implementation of the inline
 * member functions.
 *
 * Author:
 *		dannygl, 29 Oct 96
 */

#include "precomp.h"
#include <bstring.h>

// We don't support construction from an ANSI string in the Unicode build.
#if !defined(UNICODE)

BSTRING::BSTRING(LPCSTR lpcString)
{
    // Initialize the member pointer to NULL
    m_bstr = NULL;
    if (NULL == lpcString)
        return;

    // Compute the length of the required BSTR, including the null
    int cWC;

    cWC =  MultiByteToWideChar(CP_ACP, 0, lpcString, -1, NULL, 0);
    if (cWC <= 0)
    {
        return;
    };

    // Allocate the BSTR, including the null
    m_bstr = SysAllocStringLen(NULL, cWC - 1); // SysAllocStringLen adds another 1

    ASSERT(NULL != m_bstr);

    if (NULL == m_bstr)
    {
        return;
    }

    // Copy the string
    MultiByteToWideChar(CP_ACP, 0, lpcString, -1, (LPWSTR) m_bstr, cWC);

    // Verify that the string is null terminated
    ASSERT(0 == m_bstr[cWC - 1]);
}

#endif // !defined(UNICODE)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\nmutil\bestintf.cpp ===
#include "precomp.h"
#include "bestintf.h"



typedef DWORD (WINAPI * PFNGetBestInterface) (
    IN  IPAddr  dwDestAddr,
    OUT PDWORD  pdwBestIfIndex
    );

typedef DWORD (WINAPI * PFNGetIpAddrTable) (
    OUT    PMIB_IPADDRTABLE pIpAddrTable,
    IN OUT PULONG           pdwSize,
    IN     BOOL             bOrder
    );

static HINSTANCE s_hIPHLPAPI = NULL;
const TCHAR g_cszIPHLPAPIDllName[] = _TEXT("iphlpapi.dll");
static PFNGetBestInterface s_pfnGetBestInterface;
static PFNGetIpAddrTable s_pfnGetIpAddrTable;


//forward references
static DWORD IpAddrTable(PMIB_IPADDRTABLE& pIpAddrTable, BOOL fOrder = FALSE);
static DWORD InterfaceIdxToInterfaceIp(PMIB_IPADDRTABLE
		pIpAddrTable, DWORD dwIndex, in_addr* s);


DWORD NMINTERNAL NMGetBestInterface ( SOCKADDR_IN* srem, SOCKADDR_IN* sloc )
{
	SOCKET hSock;
	int nAddrSize = sizeof(SOCKADDR);
	
	const int maxhostname = 1024;
	char hostname[maxhostname + 1];
	hostent *ha;
	char** c;
	int cIpAddr; // count of IpAddresses
	in_addr* in;

	DWORD BestIFIndex;
	PMIB_IPADDRTABLE pIpAddrTable = NULL;

	int dwStatus = ERROR_SUCCESS;

    ASSERT(srem);
    ASSERT(sloc);

	// This function tries to find the best IP interface to return when given a remote address
	// Three different ways are tried.

	//(1) statically get the list of interfaces, this will work when there's only one IP address
	dwStatus = gethostname(hostname, maxhostname);
	if (dwStatus != 0)
	{
		return WSAGetLastError();
	}

	ha = gethostbyname(hostname);
	if (ha == NULL)
	{
		return WSAGetLastError();
	}

	cIpAddr = 0;   // count the interfaces, if there's only one this is easy
	for (c = ha->h_addr_list; *c != NULL; ++c)
	{
		cIpAddr++;
		in = (in_addr*)*c;
	}

	if (cIpAddr == 1) //just a single IP Address
	{
		sloc->sin_family = 0;
		sloc->sin_port = 0;
		sloc->sin_addr = *in;
		return dwStatus;
	}
	

	// (2) This computer has multiple IP interfaces, try the functions
	//     in IPHLPAPI.DLL
	//     As of this writing - Win98, NT4SP4, Windows 2000 contain these functions.
	//
	// This is a win because the information we need can be looked up statically.

	if (NULL == s_hIPHLPAPI)
	{
		s_hIPHLPAPI = ::LoadLibrary(g_cszIPHLPAPIDllName);
	}
	if (NULL != s_hIPHLPAPI)
	{
		s_pfnGetBestInterface = (PFNGetBestInterface)
			::GetProcAddress(s_hIPHLPAPI, "GetBestInterface");
		s_pfnGetIpAddrTable   = (PFNGetIpAddrTable)
			::GetProcAddress(s_hIPHLPAPI, "GetIpAddrTable");
		if ((NULL != s_pfnGetBestInterface) &&
			(NULL != s_pfnGetIpAddrTable))
		{
		    dwStatus = s_pfnGetBestInterface( (IPAddr)((ULONG_PTR)srem), &BestIFIndex);
			if (dwStatus != ERROR_SUCCESS)
			{
			    FreeLibrary(s_hIPHLPAPI);
				s_hIPHLPAPI = NULL;
				return dwStatus;
			}
			
			// get IP Address Table for mapping interface index number to ip address
			dwStatus = IpAddrTable(pIpAddrTable);
			if (dwStatus != ERROR_SUCCESS)
			{
				if (pIpAddrTable)
					MemFree(pIpAddrTable);
			    FreeLibrary(s_hIPHLPAPI);
				s_hIPHLPAPI = NULL;
				return dwStatus;
			}
			
			dwStatus = InterfaceIdxToInterfaceIp(pIpAddrTable,
												 BestIFIndex, &(sloc->sin_addr));

			MemFree(pIpAddrTable);
			if (dwStatus == ERROR_SUCCESS)
			{
			    FreeLibrary(s_hIPHLPAPI);
				s_hIPHLPAPI = NULL;
			    return dwStatus;
			}
		}
	}


	// (3) As a last resort, try and connect on the stream socket that was passed in
	//     This will work for NetMeeting when connecting to an LDAP server, for example.
	//
	hSock = socket(AF_INET, SOCK_STREAM, 0); // must be a STREAM socket for MS stack
	if (hSock != INVALID_SOCKET)
	{
		dwStatus = connect(hSock, (LPSOCKADDR)&srem, sizeof (SOCKADDR));
		if (dwStatus != SOCKET_ERROR)
		{
			getsockname(hSock, (LPSOCKADDR)&sloc, (int *) &nAddrSize);
		}
		closesocket(hSock);
		return ERROR_SUCCESS;
	}
	return SOCKET_ERROR;
}
	

//----------------------------------------------------------------------------
// Inputs: pIpAddrTable is the IP address table
//         dwIndex is the Interface Number
// Output: returns ERROR_SUCCESS when a match is found, s contains the IpAddr
//----------------------------------------------------------------------------
DWORD InterfaceIdxToInterfaceIp(PMIB_IPADDRTABLE pIpAddrTable, DWORD dwIndex, in_addr* s)
{
    for (DWORD dwIdx = 0; dwIdx < pIpAddrTable->dwNumEntries; dwIdx++)
    {
        if (dwIndex == pIpAddrTable->table[dwIdx].dwIndex)
        {
            s->S_un.S_addr = pIpAddrTable->table[dwIdx].dwAddr;
			return ERROR_SUCCESS;
        }
    }
    return 1;

}


//----------------------------------------------------------------------------
// If returned status is ERROR_SUCCESS, then pIpAddrTable points to a Ip Address
// table.
//----------------------------------------------------------------------------
DWORD IpAddrTable(PMIB_IPADDRTABLE& pIpAddrTable, BOOL fOrder)
{
    DWORD status = ERROR_SUCCESS;
    DWORD statusRetry = ERROR_SUCCESS;
    DWORD dwActualSize = 0;

    // query for buffer size needed
    status = s_pfnGetIpAddrTable(pIpAddrTable, &dwActualSize, fOrder);

    if (status == ERROR_SUCCESS)
    {
        return status;
    }
    else if (status == ERROR_INSUFFICIENT_BUFFER)
    {
        // need more space
        pIpAddrTable = (PMIB_IPADDRTABLE) MemAlloc(dwActualSize);

        statusRetry = s_pfnGetIpAddrTable(pIpAddrTable, &dwActualSize, fOrder);
        return statusRetry;
    }
    else
    {
        return status;
    }
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\nmutil\cstring.cpp ===
// CSTRING.CPP
//
// Based on the original MFC source file.

//
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1995 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "precomp.h"
#include <cstring.hpp>

#ifdef AFX_CORE1_SEG
#pragma code_seg(AFX_CORE1_SEG)
#endif

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// static class data, special inlines

// afxChNil is left for backward compatibility
REMAFX_DATADEF TCHAR AFXChNil = '\0';

// For an empty string, m_pchData will point here
// (note: avoids special case of checking for NULL m_pchData)
// empty string data (and locked)
static int RGInitData[] = { -1, 0, 0, 0 };
static REMAFX_DATADEF CSTRINGData* AFXDataNil = (CSTRINGData*)&RGInitData;
static LPCTSTR AFXPchNil = (LPCTSTR)(((BYTE*)&RGInitData)+sizeof(CSTRINGData));
// special function to make AFXEmptyString work even during initialization
const CSTRING& REMAFXAPI AFXGetEmptyString()
	{ return *(CSTRING*)&AFXPchNil; }


//////////////////////////////////////////////////////////////////////////////
// Construction/Destruction

CSTRING::CSTRING()
{
	Init();
}

CSTRING::CSTRING(const CSTRING& stringSrc)
{
	ASSERT(stringSrc.GetData()->nRefs != 0);
	if (stringSrc.GetData()->nRefs >= 0)
	{
		ASSERT(stringSrc.GetData() != AFXDataNil);
		m_pchData = stringSrc.m_pchData;
		InterlockedIncrement(&GetData()->nRefs);
	}
	else
	{
		Init();
		*this = stringSrc.m_pchData;
	}
}

CSTRING::CSTRING(LPCTSTR lpch, int nLength)
{
	Init();

	if (nLength != 0)
	{
//		ASSERT(AfxIsValidAddress(lpch, nLength, FALSE));
		AllocBuffer(nLength);
		memcpy(m_pchData, lpch, nLength*sizeof(TCHAR));
	}
}

void CSTRING::AllocBuffer(int nLen)
// always allocate one extra character for '\0' termination
// assumes [optimistically] that data length will equal allocation length
{
	ASSERT(nLen >= 0);
	ASSERT(nLen <= INT_MAX-1);    // max size (enough room for 1 extra)

	if (nLen == 0)
		Init();
	else
	{
		CSTRINGData* pData =
			(CSTRINGData*)new BYTE[sizeof(CSTRINGData) + (nLen+1)*sizeof(TCHAR)];
		pData->nRefs = 1;
		pData->data()[nLen] = '\0';
		pData->nDataLength = nLen;
		pData->nAllocLength = nLen;
		m_pchData = pData->data();
	}
}

void CSTRING::Release()
{
	if (GetData() != AFXDataNil)
	{
		ASSERT(GetData()->nRefs != 0);
		if (InterlockedDecrement(&GetData()->nRefs) <= 0)
			delete[] (BYTE*)GetData();
		Init();
	}
}

void PASCAL CSTRING::Release(CSTRINGData* pData)
{
	if (pData != AFXDataNil)
	{
		ASSERT(pData->nRefs != 0);
		if (InterlockedDecrement(&pData->nRefs) <= 0)
			delete[] (BYTE*)pData;
	}
}

void CSTRING::Empty()
{
	if (GetData()->nRefs >= 0)
		Release();
	else
		*this = &AFXChNil;
	ASSERT(GetData()->nDataLength == 0);
	ASSERT(GetData()->nRefs < 0 || GetData()->nAllocLength == 0);
}


void CSTRING::CopyBeforeWrite()
{
	if (GetData()->nRefs > 1)
	{
		CSTRINGData* pData = GetData();
		Release();
		AllocBuffer(pData->nDataLength);
		memcpy(m_pchData, pData->data(), (pData->nDataLength+1)*sizeof(TCHAR));
	}
	ASSERT(GetData()->nRefs <= 1);
}

void CSTRING::AllocBeforeWrite(int nLen)
{
	if (GetData()->nRefs > 1 || nLen > GetData()->nAllocLength)
	{
		Release();
		AllocBuffer(nLen);
	}
	ASSERT(GetData()->nRefs <= 1);
}

CSTRING::~CSTRING()
//  free any attached data
{
	if (GetData() != AFXDataNil)
	{
		if (InterlockedDecrement(&GetData()->nRefs) <= 0)
			delete[] (BYTE*)GetData();
	}
}

//////////////////////////////////////////////////////////////////////////////
// Helpers for the rest of the implementation

void CSTRING::AllocCopy(CSTRING& dest, int nCopyLen, int nCopyIndex,
	 int nExtraLen) const
{
	// will clone the data attached to this string
	// allocating 'nExtraLen' characters
	// Places results in uninitialized string 'dest'
	// Will copy the part or all of original data to start of new string

	int nNewLen = nCopyLen + nExtraLen;
	if (nNewLen == 0)
	{
		dest.Init();
	}
	else
	{
		dest.AllocBuffer(nNewLen);
		memcpy(dest.m_pchData, m_pchData+nCopyIndex, nCopyLen*sizeof(TCHAR));
	}
}

//////////////////////////////////////////////////////////////////////////////
// More sophisticated construction

CSTRING::CSTRING(LPCTSTR lpsz)
{
	Init();
//	if (lpsz != NULL && HIWORD(lpsz) == NULL)
//	{
//		UINT nID = LOWORD((DWORD)lpsz);
//		if (!LoadString(nID)) {
//			;// TRACE1("Warning: implicit LoadString(%u) failed\n", nID);
//		}
//	}
//	else
	{
		int nLen = SafeStrlen(lpsz);
		if (nLen != 0)
		{
			AllocBuffer(nLen);
			memcpy(m_pchData, lpsz, nLen*sizeof(TCHAR));
		}
	}
}

/////////////////////////////////////////////////////////////////////////////
// Special conversion constructors

#ifdef _UNICODE
CSTRING::CSTRING(LPCSTR lpsz)
{
	Init();
	int nSrcLen = lpsz != NULL ? lstrlenA(lpsz) : 0;
	if (nSrcLen != 0)
	{
		AllocBuffer(nSrcLen);
		_mbstowcsz(m_pchData, lpsz, nSrcLen+1);
		ReleaseBuffer();
	}
}
#else //_UNICODE
CSTRING::CSTRING(LPCWSTR lpsz)
{
	Init();
	int nSrcLen = lpsz != NULL ? LStrLenW(lpsz) : 0;
	if (nSrcLen != 0)
	{
		AllocBuffer(nSrcLen*2);
		_wcstombsz(m_pchData, lpsz, (nSrcLen*2)+1);
		ReleaseBuffer();
	}
}
#endif //!_UNICODE

//////////////////////////////////////////////////////////////////////////////
// Diagnostic support

//#ifdef _DEBUG
//CDumpContext& REMAFXAPI operator<<(CDumpContext& dc, const CSTRING& string)
//{
//	dc << string.m_pchData;
//	return dc;
//}
//#endif //_DEBUG

//////////////////////////////////////////////////////////////////////////////
// Assignment operators
//  All assign a new value to the string
//      (a) first see if the buffer is big enough
//      (b) if enough room, copy on top of old buffer, set size and type
//      (c) otherwise free old string data, and create a new one
//
//  All routines return the new string (but as a 'const CSTRING&') so that
//      assigning it again will cause a copy, eg: s1 = s2 = "hi there".
//

void CSTRING::AssignCopy(int nSrcLen, LPCTSTR lpszSrcData)
{
	AllocBeforeWrite(nSrcLen);
	memcpy(m_pchData, lpszSrcData, nSrcLen*sizeof(TCHAR));
	GetData()->nDataLength = nSrcLen;
	m_pchData[nSrcLen] = '\0';
}

const CSTRING& CSTRING::operator=(const CSTRING& stringSrc)
{
	if (m_pchData != stringSrc.m_pchData)
	{
		if ((GetData()->nRefs < 0 && GetData() != AFXDataNil) ||
			stringSrc.GetData()->nRefs < 0)
		{
			// actual copy necessary since one of the strings is locked
			AssignCopy(stringSrc.GetData()->nDataLength, stringSrc.m_pchData);
		}
		else
		{
			// can just copy references around
			Release();
			ASSERT(stringSrc.GetData() != AFXDataNil);
			m_pchData = stringSrc.m_pchData;
			InterlockedIncrement(&GetData()->nRefs);
		}
	}
	return *this;
}

const CSTRING& CSTRING::operator=(LPCTSTR lpsz)
{
//lts	ASSERT(lpsz == NULL || AfxIsValidString(lpsz, FALSE));
	AssignCopy(SafeStrlen(lpsz), lpsz);
	return *this;
}

/////////////////////////////////////////////////////////////////////////////
// Special conversion assignment

#ifdef _UNICODE
const CSTRING& CSTRING::operator=(LPCSTR lpsz)
{
	int nSrcLen = lpsz != NULL ? lstrlenA(lpsz) : 0;
	AllocBeforeWrite(nSrcLen);
	_mbstowcsz(m_pchData, lpsz, nSrcLen+1);
	ReleaseBuffer();
	return *this;
}
#else //!_UNICODE
const CSTRING& CSTRING::operator=(LPCWSTR lpsz)
{
	int nSrcLen = lpsz != NULL ? LStrLenW(lpsz) : 0;
	AllocBeforeWrite(nSrcLen*2);
	_wcstombsz(m_pchData, lpsz, (nSrcLen*2)+1);
	ReleaseBuffer();
	return *this;
}
#endif  //!_UNICODE

//////////////////////////////////////////////////////////////////////////////
// concatenation

// NOTE: "operator+" is done as friend functions for simplicity
//      There are three variants:
//          CSTRING + CSTRING
// and for ? = TCHAR, LPCTSTR
//          CSTRING + ?
//          ? + CSTRING

void CSTRING::ConcatCopy(int nSrc1Len, LPCTSTR lpszSrc1Data,
	int nSrc2Len, LPCTSTR lpszSrc2Data)
{
  // -- master concatenation routine
  // Concatenate two sources
  // -- assume that 'this' is a new CSTRING object

	int nNewLen = nSrc1Len + nSrc2Len;
	if (nNewLen != 0)
	{
		AllocBuffer(nNewLen);
		memcpy(m_pchData, lpszSrc1Data, nSrc1Len*sizeof(TCHAR));
		memcpy(m_pchData+nSrc1Len, lpszSrc2Data, nSrc2Len*sizeof(TCHAR));
	}
}

CSTRING REMAFXAPI operator+(const CSTRING& string1, const CSTRING& string2)
{
	CSTRING s;
	s.ConcatCopy(string1.GetData()->nDataLength, string1.m_pchData,
		string2.GetData()->nDataLength, string2.m_pchData);
	return s;
}

CSTRING REMAFXAPI operator+(const CSTRING& string, LPCTSTR lpsz)
{
//	ASSERT(lpsz == NULL || AfxIsValidString(lpsz, FALSE));
	CSTRING s;
	s.ConcatCopy(string.GetData()->nDataLength, string.m_pchData,
		CSTRING::SafeStrlen(lpsz), lpsz);
	return s;
}

CSTRING REMAFXAPI operator+(LPCTSTR lpsz, const CSTRING& string)
{
//	ASSERT(lpsz == NULL || AfxIsValidString(lpsz, FALSE));
	CSTRING s;
	s.ConcatCopy(CSTRING::SafeStrlen(lpsz), lpsz, string.GetData()->nDataLength,
		string.m_pchData);
	return s;
}

//////////////////////////////////////////////////////////////////////////////
// concatenate in place

void CSTRING::ConcatInPlace(int nSrcLen, LPCTSTR lpszSrcData)
{
	//  -- the main routine for += operators

	// if the buffer is too small, or we have a width mis-match, just
	//   allocate a new buffer (slow but sure)
	if (GetData()->nRefs > 1 || GetData()->nDataLength + nSrcLen > GetData()->nAllocLength)
	{
		// we have to grow the buffer, use the ConcatCopy routine
		CSTRINGData* pOldData = GetData();
		ConcatCopy(GetData()->nDataLength, m_pchData, nSrcLen, lpszSrcData);
		ASSERT(pOldData != NULL);
		CSTRING::Release(pOldData);
	}
	else
	{
		// fast concatenation when buffer big enough
		memcpy(m_pchData+GetData()->nDataLength, lpszSrcData, nSrcLen*sizeof(TCHAR));
		GetData()->nDataLength += nSrcLen;
		ASSERT(GetData()->nDataLength <= GetData()->nAllocLength);
		m_pchData[GetData()->nDataLength] = '\0';
	}
}

const CSTRING& CSTRING::operator+=(LPCTSTR lpsz)
{
//	ASSERT(lpsz == NULL || AfxIsValidString(lpsz, FALSE));
	ConcatInPlace(SafeStrlen(lpsz), lpsz);
	return *this;
}

const CSTRING& CSTRING::operator+=(TCHAR ch)
{
	ConcatInPlace(1, &ch);
	return *this;
}

const CSTRING& CSTRING::operator+=(const CSTRING& string)
{
	ConcatInPlace(string.GetData()->nDataLength, string.m_pchData);
	return *this;
}

/*
 * Length-sensitive comparison
 *
 *	NOTE: FEqual returns TRUE if the 2 CSTRINGS have the same length and contain
 *		  the same characters, and FALSE, otherwise.
 */

BOOL CSTRING::FEqual (const CSTRING &s2) const
{
	int						 length;

	// Compare the lengths first
	length = GetData()->nDataLength;
	if (length != s2.GetData()->nDataLength)
		return FALSE;

#ifdef _UNICODE
	// adjust the length in bytes
	length *= sizeof (TCHAR);
#endif

	/*
	 *	Now, compare the strings themselves
	 *	We use memcmp and not lstrcmp because the stings may
	 *	have embedded null characters.
	 */
	if (memcmp ((const void *) m_pchData, (const void *) s2.m_pchData, length))
		return FALSE;
	else
		return TRUE;
}

///////////////////////////////////////////////////////////////////////////////
// Advanced direct buffer access

LPTSTR CSTRING::GetBuffer(int nMinBufLength)
{
	ASSERT(nMinBufLength >= 0);

	if (GetData()->nRefs > 1 || nMinBufLength > GetData()->nAllocLength)
	{
		// we have to grow the buffer
		CSTRINGData* pOldData = GetData();
		int nOldLen = GetData()->nDataLength;   // AllocBuffer will tromp it
		if (nMinBufLength < nOldLen)
			nMinBufLength = nOldLen;
		AllocBuffer(nMinBufLength);
		memcpy(m_pchData, pOldData->data(), (nOldLen+1)*sizeof(TCHAR));
		GetData()->nDataLength = nOldLen;
		CSTRING::Release(pOldData);
	}
	ASSERT(GetData()->nRefs <= 1);

	// return a pointer to the character storage for this string
	ASSERT(m_pchData != NULL);
	return m_pchData;
}

void CSTRING::ReleaseBuffer(int nNewLength)
{
	CopyBeforeWrite();  // just in case GetBuffer was not called

	if (nNewLength == -1)
		nNewLength = lstrlen(m_pchData); // zero terminated

	ASSERT(nNewLength <= GetData()->nAllocLength);
	GetData()->nDataLength = nNewLength;
	m_pchData[nNewLength] = '\0';
}

LPTSTR CSTRING::GetBufferSetLength(int nNewLength)
{
	ASSERT(nNewLength >= 0);

	GetBuffer(nNewLength);
	GetData()->nDataLength = nNewLength;
	m_pchData[nNewLength] = '\0';
	return m_pchData;
}

void CSTRING::FreeExtra()
{
	ASSERT(GetData()->nDataLength <= GetData()->nAllocLength);
	if (GetData()->nDataLength != GetData()->nAllocLength)
	{
		CSTRINGData* pOldData = GetData();
		AllocBuffer(GetData()->nDataLength);
		memcpy(m_pchData, pOldData->data(), pOldData->nDataLength*sizeof(TCHAR));
		ASSERT(m_pchData[GetData()->nDataLength] == '\0');
		CSTRING::Release(pOldData);
	}
	ASSERT(GetData() != NULL);
}

LPTSTR CSTRING::LockBuffer()
{
	LPTSTR lpsz = GetBuffer(0);
	GetData()->nRefs = -1;
	return lpsz;
}

void CSTRING::UnlockBuffer()
{
	ASSERT(GetData()->nRefs == -1);
	if (GetData() != AFXDataNil)
		GetData()->nRefs = 1;
}

///////////////////////////////////////////////////////////////////////////////
// Commonly used routines (rarely used routines in STREX.CPP)


// find position of the first character match  (or -1 on failure)
int CSTRING::Find(TCHAR ch) const
{
	for (TCHAR * pch = m_pchData; _T('\0') != *pch; pch = CharNext(pch))
	{
		if (ch == *pch)
			return ((int)(pch - m_pchData) / sizeof(TCHAR));
	}
	return -1;
}

CSTRING CSTRING::Left(int nCount) const
{
        if (nCount < 0)
                nCount = 0;
        else if (nCount > GetData()->nDataLength)
                nCount = GetData()->nDataLength;

        CSTRING dest;
        AllocCopy(dest, nCount, 0, 0);
		return dest;
}

CSTRING CSTRING::Mid(int nFirst) const
{
	return Mid(nFirst, GetData()->nDataLength - nFirst);
}

CSTRING CSTRING::Mid(int nFirst, int nCount) const
{
	// out-of-bounds requests return sensible things
	if (nFirst < 0)
		nFirst = 0;
	if (nCount < 0)
		nCount = 0;

	if (nFirst + nCount > GetData()->nDataLength)
		nCount = GetData()->nDataLength - nFirst;
	if (nFirst > GetData()->nDataLength)
		nCount = 0;

	CSTRING dest;
	AllocCopy(dest, nCount, nFirst, 0);
	return dest;
}

void CSTRING::MakeUpper()
{
	CopyBeforeWrite();
	::CharUpper(m_pchData);
}

void CSTRING::MakeLower()
{
	CopyBeforeWrite();
	::CharLower(m_pchData);
}

void CSTRING::SetAt(int nIndex, TCHAR ch)
{
	ASSERT(nIndex >= 0);
	ASSERT(nIndex < GetData()->nDataLength);

	CopyBeforeWrite();
	m_pchData[nIndex] = ch;
}

#ifndef _UNICODE
void CSTRING::AnsiToOem()
{
	CopyBeforeWrite();
	::AnsiToOem(m_pchData, m_pchData);
}
#endif

///////////////////////////////////////////////////////////////////////////////
// CSTRING conversion helpers (these use the current system locale)

int REMAFX_CDECL _wcstombsz(char* mbstr, const wchar_t* wcstr, size_t count)
{
	if (count == 0 && mbstr != NULL)
		return 0;

	int result = ::WideCharToMultiByte(CP_ACP, 0, wcstr, -1,
		mbstr, count, NULL, NULL);
	ASSERT(mbstr == NULL || result <= (int)count);
	if (result > 0)
		mbstr[result-1] = 0;
	return result;
}

int REMAFX_CDECL _mbstowcsz(wchar_t* wcstr, const char* mbstr, size_t count)
{
	if (count == 0 && wcstr != NULL)
		return 0;

	int result = ::MultiByteToWideChar(CP_ACP, 0, mbstr, -1,
		wcstr, count);
	ASSERT(wcstr == NULL || result <= (int)count);
	if (result > 0)
		wcstr[result-1] = 0;
	return result;
}

LPWSTR REMAFXAPI AfxA2WHelper(LPWSTR lpw, LPCSTR lpa, int nChars)
{
	if (lpa == NULL)
		return NULL;
	ASSERT(lpw != NULL);
	// verify that no illegal character present
	// since lpw was allocated based on the size of lpa
	// don't worry about the number of chars
	lpw[0] = '\0';
//lts	VERIFY(MultiByteToWideChar(CP_ACP, 0, lpa, -1, lpw, nChars));
	MultiByteToWideChar(CP_ACP, 0, lpa, -1, lpw, nChars);
	return lpw;
}

LPSTR REMAFXAPI AfxW2AHelper(LPSTR lpa, LPCWSTR lpw, int nChars)
{
	if (lpw == NULL)
		return NULL;
	ASSERT(lpa != NULL);
	// verify that no illegal character present
	// since lpa was allocated based on the size of lpw
	// don't worry about the number of chars
	lpa[0] = '\0';
//lts	VERIFY(WideCharToMultiByte(CP_ACP, 0, lpw, -1, lpa, nChars, NULL, NULL));
	WideCharToMultiByte(CP_ACP, 0, lpw, -1, lpa, nChars, NULL, NULL);
	return lpa;
}

///////////////////////////////////////////////////////////////////////////////
BOOL CSTRING::LoadString(HINSTANCE hInstance, UINT nID)
{
	// try buffer size of 256, then larger size until entire string is retrieved
	int nSize = -1;
	int nLen;
	do
	{
		nSize += 256;
		nLen = ::LoadString(hInstance, nID, GetBuffer(nSize), nSize+1);
	} while (nLen == nSize);
	ReleaseBuffer();

	return nLen > 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\nmutil\combobox.cpp ===
// File: BitmapButton.cpp

#include "precomp.h"

#include "GenControls.h"

#include <windowsx.h>

CComboBox::CComboBox() :
    m_combo(NULL),
    m_hbrBack(NULL),
    m_hfText(NULL),
    m_pNotify(NULL)
{
}

CComboBox::~CComboBox()
{
	SetColors(NULL, 0, 0);
	SetFont(NULL);

	if (NULL != m_pNotify)
	{
		m_pNotify->Release();
		m_pNotify = NULL;
	}
}

BOOL CComboBox::Create(
	HWND hWndParent,			// Parent of the edit control
	UINT height,				// The height of the combo (with drop-down)
	DWORD dwStyle,				// Edit control style
	LPCTSTR szTitle,			// Initial text for the edit control
	IComboBoxChange *pNotify	// Object to notify of changes
	)
{
	if (!CFillWindow::Create(
		hWndParent,		// Window parent
		0,				// ID of the child window
		TEXT("NMComboBox"),	// Window name
		0,			// Window style; WS_CHILD|WS_VISIBLE will be added to this
		WS_EX_CONTROLPARENT		// Extended window style
		))
	{
		return(FALSE);
	}

	// Create the actual edit control and save it away
	m_combo = CreateWindowEx(0, TEXT("combobox"), szTitle,
		WS_CHILD|WS_VISIBLE|WS_TABSTOP|WS_VSCROLL|dwStyle,
		0, 0, 10, height, GetWindow(), 0,
		reinterpret_cast<HINSTANCE>(GetWindowLongPtr(hWndParent, GWLP_HINSTANCE)),
		NULL);

    //
    // We don't have a font yet, we can't set it.
    //

	m_pNotify = pNotify;
	if (NULL != m_pNotify)
	{
		m_pNotify->AddRef();
	}

	return(TRUE);
}

// Not actually implemented yet; should use the font to determine a size
void CComboBox::GetDesiredSize(SIZE *ppt)
{
	CFillWindow::GetDesiredSize(ppt);

	HWND combo = GetComboBox();
	if (NULL == combo)
	{
		return;
	}

	// ComboBoxes always size themselves to their desired size
	RECT rc;
	GetClientRect(combo, &rc);

	// Just pick a number
	ppt->cx += 100;
	ppt->cy += rc.bottom;
}

// HACKHACK georgep: This object now owns the brush
void CComboBox::SetColors(HBRUSH hbrBack, COLORREF back, COLORREF fore)
{
	// Store off the colors and brush
	if (NULL != m_hbrBack)
	{
		DeleteObject(m_hbrBack);
	}
	m_hbrBack = hbrBack;
	m_crBack = back;
	m_crFore = fore;

    HWND edit = GetEdit();
    if (NULL != edit)
    {
    	InvalidateRect(edit, NULL, TRUE);
    }
}

// HACKHACK georgep: This object now owns the font
void CComboBox::SetFont(HFONT hf)
{
	if (NULL != m_hfText)
	{
		DeleteObject(m_hfText);
	}
	m_hfText = hf;

	// Tell the edit control the font to use
    HWND edit = GetEdit();
	if (NULL != edit)
    {
	    FORWARD_WM_SETFONT(edit, hf, TRUE, ::SendMessage);
    }
}

LRESULT CComboBox::ProcessMessage(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)
{
	switch (message)
	{
		HANDLE_MSG(GetWindow(), WM_CTLCOLOREDIT, OnCtlColor);
		HANDLE_MSG(GetWindow(), WM_COMMAND     , OnCommand);
		HANDLE_MSG(GetWindow(), WM_NCDESTROY   , OnNCDestroy);

	case WM_SETFOCUS:
	{
		HWND edit = GetEdit();
		if (NULL != edit)
		{
			::SetFocus(edit);
		}
		break;
	}

	default:
		break;
	}

	return(CFillWindow::ProcessMessage(hwnd, message, wParam, lParam));
}

HBRUSH CComboBox::OnCtlColor(HWND hwnd, HDC hdc, HWND hwndChild, int type)
{
	// Do default processing if there is no brush
	if (NULL == m_hbrBack)
	{
		return(FORWARD_WM_CTLCOLOREDIT(hwnd, hdc, hwndChild, CFillWindow::ProcessMessage));
	}

	// Set the colors in the DC, and return the brush
	SetBkColor(hdc, m_crBack);
	SetTextColor(hdc, m_crFore);
	return(m_hbrBack);
}

// Sets the text for the control
void CComboBox::SetText(
	LPCTSTR szText	// The text to set
	)
{
	SetWindowText(GetEdit(), szText);
}

// Returns the number of items in the list
int CComboBox::GetNumItems()
{
    HWND combo = GetComboBox();
    int  numItems;

    if (combo)
    {
    	numItems = ComboBox_GetCount(combo);
    }
    else
    {
        numItems = 0;
    }

    return(numItems);
}

// Returns the index of the currently selected item
int CComboBox::GetSelectedIndex()
{
	return(ComboBox_GetCurSel(GetComboBox()));
}

// Sets the index of the currently selected item
void CComboBox::SetSelectedIndex(int index)
{
	ComboBox_SetCurSel(GetComboBox(), index);
}

// Gets the text for the control; returns the total text length
int CComboBox::GetText(
	LPTSTR szText,	// Where to put the text
	int nLen		// The length of the buffer
	)
{
	HWND edit = GetEdit();

	szText[0] = '\0';

	GetWindowText(edit, szText, nLen);
	return(GetWindowTextLength(edit));
}

int CComboBox::AddText(
	LPCTSTR pszText,	// The string to add
	LPARAM lUserData	// User data to associate with the string
	)
{
	HWND combo = GetComboBox();

	int index = ComboBox_AddString(combo, pszText);
	if (0 != lUserData && 0 <= index)
	{
		ComboBox_SetItemData(combo, index, lUserData);
	}

	return(index);
}

int CComboBox::GetText(
	UINT index,		// The index of the string to get
	LPTSTR pszText,	// The string buffer to fill
	int nLen		// User data to associate with the string
	)
{
	HWND combo = GetComboBox();

	int nActualLen = ComboBox_GetLBTextLen(combo, index);
	if (nActualLen >= nLen)
	{
		pszText[0] = '\0';
		return(nActualLen);
	}

	ComboBox_GetLBText(combo, index, pszText);
	return(nActualLen);
}

LPARAM CComboBox::GetUserData(
	int index	// The index of the user data to get
	)
{
	return(ComboBox_GetItemData(GetComboBox(), index));
}

// Removes an item from the list
void CComboBox::RemoveItem(
	UINT index	// The index of the item to remove
	)
{
	ComboBox_DeleteString(GetComboBox(), index);
}

void CComboBox::OnCommand(HWND hwnd, int id, HWND hwndCtl, UINT codeNotify)
{
	switch (codeNotify)
	{
	case CBN_EDITUPDATE:
		if (NULL != m_pNotify)
		{
			m_pNotify->OnTextChange(this);
		}
		break;

	case CBN_SETFOCUS:
		SetHotControl(this);
	case CBN_KILLFOCUS:
		if (NULL != m_pNotify)
		{
			m_pNotify->OnFocusChange(this, CBN_SETFOCUS==codeNotify);
		}
		break;

	case CBN_SELCHANGE:
		if (NULL != m_pNotify)
		{
			m_pNotify->OnSelectionChange(this);
		}
		break;
	}

	FORWARD_WM_COMMAND(hwnd, id, hwndCtl, codeNotify, CFillWindow::ProcessMessage);
}

void CComboBox::OnNCDestroy(HWND hwnd)
{
	if (NULL != m_pNotify)
	{
		m_pNotify->Release();
		m_pNotify = NULL;
	}

    m_combo = NULL;
	FORWARD_WM_NCDESTROY(hwnd, CFillWindow::ProcessMessage);
}

void CComboBox::Layout()
{
	HWND child = GetComboBox();
	if (NULL != child)
	{
		RECT rcClient;
		GetClientRect(GetWindow(), &rcClient);

		RECT rcDropped;
		ComboBox_GetDroppedControlRect(GetComboBox(), &rcDropped);

		SetWindowPos(child, NULL, 0, 0, rcClient.right, rcDropped.bottom-rcDropped.top, SWP_NOZORDER);
	}
}

// Get the info necessary for displaying a tooltip
void CComboBox::GetSharedTooltipInfo(TOOLINFO *pti)
{
	CFillWindow::GetSharedTooltipInfo(pti);

	// Since the child covers this whole area, we need to change the HWND to
	// hook
	HWND hwnd = GetChild();

	// HACKHACK georgep: Setting the tooltip on the first child of the combo
	// box, which should be the edit control
	if (NULL != hwnd)
	{
		hwnd = GetFirstChild(hwnd);
		if (NULL != hwnd)
		{
			pti->hwnd = hwnd;
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\nmutil\button.cpp ===
// File: BitmapButton.cpp

#include "precomp.h"

#include "GenControls.h"

#include <windowsx.h>

static const UINT IDT_FLASH = 1;
static const UINT FLASH_INTERVAL = 500;

CButton::CButton() :
	m_pNotify(NULL)
{
	m_sizeIcon.cx = 16;
	m_sizeIcon.cy = 16;
}

CButton::~CButton()
{
}

BOOL CButton::Create(
	HWND hWndParent,
	INT_PTR nId,
	LPCTSTR szTitle,
	DWORD dwStyle,
	IButtonChange *pNotify
	)
{
	if (!CFillWindow::Create(
		hWndParent,	// Window parent
		nId,		// ID of the child window
		szTitle,	// Window name
		0,			// Window style; WS_CHILD|WS_VISIBLE will be added to this
		WS_EX_CONTROLPARENT		// Extended window style
		))
	{
		return(FALSE);
	}

	m_pNotify = pNotify;
	if (NULL != m_pNotify)
	{
		m_pNotify->AddRef();
	}

	// Create the Win32 button
	CreateWindowEx(0, TEXT("button"), szTitle,
		dwStyle|WS_CHILD|WS_VISIBLE|BS_NOTIFY,
		0, 0, 10, 10,
		GetWindow(),
		reinterpret_cast<HMENU>(nId),
		reinterpret_cast<HINSTANCE>(GetWindowLongPtr(hWndParent, GWLP_HINSTANCE)),
		NULL);

	return(TRUE);
}

// Set the icon displayed with this button
void CButton::SetIcon(
	HICON hIcon	// The icon to use for this button
	)
{
	SendMessage(GetChild(), BM_SETIMAGE, IMAGE_ICON, reinterpret_cast<LPARAM>(hIcon));

	m_sizeIcon.cx = 16;
	m_sizeIcon.cy = 16;

	// If we actually stored an icon, get its info
	hIcon = GetIcon();
	if (NULL != hIcon)
	{
		ICONINFO iconinfo;
		if (GetIconInfo(hIcon, &iconinfo))
		{
			if (NULL != iconinfo.hbmColor)
			{
				CBitmapButton::GetBitmapSizes(&iconinfo.hbmColor, &m_sizeIcon, 1);
				DeleteObject(iconinfo.hbmColor);
			}
			if (NULL != iconinfo.hbmMask)
			{
				DeleteObject(iconinfo.hbmMask);
			}
		}
	}
}

// Get the icon displayed with this button
HICON CButton::GetIcon()
{
	return(reinterpret_cast<HICON>(SendMessage(GetChild(), BM_GETIMAGE, IMAGE_ICON, 0)));
}

// Set the bitmap displayed with this button
void CButton::SetBitmap(
	HBITMAP hBitmap	// The bitmap to use for this button
	)
{
	SendMessage(GetChild(), BM_SETIMAGE, IMAGE_BITMAP, reinterpret_cast<LPARAM>(hBitmap));
}

// Get the bitmap displayed with this button
HBITMAP CButton::GetBitmap()
{
	return(reinterpret_cast<HBITMAP>(SendMessage(GetChild(), BM_GETIMAGE, IMAGE_BITMAP, 0)));
}

// Get/set the checked state of the button
void CButton::SetChecked(
	BOOL bCheck	// TRUE if the button should be checked
	)
{
	Button_SetCheck(GetChild(), bCheck);
}

BOOL CButton::IsChecked()
{
	return(Button_GetCheck(GetChild()));
}

void CButton::GetDesiredSize(SIZE *psize)
{
	static const int DefDlgUnitWidth = 50;
	static const int DefDlgUnitHeight = 14;
	static const int PushButtonBorder = 4;
	static const int CheckLeftBorder = 5;
	static const int CheckOtherBorder = 1;

	HWND child = GetChild();

	SIZE sizeMinPush = { 0, 0 };
	*psize = sizeMinPush;

	DWORD dwStyle = GetWindowLong(GetChild(), GWL_STYLE);

	switch (dwStyle&(BS_ICON|BS_BITMAP))
	{
	case BS_ICON:
	{
		*psize = m_sizeIcon;
		break;
	}

	case BS_BITMAP:
	{
		HBITMAP hImg = GetBitmap();
		if (NULL == hImg)
		{
			break;
		}
		CBitmapButton::GetBitmapSizes(&hImg, psize, 1);
		break;
	}

	default: // Text
	{
		// HACKHACK georgep: Button text should not be too large
		TCHAR szTitle[80];
		GetWindowText(child, szTitle, ARRAY_ELEMENTS(szTitle));

		HDC hdc = GetDC(child);

		HFONT hf = GetWindowFont(child);
		HFONT hOld = reinterpret_cast<HFONT>(SelectObject(hdc, hf));

		GetTextExtentPoint(hdc, szTitle, lstrlen(szTitle), psize);

		TEXTMETRIC tm;
		GetTextMetrics(hdc, &tm);
		sizeMinPush.cx = tm.tmAveCharWidth * DefDlgUnitWidth  / 4;
		sizeMinPush.cy = tm.tmHeight       * DefDlgUnitHeight / 8;

		SelectObject(hdc, hOld);
		ReleaseDC(child, hdc);
		break;
	}
	}

	switch (dwStyle&(BS_PUSHBUTTON|BS_CHECKBOX|BS_RADIOBUTTON))
	{
	case BS_CHECKBOX:
	case BS_RADIOBUTTON:
	{
		psize->cx += CheckLeftBorder + GetSystemMetrics(SM_CXMENUCHECK) + CheckOtherBorder;
		psize->cy += CheckOtherBorder*2;

		int cy = GetSystemMetrics(SM_CYMENUCHECK);
		psize->cy = max(psize->cy, cy);
		break;
	}

	case BS_PUSHBUTTON:
	default:
		psize->cx += PushButtonBorder*2;
		psize->cy += PushButtonBorder*2;

		psize->cx = max(psize->cx, sizeMinPush.cx);
		psize->cy = max(psize->cy, sizeMinPush.cy);
		break;
	}
}

LRESULT CButton::ProcessMessage(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)
{
	switch (message)
	{
		HANDLE_MSG(hwnd, WM_COMMAND  , OnCommand);

	case WM_DESTROY:
		if (NULL != m_pNotify)
		{
			m_pNotify->Release();
			m_pNotify = NULL;
		}
		break;
	}

	return(CFillWindow::ProcessMessage(hwnd, message, wParam, lParam));
}

void CButton::OnCommand(HWND hwnd, int id, HWND hwndCtl, UINT codeNotify)
{
	// Change the HWND to this and forward to the parent
	HWND hwndThis = GetWindow();

	switch (codeNotify)
	{
	case BN_CLICKED:
		if (NULL != m_pNotify)
		{
			m_pNotify->OnClick(this);
			break;
		}
		FORWARD_WM_COMMAND(GetParent(hwndThis), id, hwndThis, codeNotify, ::SendMessage);
		break;

	case BN_SETFOCUS:
		SetHotControl(this);
		break;
	}
}

CBitmapButton::CBitmapButton() :
	m_hbStates(NULL),
	m_nInputStates(0),
	m_nCustomStates(0),
	m_nCustomState(0),
	m_bHot(FALSE),
	m_nFlashState(NoFlash)
{
}

CBitmapButton::~CBitmapButton()
{
	if (NULL != m_hbStates)
	{
		DeleteObject(m_hbStates);
		m_hbStates = NULL;
	}
}

BOOL CBitmapButton::Create(
	HWND hWndParent,	// The parent of the button
	int nId,			// The ID for WM_COMMAND messages
	HBITMAP hbStates,	// The 2D array of bitmaps for the states of the button,
						// vertically in the order specified in the StateBitmaps enum
						// and horizontally in the custom states order
	UINT nInputStates,	// The number of input states (Normal, Pressed, Hot, Disabled)
	UINT nCustomStates,	// The number of custom states
	IButtonChange *pNotify	// The click handler
	)
{
	// Copy the bitmap handle; note that we now own this bitmap, even if the
	// create fails
	m_hbStates = hbStates;

	// Must have a "normal" bitmap
	ASSERT(NULL!=hbStates && Normal<nInputStates && 1<=nCustomStates);

	if (!CButton::Create(
		hWndParent,		// Window parent
		nId,				// ID of the child window
		TEXT("NMButton"),	// Window name
		BS_OWNERDRAW|BS_NOTIFY|BS_PUSHBUTTON|WS_TABSTOP,	// Window style; WS_CHILD|WS_VISIBLE will be added to this
		pNotify
		))
	{
		return(FALSE);
	}

	m_nInputStates = nInputStates;
	m_nCustomStates = nCustomStates;

	return(TRUE);
}

// Creates the button, using the bitmaps specified
BOOL CBitmapButton::Create(
	HWND hWndParent,	// The parent of the button
	int nId,			// The ID for WM_COMMAND messages
	HINSTANCE hInst,	// The instance to load the bitmap from
	int nIdBitmap,		// The ID of the bitmap to use
	BOOL bTranslateColors,		// Use system background colors
	UINT nInputStates,	// The number of input states (Normal, Pressed, Hot, Disabled)
	UINT nCustomStates,			// The number of custom states
	IButtonChange *pNotify	// The click handler
	)
{
	HBITMAP hb;
	LoadBitmaps(hInst, &nIdBitmap, &hb, 1, bTranslateColors);

	return(Create(hWndParent, nId, hb, nInputStates, nCustomStates, pNotify));
}

// Return the size of the "normal" bitmap.
void CBitmapButton::GetDesiredSize(SIZE *ppt)
{
	// Note that I don't want CButton::GetDesiredSize
	CGenWindow::GetDesiredSize(ppt);

	BITMAP bm;

	// HACKHACK georgep: Only based on the normal bitmap
	if (NULL == m_hbStates || 0 == m_nInputStates || 0 == m_nCustomStates
		|| 0 == GetObject(m_hbStates, sizeof(BITMAP), &bm))
	{
		return;
	}

	ppt->cx += bm.bmWidth/m_nCustomStates;
	ppt->cy += bm.bmHeight/m_nInputStates;
}

#if FALSE
void DumpWindow(HWND hwnd, LPCTSTR pszPrefix)
{
	TCHAR szTemp[80];
	wsprintf(szTemp, TEXT("%s: %d "), pszPrefix, GetWindowLong(hwnd, GWL_ID));
	GetWindowText(hwnd, szTemp+lstrlen(szTemp), ARRAY_ELEMENTS(szTemp)-lstrlen(szTemp));
	lstrcat(szTemp, TEXT("\n"));
	OutputDebugString(szTemp);
}
#endif // FALSE

LRESULT CBitmapButton::ProcessMessage(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)
{
	switch (message)
	{
		HANDLE_MSG(hwnd, WM_DRAWITEM , OnDrawItem);
		HANDLE_MSG(hwnd, WM_SETCURSOR, OnSetCursor);
		HANDLE_MSG(hwnd, WM_TIMER    , OnTimer);

	case WM_ENABLE:
		SchedulePaint();
		break;
	}

	return(CButton::ProcessMessage(hwnd, message, wParam, lParam));
}

void CBitmapButton::OnDrawItem(HWND hwnd, const DRAWITEMSTRUCT * lpDrawItem)
{
	int nState = Normal;
	int state = lpDrawItem->itemState;

	// If pressed or selected, show the pressed bitmap
	if ((((state&ODS_DISABLED) == ODS_DISABLED) || !IsWindowEnabled(GetWindow())) && m_nInputStates > Disabled)
	{
		nState = Disabled;
	}
	// If pressed or selected, show the pressed bitmap
	else if ((state&ODS_SELECTED) == ODS_SELECTED && m_nInputStates > Pressed)
	{
		nState = Pressed;
	}
	// If hot, show the hot bitmap
	else if ((m_nFlashState != ForceNormal) && ((m_nFlashState == ForceHot) || IsHot()) && m_nInputStates > Hot)
	{
		nState = Hot;
	}
	// Otherwise show the normal bitmap
	else
	{
		nState = Normal;
	}

	// Draw in the upper left
	HDC hdcDraw = lpDrawItem->hDC;
	HDC hdcTemp = CreateCompatibleDC(hdcDraw);

	if (NULL != hdcTemp)
	{
		HPALETTE hPal = GetPalette();
		HPALETTE hOld = NULL;
		if (NULL != hPal)
		{
			hOld = SelectPalette(hdcDraw, hPal, TRUE);
			RealizePalette(hdcDraw);
			SelectPalette(hdcTemp, hPal, TRUE);
			RealizePalette(hdcTemp);
		}

		// This will tell me the size of an individual bitmap
		SIZE size;
		// Do not use an override
		CBitmapButton::GetDesiredSize(&size);

		if (NULL != SelectObject(hdcTemp, m_hbStates))
		{
			BitBlt(hdcDraw,
				lpDrawItem->rcItem.left, lpDrawItem->rcItem.top,
				size.cx, size.cy,
				hdcTemp, m_nCustomState*size.cx, nState*size.cy, SRCCOPY);

			// BUGBUG georgep: We should clear any "uncovered" area here
		}

		DeleteDC(hdcTemp);

		if (NULL != hPal)
		{
			SelectPalette(hdcDraw, hOld, TRUE);
		}
	}

	FORWARD_WM_DRAWITEM(hwnd, lpDrawItem, CButton::ProcessMessage);
}

BOOL CBitmapButton::OnSetCursor(HWND hwnd, HWND hwndCursor, UINT codeHitTest, UINT msg)
{
	SetHotControl(this);

	return(FORWARD_WM_SETCURSOR(hwnd,hwndCursor, codeHitTest, msg, CButton::ProcessMessage));
}

void CBitmapButton::SetCustomState(UINT nCustomState)
{
	ASSERT(m_nCustomState < m_nCustomStates);

	if (m_nCustomState == nCustomState)
	{
		// Nothing to do
		return;
	}

	m_nCustomState = nCustomState;
	SchedulePaint();
}

void CBitmapButton::SetHot(BOOL bHot)
{
	bHot = (bHot != FALSE);
	if (m_bHot == bHot)
	{
		return;
	}

	m_bHot = bHot;
	SchedulePaint();
}


// Change to flashing mode
void CBitmapButton::SetFlashing(int nSeconds)
{
	HWND hwndThis = GetWindow();

	if (0 == nSeconds)
	{
		KillTimer(hwndThis, IDT_FLASH);

		// This means to stop flashing
		if (IsFlashing())
		{
			m_nFlashState = NoFlash;
			SchedulePaint();
		}
	}
	else
	{
		if (NULL == hwndThis)
		{
			// I need a window to do this
			return;
		}

		m_endFlashing = GetTickCount() + nSeconds*1000;

		if (!IsFlashing())
		{
			SetTimer(hwndThis, IDT_FLASH, FLASH_INTERVAL, NULL);
			OnTimer(hwndThis, IDT_FLASH);
		}
	}
}

void CBitmapButton::OnTimer(HWND hwnd, UINT id)
{
	if (IDT_FLASH == id)
	{
		if (static_cast<int>(GetTickCount() - m_endFlashing) > 0)
		{
			SetFlashing(0);
		}
		else
		{
			m_nFlashState = (ForceNormal==m_nFlashState ? ForceHot : ForceNormal);
			SchedulePaint();
		}
	}
}

// Helper function for getting the sizes of an array of bitmaps
void CBitmapButton::GetBitmapSizes(HBITMAP parts[], SIZE sizes[], int nParts)
{
	for (--nParts; nParts>=0; --nParts)
	{
		if (NULL == parts[nParts])
		{
			sizes[nParts].cx = sizes[nParts].cy = 0;
			continue;
		}

		BITMAP bm;
		GetObject(parts[nParts], sizeof(bm), &bm);
		sizes[nParts].cx = bm.bmWidth;
		sizes[nParts].cy = bm.bmHeight;
	}
}

// I would really rather just use LoadImage with the proper flags, but it turns
// out that Win95 then tries to write into a read-only resource, which faults.
// So I have to make a copy of the BITMAPINFO with the color table and change
// it myself.
static HBITMAP MyLoadImage(HINSTANCE hInst, int id)
{
	// Load up the bitmap resource bits
	HRSRC hFound = FindResource(hInst, MAKEINTRESOURCE(id), RT_BITMAP);
	if (NULL == hFound)
	{
		return(NULL);
	}
	HGLOBAL hLoaded = LoadResource(hInst, hFound);
	if (NULL == hLoaded)
	{
		return(NULL);
	}

	HBITMAP ret = NULL;

	LPVOID lpBits = LockResource(hLoaded);
	if (NULL != lpBits)
	{
		BITMAPINFO *pbmi = reinterpret_cast<BITMAPINFO*>(lpBits);
		// create a "shortcut"
		BITMAPINFOHEADER &bmih = pbmi->bmiHeader;

		// Only deal with 8bpp, uncompressed image
		if (bmih.biSize == sizeof(BITMAPINFOHEADER)
			&& 1 == bmih.biPlanes
			&& BI_RGB == bmih.biCompression)
		{
			// Determine the length of the color table
			UINT nColors = bmih.biClrUsed;
			if (0 == nColors)
			{
				nColors = 1 << bmih.biBitCount;
			}
			ASSERT(nColors <= static_cast<UINT>(1<<bmih.biBitCount));

			// Make a copy of the BITMAPINFO and color table so I can change
			// the value of one of the table entries.
			struct
			{
				BITMAPINFO bmi;
				RGBQUAD rgb[256];
			} mbmi;
			CopyMemory(&mbmi, pbmi, sizeof(BITMAPINFOHEADER)+nColors*sizeof(RGBQUAD));

			// This is a "packed DIB" so the pixels are immediately after the
			// color table
			LPBYTE pPixels = reinterpret_cast<LPBYTE>(&pbmi->bmiColors[nColors]);
			BYTE byFirst = pPixels[0];
			switch (bmih.biBitCount)
			{
			case 8:
				break;

			case 4:
				byFirst = (byFirst >> 4) & 0x0f;
				break;

			case 1:
				byFirst = (byFirst >> 7) & 0x01;
				break;

			default:
				goto CleanUp;
			}
			ASSERT(static_cast<UINT>(byFirst) < nColors);

			// Change the value of the first pixel to be the 3DFace color
			RGBQUAD &rgbChange = mbmi.bmi.bmiColors[byFirst];
			COLORREF cr3DFace = GetSysColor(COLOR_3DFACE);
			rgbChange.rgbRed   = GetRValue(cr3DFace);
			rgbChange.rgbGreen = GetGValue(cr3DFace);
			rgbChange.rgbBlue  = GetBValue(cr3DFace);

			// Create the DIB section and copy the bits into it
			LPVOID lpDIBBits;
			ret = CreateDIBSection(NULL, &mbmi.bmi, DIB_RGB_COLORS,
				&lpDIBBits, NULL, 0);
			if (NULL != ret)
			{
				// Round the width up to the nearest DWORD
				int widthBytes = (bmih.biWidth*bmih.biBitCount+7)/8;
				widthBytes = (widthBytes+3)&~3;
				CopyMemory(lpDIBBits, pPixels, widthBytes*bmih.biHeight);
			}
		}

CleanUp:
		UnlockResource(hLoaded);
	}

	FreeResource(hLoaded);

	return(ret);
}

//Helper function for loading up a bunch of bitmaps
void CBitmapButton::LoadBitmaps(
	HINSTANCE hInst,	// The instance to load the bitmap from
	const int ids[],	// Array of bitmap ID's
	HBITMAP bms[],		// Array of HBITMAP's for storing the result
	int nBmps,			// Number of entries in the arrays
	BOOL bTranslateColors // Use system background colors
	)
{
	for (--nBmps; nBmps>=0; --nBmps)
	{
		if (0 == ids[nBmps])
		{
			bms[nBmps] = NULL;
		}
		else
		{
// #define TRYBMPFILE
#ifdef TRYBMPFILE
			bms[nBmps] = NULL;

			// This is useful for the designer to try out different bitmaps
			TCHAR szFile[80];
			wsprintf(szFile, TEXT("%d.bmp"), ids[nBmps]);

			if (((DWORD)-1) != GetFileAttributes(szFile))
			{
				int nLoadFlags = LR_CREATEDIBSECTION;

				if (bTranslateColors)
				{
					nLoadFlags |= LR_LOADMAP3DCOLORS|LR_LOADTRANSPARENT;
				}
				bms[nBmps] = (HBITMAP)LoadImage(_Module.GetModuleInstance(),
					szFile, IMAGE_BITMAP, 0, 0, nLoadFlags|LR_LOADFROMFILE);
			}

			if (NULL == bms[nBmps])
#endif // TRYBMPFILE
			{
				if (bTranslateColors)
				{
					//
					// LAURABU 2/21/99 -- LoadImage with translated colors only works
					// on Win9x if your resources
					// are NOT read-only, since Win9x tries to write into the resource
					// memory temporarily.  It faults if not.
					//
					bms[nBmps] = MyLoadImage(hInst, ids[nBmps]);
				}

				if (NULL == bms[nBmps])
				{
					bms[nBmps] = (HBITMAP)LoadImage(hInst,
						MAKEINTRESOURCE(ids[nBmps]), IMAGE_BITMAP, 0, 0, LR_CREATEDIBSECTION);
				}
			}
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\nmutil\dllutil.cpp ===
// File: dllutil.cpp

#include <precomp.h>
#include "dllutil.h"
#include "oprahcom.h"


/*  F  C H E C K  D L L  V E R S I O N  V E R S I O N  */
/*-------------------------------------------------------------------------
    %%Function: FCheckDllVersionVersion

    Make sure the dll is at least the specified version.
-------------------------------------------------------------------------*/
BOOL FCheckDllVersionVersion(LPCTSTR pszDll, DWORD dwMajor, DWORD dwMinor)
{
	DLLVERSIONINFO dvi;
	if (FAILED(HrGetDllVersion(pszDll, &dvi)))
		return FALSE;

	if (dwMajor > dvi.dwMajorVersion)
		return FALSE;

	if (dwMajor == dvi.dwMajorVersion)
	{
		if (dwMinor > dvi.dwMinorVersion)
			return FALSE;
	}

	// TODO: Add Platform check (DLLVER_PLATFORM_WINDOWS vs _NT)
	return TRUE;
}



/*  H R  G E T  D L L  V E R S I O N  */
/*-------------------------------------------------------------------------
    %%Function: HrGetDllVersion
    
    Return the version information for the DLL.
-------------------------------------------------------------------------*/
HRESULT HrGetDllVersion(LPCTSTR pszDll, DLLVERSIONINFO * pDvi)
{
	HRESULT hr;

	InitStruct(pDvi);

	HINSTANCE hInst = LoadLibrary(pszDll);
	if (NULL == hInst)
	{
		hr = E_FILE_NOT_FOUND; // file not found
	}
	else
	{
		DLLGETVERSIONPROC pDllGetVersion = (DLLGETVERSIONPROC)GetProcAddress(hInst, "DllGetVersion");
		if (NULL == pDllGetVersion)
		{
			hr = HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
		}
		else
		{
			hr = (*pDllGetVersion)(pDvi);

			WARNING_OUT(("Loaded %s (%d.%d.%d) %s", pszDll,
				pDvi->dwMajorVersion, pDvi->dwMinorVersion, pDvi->dwBuildNumber,
				(DLLVER_PLATFORM_NT == pDvi->dwPlatformID) ? "for NT" : "" ));
		}
		FreeLibrary(hInst);
	}

	return hr;
}


/*  H R  I N I T  L P F N  */
/*-------------------------------------------------------------------------
    %%Function: HrInitLpfn

    Attempt to load the library and the functions declared in the table.
-------------------------------------------------------------------------*/
HRESULT HrInitLpfn(APIFCN *pProcList, int cProcs, HINSTANCE* phLib, LPCTSTR pszDllName)
{
	bool bWeLoadedLibrary = false;

	if (NULL != pszDllName)
	{
		*phLib = LoadLibrary(pszDllName);
		if (NULL != *phLib)
		{
			bWeLoadedLibrary = true;
		}
	}

	if (NULL == *phLib)
	{
		return E_FILE_NOT_FOUND;
	}

	for (int i = 0; i < cProcs; i++)
	{
		*pProcList[i].ppfn = (LPVOID) GetProcAddress(*phLib, pProcList[i].szApiName);

		if (NULL == *pProcList[i].ppfn)
		{
			if (bWeLoadedLibrary)
			{
				FreeLibrary(*phLib);
			}
			return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
		}
	}

	return S_OK;
}


/*  N M  L O A D  L I B R A R Y  */
/*-------------------------------------------------------------------------
    %%Function: NmLoadLibrary
    
-------------------------------------------------------------------------*/
HINSTANCE NmLoadLibrary(LPCTSTR pszModule)
{
	TCHAR szPath[MAX_PATH];
	if (!GetInstallDirectory(szPath))
		return NULL;

	int cch = lstrlen(szPath);
	lstrcpyn(szPath+cch, pszModule, CCHMAX(szPath) - cch);

    return ::LoadLibraryEx(szPath, NULL, LOAD_WITH_ALTERED_SEARCH_PATH);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\nmutil\evtlog.cpp ===
#include "precomp.h"
#include <evtlog.h>

#define SRVC_NAME TEXT("mnmsrvc")
//
//  FUNCTION: AddToMessageLog(LPTSTR lpszMsg)
//
//  PURPOSE: Allows any thread to log an error message
//
//  PARAMETERS:
//    lpszMsg - text for message
//
//  RETURN VALUE:
//    none
//
//  COMMENTS:
//
VOID AddToMessageLog(WORD wType, WORD wCategory, DWORD dwEvtId, LPTSTR lpszMsg)
{
    HANDLE  hEventSource;
    LPTSTR  lpszStrings[2];
    int     cSz = 0;

    hEventSource = RegisterEventSource(NULL, SRVC_NAME);

    if (NULL != lpszMsg)
    {
        cSz = 1;
        lpszStrings[0] = lpszMsg;
    }

    if (hEventSource != NULL) {
        ReportEvent(hEventSource, // handle of event source
                    wType,                // event type
                    wCategory,            // event category
                    dwEvtId,              // event ID
                    NULL,                 // current user's SID
                    (WORD)cSz,            // strings in lpszStrings
                    0,                    // no bytes of raw data
                    0 == cSz ? NULL : (LPCTSTR*)&lpszStrings, // array of error strings
                    NULL);                // no raw data

        (VOID) DeregisterEventSource(hEventSource);
    }
}





=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\nmutil\edittext.cpp ===
// File: BitmapButton.cpp

#include "precomp.h"

#include "GenControls.h"

#include <windowsx.h>

CEditText::CEditText() : m_hbrBack(NULL), m_pNotify(NULL)
{
}

CEditText::~CEditText()
{
	SetColors(NULL, 0, 0);
	SetFont(NULL);

	if (NULL != m_pNotify)
	{
		m_pNotify->Release();
		m_pNotify = NULL;
	}
}

BOOL CEditText::Create(
	HWND hWndParent,			// Parent of the edit control
	DWORD dwStyle,				// Edit control style
	DWORD dwExStyle,			// Extended window style
	LPCTSTR szTitle,			// Initial text for the edit control
	IEditTextChange *pNotify	// Object to notify of changes
	)
{
	if (!CFillWindow::Create(
		hWndParent,		// Window parent
		0,				// ID of the child window
		TEXT("NMEditText"),	// Window name
		0,			// Window style; WS_CHILD|WS_VISIBLE will be added to this
		dwExStyle|WS_EX_CONTROLPARENT		// Extended window style
		))
	{
		return(FALSE);
	}

	// Create the actual edit control and save it away
	m_edit = CreateWindowEx(0, TEXT("edit"), szTitle,
		WS_CHILD|WS_VISIBLE|WS_TABSTOP|dwStyle,
		0, 0, 10, 10, GetWindow(), 0,
		reinterpret_cast<HINSTANCE>(GetWindowLongPtr(hWndParent, GWLP_HINSTANCE)),
		NULL);

	HWND edit = GetEdit();
	FORWARD_WM_SETFONT(edit, m_hfText, TRUE, ::SendMessage);

	m_pNotify = pNotify;
	if (NULL != m_pNotify)
	{
		m_pNotify->AddRef();
	}

	return(TRUE);
}

// Not actually implemented yet; should use the font to determine a size
void CEditText::GetDesiredSize(SIZE *ppt)
{
	CFillWindow::GetDesiredSize(ppt);
}

// HACKHACK georgep: This object now owns the brush
void CEditText::SetColors(HBRUSH hbrBack, COLORREF back, COLORREF fore)
{
	// Store off the colors and brush
	if (NULL != m_hbrBack)
	{
		DeleteObject(m_hbrBack);
	}
	m_hbrBack = hbrBack;
	m_crBack = back;
	m_crFore = fore;

	InvalidateRect(GetEdit(), NULL, TRUE);
}

// HACKHACK georgep: This object now owns the font
void CEditText::SetFont(HFONT hf)
{
	if (NULL != m_hfText)
	{
		DeleteObject(m_hfText);
	}
	m_hfText = hf;

	// Tell the edit control the font to use
	HWND edit = GetEdit();
	if (NULL != edit)
	{
		FORWARD_WM_SETFONT(edit, hf, TRUE, ::SendMessage);
	}
}

LRESULT CEditText::ProcessMessage(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)
{
	switch (message)
	{
		HANDLE_MSG(GetWindow(), WM_CTLCOLOREDIT, OnCtlColor);
		HANDLE_MSG(GetWindow(), WM_COMMAND     , OnCommand);
		HANDLE_MSG(GetWindow(), WM_NCDESTROY   , OnNCDestroy);
	}

	return(CFillWindow::ProcessMessage(hwnd, message, wParam, lParam));
}

HBRUSH CEditText::OnCtlColor(HWND hwnd, HDC hdc, HWND hwndChild, int type)
{
	// Do default processing if there is no brush
	if (NULL == m_hbrBack)
	{
		return(FORWARD_WM_CTLCOLOREDIT(hwnd, hdc, hwndChild, CFillWindow::ProcessMessage));
	}

	// Set the colors in the DC, and return the brush
	SetBkColor(hdc, m_crBack);
	SetTextColor(hdc, m_crFore);
	return(m_hbrBack);
}

// Sets the text for the control
void CEditText::SetText(
	LPCTSTR szText	// The text to set
	)
{
	SetWindowText(GetChild(), szText);
}

// Gets the text for the control; returns the total text length
int CEditText::GetText(
	LPTSTR szText,	// Where to put the text
	int nLen		// The length of the buffer
	)
{
	GetWindowText(GetChild(), szText, nLen);
	return(GetWindowTextLength(GetChild()));
}

void CEditText::OnCommand(HWND hwnd, int id, HWND hwndCtl, UINT codeNotify)
{
	switch (codeNotify)
	{
	case EN_UPDATE:
		if (NULL != m_pNotify)
		{
			m_pNotify->OnTextChange(this);
		}
		break;

	case EN_SETFOCUS:
		SetHotControl(this);
	case EN_KILLFOCUS:
		if (NULL != m_pNotify)
		{
			m_pNotify->OnFocusChange(this, EN_SETFOCUS==codeNotify);
		}
		break;
	}

	FORWARD_WM_COMMAND(hwnd, id, hwndCtl, codeNotify, CFillWindow::ProcessMessage);
}

void CEditText::OnNCDestroy(HWND hwnd)
{
	if (NULL != m_pNotify)
	{
		m_pNotify->Release();
		m_pNotify = NULL;
	}

	FORWARD_WM_NCDESTROY(hwnd, CFillWindow::ProcessMessage);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\nmutil\custring.cpp ===
// CUSTRING.CPP
//
// Implementation of the CUSTRING class, a lightweight class used to convert
// strings seamlessly between ANSI and Unicode.
//
// Derived from STRCORE.CPP.

#include "precomp.h"
#include <oprahcom.h>
#include <cstring.hpp>

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


CUSTRING::CUSTRING(PCWSTR wszText) : 
	wszData((PWSTR)wszText), 
	szData(NULL), 
	bUnicodeNew(FALSE),
	bAnsiNew(FALSE)
{
	// AssignString;
}

CUSTRING::CUSTRING(PCSTR szText) : 
	szData((PSTR)szText), 
	wszData(NULL), 
	bUnicodeNew(FALSE),
	bAnsiNew(FALSE)
{
	// AssignString;
}

CUSTRING::~CUSTRING()
{
	if (bUnicodeNew) {
		delete wszData;
	}
	if (bAnsiNew) {
		delete szData;
	}
}

CUSTRING::operator PWSTR()
{ 
	if (szData && !wszData) {
		wszData = AnsiToUnicode(szData);
		bUnicodeNew = TRUE;
	}
	return wszData;
}

CUSTRING::operator PSTR()
{ 
	if (wszData && !szData) {
		szData = UnicodeToAnsi(wszData);
		bAnsiNew = TRUE;
	}
	return szData;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\nmutil\debspew.cpp ===
// File: DebSpew.cpp

#include "precomp.h"
#include <confreg.h>
#include <RegEntry.h>


#ifdef DEBUG /* THE WHOLE FILE! */

#if defined (_M_IX86)
#define _DbgBreak()  __asm { int 3 }
#else
#define _DbgBreak() DebugBreak()
#endif

/* Types
 ********/

PCSTR g_pcszSpewModule = NULL;

/* debug flags */

typedef enum _debugdebugflags
{
   DEBUG_DFL_ENABLE_TRACE_MESSAGES  = 0x0001,

   DEBUG_DFL_LOG_TRACE_MESSAGES     = 0x0002,

   DEBUG_DFL_ENABLE_CALL_TRACING    = 0x0008,

   DEBUG_DFL_INDENT                 = 0x2000,

   ALL_DEBUG_DFLAGS                 = (DEBUG_DFL_ENABLE_TRACE_MESSAGES |
                                       DEBUG_DFL_LOG_TRACE_MESSAGES |
                                       DEBUG_DFL_ENABLE_CALL_TRACING |
                                       DEBUG_DFL_INDENT)
}
DEBUGDEBUGFLAGS;


/* Global Variables
 *******************/


#pragma data_seg(DATA_SEG_PER_INSTANCE)

/* parameters used by SpewOut() */

DWORD g_dwSpewFlags = 0;
UINT g_uSpewSev = 0;
UINT g_uSpewLine = 0;
PCSTR g_pcszSpewFile = NULL;

HDBGZONE  ghDbgZone = NULL;


/* TLS slot used to store stack depth for SpewOut() indentation */

#ifdef _DBGSTACK
DWORD s_dwStackDepthSlot = TLS_OUT_OF_INDEXES;

/* hack stack depth counter used until s_dwStackDepthSlot is not available */

ULONG_PTR s_ulcHackStackDepth = 0;
#endif

/* debug flags */

DWORD s_dwDebugModuleFlags = 0;

#pragma data_seg()



/***************************** Private Functions *****************************/

/* Module Prototypes
 ********************/

BOOL IsValidSpewSev(UINT);


/*
** IsValidSpewSev()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
BOOL IsValidSpewSev(UINT uSpewSev)
{
   BOOL bResult;

   switch (uSpewSev)
   {
      case SPEW_TRACE:
      case SPEW_CALLTRACE:
      case SPEW_WARNING:
      case SPEW_ERROR:
      case SPEW_FATAL:
         bResult = TRUE;
         break;

      default:
         ERROR_OUT(("IsValidSpewSev(): Invalid debug spew severity %u.",
                    uSpewSev));
         bResult = FALSE;
         break;
   }

   return(bResult);
}


/****************************** Public Functions *****************************/


DWORD NMINTERNAL GetDebugOutputFlags(VOID)
{
	return s_dwDebugModuleFlags;
}

VOID NMINTERNAL SetDebugOutputFlags(DWORD dw)
{
	ASSERT(FLAGS_ARE_VALID(dw, ALL_DEBUG_DFLAGS));
	s_dwDebugModuleFlags = dw;

	// Save changed data back to registry
	RegEntry re(DEBUG_KEY, HKEY_LOCAL_MACHINE);
	re.SetValue(REGVAL_DBG_SPEWFLAGS, dw);
}


/*
** InitDebugModule()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
BOOL NMINTERNAL InitDebugModule(PCSTR pcszSpewModule)
{
	RegEntry re(DEBUG_KEY, HKEY_LOCAL_MACHINE);

	s_dwDebugModuleFlags = re.GetNumber(REGVAL_DBG_SPEWFLAGS, DEFAULT_DBG_SPEWFLAGS);


   g_pcszSpewModule = pcszSpewModule;

#ifdef _DBGSTACK

   ASSERT(s_dwStackDepthSlot == TLS_OUT_OF_INDEXES);

   s_dwStackDepthSlot = TlsAlloc();

   if (s_dwStackDepthSlot != TLS_OUT_OF_INDEXES)
   {
      EVAL(TlsSetValue(s_dwStackDepthSlot, (PVOID)s_ulcHackStackDepth));

      TRACE_OUT(("InitDebugModule(): Using thread local storage slot %lu for debug stack depth counter.",
                 s_dwStackDepthSlot));
   }
   else
	{
      WARNING_OUT(("InitDebugModule(): TlsAlloc() failed to allocate thread local storage for debug stack depth counter."));
	}
#endif

	if (NULL == ghDbgZone)
	{
		PSTR rgsz[4];
		rgsz[0] = (PSTR) pcszSpewModule;

		ASSERT(0 == ZONE_WARNING);
		rgsz[1+ZONE_WARNING]  = "Warning";

		ASSERT(1 == ZONE_TRACE);
		rgsz[1+ZONE_TRACE]    = "Trace";

		ASSERT(2 == ZONE_FUNCTION);
		rgsz[1+ZONE_FUNCTION] = "Function";

		// Initialize standard debug settings with warning enabled by default
		DbgInitEx(&ghDbgZone, rgsz, 3, 0x01);
	}

	return TRUE;
}


/*
** ExitDebugModule()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
void NMINTERNAL ExitDebugModule(void)
{
#ifdef _DBGSTACK

   if (s_dwStackDepthSlot != TLS_OUT_OF_INDEXES)
   {
      s_ulcHackStackDepth = ((ULONG_PTR)TlsGetValue(s_dwStackDepthSlot));

      /* Leave s_ulcHackStackDepth == 0 if TlsGetValue() fails. */

      EVAL(TlsFree(s_dwStackDepthSlot));
      s_dwStackDepthSlot = TLS_OUT_OF_INDEXES;
   }
#endif
	g_pcszSpewModule = NULL;
	DBGDEINIT(&ghDbgZone);
}


/*
** StackEnter()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
void NMINTERNAL StackEnter(void)
{
#ifdef _DBGSTACK

   if (s_dwStackDepthSlot != TLS_OUT_OF_INDEXES)
   {
      ULONG_PTR ulcDepth;

      ulcDepth = ((ULONG_PTR)TlsGetValue(s_dwStackDepthSlot));

      ASSERT(ulcDepth < ULONG_MAX);

      EVAL(TlsSetValue(s_dwStackDepthSlot, (PVOID)(ulcDepth + 1)));
   }
   else
   {
      ASSERT(s_ulcHackStackDepth < ULONG_MAX);
      s_ulcHackStackDepth++;
   }
#endif
   return;
}


/*
** StackLeave()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
void NMINTERNAL StackLeave(void)
{
#ifdef _DBGSTACK

   if (s_dwStackDepthSlot != TLS_OUT_OF_INDEXES)
   {
      ULONG_PTR ulcDepth;

      ulcDepth = ((ULONG_PTR)TlsGetValue(s_dwStackDepthSlot));

      if (EVAL(ulcDepth > 0))
         EVAL(TlsSetValue(s_dwStackDepthSlot, (PVOID)(ulcDepth - 1)));
   }
   else
   {
      if (EVAL(s_ulcHackStackDepth > 0))
         s_ulcHackStackDepth--;
   }
#endif
   return;
}


/*
** GetStackDepth()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
ULONG_PTR NMINTERNAL GetStackDepth(void)
{
   ULONG_PTR ulcDepth = 0;
#ifdef _DBGSTACK

   if (s_dwStackDepthSlot != TLS_OUT_OF_INDEXES)
      ulcDepth = (ULONG)((ULONG_PTR)TlsGetValue(s_dwStackDepthSlot));
   else
      ulcDepth = s_ulcHackStackDepth;
#endif
   return(ulcDepth);
}



/*  _  D B G  Z  P R I N T  M S G  */
/*-------------------------------------------------------------------------
    %%Function: _DbgZPrintMsg

-------------------------------------------------------------------------*/
static VOID _DbgZPrintMsg(UINT iZone, PSTR pszFormat, va_list arglist)
{
	PCSTR pcszSpewPrefix;
	char  szModule[128];

    if (g_pcszSpewModule)
    {
    	switch (iZone)
	 	{
        	case ZONE_TRACE:
		        pcszSpewPrefix = "Trace";
        		break;
        	case ZONE_FUNCTION:
		        pcszSpewPrefix = "Func ";
        		break;
        	case ZONE_WARNING:
		        pcszSpewPrefix = "Warn ";
        		break;
        	default:
		        pcszSpewPrefix = "?????";
        		break;
		}

    	wsprintfA(szModule, "%s:%s", g_pcszSpewModule, pcszSpewPrefix);
    }
    else
    {
        // No module nonsense, empty prefix
        wsprintfA(szModule, "%s", "");
    }

	if (IS_FLAG_CLEAR(s_dwDebugModuleFlags, DEBUG_DFL_INDENT))
	{
		// Don't indent output
		DbgPrintf(szModule, pszFormat, arglist);
	}
	else
	{
		PCSTR pcszIndent;
		ULONG_PTR ulcStackDepth;
		char  szFormat[512];
		static char _szSpewLeader[] = "                                                                                ";

		ulcStackDepth = GetStackDepth();
		if (ulcStackDepth > sizeof(_szSpewLeader))
			ulcStackDepth = sizeof(_szSpewLeader);

		pcszIndent = _szSpewLeader + sizeof(_szSpewLeader) - ulcStackDepth;

		wsprintfA(szFormat, "%s%s", pcszIndent, pszFormat);
		DbgPrintf(szModule, szFormat, arglist);
	}
}


VOID WINAPI DbgZPrintError(PSTR pszFormat,...)
{
    va_list v1;
    va_start(v1, pszFormat);

    _DbgZPrintMsg(ZONE_WARNING, pszFormat, v1);
    va_end(v1);

    _DbgBreak();
}


VOID WINAPI DbgZPrintWarning(PSTR pszFormat,...)
{
	if (GETZONEMASK(ghDbgZone) & ZONE_WARNING_FLAG)
	{
		va_list v1;
		va_start(v1, pszFormat);
		
		_DbgZPrintMsg(ZONE_WARNING, pszFormat, v1);
		va_end(v1);
	}
}

VOID WINAPI DbgZPrintTrace(PSTR pszFormat,...)
{
	if (GETZONEMASK(ghDbgZone) & ZONE_TRACE_FLAG)
	{
		va_list v1;
		va_start(v1, pszFormat);
		_DbgZPrintMsg(ZONE_TRACE, pszFormat, v1);
		va_end(v1);
	}
}

VOID WINAPI DbgZPrintFunction(PSTR pszFormat,...)
{
	if (GETZONEMASK(ghDbgZone) & ZONE_FUNCTION_FLAG)
	{
		va_list v1;
		va_start(v1, pszFormat);
		_DbgZPrintMsg(ZONE_FUNCTION, pszFormat, v1);
		va_end(v1);
	}
}



#endif   /* DEBUG */


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\nmutil\dbg.cpp ===
/* dbg.cpp */

#include "precomp.h"
#include <oprahcom.h>
#include <cstring.hpp>
#include <regentry.h>
#include <confreg.h>
#include <confdbg.h>

#include <avUtil.h>


PSECURITY_DESCRIPTOR CreateSd( VOID);
BOOL CreateSids(  PSID *BuiltInAdministrators, PSID *PowerUsers, PSID *AuthenticatedUsers);

#ifdef NM_DEBUG  /* Almost the whole file */

// Special Debugbreak macro
#if defined (_M_IX86)
#define _DbgBreak()  __asm { int 3 }
#else
#define _DbgBreak() DebugBreak()
#endif

// Special Mutex Macros
#define ACQMUTEX(hMutex)	WaitForSingleObject(hMutex, INFINITE)
#define RELMUTEX(hMutex)	ReleaseMutex(hMutex)

// Constant for GlobalAddAtom
const int CCHMAX_ATOM = 255;

// Local Variables
static PNMDBG    _gpDbg = NULL;            // Shared data in mmf after zone info
static HANDLE    _ghMutexFile = NULL;      // Mutex for writing to file
static PZONEINFO _gprgZoneInfo = NULL;     // the address in which the zone is mapped,points to an array of zones
static HANDLE    _ghDbgZoneMap = NULL;     // the handle of the memory mapped file for zones
static HANDLE    _ghDbgZoneMutex = NULL;   // Mutex for accessing Zone information
static long      _gLockCount = 0;

VOID DbgCurrentTime(PCHAR psz);


/*  _  D B G  P R I N T F  */
/*-------------------------------------------------------------------------
    %%Function: _DbgPrintf

    The main, low level, debug output routine.
-------------------------------------------------------------------------*/
static VOID WINAPI _DbgPrintf(LPCSTR pszFile, PCSTR pszPrefix, PCSTR pszFormat, va_list ap)
{
	CHAR  szOutput[1024];
	PCHAR pszOutput = szOutput;
	UINT  cch;

	if (NULL == _gprgZoneInfo)
		return;

	if (DBG_FMTTIME_NONE != _gpDbg->uShowTime)
	{
		DbgCurrentTime(pszOutput);
		pszOutput += lstrlenA(pszOutput);
	}

	if (_gpDbg->fShowThreadId)
	{
		wsprintfA(pszOutput, "[%04X] ", GetCurrentThreadId());
		pszOutput += lstrlenA(pszOutput);
	}

	if (_gpDbg->fShowModule)
	{
		CHAR szFile[MAX_PATH];

		if ((NULL == pszPrefix) || ('\0' == *pszPrefix))
		{
			GetModuleFileNameA(NULL, szFile, sizeof(szFile));
			pszPrefix = ExtractFileNameA(szFile);
		}

		lstrcpyA(pszOutput, pszPrefix);
		pszOutput += lstrlenA(pszOutput);
		lstrcpyA(pszOutput, " ");
		pszOutput += 1;
	}

	wvsprintfA(pszOutput, pszFormat, ap);


	// Append carriage return, if necessary
	// WARNING: This code is not DBCS-safe.
	cch = lstrlenA(szOutput);
	if (szOutput[cch-1] == '\n')
	{
		if (szOutput[cch-2] != '\r')
		{
			lstrcpyA(&szOutput[cch-1], "\r\n");
			cch++;
		}
	}
	else
	{
		lstrcpyA(&szOutput[cch], "\r\n");
		cch += 2;
	}


	// Output to debug handler
	if (_gpDbg->fOutputDebugString)
	{
		OutputDebugStringA(szOutput);
	}


	// Output to File
	if (_gpDbg->fFileOutput || (NULL != pszFile))
	{
		HANDLE hFile;
		DWORD dw;

		// Lock access to file
		ACQMUTEX(_ghMutexFile);

		if (NULL == pszFile)
			pszFile = _gpDbg->szFile;

		// open a log file for appending. create if does not exist
		hFile = CreateFileA(pszFile, GENERIC_WRITE, 0, NULL,
			OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, (HANDLE)NULL);
		if (hFile != INVALID_HANDLE_VALUE)
		{
			// seek to end of file
			dw = SetFilePointer(hFile, 0, NULL, FILE_END);

#ifdef TEST /* Test/Retail version truncates at 40K */
			if (dw > 0x040000)
			{
				CloseHandle(hFile);
				hFile = CreateFileA(pszFile, GENERIC_WRITE, 0, NULL,
					TRUNCATE_EXISTING, FILE_ATTRIBUTE_NORMAL, (HANDLE)NULL);
			}										
			if (INVALID_HANDLE_VALUE != hFile)
#endif
			{
				WriteFile(hFile, szOutput, lstrlenA(szOutput), &dw, NULL);
				CloseHandle(hFile);
			}
		}

		// Unlock access to file
		RELMUTEX(_ghMutexFile);
	}

	// Output to viewer.  This is at the end of the function because
	// we potentially truncate szOutput.
	if ((_gpDbg->fWinOutput) && (NULL != _gpDbg->hwndCtrl))
	{
		// Make sure that the string doesn't exceed the maximum atom size.
		// WARNING: This code is not DBCS-safe.
		static const CHAR szTruncatedSuffix[] = "...\r\n";
		static const int cchTruncatedSuffix = ARRAY_ELEMENTS(szTruncatedSuffix) - 1;

		if (CCHMAX_ATOM < cch)
		{
			lstrcpyA(&szOutput[CCHMAX_ATOM - cchTruncatedSuffix], szTruncatedSuffix);
		}

		ATOM aDbgAtom = GlobalAddAtomA(szOutput);

		if (aDbgAtom)
		{
			if (!PostMessage(_gpDbg->hwndCtrl, _gpDbg->msgDisplay, (WPARAM)aDbgAtom, 0L))
			{
				// Unable to post Message, so free the atom
				GlobalDeleteAtom(aDbgAtom);
			}
		}
	}

}


PSTR WINAPI DbgZPrintf(HDBGZONE hZone, UINT iZone, PSTR pszFormat,...)
{
	CHAR sz[MAXSIZE_OF_MODULENAME+MAXSIZE_OF_ZONENAME+1];
	PCHAR psz;
	va_list v1;
	va_start(v1, pszFormat);

	if ((NULL != hZone) && (iZone < MAXNUM_OF_ZONES))
	{
	    wsprintfA(sz, "%hs:%hs", ((PZONEINFO) hZone)->pszModule, ((PZONEINFO) hZone)->szZoneNames[iZone]);
	    psz = sz;
	}
	else
	{
		psz = NULL;
	}


	if ((NULL != hZone) && ('\0' != ((PZONEINFO) hZone)->szFile[0]))
	{
		// Use the private module output filename, if specified
		_DbgPrintf(((PZONEINFO) hZone)->szFile, psz, pszFormat, v1);
	}
	else
	{
		_DbgPrintf(NULL, psz, pszFormat, v1);
	}
	
	va_end(v1);
	return pszFormat;
}


PSTR WINAPI DbgZVPrintf(HDBGZONE hZone, UINT iZone, PSTR pszFormat, va_list ap)
{
	CHAR sz[MAXSIZE_OF_MODULENAME+MAXSIZE_OF_ZONENAME+1];
	PCHAR psz;

	if ((NULL != hZone) && (iZone < MAXNUM_OF_ZONES))
	{
	    wsprintfA(sz, "%hs:%hs", ((PZONEINFO) hZone)->pszModule, ((PZONEINFO) hZone)->szZoneNames[iZone]);
	    psz = sz;
	}
	else
	{
		psz = NULL;
	}


	if ((NULL != hZone) && ('\0' != ((PZONEINFO) hZone)->szFile[0]))
	{
		// Use the private module output filename, if specified
		_DbgPrintf(((PZONEINFO) hZone)->szFile, psz, pszFormat, ap);
	}
	else
	{
		_DbgPrintf(NULL, psz, pszFormat, ap);
	}
	
	return pszFormat;
}


VOID WINAPI DbgPrintf(PCSTR pszPrefix, PCSTR pszFormat, va_list ap)
{
	_DbgPrintf(NULL, pszPrefix, pszFormat, ap);
}


VOID NMINTERNAL DbgInitEx(HDBGZONE * phDbgZone, PCHAR * psz, UINT cZones, long ulZoneDefault)
{
	UINT i;
	HDBGZONE hDbgZone;
	DBGZONEINFO dbgZoneParm;

	//DbgMsg("Module %s (%d zones)", *psz, cZones);

	InterlockedIncrement( &_gLockCount );

	InitDbgZone();

	if (cZones > MAXNUM_OF_ZONES)
		cZones = MAXNUM_OF_ZONES;


	ZeroMemory(&dbgZoneParm, sizeof(dbgZoneParm));
	
	// First string is the module name
	lstrcpynA(dbgZoneParm.pszModule, *psz, CCHMAX(dbgZoneParm.pszModule));

	// Copy the zone names
	for (i = 0; i < cZones; i++)
	{
		lstrcpynA(dbgZoneParm.szZoneNames[i], psz[1+i], CCHMAX(dbgZoneParm.szZoneNames[0]));
	}

	// Get the detault zone settings
	{
		RegEntry reZones(ZONES_KEY, HKEY_LOCAL_MACHINE);
		dbgZoneParm.ulZoneMask = reZones.GetNumber(CUSTRING(dbgZoneParm.pszModule), ulZoneDefault);
	}

	hDbgZone = NmDbgCreateZone(dbgZoneParm.pszModule);
	if (NULL == hDbgZone)
	{
		OutputDebugStringA("DbgInit: Failed to create zones!\r\n");
		return;
	}

	NmDbgSetZone(hDbgZone, &dbgZoneParm);
	*phDbgZone = hDbgZone;
}


VOID NMINTERNAL DbgDeInit(HDBGZONE * phDbgZone)
{
	if (NULL == phDbgZone)
		return;

	if (NULL == *phDbgZone)
		return;

	//DbgMsg("Freeing Zone [%s]",((PZONEINFO)(*phDbgZone))->pszModule);

	NmDbgDeleteZone("", *phDbgZone);
	*phDbgZone = NULL;

    if( 0 == InterlockedDecrement( &_gLockCount ) )
    {
        UnMapDebugZoneArea();

        if( _ghMutexFile )
        {
            CloseHandle( _ghMutexFile );
            _ghMutexFile = NULL;
        }

        if( _ghDbgZoneMutex )
        {
            CloseHandle( _ghDbgZoneMutex );
            _ghDbgZoneMutex = NULL;
        }
    }
}




//////////////////////////////////////////////////////////////////////////////////
// from dbgzone.cpp



/***************************************************************************

	Name      :	NmDbgCreateZones

	Purpose   :	A module calls this to allocate/initialize the zone area for debugging
				purposes.

	Parameters:	pszName - the name of the module

	Returns   :	

	Comment   :	

***************************************************************************/
HDBGZONE WINAPI NmDbgCreateZone(LPSTR pszName)
{

	PZONEINFO pZoneInfo=NULL;

 	if (!(pZoneInfo = FindZoneForModule(pszName)))
	 	pZoneInfo = AllocZoneForModule(pszName);
	return ((HDBGZONE)pZoneInfo);
}


/***************************************************************************

	Name      :	NmDbgDeleteZones

	Purpose   :	

	Parameters:	

	Returns   :	

	Comment   :	

***************************************************************************/
void WINAPI NmDbgDeleteZone(LPSTR pszName, HDBGZONE hDbgZone)
{
	//decrement reference count
	PZONEINFO pZoneInfo = (PZONEINFO)hDbgZone;

    ASSERT( _ghDbgZoneMutex );

	ACQMUTEX(_ghDbgZoneMutex);

	if (pZoneInfo)
	{
		pZoneInfo->ulRefCnt--;
		if (pZoneInfo->ulRefCnt == 0)
		{
			pZoneInfo->bInUse = FALSE;
			pZoneInfo->ulSignature = 0;
		}
	}

	RELMUTEX(_ghDbgZoneMutex);
}



/***************************************************************************

	Name      :	NmDbgSetZones

	Purpose   :	

	Parameters:	

	Returns   :	

	Comment   :	

***************************************************************************/
BOOL WINAPI NmDbgSetZone(HDBGZONE hDbgZone, PDBGZONEINFO pZoneParam)
{
	PZONEINFO pZoneInfo = (PZONEINFO)hDbgZone;

	if (!pZoneInfo)
		return FALSE;
	
	if (lstrcmpA(pZoneInfo->pszModule,pZoneParam->pszModule))
		return FALSE;

	pZoneInfo->ulZoneMask = pZoneParam->ulZoneMask;
	CopyMemory(pZoneInfo->szZoneNames, pZoneParam->szZoneNames,
		(sizeof(CHAR) * MAXNUM_OF_ZONES * MAXSIZE_OF_ZONENAME));
	return(TRUE);
}



/***************************************************************************

	Name      :	NmDbgGetZoneParams

	Purpose   :	

	Parameters:	

	Returns   :	

	Comment   :	

***************************************************************************/
BOOL WINAPI NmDbgGetAllZoneParams(PDBGZONEINFO *plpZoneParam,LPUINT puCnt)
{
	UINT		ui;
	PZONEINFO	pCurZone;

	if ((NULL == plpZoneParam) || (NULL == puCnt))
		return FALSE;
		
	ACQMUTEX(_ghDbgZoneMutex);

	*puCnt = 0;
	for (pCurZone = _gprgZoneInfo, ui=0;
		ui<MAXNUM_OF_MODULES && pCurZone!=NULL;
		ui++,pCurZone++)
	{
	 	if ((pCurZone->bInUse) && (pCurZone->ulSignature == ZONEINFO_SIGN))
		{
			(*puCnt)++;
		}
	}

	*plpZoneParam = _gprgZoneInfo;
	
	RELMUTEX(_ghDbgZoneMutex);
	return TRUE;
}


BOOL WINAPI NmDbgFreeZoneParams(PDBGZONEINFO pZoneParam)
{
	return TRUE;
}


PZONEINFO NMINTERNAL FindZoneForModule(LPCSTR pszModule)
{
	int i;
	PZONEINFO pCurZone;

	for (pCurZone = _gprgZoneInfo,i=0;i<MAXNUM_OF_MODULES && pCurZone!=NULL;i++,pCurZone++)
	{
	 	if ((pCurZone->bInUse) && (pCurZone->ulSignature == ZONEINFO_SIGN)
			&& (!lstrcmpA(pCurZone->pszModule,pszModule)))
		{
			ACQMUTEX(_ghDbgZoneMutex);		
			pCurZone->ulRefCnt++;
			RELMUTEX(_ghDbgZoneMutex);
			return pCurZone;
		}
	}
	return NULL;

}




/***************************************************************************

	Name      :	AllocZoneForModule

	Purpose   :	Allocates the

	Parameters:	

	Returns   :	

	Comment   :	

***************************************************************************/
PZONEINFO NMINTERNAL AllocZoneForModule(LPCSTR pszModule)
{
	int i;
	PZONEINFO pCurZone;
	PZONEINFO pZoneForMod=NULL;

	ACQMUTEX(_ghDbgZoneMutex);
	for (pCurZone = _gprgZoneInfo,i=0;
		(i<MAXNUM_OF_MODULES && pCurZone!=NULL);
		i++,pCurZone++)
	{
	 	if (!(pCurZone->bInUse))
		{
			pCurZone->bInUse = TRUE;
			pCurZone->ulSignature = ZONEINFO_SIGN;
			pCurZone->ulRefCnt = 1;
			lstrcpyA(pCurZone->pszModule, pszModule);
			pZoneForMod = pCurZone;
			break;
		}
	}
	
	RELMUTEX(_ghDbgZoneMutex);
	return(pZoneForMod);

}


VOID NMINTERNAL SetDbgFlags(void)
{
	PTSTR psz;
	RegEntry reDebug(DEBUG_KEY, HKEY_LOCAL_MACHINE);

	_gpDbg->fOutputDebugString = reDebug.GetNumber(REGVAL_DBG_OUTPUT, DEFAULT_DBG_OUTPUT);
	_gpDbg->fWinOutput = reDebug.GetNumber(REGVAL_DBG_WIN_OUTPUT, DEFAULT_DBG_NO_WIN);
	_gpDbg->fFileOutput = reDebug.GetNumber(REGVAL_DBG_FILE_OUTPUT, DEFAULT_DBG_NO_FILE);

	_gpDbg->uShowTime = reDebug.GetNumber(REGVAL_DBG_SHOW_TIME, DBG_FMTTIME_NONE);
	_gpDbg->fShowThreadId = reDebug.GetNumber(REGVAL_DBG_SHOW_THREADID, 0);
	_gpDbg->fShowModule = reDebug.GetNumber(REGVAL_DBG_SHOW_MODULE, 0);

	psz = reDebug.GetString(REGVAL_DBG_FILE);
	if (0 != lstrlen(psz))
	{
		lstrcpyA(_gpDbg->szFile, CUSTRING(psz));
	}
	else
	{
		UINT cchFile;

		cchFile = GetWindowsDirectoryA(_gpDbg->szFile, CCHMAX(_gpDbg->szFile));
		_gpDbg->szFile[cchFile++] = '\\';
		lstrcpyA(_gpDbg->szFile + cchFile, CUSTRING(DEFAULT_DBG_FILENAME));
	}
}


VOID InitZoneMmf(PZONEINFO prgZoneInfo)
{
	ZeroMemory(prgZoneInfo, CBMMFDBG);

	SetDbgFlags();
}


PZONEINFO NMINTERNAL MapDebugZoneArea(void)
{
	PZONEINFO prgZoneInfo = NULL;
	BOOL	  fCreated;
	PSECURITY_DESCRIPTOR    sd = NULL;
	SECURITY_ATTRIBUTES     sa;

	// Obtain a true NULL security descriptor (so if running as a service, user processes can access it)
	
//	InitializeSecurityDescriptor(&sd, SECURITY_DESCRIPTOR_REVISION);
//	SetSecurityDescriptorDacl(&sd, TRUE, NULL, FALSE);  // NULL DACL = wide open

    sd = CreateSd();

	FillMemory(&sa, sizeof(sa), 0);
	sa.nLength = sizeof(sa);
	sa.lpSecurityDescriptor = sd;

	//create a memory mapped object that is backed by paging file	
	_ghDbgZoneMap = CreateFileMapping(INVALID_HANDLE_VALUE, &sa, PAGE_READWRITE,
		0, CBMMFDBG, SZ_DBG_MAPPED_ZONE);

	if (_ghDbgZoneMap)
	{

		fCreated = (0 == GetLastError());
	   	prgZoneInfo = (PZONEINFO) MapViewOfFile(_ghDbgZoneMap, FILE_MAP_READ|FILE_MAP_WRITE, 0,0,0);
	   	if (NULL != prgZoneInfo)
	   	{
	   		// Grab pointer to shared data area
	   		_gpDbg = (PNMDBG) (((PBYTE) prgZoneInfo) + (MAXNUM_OF_MODULES * sizeof(ZONEINFO)));
	   		if (fCreated)
	   			InitZoneMmf(prgZoneInfo);
		}

	}

	if(sd)
	{
		HeapFree(GetProcessHeap(), 0, sd);
	}
	
	return prgZoneInfo;
}


VOID NMINTERNAL UnMapDebugZoneArea(void)
{
	if (_gprgZoneInfo)
	{
		UnmapViewOfFile(_gprgZoneInfo);
		_gprgZoneInfo = NULL;
	}

	ClosePh(&_ghDbgZoneMap);
}


VOID NMINTERNAL InitDbgZone(void)
{
	if (NULL != _gprgZoneInfo)
		return; // already initialized

	_gprgZoneInfo = MapDebugZoneArea();

	// Create log file data
	PSECURITY_DESCRIPTOR    sd = NULL;
	SECURITY_ATTRIBUTES     sa;

	// Obtain a true NULL security descriptor (so if running as a service, user processes can access it)
	
//	InitializeSecurityDescriptor(&sd, SECURITY_DESCRIPTOR_REVISION);
//	SetSecurityDescriptorDacl(&sd, TRUE, NULL, FALSE);  // NULL DACL = wide open
    sd = CreateSd();

	FillMemory(&sa, sizeof(sa), 0);
	sa.nLength = sizeof(sa);
	sa.lpSecurityDescriptor = sd;

	_ghMutexFile = CreateMutex(&sa, FALSE, SZ_DBG_FILE_MUTEX);
	_ghDbgZoneMutex = CreateMutex(&sa, FALSE, SZ_DBG_ZONE_MUTEX);

	if (_gpDbg->fFileOutput)
	{
		HANDLE  hFile;
    	DWORD dw;
    	CHAR sz[MAX_PATH];
		SYSTEMTIME  systime;


    	hFile = CreateFileA(_gpDbg->szFile,
    		GENERIC_WRITE | GENERIC_WRITE, 0, &sa,
    		CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);

    	if (INVALID_HANDLE_VALUE == hFile)
		{
			_gpDbg->fFileOutput = FALSE;
			goto cleanup;
		}

		GetLocalTime(&systime);

		wsprintfA(sz,
	     	"\r\n======== TRACE Started: %hu/%hu/%hu (%hu:%hu)\r\n",
	     	systime.wMonth, systime.wDay, systime.wYear, systime.wHour, systime.wMinute);

		SetFilePointer(hFile, 0, NULL, FILE_END);
		WriteFile(hFile, sz, lstrlenA(sz), &dw, NULL);

		CloseHandle(hFile);
	}

cleanup:
	if (sd)
	{
		HeapFree(GetProcessHeap(), 0, sd);
	}
	
}


///////////////////////////////////////
// Routines for controlling debug output

BOOL WINAPI NmDbgRegisterCtl(HWND hwnd, UINT uDisplayMsg)
{
	if ((NULL == _gpDbg) || (NULL != _gpDbg->hwndCtrl))
		return FALSE;

	_gpDbg->msgDisplay = uDisplayMsg;
	_gpDbg->hwndCtrl = hwnd;
	return TRUE;
}

BOOL WINAPI NmDbgDeregisterCtl(HWND hwnd)
{
	if ((NULL == _gpDbg) || (hwnd != _gpDbg->hwndCtrl))
		return FALSE;

	_gpDbg->hwndCtrl = NULL;
	_gpDbg->msgDisplay = 0;
	return TRUE;
}

BOOL WINAPI NmDbgSetLoggingOptions(HWND hwnd, UINT uOptions)
{
	return FALSE;
}

PNMDBG WINAPI GetPNmDbg(void)
{
	return _gpDbg;
}

VOID WINAPI NmDbgSetZoneFileName(HDBGZONE hZone, LPCSTR pszFile)
{
	PSTR pszZoneFile;

	if (IsBadWritePtr((PVOID) hZone, sizeof(ZONEINFO)))
		return;

	if (((PZONEINFO) hZone)->ulSignature != ZONEINFO_SIGN)
		return;

	pszZoneFile =  &(((PZONEINFO) hZone)->szFile[0]);

	if (NULL == pszFile)
	{
    	*pszZoneFile = '\0';
    }
    else
    {
    	lstrcpynA(pszZoneFile, pszFile, CCHMAX(((PZONEINFO) hZone)->szFile));
    }
}

/*  D B G  C U R R E N T  T I M E  */
/*-------------------------------------------------------------------------
    %%Function: DbgCurrentTime

    Format the current time
-------------------------------------------------------------------------*/
VOID DbgCurrentTime(PCHAR psz)
{
	if (DBG_FMTTIME_TICK == _gpDbg->uShowTime)
	{
		wsprintfA(psz, "[%04X] ", GetTickCount());
	}
	else
	{
		SYSTEMTIME sysTime;
		GetLocalTime(&sysTime);

		switch (_gpDbg->uShowTime)
			{
		default:
		case DBG_FMTTIME_FULL:
			wsprintfA(psz, "[%04d/%02d/%02d %02d:%02d:%02d.%03d] ",
				sysTime.wYear, sysTime.wMonth, sysTime.wDay,
				sysTime.wHour, sysTime.wMinute, sysTime.wSecond, sysTime.wMilliseconds);
			break;
		case DBG_FMTTIME_DAY:
			wsprintfA(psz, "[%02d:%02d:%02d.%03d] ",
				sysTime.wHour, sysTime.wMinute, sysTime.wSecond, sysTime.wMilliseconds);
			break;
			}
	}
}




/*  P S Z  P R I N T F  */
/*-------------------------------------------------------------------------
    %%Function: PszPrintf

	Utility function to wsprintf a string for debug.
-------------------------------------------------------------------------*/
PSTR PszPrintf(PCSTR pszFormat,...)
{
	PSTR psz = (PSTR) LocalAlloc(LMEM_FIXED, MAX_PATH);
	if (NULL != psz)
	{
	    va_list v1;
		va_start(v1, pszFormat);
	    wvsprintfA(psz, pszFormat, v1);
		va_end(v1);
	}
	return psz;
}


/*  D E B U G  T R A P  F N  */
/*-------------------------------------------------------------------------
    %%Function: DebugTrapFn
-------------------------------------------------------------------------*/
VOID NMINTERNAL DebugTrapFn(VOID)
{
	_DbgBreak();
}


VOID DebugPrintfTraceMem(LPCSTR pszFormat,...)
{
    // DO NOTHING
	va_list arglist;

	va_start(arglist, pszFormat);
	va_end(arglist);
}



#endif /* NM_DEBUG - almost the whole file */
/*************************************************************************/


const int RPF_UNKNOWN  = 0;
const int RPF_ENABLED  = 1;
const int RPF_DISABLED = 2;

static int gRpf = RPF_UNKNOWN;
static TCHAR gszRetailOutputFilename[MAX_PATH];    // retail trace filename


/*  F  E N A B L E D  R E T A I L  P R I N T F  */
/*-------------------------------------------------------------------------
    %%Function: FEnabledRetailPrintf

    Return TRUE if retail output is enabled.
-------------------------------------------------------------------------*/
BOOL FEnabledRetailPrintf(VOID)
{
	if (RPF_UNKNOWN == gRpf)
	{
		RegEntry reDebug(DEBUG_KEY, HKEY_LOCAL_MACHINE);
		gRpf = reDebug.GetNumber(REGVAL_RETAIL_LOG, RPF_DISABLED);
		if ((RPF_ENABLED != gRpf) ||
			   (!GetInstallDirectory(gszRetailOutputFilename)) )
		{
			gRpf = RPF_DISABLED;
		}
		else
		{
			lstrcat(gszRetailOutputFilename, RETAIL_LOG_FILENAME);
		}

	}

	return (RPF_ENABLED == gRpf);
}


/*  R E T A I L  P R I N T F  T R A C E  */
/*-------------------------------------------------------------------------
    %%Function: RetailPrintfTrace

    Print retail information to a file
-------------------------------------------------------------------------*/
VOID WINAPI RetailPrintfTrace(LPCSTR pszFormat,...)
{
	HANDLE  hFile;
	va_list v1;
	CHAR    szOutput[1024];

	if (!FEnabledRetailPrintf())
		return;  // Retail output is disabled

	va_start(v1, pszFormat);


#ifdef DEBUG
	// Also use normal output mechanism for debug builds
	_DbgPrintf(NULL, "Retail:PrintfTrace", pszFormat, v1);
#endif

	wvsprintfA(szOutput, pszFormat, v1);

	// Always append the CRLF
	ASSERT(lstrlenA(szOutput) < (CCHMAX(szOutput)-2));
	lstrcatA(szOutput, "\r\n");


	// open a log file for appending. create if does not exist
	hFile = CreateFile(gszRetailOutputFilename, GENERIC_WRITE,
		0, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, (HANDLE)NULL);
	if (hFile != INVALID_HANDLE_VALUE)
	{
		// seek to end of file
		DWORD dw = SetFilePointer(hFile, 0, NULL, FILE_END);
		WriteFile(hFile, szOutput, lstrlenA(szOutput), &dw, NULL);
		CloseHandle(hFile);
	}
	
	va_end(v1);
}



//
// CreateSids
//
// Create 3 Security IDs
//
// Caller must free memory allocated to SIDs on success.
//
// Returns: TRUE if successfull, FALSE if not.
//


BOOL
CreateSids(
    PSID                    *BuiltInAdministrators,
    PSID                    *PowerUsers,
    PSID                    *AuthenticatedUsers
)
{
    //
    // An SID is built from an Identifier Authority and a set of Relative IDs
    // (RIDs).  The Authority of interest to us SECURITY_NT_AUTHORITY.
    //

    SID_IDENTIFIER_AUTHORITY NtAuthority = SECURITY_NT_AUTHORITY;

    //
    // Each RID represents a sub-unit of the authority.  Two of the SIDs we
    // want to build, Local Administrators, and Power Users, are in the "built
    // in" domain.  The other SID, for Authenticated users, is based directly
    // off of the authority.
    //     
    // For examples of other useful SIDs consult the list in
    // \nt\public\sdk\inc\ntseapi.h.
    //

    if (!AllocateAndInitializeSid(&NtAuthority,
                                  2,            // 2 sub-authorities
                                  SECURITY_BUILTIN_DOMAIN_RID,
                                  DOMAIN_ALIAS_RID_ADMINS,
                                  0,0,0,0,0,0,
                                  BuiltInAdministrators)) {

        // error

    } else if (!AllocateAndInitializeSid(&NtAuthority,
                                         2,            // 2 sub-authorities
                                         SECURITY_BUILTIN_DOMAIN_RID,
                                         DOMAIN_ALIAS_RID_POWER_USERS,
                                         0,0,0,0,0,0,
                                         PowerUsers)) {

        // error

        FreeSid(*BuiltInAdministrators);
        *BuiltInAdministrators = NULL;

    } else if (!AllocateAndInitializeSid(&NtAuthority,
                                         1,            // 1 sub-authority
                                         SECURITY_AUTHENTICATED_USER_RID,
                                         0,0,0,0,0,0,0,
                                         AuthenticatedUsers)) {

        // error

        FreeSid(*BuiltInAdministrators);
        *BuiltInAdministrators = NULL;

        FreeSid(*PowerUsers);
        *PowerUsers = NULL;

    } else {
        return TRUE;
    }

    return FALSE;
}


//
// CreateSd
//
// Creates a SECURITY_DESCRIPTOR with specific DACLs.  Modify the code to
// change. 
//
// Caller must free the returned buffer if not NULL.
//

PSECURITY_DESCRIPTOR
CreateSd(
    VOID
)
{
    PSID                    AuthenticatedUsers;
    PSID                    BuiltInAdministrators;
    PSID                    PowerUsers;

    if (!CreateSids(&BuiltInAdministrators,
                    &PowerUsers,
                    &AuthenticatedUsers)) {

        // error

    } else {

        // 
        // Calculate the size of and allocate a buffer for the DACL, we need
        // this value independently of the total alloc size for ACL init.
        //

        PSECURITY_DESCRIPTOR    Sd = NULL;
        ULONG                   AclSize;

        //
        // "- sizeof (ULONG)" represents the SidStart field of the
        // ACCESS_ALLOWED_ACE.  Since we're adding the entire length of the
        // SID, this field is counted twice.
        //

        AclSize = sizeof (ACL) +
            (3 * (sizeof (ACCESS_ALLOWED_ACE) - sizeof (ULONG))) +
            GetLengthSid(AuthenticatedUsers) +
            GetLengthSid(BuiltInAdministrators) +
            GetLengthSid(PowerUsers);

        Sd = (PSECURITY_DESCRIPTOR) HeapAlloc(GetProcessHeap(), 0, SECURITY_DESCRIPTOR_MIN_LENGTH + AclSize);

        if (!Sd) {

            // error

        } else {

            ACL                     *Acl;

            Acl = (ACL *)((BYTE *)Sd + SECURITY_DESCRIPTOR_MIN_LENGTH);

            if (!InitializeAcl(Acl,
                               AclSize,
                               ACL_REVISION)) {

                // error

            } else if (!AddAccessAllowedAce(Acl,
                                            ACL_REVISION,
                                            SYNCHRONIZE | GENERIC_READ,
                                            AuthenticatedUsers)) {

                // Failed to build the ACE granting "Authenticated users"
                // (SYNCHRONIZE | GENERIC_READ) access.

            } else if (!AddAccessAllowedAce(Acl,
                                            ACL_REVISION,
                                            SYNCHRONIZE | GENERIC_READ | GENERIC_WRITE,
                                            PowerUsers)) {

                // Failed to build the ACE granting "Power users"
                // (SYNCHRONIZE | GENERIC_READ | GENERIC_WRITE) access.

            } else if (!AddAccessAllowedAce(Acl,
                                            ACL_REVISION,
                                            GENERIC_ALL,
                                            BuiltInAdministrators)) {

                // Failed to build the ACE granting "Built-in Administrators"
                // GENERIC_ALL access.

            } else if (!InitializeSecurityDescriptor(Sd,
                                                     SECURITY_DESCRIPTOR_REVISION)) {

                // error

            } else if (!SetSecurityDescriptorDacl(Sd,
                                                  TRUE,
                                                  Acl,
                                                  FALSE)) {

                // error

            } else {
                FreeSid(AuthenticatedUsers);
                FreeSid(BuiltInAdministrators);
                FreeSid(PowerUsers);

                return Sd;
            }

            HeapFree(GetProcessHeap(), 0, Sd);
        }

        FreeSid(AuthenticatedUsers);
        FreeSid(BuiltInAdministrators);
        FreeSid(PowerUsers);
    }

    return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\nmutil\hash.cpp ===
// HASH.CPP
//
// Hash utility functions for use in NetMeeting components.

#include "precomp.h"
#include <oprahcom.h>
#include "nb30.h"
#include "regentry.h"
#include "confreg.h"


CHash::CHash() : m_hProv(0), m_hHash(0), m_pbHashedData(NULL), m_cbHashedData(0), m_fReady(FALSE)
{
	if (!CryptAcquireContext(&m_hProv, NULL, MS_DEF_PROV, PROV_RSA_FULL, CRYPT_MACHINE_KEYSET)) 
	{
		// Create new if can not get default 
		if (!CryptAcquireContext(&m_hProv, NULL, MS_DEF_PROV, PROV_RSA_FULL, CRYPT_NEWKEYSET | CRYPT_MACHINE_KEYSET)) 
		{
			goto ErrorExit;	
		}
	}

	m_fReady = TRUE;
	return;
ErrorExit:
	m_fReady = FALSE;
}


CHash::~CHash()
{
	if (m_pbHashedData) delete []m_pbHashedData;
	CryptAcquireContext(&m_hProv, NULL, MS_DEF_PROV, PROV_RSA_FULL, CRYPT_DELETEKEYSET | CRYPT_MACHINE_KEYSET);
	if (m_hHash) CryptDestroyHash(m_hHash);
	if (m_hProv) CryptReleaseContext(m_hProv, 0);
}

DWORD CHash::GetHashedData(PBYTE pbData, DWORD cbData, void ** ppvHashedData)
{
	ASSERT(NULL != ppvHashedData);
	ASSERT(NULL != pbData);
	DWORD dwCount;
	RegEntry re(WINDOWS_KEY, HKEY_LOCAL_MACHINE);

	if (FALSE == m_fReady)
	{
		goto ErrorExit;
	}
	if (0 == cbData) {
		goto ErrorExit;
	}
	if (m_hHash) CryptDestroyHash(m_hHash);
	if (!CryptCreateHash(m_hProv, CALG_MD5, 0, 0, &m_hHash))
	{
		ERROR_OUT(("CHash::GetHashData() - Error creating crypt hash object."));
		goto ErrorExit;
	}
	if (!CryptHashData(m_hHash, pbData, cbData, 0))
	{
		ERROR_OUT(("CHash::GetHashData() - Error hashing data."));
		goto ErrorExit;
	}

	if (!CryptHashData(m_hHash, (PBYTE) re.GetString(REGVAL_REGISTERED_USER),
			lstrlen(re.GetString(REGVAL_REGISTERED_USER)), 0))
	{
		ERROR_OUT(("CHash::GetHashData() - Error hashing extra data."));
		goto ErrorExit;
	}

	NCB ncb;
	BYTE buf[sizeof(NCB) + 256];

	ZeroMemory ( &ncb, sizeof(ncb));
	ncb.ncb_command = NCBASTAT;
	ncb.ncb_buffer = buf;
	ncb.ncb_length = sizeof(buf);
	memcpy ( (PBYTE)ncb.ncb_callname, (PBYTE)"*              ", NCBNAMSZ );

	if ( NRC_GOODRET == Netbios(&ncb) )
	{
		//
		// NOTE: the buffer filled by the Netbios ASTAT command starts
		// with a 6-byte encoded adapter address: just use the raw
		// buffer rather than casting back to PBYTE
		//

		if (!CryptHashData(m_hHash, buf, 6, 0 ))
		{
			ERROR_OUT(("CHash::GetHashData() - Error hashing ncb data."));
			goto ErrorExit;
		}
	}
	else
	{
		WARNING_OUT(("CHash::GetHashData: Netbios failed %x", ncb.ncb_retcode));
	}
	
	dwCount = sizeof(DWORD);
	if (!CryptGetHashParam(m_hHash, HP_HASHSIZE, (BYTE *)&m_cbHashedData, &dwCount, 0)) 
	{
		goto ErrorExit;
	}
	if (m_pbHashedData) delete [] m_pbHashedData;
	if (NULL == (m_pbHashedData = new BYTE[m_cbHashedData]))
	{
		goto ErrorExit;
	}
	if (!CryptGetHashParam(m_hHash, HP_HASHVAL, m_pbHashedData, &m_cbHashedData, 0)) {
		goto ErrorExit;
	}
	*ppvHashedData = m_pbHashedData;
	return m_cbHashedData;
ErrorExit:
	return 0;     // Hash data failed 
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\nmutil\hextostr.cpp ===
// HEXTOSTR.CPP
//
// Utility functions to convert hexadecimal numbers into equivalent string
// representations.
//
// Note:  These functions are in their own file, rather than in STRUTIL.CPP,
// because they use a const array.  The current implementation of the linker
// pulls this array into binaries if they use any function in the source file,
// not just the functions which reference this array.

#include "precomp.h"
#include <strutil.h>


const CHAR rgchHexNumMap[] =
{
	'0', '1', '2', '3', '4', '5', '6', '7',
	'8', '9', 'A', 'B', 'C', 'D', 'E', 'F'
};

//
// QWordToHexString()
//
// Converts a ULARGE_INTEGER to an ANSI string (not prefixed with 0x or 0X)
//
// NOTE: pszString must point to a buffer of at least CCHMAX_ULARGE_INTEGER chars
//
// Returns the number of characters written (not including the NULL terminator)

int NMINTERNAL QWordToHexStringA(ULARGE_INTEGER qw, LPSTR pszString)
{
	ASSERT(!IsBadWritePtr(pszString, sizeof(*pszString)*CCHMAX_HEX_ULARGE_INTEGER));

	LPSTR pszCurrent = pszString;
	DWORD dwQwParts[] = {qw.HighPart, qw.LowPart};
	int i;

	// Walk the QWORD four bits at a time, mapping them to the appropriate
	// char and storing them in the caller-supplied buffer.

	// We loop through the QWORD twice, working on each DWORD separately
	for (i = 0; i < ARRAY_ELEMENTS(dwQwParts); i++)
	{
		DWORD dwQwPart = dwQwParts[i];

		// Optimization:  We only need to